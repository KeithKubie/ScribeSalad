WEBVTT
Kind: captions
Language: en

00:00:03.080 --> 00:00:03.400
MICHAEL BOLIN: Hello.

00:00:03.400 --> 00:00:04.550
Good afternoon.

00:00:04.550 --> 00:00:05.990
Welcome to, I guess,
what is the last

00:00:05.990 --> 00:00:08.170
session of Google I/O.

00:00:08.170 --> 00:00:11.070
I'm here to talk to you about
a topic that's near and dear

00:00:11.070 --> 00:00:13.570
to my heart, which is JavaScript
programming in the

00:00:13.570 --> 00:00:15.920
large with Closure tools.

00:00:15.920 --> 00:00:17.170
My name's Michael Bolin.

00:00:17.170 --> 00:00:20.170
As you can see I have my
SpeakerMeter URL up there if

00:00:20.170 --> 00:00:21.250
you want to give me feedback.

00:00:21.250 --> 00:00:25.430
I do talk about Closure a bit,
so feedback would be great.

00:00:25.430 --> 00:00:28.540
But let's get started.

00:00:28.540 --> 00:00:31.180
So first of all, something I
would actually like to clarify

00:00:31.180 --> 00:00:35.990
is who am I and why did
they let me up here?

00:00:35.990 --> 00:00:38.780
Because actually, I don't
work at Google.

00:00:38.780 --> 00:00:39.940
I used to work at Google.

00:00:39.940 --> 00:00:42.620
And while I was there I worked
on Google Calendar.

00:00:42.620 --> 00:00:44.600
I did a lot of the front-end
development for that.

00:00:44.600 --> 00:00:46.870
And then also then the majority
of the front-end

00:00:46.870 --> 00:00:49.390
development on Google Tasks.

00:00:49.390 --> 00:00:52.266
And then post-Google I wrote
a book called Closure:The

00:00:52.266 --> 00:00:53.410
Definitive Guide.

00:00:53.410 --> 00:00:56.220
Maybe some you have it.

00:00:56.220 --> 00:00:59.590
And basically around
the time when--

00:00:59.590 --> 00:01:01.720
about a year and a half ago--
when Google Open Sourced

00:01:01.720 --> 00:01:04.090
Closure, I just felt very
strongly that this is a really

00:01:04.090 --> 00:01:05.340
important toolkit.

00:01:05.340 --> 00:01:08.990
In terms of moving the web
forward, in terms of enabling

00:01:08.990 --> 00:01:12.060
people to make really fast
web applications.

00:01:12.060 --> 00:01:13.990
And that's what makes the web
better for everyone, when

00:01:13.990 --> 00:01:17.230
people can build higher
quality applications.

00:01:17.230 --> 00:01:20.640
So I've done a bit of work in
the realm of doing some large

00:01:20.640 --> 00:01:22.020
JavaScript development.

00:01:22.020 --> 00:01:25.660
And that's what we're going
to talk about today.

00:01:25.660 --> 00:01:27.760
So first I should clarify--

00:01:27.760 --> 00:01:30.120
or at least give some sort of
definition-- for what I mean

00:01:30.120 --> 00:01:32.130
by programming in the large.

00:01:32.130 --> 00:01:32.960
Just to throw out--

00:01:32.960 --> 00:01:36.440
I'm just going to make up some
numbers-- but more properties,

00:01:36.440 --> 00:01:37.950
let's say 30,000
lines of code.

00:01:37.950 --> 00:01:41.260
Let's say that's programming
in the large.

00:01:41.260 --> 00:01:43.090
Another aspect is having
a large team.

00:01:43.090 --> 00:01:44.920
Once you have more people--

00:01:44.920 --> 00:01:46.230
because you need more people
to build a bigger

00:01:46.230 --> 00:01:47.270
application--

00:01:47.270 --> 00:01:49.140
now you also have this
communication overhead that

00:01:49.140 --> 00:01:50.220
you have to think about.

00:01:50.220 --> 00:01:52.400
I think that this is really
important in terms of

00:01:52.400 --> 00:01:55.200
JavaScript because a lot of
people are used to just

00:01:55.200 --> 00:01:58.520
copying and pasting some code
they find on the web to

00:01:58.520 --> 00:02:00.940
decorate some page that they
have and that's kind of what

00:02:00.940 --> 00:02:03.540
their impression of what
JavaScript programming is.

00:02:03.540 --> 00:02:06.550
And they don't really have an
idea of how to get to the 10

00:02:06.550 --> 00:02:10.460
lines of code they copied to
the 30,000-line JavaScript

00:02:10.460 --> 00:02:12.700
application.

00:02:12.700 --> 00:02:15.500
And another aspect of this is
a longer development cycle.

00:02:15.500 --> 00:02:18.570
This is significant in terms
of, if you work at a larger

00:02:18.570 --> 00:02:21.110
company people may roll
on and off your team.

00:02:21.110 --> 00:02:24.260
They're going to have to be able
to pick up and dive into

00:02:24.260 --> 00:02:26.910
a large code base that they're
not familiar with.

00:02:26.910 --> 00:02:30.130
Also over a six-month period,
you, yourself, may not even

00:02:30.130 --> 00:02:32.370
remember what the code that
you did six months ago.

00:02:32.370 --> 00:02:35.000
So it needs to be organized.

00:02:35.000 --> 00:02:37.200
You need to have some way of
laying it out such that you

00:02:37.200 --> 00:02:39.910
can come back to it, anyone else
can come into it because

00:02:39.910 --> 00:02:43.970
this is what's going to enable
you to build more complex and

00:02:43.970 --> 00:02:45.070
interesting applications.

00:02:45.070 --> 00:02:47.150
Not that everything needs
to be complex.

00:02:47.150 --> 00:02:48.360
Absolutely not.

00:02:48.360 --> 00:02:50.900
But there's a certain class of
applications that are really

00:02:50.900 --> 00:02:53.570
interesting that we want to
see brought to the web.

00:02:53.570 --> 00:02:56.750
And for that, it just takes a
different, you need to take a

00:02:56.750 --> 00:02:59.280
different tack in terms of how
you organize your team and

00:02:59.280 --> 00:03:01.180
organize your code to
make sure you can

00:03:01.180 --> 00:03:02.650
make interesting progress.

00:03:02.650 --> 00:03:05.290
So this the area that I'm
calling JavaScript programming

00:03:05.290 --> 00:03:05.940
in the large.

00:03:05.940 --> 00:03:08.530
And that's where, I think,
Closure really fits in and

00:03:08.530 --> 00:03:10.490
speaks to that.

00:03:10.490 --> 00:03:12.670
So today if you wanted to
build a rich internet

00:03:12.670 --> 00:03:16.040
application, or an RIA, a lot
of these are thought of a

00:03:16.040 --> 00:03:18.110
single-page applications.

00:03:18.110 --> 00:03:21.420
Such as Gmail and Calendar,
where you go, you log in, you

00:03:21.420 --> 00:03:24.300
actually don't really reload
the page or change URLs.

00:03:24.300 --> 00:03:26.990
Maybe the fragment changes and
it keeps track of your state.

00:03:26.990 --> 00:03:31.250
But you load a large bundle of
JavaScript at the beginning.

00:03:31.250 --> 00:03:33.540
Perhaps you navigate through
the app, exercise certain

00:03:33.540 --> 00:03:35.750
features, more JavaScript
gets loaded.

00:03:35.750 --> 00:03:38.170
But basically you're using
this one thing where

00:03:38.170 --> 00:03:41.860
everything is in memory
on that single page.

00:03:41.860 --> 00:03:44.580
So if you wanted to create
this rich experience,

00:03:44.580 --> 00:03:47.040
something that's more akin to a
desktop app, obviously we're

00:03:47.040 --> 00:03:50.250
doing a lot of stuff with
HTML5 right now.

00:03:50.250 --> 00:03:53.510
But let's think about what some
of your options would be.

00:03:53.510 --> 00:03:56.890
So the first one is use a
plugin, such as Java or Flash.

00:03:56.890 --> 00:04:00.370
Some people may remember Java
applets, which were going to

00:04:00.370 --> 00:04:02.590
be the greatest thing and they
were going to save the web and

00:04:02.590 --> 00:04:04.710
we were going to be able to
write all our things in Swing

00:04:04.710 --> 00:04:06.600
and they were all going to be
purple and gray and it was

00:04:06.600 --> 00:04:08.510
going to be great.

00:04:08.510 --> 00:04:11.150
But the problem was, it took
like half an hour or something

00:04:11.150 --> 00:04:14.190
for that Java plugin to load and
you were looking at that

00:04:14.190 --> 00:04:15.520
coffee cup.

00:04:15.520 --> 00:04:18.100
Assuming you could even figure
out how to download it.

00:04:18.100 --> 00:04:18.920
And then Flash.

00:04:18.920 --> 00:04:23.890
Flash is obviously a lot
snappier than Java.

00:04:23.890 --> 00:04:25.320
And is very popular today.

00:04:25.320 --> 00:04:28.300
Obviously when YouTube first
came out, I don't know if

00:04:28.300 --> 00:04:30.290
there would have been a YouTube
if there weren't a

00:04:30.290 --> 00:04:31.360
Flash plugin.

00:04:31.360 --> 00:04:34.120
But certainly Apple has thrown
down the gauntlet.

00:04:34.120 --> 00:04:36.740
An iOS Flash is a non-starter.

00:04:36.740 --> 00:04:40.080
So if you want to have a code
base that you can use across

00:04:40.080 --> 00:04:42.570
different devices and supporting
iOS is important to

00:04:42.570 --> 00:04:48.240
you, than Flash is not really
a reasonable option.

00:04:48.240 --> 00:04:52.040
Another option, which is good
for building an RIA, is GWT.

00:04:52.040 --> 00:04:53.210
Obviously I'm sure there's
a lot of people

00:04:53.210 --> 00:04:55.250
here who use GWT.

00:04:55.250 --> 00:04:56.340
Certainly a lot of people at
this conference have been

00:04:56.340 --> 00:04:58.920
talking a lot about GWT.

00:04:58.920 --> 00:05:01.950
And so, if you're familiar with
it, the idea is basically

00:05:01.950 --> 00:05:03.860
that you write your application
in a language

00:05:03.860 --> 00:05:04.830
that's more familiar to you.

00:05:04.830 --> 00:05:07.190
In the case of GWT, it's Java.

00:05:07.190 --> 00:05:12.940
And then the tool takes care of
translating your Java code

00:05:12.940 --> 00:05:13.910
into JavaScript.

00:05:13.910 --> 00:05:15.600
And certainly a lot of people
have written a lot of

00:05:15.600 --> 00:05:17.540
interesting things with GWT.

00:05:17.540 --> 00:05:21.140
Even this morning, I believe,
the Angry Birds folks said

00:05:21.140 --> 00:05:22.920
that their stuff is
written in GWT.

00:05:22.920 --> 00:05:25.700
So clearly you can get
a lot done using it.

00:05:25.700 --> 00:05:28.650
But at the same time, there's
actually a lot of really great

00:05:28.650 --> 00:05:32.070
things that JavaScript has that
Java doesn't have. Such

00:05:32.070 --> 00:05:35.460
as first-order functions, is a
really big one and a really

00:05:35.460 --> 00:05:37.420
natural use of Closure's.

00:05:37.420 --> 00:05:40.470
Passing a function around as a
parameter in Java is actually

00:05:40.470 --> 00:05:42.590
incredibly awkward.

00:05:42.590 --> 00:05:45.660
Yet it's also very
straight-forward when you do

00:05:45.660 --> 00:05:46.780
it in JavaScript.

00:05:46.780 --> 00:05:49.980
Similarly there's APIs of the
browser, with HTML5, new

00:05:49.980 --> 00:05:51.450
things are coming out
all the time.

00:05:51.450 --> 00:05:55.160
In JavaScript you can use these
things very directly.

00:05:55.160 --> 00:05:58.860
In GWT you need to wrap them in
JSNI or someone else has to

00:05:58.860 --> 00:06:00.280
do that work for you.

00:06:00.280 --> 00:06:03.180
So if you really care about
getting close to the mettle of

00:06:03.180 --> 00:06:09.200
the browser, so to speak, GWT
has ways to get to it.

00:06:09.200 --> 00:06:11.760
But it's not as natural as if
you were using the language

00:06:11.760 --> 00:06:13.230
that the browser speaks,
which is JavaScript.

00:06:16.760 --> 00:06:19.850
The way that I propose, and
have built, rich internet

00:06:19.850 --> 00:06:22.980
applications is writing
lots of JavaScript.

00:06:22.980 --> 00:06:25.530
Because it is awesome.

00:06:25.530 --> 00:06:27.120
And when I say lots,
I do mean lots.

00:06:27.120 --> 00:06:30.270
The last project I worked on
we wrote 70,000 lines of

00:06:30.270 --> 00:06:32.920
JavaScript was our
application.

00:06:32.920 --> 00:06:34.775
And we did it using Closure.

00:06:37.620 --> 00:06:40.950
As I mentioned, JavaScript has
first-order functions.

00:06:40.950 --> 00:06:44.225
It also has regular expression
literal, similar to Perl.

00:06:44.225 --> 00:06:49.010
It has a prototype- based
inheritance mechanism that

00:06:49.010 --> 00:06:50.640
Java does have and other
languages don't have. It

00:06:50.640 --> 00:06:52.255
actually took that-- it was
inspired by this other

00:06:52.255 --> 00:06:53.660
language called Self.

00:06:53.660 --> 00:06:57.000
So there's a lot of neat things
that you get when you

00:06:57.000 --> 00:06:59.640
write in JavaScript, in
addition to being

00:06:59.640 --> 00:07:00.390
close to the browser.

00:07:00.390 --> 00:07:03.020
But also as a language, it
is a very good language.

00:07:03.020 --> 00:07:05.840
People have bad impressions of
it because they only associate

00:07:05.840 --> 00:07:08.300
it with browser programming,
which is traditionally

00:07:08.300 --> 00:07:10.700
fundamentally difficult
because of things like

00:07:10.700 --> 00:07:14.780
Internet Explorer 6 and all the
differences in the DOM.

00:07:14.780 --> 00:07:16.870
It's the DOM API that's actually
the source of most

00:07:16.870 --> 00:07:18.170
people's frustration.

00:07:18.170 --> 00:07:21.790
But JavaScript the language
really takes more of the heat,

00:07:21.790 --> 00:07:25.050
whereas it should not.

00:07:25.050 --> 00:07:27.340
In case you think I'm the only
person who is crazy, who

00:07:27.340 --> 00:07:30.160
thinks we should write a lot
of JavaScript, all these

00:07:30.160 --> 00:07:33.885
applications on the bottom that
Google has written, they

00:07:33.885 --> 00:07:34.900
are in JavaScript.

00:07:34.900 --> 00:07:38.480
A lot of people assume that
the Google Web Toolkit is

00:07:38.480 --> 00:07:41.080
responsible for everything
that Google produces.

00:07:41.080 --> 00:07:43.380
That's not the case.

00:07:43.380 --> 00:07:46.590
Part of it was also just
due to history.

00:07:46.590 --> 00:07:48.830
Some of these applications had
already been built up and were

00:07:48.830 --> 00:07:51.140
going and rewriting
it in GWT--

00:07:51.140 --> 00:07:52.140
doesn't seem like
a good option.

00:07:52.140 --> 00:07:57.130
But also, sometimes there
are just performance

00:07:57.130 --> 00:07:59.300
characteristics or metrics
that we wanted these

00:07:59.300 --> 00:08:00.330
applications to meet.

00:08:00.330 --> 00:08:02.570
And it just made a lot of
sense to write them in

00:08:02.570 --> 00:08:04.490
JavaScript.

00:08:04.490 --> 00:08:08.610
And all these are basically
powered by Closure.

00:08:08.610 --> 00:08:12.840
So at the same time I'm telling
you that you should

00:08:12.840 --> 00:08:16.280
write a lot of JavaScript, yet
in some ways JavaScript tries

00:08:16.280 --> 00:08:20.110
to defeat programming
in the large.

00:08:20.110 --> 00:08:23.620
So unlike Java, there's
no namespaces.

00:08:23.620 --> 00:08:26.440
There's no import statement that
is part of the language

00:08:26.440 --> 00:08:27.430
in JavaScript.

00:08:27.430 --> 00:08:30.440
And namespaces are important
because as you build up a lot

00:08:30.440 --> 00:08:32.400
of code, you need some
way to modularize it.

00:08:32.400 --> 00:08:34.190
You need some way
to organize it.

00:08:34.190 --> 00:08:37.900
Namespaces turn out to be a
pretty good mechanism for

00:08:37.900 --> 00:08:39.830
doing that sort of thing.

00:08:39.830 --> 00:08:43.419
Visibility controls are another
important point.

00:08:43.419 --> 00:08:45.640
In particular, in terms of
object oriented programming

00:08:45.640 --> 00:08:48.110
you have-- in Java you have
the private public

00:08:48.110 --> 00:08:49.450
protected key words.

00:08:49.450 --> 00:08:52.950
You're saying, this data should
only be seen by the

00:08:52.950 --> 00:08:54.820
methods that belong
to this class.

00:08:54.820 --> 00:08:56.740
This also is helpful in
programming in the large.

00:08:56.740 --> 00:08:59.830
Because then this further helps
you modularize your

00:08:59.830 --> 00:09:01.260
code, modularize data.

00:09:01.260 --> 00:09:02.820
And it's enforced
by the compiler.

00:09:02.820 --> 00:09:05.860
So you get some static
checking about this

00:09:05.860 --> 00:09:11.200
organization and you don't have
to manage it yourself.

00:09:11.200 --> 00:09:13.600
Similarly, having
a type system.

00:09:13.600 --> 00:09:17.820
A lot of people like the idea
that JavaScript is, what many

00:09:17.820 --> 00:09:18.780
people call, duck type.

00:09:18.780 --> 00:09:21.420
That if you get an object and it
has the properties that you

00:09:21.420 --> 00:09:24.730
want, then you can use it the
way that you want to.

00:09:24.730 --> 00:09:30.390
As opposed to having to create
an explicit class and having

00:09:30.390 --> 00:09:33.920
methods with strongly typed
signatures saying, this takes

00:09:33.920 --> 00:09:36.810
a string, this takes a number
and the compiler won't let you

00:09:36.810 --> 00:09:40.690
do anything that violates
that contract.

00:09:40.690 --> 00:09:43.490
But as you write more and more
JavaScript and you just pick

00:09:43.490 --> 00:09:45.160
up people's code and you're
just trying to look at the

00:09:45.160 --> 00:09:47.850
interface, this can actually
be kind of difficult.

00:09:47.850 --> 00:09:50.380
I, myself, find this someone
troubling when I look at

00:09:50.380 --> 00:09:51.510
Python documentation.

00:09:51.510 --> 00:09:53.440
Python's also both not
strongly typed.

00:09:53.440 --> 00:09:57.920
A lot of times what the method
does would be more obvious if

00:09:57.920 --> 00:10:01.510
I just knew the type signature
that were associated with it.

00:10:01.510 --> 00:10:03.520
So as you write more
and more code this

00:10:03.520 --> 00:10:04.340
can become a problem.

00:10:04.340 --> 00:10:07.070
It's also related to
refactoring, which I will

00:10:07.070 --> 00:10:09.840
probably get into later.

00:10:09.840 --> 00:10:11.100
Also static checking.

00:10:11.100 --> 00:10:14.650
So this is related to having
a type system.

00:10:14.650 --> 00:10:17.210
When you have a type system and
you have a compiler that

00:10:17.210 --> 00:10:20.590
enforces types that means at
compile time, the compiler can

00:10:20.590 --> 00:10:24.090
help you find a whole class of
errors that you might not find

00:10:24.090 --> 00:10:25.640
while running your problem.

00:10:25.640 --> 00:10:30.310
But similarly if you have an
error in an else branch--

00:10:30.310 --> 00:10:32.040
I'm sure many Python
programmers

00:10:32.040 --> 00:10:34.500
have hit this problem--

00:10:34.500 --> 00:10:36.980
or any branch of code, I should
say, where it's not

00:10:36.980 --> 00:10:38.070
executed regularly.

00:10:38.070 --> 00:10:40.940
Or say some sort of error
handling code.

00:10:40.940 --> 00:10:43.390
Because obviously you want to
test with good inputs and no

00:10:43.390 --> 00:10:45.880
one ever tests their
bad inputs.

00:10:45.880 --> 00:10:48.450
Because why would we ever
have bad inputs?

00:10:48.450 --> 00:10:51.260
But that people don't find out
until run time until someone

00:10:51.260 --> 00:10:53.280
finally happens to trigger
that error.

00:10:53.280 --> 00:10:55.200
There's a large class pf
problems that happen there

00:10:55.200 --> 00:10:57.800
that could be checked statically
if there were a

00:10:57.800 --> 00:11:00.347
compiler or some sort of other
static analysis tool to

00:11:00.347 --> 00:11:02.920
perform that checking for you.

00:11:02.920 --> 00:11:05.620
Again programming in the large,
as your code gets

00:11:05.620 --> 00:11:08.580
bigger and bigger it's really
hard to manage all these

00:11:08.580 --> 00:11:09.810
things yourself.

00:11:09.810 --> 00:11:12.220
Yes, you should be writing
unit tests or integration

00:11:12.220 --> 00:11:14.940
tests that actually exercise
all these code paths.

00:11:14.940 --> 00:11:18.260
But the reality is that most
people don't, assuming they

00:11:18.260 --> 00:11:20.470
write tests at all.

00:11:20.470 --> 00:11:22.800
And this last one is not having

00:11:22.800 --> 00:11:24.640
built-in support for templates.

00:11:24.640 --> 00:11:28.340
So in JavaScript, or any web
application, you're usually

00:11:28.340 --> 00:11:30.950
building up large
strings of HTML.

00:11:30.950 --> 00:11:34.980
Because this is the thing that
you use to create your user

00:11:34.980 --> 00:11:38.780
interface in a web browser,
is basically HTML and CSS.

00:11:38.780 --> 00:11:41.450
Unfortunately in JavaScript,
we don't

00:11:41.450 --> 00:11:43.140
have multi-line strings.

00:11:43.140 --> 00:11:44.880
Yet we want to create large DOM

00:11:44.880 --> 00:11:46.510
structures defined in HTML.

00:11:49.110 --> 00:11:51.060
And then we would really like
to have placeholders, so we

00:11:51.060 --> 00:11:52.890
could basically have
a template and

00:11:52.890 --> 00:11:54.460
substitute things in.

00:11:54.460 --> 00:11:56.530
If you have a repeated row
in a table, right?

00:11:56.530 --> 00:11:59.090
You'd like that row to be a
template that you can just

00:11:59.090 --> 00:12:03.310
reuse and pump out the same
structure HTML but with

00:12:03.310 --> 00:12:04.500
different variables.

00:12:04.500 --> 00:12:06.980
And unfortunately the way
strings work in JavaScript

00:12:06.980 --> 00:12:10.150
today, it's not so
straightforward to do that

00:12:10.150 --> 00:12:11.930
sort of thing.

00:12:11.930 --> 00:12:15.110
So these are some of the ways
that JavaScript tries to

00:12:15.110 --> 00:12:19.090
defeat or makes it harder to do
development in the large.

00:12:23.470 --> 00:12:26.030
There's a suite of tools Open
Sourced by Google called the

00:12:26.030 --> 00:12:26.810
Closure tools.

00:12:26.810 --> 00:12:29.640
And that's what the crux
of my talk is about.

00:12:29.640 --> 00:12:34.780
And these tools are useful
in general in JavaScript

00:12:34.780 --> 00:12:35.470
development.

00:12:35.470 --> 00:12:38.060
But I think their true strength
is when you start

00:12:38.060 --> 00:12:40.250
doing JavaScript development
in the large.

00:12:40.250 --> 00:12:42.430
And that, obviously,
you should start

00:12:42.430 --> 00:12:43.750
with a small project.

00:12:43.750 --> 00:12:46.010
It's not a good idea to start
with a big project.

00:12:46.010 --> 00:12:49.670
So at the outset you may not see
the value in these tools.

00:12:49.670 --> 00:12:52.360
But you might then get to a
point where you really wish

00:12:52.360 --> 00:12:54.530
you had been using them.

00:12:54.530 --> 00:12:57.170
So let's look at
what they are.

00:12:57.170 --> 00:12:59.490
The first one is the
Closure Library.

00:12:59.490 --> 00:13:04.550
The Closure Library is a library
of common utilities,

00:13:04.550 --> 00:13:08.260
widgets, written
in JavaScript.

00:13:08.260 --> 00:13:10.580
It works across browsers.

00:13:10.580 --> 00:13:14.170
It works back to IE6.

00:13:14.170 --> 00:13:16.650
So it's analogous to your
jQueries queries, your

00:13:16.650 --> 00:13:19.140
MooTools, your YUI all
that sort of thing.

00:13:19.140 --> 00:13:21.830
All these things are JavaScript
libraries that try

00:13:21.830 --> 00:13:24.830
to abstract away browser
differences from you and

00:13:24.830 --> 00:13:29.130
provide a lot of common
functionality.

00:13:29.130 --> 00:13:31.600
The next tool is Closure
Templates.

00:13:31.600 --> 00:13:34.800
So Closure Templates is
a templating language.

00:13:34.800 --> 00:13:36.790
Because we didn't have enough
templating languages.

00:13:36.790 --> 00:13:39.610
But Closure Templates does
have some unique

00:13:39.610 --> 00:13:42.250
and important features.

00:13:42.250 --> 00:13:44.500
And you can use it to--

00:13:44.500 --> 00:13:47.420
as I mentioned, it's hard to
build up strings of HTML in

00:13:47.420 --> 00:13:49.320
JavaScript using
raw JavaScript.

00:13:49.320 --> 00:13:52.150
But having a separate template
language actually makes this a

00:13:52.150 --> 00:13:55.940
lot easier and also less
error-prone, as we'll see.

00:13:55.940 --> 00:13:59.312
And the third tool is the
Closure Compiler.

00:13:59.312 --> 00:14:02.660
The Closure Compiler is
a JavaScript minifier.

00:14:02.660 --> 00:14:05.880
So that means that you may write
your JavaScript full of

00:14:05.880 --> 00:14:10.980
comments and white space that
don't actually contribute to

00:14:10.980 --> 00:14:12.560
the behavior of your program.

00:14:12.560 --> 00:14:15.610
But your users, who download the
JavaScript when they visit

00:14:15.610 --> 00:14:19.940
your site, they're paying the
penalty, so to speak, of

00:14:19.940 --> 00:14:21.710
download time and parse
time when you

00:14:21.710 --> 00:14:23.010
have these extra bytes.

00:14:23.010 --> 00:14:27.860
And so you want to use a
JavaScript minifier to reduce

00:14:27.860 --> 00:14:29.800
the size of your JavaScript
code.

00:14:29.800 --> 00:14:31.020
This saves your bandwidth.

00:14:31.020 --> 00:14:32.990
It saves the users' bandwidth.

00:14:32.990 --> 00:14:35.820
It starts up-- and the users'
application will start up

00:14:35.820 --> 00:14:39.120
faster because there's less
JavaScript to parse and it got

00:14:39.120 --> 00:14:43.650
there quicker because it
was a smaller file.

00:14:43.650 --> 00:14:45.090
There are other minifiers
out there.

00:14:45.090 --> 00:14:47.800
There's like JSMIN
and UglifyJS.

00:14:47.800 --> 00:14:50.780
But most of them only focus on
minification, whereas the

00:14:50.780 --> 00:14:53.780
Closure compiler also does
add status checking.

00:14:53.780 --> 00:14:57.390
And we'll see more of that
in a bit as well.

00:14:57.390 --> 00:14:59.810
The most important thing, I
think, about the Closure tools

00:14:59.810 --> 00:15:03.030
that people don't realize, is
that the Library, Templates,

00:15:03.030 --> 00:15:05.000
and the Compiler, they're
all independent tools.

00:15:05.000 --> 00:15:07.600
You can actually use one of the
three on any JavaScript

00:15:07.600 --> 00:15:09.920
project if that's all you're
interested in.

00:15:09.920 --> 00:15:11.740
But they are, by far
and away, most

00:15:11.740 --> 00:15:14.290
compelling when used together.

00:15:14.290 --> 00:15:16.550
The results that you get, and
the improvement in your code,

00:15:16.550 --> 00:15:18.620
are just much more compelling
when you put all these three

00:15:18.620 --> 00:15:19.650
things together.

00:15:19.650 --> 00:15:24.350
And I think that this is another
area where Closure is

00:15:24.350 --> 00:15:26.720
far beyond a lot of the
other offerings.

00:15:26.720 --> 00:15:30.790
There is jQuery, there Is
Mustache.js there is JSMin.

00:15:30.790 --> 00:15:34.780
There are analogs for all
three of these tools.

00:15:34.780 --> 00:15:37.370
So I can't claim that Closure
invented all these ideas.

00:15:37.370 --> 00:15:40.800
However I think that most of
these other projects are done

00:15:40.800 --> 00:15:42.150
kind of in a silo.

00:15:42.150 --> 00:15:45.820
Whereas the Closure tools are
done knowing the strength of

00:15:45.820 --> 00:15:46.770
each other tool in mind.

00:15:46.770 --> 00:15:48.975
And that's why it really helps
to put them together.

00:15:56.860 --> 00:15:58.990
To really understand and
appreciate the benefit of

00:15:58.990 --> 00:16:01.200
Closure Tools, first I think we
should look at some of the

00:16:01.200 --> 00:16:03.670
problems that JavaScript
developers face today.

00:16:03.670 --> 00:16:06.190
And maybe you don't even realize
that you're having

00:16:06.190 --> 00:16:08.130
this problem or that
you should be

00:16:08.130 --> 00:16:09.640
doing something better.

00:16:09.640 --> 00:16:11.300
So here's the first. People--

00:16:11.300 --> 00:16:14.450
I don't know if anyone's used
the Library Prototype JS.

00:16:14.450 --> 00:16:16.340
Prototype is a JavaScript
library that

00:16:16.340 --> 00:16:18.870
goes way, way back.

00:16:18.870 --> 00:16:23.240
And one of its claims to
fame was its terseness.

00:16:23.240 --> 00:16:27.440
So this is a function that
Prototype offers.

00:16:27.440 --> 00:16:31.140
Does anyone have a guess what
this function does, just by

00:16:31.140 --> 00:16:33.600
reading it?

00:16:33.600 --> 00:16:34.490
It does white space.

00:16:34.490 --> 00:16:34.870
Yeah.

00:16:34.870 --> 00:16:36.850
So it actually splits
your code.

00:16:36.850 --> 00:16:40.150
It splits your string that you
give it, on white space.

00:16:40.150 --> 00:16:42.830
Now if you know that, it's
probably because you've used

00:16:42.830 --> 00:16:44.240
Prototype JS before.

00:16:44.240 --> 00:16:47.020
But if you have a new person on
your project and they came

00:16:47.020 --> 00:16:50.530
upon this function that says
dollar sign W, it's pretty

00:16:50.530 --> 00:16:53.890
hard for them to come up with
what it does without, either

00:16:53.890 --> 00:16:55.720
running it or looking
at the code.

00:16:55.720 --> 00:16:57.030
And for one function
that's fine.

00:16:57.030 --> 00:16:59.700
But if this is kind of how you
design your whole library,

00:16:59.700 --> 00:17:03.710
basically to be unreadable but
terse, this is going to hurt

00:17:03.710 --> 00:17:06.099
you when you're trying to
build a large JavaScript

00:17:06.099 --> 00:17:07.960
application.

00:17:07.960 --> 00:17:10.170
For a long time people have kind
of gotten away with, or

00:17:10.170 --> 00:17:13.640
justified, this type of library
style because of

00:17:13.640 --> 00:17:17.240
arguing that, well it's saving
my users' bandwidth because

00:17:17.240 --> 00:17:19.369
I'm using fewer bytes for
my function names.

00:17:19.369 --> 00:17:22.490
And so it's saving space on the
wire and therefore it's OK

00:17:22.490 --> 00:17:25.150
to do things that no one
else understands.

00:17:25.150 --> 00:17:27.420
But with things like the Closure
compiler, which will

00:17:27.420 --> 00:17:30.050
rename variable for you--
as we'll see in a bit--

00:17:30.050 --> 00:17:32.820
that's no longer as compelling
a reason to

00:17:32.820 --> 00:17:33.950
do things that way.

00:17:33.950 --> 00:17:36.350
So in the Closure world, you're
really going to want to

00:17:36.350 --> 00:17:39.255
use names that are readable and
make sense and make sense

00:17:39.255 --> 00:17:40.770
to your teammates and are
more self-documenting.

00:17:44.030 --> 00:17:46.710
Another thing is building
up strings of HTML.

00:17:46.710 --> 00:17:50.230
So the problem is, as I
mentioned, that JavaScript is

00:17:50.230 --> 00:17:52.530
not really great at this, when
you want to preserve the

00:17:52.530 --> 00:17:56.270
formatting of the HTML and the
structure that you're trying

00:17:56.270 --> 00:17:58.670
to produce such that
it's readable.

00:17:58.670 --> 00:18:01.390
You want it to be close to what
it would be if you wrote

00:18:01.390 --> 00:18:04.390
HTML yourself.

00:18:04.390 --> 00:18:06.310
But does anyone know what this
function would return?

00:18:11.670 --> 00:18:14.500
So actually, this function, if
you just ran it, regardless of

00:18:14.500 --> 00:18:16.900
what inputs you gave
to it, this

00:18:16.900 --> 00:18:18.820
function returns undefined.

00:18:18.820 --> 00:18:22.120
And the reason is that
JavaScript has this neat

00:18:22.120 --> 00:18:25.350
feature called semicolon
insertion.

00:18:25.350 --> 00:18:29.990
And basically if you don't use
semicolons everywhere, it

00:18:29.990 --> 00:18:32.810
infers for where semicolons
can be placed.

00:18:32.810 --> 00:18:37.000
And so, unlike some other
languages you can have logic

00:18:37.000 --> 00:18:38.790
after a return statement
in JavaScript.

00:18:38.790 --> 00:18:40.405
It's actually kind of helpful
during debugging if you want

00:18:40.405 --> 00:18:42.640
to exit out real quick while
testing something.

00:18:42.640 --> 00:18:43.750
But in your production
code, this is

00:18:43.750 --> 00:18:45.190
actually kind of a disaster.

00:18:45.190 --> 00:18:49.910
So what happens is, JavaScript
inserts a semicolon basically

00:18:49.910 --> 00:18:52.060
after where that end
character would be.

00:18:52.060 --> 00:18:55.560
Or the interpreter or the
run time does this.

00:18:55.560 --> 00:18:57.350
It does this because then
there's a new line and then

00:18:57.350 --> 00:18:59.440
this whole statement--
this on its own is a

00:18:59.440 --> 00:19:02.110
valid JavaScript statement.

00:19:02.110 --> 00:19:03.690
So the first line just
becomes return.

00:19:03.690 --> 00:19:04.910
It returns undefined.

00:19:04.910 --> 00:19:08.430
Actually that statement below
it never gets executed.

00:19:08.430 --> 00:19:12.370
There's lots of little bugs,
errors, that people make

00:19:12.370 --> 00:19:13.590
around this type of behavior.

00:19:13.590 --> 00:19:17.540
And when it comes to things like
formatting HTML, it makes

00:19:17.540 --> 00:19:19.980
it particularly worse.

00:19:19.980 --> 00:19:23.800
Another problem that people
open themselves up to when

00:19:23.800 --> 00:19:26.260
they write code in this manner
is that these arguments are

00:19:26.260 --> 00:19:28.320
not HTML escaped.

00:19:28.320 --> 00:19:31.130
Meaning that, if the user
is some sort of user and

00:19:31.130 --> 00:19:34.610
potentially a malicious user,
is responsible for--

00:19:34.610 --> 00:19:39.580
if you read these values out of
a database that that user

00:19:39.580 --> 00:19:42.080
chose when they signed up or
filled out a form or something

00:19:42.080 --> 00:19:45.430
like that-- if you don't escape
the less than signs and

00:19:45.430 --> 00:19:48.780
whatnot before you blitz this
string of HTML into your

00:19:48.780 --> 00:19:52.160
application, you could open
yourself up to a across-site

00:19:52.160 --> 00:19:54.390
scripting attack.

00:19:54.390 --> 00:19:56.400
Which is very embarrassing
for you.

00:19:56.400 --> 00:19:58.110
I've done it.

00:19:58.110 --> 00:20:00.890
I was very embarrassed
as you might imagine.

00:20:00.890 --> 00:20:03.490
But it's better to have a tool
that really makes it harder to

00:20:03.490 --> 00:20:04.740
make these kinds of mistakes.

00:20:09.550 --> 00:20:14.610
Another issue is managing
dependencies in JavaScript.

00:20:14.610 --> 00:20:17.230
I look at a lot of projects, or
even websites I visit, and

00:20:17.230 --> 00:20:18.220
I wonder why they're slow.

00:20:18.220 --> 00:20:20.540
And then I take a little look
under the hood and a lot of

00:20:20.540 --> 00:20:24.580
them manage their dependencies
in this way.

00:20:24.580 --> 00:20:27.660
And I can imagine what's going
through the developer's mind

00:20:27.660 --> 00:20:28.980
as they come up with HTML.

00:20:28.980 --> 00:20:32.060
So they're like, number one,
I'm writing JavaScript.

00:20:32.060 --> 00:20:33.060
So I need jQuery.

00:20:33.060 --> 00:20:34.370
Because everyone says
jQuery's cool.

00:20:34.370 --> 00:20:35.030
So that's what I'm
going to do.

00:20:35.030 --> 00:20:38.850
So they put a script tag to
jQuery in their page.

00:20:38.850 --> 00:20:40.860
So far that's completely fine.

00:20:40.860 --> 00:20:44.590
But then they get to the point
where they have some form that

00:20:44.590 --> 00:20:46.260
needs people to input a date.

00:20:46.260 --> 00:20:47.910
And they're like, I need
a date picker.

00:20:47.910 --> 00:20:50.070
And they go and they download
a date picker library for

00:20:50.070 --> 00:20:52.890
somewhere and they just plop
another script tag in there.

00:20:52.890 --> 00:20:54.320
So now it's two tags.

00:20:54.320 --> 00:20:55.070
Not so bad, right?

00:20:55.070 --> 00:20:58.630
Probably going to need a date
picker in other places.

00:20:58.630 --> 00:20:59.980
That's OK.

00:20:59.980 --> 00:21:03.020
And then they decide that they
want some template solution.

00:21:03.020 --> 00:21:04.840
Because actually, that would
kind of help them out.

00:21:04.840 --> 00:21:07.840
And they didn't get one out of
box with jQuery or with the

00:21:07.840 --> 00:21:10.820
data picker, so they
include that.

00:21:10.820 --> 00:21:13.280
And then they started testing
on IE 6 and they're

00:21:13.280 --> 00:21:14.440
like, ah, son of a--

00:21:14.440 --> 00:21:16.670
Now I've got to add
this workaround.

00:21:16.670 --> 00:21:20.100
And it's not that big, so
everyone can just get it.

00:21:20.100 --> 00:21:22.510
It's just another script tag
and that type of thing.

00:21:22.510 --> 00:21:25.710
And then, oh, actually, I also
forgot I should probably write

00:21:25.710 --> 00:21:28.500
my application, too, while
I'm doing all this other

00:21:28.500 --> 00:21:29.650
JavaScript development.

00:21:29.650 --> 00:21:31.390
And you see lots of pages
like this, where

00:21:31.390 --> 00:21:32.520
everything gets built up.

00:21:32.520 --> 00:21:35.030
There's also a good chance
that unrelated template

00:21:35.030 --> 00:21:38.400
solution dot js happened to
bundle jQuery in their

00:21:38.400 --> 00:21:39.180
implementation.

00:21:39.180 --> 00:21:44.070
And now you're pulling down
two versions of it.

00:21:44.070 --> 00:21:45.440
I've seen a lot of
things like this.

00:21:45.440 --> 00:21:46.520
So how long can this go on?

00:21:46.520 --> 00:21:49.790
How many script tags can you
add to your web page?

00:21:49.790 --> 00:21:51.860
Well, a lot, unfortunately.

00:21:51.860 --> 00:21:55.560
And this is a big source of
slowness, if you've looked at

00:21:55.560 --> 00:22:00.090
page feed or any of Steve
Souders's work on how to make

00:22:00.090 --> 00:22:02.030
faster websites.

00:22:02.030 --> 00:22:02.850
Everyone will tell you.

00:22:02.850 --> 00:22:05.340
One, you need to minimize the
number of requests that your

00:22:05.340 --> 00:22:07.220
page makes.

00:22:07.220 --> 00:22:08.550
Sometimes you may want
to split things

00:22:08.550 --> 00:22:10.320
up to leverage cacheing.

00:22:10.320 --> 00:22:13.970
That really depends on the
profile of your page or the

00:22:13.970 --> 00:22:15.640
assets that you're trying
to download.

00:22:15.640 --> 00:22:18.220
But if you see something like
this, you're probably doing

00:22:18.220 --> 00:22:18.860
something wrong.

00:22:18.860 --> 00:22:21.440
And you could be doing something
a lot better.

00:22:21.440 --> 00:22:25.040
And also, a lot of these
disparate libraries are

00:22:25.040 --> 00:22:28.590
probably reimplementing the same
functionality and your

00:22:28.590 --> 00:22:31.600
users are now downloading
it five times.

00:22:31.600 --> 00:22:32.760
So managing dependencies.

00:22:32.760 --> 00:22:34.360
Again, I said there's no
import statement in

00:22:34.360 --> 00:22:34.980
JavaScript.

00:22:34.980 --> 00:22:39.190
So it's somewhat difficult
to do out of the box.

00:22:39.190 --> 00:22:42.950
Another thing that I've seen
happening recently is creating

00:22:42.950 --> 00:22:46.530
a special version of JavaScript
for mobile.

00:22:46.530 --> 00:22:49.270
Creating a special version of
your JavaScript for mobile is

00:22:49.270 --> 00:22:49.960
a good thing.

00:22:49.960 --> 00:22:53.060
Because they have different
capabilities and

00:22:53.060 --> 00:22:53.700
that sort of thing.

00:22:53.700 --> 00:22:56.400
But the problem is that when
I see forks of libraries.

00:22:56.400 --> 00:22:59.540
So there's a library out called
Zepto .js and it's

00:22:59.540 --> 00:23:06.420
basically a mobile web kit
implementation of jQuery So

00:23:06.420 --> 00:23:09.990
when I say mobile web kit I
mean, you can rely on an array

00:23:09.990 --> 00:23:11.420
having a for each library.

00:23:11.420 --> 00:23:14.220
Or that you know that the
query selector method is

00:23:14.220 --> 00:23:17.290
available in the DOM As opposed
to, in jQuery, to be

00:23:17.290 --> 00:23:20.400
backwards compatible there's
substantial code that it

00:23:20.400 --> 00:23:24.590
bundles to be able to emulate
query SelectorAll and

00:23:24.590 --> 00:23:26.390
iterating of an array
and a whole bunch

00:23:26.390 --> 00:23:27.320
of things like that.

00:23:27.320 --> 00:23:32.330
And so instead of trying to
write one library, and not

00:23:32.330 --> 00:23:34.270
repeating yourself, and then
doing some sort of

00:23:34.270 --> 00:23:37.720
post-processing to generate what
would be a mobile web kit

00:23:37.720 --> 00:23:41.140
optimized version and then
generating what's, let's say a

00:23:41.140 --> 00:23:43.850
browser-agnostic version, people
sometimes just choose

00:23:43.850 --> 00:23:44.800
to fork things.

00:23:44.800 --> 00:23:48.390
And obviously then, it's much
harder to maintain.

00:23:48.390 --> 00:23:49.460
You have two versions.

00:23:49.460 --> 00:23:51.440
One has features that the
other one doesn't.

00:23:51.440 --> 00:23:52.580
Testing.

00:23:52.580 --> 00:23:56.910
All the efforts of what you're
trying to do are now doubled.

00:23:59.590 --> 00:24:03.480
Another one is safeguarding
private variables.

00:24:03.480 --> 00:24:06.700
Again, because we have no idea
of visibility keywords in

00:24:06.700 --> 00:24:07.230
JavaScript.

00:24:07.230 --> 00:24:10.265
There is no public
private keyword.

00:24:10.265 --> 00:24:16.080
A lot of people use Closure to
emulate the private variables

00:24:16.080 --> 00:24:18.280
in languages like Java.

00:24:18.280 --> 00:24:21.150
And so this is an implementation
of how you

00:24:21.150 --> 00:24:23.800
could do this if you imagine,
ImmutableLatLng, if you

00:24:23.800 --> 00:24:24.900
treated that as a constructor.

00:24:24.900 --> 00:24:26.790
You passed into lat, lng.

00:24:26.790 --> 00:24:28.700
You wanted there to be
getters for these

00:24:28.700 --> 00:24:30.930
properties but not setters.

00:24:30.930 --> 00:24:32.880
This would do that for you.

00:24:32.880 --> 00:24:36.120
The downside is that means every
time you instantiate one

00:24:36.120 --> 00:24:37.140
of these objects--

00:24:37.140 --> 00:24:39.980
in this case it's creating three
new function objects as

00:24:39.980 --> 00:24:42.560
opposed to sharing one
method object.

00:24:42.560 --> 00:24:44.580
So this will take
up more memory.

00:24:44.580 --> 00:24:47.010
It also increases
look up time.

00:24:47.010 --> 00:24:49.240
Because by using a Closure, you
actually create an actual

00:24:49.240 --> 00:24:50.640
level of scope.

00:24:50.640 --> 00:24:53.500
Newer engines like V 8 this
shouldn't actually be a

00:24:53.500 --> 00:24:55.780
significant difference in terms
of the look up time.

00:24:55.780 --> 00:24:59.670
But older browsers, like IE6,
these things actually become

00:24:59.670 --> 00:25:00.920
more significant.

00:25:02.870 --> 00:25:04.680
And another thing is
documenting types.

00:25:04.680 --> 00:25:08.340
So as I mentioned we don't have
a standard syntax for

00:25:08.340 --> 00:25:12.320
documenting types of variables
and methods in JavaScript.

00:25:12.320 --> 00:25:15.080
But if you're going to have a
large application and people

00:25:15.080 --> 00:25:18.620
want to be able to look at an
API really quickly, it's more

00:25:18.620 --> 00:25:20.770
helpful if you have some
sort of standard

00:25:20.770 --> 00:25:23.460
way to document types.

00:25:23.460 --> 00:25:25.040
Sometimes libraries--

00:25:25.040 --> 00:25:28.260
this is what Dojo does,
basically is that you can make

00:25:28.260 --> 00:25:29.650
a little in-line comment.

00:25:29.650 --> 00:25:33.210
And this is actually pretty good
as long as it's, you have

00:25:33.210 --> 00:25:34.340
kind of a standard format.

00:25:34.340 --> 00:25:39.090
But even in this example, you
have a method that takes some

00:25:39.090 --> 00:25:40.440
number of parameters
and then you also

00:25:40.440 --> 00:25:41.845
specify a call back function.

00:25:41.845 --> 00:25:44.310
And a lot of people just say the
call back is a function.

00:25:44.310 --> 00:25:46.990
But really, that call
back has a contract.

00:25:46.990 --> 00:25:50.110
And in this case it
would be something

00:25:50.110 --> 00:25:51.850
that takes a lat lng.

00:25:51.850 --> 00:25:54.730
But developers right now usually
have to take a look at

00:25:54.730 --> 00:25:57.110
the implementation of the method
to see what the call

00:25:57.110 --> 00:26:00.130
back actually gets
or test it out.

00:26:00.130 --> 00:26:03.940
Because it's not expressed in
the type definition that you

00:26:03.940 --> 00:26:05.560
gave for the argument.

00:26:05.560 --> 00:26:09.410
It's a lot easier to pick up a
library and use it if you know

00:26:09.410 --> 00:26:12.030
what the contract of the
call back function is.

00:26:12.030 --> 00:26:14.290
Helps you figure out where you
should send it or actually if

00:26:14.290 --> 00:26:15.540
even if it's the right
method that you

00:26:15.540 --> 00:26:16.790
should be using or not.

00:26:20.030 --> 00:26:21.580
So these are a bunch of problems
that JavaScript

00:26:21.580 --> 00:26:22.900
developers have today.

00:26:22.900 --> 00:26:26.300
And so I want to go through the
Closure tools and let's

00:26:26.300 --> 00:26:29.640
take a look at how Closure can
help you address these

00:26:29.640 --> 00:26:33.760
problems, write better code and
avoid these pitfalls and

00:26:33.760 --> 00:26:36.750
hopefully avoid bugs.

00:26:36.750 --> 00:26:41.510
So the first thing is, this
is basically how--

00:26:41.510 --> 00:26:43.370
when you use all the Closure
tools together--

00:26:43.370 --> 00:26:46.480
how your application is built.

00:26:46.480 --> 00:26:49.660
Or how you produce JavaScript
at the bottom.

00:26:49.660 --> 00:26:52.860
So at the top, so one thing you
would have is you'd have

00:26:52.860 --> 00:26:55.130
template code.

00:26:55.130 --> 00:26:57.060
I'll show you in a second.

00:26:57.060 --> 00:27:00.790
Closure Templates is its own
templating language.

00:27:00.790 --> 00:27:04.270
So you write your templates in
that templating language.

00:27:04.270 --> 00:27:06.820
And then you run it through the
tool, Closure Templates,

00:27:06.820 --> 00:27:08.240
and that produces JavaScript.

00:27:08.240 --> 00:27:10.410
So now each template that
you wrote becomes

00:27:10.410 --> 00:27:11.680
a JavaScript function.

00:27:11.680 --> 00:27:14.390
The Closure Library, as I said,
is already a library in

00:27:14.390 --> 00:27:15.340
pure JavaScript.

00:27:15.340 --> 00:27:19.033
So now you already have your
JavaScript library for string

00:27:19.033 --> 00:27:22.470
and DOM utilities and all sorts
of other good stuff.

00:27:22.470 --> 00:27:25.030
And then the third is your
application code.

00:27:25.030 --> 00:27:29.820
So you're able to write code
that leverages both the

00:27:29.820 --> 00:27:32.530
templates and the library code
that you've written.

00:27:32.530 --> 00:27:34.490
And all three of these
things go down

00:27:34.490 --> 00:27:36.170
into the Closure Compiler.

00:27:36.170 --> 00:27:39.820
And so the Closure Compiler
is a whole program

00:27:39.820 --> 00:27:41.200
optimize and compiler.

00:27:41.200 --> 00:27:43.180
Meaning that it has all the
source code of your

00:27:43.180 --> 00:27:45.770
application at once when
it compiles it.

00:27:45.770 --> 00:27:48.560
This is unlike, let's say
Java, for example.

00:27:48.560 --> 00:27:52.180
Where some of the assets that go
through javac are JARs are

00:27:52.180 --> 00:27:57.310
pre-compiled objects and
therefore there's some

00:27:57.310 --> 00:28:00.500
optimizations that the Closure
Compiler can do on a global

00:28:00.500 --> 00:28:04.100
level because it has all
the source code.

00:28:04.100 --> 00:28:06.560
And then as a result we get
some optimized JavaScript.

00:28:06.560 --> 00:28:10.910
We get something that Closure
Compiler has produced knowing

00:28:10.910 --> 00:28:14.420
all possible code paths, so to
speak, of your JavaScript

00:28:14.420 --> 00:28:15.460
application.

00:28:15.460 --> 00:28:18.150
And so this is what enables it
to produce something that's

00:28:18.150 --> 00:28:23.410
really small, really compact
and really fast.

00:28:23.410 --> 00:28:26.790
So the first thing I want to
show you is what the syntax

00:28:26.790 --> 00:28:30.160
for Closure Templates
look like.

00:28:30.160 --> 00:28:31.710
There's a namespace
at the top.

00:28:31.710 --> 00:28:35.650
In this case I made a namespace
called widget.

00:28:35.650 --> 00:28:39.090
The next, I guess this looks
kind of like Java or Javadoc,

00:28:39.090 --> 00:28:41.380
where you declare the parameters
that are going to

00:28:41.380 --> 00:28:43.410
be passed into the template.

00:28:43.410 --> 00:28:48.890
So these are basically your
template variables below.

00:28:48.890 --> 00:28:51.920
Then you have your HTML and
we have this dollar sign

00:28:51.920 --> 00:28:54.210
placeholder type of thing.

00:28:54.210 --> 00:28:57.280
Which, is probably not too
surprising if you've looked at

00:28:57.280 --> 00:28:58.890
most other templating
solutions.

00:28:58.890 --> 00:29:01.670
There's the markup and then
there's the stuff that you

00:29:01.670 --> 00:29:04.370
want to insert.

00:29:04.370 --> 00:29:07.710
At the outset, this maybe
doesn't look too compelling.

00:29:07.710 --> 00:29:11.180
But what's more interesting is
that when we run this through

00:29:11.180 --> 00:29:17.120
the Closure Templates tool,
and so this is what is

00:29:17.120 --> 00:29:20.700
produced once you run
it through the tool.

00:29:20.700 --> 00:29:23.280
So what's actually produced
is a function.

00:29:23.280 --> 00:29:27.190
So unlike PHP, where PHP is
also a templating library,

00:29:27.190 --> 00:29:30.220
where you can't really get
access to it programatically.

00:29:30.220 --> 00:29:31.580
It's kind of like you
just hit the page

00:29:31.580 --> 00:29:32.850
and stuff just happens.

00:29:32.850 --> 00:29:35.940
Now this template is actually
a function.

00:29:35.940 --> 00:29:40.840
It has, as a parameter
it has a return type.

00:29:40.840 --> 00:29:43.580
You can see that it takes
this object in.

00:29:43.580 --> 00:29:46.660
And another thing it does for
you is that, by default, you

00:29:46.660 --> 00:29:50.010
can see that all the arguments
are escapes.

00:29:50.010 --> 00:29:53.180
So I made that comment earlier
about my original definition

00:29:53.180 --> 00:29:59.090
of a function that you'd try to
do this template, where the

00:29:59.090 --> 00:30:03.090
arguments were not escaped and
you were subject to cross-site

00:30:03.090 --> 00:30:05.170
scripting vulnerabilities.

00:30:05.170 --> 00:30:08.510
In Closure Templates, it escapes
things by default.

00:30:08.510 --> 00:30:11.660
You can add annotations to say
don't escape anything in this

00:30:11.660 --> 00:30:13.610
template or don't escape
this variable.

00:30:13.610 --> 00:30:17.050
But by default, you should
be a lot safer.

00:30:17.050 --> 00:30:21.190
Another thing is also that
by this being a function,

00:30:21.190 --> 00:30:24.150
something you can interact with
programatically, you can,

00:30:24.150 --> 00:30:27.940
if you're familiar with the idea
of function carrying, and

00:30:27.940 --> 00:30:30.830
also that in JavaScript that
functions are first order

00:30:30.830 --> 00:30:32.830
objects, that you can
pass them around.

00:30:32.830 --> 00:30:36.580
So programatiically, this is a
much nicer way to deal with

00:30:36.580 --> 00:30:38.380
the idea of a template.

00:30:38.380 --> 00:30:42.590
Also, you can see if you look
carefully, all the white space

00:30:42.590 --> 00:30:44.030
that we put in the template--

00:30:44.030 --> 00:30:46.560
just to make it readable
for ourselves--

00:30:46.560 --> 00:30:48.460
is removed when it's
translated into

00:30:48.460 --> 00:30:49.740
a JavaScript function.

00:30:49.740 --> 00:30:51.470
So this saves bytes.

00:30:51.470 --> 00:30:53.390
When you traverse the DOM
there's actually fewer white

00:30:53.390 --> 00:30:54.960
space nodes that
get in the way.

00:30:54.960 --> 00:30:57.720
So these are all nice things
and help you create markup

00:30:57.720 --> 00:31:02.260
that's basically as trim
as it can possibly be.

00:31:02.260 --> 00:31:04.640
Also I want to point out that
there's these statements that

00:31:04.640 --> 00:31:08.100
got inserted at the top, which
are goog.provide and

00:31:08.100 --> 00:31:11.420
goog.require, These are
functions that are part of the

00:31:11.420 --> 00:31:13.600
Closure Library.

00:31:13.600 --> 00:31:16.070
This is basically how namespaces
are declared and

00:31:16.070 --> 00:31:18.970
how dependencies are expressed
in the Closure Library.

00:31:18.970 --> 00:31:21.100
So as I said, there's no native
import function in

00:31:21.100 --> 00:31:23.520
JavaScript but when you write
your code for the Closure

00:31:23.520 --> 00:31:26.370
Library in this style, now you
have a standard way of

00:31:26.370 --> 00:31:29.920
expressing dependencies and
we'll see the benefits of that

00:31:29.920 --> 00:31:32.840
in just a second.

00:31:32.840 --> 00:31:35.590
So the first thing is, now if we
have this template function

00:31:35.590 --> 00:31:36.790
and now we want to use it.

00:31:36.790 --> 00:31:40.140
So now this file we said
we provide this

00:31:40.140 --> 00:31:41.670
namespace called widget.

00:31:41.670 --> 00:31:44.790
Now we'll have some application
logic, where we

00:31:44.790 --> 00:31:45.610
want to use it.

00:31:45.610 --> 00:31:48.100
So now there's a goog.require
statement for widget.

00:31:48.100 --> 00:31:49.840
And we're actually, ourselves,
going to provide a new

00:31:49.840 --> 00:31:52.120
namespace called button.

00:31:52.120 --> 00:31:54.890
So here, we add a method to
the button namespace by

00:31:54.890 --> 00:31:57.820
declaring it as a property
on the button object.

00:31:57.820 --> 00:32:00.760
And the button object got
created as a side effect of

00:32:00.760 --> 00:32:03.140
running that goog.provide
statement.

00:32:03.140 --> 00:32:05.160
And now we add it
as a property.

00:32:05.160 --> 00:32:07.600
It's just a function.

00:32:07.600 --> 00:32:10.880
All templates take one argument,
where the argument

00:32:10.880 --> 00:32:12.440
is an object literal.

00:32:12.440 --> 00:32:15.650
Where the names of the
properties are the values for

00:32:15.650 --> 00:32:19.020
the template and the values of
the property are the values

00:32:19.020 --> 00:32:20.080
for the template values.

00:32:20.080 --> 00:32:23.060
And so basically we create this
data object and now we

00:32:23.060 --> 00:32:26.740
can just pass it to
widget.button as a function,

00:32:26.740 --> 00:32:30.820
return the value and return
that from get button HTML.

00:32:30.820 --> 00:32:32.320
I find this to be--

00:32:32.320 --> 00:32:34.220
many people find this to be--
much more maintainable.

00:32:34.220 --> 00:32:36.610
Because now, when you want to
write your markup, you can

00:32:36.610 --> 00:32:39.030
basically do it in any
way that you want.

00:32:39.030 --> 00:32:42.000
You can actually put comments
in this template that don't

00:32:42.000 --> 00:32:44.700
get included as part the
markup that's sent out.

00:32:47.370 --> 00:32:48.860
And you really want
to write this.

00:32:48.860 --> 00:32:50.200
But you don't want to
write it by hand.

00:32:50.200 --> 00:32:51.530
But that's what you really
want produced.

00:32:51.530 --> 00:32:52.770
And now you have that.

00:32:52.770 --> 00:32:54.450
And now you can use
that inside your

00:32:54.450 --> 00:32:56.240
regular JavaScript function.

00:32:56.240 --> 00:32:58.120
So now we're just really
working in

00:32:58.120 --> 00:33:01.140
the JavaScript world.

00:33:01.140 --> 00:33:04.110
So as I mentioned, there's these
dependencies that we've

00:33:04.110 --> 00:33:06.760
expressed through goog.provide
and goog.require.

00:33:06.760 --> 00:33:11.780
So at the top we have button,
which we said requires widget.

00:33:11.780 --> 00:33:16.830
And widget requires soy, which
is the internal name of

00:33:16.830 --> 00:33:17.630
Closure Templates.

00:33:17.630 --> 00:33:20.020
You'll see that if you look
through Closure code.

00:33:20.020 --> 00:33:22.360
When you see soy it means
Closure Templates.

00:33:22.360 --> 00:33:25.300
And in practice, Closure
Templates by default include a

00:33:25.300 --> 00:33:25.960
bunch of stuff.

00:33:25.960 --> 00:33:28.010
It includes DOM utilities
because a lot of times you

00:33:28.010 --> 00:33:31.295
want to take the result of the
template and put it into a DOM

00:33:31.295 --> 00:33:33.710
node or create a document
fragment out of it.

00:33:33.710 --> 00:33:36.730
It includes string utilities for
doing the escaping and it

00:33:36.730 --> 00:33:39.620
also includes a lot
of utilities for

00:33:39.620 --> 00:33:40.210
internationalization.

00:33:40.210 --> 00:33:43.970
So there's actually support
for internationalization.

00:33:43.970 --> 00:33:47.020
In JavaScript Templates there's
a special message tag.

00:33:47.020 --> 00:33:50.760
So if You're building an
application that you want to

00:33:50.760 --> 00:33:54.750
localize, Closure Templates
helps with that as well.

00:33:54.750 --> 00:33:57.160
But the thing is though, in the
example that I gave, we're

00:33:57.160 --> 00:33:58.850
actually not using all
that stuff, right?

00:33:58.850 --> 00:34:00.610
We never used the
DOM utilities.

00:34:00.610 --> 00:34:03.760
We never used
internationalization.

00:34:03.760 --> 00:34:07.810
A lot of people will choose to
maintain these dependencies by

00:34:07.810 --> 00:34:10.690
hand saying, oh I don't want
to include all that stuff.

00:34:10.690 --> 00:34:12.520
But as we'll see, the Closure
Compiler will take care of

00:34:12.520 --> 00:34:13.050
that for you.

00:34:13.050 --> 00:34:17.630
So it's OK to create large
libraries, where you, in

00:34:17.630 --> 00:34:20.000
practice later, only use
some of the functions.

00:34:20.000 --> 00:34:23.570
Because you're going to want to
supply these libraries to,

00:34:23.570 --> 00:34:26.489
say, other teammates or
for other projects

00:34:26.489 --> 00:34:27.530
that you maybe use.

00:34:27.530 --> 00:34:30.630
So in practice, we'll see how
actually the DOM utilities and

00:34:30.630 --> 00:34:32.860
the internationalization stuff
gets stripped out.

00:34:32.860 --> 00:34:38.980
You don't pay some penalty for
using a more mature library.

00:34:38.980 --> 00:34:43.070
So for example, in terms of
leveraging dependencies, we'll

00:34:43.070 --> 00:34:44.280
introduce a new one
called myapp.

00:34:44.280 --> 00:34:46.219
Now let's say this is
your application.

00:34:46.219 --> 00:34:49.989
And now you require button and
you require some DOM utilities

00:34:49.989 --> 00:34:53.690
and now you have a function that
goes ahead and uses the

00:34:53.690 --> 00:34:56.739
template and inserts it into
the DOM with these standard

00:34:56.739 --> 00:34:57.755
DOM utilities.

00:34:57.755 --> 00:34:59.455
So now the dependency
graph for your

00:34:59.455 --> 00:35:00.370
application has changed.

00:35:00.370 --> 00:35:02.530
Now we have a new thing
at the root of the

00:35:02.530 --> 00:35:03.910
graph called myapp.

00:35:03.910 --> 00:35:06.140
It depends on button and
its dependencies still

00:35:06.140 --> 00:35:07.090
go all the way down.

00:35:07.090 --> 00:35:09.680
But now myapp depends on DOM.

00:35:09.680 --> 00:35:12.420
And so now actually that DOM
dependency is going to come

00:35:12.420 --> 00:35:14.570
back into our code.

00:35:14.570 --> 00:35:17.650
But the internationalization one
will still be separated.

00:35:17.650 --> 00:35:21.610
This is really nice because this
all happens naturally, as

00:35:21.610 --> 00:35:23.270
we'll see with the
Closure Compiler.

00:35:23.270 --> 00:35:25.900
As opposed to trying to manage
all those script tags by hand

00:35:25.900 --> 00:35:29.000
and trying to figure out what
the dependency ordering is and

00:35:29.000 --> 00:35:31.020
trying to find the minimal set
because you want to send down

00:35:31.020 --> 00:35:33.025
the least JavaScript
code as possible.

00:35:36.630 --> 00:35:39.856
Jumping right into the Closure
Compiler and looking at some

00:35:39.856 --> 00:35:41.000
of the effects.

00:35:41.000 --> 00:35:44.020
So the Closure Compiler, now
with code that is written in

00:35:44.020 --> 00:35:46.690
the style, it understands
these goog.provide and

00:35:46.690 --> 00:35:48.130
goog.require statements.

00:35:48.130 --> 00:35:50.870
Now this is where it gets pretty
serious in terms of the

00:35:50.870 --> 00:35:54.140
savings that it can give
you in terms of your

00:35:54.140 --> 00:35:55.460
JavaScript code size.

00:35:55.460 --> 00:35:58.260
So by default, if you just
concatenated all the files

00:35:58.260 --> 00:36:02.630
that would be transitively
required, by that myapp.js

00:36:02.630 --> 00:36:07.180
file that I created, it's
375K, approximately.

00:36:07.180 --> 00:36:09.040
Very very, large.

00:36:09.040 --> 00:36:09.850
That is a lot of code.

00:36:09.850 --> 00:36:12.290
Especially for something as
trivial that we were doing.

00:36:12.290 --> 00:36:14.110
We were just building
up some HTML and

00:36:14.110 --> 00:36:16.645
inserting it into a DOM.

00:36:16.645 --> 00:36:18.510
So that does seem
a bit excessive.

00:36:21.290 --> 00:36:23.590
But then if you run the Closure
Compiler, there's a

00:36:23.590 --> 00:36:24.920
mode called whitespace only.

00:36:24.920 --> 00:36:28.320
Where all it does is remove
whitespace and comments.

00:36:28.320 --> 00:36:30.770
This already gets you
down quite a bit.

00:36:30.770 --> 00:36:34.170
So as you may guess, the Closure
Library is actually

00:36:34.170 --> 00:36:36.590
pretty well documented
since that got rid of

00:36:36.590 --> 00:36:38.920
almost 75% of the code.

00:36:38.920 --> 00:36:42.700
So that's a pretty big
win right there.

00:36:42.700 --> 00:36:46.860
By comparison, I also ran the
same code through YUI

00:36:46.860 --> 00:36:48.770
Compressor and UglifyJS.

00:36:48.770 --> 00:36:52.820
These are some other minifiers
that are popular right now.

00:36:52.820 --> 00:36:54.680
You can see they do
a bit better than

00:36:54.680 --> 00:36:56.100
whitespace only mode.

00:36:56.100 --> 00:36:58.660
And the Closure Compiler also
has the simple mode, which is

00:36:58.660 --> 00:37:01.710
analogous to the YUI Compressor
and UglifyJS.

00:37:01.710 --> 00:37:03.830
And you can see it just ekes
them out by a little bit.

00:37:03.830 --> 00:37:06.280
But we're not looking at an
order of magnitude of

00:37:06.280 --> 00:37:07.200
difference.

00:37:07.200 --> 00:37:10.620
Until we look at the advanced
mode of the Closure Compiler.

00:37:10.620 --> 00:37:13.880
The advanced mode is quite
a different animal.

00:37:13.880 --> 00:37:17.820
Basically what it can do is,
as I mentioned it's a whole

00:37:17.820 --> 00:37:19.630
program optimize and compiler.

00:37:19.630 --> 00:37:22.420
So it basically traces
the code paths

00:37:22.420 --> 00:37:25.020
from the main method.

00:37:25.020 --> 00:37:25.920
From this main method.

00:37:25.920 --> 00:37:29.030
So this is the only function
that's actually called in this

00:37:29.030 --> 00:37:29.740
application.

00:37:29.740 --> 00:37:32.480
And it can trace through and
realize that, OK, the only

00:37:32.480 --> 00:37:35.430
things that are called ate
getButtonHtml getElement and

00:37:35.430 --> 00:37:36.420
so on and so forth.

00:37:36.420 --> 00:37:40.180
And then when it's done
optimizing, it will only

00:37:40.180 --> 00:37:44.610
include the bits that it needs,
that it's determined

00:37:44.610 --> 00:37:48.130
that will be exercised by this
JavaScript application.

00:37:48.130 --> 00:37:51.330
So now we've gotten down to
something that's 1/200 of the

00:37:51.330 --> 00:37:54.700
original size of what we
were dealing with.

00:37:54.700 --> 00:37:57.160
This is obviously a much better
way, to let a tool do

00:37:57.160 --> 00:38:01.130
this for you than do this
type of thing by hand.

00:38:01.130 --> 00:38:06.130
And even to go one step further
is that you can enable

00:38:06.130 --> 00:38:09.390
options to eliminate
platform-specific code.

00:38:09.390 --> 00:38:12.700
So if you have these special
defines, these special options

00:38:12.700 --> 00:38:15.590
pass through the compiler, you
can say, assume that it's

00:38:15.590 --> 00:38:18.660
mobile web kit and also assume
it's not JScript, which is the

00:38:18.660 --> 00:38:20.270
engine in Internet Explorer.

00:38:20.270 --> 00:38:22.430
And in this particular example,
this won't be true

00:38:22.430 --> 00:38:26.890
for all examples, but it gets
the whole program down to 481

00:38:26.890 --> 00:38:29.170
bytes, which is basically
nothing.

00:38:29.170 --> 00:38:32.410
And this is all being done for
you, as opposed to you trying

00:38:32.410 --> 00:38:35.590
to reorganize your code and
optimize it by hand in order

00:38:35.590 --> 00:38:39.280
to get this same result.

00:38:39.280 --> 00:38:42.460
So again, this also comes back
to, I mentioned that libraries

00:38:42.460 --> 00:38:45.490
Zepto.js and jQuery where people
are making these forks.

00:38:45.490 --> 00:38:48.620
Where instead if they were just
writing their code in a

00:38:48.620 --> 00:38:51.590
way that you could eliminate
blocks of code using the

00:38:51.590 --> 00:38:54.330
compiler, then they could share
much more of the common

00:38:54.330 --> 00:38:58.540
code as opposed to having to do
a giant fork, which is much

00:38:58.540 --> 00:39:01.600
harder to keep in sync.

00:39:01.600 --> 00:39:04.070
So if we look, this
is the output

00:39:04.070 --> 00:39:05.410
of the Closure Compiler.

00:39:05.410 --> 00:39:07.920
It's very, very compact.

00:39:07.920 --> 00:39:10.410
I was at the JavaScript
conference last week and

00:39:10.410 --> 00:39:12.860
someone made the astute
remark of, I don't

00:39:12.860 --> 00:39:13.760
want to be a compiler.

00:39:13.760 --> 00:39:15.670
I want a compiler to
be a compiler.

00:39:15.670 --> 00:39:18.630
And I think that's
a good adage.

00:39:18.630 --> 00:39:20.750
But right now we see a lot of
people just trying to use

00:39:20.750 --> 00:39:23.300
short variable names and some
other things and trying to do

00:39:23.300 --> 00:39:24.040
it all by hand.

00:39:24.040 --> 00:39:28.100
But no one is going to write
this type of code by hand,

00:39:28.100 --> 00:39:30.190
even though this is really
what we want

00:39:30.190 --> 00:39:31.780
produced at the outset.

00:39:31.780 --> 00:39:35.260
And as your application gets
larger and larger, it's even

00:39:35.260 --> 00:39:35.900
more important.

00:39:35.900 --> 00:39:37.840
Because you can imagine, with
that example of five script

00:39:37.840 --> 00:39:41.550
tags, you can imagine someone
growing their application to

00:39:41.550 --> 00:39:43.820
be 20 script tags and then
someone copy-pastes it because

00:39:43.820 --> 00:39:46.640
they think it's what they need
for their next project.

00:39:46.640 --> 00:39:50.730
It's just not a way to do large
JavaScript development.

00:39:50.730 --> 00:39:52.930
Especially when it's really
important that something

00:39:52.930 --> 00:39:57.470
really compact, like what you
see here, is the result.

00:39:57.470 --> 00:39:59.630
Another important thing to think
about as well is that,

00:39:59.630 --> 00:40:02.520
as our applications are getting
larger in JavaScript,

00:40:02.520 --> 00:40:06.280
that there's a lot more IP,
intellectual property, that's

00:40:06.280 --> 00:40:07.480
going into these things
that we are

00:40:07.480 --> 00:40:09.590
sending down to our users.

00:40:09.590 --> 00:40:13.110
And if you've built a very large
JavaScript application,

00:40:13.110 --> 00:40:16.790
and now say, you're putting it
in the Chrome Web Store or

00:40:16.790 --> 00:40:18.520
various other places, you don't
want to be giving your

00:40:18.520 --> 00:40:20.830
source code away, necessarily.

00:40:20.830 --> 00:40:23.330
So even though it's not the
primary goal the of the

00:40:23.330 --> 00:40:26.150
Compiler, it also effectively
serves as an obfuscator.

00:40:26.150 --> 00:40:28.860
It makes it much more difficult
for someone to take

00:40:28.860 --> 00:40:32.310
the code that they get and then
add their own features to

00:40:32.310 --> 00:40:33.860
it and then claim
it as their own.

00:40:33.860 --> 00:40:36.570
So that's another aspect, I
think, that's kind of unique

00:40:36.570 --> 00:40:40.500
to development in the large
right now, is that the bulk of

00:40:40.500 --> 00:40:41.740
the code is so much
more interesting.

00:40:41.740 --> 00:40:44.190
It took you so much more time
to build up, if you're doing

00:40:44.190 --> 00:40:47.310
it for business reasons, that
you need to have a better way

00:40:47.310 --> 00:40:48.600
to protect it.

00:40:51.910 --> 00:40:55.610
Also, as I mentioned, there's
no type system built into

00:40:55.610 --> 00:40:56.670
JavaScript natively.

00:40:56.670 --> 00:41:00.190
So one of the better ways to
approximate it is by using

00:41:00.190 --> 00:41:01.790
basically something
like annotations.

00:41:01.790 --> 00:41:02.850
And this is what we see here.

00:41:02.850 --> 00:41:07.280
We have some JS stock, as we
call it, and where we have--

00:41:07.280 --> 00:41:09.940
we have app param tags
like you're kind of

00:41:09.940 --> 00:41:11.630
accustomed to from Java.

00:41:11.630 --> 00:41:13.780
But then the thing in curly
braces is what's called a type

00:41:13.780 --> 00:41:14.300
expression.

00:41:14.300 --> 00:41:18.440
And it basically says, this is
the valid types that can be

00:41:18.440 --> 00:41:19.930
passed in for this argument.

00:41:19.930 --> 00:41:22.840
We also have this annotation
for a constructor.

00:41:22.840 --> 00:41:27.340
So that basically says that, if
the compiler sees you using

00:41:27.340 --> 00:41:29.590
this LatLng function but not
using it with the new key

00:41:29.590 --> 00:41:30.570
word, it will yell at you.

00:41:30.570 --> 00:41:32.980
Because it recognizes that
this is the constructor.

00:41:32.980 --> 00:41:34.960
It's something that's meant
to be instantiated.

00:41:34.960 --> 00:41:38.210
It's not an ordinary function.

00:41:38.210 --> 00:41:42.530
Similarly there's also this
app private annotation.

00:41:42.530 --> 00:41:45.180
And it's not on by default but
you can add a check to the

00:41:45.180 --> 00:41:48.530
Compiler that says, make sure
all accesses to something

00:41:48.530 --> 00:41:52.010
annotated with app private are
only done from what's inside a

00:41:52.010 --> 00:41:53.790
Closure class.

00:41:53.790 --> 00:41:57.020
So again, as opposed to creating
those somewhat clunky

00:41:57.020 --> 00:42:01.020
closures, now you have a way
that better communicates what

00:42:01.020 --> 00:42:02.490
you're trying to do, much
more succinctly by

00:42:02.490 --> 00:42:03.890
just saying app private.

00:42:03.890 --> 00:42:07.130
It also eliminates that run time
overhead, you had before,

00:42:07.130 --> 00:42:09.150
of creating a closure.

00:42:09.150 --> 00:42:12.950
Now instead of calling a getter
method, the Compiler

00:42:12.950 --> 00:42:15.330
can change those getter methods
into direct property

00:42:15.330 --> 00:42:18.470
look ups, it can in line them,
and this can further reduce

00:42:18.470 --> 00:42:20.300
code size and improve run
time performance.

00:42:23.130 --> 00:42:29.630
Also that these type
expressions, they also enable

00:42:29.630 --> 00:42:30.480
static typing.

00:42:30.480 --> 00:42:34.200
So the Compiler also has logic
to enforce your types.

00:42:34.200 --> 00:42:35.900
So just something that you're
accustomed from the Java

00:42:35.900 --> 00:42:39.055
compiler or any other very
strongly typed language, this

00:42:39.055 --> 00:42:42.010
is something that you can turn
on and have it check to make

00:42:42.010 --> 00:42:43.200
sure that the contracts
that you've

00:42:43.200 --> 00:42:44.770
declared are being honored.

00:42:44.770 --> 00:42:48.630
It actually is able to work with
partial type information

00:42:48.630 --> 00:42:50.480
in that you may not
document the types

00:42:50.480 --> 00:42:51.720
for all your functions.

00:42:51.720 --> 00:42:54.480
But where you do, the compiler
will leverage it and where you

00:42:54.480 --> 00:42:57.390
don't, it'll basically
make a best effort.

00:42:57.390 --> 00:42:59.260
But it shouldn't return
false positives.

00:43:02.280 --> 00:43:04.900
Finally there's a rich type
expression language.

00:43:04.900 --> 00:43:08.770
So as I mentioned before, we
often see things where someone

00:43:08.770 --> 00:43:10.310
just declares a callback.

00:43:10.310 --> 00:43:12.910
Now there's actually a standard
way, or at least from

00:43:12.910 --> 00:43:15.500
the perspective of the Closure
Compiler, so that you can say,

00:43:15.500 --> 00:43:18.680
this is a function that takes a
LatLng object, which may be

00:43:18.680 --> 00:43:21.390
null, which is what the question
mark at the front of

00:43:21.390 --> 00:43:22.610
that LatLng signifies.

00:43:22.610 --> 00:43:26.030
You can also specify if it's a
var function, the type of its

00:43:26.030 --> 00:43:26.640
return type.

00:43:26.640 --> 00:43:29.450
This one didn't happen to
have a return type.

00:43:29.450 --> 00:43:32.020
And this is a win, both for
the Compiler, because it's

00:43:32.020 --> 00:43:35.700
able to do type checking
on more complex

00:43:35.700 --> 00:43:37.570
expressions like functions.

00:43:37.570 --> 00:43:40.650
But also for your developers,
because they can go and run

00:43:40.650 --> 00:43:41.930
through the code and look
really quickly.

00:43:41.930 --> 00:43:44.320
Like, oh I just need to pass a
function that takes a LatLng?

00:43:44.320 --> 00:43:45.130
Excellent.

00:43:45.130 --> 00:43:48.810
As opposed to having to dig
through the code to figure out

00:43:48.810 --> 00:43:52.270
exactly what it does.

00:43:52.270 --> 00:43:55.830
So to try to bring all together,
JavaScript code

00:43:55.830 --> 00:43:57.020
bases are getting larger.

00:43:57.020 --> 00:43:59.500
I think the Chrome Books
announcement today is also

00:43:59.500 --> 00:44:02.840
very exciting in this regard
in that people are going to

00:44:02.840 --> 00:44:04.070
want to make bigger
and bigger apps.

00:44:04.070 --> 00:44:06.340
They're going to have to be in
JavaScript at some level,

00:44:06.340 --> 00:44:09.520
either translated from GWT
or writing them directly.

00:44:09.520 --> 00:44:11.160
Especially if you want
them to work offline.

00:44:11.160 --> 00:44:13.950
Because then all you have
when it works offline is

00:44:13.950 --> 00:44:17.210
JavaScript, HTML and CSS.

00:44:17.210 --> 00:44:24.986
So as we are bringing more
complex applications to the

00:44:24.986 --> 00:44:28.160
web, these code bases are
going to get larger.

00:44:28.160 --> 00:44:30.230
And JavaScript, unfortunately,
was not designed for

00:44:30.230 --> 00:44:31.590
programming in the large.

00:44:31.590 --> 00:44:34.540
And so one way is to try to
escape it and run to another

00:44:34.540 --> 00:44:35.660
programming language.

00:44:35.660 --> 00:44:38.820
But another option is to try to
tame it, so to speak, with

00:44:38.820 --> 00:44:39.980
the Closure tools.

00:44:39.980 --> 00:44:43.140
And that is what, in
my experiences,

00:44:43.140 --> 00:44:45.590
worked quite well.

00:44:45.590 --> 00:44:48.220
And so I encourage you not to
run from JavaScript but to

00:44:48.220 --> 00:44:51.710
give it a big bear
hug instead.

00:44:51.710 --> 00:44:54.990
But use the Closure tools
to tame it so that your

00:44:54.990 --> 00:44:58.660
application can grow but
not grow out of hand.

00:44:58.660 --> 00:44:59.630
So thank you very much.

00:44:59.630 --> 00:45:00.980
And I now have time
for questions.

00:45:00.980 --> 00:45:02.230
[APPLAUSE]

00:45:09.390 --> 00:45:11.640
Yep?

00:45:11.640 --> 00:45:15.310
AUDIENCE: I'm not sure I know
anybody who's starting on a

00:45:15.310 --> 00:45:17.090
really big JavaScript project.

00:45:17.090 --> 00:45:20.050
We already have JavaScript
projects and we're probably

00:45:20.050 --> 00:45:21.630
not using Closure tools.

00:45:21.630 --> 00:45:24.440
Very few people are outside
of Google, I feel like.

00:45:24.440 --> 00:45:27.620
How do you transition a very,
very large project--

00:45:27.620 --> 00:45:29.460
I mean the sort of project that
would actually benefit

00:45:29.460 --> 00:45:30.800
from Closure tools--

00:45:30.800 --> 00:45:34.880
onto it without like, OK well,
we're just going to spend the

00:45:34.880 --> 00:45:37.330
next three months writing
comments?

00:45:37.330 --> 00:45:40.310
MICHAEL BOLIN: So I think,
like any migration, you

00:45:40.310 --> 00:45:42.360
certainly want to
do it in pieces.

00:45:42.360 --> 00:45:45.500
And you obviously don't want to
hold up, prevent yourself

00:45:45.500 --> 00:45:48.510
from making any sort of forward
progress while you're

00:45:48.510 --> 00:45:49.750
in transition.

00:45:49.750 --> 00:45:53.920
So the first thing I would say
is using goog.provide and

00:45:53.920 --> 00:45:57.970
goog.require, having some
scaffolding to express the

00:45:57.970 --> 00:45:59.980
dependencies in your
application.

00:45:59.980 --> 00:46:02.760
I would say that is step one.

00:46:02.760 --> 00:46:08.740
Step two is then, you probably
have some existing logic for

00:46:08.740 --> 00:46:13.080
things like registering event
listeners or array utilities.

00:46:13.080 --> 00:46:16.590
And then I think what you do is
you choose one at a time to

00:46:16.590 --> 00:46:19.230
swap out what your home-brewed
solution with the Closure

00:46:19.230 --> 00:46:22.100
Library equivalent and then
you progressively do that.

00:46:22.100 --> 00:46:24.030
This is also what happened
inside Google.

00:46:24.030 --> 00:46:27.090
The Library didn't exist
forever and we had long

00:46:27.090 --> 00:46:30.320
running applications that
were already built up.

00:46:30.320 --> 00:46:31.220
And it was the same problem.

00:46:31.220 --> 00:46:33.850
Because you don't want to just
copy it all in in one day.

00:46:33.850 --> 00:46:35.880
Because then your application
doubles in size and that's not

00:46:35.880 --> 00:46:37.600
really great for your
users either.

00:46:37.600 --> 00:46:40.050
So I think you definitely want
to stage it and you definitely

00:46:40.050 --> 00:46:41.350
want to pick.

00:46:41.350 --> 00:46:43.500
Create the scaffolding with the
require and provide and

00:46:43.500 --> 00:46:45.970
then move things in
as you go forward.

00:46:45.970 --> 00:46:46.890
AUDIENCE: I should clarify.

00:46:46.890 --> 00:46:49.610
We're already using Dojo
provide and require.

00:46:49.610 --> 00:46:52.080
So we already have something
in place.

00:46:52.080 --> 00:46:53.520
Certainly we could replace
them with googs.

00:46:53.520 --> 00:46:54.410
No problem.

00:46:54.410 --> 00:46:57.830
But it's actually really the
Closure Compiler, which seems

00:46:57.830 --> 00:46:59.690
like it's an all or
nothing thing.

00:46:59.690 --> 00:47:02.450
Like either everything is marked
up with comments so it

00:47:02.450 --> 00:47:04.700
knows what to delete or it
deletes your application.

00:47:07.330 --> 00:47:08.820
MICHAEL BOLIN: As I showed, the
Closure Compiler does have

00:47:08.820 --> 00:47:09.500
different modes.

00:47:09.500 --> 00:47:11.270
So there's simple mode,
for example.

00:47:11.270 --> 00:47:12.500
AUDIENCE: I really want
advanced mode.

00:47:12.500 --> 00:47:14.130
That's where I feel like
I get the big benefit.

00:47:14.130 --> 00:47:15.400
How do I ever get there?

00:47:15.400 --> 00:47:17.360
It's a million miles away.

00:47:17.360 --> 00:47:19.190
MICHAEL BOLIN: I think that
some people in the Dojo

00:47:19.190 --> 00:47:21.320
community, well I'm sure more
than some, are interested in

00:47:21.320 --> 00:47:23.040
this as well.

00:47:23.040 --> 00:47:25.390
Another thing you can do is, the
compiler is open source.

00:47:25.390 --> 00:47:28.670
It is written in Java and it has
its own plugin system such

00:47:28.670 --> 00:47:31.810
that you can write new
compiler passes.

00:47:31.810 --> 00:47:35.100
So if you have a large, if you
feel like your code base is

00:47:35.100 --> 00:47:37.640
too large to migrate, the right
thing to do, or the

00:47:37.640 --> 00:47:39.810
simplest thing to do--
as simple as writing

00:47:39.810 --> 00:47:41.000
compiler code is--

00:47:41.000 --> 00:47:44.090
but is to write your own pass.

00:47:44.090 --> 00:47:45.430
Fortunately the Closure
Compiler has a

00:47:45.430 --> 00:47:46.650
lot of passes already.

00:47:46.650 --> 00:47:48.910
And they're also very
well unit tested.

00:47:48.910 --> 00:47:51.010
So if you break something
it'll be pretty clear.

00:47:51.010 --> 00:47:53.220
And you also have a lot of
sample code to go off.

00:47:53.220 --> 00:47:55.830
So you might want to write your
own pass that understands

00:47:55.830 --> 00:47:57.710
Dojo a bit better.

00:47:57.710 --> 00:48:00.110
And then that may be the best
way for you to leverage it.

00:48:00.110 --> 00:48:01.560
AUDIENCE: So we don't have
a lot of, even Dojo

00:48:01.560 --> 00:48:05.200
doc common in there.

00:48:05.200 --> 00:48:07.644
MICHAEL BOLIN: What
do you have?

00:48:07.644 --> 00:48:08.800
AUDIENCE: We've got comments.

00:48:08.800 --> 00:48:10.290
We've got sort of ordinary
comments.

00:48:10.290 --> 00:48:12.410
But we didn't make type
parameter comments.

00:48:12.410 --> 00:48:13.680
Who would, right?

00:48:13.680 --> 00:48:14.930
What's the point of those?

00:48:17.660 --> 00:48:20.590
MICHAEL BOLIN: Type checking is
an option of the advanced

00:48:20.590 --> 00:48:21.770
mode to get the minification.

00:48:21.770 --> 00:48:23.470
It's not a requirement.

00:48:23.470 --> 00:48:27.420
So you don't have to have
everything marked up with type

00:48:27.420 --> 00:48:30.410
expressions to even use advanced
mode, necessarily.

00:48:30.410 --> 00:48:32.820
It's more helpful if you do but
it's not a hard and fast

00:48:32.820 --> 00:48:34.130
requirement.

00:48:34.130 --> 00:48:37.390
AUDIENCE: Can I, if I have
half my code marked up--

00:48:37.390 --> 00:48:40.250
or really, a hundredth of my
code marked up with type

00:48:40.250 --> 00:48:42.160
parameters can I use
that at all?

00:48:42.160 --> 00:48:43.260
MICHAEL BOLIN: Yeah,
absolutely.

00:48:43.260 --> 00:48:46.970
So basically every time omit a
type expression, it assumes

00:48:46.970 --> 00:48:48.760
that the type expression would
be asterisk, which

00:48:48.760 --> 00:48:50.310
means the any type.

00:48:50.310 --> 00:48:54.250
And so it already has
mechanisms to

00:48:54.250 --> 00:48:55.360
deal with that situation.

00:48:55.360 --> 00:48:58.440
AUDIENCE: So if I replaced
all my Dojo requires with

00:48:58.440 --> 00:49:02.670
goog.requires and run the
advanced Compiler, what's

00:49:02.670 --> 00:49:03.200
about to happen?

00:49:03.200 --> 00:49:04.600
It's going to delete
my [? location ?]

00:49:04.600 --> 00:49:04.730
right?

00:49:04.730 --> 00:49:06.280
MICHAEL BOLIN: There are some
other caveats that are

00:49:06.280 --> 00:49:08.440
actually well documented
on the website.

00:49:08.440 --> 00:49:11.490
In terms of things like quoting
properties, is a

00:49:11.490 --> 00:49:13.940
common one.

00:49:13.940 --> 00:49:16.010
That's probably the biggest one
off the top of my head.

00:49:16.010 --> 00:49:18.760
But I think most Dojo code
is pretty similar.

00:49:18.760 --> 00:49:22.820
So I don't think it would be a
disaster but there's a very

00:49:22.820 --> 00:49:25.980
good page on code.google.com
that says hazards of using

00:49:25.980 --> 00:49:26.573
advanced mode.

00:49:26.573 --> 00:49:28.280
And it should help you
audit your code for

00:49:28.280 --> 00:49:29.470
those types of things.

00:49:29.470 --> 00:49:32.060
AUDIENCE: Thanks.

00:49:32.060 --> 00:49:33.030
AUDIENCE: Hi.

00:49:33.030 --> 00:49:36.220
We have a pretty big
JavaScript project.

00:49:36.220 --> 00:49:38.590
Probably a couple megs of
source or something.

00:49:38.590 --> 00:49:39.430
Big project.

00:49:39.430 --> 00:49:42.310
But we switched over to the
Closure Compiler last summer

00:49:42.310 --> 00:49:43.550
and we've been totally
thrilled with it.

00:49:43.550 --> 00:49:47.440
But this is the first time
we've seen the Templates.

00:49:47.440 --> 00:49:49.960
And I think it's something
we're interested in.

00:49:49.960 --> 00:49:52.780
I am curious-- because it looks
like you have to run a

00:49:52.780 --> 00:49:56.100
compiler pass just to use them--
is there any, so I

00:49:56.100 --> 00:49:59.190
know, like, we're using the
advanced mode compilation but

00:49:59.190 --> 00:50:00.765
you can run it uncompiled
and the

00:50:00.765 --> 00:50:04.260
goog.requires just do XHR requests.

00:50:04.260 --> 00:50:06.030
Get the code and eval
them and stuff.

00:50:06.030 --> 00:50:08.630
Is there an equivalent for those
templates, that you can

00:50:08.630 --> 00:50:10.470
run them straight from source?

00:50:10.470 --> 00:50:12.980
Because at this point, running
the compiler takes some time.

00:50:12.980 --> 00:50:15.790
Because it's a big project.

00:50:15.790 --> 00:50:18.720
MICHAEL BOLIN: So built a
tool, for some reason I

00:50:18.720 --> 00:50:19.890
neglected to put it
in my slides.

00:50:19.890 --> 00:50:22.020
It's called Plovr.

00:50:22.020 --> 00:50:25.020
My O'Riley animal is the golden
plover, so I named my

00:50:25.020 --> 00:50:27.620
tool Plovr, without an e because
I wanted to be cool

00:50:27.620 --> 00:50:28.790
like Flickr.

00:50:28.790 --> 00:50:33.670
But if you take a look, what it
does is it has some modes

00:50:33.670 --> 00:50:36.450
that basically you can just
point it at a directory of

00:50:36.450 --> 00:50:40.030
JavaScript in Closure Templates
files and it will

00:50:40.030 --> 00:50:41.930
just spin up and serve
them from disk.

00:50:41.930 --> 00:50:46.390
And the JS ones it will serve
verbatim and the dot.soi files

00:50:46.390 --> 00:50:49.330
for Closure Templates, it'll
translate them on the fly.

00:50:49.330 --> 00:50:52.870
So you're development, you can
still debug what is basically

00:50:52.870 --> 00:50:56.520
raw code but not have to run the
compiler over everything

00:50:56.520 --> 00:50:57.200
to get that.

00:50:57.200 --> 00:50:58.695
Because I understand that
for larger code

00:50:58.695 --> 00:51:00.260
bases it is a bit slower.

00:51:00.260 --> 00:51:00.670
AUDIENCE: OK.

00:51:00.670 --> 00:51:00.850
Cool.

00:51:00.850 --> 00:51:02.100
Thanks.

00:51:04.580 --> 00:51:06.200
AUDIENCE: I actually have
two questions for you.

00:51:06.200 --> 00:51:09.514
The first question is about
browser native functionality.

00:51:09.514 --> 00:51:12.630
The Closure Compiler, is it
smart enough to detect that

00:51:12.630 --> 00:51:13.570
kind of functionality?

00:51:13.570 --> 00:51:17.020
And then, if so, when new
browser-capable features come

00:51:17.020 --> 00:51:20.587
out, what's the delay time
between the library being

00:51:20.587 --> 00:51:25.780
updated versus not and being
able to support those.

00:51:25.780 --> 00:51:27.030
MICHAEL BOLIN: That's
a good question.

00:51:29.200 --> 00:51:30.600
So basically you're writing
in JavaScript.

00:51:30.600 --> 00:51:33.760
So if it's there you can you
test in JavaScript as you

00:51:33.760 --> 00:51:34.580
normally would.

00:51:34.580 --> 00:51:37.470
You could say, if document.body
query selector

00:51:37.470 --> 00:51:39.250
all and then do one thing.

00:51:39.250 --> 00:51:41.290
And if not, do another thing.

00:51:41.290 --> 00:51:43.770
But there's also this idea,
when using the compiler in

00:51:43.770 --> 00:51:45.870
advanced mode, this idea of
what's called externs.

00:51:45.870 --> 00:51:48.560
Where you basically say, these
are all the symbols that are

00:51:48.560 --> 00:51:50.450
going to exist in the
environment in which my code

00:51:50.450 --> 00:51:52.530
runs and their type
definitions.

00:51:52.530 --> 00:51:54.590
So document and window and
that sort of thing.

00:51:54.590 --> 00:51:57.270
Because as you saw, the Closure
Compiler renamed a

00:51:57.270 --> 00:51:58.260
whole bunch of variables.

00:51:58.260 --> 00:51:59.700
But it can't rename the
built-ins, like

00:51:59.700 --> 00:52:02.490
document and window.

00:52:02.490 --> 00:52:05.870
So when you're talking about
browser features, those are

00:52:05.870 --> 00:52:09.250
usually listed in these externs
files that declare

00:52:09.250 --> 00:52:11.300
basically what's in the
browser environment.

00:52:11.300 --> 00:52:15.490
Those are updated pretty
quickly, I would say.

00:52:15.490 --> 00:52:17.280
Because a lot of projects,
people

00:52:17.280 --> 00:52:19.160
are pushing the envelope.

00:52:19.160 --> 00:52:21.640
In that sense the compiler,
the time between a feature

00:52:21.640 --> 00:52:24.590
coming out to being used by the
Compiler, or available or

00:52:24.590 --> 00:52:28.420
recognized by the compiler
is pretty small.

00:52:28.420 --> 00:52:30.650
AUDIENCE: My second question
was about development.

00:52:30.650 --> 00:52:33.466
It looks like you don't get that
minified code until after

00:52:33.466 --> 00:52:35.980
you've run through the compiler,
which makes sense.

00:52:35.980 --> 00:52:38.900
When I'm doing actual
development and I'm debugging

00:52:38.900 --> 00:52:41.530
with Firebug or Chrome's
developer tools, do I have to

00:52:41.530 --> 00:52:44.750
load up all 150 or whatever
megabyte of

00:52:44.750 --> 00:52:47.590
those library files?

00:52:47.590 --> 00:52:49.890
MICHAEL BOLIN: It depends
how you do it.

00:52:49.890 --> 00:52:52.220
So one thing you can also do
with the Closure Compiler,

00:52:52.220 --> 00:52:54.640
which I didn't demonstrate
today, is you can have this

00:52:54.640 --> 00:52:55.540
idea modules.

00:52:55.540 --> 00:52:59.670
So GWT has this idea of code
splitting, where you can say

00:52:59.670 --> 00:53:02.070
when I'm only using up to this
feature, then only include

00:53:02.070 --> 00:53:03.180
these JavaScript files.

00:53:03.180 --> 00:53:05.740
And then if the user starts
using this other feature, then

00:53:05.740 --> 00:53:07.650
pull down these other files.

00:53:07.650 --> 00:53:11.600
So one really good technique is
to use this modules feature

00:53:11.600 --> 00:53:13.950
of the compiler, which
ultimately will compile

00:53:13.950 --> 00:53:18.490
optimized version of each of
those clumps of code and will

00:53:18.490 --> 00:53:21.090
depend on the symbols that
exist in the code that's

00:53:21.090 --> 00:53:22.010
already loaded.

00:53:22.010 --> 00:53:25.050
So basically, you're only
loading the minimal set of

00:53:25.050 --> 00:53:28.190
files for the functionality
you need right now as the

00:53:28.190 --> 00:53:30.240
user, say, goes to the
settings page.

00:53:30.240 --> 00:53:32.910
And now the settings code,
now it'll pull that down,

00:53:32.910 --> 00:53:35.360
basically on demand.

00:53:35.360 --> 00:53:36.730
And this works in
development too.

00:53:36.730 --> 00:53:38.460
So it will only be the
individual files that

00:53:38.460 --> 00:53:41.890
contribute to, what I'm
calling a module.

00:53:41.890 --> 00:53:45.360
So, no, you don't have to
necessarily load everything

00:53:45.360 --> 00:53:46.910
when you start up.

00:53:46.910 --> 00:53:48.160
AUDIENCE: Thanks.

00:53:50.480 --> 00:53:51.330
AUDIENCE: Does this one work?

00:53:51.330 --> 00:53:51.600
MICHAEL BOLIN: Sorry.

00:53:51.600 --> 00:53:52.220
I didn't see you.

00:53:52.220 --> 00:53:53.490
The lights are bright.

00:53:53.490 --> 00:53:54.590
AUDIENCE: This relates to
the first question.

00:53:54.590 --> 00:53:57.930
You had that one slide, where
you had the prototype with the

00:53:57.930 --> 00:54:01.480
dollar sign w, I've used Closure
to do some newer

00:54:01.480 --> 00:54:02.630
projects, but I have
a lot of legacy

00:54:02.630 --> 00:54:06.260
projects with Prototype.

00:54:06.260 --> 00:54:10.230
Will the compiler deal with
those types of commands, to

00:54:10.230 --> 00:54:10.830
compile them down?

00:54:10.830 --> 00:54:13.060
Or do you have to pretty much
remove all the Prototype to

00:54:13.060 --> 00:54:14.840
get the compiler to work?

00:54:14.840 --> 00:54:15.210
MICHAEL BOLIN: Well no.

00:54:15.210 --> 00:54:18.470
So if you supply the Prototype
source code as an input to the

00:54:18.470 --> 00:54:20.990
compiler, it will treat it
like any other input.

00:54:20.990 --> 00:54:22.160
And also if--

00:54:22.160 --> 00:54:24.530
so unused functions will then
also still go away.

00:54:24.530 --> 00:54:27.320
And interestingly, if you have
a function that you use a lot

00:54:27.320 --> 00:54:31.040
in the Closure Library and it
has a very verbose name, the

00:54:31.040 --> 00:54:34.420
compiler will pick the smallest
names for the

00:54:34.420 --> 00:54:37.490
functions that are used the
most. So possibly your

00:54:37.490 --> 00:54:39.640
prototype functions could get
renamed to longer things,

00:54:39.640 --> 00:54:41.990
although they're only two bytes
so it's probably not.

00:54:41.990 --> 00:54:44.350
Actually it would be longer.

00:54:44.350 --> 00:54:45.680
But basically, sorry,
the short answer to

00:54:45.680 --> 00:54:46.660
your question is yes.

00:54:46.660 --> 00:54:49.170
You can use the Prototype
code with the compiler.

00:54:51.680 --> 00:54:53.700
AUDIENCE: So one of the most fun
things in the world about

00:54:53.700 --> 00:54:57.390
doing JavaScript is after you've
minified it, that you

00:54:57.390 --> 00:55:00.720
get a bug report
from the field.

00:55:00.720 --> 00:55:04.070
So is there an equivalent to a
symbol table or something that

00:55:04.070 --> 00:55:08.190
could be added in say, a
less-than perfectly optimized?

00:55:08.190 --> 00:55:09.860
MICHAEL BOLIN: Yep.

00:55:09.860 --> 00:55:12.440
So basically there's an option,
when you run the

00:55:12.440 --> 00:55:15.110
compiler, to output as a
byproduct, a thing called a

00:55:15.110 --> 00:55:16.040
source map.

00:55:16.040 --> 00:55:19.480
And so it is a reverse mapping,
it's actually every

00:55:19.480 --> 00:55:22.860
line and character in your
compiled code, to the line and

00:55:22.860 --> 00:55:27.310
character position in the
original source code.

00:55:27.310 --> 00:55:31.700
And then there's some other
Java code that's there for

00:55:31.700 --> 00:55:34.450
taking a JavaScript stack trace
from the server and

00:55:34.450 --> 00:55:38.450
converting it into an obfuscated
JavaScript file.

00:55:38.450 --> 00:55:43.000
The only caveat is that, you
really care about the line and

00:55:43.000 --> 00:55:43.710
the character offset.

00:55:43.710 --> 00:55:46.010
And I believe right now, only
Chrome-- and I guess probably

00:55:46.010 --> 00:55:47.130
then Safari--

00:55:47.130 --> 00:55:48.560
provide both the line
and the character.

00:55:48.560 --> 00:55:51.340
Most of the other browsers
only do the line.

00:55:51.340 --> 00:55:54.200
I haven't checked Firefox 4, but
at least Firefox 3.6 still

00:55:54.200 --> 00:55:55.790
only sent the line number.

00:55:55.790 --> 00:55:59.940
So if anyone has influence over
any of those folks, it'd

00:55:59.940 --> 00:56:01.680
be great if they also sent
character offsets.

00:56:01.680 --> 00:56:04.580
Because, to exactly the point
that you're making.

00:56:07.322 --> 00:56:10.760
AUDIENCE: Is Closure planning to
implement the common module

00:56:10.760 --> 00:56:14.460
dependency, CommonJS standard?

00:56:14.460 --> 00:56:15.260
MICHAEL BOLIN: That's
a good question.

00:56:15.260 --> 00:56:17.580
So there is no plan
and there's no

00:56:17.580 --> 00:56:19.620
anti-plan as far as I know.

00:56:19.620 --> 00:56:22.770
In that they're not hating on
it and they maybe haven't

00:56:22.770 --> 00:56:26.110
figured out exactly how to
merge the two worlds.

00:56:26.110 --> 00:56:31.060
I think, if there were a good
proposal put forth on how to

00:56:31.060 --> 00:56:34.140
combine those two things, I
think the people who work on

00:56:34.140 --> 00:56:35.420
Closure would be
very interested

00:56:35.420 --> 00:56:37.130
in making that happen.

00:56:37.130 --> 00:56:38.430
AUDIENCE: Are you still
working on Closure?

00:56:38.430 --> 00:56:40.210
Or is that something Google
works on and you

00:56:40.210 --> 00:56:41.080
don't work on anymore.

00:56:41.080 --> 00:56:43.650
MICHAEL BOLIN: I contribute
to Closure for sure.

00:56:43.650 --> 00:56:46.680
And I certainly talk
to those folks.

00:56:46.680 --> 00:56:49.240
We had a discussion just last
week about it and it was kind

00:56:49.240 --> 00:56:52.600
of like, one of the many items
on the list. It's certainly

00:56:52.600 --> 00:56:55.650
something that we'd like to
address but it hasn't bubbled

00:56:55.650 --> 00:56:56.900
to the top yet.

00:57:00.326 --> 00:57:01.760
Anybody else?

00:57:01.760 --> 00:57:03.340
Thank you, everyone.

00:57:03.340 --> 00:57:05.360
I hope you enjoy Google I/O.

