WEBVTT
Kind: captions
Language: en

00:00:00.340 --> 00:00:01.390
RICHARD HYNDMAN: Oh, this
is definitely on.

00:00:01.390 --> 00:00:02.000
Hi there.

00:00:02.000 --> 00:00:05.120
And welcome to this talk on
Bluetooth best practices.

00:00:05.120 --> 00:00:06.500
My name is Richard Hyndman.

00:00:06.500 --> 00:00:08.050
I'm on the Android team.

00:00:08.050 --> 00:00:09.370
And I head up Android Developer

00:00:09.370 --> 00:00:10.990
Relations for Europe.

00:00:10.990 --> 00:00:12.120
SCOUT SINCLAIR BRODY: I'm
Scout Sinclair Brody.

00:00:12.120 --> 00:00:14.980
I'm a product manager on
the Android platform.

00:00:14.980 --> 00:00:16.200
MATTHEW XIE: Hi.

00:00:16.200 --> 00:00:19.050
My name is Matthew Xie.

00:00:19.050 --> 00:00:21.580
I'm the Android tech
lead for Bluetooth.

00:00:21.580 --> 00:00:24.460
RICHARD HYNDMAN: OK, let's get
this show on the road.

00:00:24.460 --> 00:00:26.570
So thank you all for
coming today.

00:00:26.570 --> 00:00:28.550
I'm pretty sure that some of
you out there must have

00:00:28.550 --> 00:00:31.095
suffered at the hands of
this technology before.

00:00:31.095 --> 00:00:32.140
Yeah, right.

00:00:32.140 --> 00:00:32.850
We all have.

00:00:32.850 --> 00:00:34.740
So thank you very much for
coming along, being

00:00:34.740 --> 00:00:37.060
open-minded, and listening to
what we have to say about

00:00:37.060 --> 00:00:39.500
Android on Bluetooth today.

00:00:39.500 --> 00:00:41.790
So, picture the scene.

00:00:41.790 --> 00:00:42.860
The year is--

00:00:42.860 --> 00:00:43.860
who can get the year?

00:00:43.860 --> 00:00:46.190
First person?

00:00:46.190 --> 00:00:46.310
Sorry?

00:00:46.310 --> 00:00:47.430
AUDIENCE: [INAUDIBLE]

00:00:47.430 --> 00:00:48.290
RICHARD HYNDMAN: No.

00:00:48.290 --> 00:00:49.390
1994.

00:00:49.390 --> 00:00:50.100
It's quite a tricky one.

00:00:50.100 --> 00:00:51.770
It's a bad year for
Roman numerals.

00:00:51.770 --> 00:00:54.850
But the people over at Ericsson
were sick and tired

00:00:54.850 --> 00:00:57.620
of having to reach around to the
back of their computers to

00:00:57.620 --> 00:00:59.190
plug-in their serial cables.

00:00:59.190 --> 00:01:00.780
They tried turning their
computers around.

00:01:00.780 --> 00:01:02.190
But then the power buttons
were on the wrong side.

00:01:02.190 --> 00:01:05.519
So like any good '90s innovative
company, they

00:01:05.519 --> 00:01:08.310
decided to reinvent
the whole system.

00:01:08.310 --> 00:01:11.270
And they came up with Bluetooth,
as we know, for

00:01:11.270 --> 00:01:12.900
wirelessly connecting devices,

00:01:12.900 --> 00:01:16.200
peer-to-peer over short ranges.

00:01:16.200 --> 00:01:19.990
Bluetooth's named after Harold
Blatand Gormsson, Blatand

00:01:19.990 --> 00:01:21.970
being "blue tooth" in English.

00:01:21.970 --> 00:01:25.430
He was a Danish King that united
tribes together without

00:01:25.430 --> 00:01:26.790
the use of serial cables.

00:01:26.790 --> 00:01:28.160
So that was kind of handy.

00:01:28.160 --> 00:01:29.950
It's a good name for
the technology.

00:01:29.950 --> 00:01:32.170
So you get the H from Harold--
it's a rune--, and the rune

00:01:32.170 --> 00:01:34.440
for B. Put them together, and
you get this bindrune that's

00:01:34.440 --> 00:01:37.260
the Bluetooth logo.

00:01:37.260 --> 00:01:38.800
We've had Bluetooth
on Android--

00:01:38.800 --> 00:01:39.820
there he is--

00:01:39.820 --> 00:01:41.220
since version 1.0.

00:01:41.220 --> 00:01:43.050
That's my favorite animation
all deck.

00:01:43.050 --> 00:01:46.660
And we had Bluetooth 2.0
with the EDR stack--

00:01:46.660 --> 00:01:51.930
headset profile, handset
profile, but no real APIs.

00:01:51.930 --> 00:01:55.520
So you can use Classic Bluetooth
to connect music to

00:01:55.520 --> 00:01:58.940
music players, mice to
laptops, or mice with

00:01:58.940 --> 00:02:00.310
headphones to anything
you want.

00:02:00.310 --> 00:02:03.620
But the point is, these things
need to be able to talk to

00:02:03.620 --> 00:02:03.890
each other.

00:02:03.890 --> 00:02:05.600
The need to be able to
discover each other.

00:02:05.600 --> 00:02:06.510
They need to be able
to connect.

00:02:06.510 --> 00:02:09.169
And they need to be able to
talk a common language.

00:02:09.169 --> 00:02:12.660
And for that, they're going
to need a Bluetooth stack.

00:02:12.660 --> 00:02:14.340
So what's a Bluetooth stack?

00:02:14.340 --> 00:02:17.100
A Bluetooth stack is an
implementation of the

00:02:17.100 --> 00:02:20.030
Bluetooth Core Specification.

00:02:20.030 --> 00:02:22.890
On the bottom of it, you've got
the RF Transceiver doing

00:02:22.890 --> 00:02:24.390
the actual wireless
communications.

00:02:24.390 --> 00:02:26.210
Above that, you've got the
Baseband controlling the

00:02:26.210 --> 00:02:27.190
Transceiver.

00:02:27.190 --> 00:02:30.100
Above that, you've got
the Protocol Stack.

00:02:30.100 --> 00:02:31.390
Lots and lots of protocols
all going into

00:02:31.390 --> 00:02:32.670
there, so you can talk.

00:02:32.670 --> 00:02:35.520
Lots of different types of
communication between any two

00:02:35.520 --> 00:02:37.590
Bluetooth devices.

00:02:37.590 --> 00:02:39.690
So this is a Bluetooth stack.

00:02:39.690 --> 00:02:43.600
And then on top of that, you
have your Bluetooth Profiles.

00:02:43.600 --> 00:02:45.000
Bluetooth Profiles are
definitions of--

00:02:45.000 --> 00:02:48.160
[MICROPHONE FEEDBACK]

00:02:48.160 --> 00:02:50.450
Bluetooth Profiles are
definitions of which parts of

00:02:50.450 --> 00:02:53.320
the Bluetooth stack are required
for doing each type

00:02:53.320 --> 00:02:55.190
of communication.

00:02:55.190 --> 00:02:57.670
Bluetooth Profiles generally
aren't tied in to any specific

00:02:57.670 --> 00:02:59.130
version of the stack.

00:02:59.130 --> 00:03:00.040
They're just definitions--

00:03:00.040 --> 00:03:01.360
which codex you need,
which parts of the

00:03:01.360 --> 00:03:03.330
stack do you need.

00:03:03.330 --> 00:03:05.580
So when you see versions of
Bluetooth, you're looking at

00:03:05.580 --> 00:03:07.810
versions of the core
specification.

00:03:07.810 --> 00:03:11.350
Version 1, version 1.1, which
was 802.15, the Bluetooth spec

00:03:11.350 --> 00:03:12.920
was running about a
megabit a second.

00:03:12.920 --> 00:03:15.650
Version 2 went up to about
three mega second.

00:03:15.650 --> 00:03:17.280
The little + EDR means
in Enhanced

00:03:17.280 --> 00:03:19.150
Data Rate is optional.

00:03:19.150 --> 00:03:22.150
Version 3, they claim, was
around 24 megabits a second.

00:03:22.150 --> 00:03:23.540
Not sure I ever got
that out of it.

00:03:23.540 --> 00:03:28.840
With the + HS for plus High
Speed is an 802.11 Wi-Fi link.

00:03:28.840 --> 00:03:32.320
Which brings us up
to version 4.

00:03:32.320 --> 00:03:35.040
Let's just say there have been
many, many different Bluetooth

00:03:35.040 --> 00:03:37.610
stack implementations.

00:03:37.610 --> 00:03:44.650
In Android, we've had the BlueZ
stack, powering AOSP

00:03:44.650 --> 00:03:49.610
devices, Samsung and HTC
devices, Sony Xperias.

00:03:49.610 --> 00:03:52.010
We've also had the Older
Broadcom Stack.

00:03:52.010 --> 00:03:54.850
Some of the HTC before Ice
Cream Sandwich devices.

00:03:54.850 --> 00:03:56.550
We've got a Motorola Bluetooth
Stack for all

00:03:56.550 --> 00:03:57.600
host Motorola devices.

00:03:57.600 --> 00:03:58.740
And then some others as well.

00:03:58.740 --> 00:04:00.620
And of course, these
are all compatible.

00:04:00.620 --> 00:04:02.090
But software has bugs in it.

00:04:02.090 --> 00:04:03.410
We know that software
has bugs in it.

00:04:03.410 --> 00:04:06.040
So potentially, you have to work
around different issues,

00:04:06.040 --> 00:04:07.320
just little things here
and there with all

00:04:07.320 --> 00:04:09.030
the different stacks.

00:04:09.030 --> 00:04:11.740
And whilst we've had all these
different stacks, the Android

00:04:11.740 --> 00:04:14.510
APIs that have been available to
developers and the Android

00:04:14.510 --> 00:04:16.480
Bluetooth functionality
available to consumers has

00:04:16.480 --> 00:04:19.810
also been changing throughout
the history of Bluetooth.

00:04:19.810 --> 00:04:22.710
Matt's just going to run through
quickly the different

00:04:22.710 --> 00:04:26.540
APIs we've had on Bluetooth
through the years.

00:04:26.540 --> 00:04:27.520
MATTHEW XIE: Yeah, hi.

00:04:27.520 --> 00:04:32.760
I'm going to just go over
Android Bluetooth versions

00:04:32.760 --> 00:04:35.340
features APIs a little
quickly.

00:04:35.340 --> 00:04:41.030
So as you know, Android
loves desserts.

00:04:41.030 --> 00:04:46.135
So you could say we have
a real sweet Bluetooth.

00:04:49.040 --> 00:04:54.580
Starting at the beginning,
we included Bluetooth.

00:04:54.580 --> 00:05:01.480
So Android 1.0, we have
Bluetooth 2.0 with a headset

00:05:01.480 --> 00:05:03.270
and hands-free profile.

00:05:03.270 --> 00:05:06.740
So you can make a phone call
using your Bluetooth headset

00:05:06.740 --> 00:05:09.350
[INAUDIBLE].

00:05:09.350 --> 00:05:13.420
Now, Cupcake, we have a A2DP.

00:05:13.420 --> 00:05:15.500
You can stream music
over Bluetooth.

00:05:20.210 --> 00:05:22.500
Next is Eclair.

00:05:22.500 --> 00:05:27.570
We have Bluetooth 2.1
with RFCOMM APIs.

00:05:27.570 --> 00:05:34.770
And we also added object push
and the phonebook profiles.

00:05:34.770 --> 00:05:41.910
Then with Froyo, voice dialing
over Bluetooth.

00:05:41.910 --> 00:05:51.110
Honeycomb, we added APIs for
profiles, like A2DP and

00:05:51.110 --> 00:05:53.670
hands-free.

00:05:53.670 --> 00:05:56.280
Honeycomb also added
[INAUDIBLE]

00:05:56.280 --> 00:06:02.930
PAN tethering, which is you
can connect your Bluetooth

00:06:02.930 --> 00:06:12.385
keyboard, mouse, game pad, and
typing instead of doing that

00:06:12.385 --> 00:06:13.750
on your phone.

00:06:13.750 --> 00:06:19.330
And PAN is data tethering so
you can share your internet

00:06:19.330 --> 00:06:22.020
using Bluetooth.

00:06:22.020 --> 00:06:31.050
And ICS added a Health Device
Profile so you can stream your

00:06:31.050 --> 00:06:35.910
medical data real-time
over Bluetooth.

00:06:35.910 --> 00:06:40.450
And then now, it's Jelly Bean.

00:06:40.450 --> 00:06:43.200
Over to Scout.

00:06:43.200 --> 00:06:44.840
SCOUT SINCLAIR BRODY:
So as you may know--

00:06:44.840 --> 00:06:46.600
whoops, went back
for a second.

00:06:46.600 --> 00:06:47.010
Try it again.

00:06:47.010 --> 00:06:48.230
Whoop, too far.

00:06:48.230 --> 00:06:50.080
There we go.

00:06:50.080 --> 00:06:53.980
OK, so as you may
know, in 4.2, we

00:06:53.980 --> 00:06:55.670
introduced a new stack.

00:06:55.670 --> 00:06:58.050
We moved away from BlueZ
to BlueDroid.

00:06:58.050 --> 00:07:00.570
This was a change that was made
possible by a significant

00:07:00.570 --> 00:07:03.760
contribution to AOSP
by Broadcom.

00:07:03.760 --> 00:07:05.810
There were, of course, some
bumps in the road with this

00:07:05.810 --> 00:07:08.060
transition, for which we
certainly apologize.

00:07:08.060 --> 00:07:09.720
But we felt that it
was an important

00:07:09.720 --> 00:07:12.210
move on several levels.

00:07:12.210 --> 00:07:14.740
First, we wanted a stack
that was optimized

00:07:14.740 --> 00:07:16.680
for embedded systems.

00:07:16.680 --> 00:07:20.210
Second, because of conflicting
licensing models, we actually

00:07:20.210 --> 00:07:22.870
had to run BlueZ in its own
process, which certainly had

00:07:22.870 --> 00:07:25.310
performance implications.

00:07:25.310 --> 00:07:28.420
And finally, we really felt that
having stack development

00:07:28.420 --> 00:07:32.160
happen in AOSP would allow
greater overall velocity, in

00:07:32.160 --> 00:07:34.990
terms of adding features and
adding stability and

00:07:34.990 --> 00:07:37.550
performance enhancements
over time.

00:07:37.550 --> 00:07:41.120
So that brings us to a topic
that many folks are interested

00:07:41.120 --> 00:07:43.663
in, which is Bluetooth
Low Energy.

00:07:43.663 --> 00:07:45.136
[APPLAUSE]

00:07:45.136 --> 00:07:47.670
SCOUT SINCLAIR BRODY: Clearly,
there's a lot of excitement

00:07:47.670 --> 00:07:49.790
about this technology.

00:07:49.790 --> 00:07:51.930
And I'm not sure that all of
you are familiar with it.

00:07:51.930 --> 00:07:53.430
So I want to tell you a little
bit about what it

00:07:53.430 --> 00:07:56.030
is and why it exists.

00:07:56.030 --> 00:07:58.530
Bluetooth, as it was originally
conceived, was

00:07:58.530 --> 00:08:01.740
designed to interact, allow
devices with relatively large

00:08:01.740 --> 00:08:04.320
batteries that charge frequently
to interact with

00:08:04.320 --> 00:08:06.050
one another.

00:08:06.050 --> 00:08:09.730
And as Rich mentioned, use cases
for Bluetooth Classic

00:08:09.730 --> 00:08:13.250
typically involved streaming
audio or other high bandwidth

00:08:13.250 --> 00:08:15.480
applications.

00:08:15.480 --> 00:08:18.030
However, the original
specification was a little bit

00:08:18.030 --> 00:08:21.110
heavy for devices that have very
small batteries or that

00:08:21.110 --> 00:08:23.010
you don't want to charge
every day.

00:08:23.010 --> 00:08:25.970
So Bluetooth Low Energy was
designed to work with devices

00:08:25.970 --> 00:08:27.520
in exactly this category.

00:08:27.520 --> 00:08:31.100
Such as proximity tags that you
can attach to your keys to

00:08:31.100 --> 00:08:35.909
help you find them, or
pedometers or fitness or

00:08:35.909 --> 00:08:39.630
medical sensors, or
watches, or game

00:08:39.630 --> 00:08:41.470
controllers, remote controls.

00:08:41.470 --> 00:08:43.409
There are a whole host of
possibilities with this

00:08:43.409 --> 00:08:44.810
technology.

00:08:44.810 --> 00:08:47.690
The goal is to let devices that
run on small batteries

00:08:47.690 --> 00:08:50.260
like these to go for
years at a time

00:08:50.260 --> 00:08:53.050
without being recharged.

00:08:53.050 --> 00:08:55.960
The technology that we
colloquially refer to as

00:08:55.960 --> 00:08:58.430
Bluetooth Low Energy
is actually--

00:08:58.430 --> 00:09:01.680
the official brand name of it,
as propagated by the Bluetooth

00:09:01.680 --> 00:09:05.880
SIG, is Bluetooth SMART for
devices that support just BLE,

00:09:05.880 --> 00:09:11.210
and Bluetooth SMART READY for
devices that support both BLE

00:09:11.210 --> 00:09:13.300
and Bluetooth Classic.

00:09:13.300 --> 00:09:17.060
So you might be wondering why
I'm showing a Nexus 4 here.

00:09:17.060 --> 00:09:19.670
Because, up until this point,
of course, we have not had

00:09:19.670 --> 00:09:21.180
support for Bluetooth
Low Energy

00:09:21.180 --> 00:09:23.550
in the Android platform.

00:09:23.550 --> 00:09:27.170
But today, we are excited to
announce that when Android API

00:09:27.170 --> 00:09:32.540
version 18 is released in a
couple of short months, the

00:09:32.540 --> 00:09:35.570
Nexus 4 and all future Nexus
devices will support Bluetooth

00:09:35.570 --> 00:09:38.130
Low Energy with developer-facing
APIs.

00:09:38.130 --> 00:09:41.630
[APPLAUSE]

00:09:41.630 --> 00:09:44.160
SCOUT SINCLAIR BRODY: So this
means that your apps and your

00:09:44.160 --> 00:09:46.600
peripheral devices can take
full advantage of this

00:09:46.600 --> 00:09:48.710
exciting technology.

00:09:48.710 --> 00:09:50.640
So in a couple of minutes, we're
going to go through a

00:09:50.640 --> 00:09:52.900
couple of code examples, and
you'll get a preview of the

00:09:52.900 --> 00:09:55.280
APIs for Bluetooth Low Energy.

00:09:55.280 --> 00:09:57.710
But I want to give you a bit of
terminology first that will

00:09:57.710 --> 00:09:59.370
help you in understanding
when we walk

00:09:59.370 --> 00:10:01.630
through those examples.

00:10:01.630 --> 00:10:03.680
First off, you should know
that BLE is based on the

00:10:03.680 --> 00:10:06.530
specification called GATT, which
is what your apps will

00:10:06.530 --> 00:10:08.130
actually interface with.

00:10:08.130 --> 00:10:11.010
GATT communicates using the
attribute protocol, which,

00:10:11.010 --> 00:10:14.260
true to its name, transfers data
in the form of attributes

00:10:14.260 --> 00:10:17.450
and operations on those
attributes.

00:10:17.450 --> 00:10:20.140
The most basic type of
attributes are descriptors and

00:10:20.140 --> 00:10:21.230
characteristics.

00:10:21.230 --> 00:10:24.600
A descriptor, also true to its
name, is just a descriptive

00:10:24.600 --> 00:10:26.450
tag for another piece of data.

00:10:26.450 --> 00:10:29.600
A characteristic consists of
a value and a zero or more

00:10:29.600 --> 00:10:31.770
descriptors associated
with it.

00:10:31.770 --> 00:10:34.110
The Bluetooth SIG has adopted
a number of standard

00:10:34.110 --> 00:10:37.830
characteristics for expressing
such diverse information as

00:10:37.830 --> 00:10:41.950
the day of the week or a blood
glucose value or a sensor's

00:10:41.950 --> 00:10:43.340
location on a bicycle.

00:10:43.340 --> 00:10:46.220
I mean, there are all sorts
of crazy things in there.

00:10:46.220 --> 00:10:49.090
Characteristics can then be
grouped together to form a

00:10:49.090 --> 00:10:51.330
service, which a BLE
device can then

00:10:51.330 --> 00:10:54.360
advertise to other devices.

00:10:54.360 --> 00:10:58.020
A service spec states not only
the characteristics that a

00:10:58.020 --> 00:11:02.860
GATT service makes available,
but also which characteristics

00:11:02.860 --> 00:11:05.210
the GATT clients can read,
write, or receive

00:11:05.210 --> 00:11:07.020
notifications about.

00:11:07.020 --> 00:11:09.790
Note that when two BLE-enabled
devices are communicating,

00:11:09.790 --> 00:11:13.000
either one can act as the
client or the server.

00:11:13.000 --> 00:11:14.030
They can even switch off.

00:11:14.030 --> 00:11:16.280
It all depends on which
one is actually making

00:11:16.280 --> 00:11:19.350
characteristics available
to the other one.

00:11:19.350 --> 00:11:22.625
Moving up in the specification,

00:11:22.625 --> 00:11:25.280
the next bit here--

00:11:25.280 --> 00:11:26.680
sorry, there's the client
and server.

00:11:26.680 --> 00:11:30.660
The next bit here is GATT
profiles, which define how

00:11:30.660 --> 00:11:33.430
data provided by a service is
to be exchanged between the

00:11:33.430 --> 00:11:36.460
GATT server and its clients.

00:11:36.460 --> 00:11:40.130
Profiles are defined with
specific use cases in mind,

00:11:40.130 --> 00:11:42.350
but are generally designed
to be flexible enough to

00:11:42.350 --> 00:11:45.450
accommodate multiple scenarios
within a particular domain.

00:11:45.450 --> 00:11:47.780
As of right now, there are about
20 different ones for a

00:11:47.780 --> 00:11:50.270
bunch of different use cases.

00:11:50.270 --> 00:11:52.990
And as of Android API version
18, you will be able to

00:11:52.990 --> 00:11:56.910
implement these profiles in your
apps, or future profiles

00:11:56.910 --> 00:12:00.560
that are released, or custom
profiles that you want to

00:12:00.560 --> 00:12:02.930
define for your application.

00:12:02.930 --> 00:12:04.730
Back to Rich.

00:12:04.730 --> 00:12:05.590
RICHARD HYNDMAN: Thank
you very much.

00:12:05.590 --> 00:12:07.210
OK, so we had a quick
look at the

00:12:07.210 --> 00:12:08.640
Bluetooth stack for Classic.

00:12:08.640 --> 00:12:11.640
Next, we've got the Bluetooth
stack for Low Energy as well.

00:12:11.640 --> 00:12:14.090
The point being, here, that at
the bottom you've got a low

00:12:14.090 --> 00:12:15.340
energy RF now.

00:12:15.340 --> 00:12:16.440
This is optimized.

00:12:16.440 --> 00:12:18.820
Instead of streaming data like
the Classic stack, just for

00:12:18.820 --> 00:12:21.350
bursting out these small
attributes of data and then

00:12:21.350 --> 00:12:24.230
powering back down again, this
is how Bluetooth Low Energy

00:12:24.230 --> 00:12:25.940
stays so low energy.

00:12:25.940 --> 00:12:27.970
And the protocol stack, instead
of being this enormous

00:12:27.970 --> 00:12:29.900
array of protocols, is
really focused on the

00:12:29.900 --> 00:12:31.870
one attribute profile.

00:12:31.870 --> 00:12:35.335
And on the profiles at the
top, instead of all the

00:12:35.335 --> 00:12:36.970
different profiles, we've
just got this GATT

00:12:36.970 --> 00:12:38.850
profile on the top.

00:12:38.850 --> 00:12:41.890
So the Bluetooth LE stack is a
fraction of the size of the

00:12:41.890 --> 00:12:43.260
Bluetooth Classic stack.

00:12:43.260 --> 00:12:45.250
And because of the low energy
RF, it needs a fraction of the

00:12:45.250 --> 00:12:45.840
size battery.

00:12:45.840 --> 00:12:47.920
And you get these devices, of
course, that are a fraction of

00:12:47.920 --> 00:12:51.240
the cost and run for
a lot longer.

00:12:51.240 --> 00:12:54.020
So as this talk's called
Bluetooth Best Practices, we

00:12:54.020 --> 00:12:57.570
should have a look at some of
Bluetooth's best practices.

00:12:57.570 --> 00:13:00.190
To demo this, we're going to
run through an example of

00:13:00.190 --> 00:13:04.080
connecting a Bluetooth heart
rate monitor to a Nexus 4.

00:13:04.080 --> 00:13:06.030
This is going to be, right now,
the only place where you

00:13:06.030 --> 00:13:09.120
can see the Bluetooth LE APIs
that we've created.

00:13:09.120 --> 00:13:10.950
So here we go.

00:13:10.950 --> 00:13:13.680
Although, to start with, you
always need to check if the

00:13:13.680 --> 00:13:15.130
device has Bluetooth.

00:13:15.130 --> 00:13:18.100
When I was writing this slide,
I was thinking, what devices

00:13:18.100 --> 00:13:19.280
don't have Bluetooth?

00:13:19.280 --> 00:13:20.390
I almost took the slide
back out again.

00:13:20.390 --> 00:13:23.090
And then I thought, only the
devices inside our ecosystem

00:13:23.090 --> 00:13:24.390
are CTS-tested.

00:13:24.390 --> 00:13:25.920
And they're the only ones that
we can guarantee that have

00:13:25.920 --> 00:13:26.760
Bluetooth on.

00:13:26.760 --> 00:13:29.180
So maybe there are non-Bluetooth
devices.

00:13:29.180 --> 00:13:31.230
And then there's going to be
things like Google TVs that

00:13:31.230 --> 00:13:32.980
also may not be Bluetooth
devices.

00:13:32.980 --> 00:13:35.390
So it avoids horrific crashes.

00:13:35.390 --> 00:13:37.790
It's always worth checking
if you have

00:13:37.790 --> 00:13:38.500
Bluetooth on the device.

00:13:38.500 --> 00:13:41.700
Matt's just going to run you
through the code quickly.

00:13:41.700 --> 00:13:45.310
MATTHEW XIE: Yeah so let's talk
a little about the code.

00:13:45.310 --> 00:13:49.990
To check whether there's
Bluetooth on your device or

00:13:49.990 --> 00:13:54.600
not, you check Bluetooth
Adapter.

00:13:54.600 --> 00:13:57.690
This is existing API.

00:13:57.690 --> 00:14:05.060
But the only way you'll get it
is you're seeing static method

00:14:05.060 --> 00:14:09.520
with a Bluetooth Adapter,
Get Default Adapter.

00:14:09.520 --> 00:14:12.470
If you look at this code,
we are changing that.

00:14:12.470 --> 00:14:14.080
We're obsoleting that.

00:14:14.080 --> 00:14:18.760
Now we are doing this with
our Bluetooth Manager.

00:14:18.760 --> 00:14:21.720
So you see context, Get
System Service,

00:14:21.720 --> 00:14:24.930
with Bluetooth Service.

00:14:24.930 --> 00:14:29.540
And then, from the Manager, you
get the Bluetooth Adapter.

00:14:29.540 --> 00:14:33.770
And now you check, if that's
null, then you don't have

00:14:33.770 --> 00:14:36.260
Bluetooth support in
your platform.

00:14:36.260 --> 00:14:38.090
RICHARD HYNDMAN: OK, so we've
got a device with Bluetooth.

00:14:38.090 --> 00:14:40.270
Of course, you're next going
to need to check whether

00:14:40.270 --> 00:14:41.770
Bluetooth's turned on
or off to avoid the

00:14:41.770 --> 00:14:44.470
next horrific crash.

00:14:44.470 --> 00:14:47.730
MATTHEW XIE: Yeah, you do
this by we provide API.

00:14:47.730 --> 00:14:50.910
You do this by check
from the Adapter.

00:14:50.910 --> 00:14:54.660
You check whether it's
enabled or not.

00:14:54.660 --> 00:14:59.760
If it's not enabled, you can
send an Intent to the

00:14:59.760 --> 00:15:02.440
[INAUDIBLE] app to enable it.

00:15:02.440 --> 00:15:07.460
We don't have an API to enable
it directly, because we want

00:15:07.460 --> 00:15:10.150
full user awareness.

00:15:10.150 --> 00:15:12.400
So you cannot sneak
Bluetooth on

00:15:12.400 --> 00:15:15.570
without the user's knowledge.

00:15:15.570 --> 00:15:16.880
RICHARD HYNDMAN: Yeah, so you
fire off the intent to get the

00:15:16.880 --> 00:15:18.140
Bluetooth setting screens up.

00:15:18.140 --> 00:15:20.270
Right, so now we're ready to
connect the Bluetooth LE

00:15:20.270 --> 00:15:22.360
device to the phone.

00:15:22.360 --> 00:15:24.930
So we have a new flow for
Bluetooth Low Energy.

00:15:24.930 --> 00:15:26.580
We start with a low
energy scan.

00:15:26.580 --> 00:15:28.490
And that's going to put the
device in scanning mode and

00:15:28.490 --> 00:15:29.830
look for any devices--

00:15:29.830 --> 00:15:30.840
any low-energy devices--

00:15:30.840 --> 00:15:33.350
that are currently advertising
their presence and available

00:15:33.350 --> 00:15:34.310
for connections.

00:15:34.310 --> 00:15:36.650
You find the one that you want,
you stop the scanning,

00:15:36.650 --> 00:15:39.110
and you connect to the device.

00:15:39.110 --> 00:15:40.310
Once you're connected,
you discover the

00:15:40.310 --> 00:15:41.510
services of the device.

00:15:41.510 --> 00:15:43.100
In the case of a heart rate
monitor, it's going to have

00:15:43.100 --> 00:15:44.450
the heart rate service.

00:15:44.450 --> 00:15:45.050
Then you can find the

00:15:45.050 --> 00:15:46.440
characteristics of the service.

00:15:46.440 --> 00:15:48.600
This is all about how the
GATT profile works.

00:15:48.600 --> 00:15:50.700
Characteristics of a heart rate
service, one's definitely

00:15:50.700 --> 00:15:52.690
going to be the heart
rate, the pulse.

00:15:52.690 --> 00:15:55.415
Another one could be the
location of the pulse that

00:15:55.415 --> 00:15:56.140
it's checking on the body.

00:15:56.140 --> 00:15:58.290
Maybe you've got it around your
wrist, or around your

00:15:58.290 --> 00:15:59.480
chest or something.

00:15:59.480 --> 00:16:02.380
So you can then find the heart
rate and then read it.

00:16:02.380 --> 00:16:04.530
You can either just read the
attributes for the heart rate

00:16:04.530 --> 00:16:06.920
or register to get notifications
about them.

00:16:06.920 --> 00:16:08.170
And here's the code for that.

00:16:11.670 --> 00:16:17.660
MATTHEW XIE: First, you want
to discover the BLE device.

00:16:17.660 --> 00:16:24.060
We provided a new API to do that
in the Bluetooth Adapter.

00:16:24.060 --> 00:16:26.940
This is just for LE device.

00:16:26.940 --> 00:16:30.210
You do Start LE Scan.

00:16:30.210 --> 00:16:32.280
We have two APIs.

00:16:32.280 --> 00:16:37.030
One is just API with
a callback.

00:16:37.030 --> 00:16:42.290
The other, you can pass in UUID
filters to filter out

00:16:42.290 --> 00:16:47.200
only the device you're
interested in.

00:16:47.200 --> 00:16:52.080
And this API is callback
based.

00:16:52.080 --> 00:17:01.500
We send out results through
callback, so you have to

00:17:01.500 --> 00:17:09.380
implement the LE Scan Callback
API with an LE scan.

00:17:09.380 --> 00:17:14.099
And there are three parameters
we're going to call you.

00:17:14.099 --> 00:17:15.359
One is a device.

00:17:15.359 --> 00:17:18.440
That's the one you
want to find out.

00:17:18.440 --> 00:17:24.400
And RSSI, which Receive
the Signal Strength.

00:17:24.400 --> 00:17:30.885
And the Scans Record is the
advertisement data in a byte

00:17:30.885 --> 00:17:32.135
rate format.

00:17:35.260 --> 00:17:39.860
OK, now if all you're interested
in is just the

00:17:39.860 --> 00:17:43.110
advertisement data,
then you're done.

00:17:43.110 --> 00:17:50.040
But if you want to use the
service hosted by the remote

00:17:50.040 --> 00:17:54.590
BLE device, you need
to connect to it.

00:17:54.590 --> 00:18:01.240
You do this by Bluetooth
Device Connect GATT.

00:18:01.240 --> 00:18:06.330
With this, you connect
to the remote device.

00:18:06.330 --> 00:18:10.500
This is also on callback
based.

00:18:10.500 --> 00:18:17.660
If you look there, there's
a few callback functions,

00:18:17.660 --> 00:18:24.860
because the Connect call or
Discovery call or Character

00:18:24.860 --> 00:18:28.120
Read or Write call
are asynchronous.

00:18:28.120 --> 00:18:30.510
So you'll implement the
callback function.

00:18:30.510 --> 00:18:37.730
And when there's results coming
back, we will call the

00:18:37.730 --> 00:18:40.730
callback functions.

00:18:40.730 --> 00:18:51.230
Take the example, like say, when
you see like Discover a

00:18:51.230 --> 00:18:56.170
Service, we'll call back with
onServiceDiscovered with a

00:18:56.170 --> 00:18:57.900
write status.

00:18:57.900 --> 00:19:02.790
And then you can say Get
Services to catch the service.

00:19:07.090 --> 00:19:14.080
So with a service is a list
of Bluetooth GATT service.

00:19:14.080 --> 00:19:18.210
So you traverse the services.

00:19:18.210 --> 00:19:21.890
For each service, you can
just go to look for

00:19:21.890 --> 00:19:28.060
characteristics, or you can
use UUID to find out the

00:19:28.060 --> 00:19:29.940
service you are interested.

00:19:29.940 --> 00:19:37.450
And then, the same way, you go
into each service and Get

00:19:37.450 --> 00:19:42.870
Characteristics, which is
a list of Bluetooth GATT

00:19:42.870 --> 00:19:44.830
characteristic.

00:19:44.830 --> 00:19:51.635
With that you can check UUIDs
and look for the UUID your

00:19:51.635 --> 00:19:53.090
user is interested.

00:19:53.090 --> 00:19:59.980
Like in this example, trying to
match the heart rate UUID

00:19:59.980 --> 00:20:01.980
and get that.

00:20:01.980 --> 00:20:05.860
And then, you can also
set notification.

00:20:05.860 --> 00:20:14.380
And so we'll notify you if the
characteristic changes.

00:20:14.380 --> 00:20:16.370
Now back to Scout.

00:20:16.370 --> 00:20:16.830
SCOUT SINCLAIR BRODY: OK.

00:20:16.830 --> 00:20:22.620
So there's your sneak peek at
the BLE APIs for Android.

00:20:22.620 --> 00:20:24.100
This is an exciting
technology.

00:20:24.100 --> 00:20:26.110
And we know that you're
looking forward to

00:20:26.110 --> 00:20:27.520
working with it.

00:20:27.520 --> 00:20:29.510
There are a few other things
that we think you should bear

00:20:29.510 --> 00:20:32.230
in mind, though, as you're
preparing to do so.

00:20:32.230 --> 00:20:36.490
First off, since BLE will be
introduced in Android API

00:20:36.490 --> 00:20:39.590
version 18, you'll need a
device running the next

00:20:39.590 --> 00:20:41.190
version of Android before
you can take

00:20:41.190 --> 00:20:43.360
advantage of these APIs.

00:20:43.360 --> 00:20:45.780
However, once they are released,
they will be covered

00:20:45.780 --> 00:20:48.640
by the compatibility program in
the same way that Bluetooth

00:20:48.640 --> 00:20:52.230
Classic APIs are, which means
you can count on them being

00:20:52.230 --> 00:20:54.430
present in new and
updated devices

00:20:54.430 --> 00:20:56.990
throughout the ecosystem.

00:20:56.990 --> 00:20:59.400
Next, we want you to know that
the first version of these

00:20:59.400 --> 00:21:04.010
APIs have support for the BLE
central role but not the

00:21:04.010 --> 00:21:05.380
peripheral role.

00:21:05.380 --> 00:21:07.650
This means that you won't be
able to have two Android

00:21:07.650 --> 00:21:11.210
devices talking to each other
across the BLE, at least not

00:21:11.210 --> 00:21:12.730
to begin with.

00:21:12.730 --> 00:21:15.430
Next, and speaking to the
nature of the technology

00:21:15.430 --> 00:21:19.240
itself, please remember that
Bluetooth is not a type of

00:21:19.240 --> 00:21:22.420
magic fairy dust that you can
sprinkle on your existing apps

00:21:22.420 --> 00:21:25.500
and have them become suddenly
more battery efficient.

00:21:25.500 --> 00:21:29.280
It is a different technology
with very distinctly

00:21:29.280 --> 00:21:30.900
different use cases.

00:21:30.900 --> 00:21:33.850
And this is a common
thing that I'll see

00:21:33.850 --> 00:21:34.600
in talking to people.

00:21:34.600 --> 00:21:36.700
They'll say, oh, and
now we've got BLE!

00:21:36.700 --> 00:21:38.740
Everything's going to be much
more battery efficient.

00:21:38.740 --> 00:21:40.150
I'm going to have much
better battery life.

00:21:40.150 --> 00:21:42.940
Well, it doesn't exactly
work that way.

00:21:42.940 --> 00:21:46.130
The data model for Bluetooth
Low Energy is optimized for

00:21:46.130 --> 00:21:48.250
small incremental updates.

00:21:48.250 --> 00:21:53.170
With a max theoretical
throughput of 200 kilobits per

00:21:53.170 --> 00:21:58.510
second, streaming audio or video
is really not possible.

00:21:58.510 --> 00:22:01.630
However, if you're looking to
send data over from a sensor

00:22:01.630 --> 00:22:05.170
of some sort or if you're super
forgetful and want to

00:22:05.170 --> 00:22:08.390
have BLE proximity tags attached
to everything you

00:22:08.390 --> 00:22:12.250
own, Bluetooth Low Energy is
going to be a fantastic option

00:22:12.250 --> 00:22:14.770
and definitely a more
power-efficient way to go than

00:22:14.770 --> 00:22:16.020
Classic Bluetooth.

00:22:18.220 --> 00:22:18.820
RICHARD HYNDMAN: Right,
of course.

00:22:18.820 --> 00:22:20.560
Whenever you're on a mobile OS,

00:22:20.560 --> 00:22:22.830
battery is always a concern.

00:22:22.830 --> 00:22:25.110
When you're running wireless
communications on a mobile OS,

00:22:25.110 --> 00:22:26.460
it's even more of a concern.

00:22:26.460 --> 00:22:28.080
So just a couple of little
battery tips

00:22:28.080 --> 00:22:30.010
for Classic and LE.

00:22:30.010 --> 00:22:32.020
When you're scanning for
devices, once you've found the

00:22:32.020 --> 00:22:34.280
device you're looking for, of
course, tell the system that

00:22:34.280 --> 00:22:36.400
you've found it and turn
off the scanning.

00:22:36.400 --> 00:22:39.120
This also serves another
purpose, because there's

00:22:39.120 --> 00:22:40.860
definitely, with some of the
stacks, some conflict when

00:22:40.860 --> 00:22:43.150
you're trying to make an RFCOMM
connection with the

00:22:43.150 --> 00:22:44.350
device you've just found--

00:22:44.350 --> 00:22:46.520
and some people are nodding
quite a lot--

00:22:46.520 --> 00:22:47.600
and if you're still
discovering.

00:22:47.600 --> 00:22:49.340
So don't have Discovery on while
you try and make the

00:22:49.340 --> 00:22:52.310
connection, and you'll also
save a bit of battery.

00:22:52.310 --> 00:22:54.440
Also, never loop on
any RF functions.

00:22:54.440 --> 00:22:55.430
There are wireless devices.

00:22:55.430 --> 00:22:56.430
One might go out of range.

00:22:56.430 --> 00:22:57.690
It might lose its battery
or something.

00:22:57.690 --> 00:23:00.820
So if you're trying to connect
to a device and you fail, then

00:23:00.820 --> 00:23:03.570
just ask the user or do some
intelligent logic about

00:23:03.570 --> 00:23:05.240
whether they want to
reconnect again.

00:23:05.240 --> 00:23:06.430
Don't just sit there looping
on the radio.

00:23:06.430 --> 00:23:08.910
We've see it one or two times,
and then, of course, it just

00:23:08.910 --> 00:23:10.340
depletes the battery, especially
if you're in a

00:23:10.340 --> 00:23:12.180
background service and the user
doesn't know what's going

00:23:12.180 --> 00:23:16.180
on, trying to reconnect to
something that existed before.

00:23:16.180 --> 00:23:17.930
Also, don't reinvent
the wheel.

00:23:17.930 --> 00:23:20.170
Android Beam is pretty
established now.

00:23:20.170 --> 00:23:23.890
If you want to do a Bluetooth
file transfer, for example,

00:23:23.890 --> 00:23:26.210
NFC is a great way for doing the
Bluetooth handshake at the

00:23:26.210 --> 00:23:28.820
start, for getting the details
of the two devices.

00:23:28.820 --> 00:23:31.140
And with Android Beam, you
just have to set the

00:23:31.140 --> 00:23:35.090
BeamPushUris or the
CreateBeamUrisCallback.

00:23:35.090 --> 00:23:38.060
And you can make it so when the
two devices touch, a large

00:23:38.060 --> 00:23:40.270
file is sent between
the two of them.

00:23:40.270 --> 00:23:42.080
Android Beam will do the
negotiation and send the file

00:23:42.080 --> 00:23:45.420
over Bluetooth for you.

00:23:45.420 --> 00:23:46.760
There's something to
do with the RFCOMM

00:23:46.760 --> 00:23:48.920
APIs again, as well.

00:23:48.920 --> 00:23:52.090
Initial APIs listen using
RFCOMM and create RFCOMM

00:23:52.090 --> 00:23:54.750
sockets secure APIs.

00:23:54.750 --> 00:23:58.030
And that means that they need
both devices to have a screen

00:23:58.030 --> 00:24:00.390
and I/O to be able to make the
secure connection, because you

00:24:00.390 --> 00:24:02.490
need to do all the
pin entry stuff.

00:24:02.490 --> 00:24:04.630
So if you try and make a secure
connection, or if you

00:24:04.630 --> 00:24:06.920
just try and use these APIs
and it fails, one of the

00:24:06.920 --> 00:24:10.410
reasons may be that the target
device can't display a pin.

00:24:10.410 --> 00:24:12.500
If that's the case, go back
to be insecure APIs at the

00:24:12.500 --> 00:24:16.000
bottom, create Insecure and
Listen Insecure, and it'll

00:24:16.000 --> 00:24:18.390
create the connection
much more simply.

00:24:18.390 --> 00:24:20.856
To be honest, most the time,
you don't need to use the

00:24:20.856 --> 00:24:21.820
secure APIs.

00:24:21.820 --> 00:24:24.050
If you've got both devices in
your hand, the chance of a man

00:24:24.050 --> 00:24:26.240
in the middle attack
is pretty slim.

00:24:26.240 --> 00:24:27.900
So you're going to save yourself
a lot of bother

00:24:27.900 --> 00:24:30.360
inside your application if you
just go with the insecure

00:24:30.360 --> 00:24:31.830
ones, because there's
a lot less reasons

00:24:31.830 --> 00:24:34.270
why they would fail.

00:24:34.270 --> 00:24:35.730
One last thing.

00:24:35.730 --> 00:24:37.800
What would any good Bluetooth
talk be without a

00:24:37.800 --> 00:24:39.030
final little teaser?

00:24:39.030 --> 00:24:40.650
A think it's a good point.

00:24:40.650 --> 00:24:42.160
We've got this whole
new stack in there.

00:24:42.160 --> 00:24:43.390
We're announcing a
few other things.

00:24:43.390 --> 00:24:47.020
So I'm very happy to say that
also within API 18, in a few

00:24:47.020 --> 00:24:51.470
short months, we will be adding
support for AVRCP 1.3.

00:24:51.470 --> 00:24:52.830
And to the people in the
audience that that means

00:24:52.830 --> 00:24:54.320
something to, they'll be
quite happy about that.

00:24:54.320 --> 00:24:56.460
[INAUDIBLE] will be very happy
about that, because he pings

00:24:56.460 --> 00:24:58.220
me about it every day.

00:24:58.220 --> 00:25:01.845
AVRCP 1.0 was in an earlier
version of Android, and it

00:25:01.845 --> 00:25:03.770
meant you could connect your
phone to your car stereo and

00:25:03.770 --> 00:25:05.380
do the remote control.

00:25:05.380 --> 00:25:08.050
With 1.3, we also add all
the meta data as well.

00:25:08.050 --> 00:25:09.260
So you'll see your album art.

00:25:09.260 --> 00:25:12.642
You'll see your track numbers,
track listing, album and

00:25:12.642 --> 00:25:14.220
titles, that kind of
thing, as well.

00:25:14.220 --> 00:25:17.330
So of course, there has to be
an API for that as well.

00:25:17.330 --> 00:25:19.340
And it's using an existing
API-- the Remote Control

00:25:19.340 --> 00:25:20.930
Client API.

00:25:20.930 --> 00:25:23.200
So anything that's already using
Remote Control Client--

00:25:23.200 --> 00:25:25.050
and Google Music certainly does,
and a lot of apps have

00:25:25.050 --> 00:25:26.440
Remote Control Clients
already--

00:25:26.440 --> 00:25:28.020
will automatically
work for you.

00:25:28.020 --> 00:25:31.220
And your car stereo will get all
the awesome information.

00:25:31.220 --> 00:25:33.490
If you want to have a look
inside the API, have a look

00:25:33.490 --> 00:25:37.240
inside the Media Metadata
Retriever, and there's a whole

00:25:37.240 --> 00:25:39.745
load of different tags
inside there that you

00:25:39.745 --> 00:25:42.700
can set on the API.

00:25:42.700 --> 00:25:44.660
Things like the album art,
things like that.

00:25:44.660 --> 00:25:47.350
And one final thing, make sure
you always call clear on the

00:25:47.350 --> 00:25:48.090
metadata [INAUDIBLE]

00:25:48.090 --> 00:25:50.770
first, or you're going to mix
your metadata up with whatever

00:25:50.770 --> 00:25:51.970
metadata was in there first.

00:25:51.970 --> 00:25:53.930
And it gets all a bit crazy.

00:25:53.930 --> 00:25:54.710
OK.

00:25:54.710 --> 00:25:56.360
Back to Scout to wrap it up.

00:25:56.360 --> 00:25:57.240
SCOUT SINCLAIR BRODY:
All right.

00:25:57.240 --> 00:25:59.360
So we've had a couple of
exciting announcements,

00:25:59.360 --> 00:26:03.070
including the inclusion of
Bluetooth Low Energy APIs in

00:26:03.070 --> 00:26:07.460
API version 18, along
with AVRCP 1.3.

00:26:07.460 --> 00:26:10.530
We have Office Hours immediately
following the

00:26:10.530 --> 00:26:12.480
session, over in the Android
Sandbox that

00:26:12.480 --> 00:26:13.290
you're welcome to join.

00:26:13.290 --> 00:26:16.740
I think we seem to have gone
relatively quickly, so we've

00:26:16.740 --> 00:26:19.660
got some time for questions
now as well.

00:26:19.660 --> 00:26:22.350
But of course, if you want to
find out more about the

00:26:22.350 --> 00:26:26.380
Bluetooth APIs and anything
relating to Android, as

00:26:26.380 --> 00:26:27.750
always, you should definitely
check out

00:26:27.750 --> 00:26:28.660
the developer website.

00:26:28.660 --> 00:26:31.910
And there's a specific link
right there to the Bluetooth

00:26:31.910 --> 00:26:33.480
information.

00:26:33.480 --> 00:26:36.130
And let's have you step
up to the mics if

00:26:36.130 --> 00:26:37.230
you have any questions.

00:26:37.230 --> 00:26:38.379
RICHARD HYNDMAN: Thank
you very much.

00:26:38.379 --> 00:26:39.357
SCOUT SINCLAIR BRODY:
Thank you.

00:26:39.357 --> 00:26:49.137
[APPLAUSE]

00:26:49.137 --> 00:26:51.760
SCOUT SINCLAIR BRODY:
All right.

00:26:51.760 --> 00:26:52.600
So it's hard to tell.

00:26:52.600 --> 00:26:54.630
I think we've got at
least one question.

00:26:54.630 --> 00:26:57.470
So why don't you go ahead.

00:26:57.470 --> 00:26:57.610
AUDIENCE: Hi.

00:26:57.610 --> 00:26:58.920
My name is Jimmy [? Bocham ?]

00:26:58.920 --> 00:27:00.640
from [? Stickerpoint. ?]

00:27:00.640 --> 00:27:03.220
I have a question about
the new API for

00:27:03.220 --> 00:27:04.805
Bluetooth Low Energy.

00:27:04.805 --> 00:27:07.820
The first question is, will it
support multiple devices

00:27:07.820 --> 00:27:10.160
connected at the same time?

00:27:10.160 --> 00:27:17.500
And the second question, will
it support devices calling

00:27:17.500 --> 00:27:20.400
specific apps?

00:27:20.400 --> 00:27:24.140
So if the app is not running
in the background, will you

00:27:24.140 --> 00:27:24.920
support this?

00:27:24.920 --> 00:27:25.270
SCOUT SINCLAIR BRODY: OK.

00:27:25.270 --> 00:27:26.530
So let's take them
one at a time.

00:27:26.530 --> 00:27:29.130
First was--

00:27:29.130 --> 00:27:29.582
RICHARD HYNDMAN: Will
it be able to

00:27:29.582 --> 00:27:30.130
connect to multiple devices.

00:27:30.130 --> 00:27:32.620
AUDIENCE: Multiple connections
at the same time.

00:27:32.620 --> 00:27:34.670
MATTHEW XIE: Yeah.

00:27:34.670 --> 00:27:37.680
Yeah, that's a central.

00:27:37.680 --> 00:27:40.510
Yeah, we can connect to
multiple peripherals.

00:27:40.510 --> 00:27:42.330
SCOUT SINCLAIR BRODY: OK, so if
you're running in central

00:27:42.330 --> 00:27:45.380
mode, such as you're
on the phone--

00:27:45.380 --> 00:27:45.975
MATTHEW XIE: Yeah, we
are able to do that.

00:27:45.975 --> 00:27:46.653
SCOUT SINCLAIR BRODY: --it
can connect to multiple

00:27:46.653 --> 00:27:48.170
peripherals.

00:27:48.170 --> 00:27:49.370
And then the second?

00:27:49.370 --> 00:27:54.830
AUDIENCE: The second question
was regarding if an LE device

00:27:54.830 --> 00:27:59.030
can call a specific app
that is not running.

00:27:59.030 --> 00:28:03.410
MATTHEW XIE: Yeah, so with
these callback functions.

00:28:03.410 --> 00:28:06.810
Even if it's switched in
the background, we will

00:28:06.810 --> 00:28:08.870
still call you back.

00:28:08.870 --> 00:28:12.720
AUDIENCE: So if the app is not
running, and the LE device--

00:28:12.720 --> 00:28:15.070
or the phone is on background.

00:28:15.070 --> 00:28:17.840
It could be on standby or
its on the background.

00:28:20.880 --> 00:28:23.680
And a specific device that
you've connected before that

00:28:23.680 --> 00:28:27.010
hasn't appeared before comes
into range, will you allow to

00:28:27.010 --> 00:28:29.020
call a specific app?

00:28:29.020 --> 00:28:29.420
MATTHEW XIE: Yeah.

00:28:29.420 --> 00:28:34.140
I think your app, you have
to implement our service.

00:28:34.140 --> 00:28:38.050
So that, if its activity,
if you are tending the

00:28:38.050 --> 00:28:43.510
background, it's stopped.

00:28:43.510 --> 00:28:47.890
But if you have a service,
then we will call that.

00:28:47.890 --> 00:28:49.890
RICHARD HYNDMAN: Yeah, the
scanning on the device isn't

00:28:49.890 --> 00:28:52.630
going to be scanning for new
advertising devices that are

00:28:52.630 --> 00:28:53.550
coming past the whole time.

00:28:53.550 --> 00:28:55.160
The radio is not on scanning
the whole time.

00:28:55.160 --> 00:28:57.450
So it won't know that a random
device has just come into

00:28:57.450 --> 00:28:58.956
range, I believe.

00:28:58.956 --> 00:28:59.410
MATTHEW XIE: Yeah.

00:28:59.410 --> 00:29:01.330
RICHARD HYNDMAN: So you'd have
to have a service that scans

00:29:01.330 --> 00:29:03.060
to try to find devices
that are--

00:29:03.060 --> 00:29:03.840
AUDIENCE: So you need to have
it in the background.

00:29:03.840 --> 00:29:04.880
RICHARD HYNDMAN: Yeah, you would
still need to have a

00:29:04.880 --> 00:29:05.670
service in the background.

00:29:05.670 --> 00:29:09.484
And that would not be great
for the battery, maybe.

00:29:09.484 --> 00:29:10.610
SCOUT SINCLAIR BRODY: OK,
so let's alternate.

00:29:10.610 --> 00:29:12.800
So let's go on this side.

00:29:12.800 --> 00:29:13.806
AUDIENCE: Hi.

00:29:13.806 --> 00:29:14.760
I'm [INAUDIBLE].

00:29:14.760 --> 00:29:16.410
I have a question.

00:29:16.410 --> 00:29:19.110
I noticed you didn't mention
any sort of backwards

00:29:19.110 --> 00:29:20.130
compatibility.

00:29:20.130 --> 00:29:22.660
Is there any hope of that?

00:29:22.660 --> 00:29:29.100
And do you think there's any
prospects on backporting it?

00:29:29.100 --> 00:29:31.410
Is that even possible?

00:29:31.410 --> 00:29:32.760
RICHARD HYNDMAN: So what we're
saying is that it's going to

00:29:32.760 --> 00:29:35.230
be API level 18 and above and
not be in the compatibility

00:29:35.230 --> 00:29:36.480
test suite.

00:29:38.610 --> 00:29:40.350
SCOUT SINCLAIR BRODY: And
this is very common.

00:29:40.350 --> 00:29:44.380
When a new API is introduced,
it's for that API version.

00:29:44.380 --> 00:29:47.820
It doesn't necessarily
go backwards in time.

00:29:47.820 --> 00:29:55.450
AUDIENCE: So I've already
started using the Motorola,

00:29:55.450 --> 00:30:01.300
the HTC, and the Samsung
BLE library SDKs.

00:30:01.300 --> 00:30:03.300
Is it going to be--

00:30:03.300 --> 00:30:03.500
RICHARD HYNDMAN: That's
definitely an option.

00:30:03.500 --> 00:30:05.240
Going forward though, of course,
all those devices will

00:30:05.240 --> 00:30:07.870
also, when they get to API 18,
have to support the official

00:30:07.870 --> 00:30:10.960
framework instead of BLE APIs
So if you do want to support

00:30:10.960 --> 00:30:13.310
those current SDKs that
are out there,

00:30:13.310 --> 00:30:13.940
that's absolutely fine.

00:30:13.940 --> 00:30:15.280
As always, with Android,
it's open.

00:30:15.280 --> 00:30:16.980
But going forward, yeah, you
just have to support this one

00:30:16.980 --> 00:30:18.790
set of APIs, and it'll make
your life a lot easier.

00:30:22.360 --> 00:30:26.740
AUDIENCE: To support multiple
devices connected at the same

00:30:26.740 --> 00:30:30.200
time, when the app is
in the background,

00:30:30.200 --> 00:30:31.850
how do I know which--

00:30:31.850 --> 00:30:34.220
like, in a proximity
case, there are

00:30:34.220 --> 00:30:37.590
multiple Bluetooth tags.

00:30:37.590 --> 00:30:41.130
And how can I distinguish
whether a particular--

00:30:41.130 --> 00:30:43.720
few tags are of interest
to me, that are mine.

00:30:43.720 --> 00:30:46.330
There could be other tags
which are not mine.

00:30:46.330 --> 00:30:50.610
So how do I take care of such
a kind of situation.

00:30:50.610 --> 00:30:51.790
SCOUT SINCLAIR BRODY: Under
the assumption that you've

00:30:51.790 --> 00:30:53.725
been encountered these
tags before?

00:30:53.725 --> 00:30:54.975
AUDIENCE: Yeah.

00:30:56.700 --> 00:31:00.022
Is there an association
in Bluetooth LE?

00:31:00.022 --> 00:31:01.610
RICHARD HYNDMAN: Well you can
associate inside your

00:31:01.610 --> 00:31:03.250
application with the
ID from the tag.

00:31:03.250 --> 00:31:04.830
So the first time you
get the tag, you can

00:31:04.830 --> 00:31:06.110
say, this is my keys.

00:31:06.110 --> 00:31:07.800
Inside your app, it says
it's found the tag.

00:31:07.800 --> 00:31:09.020
And you could give
it a name inside

00:31:09.020 --> 00:31:10.400
your app, if you wanted.

00:31:10.400 --> 00:31:13.280
But each BLE device is a unique
ID that you'll be able

00:31:13.280 --> 00:31:14.440
to reference again
when you see it.

00:31:14.440 --> 00:31:15.750
AUDIENCE: So it's completely
application-based?

00:31:15.750 --> 00:31:16.985
RICHARD HYNDMAN: Yeah.

00:31:16.985 --> 00:31:21.080
AUDIENCE: So it's not anything
to do with the stack itself?

00:31:21.080 --> 00:31:22.000
SCOUT SINCLAIR BRODY: No.

00:31:22.000 --> 00:31:22.910
AUDIENCE: Or the OS?

00:31:22.910 --> 00:31:24.160
SCOUT SINCLAIR BRODY: Entirely
up to the application.

00:31:27.310 --> 00:31:29.020
AUDIENCE: Hi, my
name is Albert.

00:31:29.020 --> 00:31:32.080
What LE profiles will
be supported when

00:31:32.080 --> 00:31:33.840
API 18 comes out?

00:31:33.840 --> 00:31:35.830
SCOUT SINCLAIR BRODY: So
right now we support--

00:31:35.830 --> 00:31:36.780
there's GATT.

00:31:36.780 --> 00:31:37.830
There's support for GATT.

00:31:37.830 --> 00:31:40.910
And you can implement support
for GATT profiles in your

00:31:40.910 --> 00:31:42.000
application.

00:31:42.000 --> 00:31:45.190
AUDIENCE: So you're expecting
LE profiles like heart rate

00:31:45.190 --> 00:31:46.770
monitors and [INAUDIBLE]

00:31:46.770 --> 00:31:49.310
GATT to be distributed over
the Google Play Store?

00:31:49.310 --> 00:31:49.780
RICHARD HYNDMAN: They
all run over GATT.

00:31:49.780 --> 00:31:51.490
SCOUT SINCLAIR BRODY: Yes,
they all run over GATT in

00:31:51.490 --> 00:31:52.170
Bluetooth Low Energy.

00:31:52.170 --> 00:31:54.650
AUDIENCE: And they can be
distributed over the Google

00:31:54.650 --> 00:31:57.150
Play Store?

00:31:57.150 --> 00:32:00.410
SCOUT SINCLAIR BRODY: Yeah,
it's part of your app.

00:32:00.410 --> 00:32:03.180
AUDIENCE: Is GATT server
will be supported?

00:32:03.180 --> 00:32:03.770
MATTHEW XIE: Yeah.

00:32:03.770 --> 00:32:05.988
We support.

00:32:05.988 --> 00:32:08.210
We also open up API to
support GATT server.

00:32:08.210 --> 00:32:08.970
AUDIENCE: GATT server.

00:32:08.970 --> 00:32:13.230
How about GATT over basic
rate over EDR?

00:32:13.230 --> 00:32:14.580
MATTHEW XIE: Say it again?

00:32:14.580 --> 00:32:15.170
RICHARD HYNDMAN: GATT
on Bluetooth--

00:32:15.170 --> 00:32:16.970
AUDIENCE: GATT over basic
rate over EDR.

00:32:16.970 --> 00:32:19.880
So in the Bluetooth
specification, GATT could run

00:32:19.880 --> 00:32:22.040
over Low Energy protocol,
and also could run

00:32:22.040 --> 00:32:24.570
over basic rate EDR?

00:32:24.570 --> 00:32:30.000
MATTHEW XIE: Yeah, we also
support that, yes.

00:32:30.000 --> 00:32:39.470
So if it's on the basic rate,
the API will still work.

00:32:39.470 --> 00:32:40.720
Yes.

00:32:42.690 --> 00:32:44.780
SCOUT SINCLAIR BRODY: Can you
turn the mic back on?

00:32:44.780 --> 00:32:48.070
Go ahead.

00:32:48.070 --> 00:32:49.490
No, you should be fine.

00:32:49.490 --> 00:32:52.530
I was asking the tech
folks to turn--

00:32:52.530 --> 00:32:52.770
AUDIENCE: Oh, hello?

00:32:52.770 --> 00:32:53.600
SCOUT SINCLAIR BRODY:
You're good.

00:32:53.600 --> 00:32:54.830
AUDIENCE: I didn't
get the answer.

00:32:54.830 --> 00:32:55.330
I'm sorry.

00:32:55.330 --> 00:32:58.910
MATTHEW XIE: The answer is,
the same API will work

00:32:58.910 --> 00:33:01.596
in that case, too.

00:33:01.596 --> 00:33:05.770
Like, GATT over basic rate.

00:33:05.770 --> 00:33:08.500
AUDIENCE: And you mentioned
earlier that the peripheral

00:33:08.500 --> 00:33:10.030
role is not supported.

00:33:10.030 --> 00:33:11.230
SCOUT SINCLAIR BRODY: The
peripheral role is not

00:33:11.230 --> 00:33:15.380
implemented for API version
18 at this point, no.

00:33:15.380 --> 00:33:16.490
AUDIENCE: How about the
observer role and the

00:33:16.490 --> 00:33:18.270
advertiser role?

00:33:18.270 --> 00:33:21.150
So in the GATT specification,
there's four roles-- the

00:33:21.150 --> 00:33:24.720
central, peripheral, observer,
and the advertiser.

00:33:24.720 --> 00:33:27.490
Will the other two roles
be supported, as well?

00:33:27.490 --> 00:33:28.876
MATTHEW XIE: You're talking
about the broadcaster?

00:33:28.876 --> 00:33:31.150
AUDIENCE: The broadcaster.

00:33:31.150 --> 00:33:32.720
Observer.

00:33:32.720 --> 00:33:35.350
MATTHEW XIE: No broadcaster.

00:33:35.350 --> 00:33:36.640
Observer, yes.

00:33:36.640 --> 00:33:38.700
AUDIENCE: No broadcaster.

00:33:38.700 --> 00:33:39.930
MATTHEW XIE: At this point.

00:33:39.930 --> 00:33:41.850
RICHARD HYNDMAN: We're still
making these APIs.

00:33:41.850 --> 00:33:43.670
MATTHEW XIE: API 18, no.

00:33:43.670 --> 00:33:46.500
We don't do advertisement.

00:33:46.500 --> 00:33:48.590
We don't do advertisement.

00:33:48.590 --> 00:33:51.110
We do scanning for the
advertisements.

00:33:51.110 --> 00:33:54.080
So we are in the central
role, basically.

00:33:54.080 --> 00:33:58.590
So one, the broadcaster role
or the observer role that

00:33:58.590 --> 00:34:01.740
you're talking about, that
doesn't really apply to us,

00:34:01.740 --> 00:34:05.110
because we have TX and RX.

00:34:05.110 --> 00:34:06.640
We have both TX RX.

00:34:09.600 --> 00:34:11.840
Does that answer
your question?

00:34:11.840 --> 00:34:13.656
SCOUT SINCLAIR BRODY: Maybe this
is something that we can

00:34:13.656 --> 00:34:15.929
continue during Office
Hours, if that's OK.

00:34:15.929 --> 00:34:17.270
Can you make it to
Office Hours?

00:34:17.270 --> 00:34:17.739
AUDIENCE: Yeah.

00:34:17.739 --> 00:34:18.699
AUDIENCE: OK.

00:34:18.699 --> 00:34:23.300
MATTHEW XIE: So in short, we
do central, and that's it.

00:34:23.300 --> 00:34:26.944
With central, we can scan
advertisements.

00:34:26.944 --> 00:34:34.270
So you have observer there,
supporting it in default, too.

00:34:34.270 --> 00:34:39.929
No broadcaster or peripheral
at this point for API 18.

00:34:39.929 --> 00:34:40.199
SCOUT SINCLAIR BRODY: OK.

00:34:40.199 --> 00:34:41.170
AUDIENCE: Thank you.

00:34:41.170 --> 00:34:42.260
SCOUT SINCLAIR BRODY: Thanks.

00:34:42.260 --> 00:34:43.130
Let's move over here.

00:34:43.130 --> 00:34:43.790
AUDIENCE: Hi, my
name is Diego.

00:34:43.790 --> 00:34:47.146
I work for a company that does
multiple mobile platforms.

00:34:47.146 --> 00:34:49.050
Is this going to
be available--

00:34:49.050 --> 00:34:52.219
is this going to work also with
other platforms like iOS

00:34:52.219 --> 00:34:56.190
or Windows phones that already
support Bluetooth 4.0?

00:34:56.190 --> 00:34:58.200
SCOUT SINCLAIR BRODY:
Well, so it depends.

00:34:58.200 --> 00:35:00.950
I'm actually not familiar
whether or not those devices

00:35:00.950 --> 00:35:02.700
support the peripheral role.

00:35:02.700 --> 00:35:06.570
Because in Android API version
18, we only support the

00:35:06.570 --> 00:35:07.150
central role.

00:35:07.150 --> 00:35:11.610
So if they can do peripheral,
then we can talk to them.

00:35:11.610 --> 00:35:15.500
But if they only do central as
well, then as of API 18, no,

00:35:15.500 --> 00:35:19.010
you won't be able to talk over
BLE with the devices.

00:35:19.010 --> 00:35:20.270
Basically, you need something
that can be

00:35:20.270 --> 00:35:22.460
in peripheral mode.

00:35:22.460 --> 00:35:24.080
AUDIENCE: Thanks.

00:35:24.080 --> 00:35:24.490
AUDIENCE: Hello.

00:35:24.490 --> 00:35:31.630
I was curious about APTX or "apt
x", higher dynamic range

00:35:31.630 --> 00:35:33.790
Bluetooth streaming audio.

00:35:33.790 --> 00:35:36.350
Is that going to be
supported in AOSP?

00:35:36.350 --> 00:35:41.270
Or is that just relegated to
Samsung, HTC, and others that

00:35:41.270 --> 00:35:42.250
pay a license fee?

00:35:42.250 --> 00:35:42.960
I'm just curious.

00:35:42.960 --> 00:35:44.680
SCOUT SINCLAIR BRODY: So as
far as I know, that's not

00:35:44.680 --> 00:35:49.000
something that we have working
for this next version.

00:35:49.000 --> 00:35:51.120
And in general, we don't comment
on things that are

00:35:51.120 --> 00:35:53.250
happening after that.

00:35:53.250 --> 00:35:57.200
So definitely stop by Office
Hours to talk about it and

00:35:57.200 --> 00:36:00.530
make sure that we understand
your use cases and what you

00:36:00.530 --> 00:36:01.970
envision this being
useful for.

00:36:01.970 --> 00:36:04.320
Because it can be useful for
us in sort of prioritizing

00:36:04.320 --> 00:36:07.690
what features and what aspects
of the spec we go for next.

00:36:07.690 --> 00:36:10.582
But at this point, we won't
comment on things like that.

00:36:10.582 --> 00:36:11.406
Sorry.

00:36:11.406 --> 00:36:11.820
All right.

00:36:11.820 --> 00:36:13.680
I guess one more over
here, and then we

00:36:13.680 --> 00:36:14.780
head to Office Hours.

00:36:14.780 --> 00:36:16.230
AUDIENCE: This is just
a curiosity.

00:36:16.230 --> 00:36:18.790
The iOS Bluetooth stack
rotates MAC

00:36:18.790 --> 00:36:20.890
addresses every 15 minutes.

00:36:20.890 --> 00:36:23.640
Does the Android stack do
anything like that?

00:36:23.640 --> 00:36:25.160
It's a privacy feature,
currently.

00:36:28.350 --> 00:36:30.440
MATTHEW XIE: I think we do.

00:36:30.440 --> 00:36:31.700
We do that, yes.

00:36:31.700 --> 00:36:33.170
AUDIENCE: And, just curious.

00:36:33.170 --> 00:36:35.530
What type of range have you
guys seen on Android's

00:36:35.530 --> 00:36:36.660
peripheral?

00:36:36.660 --> 00:36:39.486
Like, how many feet?

00:36:39.486 --> 00:36:39.960
RICHARD HYNDMAN: Have
we tried that?

00:36:39.960 --> 00:36:41.940
Mine works from here
to here quite well.

00:36:41.940 --> 00:36:44.490
AUDIENCE: Six inches?

00:36:44.490 --> 00:36:45.610
Twelve inches?

00:36:45.610 --> 00:36:47.480
MATTHEW XIE: More than that.

00:36:47.480 --> 00:36:49.150
I think it's--

00:36:49.150 --> 00:36:49.740
SCOUT SINCLAIR BRODY:
Obviously it

00:36:49.740 --> 00:36:51.900
depends on the device.

00:36:51.900 --> 00:36:53.490
MATTHEW XIE: Yeah, it depends
on the device.

00:36:53.490 --> 00:36:55.800
About ten meters, I would say.

00:36:55.800 --> 00:36:57.560
AUDIENCE: So one
last question.

00:36:57.560 --> 00:37:01.550
The RSSI, is that going to be
normalized across devices?

00:37:01.550 --> 00:37:06.120
So if I have two devices, like a
Samsung and an HTC, and they

00:37:06.120 --> 00:37:09.550
both report, say, at an RSSI of
85, would they be about the

00:37:09.550 --> 00:37:10.390
same distance?

00:37:10.390 --> 00:37:13.985
Or is it calibrated per device
or per radio [INAUDIBLE]

00:37:13.985 --> 00:37:16.630
or something?

00:37:16.630 --> 00:37:18.680
MATTHEW XIE: That's
a good question.

00:37:18.680 --> 00:37:22.150
I think it's calibrated.

00:37:22.150 --> 00:37:25.580
AUDIENCE: That would be great
for the CTS or whatever, to

00:37:25.580 --> 00:37:27.480
make sure that those are
consistent, because otherwise

00:37:27.480 --> 00:37:29.200
we'd have to check
it manually.

00:37:29.200 --> 00:37:29.830
Thank you.

00:37:29.830 --> 00:37:30.340
SCOUT SINCLAIR BRODY:
Makes sense.

00:37:30.340 --> 00:37:32.030
All right, on to Office Hours.

00:37:32.030 --> 00:37:32.770
Thank you all for your time.

00:37:32.770 --> 00:37:34.500
RICHARD HYNDMAN: The Office
Hours is on the third floor,

00:37:34.500 --> 00:37:35.470
at the back of the
Android area.

00:37:35.470 --> 00:37:36.820
Thanks very much.

00:37:36.820 --> 00:37:38.070
MATTHEW XIE: Thank you.

