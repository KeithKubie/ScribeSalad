WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:02.750
JAKE ARCHIBALD: So back
in 1995, JavaScript

00:00:02.750 --> 00:00:04.500
was created by Brendan Eich.

00:00:04.500 --> 00:00:08.109
And he did it in 10 days, which
is pretty crazy, that it's

00:00:08.109 --> 00:00:10.320
what most of the
web is built of now.

00:00:10.320 --> 00:00:13.250
JavaScript is 18
years old now, so it's

00:00:13.250 --> 00:00:15.740
legal to drink in
some countries.

00:00:15.740 --> 00:00:18.670
It's also on Twitter,
saying that they

00:00:18.670 --> 00:00:22.050
think they've seen JavaScript
drunk many years ago,

00:00:22.050 --> 00:00:25.100
a lot of the time
quite like that.

00:00:25.100 --> 00:00:29.010
But in 2010, another team set
about making a new language.

00:00:29.010 --> 00:00:31.010
And from what we know
now of the web-- we

00:00:31.010 --> 00:00:34.430
know how the whole web is put
together and the kind of tools

00:00:34.430 --> 00:00:35.060
we need.

00:00:35.060 --> 00:00:36.726
And that team is the
Dart team, and here

00:00:36.726 --> 00:00:38.610
to talk about it--
big warm welcome

00:00:38.610 --> 00:00:40.300
to Seth Ladd and Kasper Lund.

00:00:45.090 --> 00:00:46.050
SETH LADD: Thanks Jake.

00:00:46.050 --> 00:00:47.950
So we won't be
playing the Kenny G.

00:00:47.950 --> 00:00:49.740
We don't want you
guys to fall asleep.

00:00:49.740 --> 00:00:52.095
This is Dart for the
modern web developer.

00:00:52.095 --> 00:00:52.970
My name is Seth Ladd.

00:00:52.970 --> 00:00:55.262
I'm a developer advocate with
the Chrome and Dart team.

00:00:55.262 --> 00:00:56.636
KASPER LUND: And
I'm Kasper Lund.

00:00:56.636 --> 00:00:58.080
I'm an engineer here at Google.

00:00:58.080 --> 00:01:00.580
I work as a tech lead
on the Dart platform.

00:01:00.580 --> 00:01:03.160
And before I ventured
into Dart territory,

00:01:03.160 --> 00:01:06.490
I spent a lot of
years on optimizing V8

00:01:06.490 --> 00:01:09.067
and the optimizing
compiler in there.

00:01:09.067 --> 00:01:09.650
SETH LADD: OK.

00:01:09.650 --> 00:01:11.990
So many of you know
Dart as a language.

00:01:11.990 --> 00:01:14.879
And sure it's a structured,
scalable, familiar language,

00:01:14.879 --> 00:01:17.420
but it's also-- I like to think
of it as a batteries included

00:01:17.420 --> 00:01:17.940
platform.

00:01:17.940 --> 00:01:20.860
There's a great core set
of libraries-- things

00:01:20.860 --> 00:01:23.210
like collections, things like
asynchronous programming,

00:01:23.210 --> 00:01:25.580
futures, streams,
things like numbers,

00:01:25.580 --> 00:01:27.540
booleans, dates, times.

00:01:27.540 --> 00:01:29.710
We also ship a collection
of productive tools--

00:01:29.710 --> 00:01:33.730
a Dart Editor, an analyzer to
give you warnings and errors,

00:01:33.730 --> 00:01:36.390
a package manager we
affectionately call Pub,

00:01:36.390 --> 00:01:38.100
because you play darts in a pub.

00:01:38.100 --> 00:01:41.250
We also ship a virtual machine
which runs Dart code natively.

00:01:41.250 --> 00:01:44.320
You can run that VM on a
command line or on the server,

00:01:44.320 --> 00:01:46.790
and you can also embed
it in client browsers.

00:01:46.790 --> 00:01:49.130
But probably most
importantly, we

00:01:49.130 --> 00:01:51.000
ship a Compiler to JavaScript.

00:01:51.000 --> 00:01:53.100
So the Dart code
you see here today,

00:01:53.100 --> 00:01:54.860
and the Dart apps that
you'll be writing,

00:01:54.860 --> 00:01:57.250
you can compile that down
to essentially ECMAScript

00:01:57.250 --> 00:02:02.734
5, and run it across modern
browsers, desktop and laptop.

00:02:02.734 --> 00:02:04.900
You might have heard recently,
we launched Dart 1.0.

00:02:04.900 --> 00:02:06.941
It was a big milestone
for us, hopefully exciting

00:02:06.941 --> 00:02:07.730
for you guys.

00:02:07.730 --> 00:02:09.120
The big point of this, really--

00:02:09.120 --> 00:02:09.620
[APPLAUSE]

00:02:09.620 --> 00:02:10.495
SETH LADD: Thank you.

00:02:13.430 --> 00:02:15.210
The journey starts
here, really, for us.

00:02:15.210 --> 00:02:17.400
The big point here,
the big take away,

00:02:17.400 --> 00:02:20.110
is it's now stability
you can count on.

00:02:20.110 --> 00:02:22.340
We've been open source
since about October 2011,

00:02:22.340 --> 00:02:25.190
and gotten tons of feedback
from internal developers,

00:02:25.190 --> 00:02:27.730
external developers,
hackathons, code labs.

00:02:27.730 --> 00:02:29.750
And we've collected
that all and launched

00:02:29.750 --> 00:02:32.730
what is now a stable language,
stable core libraries for you

00:02:32.730 --> 00:02:34.520
to build production apps on.

00:02:34.520 --> 00:02:36.880
So now is the right
time to try it.

00:02:36.880 --> 00:02:37.380
OK.

00:02:37.380 --> 00:02:39.850
So when I said you
can use Dart today,

00:02:39.850 --> 00:02:42.619
I think I actually mean you can
use Dart like in the next hour.

00:02:42.619 --> 00:02:45.160
So we're going to do a lightning
tour of the syntax structure

00:02:45.160 --> 00:02:47.480
and semantics to show
you how familiar and easy

00:02:47.480 --> 00:02:49.460
it is to get started.

00:02:49.460 --> 00:02:52.320
So Dart, by design,
is very easy to learn.

00:02:52.320 --> 00:02:53.160
We have semi-colons.

00:02:53.160 --> 00:02:54.370
We have curly braces.

00:02:54.370 --> 00:02:56.904
In fact, we got a little flak
when we first launched Dart.

00:02:56.904 --> 00:02:59.320
People were like, why don't
you make the next big Haskell?

00:02:59.320 --> 00:03:01.195
And we're like, we want
more than five users.

00:03:01.195 --> 00:03:03.660
And so we wanted to make sure
that you guys can totally

00:03:03.660 --> 00:03:04.970
understand this code.

00:03:04.970 --> 00:03:06.470
We've run hackathons
and code labs.

00:03:06.470 --> 00:03:07.110
People get it.

00:03:07.110 --> 00:03:09.432
So familiar, classes.

00:03:09.432 --> 00:03:11.140
But just because it's
a familiar language

00:03:11.140 --> 00:03:12.640
you can dive into
in about an hour,

00:03:12.640 --> 00:03:14.431
doesn't mean we can't
take this opportunity

00:03:14.431 --> 00:03:17.099
to introduce new features, for
instance, with constructors.

00:03:17.099 --> 00:03:18.640
What do we always
do in constructors?

00:03:18.640 --> 00:03:19.760
This dot x equals x.

00:03:19.760 --> 00:03:20.830
This dot y equals y.

00:03:20.830 --> 00:03:21.910
This is getting boring.

00:03:21.910 --> 00:03:23.964
So Dart says, hey, if
the name of the field

00:03:23.964 --> 00:03:25.880
is the same as the
constructor parameter, just

00:03:25.880 --> 00:03:27.840
say, this.strength in this case.

00:03:27.840 --> 00:03:30.134
And that will desugar to
this.strength equals strength.

00:03:30.134 --> 00:03:31.800
Just those nice
additions that make this

00:03:31.800 --> 00:03:34.970
feel more terse, more scripty.

00:03:34.970 --> 00:03:38.310
Speaking of scripty, Dart
has operator overriding.

00:03:38.310 --> 00:03:41.450
So plus, minus, et cetera,
that's in this language.

00:03:41.450 --> 00:03:43.450
We also named
optional parameters.

00:03:43.450 --> 00:03:45.094
Again, it's a
structure language.

00:03:45.094 --> 00:03:47.510
It may look like the structure
language you've been using,

00:03:47.510 --> 00:03:49.009
but it has those
features that allow

00:03:49.009 --> 00:03:51.492
you to have a terse programming
experience that you might

00:03:51.492 --> 00:03:53.450
be more familiar with
than scripting languages.

00:03:53.450 --> 00:03:55.910
In fact, this case here, hands
is an optional parameter,

00:03:55.910 --> 00:03:57.550
but also has a
default value of one.

00:03:57.550 --> 00:04:01.000
So say more without typing more.

00:04:01.000 --> 00:04:02.550
We also support
one-line functions.

00:04:02.550 --> 00:04:02.960
This is critical.

00:04:02.960 --> 00:04:05.150
There's a lot of callbacks
going on in web programming,

00:04:05.150 --> 00:04:06.524
and a lot of times
you want to do

00:04:06.524 --> 00:04:09.900
really small, inline
function literals.

00:04:09.900 --> 00:04:12.370
We support that with
the fat arrow syntax.

00:04:12.370 --> 00:04:14.050
And we also have
string interpolation,

00:04:14.050 --> 00:04:16.630
making it very easy and quick
to create strings, just dollar

00:04:16.630 --> 00:04:18.376
sign, variable, or expression.

00:04:18.376 --> 00:04:19.250
And it's right there.

00:04:19.250 --> 00:04:21.499
It's a lot easier than doing
string builders or string

00:04:21.499 --> 00:04:23.870
concatenation.

00:04:23.870 --> 00:04:26.070
So Dart is its own language.

00:04:26.070 --> 00:04:29.570
It's not just the syntax
that masks another syntax.

00:04:29.570 --> 00:04:31.980
We have our own clean semantics.

00:04:31.980 --> 00:04:34.986
So we want to turn more of these
"wat" moments, which I'm not

00:04:34.986 --> 00:04:37.080
even sure what's going
on here, into the totally

00:04:37.080 --> 00:04:38.940
awesome atomic
dinosaur nuclear rocks.

00:04:38.940 --> 00:04:43.359
We want you to have more on
the right, less on the left.

00:04:43.359 --> 00:04:45.650
Some examples of the cleaned
up semantics that give you

00:04:45.650 --> 00:04:48.850
a more logical programming
experience in Dart-- only true

00:04:48.850 --> 00:04:49.489
is truthy.

00:04:49.489 --> 00:04:50.030
There you go.

00:04:50.030 --> 00:04:51.290
Now you know the truthy rules.

00:04:51.290 --> 00:04:52.560
Good job.

00:04:52.560 --> 00:04:55.920
There is no
undefined, only null.

00:04:55.920 --> 00:04:59.550
Yes, totally, cleaned up.

00:04:59.550 --> 00:05:02.370
No type coercion with things
like double equals and plus.

00:05:02.370 --> 00:05:06.340
So when you try to do something
funky, we're going to tell you.

00:05:06.340 --> 00:05:07.910
Pop quiz time.

00:05:07.910 --> 00:05:09.970
Here's a string "hello"
we call .missing,

00:05:09.970 --> 00:05:11.780
which obviously does
not exist on string.

00:05:11.780 --> 00:05:15.220
What would you want to
happen at this point?

00:05:15.220 --> 00:05:16.640
Undefined?

00:05:16.640 --> 00:05:17.750
I don't want undefined.

00:05:17.750 --> 00:05:21.180
I want to be told that there's
no missing method on string.

00:05:21.180 --> 00:05:23.580
And sure enough, at runtime,
when you hit code like this,

00:05:23.580 --> 00:05:26.090
the program tells you
with a very clean error.

00:05:26.090 --> 00:05:28.760
So a much more logical
programming experience.

00:05:28.760 --> 00:05:31.400
If you were to compare
'hello', which is a string,

00:05:31.400 --> 00:05:32.967
is it greater than one?

00:05:32.967 --> 00:05:34.800
I think this returns
false, but actually I'm

00:05:34.800 --> 00:05:36.730
not really sure why.

00:05:36.730 --> 00:05:40.391
So what would you
want this to happen?

00:05:40.391 --> 00:05:41.140
You want an error.

00:05:41.140 --> 00:05:42.564
You want to be--
hey, man, string

00:05:42.564 --> 00:05:44.480
does not have an instance
method greater than.

00:05:44.480 --> 00:05:47.790
You get told at runtime exactly
where the problem happened.

00:05:47.790 --> 00:05:50.360
Much more logical
programming experience.

00:05:50.360 --> 00:05:51.120
Variable scope.

00:05:51.120 --> 00:05:53.411
This one's a little bit
longer, so take a look at this.

00:05:53.411 --> 00:05:54.570
We have a main function.

00:05:54.570 --> 00:05:56.970
if(true), there's foo,
and then print(foo),

00:05:56.970 --> 00:05:58.494
but there's also
a top level foo.

00:05:58.494 --> 00:06:00.660
So the question I have for
you is-- when I run this,

00:06:00.660 --> 00:06:03.661
what will it print?

00:06:03.661 --> 00:06:04.660
KASPER LUND: Any takers?

00:06:04.660 --> 00:06:07.050
SETH LADD: It's 50/50 chance.

00:06:07.050 --> 00:06:07.880
Top top-level.

00:06:07.880 --> 00:06:08.550
Right.

00:06:08.550 --> 00:06:11.440
This prints top-level in
Dart, no variable hoisting.

00:06:11.440 --> 00:06:14.571
It's a totally logical
lexical scope-- lexical

00:06:14.571 --> 00:06:15.820
analysis-- of what's going on.

00:06:15.820 --> 00:06:17.980
If you hand most
developers this code,

00:06:17.980 --> 00:06:20.970
they'll be able to understand
what's going on here.

00:06:20.970 --> 00:06:23.140
Speaking of lexical
scope, even this

00:06:23.140 --> 00:06:24.310
is lexically scoped in Dart.

00:06:24.310 --> 00:06:26.851
This is one of the things that
totally tripped me up earlier.

00:06:26.851 --> 00:06:28.300
Here's a class AwesomeButton.

00:06:28.300 --> 00:06:31.000
And in its constructor you
set up a Click Handler.

00:06:31.000 --> 00:06:33.856
And when the button is clicked,
call this.atomicDinosaurRock.

00:06:33.856 --> 00:06:35.230
Well, what is this
at this point?

00:06:35.230 --> 00:06:37.310
The lexically
scoped this that is

00:06:37.310 --> 00:06:38.532
an instance of AwesomeButton.

00:06:38.532 --> 00:06:40.740
You give most people this
code and they will tell you

00:06:40.740 --> 00:06:43.940
what method this is calling
on, which is, I think,

00:06:43.940 --> 00:06:46.190
a pretty big improvement.

00:06:46.190 --> 00:06:48.040
So that's a little
bit on the semantics,

00:06:48.040 --> 00:06:50.650
and a little bit on the syntax.

00:06:50.650 --> 00:06:52.380
But Dart is also
designed to scale

00:06:52.380 --> 00:06:53.910
from just a couple
lines of code.

00:06:53.910 --> 00:06:55.330
You could certainly write
a ten line Dart script

00:06:55.330 --> 00:06:56.620
and have it look very scripty.

00:06:56.620 --> 00:07:00.380
But you can scale all way up
to millions of lines of code.

00:07:00.380 --> 00:07:01.520
Now we saw functions.

00:07:01.520 --> 00:07:02.220
We saw classes.

00:07:02.220 --> 00:07:03.310
We have mixins.

00:07:03.310 --> 00:07:04.120
We have interfaces.

00:07:04.120 --> 00:07:06.328
I want to talk about libraries,
which is a nice piece

00:07:06.328 --> 00:07:08.000
to help you
modularize your code.

00:07:08.000 --> 00:07:09.375
Dart libraries
are very flexible.

00:07:09.375 --> 00:07:11.170
You simply define a
file as a library.

00:07:11.170 --> 00:07:13.375
You can import libraries
from the core SDK.

00:07:13.375 --> 00:07:16.400
You can import libraries from
other people, or other files.

00:07:16.400 --> 00:07:19.590
And then you can define any
number of top level constructs

00:07:19.590 --> 00:07:20.270
in a library.

00:07:20.270 --> 00:07:22.614
So no more one public
class per file thing,

00:07:22.614 --> 00:07:23.530
if you come from Java.

00:07:23.530 --> 00:07:26.572
So in this case, two classes
and even a top level function.

00:07:26.572 --> 00:07:28.780
In Dart, you don't have to
wrap everything in a class

00:07:28.780 --> 00:07:29.840
if you don't want to.

00:07:29.840 --> 00:07:33.845
So nice, scalable
structure for you to grow.

00:07:33.845 --> 00:07:35.220
Hopefully, you
guys saw that this

00:07:35.220 --> 00:07:37.100
is a language you can
start using right away.

00:07:37.100 --> 00:07:40.190
But of course, we use
Dart to get onto the web.

00:07:40.190 --> 00:07:42.820
And to get on the web, you have
to compile Dart to JavaScript.

00:07:42.820 --> 00:07:45.020
And to do that and to
show you how it works,

00:07:45.020 --> 00:07:47.764
I'll turn it over to Kasper
to tell you all about dart2js.

00:07:47.764 --> 00:07:48.930
KASPER LUND: Thank you Seth.

00:07:48.930 --> 00:07:50.860
So finally, now I
can say something.

00:07:50.860 --> 00:07:51.707
It's wonderful.

00:07:51.707 --> 00:07:53.540
I'm going to tell you
a little bit about how

00:07:53.540 --> 00:07:55.240
we compile to
efficient JavaScript.

00:07:55.240 --> 00:07:58.060
And it's very, very
important to us to make sure

00:07:58.060 --> 00:08:00.520
that Dart runs really well
on all modern browsers,

00:08:00.520 --> 00:08:03.700
so we put a lot of
effort into that area.

00:08:03.700 --> 00:08:05.100
Our goals are fairly simple.

00:08:05.100 --> 00:08:07.905
We want to generate small code,
we want to generate fast code,

00:08:07.905 --> 00:08:09.530
and we want to make
sure that we retain

00:08:09.530 --> 00:08:13.670
the nice, clean proper Dart
semantics while doing so.

00:08:13.670 --> 00:08:16.310
So simple goals is a
good starting point.

00:08:16.310 --> 00:08:18.150
But to do this, and
to do it efficiently,

00:08:18.150 --> 00:08:20.300
we need a real
optimizing compiler,

00:08:20.300 --> 00:08:22.900
something that
doesn't just do a one

00:08:22.900 --> 00:08:24.390
to one translation
in a simple way.

00:08:24.390 --> 00:08:27.610
We actually need a lot of
the neat, modern compiling

00:08:27.610 --> 00:08:31.460
techniques we've learned
to love from other more

00:08:31.460 --> 00:08:33.929
involved projects, like V8.

00:08:33.929 --> 00:08:35.429
So we need function inlining.

00:08:35.429 --> 00:08:37.010
We need loop-invariant
code motion.

00:08:37.010 --> 00:08:38.419
We need global value numbering.

00:08:38.419 --> 00:08:40.770
We need a lot of these
things-- type propagation,

00:08:40.770 --> 00:08:43.120
redundant lode elimination,
dead code elimination,

00:08:43.120 --> 00:08:44.027
and much, much more.

00:08:44.027 --> 00:08:45.860
So we need a lot of
things in this compiler.

00:08:45.860 --> 00:08:48.430
We want to do a good job
in optimizing your code,

00:08:48.430 --> 00:08:50.490
so you don't have
to worry about it.

00:08:50.490 --> 00:08:52.936
So let's take a look at a
very simple Dart method, just

00:08:52.936 --> 00:08:54.810
to give you an impression
of what we actually

00:08:54.810 --> 00:08:56.090
translate the code to.

00:08:56.090 --> 00:08:58.460
Here's a main method that
allocates a few points,

00:08:58.460 --> 00:09:00.709
and then we compute the
distance between these points.

00:09:00.709 --> 00:09:01.980
Very simple code.

00:09:01.980 --> 00:09:03.586
Luckily, a simple
Dart method actually

00:09:03.586 --> 00:09:05.460
compiles to relatively
simple JavaScript too.

00:09:05.460 --> 00:09:08.420
So you will allocate
points the same way

00:09:08.420 --> 00:09:09.710
as you would expect it to.

00:09:09.710 --> 00:09:11.490
The only real difference
here is that when

00:09:11.490 --> 00:09:13.750
you call the distanceTo
method, we actually

00:09:13.750 --> 00:09:17.240
encode the arity, the
number of parameters passed,

00:09:17.240 --> 00:09:18.420
in the method name.

00:09:18.420 --> 00:09:19.586
Now why do we do that?

00:09:19.586 --> 00:09:21.960
The reason why we do that is
because in JavaScript, we're

00:09:21.960 --> 00:09:23.910
allowed to pass any
number of arguments.

00:09:23.910 --> 00:09:26.510
Too few or too many, it
doesn't really matter.

00:09:26.510 --> 00:09:29.309
But usually it leads to
weird and surprising behavior

00:09:29.309 --> 00:09:30.850
at runtime if you
do that, so we want

00:09:30.850 --> 00:09:32.266
to be a little bit
stricter there.

00:09:32.266 --> 00:09:35.129
So to live by Dart's proper
semantics rules there,

00:09:35.129 --> 00:09:36.670
we actually have to
check that you're

00:09:36.670 --> 00:09:38.030
calling with the right
number of parameters.

00:09:38.030 --> 00:09:39.405
And the fastest
way of doing that

00:09:39.405 --> 00:09:41.070
is just encoding it
in the method name.

00:09:41.070 --> 00:09:42.900
If you call with
too many parameters,

00:09:42.900 --> 00:09:46.720
you'll get an error that
that method doesn't exist.

00:09:46.720 --> 00:09:49.570
So when you have
large applications,

00:09:49.570 --> 00:09:51.470
you need some sort
of tool to make sure

00:09:51.470 --> 00:09:52.890
that you're not
actually shipping

00:09:52.890 --> 00:09:54.190
too much code to your clients.

00:09:54.190 --> 00:09:55.606
In particular, in
the set up where

00:09:55.606 --> 00:09:57.517
you have a nice, rich
set of core libraries

00:09:57.517 --> 00:09:59.850
and a nice set of third party
libraries you can include,

00:09:59.850 --> 00:10:01.180
you want to make
sure that whatever

00:10:01.180 --> 00:10:02.990
you ship to your clients
is only the needed

00:10:02.990 --> 00:10:04.810
bits, not all the other stuff.

00:10:04.810 --> 00:10:06.960
To do that, we have
an implementation

00:10:06.960 --> 00:10:09.385
of an algorithm called tree
shaking in the compiler.

00:10:09.385 --> 00:10:11.500
It works a little
something like this.

00:10:11.500 --> 00:10:14.820
If you have an application that
has a main method, and perhaps

00:10:14.820 --> 00:10:17.810
a few other methods
close by, foo and baz,

00:10:17.810 --> 00:10:20.420
but it's only calling
the foo method,

00:10:20.420 --> 00:10:21.940
and maybe the foo
method in return

00:10:21.940 --> 00:10:24.150
calls code pulled in
from another library--

00:10:24.150 --> 00:10:26.820
the bar method
down on the right--

00:10:26.820 --> 00:10:29.750
the library may actually have
unused parts too like the boo

00:10:29.750 --> 00:10:32.990
function here-- we want
the dart2js compiler

00:10:32.990 --> 00:10:37.320
to actually take
this set of methods

00:10:37.320 --> 00:10:39.150
like the transitive
closure of everything

00:10:39.150 --> 00:10:41.649
that you have available to
you, and shake it really good

00:10:41.649 --> 00:10:43.440
and get all this stuff
that you're actually

00:10:43.440 --> 00:10:44.742
not using out of the system.

00:10:44.742 --> 00:10:46.200
It's a process
called tree shaking.

00:10:46.200 --> 00:10:49.050
We do that and the
result is a lot smaller.

00:10:49.050 --> 00:10:52.040
It only contains main, foo,
and bar, the needed parts.

00:10:52.040 --> 00:10:54.540
So to implement this
in the compiler,

00:10:54.540 --> 00:10:56.990
we actually go
through a few steps.

00:10:56.990 --> 00:10:58.770
First we read all
your Dart sources.

00:10:58.770 --> 00:11:01.210
We don't actually
parse them fully.

00:11:01.210 --> 00:11:02.750
We don't look into
all the methods.

00:11:02.750 --> 00:11:04.810
We just look at the
structure of your code,

00:11:04.810 --> 00:11:06.880
find all the imports,
look at the libraries

00:11:06.880 --> 00:11:09.622
that you depend on,
and read those in too.

00:11:09.622 --> 00:11:11.330
When we have everything
read in that way,

00:11:11.330 --> 00:11:12.954
and we know the
structure of your code,

00:11:12.954 --> 00:11:17.930
we can actually start doing this
first level of tree shaking.

00:11:17.930 --> 00:11:18.864
We have two levels.

00:11:18.864 --> 00:11:20.530
This is the first
one, and this actually

00:11:20.530 --> 00:11:22.970
is what we call the
resolution tree shaking.

00:11:22.970 --> 00:11:25.220
And resolution is the process
of not really compiling

00:11:25.220 --> 00:11:27.720
code, but just trying to figure
out what you're referring to

00:11:27.720 --> 00:11:29.090
at certain points in the code.

00:11:29.090 --> 00:11:31.360
So it actually starts by
looking at the main function,

00:11:31.360 --> 00:11:34.030
and look at what kind of classes
or instances of which classes

00:11:34.030 --> 00:11:36.702
you allocate in there, and which
other methods you're calling.

00:11:36.702 --> 00:11:38.410
All those methods need
to go into a queue

00:11:38.410 --> 00:11:41.280
so we can process them, parse
them, get them resolved.

00:11:41.280 --> 00:11:43.750
And you just keep doing that
until nothing new is added

00:11:43.750 --> 00:11:45.480
to the queue, and
then you're done.

00:11:45.480 --> 00:11:47.090
It's relatively
simple to do this,

00:11:47.090 --> 00:11:48.790
and it gives us a
good approximation

00:11:48.790 --> 00:11:52.040
of cutting down everything,
but only based on method names.

00:11:52.040 --> 00:11:53.470
We can do a little bit better.

00:11:53.470 --> 00:11:55.178
So once we're done
with that, we actually

00:11:55.178 --> 00:11:57.834
start the process all over
again in the compilation queue.

00:11:57.834 --> 00:11:59.250
And this is where
we actually will

00:11:59.250 --> 00:12:03.640
start looking at what you
really put inside your methods,

00:12:03.640 --> 00:12:05.490
and do data-flow
analysis, and we

00:12:05.490 --> 00:12:07.454
will track how types
flow through that code.

00:12:07.454 --> 00:12:08.870
And that gives us
more information

00:12:08.870 --> 00:12:11.350
about what you're
actually needing to emit.

00:12:11.350 --> 00:12:14.270
And we do the last level of
the tree shaking at that point.

00:12:14.270 --> 00:12:17.357
The end result is that we do a
really good job of making sure

00:12:17.357 --> 00:12:18.940
that things that you
really don't need

00:12:18.940 --> 00:12:21.290
are not pulled into
your application.

00:12:21.290 --> 00:12:25.180
Finally, we actually emit
the code to a single JS file.

00:12:25.180 --> 00:12:26.670
So you can run it
in your browser.

00:12:26.670 --> 00:12:27.530
Fairly simple stuff.

00:12:27.530 --> 00:12:29.710
SETH LADD: I love this because
this is the tools helping me.

00:12:29.710 --> 00:12:31.501
I don't need to be
crafting my application.

00:12:31.501 --> 00:12:34.242
I just let the tool analyze
my program, take care of it.

00:12:34.242 --> 00:12:35.950
KASPER LUND: That's
the way it should be.

00:12:35.950 --> 00:12:39.290
So let's take a look at how
this actually works in practice.

00:12:39.290 --> 00:12:42.730
Just to give you a feel for
how dart2js does its magic,

00:12:42.730 --> 00:12:46.510
I'm going to dive into
a well-known algorithm.

00:12:46.510 --> 00:12:48.140
It's a constraint
solving algorithm.

00:12:48.140 --> 00:12:49.640
The reason why I'm
choosing this one

00:12:49.640 --> 00:12:53.360
is it's a well
understood piece of code.

00:12:53.360 --> 00:12:55.896
It's been used to benchmark
lots of different language

00:12:55.896 --> 00:12:57.020
limitations over the years.

00:12:57.020 --> 00:12:59.710
It's actually part of
the Octane benchmark

00:12:59.710 --> 00:13:01.030
Linus mentioned this morning.

00:13:01.030 --> 00:13:02.810
So it's a well-known
piece of code.

00:13:02.810 --> 00:13:03.710
It is structured.

00:13:03.710 --> 00:13:07.520
It has inheritance, and
classes, and everything

00:13:07.520 --> 00:13:09.980
we need to actually do a
good job in making your code

00:13:09.980 --> 00:13:10.770
run fast.

00:13:10.770 --> 00:13:11.970
So let's take a look at it.

00:13:11.970 --> 00:13:13.180
DeltaBlue is a
constraint solver.

00:13:13.180 --> 00:13:14.070
What does that mean?

00:13:14.070 --> 00:13:16.680
Well, basically, it's
a fairly abstract thing

00:13:16.680 --> 00:13:20.360
that works on
constraints on variables.

00:13:20.360 --> 00:13:23.350
Constraints can be
one way or two way.

00:13:23.350 --> 00:13:26.817
There are binary or unary
constraints of different kinds.

00:13:26.817 --> 00:13:28.400
And they can be used
to, for instance,

00:13:28.400 --> 00:13:31.120
model the constraints
involving laying out something

00:13:31.120 --> 00:13:31.751
on your screen.

00:13:31.751 --> 00:13:34.250
I'm pretty sure that some of
the things you just heard about

00:13:34.250 --> 00:13:36.543
from Eric actually use
this constraint to think

00:13:36.543 --> 00:13:38.490
of that internally
when building layouts.

00:13:38.490 --> 00:13:41.417
So doesn't lose an
implementation of such a beast.

00:13:41.417 --> 00:13:43.750
It uses constraints and there's
a nice hierarchy of them

00:13:43.750 --> 00:13:46.960
with unary and binary
constraints and variables.

00:13:46.960 --> 00:13:49.250
Let me show you a piece
of code from this thing,

00:13:49.250 --> 00:13:51.170
to make it a little
bit more concrete.

00:13:51.170 --> 00:13:54.690
This is a function from
the DeltaBlue algorithm.

00:13:54.690 --> 00:13:55.770
It's fairly simple.

00:13:55.770 --> 00:13:58.590
You don't have to understand
all the details here, but just

00:13:58.590 --> 00:14:02.260
note that the way it works here
is that you take a variable v,

00:14:02.260 --> 00:14:04.800
and you try to figure out all
the constraints that actually

00:14:04.800 --> 00:14:07.310
consume that
variable, and put them

00:14:07.310 --> 00:14:10.050
in a list that is also
passed in as a parameter.

00:14:10.050 --> 00:14:13.910
Hopefully this code is
reasonably readable to you.

00:14:13.910 --> 00:14:16.262
It's Dart code and to me
this looks like what I--

00:14:16.262 --> 00:14:18.220
SETH LADD: Kind of
representative of code a lot

00:14:18.220 --> 00:14:18.853
of us would write.

00:14:18.853 --> 00:14:19.620
KASPER LUND: Yeah.

00:14:19.620 --> 00:14:22.815
So in Dart, we have an
optional aesthetic type system.

00:14:22.815 --> 00:14:24.940
So you do not have to write
the types if you really

00:14:24.940 --> 00:14:25.770
don't want to.

00:14:25.770 --> 00:14:27.845
Sometimes it's nice to
have the document what

00:14:27.845 --> 00:14:30.530
a parameter means, which
is why I've done it here.

00:14:30.530 --> 00:14:32.610
But it's important to
us to make it clear

00:14:32.610 --> 00:14:36.110
that the types that you put
in are not actually used

00:14:36.110 --> 00:14:38.400
for up optimization purposes,
because we don't really

00:14:38.400 --> 00:14:40.921
know if you want
to type them in.

00:14:40.921 --> 00:14:43.420
So we don't want to force you
into typing them in the places

00:14:43.420 --> 00:14:44.450
where you don't want to.

00:14:44.450 --> 00:14:46.050
So I can go ahead
and remove them.

00:14:46.050 --> 00:14:47.420
SETH LADD: And they
might also be incorrect.

00:14:47.420 --> 00:14:49.214
KASPER LUND: They
could be incorrect.

00:14:49.214 --> 00:14:51.130
Anyway, I've gone ahead
and removed the types.

00:14:51.130 --> 00:14:54.040
The semantics of this
algorithm is exactly the same,

00:14:54.040 --> 00:14:55.149
no differences at all.

00:14:55.149 --> 00:14:57.690
It's just a little bit shorter,
and maybe a little bit harder

00:14:57.690 --> 00:14:58.330
to understand.

00:14:58.330 --> 00:15:00.810
But anyway, the code is
there, it's the same thing,

00:15:00.810 --> 00:15:03.080
and this is what we're
going to try to optimize.

00:15:03.080 --> 00:15:06.720
So first attempt at
actually compiling this code

00:15:06.720 --> 00:15:09.920
to JavaScript is somewhat large.

00:15:09.920 --> 00:15:11.350
So this is the
unoptimized version

00:15:11.350 --> 00:15:13.550
of the method you just saw.

00:15:13.550 --> 00:15:17.440
It compiled to 500 and
something characters.

00:15:17.440 --> 00:15:18.780
It's a little bit too long.

00:15:18.780 --> 00:15:22.280
I'm not even sure you can read
it in the back of the hall

00:15:22.280 --> 00:15:22.900
here.

00:15:22.900 --> 00:15:24.510
But it works.

00:15:24.510 --> 00:15:25.820
It has the right semantics.

00:15:25.820 --> 00:15:27.460
Everything works as specified.

00:15:27.460 --> 00:15:30.040
And it runs reasonably well.

00:15:30.040 --> 00:15:33.110
But it's-- I hope you agree--
it's simply not good enough.

00:15:33.110 --> 00:15:34.990
We want to do a lot better.

00:15:34.990 --> 00:15:37.930
So let's try to dive into
how we actually do better

00:15:37.930 --> 00:15:39.384
than just this blob of code.

00:15:39.384 --> 00:15:41.550
Even though the semantics
is really important to us,

00:15:41.550 --> 00:15:44.930
we also really care
about performance.

00:15:44.930 --> 00:15:46.090
So what makes this big?

00:15:46.090 --> 00:15:49.010
Well, this is just
one of the examples

00:15:49.010 --> 00:15:51.500
of why this code is little bit
bigger than what we'd like.

00:15:51.500 --> 00:15:54.400
So as Seth mentioned,
we have strict semantics

00:15:54.400 --> 00:15:56.670
about what you can compare
to numbers, for instance.

00:15:56.670 --> 00:15:59.630
So we don't want to run
into issues when you end up

00:15:59.630 --> 00:16:02.300
emitting JavaScript code that
just ends up comparing numbers

00:16:02.300 --> 00:16:04.590
and strengths for instance,
because we don't really

00:16:04.590 --> 00:16:06.180
want to rely on that behavior.

00:16:06.180 --> 00:16:08.834
So in this case
we're reading-- see

00:16:08.834 --> 00:16:10.780
if I can get this to
progress, there we

00:16:10.780 --> 00:16:13.527
go-- so we're reading the length
of something that probably

00:16:13.527 --> 00:16:15.110
is an array, but
we're not quite sure.

00:16:15.110 --> 00:16:17.359
So we don't know that the
length is actually a number.

00:16:17.359 --> 00:16:20.630
So before we continue
to actually compare

00:16:20.630 --> 00:16:22.650
this length against
a real number,

00:16:22.650 --> 00:16:25.970
we have to make sure that
it actually is a number.

00:16:25.970 --> 00:16:29.170
So we insert an explicit
check in the code that

00:16:29.170 --> 00:16:32.804
makes sure that we don't end
up relying on this somewhat

00:16:32.804 --> 00:16:34.220
surprising behavior
of JavaScript,

00:16:34.220 --> 00:16:36.178
where you can compare
numbers against strengths

00:16:36.178 --> 00:16:37.290
and get some result out.

00:16:37.290 --> 00:16:40.410
So this adds code-- more checks.

00:16:40.410 --> 00:16:42.070
So our challenge
is fairly simple.

00:16:42.070 --> 00:16:45.380
We want to have clean semantics,
unsurprising behavior,

00:16:45.380 --> 00:16:47.260
but we do not really
want those extra checks

00:16:47.260 --> 00:16:48.718
when we're compiling
to JavaScript.

00:16:48.718 --> 00:16:51.650
So how can we go
about doing that?

00:16:51.650 --> 00:16:54.800
The trick is right behind
me-- global optimizations.

00:16:54.800 --> 00:16:58.230
So we really need
to do better, and we

00:16:58.230 --> 00:17:00.790
need to do more aggressive
optimizations in the code

00:17:00.790 --> 00:17:03.860
to make it end up being
very fast and very good.

00:17:03.860 --> 00:17:05.890
So let's look at that.

00:17:05.890 --> 00:17:08.220
First up-- Dart is structured.

00:17:08.220 --> 00:17:09.530
It has classes.

00:17:09.530 --> 00:17:10.510
It has methods.

00:17:10.510 --> 00:17:11.960
It has a good structure.

00:17:11.960 --> 00:17:14.380
We can actually do
whole program analysis.

00:17:14.380 --> 00:17:15.829
So when we compile
the program, we

00:17:15.829 --> 00:17:17.369
can look at every
single bit in it,

00:17:17.369 --> 00:17:19.329
and we can actually
understand what's going on.

00:17:19.329 --> 00:17:20.700
That's a huge win for us.

00:17:20.700 --> 00:17:22.789
This allows us to actually
do code navigation

00:17:22.789 --> 00:17:24.510
and great refactoring tools.

00:17:24.510 --> 00:17:27.329
But maybe even more
dear to my heart

00:17:27.329 --> 00:17:30.370
is that we can also do a global
compile-time optimizations.

00:17:30.370 --> 00:17:31.989
So we can actually
analyze your code,

00:17:31.989 --> 00:17:33.780
understand the dependencies
between things,

00:17:33.780 --> 00:17:36.450
maybe, to a certain extent,
better than what you actually

00:17:36.450 --> 00:17:38.180
care to do yourself,
as a developer.

00:17:38.180 --> 00:17:40.150
And then we can
optimize based on that.

00:17:40.150 --> 00:17:41.712
It's pretty powerful.

00:17:41.712 --> 00:17:43.670
One of things that we
do, and one of the things

00:17:43.670 --> 00:17:45.753
that really work well for
something like DeltaBlue

00:17:45.753 --> 00:17:47.480
and for most
applications in general,

00:17:47.480 --> 00:17:49.090
is that we infer types.

00:17:49.090 --> 00:17:50.930
We compute what
types we actually

00:17:50.930 --> 00:17:54.650
will see at runtime at
different points in the code.

00:17:54.650 --> 00:17:56.420
And the way that
works is-- Here's

00:17:56.420 --> 00:17:58.280
a simple example
of how that works.

00:17:58.280 --> 00:18:01.070
Main function calls
foo, that calls bar,

00:18:01.070 --> 00:18:02.610
that calls foo again, basically.

00:18:02.610 --> 00:18:04.610
So a bunch of functions
calling each other.

00:18:04.610 --> 00:18:07.110
So how do we infer types for
the parameters of these things?

00:18:07.110 --> 00:18:08.943
How do we get the
compiler more information?

00:18:08.943 --> 00:18:10.820
Well, we start by
looking at main.

00:18:10.820 --> 00:18:12.102
So it's very simple.

00:18:12.102 --> 00:18:14.310
And by analyzing main we
can see that foo is actually

00:18:14.310 --> 00:18:15.750
called with an
integer parameter.

00:18:15.750 --> 00:18:17.020
OK, so far, so good.

00:18:17.020 --> 00:18:19.000
So we analyze foo,
under the assumption

00:18:19.000 --> 00:18:20.100
that this called the
integer parameter.

00:18:20.100 --> 00:18:21.490
Do we learn something from that?

00:18:21.490 --> 00:18:22.270
Sure.

00:18:22.270 --> 00:18:24.670
Bar is apparently also called
with an integer parameter.

00:18:24.670 --> 00:18:25.409
So far, so good.

00:18:25.409 --> 00:18:26.950
We can finish this
game a little bit.

00:18:26.950 --> 00:18:28.590
So we end up in bar.

00:18:28.590 --> 00:18:31.400
And we realize that if bar
is called with an integer

00:18:31.400 --> 00:18:33.430
parameter, then it
ends up calling foo

00:18:33.430 --> 00:18:34.970
with a string
interpolated version

00:18:34.970 --> 00:18:37.424
of that parameter,
which is a string.

00:18:37.424 --> 00:18:38.840
So foo is now
called with a string

00:18:38.840 --> 00:18:41.090
too, so we have to
go back and iterate.

00:18:41.090 --> 00:18:43.460
So foo is now apparently
also called with a string.

00:18:43.460 --> 00:18:45.360
That means bar is called
with a string too.

00:18:45.360 --> 00:18:47.010
And finally, inside
the bar method,

00:18:47.010 --> 00:18:50.290
we realize that that means that
print is called with a string.

00:18:50.290 --> 00:18:51.630
So far so good.

00:18:51.630 --> 00:18:53.700
All in all, the
compiler can actually

00:18:53.700 --> 00:18:58.900
conclude that x and y are both
either integers or strings.

00:18:58.900 --> 00:19:00.511
This is a very,
very simple example,

00:19:00.511 --> 00:19:03.010
but it actually works really
well in practice for large apps

00:19:03.010 --> 00:19:05.304
too.

00:19:05.304 --> 00:19:06.720
So let's look at
DeltaBlue and see

00:19:06.720 --> 00:19:07.970
how that actually works there.

00:19:07.970 --> 00:19:08.890
It's pretty simple.

00:19:08.890 --> 00:19:10.220
So there are a
couple of things here

00:19:10.220 --> 00:19:11.344
we want to infer types for.

00:19:11.344 --> 00:19:15.510
For instance, the two
parameters, like v and coll.

00:19:15.510 --> 00:19:17.710
And the infer actually
does that by looking

00:19:17.710 --> 00:19:20.330
at all the coll sites that
call addConstraintsConsumingTo.

00:19:20.330 --> 00:19:24.350
And we actually learned that v
is either null or a variable,

00:19:24.350 --> 00:19:26.600
and that coll cannot be null.

00:19:26.600 --> 00:19:28.700
It always is a JavaScript
array, containing

00:19:28.700 --> 00:19:31.250
only subclasses of
the class constraint.

00:19:31.250 --> 00:19:32.740
That's pretty powerful.

00:19:32.740 --> 00:19:35.370
So that's good to know for us.

00:19:35.370 --> 00:19:37.460
The rest of the method
here can also be analyzed,

00:19:37.460 --> 00:19:40.084
and we can learn something about
all these constructs in there.

00:19:40.084 --> 00:19:41.930
So we can actually get
a pretty full picture

00:19:41.930 --> 00:19:43.790
of what the types in here are.

00:19:43.790 --> 00:19:45.070
So I just listed them here.

00:19:45.070 --> 00:19:46.840
You don't have to look
at all the details,

00:19:46.840 --> 00:19:48.420
but this is very good
information for our compiler

00:19:48.420 --> 00:19:48.833
to have.

00:19:48.833 --> 00:19:50.220
SETH LADD: And it does this
without running a program,

00:19:50.220 --> 00:19:52.090
just statically
looking at the program.

00:19:52.090 --> 00:19:55.870
KASPER LUND: This is global
analysis at compile time.

00:19:55.870 --> 00:19:59.970
So let's make this
play to our advantage.

00:19:59.970 --> 00:20:01.860
So here's the code
again without type

00:20:01.860 --> 00:20:04.720
inferencing-- 526 characters.

00:20:04.720 --> 00:20:07.971
So first thing off, we know v
is either null or a variable.

00:20:07.971 --> 00:20:09.720
So we can do a little
bit better than just

00:20:09.720 --> 00:20:10.880
calling this getter on it.

00:20:10.880 --> 00:20:12.210
So we can actually
see that it always

00:20:12.210 --> 00:20:14.280
has a property determined
by, we just fetch it.

00:20:14.280 --> 00:20:15.664
Simple stuff.

00:20:15.664 --> 00:20:17.080
There are other
things that we can

00:20:17.080 --> 00:20:18.590
win even more by recognizing.

00:20:18.590 --> 00:20:21.340
For instance, v, the
variable dot constraints.

00:20:21.340 --> 00:20:23.340
Since v is a variable,
the constraints in there

00:20:23.340 --> 00:20:26.070
is always an array
of the constraints.

00:20:26.070 --> 00:20:29.340
So we don't have to go through
this calling a lengths getter

00:20:29.340 --> 00:20:30.730
and calling an index operator.

00:20:30.730 --> 00:20:33.220
We can just do the
real JavaScript way.

00:20:33.220 --> 00:20:35.650
Just fetch the length and
just index into the array.

00:20:35.650 --> 00:20:37.720
Simple stuff.

00:20:37.720 --> 00:20:40.700
Even better, we know that
v.constraints, that length

00:20:40.700 --> 00:20:42.260
is actually an integer.

00:20:42.260 --> 00:20:45.440
So this whole notion of checking
whether or not it's a number

00:20:45.440 --> 00:20:46.600
goes away.

00:20:46.600 --> 00:20:48.510
So that is a helpful thing.

00:20:48.510 --> 00:20:51.540
It's starting to improve.

00:20:51.540 --> 00:20:54.410
Now the condition that we have
in the loop is turning simpler.

00:20:54.410 --> 00:20:56.110
We can change the
y-limit to a for-loop.

00:20:56.110 --> 00:20:59.777
And at that point we're
already down to 33%

00:20:59.777 --> 00:21:01.610
smaller than the original
code I showed you.

00:21:01.610 --> 00:21:04.880
We have more to go, but
it's pretty simple stuff.

00:21:04.880 --> 00:21:05.700
coll is an array.

00:21:05.700 --> 00:21:08.390
So this calling add
on it, in a weird way,

00:21:08.390 --> 00:21:09.407
is not really necessary.

00:21:09.407 --> 00:21:10.990
So we can just use
the JavaScript push

00:21:10.990 --> 00:21:12.490
method to do that for you.

00:21:12.490 --> 00:21:13.790
Looks good.

00:21:13.790 --> 00:21:17.070
Even further, the t1 is
initialized in a simple way,

00:21:17.070 --> 00:21:18.900
so that can just move
into the for-loop.

00:21:18.900 --> 00:21:21.790
And we're down to 41% smaller
than the original JS output.

00:21:21.790 --> 00:21:24.030
We're starting to get there.

00:21:24.030 --> 00:21:25.860
c is known to be a
subclasses constraint,

00:21:25.860 --> 00:21:26.860
and it cannot be nulled.

00:21:26.860 --> 00:21:27.770
We've inferred that.

00:21:27.770 --> 00:21:30.228
So this whole notion of checking
whether or not c is nulled

00:21:30.228 --> 00:21:33.020
before doing a comparison-- this
is necessary because of null

00:21:33.020 --> 00:21:35.200
and undefined in
JavaScript by the way--

00:21:35.200 --> 00:21:37.710
we don't have to worry about
that because at least c cannot

00:21:37.710 --> 00:21:38.420
be null.

00:21:38.420 --> 00:21:40.400
So we can simplify the code.

00:21:40.400 --> 00:21:41.570
It's a good thing.

00:21:41.570 --> 00:21:45.230
Finally, we know that calling is
satisfied on c, actually always

00:21:45.230 --> 00:21:46.730
returns a boolean.

00:21:46.730 --> 00:21:49.234
And true is the only
truthy value in Dart,

00:21:49.234 --> 00:21:51.400
so usually we have to compare
against true before we

00:21:51.400 --> 00:21:52.290
branch on it.

00:21:52.290 --> 00:21:55.120
But because a boolean is
always either true or false,

00:21:55.120 --> 00:21:56.140
it's just fine.

00:21:56.140 --> 00:21:57.850
We can get rid of
that last thing.

00:21:57.850 --> 00:22:00.970
And there you have it--
an optimized version

00:22:00.970 --> 00:22:02.400
of this method that runs fast.

00:22:02.400 --> 00:22:05.370
It's much smaller, but it still
has exactly the same semantics.

00:22:05.370 --> 00:22:09.940
It's just we've proven we didn't
need some of these checks.

00:22:09.940 --> 00:22:11.440
So what's that do
to performance?

00:22:11.440 --> 00:22:13.760
Well, here's the graph
of that over time.

00:22:13.760 --> 00:22:16.650
So the top line is
the native Dart VM

00:22:16.650 --> 00:22:18.780
running the DeltaBlue algorithm.

00:22:18.780 --> 00:22:20.947
So you see that that's the
best performance we have.

00:22:20.947 --> 00:22:22.321
And it really
comes from the fact

00:22:22.321 --> 00:22:23.760
that Dart is
designed from the get

00:22:23.760 --> 00:22:25.194
go to be an efficient language.

00:22:25.194 --> 00:22:27.110
So we have a very good
implementation of that.

00:22:27.110 --> 00:22:29.651
The next two lines might be more
interesting in this context.

00:22:29.651 --> 00:22:31.835
The yellowish line
is actually V8

00:22:31.835 --> 00:22:34.210
running a handwritten version
of the DeltaBlue benchmark.

00:22:34.210 --> 00:22:36.530
This is the Octane version
of the DeltaBlue benchmark

00:22:36.530 --> 00:22:39.080
that you might have
seen in other places.

00:22:39.080 --> 00:22:41.570
As you can see, V8 improves
on that over time, slowly,

00:22:41.570 --> 00:22:44.740
and that's a very good
thing for the entire web.

00:22:44.740 --> 00:22:46.430
Maybe more interesting
to me, at least,

00:22:46.430 --> 00:22:47.919
is that the dart2js
generated code

00:22:47.919 --> 00:22:49.460
has improved a lot
on this benchmark.

00:22:49.460 --> 00:22:51.180
It's still the same
V8 that runs it,

00:22:51.180 --> 00:22:52.860
it's just that the
code we generate

00:22:52.860 --> 00:22:55.450
is actually a little bit faster
than the handwritten version.

00:22:55.450 --> 00:22:56.200
How could that be?

00:22:56.200 --> 00:22:58.050
Well basically,
we do optimization

00:22:58.050 --> 00:23:00.040
that you probably don't
want to do by hand.

00:23:00.040 --> 00:23:02.150
Because we know the entire
structure of the app,

00:23:02.150 --> 00:23:07.071
we can do some inlining for you,
and some code motion and things

00:23:07.071 --> 00:23:08.820
like that for your
loops that you probably

00:23:08.820 --> 00:23:10.140
don't care to do by hand.

00:23:10.140 --> 00:23:11.354
So it's a little bit faster.

00:23:11.354 --> 00:23:12.770
In general, what
we see is that we

00:23:12.770 --> 00:23:14.853
were very close to handwritten
dart2js performance

00:23:14.853 --> 00:23:16.492
on everything.

00:23:16.492 --> 00:23:17.950
There are cases
where we're faster.

00:23:17.950 --> 00:23:18.710
And unfortunately,
there are cases

00:23:18.710 --> 00:23:20.470
where we're a little bit slower.

00:23:20.470 --> 00:23:22.890
So anyway, the performance
looks really promising

00:23:22.890 --> 00:23:25.490
and it's nice to be able to
write in a very clean language

00:23:25.490 --> 00:23:26.850
and get good performance.

00:23:26.850 --> 00:23:29.850
So let's take a look
at how you actually

00:23:29.850 --> 00:23:32.600
go about using this Dart
thing in a real setting.

00:23:32.600 --> 00:23:34.330
SETH LADD: Yeah, thanks Kasper.

00:23:34.330 --> 00:23:35.366
So that's dart2js.

00:23:35.366 --> 00:23:36.740
A little bit about
the workflow--

00:23:36.740 --> 00:23:38.340
how and when do you apply that?

00:23:38.340 --> 00:23:40.050
Compiling JavaScript
of course is great,

00:23:40.050 --> 00:23:41.674
but I don't want to
do that every time.

00:23:41.674 --> 00:23:46.040
I want those quick iterations
that the web is known for.

00:23:46.040 --> 00:23:47.760
So what does it look like?

00:23:47.760 --> 00:23:49.227
Well, we have a
build of Chromium

00:23:49.227 --> 00:23:51.060
with the Dart virtual
machine embedded in it

00:23:51.060 --> 00:23:52.460
we've actually called Dartium.

00:23:52.460 --> 00:23:54.335
And that's where you
spend most of your time.

00:23:54.335 --> 00:23:56.200
Those are your quick
edit reload cycles.

00:23:56.200 --> 00:23:58.640
So let's look at
what that feels like.

00:23:58.640 --> 00:24:00.544
Here's a build of Dart Editor.

00:24:00.544 --> 00:24:01.960
You don't have to
use Dart Editor,

00:24:01.960 --> 00:24:03.376
but it does ship
with the project.

00:24:03.376 --> 00:24:05.120
It's a stripped down
version of Eclipse.

00:24:05.120 --> 00:24:06.360
In fact, I like to show this.

00:24:06.360 --> 00:24:07.920
I showed this screen to
somebody, and they're like,

00:24:07.920 --> 00:24:08.540
oh you have a bug?

00:24:08.540 --> 00:24:10.710
You're missing like 78
more preferences in there?

00:24:10.710 --> 00:24:13.510
Like, no, no actually,
we took those out.

00:24:13.510 --> 00:24:15.890
So it's optimized for
writing Dart code.

00:24:15.890 --> 00:24:17.500
Probably the best
way to get started

00:24:17.500 --> 00:24:19.000
is-- let's just
create a sample app.

00:24:19.000 --> 00:24:23.790
So luckily, Eric showed
us Polymer before.

00:24:23.790 --> 00:24:25.910
Dart has been porting
Polymer, polymer.dart.

00:24:25.910 --> 00:24:28.400
So we're totally in bed with
this web components things.

00:24:28.400 --> 00:24:30.130
We think it's the bee's knees.

00:24:30.130 --> 00:24:31.606
Here is a sample application.

00:24:31.606 --> 00:24:32.980
You get all the
skeleton for you.

00:24:32.980 --> 00:24:34.080
You've got the HTML.

00:24:34.080 --> 00:24:36.630
You've got the custom
elements, the CSS.

00:24:36.630 --> 00:24:38.810
So let's just run this
here to see what it's like.

00:24:38.810 --> 00:24:41.864
It's very simple here, but
we're going to run in Dartium.

00:24:41.864 --> 00:24:42.780
See, it pops right up.

00:24:42.780 --> 00:24:44.840
No compiles time needed.

00:24:44.840 --> 00:24:46.127
Click me, OK button.

00:24:46.127 --> 00:24:46.710
Click counter.

00:24:46.710 --> 00:24:47.220
OK, cool.

00:24:47.220 --> 00:24:49.560
So it gives you just the
core to get started with.

00:24:49.560 --> 00:24:53.486
Let's look a little bit at how
this application is written.

00:24:53.486 --> 00:24:54.610
Hopefully you can see this.

00:24:54.610 --> 00:24:57.667
So the polymer
element looks pretty

00:24:57.667 --> 00:24:59.500
much like what Eric was
showing you earlier.

00:24:59.500 --> 00:25:02.660
So the HTML aspects of building
highly declarative apps

00:25:02.660 --> 00:25:05.066
with Dart are very similar
to the JavaScript side.

00:25:05.066 --> 00:25:07.440
The difference though, instead
of implementing the custom

00:25:07.440 --> 00:25:09.735
element with JavaScript, you
can implement it with Dart.

00:25:09.735 --> 00:25:12.360
Dart has classes, so it makes a
ton of sense to be able to say,

00:25:12.360 --> 00:25:15.630
one class for one
custom element.

00:25:15.630 --> 00:25:16.400
So this is cool.

00:25:16.400 --> 00:25:17.920
And I'll show you a couple
other features, because Dart

00:25:17.920 --> 00:25:19.586
is structured, and
this editor gives you

00:25:19.586 --> 00:25:21.650
some nice productivity benefits.

00:25:21.650 --> 00:25:27.250
Let's say I want to add a reset
count, and then a method here.

00:25:27.250 --> 00:25:28.540
OK.

00:25:28.540 --> 00:25:29.220
Code completion.

00:25:29.220 --> 00:25:31.178
Because we can statically
analyze your program,

00:25:31.178 --> 00:25:33.190
we know what you
can call right here.

00:25:33.190 --> 00:25:34.209
And it's real time.

00:25:34.209 --> 00:25:35.250
So that's pretty awesome.

00:25:35.250 --> 00:25:38.020
Now I'll also go in and infer
the local stuff as well.

00:25:38.020 --> 00:25:39.440
OK, that's pretty cool.

00:25:39.440 --> 00:25:42.335
Now, the other neat thing about
statically analyzable language

00:25:42.335 --> 00:25:44.490
is it can understand
your program.

00:25:44.490 --> 00:25:46.810
So let's look at
this field count.

00:25:46.810 --> 00:25:49.310
Notice how it only highlights
the uses of that field.

00:25:49.310 --> 00:25:51.897
It's not doing a string
search and replace here.

00:25:51.897 --> 00:25:53.730
So it leaves out some
of the other accounts,

00:25:53.730 --> 00:25:55.521
even though obviously
it's the same string.

00:25:55.521 --> 00:25:57.490
So we can rename.

00:25:57.490 --> 00:25:59.300
We can say my account.

00:25:59.300 --> 00:26:01.769
And it only renames actual
usages of that field, again

00:26:01.769 --> 00:26:03.685
the power of a statically
analyzable language.

00:26:03.685 --> 00:26:06.930
I'm going to undo that
because I'm scared of bugs.

00:26:06.930 --> 00:26:08.730
OK, cool.

00:26:08.730 --> 00:26:10.120
Once you're in an
editor, and you

00:26:10.120 --> 00:26:12.650
have an actual virtual machine,
you can set breakpoints.

00:26:12.650 --> 00:26:14.030
So let's go back.

00:26:14.030 --> 00:26:15.190
We set a breakpoint there.

00:26:15.190 --> 00:26:16.600
We're going to re-run the app.

00:26:16.600 --> 00:26:19.420
And if I click the button, and
it all works-- yes, OK, great.

00:26:19.420 --> 00:26:21.920
So it jumps back to
the editor, and you're

00:26:21.920 --> 00:26:23.420
in the familiar
editing environment,

00:26:23.420 --> 00:26:25.430
with full breakpoints.

00:26:25.430 --> 00:26:26.400
You can inspect.

00:26:26.400 --> 00:26:27.290
This is really cool.

00:26:27.290 --> 00:26:28.510
I can jump in here.

00:26:28.510 --> 00:26:30.030
I want to inspect this instance.

00:26:30.030 --> 00:26:32.854
I don't know if you guys
can see this, actually.

00:26:32.854 --> 00:26:34.520
Trust me, that says
count and then five,

00:26:34.520 --> 00:26:36.850
so it's a live object inspector.

00:26:36.850 --> 00:26:39.400
So that's really cool.

00:26:39.400 --> 00:26:40.530
Let's move on.

00:26:40.530 --> 00:26:43.390
This app was kind of neat,
but it's also kind of boring.

00:26:43.390 --> 00:26:45.590
So I think we can do
a little bit better.

00:26:45.590 --> 00:26:48.470
In fact, that gray button,
I want to make fancier.

00:26:48.470 --> 00:26:51.700
So this is where a package
management system comes in.

00:26:51.700 --> 00:26:54.230
Our package management
system, Pub-- and let's

00:26:54.230 --> 00:27:00.417
see if we can go here--
has over 500 packages in it

00:27:00.417 --> 00:27:02.500
already from our open
source community, everything

00:27:02.500 --> 00:27:04.376
from server-side stuff
to client-side stuff,

00:27:04.376 --> 00:27:06.672
to game, crypto, you name it.

00:27:06.672 --> 00:27:09.120
Ah, here, look at
this-- fancy button.

00:27:09.120 --> 00:27:11.100
OK, so our Pub package
management system

00:27:11.100 --> 00:27:13.340
also has custom elements in it.

00:27:13.340 --> 00:27:16.004
So if you like web components,
you want to reuse them,

00:27:16.004 --> 00:27:18.170
package management system
is a great way to do that.

00:27:18.170 --> 00:27:20.960
So let's make our
button a little fancy.

00:27:20.960 --> 00:27:23.700
Let's load up the
pubspec.yaml file.

00:27:23.700 --> 00:27:27.280
This defines my application
and its dependencies.

00:27:27.280 --> 00:27:28.730
And certainly I
depend on polymer.

00:27:28.730 --> 00:27:32.400
Let's depend on fancy_button.

00:27:32.400 --> 00:27:33.010
OK, great.

00:27:33.010 --> 00:27:34.600
So now the editor
is kicking off pub.

00:27:34.600 --> 00:27:36.680
He's going to go download
it, and install it, and make

00:27:36.680 --> 00:27:37.690
sure it all works for my app.

00:27:37.690 --> 00:27:39.190
I'm a little
impatient, so I'm going

00:27:39.190 --> 00:27:41.860
to go over here and show
you what that looks like.

00:27:41.860 --> 00:27:45.280
We're going to go
into click-counter.

00:27:45.280 --> 00:27:48.140
And just like regular web
components and HTML imports,

00:27:48.140 --> 00:27:50.820
you can import the
definition of fancy button.

00:27:50.820 --> 00:27:54.150
You can say that this
button is a fancy button.

00:27:54.150 --> 00:27:56.050
Now this is all backed by Dart.

00:27:56.050 --> 00:27:58.080
It's a real web component,
and it came to us

00:27:58.080 --> 00:28:00.020
from that package
management system.

00:28:00.020 --> 00:28:02.300
Let's see if I indeed
made it a little fancier.

00:28:02.300 --> 00:28:04.050
So run in Dartium.

00:28:04.050 --> 00:28:05.460
And yes, awesome.

00:28:05.460 --> 00:28:06.180
OK.

00:28:06.180 --> 00:28:07.130
Pink, OK.

00:28:07.130 --> 00:28:09.126
So it's a nice
demonstration of how

00:28:09.126 --> 00:28:12.670
you can use a package management
system and reuse code.

00:28:12.670 --> 00:28:14.840
Finally, we need to get
this out into the wild.

00:28:14.840 --> 00:28:17.130
It's one thing to iterate
very quickly in Dartium,

00:28:17.130 --> 00:28:19.740
but it's another thing
to be able to-- find

00:28:19.740 --> 00:28:25.260
my original slides, boop,
OK-- do your final testing

00:28:25.260 --> 00:28:28.850
in production browsers like
Firefox and stable Chrome.

00:28:28.850 --> 00:28:30.790
And this is our pub
build system comes in.

00:28:30.790 --> 00:28:33.290
So iterate very fast with
Dartium and the editor,

00:28:33.290 --> 00:28:34.711
and then run a
nice build process.

00:28:34.711 --> 00:28:36.210
Now more and more
web developers are

00:28:36.210 --> 00:28:39.430
moving to a build process that
does really nice optimizations.

00:28:39.430 --> 00:28:41.012
For one, ours runs dart2js.

00:28:41.012 --> 00:28:42.595
You saw some of the
nice optimizations

00:28:42.595 --> 00:28:44.100
it can actually
do with your code.

00:28:44.100 --> 00:28:45.960
Tree shaking-- it
can minify your app.

00:28:45.960 --> 00:28:48.135
If it totally knows
your entire application,

00:28:48.135 --> 00:28:50.132
it can do a really smart
job at minification.

00:28:50.132 --> 00:28:51.340
It can also do concatenation.

00:28:51.340 --> 00:28:53.310
It can take all
your dependencies,

00:28:53.310 --> 00:28:55.820
all your custom elements,
and jam them all in together

00:28:55.820 --> 00:28:59.540
into one single file, making
the deployment and performance

00:28:59.540 --> 00:29:00.310
very, very good.

00:29:00.310 --> 00:29:01.949
In fact, in this
particular example,

00:29:01.949 --> 00:29:03.990
you saw we had a lot of
dependencies, third party

00:29:03.990 --> 00:29:06.210
stuff, custom libraries,
core libraries.

00:29:06.210 --> 00:29:07.790
This app compiles
them and gzips down

00:29:07.790 --> 00:29:10.000
to smaller than some CSS
frameworks you guys use.

00:29:10.000 --> 00:29:11.480
So I think it's kind of cool.

00:29:11.480 --> 00:29:14.020
And just to show you
that that all works,

00:29:14.020 --> 00:29:17.410
here we have it in Firefox.

00:29:17.410 --> 00:29:18.990
This is Dart, compiled
to JavaScript,

00:29:18.990 --> 00:29:22.470
using web components deployable
to a production browser today.

00:29:22.470 --> 00:29:24.160
This stuff is real
and you can use it.

00:29:27.141 --> 00:29:28.890
And then, when you're
finally ready to go,

00:29:28.890 --> 00:29:30.700
you have a nice build
directory, which

00:29:30.700 --> 00:29:33.510
has just the assets, just
those minified files,

00:29:33.510 --> 00:29:36.200
in a very nice directory you can
pick up and put onto the web.

00:29:36.200 --> 00:29:39.362
All that concatenation, all
the minification, done for you.

00:29:39.362 --> 00:29:40.570
KASPER LUND: Nice and simple.

00:29:40.570 --> 00:29:41.694
SETH LADD: Nice and simple.

00:29:41.694 --> 00:29:43.030
So, how do you get started?

00:29:43.030 --> 00:29:45.290
Well, we relaunched the website,
and we have a really nice code

00:29:45.290 --> 00:29:45.790
lab.

00:29:45.790 --> 00:29:48.400
It takes under an hour,
walks you through zero to 60.

00:29:48.400 --> 00:29:51.220
You get to build a really cool
pirate name badge generator.

00:29:51.220 --> 00:29:52.770
A really nice way
to try Dart, built

00:29:52.770 --> 00:29:54.855
for if you don't know
anything about Dart.

00:29:54.855 --> 00:29:56.480
And I want to leave
you with a reminder

00:29:56.480 --> 00:29:59.460
that Dart 1.0 is
for the modern web.

00:29:59.460 --> 00:30:02.430
It's a platform
you can use today.

00:30:02.430 --> 00:30:03.500
It's easy to get started.

00:30:03.500 --> 00:30:04.291
Go to dartlang.org.

00:30:04.291 --> 00:30:07.840
We have APIs, code labs,
articles, tutorials.

00:30:07.840 --> 00:30:10.730
And everything you saw here,
even the web component stuff,

00:30:10.730 --> 00:30:12.259
all compiles to JavaScript.

00:30:12.259 --> 00:30:13.800
So you can write
Dart, take advantage

00:30:13.800 --> 00:30:15.720
of those great semantics,
language, and tools,

00:30:15.720 --> 00:30:18.430
and still deploy
across the modern web.

00:30:18.430 --> 00:30:23.607
So I think with that-- I
think we're all ready to go.

00:30:23.607 --> 00:30:24.440
Thank you very much.

00:30:24.440 --> 00:30:25.990
Appreciate it.

