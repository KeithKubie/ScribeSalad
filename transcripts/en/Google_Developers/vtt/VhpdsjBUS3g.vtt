WEBVTT
Kind: captions
Language: en

00:00:02.659 --> 00:00:03.679
&gt;&gt;John McCutchan: Hello, everyone.

00:00:03.679 --> 00:00:04.679
I'm John McCutchan.

00:00:04.679 --> 00:00:10.700
I'm part of the Chrome DevRel team and my
focus is on making the web fast, and that's

00:00:10.700 --> 00:00:17.090
what I'm hoping to teach you today: How to
make your page very fast with V8.

00:00:17.090 --> 00:00:21.199
So this talk's going to get into some pretty
low-level details about how V8 works and how

00:00:21.199 --> 00:00:25.029
you can surface some signals, so hopefully
that's really exciting to you because it's

00:00:25.029 --> 00:00:28.570
exciting to me.

00:00:28.570 --> 00:00:31.560
So today I want to talk about Oz.

00:00:31.560 --> 00:00:35.560
Specifically, Find Your Way to Oz, the Chrome
experiment that came out in February.

00:00:35.560 --> 00:00:39.200
Let's just take a look at a video of what
the experience is like.

00:00:39.200 --> 00:00:44.140
This is all running inside the browser and
it's a game.

00:00:44.140 --> 00:00:48.970
There's about four games and it's all themed
around the new Wizard of Oz movie.

00:00:48.970 --> 00:00:52.829
So the first one is like the carnival cutout.

00:00:52.829 --> 00:00:59.960
You put your face into this -- this wooden
painting and it's using a webcam.

00:00:59.960 --> 00:01:05.880
Let me just kill the ad.

00:01:05.880 --> 00:01:11.910
So the next one is a music box, and you can
actually kind of compose your own theme that,

00:01:11.910 --> 00:01:14.190
you know, kind of fits with the Wizard of
Oz theme.

00:01:14.190 --> 00:01:18.030
And then when you -- after you're finished,
when you're walking around throughout the

00:01:18.030 --> 00:01:22.330
Wizard of Oz, the park, it will be playing
the song that you've made, and this is using

00:01:22.330 --> 00:01:31.690
Web Audio.

00:01:31.690 --> 00:01:37.830
So the next attraction at the circus is make
your own zoetrope, and for those of you who

00:01:37.830 --> 00:01:42.710
are too young to know what a zoetrope is,
including myself, it kind of predated animation

00:01:42.710 --> 00:01:47.060
in film and, you know, you kind of -- this
thing spun around in a circle and showed you

00:01:47.060 --> 00:01:50.500
a very simplistic animation like this.

00:01:50.500 --> 00:01:55.350
And again, this is using the webcam and capturing
video from your computer and then putting

00:01:55.350 --> 00:01:57.880
you into the game world.

00:01:57.880 --> 00:01:59.950
The final attraction is really impressive.

00:01:59.950 --> 00:02:06.060
It's a hot air balloon ride where you have
to navigate this big tornado and, you know,

00:02:06.060 --> 00:02:13.561
kind of escape -- Find Your Way 
to Oz.

00:02:13.561 --> 00:02:14.561
So really impressive graphics.

00:02:14.561 --> 00:02:15.820
I mean, this looks great.

00:02:15.820 --> 00:02:21.430
There's a really in-depth article on how they
actually accomplished this effect, and it's

00:02:21.430 --> 00:02:22.430
very interesting.

00:02:22.430 --> 00:02:27.060
It kind of incorporated a lot of things from
how they do effects in film where they have

00:02:27.060 --> 00:02:30.650
like a mat painting and they're kind of composing
all of these different layers together, but

00:02:30.650 --> 00:02:35.670
it's all running with WebGL.

00:02:35.670 --> 00:02:37.731
So this is Find Your Way to Oz.

00:02:37.731 --> 00:02:38.731
It's really exciting.

00:02:38.731 --> 00:02:40.250
I recommend that you check it out.

00:02:40.250 --> 00:02:43.810
Like I said, it's been using -- it's using
all of the latest HTML5 features.

00:02:43.810 --> 00:02:45.420
It's using WebGL.

00:02:45.420 --> 00:02:50.850
It was developed by unit9 and this was a partnership
between Disney and Google, and unit9 did a

00:02:50.850 --> 00:02:51.850
great job.

00:02:51.850 --> 00:02:52.850
It won a few awards.

00:02:52.850 --> 00:02:55.240
It's a really exciting project.

00:02:55.240 --> 00:03:01.690
But late in development, there was a really
serious performance problem and it wasn't

00:03:01.690 --> 00:03:03.220
a trivial problem.

00:03:03.220 --> 00:03:06.400
We were seeing something that -- you know,
we're looking at memory usage and seeing the

00:03:06.400 --> 00:03:10.330
graph along the bottom here where we're just
seeing like this sawtooth-like shape where

00:03:10.330 --> 00:03:14.569
it just keeps using more memory and the garbage
collection kicks in and cleans it up and no

00:03:14.569 --> 00:03:17.240
one could really figure this out.

00:03:17.240 --> 00:03:18.240
This was late.

00:03:18.240 --> 00:03:19.240
This was not good.

00:03:19.240 --> 00:03:20.580
The product needed to ship.

00:03:20.580 --> 00:03:24.620
Delays were a possibility and we really had
to make sure that this -- this didn't get

00:03:24.620 --> 00:03:26.710
out of hand.

00:03:26.710 --> 00:03:31.470
So lucky for unit9, they were able to call
in some performance detectives and this is

00:03:31.470 --> 00:03:37.870
Yacov and Yung from the V8 team and they were
actually able to help kind of hold unit9's

00:03:37.870 --> 00:03:41.010
hand and figure out what was going on inside
of their game.

00:03:41.010 --> 00:03:46.500
So I hope that you in the audience, after
going through this talk, will be able to do

00:03:46.500 --> 00:03:50.330
the same things that unit9 did that the V8
team taught them.

00:03:50.330 --> 00:03:56.190
So hopefully you all will become performance
detectives by the end.

00:03:56.190 --> 00:04:00.319
So before we go into what the problem was
and how we resolved it, let's spend a few

00:04:00.319 --> 00:04:05.810
minutes talking about why performance matters.

00:04:05.810 --> 00:04:10.220
So if we look at a typical frame in a browser,
the first thing that happens is you have to

00:04:10.220 --> 00:04:11.220
handle input.

00:04:11.220 --> 00:04:14.520
The users click something or they press a
button.

00:04:14.520 --> 00:04:17.410
After handling input, scripts start executing.

00:04:17.410 --> 00:04:23.030
All the -- the state of the page gets updated,
and actually this often triggers a layout

00:04:23.030 --> 00:04:28.570
change, and so the browser has to re-lay out
all the elements inside the page, and then

00:04:28.570 --> 00:04:30.600
after this, it's got to paint all of the elements.

00:04:30.600 --> 00:04:32.120
They're changed the contents.

00:04:32.120 --> 00:04:34.000
What's inside of there has changed.

00:04:34.000 --> 00:04:35.160
This is a lot of work.

00:04:35.160 --> 00:04:39.510
And then finally, it all gets composited onto
the screen.

00:04:39.510 --> 00:04:45.090
This just loops and you actually have to do
this 60 times a second and you have 16 milliseconds

00:04:45.090 --> 00:04:46.740
to accomplish all of this.

00:04:46.740 --> 00:04:52.440
If you don't, you're going to drop a frame
and you're going to get jank.

00:04:52.440 --> 00:04:58.320
So "jank" is the slang term for like kind
of a -- an unpleasant, unsmooth site experience.

00:04:58.320 --> 00:05:03.260
When you're scrolling on a page and it kind
of clips and it jumps, it doesn't feel smooth,

00:05:03.260 --> 00:05:04.260
that's jank.

00:05:04.260 --> 00:05:07.371
When you're playing an online game and it
drops a frame or some -- you know, something

00:05:07.371 --> 00:05:10.199
kind of weird happens, it pauses for a second,
that's jank.

00:05:10.199 --> 00:05:16.030
And so if you miss -- I mean, if you cannot
get all -- through all the steps in 16 milliseconds,

00:05:16.030 --> 00:05:21.010
you're going to have a janky page and users
don't really like that.

00:05:21.010 --> 00:05:22.850
So where does all this performance go?

00:05:22.850 --> 00:05:26.690
Where does that 16 milliseconds -- where does
it go?

00:05:26.690 --> 00:05:32.540
So if we look at this graph here, it's kind
of difficult to parse, but each column represents

00:05:32.540 --> 00:05:38.370
a very mainstream site on the web, like Google
Docs or Gmail or Wikipedia or something like

00:05:38.370 --> 00:05:39.370
that.

00:05:39.370 --> 00:05:44.610
And what we really care about for this talk
is the red candy-striped section along the

00:05:44.610 --> 00:05:45.610
bottom.

00:05:45.610 --> 00:05:49.620
This is actually the time that your page is
spending inside V8.

00:05:49.620 --> 00:05:57.990
And what we see is that, you know, for Google
Apps, when the page isn't idle, we're actually

00:05:57.990 --> 00:06:02.330
spending between 50 to 70% of the time inside
idle.

00:06:02.330 --> 00:06:06.700
And for other popular sites, it's in the range
of 20 to 40%.

00:06:06.700 --> 00:06:17.720
So of that 16 milliseconds, a Google app is
spending 50% of it, at least, executing scripts.

00:06:17.720 --> 00:06:20.840
So performance matters because you want your
site to grow.

00:06:20.840 --> 00:06:24.610
You want to attract more users, and users
care about the performance of the site.

00:06:24.610 --> 00:06:27.850
In particular, it's been highlighted, you
know, in recent times with battery life.

00:06:27.850 --> 00:06:31.620
If you go to a page that performs poorly,
the -- you know, the battery in your mobile

00:06:31.620 --> 00:06:35.570
device is going to drain quicker and people
are going to stop coming back because it's

00:06:35.570 --> 00:06:38.510
just not the greatest experience.

00:06:38.510 --> 00:06:41.270
Users also want smoother applications.

00:06:41.270 --> 00:06:43.570
They want that, like, smooth experience when
they scroll.

00:06:43.570 --> 00:06:48.470
They want their game to run flawlessly and
never have a hiccup on any frame.

00:06:48.470 --> 00:06:49.470
And they want more features.

00:06:49.470 --> 00:06:53.530
All of these things -- it's actually kind
of difficult to satisfy these requests, because

00:06:53.530 --> 00:06:56.150
they're all sort of competing with each other.

00:06:56.150 --> 00:06:58.970
But you as the developer, you have to satisfy
all of these requests.

00:06:58.970 --> 00:07:03.070
It's -- you want to maximize battery life,
you want the smoothest application, and you

00:07:03.070 --> 00:07:04.560
want the most featureful application.

00:07:04.560 --> 00:07:08.100
And without that, you're not going to see
a really strong growth in the traffic to your

00:07:08.100 --> 00:07:11.100
site.

00:07:11.100 --> 00:07:15.169
So let's get back to the mystery and dig in
a little bit.

00:07:15.169 --> 00:07:19.240
So solving a performance problem is actually
a lot like solving a crime.

00:07:19.240 --> 00:07:22.110
The first thing you have to do is you have
to dig in and get -- collect some evidence

00:07:22.110 --> 00:07:25.070
and really figure out what's happening.

00:07:25.070 --> 00:07:29.730
And then from the evidence, you're going to
find some suspects, and you're going to kind

00:07:29.730 --> 00:07:33.770
of interrogate the suspects and figure out
like which one of them is likely responsible

00:07:33.770 --> 00:07:35.259
for your performance problem.

00:07:35.259 --> 00:07:39.240
And then finally, you're going to go into
the forensics lab and really prove that they're

00:07:39.240 --> 00:07:43.150
responsible and dig up some information that
will hopefully let you solve the crime and

00:07:43.150 --> 00:07:45.230
fix the performance problem.

00:07:45.230 --> 00:07:55.200
So let's get started on the -- the mystery
that the unit9 team faced with Oz.

00:07:55.200 --> 00:07:57.199
So evidence collection.

00:07:57.199 --> 00:08:01.039
You want to start off asking some pretty fundamental
questions about the site that you're looking

00:08:01.039 --> 00:08:02.039
at.

00:08:02.039 --> 00:08:05.509
If it's your site, then you can probably very
quickly zoom through this, but if you're helping

00:08:05.509 --> 00:08:10.300
someone else, then you really -- it might
seem silly to start at such a basic question,

00:08:10.300 --> 00:08:12.690
but it's important to contextualize what you're
doing.

00:08:12.690 --> 00:08:16.259
So the -- Oz is a real-time interactive 3D
game.

00:08:16.259 --> 00:08:17.930
It's taking advantage of WebGL.

00:08:17.930 --> 00:08:19.220
It has to run smooth.

00:08:19.220 --> 00:08:26.860
It has to fit that 16-millisecond time slice
or else it's going to perform badly.

00:08:26.860 --> 00:08:31.130
So the next question you want to ask yourself,
are the developers following the best practices?

00:08:31.130 --> 00:08:36.640
If they're not, then the likely solution to
the performance problem is probably something

00:08:36.640 --> 00:08:37.719
really simple.

00:08:37.719 --> 00:08:41.329
They probably just aren't aware of the best
practices and are making some silly error

00:08:41.329 --> 00:08:42.770
and it's great.

00:08:42.770 --> 00:08:46.100
You can fix it in no time.

00:08:46.100 --> 00:08:50.280
But unit9 are really good developers and they
were following the best practices and they

00:08:50.280 --> 00:08:53.910
were well-read and they were up-to-date on
all of the things that you have to do to make

00:08:53.910 --> 00:08:58.819
a really smooth and, you know, impressive
3D game in the browser.

00:08:58.819 --> 00:09:01.589
So it wasn't something simple.

00:09:01.589 --> 00:09:08.649
I mean, why would I be here talking about
if it was such a trivial problem?

00:09:08.649 --> 00:09:11.720
So specifically what kind of performance problem
are you seeing?

00:09:11.720 --> 00:09:16.510
And when you're at this stage in your investigation,
you want to really kind of nail it down because

00:09:16.510 --> 00:09:19.069
this is going to lead you to suspects.

00:09:19.069 --> 00:09:25.309
And specifically, they were seeing once per
second the frame rate dropped significantly.

00:09:25.309 --> 00:09:30.389
And to add a little bit of extra information
to it, it was actually correlated with GC

00:09:30.389 --> 00:09:31.389
activity.

00:09:31.389 --> 00:09:34.490
So right when the frame rate dropped, they
actually saw that the -- there was a lot of

00:09:34.490 --> 00:09:35.509
GC activity.

00:09:35.509 --> 00:09:36.509
Garbage collector was running.

00:09:36.509 --> 00:09:41.130
So that gives you a bit of a clue as to maybe
where should you start your investigation.

00:09:41.130 --> 00:09:46.360
We're seeing a frame rate drop with GC activity.

00:09:46.360 --> 00:09:48.860
And in particular, the GC activity was massive.

00:09:48.860 --> 00:09:49.860
Once per second.

00:09:49.860 --> 00:09:52.449
10 megabytes of garbage was being collected.

00:09:52.449 --> 00:09:56.279
And so you want to ask yourself, "Is 10 megabytes
per second of garbage expected?"

00:09:56.279 --> 00:10:01.249
Because in some applications, this might be
-- that might be a reasonable amount of garbage.

00:10:01.249 --> 00:10:04.170
In this case, it's not.

00:10:04.170 --> 00:10:07.420
They should be generating almost no garbage
per second.

00:10:07.420 --> 00:10:10.059
And that was what the developers' expectations
were.

00:10:10.059 --> 00:10:15.709
So something really strange was happening
and we really needed to figure it out.

00:10:15.709 --> 00:10:21.850
So to help us come up with suspects, we need
to understand what triggers a garbage collection,

00:10:21.850 --> 00:10:25.850
because if we're seeing a correlation with
a performance drop with garbage collection,

00:10:25.850 --> 00:10:35.550
we have to understand why garbage collection
happens.

00:10:35.550 --> 00:10:41.689
So let's walk through V8 memory management
in a bit more detail and walk through a GC

00:10:41.689 --> 00:10:42.689
pause.

00:10:42.689 --> 00:10:47.829
So to help understand the performance characteristics
of a GC pause, we have to understand where

00:10:47.829 --> 00:10:52.910
the cost in allocated memory comes from, and
it's not in allocating the memory itself.

00:10:52.910 --> 00:10:54.389
That's actually really cheap.

00:10:54.389 --> 00:10:57.750
It's incredibly fast to allocate memory in
V8.

00:10:57.750 --> 00:11:02.800
The performance problem -- the cost of allocating
memory actually comes after a while you've

00:11:02.800 --> 00:11:06.550
allocated enough objects and you've actually
exhausted the memory pool.

00:11:06.550 --> 00:11:11.209
So at that point the V8 runtime is forced
to run a garbage collection and this can take

00:11:11.209 --> 00:11:12.209
milliseconds.

00:11:12.209 --> 00:11:16.019
And if we remember, like you have 16 milliseconds
to get through the entire frame.

00:11:16.019 --> 00:11:19.499
You spend 5 of it doing a GC, you've lost
your frame.

00:11:19.499 --> 00:11:24.019
You cannot recover from that.

00:11:24.019 --> 00:11:26.660
So V8 manages memory in a generational split.

00:11:26.660 --> 00:11:30.470
So values are split between young and old
and their age is actually kind of estimated

00:11:30.470 --> 00:11:33.699
based on the number of garbage collections
in which they survive.

00:11:33.699 --> 00:11:38.449
So as an object lives through collections,
it gets older.

00:11:38.449 --> 00:11:45.500
And over time, the older values are promoted
from the young generation to the old generation.

00:11:45.500 --> 00:11:51.379
So the young generation offers really fast
allocation, which I've already stated.

00:11:51.379 --> 00:11:56.160
Collection is fast in relation to the cost
of an old generation collection.

00:11:56.160 --> 00:11:57.989
And it's frequently collected.

00:11:57.989 --> 00:12:03.870
When you're using the Chrome DevTools Timeline
panel and you see a GC event, as you can see

00:12:03.870 --> 00:12:08.360
on the slide here that's the young generation
being collected.

00:12:08.360 --> 00:12:15.009
In contrast, the old generation offers fast
allocation, but relative to young generation,

00:12:15.009 --> 00:12:16.209
the collection is slower.

00:12:16.209 --> 00:12:19.680
Luckily, though, it happens infrequently.

00:12:19.680 --> 00:12:23.139
And part of that collection actually runs
concurrently with the mutator, which is your

00:12:23.139 --> 00:12:24.399
JavaScript thread.

00:12:24.399 --> 00:12:28.589
It does some incremental marking and there's
a few different types of collections that

00:12:28.589 --> 00:12:32.829
can occur in the old generation, but typically
when you've -- when you see a frame drop in

00:12:32.829 --> 00:12:38.079
your game or, you know, you see weird scrolling
behavior and it's a GC problem, it's the young

00:12:38.079 --> 00:12:39.079
generation.

00:12:39.079 --> 00:12:42.889
So let's really focus on that.

00:12:42.889 --> 00:12:46.449
So why is collecting the young generation
so much faster?

00:12:46.449 --> 00:12:50.079
Well, to help you understand that, you have
to -- you have to kind of intuitively understand

00:12:50.079 --> 00:12:54.619
the cost of a GC is proportional to the number
of live objects.

00:12:54.619 --> 00:12:59.670
So the number of objects which survive the
GC is how you can estimate how long this GC's

00:12:59.670 --> 00:13:00.910
going to take.

00:13:00.910 --> 00:13:06.549
So because we split the objects into two generations,
the young and the old, the young kind of,

00:13:06.549 --> 00:13:09.029
by definition, has a very high death rate.

00:13:09.029 --> 00:13:14.170
Very few objects survive many young generation
collections.

00:13:14.170 --> 00:13:18.630
You know, in contrast, old generation by the
very nature of what's in the old generation,

00:13:18.630 --> 00:13:23.339
these objects have lived for a long time so
you can't expect that, hey, let's do an old

00:13:23.339 --> 00:13:25.759
generation collection, they're probably all
now garbage.

00:13:25.759 --> 00:13:29.690
That doesn't make a lot of sense because they've
historically lived for a long time inside

00:13:29.690 --> 00:13:33.369
your program.

00:13:33.369 --> 00:13:36.420
So let's look at how the young generation
actually operates.

00:13:36.420 --> 00:13:40.869
So the young generation is split into two
semi-spaces equally sized, the to space and

00:13:40.869 --> 00:13:43.420
the from space.

00:13:43.420 --> 00:13:48.019
Values are allocated from the to space, so
when your JavaScript executes a new statement,

00:13:48.019 --> 00:13:50.989
new foo, it pulls some memory from the to
space.

00:13:50.989 --> 00:13:56.059
The from space is used during GC and we'll
get to that shortly.

00:13:56.059 --> 00:14:01.369
So assuming that we started with an empty
to space, it's all full of unallocated memory,

00:14:01.369 --> 00:14:06.670
page allocates Object A and then Object B,
and then C, and D. Everything up until this

00:14:06.670 --> 00:14:07.670
point is great.

00:14:07.670 --> 00:14:09.189
Things are really humming along.

00:14:09.189 --> 00:14:13.769
But unfortunately the page then tries to allocate
Object E. Now, at this point we've actually

00:14:13.769 --> 00:14:19.910
exhausted the amount of memory in the young
generation and we cannot do this.

00:14:19.910 --> 00:14:22.000
So things back up a little bit.

00:14:22.000 --> 00:14:24.730
Object E wasn't allocated because there just
wasn't room for it.

00:14:24.730 --> 00:14:26.360
The page is paused.

00:14:26.360 --> 00:14:27.360
Everything stops.

00:14:27.360 --> 00:14:31.859
The rendering stops like exactly at that line
of code where you called new.

00:14:31.859 --> 00:14:33.070
Everything pauses.

00:14:33.070 --> 00:14:35.149
A collection gets triggered.

00:14:35.149 --> 00:14:38.589
So the first thing in a collection is that
the from and the to space, they're just swapped.

00:14:38.589 --> 00:14:40.059
The labels are swapped.

00:14:40.059 --> 00:14:44.769
The old from space, which is empty, becomes
the new to space.

00:14:44.769 --> 00:14:50.339
The next stage is that all the live values
inside the young generation are discovered.

00:14:50.339 --> 00:14:55.329
These are marked and the next step is to copy
them.

00:14:55.329 --> 00:14:57.410
And this is where a lot of the time is actually
spent.

00:14:57.410 --> 00:14:58.410
It's in this copy.

00:14:58.410 --> 00:15:01.699
And this is what -- when I said earlier that
the cost of the GC is proportional to the

00:15:01.699 --> 00:15:06.160
number of objects which survive, you have
to copy these objects across from one space

00:15:06.160 --> 00:15:09.790
to the other, and this is where a lot of that
time goes.

00:15:09.790 --> 00:15:15.629
So in this example, A and C survived and we've
copied them to the new to space and here we

00:15:15.629 --> 00:15:16.629
go.

00:15:16.629 --> 00:15:26.920
The page can resume and allocate Object E.
So what you intuitively have to understand

00:15:26.920 --> 00:15:30.850
is that each allocation moves you closer to
this pause.

00:15:30.850 --> 00:15:36.399
So if you're dealing with a -- you know, something
where timing really matters, you almost want

00:15:36.399 --> 00:15:39.899
to operate under the assumption that you cannot
allocate memory.

00:15:39.899 --> 00:15:43.019
You want to kind of preallocate everything
ahead of time.

00:15:43.019 --> 00:15:47.669
Because the collection completely pauses your
application, and this brings higher latency,

00:15:47.669 --> 00:15:52.359
so just imagine that a user clicks a button
and then right then inside your click handler

00:15:52.359 --> 00:15:53.980
you allocate some new object.

00:15:53.980 --> 00:15:57.169
Boom, you've hit the GC pause and like these
are actually fields.

00:15:57.169 --> 00:16:01.389
Like "Hey, I clicked," and there's just this
moment where nothing is happening and it offers

00:16:01.389 --> 00:16:02.949
a bad user experience.

00:16:02.949 --> 00:16:04.449
In games, you get dropped frames.

00:16:04.449 --> 00:16:17.319
You know, ultimately this just leads to unhappy
users who may not come back to your site.

00:16:17.319 --> 00:16:22.019
So now that we understand what happens in
a GC pause and how you get to a GC pause,

00:16:22.019 --> 00:16:24.589
it's time to start looking at some suspects.

00:16:24.589 --> 00:16:33.160
And we've got these sneaky guys right here
-- blue, red, and green -- who are incognito.

00:16:33.160 --> 00:16:36.970
So the first suspect is pretty -- you know,
this should really jump to your mind at this

00:16:36.970 --> 00:16:39.350
point -- is just calling new.

00:16:39.350 --> 00:16:43.579
Maybe Oz is calling new all the time and they're
just like allocating all of these objects

00:16:43.579 --> 00:16:48.050
throughout the frame and then, like, they're
triggering the GC pause and they haven't retained

00:16:48.050 --> 00:16:51.209
references to any of these objects, so they're
all just garbage and it gets collected and

00:16:51.209 --> 00:16:54.139
that's where that 10 megs come from.

00:16:54.139 --> 00:16:58.249
So a careful audit of the code base confirmed
that there was no calls to new within the

00:16:58.249 --> 00:16:59.249
frame.

00:16:59.249 --> 00:17:01.889
And actually unit9 said that would have been
really embarrassing, and this goes back to

00:17:01.889 --> 00:17:04.360
them being -- they're following the best practices.

00:17:04.360 --> 00:17:11.150
They're well aware of what they should and
shouldn't be doing inside their game.

00:17:11.150 --> 00:17:15.230
So suspect Number 2 is code running in unoptimized
mode.

00:17:15.230 --> 00:17:18.060
And let's talk about why this is a suspect.

00:17:18.060 --> 00:17:22.180
If we look at JavaScript on the slide, we
can see that there is some computation and

00:17:22.180 --> 00:17:28.920
they calculate A and B and C and then they
do some multiplication and update the X position

00:17:28.920 --> 00:17:34.460
of some sprite in the game.

00:17:34.460 --> 00:17:38.400
So in unoptimized mode, there is actually
a lot of implicit memory allocations.

00:17:38.400 --> 00:17:43.210
Why we don't see any calls to new on the slide,
there is actually behind the scenes many calls

00:17:43.210 --> 00:17:45.950
to new or their equivalent.

00:17:45.950 --> 00:17:51.840
So, when we calculate P times D, a new object
is allocated.

00:17:51.840 --> 00:17:57.520
Similarly, for C plus 3 and 3.3 times dt,
new objects are being allocated at each one

00:17:57.520 --> 00:17:58.520
of these points.

00:17:58.520 --> 00:18:01.960
It is not clear to you as a developer when
you are looking at the code, but this is actually

00:18:01.960 --> 00:18:03.870
what's happening behind the scenes.

00:18:03.870 --> 00:18:09.110
And then even when we calculate A times B,
it is not assigned anywhere; but, still, memory

00:18:09.110 --> 00:18:11.270
is reserved for the result.

00:18:11.270 --> 00:18:18.750
And then the result there is multiplied with
C. More memory is allocated.

00:18:18.750 --> 00:18:23.510
In contrast, if this function was running
in optimized mode, there would actually only

00:18:23.510 --> 00:18:27.820
be a single memory allocation and that's what
the final result is assigned to the field

00:18:27.820 --> 00:18:29.420
inside the object.

00:18:29.420 --> 00:18:33.500
You can see that there is a huge difference
between the amount of memory that is churned

00:18:33.500 --> 00:18:39.080
through in unoptimized mode compared to optimized
mode.

00:18:39.080 --> 00:18:46.290
And actually V8 recently optimized for this
case so only the first time that X is updated

00:18:46.290 --> 00:18:49.400
will memory be allocated.

00:18:49.400 --> 00:18:54.420
So it has got even better.

00:18:54.420 --> 00:18:58.920
So let's walk through, like, how you transition
between unoptimized mode and optimized mode

00:18:58.920 --> 00:19:03.220
and exactly kind of what's the state machine
under the hood.

00:19:03.220 --> 00:19:06.880
So all code starts off unoptimized.

00:19:06.880 --> 00:19:08.950
The first time your function runs, it is always
going to be unoptimized.

00:19:08.950 --> 00:19:10.350
That's fine.

00:19:10.350 --> 00:19:15.370
After a little while though, V8 will say,
Hey, this function is actually pretty hot,

00:19:15.370 --> 00:19:17.780
meaning it is executing a lot.

00:19:17.780 --> 00:19:20.100
And it is going to attempt to optimize that
function.

00:19:20.100 --> 00:19:24.060
So it is going to transition from the unoptimized
state to the optimized state.

00:19:24.060 --> 00:19:29.510
But as is kind of natural in JavaScript, there
is occasionally some deoptimization events.

00:19:29.510 --> 00:19:35.380
Some assumption that was baked into the optimization
has been violated so then the function gets

00:19:35.380 --> 00:19:38.730
kicked back over to the unoptimized state.

00:19:38.730 --> 00:19:39.730
This is actually okay.

00:19:39.730 --> 00:19:45.260
This kind of naturally happens throughout
JavaScript's execution lifetime.

00:19:45.260 --> 00:19:47.220
And then, again, after a little while, V8
says, You know what?

00:19:47.220 --> 00:19:49.000
I have got some better information with this
function.

00:19:49.000 --> 00:19:50.000
It is still pretty hot.

00:19:50.000 --> 00:19:54.160
Let me try to optimize it in a better way
so we can handle both of the cases that we've

00:19:54.160 --> 00:19:56.530
seen so far.

00:19:56.530 --> 00:20:02.660
Unfortunately, what happens is that after
too many de-optimizations, your function actually

00:20:02.660 --> 00:20:06.250
just gets sent down to unoptimized hell and
you never get to escape.

00:20:06.250 --> 00:20:10.030
Like, once you are in this place, that's it,
you are always going to run in unoptimized

00:20:10.030 --> 00:20:11.730
mode.

00:20:11.730 --> 00:20:15.160
There are also other ways to get into unoptimized
hell.

00:20:15.160 --> 00:20:17.240
You can use certain code constructs.

00:20:17.240 --> 00:20:20.060
We will see an example in a little bit.

00:20:20.060 --> 00:20:24.230
But if your function has a try catch block
in it, V8 today just doesn't optimize for

00:20:24.230 --> 00:20:25.730
that.

00:20:25.730 --> 00:20:30.820
So right away as soon as the function is seen
by V8, it just gets slotted into, you know,

00:20:30.820 --> 00:20:34.500
permanently unoptimized state and it is just
going to sit there.

00:20:34.500 --> 00:20:38.420
These constructs could be optimized for, but
it just hasn't been a priority up to this

00:20:38.420 --> 00:20:41.790
point.

00:20:41.790 --> 00:20:43.990
So we've definitely got a potential suspect
here.

00:20:43.990 --> 00:20:48.940
It's possible that some code inside Oz is
running in unoptimized mode.

00:20:48.940 --> 00:20:53.390
And, you know, there actually is no way to
surface this using Chrome DevTools.

00:20:53.390 --> 00:20:58.360
You can't figure out just looking inside the
dev panel, Hey, this function is unoptimized.

00:20:58.360 --> 00:20:59.360
Let's fix it.

00:20:59.360 --> 00:21:01.030
So we have a potential suspect.

00:21:01.030 --> 00:21:06.580
So the third suspect is a common JavaScript
performance strap and that's actually modifying

00:21:06.580 --> 00:21:08.390
object shape.

00:21:08.390 --> 00:21:13.030
So if we -- V8 behind the scenes creates these
hidden classes for objects.

00:21:13.030 --> 00:21:17.310
So the point constructor assigns the X field
and then the Y field.

00:21:17.310 --> 00:21:21.380
And that -- that order, the sequence of assigning
the fields in the constructor generates the

00:21:21.380 --> 00:21:23.280
class ID.

00:21:23.280 --> 00:21:29.330
So A little bit later on after constructing
P, somewhere in the program, someone just

00:21:29.330 --> 00:21:33.640
adds a new field to the P object, which is
completely fine inside JavaScript.

00:21:33.640 --> 00:21:39.610
But that new field inside P, that instance,
creates a new class ID.

00:21:39.610 --> 00:21:45.320
So this is going to trigger a deoptimization.

00:21:45.320 --> 00:21:47.240
So let's walk through kind of what happens.

00:21:47.240 --> 00:21:50.200
This calls back to that state machine we were
just looking at.

00:21:50.200 --> 00:21:54.350
So at first we see this point object, the
class ID for it.

00:21:54.350 --> 00:21:57.760
And code is running in unoptimized state because
it is the beginning of execution and that's

00:21:57.760 --> 00:21:58.960
expected.

00:21:58.960 --> 00:22:03.430
So after a little bit of time, V8 detects
that some functions using point are hot and

00:22:03.430 --> 00:22:05.870
let's optimize for them.

00:22:05.870 --> 00:22:09.220
But then the shape is modified.

00:22:09.220 --> 00:22:11.470
And this point prime class is created.

00:22:11.470 --> 00:22:15.940
So now there's two point classes kind of floating
around inside the internal state of V8.

00:22:15.940 --> 00:22:19.400
There's point with XY and there is point with
XYZ.

00:22:19.400 --> 00:22:25.500
So the next time a call site sees this point
prime class when it is expecting a point class,

00:22:25.500 --> 00:22:31.090
it actually de-optimizes and we go across
that graph back to the unoptimized state.

00:22:31.090 --> 00:22:37.970
But after a little while, the code is optimized
to support both point and point prime classes.

00:22:37.970 --> 00:22:43.400
So, again, a careful audit confirmed there
were no shape changes.

00:22:43.400 --> 00:22:45.560
This is a really common JavaScript performance
trap.

00:22:45.560 --> 00:22:48.440
And, again, the unit9 guys were really well-read.

00:22:48.440 --> 00:22:53.030
So it is not surprising that this was not
the problem.

00:22:53.030 --> 00:22:59.000
And in some ways, suspect Number 3 is a special
case of suspect Number 2.

00:22:59.000 --> 00:23:03.280
So suspect Number 1, calling new, its alibi,
wasn't even at the crime scene.

00:23:03.280 --> 00:23:04.940
No one was doing that.

00:23:04.940 --> 00:23:06.520
Suspect Number 2 has no alibi.

00:23:06.520 --> 00:23:10.070
So it seems like a pretty likely suspect at
this point.

00:23:10.070 --> 00:23:13.681
And the third one, suspect Number 3, shape
change, again, not at the crime scene so we

00:23:13.681 --> 00:23:14.880
are really narrowing in.

00:23:14.880 --> 00:23:19.050
It really seems likely that a big chunk of
code is running in unoptimized mode.

00:23:19.050 --> 00:23:22.330
And now we need to get to the lab and prove
this.

00:23:22.330 --> 00:23:28.820
So there is a lot of tools that you can use
to help diagnose and really dig into performance

00:23:28.820 --> 00:23:29.830
problems.

00:23:29.830 --> 00:23:30.910
First is Chrome DevTools.

00:23:30.910 --> 00:23:35.780
And that's the panel that you can bring up
inside Chrome, and it ships with Chrome.

00:23:35.780 --> 00:23:39.570
But this is a real performance mystery, so
we're just going to jump right past it.

00:23:39.570 --> 00:23:41.860
We are already past Chrome DevTools.

00:23:41.860 --> 00:23:43.130
The next is about tracing.

00:23:43.130 --> 00:23:47.990
And this is a really great tool for diagnosing
the internal GPU state inside Chrome and some

00:23:47.990 --> 00:23:50.600
other really low-level information.

00:23:50.600 --> 00:23:52.730
But, again, like, we're past this.

00:23:52.730 --> 00:23:56.290
This is a really strange performance problem.

00:23:56.290 --> 00:23:59.000
So we've got to jump right down to the nitty-gritty.

00:23:59.000 --> 00:24:01.180
We have got to go to the V8 tools.

00:24:01.180 --> 00:24:04.320
The V8 tools actually ship with V8 source
code.

00:24:04.320 --> 00:24:08.630
So if you want to use these tools, you have
to go to Google code and grab V8 and compile

00:24:08.630 --> 00:24:11.240
it and then you get access to these tools.

00:24:11.240 --> 00:24:18.090
As we will see, these tools were necessary
to diagnose this performance problem.

00:24:18.090 --> 00:24:21.810
So what we want to do is we want to confirm
that unoptimized code is running and then

00:24:21.810 --> 00:24:26.550
determine why that code isn't being optimized.

00:24:26.550 --> 00:24:29.680
So the first thing we want to do is we want
to capture a V8 timeline.

00:24:29.680 --> 00:24:35.100
And the way you do that is you run Chrome
with this crazy command line flag, Chrome,

00:24:35.100 --> 00:24:39.380
no Sandbox, JS flags, prof, noprof2-lazy,
log-timer events.

00:24:39.380 --> 00:24:43.660
Kind of strange but it gives you a lot of
really good information.

00:24:43.660 --> 00:24:47.461
So after running Chrome with this and you
run your site for a little while, you close

00:24:47.461 --> 00:24:48.461
it down.

00:24:48.461 --> 00:24:51.940
Inside the directory that you launched Chrome
from will be a v8.logfile.

00:24:51.940 --> 00:24:55.050
This is a text file which you are free to
open up and look inside but it is a little

00:24:55.050 --> 00:24:56.480
bit cryptic.

00:24:56.480 --> 00:25:01.500
So V8 ships with some tools that will parse
this logfile and generate really useful information

00:25:01.500 --> 00:25:04.200
for you.

00:25:04.200 --> 00:25:09.370
So after running plot timer events on the
log, you are going to get a PNG that actually

00:25:09.370 --> 00:25:13.410
shows you a big timeline of the state of V8
and what's happening.

00:25:13.410 --> 00:25:19.440
So let's kind of walk through what's in this
diagram here.

00:25:19.440 --> 00:25:25.560
So along the left-hand side are rows representing
different states that V8 is executing in.

00:25:25.560 --> 00:25:30.250
And you will see a colored vertical tick whenever
V8 is in that state.

00:25:30.250 --> 00:25:34.380
So along the top is some different garbage
collector states.

00:25:34.380 --> 00:25:39.320
And I have arrowed out the scavenger, and
that's the young generation collection.

00:25:39.320 --> 00:25:44.740
Along the bottom there, you can see the V8.execute
state and that's when it is executing script

00:25:44.740 --> 00:25:45.740
code.

00:25:45.740 --> 00:25:50.170
You will see, though, where the blue line
for the scavenger, you can actually see that

00:25:50.170 --> 00:25:53.020
there is a blank spot on the execute.

00:25:53.020 --> 00:25:55.880
And this fits with our understanding of the
way GC works.

00:25:55.880 --> 00:26:01.980
When GC is active, your script isn't executing.

00:26:01.980 --> 00:26:06.450
So along the middle is this colored band showing
you the code kind.

00:26:06.450 --> 00:26:11.390
And this is really helpful because we suspect
that we're running some unoptimized code and

00:26:11.390 --> 00:26:12.390
looking at the timeline.

00:26:12.390 --> 00:26:14.060
It really does look like we are.

00:26:14.060 --> 00:26:16.900
So the bright green is optimized code.

00:26:16.900 --> 00:26:21.750
So when you see that across, you know that
everything executing across those ticks is

00:26:21.750 --> 00:26:22.750
optimized.

00:26:22.750 --> 00:26:28.350
What we see in the graph is we see this blue-purply
kind of color, and this is unoptimized code.

00:26:28.350 --> 00:26:33.770
And it is executing in different stubs and
different runtime methods inside V8.

00:26:33.770 --> 00:26:40.340
So it looks like our hunch was correct and
that we are executing some unoptimized code.

00:26:40.340 --> 00:26:46.380
So if we look at the transition where we switch
from running optimized code to unoptimized

00:26:46.380 --> 00:26:50.680
code, it might be difficult to see on the
slides because that's a little bit blown out.

00:26:50.680 --> 00:26:55.680
But you can actually see that there is a whole
bunch of scavenges across that time slice.

00:26:55.680 --> 00:26:59.330
You can actually see there are little gaps
in the execution that fit perfectly with when

00:26:59.330 --> 00:27:01.330
these scavengers were occurring.

00:27:01.330 --> 00:27:02.330
So here we are.

00:27:02.330 --> 00:27:03.360
Oz is running smoothly.

00:27:03.360 --> 00:27:07.270
And then we are at that one-second mark and
it hiccups down and it starts running unoptimized

00:27:07.270 --> 00:27:09.190
code for some reason.

00:27:09.190 --> 00:27:12.650
And we can see that there is all these scavenges,
and this fits exactly with what we saw inside

00:27:12.650 --> 00:27:15.170
Chrome DevTools.

00:27:15.170 --> 00:27:21.309
Another really helpful piece of information
inside the timeline is this graph along the

00:27:21.309 --> 00:27:22.309
bottom.

00:27:22.309 --> 00:27:23.480
And this is the pause times graph.

00:27:23.480 --> 00:27:26.850
So you can see at the beginning, there is
actually a whole bunch of pause times.

00:27:26.850 --> 00:27:30.840
You can see these black vertical bars sticking
up on the bottom on the left-hand side.

00:27:30.840 --> 00:27:33.271
That's when it is parsing the script, and
it is actually just getting going.

00:27:33.271 --> 00:27:37.150
And then we're in optimized function time.

00:27:37.150 --> 00:27:38.521
You don't see any pause times there.

00:27:38.521 --> 00:27:40.650
It is just this flat curve.

00:27:40.650 --> 00:27:45.110
And then right when we transition into running
unoptimized code and we see all these scavenges,

00:27:45.110 --> 00:27:48.270
we also see correlated spikes in pause times.

00:27:48.270 --> 00:27:53.200
So you can see that the scripts have stopped
executing right when the scavenges occur,

00:27:53.200 --> 00:27:58.090
right when we transition to unoptimized code.

00:27:58.090 --> 00:28:00.210
So now we need to figure out what function
is that?

00:28:00.210 --> 00:28:02.730
I mean, we've confirmed that there's unoptimized
code running.

00:28:02.730 --> 00:28:05.760
But we really have to nail down who is responsible
for it.

00:28:05.760 --> 00:28:10.700
So, again, we run Chrome with the same command
line flags but this time we take the V8 log

00:28:10.700 --> 00:28:13.610
and we run the Mac tick processor.

00:28:13.610 --> 00:28:17.770
And so when you download V8 and you build
it, you are going to get a tick processor

00:28:17.770 --> 00:28:19.660
for whatever platform you build it on.

00:28:19.660 --> 00:28:21.440
So there is a Windows one, a Linux one.

00:28:21.440 --> 00:28:24.960
In this case, we are on a Mac so we will run
the Mac tick processor.

00:28:24.960 --> 00:28:30.990
When you run that on the V8 log, you actually
get this nice helpful table of functions sorted

00:28:30.990 --> 00:28:35.440
by how frequently they're seen by the profiler.

00:28:35.440 --> 00:28:41.380
So next to drawsprites, you see this asterisk;
and that indicates that the function in question

00:28:41.380 --> 00:28:43.400
is optimized.

00:28:43.400 --> 00:28:48.250
But if we look at the top, this is the function
that is running the most -- most often in

00:28:48.250 --> 00:28:50.890
the profile capture.

00:28:50.890 --> 00:28:52.800
Updatesprites doesn't have a asterisk next
to it.

00:28:52.800 --> 00:28:55.640
So this seems like the likely culprit here.

00:28:55.640 --> 00:28:59.240
Something in updatesprites is causing it not
to be optimized.

00:28:59.240 --> 00:29:03.000
And so let's try to figure out what's going
on.

00:29:03.000 --> 00:29:07.560
So, how can we determine why a function is
not optimized?

00:29:07.560 --> 00:29:09.950
This is actually where it gets a little hairy.

00:29:09.950 --> 00:29:15.360
You run Chrome with a different set of flags
you run with trace deopt and trace opt verbose.

00:29:15.360 --> 00:29:19.430
What happens is actually a lot of text just
gets dumped to the terminal that you launched

00:29:19.430 --> 00:29:20.430
Chrome from.

00:29:20.430 --> 00:29:21.790
It is just this wall of text.

00:29:21.790 --> 00:29:25.800
You likely want to pipe it to a text file
and look at it later on.

00:29:25.800 --> 00:29:30.900
But digging through that, we looked for updatesprites
and we actually found that, Hey, here's this

00:29:30.900 --> 00:29:36.160
line that says "disabled optimization for
updatesprites, reason: Forinstatement is not

00:29:36.160 --> 00:29:37.240
the fast case."

00:29:37.240 --> 00:29:41.770
It seems kind of cryptic at this point, but
I think when we look at the source code of

00:29:41.770 --> 00:29:48.300
updatesprites, we might get a better idea
of what's going on.

00:29:48.300 --> 00:29:55.320
So, here's equivalent of the problem code
in Oz.

00:29:55.320 --> 00:29:57.960
We have this function updatesprites.

00:29:57.960 --> 00:30:02.790
And it just iterates using a for-in loop across
the sprites array.

00:30:02.790 --> 00:30:06.230
And then inside of this loop, it just does
a bunch of arithmetic.

00:30:06.230 --> 00:30:10.500
And if we remember earlier, when you are running
in unoptimized mode and you are performing

00:30:10.500 --> 00:30:14.620
arithmetic, you actually are allocating all
of these objects, like, just for temporary

00:30:14.620 --> 00:30:18.750
values that aren't being stored anywhere.

00:30:18.750 --> 00:30:21.830
And here we see this for-in statement.

00:30:21.830 --> 00:30:26.860
And this function was not being optimized
specifically because of this loop construct.

00:30:26.860 --> 00:30:31.100
And earlier when I was showing you the diagram
of the different states that your functions

00:30:31.100 --> 00:30:36.340
can be in inside V8, there is way to get into
unoptimized hell by just using a code construct

00:30:36.340 --> 00:30:38.320
that V8 doesn't optimize for today.

00:30:38.320 --> 00:30:44.370
It is not that V8 can't optimize for it, but
it just hasn't yet.

00:30:44.370 --> 00:30:47.170
So this seems like we've kind of found our
suspect here.

00:30:47.170 --> 00:30:50.690
It is this single line of code, is triggering
V8 to say, You know what?

00:30:50.690 --> 00:30:52.420
I can't optimize this.

00:30:52.420 --> 00:30:54.510
I will just treat it as an unoptimized function.

00:30:54.510 --> 00:30:56.590
We couldn't really have this.

00:30:56.590 --> 00:31:02.950
So, ah, yes, arithmetic has implicit allocations.

00:31:02.950 --> 00:31:04.510
So the fix is actually really simple.

00:31:04.510 --> 00:31:09.530
You just move the arithmetic into its own
function and this function doesn't have the

00:31:09.530 --> 00:31:14.420
forinstatement so it can actually be optimized
by V8.

00:31:14.420 --> 00:31:19.929
And we can leave that for-in loop inside the
unoptimized function and just call the updatesprite

00:31:19.929 --> 00:31:21.730
method.

00:31:21.730 --> 00:31:28.140
So if we look at the memory of such graph
before and after, we can see a really clear

00:31:28.140 --> 00:31:29.140
difference.

00:31:29.140 --> 00:31:33.590
We're no longer seeing this huge sawtooth
spike up and then come down with a GC.

00:31:33.590 --> 00:31:40.510
We are seeing a nice, natural growth curve
which -- which you want to see.

00:31:40.510 --> 00:31:41.900
So case closed, right?

00:31:41.900 --> 00:31:43.230
I mean, we figured it out.

00:31:43.230 --> 00:31:47.890
But, actually, the GC pause time was a bit
of a red herring because the real performance

00:31:47.890 --> 00:31:52.190
problem was that all this arithmetic was executing
in unoptimized mode.

00:31:52.190 --> 00:31:54.480
That's just significantly slower.

00:31:54.480 --> 00:32:02.730
So, the GC pause time actually led us to fixing
the problem but it wasn't the problem in itself.

00:32:02.730 --> 00:32:04.559
But it was a really, really simple fix.

00:32:04.559 --> 00:32:05.880
I mean, you saw how simple it was.

00:32:05.880 --> 00:32:07.600
Just move the loop body into its own function.

00:32:07.600 --> 00:32:09.550
It was great.

00:32:09.550 --> 00:32:14.530
But what was really helpful and what I hope
you can take away from this talk is that unit9,

00:32:14.530 --> 00:32:19.000
the developers who built Oz, they understood
how to look under the hood.

00:32:19.000 --> 00:32:24.429
They understood how to pull out all this information
and surface these signals inside V8.

00:32:24.429 --> 00:32:28.490
And they on their own without the help of
the V8 team were able to go and identify many

00:32:28.490 --> 00:32:33.350
other functions which would have got stuck
in deoptimization hell and just generally

00:32:33.350 --> 00:32:38.500
improved the performance of their code.

00:32:38.500 --> 00:32:42.370
So in conclusion, V8 offers three tools.

00:32:42.370 --> 00:32:47.480
There's the timeline plot tool which is this
bird's eye view of V8 activity.

00:32:47.480 --> 00:32:51.620
There is the tick processor, which is going
to give you a table of hot functions.

00:32:51.620 --> 00:32:56.290
And, remember, there is a asterisk next to
the functions which are optimized.

00:32:56.290 --> 00:32:59.560
If you are running into a similar problem,
you are going to want to look for functions

00:32:59.560 --> 00:33:00.590
that lack the asterisk.

00:33:00.590 --> 00:33:02.780
And then the deoptimization log.

00:33:02.780 --> 00:33:08.130
This actually gives you deep insight into
the optimization state machine that we looked

00:33:08.130 --> 00:33:10.610
at previously.

00:33:10.610 --> 00:33:16.160
So, solving a performance problem is just
like solving a crime in real life.

00:33:16.160 --> 00:33:18.221
You first have to start with evidence collection.

00:33:18.221 --> 00:33:22.360
And it is really important to ask the right
questions because you might start going down

00:33:22.360 --> 00:33:27.090
the path that leads you to no performance
improvement.

00:33:27.090 --> 00:33:30.750
After you've collected the right set of evidence,
you move on to suspects.

00:33:30.750 --> 00:33:34.680
You try and narrow it down to a few likely
culprits.

00:33:34.680 --> 00:33:39.010
And then after interrogating your suspects,
you want to move on to the forensics lab and

00:33:39.010 --> 00:33:41.640
use these tools to prove your case.

00:33:41.640 --> 00:33:46.110
So, of course, you want to start with Chrome
DevTools and then maybe about tracing before

00:33:46.110 --> 00:33:47.230
you get to V8.

00:33:47.230 --> 00:33:51.400
But sometimes these performance problems are
so mysterious that the only way that you're

00:33:51.400 --> 00:33:58.100
going to be able to solve them is by using
these tools that we just covered.

00:33:58.100 --> 00:34:01.240
So thank you.

00:34:01.240 --> 00:34:10.700
[ Applause ]
So don't forget to check out perf alley.

00:34:10.700 --> 00:34:13.710
And we have a few minutes for questions.

00:34:13.710 --> 00:34:16.700
But afterwards, I will be up doing some Chrome
office hours upstairs.

00:34:16.700 --> 00:34:21.689
If you have any questions, please come to
the mic.

00:34:21.689 --> 00:34:22.689
&gt;&gt;&gt; Hi.

00:34:22.689 --> 00:34:29.300
So I'm curious if I used -- if I had used
a closure compiler to compile my JavaScript,

00:34:29.300 --> 00:34:34.609
does it automatically figure out that these
constructs could lead to unoptimized code

00:34:34.609 --> 00:34:36.310
and remove them?

00:34:36.310 --> 00:34:37.310
Or what happens?

00:34:37.310 --> 00:34:39.700
&gt;&gt;John McCutchan: That's actually a good question
for the closure team.

00:34:39.700 --> 00:34:40.700
&gt;&gt;&gt; Uh-huh.

00:34:40.700 --> 00:34:44.419
&gt;&gt;John McCutchan: But I would hope that some
constructs they are aware are slower.

00:34:44.419 --> 00:34:49.339
Of course, it varies over which JavaScript
engine is executing the code.

00:34:49.339 --> 00:34:50.339
&gt;&gt;&gt; Okay.

00:34:50.339 --> 00:34:51.729
&gt;&gt;John McCutchan: Everyone has a slightly
different performance profile.

00:34:51.729 --> 00:34:56.109
&gt;&gt;&gt; I mean, is there some or any static analysis,
some kind of tool I could put my JavaScript

00:34:56.109 --> 00:34:59.680
into to tell me when I'm using constructs
like this?

00:34:59.680 --> 00:35:04.049
Because it seems like this you could have
caught very easily without actually running

00:35:04.049 --> 00:35:05.049
it, right?

00:35:05.049 --> 00:35:07.839
&gt;&gt;John McCutchan: Well, in some sense, yeah,
it does kind of seem that way.

00:35:07.839 --> 00:35:12.369
You will note that the message was actually
-- the forinstatement is not the fast case.

00:35:12.369 --> 00:35:16.849
So the fact that it couldn't be optimized
really depended on the runtime behavior.

00:35:16.849 --> 00:35:21.640
But I agree, it would be nice to have a static
analysis tool that was kept current with JavaScript

00:35:21.640 --> 00:35:24.380
engines because this is always changing.

00:35:24.380 --> 00:35:27.859
So you wouldn't want to have a tool that's
a year old because some of the advice might

00:35:27.859 --> 00:35:28.859
just be wrong.

00:35:28.859 --> 00:35:29.880
&gt;&gt;&gt; Right, okay.

00:35:29.880 --> 00:35:30.880
Cool.

00:35:30.880 --> 00:35:32.549
&gt;&gt;&gt; Hi, I'm James Harding.

00:35:32.549 --> 00:35:36.999
I was wondering, is there a way that you can
tell V8 you are going to allocate a bunch

00:35:36.999 --> 00:35:42.160
of objects, especially like if a user goes
to a page where, like, the developer, like,

00:35:42.160 --> 00:35:45.369
we know that there's going to be thousands
of objects that are going to be allocated

00:35:45.369 --> 00:35:48.079
when they visit that page, is there any way
to sort of optimize that?

00:35:48.079 --> 00:35:52.660
&gt;&gt;John McCutchan: There is no way to tell
V8, hey, I'm going to allocate thousands of

00:35:52.660 --> 00:35:54.480
objects, don't do any GC.

00:35:54.480 --> 00:35:59.079
What you could do is at that initial -- when
the page is first loading and the scripts

00:35:59.079 --> 00:36:03.920
are first executing, you can preallocate a
lot of these objects and then keep them around.

00:36:03.920 --> 00:36:06.420
&gt;&gt;&gt; Okay, thank you.

00:36:06.420 --> 00:36:08.720
&gt;&gt;&gt; So this kind of goes back to the first
question.

00:36:08.720 --> 00:36:13.660
You said that static tools probably wouldn't
be good because, I mean, the advice changes,

00:36:13.660 --> 00:36:14.660
right?

00:36:14.660 --> 00:36:17.950
I mean, the engine changes and what was good
before is no longer good.

00:36:17.950 --> 00:36:20.500
But I see that same problem with something
like this, right?

00:36:20.500 --> 00:36:26.150
Like, you make that change now, but that change
that you made now is no longer good in the

00:36:26.150 --> 00:36:27.150
future?

00:36:27.150 --> 00:36:28.150
Right?

00:36:28.150 --> 00:36:29.150
Because this changes a lot, like the V8 engine.

00:36:29.150 --> 00:36:30.460
&gt;&gt;John McCutchan: Yeah, so it does.

00:36:30.460 --> 00:36:35.390
But what I'm trying to get across here is
how to use these tools to uncover any performance

00:36:35.390 --> 00:36:36.390
problem.

00:36:36.390 --> 00:36:37.390
&gt;&gt;&gt; Yeah.

00:36:37.390 --> 00:36:38.459
&gt;&gt;John McCutchan: Not just highlight this
for-in loop.

00:36:38.459 --> 00:36:39.459
&gt;&gt;&gt; Right.

00:36:39.459 --> 00:36:45.599
Do you think that V8 -- I don't know how to
say this -- is stable enough to, like, justify

00:36:45.599 --> 00:36:46.599
that?

00:36:46.599 --> 00:36:50.420
Because, I mean, I wouldn't want to do something
like this, which is quite a bit of investment,

00:36:50.420 --> 00:36:55.180
to have, like, two months later, like -- I
don't know a lot about V8.

00:36:55.180 --> 00:36:58.920
Do you think it is stable enough that this
kind of investment is worth it?

00:36:58.920 --> 00:37:03.519
&gt;&gt;John McCutchan: Well, again, this work was
done because the performance was bad already.

00:37:03.519 --> 00:37:04.519
&gt;&gt;&gt; Uh-huh.

00:37:04.519 --> 00:37:07.640
&gt;&gt;John McCutchan: So, I mean, that's the first
question you should ask yourself, is: Are

00:37:07.640 --> 00:37:08.640
things performing fine?

00:37:08.640 --> 00:37:12.970
In which case, you should stop, because great,
there is no problem.

00:37:12.970 --> 00:37:14.940
But V8 does change a lot.

00:37:14.940 --> 00:37:20.920
But I wouldn't expect V8 to take something
that once ran fast and make it run slow.

00:37:20.920 --> 00:37:21.920
&gt;&gt;&gt; Okay.

00:37:21.920 --> 00:37:22.920
Thanks.

00:37:22.920 --> 00:37:23.920
&gt;&gt;&gt; Hi.

00:37:23.920 --> 00:37:27.509
I'm (saying name) from LinkedIn Mobile.

00:37:27.509 --> 00:37:33.069
I'm curious, what are you guys doing with
the Chrome DevTools to help bring better some

00:37:33.069 --> 00:37:36.880
of the P analysis and performance analysis
to node GAS?

00:37:36.880 --> 00:37:40.190
Because right now there's a lot of community
projects out there that kind of attempt to

00:37:40.190 --> 00:37:41.190
do that.

00:37:41.190 --> 00:37:45.559
It would really be nice if there was a Google-blessed
way of profiling V8 in node GAS for long-running

00:37:45.559 --> 00:37:46.950
processes in memory management.

00:37:46.950 --> 00:37:50.859
&gt;&gt;John McCutchan: That would be nice, but
I'm not the right person to ask that question.

00:37:50.859 --> 00:37:52.509
I think it would be great, too.

00:37:52.509 --> 00:37:55.460
We have a question at the back microphone
now.

00:37:55.460 --> 00:37:56.460
&gt;&gt;&gt; Yeah.

00:37:56.460 --> 00:37:57.460
So these tools look really cool.

00:37:57.460 --> 00:37:58.559
I would like to use them.

00:37:58.559 --> 00:38:00.900
I don't particularly want to download V8 to
do so.

00:38:00.900 --> 00:38:04.069
Do you know if there are any plans to source
this sort of information in Chrome?

00:38:04.069 --> 00:38:05.069
It seems like it would be useful to Chrome
--

00:38:05.069 --> 00:38:06.069
[ Multiple people speaking simultaneously
]

00:38:06.069 --> 00:38:10.489
&gt;&gt;John McCutchan: There is discussions about
how we can surface some of these signals into

00:38:10.489 --> 00:38:15.480
Chrome DevTools or maybe about tracing so
you don't have to go and grab the V8 source

00:38:15.480 --> 00:38:16.480
code.

00:38:16.480 --> 00:38:21.930
But it's going to be kind of like this -- it
is going to be a continuous transition so

00:38:21.930 --> 00:38:25.779
you could still get into situations where,
you know, we've surfaced a whole bunch of

00:38:25.779 --> 00:38:29.319
signals but you still need to go and grab
the tools to find that one signal that we

00:38:29.319 --> 00:38:30.390
haven't surfaced yet.

00:38:30.390 --> 00:38:31.390
But yeah.

00:38:31.390 --> 00:38:35.329
We're aware of the desire to have this stuff
come up into DevTools.

00:38:35.329 --> 00:38:36.759
All right.

00:38:36.759 --> 00:38:38.200
Thank you.

00:38:38.200 --> 00:38:38.920
[ Applause ]

