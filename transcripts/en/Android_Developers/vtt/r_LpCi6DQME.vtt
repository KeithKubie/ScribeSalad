WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:09.779
[APPLAUSE]

00:00:09.779 --> 00:00:10.570
COLT MCANLIS: Yeah!

00:00:13.972 --> 00:00:18.380
Google I/O, 2016, right?

00:00:18.380 --> 00:00:19.081
Oh, come on.

00:00:19.081 --> 00:00:20.080
We're done clapping now?

00:00:20.080 --> 00:00:20.933
Is that it?

00:00:20.933 --> 00:00:21.900
[LAUGHTER]

00:00:21.900 --> 00:00:22.890
All right, we're done.

00:00:22.890 --> 00:00:23.700
Hello, everyone.

00:00:23.700 --> 00:00:24.700
How are you doing today?

00:00:24.700 --> 00:00:25.570
Good?

00:00:25.570 --> 00:00:27.720
Staying out of the sun?

00:00:27.720 --> 00:00:28.220
Yes?

00:00:28.220 --> 00:00:29.140
Fantastic.

00:00:29.140 --> 00:00:31.137
Hey, I want to thank
everybody for being here.

00:00:31.137 --> 00:00:33.220
My name is Colt McAnlis,
and I've got to tell you,

00:00:33.220 --> 00:00:37.050
I love Google I/O. I love Google
I/O, because this is the one

00:00:37.050 --> 00:00:40.240
time during the whole year
that the crazy Googlers get

00:00:40.240 --> 00:00:42.600
to talk to all of you all
about the weird stuff we

00:00:42.600 --> 00:00:44.641
do that we can't talk
about the rest of the year.

00:00:44.641 --> 00:00:46.164
And that is fantastic, right?

00:00:46.164 --> 00:00:47.830
And today, we're
talking about something

00:00:47.830 --> 00:00:49.870
that's so near and
dear to my heart,

00:00:49.870 --> 00:00:51.300
and that's data compression.

00:00:51.300 --> 00:00:54.540
It is, by far, one of my
favorite, most obsessive things

00:00:54.540 --> 00:00:56.020
that I ever get involved with.

00:00:56.020 --> 00:00:57.790
And I'm so happy that
all of you are here.

00:00:57.790 --> 00:00:59.790
And all the people standing
outside-- I'm sorry.

00:00:59.790 --> 00:01:01.400
There's capacity issues.

00:01:01.400 --> 00:01:03.660
We'll give them a t-shirt
or something later.

00:01:03.660 --> 00:01:06.940
But really quick, before we
begin, I've got to tell you,

00:01:06.940 --> 00:01:08.580
we've only got 45 minutes today.

00:01:08.580 --> 00:01:11.860
And that is just not
enough time to get

00:01:11.860 --> 00:01:15.740
through all the awesome, crazy
image compression content

00:01:15.740 --> 00:01:17.020
that we need to get done.

00:01:17.020 --> 00:01:18.070
So over the past
couple of weeks,

00:01:18.070 --> 00:01:19.530
I've been trying to
diffuse some of this stuff

00:01:19.530 --> 00:01:20.510
to some other places.

00:01:20.510 --> 00:01:22.440
First off, here's
my Medium.com page.

00:01:22.440 --> 00:01:24.654
Has anyone been
reading these articles?

00:01:24.654 --> 00:01:25.579
AUDIENCE: [INAUDIBLE]!

00:01:25.579 --> 00:01:26.370
COLT MCANLIS: Yeah!

00:01:26.370 --> 00:01:28.350
A round of applause if you've
been reading the Medium

00:01:28.350 --> 00:01:29.195
articles, yeah?

00:01:29.195 --> 00:01:30.560
[APPLAUSE]

00:01:30.560 --> 00:01:33.120
We're live, folks. you've
got to make 'em hear it.

00:01:33.120 --> 00:01:34.507
Yeah?

00:01:34.507 --> 00:01:36.840
If you read these articles,
we get into a lot more depth

00:01:36.840 --> 00:01:38.440
on how some of these
image formats work

00:01:38.440 --> 00:01:39.890
and how to make
them a lot smaller.

00:01:39.890 --> 00:01:42.270
Second off, of course, is the
Android Performance Patterns

00:01:42.270 --> 00:01:42.769
videos.

00:01:42.769 --> 00:01:43.607
Anybody watch these?

00:01:43.607 --> 00:01:44.830
[APPLAUSE]

00:01:44.830 --> 00:01:45.900
Thank you.

00:01:45.900 --> 00:01:47.050
Thank you.

00:01:47.050 --> 00:01:48.250
Thank you.

00:01:48.250 --> 00:01:49.010
That's fantastic.

00:01:49.010 --> 00:01:51.785
Now, if you've ever been
interested in data compression,

00:01:51.785 --> 00:01:53.410
if you've ever tried
to make an attempt

00:01:53.410 --> 00:01:55.230
to understand the
algorithms, but found

00:01:55.230 --> 00:01:57.260
that the math is
really weird, or it's

00:01:57.260 --> 00:01:58.820
too gnarly of a
concept, or maybe

00:01:58.820 --> 00:02:00.320
it's not presented
in the right way,

00:02:00.320 --> 00:02:02.570
then good news for you,
because Alex Hackey

00:02:02.570 --> 00:02:04.090
and I have actually
got together,

00:02:04.090 --> 00:02:06.276
and we've actually written
a data compression book.

00:02:06.276 --> 00:02:07.900
And we took a different
approach to it.

00:02:07.900 --> 00:02:10.250
We threw out all the math.

00:02:10.250 --> 00:02:13.300
All of that crazy gnarly stuff
that makes your brain melt,

00:02:13.300 --> 00:02:14.074
we got rid of it.

00:02:14.074 --> 00:02:15.490
And we re-approached
how we should

00:02:15.490 --> 00:02:19.110
be teaching data compression
to modern developers

00:02:19.110 --> 00:02:20.120
and engineers.

00:02:20.120 --> 00:02:23.080
So if you're interested in a
deep, fundamental understanding

00:02:23.080 --> 00:02:26.671
of how to make your apps smaller
for users, check out this book.

00:02:26.671 --> 00:02:27.170
Deal?

00:02:27.170 --> 00:02:27.787
Deal?

00:02:27.787 --> 00:02:29.370
All right, business
is out of the way.

00:02:29.370 --> 00:02:30.130
Let's get started.

00:02:30.130 --> 00:02:32.560
So when we talk about
reducing the data

00:02:32.560 --> 00:02:35.310
sizes of your applications
for your users,

00:02:35.310 --> 00:02:38.090
there's generally two buckets
that I like to think of.

00:02:38.090 --> 00:02:40.364
On one side, is your APK size.

00:02:40.364 --> 00:02:41.780
And this includes
all of the stuff

00:02:41.780 --> 00:02:44.980
like code sizes, language
information resources, image

00:02:44.980 --> 00:02:45.480
resources.

00:02:45.480 --> 00:02:47.460
We've got layout data,
config, blah, blah,

00:02:47.460 --> 00:02:49.790
blah-- all of the
information that's

00:02:49.790 --> 00:02:53.250
zipped up into a single APK
file and downloaded when

00:02:53.250 --> 00:02:55.090
users install your application.

00:02:55.090 --> 00:02:58.520
Now, on the other side of
things is all of the other stuff

00:02:58.520 --> 00:03:00.730
that your app downloads
once it's installed

00:03:00.730 --> 00:03:01.780
from the internet, right?

00:03:01.780 --> 00:03:03.970
So this could be many,
many, many things,

00:03:03.970 --> 00:03:07.090
but it mostly boils down to
images and serialized data.

00:03:07.090 --> 00:03:09.720
Now, I've got to say that
the APK stuff, making

00:03:09.720 --> 00:03:13.425
your APKs smaller, is a
whole deep and crazy domain

00:03:13.425 --> 00:03:15.050
that we're not going
to get into today.

00:03:15.050 --> 00:03:16.880
However, if you
stay in your seats,

00:03:16.880 --> 00:03:21.100
the next session will go very,
very deep into that subject.

00:03:21.100 --> 00:03:23.520
So make sure you
stick around for that.

00:03:23.520 --> 00:03:25.070
One thing you
notice here, though,

00:03:25.070 --> 00:03:28.547
is that images actually show
up in both of these categories.

00:03:28.547 --> 00:03:30.630
And that's why we're
focusing on our images today.

00:03:30.630 --> 00:03:33.107
Because quite frankly,
images are awesome, right?

00:03:33.107 --> 00:03:34.315
Round of applause for images?

00:03:34.315 --> 00:03:35.120
[APPLAUSE]

00:03:35.120 --> 00:03:35.620
Yeah?

00:03:39.110 --> 00:03:42.290
I promise you, I will ask you
to applaud weirder and weirder

00:03:42.290 --> 00:03:46.510
stuff as the talk goes on,
like who likes gummy bears?

00:03:46.510 --> 00:03:47.770
[APPLAUSE]

00:03:47.770 --> 00:03:48.694
Yeah, there we go.

00:03:48.694 --> 00:03:51.360
We have to have an understanding
as an audience and a presenter.

00:03:51.360 --> 00:03:53.090
That's how this works, right?

00:03:53.090 --> 00:03:54.500
Images are fantastic.

00:03:54.500 --> 00:03:55.920
We use them in our applications.

00:03:55.920 --> 00:03:59.000
We convey emotion, and
power, and information,

00:03:59.000 --> 00:04:00.430
and all this other great stuff.

00:04:00.430 --> 00:04:04.040
But images also have a problem,
is that they're easy to bloat.

00:04:04.040 --> 00:04:05.900
They're easy to get
too big, and too many

00:04:05.900 --> 00:04:07.590
resolutions, and
too many pixels.

00:04:07.590 --> 00:04:10.040
And that causes
problems for your users,

00:04:10.040 --> 00:04:11.900
because bigger
images take longer

00:04:11.900 --> 00:04:13.970
to download, which
means that there's

00:04:13.970 --> 00:04:17.310
more bits on the wire, which
costs your users more money

00:04:17.310 --> 00:04:19.700
to download them, because
they're on metered plans.

00:04:19.700 --> 00:04:21.754
And their cellular
radio is on longer,

00:04:21.754 --> 00:04:23.420
downloading the larger
images, so you're

00:04:23.420 --> 00:04:25.400
eating their battery more.

00:04:25.400 --> 00:04:27.290
All of these little
things add up

00:04:27.290 --> 00:04:29.430
when you start bringing
these images down,

00:04:29.430 --> 00:04:32.480
which is why making sure that
your images are compressed

00:04:32.480 --> 00:04:36.460
as good and as small as possible
is super important to make sure

00:04:36.460 --> 00:04:39.600
that your users are having
the best experience.

00:04:39.600 --> 00:04:41.650
And in general, there's
a lot of different things

00:04:41.650 --> 00:04:42.691
you could do with images.

00:04:42.691 --> 00:04:45.900
But as Android developers,
there's really only four data

00:04:45.900 --> 00:04:49.810
formats we care about--
PNGs, VectorDrawables, JPEGs

00:04:49.810 --> 00:04:50.640
and WebP.

00:04:50.640 --> 00:04:53.210
Now, the rest of the talk that
we're going to go into today

00:04:53.210 --> 00:04:55.900
is going to be opening up
each one of these formats,

00:04:55.900 --> 00:04:58.020
taking a look at how
it works internally

00:04:58.020 --> 00:05:01.250
and how you can squeeze
out every bit of data

00:05:01.250 --> 00:05:02.750
from these things possible.

00:05:02.750 --> 00:05:05.250
Sound good?

00:05:05.250 --> 00:05:05.980
Sound good?

00:05:05.980 --> 00:05:07.390
[APPLAUSE]

00:05:07.390 --> 00:05:08.282
Yes.

00:05:08.282 --> 00:05:10.740
Don't worry, you'll will get
the hang of the applause cues.

00:05:10.740 --> 00:05:12.800
They took down the sign
that I asked for later.

00:05:12.800 --> 00:05:13.301
That's OK.

00:05:13.301 --> 00:05:13.800
All right.

00:05:13.800 --> 00:05:15.530
So let's start at the
top with PNG files.

00:05:15.530 --> 00:05:19.632
PNGs have to be one of the
most amazing formats in terms

00:05:19.632 --> 00:05:20.590
of Android development.

00:05:20.590 --> 00:05:22.880
They've been here as
long as anybody has seen.

00:05:22.880 --> 00:05:26.770
They provide amazing quality
and, actually, pretty good

00:05:26.770 --> 00:05:27.930
data compression.

00:05:27.930 --> 00:05:30.190
So let's figure out what's
going on under the hood.

00:05:30.190 --> 00:05:31.610
So let's say we have an image.

00:05:31.610 --> 00:05:34.050
The way PNG compression
works is that we

00:05:34.050 --> 00:05:38.270
take every row of pixels in
that image, one at a time,

00:05:38.270 --> 00:05:40.130
we process each
row individually.

00:05:40.130 --> 00:05:41.790
And what we do is,
we apply something

00:05:41.790 --> 00:05:43.230
called a filter to it.

00:05:43.230 --> 00:05:46.640
Now, the filter itself is
basically a modified delta

00:05:46.640 --> 00:05:47.480
processor, right?

00:05:47.480 --> 00:05:50.100
So basically, it's going to try
to subtract the current pixel

00:05:50.100 --> 00:05:52.350
in the row from the previous
pixels, or the one above it,

00:05:52.350 --> 00:05:53.474
and do all this weird math.

00:05:53.474 --> 00:05:56.370
The point of the
filter is simple.

00:05:56.370 --> 00:05:58.980
It wants to produce the
most number of zeros

00:05:58.980 --> 00:06:00.540
and duplicate values possible.

00:06:00.540 --> 00:06:01.330
That's it.

00:06:01.330 --> 00:06:03.040
That's all it wants to do.

00:06:03.040 --> 00:06:06.640
The output of that is then
fed into a very common,

00:06:06.640 --> 00:06:09.973
super-everywhere encoding
system called, deflate.

00:06:09.973 --> 00:06:11.223
Anybody familiar with deflate?

00:06:11.223 --> 00:06:13.490
[ONE PERSON APPLAUDS]

00:06:13.490 --> 00:06:15.412
Get him a t-shirt.

00:06:15.412 --> 00:06:16.202
[LAUGHTER]

00:06:16.202 --> 00:06:16.910
That's all right.

00:06:16.910 --> 00:06:19.400
We'll get it to you later.

00:06:19.400 --> 00:06:22.190
[LAUGHTER]

00:06:22.190 --> 00:06:24.510
Deflate is actually comprised
of two main compression

00:06:24.510 --> 00:06:25.010
algorithms.

00:06:25.010 --> 00:06:26.990
The first one is called LZ77.

00:06:26.990 --> 00:06:29.000
If you've watched my
compressor head video,

00:06:29.000 --> 00:06:32.370
then you'll know that LZ77 is
a dictionary algorithm that

00:06:32.370 --> 00:06:35.840
tries to match runs of
duplicate characters

00:06:35.840 --> 00:06:38.900
multiple times in
a stream of data.

00:06:38.900 --> 00:06:41.290
The output of that is then
tossed to a Huffman encoder,

00:06:41.290 --> 00:06:42.780
which is a statistical encoder.

00:06:42.780 --> 00:06:44.710
If you've ever been
to CS-101, you've

00:06:44.710 --> 00:06:46.630
probably dealt with
Huffman in some form.

00:06:46.630 --> 00:06:48.400
Now this, again, is
done on a single line.

00:06:48.400 --> 00:06:51.480
And the output of deflate
is then kicked out to disk.

00:06:51.480 --> 00:06:55.330
Now what these two stages
mean is very important.

00:06:55.330 --> 00:06:59.390
In areas of your image where
there's very similar pixels,

00:06:59.390 --> 00:07:02.000
or there's a lot of
duplicate pixels,

00:07:02.000 --> 00:07:04.590
that filtering stage is going
to produce a lot of zeros.

00:07:04.590 --> 00:07:07.220
It's going to produce a lot
of duplicate symbols, which

00:07:07.220 --> 00:07:09.017
means the lZ77 and
the deflate stage

00:07:09.017 --> 00:07:10.850
are going to come through
and basically make

00:07:10.850 --> 00:07:12.020
that stuff disappear.

00:07:12.020 --> 00:07:15.970
So areas of similarity are
going to get great compression.

00:07:15.970 --> 00:07:17.770
However, areas of
noise, where there's not

00:07:17.770 --> 00:07:19.810
a lot of similar pixels, where
there's different colors that

00:07:19.810 --> 00:07:21.330
may not be adjoined
to each other,

00:07:21.330 --> 00:07:23.580
are actually going to
have worse compression.

00:07:23.580 --> 00:07:26.230
And that's what you get with
this trade-off of the filtering

00:07:26.230 --> 00:07:29.380
stage with the
deflate stage, right?

00:07:29.380 --> 00:07:32.370
Now, with this in
mind, we can obviously

00:07:32.370 --> 00:07:35.300
see a couple of places
that PNGs can be optimized

00:07:35.300 --> 00:07:36.800
a little bit more, right?

00:07:36.800 --> 00:07:39.010
The first, of course,
is less input colors.

00:07:39.010 --> 00:07:41.960
If we've got less input colors
coming into the filtering

00:07:41.960 --> 00:07:43.480
stage, that means
that we're going

00:07:43.480 --> 00:07:45.340
to have less unique
colors coming out,

00:07:45.340 --> 00:07:47.090
and we're going to get
better compression.

00:07:47.090 --> 00:07:49.006
The other thing is
actually smarter filtering.

00:07:49.006 --> 00:07:50.256
I won't get into it right now.

00:07:50.256 --> 00:07:51.547
There's a different post on it.

00:07:51.547 --> 00:07:53.557
But there's like five
different filtering modes

00:07:53.557 --> 00:07:55.890
that the encoder can choose
on and all that other stuff.

00:07:55.890 --> 00:07:58.760
And there's a lot of
math and accelerations

00:07:58.760 --> 00:08:00.390
that go into finding
that in a way

00:08:00.390 --> 00:08:02.764
that it's not going to take
10 years to compute it.

00:08:02.764 --> 00:08:04.680
The other thing is a
better deflate algorithm.

00:08:04.680 --> 00:08:06.960
Now, believe or not, deflate
isn't the best version

00:08:06.960 --> 00:08:07.850
of deflate.

00:08:07.850 --> 00:08:09.932
There's actually more
modern deflates out there.

00:08:09.932 --> 00:08:11.390
And applying those
to the algorithm

00:08:11.390 --> 00:08:12.723
actually produces smaller files.

00:08:12.723 --> 00:08:15.300
And finally, removing
chunks-- and that's

00:08:15.300 --> 00:08:18.070
actually a tricky one that
I'll get to in a minute.

00:08:18.070 --> 00:08:20.403
But I know what you're saying,
like, hey, wait a minute,

00:08:20.403 --> 00:08:22.790
all of that stuff should
be happening for me, right?

00:08:22.790 --> 00:08:25.164
I mean, there's this really
cool tool in the Android tool

00:08:25.164 --> 00:08:26.704
chain called, AAPT.

00:08:26.704 --> 00:08:27.620
Anybody heard or that?

00:08:27.620 --> 00:08:28.619
Round of applause, yeah?

00:08:28.619 --> 00:08:29.376
[APPLAUSE]

00:08:29.376 --> 00:08:30.964
Yeah.

00:08:30.964 --> 00:08:32.380
I mean, in reality,
this should be

00:08:32.380 --> 00:08:33.629
doing all that for you, right?

00:08:33.629 --> 00:08:36.390
It should be crunching your
PNGS down as small as possible.

00:08:36.390 --> 00:08:39.179
Anyone seen that happen?

00:08:39.179 --> 00:08:39.679
Nobody?

00:08:39.679 --> 00:08:40.760
Some people?

00:08:40.760 --> 00:08:41.929
Someone's asleep already.

00:08:41.929 --> 00:08:42.532
One applause.

00:08:42.532 --> 00:08:43.490
Get that guy a t-shirt.

00:08:43.490 --> 00:08:44.760
[LAUGHTER]

00:08:44.760 --> 00:08:47.500
T-shirts for every
clap. [LAUGHS]

00:08:47.500 --> 00:08:50.120
So I want to point out that,
while the AAPT tool is there

00:08:50.120 --> 00:08:53.120
to actually try to make
your PNG file smaller,

00:08:53.120 --> 00:08:55.690
it doesn't do
everything it could.

00:08:55.690 --> 00:08:59.900
AAPT tool does three things
specifically, no more, no less.

00:08:59.900 --> 00:09:02.390
The first thing it does
is analyze your PNG files

00:09:02.390 --> 00:09:06.500
to see whether or not you're
only using grayscale colors.

00:09:06.500 --> 00:09:08.860
So for example, if your
red, green, blue channels

00:09:08.860 --> 00:09:11.120
are all the same
color, it will actually

00:09:11.120 --> 00:09:15.340
make your entire image into a
single, 8-bit alpha channel.

00:09:15.340 --> 00:09:15.840
That's it.

00:09:15.840 --> 00:09:17.090
Goes right down to gray scale.

00:09:17.090 --> 00:09:19.131
The second thing it'll
look for is whether or not

00:09:19.131 --> 00:09:21.172
you're actually using
your transparency channel.

00:09:21.172 --> 00:09:22.880
If you've got a fully
opaque image that's

00:09:22.880 --> 00:09:24.940
not using any
transparency bits, it'll

00:09:24.940 --> 00:09:26.620
actually get rid of
that entire channel

00:09:26.620 --> 00:09:28.250
and save it out to be smaller.

00:09:28.250 --> 00:09:30.120
And the final thing--
and this is the one

00:09:30.120 --> 00:09:33.350
that's pretty awesome-- it'll
actually scan your entire image

00:09:33.350 --> 00:09:39.600
and determine whether or not
you're using 256 unique colors.

00:09:39.600 --> 00:09:42.020
If you're using
256 unique colors,

00:09:42.020 --> 00:09:44.720
it'll save your image
in a palleted format,

00:09:44.720 --> 00:09:49.460
which basically decreases
the size by some insane

00:09:49.460 --> 00:09:50.400
amount, right?

00:09:50.400 --> 00:09:53.120
Basically all of the
32-bit per pixel data

00:09:53.120 --> 00:09:55.180
gets quantized into a
little table like that

00:09:55.180 --> 00:09:56.190
that we call a palette.

00:09:56.190 --> 00:09:58.900
And it's replaced with an 8-bit
pointer into that palette.

00:09:58.900 --> 00:10:01.350
So instead of 32 bits per
pixel, you're now down 8.

00:10:01.350 --> 00:10:02.501
Good savings, right?

00:10:02.501 --> 00:10:04.000
So the question
that I have, though,

00:10:04.000 --> 00:10:07.610
is that OK, AAPT is really
good, but how good is it?

00:10:07.610 --> 00:10:10.650
And the answer that, I had
to open up an application

00:10:10.650 --> 00:10:14.230
and take a look at how AAPT
was impacting and affecting

00:10:14.230 --> 00:10:15.855
that application, to
see whether or not

00:10:15.855 --> 00:10:17.813
it was doing a really
good job, or if there are

00:10:17.813 --> 00:10:19.310
some improvements to be made.

00:10:19.310 --> 00:10:21.170
So being I/O, I
felt maybe we should

00:10:21.170 --> 00:10:23.970
do a callback to last
year's I/O sched application

00:10:23.970 --> 00:10:26.830
and see how well AAPT
was doing with that.

00:10:26.830 --> 00:10:28.430
So anyone look through
the source code

00:10:28.430 --> 00:10:30.430
of the I/O scheduler
application from last year?

00:10:30.430 --> 00:10:31.359
Round of applause?

00:10:31.359 --> 00:10:31.858
Yeah?

00:10:31.858 --> 00:10:32.794
[APPLAUSE]

00:10:32.794 --> 00:10:33.730
Good.

00:10:33.730 --> 00:10:36.660
Did anyone find the hidden
Easter egg in the source code?

00:10:36.660 --> 00:10:37.246
No?

00:10:37.246 --> 00:10:37.920
Oh.

00:10:37.920 --> 00:10:39.295
Then forget I said anything.

00:10:39.295 --> 00:10:41.470
[LAUGHTER]

00:10:41.470 --> 00:10:43.760
So when we open up this file,
there's a lot of assets.

00:10:43.760 --> 00:10:45.426
Now, there's two
things to compare here.

00:10:45.426 --> 00:10:48.324
Of course, first is the
source code files in GitHub,

00:10:48.324 --> 00:10:50.240
and then there's the APK
that you can actually

00:10:50.240 --> 00:10:51.910
download from the Play
Store, unzip, and take

00:10:51.910 --> 00:10:53.120
a look at the assets, right?

00:10:53.120 --> 00:10:54.970
So I wanted to look
between these two,

00:10:54.970 --> 00:10:57.090
because if AAPT is
doing a great job,

00:10:57.090 --> 00:11:00.040
I should see a big change
between those two file sizes,

00:11:00.040 --> 00:11:00.540
right?

00:11:00.540 --> 00:11:01.740
So I opened up the
file, and I just

00:11:01.740 --> 00:11:02.926
picked some random graphic.

00:11:02.926 --> 00:11:04.550
This was the one I
happened to look at.

00:11:04.550 --> 00:11:08.250
That's a 144 x 140
pixel PNG file.

00:11:08.250 --> 00:11:10.630
And that's 6k.

00:11:10.630 --> 00:11:14.580
That's huge, right?

00:11:14.580 --> 00:11:16.540
Sorry, this is in the
source code repo, right?

00:11:16.540 --> 00:11:18.623
Now, when I open up the
APK and take a look at it,

00:11:18.623 --> 00:11:24.120
it's actually only 2k, which is
better, but still way too big

00:11:24.120 --> 00:11:25.940
for 144 x 144 pixels.

00:11:25.940 --> 00:11:28.870
Like that's massively
huge, right?

00:11:28.870 --> 00:11:32.500
And so I said, well, hold
on, something's missing here.

00:11:32.500 --> 00:11:34.145
Obviously, we've got
some optimization.

00:11:34.145 --> 00:11:35.520
Let's figure out
what's going on.

00:11:35.520 --> 00:11:37.360
So I opened up this
image in Photoshop,

00:11:37.360 --> 00:11:38.715
and I saved it for the web.

00:11:38.715 --> 00:11:40.090
There's a difference
between file

00:11:40.090 --> 00:11:42.360
save and file save for web.

00:11:42.360 --> 00:11:44.190
There's a whole different
process in there.

00:11:44.190 --> 00:11:45.860
In that process, I
actually quantized

00:11:45.860 --> 00:11:48.071
it to only use 256 colors.

00:11:48.071 --> 00:11:49.570
And you can see,
when I did that, we

00:11:49.570 --> 00:11:52.560
got about the same
size as was in the APK.

00:11:52.560 --> 00:11:55.660
So we can see that, hey,
the AAPT did its job.

00:11:55.660 --> 00:11:58.910
It probably quantized this
to an indexed image, right?

00:11:58.910 --> 00:12:00.710
But here's the problem.

00:12:00.710 --> 00:12:01.950
Take a look at that image.

00:12:01.950 --> 00:12:04.980
Does it look like
it's using 256 colors?

00:12:04.980 --> 00:12:05.580
No.

00:12:05.580 --> 00:12:07.400
So let's crank it
down a little bit.

00:12:07.400 --> 00:12:08.970
Here's what 64
colors looks like.

00:12:08.970 --> 00:12:10.840
Anybody see a change?

00:12:10.840 --> 00:12:13.470
Let's go even more-- 16 colors.

00:12:13.470 --> 00:12:15.210
Still don't see a change.

00:12:15.210 --> 00:12:18.460
Eight colors, still
don't see a change.

00:12:18.460 --> 00:12:21.470
Or if you do, your eyes
are better than mine.

00:12:21.470 --> 00:12:23.940
The point here is that we
went from 256 unique colors

00:12:23.940 --> 00:12:25.780
down to eight unique
colors and didn't see

00:12:25.780 --> 00:12:27.430
a change in visual perception.

00:12:27.430 --> 00:12:31.310
The difference in file size
though, was huge, right?

00:12:31.310 --> 00:12:35.210
Because we were able to
find a smaller color size.

00:12:35.210 --> 00:12:38.270
So let's look at a
different example here.

00:12:38.270 --> 00:12:40.460
So this is one of
the big banner images

00:12:40.460 --> 00:12:42.150
that you see inside
of the application.

00:12:42.150 --> 00:12:47.580
That's 49.5k in the GitHub
repo, and 32k inside of the APK.

00:12:47.580 --> 00:12:51.670
So again, there's some smaller
modifications going on here

00:12:51.670 --> 00:12:54.980
to the AAPT tool, but still,
let's see if our trick

00:12:54.980 --> 00:12:56.240
works here too, right?

00:12:56.240 --> 00:12:59.660
So let's actually
down-res it to 32 colors.

00:12:59.660 --> 00:13:01.740
This one isn't that good, right?

00:13:01.740 --> 00:13:04.612
I mean, you can see some
banding in the gradients there.

00:13:04.612 --> 00:13:06.070
You can see that
some of the colors

00:13:06.070 --> 00:13:08.280
just aren't looking
as true as you can.

00:13:08.280 --> 00:13:11.440
So let's bump that up
to exactly 256 colors.

00:13:11.440 --> 00:13:15.039
Here you can't actually see
any visual difference, right?

00:13:15.039 --> 00:13:16.830
But notice the difference
in the file size.

00:13:16.830 --> 00:13:20.420
This is only 18k, instead
of the 36k, right?

00:13:20.420 --> 00:13:24.000
So this image actually
only needed 256 colors,

00:13:24.000 --> 00:13:25.990
but maybe the source
image didn't have that.

00:13:25.990 --> 00:13:28.700
And this is the problem
with the AAPT tool.

00:13:28.700 --> 00:13:31.980
It does a great job of
those exact three things,

00:13:31.980 --> 00:13:33.140
and no more than that.

00:13:33.140 --> 00:13:34.800
So in the first
case, we had an image

00:13:34.800 --> 00:13:37.262
that obviously
needed less colors

00:13:37.262 --> 00:13:38.720
and could have been
optimized more.

00:13:38.720 --> 00:13:40.460
And in the second
case, we had an image

00:13:40.460 --> 00:13:43.790
that had maybe just
over 256 colors

00:13:43.790 --> 00:13:47.021
that, if we set it to 256, it
still would have looked fine.

00:13:47.021 --> 00:13:47.520
Right?

00:13:47.520 --> 00:13:49.790
AAPT does neither
of these for you,

00:13:49.790 --> 00:13:52.380
which means that it's
your job, as a developer,

00:13:52.380 --> 00:13:54.080
to step past that
and start doing

00:13:54.080 --> 00:13:57.970
additional methods to reduce
the size of your PNG files.

00:13:57.970 --> 00:14:00.070
So let's take a look,
as I said before,

00:14:00.070 --> 00:14:02.330
how easy it is to mess this up.

00:14:02.330 --> 00:14:08.270
So you actually just take a 16
pixel x 16 pixel all red PNG

00:14:08.270 --> 00:14:12.840
file, File, Save As from
Photoshop, you look at 2k.

00:14:12.840 --> 00:14:17.599
That's 64 pixels, that 2k.

00:14:17.599 --> 00:14:19.140
The funny thing
right now is everyone

00:14:19.140 --> 00:14:21.348
in the room is doing a gut
check about whether or not

00:14:21.348 --> 00:14:24.060
their designers are using
File, Save As from Photoshop

00:14:24.060 --> 00:14:26.050
to save their PNGs, right?

00:14:26.050 --> 00:14:27.419
Right? [CHUCKLES]

00:14:27.419 --> 00:14:28.960
When you save it
for web, though, you

00:14:28.960 --> 00:14:30.760
end up at 121 bytes,
which is better,

00:14:30.760 --> 00:14:31.930
which is obviously better.

00:14:31.930 --> 00:14:33.263
That's the thing we want to see.

00:14:33.263 --> 00:14:36.466
This is how easy it is
to mess up this problem.

00:14:36.466 --> 00:14:38.090
Now, the good news
is, though, that you

00:14:38.090 --> 00:14:40.247
don't have to go into
crazy town with trying

00:14:40.247 --> 00:14:41.830
to optimize all those
things we talked

00:14:41.830 --> 00:14:44.200
about before with the
different stages of PNG.

00:14:44.200 --> 00:14:48.650
PNG optimization is an old
problem, old meaning the 90s,

00:14:48.650 --> 00:14:49.150
right?

00:14:49.150 --> 00:14:52.350
I mean, some of you were
alive in the 90s, right?

00:14:52.350 --> 00:14:52.850
[APPLAUSE]

00:14:52.850 --> 00:14:53.349
OK.

00:14:53.349 --> 00:14:54.430
Yeah.

00:14:54.430 --> 00:14:57.350
Who wasn't alive in the 90s?

00:14:57.350 --> 00:14:57.860
OK.

00:14:57.860 --> 00:14:58.470
All right.

00:14:58.470 --> 00:14:59.620
Yeah.

00:14:59.620 --> 00:15:00.170
Old people.

00:15:00.170 --> 00:15:00.944
Nice.

00:15:00.944 --> 00:15:01.840
[LAUGHTER]

00:15:01.840 --> 00:15:03.720
Sorry-- professional people.

00:15:03.720 --> 00:15:04.780
Yeah.

00:15:04.780 --> 00:15:07.354
The truth is that there is a
plethora, a plethora of tools

00:15:07.354 --> 00:15:10.020
out there that have already been
solving this problem for almost

00:15:10.020 --> 00:15:10.870
two decades.

00:15:10.870 --> 00:15:13.530
You don't got to do the heavy
lifting, just Google it,

00:15:13.530 --> 00:15:15.330
and pick any one of these.

00:15:15.330 --> 00:15:15.830
Really.

00:15:15.830 --> 00:15:17.350
They all do different
stuff, and have

00:15:17.350 --> 00:15:18.720
different algorithms,
and different needs,

00:15:18.720 --> 00:15:20.219
and different
settings, and whatnot.

00:15:20.219 --> 00:15:22.880
But if you just add any one of
these to your existing asset

00:15:22.880 --> 00:15:25.060
chain, you're going to
get an immediate reduction

00:15:25.060 --> 00:15:27.200
and an immediate
improvement in file size.

00:15:27.200 --> 00:15:29.710
Now, that being said,
there are some things

00:15:29.710 --> 00:15:33.810
that you can do to make it even
better in terms of file sizes.

00:15:33.810 --> 00:15:36.210
And I only mention
these two things

00:15:36.210 --> 00:15:38.767
because I'm seeing them
a lot in applications

00:15:38.767 --> 00:15:40.350
that I'm opening and
taking a look at.

00:15:40.350 --> 00:15:42.600
AKA here's the
things you are all

00:15:42.600 --> 00:15:45.680
doing that you need to stop.

00:15:45.680 --> 00:15:49.110
So first off is, if you
can, in every single way,

00:15:49.110 --> 00:15:55.430
try, try, try to make your
image 256 colors or less.

00:15:55.430 --> 00:15:57.572
It's a pretty simple
quantization step.

00:15:57.572 --> 00:15:58.280
You just test it.

00:15:58.280 --> 00:15:59.010
You take a look at it.

00:15:59.010 --> 00:16:00.384
Here is one of
our Google doodles

00:16:00.384 --> 00:16:02.390
that we actually put
on our main page here.

00:16:02.390 --> 00:16:05.020
You can see, it came down
as 24 bits per pixel.

00:16:05.020 --> 00:16:07.710
It wasn't indexed at 197k.

00:16:07.710 --> 00:16:11.100
When we exported it at the
index mode, it was only 73k.

00:16:11.100 --> 00:16:14.790
Again, visual difference
here, imperceptible.

00:16:14.790 --> 00:16:16.960
But the difference in
file size was huge,

00:16:16.960 --> 00:16:21.020
just by trying to take into
account hitting that index

00:16:21.020 --> 00:16:22.220
mark.

00:16:22.220 --> 00:16:24.720
And you can see, the palette
here is actually pretty simple.

00:16:24.720 --> 00:16:25.940
I mean, there's
nothing crazy going on.

00:16:25.940 --> 00:16:28.500
By the way, that diamond down
there on that white actually

00:16:28.500 --> 00:16:31.652
represents the transparent
pixel color for that.

00:16:31.652 --> 00:16:33.360
And you can actually
do a bunch of those.

00:16:33.360 --> 00:16:34.068
Read the article.

00:16:34.068 --> 00:16:35.640
There's more stuff
on that there.

00:16:35.640 --> 00:16:36.920
Here's another one.

00:16:36.920 --> 00:16:39.860
Can anybody tell me
why one of these images

00:16:39.860 --> 00:16:42.954
is 139 and one of these is 214?

00:16:42.954 --> 00:16:43.954
AUDIENCE: Alpha channel.

00:16:43.954 --> 00:16:45.120
COLT MCANLIS: Alpha channel.

00:16:45.120 --> 00:16:45.720
Good.

00:16:45.720 --> 00:16:46.928
What about the alpha channel?

00:16:46.928 --> 00:16:48.240
AUDIENCE: One of them's white.

00:16:48.240 --> 00:16:49.550
COLT MCANLIS: Wait, did
you read the article?

00:16:49.550 --> 00:16:50.049
Oh, wait.

00:16:50.049 --> 00:16:50.984
Nevermind.

00:16:50.984 --> 00:16:51.790
Cheater.

00:16:51.790 --> 00:16:53.882
No, I'm kidding. [LAUGHS]

00:16:53.882 --> 00:16:55.590
So it's absolutely
right-- alpha channel.

00:16:55.590 --> 00:16:56.890
So here's what's happening.

00:16:56.890 --> 00:16:59.890
I've seen this quite a bit in
a lot of the files I've opened.

00:16:59.890 --> 00:17:03.450
So visually, you can
see that the last frame

00:17:03.450 --> 00:17:04.770
is what the user sees here.

00:17:04.770 --> 00:17:06.895
But when you open this
thing up and you take a look

00:17:06.895 --> 00:17:09.089
at the RGB channels and
the A channels separately,

00:17:09.089 --> 00:17:10.540
you can see that
the RGB actually

00:17:10.540 --> 00:17:14.140
has a ton of data that gets
masked out by the alpha value.

00:17:14.140 --> 00:17:17.859
The end result is the same
visual image to the user.

00:17:17.859 --> 00:17:20.319
But to the compressor,
we still have

00:17:20.319 --> 00:17:23.420
to compress all
of that RGB data.

00:17:23.420 --> 00:17:25.420
The filtering stage still
has to be run on it.

00:17:25.420 --> 00:17:26.530
The output of that
still has to be run

00:17:26.530 --> 00:17:27.829
through a deflate algorithm.

00:17:27.829 --> 00:17:30.540
And because there's a lot
of non-uniform pixels there,

00:17:30.540 --> 00:17:33.040
the result is going to be a lot
of bloat in your compressor,

00:17:33.040 --> 00:17:33.540
right?

00:17:33.540 --> 00:17:35.530
However, if we try to
pre-multiply this stuff

00:17:35.530 --> 00:17:37.120
and mask out the
pixels that we know

00:17:37.120 --> 00:17:39.100
are never going to
be seen, we end up

00:17:39.100 --> 00:17:40.900
with a much smaller file size.

00:17:40.900 --> 00:17:43.480
I have been seeing this in
applications popping up lately

00:17:43.480 --> 00:17:45.940
a lot more than I'd like to say.

00:17:45.940 --> 00:17:48.699
So take a look at this.

00:17:48.699 --> 00:17:50.740
Now, one of the final
things I need to point out.

00:17:50.740 --> 00:17:52.281
If you're going to
go down this path,

00:17:52.281 --> 00:17:55.249
and you're going to add in some
of these awesome pre-processing

00:17:55.249 --> 00:17:57.540
tools to your chain and get
it all working with Gradle,

00:17:57.540 --> 00:17:58.870
and you're going tell
your designers to not

00:17:58.870 --> 00:18:01.245
do that thing I just said,
and try to make indexed files,

00:18:01.245 --> 00:18:03.144
you may run into a
really weird issue.

00:18:03.144 --> 00:18:04.810
So let's say we've
got this great image.

00:18:04.810 --> 00:18:06.260
It's about 216k.

00:18:06.260 --> 00:18:09.070
And we actually run
it through Zopfli PNG,

00:18:09.070 --> 00:18:11.810
which is a fantastic
open source tool that

00:18:11.810 --> 00:18:15.200
is a better deflate algorithm
compressor for PNG files.

00:18:15.200 --> 00:18:17.400
And we get it down
to about 185k.

00:18:17.400 --> 00:18:20.180
But when you build it, it
actually goes through AAPT,

00:18:20.180 --> 00:18:24.090
and it bloats to 201k.

00:18:24.090 --> 00:18:28.050
The reason for this
is that the AAPT tool

00:18:28.050 --> 00:18:30.801
doesn't know that you've
pre-processed your image.

00:18:30.801 --> 00:18:31.300
Right?

00:18:31.300 --> 00:18:33.554
Again, it's only checking
for those three things.

00:18:33.554 --> 00:18:35.220
And so it's going to
look at your image,

00:18:35.220 --> 00:18:38.287
and it's going to try to make
it into A, B, or C format.

00:18:38.287 --> 00:18:40.370
And then it's just going
to save it right to disk.

00:18:40.370 --> 00:18:41.510
The problem with that,
though, is that you

00:18:41.510 --> 00:18:42.676
may have made modifications.

00:18:42.676 --> 00:18:44.580
And obviously, your
version is smaller,

00:18:44.580 --> 00:18:46.210
and their version may not be.

00:18:46.210 --> 00:18:47.980
To get around this
in your application,

00:18:47.980 --> 00:18:50.330
you need to specify
the option Gradle,

00:18:50.330 --> 00:18:52.030
cruncherEnabled equals False.

00:18:52.030 --> 00:18:54.680
This will disable
AAPT optimization

00:18:54.680 --> 00:18:57.190
for all of your PNG files that
are coming though your pipe.

00:18:57.190 --> 00:18:59.477
Now the problem, though,
is that, once you do this,

00:18:59.477 --> 00:19:01.810
it's kind of on you to make
sure that all of your images

00:19:01.810 --> 00:19:02.730
are awesome at that point.

00:19:02.730 --> 00:19:03.230
Right?

00:19:03.230 --> 00:19:05.040
Which you're all going to do?

00:19:05.040 --> 00:19:08.400
[APPLAUSE]

00:19:08.400 --> 00:19:09.090
All right.

00:19:09.090 --> 00:19:10.533
Now the back row.

00:19:10.533 --> 00:19:13.371
[APPLAUSE]

00:19:13.371 --> 00:19:15.794
Now, let's try the
front row again.

00:19:15.794 --> 00:19:17.582
[APPLAUSE]

00:19:17.582 --> 00:19:18.260
That was good.

00:19:18.260 --> 00:19:18.350
That was good.

00:19:18.350 --> 00:19:19.590
I'm sorry, the
front row's winning.

00:19:19.590 --> 00:19:21.012
Back row, you want try again?

00:19:21.012 --> 00:19:22.370
[APPLAUSE AND WHISTLING]

00:19:22.370 --> 00:19:23.264
Oh.

00:19:23.264 --> 00:19:25.052
Oh.

00:19:25.052 --> 00:19:26.410
They added whistling.

00:19:26.410 --> 00:19:27.864
Come on, front row.

00:19:27.864 --> 00:19:28.780
We'll try again later.

00:19:28.780 --> 00:19:29.279
All right.

00:19:29.279 --> 00:19:31.200
The live stream's
getting antsy. [LAUGHS]

00:19:31.200 --> 00:19:31.700
All right.

00:19:31.700 --> 00:19:34.054
So make sure that you actually
set this configuration

00:19:34.054 --> 00:19:36.220
inside of your Gradle file,
so that you don't end up

00:19:36.220 --> 00:19:38.053
actually bloating images
that you've already

00:19:38.053 --> 00:19:39.677
taken the time to compress.

00:19:39.677 --> 00:19:42.010
Now, probably one of the
biggest things that you can do,

00:19:42.010 --> 00:19:44.310
though, in terms of file
savings, is actually

00:19:44.310 --> 00:19:46.670
consider replacing
your PNGs altogether

00:19:46.670 --> 00:19:49.120
with vector drawables instead.

00:19:49.120 --> 00:19:53.110
Now, for those who don't know,
PNG files are raster files.

00:19:53.110 --> 00:19:55.640
They have a big problem in
that you need multiple of them

00:19:55.640 --> 00:19:57.430
in a file to actually
get your images.

00:19:57.430 --> 00:19:59.469
So we need one at
this resolution,

00:19:59.469 --> 00:20:01.760
and one at this resolution,
and one at this resolution.

00:20:01.760 --> 00:20:03.385
Which means, in our
APK, we're actually

00:20:03.385 --> 00:20:06.810
ending up at a 55k footprint to
represent the same visual image

00:20:06.810 --> 00:20:08.110
at different resolutions.

00:20:08.110 --> 00:20:09.390
And there's some tricks
you can play here

00:20:09.390 --> 00:20:11.870
with split APKs, and upsampling,
and all this other stuff,

00:20:11.870 --> 00:20:13.570
but this is the
gist of the problem.

00:20:13.570 --> 00:20:15.390
There's another way to
approach this issue,

00:20:15.390 --> 00:20:18.386
and it's the concept of actually
drawing your images with code.

00:20:18.386 --> 00:20:19.760
So that same
picture-- what if we

00:20:19.760 --> 00:20:21.189
took a stab at it saying this.

00:20:21.189 --> 00:20:22.730
Let's admit a byte
code that actually

00:20:22.730 --> 00:20:24.170
draws a white
background, and then

00:20:24.170 --> 00:20:26.860
another code that actually
draws a red circle.

00:20:26.860 --> 00:20:29.520
Now, if we create our custom
DSL language and whatnot,

00:20:29.520 --> 00:20:32.430
we could actually get this
into one byte per instruction

00:20:32.430 --> 00:20:34.250
and actually end up
at about 15 bytes

00:20:34.250 --> 00:20:36.752
to represent the same thing.

00:20:36.752 --> 00:20:39.210
The result of this is that we
can generate those same three

00:20:39.210 --> 00:20:41.790
images at any of
these three sizes,

00:20:41.790 --> 00:20:43.570
using only 15 bytes
of our scheme,

00:20:43.570 --> 00:20:46.200
instead of the 55k that
we were using before.

00:20:46.200 --> 00:20:49.140
This is the concept of
vector image formats.

00:20:49.140 --> 00:20:49.770
Right?

00:20:49.770 --> 00:20:51.710
Basically, we take
some sort of stream

00:20:51.710 --> 00:20:54.340
that represents how to draw
primitives on a screen,

00:20:54.340 --> 00:20:57.100
we actually execute those,
rasterizing those primitives

00:20:57.100 --> 00:20:58.827
to a bitmap in CPU memory.

00:20:58.827 --> 00:21:00.410
We upload that to
the GPU, and then we

00:21:00.410 --> 00:21:02.370
end up actually drawing
that to the screen.

00:21:02.370 --> 00:21:05.670
The benefit you get here
is much smaller file sizes.

00:21:05.670 --> 00:21:08.340
The downside, though, is
you actually trade off time.

00:21:08.340 --> 00:21:10.710
It takes longer to
rasterize these images

00:21:10.710 --> 00:21:13.050
and get them into memory
than it does to actually,

00:21:13.050 --> 00:21:15.720
say, use the hardware
decoder and decode a JPEG.

00:21:15.720 --> 00:21:16.620
So there's a little
bit of a trade-off

00:21:16.620 --> 00:21:17.786
you have to deal with there.

00:21:17.786 --> 00:21:21.180
But this is the whole
idea behind the Android's,

00:21:21.180 --> 00:21:22.500
vector drawable format.

00:21:22.500 --> 00:21:25.990
It's a series of
instructions that

00:21:25.990 --> 00:21:28.350
define how to draw paths,
and colors, and gradients,

00:21:28.350 --> 00:21:30.058
and all other sorts
of stuff, so that you

00:21:30.058 --> 00:21:33.810
can draw these images at the
sizes you need on demand.

00:21:33.810 --> 00:21:36.420
But the question is-- OK,
this is fine, this is fancy,

00:21:36.420 --> 00:21:38.415
I've already got a
pipeline of awesome PNGs

00:21:38.415 --> 00:21:40.010
and my artists know
how to make PNGs.

00:21:40.010 --> 00:21:42.218
They don't know how to do
this vector drawable thing.

00:21:42.218 --> 00:21:44.950
Come on, bald guy, let's
get to the point here.

00:21:44.950 --> 00:21:46.280
What's really going on?

00:21:46.280 --> 00:21:47.010
Don't worry.

00:21:47.010 --> 00:21:48.690
So I decided to run a test.

00:21:48.690 --> 00:21:51.180
How much could vector
drawables actually save me

00:21:51.180 --> 00:21:52.530
as a developer?

00:21:52.530 --> 00:21:54.120
To figure this out,
though, I needed

00:21:54.120 --> 00:21:55.795
to take the I/O
sched application

00:21:55.795 --> 00:21:58.580
and actually convert all of
my images to vector drawables.

00:21:58.580 --> 00:22:00.770
Well, there's 270
of those things,

00:22:00.770 --> 00:22:03.780
totaling up to 926k in size.

00:22:03.780 --> 00:22:06.820
I don't have the time to
hand customize all 270

00:22:06.820 --> 00:22:08.062
of those images.

00:22:08.062 --> 00:22:09.770
Thankfully, there's
a tool to the rescue.

00:22:09.770 --> 00:22:12.040
There's a great tool on the
internet called Potrace.

00:22:12.040 --> 00:22:13.890
And this tool's been
around a long time.

00:22:13.890 --> 00:22:16.240
It'll take a bitmap
image, which is literally

00:22:16.240 --> 00:22:18.890
a image with 1-bit per
pixel, and actually

00:22:18.890 --> 00:22:25.390
turn it into a vector format--
raster image to vector format.

00:22:25.390 --> 00:22:27.920
So I decided to run this on
every asset inside the I/O

00:22:27.920 --> 00:22:28.980
sched application.

00:22:28.980 --> 00:22:31.080
And the results were
actually a lot better

00:22:31.080 --> 00:22:33.244
than I expected, to be
honest with you, right?

00:22:33.244 --> 00:22:35.160
So you can see the top
row here is the source.

00:22:35.160 --> 00:22:36.701
And the bottom row
here is the result

00:22:36.701 --> 00:22:38.400
of the Potrace application.

00:22:38.400 --> 00:22:39.530
We're pretty close.

00:22:39.530 --> 00:22:40.940
The first one looks identical.

00:22:40.940 --> 00:22:42.430
The second one, you
can see some rounding.

00:22:42.430 --> 00:22:43.650
The third one, pretty good.

00:22:43.650 --> 00:22:46.210
The fourth one, you can see that
we're only dealing with shapes,

00:22:46.210 --> 00:22:47.376
so we lose some color there.

00:22:47.376 --> 00:22:48.630
And the hexagon is perfect.

00:22:48.630 --> 00:22:50.840
The hexagon is actually a
really cool example here,

00:22:50.840 --> 00:22:55.190
because that hexagon actually
absorbed 6k of our file size

00:22:55.190 --> 00:22:56.350
at different resolutions.

00:22:56.350 --> 00:23:01.420
However, the vector
version was only 961 bytes.

00:23:01.420 --> 00:23:04.330
So even just running it
through here, we saw some wins.

00:23:04.330 --> 00:23:06.700
The downside, though, is that
this is an automated tool.

00:23:06.700 --> 00:23:07.200
Right?

00:23:07.200 --> 00:23:08.130
I mean, this is only a test.

00:23:08.130 --> 00:23:09.020
We're just trying
to figure out how

00:23:09.020 --> 00:23:09.970
all this stuff works together.

00:23:09.970 --> 00:23:11.710
And obviously, there
were some failures.

00:23:11.710 --> 00:23:13.710
We missed some
interspersion detail.

00:23:13.710 --> 00:23:16.190
Obviously, we're not getting
the exact font representation.

00:23:16.190 --> 00:23:18.417
And it just fell over and
died on the I/O algorithm.

00:23:18.417 --> 00:23:19.610
Right?

00:23:19.610 --> 00:23:22.540
The result, though, I
think, was a good test

00:23:22.540 --> 00:23:24.450
to figure out what
you could save.

00:23:24.450 --> 00:23:26.220
So running things
through Potrace,

00:23:26.220 --> 00:23:28.820
we actually ended up
with only 153 files,

00:23:28.820 --> 00:23:31.960
because we didn't have to
have one for each resolution.

00:23:31.960 --> 00:23:34.620
And the result
was actually 149k.

00:23:34.620 --> 00:23:37.770
That's 84% reduction
in asset sizes,

00:23:37.770 --> 00:23:41.160
by just moving everything to
be a vector drawable, which

00:23:41.160 --> 00:23:42.980
is a pretty good savings.

00:23:42.980 --> 00:23:43.480
Yes.

00:23:43.480 --> 00:23:44.030
Let's clap.

00:23:44.030 --> 00:23:44.310
Yes.

00:23:44.310 --> 00:23:44.810
[APPLAUSE]

00:23:44.810 --> 00:23:45.600
This man.

00:23:45.600 --> 00:23:47.347
Yes.

00:23:47.347 --> 00:23:48.430
You started the clap, sir.

00:23:48.430 --> 00:23:49.562
You are awesome.

00:23:49.562 --> 00:23:50.190
Fantastic.

00:23:50.190 --> 00:23:50.690
Yeah.

00:23:50.690 --> 00:23:53.137
So 84% smaller, that's a
pretty good deal, right?

00:23:53.137 --> 00:23:54.970
Now, it's worth noting
this was just a test.

00:23:54.970 --> 00:23:58.140
You can't just go run Potrace
and convert everything over.

00:23:58.140 --> 00:24:00.790
I mean, it spits out EPS
files, and that's not the same

00:24:00.790 --> 00:24:01.291
as VD files.

00:24:01.291 --> 00:24:03.165
And oh, by the way,
there's actually a chance

00:24:03.165 --> 00:24:04.890
that you could
optimize stuff further.

00:24:04.890 --> 00:24:07.500
Instead of just importing from
SVG, if you did stuff by hand,

00:24:07.500 --> 00:24:09.041
you may actually be
able to get stuff

00:24:09.041 --> 00:24:10.366
down even smaller than that.

00:24:10.366 --> 00:24:12.490
But the main point is, you
can get a lot of savings

00:24:12.490 --> 00:24:14.450
here by moving to
vector drawables,

00:24:14.450 --> 00:24:17.390
so make sure you
take a look at it.

00:24:17.390 --> 00:24:20.390
Now, let's talk about the big
images, the big, big images,

00:24:20.390 --> 00:24:21.560
JPEGs.

00:24:21.560 --> 00:24:22.500
Who loves JPEGs?

00:24:22.500 --> 00:24:23.428
[APPLAUSE]

00:24:23.428 --> 00:24:25.251
Yeah?

00:24:25.251 --> 00:24:25.750
Yep.

00:24:25.750 --> 00:24:27.166
I didn't hear
anybody in the back.

00:24:27.166 --> 00:24:30.615
[APPLAUSE]

00:24:30.615 --> 00:24:32.546
[LAUGHS] I love the
begrudging pause.

00:24:32.546 --> 00:24:33.046
Right?

00:24:33.046 --> 00:24:34.002
Like, ugh.

00:24:34.002 --> 00:24:35.440
Fine.

00:24:35.440 --> 00:24:37.903
We're just here to stay
out of the heat. [LAUGHS]

00:24:37.903 --> 00:24:39.350
[LAUGHTER]

00:24:39.350 --> 00:24:40.215
Pass me some water.

00:24:40.215 --> 00:24:41.480
This is great.

00:24:41.480 --> 00:24:43.750
OK, JPEG files--
I've got to tell you,

00:24:43.750 --> 00:24:47.500
JPEGS are-- they're crazy.

00:24:47.500 --> 00:24:52.330
One of the most impressive
algorithmic systems I've

00:24:52.330 --> 00:24:54.040
ever encountered.

00:24:54.040 --> 00:24:57.730
It's impressive the math
that goes into this, not just

00:24:57.730 --> 00:24:59.360
from an algorithm
perspective, but just

00:24:59.360 --> 00:25:02.017
the raw math of the situation.

00:25:02.017 --> 00:25:02.850
Take a look at this.

00:25:02.850 --> 00:25:05.500
So when you encode a JPEG,
here's what's going on.

00:25:05.500 --> 00:25:07.094
You take your source RGB image.

00:25:07.094 --> 00:25:09.510
And the first thing that happens
is we actually convert it

00:25:09.510 --> 00:25:11.190
to a separate color space.

00:25:11.190 --> 00:25:13.480
The reason for this
is the human eye,

00:25:13.480 --> 00:25:16.120
the psycho-visual
differences in the human eye

00:25:16.120 --> 00:25:20.690
are less susceptible
to the YCBCR color

00:25:20.690 --> 00:25:23.040
space, or the chroma
luminance color space.

00:25:23.040 --> 00:25:23.554
Right?

00:25:23.554 --> 00:25:25.845
We're actually more tuned--
the human eye is more tuned

00:25:25.845 --> 00:25:29.140
to see differences in
RGBs, than we are YCBCR,

00:25:29.140 --> 00:25:32.940
so the first thing the JPEG does
is convert it to that space.

00:25:32.940 --> 00:25:34.620
The next thing is
we actually reduce

00:25:34.620 --> 00:25:38.240
the size of the CB, the chroma
channels, CB and CR channels.

00:25:38.240 --> 00:25:39.900
Again, the human
eye doesn't notice

00:25:39.900 --> 00:25:41.680
as much changes
in that spectrum,

00:25:41.680 --> 00:25:43.175
so it doesn't worry about it.

00:25:43.175 --> 00:25:45.550
After that, we actually go
through and block up our image

00:25:45.550 --> 00:25:48.850
and apply the discrete
cosine transform.

00:25:48.850 --> 00:25:51.710
This is magical.

00:25:51.710 --> 00:25:54.270
If you get a chance to check
out the blog post on this,

00:25:54.270 --> 00:25:57.370
basically, the idea of the
discrete cosine transform

00:25:57.370 --> 00:25:59.800
is that any signal
can be represented

00:25:59.800 --> 00:26:03.500
by a sum of cosines.

00:26:03.500 --> 00:26:04.830
What?

00:26:04.830 --> 00:26:06.070
It's a thing.

00:26:06.070 --> 00:26:06.690
It's a thing.

00:26:06.690 --> 00:26:08.940
Like these mathematicians
sat down and worked that out

00:26:08.940 --> 00:26:10.880
on paper, before
computers were awesome.

00:26:10.880 --> 00:26:12.890
Like, discrete
cosine transform is

00:26:12.890 --> 00:26:15.240
one of the most amazing
things I have ever seen.

00:26:15.240 --> 00:26:18.290
Basically, they can represent
any 8 x 8 block of pixels

00:26:18.290 --> 00:26:21.470
by summing cosine transforms
across a 2D space.

00:26:21.470 --> 00:26:23.520
That is awesome, right?

00:26:23.520 --> 00:26:26.129
The output of that is then
ran into a quantization phase.

00:26:26.129 --> 00:26:27.920
The quantization phase
just basically takes

00:26:27.920 --> 00:26:29.420
the output of the
basis coefficients

00:26:29.420 --> 00:26:31.470
and quantizes them down
to integers in a subspace

00:26:31.470 --> 00:26:32.500
that we can actually
encode more.

00:26:32.500 --> 00:26:34.583
Then it gets sent out to
this statistical encoding

00:26:34.583 --> 00:26:37.520
phase, which may be
Huffman, or arithmetic,

00:26:37.520 --> 00:26:39.940
or whatever your particular
flavor of the month is.

00:26:39.940 --> 00:26:43.150
And then finally, of course,
we go to the output JPEG file.

00:26:43.150 --> 00:26:44.690
Now, here's the weird thing.

00:26:44.690 --> 00:26:46.640
This is awesome.

00:26:46.640 --> 00:26:48.730
This is totally crazy, right?

00:26:48.730 --> 00:26:50.900
Way harder than PNG.

00:26:50.900 --> 00:26:52.530
Then why, when you
export an image,

00:26:52.530 --> 00:26:54.020
you're given like one slider?

00:26:54.020 --> 00:26:57.620
[LAUGHTER]

00:26:57.620 --> 00:27:00.450
All of this chaos is
hidden behind one slider

00:27:00.450 --> 00:27:02.460
when you export an image.

00:27:02.460 --> 00:27:04.320
That's impressive
on its own right.

00:27:04.320 --> 00:27:06.320
Now, the question is,
what should this value be?

00:27:06.320 --> 00:27:07.500
This is the JPEG quality.

00:27:07.500 --> 00:27:09.290
When you export a
JPEG, we ask you

00:27:09.290 --> 00:27:11.534
what quality you want
it outputted at, right?

00:27:11.534 --> 00:27:13.200
So the question is,
what should this be?

00:27:13.200 --> 00:27:13.700
Right?

00:27:13.700 --> 00:27:16.470
So let's take a visual look at
what Photoshop would actually

00:27:16.470 --> 00:27:17.310
output as.

00:27:17.310 --> 00:27:20.910
So here's PS12, so this it
would be 100% JPEG quality.

00:27:20.910 --> 00:27:21.580
Right?

00:27:21.580 --> 00:27:22.960
263k.

00:27:22.960 --> 00:27:28.224
Let's drop down to
11, 10, go to 8.

00:27:28.224 --> 00:27:29.890
You can start seeing
some blocking here.

00:27:29.890 --> 00:27:32.257
Look right above the
red parrot's head.

00:27:32.257 --> 00:27:34.090
You can start seeing
some ringing artifacts.

00:27:34.090 --> 00:27:36.440
The gradients in the background
aren't as solid there.

00:27:36.440 --> 00:27:39.180
Let's go down to 4.

00:27:39.180 --> 00:27:40.370
So this is quality 4.

00:27:40.370 --> 00:27:42.120
You see a lot more
ringing artifacts here.

00:27:42.120 --> 00:27:42.750
Right?

00:27:42.750 --> 00:27:45.010
You can start seeing the
quantization artifacts

00:27:45.010 --> 00:27:46.830
in each 8 x 8 block, right?

00:27:46.830 --> 00:27:48.220
And zero.

00:27:48.220 --> 00:27:49.940
Obviously, some color
bleeding going on.

00:27:49.940 --> 00:27:51.470
We're seeing some
big stuff there.

00:27:51.470 --> 00:27:55.430
So the question is, though,
what value should I choose?

00:27:55.430 --> 00:27:55.930
Right?

00:27:55.930 --> 00:27:57.639
I mean, you can't open
every single image

00:27:57.639 --> 00:27:59.679
and take a look at it and
choose the right value.

00:27:59.679 --> 00:28:01.370
There's just no way
we can support that

00:28:01.370 --> 00:28:04.300
in any sort of real pipeline.

00:28:04.300 --> 00:28:07.360
The solution is to not, it's
to automate the whole process.

00:28:07.360 --> 00:28:10.322
And for that-- I'll get
to it in another slide.

00:28:10.322 --> 00:28:13.640
[LAUGHS] The real solution here
is to automate this process

00:28:13.640 --> 00:28:14.390
and figure it out.

00:28:14.390 --> 00:28:15.950
But that's actually not
what most people are doing.

00:28:15.950 --> 00:28:17.690
What most people are
actually doing here,

00:28:17.690 --> 00:28:20.600
is choosing some value and
exporting all of their images

00:28:20.600 --> 00:28:21.150
at that.

00:28:21.150 --> 00:28:23.067
The ImgMin project,
which is an open source

00:28:23.067 --> 00:28:25.650
project on the internet, started
downloading a bunch of images

00:28:25.650 --> 00:28:27.024
from all of these
social networks

00:28:27.024 --> 00:28:29.800
and figuring out what their
exported quality was, and then

00:28:29.800 --> 00:28:31.240
put it together in a table.

00:28:31.240 --> 00:28:33.720
So you can actually see what
everyone is exporting things

00:28:33.720 --> 00:28:34.270
at.

00:28:34.270 --> 00:28:36.780
Now, the ones with ranges are
actually really impressive,

00:28:36.780 --> 00:28:39.300
because it means that they're
trying to actually find

00:28:39.300 --> 00:28:40.440
the right range of things.

00:28:40.440 --> 00:28:42.732
The weird thing is it's not
as scalable as you'd think.

00:28:42.732 --> 00:28:43.231
Right?

00:28:43.231 --> 00:28:45.150
Like if something
happens to be brighter,

00:28:45.150 --> 00:28:46.150
it's given these values.

00:28:46.150 --> 00:28:47.566
If it's darker,
it's these values.

00:28:47.566 --> 00:28:49.560
It's a little bit more
quantized than dynamic.

00:28:49.560 --> 00:28:50.934
But the question
for your project

00:28:50.934 --> 00:28:53.500
is, how do we figure
this out algorithmically?

00:28:53.500 --> 00:28:56.560
And for that, I want to
introduce Butteraugli.

00:28:56.560 --> 00:28:59.160
This is an open source project
made by the compression

00:28:59.160 --> 00:29:01.550
team in Zurich who
loves naming things so

00:29:01.550 --> 00:29:03.263
that I can't Google for them.

00:29:03.263 --> 00:29:04.030
[LAUGHTER]

00:29:04.030 --> 00:29:05.630
--or spell them
or pronounce them.

00:29:05.630 --> 00:29:07.220
So to make sure that you
all can pronounce it,

00:29:07.220 --> 00:29:08.890
we're going to say
it together here, OK?

00:29:08.890 --> 00:29:09.931
This is going to be boo--

00:29:09.931 --> 00:29:10.912
AUDIENCE: Boo--

00:29:10.912 --> 00:29:11.705
COLT MCANLIS: Ter--

00:29:11.705 --> 00:29:12.526
AUDIENCE: Ter--

00:29:12.526 --> 00:29:13.378
COLT MCANLIS: Aug--

00:29:13.378 --> 00:29:14.230
AUDIENCE: Aug--

00:29:14.230 --> 00:29:14.580
COLT MCANLIS: Lee--

00:29:14.580 --> 00:29:15.245
AUDIENCE: Lee.

00:29:15.245 --> 00:29:16.328
COLT MCANLIS: Butteraugli.

00:29:16.328 --> 00:29:17.442
AUDIENCE: Butteraugli.

00:29:17.442 --> 00:29:18.150
COLT MCANLIS: OK.

00:29:18.150 --> 00:29:19.940
Now, you all can
Google this later.

00:29:19.940 --> 00:29:22.380
In the native language,
it means a sweet bread

00:29:22.380 --> 00:29:23.240
to eat with coffee.

00:29:23.240 --> 00:29:25.850
But in the GitHub
project, it means a way

00:29:25.850 --> 00:29:29.900
to compare the psycho-visual
similarity of two images.

00:29:29.900 --> 00:29:32.030
This is basically a
way for us to say,

00:29:32.030 --> 00:29:34.750
let me take a source
image and compress it

00:29:34.750 --> 00:29:37.530
and see how the human eye
responds to the differences

00:29:37.530 --> 00:29:38.280
between these two.

00:29:38.280 --> 00:29:40.482
How much error can
we actually notice?

00:29:40.482 --> 00:29:42.690
Now, you may have heard some
other terms in the past,

00:29:42.690 --> 00:29:44.154
like PSNR.

00:29:44.154 --> 00:29:45.070
Anybody hear that one?

00:29:45.070 --> 00:29:45.970
Yeah?

00:29:45.970 --> 00:29:46.470
SSIM?

00:29:46.470 --> 00:29:46.970
Yeah?

00:29:46.970 --> 00:29:47.680
These are common.

00:29:47.680 --> 00:29:48.180
Yeah?

00:29:48.180 --> 00:29:48.610
Nice.

00:29:48.610 --> 00:29:49.818
These are very common things.

00:29:49.818 --> 00:29:52.020
Think of Butteraugli in
the same fashion of that,

00:29:52.020 --> 00:29:55.490
the ability to measure two
different psycho-visual changes

00:29:55.490 --> 00:29:57.480
as an image changes.

00:29:57.480 --> 00:30:00.060
Now, the real use
of Butteraugli,

00:30:00.060 --> 00:30:01.760
the intention that
it was made for,

00:30:01.760 --> 00:30:04.890
was to actually
figure out how much we

00:30:04.890 --> 00:30:08.013
can compress an image before
the human eye notices anything.

00:30:08.013 --> 00:30:08.800
Right?

00:30:08.800 --> 00:30:12.210
How far can we go before
even the smallest perceived

00:30:12.210 --> 00:30:13.117
visual change occurs?

00:30:13.117 --> 00:30:15.200
And when you actually use
the Butteraugli library,

00:30:15.200 --> 00:30:17.810
you'll notice that that actually
occurs at the 1.0 level.

00:30:17.810 --> 00:30:20.490
So when you export
at Butteraugli 1.0,

00:30:20.490 --> 00:30:22.660
that is where-- or
when you test it

00:30:22.660 --> 00:30:25.467
and you get 1.0, that is
where the human eye starts

00:30:25.467 --> 00:30:26.300
to notice artifacts.

00:30:26.300 --> 00:30:28.710
Anything above
1.0 is chaos land.

00:30:28.710 --> 00:30:31.411
Anything below 1.0, the
human eye can't decipher.

00:30:31.411 --> 00:30:31.910
Right?

00:30:31.910 --> 00:30:33.520
So your goal would
be like, hey, we

00:30:33.520 --> 00:30:34.770
have a lot of high res images.

00:30:34.770 --> 00:30:37.900
We want high res images, and we
want to find the ideal export.

00:30:37.900 --> 00:30:39.080
This will help you.

00:30:39.080 --> 00:30:42.010
But sometimes, I
don't want perfection.

00:30:42.010 --> 00:30:42.799
Right?

00:30:42.799 --> 00:30:45.090
Sometimes, I want a little
bit of compression artifacts

00:30:45.090 --> 00:30:45.630
in there.

00:30:45.630 --> 00:30:47.990
Sometimes, someone's loading
something on a 2G network,

00:30:47.990 --> 00:30:49.550
or they're sitting on
roaming, or they're

00:30:49.550 --> 00:30:51.716
in the middle of India and
they don't have the right

00:30:51.716 --> 00:30:54.227
connectivity, I want to give
them a worse quality image,

00:30:54.227 --> 00:30:56.560
so it doesn't take them six
hours to download the thing.

00:30:56.560 --> 00:30:57.060
Right?

00:30:57.060 --> 00:30:58.350
They don't have to pay for it.

00:30:58.350 --> 00:31:00.910
So maybe I'm OK going above 1.0.

00:31:00.910 --> 00:31:04.090
So how would we go about
doing something like this?

00:31:04.090 --> 00:31:07.780
How would we find the right
level for some other statistic?

00:31:07.780 --> 00:31:09.030
And it's actually pretty easy.

00:31:09.030 --> 00:31:11.321
If we actually take a little
Python script here and run

00:31:11.321 --> 00:31:14.130
ImageMagick, we can convert
a PNG to a JPEG file

00:31:14.130 --> 00:31:14.860
at some quality.

00:31:14.860 --> 00:31:15.760
Right?

00:31:15.760 --> 00:31:18.430
We convert that
JPEG back to a PNG,

00:31:18.430 --> 00:31:20.640
so we know we're
actually comparing apples

00:31:20.640 --> 00:31:21.580
to apples here.

00:31:21.580 --> 00:31:24.340
And then we run those two PNG
files through Butteraugli.

00:31:24.340 --> 00:31:26.820
And if the score is
above some random metric

00:31:26.820 --> 00:31:29.320
that we've decided, based
upon artificial intelligence

00:31:29.320 --> 00:31:31.700
and machine learning for
this person, in this area,

00:31:31.700 --> 00:31:34.790
on this device-- let's
just say it's 2.0,

00:31:34.790 --> 00:31:37.360
randomly-- then we return
that quality value.

00:31:37.360 --> 00:31:39.280
So what does this look like?

00:31:39.280 --> 00:31:40.810
So I ran this on
the parrots images.

00:31:40.810 --> 00:31:42.710
And you can see,
really quickly, we

00:31:42.710 --> 00:31:46.545
found that, about quality 60,
we passed the 2.0 threshold.

00:31:46.545 --> 00:31:47.700
Right?

00:31:47.700 --> 00:31:50.550
And then, it actually was able
to dive in a little bit more

00:31:50.550 --> 00:31:52.720
and get single-step
quantization.

00:31:52.720 --> 00:31:56.770
Actually found that, at quality
62, we broke the 2.0 threshold.

00:31:56.770 --> 00:31:59.140
Let's look at this side by side.

00:31:59.140 --> 00:32:01.430
This is the 1.0 score
and the 2.0 score.

00:32:01.430 --> 00:32:03.520
The difference is 60k.

00:32:03.520 --> 00:32:04.030
Right?

00:32:04.030 --> 00:32:07.550
But the Butteraugli
image metric is so nice

00:32:07.550 --> 00:32:11.294
that you can see very small
changes in the 2.0 version.

00:32:11.294 --> 00:32:13.960
Of course, this is blown up on a
screen, and on the live stream,

00:32:13.960 --> 00:32:15.080
and all this other stuff.

00:32:15.080 --> 00:32:17.121
But the main point that
I'm trying to get to here

00:32:17.121 --> 00:32:20.930
is that you don't have to
choose one image compression

00:32:20.930 --> 00:32:21.970
quality for everything.

00:32:21.970 --> 00:32:25.560
You can actually dynamically
choose this and move on.

00:32:25.560 --> 00:32:27.930
So beyond that, though,
there's a couple of things

00:32:27.930 --> 00:32:31.040
that you can do by hand.

00:32:31.040 --> 00:32:33.730
JPEG, unfortunately, has the
same problem that PNG does.

00:32:33.730 --> 00:32:34.340
Right?

00:32:34.340 --> 00:32:38.360
File, Save As from
Photoshop, 11k

00:32:38.360 --> 00:32:40.440
for that 16 x 16 pixel block.

00:32:40.440 --> 00:32:41.970
11k!

00:32:41.970 --> 00:32:43.310
Ugh!

00:32:43.310 --> 00:32:45.366
Are you sure your designers
aren't doing that?

00:32:45.366 --> 00:32:46.220
[LAUGHTER]

00:32:46.220 --> 00:32:48.130
Are you really sure?

00:32:48.130 --> 00:32:49.470
Think about it.

00:32:49.470 --> 00:32:51.300
Maybe send a text real quick.

00:32:51.300 --> 00:32:52.270
[LAUGHTER]

00:32:52.270 --> 00:32:53.240
Yeah?

00:32:53.240 --> 00:32:56.030
Save As gets us to 1.1k.

00:32:56.030 --> 00:33:00.760
Still, that's a 16
pixel x 16 pixel image.

00:33:00.760 --> 00:33:03.910
The funny thing is-- you want
to know what's going on here?

00:33:03.910 --> 00:33:06.950
Extra data, Metadata.

00:33:06.950 --> 00:33:09.660
JPEGs and PNGs have the
ability to add block data

00:33:09.660 --> 00:33:10.651
to your image.

00:33:10.651 --> 00:33:12.400
So when I'm standing
on the Google campus,

00:33:12.400 --> 00:33:13.710
wandering around,
because it's Google I/O,

00:33:13.710 --> 00:33:14.980
and I take a picture
of the Gator.

00:33:14.980 --> 00:33:16.480
This is how my image
sharing service

00:33:16.480 --> 00:33:18.292
knows where I was standing.

00:33:18.292 --> 00:33:19.750
There's blocks that
they can insert

00:33:19.750 --> 00:33:21.833
into your JPEG files that
have this location-based

00:33:21.833 --> 00:33:22.780
information.

00:33:22.780 --> 00:33:23.972
And that bloats your image.

00:33:23.972 --> 00:33:25.930
And if you're not properly
removing this stuff,

00:33:25.930 --> 00:33:27.280
as an image serving
application, that

00:33:27.280 --> 00:33:29.590
means every other user who's
downloading it is grabbing

00:33:29.590 --> 00:33:31.350
this extra bloated data.

00:33:31.350 --> 00:33:33.712
Obviously, that's
not a good idea.

00:33:33.712 --> 00:33:35.920
So let's talk about-- that's
obviously block removal,

00:33:35.920 --> 00:33:36.950
but there's a bunch
of other places

00:33:36.950 --> 00:33:38.190
that we can optimize
here, right?

00:33:38.190 --> 00:33:39.731
We can change how
we're downsampling.

00:33:39.731 --> 00:33:43.520
We can improve the way that the
DCT coefficients are handled.

00:33:43.520 --> 00:33:45.114
We can improve the
way we quantize.

00:33:45.114 --> 00:33:47.280
Or we could just apply a
better statistical encoder.

00:33:47.280 --> 00:33:47.860
Right?

00:33:47.860 --> 00:33:48.742
Great news, folks.

00:33:48.742 --> 00:33:50.450
You don't got to worry
about any of that.

00:33:50.450 --> 00:33:52.270
Everybody's already
got it solved.

00:33:52.270 --> 00:33:55.150
Googling for this brings
you a pretty good handful

00:33:55.150 --> 00:33:57.310
of algorithms and tools
that you can put right

00:33:57.310 --> 00:33:58.500
into your tool chain.

00:33:58.500 --> 00:34:00.830
The first two here,
JPEGMini and MozJPEG,

00:34:00.830 --> 00:34:05.210
actually go to find another
lossy compression variant.

00:34:05.210 --> 00:34:07.350
So they'll degrade
the image quality

00:34:07.350 --> 00:34:09.719
of your image to get you
just a little bit farther

00:34:09.719 --> 00:34:11.030
and a little bit more savings.

00:34:11.030 --> 00:34:11.530
Right?

00:34:11.530 --> 00:34:14.449
On the other two, cJPEG
and packJPG are lossless.

00:34:14.449 --> 00:34:16.630
They're going to try to
improve those quantization

00:34:16.630 --> 00:34:19.560
and statistical encoding stages,
so that you don't actually

00:34:19.560 --> 00:34:20.590
lose any bits.

00:34:20.590 --> 00:34:23.030
The interesting thing is that
packJPG actually works more

00:34:23.030 --> 00:34:24.480
as a post format than anything.

00:34:24.480 --> 00:34:26.409
It'll actually take
your JPEG and encode it

00:34:26.409 --> 00:34:28.869
in its own format, so we can
get it even smaller than that.

00:34:28.869 --> 00:34:30.739
And of course, you've got
a lot of web solutions

00:34:30.739 --> 00:34:32.440
that you can find
too where you upload

00:34:32.440 --> 00:34:34.109
your image to some
API or some service,

00:34:34.109 --> 00:34:36.400
it'll do everything on the
back end and send it to you.

00:34:36.400 --> 00:34:38.090
I don't care what you use.

00:34:38.090 --> 00:34:40.110
Pick one, right?

00:34:40.110 --> 00:34:43.440
And don't let your designers
hit Save As from Photoshop.

00:34:43.440 --> 00:34:43.940
Right?

00:34:43.940 --> 00:34:44.930
Any of these will work.

00:34:44.930 --> 00:34:45.429
Pick one.

00:34:45.429 --> 00:34:45.969
Test it out.

00:34:45.969 --> 00:34:46.620
See how it works.

00:34:46.620 --> 00:34:48.495
Send me a tweet, let me
know how it happened.

00:34:48.495 --> 00:34:49.211
Right?

00:34:49.211 --> 00:34:49.960
One thing, though.

00:34:49.960 --> 00:34:51.730
I've got to say, this one's
really cool to do by hand.

00:34:51.730 --> 00:34:52.770
And I've only got
a couple minutes,

00:34:52.770 --> 00:34:54.603
so I'm going to try to
go through this fast.

00:34:54.603 --> 00:34:58.120
Two images here, top
one 175, Colt-modified,

00:34:58.120 --> 00:35:00.000
82k on the bottom.

00:35:00.000 --> 00:35:03.080
What we're doing here-- remember
that the first thing that JPEG

00:35:03.080 --> 00:35:05.980
does is split your image
into a different color space,

00:35:05.980 --> 00:35:08.230
because the human eye is
more perceptible to some loss

00:35:08.230 --> 00:35:09.140
than others.

00:35:09.140 --> 00:35:11.560
So what we do here is, we
actually, in Photoshop, split

00:35:11.560 --> 00:35:12.710
this to LAB color mode.

00:35:12.710 --> 00:35:13.210
Right?

00:35:13.210 --> 00:35:14.910
Which is luminance
and then AB channels.

00:35:14.910 --> 00:35:17.440
We select the areas of high
contrast inside of the AB

00:35:17.440 --> 00:35:20.726
channels, and we actually
just go File Blur.

00:35:20.726 --> 00:35:22.350
What we're doing here
is we're actually

00:35:22.350 --> 00:35:26.250
reducing the number of unique
colors, the amount of noise

00:35:26.250 --> 00:35:31.380
in these chroma channels, so
that when the JPEG codec comes

00:35:31.380 --> 00:35:33.510
back through, there's
less information there

00:35:33.510 --> 00:35:34.720
that it has to find unique.

00:35:34.720 --> 00:35:36.820
And you're actually going to get
better compression as a result.

00:35:36.820 --> 00:35:38.550
So this simple
technique, going through,

00:35:38.550 --> 00:35:40.027
hand optimizing
some of this stuff,

00:35:40.027 --> 00:35:41.610
can actually save
you-- what was this?

00:35:41.610 --> 00:35:45.490
2x or 50% savings on a file?

00:35:45.490 --> 00:35:48.310
If you're serving a million
files a day, that's huge.

00:35:48.310 --> 00:35:49.870
Right?

00:35:49.870 --> 00:35:50.380
All right.

00:35:50.380 --> 00:35:52.520
Let's get to the
final one here-- WebP.

00:35:52.520 --> 00:35:53.127
Fans of WebP?

00:35:53.127 --> 00:35:54.070
[APPLAUSE]

00:35:54.070 --> 00:35:54.570
Yeah?

00:35:57.881 --> 00:35:58.827
Yes.

00:35:58.827 --> 00:36:02.280
WebP, I've got to say,
as impressive as JPEG

00:36:02.280 --> 00:36:05.420
is, WebP is in its own league.

00:36:05.420 --> 00:36:07.380
I've done compression
for a long time.

00:36:07.380 --> 00:36:08.990
It's in its own league.

00:36:08.990 --> 00:36:12.650
I mean, on one side, you've
got a whole suite of algorithms

00:36:12.650 --> 00:36:15.410
that applies, so we can
keep up with the lossy type

00:36:15.410 --> 00:36:16.661
of compression that JPEG does.

00:36:16.661 --> 00:36:18.035
On the other side
of it, it's got

00:36:18.035 --> 00:36:20.210
this whole separate filtering
and prediction policy,

00:36:20.210 --> 00:36:22.910
so it can do lossless
encoding, just like PNG.

00:36:22.910 --> 00:36:26.390
It's even got some LZ77 and
dictionary encoding in there,

00:36:26.390 --> 00:36:27.250
so it can do that.

00:36:27.250 --> 00:36:29.770
The result is pretty simple.

00:36:29.770 --> 00:36:32.790
Across the board, all of these
optimizations and techniques

00:36:32.790 --> 00:36:37.962
make it competitive with
both PNG and JPEG everywhere.

00:36:37.962 --> 00:36:39.920
And it supports all of
these features, as well.

00:36:39.920 --> 00:36:41.250
And in most time,
it's actually winning,

00:36:41.250 --> 00:36:42.208
if you check out those.

00:36:42.208 --> 00:36:44.020
So you get smaller file sizes.

00:36:44.020 --> 00:36:46.250
You get more features
in those file sizes.

00:36:46.250 --> 00:36:48.640
And it's supported natively
on Android, which is awesome.

00:36:48.640 --> 00:36:50.056
Round of applause
for that, right?

00:36:50.056 --> 00:36:55.320
[APPLAUSE]

00:36:55.320 --> 00:36:55.980
OK.

00:36:55.980 --> 00:36:57.577
Now, let's get
real for a minute.

00:36:57.577 --> 00:36:59.910
I know we laughed at gummy
bears and had a clapping war,

00:36:59.910 --> 00:37:00.440
but let's get real.

00:37:00.440 --> 00:37:01.200
Can we get real?

00:37:01.200 --> 00:37:02.210
Round of applause
for getting real.

00:37:02.210 --> 00:37:02.810
[APPLAUSE]

00:37:02.810 --> 00:37:03.309
Yeah?

00:37:05.920 --> 00:37:07.940
The weirdest applause
request ever.

00:37:07.940 --> 00:37:11.050
If there's one thing you
remember-- some bald guy got

00:37:11.050 --> 00:37:12.680
on stage at Google
I/O. I was hiding

00:37:12.680 --> 00:37:13.880
in a tent trying to
get out of the sun,

00:37:13.880 --> 00:37:16.379
and he yelled at me for an hour,
but I remembered one thing.

00:37:16.379 --> 00:37:17.280
It's this.

00:37:17.280 --> 00:37:18.330
This is one thing.

00:37:18.330 --> 00:37:19.520
This is all I'm asking
you to remember.

00:37:19.520 --> 00:37:20.019
That's it.

00:37:20.019 --> 00:37:21.650
Nothing else, just this, OK?

00:37:21.650 --> 00:37:22.830
This diagram.

00:37:22.830 --> 00:37:26.130
When you're choosing what
kind of image to make,

00:37:26.130 --> 00:37:28.114
the decision on the
format is super important.

00:37:28.114 --> 00:37:29.780
The first thing you
have to ask yourself

00:37:29.780 --> 00:37:32.380
is, can this image
be a vector drawable?

00:37:32.380 --> 00:37:33.861
If yes, make it a
vector drawable.

00:37:33.861 --> 00:37:34.360
Done.

00:37:34.360 --> 00:37:34.859
Easy.

00:37:34.859 --> 00:37:35.840
Go to lunch.

00:37:35.840 --> 00:37:40.250
If no, ask yourself,
do I support WebP?

00:37:40.250 --> 00:37:41.510
If yes, make it a WebP.

00:37:41.510 --> 00:37:42.120
Go to lunch.

00:37:42.120 --> 00:37:43.130
You're done for the day.

00:37:43.130 --> 00:37:43.670
Good job.

00:37:43.670 --> 00:37:44.340
Peer bonus.

00:37:44.340 --> 00:37:46.120
Sweet.

00:37:46.120 --> 00:37:47.860
If you don't support
WebP, ask yourself,

00:37:47.860 --> 00:37:49.760
does it need transparency?

00:37:49.760 --> 00:37:52.334
If yes, obviously, you've
got to use PNG for that.

00:37:52.334 --> 00:37:53.750
If no, you've got
to ask yourself,

00:37:53.750 --> 00:37:54.750
is it simple or complex?

00:37:54.750 --> 00:37:57.230
Remember, PNG optimizes
and compresses better

00:37:57.230 --> 00:37:59.740
in areas of very
self-similar pixels.

00:37:59.740 --> 00:38:02.000
So the more photo-realistic
an image, the worse

00:38:02.000 --> 00:38:03.560
PNG is going to compress it.

00:38:03.560 --> 00:38:05.440
The more simpler an
image, the better PNG's

00:38:05.440 --> 00:38:06.690
going to compress it, right?

00:38:06.690 --> 00:38:08.726
If it's complex, we're
going to go JPEG.

00:38:08.726 --> 00:38:11.770
Now, if we end up
at PNG, we want

00:38:11.770 --> 00:38:14.630
to make sure that we're
running a tool on it, reducing

00:38:14.630 --> 00:38:16.079
colors, trying to
make it indexed,

00:38:16.079 --> 00:38:18.120
and hand-optimizing it in
places where we need to

00:38:18.120 --> 00:38:19.260
for Hero assets.

00:38:19.260 --> 00:38:20.230
Same thing with JPEG.

00:38:20.230 --> 00:38:23.100
Use a tool, correct the
quality, and hand optimize

00:38:23.100 --> 00:38:25.965
where you can.

00:38:25.965 --> 00:38:27.590
I love that everyone's
taking pictures.

00:38:27.590 --> 00:38:29.120
This is live streamed.

00:38:29.120 --> 00:38:30.630
You can get this later.

00:38:30.630 --> 00:38:32.069
[LAUGHTER]

00:38:32.069 --> 00:38:34.110
In fact, if you check out
the Spaces application,

00:38:34.110 --> 00:38:35.079
I'll put this up later.

00:38:35.079 --> 00:38:36.495
Put your phones
down, you're good.

00:38:36.495 --> 00:38:37.449
[LAUGHTER]

00:38:37.449 --> 00:38:39.490
I'm flattered that you're
taking a picture of me,

00:38:39.490 --> 00:38:40.550
but you know-- I can pose.

00:38:40.550 --> 00:38:41.950
Anyone want a
picture of the pose?

00:38:41.950 --> 00:38:42.330
[LAUGHTER]

00:38:42.330 --> 00:38:42.420
No?

00:38:42.420 --> 00:38:42.920
Anybody?

00:38:42.920 --> 00:38:43.676
Oh, Someone there.

00:38:43.676 --> 00:38:45.494
[LAUGHTER]

00:38:45.494 --> 00:38:46.160
AUDIENCE: There.

00:38:46.160 --> 00:38:46.917
There.

00:38:46.917 --> 00:38:48.542
COLT MCANLIS: Oh,
need to be over here?

00:38:48.542 --> 00:38:50.310
[LAUGHTER]

00:38:50.310 --> 00:38:50.810
OK, no.

00:38:50.810 --> 00:38:51.150
We've got to get back.

00:38:51.150 --> 00:38:51.990
We've got to get back to it.

00:38:51.990 --> 00:38:53.531
The A/V people are
getting mad at me.

00:38:53.531 --> 00:38:54.040
Sorry.

00:38:54.040 --> 00:38:54.540
OK.

00:38:54.540 --> 00:38:57.210
Most importantly, though,
this one simple thing,

00:38:57.210 --> 00:38:58.620
profile your code.

00:38:58.620 --> 00:39:00.160
Profile your code.

00:39:00.160 --> 00:39:01.347
Profile your code.

00:39:01.347 --> 00:39:03.930
Before you make any decisions,
before you make any performance

00:39:03.930 --> 00:39:05.555
changes, before you
change your format,

00:39:05.555 --> 00:39:09.430
before you put bits on the
wire that your users are

00:39:09.430 --> 00:39:13.960
going to have to pay to
download, profile it.

00:39:13.960 --> 00:39:16.890
Make a decision based
upon evidence, and data,

00:39:16.890 --> 00:39:18.770
and the best thing
for your users.

00:39:18.770 --> 00:39:21.160
Do not go lazily
into these decisions,

00:39:21.160 --> 00:39:23.050
because they have
huge ramifications

00:39:23.050 --> 00:39:25.770
for the people who love
you and your applications.

00:39:25.770 --> 00:39:27.010
Profile it.

00:39:27.010 --> 00:39:30.410
In some cases, JPEG's going
to be better than PNG.

00:39:30.410 --> 00:39:32.910
In some cases, WebP's going
to be the best option.

00:39:32.910 --> 00:39:34.746
In some cases, it's
going to load too slow,

00:39:34.746 --> 00:39:36.370
and you're going to
want to use a JPEG.

00:39:36.370 --> 00:39:39.850
In every single situation,
profile your code.

00:39:39.850 --> 00:39:41.290
Find the sweet spot.

00:39:41.290 --> 00:39:44.840
Optimize for your
users, in every case.

00:39:44.840 --> 00:39:47.450
And thank you, thank
you, thank you, so much,

00:39:47.450 --> 00:39:48.630
for coming to this session.

00:39:48.630 --> 00:39:49.588
My name's Colt McAnlis.

00:39:49.588 --> 00:39:50.540
[APPLAUSE]

00:39:50.540 --> 00:39:54.790
[MUSIC PLAYING]

