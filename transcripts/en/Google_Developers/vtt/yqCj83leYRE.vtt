WEBVTT
Kind: captions
Language: en

00:00:04.970 --> 00:00:09.300
&gt;&gt;Reto Meier: Good morning, everyone.
Thanks for coming along today and squeezing

00:00:09.300 --> 00:00:13.709
in. It's a big crowd in here today. So thanks
for your patience as well. I know we are starting

00:00:13.709 --> 00:00:17.341
a bit late but the keynote went over a little.
It was hopefully interesting and exciting

00:00:17.341 --> 00:00:21.199
for you all.
My name is Reto Meier. I am a developer advocate

00:00:21.199 --> 00:00:26.140
for Android at Google and today I am going
to talk to you about how to get started developing

00:00:26.140 --> 00:00:30.169
for Android.
Before I do get started, I want to point your

00:00:30.169 --> 00:00:34.710
attention to this bit.ly link. We are going
to be doing live waves for each of the sessions

00:00:34.710 --> 00:00:39.030
at Google I/O this year. So if you want to
become a part of that, have some conversations

00:00:39.030 --> 00:00:44.120
with people at the session or reading your
notes from afar, follow this link to ioandroid1

00:00:44.120 --> 00:00:49.110
bit.ly link. If you want to tweet about it,
the tweet tag for this session is Android1

00:00:49.110 --> 00:00:52.650
as well.
One of the things I like to ask whenever I

00:00:52.650 --> 00:00:56.420
do these sessions is how many people in the
room have Android phones?

00:00:56.420 --> 00:01:01.650
Wow! That's phenomenal!
How many have the coolest new phones like

00:01:01.650 --> 00:01:05.369
a Droid or a Nexus One or something like that?
That's incredible.

00:01:05.369 --> 00:01:13.030
In fairness, how many of you had these phones
before we sent them to you for coming along?

00:01:13.030 --> 00:01:18.860
That's pretty respectable, I have to say.
I am impressed. That's great. It's even better

00:01:18.860 --> 00:01:27.040
to see you guys here with the phone, trying
to be involved in how to create apps for it.

00:01:27.040 --> 00:01:33.640
What is Android? Android is an open source,
open platform for mobile development.

00:01:33.640 --> 00:01:37.560
You know what? I feel like I have given this
slide before, and if I have a look in the

00:01:37.560 --> 00:01:41.690
audience I feel like I have probably given
this slide to a few of you beforehand.

00:01:41.690 --> 00:01:45.580
Is there anyone here who doesn't know a little
bit about Android, at least?

00:01:45.580 --> 00:01:49.830
Let's ask it a little differently. How many
of you have downloaded the SDK and maybe installed

00:01:49.830 --> 00:01:52.740
Eclipse and the plug-in?
Wow!

00:01:52.740 --> 00:01:59.740
And how many of you have done your first apps,
something a little more than Hello World.

00:01:59.740 --> 00:02:03.880
So that's most of you.
So we can probably skip this really basic

00:02:03.880 --> 00:02:08.410
stuff. We had a boot camp yesterday. All of
this information is online at developer.android.com.

00:02:08.410 --> 00:02:13.440
So if you really do want to understand the
absolute fundamentals, check this out. It's

00:02:13.440 --> 00:02:16.830
got everything you need. It will tell you
all about the APIs that are included, give

00:02:16.830 --> 00:02:20.280
you tutorials, sample apps, those sorts of
things.

00:02:20.280 --> 00:02:25.090
What we're going to do today I think is something
a little bit different. In the past, it's

00:02:25.090 --> 00:02:30.190
been all about, as a developer advocate, telling
people about Android, getting them excited.

00:02:30.190 --> 00:02:33.870
I think judging by the number of people with
Android phones and who have already gotten

00:02:33.870 --> 00:02:39.660
started, we are a little beyond that.
Now it's about quality, building better applications.

00:02:39.660 --> 00:02:45.560
So instead today I am going to present to
you some best practices for beginners on Android

00:02:45.560 --> 00:02:49.459
to help make sure that you guys, when you
get started are creating great apps, not just

00:02:49.459 --> 00:02:56.640
any app.
So as a developer, you have a choice. You

00:02:56.640 --> 00:03:02.430
can be a good developer, or you can be a lazy
developer.

00:03:02.430 --> 00:03:08.840
And like any choice, that choice has consequences.
As a developer, you are absolutely at the

00:03:08.840 --> 00:03:13.510
mercy of your users. If you create a bad user
experience, they are going to uninstall your

00:03:13.510 --> 00:03:16.950
app, they are going to give you one star,
they are going to write a snarky comment,

00:03:16.950 --> 00:03:21.370
and before you know it your app is going to
disappear. It's going to drop down the list

00:03:21.370 --> 00:03:24.720
of top apps.
When people do find it through a search, it

00:03:24.720 --> 00:03:28.440
will have one star. They won't bother with
it. If they do, they have a bad experience,

00:03:28.440 --> 00:03:32.150
they do the same thing. Before you know it,
your app is gone.

00:03:32.150 --> 00:03:36.190
On the other hand, if you are a good developer,
if you use some of these best practices, then

00:03:36.190 --> 00:03:40.840
you are going to create an app people love,
they are going to use it, keep using it, give

00:03:40.840 --> 00:03:44.830
it higher rankings, positive comments. It's
going to show up on the top lists. It's going

00:03:44.830 --> 00:03:49.540
to be the app with four and a half stars when
they do a search. People are going to talk

00:03:49.540 --> 00:03:53.120
about it, people are going to use it, it's
got a potential for being featured. This is

00:03:53.120 --> 00:03:56.620
what you want.
So on the assumption what you guys want do

00:03:56.620 --> 00:04:01.460
is become good developers, what I want to
talk to you today is I want to give you five

00:04:01.460 --> 00:04:06.180
examples of things you should not do, five
examples of things that you should do, and

00:04:06.180 --> 00:04:10.530
then in the last ten or 15 minutes I want
to give you a couple of practical examples

00:04:10.530 --> 00:04:16.070
of areas within Android development where
a few simple best practices can really improve

00:04:16.070 --> 00:04:21.739
the quality of your applications, make them
more useful and more performant within the

00:04:21.739 --> 00:04:24.389
system.
So we are going to start off with the five

00:04:24.389 --> 00:04:32.580
deadly since of Android development.
First one is sloth. It is key that your applications

00:04:32.580 --> 00:04:38.810
are fast and responsive at all times.
The two golden rules for creating performant

00:04:38.810 --> 00:04:44.470
applications within Android are to not do
any work that you don't need to do and not

00:04:44.470 --> 00:04:47.670
to allocate any memory if you can possibly
avoid it.

00:04:47.670 --> 00:04:53.030
Now, the Android developer Web site, developer@android.com
has a whole list of performace pointers, some

00:04:53.030 --> 00:04:57.120
of which are summarized here. I am not going
to go through each of these in detail. It's

00:04:57.120 --> 00:05:00.660
on the Web site. You can do that there. But
what you will find that all of these have

00:05:00.660 --> 00:05:05.380
in common is they in some way or another refer
back to the previous two golden rules. They

00:05:05.380 --> 00:05:09.500
don't do any work if they don't have to do
it, and they avoid allocating memory, such

00:05:09.500 --> 00:05:15.080
as creating objects, if they can.
The reason why this is so important is because

00:05:15.080 --> 00:05:20.030
small changes in efficiency within your application
in such a resource constrained environment

00:05:20.030 --> 00:05:24.880
as mobile phones can have a significant impact
on the performance of your applications.

00:05:24.880 --> 00:05:28.870
So even things which you probably would never
have considered, and many of these certainly,

00:05:28.870 --> 00:05:32.580
from a desktop developing background that
I am from, I wouldn't have given a second

00:05:32.580 --> 00:05:37.810
thought to because they seem like such minor
improvements in terms of efficiency, in a

00:05:37.810 --> 00:05:41.000
resource constrained environment this can
have a significant impact and is something

00:05:41.000 --> 00:05:48.080
you really do need to pay attention to.
Just as important as performance, if not more

00:05:48.080 --> 00:05:56.650
so, is responsiveness.
So mobile users, they do not have any patience.

00:05:56.650 --> 00:05:59.590
You are all mobile users and you know what
it's like. Your mobile phone is something

00:05:59.590 --> 00:06:03.449
you are using on the go. It's not something
you are sitting down comfortably in front

00:06:03.449 --> 00:06:08.880
of a workstation where you are waiting for
something to load. Basically everything has

00:06:08.880 --> 00:06:14.620
to happen immediately.
And the same is true for your applications.

00:06:14.620 --> 00:06:19.680
So you have to make sure users have the instant
gratification. What that means is you don't

00:06:19.680 --> 00:06:25.139
want to have modal loading dialogues where
people are seeing a spinning beach ball or

00:06:25.139 --> 00:06:29.800
hourglass or anything along those lines. They
need to be able to interact with your application

00:06:29.800 --> 00:06:32.610
instantly.
So if you are creating something like a news

00:06:32.610 --> 00:06:37.690
app, for example, rather than having a loading
dialogue which comes up and prevents the user

00:06:37.690 --> 00:06:42.680
from doing anything, what you want to do is
allow them to continue to interact while updating

00:06:42.680 --> 00:06:46.480
them on progress and then showing them whatever
information you can as quickly as you can.

00:06:46.480 --> 00:06:50.880
So that means downloading the news headlines
and filling them in as you decode them from

00:06:50.880 --> 00:06:55.949
the input stream.
Going back afterwards and adding the images

00:06:55.949 --> 00:06:59.980
as they get downloaded, so rather than waiting
until everything is finished and ready to

00:06:59.980 --> 00:07:03.380
go, you are gradually increasing the amount
of information available.

00:07:03.380 --> 00:07:07.810
And you can extend this to things such as
prefetching. So again if it's a news app,

00:07:07.810 --> 00:07:11.530
something like that, you fill in the information
for the first screen, and then while they

00:07:11.530 --> 00:07:15.009
are reading that or while the user is doing
anything else, you are prefetching the dialer

00:07:15.009 --> 00:07:20.500
for each of the sections they may navigate
to. And the intent here is as soon as the

00:07:20.500 --> 00:07:24.210
user is using the application, they are not
having to wait any longer for things. It's

00:07:24.210 --> 00:07:27.840
available as soon as it possibly can be. And
this is particularly important for something

00:07:27.840 --> 00:07:32.449
like a mobile phone where your data bandwidth
is going to be limited. It's going to take

00:07:32.449 --> 00:07:37.360
some time for a lot of these things to load.
So you need to do everything you can to remove

00:07:37.360 --> 00:07:42.570
that lagginess.
How many have you have seen one of these?

00:07:42.570 --> 00:07:49.410
Yeah, come on, I think a few more than that.
If your user sees one of these, you have already

00:07:49.410 --> 00:07:55.039
failed. It's absolutely the worst thing you
can possibly have your user see.

00:07:55.039 --> 00:07:58.110
The documentation will rightly tell you that
you will see one of those "application not

00:07:58.110 --> 00:08:04.349
responding" dialogues if the user tries to
perform an action on your phone and the device

00:08:04.349 --> 00:08:08.979
isn't responsive within five seconds. So you
have five seconds to respond before you get

00:08:08.979 --> 00:08:14.889
the ANR of death. That's absolutely true.
It's also a little bit misleading. In reality

00:08:14.889 --> 00:08:19.539
you have between one and 200 milliseconds
before your users are going to start thinking

00:08:19.539 --> 00:08:24.020
your application is laggy.
So it's important that you move anything which

00:08:24.020 --> 00:08:28.820
can in any way take longer than just a fraction
of the second and interrupt the UI flow that

00:08:28.820 --> 00:08:33.500
you move it into a background thread. There's
a number of ways you can do that. The most

00:08:33.500 --> 00:08:38.029
simple and straightforward is to use Java
threading to move all those time-consuming

00:08:38.029 --> 00:08:43.680
operations into a thread. Of course that brings
with it a whole a lot of issues such as synchronizing

00:08:43.680 --> 00:08:48.480
to the UI thread so you can update progress
and change the UI depending on the progress

00:08:48.480 --> 00:08:54.350
of your background activity.
So what we have created in Android is a class

00:08:54.350 --> 00:09:00.179
called async task. And what this does is it
wraps up that model for you. So rather than

00:09:00.179 --> 00:09:04.670
having to do all of the thread handling yourself
in the UI synchronization, you can implement

00:09:04.670 --> 00:09:10.070
this class and have it do it for you.
So it's a generic class so all of the parameters

00:09:10.070 --> 00:09:14.139
here can be defined to whichever types that
you want to use.

00:09:14.139 --> 00:09:17.399
In this example, I have kept it simple and
left it as void.

00:09:17.399 --> 00:09:21.739
So as you can see, the "do in background"
event handler is where you actually do this

00:09:21.739 --> 00:09:27.180
time-consuming operation. While that's happening
you can regularly publish progress. So if

00:09:27.180 --> 00:09:31.309
you are downloading multiple pictures and
you want to update the UI with each picture

00:09:31.309 --> 00:09:36.769
as it comes through or simply update a progress
dialogue as you are performing this action,

00:09:36.769 --> 00:09:40.610
you can call publish progress, optionally
passing the parameter, and that's going fire

00:09:40.610 --> 00:09:45.689
this on-progress update handler, receiving
that parameter if you pass one through. And

00:09:45.689 --> 00:09:50.309
this is already synchronized to the UI thread.
So you can update your UI, you can trigger

00:09:50.309 --> 00:09:54.620
a notification, call up a toast, anything
like that and you don't have to do the thread

00:09:54.620 --> 00:09:59.619
synchronization work.
Similarly, once you have completed your background

00:09:59.619 --> 00:10:03.661
processing task you can optionally return
a value, that's going to get passed on to

00:10:03.661 --> 00:10:08.779
on post execute. And this is synchronized
to the UI thread. You can modify the UI with

00:10:08.779 --> 00:10:14.100
the data you have been progressing, notify
your users it's complete, anything like that,

00:10:14.100 --> 00:10:16.089
and the synchronization is already done for
you.

00:10:16.089 --> 00:10:24.600
The next sin is that of gluttony. The only
thing worse than having an app that is slow

00:10:24.600 --> 00:10:28.110
and unresponsive is an app which makes the
system slow and unresponsive and drains all

00:10:28.110 --> 00:10:34.689
of your battery as well just for good measure.
The key is to always use your system resources

00:10:34.689 --> 00:10:38.939
responsibly.
So to avoid being a bad citizen, what you

00:10:38.939 --> 00:10:43.769
want to do is make sure you are being very
respectful of power. Don't use power unless

00:10:43.769 --> 00:10:48.800
you absolutely have to. Don't do updates more
often than you need to, either. And that can

00:10:48.800 --> 00:10:54.189
be updates from location listeners, from accelerometers,
widget updates, anything that's going to cause

00:10:54.189 --> 00:10:59.399
the phone to wake up or to listen to a sensor
or do any kind of action. You want to do this

00:10:59.399 --> 00:11:04.100
as infrequently as possible. Obviously there's
tradeoffs there against usability, but it's

00:11:04.100 --> 00:11:07.779
still important to find out what's the minimum
amount we can do that's still going to make

00:11:07.779 --> 00:11:14.920
it a useful, usable application.
Things you should do. Find ways to share data.

00:11:14.920 --> 00:11:17.699
Processing data, pulling it down through the
network, all of these things are going to

00:11:17.699 --> 00:11:23.720
consume resources. Battery, Internet bandwidth.
If you can find ways that your application

00:11:23.720 --> 00:11:28.230
can share that data between other applications,
whether it's yourselves or third parties,

00:11:28.230 --> 00:11:33.529
or if you can leverage data from another application
or from something Natively, this is an opportunity

00:11:33.529 --> 00:11:38.899
to reduce that resource use.
Similarly, wherever possible you should be

00:11:38.899 --> 00:11:43.249
event driven. So there are some circumstances
where you will need to do polling. That's

00:11:43.249 --> 00:11:47.319
the way it is at the moment certainly. But
wherever possible you should be listening

00:11:47.319 --> 00:11:51.480
for system events or for broadcast intents
from your application or others. We will talk

00:11:51.480 --> 00:11:55.879
a little bit more about how you go about doing
that later in this session.

00:11:55.879 --> 00:11:59.689
Possibly one of the most important things
is to let the system manage resources. So

00:11:59.689 --> 00:12:04.220
a lot of the Android framework team, their
whole goal is to find ways of being able to

00:12:04.220 --> 00:12:08.429
make the framework manage these resources.
So it's important to try and find ways that

00:12:08.429 --> 00:12:13.029
you can work with the system to take advantage
of those optimizations. And importantly, not

00:12:13.029 --> 00:12:18.879
try and fight against what the system is doing.
How many of you are familiar with the wake

00:12:18.879 --> 00:12:23.290
lock?
All right. I may very well regret showing

00:12:23.290 --> 00:12:29.029
you this but this is a wake lock. What it
is, it's a way to force the device to stay

00:12:29.029 --> 00:12:33.959
on, so you can keep just the CPU running or
you can keep the screen on as well. And that's,

00:12:33.959 --> 00:12:38.319
in fact, what this particular example shows.
We're using the power manager to create a

00:12:38.319 --> 00:12:43.929
new wake lock, which is going to keep the
screen on, though optionally dimmed. And then

00:12:43.929 --> 00:12:47.910
what we're doing is calling acquire, and at
that point the screen and the CPU is going

00:12:47.910 --> 00:12:52.660
to be kept on until this wake lock is released.
So in this example we have specified a ten

00:12:52.660 --> 00:12:57.609
second timeout. So no matter what happens,
it's going to be released after ten seconds

00:12:57.609 --> 00:13:02.920
unless we release it first by calling release.
Wake locks are really cool, they are really

00:13:02.920 --> 00:13:06.329
useful, and very important. Particularly,
you've got things happening in the background,

00:13:06.329 --> 00:13:10.299
if you have got things happening in a regular
basis or responding to system events which

00:13:10.299 --> 00:13:14.579
may occur while your device is on standby,
you need to use wake locks to make sure it

00:13:14.579 --> 00:13:17.389
doesn't turn off while you're in the middle
of completing a task.

00:13:17.389 --> 00:13:22.499
The thing is this. They are very powerful,
but it also requires a lot of responsibility

00:13:22.499 --> 00:13:26.140
on your behalf.
So if you are using wake locks, you need to

00:13:26.140 --> 00:13:31.660
make sure that you really need to use one.
It's tempting to just use it wherever you

00:13:31.660 --> 00:13:35.049
can. Oh, this is something that should be
completed. Unless it needs to be completed

00:13:35.049 --> 00:13:38.989
within a certain period of time, don't use
a wake lock.

00:13:38.989 --> 00:13:43.709
If you do need to use one, use the minimum
level of wake lock possible, and use it for

00:13:43.709 --> 00:13:46.559
the shortest amount of time that you possibly
can.

00:13:46.559 --> 00:13:50.810
So that's the -- in the example that we gave
that you just saw previously, we had a ten-second

00:13:50.810 --> 00:13:55.730
timeout to make sure that no matter what happens,
it will be ended in that time frame.

00:13:55.730 --> 00:14:00.589
So this is an important thing to do to make
sure you are not holding wake locks and draining

00:14:00.589 --> 00:14:06.220
the battery unnecessarily.
One of the others things I want to point out

00:14:06.220 --> 00:14:10.279
is that in most cases, you shouldn't actually
need to keep the screen on. Certainly the

00:14:10.279 --> 00:14:14.160
CPU, but the screen you shouldn't have to.
Now, if you are creating an application which

00:14:14.160 --> 00:14:18.139
does need the screen to be on, a video player
or something like that where the user isn't

00:14:18.139 --> 00:14:23.709
interacting but you want the screen on, there
is an alternative, and that's to let the window

00:14:23.709 --> 00:14:27.610
manager handle it for you.
So rather than using a wake lock to keep your

00:14:27.610 --> 00:14:31.839
screen on, what you can do is get a handle
of the window and pass this "keep screen on"

00:14:31.839 --> 00:14:36.980
flag to it, and that will let the window manager
handle the wake lock for you. That way you

00:14:36.980 --> 00:14:40.449
don't have to worry about finding out all
the different ways your activity can be hidden,

00:14:40.449 --> 00:14:44.449
when it should or shouldn't be keeping a screen
on, and managing these wake locks. You are

00:14:44.449 --> 00:14:48.259
essentially letting the run time do that four.
It's a much safer, much more secure way of

00:14:48.259 --> 00:14:53.929
doing things.
Please don't be the developer which makes

00:14:53.929 --> 00:14:59.049
the user pull the battery. Don't be hostile.
Don't fight your users. You are there to create

00:14:59.049 --> 00:15:02.730
an experience which is good for them, and
they should be one of the -- they should always

00:15:02.730 --> 00:15:07.919
be your top priority.
You absolutely live and die by your user's

00:15:07.919 --> 00:15:12.069
experience. So you absolutely need to make
it a good one. And you need to respect those

00:15:12.069 --> 00:15:16.180
user expectations for the way your application
behaves.

00:15:16.180 --> 00:15:20.301
When I asked my team for some best practices
around Android development, what sort of things

00:15:20.301 --> 00:15:24.399
should I share with you guys, this is one
of the quotes that I got back. Doing what

00:15:24.399 --> 00:15:28.829
the user expects with respect to navigation
flow is absurdly important for overall user

00:15:28.829 --> 00:15:34.049
satisfaction. I really like this because it
summed up a few thoughts I had and which were

00:15:34.049 --> 00:15:37.359
particularly important to me when explaining
to people how they should be creating the

00:15:37.359 --> 00:15:42.410
user experiences.
Users have been using their phones for a lot

00:15:42.410 --> 00:15:46.129
longer than they have been using your apps.
And they have been using other apps that are

00:15:46.129 --> 00:15:50.559
on the phone longer than using yours as well
so they have expectations for the way applications

00:15:50.559 --> 00:15:57.220
behave. Interfering with those expectations
just makes it harder for them to use your

00:15:57.220 --> 00:16:00.040
app.
So while you do need to make sure it's always

00:16:00.040 --> 00:16:04.679
easy and intuitive to learn and use your application,
you also need to think about it in the greater

00:16:04.679 --> 00:16:10.170
context of an Android device. One of the particular
ones I want to call out to you today is the

00:16:10.170 --> 00:16:14.839
back button. The back button on Android is
a little bit unique. It's not something you

00:16:14.839 --> 00:16:19.989
see in a lot of other mobile platforms but
it's also integral to the way people use their

00:16:19.989 --> 00:16:25.149
phones. The key to the back button is in the
name. It means back. It's going back to something

00:16:25.149 --> 00:16:29.040
you have already seen. You should never be
seeing a new screen when you hit back. It

00:16:29.040 --> 00:16:32.829
works the same way, or at least it should
work the same way as the back button on your

00:16:32.829 --> 00:16:37.759
browser. Every time you hit back on your browser
you are going to a previous Web page or Web

00:16:37.759 --> 00:16:41.809
site that you have already been to. You are
not navigating to the home page of a new site.

00:16:41.809 --> 00:16:45.920
So if you navigate from one site to another
and then within pages, hitting back will always

00:16:45.920 --> 00:16:50.109
take you back through these other places,
and that's exactly the way it should act within

00:16:50.109 --> 00:16:56.639
your application. It's not an up button. It's
a back button.

00:16:56.639 --> 00:17:02.449
So of course respecting the user expectations
in terms of navigation is definitely one important

00:17:02.449 --> 00:17:06.530
part, but it's not the only expectation that
you need to respect.

00:17:06.530 --> 00:17:14.510
Phones are really extremely personal devices.
They are something which people use their

00:17:14.510 --> 00:17:18.329
phones in ways which are unique to them and
they will have work flows built around those

00:17:18.329 --> 00:17:23.449
expectations. So again, it's important you
not interfere with the way they expect to

00:17:23.449 --> 00:17:29.730
be able Tuesday their phones.
So what does that mean? It means there's a

00:17:29.730 --> 00:17:34.559
whole bunch of things, again, which are around
Android. And because it's so open, you can

00:17:34.559 --> 00:17:38.140
pretty much take control of the user experience
in any way you want to. And one of the ways

00:17:38.140 --> 00:17:45.259
in which people do that is by hiding the status
bar.

00:17:45.259 --> 00:17:49.299
The thing about that is that it's great, you
get an extra 20 or so pixels at the top of

00:17:49.299 --> 00:17:53.519
your display, and if you are creating a game,
this is an absolutely legitimate thing to

00:17:53.519 --> 00:17:57.210
do. You want to complete a fully immersive
full-screen experience, and users have an

00:17:57.210 --> 00:18:01.380
expectation that that's the way it's going
to work. But I have seen apps do this just

00:18:01.380 --> 00:18:05.559
because they would like to have a bit of extra
space. What they may not appreciate is by

00:18:05.559 --> 00:18:09.430
doing something like that, the user loses
then their status bar, which means they don't

00:18:09.430 --> 00:18:13.830
get the clock, they don't get notifications,
they don't get a variety of things which they

00:18:13.830 --> 00:18:17.919
are expecting to be there. It makes it harder
for them to understand your app and to use

00:18:17.919 --> 00:18:21.740
it. They are much more likely to try to find
someone else who has done the same sort of

00:18:21.740 --> 00:18:25.010
thing as you but are letting them use their
phone in way they are familiar with.

00:18:25.010 --> 00:18:29.220
So it's really important that you not hijack
the way in which people use it, so they can

00:18:29.220 --> 00:18:34.010
continue to use their phone in ways they have
personalized for themselves while also making

00:18:34.010 --> 00:18:39.909
use of your application.
So far the previous three points have all

00:18:39.909 --> 00:18:46.399
been sort of implicit expectations or contracts
with the user. It's the expectation that your

00:18:46.399 --> 00:18:51.840
app will work well within the context of Android.
This fourth point is much more explicit. It's

00:18:51.840 --> 00:18:58.820
the idea of obeying what users have explicitly
told that you they want your application to

00:18:58.820 --> 00:19:02.230
do.
This is particularly important around things

00:19:02.230 --> 00:19:05.450
like location privacy and anything which has
a cost implication.

00:19:05.450 --> 00:19:12.139
Particularly for something like location privacy,
that can even have legal implications in some

00:19:12.139 --> 00:19:17.929
countries where if you don't give the users
the option to opt out, then you can run into

00:19:17.929 --> 00:19:22.049
real problems.
So one of the system settings that you can

00:19:22.049 --> 00:19:26.649
do on your Android phones is to turn off background
data transfer. So I don't know how many of

00:19:26.649 --> 00:19:31.179
you knew that. What I am curious to know is
how many of you do know that that's something

00:19:31.179 --> 00:19:37.789
which each application has to respect individually?
All right. So this is how do you that. This

00:19:37.789 --> 00:19:43.250
is how you find out whether or not a user
has enabled background data transfer.

00:19:43.250 --> 00:19:47.669
Using the connectivity manager, it's a simple
call to get background data setting.

00:19:47.669 --> 00:19:52.509
There's also an intent that gets fired if
the user changes this. So what that means

00:19:52.509 --> 00:19:58.130
is if this is turned off, then your application
is not allowed to transfer data in the background.

00:19:58.130 --> 00:20:03.159
Now, it still can. It's up to you to turn
it off. But it's something the user isn't

00:20:03.159 --> 00:20:07.320
expecting, so if it is transferring data in
the background and the user is getting hit

00:20:07.320 --> 00:20:11.730
for a thousand dollar roaming phone bill,
it's you they are going to be angry at. So

00:20:11.730 --> 00:20:19.549
it's really important that you respect that.
The next sin is that of arrogance. Don't fight

00:20:19.549 --> 00:20:25.140
the system. It will most likely win.
What do I mean by don't fight the system?

00:20:25.140 --> 00:20:30.750
It's doing things like not using unsupported
 -- or I should say, undocument APIs. And

00:20:30.750 --> 00:20:35.260
it's important, I will say it twice. The reason
for this is pretty straightforward. It's for

00:20:35.260 --> 00:20:40.490
your own good. It's not for any other reason
than the fact if they are not documented,

00:20:40.490 --> 00:20:44.960
the reason for that more often than not is
because we think it's going to change.

00:20:44.960 --> 00:20:49.379
So we can use these undocumented APIs. It's
all open source. You can see everything that's

00:20:49.379 --> 00:20:52.679
there, there is nothing to prevent you, but
then when the next release of Android comes

00:20:52.679 --> 00:20:56.440
out, your app is going to break. And you are
going to have to spend a lot of time trying

00:20:56.440 --> 00:21:01.559
to figure out how to then make it work with
this new version possibly even before you

00:21:01.559 --> 00:21:05.190
have that update on your phone or even the
SDK to do anything about it.

00:21:05.190 --> 00:21:09.230
So it's really important that you think long
and hard before you use anything that's not

00:21:09.230 --> 00:21:13.611
officially supported.
Just as important, and this kind of goes back

00:21:13.611 --> 00:21:18.490
to the topics we were just talking about previously,
and that's make sure that your application

00:21:18.490 --> 00:21:22.640
is consistent with the system. Don't try and
fight against the way that the system normally

00:21:22.640 --> 00:21:26.250
works, because that's going to be in line
with the user expectations. It's going to

00:21:26.250 --> 00:21:29.230
make it easier for the system to optimize
resources.

00:21:29.230 --> 00:21:33.780
So try to find ways to work with the system
rather than try to find ways to work against

00:21:33.780 --> 00:21:39.830
it.
Related to that is respecting the application

00:21:39.830 --> 00:21:43.480
life cycle model. So you have all got the
SDK, you have all gotten started which means

00:21:43.480 --> 00:21:48.029
hopefully you are aware of the application
life cycle within Android.

00:21:48.029 --> 00:21:51.120
So what that means is that there's a bunch
of ways that your application can be switched

00:21:51.120 --> 00:21:56.179
out; in fact, can be terminated by the run
time to reclaim resources for other running

00:21:56.179 --> 00:21:58.879
activities.
So it's really important that you use things

00:21:58.879 --> 00:22:04.110
like on pours, on stop, on start, on restart
to make sure that that transition is invisible

00:22:04.110 --> 00:22:08.161
to your users.
As far as they are concerned, your application

00:22:08.161 --> 00:22:12.190
should always just be sitting there a moment
away from being the active foreground activity.

00:22:12.190 --> 00:22:17.480
So you should be saving state, saving data,
caching things so they are not having to restart

00:22:17.480 --> 00:22:23.820
the app each time they switch to it. They
are simply switching a back.

00:22:23.820 --> 00:22:31.150
So the final five, the final sin I want to
cover is that of discrimination. Design for

00:22:31.150 --> 00:22:34.720
everyone.
One of the big strengths of Android is there

00:22:34.720 --> 00:22:39.820
are a huge number of handsets. If you have
been out the front here you will be able to

00:22:39.820 --> 00:22:46.620
see this massive bookcase of Android phones.
And there's a few dozen there at least. And

00:22:46.620 --> 00:22:51.279
it's all different screen sizes, hardware
types, supported things.

00:22:51.279 --> 00:22:55.980
And many of them are running different platforms.
So this is the latest breakdown of the different

00:22:55.980 --> 00:22:59.159
platforms that are available.
So you can see right away that if you are

00:22:59.159 --> 00:23:04.179
targeting a single platform, you are already
cutting out two-thirds of your users.

00:23:04.179 --> 00:23:07.910
If you are targeting a single device, then
that's going to be even more extreme. So you

00:23:07.910 --> 00:23:13.929
need to find ways to include everyone.
At the same time, if you design for the lowest

00:23:13.929 --> 00:23:18.039
denominator, you are going to be restricting
two-thirds of your users from having some

00:23:18.039 --> 00:23:22.080
of these advanced features.
So there are ways you can support everyone

00:23:22.080 --> 00:23:26.850
can while symptom including the advanced API
features for the people who have those platforms

00:23:26.850 --> 00:23:33.120
running on their phone.
The key to that is to not make any assumptions.

00:23:33.120 --> 00:23:38.200
It's to design for multiple displays. It's
to design expecting internationalization right

00:23:38.200 --> 00:23:43.120
from the beginning. It's all about externalizing
everything you can so you can support as many

00:23:43.120 --> 00:23:46.309
different locations, languages, and features
as possible.

00:23:46.309 --> 00:23:53.659
So how do you go about doing that?
The key is externalization. There's a resources

00:23:53.659 --> 00:23:58.549
framework within Android that's very powerful
which lets you externalize pretty much anything.

00:23:58.549 --> 00:24:01.350
So you should never have a hard coded anything
in your code.

00:24:01.350 --> 00:24:06.071
If it's a string value, a dimension value,
anything like that, colors, they should all

00:24:06.071 --> 00:24:11.320
be externalized into the resources hierarchy
so that you can have different variations

00:24:11.320 --> 00:24:15.010
for different locations, different hardware.
And so you can create an optimized experience

00:24:15.010 --> 00:24:20.549
for everyone who is using your application.
Even within resources, if you are creating

00:24:20.549 --> 00:24:26.640
an array of strings, each of the values within
that array resource should be a link to another

00:24:26.640 --> 00:24:30.759
resource, the string resources.
So the way that actually looks is like this.

00:24:30.759 --> 00:24:36.220
So within your project folder you have a resources
subdirectory or RES subdirectory which contains

00:24:36.220 --> 00:24:42.379
the resources. And as you can see on the right-hand
side here we have done that for string values.

00:24:42.379 --> 00:24:46.889
So we have different values localized for
a number of different languages.

00:24:46.889 --> 00:24:50.409
On the left-hand side we have done something
similar for assets. So you have got three

00:24:50.409 --> 00:24:57.080
different icons for the different resolution
categories supported, and optimized layouts

00:24:57.080 --> 00:25:01.879
for each of the screen sizes as well.
Now, run time, Android is going to go through,

00:25:01.879 --> 00:25:06.250
look at the device that it's running on, and
pick the right values from all of these things.

00:25:06.250 --> 00:25:10.019
And so you as the developer don't have to
do anything other than have these externalized

00:25:10.019 --> 00:25:14.129
resources, and you are going to get the best
possible result that any variation of the

00:25:14.129 --> 00:25:15.761
hardware that your application is running
on.

00:25:15.761 --> 00:25:23.140
I could go on about this for the rest of my
hour. I won't because Justin is going to do

00:25:23.140 --> 00:25:28.230
that this afternoon. So if you are interested
in exactly how you can do these things, things

00:25:28.230 --> 00:25:33.559
like using reflection, things like using these
resources hierarchy to be able to create this

00:25:33.559 --> 00:25:38.640
optimized experience for as many users as
possible, I strongly urge you to check that

00:25:38.640 --> 00:25:42.850
out this afternoon.
So that neatly covers everything that you

00:25:42.850 --> 00:25:46.120
need to avoid.
So I want to lift the mood a little and cover

00:25:46.120 --> 00:25:48.779
a few things that you really should be looking
at doing.

00:25:48.779 --> 00:25:51.960
So it's the five glorious virtues of Android
development.

00:25:51.960 --> 00:25:57.210
The first one is that of beauty.
How many people in the room are designers?

00:25:57.210 --> 00:26:00.600
We've got a couple.
Nice.

00:26:00.600 --> 00:26:03.940
Thanks for coming.
How many of you guys who aren't designers

00:26:03.940 --> 00:26:08.889
still create the assets and do the work flows
and the user experience and the layouts and

00:26:08.889 --> 00:26:12.500
everything for your applications?
Yeah.

00:26:12.500 --> 00:26:15.509
That's actually fewer than I thought.
I think some of you are a little shy.

00:26:15.509 --> 00:26:20.761
But even still, if you are serious about this,
if you really want to create an application

00:26:20.761 --> 00:26:26.711
that's great rather than just good, you need
to be serious about the way your application

00:26:26.711 --> 00:26:29.139
looks.
You need to be looking to hire one of the

00:26:29.139 --> 00:26:32.090
first lot of guys which put their hand up.
So, hopefully, you'll be popular later in

00:26:32.090 --> 00:26:37.620
the day.
Beauty is important.

00:26:37.620 --> 00:26:41.799
If you are designing and implementing the
designs which people do for you, there is

00:26:41.799 --> 00:26:46.460
a session again today at 4:15, after Justin's,
on Android UI design patterns.

00:26:46.460 --> 00:26:50.020
So that's going to talk a little bit about
the sorts of work flows and user experiences

00:26:50.020 --> 00:26:56.259
that are standard within Android and how you
can go about implementing those in an efficient

00:26:56.259 --> 00:26:59.980
way.
So if you're involved in the UI design implementation

00:26:59.980 --> 00:27:03.620
of your applications, and I think it is fair
to say that most of you will be, then this

00:27:03.620 --> 00:27:06.480
is definitely a session you will want to check
out.

00:27:06.480 --> 00:27:09.321
Rather than going into too much detail, given
that there is this session later in the day,

00:27:09.321 --> 00:27:12.720
I want to go over a few specific points while
I have your attention.

00:27:12.720 --> 00:27:18.590
The first one is to create assets for large
devices.

00:27:18.590 --> 00:27:22.020
So so far, the trend has been increasing resolution,
increasing sizes.

00:27:22.020 --> 00:27:25.580
And there's no reason to believe that that's
going to go anywhere other than continue to

00:27:25.580 --> 00:27:28.700
move in that direction.
So what you need to do is make sure that you

00:27:28.700 --> 00:27:33.590
create those assets as big as possible.
So that means scalable vector art or large

00:27:33.590 --> 00:27:39.929
raster images which can then be scaled down
and optimized for the lower resolutions.

00:27:39.929 --> 00:27:43.749
The key thing, really, is being resolution-independent
entirely.

00:27:43.749 --> 00:27:48.150
It's -- we're no longer in this place where
you can assume that mobile phone screen sizes

00:27:48.150 --> 00:27:50.529
are going to be a particular size or a particular
resolution.

00:27:50.529 --> 00:27:56.269
There's also a whole collection of different
screen sizes and slight variations in resolution.

00:27:56.269 --> 00:27:59.110
Your best bet is to be independent of that
wherever you can be.

00:27:59.110 --> 00:28:04.419
So use device-independent pixels, use relative
layouts, all of these things, which we have

00:28:04.419 --> 00:28:07.159
had to be doing in Web and desktop development
for a long time.

00:28:07.159 --> 00:28:11.600
It's the same situation for mobiles.
You can't make assumptions about the screen

00:28:11.600 --> 00:28:16.980
that your apps will be running on.
Two things which I do want to point out, because

00:28:16.980 --> 00:28:21.029
you guys are new to Android, these two tools
layout opt and hierarchy view.

00:28:21.029 --> 00:28:24.300
These are within the SDK tools folder of the
SDK download.

00:28:24.300 --> 00:28:28.580
They will help you to analyze and then optimize
your layouts.

00:28:28.580 --> 00:28:31.950
Once you've worked out what it is you want
to display, this will help to make sure that

00:28:31.950 --> 00:28:35.460
you implement that in a way that's efficient
and performant.

00:28:35.460 --> 00:28:43.429
So definitely check those out.
So for the next few virtues, what I want to

00:28:43.429 --> 00:28:47.750
do is, rather than just talking about it,
I want to show you a couple of examples of

00:28:47.750 --> 00:28:51.230
applications which make use of some of these
virtues.

00:28:51.230 --> 00:28:54.519
So the first example I want to give is that
of generosity.

00:28:54.519 --> 00:28:59.730
It's the idea of sharing and consuming functionality
within your own application so you can bring

00:28:59.730 --> 00:29:06.400
multiple applications together and the example
is Where and Open Table.

00:29:06.400 --> 00:29:11.200
Where is an application which lets you find
things, like restaurants.

00:29:11.200 --> 00:29:16.659
Open Table is an application which lets you
book tables at restaurants.

00:29:16.659 --> 00:29:20.619
So it should be fairly simple to see how these
two things should be able to work together.

00:29:20.619 --> 00:29:25.130
And that's what I want to demonstrate now.
Brilliant.

00:29:25.130 --> 00:29:34.649
Okay.
So if I open up Where, look for places, restaurants,

00:29:34.649 --> 00:29:38.789
American, in the local area.
Excellent.

00:29:38.789 --> 00:29:41.570
We'll have a look at Sauce here.
Four and a half stars.

00:29:41.570 --> 00:29:48.070
That looks quality.
So, you know, as you'd expect from any of

00:29:48.070 --> 00:29:51.059
these sorts of sites, it's got a picture,
it's got ratings, phone number, which we can

00:29:51.059 --> 00:29:55.789
use to dial the restaurant and make a booking.
And down at the bottom here, we have a "reserve

00:29:55.789 --> 00:30:03.190
now" button.
If I press that, it opens Open Table, which

00:30:03.190 --> 00:30:07.059
then has a look at the restaurant which we've
typed in, which is Sauce.

00:30:07.059 --> 00:30:12.530
Lets us find a table.
Gives us the options for what times are available.

00:30:12.530 --> 00:30:17.150
We can click that and then make that booking.
I won't make the booking, because there's

00:30:17.150 --> 00:30:20.299
an after party at Google I/O tonight.
So I'm going to go to that instead.

00:30:20.299 --> 00:30:25.730
Just to show these are two separate applications,
we can open Open Table separately from that

00:30:25.730 --> 00:30:30.110
icon there.
So I think that's really cool.

00:30:30.110 --> 00:30:34.789
I think that's something which a lot of applications
can make use of.

00:30:34.789 --> 00:30:37.330
So the question is, how do they go about doing
something like that?

00:30:37.330 --> 00:30:42.249
And it's through using intents, and intents
are one of the most fundamental things about

00:30:42.249 --> 00:30:46.899
Android and the power of it and the way things
actually work, the way you glue together different

00:30:46.899 --> 00:30:52.460
activities in different -- either within your
own application or between multiple applications.

00:30:52.460 --> 00:30:56.389
So using intents, you can share this functionality
and leverage functionality from other people

00:30:56.389 --> 00:31:00.519
the way Where and Open Table have done so
today.

00:31:00.519 --> 00:31:04.779
So rather than just talk about it, I'm going
to show exactly how they go about doing that.

00:31:04.779 --> 00:31:09.639
The way you do it is, you create a new intent.
An intent consists of an action you want to

00:31:09.639 --> 00:31:12.710
perform and some data that you want to perform
that action on.

00:31:12.710 --> 00:31:16.670
Within your own application, you may choose
to start an activity by creating an intent

00:31:16.670 --> 00:31:21.169
that specifies the context and a particular
activity class that you want to load.

00:31:21.169 --> 00:31:25.019
That's what I call like an explicit intent.
You're saying open this activity.

00:31:25.019 --> 00:31:28.270
I know which one it is.
What this demonstrates is a way to create

00:31:28.270 --> 00:31:32.030
an implicit intent.
You're saying, I don't know which application

00:31:32.030 --> 00:31:37.190
can do this, but I want someone to be able
to fulfill this booking action against this

00:31:37.190 --> 00:31:40.750
hotel.
I'm just going to start an activity in the

00:31:40.750 --> 00:31:43.679
hope that someone is able to do that.
There are ways to peek to make sure that an

00:31:43.679 --> 00:31:47.679
activity does exist, to point people to the
market if there's a particular application

00:31:47.679 --> 00:31:51.509
that you would like to suggest to them to
use to fulfill it.

00:31:51.509 --> 00:31:55.900
On the other side, if you had this application
which can fulfill this request, the way that

00:31:55.900 --> 00:32:00.269
you announce that to the system is to add
an intent filter to your activity node in

00:32:00.269 --> 00:32:03.429
the manifest.
And here what you're saying is, I'm capable

00:32:03.429 --> 00:32:07.509
of performing this booking action on this
hotel name data.

00:32:07.509 --> 00:32:14.210
And so you can see when the -- when the previous
application calls this intent, intent resolution

00:32:14.210 --> 00:32:19.700
is going to go through, find this filter,
and it's going to cause this activity to start.

00:32:19.700 --> 00:32:24.840
Within the activity, you can then call get
intent to find the intent that was used to

00:32:24.840 --> 00:32:27.419
start this activity.
So it's going to be this booking intent which

00:32:27.419 --> 00:32:31.879
we had in the previous slides, call get action
and get data to get the action and data to

00:32:31.879 --> 00:32:35.190
confirm that it's the action that you want
to perform.

00:32:35.190 --> 00:32:39.239
Pull out the data, in this case, it will be
the hotel name, and then you can use this

00:32:39.239 --> 00:32:42.679
to populate your form.
In the case of Open Table, that's obviously

00:32:42.679 --> 00:32:45.600
a -- you know, the restaurant name and the
ability to make those bookings.

00:32:45.600 --> 00:32:49.660
It can be something similar or different for
hotels or for any other action that you can

00:32:49.660 --> 00:32:54.869
think of in any other kind of data.
Update the UI, allow the user to complete

00:32:54.869 --> 00:32:58.799
the action, and then when they hit "okay"
or "cancel" you can set a result.

00:32:58.799 --> 00:33:03.070
In this case, we've said okay.
The null parameter there is actually an intent.

00:33:03.070 --> 00:33:09.070
So you can, for example, using the full intent
data, add extras to this calling intent which

00:33:09.070 --> 00:33:13.239
has, say, an affiliate code.
Then you can return an intent which has something,

00:33:13.239 --> 00:33:17.480
for example, a booking reference number.
So you can pass this data backwards and forwards

00:33:17.480 --> 00:33:21.610
beyond just starting a new activity and including
it within your work flow, you can actually

00:33:21.610 --> 00:33:24.119
have data passing between these applications
anonymously.

00:33:24.119 --> 00:33:28.799
And this is really -- this is really powerful.
And to me, this is something that I hope you

00:33:28.799 --> 00:33:32.940
that guys, as -- as beginners to Android,
really have a think about.

00:33:32.940 --> 00:33:37.450
If you're creating an app, if you have some
functionality, how can other people use it?

00:33:37.450 --> 00:33:42.919
How can I expose parts of my work flow to
give another way in for users to be able to

00:33:42.919 --> 00:33:46.890
get access to that, even if they're not launching
my app from the start menu or from the launcher

00:33:46.890 --> 00:33:50.559
or from the home screen.
And at the same time, if you've got an application,

00:33:50.559 --> 00:33:53.119
how can I leverage what other people have
done?

00:33:53.119 --> 00:33:57.629
How can I use that within my own application
to provide users with more functionality?

00:33:57.629 --> 00:34:01.159
So it's -- I think it's really exciting.
I hope it's something that you guys take away

00:34:01.159 --> 00:34:06.539
and have a real think about.
The next virtue is that of ubiquity.

00:34:06.539 --> 00:34:10.760
And for this, I'm going to use one of my own
 -- one of my own applications, just to demonstrate

00:34:10.760 --> 00:34:17.109
the sorts of things that you can do to make
your app more than just an icon on the launcher.

00:34:17.109 --> 00:34:21.159
So, again, you can see the application shortcut.
It's an earthquake.

00:34:21.159 --> 00:34:26.500
What it does is pulls the U.S. geological
society's earthquake RSS feed and gives you

00:34:26.500 --> 00:34:31.579
a list of all of the most recent earthquakes
and what the magnitude was.

00:34:31.579 --> 00:34:35.710
But the reason I want to show it to you today
is just to show the different ways in which

00:34:35.710 --> 00:34:40.179
you can have your application be used by the
user or visible to the user.

00:34:40.179 --> 00:34:44.040
So the first things you'll notice here is,
obviously, we've got two different home screen

00:34:44.040 --> 00:34:46.460
widgets.
We've also got live folders.

00:34:46.460 --> 00:34:52.799
So this "all quakes" small icon on the top
right, if we click that, it's using a content

00:34:52.799 --> 00:34:57.810
provider to give us a list of all of the last
earthquakes which the application has found.

00:34:57.810 --> 00:35:00.330
So, again, users can have that on their home
screen.

00:35:00.330 --> 00:35:03.760
We've also got a shortcut here.
And if we have a look at the status bar, we've

00:35:03.760 --> 00:35:07.980
also got notification.
So at the moment, I have it sent to poll regularly.

00:35:07.980 --> 00:35:11.771
Whenever a new earthquake is detected, it's
going to fire a notification, the same way

00:35:11.771 --> 00:35:17.270
as you would get for e-mail, which, as you
can see, shows the last location time and

00:35:17.270 --> 00:35:21.940
magnitude.
So -- I mean, these are all fairly straightforward

00:35:21.940 --> 00:35:23.500
things.
And they're really easy to do.

00:35:23.500 --> 00:35:28.730
What it does is makes your application more
noticeable, it provides more access points

00:35:28.730 --> 00:35:34.920
for users to get to your application functionality.
So by doing things like creating widgets,

00:35:34.920 --> 00:35:38.880
populating your search results from your own
application into the quick search box, using

00:35:38.880 --> 00:35:44.609
live folders, live wallpapers, notifications,
all of these things, it provides you a way

00:35:44.609 --> 00:35:50.589
to really expand the engagement of your application.
And what we have found is, the more engaged

00:35:50.589 --> 00:35:54.730
people are, the more different ways they find
to interact with your application, the stickier

00:35:54.730 --> 00:35:59.140
it becomes, the less likely they are to want
to install it, the more likely they are to

00:35:59.140 --> 00:36:09.020
find more ways and more opportunities to use
that application.

00:36:09.020 --> 00:36:16.510
So the -- excuse me.
The next virtue I want to cover is that of

00:36:16.510 --> 00:36:20.650
utility.
So you can create and launch almost any application

00:36:20.650 --> 00:36:25.700
that you want to in the Android Market.
It doesn't necessarily mean that you should.

00:36:25.700 --> 00:36:28.980
There are 30,000, or over 30,000 apps in the
market already.

00:36:28.980 --> 00:36:32.599
Which means if you create something, you need
to find a way to stand out.

00:36:32.599 --> 00:36:38.720
That means being useful or being interesting.
Ideally, it's being both.

00:36:38.720 --> 00:36:44.069
So one of the -- one of the applications that
I want to demonstrate for this purpose is

00:36:44.069 --> 00:36:49.570
actually -- it's not particularly exciting,
though, you know, your mileage may vary, I

00:36:49.570 --> 00:36:53.599
suppose.
What it does, it's an app called from (inaudible)

00:36:53.599 --> 00:36:58.670
which is an online grocery store in the U.K.
And I use this to do my shopping so I can

00:36:58.670 --> 00:37:03.380
do it from my home.
What it does, it's fairly straightforward,

00:37:03.380 --> 00:37:09.750
it lets you shop.
And the key to it is that it's a particularly

00:37:09.750 --> 00:37:11.609
useful app.
That's something I need to do, something that

00:37:11.609 --> 00:37:14.839
I don't particularly enjoy doing.
And this app tries to make it as simple for

00:37:14.839 --> 00:37:18.000
me as possible.
One of the features it does is it does all

00:37:18.000 --> 00:37:21.860
of this offline.
So the first thing it does is downloads the

00:37:21.860 --> 00:37:25.510
entire catalogue, which it keeps synched,
and you can, in fact, see the catalogue sync

00:37:25.510 --> 00:37:29.490
starting in the background, which will let
me browse and do my shopping while I'm on

00:37:29.490 --> 00:37:33.421
the underground, which on the U.K. doesn't
have any Wi-Fi or 3G access.

00:37:33.421 --> 00:37:37.261
So I can still do the shopping while I don't
have any Internet connectivity, which is helpful

00:37:37.261 --> 00:37:40.740
for me.
They've also made use of a couple of really

00:37:40.740 --> 00:37:43.180
nice features within Android to make this
even more useful.

00:37:43.180 --> 00:37:54.950
The first is voice search.
So if I hit the microphone icon, bananas.

00:37:54.950 --> 00:38:02.819
Oops.
Come on, Internet.

00:38:02.819 --> 00:38:11.819
You can see that it will search through its
database, and with any luck,

00:38:11.819 --> 00:38:15.230
it will display loading.
No, it will show you some bananas, which is

00:38:15.230 --> 00:38:18.839
helpful.
So this is a great way that I can do my grocery

00:38:18.839 --> 00:38:23.079
shopping while reading through recipes or
wandering through my kitchen and I can just

00:38:23.079 --> 00:38:26.700
hit this button and call out the things that
I want to shop and add them to my basket,

00:38:26.700 --> 00:38:30.730
which I think is really neat.
The final thing I want to demonstrate is bar

00:38:30.730 --> 00:38:33.770
code scanning.
Again, they're using this idea of being able

00:38:33.770 --> 00:38:40.630
to integrate other applications so that, again,
I can just hit -- sorry.

00:38:40.630 --> 00:38:48.549
So it's a box of tomato puree.
So, again, I can hit the bar code button.

00:38:48.549 --> 00:38:55.920
What that's going to do is open up the bar
code scanner, which you can see.

00:38:55.920 --> 00:39:00.750
Which is a third-party application, bar code
scanner, which, hopefully, some of you guys

00:39:00.750 --> 00:39:03.829
have installed for today to do the scavenger
hunt.

00:39:03.829 --> 00:39:08.060
That finds it for me.
Again, these things, they're not -- they're

00:39:08.060 --> 00:39:10.830
not incredible, they're not that exciting,
but they are really useful.

00:39:10.830 --> 00:39:17.040
And what though is demonstrate a need, a utility
which people are going to find useful.

00:39:17.040 --> 00:39:19.339
So that's the key.
If you are creating application, make sure

00:39:19.339 --> 00:39:22.230
that it solves a problem.
Make sure that there's a reason why people

00:39:22.230 --> 00:39:25.990
are going to download it.
It can be something practical, like shopping,

00:39:25.990 --> 00:39:30.040
or it can be something far more pragmatic,
like, I get bored waiting for the train for

00:39:30.040 --> 00:39:33.740
ten minutes every morning, so I want a game
which I can play casually and keep my entertained

00:39:33.740 --> 00:39:36.260
for that period.
That's useful.

00:39:36.260 --> 00:39:39.010
You need to think about ways in which you
can create something which people are going

00:39:39.010 --> 00:39:46.280
to want to use.
The last glorious virtue is an important one.

00:39:46.280 --> 00:39:50.790
So important I kind of needed to invent a
word to make it fit into the slides.

00:39:50.790 --> 00:39:56.180
It's epicness, "icity."
It's being legendary, it's thinking outside

00:39:56.180 --> 00:40:01.210
of the box of creating an app which is a version
of something which you are going to already

00:40:01.210 --> 00:40:05.359
see on a Web site.
The reason why I haven't got an image there

00:40:05.359 --> 00:40:09.319
is because it's stuff which you haven't considered
yet, something that no one has considered.

00:40:09.319 --> 00:40:13.950
It's finding new paradigms and new ways to
use the hardware that haven't been used beforehand.

00:40:13.950 --> 00:40:18.760
So there are some really great examples of
this, of companies which have thought beyond

00:40:18.760 --> 00:40:23.799
these sort of basic ideas, people like Shazam,
which will listen to the ambient music and

00:40:23.799 --> 00:40:27.790
tell you what it is that you're listening
to and give you the opportunity to buy that

00:40:27.790 --> 00:40:31.430
music.
It's Google Goggles is another good example,

00:40:31.430 --> 00:40:34.630
which lets you use the camera to take photos
of things in your surroundings and tell you

00:40:34.630 --> 00:40:40.490
what it is you're looking at.
Or immersive augmented reality, which uses

00:40:40.490 --> 00:40:47.250
the compass, GPS, accelerometers, which lets
you stand where you are and overlay contextual

00:40:47.250 --> 00:40:51.670
information.
These are really great, really innovative

00:40:51.670 --> 00:40:54.981
ways to use this mobile platform.
And it's these sorts of things that you should

00:40:54.981 --> 00:40:58.990
be considering and thinking about how you
can create an app which is going to stand

00:40:58.990 --> 00:41:03.350
out in a market with tens of thousands of
applications.

00:41:03.350 --> 00:41:08.869
So that covers the -- sort of the ten high-level
dos and don'ts.

00:41:08.869 --> 00:41:15.089
What I want to do is spend the next few minutes
covering two specific practical examples of

00:41:15.089 --> 00:41:18.110
areas within Android which I think as beginners
you'll be able to get a lot of out of.

00:41:18.110 --> 00:41:21.789
This is going to be little more technical
and there will be more code.

00:41:21.789 --> 00:41:25.940
If you're not comfortable with code, you can
spend the next ten, 15 minutes wondering why

00:41:25.940 --> 00:41:29.069
you've come to a developers' conference.
[ Laughter ]

00:41:29.069 --> 00:41:34.210
&gt;&gt;Reto Meier: The first thing I want to cover
is services and alarms.

00:41:34.210 --> 00:41:38.900
They go together, or at least they should
do, if you are using them the right way.

00:41:38.900 --> 00:41:41.820
Services are incredibly powerful.
They're what lets you have these background

00:41:41.820 --> 00:41:47.539
data, these applications running in the background.
And because of that, they have the potential

00:41:47.539 --> 00:41:53.180
to -- they give you the potential to commit
four of the -- four of the five sins we talked

00:41:53.180 --> 00:41:58.319
about, so sloth, gluttony, hostility, and
arrogance are all things you need to be cautious

00:41:58.319 --> 00:42:01.090
of and aware of when you're creating your
services.

00:42:01.090 --> 00:42:07.130
So what we're going to do now is have a look
at how you can avoid being "that guy."

00:42:07.130 --> 00:42:10.809
And that guy is the one who creates the app
that's kind of cool, does something useful,

00:42:10.809 --> 00:42:15.460
but you always end up uninstalling it because
it drains all of your battery and you can't

00:42:15.460 --> 00:42:18.549
find a way to turn it off properly and it
doesn't give you any of the options that you

00:42:18.549 --> 00:42:23.710
need to stop draining all of your resources.
So that's what we want to try and avoid.

00:42:23.710 --> 00:42:27.240
These are some of the ways in which you can
go about doing that.

00:42:27.240 --> 00:42:32.420
So I think most of us probably know, hopefully,
the way the application life cycle works,

00:42:32.420 --> 00:42:38.609
that your background services may be killed
by the run time in order to reclaim resources.

00:42:38.609 --> 00:42:44.200
How many of you know what happens next?
Not too many.

00:42:44.200 --> 00:42:46.280
Okay.
So what it does is, the run time is then going

00:42:46.280 --> 00:42:48.990
to restart your service as soon as it possibly
can.

00:42:48.990 --> 00:42:53.690
So it will kill it to gain some resources
for the foreground activity, but it'll try

00:42:53.690 --> 00:42:58.780
to restart it as quickly as it can, often
within a second or within a few seconds, if

00:42:58.780 --> 00:43:02.730
it possibly can.
So that's what happens by default.

00:43:02.730 --> 00:43:06.190
The thing is, as a developer, you know whether
or not that's actually legitimate.

00:43:06.190 --> 00:43:07.990
You know whether or not your service needs
to run.

00:43:07.990 --> 00:43:12.410
So wherever possible, you should tell the
system, "That's actually not required."

00:43:12.410 --> 00:43:20.920
You can do that, as of Android 2, using "on
start" command, which was in services prior

00:43:20.920 --> 00:43:23.930
to 2.
The difference between it is that it lets

00:43:23.930 --> 00:43:28.510
you return a code which tells the run time
exactly how to react to the service being

00:43:28.510 --> 00:43:30.671
killed.
And the return value I want to point you to

00:43:30.671 --> 00:43:35.180
today is start not sticky.
So by returning this, you're telling the run

00:43:35.180 --> 00:43:39.400
time, if this service gets killed, don't restart
it.

00:43:39.400 --> 00:43:43.619
Just let it go.
This is perfect for services which are going

00:43:43.619 --> 00:43:47.690
to be happening on a regular basis.
So if you're polling for updates every ten

00:43:47.690 --> 00:43:52.410
or 15 minutes, if it misses this particular
update, it's probably not that important.

00:43:52.410 --> 00:43:56.390
This is a way for you to be able to work with
the system to keep the system more responsive

00:43:56.390 --> 00:44:00.920
and to keep your app and other apps more responsive.
So that's definitely something you want to

00:44:00.920 --> 00:44:05.190
consider for any service which performs a
single action which gets repeated on a regular

00:44:05.190 --> 00:44:11.630
basis.
Related to that, we talked about background

00:44:11.630 --> 00:44:14.560
services, and there's something similar called
a foreground service.

00:44:14.560 --> 00:44:20.170
What that is is a service which runs still
invisibly to the user, but which is interacting

00:44:20.170 --> 00:44:23.630
with them directly.
So two good examples of that are a music player

00:44:23.630 --> 00:44:27.761
and turn-by-turn navigation.
So if you have an application like that, it

00:44:27.761 --> 00:44:32.859
needs to run in the foreground.
The thing about foreground services is that

00:44:32.859 --> 00:44:35.690
the system treats them the same as it does
foreground activities, which makes it much,

00:44:35.690 --> 00:44:40.590
much less likely for them to get killed, which
means that if you have a number of foreground

00:44:40.590 --> 00:44:44.720
services, it can have a big impact on the
overall system performance.

00:44:44.720 --> 00:44:49.000
The key is to not use them unless you absolutely
have to.

00:44:49.000 --> 00:44:53.550
If you do have them running, you should always
give users the opportunity to first see that

00:44:53.550 --> 00:44:56.780
it's running and, secondly, to find ways in
which to turn it off.

00:44:56.780 --> 00:45:02.849
So if from Android 2 onwards, foreground services
need to have an ongoing notification.

00:45:02.849 --> 00:45:07.809
So I would urge you all, if you are developing
for systems prior to 2.0, to use the ongoing

00:45:07.809 --> 00:45:12.329
notification anyway.
It's a way for users to be able to say, at

00:45:12.329 --> 00:45:16.550
the moment, it's more important for me to
have system resources than to have this application

00:45:16.550 --> 00:45:19.170
running.
It's a really important way of being able

00:45:19.170 --> 00:45:24.450
to not be hostile and to be able to help the
system to manage its resources effectively.

00:45:24.450 --> 00:45:30.410
So we've talked about the way that the run
time can kill background services or help

00:45:30.410 --> 00:45:33.339
the -- how you can help the user to kill foreground
services.

00:45:33.339 --> 00:45:36.589
The more important thing is for you to kill
your own services.

00:45:36.589 --> 00:45:39.541
Services consume resources, they're in the
background.

00:45:39.541 --> 00:45:43.039
They should be running for the smallest amount
of time possible.

00:45:43.039 --> 00:45:48.130
So to stop them running, you call stopself.
So within your activities -- sorry, within

00:45:48.130 --> 00:45:52.950
your services, whenever they complete a task,
and ideally, your services should only be

00:45:52.950 --> 00:45:56.910
running in order to fulfill particular tasks
or if they're bound to an activity.

00:45:56.910 --> 00:45:59.619
So as soon as the activity goes away, they
should be unbound.

00:45:59.619 --> 00:46:04.549
If they're in the background, they should
be completing one task, one action, and then

00:46:04.549 --> 00:46:08.349
call stopself.
So a way to be able to implement this is,

00:46:08.349 --> 00:46:13.200
again, using the async task, which we talked
about, in combination with start not sticky.

00:46:13.200 --> 00:46:18.710
So what we can see here is kicking off an
asynchronous task, that's going to call stop

00:46:18.710 --> 00:46:22.119
self.
So we can ensure this is running for the smallest

00:46:22.119 --> 00:46:26.819
amount of time possible.
The only thing better than making sure your

00:46:26.819 --> 00:46:30.780
services are well managed is not starting
them to begin with.

00:46:30.780 --> 00:46:35.260
In fact, you need to ask yourself, do you
actually need a service for what -- for the

00:46:35.260 --> 00:46:39.950
action which you are trying to perform?
So the question is, what's the alternative?

00:46:39.950 --> 00:46:45.300
And the alternative is alarms and intent receivers.
So intent receivers are a great way to be

00:46:45.300 --> 00:46:50.400
able to make your application much more event-driven.
What we're going to do now is have a look

00:46:50.400 --> 00:46:54.460
at a way that you can use alarms and intent
receivers to replace a service which would

00:46:54.460 --> 00:46:58.160
be running in the background simply to do
regular polling.

00:46:58.160 --> 00:47:00.819
And that's definitely not something that you
want to have.

00:47:00.819 --> 00:47:07.690
So the way you can do this, the way alarms
work is that they let you set an event to

00:47:07.690 --> 00:47:11.361
happen either in the future or on an ongoing
basis in the future.

00:47:11.361 --> 00:47:14.950
An intent receiver is a way that you can say
that you want to listen for something, an

00:47:14.950 --> 00:47:19.710
intent, a broadcast intent, either from your
own application, a third party's, or, indeed,

00:47:19.710 --> 00:47:23.400
the system, and then react accordingly.
So what we're going to look at now is how

00:47:23.400 --> 00:47:26.020
to replace this polling with alarms and intent
receivers.

00:47:26.020 --> 00:47:31.920
So you start off within your application.
You create a new broadcast receiver implementation.

00:47:31.920 --> 00:47:35.809
And with -- "on receive" is where you're going
to perform whatever action you want to have

00:47:35.809 --> 00:47:40.089
happen on a regular basis.
In this instance, we're going to start a service.

00:47:40.089 --> 00:47:43.830
It's going to be the sort of service which
is going to run up, simply do your update,

00:47:43.830 --> 00:47:47.250
and then kill itself.
Once you've created it, you, obviously, need

00:47:47.250 --> 00:47:50.869
to include it in your manifest using the XML
text above.

00:47:50.869 --> 00:47:55.630
And you include an intent filter now which
is going to specify a broadcast intent to

00:47:55.630 --> 00:47:59.079
listen to.
So now whenever the system broadcasts or refreshes

00:47:59.079 --> 00:48:03.770
this intent, your application, my receiver,
is going to get spun up and "on receive" is

00:48:03.770 --> 00:48:07.109
going to get called and this update is going
to happen.

00:48:07.109 --> 00:48:11.450
So how do you get that to happen?
Using alarms.

00:48:11.450 --> 00:48:16.920
So what we've done here is we've created a
new alarm using the alarm manager, which creates

00:48:16.920 --> 00:48:22.289
a new intent, which is refresh this, which
is going to wake up the device every 15 minutes

00:48:22.289 --> 00:48:25.460
and execute this receive handler which we
saw beforehand.

00:48:25.460 --> 00:48:30.780
Now, this is really neat, because this all
happens even if your application is totally

00:48:30.780 --> 00:48:33.000
not running.
So if it's been killed, once you set these

00:48:33.000 --> 00:48:37.420
alarms, they will continue to happen without
your application having to run in the background,

00:48:37.420 --> 00:48:41.349
consuming resources.
There is a risk with this particular implementation,

00:48:41.349 --> 00:48:43.570
though.
I'm sure you can probably spot what it is.

00:48:43.570 --> 00:48:48.839
If you've got ten applications, each of which
set one of these repeating alarms to happen

00:48:48.839 --> 00:48:53.650
every 15 minutes and it takes about a minute
for it to complete this update, you're going

00:48:53.650 --> 00:48:57.790
to end up with your phone on constantly while
it's performing the updates for all of these

00:48:57.790 --> 00:49:01.150
different applications.
So there is a solution for this.

00:49:01.150 --> 00:49:05.829
And that's using inexact alarms.
Inexact alarms work almost exactly the same

00:49:05.829 --> 00:49:10.000
way, but instead of calling set repeating,
you call set inexact repeating.

00:49:10.000 --> 00:49:14.180
What this does is lets the system phase-shift
these alarms which are all going to happen

00:49:14.180 --> 00:49:17.609
at close to the same time to happen at the
same time.

00:49:17.609 --> 00:49:22.089
So rather than 15 alarms happening over the
course of 15 minutes, you have them all happen

00:49:22.089 --> 00:49:26.720
at the same time or very close to each other
in a way that the system is able to optimize.

00:49:26.720 --> 00:49:29.470
So this is going to have a dramatic impact
on your resource usage.

00:49:29.470 --> 00:49:33.690
If you have something which needs to happen
regularly but doesn't have to happen exactly,

00:49:33.690 --> 00:49:41.000
use inexact repeating rather than repeating.
So very quickly, before I run out of time

00:49:41.000 --> 00:49:43.470
entirely, I want to have a quick look at location-based
services.

00:49:43.470 --> 00:49:48.840
This is something that's really fundamental
to the way mobile apps work.

00:49:48.840 --> 00:49:52.779
Location context is really important.
It's also really important to get wrong.

00:49:52.779 --> 00:49:56.740
So this is a really simple implementation
of a location listener.

00:49:56.740 --> 00:50:00.240
Those of you who have played around with this
beforehand can probably spot the problems

00:50:00.240 --> 00:50:05.680
a mile off.
What we are doing wrong is, when we request

00:50:05.680 --> 00:50:09.260
our location updates, we're not having any
limits on frequency of those updates.

00:50:09.260 --> 00:50:13.401
So this is saying, no matter how much time
has passed since the last one, even if it

00:50:13.401 --> 00:50:18.260
was half a second ago, even if the user hasn't
moved, every time the GPS gets a new signal,

00:50:18.260 --> 00:50:23.440
I want to fire my code.
What's more, we're specifying the GPS explicitly.

00:50:23.440 --> 00:50:25.660
Even worse, we're doing that using a string
literal.

00:50:25.660 --> 00:50:32.260
So how do we improve that?
So these are some of the things that we need

00:50:32.260 --> 00:50:35.589
to be looking at.
How often do we need to get these updates?

00:50:35.589 --> 00:50:39.130
Do we need to use a specific provider?
And what happens if that provider isn't available

00:50:39.130 --> 00:50:42.839
in how accurate do we need to be?
What's the impact of all of these things going

00:50:42.839 --> 00:50:47.240
to be on our battery life?
And what happens in the case of GPS when it's

00:50:47.240 --> 00:50:52.210
going to be jumpy at the beginning?
How do we create that instant positive user

00:50:52.210 --> 00:50:57.010
experience where they don't have to wait for
a GPS to settle?

00:50:57.010 --> 00:50:58.890
So the first thing we want to do is restrict
those updates.

00:50:58.890 --> 00:51:02.770
It's one of the fundamental things we talked
about earlier on, is limiting the number of

00:51:02.770 --> 00:51:05.869
updates.
Right here, it's quite simply, we've specified

00:51:05.869 --> 00:51:10.270
a minimum frequency, which is -- or maximum
frequency, I should say, which is saying we

00:51:10.270 --> 00:51:12.970
don't need updates any more often than every
five minutes.

00:51:12.970 --> 00:51:17.430
And we don't really need to know if they've
gone anything less than a kilometer.

00:51:17.430 --> 00:51:20.950
So we can put that in really easily.
That's already going to make a dramatic difference

00:51:20.950 --> 00:51:29.000
to letting the system manage that GPS resource.
Next, we want to remove that GPS.

00:51:29.000 --> 00:51:33.039
So we definitely don't want a string literal.
We don't even want to specify a particular

00:51:33.039 --> 00:51:34.930
provider.
We don't know what's going to come out in

00:51:34.930 --> 00:51:38.180
the future, we don't know what the user has
enabled and what their preferences are.

00:51:38.180 --> 00:51:43.240
By using the "criteria" class, we can specify
the power consumption that we're after, the

00:51:43.240 --> 00:51:48.049
accuracy that we require, and a number of
other hardware requirements that we do or

00:51:48.049 --> 00:51:51.339
don't need.
So by doing this, we're able to ask the location

00:51:51.339 --> 00:51:55.339
manager to get us the best provider based
on what's currently active and available on

00:51:55.339 --> 00:51:57.890
the system.
And that's going to have -- that's going to

00:51:57.890 --> 00:52:00.430
make sure that we can do a lot of things.
That's going to make sure that we always have

00:52:00.430 --> 00:52:04.270
the best provider for the current situation.
It's going to make sure that we only have

00:52:04.270 --> 00:52:09.089
active providers so we're not left with not
being able to get location at all just because

00:52:09.089 --> 00:52:12.240
the user isn't using GPS and that's what we
would prefer.

00:52:12.240 --> 00:52:18.220
So now we've got a much more efficient solution.
And we need to think about what the implications

00:52:18.220 --> 00:52:22.750
are for your actual app.
So one of those things is what I mentioned

00:52:22.750 --> 00:52:26.460
a little bit earlier on is GPS.
When you start up a GPS, it will bounce around.

00:52:26.460 --> 00:52:32.520
You'll have to wait sometimes minutes until
it's a nice, solid, accurate value.

00:52:32.520 --> 00:52:36.930
So one solution to this is to implement a
backoff pattern where you're using multiple

00:52:36.930 --> 00:52:42.609
location listeners so you can get a result
and as accurate a result as possible before

00:52:42.609 --> 00:52:47.779
you're going to back off and let the system
use the much more managed, infrequent update

00:52:47.779 --> 00:52:51.150
approach that we talked about.
So how does that look?

00:52:51.150 --> 00:52:54.710
So it works much the same way.
So the first thing we're going to do is create

00:52:54.710 --> 00:52:59.500
a location listener for our best provider,
the one which uses the criteria we specified

00:52:59.500 --> 00:53:02.510
and has the -- the maximum frequency and distance
requirements.

00:53:02.510 --> 00:53:07.710
We're also going to implement two location
listeners, one for a course provider and one

00:53:07.710 --> 00:53:12.390
for a -- one for a bounce provider, which
is going to take care of the GPS sort of stuff.

00:53:12.390 --> 00:53:17.970
And both of those are going to have no restrictions.
And this is what it's going to look like in

00:53:17.970 --> 00:53:20.079
code.
We're going to have a look at the on location

00:53:20.079 --> 00:53:24.440
change for the course listener at the bottom.
It's going to say, well, I'm going to assume

00:53:24.440 --> 00:53:28.819
that the course listener, which is going to
going to be the Wi-Fi cell ID approach, is

00:53:28.819 --> 00:53:32.349
going to be able to give us something quickly
albeit not particularly accurately.

00:53:32.349 --> 00:53:35.640
I want to grab that and use it so the user
at least has something.

00:53:35.640 --> 00:53:38.361
But only once.
Then we're going to use the bounce provider

00:53:38.361 --> 00:53:43.630
to say, look, I want every update from the
GPS until it gets better than within sort

00:53:43.630 --> 00:53:47.740
of ten meters of accuracy.
At that point, I'm willing to fall back to

00:53:47.740 --> 00:53:52.640
our more managed approach.
So this should be able to give us a location

00:53:52.640 --> 00:53:57.410
as quickly as possible, and then rapidly sort
of scale down once we increase the accuracy

00:53:57.410 --> 00:54:03.700
of our GPS receiver.
So, finally, to summarize, hopefully, by the

00:54:03.700 --> 00:54:07.190
end of today or the end of this session, and
certainly there's a lot of other Android sessions

00:54:07.190 --> 00:54:10.550
over the next two days that will hopefully
help you to do this, but we want you to be

00:54:10.550 --> 00:54:14.940
good developers, not lazy developers.
Think about performance and how it's going

00:54:14.940 --> 00:54:19.240
to impact your application.
Think about the user experience, respect your

00:54:19.240 --> 00:54:24.279
users, respect the system, and think big.
Think about how you can create something beyond

00:54:24.279 --> 00:54:26.519
what's already been done.
So thank you very much.

00:54:26.519 --> 00:54:27.519
[ Applause ]
I'm not sure if we have time for questions.

00:54:27.519 --> 00:54:28.519
Not at all.
So what I am going to do is, if you have questions,

00:54:28.519 --> 00:54:29.519
check out the Wave link.
There is a moderator.

00:54:29.519 --> 00:54:30.519
You will be able to post questions there.
I will make sure that all of those get added.

00:54:30.519 --> 00:54:31.519
There's also developer.android.com and a number
of other things.

00:54:31.519 --> 00:54:31.523
So enjoy your lunch.

