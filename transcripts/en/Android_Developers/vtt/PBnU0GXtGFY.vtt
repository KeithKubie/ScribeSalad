WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.814
[MUSIC PLAYING]

00:00:04.655 --> 00:00:07.030
JENNY YUEN: I've been doing
Android for about four years.

00:00:07.030 --> 00:00:11.620
So I'll tell you a little
bit about the story of how

00:00:11.620 --> 00:00:13.370
Facebook as a
company transitioned

00:00:13.370 --> 00:00:18.370
from having a small mobile
team to a company that focuses

00:00:18.370 --> 00:00:21.950
on mobile as a first priority.

00:00:21.950 --> 00:00:24.680
So let me start
with a story here.

00:00:24.680 --> 00:00:31.620
Back around 2010, 2011,
Facebook had a very, very small

00:00:31.620 --> 00:00:32.159
mobile team.

00:00:32.159 --> 00:00:36.260
For some context, if you
guys don't know about this,

00:00:36.260 --> 00:00:38.050
Facebook started in 2004.

00:00:38.050 --> 00:00:39.980
It started as a web application.

00:00:39.980 --> 00:00:47.670
And then with transition--
with large number of devices

00:00:47.670 --> 00:00:50.580
appearing in the market
and mobile being a very

00:00:50.580 --> 00:00:54.950
important thing, Facebook
started a mobile team.

00:00:54.950 --> 00:00:59.520
Around 2010, 2011, 11 which
is when I joined Facebook,

00:00:59.520 --> 00:01:00.840
we still had a mobile team.

00:01:00.840 --> 00:01:03.570
And we realized, well
it doesn't really

00:01:03.570 --> 00:01:07.001
make much sense on how to
scale our app if we have

00:01:07.001 --> 00:01:08.750
a mobile team, and the
rest of the company

00:01:08.750 --> 00:01:10.990
is focusing on our
desktop application.

00:01:10.990 --> 00:01:14.870
We had product developers,
project managers,

00:01:14.870 --> 00:01:22.190
and product designers for
each feature in our website,

00:01:22.190 --> 00:01:24.020
focusing only on www.

00:01:24.020 --> 00:01:29.860
And we had a team that had
probably a dozen developers

00:01:29.860 --> 00:01:31.870
focusing on
everything on mobile.

00:01:31.870 --> 00:01:33.216
Well, so what do we do?

00:01:33.216 --> 00:01:35.090
We realized that this
was not going to scale,

00:01:35.090 --> 00:01:38.180
and we started building a bunch
of these experiences in mobile.

00:01:38.180 --> 00:01:40.690
And as we finished
building them,

00:01:40.690 --> 00:01:44.960
we transitioned the ownership
to each of the product teams.

00:01:44.960 --> 00:01:47.600
We continue doing so.

00:01:47.600 --> 00:01:51.380
As of today, we no
longer have mobile teams.

00:01:51.380 --> 00:01:53.839
So if you guys come
and ask us, hey,

00:01:53.839 --> 00:01:55.880
what is the size of your
mobile team at Facebook,

00:01:55.880 --> 00:02:01.100
we just say the whole company
is focusing on mobile.

00:02:01.100 --> 00:02:03.890
I really want to emphasize this.

00:02:03.890 --> 00:02:05.620
So what happens here?

00:02:05.620 --> 00:02:09.860
When we transition our company
into focusing fully on mobile,

00:02:09.860 --> 00:02:11.590
we're injecting
hundreds of developers

00:02:11.590 --> 00:02:13.199
into each of our
mobile code bases.

00:02:13.199 --> 00:02:14.740
There a lot of
interesting challenges

00:02:14.740 --> 00:02:15.840
that arise from this.

00:02:15.840 --> 00:02:19.150
So I'll tell you a couple
stories around this.

00:02:19.150 --> 00:02:28.350
So that's in the context of our
engineering size and culture.

00:02:28.350 --> 00:02:31.930
But let's look at it from the
other point of view, our users.

00:02:31.930 --> 00:02:36.900
As of today, we have 1.3
billion mobile monthly actives.

00:02:36.900 --> 00:02:41.790
And they are using our
app all over the world

00:02:41.790 --> 00:02:45.460
under different
network conditions.

00:02:45.460 --> 00:02:48.000
You guys know about the
Android fragmentation problem.

00:02:48.000 --> 00:02:51.175
It's a benefit, but also it's
an interesting challenge.

00:02:51.175 --> 00:02:53.860
That means that there
are lots of people

00:02:53.860 --> 00:02:58.740
in the world that
are able to have

00:02:58.740 --> 00:03:00.690
internet connected devices now.

00:03:00.690 --> 00:03:02.360
And because of
this, we're building

00:03:02.360 --> 00:03:05.780
the-- we're in a really, really
good position where we're

00:03:05.780 --> 00:03:07.280
building the
application that allows

00:03:07.280 --> 00:03:11.840
them to connect with the world
and their friends and family.

00:03:11.840 --> 00:03:17.440
So this is a graph
of the projection

00:03:17.440 --> 00:03:21.690
of internet connected devices
in the next couple of years.

00:03:21.690 --> 00:03:24.560
It's made by this third
party company called IDC.

00:03:24.560 --> 00:03:28.990
And here I'm separating,
in the yellow section,

00:03:28.990 --> 00:03:33.700
the developed markets, and the
blue ones, emerging markets.

00:03:33.700 --> 00:03:38.930
Now, that sharp, sharp
ramp up, that sharp graph

00:03:38.930 --> 00:03:42.350
indicates that in the
next couple of years,

00:03:42.350 --> 00:03:44.990
we will have a ton of
users coming injected

00:03:44.990 --> 00:03:46.115
into the Android ecosystem.

00:03:46.115 --> 00:03:48.323
And they're not going to
have phones like the ones we

00:03:48.323 --> 00:03:49.220
have in our pockets.

00:03:49.220 --> 00:03:53.220
They're going to have phones
that probably have helped

00:03:53.220 --> 00:03:58.030
the hardware set that back
in probably three years ago

00:03:58.030 --> 00:03:59.690
were the newest
phone that we had.

00:03:59.690 --> 00:04:02.210
So we have a lot of interesting
engineering challenges

00:04:02.210 --> 00:04:04.170
to handle here.

00:04:04.170 --> 00:04:07.830
And because of this, we need
as many developers in Facebook

00:04:07.830 --> 00:04:11.310
to be tackling this, not just
a mobile team, obviously.

00:04:11.310 --> 00:04:14.670
So today, I'm going to
tell you about, broadly,

00:04:14.670 --> 00:04:16.170
mobile at Facebook.

00:04:16.170 --> 00:04:19.510
And I could keep talking over
and over for hours about this.

00:04:19.510 --> 00:04:22.310
I've picked a couple
selected topics here.

00:04:22.310 --> 00:04:24.870
First, I guess the
complex is, we have 1.3

00:04:24.870 --> 00:04:26.450
billion mobile monthly actives.

00:04:26.450 --> 00:04:29.270
And this number is
growing every single day.

00:04:29.270 --> 00:04:30.527
What do we do about this?

00:04:30.527 --> 00:04:31.360
How do we handle it?

00:04:31.360 --> 00:04:34.110
Where are the interesting
problems that arise?

00:04:34.110 --> 00:04:37.010
We also want to make sure that
we ship really, really fast.

00:04:37.010 --> 00:04:40.220
Just because we have a ton
of devices and a ton of users

00:04:40.220 --> 00:04:43.090
does not mean that we should
be slowing ourselves down.

00:04:43.090 --> 00:04:45.530
We ship an APK every week now.

00:04:48.724 --> 00:04:51.140
Many of you guys, as you guys
are Android developers here,

00:04:51.140 --> 00:04:52.630
you realize it's
actually really,

00:04:52.630 --> 00:04:54.814
really tough to do this.

00:04:54.814 --> 00:04:56.230
In addition to
that, we have a ton

00:04:56.230 --> 00:04:57.690
of features in one single app.

00:04:57.690 --> 00:04:59.570
We have a ton of developers.

00:04:59.570 --> 00:05:01.640
Our app is feature packed.

00:05:01.640 --> 00:05:06.420
How do we do it so that we do
this in a very reliable manner?

00:05:06.420 --> 00:05:08.490
On Android, native
clients in particular,

00:05:08.490 --> 00:05:10.390
we have a very low
tolerance for error.

00:05:10.390 --> 00:05:12.910
We're dealing with state,
memory, networking,

00:05:12.910 --> 00:05:17.240
a lot of these things
that are very, very

00:05:17.240 --> 00:05:20.370
tricky to deal with in a very,
very constrained environment.

00:05:20.370 --> 00:05:23.580
And once we actually
ship something out,

00:05:23.580 --> 00:05:25.820
we can't assume that
with the next release,

00:05:25.820 --> 00:05:27.470
no one will be
seeing this version.

00:05:27.470 --> 00:05:29.300
We have a very low
tolerance for error.

00:05:29.300 --> 00:05:32.060
So I'm going to tell you
a couple stories about how

00:05:32.060 --> 00:05:34.190
Facebook handle a bunch
of these problems while

00:05:34.190 --> 00:05:37.540
scaling in size and speed.

00:05:37.540 --> 00:05:39.360
So, two ways.

00:05:39.360 --> 00:05:41.910
First I'm going to talk
about coding at scale.

00:05:41.910 --> 00:05:43.610
And the second part
is how we release

00:05:43.610 --> 00:05:48.190
to the world in a very fast,
speedy, and reliable manner.

00:05:48.190 --> 00:05:50.790
So let's talk about
coding at scale.

00:05:50.790 --> 00:05:54.450
So I guess story time.

00:05:54.450 --> 00:05:57.770
Around 2011 when I
started Facebook,

00:05:57.770 --> 00:05:59.430
this was also
coincidentally the time

00:05:59.430 --> 00:06:01.600
when we were
transitioning from having

00:06:01.600 --> 00:06:05.940
just some small
core mobile teams

00:06:05.940 --> 00:06:10.150
and having the whole company
jump in and do Android and iOS

00:06:10.150 --> 00:06:11.740
development.

00:06:11.740 --> 00:06:13.850
So was it as easy as it sounds?

00:06:13.850 --> 00:06:14.680
Obviously not.

00:06:14.680 --> 00:06:16.160
It was actually really scary.

00:06:16.160 --> 00:06:20.390
I remember almost like, in
my mind, almost overnight,

00:06:20.390 --> 00:06:23.690
the code base had transitioned
from probably a dozen engineers

00:06:23.690 --> 00:06:25.910
to hundreds, probably
a hundred engineers.

00:06:25.910 --> 00:06:26.910
I'm probably overacting.

00:06:26.910 --> 00:06:28.240
It was probably like so many.

00:06:28.240 --> 00:06:29.910
But still a lot.

00:06:29.910 --> 00:06:33.030
So how did this affect my life?

00:06:33.030 --> 00:06:34.450
You could never build.

00:06:34.450 --> 00:06:35.667
Everything was crashy.

00:06:35.667 --> 00:06:38.000
When you thought your feature,
when you finished writing

00:06:38.000 --> 00:06:42.420
your code, nothing worked.

00:06:42.420 --> 00:06:46.660
So obviously we realized
developer efficiency

00:06:46.660 --> 00:06:50.560
was going to be affected
by having a lot of people

00:06:50.560 --> 00:06:52.210
writing a lot of code.

00:06:52.210 --> 00:06:54.620
So we realized that we had
to make some infrastructure

00:06:54.620 --> 00:06:57.630
changes and cultural changes
for this to work out.

00:06:57.630 --> 00:06:59.290
You can't just
transition from having

00:06:59.290 --> 00:07:02.730
12 engineers to a
hundred in one day

00:07:02.730 --> 00:07:05.030
and not expect hiccups here.

00:07:05.030 --> 00:07:06.730
So we realized,
well first we need

00:07:06.730 --> 00:07:10.630
to create an environment that
enforces testing, and also

00:07:10.630 --> 00:07:16.930
makes it easy to write more
tests, just avoid brittle code.

00:07:16.930 --> 00:07:19.380
And the second part is we
need to break dependencies

00:07:19.380 --> 00:07:20.910
amongst the different teams.

00:07:20.910 --> 00:07:21.790
What does that mean?

00:07:21.790 --> 00:07:25.160
If I'm working on News Feed and
something on the photo upload

00:07:25.160 --> 00:07:29.240
flow breaks or is
using a lot of memory,

00:07:29.240 --> 00:07:31.787
me as a News Feed engineer, I
should not be blocked by that.

00:07:31.787 --> 00:07:33.370
And I should be able
to build my code,

00:07:33.370 --> 00:07:36.860
and you should be
able to deploy it.

00:07:36.860 --> 00:07:38.360
So what did we do?

00:07:38.360 --> 00:07:41.350
So we started using
dependency injection.

00:07:41.350 --> 00:07:43.700
So many of you guys are
probably familiar with this.

00:07:43.700 --> 00:07:45.940
But for those who are
not, dependency injection

00:07:45.940 --> 00:07:49.680
is a design pattern
for externally setting

00:07:49.680 --> 00:07:52.210
object dependencies and
separating the creation

00:07:52.210 --> 00:07:53.720
versus the behavior.

00:07:53.720 --> 00:07:56.290
What this does, naturally,
is that it encourages

00:07:56.290 --> 00:08:00.297
modularity and testability.

00:08:00.297 --> 00:08:02.630
You guys are probably familiar
with dependency injection

00:08:02.630 --> 00:08:05.640
frameworks like Dagger
for instance and Guice.

00:08:05.640 --> 00:08:09.630
Back in 2011, Dagger was not
available as an open source

00:08:09.630 --> 00:08:13.800
framework, and Guice was
giving us performance problem.

00:08:13.800 --> 00:08:15.680
So we developed our
own internal one.

00:08:15.680 --> 00:08:21.350
But the inspiration and the
same principles still apply.

00:08:21.350 --> 00:08:23.080
Now let me give an
example for those

00:08:23.080 --> 00:08:24.660
who are not familiar with this.

00:08:24.660 --> 00:08:27.980
The idea is, let's say
I'm creating a method that

00:08:27.980 --> 00:08:29.480
fetches data for my News Feed.

00:08:29.480 --> 00:08:31.060
Let's call it NewsFeedFetcher.

00:08:31.060 --> 00:08:33.750
And it requires a lot
of different objects,

00:08:33.750 --> 00:08:36.940
say an HttpRequestHelper
so that you can fetch

00:08:36.940 --> 00:08:40.490
something, some
sort of JsonParser,

00:08:40.490 --> 00:08:42.370
and some sort of
ImageDownloader.

00:08:42.370 --> 00:08:45.430
All of those are
modular classes that

00:08:45.430 --> 00:08:48.760
perform separate objectives.

00:08:48.760 --> 00:08:53.150
So one way to construct this
dependency in a nice manner

00:08:53.150 --> 00:08:57.490
is just within your constructor
or within your main method.

00:08:57.490 --> 00:08:59.760
And within your class,
initialize them.

00:08:59.760 --> 00:09:04.790
Called new HttpRequestHelper,
new parser, downloader,

00:09:04.790 --> 00:09:06.370
et cetera.

00:09:06.370 --> 00:09:09.600
So what happens here?

00:09:09.600 --> 00:09:13.270
So the problem in
that case is that you

00:09:13.270 --> 00:09:15.460
tangle a lot of
dependency creation

00:09:15.460 --> 00:09:16.870
together with the objects.

00:09:16.870 --> 00:09:18.870
And it's really,
really hard to test it.

00:09:18.870 --> 00:09:21.130
So with dependency
injection, the idea

00:09:21.130 --> 00:09:23.259
is that rather than
creating your dependencies,

00:09:23.259 --> 00:09:25.050
you're going to assume
that they get passed

00:09:25.050 --> 00:09:27.780
to you by some god
like injector class,

00:09:27.780 --> 00:09:30.340
or just get passed you
by the constructor.

00:09:30.340 --> 00:09:33.090
And you get this
@Inject annotation.

00:09:33.090 --> 00:09:34.990
What this @Inject
annotation does

00:09:34.990 --> 00:09:37.890
is it goes through all of the
methods that were annotated

00:09:37.890 --> 00:09:43.100
like this, and creates an
injector global object,

00:09:43.100 --> 00:09:47.150
a singleton, that when we're
asking for a particular object,

00:09:47.150 --> 00:09:53.010
FetchNewsFeedMethod, will
pass all of these objects

00:09:53.010 --> 00:09:54.960
during instantiation time.

00:09:54.960 --> 00:09:58.520
And it will also, if you
want just one instance of it,

00:09:58.520 --> 00:10:01.814
it will hold that instance,
and we won't recreate it.

00:10:01.814 --> 00:10:03.230
What is the nice
thing about this?

00:10:03.230 --> 00:10:05.950
If you're writing tests, you
can pass fake versions of it.

00:10:05.950 --> 00:10:07.800
You keep a very clean interface.

00:10:07.800 --> 00:10:12.160
And the other part is that
you can build your own module,

00:10:12.160 --> 00:10:15.209
and then connect it to
the other ones as part

00:10:15.209 --> 00:10:17.250
of the final version when
deploying and compiling

00:10:17.250 --> 00:10:20.090
the app.

00:10:20.090 --> 00:10:23.640
So this encourages
testability, code modularity,

00:10:23.640 --> 00:10:25.841
and also helps us
scale our code base.

00:10:29.360 --> 00:10:31.380
And this is obviously
really, really important

00:10:31.380 --> 00:10:37.440
when you have tons of developers
writing code at the same time.

00:10:37.440 --> 00:10:41.940
So one of the problems
here is performance.

00:10:41.940 --> 00:10:44.620
Let me illustrate why
performance is a problem.

00:10:44.620 --> 00:10:48.090
It lies on the area of
dependency resolution.

00:10:48.090 --> 00:10:50.940
So at run time, because
you don't really

00:10:50.940 --> 00:10:53.290
know who are the
objects that you're

00:10:53.290 --> 00:10:56.020
going to be depending
on, we realize OK, you

00:10:56.020 --> 00:10:59.240
hook that NewsFeedFetcher
to this HttpRequestHelper,

00:10:59.240 --> 00:11:00.800
this parser, and
this downloader.

00:11:00.800 --> 00:11:03.530
It's not until you initialize
the app during cold start

00:11:03.530 --> 00:11:05.789
that you are doing
all of the stuff.

00:11:05.789 --> 00:11:07.330
This takes us to a
different problem.

00:11:07.330 --> 00:11:08.950
In order to have all
this flexibility,

00:11:08.950 --> 00:11:11.810
our cold start time is just
going through the roof.

00:11:11.810 --> 00:11:13.990
So what do we do here?

00:11:13.990 --> 00:11:16.590
So we can actually switch
all of this to compile time.

00:11:16.590 --> 00:11:18.830
But if we hard
coded everything, we

00:11:18.830 --> 00:11:20.410
would go back into
the old method

00:11:20.410 --> 00:11:22.920
where everything felt
wired and static.

00:11:22.920 --> 00:11:26.880
And we wouldn't be able to
write tests in an easy manner.

00:11:26.880 --> 00:11:31.300
So one of the
engineers at Facebook

00:11:31.300 --> 00:11:34.440
thought, OK, instead, we should
look at the Java bytecode

00:11:34.440 --> 00:11:37.760
and modify it at compile
time to substitute

00:11:37.760 --> 00:11:42.310
the creators of this
providers into static methods,

00:11:42.310 --> 00:11:44.300
and actually wire them
to the final versions.

00:11:44.300 --> 00:11:46.758
And when you're doing tests,
you still get the flexibility.

00:11:49.680 --> 00:11:54.350
At the end of the day, we
reduce start up time by 20%.

00:11:54.350 --> 00:11:56.790
And you do all these
operations at compile time,

00:11:56.790 --> 00:11:59.550
which happen offline.

00:11:59.550 --> 00:12:03.770
So that's just one example
of how we actually broke down

00:12:03.770 --> 00:12:05.990
a lot of our development
process, what

00:12:05.990 --> 00:12:07.620
type of infrastructure
that we actually

00:12:07.620 --> 00:12:09.480
put in place so that
we could move really

00:12:09.480 --> 00:12:11.040
fast in an independent manner.

00:12:14.640 --> 00:12:18.390
Here's an example of a diff
that we send out for review.

00:12:18.390 --> 00:12:20.860
A lot of the internal
details are blurred here

00:12:20.860 --> 00:12:22.730
for confidentiality purposes.

00:12:22.730 --> 00:12:24.630
But what I want you
to pay attention to

00:12:24.630 --> 00:12:27.970
is the green and
red blocks here.

00:12:27.970 --> 00:12:29.910
Every time we send
a diff for review,

00:12:29.910 --> 00:12:32.940
we run a lot of tests,
both unit, end to end,

00:12:32.940 --> 00:12:34.900
and screenshot test.

00:12:34.900 --> 00:12:38.860
This help us prevent
brittle code.

00:12:38.860 --> 00:12:41.320
And if we create
the right framework

00:12:41.320 --> 00:12:44.690
for the different teams to
start being able to write code,

00:12:44.690 --> 00:12:47.760
we will be able to identify
a bunch of these failures

00:12:47.760 --> 00:12:52.144
before we even land the
code so that our trunk is

00:12:52.144 --> 00:12:53.060
in a healthier manner.

00:12:57.310 --> 00:13:01.390
So the other part,
another trick that we

00:13:01.390 --> 00:13:03.260
found that was very,
very useful when

00:13:03.260 --> 00:13:08.740
scaling our mobile organization
is identifying common APIs.

00:13:08.740 --> 00:13:12.320
Let me tell you one
example of a case study.

00:13:12.320 --> 00:13:14.830
So if you're working on
a feature at Facebook,

00:13:14.830 --> 00:13:17.140
there's chances that
you'll be needing

00:13:17.140 --> 00:13:20.770
to download some
data from the cloud,

00:13:20.770 --> 00:13:26.370
cache it somehow locally, and
show it in some sort of UI.

00:13:26.370 --> 00:13:30.260
So this obviously involves
writing some sort of code.

00:13:30.260 --> 00:13:34.460
And, well, the reality is
that we have a lot of features

00:13:34.460 --> 00:13:36.689
and a lot of engineers,
and each of them

00:13:36.689 --> 00:13:37.730
writes their own version.

00:13:40.290 --> 00:13:42.160
You might be wondering,
why can't this

00:13:42.160 --> 00:13:44.100
be abstracted into
a common library?

00:13:44.100 --> 00:13:47.125
Well, let's think about the
case of fetching your News

00:13:47.125 --> 00:13:51.380
Feed versus fetching photos,
fetching events, et cetera.

00:13:51.380 --> 00:13:57.090
The structure of your query
changes drastically depending

00:13:57.090 --> 00:13:58.540
on what you're trying to do.

00:13:58.540 --> 00:14:03.650
So there is some sort of custom
code that has to be written.

00:14:05.370 --> 00:14:07.250
You can call a general
HTTP library, you

00:14:07.250 --> 00:14:10.760
but you still have to
construct the parameters

00:14:10.760 --> 00:14:13.630
that you're asking-- the
API call with the parameters

00:14:13.630 --> 00:14:15.790
that you want.

00:14:15.790 --> 00:14:17.470
So this happen across the board.

00:14:17.470 --> 00:14:19.750
And at some point,
one of our engineers

00:14:19.750 --> 00:14:25.570
decided hey, this
underlying API method call,

00:14:25.570 --> 00:14:27.330
I'd like to optimize it.

00:14:27.330 --> 00:14:29.810
But then he realized,
uh oh, in order

00:14:29.810 --> 00:14:32.970
to make an optimization
to the fetching mechanism,

00:14:32.970 --> 00:14:35.390
you have to change every
single line of code

00:14:35.390 --> 00:14:37.202
in many, many
different products.

00:14:37.202 --> 00:14:39.160
And when you do that, it
doesn't come for free.

00:14:39.160 --> 00:14:40.160
This is not that simple.

00:14:40.160 --> 00:14:42.730
You could be breaking
some other product code.

00:14:42.730 --> 00:14:44.800
And people get pissed,
and it's actually really,

00:14:44.800 --> 00:14:45.840
really tedious.

00:14:45.840 --> 00:14:48.420
So one of the ideas
that we came up with

00:14:48.420 --> 00:14:52.990
is instead, write a small
snippet of what you're

00:14:52.990 --> 00:14:56.780
trying to-- in a small
snippet of a text file,

00:14:56.780 --> 00:14:59.740
specify what you're going to
try to download from the server.

00:14:59.740 --> 00:15:05.400
And have a library autogenerate
the actual API method calls

00:15:05.400 --> 00:15:08.390
from that templated version.

00:15:08.390 --> 00:15:11.970
What this does is this
allows for making changes

00:15:11.970 --> 00:15:16.980
in the particular underlying
architecture to be much easier

00:15:16.980 --> 00:15:22.080
and not affect that much
of the product internals.

00:15:22.080 --> 00:15:26.570
So the engineers that work
on this type of optimizations

00:15:26.570 --> 00:15:29.150
and developer APIs at
Facebook are called product

00:15:29.150 --> 00:15:31.000
infrastructure engineers.

00:15:31.000 --> 00:15:34.380
And their objective is to make
it easier for product teams

00:15:34.380 --> 00:15:36.535
to develop faster.

00:15:39.400 --> 00:15:42.930
So I guess that's kind of my
high level overview of how

00:15:42.930 --> 00:15:45.010
Facebook as an
organization has scaled

00:15:45.010 --> 00:15:48.590
from having a small
group of engineers

00:15:48.590 --> 00:15:54.467
working on mobile to the
whole company touching it.

00:15:54.467 --> 00:15:56.050
Now I'm going to
switch gears and talk

00:15:56.050 --> 00:15:58.840
a little bit about how we
release our app into the world.

00:16:01.500 --> 00:16:04.670
So if you guys were
at the talk yesterday

00:16:04.670 --> 00:16:07.770
on emerging markets
for Facebook,

00:16:07.770 --> 00:16:11.010
we talked about how we have
over 10,000 different Android

00:16:11.010 --> 00:16:12.630
devices out there.

00:16:12.630 --> 00:16:16.540
Over 10,000 different
devices are running Facebook,

00:16:16.540 --> 00:16:17.990
which is kind of scary.

00:16:17.990 --> 00:16:22.810
We need to make sure that our
app works in all of these cases

00:16:22.810 --> 00:16:25.630
and is not creating a
terrible experience.

00:16:25.630 --> 00:16:27.880
So how do we do that?

00:16:27.880 --> 00:16:34.080
Well, we have a ton of different
layers of support here.

00:16:34.080 --> 00:16:35.790
The first one is
employee dogfooding.

00:16:35.790 --> 00:16:38.040
Let's say I'm building
my particular feature,

00:16:38.040 --> 00:16:40.080
and I'm pretty
sure that it works.

00:16:40.080 --> 00:16:41.120
But I don't know.

00:16:41.120 --> 00:16:42.770
There's 10,000
different devices.

00:16:42.770 --> 00:16:46.820
There's a lot of different
connectivity types.

00:16:46.820 --> 00:16:49.480
And to be honest, a lot
of different use cases.

00:16:49.480 --> 00:16:53.510
So rely on our employee
dogfooding program.

00:16:53.510 --> 00:16:56.170
We have thousands of
engineers at Facebook,

00:16:56.170 --> 00:16:59.190
and we really encourage a
lot of them to use Android.

00:16:59.190 --> 00:17:02.880
And we have this Rage
Shake feature support.

00:17:02.880 --> 00:17:05.089
Again, if you provide the
right tools for people

00:17:05.089 --> 00:17:07.250
to report a lot of
this information,

00:17:07.250 --> 00:17:08.500
it makes it easier.

00:17:08.500 --> 00:17:11.410
So if you find something
that doesn't feel right

00:17:11.410 --> 00:17:14.210
or an experience that
is really bothering you,

00:17:14.210 --> 00:17:16.630
you Rage Shake your phone.

00:17:16.630 --> 00:17:22.250
And then you get to
write an employee report.

00:17:22.250 --> 00:17:24.079
So is that enough?

00:17:24.079 --> 00:17:25.339
Well, the answer is no.

00:17:25.339 --> 00:17:28.900
So we take advantage of the
Google Play's alpha and beta

00:17:28.900 --> 00:17:30.020
channels.

00:17:30.020 --> 00:17:33.540
We have over
100,000 alpha users,

00:17:33.540 --> 00:17:37.900
and we have a little over a
million beta testers right now.

00:17:37.900 --> 00:17:43.100
So we release our app
into alpha every day,

00:17:43.100 --> 00:17:47.490
a new version of master into
that, and every couple of days

00:17:47.490 --> 00:17:50.010
into beta.

00:17:50.010 --> 00:17:52.680
This allows us to turn
on our features early.

00:17:52.680 --> 00:17:55.540
So if you guys are
interested in staying up

00:17:55.540 --> 00:17:58.600
to date with the newest
Facebook features,

00:17:58.600 --> 00:18:01.420
we turn them on much more often
in the alpha and beta channels.

00:18:01.420 --> 00:18:04.000
And we turn them
down in production.

00:18:04.000 --> 00:18:06.770
So check out those channels.

00:18:06.770 --> 00:18:09.730
By looking at this,
we're able to do

00:18:09.730 --> 00:18:14.240
identify crash rates mostly and
see some of our obvious booting

00:18:14.240 --> 00:18:15.080
problems.

00:18:15.080 --> 00:18:17.179
Now this is not
perfect, because most

00:18:17.179 --> 00:18:18.970
of the users in the
alpha and beta channels

00:18:18.970 --> 00:18:21.990
have really high end phones.

00:18:21.990 --> 00:18:23.680
Most of the phones
are Nexus phones.

00:18:23.680 --> 00:18:27.490
So it's a little skewed towards
a very tech oriented audience.

00:18:27.490 --> 00:18:28.940
Nonetheless, that
is very helpful.

00:18:31.760 --> 00:18:34.230
If everything passes here,
if everything looks good,

00:18:34.230 --> 00:18:37.820
we release to a small
percentage of the world.

00:18:37.820 --> 00:18:40.282
Now I mentioned
this is our release.

00:18:40.282 --> 00:18:42.240
We have multiple releases
of different products

00:18:42.240 --> 00:18:42.890
all the time.

00:18:42.890 --> 00:18:44.630
But we're very, very careful.

00:18:44.630 --> 00:18:47.560
Sometimes if we are looking
at product changes that

00:18:47.560 --> 00:18:51.070
affect a lot of users
and are pretty obvious,

00:18:51.070 --> 00:18:55.450
we run tests in
countries in particular

00:18:55.450 --> 00:18:58.720
to see where the longer
term network affect's there.

00:18:58.720 --> 00:19:01.970
And sometimes if it's something
smaller, we will run a 1% test,

00:19:01.970 --> 00:19:06.190
look at engagement
metrics and keep rolling

00:19:06.190 --> 00:19:09.390
to a larger audience that way.

00:19:09.390 --> 00:19:11.080
But is this enough?

00:19:11.080 --> 00:19:13.150
The answer is no.

00:19:13.150 --> 00:19:15.560
Let me tell you a
story about something

00:19:15.560 --> 00:19:18.310
that we didn't catch
in the employee dogfood

00:19:18.310 --> 00:19:21.680
program, the alpha,
or beta releases,

00:19:21.680 --> 00:19:25.130
or even when we
rolled out slowly.

00:19:25.130 --> 00:19:30.070
So this was in the context
of a photo uploader.

00:19:30.070 --> 00:19:33.050
So I guess this
might look familiar.

00:19:33.050 --> 00:19:35.670
If we are trying
to show a progress

00:19:35.670 --> 00:19:38.189
bar for uploading
photos, your code

00:19:38.189 --> 00:19:39.480
might look something like this.

00:19:39.480 --> 00:19:43.630
Obviously I
simplified a lot here.

00:19:43.630 --> 00:19:45.610
Here it's saying, hey
you're uploading photos

00:19:45.610 --> 00:19:48.800
at 70% of the total.

00:19:48.800 --> 00:19:51.580
So we go through a phase
of internationalization

00:19:51.580 --> 00:19:53.650
of strings.

00:19:53.650 --> 00:20:01.590
So obviously, when you multiply
that number in Android,

00:20:01.590 --> 00:20:03.560
the placeholder percent
d, and it will actually

00:20:03.560 --> 00:20:04.520
substitute a number.

00:20:04.520 --> 00:20:07.950
So that's probably pretty
clear for this crowd.

00:20:07.950 --> 00:20:11.450
When we translate stuff,
we send our strings--

00:20:11.450 --> 00:20:15.190
uploading photos, whatever--
into our internationalization

00:20:15.190 --> 00:20:16.730
console.

00:20:16.730 --> 00:20:20.270
And we have a lot of
volunteer translators.

00:20:20.270 --> 00:20:24.330
So in the case of Finnish,
Danish, and Polish,

00:20:24.330 --> 00:20:26.030
I had a single
translator doing this.

00:20:26.030 --> 00:20:30.100
They thought oh, this percent
sign was probably a mistake.

00:20:30.100 --> 00:20:32.980
So they removed it
in the translation.

00:20:32.980 --> 00:20:34.750
So what happens here?

00:20:34.750 --> 00:20:35.470
There's no crash.

00:20:35.470 --> 00:20:37.080
No crash happens here.

00:20:37.080 --> 00:20:38.720
Well, there's a crash.

00:20:38.720 --> 00:20:41.240
But there's no
compilation mistake here.

00:20:41.240 --> 00:20:45.000
So everything still builds.

00:20:45.000 --> 00:20:47.750
Depending on how you write your
code, it could a soft error,

00:20:47.750 --> 00:20:49.670
or it could be a
cancellation of uploads,

00:20:49.670 --> 00:20:52.490
or it could be a crash.

00:20:52.490 --> 00:20:58.370
So regardless, this means
that our users in the Nordics

00:20:58.370 --> 00:21:01.240
are not getting a photo uploads.

00:21:01.240 --> 00:21:03.760
Now the reason why this
was even more subtle

00:21:03.760 --> 00:21:07.260
is because we have separate
experiences for low end

00:21:07.260 --> 00:21:09.130
phones and high end phones.

00:21:09.130 --> 00:21:11.710
So this was just happening
for Gingerbread users

00:21:11.710 --> 00:21:14.380
in Finish, Polish, and Danish.

00:21:14.380 --> 00:21:19.220
So we did not have anyone in
the alpha or beta channels that

00:21:19.220 --> 00:21:22.420
used any of these
particular cases.

00:21:22.420 --> 00:21:24.840
So how did we catch it?

00:21:24.840 --> 00:21:30.850
We immediately saw an
increase in upload failures,

00:21:30.850 --> 00:21:33.030
in this particular scenario.

00:21:33.030 --> 00:21:36.070
We drilled more into
this, and identified this.

00:21:38.170 --> 00:21:42.630
So we have very, very
targeted instrumentation tools

00:21:42.630 --> 00:21:45.840
so that we can identify
large changes in engagement.

00:21:45.840 --> 00:21:48.710
And sometimes many of this
are related to releases.

00:21:48.710 --> 00:21:51.610
And then we can actually
bisect and identify

00:21:51.610 --> 00:21:54.580
what the particular problem is.

00:21:54.580 --> 00:21:59.615
So is this enough?

00:21:59.615 --> 00:22:01.490
So I touched a little
bit into the analytics.

00:22:01.490 --> 00:22:04.450
How do we understand that
our app is doing well once we

00:22:04.450 --> 00:22:05.980
release it to the world?

00:22:05.980 --> 00:22:09.060
So we have a lot of
dependencies and a lot of tools

00:22:09.060 --> 00:22:10.860
that we can use.

00:22:10.860 --> 00:22:14.360
Examples are crash logs, bug
reports, and Google Play store

00:22:14.360 --> 00:22:14.860
reviews.

00:22:19.470 --> 00:22:22.870
Everything in this form
comes like a snippet of text.

00:22:22.870 --> 00:22:25.840
Even a crash report, if
you look at your ADB stack,

00:22:25.840 --> 00:22:27.590
you're waiting for the
particular pattern.

00:22:27.590 --> 00:22:30.230
You're catching it,
and you're storing it.

00:22:30.230 --> 00:22:35.160
None of this structured,
especially like Rage Shake

00:22:35.160 --> 00:22:35.990
reports.

00:22:35.990 --> 00:22:40.280
People say, oh my feed is not
loading, or I can't comment.

00:22:40.280 --> 00:22:41.970
Those are examples.

00:22:41.970 --> 00:22:44.740
But we get thousands
and thousands a day

00:22:44.740 --> 00:22:48.590
reports of this kind, mostly
because of our magnitude.

00:22:48.590 --> 00:22:50.030
So one of the
things that we do is

00:22:50.030 --> 00:22:52.670
we use machine learning and
natural language processing

00:22:52.670 --> 00:22:57.110
to cluster a lot of this
reports using keywords.

00:22:57.110 --> 00:23:01.620
And we identify which
are the main categories.

00:23:01.620 --> 00:23:06.110
This allows us to focus
on the most pressing bugs

00:23:06.110 --> 00:23:11.410
and be able to cut by different
device classes, features, et

00:23:11.410 --> 00:23:12.730
cetera.

00:23:12.730 --> 00:23:16.340
And this is how we identify
some of our most alarming bugs.

00:23:16.340 --> 00:23:19.460
And we have task forces to
focus on them in particular.

00:23:19.460 --> 00:23:22.570
Examples are like hey,
if people can't like,

00:23:22.570 --> 00:23:23.700
what's happening here?

00:23:23.700 --> 00:23:26.880
Or if your News Feed is
not loading, we drill down.

00:23:26.880 --> 00:23:28.690
I don't understand,
add more logging,

00:23:28.690 --> 00:23:31.550
and come back and forth.

00:23:31.550 --> 00:23:35.100
So this is an example
of a screenshot

00:23:35.100 --> 00:23:37.350
that our engineers look
at when they get a crash.

00:23:37.350 --> 00:23:41.030
I have, again, blurred a bunch
of our internal data here.

00:23:41.030 --> 00:23:43.410
But the structure here
is that to the left,

00:23:43.410 --> 00:23:46.650
you get your stack trace
after all the clustering that

00:23:46.650 --> 00:23:47.900
happened.

00:23:47.900 --> 00:23:50.660
And to the right, we get
aggregate crash summaries.

00:23:50.660 --> 00:23:52.820
For instance, how often
is this happening?

00:23:52.820 --> 00:23:55.030
What device classes
is this happening?

00:23:55.030 --> 00:23:59.310
Since which version are we
seeing a lot of this stuff?

00:23:59.310 --> 00:24:02.970
These are all the tools that we
can give our engineers so they

00:24:02.970 --> 00:24:05.976
can reproduce this and address
a lot of these crashes in a much

00:24:05.976 --> 00:24:06.850
more promptly manner.

00:24:09.890 --> 00:24:12.150
So ever since we started
having these tools,

00:24:12.150 --> 00:24:16.190
these help reduce crashes
by 75%, which is a lot.

00:24:16.190 --> 00:24:17.060
What does this say?

00:24:17.060 --> 00:24:18.755
If we build the
right infrastructure,

00:24:18.755 --> 00:24:21.510
if we build the
right tools, we will

00:24:21.510 --> 00:24:25.405
be able to target the problems
in a much clearer manner.

00:24:29.420 --> 00:24:31.400
So that's all I have here today.

00:24:31.400 --> 00:24:34.210
It looks like we have
a much larger slot.

00:24:34.210 --> 00:24:36.077
And I have a 30
minute talk prepared,

00:24:36.077 --> 00:24:37.410
but I'll start taking questions.

00:24:39.932 --> 00:24:41.640
And there are a bunch
of us from Facebook

00:24:41.640 --> 00:24:45.499
here if you guys have
broad questions as well.

00:24:45.499 --> 00:24:48.406
AUDIENCE: How do you assess
the severity of a bug,

00:24:48.406 --> 00:24:50.489
or how do you prioritize
bugs across the different

00:24:50.489 --> 00:24:51.244
[INAUDIBLE]?

00:24:51.244 --> 00:24:52.660
JENNY YUEN: So the
question-- I'll

00:24:52.660 --> 00:24:55.710
repeat that-- is
how do you identify

00:24:55.710 --> 00:24:58.390
the severity of the bug, and
how do you prioritize it?

00:24:58.390 --> 00:25:01.200
Well, so remember
that slide that I

00:25:01.200 --> 00:25:06.350
talked about where we have a lot
of input of reports, crashes,

00:25:06.350 --> 00:25:07.230
et cetera?

00:25:07.230 --> 00:25:12.230
So we have information like, how
often is this being reported?

00:25:12.230 --> 00:25:18.190
So if people are pressing the
report a bug button, the more

00:25:18.190 --> 00:25:20.960
they report it, it indicates
a lot more severity

00:25:20.960 --> 00:25:22.410
and like a broader use case.

00:25:22.410 --> 00:25:25.950
So we have a program
at Facebook called

00:25:25.950 --> 00:25:29.980
the Countdown, the Countdown
kind of like program

00:25:29.980 --> 00:25:32.250
where we look at
all of the bugs that

00:25:32.250 --> 00:25:34.640
are being reported, the ones
that are reported the most.

00:25:34.640 --> 00:25:39.390
And we have specific task
forces to handle each of them.

00:25:39.390 --> 00:25:41.090
Some of them are
easier than others.

00:25:41.090 --> 00:25:43.510
Some of them are because we
release something by mistake

00:25:43.510 --> 00:25:46.630
and we can do immediate
targeted fixes.

00:25:46.630 --> 00:25:48.136
Some of them are more subtle.

00:25:48.136 --> 00:25:49.260
Let me give you an example.

00:25:49.260 --> 00:25:53.420
We had a like reliability
problem at some point.

00:25:53.420 --> 00:25:54.540
People couldn't like.

00:25:54.540 --> 00:25:57.820
But if this was
really mainstream,

00:25:57.820 --> 00:26:00.050
like obvious problem, we
would have realized this,

00:26:00.050 --> 00:26:01.270
and we could have targeted.

00:26:01.270 --> 00:26:02.800
It was not the case.

00:26:02.800 --> 00:26:03.920
It was pretty subtle.

00:26:03.920 --> 00:26:08.244
And we broke down a bunch
of the different cases

00:26:08.244 --> 00:26:09.910
by adding a bunch of
logging and looking

00:26:09.910 --> 00:26:11.850
at what are the reports are.

00:26:11.850 --> 00:26:14.900
In some cases, in low
connectivity scenarios,

00:26:14.900 --> 00:26:17.430
people were hitting like,
but this was not propagating.

00:26:17.430 --> 00:26:20.770
And they hit like a lot, like,
and like, like, and like.

00:26:20.770 --> 00:26:23.590
And our site integrity,
or like our spam filter

00:26:23.590 --> 00:26:26.350
detection mechanisms
realized, OK, you

00:26:26.350 --> 00:26:29.550
can't be liking
this story a ton.

00:26:29.550 --> 00:26:30.500
We're going to block.

00:26:30.500 --> 00:26:32.570
We're going to
essentially block you.

00:26:32.570 --> 00:26:35.120
But this was happening because
people were pressing this back

00:26:35.120 --> 00:26:35.620
and forth.

00:26:35.620 --> 00:26:37.440
It was queueing up
on the client side.

00:26:37.440 --> 00:26:41.060
And when the connectivity came
back up, all the queue of likes

00:26:41.060 --> 00:26:44.490
and likes, a request
was coming on to server.

00:26:44.490 --> 00:26:46.160
So we were able
to identify that.

00:26:46.160 --> 00:26:50.230
And we were able to remove
all those likes and likes

00:26:50.230 --> 00:26:51.230
and fix that.

00:26:51.230 --> 00:26:53.310
So that's one
example of a problem.

00:26:53.310 --> 00:26:58.310
But since this is affecting
some of our core functionally,

00:26:58.310 --> 00:27:03.280
having signals of how
often it is being reported

00:27:03.280 --> 00:27:05.530
helps us identify
the severity of them.

00:27:07.810 --> 00:27:11.045
Does that help
answer you question?

00:27:11.045 --> 00:27:11.545
Yeah?

00:27:11.545 --> 00:27:12.846
AUDIENCE: What sort
of testing process

00:27:12.846 --> 00:27:15.012
do you have in place that
would allow you to release

00:27:15.012 --> 00:27:16.145
an app on a weekly basis?

00:27:16.145 --> 00:27:18.770
JENNY YUEN: So the question was,
what type of testing processes

00:27:18.770 --> 00:27:21.350
do you have in
place that allow you

00:27:21.350 --> 00:27:24.580
to release on a weekly basis?

00:27:24.580 --> 00:27:29.219
So we just started transitioning
from a two week release cycle

00:27:29.219 --> 00:27:30.760
to a one week release
cycle recently.

00:27:33.630 --> 00:27:35.947
So let me give you a little
more historical context.

00:27:35.947 --> 00:27:37.280
We used to release once a month.

00:27:37.280 --> 00:27:38.905
We used to not have
a release schedule.

00:27:38.905 --> 00:27:43.410
We were ready to release,
and then we released it.

00:27:43.410 --> 00:27:45.420
This is back in the
days when we had

00:27:45.420 --> 00:27:47.510
probably a small mobile team.

00:27:47.510 --> 00:27:50.010
We had a big rewrite,
we released it.

00:27:50.010 --> 00:27:52.340
Then we switched to
release once a month

00:27:52.340 --> 00:27:54.240
when we started
having a lot of people

00:27:54.240 --> 00:27:56.670
developing in the codebase.

00:27:56.670 --> 00:28:02.999
We used to have a month
soak period and a month--

00:28:02.999 --> 00:28:05.040
you branch cut, and you
have a month soak period.

00:28:05.040 --> 00:28:09.250
And only bug fixes go in there.

00:28:09.250 --> 00:28:11.620
It was really tough
because suddenly,

00:28:11.620 --> 00:28:13.920
if you couldn't get your
feature for the month,

00:28:13.920 --> 00:28:16.860
you had to actually
wait for another month.

00:28:16.860 --> 00:28:20.740
And reliability was
super important.

00:28:20.740 --> 00:28:23.800
So we started by having
a lot of unit tests,

00:28:23.800 --> 00:28:27.690
like setting a lot of the-- the
dependency injection framework

00:28:27.690 --> 00:28:31.490
integration was mostly so that
we could even write unit tests.

00:28:31.490 --> 00:28:32.600
So that started first.

00:28:32.600 --> 00:28:36.050
And then with time,
we realized that hey,

00:28:36.050 --> 00:28:38.600
now that we're
releasing every week,

00:28:38.600 --> 00:28:42.200
it's really hard to have
manual testing in place.

00:28:42.200 --> 00:28:44.970
We used to have a
QA testing team that

00:28:44.970 --> 00:28:46.720
looked at a bunch of
the core interactions

00:28:46.720 --> 00:28:49.510
to make sure, say, you
could load your News Feed,

00:28:49.510 --> 00:28:52.780
you could post a photo,
you could like a story.

00:28:52.780 --> 00:28:55.239
Like a lot of our
core interactions,

00:28:55.239 --> 00:28:57.530
they would manually test a
lot of our core interactions

00:28:57.530 --> 00:28:58.737
before we shipped.

00:28:58.737 --> 00:29:00.945
Now with a one week release
cycle, that's impossible.

00:29:05.510 --> 00:29:10.160
So we have a really good
end to end testing framework

00:29:10.160 --> 00:29:14.680
and screenshot testing
framework that we use now.

00:29:14.680 --> 00:29:16.940
A screenshot testing
framework operates

00:29:16.940 --> 00:29:18.560
a lot like a unit test.

00:29:18.560 --> 00:29:22.430
It allows you to separate
a lot of the components,

00:29:22.430 --> 00:29:26.220
and it takes a
screenshot of a lot of UI

00:29:26.220 --> 00:29:28.090
that you have so that
it can compare it

00:29:28.090 --> 00:29:28.990
with the old version.

00:29:31.430 --> 00:29:33.779
And it can ask you, hey,
do you mean for this

00:29:33.779 --> 00:29:34.570
to be a difference?

00:29:34.570 --> 00:29:38.060
So if we have
undesired changes, we

00:29:38.060 --> 00:29:40.510
can actually
identify them early.

00:29:40.510 --> 00:29:42.875
Our end to end tests
are meant to substitute

00:29:42.875 --> 00:29:44.000
some of our manual testing.

00:29:48.730 --> 00:29:51.540
As a principle, we're asking
all of the product teams

00:29:51.540 --> 00:29:53.560
to sort of transition to this.

00:29:53.560 --> 00:29:56.260
So how do we enforce it?

00:29:56.260 --> 00:30:00.060
We have this concept of
a test storm happening.

00:30:00.060 --> 00:30:04.120
At Facebook, we
have a lot of trials

00:30:04.120 --> 00:30:08.350
of what would happen
if our data center,

00:30:08.350 --> 00:30:10.300
if X data center went down.

00:30:10.300 --> 00:30:12.500
So we want to actually
understand our weaknesses

00:30:12.500 --> 00:30:13.060
there.

00:30:13.060 --> 00:30:16.450
So what would happen if
our QA testing team just

00:30:16.450 --> 00:30:17.590
was not available?

00:30:17.590 --> 00:30:21.860
So we're having
a test storm plan

00:30:21.860 --> 00:30:23.470
where our objective
is to transition

00:30:23.470 --> 00:30:27.440
a lot of our manual testing
into end to end tests.

00:30:27.440 --> 00:30:30.200
So the answer is,
there's a mix of stuff.

00:30:30.200 --> 00:30:32.710
We have a lot of
tools now that allow

00:30:32.710 --> 00:30:35.340
us to write from all
the way from unit tests

00:30:35.340 --> 00:30:36.294
to end to end tests.

00:30:36.294 --> 00:30:37.835
And the idea is to
prevent regression

00:30:37.835 --> 00:30:41.780
so that we don't have to be
fixing stuff after launch.

00:30:44.438 --> 00:30:45.979
AUDIENCE: How do
you find the balance

00:30:45.979 --> 00:30:48.943
between the staged rollouts,
just lower percentage

00:30:48.943 --> 00:30:53.636
of whatever versus having
a consistent experience

00:30:53.636 --> 00:30:56.552
across all customers?

00:30:56.552 --> 00:30:58.260
JENNY YUEN: So the
question is, how do we

00:30:58.260 --> 00:30:59.980
find the balance
between a staged roll

00:30:59.980 --> 00:31:03.800
out and a consistent experience
amongst different people?

00:31:03.800 --> 00:31:06.950
Well, so we release
our app once a week.

00:31:09.670 --> 00:31:11.980
That is a staged
rollout on its own.

00:31:11.980 --> 00:31:14.740
We want to make sure that
we monitor a lot of things

00:31:14.740 --> 00:31:18.120
like crash rates, bug reports.

00:31:18.120 --> 00:31:19.930
So we want to be
very, very careful

00:31:19.930 --> 00:31:25.365
about not introducing a
release that is bad for users.

00:31:25.365 --> 00:31:29.790
So in that sense, we will
have a gradual rollout.

00:31:29.790 --> 00:31:34.470
That being said, we do a
lot of experimentations

00:31:34.470 --> 00:31:36.550
in our features because
we want to make sure

00:31:36.550 --> 00:31:38.910
that whatever we
roll out to 100%

00:31:38.910 --> 00:31:41.130
is the best experience
for our users.

00:31:41.130 --> 00:31:43.570
Let me give you an example.

00:31:43.570 --> 00:31:49.380
When we redid the way we
navigate to open comments,

00:31:49.380 --> 00:31:55.520
we had a new, very
fancy design that when

00:31:55.520 --> 00:31:57.760
you tapped on comments,
it opened a popover.

00:31:57.760 --> 00:31:58.820
It was bouncy.

00:31:58.820 --> 00:32:00.060
It was very friendly.

00:32:00.060 --> 00:32:02.360
But we found out that
hey, if you actually

00:32:02.360 --> 00:32:05.844
looked at low end device users,
they were actually having

00:32:05.844 --> 00:32:06.760
a terrible experience.

00:32:06.760 --> 00:32:08.210
They were commenting less.

00:32:08.210 --> 00:32:09.620
So we dug in a little bit more.

00:32:09.620 --> 00:32:12.605
We actually opened this
in a low end phone,

00:32:12.605 --> 00:32:16.080
and we realized that
animation is so choppy,

00:32:16.080 --> 00:32:18.030
there's really no
point in having it.

00:32:18.030 --> 00:32:21.640
So if we had released the
one version to everybody,

00:32:21.640 --> 00:32:23.790
we would have hurt
our low end users,

00:32:23.790 --> 00:32:26.380
and seen better
engagement, and have

00:32:26.380 --> 00:32:29.080
a better, more delightful
experience for high end users.

00:32:29.080 --> 00:32:32.660
But because we had the way to
look at all these analytics,

00:32:32.660 --> 00:32:36.470
we were able to pinpoint that
for some users, this is bad.

00:32:36.470 --> 00:32:38.280
And for some of the
users it's better.

00:32:38.280 --> 00:32:39.930
So what we did in
that case is we

00:32:39.930 --> 00:32:42.700
turned off animation
for our low end users.

00:32:42.700 --> 00:32:45.980
And they actually got to
experience the full screen

00:32:45.980 --> 00:32:48.360
behavior that we had, which
was better than the old one,

00:32:48.360 --> 00:32:50.030
but they didn't
need animation that

00:32:50.030 --> 00:32:52.110
was going to be choppy anyway.

00:32:52.110 --> 00:32:53.936
So I guess to answer
your question,

00:32:53.936 --> 00:32:56.060
one of the things we learned
is that there's no one

00:32:56.060 --> 00:32:59.630
size fits all for everybody.

00:32:59.630 --> 00:33:04.950
There's a lot of diversity in
device models, in screen sizes,

00:33:04.950 --> 00:33:09.770
in usages, in general usage,
not just from your device,

00:33:09.770 --> 00:33:11.760
but also culturally speaking.

00:33:11.760 --> 00:33:14.420
For instance, people
in different countries

00:33:14.420 --> 00:33:17.040
have different ratios of
friends versus page content.

00:33:17.040 --> 00:33:19.617
And people use Facebook in
a slightly different manner.

00:33:19.617 --> 00:33:21.200
So the important
thing for us is to be

00:33:21.200 --> 00:33:23.158
able to understand our
users in the best manner

00:33:23.158 --> 00:33:28.130
and provide them with what
will make them have a better

00:33:28.130 --> 00:33:30.500
experience.

00:33:30.500 --> 00:33:31.000
Yeah?

00:33:31.000 --> 00:33:33.410
AUDIENCE: Do you guys
leverage any feature clipping?

00:33:33.410 --> 00:33:34.618
JENNY YUEN: What do you mean?

00:33:34.618 --> 00:33:38.278
AUDIENCE: Like ship a
feature turned off, and then

00:33:38.278 --> 00:33:40.840
turn it on later?

00:33:40.840 --> 00:33:44.290
JENNY YUEN: The question is if
we leverage any centers where

00:33:44.290 --> 00:33:46.814
we turn on the feature then
turn off and turn it on.

00:33:46.814 --> 00:33:48.230
I can't think of
a particular one,

00:33:48.230 --> 00:33:50.414
but do you have an
example in mind?

00:33:50.414 --> 00:33:55.655
AUDIENCE: Yeah, you may
ship-- like for an A/B testing

00:33:55.655 --> 00:33:58.270
scenario, instead of doing
two different builds,

00:33:58.270 --> 00:34:02.472
you ship one build
with a flag that

00:34:02.472 --> 00:34:05.846
says use this like button
or that like button.

00:34:05.846 --> 00:34:08.256
And then you turn
that on and off

00:34:08.256 --> 00:34:09.702
to determine which one's better.

00:34:09.702 --> 00:34:11.785
You could use for A/B
testing, or it could be good

00:34:11.785 --> 00:34:16.269
for, I guess keeping code that's
not yet ready for full release,

00:34:16.269 --> 00:34:18.060
but it's not holding
up your release cycle.

00:34:18.060 --> 00:34:19.810
JENNY YUEN: Yeah, we
do that all the time.

00:34:19.810 --> 00:34:21.500
In fact, we have a
lot of experiments

00:34:21.500 --> 00:34:22.550
running simultaneously.

00:34:22.550 --> 00:34:25.350
We have a very good
experimentation framework.

00:34:25.350 --> 00:34:28.000
It was built internally.

00:34:28.000 --> 00:34:30.920
Literally, probably every
single product change,

00:34:30.920 --> 00:34:33.400
and any large
infrastructure change

00:34:33.400 --> 00:34:36.170
will go through
experimentation here.

00:34:36.170 --> 00:34:39.380
The context being--

00:34:40.579 --> 00:34:42.120
For instance, if
you have a refactor,

00:34:42.120 --> 00:34:44.872
you want to make sure that
all your metrics are neutral.

00:34:44.872 --> 00:34:46.830
And if they're not, you
want to understand why,

00:34:46.830 --> 00:34:48.820
because it's probably
a bug otherwise.

00:34:48.820 --> 00:34:52.860
For our products, we
constantly roll out

00:34:52.860 --> 00:34:56.820
this in terms of tests.

00:34:56.820 --> 00:34:59.620
The set up of the test matters.

00:34:59.620 --> 00:35:03.246
It varies a lot depending on
what the test is in particular.

00:35:03.246 --> 00:35:05.454
But is there something in
particular you had in mind?

00:35:05.454 --> 00:35:05.995
AUDIENCE: No.

00:35:05.995 --> 00:35:11.359
I'm just curious if you do that
at build time with variance,

00:35:11.359 --> 00:35:13.192
or so you a particular
APK that's configured

00:35:13.192 --> 00:35:15.340
a particular way, or
is that controlled--

00:35:15.340 --> 00:35:15.630
JENNY YUEN: Server control.

00:35:15.630 --> 00:35:16.440
AUDIENCE: On your server?

00:35:16.440 --> 00:35:18.065
JENNY YUEN: It's all
server controlled.

00:35:18.065 --> 00:35:21.570
So the way it works
is that we have--

00:35:21.570 --> 00:35:24.450
the system we call is a
quick experimentation system.

00:35:24.450 --> 00:35:25.244
It's like internal.

00:35:25.244 --> 00:35:25.910
We call it that.

00:35:25.910 --> 00:35:29.300
And also we have a
gating system for that.

00:35:29.300 --> 00:35:32.410
And a lot of the
signals, every six hours,

00:35:32.410 --> 00:35:35.000
we download some small
snippet information.

00:35:35.000 --> 00:35:36.970
Which is like, imagine a table.

00:35:36.970 --> 00:35:39.390
It's like a name of
experiments mapped to the group

00:35:39.390 --> 00:35:40.480
that you're assigned to.

00:35:40.480 --> 00:35:42.480
And depending on which
group you're assigned to,

00:35:42.480 --> 00:35:46.130
your code actually decides
to turn this on or off,

00:35:46.130 --> 00:35:49.670
kind of like log a lot of
user engagement information,

00:35:49.670 --> 00:35:52.780
like your behavior, the
behavior of the user,

00:35:52.780 --> 00:35:55.967
depending on the flow.

00:35:55.967 --> 00:35:56.466
Yeah?

00:35:56.466 --> 00:35:58.625
AUDIENCE: What kinds
of tools and processes

00:35:58.625 --> 00:36:01.127
do you have around code reviews?

00:36:01.127 --> 00:36:02.710
JENNY YUEN: The
question is, what type

00:36:02.710 --> 00:36:06.440
of tools and processes do
we have around code reviews?

00:36:06.440 --> 00:36:08.590
So it really
depends by the team.

00:36:08.590 --> 00:36:11.550
So we are a very bottoms
up company in the sense

00:36:11.550 --> 00:36:13.990
that we try not to build
things are not necessary.

00:36:13.990 --> 00:36:14.930
But that being said.

00:36:14.930 --> 00:36:19.780
The common things that
come up is automatically

00:36:19.780 --> 00:36:22.400
running the test is something
that has been found very

00:36:22.400 --> 00:36:23.930
useful across all the teams.

00:36:23.930 --> 00:36:26.850
So by the time your
review comes back,

00:36:26.850 --> 00:36:28.980
we are able to run a
bunch of unit tests

00:36:28.980 --> 00:36:32.640
or end to end
tests in that case.

00:36:32.640 --> 00:36:38.770
I guess we have general
linters and a bunch

00:36:38.770 --> 00:36:42.350
of agreed upon
patterns that we like

00:36:42.350 --> 00:36:45.410
to enforce so that our code
is consistent and coherent

00:36:45.410 --> 00:36:48.030
across everything.

00:36:48.030 --> 00:36:50.630
What else?

00:36:50.630 --> 00:36:54.610
Yeah, I think at a high level,
that's what I'm thinking of.

00:36:54.610 --> 00:36:57.290
We do like to, kind
of like in principle,

00:36:57.290 --> 00:37:00.660
say, hey, if you are
done building a feature,

00:37:00.660 --> 00:37:04.015
because end to end tests
are heavy and expensive--

00:37:06.610 --> 00:37:11.020
Let's say we ship this,
and we agreed on this

00:37:11.020 --> 00:37:15.090
as being the feature that
we want to actually release

00:37:15.090 --> 00:37:17.480
and in this form,
we go back and start

00:37:17.480 --> 00:37:21.810
looking at what are
the core tests that we

00:37:21.810 --> 00:37:23.330
would like to build.

00:37:23.330 --> 00:37:25.606
And from the point
of view of a user.

00:37:25.606 --> 00:37:28.382
And we try to do that.

00:37:28.382 --> 00:37:29.340
Yeah, we'll start here.

00:37:32.581 --> 00:37:34.700
AUDIENCE: When you
went from 12 engineers

00:37:34.700 --> 00:37:38.144
to 60 engineers on
your web platform,

00:37:38.144 --> 00:37:39.620
how did your codebase change?

00:37:39.620 --> 00:37:41.588
Did you start to break
up the different modules

00:37:41.588 --> 00:37:44.050
or [INAUDIBLE] you get?

00:37:44.050 --> 00:37:46.050
JENNY YUEN: So the
question is, what

00:37:46.050 --> 00:37:48.520
happened when you
switch from 12 engineers

00:37:48.520 --> 00:37:49.970
to hundreds of engineers?

00:37:49.970 --> 00:37:51.870
How did your code change?

00:37:51.870 --> 00:37:54.270
From my memory, the biggest
thing that changed was we

00:37:54.270 --> 00:37:55.810
started using
dependency injection,

00:37:55.810 --> 00:38:00.840
because everything
was tangled together,

00:38:00.840 --> 00:38:02.710
and stuff was breaking.

00:38:02.710 --> 00:38:05.000
And if you could build
a particular module

00:38:05.000 --> 00:38:06.740
and just not have
to depend on it,

00:38:06.740 --> 00:38:09.220
it's actually really helpful.

00:38:09.220 --> 00:38:14.400
The second one that we built,
that we developed because we

00:38:14.400 --> 00:38:16.950
didn't find a tool that could
handle a bunch of our scale

00:38:16.950 --> 00:38:19.960
was Buck, our build system.

00:38:19.960 --> 00:38:24.640
So the way Buck works is that
it builds particular modules.

00:38:24.640 --> 00:38:27.450
And it doesn't rebuild them
if they haven't changed.

00:38:30.070 --> 00:38:32.570
Buck is a general build system.

00:38:32.570 --> 00:38:33.660
It's actually open source.

00:38:33.660 --> 00:38:34.940
It's not specific to Android.

00:38:34.940 --> 00:38:39.370
It's part of our iOS
build system as well now.

00:38:39.370 --> 00:38:42.260
But the advantage
of that was, we used

00:38:42.260 --> 00:38:45.390
have a single-- we still
have a single repository.

00:38:45.390 --> 00:38:48.390
But each of our
modules have to be--

00:38:48.390 --> 00:38:51.370
like when building the whole
thing, it would take forever.

00:38:51.370 --> 00:38:54.300
With time, what we
developed was different ways

00:38:54.300 --> 00:38:57.090
of distributing the builds
across different machines

00:38:57.090 --> 00:38:59.100
so that not everything
lies on your laptop.

00:38:59.100 --> 00:39:05.020
And your laptop doesn't look
like it's starting up a rocket.

00:39:05.020 --> 00:39:07.050
It doesn't sound
like a rocket ship.

00:39:07.050 --> 00:39:10.520
So Buck was pretty impactful.

00:39:10.520 --> 00:39:12.055
What other things did we change?

00:39:17.220 --> 00:39:19.630
The stuff I was mentioning,
I was mentioning here

00:39:19.630 --> 00:39:21.890
how we fetch data
from our servers.

00:39:21.890 --> 00:39:23.330
It's a framework called GraphQL.

00:39:23.330 --> 00:39:24.580
It's open source now.

00:39:24.580 --> 00:39:30.240
It allows us to
effectively download--

00:39:30.240 --> 00:39:33.540
it's an API that allows us
to effectively download data

00:39:33.540 --> 00:39:34.410
from our servers.

00:39:34.410 --> 00:39:39.160
But it's also tolerant
to versioning.

00:39:39.160 --> 00:39:41.050
What do I mean with this?

00:39:41.050 --> 00:39:47.090
So we all know that our--
the APK that we probably

00:39:47.090 --> 00:39:50.680
released a couple months ago,
it's still out in the wild.

00:39:53.850 --> 00:39:56.180
So we can't deprecate
certain methods.

00:39:56.180 --> 00:40:00.550
So rather than saying,
hey, this is API,

00:40:00.550 --> 00:40:03.080
and we're switching it like
this in the next release, which

00:40:03.080 --> 00:40:05.242
doesn't really work.

00:40:05.242 --> 00:40:10.680
We came up with an API
construction that allows

00:40:10.680 --> 00:40:12.190
us to ask for specific parts.

00:40:12.190 --> 00:40:14.415
For instance, if we are
rendering News Feed,

00:40:14.415 --> 00:40:15.890
it's pass me all the stories.

00:40:15.890 --> 00:40:18.070
Pass me the message of it.

00:40:18.070 --> 00:40:19.440
Pass me the link for it.

00:40:19.440 --> 00:40:21.010
Pass me the photo.

00:40:21.010 --> 00:40:25.710
And what if, in the next
version of News Feed,

00:40:25.710 --> 00:40:27.690
first we were not
rendering photos.

00:40:27.690 --> 00:40:30.380
And we're just rendering
everything like a text piece.

00:40:30.380 --> 00:40:33.750
And in the next version, we want
to have a rich media format.

00:40:33.750 --> 00:40:40.000
So how do we repurpose this API
so that the old version still

00:40:40.000 --> 00:40:44.080
keeps working and we don't have
to change our signature a lot.

00:40:44.080 --> 00:40:47.430
In new ones, we can support
a bunch of this stuff.

00:40:47.430 --> 00:40:49.330
We use the concept of a stylist.

00:40:49.330 --> 00:40:53.410
The idea is in JSON,
as part of your JSON,

00:40:53.410 --> 00:40:57.670
you have a stylist that says, I
want to render you as a photo.

00:40:57.670 --> 00:41:00.490
And as a photo, if
it's as a photo format,

00:41:00.490 --> 00:41:04.350
you need to make sure that
your image URL is there,

00:41:04.350 --> 00:41:05.740
and the title is there.

00:41:05.740 --> 00:41:08.120
And if you can't
render a photo, there's

00:41:08.120 --> 00:41:10.860
a fallback mechanism, which
is just text for instance.

00:41:10.860 --> 00:41:12.380
And this is how we grow.

00:41:12.380 --> 00:41:15.520
So that has been very helpful.

00:41:15.520 --> 00:41:17.620
So check it out.

00:41:17.620 --> 00:41:20.110
A lot of this is part of
like a framework of GraphQL,

00:41:20.110 --> 00:41:24.960
but also a lot of this was
custom within our team.

00:41:24.960 --> 00:41:26.712
AUDIENCE: Do you
design for the low end

00:41:26.712 --> 00:41:28.253
first and then
progressively enhance,

00:41:28.253 --> 00:41:30.849
or do you design for the
high end and [INAUDIBLE]?

00:41:30.849 --> 00:41:32.390
JENNY YUEN: So the
question is, do we

00:41:32.390 --> 00:41:34.750
design for the low end
first and progressively

00:41:34.750 --> 00:41:36.152
enhance, or the other way?

00:41:36.152 --> 00:41:38.360
So we have someone from the
emerging markets in here.

00:41:38.360 --> 00:41:39.580
Like I don't want to
put you on the spot.

00:41:39.580 --> 00:41:41.430
I can answer it, but
it seems like you

00:41:41.430 --> 00:41:43.500
will able to add color.

00:41:43.500 --> 00:41:45.020
So I'll take a
stab, and then Alex

00:41:45.020 --> 00:41:47.656
can probably add here more.

00:41:47.656 --> 00:41:51.230
To be honest, we tried
to build empathy.

00:41:51.230 --> 00:41:52.920
That's the most important thing.

00:41:52.920 --> 00:41:57.920
One of the things we realized
is that first, [INAUDIBLE]

00:41:57.920 --> 00:42:02.750
an Android phone, you need to
use an Android phone everyday

00:42:02.750 --> 00:42:05.260
too so that you can understand
how navigation works,

00:42:05.260 --> 00:42:07.500
what type of limitations
of hardware we have.

00:42:07.500 --> 00:42:11.170
So we make sure that
we really, really push

00:42:11.170 --> 00:42:14.810
every one at the companies
to start using Android.

00:42:14.810 --> 00:42:17.430
A couple things
that we also tried

00:42:17.430 --> 00:42:20.520
is low end phone
versus high end phone.

00:42:24.170 --> 00:42:28.290
This started with one of
our PMs, Chis Marra, who

00:42:28.290 --> 00:42:31.110
started raising a
lot of awareness

00:42:31.110 --> 00:42:33.960
about the different types
of phones out there.

00:42:33.960 --> 00:42:36.700
So he asked, can everyone carry
a low end phone and a high end

00:42:36.700 --> 00:42:37.200
phone?

00:42:41.310 --> 00:42:44.130
The other part is we
build a lot of APIs

00:42:44.130 --> 00:42:46.940
so that people can
understand the data

00:42:46.940 --> 00:42:49.420
and be able to cut it
across different device

00:42:49.420 --> 00:42:51.700
models and different kind
of [INAUDIBLE] models.

00:42:51.700 --> 00:42:52.610
What does that mean?

00:42:52.610 --> 00:42:55.570
Well, so if you guys
attended the talk yesterday,

00:42:55.570 --> 00:42:58.101
we talked about how we have
10,000 different devices.

00:42:58.101 --> 00:42:59.850
And when we have 10,000
different devices,

00:42:59.850 --> 00:43:02.230
are you supposed to carry
10,000 different phones,

00:43:02.230 --> 00:43:03.140
test all of them?

00:43:03.140 --> 00:43:07.190
It's literally
impossible to do that.

00:43:07.190 --> 00:43:09.540
But what we do
know is that there

00:43:09.540 --> 00:43:12.240
are certain characteristics
that differentiate

00:43:12.240 --> 00:43:19.690
them-- the number of cores,
the screen size, basically

00:43:19.690 --> 00:43:21.100
their speed.

00:43:21.100 --> 00:43:25.070
So rather than thinking
about each of the devices,

00:43:25.070 --> 00:43:28.380
we think about if you took
this phone, the specifications

00:43:28.380 --> 00:43:31.030
of this phone, how
will you map it

00:43:31.030 --> 00:43:35.870
to-- when was it the newest
flagship phone in the US?

00:43:35.870 --> 00:43:39.629
So the same way you
think about car models,

00:43:39.629 --> 00:43:42.170
I don't really know about the
models everywhere in the world.

00:43:42.170 --> 00:43:45.710
But I can think of, OK, this
is a car that would have

00:43:45.710 --> 00:43:48.360
released in 2010 for instance.

00:43:48.360 --> 00:43:50.590
So we created this
year class model

00:43:50.590 --> 00:43:53.140
so that instead of thinking
about 10,000 different phones,

00:43:53.140 --> 00:44:00.219
you think about five or six,
or really just fast and slow.

00:44:00.219 --> 00:44:02.510
So probably the ones in your
pockets are the fast ones,

00:44:02.510 --> 00:44:04.676
and think about something
that was flagship in 2011.

00:44:07.180 --> 00:44:10.430
So when we have this
type of framework,

00:44:10.430 --> 00:44:13.300
we can cut our data
across [INAUDIBLE] there.

00:44:13.300 --> 00:44:15.470
So that's one part, be able
to understand your data.

00:44:15.470 --> 00:44:17.530
And the second part
is also, try to use

00:44:17.530 --> 00:44:20.120
this phone and this model.

00:44:20.120 --> 00:44:21.970
The emerging
markets team started

00:44:21.970 --> 00:44:23.390
what we call 2G Tuesday.

00:44:23.390 --> 00:44:26.510
The idea is on
Tuesday, you will have

00:44:26.510 --> 00:44:28.160
an ad on top of
your Facebook that

00:44:28.160 --> 00:44:30.260
says-- a megaphone
we call it-- that

00:44:30.260 --> 00:44:35.550
says, can you start
using Facebook

00:44:35.550 --> 00:44:38.800
as if we slowed down everything
and you were in a 2G network,

00:44:38.800 --> 00:44:40.670
examples like this.

00:44:40.670 --> 00:44:43.970
So all of this, those
are the objective

00:44:43.970 --> 00:44:47.200
of building empathy so that
our designers, our product

00:44:47.200 --> 00:44:48.740
developers, and our
product managers

00:44:48.740 --> 00:44:52.120
can think about where the
problems are happening

00:44:52.120 --> 00:44:52.780
everywhere.

00:44:52.780 --> 00:44:54.155
In addition to
that, we also have

00:44:54.155 --> 00:44:56.840
a lot of research field trips
going to different emerging

00:44:56.840 --> 00:44:59.200
markets.

00:44:59.200 --> 00:45:00.950
So I know we got to
India, Southeast Asia.

00:45:00.950 --> 00:45:02.740
We go to Mexico.

00:45:02.740 --> 00:45:05.640
And we interview
a bunch of people

00:45:05.640 --> 00:45:07.320
and ask them about
their usage patterns.

00:45:07.320 --> 00:45:09.430
This helps us to
understand emerging markets

00:45:09.430 --> 00:45:11.326
as well as cultural
differences too.

00:45:14.122 --> 00:45:15.980
Do you want to add
something Alex?

00:45:15.980 --> 00:45:18.262
ALEX: Nope, it's a good answer.

00:45:18.262 --> 00:45:20.431
AUDIENCE: So you're
mentioning that you're moving

00:45:20.431 --> 00:45:22.118
to a weekly release cycle.

00:45:22.118 --> 00:45:25.492
I was just curious how you
managed the exponential upgrade

00:45:25.492 --> 00:45:28.384
path that users can
potentially go through,

00:45:28.384 --> 00:45:30.582
not to mention preloads as well.

00:45:30.582 --> 00:45:32.165
JENNY YUEN: Exponential
upgrade paths?

00:45:32.165 --> 00:45:32.874
What do you mean?

00:45:32.874 --> 00:45:35.331
AUDIENCE: So if someone didn't
take your upgrade this week,

00:45:35.331 --> 00:45:38.008
they're potentially three weeks
older versus two weeks older.

00:45:38.008 --> 00:45:40.815
And then next week, there's
an entire new [INAUDIBLE]

00:45:40.815 --> 00:45:43.820
upgrades to deal with.

00:45:43.820 --> 00:45:45.990
JENNY YUEN: I'll try to
repeat it for everybody.

00:45:45.990 --> 00:45:49.340
So when you switch to a
one week release cycle,

00:45:49.340 --> 00:45:51.880
and people haven't
upgraded in two weeks,

00:45:51.880 --> 00:45:54.400
and this person hasn't
upgraded in one week.

00:45:54.400 --> 00:45:56.720
Suddenly you have
the newest version

00:45:56.720 --> 00:45:59.030
that you have out,
but really have

00:45:59.030 --> 00:46:01.240
a bunch of people in the
prior one, the one before.

00:46:01.240 --> 00:46:03.720
And it blows up a
lot more than if you

00:46:03.720 --> 00:46:07.380
were releasing twice a
week-- like twice a month,

00:46:07.380 --> 00:46:07.990
for instance.

00:46:07.990 --> 00:46:09.300
Is that the context?

00:46:09.300 --> 00:46:11.050
Yeah, the problem is
that it's not simple.

00:46:11.050 --> 00:46:12.550
We've been dealing
with this problem

00:46:12.550 --> 00:46:16.090
ever since we were even
releasing once a month,

00:46:16.090 --> 00:46:17.490
Android in particular.

00:46:17.490 --> 00:46:23.510
iOS users actually upgrade
much faster than Android users.

00:46:23.510 --> 00:46:25.220
It's probably pretty
obvious why because

00:46:25.220 --> 00:46:30.160
of the different network
connections, et cetera as well.

00:46:30.160 --> 00:46:34.846
So on Android-- I guess to
contrast a little bit with iOS,

00:46:34.846 --> 00:46:36.470
iOS doesn't have an
alpha beta channel.

00:46:36.470 --> 00:46:38.090
We have one, which is nice.

00:46:38.090 --> 00:46:42.660
It's not enough fully, but
we'll take what we can get.

00:46:42.660 --> 00:46:44.970
We still have versions
that exist out there.

00:46:44.970 --> 00:46:50.140
I remember seeing like
a bug of version--

00:46:50.140 --> 00:46:51.640
a server side
change that we made

00:46:51.640 --> 00:46:57.990
by mistake that was breaking
a release that came out

00:46:57.990 --> 00:46:59.380
a year ago.

00:46:59.380 --> 00:47:02.950
So we are still handling--

00:47:04.100 --> 00:47:07.970
We are still handling binaries
that were released a year ago.

00:47:07.970 --> 00:47:10.660
And the answer for that is we
have to be very, very flexible.

00:47:10.660 --> 00:47:12.780
And we really need
to-- we can never

00:47:12.780 --> 00:47:17.450
assume that an APK that is
released will disappear.

00:47:17.450 --> 00:47:20.510
So what do we do?

00:47:20.510 --> 00:47:24.470
We need to make sure that
before we release everything,

00:47:24.470 --> 00:47:25.590
we have tested everything.

00:47:25.590 --> 00:47:27.320
This is why testing
is really important.

00:47:27.320 --> 00:47:28.845
Instrumentation is
super important.

00:47:32.010 --> 00:47:35.260
The most important thing is that
we need to design our server

00:47:35.260 --> 00:47:37.880
APIs in a flexible manner,
because you cannot assume that

00:47:37.880 --> 00:47:39.890
you can deprecate a function.

00:47:39.890 --> 00:47:43.760
So rather than saying this is
the version, version 1, version

00:47:43.760 --> 00:47:47.880
2 of the API call,
we need to invert it.

00:47:47.880 --> 00:47:50.100
We need to think about--

00:47:51.300 --> 00:47:54.570
We need to think about
how do you expose things

00:47:54.570 --> 00:47:58.800
where the client is saying,
give me this information, rather

00:47:58.800 --> 00:48:01.590
than giving-- for instance,
in the case of News Feed,

00:48:01.590 --> 00:48:07.590
is give me the last 10 stories
with this particular fields,

00:48:07.590 --> 00:48:10.280
as opposed to saying,
just give me feed.

00:48:10.280 --> 00:48:12.090
Because that will change.

00:48:12.090 --> 00:48:15.700
So if you tell the server,
give me the last ten

00:48:15.700 --> 00:48:21.179
stories with the message, with
the image, with the image URL,

00:48:21.179 --> 00:48:22.970
it's very different
from just give me feed.

00:48:22.970 --> 00:48:25.010
And I changed the signature.

00:48:25.010 --> 00:48:29.192
So that's by design in the
APIs that we have to do.

00:48:29.192 --> 00:48:29.692
Yeah?

00:48:29.692 --> 00:48:31.628
AUDIENCE: Is the
Facebook testing

00:48:31.628 --> 00:48:35.514
tools and the infrastructure
that you mentioned open source?

00:48:35.514 --> 00:48:36.680
JENNY YUEN: So question is--

00:48:36.680 --> 00:48:38.950
AUDIENCE: [INAUDIBLE]?

00:48:38.950 --> 00:48:43.050
JENNY YUEN: So the question is
if our infrastructure-- I guess

00:48:43.050 --> 00:48:44.660
I'll rephrase it a little bit.

00:48:44.660 --> 00:48:48.450
Let me know if it's accurate.

00:48:48.450 --> 00:48:52.410
Which internal tools are open
source that are available?

00:48:52.410 --> 00:48:54.050
So not everything to be honest.

00:48:54.050 --> 00:48:59.009
So what we do is we
want to make sure

00:48:59.009 --> 00:49:00.800
that a lot of the stuff
that we open source

00:49:00.800 --> 00:49:02.640
is packaged correctly,
and it works well,

00:49:02.640 --> 00:49:04.860
and its generic enough
for people to use.

00:49:04.860 --> 00:49:06.570
We do open source
a lot of stuff.

00:49:06.570 --> 00:49:09.375
The screenshot tests work.

00:49:09.375 --> 00:49:11.700
The author is Arnold Noronha.

00:49:11.700 --> 00:49:15.860
He is an engineer in New York
on the infrastructure team.

00:49:15.860 --> 00:49:17.050
He just released that.

00:49:17.050 --> 00:49:19.490
So if you're making
a lot of UI changes

00:49:19.490 --> 00:49:21.780
and you want to make sure
that stuff is consistent,

00:49:21.780 --> 00:49:22.430
check that out.

00:49:22.430 --> 00:49:25.970
It's called Android
screenshot test framework.

00:49:25.970 --> 00:49:28.680
Unit test, we just use
standard JUnit stuff.

00:49:31.690 --> 00:49:33.860
The end to end test
framework, we're

00:49:33.860 --> 00:49:37.770
actually pulling from the open
source framework community.

00:49:37.770 --> 00:49:38.910
We use Selendroid.

00:49:38.910 --> 00:49:42.410
So we kind of repurpose it
to use our internal tooling,

00:49:42.410 --> 00:49:44.990
but it comes from open source.

00:49:44.990 --> 00:49:47.590
The dependency injection
framework is not open source.

00:49:47.590 --> 00:49:49.550
It's very similar to
Dagger, so I encourage

00:49:49.550 --> 00:49:50.850
you to check that one out.

00:49:54.140 --> 00:49:57.140
Check out our--
so we have a page

00:49:57.140 --> 00:50:02.070
for a bunch of our
Facebook open source tools.

00:50:02.070 --> 00:50:05.430
That will have information
about the different projects.

00:50:05.430 --> 00:50:09.110
Another cool one is Rebound.

00:50:09.110 --> 00:50:11.490
It's a UI library
that allows you

00:50:11.490 --> 00:50:14.340
to make bouncy animations
so that you can use spring

00:50:14.340 --> 00:50:17.180
physics to create elements.

00:50:17.180 --> 00:50:18.610
AUDIENCE: [INAUDIBLE]

00:50:18.610 --> 00:50:19.570
JENNY YUEN: Chat heads.

00:50:19.570 --> 00:50:20.740
That comes from Rebound.

00:50:20.740 --> 00:50:22.739
So I know a lot of companies
have used that one.

00:50:26.528 --> 00:50:27.028
Yes?

00:50:27.028 --> 00:50:32.008
AUDIENCE: Have you started
looking [INAUDIBLE]

00:50:38.490 --> 00:50:41.680
JENNY YUEN: So let me see if I
heard the question correctly.

00:50:41.680 --> 00:50:43.590
When you said that
we transitioned

00:50:43.590 --> 00:50:47.865
from mobile to
everyone writing code,

00:50:47.865 --> 00:50:50.220
did they all have
mobile experience?

00:50:50.220 --> 00:50:52.570
How do we handle
a bunch of that?

00:50:52.570 --> 00:50:56.070
The answer is, we need a
lot of mobile engineers.

00:50:59.820 --> 00:51:03.680
We are hiring a lot for
Android and iOS engineers.

00:51:03.680 --> 00:51:08.285
So if anyone is looking for a
job, come talk to us as well.

00:51:08.285 --> 00:51:10.610
That's my plug for hiring.

00:51:10.610 --> 00:51:14.910
But the point is,
because Android and iOS--

00:51:14.910 --> 00:51:18.950
mobile technologies are fairly
new compared to say, web

00:51:18.950 --> 00:51:20.800
technologies or
systems in general,

00:51:20.800 --> 00:51:24.340
we could not hire enough
people to work on Android.

00:51:24.340 --> 00:51:28.300
We could not hire enough people
to satisfy the rate at which we

00:51:28.300 --> 00:51:29.220
needed people.

00:51:29.220 --> 00:51:31.660
So a couple things we did.

00:51:31.660 --> 00:51:33.990
The first thing is we
hired an in house company

00:51:33.990 --> 00:51:36.952
to come teach us how to do
Android, Big Nerd Ranch.

00:51:36.952 --> 00:51:38.660
So I part of the first
class doing there.

00:51:38.660 --> 00:51:41.225
I was not an Android developer
before I joined Facebook.

00:51:41.225 --> 00:51:44.720
I was actually doing machine
learning and computer vision.

00:51:44.720 --> 00:51:46.360
So we transitioned there.

00:51:46.360 --> 00:51:49.610
One of the things we found
out is that, well, you know,

00:51:49.610 --> 00:51:50.496
it's a language.

00:51:50.496 --> 00:51:51.620
It's a different framework.

00:51:51.620 --> 00:51:54.160
But it's still programming.

00:51:54.160 --> 00:51:59.030
You're dealing with
building a system that

00:51:59.030 --> 00:52:01.380
is going to be having
a lot of uptime

00:52:01.380 --> 00:52:04.510
in a very resource
constrained environment.

00:52:04.510 --> 00:52:08.410
So a lot of the people that
have worked on systems and web

00:52:08.410 --> 00:52:13.530
can apply a lot of that
knowledge into Android itself.

00:52:13.530 --> 00:52:15.340
And they have to
learn about a bunch

00:52:15.340 --> 00:52:18.820
of like the general
framework details.

00:52:18.820 --> 00:52:21.780
So we have found that a
lot of our web and systems

00:52:21.780 --> 00:52:25.530
engineers at Facebook have
been very, very-- have

00:52:25.530 --> 00:52:28.200
contributed a lot
to how our internals

00:52:28.200 --> 00:52:31.320
and how our architecture
patterns have been [INAUDIBLE].

00:52:31.320 --> 00:52:34.530
The second part
is we realized OK,

00:52:34.530 --> 00:52:36.280
since we can't hire
enough Android people,

00:52:36.280 --> 00:52:37.610
how about we train them?

00:52:37.610 --> 00:52:42.620
So at Facebook we have
our bootcamp program.

00:52:42.620 --> 00:52:44.070
When we hire you
into Facebook, we

00:52:44.070 --> 00:52:45.950
don't preallocate
you into a team.

00:52:45.950 --> 00:52:47.590
We have some custom
pipelines that do,

00:52:47.590 --> 00:52:49.610
but most people are generalists.

00:52:49.610 --> 00:52:52.070
And they go through
six weeks of classes

00:52:52.070 --> 00:52:54.220
where they learn how to
use our full systems.

00:52:54.220 --> 00:52:58.550
And back in the day, it was
only the web and the C++ layer.

00:52:58.550 --> 00:53:00.740
And then we realized, OK,
we need to add something

00:53:00.740 --> 00:53:02.570
for mobile, Android and iOS.

00:53:02.570 --> 00:53:07.050
So if you join Facebook now,
after three weeks of learning

00:53:07.050 --> 00:53:11.110
how to use the general web
stack and the system stack,

00:53:11.110 --> 00:53:14.970
we give you the option to join
the iOS track or the Android

00:53:14.970 --> 00:53:17.860
track, or stay in
the systems track.

00:53:17.860 --> 00:53:21.930
And at that point,
we teach classes.

00:53:21.930 --> 00:53:23.930
The classes are
all internal now.

00:53:23.930 --> 00:53:27.890
We developed our
internal curriculum.

00:53:27.890 --> 00:53:31.570
For one week, you learn how
to write Android from scratch

00:53:31.570 --> 00:53:34.240
without the Facebook libraries.

00:53:34.240 --> 00:53:37.450
You build an Instagram app,
like a baby Instagram app.

00:53:37.450 --> 00:53:40.640
And after that first week--
so it's a very intense week.

00:53:40.640 --> 00:53:42.840
And after that, you
learn a lot about how

00:53:42.840 --> 00:53:46.612
to use the Android specific
tools, or iOS specific tools.

00:53:46.612 --> 00:53:48.320
And you start talking
to different teams.

00:53:48.320 --> 00:53:51.700
And then by two weeks in,
you're already contributing

00:53:51.700 --> 00:53:53.096
to our mobile codebases.

00:53:53.096 --> 00:53:54.720
So this is how we
have handled the fact

00:53:54.720 --> 00:53:57.970
that there's not enough
Android developers out there.

00:53:57.970 --> 00:54:00.070
So we train them.

00:54:00.070 --> 00:54:01.362
And that has worked out well.

00:54:01.362 --> 00:54:02.820
And we're still
looking for people.

00:54:08.610 --> 00:54:10.640
Any other questions?

00:54:10.640 --> 00:54:11.260
OK.

00:54:11.260 --> 00:54:13.135
I guess if there are
no more questions,

00:54:13.135 --> 00:54:14.550
I'll stick around here.

00:54:14.550 --> 00:54:17.590
Feel free to stop by, chat.

00:54:17.590 --> 00:54:18.340
Thank you.

00:54:18.340 --> 00:54:20.440
[APPLAUSE]

00:54:22.840 --> 00:54:26.190
[MUSIC PLAYING]

