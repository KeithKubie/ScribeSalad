WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:05.440
[MUSIC PLAYING]

00:00:05.440 --> 00:00:06.709
JAMES LAU: Hello.

00:00:06.709 --> 00:00:07.750
Good afternoon, everyone.

00:00:07.750 --> 00:00:10.010
[APPLAUSE]

00:00:10.010 --> 00:00:12.467
We're so excited
to be here today.

00:00:12.467 --> 00:00:14.050
We know you have a
choice of sessions,

00:00:14.050 --> 00:00:17.770
so thank you for choosing us,
and being here today with us.

00:00:17.770 --> 00:00:21.130
I am James, and I work
on Android Studio.

00:00:21.130 --> 00:00:23.470
And here with me
today is Jerome.

00:00:23.470 --> 00:00:26.560
He's the tech lead for the
build system in Android Studio.

00:00:26.560 --> 00:00:28.270
So we're here today
to talk about one

00:00:28.270 --> 00:00:32.530
of our favorite topics, which
is how to speed up your Android

00:00:32.530 --> 00:00:35.630
Gradle builds.

00:00:35.630 --> 00:00:39.770
Now, slow build speed is a
huge productivity buster.

00:00:39.770 --> 00:00:42.140
It's kind of like
driving down the road

00:00:42.140 --> 00:00:45.830
and constantly hitting speed
bumps after speed bumps.

00:00:45.830 --> 00:00:48.020
We've heard you
loud and clear that

00:00:48.020 --> 00:00:50.962
build speed is critical
to your productivity.

00:00:50.962 --> 00:00:53.420
That's why we've been focused
for the past several quarters

00:00:53.420 --> 00:00:56.180
on improving our build
speed performance.

00:00:56.180 --> 00:00:58.850
Now, to give you
some context on why

00:00:58.850 --> 00:01:01.940
we're so excited to talk
about this subject today--

00:01:01.940 --> 00:01:06.440
over the past year, we've been
hosting a series of developer

00:01:06.440 --> 00:01:08.180
build clinics.

00:01:08.180 --> 00:01:12.050
In these build clinics, we meet
with developers one on one,

00:01:12.050 --> 00:01:14.030
and they would come
to us and tell us

00:01:14.030 --> 00:01:16.460
about their build
performance issues.

00:01:16.460 --> 00:01:18.590
Now, we would play
doctor in these clinics,

00:01:18.590 --> 00:01:21.410
which is kind of fun.

00:01:21.410 --> 00:01:23.720
But the most surprising
part of this-- and this

00:01:23.720 --> 00:01:27.870
was surprising to us, is
that more often than not,

00:01:27.870 --> 00:01:32.120
we would be able to speed up
their development built by 3x,

00:01:32.120 --> 00:01:38.480
4x, sometimes even up to 10x by
applying a simple set of tips.

00:01:38.480 --> 00:01:41.810
And that set of tips is what
we will share with you today.

00:01:45.660 --> 00:01:49.480
Now, our talk today will be
structured into three parts.

00:01:49.480 --> 00:01:51.840
First, I'm going to
talk about the tips

00:01:51.840 --> 00:01:55.730
for improving your
projects' development belts.

00:01:55.730 --> 00:01:58.440
Second, Jerome is
going to talk to you

00:01:58.440 --> 00:02:02.580
about how you can make the most
out of the new Android Gradle

00:02:02.580 --> 00:02:06.510
plugin 3.0 that we just
released yesterday.

00:02:06.510 --> 00:02:10.050
And finally, he will wrap up
by talking about some tools

00:02:10.050 --> 00:02:13.930
and best practices on how
to debug and profile your

00:02:13.930 --> 00:02:15.045
build performance issues.

00:02:19.230 --> 00:02:21.170
So now, let's talk
about the tips

00:02:21.170 --> 00:02:24.140
for speeding up your builds.

00:02:24.140 --> 00:02:26.870
So what I'm going to
show you is that I'm

00:02:26.870 --> 00:02:30.840
going to present these
tips to you one at a time.

00:02:30.840 --> 00:02:33.320
And what I'm also going
to do is that I'm also

00:02:33.320 --> 00:02:37.790
going to use the Santa
Tracker project as an example

00:02:37.790 --> 00:02:41.420
to show you the impact
of each of these tips.

00:02:41.420 --> 00:02:44.540
Now, I'm going to apply
these tips one at a time,

00:02:44.540 --> 00:02:46.310
and we'll see how
fast we can get the

00:02:46.310 --> 00:02:48.380
build to become at the end, OK?

00:02:52.210 --> 00:02:54.630
Before we start though,
I need to talk to you

00:02:54.630 --> 00:02:57.120
a little bit about the
Santa Tracker project.

00:02:57.120 --> 00:02:59.070
Because build
performance is really

00:02:59.070 --> 00:03:02.140
dependent on the
project's characteristics.

00:03:02.140 --> 00:03:04.410
So the Santa
Tracker is organized

00:03:04.410 --> 00:03:07.710
into nine different modules,
including a wear module.

00:03:07.710 --> 00:03:10.230
It has about 500 Java files.

00:03:10.230 --> 00:03:12.810
It's pretty resource-heavy,
with thousands

00:03:12.810 --> 00:03:17.310
of XML files and 3,500 pngs.

00:03:17.310 --> 00:03:22.130
It uses multidex, no annotation
processors, and the final debug

00:03:22.130 --> 00:03:26.730
APK is about 60 megabytes,
so it's fairly large.

00:03:26.730 --> 00:03:29.340
If you would like to explore
more about this project,

00:03:29.340 --> 00:03:31.440
you can find it on Google's
and GitHub account.

00:03:35.070 --> 00:03:37.650
Now, for benchmarking
of this project,

00:03:37.650 --> 00:03:40.590
I'm going to show you three
sets of numbers focused

00:03:40.590 --> 00:03:42.370
on three build scenarios.

00:03:42.370 --> 00:03:44.730
The first one is
simply a full build.

00:03:44.730 --> 00:03:47.070
It's just a clean,
assemble debug.

00:03:47.070 --> 00:03:51.630
The second one is a incremental
build with a Java change.

00:03:51.630 --> 00:03:55.380
It's a one line Java change
in a method implementation.

00:03:55.380 --> 00:03:57.330
And the third one
is an incremental

00:03:57.330 --> 00:03:58.980
build with a resource change.

00:03:58.980 --> 00:04:01.850
And it's a simple add or
remove string resource.

00:04:01.850 --> 00:04:04.950
And we can measure the build
times for each of these.

00:04:04.950 --> 00:04:07.380
Now just remember,
build times are

00:04:07.380 --> 00:04:10.290
highly dependent on your
project's characteristics

00:04:10.290 --> 00:04:11.730
and your build environment.

00:04:11.730 --> 00:04:15.150
So you may get more or you may
get less out of these tips.

00:04:17.899 --> 00:04:20.195
That is to say, actual
results may vary.

00:04:24.050 --> 00:04:28.590
OK, so the first tip is to make
sure you use the latest Android

00:04:28.590 --> 00:04:30.200
Gradle plugin.

00:04:30.200 --> 00:04:33.410
With each release, we
make a lot of bug fixes,

00:04:33.410 --> 00:04:36.350
and fix performance issues,
as well as introduce

00:04:36.350 --> 00:04:37.820
new performance features.

00:04:37.820 --> 00:04:41.550
So you want to make sure you
are able to leverage those.

00:04:41.550 --> 00:04:43.820
Now, there are a couple
of things to note here.

00:04:43.820 --> 00:04:48.320
First one is that starting
with the plugin 3.0,

00:04:48.320 --> 00:04:51.620
we are going to distribute the
plugin through the new Google's

00:04:51.620 --> 00:04:55.010
Maven repository that
we announced yesterday.

00:04:55.010 --> 00:04:57.470
So you need to add that
Maven line at the top

00:04:57.470 --> 00:04:59.420
to get the new plugin.

00:04:59.420 --> 00:05:03.980
Second is that the plugin
often requires specific version

00:05:03.980 --> 00:05:07.220
of build tools, as well as
specific versions of Gradle

00:05:07.220 --> 00:05:08.430
itself.

00:05:08.430 --> 00:05:10.280
So the easiest way
for you to do this

00:05:10.280 --> 00:05:12.680
is, do the update
in Android Studio

00:05:12.680 --> 00:05:14.630
because it will figure
out what it needs,

00:05:14.630 --> 00:05:17.750
and make sure it's
the right combination.

00:05:17.750 --> 00:05:21.860
And third, the 3.0 plugin
is a bit of an exception

00:05:21.860 --> 00:05:24.350
because we introduced
some breaking changes,

00:05:24.350 --> 00:05:26.810
so it might require a
little bit more work

00:05:26.810 --> 00:05:28.370
on your part to update.

00:05:28.370 --> 00:05:30.680
We have published
a migration guide,

00:05:30.680 --> 00:05:33.412
and you'll see the link at
the end of the presentation.

00:05:37.270 --> 00:05:39.310
And this was the
result that I got

00:05:39.310 --> 00:05:41.380
after switching
the Santa Tracker

00:05:41.380 --> 00:05:46.900
project from the old 2.2
plugin to 3.0 alpha 1.

00:05:46.900 --> 00:05:49.210
Now, you can see that
immediately we shaved off

00:05:49.210 --> 00:05:53.980
25% from the full build, 40%
from the incremental Java

00:05:53.980 --> 00:05:58.060
change, and about 16%
for resource change.

00:05:58.060 --> 00:06:01.670
Not bad for updating
to the latest plugin.

00:06:05.040 --> 00:06:10.060
Now, second tip is to
avoid Legacy multidex.

00:06:10.060 --> 00:06:13.630
Now, I think most of you
know that if your app exceeds

00:06:13.630 --> 00:06:18.790
the 64k method reference limit,
you will need to use multidex.

00:06:18.790 --> 00:06:22.750
But what you may not know is
that if your minSdkVersion is

00:06:22.750 --> 00:06:26.500
lower than 21 and
you use multidex,

00:06:26.500 --> 00:06:29.800
you will be using what's
called Legacy multidex, which

00:06:29.800 --> 00:06:32.090
is a lot slower to build.

00:06:32.090 --> 00:06:34.300
So you want to avoid that.

00:06:34.300 --> 00:06:37.630
Now, if you usually start
your build in Android Studio

00:06:37.630 --> 00:06:40.030
by hitting the Run button,
this doesn't really

00:06:40.030 --> 00:06:43.330
apply to you because newer
versions of Android Studio

00:06:43.330 --> 00:06:45.520
will automatically
detect the API

00:06:45.520 --> 00:06:49.060
level of your connected
device or emulator image,

00:06:49.060 --> 00:06:53.600
and switch to native
multidex if applicable.

00:06:53.600 --> 00:06:55.780
But I also know a lot
of you are in the habit

00:06:55.780 --> 00:06:58.190
of doing your builds
from the command line.

00:06:58.190 --> 00:07:00.100
So if you want to
continue to do that,

00:07:00.100 --> 00:07:02.470
you should define a
new product flavor.

00:07:02.470 --> 00:07:05.350
Here, for example, I
call it development.

00:07:05.350 --> 00:07:08.740
And simply set your
minSdkVersion to something

00:07:08.740 --> 00:07:11.560
that 21 or above.

00:07:11.560 --> 00:07:14.660
And on the command line, now you
can call assemble development

00:07:14.660 --> 00:07:17.575
debug, and you will
avoid Legacy multidex.

00:07:20.900 --> 00:07:23.330
And then these are the
results that I got.

00:07:23.330 --> 00:07:26.240
We shaved another five
seconds off the full build,

00:07:26.240 --> 00:07:27.440
a whopping eight seconds--

00:07:27.440 --> 00:07:30.680
that's more than 50%
of what we had before.

00:07:30.680 --> 00:07:33.080
And then incremental
build for resource change

00:07:33.080 --> 00:07:34.700
is about the same
as you would expect.

00:07:39.490 --> 00:07:42.210
Now, the third tip
here is that you

00:07:42.210 --> 00:07:46.050
should disable multi-APK
generation for your development

00:07:46.050 --> 00:07:47.190
build.

00:07:47.190 --> 00:07:51.510
Now, you do this typically
by using the splits block

00:07:51.510 --> 00:07:52.980
in a DSL.

00:07:52.980 --> 00:07:56.790
Multi-APK allows you
to define dimensions

00:07:56.790 --> 00:08:00.360
that you want to generate
multiple SDKs upon.

00:08:00.360 --> 00:08:04.200
The idea here is that you
can tell it to generate along

00:08:04.200 --> 00:08:07.860
dimensions like
ABI or density so

00:08:07.860 --> 00:08:12.390
that it generates these multiple
APKs that are smaller in size.

00:08:12.390 --> 00:08:15.690
Now, small APKs are great
for your release builds,

00:08:15.690 --> 00:08:19.080
but they aren't that important
for your development builds.

00:08:19.080 --> 00:08:21.270
So if you turn it on for
your development builds,

00:08:21.270 --> 00:08:25.080
you'll be wasting time packaging
and creating these APKs

00:08:25.080 --> 00:08:26.040
that you're not using.

00:08:29.600 --> 00:08:33.200
Now, to disable multi-APK
generation properly,

00:08:33.200 --> 00:08:35.570
you can't just disable
it in the splits block

00:08:35.570 --> 00:08:39.409
because that block is global
to all your build variants.

00:08:39.409 --> 00:08:41.450
So one way you
can do it properly

00:08:41.450 --> 00:08:43.490
is to define a
property like here.

00:08:43.490 --> 00:08:46.490
Here I've defined a
property called devBuild.

00:08:46.490 --> 00:08:48.620
And I'm just going
to pass that property

00:08:48.620 --> 00:08:51.410
to Gradle every time I
do a development build.

00:08:51.410 --> 00:08:53.120
And if Gradle sees
that property,

00:08:53.120 --> 00:09:00.050
it will set the splits.abi
and .density.enable to false,

00:09:00.050 --> 00:09:02.420
and the multi-APK
generation will not happen.

00:09:05.690 --> 00:09:09.560
Now, if you're using Studio,
you can also pass this flag

00:09:09.560 --> 00:09:12.680
through the compiler
options under preferences

00:09:12.680 --> 00:09:17.120
by adding -PdevBuild,
in this case.

00:09:17.120 --> 00:09:19.500
With this flag,
every time Studio

00:09:19.500 --> 00:09:22.760
does a build, it will also
pass the same flag to Gradle

00:09:22.760 --> 00:09:25.190
so multi-APK generation
will not occur.

00:09:28.710 --> 00:09:33.240
And these are the numbers I
got after disabling multi-APK.

00:09:33.240 --> 00:09:35.770
Again, some more improvements
across the board.

00:09:40.400 --> 00:09:44.950
Now, Tip 4 is to minimize
the set of resources

00:09:44.950 --> 00:09:47.680
that you package in
your development build.

00:09:47.680 --> 00:09:49.900
Now, by default,
the build system

00:09:49.900 --> 00:09:54.430
will include the resources for
all the languages and screen

00:09:54.430 --> 00:09:58.445
densities that your app and the
libraries that your app uses

00:09:58.445 --> 00:10:00.010
define.

00:10:00.010 --> 00:10:03.010
So if your app supports
many different languages,

00:10:03.010 --> 00:10:05.680
or many different
screen densities,

00:10:05.680 --> 00:10:08.140
then you're actually
wasting a lot

00:10:08.140 --> 00:10:12.280
of time doing work for no reason
because during development

00:10:12.280 --> 00:10:15.310
you're only ever,
probably, going to be using

00:10:15.310 --> 00:10:17.430
one set of those resources.

00:10:17.430 --> 00:10:21.160
Now to do this, you should
use the resConfigs keyword

00:10:21.160 --> 00:10:25.030
and specify the language
and the screen density

00:10:25.030 --> 00:10:27.010
that you need for your
development builds.

00:10:30.980 --> 00:10:33.170
And then you can
see here on the full

00:10:33.170 --> 00:10:36.340
build, we shaved off
in another 6 seconds,

00:10:36.340 --> 00:10:40.040
24% off the incremental
build in Java change,

00:10:40.040 --> 00:10:44.810
and 21% for the incremental
resource change case.

00:10:44.810 --> 00:10:46.080
Continuing to make gains.

00:10:49.320 --> 00:10:53.400
Next up is disabling
png crunching.

00:10:53.400 --> 00:10:59.240
Now by default, AAPT will crunch
your pngs to reduce their size,

00:10:59.240 --> 00:11:01.560
yielding you a smaller APK.

00:11:01.560 --> 00:11:04.740
Again, that's a great thing
for your release APKs,

00:11:04.740 --> 00:11:07.470
but not that important for
your development builds.

00:11:11.850 --> 00:11:15.810
So to avoid png crunching,
you can use the same property

00:11:15.810 --> 00:11:22.170
that we define, and have, at the
aaptOptions and cruncherEnabled

00:11:22.170 --> 00:11:26.920
flag, to disable it if Gradle
sees that properly defined.

00:11:26.920 --> 00:11:30.000
And again, on Gradle, whenever
you do a development build,

00:11:30.000 --> 00:11:34.360
you can pass that property into
Gradle to avoid png crunching.

00:11:37.580 --> 00:11:41.300
The other option to
avoid png crunching

00:11:41.300 --> 00:11:44.510
is to convert all
your pngs into webp.

00:11:44.510 --> 00:11:51.020
Now, webp is up to 25% smaller,
so you get a smaller APK

00:11:51.020 --> 00:11:52.640
to boot.

00:11:52.640 --> 00:11:55.970
Newer versions of Android
Studio also supports conversion

00:11:55.970 --> 00:11:59.540
within the IDE, so you can
easily convert your pngs

00:11:59.540 --> 00:12:01.520
into webp format.

00:12:01.520 --> 00:12:05.300
Now, the only thing that
you need to be careful about

00:12:05.300 --> 00:12:07.490
is the OS requirements.

00:12:07.490 --> 00:12:12.230
If you're using Opaque
webps, API level 15 and above

00:12:12.230 --> 00:12:13.640
will support them.

00:12:13.640 --> 00:12:16.850
But if you have alpha channels
and support transparencies

00:12:16.850 --> 00:12:20.730
in your webp, then you
need API level 18 or above.

00:12:20.730 --> 00:12:22.360
So that is something
to be mindful of.

00:12:26.360 --> 00:12:29.560
So these are the numbers that
I got after disabling png

00:12:29.560 --> 00:12:30.880
crunching.

00:12:30.880 --> 00:12:33.824
So you can see, we shaved
off 9 seconds off the full

00:12:33.824 --> 00:12:34.990
build here, which is pretty.

00:12:34.990 --> 00:12:38.410
Substantial but that's also
because the Santa Tracker

00:12:38.410 --> 00:12:40.390
has a ton of pngs in them.

00:12:40.390 --> 00:12:43.660
So previously, we were spending
a lot of time doing that.

00:12:43.660 --> 00:12:46.780
And for the other ones, they
didn't really change that much.

00:12:46.780 --> 00:12:48.760
Now here's the kicker--

00:12:48.760 --> 00:12:51.850
when I looked at the
APK size with crunching

00:12:51.850 --> 00:12:55.630
and without crunching, turns
out there was no difference.

00:12:55.630 --> 00:12:57.430
Turns out Santa
Tracker was already

00:12:57.430 --> 00:13:00.760
using pretty optimal
pngs to begin with,

00:13:00.760 --> 00:13:03.140
and it was just doing png
crunching for no reason.

00:13:07.040 --> 00:13:10.310
OK, Tip 6 is to use Instant Run.

00:13:10.310 --> 00:13:14.780
So Instant Run was launched
in Android Studio 2.0.

00:13:14.780 --> 00:13:16.910
Since then, we have
spent a lot of time

00:13:16.910 --> 00:13:19.390
improving its reliability.

00:13:19.390 --> 00:13:23.450
The version of Instant Run
that we are launching with 3.0

00:13:23.450 --> 00:13:25.910
is massively different than 2.0.

00:13:25.910 --> 00:13:28.070
We have removed a
lot of hacks that we

00:13:28.070 --> 00:13:30.560
made to work around
platform limitations

00:13:30.560 --> 00:13:32.720
to make things more reliable.

00:13:32.720 --> 00:13:35.030
The trade off is,
Instant Run will now only

00:13:35.030 --> 00:13:37.760
work on API level 21 or above.

00:13:37.760 --> 00:13:41.960
Now, that does not mean you
can't have your app's min SDK

00:13:41.960 --> 00:13:43.430
version set to lower.

00:13:43.430 --> 00:13:44.990
It just means the
device that you're

00:13:44.990 --> 00:13:49.100
running Instant App on
need to be 21 or above.

00:13:49.100 --> 00:13:50.750
We've also tweaked that UI.

00:13:50.750 --> 00:13:54.170
So instead of having a
single Instant Run button,

00:13:54.170 --> 00:13:58.040
the button is now separated
into a run and an apply changes

00:13:58.040 --> 00:13:59.000
button.

00:13:59.000 --> 00:14:00.890
When you hit the
Run button, we will

00:14:00.890 --> 00:14:04.340
try to do a cold
swap, and the acti--

00:14:04.340 --> 00:14:07.106
the app, excuse me,
will always restart.

00:14:07.106 --> 00:14:08.480
When you click
the Apply Changes,

00:14:08.480 --> 00:14:11.570
we will try to do a
hot or warm swap first.

00:14:11.570 --> 00:14:14.570
And that would push changes
directly into the live process.

00:14:17.680 --> 00:14:20.460
Now, one thing to
note, though, is

00:14:20.460 --> 00:14:22.900
that when you use
Instant Run, it

00:14:22.900 --> 00:14:25.480
makes your lives a little
bit easier because we, again,

00:14:25.480 --> 00:14:29.620
automatically look at the target
device, look at its API level,

00:14:29.620 --> 00:14:32.920
and look at the set of resources
it needs, and automatically

00:14:32.920 --> 00:14:36.430
built the minimal thing that
the target device requires.

00:14:36.430 --> 00:14:40.240
So even if you didn't define
a separate product flavor,

00:14:40.240 --> 00:14:42.880
you would automatically get
some of the optimizations.

00:14:46.440 --> 00:14:49.560
And these are the
numbers that I got after.

00:14:49.560 --> 00:14:52.480
Notice, there is--
we actually regressed

00:14:52.480 --> 00:14:54.680
by seven seconds
for the full build.

00:14:54.680 --> 00:14:58.520
The reason for that is that, in
order for Instant Run to work,

00:14:58.520 --> 00:15:01.780
we have to do extra
work to shard the APKs,

00:15:01.780 --> 00:15:04.370
and to do bytecode
manipulation to prepare

00:15:04.370 --> 00:15:08.120
your app for future hot,
warm, and cold swaps.

00:15:08.120 --> 00:15:11.850
So that's where the
seven seconds came from.

00:15:11.850 --> 00:15:14.260
We're working to drive
that number down.

00:15:14.260 --> 00:15:18.110
Now, hopefully you'll see that
for the incremental changes,

00:15:18.110 --> 00:15:21.380
we shaved off three seconds
for each of those cases.

00:15:21.380 --> 00:15:24.650
Hopefully after you do a few
of the incremental changes,

00:15:24.650 --> 00:15:28.180
you would recoup the
initial build slow down.

00:15:31.800 --> 00:15:35.250
Now, Tip 7 is a fun one.

00:15:35.250 --> 00:15:39.180
It's that you should
avoid inadvertent changes

00:15:39.180 --> 00:15:41.280
to your project.

00:15:41.280 --> 00:15:44.520
And the code shown here
is an example of such.

00:15:44.520 --> 00:15:47.970
At first glance, it
seems pretty reasonable.

00:15:47.970 --> 00:15:51.180
The code here is basically
just using the current DateTime

00:15:51.180 --> 00:15:53.094
as the version
code for your app.

00:15:53.094 --> 00:15:54.510
Which is a reasonable
thing to do,

00:15:54.510 --> 00:15:57.360
because every time
you build, you

00:15:57.360 --> 00:16:01.470
want to have a unique ID so that
when your QA team logs a bug,

00:16:01.470 --> 00:16:04.260
they can tell you
which build it was.

00:16:04.260 --> 00:16:06.300
Now the reason
why this is bad is

00:16:06.300 --> 00:16:09.330
because this would force your
Android manifest to change

00:16:09.330 --> 00:16:12.570
at every build, even the
ones that you you are not

00:16:12.570 --> 00:16:13.870
distributing to anybody.

00:16:21.570 --> 00:16:23.610
Now, Santa Tracker
didn't have this problem,

00:16:23.610 --> 00:16:28.200
but I simulated this by forcing
a manifest change every time.

00:16:28.200 --> 00:16:30.790
And this was the result.
So as you can see,

00:16:30.790 --> 00:16:33.090
if I had that code
in my project,

00:16:33.090 --> 00:16:37.320
I would have added 3 seconds
to my incremental Java

00:16:37.320 --> 00:16:39.830
build every time,
and 3.6 seconds

00:16:39.830 --> 00:16:42.660
to my incremental resource
change every time.

00:16:42.660 --> 00:16:43.770
That's huge.

00:16:43.770 --> 00:16:46.200
And that's time spent
for no good reason.

00:16:49.690 --> 00:16:51.640
Now, in the previous
example, you

00:16:51.640 --> 00:16:57.310
can easily fix this by, again,
conditioning the setting

00:16:57.310 --> 00:17:01.540
of the unique version code
based on the devBuild property

00:17:01.540 --> 00:17:03.170
that we were using earlier.

00:17:03.170 --> 00:17:06.650
So in this case, if that
property is defined,

00:17:06.650 --> 00:17:08.859
then we set it to
a static value.

00:17:08.859 --> 00:17:10.900
If not, we will
generate a unique value.

00:17:17.079 --> 00:17:19.359
Now, having bad code
in your build script

00:17:19.359 --> 00:17:22.300
is not the only way
to get into trouble.

00:17:22.300 --> 00:17:25.000
I know a lot of you
use Crashlytics.

00:17:25.000 --> 00:17:30.120
And it's a great product,
so it must be safe, right?

00:17:30.120 --> 00:17:31.800
Well, that depends.

00:17:31.800 --> 00:17:35.160
Turns out Crashlytics
by default will always

00:17:35.160 --> 00:17:38.790
generate a unique build
ID on every build.

00:17:38.790 --> 00:17:42.040
But they provide a flag
for you to turn this off.

00:17:42.040 --> 00:17:44.250
So you need to be careful
about setting this flag.

00:17:44.250 --> 00:17:45.900
You should set this
flag in your debug

00:17:45.900 --> 00:17:49.980
build's or development build's
alwaysUpdateBuildID to false.

00:17:49.980 --> 00:17:52.260
They also supply
a different flag

00:17:52.260 --> 00:17:54.194
to disable Crashlytics
altogether,

00:17:54.194 --> 00:17:55.860
and you can consider
using that as well.

00:17:59.530 --> 00:18:03.770
Now, Tip 8 is that you should
not use dynamic versions.

00:18:03.770 --> 00:18:07.530
Gradle provides a very
convenient way for you

00:18:07.530 --> 00:18:10.950
to tell Gradle that, hey,
I want to use the latest

00:18:10.950 --> 00:18:14.570
version of this library,
through this plus symbol here.

00:18:14.570 --> 00:18:17.280
Now, it's bad for a
couple of reasons.

00:18:17.280 --> 00:18:19.560
From a performance
perspective, that

00:18:19.560 --> 00:18:22.260
will make Gradle check for
new versions of that library

00:18:22.260 --> 00:18:26.010
every 24 hours, causing
your dependency resolution

00:18:26.010 --> 00:18:28.670
time to increase.

00:18:28.670 --> 00:18:32.880
Now, even if you are
OK with that hit,

00:18:32.880 --> 00:18:37.680
it's still bad because it makes
your build nondeterministic.

00:18:37.680 --> 00:18:40.960
You do a build today compared
to a build two weeks from now,

00:18:40.960 --> 00:18:43.410
you might be building
completely different things

00:18:43.410 --> 00:18:46.320
because the libraries have
changed underneath of you.

00:18:46.320 --> 00:18:47.670
So please avoid doing this.

00:18:52.160 --> 00:18:56.510
Tip 9 is that you should
be careful about the amount

00:18:56.510 --> 00:18:59.180
of memory you're
giving to Gradle.

00:18:59.180 --> 00:19:02.270
In Android Studio, when you
create a brand new project,

00:19:02.270 --> 00:19:07.610
by default we will give Gradle
1.5 gigabytes of memory.

00:19:07.610 --> 00:19:09.680
That might be a good
setting for your project,

00:19:09.680 --> 00:19:11.775
or it might be a bad
setting for your project,

00:19:11.775 --> 00:19:12.650
we don't really know.

00:19:12.650 --> 00:19:15.770
Because it really depends
on the characteristics

00:19:15.770 --> 00:19:16.760
of your project.

00:19:16.760 --> 00:19:21.600
So you should tweak this
setting to see what's optimal.

00:19:21.600 --> 00:19:25.280
Now, another thing I want to
call out is that in our DSL,

00:19:25.280 --> 00:19:27.560
we have this dexOptions
where we allow

00:19:27.560 --> 00:19:32.360
you to set the javaMaxHeapSize
for the dex process.

00:19:32.360 --> 00:19:36.110
This made a lot of sense
when dex was out of process.

00:19:36.110 --> 00:19:41.780
But since the plugin 2.1, dex
is now in-process by default.

00:19:41.780 --> 00:19:44.600
So you should not really
set this flag anymore.

00:19:44.600 --> 00:19:46.430
So if you have it, you
can just delete it.

00:19:51.060 --> 00:19:53.760
Now, the last tip here
is that you should

00:19:53.760 --> 00:19:57.240
enable the new Gradle cache.

00:19:57.240 --> 00:20:00.750
Now, if you were at the
What's New for Dev Tools talk

00:20:00.750 --> 00:20:04.390
this morning, you might have
heard Xavier talk about this.

00:20:04.390 --> 00:20:07.470
This is a new caching
mechanism from Gradle

00:20:07.470 --> 00:20:12.690
where you can cache all the
task outputs from every task.

00:20:12.690 --> 00:20:16.470
Now, this is different
from the build cache

00:20:16.470 --> 00:20:20.730
that we introduced in Android
Studio 2.3, which only cached

00:20:20.730 --> 00:20:24.060
pre-dexed external libraries.

00:20:24.060 --> 00:20:27.850
Now, this cache uses the
same up to date mechanism,

00:20:27.850 --> 00:20:30.150
but it doesn't only
work for the last build,

00:20:30.150 --> 00:20:33.960
but it works for any previous
build from any location.

00:20:33.960 --> 00:20:36.240
Which means it would
really speed up your

00:20:36.240 --> 00:20:38.640
build when you switch
branches, and it will

00:20:38.640 --> 00:20:42.480
enable distributed caching.

00:20:42.480 --> 00:20:44.310
Because this is so
new, we haven't fully

00:20:44.310 --> 00:20:47.490
taken advantage of
it yet in Canary 1,

00:20:47.490 --> 00:20:51.400
but we are actively
working on this in 3.0.

00:20:51.400 --> 00:20:55.110
So our advice to you is that
you should set this to true now,

00:20:55.110 --> 00:20:56.220
turn it on.

00:20:56.220 --> 00:20:58.980
And through the next
several Canarys previews

00:20:58.980 --> 00:21:00.720
and eventually
stable, you should

00:21:00.720 --> 00:21:03.374
see progressively
improved performance.

00:21:06.340 --> 00:21:07.930
And these are the
numbers that I got

00:21:07.930 --> 00:21:10.270
after turning on
the build cache,

00:21:10.270 --> 00:21:14.050
even though we haven't fully
take taken advantage of it yet.

00:21:14.050 --> 00:21:18.940
So you can see the full
build actually dropped down

00:21:18.940 --> 00:21:22.720
by seven seconds, and it
negated the regression that

00:21:22.720 --> 00:21:25.060
was introduced by Instant Run.

00:21:25.060 --> 00:21:27.932
And the incremental build
actually got slightly slower.

00:21:27.932 --> 00:21:29.640
That's something that
we're looking into.

00:21:33.360 --> 00:21:35.840
So here are the
cumulative improvements

00:21:35.840 --> 00:21:38.450
after applying all these tips.

00:21:38.450 --> 00:21:41.360
The full build is now
three times faster.

00:21:41.360 --> 00:21:44.750
The incremental Java
build is 12 times faster.

00:21:44.750 --> 00:21:47.000
And the resource change is
also three times faster.

00:21:52.357 --> 00:21:53.331
[APPLAUSE]

00:21:53.331 --> 00:21:54.305
Thank you.

00:22:01.610 --> 00:22:05.050
Now, here is a summary
of all the tips.

00:22:05.050 --> 00:22:07.900
I have also created
a GitHub repo

00:22:07.900 --> 00:22:11.110
if you want to be able to
reproduce some of these results

00:22:11.110 --> 00:22:14.860
and experiment with some
of these tips yourselves.

00:22:14.860 --> 00:22:17.240
And that's it for me.

00:22:17.240 --> 00:22:18.296
Thank you, James.

00:22:18.296 --> 00:22:23.976
[APPLAUSE]

00:22:23.976 --> 00:22:25.600
JEROME DOCHEZ: All
right, so up to now,

00:22:25.600 --> 00:22:28.510
you've seen a number
of tricks and tips

00:22:28.510 --> 00:22:29.850
to help with the performance.

00:22:29.850 --> 00:22:31.600
Now I would like to
talk a little bit more

00:22:31.600 --> 00:22:35.740
about some more radical changes
you can do with your build

00:22:35.740 --> 00:22:37.450
to leverage some of
the new feature that

00:22:37.450 --> 00:22:40.120
comes with Gradle plugin 3.0.

00:22:40.120 --> 00:22:42.040
And in particular,
I'd like to talk

00:22:42.040 --> 00:22:45.100
about the multi-module projects.

00:22:45.100 --> 00:22:48.160
So we've had multi-module
projects for a long time,

00:22:48.160 --> 00:22:52.240
but we used to discourage it
because we had, quite honestly,

00:22:52.240 --> 00:22:55.250
a lot of issues both in
Gradle and in Android

00:22:55.250 --> 00:22:57.070
plugin around scalability.

00:22:57.070 --> 00:22:59.860
As you had more
and more modules,

00:22:59.860 --> 00:23:02.620
the thing was getting
slower and slower.

00:23:02.620 --> 00:23:05.470
So we worked really hard
with Gradle to fix this.

00:23:05.470 --> 00:23:09.220
And now we totally
recommend you to go

00:23:09.220 --> 00:23:12.720
to the multi-module project
if that makes sense for you.

00:23:12.720 --> 00:23:14.020
But what do you have to do?

00:23:14.020 --> 00:23:16.210
So if you remember, or if
you have created projects

00:23:16.210 --> 00:23:19.090
with Android Studio
from scratch,

00:23:19.090 --> 00:23:21.560
any project Studio
created from templates

00:23:21.560 --> 00:23:24.260
is a multi-module
project to start with.

00:23:24.260 --> 00:23:26.430
It just has one,
but you can add it.

00:23:26.430 --> 00:23:28.930
It's ready to be multi-module.

00:23:28.930 --> 00:23:33.070
To do that, you just need to
include a few more subfolders

00:23:33.070 --> 00:23:35.800
in your main settings.Gradle.

00:23:35.800 --> 00:23:38.230
And then you can start moving
code from, say, the app

00:23:38.230 --> 00:23:40.060
into the lib1 or the lib2.

00:23:40.060 --> 00:23:42.100
Obviously this sounds very easy.

00:23:42.100 --> 00:23:45.400
Modularity is not
easy, I can guarantee.

00:23:45.400 --> 00:23:47.710
It's going to be painful
if you want to do this.

00:23:47.710 --> 00:23:49.510
Not painful, but it's
going to be hard.

00:23:49.510 --> 00:23:52.022
And it's not something you
should do over the weekend.

00:23:52.022 --> 00:23:53.230
It's going to take some time.

00:23:55.605 --> 00:23:57.230
However, we're going
to see that it has

00:23:57.230 --> 00:23:59.300
a lot of improvements with it.

00:23:59.300 --> 00:24:02.450
So here we have an
example of three modules--

00:24:02.450 --> 00:24:04.760
the app, which is
importing the lib, which

00:24:04.760 --> 00:24:06.137
itself is importing the lib 2.

00:24:06.137 --> 00:24:07.970
As you can see, it is
a straight dependency.

00:24:07.970 --> 00:24:11.120
We are using the compile
configuration to define this.

00:24:11.120 --> 00:24:13.820
And as you do a code
change, before in 3.0,

00:24:13.820 --> 00:24:16.820
say you're doing some
code change in lib 2,

00:24:16.820 --> 00:24:19.150
you would start recompiling
lib1 because, say,

00:24:19.150 --> 00:24:21.602
your code change may be
removing a public method.

00:24:21.602 --> 00:24:23.060
So of course you
need to recompile,

00:24:23.060 --> 00:24:26.420
whoever is using that
particular lib tool to make sure

00:24:26.420 --> 00:24:28.370
that you not using that method.

00:24:28.370 --> 00:24:31.550
But it will also retrigger
completion of app,

00:24:31.550 --> 00:24:35.900
and that's because the compile
dependency is transitive.

00:24:35.900 --> 00:24:38.810
That means that app,
which depends lib1,

00:24:38.810 --> 00:24:41.750
kind of transitively
also depends on lib2 just

00:24:41.750 --> 00:24:46.640
because lib1 itself
was importing lib2.

00:24:46.640 --> 00:24:52.340
And that's some of the thing
that is going to change in 3.0.

00:24:52.340 --> 00:24:55.090
Now, the first thing that
Gradle is giving us for free

00:24:55.090 --> 00:24:56.916
is compilation avoidance.

00:24:56.916 --> 00:24:58.290
So you don't have
to do anything.

00:24:58.290 --> 00:25:02.170
You're going to reap some of the
benefits from it immediately.

00:25:02.170 --> 00:25:04.030
And what they do is
that they came up

00:25:04.030 --> 00:25:05.500
with the notion of an ABI.

00:25:05.500 --> 00:25:08.230
An ABI is the Application
Binary Interface.

00:25:08.230 --> 00:25:10.150
In simple terms,
it means basically

00:25:10.150 --> 00:25:12.190
your public methods
and fields, anything

00:25:12.190 --> 00:25:15.160
that can be invoked
outside of the module.

00:25:15.160 --> 00:25:18.040
So you can have an ABI change,
or you can have a non-ABI

00:25:18.040 --> 00:25:20.850
change, depending on whether
or not you are using a public--

00:25:20.850 --> 00:25:23.870
you're changing a public API.

00:25:23.870 --> 00:25:26.819
Now, a non-ABI change has
no impact on consumers.

00:25:26.819 --> 00:25:28.360
If you're changing
the implementation

00:25:28.360 --> 00:25:32.206
of a method which is
private, why should the--

00:25:32.206 --> 00:25:33.580
or even if it's
public, actually,

00:25:33.580 --> 00:25:36.850
if it's just implementation of
a method, none of the consumers

00:25:36.850 --> 00:25:39.310
are going to be impacted by
this change of implementation.

00:25:39.310 --> 00:25:40.840
So you don't have
to recompile them.

00:25:40.840 --> 00:25:43.930
However, obviously, if you're
removing a public method

00:25:43.930 --> 00:25:46.000
or changing a public
method signature,

00:25:46.000 --> 00:25:47.560
this is an ABI change.

00:25:47.560 --> 00:25:51.400
This will trigger consumer
modules to be recompiled.

00:25:51.400 --> 00:25:53.620
So far it's pretty simple.

00:25:53.620 --> 00:25:55.100
So let's look how it looks.

00:25:55.100 --> 00:25:56.710
I have non-ABI change.

00:25:56.710 --> 00:25:59.830
So something which is private
to lib2 is being changed.

00:25:59.830 --> 00:26:01.400
Nothing is recompiled.

00:26:01.400 --> 00:26:05.380
Now, I have an ABI change,
and we are going back

00:26:05.380 --> 00:26:09.850
to the original case of
pre-3.0 recompilation.

00:26:09.850 --> 00:26:12.940
I'm changing something
which is visibly lib2.

00:26:12.940 --> 00:26:16.350
lib1, which is importing it
directly, has to be recompiled.

00:26:16.350 --> 00:26:20.050
And app, which is
importing it transitively,

00:26:20.050 --> 00:26:22.120
also has to be recompiled.

00:26:22.120 --> 00:26:27.580
That's really very annoying
because why would you

00:26:27.580 --> 00:26:29.430
want to recompile app?

00:26:29.430 --> 00:26:31.180
From this diagram, it
seems pretty obvious

00:26:31.180 --> 00:26:33.460
that app is not using lib2.

00:26:33.460 --> 00:26:35.380
But the fact is
that, because it's

00:26:35.380 --> 00:26:38.110
declared through this
compiled configuration,

00:26:38.110 --> 00:26:42.520
Gradle does not know if
app is using the ability

00:26:42.520 --> 00:26:45.100
to use the lib2 interface.

00:26:45.100 --> 00:26:49.900
Basically, the compile leak,
the implementation detail

00:26:49.900 --> 00:26:54.400
of lib1, which is the lib2,
to the consumers of itself.

00:26:54.400 --> 00:26:57.190
That means that now app
can see lib1 and lib2,

00:26:57.190 --> 00:26:58.660
and that's really,
really something

00:26:58.660 --> 00:27:01.540
that needed to be changed.

00:27:01.540 --> 00:27:04.300
Now, let's have a look
on how that really

00:27:04.300 --> 00:27:08.410
ripples into when you have a
really big [INAUDIBLE] board

00:27:08.410 --> 00:27:08.950
of modules.

00:27:08.950 --> 00:27:11.160
Here we've got only
nine modules, that--

00:27:11.160 --> 00:27:13.140
eight modules,
that's pretty simple.

00:27:13.140 --> 00:27:16.060
But say you have 50 modules,
and you have one leaf module

00:27:16.060 --> 00:27:19.450
at the very bottom, and you're
making a non-ABI code change.

00:27:19.450 --> 00:27:24.280
So that has to be recompiled,
that's pretty obvious right?

00:27:24.280 --> 00:27:27.500
Now, let's switch to
the ABI code change.

00:27:27.500 --> 00:27:30.025
Let's say that now we
are changing a public API

00:27:30.025 --> 00:27:31.840
of that really leaf module.

00:27:31.840 --> 00:27:33.460
Of course we're going
to recompile it.

00:27:33.460 --> 00:27:35.110
And then we're
going to recompile

00:27:35.110 --> 00:27:37.570
all the immediate users.

00:27:37.570 --> 00:27:40.150
But because they
are transitively

00:27:40.150 --> 00:27:42.070
dependent on each
other, why, you're going

00:27:42.070 --> 00:27:43.420
to compile the other ones, too.

00:27:43.420 --> 00:27:45.711
And then eventually, you're
going to recompile the app.

00:27:45.711 --> 00:27:47.380
Now, if you've had
250 modules, you're

00:27:47.380 --> 00:27:49.570
going to recompile 250 modules.

00:27:49.570 --> 00:27:53.080
And app-- when you've got an
SDK, common type of library,

00:27:53.080 --> 00:27:55.340
this will happen quite a bit.

00:27:55.340 --> 00:28:00.160
So basically what
Gradle realized

00:28:00.160 --> 00:28:03.010
is that compile is all wrong.

00:28:03.010 --> 00:28:05.460
And there was no
distinction between,

00:28:05.460 --> 00:28:09.280
oh, I want to use this
library as an implementation

00:28:09.280 --> 00:28:12.160
detail of my library,
but by no mean should you

00:28:12.160 --> 00:28:14.770
be using the API
of this library,

00:28:14.770 --> 00:28:18.660
because you should only be
using the API of my library.

00:28:18.660 --> 00:28:22.120
Versus, oh yeah, not
only am I using this API,

00:28:22.120 --> 00:28:24.430
but I'm offering each
API as part of mine.

00:28:24.430 --> 00:28:26.480
As a composition, if you want.

00:28:26.480 --> 00:28:29.920
So say, for instance, you are a
library and you're using Guava,

00:28:29.920 --> 00:28:31.301
you want to provide your API.

00:28:31.301 --> 00:28:32.800
It doesn't really
mean that you want

00:28:32.800 --> 00:28:35.830
your users to use the
Guava API through you,

00:28:35.830 --> 00:28:39.490
because that's really nasty
when you think of a time, right?

00:28:39.490 --> 00:28:42.280
What about if you want to remove
Guava from your implementation

00:28:42.280 --> 00:28:45.160
detail because now you're
using the new JDK collection

00:28:45.160 --> 00:28:47.330
clusters, and Guava
is not useful anymore?

00:28:47.330 --> 00:28:51.430
Why, you can't, because
you used in the past

00:28:51.430 --> 00:28:56.200
to provide Guava as a transitive
dependency of your module.

00:28:56.200 --> 00:28:58.810
So therefore you can
break your clients.

00:28:58.810 --> 00:29:01.670
People can start using Guava
API through your module,

00:29:01.670 --> 00:29:03.530
and that's it.

00:29:03.530 --> 00:29:07.480
So really, this compiled
dependency was all wrong.

00:29:07.480 --> 00:29:09.850
And all consumers
of a module consumes

00:29:09.850 --> 00:29:13.120
all of their transitive
dependencies, which basically

00:29:13.120 --> 00:29:16.300
was yielding way too
many details about how

00:29:16.300 --> 00:29:18.310
you implement it.

00:29:18.310 --> 00:29:20.560
So they came up--

00:29:20.560 --> 00:29:24.400
Gradle came up with a new way
of declaring your dependencies.

00:29:24.400 --> 00:29:26.380
Compile is not
deprecated, and it's

00:29:26.380 --> 00:29:29.680
replaced by two new
configurations, either API

00:29:29.680 --> 00:29:31.150
or implementation.

00:29:31.150 --> 00:29:33.370
So you can see
here, I'm replacing

00:29:33.370 --> 00:29:35.830
what I used to declare
X and Y with one

00:29:35.830 --> 00:29:38.190
declares as an
implementation detail--

00:29:38.190 --> 00:29:39.520
that's implementation.

00:29:39.520 --> 00:29:44.260
So that means that I'm consuming
libx as an implementation

00:29:44.260 --> 00:29:47.620
detail, but none of my
users will have access

00:29:47.620 --> 00:29:50.950
to its implementation,
to its API.

00:29:50.950 --> 00:29:56.860
However, I'm also using liby,
and I'm also offering its API

00:29:56.860 --> 00:29:57.960
as part of my API.

00:29:57.960 --> 00:30:00.670
I'm composing over
that particular module.

00:30:00.670 --> 00:30:04.790
So this is strict
distinction between the two.

00:30:04.790 --> 00:30:10.060
Now, API is basically the
equivalent of the old compile.

00:30:10.060 --> 00:30:11.410
It's the easy way to go.

00:30:11.410 --> 00:30:14.710
If you were to do a search and
replace by compile with API,

00:30:14.710 --> 00:30:16.070
it would just work.

00:30:16.070 --> 00:30:18.310
But we totally not
recommend doing this

00:30:18.310 --> 00:30:20.820
because, again, you're going
to leak all your dependencies,

00:30:20.820 --> 00:30:23.320
and that's a bad idea.

00:30:23.320 --> 00:30:25.660
Better would be to
use implementation.

00:30:25.660 --> 00:30:30.341
Then you clearly say, I'm using
an implementation details.

00:30:30.341 --> 00:30:32.090
As an implementation
detail of my library,

00:30:32.090 --> 00:30:34.270
I'm using this
module, and I am not

00:30:34.270 --> 00:30:37.360
going to leak it to my users.

00:30:37.360 --> 00:30:38.440
Seems pretty easy.

00:30:38.440 --> 00:30:40.870
So in fact, you should
probably just do a search

00:30:40.870 --> 00:30:43.960
and replace of all your compile,
replace it with implementation.

00:30:43.960 --> 00:30:48.950
Your build might break because
some users of your library

00:30:48.950 --> 00:30:51.744
somewhere was using actually
a dependency you were leaking.

00:30:51.744 --> 00:30:53.410
The only thing that
you would have to do

00:30:53.410 --> 00:30:55.810
is that it would have
to directly also declare

00:30:55.810 --> 00:30:58.480
their dependency on whichever
module they were actually

00:30:58.480 --> 00:31:00.581
using.

00:31:00.581 --> 00:31:03.080
So it's a little bit more work,
but it shouldn't be too bad.

00:31:03.080 --> 00:31:05.210
Now, let's look
how it looks like.

00:31:05.210 --> 00:31:09.190
Again, if you do a non-ABI
change, nothing happens.

00:31:09.190 --> 00:31:10.690
You're changing lib2.

00:31:10.690 --> 00:31:12.280
lib1 and app are
not to be compiled.

00:31:12.280 --> 00:31:13.960
No change here.

00:31:13.960 --> 00:31:15.890
But if you switch
to the ABI change,

00:31:15.890 --> 00:31:17.650
this was what we used to have.

00:31:17.650 --> 00:31:23.470
Now with an ABI change, app
is not recompiled any longer.

00:31:23.470 --> 00:31:27.790
Only lib1 would be recompiled
because lib2 2 is not

00:31:27.790 --> 00:31:29.260
visible to app.

00:31:29.260 --> 00:31:32.120
This may seem to be a
very little small detail.

00:31:32.120 --> 00:31:35.830
But when you come back to
the example I gave earlier

00:31:35.830 --> 00:31:38.430
where you had this ABI code
change at the leaf module,

00:31:38.430 --> 00:31:39.430
you remember?

00:31:39.430 --> 00:31:42.580
I was compiling, obviously,
the module that changes.

00:31:42.580 --> 00:31:45.040
You're still going to
recompile all the modules that

00:31:45.040 --> 00:31:48.190
imported directly, but it's
going to stop right there.

00:31:48.190 --> 00:31:50.890
It's not going to
recompile anything else.

00:31:50.890 --> 00:31:55.120
Now, here you can see,
I'm saving about 50%

00:31:55.120 --> 00:31:56.690
of recompilation.

00:31:56.690 --> 00:31:57.230
Not too bad.

00:31:57.230 --> 00:31:59.440
But if you have an
application with 5,200

00:31:59.440 --> 00:32:01.480
or whatever number
of modules, this

00:32:01.480 --> 00:32:04.580
can be substantial saving, OK?

00:32:07.280 --> 00:32:09.360
So it adds up.

00:32:09.360 --> 00:32:12.550
You have compilation avoidance,
plus this API implementation

00:32:12.550 --> 00:32:13.500
configurations.

00:32:13.500 --> 00:32:16.610
You're going to get
much faster builds.

00:32:16.610 --> 00:32:21.170
I want to talk about one last
final note on modularity.

00:32:21.170 --> 00:32:23.090
When you have multiple
modules, Gradle

00:32:23.090 --> 00:32:24.590
can build them in parallel.

00:32:24.590 --> 00:32:27.110
We've had issues where
sometimes one task has

00:32:27.110 --> 00:32:30.350
to run before a number of other
tasks waiting for it to finish

00:32:30.350 --> 00:32:32.060
can be running.

00:32:32.060 --> 00:32:33.620
When you do things
in parallel, you

00:32:33.620 --> 00:32:35.520
don't have such issues anymore.

00:32:35.520 --> 00:32:37.100
So this is really
a great advantage,

00:32:37.100 --> 00:32:41.180
to use multi-core machines
when you have multiple modules.

00:32:41.180 --> 00:32:43.880
Having multiple modules
is a great workaround

00:32:43.880 --> 00:32:45.979
for the lack of some of
the incremental tasks.

00:32:45.979 --> 00:32:48.020
As you may have heard by
now, and something which

00:32:48.020 --> 00:32:51.020
is very important, javac task--

00:32:51.020 --> 00:32:53.930
the task that compile your
Java code into class files,

00:32:53.930 --> 00:32:56.030
is, in theory, incremental.

00:32:56.030 --> 00:33:00.020
However, as soon as you start
using annotation processes,

00:33:00.020 --> 00:33:02.090
we have to turn out
the incrementality

00:33:02.090 --> 00:33:04.070
because some
annotation processes,

00:33:04.070 --> 00:33:05.384
they want to see the world.

00:33:05.384 --> 00:33:06.800
You know, they
want to see Dagger,

00:33:06.800 --> 00:33:08.780
they want to see all
the injection points.

00:33:08.780 --> 00:33:10.119
Are they all satisfied?

00:33:10.119 --> 00:33:11.660
So even if you change
only one class,

00:33:11.660 --> 00:33:14.180
you have to recompile everything
so that the annotation

00:33:14.180 --> 00:33:17.970
processes can be fed,
and react appropriately.

00:33:17.970 --> 00:33:21.815
Now, if you split this javac
task into multiple modules,

00:33:21.815 --> 00:33:23.190
none of them will
be incremental.

00:33:23.190 --> 00:33:25.356
But because they will be
much smaller, each of them,

00:33:25.356 --> 00:33:28.590
they going to be much faster.

00:33:28.590 --> 00:33:31.370
We try in the Gradle plugin
to provide some parallelism

00:33:31.370 --> 00:33:32.210
within a task.

00:33:32.210 --> 00:33:34.610
But it's difficult,
and it's limited.

00:33:34.610 --> 00:33:38.630
And you will never get
as much parallelism

00:33:38.630 --> 00:33:42.515
as if you are using
multi-module projects.

00:33:45.170 --> 00:33:47.570
Now, let's say you've
been very good,

00:33:47.570 --> 00:33:49.880
you've followed all
of James' steps,

00:33:49.880 --> 00:33:52.370
you've tried to
understand what is wrong,

00:33:52.370 --> 00:33:53.930
it's still slow, right?

00:33:53.930 --> 00:33:56.540
So what is the next step
for you to understand?

00:33:56.540 --> 00:34:02.030
What can you do to figure
out, why is my build slow?

00:34:02.030 --> 00:34:05.390
Now, one thing to realize
is that slow builds are not

00:34:05.390 --> 00:34:06.300
normal.

00:34:06.300 --> 00:34:09.290
This is not a reality in
which you should be living.

00:34:09.290 --> 00:34:10.719
Let me be very clear--

00:34:10.719 --> 00:34:15.500
a full build that takes
10 minutes is not normal.

00:34:15.500 --> 00:34:18.739
An incremental build that takes
almost the same amount of time

00:34:18.739 --> 00:34:21.860
as a full build is
even less normal.

00:34:21.860 --> 00:34:24.830
And finally, when you
change nothing and you run

00:34:24.830 --> 00:34:28.180
the build again, and it seems
to rerun a number of tasks

00:34:28.180 --> 00:34:30.920
but you don't know why
because you changed nothing,

00:34:30.920 --> 00:34:33.120
this is clearly not normal.

00:34:33.120 --> 00:34:34.520
So there are
scenarios like these

00:34:34.520 --> 00:34:37.430
that you should be looking
into, and figuring out,

00:34:37.430 --> 00:34:38.929
do I really have
to go through this?

00:34:38.929 --> 00:34:40.429
Maybe there are
some stuff I can do

00:34:40.429 --> 00:34:41.780
to make things better for me.

00:34:41.780 --> 00:34:45.080
And we all know that
the build is a tax.

00:34:45.080 --> 00:34:47.540
Nobody likes to pay taxes.

00:34:47.540 --> 00:34:50.510
So understanding the build is
like paying taxes on taxes,

00:34:50.510 --> 00:34:51.449
I understand that.

00:34:51.449 --> 00:34:53.750
But you must understand
at some level

00:34:53.750 --> 00:34:55.969
that you need to spend
some time into it,

00:34:55.969 --> 00:35:01.340
to invest into understanding,
where is my build being spent?

00:35:01.340 --> 00:35:03.380
Which task is taking time?

00:35:03.380 --> 00:35:07.580
So that you can eventually
have a chance to improve it.

00:35:07.580 --> 00:35:09.720
But what can go wrong?

00:35:09.720 --> 00:35:12.199
Like we talked earlier,
third party plugins,

00:35:12.199 --> 00:35:14.240
you have to be very careful
about the third party

00:35:14.240 --> 00:35:14.960
plugins you're using.

00:35:14.960 --> 00:35:17.060
Some of them are very
well-written, some of them

00:35:17.060 --> 00:35:18.810
not so well.

00:35:18.810 --> 00:35:20.180
Incorrect code organization.

00:35:20.180 --> 00:35:21.830
That's particularly
true, for instance,

00:35:21.830 --> 00:35:24.830
when you were coming from the
Eclipse side of things a few

00:35:24.830 --> 00:35:27.200
years back where all the
source files were in the source

00:35:27.200 --> 00:35:30.080
directory, like
AIDL, C++, and Java.

00:35:30.080 --> 00:35:31.820
They were all in
the same folder.

00:35:31.820 --> 00:35:37.850
So if you change one, it would
trigger all the tasks to rerun.

00:35:37.850 --> 00:35:40.400
Some people like to build,
to customize all of their

00:35:40.400 --> 00:35:41.160
build system.

00:35:41.160 --> 00:35:44.109
And sometimes it goes
really, really wild.

00:35:44.109 --> 00:35:45.650
And finally, some
incorrect settings.

00:35:45.650 --> 00:35:47.210
But you need to
understand and spend

00:35:47.210 --> 00:35:49.430
some time in the build system.

00:35:49.430 --> 00:35:52.540
And I know this is not
something that you like to do.

00:35:52.540 --> 00:35:54.180
You're app developers.

00:35:54.180 --> 00:35:58.440
But as your project is growing,
you must spend some time.

00:35:58.440 --> 00:36:00.680
Now, there are tools
to help you so that you

00:36:00.680 --> 00:36:02.220
spend a minimum amount of time.

00:36:02.220 --> 00:36:05.210
But before we get into
this, I forgot that slide.

00:36:05.210 --> 00:36:09.050
One of the thing we repeatedly
see over and over again

00:36:09.050 --> 00:36:12.890
with people who complain about
their slow build is the doLast.

00:36:12.890 --> 00:36:14.790
doLast is bad.

00:36:14.790 --> 00:36:18.886
Gradle cannot understand if your
task is now incremental or not,

00:36:18.886 --> 00:36:21.010
because it doesn't know
what you're doing in there.

00:36:21.010 --> 00:36:24.080
doLast is bad because most of
the time, up to date checks

00:36:24.080 --> 00:36:26.780
will also fail because you're
probably writing something

00:36:26.780 --> 00:36:28.970
somewhere, and it's in
the output directory

00:36:28.970 --> 00:36:31.160
of the particular task, or
you're changing something

00:36:31.160 --> 00:36:32.450
after the task run.

00:36:32.450 --> 00:36:35.430
And so basically,
again, Gradle is lost.

00:36:35.430 --> 00:36:37.220
So it will rerun
your task every time.

00:36:37.220 --> 00:36:39.950
Avoid this type of things.

00:36:39.950 --> 00:36:43.430
And one way that you can do that
is by writing your own plugin.

00:36:43.430 --> 00:36:47.480
I know it sounds scary, but
believe me, it's not that bad.

00:36:47.480 --> 00:36:49.040
You can write your own plugin.

00:36:49.040 --> 00:36:51.304
You can put it in the
buildSrc directory, which

00:36:51.304 --> 00:36:53.470
mean that it will be available
to all of your module

00:36:53.470 --> 00:36:54.590
automatically.

00:36:54.590 --> 00:36:55.790
Remember to profile it.

00:36:55.790 --> 00:36:59.300
I profile my code everyday,
and I'm always surprised.

00:36:59.300 --> 00:37:03.350
And instead of using doLast,
try to write a custom task

00:37:03.350 --> 00:37:06.500
with proper inputs and outputs
so that Gradle can cache it,

00:37:06.500 --> 00:37:11.050
Gradle can understand what
would make that task up to date

00:37:11.050 --> 00:37:11.550
or not.

00:37:14.410 --> 00:37:17.140
Now, you still don't get it.

00:37:17.140 --> 00:37:20.890
I mean, it's still slow, and
you've been spending time

00:37:20.890 --> 00:37:22.180
on this, and it's still slow.

00:37:22.180 --> 00:37:23.770
So what can you do?

00:37:23.770 --> 00:37:26.705
Next thing to do,
run with a dry-run.

00:37:26.705 --> 00:37:28.330
This will tell you
how much time you're

00:37:28.330 --> 00:37:29.920
spending in the configuration.

00:37:29.920 --> 00:37:33.700
This should be a couple of
seconds, 10 seconds at best,

00:37:33.700 --> 00:37:36.994
at maximum if you really
have a huge project.

00:37:36.994 --> 00:37:38.910
If you start spending
way too much time there,

00:37:38.910 --> 00:37:39.909
there's something wrong.

00:37:39.909 --> 00:37:42.164
Some plugin somewhere is
doing something wrong,

00:37:42.164 --> 00:37:43.705
and we need to
understand what it is.

00:37:43.705 --> 00:37:46.360
[INAUDIBLE] that ways.

00:37:46.360 --> 00:37:49.030
Then you should do a --info.

00:37:49.030 --> 00:37:50.380
--info and is very useful.

00:37:50.380 --> 00:37:55.780
It will tell you what
tasks are running, and why.

00:37:55.780 --> 00:38:00.550
Again, you change none of your
source code, you rerun a build,

00:38:00.550 --> 00:38:02.560
some tasks are
running and you know

00:38:02.560 --> 00:38:06.700
why, the --info will tell
you exactly why this process

00:38:06.700 --> 00:38:09.250
manifest task is running.

00:38:09.250 --> 00:38:12.460
That's because the main
manifestation has changed.

00:38:12.460 --> 00:38:14.819
Then you have to do some
detective work to figure out

00:38:14.819 --> 00:38:17.110
who changed it-- because
obviously you didn't change it

00:38:17.110 --> 00:38:21.520
yourself, but at least
it gives you a hint.

00:38:21.520 --> 00:38:24.940
Next one is the profile, a
slightly more complicated tool

00:38:24.940 --> 00:38:28.210
that will give you the ability
to look at all your tasks

00:38:28.210 --> 00:38:30.400
and see how much time you
spent in each of them.

00:38:30.400 --> 00:38:31.550
This is very high level.

00:38:31.550 --> 00:38:33.549
This is very useful to
figure out that maybe one

00:38:33.549 --> 00:38:34.636
task is dominating.

00:38:34.636 --> 00:38:36.010
Most of the time
we've seen this,

00:38:36.010 --> 00:38:39.370
one task takes 90% of
the time of your build.

00:38:39.370 --> 00:38:45.330
Find out what it is, what is
it doing before you report.

00:38:45.330 --> 00:38:48.630
And then, for the hardcore,
there is another profiler.

00:38:48.630 --> 00:38:52.020
It's a tool which is provided
by Gradle, and it's great.

00:38:52.020 --> 00:38:55.070
It gives you the ability to
profile and to benchmark.

00:38:55.070 --> 00:38:57.120
The profile is the
most interesting one.

00:38:57.120 --> 00:39:01.110
You can actually generate a
profiler information right

00:39:01.110 --> 00:39:05.670
from there, which you can
use to file bug against us.

00:39:05.670 --> 00:39:08.460
So if you think that you've
done all your homework,

00:39:08.460 --> 00:39:12.510
your build is still slow, you
don't get it, run the profiler.

00:39:12.510 --> 00:39:15.150
Give us your yourkit
profile information,

00:39:15.150 --> 00:39:16.980
file a bug against
us, and then we'll

00:39:16.980 --> 00:39:20.250
start looking into why
is your build slow?

00:39:20.250 --> 00:39:23.940
Much better than just filing a
bug saying, my build is slow,

00:39:23.940 --> 00:39:25.380
I don't know why--

00:39:25.380 --> 00:39:29.010
not giving a build.Gradle,
not giving us any information.

00:39:29.010 --> 00:39:30.990
This is not stuff
we can act upon.

00:39:30.990 --> 00:39:35.840
With this, we can look into
why your build is slow.

00:39:35.840 --> 00:39:37.850
Some resources.

00:39:37.850 --> 00:39:40.970
This is what we've seen today,
Santa Tracker Project Fork.

00:39:40.970 --> 00:39:44.210
Look at the Migration
Guide to Android Studio,

00:39:44.210 --> 00:39:47.300
optimize your build speed,
look into the Gradle.

00:39:47.300 --> 00:39:49.290
It's always like when
you receive a new JDK,

00:39:49.290 --> 00:39:51.250
you look at the newest
things in the JDK,

00:39:51.250 --> 00:39:52.430
when there is a new
Gradle, you should

00:39:52.430 --> 00:39:54.260
look into what is the
new things in there.

00:39:54.260 --> 00:39:57.320
There's always a bunch of useful
utilities that you can use.

00:39:57.320 --> 00:39:58.340
Thank you very much.

00:39:58.340 --> 00:39:59.540
[APPLAUSE]

00:40:00.440 --> 00:40:05.290
[MUSIC PLAYING]

