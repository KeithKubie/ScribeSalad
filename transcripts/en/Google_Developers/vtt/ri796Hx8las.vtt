WEBVTT
Kind: captions
Language: en

00:00:00.667 --> 00:00:01.801
Lee: Hi, I'm Jacob Lee.

00:00:01.801 --> 00:00:05.534
I'm with the Google Code Open
Source Project hosting team,

00:00:05.534 --> 00:00:07.501
and I'm going to be talking

00:00:07.501 --> 00:00:10.334
about the Mercurial distributed
version control system

00:00:10.334 --> 00:00:15.434
and how we got it to run
on Google infrastructure.

00:00:15.434 --> 00:00:17.467
A point of administravia,

00:00:17.467 --> 00:00:20.767
this is sort of a--we are
officially launching this

00:00:20.767 --> 00:00:22.334
to the public today.

00:00:22.334 --> 00:00:23.667
Actually,
as of several hours ago,

00:00:23.667 --> 00:00:25.000
so you can go create projects,

00:00:25.000 --> 00:00:27.234
but after my talk.

00:00:27.234 --> 00:00:31.901
And if you're tempted
to vanish, say, during Q&amp;A,

00:00:31.901 --> 00:00:34.534
I would at least lurk
in the back until the end,

00:00:34.534 --> 00:00:35.901
because we have T-shirts.

00:00:35.901 --> 00:00:40.667
So if you want one,
I'd stick around.

00:00:40.667 --> 00:00:42.000
That's a great sound.

00:00:42.000 --> 00:00:46.133
All right, so I'm going
to first talk a little bit

00:00:46.133 --> 00:00:48.167
about project hosting,
and then a lot

00:00:48.167 --> 00:00:51.634
about how Mercurial
is implemented,

00:00:51.634 --> 00:00:54.300
and then about
our implementation.

00:00:54.300 --> 00:00:58.601
So let's first time warp
way back to the distant past

00:00:58.601 --> 00:01:02.968
where we still maintained source
code in giant card catalogs.

00:01:02.968 --> 00:01:08.567
This is July 2006
at OSCON,

00:01:08.567 --> 00:01:12.200
three years ago
when we first announced

00:01:12.200 --> 00:01:14.567
Google code project hosting
to the public.

00:01:14.567 --> 00:01:21.300
At that time, Subversion 1.0
was about two years old.

00:01:21.300 --> 00:01:24.334
One of the earliest distributed
version control systems,

00:01:24.334 --> 00:01:27.067
Monotone,
was a year older than that.

00:01:27.067 --> 00:01:31.067
Git and Mercurial were,
more or less, sort of brand-new.

00:01:31.067 --> 00:01:36.267
CVS was widely used, and I guess
now we're dating ourselves well,

00:01:36.267 --> 00:01:39.067
and maybe several months
before that, back in February,

00:01:39.067 --> 00:01:41.701
Sourceforge had just announced
Subversion support

00:01:41.701 --> 00:01:45.434
to add to its offering
of CVS.

00:01:45.434 --> 00:01:47.834
And we came
into that environment

00:01:47.834 --> 00:01:52.667
with the goal of using
our unique assets,

00:01:52.667 --> 00:01:55.167
which is Google infrastructure,

00:01:55.167 --> 00:02:00.467
to provide rock-solid
and scalable Subversion hosting,

00:02:00.467 --> 00:02:03.834
and thereby provide a platform
for collaboration

00:02:03.834 --> 00:02:05.901
on open source projects.

00:02:05.901 --> 00:02:12.133
And nowadays, well, there's
lots of options out there

00:02:12.133 --> 00:02:15.434
for new and existing
open source projects.

00:02:15.434 --> 00:02:21.601
Google Code now has 200,000
or so, give or take, projects

00:02:21.601 --> 00:02:23.701
and several million
unique visitors per day.

00:02:23.701 --> 00:02:26.100
Sourceforge has expanded
their offerings.

00:02:26.100 --> 00:02:27.801
They have shell accounts

00:02:27.801 --> 00:02:30.234
and several distributed version
control systems

00:02:30.234 --> 00:02:32.400
and, you know,
hosted Trac instances

00:02:32.400 --> 00:02:33.801
and cool things like that.

00:02:33.801 --> 00:02:37.000
And there are new players
like GitHub and Bitbucket,

00:02:37.000 --> 00:02:38.367
which are specialized

00:02:38.367 --> 00:02:39.868
for a particular
version control system

00:02:39.868 --> 00:02:42.501
and provide a well-integrated
social experience

00:02:42.501 --> 00:02:45.567
on top of that,
and that's all really great.

00:02:45.567 --> 00:02:48.968
And we're happy
that there are so many choices

00:02:48.968 --> 00:02:50.400
for projects out there.

00:02:50.400 --> 00:02:53.801
But we still think
that Google is well-positioned

00:02:53.801 --> 00:03:00.634
to support and support well
these newly prominent features

00:03:00.634 --> 00:03:02.501
of distributed version control.

00:03:02.501 --> 00:03:07.167
So with that, about a month
ago, we started offering

00:03:07.167 --> 00:03:11.334
Mercurial support to about
50 or so trusted testers--

00:03:11.334 --> 00:03:16.334
brave volunteers--and now
it is open to the public.

00:03:16.334 --> 00:03:18.467
That's just
a quick screenshot.

00:03:18.467 --> 00:03:20.767
So why did we choose Mercurial?

00:03:20.767 --> 00:03:24.534
This was the source
of many great discussions.

00:03:24.534 --> 00:03:26.701
It was sort of entertaining

00:03:26.701 --> 00:03:29.000
if you like angry people.

00:03:29.000 --> 00:03:34.801
So, you know, why would we
choose Mercurial and not Git

00:03:34.801 --> 00:03:37.601
or Bazaar
or many of the other systems

00:03:37.601 --> 00:03:40.434
shown on the previous slides?

00:03:40.434 --> 00:03:42.400
Any individual might have
personal reasons

00:03:42.400 --> 00:03:44.100
to like one or the other.

00:03:44.100 --> 00:03:45.868
If you were
to grossly over-generalize,

00:03:45.868 --> 00:03:49.100
you might like Mercurial's
simple, orthogonal workflow.

00:03:49.100 --> 00:03:53.300
You might like Git's ability
to do almost anything.

00:03:53.300 --> 00:03:57.801
Our decision was primarily
technical and sort of unique

00:03:57.801 --> 00:03:59.167
to our situation.

00:03:59.167 --> 00:04:03.434
Mercurial has a really fantastic
wire protocol

00:04:03.434 --> 00:04:06.167
that is over HTTP.

00:04:06.167 --> 00:04:09.100
And that
is what Google is built on.

00:04:09.100 --> 00:04:11.167
Almost everything we do is HTTP

00:04:11.167 --> 00:04:12.868
with a handful
of exceptions,

00:04:12.868 --> 00:04:15.868
like Google Talk,
which is Jabber/XMPP.

00:04:15.868 --> 00:04:21.834
And that's something that was
sort of unique to Mercurial

00:04:21.834 --> 00:04:26.534
that makes it a very good fit
for our infrastructure.

00:04:26.534 --> 00:04:30.300
That is the only stupid keynote
transition I am going to use

00:04:30.300 --> 00:04:31.901
in this whole presentation,
but I had to,

00:04:31.901 --> 00:04:33.334
'cause it's a flamewar.

00:04:33.334 --> 00:04:35.801
And it's the point
where people were starting

00:04:35.801 --> 00:04:38.067
to evade our +1 filters

00:04:38.067 --> 00:04:40.767
that we decided to make
that issue read-only.

00:04:40.767 --> 00:04:42.200
Right.
Okay.

00:04:42.200 --> 00:04:46.701
So if you're not familiar
with--well, first of all,

00:04:46.701 --> 00:04:50.501
how many people here use on,
say, a day-to-day

00:04:50.501 --> 00:04:53.801
or at least weekly basis,
version control?

00:04:53.801 --> 00:04:55.701
That's good.
That's really good.

00:04:55.701 --> 00:04:59.334
If your hand didn't go up,
you should consider.

00:04:59.334 --> 00:05:03.067
It is an investment that pays
itself in spades in time.

00:05:03.067 --> 00:05:07.701
So how many people
use distributed version control?

00:05:07.701 --> 00:05:08.934
Nice. Nice.

00:05:08.934 --> 00:05:11.934
All right, how many people
use Mercurial?

00:05:11.934 --> 00:05:16.300
Pretty good.
Git?

00:05:16.300 --> 00:05:18.968
All right. Fight?
All right. Okay.

00:05:18.968 --> 00:05:21.167
I stole that joke
from Fitz and Ben, thanks.

00:05:21.167 --> 00:05:22.467
All right?

00:05:22.467 --> 00:05:25.167
So if you're not familiar,
the basic workflow

00:05:25.167 --> 00:05:28.100
is you've got your, instead of
being on some server somewhere,

00:05:28.100 --> 00:05:30.367
you just have your repository
sitting on disk.

00:05:30.367 --> 00:05:33.601
You initialize it,
you hack a bunch,

00:05:33.601 --> 00:05:37.200
and then, when you feel you have
a coherent change that--

00:05:37.200 --> 00:05:39.734
say, like a single patch
that you would mail out--

00:05:39.734 --> 00:05:40.868
then you just commit that,

00:05:40.868 --> 00:05:42.434
hack some more,
and commit that.

00:05:42.434 --> 00:05:43.601
And you keep doing that,

00:05:43.601 --> 00:05:47.601
and you build up your list
of changes.

00:05:47.601 --> 00:05:50.467
And when you feel that
you have something to share--

00:05:50.467 --> 00:05:53.367
which, hopefully, if you
attended Ben and Fitz's talk,

00:05:53.367 --> 00:05:55.400
is relatively early--

00:05:55.400 --> 00:05:59.100
then you push it out
to some public URL.

00:05:59.100 --> 00:06:02.067
And then some other random
person can come and clone it,

00:06:02.067 --> 00:06:04.467
and they get a copy
of your repository

00:06:04.467 --> 00:06:06.567
with complete history
locally on their disk.

00:06:06.567 --> 00:06:09.467
And they hack a bunch, and
they can do their own commits.

00:06:09.467 --> 00:06:11.767
And they have something
to share back to you,

00:06:11.767 --> 00:06:14.133
they push to their server.

00:06:14.133 --> 00:06:16.934
And their changes
are in red there.

00:06:16.934 --> 00:06:19.367
And then, meanwhile,
you've done some more hacking,

00:06:19.367 --> 00:06:20.801
and then at some point,
you decide,

00:06:20.801 --> 00:06:23.501
"Oh, hey, so-and-so just
emailed me with a cool feature.

00:06:23.501 --> 00:06:25.667
I'll merge it back in."

00:06:25.667 --> 00:06:28.334
So you get it
from their repository,

00:06:28.334 --> 00:06:31.901
and now all of a sudden,
you have--at the front

00:06:31.901 --> 00:06:34.000
of your repository,
you have a change

00:06:34.000 --> 00:06:35.601
and they have a change.

00:06:35.601 --> 00:06:37.234
And then you merge them in,

00:06:37.234 --> 00:06:39.534
and hopefully
there are no conflicts,

00:06:39.534 --> 00:06:44.701
and then you have the tip
of your repository,

00:06:44.701 --> 00:06:46.734
the single front point
of history.

00:06:46.734 --> 00:06:51.968
And merging is something
that is really scary,

00:06:51.968 --> 00:06:54.501
historically at least.

00:06:54.501 --> 00:06:59.000
You just don't know
what crazy state

00:06:59.000 --> 00:07:01.868
the code will be in
when you are done.

00:07:01.868 --> 00:07:04.767
That used to be the case,
and one advantage

00:07:04.767 --> 00:07:07.901
of distributed version control
is that this is something

00:07:07.901 --> 00:07:09.133
that happens all the time--

00:07:09.133 --> 00:07:10.901
pretty much anytime
you integrate a change

00:07:10.901 --> 00:07:13.567
that someone else did
simultaneously with you--

00:07:13.567 --> 00:07:17.601
and it's relatively
pain-free, so...

00:07:17.601 --> 00:07:20.400
The other advantages
is everyone--

00:07:20.400 --> 00:07:22.801
this person who submitted
the change doesn't have to be

00:07:22.801 --> 00:07:24.934
a core contributor
to be able to use

00:07:24.934 --> 00:07:26.501
the same tools that I do,

00:07:26.501 --> 00:07:28.601
and have their own...

00:07:28.601 --> 00:07:30.801
to keep track of history
and so forth.

00:07:30.801 --> 00:07:32.534
And you can do this--

00:07:32.534 --> 00:07:35.000
So these two repositories
can be totally equal,

00:07:35.000 --> 00:07:37.267
or your social structure
might be set up

00:07:37.267 --> 00:07:39.300
so that one repository's
considered central.

00:07:39.300 --> 00:07:41.267
You might have several
central repositories,

00:07:41.267 --> 00:07:43.334
some more bleeding edge
than others.

00:07:43.334 --> 00:07:47.167
But you're not constrained
by technical limitations

00:07:47.167 --> 00:07:51.334
for how you choose to structure
your repositories.

00:07:51.334 --> 00:07:52.767
And if you've tried
to do things

00:07:52.767 --> 00:07:55.067
like sync from one repository
to another in Subversion,

00:07:55.067 --> 00:07:56.267
it's sort of a pain.

00:07:56.267 --> 00:07:59.400
So this solves
that problem well too.

00:07:59.400 --> 00:08:02.234
So moving on to:
How does Mercurial

00:08:02.234 --> 00:08:03.734
actually implement this?

00:08:03.734 --> 00:08:07.968
So the first thing to note
is that this repository here

00:08:07.968 --> 00:08:11.100
is not a linear list
of changes.

00:08:11.100 --> 00:08:12.601
It's a graph.

00:08:12.601 --> 00:08:16.133
Specifically it's a directed--
a cyclic graph.

00:08:16.133 --> 00:08:18.934
You don't--
I mean, internally, Mercurial--

00:08:18.934 --> 00:08:20.634
Well, Mercurial
might present to you

00:08:20.634 --> 00:08:23.667
a numbered list of changes,
but those numbers

00:08:23.667 --> 00:08:25.667
are totally specific
to your repository.

00:08:25.667 --> 00:08:28.000
Someone who integrated their
changes in a different order

00:08:28.000 --> 00:08:29.767
might have different numbers.

00:08:29.767 --> 00:08:32.534
So when we were actually talking
to other people,

00:08:32.534 --> 00:08:35.968
we identified changes
by a unique identifier

00:08:35.968 --> 00:08:40.133
that happens to be
the hash of some states

00:08:40.133 --> 00:08:41.968
of the repository.

00:08:41.968 --> 00:08:44.434
So we've got this graph here.

00:08:44.434 --> 00:08:48.634
Each node in the graph
is a changeset, a single patch.

00:08:48.634 --> 00:08:51.868
And the edges in the graph
are ancestry relationships.

00:08:51.868 --> 00:08:56.067
We identify a changeset
by the hash of its contents.

00:08:56.067 --> 00:08:57.834
And the contents are enough

00:08:57.834 --> 00:09:00.767
to uniquely identify
the changeset.

00:09:00.767 --> 00:09:03.567
It is, you know, the log
message, the user, the date,

00:09:03.567 --> 00:09:07.501
a pointer to the manifest,
which has the list of files,

00:09:07.501 --> 00:09:12.234
and the parents
of the change

00:09:12.234 --> 00:09:14.968
if it is not the first one
in your repository.

00:09:14.968 --> 00:09:17.434
So that's kind of the key point,
because that means

00:09:17.434 --> 00:09:19.067
two changes that happen
to touch

00:09:19.067 --> 00:09:21.000
the same file
and have the same message,

00:09:21.000 --> 00:09:24.267
they're still identified by--

00:09:24.267 --> 00:09:27.300
they're still unique
because their parents,

00:09:27.300 --> 00:09:29.334
which are different,
are included as part

00:09:29.334 --> 00:09:30.434
of the hash.

00:09:30.434 --> 00:09:33.000
And so that means,
because of all this,

00:09:33.000 --> 00:09:36.267
a single changeset
is entirely immutable.

00:09:36.267 --> 00:09:39.901
And this is a difference
from other systems like Git.

00:09:39.901 --> 00:09:44.667
You can't change the contents
of a changeset without--

00:09:44.667 --> 00:09:47.300
If you--say you
were to compress a bunch

00:09:47.300 --> 00:09:49.434
so it still represented
the same final state

00:09:49.434 --> 00:09:51.000
but had
different ancestry.

00:09:51.000 --> 00:09:53.334
Then it has a different I.D.,

00:09:53.334 --> 00:09:54.934
which means
it's a different changeset,

00:09:54.934 --> 00:09:57.033
because you identify them
by I.D.

00:09:57.033 --> 00:10:01.267
So this means that Mercurial
really is not much a fan

00:10:01.267 --> 00:10:02.601
of rewriting history.

00:10:02.601 --> 00:10:05.067
There are extensions to do it,
but it happens really

00:10:05.067 --> 00:10:10.400
before a repository
has been published, typically.

00:10:10.400 --> 00:10:13.801
All right,
so we actually have--

00:10:13.801 --> 00:10:17.667
The user visible graph
is the graph of changesets,

00:10:17.667 --> 00:10:20.400
but conceptually
there are many others.

00:10:20.400 --> 00:10:24.667
I mentioned earlier
that the manifest is the list

00:10:24.667 --> 00:10:27.234
of files in the changesets.

00:10:27.234 --> 00:10:31.434
That is also versioned in the
same way that changesets are.

00:10:31.434 --> 00:10:35.567
Every time you make a commit,
if the list of files changes,

00:10:35.567 --> 00:10:38.868
that is a new node
in the manifest graph,

00:10:38.868 --> 00:10:41.734
with its parent being
the previous list of files.

00:10:41.734 --> 00:10:46.667
And then each individual file
conceptually has its own graph,

00:10:46.667 --> 00:10:50.567
which, each time
you change the file--

00:10:50.567 --> 00:10:52.567
change the contents
of the file,

00:10:52.567 --> 00:10:56.567
it gets a new node identified
as the hash of its contents.

00:10:56.567 --> 00:10:59.734
And then so you're building up
these graphs here.

00:10:59.734 --> 00:11:02.501
The changesets point down
to the manifests,

00:11:02.501 --> 00:11:06.267
and manifests point down
to the version of the file

00:11:06.267 --> 00:11:08.701
at that particular point.

00:11:08.701 --> 00:11:12.100
And then to be able to do
certain operations efficiently,

00:11:12.100 --> 00:11:14.901
you also have a link
back up.

00:11:14.901 --> 00:11:18.367
Files and manifests have links
back up to the changesets.

00:11:18.367 --> 00:11:21.133
So that's actually--

00:11:21.133 --> 00:11:24.734
It's a very simple model
of history.

00:11:24.734 --> 00:11:27.400
A handful of other concepts
that are good to know:

00:11:27.400 --> 00:11:29.834
The heads of the repository
are simply

00:11:29.834 --> 00:11:36.534
the most recent changesets
that do not have any children.

00:11:36.534 --> 00:11:38.634
Typically, at least
in the public repository,

00:11:38.634 --> 00:11:40.400
there's exactly one head.

00:11:40.400 --> 00:11:41.868
It's a good state
to be in.

00:11:41.868 --> 00:11:43.834
You might
have multiple branches,

00:11:43.834 --> 00:11:49.567
which are just named heads,
and, well, named heads

00:11:49.567 --> 00:11:51.467
coupled with their parents...

00:11:51.467 --> 00:11:53.801
And then you have tags,
which is just a name

00:11:53.801 --> 00:11:58.667
attached to a particular
revision, say, for a release.

00:11:58.667 --> 00:12:00.767
All right.

00:12:00.767 --> 00:12:05.934
So how is this
actually stored on disk?

00:12:05.934 --> 00:12:09.968
Mercurial uses a structure
called a revlog that,

00:12:09.968 --> 00:12:14.767
if you've noticed, these graphs
are fundamentally the same

00:12:14.767 --> 00:12:17.300
whether they're operating
on files, manifests,

00:12:17.300 --> 00:12:19.300
or changesets.

00:12:19.300 --> 00:12:23.133
So they're stored in a format
called a revlog

00:12:23.133 --> 00:12:25.167
that is designed to meet
the requirements

00:12:25.167 --> 00:12:26.801
of what Mercurial has to do,

00:12:26.801 --> 00:12:30.434
which is you have to be able
to append to it,

00:12:30.434 --> 00:12:33.601
because you need to add
new changesets to your history.

00:12:33.601 --> 00:12:34.767
You need to be able

00:12:34.767 --> 00:12:38.434
to access it at random
to be able to, say,

00:12:38.434 --> 00:12:40.434
walk the history
of a particular file,

00:12:40.434 --> 00:12:43.334
or to look up a
file-particular revision.

00:12:43.334 --> 00:12:46.434
And it has to be fast,
and it has to be compact.

00:12:46.434 --> 00:12:50.133
So there are two components
to this file.

00:12:50.133 --> 00:12:53.901
You have--Well, first of all,
there is one revlog

00:12:53.901 --> 00:12:55.334
for each conceptual graph.

00:12:55.334 --> 00:12:58.634
There's one for changelogs,
one for manifests,

00:12:58.634 --> 00:13:02.634
and one per file tracked
in the repository.

00:13:02.634 --> 00:13:04.267
It's divided
into two components.

00:13:04.267 --> 00:13:07.033
You have an index
and a data file.

00:13:07.033 --> 00:13:09.901
And to add a new node
to one of these graphs,

00:13:09.901 --> 00:13:12.334
you simply add a new BLOB
of data

00:13:12.334 --> 00:13:14.734
to the end of the data file

00:13:14.734 --> 00:13:17.667
and add a new record
to the index.

00:13:17.667 --> 00:13:20.834
The index is just a list
affixed with records

00:13:20.834 --> 00:13:27.234
that tells you, for a particular
changeset number or file number,

00:13:27.234 --> 00:13:29.968
what is its identifier,
what are its parents,

00:13:29.968 --> 00:13:33.868
and importantly where is
it located in the data file.

00:13:33.868 --> 00:13:36.567
So the index tends
to be very compact,

00:13:36.567 --> 00:13:39.667
such that you can--
when you hit it a bunch,

00:13:39.667 --> 00:13:41.634
it tends to stick around
in memory,

00:13:41.634 --> 00:13:43.567
and it's only 64 bytes
per node.

00:13:43.567 --> 00:13:47.400
It doesn't take up
very much space in memory.

00:13:47.400 --> 00:13:51.701
And so the data file--
I sort of said

00:13:51.701 --> 00:13:54.634
that you just keep appending
to the end of it,

00:13:54.634 --> 00:13:57.167
which is true,
but if you're doing that

00:13:57.167 --> 00:14:01.968
for, say, a megabyte--a file
that's a megabyte in size,

00:14:01.968 --> 00:14:05.334
each time you changed it,
that would grow quickly.

00:14:05.334 --> 00:14:08.534
So you actually just store
deltas in this file.

00:14:08.534 --> 00:14:10.367
You keep appending
to a list of deltas,

00:14:10.367 --> 00:14:13.133
which would have
its own problem,

00:14:13.133 --> 00:14:15.701
and that's--to reconstruct
the actual file,

00:14:15.701 --> 00:14:19.167
you would have to walk
several revisions,

00:14:19.167 --> 00:14:23.000
and so the way Mercurial
strikes a compromise here

00:14:23.000 --> 00:14:27.167
is that simply once the size
of the accumulated deltas

00:14:27.167 --> 00:14:29.167
exceeds the actual size
of the file,

00:14:29.167 --> 00:14:31.334
it records a new snapshot.

00:14:31.334 --> 00:14:35.234
So typically, it doesn't have
to read very many entries

00:14:35.234 --> 00:14:39.434
in this revlog to reconstruct
a particular version

00:14:39.434 --> 00:14:41.167
of a particular node.

00:14:41.167 --> 00:14:46.234
All right.
And so...

00:14:46.234 --> 00:14:49.434
I just talked about all of that.
Great.

00:14:49.434 --> 00:14:51.734
Writing to the repository
is as I described,

00:14:51.734 --> 00:14:54.968
and the only thing is you do
need to lock the repository

00:14:54.968 --> 00:14:57.667
when you're doing this,
so that you don't present

00:14:57.667 --> 00:15:02.467
an inconsistent state
to any other instance

00:15:02.467 --> 00:15:06.000
of the hg command
that happens to be running.

00:15:06.000 --> 00:15:07.634
All right, so when you--

00:15:07.634 --> 00:15:09.634
to, say, make a new commit
to the repository,

00:15:09.634 --> 00:15:13.667
we lock it and we compute
the list of modified files,

00:15:13.667 --> 00:15:15.400
which--it has to be locked
during that--

00:15:15.400 --> 00:15:17.133
and we show the--
you know,

00:15:17.133 --> 00:15:19.667
we invite the user
to type in a log message,

00:15:19.667 --> 00:15:22.701
and then we write
a new list of files,

00:15:22.701 --> 00:15:25.534
and then the new manifest
and then the new changeset.

00:15:25.534 --> 00:15:28.267
We go in that order
to make rollbacks easier

00:15:28.267 --> 00:15:30.400
in case the user cancels
at some point.

00:15:30.400 --> 00:15:33.734
And so when I say
it's locked,

00:15:33.734 --> 00:15:36.634
I mean--
and then I say

00:15:36.634 --> 00:15:40.033
we ask the user to type in a
description of their changeset.

00:15:40.033 --> 00:15:42.033
It's very locked.

00:15:42.033 --> 00:15:44.734
Because that's
an arbitrarily long operation.

00:15:44.734 --> 00:15:46.400
So this is only a write-lock.

00:15:46.400 --> 00:15:47.868
So you can still read
the repository

00:15:47.868 --> 00:15:49.067
while this is going on,

00:15:49.067 --> 00:15:52.868
but it's very much,
you know, one operation

00:15:52.868 --> 00:15:55.133
at a time--
one write operation

00:15:55.133 --> 00:15:56.501
at a time
on this repository.

00:15:56.501 --> 00:15:58.200
So those are all things

00:15:58.200 --> 00:16:00.334
that are just happening on disk,
which is great.

00:16:00.334 --> 00:16:03.434
It's really fast, and you can
do it on an airplane.

00:16:03.434 --> 00:16:05.667
To actually exchange
with other people,

00:16:05.667 --> 00:16:08.868
the network options we have
to do are pushes and pulls.

00:16:08.868 --> 00:16:12.067
That's how we exchange fragments
of our repository

00:16:12.067 --> 00:16:15.267
or, more typically, the whole
thing with other people.

00:16:15.267 --> 00:16:21.534
So to do a push is very easy,
assuming that you are up to date

00:16:21.534 --> 00:16:25.167
with the remote server
that you're trying to push to.

00:16:25.167 --> 00:16:27.167
I'll gloss over the case
where you're not up to date.

00:16:27.167 --> 00:16:29.267
It's like doing a pull,
then a push, sort of.

00:16:29.267 --> 00:16:32.901
So to do a push,
you ask the remote repository,

00:16:32.901 --> 00:16:34.400
"What are your heads?

00:16:34.400 --> 00:16:37.534
What are the most recent
revisions in your repository?"

00:16:37.534 --> 00:16:42.200
And then you find those
in your repository,

00:16:42.200 --> 00:16:45.033
because you have more stuff
than they do, typically.

00:16:45.033 --> 00:16:47.901
And then you say, "Okay,
everything from that point

00:16:47.901 --> 00:16:51.267
forward is typically
what I'm going to send you."

00:16:51.267 --> 00:16:54.200
And then you bundle that up
into a changeset

00:16:54.200 --> 00:16:57.234
and then upload it.

00:16:57.234 --> 00:16:59.167
It's a very straightforward
and fast operation.

00:16:59.167 --> 00:17:01.634
Pull is slightly
more complicated,

00:17:01.634 --> 00:17:05.200
because there's this negotiation
process where you have

00:17:05.200 --> 00:17:11.234
to figure out what the remote
has that you don't have,

00:17:11.234 --> 00:17:13.934
so that you transfer
the minimum amount--

00:17:13.934 --> 00:17:18.000
so the minimum amount necessary
is transferred to you.

00:17:18.000 --> 00:17:22.467
So in this case,
I have the nodes in blue

00:17:22.467 --> 00:17:25.934
and the remote has all
of these new ones in yellow.

00:17:25.934 --> 00:17:28.400
So I ask, "What are your heads,
3, 9, and 13?

00:17:28.400 --> 00:17:30.634
"Oh, I don't have 9 and 13.

00:17:30.634 --> 00:17:34.367
Tell me about, you know,
what is some ancestry of 9?"

00:17:34.367 --> 00:17:37.501
And it says,
"Well, 9 follows a bunch of--

00:17:37.501 --> 00:17:40.167
it goes back until 6,
and 6 has parents 2 and 5."

00:17:40.167 --> 00:17:42.601
I say, "Oh, good, I have 5.
We're getting somewhere."

00:17:42.601 --> 00:17:47.801
And you keep going
with this sort of 20 questions

00:17:47.801 --> 00:17:52.133
of figuring out
what you need to get.

00:17:52.133 --> 00:17:58.534
And your goal here is
to identify nodes 5 and 10.

00:17:58.534 --> 00:18:03.767
Those are the farthest back
nodes that you don't have.

00:18:03.767 --> 00:18:06.767
And then I tell the server,
"Please send me everything

00:18:06.767 --> 00:18:08.133
from 5 and 10 forward."

00:18:08.133 --> 00:18:10.334
And it bundles them up
and sends.

00:18:10.334 --> 00:18:12.467
So there's a lot of--
it's a little chatty

00:18:12.467 --> 00:18:17.868
at the beginning, but that's
only transferring information

00:18:17.868 --> 00:18:19.734
about changesets.

00:18:19.734 --> 00:18:23.868
The actual changeset,
the potentially large operation,

00:18:23.868 --> 00:18:30.367
is getting the actual bundle
of new data.

00:18:30.367 --> 00:18:34.234
But that is a single response
from the server.

00:18:34.234 --> 00:18:38.400
So that is something that's--
this is what I am referring to

00:18:38.400 --> 00:18:42.434
when I say that it is well
designed for our infrastructure,

00:18:42.434 --> 00:18:44.901
as I'll get to.

00:18:44.901 --> 00:18:50.434
All right, so how does
our implementation--

00:18:50.434 --> 00:18:52.734
What did we have to do
to get this running?

00:18:52.734 --> 00:18:56.300
Well, so there's good news
and bad news

00:18:56.300 --> 00:18:59.667
about the way
Mercurial is set up

00:18:59.667 --> 00:19:01.200
and how we're set up.

00:19:01.200 --> 00:19:05.133
The good news is we don't have
to do, like, commits

00:19:05.133 --> 00:19:08.767
and anything that the hg clients
would want to do

00:19:08.767 --> 00:19:10.701
to our repository,
any extensions or something,

00:19:10.701 --> 00:19:13.334
'cause those all happen on
the users' local repositories.

00:19:13.334 --> 00:19:16.267
We only care
about the network operations,

00:19:16.267 --> 00:19:19.200
that is push and pull,
and we care about whatever

00:19:19.200 --> 00:19:21.901
we have to do to support
our Web front-end,

00:19:21.901 --> 00:19:24.033
the source browser.

00:19:24.033 --> 00:19:26.434
Oh, and we have to do
very simple commits

00:19:26.434 --> 00:19:30.601
for the wiki, which--
project wiki is stored

00:19:30.601 --> 00:19:34.267
in a Mercurial repository
as well.

00:19:34.267 --> 00:19:36.133
But other than that,
it's mostly push and pull

00:19:36.133 --> 00:19:37.767
and some querying.

00:19:37.767 --> 00:19:41.067
So it's all...

00:19:41.067 --> 00:19:43.534
It's mostly
just this DAG walking

00:19:43.534 --> 00:19:45.100
that I'll get to.

00:19:45.100 --> 00:19:47.667
But Mercurial makes a lot
of assumptions

00:19:47.667 --> 00:19:51.067
that don't work for us.

00:19:51.067 --> 00:19:55.400
For instance, it can--
a single process is running

00:19:55.400 --> 00:19:57.000
on a single machine.

00:19:57.000 --> 00:19:59.067
It can access the file system
directly.

00:19:59.067 --> 00:20:01.267
The file system--
a single hard drive

00:20:01.267 --> 00:20:04.634
holding the Mercurial
repository--it can lock it.

00:20:04.634 --> 00:20:09.934
It can load all
of the index files that it needs

00:20:09.934 --> 00:20:13.634
into memory and do fast
random access on them.

00:20:13.634 --> 00:20:16.267
Most of these assumptions
don't work for us

00:20:16.267 --> 00:20:21.167
at all at Google,
because we've got sort of--

00:20:21.167 --> 00:20:26.267
well, see, here's a particular
Google cluster, right?

00:20:26.267 --> 00:20:29.234
That's actually
a picture of one

00:20:29.234 --> 00:20:33.100
of the first Google server
environments back at Stanford,

00:20:33.100 --> 00:20:37.100
but we tend to have racks
that look like that.

00:20:37.100 --> 00:20:39.801
We have--our whole
infrastructure is built

00:20:39.801 --> 00:20:42.801
on the assumption
that we have lots and lots

00:20:42.801 --> 00:20:46.100
and lots
of relatively cheap computers.

00:20:46.100 --> 00:20:48.701
I mean, we would--used to say
"commodity computers."

00:20:48.701 --> 00:20:51.267
They're not strictly commodity.

00:20:51.267 --> 00:20:53.601
We're not buying them
from Dell or anything.

00:20:53.601 --> 00:20:58.133
But they're certainly not
the beefiest servers

00:20:58.133 --> 00:21:00.868
that money can buy.

00:21:00.868 --> 00:21:05.434
On top of that, we have our
layers like GFS and BigTable,

00:21:05.434 --> 00:21:08.234
which I'll talk about.

00:21:08.234 --> 00:21:11.901
The whole point of this
is that, when you've got

00:21:11.901 --> 00:21:17.000
the volume that we do,
you're going to have

00:21:17.000 --> 00:21:18.634
lots and lots of computers
anyway,

00:21:18.634 --> 00:21:21.133
and as soon as you have
lots and lots of servers,

00:21:21.133 --> 00:21:23.534
you're going to have failures
all the time.

00:21:23.534 --> 00:21:26.567
And so there's really
no point in over-engineering

00:21:26.567 --> 00:21:28.601
because
you'll still have failures,

00:21:28.601 --> 00:21:30.834
and your software will
still have to handle them,

00:21:30.834 --> 00:21:36.334
so we prefer just giant clusters
and write the software

00:21:36.334 --> 00:21:38.167
as robustly as we can
to operate on them.

00:21:38.167 --> 00:21:42.968
So the first layer for that
is the Google File System, GFS.

00:21:42.968 --> 00:21:48.968
It was built way early on
to serve the needs of Search,

00:21:48.968 --> 00:21:51.434
so the primary need
that it has to be robust

00:21:51.434 --> 00:21:54.400
in the face of random computers
or RACs

00:21:54.400 --> 00:21:56.267
or data centers vanishing.

00:21:56.267 --> 00:22:00.100
It has to hold hundreds
of terabytes,

00:22:00.100 --> 00:22:03.734
and these numbers probably
are all low balls, pro tip.

00:22:03.734 --> 00:22:08.667
And, you know,
multi-gigabyte files...

00:22:08.667 --> 00:22:10.234
The unique workload
of searches,

00:22:10.234 --> 00:22:13.734
you need to be able to stream
these files really fast.

00:22:13.734 --> 00:22:15.334
Like, say you're running
a MapReduce,

00:22:15.334 --> 00:22:16.701
a computation across them.

00:22:16.701 --> 00:22:18.567
So you just need to be able
to stream it really fast,

00:22:18.567 --> 00:22:21.334
and you need to append
to it very fast,

00:22:21.334 --> 00:22:23.634
and you need to be able
to append to it concurrently.

00:22:23.634 --> 00:22:25.968
Say you have lots of workers
all appending to the same thing.

00:22:25.968 --> 00:22:27.801
They need to be able to do that
without stepping

00:22:27.801 --> 00:22:29.367
on each other's toes.

00:22:29.367 --> 00:22:31.334
And maybe you need
to do random access,

00:22:31.334 --> 00:22:33.067
but it's not
your primary workload,

00:22:33.067 --> 00:22:34.367
and it needs to be possible

00:22:34.367 --> 00:22:35.901
but it doesn't need
to be fast.

00:22:35.901 --> 00:22:38.968
So there's a system
called Google File System.

00:22:38.968 --> 00:22:41.667
There is--it's published.
There's a paper about it.

00:22:41.667 --> 00:22:43.167
It's not open source.

00:22:43.167 --> 00:22:45.968
But it's
a single master system,

00:22:45.968 --> 00:22:49.400
just to keep
the implementation sane.

00:22:49.400 --> 00:22:53.300
And then it farms out--
it divides a single file

00:22:53.300 --> 00:22:55.934
into multiple chunks
that are 64 megs each,

00:22:55.934 --> 00:23:00.000
farms those out
to a bunch of servers,

00:23:00.000 --> 00:23:03.534
multiple copies--
it might be three or four copies

00:23:03.534 --> 00:23:07.734
of it on separate machines--

00:23:07.734 --> 00:23:10.534
and then you always
query the master,

00:23:10.534 --> 00:23:12.501
"Hey, where can I find
this file?"

00:23:12.501 --> 00:23:16.467
And it tells you, "Oh, there are
chunks here, here, and here,"

00:23:16.467 --> 00:23:18.901
and then you hit
the actual file servers.

00:23:18.901 --> 00:23:21.634
And those might--if they die,
then you go back

00:23:21.634 --> 00:23:23.234
to the master
and ask it again,

00:23:23.234 --> 00:23:25.267
and eventually it will figure--
it keeps it in sync.

00:23:25.267 --> 00:23:27.701
But so would we just--

00:23:27.701 --> 00:23:30.167
well, that actually sounds
sort of attractive.

00:23:30.167 --> 00:23:34.234
We need fast appends and--

00:23:34.234 --> 00:23:36.868
but so do--will we just
build straight on GFS?

00:23:36.868 --> 00:23:41.334
No, and actually most teams
at Google don't do that

00:23:41.334 --> 00:23:45.100
because, first of all,
GFS doesn't handle replication

00:23:45.100 --> 00:23:47.634
between data centers,
and we like keeping our data

00:23:47.634 --> 00:23:49.033
in more than one data center,

00:23:49.033 --> 00:23:52.300
so if one vanishes
from the face of the Earth,

00:23:52.300 --> 00:23:54.200
we don't have to go
and tell people,

00:23:54.200 --> 00:23:56.200
"Hey, guys, you know
all those repositories

00:23:56.200 --> 00:23:57.734
we were holding on to for you?"

00:23:57.734 --> 00:23:59.067
So that would be embarrassing.

00:23:59.067 --> 00:24:01.701
So we don't want to have
to write that ourselves.

00:24:01.701 --> 00:24:03.000
We need to be on top of GFS.

00:24:03.000 --> 00:24:06.801
And also the performance
characteristics are, you know,

00:24:06.801 --> 00:24:08.968
sort of quirky
and this whole, for instance,

00:24:08.968 --> 00:24:11.167
if you need to fetch
a byte from a file,

00:24:11.167 --> 00:24:13.734
you have to swap it in
in 64 megabyte chunks,

00:24:13.734 --> 00:24:17.000
and that's sort of suboptimal.

00:24:17.000 --> 00:24:18.801
It would not jive very well

00:24:18.801 --> 00:24:23.634
to simply have the revlogs
correspond to GFS files.

00:24:23.634 --> 00:24:25.067
It would have saved us
a lot of coding,

00:24:25.067 --> 00:24:26.400
but it wouldn't have worked.

00:24:26.400 --> 00:24:29.434
So on top of that,
there's BigTable,

00:24:29.434 --> 00:24:32.701
which is the primary database
technology used at Google.

00:24:32.701 --> 00:24:36.267
It's used by lots of teams.

00:24:36.267 --> 00:24:39.100
It is not a relational database.

00:24:39.100 --> 00:24:43.100
It is sort of
a row/column database.

00:24:43.100 --> 00:24:49.267
It is built to meet the diverse
needs of many Google teams.

00:24:49.267 --> 00:24:53.467
So it has--
but the primary example,

00:24:53.467 --> 00:24:55.400
you know,
is in the papers about it--

00:24:55.400 --> 00:24:57.501
tend to deal with Search,
imagine that.

00:24:57.501 --> 00:25:01.100
So your rows
are just arbitrary strings

00:25:01.100 --> 00:25:03.434
that are lexicographically
ordered.

00:25:03.434 --> 00:25:08.534
Those are single-table,
which is ginormous.

00:25:08.534 --> 00:25:10.133
It can be ginormous.

00:25:10.133 --> 00:25:13.701
So it's chunked out
to different servers

00:25:13.701 --> 00:25:19.767
by the row space, so different
sections vertically.

00:25:19.767 --> 00:25:22.367
And then--
or horizontally, yeah.

00:25:22.367 --> 00:25:25.434
The columns
are also arbitrary strings.

00:25:25.434 --> 00:25:27.667
So it's sort of a,
you know, you end up

00:25:27.667 --> 00:25:30.367
with this sparse matrix
where you don't have to have

00:25:30.367 --> 00:25:31.567
alleys for every column.

00:25:31.567 --> 00:25:34.701
And they're grouped
into families

00:25:34.701 --> 00:25:36.667
also for locality
of access.

00:25:36.667 --> 00:25:39.868
And then the values
you actually store, well,

00:25:39.868 --> 00:25:41.601
it might be a single value
per cell.

00:25:41.601 --> 00:25:44.734
It might be a list
of values by timestamp,

00:25:44.734 --> 00:25:47.567
which is a feature
that we are not too reliant on,

00:25:47.567 --> 00:25:49.067
so I'll gloss over it.

00:25:49.067 --> 00:25:53.367
And the actual values
you store are opaque BLOBs.

00:25:53.367 --> 00:25:57.167
There's no sort of, you know,
referential integrity

00:25:57.167 --> 00:25:59.467
or SQL-like thing going on here.

00:25:59.467 --> 00:26:01.200
You're just storing BLOBs
in this,

00:26:01.200 --> 00:26:03.734
and now that it's open source,
we can talk about it.

00:26:03.734 --> 00:26:06.000
So these BLOBs
often are protocol buffers.

00:26:06.000 --> 00:26:07.501
All right.

00:26:07.501 --> 00:26:11.534
The operations that you do,
you look up by a particular row

00:26:11.534 --> 00:26:12.968
and column name.

00:26:12.968 --> 00:26:17.000
You might scan a set of rows,
and you might, of course,

00:26:17.000 --> 00:26:19.200
write to it,
and you have the ability

00:26:19.200 --> 00:26:21.133
to lock a particular row

00:26:21.133 --> 00:26:24.334
to write values into it,
which is important.

00:26:24.334 --> 00:26:25.467
We care about that.

00:26:25.467 --> 00:26:27.467
And this also--
it's not open source,

00:26:27.467 --> 00:26:29.067
but there's a paper
about it,

00:26:29.067 --> 00:26:31.300
and the Hadoop project
from Apache

00:26:31.300 --> 00:26:34.267
I believe has an open source
implementation

00:26:34.267 --> 00:26:36.701
of a BigTable-like system.

00:26:36.701 --> 00:26:42.033
So BigTable is what
we would like to build on.

00:26:42.033 --> 00:26:44.601
It's widely used
inside Google.

00:26:44.601 --> 00:26:47.968
So it turns out
that we've got

00:26:47.968 --> 00:26:49.834
all these things
indexed by hash.

00:26:49.834 --> 00:26:53.868
That is a very good match
for BigTable,

00:26:53.868 --> 00:26:57.767
which we can treat essentially
as a giant hash table

00:26:57.767 --> 00:27:00.667
with some other features.

00:27:00.667 --> 00:27:05.868
So those changesets that we
identify or--sorry, these nodes

00:27:05.868 --> 00:27:09.200
in the graph, which might be
changesets, might be file--

00:27:09.200 --> 00:27:13.968
particular versions of files,
we store those in our row space,

00:27:13.968 --> 00:27:19.167
identified by this hash,
by the repository name,

00:27:19.167 --> 00:27:22.033
and by what kind of node it is.

00:27:22.033 --> 00:27:27.400
The "C" there is for changesets.
The "M" is for manifest.

00:27:27.400 --> 00:27:28.734
"F" is for files.

00:27:28.734 --> 00:27:30.901
And if it's a file,
it's also identified

00:27:30.901 --> 00:27:32.801
by what's its path.

00:27:32.801 --> 00:27:37.133
Because as I mentioned, these
are sorted lexicographically,

00:27:37.133 --> 00:27:38.434
so this has the advantage--

00:27:38.434 --> 00:27:42.167
And they're split
into tablets

00:27:42.167 --> 00:27:48.734
where rows that are close
together are likely to end up

00:27:48.734 --> 00:27:51.434
on the same machine
and can be accessed

00:27:51.434 --> 00:27:53.734
very efficiently together.

00:27:53.734 --> 00:27:56.467
So all the changesets
for a single repository

00:27:56.467 --> 00:27:58.968
end up next to each other
lexicographically.

00:27:58.968 --> 00:28:01.634
Same with the manifests,
same with the different versions

00:28:01.634 --> 00:28:03.033
of each file.

00:28:03.033 --> 00:28:05.334
And then--
so the values that we store

00:28:05.334 --> 00:28:09.300
split up
into these column families here.

00:28:09.300 --> 00:28:12.100
So for files we store
the contents of the file,

00:28:12.100 --> 00:28:13.100
obviously enough.

00:28:13.100 --> 00:28:16.300
We actually fragment them

00:28:16.300 --> 00:28:19.868
because there are row size
limitations in BigTable.

00:28:19.868 --> 00:28:24.534
But we can still retrieve those
linearly by row.

00:28:24.534 --> 00:28:28.534
And then for manifests
we just store the list of files,

00:28:28.534 --> 00:28:32.133
and for changesets, we store
the changed contents,

00:28:32.133 --> 00:28:33.767
the log message, and so forth.

00:28:33.767 --> 00:28:36.067
Just basic data
and metadata.

00:28:36.067 --> 00:28:40.434
And so that's
all just the raw contents

00:28:40.434 --> 00:28:42.968
of the graph that we throw
into Table.

00:28:42.968 --> 00:28:46.634
And so I actually identify
a single repository.

00:28:46.634 --> 00:28:50.667
We have its own row indexed
by our repository name.

00:28:50.667 --> 00:28:55.467
And it has simply
the list of heads

00:28:55.467 --> 00:28:59.634
that refers back to the
changesets stored in the table.

00:28:59.634 --> 00:29:02.067
So that which is enough
to uniquely identify

00:29:02.067 --> 00:29:03.868
the current state
of the repository.

00:29:03.868 --> 00:29:08.634
So for the operations
that we actually want to do,

00:29:08.634 --> 00:29:11.634
and why they are efficient--

00:29:11.634 --> 00:29:13.701
this is--first of all,
to clarify,

00:29:13.701 --> 00:29:15.501
this is--when I say
push and pull here,

00:29:15.501 --> 00:29:18.334
this is all
from the client's perspective.

00:29:18.334 --> 00:29:22.868
So if I'm pushing something
into Google's servers,

00:29:22.868 --> 00:29:26.767
well, all we have to do
when we receive

00:29:26.767 --> 00:29:31.300
this incoming graph data
is just shovel it

00:29:31.300 --> 00:29:33.634
into this row space
we talked about earlier,

00:29:33.634 --> 00:29:36.367
and it's all sort of--
it's garbage.

00:29:36.367 --> 00:29:40.367
It's unlinked.
It's not referenced anywhere.

00:29:40.367 --> 00:29:42.100
So we are free to do that

00:29:42.100 --> 00:29:44.467
without acquiring
any sort of lock,

00:29:44.467 --> 00:29:46.434
because it's not messing up
the current state

00:29:46.434 --> 00:29:48.834
of the repository,
because we haven't changed

00:29:48.834 --> 00:29:49.901
the list of heads.

00:29:49.901 --> 00:29:52.634
So once we are done
with all that,

00:29:52.634 --> 00:29:56.934
we've noted what we think
the current heads are

00:29:56.934 --> 00:29:58.133
in the repository.

00:29:58.133 --> 00:29:59.400
And if that's still the same,

00:29:59.400 --> 00:30:01.834
that means nothing else
has happened to this,

00:30:01.834 --> 00:30:06.968
so we can go ahead
and lock the repository row,

00:30:06.968 --> 00:30:09.667
check to make sure
it hasn't changed,

00:30:09.667 --> 00:30:13.300
and then write the new list
of heads that we computed.

00:30:13.300 --> 00:30:16.167
And then--well,
then we're done.

00:30:16.167 --> 00:30:18.968
The repository instantly
refers to this new data.

00:30:18.968 --> 00:30:20.434
We just add it
to the table.

00:30:20.434 --> 00:30:22.334
And that's all something
that, you know, can be done--

00:30:22.334 --> 00:30:25.701
if you have multiple pushes
going at the same time,

00:30:25.701 --> 00:30:30.400
they pretty much all succeed
and they all happen in parallel.

00:30:30.400 --> 00:30:33.434
One of them will win for
this actual very small write

00:30:33.434 --> 00:30:35.133
at the end
for the repository row.

00:30:35.133 --> 00:30:37.601
And the other one will have
to do a little more computation

00:30:37.601 --> 00:30:39.200
before it can update
that row again.

00:30:39.200 --> 00:30:41.701
But it still gets to succeed.

00:30:41.701 --> 00:30:44.000
Now if the client
is pulling from us,

00:30:44.000 --> 00:30:46.234
we have to answer
that game of 20 questions

00:30:46.234 --> 00:30:48.434
that I described
earlier of the repository--

00:30:48.434 --> 00:30:52.367
of the client asking us,
"Well, what do you have?"

00:30:52.367 --> 00:30:56.734
And so that is mostly

00:30:56.734 --> 00:31:01.634
just tracing back the history
of the repository in this table.

00:31:01.634 --> 00:31:03.534
We look up a changeset.

00:31:03.534 --> 00:31:06.133
We look up its parents,
keep going until we find

00:31:06.133 --> 00:31:07.868
the information
the client wants.

00:31:07.868 --> 00:31:12.667
And once the client has
identified, "Okay, I want you

00:31:12.667 --> 00:31:17.033
to send me everything
from these two changes forward,"

00:31:17.033 --> 00:31:21.667
then we can get
the actual changeset contents

00:31:21.667 --> 00:31:24.334
from the table
and then stream those out

00:31:24.334 --> 00:31:25.901
to the client.

00:31:25.901 --> 00:31:27.901
That is--
so at the beginning,

00:31:27.901 --> 00:31:30.367
there's some graph-blocking,
but to actually read

00:31:30.367 --> 00:31:32.567
the changesets
and build up this bundle,

00:31:32.567 --> 00:31:36.067
that is something that we can
rely on BigTable's parallelism

00:31:36.067 --> 00:31:39.434
to just--we basically can send
them out to the client

00:31:39.434 --> 00:31:40.801
as fast as we can read them.

00:31:40.801 --> 00:31:43.267
And then the last major
operation we have to do

00:31:43.267 --> 00:31:45.067
is for the source browser,

00:31:45.067 --> 00:31:47.434
the graphical front end
that we've written,

00:31:47.434 --> 00:31:50.334
and that is things like
getting the next and previous

00:31:50.334 --> 00:31:51.901
revisions of a file,

00:31:51.901 --> 00:31:53.067
and getting the history--

00:31:53.067 --> 00:31:55.534
or at a particular path,

00:31:55.534 --> 00:31:57.200
getting the next
and previous revisions,

00:31:57.200 --> 00:31:59.467
getting the contents of a file

00:31:59.467 --> 00:32:00.868
at a particular revision,

00:32:00.868 --> 00:32:02.067
that sort of thing.

00:32:02.067 --> 00:32:04.968
That is all just graph walking,
so it's--

00:32:04.968 --> 00:32:09.400
Well, we'll get into
the performance of that.

00:32:09.400 --> 00:32:10.767
There's--also we got--

00:32:10.767 --> 00:32:14.567
Well, there's a lot of
optimizations that we can do

00:32:14.567 --> 00:32:17.834
that are--or really
that BigTable does for us.

00:32:17.834 --> 00:32:19.701
The thing we need to avoid

00:32:19.701 --> 00:32:22.968
is doing a sequential
read or write,

00:32:22.968 --> 00:32:25.033
which is ask BigTable
for something,

00:32:25.033 --> 00:32:26.567
wait for an answer,

00:32:26.567 --> 00:32:28.100
ask it for something else.

00:32:28.100 --> 00:32:30.167
Because Mercurial is sitting
on a local file system.

00:32:30.167 --> 00:32:31.467
It can do that very quickly.

00:32:31.467 --> 00:32:33.701
And it's typically--
it'll all be in memory,

00:32:33.701 --> 00:32:35.901
and for us that is maybe,
I don't know,

00:32:35.901 --> 00:32:38.200
20 millisecond round-trip
each time.

00:32:38.200 --> 00:32:41.534
So our goal is to let BigTable
do the concurrency.

00:32:41.534 --> 00:32:43.367
We throw all of our,
you know--

00:32:43.367 --> 00:32:44.901
If we have writes,

00:32:44.901 --> 00:32:46.801
we the throw them into a pool

00:32:46.801 --> 00:32:48.934
and wait for all of them
to finish,

00:32:48.934 --> 00:32:51.033
and BigTable gets back
to us eventually.

00:32:51.033 --> 00:32:52.601
Same with reads.

00:32:52.601 --> 00:32:55.367
And then we do a little bit
of computation

00:32:55.367 --> 00:32:57.200
to minimize
this graph walking

00:32:57.200 --> 00:33:00.167
for things that we know
the client is going to ask us.

00:33:00.167 --> 00:33:03.834
It's going to ask,
"Hey, for this particular node

00:33:03.834 --> 00:33:05.033
"that I don't have,

00:33:05.033 --> 00:33:07.601
"what is the farthest back node

00:33:07.601 --> 00:33:09.067
before a merge?"

00:33:09.067 --> 00:33:10.601
'Cause that's
a single line of history

00:33:10.601 --> 00:33:12.501
that it's going to want
to investigate further,

00:33:12.501 --> 00:33:14.334
so that's the sort of thing
we can pre-compute,

00:33:14.334 --> 00:33:15.734
because it's all in the past,

00:33:15.734 --> 00:33:17.200
and it's guaranteed
never to change.

00:33:17.200 --> 00:33:20.200
So we can just store it
when we do the writes.

00:33:20.200 --> 00:33:25.467
So the actual results
we get from our implementation,

00:33:25.467 --> 00:33:26.968
pushing--

00:33:26.968 --> 00:33:28.267
When the client
is pushing to us,

00:33:28.267 --> 00:33:31.200
that is ridiculously fast.

00:33:31.200 --> 00:33:34.300
We just accept data
and writes into the table,

00:33:34.300 --> 00:33:36.567
and because there are many,
many machines involved here,

00:33:36.567 --> 00:33:38.667
this can happen way faster

00:33:38.667 --> 00:33:42.467
than an actual
file system writes.

00:33:42.467 --> 00:33:47.634
The pull, that negotiation
process at the beginning,

00:33:47.634 --> 00:33:50.133
is still a certain mound
of synchronous reads

00:33:50.133 --> 00:33:51.534
where we have to wait
for an answer,

00:33:51.534 --> 00:33:54.267
and that's something
that's even--

00:33:54.267 --> 00:33:57.701
We can't do anything about
a lot of those round-trips,

00:33:57.701 --> 00:33:59.534
so even at the best case,

00:33:59.534 --> 00:34:02.601
once we're finished optimizing
our implementation,

00:34:02.601 --> 00:34:05.767
we might still be, say,
twice as slow as Mercurial,

00:34:05.767 --> 00:34:07.534
because of the difference
in architecture.

00:34:07.534 --> 00:34:09.734
And then
for the source browser,

00:34:09.734 --> 00:34:13.067
we're very fast
for certain operations.

00:34:13.067 --> 00:34:15.534
Retrieving a particular
revision of the file--

00:34:15.534 --> 00:34:17.801
that's just a table lookup.

00:34:17.801 --> 00:34:20.634
Retrieving the history
of the file--

00:34:20.634 --> 00:34:21.767
so in Mercurial,

00:34:21.767 --> 00:34:24.968
that is just tracing
a single revlog

00:34:24.968 --> 00:34:27.200
that holds the whole contents
of a file.

00:34:27.200 --> 00:34:29.067
That's slow for us,

00:34:29.067 --> 00:34:31.868
'cause we have to do
a whole bunch of graph walking,

00:34:31.868 --> 00:34:33.567
and that's something
we're working on.

00:34:33.567 --> 00:34:36.534
You'll notice that's slow
on the web front end and we're--

00:34:36.534 --> 00:34:38.400
but we have some stuff

00:34:38.400 --> 00:34:41.701
we can do
to make it faster still.

00:34:41.701 --> 00:34:44.968
But overall, though--

00:34:44.968 --> 00:34:47.334
So those numbers
for a single repository

00:34:47.334 --> 00:34:50.701
also hold true for however much
we want to serve.

00:34:50.701 --> 00:34:54.434
A, you know, single job
running in a data center,

00:34:54.434 --> 00:34:56.767
we can serve hundreds
of queries per second

00:34:56.767 --> 00:34:59.534
on the source browser across
all sorts of repositories.

00:34:59.534 --> 00:35:02.467
And for the pushing
and pulling,

00:35:02.467 --> 00:35:04.534
we can do tens
of megabits per second

00:35:04.534 --> 00:35:05.701
from the single job,

00:35:05.701 --> 00:35:08.734
which is rather fast
for a Python program

00:35:08.734 --> 00:35:10.100
on a single computer.

00:35:10.100 --> 00:35:13.968
So we don't run into things
like lock contention

00:35:13.968 --> 00:35:16.234
as much as you would

00:35:16.234 --> 00:35:18.267
if you had
the stock Mercurial server

00:35:18.267 --> 00:35:19.634
trying to do
that sort of thing.

00:35:19.634 --> 00:35:23.934
So the lessons we can learn
from this is, you know,

00:35:23.934 --> 00:35:27.534
engineering, it's really
about trade-offs,

00:35:27.534 --> 00:35:29.868
and there are things that are--

00:35:29.868 --> 00:35:33.868
The design goals very much
affect the end product.

00:35:33.868 --> 00:35:36.334
Our design goal is that

00:35:36.334 --> 00:35:41.200
if the entire project-hosting
ecosystem--

00:35:41.200 --> 00:35:42.667
Well, if all of Google code

00:35:42.667 --> 00:35:45.367
decided to switch their projects
today to Mercurial,

00:35:45.367 --> 00:35:47.501
we could handle it maybe

00:35:47.501 --> 00:35:49.834
by throwing a couple more
computers at it,

00:35:49.834 --> 00:35:51.901
bring up a couple more jobs,

00:35:51.901 --> 00:35:54.267
and we can
handle the traffic fine.

00:35:54.267 --> 00:35:57.200
But at the same time,

00:35:57.200 --> 00:35:59.534
that, I mean,
involves a lot of--

00:35:59.534 --> 00:36:03.467
When you're sharding things
across computers like that,

00:36:03.467 --> 00:36:05.968
it's always--
there are certain operations

00:36:05.968 --> 00:36:08.601
that you're not
going to be able to do as fast

00:36:08.601 --> 00:36:11.234
as if you just had
a single process

00:36:11.234 --> 00:36:13.167
talking directly to disk.

00:36:13.167 --> 00:36:17.767
So the scalability there
will always have a price.

00:36:17.767 --> 00:36:19.033
So that's something that--

00:36:19.033 --> 00:36:20.634
When you're starting
to design a system,

00:36:20.634 --> 00:36:22.400
these are the things
you need to keep in mind.

00:36:22.400 --> 00:36:27.634
And one more cool thing
that we have...

00:36:27.634 --> 00:36:28.934
I think that's
a Lego clone army.

00:36:28.934 --> 00:36:29.934
I don't know.

00:36:29.934 --> 00:36:33.033
But so you notice that--

00:36:33.033 --> 00:36:36.067
We'll go back to this...

00:36:36.067 --> 00:36:39.567
All of that data
in that top table,

00:36:39.567 --> 00:36:41.834
that's all immutable.

00:36:41.834 --> 00:36:47.133
And one thing that's very common
in a distributed workflow

00:36:47.133 --> 00:36:51.033
is having, you know,
multiple copies of this--

00:36:51.033 --> 00:36:53.400
more or less,
the same repository.

00:36:53.400 --> 00:36:56.501
And that is, for Mercurial,

00:36:56.501 --> 00:37:00.400
that is something that if you
want to clone a local repository

00:37:00.400 --> 00:37:01.467
that's sitting on disk...

00:37:01.467 --> 00:37:03.267
Well, it doesn't do any work.

00:37:03.267 --> 00:37:07.934
It actually hard-links
the new repository to the old,

00:37:07.934 --> 00:37:10.934
and then when you
actually do a write,

00:37:10.934 --> 00:37:14.734
it then goes, "Whoa, this file
has two references to it.

00:37:14.734 --> 00:37:16.000
It's linked somewhere else."

00:37:16.000 --> 00:37:17.567
And then it actually
does the copy then.

00:37:17.567 --> 00:37:19.501
So cloning is wicked fast.

00:37:19.501 --> 00:37:22.100
But you have--
Oh, I should stop doing that.

00:37:22.100 --> 00:37:26.601
But it will slow down
your operations randomly later.

00:37:26.601 --> 00:37:28.734
So it sort of...it works.

00:37:28.734 --> 00:37:30.901
We can do a little bit
better than that,

00:37:30.901 --> 00:37:33.200
because all that--

00:37:33.200 --> 00:37:35.734
If we were to clone a repository
on the service side,

00:37:35.734 --> 00:37:38.868
all that actual revision data
that's stored in that table,

00:37:38.868 --> 00:37:41.200
that's all immutable,

00:37:41.200 --> 00:37:44.801
and whatever happens
for the divergent history

00:37:44.801 --> 00:37:46.834
of these two repositories,

00:37:46.834 --> 00:37:49.067
that data can remain shared.

00:37:49.067 --> 00:37:51.801
So the only thing that uniquely
identifies a repository

00:37:51.801 --> 00:37:53.501
is that list of heads,

00:37:53.501 --> 00:37:55.868
and the list of branches
and things like that,

00:37:55.868 --> 00:37:58.467
and also meant if we have
any sort of references

00:37:58.467 --> 00:38:00.334
pointing forward
that we've pre-computed,

00:38:00.334 --> 00:38:02.000
those are things we have
to watch out for,

00:38:02.000 --> 00:38:04.701
but the bulk of the data
is shared.

00:38:04.701 --> 00:38:08.133
So that's something that we can
certainly do pretty easily

00:38:08.133 --> 00:38:10.601
from a technical perspective.

00:38:10.601 --> 00:38:13.501
Getting the right UI

00:38:13.501 --> 00:38:16.000
and integration with our
existing project hosting

00:38:16.000 --> 00:38:18.434
is something that'll
take more effort,

00:38:18.434 --> 00:38:20.968
but it's something that you can
look forward to

00:38:20.968 --> 00:38:23.300
in the near future
in your projects.

00:38:23.300 --> 00:38:25.000
And we believe that,
you know,

00:38:25.000 --> 00:38:26.868
the distributed workflow,

00:38:26.868 --> 00:38:28.567
I mean,
it's not really just--

00:38:28.567 --> 00:38:30.701
You don't want to be able
to use Mercurial.

00:38:30.701 --> 00:38:32.300
Though you might enjoy
using Mercurial,

00:38:32.300 --> 00:38:34.200
you want to be able
to take advantage

00:38:34.200 --> 00:38:37.467
of the workflow of
distributed version control,

00:38:37.467 --> 00:38:39.367
and that's what we hope
to support.

00:38:39.367 --> 00:38:41.968
Thank you.
Any questions?

00:38:41.968 --> 00:38:44.968
[applause]

00:38:47.868 --> 00:38:48.868
man: I have one.

00:38:48.868 --> 00:38:49.868
Lee: Yeah.

00:38:49.868 --> 00:38:51.267
man: Kind of unrelated,

00:38:51.267 --> 00:38:53.601
but we are always
looking for ways

00:38:53.601 --> 00:38:55.467
to let our, like,
graphic designers

00:38:55.467 --> 00:38:57.534
store big Photoshop files.

00:38:57.534 --> 00:39:00.501
Kind of doesn't work
in Service Control,

00:39:00.501 --> 00:39:03.767
but I've never seen
another solution.

00:39:03.767 --> 00:39:06.400
You know, we want revisioning
in that process.

00:39:06.400 --> 00:39:08.767
But, you know.
Do you have any solutions?

00:39:08.767 --> 00:39:11.934
Lee: Write one
and tell us about it.

00:39:11.934 --> 00:39:15.467
man: No, you're Google.
You should know things.

00:39:15.467 --> 00:39:18.167
Lee: Well, actually, for
projects that are doing this,

00:39:18.167 --> 00:39:21.133
we recommend using
our downloads server,

00:39:21.133 --> 00:39:24.834
which you can at least give,
you know, revision numbers.

00:39:24.834 --> 00:39:26.701
You have to do it yourself,
it's a pain,

00:39:26.701 --> 00:39:27.901
but it's doable,

00:39:27.901 --> 00:39:29.534
and that is relying
on a different,

00:39:29.534 --> 00:39:31.367
totally different
massive storage system.

00:39:31.367 --> 00:39:32.601
man: All right.

00:39:32.601 --> 00:39:35.601
Well, maybe we'll start
an open source project.

00:39:35.601 --> 00:39:37.100
man: Hi.

00:39:37.100 --> 00:39:39.367
You talked about
the changesets

00:39:39.367 --> 00:39:42.000
sort of having
a similar hash value,

00:39:42.000 --> 00:39:44.200
and then that's why
they hash together--

00:39:44.200 --> 00:39:46.434
well, close to each other.

00:39:46.434 --> 00:39:47.701
Is that--

00:39:47.701 --> 00:39:51.334
Lee: Well, say a change
and its parents

00:39:51.334 --> 00:39:53.100
will have totally different
hashes, right?

00:39:53.100 --> 00:39:56.701
Because it tries to be
a reasonably smooth function,

00:39:56.701 --> 00:39:59.534
or reasonably
arbitrary function.

00:39:59.534 --> 00:40:02.701
But they all have
the same prefix

00:40:02.701 --> 00:40:03.801
of the repository name

00:40:03.801 --> 00:40:05.067
and then "C."

00:40:05.067 --> 00:40:07.901
As opposed to, say,
the files that are manifest,

00:40:07.901 --> 00:40:09.434
that are also stored
in the same table.

00:40:09.434 --> 00:40:11.868
To be clear,
that was all one BigTable.

00:40:11.868 --> 00:40:14.267
man: Yeah, so, I mean,

00:40:14.267 --> 00:40:17.767
so my question is more probably
related to BigTable.

00:40:17.767 --> 00:40:21.634
So this sort of the same
prefix hashing

00:40:21.634 --> 00:40:24.434
to similar locations,

00:40:24.434 --> 00:40:27.434
is that something that is
by default in BigTable,

00:40:27.434 --> 00:40:29.000
or did you have to do
something for that?

00:40:29.000 --> 00:40:31.267
Lee:
No, that's how it works.

00:40:31.267 --> 00:40:33.767
Rows are stored
lexicographically

00:40:33.767 --> 00:40:36.834
and then sharded
by their prefix.

00:40:36.834 --> 00:40:39.234
man: So it's a
location-preserving hash table?

00:40:39.234 --> 00:40:40.300
Lee: Sorry?

00:40:40.300 --> 00:40:41.601
man:
Like, I mean, BigTable

00:40:41.601 --> 00:40:44.133
is like a
location-preserving hash...

00:40:44.133 --> 00:40:47.734
I mean, it preserves,
like, I mean, based on--

00:40:47.734 --> 00:40:51.367
Lee: No, no, it'll just--
it'll start on one tab,

00:40:51.367 --> 00:40:52.567
and then when it gets big enough

00:40:52.567 --> 00:40:55.701
it'll split it up
as it deems appropriate.

00:40:55.701 --> 00:40:57.267
man: Thanks.

00:40:57.267 --> 00:40:59.300
Lee: It's not something
we really have to deal with.

00:40:59.300 --> 00:41:02.133
It's BigTable magic.

00:41:02.133 --> 00:41:03.667
man:
I was just wondering

00:41:03.667 --> 00:41:07.000
if you imagine Google eventually
using something like Mercurial

00:41:07.000 --> 00:41:09.234
for its own
internal development,

00:41:09.234 --> 00:41:11.067
and compared to, you know,

00:41:11.067 --> 00:41:12.968
big systems like Perforce
have trade-offs,

00:41:12.968 --> 00:41:15.234
and can you talk a little about
what those trade-offs are,

00:41:15.234 --> 00:41:16.634
and what systems like Perforce

00:41:16.634 --> 00:41:18.133
do better or worse
than Mercurial

00:41:18.133 --> 00:41:19.667
and sort of how
you think that through?

00:41:19.667 --> 00:41:22.133
Lee: Well, we're sort of
unique at Google.

00:41:22.133 --> 00:41:26.734
We have our--
basically one giant repository

00:41:26.734 --> 00:41:29.367
for, like, everything.

00:41:29.367 --> 00:41:31.434
So Perforce scales...

00:41:31.434 --> 00:41:36.367
Well, crack engineers whom I'm--
don't know who they are

00:41:36.367 --> 00:41:38.200
do a good job of scaling it,

00:41:38.200 --> 00:41:40.100
and so I don't know actually

00:41:40.100 --> 00:41:43.734
if there are any developments
on that front.

00:41:43.734 --> 00:41:45.334
man: I've been trying
to evaluate

00:41:45.334 --> 00:41:47.400
the different distributed
version control systems,

00:41:47.400 --> 00:41:49.200
and one of the big things
in my environment

00:41:49.200 --> 00:41:52.133
is being able to import existing
subversion repositories

00:41:52.133 --> 00:41:54.200
into whatever it is,

00:41:54.200 --> 00:41:56.100
and I ran into
quite a few problems

00:41:56.100 --> 00:41:57.534
using Mercurial and such.

00:41:57.534 --> 00:41:59.200
I've been kind of
leaning towards Bazaar,

00:41:59.200 --> 00:42:01.567
and I was just wondering what
was your experience with that,

00:42:01.567 --> 00:42:02.734
and how poorly did it go,

00:42:02.734 --> 00:42:04.200
and that kind of thing?

00:42:04.200 --> 00:42:08.467
Lee: Well, the actual import,
I found, is straightforward.

00:42:08.467 --> 00:42:11.167
Getting all
of the correct bindings

00:42:11.167 --> 00:42:14.000
is a pain in the neck
right now.

00:42:14.000 --> 00:42:17.901
You have to get
the subversion Python bindings,

00:42:17.901 --> 00:42:20.167
because Mercurial is written
all in Python.

00:42:20.167 --> 00:42:22.133
That's kind of
the most annoying one.

00:42:22.133 --> 00:42:24.834
If you have, say,
a recent Ubuntu distribution,

00:42:24.834 --> 00:42:26.834
you might have it
all out of the box.

00:42:26.834 --> 00:42:30.467
Otherwise you have
some compiling from source

00:42:30.467 --> 00:42:32.033
in your future,
and that's loads of fun.

00:42:32.033 --> 00:42:35.267
So that's something--
It would probably be, I mean,

00:42:35.267 --> 00:42:37.634
GitHub I know actually has

00:42:37.634 --> 00:42:39.801
some sort of automated imports

00:42:39.801 --> 00:42:42.601
for existing
subversion repositories,

00:42:42.601 --> 00:42:43.601
which is really cool.

00:42:43.601 --> 00:42:45.267
So...

00:42:45.267 --> 00:42:46.501
Yeah?

00:42:46.501 --> 00:42:48.634
man: Do you offer
transition from subversion

00:42:48.634 --> 00:42:50.367
to Mercurial currently?

00:42:50.367 --> 00:42:51.367
Lee: Yes.

00:42:51.367 --> 00:42:52.767
As of this afternoon,

00:42:52.767 --> 00:42:54.367
you can select
from the little drop-down

00:42:54.367 --> 00:42:55.367
which system to use,

00:42:55.367 --> 00:42:57.000
but unfortunately you do
have to do

00:42:57.000 --> 00:42:58.234
the migration yourself,

00:42:58.234 --> 00:42:59.501
which we know is annoying.

00:42:59.501 --> 00:43:01.334
man: Just interested,

00:43:01.334 --> 00:43:03.100
can you extend this concept

00:43:03.100 --> 00:43:04.934
to content repositories?

00:43:04.934 --> 00:43:06.567
Like, say, does Google Docs

00:43:06.567 --> 00:43:08.834
also use
similar version systems?

00:43:08.834 --> 00:43:10.367
Lee: Sorry?

00:43:10.367 --> 00:43:11.367
man: Like, Google Docs,

00:43:11.367 --> 00:43:13.534
does it use BigTable
for its content?

00:43:13.534 --> 00:43:15.901
Lee: Oh.
I don't know what Docs uses.

00:43:15.901 --> 00:43:19.501
A lot of teams at Google
use BigTable,

00:43:19.501 --> 00:43:22.968
but, I mean, Docs and sites
all do versioning,

00:43:22.968 --> 00:43:26.000
but they're certainly not,
like, using Mercurial

00:43:26.000 --> 00:43:27.167
or Git behind the scenes.

00:43:27.167 --> 00:43:30.334
man: I was wondering
about your experience

00:43:30.334 --> 00:43:33.434
while changing the,
let's say,

00:43:33.434 --> 00:43:36.868
writing or disk back-end of
Mercurial to work with BigTable.

00:43:36.868 --> 00:43:39.734
If you're, for instance,

00:43:39.734 --> 00:43:42.367
going to release these
modifications to Mercurial

00:43:42.367 --> 00:43:43.467
to the public,

00:43:43.467 --> 00:43:45.167
as a first partial question,

00:43:45.167 --> 00:43:47.868
and then what's your opinion
or your advice,

00:43:47.868 --> 00:43:49.601
'cause I'm very interested

00:43:49.601 --> 00:43:51.467
in being able to change
that back-end

00:43:51.467 --> 00:43:53.067
instead of writing
directly to disk--

00:43:53.067 --> 00:43:55.801
writing, for example,
to our relational database.

00:43:55.801 --> 00:43:57.834
Lee: Ooh. That'd be fun.

00:43:57.834 --> 00:43:59.567
Well, it turns out,

00:43:59.567 --> 00:44:02.601
so we're not that fundamental
a structure of the revlog.

00:44:02.601 --> 00:44:05.767
We had to totally
replace that,

00:44:05.767 --> 00:44:09.501
and that's sort of the bulk
of the interesting operat--

00:44:09.501 --> 00:44:10.801
That coupled with us

00:44:10.801 --> 00:44:13.033
only dealing
with the network operations

00:44:13.033 --> 00:44:16.901
means we use the little bits of,
say, like the parsing code,

00:44:16.901 --> 00:44:21.501
but most of the actual
implementation is internal.

00:44:21.501 --> 00:44:25.234
So it'd be something
that's sort of challenging

00:44:25.234 --> 00:44:27.901
to open source because of
the dependency on BigTable,

00:44:27.901 --> 00:44:29.534
but I hope at the very least

00:44:29.534 --> 00:44:32.868
you can expect maybe a white
paper or something from us.

00:44:32.868 --> 00:44:35.501
If not,
as upside of...yeah.

00:44:35.501 --> 00:44:37.033
man:
I was mainly thinking of just

00:44:37.033 --> 00:44:39.267
maybe a small extraction layer

00:44:39.267 --> 00:44:44.200
where you can hook your,
let's say, persistent strategy.

00:44:44.200 --> 00:44:47.634
Lee: Yeah, you can--
the Mercurial code base

00:44:47.634 --> 00:44:49.167
is relatively clean.

00:44:49.167 --> 00:44:51.567
It'd be sort of doable.

00:44:51.567 --> 00:44:53.667
But you have to keep in mind

00:44:53.667 --> 00:44:57.267
your access patterns
are going to--

00:44:57.267 --> 00:45:00.567
or your performance
characteristics

00:45:00.567 --> 00:45:02.033
are going to be
totally different.

00:45:02.033 --> 00:45:05.000
So if it hopes to be able
to do random access

00:45:05.000 --> 00:45:09.667
by integer alias
for changesets,

00:45:09.667 --> 00:45:10.934
and do that quickly,

00:45:10.934 --> 00:45:12.334
you need to be able
to support that.

00:45:12.334 --> 00:45:13.634
Which, actually,
in, you know,

00:45:13.634 --> 00:45:15.067
say, a
stock-relational database,

00:45:15.067 --> 00:45:16.067
probably would be doable.

00:45:16.067 --> 00:45:17.701
We don't use integer I.D.s,

00:45:17.701 --> 00:45:19.868
you know, anywhere
in our implementation.

00:45:19.868 --> 00:45:23.667
It's only hashes, so ours
is pretty quirky in that, so...

00:45:23.667 --> 00:45:25.901
man: Okay, and just
a very small question more.

00:45:25.901 --> 00:45:32.334
Do you support for sub-treat
cloning or exporting?

00:45:32.334 --> 00:45:35.334
Yeah, I mean, instead
of the full repository,

00:45:35.334 --> 00:45:38.467
just the subset of the path.

00:45:38.467 --> 00:45:41.100
Lee: No, I don't think
Mercurial does that.

00:45:41.100 --> 00:45:42.267
man: Mercurial does not.

00:45:42.267 --> 00:45:43.601
Lee: Yeah, no,
so we don't either.

00:45:43.601 --> 00:45:44.601
man: Okay, thank you.

00:45:44.601 --> 00:45:47.534
Lee: It's not in the protocol.

00:45:47.534 --> 00:45:48.701
man: Hi.

00:45:48.701 --> 00:45:51.934
A lot of CM systems
set up at the beginning

00:45:51.934 --> 00:45:54.534
to facilitate the rest
of the engineering process.

00:45:54.534 --> 00:45:57.267
Do you have any plans
to integrate or support

00:45:57.267 --> 00:46:00.300
continuous integration
on the back end,

00:46:00.300 --> 00:46:02.334
tying into bug systems

00:46:02.334 --> 00:46:04.868
where you can track changes

00:46:04.868 --> 00:46:06.200
both in the
issue tracking system

00:46:06.200 --> 00:46:08.400
and in the quote system
linked together?

00:46:08.400 --> 00:46:10.767
Lee: Some of that
is possible right now.

00:46:10.767 --> 00:46:12.100
We support web hooks,

00:46:12.100 --> 00:46:14.701
so when there's a new commit
in the repository

00:46:14.701 --> 00:46:16.567
or a new push for Mercurial,

00:46:16.567 --> 00:46:20.400
we just hit an external URL.

00:46:20.400 --> 00:46:22.767
That URL then could get
that revision

00:46:22.767 --> 00:46:25.934
and run, say, a continuous
build from that.

00:46:25.934 --> 00:46:27.968
It's something that--
it would be sort of challenging

00:46:27.968 --> 00:46:29.133
for us to support internally,

00:46:29.133 --> 00:46:30.467
just 'cause every build system

00:46:30.467 --> 00:46:32.000
is so radically unique,

00:46:32.000 --> 00:46:33.734
so that's the best bet
for now.

00:46:33.734 --> 00:46:39.234
man: And what about integration
with bug tracking?

00:46:39.234 --> 00:46:41.234
Lee:
What sort of integration?

00:46:41.234 --> 00:46:43.868
man: Well, a lot of
well developed CM systems

00:46:43.868 --> 00:46:45.567
have this notion
that you have a change,

00:46:45.567 --> 00:46:48.067
and the change incorporates
both the code change

00:46:48.067 --> 00:46:50.467
and the issues
that are associated with it.

00:46:50.467 --> 00:46:52.434
Lee: Versioned issues.
No, we--

00:46:52.434 --> 00:46:53.734
man:
Not versioning the issues,

00:46:53.734 --> 00:46:54.901
but tying the issues together

00:46:54.901 --> 00:46:56.100
with the source-code changes.

00:46:56.100 --> 00:46:57.667
Lee:
We have some integration

00:46:57.667 --> 00:47:00.601
where your commits
include commands

00:47:00.601 --> 00:47:01.634
to the issue tracker.

00:47:01.634 --> 00:47:04.000
Like, "Fixes issue number 23."

00:47:04.000 --> 00:47:06.601
It will actually close
issue 23,

00:47:06.601 --> 00:47:07.667
so that's sort of
the most we do.

00:47:07.667 --> 00:47:09.934
man: Okay.

00:47:09.934 --> 00:47:11.634
Lee: All right?

00:47:11.634 --> 00:47:13.167
Thank you.
We have T-shirts.

00:47:13.167 --> 00:47:14.434
[applause]

