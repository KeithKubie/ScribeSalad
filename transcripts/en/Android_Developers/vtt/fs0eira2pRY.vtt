WEBVTT
Kind: captions
Language: en

00:00:03.290 --> 00:00:04.700
XAVIER DUCROCHET: Good morning.

00:00:04.700 --> 00:00:06.370
My name is Xavier Ducrochet.

00:00:06.370 --> 00:00:07.890
TOR NORBYE: I'm Torn Norbye.

00:00:07.890 --> 00:00:12.040
JAMAL EASON: Hi, and I'm
Jamal, and welcome to

00:00:12.040 --> 00:00:17.970
"What's new in Android Studio."

00:00:17.970 --> 00:00:20.680
So today we're going to talk
about three distinct features,

00:00:20.680 --> 00:00:26.300
IDE enhancements, build system,
and the Android Emulator.

00:00:26.300 --> 00:00:30.510
So first topic, the Android
Studio Enhancements.

00:00:30.510 --> 00:00:36.032
So going back, at Google I/O
we launched Android Studio 1.3,

00:00:36.032 --> 00:00:37.990
and there we launched a
whole host of features,

00:00:37.990 --> 00:00:40.860
including the C++
editor, data binding,

00:00:40.860 --> 00:00:44.480
and some new art new UI
around SDK management.

00:00:44.480 --> 00:00:46.550
Over this past
summer and fall, we

00:00:46.550 --> 00:00:49.940
worked on new vector
assets, new HPROF bug fixes,

00:00:49.940 --> 00:00:53.940
and a whole host of other
features around Android Studio.

00:00:53.940 --> 00:00:56.770
And today we are really excited
to talk about Android Studio

00:00:56.770 --> 00:00:59.470
2.0 today at the
Android Dev Summit.

00:01:02.330 --> 00:01:06.030
So features since
Google I/O 2015.

00:01:06.030 --> 00:01:08.000
Before jumping into
some of the 2.0 stuff,

00:01:08.000 --> 00:01:10.240
I want to recap some of the
great stuff we worked on

00:01:10.240 --> 00:01:12.920
in the past few months.

00:01:12.920 --> 00:01:15.580
So for instance, we
launched a GPU Monitor.

00:01:15.580 --> 00:01:18.340
The GPU monitor allows
you to look at your app

00:01:18.340 --> 00:01:21.580
as is performing on your device
and see the impact on the GPU

00:01:21.580 --> 00:01:24.150
calls for your device.

00:01:24.150 --> 00:01:25.490
We launched a network monitor.

00:01:25.490 --> 00:01:27.470
You look at the input
and output calls

00:01:27.470 --> 00:01:30.430
of your device on the network
while running your device

00:01:30.430 --> 00:01:34.590
on either an emulator
or a real device.

00:01:34.590 --> 00:01:35.590
App implants.

00:01:35.590 --> 00:01:38.290
For the new App templates,
we took a real look at those

00:01:38.290 --> 00:01:41.490
and added things like App
compact, design library

00:01:41.490 --> 00:01:43.400
to help you get
started on a new app,

00:01:43.400 --> 00:01:45.716
or add new enhancements to
a preexisting application.

00:01:48.790 --> 00:01:49.440
Theme editor.

00:01:49.440 --> 00:01:52.180
Theme editor was a way for
you to visualize your styles

00:01:52.180 --> 00:01:55.540
and colors to XML, to get
a recap of how your look

00:01:55.540 --> 00:01:57.620
and feel is going to
look for the application,

00:01:57.620 --> 00:02:02.050
and visualize those tweaks as
you do your app development.

00:02:02.050 --> 00:02:03.950
And Vector Asset Studio.

00:02:03.950 --> 00:02:06.150
One pain point we talked
about at Google I/O

00:02:06.150 --> 00:02:08.570
was about how to manage
your raster assets.

00:02:08.570 --> 00:02:10.660
Previously you
would have to manage

00:02:10.660 --> 00:02:15.250
10 to 20 different assets per
API level for your application.

00:02:15.250 --> 00:02:18.620
Today you can import one of
the vector drawable assets

00:02:18.620 --> 00:02:21.130
we provide for you from
the material library,

00:02:21.130 --> 00:02:23.960
or you can import one
of your own SEG files

00:02:23.960 --> 00:02:25.790
and place that in
your application.

00:02:25.790 --> 00:02:27.890
And during build time,
we will automatically

00:02:27.890 --> 00:02:29.490
generate all the
raster images for you

00:02:29.490 --> 00:02:31.883
automatically, so you only
have to manage one asset.

00:02:35.749 --> 00:02:37.540
And that's just an
example of a few things.

00:02:37.540 --> 00:02:40.300
We have Lint checks,
better accessibility,

00:02:40.300 --> 00:02:42.940
bi-directional support,
better test UI, a Logcat, a

00:02:42.940 --> 00:02:44.340
and a whole host of things.

00:02:44.340 --> 00:02:45.927
And we're still investing.

00:02:45.927 --> 00:02:47.510
We're excited that
we're still working

00:02:47.510 --> 00:02:50.300
on things to make your life
more better as an app developer.

00:02:50.300 --> 00:02:52.720
With that, we'll jump
into the build system.

00:02:52.720 --> 00:02:55.300
XAVIER DUCROCHET: All right,
thank you J. All right,

00:02:55.300 --> 00:02:59.150
so let's talk about
the build system.

00:02:59.150 --> 00:03:01.140
Before we talk
about Instant Run we

00:03:01.140 --> 00:03:04.450
want to talk about just general
build system improvement.

00:03:04.450 --> 00:03:06.012
Instant Run does
not always activate,

00:03:06.012 --> 00:03:07.470
and so we still
wanted to make sure

00:03:07.470 --> 00:03:11.550
that the build system would
be faster than it used to be.

00:03:11.550 --> 00:03:14.480
So we know of a few
bottlenecks that I'm sure

00:03:14.480 --> 00:03:16.929
very obvious to you, whether
it's dx or ProGuard or just

00:03:16.929 --> 00:03:17.970
the installation process.

00:03:17.970 --> 00:03:20.820
So let's go through
a few of those.

00:03:20.820 --> 00:03:24.050
So the first fix that we did
was we improved the dx merger.

00:03:24.050 --> 00:03:26.260
So when you build with
Android, with a Gradle

00:03:26.260 --> 00:03:28.540
and you have a lot
of dependencies,

00:03:28.540 --> 00:03:31.740
we're going to predict all of
those dependencies separately

00:03:31.740 --> 00:03:33.740
running dx on each of
them, and then at the hand

00:03:33.740 --> 00:03:35.180
we have a merge state.

00:03:35.180 --> 00:03:38.400
Now, the algorithm them was
pretty bad, unfortunately.

00:03:38.400 --> 00:03:41.599
It was a quadratic algorithm,
and so the more and more

00:03:41.599 --> 00:03:44.140
dependencies that you have in
your project, the really slower

00:03:44.140 --> 00:03:45.200
it would get.

00:03:45.200 --> 00:03:46.560
The new one is linear.

00:03:46.560 --> 00:03:48.860
If you have a large
number of dependencies,

00:03:48.860 --> 00:03:52.640
just the dx merger step could be
at least an order of magnitude

00:03:52.640 --> 00:03:53.910
faster.

00:03:53.910 --> 00:03:58.680
It's available in 23.0.2, which
we shipped a few weeks ago,

00:03:58.680 --> 00:04:01.680
so if your project is not
yet using that build tools,

00:04:01.680 --> 00:04:03.850
you should definitely get it.

00:04:03.850 --> 00:04:07.360
The second thing that we did
was we now run dx in process.

00:04:07.360 --> 00:04:10.570
So I said we run a
lot of critics saying,

00:04:10.570 --> 00:04:13.230
a lot of different version of
dx in parallel, and for each

00:04:13.230 --> 00:04:15.200
of those we would
start a different VM.

00:04:15.200 --> 00:04:18.750
And that means you have the
cost of starting the VM.

00:04:18.750 --> 00:04:20.269
That means that
the JIT of the JVM

00:04:20.269 --> 00:04:22.560
does not have time to
really optimize the code,

00:04:22.560 --> 00:04:24.290
and then it's
really a lot slower.

00:04:24.290 --> 00:04:27.730
So we changed that
in Plugin 2.0.

00:04:27.730 --> 00:04:30.900
Also, it requires
Build Tools 23.0.2,

00:04:30.900 --> 00:04:32.740
and it requires Gradle 2.4.

00:04:32.740 --> 00:04:35.044
The previous version would
drop all the plug-in code

00:04:35.044 --> 00:04:36.960
on every run, so that
would not actually work.

00:04:36.960 --> 00:04:39.770
We recommend using
2.8 or 2.9 anyway,

00:04:39.770 --> 00:04:41.540
but you need at least 2.4.

00:04:41.540 --> 00:04:46.156
Simple set up, just dexOption,
dexInProcess equal true.

00:04:46.156 --> 00:04:48.530
For now, it's forced by default.
We want to get feedback.

00:04:48.530 --> 00:04:50.360
Make sure that there's no issue.

00:04:50.360 --> 00:04:53.250
So let's look at some benchmark.

00:04:53.250 --> 00:04:54.770
This is I/O schedule 2014.

00:04:54.770 --> 00:04:56.810
There's about 15
or so dependencies,

00:04:56.810 --> 00:04:58.230
maybe a bit more than that.

00:04:58.230 --> 00:05:01.390
As you can see, both clean
builds and incremental

00:05:01.390 --> 00:05:03.404
build are much, much faster.

00:05:03.404 --> 00:05:04.320
So that's pretty good.

00:05:04.320 --> 00:05:07.310
So on the left is the
old plug-in, the old dx,

00:05:07.310 --> 00:05:09.310
and on the right is the
new plug-in, the new dx,

00:05:09.310 --> 00:05:11.310
and dx in process.

00:05:11.310 --> 00:05:12.740
Now, doing that
has some trade off

00:05:12.740 --> 00:05:14.060
that you have to think about.

00:05:14.060 --> 00:05:16.740
I'm sure some of you have
done something like that,

00:05:16.740 --> 00:05:19.720
giving a few more memory to dx.

00:05:19.720 --> 00:05:23.355
Now, what happens here
is that every call to dx

00:05:23.355 --> 00:05:24.480
will actually get two gigs.

00:05:24.480 --> 00:05:26.050
So if you're predicting
four different libraries

00:05:26.050 --> 00:05:28.220
in parallel, you have four
dx running in parallel,

00:05:28.220 --> 00:05:29.770
and each of them gets two gigs.

00:05:29.770 --> 00:05:32.630
And all of them will
be in the same JVM,

00:05:32.630 --> 00:05:34.055
so you will need
to give probably

00:05:34.055 --> 00:05:35.560
a little bit more memory.

00:05:35.560 --> 00:05:38.080
The other thing to think
about is that this,

00:05:38.080 --> 00:05:40.760
when we toss that in
your build of Gradle,

00:05:40.760 --> 00:05:43.000
the Gradle JVM has
already started,

00:05:43.000 --> 00:05:45.500
and you cannot change that
after the fact, right.

00:05:45.500 --> 00:05:47.220
So it's only to control
external process.

00:05:47.220 --> 00:05:48.761
So if you have that
right now in your

00:05:48.761 --> 00:05:51.070
build of Gradle, when you
switch to dx in process

00:05:51.070 --> 00:05:52.510
that won't do anything.

00:05:52.510 --> 00:05:55.220
You have instead to
change Gradle properties,

00:05:55.220 --> 00:05:56.674
give it more memory.

00:05:56.674 --> 00:05:59.090
You may already have done that
because ProGuard is already

00:05:59.090 --> 00:06:01.892
in memory, and ProGuard some
times requires a lot of memory.

00:06:01.892 --> 00:06:03.600
So you will have to
play with that value.

00:06:03.600 --> 00:06:06.510
It may not be exactly,
like four times what

00:06:06.510 --> 00:06:09.020
you gave to dx before because
there's different overhead,

00:06:09.020 --> 00:06:10.980
but you should play
with the number.

00:06:10.980 --> 00:06:14.470
Do realize, though, that this
is long lasting in the daemon.

00:06:14.470 --> 00:06:16.510
The daemon has a
three hour time out,

00:06:16.510 --> 00:06:18.510
so this memory will
be used all the time,

00:06:18.510 --> 00:06:21.480
while before dx was really
to fire and then forget,

00:06:21.480 --> 00:06:24.020
and the JVM would disappear.

00:06:24.020 --> 00:06:25.995
Still, it's a very
big speed gain,

00:06:25.995 --> 00:06:27.420
so you should definitely try it.

00:06:27.420 --> 00:06:30.370
Right now we run up to
four dx in parallel.

00:06:30.370 --> 00:06:33.150
You can control that through
an environmental variable,

00:06:33.150 --> 00:06:35.190
android.dexerPoolSize.

00:06:35.190 --> 00:06:36.790
Give us feedback
on the number that

00:06:36.790 --> 00:06:38.790
works for you, the memory,
and things like that,

00:06:38.790 --> 00:06:42.480
and we may tweak the
default values later.

00:06:42.480 --> 00:06:45.257
The second bottleneck I want
to talk about is ProGuard.

00:06:45.257 --> 00:06:46.340
Now, ProGuard works great.

00:06:46.340 --> 00:06:47.360
There's no issue.

00:06:47.360 --> 00:06:50.230
You know, if you're running
it for your release process,

00:06:50.230 --> 00:06:51.270
not a problem.

00:06:51.270 --> 00:06:52.686
The problem starts
happening when

00:06:52.686 --> 00:06:54.060
you have a really
big application

00:06:54.060 --> 00:06:55.930
and you have more
than 65K method,

00:06:55.930 --> 00:06:58.231
and you need to shrink it
below the actually limit.

00:06:58.231 --> 00:07:00.730
So when you do that, you need
to run ProGuard on every debug

00:07:00.730 --> 00:07:02.840
build, and it's slow.

00:07:02.840 --> 00:07:04.500
The main problem,
it's not incremental.

00:07:04.500 --> 00:07:07.630
And a second problem is
it disables PreDexing.

00:07:07.630 --> 00:07:10.120
And by that, I mean that
when you run ProGuard,

00:07:10.120 --> 00:07:12.310
the output of ProGuard
is a single jar, which

00:07:12.310 --> 00:07:14.870
means that you have to
re-dex the whole application

00:07:14.870 --> 00:07:16.420
and its dependencies every time.

00:07:16.420 --> 00:07:18.354
And so we really
wanted to fix that.

00:07:18.354 --> 00:07:20.020
So we've been working
on a new shrinker.

00:07:20.020 --> 00:07:22.970
It's experimental right now.

00:07:22.970 --> 00:07:25.960
The big thing is that it
has some incrementality.

00:07:25.960 --> 00:07:29.140
But the big thing, really,
is that it unables preDexing.

00:07:29.140 --> 00:07:31.410
So if you have, let's
say, your main application

00:07:31.410 --> 00:07:33.890
plus 10 dependencies, the
output of the shrinker

00:07:33.890 --> 00:07:37.920
will be 10 dependencies, or 10
jars, plus a jar for your code.

00:07:37.920 --> 00:07:41.729
And even if the shrinker has to
do a full non-incremental run,

00:07:41.729 --> 00:07:42.770
it doesn't really matter.

00:07:42.770 --> 00:07:44.980
If it only touches one
of those jar files,

00:07:44.980 --> 00:07:47.540
the other nine jars
will be the same,

00:07:47.540 --> 00:07:49.460
and Gradle allows
us to just say, hey,

00:07:49.460 --> 00:07:50.460
those jars are the same.

00:07:50.460 --> 00:07:51.626
I don't need to re-dex them.

00:07:51.626 --> 00:07:53.150
I already have dexed
them somewhere.

00:07:53.150 --> 00:07:56.000
And that's again
a big speed gain.

00:07:56.000 --> 00:07:57.700
This is only a shrinker.

00:07:57.700 --> 00:07:59.300
Our goal is not to
replace ProGuard.

00:07:59.300 --> 00:08:01.334
So the configuration
is per-variant.

00:08:01.334 --> 00:08:02.500
It doesn't do a obfuscation.

00:08:02.500 --> 00:08:03.750
It doesn't do it optimization.

00:08:03.750 --> 00:08:06.010
It's only a shrinker
for debug mode only.

00:08:06.010 --> 00:08:11.020
And the other thing it
will allow us in the future

00:08:11.020 --> 00:08:13.540
is to do legacy multi-dex
faster, as well.

00:08:13.540 --> 00:08:15.390
Right now, if you first
shrink with ProGuard

00:08:15.390 --> 00:08:17.940
to get below to 65K limit,
but you're still above it,

00:08:17.940 --> 00:08:19.860
you have to enable
legacy multi-dex,

00:08:19.860 --> 00:08:22.369
if your main SDK
is less than 21.

00:08:22.369 --> 00:08:24.410
So in that case what
happens is the process says,

00:08:24.410 --> 00:08:26.150
hey, we run ProGuard
a second time.

00:08:26.150 --> 00:08:29.500
Because it was slow the first
time, so let's run it again.

00:08:29.500 --> 00:08:32.450
And so here, because we control
the code of the shrinker,

00:08:32.450 --> 00:08:35.650
it's easier to keep the graph
of dependencies and method codes

00:08:35.650 --> 00:08:37.400
and things like
that, and actually

00:08:37.400 --> 00:08:39.940
run shrinker and multi-dex
at the same time.

00:08:39.940 --> 00:08:42.150
So that will come later,
probably after today

00:08:42.150 --> 00:08:46.157
though, we want to stabilize
first the shrinker for 2.0.

00:08:46.157 --> 00:08:47.740
It's not actually
available right now,

00:08:47.740 --> 00:08:49.782
in alpha, one of the plug- in.

00:08:49.782 --> 00:08:52.040
It will come in the next
plug-in in a few weeks.

00:08:52.040 --> 00:08:53.420
This is how you
enable it, so you

00:08:53.420 --> 00:08:56.532
do have to unable minify still.

00:08:56.532 --> 00:08:58.490
Within debug, you would
say, useProguard false,

00:08:58.490 --> 00:09:00.406
and in release you would
say useProguard true.

00:09:00.406 --> 00:09:03.480
Actually, it's true by default,
so you don't need to say it,

00:09:03.480 --> 00:09:06.210
but this is what
would happen here.

00:09:06.210 --> 00:09:07.377
The results.

00:09:07.377 --> 00:09:08.960
So if we look at
here, the first thing

00:09:08.960 --> 00:09:11.126
I want to mention, just to
go back to the dx merger,

00:09:11.126 --> 00:09:13.500
if you compare the clean
build on the first column

00:09:13.500 --> 00:09:15.390
and the clean build with
shrinking on the first column,

00:09:15.390 --> 00:09:17.640
you'll notice that, hey,
running ProGuard is faster.

00:09:17.640 --> 00:09:19.920
That's because,
again, I said ProGuard

00:09:19.920 --> 00:09:24.494
disables merging of dx, and
dx being so bad at merging,

00:09:24.494 --> 00:09:25.910
it's actually
better not to do it.

00:09:25.910 --> 00:09:27.720
But anyway, we fixed that.

00:09:27.720 --> 00:09:29.840
So on the right
column, you can see

00:09:29.840 --> 00:09:32.780
that we're quite
faster than before,

00:09:32.780 --> 00:09:35.820
almost two x, and that
is running the shrinker

00:09:35.820 --> 00:09:37.340
in a non incremental way.

00:09:37.340 --> 00:09:40.547
So as soon as there's a change,
we re-run the full shrinking.

00:09:40.547 --> 00:09:42.380
If we run it actually
in an incremental way,

00:09:42.380 --> 00:09:43.760
it's something that is
not completely there,

00:09:43.760 --> 00:09:45.510
so I do not want to
show the numbers,

00:09:45.510 --> 00:09:48.020
we get a little
bit faster, again.

00:09:48.020 --> 00:09:51.180
So if you compare
on the left side,

00:09:51.180 --> 00:09:53.190
basically doing a clean
or an incremental build

00:09:53.190 --> 00:09:54.890
was just basically
not different,

00:09:54.890 --> 00:09:58.480
and here we can get, hopefully,
at least twice faster

00:09:58.480 --> 00:10:00.290
than a clean build
for incremental.

00:10:00.290 --> 00:10:01.770
So that's quite good.

00:10:01.770 --> 00:10:03.680
So that's the changes
for actually building.

00:10:03.680 --> 00:10:05.830
Now we want to talk
about deployment.

00:10:05.830 --> 00:10:06.750
Deployment is slow.

00:10:06.750 --> 00:10:08.290
We know ADB is slow.

00:10:08.290 --> 00:10:10.380
So we talked about
it a little bit

00:10:10.380 --> 00:10:12.040
yesterday during the keynote.

00:10:12.040 --> 00:10:14.480
We'll have a new ADB
push/pull protocol.

00:10:14.480 --> 00:10:16.321
Much faster throughput.

00:10:16.321 --> 00:10:18.570
It's coming to the emulator
soon, and with some system

00:10:18.570 --> 00:10:22.230
image, at least API 22 and 23.

00:10:22.230 --> 00:10:27.200
And we'll backhaul that later
to two more system images.

00:10:27.200 --> 00:10:28.990
So deploying faster is great.

00:10:28.990 --> 00:10:32.450
What we want to do also
is maybe push less.

00:10:32.450 --> 00:10:35.655
We have a new
mechanism in studio 1.5

00:10:35.655 --> 00:10:38.280
that you may have noticed, where
when you click the run button,

00:10:38.280 --> 00:10:41.430
we first ask you where
you want to deploy it to.

00:10:41.430 --> 00:10:43.580
And then we build,
and then we deploy.

00:10:43.580 --> 00:10:46.770
And before we would do first
build and then ask you.

00:10:46.770 --> 00:10:49.239
So this is something
that is not related

00:10:49.239 --> 00:10:50.780
to what we wanted
to do, but since we

00:10:50.780 --> 00:10:52.870
are doing that now, we figured,
hey maybe we can do something.

00:10:52.870 --> 00:10:54.720
So as a first proof
of concept, we

00:10:54.720 --> 00:10:58.172
decided to do it to
target specifically

00:10:58.172 --> 00:10:59.630
for your device in
term of density.

00:10:59.630 --> 00:11:01.310
So if you plug a
device with MDPI,

00:11:01.310 --> 00:11:05.460
you know, wide package,
XHDPI wide package, XXHDPI

00:11:05.460 --> 00:11:06.650
and all of that.

00:11:06.650 --> 00:11:08.570
So APT does that for
us in a very smart way.

00:11:08.570 --> 00:11:13.280
So if there's some assets
that you do not have in MDPI,

00:11:13.280 --> 00:11:15.470
it will package in
all the density,

00:11:15.470 --> 00:11:17.120
basically like the
device would choose.

00:11:17.120 --> 00:11:20.080
Right, if you have a device
that has a density, when

00:11:20.080 --> 00:11:25.390
you don't have those assets, it
finds some other assets to use.

00:11:25.390 --> 00:11:27.600
So here we don't gain
a whole lot, only 10%,

00:11:27.600 --> 00:11:29.426
but this is still useful.

00:11:29.426 --> 00:11:31.300
But we do want to extend
that to more things.

00:11:31.300 --> 00:11:33.466
So the things that we want
to extend to, for example

00:11:33.466 --> 00:11:34.380
are ABIs.

00:11:34.380 --> 00:11:38.000
If you deploy to an X86 device,
why build and package on code?

00:11:38.000 --> 00:11:39.040
Let's not do it.

00:11:39.040 --> 00:11:40.950
Right, so we'll do
that next, and that

00:11:40.950 --> 00:11:43.980
would be for people who have
native code, a big gain.

00:11:43.980 --> 00:11:46.160
And then we want to do
that for multi-dex as well.

00:11:46.160 --> 00:11:47.243
It's not really packaging.

00:11:47.243 --> 00:11:48.870
It's more building this time.

00:11:48.870 --> 00:11:50.380
Right now, we tell
you, hey, if you

00:11:50.380 --> 00:11:51.880
have to use legacy
multi-dex and you

00:11:51.880 --> 00:11:55.210
want it to be faster, create
a variant for minSDK 21

00:11:55.210 --> 00:11:57.320
and above, so that when
you deploy to, let's

00:11:57.320 --> 00:11:59.960
say, a marshmallow device
it uses the native multi-dex

00:11:59.960 --> 00:12:01.230
rather than the legacy.

00:12:01.230 --> 00:12:03.021
So here we're
basically going to be

00:12:03.021 --> 00:12:04.270
able to do that automatically.

00:12:04.270 --> 00:12:07.600
If you plug at 21, it will just
build it with the native one.

00:12:07.600 --> 00:12:09.280
You unplug it, you
plug a different one,

00:12:09.280 --> 00:12:10.850
and it will use the legacy one.

00:12:10.850 --> 00:12:13.350
That way you don't have to think
about changing the variants

00:12:13.350 --> 00:12:15.570
and deploying the wrong
variant to the wrong device,

00:12:15.570 --> 00:12:18.950
and all of that will just
take care of that for you.

00:12:18.950 --> 00:12:22.911
OK so, we saw a building,
we saw deploying,

00:12:22.911 --> 00:12:23.910
now you have to install.

00:12:23.910 --> 00:12:25.380
So I took this small
little app, right.

00:12:25.380 --> 00:12:26.330
IO schedule five meg.

00:12:26.330 --> 00:12:27.320
That's not really big.

00:12:27.320 --> 00:12:29.400
And I try to install
it on my Nexus six,

00:12:29.400 --> 00:12:34.141
and the install was 12 seconds,
which is just 12 seconds.

00:12:34.141 --> 00:12:34.640
It's awful.

00:12:34.640 --> 00:12:36.330
I mean, we have
before and after.

00:12:36.330 --> 00:12:38.060
Right, it's like we made
some really good progress

00:12:38.060 --> 00:12:38.580
on building.

00:12:38.580 --> 00:12:39.505
2.4 x.

00:12:39.505 --> 00:12:40.130
That's awesome.

00:12:40.130 --> 00:12:43.500
And then we add installation,
and it's just bad.

00:12:43.500 --> 00:12:46.890
So 18 x is better than 28.

00:12:46.890 --> 00:12:49.076
Sorry, 18 seconds
is better than 28,

00:12:49.076 --> 00:12:50.450
but it's still
just way too slow.

00:12:50.450 --> 00:12:52.140
So we wanted to fix that.

00:12:52.140 --> 00:12:53.790
And so that's why
we did Instant Run.

00:12:53.790 --> 00:12:57.130
We really wanted to change the
whole deployment cycle from end

00:12:57.130 --> 00:12:57.630
to end.

00:12:57.630 --> 00:12:59.820
Not just focus on building,
but look at everything.

00:12:59.820 --> 00:13:01.695
And we wanted to do that
in a way that worked

00:13:01.695 --> 00:13:03.390
on all the devices as well.

00:13:03.390 --> 00:13:04.680
So Instant Run.

00:13:04.680 --> 00:13:08.264
What we want to do is we want
to deploy as little as possible,

00:13:08.264 --> 00:13:09.610
so only what changed.

00:13:09.610 --> 00:13:12.540
We want to avoid installing,
because as we just it's 20

00:13:12.540 --> 00:13:15.220
seconds, or more if you have a
much bigger application, right.

00:13:15.220 --> 00:13:17.050
It could be a lot more.

00:13:17.050 --> 00:13:19.130
And while we're at
it, let's just not

00:13:19.130 --> 00:13:22.080
kill the app whatsoever, right.

00:13:22.080 --> 00:13:23.821
TOR NORBYE: So to
avoid killing the app,

00:13:23.821 --> 00:13:25.320
it's not always
possible if you made

00:13:25.320 --> 00:13:26.970
a completely structural change.

00:13:26.970 --> 00:13:28.512
But when we can
leave it running,

00:13:28.512 --> 00:13:29.720
that's what we call hot-swap.

00:13:29.720 --> 00:13:31.840
So the app is just running.

00:13:31.840 --> 00:13:34.814
If we have to mess with your
app in more significant ways,

00:13:34.814 --> 00:13:37.230
but still leave it running,
that's what we call warm swap.

00:13:37.230 --> 00:13:40.470
So a resource change
will trigger a warm swap.

00:13:40.470 --> 00:13:42.060
Cold swap is not in
the preview build,

00:13:42.060 --> 00:13:44.110
but that's where we
restart your app in order

00:13:44.110 --> 00:13:45.690
to make bigger
structural changes so

00:13:45.690 --> 00:13:48.070
that your objects have changed.

00:13:48.070 --> 00:13:50.650
And of course, the last one
is full rebuild and reinstall.

00:13:50.650 --> 00:13:52.830
If you change something,
for example, the app icon,

00:13:52.830 --> 00:13:54.560
we're going to have to do this
because obviously your launcher

00:13:54.560 --> 00:13:55.476
wants to see the icon.

00:13:55.476 --> 00:13:57.322
We can't deal with that.

00:13:57.322 --> 00:14:00.240
But rebuild and reinstall
is where we are today before

00:14:00.240 --> 00:14:01.480
and Instant Run.

00:14:01.480 --> 00:14:03.729
XAVIER DUCROCHET: So let's
see what happens, actually,

00:14:03.729 --> 00:14:05.877
when you do a full regular
build with Instant Run

00:14:05.877 --> 00:14:07.710
because we have to
prepare your application.

00:14:07.710 --> 00:14:09.590
If you take a regular
application built with an older

00:14:09.590 --> 00:14:12.310
version of Studio, we can't just
go and replace stuff on the fly

00:14:12.310 --> 00:14:12.490
there.

00:14:12.490 --> 00:14:13.656
It's just not going to work.

00:14:13.656 --> 00:14:15.770
So the first thing
that we started doing

00:14:15.770 --> 00:14:18.172
is, when you build it
with Gradle from Studio,

00:14:18.172 --> 00:14:20.130
we kind of do something
a little bit different.

00:14:20.130 --> 00:14:24.760
So we call Gradle with and
additional property saying,

00:14:24.760 --> 00:14:26.690
hey, you're in
that special mode.

00:14:26.690 --> 00:14:28.520
And in Gradle we
create additional tasks

00:14:28.520 --> 00:14:30.270
in order to do more
work than if you

00:14:30.270 --> 00:14:31.700
build from the command line.

00:14:31.700 --> 00:14:34.355
So we'll do bytecode
instrumentation,

00:14:34.355 --> 00:14:36.730
we'll add a server to you app
so that you can talk to it,

00:14:36.730 --> 00:14:37.660
and things like that.

00:14:37.660 --> 00:14:40.870
So let's look at
what it looks like.

00:14:40.870 --> 00:14:43.304
This is a very simplified
version of the build steps.

00:14:43.304 --> 00:14:44.720
Right, we have the
manifest merger

00:14:44.720 --> 00:14:46.257
that generates
the final manifest

00:14:46.257 --> 00:14:47.840
that we packaged
with APT, and then we

00:14:47.840 --> 00:14:52.700
have the Java CDX flow where we
just compile and convert code.

00:14:52.700 --> 00:14:55.080
So the first thing that we
do is we stop feeding dx

00:14:55.080 --> 00:14:56.730
with regular classes.

00:14:56.730 --> 00:14:59.192
So we have a new API
called Transform API,

00:14:59.192 --> 00:15:00.900
and I'll talk about
that in my other talk

00:15:00.900 --> 00:15:02.049
on the Gradle plugin.

00:15:02.049 --> 00:15:04.340
And so we're going to do that
bytecode instrumentation,

00:15:04.340 --> 00:15:06.360
and we're basically going to
add a level of indirection

00:15:06.360 --> 00:15:08.330
to every method and
constructor in your code

00:15:08.330 --> 00:15:11.820
so that we can go and replace
stuff on the fly later.

00:15:11.820 --> 00:15:14.120
Then, I mentioned we need
an app server because Studio

00:15:14.120 --> 00:15:16.203
will talk directly to the
app, so we add that code

00:15:16.203 --> 00:15:17.850
to your app.

00:15:17.850 --> 00:15:20.840
And then we just
send that to dx.

00:15:20.840 --> 00:15:22.550
In order to actually
start the server

00:15:22.550 --> 00:15:25.010
and add some custom classloader
and things like that,

00:15:25.010 --> 00:15:26.676
we actually have to
change our manifest.

00:15:26.676 --> 00:15:28.350
So we actually
instrument your manifest.

00:15:28.350 --> 00:15:33.020
We add stuff to it, and we add
a new custom application class,

00:15:33.020 --> 00:15:35.640
and then we actually need to
add that particular application

00:15:35.640 --> 00:15:37.020
class to your code.

00:15:37.020 --> 00:15:40.350
And that, if you have already
your own custom application

00:15:40.350 --> 00:15:43.170
class, the one that
we use will proxy

00:15:43.170 --> 00:15:45.530
and delegate to yours so
that it's transparent.

00:15:45.530 --> 00:15:47.280
You don't have
anything to change.

00:15:47.280 --> 00:15:49.230
That was one thing that
we really wanted to do

00:15:49.230 --> 00:15:51.760
is, as a developer, you
shouldn't have to go and hack

00:15:51.760 --> 00:15:54.080
the code around to make the
app work with Instant Run.

00:15:54.080 --> 00:15:55.480
It should just work.

00:15:55.480 --> 00:15:57.260
And then the final
thing that we are doing

00:15:57.260 --> 00:15:59.930
is, in order to make sure that
the connection between the app

00:15:59.930 --> 00:16:02.632
and Studio is valid,
we generate a build ID

00:16:02.632 --> 00:16:04.090
on every build to
make sure that we

00:16:04.090 --> 00:16:07.620
know what the current state is.

00:16:07.620 --> 00:16:10.180
TOR NORBYE: So when you are
hitting the Run button in ID,

00:16:10.180 --> 00:16:11.410
this is what happens.

00:16:11.410 --> 00:16:14.519
We first make sure that you're
actually using Gradle 2.0.

00:16:14.519 --> 00:16:16.310
And then we check the
build IDs I have just

00:16:16.310 --> 00:16:19.060
mentioned to make sure that the
device and Gradle are in sync,

00:16:19.060 --> 00:16:21.740
because if they're
not, if you run

00:16:21.740 --> 00:16:24.077
your device on a different
development machine,

00:16:24.077 --> 00:16:26.410
it could be really, really
bad if we put the wrong bytes

00:16:26.410 --> 00:16:27.787
on there that are incompatible.

00:16:27.787 --> 00:16:29.870
Then we make sure that we
can actually talk to it,

00:16:29.870 --> 00:16:32.240
so we use a socket
connection to the app.

00:16:32.240 --> 00:16:34.530
And then we check, is the
activity in the foreground?

00:16:34.530 --> 00:16:37.880
And if all that's true,
then we run Gradle.

00:16:37.880 --> 00:16:40.440
And Gradle is run with a
different task which basically

00:16:40.440 --> 00:16:42.720
would build up the dex files.

00:16:42.720 --> 00:16:45.140
It then runs a verifier
which makes sure

00:16:45.140 --> 00:16:47.240
that everything that
you've done in your code

00:16:47.240 --> 00:16:49.660
is compatible with a hot-swap.

00:16:49.660 --> 00:16:52.750
And if it is, of course
we can do a hot-swap,

00:16:52.750 --> 00:16:55.061
otherwise we will
do a cold swap.

00:16:55.061 --> 00:16:56.810
And the other thing
we do for optimization

00:16:56.810 --> 00:16:59.334
is to monitor the files
you're editing in the ID.

00:16:59.334 --> 00:17:00.750
And the reason
we're doing that is

00:17:00.750 --> 00:17:02.590
that that allows
the Gradle plug-in

00:17:02.590 --> 00:17:04.859
to do certain optimizations.

00:17:04.859 --> 00:17:06.369
They're not
technically necessary,

00:17:06.369 --> 00:17:08.602
but we're really looking
for latency avoidance,

00:17:08.602 --> 00:17:11.060
and so if I've noticed that
you've only touched Java files,

00:17:11.060 --> 00:17:12.768
we don't have to touch
the resource task.

00:17:12.768 --> 00:17:15.260
Or similarly, if you've
only touched the Java class.

00:17:15.260 --> 00:17:16.528
Anything you want to add?

00:17:16.528 --> 00:17:18.819
XAVIER DUCROCHET: So right
now we only support hot swap

00:17:18.819 --> 00:17:19.610
in the main module.

00:17:19.610 --> 00:17:21.250
We'll add that to
the sub-module.

00:17:21.250 --> 00:17:22.260
But one of the
optimizations that we do

00:17:22.260 --> 00:17:24.190
is, if you change the
code in the main module

00:17:24.190 --> 00:17:25.565
and you just ask
Gradle to build,

00:17:25.565 --> 00:17:27.273
it doesn't know anything
about the state.

00:17:27.273 --> 00:17:29.370
It doesn't monitor the
file change at the moment.

00:17:29.370 --> 00:17:31.700
And so it's going to try to
build all your submodules,

00:17:31.700 --> 00:17:33.520
which will be up to
date, but because it

00:17:33.520 --> 00:17:35.520
doesn't know anything it
has to go and make sure

00:17:35.520 --> 00:17:36.978
that all the files
haven't changed.

00:17:36.978 --> 00:17:38.540
And if you have
dozens of modules,

00:17:38.540 --> 00:17:39.950
that can take a lot of time.

00:17:39.950 --> 00:17:41.080
Now, if you actually
run it, you will

00:17:41.080 --> 00:17:42.900
see up-to-date, up-to-date,
up-to-date, up-to-date

00:17:42.900 --> 00:17:44.399
and nothing change,
and that's good.

00:17:44.399 --> 00:17:46.370
But it can still
take some time if you

00:17:46.370 --> 00:17:48.995
don't have an SSD, if you
have slow IO, whatever.

00:17:48.995 --> 00:17:50.870
You know, that's going
to take a lot of time.

00:17:50.870 --> 00:17:52.450
And so, Studio knows.

00:17:52.450 --> 00:17:54.680
Studio tells you, hey, only
the main module changed,

00:17:54.680 --> 00:17:57.500
and then we just, same thing,
add the Gradle plug-in.

00:17:57.500 --> 00:17:59.952
We will just stop
asking to build those,

00:17:59.952 --> 00:18:01.660
and then we won't even
do the up to date,

00:18:01.660 --> 00:18:05.140
and then it's much, much faster.

00:18:05.140 --> 00:18:07.710
So this is what happens once
you get the actual file.

00:18:07.710 --> 00:18:09.900
So here you have Studio on
the left and then Gradle,

00:18:09.900 --> 00:18:11.550
and then on the right, you
have your app, it's running,

00:18:11.550 --> 00:18:13.258
and it has a server
and it has that class

00:18:13.258 --> 00:18:14.440
that we just touched.

00:18:14.440 --> 00:18:18.596
So we call Gradle, and then
here, it's a custom task.

00:18:18.596 --> 00:18:19.970
It's not a regular
assemble debug

00:18:19.970 --> 00:18:21.530
that you would normally use.

00:18:21.530 --> 00:18:23.780
And we created a dex
file that contains

00:18:23.780 --> 00:18:25.069
only the classes that change.

00:18:25.069 --> 00:18:26.860
It could be one, it
could be two, depending

00:18:26.860 --> 00:18:28.200
on how many you change.

00:18:28.200 --> 00:18:31.390
Then Studio grabs that,
sends that to the app server,

00:18:31.390 --> 00:18:34.390
which gets ready to use the
custom classloader to just load

00:18:34.390 --> 00:18:34.890
it.

00:18:34.890 --> 00:18:37.223
Now, the thing that's important
is that when we load it,

00:18:37.223 --> 00:18:42.450
we don't actually load the same
class that you actually wrote.

00:18:42.450 --> 00:18:44.170
The classes there, we
can't replace them.

00:18:44.170 --> 00:18:46.120
So what we load instead
is a special version,

00:18:46.120 --> 00:18:48.360
and that special version
is created by Gradle itself

00:18:48.360 --> 00:18:50.040
during the bytecode
transformation,

00:18:50.040 --> 00:18:51.910
and it's just an override of it.

00:18:51.910 --> 00:18:57.370
And then the app server will
just basically modify the class

00:18:57.370 --> 00:19:00.240
here on the left to
delegate every method

00:19:00.240 --> 00:19:02.330
call to the override.

00:19:02.330 --> 00:19:04.604
And that's because that
version of the class

00:19:04.604 --> 00:19:06.770
is a special version, as I
showed in the first graph

00:19:06.770 --> 00:19:08.780
where we had that
bytecode instrumentation.

00:19:08.780 --> 00:19:10.660
We go and we add that
level of indirection,

00:19:10.660 --> 00:19:12.560
so here the app
server just makes

00:19:12.560 --> 00:19:15.530
the connection between the
original class saying, hey,

00:19:15.530 --> 00:19:18.240
now when we call that
method just go and call

00:19:18.240 --> 00:19:21.390
that version instead.

00:19:21.390 --> 00:19:24.410
TOR NORBYE: So for
resource changes,

00:19:24.410 --> 00:19:27.360
we're currently relying on
sending all the resources.

00:19:27.360 --> 00:19:29.312
So we have to run APT.

00:19:29.312 --> 00:19:30.770
So if you have an
app that's really

00:19:30.770 --> 00:19:33.270
large with lots of resources,
it's not going to be instant.

00:19:33.270 --> 00:19:36.780
So the instant run feature is
really after the hot-swap case.

00:19:36.780 --> 00:19:39.667
But there is a
incremental APT under way

00:19:39.667 --> 00:19:41.500
that's going to really
help with this a lot.

00:19:41.500 --> 00:19:42.890
And we have some
short term tricks

00:19:42.890 --> 00:19:44.598
we're going to do,
too, to send a smaller

00:19:44.598 --> 00:19:46.810
portion of the resource file.

00:19:46.810 --> 00:19:48.460
And once we send
it across the wire,

00:19:48.460 --> 00:19:51.640
we then use reflection
hacks-- and I

00:19:51.640 --> 00:19:54.460
think there's no prettier way
of referring to it-- to actually

00:19:54.460 --> 00:19:57.200
make that running app
restart activity and apply

00:19:57.200 --> 00:19:58.852
the changes you made.

00:19:58.852 --> 00:20:00.810
There are some limitations
to resource changes.

00:20:00.810 --> 00:20:03.271
If you change for example the
app name or any resource that

00:20:03.271 --> 00:20:04.770
can be referenced
from the manifest,

00:20:04.770 --> 00:20:07.510
we know we have to
trigger a full rebuild.

00:20:07.510 --> 00:20:10.440
And the other thing is that
until the preview build,

00:20:10.440 --> 00:20:12.330
we had some special
optimizations where the R

00:20:12.330 --> 00:20:14.620
class was treated specially.

00:20:14.620 --> 00:20:17.696
So we would exclude
field checks for them.

00:20:17.696 --> 00:20:19.820
But we saw some crashes,
so to be on the safe side,

00:20:19.820 --> 00:20:21.450
if you have any ID
changes as well.

00:20:21.450 --> 00:20:23.840
So if you drop in a new
button in the layout editor,

00:20:23.840 --> 00:20:25.810
that's going to put an
ID for you by default.

00:20:25.810 --> 00:20:27.855
Or even if you have +
IDs, and you reorder them,

00:20:27.855 --> 00:20:29.480
that will change the
values in R class.

00:20:29.480 --> 00:20:34.080
So those things right now
would trigger a restart.

00:20:34.080 --> 00:20:35.960
And so for cold swap,
this is something that

00:20:35.960 --> 00:20:37.360
is not in the preview build.

00:20:37.360 --> 00:20:38.840
We'll demo it shortly.

00:20:38.840 --> 00:20:40.840
But that's when you have
an incompatible change.

00:20:40.840 --> 00:20:42.530
So you've added a
field, which currently

00:20:42.530 --> 00:20:44.890
is an incompatible change.

00:20:44.890 --> 00:20:47.140
And we're working
on basically making

00:20:47.140 --> 00:20:51.270
that be not a full rebuild,
which it is right now.

00:20:51.270 --> 00:20:52.880
XAVIER DUCROCHET:
OK, so there's a lot

00:20:52.880 --> 00:20:54.140
of things happening
under the hood.

00:20:54.140 --> 00:20:56.348
Bytecode instrumentation,
replacing class on the fly.

00:20:56.348 --> 00:20:59.010
But we wanted it to be as
easy for you as possible.

00:20:59.010 --> 00:21:03.330
The user interface for Instant
Run is just like the Run button

00:21:03.330 --> 00:21:04.640
that you've used before.

00:21:04.640 --> 00:21:07.030
So the goal is that
Studio knows whether we

00:21:07.030 --> 00:21:09.930
can do Instant Run, whether we
can do cold swap, warm swap,

00:21:09.930 --> 00:21:10.880
hot-swap, anything.

00:21:10.880 --> 00:21:13.134
You don't have to
think about it.

00:21:13.134 --> 00:21:14.550
If there's a little
lightning bolt

00:21:14.550 --> 00:21:17.080
right next to the
Run button, then you

00:21:17.080 --> 00:21:19.405
know that you'll
have Instant Run.

00:21:19.405 --> 00:21:22.865
But just keep pressing that
button or using the shortcut,

00:21:22.865 --> 00:21:24.150
and it will just happen.

00:21:24.150 --> 00:21:27.680
And hopefully, the
best scenario will

00:21:27.680 --> 00:21:31.080
happen without you
having to do anything.

00:21:31.080 --> 00:21:34.090
Now, because we talk
directly to the app,

00:21:34.090 --> 00:21:36.730
and we send stuff
on the fly, you

00:21:36.730 --> 00:21:39.250
could be in the weird situation
where we replace some code,

00:21:39.250 --> 00:21:42.214
but because the state can be
weird, there is a stop button.

00:21:42.214 --> 00:21:43.880
So if you do that,
it will kill the app,

00:21:43.880 --> 00:21:45.338
and then on the
next run it will do

00:21:45.338 --> 00:21:48.950
a regular, hopefully
cold swap at some point,

00:21:48.950 --> 00:21:50.764
but for now a full reboot.

00:21:50.764 --> 00:21:53.180
And then you have a shortcut
also to restart the activity.

00:21:53.180 --> 00:21:54.930
There's some cases
where we replace stuff,

00:21:54.930 --> 00:21:58.516
but we can't actually apply it,
so we have a shortcut for that.

00:21:58.516 --> 00:21:59.640
TOR NORBYE: All right demo.

00:21:59.640 --> 00:22:02.790
Can we get stage two.

00:22:02.790 --> 00:22:04.550
All right, so here
is an old project.

00:22:04.550 --> 00:22:08.800
You can see it's using the
ancient Gradle plugin 1.5.

00:22:08.800 --> 00:22:11.510
And if you bring up
the preference panel,

00:22:11.510 --> 00:22:13.300
and you go to the
Instant Run settings,

00:22:13.300 --> 00:22:14.300
you can see it's
telling me right

00:22:14.300 --> 00:22:16.091
now that I don't have
Instant Run because I

00:22:16.091 --> 00:22:17.570
need to update my project.

00:22:17.570 --> 00:22:20.080
What that will do is it
will update to Gradle 2.0,

00:22:20.080 --> 00:22:23.170
but it will also give you
build tools 23.0.2 which

00:22:23.170 --> 00:22:25.610
isn't necessary, but really
it's going to be much faster.

00:22:25.610 --> 00:22:26.630
XAVIER DUCROCHET: Yeah,
you should use them anyway.

00:22:26.630 --> 00:22:28.147
TOR NORBYE: And
Gradle plug-in 2.8.

00:22:28.147 --> 00:22:29.730
All right, so here
I'm going to switch

00:22:29.730 --> 00:22:33.290
to a different project, a Topeka
sample app, which I've already

00:22:33.290 --> 00:22:35.280
run on the device.

00:22:35.280 --> 00:22:38.150
So let me show you some
of the Instant Run stuff.

00:22:38.150 --> 00:22:39.650
The first thing
we can do here is,

00:22:39.650 --> 00:22:40.858
we can change some resources.

00:22:40.858 --> 00:22:42.690
So see it says
sign in at the top?

00:22:42.690 --> 00:22:44.739
Let me open up the
translations editor

00:22:44.739 --> 00:22:46.530
and find the sign-in
string, and we'll just

00:22:46.530 --> 00:22:51.960
change it to welcome, sign in.

00:22:51.960 --> 00:22:54.040
And if I hit the
Instant Run button,

00:22:54.040 --> 00:22:57.060
it now performs a
incremental build,

00:22:57.060 --> 00:22:59.390
it grabs the whole resource
file, and it sends it over.

00:22:59.390 --> 00:23:00.598
And it restarts the activity.

00:23:00.598 --> 00:23:03.300
You can see it says,
welcome, sign in, over here.

00:23:03.300 --> 00:23:06.480
If I switch to the theme editor,
I can make non string changes,

00:23:06.480 --> 00:23:06.980
too.

00:23:06.980 --> 00:23:09.860
So let's for example go and
change the primary color

00:23:09.860 --> 00:23:13.185
to material red, material pink.

00:23:13.185 --> 00:23:14.980
We'll do red.

00:23:14.980 --> 00:23:16.920
And we can also change
the status color

00:23:16.920 --> 00:23:21.390
for the device, which I thought
was-- now I can't see it.

00:23:21.390 --> 00:23:23.510
There it is.

00:23:23.510 --> 00:23:26.360
So we'll switch that
to let's say this one.

00:23:26.360 --> 00:23:30.360
And again, if I press Instant
Run, it packages the resources,

00:23:30.360 --> 00:23:34.270
the app is still running,
and it applies those changes.

00:23:34.270 --> 00:23:37.790
So let's make some code changes.

00:23:37.790 --> 00:23:40.760
So if you look at this
grid of icons over here,

00:23:40.760 --> 00:23:42.170
the number of icons is dynamic.

00:23:42.170 --> 00:23:44.327
It is based on the size
of the avatar icons

00:23:44.327 --> 00:23:46.910
and the size of the screen, and
it's done by this method right

00:23:46.910 --> 00:23:49.690
here, calculate span count.

00:23:49.690 --> 00:23:51.660
I can just go and
change this code.

00:23:51.660 --> 00:23:53.990
Let's say, just hard
code it to three for now.

00:23:53.990 --> 00:24:00.420
And if I press Instant Run, you
can see that nothing happens.

00:24:00.420 --> 00:24:02.640
And you can see that it
was saying in the toast,

00:24:02.640 --> 00:24:05.212
we've made this change
for you, but you may

00:24:05.212 --> 00:24:06.420
want to restart the activity.

00:24:06.420 --> 00:24:09.199
And that's because this
code is only run on create.

00:24:09.199 --> 00:24:10.740
So just because I've
hot-swaped, that

00:24:10.740 --> 00:24:13.501
doesn't really make the
change visually appear.

00:24:13.501 --> 00:24:15.125
But there's also a
bubble we're showing

00:24:15.125 --> 00:24:16.958
in the bottom left
corner here, saying, hey,

00:24:16.958 --> 00:24:18.330
you haven't restarted activity.

00:24:18.330 --> 00:24:19.170
Would you like to do that?

00:24:19.170 --> 00:24:21.200
It's telling you what the
shortcut is for doing it.

00:24:21.200 --> 00:24:22.699
We can also configure
it by options.

00:24:25.550 --> 00:24:28.312
First of all, I'll
turn the option on.

00:24:28.312 --> 00:24:30.270
But I'll also just apply
it manually right now,

00:24:30.270 --> 00:24:33.370
Control, Shift, R. You can
see we have three columns.

00:24:33.370 --> 00:24:36.620
And now if I switch it to four,
for example and press Control,

00:24:36.620 --> 00:24:39.800
Run, you can see
it's nearly instant.

00:24:39.800 --> 00:24:41.110
Right, four columns.

00:24:41.110 --> 00:24:44.440
So that's basically the
hot-swap case, and the warm case

00:24:44.440 --> 00:24:45.490
with the resources.

00:24:45.490 --> 00:24:46.990
Now I'm going to
show you cold swap.

00:24:46.990 --> 00:24:49.010
So cold- swap is not
actually enabled,

00:24:49.010 --> 00:24:51.440
and the reason for
that is primarily

00:24:51.440 --> 00:24:53.060
that it's really, really buggy.

00:24:53.060 --> 00:24:55.990
So you can see I have an
option here called demo only,

00:24:55.990 --> 00:24:59.047
and that's because this is
not available in your build.

00:24:59.047 --> 00:25:01.380
But I'm going to show you
what it does when we hopefully

00:25:01.380 --> 00:25:02.900
get it working.

00:25:02.900 --> 00:25:07.294
So let's put the real code back
in, and let me do some method

00:25:07.294 --> 00:25:07.960
extraction here.

00:25:07.960 --> 00:25:12.340
So I'm going to actually
extract this whole line.

00:25:12.340 --> 00:25:13.780
We'll call it get avatar size.

00:25:13.780 --> 00:25:15.355
Oh, and the IDE
noticed, hey, this

00:25:15.355 --> 00:25:16.480
is a pretty generic method.

00:25:16.480 --> 00:25:18.340
Let me try to
generalize that for you.

00:25:18.340 --> 00:25:20.760
So now it's basically turned
it into something different,

00:25:20.760 --> 00:25:23.400
which I'll call, get dimension.

00:25:23.400 --> 00:25:25.730
And then we'll extract
this expression over here

00:25:25.730 --> 00:25:30.470
to calculate columns.

00:25:30.470 --> 00:25:32.580
So now we have some
structural changes.

00:25:32.580 --> 00:25:38.150
And because I turned on
cold swap, if I hit run now,

00:25:38.150 --> 00:25:41.797
it's going to kill the
app, and restart it.

00:25:41.797 --> 00:25:43.130
But it's not doing a full build.

00:25:43.130 --> 00:25:44.610
You can see it's the
little bubble saying, hey,

00:25:44.610 --> 00:25:45.500
method added.

00:25:45.500 --> 00:25:47.080
We couldn't really restart it.

00:25:47.080 --> 00:25:50.200
But now the app is
back and running,

00:25:50.200 --> 00:25:53.140
and it's running the new code,
although it's the correct code,

00:25:53.140 --> 00:25:55.348
so let me change it to prove
that this new method can

00:25:55.348 --> 00:25:57.350
do the right thing.

00:25:57.350 --> 00:25:59.400
So Instant Run, two columns,
from the new method.

00:25:59.400 --> 00:26:01.890
So that's cold- swap
which hopefully we'll

00:26:01.890 --> 00:26:03.580
get working soon.

00:26:03.580 --> 00:26:06.590
The last thing I want to
show you is data binding.

00:26:06.590 --> 00:26:08.800
So data binding, also broke
for the preview build,

00:26:08.800 --> 00:26:12.280
we have it working in
the [INAUDIBLE] again.

00:26:12.280 --> 00:26:15.250
Actually, let me just
run it first of all.

00:26:15.250 --> 00:26:18.110
So this is a sample app I
found in the data binding code

00:26:18.110 --> 00:26:20.230
repository.

00:26:20.230 --> 00:26:23.900
I don't know what the app
means, but it has some buying

00:26:23.900 --> 00:26:26.990
expressions I can show you.

00:26:26.990 --> 00:26:31.569
So while that's starting,
let me show the stuff

00:26:31.569 --> 00:26:32.610
we have for data binding.

00:26:32.610 --> 00:26:34.443
This is not integrated
in the preview build,

00:26:34.443 --> 00:26:36.464
but we've finally,
you could say,

00:26:36.464 --> 00:26:38.630
added code completion for
expression language stuff.

00:26:38.630 --> 00:26:42.900
So here, not only can I
navigate between symbols

00:26:42.900 --> 00:26:45.690
and into methods
and data objects.

00:26:45.690 --> 00:26:47.822
We also have full
code completion here

00:26:47.822 --> 00:26:49.530
on all the attributes
and all that stuff.

00:26:49.530 --> 00:26:52.160
So that's nice.

00:26:52.160 --> 00:26:53.980
So as you can see
in this app here,

00:26:53.980 --> 00:26:56.750
we have uppercase characters
in some of these name cards.

00:26:56.750 --> 00:27:02.580
If I were to change this to
lower case, and do Instant Run,

00:27:02.580 --> 00:27:06.572
you can see that, hopefully,
soon it applied the change,

00:27:06.572 --> 00:27:08.030
and you can see
it's now lowercase.

00:27:08.030 --> 00:27:09.790
So data binding is working
too, and that will hopefully

00:27:09.790 --> 00:27:12.450
make data binding and Instant
Run work really well together.

00:27:12.450 --> 00:27:15.234
And that's it for the demo.

00:27:15.234 --> 00:27:18.601
[APPLAUSE]

00:27:23.411 --> 00:27:25.420
JAMAL EASON: All right,
so Android emulator.

00:27:25.420 --> 00:27:27.440
So we talked about
the Android emulator

00:27:27.440 --> 00:27:29.490
at the keynote
yesterday, and we really

00:27:29.490 --> 00:27:31.650
wanted to invest time and
effort into the product

00:27:31.650 --> 00:27:34.200
because we knew, we use it
all the time as a developer,

00:27:34.200 --> 00:27:37.880
but it hasn't been as great as
we wanted it to be as a team.

00:27:37.880 --> 00:27:40.540
So the two things we worked
on, first is performance,

00:27:40.540 --> 00:27:42.450
and the second
thing is usability.

00:27:42.450 --> 00:27:44.574
And we think of performance
in three different ways

00:27:44.574 --> 00:27:49.280
for the emulator, it's
around CPU, GPU and I/O.

00:27:49.280 --> 00:27:53.509
So for CPU, what we added to the
emulator is multi-core support.

00:27:53.509 --> 00:27:55.550
What it allows you to do
is that you can actually

00:27:55.550 --> 00:27:58.410
process your apps faster,
install them faster, and get

00:27:58.410 --> 00:28:01.800
a more performing
experience in the emulator.

00:28:01.800 --> 00:28:05.470
For GPU, we've had a
strong offering so far,

00:28:05.470 --> 00:28:07.690
but we added additional
GL calls so you actually

00:28:07.690 --> 00:28:10.270
can support more
GL applications,

00:28:10.270 --> 00:28:12.960
and get a more performing
experience while using open

00:28:12.960 --> 00:28:14.770
GL ES.

00:28:14.770 --> 00:28:18.160
And the third column we
added is I/O. So Xav touched

00:28:18.160 --> 00:28:21.630
on ADV push speeds, but we
also looked at the I/O speed

00:28:21.630 --> 00:28:23.790
on the actual virtual device.

00:28:23.790 --> 00:28:25.850
In itself it's like a
little mini hard drive.

00:28:25.850 --> 00:28:28.050
We actually improved
that very dramatically

00:28:28.050 --> 00:28:30.960
in order to improve things like
install time and processing

00:28:30.960 --> 00:28:32.180
time.

00:28:32.180 --> 00:28:33.960
So let's look at some
data to highlight

00:28:33.960 --> 00:28:35.342
that particular data point.

00:28:35.342 --> 00:28:37.050
And so we looked at
the Google Play Store

00:28:37.050 --> 00:28:38.250
and tried to find
the biggest app

00:28:38.250 --> 00:28:40.550
possible to kind of highlight
this particular scenario.

00:28:40.550 --> 00:28:41.250
We found one.

00:28:41.250 --> 00:28:42.709
It's about 45 megabytes.

00:28:42.709 --> 00:28:43.500
It's quite extreme.

00:28:43.500 --> 00:28:45.690
Most developers don't
have apps this big,

00:28:45.690 --> 00:28:47.960
but lets us use
this as an example.

00:28:47.960 --> 00:28:50.600
So in the past, the
emulator 1.0 would take just

00:28:50.600 --> 00:28:54.710
under 300 seconds to install
and push that application.

00:28:54.710 --> 00:28:57.130
Most of the time,
as indicated by Xav,

00:28:57.130 --> 00:29:00.040
is actually on the install part.

00:29:00.040 --> 00:29:02.530
In a few seconds, you can
push it across the wire,

00:29:02.530 --> 00:29:04.940
but it takes a long
time to process.

00:29:04.940 --> 00:29:06.860
That same application
on the Nexus 6

00:29:06.860 --> 00:29:09.030
was just under 150 seconds.

00:29:09.030 --> 00:29:09.635
That's OK.

00:29:09.635 --> 00:29:11.390
But we thought we
could do better.

00:29:11.390 --> 00:29:14.570
So they Android
studio emulator 2.0,

00:29:14.570 --> 00:29:18.842
we're now just under 45
seconds for that same push.

00:29:18.842 --> 00:29:26.640
[APPLAUSE]

00:29:26.640 --> 00:29:27.992
So usability.

00:29:27.992 --> 00:29:30.200
So again, the emulator has
been around for some time.

00:29:30.200 --> 00:29:32.420
We've had a lot of great
features, but most of them

00:29:32.420 --> 00:29:33.840
have been under command line.

00:29:33.840 --> 00:29:37.100
Not very easy to use,
not very intuitive.

00:29:37.100 --> 00:29:39.290
Again, if you're trying to
develop your application

00:29:39.290 --> 00:29:40.831
and try out different
scenarios, it's

00:29:40.831 --> 00:29:43.680
very difficult to remember
some keyboard shortcut-- we

00:29:43.680 --> 00:29:47.170
have shortcuts now, but remember
some archaic ADB push command,

00:29:47.170 --> 00:29:49.260
or some command just
to get your app running

00:29:49.260 --> 00:29:50.750
or to try out some scenario.

00:29:50.750 --> 00:29:54.080
So we decided to invest on
a new UI to address this.

00:29:54.080 --> 00:29:56.650
So let's jump to
stage one demo please.

00:29:59.990 --> 00:30:00.570
OK, perfect.

00:30:00.570 --> 00:30:03.810
So this is the new UI
for the Android emulator.

00:30:03.810 --> 00:30:07.050
We showed a little bit of
this at the keynote yesterday.

00:30:07.050 --> 00:30:08.900
So of course, here,
let me just open up

00:30:08.900 --> 00:30:11.657
Google Maps here in my recents.

00:30:14.960 --> 00:30:18.890
All right, so as before, you
can use the emulator to type

00:30:18.890 --> 00:30:23.020
in directly into the
UI for quickly typing.

00:30:23.020 --> 00:30:24.140
So let's go to New York.

00:30:24.140 --> 00:30:25.820
And again, with open
GL we can quickly

00:30:25.820 --> 00:30:29.600
render this really quickly with
the UI to render all the maps.

00:30:29.600 --> 00:30:32.210
But in addition to just allowing
you to enter in GPS points,

00:30:32.210 --> 00:30:35.260
we've also allowed you
to import KML files.

00:30:35.260 --> 00:30:38.380
So here in the right hand side,
I have a table of GPS points,

00:30:38.380 --> 00:30:40.510
and this right now
is a path I want

00:30:40.510 --> 00:30:42.380
to test out for my application.

00:30:42.380 --> 00:30:45.000
So let me turn on the GPS
location here on the emulator,

00:30:45.000 --> 00:30:46.950
pressing the blue button here.

00:30:46.950 --> 00:30:48.700
Let me speed this up
to two x for the demo

00:30:48.700 --> 00:30:50.280
here, and press play.

00:30:50.280 --> 00:30:53.790
And what's happening now is
that I'm now pumping in points

00:30:53.790 --> 00:30:55.267
to my emulator.

00:30:55.267 --> 00:30:56.600
This is actually the Googleplex.

00:30:56.600 --> 00:30:58.850
And you can kind of move
through the emulator experience

00:30:58.850 --> 00:31:01.141
and kind of repeat that
process for applications if you

00:31:01.141 --> 00:31:03.836
use location in your emulation.

00:31:03.836 --> 00:31:06.080
Cool.

00:31:06.080 --> 00:31:06.920
All right.

00:31:06.920 --> 00:31:12.400
All right, so moving on to the
next tab is around cellular.

00:31:12.400 --> 00:31:14.400
Now, some developers
have asked about, hey,

00:31:14.400 --> 00:31:16.630
how do I have some
way to control

00:31:16.630 --> 00:31:17.760
the speed of my network.

00:31:17.760 --> 00:31:24.750
So let me just kind of
zoom into the top here, OK.

00:31:24.750 --> 00:31:26.550
So you can control
here the network type.

00:31:26.550 --> 00:31:27.642
I want to change it to 2G.

00:31:27.642 --> 00:31:29.225
If you notice here
under no vacations,

00:31:29.225 --> 00:31:31.850
it's currently
saying a 3G Android.

00:31:31.850 --> 00:31:33.900
Changing this to Edge
will change this to 2G.

00:31:33.900 --> 00:31:35.840
We can change that
to E for edge.

00:31:35.840 --> 00:31:38.474
Let me pull that back to
full for this demonstration.

00:31:38.474 --> 00:31:40.140
Or if I want to change
things like, hey,

00:31:40.140 --> 00:31:42.814
what happens if I'm
roaming, I can quickly

00:31:42.814 --> 00:31:44.230
change that on my
data connection.

00:31:44.230 --> 00:31:47.414
That changes from an E
to an R for that icon.

00:31:47.414 --> 00:31:48.830
Or if you want to
see what happens

00:31:48.830 --> 00:31:51.390
with an application that has
no service or the SIM card's

00:31:51.390 --> 00:31:54.950
out, how do I simulate
that situation.

00:31:54.950 --> 00:31:57.590
And here I can simulate that
on the cellular tab as well.

00:31:57.590 --> 00:31:59.156
Again, this is just
to help you out

00:31:59.156 --> 00:32:01.030
to figure out your
different data connections

00:32:01.030 --> 00:32:03.410
as you're testing
your application.

00:32:03.410 --> 00:32:09.660
[APPLAUSE]

00:32:09.660 --> 00:32:11.675
OK, so moving on to battery.

00:32:11.675 --> 00:32:13.800
So battery, here-- let me
just open up battery here

00:32:13.800 --> 00:32:14.710
in this UI.

00:32:14.710 --> 00:32:16.000
Great.

00:32:16.000 --> 00:32:18.680
So as you can see here, I can
move the charge level here

00:32:18.680 --> 00:32:19.430
with the UI.

00:32:19.430 --> 00:32:20.880
That's straightforward.

00:32:20.880 --> 00:32:22.950
I can say, hey, I want
it to be charging,

00:32:22.950 --> 00:32:25.540
can be in AC, or not charging,
so I can change the state.

00:32:25.540 --> 00:32:26.890
That's moves it to not charging.

00:32:26.890 --> 00:32:28.390
So straightforward
there, just a way

00:32:28.390 --> 00:32:30.620
for you to toggle that if
your app uses any battery

00:32:30.620 --> 00:32:32.800
kind of configurations,
we now have a UI for you

00:32:32.800 --> 00:32:36.760
to manage that as well.

00:32:36.760 --> 00:32:37.320
Great.

00:32:37.320 --> 00:32:40.080
All right, so now
moving on to phone.

00:32:40.080 --> 00:32:42.440
So at the keynote
we talked about,

00:32:42.440 --> 00:32:44.980
you can actually receive
phone calls from the emulator.

00:32:44.980 --> 00:32:46.490
That's what your app does.

00:32:46.490 --> 00:32:48.164
But we also can
send SMS messages

00:32:48.164 --> 00:32:49.830
if that's what you
need to test as well.

00:32:49.830 --> 00:32:51.990
So in this case, I sent
myself a text saying, hey,

00:32:51.990 --> 00:32:53.290
don't forget the marshmallows.

00:32:53.290 --> 00:32:55.150
That's great.

00:32:55.150 --> 00:32:56.350
We'll come back to that.

00:32:56.350 --> 00:32:59.210
So let me go back to sensors.

00:32:59.210 --> 00:33:02.591
So at Google ILS past year,
we talked about fingerprint.

00:33:02.591 --> 00:33:04.590
And fingerprint is a way
for you to authenticate

00:33:04.590 --> 00:33:07.714
your application either
for payment or for security

00:33:07.714 --> 00:33:08.380
for your device.

00:33:08.380 --> 00:33:11.140
And we've added that feature
into the emulator itself.

00:33:11.140 --> 00:33:14.850
So if you go under settings,
we have fingerprint here,

00:33:14.850 --> 00:33:15.870
under Security.

00:33:15.870 --> 00:33:16.690
Great.

00:33:16.690 --> 00:33:17.550
Fingerprint.

00:33:17.550 --> 00:33:19.619
And here we can ask you
to add a fingerprint

00:33:19.619 --> 00:33:20.535
to unlock your device.

00:33:20.535 --> 00:33:23.010
You can click Continue here.

00:33:23.010 --> 00:33:26.750
And use a pin to
super secure for once.

00:33:26.750 --> 00:33:27.600
Great.

00:33:27.600 --> 00:33:30.690
All right, and then we have
this fingerprint tab here.

00:33:30.690 --> 00:33:33.040
And what this
allows you to do, it

00:33:33.040 --> 00:33:38.120
has 10 input points for
10 fingers on your hands.

00:33:38.120 --> 00:33:40.866
And let's say I wanted to use
my finger one, touch the sensor,

00:33:40.866 --> 00:33:42.522
boom it's authenticated.

00:33:42.522 --> 00:33:44.480
Now you've added fingerprints
into your device,

00:33:44.480 --> 00:33:46.310
and now you can use this
for testing for fingerprint

00:33:46.310 --> 00:33:47.226
for your applications.

00:33:54.060 --> 00:33:54.650
OK.

00:33:54.650 --> 00:33:55.540
Great.

00:33:55.540 --> 00:33:57.220
So a last few things here.

00:33:57.220 --> 00:33:59.729
So on settings, if
you don't like dark,

00:33:59.729 --> 00:34:02.020
we have the ability for you
to switch to a light theme.

00:34:02.020 --> 00:34:05.430
If that's your option
here, so we go to lights.

00:34:05.430 --> 00:34:06.990
That the light theme
of the emulator.

00:34:06.990 --> 00:34:09.260
So you can see how that works.

00:34:09.260 --> 00:34:13.889
My personal favorite is dark, so
I'll put it back to dark here.

00:34:13.889 --> 00:34:14.739
All right.

00:34:14.739 --> 00:34:17.699
And then we're just going to
close this extended controls

00:34:17.699 --> 00:34:19.010
here.

00:34:19.010 --> 00:34:23.650
So we talked about the
drag and drop capability.

00:34:23.650 --> 00:34:26.920
In addition to being able to
install APKs drag and drop,

00:34:26.920 --> 00:34:29.316
we also allow you to
install media files.

00:34:29.316 --> 00:34:30.440
So let me go to my SD card.

00:34:30.440 --> 00:34:31.731
And let's go to download, here.

00:34:31.731 --> 00:34:34.020
Let me rotate, because
rotate's also available here,

00:34:34.020 --> 00:34:35.139
which is great.

00:34:35.139 --> 00:34:37.370
So I can rotate
that very easily.

00:34:37.370 --> 00:34:40.420
Let me resize this so you
can kind of see this together

00:34:40.420 --> 00:34:41.179
on one screen.

00:34:41.179 --> 00:34:42.699
OK.

00:34:42.699 --> 00:34:45.864
So I have a picture here I
wanted to get on this device.

00:34:45.864 --> 00:34:50.159
So I can simply drag this
on to my emulator window,

00:34:50.159 --> 00:34:51.260
and there you go.

00:34:51.260 --> 00:34:52.678
So this is my picture.

00:34:52.678 --> 00:34:59.890
[APPLAUSE]

00:34:59.890 --> 00:35:00.710
There.

00:35:00.710 --> 00:35:02.870
OK.

00:35:02.870 --> 00:35:05.280
All right.

00:35:05.280 --> 00:35:08.350
So then let's go
back to the SMS here.

00:35:08.350 --> 00:35:10.957
So I sent myself
that text message.

00:35:10.957 --> 00:35:12.540
So let me just rotate
this back again.

00:35:12.540 --> 00:35:14.010
So let's back to this.

00:35:14.010 --> 00:35:15.280
All right.

00:35:15.280 --> 00:35:17.370
And let's go to that message.

00:35:17.370 --> 00:35:18.840
Here we go.

00:35:18.840 --> 00:35:21.647
Right, so there is that
text I sent to myself.

00:35:21.647 --> 00:35:23.730
All right, let's make this
a little bigger here so

00:35:23.730 --> 00:35:24.960
everybody can see this.

00:35:24.960 --> 00:35:25.460
Great.

00:35:25.460 --> 00:35:27.780
You can resize up at the corner.

00:35:27.780 --> 00:35:30.610
And again, with a keyboard,
I can just type messages here

00:35:30.610 --> 00:35:31.670
on the keyboard.

00:35:31.670 --> 00:35:35.350
And so, then, lastly,
I will say thanks

00:35:35.350 --> 00:35:43.970
for coming to Android
Dev Conference.

00:35:43.970 --> 00:35:44.470
Cool.

00:35:44.470 --> 00:35:45.800
Spell check's also
included here.

00:35:45.800 --> 00:35:46.300
Great.

00:35:46.300 --> 00:35:46.900
Conference.

00:35:46.900 --> 00:35:48.460
And send.

00:35:48.460 --> 00:35:49.210
That's it.

00:35:49.210 --> 00:35:50.044
Great.

00:35:50.044 --> 00:35:54.760
[APPLAUSE]

00:35:54.760 --> 00:35:56.548
Let's switch back
to slides, please.

00:36:01.834 --> 00:36:03.750
So we talked about a lot
of different features

00:36:03.750 --> 00:36:06.330
here at this session.

00:36:06.330 --> 00:36:08.830
And so a few things are
going to be available now.

00:36:08.830 --> 00:36:11.520
So things like the dx
merger, Instant Run

00:36:11.520 --> 00:36:13.262
is available today in
the Canary channel,

00:36:13.262 --> 00:36:15.595
and coming soon we're adding
the shrinker, the emulator,

00:36:15.595 --> 00:36:17.330
and APT.

00:36:17.330 --> 00:36:21.780
Actually, APT is coming
later on in a few weeks.

00:36:21.780 --> 00:36:24.566
And so with that,
I think that's--

00:36:24.566 --> 00:36:26.440
XAVIER DUCROCHET: We
have time for questions.

00:36:26.440 --> 00:36:28.172
JAMAL EASON: We'll
have questions.

00:36:28.172 --> 00:36:28.844
So questions.

00:36:28.844 --> 00:36:30.260
TOR NORBYE: I think
we're supposed

00:36:30.260 --> 00:36:32.470
to tell people to line up.

00:36:32.470 --> 00:36:35.500
There's some mics over there,
so you need to go to the mics

00:36:35.500 --> 00:36:36.730
so that everyone can hear.

00:36:36.730 --> 00:36:41.440
AUDIENCE: Hi, my question is,
can Android emulate Android

00:36:41.440 --> 00:36:45.342
wear connectivity to the
Android phone emulator.

00:36:45.342 --> 00:36:46.050
JAMAL EASON: Yes.

00:36:46.050 --> 00:36:50.720
So if you load up and Android
wear AV with a device,

00:36:50.720 --> 00:36:53.110
we automatically simulate
that Bluetooth connection

00:36:53.110 --> 00:36:55.120
so you can send messages
between your Android

00:36:55.120 --> 00:36:56.380
wear and the device.

00:36:56.380 --> 00:36:57.490
AUDIENCE: Thank you.

00:36:57.490 --> 00:37:00.850
[APPLAUSE]

00:37:00.850 --> 00:37:01.517
JAMAL EASON: Hi.

00:37:01.517 --> 00:37:03.975
AUDIENCE: Do you know if you
can modify the Network setting

00:37:03.975 --> 00:37:06.610
in the emulator so you can
point to a proxy, a local proxy,

00:37:06.610 --> 00:37:08.526
if you wanted to use
like Charles or something

00:37:08.526 --> 00:37:10.905
like that to sniff
network traffic?

00:37:10.905 --> 00:37:13.030
JAMAL EASON: Do you want
to say that one more time?

00:37:13.030 --> 00:37:16.470
AUDIENCE: Point a Wi-Fi
connection on the emulator

00:37:16.470 --> 00:37:19.440
to a local proxy so you
could sniff network traffic,

00:37:19.440 --> 00:37:22.590
like using Charles proxy
or something like that.

00:37:22.590 --> 00:37:23.840
JAMAL EASON: I don't think so.

00:37:23.840 --> 00:37:25.040
Look talk afterwards.

00:37:26.122 --> 00:37:28.080
XAVIER DUCROCHET: We
don't have Wi-Fi emulation

00:37:28.080 --> 00:37:29.630
because there's only
one network connection

00:37:29.630 --> 00:37:30.520
on the emulator right now.

00:37:30.520 --> 00:37:32.395
It's something we're
working on, so right now

00:37:32.395 --> 00:37:34.950
you only have basically
the network connection.

00:37:34.950 --> 00:37:36.615
But it's something
we want to fix.

00:37:36.615 --> 00:37:36.930
AUDIENCE: Cool.

00:37:36.930 --> 00:37:37.400
Thanks.

00:37:37.400 --> 00:37:38.816
TOR NORBYE: Let's
go to this side.

00:37:38.816 --> 00:37:41.580
AUDIENCE: You mentioned better
GPU support in the emulator.

00:37:41.580 --> 00:37:45.710
Which versions of the
S can we play with now?

00:37:45.710 --> 00:37:48.850
JAMAL EASON: So we're
shipping with OpenGL ES 2.0,

00:37:48.850 --> 00:37:51.620
and we're working on 3.0.

00:37:51.620 --> 00:37:53.181
AUDIENCE: Thank you.

00:37:53.181 --> 00:37:55.570
AUDIENCE: Is it possible
to run the Instant

00:37:55.570 --> 00:37:58.520
Run from the command line?

00:37:58.520 --> 00:37:59.150
TOR NORBYE: No.

00:37:59.150 --> 00:38:01.400
The reason for that is that
a lot of stuff we're doing

00:38:01.400 --> 00:38:03.710
is there, in particular
the socket connection,

00:38:03.710 --> 00:38:05.100
is from the IDE,
not from Gradle.

00:38:05.100 --> 00:38:07.580
So the IDE is really
central Instant Run.

00:38:07.580 --> 00:38:12.180
A lot of the tasks you see, like
actually preparing, performing

00:38:12.180 --> 00:38:14.580
the incremental dex
file creation is done.

00:38:14.580 --> 00:38:16.830
Just looking in the Gradle
console to see which task's

00:38:16.830 --> 00:38:19.020
running, plus that
command line flag

00:38:19.020 --> 00:38:20.990
that was in Xavier's slide.

00:38:20.990 --> 00:38:23.450
But no, you need the IDE.

00:38:23.450 --> 00:38:25.030
AUDIENCE: So I have
on more question.

00:38:25.030 --> 00:38:26.071
It's about the emulation.

00:38:26.071 --> 00:38:30.890
Is it possible to
simulate a SIM card?

00:38:30.890 --> 00:38:34.810
JAMAL EASON: We are going
to add the SIM card soon.

00:38:34.810 --> 00:38:36.150
AUDIENCE: Thank you

00:38:36.150 --> 00:38:37.320
XAVIER DUCROCHET: OK

00:38:37.320 --> 00:38:39.430
AUDIENCE: On the NDK
side, when will you

00:38:39.430 --> 00:38:42.040
be adding support for
building static libraries

00:38:42.040 --> 00:38:44.220
and native only libraries
from Android Studio?

00:38:48.600 --> 00:38:50.100
XAVIER DUCROCHET:
I'll talk about it

00:38:50.100 --> 00:38:52.120
a little bit in the
next talk about Gradle,

00:38:52.120 --> 00:38:56.160
but we just added [INAUDIBLE]
support for modules that only

00:38:56.160 --> 00:39:01.380
build native code,
and we also just added

00:39:01.380 --> 00:39:04.350
intermodule dependencies
because the NDK is

00:39:04.350 --> 00:39:08.000
built on the new version,
new APIs on the Gradle side

00:39:08.000 --> 00:39:10.170
to do plugins.

00:39:10.170 --> 00:39:11.630
In the previous
version we didn't

00:39:11.630 --> 00:39:13.670
have intermodule dependencies
because they handle that

00:39:13.670 --> 00:39:14.050
differently.

00:39:14.050 --> 00:39:15.640
So we have intermodule
dependencies,

00:39:15.640 --> 00:39:17.670
and there's an option
to do a static linkage

00:39:17.670 --> 00:39:19.440
between different module.

00:39:19.440 --> 00:39:21.740
So you should be
able to do that now.

00:39:21.740 --> 00:39:22.600
AUDIENCE: OK.

00:39:22.600 --> 00:39:24.409
Thanks.

00:39:24.409 --> 00:39:26.200
AUDIENCE: So the Android
emulator currently

00:39:26.200 --> 00:39:29.620
supports doing
fingerprint by touching,

00:39:29.620 --> 00:39:31.750
but it really only
supports happy path, i.e.

00:39:31.750 --> 00:39:33.920
You either touch
finger one or two,

00:39:33.920 --> 00:39:36.190
and not any of the, like,
finger move too fast,

00:39:36.190 --> 00:39:37.481
or some of the error scenarios.

00:39:37.481 --> 00:39:39.234
Is there are any
plans to add that in?

00:39:39.234 --> 00:39:40.734
JAMAL EASON: Yeah,
so it's not going

00:39:40.734 --> 00:39:42.317
to be in the initial
release for that,

00:39:42.317 --> 00:39:45.630
but we are planning to add more
fingerprint test conditions.

00:39:45.630 --> 00:39:47.740
AUDIENCE: Thank you

00:39:47.740 --> 00:39:52.940
AUDIENCE: Also only emulator,
is there any support

00:39:52.940 --> 00:39:54.580
for other device sensors?

00:39:54.580 --> 00:39:57.060
Accelerometer,
gyroscope, ambient light,

00:39:57.060 --> 00:39:58.500
any of that kind of stuff?

00:39:58.500 --> 00:40:00.855
JAMAL EASON: Yes, so
that in a future release.

00:40:00.855 --> 00:40:03.230
We didn't show that today,
but definitely it's on the run

00:40:03.230 --> 00:40:04.430
up to get that out.

00:40:04.430 --> 00:40:06.490
Yep.

00:40:06.490 --> 00:40:09.177
AUDIENCE: I was wondering,
for the connectivity settings

00:40:09.177 --> 00:40:10.760
on the new emulator,
is it possible to

00:40:10.760 --> 00:40:13.014
simulate partial or
total packet loss?

00:40:15.920 --> 00:40:17.990
JAMAL EASON: So there is
a data drop connection

00:40:17.990 --> 00:40:20.050
that's on the emulator.

00:40:20.050 --> 00:40:20.794
It's OK.

00:40:20.794 --> 00:40:23.210
We're working on creating a
more enhanced version of that.

00:40:23.210 --> 00:40:25.820
But today you can say, I want
to like degregate to 2G network,

00:40:25.820 --> 00:40:30.510
and you can simulate
that situation today.

00:40:30.510 --> 00:40:33.650
AUDIENCE: So you showed a demo
that simulated the location

00:40:33.650 --> 00:40:34.180
changes.

00:40:34.180 --> 00:40:36.810
I'm assuming that's intended
for the geo-fencing API,

00:40:36.810 --> 00:40:38.570
testing that out.

00:40:38.570 --> 00:40:41.790
And you also mentioned
the support for KML files.

00:40:41.790 --> 00:40:43.460
What about GPX files?

00:40:43.460 --> 00:40:45.430
JAMAL EASON: Yes, so
we parse GPX and KML.

00:40:45.430 --> 00:40:47.930
AUDIENCE: OK.

00:40:47.930 --> 00:40:51.140
AUDIENCE: So when you
install with Instant Run,

00:40:51.140 --> 00:40:52.950
is that a normal
stand alone APK,

00:40:52.950 --> 00:40:55.577
so if I then disconnect the
device and take it away,

00:40:55.577 --> 00:40:57.410
is that still going to
work in the same way,

00:40:57.410 --> 00:41:00.660
or does it rely somehow in being
connected to Android Studio

00:41:00.660 --> 00:41:01.160
still?

00:41:01.160 --> 00:41:02.650
TOR NORBYE: No,
it runs just fine.

00:41:02.650 --> 00:41:03.150
Yeah.

00:41:03.150 --> 00:41:05.690
The only thing is that it does
some extra stuff, like listen

00:41:05.690 --> 00:41:07.470
on a certain socket,
but the app is

00:41:07.470 --> 00:41:09.470
a self-contained APK that
has everything and can

00:41:09.470 --> 00:41:10.190
run anywhere.

00:41:10.190 --> 00:41:12.350
AUDIENCE: Great, thanks.

00:41:12.350 --> 00:41:14.630
AUDIENCE: Is there
any sort of SDK

00:41:14.630 --> 00:41:17.450
so that for some of
these emulator features,

00:41:17.450 --> 00:41:20.600
so if we're running
integration tests on emulators

00:41:20.600 --> 00:41:23.775
and that kind of stuff, we can
control some of the settings?

00:41:23.775 --> 00:41:25.900
JAMAL EASON: Yeah, that's
not in the first release.

00:41:25.900 --> 00:41:27.544
Something we've
been thinking about,

00:41:27.544 --> 00:41:30.220
but we're definitely
planning on working on it.

00:41:30.220 --> 00:41:33.040
Yeah.

00:41:33.040 --> 00:41:35.520
AUDIENCE: Will the new
emulators support headless mood

00:41:35.520 --> 00:41:38.802
for continuous
integration servers?

00:41:38.802 --> 00:41:40.010
JAMAL EASON: That same point.

00:41:40.010 --> 00:41:43.320
So we are looking at the
remote testing application

00:41:43.320 --> 00:41:47.190
for that, so we're definitely
planning to do that.

00:41:47.190 --> 00:41:50.850
AUDIENCE: So the logcat view
in Android studio kind of--

00:41:50.850 --> 00:41:53.780
is not great.

00:41:53.780 --> 00:41:58.560
Like it still doesn't have the
column view that Eclipse had,

00:41:58.560 --> 00:42:03.570
sorting your tags and your
time stamps, and filtering

00:42:03.570 --> 00:42:07.460
doesn't seem to be as
robust, and half the time it

00:42:07.460 --> 00:42:09.914
seems like it loses the
connection to the device.

00:42:09.914 --> 00:42:12.080
TOR NORBYE: Well, the
connection wouldn't be logcat.

00:42:12.080 --> 00:42:14.960
We know that ADB has been
pretty flaky particularly

00:42:14.960 --> 00:42:17.252
on some platforms, and I
think the newer version of ADB

00:42:17.252 --> 00:42:19.084
is actually better, so
you should definitely

00:42:19.084 --> 00:42:20.284
install the preview version.

00:42:20.284 --> 00:42:22.700
That's what we use for the
demo because Instant Run really

00:42:22.700 --> 00:42:26.150
wants an ADB connection
to be reliable.

00:42:26.150 --> 00:42:27.580
On the-- what was
the other point?

00:42:28.220 --> 00:42:30.245
JAMAL EASON: So we
also replace logcat.

00:42:30.245 --> 00:42:31.620
TOR NORBYE: Well,
what we've done

00:42:31.620 --> 00:42:35.839
is we in 1.4 we made
logcat quite a bit better.

00:42:35.839 --> 00:42:37.130
So before that it was terrible.

00:42:37.130 --> 00:42:38.546
Now it's better,
although it still

00:42:38.546 --> 00:42:40.040
doesn't have the table sorting.

00:42:40.040 --> 00:42:42.123
Part of the reason for
that is that we're actually

00:42:42.123 --> 00:42:44.570
using a console widget which
gives us some other stuff.

00:42:44.570 --> 00:42:46.695
For example, we can collapse
dock traces and things

00:42:46.695 --> 00:42:51.340
like that in a much smarter
way with the auto expand.

00:42:51.340 --> 00:42:54.681
In the 2.0 preview, we've
done some more work.

00:42:54.681 --> 00:42:56.180
Actually, it might
have been in 1.5.

00:42:56.180 --> 00:42:57.950
We show dead
processes, for example.

00:42:57.950 --> 00:42:59.630
Right, so once
your process dies,

00:42:59.630 --> 00:43:03.170
you can still find it
in the process list.

00:43:03.170 --> 00:43:05.504
And for 10 x, when we do cold
swap, the process changes.

00:43:05.504 --> 00:43:07.586
It was very important for
us to actually associate

00:43:07.586 --> 00:43:09.616
the two together, so
we've done that as well.

00:43:09.616 --> 00:43:11.990
XAVIER DUCROCHET: But we know
that we need to improve it.

00:43:11.990 --> 00:43:15.420
We have some work plans
for it to rewrite the UI.

00:43:15.420 --> 00:43:19.250
AUDIENCE: I usually use
it from the terminal,

00:43:19.250 --> 00:43:21.090
just so you can
have multiple tabs

00:43:21.090 --> 00:43:23.100
or you can have
different sortings

00:43:23.100 --> 00:43:25.767
where Android Studio is kind of
pretty inflexible about that.

00:43:25.767 --> 00:43:27.600
XAVIER DUCROCHET: Yeah,
we want to fix that.

00:43:30.490 --> 00:43:32.990
Yes.

00:43:32.990 --> 00:43:37.300
AUDIENCE: I was wondering
if you considered

00:43:37.300 --> 00:43:43.450
any impact of the
bytecode for Instant Run

00:43:43.450 --> 00:43:48.710
for developers who might be
using MAT and trying to profile

00:43:48.710 --> 00:43:52.560
their apps,
considering, you know,

00:43:52.560 --> 00:43:55.620
looking at performance
tools and such?

00:43:55.620 --> 00:43:56.370
TOR NORBYE: Right.

00:43:56.370 --> 00:43:58.790
Are you asking about the
overhead of the indirection?

00:43:58.790 --> 00:43:59.998
AUDIENCE: More or less, yeah.

00:43:59.998 --> 00:44:02.940
Instrumenting the bytecode
has to have some impact, and--

00:44:02.940 --> 00:44:04.690
TOR NORBYE: Yeah, I
definitely wouldn't do

00:44:04.690 --> 00:44:06.830
profiling on Instant Run mode.

00:44:06.830 --> 00:44:10.290
I'd probably turn off Instant
Run when I'm going to measure.

00:44:10.290 --> 00:44:14.210
In our experience it hasn't been
a noticeable lag, I would say.

00:44:14.210 --> 00:44:17.477
But you know, results
may vary, I guess.

00:44:17.477 --> 00:44:19.560
XAVIER DUCROCHET: I mean,
for memory, it shouldn't

00:44:19.560 --> 00:44:21.560
impact it too much anyway.

00:44:21.560 --> 00:44:25.360
There is an instance
of each override class,

00:44:25.360 --> 00:44:27.540
only for the classes that
you replace, of course.

00:44:27.540 --> 00:44:29.580
But you know, because
you mentioned MAT, right?

00:44:29.580 --> 00:44:33.400
So there should be
no memory changes.

00:44:33.400 --> 00:44:35.340
We're not allocating
a lot more objects.

00:44:35.340 --> 00:44:36.609
We're not doing any of that.

00:44:36.609 --> 00:44:38.400
So for memory there
shouldn't be any issue.

00:44:38.400 --> 00:44:40.750
For performance, yes, there
is definitely something.

00:44:40.750 --> 00:44:42.166
If you do actually
method tracing,

00:44:42.166 --> 00:44:44.690
you're going to see all
those overrides, delegation,

00:44:44.690 --> 00:44:45.969
and all of that.

00:44:45.969 --> 00:44:48.010
TOR NORBYE: But the main
cost is to stuff we add,

00:44:48.010 --> 00:44:50.790
that counts towards
a 65K method limit.

00:44:50.790 --> 00:44:52.414
XAVIER DUCROCHET: Right.

00:44:52.414 --> 00:44:53.080
AUDIENCE: Right.

00:44:53.080 --> 00:44:55.190
That's another problem.

00:44:55.190 --> 00:45:00.270
I guess I was wondering if the
bytecode had been measured.

00:45:00.270 --> 00:45:06.085
Like, you're testing with
a 5 meg app the IO app.

00:45:06.085 --> 00:45:08.210
XAVIER DUCROCHET: Measured
in terms of performance?

00:45:08.210 --> 00:45:11.310
AUDIENCE: No, just the
difference in size.

00:45:11.310 --> 00:45:14.864
For example, when you
install using Instant Run.

00:45:14.864 --> 00:45:16.030
TOR NORBYE: It's negligible.

00:45:16.030 --> 00:45:17.347
I mean, it's very tiny.

00:45:17.347 --> 00:45:18.680
It's basically the same access--

00:45:18.680 --> 00:45:20.010
AUDIENCE: It might be nice to
see those numbers, that's all.

00:45:20.010 --> 00:45:22.880
Because for five megabytes
maybe it's really tiny,

00:45:22.880 --> 00:45:24.570
but if you're doing
the multi-dex--

00:45:24.570 --> 00:45:25.592
TOR NORBYE: It shouldn't
be proportional.

00:45:25.592 --> 00:45:26.300
AUDIENCE: Uh-huh.

00:45:27.270 --> 00:45:29.020
TOR NORBYE: In
fact, we only touch

00:45:29.020 --> 00:45:31.807
your code, not the library code,
which makes a big difference.

00:45:31.807 --> 00:45:34.140
So when you're using large
libraries, like play services

00:45:34.140 --> 00:45:35.610
and design library
and app compact,

00:45:35.610 --> 00:45:37.470
we're not going to and
instrumenting those.

00:45:37.470 --> 00:45:39.240
We only instrument
your actual app code

00:45:39.240 --> 00:45:40.490
that we think you will change.

00:45:40.490 --> 00:45:43.860
And so that's a pretty small
amount of code, actually.

00:45:43.860 --> 00:45:44.800
AUDIENCE: Usually.

00:45:44.800 --> 00:45:45.640
TOR NORBYE: Yeah

00:45:45.640 --> 00:45:46.170
AUDIENCE: Not necessarily.

00:45:46.170 --> 00:45:48.169
TOR NORBYE: Yeah Yeah,
we are aware of some code

00:45:48.169 --> 00:45:49.770
bases that are pretty large.

00:45:49.770 --> 00:45:52.395
AUDIENCE: Yeah, so did you want
to talk about multi-dex at all?

00:45:52.395 --> 00:45:54.853
TOR NORBYE: Well, one of the
nice things that Xav mentioned

00:45:54.853 --> 00:45:57.330
is that we now target it
to the device you picked,

00:45:57.330 --> 00:46:01.860
and a lot of developers
target newer devices.

00:46:01.860 --> 00:46:04.697
So if you're 21 and up, we can
use the-- what is it called?

00:46:04.697 --> 00:46:05.572
Non legacy multi-dex?

00:46:05.572 --> 00:46:06.196
What is called?

00:46:06.196 --> 00:46:07.120
Native multi-dex.

00:46:07.120 --> 00:46:08.160
XAVIER DUCROCHET: So
we don't do that yet,

00:46:08.160 --> 00:46:09.470
but we'll do that soon.

00:46:09.470 --> 00:46:11.443
One issue to think
about for multi-dex,

00:46:11.443 --> 00:46:14.360
is if you're in legacy
multi-dex and your app is

00:46:14.360 --> 00:46:19.920
very close to the 65 K limit,
and adding that extra upserver

00:46:19.920 --> 00:46:22.225
and stuff like that may
bring you over the limit,

00:46:22.225 --> 00:46:24.100
and in that case you
would have to figure out

00:46:24.100 --> 00:46:26.460
what to do in your app to
reduce the amount of classes

00:46:26.460 --> 00:46:27.919
that you need upstart.

00:46:27.919 --> 00:46:29.710
JAMAL EASON: So we're
actually out of time,

00:46:29.710 --> 00:46:32.894
so if you have more questions,
please see us in the sandbox

00:46:32.894 --> 00:46:34.560
over there, and thanks
for coming today.

00:46:34.560 --> 00:46:35.476
TOR NORBYE: Thank you.

00:46:35.476 --> 00:46:37.010
[APPLAUSE]

