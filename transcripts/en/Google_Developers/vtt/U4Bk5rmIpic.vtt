WEBVTT
Kind: captions
Language: en

00:00:04.634 --> 00:00:06.067
Chris Pruett:
Okay, hello, everybody.

00:00:06.067 --> 00:00:08.434
Thank you for coming.
I'd like to get started.

00:00:08.434 --> 00:00:10.767
I'm supposed to reiterate
the point

00:00:10.767 --> 00:00:12.534
about not sitting
in this room.

00:00:12.534 --> 00:00:13.834
We have a Fire Marshal issue,

00:00:13.834 --> 00:00:15.367
so if you can please
find a seat.

00:00:15.367 --> 00:00:18.267
If there aren't any seats,
please stand.

00:00:18.267 --> 00:00:20.100
We don't want to get
shut down.

00:00:20.100 --> 00:00:21.801
The other point
that I wanted to make

00:00:21.801 --> 00:00:23.334
before we get started here

00:00:23.334 --> 00:00:24.868
is we're really looking
for feedback.

00:00:24.868 --> 00:00:27.300
There is a site that I've now
just hidden with my slides,

00:00:27.300 --> 00:00:29.400
but I'll put it up
at the very end.

00:00:29.400 --> 00:00:31.501
It's haveasec.com/io

00:00:31.501 --> 00:00:33.701
and it...we're, you know,
accumulating feedback

00:00:33.701 --> 00:00:35.434
about the talks here today.

00:00:35.434 --> 00:00:37.601
Please take a moment
to fill out your feedback

00:00:37.601 --> 00:00:39.434
about this talk and about all
the other talks you see here.

00:00:39.434 --> 00:00:41.033
Thank you.

00:00:41.033 --> 00:00:43.834
Okay, so this is Writing
Real-Time Games for Android.

00:00:43.834 --> 00:00:46.634
This is the opposite of
the Saving Battery Life talk.

00:00:46.634 --> 00:00:50.167
[laughter]
and the...

00:00:50.167 --> 00:00:54.000
I've a lot of stuff
to talk about today,

00:00:54.000 --> 00:00:56.467
and it's kind of a lot of
like random, unrelated--

00:00:56.467 --> 00:00:58.033
seemingly unrelated topics,

00:00:58.033 --> 00:01:00.434
so I'm gonna try to go through
them as logically as I can.

00:01:00.434 --> 00:01:02.400
Hopefully, it'll make sense.

00:01:02.400 --> 00:01:05.868
Did you see that awesome fade?
That slide totally faded in.

00:01:05.868 --> 00:01:07.501
I don't think I've ever
had like a...

00:01:07.501 --> 00:01:10.300
a thing that has like
a slide presentation

00:01:10.300 --> 00:01:12.100
that has fades
and moving stuff before,

00:01:12.100 --> 00:01:13.901
so this is like
a new experience for me.

00:01:13.901 --> 00:01:15.501
Right, so my name's Chris.

00:01:15.501 --> 00:01:17.701
I'm a Developer Advocate
for Android.

00:01:17.701 --> 00:01:19.501
I work in Japan.

00:01:19.501 --> 00:01:22.501
My job is to advocate
Android development,

00:01:22.501 --> 00:01:24.334
so please make something.

00:01:24.334 --> 00:01:26.300
I can help, maybe.

00:01:26.300 --> 00:01:28.701
If you're in Japan...
[speaking Japanese]

00:01:28.701 --> 00:01:31.300
Before that,
I was an engineer on Lively.

00:01:31.300 --> 00:01:33.701
I worked on animation code,
collision detection,

00:01:33.701 --> 00:01:35.467
service stuff,
all kinds of stuff.

00:01:35.467 --> 00:01:37.501
Lively was
our rather short-lived

00:01:37.501 --> 00:01:40.467
but very cool 3D online world.

00:01:40.467 --> 00:01:42.801
And before I started at Google
in 2007,

00:01:42.801 --> 00:01:44.801
I worked for about six years
in the game industry.

00:01:44.801 --> 00:01:48.033
Shipped about ten titles
for GBA, PlayStation Portable,

00:01:48.033 --> 00:01:50.100
PlayStation 2, Wii.

00:01:50.100 --> 00:01:52.434
So I have some experience
making games

00:01:52.434 --> 00:01:54.100
that are on other platforms.

00:01:54.100 --> 00:01:55.634
And today I want to talk about

00:01:55.634 --> 00:01:58.267
my experience making games
for Android.

00:01:58.267 --> 00:02:01.267
So, I mean, obviously
Android's a cool platform,

00:02:01.267 --> 00:02:02.834
and making games is awesome,

00:02:02.834 --> 00:02:05.934
so the two together have just
gotta be awesome squared, right?

00:02:05.934 --> 00:02:08.033
But it's really easy
to say that,

00:02:08.033 --> 00:02:10.267
and especially from,
you know,

00:02:10.267 --> 00:02:12.334
my perspective,
as like an employee of Google,

00:02:12.334 --> 00:02:14.400
it's really easy to say, hey,
make games for Android.

00:02:14.400 --> 00:02:15.934
It'll be great!

00:02:15.934 --> 00:02:18.601
Without ever knowing if it's,
really, you know, feasible.

00:02:18.601 --> 00:02:20.868
And I don't know how many
people in the audience

00:02:20.868 --> 00:02:22.601
are game developers here,

00:02:22.601 --> 00:02:24.934
but game developers will tell
you that games are weird, right?

00:02:24.934 --> 00:02:26.367
They don't really fit into

00:02:26.367 --> 00:02:28.434
regular application
development models very easily.

00:02:28.434 --> 00:02:30.400
They push your hardware in ways

00:02:30.400 --> 00:02:32.501
that your other applications
will not.

00:02:32.501 --> 00:02:35.601
So I wanted to...
in my position as an advocate,

00:02:35.601 --> 00:02:37.601
I wanted to be able
to advocate, you know,

00:02:37.601 --> 00:02:39.501
development of video games.

00:02:39.501 --> 00:02:41.133
But to do that with confidence,

00:02:41.133 --> 00:02:42.968
I need to be able to know that,
you know,

00:02:42.968 --> 00:02:44.701
the platform's actually
capable.

00:02:44.701 --> 00:02:46.200
So I made a game,

00:02:46.200 --> 00:02:49.234
and I'll talk a little bit about
the game today that I made.

00:02:49.234 --> 00:02:51.367
It's basically
a learning exercise,

00:02:51.367 --> 00:02:53.300
but I was also able
to make a fun game.

00:02:53.300 --> 00:02:55.200
I'll release it
when it's done,

00:02:55.200 --> 00:02:56.767
hopefully in a month or two.

00:02:56.767 --> 00:02:58.334
And I'll release all the source,

00:02:58.334 --> 00:03:00.367
and hopefully, people
can use that to, you know,

00:03:00.367 --> 00:03:02.234
build their own games
for Android.

00:03:02.234 --> 00:03:04.234
So what I'm gonna talk
to you about today

00:03:04.234 --> 00:03:05.834
is, you know,
who cares about games?

00:03:05.834 --> 00:03:07.701
Who cares about games
on Android?

00:03:07.701 --> 00:03:09.701
Why don't we just write like

00:03:09.701 --> 00:03:13.033
Awesome Friend Feed Connect
Facebook Apps

00:03:13.033 --> 00:03:14.400
or something, right?

00:03:14.400 --> 00:03:16.033
Like isn't that where
we're all going?

00:03:16.033 --> 00:03:17.834
But we'll talk about games
in a little bit.

00:03:17.834 --> 00:03:19.834
I'll talk a little bit about
game engine architecture.

00:03:19.834 --> 00:03:21.200
This isn't really
Android-specific,

00:03:21.200 --> 00:03:24.033
but I figure that
a lot of people in this room,

00:03:24.033 --> 00:03:25.634
and there's quite
a lot of you today,

00:03:25.634 --> 00:03:27.300
are interested in writing games

00:03:27.300 --> 00:03:28.834
but don't have a lot of
experience doing so.

00:03:28.834 --> 00:03:30.234
And like I said,

00:03:30.234 --> 00:03:32.033
game architecture
from a code point of view

00:03:32.033 --> 00:03:33.400
is very strange,

00:03:33.400 --> 00:03:35.834
so I just want to...
a couple of slides

00:03:35.834 --> 00:03:37.667
about how I go about,
you know,

00:03:37.667 --> 00:03:40.834
architecting games that I build
and how I, very specifically,

00:03:40.834 --> 00:03:42.601
which sort of architecture

00:03:42.601 --> 00:03:45.033
that I found
worked well on Android.

00:03:45.033 --> 00:03:47.334
And then talk a little bit
about writing Java code

00:03:47.334 --> 00:03:50.434
that's fast,
like really, actually fast...

00:03:50.434 --> 00:03:53.834
on Android, using
the Dalvik virtual machine.

00:03:53.834 --> 00:03:55.734
And then some rendering stuff,

00:03:55.734 --> 00:03:57.434
drawing efficiently
and then some tips and tricks.

00:03:57.434 --> 00:03:59.601
We'll get to that.

00:03:59.601 --> 00:04:01.934
So who cares about games
on mobile devices?

00:04:01.934 --> 00:04:03.801
Well, everybody,
apparently, right?

00:04:03.801 --> 00:04:06.767
iPhone where--App Store,

00:04:06.767 --> 00:04:09.300
like number one category of
download applications is games,

00:04:09.300 --> 00:04:12.100
and 79% of people
have downloaded a game once.

00:04:12.100 --> 00:04:14.133
You know, 100 million
Nintendo DSes in the world.

00:04:14.133 --> 00:04:18.133
200 million Game Boy Advances
and original Game Boys, right?

00:04:18.133 --> 00:04:20.267
And these are sold
to an audience

00:04:20.267 --> 00:04:23.300
that is not necessarily
just traditional gamers, right?

00:04:23.300 --> 00:04:25.100
I mean, you can find
a lot of people

00:04:25.100 --> 00:04:27.701
who have a Game Boy Advance or
a Nintendo DS in their pocket

00:04:27.701 --> 00:04:30.100
that, you know, would never
consider buying an Xbox 360

00:04:30.100 --> 00:04:32.100
or a PlayStation 3
or something like that.

00:04:32.100 --> 00:04:35.067
So there's a huge interest
in mobile games.

00:04:35.067 --> 00:04:37.267
And up until now,

00:04:37.267 --> 00:04:39.901
games on cell phones
have not been, you know,

00:04:39.901 --> 00:04:43.467
a really valuable proposition.

00:04:43.467 --> 00:04:45.901
And that's because before,
you know, say, the iPhone,

00:04:45.901 --> 00:04:48.868
cell phones were really not
very well designed for games,

00:04:48.868 --> 00:04:50.501
like the aspect ratio
was wrong,

00:04:50.501 --> 00:04:52.901
maybe headphones that,
for the longest time,

00:04:52.901 --> 00:04:54.701
couldn't read more than one,
you know, button input

00:04:54.701 --> 00:04:58.133
or only had like a 92-color
palette or some crap like that.

00:04:58.133 --> 00:05:01.100
So right now we're getting into
systems that are portable,

00:05:01.100 --> 00:05:04.734
they're high-powered,
they're able to host real games,

00:05:04.734 --> 00:05:07.968
and by real I mean like
modern game design kind of games

00:05:07.968 --> 00:05:10.133
that people want to make
and play today,

00:05:10.133 --> 00:05:12.934
not, you know, games
that were popular 30 years ago.

00:05:12.934 --> 00:05:16.968
And we also, I think,
are seeing a convergence

00:05:16.968 --> 00:05:18.567
of people who are interested
in, you know,

00:05:18.567 --> 00:05:20.968
having a cool phone
and also playing games,

00:05:20.968 --> 00:05:22.968
even if they're not
what we would consider

00:05:22.968 --> 00:05:25.968
the, you know, traditional
hardcore gamer market.

00:05:25.968 --> 00:05:28.767
I'm not gonna use the word
casual in this talk.

00:05:28.767 --> 00:05:33.133
So as I said before,
game tech is really specific.

00:05:33.133 --> 00:05:35.534
Another reason to do games
on Android

00:05:35.534 --> 00:05:38.567
and on any platform, I think,
is a stress test.

00:05:38.567 --> 00:05:40.334
If you can support games

00:05:40.334 --> 00:05:43.167
and you can support a lot of
different types of games,

00:05:43.167 --> 00:05:45.133
then I think that your API
is probably gonna be able

00:05:45.133 --> 00:05:47.934
to support all kinds of
other media applications.

00:05:50.133 --> 00:05:53.000
So why games on Android,
right?

00:05:53.000 --> 00:05:56.167
This is the one slide
I'm gonna spend on this.

00:05:56.167 --> 00:05:58.934
I have this really long,
involved rant,

00:05:58.934 --> 00:06:03.000
like invective-filled spew
that I would like to give to you

00:06:03.000 --> 00:06:05.000
about what's wrong
with the current game industry.

00:06:05.000 --> 00:06:06.501
But I'm not gonna do that.

00:06:06.501 --> 00:06:08.234
I'm just gonna give the little
30-second one slide version,

00:06:08.234 --> 00:06:09.901
and that's that basically

00:06:09.901 --> 00:06:12.501
the traditional game industry
has been built,

00:06:12.501 --> 00:06:14.601
especially in the last, say,
ten years,

00:06:14.601 --> 00:06:17.200
around marketing games towards
a very specific audience,

00:06:17.200 --> 00:06:18.667
and that audience
is an audience

00:06:18.667 --> 00:06:21.501
that really appreciates
advances in technology.

00:06:21.501 --> 00:06:24.567
It's also an audience that has
a lot of disposable income.

00:06:24.567 --> 00:06:27.968
So we've seen games
that sell well

00:06:27.968 --> 00:06:29.934
also being correlated
with games

00:06:29.934 --> 00:06:31.801
that have really nice
graphics tech

00:06:31.801 --> 00:06:34.634
or have really impressive
technical features.

00:06:34.634 --> 00:06:36.968
But what has happened,
because of that,

00:06:36.968 --> 00:06:38.567
is that that audience
has become

00:06:38.567 --> 00:06:40.000
the only viable audience

00:06:40.000 --> 00:06:42.400
in the minds
of a lot of game developers.

00:06:42.400 --> 00:06:44.667
And so we have, you know,
consoles now

00:06:44.667 --> 00:06:46.801
that are extremely
powerful computers

00:06:46.801 --> 00:06:49.634
and cost, you know,
200, 300, $400 when they launch,

00:06:49.634 --> 00:06:51.167
or more.

00:06:51.167 --> 00:06:53.968
And, you know, they do produce
fantastic games.

00:06:53.968 --> 00:06:55.934
I don't have anything bad
to say about those games.

00:06:55.934 --> 00:06:57.367
I love them myself too.

00:06:57.367 --> 00:06:59.234
But, you know, you could make
a PlayStation game

00:06:59.234 --> 00:07:01.100
for $5 million,
a PlayStation 2 game,

00:07:01.100 --> 00:07:02.267
$5 million.

00:07:02.267 --> 00:07:03.734
And, you know, you make
a PlayStation 3 game

00:07:03.734 --> 00:07:05.467
or an Xbox 360 game nowadays,

00:07:05.467 --> 00:07:08.100
and you're talking about, what,
20, 30, $40 million, right?

00:07:08.100 --> 00:07:10.100
I mean, we're very carefully--

00:07:10.100 --> 00:07:12.868
or very quickly
moving into a space

00:07:12.868 --> 00:07:17.501
where the platform
is becoming less and less able

00:07:17.501 --> 00:07:20.000
to support itself
on its one market base,

00:07:20.000 --> 00:07:22.000
which is sort of
the hardcore gamer, right?

00:07:22.000 --> 00:07:23.501
And we do have
alternatives, right?

00:07:23.501 --> 00:07:24.834
We've got
like Xbox Live Arcade

00:07:24.834 --> 00:07:27.868
and we have Nintendo Wii
and the DS and the iPhone

00:07:27.868 --> 00:07:30.467
showing that there are--
there is a market for games

00:07:30.467 --> 00:07:34.267
that are not about, you know,
muscle-bound like space marines

00:07:34.267 --> 00:07:36.667
who have amnesia
or a mysterious past, right?

00:07:36.667 --> 00:07:39.033
[laughter]
Like, um...

00:07:39.033 --> 00:07:40.767
if you are into muscle-bound
space marines

00:07:40.767 --> 00:07:42.334
with a mysterious past

00:07:42.334 --> 00:07:44.067
and you really like, you know,
guns that are also chainsaws,

00:07:44.067 --> 00:07:46.033
there's tons of games
for you, right?

00:07:46.033 --> 00:07:47.601
That's great.
You're the target audience.

00:07:47.601 --> 00:07:49.267
But there's a lot of other
people out there

00:07:49.267 --> 00:07:50.968
who, you know, might like
a game about something else.

00:07:50.968 --> 00:07:52.267
And the gaming industry

00:07:52.267 --> 00:07:53.901
doesn't really make games
for them anymore.

00:07:53.901 --> 00:07:55.634
They used to,
but now it's too expensive.

00:07:55.634 --> 00:07:57.667
I mean,
$50 million on a video game,

00:07:57.667 --> 00:07:59.334
you're gonna
not do anything new, right?

00:07:59.334 --> 00:08:00.834
You're gonna do whatever
sold last time

00:08:00.834 --> 00:08:02.367
because you spent $50 million

00:08:02.367 --> 00:08:04.501
and there's no way
you're gonna take any risk.

00:08:04.501 --> 00:08:07.067
So what we see is
a contraption of viable genres.

00:08:07.067 --> 00:08:08.701
And that's not good, right?

00:08:08.701 --> 00:08:10.033
I mean, games are awesome.

00:08:10.033 --> 00:08:11.501
They should be enjoyed
by everybody,

00:08:11.501 --> 00:08:13.000
and we should be able
to make whatever we want.

00:08:13.000 --> 00:08:14.434
Right now, the current
marketing conditions

00:08:14.434 --> 00:08:16.634
mean that 10% of, you know,
professional game developers

00:08:16.634 --> 00:08:19.367
make a profit and everybody
else goes out of business.

00:08:19.367 --> 00:08:21.601
So I think that--
and this is, like I said,

00:08:21.601 --> 00:08:25.000
the end of my little
side rant here about this.

00:08:25.000 --> 00:08:28.334
Mobile games in particular,
games that are being distributed

00:08:28.334 --> 00:08:30.033
over digital
distribution services

00:08:30.033 --> 00:08:32.467
like Android and like iPhone
and Xbox Live Arcade

00:08:32.467 --> 00:08:34.234
and those types of systems

00:08:34.234 --> 00:08:36.634
can solve this problem,
right?

00:08:36.634 --> 00:08:38.868
Because we can give developers

00:08:38.868 --> 00:08:42.467
a means to develop games
that are much, much lower risk

00:08:42.467 --> 00:08:43.901
to developers.

00:08:43.901 --> 00:08:46.167
And lower risk means more
interesting and diverse content

00:08:46.167 --> 00:08:48.467
because you can, you know,
you can take a risk.

00:08:48.467 --> 00:08:51.267
You can, you know, do something
that's experimental,

00:08:51.267 --> 00:08:53.100
do something that
you'd never be able to do

00:08:53.100 --> 00:08:54.868
in a $15 million game.

00:08:54.868 --> 00:08:57.033
So I think that Android's
particularly well-positioned

00:08:57.033 --> 00:08:58.367
from this point of view

00:08:58.367 --> 00:09:00.200
because we have
an audience of people

00:09:00.200 --> 00:09:01.701
who want a cool phone

00:09:01.701 --> 00:09:04.467
and also want to be able to play
games that do things on it,

00:09:04.467 --> 00:09:06.000
as we saw
in the previous slide.

00:09:06.000 --> 00:09:07.467
You know, portable games
are a big deal,

00:09:07.467 --> 00:09:08.801
and all of you are here,

00:09:08.801 --> 00:09:10.234
and they put me
in the really big room

00:09:10.234 --> 00:09:11.667
because clearly people
care about games, right?

00:09:11.667 --> 00:09:12.901
But on the other hand,

00:09:12.901 --> 00:09:14.634
we also have always-on
internet connection,

00:09:14.634 --> 00:09:16.267
and we have an internet-savvy
audience,

00:09:16.267 --> 00:09:17.767
and that's a combination
of things

00:09:17.767 --> 00:09:20.234
that we haven't actually seen
very much of in the past.

00:09:20.234 --> 00:09:21.834
iPhone's certainly
doing it too.

00:09:21.834 --> 00:09:24.601
I think that Android
can be right up there

00:09:24.601 --> 00:09:28.868
in this sort of sea change
of allowing you...

00:09:28.868 --> 00:09:35.000
or maybe...previously retired
gamers to come back.

00:09:35.000 --> 00:09:39.834
So, um...advance.

00:09:39.834 --> 00:09:43.634
So what kind of game
did I make,

00:09:43.634 --> 00:09:45.734
and why did I choose
to make that game?

00:09:45.734 --> 00:09:47.767
I had three goals
when I started out,

00:09:47.767 --> 00:09:49.067
and I have to tell you,

00:09:49.067 --> 00:09:51.234
I worked on Lively until
about October of last year.

00:09:51.234 --> 00:09:52.868
I moved to Japan
in October of last year,

00:09:52.868 --> 00:09:55.234
and I started working on this
in like very late in November.

00:09:55.234 --> 00:09:58.000
And this is a 20% project
for me.

00:09:58.000 --> 00:10:00.033
I work on it one day a week.

00:10:00.033 --> 00:10:02.200
So this is not
my full-time job.

00:10:02.200 --> 00:10:04.801
So I needed a game
that I could actually complete

00:10:04.801 --> 00:10:07.400
in a good amount of time
that I think I could make fun.

00:10:07.400 --> 00:10:09.234
I don't see any reason
to make a game

00:10:09.234 --> 00:10:11.000
if you're not gonna
make it fun, right?

00:10:11.000 --> 00:10:12.434
So my first,
my number one goal

00:10:12.434 --> 00:10:14.200
is to make a fun game

00:10:14.200 --> 00:10:15.801
in the sort of time
that I had

00:10:15.801 --> 00:10:17.801
and with the constraints
that I had.

00:10:17.801 --> 00:10:19.434
My number two goal,
as I mentioned,

00:10:19.434 --> 00:10:20.801
was to produce open source.

00:10:20.801 --> 00:10:23.801
I think that a lot of people
would make more games

00:10:23.801 --> 00:10:25.200
if they knew where to start,

00:10:25.200 --> 00:10:27.234
and if I can provide
some code or some framework

00:10:27.234 --> 00:10:29.234
or some documents
or some blog posts or something

00:10:29.234 --> 00:10:30.601
saying, like,
here's how I did it,

00:10:30.601 --> 00:10:32.801
you know, maybe that's
a jumping-off point.

00:10:32.801 --> 00:10:34.200
And even better,
down the road,

00:10:34.200 --> 00:10:36.000
if other people
could take that code

00:10:36.000 --> 00:10:37.400
and make new games
out of it

00:10:37.400 --> 00:10:39.000
and release their source
as well,

00:10:39.000 --> 00:10:40.334
then I think we could have

00:10:40.334 --> 00:10:42.234
a really pretty awesome
community.

00:10:42.234 --> 00:10:43.400
And then like,
as I said before,

00:10:43.400 --> 00:10:44.834
I want to stress
this platform.

00:10:44.834 --> 00:10:46.434
So I went for an orthodox
2D side-scroller.

00:10:46.434 --> 00:10:48.601
I'm assuming everybody
knows what that is,

00:10:48.601 --> 00:10:50.000
but just in case that's,
you know,

00:10:50.000 --> 00:10:52.000
Super Mario Brothers,
Sonic the Hedgehog,

00:10:52.000 --> 00:10:53.400
games like that.

00:10:53.400 --> 00:10:55.801
We have, basically,
multiple layers of images

00:10:55.801 --> 00:10:58.200
that are scrolling
at different speeds.

00:10:58.200 --> 00:11:00.200
It's called parallax scrolling.

00:11:00.200 --> 00:11:01.667
They're built out of tiles.

00:11:01.667 --> 00:11:04.300
We have little small images
that get put next to each other

00:11:04.300 --> 00:11:05.467
to build the world,

00:11:05.467 --> 00:11:07.267
so it's pretty traditional,

00:11:07.267 --> 00:11:10.467
very, very popular
in the mid, early '90s genre.

00:11:10.467 --> 00:11:12.501
Recently under-served,
I think.

00:11:12.501 --> 00:11:14.300
Nice thing about
this particular genre

00:11:14.300 --> 00:11:16.300
is I felt I could do it
in six months.

00:11:16.300 --> 00:11:17.667
I made a bunch of side-scrollers

00:11:17.667 --> 00:11:19.100
when I was working
on Game Boy Advance games.

00:11:19.100 --> 00:11:20.667
I have some experience
with them,

00:11:20.667 --> 00:11:22.267
and I quite enjoy
the genre myself.

00:11:22.267 --> 00:11:24.300
So it felt like something
that'd be fun to make,

00:11:24.300 --> 00:11:26.000
something that I thought
the people would enjoy

00:11:26.000 --> 00:11:27.367
and also the correct skill.

00:11:27.367 --> 00:11:28.868
It also pushed the right buttons
technically.

00:11:28.868 --> 00:11:31.868
I need to know how to do input
systems correctly and sound,

00:11:31.868 --> 00:11:33.234
and I need to be able to draw
with OpenGL or Canvas

00:11:33.234 --> 00:11:35.300
or whatever it is I'm gonna do

00:11:35.300 --> 00:11:38.100
that any game is gonna know--
have to know how to do,

00:11:38.100 --> 00:11:39.667
whether or not it's 2D or 3D.

00:11:39.667 --> 00:11:41.868
So then the stuff
I'm gonna talk about today

00:11:41.868 --> 00:11:43.300
is a little bit focused on 2D,

00:11:43.300 --> 00:11:44.868
'cause that's the kind of
game that I made.

00:11:44.868 --> 00:11:46.501
I suspect
that a lot of it will be

00:11:46.501 --> 00:11:48.667
completely applicable
to 3D games as well,

00:11:48.667 --> 00:11:51.467
especially the stuff about
using OpenGL quickly.

00:11:51.467 --> 00:11:54.667
So please don't
take this as being

00:11:54.667 --> 00:11:56.667
absolutely
just for 2D games.

00:11:56.667 --> 00:11:59.267
I want to talk about games
in a general purpose case,

00:11:59.267 --> 00:12:01.934
but I'm gonna use
the 2D game that I built.

00:12:01.934 --> 00:12:04.934
Okay, so let's talk about
some game engine architecture.

00:12:04.934 --> 00:12:06.567
Before that, I had a picture

00:12:06.567 --> 00:12:09.801
of a guy holding
a chainsaw gun here, but...

00:12:09.801 --> 00:12:11.300
legal made me take it out.

00:12:11.300 --> 00:12:12.767
[laughter]
Sorry.

00:12:12.767 --> 00:12:14.534
I just put the little text in
instead.

00:12:14.534 --> 00:12:16.968
I didn't really, you know,
own the license, I guess,

00:12:16.968 --> 00:12:18.267
so they were right.

00:12:18.267 --> 00:12:20.534
So I just wanna have
a really quick demo here.

00:12:20.534 --> 00:12:22.467
This is the game
that I'm working on.

00:12:22.467 --> 00:12:24.033
It's called Replica Island.

00:12:24.033 --> 00:12:26.033
It's getting close
to being done,

00:12:26.033 --> 00:12:27.701
and it's probably
about an Alpha.

00:12:27.701 --> 00:12:32.033
I have a very low-quality
video to show you.

00:12:32.033 --> 00:12:34.200
It's really hard
to shoot video

00:12:34.200 --> 00:12:36.300
on the Android device
that I have.

00:12:36.300 --> 00:12:37.901
So I apologize.

00:12:37.901 --> 00:12:39.634
And it's also quite difficult
to play a video game

00:12:39.634 --> 00:12:41.133
while shooting video
on an Android device

00:12:41.133 --> 00:12:43.834
and keep the screen
from getting screwed up.

00:12:43.834 --> 00:12:45.501
So I just have
a very short clip,

00:12:45.501 --> 00:12:46.934
and it's not really
representative

00:12:46.934 --> 00:12:48.501
of the entire game,

00:12:48.501 --> 00:12:51.434
but it'll give you an idea
of what I'm talking about,

00:12:51.434 --> 00:12:53.534
an idea of what the scope is
that I'm working on,

00:12:53.534 --> 00:12:55.234
and hopefully,
you'll think it looks cool too.

00:12:55.234 --> 00:12:57.701
Let's see if I can
make that play here.

00:12:57.701 --> 00:13:01.067
I think I have to click again.

00:13:01.067 --> 00:13:03.000
There we go.

00:13:03.000 --> 00:13:05.033
[laughter]

00:13:05.033 --> 00:13:06.634
So we got, you know...

00:13:06.634 --> 00:13:09.634
the Android robot,
and he's blowing some guys up

00:13:09.634 --> 00:13:11.200
and crushing some robots.

00:13:11.200 --> 00:13:13.167
And he's gonna take
this robot over here

00:13:13.167 --> 00:13:14.601
with this little red ball.

00:13:14.601 --> 00:13:16.334
Now he's possessed him.

00:13:18.567 --> 00:13:19.968
Now I can walk over here.

00:13:19.968 --> 00:13:21.567
This is a test level,

00:13:21.567 --> 00:13:23.801
so there's not really
anything to do in this level,

00:13:23.801 --> 00:13:26.734
but the robot can walk
over here and then self-destruct

00:13:26.734 --> 00:13:28.701
to go back to Android.

00:13:28.701 --> 00:13:31.667
So the goal is to collect
the three gems in each level.

00:13:31.667 --> 00:13:33.868
You can get coins
and things like that.

00:13:33.868 --> 00:13:35.601
There's some power-ups
to acquire

00:13:35.601 --> 00:13:37.000
and a lot of robots to crush,

00:13:37.000 --> 00:13:38.534
people to talk to,
things like that.

00:13:38.534 --> 00:13:41.334
And it's pretty traditional
side-scroll.

00:13:51.601 --> 00:13:54.534
[laughter]

00:13:56.400 --> 00:13:58.234
Oh, and here's a character
we can talk to.

00:13:58.234 --> 00:14:01.033
But I think we're just gonna
run by her instead.

00:14:01.033 --> 00:14:02.767
And you can kind of see,
you know,

00:14:02.767 --> 00:14:04.467
that there's a couple
of layers of background

00:14:04.467 --> 00:14:05.868
that are scrolling
at different speeds.

00:14:05.868 --> 00:14:07.267
That's the parallax
we talked about.

00:14:07.267 --> 00:14:08.667
We'll talk about that in a bit.

00:14:08.667 --> 00:14:10.167
Okay,
so there's the third gem.

00:14:10.167 --> 00:14:13.200
Hooray,
we completed the level.

00:14:13.200 --> 00:14:15.400
So that's Replica Island.

00:14:15.400 --> 00:14:22.100
[applause]

00:14:22.100 --> 00:14:24.067
Thanks. I hope you guys
enjoy it when it comes out.

00:14:24.067 --> 00:14:25.801
I'd like to hear
your feedback.

00:14:25.801 --> 00:14:29.567
So I want to talk a little bit
about how I build games

00:14:29.567 --> 00:14:30.868
just generally.

00:14:30.868 --> 00:14:33.267
And this sort of general
architecture

00:14:33.267 --> 00:14:37.467
is the architecture
I used to build Replica Island.

00:14:37.467 --> 00:14:39.467
It's also very similar
to the architecture

00:14:39.467 --> 00:14:41.467
that I used to build
a Spider-Man game

00:14:41.467 --> 00:14:43.067
on PlayStation 2.

00:14:43.067 --> 00:14:45.501
So I believe that it scales
pretty well.

00:14:45.501 --> 00:14:46.968
My approach is to--

00:14:46.968 --> 00:14:48.868
you know, we have like
the same kind of problems

00:14:48.868 --> 00:14:50.667
that we have to solve
in all games,

00:14:50.667 --> 00:14:52.067
and that's that you have
this sort of world

00:14:52.067 --> 00:14:53.634
full of objects
that need to be simulated

00:14:53.634 --> 00:14:54.868
with time, right?

00:14:54.868 --> 00:14:57.067
We got, you know,
the character moving around

00:14:57.067 --> 00:14:58.868
and there's other things,
and they're gonna collide,

00:14:58.868 --> 00:15:00.868
and they're gonna pick up stuff
and hit the ground and bounce.

00:15:00.868 --> 00:15:02.934
And then they're gonna have
velocities

00:15:02.934 --> 00:15:04.734
that need to be calculated

00:15:04.734 --> 00:15:06.734
and also animations
that need to be updated.

00:15:06.734 --> 00:15:09.534
These are all sort of
taking a time step,

00:15:09.534 --> 00:15:11.000
a simulation step,
and then updating

00:15:11.000 --> 00:15:12.734
and then figuring out
the results.

00:15:12.734 --> 00:15:14.934
That's sort of the basic
problem that most games face.

00:15:14.934 --> 00:15:16.734
So what I do is
I have a game graph.

00:15:16.734 --> 00:15:19.868
Basically we have a--
you can think of it as a tree.

00:15:19.868 --> 00:15:21.334
It's technically a graph,

00:15:21.334 --> 00:15:23.734
but you can think of it
as a tree for most cases,

00:15:23.734 --> 00:15:26.734
where the root node
is the main loop.

00:15:26.734 --> 00:15:29.534
And all the child nodes
under that root

00:15:29.534 --> 00:15:32.334
are things that get updated
every frame by the main loop.

00:15:32.334 --> 00:15:33.934
And those things
can have their children,

00:15:33.934 --> 00:15:35.734
and those things can be
updated every frame as well.

00:15:35.734 --> 00:15:37.133
And, you know, halfway
through the tree

00:15:37.133 --> 00:15:40.734
it's okay if we start adjusting
the way the things below

00:15:40.734 --> 00:15:42.734
in that particular sub-graph
get updated.

00:15:42.734 --> 00:15:44.734
For example,

00:15:44.734 --> 00:15:48.534
we could have a main loop
that has a game object child

00:15:48.534 --> 00:15:50.534
and a game object--
I'm sorry, manager as a child.

00:15:50.534 --> 00:15:52.334
And that manager
is gonna be the thing

00:15:52.334 --> 00:15:53.934
that manages all, say, like

00:15:53.934 --> 00:15:56.534
the sprites for bad guys
on the screen.

00:15:56.534 --> 00:15:58.334
And the thing about
bad guys on the screen

00:15:58.334 --> 00:16:00.334
is you don't really care
about what they're doing

00:16:00.334 --> 00:16:02.601
when they get far enough
away from the camera, right?

00:16:02.601 --> 00:16:04.601
In fact, you'd like to stop
processing them completely

00:16:04.601 --> 00:16:06.000
when they get far enough
away from the camera

00:16:06.000 --> 00:16:08.400
because, you know,
they're gonna slow stuff down.

00:16:08.400 --> 00:16:09.801
You got a huge level

00:16:09.801 --> 00:16:12.000
and there's like 500 guys
in there,

00:16:12.000 --> 00:16:13.801
but there's only three
that are actually close

00:16:13.801 --> 00:16:15.601
to actually being able
to interact with the player,

00:16:15.601 --> 00:16:17.801
and you only want to update
those three, right?

00:16:17.801 --> 00:16:20.601
So...in the game-graph context,

00:16:20.601 --> 00:16:25.234
the game manager node can sort
its children by visibility

00:16:25.234 --> 00:16:26.601
and only visit the children

00:16:26.601 --> 00:16:28.200
that it thinks are close
to being visible.

00:16:28.200 --> 00:16:31.400
That's kind of how that
concept fits into the graph.

00:16:31.400 --> 00:16:33.400
The game objects themselves

00:16:33.400 --> 00:16:36.200
which are, you know,
"an enemy" or "an explosion,"

00:16:36.200 --> 00:16:37.601
or "the player",

00:16:37.601 --> 00:16:39.601
those things are sub-graphs
of the game graph as well.

00:16:39.601 --> 00:16:42.200
You know, the sort of
initial implementation

00:16:42.200 --> 00:16:44.400
that I started out,
sort of the naive implementation

00:16:44.400 --> 00:16:47.000
when I first, you know,
joined the game industry

00:16:47.000 --> 00:16:50.734
was to take...you know,
make a game object class

00:16:50.734 --> 00:16:53.400
and then derive that to make
visible game object class

00:16:53.400 --> 00:16:55.000
and implement
the rendering part.

00:16:55.000 --> 00:16:57.334
And then derive that and make
a moving game object class

00:16:57.334 --> 00:16:59.200
and implement, you know,
velocity calculations.

00:16:59.200 --> 00:17:00.634
And then derive that
and make, you know,

00:17:00.634 --> 00:17:02.467
the rendering--
or, I'm sorry--

00:17:02.467 --> 00:17:04.467
the collision detection
game object

00:17:04.467 --> 00:17:06.567
and then derive that
and make the player out of that.

00:17:06.567 --> 00:17:08.267
And that actually works
for a while,

00:17:08.267 --> 00:17:10.267
and then eventually
you'll get into a case

00:17:10.267 --> 00:17:12.567
where you need, you know,
functionality from step A

00:17:12.567 --> 00:17:14.033
and functionality from step C,

00:17:14.033 --> 00:17:16.067
but you don't want
the class in the middle.

00:17:16.067 --> 00:17:17.501
And then you're sort of
screwed, right?

00:17:17.501 --> 00:17:20.701
So what I've been doing
for the last couple of years

00:17:20.701 --> 00:17:22.467
is sort of an aggregate
object model

00:17:22.467 --> 00:17:24.868
where I have a game object

00:17:24.868 --> 00:17:28.701
that is just
a list of other components.

00:17:28.701 --> 00:17:32.100
And each component is a single
piece of functionality.

00:17:32.100 --> 00:17:34.467
It updates
like a single update loop

00:17:34.467 --> 00:17:36.667
that says
I'm gonna do something

00:17:36.667 --> 00:17:39.200
like move the player
or render the player

00:17:39.200 --> 00:17:40.701
or take the input
from the device

00:17:40.701 --> 00:17:42.868
and then decide
how to adjust velocities.

00:17:42.868 --> 00:17:44.467
And it only does one thing.

00:17:44.467 --> 00:17:46.267
And the nice thing
about that approach is

00:17:46.267 --> 00:17:48.400
you only insert the components
into the object

00:17:48.400 --> 00:17:49.801
as they need it.

00:17:49.801 --> 00:17:51.467
So the player happens
to need to know

00:17:51.467 --> 00:17:52.868
how to read the input,

00:17:52.868 --> 00:17:54.467
but the enemies,
until they get possessed,

00:17:54.467 --> 00:17:56.200
don't need to actually
read the input ever,

00:17:56.200 --> 00:17:58.467
so they don't have to have
the input component.

00:17:58.467 --> 00:17:59.934
And if I decide
to possess an enemy

00:17:59.934 --> 00:18:01.667
and then suddenly
I want him to respond

00:18:01.667 --> 00:18:02.934
to the input component,

00:18:02.934 --> 00:18:04.534
I can just stick
a new component

00:18:04.534 --> 00:18:06.334
into his game object
at runtime,

00:18:06.334 --> 00:18:07.934
and it suddenly
starts working.

00:18:07.934 --> 00:18:10.300
So this is actually
an important point,

00:18:10.300 --> 00:18:12.367
and the reason
I'm sort of belaboring it

00:18:12.367 --> 00:18:15.100
is that also
it's very helpful

00:18:15.100 --> 00:18:17.534
because it helps you not
execute code

00:18:17.534 --> 00:18:19.534
that you don't need to do.

00:18:19.534 --> 00:18:21.000
And not doing extra work

00:18:21.000 --> 00:18:22.734
is gonna be a recurring
theme in this talk.

00:18:22.734 --> 00:18:24.501
Because optimization
is gonna become

00:18:24.501 --> 00:18:26.534
a big problem for us
when we start to write games.

00:18:26.534 --> 00:18:30.000
So, um...
let's go to the graph and see...

00:18:30.000 --> 00:18:32.634
This would be like
the top level view

00:18:32.634 --> 00:18:35.000
of like a very simple game graph
where we have a main loop

00:18:35.000 --> 00:18:36.434
and then we have some other
systems as children

00:18:36.434 --> 00:18:37.801
that get updated every frame.

00:18:37.801 --> 00:18:39.834
I just wanna give you an idea
of how I do this.

00:18:39.834 --> 00:18:41.267
This isn't the only way
to do this.

00:18:41.267 --> 00:18:42.934
This is just the way
I do it.

00:18:42.934 --> 00:18:44.767
So here's an example
with two objects

00:18:44.767 --> 00:18:46.701
and the game object's
just in there.

00:18:46.701 --> 00:18:48.067
Background object
was the thing

00:18:48.067 --> 00:18:49.467
that's drawing the backgrounds
and the layers,

00:18:49.467 --> 00:18:51.968
and then the player object
would be like the player itself.

00:18:51.968 --> 00:18:53.868
And you can kind of see how
they're made up of components

00:18:53.868 --> 00:18:56.000
where they sort of--they look
like children in the graph

00:18:56.000 --> 00:18:57.634
'cause that's what they are.

00:18:57.634 --> 00:19:00.601
So for the background,
there's like three layers.

00:19:00.601 --> 00:19:04.300
There's the, I think--
you saw it in the demo just now.

00:19:04.300 --> 00:19:06.000
There's like
the blue static background

00:19:06.000 --> 00:19:07.834
and then there was
a mid-ground layer

00:19:07.834 --> 00:19:09.434
and there's a foreground layer
as well.

00:19:09.434 --> 00:19:10.901
So for each of those layers,

00:19:10.901 --> 00:19:12.734
there's a scroller component
and a render component.

00:19:12.734 --> 00:19:13.901
Scroller component figures out

00:19:13.901 --> 00:19:15.367
how much it's supposed
to be scrolled,

00:19:15.367 --> 00:19:17.100
based on the current
camera position.

00:19:17.100 --> 00:19:18.734
And then the render
component says

00:19:18.734 --> 00:19:20.667
okay, now go render this
as frame.

00:19:20.667 --> 00:19:22.834
And then the player's made
of a bunch of stuff

00:19:22.834 --> 00:19:26.767
like physics and animation
and rendering and gravity,

00:19:26.767 --> 00:19:28.334
movement,
things like that.

00:19:28.334 --> 00:19:30.601
So this is actually
pretty close

00:19:30.601 --> 00:19:33.000
to the way that
Replica Island works right now.

00:19:33.000 --> 00:19:35.200
It's a little bit
of a simplification.

00:19:35.200 --> 00:19:39.501
But...you can see
that every frame,

00:19:39.501 --> 00:19:42.267
if we wanna update this game
and produce a new frame

00:19:42.267 --> 00:19:45.033
showing one more
simulation step of the game,

00:19:45.033 --> 00:19:47.000
all we have to do
is traverse this graph.

00:19:47.000 --> 00:19:49.167
And the order in which
we traverse these things,

00:19:49.167 --> 00:19:50.601
you know,
is sort of important,

00:19:50.601 --> 00:19:53.133
so just sort of say
breadth-first, left to right.

00:19:55.434 --> 00:19:57.501
Anyway, that's how I do it.
You can do it however you want.

00:19:57.501 --> 00:20:00.501
But I wanted to sort of...
just sort of say, you know,

00:20:00.501 --> 00:20:01.801
think about this kind of stuff

00:20:01.801 --> 00:20:03.367
when you start
writing video games

00:20:03.367 --> 00:20:04.667
because if you don't,

00:20:04.667 --> 00:20:06.167
it will come back
and bite you later.

00:20:06.167 --> 00:20:08.234
It bit me on production games

00:20:08.234 --> 00:20:10.667
that I did in my previous job
several times

00:20:10.667 --> 00:20:12.467
until I stopped doing it
that way

00:20:12.467 --> 00:20:14.267
and started doing it
this way.

00:20:14.267 --> 00:20:16.834
An important point about this
is that the graph takes time,

00:20:16.834 --> 00:20:20.901
like the delta from the previous
frame, as its input.

00:20:20.901 --> 00:20:23.334
Its output is a bunch of things
to draw for the render system,

00:20:23.334 --> 00:20:24.567
but its input is time.

00:20:24.567 --> 00:20:26.267
And the reason
that that's important

00:20:26.267 --> 00:20:28.267
is that any sort of
temporal logic

00:20:28.267 --> 00:20:30.167
that you're gonna do
in a game

00:20:30.167 --> 00:20:32.400
for a system like Android
needs to be scaled by time.

00:20:32.400 --> 00:20:34.601
So that means velocity
calculations,

00:20:34.601 --> 00:20:36.133
animation duration
calculations.

00:20:36.133 --> 00:20:39.100
Anything that's related to time
has to be scaled by real time

00:20:39.100 --> 00:20:40.767
and not like, say,
frame counts.

00:20:40.767 --> 00:20:42.267
It's really easy to say,

00:20:42.267 --> 00:20:44.167
"Oh, I'm gonna add five
to my velocity,

00:20:44.167 --> 00:20:46.467
or I'm gonna, you know,
wait for three frames

00:20:46.467 --> 00:20:48.000
and then play
this other animation."

00:20:48.000 --> 00:20:49.601
And the reason you don't
ever wanna do that

00:20:49.601 --> 00:20:51.667
is you don't know what
the duration of each frame is.

00:20:51.667 --> 00:20:53.734
You might think, well,
I'm running at 60 hertz,

00:20:53.734 --> 00:20:56.033
but Android
is a multiprocessing OS.

00:20:56.033 --> 00:20:58.033
You have no idea
what's going on in the CPU.

00:20:58.033 --> 00:20:59.767
You have to plan
for a variable framerate.

00:20:59.767 --> 00:21:02.734
And what happens when you don't
plan for a variable framerate

00:21:02.734 --> 00:21:04.300
is when your framerate's
really low,

00:21:04.300 --> 00:21:06.234
your game kind of falls apart
and slows way down.

00:21:06.234 --> 00:21:10.734
And you also start to experience
sort of temporal anomalies

00:21:10.734 --> 00:21:12.567
as the framerate fluctuate.

00:21:12.567 --> 00:21:14.400
Like your collision detection
will cease to work

00:21:14.400 --> 00:21:16.067
and things like that.

00:21:16.067 --> 00:21:18.234
So very important point
is that--

00:21:18.234 --> 00:21:20.968
and that a lot of people
would not maybe think about

00:21:20.968 --> 00:21:22.868
if they've not written
a game before--

00:21:22.868 --> 00:21:26.400
is to take time and do all
the calculations you need to do

00:21:26.400 --> 00:21:28.067
related to time with real-time.

00:21:28.067 --> 00:21:29.934
It's okay if you buy us
some time.

00:21:29.934 --> 00:21:31.701
You want to have
a slowed down &lt;i&gt;Matrix&lt;/i&gt; effect?

00:21:31.701 --> 00:21:33.000
Sure. Go for it.

00:21:33.000 --> 00:21:34.934
Just don't use frame counts
as your...

00:21:34.934 --> 00:21:37.467
The other important point
is that

00:21:37.467 --> 00:21:39.167
the traversal
of the game graph

00:21:39.167 --> 00:21:40.868
doesn't actually draw anything
on the screen.

00:21:40.868 --> 00:21:42.400
It just produces
a list of things

00:21:42.400 --> 00:21:44.701
that we might draw
sometime in the future.

00:21:44.701 --> 00:21:46.534
And that's important
because of the way that--

00:21:46.534 --> 00:21:49.267
it's particularly important
in kind of all kinds of games,

00:21:49.267 --> 00:21:50.968
but for Android it's important

00:21:50.968 --> 00:21:53.133
because of the way
that rendering works.

00:21:53.133 --> 00:21:55.667
And this is true
whether or not

00:21:55.667 --> 00:21:58.501
you use OpenGL
or you use the Canvas system

00:21:58.501 --> 00:21:59.868
to be doing your drawing.

00:21:59.868 --> 00:22:02.734
You're gonna hit a point
at which the rendering threat

00:22:02.734 --> 00:22:04.734
is gonna block on hardware.

00:22:04.734 --> 00:22:06.334
And the reason
that that happens is that

00:22:06.334 --> 00:22:08.601
the hardware may not be done
drawing the previous frame.

00:22:08.601 --> 00:22:10.334
If the hardware's not done
drawing the previous frame,

00:22:10.334 --> 00:22:12.334
it's not gonna let you do
anything until it's finished.

00:22:12.334 --> 00:22:15.133
So if you're using OpenGL ES
and you call EGLSwapBuffers,

00:22:15.133 --> 00:22:16.734
that's gonna block,

00:22:16.734 --> 00:22:19.100
and it can block for like
16 milliseconds, right?

00:22:19.100 --> 00:22:20.534
And the CPU's not really
doing anything

00:22:20.534 --> 00:22:22.334
when that thread is blocked.

00:22:22.334 --> 00:22:26.467
But it means that your game
is not proceeding, right?

00:22:26.467 --> 00:22:29.567
So it's important to split
the game logic

00:22:29.567 --> 00:22:30.901
from the rendering layer.

00:22:30.901 --> 00:22:33.901
And the way that I did it
for Replica Island

00:22:33.901 --> 00:22:35.734
is I have three main threads.

00:22:35.734 --> 00:22:39.000
The main activity
is what I call the UI thread.

00:22:39.000 --> 00:22:40.734
It's just that when you make
an Android application,

00:22:40.734 --> 00:22:41.901
you make an activity

00:22:41.901 --> 00:22:43.667
and it comes up
and it produces your views,

00:22:43.667 --> 00:22:45.167
and then it can receive
input events.

00:22:45.167 --> 00:22:46.634
That's pretty much
all it does.

00:22:46.634 --> 00:22:48.534
That thread's mostly dormant.

00:22:48.534 --> 00:22:52.000
It bootstraps the game,
then it's pretty much done.

00:22:52.000 --> 00:22:54.167
Excuse me.

00:22:54.167 --> 00:22:56.701
I have a game thread which
is where the game graph lives.

00:22:56.701 --> 00:22:59.234
It gets updated, you know,
as often as I plan,

00:22:59.234 --> 00:23:02.100
and it produces
a list of drawable things

00:23:02.100 --> 00:23:03.968
to hand off
to the rendering thread.

00:23:03.968 --> 00:23:06.734
The rendering thread
is basically a SurfaceHolder.

00:23:06.734 --> 00:23:10.801
If you look at any of
the OpenGL examples

00:23:10.801 --> 00:23:12.801
that are shipped
with API demos--

00:23:12.801 --> 00:23:14.367
0r in a few minutes,

00:23:14.367 --> 00:23:16.067
I'll talk about
a sample that I wrote

00:23:16.067 --> 00:23:17.601
that you can look at as well--

00:23:17.601 --> 00:23:20.834
you'll see classes
like GL SurfaceView,

00:23:20.834 --> 00:23:24.567
which was part of API demos
in previous versions south,

00:23:24.567 --> 00:23:26.667
part of the API in Android 1.5,

00:23:26.667 --> 00:23:29.501
but it implements
a separate rendering thread

00:23:29.501 --> 00:23:31.000
separate from the main thread

00:23:31.000 --> 00:23:34.501
that just sits there and talks
to OpenGL as quickly as it can.

00:23:34.501 --> 00:23:36.334
So basically we have
this game thread

00:23:36.334 --> 00:23:38.968
producing a list of things
to draw, every frame,

00:23:38.968 --> 00:23:41.067
and then the rendering thread
consuming this every frame.

00:23:41.067 --> 00:23:42.968
And the nice thing
about this is that means

00:23:42.968 --> 00:23:45.000
that the framerates of these
two threads are decoupled.

00:23:45.000 --> 00:23:46.534
If the rendering thread
slows way down

00:23:46.534 --> 00:23:48.667
because I just threw
a hundred sprites at it,

00:23:48.667 --> 00:23:51.467
then as it's chugging on drawing
those hundred sprites,

00:23:51.467 --> 00:23:54.400
the game thread can continue
to run at 30 hertz

00:23:54.400 --> 00:23:56.701
or 60 hertz or whatever.

00:23:56.701 --> 00:24:00.234
If there's a...backlog
of the other direction,

00:24:00.234 --> 00:24:02.734
like the rendering thread
is starved,

00:24:02.734 --> 00:24:04.934
it'll just re-render the frame
that it had previously.

00:24:04.934 --> 00:24:06.534
Which is not ideal.

00:24:06.534 --> 00:24:08.067
you don't want to drop a frame
if you can ever avoid it.

00:24:08.067 --> 00:24:09.667
But, you know,
the screen doesn't go black.

00:24:09.667 --> 00:24:11.067
Nothing blows up.

00:24:11.067 --> 00:24:12.534
You can pause the game

00:24:12.534 --> 00:24:13.934
just by turning off
the game thread,

00:24:13.934 --> 00:24:15.400
and the rendering pedals
still continue

00:24:15.400 --> 00:24:18.067
to draw stuff on the screen,
whatever it had last.

00:24:18.067 --> 00:24:20.067
So I'm sure there are
other ways to do this.

00:24:20.067 --> 00:24:21.634
This is how I did it
on Replica Island,

00:24:21.634 --> 00:24:25.534
and it worked out pretty well.

00:24:25.534 --> 00:24:27.434
Okay. So let's talk
a little bit about

00:24:27.434 --> 00:24:29.167
writing Java code that's fast.

00:24:29.167 --> 00:24:32.000
Before I start talking
about this,

00:24:32.000 --> 00:24:34.701
I'm gonna offend all of the Java
engineers in the room,

00:24:34.701 --> 00:24:37.033
and I apologize for that.

00:24:37.033 --> 00:24:39.934
Also when I say Java,
I mean Java on Android

00:24:39.934 --> 00:24:41.467
running
the Dalvik virtual machine,

00:24:41.467 --> 00:24:43.400
not any other kind of Java.

00:24:43.400 --> 00:24:47.167
So please don't kill me.

00:24:47.167 --> 00:24:48.467
Basically,
I'm a C++ engineer.

00:24:48.467 --> 00:24:50.267
In fact, I never wrote
a line of Java

00:24:50.267 --> 00:24:51.667
in my entire life
before I started this game.

00:24:51.667 --> 00:24:52.868
So you should probably take

00:24:52.868 --> 00:24:54.467
everything I have to say
about Java applications

00:24:54.467 --> 00:24:56.133
with a kind of gigantic
grain of salt.

00:24:56.133 --> 00:24:58.667
But, you know, I also think
that most Java applications

00:24:58.667 --> 00:25:00.200
don't really need to do--

00:25:00.200 --> 00:25:02.968
be optimized to the sort of
level that I've been working.

00:25:02.968 --> 00:25:04.133
Because, you know,
for the most part,

00:25:04.133 --> 00:25:05.734
you have this language

00:25:05.734 --> 00:25:07.834
that provides a bunch of awesome
services for you.

00:25:07.834 --> 00:25:09.534
It provides an awesome
standard library,

00:25:09.534 --> 00:25:11.167
you've got memory referencing
and all this other stuff

00:25:11.167 --> 00:25:13.767
that you don't get in languages
like C++.

00:25:13.767 --> 00:25:15.534
and that's why writing
Java applications

00:25:15.534 --> 00:25:17.334
is easy and cool, right?

00:25:17.334 --> 00:25:19.767
And then maybe, you know,
I'm sure that everybody does

00:25:19.767 --> 00:25:21.534
sort of macro level
optimization of their algorithms

00:25:21.534 --> 00:25:25.934
and not doing an order
N-squared, you know, search

00:25:25.934 --> 00:25:29.133
when you can do a...and log N
search and stuff like that.

00:25:29.133 --> 00:25:30.767
But I'm gonna talk about
optimizations

00:25:30.767 --> 00:25:32.934
that are a little bit
more low level than that,

00:25:32.934 --> 00:25:35.334
and I think that might be
something that Java engineers

00:25:35.334 --> 00:25:37.601
don't generally
have to worry about.

00:25:37.601 --> 00:25:39.033
So hopefully this will be
some useful information

00:25:39.033 --> 00:25:40.534
here for you.

00:25:40.534 --> 00:25:42.200
There's one bullet point

00:25:42.200 --> 00:25:43.901
that says writing
real-time games

00:25:43.901 --> 00:25:45.300
in an exercise in finding
the perfect balance

00:25:45.300 --> 00:25:46.734
between flexibility
and performance.

00:25:46.734 --> 00:25:48.934
That's like a whole talk
in itself, that topic.

00:25:48.934 --> 00:25:51.133
But basically, what I want
to say real briefly is

00:25:51.133 --> 00:25:53.133
that at some point
you're going to have to choose

00:25:53.133 --> 00:25:54.534
between absolute performance

00:25:54.534 --> 00:25:56.334
and the ability
to make the game.

00:25:56.334 --> 00:25:58.300
And making games is about
duration, right?

00:25:58.300 --> 00:26:00.133
What you're gonna do,
if you sit down and make a game,

00:26:00.133 --> 00:26:01.868
is you're gonna have an idea,
and you're gonna make it,

00:26:01.868 --> 00:26:03.334
and you'll write it
and it'll be great,

00:26:03.334 --> 00:26:04.734
and then you'll give it
to somebody else,

00:26:04.734 --> 00:26:06.000
and they'll have no idea
how to do it

00:26:06.000 --> 00:26:07.400
or they will not find it
fun at all,

00:26:07.400 --> 00:26:08.901
and you realize
that there'll be

00:26:08.901 --> 00:26:10.801
all these usability problems
with it, so you'll iterate.

00:26:10.801 --> 00:26:11.868
And that's how games are made.

00:26:11.868 --> 00:26:13.167
And the games
that are really good

00:26:13.167 --> 00:26:14.467
are the ones that iterated
for a really long time.

00:26:14.467 --> 00:26:15.901
That's for the general rule.

00:26:15.901 --> 00:26:18.200
In order to iterate, you need
to have your code flexible.

00:26:18.200 --> 00:26:20.000
You need to be able to go in
and make changes

00:26:20.000 --> 00:26:21.601
without injecting bugs.

00:26:21.601 --> 00:26:23.601
You need to be able to swap out
one piece for another.

00:26:23.601 --> 00:26:25.434
You need to be able to write
tools that can generate data

00:26:25.434 --> 00:26:27.200
that the game will use.

00:26:27.200 --> 00:26:28.534
You need to have a bunch
of infrastructure.

00:26:28.534 --> 00:26:29.734
But infrastructure often comes

00:26:29.734 --> 00:26:31.200
with a cost of performance,
right?

00:26:31.200 --> 00:26:34.701
As soon as you have all your
games serialized in XML,

00:26:34.701 --> 00:26:36.200
then you have to actually
load the XML

00:26:36.200 --> 00:26:37.400
and walk through
all those objects,

00:26:37.400 --> 00:26:39.033
and that's not
really fast, right?

00:26:39.033 --> 00:26:42.234
So at some point,
you're gonna have to choose

00:26:42.234 --> 00:26:43.801
between flexibility
and performance.

00:26:43.801 --> 00:26:46.801
And basically, I always err
on the side of flexibility

00:26:46.801 --> 00:26:49.000
until the game
starts to slow down

00:26:49.000 --> 00:26:52.200
and then I have to go back
into performance tuning.

00:26:52.200 --> 00:26:55.601
And the reason is that...

00:26:55.601 --> 00:26:57.601
if you can't tune the game,
it's not gonna be fun.

00:26:57.601 --> 00:26:59.634
And there's no point in making
a game that's not fun.

00:26:59.634 --> 00:27:02.267
The corollary to that
is if you make a fun game

00:27:02.267 --> 00:27:03.868
that runs at one frame
per second,

00:27:03.868 --> 00:27:05.267
nobody's gonna play it.

00:27:05.267 --> 00:27:07.467
So it's not all one
or the other.

00:27:07.467 --> 00:27:08.868
But if you have to choose,

00:27:08.868 --> 00:27:11.267
my general advice
is to stay on the side

00:27:11.267 --> 00:27:13.868
of flexibility
and then, you know,

00:27:13.868 --> 00:27:15.467
go back to performance
when you need it.

00:27:15.467 --> 00:27:16.868
And to enable that,

00:27:16.868 --> 00:27:18.667
my approach here,
which has served me very well,

00:27:18.667 --> 00:27:21.467
it to just implement everything
as simple as possible

00:27:21.467 --> 00:27:22.868
for the first iteration

00:27:22.868 --> 00:27:25.467
but keep all the hooks there
for swapping things out.

00:27:25.467 --> 00:27:28.267
So it's okay to do that
order N-search the first time

00:27:28.267 --> 00:27:30.267
and when that order N-search
shows up on your profiler,

00:27:30.267 --> 00:27:31.667
then it might be
a pretty good time

00:27:31.667 --> 00:27:33.467
to go back and replace it
with something smarter.

00:27:33.467 --> 00:27:35.467
And when you wrote that
order N-search, hopefully

00:27:35.467 --> 00:27:37.467
you wrote it in such a way
that it's very easy to replace

00:27:37.467 --> 00:27:39.067
without the calling code
knowing anything about it.

00:27:39.067 --> 00:27:41.467
So then that leads me to
the last point about this topic,

00:27:41.467 --> 00:27:43.667
and that's profile early
and constantly.

00:27:43.667 --> 00:27:46.400
And we have a bunch of profiling
tools I'll touch on

00:27:46.400 --> 00:27:47.868
in a little bit later,

00:27:47.868 --> 00:27:49.467
but if you make like a thing

00:27:49.467 --> 00:27:51.367
that accumulates
the amount of time

00:27:51.367 --> 00:27:52.934
that you're spending per frame

00:27:52.934 --> 00:27:54.868
and spits it out
every three seconds to log,

00:27:54.868 --> 00:27:56.434
that's fantastic,
that's all you need.

00:27:56.434 --> 00:27:58.501
I mean, you can write that
in about an hour.

00:27:58.501 --> 00:27:59.868
And you can hook it up

00:27:59.868 --> 00:28:01.300
into all your game systems
really early,

00:28:01.300 --> 00:28:02.767
and you should do that,

00:28:02.767 --> 00:28:04.200
and you should have
a constant understanding

00:28:04.200 --> 00:28:05.834
of where you are
in your game framerate.

00:28:05.834 --> 00:28:08.267
Because if you want until
the last minute

00:28:08.267 --> 00:28:11.934
to go look at why your game's
not fast enough,

00:28:11.934 --> 00:28:13.334
then you're gonna be screwed.

00:28:13.334 --> 00:28:16.334
It may be the case that you
have just one, you know,

00:28:16.334 --> 00:28:19.534
system that's like, oh, a repeat
from 1 to 1,000.

00:28:19.534 --> 00:28:21.133
But it may also be the case

00:28:21.133 --> 00:28:23.133
that it's a death
from a thousand cuts, right,

00:28:23.133 --> 00:28:25.801
and that you don't have any one
system that you can optimize.

00:28:25.801 --> 00:28:27.234
And that's a really difficult
position to be in.

00:28:27.234 --> 00:28:30.934
So I said, you know, print
your profile out really early

00:28:30.934 --> 00:28:33.534
and keep looking at it
and keep understanding,

00:28:33.534 --> 00:28:35.100
you know, what you're doing.

00:28:35.100 --> 00:28:37.534
One comment that I would
like to make about this point

00:28:37.534 --> 00:28:39.100
before I go on is that

00:28:39.100 --> 00:28:40.534
don't print your profile
to the screen.

00:28:40.534 --> 00:28:43.400
I see a lot of developers
make this mistake.

00:28:43.400 --> 00:28:46.934
Because it's really easy,
especially in Java, I think,

00:28:46.934 --> 00:28:48.868
to mess up
printing to the screen

00:28:48.868 --> 00:28:51.667
in a way that will
actually affect the output.

00:28:51.667 --> 00:28:53.534
Like you can very easily hurt
your framerate

00:28:53.534 --> 00:28:55.067
by printing it on the screen.

00:28:55.067 --> 00:28:56.934
And also,
it's not information

00:28:56.934 --> 00:28:58.501
that you really need to see
all the time.

00:28:58.501 --> 00:29:01.601
A heartbeat every three seconds
is sufficient.

00:29:01.601 --> 00:29:05.133
I had one guy that
I worked with who, you know,

00:29:05.133 --> 00:29:07.601
had been working on improving
his framerate for his game

00:29:07.601 --> 00:29:10.000
and it had gotten progressively
faster and faster and faster.

00:29:10.000 --> 00:29:12.033
Then he hit a wall, and he
couldn't figure out what it was.

00:29:12.033 --> 00:29:13.634
And when he went
and looked at it,

00:29:13.634 --> 00:29:15.334
it turned out that
all the string calculations

00:29:15.334 --> 00:29:17.100
he was doing to print the frames
per second counter

00:29:17.100 --> 00:29:18.400
out on the screen were causing

00:29:18.400 --> 00:29:19.801
all these allocations
to be created

00:29:19.801 --> 00:29:21.601
which was causing the GC to fire
all the time,

00:29:21.601 --> 00:29:23.400
which was slowing him down.

00:29:23.400 --> 00:29:25.467
So just a point of caution.

00:29:25.467 --> 00:29:28.734
Okay, so let's talk about

00:29:28.734 --> 00:29:32.567
ways to use Java that are not
very flexible but are very fast.

00:29:32.567 --> 00:29:35.868
Given that I gave you
the flexibility talk.

00:29:35.868 --> 00:29:37.567
Don't every allocate memory.

00:29:37.567 --> 00:29:39.801
Okay, you can allocate memory,
but don't release it.

00:29:39.801 --> 00:29:41.601
That's a little extreme,
right,

00:29:41.601 --> 00:29:44.200
but what's gonna happen is
when you allocate memory,

00:29:44.200 --> 00:29:46.234
every time you allocate memory,
the GC gets a chance to run.

00:29:46.234 --> 00:29:49.601
And the GC right now,
under Android 1.5,

00:29:49.601 --> 00:29:51.801
can take 100 to 300
milliseconds,

00:29:51.801 --> 00:29:53.400
even if there's nothing
to actually do.

00:29:53.400 --> 00:29:55.200
And it has to walk
the whole object map, right?

00:29:55.200 --> 00:29:58.400
So 300 milliseconds
at a 60 hertz game--

00:29:58.400 --> 00:30:00.000
I mean, the user's
gonna feel that.

00:30:00.000 --> 00:30:01.501
That's 1/3 of a second,
right?

00:30:01.501 --> 00:30:05.000
The user's gonna know
that the game just stopped,

00:30:05.000 --> 00:30:07.434
and that's absolute death
for real-time games.

00:30:07.434 --> 00:30:10.334
If you remember the video
I just showed you,

00:30:10.334 --> 00:30:12.267
if the robot's
jumping over a pit,

00:30:12.267 --> 00:30:14.200
and the game stops,
and then he falls into the pit,

00:30:14.200 --> 00:30:15.601
you know,
that's a bad game, right?

00:30:15.601 --> 00:30:18.267
The player's gonna stop
at that point.

00:30:18.267 --> 00:30:20.767
So you don't ever
really want the GC to fire.

00:30:20.767 --> 00:30:23.501
So, okay, go a little bit
less extreme.

00:30:23.501 --> 00:30:24.901
Allocate all your memory
up front.

00:30:24.901 --> 00:30:26.100
Allocate all your memory

00:30:26.100 --> 00:30:27.634
at a time when gameplay
is not going on.

00:30:27.634 --> 00:30:29.501
And don't allocate
and don't release

00:30:29.501 --> 00:30:31.834
while gameplay
is actually running.

00:30:31.834 --> 00:30:33.601
And memory pools
are your friend.

00:30:33.601 --> 00:30:35.467
This is not actually
a very hard problem to solve,

00:30:35.467 --> 00:30:36.634
and non-Java languages,

00:30:36.634 --> 00:30:38.234
we have to solve this
all the time anyway,

00:30:38.234 --> 00:30:40.667
so just, you know,

00:30:40.667 --> 00:30:41.667
make your memory pools.

00:30:41.667 --> 00:30:42.968
Pre-allocate all your objects.

00:30:42.968 --> 00:30:45.000
Reuse them. Don't actually
release the references.

00:30:45.000 --> 00:30:48.000
And when you are at a point
that you know you can pause,

00:30:48.000 --> 00:30:49.734
like in between level load

00:30:49.734 --> 00:30:51.701
or at a pause screen

00:30:51.701 --> 00:30:52.901
or sometime when the game

00:30:52.901 --> 00:30:55.000
is not running a simulation
at full tilt,

00:30:55.000 --> 00:30:57.434
that's when you should
manually invoke the GC.

00:30:57.434 --> 00:30:58.534
There's a command.

00:30:58.534 --> 00:31:00.534
I think
it's System.getRunTime,

00:31:00.534 --> 00:31:02.133
invokeGC,
or something like that.

00:31:02.133 --> 00:31:03.234
And it will just--

00:31:03.234 --> 00:31:04.834
You can cause it to run
whenever you want.

00:31:04.834 --> 00:31:07.767
Otherwise you don't know
when the GCs gonna run, right?

00:31:07.767 --> 00:31:10.901
You can't really predict

00:31:10.901 --> 00:31:13.400
if it's based on whatever
parameters it uses

00:31:13.400 --> 00:31:14.801
and how often
you allocate memory.

00:31:14.801 --> 00:31:16.834
So beware of memory allocation.

00:31:16.834 --> 00:31:19.601
Also, we have this
pretty fantastic tool

00:31:19.601 --> 00:31:21.067
that ships
with the Android SDK

00:31:21.067 --> 00:31:22.267
called DDMS.

00:31:22.267 --> 00:31:24.267
And it'll allow you
to track allocations

00:31:24.267 --> 00:31:26.334
pretty much in real-time
as your application runs.

00:31:26.334 --> 00:31:28.200
So you can run your game

00:31:28.200 --> 00:31:29.801
on your device
and have it plugged in,

00:31:29.801 --> 00:31:31.000
and you can boot up DDMS.

00:31:31.000 --> 00:31:33.400
Actually,
there's a tab in Eclipse

00:31:33.400 --> 00:31:34.601
for it now even.

00:31:34.601 --> 00:31:36.734
And you can hit
"start tracking allocations,"

00:31:36.734 --> 00:31:37.934
and when you hit stop,

00:31:37.934 --> 00:31:39.501
you'll get a list
of all the allocations

00:31:39.501 --> 00:31:41.300
that occurred, you know,

00:31:41.300 --> 00:31:43.634
in between those two
buttons clicks, right?

00:31:43.634 --> 00:31:44.801
And what you're gonna find out

00:31:44.801 --> 00:31:46.868
is that Java
allocates memory all the time

00:31:46.868 --> 00:31:48.200
in places
you would never expect.

00:31:48.200 --> 00:31:49.300
At least I never expected.

00:31:49.300 --> 00:31:51.501
Like you ask for the array
for an enum,

00:31:51.501 --> 00:31:52.501
like enum.values(),

00:31:52.501 --> 00:31:53.734
yeah, that allocates memory.

00:31:53.734 --> 00:31:55.934
And you're gonna use
a HashMap or an Iterator

00:31:55.934 --> 00:31:57.133
or anything from collections,

00:31:57.133 --> 00:31:58.133
that allocates memory.

00:31:58.133 --> 00:32:00.601
Arrays.sort(), really fast,

00:32:00.601 --> 00:32:03.067
but duplicates
the data it works on.

00:32:03.067 --> 00:32:05.901
Any kind of, like,
system library function

00:32:05.901 --> 00:32:08.033
where they want to give you back
an immutable reference,

00:32:08.033 --> 00:32:10.300
but there's no such thing as
an immutable reference in Java,

00:32:10.300 --> 00:32:11.300
so they have to copy it.

00:32:11.300 --> 00:32:14.334
You can really easily find out

00:32:14.334 --> 00:32:15.834
that you made a lot of mistakes.

00:32:15.834 --> 00:32:18.100
I had to go back and rewrite
a bunch of my code

00:32:18.100 --> 00:32:19.634
after I started using DDMS,

00:32:19.634 --> 00:32:20.667
so DDMS is fantastic.

00:32:20.667 --> 00:32:21.801
What you can do,

00:32:21.801 --> 00:32:23.701
is you can reduce
all the allocations

00:32:23.701 --> 00:32:25.167
that you do yourself
in your own code.

00:32:25.167 --> 00:32:26.567
Some of the stuff
that Java is doing

00:32:26.567 --> 00:32:30.400
is not gonna be avoidable,
and that's okay.

00:32:30.400 --> 00:32:32.601
We don't actually need to
get rid of 100% of allocations.

00:32:32.601 --> 00:32:34.234
We just want to get rid of,
like, 90% of them.

00:32:34.234 --> 00:32:37.467
So having a little bit
of, like, say, StringCchCat,

00:32:37.467 --> 00:32:40.667
or, you know,
a little bit of stuff

00:32:40.667 --> 00:32:43.133
that you can't stop anyway,
is fine.

00:32:43.133 --> 00:32:45.901
It's fine. You don't have
to worry about it.

00:32:45.901 --> 00:32:48.534
What you want to do
is keep the GC

00:32:48.534 --> 00:32:49.767
from running frequently.

00:32:49.767 --> 00:32:51.501
You know, if it runs once
every five minutes,

00:32:51.501 --> 00:32:52.767
that's still much better

00:32:52.767 --> 00:32:54.334
than running randomly
every 30 seconds

00:32:54.334 --> 00:32:55.934
or something like that.

00:32:55.934 --> 00:32:58.868
So my approach is basically
to treat Java like C++.

00:32:58.868 --> 00:32:59.968
And this is the point

00:32:59.968 --> 00:33:01.667
where I said I was gonna
offend everybody.

00:33:01.667 --> 00:33:04.734
This is--completely flies in
the face of the language design,

00:33:04.734 --> 00:33:05.934
which I completely understand

00:33:05.934 --> 00:33:07.334
and I sympathize with.

00:33:07.334 --> 00:33:09.234
But if you want
to make a fun game,

00:33:09.234 --> 00:33:12.000
making a fun game and having it
actually be fun to play

00:33:12.000 --> 00:33:14.067
is more important, I think,
than language security.

00:33:14.067 --> 00:33:16.968
So you can't really
use collections.

00:33:16.968 --> 00:33:19.167
You can't really use enums.

00:33:19.167 --> 00:33:21.667
They're a really bad idea anyway
for a lot of different reasons.

00:33:21.667 --> 00:33:24.934
Like I said, Arrays.sort()
allocates memory.

00:33:24.934 --> 00:33:28.400
Stuff like
Reflection.getClassNames,

00:33:28.400 --> 00:33:29.400
things like that.

00:33:29.400 --> 00:33:30.701
You can use these functions,

00:33:30.701 --> 00:33:32.534
but not as the game
is running, and not--

00:33:32.534 --> 00:33:34.467
And it's not like you have
to completely ban them,

00:33:34.467 --> 00:33:36.000
but what you have
to understand is that

00:33:36.000 --> 00:33:37.234
every time you allocate memory

00:33:37.234 --> 00:33:39.267
or any time one of these
functions allocate memory,

00:33:39.267 --> 00:33:40.534
the GCs getting a chance,
right?

00:33:40.534 --> 00:33:42.834
So I just avoid them completely.

00:33:42.834 --> 00:33:45.300
And actually,
once you're cognizant

00:33:45.300 --> 00:33:47.234
of this particular problem,

00:33:47.234 --> 00:33:48.234
it's pretty easy to avoid.

00:33:48.234 --> 00:33:50.367
As far as I know,

00:33:50.367 --> 00:33:54.167
I've not gotten the GC to run
during &lt;i&gt;Replica Island&lt;/i&gt; gameplay

00:33:54.167 --> 00:33:56.067
in about five months.

00:33:56.067 --> 00:33:59.067
So...I kind of have
these slides here

00:33:59.067 --> 00:34:03.133
just to let you know sort of
the extent of the problems

00:34:03.133 --> 00:34:04.567
that when you go
to write your games,

00:34:04.567 --> 00:34:06.133
you can, you know,
code appropriately.

00:34:06.133 --> 00:34:08.367
But absolutely use DDMS

00:34:08.367 --> 00:34:10.801
as your tool to find out where
allocations are coming from,

00:34:10.801 --> 00:34:12.601
'cause it's fantastic for that.

00:34:12.601 --> 00:34:15.834
Also, like I said,
I'm not really a Java engineer.

00:34:15.834 --> 00:34:17.367
I just sort of play one on TV,

00:34:17.367 --> 00:34:18.968
so I'm sure the rest of you

00:34:18.968 --> 00:34:20.934
could come up with much better
solutions than I did,

00:34:20.934 --> 00:34:22.601
you know,
like replacing implementations

00:34:22.601 --> 00:34:23.934
from the standard libraries

00:34:23.934 --> 00:34:25.767
with ones that don't
do allocations at runtime

00:34:25.767 --> 00:34:26.767
or come out of a pool,

00:34:26.767 --> 00:34:27.968
and those might, you know,

00:34:27.968 --> 00:34:29.534
allow you to go back
and use some of those

00:34:29.534 --> 00:34:30.801
standard library things

00:34:30.801 --> 00:34:32.801
without, you know,
having to rewrite everything.

00:34:32.801 --> 00:34:34.234
I don't actually
know how to do that.

00:34:34.234 --> 00:34:36.334
Okay, so step two,
don't call functions.

00:34:36.334 --> 00:34:39.167
Well, okay,
you can call functions,

00:34:39.167 --> 00:34:41.868
but you have to understand
that functions are not free.

00:34:41.868 --> 00:34:43.834
They kind of
don't teach you in school,

00:34:43.834 --> 00:34:45.434
at least when I went to school,

00:34:45.434 --> 00:34:47.501
they didn't really ever
touch on the fact

00:34:47.501 --> 00:34:49.300
that, you know,
functions might be expensive.

00:34:49.300 --> 00:34:51.200
And, in fact, in Java,
they're pretty expensive

00:34:51.200 --> 00:34:54.434
depending on what kind of
function you're calling, right?

00:34:54.434 --> 00:34:56.033
Don't ever call
interface functions.

00:34:56.033 --> 00:34:57.300
Those are really slow.

00:34:57.300 --> 00:34:59.100
Like, you call a function
through an interface,

00:34:59.100 --> 00:35:00.968
it has to go through an extra
lookup or something.

00:35:00.968 --> 00:35:02.167
It's 30% overhead.

00:35:02.167 --> 00:35:04.467
At least that's about
what I calculated.

00:35:04.467 --> 00:35:05.934
Your mileage may vary.

00:35:05.934 --> 00:35:08.968
But, like,
Accessors and Mutators,

00:35:08.968 --> 00:35:11.033
my "bestest" friends in C++,

00:35:11.033 --> 00:35:13.467
don't really belong
in your inner loop in Java,

00:35:13.467 --> 00:35:15.300
because you want to avoid--

00:35:15.300 --> 00:35:17.767
Any time you're in
a time-critical piece of code,

00:35:17.767 --> 00:35:19.033
you want to cut down

00:35:19.033 --> 00:35:20.801
the number of functions
that you're calling.

00:35:20.801 --> 00:35:22.567
So if that means
calling something once

00:35:22.567 --> 00:35:23.934
and assigning it
to a local variable

00:35:23.934 --> 00:35:26.033
and then using that for
the remainder of the function,

00:35:26.033 --> 00:35:27.334
that's great.

00:35:27.334 --> 00:35:29.167
If you can assign that local
variable at Bootstrap

00:35:29.167 --> 00:35:30.734
and then never
call that function again,

00:35:30.734 --> 00:35:32.367
that's even better, right?

00:35:32.367 --> 00:35:33.968
This is what I was talking about
when I said

00:35:33.968 --> 00:35:35.033
"death by a thousand cuts."

00:35:35.033 --> 00:35:37.601
If you architect your game
in a way

00:35:37.601 --> 00:35:39.167
that you would architect
any other sort

00:35:39.167 --> 00:35:41.000
of regular application,

00:35:41.000 --> 00:35:42.767
you'd probably end up
with a lot of, you know,

00:35:42.767 --> 00:35:44.033
general function calls.

00:35:44.033 --> 00:35:45.934
"Get this, set this,
put this over here," right?

00:35:45.934 --> 00:35:48.300
Yeah, you call those things a
couple 100,000 times per frame,

00:35:48.300 --> 00:35:49.734
and that's the end
of your frame rate.

00:35:49.734 --> 00:35:51.133
And then what
are you gonna do, right?

00:35:51.133 --> 00:35:52.200
It's not very easy to go back

00:35:52.200 --> 00:35:53.734
and change
all your functions, right?

00:35:53.734 --> 00:35:55.534
So beware.

00:35:55.534 --> 00:35:57.300
You also have to be
a little bit wary

00:35:57.300 --> 00:35:58.834
of JNI functions.

00:35:58.834 --> 00:36:01.968
JNI is the Java mechanism
for calling in to native code.

00:36:01.968 --> 00:36:03.634
And, actually,
the nice thing about it is,

00:36:03.634 --> 00:36:05.234
you know,
you're executing native code.

00:36:05.234 --> 00:36:06.367
Native code's really fast.

00:36:06.367 --> 00:36:08.267
So the contents of the function
are really fast,

00:36:08.267 --> 00:36:10.200
but actually calling it
is actually kind of slow.

00:36:10.200 --> 00:36:12.334
There's some pretty significant
overhead that occurs

00:36:12.334 --> 00:36:14.934
when you actually need
to invoke a native function.

00:36:14.934 --> 00:36:17.400
So in particular, like,
if you're calling

00:36:17.400 --> 00:36:24.400
OpenGL stuff
from inside of Java,

00:36:24.400 --> 00:36:26.234
you know,
all those gl.glXX() functions,

00:36:26.234 --> 00:36:28.234
all of those
are JNI functions, right?

00:36:28.234 --> 00:36:31.634
And it's really easy to get up
to several hundred OpenGL calls

00:36:31.634 --> 00:36:33.534
a frame
for a pretty simple scene,

00:36:33.534 --> 00:36:36.267
so this is something
you should be cognizant of.

00:36:36.267 --> 00:36:39.434
And one thing that
you may end up having to do

00:36:39.434 --> 00:36:41.000
that I've had to do
in a couple of cases,

00:36:41.000 --> 00:36:43.834
which,
as a sort of programmer,

00:36:43.834 --> 00:36:44.834
it really offends me,

00:36:44.834 --> 00:36:47.367
is just make fields public.

00:36:47.367 --> 00:36:51.033
And, like, that goes against
every, you know,

00:36:51.033 --> 00:36:52.868
kind of grain in my body,

00:36:52.868 --> 00:36:54.501
because I want to be
a defensive programmer,

00:36:54.501 --> 00:36:56.267
and I don't want to,
you know, write code

00:36:56.267 --> 00:36:58.934
that is susceptible
to easily ejectable bugs,

00:36:58.934 --> 00:36:59.934
but on the other hand,

00:36:59.934 --> 00:37:01.334
gameplay's king, right?

00:37:01.334 --> 00:37:03.501
I mean, there's no point
in making a game

00:37:03.501 --> 00:37:04.901
if it's not gonna be fun.

00:37:04.901 --> 00:37:06.334
And if you find, you know,

00:37:06.334 --> 00:37:07.868
you run your profiler
like I told you to

00:37:07.868 --> 00:37:11.634
and you find out
that accessing this one field,

00:37:11.634 --> 00:37:13.467
like, the position
of the player, for example,

00:37:13.467 --> 00:37:16.033
is happening, you know,
100,000 times a frame,

00:37:16.033 --> 00:37:17.400
then you could, you know,

00:37:17.400 --> 00:37:19.467
you might be able to get
some pretty serious time back

00:37:19.467 --> 00:37:22.767
by just making
that field public.

00:37:22.767 --> 00:37:24.868
Here's a graph.

00:37:24.868 --> 00:37:26.801
It's not a very scientific test,

00:37:26.801 --> 00:37:28.367
so I didn't put any numbers
on the graph,

00:37:28.367 --> 00:37:34.467
but I think that the sort of
relative costs

00:37:34.467 --> 00:37:36.701
of these types of functions
is correct.

00:37:36.701 --> 00:37:38.834
Basically, what this means
is you call a local function

00:37:38.834 --> 00:37:40.501
or you call a function
from a derived class

00:37:40.501 --> 00:37:42.033
or you call
a virtual function of Java,

00:37:42.033 --> 00:37:43.200
it's all kind of the same cost.

00:37:43.200 --> 00:37:44.534
You can an interface class,

00:37:44.534 --> 00:37:48.801
you all of a sudden incur
this sort of 30% overhead.

00:37:48.801 --> 00:37:52.200
And then you call through JNI
that overhead's even higher.

00:37:52.200 --> 00:37:55.601
Just to illustrate
what I already said.

00:37:55.601 --> 00:37:58.767
Okay, so a couple
of other tips about Java,

00:37:58.767 --> 00:37:59.968
and then
I'll shut up about it.

00:37:59.968 --> 00:38:02.601
Local variables
are your friend.

00:38:02.601 --> 00:38:05.901
Even better than member
variables are local variables.

00:38:05.901 --> 00:38:08.434
Use the final keyword
anywhere you can.

00:38:08.434 --> 00:38:12.033
That's, like, you know,
I think CS 101,

00:38:12.033 --> 00:38:13.567
but I thought
I'd reiterate it anyway.

00:38:13.567 --> 00:38:16.968
You know, the G1 and other
Android hardware devices

00:38:16.968 --> 00:38:18.701
at the moment don't have an FPU,

00:38:18.701 --> 00:38:20.434
so if you do any kind
of float math,

00:38:20.434 --> 00:38:22.167
that's gonna be done in software

00:38:22.167 --> 00:38:23.534
by an FPU emulator.

00:38:23.534 --> 00:38:25.901
So if you're really interested
in absolute performance,

00:38:25.901 --> 00:38:28.033
you could consider
using fixed-point math.

00:38:28.033 --> 00:38:29.501
I actually
don't care this much.

00:38:29.501 --> 00:38:31.267
This is a point
where I chose flexibility

00:38:31.267 --> 00:38:32.367
over absolute performance.

00:38:32.367 --> 00:38:33.801
I just go ahead
and do the float math,

00:38:33.801 --> 00:38:37.934
and it's really hard to gauge
how much that costs me

00:38:37.934 --> 00:38:39.267
in terms of my frame rate,

00:38:39.267 --> 00:38:42.701
but I don't believe it
to be very high.

00:38:42.701 --> 00:38:48.734
Another point that's just
sort of unique to Android,

00:38:48.734 --> 00:38:52.400
is that the regular
Java print mechanism,

00:38:52.400 --> 00:38:53.934
System.out.print(), I guess,

00:38:53.934 --> 00:38:55.033
is actually fairly slow,

00:38:55.033 --> 00:38:57.033
and you should use Log.d()
or Log.e()

00:38:57.033 --> 00:38:58.467
or one of these
other log equivalents

00:38:58.467 --> 00:39:00.000
that we give you
to print out the log caps,

00:39:00.000 --> 00:39:01.067
'cause it's way faster.

00:39:01.067 --> 00:39:02.133
And that's another example

00:39:02.133 --> 00:39:03.834
of where you could
unintentionally

00:39:03.834 --> 00:39:05.000
sort of screw your frame rate,

00:39:05.000 --> 00:39:06.501
but you're just trying
to produce logs.

00:39:06.501 --> 00:39:07.601
And then use Traceview.

00:39:07.601 --> 00:39:08.767
I mean,
this is the best part.

00:39:08.767 --> 00:39:13.801
We ship a pretty
full-fledged profiler

00:39:13.801 --> 00:39:15.234
with the Android SDK,

00:39:15.234 --> 00:39:16.234
and, even better,

00:39:16.234 --> 00:39:17.934
you can turn profiling
on and off

00:39:17.934 --> 00:39:19.400
with just this little
function call,

00:39:19.400 --> 00:39:21.100
so you can make,
like, a menu item

00:39:21.100 --> 00:39:22.767
in your little menu
that pops up

00:39:22.767 --> 00:39:25.100
that says, you know,
"toggle method profiling,"

00:39:25.100 --> 00:39:27.234
and that will let you go
to some little spot in your game

00:39:27.234 --> 00:39:28.667
that you notice
appears to be slow,

00:39:28.667 --> 00:39:29.767
and turn on, you know,

00:39:29.767 --> 00:39:31.133
method tracing
right at that spot,

00:39:31.133 --> 00:39:32.701
and as soon as you
turn on method tracing,

00:39:32.701 --> 00:39:34.400
your frame rate's
gonna fall through the floor

00:39:34.400 --> 00:39:35.701
'cause that's really expensive.

00:39:35.701 --> 00:39:37.968
But you can, you know,
generate this trace file

00:39:37.968 --> 00:39:40.300
just in the area
that you're interested in,

00:39:40.300 --> 00:39:42.000
and then go back
and look at it in Traceview.

00:39:42.000 --> 00:39:44.033
And the numbers for, like,
how long it actually took

00:39:44.033 --> 00:39:45.133
to call a function,

00:39:45.133 --> 00:39:46.734
you should probably
just ignore those,

00:39:46.734 --> 00:39:48.033
because method tracing goes on,

00:39:48.033 --> 00:39:49.634
and the actual,
you know, seconds value

00:39:49.634 --> 00:39:51.067
is probably not very useful,

00:39:51.067 --> 00:39:53.801
but the number of times that
a particular function was called

00:39:53.801 --> 00:39:55.767
and who its parents were
and who its children were,

00:39:55.767 --> 00:39:57.601
and what percentage
of the total time they were,

00:39:57.601 --> 00:39:58.767
that's super valuable.

00:39:58.767 --> 00:40:00.367
And you get
these cool graphs too, right?

00:40:00.367 --> 00:40:01.534
So absolutely use this tool.

00:40:01.534 --> 00:40:04.601
The fact that we
actually have this tool

00:40:04.601 --> 00:40:05.834
is really great.

00:40:05.834 --> 00:40:07.634
Usually we write this stuff
ourselves, right?

00:40:07.634 --> 00:40:09.734
Okay, so let's talk
about rendering.

00:40:09.734 --> 00:40:13.767
This is a screenshot
from the sample that I wrote.

00:40:13.767 --> 00:40:14.767
I alluded to it earlier.

00:40:14.767 --> 00:40:15.834
Called SpriteMethodTest,

00:40:15.834 --> 00:40:17.300
and what it does is,

00:40:17.300 --> 00:40:19.334
it just tries to draw sprites 
on the screen really fast,

00:40:19.334 --> 00:40:21.400
and it sort of animates them
and bounces them around.

00:40:21.400 --> 00:40:23.968
And what it does is,

00:40:23.968 --> 00:40:25.300
it lets you choose--

00:40:25.300 --> 00:40:27.133
There's a bunch of different
rendering mechanisms

00:40:27.133 --> 00:40:28.667
in Android that I'm
gonna cover in a minute,

00:40:28.667 --> 00:40:30.067
and it lets you choose
each of them,

00:40:30.067 --> 00:40:31.067
or a subset of them,

00:40:31.067 --> 00:40:32.968
and run the same test

00:40:32.968 --> 00:40:34.601
with pretty much
the same output,

00:40:34.601 --> 00:40:39.901
and then compare the results
to see, you know, what's faster.

00:40:39.901 --> 00:40:41.267
So this is what it looks like

00:40:41.267 --> 00:40:43.734
if you run with a thousand
sprites on the screen

00:40:43.734 --> 00:40:46.834
and you use the
draw_texture OpenGL extension,

00:40:46.834 --> 00:40:48.234
which is available on the G1.

00:40:48.234 --> 00:40:50.634
And with a thousand sprites
on the screen and a background,

00:40:50.634 --> 00:40:54.133
it runs about
ten frames a second on the G1.

00:40:54.133 --> 00:40:56.033
So, and, you know,

00:40:56.033 --> 00:40:57.968
I'll put the URL up for that,

00:40:57.968 --> 00:40:59.133
so you can test it yourself

00:40:59.133 --> 00:41:01.934
on your new devices
at the end of this part.

00:41:01.934 --> 00:41:06.267
So, basically, you have two
methods for drawing on Android.

00:41:06.267 --> 00:41:07.334
The first is Canvas,

00:41:07.334 --> 00:41:11.100
which is a very slick,
very easy to use

00:41:11.100 --> 00:41:14.501
software-based
drawing mechanism,

00:41:14.501 --> 00:41:16.601
which is how most
of the Android UI is drawn.

00:41:16.601 --> 00:41:19.100
It's pretty easy
to get into Canvas

00:41:19.100 --> 00:41:20.767
and start drawing lines
and making things

00:41:20.767 --> 00:41:22.434
and, you know,
copying images in there

00:41:22.434 --> 00:41:23.901
and rotating them.

00:41:23.901 --> 00:41:26.234
And, actually, considering
that it's all done on the CPU,

00:41:26.234 --> 00:41:27.367
it's pretty fast.

00:41:27.367 --> 00:41:28.968
If you don't have a lot
of drawing to do,

00:41:28.968 --> 00:41:31.501
like, for example,
in the SpriteMethodTest case,

00:41:31.501 --> 00:41:33.033
under about ten sprites,

00:41:33.033 --> 00:41:34.033
easily hit 60 hertz,

00:41:34.033 --> 00:41:35.634
just using the software
implementation.

00:41:35.634 --> 00:41:37.501
Don't have to worry
about OpenGL stuff.

00:41:37.501 --> 00:41:40.968
And Canvas is by far the easier
of the two mechanisms to use.

00:41:40.968 --> 00:41:42.634
It's easy to set up.
It's easy to tear down.

00:41:42.634 --> 00:41:44.901
There's already, you know,
hooks for it in the main thread

00:41:44.901 --> 00:41:46.634
if you don't want to make
a rendering thread,

00:41:46.634 --> 00:41:48.167
although I recommend you do.

00:41:48.167 --> 00:41:50.467
So, you know, if you're making
a &lt;i&gt;Bejeweled&lt;/i&gt; clone...

00:41:50.467 --> 00:41:51.667
I mean,
you can make something

00:41:51.667 --> 00:41:53.334
more interesting
than &lt;i&gt;Bejeweled,&lt;/i&gt; right?

00:41:53.334 --> 00:41:54.834
But if you're making
a &lt;i&gt;Bejeweled&lt;/i&gt; clone,

00:41:54.834 --> 00:41:57.434
you know, Canvas will probably
meet all of your needs.

00:41:57.434 --> 00:41:59.767
Then the other option
is OpenGL ES.

00:41:59.767 --> 00:42:03.501
So, obviously, you can use
OpenGL for 3D drawing.

00:42:03.501 --> 00:42:05.067
You can also use it
for 2D drawing.

00:42:05.067 --> 00:42:07.968
It's accelerated on platforms
that have hardware acceleration,

00:42:07.968 --> 00:42:09.934
like the G1.

00:42:09.934 --> 00:42:11.767
And other platforms
in the future,

00:42:11.767 --> 00:42:13.467
if they don't have
hardware acceleration,

00:42:13.467 --> 00:42:15.133
like for example,
you run in the emulator,

00:42:15.133 --> 00:42:16.968
then there's a software renderer

00:42:16.968 --> 00:42:18.667
that is supplied.

00:42:18.667 --> 00:42:22.367
It does scale to much more
complicated scenes than Canvas.

00:42:22.367 --> 00:42:25.067
Because the actual
composition of the frame

00:42:25.067 --> 00:42:26.400
is done in hardware,

00:42:26.400 --> 00:42:28.334
and the hardware's pretty good
at doing that.

00:42:28.334 --> 00:42:31.734
So you can get 1,000, you know,
sprites on the screen

00:42:31.734 --> 00:42:33.534
at ten frames per second.

00:42:33.534 --> 00:42:35.501
In OpenGL, there's no way
you could get

00:42:35.501 --> 00:42:37.601
anywhere close to that speed
in Canvas.

00:42:37.601 --> 00:42:40.033
It's considerably
more complicated to use.

00:42:40.033 --> 00:42:42.167
There's some setup
and tear-down.

00:42:42.167 --> 00:42:44.701
You've got to copy your textures
into video memory,

00:42:44.701 --> 00:42:46.634
and you have to watch out
for the case

00:42:46.634 --> 00:42:48.033
where your video memory
got trashed

00:42:48.033 --> 00:42:50.000
because another application
came up in front of yours,

00:42:50.000 --> 00:42:51.601
and then you have
to reload your textures.

00:42:51.601 --> 00:42:52.934
Things like that.

00:42:52.934 --> 00:42:54.601
There's a little bit
of work to do for the setup,

00:42:54.601 --> 00:42:55.934
but then once
it's up and running,

00:42:55.934 --> 00:42:57.934
the actual API to draw things

00:42:57.934 --> 00:42:59.701
is not
that much more complicated.

00:42:59.701 --> 00:43:02.300
So with OpenGL, we get actually
a lot of different ways

00:43:02.300 --> 00:43:03.734
we can draw things in 2D.

00:43:03.734 --> 00:43:06.634
The easy, most,
you know, basic case,

00:43:06.634 --> 00:43:08.968
is just to make,
like, a 2D quad,

00:43:08.968 --> 00:43:10.734
just a square of verts,

00:43:10.734 --> 00:43:12.634
and, you know,
put a texture on it,

00:43:12.634 --> 00:43:15.400
and just draw that using
an orthographic projection.

00:43:15.400 --> 00:43:18.801
And that's like the OpenGL 1.0,

00:43:18.801 --> 00:43:22.434
or, like, 101 type of approach
to drawing sprites.

00:43:22.434 --> 00:43:23.968
And that works, you know.

00:43:23.968 --> 00:43:27.100
The other way is we could
use vertex buffer objects,

00:43:27.100 --> 00:43:29.100
which are basically
exactly the same thing,

00:43:29.100 --> 00:43:30.501
except you take
that vertex buffer

00:43:30.501 --> 00:43:32.267
that describes
your little square,

00:43:32.267 --> 00:43:34.000
and you throw it
in video memory.

00:43:34.000 --> 00:43:36.400
And then it doesn't have to get
sent down the bus every frame,

00:43:36.400 --> 00:43:37.701
and the card
just has it in memory,

00:43:37.701 --> 00:43:39.067
and it's already
in a native format,

00:43:39.067 --> 00:43:40.501
and they can draw it faster.

00:43:40.501 --> 00:43:43.834
Thing about VBOs is that
they're not actually supported

00:43:43.834 --> 00:43:46.167
as part of OpenGL ES 1.0,

00:43:46.167 --> 00:43:49.033
and Android guarantees
OpenGL ES 1.0,

00:43:49.033 --> 00:43:50.534
but not anything above that.

00:43:50.534 --> 00:43:53.234
So if you want to use
that type of extension,

00:43:53.234 --> 00:43:54.501
it's available on the G1.

00:43:54.501 --> 00:43:58.067
You need to check to see
if that extension exists,

00:43:58.067 --> 00:43:59.968
because you could be running
on some future device

00:43:59.968 --> 00:44:01.300
that we don't know about yet

00:44:01.300 --> 00:44:03.767
that doesn't actually support
that extension.

00:44:03.767 --> 00:44:06.267
And how do we choose
which extensions are supported?

00:44:06.267 --> 00:44:07.701
Well, we don't.

00:44:07.701 --> 00:44:10.167
The people who write the OpenGL
driver for the specific device

00:44:10.167 --> 00:44:11.534
get to choose, right?

00:44:11.534 --> 00:44:14.000
So the G1's, you know,
extensions that it supports,

00:44:14.000 --> 00:44:16.000
it actually supports
quite a number of extensions,

00:44:16.000 --> 00:44:19.300
are all based on what the driver
that Qualcomm supplied us--

00:44:19.300 --> 00:44:20.834
supports, right?

00:44:20.834 --> 00:44:23.133
So whenever you use
any kind of extension,

00:44:23.133 --> 00:44:24.334
with VBOs--
I'm gonna talk about

00:44:24.334 --> 00:44:26.300
draw_texture
in a minute as well--

00:44:26.300 --> 00:44:28.067
you need to test the...

00:44:28.067 --> 00:44:30.934
I think it's
glGetString(GL_EXTENSIONS).

00:44:30.934 --> 00:44:32.467
I have that in the next slide,
I think.

00:44:32.467 --> 00:44:34.200
That will just be a string

00:44:34.200 --> 00:44:35.734
of the extensions
that are supported,

00:44:35.734 --> 00:44:37.033
and you need to,
like, grep that,

00:44:37.033 --> 00:44:38.467
to make sure
that the functionality

00:44:38.467 --> 00:44:40.300
you want to use
is actually available

00:44:40.300 --> 00:44:41.534
in the device you're running on.

00:44:41.534 --> 00:44:43.200
If you don't do that,
and you run on a device

00:44:43.200 --> 00:44:44.367
that doesn't have that thing,

00:44:44.367 --> 00:44:46.267
your game's gonna crash, right?

00:44:46.267 --> 00:44:49.467
Fortunately, for something
like VBOs and quads,

00:44:49.467 --> 00:44:51.534
the actual interface
is so similar

00:44:51.534 --> 00:44:53.200
that it's pretty easy
to write your code

00:44:53.200 --> 00:44:55.567
such that you can fall back
on the 1.0 implementation,

00:44:55.567 --> 00:44:57.367
if the, you know,
1.1 one doesn't exist.

00:44:57.367 --> 00:44:59.167
And then there's
the draw_texture extension,

00:44:59.167 --> 00:45:01.734
which is another extension that
you have to check existence for.

00:45:01.734 --> 00:45:02.934
And what it does is,

00:45:02.934 --> 00:45:04.767
it sort of just blits textures
to the screen.

00:45:04.767 --> 00:45:06.000
It's very fast.

00:45:06.000 --> 00:45:07.968
The disadvantage
to the draw_texture extension

00:45:07.968 --> 00:45:09.868
is it can't do rotation,
I think.

00:45:09.868 --> 00:45:12.234
So here's a graph
of the relative speeds

00:45:12.234 --> 00:45:13.767
of these drawing mechanisms.

00:45:13.767 --> 00:45:15.567
This is basically
straight output

00:45:15.567 --> 00:45:17.534
from that SpriteMethodTest.

00:45:17.534 --> 00:45:20.467
At ten, what we have
on the left side

00:45:20.467 --> 00:45:22.334
is the number of Sprites
that it's drawing,

00:45:22.334 --> 00:45:23.767
and on the bottom axis

00:45:23.767 --> 00:45:25.701
is the number
of milliseconds it took.

00:45:25.701 --> 00:45:26.934
And keep in mind

00:45:26.934 --> 00:45:29.701
that 16 milliseconds
is where you have to be

00:45:29.701 --> 00:45:31.300
in order to get 60 hertz.

00:45:31.300 --> 00:45:33.634
32 milliseconds is where you
need to be to give you 30 hertz.

00:45:33.634 --> 00:45:35.767
So anything slower
than 32 milliseconds

00:45:35.767 --> 00:45:37.767
is probably gonna be an
unplayable real-time game,

00:45:37.767 --> 00:45:41.634
unless you're making a game that
isn't really that real-time.

00:45:41.634 --> 00:45:43.834
So, you know,
faster is better, right?

00:45:43.834 --> 00:45:44.968
So if we look at ten sprites,

00:45:44.968 --> 00:45:46.400
all of them
are pretty much the same.

00:45:46.400 --> 00:45:47.834
And the reason
they're all the same

00:45:47.834 --> 00:45:49.200
is that,
like I said before,

00:45:49.200 --> 00:45:52.300
the hardware's gonna block
on the page flip, right?

00:45:52.300 --> 00:45:54.434
On the previous frame
completing drawing.

00:45:54.434 --> 00:45:56.000
So with ten sprites,

00:45:56.000 --> 00:45:57.434
all of these methods,

00:45:57.434 --> 00:46:00.801
draw_texture and VBOs
and the Basic Quads and Canvas,

00:46:00.801 --> 00:46:02.501
can actually generate the frame

00:46:02.501 --> 00:46:04.133
in probably less than
60 milliseconds,

00:46:04.133 --> 00:46:05.501
and then the remainder
of the time

00:46:05.501 --> 00:46:07.534
it comes from
the hardware blocking.

00:46:07.534 --> 00:46:10.601
When we get up to 50 sprites,

00:46:10.601 --> 00:46:13.000
you can already see that Canvas
is starting to take off, right?

00:46:13.000 --> 00:46:15.100
It's already starting
to slow down.

00:46:15.100 --> 00:46:17.801
And you can see,
real dramatically,

00:46:17.801 --> 00:46:19.601
as we get up to, like,
you know, 1,000 sprites,

00:46:19.601 --> 00:46:22.067
that Canvas is totally host.

00:46:22.067 --> 00:46:25.067
Actually,
the Basic Quads approach

00:46:25.067 --> 00:46:26.067
is totally host too.

00:46:26.067 --> 00:46:27.267
This is on the G1.

00:46:27.267 --> 00:46:28.901
It might be different
on other platforms.

00:46:28.901 --> 00:46:30.000
But for the G1, you know,

00:46:30.000 --> 00:46:31.801
that's almost
as slow as Canvas,

00:46:31.801 --> 00:46:33.400
even though it's
hardware-accelerated.

00:46:33.400 --> 00:46:35.133
VBOs actually hang in there
pretty good.

00:46:35.133 --> 00:46:37.400
They're, you know,
easily twice as fast

00:46:37.400 --> 00:46:39.901
as the non-VBO version
of the same quads.

00:46:39.901 --> 00:46:42.334
And the draw_texture
just totally kicks ass.

00:46:42.334 --> 00:46:44.067
It does, you know,
slow down.

00:46:44.067 --> 00:46:45.901
"Oh, you've dropped down
to ten frames a second

00:46:45.901 --> 00:46:47.801
when they have a thousand
sprites on the screen."

00:46:47.801 --> 00:46:49.667
But ten frames a second
is only 90 milliseconds.

00:46:49.667 --> 00:46:55.634
Way better than
362 milliseconds for Canvas.

00:46:55.634 --> 00:46:58.200
So, short answer is
you should use draw_texture,

00:46:58.200 --> 00:46:59.601
right?

00:46:59.601 --> 00:47:03.200
Especially if you're making
a game that's 2D.

00:47:03.200 --> 00:47:06.133
For &lt;i&gt;Replica Island,&lt;/i&gt;

00:47:06.133 --> 00:47:08.767
I used draw_texture for all
of the sprites on the screen,

00:47:08.767 --> 00:47:11.067
and, actually, I talk about
how I rendered the background.

00:47:11.067 --> 00:47:13.300
I experimented with draw_texture
for that as well.

00:47:13.300 --> 00:47:16.367
And here's that thing
I already said.

00:47:16.367 --> 00:47:19.334
You must check this
glGetString(GL10.GL_EXTENSIONS)

00:47:19.334 --> 00:47:21.000
before you start
using these extensions,

00:47:21.000 --> 00:47:23.067
otherwise you won't
be future-proof.

00:47:23.067 --> 00:47:25.367
However, like I said,
Canvas is really easy to use,

00:47:25.367 --> 00:47:26.834
and it might be
a total win for you

00:47:26.834 --> 00:47:28.801
if you don't have
to update things every frame,

00:47:28.801 --> 00:47:30.200
or you have a type of game

00:47:30.200 --> 00:47:32.267
where you have very few things
to draw every frame.

00:47:32.267 --> 00:47:34.133
Because for small data sets,

00:47:34.133 --> 00:47:36.367
it's more than capable.

00:47:36.367 --> 00:47:38.834
So this is the URL
for the SpriteMethodTests

00:47:38.834 --> 00:47:40.300
that I made.

00:47:40.300 --> 00:47:43.033
If you got a version of it
before about yesterday,

00:47:43.033 --> 00:47:45.801
it actually contained a bug
that I'm gonna talk about

00:47:45.801 --> 00:47:47.100
at the end of this talk,

00:47:47.100 --> 00:47:48.534
so you should grab
the source again.

00:47:48.534 --> 00:47:50.434
But it's up on
code.google.com,

00:47:50.434 --> 00:47:53.467
and you can download it,
and you can look at it.

00:47:53.467 --> 00:47:55.167
It kind of provides
a framework, also,

00:47:55.167 --> 00:47:56.834
for how you might build
a 2D game.

00:47:56.834 --> 00:47:58.734
It's very similar to what
I ended up writing

00:47:58.734 --> 00:47:59.734
for &lt;i&gt;Replica Island.&lt;/i&gt;

00:47:59.734 --> 00:48:01.200
But it let's you, you know,

00:48:01.200 --> 00:48:03.400
sort of generate an activity,

00:48:03.400 --> 00:48:06.133
then just swap out the rendering
mechanism pretty easily

00:48:06.133 --> 00:48:10.334
using the same
sort of simulation code.

00:48:10.334 --> 00:48:12.267
Okay, so I want to talk
a little bit about

00:48:12.267 --> 00:48:15.267
how I drew the backgrounds
for &lt;i&gt;Replica Island.&lt;/i&gt;

00:48:15.267 --> 00:48:16.968
And the reason that I want
to talk about this

00:48:16.968 --> 00:48:18.667
is that background drawing
ends up being

00:48:18.667 --> 00:48:19.834
the most expensive operation

00:48:19.834 --> 00:48:21.200
in drawing by frame.

00:48:21.200 --> 00:48:23.067
It's more expensive
than drawing with sprites.

00:48:23.067 --> 00:48:25.434
It's more expensive than
calculating collision detection.

00:48:25.434 --> 00:48:26.434
It's costly.

00:48:26.434 --> 00:48:28.601
So the way &lt;i&gt;Replica Island&lt;/i&gt; works

00:48:28.601 --> 00:48:30.367
is there's actually
three parallax layers.

00:48:30.367 --> 00:48:32.100
One of them's just
a static bitmap.

00:48:32.100 --> 00:48:33.968
It's actually slightly larger
than the screen,

00:48:33.968 --> 00:48:35.167
so it scrolls, but very slowly.

00:48:35.167 --> 00:48:37.033
The second is a mid-ground layer

00:48:37.033 --> 00:48:39.434
that scrolls at some speed
slower than the main camera

00:48:39.434 --> 00:48:40.934
to sort of give
the illusion of depth,

00:48:40.934 --> 00:48:43.200
and then the foreground layer
is kind of what the character

00:48:43.200 --> 00:48:44.334
is standing on.

00:48:44.334 --> 00:48:47.067
It would be nice to have
more layers, right?

00:48:47.067 --> 00:48:48.367
Because then
I could have, like,

00:48:48.367 --> 00:48:49.734
a layer in front
of the character,

00:48:49.734 --> 00:48:50.801
like, a shadow layer,

00:48:50.801 --> 00:48:52.234
or some trees
that go in front of you,

00:48:52.234 --> 00:48:53.234
or something like that.

00:48:53.234 --> 00:48:54.834
But at this point,

00:48:54.834 --> 00:48:56.968
the game is not
quite fast enough for me

00:48:56.968 --> 00:48:58.400
to increase
the number of layers

00:48:58.400 --> 00:49:00.567
without having to decrease
something else.

00:49:00.567 --> 00:49:02.801
So if I decided to trade
the number of enemies

00:49:02.801 --> 00:49:04.601
I'm gonna put on the screen
for another layer,

00:49:04.601 --> 00:49:05.901
I could do that.

00:49:05.901 --> 00:49:10.067
But given the sort of
game fidelity that I want,

00:49:10.067 --> 00:49:12.267
I decided to cap it
at three layers.

00:49:12.267 --> 00:49:15.400
So each layer besides
the very background one,

00:49:15.400 --> 00:49:17.033
is drawn out of tiles,

00:49:17.033 --> 00:49:20.968
these little, small,
32x32 pixel squares, right?

00:49:20.968 --> 00:49:22.000
And those are reusable,

00:49:22.000 --> 00:49:23.234
and the reason
to do it that way

00:49:23.234 --> 00:49:25.167
is that then you can have
levels of any size.

00:49:25.167 --> 00:49:28.000
Your level just ends up
being this big array

00:49:28.000 --> 00:49:29.200
of tile and indexes,

00:49:29.200 --> 00:49:30.567
and all you have to do to draw

00:49:30.567 --> 00:49:32.667
is figure out which part
of that array you're looking at

00:49:32.667 --> 00:49:34.067
given the camera,

00:49:34.067 --> 00:49:36.033
and then just go draw those
textures in the right spot,

00:49:36.033 --> 00:49:37.667
so you're not limited
by the size of VRAM,

00:49:37.667 --> 00:49:39.467
you're not limited
by the size of main memory.

00:49:39.467 --> 00:49:41.801
I guess you are,
but the actual tile map

00:49:41.801 --> 00:49:43.067
is very small.

00:49:43.067 --> 00:49:45.000
And the actual level maps
end up being very small,

00:49:45.000 --> 00:49:47.400
like 4k.

00:49:47.400 --> 00:49:50.033
So you can make levels
of pretty much any size.

00:49:50.033 --> 00:49:51.868
The bad part about this

00:49:51.868 --> 00:49:53.400
is that if you're gonna
draw a layer

00:49:53.400 --> 00:49:55.367
that is completely full
of tiles,

00:49:55.367 --> 00:49:58.000
that means you're gonna make,
like, 150 calls

00:49:58.000 --> 00:50:01.000
to this, like,
draw_texture extension,

00:50:01.000 --> 00:50:03.100
or whatever method
you choose to use,

00:50:03.100 --> 00:50:05.801
because each one of those tiles

00:50:05.801 --> 00:50:07.400
has to get drawn.

00:50:07.400 --> 00:50:08.968
And 150 calls to OpenGL,

00:50:08.968 --> 00:50:10.901
just right there,
based on the previous side,

00:50:10.901 --> 00:50:13.133
you should know that those
are all JNI calls,

00:50:13.133 --> 00:50:15.534
and no matter what
they actually do under the hood,

00:50:15.534 --> 00:50:17.467
I'm incurring some costs
to call those functions

00:50:17.467 --> 00:50:18.667
150 times per layer,

00:50:18.667 --> 00:50:20.267
and I have two layers
that are like this,

00:50:20.267 --> 00:50:23.868
so you know, that's 300 calls
per frame, right?

00:50:23.868 --> 00:50:25.167
That might be pretty costly.

00:50:25.167 --> 00:50:27.000
The other thing that I
actually did not run into

00:50:27.000 --> 00:50:29.234
but you could run into
on this sort of thing

00:50:29.234 --> 00:50:30.934
is that, you know,
some GL implementations

00:50:30.934 --> 00:50:33.200
have a fixed amount
of command buffer size,

00:50:33.200 --> 00:50:34.667
and if you overflow that,

00:50:34.667 --> 00:50:37.834
then it's gonna start drawing
before you're finished.

00:50:37.834 --> 00:50:39.367
Actually, I never hit that,

00:50:39.367 --> 00:50:41.834
but having that many GL calls

00:50:41.834 --> 00:50:43.934
for my sort of
rather simple frame

00:50:43.934 --> 00:50:46.067
seemed kind of wrong.

00:50:46.067 --> 00:50:48.267
So I tried a bunch
of different ways.

00:50:48.267 --> 00:50:49.834
Here's what
those layers look like.

00:50:49.834 --> 00:50:51.033
There's the background image,

00:50:51.033 --> 00:50:52.267
and then there's the mid-ground,

00:50:52.267 --> 00:50:53.667
and there's the foreground,
right?

00:50:53.667 --> 00:50:55.400
I tried to render this
a bunch of different ways,

00:50:55.400 --> 00:50:57.601
because it's pretty slow,
and I wanted to make it better.

00:50:57.601 --> 00:51:00.801
And this is what they look like
when they get composited right.

00:51:00.801 --> 00:51:04.467
So I started out with
a really simple approach,

00:51:04.467 --> 00:51:08.167
and that was just to take this
thing called an atlas texture,

00:51:08.167 --> 00:51:09.367
which is just a texture

00:51:09.367 --> 00:51:11.000
that contains
all of the possible tiles

00:51:11.000 --> 00:51:12.234
in this particular level,

00:51:12.234 --> 00:51:14.000
and then use this
draw_texture extension

00:51:14.000 --> 00:51:15.434
to draw all the tiles
individually.

00:51:15.434 --> 00:51:16.567
And what I was gonna do

00:51:16.567 --> 00:51:18.200
is I was gonna select tiles

00:51:18.200 --> 00:51:19.901
out of this texture map

00:51:19.901 --> 00:51:22.467
by using
the glParameter() function,

00:51:22.467 --> 00:51:23.734
which allows you to set cropping

00:51:23.734 --> 00:51:24.934
on the texture, right?

00:51:24.934 --> 00:51:27.067
So I just, you know,
bind the texture once,

00:51:27.067 --> 00:51:28.200
and then set the crop and draw,

00:51:28.200 --> 00:51:29.367
and then
set the crop and draw,

00:51:29.367 --> 00:51:30.467
set the crop and draw, right?

00:51:30.467 --> 00:51:31.601
This is a terrible idea.

00:51:31.601 --> 00:51:33.167
It totally worked.
I mean, like, you know,

00:51:33.167 --> 00:51:34.734
it produced the output
that I expected,

00:51:34.734 --> 00:51:35.968
but it was really,
really slow.

00:51:35.968 --> 00:51:37.100
And I should have guessed

00:51:37.100 --> 00:51:38.667
that it was gonna be
really, really slow,

00:51:38.667 --> 00:51:40.434
because it turns out
that glTextureParameter()

00:51:40.434 --> 00:51:41.701
is a pretty slow function
to call,

00:51:41.701 --> 00:51:43.467
and that this produces
a lot of state change,

00:51:43.467 --> 00:51:45.467
and if you ever worked
on fixed-function hardware

00:51:45.467 --> 00:51:47.534
like this is, state change
is expensive.

00:51:47.534 --> 00:51:49.601
Any kind of state change
that you're gonna apply.

00:51:49.601 --> 00:51:51.534
I mean, binding texture
can be expensive, right?

00:51:51.534 --> 00:51:52.934
So you want to, you know,

00:51:52.934 --> 00:51:54.501
avoid as much state change
as possible,

00:51:54.501 --> 00:51:56.400
and this is a huge amount
of state change, right?

00:51:56.400 --> 00:51:57.834
So, boy, this did not work.

00:51:57.834 --> 00:51:58.901
I mean, it looked all right,

00:51:58.901 --> 00:51:59.968
but it was really slow.

00:51:59.968 --> 00:52:01.367
So then I decided,

00:52:01.367 --> 00:52:03.300
well, instead of using
this atlas texture thing,

00:52:03.300 --> 00:52:05.601
I'll cut it up
into individual, 32x32 textures,

00:52:05.601 --> 00:52:07.767
and then I'll just call
draw_texture for those things,

00:52:07.767 --> 00:52:11.234
and I won't ever have to change
the state of the texture itself

00:52:11.234 --> 00:52:12.267
once I've loaded it.

00:52:12.267 --> 00:52:13.701
Actually,
this works pretty well.

00:52:13.701 --> 00:52:14.834
You know, I have to make

00:52:14.834 --> 00:52:16.501
some adjustments
to the way that you draw,

00:52:16.501 --> 00:52:18.200
because if you're gonna,
you know--

00:52:18.200 --> 00:52:20.200
If you have a loop
that's walking over, like,

00:52:20.200 --> 00:52:22.968
a 2D array, in order to find all
the tiles that you need to draw,

00:52:22.968 --> 00:52:24.634
and you're gonna iterate
over that array,

00:52:24.634 --> 00:52:25.968
like, 400 times per frame,

00:52:25.968 --> 00:52:27.667
that's actually kind of slow
just right there.

00:52:27.667 --> 00:52:29.334
So I like sort of RLEing
the tile map

00:52:29.334 --> 00:52:30.767
and things like that,

00:52:30.767 --> 00:52:33.133
so that I can get through that
particular operation faster.

00:52:33.133 --> 00:52:34.934
But once those sort of
easy optimizations

00:52:34.934 --> 00:52:35.934
are out of the way,

00:52:35.934 --> 00:52:37.634
this actually works
pretty well.

00:52:37.634 --> 00:52:39.767
You still are calling,
you know,

00:52:39.767 --> 00:52:41.334
in the worst case especially,

00:52:41.334 --> 00:52:43.067
a lot of OpenGL calls.

00:52:43.067 --> 00:52:45.267
But it does draw,
and it does draw pretty fast

00:52:45.267 --> 00:52:46.801
in this sparse case.

00:52:46.801 --> 00:52:48.234
The nice thing
about this approach

00:52:48.234 --> 00:52:50.334
is that if
your tile map is sparse

00:52:50.334 --> 00:52:52.133
like those layers
that I just showed you were,

00:52:52.133 --> 00:52:54.167
you know, it doesn't actually
have to do a lot of work.

00:52:54.167 --> 00:52:55.234
It kind of has to do some work

00:52:55.234 --> 00:52:56.567
to figure out
which tiles to draw,

00:52:56.567 --> 00:52:58.501
but the actual
number of draw calls

00:52:58.501 --> 00:52:59.801
is fairly small.

00:52:59.801 --> 00:53:01.801
So that was good.

00:53:01.801 --> 00:53:04.334
The problem is the worst case
from this is really bad.

00:53:04.334 --> 00:53:06.868
You know, you go up to, like,
9 to 13 milliseconds

00:53:06.868 --> 00:53:08.100
just to make the calls,

00:53:08.100 --> 00:53:10.100
and then, like, 19 to 23
milliseconds to draw,

00:53:10.100 --> 00:53:12.767
which is completely unacceptable
for a game like this.

00:53:12.767 --> 00:53:15.033
When both layers
are totally full of tiles,

00:53:15.033 --> 00:53:17.067
then you make, you know,
a huge number of draw calls,

00:53:17.067 --> 00:53:18.701
and it gets, like, really slow.

00:53:18.701 --> 00:53:23.467
So then I went back
to the meta-tile approach,

00:53:23.467 --> 00:53:25.167
but instead of drawing
with draw_texture,

00:53:25.167 --> 00:53:26.300
I decided to use VBOs,

00:53:26.300 --> 00:53:28.234
which I know are technically
slightly slower

00:53:28.234 --> 00:53:29.267
than draw_texture,

00:53:29.267 --> 00:53:30.534
but I figured
maybe in this case

00:53:30.534 --> 00:53:32.334
I could, you know, come up
with a way to use them

00:53:32.334 --> 00:53:33.400
that is a little bit faster.

00:53:33.400 --> 00:53:34.467
And what I ended up doing

00:53:34.467 --> 00:53:35.767
is I ended up
splitting the level

00:53:35.767 --> 00:53:37.200
into what I call
these meta tiles,

00:53:37.200 --> 00:53:39.467
which are basically just these,
like, regular grid of tiles

00:53:39.467 --> 00:53:41.200
that I defined with verts.

00:53:41.200 --> 00:53:44.634
And then I just UV
the atlas texture to them,

00:53:44.634 --> 00:53:46.200
so that they look correct

00:53:46.200 --> 00:53:48.400
for whatever the level says
they're supposed to be there,

00:53:48.400 --> 00:53:50.067
and I split them such
that they're about--

00:53:50.067 --> 00:53:51.868
I mean, in that level,
they're probably about

00:53:51.868 --> 00:53:54.200
five tiles wide
by five tiles tall.

00:53:54.200 --> 00:53:56.133
I just want to get about
four of them on the screen.

00:53:56.133 --> 00:53:57.367
So there's a pretty simple
algorithm

00:53:57.367 --> 00:53:58.634
for taking
the size of the screen

00:53:58.634 --> 00:54:00.400
and taking the size of the level
and cutting it up

00:54:00.400 --> 00:54:01.467
into these meta tiles.

00:54:01.467 --> 00:54:02.834
And then the nice thing
about that

00:54:02.834 --> 00:54:05.400
is that you only make, like,
four draw calls per frame,

00:54:05.400 --> 00:54:06.501
right?

00:54:06.501 --> 00:54:07.868
You're only drawing
four meta tiles.

00:54:07.868 --> 00:54:11.267
And it just happens
that they're larger

00:54:11.267 --> 00:54:12.400
than the regular tiles.

00:54:12.400 --> 00:54:14.334
The other good thing is that

00:54:14.334 --> 00:54:15.868
you only have to call
BindTexture() once

00:54:15.868 --> 00:54:18.734
for each of your layers,

00:54:18.734 --> 00:54:20.100
because,
like I said before,

00:54:20.100 --> 00:54:21.400
state change is slow,

00:54:21.400 --> 00:54:22.467
but you're just gonna bind
those [indistinct].

00:54:22.467 --> 00:54:23.634
It does take up more VRAM,

00:54:23.634 --> 00:54:25.033
but actually, you have
quite a lot of VRAM

00:54:25.033 --> 00:54:26.400
to work with on the G1,

00:54:26.400 --> 00:54:28.234
so it hasn't been
a problem at all.

00:54:28.234 --> 00:54:29.834
The issue with this is,

00:54:29.834 --> 00:54:31.234
it's actually not quite as fast

00:54:31.234 --> 00:54:35.000
as the draw_texture solution
in the previous slide

00:54:35.000 --> 00:54:36.434
in the average case,

00:54:36.434 --> 00:54:37.868
because being a sparse map

00:54:37.868 --> 00:54:39.467
doesn't give it any advantage.

00:54:39.467 --> 00:54:41.501
In a case where there's
no tiles at all

00:54:41.501 --> 00:54:42.634
in an entire meta tile,

00:54:42.634 --> 00:54:44.300
I could throw that
entire meta tile away,

00:54:44.300 --> 00:54:45.534
but in most of the cases,

00:54:45.534 --> 00:54:48.267
there's, you know,
it's pretty common

00:54:48.267 --> 00:54:49.634
that you'd be in a situation

00:54:49.634 --> 00:54:52.334
where there are, you know,
one or two tiles in there,

00:54:52.334 --> 00:54:54.067
and then you have to draw
the entire meta tile.

00:54:54.067 --> 00:54:55.234
So the worst case

00:54:55.234 --> 00:54:56.934
and the average case
are actually the same,

00:54:56.934 --> 00:54:58.868
which means it's a huge
improvement for the worst case,

00:54:58.868 --> 00:55:00.767
but it means the average case
is a little bit slower.

00:55:00.767 --> 00:55:02.100
Still, it's fast enough

00:55:02.100 --> 00:55:04.133
that I could probably get
to 60 hertz from here.

00:55:04.133 --> 00:55:06.367
I'm only about five milliseconds
away, at this point,

00:55:06.367 --> 00:55:09.367
so this is what
I ended up going with.

00:55:09.367 --> 00:55:11.234
Another way to do this
would have been

00:55:11.234 --> 00:55:12.400
to maybe pre-render the level

00:55:12.400 --> 00:55:14.033
into, like, a Canvas bitmap,

00:55:14.033 --> 00:55:15.968
and then cut that up
into different textures,

00:55:15.968 --> 00:55:18.367
and then assign those
to just very Basic Quads,

00:55:18.367 --> 00:55:19.834
and use that.

00:55:19.834 --> 00:55:23.167
The problem with that is that
it takes a lot of main memory.

00:55:23.167 --> 00:55:24.601
It takes a lot of VRAM,

00:55:24.601 --> 00:55:26.234
and the OpenGL
startup and shutdown

00:55:26.234 --> 00:55:27.234
that I talked about before

00:55:27.234 --> 00:55:28.567
would become really problematic,

00:55:28.567 --> 00:55:29.868
so I haven't even
tried that yet.

00:55:29.868 --> 00:55:31.734
It would probably render
real fast, though.

00:55:31.734 --> 00:55:32.734
So I'm running out of time,

00:55:32.734 --> 00:55:34.033
but real quick, tips and tricks.

00:55:34.033 --> 00:55:35.968
You're making a game,
you might have noticed

00:55:35.968 --> 00:55:37.968
that if you touch the screen
your frame rate drops.

00:55:37.968 --> 00:55:40.801
That's because when you
touch the screen on Android,

00:55:40.801 --> 00:55:43.701
your application gets flooded
with MotionEvents.

00:55:43.701 --> 00:55:45.701
And the real easy solution to--

00:55:45.701 --> 00:55:47.400
We should probably solve this
in the API,

00:55:47.400 --> 00:55:48.567
but for now, the real solution

00:55:48.567 --> 00:55:50.234
is to sleep in the callback,

00:55:50.234 --> 00:55:51.901
because that will pause

00:55:51.901 --> 00:55:53.467
the thing
that's generating the events

00:55:53.467 --> 00:55:54.501
and sending them to you

00:55:54.501 --> 00:55:55.567
long enough that your thread

00:55:55.567 --> 00:55:56.734
won't context switch so much,

00:55:56.734 --> 00:55:58.067
and you won't
get totally killed.

00:55:58.067 --> 00:56:00.367
There's a balance
here too, right?

00:56:00.367 --> 00:56:01.567
Because if you sleep

00:56:01.567 --> 00:56:03.000
for too long
on your input callback,

00:56:03.000 --> 00:56:04.734
then you're gonna start
dropping input events,

00:56:04.734 --> 00:56:06.334
and your control's
not gonna feel as tight.

00:56:06.334 --> 00:56:08.300
But I think you'd probably
get away with 60 milliseconds,

00:56:08.300 --> 00:56:09.567
32 milliseconds no problem,

00:56:09.567 --> 00:56:11.267
and that will pretty much
solve that problem.

00:56:11.267 --> 00:56:13.234
You will no longer see
a frame rate effect

00:56:13.234 --> 00:56:14.834
of just touching the screen.

00:56:14.834 --> 00:56:16.968
If you're making a painting
application or something,

00:56:16.968 --> 00:56:18.868
you might not be able to sleep
for that long of time.

00:56:18.868 --> 00:56:20.734
The mechanics,
like I said before,

00:56:20.734 --> 00:56:22.534
of loading OpenGL memory up

00:56:22.534 --> 00:56:24.267
and reloading it up
when the contents are lost

00:56:24.267 --> 00:56:25.634
are fairly complicated,

00:56:25.634 --> 00:56:27.634
but fortunately there's this
GLSurfaceView class

00:56:27.634 --> 00:56:28.968
that's in the API right now

00:56:28.968 --> 00:56:29.968
that does all this for you.

00:56:29.968 --> 00:56:30.968
So use that as a reference,

00:56:30.968 --> 00:56:32.434
or just build your game
on top of that.

00:56:32.434 --> 00:56:34.901
I built my game
on a modified version of that.

00:56:34.901 --> 00:56:36.534
This is just a real quick point,

00:56:36.534 --> 00:56:37.734
but ATITC texture compression

00:56:37.734 --> 00:56:38.734
is available on the G1,

00:56:38.734 --> 00:56:40.100
but you wouldn't know that

00:56:40.100 --> 00:56:41.801
unless you checked
the GL extension string.

00:56:41.801 --> 00:56:43.000
That's why you should check it.

00:56:43.000 --> 00:56:44.167
And you have to sort of find

00:56:44.167 --> 00:56:46.701
what the GL enum
parameter numbers are

00:56:46.701 --> 00:56:48.234
and insert them yourself,

00:56:48.234 --> 00:56:50.234
but I've heard that because
we're sort of bus-limited

00:56:50.234 --> 00:56:51.234
in a lot of cases,

00:56:51.234 --> 00:56:52.467
this can be
a huge improvement.

00:56:52.467 --> 00:56:54.167
So if you're doing stuff
with a lot of texture,

00:56:54.167 --> 00:56:56.367
and you want to, you know,
increase the amount of texture

00:56:56.367 --> 00:56:57.767
you can push
over the bus every frame,

00:56:57.767 --> 00:56:59.167
you can look
at ATITC compression.

00:56:59.167 --> 00:57:00.934
And then this is the bug
that I talked about

00:57:00.934 --> 00:57:02.534
that SpriteMethodTest
suffered from

00:57:02.534 --> 00:57:04.200
before I fixed it yesterday.

00:57:04.200 --> 00:57:07.033
And that's that up unt--
including Cupcake,

00:57:07.033 --> 00:57:08.968
we failed to throw an exception

00:57:08.968 --> 00:57:11.601
when you use indirect buffers
with OpenGL,

00:57:11.601 --> 00:57:13.300
which is actually against
the OpenGL spec,

00:57:13.300 --> 00:57:15.067
and what can happen
if you use indirect buffers

00:57:15.067 --> 00:57:16.667
is that the GC can move
your memory around

00:57:16.667 --> 00:57:19.234
and the OpenGL won't know it.

00:57:19.234 --> 00:57:21.200
So just use direct buffers.

00:57:21.200 --> 00:57:23.000
The API's
almost exactly the same.

00:57:23.000 --> 00:57:24.834
It's pretty easy,
and it will fix the problem.

00:57:24.834 --> 00:57:27.000
But in Cupcake even right now,

00:57:27.000 --> 00:57:28.167
if you use indirect buffers,

00:57:28.167 --> 00:57:29.634
there's no particular
error thrown.

00:57:29.634 --> 00:57:31.300
You might just get,
like, a random crash.

00:57:31.300 --> 00:57:34.834
In doughnuts,
it will throw an exception.

00:57:34.834 --> 00:57:37.133
Okay,
so game design tips.

00:57:37.133 --> 00:57:39.634
This is just
Android-specific advice

00:57:39.634 --> 00:57:40.634
for making a popular game.

00:57:40.634 --> 00:57:42.033
Keep it small, right?

00:57:42.033 --> 00:57:45.133
When people go to, you know,
delete stuff off their phone

00:57:45.133 --> 00:57:46.634
because they're
running out of space,

00:57:46.634 --> 00:57:48.701
the applications get listed
in order of size.

00:57:48.701 --> 00:57:52.167
That game that I just
showed you, &lt;i&gt;Replica Island,&lt;/i&gt;

00:57:52.167 --> 00:57:53.767
has, like,
a bunch of different enemies.

00:57:53.767 --> 00:57:55.467
It's got five different,
like, world maps,

00:57:55.467 --> 00:57:56.934
and it's gonna have,
like, 40 levels,

00:57:56.934 --> 00:57:58.400
and it clocks in at,
like, three megs.

00:57:58.400 --> 00:58:00.367
So you can very easily,
you know,

00:58:00.367 --> 00:58:02.033
if you choose the right
kind of art style,

00:58:02.033 --> 00:58:03.634
you choose data
that's easy to compress,

00:58:03.634 --> 00:58:05.667
you can make a game
that is very small.

00:58:05.667 --> 00:58:08.033
You know, &lt;i&gt;Super Mario World&lt;/i&gt;
runs on 512k.

00:58:08.033 --> 00:58:13.400
So you should try to optimize
the size of your application,

00:58:13.400 --> 00:58:16.067
because it'll increase
your longevity.

00:58:16.067 --> 00:58:17.634
Make good games, right?

00:58:17.634 --> 00:58:18.701
The key to Android right now

00:58:18.701 --> 00:58:20.133
on the market is quality.

00:58:20.133 --> 00:58:22.334
You know, if you want to get
in that Featured Apps section,

00:58:22.334 --> 00:58:23.667
there's no way to do it

00:58:23.667 --> 00:58:25.567
other than making something
that's really cool,

00:58:25.567 --> 00:58:27.667
that we at Google like, but also
that all the users like.

00:58:27.667 --> 00:58:29.133
There's no way
to pay your way in,

00:58:29.133 --> 00:58:31.167
or have a certain number of
downloads and then you get in,

00:58:31.167 --> 00:58:32.300
something like that.

00:58:32.300 --> 00:58:34.067
Just make something that
all the users like.

00:58:34.067 --> 00:58:36.868
I highly recommend that you
put some time in to polish,

00:58:36.868 --> 00:58:37.868
and to making something

00:58:37.868 --> 00:58:39.200
that's really highly competent.

00:58:39.200 --> 00:58:41.033
And if you do that,
you'll be ahead of the pack.

00:58:41.033 --> 00:58:42.300
Because there's a lot of people

00:58:42.300 --> 00:58:44.300
who just like to, you know,
throw something up there

00:58:44.300 --> 00:58:45.767
that they wrote
in an evening, right?

00:58:45.767 --> 00:58:47.334
And the users
are really, really picky.

00:58:47.334 --> 00:58:49.067
They'll really prefer something

00:58:49.067 --> 00:58:50.801
that looks like it has
a level of polish on it,

00:58:50.801 --> 00:58:52.634
or has nice art style,
or something like that,

00:58:52.634 --> 00:58:53.834
so I highly recommend

00:58:53.834 --> 00:58:55.501
that you focus
even a little bit on quality.

00:58:55.501 --> 00:58:56.667
It'll set you apart.

00:58:56.667 --> 00:58:58.567
And then the last thing
I just wanted to say,

00:58:58.567 --> 00:59:00.467
although I'm doing this
out of order,

00:59:00.467 --> 00:59:02.267
is that not all devices
are gonna have

00:59:02.267 --> 00:59:03.734
the same input systems,

00:59:03.734 --> 00:59:05.267
and you should just be
cognizant of that.

00:59:05.267 --> 00:59:06.601
I'm using a trackball
for my game.

00:59:06.601 --> 00:59:08.267
I don't know exactly how
it's going to work

00:59:08.267 --> 00:59:11.100
when the Samsung,
you know, i7500 comes out,

00:59:11.100 --> 00:59:12.501
'cause that has a D-pad.

00:59:12.501 --> 00:59:15.834
Probably you should just support
all of the input systems,

00:59:15.834 --> 00:59:19.267
because they're already in the
framework for getting events,

00:59:19.267 --> 00:59:20.501
but if you don't do that,

00:59:20.501 --> 00:59:21.934
you may have a game--

00:59:21.934 --> 00:59:24.200
Like, say you relied on the
hardware keyboard for your game,

00:59:24.200 --> 00:59:26.200
it's not gonna be playable
on the Sapphire, right?

00:59:26.200 --> 00:59:27.767
So that's something else
to be aware of.

00:59:27.767 --> 00:59:30.667
And that is pretty much my talk.

00:59:30.667 --> 00:59:32.601
Thank you very much
for coming today.

00:59:32.601 --> 00:59:34.067
[applause]
Thank you for listening,

00:59:34.067 --> 00:59:40.400
and I'm happy to answer
any questions.

00:59:40.400 --> 00:59:42.434
Please use the microphone.

00:59:42.434 --> 00:59:44.501
Oh, I'm sorry.

00:59:44.501 --> 00:59:45.968
Okay, I'm gonna answer
one question,

00:59:45.968 --> 00:59:48.834
and then I'm out of time,
because I ran long.

00:59:48.834 --> 00:59:50.667
So I think you're up.
What's up?

00:59:50.667 --> 00:59:52.567
man:
My question was about C++,

00:59:52.567 --> 00:59:56.033
whether game development
on Android

00:59:56.033 --> 00:59:57.200
can be done in C++...

00:59:57.200 --> 00:59:58.200
Pruett: Yes.

00:59:58.200 --> 00:59:59.634
man:
And how easy is that to do,

00:59:59.634 --> 01:00:01.234
and whether there will be
any sample apps

01:00:01.234 --> 01:00:02.868
for that platform.

01:00:02.868 --> 01:00:04.067
Pruett: Yes.

01:00:04.067 --> 01:00:05.734
Can you use C++
for your game development?

01:00:05.734 --> 01:00:06.901
Right now it's really hard.

01:00:06.901 --> 01:00:09.567
Very soon we will ship something
called the NDK,

01:00:09.567 --> 01:00:12.834
which will allow you
to build C++ native components

01:00:12.834 --> 01:00:14.901
to your applications and then
call into them from Java,

01:00:14.901 --> 01:00:17.067
and then you can absolutely
use C++ to build your games.

01:00:17.067 --> 01:00:18.601
If you do that, though,

01:00:18.601 --> 01:00:21.234
you're gonna tie your games to
whatever particular architecture

01:00:21.234 --> 01:00:22.501
you compiled that code for,

01:00:22.501 --> 01:00:24.100
which means
that you're gonna lose

01:00:24.100 --> 01:00:25.200
a lot of the interoperability

01:00:25.200 --> 01:00:26.400
that Android sort of promises.

01:00:26.400 --> 01:00:27.934
So if you're willing
to make that change

01:00:27.934 --> 01:00:30.133
or you're willing to compile
from multiple architectures,

01:00:30.133 --> 01:00:31.434
then absolutely.

01:00:31.434 --> 01:00:33.334
And, in fact, we have games
up on market right now

01:00:33.334 --> 01:00:34.701
that are built that way,

01:00:34.701 --> 01:00:37.634
but as of right now,
it's kind of a pain in the butt.

01:00:37.634 --> 01:00:40.300
Couple--Give us a little bit
of time to build it in.

01:00:40.300 --> 01:00:42.567
Okay, thank you very much.

01:00:42.567 --> 01:00:44.734
[no audio]

01:00:49.801 --> 01:00:50.801
Sorry.

01:00:50.801 --> 01:00:51.801
Sorry, just as you leave,

01:00:51.801 --> 01:00:54.067
if we can switch
to this machine...

01:00:54.067 --> 01:00:55.501
Oh, I have it here, don't I?

01:00:55.501 --> 01:00:58.467
Here's the feedback link.

01:00:58.467 --> 01:01:00.167
Please go give your feedback
about this talk

01:01:00.167 --> 01:01:01.400
and every other talk,

01:01:01.400 --> 01:01:02.801
'cause we'd really
appreciate it.

01:01:02.801 --> 01:01:04.567
Thank you very much.

