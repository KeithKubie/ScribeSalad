WEBVTT
Kind: captions
Language: en

00:00:01.290 --> 00:00:02.560
BRUNO OLIVEIRA: My name is Bruno
Oliveira, and I work

00:00:02.560 --> 00:00:04.210
with Android Developer
Relations.

00:00:04.210 --> 00:00:04.550
TOM WILSON: Hi.

00:00:04.550 --> 00:00:05.270
I'm Tom.

00:00:05.270 --> 00:00:07.690
I'm an engineer on the Google
Play Services Team.

00:00:07.690 --> 00:00:08.890
BRUNO OLIVEIRA: And we're going
to talk to you about

00:00:08.890 --> 00:00:10.400
some advanced games topics.

00:00:10.400 --> 00:00:12.960
Actually, we couldn't reveal
that before, but our session

00:00:12.960 --> 00:00:16.120
is actually about advanced games
topics using Google Play

00:00:16.120 --> 00:00:18.800
game services, of course.

00:00:18.800 --> 00:00:22.280
So for this talk, we're going to
assume that you went to the

00:00:22.280 --> 00:00:25.060
other talks and that you already
know all the basics.

00:00:25.060 --> 00:00:27.430
Of course, I'm not talking
about this BASIC.

00:00:27.430 --> 00:00:29.470
I'm talking about
these basics.

00:00:29.470 --> 00:00:31.370
So you should be able
to set up your game.

00:00:31.370 --> 00:00:32.940
You should be able to
create a client ID.

00:00:32.940 --> 00:00:35.550
You should be able to write the
sign-in flow, basic stuff

00:00:35.550 --> 00:00:37.660
like achievements, leaderboards,
and then set up

00:00:37.660 --> 00:00:39.090
a multiplayer game as well.

00:00:39.090 --> 00:00:41.140
So we're not going to cover
any of those basics.

00:00:41.140 --> 00:00:44.150
Now, we're going to talk about
a few topics that go beyond a

00:00:44.150 --> 00:00:44.910
basic game.

00:00:44.910 --> 00:00:47.220
We're going to talk about some
of the things that real games

00:00:47.220 --> 00:00:48.280
often need.

00:00:48.280 --> 00:00:49.930
So GamesClient is great.

00:00:49.930 --> 00:00:50.810
I love it.

00:00:50.810 --> 00:00:53.910
For simple games, it's
all you'll need.

00:00:53.910 --> 00:00:56.460
But real games often have a
need to use PlusClient and

00:00:56.460 --> 00:00:58.960
AppStateClient as well and
manage all three of them in a

00:00:58.960 --> 00:01:00.530
way that makes sense.

00:01:00.530 --> 00:01:01.930
Now, real games have
players that deeply

00:01:01.930 --> 00:01:02.830
care about their progress.

00:01:02.830 --> 00:01:06.220
So I pick up my game, and then
I spend countless hours

00:01:06.220 --> 00:01:08.740
battling monsters, solving
mazes, collecting loot.

00:01:08.740 --> 00:01:11.890
Eventually, my Level 1000
Fighter Wizard Cleric Board

00:01:11.890 --> 00:01:14.090
can survive pretty much anything
in the known universe

00:01:14.090 --> 00:01:17.530
except a phone upgrade
that kills them.

00:01:17.530 --> 00:01:20.200
So real games have players that
deeply care about that

00:01:20.200 --> 00:01:23.200
kind of thing, which is why real
games need Cloud Save,

00:01:23.200 --> 00:01:25.360
not just simple Cloud Save,
but you need to deal with

00:01:25.360 --> 00:01:27.430
Cloud Save conflicts in a way
that makes sense and doesn't

00:01:27.430 --> 00:01:29.510
lose any progress
for your users.

00:01:29.510 --> 00:01:31.980
Also, real games often use
native code, which, as we

00:01:31.980 --> 00:01:33.510
know, is pretty simple, right?

00:01:33.510 --> 00:01:37.200
And nothing ever, ever
goes wrong with that.

00:01:37.200 --> 00:01:39.850
Real games often need a lot
more, like custom UIs.

00:01:39.850 --> 00:01:40.820
They need to do advanced
automatching.

00:01:40.820 --> 00:01:43.550
They need to integrate with
third party engines.

00:01:43.550 --> 00:01:45.810
Which is why we're going to
structure this talk around

00:01:45.810 --> 00:01:47.580
nine tips for real games.

00:01:47.580 --> 00:01:50.105
Actually, they're not exactly
tips because these are not

00:01:50.105 --> 00:01:52.710
things that you necessarily
have to implement.

00:01:52.710 --> 00:01:55.260
Let's call them, say,
information quanta?

00:01:55.260 --> 00:01:56.505
TOM WILSON: That's
a little wordy.

00:01:56.505 --> 00:01:58.400
How about something simple
like how tos?

00:01:58.400 --> 00:01:58.820
BRUNO OLIVEIRA: How tos.

00:01:58.820 --> 00:02:00.650
How to's better, so that's
a good idea.

00:02:00.650 --> 00:02:03.560
So onto the first how to, which
is useful for games and,

00:02:03.560 --> 00:02:04.710
I think, life.

00:02:04.710 --> 00:02:05.950
TOM WILSON: Unfortunately, we
can only teach you it for

00:02:05.950 --> 00:02:09.229
games, not for life
in general.

00:02:09.229 --> 00:02:10.729
BRUNO OLIVEIRA: Anyway,
so, what's that?

00:02:10.729 --> 00:02:11.860
TOM WILSON: It's the universally
accepted

00:02:11.860 --> 00:02:13.100
representation of a user.

00:02:13.100 --> 00:02:14.470
BRUNO OLIVEIRA: Of course,
naturally.

00:02:14.470 --> 00:02:16.847
Fortunately, I write
code better than I

00:02:16.847 --> 00:02:18.830
draw pictures, naturally.

00:02:18.830 --> 00:02:22.390
So some games manage to
accomplish a very unique feat,

00:02:22.390 --> 00:02:26.120
which is to annoy the players
on the very first screen.

00:02:26.120 --> 00:02:27.400
That's actually pretty
impressive.

00:02:27.400 --> 00:02:28.500
You can show one screen
and you can

00:02:28.500 --> 00:02:29.890
annoy most of the players.

00:02:29.890 --> 00:02:31.970
How does that happen?

00:02:31.970 --> 00:02:34.590
One sure way to make sure that
that's going to happen is if

00:02:34.590 --> 00:02:36.460
the player starts your game,
doesn't even know what the

00:02:36.460 --> 00:02:39.670
game is about, and what they see
is an annoying pop-up that

00:02:39.670 --> 00:02:40.750
might say something like that.

00:02:40.750 --> 00:02:42.420
Maybe not exactly with
those words, but

00:02:42.420 --> 00:02:43.310
that's what they mean.

00:02:43.310 --> 00:02:47.000
You either sign into my game
or you get out of my game

00:02:47.000 --> 00:02:48.220
because you have to sign in.

00:02:48.220 --> 00:02:49.930
So that's not a very good
experience for the user

00:02:49.930 --> 00:02:52.830
because maybe I don't even know
what the game is about.

00:02:52.830 --> 00:02:55.290
A slightly less annoying
variation is games that don't

00:02:55.290 --> 00:02:57.970
really require me to sign in,
but then they spam me every

00:02:57.970 --> 00:03:01.173
time I start the game with a
pop-up asking me if I want to

00:03:01.173 --> 00:03:02.770
sign in or not.

00:03:02.770 --> 00:03:05.400
And then maybe I don't even know
what the game is about

00:03:05.400 --> 00:03:07.510
yet, but then I keep getting
spammed every

00:03:07.510 --> 00:03:08.300
time I start the game.

00:03:08.300 --> 00:03:10.450
So why should I click
that if I don't know

00:03:10.450 --> 00:03:11.940
what the game is about?

00:03:11.940 --> 00:03:14.480
Compare that to this more
friendly game experience that

00:03:14.480 --> 00:03:17.320
offers, but doesn't force,
the option to sign in.

00:03:17.320 --> 00:03:19.790
Notice that it also explains to
the user what it means to

00:03:19.790 --> 00:03:21.490
sign in in the context
of the game.

00:03:21.490 --> 00:03:24.180
And if I still don't feel like
signing into the game, I can

00:03:24.180 --> 00:03:27.420
play Single Player, and that's
still going to be fine.

00:03:27.420 --> 00:03:29.460
Now, I'm eventually convinced
that I want to sign into this

00:03:29.460 --> 00:03:31.710
particular game, and then the
game clarifies that I'm signed

00:03:31.710 --> 00:03:34.260
in and gives me an option to
sign out, so I'm in control of

00:03:34.260 --> 00:03:35.580
the sign-in.

00:03:35.580 --> 00:03:37.470
And then it enables some
additional functionality like

00:03:37.470 --> 00:03:39.940
Multiplayer, Achievements
and High Scores.

00:03:39.940 --> 00:03:42.530
So at the very least, any calls
to the game's API in

00:03:42.530 --> 00:03:45.150
your code should be protected
by that check.

00:03:45.150 --> 00:03:46.550
So if the game's client
is connected,

00:03:46.550 --> 00:03:47.390
you call the method.

00:03:47.390 --> 00:03:49.660
If it's not, you do something
else, but

00:03:49.660 --> 00:03:51.110
at least don't crash.

00:03:51.110 --> 00:03:53.090
And of course, if you want to
implement that well behaved

00:03:53.090 --> 00:03:56.115
sign-in flow, you need to make
sure that you don't show a

00:03:56.115 --> 00:03:58.200
pop-up unless the user actually
clicks the Sign-In

00:03:58.200 --> 00:04:00.210
button, because it's very
annoying to see a pop-up when

00:04:00.210 --> 00:04:01.270
you didn't ask for it.

00:04:01.270 --> 00:04:03.480
To do this, it's important to
keep in mind that calling

00:04:03.480 --> 00:04:05.190
connect won't actually
show a pop-up.

00:04:05.190 --> 00:04:06.790
There's no pop-up if
you call connect.

00:04:06.790 --> 00:04:08.890
So you can call it safely
from onStart.

00:04:08.890 --> 00:04:12.140
Now, where the pop-up might
show is when you try to

00:04:12.140 --> 00:04:13.400
resolve a connection result.

00:04:13.400 --> 00:04:15.860
This may show a pop-up, so you
only want to do that if the

00:04:15.860 --> 00:04:17.670
user clicked the
Sign-In button.

00:04:17.670 --> 00:04:18.709
This is how you might
implement this.

00:04:18.709 --> 00:04:20.519
You have a Boolean flag
indicating whether or not the

00:04:20.519 --> 00:04:24.185
user has clicked the Sign-In
button, and then you use that

00:04:24.185 --> 00:04:26.640
flag to decide what to do with
a connection failure.

00:04:26.640 --> 00:04:29.210
So when you get a connection
failure, you see, did the user

00:04:29.210 --> 00:04:30.270
request sign in?

00:04:30.270 --> 00:04:36.050
If they did, then it can show
that pop-up dialog.

00:04:36.050 --> 00:04:37.800
That's OK, because they
requested it.

00:04:37.800 --> 00:04:41.430
If they didn't, then you store
that result for later.

00:04:41.430 --> 00:04:43.670
When the user eventually clicks
the Sign-In button,

00:04:43.670 --> 00:04:46.000
then you check if there's a
pending connection result from

00:04:46.000 --> 00:04:47.080
the previous step.

00:04:47.080 --> 00:04:49.430
And if there is, you
try to resolve it.

00:04:49.430 --> 00:04:51.130
And if not, you set that
flag to true and

00:04:51.130 --> 00:04:52.630
then attempt to connect.

00:04:52.630 --> 00:04:55.310
And I think that's pretty much
it if you only have a

00:04:55.310 --> 00:04:56.470
GamesClient.

00:04:56.470 --> 00:04:58.170
But, Tom, what happens if
they have something more

00:04:58.170 --> 00:05:00.680
complicated using, say,
GamesClient, PlusClient,

00:05:00.680 --> 00:05:01.280
AppStateClient?

00:05:01.280 --> 00:05:02.210
What happens in that case?

00:05:02.210 --> 00:05:04.880
TOM WILSON: It's funny that you
ask because our next topic

00:05:04.880 --> 00:05:06.230
is exactly that.

00:05:06.230 --> 00:05:06.480
BRUNO OLIVEIRA: Oh.

00:05:06.480 --> 00:05:06.920
What a coincidence.

00:05:06.920 --> 00:05:07.730
TOM WILSON: What are
the odds, right?

00:05:07.730 --> 00:05:08.650
BRUNO OLIVEIRA: It's almost
like we planned this.

00:05:08.650 --> 00:05:10.570
TOM WILSON: Yeah, somehow.

00:05:10.570 --> 00:05:12.380
So we've talked in the basic
talks about how you use a

00:05:12.380 --> 00:05:14.190
single Google Play
services client.

00:05:14.190 --> 00:05:16.180
Let's quickly recap what
that looks like.

00:05:16.180 --> 00:05:18.540
You've got your onCreate method,
then you have your

00:05:18.540 --> 00:05:21.350
onStart, where you connect
to the GamesClient.

00:05:21.350 --> 00:05:22.980
If you get an
onConnectionFailed, then you

00:05:22.980 --> 00:05:24.240
resolve your problems.

00:05:24.240 --> 00:05:25.750
onConnected, you're
ready to go.

00:05:25.750 --> 00:05:28.000
And then finally, an onStop,
you disconnect.

00:05:28.000 --> 00:05:31.210
So if you've got multiple
clients when you get created,

00:05:31.210 --> 00:05:33.430
go ahead and create all the
clients that you want, and

00:05:33.430 --> 00:05:35.010
then add them to an array
so that you can

00:05:35.010 --> 00:05:36.640
keep track of them.

00:05:36.640 --> 00:05:38.680
Now you just start connecting
your clients in order.

00:05:38.680 --> 00:05:39.730
Connecting an already connected

00:05:39.730 --> 00:05:40.940
client is totally safe.

00:05:40.940 --> 00:05:42.485
There's nothing else you need
to worry about there, so you

00:05:42.485 --> 00:05:44.630
just don't need any extra
error checking.

00:05:44.630 --> 00:05:48.150
If you encounter a failure while
connecting, you just

00:05:48.150 --> 00:05:49.620
resolve it the way you
normally would.

00:05:49.620 --> 00:05:51.710
Most of the time, that's going
to involve launching some sort

00:05:51.710 --> 00:05:54.530
of intent to get a result back,
and then once you get

00:05:54.530 --> 00:05:57.120
the result, you just continue
connecting clients.

00:05:57.120 --> 00:05:59.530
If a client's already connected
and you call connect

00:05:59.530 --> 00:06:01.710
on it, you'll get the
onConnected callback.

00:06:01.710 --> 00:06:04.200
So in this callback, all you
have to do is loop through it

00:06:04.200 --> 00:06:06.400
looking for the first
nonconnected client and then

00:06:06.400 --> 00:06:07.610
repeat the process.

00:06:07.610 --> 00:06:11.440
Once they're all connected,
you're good to go.

00:06:11.440 --> 00:06:14.320
Finally, in onStop, all you have
to do is disconnect all

00:06:14.320 --> 00:06:14.815
of your clients.

00:06:14.815 --> 00:06:16.370
That'll tear down all the
state, make sure that

00:06:16.370 --> 00:06:19.600
everything's good, release
all the resources.

00:06:19.600 --> 00:06:22.040
Different clients that you're
going to be using ask for

00:06:22.040 --> 00:06:23.710
different permissions because
they're accessing

00:06:23.710 --> 00:06:25.100
different user data.

00:06:25.100 --> 00:06:26.710
So if you just do the default
thing we just showed you

00:06:26.710 --> 00:06:28.800
above, this is what your game's
going to look like.

00:06:28.800 --> 00:06:29.910
You're going to see
a Sign-In button.

00:06:29.910 --> 00:06:33.520
The user clicks it, they'll
see a pop-up.

00:06:33.520 --> 00:06:36.440
And then they'll see another
pop-up, and then, eventually,

00:06:36.440 --> 00:06:37.740
they're going to make
it to your game.

00:06:37.740 --> 00:06:40.530
That's going to make your
users look like this.

00:06:40.530 --> 00:06:42.060
It's not a really
good experience.

00:06:42.060 --> 00:06:43.810
So how do we do better
than that?

00:06:43.810 --> 00:06:46.410
To avoid this, when you create
your clients, you just request

00:06:46.410 --> 00:06:48.440
all of the scopes that
you need all at once.

00:06:48.440 --> 00:06:50.360
So when you build every client,
you just pass in all

00:06:50.360 --> 00:06:52.700
of the scopes that you want to
use, and that's going to turn

00:06:52.700 --> 00:06:56.890
this nightmarish multi-pop-up
scenario into this.

00:06:56.890 --> 00:06:59.420
It just consolidates them down
into one, which will make your

00:06:59.420 --> 00:07:01.820
users look like this.

00:07:01.820 --> 00:07:03.930
So if you want some examples,
you can look

00:07:03.930 --> 00:07:04.730
at our sample code.

00:07:04.730 --> 00:07:06.440
We've released this
with the SDK.

00:07:06.440 --> 00:07:09.600
We have a GamesHelper class and
a BaseGameActivity class

00:07:09.600 --> 00:07:10.840
that use all three clients--

00:07:10.840 --> 00:07:12.770
Games, Plus, and AppState-- so
that you can check it out and

00:07:12.770 --> 00:07:13.910
see how this works.

00:07:13.910 --> 00:07:15.670
So that's how you can use
multiple clients.

00:07:15.670 --> 00:07:18.300
But now that the users are in
your game, let's talk a little

00:07:18.300 --> 00:07:21.610
bit about actually giving them
something fun to do.

00:07:21.610 --> 00:07:24.170
Bruno's going to talk about how
to use the Games APIs from

00:07:24.170 --> 00:07:27.280
our favorite place,
native code.

00:07:27.280 --> 00:07:30.890
BRUNO OLIVEIRA: So until now,
we've been pretty much safely

00:07:30.890 --> 00:07:35.000
tucked inside the cozy virtual
machine, but it's time to step

00:07:35.000 --> 00:07:37.360
out in that exciting world
where many games live.

00:07:37.360 --> 00:07:40.120
And that's, of course, the
world of native code.

00:07:40.120 --> 00:07:41.110
Nothing against Dalvik.

00:07:41.110 --> 00:07:43.170
Virtual machines are just
great, but when I first

00:07:43.170 --> 00:07:43.920
learned how to use
NativeActivity,

00:07:43.920 --> 00:07:46.240
I was really excited.

00:07:46.240 --> 00:07:47.960
It was like, yay, C, C++.

00:07:47.960 --> 00:07:50.210
And then I realized there
was stuff that I needed

00:07:50.210 --> 00:07:52.690
to do in Java, too.

00:07:52.690 --> 00:07:55.030
Fortunately, there is JNI,
which, as we know, is pretty

00:07:55.030 --> 00:07:56.310
simple and straightforward.

00:07:56.310 --> 00:07:59.030
So I call FindClass and then
I get my JavaClass and

00:07:59.030 --> 00:08:00.090
everything should work, right?

00:08:00.090 --> 00:08:01.030
TOM WILSON: This always works.

00:08:01.030 --> 00:08:02.050
BRUNO OLIVEIRA: This
always works.

00:08:02.050 --> 00:08:05.480
And then, of course, I am met
with sadness because I see a

00:08:05.480 --> 00:08:06.550
ClassNotFoundException.

00:08:06.550 --> 00:08:10.560
And after digging a lot, that
happens because that thing

00:08:10.560 --> 00:08:13.250
right there doesn't really have
a clue about my classes.

00:08:13.250 --> 00:08:14.770
It knows about the framework
classes.

00:08:14.770 --> 00:08:16.050
So if I'm trying to instantiate
the framework

00:08:16.050 --> 00:08:18.783
class, that's fine, but my
classes, it doesn't really

00:08:18.783 --> 00:08:19.710
know anything about.

00:08:19.710 --> 00:08:21.410
There is a solution which
involves getting a different

00:08:21.410 --> 00:08:23.710
class loader and so on, but
here's a method that's often

00:08:23.710 --> 00:08:25.840
easier for native
applications.

00:08:25.840 --> 00:08:28.170
If I derive my class from
the frameworks standard

00:08:28.170 --> 00:08:31.290
NativeActivity, I can add some
convenience methods to it,

00:08:31.290 --> 00:08:33.679
which I can then call from
native code without any need

00:08:33.679 --> 00:08:36.830
to deal with class loaders and
any funny business like that.

00:08:36.830 --> 00:08:39.620
So I just load my shared library
like this, as usual,

00:08:39.620 --> 00:08:42.390
and then I write a convenience
method in my derived activity

00:08:42.390 --> 00:08:44.380
class, which I'll call
from native code.

00:08:44.380 --> 00:08:47.370
In this example, this
convenience method is calling

00:08:47.370 --> 00:08:50.050
GamesClient.submitScore, and
then I'm going to call that

00:08:50.050 --> 00:08:51.010
from native code.

00:08:51.010 --> 00:08:51.890
How do I do that?

00:08:51.890 --> 00:08:52.960
This is how I do it
from native code.

00:08:52.960 --> 00:08:55.160
I just get the object and then
get the method using the

00:08:55.160 --> 00:08:57.790
method name and signature,
and then call using

00:08:57.790 --> 00:08:58.570
CallVoidMethod.

00:08:58.570 --> 00:09:01.780
So that calls my convenience
method.

00:09:01.780 --> 00:09:03.170
TOM WILSON: That just seems
too easy, Bruno.

00:09:03.170 --> 00:09:06.180
BRUNO OLIVEIRA: It's
too easy, right?

00:09:06.180 --> 00:09:09.760
Well, if you ever feel that
anything looks too easy or too

00:09:09.760 --> 00:09:11.980
simple, just add a different
thread into it.

00:09:11.980 --> 00:09:14.700
So as you know, multithreading
is very complicated.

00:09:14.700 --> 00:09:16.790
It is my opinion that if the
world ends one day, it's going

00:09:16.790 --> 00:09:18.467
to be because of a raised
condition somewhere.

00:09:18.467 --> 00:09:19.750
[LAUGHTER]

00:09:19.750 --> 00:09:21.260
BRUNO OLIVEIRA: So what
about threading?

00:09:21.260 --> 00:09:25.790
So native code often runs
outside of the main thread.

00:09:25.790 --> 00:09:29.120
That's even the default if
you're using NativeActivity.

00:09:29.120 --> 00:09:31.540
So what happens if you
accidentally make a method

00:09:31.540 --> 00:09:34.950
call that should have been done
on the UI thread from

00:09:34.950 --> 00:09:36.350
that separate thread?

00:09:36.350 --> 00:09:38.340
What's going to happen is that
maybe your app is going to--

00:09:38.340 --> 00:09:40.420
maybe it's going to work.

00:09:40.420 --> 00:09:44.480
And that's terrible, because
then you don't notice the bug.

00:09:44.480 --> 00:09:46.610
But maybe your app is going
to behave in some bizarre,

00:09:46.610 --> 00:09:47.480
strange way.

00:09:47.480 --> 00:09:50.500
Maybe it's going to go up in
flames, leaving you only this

00:09:50.500 --> 00:09:52.770
mysterious error
message behind.

00:09:52.770 --> 00:09:55.470
That, of course, is a very clear
message except that it's

00:09:55.470 --> 00:09:56.270
in log speak.

00:09:56.270 --> 00:09:58.230
And logs are very friendly
creatures.

00:09:58.230 --> 00:10:00.470
They are, in fact, the
developer's best friend, but

00:10:00.470 --> 00:10:01.250
they just have trouble

00:10:01.250 --> 00:10:03.330
expressing themselves sometimes.

00:10:03.330 --> 00:10:05.500
In log culture, this message
really means,

00:10:05.500 --> 00:10:06.570
"I really like you.

00:10:06.570 --> 00:10:09.360
But you are on the wrong
thread." So if you see that

00:10:09.360 --> 00:10:11.890
message, that means there's
nothing wrong, you're just

00:10:11.890 --> 00:10:13.560
calling that method from
the wrong thread.

00:10:13.560 --> 00:10:15.810
You should be careful to call
that from the correct thread.

00:10:15.810 --> 00:10:18.150
In these cases, you can use
the off-thread developer's

00:10:18.150 --> 00:10:19.150
best friend, which is?

00:10:19.150 --> 00:10:20.530
TOM WILSON: Got to be
their dog, right?

00:10:20.530 --> 00:10:21.160
BRUNO OLIVEIRA: The dog?

00:10:21.160 --> 00:10:21.940
Well, close.

00:10:21.940 --> 00:10:23.020
It's runOnUiThread.

00:10:23.020 --> 00:10:23.910
TOM WILSON: And this
is why Bruno is a

00:10:23.910 --> 00:10:25.530
DevRel, not an artist.

00:10:25.530 --> 00:10:27.660
BRUNO OLIVEIRA: Exactly.

00:10:27.660 --> 00:10:30.820
So summarizing, your native code
calls your Java method

00:10:30.820 --> 00:10:34.050
via JNI, and then that method
calls runOnUiThread,

00:10:34.050 --> 00:10:35.190
specifying runnable.

00:10:35.190 --> 00:10:37.550
And when that runnable runs, of
course, that's going to be

00:10:37.550 --> 00:10:38.440
on the UI thread.

00:10:38.440 --> 00:10:40.930
Then you finally invoke the
Games API and everything

00:10:40.930 --> 00:10:42.330
should work.

00:10:42.330 --> 00:10:45.130
So this is what your convenience
method probably

00:10:45.130 --> 00:10:45.800
looks like.

00:10:45.800 --> 00:10:48.665
This method can be called from
any thread because it makes

00:10:48.665 --> 00:10:52.370
sure that this inner part only
happens on the UI thread.

00:10:52.370 --> 00:10:54.430
You can even call this from the
UI thread itself because

00:10:54.430 --> 00:10:59.510
runOnUiThread is safe to call
from the UI thread itself.

00:10:59.510 --> 00:11:01.300
So now that we've talked about
threads, let's talk about

00:11:01.300 --> 00:11:03.060
another interesting topic,
which is the border.

00:11:03.060 --> 00:11:05.540
As you know, the border can
be a very dangerous place.

00:11:05.540 --> 00:11:07.842
One hears lots of stories
about the border.

00:11:07.842 --> 00:11:10.100
I'm, of course, talking about
the border between Dalvik and

00:11:10.100 --> 00:11:11.150
native code.

00:11:11.150 --> 00:11:13.165
So there are many frightening
stories about data structures

00:11:13.165 --> 00:11:16.130
that try to cross, don't quite
make it to the other side.

00:11:16.130 --> 00:11:19.470
They fall prey to bands of stray
pointers, and they wind

00:11:19.470 --> 00:11:21.700
up in the craziest
places of memory.

00:11:21.700 --> 00:11:23.440
And there are stories of
shipments that end up having

00:11:23.440 --> 00:11:27.750
to be copied every single time
in what are very, very slow

00:11:27.750 --> 00:11:29.170
smuggling operations.

00:11:29.170 --> 00:11:31.160
And then there are even cases
where things are so

00:11:31.160 --> 00:11:34.520
uncivilized around the border
that the garbage collector has

00:11:34.520 --> 00:11:36.510
to do a lot of work to pick up
the debris that your code

00:11:36.510 --> 00:11:40.430
leaves behind, which is why
we're going to give you some

00:11:40.430 --> 00:11:42.440
quick travel tips to ensure
that you have a safe and

00:11:42.440 --> 00:11:45.340
speedy journey down to
the native border.

00:11:45.340 --> 00:11:47.200
First of all is travel light.

00:11:47.200 --> 00:11:48.660
Avoid copying tons
of data back and

00:11:48.660 --> 00:11:49.880
forth across the border.

00:11:49.880 --> 00:11:52.140
Remember that copies can happen
where you least expect.

00:11:52.140 --> 00:11:54.960
So for instance, even that code
that looks innocent, you

00:11:54.960 --> 00:11:58.400
might actually be copying the
whole 128K managed buffer

00:11:58.400 --> 00:12:01.860
twice in that code, maybe even
three times, and that's all

00:12:01.860 --> 00:12:03.840
because you want to access
four bytes out of it.

00:12:03.840 --> 00:12:05.450
Because when you call
GetByteArrayElements, you

00:12:05.450 --> 00:12:07.325
might be making a copy, and
when you call Release, you

00:12:07.325 --> 00:12:08.640
might be making another copy.

00:12:08.640 --> 00:12:10.960
A much more economical way to do
that would be just to call

00:12:10.960 --> 00:12:13.170
GetByteArrayRegion, and then
just get the bytes that you

00:12:13.170 --> 00:12:14.910
need out of it.

00:12:14.910 --> 00:12:16.570
Also, pack the right buffers.

00:12:16.570 --> 00:12:17.880
That's very important.

00:12:17.880 --> 00:12:20.570
Remember that managed byte
buffers are very fast to

00:12:20.570 --> 00:12:23.240
access on Dalvik but may be
very slow on native code.

00:12:23.240 --> 00:12:26.250
On the other hand, if you're
going to do most of your byte

00:12:26.250 --> 00:12:28.980
work in native code, then
you should probably use

00:12:28.980 --> 00:12:31.380
allocateDirect to get a direct
buffer because that's going to

00:12:31.380 --> 00:12:33.730
be fast on native, but
maybe it's going

00:12:33.730 --> 00:12:35.250
to be slow on Dalvik.

00:12:35.250 --> 00:12:37.180
There's no solution that's
fast and fast.

00:12:37.180 --> 00:12:38.930
You have to choose your buffers
carefully depending on

00:12:38.930 --> 00:12:41.030
where you're going to
do most of the work.

00:12:41.030 --> 00:12:42.580
Also, don't engage in
race conditions.

00:12:42.580 --> 00:12:44.545
You might have heard about
race conditions.

00:12:44.545 --> 00:12:47.180
They are a dangerous local sport
around the border, and

00:12:47.180 --> 00:12:48.480
they're not for tourists.

00:12:48.480 --> 00:12:51.310
So if you're sharing buffers
between native thread and

00:12:51.310 --> 00:12:55.420
native code, make sure you
use the correct locking.

00:12:55.420 --> 00:12:57.530
Sometimes you can even
call GamesClient

00:12:57.530 --> 00:12:59.200
from different threads.

00:12:59.200 --> 00:13:02.730
But be careful not to call
from two threads

00:13:02.730 --> 00:13:03.550
at any given time.

00:13:03.550 --> 00:13:06.040
So use some smart locking
to make sure that

00:13:06.040 --> 00:13:07.290
that doesn't happen.

00:13:10.220 --> 00:13:13.840
And last but not least, don't
keep stuff that's not yours.

00:13:13.840 --> 00:13:15.580
That's frowned upon.

00:13:15.580 --> 00:13:17.830
I'm talking about Dalvik
references, of course.

00:13:17.830 --> 00:13:20.310
So just because you got one
through a method call, it

00:13:20.310 --> 00:13:21.660
doesn't mean you
get to keep it.

00:13:21.660 --> 00:13:23.840
If you want to make a local
reference global and keep it

00:13:23.840 --> 00:13:27.070
forever and ever, you need to
ask JNI and you need to ask

00:13:27.070 --> 00:13:27.870
JNI nicely.

00:13:27.870 --> 00:13:28.795
So what's the magic word?

00:13:28.795 --> 00:13:29.750
TOM WILSON: Please, right?

00:13:29.750 --> 00:13:30.570
BRUNO OLIVEIRA: Well,
close to that.

00:13:30.570 --> 00:13:32.040
It's NewGlobalRef.

00:13:32.040 --> 00:13:35.255
So NewGlobalRef is the magic
word that you use on JNI if

00:13:35.255 --> 00:13:38.820
you want to keep something that
it has passed to you.

00:13:38.820 --> 00:13:41.650
Now that we've talked about
all this native code stuff

00:13:41.650 --> 00:13:44.850
that's pretty much down on the
ground, let's take a break and

00:13:44.850 --> 00:13:45.950
go back to the sky.

00:13:45.950 --> 00:13:46.430
Let's talk about Cloud Save.

00:13:46.430 --> 00:13:47.992
You know, like cloud, sky?

00:13:47.992 --> 00:13:48.406
TOM WILSON: Cloud.

00:13:48.406 --> 00:13:49.120
Sky.

00:13:49.120 --> 00:13:49.850
Got it.

00:13:49.850 --> 00:13:51.710
Very clever, Bruno.

00:13:51.710 --> 00:13:53.425
So for those of you who were in
some of the previous talks

00:13:53.425 --> 00:13:55.290
today, we talked a little bit
about the Cloud Save features

00:13:55.290 --> 00:13:56.080
we're releasing.

00:13:56.080 --> 00:13:58.440
You could save your game in the
cloud, load it again later

00:13:58.440 --> 00:13:59.360
on another device.

00:13:59.360 --> 00:14:00.740
It's pretty cool, right?

00:14:00.740 --> 00:14:02.740
But sometimes you have to
deal with conflicts.

00:14:02.740 --> 00:14:04.440
This might happen if the user's
playing on multiple

00:14:04.440 --> 00:14:06.910
devices or if they play while
they're offline and then come

00:14:06.910 --> 00:14:08.140
back online later.

00:14:08.140 --> 00:14:09.510
We're going to walk through
how that works in a little

00:14:09.510 --> 00:14:10.510
more detail.

00:14:10.510 --> 00:14:12.405
As a quick refresher, if you're
going to use the App

00:14:12.405 --> 00:14:14.700
State APIs, you have to make
sure your app is actually

00:14:14.700 --> 00:14:15.840
configured to use them.

00:14:15.840 --> 00:14:18.760
So you go to the Google API
console and turn on the Google

00:14:18.760 --> 00:14:21.030
Play App State API
bit as seen here.

00:14:21.030 --> 00:14:22.680
If you've already configured
your game through the Play

00:14:22.680 --> 00:14:24.640
console by using the other
Games features,

00:14:24.640 --> 00:14:25.620
you're already set up.

00:14:25.620 --> 00:14:27.590
Everything's good to go.

00:14:27.590 --> 00:14:29.580
There are three main APIs that
you'll want to use on the

00:14:29.580 --> 00:14:30.500
AppStateClient.

00:14:30.500 --> 00:14:32.100
The first is loadState.

00:14:32.100 --> 00:14:34.610
You call this to actually load
the most recent state from the

00:14:34.610 --> 00:14:36.165
cloud onto your device.

00:14:36.165 --> 00:14:40.160
The next is updateState, and
you can call this to, well,

00:14:40.160 --> 00:14:41.990
update the state of your data.

00:14:41.990 --> 00:14:43.490
This form does a lazy update.

00:14:43.490 --> 00:14:46.000
It just schedules the update
to happen whenever we next

00:14:46.000 --> 00:14:47.150
sync to the cloud.

00:14:47.150 --> 00:14:48.990
There's another form that
you can call with an

00:14:48.990 --> 00:14:51.830
updateStateImmediate that
updates the state immediately.

00:14:51.830 --> 00:14:52.960
You might be sensing a
pattern with some of

00:14:52.960 --> 00:14:54.540
these method names.

00:14:54.540 --> 00:14:56.470
Finally, there's resolveState.

00:14:56.470 --> 00:14:58.080
This is the API that you call
when you actually want to

00:14:58.080 --> 00:14:59.440
resolve a conflict, and
it's what we're

00:14:59.440 --> 00:15:01.570
going to focus on here.

00:15:01.570 --> 00:15:03.750
As you saw in the previous
slide, whenever you actually

00:15:03.750 --> 00:15:05.860
load state, the first argument
you pass in is an

00:15:05.860 --> 00:15:07.310
OnStateLoadedListener.

00:15:07.310 --> 00:15:09.250
This is an interface that
has two methods.

00:15:09.250 --> 00:15:11.660
The first is onStateLoaded, and
that's what we call in the

00:15:11.660 --> 00:15:14.070
normal case where everything's
working perfectly.

00:15:14.070 --> 00:15:16.340
The second callback is
onStateConflict, and that's

00:15:16.340 --> 00:15:18.210
what happens when our SDK
detects that there's been a

00:15:18.210 --> 00:15:19.990
conflict somewhere
in your data.

00:15:19.990 --> 00:15:22.060
It gives you back the data
that's stored locally as well

00:15:22.060 --> 00:15:23.620
as the data that's
on the cloud.

00:15:23.620 --> 00:15:25.650
So to help illustrate what's
actually going on here, we're

00:15:25.650 --> 00:15:27.330
going to talk about my
favorite new game.

00:15:27.330 --> 00:15:29.790
It's this totally rad, totally
awesome new game, and it's

00:15:29.790 --> 00:15:32.310
called "Pick a Color." It's
going to be the next number

00:15:32.310 --> 00:15:33.710
one hit on the Play
Store, I'm sure.

00:15:33.710 --> 00:15:35.330
BRUNO OLIVEIRA: Awesome game.

00:15:35.330 --> 00:15:37.310
TOM WILSON: So when we talked
in the introduction talk, we

00:15:37.310 --> 00:15:38.740
mentioned that each write
to the server is

00:15:38.740 --> 00:15:40.120
associated with a version.

00:15:40.120 --> 00:15:42.430
The way we deal with detecting
conflicts is to separate our

00:15:42.430 --> 00:15:44.440
storage on the device
into two areas.

00:15:44.440 --> 00:15:46.460
We have one for the local state
and one for the latest

00:15:46.460 --> 00:15:47.910
we know from the server.

00:15:47.910 --> 00:15:50.160
We also maintain a dirty bit
to help indicate whether or

00:15:50.160 --> 00:15:52.380
not the local data's
been modified.

00:15:52.380 --> 00:15:54.260
So let's walk through what
happens if I'm actually

00:15:54.260 --> 00:15:57.930
playing "Pick a Color." I pick
blue as my favorite color, and

00:15:57.930 --> 00:15:59.890
that writes locally that
my data is blue and

00:15:59.890 --> 00:16:02.080
then marks it as dirty.

00:16:02.080 --> 00:16:04.290
Now we're going to sync, send
that up to the server, and

00:16:04.290 --> 00:16:07.690
that associates a new version
from the server of ABC.

00:16:07.690 --> 00:16:10.780
When that returns to the device
and says, hey, success,

00:16:10.780 --> 00:16:12.590
it's going to mark that the data
is no longer dirty and

00:16:12.590 --> 00:16:15.350
store ABC as the current
version.

00:16:15.350 --> 00:16:18.130
Now if I choose yellow, I'm
going to write locally that

00:16:18.130 --> 00:16:20.610
the data is yellow and
mark it as dirty.

00:16:20.610 --> 00:16:23.710
So what's going to happen if
my device goes offline now?

00:16:23.710 --> 00:16:26.140
Well, it still knows about the
data that I'm holding, it

00:16:26.140 --> 00:16:28.290
still has all that state
locally, and so the next time

00:16:28.290 --> 00:16:30.130
it comes online, it's going
to try to sync.

00:16:30.130 --> 00:16:32.000
But what's going to happen?

00:16:32.000 --> 00:16:33.995
Let's imagine that we've got
someone else who's got a

00:16:33.995 --> 00:16:36.480
separate device and has randomly
chosen their favorite

00:16:36.480 --> 00:16:37.890
color to be green.

00:16:37.890 --> 00:16:40.910
I'm going to come back online,
and now I don't know what's

00:16:40.910 --> 00:16:41.540
going to happen, right?

00:16:41.540 --> 00:16:43.400
There's going to be something
weird here.

00:16:43.400 --> 00:16:46.490
So when I actually call load
state, I'm going to get called

00:16:46.490 --> 00:16:49.780
back in to pick a color with the
onStateConflict callback.

00:16:49.780 --> 00:16:53.010
We'll have local data as yellow,
server data as green,

00:16:53.010 --> 00:16:54.730
and the version that it returns
to us is the latest

00:16:54.730 --> 00:16:57.320
from the server which is
DEF, in this case.

00:16:57.320 --> 00:16:58.960
So how can "Pick a
Color" actually

00:16:58.960 --> 00:17:00.200
resolve this conflict?

00:17:00.200 --> 00:17:01.180
You've got colors, right?

00:17:01.180 --> 00:17:02.860
They don't merge very well.

00:17:02.860 --> 00:17:04.990
So maybe it's just going
to ask me to pick my

00:17:04.990 --> 00:17:06.780
new favorite color.

00:17:06.780 --> 00:17:09.130
I'm a typical user and, of
course, that means I'm always

00:17:09.130 --> 00:17:10.089
consistent.

00:17:10.089 --> 00:17:12.280
So now I've changed my
mind and red is my

00:17:12.280 --> 00:17:13.470
new favorite color.

00:17:13.470 --> 00:17:16.640
So it's going to call
resolveState with data red and

00:17:16.640 --> 00:17:20.520
version DEF, which updates the
local data and the version.

00:17:20.520 --> 00:17:21.750
We send that to the server.

00:17:21.750 --> 00:17:23.930
The server now has a new version
in the cloud, and when

00:17:23.930 --> 00:17:26.640
it calls us back with success,
we mark that the data is no

00:17:26.640 --> 00:17:28.830
longer dirty and update
our records.

00:17:28.830 --> 00:17:29.510
There we go.

00:17:29.510 --> 00:17:30.970
The conflict's resolved.

00:17:30.970 --> 00:17:34.760
So the resolveState API takes
in new data that you want to

00:17:34.760 --> 00:17:35.950
pass up to the server.

00:17:35.950 --> 00:17:39.580
You're supposed to pass the best
data for your users, but

00:17:39.580 --> 00:17:42.500
how do you know what
the best data is?

00:17:42.500 --> 00:17:44.010
That's going to depend
on your game.

00:17:44.010 --> 00:17:46.330
You could just take the most
recent from the server-- maybe

00:17:46.330 --> 00:17:47.650
newest is best--

00:17:47.650 --> 00:17:49.280
or you could prompt the
user, kind of like

00:17:49.280 --> 00:17:50.420
"Pick a Color" did.

00:17:50.420 --> 00:17:52.750
But in general, you're going
to want to do something a

00:17:52.750 --> 00:17:53.780
little bit better than that.

00:17:53.780 --> 00:17:56.690
If you store some data in your
state, you could actually do a

00:17:56.690 --> 00:17:59.500
Smart Merge and figure out how
to actually get the user into

00:17:59.500 --> 00:18:00.990
the best possible state.

00:18:00.990 --> 00:18:03.230
Let's take a look from
another sample game.

00:18:03.230 --> 00:18:04.570
This is our other
favorite game.

00:18:04.570 --> 00:18:05.210
It's called--

00:18:05.210 --> 00:18:06.290
BRUNO OLIVEIRA: It's even better
than "Pick a Color."

00:18:06.290 --> 00:18:07.930
TOM WILSON: I don't
know about that.

00:18:07.930 --> 00:18:09.190
It exists, so maybe
it's better.

00:18:09.190 --> 00:18:11.430
But this is one of the sample
games that we actually

00:18:11.430 --> 00:18:12.760
released with the platform.

00:18:12.760 --> 00:18:14.980
You can see it's a really,
very exciting game.

00:18:14.980 --> 00:18:17.310
It's got a bunch of worlds, a
bunch of levels, lots of deep,

00:18:17.310 --> 00:18:18.600
engaging gameplay.

00:18:18.600 --> 00:18:21.500
And to play this game, it's
really, really hard, but you

00:18:21.500 --> 00:18:24.400
basically click on a level and
it asks you how many stars you

00:18:24.400 --> 00:18:27.160
got, and then it gives
you that many stars.

00:18:27.160 --> 00:18:29.830
It's really hard.

00:18:29.830 --> 00:18:32.010
This is what our savedState
for that game looks like.

00:18:32.010 --> 00:18:33.990
It's really just a map that says
how many stars I got on

00:18:33.990 --> 00:18:34.830
each level.

00:18:34.830 --> 00:18:37.890
So if I have a conflict between
this state on the left

00:18:37.890 --> 00:18:41.220
and this state on the right,
which one of them is best?

00:18:41.220 --> 00:18:42.990
Well, we don't really
know, right?

00:18:42.990 --> 00:18:45.660
I got different numbers of stars
on a different subset of

00:18:45.660 --> 00:18:47.280
levels in each one.

00:18:47.280 --> 00:18:48.990
It was really hard to
get all those stars.

00:18:48.990 --> 00:18:51.640
It took me a lot of hard work
and a lot of pain, so I really

00:18:51.640 --> 00:18:52.830
don't want to lose those.

00:18:52.830 --> 00:18:56.360
So the right way to do this
would be for a game to build a

00:18:56.360 --> 00:18:59.510
combined map that actually takes
in the keys from both

00:18:59.510 --> 00:19:01.960
and then in the case of
collision between the keys,

00:19:01.960 --> 00:19:03.580
takes the highest value.

00:19:03.580 --> 00:19:04.120
Pretty simple.

00:19:04.120 --> 00:19:05.990
On each level, give me the best
number of stars that I

00:19:05.990 --> 00:19:07.450
possibly got.

00:19:07.450 --> 00:19:09.790
The overall takeaway here, you
have to figure out the right

00:19:09.790 --> 00:19:12.700
thing to do for your game in
order to avoid losing progress

00:19:12.700 --> 00:19:13.990
for your users.

00:19:13.990 --> 00:19:15.700
So hopefully that gives you a
little bit of insight into how

00:19:15.700 --> 00:19:18.030
we handle conflicts in the SDK,
what kinds of things you

00:19:18.030 --> 00:19:20.170
should do with your game to
actually handle this.

00:19:20.170 --> 00:19:22.420
Most of the example games we
used here are pretty basic--

00:19:22.420 --> 00:19:24.250
I mean, "Pick a Color" and
"CollectAllTheStars" are

00:19:24.250 --> 00:19:27.260
awesome, but they're not
the most state of

00:19:27.260 --> 00:19:28.520
the art games ever.

00:19:28.520 --> 00:19:30.130
Bruno, do you have any advice
for people who actually want

00:19:30.130 --> 00:19:32.940
to make fancier, more exciting,
more graphically

00:19:32.940 --> 00:19:33.960
intense games?

00:19:33.960 --> 00:19:34.400
BRUNO OLIVEIRA: Sure.

00:19:34.400 --> 00:19:36.780
I know that after
"CollectAllTheStars" and "Pick

00:19:36.780 --> 00:19:39.740
a Color," that sets the bar
pretty high for games.

00:19:39.740 --> 00:19:43.330
But even though it sets the bar
pretty high, you can still

00:19:43.330 --> 00:19:44.550
make good games after that.

00:19:44.550 --> 00:19:45.240
TOM WILSON: You can do better.

00:19:45.240 --> 00:19:46.610
BRUNO OLIVEIRA: Yeah,
you can do better.

00:19:46.610 --> 00:19:48.530
So let's talk about third
party engines.

00:19:48.530 --> 00:19:50.780
Now, there are exceptions, of
course, but most nontrivial

00:19:50.780 --> 00:19:52.110
games are probably going
to want to use an

00:19:52.110 --> 00:19:53.500
engine of some sort.

00:19:53.500 --> 00:19:54.570
You've been down this
road before.

00:19:54.570 --> 00:19:55.980
We're all developers.

00:19:55.980 --> 00:19:57.140
You started thinking, well,
engines are for

00:19:57.140 --> 00:19:58.400
lazy people, right?

00:19:58.400 --> 00:20:00.110
And then, man, this
shader stuff is

00:20:00.110 --> 00:20:01.670
actually kind of hard.

00:20:01.670 --> 00:20:03.890
And then wait, we can actually
make it work if we just render

00:20:03.890 --> 00:20:05.900
everything backwards three
times and then flip the

00:20:05.900 --> 00:20:08.240
y-axis, and that doesn't work.

00:20:08.240 --> 00:20:10.660
And then, we're never going
to ship this thing.

00:20:10.660 --> 00:20:12.420
OK, let's use an engine.

00:20:12.420 --> 00:20:14.060
So you've been down
this road before.

00:20:14.060 --> 00:20:16.210
So there are two kinds of
engines, the ones that you

00:20:16.210 --> 00:20:19.960
have control of and then you can
call them from your code,

00:20:19.960 --> 00:20:22.700
and this other type that works
in the reverse order.

00:20:22.700 --> 00:20:24.620
In this case, you don't
call the engine.

00:20:24.620 --> 00:20:27.040
The engine is going
to call you.

00:20:27.040 --> 00:20:29.240
The first type is trivial
because it's no different from

00:20:29.240 --> 00:20:31.670
integrating with any other
application, so we're going to

00:20:31.670 --> 00:20:35.050
focus on the second kind, which
can be more challenging.

00:20:35.050 --> 00:20:37.720
So the first thing you have to
figure out in your engine is

00:20:37.720 --> 00:20:39.710
where it's hiding
AndroidManifest.xml.

00:20:39.710 --> 00:20:41.760
It's definitely hiding that
somewhere because if it

00:20:41.760 --> 00:20:44.840
produces an Android APK, it has
to hide that somewhere.

00:20:44.840 --> 00:20:48.100
So there should be an easy way
to override it or add extra

00:20:48.100 --> 00:20:48.790
stuff into it.

00:20:48.790 --> 00:20:50.770
TOM WILSON: If there isn't, it's
seriously time to find a

00:20:50.770 --> 00:20:51.670
new engine.

00:20:51.670 --> 00:20:52.580
That's kind of important.

00:20:52.580 --> 00:20:53.970
BRUNO OLIVEIRA: Because
if you can't override

00:20:53.970 --> 00:20:55.150
AndroidManifest, there's
a whole bunch of

00:20:55.150 --> 00:20:56.250
things you can't do.

00:20:56.250 --> 00:20:59.070
So once you figure out where
your engine is hiding that,

00:20:59.070 --> 00:21:00.830
then you have to add some
things into it.

00:21:00.830 --> 00:21:03.560
Particularly, you have to make
sure that the Games Metadata

00:21:03.560 --> 00:21:04.690
tag is there.

00:21:04.690 --> 00:21:06.750
And of course, if you use Cloud
Save, you have to also

00:21:06.750 --> 00:21:09.130
make sure that the Cloud Save
metadata is also there, which

00:21:09.130 --> 00:21:12.170
looks just like that one except
it says AppState.

00:21:12.170 --> 00:21:14.560
Also remember that this is a
resource reference, so you

00:21:14.560 --> 00:21:17.000
also have to add that resource
somehow in the engine.

00:21:17.000 --> 00:21:19.500
That's usually done through
an XML file.

00:21:19.500 --> 00:21:21.870
Now, you usually have two parts,
which is the platform

00:21:21.870 --> 00:21:24.210
independent code, which might
be some game scripting

00:21:24.210 --> 00:21:26.800
language, and then you have the
platform dependent code.

00:21:26.800 --> 00:21:28.690
So you have to figure out where
to put the platform

00:21:28.690 --> 00:21:30.170
dependent code in your engine.

00:21:30.170 --> 00:21:33.430
So that's going to vary from
engine to engine, but usually,

00:21:33.430 --> 00:21:35.740
when we're talking about the
Android platform, that

00:21:35.740 --> 00:21:37.330
typically means just
dropping a JAR file

00:21:37.330 --> 00:21:38.860
somewhere in the engine.

00:21:38.860 --> 00:21:41.150
And then there's going to be
a way through which you can

00:21:41.150 --> 00:21:43.850
access the JAR from your
platform independent code.

00:21:43.850 --> 00:21:46.280
Some engines have easy
integrations with Java.

00:21:46.280 --> 00:21:50.690
If it doesn't, then you may
have to resort to JNI.

00:21:50.690 --> 00:21:53.850
But either way, you can
access your JAR file.

00:21:53.850 --> 00:21:55.640
Now it's time to set
up your activity.

00:21:55.640 --> 00:21:58.000
If you can directly subclass
BaseGameActivity, that's the

00:21:58.000 --> 00:22:01.080
best case scenario because
BaseGameActivity implements

00:22:01.080 --> 00:22:03.350
the whole sign-in
cycle for you.

00:22:03.350 --> 00:22:05.880
If you can't do that, we're
going to talk about next.

00:22:05.880 --> 00:22:07.530
But BaseGameActivity
is available

00:22:07.530 --> 00:22:09.260
on the Samples Package.

00:22:09.260 --> 00:22:11.160
Now, if you can't for
some reason subclass

00:22:11.160 --> 00:22:12.500
BaseGameActivity, don't worry.

00:22:12.500 --> 00:22:15.150
Not all is lost because you
can still use GameHelper.

00:22:15.150 --> 00:22:17.780
Actually, BaseGameActivity is
a pretty lazy class because

00:22:17.780 --> 00:22:20.130
it's just really a wraparound
GameHelper.

00:22:20.130 --> 00:22:21.873
So if you can't use
BaseGameActivity, you can

00:22:21.873 --> 00:22:23.700
still use GameHelper,
which actually

00:22:23.700 --> 00:22:24.750
does most of the work.

00:22:24.750 --> 00:22:27.115
BaseGameActivity just takes
the credit for it.

00:22:27.115 --> 00:22:30.490
Now, specifically, you have to
hook up onStart, onStop, and

00:22:30.490 --> 00:22:32.820
onActivityResult on your
Activities Life Cycle into

00:22:32.820 --> 00:22:33.870
GameHelper.

00:22:33.870 --> 00:22:36.580
Then you have to call
onUserInitiatedSignIn whenever

00:22:36.580 --> 00:22:38.040
the user clicks the
Sign-In button.

00:22:38.040 --> 00:22:40.010
Of course, the Sign-In button is
up to you to implement, so

00:22:40.010 --> 00:22:43.560
it might be a rotating,
floating, 3D Sign-In button,

00:22:43.560 --> 00:22:45.540
or even 4D.

00:22:45.540 --> 00:22:47.970
When the user clicks that, you
call onUserInitiatedSignIn to

00:22:47.970 --> 00:22:50.520
begin the sign-in process, and
then you have to listen for

00:22:50.520 --> 00:22:53.120
the sign-in callbacks, which
notify you when the sign-in

00:22:53.120 --> 00:22:55.510
has succeeded or failed.

00:22:55.510 --> 00:22:58.710
So usually hooking up onStart
and onStop are not really a

00:22:58.710 --> 00:23:01.840
problem because most engines
have good equivalents for that

00:23:01.840 --> 00:23:03.830
because those are pretty common
life cycle methods.

00:23:03.830 --> 00:23:06.800
Now, you might have a problem
with onActivityResult.

00:23:06.800 --> 00:23:10.840
That can be more troublesome
because if your engine doesn't

00:23:10.840 --> 00:23:13.680
give me access to that, well
then, there's really only one

00:23:13.680 --> 00:23:17.030
thing left to do, which is you
have to override your engine's

00:23:17.030 --> 00:23:19.260
base activity and then update
your AndroidManifest to

00:23:19.260 --> 00:23:19.820
reflect that.

00:23:19.820 --> 00:23:22.970
So you find out what your
engine's base activity is,

00:23:22.970 --> 00:23:25.560
then override, make your own
activity base on that, and

00:23:25.560 --> 00:23:28.250
then override onActivityResult.

00:23:28.250 --> 00:23:31.370
Also, remember what
we mentioned

00:23:31.370 --> 00:23:32.480
about threads before.

00:23:32.480 --> 00:23:34.370
If you're sure that your engine
always calls everything

00:23:34.370 --> 00:23:36.200
on the UI thread, that's
no problem.

00:23:36.200 --> 00:23:37.360
Don't worry about anything.

00:23:37.360 --> 00:23:40.380
If you're using any thread
that's different from the UI

00:23:40.380 --> 00:23:42.940
thread, remember to use the
off-thread developer's best

00:23:42.940 --> 00:23:43.960
friend, which is, of course,

00:23:43.960 --> 00:23:46.270
runOnUiThread, just to be safe.

00:23:46.270 --> 00:23:49.130
Summarizing, whenever the Games
API wants to talk to

00:23:49.130 --> 00:23:51.660
your code, it's going to invoke
your platform-dependent

00:23:51.660 --> 00:23:53.780
code, which includes the
GameHelper, and then your game

00:23:53.780 --> 00:23:55.900
logic is going to be notified
through the listeners that you

00:23:55.900 --> 00:23:57.940
installed on GameHelper.

00:23:57.940 --> 00:23:59.930
If you go the other way--

00:23:59.930 --> 00:24:02.160
suppose you want to call
the Games API--

00:24:02.160 --> 00:24:04.210
then you call your
platform-dependent code, and

00:24:04.210 --> 00:24:06.870
then you post a runnable to the
UI thread, and then on the

00:24:06.870 --> 00:24:08.520
UI thread-- that's all on your

00:24:08.520 --> 00:24:09.950
platform-dependent code, of course.

00:24:09.950 --> 00:24:12.040
Then that runnable's going to
call GameHelper, and then

00:24:12.040 --> 00:24:14.850
GameHelper is going to make
the Games API call.

00:24:14.850 --> 00:24:17.220
Now, I know that this looks
complicated, but it actually

00:24:17.220 --> 00:24:18.960
looks more complicated
than it actually is.

00:24:18.960 --> 00:24:21.120
And to show you that this is
not just theory, we've

00:24:21.120 --> 00:24:24.415
actually made a demo
integration, and we published

00:24:24.415 --> 00:24:25.320
that at that URL.

00:24:25.320 --> 00:24:27.880
So that's already live, so feel
free to download that and

00:24:27.880 --> 00:24:30.350
take a look at that game.

00:24:30.350 --> 00:24:34.720
So now your immersive,
nightmarish, 3D zombie game is

00:24:34.720 --> 00:24:36.800
all fully integrated
with our API.

00:24:36.800 --> 00:24:38.650
Now since you're putting all
this work to make sure that

00:24:38.650 --> 00:24:41.710
you have this awesome, immersive
experience, you

00:24:41.710 --> 00:24:43.320
probably want to make sure
that you don't break that

00:24:43.320 --> 00:24:45.830
atmosphere by showing screens
that have nothing to do with

00:24:45.830 --> 00:24:46.700
zombies at all.

00:24:46.700 --> 00:24:47.990
So how do you do that?

00:24:47.990 --> 00:24:50.890
TOM WILSON: Well, we provided
a lot of really cool UI

00:24:50.890 --> 00:24:54.360
widgets in our SDK for you,
but sometimes those aren't

00:24:54.360 --> 00:24:55.170
right for your game.

00:24:55.170 --> 00:24:56.870
Sometimes they don't have the
right style, they don't have

00:24:56.870 --> 00:24:57.790
the right theme.

00:24:57.790 --> 00:24:59.150
They don't really look right.

00:24:59.150 --> 00:24:59.960
It's OK.

00:24:59.960 --> 00:25:00.960
We're not going to be
offended if you

00:25:00.960 --> 00:25:02.410
don't like our UI style.

00:25:02.410 --> 00:25:02.780
BRUNO OLIVEIRA: Much.

00:25:02.780 --> 00:25:03.490
TOM WILSON: Much.

00:25:03.490 --> 00:25:04.170
Maybe a little.

00:25:04.170 --> 00:25:07.345
But you can actually write
your own custom UIs.

00:25:07.345 --> 00:25:09.910
So this is "Nostalgic Racer."
It's a little sample game that

00:25:09.910 --> 00:25:12.000
Bruno wrote to test out
some of our platform.

00:25:12.000 --> 00:25:12.270
Wait.

00:25:12.270 --> 00:25:12.840
Actually, hang on.

00:25:12.840 --> 00:25:14.260
It says right here that I'm
supposed to wait for the

00:25:14.260 --> 00:25:15.710
audience to ooh and aah.

00:25:15.710 --> 00:25:16.700
Audience?

00:25:16.700 --> 00:25:17.046
Ooh.

00:25:17.046 --> 00:25:17.740
AUDIENCE: Ooh.

00:25:17.740 --> 00:25:19.420
Aah.

00:25:19.420 --> 00:25:19.830
TOM WILSON: There we go.

00:25:19.830 --> 00:25:20.560
All right, cool.

00:25:20.560 --> 00:25:22.760
Only a little bit of prompting
for that one.

00:25:22.760 --> 00:25:24.130
BRUNO OLIVEIRA: It's got
square wheels, which is

00:25:24.130 --> 00:25:26.030
actually how physics used
to work in the '80s.

00:25:26.030 --> 00:25:26.690
TOM WILSON: Right.

00:25:26.690 --> 00:25:28.940
Square wheels, giant
pixels everywhere.

00:25:28.940 --> 00:25:30.540
It's really cool,
really retro.

00:25:30.540 --> 00:25:32.230
But here's the problem.

00:25:32.230 --> 00:25:34.190
Here's our standard
leaderboard UI.

00:25:34.190 --> 00:25:38.165
It's slick, it's high res, but
"Nostalgic Racer" isn't really

00:25:38.165 --> 00:25:38.750
either of those.

00:25:38.750 --> 00:25:39.530
BRUNO OLIVEIRA: It's neither
of those things.

00:25:39.530 --> 00:25:40.770
TOM WILSON: It doesn't
really fit.

00:25:40.770 --> 00:25:44.366
So instead, we wrote a little
custom widget here that's,

00:25:44.366 --> 00:25:47.660
well, more nostalgic, keeps the
users in that vibe, keeps

00:25:47.660 --> 00:25:49.840
it all going.

00:25:49.840 --> 00:25:51.790
So in order to let you build
these experiences, we made

00:25:51.790 --> 00:25:54.740
sure that we had a Raw Data API
for all of our features--

00:25:54.740 --> 00:25:56.610
achievements, leaderboards,
players,

00:25:56.610 --> 00:25:58.070
invitations, et cetera.

00:25:58.070 --> 00:26:00.090
It was a really important design
principle for us when

00:26:00.090 --> 00:26:02.450
we were building all of our
widgets that anything we

00:26:02.450 --> 00:26:04.920
wanted had to be built on
APIs that were available

00:26:04.920 --> 00:26:06.340
as part of the SDK.

00:26:06.340 --> 00:26:09.490
Otherwise, we're kind of
cheating, and that's not cool.

00:26:09.490 --> 00:26:11.310
So how do you use these APIs?

00:26:11.310 --> 00:26:13.240
Here's an example using
our Leaderboard APIs.

00:26:13.240 --> 00:26:14.800
And there's obviously a lot
more and a lot more

00:26:14.800 --> 00:26:17.220
documentation available
online.

00:26:17.220 --> 00:26:19.810
But in this case, you create a
listener, then you call one of

00:26:19.810 --> 00:26:21.390
our score loading methods.

00:26:21.390 --> 00:26:23.560
This one in particular is
asking for the window of

00:26:23.560 --> 00:26:26.570
scores around the current player
on the All Time Social

00:26:26.570 --> 00:26:29.410
Leaderboard, so the best scores
from your friends.

00:26:29.410 --> 00:26:31.570
Once the scores are loaded,
you'll get the

00:26:31.570 --> 00:26:34.350
onLeaderboardScoresLoaded
callback, and that'll give you

00:26:34.350 --> 00:26:35.610
back the actual data
that you want.

00:26:35.610 --> 00:26:38.370
The statusCode here tells you
what happened during the load.

00:26:38.370 --> 00:26:40.520
So if it's OK, it means
you've got new data,

00:26:40.520 --> 00:26:41.470
everything's great.

00:26:41.470 --> 00:26:43.560
If it's something else, you'll
read the documentation and see

00:26:43.560 --> 00:26:46.620
what to do in that case, and
then you actually get the

00:26:46.620 --> 00:26:48.500
actual data for your scores.

00:26:48.500 --> 00:26:51.330
Our API provides data in the
form of data buffers, which

00:26:51.330 --> 00:26:52.520
are kind of like lists.

00:26:52.520 --> 00:26:54.440
You iterate through them and
grab the data you want and

00:26:54.440 --> 00:26:56.100
bind it to your views.

00:26:56.100 --> 00:26:56.950
So that's great.

00:26:56.950 --> 00:27:00.170
It lets you put together all
these awesome lists of data.

00:27:00.170 --> 00:27:03.210
But just remember that
leaderboards

00:27:03.210 --> 00:27:04.820
don't have to be boring.

00:27:04.820 --> 00:27:07.160
Just because we're giving you an
API that looks like a list

00:27:07.160 --> 00:27:09.770
of scores and names and numbers,
that's not what you

00:27:09.770 --> 00:27:10.420
have to build.

00:27:10.420 --> 00:27:12.150
You can build something
really cool.

00:27:12.150 --> 00:27:14.420
As an example of this-- you saw
this during the keynote--

00:27:14.420 --> 00:27:16.980
but this was a really cool
integration from our friends

00:27:16.980 --> 00:27:19.800
at 2D Boy for their game "World
of Goo." The clouds

00:27:19.800 --> 00:27:21.700
represent your friends, and then
you can kind of see your

00:27:21.700 --> 00:27:25.050
own cloud moving around as you
up and down your tower.

00:27:25.050 --> 00:27:26.890
It shows you the scores, but
it shows you them in an

00:27:26.890 --> 00:27:29.620
in-game, really interesting,
really fun way.

00:27:29.620 --> 00:27:31.360
So we're really excited to see
what kind of stuff you guys

00:27:31.360 --> 00:27:33.870
can do with this and what kind
of cool games we're going to

00:27:33.870 --> 00:27:35.150
get out of this.

00:27:35.150 --> 00:27:37.550
We've talked a little bit about
building custom UIs, but

00:27:37.550 --> 00:27:40.000
let's switch gears a little bit
here and talk about some

00:27:40.000 --> 00:27:43.250
of our actual UI widgets.

00:27:43.250 --> 00:27:44.940
BRUNO OLIVEIRA: So who likes
to wait for stuff?

00:27:44.940 --> 00:27:46.015
TOM WILSON: I do.

00:27:46.015 --> 00:27:47.350
Totally.

00:27:47.350 --> 00:27:48.270
BRUNO OLIVEIRA: Waiting
is awesome.

00:27:48.270 --> 00:27:50.040
So when you start a multiplayer
game, you have to

00:27:50.040 --> 00:27:51.510
wait for your friends to join.

00:27:51.510 --> 00:27:52.920
I mean, that's just life.

00:27:52.920 --> 00:27:52.990
TOM WILSON: I don't know.

00:27:52.990 --> 00:27:54.590
I don't think people are
actually that happy when

00:27:54.590 --> 00:27:55.540
they're waiting, unless
they're me.

00:27:55.540 --> 00:27:56.980
BRUNO OLIVEIRA: Oh yeah,
that's true.

00:27:56.980 --> 00:27:58.990
Pretty soon, the users are
going to be like that if

00:27:58.990 --> 00:27:59.420
they're waiting.

00:27:59.420 --> 00:28:00.750
And then they're going
to go like that, and

00:28:00.750 --> 00:28:01.840
nobody wants that.

00:28:01.840 --> 00:28:03.180
So how can you make
that better?

00:28:03.180 --> 00:28:04.330
TOM WILSON: I mean, besides
faster friends?

00:28:04.330 --> 00:28:05.920
BRUNO OLIVEIRA: Yeah, besides
getting faster friends and

00:28:05.920 --> 00:28:07.330
unfriending the slow ones.

00:28:07.330 --> 00:28:07.700
That too.

00:28:07.700 --> 00:28:10.880
But even if you can't get faster
friends, you should at

00:28:10.880 --> 00:28:12.910
least show a waiting screen
that's not that boring.

00:28:12.910 --> 00:28:13.680
How do you do that?

00:28:13.680 --> 00:28:15.530
So for instance, with
something like this.

00:28:15.530 --> 00:28:18.600
This is our built-in Waiting
Room UI that you get for free

00:28:18.600 --> 00:28:19.670
with our API.

00:28:19.670 --> 00:28:22.600
So it actually gives me a
sense of progress as I'm

00:28:22.600 --> 00:28:23.290
waiting for the game.

00:28:23.290 --> 00:28:25.460
It shows me which participants
have joined, which ones are

00:28:25.460 --> 00:28:27.440
invited, and so on and so forth,
so I have a general

00:28:27.440 --> 00:28:31.110
sense of the progress as
the connection happens.

00:28:31.110 --> 00:28:34.740
So to launch it, first of all,
you have to decide what's the

00:28:34.740 --> 00:28:37.420
minimum number of players that
you need to start the game in

00:28:37.420 --> 00:28:38.770
a way that makes sense.

00:28:38.770 --> 00:28:41.740
In this simple example, we're
just using int max because

00:28:41.740 --> 00:28:42.690
this means everybody.

00:28:42.690 --> 00:28:45.890
We want to wait for everybody
to join to start the game.

00:28:45.890 --> 00:28:49.240
And then what I do is I get a
getRealTimeWaitingRoomIntent

00:28:49.240 --> 00:28:52.010
from the GamesClient, and then
I launch that intent.

00:28:52.010 --> 00:28:54.620
And notice that I should do that
both from onRoomCreated

00:28:54.620 --> 00:28:57.250
and onRoomJoined because those
are the two ways in which you

00:28:57.250 --> 00:28:58.380
can find yourself in a room.

00:28:58.380 --> 00:29:00.970
You either create a room or
you're joining a room that

00:29:00.970 --> 00:29:01.890
already exists.

00:29:01.890 --> 00:29:04.400
So on those two callbacks,
you create the waiting

00:29:04.400 --> 00:29:06.420
room just like that.

00:29:06.420 --> 00:29:08.360
Now eventually, the waiting
room is going to get

00:29:08.360 --> 00:29:10.070
dismissed, and when that
happens, that's going to

00:29:10.070 --> 00:29:12.790
happen for one of
three reasons.

00:29:12.790 --> 00:29:15.900
First of all is if you get
Activity.RESULT_OK.

00:29:15.900 --> 00:29:17.895
This means that the Waiting Room
was dismissed because the

00:29:17.895 --> 00:29:18.860
game can start.

00:29:18.860 --> 00:29:21.190
This happens when everybody's
connected and you can start

00:29:21.190 --> 00:29:22.190
right away.

00:29:22.190 --> 00:29:25.510
If the user specifically asks
to leave the room from the

00:29:25.510 --> 00:29:27.900
Waiting Room UI, you're going
to get RESULT_LEFT_ROOM.

00:29:27.900 --> 00:29:29.700
In this case, you should
leave the room.

00:29:29.700 --> 00:29:31.450
Remember that the Waiting Room
UI is nothing but that.

00:29:31.450 --> 00:29:32.050
It's a UI.

00:29:32.050 --> 00:29:34.050
So it doesn't actually leave
the room for you.

00:29:34.050 --> 00:29:35.820
You actually have to write the
code that leaves the room

00:29:35.820 --> 00:29:37.520
there, which is just one line.

00:29:37.520 --> 00:29:39.580
And then, of course, what might
have happened is that

00:29:39.580 --> 00:29:42.090
the user dismissed the waiting
room, pressing the Back button

00:29:42.090 --> 00:29:43.280
or the Up button.

00:29:43.280 --> 00:29:46.250
In this case, the actual meaning
of that is pretty much

00:29:46.250 --> 00:29:47.380
up to your game.

00:29:47.380 --> 00:29:49.590
You might want to make that the
same as leaving the room,

00:29:49.590 --> 00:29:51.520
or you might just want to
minimize the Waiting Room UI

00:29:51.520 --> 00:29:54.410
and keep that going in the
background, however you wish.

00:29:54.410 --> 00:29:57.120
So that's going to depend
on your game.

00:29:57.120 --> 00:29:59.510
Now, it's important to realize
that when you're showing the

00:29:59.510 --> 00:30:02.470
waiting room, if you don't
specify int max and you

00:30:02.470 --> 00:30:04.560
specify an actual number of
players that the game can

00:30:04.560 --> 00:30:06.750
start with-- say, for
example, two--

00:30:06.750 --> 00:30:11.280
then if that is smaller than the
number of players that are

00:30:11.280 --> 00:30:14.770
actually playing, what may
happen is that the players may

00:30:14.770 --> 00:30:16.600
hit a button that's called
Start Early.

00:30:16.600 --> 00:30:19.100
So whenever you have that number
of participants, the

00:30:19.100 --> 00:30:21.780
Start Early button is going
to be enabled on the UI.

00:30:21.780 --> 00:30:24.450
In that case, be aware that not
everybody is going to hit

00:30:24.450 --> 00:30:25.700
that button at the same time.

00:30:30.260 --> 00:30:32.400
Suppose that I invited four
players and I have three, so

00:30:32.400 --> 00:30:34.230
it's more than enough to start
the game because the minimum

00:30:34.230 --> 00:30:37.050
is two, and then one of them
clicks the Start Early button.

00:30:37.050 --> 00:30:38.980
The other ones are not going
to realize that unless you

00:30:38.980 --> 00:30:40.020
implement that.

00:30:40.020 --> 00:30:42.880
So it's very important that you
send a real time message

00:30:42.880 --> 00:30:44.270
to the other participants
saying, hey, we're

00:30:44.270 --> 00:30:45.370
starting the game.

00:30:45.370 --> 00:30:48.200
And then when you get the real
time message that we are

00:30:48.200 --> 00:30:50.550
starting early, you finish the
waiting room, you dismiss it

00:30:50.550 --> 00:30:53.300
from the screen, and then
start the game.

00:30:53.300 --> 00:30:56.290
Now, after the waiting room goes
away, the game starts.

00:30:56.290 --> 00:30:57.510
Yay!

00:30:57.510 --> 00:30:58.050
But wait a second.

00:30:58.050 --> 00:30:59.980
That's not the game that
I signed up for.

00:30:59.980 --> 00:31:02.720
I wanted to play a cooperative
game, and suddenly, I'm

00:31:02.720 --> 00:31:04.520
surprised that everyone's
killing everybody.

00:31:04.520 --> 00:31:05.530
So what's happening?

00:31:05.530 --> 00:31:08.550
I think I just got automatched
into the wrong type of game.

00:31:08.550 --> 00:31:10.840
So, Tom, how can I stop
that from happening?

00:31:10.840 --> 00:31:12.790
TOM WILSON: Well, fortunately,
we thought about this a little

00:31:12.790 --> 00:31:15.040
when we were building
this SDK.

00:31:15.040 --> 00:31:17.240
We gave you this concept
called a match variant.

00:31:17.240 --> 00:31:18.770
So what's a variant?

00:31:18.770 --> 00:31:21.480
It's just a number that helps
identify what particular type

00:31:21.480 --> 00:31:22.370
of game you want to play.

00:31:22.370 --> 00:31:24.760
If your game supports multiple
game modes, you're probably

00:31:24.760 --> 00:31:26.330
going to want to use something
like variants.

00:31:26.330 --> 00:31:28.290
The contract with variants is
that when we assemble the

00:31:28.290 --> 00:31:30.960
matches on the server, only
participants who request the

00:31:30.960 --> 00:31:32.840
same variant will be
matched together.

00:31:32.840 --> 00:31:35.290
That way the people who want
to play "Capture the Flag"

00:31:35.290 --> 00:31:37.020
aren't super surprised when
everybody starts running

00:31:37.020 --> 00:31:39.510
around playing "Deathmatch" and
shooting them in the face.

00:31:39.510 --> 00:31:42.150
That's not a good experience
for your users.

00:31:42.150 --> 00:31:43.350
How do you actually use these?

00:31:43.350 --> 00:31:45.810
Well, first thing you do is
you declare a constant.

00:31:45.810 --> 00:31:49.520
A variant can be any integer
between 1 and 1023.

00:31:49.520 --> 00:31:50.860
We figured we wanted
to give you a

00:31:50.860 --> 00:31:52.730
reasonable number of them.

00:31:52.730 --> 00:31:55.010
When the user wants to start a
new automatch game, you just

00:31:55.010 --> 00:31:56.900
create a room config with
the appropriate variant

00:31:56.900 --> 00:31:58.030
and create a room.

00:31:58.030 --> 00:31:58.800
There you go.

00:31:58.800 --> 00:32:00.980
So this is a user that's going
to go into the automatch queue

00:32:00.980 --> 00:32:02.490
for a deathmatch game.

00:32:02.490 --> 00:32:04.790
In general, you use the variants
to split your players

00:32:04.790 --> 00:32:06.950
into separate pools so that you
can match them only within

00:32:06.950 --> 00:32:07.920
their pool.

00:32:07.920 --> 00:32:08.790
This is great.

00:32:08.790 --> 00:32:11.990
You can divide your users into
as many as you want, but don't

00:32:11.990 --> 00:32:13.810
go totally crazy.

00:32:13.810 --> 00:32:16.330
Different variants can't match
together, so the more variants

00:32:16.330 --> 00:32:18.990
you use, the smaller the pool
of players that can match in

00:32:18.990 --> 00:32:20.040
each pool is going to be.

00:32:20.040 --> 00:32:20.980
BRUNO OLIVEIRA: That's
also good advice for

00:32:20.980 --> 00:32:21.850
games and for life.

00:32:21.850 --> 00:32:23.210
TOM WILSON: [LAUGHS]

00:32:23.210 --> 00:32:25.550
So if you have a million users
and you use a million

00:32:25.550 --> 00:32:27.730
different variants, well, then
each user's off waiting in

00:32:27.730 --> 00:32:29.500
their own individual pool and
they're never going to find

00:32:29.500 --> 00:32:32.260
anyone to play with,
and that's not fun.

00:32:32.260 --> 00:32:34.480
Sometimes you're going to need
to make changes to your game

00:32:34.480 --> 00:32:36.680
that aren't compatible with
previous versions.

00:32:36.680 --> 00:32:38.490
This is another way that you
can use variants to help

00:32:38.490 --> 00:32:39.750
protect yourself from that.

00:32:39.750 --> 00:32:41.950
If Version Two of your game
doesn't know how to talk to

00:32:41.950 --> 00:32:44.310
Version One of your game, users
of these two versions

00:32:44.310 --> 00:32:46.440
are going to see something
that looks like this.

00:32:46.440 --> 00:32:49.850
So I'm in the game, I push
Quick Match, then

00:32:49.850 --> 00:32:51.120
I see Please Wait.

00:32:51.120 --> 00:32:53.410
BRUNO OLIVEIRA: Or our Waiting
Room UI, of course.

00:32:53.410 --> 00:32:54.510
TOM WILSON: Even better.

00:32:54.510 --> 00:32:55.040
Oh cool!

00:32:55.040 --> 00:32:55.710
Someone joined.

00:32:55.710 --> 00:32:57.030
Now I'm getting ready
to play the game.

00:32:57.030 --> 00:32:57.910
All right, get ready.

00:32:57.910 --> 00:32:58.870
This is going to
be so awesome.

00:32:58.870 --> 00:33:00.730
Oh my god, this game's
going to be rocking.

00:33:00.730 --> 00:33:01.350
Oh.

00:33:01.350 --> 00:33:02.450
Whoops.

00:33:02.450 --> 00:33:03.250
Right.

00:33:03.250 --> 00:33:04.670
Not really a great experience.

00:33:04.670 --> 00:33:07.280
So the long and short here is
if you can be backwards

00:33:07.280 --> 00:33:09.720
compatible, obviously,
you should be.

00:33:09.720 --> 00:33:11.920
Sometimes you can't, so
you just use variants.

00:33:11.920 --> 00:33:14.760
If Version One and Version Two
use different variants, then

00:33:14.760 --> 00:33:16.880
users won't get automatched
together and get that bad

00:33:16.880 --> 00:33:18.620
incompatible experience.

00:33:18.620 --> 00:33:20.080
We're near the end
of our time here.

00:33:20.080 --> 00:33:21.850
You guys are well on your way
to becoming masters of using

00:33:21.850 --> 00:33:24.650
this API, but we've got one more
thing to talk about, and

00:33:24.650 --> 00:33:26.960
it's every multiplayer
developer's favorite topic.

00:33:26.960 --> 00:33:29.261
Let's talk a little
bit about sockets.

00:33:29.261 --> 00:33:29.860
BRUNO OLIVEIRA: All
right, last one.

00:33:29.860 --> 00:33:31.220
Sockets.

00:33:31.220 --> 00:33:32.440
Yay, sockets.

00:33:32.440 --> 00:33:33.540
Who likes sockets?

00:33:33.540 --> 00:33:36.590
So as you know, I don't think
I have to tell anyone what

00:33:36.590 --> 00:33:37.080
sockets are.

00:33:37.080 --> 00:33:38.790
You just push things on one
side, they come out the other

00:33:38.790 --> 00:33:40.210
side, that's it.

00:33:40.210 --> 00:33:42.970
So if they are reliable sockets,
there's a guarantee

00:33:42.970 --> 00:33:44.320
that that's going to happen,
but that's not

00:33:44.320 --> 00:33:45.150
how our sockets work.

00:33:45.150 --> 00:33:47.730
Our sockets are a form of
unreliable messaging.

00:33:47.730 --> 00:33:48.700
It's like a UDP socket.

00:33:48.700 --> 00:33:51.300
So this means that you push
things on one side and on the

00:33:51.300 --> 00:33:53.330
other side, they might be
missing or they may arrive in

00:33:53.330 --> 00:33:54.300
a different order.

00:33:54.300 --> 00:33:55.860
So this is how our
sockets work.

00:33:55.860 --> 00:33:57.320
So why would you want
to use sockets?

00:33:57.320 --> 00:33:58.380
For three main reasons.

00:33:58.380 --> 00:34:01.790
First of all, you might be
trying to reuse some existing

00:34:01.790 --> 00:34:04.300
code or an engine that
relies on sockets.

00:34:04.300 --> 00:34:06.580
You might decide that your game
logic makes more sense if

00:34:06.580 --> 00:34:08.650
you have stream-like objects
where you can push bytes on

00:34:08.650 --> 00:34:10.409
one side and pull bytes
on the other side.

00:34:10.409 --> 00:34:12.820
Or maybe you're just sending and
receiving a lot of stuff

00:34:12.820 --> 00:34:15.810
from native code and you don't
want to incur that cost of a

00:34:15.810 --> 00:34:18.260
Dalvik call every time you want
to send a packet, so you

00:34:18.260 --> 00:34:22.260
just have a native file
descriptor to use for that.

00:34:22.260 --> 00:34:24.399
So to enable sockets, all you
have to do is call this during

00:34:24.399 --> 00:34:24.870
room setup.

00:34:24.870 --> 00:34:27.270
So remember RoomConfig is how
you configure the room?

00:34:27.270 --> 00:34:30.770
You just enable socket
communications based on your

00:34:30.770 --> 00:34:32.639
RoomConfig, and that's going
to enable sockets.

00:34:32.639 --> 00:34:37.230
Also, if you enable sockets, you
can't use the high level

00:34:37.230 --> 00:34:38.460
UnreliableRealTimeMessage.

00:34:38.460 --> 00:34:40.100
You have to choose either
one or the other.

00:34:40.100 --> 00:34:41.460
Can't have both.

00:34:41.460 --> 00:34:44.139
So to get a real time socket
for a participant, you call

00:34:44.139 --> 00:34:44.840
guess what?

00:34:44.840 --> 00:34:47.909
It's another one of those
intuitive API names, which is

00:34:47.909 --> 00:34:49.960
getRealTimeSocke
tForParticipant.

00:34:49.960 --> 00:34:51.949
That gives you a real time
socket for that particular

00:34:51.949 --> 00:34:52.889
participant.

00:34:52.889 --> 00:34:55.400
And then you can get the input
stream and output stream from

00:34:55.400 --> 00:34:56.000
that as well.

00:34:56.000 --> 00:34:58.120
And from that point on, it's
just a regular input stream

00:34:58.120 --> 00:34:58.620
and output stream.

00:34:58.620 --> 00:35:00.870
You can push bytes on one
side and pull bytes

00:35:00.870 --> 00:35:02.040
on the other side.

00:35:02.040 --> 00:35:04.500
Now, of course, sockets are
a form of unreliable

00:35:04.500 --> 00:35:07.930
communication, so it's very
important to understand how

00:35:07.930 --> 00:35:10.000
packets may be lost
on the stream.

00:35:10.000 --> 00:35:12.915
So if I write "lorem" and then I
write "ipsum" on one side of

00:35:12.915 --> 00:35:15.600
the socket, you might just get
"lorem ipsum" on the other

00:35:15.600 --> 00:35:16.760
side if you're lucky.

00:35:16.760 --> 00:35:19.660
Maybe you're just going to get
"lorem," maybe you're going to

00:35:19.660 --> 00:35:22.370
get "ipsum." Maybe if you're on
a particularly unlucky day,

00:35:22.370 --> 00:35:24.880
you're going to get zip,
nothing at all.

00:35:24.880 --> 00:35:26.860
And then remember you might also
get "ipsum lorem" because

00:35:26.860 --> 00:35:28.230
your ordering is
not guaranteed.

00:35:28.230 --> 00:35:30.830
It usually arrives in order,
but it's not guaranteed.

00:35:30.830 --> 00:35:33.300
However, what we do guarantee
that you will not get is a

00:35:33.300 --> 00:35:35.430
truncated packet, and we do
guarantee that you're not

00:35:35.430 --> 00:35:37.190
going to get a corrupted
packet.

00:35:37.190 --> 00:35:39.150
Because we do guarantee that if
the packet arrives on the

00:35:39.150 --> 00:35:41.980
other side, it's going to be
exactly as it was sent.

00:35:41.980 --> 00:35:43.910
Also remember that there are
no built-in delimiters.

00:35:43.910 --> 00:35:46.470
So you're going to have to
figure out a way to tell when

00:35:46.470 --> 00:35:49.040
your packets begin and end, or
just put a special character

00:35:49.040 --> 00:35:50.700
or length field or
something else.

00:35:50.700 --> 00:35:54.540
Because if you write ABCD and
then EFGH on one side, you're

00:35:54.540 --> 00:35:56.760
going to get this string on
the other side and you're

00:35:56.760 --> 00:35:59.261
going to have to tell where
they begin and end.

00:35:59.261 --> 00:36:03.840
And if you want to access the
socket from native code, it's

00:36:03.840 --> 00:36:05.340
actually very easy to
get a native file

00:36:05.340 --> 00:36:06.820
descriptor from that.

00:36:06.820 --> 00:36:09.170
You just call
getParcelFileDescriptor and

00:36:09.170 --> 00:36:11.890
then you call getFd, and that
gives you a perfectly good

00:36:11.890 --> 00:36:15.000
integer file descriptor to
use from native code.

00:36:15.000 --> 00:36:16.900
So I'm calling my native method,
and of course, like

00:36:16.900 --> 00:36:20.460
any reasonable person, once I
get a file descriptor, I write

00:36:20.460 --> 00:36:22.050
the digits of pi into it.

00:36:22.050 --> 00:36:24.020
So this is just native code.

00:36:24.020 --> 00:36:26.630
That write is just a standard,
plain vanilla, write system

00:36:26.630 --> 00:36:28.760
call that I'm calling with that
file descriptor to write

00:36:28.760 --> 00:36:30.960
bytes into it.

00:36:30.960 --> 00:36:33.400
All right.

00:36:33.400 --> 00:36:35.300
Well, we've talked about a
whole bunch of things.

00:36:35.300 --> 00:36:38.250
So from friendly sign-in, we
talked about Cloud Save.

00:36:38.250 --> 00:36:39.690
We talked about a
whole bunch of

00:36:39.690 --> 00:36:41.210
multiplayer topics, actually.

00:36:41.210 --> 00:36:43.690
We talked about how to integrate
with game engines.

00:36:43.690 --> 00:36:45.980
We even talked about the
exciting world of sockets and

00:36:45.980 --> 00:36:47.110
match variants.

00:36:47.110 --> 00:36:49.590
So we hope that these small bits
of information are going

00:36:49.590 --> 00:36:51.700
to help you refine your game and
make sure that it provides

00:36:51.700 --> 00:36:53.430
the best possible
user experience.

00:36:53.430 --> 00:36:56.700
The reason I hope for that is
because players nowadays are

00:36:56.700 --> 00:36:59.270
very, very demanding, and your
quality control can't

00:36:59.270 --> 00:37:00.720
be just like that.

00:37:00.720 --> 00:37:01.840
Actually, we've seen worse.

00:37:01.840 --> 00:37:02.110
TOM WILSON: We've seen worse.

00:37:02.110 --> 00:37:03.410
BRUNO OLIVEIRA: We've seen some
quality control that's

00:37:03.410 --> 00:37:04.160
kind of like that.

00:37:04.160 --> 00:37:05.570
[LAUGHTER]

00:37:05.570 --> 00:37:07.610
BRUNO OLIVEIRA: Anyway, that
doesn't really work for games.

00:37:07.610 --> 00:37:09.950
Games have to be really, really
awesome because there's

00:37:09.950 --> 00:37:12.200
a lot of competition out there
for the user's attention.

00:37:12.200 --> 00:37:13.265
So unless your game
is awesome, it

00:37:13.265 --> 00:37:14.470
doesn't stand a chance.

00:37:14.470 --> 00:37:18.050
So what we hope to do with the
Google Play Game Services API

00:37:18.050 --> 00:37:20.770
is we want to take the boring
stuff out of the way.

00:37:20.770 --> 00:37:23.140
We want to take care of all that
boring automatching and

00:37:23.140 --> 00:37:25.810
message transport stuff so that
you can focus on what

00:37:25.810 --> 00:37:27.600
makes your game really,
really awesome.

00:37:27.600 --> 00:37:29.910
So thank you very much for
coming to our talk, and

00:37:29.910 --> 00:37:31.360
remember to rate our session.

00:37:31.360 --> 00:37:34.170
If you want to praise us or
throw your virtual tomatoes,

00:37:34.170 --> 00:37:38.240
you can rate the session using
either the QR code or the

00:37:38.240 --> 00:37:39.310
Google I/O App.

00:37:39.310 --> 00:37:40.350
So thank you very much.

00:37:40.350 --> 00:37:41.900
[APPLAUSE]

