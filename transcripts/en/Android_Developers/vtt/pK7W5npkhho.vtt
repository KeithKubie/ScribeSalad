WEBVTT
Kind: captions
Language: en

00:00:00.976 --> 00:00:04.392
[MUSIC PLAYING]

00:00:05.860 --> 00:00:07.280
JONATHAN GERRISH:
Hello, everyone.

00:00:07.280 --> 00:00:09.880
Welcome to this morning session
on test-driven development

00:00:09.880 --> 00:00:11.690
for the Android platform.

00:00:11.690 --> 00:00:15.610
My name is Jonathan Gerrish and
I'm part of the Mobile Ninjas.

00:00:15.610 --> 00:00:17.110
We're a small team
within Google who

00:00:17.110 --> 00:00:20.130
are passionate about
software testing.

00:00:20.130 --> 00:00:22.130
Can I get a quick show
of hands in the audience?

00:00:22.130 --> 00:00:23.879
How many of you are
actually writing tests

00:00:23.879 --> 00:00:26.470
as part of your normal
software development practice?

00:00:26.470 --> 00:00:28.390
That's fantastic.

00:00:28.390 --> 00:00:30.824
OK.

00:00:30.824 --> 00:00:32.740
So if you've written
tests for Android before,

00:00:32.740 --> 00:00:35.320
you've probably used
some of our tools.

00:00:35.320 --> 00:00:38.690
We developed the Android
testing support library,

00:00:38.690 --> 00:00:40.520
which includes the
JUnit for test runner

00:00:40.520 --> 00:00:44.250
and rules, the Espresso
UI testing framework,

00:00:44.250 --> 00:00:45.910
and we're also
active contributors

00:00:45.910 --> 00:00:51.440
to Roboelectric, the open source
Android unit testing framework.

00:00:51.440 --> 00:00:53.190
So everyone is telling
you to write tests,

00:00:53.190 --> 00:00:55.320
but why should you really do it?

00:00:55.320 --> 00:00:57.847
It's true that tests
take time to write.

00:00:57.847 --> 00:00:59.430
They're adding code
to your code base.

00:00:59.430 --> 00:01:01.138
And perhaps you've
been in this situation

00:01:01.138 --> 00:01:04.410
before, where your manager or
client has been telling you

00:01:04.410 --> 00:01:06.330
that they're slowing you down.

00:01:06.330 --> 00:01:09.590
But there's so many compelling
reasons to write tests.

00:01:09.590 --> 00:01:12.390
Tests give you rapid
feedback on failures.

00:01:12.390 --> 00:01:16.080
So failures that are spotted
earlier on in the development

00:01:16.080 --> 00:01:20.280
cycle are far easier to fix
than ones that have gone live.

00:01:20.280 --> 00:01:23.904
Secondly, tests give
you a safety net.

00:01:23.904 --> 00:01:25.320
With a good suite
of tests, you're

00:01:25.320 --> 00:01:27.780
free to refactor,
clean up, and optimize

00:01:27.780 --> 00:01:30.030
your code, safe in the
knowledge that you're not going

00:01:30.030 --> 00:01:32.790
to break existing behavior.

00:01:32.790 --> 00:01:35.490
Tests are really the backbone
of sustainable software

00:01:35.490 --> 00:01:36.660
development.

00:01:36.660 --> 00:01:38.580
You'll be able to
maintain a stable velocity

00:01:38.580 --> 00:01:40.890
throughout the lifetime
of your project,

00:01:40.890 --> 00:01:44.850
and you're going to avoid the
boom-bust cycles of crunch

00:01:44.850 --> 00:01:48.050
feature time and the
aggregation of technical debt.

00:01:51.100 --> 00:01:54.190
So in software testing,
there exists the concept

00:01:54.190 --> 00:01:56.300
of the testing pyramid.

00:01:56.300 --> 00:01:58.270
And this is made up
of a number of layers.

00:01:58.270 --> 00:02:00.962
And each layer brings with it
its own trade-offs that you're

00:02:00.962 --> 00:02:01.920
going to have to weigh.

00:02:04.630 --> 00:02:08.169
At the lowest layer is the
small tests, or the unit tests.

00:02:08.169 --> 00:02:11.470
And these need to be very
fast and highly focused.

00:02:11.470 --> 00:02:14.290
That's why we recommend you
run these kind of tests, what

00:02:14.290 --> 00:02:16.480
is known as local unit tests.

00:02:16.480 --> 00:02:20.140
And these are going to run on
your local desktop machine.

00:02:20.140 --> 00:02:22.390
The trade-off you're making
with these kind of tests

00:02:22.390 --> 00:02:24.730
is infidelity because
you're not running

00:02:24.730 --> 00:02:27.640
on a realistic environment and
you're probably substituting

00:02:27.640 --> 00:02:29.500
in a bunch of mocks and fakes.

00:02:32.840 --> 00:02:34.340
As we move up the
pyramid, we're now

00:02:34.340 --> 00:02:37.440
into the realms of integration
testing and end-to-end testing.

00:02:37.440 --> 00:02:41.030
And the key with these kind of
tests is to bring in fidelity.

00:02:41.030 --> 00:02:42.560
That's why we
recommend that you run

00:02:42.560 --> 00:02:46.631
these kinds of tests on a
real device or an emulator.

00:02:46.631 --> 00:02:48.005
These are the
kinds of tests that

00:02:48.005 --> 00:02:51.850
are going to tell you that
your software actually works.

00:02:51.850 --> 00:02:54.560
However, they are less
focused, so a failure

00:02:54.560 --> 00:02:57.590
in one of these kind of tests
might take a little longer

00:02:57.590 --> 00:03:00.110
to track down than it
would in a unit test.

00:03:00.110 --> 00:03:02.270
And one of the big
trade-offs you're making

00:03:02.270 --> 00:03:04.700
is in test execution speed.

00:03:04.700 --> 00:03:06.870
Because you're assembling
multiple components,

00:03:06.870 --> 00:03:09.270
they all have to be
built and then packaged,

00:03:09.270 --> 00:03:11.180
shipped to a device
where the tests are run,

00:03:11.180 --> 00:03:13.040
and the results
are collected back.

00:03:13.040 --> 00:03:16.250
That's going to take extra time.

00:03:16.250 --> 00:03:18.370
There's no single layer
in this testing pyramid

00:03:18.370 --> 00:03:21.590
that can suffice, so
what you need to do

00:03:21.590 --> 00:03:24.590
is to blend in tests
at each different tier,

00:03:24.590 --> 00:03:27.290
leveraging the strengths
of one category

00:03:27.290 --> 00:03:30.290
to weigh off the
trade-offs in another.

00:03:30.290 --> 00:03:33.200
There's no real hard
and fast rule here,

00:03:33.200 --> 00:03:35.540
but Google's own
internal testing experts

00:03:35.540 --> 00:03:38.590
recommend the
70-20-10 rule of thumb

00:03:38.590 --> 00:03:42.990
as the ratio between small,
medium, and large tests.

00:03:42.990 --> 00:03:46.470
Let's take a look
at our workflow.

00:03:46.470 --> 00:03:49.110
So with test-driven
development, the idea

00:03:49.110 --> 00:03:51.220
is that you start by
writing your tests,

00:03:51.220 --> 00:03:53.590
then you implement the code
to make those tests pass.

00:03:53.590 --> 00:03:55.890
And then when your tests
are green, you can submit.

00:03:55.890 --> 00:03:57.900
Again, a quick show of hands.

00:03:57.900 --> 00:04:01.130
Who out there has
test-driven their code,

00:04:01.130 --> 00:04:04.480
tried test-driven
development in the past?

00:04:04.480 --> 00:04:04.980
OK.

00:04:04.980 --> 00:04:06.390
Cool.

00:04:06.390 --> 00:04:08.610
We like test-driven
development because it

00:04:08.610 --> 00:04:12.390
makes you think about the design
of your application up front.

00:04:12.390 --> 00:04:14.730
It gives due
consideration to APIs

00:04:14.730 --> 00:04:16.980
and the structure of your code.

00:04:16.980 --> 00:04:18.510
With test-driven
development, you're

00:04:18.510 --> 00:04:21.450
also going to be writing
less code because you only

00:04:21.450 --> 00:04:25.230
write the code necessary
to satisfy your tests.

00:04:25.230 --> 00:04:27.684
This will enable you to
release early and often.

00:04:27.684 --> 00:04:29.100
As you're constantly
green, you'll

00:04:29.100 --> 00:04:31.530
be able to deploy a working
application at a moment's

00:04:31.530 --> 00:04:33.790
notice.

00:04:33.790 --> 00:04:35.960
If you're following
the test pyramid,

00:04:35.960 --> 00:04:40.020
the workflow is going to
look something like this.

00:04:40.020 --> 00:04:42.890
First of all, we have a
larger outer iteration

00:04:42.890 --> 00:04:46.100
that's concerned with
feature development.

00:04:46.100 --> 00:04:50.600
Here, it's driven by a
UI test, and the mantra

00:04:50.600 --> 00:04:54.230
with test-driven development
is Red, Green, Refactor.

00:04:54.230 --> 00:04:55.910
We start off with
a failing test,

00:04:55.910 --> 00:04:57.950
we implement the code
to make that test pass,

00:04:57.950 --> 00:04:58.825
and then we refactor.

00:05:01.930 --> 00:05:04.270
Inside the larger
iteration are a series

00:05:04.270 --> 00:05:05.830
of smaller iterations
and these are

00:05:05.830 --> 00:05:07.870
concerned with the unit tests.

00:05:07.870 --> 00:05:10.690
Here, you're building
the units required

00:05:10.690 --> 00:05:12.310
to make the feature pass.

00:05:12.310 --> 00:05:15.040
And again, you use
the same mantra here.

00:05:15.040 --> 00:05:16.480
Red, Green, Refactor.

00:05:16.480 --> 00:05:18.310
Red, Green, Refactor.

00:05:18.310 --> 00:05:23.151
Let's take a look at
an example application.

00:05:23.151 --> 00:05:24.900
The feature we're going
to implement today

00:05:24.900 --> 00:05:28.570
is the Add Notes flow to a
sample note-taking application.

00:05:28.570 --> 00:05:30.090
If we take a look
at our mock-ups,

00:05:30.090 --> 00:05:33.020
we can see that we start
on a notes list screen

00:05:33.020 --> 00:05:34.770
full of some existing notes.

00:05:34.770 --> 00:05:37.470
There's a floating action
button down at the bottom.

00:05:37.470 --> 00:05:39.270
And the user will
click this, taking them

00:05:39.270 --> 00:05:41.700
onto the new add notes screen.

00:05:41.700 --> 00:05:44.460
Here, they can enter a title
and a description for their note

00:05:44.460 --> 00:05:45.970
before clicking Save.

00:05:45.970 --> 00:05:47.460
The note will be
persisted and then

00:05:47.460 --> 00:05:49.611
they'll return back to
their notes list screen,

00:05:49.611 --> 00:05:51.360
where they can see
their newly added note,

00:05:51.360 --> 00:05:53.484
along with any other notes
that previously existed.

00:05:56.040 --> 00:05:58.420
Coming back to our
workflow for a moment,

00:05:58.420 --> 00:06:01.360
remember that we start
with a failing UI test.

00:06:01.360 --> 00:06:05.340
So let's take a look at how this
test would look using Espresso,

00:06:05.340 --> 00:06:09.290
the UI testing framework.

00:06:09.290 --> 00:06:14.120
The first step is to click
on the Add Note button.

00:06:14.120 --> 00:06:18.050
Then we enter the title and
description and click Save

00:06:18.050 --> 00:06:20.344
before returning to
the notes list screen.

00:06:20.344 --> 00:06:22.760
And here, we're going to verify
that the note that we just

00:06:22.760 --> 00:06:26.430
added actually shows up.

00:06:26.430 --> 00:06:28.370
Now remember, with
test-driven development,

00:06:28.370 --> 00:06:31.220
we'll not implemented
code just yet.

00:06:31.220 --> 00:06:32.900
All we have to do
is implement enough

00:06:32.900 --> 00:06:36.140
of the application to satisfy
the specification of our tests.

00:06:36.140 --> 00:06:39.770
So an empty activity, and just
the resources that we need,

00:06:39.770 --> 00:06:41.540
will suffice.

00:06:41.540 --> 00:06:43.640
Once we have that,
we can run our test

00:06:43.640 --> 00:06:45.157
and we'll see it'll fail.

00:06:45.157 --> 00:06:46.740
Now we have to
implement this feature.

00:06:49.910 --> 00:06:53.470
So applications are built
up of many small units.

00:06:53.470 --> 00:06:57.430
These are small, highly
focused, specialized components

00:06:57.430 --> 00:07:00.132
that do one thing
and they do it well.

00:07:00.132 --> 00:07:01.840
Collections of these
small units are then

00:07:01.840 --> 00:07:04.390
assembled together so that
their collaborations will

00:07:04.390 --> 00:07:05.550
satisfy our feature.

00:07:09.750 --> 00:07:12.370
Let's take a moment to summarize
the key characteristics that

00:07:12.370 --> 00:07:13.530
make up a good unit test.

00:07:16.320 --> 00:07:18.710
As well as the
normal conditions,

00:07:18.710 --> 00:07:22.620
you're wanting to test your
failure conditions, invalid

00:07:22.620 --> 00:07:24.710
inputs, and boundary conditions.

00:07:24.710 --> 00:07:26.835
You're going to end up
writing a lot of unit tests.

00:07:30.160 --> 00:07:33.100
Unit tests must always give
you the same result every time.

00:07:33.100 --> 00:07:35.860
So avoid depending on
things that might change--

00:07:35.860 --> 00:07:39.760
For example, an external server
or the current time of day--

00:07:39.760 --> 00:07:42.410
because this is going to bring
flakiness into your unit tests.

00:07:45.480 --> 00:07:49.500
Unit tests should exercise one
specific aspect of your code

00:07:49.500 --> 00:07:50.946
at a time.

00:07:50.946 --> 00:07:53.070
You're wanting to see that
a failure in a unit test

00:07:53.070 --> 00:07:57.970
will lead you, very quickly,
to a natural bug in your code.

00:07:57.970 --> 00:07:59.777
And when you write
unit tests, avoid

00:07:59.777 --> 00:08:02.110
making too many assumptions
on the actual implementation

00:08:02.110 --> 00:08:03.600
of your code.

00:08:03.600 --> 00:08:05.530
You want your unit
test to test behavior.

00:08:05.530 --> 00:08:07.409
That way, you avoid
rewriting your test

00:08:07.409 --> 00:08:08.950
when your implementation
is changing.

00:08:12.406 --> 00:08:14.530
And one of the most important
aspects of unit tests

00:08:14.530 --> 00:08:16.840
is they've got to be fast,
especially because you're

00:08:16.840 --> 00:08:20.470
writing so many of them and,
during TDD workflow, running

00:08:20.470 --> 00:08:22.975
them rapidly.

00:08:22.975 --> 00:08:26.080
It would be terrible
if you were discouraged

00:08:26.080 --> 00:08:29.420
from writing tests or
refactoring your code because

00:08:29.420 --> 00:08:35.210
of the pain in the execution
time of those tests.

00:08:35.210 --> 00:08:37.429
And finally, unit tests
are an excellent source

00:08:37.429 --> 00:08:39.740
of documentation and
the way it's constantly

00:08:39.740 --> 00:08:41.690
evolving with the
code as it changes,

00:08:41.690 --> 00:08:44.990
unlike static documents that
will stagnate over time.

00:08:49.240 --> 00:08:52.430
Let's try a unit test for
our Add Notes activity.

00:08:52.430 --> 00:08:54.264
This activity is going
to take in user input

00:08:54.264 --> 00:08:55.680
and then we're
going to persist it

00:08:55.680 --> 00:08:57.020
to local storage on the device.

00:08:59.640 --> 00:09:00.140
OK.

00:09:00.140 --> 00:09:02.630
So we're going to create
the Add Note activity class,

00:09:02.630 --> 00:09:05.450
and this will extend Activity,
which is an Android framework

00:09:05.450 --> 00:09:06.710
class.

00:09:06.710 --> 00:09:10.160
It has a view which is going
to be inflated with a layout.

00:09:10.160 --> 00:09:11.660
The user will enter
their data here.

00:09:11.660 --> 00:09:14.330
And then we're going to
persist that note into Android

00:09:14.330 --> 00:09:16.397
SharedPreferences mechanism.

00:09:20.037 --> 00:09:22.120
It's conceivable that, as
our application evolves,

00:09:22.120 --> 00:09:23.410
so did our requirement.

00:09:23.410 --> 00:09:25.600
And perhaps our
storage requirements

00:09:25.600 --> 00:09:29.170
evolve to persist the
notes onto cloud storage

00:09:29.170 --> 00:09:32.980
and we have to build some kind
of a synchronization mechanism

00:09:32.980 --> 00:09:36.610
for local storage for
the offline use case.

00:09:36.610 --> 00:09:39.730
And in these cases, we see
opportunities for abstraction.

00:09:39.730 --> 00:09:42.220
We might, in this
example, see that we

00:09:42.220 --> 00:09:44.680
can extract a notes repository.

00:09:44.680 --> 00:09:48.220
However, one of the key aspects
of test-driven development

00:09:48.220 --> 00:09:51.370
is that we only start by
writing the simplest case first,

00:09:51.370 --> 00:09:52.690
and then we iterate.

00:09:52.690 --> 00:09:57.250
So we're going to resist the
temptation to do this early.

00:09:57.250 --> 00:10:01.750
Let's take a look at a sample
of what an idealized unit

00:10:01.750 --> 00:10:03.310
test would look like.

00:10:03.310 --> 00:10:07.570
They're generally built
up into three stages.

00:10:07.570 --> 00:10:09.190
The first stage
is you're setting

00:10:09.190 --> 00:10:11.080
the conditions for
the test, and this

00:10:11.080 --> 00:10:13.420
includes preparing
the environment,

00:10:13.420 --> 00:10:17.200
setting up your dependencies
with their required state,

00:10:17.200 --> 00:10:20.050
and preparing any input data.

00:10:20.050 --> 00:10:23.620
Next, we'll exercise the code
under test, before finally,

00:10:23.620 --> 00:10:27.700
making assertions on the
results or the state.

00:10:27.700 --> 00:10:30.430
I like to clearly separate
each of these three

00:10:30.430 --> 00:10:35.170
stages of the test and bring the
pertinent aspects of each test

00:10:35.170 --> 00:10:37.610
front and center to make
for a really readable test.

00:10:41.560 --> 00:10:43.870
Up until now with
the Android platform,

00:10:43.870 --> 00:10:46.210
you're writing your
unit tests using

00:10:46.210 --> 00:10:48.190
the mockable jarring
conjunction with a mocking

00:10:48.190 --> 00:10:50.640
library, such as Marketo.

00:10:50.640 --> 00:10:52.660
And let's take a
look at an example

00:10:52.660 --> 00:10:56.610
of a test written with Marketo.

00:10:56.610 --> 00:10:57.940
OK.

00:10:57.940 --> 00:10:58.840
Wow.

00:10:58.840 --> 00:11:00.950
That's a lot of code.

00:11:00.950 --> 00:11:01.450
OK.

00:11:01.450 --> 00:11:04.570
So because we have so many
interactions with the Android

00:11:04.570 --> 00:11:07.270
framework, we're going
to need to provide

00:11:07.270 --> 00:11:11.110
stubbing behavior for all of
them in order just to make--

00:11:11.110 --> 00:11:14.560
just to satisfy the
execution paths of our test.

00:11:14.560 --> 00:11:18.520
And furthermore, because Android
uses a lot of static methods,

00:11:18.520 --> 00:11:20.680
we're forced to introduce
a second mocking

00:11:20.680 --> 00:11:22.510
library, PowerMock,
that will handle

00:11:22.510 --> 00:11:25.210
this special case for us.

00:11:25.210 --> 00:11:28.050
And there are also some pretty
bad code [INAUDIBLE] here.

00:11:28.050 --> 00:11:30.730
Let's take a look.

00:11:30.730 --> 00:11:34.930
You see, we're forced to spy
on the activity on the test

00:11:34.930 --> 00:11:37.660
and we're needing to do
this to modify its behavior.

00:11:37.660 --> 00:11:40.330
And stubbing it out and
providing some no ops.

00:11:40.330 --> 00:11:42.970
So we're moving out of the
realms of black box testing

00:11:42.970 --> 00:11:45.130
here.

00:11:45.130 --> 00:11:47.410
And finally, at the
end, we're making

00:11:47.410 --> 00:11:50.779
assertions about the
implementation details.

00:11:50.779 --> 00:11:53.070
And if these change, our test
will need to change, too.

00:11:55.610 --> 00:11:58.550
So remembering the
characteristics of a good unit

00:11:58.550 --> 00:12:02.450
test, let's take a moment to
score this particular test.

00:12:02.450 --> 00:12:04.490
While it is very
focused, we're just

00:12:04.490 --> 00:12:07.670
testing the happy path
of our Add Notes flow,

00:12:07.670 --> 00:12:12.560
and it's certainly fast because
it's running on the local JVM.

00:12:12.560 --> 00:12:14.510
However, we were
making rather a lot

00:12:14.510 --> 00:12:18.350
of assumptions about the
implementation in that test.

00:12:18.350 --> 00:12:22.130
And with this, if any of
our implementation changes,

00:12:22.130 --> 00:12:23.840
it's likely we'll
need to rewrite

00:12:23.840 --> 00:12:26.600
that test substantially.

00:12:26.600 --> 00:12:29.990
And finally, all that
excess boilerplate stubbing

00:12:29.990 --> 00:12:31.430
is really distracting.

00:12:31.430 --> 00:12:33.975
It's distracting away
from the key aspects

00:12:33.975 --> 00:12:35.600
of the test, the
conditions of the test

00:12:35.600 --> 00:12:37.025
that you're trying to document.

00:12:40.860 --> 00:12:42.570
Well luckily, there's
a tool that helps

00:12:42.570 --> 00:12:44.640
address some of these issues.

00:12:44.640 --> 00:12:47.850
So introducing Roboelectric.

00:12:47.850 --> 00:12:50.340
Roboelectric is an
Android unit testing

00:12:50.340 --> 00:12:55.050
tool that's open sourced that
we are actively contributing to.

00:12:55.050 --> 00:12:56.760
And to tell you
more about how you

00:12:56.760 --> 00:12:58.680
can write great tests
with Roboelectric,

00:12:58.680 --> 00:13:00.810
I'm going to hand you over
to Christian Williams,

00:13:00.810 --> 00:13:03.145
the original author
of Roboelectric.

00:13:03.145 --> 00:13:05.570
[APPLAUSE]

00:13:08.480 --> 00:13:10.060
CHRISTIAN WILLIAMS:
Thanks, Jonathan.

00:13:10.060 --> 00:13:12.160
It's awesome to see
so many people who are

00:13:12.160 --> 00:13:15.980
into Android testing and TDD.

00:13:15.980 --> 00:13:18.850
Yeah, Roboelectric is this
scrappy little open source

00:13:18.850 --> 00:13:21.340
project that I started
hacking on back

00:13:21.340 --> 00:13:22.990
in the early days
of Android Testing

00:13:22.990 --> 00:13:27.190
because I was just super annoyed
at how long it took to deploy

00:13:27.190 --> 00:13:30.490
and run tests on an emulator.

00:13:30.490 --> 00:13:32.050
And it's kind of
been a side project

00:13:32.050 --> 00:13:34.360
of a bunch of different
people until last year, when

00:13:34.360 --> 00:13:37.640
I had the privilege of joining
my friend Jonathan at Google,

00:13:37.640 --> 00:13:40.090
where he was already working,
on improving Roboelectric

00:13:40.090 --> 00:13:42.910
for Google's own
internal test suites.

00:13:42.910 --> 00:13:46.149
And since then, we've been
really beefing up Roboelectric

00:13:46.149 --> 00:13:48.190
and contributing back to
the open source project.

00:13:50.890 --> 00:13:53.170
Today, Roboelectric isn't
an officially supported part

00:13:53.170 --> 00:13:57.099
of the Android testing
platform, but we

00:13:57.099 --> 00:13:58.640
found that, when
it's used correctly,

00:13:58.640 --> 00:14:01.010
it can be a really useful
part of your testing strategy.

00:14:01.010 --> 00:14:03.009
And I'm going to show you
a little bit about how

00:14:03.009 --> 00:14:04.180
you can do that, too.

00:14:04.180 --> 00:14:05.943
Let's go back to
our notes unit test

00:14:05.943 --> 00:14:08.068
and see how we might approach
it with Roboelectric.

00:14:11.020 --> 00:14:13.659
Since Roboelectric runs
as a local unit test,

00:14:13.659 --> 00:14:15.450
it'll still be running
on your workstation,

00:14:15.450 --> 00:14:17.200
not on an emulator.

00:14:17.200 --> 00:14:20.050
But Roboelectric provides
a little Android sandbox

00:14:20.050 --> 00:14:25.010
next to your test, where the
actual SDK code is running.

00:14:25.010 --> 00:14:27.370
You'll have access to your
activities, your layouts,

00:14:27.370 --> 00:14:28.900
and views, and resources.

00:14:28.900 --> 00:14:31.570
And you can generally just
call most Android methods

00:14:31.570 --> 00:14:34.224
and they'll kind of
work like you'd expect.

00:14:34.224 --> 00:14:35.890
There are parts of
the Android framework

00:14:35.890 --> 00:14:41.530
that rely on native code or
collective hardware or interact

00:14:41.530 --> 00:14:43.270
with external system services.

00:14:43.270 --> 00:14:45.850
So for that, Roboelectric
provides a sort of test stubble

00:14:45.850 --> 00:14:48.310
that we call Shadows.

00:14:48.310 --> 00:14:50.770
And those provide
alternative limitations

00:14:50.770 --> 00:14:55.100
of that code that's
appropriate for unit testing.

00:14:55.100 --> 00:14:59.190
Remember that test that we just
saw that had 20 lines of code,

00:14:59.190 --> 00:15:01.460
of mock set-up code?

00:15:01.460 --> 00:15:04.630
Let's see how that
looks in Roboelectric.

00:15:04.630 --> 00:15:05.500
That's a lot less.

00:15:05.500 --> 00:15:08.070
We've gotten rid of
all the boilerplate.

00:15:08.070 --> 00:15:11.274
The test is about half the
size and much more concise.

00:15:11.274 --> 00:15:13.690
We're not forced to think about
the implementation details

00:15:13.690 --> 00:15:17.012
as we're writing the
test, which is quite nice.

00:15:17.012 --> 00:15:18.970
Roboelectric is going to
set up the application

00:15:18.970 --> 00:15:20.530
according to your manifest.

00:15:20.530 --> 00:15:23.140
And if we were asking it
to set up our activity,

00:15:23.140 --> 00:15:25.540
it runs it through the
appropriate life cycle

00:15:25.540 --> 00:15:27.250
to get it into the right state.

00:15:27.250 --> 00:15:32.570
Inflates views, all that stuff
that we expect on a device.

00:15:32.570 --> 00:15:36.410
So we can just interact with
it as if you're on a device.

00:15:36.410 --> 00:15:40.030
So we add some text to
some fields, click on it,

00:15:40.030 --> 00:15:43.042
and assert that it adds
a note to the repository.

00:15:43.042 --> 00:15:44.500
Now, notice that
we're not actually

00:15:44.500 --> 00:15:49.480
going as far as the UI test that
we wrote at the very beginning.

00:15:49.480 --> 00:15:51.070
We're not asserting
that the new note

00:15:51.070 --> 00:15:53.680
appears on the view screen.

00:15:53.680 --> 00:15:55.540
That would be the job
of another unit test.

00:15:58.930 --> 00:16:01.540
Now, I mentioned
Roboelectric's shadows.

00:16:01.540 --> 00:16:04.320
They actually give
extended testing

00:16:04.320 --> 00:16:06.280
APIs to some
Android classes that

00:16:06.280 --> 00:16:10.090
let us query internal
state and sometimes change

00:16:10.090 --> 00:16:11.170
their behavior.

00:16:11.170 --> 00:16:14.200
In this example, we were
asking the application

00:16:14.200 --> 00:16:17.800
if any of our activities
requested that an intent be

00:16:17.800 --> 00:16:19.330
launched during the test.

00:16:19.330 --> 00:16:21.520
We could use that to
assert that, after saving

00:16:21.520 --> 00:16:24.220
the note to the
repository, we're

00:16:24.220 --> 00:16:28.030
going to go to the
View Notes activity.

00:16:28.030 --> 00:16:33.640
Similar testing APIs exist for
simulating hardware responses

00:16:33.640 --> 00:16:35.900
or external services,
things like that.

00:16:38.590 --> 00:16:41.290
At this point, we have
a failing unit test.

00:16:41.290 --> 00:16:42.380
And now we get to--

00:16:42.380 --> 00:16:44.860
we're ready for the easy part,
writing the production code.

00:16:48.040 --> 00:16:50.440
In the spirit of
TDD, we're only going

00:16:50.440 --> 00:16:54.820
to write exactly as much as is
needed to make the test pass.

00:16:54.820 --> 00:16:56.890
No more, no speculative coding.

00:16:56.890 --> 00:17:00.880
So we inflate a layout,
attach a click handler,

00:17:00.880 --> 00:17:03.080
and when the click
happens, we fade a note

00:17:03.080 --> 00:17:04.533
and add it to the repository.

00:17:08.420 --> 00:17:10.974
Now we can run the
test, see it pass.

00:17:10.974 --> 00:17:13.140
If there's some improvement
we can make to the code,

00:17:13.140 --> 00:17:15.416
we'll go back and refactor,
and then we repeat.

00:17:15.416 --> 00:17:17.040
This is where you
get the thoroughness.

00:17:17.040 --> 00:17:18.810
And Roboelectric is
super handy for this

00:17:18.810 --> 00:17:21.119
because it gives you
nice, fast test runs.

00:17:21.119 --> 00:17:22.880
You can get into a comfy cycle.

00:17:27.640 --> 00:17:30.370
We want to not just test
the happy path here.

00:17:30.370 --> 00:17:33.100
We're going to test all the
different cases that our code

00:17:33.100 --> 00:17:34.690
is likely to encounter.

00:17:34.690 --> 00:17:38.451
So for example, input validation
and external conditions

00:17:38.451 --> 00:17:40.450
like the network being
down and stuff like that.

00:17:43.720 --> 00:17:48.200
Roboelectric can also help with
simulating device conditions

00:17:48.200 --> 00:17:49.380
that you'll encounter.

00:17:49.380 --> 00:17:52.760
For example, you can
specify qualifiers

00:17:52.760 --> 00:17:54.860
that the test should run with.

00:17:54.860 --> 00:17:57.680
Here, we're saying a certain
screen size and orientation,

00:17:57.680 --> 00:18:00.230
which might change
the layout a bit.

00:18:00.230 --> 00:18:04.490
You can ask Roboelectric to run
your test under a specific SDK.

00:18:04.490 --> 00:18:07.600
So we'll say Jelly Bean here.

00:18:07.600 --> 00:18:11.480
And it actually uses of the
SDK code from that version.

00:18:11.480 --> 00:18:14.270
And you can also
tell Roboelectric,

00:18:14.270 --> 00:18:16.130
I want to run this
test under every SDK

00:18:16.130 --> 00:18:18.980
that you support, or
some range of them

00:18:18.980 --> 00:18:20.360
that you're interested in.

00:18:20.360 --> 00:18:23.540
And we support Jelly
Bean through O right now.

00:18:26.890 --> 00:18:29.460
At Google, we rely really
heavily on Roboelectric

00:18:29.460 --> 00:18:31.410
and we're investing
in making it better.

00:18:31.410 --> 00:18:32.868
We've got dozens
of apps, including

00:18:32.868 --> 00:18:34.650
these, that have
hundreds of thousands

00:18:34.650 --> 00:18:36.510
of unit tests
running internally.

00:18:36.510 --> 00:18:39.060
So it's well battle-tested.

00:18:39.060 --> 00:18:42.290
And we've also recently started
running the Android CTS, which

00:18:42.290 --> 00:18:46.290
is the official Android test
suite against Roboelectric.

00:18:46.290 --> 00:18:48.540
And we're about 70% passing
right now, getting better

00:18:48.540 --> 00:18:50.950
with every release.

00:18:50.950 --> 00:18:52.770
So if you used
Roboelectric in the past

00:18:52.770 --> 00:18:54.720
and found that
it's come up short,

00:18:54.720 --> 00:18:56.430
or if you're stuck
in an old version,

00:18:56.430 --> 00:18:59.850
I definitely recommend that
you get up to the latest

00:18:59.850 --> 00:19:01.150
because it's come a long way.

00:19:04.530 --> 00:19:07.237
We've been working
on reducing friction

00:19:07.237 --> 00:19:09.570
in integrating Roboelectric
with the Android tool chain.

00:19:09.570 --> 00:19:13.770
It works now very well with
Android Studio, with Gradle.

00:19:13.770 --> 00:19:18.310
And we've got support for
Bazel, Google's own open source

00:19:18.310 --> 00:19:19.410
build system coming soon.

00:19:22.410 --> 00:19:26.100
Roboelectric isn't a
one-size-fits-all testing tool.

00:19:26.100 --> 00:19:28.770
It's fast, but it's not
100% identical to Android

00:19:28.770 --> 00:19:33.150
in every way, so you want
to use it judiciously.

00:19:33.150 --> 00:19:36.180
As I said before, avoid
writing unit tests that link

00:19:36.180 --> 00:19:37.650
multiple activities together.

00:19:37.650 --> 00:19:39.210
That's not so much a unit test.

00:19:39.210 --> 00:19:41.255
That's much better for Espresso.

00:19:41.255 --> 00:19:43.380
If you find yourself dealing
with multiple threads,

00:19:43.380 --> 00:19:45.120
synchronization
issues, stuff like

00:19:45.120 --> 00:19:48.780
that, you're also probably not
writing a unit tests, so not

00:19:48.780 --> 00:19:50.880
good for electric.

00:19:50.880 --> 00:19:53.310
And particularly, avoid
using Roboelectric

00:19:53.310 --> 00:19:59.190
to test your integration
with Android APIs and things

00:19:59.190 --> 00:20:01.130
like Google Play services.

00:20:01.130 --> 00:20:03.680
You really need to have
higher-level tests to give you

00:20:03.680 --> 00:20:06.810
confidence that that's working.

00:20:06.810 --> 00:20:08.940
So now that we've got
some passing unit tests,

00:20:08.940 --> 00:20:11.250
I'm going to hand you over
to my colleague, Stefan

00:20:11.250 --> 00:20:14.870
to talk about higher
level testing.

00:20:14.870 --> 00:20:18.265
[APPLAUSE]

00:20:20.700 --> 00:20:23.520
STEFAN: Thank you, Christian.

00:20:23.520 --> 00:20:27.210
Let's go back to our
developer workflow diagram.

00:20:27.210 --> 00:20:30.060
At this point, we hopefully
have a ton of unit tests

00:20:30.060 --> 00:20:33.220
and they thoroughly test
all our business logic.

00:20:33.220 --> 00:20:36.030
But let's switch gears and
try to see how we can actually

00:20:36.030 --> 00:20:40.020
write some integration tests to
see how these units integrate,

00:20:40.020 --> 00:20:41.910
and how they actually
integrate with Android

00:20:41.910 --> 00:20:45.810
and how they run in
a real environment.

00:20:45.810 --> 00:20:48.540
On Android, these tests
are usually referred to

00:20:48.540 --> 00:20:50.325
as instrumentation tests.

00:20:50.325 --> 00:20:52.950
And I'm pretty sure most of you
have written an instrumentation

00:20:52.950 --> 00:20:54.390
test before.

00:20:54.390 --> 00:20:57.960
And even though they look
super simple on the surface,

00:20:57.960 --> 00:21:00.600
there's actually a lot
going on under the hood,

00:21:00.600 --> 00:21:02.160
if you think about it.

00:21:02.160 --> 00:21:03.600
You have to compile
the code, you

00:21:03.600 --> 00:21:05.280
have to process
your resources, you

00:21:05.280 --> 00:21:09.900
have to bring up a full system
image and then run your test.

00:21:09.900 --> 00:21:13.050
And there's a lot of things
that go on on various levels

00:21:13.050 --> 00:21:15.210
of the Android stack.

00:21:15.210 --> 00:21:19.039
So these tests give
you high fidelity,

00:21:19.039 --> 00:21:20.580
but as John was
mentioning, they come

00:21:20.580 --> 00:21:24.150
at a cost, which
is they are slower

00:21:24.150 --> 00:21:29.320
and sometimes, they're
more flaky than unit tests.

00:21:29.320 --> 00:21:31.110
So let's actually
see how this works

00:21:31.110 --> 00:21:33.450
in your day-to-day
development flow.

00:21:33.450 --> 00:21:36.000
Let's say you're
an Android Studio.

00:21:36.000 --> 00:21:39.210
You've just written
your new Espresso test

00:21:39.210 --> 00:21:42.252
and you hit the Run
button to run the test.

00:21:42.252 --> 00:21:44.460
So the first thing that
Android Studio is going to do

00:21:44.460 --> 00:21:47.430
is it's going to install
two APKs for you, the test

00:21:47.430 --> 00:21:51.030
APK and the app on your test.

00:21:51.030 --> 00:21:53.970
Now, the test APK contains
Android JUnit Runner,

00:21:53.970 --> 00:21:58.300
it contains the test cases,
and your test manifest.

00:21:58.300 --> 00:22:00.150
And then, in order
to run the test,

00:22:00.150 --> 00:22:04.110
Android Studio calls, under the
hood, ADB Shell AM Instrument.

00:22:04.110 --> 00:22:07.320
And then Android JUnit Runner
will use instrumentation

00:22:07.320 --> 00:22:09.090
to control your
app on your test.

00:22:12.270 --> 00:22:14.790
What is instrumentation?

00:22:14.790 --> 00:22:17.980
I think you guys may
have noticed this.

00:22:17.980 --> 00:22:21.900
It's a top-level tag in your
manifest, and why is that?

00:22:21.900 --> 00:22:24.210
Instrumentation is
actually something

00:22:24.210 --> 00:22:27.840
that's used deeply inside
the Android framework,

00:22:27.840 --> 00:22:31.710
and it's used to control the
lifecycle of your activities,

00:22:31.710 --> 00:22:33.130
for instance.

00:22:33.130 --> 00:22:37.020
So if you think about it, it's
a perfect interception point

00:22:37.020 --> 00:22:39.990
that we can use to
inject the test runner.

00:22:39.990 --> 00:22:43.410
And that's why Android JUnit
Runner is nothing more or less

00:22:43.410 --> 00:22:46.970
than instrumentation.

00:22:46.970 --> 00:22:49.280
Let's go a little
bit deeper and see

00:22:49.280 --> 00:22:53.270
what happens when Android
Studio actually runs your test.

00:22:53.270 --> 00:22:55.640
It runs ADB Shell
AM Instrument, which

00:22:55.640 --> 00:22:58.640
will end up calling out
to Activity Manager.

00:22:58.640 --> 00:23:01.150
Activity manager will
then call, at one point,

00:23:01.150 --> 00:23:05.060
onCreate on your
instrumentation.

00:23:05.060 --> 00:23:07.160
Now that we know that
Android JUnit Runner is

00:23:07.160 --> 00:23:11.240
our instrumentation,
at this point,

00:23:11.240 --> 00:23:14.630
it will call onCreate
on the runner.

00:23:14.630 --> 00:23:17.760
And then the runner is going
to do a few things for you.

00:23:17.760 --> 00:23:20.000
It's going to collect
all your tests.

00:23:20.000 --> 00:23:23.150
Then it's going to run all
these tests sequentially

00:23:23.150 --> 00:23:26.190
and then it's reporting
back the results.

00:23:26.190 --> 00:23:28.670
One thing to note here is
that Android JUnit runner--

00:23:28.670 --> 00:23:30.110
and you may have noticed this--

00:23:30.110 --> 00:23:33.920
runs in the same process
than your application.

00:23:33.920 --> 00:23:35.780
And more importantly,
if you usually

00:23:35.780 --> 00:23:38.720
use Android JUnit Runner,
it runs all the tests

00:23:38.720 --> 00:23:42.020
in one single
instrumentation invocation.

00:23:42.020 --> 00:23:46.320
Android JUnit runner is
heavily used inside Google.

00:23:46.320 --> 00:23:48.710
We run billions of
tests each month

00:23:48.710 --> 00:23:50.360
using Android JUnit runner.

00:23:50.360 --> 00:23:55.060
And while doing so, we saw
some challenges that we faced

00:23:55.060 --> 00:23:58.220
and that we had to solve.

00:23:58.220 --> 00:24:02.750
One thing that we see
a lot is Shared State.

00:24:02.750 --> 00:24:05.060
And I'm not talking about
the kind of shared state

00:24:05.060 --> 00:24:07.730
that you control and that
you code in your app.

00:24:07.730 --> 00:24:11.240
I'm talking about the shared
state that builds up on memory,

00:24:11.240 --> 00:24:14.330
builds up on disk, and
makes your tests fail

00:24:14.330 --> 00:24:18.500
for no reason or
unpredictable conditions.

00:24:18.500 --> 00:24:21.500
And this, among other
things, will, at one point,

00:24:21.500 --> 00:24:23.170
lead to crashes.

00:24:23.170 --> 00:24:26.900
But in the previous module
that I just showed you,

00:24:26.900 --> 00:24:29.390
if one of your tests crashes
your instrumentation,

00:24:29.390 --> 00:24:33.560
it will take the whole
app process with it

00:24:33.560 --> 00:24:36.680
and all the subsequent
tests will not run anymore.

00:24:36.680 --> 00:24:39.740
And this is obviously a
problem for large test suites.

00:24:39.740 --> 00:24:42.110
Similarly, if you
think about debugging,

00:24:42.110 --> 00:24:45.320
if you run a couple of thousand
tests in one invocation,

00:24:45.320 --> 00:24:46.850
just think about
what your lock head

00:24:46.850 --> 00:24:51.920
will look like when you have
to go through it for debugging.

00:24:51.920 --> 00:24:54.410
So that's why inside
of Google, we have

00:24:54.410 --> 00:24:56.420
taken a different approach.

00:24:56.420 --> 00:25:00.560
Inside of Google,
every test method

00:25:00.560 --> 00:25:05.060
runs in its own
instrumentation and location.

00:25:05.060 --> 00:25:07.130
Now, you can do
this today, right?

00:25:07.130 --> 00:25:09.520
You can make multiple ADB calls.

00:25:09.520 --> 00:25:12.690
You can use a runner arc and
maintain your custom script.

00:25:12.690 --> 00:25:14.450
But the problem is
it might not really

00:25:14.450 --> 00:25:19.430
integrate well with your
development environment.

00:25:19.430 --> 00:25:22.430
That's why, today, I'm happy
to announce the Android Test

00:25:22.430 --> 00:25:23.900
Orchestrator.

00:25:23.900 --> 00:25:25.290
And the Android
Test Orchestrator

00:25:25.290 --> 00:25:29.270
is a way that allows you to
run tests like we do in Google.

00:25:29.270 --> 00:25:32.330
It's a service APK that
runs in the background

00:25:32.330 --> 00:25:38.690
and runs its test in a single
instrumentation invocation.

00:25:38.690 --> 00:25:42.560
And this, obviously,
has benefits, right?

00:25:42.560 --> 00:25:44.640
There's no shared state anymore.

00:25:44.640 --> 00:25:46.520
And in fact, the Android
Test Orchestrator

00:25:46.520 --> 00:25:50.990
runs PM clear before
it runs its tests.

00:25:50.990 --> 00:25:55.400
More so, crashes are
now completely isolated

00:25:55.400 --> 00:25:59.600
because we have single
instrumentation invocations.

00:25:59.600 --> 00:26:02.330
If a crash happens, all
the subsequent tests

00:26:02.330 --> 00:26:04.130
will still run.

00:26:04.130 --> 00:26:07.700
And similarly, for debugging,
all the debugging information

00:26:07.700 --> 00:26:09.440
that you collect and
pull off the device

00:26:09.440 --> 00:26:11.330
is now scoped to
a particular test.

00:26:14.360 --> 00:26:19.100
This is great and we benefit a
lot from it inside of Google.

00:26:19.100 --> 00:26:21.710
Let's see how it actually works.

00:26:21.710 --> 00:26:25.310
On top of installing the
test APK and on our tests,

00:26:25.310 --> 00:26:29.720
what we do now is we install
a third APK on our device,

00:26:29.720 --> 00:26:32.870
and it's a service APK running
in the background containing

00:26:32.870 --> 00:26:34.700
the orchestrator.

00:26:34.700 --> 00:26:37.580
And then, instead of running
multiple ATB commands,

00:26:37.580 --> 00:26:39.680
we run a single ATB command.

00:26:39.680 --> 00:26:41.840
But we don't instrument
the app under test.

00:26:41.840 --> 00:26:44.534
We instrument the
orchestrator directly.

00:26:44.534 --> 00:26:45.950
And then the
orchestrator is going

00:26:45.950 --> 00:26:48.810
to do all its work
on the device.

00:26:48.810 --> 00:26:51.620
So it's going to use Android
JUnit Runner to collect

00:26:51.620 --> 00:26:53.360
your tests, but then
it's going to run

00:26:53.360 --> 00:26:57.560
each of those tests
in its own invocation.

00:26:57.560 --> 00:27:03.080
And it's amazing and I'm pretty
sure you will like this a lot.

00:27:03.080 --> 00:27:05.660
And it will be available in the
next Android Testing Support

00:27:05.660 --> 00:27:06.950
library release.

00:27:06.950 --> 00:27:09.380
And more importantly,
we will have integration

00:27:09.380 --> 00:27:11.210
with Android Studio.

00:27:11.210 --> 00:27:13.610
It will be available in
Gradle and we will also

00:27:13.610 --> 00:27:15.410
have integration
with Firebase Test

00:27:15.410 --> 00:27:18.860
Lab coming later this year.

00:27:18.860 --> 00:27:22.040
Now that we know
how to run our test,

00:27:22.040 --> 00:27:25.310
let's actually look at how we
can write these integration

00:27:25.310 --> 00:27:26.180
tests.

00:27:26.180 --> 00:27:29.570
And usually, if you write a
[INAUDIBLE] test on Android,

00:27:29.570 --> 00:27:32.090
you're using the Espresso
testing framework.

00:27:32.090 --> 00:27:36.110
And as you can see, espresso
has this nice and simple API.

00:27:36.110 --> 00:27:38.390
And it actually
works pretty simple.

00:27:38.390 --> 00:27:41.420
What it does is you
give us a view matcher

00:27:41.420 --> 00:27:43.430
and we find a view
in the hierarchy that

00:27:43.430 --> 00:27:44.570
matches that matcher.

00:27:44.570 --> 00:27:46.680
And then, we either
perform a view action

00:27:46.680 --> 00:27:49.150
or check a view assertion.

00:27:49.150 --> 00:27:51.090
And because this
API is so simple,

00:27:51.090 --> 00:27:55.520
it's the perfect tool, too,
for fast TDD prototyping

00:27:55.520 --> 00:27:58.160
of UI tests.

00:27:58.160 --> 00:28:00.920
But in order to provide
you such a simple API,

00:28:00.920 --> 00:28:05.370
there's a lot of things that
need to go on under the hood.

00:28:05.370 --> 00:28:09.530
So let's actually look
at how Espresso works.

00:28:09.530 --> 00:28:12.207
So when you call onView
and give us your matcher,

00:28:12.207 --> 00:28:13.790
the first thing that
we're going to do

00:28:13.790 --> 00:28:18.020
is we're going to create a
view interaction for you.

00:28:18.020 --> 00:28:20.420
And then the next
thing is we make sure

00:28:20.420 --> 00:28:23.000
that your app is in
an idling, sane state

00:28:23.000 --> 00:28:25.160
before we are ready
to interact with it.

00:28:25.160 --> 00:28:28.055
And you can think of it, this
is at the core of Espresso.

00:28:28.055 --> 00:28:32.180
And Espresso is well-known for
its synchronization guarantees.

00:28:32.180 --> 00:28:34.460
And the way we do it
is we loop the message

00:28:34.460 --> 00:28:36.830
queue until there
are no messages

00:28:36.830 --> 00:28:39.110
for a reasonable amount of time.

00:28:39.110 --> 00:28:40.970
We look at all your
idling resources

00:28:40.970 --> 00:28:42.890
and make sure they're idle.

00:28:42.890 --> 00:28:46.370
And we also look at Async
Tasks to make sure there's

00:28:46.370 --> 00:28:48.020
no background work running.

00:28:48.020 --> 00:28:49.970
And only if we know
that your app is

00:28:49.970 --> 00:28:53.240
in a sane and stable state
and we're ready to interact,

00:28:53.240 --> 00:28:54.776
we're going to move on.

00:28:54.776 --> 00:28:56.900
And then we're going to
traverse the view hierarchy

00:28:56.900 --> 00:29:00.189
and find the view that
matches your matcher.

00:29:00.189 --> 00:29:01.730
And once we have
the view, we're then

00:29:01.730 --> 00:29:07.330
going to perform a view
action or a view assertion.

00:29:07.330 --> 00:29:08.600
And this is great.

00:29:08.600 --> 00:29:11.330
So now let's circle
back to the test

00:29:11.330 --> 00:29:13.730
that we showed you
in the beginning

00:29:13.730 --> 00:29:16.980
and have a closer look now that
we know how Espresso works.

00:29:16.980 --> 00:29:19.910
So in the first line,
as you may remember,

00:29:19.910 --> 00:29:21.990
we tried to click on
the Add Note button.

00:29:21.990 --> 00:29:25.280
And here, we're just going to
use a with ID matcher, which

00:29:25.280 --> 00:29:28.100
is a simple matcher that is
matching a view in the view

00:29:28.100 --> 00:29:30.920
hierarchy according to its ID.

00:29:30.920 --> 00:29:33.720
The next thing we want to do
is we want to click on the View

00:29:33.720 --> 00:29:37.580
and we use a Click
View action for this.

00:29:37.580 --> 00:29:41.840
Now, where it gets
interesting is the next line.

00:29:41.840 --> 00:29:44.960
Because on this line, we want to
type the title and description.

00:29:44.960 --> 00:29:48.320
And we want to use a type
text action for that.

00:29:48.320 --> 00:29:51.170
But here, all the espresso
synchronization guarantees

00:29:51.170 --> 00:29:53.510
will kick in and only
if we know that we

00:29:53.510 --> 00:29:57.380
are ready to interact
with your application,

00:29:57.380 --> 00:30:01.040
we're going to invoke
the type test action.

00:30:01.040 --> 00:30:03.230
And this is great
because it frees you

00:30:03.230 --> 00:30:04.940
from adding
additional boilerplate

00:30:04.940 --> 00:30:08.150
code and additional
slipping code to your test.

00:30:08.150 --> 00:30:11.150
So similarly, we're
going to save the note

00:30:11.150 --> 00:30:14.780
and then we're going to verify
that it's displayed on screen.

00:30:14.780 --> 00:30:15.560
And this is great.

00:30:15.560 --> 00:30:18.080
Now we know how
Espresso works and we

00:30:18.080 --> 00:30:22.882
know how it's a great tool to
do test-driven development.

00:30:22.882 --> 00:30:24.590
And now I'm going to
hand it over to Nick

00:30:24.590 --> 00:30:29.240
to talk a little bit more on how
you can improve your UI tests

00:30:29.240 --> 00:30:32.466
and how to improve your large
and medium testing strategy.

00:30:32.466 --> 00:30:35.214
[APPLAUSE]

00:30:36.590 --> 00:30:38.540
NICK KOROSTELEV:
Thank you, Stephan.

00:30:38.540 --> 00:30:40.970
So One good attribute
of a UI test

00:30:40.970 --> 00:30:43.056
is a test that never sleeps.

00:30:43.056 --> 00:30:44.930
So let's go back to our
example to illustrate

00:30:44.930 --> 00:30:47.132
this point a little bit further.

00:30:47.132 --> 00:30:48.590
In our example, as
you remember, we

00:30:48.590 --> 00:30:51.330
have a note that we
save into memory,

00:30:51.330 --> 00:30:53.820
which is pretty fast
and pretty reliable.

00:30:53.820 --> 00:30:57.380
However, in reality,
as your app grows,

00:30:57.380 --> 00:30:59.750
you probably want extend
this functionality

00:30:59.750 --> 00:31:03.530
and save your note to the cloud
or Google Drive, for example.

00:31:03.530 --> 00:31:06.110
So when running our
large end-to-end test,

00:31:06.110 --> 00:31:07.640
we want to use a
real environment

00:31:07.640 --> 00:31:09.650
where we hit the real server.

00:31:09.650 --> 00:31:11.510
And depending on your
network connection,

00:31:11.510 --> 00:31:13.820
this may take a long
time, so you probably

00:31:13.820 --> 00:31:15.530
want to do is in the background.

00:31:15.530 --> 00:31:18.440
Now the problem is that
Espresso synchronization is not

00:31:18.440 --> 00:31:22.400
aware of any of your
long-running tasks.

00:31:22.400 --> 00:31:25.340
This is somewhere where
developers would probably

00:31:25.340 --> 00:31:28.220
do something as ugly as putting
a thread sleep in their code.

00:31:28.220 --> 00:31:30.350
But with Espresso, it
is not actually required

00:31:30.350 --> 00:31:33.035
because you can write an
Idling Resource, where

00:31:33.035 --> 00:31:36.110
an idling resource is a
simple interface for you

00:31:36.110 --> 00:31:38.330
as a developer to
implement to teach Espresso

00:31:38.330 --> 00:31:42.940
synchronization of any of your
custom, long-running tasks

00:31:42.940 --> 00:31:44.490
of your app.

00:31:44.490 --> 00:31:48.710
So with this Idling Resource, we
made our large end-to-end test

00:31:48.710 --> 00:31:50.310
more reliable.

00:31:50.310 --> 00:31:53.240
So let's see how we can add
some more medium-sized tests

00:31:53.240 --> 00:31:55.320
to your test suite.

00:31:55.320 --> 00:31:56.870
So for a medium-sized
test, we want

00:31:56.870 --> 00:32:00.335
to keep them small and focused
on a single UI component, where

00:32:00.335 --> 00:32:04.130
a single UI component may be
a specific view, fragment,

00:32:04.130 --> 00:32:06.027
or an activity.

00:32:06.027 --> 00:32:07.610
So let's go back to
our example to see

00:32:07.610 --> 00:32:11.360
how we can isolate our
large end-to-end to more

00:32:11.360 --> 00:32:13.430
isolated components.

00:32:13.430 --> 00:32:16.040
Here in this example,
again, you may have noticed

00:32:16.040 --> 00:32:17.850
that there are two activities.

00:32:17.850 --> 00:32:20.450
The List activity on
the left and the Add

00:32:20.450 --> 00:32:22.340
Note activity on the right.

00:32:22.340 --> 00:32:24.716
So until now, we wrote
a large end-to-end test

00:32:24.716 --> 00:32:26.090
that gives us a
lot of confidence

00:32:26.090 --> 00:32:28.760
because it touches
upon a lot of your code

00:32:28.760 --> 00:32:31.700
in your app, which is great
for large end-to-end tests,

00:32:31.700 --> 00:32:34.310
but it's not so great for
an iterative test-driven

00:32:34.310 --> 00:32:35.120
development cycle.

00:32:39.080 --> 00:32:41.060
So let's see how we
can isolate these

00:32:41.060 --> 00:32:46.160
and have isolated tests for
each activity in isolation.

00:32:46.160 --> 00:32:48.980
To isolate the left-hand
side, the List activity,

00:32:48.980 --> 00:32:52.850
we can use Espresso Intent,
where Espresso Intent is

00:32:52.850 --> 00:32:55.040
a simple API that
allows you to intercept

00:32:55.040 --> 00:32:58.430
any of your ongoing intents,
verify their content,

00:32:58.430 --> 00:33:03.440
and provide back a
mock activity result.

00:33:03.440 --> 00:33:04.010
Great.

00:33:04.010 --> 00:33:06.855
Let's see how that API
actually looks like.

00:33:06.855 --> 00:33:08.730
So as you can see, it's
very straightforward.

00:33:08.730 --> 00:33:12.980
You have an intent matcher that
will match your growing intent,

00:33:12.980 --> 00:33:15.730
and you can provide a version
of your activity result

00:33:15.730 --> 00:33:17.730
back to the caller.

00:33:17.730 --> 00:33:18.230
OK.

00:33:18.230 --> 00:33:22.970
Let's use this API to write
our first isolated test.

00:33:22.970 --> 00:33:25.700
In this test, you can
see, on the first line,

00:33:25.700 --> 00:33:27.540
we do exactly that.

00:33:27.540 --> 00:33:30.350
We intercept our
content and we provide

00:33:30.350 --> 00:33:32.630
a stub version of
our activity result.

00:33:32.630 --> 00:33:34.880
Now, on the second
line, when we perform

00:33:34.880 --> 00:33:37.550
Click, instead of
starting a new activity,

00:33:37.550 --> 00:33:39.980
Espresso will
intercept this intent

00:33:39.980 --> 00:33:42.740
and provide a Stub Activity
result, which we can then

00:33:42.740 --> 00:33:48.800
use on the last line to
verify that our UI was updated

00:33:48.800 --> 00:33:50.670
accordingly.

00:33:50.670 --> 00:33:52.501
Now we have an isolated test.

00:33:52.501 --> 00:33:53.000
OK.

00:33:53.000 --> 00:33:55.490
So let's go back to
our example and see

00:33:55.490 --> 00:33:57.920
how we can isolate the
second part, right?

00:33:57.920 --> 00:34:00.770
So when you usually
write tests, you

00:34:00.770 --> 00:34:02.720
end up in a position
where you may

00:34:02.720 --> 00:34:06.630
have some external
dependencies in play that

00:34:06.630 --> 00:34:09.020
are outside of your control.

00:34:09.020 --> 00:34:11.750
In our example, as
I showed before,

00:34:11.750 --> 00:34:16.219
we have a note that we save
and it hits the real server.

00:34:16.219 --> 00:34:18.170
Now even though we have
another resource now

00:34:18.170 --> 00:34:20.360
that makes it more
reliable, your test

00:34:20.360 --> 00:34:21.860
can still fail
because your server

00:34:21.860 --> 00:34:23.929
may crash for some reason.

00:34:23.929 --> 00:34:25.909
So your task will fail.

00:34:25.909 --> 00:34:28.699
So wouldn't it be better if we
completely isolate ourselves

00:34:28.699 --> 00:34:31.159
from these conditions
and run our tests

00:34:31.159 --> 00:34:33.260
in a hermetic environment?

00:34:33.260 --> 00:34:36.080
This will not only make
your test run much faster,

00:34:36.080 --> 00:34:38.810
but it will also
eliminate any flakiness.

00:34:38.810 --> 00:34:40.969
And beyond this
specific example,

00:34:40.969 --> 00:34:42.679
you further want
to isolate yourself

00:34:42.679 --> 00:34:45.150
from any external dependencies.

00:34:45.150 --> 00:34:48.120
So for example, you don't want
to test any Android system

00:34:48.120 --> 00:34:50.810
UI or any other UI
components that you

00:34:50.810 --> 00:34:54.155
don't own because they
probably already tested

00:34:54.155 --> 00:34:56.030
and they can also change
without your knowing

00:34:56.030 --> 00:34:59.390
so your test will actually fail.

00:34:59.390 --> 00:35:01.040
Let's see how our
second isolated

00:35:01.040 --> 00:35:03.330
test will look in code.

00:35:03.330 --> 00:35:07.040
So the main point here
is that we no longer use

00:35:07.040 --> 00:35:09.170
the real server.

00:35:09.170 --> 00:35:13.160
Instead, we set up a
hermetic repository.

00:35:13.160 --> 00:35:15.800
Now, there's many different
ways of you to do this

00:35:15.800 --> 00:35:17.300
and this is just one way.

00:35:17.300 --> 00:35:19.910
So then you can use
this hermetic repository

00:35:19.910 --> 00:35:21.860
in order to verify that
your note is actually

00:35:21.860 --> 00:35:24.740
saved without ever leaving
the context of your app

00:35:24.740 --> 00:35:27.380
or hitting the network.

00:35:27.380 --> 00:35:29.540
So at this point, if
you think about it,

00:35:29.540 --> 00:35:36.450
you have two smaller tests
that are way more reliable

00:35:36.450 --> 00:35:38.010
and run much faster.

00:35:38.010 --> 00:35:40.560
But at the same time, you
maintain the same amount

00:35:40.560 --> 00:35:43.350
of test coverage as your
large end-to-end test.

00:35:43.350 --> 00:35:46.770
And this is why we want to
have more of these smaller

00:35:46.770 --> 00:35:50.460
isolated tests compared to
the large end-to-end tests we

00:35:50.460 --> 00:35:52.510
showed before.

00:35:52.510 --> 00:35:53.010
OK.

00:35:53.010 --> 00:35:57.180
So at this point, we iterated
through our developer cycle

00:35:57.180 --> 00:36:00.300
a few times and we should
see all of our tests

00:36:00.300 --> 00:36:03.270
start turning green and we
should be confident to release

00:36:03.270 --> 00:36:04.530
our feature.

00:36:04.530 --> 00:36:07.050
However, before
we conclude, let's

00:36:07.050 --> 00:36:10.080
jump into the
future for a second.

00:36:10.080 --> 00:36:13.050
As your app grows
and your team grows,

00:36:13.050 --> 00:36:15.776
you continue adding more and
more features to your app.

00:36:15.776 --> 00:36:17.400
And you may find
yourself in a position

00:36:17.400 --> 00:36:21.750
where you may have UI running
in multiple processes, which

00:36:21.750 --> 00:36:23.890
is exactly what
happened at Google.

00:36:23.890 --> 00:36:25.800
So if you go to our
Add Notes example,

00:36:25.800 --> 00:36:27.700
this may look
something like this.

00:36:27.700 --> 00:36:30.240
You have a first activity
that runs in your main process

00:36:30.240 --> 00:36:31.840
on the left-hand side.

00:36:31.840 --> 00:36:36.690
And now the second activity
will run in a private process.

00:36:36.690 --> 00:36:39.190
And in this case, we're
going to call it Add Notes.

00:36:39.190 --> 00:36:40.780
So how do we test that?

00:36:40.780 --> 00:36:45.720
Well, before Android O, it
wasn't possible to test.

00:36:45.720 --> 00:36:48.870
But with Android O, there
is a new instrumentation

00:36:48.870 --> 00:36:51.900
attribute that you can use
in order to define which

00:36:51.900 --> 00:36:54.300
process you want to instrument.

00:36:54.300 --> 00:36:56.670
While instrumenting and
running tests, I guess,

00:36:56.670 --> 00:36:58.650
each process, in
isolation, is a great idea

00:36:58.650 --> 00:37:01.650
and you should do it, you may
find yourself in a position

00:37:01.650 --> 00:37:05.730
where you want to cross-process
boundaries within one test.

00:37:05.730 --> 00:37:08.160
So you would probably
want to write an Espresso

00:37:08.160 --> 00:37:10.980
test that looks like this.

00:37:10.980 --> 00:37:13.770
While this was not only
impossible on a framework level

00:37:13.770 --> 00:37:17.250
before Android O, this was also
impossible on Espresso level.

00:37:17.250 --> 00:37:19.770
Because in this
specific example,

00:37:19.770 --> 00:37:22.560
Espresso is not even aware
of your secondary process,

00:37:22.560 --> 00:37:25.560
nor can it maintain any of
the synchronization guarantees

00:37:25.560 --> 00:37:27.750
we all know and love.

00:37:27.750 --> 00:37:33.030
Today, I'm happy to announce
Multiprocess Espresso support.

00:37:33.030 --> 00:37:35.730
Without changing any of your
test code or your app code

00:37:35.730 --> 00:37:37.950
this will allow you to
seamlessly interact with UI

00:37:37.950 --> 00:37:40.590
across processes, while
maintaining all of us

00:37:40.590 --> 00:37:44.250
Espresso synchronization
guarantees.

00:37:44.250 --> 00:37:47.550
And it will be available in the
next version of Android Test

00:37:47.550 --> 00:37:49.200
Support Library release.

00:37:49.200 --> 00:37:53.400
So let's have a quick overview
of how it actually works.

00:37:53.400 --> 00:37:55.980
Traditionally, as you
know, in our example,

00:37:55.980 --> 00:38:00.120
we start in one
process, where we

00:38:00.120 --> 00:38:02.910
have an instance of Android
JUnit Runner and Espresso,

00:38:02.910 --> 00:38:04.117
in this case.

00:38:04.117 --> 00:38:05.700
Now, if you remember
from our example,

00:38:05.700 --> 00:38:08.130
when we click the
Add Note button,

00:38:08.130 --> 00:38:11.640
there will be a new activity
and now we have a new process.

00:38:11.640 --> 00:38:15.030
So the problem now
is that we have

00:38:15.030 --> 00:38:18.090
two processes with two different
instances of Android JUnit

00:38:18.090 --> 00:38:21.360
Runner and Espresso, and
they're not aware of each other.

00:38:21.360 --> 00:38:23.160
So the first thing
that we want to do

00:38:23.160 --> 00:38:26.130
is we want to establish
communication between the two

00:38:26.130 --> 00:38:28.140
Android JUnit Runners.

00:38:28.140 --> 00:38:31.080
And now that we have
this communication,

00:38:31.080 --> 00:38:34.440
we can use it to establish
the communication

00:38:34.440 --> 00:38:35.940
to Espresso instances.

00:38:35.940 --> 00:38:38.700
And the way we do
that is by having

00:38:38.700 --> 00:38:42.210
an ability in the Android JUnit
Runner to register any testing

00:38:42.210 --> 00:38:45.570
frameworks, like Espresso,
with Android JUnit Runner.

00:38:45.570 --> 00:38:49.140
And then the runner will then
facilitate all the handshaking

00:38:49.140 --> 00:38:51.930
required in order to establish
communication between the two

00:38:51.930 --> 00:38:54.030
Espresso instances.

00:38:54.030 --> 00:38:55.920
Now that the two
Espresso instances

00:38:55.920 --> 00:38:58.320
can talk to each
other, it can then

00:38:58.320 --> 00:39:01.200
use it in order to enable
cross-process testing

00:39:01.200 --> 00:39:04.140
and maintain all the
synchronization guarantees

00:39:04.140 --> 00:39:06.190
that we had before.

00:39:06.190 --> 00:39:08.610
OK.

00:39:08.610 --> 00:39:11.354
With that, we're reaching the
end of our developer workflow

00:39:11.354 --> 00:39:13.020
and we showed you all
the tools that you

00:39:13.020 --> 00:39:15.210
can use across each
step of the way

00:39:15.210 --> 00:39:18.600
in order to make TDD
happen on Android.

00:39:18.600 --> 00:39:22.560
And with that said, even if you
don't follow this flow exactly,

00:39:22.560 --> 00:39:25.020
hopefully, you know how
to use every single tool

00:39:25.020 --> 00:39:27.930
and how to write good tests
in order to bring your app

00:39:27.930 --> 00:39:31.030
quality to the next level.

00:39:31.030 --> 00:39:34.925
So if you like to write tests
and you want to write and run

00:39:34.925 --> 00:39:37.050
tests like we do at Google,
here are some resources

00:39:37.050 --> 00:39:40.000
to get you started.

00:39:40.000 --> 00:39:41.550
I want to thank
you and I think we

00:39:41.550 --> 00:39:43.800
have some time for questions.

00:39:43.800 --> 00:39:50.580
And if not, we have office
hours at 3:30 today.

00:39:50.580 --> 00:39:52.030
So hopefully, we'll
see you there.

00:39:52.030 --> 00:39:52.530
Thank you.

00:39:52.530 --> 00:39:54.490
[APPLAUSE]

00:39:56.450 --> 00:40:00.020
[MUSIC PLAYING]

