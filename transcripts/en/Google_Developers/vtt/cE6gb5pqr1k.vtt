WEBVTT
Kind: captions
Language: en

00:00:00.370 --> 00:00:00.620
Hi.

00:00:00.620 --> 00:00:03.150
I'm Christina, product manager
for the Google App Engine

00:00:03.150 --> 00:00:04.390
search API.

00:00:04.390 --> 00:00:07.120
In this webinar, we'll provide
an introduction to the Search

00:00:07.120 --> 00:00:09.560
API and show you how to use
it in your App Engine

00:00:09.560 --> 00:00:11.150
application.

00:00:11.150 --> 00:00:13.360
The Search API lets your
application perform

00:00:13.360 --> 00:00:16.540
Google-like full-text searches
over structured data and also

00:00:16.540 --> 00:00:19.240
supports GeoSearch for
location-based searches.

00:00:19.240 --> 00:00:21.670
It provides a straightforward
model for indexing and

00:00:21.670 --> 00:00:26.390
searching data and displaying
the results of search queries.

00:00:26.390 --> 00:00:29.230
Using the Search API, you can
query any data source you

00:00:29.230 --> 00:00:31.500
choose by creating
search documents.

00:00:31.500 --> 00:00:33.930
You structure data in documents
using fields to

00:00:33.930 --> 00:00:37.350
describe the different types of
data the document contains,

00:00:37.350 --> 00:00:39.690
and then add the document
to an index to make it

00:00:39.690 --> 00:00:40.750
searchable.

00:00:40.750 --> 00:00:43.630
Once documents are indexed, you
can search an index via

00:00:43.630 --> 00:00:46.340
the Search API's comprehensive
query language.

00:00:46.340 --> 00:00:48.700
When you query, you can specify
sort orders on the

00:00:48.700 --> 00:00:51.480
results, control the
presentation and content of

00:00:51.480 --> 00:00:53.910
the search results with features
like snippets, and

00:00:53.910 --> 00:00:55.550
use cursors and offsets.

00:00:55.550 --> 00:00:58.290
The search API can be useful
in a range of applications,

00:00:58.290 --> 00:01:01.100
like user review search,
searching over blog posts and

00:01:01.100 --> 00:01:05.060
comments, document discovery,
help desk answer retrieval,

00:01:05.060 --> 00:01:08.120
resume search and recruiting,
and product searches in an

00:01:08.120 --> 00:01:10.140
online store, the example
application

00:01:10.140 --> 00:01:11.740
we'll use in this webinar.

00:01:11.740 --> 00:01:13.900
In this webinar, we will
highlight the features of the

00:01:13.900 --> 00:01:16.740
search API and get you started
on adding full-text search to

00:01:16.740 --> 00:01:18.610
your own App Engine
applications.

00:01:18.610 --> 00:01:21.430
We'll start by looking at
defining search indexes and

00:01:21.430 --> 00:01:24.640
building documents, and then
move on to querying, sorting,

00:01:24.640 --> 00:01:27.160
GeoSearch, and, finally,
best practices.

00:01:27.160 --> 00:01:29.220
For the purposes of this
webinar, we'll be using

00:01:29.220 --> 00:01:31.460
Python, but the flow in
Java is quite similar.

00:01:31.460 --> 00:01:33.470
And Java code snippets
can be found at

00:01:33.470 --> 00:01:34.720
fts-webinar.appspot.com.

00:01:37.630 --> 00:01:40.050
This webinar assumes that you
have familiarity with building

00:01:40.050 --> 00:01:42.590
an App Engine app in either
Java or Python.

00:01:42.590 --> 00:01:45.410
For more background on App
Engine, see our documentation

00:01:45.410 --> 00:01:49.270
at developers.googl
e.com/appengine.

00:01:49.270 --> 00:01:51.230
At the end of this presentation,
you'll find a

00:01:51.230 --> 00:01:54.410
resources slide with links to
the documentation and other

00:01:54.410 --> 00:01:56.230
useful sources of information.

00:01:56.230 --> 00:01:58.590
So now, I'll hand it over to
Amy, who will demo some of the

00:01:58.590 --> 00:02:01.620
full-text search features in a
sample application and walk

00:02:01.620 --> 00:02:04.390
you through getting started
with the search API.

00:02:04.390 --> 00:02:04.860
AMY UNRUH: Hi.

00:02:04.860 --> 00:02:08.490
I'm Amy, a developer relations
engineer working on the App

00:02:08.490 --> 00:02:10.740
Engine search API.

00:02:10.740 --> 00:02:13.770
We're going to use an example
product search application to

00:02:13.770 --> 00:02:16.760
illustrate some of the features
of the search API.

00:02:16.760 --> 00:02:19.685
This application shows how you
might use full-text search in

00:02:19.685 --> 00:02:21.100
an e-commerce application.

00:02:21.100 --> 00:02:24.910
We've indexed two general kinds
of content in this app,

00:02:24.910 --> 00:02:28.320
product information and
information about stores,

00:02:28.320 --> 00:02:31.310
including their geographical
location.

00:02:31.310 --> 00:02:34.560
The application allows a user to
find products by searching

00:02:34.560 --> 00:02:37.860
and sorting the product content
and to use GeoSearch

00:02:37.860 --> 00:02:42.270
to find stores that carry a
given product near to them.

00:02:42.270 --> 00:02:44.940
So we'll do a short demo first
to introduce some of the

00:02:44.940 --> 00:02:47.740
features covered
in the webinar.

00:02:47.740 --> 00:02:49.270
This is our demo application.

00:02:49.270 --> 00:02:54.380
It has two example product
categories, books and HDTVs.

00:02:54.380 --> 00:02:56.820
So it's kind of a small store.

00:02:56.820 --> 00:03:01.450
And it contains index product
documents and index store

00:03:01.450 --> 00:03:02.700
location information.

00:03:04.910 --> 00:03:05.640
OK.

00:03:05.640 --> 00:03:08.350
So let's do some searches so
that you can get a sense of

00:03:08.350 --> 00:03:11.930
the query language and the
search API features.

00:03:11.930 --> 00:03:15.740
For the purposes of this demo,
we're going to show you the

00:03:15.740 --> 00:03:19.260
query as is, including the query
operators, so that you

00:03:19.260 --> 00:03:20.990
can get a sense of
the language.

00:03:20.990 --> 00:03:23.010
For a real application,
you would obscure

00:03:23.010 --> 00:03:24.150
that from the user.

00:03:24.150 --> 00:03:27.900
You wouldn't expect them
to know the details

00:03:27.900 --> 00:03:30.020
of the query language.

00:03:30.020 --> 00:03:32.850
I'm going to start by submitting
an empty query.

00:03:32.850 --> 00:03:35.630
This retrieves all of the
documents in the application,

00:03:35.630 --> 00:03:39.255
sorted by their average
rating.

00:03:39.255 --> 00:03:41.500
You can see there are
only 12 of them.

00:03:41.500 --> 00:03:43.630
Now I'm going to filter
on books,

00:03:43.630 --> 00:03:44.880
filter on product category.

00:03:47.970 --> 00:03:52.860
So here's an example of
filtering on a document field.

00:03:52.860 --> 00:03:54.110
Now let's sort on price.

00:03:59.130 --> 00:04:02.050
So as you can see, we can
sort on different

00:04:02.050 --> 00:04:03.670
aspects of our documents.

00:04:03.670 --> 00:04:06.110
And you'll note that we have
support for pagination.

00:04:10.560 --> 00:04:10.900
All right.

00:04:10.900 --> 00:04:13.170
Now let's do something a little
more interesting, add a

00:04:13.170 --> 00:04:24.830
search term, "stories."
I'm going to

00:04:24.830 --> 00:04:28.220
sort my query by relevance.

00:04:28.220 --> 00:04:37.090
So what this does is it uses a
TF by IDF score to sort, term

00:04:37.090 --> 00:04:39.620
frequency by inverse
document frequency.

00:04:39.620 --> 00:04:44.850
So this is finding documents
that are particularly relevant

00:04:44.850 --> 00:04:46.880
to our search.

00:04:46.880 --> 00:04:49.870
And notice that we're displaying
only a snippet of

00:04:49.870 --> 00:04:51.620
the description fields.

00:04:51.620 --> 00:04:56.420
And that the hit on the term
"stories" here is bolded.

00:04:56.420 --> 00:04:59.630
So let's look, just very
quickly, at the product

00:04:59.630 --> 00:05:04.670
details of the top two
hits for that search.

00:05:04.670 --> 00:05:09.560
And you'll see that this first
hit has a number of instances

00:05:09.560 --> 00:05:11.510
of the word "stories"
in the description.

00:05:11.510 --> 00:05:15.540
And you'll notice that the
description is longer than the

00:05:15.540 --> 00:05:19.410
original snippet that we
were just showing.

00:05:19.410 --> 00:05:22.270
And if we look at the product
details for the second hit

00:05:22.270 --> 00:05:25.960
here, you'll see that we only
have one instance of the word

00:05:25.960 --> 00:05:29.280
"stories." So we're sorting the
documents by relevance.

00:05:29.280 --> 00:05:36.610
And we are auto-generating
snippets with the hits bolded.

00:05:36.610 --> 00:05:40.700
And the snippets are showing
where the hit was in the long

00:05:40.700 --> 00:05:41.700
description.

00:05:41.700 --> 00:05:42.510
All right.

00:05:42.510 --> 00:05:45.850
Now let's look at Boolean
operators.

00:05:45.850 --> 00:05:49.200
So if you just type in
some search terms--

00:05:49.200 --> 00:05:53.680
I will type in "stories"
and "novels"--

00:05:53.680 --> 00:05:57.380
this is an implicit "and"
of these terms.

00:05:57.380 --> 00:06:00.900
And you'll notice that we
don't appear to have any

00:06:00.900 --> 00:06:05.630
products in our store that use
both those terms together.

00:06:05.630 --> 00:06:11.950
So now let's use the or operator
and do an or query.

00:06:11.950 --> 00:06:15.010
And then we get some results.

00:06:15.010 --> 00:06:18.490
So we have some documents with
hits on one or the other of

00:06:18.490 --> 00:06:19.220
those terms.

00:06:19.220 --> 00:06:22.060
And you can see, again, the
snippeting is showing where we

00:06:22.060 --> 00:06:24.530
got the hits and is bolding.

00:06:24.530 --> 00:06:28.140
You can also restrict a search
term to a specific field in an

00:06:28.140 --> 00:06:28.780
index document.

00:06:28.780 --> 00:06:31.310
And we'll talk in more detail
just a bit later about what we

00:06:31.310 --> 00:06:32.720
mean by fields.

00:06:32.720 --> 00:06:35.780
So let's look at the syntax
for doing that.

00:06:35.780 --> 00:06:38.540
One of the fields in our product
document is the Name

00:06:38.540 --> 00:06:40.440
field, the product name.

00:06:40.440 --> 00:06:45.700
And I'm going to search for
documents that have the word

00:06:45.700 --> 00:06:47.830
"the" in the product name.

00:06:47.830 --> 00:06:50.730
So you can see we're getting
some hits, Otherwise Known as

00:06:50.730 --> 00:06:53.850
the Human Condition,
for example.

00:06:53.850 --> 00:06:59.550
You can combine searches
on name fields with

00:06:59.550 --> 00:07:02.450
other terms, like this.

00:07:02.450 --> 00:07:06.420
So I'm looking for documents
that have the word

00:07:06.420 --> 00:07:09.950
"collection" somewhere in one
of their fields and have the

00:07:09.950 --> 00:07:13.180
word "name" in the product.

00:07:13.180 --> 00:07:17.980
And you can do searches for
fields that aren't in all of

00:07:17.980 --> 00:07:18.770
your documents.

00:07:18.770 --> 00:07:23.980
So, for example, our book
products have a publisher

00:07:23.980 --> 00:07:25.680
field, but our TVs don't.

00:07:25.680 --> 00:07:31.880
So we can look for something
like this, publisher Penguin.

00:07:31.880 --> 00:07:35.800
And there's some of
our hits for that.

00:07:35.800 --> 00:07:39.890
And search API also supports
atomic fields, which must be

00:07:39.890 --> 00:07:41.100
matched exactly.

00:07:41.100 --> 00:07:45.760
So this means that you can't
search for just a substring in

00:07:45.760 --> 00:07:46.270
that field.

00:07:46.270 --> 00:07:50.660
You need to search for the whole
string to get a hit.

00:07:50.660 --> 00:07:54.380
And our categories are
atomic fields.

00:07:54.380 --> 00:07:58.110
And that's because we want to
search exactly on categories.

00:07:58.110 --> 00:08:01.500
We want to treat them
essentially as a token, or an

00:08:01.500 --> 00:08:02.730
innumerable.

00:08:02.730 --> 00:08:04.740
You can also use numeric
comparators.

00:08:04.740 --> 00:08:08.570
So you do this by using the
field name in the expression.

00:08:08.570 --> 00:08:10.740
So price is one of
the field names

00:08:10.740 --> 00:08:13.010
in our product documents.

00:08:13.010 --> 00:08:20.740
And so we can do queries, like
price less than $20.

00:08:20.740 --> 00:08:26.160
And as before, you can include
use of these numeric

00:08:26.160 --> 00:08:27.790
comparatives with other
search terms.

00:08:27.790 --> 00:08:31.690
So now we're looking for all
products that have the word

00:08:31.690 --> 00:08:34.809
"novel" where price
is less than $20.

00:08:34.809 --> 00:08:37.110
So this demo showed you some
of the features and

00:08:37.110 --> 00:08:39.320
capabilities of the
search API.

00:08:39.320 --> 00:08:42.320
We'll come back to the example
application a little bit later

00:08:42.320 --> 00:08:45.270
in the webinar to show you
a few more concepts.

00:08:45.270 --> 00:08:47.770
So now let's look at how you
can add full-text search

00:08:47.770 --> 00:08:50.470
capabilities to your
own application.

00:08:50.470 --> 00:08:53.010
We'll start with indexes.

00:08:53.010 --> 00:08:55.890
Start by looking at what a
search index is and how you

00:08:55.890 --> 00:08:59.130
add content to an index.

00:08:59.130 --> 00:09:02.490
The search API operates through
an index object.

00:09:02.490 --> 00:09:05.340
And an index allows you to
store content and index

00:09:05.340 --> 00:09:09.290
documents, retrieve documents
using search queries, modify

00:09:09.290 --> 00:09:11.840
documents, and delete
documents.

00:09:11.840 --> 00:09:15.870
So each index has a name and
optionally a namespace.

00:09:15.870 --> 00:09:18.580
The index name uniquely
identifies an

00:09:18.580 --> 00:09:21.040
index in a given namespace.

00:09:21.040 --> 00:09:24.450
In your code, you create an
index object by specifying the

00:09:24.450 --> 00:09:25.685
index name.

00:09:25.685 --> 00:09:29.660
The underlying document index
will be created at first write

00:09:29.660 --> 00:09:31.360
if it does not already exist.

00:09:31.360 --> 00:09:35.460
So you don't have to explicitly
create it yourself.

00:09:35.460 --> 00:09:38.070
So let's look at what this
looks like in your code.

00:09:38.070 --> 00:09:42.050
First of all, we import
the search module.

00:09:42.050 --> 00:09:46.520
And here, we're creating an
index object with name

00:09:46.520 --> 00:09:47.770
productsearch1.

00:09:50.454 --> 00:09:54.380
The second line here shows what
the code would look like

00:09:54.380 --> 00:09:57.420
if you wanted to specify a
namespace that the index was

00:09:57.420 --> 00:10:00.390
associated with.

00:10:00.390 --> 00:10:02.060
Next, let's look at how
to add searchable

00:10:02.060 --> 00:10:03.490
content to an index.

00:10:03.490 --> 00:10:05.880
You do this using documents.

00:10:05.880 --> 00:10:09.570
Documents hold an index's
searchable content.

00:10:09.570 --> 00:10:11.360
So you add a document
to an index.

00:10:11.360 --> 00:10:14.900
And then once it's indexed,
you can query it.

00:10:14.900 --> 00:10:17.520
A document represents a
uniquely identified

00:10:17.520 --> 00:10:19.550
collection of fields.

00:10:19.550 --> 00:10:23.000
And it's identified by
a unique document ID.

00:10:23.000 --> 00:10:25.860
Fields are named typed values.

00:10:25.860 --> 00:10:28.440
So some of the field types
that we're using in our

00:10:28.440 --> 00:10:32.520
example application are text
field, number field, date

00:10:32.520 --> 00:10:34.990
field, and atom field.

00:10:34.990 --> 00:10:39.760
And all of these are pretty
much what you would expect

00:10:39.760 --> 00:10:40.400
them to be.

00:10:40.400 --> 00:10:42.970
The documentation provides
a lot more information.

00:10:42.970 --> 00:10:46.750
So I wanted to particularly
comment on atom field, which

00:10:46.750 --> 00:10:50.690
is essentially an innumerable
or a token.

00:10:50.690 --> 00:10:53.850
You only get a hit on an atom
field if you search for the

00:10:53.850 --> 00:10:55.980
entire string, not
a substring.

00:10:55.980 --> 00:10:58.960
So let's look at the structure
of the product documents in

00:10:58.960 --> 00:11:00.920
our example application.

00:11:00.920 --> 00:11:03.940
We've got two different
categories of products, books

00:11:03.940 --> 00:11:05.670
and televisions.

00:11:05.670 --> 00:11:11.210
And each product document always
includes certain core

00:11:11.210 --> 00:11:13.870
fields, which this figure
is indicating

00:11:13.870 --> 00:11:15.400
by these boxes here.

00:11:15.400 --> 00:11:18.870
So some of these core fields
are product ID, name,

00:11:18.870 --> 00:11:23.520
description, category,
price, date, and the

00:11:23.520 --> 00:11:25.470
rating of the product.

00:11:25.470 --> 00:11:29.330
Then the televisions have some
additional fields, such as TV

00:11:29.330 --> 00:11:30.620
type and brand.

00:11:30.620 --> 00:11:31.800
And the books have
some additional

00:11:31.800 --> 00:11:34.050
fields, such as publisher.

00:11:34.050 --> 00:11:37.590
And so we're imposing the
structure, the semantics, at

00:11:37.590 --> 00:11:39.670
the application level.

00:11:39.670 --> 00:11:42.530
So in our example application,
product documents always

00:11:42.530 --> 00:11:44.770
include the same core fields.

00:11:44.770 --> 00:11:46.760
All televisions always have
the same additional

00:11:46.760 --> 00:11:48.460
fields, and so on.

00:11:48.460 --> 00:11:51.350
The documents themselves in
the search API do not

00:11:51.350 --> 00:11:55.210
intrinsically have kinds
in the sense

00:11:55.210 --> 00:11:57.860
of datastore entities.

00:11:57.860 --> 00:12:00.970
You impose semantics on
these documents at

00:12:00.970 --> 00:12:03.030
the application level.

00:12:03.030 --> 00:12:06.120
So you can use namespaces and
indexes, as well as field

00:12:06.120 --> 00:12:09.160
values, to organize
your documents.

00:12:09.160 --> 00:12:11.630
In the example application,
there are two indexes.

00:12:11.630 --> 00:12:14.640
All of the product documents
are in one index.

00:12:14.640 --> 00:12:17.540
And another index, which holds
information about store

00:12:17.540 --> 00:12:19.990
locations, we'll talk
about a little bit

00:12:19.990 --> 00:12:22.620
later in the webinar.

00:12:22.620 --> 00:12:26.290
So let's take a look at how we
build a product document.

00:12:26.290 --> 00:12:28.720
The first thing that we do
is to find the fields.

00:12:28.720 --> 00:12:32.140
And then we create the documents
from the fields.

00:12:32.140 --> 00:12:35.580
So in our example application,
we're using text fields, atom

00:12:35.580 --> 00:12:37.520
fields, number fields,
and date fields

00:12:37.520 --> 00:12:39.900
types for product documents.

00:12:39.900 --> 00:12:42.780
And in particular, worth
commenting that we're using

00:12:42.780 --> 00:12:46.040
atom fields for the product
categories names.

00:12:46.040 --> 00:12:49.120
This means that if we search on
the category field, we need

00:12:49.120 --> 00:12:52.540
to use the exact category name
string, not a substring, to

00:12:52.540 --> 00:12:54.130
get a match.

00:12:54.130 --> 00:12:56.690
So atoms fields can be
particularly useful for things

00:12:56.690 --> 00:12:59.810
like categories, where exact
matches are expected, and

00:12:59.810 --> 00:13:02.010
where we don't want to
match on substrings.

00:13:02.010 --> 00:13:04.580
And text fields can be better
for things like titles and

00:13:04.580 --> 00:13:06.690
descriptions.

00:13:06.690 --> 00:13:09.830
So, given the fields, we can
create a document object.

00:13:09.830 --> 00:13:12.920
For each product document, we'll
set its document ID to

00:13:12.920 --> 00:13:17.720
be the known, pre-defined,
unique idea of that product.

00:13:17.720 --> 00:13:20.910
And if we did not specify the
document ID, one would be

00:13:20.910 --> 00:13:25.630
auto-generated for us when we
add the document to the index.

00:13:25.630 --> 00:13:28.190
And so this is what the
code looks like.

00:13:28.190 --> 00:13:31.210
We have built the
product fields.

00:13:31.210 --> 00:13:35.680
We're creating a document object
using those fields,

00:13:35.680 --> 00:13:37.320
using that content.

00:13:37.320 --> 00:13:40.680
And in this case, because we
have unique product IDs for

00:13:40.680 --> 00:13:43.470
each of our products, we're
setting the documentary ID to

00:13:43.470 --> 00:13:46.720
be that product ID.

00:13:46.720 --> 00:13:46.980
OK.

00:13:46.980 --> 00:13:50.240
So we've looked at how to create
documents from fields

00:13:50.240 --> 00:13:51.740
that hold the document
content.

00:13:51.740 --> 00:13:54.340
And now we can add
them to an index.

00:13:54.340 --> 00:13:55.980
Let's look at how to do this.

00:13:55.980 --> 00:13:59.380
This allows the documents to be
searched using the Search

00:13:59.380 --> 00:14:03.500
API's query language
and query options.

00:14:03.500 --> 00:14:08.630
So here, again, we've created
our document.

00:14:08.630 --> 00:14:13.570
Now we're going to use the add
method of the index object

00:14:13.570 --> 00:14:16.890
here to add the document.

00:14:16.890 --> 00:14:23.200
And the results of doing the
add are an interval.

00:14:23.200 --> 00:14:25.970
In this case, we've called
it add result.

00:14:25.970 --> 00:14:30.440
And you can extract the assign
documents IDs from that

00:14:30.440 --> 00:14:34.850
interval, as we show here,
with the results return.

00:14:34.850 --> 00:14:38.820
So if you didn't assign the
documentation ID to a

00:14:38.820 --> 00:14:43.520
document, then this is how you
could obtain the document ID

00:14:43.520 --> 00:14:45.220
that was auto-generated.

00:14:45.220 --> 00:14:48.470
And if you did assign a document
ID, like we showed

00:14:48.470 --> 00:14:50.230
here, then what would
be returned would

00:14:50.230 --> 00:14:52.740
be that same ID.

00:14:52.740 --> 00:14:58.300
So when you do a document add to
an index, be sure to catch

00:14:58.300 --> 00:14:59.730
any exceptions at result.

00:14:59.730 --> 00:15:02.950
Here we're catching search dot
error, which is a general

00:15:02.950 --> 00:15:04.860
Search API exception.

00:15:04.860 --> 00:15:05.250
All right.

00:15:05.250 --> 00:15:10.580
So let's just take a quick look
again at a product detail

00:15:10.580 --> 00:15:14.060
page from the example
application.

00:15:14.060 --> 00:15:18.970
And this is showing, just for
demonstration purposes, the

00:15:18.970 --> 00:15:22.480
raw field names that we're
using for this document.

00:15:22.480 --> 00:15:25.630
And obviously, you would not
want to expose this in a real

00:15:25.630 --> 00:15:26.640
application.

00:15:26.640 --> 00:15:30.100
And so you can see that these
are all of the fields that

00:15:30.100 --> 00:15:34.610
we're using in our documents,
and you can see their content.

00:15:34.610 --> 00:15:37.590
And you can add documents one
at a time or you can add a

00:15:37.590 --> 00:15:39.910
list of documents in batch.

00:15:39.910 --> 00:15:44.240
And that is more efficient
if you add them in batch.

00:15:44.240 --> 00:15:48.870
So far, we've talked about how
to build indexes and build

00:15:48.870 --> 00:15:52.580
documents and add them
to the indexes to

00:15:52.580 --> 00:15:54.720
get queryable content.

00:15:54.720 --> 00:15:57.430
So next, Ged is going
to talk about how to

00:15:57.430 --> 00:16:00.000
search over our indexes.

00:16:00.000 --> 00:16:00.290
GED ELLIS: Hi.

00:16:00.290 --> 00:16:02.830
I'm Ged, a software engineer
working on the App Engine

00:16:02.830 --> 00:16:04.080
Search API.

00:16:04.080 --> 00:16:06.460
By adding documents to an
index, we have made the

00:16:06.460 --> 00:16:08.210
document content searchable.

00:16:08.210 --> 00:16:10.410
So now we can perform full-text
search queries over

00:16:10.410 --> 00:16:12.360
the documents in the index.

00:16:12.360 --> 00:16:14.670
There are two ways to submit
a search query.

00:16:14.670 --> 00:16:17.030
Most simply, you can pass a
query string to the index

00:16:17.030 --> 00:16:18.040
search method.

00:16:18.040 --> 00:16:20.850
Or you can create a search query
object and pass that to

00:16:20.850 --> 00:16:22.290
the search method.

00:16:22.290 --> 00:16:24.860
Construction of a query object
allows you to specify query,

00:16:24.860 --> 00:16:28.530
sort, and result presentation
options for your search.

00:16:28.530 --> 00:16:30.900
First, we'll look at how to
construct simple queries using

00:16:30.900 --> 00:16:32.220
both approaches.

00:16:32.220 --> 00:16:34.730
Then later, we'll look at how
to perform more complex

00:16:34.730 --> 00:16:37.310
queries using the
query object.

00:16:37.310 --> 00:16:39.537
A query string can be any string
that can be passed by

00:16:39.537 --> 00:16:41.520
the search API's
query language.

00:16:41.520 --> 00:16:43.740
See the search API's
documentation for a detailed

00:16:43.740 --> 00:16:45.520
description of the
query language.

00:16:45.520 --> 00:16:48.040
The query string should
be a unicode string.

00:16:48.040 --> 00:16:51.260
The example looks for products
that contain the terms

00:16:51.260 --> 00:16:54.190
"writings" and "collection."
The query string is passed

00:16:54.190 --> 00:16:56.225
into the index object
search method.

00:16:56.225 --> 00:16:57.280
It's here.

00:16:57.280 --> 00:16:59.850
And then later we'll see how to
process the search results

00:16:59.850 --> 00:17:01.110
that are returned.

00:17:01.110 --> 00:17:03.280
A search query object gives
you more control over your

00:17:03.280 --> 00:17:05.819
query options than does
just a query string.

00:17:05.819 --> 00:17:08.310
Here we first construct a
query options object.

00:17:08.310 --> 00:17:10.260
This argument specifies that
the query should return a

00:17:10.260 --> 00:17:11.890
limited number of results.

00:17:11.890 --> 00:17:14.310
Then we construct the query
object using the query string

00:17:14.310 --> 00:17:16.210
and the query options object.

00:17:16.210 --> 00:17:18.430
We then pass the query object
to the search method.

00:17:18.430 --> 00:17:20.920
Once you've submitted a query,
search results are returned to

00:17:20.920 --> 00:17:23.400
the application in a search
results object, which includes

00:17:23.400 --> 00:17:26.730
the number of results found,
the documents returned.

00:17:26.730 --> 00:17:28.230
The number of results returned
is the length

00:17:28.230 --> 00:17:29.990
of the results property.

00:17:29.990 --> 00:17:32.120
The number found property is
set to the number of hits

00:17:32.120 --> 00:17:33.150
found in the search.

00:17:33.150 --> 00:17:36.180
The returned documents are
accessed by iterating on the

00:17:36.180 --> 00:17:37.920
search results object.

00:17:37.920 --> 00:17:41.510
You can then access the
properties of the document,

00:17:41.510 --> 00:17:44.000
such as doc ID and fields.

00:17:44.000 --> 00:17:46.730
As we have discussed, you can
submit a search query using a

00:17:46.730 --> 00:17:50.330
simple string or, alternatively,
a query object.

00:17:50.330 --> 00:17:52.620
The query class constructor
takes as arguments a query

00:17:52.620 --> 00:17:54.490
string and query
options object.

00:17:54.490 --> 00:17:57.600
The query options object allows
you to configure a wide

00:17:57.600 --> 00:17:59.820
range of options to fine-tune
your search.

00:17:59.820 --> 00:18:01.290
Let's take a look at one
of the query options

00:18:01.290 --> 00:18:03.870
configurations used in the
example product search

00:18:03.870 --> 00:18:05.150
application.

00:18:05.150 --> 00:18:10.210
Here, we are setting a query
offset, a limit, and some sort

00:18:10.210 --> 00:18:15.740
options, and a list of snippeted
fields, and a list

00:18:15.740 --> 00:18:18.510
of return fields.

00:18:18.510 --> 00:18:20.930
Let's take a look at what each
of these properties do.

00:18:23.870 --> 00:18:27.130
To control the number of results
that a query returns,

00:18:27.130 --> 00:18:30.850
use the limit parameter of the
query options constructor.

00:18:30.850 --> 00:18:34.170
In the example product search
application, we used limit to

00:18:34.170 --> 00:18:36.630
return, at most, three
results per page.

00:18:36.630 --> 00:18:38.100
We also used the offset
parameter.

00:18:38.100 --> 00:18:40.400
The offset indicates the number
of matched documents to

00:18:40.400 --> 00:18:42.590
skip when returning results.

00:18:42.590 --> 00:18:46.060
The limit and offset parameters
provide support for

00:18:46.060 --> 00:18:48.330
pagination in the product
search application.

00:18:48.330 --> 00:18:50.690
To implement pagination, we
also need to know how many

00:18:50.690 --> 00:18:52.980
results were returned from
this query and how many

00:18:52.980 --> 00:18:55.560
matches were found in total.

00:18:55.560 --> 00:18:58.190
As we saw earlier, we can get
the information from the

00:18:58.190 --> 00:19:01.190
return search results object.

00:19:01.190 --> 00:19:03.490
The use of snippeted fields
allows you return an

00:19:03.490 --> 00:19:06.990
abbreviated snippet of a field
instead of its full content.

00:19:06.990 --> 00:19:10.080
And if your search query has a
match on the snippeted field,

00:19:10.080 --> 00:19:12.130
then the snippet will include
the fragment of the field in

00:19:12.130 --> 00:19:14.910
which the hit occurred and will
highlight in bold the

00:19:14.910 --> 00:19:17.060
search terms in that fragment.

00:19:17.060 --> 00:19:19.610
In the product search
application, a search query

00:19:19.610 --> 00:19:23.180
returns three hits in the
document's description fields

00:19:23.180 --> 00:19:26.320
because we requested that
description to be snippeted.

00:19:26.320 --> 00:19:28.520
The snippet expressions in the
results have "stories"

00:19:28.520 --> 00:19:30.650
highlighted.

00:19:30.650 --> 00:19:32.960
You specify the snippeting that
occurred by specifying

00:19:32.960 --> 00:19:34.310
fields to snippet.

00:19:34.310 --> 00:19:36.460
In the product search
application, we request

00:19:36.460 --> 00:19:39.080
snippeting of the description
field.

00:19:39.080 --> 00:19:42.670
Then, when you're processing
your query, you can access the

00:19:42.670 --> 00:19:44.150
generated snippets
from a return

00:19:44.150 --> 00:19:46.380
documents expressions property.

00:19:46.380 --> 00:19:50.090
The expressions property holds
a list of computed fields

00:19:50.090 --> 00:19:51.630
which are the result
of expressions

00:19:51.630 --> 00:19:53.190
requested in the query.

00:19:53.190 --> 00:19:55.000
This includes snippeted
fields.

00:19:55.000 --> 00:19:58.240
So here, we're graphing the
snippet generated for the

00:19:58.240 --> 00:20:00.300
description field of a document
returned by the

00:20:00.300 --> 00:20:02.050
search results.

00:20:02.050 --> 00:20:04.460
The returned expression property
allows you to define

00:20:04.460 --> 00:20:07.380
computed fields based on your
document fields that are

00:20:07.380 --> 00:20:08.910
returned as part of the
scored document

00:20:08.910 --> 00:20:10.590
in the search results.

00:20:10.590 --> 00:20:13.280
As a simple example, suppose
that we want to calculate

00:20:13.280 --> 00:20:15.770
prices, including sales
tax, for our products.

00:20:15.770 --> 00:20:18.290
Suppose the sales tax is 8%.

00:20:18.290 --> 00:20:21.620
We create a search field
expression with the name

00:20:21.620 --> 00:20:27.760
adjusted price, whose value
is price times 1.08.

00:20:27.760 --> 00:20:30.850
After including a returned
expressions list in our query

00:20:30.850 --> 00:20:33.580
options object, we can access
that computed field in the

00:20:33.580 --> 00:20:36.490
documents returned from the
search query via expressions

00:20:36.490 --> 00:20:40.000
property, like we did in the
generated description for

00:20:40.000 --> 00:20:42.030
field snippets.

00:20:42.030 --> 00:20:44.340
We've now looked at some ways
to define more exactly the

00:20:44.340 --> 00:20:46.110
documents to be returned
from a search.

00:20:46.110 --> 00:20:47.640
But we haven't yet
discussed how to

00:20:47.640 --> 00:20:48.720
order the query results.

00:20:48.720 --> 00:20:51.520
You can sort on a field value,
as well as expressions that

00:20:51.520 --> 00:20:53.020
include the field value.

00:20:53.020 --> 00:20:55.630
Sorts can be multidimensional,
sorting first in one field

00:20:55.630 --> 00:20:58.080
expression, then on another,
and so on.

00:20:58.080 --> 00:21:01.360
In addition, you can sort on a
score based on the documents'

00:21:01.360 --> 00:21:04.490
turn frequency by inverse
document frequency ranking.

00:21:04.490 --> 00:21:06.550
Or you can make use of that
score in a more complex

00:21:06.550 --> 00:21:08.040
ranking expression.

00:21:08.040 --> 00:21:11.110
Let's take a look at these query
sorting features now.

00:21:11.110 --> 00:21:13.020
The sort options class provides
the basis for

00:21:13.020 --> 00:21:15.040
defining query result
sort orders.

00:21:15.040 --> 00:21:17.640
A sort options object, once
defined, is used as the sort

00:21:17.640 --> 00:21:20.650
options parameter of a query
options constructor.

00:21:20.650 --> 00:21:22.710
A sort options object can be
configured in a number of

00:21:22.710 --> 00:21:23.580
different ways.

00:21:23.580 --> 00:21:25.710
Let's take a look first
at match scorer class.

00:21:25.710 --> 00:21:28.620
It is used to sort documents in
descending order, using a

00:21:28.620 --> 00:21:32.040
score based on term frequency
via document frequency.

00:21:32.040 --> 00:21:34.410
This sort is used by the example
app when the user

00:21:34.410 --> 00:21:37.880
selects relevance from the query
sort menu in the UI.

00:21:37.880 --> 00:21:41.930
To use match scoring, a match
scorer object is passed as the

00:21:41.930 --> 00:21:45.830
match scorer parameter of the
sort options constructor.

00:21:45.830 --> 00:21:48.000
You can also pass the sort
options constructor and

00:21:48.000 --> 00:21:50.525
expressions argument, which
is an iterable of

00:21:50.525 --> 00:21:52.270
sort expression objects.

00:21:52.270 --> 00:21:54.590
This lets you perform a
multidimensional sort based on

00:21:54.590 --> 00:21:56.270
the document field values.

00:21:56.270 --> 00:21:58.240
Let's take at look at how we're
using sort options in

00:21:58.240 --> 00:22:00.180
the example application.

00:22:00.180 --> 00:22:02.880
We define a sort expression
object for each product

00:22:02.880 --> 00:22:04.900
document field that we plan
to use in the UI as

00:22:04.900 --> 00:22:06.550
an available sort.

00:22:06.550 --> 00:22:09.690
For example, here are the sort
expression objects for the

00:22:09.690 --> 00:22:15.200
price, product name, and
average rating fields.

00:22:15.200 --> 00:22:17.580
For all of these definitions,
the expression parameter here

00:22:17.580 --> 00:22:20.340
is simply the field name.

00:22:20.340 --> 00:22:21.720
As we'll see shortly, the

00:22:21.720 --> 00:22:23.740
expression can be more complex.

00:22:23.740 --> 00:22:26.410
We define the sort direction
for each search field.

00:22:26.410 --> 00:22:29.750
For example, we're sorting
price and product name in

00:22:29.750 --> 00:22:31.180
ascending order.

00:22:31.180 --> 00:22:34.510
With average rating, we want to
sort in descending order.

00:22:34.510 --> 00:22:36.440
Since this is the default sort
direction, we don't need to

00:22:36.440 --> 00:22:37.790
specify it.

00:22:37.790 --> 00:22:40.470
We're also defining a default
value, which is used if a

00:22:40.470 --> 00:22:43.250
given document doesn't include
the field in the expression.

00:22:43.250 --> 00:22:46.160
For a string-based field like
product name, the default

00:22:46.160 --> 00:22:49.290
value must be a string.

00:22:49.290 --> 00:22:52.330
For numerical fields,
it must be numeric.

00:22:52.330 --> 00:22:54.890
We create a sort options object
with the expressions

00:22:54.890 --> 00:22:59.470
parameter set to its list of
these sort expressions.

00:22:59.470 --> 00:23:01.780
And as before, we pass the sort
options object to the

00:23:01.780 --> 00:23:03.950
query options constructor.

00:23:03.950 --> 00:23:05.990
The expression property and the
sort expression object can

00:23:05.990 --> 00:23:07.870
be more than just
a field name.

00:23:07.870 --> 00:23:10.210
For example, we can access the
document score in the sort

00:23:10.210 --> 00:23:11.360
expressions.

00:23:11.360 --> 00:23:15.215
This is done using the special
construct underscore score.

00:23:15.215 --> 00:23:17.960
The sort expression sorts on
the value of the average

00:23:17.960 --> 00:23:21.870
rating field plus the
document score.

00:23:21.870 --> 00:23:25.770
If you access underscore score
in a sort expression, your

00:23:25.770 --> 00:23:28.060
sort options object should
include a scorer.

00:23:28.060 --> 00:23:31.090
So here we've concluded the
match scorer object.

00:23:31.090 --> 00:23:33.430
And now my colleague Bo is going
to talk about GeoSearch

00:23:33.430 --> 00:23:36.000
and best practices using
the Search API.

00:23:36.000 --> 00:23:36.460
BO MAJEWSKI: Hi.

00:23:36.460 --> 00:23:37.395
I'm Bo.

00:23:37.395 --> 00:23:39.410
I'm a software engineer
on App Engine working

00:23:39.410 --> 00:23:40.840
on the Search API.

00:23:40.840 --> 00:23:43.290
I'll take you through
location-based search.

00:23:43.290 --> 00:23:46.000
Location queries are what allows
you to find all nearby

00:23:46.000 --> 00:23:48.716
restaurants or all nearby
[? string ?] objects.

00:23:48.716 --> 00:23:51.310
In order to execute a
location-based query, we need

00:23:51.310 --> 00:23:54.100
to have three pieces
of information.

00:23:54.100 --> 00:23:56.610
First, we need the point
from which we're

00:23:56.610 --> 00:23:58.260
measuring the distance.

00:23:58.260 --> 00:24:01.390
We also need to have some sort
of distance, such as 10

00:24:01.390 --> 00:24:03.330
kilometers or 10 miles.

00:24:03.330 --> 00:24:05.850
Both of these are usually
supplied by the user.

00:24:05.850 --> 00:24:09.840
The last piece of information is
the set of points to which

00:24:09.840 --> 00:24:11.690
the distance is being
measured.

00:24:11.690 --> 00:24:14.270
This needs to be a set of
documents, which represent

00:24:14.270 --> 00:24:15.910
some real-life objects.

00:24:15.910 --> 00:24:18.290
In our case, stores.

00:24:18.290 --> 00:24:20.850
First, let's look at the
location search in the

00:24:20.850 --> 00:24:22.390
application.

00:24:22.390 --> 00:24:26.040
We found the product, the book
Runaway, and we want to

00:24:26.040 --> 00:24:27.030
purchase it.

00:24:27.030 --> 00:24:31.240
So we initially enter 20
kilometers radius and try to

00:24:31.240 --> 00:24:33.330
look for all the stores.

00:24:33.330 --> 00:24:36.400
This finds some stores in
Mountain View, some stores in

00:24:36.400 --> 00:24:39.060
Sunnyvale and San Jose.

00:24:39.060 --> 00:24:43.800
We can widen our search,
make it 40 kilometers.

00:24:43.800 --> 00:24:45.830
This time, we find pretty
much all the

00:24:45.830 --> 00:24:48.450
stores in the Bay Area.

00:24:48.450 --> 00:24:52.660
And since it's a particularly
nice day, we might try driving

00:24:52.660 --> 00:24:55.710
even further, so now we are
looking for everything within

00:24:55.710 --> 00:24:56.940
100 kilometers.

00:24:56.940 --> 00:24:59.392
And it finds one store
in Carmel Valley.

00:25:02.230 --> 00:25:04.450
So let's look at how
to include this

00:25:04.450 --> 00:25:06.770
information in a document.

00:25:06.770 --> 00:25:09.880
Location is defined by a
GeoPoint class which stores

00:25:09.880 --> 00:25:11.110
latitude and longitude.

00:25:11.110 --> 00:25:14.190
The latitude specifies the
angular distance in degrees

00:25:14.190 --> 00:25:15.660
from the equator.

00:25:15.660 --> 00:25:18.980
And the longitude specifies the
angular distance, again,

00:25:18.980 --> 00:25:21.600
in degrees, from the
Prime Meridian.

00:25:21.600 --> 00:25:24.480
For example, the location of the
Opera House in Sydney is

00:25:24.480 --> 00:25:30.290
defined by a GeoPoint minus
33.857, which is the south,

00:25:30.290 --> 00:25:34.630
and 151.215 west.

00:25:34.630 --> 00:25:37.100
You learn that to start GeoPoint
in a document, you

00:25:37.100 --> 00:25:41.260
need to add the geo field with
the GeoPoint set at its value.

00:25:41.260 --> 00:25:43.780
Once the documents are
constructed and added to the

00:25:43.780 --> 00:25:48.390
index, we are ready to run a
search query against it.

00:25:48.390 --> 00:25:51.770
A GeoSearch query uses the
distance function, which takes

00:25:51.770 --> 00:25:55.190
the field name and
the GeoPoint.

00:25:55.190 --> 00:25:57.960
The field name is the name
of the field that you are

00:25:57.960 --> 00:25:59.140
searching on.

00:25:59.140 --> 00:26:01.940
The GeoPoint identifies
the location from

00:26:01.940 --> 00:26:04.250
which you are searching.

00:26:04.250 --> 00:26:08.280
We compare the value returned by
a distance function with a

00:26:08.280 --> 00:26:10.290
distance specified
by the users.

00:26:10.290 --> 00:26:12.500
If you were in Sydney Opera
House, say, listening to

00:26:12.500 --> 00:26:15.270
Puccini's Tosca., And
experienced a desire to locate

00:26:15.270 --> 00:26:18.350
the stores within
4.5 kilometers.

00:26:18.350 --> 00:26:21.000
You would use the
following query.

00:26:21.000 --> 00:26:24.490
You would enter distance from
store location from a GeoPoint

00:26:24.490 --> 00:26:27.140
that identifies the
Sydney Opera House

00:26:27.140 --> 00:26:28.750
is less than 4,500.

00:26:28.750 --> 00:26:32.310
And this is measured
in meters.

00:26:32.310 --> 00:26:34.440
Running the query against the
index would return all

00:26:34.440 --> 00:26:37.185
documents for which store
location field records a point

00:26:37.185 --> 00:26:42.010
that is less than 4,500 meters
away from Sydney Opera House.

00:26:42.010 --> 00:26:44.750
Getting all stores within a
given instance is nice, but

00:26:44.750 --> 00:26:47.830
what would be even better is if
we could sort them by how

00:26:47.830 --> 00:26:49.740
far we need to walk or drive.

00:26:49.740 --> 00:26:52.040
This can be done by adding
a sort expression.

00:26:52.040 --> 00:26:54.760
Again, assume that the user is
browsing store location from

00:26:54.760 --> 00:26:56.090
Sydney Opera House.

00:26:56.090 --> 00:26:59.800
The query that finds the stores
within 4.5 kilometers

00:26:59.800 --> 00:27:02.770
and sorts them by a distance
from a user

00:27:02.770 --> 00:27:04.250
would look as follows.

00:27:04.250 --> 00:27:07.470
The query string remains the
same-- distance from a store

00:27:07.470 --> 00:27:11.190
location to a GeoPoint
is less than 4,500.

00:27:11.190 --> 00:27:16.160
What we add is the sorting
expression, which asks to sort

00:27:16.160 --> 00:27:19.130
by distance, again, from
the same point

00:27:19.130 --> 00:27:21.120
based on store location.

00:27:21.120 --> 00:27:25.370
We sort in ascending order,
which guarantees that the

00:27:25.370 --> 00:27:28.660
stores that are closest to
us are returned first.

00:27:28.660 --> 00:27:30.780
This concludes our quick
overview of the

00:27:30.780 --> 00:27:33.180
location-based searches.

00:27:33.180 --> 00:27:37.020
Let me talk about some best
practices for Search API.

00:27:37.020 --> 00:27:40.360
We did not provide a separate
update document operation.

00:27:40.360 --> 00:27:44.470
The semantic of an index is such
that adding a document

00:27:44.470 --> 00:27:47.240
with an existing ID
simply updates it.

00:27:47.240 --> 00:27:49.150
But it also means that you
should manage your own

00:27:49.150 --> 00:27:52.380
document IDs if you plan
updating documents.

00:27:52.380 --> 00:27:55.860
Managing your own IDs is also a
good idea if your documents

00:27:55.860 --> 00:27:57.670
represent some external
objects.

00:27:57.670 --> 00:27:59.440
For example, if you have a
document that is a searchable

00:27:59.440 --> 00:28:00.750
representation of [INAUDIBLE]

00:28:00.750 --> 00:28:04.030
entity, you could set the ID
to the key of the entity.

00:28:04.030 --> 00:28:07.330
When you search, you can ask for
the index to only return

00:28:07.330 --> 00:28:10.850
document IDs, and then convert
them back to the entity keys

00:28:10.850 --> 00:28:13.770
and retrieve all matching
entities.

00:28:13.770 --> 00:28:17.110
With regard to index name, it is
more efficient to have one

00:28:17.110 --> 00:28:20.820
index per user than one large
index and store owner

00:28:20.820 --> 00:28:23.210
attribute with each document.

00:28:23.210 --> 00:28:25.600
The only time you could consider
having one large

00:28:25.600 --> 00:28:29.380
index is when you need to find
all documents regardless of

00:28:29.380 --> 00:28:31.670
which user owns it.

00:28:31.670 --> 00:28:33.990
Each document has a
rank attribute.

00:28:33.990 --> 00:28:37.250
If not set, it is assigned
a time the document was

00:28:37.250 --> 00:28:38.860
added to the index.

00:28:38.860 --> 00:28:41.450
The documents are presorted on
rank, both in ascending and

00:28:41.450 --> 00:28:42.600
descending order.

00:28:42.600 --> 00:28:45.450
If you do not specify the
sorting criteria, it will

00:28:45.450 --> 00:28:49.030
simply return documents in
descending order of the rank.

00:28:49.030 --> 00:28:52.510
This is the result of having the
freshest documents first.

00:28:52.510 --> 00:28:56.120
If you have one simple order,
say rating, in which documents

00:28:56.120 --> 00:28:58.090
should always be returned,
you should

00:28:58.090 --> 00:29:00.310
assign rank value yourself.

00:29:00.310 --> 00:29:03.100
This significantly speeds
up your search queries.

00:29:03.100 --> 00:29:05.550
If you plan to insert or delete
a large number of

00:29:05.550 --> 00:29:07.820
documents, please use
a task queue.

00:29:07.820 --> 00:29:11.750
This allows you to control the
rate of insertion and to retry

00:29:11.750 --> 00:29:14.830
some documents that did not
index due to transient errors.

00:29:14.830 --> 00:29:17.630
Atom fields is our version
of enum values.

00:29:17.630 --> 00:29:20.340
Atom fields must be shorter
than 500 characters.

00:29:20.340 --> 00:29:21.970
However, they are
not tokenized.

00:29:21.970 --> 00:29:25.690
As a result, atomfield full
space bar is not the same as

00:29:25.690 --> 00:29:28.010
atomfield full comma bar.

00:29:28.010 --> 00:29:30.530
You can even use them to do
your own tokenization by

00:29:30.530 --> 00:29:33.010
inserting repeated
atom fields.

00:29:33.010 --> 00:29:36.740
However, please remember that
this comes with a price.

00:29:36.740 --> 00:29:39.580
And now off to Christina for
some closing remarks.

00:29:39.580 --> 00:29:40.460
CHRISTINA ILVENTO: So
that about sums

00:29:40.460 --> 00:29:41.440
it up for our webinar.

00:29:41.440 --> 00:29:42.700
Thanks for watching.

00:29:42.700 --> 00:29:45.320
To learn more about the App
Engine Search API, check out

00:29:45.320 --> 00:29:48.310
our documentation and sample
application and ask any

00:29:48.310 --> 00:29:51.650
questions on Stack Overflow with
the Google dash app dash

00:29:51.650 --> 00:29:52.390
engine tag.

00:29:52.390 --> 00:29:53.640
Happy coding.

