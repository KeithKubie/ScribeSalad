WEBVTT
Kind: captions
Language: en

00:00:03.820 --> 00:00:05.940
JUSTIN UBERTI: So what you all
think of the Google Glass

00:00:05.940 --> 00:00:07.247
Hangout this morning?

00:00:07.247 --> 00:00:10.110
[AUDIENCE CHEERING]

00:00:10.110 --> 00:00:13.260
JUSTIN UBERTI: What an amazing
way to show off the power of

00:00:13.260 --> 00:00:14.705
real-time communication.

00:00:14.705 --> 00:00:16.570
When I first heard about it,
they're going to jump out of

00:00:16.570 --> 00:00:19.260
an airship and have it all in a
Hangout, I was like, that's

00:00:19.260 --> 00:00:19.990
pretty incredible.

00:00:19.990 --> 00:00:21.800
But anyway, I'm Justin Uberti.

00:00:21.800 --> 00:00:25.420
And today, I'd like to tell
you all about WebRTC, a

00:00:25.420 --> 00:00:27.530
project to bring real-time
communication--

00:00:27.530 --> 00:00:29.100
RTC--

00:00:29.100 --> 00:00:30.350
to the open web platform.

00:00:33.080 --> 00:00:37.240
So I currently work on the
WebRTC team here at Google,

00:00:37.240 --> 00:00:39.410
which is part of the
Chrome project.

00:00:39.410 --> 00:00:43.020
Before joining WebRTC, I was
the lead in the Google Talk

00:00:43.020 --> 00:00:45.480
team, where we built some really
exciting applications,

00:00:45.480 --> 00:00:48.500
and also learned a lot of really
hard lessons about what

00:00:48.500 --> 00:00:52.490
it takes to do these kinds
of apps in a browser.

00:00:52.490 --> 00:00:54.450
I also kind of learned that some
people on the internet

00:00:54.450 --> 00:00:56.710
think I have really
small hands.

00:00:56.710 --> 00:00:57.960
I don't get it.

00:01:00.720 --> 00:01:02.670
So enough about me.

00:01:02.670 --> 00:01:04.180
Let me see what kind of
developers we have in the

00:01:04.180 --> 00:01:05.580
audience today.

00:01:05.580 --> 00:01:07.160
Raise your hand if you're
really familiar with the

00:01:07.160 --> 00:01:08.410
following technologies.

00:01:10.490 --> 00:01:12.884
WebRTC?

00:01:12.884 --> 00:01:14.800
OK.

00:01:14.800 --> 00:01:17.090
HTML5?

00:01:17.090 --> 00:01:18.310
Good.

00:01:18.310 --> 00:01:19.560
WebSockets?

00:01:21.530 --> 00:01:24.450
App Engine?

00:01:24.450 --> 00:01:25.608
SIP?

00:01:25.608 --> 00:01:27.700
OK.

00:01:27.700 --> 00:01:29.580
H 323?

00:01:29.580 --> 00:01:30.140
OK.

00:01:30.140 --> 00:01:32.070
You folks who raised your
hands, you have my

00:01:32.070 --> 00:01:33.320
condolences.

00:01:40.170 --> 00:01:43.310
So what exactly is WebRTC?

00:01:43.310 --> 00:01:46.930
Well, let me tell you
a little story.

00:01:46.930 --> 00:01:48.790
A couple years ago, when we
are working on what would

00:01:48.790 --> 00:01:51.990
become Hangouts, the Chrome
team approached us.

00:01:51.990 --> 00:01:55.000
And they said, the open web
platform has some amazing

00:01:55.000 --> 00:01:56.460
technology.

00:01:56.460 --> 00:01:58.490
And people are building
incredible apps with it.

00:01:58.490 --> 00:02:01.030
But there's one big
gap remaining.

00:02:01.030 --> 00:02:04.220
To build apps like Google Video
Chat, you need plugins.

00:02:04.220 --> 00:02:07.160
And these plugins have all sorts
of problems, security,

00:02:07.160 --> 00:02:08.590
everything.

00:02:08.590 --> 00:02:11.500
What would it take to take the
stuff you built for Google

00:02:11.500 --> 00:02:13.620
Video Chat and Hangouts,
and make it part of

00:02:13.620 --> 00:02:16.410
the open web platform?

00:02:16.410 --> 00:02:19.440
Well, we said, it would
be really complicated.

00:02:19.440 --> 00:02:21.110
I mean, we'd have all
these technology

00:02:21.110 --> 00:02:22.250
issues to figure out.

00:02:22.250 --> 00:02:23.710
And we'd have to deal
with like codec

00:02:23.710 --> 00:02:25.870
licensing, and open sourcing.

00:02:25.870 --> 00:02:28.700
And most of all, we'd have to
work with other browser

00:02:28.700 --> 00:02:31.470
manufacturers and other industry
players to make an

00:02:31.470 --> 00:02:34.740
actual standard for something
that can be implemented across

00:02:34.740 --> 00:02:37.760
all browsers and across
the entire web.

00:02:37.760 --> 00:02:40.710
And so in typical Google
fashion, the response we got

00:02:40.710 --> 00:02:44.000
back was, sounds like a plan.

00:02:44.000 --> 00:02:46.090
When can we have it?

00:02:46.090 --> 00:02:48.110
So we got to work.

00:02:48.110 --> 00:02:51.290
Where we didn't have the right
technology pieces in house, we

00:02:51.290 --> 00:02:54.690
went out and we acquired state
of the art, the very best

00:02:54.690 --> 00:02:56.490
technology out there.

00:02:56.490 --> 00:02:59.030
We assembled these pieces
into a system.

00:02:59.030 --> 00:03:01.500
And as we started talking to
other people, and we talked to

00:03:01.500 --> 00:03:07.220
other browser manufacturers,
Firefox, Opera, Microsoft.

00:03:07.220 --> 00:03:10.150
We talked to people who would
build apps on this platform,

00:03:10.150 --> 00:03:12.360
people like Skype, people
like Cisco.

00:03:12.360 --> 00:03:16.220
And we talked to the typical
telecom providers, folks like

00:03:16.220 --> 00:03:18.800
Ericsson, AT&amp;T.

00:03:18.800 --> 00:03:22.590
They were all super excited
about this because it's

00:03:22.590 --> 00:03:26.040
potential, not just for the
web, but for the entire

00:03:26.040 --> 00:03:28.400
communications industry.

00:03:28.400 --> 00:03:31.700
So that's the premise of WebRTC,
RTC to build real-time

00:03:31.700 --> 00:03:34.720
communications into the fabric
of the web, where every

00:03:34.720 --> 00:03:37.300
browser has a built in, state
of the art communication

00:03:37.300 --> 00:03:42.460
stack, and create a new open
platform that any application

00:03:42.460 --> 00:03:44.160
and any device can use
to communicate.

00:03:47.130 --> 00:03:48.760
So think about that.

00:03:48.760 --> 00:03:51.830
This is where we're having,
the ability to get the

00:03:51.830 --> 00:03:53.320
communications industry--

00:03:53.320 --> 00:03:55.840
a $2 trillion industry--

00:03:55.840 --> 00:03:58.080
moving at web speed.

00:03:58.080 --> 00:04:00.280
And not only will the developers
be able to build

00:04:00.280 --> 00:04:03.310
and deploy voice and video apps,
just like any other web

00:04:03.310 --> 00:04:06.340
app, but we'll also start to see
communication being built

00:04:06.340 --> 00:04:08.970
in as a feature to all
sorts of apps.

00:04:08.970 --> 00:04:12.575
In a game, the ability to see
the opponent's face right as

00:04:12.575 --> 00:04:14.320
you checkmate them.

00:04:14.320 --> 00:04:17.630
Or in customer service on a
website, a shopping website,

00:04:17.630 --> 00:04:20.980
to be able to talk to a customer
service rep live in

00:04:20.980 --> 00:04:24.620
person with a single click.

00:04:24.620 --> 00:04:28.220
As WebRTC takes hold across
computers and all sorts of

00:04:28.220 --> 00:04:32.170
devices, we have the real
ability to create the next

00:04:32.170 --> 00:04:35.270
generation phone network, where
every WebRTC enabled

00:04:35.270 --> 00:04:37.630
device can communicate
with amazing

00:04:37.630 --> 00:04:38.880
audio and video quality.

00:04:41.800 --> 00:04:43.930
So take this quote
from NoJitter.

00:04:43.930 --> 00:04:47.045
This is a communications
industry blog.

00:04:47.045 --> 00:04:52.370
"WebRTC and HTML5 could enable
the same transformation for

00:04:52.370 --> 00:04:57.310
real time that the original
browser did for information."

00:04:57.310 --> 00:04:59.930
That's a pretty lofty
comparison.

00:04:59.930 --> 00:05:02.110
So how do we get there?

00:05:02.110 --> 00:05:05.170
Well first, we need to get
WebRTC in the hands of you,

00:05:05.170 --> 00:05:06.530
the developers.

00:05:06.530 --> 00:05:08.530
And here's where we're
at with that.

00:05:08.530 --> 00:05:12.940
The first WebRTC support is now
shipping in Chrome 21, the

00:05:12.940 --> 00:05:14.620
current Chrome Dev track.

00:05:14.620 --> 00:05:16.390
And also in Opera 12.

00:05:16.390 --> 00:05:18.970
We're expecting to have Firefox
join us before the end

00:05:18.970 --> 00:05:20.520
of the year.

00:05:20.520 --> 00:05:24.240
We've also brought WebRTC
support to Internet Explorer

00:05:24.240 --> 00:05:25.650
via ChromeFrame.

00:05:25.650 --> 00:05:28.470
And so we'll soon have
support across

00:05:28.470 --> 00:05:31.780
almost all desktop browsers.

00:05:31.780 --> 00:05:34.130
As this technology stabilizes,
we're also going to see web

00:05:34.130 --> 00:05:37.480
WebRTC start to appear in the
various mobile browsers.

00:05:37.480 --> 00:05:41.790
And for those building native
applications, either on

00:05:41.790 --> 00:05:45.030
desktop or mobile, we have
native versions of the WebRTC

00:05:45.030 --> 00:05:47.110
stack that are fully compatible
with their web

00:05:47.110 --> 00:05:48.360
counterparts.

00:05:50.280 --> 00:05:53.270
So the functionality the WebRTC
offers falls into three

00:05:53.270 --> 00:05:55.180
categories.

00:05:55.180 --> 00:05:59.840
The first, MediaStreams, also
known as get user media, is

00:05:59.840 --> 00:06:02.450
about getting access to the
user's camera and mic.

00:06:02.450 --> 00:06:03.800
There are a lot of cool
apps that can be

00:06:03.800 --> 00:06:06.190
built with just this.

00:06:06.190 --> 00:06:08.970
Next the technology called
PeerConnection.

00:06:08.970 --> 00:06:11.830
This is the engine behind making
high quality peer to

00:06:11.830 --> 00:06:15.850
peer voice and video
calls on the web.

00:06:15.850 --> 00:06:17.280
Last is a new bit of
functionality called

00:06:17.280 --> 00:06:18.160
DataChannels.

00:06:18.160 --> 00:06:21.630
It's so new, the spec for this
hasn't fully stabilized yet.

00:06:21.630 --> 00:06:23.480
But it has incredible
potential.

00:06:23.480 --> 00:06:28.670
The ability for any web app to
be a P2P app, to exchange

00:06:28.670 --> 00:06:31.620
application data peer to peer.

00:06:31.620 --> 00:06:36.045
Now let's take a look at
each one of these.

00:06:36.045 --> 00:06:39.040
Now, if you're following along
at home, and you want to try

00:06:39.040 --> 00:06:41.600
out the things about the show,
and you're running Chrome, you

00:06:41.600 --> 00:06:43.860
want to turn on the flags to
enable MediaStreams and

00:06:43.860 --> 00:06:45.470
PeerConnection.

00:06:45.470 --> 00:06:50.430
If you go to About Flags in your
Chrome build, you'll see

00:06:50.430 --> 00:06:51.905
these options in a list.

00:06:51.905 --> 00:06:54.330
And you turn on MediaStream
and PeerConnection.

00:06:54.330 --> 00:06:57.510
In the Dev channel on Chrome
21, you won't see a

00:06:57.510 --> 00:07:00.800
MediaStream option, because
it's now on by default.

00:07:00.800 --> 00:07:02.420
And if you don't want to turn
this on for your existing

00:07:02.420 --> 00:07:05.850
version of Chrome, you can
download Google Chrome Canary

00:07:05.850 --> 00:07:07.810
and run it side by
side with your

00:07:07.810 --> 00:07:09.060
existing version of Chrome.

00:07:11.452 --> 00:07:13.420
So first up, MediaStreams.

00:07:17.170 --> 00:07:20.500
A MediaStream represents a media
source, and can contain

00:07:20.500 --> 00:07:24.130
multiple media tracks that
can be of various types.

00:07:24.130 --> 00:07:27.370
So for example, if we get a
MediaStream for the user's

00:07:27.370 --> 00:07:30.890
webcam and mic, we'll have a
single stream, but a track for

00:07:30.890 --> 00:07:35.020
video, and a track for audio, as
shown in the diagram here.

00:07:35.020 --> 00:07:37.540
Now, in a video conference,
we could have multiple

00:07:37.540 --> 00:07:39.200
MediaStreams.

00:07:39.200 --> 00:07:42.280
And one MediaStream would exist
for each participant,

00:07:42.280 --> 00:07:45.680
each one with an audio
and video track.

00:07:45.680 --> 00:07:48.270
Now, once we have a MediaStream
we need a way to

00:07:48.270 --> 00:07:49.520
actually play it out.

00:07:49.520 --> 00:07:52.390
And fortunately, we have an
easy way to play audio and

00:07:52.390 --> 00:07:54.930
video in HTML via
the aptly named,

00:07:54.930 --> 00:07:57.070
audio and video elements.

00:07:57.070 --> 00:07:59.470
Now, in order to plug a
MediaStream into these

00:07:59.470 --> 00:08:03.050
elements, we first need a way
to get a URL that references

00:08:03.050 --> 00:08:04.200
the MediaStream.

00:08:04.200 --> 00:08:07.700
Fortunately, there's a method
called create object URL that

00:08:07.700 --> 00:08:09.500
does just that.

00:08:09.500 --> 00:08:13.370
Plug that URL into a tag, and
then media will start to play.

00:08:13.370 --> 00:08:15.910
Now lastly, how do we get
the MediaStream for

00:08:15.910 --> 00:08:16.910
the webcam and mic?

00:08:16.910 --> 00:08:20.620
So there's a new API called
getUserMedia.

00:08:20.620 --> 00:08:23.770
In Chrome, it's prefixed
as WebKit getUserMedia.

00:08:23.770 --> 00:08:25.420
And the API is async.

00:08:25.420 --> 00:08:28.740
So you call it, it prompts the
user for permission to access

00:08:28.740 --> 00:08:29.270
their devices.

00:08:29.270 --> 00:08:30.740
We spend a lot of time worrying

00:08:30.740 --> 00:08:32.409
about privacy and security.

00:08:32.409 --> 00:08:35.630
And that gives you back a
MediaStream via callback once

00:08:35.630 --> 00:08:36.880
it's successful.

00:08:39.240 --> 00:08:42.230
So here's that all
put together.

00:08:42.230 --> 00:08:47.595
Get user media, get a callback,
create URL, stuff it

00:08:47.595 --> 00:08:49.500
in a video tag.

00:08:49.500 --> 00:08:50.750
So let's see that in action.

00:08:55.030 --> 00:08:57.310
So here we get prompted
for our camera.

00:08:57.310 --> 00:09:00.160
I'll pick my good camera
right here.

00:09:00.160 --> 00:09:04.140
And there it is.

00:09:04.140 --> 00:09:06.570
Webcam access right
in the browser.

00:09:06.570 --> 00:09:07.820
Pretty cool.

00:09:11.610 --> 00:09:16.980
So now let's jazz it
up a little bit.

00:09:16.980 --> 00:09:18.900
So the first thing that
everybody does with

00:09:18.900 --> 00:09:21.640
getUserMedia is to make
a Photo Booth app.

00:09:21.640 --> 00:09:24.060
And we're not going to
be any exception.

00:09:24.060 --> 00:09:26.820
So let's add a button so that we
can draw the current video

00:09:26.820 --> 00:09:30.330
frame directly onto a campus,
just like a camera.

00:09:30.330 --> 00:09:32.980
So let's try that out.

00:09:32.980 --> 00:09:35.030
So here's our next sample.

00:09:35.030 --> 00:09:35.520
Get prompted.

00:09:35.520 --> 00:09:37.550
This time I'm going to tell it
to remember it, so I don't

00:09:37.550 --> 00:09:38.800
want you to do this again.

00:09:41.860 --> 00:09:47.240
OK, and so give a big thumbs
up for the camera here.

00:09:47.240 --> 00:09:48.690
And there's our Photo Booth.

00:09:54.920 --> 00:09:57.610
So of course, all good Photo
Booths need some

00:09:57.610 --> 00:09:59.320
sort of video effects.

00:09:59.320 --> 00:10:02.180
The web platform gives us some
great tools to do this.

00:10:02.180 --> 00:10:06.170
With CSS, we can apply a style
to any visual element, like a

00:10:06.170 --> 00:10:08.500
video tag or a canvas.

00:10:08.500 --> 00:10:11.950
So here, we can apply a black
and white effect, this built

00:10:11.950 --> 00:10:14.660
in webkit gray scale CSS.

00:10:14.660 --> 00:10:16.840
And so when the button is
clicked, we're going to apply

00:10:16.840 --> 00:10:20.430
that CSS class to the
video element.

00:10:20.430 --> 00:10:21.870
So I've made a demo.

00:10:21.870 --> 00:10:23.620
And I've got a couple more
effects in here.

00:10:23.620 --> 00:10:25.160
So let me show them
to you now.

00:10:27.740 --> 00:10:28.370
So I start up.

00:10:28.370 --> 00:10:31.370
And since I've remembered the
preference, it doesn't need to

00:10:31.370 --> 00:10:32.510
prompt me again.

00:10:32.510 --> 00:10:35.320
So let me try, we got
sepia tone here.

00:10:35.320 --> 00:10:37.925
And let's see, there's blur.

00:10:37.925 --> 00:10:38.910
And there's black and white.

00:10:38.910 --> 00:10:40.765
And I like black and white,
it looks real serious.

00:10:43.380 --> 00:10:45.660
So there's a lot of cool
stuff you can do

00:10:45.660 --> 00:10:46.910
just with these things.

00:10:49.290 --> 00:10:53.760
Now, that's what you can do
with a few lines of code.

00:10:53.760 --> 00:10:56.800
But I want to show you now
a complete Photo Booth

00:10:56.800 --> 00:10:58.670
application that uses
this technology.

00:10:58.670 --> 00:11:00.940
And the app I'm about to show
you is called Webcam Toy.

00:11:00.940 --> 00:11:05.000
And it's written by a guy named
Paul Neave, who got

00:11:05.000 --> 00:11:08.200
involved with WebRTC in the
very, very beginning.

00:11:08.200 --> 00:11:12.400
And so this thing uses Canvas
and WebGL pixel shaders to do

00:11:12.400 --> 00:11:13.540
some really amazing effects.

00:11:13.540 --> 00:11:16.030
There's over 100 effects
in this app.

00:11:16.030 --> 00:11:17.480
So there's some really
cool ones.

00:11:17.480 --> 00:11:18.720
Like, let me show you.

00:11:18.720 --> 00:11:19.940
This one's one of my
favorites here.

00:11:19.940 --> 00:11:23.450
Snow, it comes down and it sort
of builds up and stuff.

00:11:23.450 --> 00:11:25.510
And you can kind of clear
it off and stuff.

00:11:25.510 --> 00:11:26.510
It's really cool.

00:11:26.510 --> 00:11:29.000
And let's see, what else?

00:11:29.000 --> 00:11:32.140
The sketch one, this is also
one of my favorites.

00:11:32.140 --> 00:11:35.090
But what I really want to do is
I'm going to take a picture

00:11:35.090 --> 00:11:37.640
this room so I can remember
this moment here.

00:11:37.640 --> 00:11:39.890
All right, what's
a good effect?

00:11:39.890 --> 00:11:41.140
I like this one.

00:11:46.002 --> 00:11:48.970
[CAMERA SHUTTER SOUND]

00:11:48.970 --> 00:11:53.010
JUSTIN UBERTI: All right,
immortalized forever.

00:11:53.010 --> 00:11:56.700
OK, so one other thing that Paul
has done, though, is he's

00:11:56.700 --> 00:12:00.330
wired getUserMedia to do
real-time face recognition in

00:12:00.330 --> 00:12:01.580
JavaScript.

00:12:10.500 --> 00:12:13.660
So here we have real-time face
detection running in

00:12:13.660 --> 00:12:14.610
JavaScript.

00:12:14.610 --> 00:12:17.760
Now, I never thought I would
be saying those words.

00:12:17.760 --> 00:12:21.530
But here it is, as long as
I look at the camera.

00:12:21.530 --> 00:12:23.730
So this kind of gives
a new meaning to

00:12:23.730 --> 00:12:26.320
Chrome's incognito mode.

00:12:26.320 --> 00:12:29.670
So as you can see, some amazing
things are possible

00:12:29.670 --> 00:12:32.170
when we combine WebRTC with the
rest of the web platform.

00:12:39.390 --> 00:12:43.230
OK, so that's how we get
access to devices.

00:12:43.230 --> 00:12:45.290
Now PeerConnection Connection
will let us take those

00:12:45.290 --> 00:12:47.310
MediaStreams and send
them across the

00:12:47.310 --> 00:12:49.140
internet peer to peer.

00:12:51.860 --> 00:12:56.643
So PeerConnection, as its name
indicates, is the API they use

00:12:56.643 --> 00:12:58.440
to set up peer to
peer sessions.

00:12:58.440 --> 00:13:01.270
And it handles all the tricky
parts you need to establish a

00:13:01.270 --> 00:13:05.390
connection and run audio/video
over it, establishing the P2P

00:13:05.390 --> 00:13:08.820
link, managing the various
audio and video codecs,

00:13:08.820 --> 00:13:11.080
encryption, tuning the
audio/video stream to make

00:13:11.080 --> 00:13:14.570
best use of the available
bandwidth.

00:13:14.570 --> 00:13:17.740
But before we get into how
PeerConnection works, let's

00:13:17.740 --> 00:13:20.830
take a look at a typical voice
video application.

00:13:20.830 --> 00:13:23.350
I have Google Talk, let's
set up a call.

00:13:23.350 --> 00:13:27.040
So the app wants to be able to
send the media directly to the

00:13:27.040 --> 00:13:27.640
other side.

00:13:27.640 --> 00:13:30.090
But in order to do so, it needs
to establish the direct

00:13:30.090 --> 00:13:32.720
link and the details of how
the media should be sent.

00:13:32.720 --> 00:13:35.500
And the way it does that is sort
of by randevuing through

00:13:35.500 --> 00:13:39.560
the cloud by sending signaling
messages over its connection

00:13:39.560 --> 00:13:42.720
using a protocol like
XMPP or SIP.

00:13:42.720 --> 00:13:45.140
And these messages are relayed
to the other side.

00:13:45.140 --> 00:13:47.890
This exchange of parameters
allows both sides to

00:13:47.890 --> 00:13:52.690
successfully randevu and
establish the call.

00:13:52.690 --> 00:13:55.810
Now, what we could have just
taken that logic and stuffed

00:13:55.810 --> 00:13:56.910
it into the browser.

00:13:56.910 --> 00:13:58.895
The app would just tell the
browser where to connect to

00:13:58.895 --> 00:14:01.930
and to establish a SIP or XMPP
connection, just like a

00:14:01.930 --> 00:14:03.430
desktop app.

00:14:03.430 --> 00:14:07.290
But this isn't my makes sense
for a couple reasons.

00:14:07.290 --> 00:14:08.740
The app already has
a connection to

00:14:08.740 --> 00:14:11.266
the cloud using HTTP.

00:14:11.266 --> 00:14:14.010
And if we bake the signaling
protocol into the browser,

00:14:14.010 --> 00:14:17.010
we'd have to pick one that
everybody could agree on.

00:14:17.010 --> 00:14:19.010
That doesn't seem too likely,
given the various apps that

00:14:19.010 --> 00:14:20.560
are out there.

00:14:20.560 --> 00:14:22.790
And lastly, this connection
would have to deal with all

00:14:22.790 --> 00:14:27.640
the proxy and Firewall issues
that HTTP has already solved.

00:14:27.640 --> 00:14:29.000
So we didn't do this.

00:14:29.000 --> 00:14:30.780
What did we do?

00:14:30.780 --> 00:14:33.040
So we have an approach
that's called JSEP--

00:14:33.040 --> 00:14:36.050
JavaScript Session Establishment
Protocol.

00:14:36.050 --> 00:14:38.280
And we thought, let's
put the minimum we

00:14:38.280 --> 00:14:39.620
need into the browser.

00:14:39.620 --> 00:14:42.620
In 2012, that's peer to peer
networking, codecs, and

00:14:42.620 --> 00:14:43.450
encryption.

00:14:43.450 --> 00:14:44.870
And let the app do
all the rest.

00:14:44.870 --> 00:14:47.160
The app can manage all the call
setup, using whatever

00:14:47.160 --> 00:14:49.000
mechanism it wants.

00:14:49.000 --> 00:14:51.450
The app will simply tell the
browser about the parameters

00:14:51.450 --> 00:14:54.440
it wants to use for the call
using things we call session

00:14:54.440 --> 00:14:56.370
descriptions.

00:14:56.370 --> 00:14:58.910
As long as the app has some
way to exchange session

00:14:58.910 --> 00:15:01.980
descriptions with the other
side, it can do this any way

00:15:01.980 --> 00:15:03.230
that it wants to.

00:15:05.560 --> 00:15:11.500
So for example, we could use
App Engine and use XML HTTP

00:15:11.500 --> 00:15:14.675
Request to post the session
descriptions using an adjacent

00:15:14.675 --> 00:15:16.260
encoding to App Engine.

00:15:16.260 --> 00:15:18.940
And have App Engine deliver them
to the remote side using

00:15:18.940 --> 00:15:22.670
the App Engine channel API.

00:15:22.670 --> 00:15:25.850
Or we could actually implement
the SIP protocol in

00:15:25.850 --> 00:15:28.800
JavaScript, convert the session
descriptions to SIP

00:15:28.800 --> 00:15:31.180
messages and send them
to existing SIP

00:15:31.180 --> 00:15:32.460
equipment out there.

00:15:32.460 --> 00:15:34.730
And so there's a ton of existing
SIP equipment, the

00:15:34.730 --> 00:15:37.200
phone network, soft switches,
existing enterprise video

00:15:37.200 --> 00:15:38.310
conferencing equipment.

00:15:38.310 --> 00:15:42.760
And people are already using
this today to have SIP Interop

00:15:42.760 --> 00:15:46.110
with WebRTC without forcing
WebRTC to have SIP built in.

00:15:48.680 --> 00:15:52.160
So the abstract PeerConnection
API allows us to handle either

00:15:52.160 --> 00:15:54.570
of these cases, along with a
whole set of others that I

00:15:54.570 --> 00:15:56.100
haven't mentioned.

00:15:56.100 --> 00:15:59.740
Now, the basic thing that a
PeerConnection needs is in

00:15:59.740 --> 00:16:02.720
local session description,
which holds the local

00:16:02.720 --> 00:16:05.910
parameters for the call in the
remote session description,

00:16:05.910 --> 00:16:08.030
which indicates the
remote parameters.

00:16:08.030 --> 00:16:12.110
It also needs the transport
candidates, which are the IP

00:16:12.110 --> 00:16:15.420
addresses and ports that the
remote side is reachable at.

00:16:15.420 --> 00:16:17.070
Sometimes these are included
within the session

00:16:17.070 --> 00:16:18.950
description.

00:16:18.950 --> 00:16:21.790
Now, I'm going to walk through
a call setup, and show how

00:16:21.790 --> 00:16:23.760
these parameters
are exchanged.

00:16:23.760 --> 00:16:27.890
One thing to note, the initial
parameters sent by the caller

00:16:27.890 --> 00:16:30.760
specify everything that a
caller is capable of.

00:16:30.760 --> 00:16:32.730
And we call that an offer.

00:16:32.730 --> 00:16:36.180
The response from the callee,
which indicates the negotiated

00:16:36.180 --> 00:16:38.500
or selected parameters,
is called an answer.

00:16:49.990 --> 00:16:51.540
So here's the first thing.

00:16:51.540 --> 00:16:54.380
The app creates the local
session description, the

00:16:54.380 --> 00:16:58.680
offer, passes into the
PeerConnection API, and sends

00:16:58.680 --> 00:17:03.390
it to the remote side using
whatever mechanism it wants.

00:17:03.390 --> 00:17:07.000
The caller gets it and gives it
to the PeerConnection API

00:17:07.000 --> 00:17:09.869
as the remote description.

00:17:09.869 --> 00:17:13.119
Then, assuming that the callee
accepts the call, generates

00:17:13.119 --> 00:17:16.319
their own session description,
passes it into PeerConnection,

00:17:16.319 --> 00:17:19.569
and sends it back to the
caller as an answer.

00:17:19.569 --> 00:17:23.050
The caller gets that answer and
gives it to PeerConnection

00:17:23.050 --> 00:17:24.300
as a receive session
description.

00:17:26.900 --> 00:17:29.050
Now, at this point, the browser
has everything it

00:17:29.050 --> 00:17:31.960
needs to establish the call, the
local session description,

00:17:31.960 --> 00:17:33.880
the remote session description,
the transport

00:17:33.880 --> 00:17:39.320
candidates, the P2P link gets
established, and media flows.

00:17:39.320 --> 00:17:42.750
So let's look at what this
looks like in code.

00:17:42.750 --> 00:17:45.950
The caller creates a
PeerConnection, plugs a

00:17:45.950 --> 00:17:50.000
MediaStream into it, which it
got from the getUserMedia API

00:17:50.000 --> 00:17:51.490
via add stream.

00:17:51.490 --> 00:17:54.770
It then creates an offer, plugs
it in, and sends it off

00:17:54.770 --> 00:17:56.620
to the callee.

00:17:56.620 --> 00:17:59.880
When the callee gets it, over
here on the right, it creates

00:17:59.880 --> 00:18:02.860
a PeerConnection, stuffs in
the offer via set remote

00:18:02.860 --> 00:18:05.660
description, and then creates
its own session description as

00:18:05.660 --> 00:18:10.230
an answer that it can send
back to the caller.

00:18:10.230 --> 00:18:13.110
The caller then gets its answer
on the left, sets call

00:18:13.110 --> 00:18:15.670
set remote description with the
received answer, and the

00:18:15.670 --> 00:18:16.920
set up is complete.

00:18:20.700 --> 00:18:23.290
So let's see how this
looks like in code.

00:18:23.290 --> 00:18:25.690
We're going to do the
offer/answer dance here in a

00:18:25.690 --> 00:18:28.230
single web page with two
PeerConnections.

00:18:28.230 --> 00:18:31.060
Instead of sending these
messages across the internet,

00:18:31.060 --> 00:18:33.100
we're going to just stuff them
directly into the appropriate

00:18:33.100 --> 00:18:36.140
PeerConnection So let's
try this out.

00:18:40.440 --> 00:18:41.690
Still like this incognito
mode.

00:18:49.720 --> 00:18:50.640
OK.

00:18:50.640 --> 00:18:52.600
So we start up the camera.

00:18:59.140 --> 00:19:01.180
And now, when we hit the call
button, we're going to spin up

00:19:01.180 --> 00:19:04.710
all the codec, P2P, crypto,
all that sort of stuff.

00:19:04.710 --> 00:19:07.750
And we should see the video
appear in the panel on the

00:19:07.750 --> 00:19:11.650
right as what the remote
user would see.

00:19:11.650 --> 00:19:13.783
Bang, there it is.

00:19:13.783 --> 00:19:15.050
Now, let me show
you that again.

00:19:15.050 --> 00:19:18.800
I'm going to hang it
up and call again.

00:19:18.800 --> 00:19:20.900
And there it goes.

00:19:20.900 --> 00:19:23.590
So you'll see that we have
this functionality.

00:19:23.590 --> 00:19:25.550
And as long as it's sending
session descriptions back and

00:19:25.550 --> 00:19:33.030
forth, the rest of it pretty
much manages itself.

00:19:33.030 --> 00:19:35.795
Now, that's kind of cheating.

00:19:35.795 --> 00:19:38.710
You know, passing the data back
and forth in a single web

00:19:38.710 --> 00:19:40.960
page isn't really that
interesting from

00:19:40.960 --> 00:19:41.760
a video call scenario.

00:19:41.760 --> 00:19:44.280
We want to call someone on the
other side of the planet, not

00:19:44.280 --> 00:19:45.390
in the same web page.

00:19:45.390 --> 00:19:48.150
So how are we to do This Well,
in order to make this into a

00:19:48.150 --> 00:19:51.040
real video calling app, we need
to send those session

00:19:51.040 --> 00:19:53.280
descriptions across
the internet.

00:19:53.280 --> 00:19:54.930
Now, let's look at how
we can do that.

00:19:58.180 --> 00:20:00.440
So it's really easy
to send a session

00:20:00.440 --> 00:20:02.060
description to the cloud.

00:20:02.060 --> 00:20:04.340
We just make it into a string,
and shoot it off

00:20:04.340 --> 00:20:06.936
over XML HTTP Request.

00:20:06.936 --> 00:20:09.160
But how can we receive them?

00:20:09.160 --> 00:20:12.290
Especially when this is a
real-time application.

00:20:12.290 --> 00:20:13.630
The caller doesn't want
to sit there forever

00:20:13.630 --> 00:20:15.060
waiting for the callee.

00:20:15.060 --> 00:20:17.790
We don't want to spend a
lot of time polling.

00:20:17.790 --> 00:20:18.960
What can we do?

00:20:18.960 --> 00:20:21.750
Well, App Engine gives us
a great tool for this.

00:20:21.750 --> 00:20:25.480
The Channel API provides an easy
to use, server to client

00:20:25.480 --> 00:20:28.600
signaling path for pushing
session descriptions from the

00:20:28.600 --> 00:20:30.450
server to the client.

00:20:30.450 --> 00:20:33.810
And App Engine takes care
of all the details.

00:20:33.810 --> 00:20:36.910
No matter how many users you
have, or where users are in

00:20:36.910 --> 00:20:39.290
the world, you can use
the same simple API

00:20:39.290 --> 00:20:40.540
to send down messages.

00:20:44.080 --> 00:20:45.195
So here's how it works.

00:20:45.195 --> 00:20:48.260
The first thing you do is
establish a channel.

00:20:48.260 --> 00:20:50.530
You can do this when serving
the web page to eliminate a

00:20:50.530 --> 00:20:51.470
round trip.

00:20:51.470 --> 00:20:54.670
So in the server, you simply
create a Channel API token and

00:20:54.670 --> 00:20:57.720
send it down in the
web page response.

00:20:57.720 --> 00:21:00.620
The app then uses the JavaScript
API with that token

00:21:00.620 --> 00:21:03.420
to bring up the back channel,
and you're ready to rock.

00:21:03.420 --> 00:21:05.310
You can send messages
from your server

00:21:05.310 --> 00:21:08.010
down to your client.

00:21:08.010 --> 00:21:12.100
So here we have Client B that
wants to send a message and

00:21:12.100 --> 00:21:15.450
link the session description
to Client A. It does so

00:21:15.450 --> 00:21:16.020
typically [? in the ?]

00:21:16.020 --> 00:21:19.420
POST using XML HTTP
Request to get the

00:21:19.420 --> 00:21:21.720
message up to App Engine.

00:21:21.720 --> 00:21:23.765
And then it codes an identifier
to indicate who it

00:21:23.765 --> 00:21:24.550
should be sent to.

00:21:24.550 --> 00:21:26.970
Now, your app can use the
identifier to find the right

00:21:26.970 --> 00:21:29.410
channel instance on
the server side.

00:21:29.410 --> 00:21:31.330
And once it does that, you
simply call [? send ?]

00:21:31.330 --> 00:21:31.775
the channel.

00:21:31.775 --> 00:21:34.680
And it gets pushed down to
Client A who receives it in a

00:21:34.680 --> 00:21:37.250
JavaScript callback,
super easy.

00:21:40.470 --> 00:21:44.500
So here's a snippet that shows
how this all works.

00:21:44.500 --> 00:21:48.140
At the top, the client brings up
the back channel using the

00:21:48.140 --> 00:21:49.770
App Engine API.

00:21:49.770 --> 00:21:53.520
Then, when it gets an incoming
call message in its callback,

00:21:53.520 --> 00:21:56.610
we can set the remote and local
descriptions, create an

00:21:56.610 --> 00:21:59.400
answer, and then shoot
that back using XHR.

00:22:04.340 --> 00:22:07.790
So these are some great little
examples to sort of show the

00:22:07.790 --> 00:22:09.970
basics of the API.

00:22:09.970 --> 00:22:13.440
But we also want to have a
complete video calling

00:22:13.440 --> 00:22:16.410
application, a reference sample
application, where we

00:22:16.410 --> 00:22:20.140
can show developers the
best ways to bring

00:22:20.140 --> 00:22:21.490
this stuff all together.

00:22:21.490 --> 00:22:23.670
And we also want it to be the
kind of application that we

00:22:23.670 --> 00:22:26.840
can use in our daily work, not
just a sample app, something

00:22:26.840 --> 00:22:29.910
that will be a full-fledged
reference application.

00:22:29.910 --> 00:22:32.730
So we created AppRTC.

00:22:32.730 --> 00:22:35.830
It runs on App Engine using
things like Channel API and

00:22:35.830 --> 00:22:40.040
Data Store, and shows how to use
the WebRTC APIs, handling

00:22:40.040 --> 00:22:43.760
session descriptions, making
call setup fast, and showing

00:22:43.760 --> 00:22:45.130
NAT Traversal works.

00:22:45.130 --> 00:22:47.725
And every AppRTC call
is fully encrypted.

00:22:51.040 --> 00:22:54.940
Now, I really want to
show this to you.

00:22:54.940 --> 00:22:57.640
So we've got some people
on the team.

00:22:57.640 --> 00:22:59.800
And they've been working
really hard on

00:22:59.800 --> 00:23:03.250
some updates to AppRTC.

00:23:03.250 --> 00:23:06.000
Now, I want to just sort of
check in with them real quick

00:23:06.000 --> 00:23:09.620
and make sure that they're not
getting too stressed out.

00:23:09.620 --> 00:23:11.150
So let's do that now.

00:23:23.330 --> 00:23:24.580
OK.

00:23:33.130 --> 00:23:34.980
Hey, Ray.

00:23:34.980 --> 00:23:37.290
You look pretty relaxed there.

00:23:37.290 --> 00:23:40.560
Did you get that work done
I wanted you to do?

00:23:40.560 --> 00:23:41.945
RAY: Yep, yep, sure did.

00:23:41.945 --> 00:23:44.830
WebRTC and App Engine
took care of the

00:23:44.830 --> 00:23:45.630
most complicated stuff.

00:23:45.630 --> 00:23:49.970
So I'm done, Justin.

00:23:49.970 --> 00:23:52.560
JUSTIN UBERTI: Well, I mean,
let me say, it looks great.

00:23:52.560 --> 00:23:57.630
I mean, not just the app,
but also your pool.

00:23:57.630 --> 00:24:00.770
You know, I wish I could
swing by later.

00:24:00.770 --> 00:24:03.510
Anyway, I've got to get
back to the session.

00:24:03.510 --> 00:24:04.600
It's going great.

00:24:04.600 --> 00:24:07.090
And I'll let you get
back to relaxing.

00:24:07.090 --> 00:24:08.190
Catch you later, Ray.

00:24:08.190 --> 00:24:09.440
RAY: See you, Justin.

00:24:12.750 --> 00:24:18.030
[APPLAUSE]

00:24:18.030 --> 00:24:20.860
JUSTIN UBERTI: So that's the
kind of quality that you can

00:24:20.860 --> 00:24:22.660
accomplish with WebRTC.

00:24:22.660 --> 00:24:25.940
Real calls across the
internet, right

00:24:25.940 --> 00:24:27.190
from your web browser.

00:24:30.760 --> 00:24:34.490
OK, so we just showed how
to send audio and

00:24:34.490 --> 00:24:36.040
video peer to peer.

00:24:36.040 --> 00:24:38.710
But what if we just
want to send data?

00:24:38.710 --> 00:24:40.120
Well, enter DataChannels.

00:24:42.820 --> 00:24:45.720
So DataChannels designed to
allow apps to exchange

00:24:45.720 --> 00:24:49.100
arbitrary application data
with low latency, high

00:24:49.100 --> 00:24:52.710
throughput and message rate,
and optionally unreliable

00:24:52.710 --> 00:24:54.950
semantics so you keep
chugging, even

00:24:54.950 --> 00:24:56.620
if you lose a packet.

00:24:56.620 --> 00:24:58.530
Now, there are lots of great
real world use cases that

00:24:58.530 --> 00:25:02.030
DataChannels are great for.

00:25:02.030 --> 00:25:04.770
If you have a game, and you want
to send the positions of

00:25:04.770 --> 00:25:07.240
bullets in a game, you don't
want to send that data over

00:25:07.240 --> 00:25:11.110
HTTP, to the server and back
with all the HTTP overhead.

00:25:11.110 --> 00:25:13.560
You can instead send it in a
very tight, efficient message

00:25:13.560 --> 00:25:15.910
over the peer to peer channel.

00:25:15.910 --> 00:25:19.270
For remote desktop apps, you can
do things like track the

00:25:19.270 --> 00:25:22.880
position of the mouse with
great responsiveness.

00:25:22.880 --> 00:25:24.700
And there's a lot of other
great examples.

00:25:24.700 --> 00:25:27.230
But one I particularly like
is the ability to create a

00:25:27.230 --> 00:25:29.720
secure, decentralized network.

00:25:29.720 --> 00:25:32.870
And you can imagine, in a place
were there's censorship

00:25:32.870 --> 00:25:35.630
of the internet, you could
provide this mechanism as a

00:25:35.630 --> 00:25:38.680
way where people can communicate
over a private

00:25:38.680 --> 00:25:39.930
encrypted channel.

00:25:42.730 --> 00:25:47.330
So here are the key features
of the DataChannel.

00:25:47.330 --> 00:25:49.130
To set it up, we're going
to leverage the

00:25:49.130 --> 00:25:50.450
PeerConnection setup.

00:25:50.450 --> 00:25:52.350
You do this sort of offer/answer
dance.

00:25:52.350 --> 00:25:53.830
We'll get the channel
bootstrapped.

00:25:53.830 --> 00:25:55.840
But then you can create
multiple channels.

00:25:55.840 --> 00:25:59.670
And those channels can all be
either reliable or unreliable.

00:25:59.670 --> 00:26:02.990
In a game, you might want your
state updates to be reliable,

00:26:02.990 --> 00:26:06.930
but projectiles can be sent over
an unreliable channel.

00:26:06.930 --> 00:26:09.560
Security and congestion control
is built right in.

00:26:09.560 --> 00:26:11.720
The app gets this for free.

00:26:11.720 --> 00:26:14.910
And we've tried to make
developers lives easier by

00:26:14.910 --> 00:26:18.040
keeping a similar API
to WebSockets.

00:26:18.040 --> 00:26:21.460
So that code written to use a
WebSocket should work just as

00:26:21.460 --> 00:26:23.180
well when coupled with
a DataChannel.

00:26:26.830 --> 00:26:31.520
So here's a simple usage
of DataChannels.

00:26:31.520 --> 00:26:34.270
We want to have two clients
exchanging data.

00:26:34.270 --> 00:26:36.060
They exchange session
descriptions to get the peer

00:26:36.060 --> 00:26:37.760
to peer link set up.

00:26:37.760 --> 00:26:39.430
And then, we're ready to go.

00:26:39.430 --> 00:26:40.210
We send the data.

00:26:40.210 --> 00:26:42.960
And it gets sent over the
internet using standard IETF

00:26:42.960 --> 00:26:47.270
protocols, SCTP, Datagram
TLS over UDP.

00:26:47.270 --> 00:26:50.410
It goes through a [? NAS ?],
it just works.

00:26:50.410 --> 00:26:53.700
This is going to be a
revolutionary technology.

00:26:53.700 --> 00:26:57.870
And here's what this
looks like in code.

00:26:57.870 --> 00:26:59.320
It's really simple.

00:26:59.320 --> 00:27:02.640
You just call on each side,
create DataChannel, you

00:27:02.640 --> 00:27:04.270
specify an identifier.

00:27:04.270 --> 00:27:07.240
This identifier is what allows
both channels to get connected

00:27:07.240 --> 00:27:11.820
together in the middle because
they're indicated by name.

00:27:11.820 --> 00:27:13.260
And then, once it's connected,
you just

00:27:13.260 --> 00:27:15.140
call/send on one side.

00:27:15.140 --> 00:27:17.440
And our message gets called on
the other side, just like

00:27:17.440 --> 00:27:19.150
WebSockets.

00:27:19.150 --> 00:27:21.480
Now, I wish I could show
this to you now.

00:27:21.480 --> 00:27:23.350
But as I mentioned before, we're
still finishing up the

00:27:23.350 --> 00:27:24.680
details of the spec.

00:27:24.680 --> 00:27:27.550
But expect to see this in Chrome
in the near future.

00:27:30.960 --> 00:27:33.660
So you can also imagine
some more complicated

00:27:33.660 --> 00:27:36.160
topologies for this.

00:27:36.160 --> 00:27:39.150
If we want to distribute data
between multiple peers, we can

00:27:39.150 --> 00:27:41.960
create a mesh, where each
endpoint is connected to each

00:27:41.960 --> 00:27:43.130
other endpoint.

00:27:43.130 --> 00:27:45.760
If you're creating like a
multiplayer game, this is a

00:27:45.760 --> 00:27:49.300
really easy way to get
multiplayer functionality

00:27:49.300 --> 00:27:53.130
without having to have a big
server infrastructure.

00:27:53.130 --> 00:27:55.630
But you can also imagine some
other interesting things.

00:27:55.630 --> 00:27:58.100
You create a graph.

00:27:58.100 --> 00:28:00.900
And say you want to be able to
send down a lot of data from

00:28:00.900 --> 00:28:02.020
your service.

00:28:02.020 --> 00:28:05.830
Instead of having to send the
data n times by unicasting it

00:28:05.830 --> 00:28:10.290
to all your clients, you can
instead construct a tree, and

00:28:10.290 --> 00:28:14.960
use peer to peer to push the
data very efficient to all

00:28:14.960 --> 00:28:16.030
your clients.

00:28:16.030 --> 00:28:18.370
Since you control the
application, you can have the

00:28:18.370 --> 00:28:21.570
application take the data and
it's distributed to other

00:28:21.570 --> 00:28:23.570
peers that it might
be connected to.

00:28:23.570 --> 00:28:26.090
There will be some amazing
things that will be created as

00:28:26.090 --> 00:28:27.340
a result of this technology.

00:28:30.280 --> 00:28:34.850
OK, so we went over a lot
of stuff really quickly.

00:28:34.850 --> 00:28:36.100
Let's review.

00:28:42.630 --> 00:28:45.590
We're building real-time
communication into the fabric

00:28:45.590 --> 00:28:50.090
of the web, providing amazing
new voice, video, and peer to

00:28:50.090 --> 00:28:54.920
peer functionality in the open
web platform, and enabling the

00:28:54.920 --> 00:28:59.490
communications industry
to move at web speed.

00:28:59.490 --> 00:29:01.260
This is a really
exciting time.

00:29:01.260 --> 00:29:02.720
We're really excited
on the team.

00:29:02.720 --> 00:29:04.320
We can't wait to see the
apps you guys are

00:29:04.320 --> 00:29:05.570
going to build on this.

00:29:07.660 --> 00:29:12.400
So MediaStreams are shipping
in Chrome 21.

00:29:12.400 --> 00:29:15.640
PeerConnection is in Chrome
20 behind a flag.

00:29:15.640 --> 00:29:17.540
But we're working hard to
try to stabilize it in

00:29:17.540 --> 00:29:20.020
time for Chrome 22.

00:29:20.020 --> 00:29:21.950
The DataChannel works is going
to follow along after that.

00:29:21.950 --> 00:29:24.930
And we expect to do this
by the end of the year.

00:29:24.930 --> 00:29:27.320
Opera is also shipping
MediaStreams now.

00:29:27.320 --> 00:29:30.470
And our friends at Mozilla, they
tell us they think that

00:29:30.470 --> 00:29:34.310
they get all this stuff done
by the end of the year.

00:29:34.310 --> 00:29:37.700
Now, for people using Internet
Explorer, we've got WebRTC

00:29:37.700 --> 00:29:38.860
running in ChromeFrame.

00:29:38.860 --> 00:29:41.030
And it works great.

00:29:41.030 --> 00:29:42.980
As we start to stabilize things,
we're also going to

00:29:42.980 --> 00:29:44.915
see stuff landing in
mobile browsers.

00:29:44.915 --> 00:29:47.580
And as I mentioned before, we
have native versions of the

00:29:47.580 --> 00:29:50.190
entire stack available for the
app builders out there.

00:29:55.180 --> 00:29:58.415
So here's our resident Icelandic
team member, Tommy

00:29:58.415 --> 00:29:59.400
Gunnarsson.

00:29:59.400 --> 00:30:03.580
He's showing off AppRTC running
here in IE, courtesy

00:30:03.580 --> 00:30:05.290
of ChromeFrame.

00:30:05.290 --> 00:30:08.360
So for more information about
ChromeFrame you check it out

00:30:08.360 --> 00:30:10.590
at google.com/chromeframe.

00:30:10.590 --> 00:30:13.630
Now, incidentally, we might
be thinking, well what is

00:30:13.630 --> 00:30:14.760
Microsoft doing about
supporting

00:30:14.760 --> 00:30:16.190
this natively in IE?

00:30:16.190 --> 00:30:18.490
Well, I don't know for sure.

00:30:18.490 --> 00:30:21.540
But I saw a couple of WebRTC
related job postings show up

00:30:21.540 --> 00:30:23.630
on the Microsoft career
site in the past week.

00:30:23.630 --> 00:30:25.120
So I'm pretty sure
they're investing

00:30:25.120 --> 00:30:26.370
pretty heavily in this.

00:30:29.230 --> 00:30:34.380
OK, so I'd like to show you
one more demo, or two more

00:30:34.380 --> 00:30:38.460
demos here of examples of what
third-party developers are

00:30:38.460 --> 00:30:40.025
doing with this technology.

00:30:40.025 --> 00:30:43.390
So the first is an application
called Twinsee.

00:30:43.390 --> 00:30:46.670
The team there has created a
WebRTC app that works on both

00:30:46.670 --> 00:30:48.610
web and on mobile.

00:30:48.610 --> 00:30:50.193
And I'm going to call them
up now using the app

00:30:50.193 --> 00:30:51.443
that they've built.

00:31:23.900 --> 00:31:24.580
MALE SPEAKER: Hello.

00:31:24.580 --> 00:31:25.750
JUSTIN UBERTI: Hey, guys.

00:31:25.750 --> 00:31:29.880
You're live at Google
I/O 2012.

00:31:29.880 --> 00:31:31.130
MALE SPEAKER: Wow.

00:31:34.540 --> 00:31:36.080
JUSTIN UBERTI: So tell me
about this app that

00:31:36.080 --> 00:31:38.180
you've built. .

00:31:38.180 --> 00:31:40.210
MALE SPEAKER: OK so let me
introduce ourselves.

00:31:40.210 --> 00:31:41.920
So I'm [? Michel Gien, ?]

00:31:41.920 --> 00:31:44.480
and I'm here with
[? Christian Giacomo. ?]

00:31:44.480 --> 00:31:48.310
And we founded Twinlife at the
beginning of this year.

00:31:48.310 --> 00:31:52.680
And the purpose of Twinlife
is connecting generations.

00:31:52.680 --> 00:31:57.730
So our focus right now is to
take Android tablets and smart

00:31:57.730 --> 00:32:02.130
TVs and make them usable by
older persons, so they can

00:32:02.130 --> 00:32:04.520
interact with their family,
their children and

00:32:04.520 --> 00:32:06.360
grandchildren.

00:32:06.360 --> 00:32:12.980
So our first building block is
this Twinsee service, which is

00:32:12.980 --> 00:32:17.710
made of an Android application,
using at the

00:32:17.710 --> 00:32:21.390
native WebRTC APIs,
which Christian

00:32:21.390 --> 00:32:22.860
integrated into Android.

00:32:22.860 --> 00:32:30.060
And web service, twinsee.net, to
connect users, whether they

00:32:30.060 --> 00:32:33.500
come from a Chrome browser, or
whether they come from a

00:32:33.500 --> 00:32:37.660
Twinsee application
on Android tablet.

00:32:37.660 --> 00:32:38.600
JUSTIN UBERTI: That's great.

00:32:38.600 --> 00:32:40.345
It feels like you guys
are right here in San

00:32:40.345 --> 00:32:41.800
Francisco with us.

00:32:41.800 --> 00:32:44.260
So when can I expect this
to be available?

00:32:47.700 --> 00:32:50.760
MALE SPEAKER: Twinsee will be
available for public testing

00:32:50.760 --> 00:32:55.650
on the Android Market in
the August time frame.

00:32:55.650 --> 00:32:58.610
So I'll show you here
in the mirror.

00:32:58.610 --> 00:33:00.800
You can see that this
tablet we're using

00:33:00.800 --> 00:33:03.520
right now is Asus Prime.

00:33:03.520 --> 00:33:05.900
And so if you have any
questions, contact us at

00:33:05.900 --> 00:33:08.450
twinsee.net.

00:33:08.450 --> 00:33:10.180
JUSTIN UBERTI: OK, that
looks great, guys.

00:33:10.180 --> 00:33:12.470
MALE SPEAKER: I hope you're have
at Google I/O. I wish we

00:33:12.470 --> 00:33:14.860
were there.

00:33:14.860 --> 00:33:15.940
JUSTIN UBERTI: Looks
great, guys.

00:33:15.940 --> 00:33:17.070
Well, that's really exciting.

00:33:17.070 --> 00:33:18.750
I'll let you guys
get some sleep.

00:33:18.750 --> 00:33:21.612
Talk to you later.

00:33:21.612 --> 00:33:34.680
[APPLAUSE]

00:33:34.680 --> 00:33:35.580
JUSTIN UBERTI: OK.

00:33:35.580 --> 00:33:40.030
So the last thing I want to
show, I know a ton of you are

00:33:40.030 --> 00:33:43.630
using GitHub to host and
share your code.

00:33:43.630 --> 00:33:46.240
So that's why I'm really excited
to introduce this next

00:33:46.240 --> 00:33:50.690
app called GitTogether, which
brings real-time communication

00:33:50.690 --> 00:33:52.680
to the GitHub community.

00:33:52.680 --> 00:33:55.240
Now, the guys who built this
have been involved with WebRTC

00:33:55.240 --> 00:33:56.820
since the very beginning.

00:33:56.820 --> 00:33:58.170
Let's call them up now.

00:33:58.170 --> 00:34:00.990
And they can tell you about
how this works.

00:34:00.990 --> 00:34:03.910
These guys have been
working on this.

00:34:03.910 --> 00:34:06.380
They're creating not just an
application, but also a

00:34:06.380 --> 00:34:09.199
JavaScript framework that
allows a lot of

00:34:09.199 --> 00:34:11.920
simplifications to be done
for people who are WebRTC

00:34:11.920 --> 00:34:13.170
developers.

00:34:17.100 --> 00:34:21.420
So that's everything for
WebRTC see today.

00:34:21.420 --> 00:34:23.800
We covered a lot of
stuff quickly.

00:34:23.800 --> 00:34:31.000
[APPLAUSE]

00:34:31.000 --> 00:34:32.170
JUSTIN UBERTI: Thank you.

00:34:32.170 --> 00:34:35.790
Oh, also, the GitTogether
is made by vline.com.

00:34:35.790 --> 00:34:38.969
Also, check out the Chrome
Developer sandbox.

00:34:38.969 --> 00:34:40.120
We've got some stuff
down there.

00:34:40.120 --> 00:34:42.969
There's a Voxeo, who is an
emergency response app being

00:34:42.969 --> 00:34:44.489
built using WebRTC.

00:34:44.489 --> 00:34:47.940
And we've also got a really
cool WebRTC based game

00:34:47.940 --> 00:34:48.380
called Who Am I?

00:34:48.380 --> 00:34:49.840
MIT

00:34:49.840 --> 00:34:50.790
Thank you all for coming.

00:34:50.790 --> 00:34:52.670
I'll be happy to answer any
questions that you might have.

00:34:57.500 --> 00:35:01.120
Step up to the microphone, so
the video can record it.

00:35:01.120 --> 00:35:03.120
AUDIENCE: In a lot of your
slides, you had a dotted line

00:35:03.120 --> 00:35:06.340
between the two browsers
on the bottom.

00:35:06.340 --> 00:35:10.430
Is that an actual connection
somehow.

00:35:10.430 --> 00:35:13.210
I mean, if both of them are
behind a net firewall, how do

00:35:13.210 --> 00:35:16.250
you get the peer to peer
communication to go?

00:35:16.250 --> 00:35:19.110
Is there actually a server
there that's--

00:35:19.110 --> 00:35:22.480
JUSTIN UBERTI: So there's
a technology called ICE.

00:35:22.480 --> 00:35:25.240
And ICE is Interactive
Connectivity Establishment.

00:35:25.240 --> 00:35:28.120
And what it does is it basically
finds all the IP

00:35:28.120 --> 00:35:31.080
addresses that it can come up,
your local address, the

00:35:31.080 --> 00:35:34.425
address of your NAT or firewall,
or an address that

00:35:34.425 --> 00:35:36.310
could be hosted in
a data center.

00:35:36.310 --> 00:35:40.410
And it does interactive checks
to figure out what is the best

00:35:40.410 --> 00:35:44.340
path between the two peers
to establish data.

00:35:44.340 --> 00:35:48.180
In our experience with Google
Talk, we find that in about

00:35:48.180 --> 00:35:51.290
90% of the cases, we can
actually establish a peer to

00:35:51.290 --> 00:35:53.900
peer link, even if both
sides are behind NAT.

00:35:53.900 --> 00:35:58.120
The rules of NAT are such that
if we know the address of the

00:35:58.120 --> 00:36:00.380
other person's NAT, we can still
get that peer to peer

00:36:00.380 --> 00:36:03.025
link going between two
peers using UDP.

00:36:05.590 --> 00:36:06.840
AUDIENCE: Thanks.

00:36:09.560 --> 00:36:10.020
AUDIENCE: Hi.

00:36:10.020 --> 00:36:11.420
Can you talk about
codec support?

00:36:11.420 --> 00:36:13.820
Because I know you guys have
acquired GIPS, and with that

00:36:13.820 --> 00:36:14.830
came iLBC and iSAC.

00:36:14.830 --> 00:36:17.460
But are you going to do
something like Opus support,

00:36:17.460 --> 00:36:19.020
or something like that?

00:36:19.020 --> 00:36:22.540
JUSTIN UBERTI: So this is all
a big topic for the IETF.

00:36:22.540 --> 00:36:25.770
But what we are planning
support, assuming we can work

00:36:25.770 --> 00:36:30.790
out all the licensing details,
VP8 will be our open, royalty

00:36:30.790 --> 00:36:32.330
free video codec.

00:36:32.330 --> 00:36:35.080
And then, as far as all your
codecs are concerned, we'll

00:36:35.080 --> 00:36:38.900
support G.711 for legacy
interoperability.

00:36:38.900 --> 00:36:40.840
We'll support iSAC.

00:36:40.840 --> 00:36:45.000
And we hope to support Opus,
assuming that Microsoft can

00:36:45.000 --> 00:36:47.210
help us out in the
licensing front.

00:36:47.210 --> 00:36:50.450
AUDIENCE: And can you talk about
iLBC voice quality on an

00:36:50.450 --> 00:36:51.930
Android platform?

00:36:51.930 --> 00:36:54.090
Have you guys had good
luck with it?

00:36:54.090 --> 00:36:56.150
I mean, are you seeing good
performance relative to a

00:36:56.150 --> 00:36:57.860
general cell phone call?

00:36:57.860 --> 00:36:59.700
JUSTIN UBERTI: We have the
person who wrote iLBC here

00:36:59.700 --> 00:37:00.975
sitting in the audience.

00:37:00.975 --> 00:37:02.250
AUDIENCE: That guy,
right there?

00:37:02.250 --> 00:37:02.330
JUSTIN UBERTI: Yeah, that guy.

00:37:02.330 --> 00:37:03.700
AUDIENCE: OK, I'll
talk to him.

00:37:03.700 --> 00:37:06.680
Thank you.

00:37:06.680 --> 00:37:08.480
AUDIENCE: Hi.

00:37:08.480 --> 00:37:12.540
Simple question, I saw on the
first demo that you showed how

00:37:12.540 --> 00:37:15.110
to use video.

00:37:15.110 --> 00:37:18.440
Well, you didn't show about
audio, but I guess audio is

00:37:18.440 --> 00:37:20.900
also included.

00:37:20.900 --> 00:37:23.490
Only on one to one conversation,
is there a way

00:37:23.490 --> 00:37:25.110
to make it broadcast?

00:37:25.110 --> 00:37:28.920
For example, this show can be
seen on the web page by

00:37:28.920 --> 00:37:31.350
multiple users?

00:37:31.350 --> 00:37:35.230
JUSTIN UBERTI: Yeah, so a
PeerConnection creates a

00:37:35.230 --> 00:37:37.800
connection between yourself
and a remote peer.

00:37:37.800 --> 00:37:41.090
And if you want to have a
multi-way conversation,

00:37:41.090 --> 00:37:43.270
there's a couple ways
you can do this.

00:37:43.270 --> 00:37:45.690
The first thing is you could
have multiple PeerConnections

00:37:45.690 --> 00:37:49.140
and establish a full mesh,
like I show here.

00:37:49.140 --> 00:37:52.020
If you have four participants,
you establish three

00:37:52.020 --> 00:37:56.080
PeerConnections, one of each
remote participant.

00:37:56.080 --> 00:37:57.810
This doesn't scale
all the way up.

00:37:57.810 --> 00:37:59.310
So one of the other things that
you can do as you get to

00:37:59.310 --> 00:38:02.210
be in a large conference, is
actually have a central server

00:38:02.210 --> 00:38:04.970
and create like a star topology,
where the other

00:38:04.970 --> 00:38:09.180
side, instead of being a
browser, is actually a server.

00:38:09.180 --> 00:38:12.130
And then using the WebRTC tools,
you can create a server

00:38:12.130 --> 00:38:15.110
that could do multi-party.

00:38:15.110 --> 00:38:19.970
AUDIENCE: OK, I think maybe
I asked you wrongly.

00:38:19.970 --> 00:38:23.170
I'm only interested one party
who is transmitting.

00:38:23.170 --> 00:38:26.950
The other ones don't need
to talk, only to listen.

00:38:26.950 --> 00:38:30.150
So it's like UDP
in that sense.

00:38:30.150 --> 00:38:30.870
JUSTIN UBERTI: Right, right.

00:38:30.870 --> 00:38:31.520
Sorry.

00:38:31.520 --> 00:38:34.550
In that case, the other side
wouldn't even have to call

00:38:34.550 --> 00:38:35.490
getUserMedia.

00:38:35.490 --> 00:38:39.050
So the side who calls
getUserMedia can specify

00:38:39.050 --> 00:38:42.710
whether it wants video
and/or audio.

00:38:42.710 --> 00:38:44.080
But you won't need to call
getUserMedia at all.

00:38:44.080 --> 00:38:47.480
So if you want to receive only,
you just would not call

00:38:47.480 --> 00:38:51.100
getUserMedia, and you wouldn't
call AddStream on that side.

00:38:51.100 --> 00:38:53.718
And then you would just play.

00:38:53.718 --> 00:38:54.570
AUDIENCE: I see.

00:38:54.570 --> 00:38:55.400
OK, thank you.

00:38:55.400 --> 00:38:56.650
JUSTIN UBERTI: Sure.

00:38:58.480 --> 00:39:00.650
AUDIENCE: So if you want to
stream to the server and save

00:39:00.650 --> 00:39:04.762
the recorded video, are there
components or libraries that

00:39:04.762 --> 00:39:06.310
are available?

00:39:06.310 --> 00:39:10.060
JUSTIN UBERTI: So I mean, if
you're familiar with media

00:39:10.060 --> 00:39:13.110
processing, you can build these
kind of servers using

00:39:13.110 --> 00:39:15.400
the WebRTC components.

00:39:15.400 --> 00:39:20.090
There is something in the WebRTC
spec for an API called

00:39:20.090 --> 00:39:21.570
Media Recorder.

00:39:21.570 --> 00:39:23.400
It's missing a lot of
detail right now.

00:39:23.400 --> 00:39:24.730
So it's not being implemented.

00:39:24.730 --> 00:39:27.590
But we expect, at some point in
time, there will be an easy

00:39:27.590 --> 00:39:28.690
way to do media recording.

00:39:28.690 --> 00:39:31.570
For right now, the easiest way
is to build a server, make a

00:39:31.570 --> 00:39:32.620
PeerConnection to it.

00:39:32.620 --> 00:39:35.010
And then you can then save
it out to a file there.

00:39:35.010 --> 00:39:37.180
AUDIENCE: So the component would
be the C++ libraries

00:39:37.180 --> 00:39:38.620
that you would bind
into your server?

00:39:38.620 --> 00:39:39.870
JUSTIN UBERTI: Yes.

00:39:43.190 --> 00:39:46.130
AUDIENCE: I had a question about
whether Screen Sharing

00:39:46.130 --> 00:39:50.070
is still in consideration
as a video source?

00:39:50.070 --> 00:39:51.320
JUSTIN UBERTI: It
absolutely is.

00:39:54.590 --> 00:39:57.560
The question is whether Screen
Sharing will be supported as a

00:39:57.560 --> 00:39:58.690
video source.

00:39:58.690 --> 00:40:01.340
And it's sort of one of these
things where we definitely

00:40:01.340 --> 00:40:03.760
want to support it, we have
the technology to do it.

00:40:03.760 --> 00:40:06.670
But in terms of making sure we
get something out there, v1

00:40:06.670 --> 00:40:08.586
will be just video only.

00:40:08.586 --> 00:40:11.310
AUDIENCE: [INAUDIBLE].

00:40:11.310 --> 00:40:13.060
JUSTIN UBERTI: You could also
do it with camera drivers.

00:40:13.060 --> 00:40:14.730
Although, the issue with camera
drivers is that their

00:40:14.730 --> 00:40:17.825
resolution will be artificially
limited.

00:40:17.825 --> 00:40:19.460
AUDIENCE: Do you have
plans to integrate

00:40:19.460 --> 00:40:22.190
with Server-Sent Events?

00:40:22.190 --> 00:40:23.440
JUSTIN UBERTI: Server-Sent
Events.

00:40:25.348 --> 00:40:29.620
Are you specific about what
you have in mind there?

00:40:29.620 --> 00:40:33.890
AUDIENCE: Well, to get the
session exchange pushed back

00:40:33.890 --> 00:40:35.130
the answer.

00:40:35.130 --> 00:40:36.640
JUSTIN UBERTI: I think I'll have
to get back you on that.

00:40:36.640 --> 00:40:37.860
I'm not sure I'm familiar
enough with

00:40:37.860 --> 00:40:39.800
the Server-Sent Events.

00:40:39.800 --> 00:40:42.850
AUDIENCE: They're part of the
[INAUDIBLE] working group

00:40:42.850 --> 00:40:43.915
specifications.

00:40:43.915 --> 00:40:45.165
JUSTIN UBERTI: We can
talk afterwards.

00:40:47.560 --> 00:40:48.170
AUDIENCE: Hi.

00:40:48.170 --> 00:40:51.970
There will be any SIP
integration in the future?

00:40:51.970 --> 00:40:55.340
Any way to make a phone
call using these API?

00:40:55.340 --> 00:40:56.860
JUSTIN UBERTI: Yeah, so we
actually have some demos--

00:40:56.860 --> 00:40:57.860
I didn't show them today--

00:40:57.860 --> 00:41:00.810
where you can actually make
a phone call to the PSTN.

00:41:00.810 --> 00:41:04.860
And there's a couple
ways you can do it.

00:41:04.860 --> 00:41:07.100
You can send JSON to your web
server, and have the web

00:41:07.100 --> 00:41:09.540
server then gateway
that to SIP.

00:41:09.540 --> 00:41:12.720
Or there's a product
called sipML5--

00:41:12.720 --> 00:41:14.010
sipml5.org--

00:41:14.010 --> 00:41:15.910
where they're actually
implementing a SIP stack

00:41:15.910 --> 00:41:17.760
within the browser itself.

00:41:17.760 --> 00:41:21.460
So it converts the session
descriptions to SIP messages

00:41:21.460 --> 00:41:23.140
right inside the web
application.

00:41:23.140 --> 00:41:27.750
So you can definitely do SIP
calls using this technology.

00:41:27.750 --> 00:41:28.030
AUDIENCE: Great.

00:41:28.030 --> 00:41:32.250
And there will be an SDK for
Android, or something?

00:41:32.250 --> 00:41:34.770
JUSTIN UBERTI: Yeah, we
have existing SDK.

00:41:34.770 --> 00:41:39.460
If you go to WebRTC.org, you
can download the code for

00:41:39.460 --> 00:41:40.685
running this on Android.

00:41:40.685 --> 00:41:41.920
AUDIENCE: Thank you very much.

00:41:41.920 --> 00:41:43.170
JUSTIN UBERTI: Sure.

00:41:46.040 --> 00:41:46.380
OK.

00:41:46.380 --> 00:41:47.920
Thank you all for coming.

00:41:47.920 --> 00:41:53.513
[APPLAUSE]

