WEBVTT
Kind: captions
Language: en

00:00:01.510 --> 00:00:06.500
&gt;&gt;Chris Pruett: Hi, folks. This is writing
real-time games for Android redux. I think

00:00:06.500 --> 00:00:11.020
people are still trailing in but we have to
start.

00:00:11.020 --> 00:00:15.680
There is totally a Wave open about this right
now, and here is the URL and you should totally

00:00:15.680 --> 00:00:21.770
use it. There is somebody taking note, and
you can ask questions and I will try to answer

00:00:21.770 --> 00:00:24.120
them at the end.
Who am I? I am a developer advocate. My name

00:00:24.120 --> 00:00:30.080
is Chris Pruett. My focus is on video games
for Android. Before I joined Google I was

00:00:30.080 --> 00:00:35.239
a video game engineer.
Today I want to talk about three things related

00:00:35.239 --> 00:00:40.039
to Android, kind of three big buckets. Those
three things are basically hardware stuff

00:00:40.039 --> 00:00:45.850
software design, and Android market for games.
Hardware stuff, I want to talk about how the

00:00:45.850 --> 00:00:52.219
world has changed in the last year or so,
the type of devices we have, and also stuff

00:00:52.219 --> 00:00:56.940
about performance. For game architecture,
that's the software design stuff. I would

00:00:56.940 --> 00:01:00.750
like to talk to you about how games can be
developed for Android and what the right way

00:01:00.750 --> 00:01:05.970
to go about that is. And also the tips and
tricks and pitfalls that game developers often

00:01:05.970 --> 00:01:09.860
run into.
And then Android market for games.

00:01:09.860 --> 00:01:15.220
I want to tell about what I learned shipping
a game on Android market. And to do that I

00:01:15.220 --> 00:01:21.400
am going to use this game I wrote called Replica
Island as a case study. And I will refer back

00:01:21.400 --> 00:01:29.190
to Replica Island throughout the talk.
So last year I was up on the stage and I gave

00:01:29.190 --> 00:01:35.770
a talk about games. And at that point there
was basically one device available on the

00:01:35.770 --> 00:01:40.000
market, and that was the G1. Android 1.5 had
just been released and there were less than

00:01:40.000 --> 00:01:45.350
5,000 apps on the app store. So within a year
we came a long way. We have lots and lots

00:01:45.350 --> 00:01:49.430
of devices on the market now, lots and lots
of apps in the store, and a lot of those are

00:01:49.430 --> 00:01:53.870
games.
As game developers, one thing that a lot of

00:01:53.870 --> 00:02:00.590
people probably worry about is if there are
a lot of devices, how do you target all of

00:02:00.590 --> 00:02:07.730
them? Fortunately, when it comes to graphics
performance and CPU performance, all the devices

00:02:07.730 --> 00:02:12.730
in the world have broken pretty cleanly out
into two discrete categories, which I am going

00:02:12.730 --> 00:02:18.670
to call first generation and second generation.
This is fantastic because as a game developer,

00:02:18.670 --> 00:02:23.879
you can choose sort of which category, or
both categories, to support, and that should

00:02:23.879 --> 00:02:30.670
give you a baseline for performance that you
can use to target your game design. First

00:02:30.670 --> 00:02:36.500
generation devices typified here by the HTC
Magic, also called the MyTouch in the U.S.,

00:02:36.500 --> 00:02:46.600
basically the same hardware as the G1. Typically
500 megahertz ARM processor. Typically Android

00:02:46.600 --> 00:02:52.790
 -- I'm sorry, these devices support OpenGL
ES 1.0, 1.1. Almost all of them have a hardware

00:02:52.790 --> 00:02:59.870
back end to back this up. They almost all
have HVGA screens. I can get about 5,000 textured

00:02:59.870 --> 00:03:04.840
unlit colored verts per frame at 30 frames
per second on these devices, and about 1024

00:03:04.840 --> 00:03:09.739
verts per frame at 60 frames a second. And
I will talk about how I arrived at these numbers

00:03:09.739 --> 00:03:15.010
later. These devices are generally Android
1.5 or 1.6, although a bunch of them are due

00:03:15.010 --> 00:03:19.980
to be upgraded to 2.0 in the near future.
And they represent about 60% of the market

00:03:19.980 --> 00:03:25.819
at the moment. This is the first generation.
Sort of the low end.

00:03:25.819 --> 00:03:30.981
Second generation devices basically started
with the Droid and include the Nexus One,

00:03:30.981 --> 00:03:36.239
and I have a picture of the Xperia on the
other slide. But they are much higher end.

00:03:36.239 --> 00:03:42.849
Much faster CPUs, much faster graphics performance.
These devices are supporting OpenGL ES 2.0.

00:03:42.849 --> 00:03:48.980
They have big screens, and as you can see,
I can get about 27,000 verts per frame at

00:03:48.980 --> 00:03:53.370
30 frames a second, so there's about a 5x
performance improvement in terms of pure graphics

00:03:53.370 --> 00:03:59.419
performance, at least within the study of
the tests that I have done.

00:03:59.419 --> 00:04:05.150
However, these devices have big screens, and
that means that they spend a lot of time copying

00:04:05.150 --> 00:04:09.629
the pixels to fill those big screens every
frame. So these devices are basically fill

00:04:09.629 --> 00:04:13.919
limited, and it's very hard to do faster than
30 frames a second on these high-end devices,

00:04:13.919 --> 00:04:21.220
even though they can render quite quickly.
These devices are generally running Android

00:04:21.220 --> 00:04:29.230
2.0, 2.1. Couple are on 1.6. And they are
about 40% of the market at the moment.

00:04:29.230 --> 00:04:32.790
The first device, like I said, is the Droid.
It shipped in December, late November, I think,

00:04:32.790 --> 00:04:37.510
of last year. That was the first device in
this class, and now these devices represent

00:04:37.510 --> 00:04:42.660
40% of the market. So you can see in a short
period of time, these higher end devices have

00:04:42.660 --> 00:04:46.691
sort of come from zero to a very significant
part of the market.

00:04:46.691 --> 00:04:55.160
So as game developers, one of the things that
you probably are interested in is, well, you

00:04:55.160 --> 00:04:59.400
know, CPU and graphics performance is one
kind of difference, but there's a lot of different

00:04:59.400 --> 00:05:03.291
handsets. There's a lot of different other
things that game developers might care about,

00:05:03.291 --> 00:05:09.850
like input system or screen size. How do I
deal with those? And I think, having built

00:05:09.850 --> 00:05:13.480
a game for these devices and trying to get
it to run on every single thing under the

00:05:13.480 --> 00:05:19.970
sun, I think that the three points of device
diversity that you need to be concerned about

00:05:19.970 --> 00:05:24.340
are screen size, input hardware, and OpenGL
driver.

00:05:24.340 --> 00:05:28.120
Screen size is really easy, actually, because
the Android framework gives you tons of tools

00:05:28.120 --> 00:05:32.210
for dealing with different screen sizes. Basically
you can query the size of the screen, and

00:05:32.210 --> 00:05:37.020
if you are using OpenGL you can set your view
bore to that size. It's not very hard. You

00:05:37.020 --> 00:05:40.470
can also use the alternative resource system
to load different size assets and go all crazy

00:05:40.470 --> 00:05:43.780
if you want to. But if you want to keep it
simple, managing multiple screen sizes is

00:05:43.780 --> 00:05:48.530
not very difficult.
Input hardware is a little trickier because

00:05:48.530 --> 00:05:53.180
some of these phones have a track ball, some
have a D-pad, some have a keyboard, some have

00:05:53.180 --> 00:05:59.620
screens with multi-touch, some don't. Some
have an optical track pad. That's a new thing.

00:05:59.620 --> 00:06:03.280
And for a game, a lot of the playability of
the game, regardless of the technology it

00:06:03.280 --> 00:06:08.710
employs, is going to be based on how well
the user can actually control the game itself.

00:06:08.710 --> 00:06:13.090
And the interface between the phone and the
user is going to determine a lot of the fun

00:06:13.090 --> 00:06:16.930
factor for your game.
So having a lot of different hardware means

00:06:16.930 --> 00:06:21.660
that you may have -- you may think you have
a significant challenge to support all these

00:06:21.660 --> 00:06:25.950
devices, but actually the API does a pretty
good job of standardizing all these different

00:06:25.950 --> 00:06:31.030
types of inputs into two types of input events:
motion events and key events. And I will talk

00:06:31.030 --> 00:06:36.460
at some length later about how I manage to
sort of try to support all of these different

00:06:36.460 --> 00:06:42.120
types of diverse input systems for my game.
And you can be pretty much guaranteed that

00:06:42.120 --> 00:06:46.120
all devices are going to have a touch screen,
accelerometer, orientation sensors, things

00:06:46.120 --> 00:06:49.080
like that.
So if you can make a game that only relies

00:06:49.080 --> 00:06:54.930
on those things, then you are going to run
everywhere without any modification.

00:06:54.930 --> 00:06:58.560
OpenGL driver. The thing here is that these
devices are built by different people and

00:06:58.560 --> 00:07:02.860
they have different back ends, and the drivers
are written mostly by the OEMs, so those things

00:07:02.860 --> 00:07:09.330
are also different. So for example the Nexus
One uses a Qualcomm back end which as an ATI

00:07:09.330 --> 00:07:13.890
graphics back end in that, and that driver
supports ATITC texture compression.

00:07:13.890 --> 00:07:20.090
The Droid has a power VR back end. That thing
supports PVRTC texture compression, and they

00:07:20.090 --> 00:07:26.980
are not compatible. If you wanted to use texture
compression, you can ship versions of textures

00:07:26.980 --> 00:07:30.280
that have both. You can choose not to use
texture compression. That's what I did. Or

00:07:30.280 --> 00:07:37.030
you can use ETC1, which is the emerging standard
amongst OpenGL ES compatible devices.

00:07:37.030 --> 00:07:41.830
That's the big driver delta that you probably
want to be aware of, is this texture format

00:07:41.830 --> 00:07:46.900
issue.
Almost the entire world at this point is ATITC

00:07:46.900 --> 00:07:51.740
backed, and the Droid is the outlier with
PVRTC. I'm sure that in the future, there

00:07:51.740 --> 00:07:58.020
will be more. ETC1 is probably the way to
go here. It seems like it's the simplest,

00:07:58.020 --> 00:08:01.960
most standard solution. It's also not the
best format. Doesn't support alpha. There

00:08:01.960 --> 00:08:06.060
are some other problems with it. But that's
probably something to be cognizant of when

00:08:06.060 --> 00:08:09.520
you are developing.
For my part, I actually didn't use any texture

00:08:09.520 --> 00:08:13.780
compression. I just loaded all the textures
raw, and it was fine.

00:08:13.780 --> 00:08:16.920
Some of these devices support OpenGL 1.1,
some support 2.0. That's something you ought

00:08:16.920 --> 00:08:20.420
to be cognizant of.
If you are writing a shader based OpenGL 2.0

00:08:20.420 --> 00:08:24.350
game, obviously it's not going to run on the
first generation of devices that don't support

00:08:24.350 --> 00:08:29.540
OpenGL ES 2.0.
And also, GL extensions is a string that you

00:08:29.540 --> 00:08:34.260
can query from OpenGL. It tells you what the
particular device you are running on supports

00:08:34.260 --> 00:08:38.830
above and beyond the spec. So if you are going
to use extensions, and I actually use several

00:08:38.830 --> 00:08:43.729
of them, to get higher performance, you need
to query the string before you start using

00:08:43.729 --> 00:08:47.080
it. Things like what texture format are supported
will show up in the string.

00:08:47.080 --> 00:08:53.480
So that's the sort of standard way for OpenGL
ES to allow device specific extensions. You

00:08:53.480 --> 00:08:56.150
should check to see if they are available
if you want to use them and then fall back

00:08:56.150 --> 00:09:01.560
on the regular spec if they are not.
The other thing to consider is that Android

00:09:01.560 --> 00:09:06.560
versions in the wild are different. There's
basically three versions available in the

00:09:06.560 --> 00:09:12.680
world right now. That's Android 2.1, Android
1.5 and Android 1.6. From a game developer's

00:09:12.680 --> 00:09:17.750
perspective, there is not a whole lot of difference
between these three versions. Android 1.5

00:09:17.750 --> 00:09:22.130
basically gives you everything you would need
the to build most every game in the world.

00:09:22.130 --> 00:09:27.060
The big difference between Android 1.5 and
Android 1.6 as far as you're concerned is

00:09:27.060 --> 00:09:30.090
Android 1.6 added support for different sized
screens.

00:09:30.090 --> 00:09:35.779
So Android 1.5, every device is guaranteed
to be HVGA. From Android 1.6 on, they can

00:09:35.779 --> 00:09:38.731
be different sizes.
The way that works in practice is, when you

00:09:38.731 --> 00:09:42.950
query the size of the screen from the framework,
if you're running in Android 1.6, you'll get

00:09:42.950 --> 00:09:46.930
a value that might not be HVGA.
And if you're in 1.5, you'll always get HVGA

00:09:46.930 --> 00:09:49.580
values.
It's a pretty simple step up.

00:09:49.580 --> 00:09:53.870
In 2.0, we produced support for our OpenGL
ES 2.0.

00:09:53.870 --> 00:09:55.311
That's something that game developers usually
care about.

00:09:55.311 --> 00:10:01.400
There's also multitouch APIs in 2.0.
Actually, Android, because you can write almost

00:10:01.400 --> 00:10:05.870
your entire game on Android 1.5, it's pretty
easy to be backwards compatible and cover

00:10:05.870 --> 00:10:09.800
the entire range of devices.
If you target Android 1.5 or 1.6, that's a

00:10:09.800 --> 00:10:13.530
pretty good way to go.
You can see they're pretty big parts of this

00:10:13.530 --> 00:10:16.980
pie.
You can also do things like target Android

00:10:16.980 --> 00:10:22.260
2 and say that your MIN SDK is 1.5 and then
use Java Reflection to make sure that, say,

00:10:22.260 --> 00:10:24.460
the multitouch APIs are there before you call
them.

00:10:24.460 --> 00:10:27.510
You have quite a lot of flexibility in this
case.

00:10:27.510 --> 00:10:31.800
But generally, the message here is, you know,
you don't want to forget about Android 1.5

00:10:31.800 --> 00:10:36.840
devices or Android 1.6 devices, because they're
a big segment of the market.

00:10:36.840 --> 00:10:39.722
So the big question that -- I work with a
lot of game developers.

00:10:39.722 --> 00:10:42.580
The big question they always have is, so what's
the high end?

00:10:42.580 --> 00:10:48.150
What's the upper bound for performance?
So what I did is, I wrote a 3D -- sort of

00:10:48.150 --> 00:10:53.480
simple 3D profiler to see what these kind
of new devices, particularly I was interested

00:10:53.480 --> 00:10:58.300
in the second-generation devices, to see what
they could do.

00:10:58.300 --> 00:11:01.860
And this is a very simple test.
What it is is it takes a height map and extrudes

00:11:01.860 --> 00:11:05.921
it in 3D.
And I can tune the complexity of the scene

00:11:05.921 --> 00:11:08.210
up.
I can say you divide this ten times or I want

00:11:08.210 --> 00:11:11.760
you to divide the height map 1,000 times.
So the number of verts in the stream can be

00:11:11.760 --> 00:11:14.490
scaled.
I also have controls for scaling OpenGL state,

00:11:14.490 --> 00:11:17.220
like, texture size and mip maps and things
like that.

00:11:17.220 --> 00:11:19.110
And those aren't really included in this particular
test.

00:11:19.110 --> 00:11:25.921
I was looking just at seeing complexity.
And what I found was that all of these devices

00:11:25.921 --> 00:11:29.779
 -- I looked at the Liquid, the Nexus One,
the Droid, and the Xperia, and just to have

00:11:29.779 --> 00:11:33.860
one phone representing the first generation
of devices, I have the HTC Magic in here,

00:11:33.860 --> 00:11:36.950
too.
What I found is, basically, regardless of

00:11:36.950 --> 00:11:40.710
how many verts I draw, they all perform at
about the same speed.

00:11:40.710 --> 00:11:44.350
The exception here is the Magic.
You can see that it starts out very fast,

00:11:44.350 --> 00:11:47.101
at 500 verts.
It's able to render 60 frames a second.

00:11:47.101 --> 00:11:51.120
Then it linearly grows, as you might expect
it to.

00:11:51.120 --> 00:11:55.610
The other devices, like, especially the Xperia
 -- that's the green line there -- the Xperia's

00:11:55.610 --> 00:11:59.210
speed is probably linked to its refresh rate.
'Cause even if I draw a scene with nothing

00:11:59.210 --> 00:12:04.089
in it, it takes 32 milliseconds.
That red line on this graph, by the way -- the

00:12:04.089 --> 00:12:10.899
bottom axis here is verts per frame, and the
"Y" axis is frame time.

00:12:10.899 --> 00:12:14.990
And if you've done game development before,
you probably know that in order to render

00:12:14.990 --> 00:12:18.800
at 30 frames a second, you need to complete
your frame in under 32 milliseconds.

00:12:18.800 --> 00:12:22.250
The red line is the 32-second millisecond
barrier.

00:12:22.250 --> 00:12:28.300
Any slower and the game may not be playable,
especially if it's a, you know, kind of action-packed

00:12:28.300 --> 00:12:32.330
game or something that requires quick reflexes.
If it's a slower-paced game or something that

00:12:32.330 --> 00:12:36.170
is not animation-heavy or the screen isn't
changing every frame, then you can certainly

00:12:36.170 --> 00:12:40.270
get away with slower than 30 frames a second.
But most games make 30 frames a second their

00:12:40.270 --> 00:12:43.810
target.
That's what I've put on this graph.

00:12:43.810 --> 00:12:47.190
So why doesn't this time change?
Why doesn't the scene complexity have much

00:12:47.190 --> 00:12:51.380
to do with the time?
I think this is because, as I mentioned earlier,

00:12:51.380 --> 00:12:54.910
most of the time, for this frame is actually
being spent copying pixels, not rasterizing

00:12:54.910 --> 00:12:57.930
the scene.
That's because these devices all have big

00:12:57.930 --> 00:13:02.610
screens and are mostly fill-bound.
Good news is that even if we render a pretty

00:13:02.610 --> 00:13:03.980
complicated scene, it doesn't cost us any
more.

00:13:03.980 --> 00:13:08.121
If you target 30 frames a seconds, you should
be able to get quite a lot of performance

00:13:08.121 --> 00:13:13.360
out of these devices at that speed.
If I increase the number of verts in the scene,

00:13:13.360 --> 00:13:16.890
you know, it's pretty much the same story.
Things start to get slower, and all these

00:13:16.890 --> 00:13:20.180
devices pass that 32-millisecond boundary
eventually.

00:13:20.180 --> 00:13:24.790
I kind of binary-searched this space to find
out where the maximum bar was.

00:13:24.790 --> 00:13:29.891
The average, to me, seems like about 27,000
textured unlit colored verts per frame.

00:13:29.891 --> 00:13:34.029
There's a couple of devices that can do a
little bit better than that, but that seems

00:13:34.029 --> 00:13:37.960
to be a good target.
This code is all open source.

00:13:37.960 --> 00:13:40.450
It's on apps for Android.
I have the link at the end.

00:13:40.450 --> 00:13:42.810
If you'd like to reproduce this on your device,
you can do that.

00:13:42.810 --> 00:13:47.610
There's also a bunch of other tests and stuff
in this code that you can use.

00:13:47.610 --> 00:13:53.529
So the message here is, on the low-end devices,
if your target is 30 frames a second, you

00:13:53.529 --> 00:13:56.709
can push about 5,000 verts per frame.
If your target is the high-end devices, you

00:13:56.709 --> 00:14:02.190
can push almost 30,000 verts per frame, looking
at five, five and a half X difference.

00:14:02.190 --> 00:14:06.311
But the high-end devices are only 40% of the
market at the moment.

00:14:06.311 --> 00:14:10.520
You'd like to be able to target everything.
You need to scale from the low end to the

00:14:10.520 --> 00:14:13.839
high end.
And, actually, thinking about writing code

00:14:13.839 --> 00:14:17.260
that can scale from the low end to the high
end in order to sort of make your user base

00:14:17.260 --> 00:14:22.180
as large as possible has a lot of benefits
even for the high end.

00:14:22.180 --> 00:14:26.390
Just real quickly, I kind of want to make
a point about level of detail.

00:14:26.390 --> 00:14:31.370
Level of detail, the idea here is that if
things are farther away in the scene, like

00:14:31.370 --> 00:14:35.680
the further away from the point of view of
the camera, then they're smaller on the screen.

00:14:35.680 --> 00:14:40.160
They're taking up fewer total number of pixels.
In that case, they don't need to be as a high

00:14:40.160 --> 00:14:43.839
resolution mesh as they would if they were
closer to the scene.

00:14:43.839 --> 00:14:48.230
So in this case, what I did is I took the
test and I instanced a little programmer art

00:14:48.230 --> 00:14:53.430
hill here and made it so that as the hills
get further out in the background, they become

00:14:53.430 --> 00:14:58.399
simpler meshes.
The image on the left here has no level of

00:14:58.399 --> 00:15:02.060
detail turned on.
The image all the way on the right has level

00:15:02.060 --> 00:15:05.370
of detail turned on pretty aggressively.
You can see, you know, if you look at those

00:15:05.370 --> 00:15:08.381
mountains in the background on the right that
kind of look kind of crappy, because this

00:15:08.381 --> 00:15:13.290
is basically programmer 3D art.
But if you had a little dune buggy or something

00:15:13.290 --> 00:15:16.250
that was right in the center of the frame
that the user's eye was targeted on, I don't

00:15:16.250 --> 00:15:19.120
think they would notice.
And even though these scenes look pretty similar,

00:15:19.120 --> 00:15:25.000
the actual performance is pretty different.
So I highly recommend thinking about scaling

00:15:25.000 --> 00:15:27.971
between the low end and the high end.
You can do this with complexity of the scene,

00:15:27.971 --> 00:15:31.070
like I'm doing here.
You can also do it with mip mapping and other

00:15:31.070 --> 00:15:34.950
techniques to say, stuff that is further in
the background, make it simpler.

00:15:34.950 --> 00:15:39.420
And if you're going to support these lower-end
devices, one way to do that is just to chop

00:15:39.420 --> 00:15:44.230
off the high end and allow your device to
be lower resolution on these lower-res devices.

00:15:44.230 --> 00:15:47.750
They have smaller screens, anyway.
Also, if you use artists to generate the stuff,

00:15:47.750 --> 00:15:54.420
it looks a lot better.
I told you about what to expect in terms of

00:15:54.420 --> 00:15:59.810
performance, at least based on this test.
I told you about the two device classes you

00:15:59.810 --> 00:16:03.959
can think of as your baselines.
Now I want to give you a couple of best practices

00:16:03.959 --> 00:16:09.250
about how to actually achieve maximum performance.
This is mostly OpenGL-centric stuff.

00:16:09.250 --> 00:16:13.220
If you have done OpenGL, especially OpenGL
ES, on mobile devices before, I don't think

00:16:13.220 --> 00:16:17.660
you'll see any surprises here.
If you take one thing away about performance

00:16:17.660 --> 00:16:21.610
from this talk, it should be that you must
use VBOs.

00:16:21.610 --> 00:16:26.250
VBOs are vertex buffer objects.
That's vertex arrays that are stored on the

00:16:26.250 --> 00:16:30.400
video card in VRAM.
This is a huge performance improvement to

00:16:30.400 --> 00:16:33.140
these guys.
And they are almost universally supported.

00:16:33.140 --> 00:16:38.279
Now, that said, you want to have as view VBOs
as possible in memory at any given time, because

00:16:38.279 --> 00:16:41.060
switching between them is a pretty expensive
operation.

00:16:41.060 --> 00:16:44.180
Actually, all OpenGL state change is a pretty
expensive operation.

00:16:44.180 --> 00:16:47.779
So when optimizing a 3D scene, your mantra
should be, "Limit state change."

00:16:47.779 --> 00:16:51.190
There's no advantage to using fixed point
verts.

00:16:51.190 --> 00:16:54.070
You can test this with the height map profiler
code.

00:16:54.070 --> 00:16:57.899
Floating-point verts are actually faster in
most cases.

00:16:57.899 --> 00:17:00.970
I mentioned (inaudible) texture compression
is the most compatible across all of these

00:17:00.970 --> 00:17:05.559
OpenGL ES 2.0 devices.
It's not generally supported by the OpenGL

00:17:05.559 --> 00:17:09.480
ES 1.0, 1.1 devices.
If you're going to do 2D texture blitting

00:17:09.480 --> 00:17:12.490
to the screen, like you're drawing a 2D game
or you have (inaudible) elements, the draw

00:17:12.490 --> 00:17:19.809
texture extension is pretty much universally
supported and it is the fast path for 2D.

00:17:19.809 --> 00:17:23.140
And I mention that the WVGA devices are fill
bound, so your target should be 30 frames

00:17:23.140 --> 00:17:26.209
a second.
To use GL extensions to check what you have

00:17:26.209 --> 00:17:29.630
to scale between the low and the high end.
If you're using 2D games, if you're making

00:17:29.630 --> 00:17:32.980
a simple 2D game, especially if you're targeting
high-end devices, you can probably get away

00:17:32.980 --> 00:17:35.460
with just CPU drawing.
There's a whole system called Canvas that

00:17:35.460 --> 00:17:42.090
will copy the bit maps on main memory in CPU.
It's not horribly slow, but it has a lower

00:17:42.090 --> 00:17:45.900
high watermark on the low-end devices.
If your game is simple and doesn't need 30

00:17:45.900 --> 00:17:49.730
frames a second animation or not the entire
frame is changing every frame, that's something

00:17:49.730 --> 00:17:53.980
you can consider.
And if you decide to target those high-end

00:17:53.980 --> 00:18:00.910
devices that support OpenGL ES 2.0, then always
use OpenGL ES 2.0 instead of 1.0.

00:18:00.910 --> 00:18:06.780
Even though those devices are backwards compatible
GL ES 1.0, 1.1, they implement it as an emulation

00:18:06.780 --> 00:18:12.020
layer between sort of the OpenGL ES 1.1 spec
and the actual 2.0 hardware.

00:18:12.020 --> 00:18:15.981
So if have you a choice between 1 and 2 and
you are okay with cutting out the low end

00:18:15.981 --> 00:18:21.210
that doesn't support 2, always choose 2.
So on Replica Island, I used a combination

00:18:21.210 --> 00:18:25.510
of these methods to draw the scene.
This game, I worked really hard to make sure

00:18:25.510 --> 00:18:30.530
that it runs on pretty much every device out
there, even the G1.

00:18:30.530 --> 00:18:35.460
I developed most of the game on a G1.
I used the draw texture extension which I

00:18:35.460 --> 00:18:44.281
just mentioned for my 2D sprites.
It also includes the background image, which

00:18:44.281 --> 00:18:47.900
is basically a static texture that scrolls
a little bit.

00:18:47.900 --> 00:18:53.970
The tile layers themselves are -- the foreground
is actually made out of tiles.

00:18:53.970 --> 00:18:58.970
And I rendered that using VBOs.
And I have spoken before about the different

00:18:58.970 --> 00:19:01.630
methods that I experimented with to render
this background efficiently.

00:19:01.630 --> 00:19:07.170
And I've actually come up with another method,
which is what I shipped with, which was to

00:19:07.170 --> 00:19:11.480
take the entire level and wrap it up into
a single large VBO and then draw scan lines

00:19:11.480 --> 00:19:14.900
of tiles out of it.
You can actually draw a subset of vertices

00:19:14.900 --> 00:19:17.750
within a single VBO.
It's much faster than having separate VBOs.

00:19:17.750 --> 00:19:21.390
This worked out really well for me.
I have a single texture to bind, a single

00:19:21.390 --> 00:19:24.210
buffer to bind, and then I can draw any part
of the level, depending on where the camera

00:19:24.210 --> 00:19:27.540
is looking.
Okay.

00:19:27.540 --> 00:19:30.720
We talked about performance.
Let's move on to game architecture.

00:19:30.720 --> 00:19:37.990
I want to talk a little bit about how you
should go around architecting your software

00:19:37.990 --> 00:19:42.780
for Android games.
I'm an advocate of this dual-thread approach.

00:19:42.780 --> 00:19:46.799
The idea here is, you have a game thread and
a render thread, and they're separated.

00:19:46.799 --> 00:19:51.500
The game thread is doing all your nongraphics
simulation update, AI, collision detection,

00:19:51.500 --> 00:19:56.290
physics, whatever, and then it's telling the
render thread what to draw for the next frame.

00:19:56.290 --> 00:20:01.200
So if you look at this chart, we have -- Android
framework is kind of at the top, and it's

00:20:01.200 --> 00:20:05.960
going to send input events to your activity
thread, which is basically your main UI thread.

00:20:05.960 --> 00:20:10.800
All Android applications have this.
And the activity thread is going to be dormant

00:20:10.800 --> 00:20:14.380
until it gets woken up by an input event.
And I think you should just take that input

00:20:14.380 --> 00:20:19.380
event and pass it on to your game to let the
game thread figure out what to do with it.

00:20:19.380 --> 00:20:22.049
The game thread and the rendering thread are
going to be running in parallel.

00:20:22.049 --> 00:20:26.580
The reason to split these is that the rendering
thread is going to periodically have to block

00:20:26.580 --> 00:20:29.870
on hardware.
If you're able to run fast enough that you're

00:20:29.870 --> 00:20:33.530
ready to draw before the previous frame is
complete, then the rendering thread is going

00:20:33.530 --> 00:20:37.700
to actually stop and wait for the hardware
to say, it's ready to start it, issuing commands

00:20:37.700 --> 00:20:41.091
again.
So during that time, you know, this is a game,

00:20:41.091 --> 00:20:44.270
there's no reason to leave the CPU idle.
We might as well have another thread doing

00:20:44.270 --> 00:20:46.799
the next frame of simulation running at the
same time.

00:20:46.799 --> 00:20:55.830
This is basically how Replica Island is implemented.
If you follow this sort of approach or if

00:20:55.830 --> 00:20:59.590
you decide generally that you would like to
have a separated rendering thread, which I

00:20:59.590 --> 00:21:03.530
highly recommend, you can use this GL surface
view class which we've written for you.

00:21:03.530 --> 00:21:07.790
This a class that does all the setup and teardown
for OpenGL.

00:21:07.790 --> 00:21:11.860
It will manage all of your OpenGL state through
pausing and stuff like that.

00:21:11.860 --> 00:21:16.200
And it basically just manages this whole thread.
It gives you a very simple interface to load

00:21:16.200 --> 00:21:20.282
textures and to set up the view port and to
actually draw the frame.

00:21:20.282 --> 00:21:27.179
Just to give you an idea of how simple this
is, this is a Android application.

00:21:27.179 --> 00:21:31.350
This is pretty much all the code you would
need to just get something up on the screen

00:21:31.350 --> 00:21:33.440
that's rendering with OpenGL using GL surface
view.

00:21:33.440 --> 00:21:39.990
The only part that I actually have to write
other than this sort of activity shell itself

00:21:39.990 --> 00:21:44.429
is this part that says "awesome game renderer"
that's going to render my awesome game.

00:21:44.429 --> 00:21:47.890
Plug that thing into the GL surface view and
then it's ready to go.

00:21:47.890 --> 00:21:52.360
Just needs to know about pause events.
So what's the GL surface view renderer?

00:21:52.360 --> 00:21:54.530
Well, it's basically these three call-backs
that I just mentioned.

00:21:54.530 --> 00:21:58.800
You get a call-back when the surface is created.
That's when you load your textures and set

00:21:58.800 --> 00:22:03.940
up your VBOs and any other work that you need
to do that requires writing to VRAM.

00:22:03.940 --> 00:22:09.220
You get a call-back when the surface is changed.
That's when your view port is ready to go,

00:22:09.220 --> 00:22:12.720
either because it's been ready to go the first
time or because the phone has been rotated

00:22:12.720 --> 00:22:14.860
and you want to handle orientation changes,
things like that.

00:22:14.860 --> 00:22:18.230
Set your viewpoint.
Then you get a call-back to undraw frame every

00:22:18.230 --> 00:22:22.470
frame that you want to draw.
That's pretty simple; right?

00:22:22.470 --> 00:22:25.560
Replica Island uses this.
Pretty much every 3D game on the market uses

00:22:25.560 --> 00:22:27.400
this.
It saves you a lot of time.

00:22:27.400 --> 00:22:31.150
You should use it.
Let's say you don't really want to write your

00:22:31.150 --> 00:22:37.370
game in Java or you have your game written
in C++ and you want to bring it over to Android.

00:22:37.370 --> 00:22:40.560
You can do this with NDK.
The way I would suggest is to use the same

00:22:40.560 --> 00:22:43.179
framework.
Use Java threads to split this stuff up.

00:22:43.179 --> 00:22:47.780
You still are going to have the same problem
with the hardware blocking sometimes.

00:22:47.780 --> 00:22:50.070
You want to separate rendering out from game
simulation.

00:22:50.070 --> 00:22:53.031
But you don't have to render -- implement
the rendering or the game (inaudible) in Java.

00:22:53.031 --> 00:22:56.280
You can just implement it in native code.
I would set up these up with regular Java

00:22:56.280 --> 00:23:00.970
threads and call in to native code to implement
the content of these threads.

00:23:00.970 --> 00:23:06.250
The way that would change the example I just
showed you a minute ago might be like this.

00:23:06.250 --> 00:23:12.419
In this case, I've taken this awesome game
renderer and added some sort of native prototypes.

00:23:12.419 --> 00:23:16.059
I'm assuming that I wrote this code in C++
and compiled it with the NDK and then I'm

00:23:16.059 --> 00:23:19.490
loading the library here in this little static
section.

00:23:19.490 --> 00:23:24.440
And, basically, I'm just going to call similar
functions that I've defined in my own C code

00:23:24.440 --> 00:23:28.580
from the Java call-backs.
You notice that the GL state is shared here.

00:23:28.580 --> 00:23:36.170
I can set stuff up in GL with Java and then
refer to it in C land or vice versa.

00:23:36.170 --> 00:23:39.830
It's all the same OpenGL context.
So I don't actually have to pass anything.

00:23:39.830 --> 00:23:44.049
You can see Java gets a GL pointer.
But there's nothing to pass down to the actual

00:23:44.049 --> 00:23:51.450
native code in this case.
This is how I recommend users go about setting

00:23:51.450 --> 00:23:54.750
up your Android games if you have a lot of
code that's already written or that you're

00:23:54.750 --> 00:23:58.500
going to write in C++.
Now, part of the reason that I'm recommending

00:23:58.500 --> 00:24:02.100
this, some people are, like, "Why do I have
to have this whole Java thread nonsense?

00:24:02.100 --> 00:24:04.309
I wrote my game already.
It's good to go."

00:24:04.309 --> 00:24:10.309
Is because, well, Android's a multi-processing
operating system.

00:24:10.309 --> 00:24:15.030
And because of that, there are some cases
that you won't see on other mobile devices

00:24:15.030 --> 00:24:20.050
that aren't multiprocessing.
One of them is this pausing problem that I

00:24:20.050 --> 00:24:23.049
want to talk about.
And what that is is, say I'm running this

00:24:23.049 --> 00:24:26.400
game.
I have on the left here, you know, sort of

00:24:26.400 --> 00:24:28.590
the game output.
It's a scene from the game.

00:24:28.590 --> 00:24:33.191
And on the right, I have something which is
what I imagine the contents of VRAM to be,

00:24:33.191 --> 00:24:37.320
just a bunch of textures that I've loaded.
I'm playing and everything is great and I've

00:24:37.320 --> 00:24:41.240
set it all up and everything is fine.
And then I decide I'm going to go home.

00:24:41.240 --> 00:24:45.740
And I check my e-mail.
And then I may run another OpenGL-intensive

00:24:45.740 --> 00:24:49.010
application.
And at some point, what happens is, depending

00:24:49.010 --> 00:24:53.710
on how much memory my device has, at some
point, you know, maybe the VRAM that I allocated

00:24:53.710 --> 00:24:59.160
for all of those textures in my game, it needs
to be used, maybe by this profiler test.

00:24:59.160 --> 00:25:02.919
In that case, you know, what Android is going
to do is leave my game running but go ahead

00:25:02.919 --> 00:25:07.940
and give the VRAM to the other process.
So when my game comes back, all the VRAM is

00:25:07.940 --> 00:25:11.700
basically toast.
If you use GL surface view, you will get a

00:25:11.700 --> 00:25:15.850
call-back to on surface created in this case.
That means it's time to reload your texture

00:25:15.850 --> 00:25:19.600
and buffers.
And some games are not built with the idea

00:25:19.600 --> 00:25:22.820
that the texture handles that they've allocated
in VRAM are going to change in the future.

00:25:22.820 --> 00:25:24.710
So this is something you definitely need to
be cognizant of.

00:25:24.710 --> 00:25:29.169
But if you use GL surface view, it will work
out all the details.

00:25:29.169 --> 00:25:33.650
When you come back from a pause, if your GL
context is dead, it will tell you and give

00:25:33.650 --> 00:25:37.340
you a chance to load textures and buffers
again.

00:25:37.340 --> 00:25:41.720
Now, on Replica Island, I actually made it
more complicated on myself, because GL surface

00:25:41.720 --> 00:25:46.010
view actually proactively throws state away
when it pauses, on the theory other applications

00:25:46.010 --> 00:25:50.340
need to use it.
But I had a case where I wanted the GL data

00:25:50.340 --> 00:25:53.799
to stick around while I brought up another
activity.

00:25:53.799 --> 00:25:56.500
That was this dialogue box case.
The game is paused in the background, and

00:25:56.500 --> 00:25:58.470
this dialogue box activity has come to the
foreground.

00:25:58.470 --> 00:26:03.039
But I really don't want to reload textures
just when a dialogue box pops up.

00:26:03.039 --> 00:26:08.500
So I modified GL surface view in this case
to only reload textures when the context is

00:26:08.500 --> 00:26:12.780
detected to be lost.
That works out fine, too.

00:26:12.780 --> 00:26:16.650
While I'm talking about things I learned on
Replica Island, I want to sort of shift gears

00:26:16.650 --> 00:26:21.549
to talk about something that's not graphics-related.
And that was input customization.

00:26:21.549 --> 00:26:26.200
This is something that I did not anticipate.
Users really, really want to be able to customize

00:26:26.200 --> 00:26:29.679
their controls.
And the game, just if you haven't tried it,

00:26:29.679 --> 00:26:32.679
the game is mostly track ball, touch screen-based
game.

00:26:32.679 --> 00:26:37.520
You can play it with a D pad or now you can
play it with the keyboard.

00:26:37.520 --> 00:26:41.920
And I added some tilt controls in there after
a couple of updates to allow people like Xperia

00:26:41.920 --> 00:26:45.230
owners, who had no track ball or D pad, to
play.

00:26:45.230 --> 00:26:48.780
What I found out is, first of all, there are
a lot of devices with a lot of different controls

00:26:48.780 --> 00:26:50.700
out there.
And all of those users want to be able to

00:26:50.700 --> 00:26:52.752
play my game.
And all of those users are going to want to

00:26:52.752 --> 00:26:56.419
be able to play your games as well.
So allowing people to customize the controls

00:26:56.419 --> 00:27:00.710
to fit their phone is a good idea.
Above and beyond that, what surprised me was,

00:27:00.710 --> 00:27:03.990
users actually want to be able to customize
their controls even if they have the default

00:27:03.990 --> 00:27:06.110
setup that you had in mind when you built
it.

00:27:06.110 --> 00:27:10.850
I have users telling me that they have a Droid
that has a D pad and has a keyboard, and they'd

00:27:10.850 --> 00:27:13.460
rather use the tilt controls because that's
what they are comfortable with.

00:27:13.460 --> 00:27:17.400
That's something I didn't anticipate.
I've made -- since I released the game in

00:27:17.400 --> 00:27:21.360
March of this year, I've made four updates.
All of them have been to extend the amount

00:27:21.360 --> 00:27:26.211
of input customization that I support.
Side effect of that is that my input system

00:27:26.211 --> 00:27:29.090
got kind of complicated.
I started out with a pretty simple system

00:27:29.090 --> 00:27:32.419
where the game wants to have a query-based
interface.

00:27:32.419 --> 00:27:35.950
The game wants to be able to say, when was
the last time the jump button was pushed?

00:27:35.950 --> 00:27:39.960
Or how long has the jump button been down?
Or what was the last vector of the track ball

00:27:39.960 --> 00:27:41.720
roll? Something like that.
Android doesn't really give you events in

00:27:41.720 --> 00:27:42.720
that way, doesn't really provide a query interface
for you.

00:27:42.720 --> 00:27:43.720
It says, "Here's a delta. Update."
You know, Android doesn't really give you

00:27:43.720 --> 00:27:47.380
events in that way. It doesn't really provide
a query interface for you. It says here is

00:27:47.380 --> 00:27:52.169
a delta update. The track ball has moved a
little more or this keyboard button has come

00:27:52.169 --> 00:27:54.090
up.
So I put a little system in between those

00:27:54.090 --> 00:28:00.590
two just to record the current hardware state.
In the initial version, all it did was really

00:28:00.590 --> 00:28:05.730
expose a track ball API to the game. So the
game could say what's the current track ball

00:28:05.730 --> 00:28:10.280
state. And halfway through development I added
a couple of other APIs for what is the touch

00:28:10.280 --> 00:28:12.240
screen doing and what's the orientation sensor
doing, and that's pretty much how the first

00:28:12.240 --> 00:28:16.370
version shipped.
And then I started to add customization stuff

00:28:16.370 --> 00:28:21.410
and I realized I wanted to add heuristics
in there because maybe the track ball is too

00:28:21.410 --> 00:28:26.400
sensitive on some devices, so I wanted to
have a heuristic for tuning where the dead

00:28:26.400 --> 00:28:29.590
zone is.
I didn't really want to increase the number

00:28:29.590 --> 00:28:32.841
of APIs I supply to the game because then
the game is going to get ugly and complicated,

00:28:32.841 --> 00:28:36.370
so instead I made the input system really
ugly and complicated.

00:28:36.370 --> 00:28:40.669
And this is horrible; right? Like if I had
planned on this, I could have done it better

00:28:40.669 --> 00:28:46.100
the first time out, but I didn't plan on it.
So in the most recent update, I ripped all

00:28:46.100 --> 00:28:52.220
this crap out and rewrote it like this.
Now there's a generic input system that takes

00:28:52.220 --> 00:28:55.640
input state from the Android framework and
records it but doesn't do anything with it.

00:28:55.640 --> 00:29:00.120
And there's a separate interface called the
input interface that takes the stuff from

00:29:00.120 --> 00:29:05.130
the input system and applies whatever heuristics
or filters or configuration control options

00:29:05.130 --> 00:29:10.200
and provides a game-specific API. Jump button
is down, you know, the user wants to go left.

00:29:10.200 --> 00:29:13.049
Things like that.
This is all open source. All the stuff is

00:29:13.049 --> 00:29:17.000
up code.google.com. So if you are going to
make a game and you would like to have the

00:29:17.000 --> 00:29:21.730
same sort of query interface, you can just
grab this input system and reuse it.

00:29:21.730 --> 00:29:24.300
You can probably write your own input interface
depending on what inputs your game wants.

00:29:24.300 --> 00:29:29.220
This is something I had not anticipated that
I got a lot of bang for the buck out of for

00:29:29.220 --> 00:29:36.820
my users.
So last section here, is I'd like to talk

00:29:36.820 --> 00:29:46.360
about Android Market for games. And I didn't
really know a lot about Android Market for

00:29:46.360 --> 00:29:51.900
video games. I knew what games were up there,
and I knew that there were different ways

00:29:51.900 --> 00:29:57.340
to try to promote games. And I didn't really
have any idea what makes a successful game

00:29:57.340 --> 00:30:02.540
in terms of Android Market user base.
So I tried a bunch of stuff. The Replica Island

00:30:02.540 --> 00:30:08.461
project, the entire point was to be an experiment.
First, can I write this sort of game on Android,

00:30:08.461 --> 00:30:12.700
and then how do I write it. And then finally,
how do I publish it? What's the best way to

00:30:12.700 --> 00:30:17.630
do that?
So the first thing I did is I took a look

00:30:17.630 --> 00:30:19.991
at the traits of the most successful games
on Android Market.

00:30:19.991 --> 00:30:28.220
This is a pretty small view of the market;
right? This is only the top ten titles across

00:30:28.220 --> 00:30:32.210
all game categories, and I sorted them by
most popular, which is the market ranking,

00:30:32.210 --> 00:30:38.430
and most downloaded.
And basically what I could see is that pretty

00:30:38.430 --> 00:30:43.470
much all of these apps are backwards compatible
to 1.5. That's a big deal. There's a lot of

00:30:43.470 --> 00:30:48.400
users who are still back on 1.5 and 1.6.
So the successful apps, at least in the top

00:30:48.400 --> 00:30:54.940
ten, almost all support that.
Almost everybody has screen shots in their

00:30:54.940 --> 00:31:00.330
market listings. That's a really big deal,
too because users want to see what it is,

00:31:00.330 --> 00:31:02.730
even if it's a free app, they want to see
what they are getting before they download

00:31:02.730 --> 00:31:05.110
it.
You will see the most downloaded free list

00:31:05.110 --> 00:31:09.460
here actually has the fewest number of screen
shots. It's only 50%. My theory there is a

00:31:09.460 --> 00:31:14.750
lot of those apps predate our market screen
shot system. They have been up there such

00:31:14.750 --> 00:31:19.630
a long time that a lot of users download them
before they are even screen shots.

00:31:19.630 --> 00:31:23.179
And for paid apps -- I was making a free app
so this wasn't particularly relevant to me,

00:31:23.179 --> 00:31:28.090
but I was interested. For paid apps, most
of them supply a free version, some sort of

00:31:28.090 --> 00:31:32.570
light version, free demo, something like that.
And it looks like the average price for the

00:31:32.570 --> 00:31:39.169
most popular apps is less than 3.50.
So my idea was, well, I'm making this game.

00:31:39.169 --> 00:31:42.169
I want it to be successful. It's going to
be free. I am going to open source it anyway.

00:31:42.169 --> 00:31:46.620
So it doesn't really matter. I am not interested
in making money on it, per se, but I would

00:31:46.620 --> 00:31:53.130
like to understand as an experiment what I
need to do to make this thing popular.

00:31:53.130 --> 00:31:57.890
I gave a talk here at Google I/O last year,
and I mentioned this game and I showed a demo,

00:31:57.890 --> 00:31:59.820
and I made the mistake of saying it was almost
done.

00:31:59.820 --> 00:32:04.700
It's all up on YouTube now and it's totally
closed captioned of me saying it's almost

00:32:04.700 --> 00:32:08.499
done. And I had this function in my head that
looked like this, I guess.

00:32:08.499 --> 00:32:10.970
[ Laughter ]
&gt;&gt;Chris Pruett: Because I really released

00:32:10.970 --> 00:32:16.270
it like two months ago. The lesson here is
don't ever say it's almost done.

00:32:16.270 --> 00:32:20.030
The reason I didn't release it is because
I wasn't ready to. And part of the reason

00:32:20.030 --> 00:32:23.779
for that was that I didn't know anything about
marketing and I had a lot to learn.

00:32:23.779 --> 00:32:30.049
My initial marketing plan was to make a Web
site, to have a blog about it, and to send

00:32:30.049 --> 00:32:35.740
out some press releases to a couple of Android
blogs, like five of them, and to have a QR

00:32:35.740 --> 00:32:37.980
code that you could scan to download the game.
That was it.

00:32:37.980 --> 00:32:44.309
And the base plan for this was that my marketing
spend was going to be zero dollars. That was

00:32:44.309 --> 00:32:48.950
the most important part to me.
Actually, it turned out that I didn't have

00:32:48.950 --> 00:32:54.230
a lot of confidence in writing the press release
myself, so I got this guy Nicholai, my PR

00:32:54.230 --> 00:32:59.100
manager, to write it for me. And Nicholai
said he would do it pretty much for free as

00:32:59.100 --> 00:33:04.190
long as I bought him the entire set of Ming's
Quest DVDs off Amazon.com.

00:33:04.190 --> 00:33:08.400
So I looked and that cost 39.99, so my marketing
spend was up to 39.99.

00:33:08.400 --> 00:33:12.230
So we did it, and actually he wrote the press
releases and sent them out and it was pretty

00:33:12.230 --> 00:33:16.730
successful. And once we got past our agreed
upon cap, he said where is my Ming's Quest

00:33:16.730 --> 00:33:21.369
DVDs? And I went back and looked on Amazon
again and I had made a mistake. They don't

00:33:21.369 --> 00:33:25.580
have a Ming's Quest DVD set. I was looking
at simply Ming's, and so my marketing expense

00:33:25.580 --> 00:33:29.940
went back to zero dollars.
Sorry, Nicholai.

00:33:29.940 --> 00:33:37.320
I ended up releasing the app in March of this
year and it's done he pretty well. I passed

00:33:37.320 --> 00:33:41.669
half a million downloads within two months
which was very exciting. User feedback has

00:33:41.669 --> 00:33:45.390
been pretty good. I am at four and a half
out of five stars.

00:33:45.390 --> 00:33:52.029
I will show you the graph, hooray, volume,
but you can tell there are some points at

00:33:52.029 --> 00:33:57.520
which the angle of the graph changes, and
I wanted to talk about what those points were.

00:33:57.520 --> 00:34:01.600
The first ten days -- Like I said, Replica
Island is an experiment. My goal is to be

00:34:01.600 --> 00:34:05.451
able to use it in a case study at a talk like
this to tell you guys when you go out to make

00:34:05.451 --> 00:34:11.409
a real game, here is what you should do. I
had no idea it was going to be this well accepted.

00:34:11.409 --> 00:34:17.190
But as an experiment I decided to track the
difference between my zero-dollar marketing

00:34:17.190 --> 00:34:22.050
plan and organic growth.
So for the first ten days I didn't say anything.

00:34:22.050 --> 00:34:25.610
I launched the game. I just uploaded it to
market. I didn't write in my blog, I didn't

00:34:25.610 --> 00:34:28.661
talk about it. I was at another conference
and I mentioned to the people there that I

00:34:28.661 --> 00:34:33.030
had released it, so those 200 people there
knew I release. But there was no fanfare,

00:34:33.030 --> 00:34:37.169
no marketing, no nothing. Because I wanted
to see what would happen if I just uploaded

00:34:37.169 --> 00:34:40.840
it, said nothing about it.
The first ten days I got about 18,000 downloads.

00:34:40.840 --> 00:34:47.220
That seemed to be about the rate of organic
growth, which wasn't bad. Ten days on, I said

00:34:47.220 --> 00:34:53.149
okay, Nicholai, send out your press releases,
and he did. And you can see what happened

00:34:53.149 --> 00:34:58.150
here. We had one YouTube video and this press
release he wrote, and as soon as he sent that

00:34:58.150 --> 00:35:05.000
out, the angle went up a little bit. A bunch
of blogs were very nice and wrote about the

00:35:05.000 --> 00:35:08.240
game, and people looked at the YouTube link,
and a bunch of people re-tweeted it, and that

00:35:08.240 --> 00:35:16.970
was pretty cool. Gizmodo wrote an article
about it. That was cool. And the angle stayed

00:35:16.970 --> 00:35:22.241
pretty nice after that until I got featured
on Android Market. Full disclosure, I am part

00:35:22.241 --> 00:35:25.240
of the Android team. I didn't have anything
to do with the decision to feature Replica

00:35:25.240 --> 00:35:28.050
Island. I was very excited about it when it
happened.

00:35:28.050 --> 00:35:34.109
And that is what caused the graph to go to
its current angle, which is about 10,000 downloads

00:35:34.109 --> 00:35:40.160
a day.
Didn't actually help my download speed at

00:35:40.160 --> 00:35:42.722
all.
Some developers have come to me and said,

00:35:42.722 --> 00:35:47.700
"I'm worried that developers are going to
ship superfluous updates just so they can

00:35:47.700 --> 00:35:53.300
get into the 'just in' category." And these
were updates to add control options, so I

00:35:53.300 --> 00:35:56.740
thought they would be very high value, and
the market comments suggested users really

00:35:56.740 --> 00:36:02.950
liked them, but I did not see any sort of
spike from shipping an update in my downloads.

00:36:02.950 --> 00:36:08.030
This evidence is only my application, but
from my point of view here, it doesn't look

00:36:08.030 --> 00:36:11.910
like shipping updates helps a lot. So I don't
think you are going to artificially inflate

00:36:11.910 --> 00:36:19.200
your downloads that way.
So going back to this couple-of-months calculation.

00:36:19.200 --> 00:36:23.099
The real problem that I had with shipping
the game in a couple of months was not technical.

00:36:23.099 --> 00:36:27.599
When I showed it last year, it was pretty
much running. The tech was pretty much there.

00:36:27.599 --> 00:36:32.210
It ran on the G1. It scaled up to the newer
devices when those devices came out. I didn't

00:36:32.210 --> 00:36:35.440
have a lot of technical problems to solve
at that point.

00:36:35.440 --> 00:36:41.450
The problem was the game wasn't all that great.
I thought it was kind of boring. It was mediocre.

00:36:41.450 --> 00:36:43.980
Part of the issue here was that my tools were
not that great. This is the level editor.

00:36:43.980 --> 00:36:48.570
This is the level editor. I wrote it in three
days in JavaScript. It totally works, and

00:36:48.570 --> 00:36:52.440
it was pretty limiting in the long run.
The problem was that I had developed these

00:36:52.440 --> 00:36:56.430
levels and they worked, and they weren't as
fun as I want them to be, and in order to

00:36:56.430 --> 00:36:59.080
make them more fun I was going to have to
spend more than three days on the tool, and

00:36:59.080 --> 00:37:04.109
I really didn't want to do that.
So instead of making the tools better, I decided

00:37:04.109 --> 00:37:08.369
to release the game to some users and try
to get user feedback.

00:37:08.369 --> 00:37:12.050
When I worked in the game industry one of
the things we would do is bring kids in, have

00:37:12.050 --> 00:37:16.780
them play the game, watch them play and see
where they would fail. And it was obvious.

00:37:16.780 --> 00:37:20.099
Would you watch a kid run into a brick wall
for a while because he doesn't see wall there

00:37:20.099 --> 00:37:24.230
because your texture hasn't high enough contrast
or something like that. It was very instructive

00:37:24.230 --> 00:37:28.900
for making the game better.
But on a hand-held device like this, it's

00:37:28.900 --> 00:37:32.890
hard to sit over someone's shoulder and watch
them play the game as they play, so instead

00:37:32.890 --> 00:37:37.109
I made an automated system.
So I made a system where every time a player

00:37:37.109 --> 00:37:39.980
dies, I was particularly interested in where
the players were going to die, everywhere

00:37:39.980 --> 00:37:43.210
that they'd die, it would ping a server and
say, "Hey, player died here. Player died here."

00:37:43.210 --> 00:37:46.310
And every time a player completed a level,
it would say, "Player completed a level it.

00:37:46.310 --> 00:37:50.290
Took this amount of time."
And the output of that I graphed as a heat

00:37:50.290 --> 00:37:56.710
map over my level geometry, and this was super
awesome because it totally told me where the

00:37:56.710 --> 00:38:02.170
difficult parts of my game were and where
the not-so-difficult parts of my game were.

00:38:02.170 --> 00:38:06.700
This little valley over here, that's like
the valley of death. Tons of people die there.

00:38:06.700 --> 00:38:08.770
I didn't intend it to be that hard but it
turned out to be.

00:38:08.770 --> 00:38:16.230
So I learned a lot from this. I looked at
this feedback and I said, okay, my camera

00:38:16.230 --> 00:38:20.021
system needs work because too many people
are dying from falling in pits. And the control

00:38:20.021 --> 00:38:23.560
system isn't tight enough, and this level
over here that I intended to be really easy

00:38:23.560 --> 00:38:26.821
is really hard which indicates that people
aren't learning how to use this particular

00:38:26.821 --> 00:38:29.040
game mechanic because I am not teaching it
well enough to them.

00:38:29.040 --> 00:38:32.599
And in a very short amount of time I got a
huge volume of information that I could turn

00:38:32.599 --> 00:38:36.560
into minor adjustments that improved the quality
of the game a lot.

00:38:36.560 --> 00:38:41.380
I was so happy with the system that I shipped
the final game with it turned on. You can

00:38:41.380 --> 00:38:45.420
turn it off in the options if you don't want
to share this information with me, but if

00:38:45.420 --> 00:38:50.980
you don't turn it off, the game will ping
the server and tell me that an anonymous user

00:38:50.980 --> 00:38:55.280
has died in this location. So now I have tons
and tons and tons of data from real users

00:38:55.280 --> 00:39:00.351
about where I failed at level design.
And this is instructive because users are

00:39:00.351 --> 00:39:06.020
also looking for developers who are interested
in continuing to improve their games. So if

00:39:06.020 --> 00:39:09.609
I make an update based on this and push it
out and say, "Okay, everybody who got stuck

00:39:09.609 --> 00:39:16.030
on level 22, I totally am there for you today,"
a lot of users are really happy about that.

00:39:16.030 --> 00:39:20.030
I am very excited to be able to continue to
work directly with my users like that. That's

00:39:20.030 --> 00:39:25.040
something that in other game spaces is basically
impossible.

00:39:25.040 --> 00:39:28.730
You should listen to your users generally.
It's useful to listen to users because they

00:39:28.730 --> 00:39:32.550
have really good feedback. Some of it is really
harsh and some of it is really hard to take,

00:39:32.550 --> 00:39:36.800
but a lot of it is really, really positive
and really useful. I learned a lot from looking

00:39:36.800 --> 00:39:41.070
at market comments.
Android Market users are also hilarious.

00:39:41.070 --> 00:39:47.670
[ Laughter ]
&gt;&gt;Chris Pruett: My daily routine now is downloading

00:39:47.670 --> 00:39:52.460
 -- or opening up market and reading the comments
to see what's been posted lately.

00:39:52.460 --> 00:39:55.160
Sometimes I learn something, and sometimes
it's just really funny.

00:39:55.160 --> 00:40:02.720
Sorry about your G1 mouse thing, dude.
[ Laughter ]

00:40:02.720 --> 00:40:10.290
&gt;&gt;Chris Pruett: Also, and this is another
thing I did not expect, users are fascinating.

00:40:10.290 --> 00:40:14.940
Particularly this user group is fascinating
because you have a view into them with Android

00:40:14.940 --> 00:40:16.860
Market that you don't get with other game
spaces.

00:40:16.860 --> 00:40:22.660
Like this top one here says, "Completed game.
Now what? Need more levels or uninstall."

00:40:22.660 --> 00:40:26.570
And the one below that, Jon, says, "Fix level
22 with the spikes and make it so you can

00:40:26.570 --> 00:40:28.609
play through other levels, then I will give
it five stars."

00:40:28.609 --> 00:40:34.040
This is basically like a threat; right? "I
am going to uninstall your game." Like, okay,

00:40:34.040 --> 00:40:38.599
I beat the whole game. You have to give me
more content or I am going to uninstall.

00:40:38.599 --> 00:40:43.750
And the bottom ones are like challenges and
bugs are the same thing? Like level 22 is

00:40:43.750 --> 00:40:47.560
pretty hard. I made it pretty hard. It's pretty
late in the game. I made it hard intentionally,

00:40:47.560 --> 00:40:52.950
but these users see it as a bug. If I can't
progress, then the game is broken. That's

00:40:52.950 --> 00:40:58.300
fascinating to me.
And I don't think these users are necessarily

00:40:58.300 --> 00:41:02.970
wrong. I mean, this is not the way that I
had thought about game design, but if I'm

00:41:02.970 --> 00:41:05.950
really trying to reach the maximum number
of users, I should probably consider their

00:41:05.950 --> 00:41:11.079
point of view.
So some lessons I learned from users are that

00:41:11.079 --> 00:41:17.800
user bug reports are highly, highly unreliable.
That said, if you can find a user who is willing

00:41:17.800 --> 00:41:22.490
to work with you and send you logs and try
to say here is how I am reproducing this bug,

00:41:22.490 --> 00:41:26.990
those people are invaluable and you should
totally, totally have an e-mail correspondence

00:41:26.990 --> 00:41:32.660
with them at the very least.
Also, I found that users tend to chalk up

00:41:32.660 --> 00:41:38.430
bugs, even if they are not bugs, to which
device they are using. And almost all the

00:41:38.430 --> 00:41:42.440
time, almost all the bugs I shipped affected
all the devices. And I have very, very few

00:41:42.440 --> 00:41:47.670
device-specific bugs. So like here is a demo
here or example here where the first guy says,

00:41:47.670 --> 00:41:51.060
"Works great on the Samsung Moment," and the
next poster says, "It doesn't work on Samsung

00:41:51.060 --> 00:41:57.100
Moment." Which is it? Turns out it works pretty
well on the Moment.

00:41:57.100 --> 00:42:00.810
So different strokes. This is what I was talking
about, different user perspectives. Some of

00:42:00.810 --> 00:42:04.750
these users are extremely casual. Some just
want to be able to consume the content. They

00:42:04.750 --> 00:42:08.690
don't want any sort of challenge. And other
users are extremely hard core, like they tell

00:42:08.690 --> 00:42:13.359
me that the game is too easy. I included three
different endings and they unlock all three

00:42:13.359 --> 00:42:19.130
in two hours and say now what?
Replica Island actually has a dynamic difficulty

00:42:19.130 --> 00:42:22.720
adjustment in there which is a system by which
if the game sees that you are really sucking,

00:42:22.720 --> 00:42:27.090
it will try to dial down the difficulty without
telling you about it. Players don't like to

00:42:27.090 --> 00:42:31.310
hear they are hand held, but my goal is to
get them to continue to move through the game,

00:42:31.310 --> 00:42:33.480
because if they get frustrated, they are going
to uninstall for sure.

00:42:33.480 --> 00:42:40.500
That's a good idea, but that's not nearly
enough, and my future updates are going to

00:42:40.500 --> 00:42:46.390
be even more proactive about either giving
more rewards to users that are hard core.

00:42:46.390 --> 00:42:50.609
Maybe that's achievement systems or maybe
it's social sharing with other friends or

00:42:50.609 --> 00:42:54.460
some other way for them to go out of their
way to want to beat the game more than once

00:42:54.460 --> 00:42:59.540
or beat the game without taking a hit or something
like that, and also maybe an option to remove

00:42:59.540 --> 00:43:04.300
all challenge completely from the game. Maybe
select any level or say I want to be able

00:43:04.300 --> 00:43:08.430
to fly forever, whatever it is, f the users
who just want to consume the content who aren't

00:43:08.430 --> 00:43:13.640
interested in a hard-core challenge.
Other thing to remember is your market placement

00:43:13.640 --> 00:43:19.060
is not static. I have, like I said, I have
a 4.5 review score at the moment which is

00:43:19.060 --> 00:43:22.980
fantastic, but for about three days there
I lost half a star and I was down to four

00:43:22.980 --> 00:43:29.761
and that pissed me off. I was like I have
to get those guys back. And I had an update

00:43:29.761 --> 00:43:32.650
that I had been working on and I fast tracked
the update and I shipped it and my half star

00:43:32.650 --> 00:43:37.390
came back and I felt so good about it.
But the thing you have to remember is the

00:43:37.390 --> 00:43:42.760
users are actively playing and rating your
content even after you sort of consider it

00:43:42.760 --> 00:43:48.079
done. So if you want to stay at a high placement
in market, you have to get actively involved.

00:43:48.079 --> 00:43:51.990
And it doesn't always mean shipping updates.
It might mean making your description text

00:43:51.990 --> 00:43:58.930
more explicit, or telling users how to play
the game better or providing some other sorts

00:43:58.930 --> 00:44:04.260
of support, but users are there and they are
active, and the market placement moves.

00:44:04.260 --> 00:44:09.460
And then communicating as many ways as possible
is the last point here. This is actually really

00:44:09.460 --> 00:44:13.580
hard. But when you make an update, unless
you are really verbose about it, users aren't

00:44:13.580 --> 00:44:17.240
going to understand what you changed. The
number one complaints I have right now are

00:44:17.240 --> 00:44:21.470
all related to control customization options
that I solved two updates ago. And the control

00:44:21.470 --> 00:44:26.500
customization screen itself is not discoverable
enough, and people are not finding there's

00:44:26.500 --> 00:44:30.849
a solution to their problem and they're writing
a report in Market about it. So my next step

00:44:30.849 --> 00:44:35.109
is to try to make that more discoverable by
communicating it in more ways and different

00:44:35.109 --> 00:44:38.620
ways. Something to think about.
To finish up here, I want to leave you here

00:44:38.620 --> 00:44:43.260
with a quote by a guy named Jonathan Blow.
He is the developer of a game called Braid,

00:44:43.260 --> 00:44:47.640
which is a pretty awesome game. He says, "It's
not so much about innovation as exploring

00:44:47.640 --> 00:44:51.700
interestingness." This has been a really instructive
quote for me for the last year or two because

00:44:51.700 --> 00:44:57.740
what he is talking about is your game needs
to be interesting. The way you define quality

00:44:57.740 --> 00:45:00.520
of a game is by whether or not it's interesting
to users.

00:45:00.520 --> 00:45:03.960
That might be a function of technology, or
it might be a function of innovative game

00:45:03.960 --> 00:45:07.930
mechanics nobody has ever seen before, or
it might be art style or good writing or something

00:45:07.930 --> 00:45:12.100
like that.
Whatever it takes, make sure the game is interesting

00:45:12.100 --> 00:45:15.660
and then users will come.
Last but not least, here is the Wave link

00:45:15.660 --> 00:45:19.200
again. There are some Google Moderator stuff
up here. I will put the questions up in a

00:45:19.200 --> 00:45:24.090
second. I am also going to take questions
from the mics, wherever they are. We have

00:45:24.090 --> 00:45:27.849
about 15 minutes for questions. And here is
the source code.

00:45:27.849 --> 00:45:31.190
First, if you have never written anything
for Android before, then you might be kind

00:45:31.190 --> 00:45:33.609
of wondering what the heck I am talking about
with this talk. But developer.Android.com

00:45:33.609 --> 00:45:38.880
is where to start.
And SpriteMethodTest is another profile test

00:45:38.880 --> 00:45:43.251
I wrote for 2D testing. That source and the
HeightMapProfiler I talked about today are

00:45:43.251 --> 00:45:47.510
up on this apps-for-android project on Google
code.

00:45:47.510 --> 00:45:55.002
And replicaisland.net has links to the game
and source and other things about the game

00:45:55.002 --> 00:45:58.150
if you are interested. All the sources are
available under Appache, too. So if you want

00:45:58.150 --> 00:46:00.779
to use it to make your own games, go for it.
Thank you very much.

00:46:00.779 --> 00:46:12.880
[ Applause ]
&gt;&gt;Chris Pruett: Okay. So I am going to switch

00:46:12.880 --> 00:46:26.570
over to Google Moderator here.
I apologize for the small screen but I totally

00:46:26.570 --> 00:46:34.869
set it up wrong.
Okay. Let's do -- Is there a question on the

00:46:34.869 --> 00:46:39.430
mic first? You, sir, over here.
&gt;&gt;&gt; I was just wondering if you had any comments

00:46:39.430 --> 00:46:42.760
about audio for games.
&gt;&gt;Chris Pruett: Sure.

00:46:42.760 --> 00:46:49.690
&gt;&gt;&gt; And then FPUs. Some devices, or about
half of the devices don't have them, and the

00:46:49.690 --> 00:46:53.182
other half --
&gt;&gt;Chris Pruett: Right. So the question is

00:46:53.182 --> 00:46:58.130
what to do about audio for games and what
about devices -- support for FPUs.

00:46:58.130 --> 00:47:03.010
Most games, the way they want to play audio
is either by playing a streaming music track

00:47:03.010 --> 00:47:07.610
or by playing sound effects. And both of those
APIs are available. They are only available

00:47:07.610 --> 00:47:11.170
from Java, though.
For playing streaming music you probably want

00:47:11.170 --> 00:47:16.081
to use the media player object. And for playing
sound effects there is an object called sound

00:47:16.081 --> 00:47:18.960
pool, and will allow you to load a bunch of
samples and then fire them off and it has

00:47:18.960 --> 00:47:23.109
a priority system. It's basically what most,
I think, game engines will implement themselves.

00:47:23.109 --> 00:47:30.180
If you are writing your code in C++, you can't
talk to those systems directly, so the normal

00:47:30.180 --> 00:47:34.090
mode that game developers I have worked with
are doing is they are either doing all the

00:47:34.090 --> 00:47:38.970
mixing themselves in C++ and passing a PCM
stream up to a media player, which is fine

00:47:38.970 --> 00:47:41.420
if you already have mixing code or if you
just like to let the Android framework do

00:47:41.420 --> 00:47:47.500
it, you can either just call into Java from
C++ using JNI or you can just write the sort

00:47:47.500 --> 00:47:53.230
of sound invocation code in Java.
On the point about FPUs, that's true. Some

00:47:53.230 --> 00:47:58.859
devices have it, some devices do not.
The tests that I have seen suggest that there's

00:47:58.859 --> 00:48:06.130
no benefit in Java to writing code in fixed
point because the VMs version -- or whatever

00:48:06.130 --> 00:48:13.120
code you write to do fixed point emulation
is going to be as slow or the same speed at

00:48:13.120 --> 00:48:15.099
the software emulator that's already running
in native code.

00:48:15.099 --> 00:48:17.991
So if you're writing in Java, don't worry
about it.

00:48:17.991 --> 00:48:19.610
Just use floating point.
That's what I did.

00:48:19.610 --> 00:48:24.720
I didn't ever worry about it.
If you're writing code in native code, then,

00:48:24.720 --> 00:48:30.540
yeah, there's some things you want to be -- you
want to be cognizant that there is no floating-point

00:48:30.540 --> 00:48:34.700
device on a lot of devices.
That will probably continue to be true.

00:48:34.700 --> 00:48:39.260
If you can detect that there is floating-point
hardware by the name of the architecture or

00:48:39.260 --> 00:48:43.250
something like that, you can use it.
My suspicion is that you don't need to worry

00:48:43.250 --> 00:48:46.140
about it too much.
And if you really have high-performance code,

00:48:46.140 --> 00:48:49.700
then you're probably using fixed point already,
even in native code.

00:48:49.700 --> 00:48:54.069
Okay. So question over here.
&gt;&gt;&gt; Just wondering whether you have any suggestion

00:48:54.069 --> 00:48:59.980
if you write to target the third generation
or fourth generation of device, for example,

00:48:59.980 --> 00:49:06.240
the next Android release or even, like, a
device with a different processor other than

00:49:06.240 --> 00:49:07.680
ARM?
&gt;&gt;Chris Pruett: So you're talking about the

00:49:07.680 --> 00:49:10.300
emulator?
&gt;&gt;&gt; On the real device.

00:49:10.300 --> 00:49:15.739
&gt;&gt;Chris Pruett: I'm sorry, could you ask the
question again.

00:49:15.739 --> 00:49:20.550
&gt;&gt;&gt; Kind of in the future, or next -- future
generation, you probably have Android 2.2

00:49:20.550 --> 00:49:30.390
and so forth, and also the device for (inaudible)
could be using, like, X86 or mixed kind of

00:49:30.390 --> 00:49:34.230
processors.
So any suggestion if you would like to target

00:49:34.230 --> 00:49:37.510
that kind of device.
&gt;&gt;Chris Pruett: The question is, if you want

00:49:37.510 --> 00:49:41.079
to target devices that don't exist yet or
haven't come out yet that are not running

00:49:41.079 --> 00:49:48.579
on our processors, how do you do it.
Basically, you can figure it out yourself.

00:49:48.579 --> 00:49:53.390
The NDK is based on GDB.
And if you go and look at the make scripts

00:49:53.390 --> 00:50:01.089
inside of the NDK, you can probably figure
out how to build a application for that architecture.

00:50:01.089 --> 00:50:05.819
Now, the thing is, there's a whole bunch of
stuff in the framework for loading different

00:50:05.819 --> 00:50:08.460
ABIs.
And we're going to have to support that before

00:50:08.460 --> 00:50:13.490
you can really easily target those ABIs.
So what I would suggest is, by the time a

00:50:13.490 --> 00:50:18.460
significant device that supports another architecture
comes out, the NDK will have support for that.

00:50:18.460 --> 00:50:21.290
So I wouldn't worry about it too much.
If you're on the cutting edge, then you're

00:50:21.290 --> 00:50:24.320
on the cutting edge.
But if you're a regular developer, we will

00:50:24.320 --> 00:50:28.930
have software kits out for you by the time
those devices are going to ship.

00:50:28.930 --> 00:50:33.941
I'm going to take a question from the moderator
thing here, if I can.

00:50:33.941 --> 00:50:43.790
That's fantastic.
Yay!

00:50:43.790 --> 00:50:49.150
Okay.
This is awesome.

00:50:49.150 --> 00:50:54.839
Okay.
So I looked at this before, and it looks like

00:50:54.839 --> 00:50:58.079
this question about Replica Island having
benefited from prerelease with a few (inaudible)

00:50:58.079 --> 00:51:01.859
and no story to build up excitement for the
game and we have a lot of frustrated users,

00:51:01.859 --> 00:51:06.980
people are totally ambivalent about that question.
But it has a lot of votes, so I'm going to

00:51:06.980 --> 00:51:09.940
answer it.
I did prerelease Replica Island to a limited

00:51:09.940 --> 00:51:12.470
number of users, all beta test users.
I didn't do it on market.

00:51:12.470 --> 00:51:16.460
The story, actually, was written first.
I wrote the story before I did any of the

00:51:16.460 --> 00:51:18.880
level design.
So cutting the story out would not have saved

00:51:18.880 --> 00:51:22.000
me time.
Maybe this questioner is asking about if I

00:51:22.000 --> 00:51:25.510
could have cut the story out as a reason for
users to come back after a public beta.

00:51:25.510 --> 00:51:30.180
I don't know.
I think that users who download something

00:51:30.180 --> 00:51:34.550
on Android Market and leave it installed are
interested in that app.

00:51:34.550 --> 00:51:37.741
And you can continue to ship updates to them
very easily over Android Market.

00:51:37.741 --> 00:51:40.400
It seems like a public beta thing could sort
of work.

00:51:40.400 --> 00:51:45.339
In my particular case, I felt like the game
was pretty solid when I shipped it, and immediately

00:51:45.339 --> 00:51:49.930
when I found out that, say, users who had
Xperia's couldn't play, I tried to make modifications

00:51:49.930 --> 00:51:53.220
to help them.
I don't know if it would have benefited from

00:51:53.220 --> 00:51:55.630
a prerelease.
But I don't think it would have benefited

00:51:55.630 --> 00:52:00.410
me in terms of a development time.
The test I did with users to get feedback

00:52:00.410 --> 00:52:03.220
from on the levels was useful.
But I didn't use Android Market for that.

00:52:03.220 --> 00:52:06.240
I just sent them the APK.
Question over here.

00:52:06.240 --> 00:52:09.920
&gt;&gt;&gt; So when you were talking about your tips
and tricks, there were a bunch of things you

00:52:09.920 --> 00:52:12.450
listed.
One of them was, it doesn't make sense to

00:52:12.450 --> 00:52:17.620
go to the NDK just for OpenGL calls.
And I remember last year, you mentioned you

00:52:17.620 --> 00:52:20.450
had a graph of how expensive each function
call is.

00:52:20.450 --> 00:52:23.819
And JNI was way up there.
So it seems to me that it would make sense

00:52:23.819 --> 00:52:28.810
to kind of bundle them into one since the
open GL calls are just JNIs, as far as I understand.

00:52:28.810 --> 00:52:33.660
So why is that that it's not valuable?
&gt;&gt;Chris Pruett: I thought so, too.

00:52:33.660 --> 00:52:38.089
I didn't touch on it, but I said in the slide
that one of the tests I did with the height

00:52:38.089 --> 00:52:43.910
map profile senior I wrote the whole renderer
in Java and then the whole same code in C++

00:52:43.910 --> 00:52:48.450
to see what the difference between the NDK
version of the renderer and the Java version

00:52:48.450 --> 00:52:51.380
of the renderer is.
And it turned out there was almost no difference.

00:52:51.380 --> 00:52:59.920
That's because I wasn't doing any intensive.
If you call it will from Java, it's going

00:52:59.920 --> 00:53:04.869
to jump down to native code anyway.
The question is why isn't there a huge performance

00:53:04.869 --> 00:53:09.550
benefit to skipping all those individual JNI
calls and having one function that does the

00:53:09.550 --> 00:53:12.380
cause from the code.
There is a small delta.

00:53:12.380 --> 00:53:16.820
It actually turns out to be less than a millisecond
even in the worst-case test, in this particular

00:53:16.820 --> 00:53:19.490
test.
Now, I don't have a lot of state to set in

00:53:19.490 --> 00:53:22.680
this thing.
I don't have a lot of GL calls to make.

00:53:22.680 --> 00:53:26.800
So if you are the type of application that
has hundreds of thousands of GL calls to make

00:53:26.800 --> 00:53:30.619
every frame, then JNI overhead is probably
something you want to be cognizant of.

00:53:30.619 --> 00:53:35.230
For my particular tastes, I want to set up
all of the state ahead of time and issue as

00:53:35.230 --> 00:53:38.440
few calls as possible, because that's the
fastest way to draw, especially for a test

00:53:38.440 --> 00:53:42.230
like this.
None of that is CPU-intensive.

00:53:42.230 --> 00:53:50.609
It's waiting for the driver to set the state.
Calling for an NDK is not a benefit.

00:53:50.609 --> 00:53:57.390
Using the NDK closes off which platforms -- if,
you know, some theoretical X86 platform shipped

00:53:57.390 --> 00:53:59.630
in the future, unless I recompile my code,
that NDK code won't work.

00:53:59.630 --> 00:54:04.680
I've boxed myself in.
So if you're going to use native code, do

00:54:04.680 --> 00:54:09.130
something intensive with it.
It does exist.

00:54:09.130 --> 00:54:13.180
But, you know, do your physics calculation
or do your scene graph walking or whatever

00:54:13.180 --> 00:54:17.171
it is that is expensive to do in an interpreted
language, do that in native code.

00:54:17.171 --> 00:54:20.472
Don't just issue GL commands.
&gt;&gt;&gt; Okay, thanks.

00:54:20.472 --> 00:54:21.472
&gt;&gt;Chris Pruett: Okay.
Over here.

00:54:21.472 --> 00:54:26.940
&gt;&gt;&gt; If you need to add a video stream, be
it from a camera or a media file, into your

00:54:26.940 --> 00:54:31.460
graphics, how would you do it?
Let's say it's a VGSI.

00:54:31.460 --> 00:54:35.060
What kind of performance do you expect?
&gt;&gt;Chris Pruett: You're saying read from a

00:54:35.060 --> 00:54:38.870
media file into --
&gt;&gt;&gt; Or a camera stream, live camera stream

00:54:38.870 --> 00:54:40.561
coming in.
&gt;&gt;Chris Pruett: You mean specifically coming

00:54:40.561 --> 00:54:45.829
into GL memory?
The question is how to get bit maps into OpenGL

00:54:45.829 --> 00:54:50.059
fast.
So there's only really one way to do it.

00:54:50.059 --> 00:54:52.900
That's to set them as a texture.
You can set a render target and copy them

00:54:52.900 --> 00:54:56.089
there.
There's a GL subtexture image and also a,

00:54:56.089 --> 00:55:03.300
like, GL utiles will give you a copy for (inaudible).
That's generally not a fast operation.

00:55:03.300 --> 00:55:06.040
And it's pretty much bus-bound, as far as
I can tell.

00:55:06.040 --> 00:55:10.210
So the answer is, don't do that if you can
avoid it.

00:55:10.210 --> 00:55:13.369
Preload all your textures.
And when you get the call to surface change,

00:55:13.369 --> 00:55:15.880
load them again.
In the case of a camera or something like

00:55:15.880 --> 00:55:19.040
that, I think it's going to be pretty difficult.
I think that you can do it.

00:55:19.040 --> 00:55:24.670
And I think that you can do it at a frame
rate that is, you know, above 15 frames a

00:55:24.670 --> 00:55:27.120
second.
But probably not on the current round of -- the

00:55:27.120 --> 00:55:29.599
current range of hardware, anyway, at 30 frames
a second.

00:55:29.599 --> 00:55:34.970
Because the bus is going to get saturated.
And also when you're in a case where the hardware

00:55:34.970 --> 00:55:38.550
is waiting for this copy to complete, any
other sort of context switcher interrupt,

00:55:38.550 --> 00:55:42.619
lining an event call back is going to be much
more expensive than it would be in a regular

00:55:42.619 --> 00:55:46.230
game.
So my recommendation is, if you plan on sort

00:55:46.230 --> 00:55:49.320
of loading textures at run time as the game
is running or as your simulation is running,

00:55:49.320 --> 00:55:54.589
you should expect that to be very expensive.
&gt;&gt;&gt; What about you mentioned (inaudible) texture.

00:55:54.589 --> 00:55:59.180
I wasn't familiar with it.
&gt;&gt;Chris Pruett: Draw texture takes a level

00:55:59.180 --> 00:56:04.460
 -- a texture that's already been loaded into
GL memory and just draws it.

00:56:04.460 --> 00:56:08.119
It's basically the same as making a quad and
making orthographic projection and saying

00:56:08.119 --> 00:56:09.960
draw.
You don't have to do any stuff, you just say

00:56:09.960 --> 00:56:14.819
draw texture and give it a scale and X, Y,
Z.

00:56:14.819 --> 00:56:22.109
It's faster than to do it in code.
I'll take a question from moderator, if I

00:56:22.109 --> 00:56:25.940
can make it scroll correctly.
So, let's see.

00:56:25.940 --> 00:56:30.000
A question about Android Market in other countries
and a question about Flash 10.

00:56:30.000 --> 00:56:35.480
So real quick about Flash.
I don't know anything about Flash.

00:56:35.480 --> 00:56:38.119
[ Laughter ]
&gt;&gt;Chris Pruett: I'm involved in the game developer

00:56:38.119 --> 00:56:42.210
side of things and not the framework, and
I don't work at Adobe.

00:56:42.210 --> 00:56:46.280
So I think that there's probably lots to learn
about Flash at this conference.

00:56:46.280 --> 00:56:49.160
But I don't know what those things are.
I do think that if you're going to make a

00:56:49.160 --> 00:56:54.000
Flash game and you would like to bring it
over to Android, then, you know, the simplest

00:56:54.000 --> 00:56:57.240
way to do it is probably to take whatever
they're building and ship it.

00:56:57.240 --> 00:57:00.740
The problem with that is that, you know, you're
going to ship it to the devices that support

00:57:00.740 --> 00:57:04.571
Flash, which is going to be a very small subset
of that graph that I showed you.

00:57:04.571 --> 00:57:07.760
If you're interested in minimum time to ship,
it sounds like a really good idea.

00:57:07.760 --> 00:57:10.801
If you're interested in taking content you
have already built and get it up on Android,

00:57:10.801 --> 00:57:13.510
that sounds like a good first step.
If you're interested in using every single

00:57:13.510 --> 00:57:16.930
Android user in the world, that may not be
a good way to go.

00:57:16.930 --> 00:57:22.609
That's about all I have to say about Flash.
I have a very short amount of time remaining.

00:57:22.609 --> 00:57:24.109
If you have a question, please come up to
the mike.

00:57:24.109 --> 00:57:26.329
Because otherwise people won't be able to
hear you.

00:57:26.329 --> 00:57:28.480
Any other mike questions?
Okay.

00:57:28.480 --> 00:57:36.260
Speak loudly and I'll repeat it.
&gt;&gt;&gt; Do you have any references on the best

00:57:36.260 --> 00:57:38.680
way to mix in text with OpenGL?
&gt;&gt;Chris Pruett: The question is, how do you

00:57:38.680 --> 00:57:43.349
mix in text with OpenGL.
OpenGL is really bad at text, generally.

00:57:43.349 --> 00:57:49.030
You can make your texture with your characters
in it and then try to make quads to draw the

00:57:49.030 --> 00:57:52.099
texture.
We actually have a demo in the API demos that

00:57:52.099 --> 00:57:59.589
will take the -- will take the Android sort
of font system and rasterize them fonts into

00:57:59.589 --> 00:58:01.600
a texture and you can build that to build
quads.

00:58:01.600 --> 00:58:08.060
But it's not international, it won't do UTF-8
stuff, if you want to support languages like

00:58:08.060 --> 00:58:11.500
Chinese, your textures are going to become
huge.

00:58:11.500 --> 00:58:17.890
If you want to overlay text or overlay any
sort of regular view hierarchy stuff on top

00:58:17.890 --> 00:58:23.330
of OpenGL output, you can do that very easily
using GL surface view.

00:58:23.330 --> 00:58:26.220
That's going to just be an element in your
view hierarchy.

00:58:26.220 --> 00:58:31.540
You can put other elements in front of it.
In my game, I have a pause text that comes

00:58:31.540 --> 00:58:35.000
up which is actually just an image, but doesn't
draw with OpenGL, just draws with the regular

00:58:35.000 --> 00:58:38.520
Android image view system.
I draw it right on top of the GL surface.

00:58:38.520 --> 00:58:42.680
There's not a lot of overhead to doing it.
If you're talking about compositing text to

00:58:42.680 --> 00:58:47.150
an only seam, that's the way to go.
Do I have time for one more question?

00:58:47.150 --> 00:58:49.339
Is that it?
I think I'm out of time.

00:58:49.339 --> 00:58:52.060
Thank you very much for coming.
And I'm looking forward to seeing all the

00:58:52.060 --> 00:58:52.620
games you guys are going to make.
[ Applause ]

