WEBVTT
Kind: captions
Language: en

00:00:05.070 --> 00:00:05.820
LILLI THOMPSON: Hello.

00:00:05.820 --> 00:00:09.500
I'm Lilli Thompson, and this
is Console to Chrome, HTML5

00:00:09.500 --> 00:00:12.630
and JavaScript for
game developers.

00:00:12.630 --> 00:00:16.040
So first of all, just a little
bit of background on me.

00:00:16.040 --> 00:00:19.690
So I am an ex-console game
programmer that joined Google

00:00:19.690 --> 00:00:20.670
as a software engineer.

00:00:20.670 --> 00:00:22.790
And I did that for a couple of
years, nothing to do with

00:00:22.790 --> 00:00:26.070
graphics or game, just generic
software engineering.

00:00:26.070 --> 00:00:27.560
And then, I found that
I really missed game

00:00:27.560 --> 00:00:28.100
development.

00:00:28.100 --> 00:00:30.770
So I then joined the
Chrome team as a

00:00:30.770 --> 00:00:32.240
game developer advocate.

00:00:32.240 --> 00:00:35.210
And what that means is that what
I do now is that I work

00:00:35.210 --> 00:00:37.880
with game developers who are
working with technologies that

00:00:37.880 --> 00:00:39.840
are a priority for Chrome.

00:00:39.840 --> 00:00:42.610
And the big two for me
are HTML5 and WebGL.

00:00:42.610 --> 00:00:47.540
So that's what I do a lot of,
and that's why I'm here today.

00:00:47.540 --> 00:00:49.800
So first of all, an overview
of this talk.

00:00:49.800 --> 00:00:52.460
The thing you really need to
know is that this is a

00:00:52.460 --> 00:00:54.230
201-level talk.

00:00:54.230 --> 00:00:56.430
I'm not going to give
you the HTML5 pitch.

00:00:56.430 --> 00:00:58.530
And I'm not going to give you an
intro to game development.

00:00:58.530 --> 00:01:00.760
I'm going to assume that you're
a game developer type

00:01:00.760 --> 00:01:04.680
person that already knows that
they want to use HTML5.

00:01:04.680 --> 00:01:07.420
Maybe you've done a WebGL
tutorial and even rendered

00:01:07.420 --> 00:01:09.030
your first couple
of triangles.

00:01:09.030 --> 00:01:11.900
But now, there's a huge
knowledge gap between making a

00:01:11.900 --> 00:01:14.880
prototype and actually
making a scalable

00:01:14.880 --> 00:01:17.150
large-scale game engine.

00:01:17.150 --> 00:01:20.300
And so that's really what
I want to address today.

00:01:20.300 --> 00:01:22.800
And there are a couple of topics
that go into that.

00:01:22.800 --> 00:01:25.230
The first, I'll just have to
go really briefly over the

00:01:25.230 --> 00:01:26.030
HTML5 APIs.

00:01:26.030 --> 00:01:27.680
I'm not going to spend
a lot of time on it.

00:01:27.680 --> 00:01:30.550
But I want to make sure that
we're all on the same page.

00:01:30.550 --> 00:01:33.170
Then the real meat of the
issue for a lot of game

00:01:33.170 --> 00:01:34.890
developers is JavaScript.

00:01:34.890 --> 00:01:37.670
Just writing code at that
scale in JavaScript is

00:01:37.670 --> 00:01:39.400
something that a lot of console

00:01:39.400 --> 00:01:41.040
programmers struggle with.

00:01:41.040 --> 00:01:42.830
And so I'm going to spend a lot
of time there in talking

00:01:42.830 --> 00:01:44.640
about how to do that.

00:01:44.640 --> 00:01:48.240
And then finally, when you write
an HTML5 game, you're

00:01:48.240 --> 00:01:51.090
actually writing a game that
renders inside a much more

00:01:51.090 --> 00:01:54.430
complicated system of Chrome's
rendering system.

00:01:54.430 --> 00:01:57.220
And so there's all sorts of
things to know there.

00:01:57.220 --> 00:01:59.500
And if you really understand how
Chrome is set up, you can

00:01:59.500 --> 00:02:01.460
optimize your game and
make it run better.

00:02:01.460 --> 00:02:05.290
So those are the topics I'm
going to cover today.

00:02:05.290 --> 00:02:07.920
So there are two major
ways that people

00:02:07.920 --> 00:02:10.410
think about HTML5 games.

00:02:10.410 --> 00:02:12.940
The first is as a means
to get ubiquity.

00:02:12.940 --> 00:02:16.340
There's a whole class of people
who look at HTML5 as a

00:02:16.340 --> 00:02:19.430
way to write one code base and
run it in multiple places.

00:02:19.430 --> 00:02:23.060
So the dream is that every
phone, every tablet, every PC,

00:02:23.060 --> 00:02:24.700
every device has a browser.

00:02:24.700 --> 00:02:27.370
And if you can squish your
game into a browser, into

00:02:27.370 --> 00:02:30.190
HTML5, then that's great
for your maintenance.

00:02:30.190 --> 00:02:31.980
You have one code base, and
it's running everywhere.

00:02:31.980 --> 00:02:33.750
That's awesome.

00:02:33.750 --> 00:02:37.440
But that particular use of HTML5
comes with a certain set

00:02:37.440 --> 00:02:38.660
of constraints.

00:02:38.660 --> 00:02:41.550
So naturally, if you're really
targeting ubiquity, if that's

00:02:41.550 --> 00:02:44.250
your point, then you have to peg
the specification for your

00:02:44.250 --> 00:02:48.010
game to the lowest common
denominator, both in terms of

00:02:48.010 --> 00:02:50.780
what APIs you can use, because
you need APIs that are very

00:02:50.780 --> 00:02:54.000
broadly supported, and also in
terms of what you can demand

00:02:54.000 --> 00:02:55.870
out of the hardware because you
have to assume that you

00:02:55.870 --> 00:02:59.710
want to run just as well on a
phone as you do on a desktop.

00:02:59.710 --> 00:03:02.750
So anyway, very nice use of
HTML5, but then there's this

00:03:02.750 --> 00:03:05.380
other way people think about
it, which is as a way to do

00:03:05.380 --> 00:03:07.550
something awesome with
the browser.

00:03:07.550 --> 00:03:10.850
So there's a different set of
people who see the browser as

00:03:10.850 --> 00:03:14.200
a distribution platform for
their console-style games and

00:03:14.200 --> 00:03:17.560
are really excited by all the
great new potential that HTML5

00:03:17.560 --> 00:03:19.340
had added to the browser.

00:03:19.340 --> 00:03:21.240
And they really want to take
advantage of that.

00:03:21.240 --> 00:03:23.470
And there's a huge potential
there, making sharable,

00:03:23.470 --> 00:03:25.520
linkable, seamless
experiences.

00:03:25.520 --> 00:03:27.220
You can get so many
users that way.

00:03:27.220 --> 00:03:28.760
And it's so exciting.

00:03:28.760 --> 00:03:31.220
But as you can imagine, these
people who are really

00:03:31.220 --> 00:03:33.960
interested in being on the
leading edge, their goals are

00:03:33.960 --> 00:03:35.700
very different than the people
who are trying to

00:03:35.700 --> 00:03:37.970
do HTML5 for ubiquity.

00:03:37.970 --> 00:03:40.880
Because by virtue of being on
the bleeding edge, these

00:03:40.880 --> 00:03:43.140
things aren't going to be
supported everywhere.

00:03:43.140 --> 00:03:46.040
If you're making a game that's
a PC-style game that's really

00:03:46.040 --> 00:03:48.770
demanding, it's not going to run
on 10-year-old hardware.

00:03:48.770 --> 00:03:50.910
And that's OK for
this use case.

00:03:50.910 --> 00:03:54.310
So whenever you talk to people
about their opinions about

00:03:54.310 --> 00:03:56.490
HTML5 and what it's good for
and what it isn't good for,

00:03:56.490 --> 00:03:59.210
you should make sure you
understand which of these

00:03:59.210 --> 00:04:01.370
cases they're coming
at it from.

00:04:01.370 --> 00:04:03.700
And to be very clear here,
what I want to talk about

00:04:03.700 --> 00:04:06.480
today is the leading
edge of HTML5.

00:04:06.480 --> 00:04:09.660
I want to talk about credible
console-style experiences

00:04:09.660 --> 00:04:10.970
rendered in the browser.

00:04:13.870 --> 00:04:17.079
So to begin talking about that,
we need to talk about

00:04:17.079 --> 00:04:18.959
HTML5 APIs, at least briefly.

00:04:18.959 --> 00:04:21.790
So the first one you're going
to need is WebGL.

00:04:21.790 --> 00:04:24.750
So WebGL is the way you do 3D
rendering in a browser.

00:04:24.750 --> 00:04:25.910
It's a lot like OpenGL.

00:04:25.910 --> 00:04:28.230
So if you're already an OpenGL
programmer, it's going to be

00:04:28.230 --> 00:04:31.120
pretty familiar to you,
except for it's

00:04:31.120 --> 00:04:33.330
actually OpenGL ES 2.0.

00:04:33.330 --> 00:04:36.430
It's the embedded systems
version of OpenGL.

00:04:36.430 --> 00:04:39.360
And what that means is that when
they made the embedded

00:04:39.360 --> 00:04:42.610
systems versions of the
specifications, they took out

00:04:42.610 --> 00:04:44.990
everything that was deemed to be
redundant in order to make

00:04:44.990 --> 00:04:47.670
it small and compact to
fit on mobile devices.

00:04:47.670 --> 00:04:51.050
But that means that a lot of
stuff is sort of removed.

00:04:51.050 --> 00:04:53.970
And the first thing you're going
to notice there is that

00:04:53.970 --> 00:04:55.310
fixed function lighting
is gone.

00:04:55.310 --> 00:04:57.790
So all your rendering in WebGL
is going to be done through

00:04:57.790 --> 00:04:59.200
programmable shaders.

00:04:59.200 --> 00:05:00.700
You're going to have to get
used to that if you're not

00:05:00.700 --> 00:05:02.470
used to that already.

00:05:02.470 --> 00:05:04.690
And besides that, there are a
bunch of other little things

00:05:04.690 --> 00:05:07.430
which, when I talk to game
developers about them, they're

00:05:07.430 --> 00:05:10.180
usually described as annoyances,
just random stuff

00:05:10.180 --> 00:05:12.130
that just is missing for
whatever reason in the

00:05:12.130 --> 00:05:13.010
specification.

00:05:13.010 --> 00:05:16.880
So for instance, depth buffer
access, texture compression is

00:05:16.880 --> 00:05:19.780
only available in a limited
form, instancing is missing,

00:05:19.780 --> 00:05:21.020
and so on, and so forth.

00:05:21.020 --> 00:05:22.560
So there are little
stumbling blocks.

00:05:22.560 --> 00:05:23.900
None of them are
deal breakers.

00:05:23.900 --> 00:05:26.770
You can still make a
high-quality, graphically

00:05:26.770 --> 00:05:27.960
impressive 3D game.

00:05:27.960 --> 00:05:29.020
But you're going to
have to know that

00:05:29.020 --> 00:05:31.740
these issues are there.

00:05:31.740 --> 00:05:34.360
And then, there's a different
class of things, which is a

00:05:34.360 --> 00:05:38.890
set of operations in OpenGL
ES that have a different

00:05:38.890 --> 00:05:41.360
performance profile than you
might expect in Chrome.

00:05:41.360 --> 00:05:43.700
So, for instance, anything that
starts with a "read,"

00:05:43.700 --> 00:05:46.140
anything that's starts with a
"get" and "glFinish," that

00:05:46.140 --> 00:05:48.140
kind of operation, they're
all going to be extra

00:05:48.140 --> 00:05:48.970
expensive in Chrome.

00:05:48.970 --> 00:05:50.290
They were always somewhat
expensive.

00:05:50.290 --> 00:05:52.050
Now they're going to be
really expensive.

00:05:52.050 --> 00:05:56.270
And when we get into talking
about how Chrome actually

00:05:56.270 --> 00:05:59.760
renders things, I'll be able
to explain why that is.

00:05:59.760 --> 00:06:04.240
But besides those performance
notes, the rest of the

00:06:04.240 --> 00:06:06.710
performance of WebGL is
actually pretty great.

00:06:06.710 --> 00:06:09.030
It's actually tremendously
impressive.

00:06:09.030 --> 00:06:11.080
It's really calling straight
through the hardware, so the

00:06:11.080 --> 00:06:13.550
performance of WebGL is very,
very similar to the

00:06:13.550 --> 00:06:15.260
performance of OpenGL.

00:06:15.260 --> 00:06:17.270
And you can get a
lot out of it.

00:06:17.270 --> 00:06:20.250
And the other thing to note is
that the specification is

00:06:20.250 --> 00:06:21.870
evolving very, very quickly.

00:06:21.870 --> 00:06:24.900
If you look at where WebGL was
a year ago versus where it is

00:06:24.900 --> 00:06:27.270
today, you're going to see
a lot of improvements.

00:06:27.270 --> 00:06:29.460
So especially, when you think
about all these little things

00:06:29.460 --> 00:06:31.890
that are either annoying, or
missing, or whatever, make

00:06:31.890 --> 00:06:34.390
sure you check back in with your
assumptions every three

00:06:34.390 --> 00:06:37.330
to six months because fixes very
well might have come into

00:06:37.330 --> 00:06:38.260
the specification.

00:06:38.260 --> 00:06:41.570
Or better still, go to the WebGL
mailing list and start

00:06:41.570 --> 00:06:44.200
talking about what it is you
need and want, because they're

00:06:44.200 --> 00:06:48.620
very responsive, and a lot of
changes are getting made.

00:06:48.620 --> 00:06:50.020
So you can render polygons.

00:06:50.020 --> 00:06:52.300
Next thing you need to do on
your way to a prototype is to

00:06:52.300 --> 00:06:54.560
be able to play some audio.

00:06:54.560 --> 00:06:58.100
HTML5 audio is a notorious
sticking point.

00:06:58.100 --> 00:07:01.560
Everyone in the HTML5 games
community has heard everybody

00:07:01.560 --> 00:07:04.710
else complain about how
painful audio is.

00:07:04.710 --> 00:07:07.550
And that's pretty true,
quite honestly.

00:07:07.550 --> 00:07:11.740
It's pretty safe to say that
audio in HTML5 is the most

00:07:11.740 --> 00:07:14.970
important, least standardized
thing.

00:07:14.970 --> 00:07:17.710
And so there actually is no
specification that's really

00:07:17.710 --> 00:07:19.740
suitable for this kind of game
that's going to work

00:07:19.740 --> 00:07:20.400
everywhere.

00:07:20.400 --> 00:07:22.960
So you're stuck falling back and
doing different things for

00:07:22.960 --> 00:07:23.670
different browsers.

00:07:23.670 --> 00:07:25.500
I wish it wasn't the case, but
that's sort of the world we

00:07:25.500 --> 00:07:26.710
live in today.

00:07:26.710 --> 00:07:29.440
Of all the specifications out
there, the one that I

00:07:29.440 --> 00:07:32.090
personally think is the best and
most suitable for games is

00:07:32.090 --> 00:07:34.810
the web audio API, which is
only in Chrome right now.

00:07:34.810 --> 00:07:37.290
And it offers just a lot
of features, sort of a

00:07:37.290 --> 00:07:40.590
graph-based audio processing
system, all kinds of

00:07:40.590 --> 00:07:42.920
out-of-the-box nodes and filters
you can just use.

00:07:42.920 --> 00:07:44.110
It's hardware accelerated.

00:07:44.110 --> 00:07:45.470
It's very accurate in
its timing, and

00:07:45.470 --> 00:07:46.500
so on, and so forth.

00:07:46.500 --> 00:07:49.100
So it will help you out.

00:07:49.100 --> 00:07:51.790
And then, there's so much more
that I just don't have time to

00:07:51.790 --> 00:07:52.500
get to today.

00:07:52.500 --> 00:07:55.570
There's all kinds of new APIs
being added to the HTML5

00:07:55.570 --> 00:07:58.190
standards all the time.

00:07:58.190 --> 00:08:00.560
Instead of trying to go over
them here, because I just

00:08:00.560 --> 00:08:02.860
don't have time, I'm going to
add a resources slide at the

00:08:02.860 --> 00:08:05.040
end where you can go and read
about any one of these

00:08:05.040 --> 00:08:06.150
particular things.

00:08:06.150 --> 00:08:07.720
There are also lots of
presentations that sort of

00:08:07.720 --> 00:08:09.610
catalog APIs for games.

00:08:09.610 --> 00:08:12.320
But suffice to say for the
moment, there are a lot of

00:08:12.320 --> 00:08:13.550
things that you should
look into.

00:08:13.550 --> 00:08:16.660
If these things don't look
familiar to you yet, then you

00:08:16.660 --> 00:08:20.290
should go look them up and see
if they're useful to you.

00:08:20.290 --> 00:08:22.180
And that's pretty
much for HTML5.

00:08:22.180 --> 00:08:24.060
Pretty much two things you need,
You need to be able to

00:08:24.060 --> 00:08:24.800
render triangles.

00:08:24.800 --> 00:08:26.870
You need to be able
to play sound.

00:08:26.870 --> 00:08:28.700
From there, you can
make a prototype.

00:08:28.700 --> 00:08:31.550
Once you've got a prototype, now
comes the hard part where

00:08:31.550 --> 00:08:33.159
you take prototype
to game engine.

00:08:33.159 --> 00:08:36.390
And that transition is all about
writing high-performance

00:08:36.390 --> 00:08:37.340
JavaScript.

00:08:37.340 --> 00:08:40.140
So that's what we're going
to talk about now.

00:08:40.140 --> 00:08:43.390
And before I get too deep into
it, a great big caveat that

00:08:43.390 --> 00:08:45.870
what I'm talking about
is JavaScript

00:08:45.870 --> 00:08:47.780
performance for Chrome.

00:08:47.780 --> 00:08:50.500
Every browser has its own
JavaScript engine, or there

00:08:50.500 --> 00:08:53.210
are many different JavaScript
implementations.

00:08:53.210 --> 00:08:55.330
And they're all going to have
different performance quirks.

00:08:55.330 --> 00:08:57.570
Certain operations are going to
be slow over here, and fast

00:08:57.570 --> 00:08:58.810
over there, and all that.

00:08:58.810 --> 00:09:01.100
So this presentation, I'm
going to try to give you

00:09:01.100 --> 00:09:02.530
general information.

00:09:02.530 --> 00:09:05.680
But this information has been
written in the context of V8

00:09:05.680 --> 00:09:08.580
and sort of confirmed with
the V8 team for accuracy.

00:09:08.580 --> 00:09:10.410
And I'm not trying to
or qualified to

00:09:10.410 --> 00:09:13.740
speak for other browsers.

00:09:13.740 --> 00:09:15.380
So let's talk JavaScript.

00:09:15.380 --> 00:09:18.620
JavaScript is a high-level
scripting language.

00:09:18.620 --> 00:09:21.250
And it's extremely permissive
in what it allows you to do,

00:09:21.250 --> 00:09:23.570
extremely squishy
in its syntax.

00:09:23.570 --> 00:09:24.730
It's typeless.

00:09:24.730 --> 00:09:25.650
It's kind of interpreted.

00:09:25.650 --> 00:09:27.280
It's just-in-time compiled.

00:09:27.280 --> 00:09:30.050
There's no explicit syntax
for memory management.

00:09:30.050 --> 00:09:33.990
And it's all running on a single
thread with some HTML5

00:09:33.990 --> 00:09:36.660
exceptions called web workers
which you should go look up if

00:09:36.660 --> 00:09:38.980
you don't know what
they are already.

00:09:38.980 --> 00:09:41.610
So the nice thing about
JavaScript is that it's great

00:09:41.610 --> 00:09:44.460
to have an application running
in JavaScript in front of your

00:09:44.460 --> 00:09:48.100
end users because it is great
at not falling down.

00:09:48.100 --> 00:09:51.280
JavaScript is great at eating
bad input and staying up.

00:09:51.280 --> 00:09:52.410
Nothing makes it crash.

00:09:52.410 --> 00:09:57.340
It's super effective at being
robust. The sort of dark side

00:09:57.340 --> 00:10:00.110
of that, though, is that because
JavaScript doesn't

00:10:00.110 --> 00:10:03.900
have a lot of structure of its
own and because it is really,

00:10:03.900 --> 00:10:06.270
really permissive in what it
allows you to do, and it never

00:10:06.270 --> 00:10:08.930
sort of spits errors at you,
that while you're developing,

00:10:08.930 --> 00:10:10.590
you're sort of stuck
in this Wild West

00:10:10.590 --> 00:10:11.520
kind of lawless world.

00:10:11.520 --> 00:10:15.470
And it's really hard to work in
that kind of unstructured

00:10:15.470 --> 00:10:16.400
environment.

00:10:16.400 --> 00:10:18.800
So from a developer standpoint,
what I usually

00:10:18.800 --> 00:10:21.420
think is that you want a really
permissive system for

00:10:21.420 --> 00:10:24.080
deployment, because you don't
want to put something in front

00:10:24.080 --> 00:10:25.710
of end users that will crash.

00:10:25.710 --> 00:10:28.230
And you want a really strict
system for development so that

00:10:28.230 --> 00:10:31.740
JavaScript doesn't allow you
to do anything silly.

00:10:31.740 --> 00:10:34.260
And JavaScript being way over
on the permissive end of the

00:10:34.260 --> 00:10:37.180
spectrum, development of
large-scale systems in it can

00:10:37.180 --> 00:10:39.830
be difficult.

00:10:39.830 --> 00:10:42.680
So what people do, because
JavaScript doesn't bring a lot

00:10:42.680 --> 00:10:45.750
of structure of its own, is that
they impose artificial

00:10:45.750 --> 00:10:47.400
structure on JavaScript.

00:10:47.400 --> 00:10:50.200
So either they have their team
follow very strict coding

00:10:50.200 --> 00:10:52.330
standards, or there are patterns
that allow you to

00:10:52.330 --> 00:10:53.330
privatize data.

00:10:53.330 --> 00:10:56.380
Even though JavaScript doesn't
have an actual way to

00:10:56.380 --> 00:10:58.230
privatize data, you can
sort of fake it

00:10:58.230 --> 00:10:59.590
with certain patterns.

00:10:59.590 --> 00:11:02.310
There are post-processing tools
that will warn you or

00:11:02.310 --> 00:11:04.550
add static types and tell
you when you're

00:11:04.550 --> 00:11:05.830
doing something silly.

00:11:05.830 --> 00:11:07.780
So there's all that kind of
stuff that you should be aware

00:11:07.780 --> 00:11:10.720
if you're making a large-scale
JavaScript application.

00:11:10.720 --> 00:11:13.590
And then you should also just
be aware that JavaScript is

00:11:13.590 --> 00:11:15.380
not going to spit a lot
of errors at you.

00:11:15.380 --> 00:11:18.680
So when there are problems in a
certain part of your system,

00:11:18.680 --> 00:11:21.370
it might be hard to figure out
what exactly has gone wrong,

00:11:21.370 --> 00:11:23.990
because JavaScript always thinks
that everything is OK.

00:11:23.990 --> 00:11:26.190
So it's hard to trace
back error chains.

00:11:26.190 --> 00:11:29.440
And in an environment like that,
you want to code extra

00:11:29.440 --> 00:11:30.480
defensively.

00:11:30.480 --> 00:11:33.760
The idea is that you want to
design your system in a

00:11:33.760 --> 00:11:35.900
modular way, which is
always a good idea.

00:11:35.900 --> 00:11:38.560
And then, hopefully, you can
design it such that if one of

00:11:38.560 --> 00:11:41.780
your modules starts behaving
strangely, starts going wonky,

00:11:41.780 --> 00:11:43.680
and you can't figure out why,
you can just kill it, and

00:11:43.680 --> 00:11:45.860
restart a fresh one, and
reconnect it to your system

00:11:45.860 --> 00:11:46.900
while the whole thing
is running.

00:11:46.900 --> 00:11:49.250
And if you can design in that
way, you'll save yourself a

00:11:49.250 --> 00:11:53.635
lot of pain dealing in the
system that's sort of squishy.

00:11:56.720 --> 00:11:59.270
So if you're still one of those
people who thinks to

00:11:59.270 --> 00:12:01.910
themselves, well, JavaScript,
that's a scripting language.

00:12:01.910 --> 00:12:04.670
You could never actually write
a high-performance credible

00:12:04.670 --> 00:12:05.880
game in JavaScript.

00:12:05.880 --> 00:12:09.000
You are dealing with seriously
dated information.

00:12:09.000 --> 00:12:11.840
JavaScript engines are really
fast these days.

00:12:11.840 --> 00:12:14.700
They are absolutely capable of
doing the kind of processing

00:12:14.700 --> 00:12:16.960
required for this
kind of game.

00:12:16.960 --> 00:12:20.310
The problem is that it's just
really easy to write bad code

00:12:20.310 --> 00:12:21.230
in JavaScript.

00:12:21.230 --> 00:12:23.760
And there are a ton of examples
of bad code in

00:12:23.760 --> 00:12:26.600
JavaScript that people tend
to follow as patterns.

00:12:26.600 --> 00:12:31.440
So not only is JavaScript
performance squirrely in that

00:12:31.440 --> 00:12:34.220
it's hard to tell what exactly
is going wrong, or small

00:12:34.220 --> 00:12:36.550
changes in your JavaScript can
have really, really big

00:12:36.550 --> 00:12:39.280
performance implications, and
that information isn't really

00:12:39.280 --> 00:12:42.810
surfaced all that well to you as
a developer, but on top of

00:12:42.810 --> 00:12:46.110
all that, the VM itself, the
actual virtual machine that's

00:12:46.110 --> 00:12:48.860
executing your JavaScript, V8
in Chrome's case, is under

00:12:48.860 --> 00:12:49.730
development too.

00:12:49.730 --> 00:12:53.330
So something that was slow
yesterday might be fast today.

00:12:53.330 --> 00:12:55.960
And so you have to keep all of
this in your mind as you're

00:12:55.960 --> 00:12:59.180
trying to write high-performance
JavaScript.

00:12:59.180 --> 00:13:02.150
So the best way I know how to
give advice on how to write

00:13:02.150 --> 00:13:05.800
high-performance JavaScript is
to explain to you the pieces,

00:13:05.800 --> 00:13:07.540
the general components
of how V8 is

00:13:07.540 --> 00:13:09.260
actually executing things.

00:13:09.260 --> 00:13:12.180
And then, you can develop an
intuition for what might be

00:13:12.180 --> 00:13:14.440
fast and what might be slow,
and go from there.

00:13:14.440 --> 00:13:17.860
So again, I'm talking about
components of V8 here.

00:13:17.860 --> 00:13:19.700
In general, these are components
you find in a lot

00:13:19.700 --> 00:13:20.940
of JavaScript engines.

00:13:20.940 --> 00:13:23.510
But this, in particular,
is referencing V8's

00:13:23.510 --> 00:13:25.500
implementation.

00:13:25.500 --> 00:13:27.930
So the components are you have
a just-in-time compiler.

00:13:27.930 --> 00:13:30.600
That compiler compiles two sum
representations, so you have

00:13:30.600 --> 00:13:32.560
an object model under
the hood.

00:13:32.560 --> 00:13:34.100
You have an optimizing
compiler that

00:13:34.100 --> 00:13:35.210
compiles after that.

00:13:35.210 --> 00:13:36.710
And then, at the end of the
day, you have a garbage

00:13:36.710 --> 00:13:39.010
collector that's running around
cleaning up after you.

00:13:39.010 --> 00:13:42.360
So I'll talk about each
of these components.

00:13:42.360 --> 00:13:45.550
First of all, the just-in-time
compiler.

00:13:45.550 --> 00:13:47.590
So the just-in-time compiler,
what it does is

00:13:47.590 --> 00:13:48.520
very easy to explain.

00:13:48.520 --> 00:13:50.230
It looks at the JavaScript
you wrote.

00:13:50.230 --> 00:13:52.780
And it takes snippets of your
JavaScript, and it turns them

00:13:52.780 --> 00:13:54.230
into native code.

00:13:54.230 --> 00:13:57.650
And that translation, the
directive of the just-in-time

00:13:57.650 --> 00:14:00.060
compiler, is to do that as
quickly as possible.

00:14:00.060 --> 00:14:05.190
It doesn't try to be overly
clever or to specialize or

00:14:05.190 --> 00:14:06.510
optimize at that point.

00:14:06.510 --> 00:14:08.520
It's trying to make the
interpretation of JavaScript

00:14:08.520 --> 00:14:10.380
files fast. So it just
does that translation

00:14:10.380 --> 00:14:11.310
as fast as it can.

00:14:11.310 --> 00:14:13.960
And it does a great job of it.

00:14:13.960 --> 00:14:15.660
So when we talk about the
just-in-time compiler, we're

00:14:15.660 --> 00:14:17.950
talking about generating
native code.

00:14:17.950 --> 00:14:20.080
So now we need to talk
about what kind of

00:14:20.080 --> 00:14:21.840
native code gets generated.

00:14:21.840 --> 00:14:23.770
We need to talk about
data types.

00:14:23.770 --> 00:14:26.980
So the first data type of
interest is numbers, numeric

00:14:26.980 --> 00:14:29.420
types, of course,
very important.

00:14:29.420 --> 00:14:33.700
So V8 has two major internal
representations of numbers.

00:14:33.700 --> 00:14:36.220
There are small ints values
and heap numbers, and they

00:14:36.220 --> 00:14:38.460
have different performance
profiles.

00:14:38.460 --> 00:14:41.960
So small ints are the case you
want to be in if you can.

00:14:41.960 --> 00:14:45.470
They are immediate values as
opposed to heap numbers, which

00:14:45.470 --> 00:14:47.490
are allocated somewhere
else on the heap.

00:14:47.490 --> 00:14:49.660
Small ints are something you're
just holding on to.

00:14:49.660 --> 00:14:52.710
And that means they're really
fast to interact with.

00:14:55.250 --> 00:14:57.750
The size of a heap number is
an interesting question.

00:14:57.750 --> 00:15:01.990
On 32-bit machines, heap numbers
are ints that are 31

00:15:01.990 --> 00:15:02.970
bits or less.

00:15:02.970 --> 00:15:07.010
On 64-bit machines, small ints
are 32 bits or less.

00:15:07.010 --> 00:15:10.820
So there's some sort
of intricacy there.

00:15:10.820 --> 00:15:13.650
In general, you probably want to
target both 32-bit machines

00:15:13.650 --> 00:15:15.250
and 64-bit machines.

00:15:15.250 --> 00:15:18.390
So you probably want
to aim for 31-bit

00:15:18.390 --> 00:15:19.940
integers if you can.

00:15:19.940 --> 00:15:22.410
Now, don't go crazy with this,
because other kinds of numbers

00:15:22.410 --> 00:15:24.150
can be optimized later too.

00:15:24.150 --> 00:15:26.970
But if you have a system, like
your OPT tree system or your

00:15:26.970 --> 00:15:30.510
particle system that lends
itself to being cast in terms

00:15:30.510 --> 00:15:34.210
of integer math, it might be a
major performance improvement

00:15:34.210 --> 00:15:37.950
for you if you can get into
these SMI values.

00:15:37.950 --> 00:15:39.020
So that's SMIs.

00:15:39.020 --> 00:15:40.070
Then we have heap numbers.

00:15:40.070 --> 00:15:43.480
So heap numbers are anything
that won't fit into an SMI and

00:15:43.480 --> 00:15:45.340
is not a local variable.

00:15:45.340 --> 00:15:48.380
So exactly like you'd expect,
these numbers can't be

00:15:48.380 --> 00:15:49.680
allocated in an immediate
mode.

00:15:49.680 --> 00:15:52.170
So they need to be wrapped up
and allocated on the heap,

00:15:52.170 --> 00:15:54.100
which means that now they're
going to be slightly slower to

00:15:54.100 --> 00:15:56.110
deal with because you're
referencing a number that's

00:15:56.110 --> 00:15:58.180
somewhere else.

00:15:58.180 --> 00:16:00.250
Now, before you go crazy, again,
I want to make sure

00:16:00.250 --> 00:16:02.880
that I don't accidentally tell
you to overspecialize.

00:16:02.880 --> 00:16:04.960
Doubles are sometimes
optimized.

00:16:04.960 --> 00:16:06.820
V8 knows that math is
really important.

00:16:06.820 --> 00:16:08.550
It's something people
want to do a lot of.

00:16:08.550 --> 00:16:10.930
So we'll try to optimize
your doubles.

00:16:10.930 --> 00:16:12.710
It'll try to allocate them
in immediate mode.

00:16:12.710 --> 00:16:15.560
It'll try to allocate them
in registers if it can.

00:16:15.560 --> 00:16:18.000
But it might not be able to, so
there's no guarantee there.

00:16:18.000 --> 00:16:20.480
So again, don't go crazy trying
to make all small ints.

00:16:20.480 --> 00:16:23.320
But if you can, if it lends
itself to your system, it

00:16:23.320 --> 00:16:26.450
could work for you.

00:16:26.450 --> 00:16:27.400
So that's numbers.

00:16:27.400 --> 00:16:29.620
Next, we need to talk
about arrays.

00:16:29.620 --> 00:16:33.360
So the first type of array to
talk about in JavaScript is

00:16:33.360 --> 00:16:34.540
the TypedArray.

00:16:34.540 --> 00:16:38.095
So TypedArrays are going to make
a lot of sense to you if

00:16:38.095 --> 00:16:39.930
you're coming from
a C background.

00:16:39.930 --> 00:16:43.930
They are contiguous blocks of
memory that are specified for

00:16:43.930 --> 00:16:45.250
a particular data type.

00:16:45.250 --> 00:16:48.430
So you have Uint32Array,
Float64Array, Uint8Array, and

00:16:48.430 --> 00:16:50.940
so on, and so forth, which
actually, if you're familiar

00:16:50.940 --> 00:16:52.610
with JavaScript, is
sort of unusual.

00:16:52.610 --> 00:16:54.690
Because most things in
JavaScript have no type.

00:16:54.690 --> 00:16:58.220
So this idea that we're
specifying a very specific

00:16:58.220 --> 00:17:01.420
size for our numbers is actually
like pretty unique.

00:17:01.420 --> 00:17:04.200
And that's because the
TypedArray specification grew

00:17:04.200 --> 00:17:07.060
up alongside the WebGL
specification.

00:17:07.060 --> 00:17:10.940
And you can imagine how you need
that level of specificity

00:17:10.940 --> 00:17:12.180
if you're doing graphics
programming.

00:17:12.180 --> 00:17:13.460
So that's sort of where
the TypedArray

00:17:13.460 --> 00:17:14.730
specification came from.

00:17:14.730 --> 00:17:17.349
But it's been adopted
into other things

00:17:17.349 --> 00:17:18.410
now that it's there.

00:17:18.410 --> 00:17:19.700
So again, they're memory
efficient.

00:17:19.700 --> 00:17:20.690
You don't have to box them.

00:17:20.690 --> 00:17:21.810
They behave as you'd expect.

00:17:21.810 --> 00:17:24.760
They're a very nice
option for arrays.

00:17:24.760 --> 00:17:27.030
But if you can't use TypedArrays
for whatever

00:17:27.030 --> 00:17:29.750
reason, you need to use
JavaScript Arrays.

00:17:29.750 --> 00:17:31.560
So JavaScript Array object--

00:17:31.560 --> 00:17:33.050
Array with a capital A--

00:17:33.050 --> 00:17:35.970
has an API which is going to
look a little weird to you if

00:17:35.970 --> 00:17:38.030
you are used to C-style
arrays.

00:17:38.030 --> 00:17:40.040
It's going to have operations
that are different.

00:17:40.040 --> 00:17:41.590
It's going to have like
push and pop.

00:17:41.590 --> 00:17:44.730
It's going to allow you to
index out of bounds.

00:17:44.730 --> 00:17:48.090
It's going to have just sort
of odd behavior to me as

00:17:48.090 --> 00:17:50.260
somebody coming from C.

00:17:50.260 --> 00:17:54.400
So as you can imagine, because
the API allows all these non-C

00:17:54.400 --> 00:17:57.850
array-like things, the backing
storage in V8 is not always

00:17:57.850 --> 00:18:00.390
something that looks
like an array.

00:18:00.390 --> 00:18:02.290
There are actually two different
types of backing

00:18:02.290 --> 00:18:03.380
storage for arrays.

00:18:03.380 --> 00:18:06.720
There are sparse arrays and
dense arrays, which map to

00:18:06.720 --> 00:18:08.700
either something that looks
like a C-style array, like

00:18:08.700 --> 00:18:11.150
you'd expect, or a hash table.

00:18:11.150 --> 00:18:14.920
And if your array is backed by a
V8 hash table, that's called

00:18:14.920 --> 00:18:16.360
being in dictionary
mode, and it's

00:18:16.360 --> 00:18:17.880
considerably less efficient.

00:18:17.880 --> 00:18:19.320
It's a case that you
want to avoid.

00:18:22.130 --> 00:18:24.440
There are many factors in V8
that causes you to be kicked

00:18:24.440 --> 00:18:27.650
into dictionary mode or not.

00:18:27.650 --> 00:18:30.210
So it's kind of complicated
to define them all.

00:18:30.210 --> 00:18:33.110
But one of them, for instance,
is space efficiency.

00:18:33.110 --> 00:18:36.700
So if the codes you wrote will
be three times more efficient,

00:18:36.700 --> 00:18:40.860
use three times less space if it
was backed by a hash table

00:18:40.860 --> 00:18:43.680
than an array, then it'll be a
hash table on the back end.

00:18:43.680 --> 00:18:45.810
So there are criteria
like that.

00:18:45.810 --> 00:18:47.430
Let me give you an example.

00:18:47.430 --> 00:18:50.360
So this is something that
JavaScript allows you to do.

00:18:50.360 --> 00:18:52.590
JavaScript allows you to create
a new uninitialized

00:18:52.590 --> 00:18:54.500
array and then just suddenly
index into

00:18:54.500 --> 00:18:56.850
it at whatever index.

00:18:56.850 --> 00:18:58.920
This, of course, doesn't make
any sense in C. It's not

00:18:58.920 --> 00:19:00.660
something you'd actually do.

00:19:00.660 --> 00:19:04.450
And in V8, it will immediately
trigger dictionary mode.

00:19:04.450 --> 00:19:07.580
So this, you will now have a
nice, slow array to work with,

00:19:07.580 --> 00:19:09.810
not something you want.

00:19:09.810 --> 00:19:12.210
This is an example of a better
way to do things.

00:19:12.210 --> 00:19:13.530
So real simple change.

00:19:13.530 --> 00:19:14.980
All you have to do is
declare how much

00:19:14.980 --> 00:19:16.280
storage you want up front.

00:19:16.280 --> 00:19:19.350
Now you have declared to V8
that you actually want an

00:19:19.350 --> 00:19:20.580
array of a certain size.

00:19:20.580 --> 00:19:23.840
V8 will back your array by a
contiguous array of that size,

00:19:23.840 --> 00:19:24.960
and you can go from there.

00:19:24.960 --> 00:19:28.980
Very sensible, kind of
no-brainerish, but again,

00:19:28.980 --> 00:19:31.810
JavaScript allows you to do it
in a way that ends up being

00:19:31.810 --> 00:19:35.830
very inefficient, so it's
important to know.

00:19:35.830 --> 00:19:38.870
So that is the numeric
representation and the

00:19:38.870 --> 00:19:41.730
immediate representation
of objects.

00:19:41.730 --> 00:19:44.060
Now, we're going to talk about
representing JavaScript

00:19:44.060 --> 00:19:46.670
objects in V8.

00:19:46.670 --> 00:19:49.620
So objects in JavaScript
are these very

00:19:49.620 --> 00:19:50.860
poorly defined things.

00:19:50.860 --> 00:19:52.630
They are associative arrays.

00:19:52.630 --> 00:19:55.340
They're just bundles of key
value pairs of properties.

00:19:55.340 --> 00:19:58.030
So you have string value for
key, property value.

00:19:58.030 --> 00:20:01.450
And all property values are
these undefined whatevers,

00:20:01.450 --> 00:20:03.740
because JavaScript doesn't
have a notion of type.

00:20:03.740 --> 00:20:05.350
Objects have prototype chains.

00:20:05.350 --> 00:20:08.440
You can add and remove
properties anywhere at the

00:20:08.440 --> 00:20:11.270
prototype chain and on the
object itself at any point.

00:20:11.270 --> 00:20:14.950
JavaScript doesn't enforce
any specificity or

00:20:14.950 --> 00:20:17.630
structure in your code.

00:20:17.630 --> 00:20:20.940
So if you wanted to, you could
make every single object in

00:20:20.940 --> 00:20:24.770
your whole program absolutely
a unique set of properties.

00:20:24.770 --> 00:20:27.510
Nothing in JavaScript will
enforce structure or

00:20:27.510 --> 00:20:29.100
self-similarity.

00:20:29.100 --> 00:20:32.130
But just because JavaScript
allows you to do that, you

00:20:32.130 --> 00:20:32.910
really, really shouldn't.

00:20:32.910 --> 00:20:35.230
That's actually a terrible thing
to do for performance.

00:20:35.230 --> 00:20:37.080
And I'll explain why
in a minute.

00:20:39.870 --> 00:20:45.220
So in V8, the V8 team looked
at trying to write a

00:20:45.220 --> 00:20:47.830
large-scale application in
JavaScript and thought, hey,

00:20:47.830 --> 00:20:49.800
you know what's important in
large-scale systems is

00:20:49.800 --> 00:20:50.870
object-orientedness.

00:20:50.870 --> 00:20:52.770
And if you have
object-orientedness in your

00:20:52.770 --> 00:20:56.020
system, then now, property
access is one of the key

00:20:56.020 --> 00:20:59.140
things that you need to make
fast. So V8 designed its

00:20:59.140 --> 00:21:03.210
structure to make property
access on objects as efficient

00:21:03.210 --> 00:21:04.660
as it could be.

00:21:04.660 --> 00:21:07.220
So the internal representation
of an object

00:21:07.220 --> 00:21:09.300
in V8 is three words.

00:21:09.300 --> 00:21:12.290
So first, we have a hidden class
pointer, which is an

00:21:12.290 --> 00:21:15.010
internal notion of type, which
I'll explain in a second.

00:21:15.010 --> 00:21:16.800
And then we have two pointers
to different kinds of

00:21:16.800 --> 00:21:17.380
properties.

00:21:17.380 --> 00:21:20.330
We have properties that have
string names and then

00:21:20.330 --> 00:21:21.800
properties that have
int names.

00:21:21.800 --> 00:21:24.330
But really, the only thing
that's important is you have a

00:21:24.330 --> 00:21:27.890
type, and then you have
property storage.

00:21:27.890 --> 00:21:29.500
So what's this hidden
class thing?

00:21:29.500 --> 00:21:31.490
So hidden classes, again,
they're V8's

00:21:31.490 --> 00:21:32.620
internal notion of type.

00:21:32.620 --> 00:21:34.845
JavaScript itself isn't going to
enforce any kind of notion

00:21:34.845 --> 00:21:36.080
of type on you.

00:21:36.080 --> 00:21:39.680
But in order to make things
efficient, V8 itself needs to

00:21:39.680 --> 00:21:42.770
have some sort of structure in
what it thinks you're doing.

00:21:42.770 --> 00:21:44.840
So it introduces
a type system.

00:21:44.840 --> 00:21:46.990
And that type system
groups objects

00:21:46.990 --> 00:21:47.830
with the same structure.

00:21:47.830 --> 00:21:50.990
So as you're adding properties
to objects, which you can do

00:21:50.990 --> 00:21:54.340
in JavaScript, V8 will be
looking at the properties on

00:21:54.340 --> 00:21:57.740
each object and mapping that
bundle of properties to a

00:21:57.740 --> 00:22:01.580
hidden class, which defines an
object with exactly those

00:22:01.580 --> 00:22:01.920
properties.

00:22:01.920 --> 00:22:06.150
So, for instance, if I have this
constructor in JavaScript

00:22:06.150 --> 00:22:09.660
where I have a point, and it
has an x and y, and the way

00:22:09.660 --> 00:22:12.340
those values are added by first
adding x to the object

00:22:12.340 --> 00:22:15.800
and then adding y, that's going
to generate a hidden

00:22:15.800 --> 00:22:19.110
class that backs objects that
are created from this function

00:22:19.110 --> 00:22:22.340
that has exactly the
properties x and y.

00:22:22.340 --> 00:22:24.510
And that really seems
sort of obvious.

00:22:24.510 --> 00:22:27.800
But then, the first time this
function is run, that hidden

00:22:27.800 --> 00:22:30.980
class is going to be built
for the first time.

00:22:30.980 --> 00:22:34.180
And then, all subsequent times
this function is run, those

00:22:34.180 --> 00:22:36.930
new objects can share the
same hidden class.

00:22:36.930 --> 00:22:38.840
So you only pay the price
for building it

00:22:38.840 --> 00:22:39.720
the very first time.

00:22:39.720 --> 00:22:43.480
After that, you can just
use the same object.

00:22:43.480 --> 00:22:45.190
So we went through all this
trouble of building up a

00:22:45.190 --> 00:22:45.930
notion of type.

00:22:45.930 --> 00:22:49.050
So now, we have types that
correspond to specifically

00:22:49.050 --> 00:22:50.960
what exact properties
are on an object.

00:22:50.960 --> 00:22:58.020
We can use that notion of type
to make property access quick

00:22:58.020 --> 00:23:01.180
using something called
inline caching.

00:23:01.180 --> 00:23:04.850
So if you want to look up a
property on an object in

00:23:04.850 --> 00:23:07.110
JavaScript, you're going to say,
I am looking for property

00:23:07.110 --> 00:23:11.920
with name x on object y.

00:23:11.920 --> 00:23:14.660
The first thing you do when
you're trying to look up a

00:23:14.660 --> 00:23:19.020
property is check the hidden
class of the object.

00:23:19.020 --> 00:23:21.990
If you've never tried to look up
that property on an object

00:23:21.990 --> 00:23:24.600
of that type before, then what
you're going to have to do is

00:23:24.600 --> 00:23:27.280
a fully generic search
for that property.

00:23:27.280 --> 00:23:28.590
So again, we just have a bundle

00:23:28.590 --> 00:23:29.450
of properties somewhere.

00:23:29.450 --> 00:23:30.600
They all have string names.

00:23:30.600 --> 00:23:32.580
You have a string of the
property you're looking for.

00:23:32.580 --> 00:23:34.880
And you're going to have to look
through that list for the

00:23:34.880 --> 00:23:36.750
property that has
a matching name.

00:23:36.750 --> 00:23:39.020
That's a pretty slow
operation.

00:23:39.020 --> 00:23:41.860
But once you found that
property once, you can

00:23:41.860 --> 00:23:43.270
remember the offset to it.

00:23:43.270 --> 00:23:45.620
You can remember where you found
that property and use it

00:23:45.620 --> 00:23:49.300
later, which means that you can
use that to generate new

00:23:49.300 --> 00:23:52.900
optimized code which specifies
how you look up that

00:23:52.900 --> 00:23:55.520
particular property on that
particular object.

00:23:55.520 --> 00:23:58.110
And the next time you want to
look up property with that

00:23:58.110 --> 00:24:00.920
name on an object of
that type, you

00:24:00.920 --> 00:24:01.830
can have direct access.

00:24:01.830 --> 00:24:04.220
You know exactly where to go
in an object of that type.

00:24:04.220 --> 00:24:06.190
And it's much, much,
much faster.

00:24:06.190 --> 00:24:09.470
So that's really what the notion
of having hidden class

00:24:09.470 --> 00:24:12.910
is getting us, is now we can
make property access really

00:24:12.910 --> 00:24:15.970
fast through inline caching.

00:24:15.970 --> 00:24:19.110
So this is a classic example
of a bad idea.

00:24:19.110 --> 00:24:21.380
So I have another constructor.

00:24:21.380 --> 00:24:23.200
It's creating a vector object.

00:24:23.200 --> 00:24:25.190
It's adding an x and y.

00:24:25.190 --> 00:24:27.730
But then, after I go through the
trouble of doing that, I

00:24:27.730 --> 00:24:31.100
decide that I now wanted
property z on this object.

00:24:31.100 --> 00:24:34.140
The problem with that is that
if you add a property z to

00:24:34.140 --> 00:24:36.760
that object at some future
point, if you just dynamically

00:24:36.760 --> 00:24:39.480
do that, you're going to change
the hidden class of the

00:24:39.480 --> 00:24:42.290
object, which means that all
this nice caching you've done

00:24:42.290 --> 00:24:44.140
and building up a notion of
where the properties are,

00:24:44.140 --> 00:24:45.520
that's just blown away
because now you have

00:24:45.520 --> 00:24:46.350
a new hidden class.

00:24:46.350 --> 00:24:48.090
You have to pay to build the new
hidden class, and now you

00:24:48.090 --> 00:24:50.720
have to deal with a
new hidden class.

00:24:50.720 --> 00:24:53.160
So one of the best things you
can do to make your code

00:24:53.160 --> 00:24:56.250
efficient is to create a
few well-defined types.

00:24:56.250 --> 00:24:58.910
Don't do a lot of dynamic
property adding and removing

00:24:58.910 --> 00:25:00.350
outside of constructors.

00:25:00.350 --> 00:25:03.100
Pretty much set things up once,
have them look alike so

00:25:03.100 --> 00:25:05.890
that they can share the same
hidden class, and don't mess

00:25:05.890 --> 00:25:09.520
with the properties they have.

00:25:09.520 --> 00:25:11.730
So now we know an object
has properties.

00:25:11.730 --> 00:25:15.680
Those properties can be in
different storage states.

00:25:15.680 --> 00:25:17.830
So the first state, the default,
is that they can be

00:25:17.830 --> 00:25:19.690
stored directly in an
array on the object.

00:25:19.690 --> 00:25:20.330
That's great.

00:25:20.330 --> 00:25:22.270
That's fast. That's where
you want to be.

00:25:22.270 --> 00:25:25.410
A second state they can be in
is being stored in array off

00:25:25.410 --> 00:25:26.020
the objects.

00:25:26.020 --> 00:25:26.640
Still great.

00:25:26.640 --> 00:25:27.260
Still an array.

00:25:27.260 --> 00:25:28.710
No problem.

00:25:28.710 --> 00:25:30.980
The third case, which is the
one you really have to look

00:25:30.980 --> 00:25:33.650
out for, is when they're
stored in a hash table.

00:25:33.650 --> 00:25:36.900
So much like just the array case
in general where arrays

00:25:36.900 --> 00:25:39.210
can have different types of
backing storage, properties

00:25:39.210 --> 00:25:41.120
can have different types
of backing storage too.

00:25:41.120 --> 00:25:43.350
So properties can either be in
normal mode where they're

00:25:43.350 --> 00:25:46.280
stored as an array or a
dictionary mode where they're

00:25:46.280 --> 00:25:47.530
stored as a hash table.

00:25:47.530 --> 00:25:49.640
And if you have an object in
dictionary mode, it's going to

00:25:49.640 --> 00:25:51.070
be much slower to
interact with.

00:25:51.070 --> 00:25:53.420
So you don't want that.

00:25:53.420 --> 00:25:56.440
So what triggers dictionary
mode, and how do you avoid it?

00:25:56.440 --> 00:25:58.850
Well, one thing that triggers
it is too many properties.

00:25:58.850 --> 00:26:01.390
So if you have so many
properties that they won't fit

00:26:01.390 --> 00:26:03.780
into the internal storage for
properties, then you have to

00:26:03.780 --> 00:26:05.860
have a hash table elsewhere.

00:26:05.860 --> 00:26:07.580
And that number of too
many properties is

00:26:07.580 --> 00:26:08.580
somewhere around 30.

00:26:08.580 --> 00:26:12.620
It's quite generous, but you
might hit it in some cases.

00:26:12.620 --> 00:26:16.890
The other things you can do to
confuse your object and kick

00:26:16.890 --> 00:26:19.450
it into dictionary mode
are to change the

00:26:19.450 --> 00:26:20.490
properties on that object.

00:26:20.490 --> 00:26:23.150
You can change the attribute,
you can delete properties,

00:26:23.150 --> 00:26:23.710
that kind of thing.

00:26:23.710 --> 00:26:25.030
Those things are all going
to kick you straight to

00:26:25.030 --> 00:26:25.910
dictionary mode.

00:26:25.910 --> 00:26:28.720
Again, and now you're going to
make your object much slower

00:26:28.720 --> 00:26:29.970
to interact with.

00:26:33.330 --> 00:26:34.480
So that's object storage.

00:26:34.480 --> 00:26:37.180
And we have a general idea of
what we want to do, which is

00:26:37.180 --> 00:26:41.490
pretty much create repeating
common stable structures in

00:26:41.490 --> 00:26:43.620
our code, not change them too
much so we can do all our nice

00:26:43.620 --> 00:26:44.790
caching and stuff.

00:26:44.790 --> 00:26:46.670
Now, we're going to talk about
the optimizing compiler which

00:26:46.670 --> 00:26:50.220
is how you really make
JavaScript fast.

00:26:50.220 --> 00:26:53.550
So the optimizing compiler is
the second of two compilers.

00:26:53.550 --> 00:26:55.550
Remember, we had the
just-in-time compiler first,

00:26:55.550 --> 00:26:57.930
which is doing its best to just
make the translation from

00:26:57.930 --> 00:27:00.750
JavaScript to native code
as fast as it can.

00:27:00.750 --> 00:27:02.650
And then, we have this other
compiler, the optimizing

00:27:02.650 --> 00:27:04.670
compiler, which is actually
going to look at that code

00:27:04.670 --> 00:27:09.550
that's generated and try to make
it really good fast code.

00:27:09.550 --> 00:27:14.050
So because JavaScript doesn't
give you any language to tell

00:27:14.050 --> 00:27:17.130
V8 what you're intending, the
only thing that the optimizing

00:27:17.130 --> 00:27:20.820
compiler can do is sit back and
watch your system as it

00:27:20.820 --> 00:27:23.330
warms up and try to infer
structures in your code.

00:27:23.330 --> 00:27:24.500
It's going to watch
what you're doing.

00:27:24.500 --> 00:27:28.620
It's going to watch for what
types are where and how the

00:27:28.620 --> 00:27:31.250
data is flowing through it, and
then make inferences about

00:27:31.250 --> 00:27:34.120
the kinds of optimizations
that it can do.

00:27:34.120 --> 00:27:38.710
So this is a costly operation,
which is why we don't actually

00:27:38.710 --> 00:27:41.200
just try to optimize
everything.

00:27:41.200 --> 00:27:43.850
The system only tries to
optimize functions that have

00:27:43.850 --> 00:27:47.125
been deemed to be worthwhile,
and that decision is made from

00:27:47.125 --> 00:27:48.030
a profiler thread.

00:27:48.030 --> 00:27:51.070
So when Crankshaft, which is
the name of V8's optimizing

00:27:51.070 --> 00:27:54.470
compiler, spins up, spins up a
profiling thread to watch for

00:27:54.470 --> 00:27:57.880
what functions are hot, when
it sees a function that it

00:27:57.880 --> 00:28:00.640
thinks should be optimized, it
then looks at the type data

00:28:00.640 --> 00:28:01.600
it's collected so far.

00:28:01.600 --> 00:28:03.890
So it's like, ah, this function
seems to take ints

00:28:03.890 --> 00:28:04.440
all the time.

00:28:04.440 --> 00:28:06.690
And it seems to return this
kind of data, and

00:28:06.690 --> 00:28:07.770
so on, and so forth.

00:28:07.770 --> 00:28:11.160
And using that type data that
it's collected, it can do all

00:28:11.160 --> 00:28:12.170
sorts of optimization.

00:28:12.170 --> 00:28:13.400
It can inline code.

00:28:13.400 --> 00:28:16.210
It can do loop invariant
code motion.

00:28:16.210 --> 00:28:18.710
It can do all sorts of
optimizations and specialize

00:28:18.710 --> 00:28:19.620
on those types.

00:28:19.620 --> 00:28:23.160
Then, it can take the new
optimized fast path code it

00:28:23.160 --> 00:28:25.790
generated, do on-stack
replacement to just swap it

00:28:25.790 --> 00:28:28.820
out in place, hold on to the old
slow code, just in case it

00:28:28.820 --> 00:28:32.530
needs it later, and continue on
executing without anybody

00:28:32.530 --> 00:28:34.140
knowing the difference except
for that the code is much,

00:28:34.140 --> 00:28:35.500
much faster now.

00:28:35.500 --> 00:28:39.140
So the optimizing compiler is
really the heart of what will

00:28:39.140 --> 00:28:42.590
make your game JavaScript
performant.

00:28:42.590 --> 00:28:45.330
And you really need to be
working with this system to

00:28:45.330 --> 00:28:48.170
try to play nice with it.

00:28:48.170 --> 00:28:51.200
So what kind of structures are
optimized by Crankshaft?

00:28:51.200 --> 00:28:52.350
Well, I'll tell you,
not everything.

00:28:52.350 --> 00:28:55.230
Not everything is an eligible
construct in your JavaScript

00:28:55.230 --> 00:28:57.130
for optimization.

00:28:57.130 --> 00:28:59.870
When Crankshaft looks at a
function, it's like, ah, I

00:28:59.870 --> 00:29:00.610
want to optimize that.

00:29:00.610 --> 00:29:02.170
It starts trying to
optimize the code.

00:29:02.170 --> 00:29:04.240
And then in the middle, it hits
something that it can't

00:29:04.240 --> 00:29:05.000
actually do.

00:29:05.000 --> 00:29:07.180
It finds something that
it can't optimize.

00:29:07.180 --> 00:29:09.500
That's a condition
we call bailout.

00:29:09.500 --> 00:29:11.230
Bailout means I tried
to optimize this.

00:29:11.230 --> 00:29:12.680
I tried for you, but actually,
I couldn't

00:29:12.680 --> 00:29:13.640
do it for some reason.

00:29:13.640 --> 00:29:16.950
So I'm just going to not
try to optimize that.

00:29:16.950 --> 00:29:18.940
And there are a number of things
that cause bailouts.

00:29:18.940 --> 00:29:20.800
And they actually change
a good deal.

00:29:20.800 --> 00:29:24.170
So one thing is that functions
are too long.

00:29:24.170 --> 00:29:26.080
Functions that are really,
really long are not candidates

00:29:26.080 --> 00:29:27.170
for optimization.

00:29:27.170 --> 00:29:30.030
This is an interesting case
because some of these tools

00:29:30.030 --> 00:29:31.730
that try to make your JavaScript
fast, like

00:29:31.730 --> 00:29:35.640
post-processing tools, like
closure, some of those in some

00:29:35.640 --> 00:29:38.530
cases do such aggressive
in-lining that they create

00:29:38.530 --> 00:29:39.690
these giant functions.

00:29:39.690 --> 00:29:41.590
And then, those giant functions
are no longer

00:29:41.590 --> 00:29:44.570
candidates for optimization
by Crankshaft.

00:29:44.570 --> 00:29:46.280
And so they actually make the
code a good deal slower.

00:29:46.280 --> 00:29:47.870
I've seen this happen.

00:29:47.870 --> 00:29:50.860
So when I see function too long,
you probably wouldn't

00:29:50.860 --> 00:29:52.560
write it, a function
that long.

00:29:52.560 --> 00:29:53.670
But something that's

00:29:53.670 --> 00:29:55.520
post-processing your code might.

00:29:55.520 --> 00:29:58.820
So you should keep
your eye on it.

00:29:58.820 --> 00:30:01.310
And other than that, there are
just a number of specific

00:30:01.310 --> 00:30:02.890
cases that can't be optimized.

00:30:02.890 --> 00:30:05.570
If you want to see what's
being optimized and what

00:30:05.570 --> 00:30:08.430
isn't, you can use these
two handy V8 flags.

00:30:08.430 --> 00:30:10.600
You can use trace-bailout,
and trace-opt.

00:30:10.600 --> 00:30:13.490
Tract-bailout will spit out
the function names of what

00:30:13.490 --> 00:30:15.010
things are bailing
out and why.

00:30:15.010 --> 00:30:16.190
Trace-opt will tell you what

00:30:16.190 --> 00:30:17.740
functions are getting optimized.

00:30:17.740 --> 00:30:22.450
So I have a bunch of specific
output from trace-bailout.

00:30:22.450 --> 00:30:26.270
These actually came from a
recent trace that I ran.

00:30:26.270 --> 00:30:28.170
And you can see, this
sort of makes sense.

00:30:28.170 --> 00:30:29.230
They're very readable--

00:30:29.230 --> 00:30:31.260
tryCatch not supported,
Forin not supported,

00:30:31.260 --> 00:30:33.250
NonStringToString
not supported.

00:30:33.250 --> 00:30:35.270
I debated a lot putting
them on the slide.

00:30:35.270 --> 00:30:38.620
I wanted to put something up
here as representative.

00:30:38.620 --> 00:30:41.050
But just know that these are the
types of things that will

00:30:41.050 --> 00:30:43.840
change, like the V8 team is
trying to optimize this.

00:30:43.840 --> 00:30:45.350
They're trying to handle
more cases.

00:30:45.350 --> 00:30:48.540
So just keep checking in about
what in your code is bailing

00:30:48.540 --> 00:30:50.620
out and what is working
well, and keep

00:30:50.620 --> 00:30:51.870
watching with the flags.

00:30:54.520 --> 00:30:58.070
So the thing is, all those
wonderful optimizations that

00:30:58.070 --> 00:31:00.870
Crankshaft made for you when it
does successfully optimize

00:31:00.870 --> 00:31:02.750
functions are speculative.

00:31:02.750 --> 00:31:05.170
They are based on the
information that Crankshaft

00:31:05.170 --> 00:31:07.040
has at the time they are made.

00:31:07.040 --> 00:31:08.720
So again, the way Crankshaft
works, it

00:31:08.720 --> 00:31:09.880
just watches the system.

00:31:09.880 --> 00:31:11.590
It infers what patterns
are where.

00:31:11.590 --> 00:31:14.260
It sees what the types kind of
are, and then, it tries to

00:31:14.260 --> 00:31:15.930
specialize based on that.

00:31:15.930 --> 00:31:18.510
So if your code always did
things a certain way, it

00:31:18.510 --> 00:31:20.750
always passed this function
ints, and then suddenly, it's

00:31:20.750 --> 00:31:22.980
like, nah, I want to pass this
function objects or strings or

00:31:22.980 --> 00:31:28.570
whatever, suddenly, the
assumptions that were made to

00:31:28.570 --> 00:31:30.440
optimize that code
are violated.

00:31:30.440 --> 00:31:32.770
And that results in something
called the deopt, which is

00:31:32.770 --> 00:31:36.080
where we have to take that slow
code that we kept around

00:31:36.080 --> 00:31:38.940
just in case and swap it back
in for the fast code.

00:31:38.940 --> 00:31:40.970
And deoptimizations
are really tragic.

00:31:40.970 --> 00:31:42.410
They're sort of a double fail.

00:31:42.410 --> 00:31:45.400
Because you paid to optimize the
code, which was expensive.

00:31:45.400 --> 00:31:46.330
And you paid to swap it in.

00:31:46.330 --> 00:31:48.580
And then you paid to swap
it back out again.

00:31:48.580 --> 00:31:51.100
And now, you're running slow
code again on a function that

00:31:51.100 --> 00:31:52.470
Crankshaft thought it
should optimize.

00:31:52.470 --> 00:31:55.180
So you really don't want
deoptimizations.

00:31:55.180 --> 00:31:59.330
The way you tell whether your
code is deopting is using

00:31:59.330 --> 00:32:01.260
another handy flag in
V8-- trace-deopt.

00:32:01.260 --> 00:32:02.870
And that, again, it'll
tell you the

00:32:02.870 --> 00:32:03.820
names of the functions.

00:32:03.820 --> 00:32:08.270
It'll output them to stdout,
the names of the functions

00:32:08.270 --> 00:32:09.260
that are deopting and why.

00:32:09.260 --> 00:32:13.140
So keep an eye on that as
you write your game.

00:32:13.140 --> 00:32:16.140
So in general, what you should
be taking away from all this

00:32:16.140 --> 00:32:18.640
is that JavaScript, it's
this wonderfully

00:32:18.640 --> 00:32:19.940
elegant dynamic language.

00:32:19.940 --> 00:32:22.110
So once you get used to it,
you can do all this stuff

00:32:22.110 --> 00:32:24.000
which is very JavaScripty.

00:32:24.000 --> 00:32:26.810
You can dynamically add
properties and take optional

00:32:26.810 --> 00:32:29.230
arguments to functions and
use closures in this

00:32:29.230 --> 00:32:31.830
very elegant way.

00:32:31.830 --> 00:32:34.320
Whenever you see something
that's really dynamic and

00:32:34.320 --> 00:32:37.740
really JavaScripty, you should
be a little bit suspicious,

00:32:37.740 --> 00:32:41.090
because, just because you're
not writing native code,

00:32:41.090 --> 00:32:43.180
doesn't mean that someone isn't
writing native code.

00:32:43.180 --> 00:32:46.270
Remember that Crankshaft is over
here watching what you do

00:32:46.270 --> 00:32:49.190
and trying to figure out what
you mean, trying to infer from

00:32:49.190 --> 00:32:50.560
your program's behavior
what you mean.

00:32:50.560 --> 00:32:53.560
So if you keep changing what
your program does, it can't

00:32:53.560 --> 00:32:54.800
help you optimize.

00:32:54.800 --> 00:32:58.390
So the more type stable and
predictable and C-like you can

00:32:58.390 --> 00:33:02.160
make your code, the better
you're going to be.

00:33:02.160 --> 00:33:04.600
So again, that's a
rule of thumb.

00:33:04.600 --> 00:33:09.740
JavaScripty JavaScriptisms can
be fast. But if you want like

00:33:09.740 --> 00:33:13.860
a hard-and-fast rule, the more
like C it is, those things are

00:33:13.860 --> 00:33:16.830
likely to be faster.

00:33:16.830 --> 00:33:19.960
So in terms of other rules, so
create a few well-defined

00:33:19.960 --> 00:33:22.230
object types.

00:33:22.230 --> 00:33:25.880
Don't add way too many
properties to objects.

00:33:25.880 --> 00:33:27.300
Keep it reasonable.

00:33:27.300 --> 00:33:30.310
Don't start changing the data
types your functions take.

00:33:30.310 --> 00:33:33.730
Try to make things type
stable and C like.

00:33:33.730 --> 00:33:36.980
Don't use functions that
are way too big.

00:33:36.980 --> 00:33:40.180
And in general, just as you
develop, keep an eye on what's

00:33:40.180 --> 00:33:41.140
going on in V8.

00:33:41.140 --> 00:33:44.270
Profile occasionally with
trace-deopt, trace-GC,

00:33:44.270 --> 00:33:50.140
trace-bailout, and see what's
going on and just keep an eye.

00:33:50.140 --> 00:33:51.700
Now the last thing.

00:33:51.700 --> 00:33:54.290
We'll talk about the
garbage collector.

00:33:54.290 --> 00:33:58.330
So JavaScript, of course, is a
garbage-collected language.

00:33:58.330 --> 00:34:02.660
And garbage collection hitches
are one of the very first

00:34:02.660 --> 00:34:05.200
performance problems I hear
people complaining about.

00:34:05.200 --> 00:34:08.290
When people write large-scale
JavaScript systems, one of the

00:34:08.290 --> 00:34:10.580
first things they come back
with is like, wow, we're

00:34:10.580 --> 00:34:12.570
getting this like sawtooth
performance curve.

00:34:12.570 --> 00:34:13.250
What's up with that?

00:34:13.250 --> 00:34:17.139
And that's the garbage
collector going.

00:34:17.139 --> 00:34:21.080
So V8's garbage collector is
a precise, incremental,

00:34:21.080 --> 00:34:23.020
generational garbage
collector.

00:34:23.020 --> 00:34:25.480
Of all those adjectives, the
one you really need to care

00:34:25.480 --> 00:34:28.170
about is generational, which
really just means there are

00:34:28.170 --> 00:34:31.360
two areas of memory,
two or more.

00:34:31.360 --> 00:34:32.320
There are actually more.

00:34:32.320 --> 00:34:35.270
But two areas of memory for
all intents and purposes.

00:34:35.270 --> 00:34:37.130
There is a small
area that's for

00:34:37.130 --> 00:34:38.250
really short-lived objects.

00:34:38.250 --> 00:34:41.340
And then, there's an area for
objects that are going to live

00:34:41.340 --> 00:34:43.590
a long time.

00:34:43.590 --> 00:34:45.650
And if you want to see what's
going on with the garbage

00:34:45.650 --> 00:34:48.940
collector, you could run again
a handy dandy V8 flag--

00:34:48.940 --> 00:34:49.659
trace-GC.

00:34:49.659 --> 00:34:51.790
And that will spew a bunch of
information about what's going

00:34:51.790 --> 00:34:56.159
on with the garbage collector
for your perusal.

00:34:56.159 --> 00:34:58.640
So if you're trying to make
an application that is

00:34:58.640 --> 00:35:00.870
garbage-collector friendly, one
of the things you should

00:35:00.870 --> 00:35:03.330
be aware of is that promotion
is expensive.

00:35:03.330 --> 00:35:03.960
So again, we have a

00:35:03.960 --> 00:35:05.240
generational garbage collector.

00:35:05.240 --> 00:35:07.750
So we have a young generation
and an older generation.

00:35:07.750 --> 00:35:11.730
And the promotion of objects
from the young to the old

00:35:11.730 --> 00:35:14.190
generation is expensive because
you're actually

00:35:14.190 --> 00:35:16.890
copying an object out of one
area of memory into another

00:35:16.890 --> 00:35:17.840
area of memory.

00:35:17.840 --> 00:35:21.110
So one of the worst things you
can do is you can have an

00:35:21.110 --> 00:35:23.520
object that lives just long
enough to get promoted, and

00:35:23.520 --> 00:35:25.300
then you forget about it.

00:35:25.300 --> 00:35:28.050
So you want, in general, either
objects that are going

00:35:28.050 --> 00:35:30.290
to live a very short time or
objects that are going to live

00:35:30.290 --> 00:35:31.120
a very long time.

00:35:31.120 --> 00:35:36.120
Medium-lived objects, you're
kind of wasting some time

00:35:36.120 --> 00:35:38.440
promoting them.

00:35:38.440 --> 00:35:42.810
The other thing you need to be
aware of is that in a system

00:35:42.810 --> 00:35:45.700
that is garbage collected, it's
very important that you

00:35:45.700 --> 00:35:47.880
release your references
to things.

00:35:47.880 --> 00:35:51.980
Pretty obvious, except for that
in JavaScript, you can

00:35:51.980 --> 00:35:53.590
have these large systems that
are sort of hard to tell

00:35:53.590 --> 00:35:54.420
what's going.

00:35:54.420 --> 00:35:57.040
Also, there are some tricky
things in JavaScript that can

00:35:57.040 --> 00:35:58.550
hold on to references for you.

00:35:58.550 --> 00:36:02.030
So for instance, execution
contexts and closures can both

00:36:02.030 --> 00:36:04.100
hold onto references
for objects and not

00:36:04.100 --> 00:36:05.070
let them get collected.

00:36:05.070 --> 00:36:07.300
So you need to be a little
careful with your JavaScript.

00:36:07.300 --> 00:36:11.120
Keep track of where all
your memory is.

00:36:11.120 --> 00:36:13.450
And then, the number one thing
you can do to make a

00:36:13.450 --> 00:36:15.470
garbage-collector friendly
application is to

00:36:15.470 --> 00:36:16.900
not generate garbage.

00:36:16.900 --> 00:36:20.110
And that will help you
avoid GC stalls.

00:36:20.110 --> 00:36:24.130
So the difficulty with that is
that most things are objects

00:36:24.130 --> 00:36:24.840
in JavaScript.

00:36:24.840 --> 00:36:27.370
Temp variables, closures, all of
this other kind of stuff is

00:36:27.370 --> 00:36:28.000
JavaScript.

00:36:28.000 --> 00:36:30.890
Very few things aren't.

00:36:30.890 --> 00:36:33.940
Small ints, for instance,
are one thing that is

00:36:33.940 --> 00:36:34.700
an immediate value.

00:36:34.700 --> 00:36:37.290
So that's another really good
reason to use small ints.

00:36:37.290 --> 00:36:39.780
Other than that, good rules of
thumb are to use scratch pads,

00:36:39.780 --> 00:36:44.100
sort of reuse variables between
functions, and to

00:36:44.100 --> 00:36:46.690
update things in place
where you can.

00:36:46.690 --> 00:36:49.870
So, for instance, this is an
example of a classic bad idea.

00:36:49.870 --> 00:36:52.170
So it's just a simple
vector add function.

00:36:52.170 --> 00:36:53.200
One of the first things
you're going to

00:36:53.200 --> 00:36:54.590
need is a math library.

00:36:54.590 --> 00:36:57.460
You might think that this was a
good way to write it, except

00:36:57.460 --> 00:36:59.900
for that this actually allocates
a brand new vector

00:36:59.900 --> 00:37:02.080
object every time you try to
do a vector add, which is

00:37:02.080 --> 00:37:03.460
going to be often.

00:37:03.460 --> 00:37:05.500
So that's going to be really,
really garbage-collector

00:37:05.500 --> 00:37:07.300
unfriendly.

00:37:07.300 --> 00:37:08.670
This is a much better
way to write it.

00:37:08.670 --> 00:37:11.930
I actually much prefer
the first syntax.

00:37:11.930 --> 00:37:14.310
But this is a much better way to
write it in the context of

00:37:14.310 --> 00:37:16.540
a garbage collector where
you actually add

00:37:16.540 --> 00:37:17.510
to the first vector.

00:37:17.510 --> 00:37:19.490
You just update the first
vector in place.

00:37:19.490 --> 00:37:21.920
You don't allocate
a new object.

00:37:21.920 --> 00:37:24.410
So this is going to
work a lot better.

00:37:24.410 --> 00:37:27.680
Subtle point here is that if
you're working with doubles

00:37:27.680 --> 00:37:32.270
again, you might be boxing and
allocating new heap numbers.

00:37:32.270 --> 00:37:33.870
So this might create
some garbage

00:37:33.870 --> 00:37:34.920
collector pressure anyway.

00:37:34.920 --> 00:37:36.210
But it's still going
to be much better.

00:37:38.900 --> 00:37:41.710
So now you know how to write a
high-performance JavaScript

00:37:41.710 --> 00:37:42.260
application.

00:37:42.260 --> 00:37:45.120
Or hopefully, you have some
intuition as to what might be

00:37:45.120 --> 00:37:47.510
fast, what might be slow, and
how to check whether things

00:37:47.510 --> 00:37:49.350
are going well or not
in your JavaScript.

00:37:49.350 --> 00:37:50.610
That's awesome.

00:37:50.610 --> 00:37:53.470
Now, we have to take that
application and put it Chrome

00:37:53.470 --> 00:37:55.240
in the context of Chrome
where all this other

00:37:55.240 --> 00:37:55.950
stuff is going on.

00:37:55.950 --> 00:37:58.700
So let's talk about that.

00:37:58.700 --> 00:38:00.480
So first of all, when you're
in Chrome or when you're in

00:38:00.480 --> 00:38:04.490
any browser, it's just very
different than being on a PC

00:38:04.490 --> 00:38:05.050
or a console.

00:38:05.050 --> 00:38:06.810
There's a lot of stuff
you don't know.

00:38:06.810 --> 00:38:09.730
You don't know what
browser you're in.

00:38:09.730 --> 00:38:12.590
And different browsers, they
have different performance

00:38:12.590 --> 00:38:14.100
profiles for different
operations.

00:38:14.100 --> 00:38:17.080
And also, they support
different HTML5 API.

00:38:17.080 --> 00:38:19.780
So every single thing you do,
you need to check whether it's

00:38:19.780 --> 00:38:22.090
supported here.

00:38:22.090 --> 00:38:23.840
You don't know anything about
the local hardware.

00:38:23.840 --> 00:38:26.730
And this is a really hard one
for people to get their head

00:38:26.730 --> 00:38:29.370
around how important this is.

00:38:29.370 --> 00:38:32.210
Most game developers who are
coming from the console PC

00:38:32.210 --> 00:38:36.330
space have never had to deal
with a range of hardware so

00:38:36.330 --> 00:38:39.340
broad as you have
to for the web.

00:38:39.340 --> 00:38:42.630
Everything from a five-year-old
phone to the

00:38:42.630 --> 00:38:45.420
latest and greatest desktop
system of today, that's the

00:38:45.420 --> 00:38:48.920
range of things that
can run HTML5.

00:38:48.920 --> 00:38:51.220
And so you can get these huge
performance differences, which

00:38:51.220 --> 00:38:55.200
means that it's very important
that you do a lot of checking

00:38:55.200 --> 00:38:59.410
in your code about what the
local system can handle.

00:38:59.410 --> 00:39:00.590
Another thing you have
to know is that your

00:39:00.590 --> 00:39:02.060
game lives in a tab.

00:39:02.060 --> 00:39:03.520
What does that mean to you?

00:39:03.520 --> 00:39:05.740
It means that that tab can
actually close at any time.

00:39:05.740 --> 00:39:06.580
Now, this is always true.

00:39:06.580 --> 00:39:09.630
If you're writing a console
game, the user can walk up and

00:39:09.630 --> 00:39:11.340
hit the power button
on the console.

00:39:11.340 --> 00:39:14.320
That's always an issue, except
for that the way people

00:39:14.320 --> 00:39:17.260
interact with tabs in a browser
is far more ephemeral.

00:39:17.260 --> 00:39:19.610
It's very normal for somebody
to be playing a web game and

00:39:19.610 --> 00:39:21.840
then be like, oh, I want to
check email and just close

00:39:21.840 --> 00:39:22.800
that tab down.

00:39:22.800 --> 00:39:25.040
And this is important for you
to know, because if you're

00:39:25.040 --> 00:39:27.610
writing files to local cache or
something like that, you're

00:39:27.610 --> 00:39:29.340
going to have to be very careful
that you're ready to

00:39:29.340 --> 00:39:32.600
be shut down at any time.

00:39:32.600 --> 00:39:34.260
There might be other
applications running in your

00:39:34.260 --> 00:39:34.910
same thread.

00:39:34.910 --> 00:39:37.240
Here, I'm talking about
Chrome specifically.

00:39:37.240 --> 00:39:39.950
So you might not have the whole
thread to work with.

00:39:39.950 --> 00:39:42.230
And there's this other
compositing and rendering

00:39:42.230 --> 00:39:44.840
cycle that's going around your
game that's making the whole

00:39:44.840 --> 00:39:46.090
web page itself.

00:39:46.090 --> 00:39:49.070
And so you need to fit
into that as well.

00:39:49.070 --> 00:39:51.380
So let's talk about this
local hardware thing.

00:39:51.380 --> 00:39:53.980
So you know nothing about
the local environment.

00:39:53.980 --> 00:39:56.100
And I know I just said
this, but I really

00:39:56.100 --> 00:39:58.150
can't stress it enough.

00:39:58.150 --> 00:40:01.660
Because of privacy concerns,
there's nothing in JavaScript

00:40:01.660 --> 00:40:04.200
that allows you to ask detailed
questions about a

00:40:04.200 --> 00:40:05.180
user's local machine.

00:40:05.180 --> 00:40:07.320
So there's no way that
you can ask what kind

00:40:07.320 --> 00:40:08.370
of hardware is this?

00:40:08.370 --> 00:40:09.860
What can it support?

00:40:09.860 --> 00:40:12.270
So you're just in charge
of being able to

00:40:12.270 --> 00:40:14.780
scale on your own.

00:40:14.780 --> 00:40:16.330
And in the PC world,
this is not a

00:40:16.330 --> 00:40:18.850
problem because PC games--

00:40:18.850 --> 00:40:20.520
console games don't have this
problem to begin with.

00:40:20.520 --> 00:40:23.660
PC games specifically say
on them what the system

00:40:23.660 --> 00:40:24.370
requirements are.

00:40:24.370 --> 00:40:25.290
And everybody's used to that.

00:40:25.290 --> 00:40:27.740
Everybody's happy with that.

00:40:27.740 --> 00:40:31.120
On the web, people have this
expectation that everything be

00:40:31.120 --> 00:40:33.170
lowest common denominator,
which is a

00:40:33.170 --> 00:40:34.000
blessing and a curse.

00:40:34.000 --> 00:40:35.760
I love that you get broad
distribution.

00:40:35.760 --> 00:40:38.680
However, it makes it really
hard if you're trying to

00:40:38.680 --> 00:40:40.580
target the high end.

00:40:40.580 --> 00:40:43.640
And so what you can do that
this is just be very, very

00:40:43.640 --> 00:40:46.590
clear with your users about
how your game will run on

00:40:46.590 --> 00:40:47.390
their machine.

00:40:47.390 --> 00:40:50.560
The last thing you want is to
have your users buy your game

00:40:50.560 --> 00:40:53.520
from some web app store, the
Chrome Web Store, for

00:40:53.520 --> 00:40:56.760
instance, and try to play it,
and then find that it doesn't

00:40:56.760 --> 00:40:59.290
run, or it runs at 5 FPS or
whatever, because they're

00:40:59.290 --> 00:41:00.740
running on very old hardware.

00:41:00.740 --> 00:41:02.120
And then, they give you
a one-star review.

00:41:02.120 --> 00:41:03.050
They're like, this game sucks.

00:41:03.050 --> 00:41:03.730
I can't run it.

00:41:03.730 --> 00:41:07.180
So you really, really need to
be communicating proactively

00:41:07.180 --> 00:41:08.790
with your users about
what they can

00:41:08.790 --> 00:41:09.770
expect from your game.

00:41:09.770 --> 00:41:10.810
I can't stress that enough.

00:41:10.810 --> 00:41:14.610
It's like really important
for end-user experience.

00:41:14.610 --> 00:41:16.950
Also, if you can, you want
graceful degradation where

00:41:16.950 --> 00:41:18.080
it's not just a binary thing.

00:41:18.080 --> 00:41:20.840
You want to be able to make your
games gracefully scaled

00:41:20.840 --> 00:41:24.320
down to fit on lower-end
hardware.

00:41:24.320 --> 00:41:26.320
So one thing you can do
to that end is micro

00:41:26.320 --> 00:41:27.230
benchmarking.

00:41:27.230 --> 00:41:28.760
And so this is where
you, yourself--

00:41:28.760 --> 00:41:29.950
again, it's all home brew.

00:41:29.950 --> 00:41:31.550
Nothing in the JavaScript
standards helps you.

00:41:31.550 --> 00:41:34.550
But you, yourself, write little
benchmarks that stress

00:41:34.550 --> 00:41:37.370
what your game is going
to stress and

00:41:37.370 --> 00:41:38.350
collects data about that.

00:41:38.350 --> 00:41:41.290
So maybe, during your loading
screen, you run a bunch of

00:41:41.290 --> 00:41:44.410
tests, get a feeling about what
the local system is, and

00:41:44.410 --> 00:41:47.560
then suggest settings or send
that data back to your service

00:41:47.560 --> 00:41:48.660
for analysis.

00:41:48.660 --> 00:41:52.340
Or while the game is running,
you see what the FPS is and

00:41:52.340 --> 00:41:54.980
adjust accordingly or take
data accordingly.

00:41:54.980 --> 00:41:57.100
But you really need to
be proactive about

00:41:57.100 --> 00:41:59.750
collecting this data.

00:41:59.750 --> 00:42:02.570
And that's pretty much it for
dealing with the hardware

00:42:02.570 --> 00:42:04.960
variation you're going to
find in HTML5 games.

00:42:04.960 --> 00:42:08.190
Collect data, communicate, and
make sure, above all, that you

00:42:08.190 --> 00:42:10.185
set your users' expectations
appropriately.

00:42:13.180 --> 00:42:16.110
So up until now, I've been
talking about HTML5

00:42:16.110 --> 00:42:16.920
specifications.

00:42:16.920 --> 00:42:19.700
I've been talking about how to
make JavaScript fast. Those

00:42:19.700 --> 00:42:20.950
things all live within V8.

00:42:20.950 --> 00:42:23.350
So here, we're talking about
things that live in V8.

00:42:23.350 --> 00:42:25.740
Let's talk about what
goes around that.

00:42:25.740 --> 00:42:29.400
So V8 lives in WebKit alongside
CSS and HTML.

00:42:29.400 --> 00:42:33.570
So the same way V8 executes
JavaScript, there's another

00:42:33.570 --> 00:42:37.140
machine for HTML and another
system for CSS.

00:42:37.140 --> 00:42:39.450
All of those things
live side by side.

00:42:39.450 --> 00:42:42.010
When they want to render things,
any one of those

00:42:42.010 --> 00:42:44.480
things can send commands
on this RPC

00:42:44.480 --> 00:42:47.220
buffer to the GPU process.

00:42:47.220 --> 00:42:50.430
All rendering in Chrome is done
in a separate process

00:42:50.430 --> 00:42:53.190
entirely, not just a separate
thread, a separate process.

00:42:53.190 --> 00:42:56.040
And it's done on a separate
process for security reasons.

00:42:56.040 --> 00:42:59.570
And so this structure is very
important to understand

00:42:59.570 --> 00:43:01.670
because you're sharing this
RPC buffer with everything

00:43:01.670 --> 00:43:04.310
else that's trying to
render anything.

00:43:04.310 --> 00:43:07.400
Then from the GPU process, it'll
actually communicate

00:43:07.400 --> 00:43:09.600
with the drivers and the
hardware itself to do the

00:43:09.600 --> 00:43:10.780
actual rendering.

00:43:10.780 --> 00:43:13.130
But there are a couple of
additional pieces of

00:43:13.130 --> 00:43:14.150
complexity here.

00:43:14.150 --> 00:43:17.610
One is that on Windows where
you don't have good OpenGL

00:43:17.610 --> 00:43:20.090
drivers, there's this layer
called ANGLE, Almost Native

00:43:20.090 --> 00:43:21.240
Graphics Layer Engine.

00:43:21.240 --> 00:43:24.930
And that will do a translation
from OpenGL to DirectX.

00:43:24.930 --> 00:43:26.760
And then, there's this other
translation layer called

00:43:26.760 --> 00:43:27.380
SwiftShader.

00:43:27.380 --> 00:43:30.330
So on machines that don't have
good drivers or drivers that

00:43:30.330 --> 00:43:33.660
are good enough for WebGL,
SwiftShader will actually do

00:43:33.660 --> 00:43:34.770
software rasterization.

00:43:34.770 --> 00:43:38.000
So there's all this complexity
from your game on down into

00:43:38.000 --> 00:43:38.950
the actual rendering.

00:43:38.950 --> 00:43:41.200
So let's talk about that.

00:43:41.200 --> 00:43:45.050
So first, let's talk about
the RPC buffer part.

00:43:45.050 --> 00:43:47.830
So if you remember way back
when I was talking about

00:43:47.830 --> 00:43:50.210
WebGL, I mentioned that
certain commands have

00:43:50.210 --> 00:43:52.600
unexpectedly slow performance.

00:43:52.600 --> 00:43:54.730
And those are anything that
starts with "read," anything

00:43:54.730 --> 00:43:57.680
that starts with "get," these
things that require round

00:43:57.680 --> 00:43:59.110
trips to the GPU.

00:43:59.110 --> 00:44:01.540
And now that you understand that
there's an RPC buffer in

00:44:01.540 --> 00:44:03.810
there and rendering is done on a
separate process, I'm hoping

00:44:03.810 --> 00:44:05.850
that you'll have some intuition
for why that is and

00:44:05.850 --> 00:44:07.970
what sorts of command
might be slow.

00:44:07.970 --> 00:44:11.820
So besides that, the other thing
you have to know about

00:44:11.820 --> 00:44:13.750
that buffer is that
it's shared, and

00:44:13.750 --> 00:44:15.210
it's limited in size.

00:44:15.210 --> 00:44:18.520
So there's a specific size
limit on that buffer.

00:44:18.520 --> 00:44:21.970
And all the resources that you
upload to the GPU are going to

00:44:21.970 --> 00:44:22.980
eat up that size.

00:44:22.980 --> 00:44:25.680
And it's total size of
resources, not total of number

00:44:25.680 --> 00:44:26.280
of resources.

00:44:26.280 --> 00:44:27.950
But all your textures, all
your buffers, all your

00:44:27.950 --> 00:44:29.150
commands, they're all
going to go into the

00:44:29.150 --> 00:44:31.890
budget for that buffer.

00:44:31.890 --> 00:44:36.690
And if you go over that buffer
size, then you're going to

00:44:36.690 --> 00:44:39.000
trigger something called a sink
flush, which is slow.

00:44:39.000 --> 00:44:40.350
And it's going to amount
to a stall.

00:44:40.350 --> 00:44:42.350
So that means that you're trying
to send another command

00:44:42.350 --> 00:44:43.430
on that buffer.

00:44:43.430 --> 00:44:44.650
But the buffer is
already full.

00:44:44.650 --> 00:44:46.730
And so the buffer is like,
ah, no room for that.

00:44:46.730 --> 00:44:49.200
So I have to stop and actually
process through the whole

00:44:49.200 --> 00:44:50.910
thing, have to flush everything
out before I can

00:44:50.910 --> 00:44:52.430
process this new command.

00:44:52.430 --> 00:44:56.750
And what that's going to look
like to you is that suddenly,

00:44:56.750 --> 00:44:58.870
one of the commands you're
sending to OpenGL is going to

00:44:58.870 --> 00:45:01.420
look like it takes a really
long time for no reason in

00:45:01.420 --> 00:45:02.170
your profiling view.

00:45:02.170 --> 00:45:04.690
You're like, wow, that command
was always perfectly fine, and

00:45:04.690 --> 00:45:06.430
now, it's taking 40
milliseconds.

00:45:06.430 --> 00:45:08.650
And that's because you spilled
the buffer, and you triggered

00:45:08.650 --> 00:45:10.920
a sink flush.

00:45:10.920 --> 00:45:14.250
So really, the only thing you
can do here is try to amortize

00:45:14.250 --> 00:45:16.100
the cost of uploading
across frames.

00:45:16.100 --> 00:45:17.920
So just try to limit what
you do per frame.

00:45:17.920 --> 00:45:20.750
If you see these big stalls, you
can have an intuition that

00:45:20.750 --> 00:45:23.950
you're probably or might be
spilling that buffer and act

00:45:23.950 --> 00:45:25.410
accordingly.

00:45:25.410 --> 00:45:27.760
One note here is that when I
talked about this with the

00:45:27.760 --> 00:45:30.490
Chrome GPU team, they said yes,
this is true for now.

00:45:30.490 --> 00:45:31.500
This is good information.

00:45:31.500 --> 00:45:33.060
But this is something
that's subject to

00:45:33.060 --> 00:45:34.080
change in the future.

00:45:34.080 --> 00:45:35.900
So keep checking back in
with this assumption.

00:45:35.900 --> 00:45:40.480
Hopefully, this will get better,
that this problem of

00:45:40.480 --> 00:45:42.150
causing sink flushes won't be
a problem in the future.

00:45:42.150 --> 00:45:46.170
But for now, this
is good advice.

00:45:46.170 --> 00:45:49.050
So now, let's talk about the
close to the hardware type

00:45:49.050 --> 00:45:51.240
part of the system.

00:45:51.240 --> 00:45:53.660
So what do you need to
know about drivers?

00:45:53.660 --> 00:45:57.150
Really just that they're
there, and that not all

00:45:57.150 --> 00:45:58.410
drivers are secure.

00:45:58.410 --> 00:46:01.950
Not all drivers are stable
for use with WebGL.

00:46:01.950 --> 00:46:04.770
And that means in order to
keep people's browsing

00:46:04.770 --> 00:46:08.550
experiences secure and stable,
that many or some drivers are

00:46:08.550 --> 00:46:10.180
blacklisted.

00:46:10.180 --> 00:46:12.930
So sometimes, people running
on a computer that is

00:46:12.930 --> 00:46:15.360
perfectly a-- computer and
browser perfectly capable of

00:46:15.360 --> 00:46:19.560
playing your game will not be
able to use WebGL because

00:46:19.560 --> 00:46:21.580
their drivers are blacklisted.

00:46:21.580 --> 00:46:25.520
And unfortunately, the only way
to test whether the local

00:46:25.520 --> 00:46:29.630
machine is capable of running
WebGL is by actually trying to

00:46:29.630 --> 00:46:31.660
create a context and
seeing if it fails.

00:46:31.660 --> 00:46:33.770
So the first thing you do when
you're making a WebGL

00:46:33.770 --> 00:46:35.910
application is make
a WebGL context.

00:46:35.910 --> 00:46:38.560
And you really just have to try
it, see if it works, and

00:46:38.560 --> 00:46:39.880
then handle accordingly.

00:46:39.880 --> 00:46:43.360
There's no more elegant
way than that.

00:46:43.360 --> 00:46:46.590
The other thing I mentioned is
this Almost Native Graphics

00:46:46.590 --> 00:46:50.520
Layer Engine, which in response
to the fact that, in

00:46:50.520 --> 00:46:53.780
general, DirectX rendering works
better on Windows than

00:46:53.780 --> 00:46:57.330
OpenGL rendering, or rather,
OpenGL drivers for Windows

00:46:57.330 --> 00:47:00.880
tend to be somewhat buggy or
unstable, there's this layer

00:47:00.880 --> 00:47:03.850
called ANGLE, which will
translate your OpenGL calls

00:47:03.850 --> 00:47:07.370
into DirectX before rendering
on Windows only.

00:47:07.370 --> 00:47:10.000
Hopefully, you never need
to know about this.

00:47:10.000 --> 00:47:11.220
It's just sort of trivia.

00:47:11.220 --> 00:47:14.870
But it's good for you to know
that it's there just in case.

00:47:14.870 --> 00:47:16.610
And then, finally, we
have SwiftShader.

00:47:16.610 --> 00:47:18.850
Again, this is software
rasterization.

00:47:18.850 --> 00:47:24.060
So if you have a system that's
capable of running your game,

00:47:24.060 --> 00:47:27.030
but for some reason, their
drivers don't work, then you

00:47:27.030 --> 00:47:29.270
might get SwiftShader,
SwiftShader software

00:47:29.270 --> 00:47:30.950
rasterization.

00:47:30.950 --> 00:47:34.130
Now, this is just another case
where you're going to have to

00:47:34.130 --> 00:47:36.660
be really proactive about
judging the performance of the

00:47:36.660 --> 00:47:39.000
local machine, because, of
course, software rasterization

00:47:39.000 --> 00:47:41.550
is going to be nowhere
near as performant as

00:47:41.550 --> 00:47:44.070
hardware-accelerated OpenGL.

00:47:44.070 --> 00:47:46.400
So you need to be really careful
that you're catching

00:47:46.400 --> 00:47:49.290
these cases, and testing the
performance, and degrading

00:47:49.290 --> 00:47:51.700
appropriately, or informing
the user appropriately.

00:47:51.700 --> 00:47:54.770
Again, you never had any
guarantees about software

00:47:54.770 --> 00:47:56.310
rasterization or not.

00:47:56.310 --> 00:47:59.040
It could always have been a
10-year-old graphics card.

00:47:59.040 --> 00:48:01.110
Now, you have software
rasterization in the mix.

00:48:01.110 --> 00:48:05.530
That just hammers home that
point a little bit harder.

00:48:05.530 --> 00:48:08.940
So let's talk about your
rendering loop for your game.

00:48:08.940 --> 00:48:12.800
So old-style JavaScript, the
way you would do periodic

00:48:12.800 --> 00:48:16.020
function calls are with these
two methods, setInterval and

00:48:16.020 --> 00:48:17.140
setTimeout.

00:48:17.140 --> 00:48:19.940
But the problem with those is
that there's no way to tell

00:48:19.940 --> 00:48:20.980
the browser what you're doing.

00:48:20.980 --> 00:48:24.040
And again, much like we were
seeing with the V8 case when

00:48:24.040 --> 00:48:26.130
we were talking about performant
JavaScript,

00:48:26.130 --> 00:48:28.060
performant rendering in general,
being performant in

00:48:28.060 --> 00:48:31.680
general, is about being able
to inform the system what

00:48:31.680 --> 00:48:34.590
you're doing in specific
terms so that it can

00:48:34.590 --> 00:48:36.420
optimize around you.

00:48:36.420 --> 00:48:38.780
SetInterval and setTimeout are
not specific about what

00:48:38.780 --> 00:48:39.170
they're doing.

00:48:39.170 --> 00:48:40.670
They could be doing anything.

00:48:40.670 --> 00:48:42.270
We don't know that this
is an animation.

00:48:42.270 --> 00:48:44.200
So the browser can't do
anything to help you.

00:48:44.200 --> 00:48:46.400
And that's why they're
bad ideas.

00:48:46.400 --> 00:48:50.270
Instead, there's this nice API
in the HTML5 family of APIs

00:48:50.270 --> 00:48:51.820
called RequestAnimationFrame.

00:48:51.820 --> 00:48:56.060
And this is a way to do periodic
rendering in a way

00:48:56.060 --> 00:48:58.890
that tells the browser exactly
what you mean.

00:48:58.890 --> 00:49:02.590
So RequestAnimationFrame will
try to call at 60 hertz, and

00:49:02.590 --> 00:49:07.420
it'll adapts down if you can't
actually call at 60 hertz.

00:49:07.420 --> 00:49:08.530
It'll never call faster
than that.

00:49:08.530 --> 00:49:10.486
But it'll call slower
if it needs to.

00:49:15.260 --> 00:49:18.660
So because the
RequestAnimationFrame callback

00:49:18.660 --> 00:49:21.260
is always going to be scaling
its performance to how long

00:49:21.260 --> 00:49:25.550
your frames are taking, if you
can't run at 60 hertz, then

00:49:25.550 --> 00:49:27.850
your frame rate's going to go
a little jaggy, because it's

00:49:27.850 --> 00:49:32.620
going to be based on how long
one of the recent frames took.

00:49:32.620 --> 00:49:35.010
And so if you don't want your
frame rate to wander, you need

00:49:35.010 --> 00:49:37.430
to clamp it to either
60 or 30.

00:49:37.430 --> 00:49:39.750
If you're trying to clamp your
frame rate to 30, what you do

00:49:39.750 --> 00:49:41.120
is just the simplest
thing possible.

00:49:41.120 --> 00:49:43.570
You're just going to manually
skip frames by making a

00:49:43.570 --> 00:49:45.785
counter that counts up, and you
render on even frames and

00:49:45.785 --> 00:49:48.200
not on odd frames,
or whatever.

00:49:48.200 --> 00:49:52.030
So that's what you want to do
if having a jaggy frame rate

00:49:52.030 --> 00:49:54.250
bothers you.

00:49:54.250 --> 00:49:56.220
And the other thing that
RequestAnimationFrame can do

00:49:56.220 --> 00:50:01.000
for you, because it knows that
you are animating, it can feed

00:50:01.000 --> 00:50:02.870
Chrome's rendering pipeline
with your data at

00:50:02.870 --> 00:50:04.120
a consistent rate.

00:50:04.120 --> 00:50:08.470
And it can adapt the work you do
on the GPU and CPU to make

00:50:08.470 --> 00:50:10.790
sure that you're not just
throwing a bunch of commands

00:50:10.790 --> 00:50:12.740
over the wall that you could
never possibly render on the

00:50:12.740 --> 00:50:15.500
GPU, that you're not totally
swamping everything.

00:50:15.500 --> 00:50:15.880
That's what

00:50:15.880 --> 00:50:17.170
RequestAnimationFrame gives you.

00:50:20.180 --> 00:50:21.630
So this is a typical
game loop.

00:50:21.630 --> 00:50:24.070
You have update, render, swap,
update, render, swap.

00:50:24.070 --> 00:50:26.720
That's pretty normal, you know,
while true, do this.

00:50:26.720 --> 00:50:28.610
That's a game.

00:50:28.610 --> 00:50:29.770
This is the way it
fits into Chrome.

00:50:29.770 --> 00:50:31.410
So you have
RequestAnimationFrame, which

00:50:31.410 --> 00:50:32.710
is your JavaScript code.

00:50:32.710 --> 00:50:36.230
You have composite, which Chrome
takes care of that.

00:50:36.230 --> 00:50:38.160
That's where everything is
smooshed together and rendered

00:50:38.160 --> 00:50:41.110
on the screen, and then, you
have a swap as well.

00:50:41.110 --> 00:50:43.590
So that loop is going on if you
have the main loop of your

00:50:43.590 --> 00:50:45.030
game in there.

00:50:45.030 --> 00:50:47.330
If you didn't have that, the
browser would just go back to

00:50:47.330 --> 00:50:48.810
idle and sit idly.

00:50:48.810 --> 00:50:51.640
User input can also cause a
screen dirty, which causes a

00:50:51.640 --> 00:50:54.190
composite, which causes a swap,
which then either goes

00:50:54.190 --> 00:50:55.570
back to idle or goes
back into your

00:50:55.570 --> 00:50:56.820
RequestAnimationFrame loop.

00:51:02.070 --> 00:51:04.940
So now, let's talk about
the life of a frame.

00:51:04.940 --> 00:51:10.310
So the way frames work in
Chrome is that we have

00:51:10.310 --> 00:51:11.490
RequestAnimationFrame calls.

00:51:11.490 --> 00:51:16.050
So first thing that's done is
that your JavaScript in your

00:51:16.050 --> 00:51:18.660
RequestAnimationFrame
call is executed.

00:51:18.660 --> 00:51:21.470
And during that JavaScript,
it'll kick off a bunch of

00:51:21.470 --> 00:51:23.790
calls that result in commands
on the GPU.

00:51:23.790 --> 00:51:25.920
So you're going to kick off
commands down that RPC buffer

00:51:25.920 --> 00:51:28.420
that are going to go on to this
other rendering process.

00:51:28.420 --> 00:51:31.530
When all your JavaScript is
completed, and all your GPU

00:51:31.530 --> 00:51:34.540
work is completed, you have all
the information you need,

00:51:34.540 --> 00:51:36.950
so you can composite the whole
frame together, and

00:51:36.950 --> 00:51:38.220
you could do a swap.

00:51:38.220 --> 00:51:40.140
So that's the general cycle.

00:51:40.140 --> 00:51:43.860
You do your JavaScript
callback, which kicks

00:51:43.860 --> 00:51:44.870
off your GPU work.

00:51:44.870 --> 00:51:47.040
When all that's done,
you can composite.

00:51:47.040 --> 00:51:48.660
And then you just wait out
the rest of the frame.

00:51:48.660 --> 00:51:55.160
If your frame is under 16
milliseconds, it'll just wait

00:51:55.160 --> 00:51:57.600
until the next call of
RequestAnimationFrame.

00:51:57.600 --> 00:52:01.320
So yes, it just keeps
on like that.

00:52:01.320 --> 00:52:04.180
So in that diagram I showed
you before about how all

00:52:04.180 --> 00:52:06.370
things fit together, one thing
I left out is user input.

00:52:06.370 --> 00:52:10.440
So I want to talk a little
bit about user input now.

00:52:10.440 --> 00:52:14.250
One really important thing you
need to know is that while

00:52:14.250 --> 00:52:19.070
your main JavaScript thread
is busy, input is queued.

00:52:19.070 --> 00:52:21.620
And that can introduce
a lot of input

00:52:21.620 --> 00:52:23.780
latency into your code.

00:52:23.780 --> 00:52:25.920
So let me talk about how
that actually works.

00:52:25.920 --> 00:52:29.550
So here we have a diagram
similar to before, so it's

00:52:29.550 --> 00:52:30.990
showing a series of frames.

00:52:30.990 --> 00:52:33.100
First, you do your
JavaScript work.

00:52:33.100 --> 00:52:35.140
Then you do your GPU work.

00:52:35.140 --> 00:52:37.450
And you just keep doing that.

00:52:37.450 --> 00:52:41.190
If during my JavaScript work
I get a bunch of mouse move

00:52:41.190 --> 00:52:43.600
events, I'm not going to
hear them right away.

00:52:43.600 --> 00:52:46.300
I can't hear them while the
main thread is busy.

00:52:46.300 --> 00:52:48.530
And they came in when the
main thread is busy.

00:52:48.530 --> 00:52:52.140
Once the JavaScript execution
is done, you're eligible to

00:52:52.140 --> 00:52:53.540
hear a mouse event.

00:52:53.540 --> 00:52:54.960
So here, in this case,
I'm going to

00:52:54.960 --> 00:52:57.120
hear this most freshest--

00:52:57.120 --> 00:53:00.170
most recent, freshest
mouse click.

00:53:00.170 --> 00:53:03.330
Then during the next frame,
now I've got a m event.

00:53:03.330 --> 00:53:06.070
Now I'm eligible during the
next frame to process that

00:53:06.070 --> 00:53:07.040
mouse event.

00:53:07.040 --> 00:53:08.830
And then at the very end
of the next frame when

00:53:08.830 --> 00:53:11.550
everything's rendered, the
result of that mouse input can

00:53:11.550 --> 00:53:13.210
get rendered.

00:53:13.210 --> 00:53:15.840
And so you can see, especially
with this queuing delay, where

00:53:15.840 --> 00:53:18.270
if events come in while the main
thread is busy, they just

00:53:18.270 --> 00:53:21.950
get queued up, and you can't
hear them until later, you can

00:53:21.950 --> 00:53:24.420
have a lot of input latency.

00:53:24.420 --> 00:53:27.940
The rule of thumb is that your
input latency is going to be

00:53:27.940 --> 00:53:30.990
approximately twice
your frame length.

00:53:30.990 --> 00:53:34.480
So if these are 16-millisecond
frames, then the maximum input

00:53:34.480 --> 00:53:38.020
latency you can get if you're
unlucky is 32 milliseconds,

00:53:38.020 --> 00:53:39.420
which is a hell of
a lot of latency.

00:53:39.420 --> 00:53:41.470
But that's sort of the system
that you live in.

00:53:41.470 --> 00:53:44.300
So you just have to be ready
to deal with that.

00:53:44.300 --> 00:53:47.240
The other thing you can do to
help yourself is to move work

00:53:47.240 --> 00:53:48.290
off the main thread.

00:53:48.290 --> 00:53:50.530
So moving work to
the GPU is good.

00:53:50.530 --> 00:53:52.750
Moving work to web
workers is good.

00:53:52.750 --> 00:53:55.570
Anything that helps you free up
the main thread to be able

00:53:55.570 --> 00:53:58.960
to receive user input
is good for you.

00:54:01.580 --> 00:54:04.770
So one more thing to talk about
user input is that one

00:54:04.770 --> 00:54:07.210
of the really important things
that RequestAnimationFrame

00:54:07.210 --> 00:54:10.660
does is it allows Chrome
to schedule your work

00:54:10.660 --> 00:54:11.560
accordingly.

00:54:11.560 --> 00:54:14.350
So again, we see the same
simplified version of the

00:54:14.350 --> 00:54:16.440
diagram we've been looking at
where you have your work, and

00:54:16.440 --> 00:54:17.910
then Chrome's work,
and then wait.

00:54:17.910 --> 00:54:19.900
Your work, and then Chrome's
work, and then wait, and so

00:54:19.900 --> 00:54:20.980
on, and so forth.

00:54:20.980 --> 00:54:24.350
This all makes perfect sense,
nice repeating pattern.

00:54:24.350 --> 00:54:27.410
But when you have outside
events, DOM events or timers,

00:54:27.410 --> 00:54:30.220
or things going off that cause
things at unexpected

00:54:30.220 --> 00:54:33.060
intervals, Chrome no longer has
the ability to schedule

00:54:33.060 --> 00:54:33.520
those things.

00:54:33.520 --> 00:54:35.200
They just happened
in on events.

00:54:35.200 --> 00:54:38.560
So in this case, on the slide,
I got this on-click event.

00:54:38.560 --> 00:54:40.470
It required some work.

00:54:40.470 --> 00:54:42.845
That processing all would have
fit in this frame nicely.

00:54:42.845 --> 00:54:45.040
But because Chrome didn't know
about that work, it couldn't

00:54:45.040 --> 00:54:48.200
schedule, it which means that
this frame is actually going

00:54:48.200 --> 00:54:49.110
to be delivered late.

00:54:49.110 --> 00:54:51.480
It's going to wait for that
on-click event to complete.

00:54:51.480 --> 00:54:52.740
It's going to deliver
the frame late.

00:54:52.740 --> 00:54:55.160
And then, the next frame, frame
N+1, is actually going

00:54:55.160 --> 00:54:57.860
to have a shorter time
in which to execute.

00:54:57.860 --> 00:55:03.140
So what this means to you is
essentially never do any work

00:55:03.140 --> 00:55:05.050
outside of
RequestAnimationFrame.

00:55:05.050 --> 00:55:09.210
If you want like a DOM-based hub
over your WebGL game, what

00:55:09.210 --> 00:55:12.060
you really want to be doing is
buffering up all user input

00:55:12.060 --> 00:55:14.300
and then handling those
user inputs in the

00:55:14.300 --> 00:55:15.780
RequestAnimationFrame
callback.

00:55:15.780 --> 00:55:18.030
You don't want to just handle
them whenever they come in.

00:55:18.030 --> 00:55:20.110
Because you have to think about
how Chrome is actually

00:55:20.110 --> 00:55:21.500
scheduling the work.

00:55:21.500 --> 00:55:23.770
You have to give Chrome a chance
to pack that work in

00:55:23.770 --> 00:55:26.060
nicely, which means that you
have to actually do any

00:55:26.060 --> 00:55:28.280
processing you want
to do inside the

00:55:28.280 --> 00:55:29.530
RequestAnimationFrame
callback.

00:55:32.180 --> 00:55:34.460
So just in summary of what we've
learned about living

00:55:34.460 --> 00:55:36.610
inside Chrome, first
of all, throttle

00:55:36.610 --> 00:55:37.800
your upload per frame.

00:55:37.800 --> 00:55:40.290
Watch out for big performance
stalls.

00:55:40.290 --> 00:55:42.460
Those are probably
sink flushes.

00:55:42.460 --> 00:55:44.830
And they mean that you're
uploading too much data at

00:55:44.830 --> 00:55:47.520
once essentially.

00:55:47.520 --> 00:55:50.200
Your game lives inside Chrome,
so you have to respect

00:55:50.200 --> 00:55:53.070
Chrome's natural rendering cycle
and have to be prepared

00:55:53.070 --> 00:55:56.490
to give 2 to 4 milliseconds per
frame to Chrome for all

00:55:56.490 --> 00:55:59.030
the compositing and swapping
and finalizing that Chrome

00:55:59.030 --> 00:55:59.800
needs to do.

00:55:59.800 --> 00:56:01.610
So you don't actually have
16 milliseconds.

00:56:01.610 --> 00:56:02.910
You actually have 12.

00:56:02.910 --> 00:56:05.580
Hopefully, it will come in under
4, but you have to be

00:56:05.580 --> 00:56:08.840
prepared to give
that much away.

00:56:08.840 --> 00:56:10.880
Never handle outside
events directly.

00:56:10.880 --> 00:56:14.010
Never handle user events
directly in events.

00:56:14.010 --> 00:56:17.080
Make sure you queue all the
work you need to do up and

00:56:17.080 --> 00:56:17.950
handle it in RAF.

00:56:17.950 --> 00:56:19.860
All the work you do should
be inside your

00:56:19.860 --> 00:56:22.720
RequestAnimationFrame callback
if you want Chrome to be able

00:56:22.720 --> 00:56:25.910
to schedule it nicely.

00:56:25.910 --> 00:56:28.490
And then, if you're concerned
about input latency, if that's

00:56:28.490 --> 00:56:31.350
a big deal for you, then the
best thing you can do there is

00:56:31.350 --> 00:56:32.970
move work off your
main thread.

00:56:32.970 --> 00:56:35.480
Move it to the GPU, move it
to Web Workers, whatever.

00:56:35.480 --> 00:56:38.970
Just know that the input is
blocked or queued while the

00:56:38.970 --> 00:56:39.820
main thread is busy.

00:56:39.820 --> 00:56:44.340
And that's just going to imply
some input latency for you.

00:56:44.340 --> 00:56:47.225
So in general, all this amounts
to be aware of what

00:56:47.225 --> 00:56:49.430
Chrome is doing and how you
fit inside it and try

00:56:49.430 --> 00:56:50.680
to work with that.

00:56:53.470 --> 00:56:57.120
So we've talked about how to
write fast JavaScript.

00:56:57.120 --> 00:56:59.180
We've talked about how to make
that JavaScript work well

00:56:59.180 --> 00:57:00.270
inside of Chrome.

00:57:00.270 --> 00:57:02.920
And now, just in the short time
I have left, I'm going to

00:57:02.920 --> 00:57:05.860
talk about the developer tools
you need to check how well

00:57:05.860 --> 00:57:08.000
you're doing.

00:57:08.000 --> 00:57:10.370
So first of all, just be aware
that Chrome's got all these

00:57:10.370 --> 00:57:11.280
handy dandy flags.

00:57:11.280 --> 00:57:13.740
So you can type about and then
a number of things different

00:57:13.740 --> 00:57:16.250
into Chrome to get
some cool stats.

00:57:16.250 --> 00:57:18.970
So there's about:flags, which
has a lot of graphics options,

00:57:18.970 --> 00:57:21.860
including an FPS counter,
which I essentially just

00:57:21.860 --> 00:57:23.120
perpetually leave on.

00:57:23.120 --> 00:57:25.380
There's about:memory, which
shows you exactly what's going

00:57:25.380 --> 00:57:26.490
on with memory in Chrome.

00:57:26.490 --> 00:57:28.630
It's a very in-depth
detailed view.

00:57:28.630 --> 00:57:31.910
There's about:gpu, which is
useful for figuring out what

00:57:31.910 --> 00:57:33.590
Chrome thinks your
GPU stats are.

00:57:33.590 --> 00:57:36.410
Or if you're taking bug reports
from external people,

00:57:36.410 --> 00:57:38.060
it's really nice to get
them to dump that data

00:57:38.060 --> 00:57:38.940
and give it to you.

00:57:38.940 --> 00:57:42.000
So these are all tools you
should be aware of.

00:57:42.000 --> 00:57:43.540
Then we have the Chrome
developer tools.

00:57:43.540 --> 00:57:48.560
So the Chrome developer tools
are really, really useful.

00:57:48.560 --> 00:57:51.100
They were designed. or
had been used most

00:57:51.100 --> 00:57:52.850
often on web pages.

00:57:52.850 --> 00:57:54.990
They're really, really
great for web pages.

00:57:54.990 --> 00:57:57.060
They're also good for games,
but they've been optimized

00:57:57.060 --> 00:57:58.000
around that case.

00:57:58.000 --> 00:58:01.290
So for instance, the CPU
profiler only take samples

00:58:01.290 --> 00:58:03.040
every 1 or 2 milliseconds.

00:58:03.040 --> 00:58:06.550
So it's a lot less resolution
than you would want.

00:58:06.550 --> 00:58:07.600
But they're really good
for some things.

00:58:07.600 --> 00:58:10.110
So how you get to the developer
tools, there's a

00:58:10.110 --> 00:58:13.110
wrench icon up in the upper
right hand of Chrome.

00:58:13.110 --> 00:58:15.590
Then you go to the Tools menu,
go to Developer Tools.

00:58:15.590 --> 00:58:18.160
And the things you should be
aware of there are the

00:58:18.160 --> 00:58:21.610
timeline view, which completely
rocks for trying to

00:58:21.610 --> 00:58:23.620
see how your resource
loads are going.

00:58:23.620 --> 00:58:26.220
That's the thing that I find it
most useful for, is seeing

00:58:26.220 --> 00:58:29.420
where resource requests were
made and how long they took.

00:58:29.420 --> 00:58:32.380
There's the CPU profiler,
standard profiler.

00:58:32.380 --> 00:58:34.590
Again, resolution a little
low, but it still can be

00:58:34.590 --> 00:58:36.210
really useful.

00:58:36.210 --> 00:58:38.720
And then there's the heap
profiler, which is a super

00:58:38.720 --> 00:58:41.080
useful in-depth look
at exactly where

00:58:41.080 --> 00:58:42.450
all your memory is.

00:58:42.450 --> 00:58:46.180
So those are the tools that are
most important, I think,

00:58:46.180 --> 00:58:50.200
of the Chrome developer tools
for game developers.

00:58:50.200 --> 00:58:52.050
And then, there's
about:tracing.

00:58:52.050 --> 00:58:55.970
So about:tracing is the heaviest
weight tool you

00:58:55.970 --> 00:58:58.470
should be aware of in Chrome if
you're actually trying to

00:58:58.470 --> 00:58:59.880
debug a game.

00:58:59.880 --> 00:59:02.650
So this view that's on the
slide, pretty confusing the

00:59:02.650 --> 00:59:03.840
first time you look at it.

00:59:03.840 --> 00:59:06.840
Every one of these colored
lines, colored vertical lines,

00:59:06.840 --> 00:59:09.670
represents a function call
that's instrumented.

00:59:09.670 --> 00:59:13.310
And so this actually gives you a
list of all the instrumented

00:59:13.310 --> 00:59:16.110
function calls on every Chrome
process, so for every open

00:59:16.110 --> 00:59:18.740
tab, as well as calls
for the GPU.

00:59:18.740 --> 00:59:20.710
So this is the tool you're going
to look at if you're

00:59:20.710 --> 00:59:22.710
going to want to see how
your CPU work and

00:59:22.710 --> 00:59:24.130
your GPU work relate.

00:59:24.130 --> 00:59:26.410
This is what's going
to be useful.

00:59:26.410 --> 00:59:29.110
If you zoom way in on that view
I just showed you, you

00:59:29.110 --> 00:59:32.060
can see that each one of those
colored boxes, actually, you

00:59:32.060 --> 00:59:33.470
can see a function name in it.

00:59:33.470 --> 00:59:35.490
And that function name
data is really raw.

00:59:35.490 --> 00:59:36.800
Again, it's right out
of the source code.

00:59:36.800 --> 00:59:41.810
So if you don't know what draw
layers means in this

00:59:41.810 --> 00:59:44.460
particular context, then
that's too bad.

00:59:44.460 --> 00:59:47.370
But you can kind of look at the
function names and make

00:59:47.370 --> 00:59:49.240
educated guesses about
what they mean.

00:59:49.240 --> 00:59:52.430
And then the really useful thing
you can do with this is

00:59:52.430 --> 00:59:55.530
that from JavaScript, you
can add console.time and

00:59:55.530 --> 00:59:58.990
console.timeEnd tags with
your own string tag.

00:59:58.990 --> 01:00:01.770
And that will create a colored
box in this view, just like

01:00:01.770 --> 01:00:04.380
all the other function calls
that will manually instrument

01:00:04.380 --> 01:00:05.480
a function call for you.

01:00:05.480 --> 01:00:08.260
And you can see exactly where
your function call happened

01:00:08.260 --> 01:00:09.660
within your frame.

01:00:09.660 --> 01:00:11.730
So this is a tool you
definitely, definitely want to

01:00:11.730 --> 01:00:13.870
be aware of.

01:00:13.870 --> 01:00:16.910
And then finally, I know I
mentioned this in the section

01:00:16.910 --> 01:00:19.270
about JavaScript, but you really
should be checking your

01:00:19.270 --> 01:00:20.320
code with V8 flags.

01:00:20.320 --> 01:00:23.080
Unfortunately, this information
about what

01:00:23.080 --> 01:00:25.310
JavaScript is fast and
slow isn't surfaced

01:00:25.310 --> 01:00:26.920
really well to the user.

01:00:26.920 --> 01:00:28.770
It's all sort of at
the command line.

01:00:28.770 --> 01:00:30.890
But it's very, very important
information.

01:00:30.890 --> 01:00:33.200
And so I also put up
here exactly how to

01:00:33.200 --> 01:00:35.990
run this for a Mac.

01:00:35.990 --> 01:00:38.560
It's not really friendly being
on a slide, but I wanted

01:00:38.560 --> 01:00:41.490
people to have these slides
after the fact as reference to

01:00:41.490 --> 01:00:43.230
be able to refer to it.

01:00:43.230 --> 01:00:45.370
So that's actually a call you
can cut and paste into your

01:00:45.370 --> 01:00:48.270
Mac to make this happen.

01:00:48.270 --> 01:00:50.750
And then finally, there's
WebGL Inspector.

01:00:50.750 --> 01:00:54.360
So WebGL Inspector is an
open-source Chrome extension

01:00:54.360 --> 01:00:57.690
which patterns itself after
PIX or one of these other

01:00:57.690 --> 01:01:00.640
heavyweight graphics debugging
tools that people in the games

01:01:00.640 --> 01:01:02.540
industry especially are
really fond of.

01:01:02.540 --> 01:01:05.400
So if you want to step through
your draw calls or see exactly

01:01:05.400 --> 01:01:07.550
how your textures are bound
something like that, WebGL

01:01:07.550 --> 01:01:10.220
Inspector is going to be very,
very useful to you.

01:01:10.220 --> 01:01:13.130
So you should definitely
check that out.

01:01:13.130 --> 01:01:15.710
And then finally, one more note
before I'm out of time.

01:01:15.710 --> 01:01:18.370
I just want to stress
that we really,

01:01:18.370 --> 01:01:20.030
really, really want feedback.

01:01:20.030 --> 01:01:23.530
It's not at all knowing or
unwelcome to file bugs.

01:01:23.530 --> 01:01:24.860
It's really welcome.

01:01:24.860 --> 01:01:28.240
I really, really look forward to
working with teams that are

01:01:28.240 --> 01:01:29.430
verbose about what they want.

01:01:29.430 --> 01:01:30.750
And they file bugs in Chrome.

01:01:30.750 --> 01:01:33.170
And they sort of squawk a lot
about what's working and

01:01:33.170 --> 01:01:35.090
what's not working.

01:01:35.090 --> 01:01:37.740
So please, please, please,
when you find things that

01:01:37.740 --> 01:01:39.620
don't work in Chrome, or things
you'd like to work

01:01:39.620 --> 01:01:41.140
better, or features
you want, please

01:01:41.140 --> 01:01:42.990
log things into crbug.com.

01:01:42.990 --> 01:01:44.390
That's the Chrome
bug database.

01:01:44.390 --> 01:01:47.740
Or if there are features you
want in WebGL or in any of the

01:01:47.740 --> 01:01:50.840
HTML5 specifications, please go
to those mailing lists and

01:01:50.840 --> 01:01:53.660
talk about what you need and
what your experience is.

01:01:53.660 --> 01:01:55.830
The community is not so large
that you can't make a

01:01:55.830 --> 01:01:56.990
difference.

01:01:56.990 --> 01:01:59.830
Really, the decisions are made
by the people who show up.

01:01:59.830 --> 01:02:02.950
And you are really capable
of influencing what

01:02:02.950 --> 01:02:03.670
actually gets done.

01:02:03.670 --> 01:02:05.690
So please, please, please
email those

01:02:05.690 --> 01:02:07.210
mailing lists, file bugs.

01:02:07.210 --> 01:02:10.710
Everybody really wants
to hear from you.

01:02:10.710 --> 01:02:11.180
All right.

01:02:11.180 --> 01:02:12.050
And that's it.

01:02:12.050 --> 01:02:13.300
Thank you very much.

