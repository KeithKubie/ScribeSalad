WEBVTT
Kind: captions
Language: en

00:00:03.889 --> 00:00:05.660
&gt;&gt;Reto Meier: Good morning, everyone.

00:00:05.660 --> 00:00:10.530
My name is Reto Meier and I'm the tech lead
for the Android Developer Relations Team.

00:00:10.530 --> 00:00:15.960
Today I'm going to be presenting the third
part of my Android protips trilogy, Android

00:00:15.960 --> 00:00:19.910
Protips 3, Making Apps Work Like Magic.

00:00:19.910 --> 00:00:25.329
As always, there will be code, so if you came
to Google I/O just for the Android handouts,

00:00:25.329 --> 00:00:29.060
now will probably be a good time to sit back
and start mentally composing your angry blog

00:00:29.060 --> 00:00:30.060
post.

00:00:30.060 --> 00:00:36.071
[ Laughter ]
&gt;&gt;Reto Meier: So I'm old, but I don't particularly

00:00:36.071 --> 00:00:40.890
look it because in the world of technology
we don't measure age by the simple passing

00:00:40.890 --> 00:00:46.110
of years, but instead by the number of transistors
we can fit on an integrated circuit.

00:00:46.110 --> 00:00:49.170
Let's call this Moore's age.

00:00:49.170 --> 00:00:50.629
So Moore's age is exponential.

00:00:50.629 --> 00:00:53.370
In fact, as we all know it doubles every 22
years.

00:00:53.370 --> 00:00:57.160
So let's look at this on an algorithmic scale.

00:00:57.160 --> 00:01:04.940
Here it's easier to see that my real age is
closer to 131,000 years old.

00:01:04.940 --> 00:01:09.290
That's a lot of time and it's kind of hard
to understand exactly how old that is.

00:01:09.290 --> 00:01:12.390
Measuring time exponentially isn't something
that most of us do.

00:01:12.390 --> 00:01:16.980
So let's have a look at a couple of examples
to put that into perspective.

00:01:16.980 --> 00:01:29.119
It's old enough that I will forever associate
going online with this sound...

00:01:29.119 --> 00:01:38.900
[ Sound effects ]
&gt;&gt;Reto Meier: In fact, it's old enough that

00:01:38.900 --> 00:01:44.110
growing up my dad used to sell and service
these office machines.

00:01:44.110 --> 00:01:48.490
Back then I.B.M. compatible meant these golf
ball print heads which would fit into an I.B.M.

00:01:48.490 --> 00:01:50.210
Selectric typewriter.

00:01:50.210 --> 00:01:56.500
Now, of course, time when measured exponentially
moves very, very quickly, so by the name I

00:01:56.500 --> 00:02:00.350
was in high school typewriters had all but
disappeared and mobile phones had started

00:02:00.350 --> 00:02:01.760
to make their first appearances.

00:02:01.760 --> 00:02:04.460
Now, they were still primitive at that point.

00:02:04.460 --> 00:02:08.130
You couldn't even send and receive text messages
let alone do any of the amazing things we

00:02:08.130 --> 00:02:10.289
do on today's smartphones.

00:02:10.289 --> 00:02:14.420
So it's fair to say that the only people walking
around with real personal communicators, let

00:02:14.420 --> 00:02:19.680
alone tablet computers, were serving aboard
the USS Enterprise.

00:02:19.680 --> 00:02:21.819
So what does that have to do with building
magic apps?

00:02:21.819 --> 00:02:23.680
Well, we need to put this into perspective.

00:02:23.680 --> 00:02:25.959
We need to understand what we're trying to
achieve.

00:02:25.959 --> 00:02:30.840
And so handily one of my favorite science
fiction authors, Arthur C. Clarke, has helped

00:02:30.840 --> 00:02:32.340
define that for us.

00:02:32.340 --> 00:02:38.209
He said that any significantly advanced technology
is indistinguishable from magic.

00:02:38.209 --> 00:02:43.810
So that's what we're trying to aim for, but
there's a problem because we're all engineers,

00:02:43.810 --> 00:02:46.740
so we don't really believe in magic.

00:02:46.740 --> 00:02:51.720
Even back as a teen in the mid '90s messing
around with BNC terminators trying to get

00:02:51.720 --> 00:02:57.800
Doom 2 to play on my local area network, I
didn't think the communicator badges in Star

00:02:57.800 --> 00:03:02.730
Trek were magic, I thought they were kind
of implausible and poorly thought through.

00:03:02.730 --> 00:03:05.390
I mean, did you have to press them to initiate
a call?

00:03:05.390 --> 00:03:08.890
How did they know who Riker was and how to
get in touch with him?

00:03:08.890 --> 00:03:14.489
How did it know whether to make the badge
tingle or to have the ship's voice tell me

00:03:14.489 --> 00:03:16.099
that there was an incoming call?

00:03:16.099 --> 00:03:18.120
They just seemed to magically know how it
worked.

00:03:18.120 --> 00:03:20.150
It didn't seem very realistic to me.

00:03:20.150 --> 00:03:25.870
Well, here's the thing, 20 years later we
have the science fiction that they depicted

00:03:25.870 --> 00:03:29.610
for 300 years in the future in all of our
pockets.

00:03:29.610 --> 00:03:31.890
We have personal communicators.

00:03:31.890 --> 00:03:33.510
We have tablets.

00:03:33.510 --> 00:03:37.590
It turns out this whole idea of predicting
the future to build magical apps based on

00:03:37.590 --> 00:03:39.090
what's out there is really hard.

00:03:39.090 --> 00:03:40.819
I discovered this for myself.

00:03:40.819 --> 00:03:46.269
I mean, five years ago there was no Android
and three years ago I wrote this blog post

00:03:46.269 --> 00:03:51.920
suggesting that it would probably take about
10 years until we started seeing augmented

00:03:51.920 --> 00:03:56.760
reality glasses and the sort of voice and
gesture recognition that you would need to

00:03:56.760 --> 00:03:58.810
power them.

00:03:58.810 --> 00:04:02.489
Now I look into the audience and I see some
Glass explorers already, which tells me I

00:04:02.489 --> 00:04:04.120
was a little off.

00:04:04.120 --> 00:04:06.540
So even 10 years ahead I was hopelessly pessimistic.

00:04:06.540 --> 00:04:10.450
It only took three and we got most of the
way there.

00:04:10.450 --> 00:04:12.030
So it represents a real challenge for us.

00:04:12.030 --> 00:04:17.560
How do we build apps significantly advanced
enough to appear magical when it takes 20

00:04:17.560 --> 00:04:22.830
years for 300 years of technology to come
true when you can't even look 10 years ahead

00:04:22.830 --> 00:04:24.790
and guess what may be unrealistic?

00:04:24.790 --> 00:04:27.810
Well, Arthur C. Clarke helps us out again.

00:04:27.810 --> 00:04:34.380
He tells us to make something seem magic you
need to go past the improbable and to look

00:04:34.380 --> 00:04:37.760
beyond the simple case of, well, what if we
can make this smaller, what if we can make

00:04:37.760 --> 00:04:39.760
this faster?

00:04:39.760 --> 00:04:44.570
As Larry was saying in yesterday's keynote,
develop things that don't exist yet.

00:04:44.570 --> 00:04:47.170
Develop things which people don't think are
even possible.

00:04:47.170 --> 00:04:52.530
Now, you will know that you've been successful
if you show the app you've built to an engineer

00:04:52.530 --> 00:04:57.479
and they say, is that actually doing anything
or is that just a mock?

00:04:57.479 --> 00:05:00.350
[ Laughter ]
&gt;&gt;Reto Meier: That's our aim, that's our goal.

00:05:00.350 --> 00:05:04.540
That's what we should be trying to achieve.

00:05:04.540 --> 00:05:05.790
So how do we do such a thing?

00:05:05.790 --> 00:05:08.750
We know that developing any kind of software
is all about compromise.

00:05:08.750 --> 00:05:13.730
Something which looks great on a design doc,
on a whiteboard, often looks more than a little

00:05:13.730 --> 00:05:17.690
different once we've actually implemented
it.

00:05:17.690 --> 00:05:23.560
So what we need to do is figure out which
of those compromises do we need to do in order

00:05:23.560 --> 00:05:28.390
to ship something and which of these compromises
is going to make our app that little bit less

00:05:28.390 --> 00:05:29.400
magical.

00:05:29.400 --> 00:05:34.630
Now, the easy way is to look at your competitors,
see what's already out there, find out what

00:05:34.630 --> 00:05:37.840
features they've got, what platform features
they're utilizing, what countries they're

00:05:37.840 --> 00:05:42.240
localized for, what devices they've built
an optimal experience for, and use that as

00:05:42.240 --> 00:05:43.240
a guide.

00:05:43.240 --> 00:05:46.310
I mean, you're building this app so it's obviously
going to be better.

00:05:46.310 --> 00:05:49.290
You can use your competitors as an idea what
you should be aiming for.

00:05:49.290 --> 00:05:54.530
Now, the problem is that is there's a term
for this in sports and it's called skating

00:05:54.530 --> 00:05:57.050
to where the puck was.

00:05:57.050 --> 00:06:02.460
And it assumes that while you're busily building
your app, your competitors are standing still.

00:06:02.460 --> 00:06:07.220
And that's far from the truth, because they're
not even moving at the speed they were beforehand.

00:06:07.220 --> 00:06:10.910
The end of last year we asked you guys in
our first Android developer survey what are

00:06:10.910 --> 00:06:14.850
your plans for investment in Android over
the next six months?

00:06:14.850 --> 00:06:19.690
And more than half of you told us you were
planning to increase your investment and a

00:06:19.690 --> 00:06:24.020
significant number said to increase it by
a lot.

00:06:24.020 --> 00:06:28.400
So that means -- well, of course, the follow-on
question to that is what are you planning

00:06:28.400 --> 00:06:29.430
to invest in?

00:06:29.430 --> 00:06:30.910
And we asked that, too.

00:06:30.910 --> 00:06:35.530
You asked you were going to make new apps,
make your existing apps higher quality and

00:06:35.530 --> 00:06:38.100
you were going to build new features.

00:06:38.100 --> 00:06:41.430
So suddenly in the six months you were building
your first version using your competitors

00:06:41.430 --> 00:06:48.050
as a target, you have more competitors with
better apps and more features.

00:06:48.050 --> 00:06:52.580
So in that next six months if you're very
lucky you're just going to be six months behind

00:06:52.580 --> 00:06:55.150
and chances are you will be a lot further
behind.

00:06:55.150 --> 00:07:00.150
Now, you are here trying to learn how to build
magic apps.

00:07:00.150 --> 00:07:04.060
So aiming for the past, aiming where your
competitors already have been, isn't interesting.

00:07:04.060 --> 00:07:08.830
That's not how you create magic, it's not
how you inspire love from your users who have

00:07:08.830 --> 00:07:12.750
never seen anything like this before, which
is why it's so frustrating to see so many

00:07:12.750 --> 00:07:18.560
developers looking at these graphs as though
they have some sort of magic key to future.

00:07:18.560 --> 00:07:23.170
These conveniently hockey-shaped pucks represent
exactly that, the past.

00:07:23.170 --> 00:07:25.000
This is the entire ecosystem.

00:07:25.000 --> 00:07:30.880
So you understand that of the 900 million
devices that have been activated, those which

00:07:30.880 --> 00:07:36.030
are still being used -- this is still useful
to understand your backwards compatibility

00:07:36.030 --> 00:07:40.680
story, but in terms of your future development
and what you're building for, that doesn't

00:07:40.680 --> 00:07:42.660
tell the full story.

00:07:42.660 --> 00:07:46.940
Because if you're sitting around waiting for
Jelly Bean to hit 50% before you start using

00:07:46.940 --> 00:07:51.300
those features and if you're waiting for large
and extra large devices to represent 50% of

00:07:51.300 --> 00:07:57.340
the market, you will be behind because your
competitors are already building those apps.

00:07:57.340 --> 00:08:01.830
So your chances of having something advanced
enough to appear magical turn to zero because

00:08:01.830 --> 00:08:06.040
you already have the apps out there taking
advantage of these new features.

00:08:06.040 --> 00:08:10.630
Because if you focus too much on those little
slices it's really easy to forget that the

00:08:10.630 --> 00:08:13.010
pie keeps getting bigger.

00:08:13.010 --> 00:08:17.890
900 million devices, millions of new devices
activated each day and, of course, that Jelly

00:08:17.890 --> 00:08:24.180
Bean slice and those tablet slices represent
a much larger proportion of the new activations

00:08:24.180 --> 00:08:25.180
everyday.

00:08:25.180 --> 00:08:29.460
So we're still talking about hundreds of thousands
of users with the latest devices and the latest

00:08:29.460 --> 00:08:30.460
platforms.

00:08:30.460 --> 00:08:36.270
And I say this because I want to encourage
you all to create the best possible app for

00:08:36.270 --> 00:08:40.900
every user, especially those on the latest
devices because they are your target audience.

00:08:40.900 --> 00:08:45.010
They're the ones which have just spent hundreds
of dollars on a brand new phone running the

00:08:45.010 --> 00:08:46.750
latest version of Android.

00:08:46.750 --> 00:08:51.560
They're looking to have a magical experience,
something which they can use internally to

00:08:51.560 --> 00:08:55.530
justify this new purchase, something they
can show off to their friends and say, hey,

00:08:55.530 --> 00:08:57.080
check this out, isn't this incredible?

00:08:57.080 --> 00:09:01.680
I didn't even think this could be done.

00:09:01.680 --> 00:09:05.340
So let's start by having a look at some of
the simple things you can do to create a magical

00:09:05.340 --> 00:09:07.620
experience using the latest platform versions.

00:09:07.620 --> 00:09:14.000
And I think one of the most obvious for me
is Android Beam mainly because it's so simple.

00:09:14.000 --> 00:09:15.460
Most of this is boilerplate code.

00:09:15.460 --> 00:09:20.390
Always saying in unresume is if this activity
is in the foreground we want to create a message

00:09:20.390 --> 00:09:22.270
which we can send across Android Beam.

00:09:22.270 --> 00:09:25.560
If we look at create message again it's fairly
straightforward.

00:09:25.560 --> 00:09:30.120
The main thing happening here is we're creating
a payload that's contextualized by the app's

00:09:30.120 --> 00:09:31.510
current location.

00:09:31.510 --> 00:09:36.270
Whatever we're doing, reading book, watching
a movie, playing a game, we want to encapsulate

00:09:36.270 --> 00:09:39.260
this into a payload which we can send to another
device.

00:09:39.260 --> 00:09:42.600
So it can be a URI, it can be a series of
integers.

00:09:42.600 --> 00:09:46.420
It's binary so it can be pretty much anything
you like.

00:09:46.420 --> 00:09:48.770
And on the receiver end it's again pretty
straightforward.

00:09:48.770 --> 00:09:54.500
You add an intent filter to activity saying
I'm interested in receiving Android Beam messages

00:09:54.500 --> 00:09:55.660
so that I can process them.

00:09:55.660 --> 00:10:00.270
And within your activity you're extracting
that payload, figuring out what the context

00:10:00.270 --> 00:10:04.750
is and navigating your app to the right location
so that you can then have that experience

00:10:04.750 --> 00:10:10.510
of being able to send something from one device
to another by a simple lift tap.

00:10:10.510 --> 00:10:15.280
And then some examples, you can obviously
transfer a news article if you're in a news

00:10:15.280 --> 00:10:20.940
app or transfer a maps location in maps or
a restaurant review or maybe a radio station

00:10:20.940 --> 00:10:24.190
or maybe you're playing a game and you would
like to play it multiplayer.

00:10:24.190 --> 00:10:28.610
So suddenly you can just hold the two devices
together, tap them and you've transferred

00:10:28.610 --> 00:10:31.070
straight away into a multiplayer experience.

00:10:31.070 --> 00:10:32.460
And that's pretty magical.

00:10:32.460 --> 00:10:35.570
It may seem old hat to us, but we all have
new devices.

00:10:35.570 --> 00:10:39.330
We all understand this technology, but for
regular people this is the sort of stuff that

00:10:39.330 --> 00:10:41.000
creates magical experiences.

00:10:41.000 --> 00:10:46.570
Once you've initiated a multiplayer game that
way, everything else says kludgy.

00:10:46.570 --> 00:10:49.530
Another example, even easier this time, lock
screen widgets.

00:10:49.530 --> 00:10:53.470
Is there a more valuable piece of screen real
estate on a device than the lock screen?

00:10:53.470 --> 00:10:59.441
Every device with a lock, hopefully most of
them, is going to have your widget when they

00:10:59.441 --> 00:11:02.930
turn on -- every time they take their phone
off standby.

00:11:02.930 --> 00:11:06.530
And because not everyone has done this yet,
you have that much better chance of being

00:11:06.530 --> 00:11:09.840
the widget that they select for their phone.

00:11:09.840 --> 00:11:14.300
And it's a line of XML to say, you know, I've
tried it out, it does work on the lock screen,

00:11:14.300 --> 00:11:15.300
it's worth doing.

00:11:15.300 --> 00:11:18.060
If you've already spent the time building
the home screen widget, this just lets your

00:11:18.060 --> 00:11:21.170
users take advantage of it in a new place.

00:11:21.170 --> 00:11:25.390
And because it's so valuable it's worth writing
a couple of extra lines of code so you can

00:11:25.390 --> 00:11:30.660
specify a different layout specifically for
the lock screen.

00:11:30.660 --> 00:11:34.230
Because if you're the first there, that's
great, but you want to make sure that you're

00:11:34.230 --> 00:11:38.290
kept there so you want to make sure that that
experience on the lock screen is as authentic

00:11:38.290 --> 00:11:43.020
and native as it can feel so the user starts
to think of it as part of their phone and

00:11:43.020 --> 00:11:46.450
that's something that they can never replace
with anyone else's lock screen widget.

00:11:46.450 --> 00:11:51.440
So it's a great example of where being first
isn't necessarily everything, but it's definitely

00:11:51.440 --> 00:11:52.440
something.

00:11:52.440 --> 00:11:55.550
It does give you an advantage.

00:11:55.550 --> 00:11:58.820
So that's a couple of really straightforward
things, but there's more to this idea of making

00:11:58.820 --> 00:12:02.610
magical apps than just using the latest platform
versions.

00:12:02.610 --> 00:12:07.680
As usual I have separated my presentation
into three distinct sections, each with a

00:12:07.680 --> 00:12:12.250
short animation to give you a little bit of
an idea as to what I'm going to talk about.

00:12:12.250 --> 00:12:16.130
Starting with this one.

00:12:16.130 --> 00:12:28.900
[ Video playing ]
[ Sound effects ]

00:12:28.900 --> 00:12:43.550
[ Video concludes ]
&gt;&gt;Reto Meier: So context.

00:12:43.550 --> 00:12:49.290
It turns out context isn't just important,
it's absolutely critical.

00:12:49.290 --> 00:12:53.360
To give -- to really get an understanding
of how important context is and how useful

00:12:53.360 --> 00:12:58.320
it can be when developing our apps and the
opportunity that it represents for us as developers,

00:12:58.320 --> 00:13:00.470
I would like you guys to help me out.

00:13:00.470 --> 00:13:04.090
I would like to start by asking you to take
your phones out of your pockets.

00:13:04.090 --> 00:13:06.250
I assume you put them away.

00:13:06.250 --> 00:13:07.420
And unlock it.

00:13:07.420 --> 00:13:08.529
Thank you.

00:13:08.529 --> 00:13:13.260
Now, hand it over to the person sitting next
to you.

00:13:13.260 --> 00:13:15.830
[ Laughter ]
&gt;&gt;Reto Meier: No, don't do that.

00:13:15.830 --> 00:13:20.850
[ Laughter ]
&gt;&gt;Reto Meier: It's a very bad idea.

00:13:20.850 --> 00:13:23.110
I would never give any of you my unlocked
phone.

00:13:23.110 --> 00:13:27.911
I would rather put my home address up on the
screen and my vacation schedule than give

00:13:27.911 --> 00:13:28.960
any of you my unlocked phone.

00:13:28.960 --> 00:13:31.170
And it's nothing personal, it's not about
you guys.

00:13:31.170 --> 00:13:34.480
I wouldn't give my phone unlocked to friends
and family.

00:13:34.480 --> 00:13:38.240
A bunch of you are sitting next to someone
who did manage to score a free phone at Google

00:13:38.240 --> 00:13:39.840
I/O this year.

00:13:39.840 --> 00:13:44.120
[ Laughter ]
&gt;&gt;Reto Meier: Wait for that to drop.

00:13:44.120 --> 00:13:49.040
The rest of you know exactly why you would
never give your unlocked phone to anyone else.

00:13:49.040 --> 00:13:51.730
It's because your phone knows you.

00:13:51.730 --> 00:13:56.070
It knows the news you read, it knows the books
you read, it knows the music you listen to,

00:13:56.070 --> 00:13:57.070
the movies you watch.

00:13:57.070 --> 00:13:58.300
It knows the games you play.

00:13:58.300 --> 00:14:00.120
It knows who your friends are.

00:14:00.120 --> 00:14:03.240
It knows where you live and what your vacation
schedule is.

00:14:03.240 --> 00:14:08.690
All of that information is encapsulated within
someone's phone and that gives us as developers

00:14:08.690 --> 00:14:14.050
a huge opportunity to be able to leverage
some of that context to create these magical

00:14:14.050 --> 00:14:18.190
experiences where we can transition from building
apps which people use on their phone because

00:14:18.190 --> 00:14:23.910
it's convenient to building apps which are
personalized for every person who uses it.

00:14:23.910 --> 00:14:24.930
And that gives you that tie-in.

00:14:24.930 --> 00:14:29.820
That creates that magic which makes people
want to keep using your phone.

00:14:29.820 --> 00:14:34.130
So what kind of context can we utilize?

00:14:34.130 --> 00:14:39.160
I think probably the most fundamental piece
of context on any mobile device is location.

00:14:39.160 --> 00:14:41.570
And you all know I like to talk about location.

00:14:41.570 --> 00:14:46.290
I talked about location a lot back in 2011
here at I/O and I followed up that with a

00:14:46.290 --> 00:14:50.570
deep dive into location blog post and then,
of course, there's a sample project which,

00:14:50.570 --> 00:14:57.170
of course, contained a couple of dozen classes,
just small snippets of code which were backwards

00:14:57.170 --> 00:14:58.170
compatible.

00:14:58.170 --> 00:14:59.220
They weren't too complex.

00:14:59.220 --> 00:15:02.150
I mean, there was a lot of it.

00:15:02.150 --> 00:15:05.350
The location team, they had a look at this
and they said, you know, I think we can do

00:15:05.350 --> 00:15:06.430
better than this.

00:15:06.430 --> 00:15:11.620
In fact, I think we can make it both more
efficient and easier to use, which is why

00:15:11.620 --> 00:15:15.990
it's so fantastic that here at Google I/O
this year they've released a new location-based

00:15:15.990 --> 00:15:19.000
services as part of Google Play Services.

00:15:19.000 --> 00:15:22.190
And it's actually really easy to use.

00:15:22.190 --> 00:15:27.011
Like most Google Play Services, you simply
create the new client, call connect so that

00:15:27.011 --> 00:15:31.050
your application can bind to this location
service and then you can start using those

00:15:31.050 --> 00:15:33.630
updates in much the same ways that you would
have in the past.

00:15:33.630 --> 00:15:37.230
And if you look at that implementation it
actually looks pretty naive.

00:15:37.230 --> 00:15:41.700
This is the sort of code snippet you would
have seen in previous years around location

00:15:41.700 --> 00:15:43.800
where we just assume that everything works.

00:15:43.800 --> 00:15:47.060
You don't need to worry about whether providers
are enabled or not.

00:15:47.060 --> 00:15:50.820
And we can't fit more than this on one slide
anyway.

00:15:50.820 --> 00:15:54.860
But the beauty of the Fused Location Provider
is that's actually true.

00:15:54.860 --> 00:15:56.950
It does all of that for you.

00:15:56.950 --> 00:16:01.970
So rather than having to worry about which
particular provider is enabled, which provider

00:16:01.970 --> 00:16:04.960
is giving you the best results at the current
time.

00:16:04.960 --> 00:16:10.070
Because maybe it's GPS but then if I'm inside,
maybe it's Wi-Fi, fuse provider does all of

00:16:10.070 --> 00:16:11.070
that work for you.

00:16:11.070 --> 00:16:15.770
You don't have to have receivers looking to
see if a different provider is enabled.

00:16:15.770 --> 00:16:20.370
You don't even have to specify a provider
or even criteria for us to figure out a provider

00:16:20.370 --> 00:16:21.370
for you.

00:16:21.370 --> 00:16:26.510
You just say I want to get updates within
this time frame, and importantly, you tell

00:16:26.510 --> 00:16:29.820
us what's more important, within the context
of your application.

00:16:29.820 --> 00:16:34.451
If you want to make sure you get as accurate
results as possible or do you want to make

00:16:34.451 --> 00:16:38.760
sure the battery lasts as long as possible
or do you just want to trust us and the Fused

00:16:38.760 --> 00:16:42.560
Location Provider to figure that out for you.

00:16:42.560 --> 00:16:43.560
It's as simple as that.

00:16:43.560 --> 00:16:46.080
And then the Fused Location Provider does
all of the work, and because it's part of

00:16:46.080 --> 00:16:52.040
Google Play services, as we improve and iterate
on those algorithms, we will continue to be

00:16:52.040 --> 00:16:56.140
able to improve the efficiency of your apps
which use this code to improve.

00:16:56.140 --> 00:16:57.670
So you don't have to worry about any of this.

00:16:57.670 --> 00:16:59.520
It will just magically get better and better.

00:16:59.520 --> 00:17:03.450
All you need to do is tell us what the priority
is from your app.

00:17:03.450 --> 00:17:08.270
So I kind of think of this as working the
way it always should have worked.

00:17:08.270 --> 00:17:13.230
Speaking of which, we now have geofencing
which replaces the much maligned, and rightfully

00:17:13.230 --> 00:17:16.189
so, proximity list which didn't work.

00:17:16.189 --> 00:17:18.310
Geofencing does what they always should have.

00:17:18.310 --> 00:17:23.550
You specify a particular location, a boundary
around that location, and then you tell us

00:17:23.550 --> 00:17:27.010
whether you're interested in someone coming
in or going out of that boundary.

00:17:27.010 --> 00:17:31.690
And then we send you a pending intent to tell
you whenever that happens.

00:17:31.690 --> 00:17:36.510
So suddenly you're able to use location context
without having to follow the user around all

00:17:36.510 --> 00:17:38.290
the time.

00:17:38.290 --> 00:17:40.830
Again, built on top of the Fused Location
Provider.

00:17:40.830 --> 00:17:41.980
So do all of that work.

00:17:41.980 --> 00:17:46.670
We know all the geofences sent by all of the
apps, and we're able to intelligently select

00:17:46.670 --> 00:17:50.440
whether we should use GPS or you should use
Wi-Fi or some combination or something else

00:17:50.440 --> 00:17:55.230
entirely based on the proximity from those
boundaries.

00:17:55.230 --> 00:17:56.370
So it's better for efficiency.

00:17:56.370 --> 00:17:58.010
It makes your app simpler.

00:17:58.010 --> 00:18:01.550
It's better for privacy because you're not
having to follow users around.

00:18:01.550 --> 00:18:05.890
You can still utilize all that context based
on specific locations but focus them on just

00:18:05.890 --> 00:18:07.930
the areas you care about.

00:18:07.930 --> 00:18:10.760
It's about using context but in a slightly
different way.

00:18:10.760 --> 00:18:13.970
It's about using the context of your app to
know when it's important that you know where

00:18:13.970 --> 00:18:15.110
someone is.

00:18:15.110 --> 00:18:20.420
They also had another API that was again talked
about in the keynote yesterday, activity recognition.

00:18:20.420 --> 00:18:25.060
I think this is really exciting because it
represents something entirely new and it's

00:18:25.060 --> 00:18:30.211
an opportunity for us not just to know where
someone is but what they're doing, what activity

00:18:30.211 --> 00:18:34.570
they're engaged in, if they're standing still,
if they're cycling, if they're driving.

00:18:34.570 --> 00:18:39.460
And we can suddenly build apps which either
use that information directly, so a sports

00:18:39.460 --> 00:18:42.760
or a fitness app which can keep track of when
you're walking, when you're running, when

00:18:42.760 --> 00:18:48.670
you're cycling, or we can use it to make our
existing apps a little bit cleverer.

00:18:48.670 --> 00:18:54.710
So in this example we're looking at the results
and we're saying, okay, this app is looking

00:18:54.710 --> 00:18:58.010
for points of interest based on my current
location.

00:18:58.010 --> 00:19:02.110
So if I'm standing still, I can probably disable
all of those updates.

00:19:02.110 --> 00:19:04.960
I mean, the buildings aren't moving, I'm not
moving.

00:19:04.960 --> 00:19:06.940
So the updates are probably fine as they are.

00:19:06.940 --> 00:19:11.610
But if I'm driving, better still if I'm a
passenger in a car where someone else is driving,

00:19:11.610 --> 00:19:16.290
I might want to get much faster updates so
I can recommend where we're going to go and

00:19:16.290 --> 00:19:17.290
eat.

00:19:17.290 --> 00:19:20.700
So you basically want to crank everything
up to 11, make it as fast as possible.

00:19:20.700 --> 00:19:25.060
Now we can sort of imply a bunch of this and
add it into the Fused Location Provider ourselves

00:19:25.060 --> 00:19:31.410
but it's actually very contextually based
because in this example, which is almost identical,

00:19:31.410 --> 00:19:35.870
but here it's an app which is telling us up-to-date
sports scores.

00:19:35.870 --> 00:19:40.740
Now suddenly if I'm standing still, I want
to get frequent updates because I'm standing

00:19:40.740 --> 00:19:42.770
there looking at the current sports game.

00:19:42.770 --> 00:19:48.910
But if I'm cycling, the phone is in my pocket,
we can probably disable them completely.

00:19:48.910 --> 00:19:53.830
So it's really about figuring out how your
app works, figuring out that context and being

00:19:53.830 --> 00:19:58.900
able to use the results we have here based
on what the users are actually doing to try

00:19:58.900 --> 00:20:03.420
to create something more efficient, more magical,
just a better app.

00:20:03.420 --> 00:20:05.390
And really, that's what this comes down to.

00:20:05.390 --> 00:20:09.250
It's trying to figure out how to utilize this
additional contextual information either to

00:20:09.250 --> 00:20:18.740
create a new user experience or just to make
your apps that much more efficient.

00:20:18.740 --> 00:20:21.040
So we're talking Google Play services.

00:20:21.040 --> 00:20:22.660
We're talking about context.

00:20:22.660 --> 00:20:26.490
It would be remiss of me not to at least mention
Google+.

00:20:26.490 --> 00:20:30.700
Now, here we have a bunch of opportunities.

00:20:30.700 --> 00:20:33.240
First and foremost, we have login.

00:20:33.240 --> 00:20:37.740
So you're able to get rid of all that user
name password jumping around, having someone

00:20:37.740 --> 00:20:41.809
create a new account for your service and
two years later when they get a new phone

00:20:41.809 --> 00:20:44.450
they can't remember having created it in the
first place, can't remember the user name

00:20:44.450 --> 00:20:47.920
or the password, having to start it all over
again.

00:20:47.920 --> 00:20:52.400
Here we're able to take advantage of the fact
that most Android users are going to have

00:20:52.400 --> 00:20:55.950
Google+ installed on their device and they're
going to be signed in to it.

00:20:55.950 --> 00:20:57.020
So you have this context.

00:20:57.020 --> 00:20:58.470
You already know this.

00:20:58.470 --> 00:21:02.200
And with cross-device single sign-on, you
only need to do this once.

00:21:02.200 --> 00:21:07.610
So they click sign in, give them the option
to accept and that's it.

00:21:07.610 --> 00:21:10.610
Suddenly they're logged into your app on every
device that they own, and always will be.

00:21:10.610 --> 00:21:12.490
And that's a tremendous opportunity.

00:21:12.490 --> 00:21:15.580
It's something which feels magical because
the user knows that it's their device.

00:21:15.580 --> 00:21:18.270
They're not going to give to anyone.

00:21:18.270 --> 00:21:21.800
So being able to say you already know who
I am and I'm logged in, makes it that much

00:21:21.800 --> 00:21:24.070
easier, more seamless.

00:21:24.070 --> 00:21:28.660
And once you've logged in you suddenly have
even more opportunity.

00:21:28.660 --> 00:21:32.090
Suddenly you know what the person looks like
and you know their name so you can start addressing

00:21:32.090 --> 00:21:36.750
them personally, you can start using the avatar
they have selected to represent them.

00:21:36.750 --> 00:21:38.860
And you also get to know who their friends
are.

00:21:38.860 --> 00:21:42.870
Now, this is a tremendous opportunity because
suddenly you're able to contextualize the

00:21:42.870 --> 00:21:49.240
content you're sharing within the application
based on what their friends are doing.

00:21:49.240 --> 00:21:52.480
So restaurants that their friends are eating
at, books that they're reading, music that

00:21:52.480 --> 00:21:54.820
they're listening to, games that they're playing.

00:21:54.820 --> 00:21:58.660
You can even go a step further and say if
all of your friends are reading a particular

00:21:58.660 --> 00:22:01.220
newsletter, maybe you should be alerted.

00:22:01.220 --> 00:22:03.980
Maybe that's a trigger to create a notification.

00:22:03.980 --> 00:22:07.960
Or maybe you don't want to have so much editorial
modification based on this kind of context

00:22:07.960 --> 00:22:10.730
within your app so you use it the other way.

00:22:10.730 --> 00:22:13.110
You use it to create a more efficient app.

00:22:13.110 --> 00:22:17.520
You say, well, we're not going to suggest
that they read it, but we know there's a very

00:22:17.520 --> 00:22:21.929
good chance they will anyway, so we're going
to prefetch the articles which most of their

00:22:21.929 --> 00:22:26.440
friends have read so that we're that much
more efficient.

00:22:26.440 --> 00:22:33.059
Now, there is a risk when we start building
all of this context into our applications,

00:22:33.059 --> 00:22:37.910
and that risk is we're going to fall into
the Uncanny App Valley.

00:22:37.910 --> 00:22:43.559
Now, generally speaking the more context you
add to your app, the more awesome it is; right?

00:22:43.559 --> 00:22:45.350
So what happens here?

00:22:45.350 --> 00:22:50.680
Well, this is the point of inflection where
if you're not careful, your app can go from

00:22:50.680 --> 00:22:56.730
being intuitive and clever and knowing more
than you even thought it could into being

00:22:56.730 --> 00:23:01.990
creepy and stalkerish and a little uncomfortable.

00:23:01.990 --> 00:23:05.380
You want to make sure you're creating experiences
where people are thinking, "Wow, I did not

00:23:05.380 --> 00:23:11.570
know you could do that!" rather than, "wow,
I did not know you could do that...."

00:23:11.570 --> 00:23:15.730
It's a subtle distinction but it's important,
and it's all about making sure your users

00:23:15.730 --> 00:23:18.290
are only ever pleasantly surprised.

00:23:18.290 --> 00:23:20.550
They're never unpleasantly surprised.

00:23:20.550 --> 00:23:24.840
And that means you need to let them know what
you're doing, why you're doing it and, where

00:23:24.840 --> 00:23:26.210
appropriate, let them opt out of it.

00:23:26.210 --> 00:23:31.450
I'm not saying you need to nag a user every
time you want to use another piece of context.

00:23:31.450 --> 00:23:32.820
That's not appropriate either.

00:23:32.820 --> 00:23:36.670
But it should be obvious from everything your
app does and says about itself, starting with

00:23:36.670 --> 00:23:38.640
the description in Google Play.

00:23:38.640 --> 00:23:43.600
For something like Google Now, for example,
it uses every piece of context it can find

00:23:43.600 --> 00:23:47.419
to try to create these magical experiences,
and it's wonderful and we love it.

00:23:47.419 --> 00:23:48.780
But we knew that going in.

00:23:48.780 --> 00:23:52.179
From the description in Google Play to the
first time we open the app, it makes it very

00:23:52.179 --> 00:23:53.790
clear what's happening.

00:23:53.790 --> 00:23:58.750
Now, as counter example, if you downloaded
a replacement keyboard and it started popping

00:23:58.750 --> 00:24:03.110
up notifications telling you about sporting
teams you liked because you searched for them,

00:24:03.110 --> 00:24:04.559
you would be a little creeped out.

00:24:04.559 --> 00:24:06.630
Now, I'm not saying that's a bad idea.

00:24:06.630 --> 00:24:10.730
I'm just saying if you do build such a keyboard,
you need to make sure your users understand

00:24:10.730 --> 00:24:12.440
exactly what's happening with their data.

00:24:12.440 --> 00:24:16.340
And that's particularly important when you're
using anything potentially sensitive.

00:24:16.340 --> 00:24:20.100
So location information, contact information,
all of that.

00:24:20.100 --> 00:24:25.210
They are all protected behind permissions,
so that gives you a really good start, but

00:24:25.210 --> 00:24:29.760
it's important that you're using that information
which users have granted you access to use

00:24:29.760 --> 00:24:31.580
in a responsible way.

00:24:31.580 --> 00:24:34.929
So you're not transmitting their location
information unless that's something that's

00:24:34.929 --> 00:24:37.130
fundamental to the way your app works.

00:24:37.130 --> 00:24:42.760
And if it is, say you have an app which will
tell you where you've left your phone, you

00:24:42.760 --> 00:24:45.010
should only be keeping as much data as you
need.

00:24:45.010 --> 00:24:47.370
The last couple of places, not the last six
months.

00:24:47.370 --> 00:24:50.660
And if they uninstall the app, everything
should get deleted.

00:24:50.660 --> 00:24:53.750
Everything on the device, everything on your
servers.

00:24:53.750 --> 00:24:57.300
Uninstalling is basically their way of opting
out, and so you need to remove all of that

00:24:57.300 --> 00:24:58.300
data.

00:24:58.300 --> 00:25:00.050
And the same goes for things like contacts.

00:25:00.050 --> 00:25:03.870
It's not uncommon for apps to want to be able
to look at your contact list and see whether

00:25:03.870 --> 00:25:07.350
other people using the same services are their
friends.

00:25:07.350 --> 00:25:11.000
But you never need to actually transmit any
of that contact information.

00:25:11.000 --> 00:25:12.290
You can just hash it.

00:25:12.290 --> 00:25:13.650
You don't actually try to email anyone.

00:25:13.650 --> 00:25:17.770
You're just looking for collisions and that's
a perfect example of where you should be obfuscating

00:25:17.770 --> 00:25:18.770
that data.

00:25:18.770 --> 00:25:24.260
Making it useful for what you're doing but
not useful for anything else.

00:25:24.260 --> 00:25:28.870
So if we're trying to make sure that we create
no experiences which people find disconcerting,

00:25:28.870 --> 00:25:29.870
we want to go the other way.

00:25:29.870 --> 00:25:32.570
We want to create magical experiences which
delight people.

00:25:32.570 --> 00:25:35.000
Which segues neatly into my next video.

00:25:35.000 --> 00:25:50.130
[ Video playing ]
[ Applause ]

00:25:50.130 --> 00:26:20.040
&gt;&gt;Reto Meier: Thank you.

00:26:20.040 --> 00:26:21.190
So we want to delight users.

00:26:21.190 --> 00:26:25.340
We want to create experiences that are memorable
for the right reasons.

00:26:25.340 --> 00:26:28.470
Because if we do this right, we can create
experiences which move beyond people just

00:26:28.470 --> 00:26:32.980
using your app and being happy about it, but
loving your app and wanting to use it specifically

00:26:32.980 --> 00:26:36.380
so they can experience the joy of using your
app.

00:26:36.380 --> 00:26:37.860
And this is important.

00:26:37.860 --> 00:26:42.799
In fact, Rob Foster of Mysterious Trousers
recently wrote that introducing visceral elements

00:26:42.799 --> 00:26:46.610
into an app will make it speak to the subconscious.

00:26:46.610 --> 00:26:51.070
And that's a concept that really resonated
with me because life is about more than just

00:26:51.070 --> 00:26:52.070
the things we do.

00:26:52.070 --> 00:26:54.890
It's about the experiences we have.

00:26:54.890 --> 00:27:00.320
When we sit down for a meal, it's not just
about consuming calories and taking in nutrients.

00:27:00.320 --> 00:27:02.410
It's about that experience.

00:27:02.410 --> 00:27:08.419
The smell of the food cooking, the texture
of the food, the smell, the taste.

00:27:08.419 --> 00:27:12.050
Everything about it is something which adds
up to much, much more than just the simple

00:27:12.050 --> 00:27:13.050
process of eating.

00:27:13.050 --> 00:27:14.980
It's why we eat even when we don't have to.

00:27:14.980 --> 00:27:19.740
It's why we spend a lot of money to go to
nice restaurants, to have that experience.

00:27:19.740 --> 00:27:23.309
And that's the sort of thing we want to be
creating in our app, something visceral, something

00:27:23.309 --> 00:27:28.760
emotional, which makes people want to use
our app, whether they have to or not.

00:27:28.760 --> 00:27:33.700
I mean, we've all sat around, we're all developers,
we've all wondered why is it that someone

00:27:33.700 --> 00:27:40.250
is willing to spend five bucks multiple times
a day on a cup of flavored hot water, but

00:27:40.250 --> 00:27:43.920
while they're sitting in Starbucks drive through
waiting for it to arrive they'll go on their

00:27:43.920 --> 00:27:48.600
phone and write an angry all-cap screed calling
you a thief and a liar because you charged

00:27:48.600 --> 00:27:53.070
a buck 49 for your app instead of 99 cents.

00:27:53.070 --> 00:27:57.950
Part of the reason for that is a cup of coffee
gives you a lot of things for free which are

00:27:57.950 --> 00:28:00.010
much, much harder to build into an app.

00:28:00.010 --> 00:28:05.290
It's the warmth of the mug, the smell of freshly
brewed coffee, the first taste of coffee in

00:28:05.290 --> 00:28:07.980
the morning.

00:28:07.980 --> 00:28:12.760
It's very hard to emulate those things within
an app, but it's that which gives you the

00:28:12.760 --> 00:28:13.760
value.

00:28:13.760 --> 00:28:18.039
That's what people are paying for, not just
the cup of water but for the experience around

00:28:18.039 --> 00:28:19.039
it.

00:28:19.039 --> 00:28:22.100
Now, that represents a real challenge for
us, because if that's what we're trying to

00:28:22.100 --> 00:28:23.930
achieve, how do we do that?

00:28:23.930 --> 00:28:31.059
I mean, there are companies like scent air
which actually creates Al aroma delivery systems

00:28:31.059 --> 00:28:36.160
so they can make the street at the front of
your ice cream shot smell like freshly baked

00:28:36.160 --> 00:28:41.990
sugar cones or freshly brewed coffee whether
they have that stuff in the store or not.

00:28:41.990 --> 00:28:47.120
You can have the scent of shattered reality,
which is, I think, lavender.

00:28:47.120 --> 00:28:51.070
[ Laughter ]
&gt;&gt;Reto Meier: But until Google nose has a

00:28:51.070 --> 00:28:52.390
public API --
[ Laughter ]

00:28:52.390 --> 00:28:58.890
&gt;&gt;Reto Meier: -- we're going to need to be
a little bit more creative.

00:28:58.890 --> 00:29:00.799
So we have five senses.

00:29:00.799 --> 00:29:07.200
I think we can clearly say that taste is out,
smell for now is probably out as well.

00:29:07.200 --> 00:29:09.120
See what happens next year.

00:29:09.120 --> 00:29:11.230
So we can focus on the senses that we have.

00:29:11.230 --> 00:29:20.360
So that means focusing sharply on sight, sound,
and of course everyone's favorite, touch.

00:29:20.360 --> 00:29:21.360
So how do we do this?

00:29:21.360 --> 00:29:23.919
And what are we really trying to achieve?

00:29:23.919 --> 00:29:28.460
Now, because we only have the three senses
to work with, we have to work doubly hard

00:29:28.460 --> 00:29:32.789
to try and generate that emotional response
by utilizing the senses that we have available.

00:29:32.789 --> 00:29:35.080
And that means taking risks.

00:29:35.080 --> 00:29:39.550
Because if we can do this, if we can make
users feel an emotional attachment to our

00:29:39.550 --> 00:29:44.130
app in the same way that they do their first
cup of coffee in the morning, then you don't

00:29:44.130 --> 00:29:45.480
just have passionate users.

00:29:45.480 --> 00:29:48.220
You have Kool-Aid drinking fan boys and fan
girls.

00:29:48.220 --> 00:29:50.160
You have people who will go to the forums.

00:29:50.160 --> 00:29:51.530
They will blog about it.

00:29:51.530 --> 00:29:54.600
They will talk about your app as the best
thing in the world, as the reason to buy a

00:29:54.600 --> 00:29:59.799
particular phone just so other people can
have this incredible experience.

00:29:59.799 --> 00:30:02.820
So this may be a little controversial but
I'm going to suggest that you need to break

00:30:02.820 --> 00:30:04.570
the rules.

00:30:04.570 --> 00:30:07.980
Playing it safe is not the way you make people
fall in love.

00:30:07.980 --> 00:30:13.070
But before you break the rules, like any great
artist you need to understand them fully.

00:30:13.070 --> 00:30:18.480
It's only by understanding the rules, understanding
philosophy behind it, the spirit, the vision

00:30:18.480 --> 00:30:22.050
that created them that you can move beyond
them.

00:30:22.050 --> 00:30:27.299
Now, the good news is that all of that vision
and spirit is encapsulated very neatly at

00:30:27.299 --> 00:30:29.270
developer.android.com/design.

00:30:29.270 --> 00:30:33.230
And that's where the Android team talk about
not just the practicalities, not just how

00:30:33.230 --> 00:30:37.690
things should look, how things should behave,
but the vision that underlies all of that

00:30:37.690 --> 00:30:39.100
thinking.

00:30:39.100 --> 00:30:40.130
And that's your baseline.

00:30:40.130 --> 00:30:44.840
That's where you should be looking to say
I want to create my own magical experience.

00:30:44.840 --> 00:30:49.799
And I could spend the rest of this session
telling you how to create a killer UI element,

00:30:49.799 --> 00:30:55.160
something your users would fall in love with
and you associate just with your app.

00:30:55.160 --> 00:30:59.370
But then all of you would have that UI element
and it would be a lot less useful.

00:30:59.370 --> 00:31:03.799
So you need to do that hard work yourselves
and I can get away with just explaining more

00:31:03.799 --> 00:31:05.490
of the rules.

00:31:05.490 --> 00:31:10.180
Now, I'm not a designer, so I'm not going
to go through all of the visual design elements

00:31:10.180 --> 00:31:11.630
and the right way to do you will after those
things.

00:31:11.630 --> 00:31:16.040
We have a team of designers which have come
to Moscone this week to tell you all about

00:31:16.040 --> 00:31:20.850
it and all day today, starting in room 5 with
the cognitive science and design with Alex

00:31:20.850 --> 00:31:21.850
Freiberg.

00:31:21.850 --> 00:31:23.760
Great sessions.

00:31:23.760 --> 00:31:28.190
Everything from understanding the science
behind how to design things to practical implementation

00:31:28.190 --> 00:31:31.170
tips so you can take that vision and turn
it into reality.

00:31:31.170 --> 00:31:34.470
So if you thought design wasn't important,
you're wrong.

00:31:34.470 --> 00:31:37.970
This is your opportunity to rectify that and
find out exactly how you can make sure that

00:31:37.970 --> 00:31:43.950
design is a central element to all of your
app choices.

00:31:43.950 --> 00:31:44.950
So what else have we got?

00:31:44.950 --> 00:31:45.950
We've got sight.

00:31:45.950 --> 00:31:47.250
Now, sound is a little bit more subtle.

00:31:47.250 --> 00:31:50.720
How can we create an engaging app using sound?

00:31:50.720 --> 00:31:52.740
Isn't that a little bit more specific?

00:31:52.740 --> 00:31:56.220
Well, it can be but it doesn't have to be.

00:31:56.220 --> 00:31:58.070
Let's take text to speech.

00:31:58.070 --> 00:32:00.679
Again, this is pretty easy to set up.

00:32:00.679 --> 00:32:05.520
You need to check to see whether or not text
to speech is installed on that device.

00:32:05.520 --> 00:32:10.370
If it isn't, then you need to start a new
activity to install it, and if it is, you're

00:32:10.370 --> 00:32:11.370
ready to go.

00:32:11.370 --> 00:32:14.630
So it's a little bit of code which gets run
once.

00:32:14.630 --> 00:32:18.690
And then to say something, it's a line of
code.

00:32:18.690 --> 00:32:24.270
Now, this may seem like a small thing, but
it's actually kind of a big deal.

00:32:24.270 --> 00:32:28.550
Now, whether it's an app like Google navigation,
which you simply can't use without text to

00:32:28.550 --> 00:32:33.610
speech, or something like Google Now that
creates that experience where you ask it a

00:32:33.610 --> 00:32:35.720
question and it tells you the answer.

00:32:35.720 --> 00:32:37.460
Now, you could just read it off the screen.

00:32:37.460 --> 00:32:42.330
There's no particular reason why it should
read it out, but it does, and it speaks to

00:32:42.330 --> 00:32:43.330
us emotionally.

00:32:43.330 --> 00:32:47.910
We're interacting with it as we would a real
thing or a real person.

00:32:47.910 --> 00:32:49.240
Because that's what we prefer to do.

00:32:49.240 --> 00:32:53.630
We would prefer to interact with real objects
and real people than machines or representations

00:32:53.630 --> 00:32:55.150
of things.

00:32:55.150 --> 00:32:58.220
And so that's our challenge, and so using
something like text to speech is that opportunity.

00:32:58.220 --> 00:33:03.610
And it adds functionality, functionality which
because it's sensory based is going to get

00:33:03.610 --> 00:33:05.600
people addicted to your app.

00:33:05.600 --> 00:33:11.380
Say I have two news apps and they both look
about the same and they have the same quality

00:33:11.380 --> 00:33:12.380
of news.

00:33:12.380 --> 00:33:14.799
In fact, they're getting it from the same
source.

00:33:14.799 --> 00:33:17.809
One of them maybe looks a little nicer but
the other one has the ability to read out

00:33:17.809 --> 00:33:21.450
my headlines to me as I'm driving to work
in the morning.

00:33:21.450 --> 00:33:25.470
Suddenly, I can use only one of those apps.

00:33:25.470 --> 00:33:30.280
So by adding something like text to speech,
you add a whole set of new users who previously

00:33:30.280 --> 00:33:33.690
wouldn't have had a reason to pick your app,
but now, suddenly, it's the thing which makes

00:33:33.690 --> 00:33:38.690
your app different, which makes it stand out,
which makes it an app they have to use.

00:33:38.690 --> 00:33:42.500
And they love you for it, because they feel
like you've built that in just for them.

00:33:42.500 --> 00:33:46.470
You've built this so I can use the app in
my particular circumstances.

00:33:46.470 --> 00:33:50.780
That's the way you create these magical experiences,
by developing for everyone and taking advantage

00:33:50.780 --> 00:33:54.690
of these simple things to create that rich
sensory experience.

00:33:54.690 --> 00:33:56.799
But that's only half of the equation.

00:33:56.799 --> 00:34:02.320
If your apps can talk to you, then they should
listen as well.

00:34:02.320 --> 00:34:03.960
And that's where speech recognition comes
in.

00:34:03.960 --> 00:34:07.030
Here, we're using intents with extras to specify
parameters.

00:34:07.030 --> 00:34:11.099
We're saying the language model we want, which
is almost always going to be freeform if you're

00:34:11.099 --> 00:34:16.369
just taking in data that you want to process,
the prompt that you want to show the user,

00:34:16.369 --> 00:34:18.279
and the language you want to listen in.

00:34:18.279 --> 00:34:23.539
Then we start an activity, which puts up the
voice recognition dialogue and allows the

00:34:23.539 --> 00:34:24.539
user to start speaking.

00:34:24.539 --> 00:34:29.099
And we get all of that back on our activity
result handler.

00:34:29.099 --> 00:34:34.469
Now, in this example, we're going to just
take the most likely result off the top of

00:34:34.469 --> 00:34:35.469
the stack.

00:34:35.469 --> 00:34:38.889
We actually get back an array list of all
the possible solutions based on the recognition

00:34:38.889 --> 00:34:39.889
algorithms.

00:34:39.889 --> 00:34:45.499
Now, the system just has to guess, well, which
of these things most closely matches our expectations?

00:34:45.499 --> 00:34:47.879
But you have an opportunity.

00:34:47.879 --> 00:34:51.809
Because you know the context, you know what
it was that prompted the user to say something

00:34:51.809 --> 00:34:53.669
to the device.

00:34:53.669 --> 00:34:59.480
So it's a much better idea to go through that
entire list and say, well, based on what we're

00:34:59.480 --> 00:35:02.380
expecting, which of those things is the most
likely response?

00:35:02.380 --> 00:35:05.690
And, again, you can do something pretty special
here.

00:35:05.690 --> 00:35:10.890
You can create an app that has better speech
recognition ability than the platform, than

00:35:10.890 --> 00:35:12.400
Google Now.

00:35:12.400 --> 00:35:13.479
Because you know what to expect.

00:35:13.479 --> 00:35:17.559
You know exactly what you think the user was
going to say, and so you're able to then go

00:35:17.559 --> 00:35:23.200
through this list and pick out the appropriate
information.

00:35:23.200 --> 00:35:24.319
So what other senses do we have?

00:35:24.319 --> 00:35:25.920
I think I'd like to move on to touch.

00:35:25.920 --> 00:35:30.880
And I think touch is probably one of the most
fundamental things about modern smartphones,

00:35:30.880 --> 00:35:34.891
things which really changed over from the
feature phones that we had in the past to

00:35:34.891 --> 00:35:39.640
something which was -- felt a little bit more
magic, a little bit more futuristic.

00:35:39.640 --> 00:35:45.180
The first thing you need to do is make sure
the things which you have on screen are actually

00:35:45.180 --> 00:35:46.180
touchable.

00:35:46.180 --> 00:35:49.269
And that means corresponding to a 48-DP rhythm.

00:35:49.269 --> 00:35:54.640
48 DPs corresponds to about nine millimeters
of physical space, which, not coincidentally,

00:35:54.640 --> 00:35:59.740
is about the amount of space you need to touch
something on a screen with your finger.

00:35:59.740 --> 00:36:04.700
This is important, because you want to make
sure that users get to actually press the

00:36:04.700 --> 00:36:06.200
things they wanted to press.

00:36:06.200 --> 00:36:09.009
You want to delight them, not antagonize them.

00:36:09.009 --> 00:36:12.980
If someone presses a screen, tries to do something,
and something else happens, either they're

00:36:12.980 --> 00:36:17.099
going to get angry at your app because it
did the wrong thing or angry at themselves,

00:36:17.099 --> 00:36:18.330
because they did the wrong thing.

00:36:18.330 --> 00:36:21.369
Either way, you did the wrong thing.

00:36:21.369 --> 00:36:24.859
You want to create something delightful, something
which makes people want to continue using

00:36:24.859 --> 00:36:26.450
your application.

00:36:26.450 --> 00:36:30.079
That means you need to eliminate all of those
situations where something happened which

00:36:30.079 --> 00:36:31.489
the user wasn't expecting.

00:36:31.489 --> 00:36:36.700
And that's one of the reasons why we suggest
you not put buttons or any touch target towards

00:36:36.700 --> 00:36:39.969
the bottom of your screen, because they're
so close to the navigation buttons, it's very

00:36:39.969 --> 00:36:46.210
easy to accidentally exit your app, which,
hopefully, is not what your users were expecting

00:36:46.210 --> 00:36:48.470
to happen.

00:36:48.470 --> 00:36:52.130
It's all really part of trying to create a
more Tactile experience, something which more

00:36:52.130 --> 00:36:56.260
closely resembles touching real things in
the real world.

00:36:56.260 --> 00:36:59.969
And a big part of that is making sure that
you understand that your users know what can

00:36:59.969 --> 00:37:02.740
be touched, and if they touch it, it should
respond.

00:37:02.740 --> 00:37:05.579
If you touch a real thing in real life, you
know you've touched it.

00:37:05.579 --> 00:37:10.049
It reacts somehow, even if it's just by pushing
back against your finger.

00:37:10.049 --> 00:37:13.869
So in this example, we're going to look at
being able to create different backgrounds

00:37:13.869 --> 00:37:16.869
to take account of all of these different
states of being touchable, of being touched,

00:37:16.869 --> 00:37:17.990
of being focused.

00:37:17.990 --> 00:37:23.630
Now, if creating all of these different backgrounds
seems like a lot of hard work, it is.

00:37:23.630 --> 00:37:25.990
So you can cheat and just use one we've built
for you already.

00:37:25.990 --> 00:37:30.510
So you can either stick that in the background
of things like buttons, or go the other way

00:37:30.510 --> 00:37:31.690
and stick it in the foreground.

00:37:31.690 --> 00:37:37.079
If you have an image view which he want to
make touchable, you put this in the foreground

00:37:37.079 --> 00:37:43.289
and you make sure you have the Tactile response,
the ability to touch things and see them react

00:37:43.289 --> 00:37:45.900
when you're touching them.

00:37:45.900 --> 00:37:50.849
We talked earlier about creating apps which
worked for everyone.

00:37:50.849 --> 00:37:52.369
And we're talking about touch.

00:37:52.369 --> 00:37:53.650
We're talking about voice.

00:37:53.650 --> 00:38:01.130
So it seems reasonable to segue into making
sure that your apps work really well for accessibility,

00:38:01.130 --> 00:38:04.849
for people who have visual impairments, to
make sure that they, too, can take advantage

00:38:04.849 --> 00:38:06.769
of your beautifully designed app.

00:38:06.769 --> 00:38:08.819
And it's actually pretty easy.

00:38:08.819 --> 00:38:12.560
Again, add a content description to every
control.

00:38:12.560 --> 00:38:16.619
And it's important here that you describe
the content, not the container.

00:38:16.619 --> 00:38:20.519
So saying, "This is a button," is not helpful.

00:38:20.519 --> 00:38:21.660
You have to say what the button does.

00:38:21.660 --> 00:38:22.799
So, "Send message."

00:38:22.799 --> 00:38:24.130
"Add a contact."

00:38:24.130 --> 00:38:25.130
Whatever it is.

00:38:25.130 --> 00:38:30.229
You have to remember that whoever is using
this can't see your app, or at least can't

00:38:30.229 --> 00:38:31.229
see it well.

00:38:31.229 --> 00:38:32.660
You want to keep it short, concise, and descriptive.

00:38:32.660 --> 00:38:36.849
It's particularly important if you're building
your own controls.

00:38:36.849 --> 00:38:42.039
In this, we have a compass rose, it's beautifully
designed and shows exactly what your direction

00:38:42.039 --> 00:38:43.039
is.

00:38:43.039 --> 00:38:46.200
But for someone who can't see it, that's suddenly
a disadvantage.

00:38:46.200 --> 00:38:50.509
So we're going to create our own accessibility
event that describes that content.

00:38:50.509 --> 00:38:56.060
Every time the visual elements change, we're
going to modify the output for accessibility

00:38:56.060 --> 00:38:58.130
support as well.

00:38:58.130 --> 00:39:03.769
Now, to take a step back, if we're talking
about creating something more Tactile, well,

00:39:03.769 --> 00:39:07.880
the real world, you can interact with using
more than just one finger pressing touch targets

00:39:07.880 --> 00:39:08.880
on a screen.

00:39:08.880 --> 00:39:09.880
You can use gestures.

00:39:09.880 --> 00:39:10.890
You can swipe things away.

00:39:10.890 --> 00:39:12.019
You can turn them around.

00:39:12.019 --> 00:39:15.019
You can move them all with your hands.

00:39:15.019 --> 00:39:19.290
So I recommend checking out this Android training
class on touch gestures.

00:39:19.290 --> 00:39:22.920
This gives you an idea of some of the ways
you can get started to create these more Tactile,

00:39:22.920 --> 00:39:27.890
these more realistic interactions with the
objects on the screen.

00:39:27.890 --> 00:39:30.019
But it's -- again, it's only really going
part of the way.

00:39:30.019 --> 00:39:34.539
Because, again, we can do more than just interact
with things with two fingers.

00:39:34.539 --> 00:39:35.539
We have ten.

00:39:35.539 --> 00:39:39.499
And, in fact, Android supports that with a
delightfully named Jazz Hands.

00:39:39.499 --> 00:39:44.210
I voted for Spirit Fingers, but what are you
going to do?

00:39:44.210 --> 00:39:47.910
In this example, we're keeping track of everything
which is touching the screen.

00:39:47.910 --> 00:39:50.320
I'm going to go ahead and assume it's fingers.

00:39:50.320 --> 00:39:54.469
We know when things get pressed, we know when
it gets lifted off and we know every time

00:39:54.469 --> 00:39:55.469
it's moved.

00:39:55.469 --> 00:39:59.440
And we know every event we receive has all
of that information.

00:39:59.440 --> 00:40:04.040
So suddenly we have access to not just the
location of every finger on the screen, but

00:40:04.040 --> 00:40:09.890
the relative movement over time, which means
that we're able to create some fairly complex

00:40:09.890 --> 00:40:10.890
gestures.

00:40:10.890 --> 00:40:15.130
I'm not suggesting you go and redesign your
entire UI based on ten-finger chord progressions.

00:40:15.130 --> 00:40:17.559
That's going to make it a little less intuitive.

00:40:17.559 --> 00:40:19.730
But what an Easter egg.

00:40:19.730 --> 00:40:23.410
The first time someone picks up a CAD package,
and they go, well, I need this cog and this

00:40:23.410 --> 00:40:30.980
cog to move together and integrate, and to
be able to do that, to resize and shift all

00:40:30.980 --> 00:40:34.900
using two hands on a single device, or having
two people be able to play a game against

00:40:34.900 --> 00:40:41.319
each other on a large tablet, it's not quite
Iron Man 3, it's not quite Minority Report.

00:40:41.319 --> 00:40:43.249
It's not that far off, either.

00:40:43.249 --> 00:40:48.140
It certainly makes using a mouse and a keyboard
look a lot like a hammer and a chisel.

00:40:48.140 --> 00:40:51.559
Once you've experienced this kind of user
interaction, everything else is going to seem

00:40:51.559 --> 00:40:53.259
old and backwards.

00:40:53.259 --> 00:40:54.259
So you want to create that.

00:40:54.259 --> 00:40:58.430
You want to be the app which presents these
magical experiences, these opportunities to

00:40:58.430 --> 00:41:02.509
see into what the future of user interaction
is going to be like.

00:41:02.509 --> 00:41:05.719
Now, again, there are risks.

00:41:05.719 --> 00:41:10.180
And we're breaking the rules, we're trying
to create an emotional response from our users.

00:41:10.180 --> 00:41:16.349
And the reality is not every emotional response
is positive.

00:41:16.349 --> 00:41:19.170
Particularly if you change things which people
have gotten used to.

00:41:19.170 --> 00:41:22.329
Things which people think as the killer feature
of your app, and then you go and change it

00:41:22.329 --> 00:41:25.880
or you make it unavailable because, well,
you kind of got bored with it or it was hard

00:41:25.880 --> 00:41:26.880
to implement.

00:41:26.880 --> 00:41:29.160
They're going to react angrily.

00:41:29.160 --> 00:41:32.859
So it's really important that whenever you're
trying to break those rules, break those conventions,

00:41:32.859 --> 00:41:39.060
that you do a lot of testing, which is why
it's so helpful that Google Play now has the

00:41:39.060 --> 00:41:44.349
ability to do beta testing and stage rollouts,
which means you can create a circle of people,

00:41:44.349 --> 00:41:48.119
your trusted testers, who you're going to
push out these new releases for.

00:41:48.119 --> 00:41:49.910
These are your most passionate users.

00:41:49.910 --> 00:41:53.049
And you can test all of your changes, see
how they react.

00:41:53.049 --> 00:41:56.789
And you can use things like Analytics to find
out exactly how that's going.

00:41:56.789 --> 00:41:59.200
But better still, you should ask them.

00:41:59.200 --> 00:42:03.509
Because a lot of this emotional stuff, a lot
of this engagement is about more than just

00:42:03.509 --> 00:42:04.509
how people use the app.

00:42:04.509 --> 00:42:06.579
It's about how they feel about the app.

00:42:06.579 --> 00:42:10.529
So this now gives you that opportunity to
talk to your users, give them a special version,

00:42:10.529 --> 00:42:13.290
and see how that goes before you start rolling
it out.

00:42:13.290 --> 00:42:16.299
Once you do start rolling it out, you can
keep track of how that's going.

00:42:16.299 --> 00:42:20.680
If you see that your star rating is starting
to crash as you increase the number of people

00:42:20.680 --> 00:42:25.810
using the new version, it may be a good time
to stop, take stock, and see whether or not

00:42:25.810 --> 00:42:28.500
you're making the right decision.

00:42:28.500 --> 00:42:34.170
And it's important to remember, too, when
you're doing these things that not all users

00:42:34.170 --> 00:42:35.789
are created equal.

00:42:35.789 --> 00:42:39.019
They're certainly all equal in the general
sense.

00:42:39.019 --> 00:42:41.759
But they're not all equally valuable to you.

00:42:41.759 --> 00:42:46.900
I had a look at the analytics for my app,
Earthquake, on Google Play.

00:42:46.900 --> 00:42:51.049
And unsurprisingly, it turns out that smartphones
are my largest audience.

00:42:51.049 --> 00:42:56.650
What was a little more surprising to me is
that tablet users were far more engaged.

00:42:56.650 --> 00:42:59.729
They spent a lot of more time in my app.

00:42:59.729 --> 00:43:03.339
Now, that may not be particularly relevant
to you.

00:43:03.339 --> 00:43:05.940
Maybe you don't care how much time people
spend in your app.

00:43:05.940 --> 00:43:08.719
If you're selling advertising, you probably
do.

00:43:08.719 --> 00:43:12.589
If you're doing some other kind of monetization
strategy, such as in-app billing, what's more

00:43:12.589 --> 00:43:17.089
important to you is understanding how quickly
they navigate through that funnel.

00:43:17.089 --> 00:43:21.240
But either way, what you need to figure out
is who is your most valuable user base.

00:43:21.240 --> 00:43:24.989
Who are the people which represent your key
audience.

00:43:24.989 --> 00:43:26.430
What is making them happy?

00:43:26.430 --> 00:43:27.530
How do I make them happier?

00:43:27.530 --> 00:43:30.380
How do I make other people as happy as them?

00:43:30.380 --> 00:43:33.700
You can get a lot of this information from
the Google Play Developer Console, which gives

00:43:33.700 --> 00:43:39.140
you a good start for understanding sort of
the broad breakdowns of countries and devices

00:43:39.140 --> 00:43:40.520
and device types.

00:43:40.520 --> 00:43:44.249
But if you really want to understand that
funnel, understand how people are going through

00:43:44.249 --> 00:43:49.369
your app, where they're exiting and why, you
need to use a slightly more robust solution.

00:43:49.369 --> 00:43:53.780
And that's where something like Google Analytics
for Mobile Applications comes into play.

00:43:53.780 --> 00:43:59.410
Here you can track every action, every button
they press, every screen they swipe, to understand

00:43:59.410 --> 00:44:00.869
how are they using their app?

00:44:00.869 --> 00:44:02.430
What is their path?

00:44:02.430 --> 00:44:04.979
What is the path of people who are monetizing
the best?

00:44:04.979 --> 00:44:06.329
How do I optimize that?

00:44:06.329 --> 00:44:08.400
Where are people exiting my app, and why?

00:44:08.400 --> 00:44:12.470
And this kind of rich information is really
important to understand how to create that

00:44:12.470 --> 00:44:17.059
delightful response, how to create something
that speaks viscerally to your apps so that

00:44:17.059 --> 00:44:18.059
it appears magical.

00:44:18.059 --> 00:44:22.730
You want to remove all the obstacles and make
it as easy for them to enjoy your app as they

00:44:22.730 --> 00:44:25.749
can.

00:44:25.749 --> 00:44:31.890
That brings me to my final point.

00:44:31.890 --> 00:44:50.690
[ Sound effects ]
(Game video).

00:44:50.690 --> 00:45:04.069
&gt;&gt;Reto Meier: So a good magician never reveals
his tricks.

00:45:04.069 --> 00:45:08.210
And neither should you, because that's the
surest way of ruining the magic.

00:45:08.210 --> 00:45:11.630
You want to keep people guessing, asking the
question, how did they do that?

00:45:11.630 --> 00:45:12.630
Is that even possible?

00:45:12.630 --> 00:45:14.549
I didn't think you could do that.

00:45:14.549 --> 00:45:17.119
Telling them how totally destroys all of that.

00:45:17.119 --> 00:45:20.819
And for me, one of the most magical things
about smartphones is still the Internet, the

00:45:20.819 --> 00:45:24.750
fact that there is this cloud of information
that has the answers to all of my questions.

00:45:24.750 --> 00:45:27.539
But you want to steal that magic for yourself.

00:45:27.539 --> 00:45:31.369
You don't want people thinking about the fact
that your app is a portal to a world of information.

00:45:31.369 --> 00:45:34.640
You want people to think your app knows everything.

00:45:34.640 --> 00:45:39.700
And so a big part of that for me is to eliminate
that transport mechanism, make people not

00:45:39.700 --> 00:45:41.700
think about the fact that this is happening.

00:45:41.700 --> 00:45:45.829
Or to put it another way, eliminate the refresh
button.

00:45:45.829 --> 00:45:49.619
Or at least make it something that your users
never have to press, something you can safely

00:45:49.619 --> 00:45:54.339
hide away in after overflow menu somewhere,
and then you look at your analytics, actually,

00:45:54.339 --> 00:45:55.349
no one uses it.

00:45:55.349 --> 00:45:59.839
Some people feel better that it's there, but
they never have to, because your data is always

00:45:59.839 --> 00:46:05.009
up-to-date, it's always relevant, it's all
low latency, you always know exactly what

00:46:05.009 --> 00:46:08.969
the user wants before they've even had to
ask for it, and certainly before they've had

00:46:08.969 --> 00:46:11.609
to press refresh to find out where it is.

00:46:11.609 --> 00:46:16.770
Now, last year, I talked a lot about this,
and the big cookie model for transferring

00:46:16.770 --> 00:46:17.770
data.

00:46:17.770 --> 00:46:21.369
So this idea of bundling and batching and
prefetching all of your information to make

00:46:21.369 --> 00:46:25.780
sure that it's as efficient as possible when
you're performing your data transfers.

00:46:25.780 --> 00:46:30.280
This year, I want to take a step sideways
and look at some of the APIs that you can

00:46:30.280 --> 00:46:35.640
use to really implement some of those higher-level
notions.

00:46:35.640 --> 00:46:40.459
So generally speaking, amongst the reasons
to transfer data are client updates, server

00:46:40.459 --> 00:46:46.400
updates, there's on-demand downloads and uploads,
and cross-device updates.

00:46:46.400 --> 00:46:51.799
Now, for server updates, hopefully, you're
all very familiar with Google Cloud Messaging,

00:46:51.799 --> 00:46:56.769
you're using this instead of setting up repeating
alarms to poll your server at a certain interval

00:46:56.769 --> 00:46:58.740
to find out if there's anything new to check.

00:46:58.740 --> 00:47:02.589
Because it's clearly the right way to go.

00:47:02.589 --> 00:47:08.630
You use our infrastructure to have your server
tell our server when the clients need to be

00:47:08.630 --> 00:47:12.029
updated, and then we can handle sending that
information to your clients so that they don't

00:47:12.029 --> 00:47:13.630
need to poll.

00:47:13.630 --> 00:47:17.849
They just get notified of when there is new
information that they need to synchronize

00:47:17.849 --> 00:47:18.849
with.

00:47:18.849 --> 00:47:23.089
Now, as I say, hopefully, you're all already
using this, because every time you set up

00:47:23.089 --> 00:47:30.410
a repeating alarm to poll a server to look
for data updates, Sundar kills a bugdroid.

00:47:30.410 --> 00:47:33.410
[ Laughter ]
&gt;&gt;Reto Meier: Sad but true.

00:47:33.410 --> 00:47:37.940
Moving on, what else can we do, cross-device
updates, that's another one which is very

00:47:37.940 --> 00:47:38.940
handy.

00:47:38.940 --> 00:47:42.369
As it turns out, Google Cloud Messaging can
help you there as well.

00:47:42.369 --> 00:47:48.430
Now you can create a persistent SMPP connection
between your server and our server and have

00:47:48.430 --> 00:47:53.959
your application running on the device send
messages back to our server, using the same

00:47:53.959 --> 00:47:58.960
Google Cloud Messaging infrastructure rather
than having to maintain that connection between

00:47:58.960 --> 00:48:02.309
your device and your servers yourselves.

00:48:02.309 --> 00:48:03.309
This is really useful.

00:48:03.309 --> 00:48:08.119
In fact, you can use this additionally to
send messages from your device to other devices.

00:48:08.119 --> 00:48:12.890
So things like the Google Calendar notification
cross-device dismissal that you saw in the

00:48:12.890 --> 00:48:15.509
keynote are all powered using this technology.

00:48:15.509 --> 00:48:20.579
So if a user gets notified on one device and
they dismiss it, you want to be able to make

00:48:20.579 --> 00:48:24.969
sure that that same notification disappears
on any other app that they're running, sorry,

00:48:24.969 --> 00:48:29.499
on any other device they're running, so they
don't pick up their tablet and have 15 different

00:48:29.499 --> 00:48:34.380
notifications which they've already dealt
with on their phone.

00:48:34.380 --> 00:48:38.469
As it turns out, it's actually a pretty simple
API, certainly from the client side, all you

00:48:38.469 --> 00:48:42.589
need to do is get access to a Google Cloud
Messaging object and send a message.

00:48:42.589 --> 00:48:47.040
And you can specify either a project ID to
send it back to your server or a notification

00:48:47.040 --> 00:48:49.759
ID to transmit it to all of the other devices.

00:48:49.759 --> 00:48:54.120
Not going to go into too much detail, not
going to talk about the server setup, because

00:48:54.120 --> 00:48:59.319
I am not a server guy, but Francesco, who
is, and knows all about Google Cloud Messaging

00:48:59.319 --> 00:49:04.849
because he wrote it, is presenting in this
room at 1:40 this afternoon.

00:49:04.849 --> 00:49:06.539
So I recommend that you check it out.

00:49:06.539 --> 00:49:09.960
Even if you use Google Cloud Messaging, find
out all about these new features and how you

00:49:09.960 --> 00:49:15.229
can make your apps even more efficient when
it comes to downloading data.

00:49:15.229 --> 00:49:18.619
So -- okay, so GMC has taken care of server
and cross device.

00:49:18.619 --> 00:49:21.009
Let's have a look at client updates.

00:49:21.009 --> 00:49:25.670
Now, for client updates, when you've got information
on your device that you want to send to a

00:49:25.670 --> 00:49:31.519
server, there's actually a really useful API
that already exists, if it's somewhat underutilized.

00:49:31.519 --> 00:49:34.650
And that is Sync Adapter.

00:49:34.650 --> 00:49:38.180
One of the reasons it's not well utilized
is because we've done a terrible job of documenting

00:49:38.180 --> 00:49:39.180
it.

00:49:39.180 --> 00:49:40.180
And we're going to change that.

00:49:40.180 --> 00:49:43.619
But I'm going to step you through the process
now so you understand exactly how relatively

00:49:43.619 --> 00:49:44.749
simple it is.

00:49:44.749 --> 00:49:46.440
I said there was going to be code.

00:49:46.440 --> 00:49:51.269
There's quite a lot of code here, and quite
a short amount of time, so be prepared.

00:49:51.269 --> 00:49:54.930
So you start by extending the abstract thread
in Sync Adapter.

00:49:54.930 --> 00:49:56.999
This part is really simple.

00:49:56.999 --> 00:49:58.990
Extend it, overwrite on perform sync.

00:49:58.990 --> 00:50:03.140
And this is all going to be asynchronously
and handled for you.

00:50:03.140 --> 00:50:07.109
So all of the queuing, all of the time shifting
to make sure that all of your requests are

00:50:07.109 --> 00:50:12.010
bundled up together within sort of a short
time window and across apps as well is all

00:50:12.010 --> 00:50:13.010
handled.

00:50:13.010 --> 00:50:16.420
We'll even check to see whether or not the
device is connected to the Internet and wait

00:50:16.420 --> 00:50:17.920
until you are until that happens.

00:50:17.920 --> 00:50:20.599
We can even support things like whether or
not you're connected to Wi-Fi.

00:50:20.599 --> 00:50:25.519
So All of those intent receivers that I talked
about last year, if you use the Sync Adapter,

00:50:25.519 --> 00:50:30.160
we will do all of that work on your behalf.

00:50:30.160 --> 00:50:34.299
We designed all of this to work specifically
to synchronize content providers associated

00:50:34.299 --> 00:50:37.739
with an account with a server where that data
is stored.

00:50:37.739 --> 00:50:39.319
So think something like Gmail.

00:50:39.319 --> 00:50:43.750
So there's a little bit of extra plumbing
that you need to do if you don't already have

00:50:43.750 --> 00:50:44.750
those.

00:50:44.750 --> 00:50:48.529
If you do have an account and a content provider
in your app, good news, you can stop paying

00:50:48.529 --> 00:50:49.529
attention.

00:50:49.529 --> 00:50:53.750
For the rest of you, I'm going to show you
a little shortcut so that you can take advantage

00:50:53.750 --> 00:50:57.029
of this API without having to figure out too
much about the rest of it.

00:50:57.029 --> 00:50:59.769
So you start by wrapping your adapter in a
service.

00:50:59.769 --> 00:51:03.959
So this is going to represent the process
that is actually going to run and skewed that

00:51:03.959 --> 00:51:06.589
Sync Adapter when we request syncs.

00:51:06.589 --> 00:51:08.880
So far, so good.

00:51:08.880 --> 00:51:12.180
Next, we need to create an abstract account
authenticator.

00:51:12.180 --> 00:51:14.650
Here's where it starts to look a little bit
more complicated.

00:51:14.650 --> 00:51:17.690
But, again, this is largely boilerplate stubbed
code.

00:51:17.690 --> 00:51:20.809
The important thing here to keep in mind is
the account type.

00:51:20.809 --> 00:51:24.989
So that is one of the things we're going to
use as a key when we request sync.

00:51:24.989 --> 00:51:30.190
It's going to be the account type and the
content provider authority.

00:51:30.190 --> 00:51:33.430
All that's happening in this piece of code
here is that we're going to basically create

00:51:33.430 --> 00:51:34.430
a dummy account.

00:51:34.430 --> 00:51:38.239
We're going to force a new account specifically
for your application into the device.

00:51:38.239 --> 00:51:39.740
It's going to be invisible to users.

00:51:39.740 --> 00:51:42.650
It's not going to have authority to do anything.

00:51:42.650 --> 00:51:48.069
It's just a way of being able to create this
dummy account that we can reference.

00:51:48.069 --> 00:51:50.999
Because it's doing something, we need to wrap
that in a service as well.

00:51:50.999 --> 00:51:55.910
So that's going to be the service which wraps
around that account adapter and creates it

00:51:55.910 --> 00:51:57.249
for you.

00:51:57.249 --> 00:52:02.380
And then we have a little config file where
we define what our account type is again so

00:52:02.380 --> 00:52:06.710
that the manifest knows what it is when we're
looking for an account that we can use.

00:52:06.710 --> 00:52:10.249
And a bunch of extra metadata which we don't
actually need, because we're not actually

00:52:10.249 --> 00:52:12.539
going to display this to anyone.

00:52:12.539 --> 00:52:13.569
Next we have a content provider.

00:52:13.569 --> 00:52:16.309
And I think this is probably a little bit
more familiar to everyone.

00:52:16.309 --> 00:52:18.680
And this is just completely stubbed out.

00:52:18.680 --> 00:52:21.960
So even if you don't want to use a content
provider in your app, you can still utilize

00:52:21.960 --> 00:52:22.960
this.

00:52:22.960 --> 00:52:26.949
The key here is, again, when we add it to
our manifest, we define the authority.

00:52:26.949 --> 00:52:31.549
And that's the other key that we're going
to use when we're asking for our syncs.

00:52:31.549 --> 00:52:37.049
So now we have all the information that we
need to create our Sync Adapter XML.

00:52:37.049 --> 00:52:40.030
So if you already have an account type and
a content provider, here's the bit where you

00:52:40.030 --> 00:52:41.959
get to start listening again.

00:52:41.959 --> 00:52:45.449
You specify the authority and the account
type here so that when we're going through

00:52:45.449 --> 00:52:50.140
the manifest looking for a Sync Adapter that
we want to run, those keys are available.

00:52:50.140 --> 00:52:55.209
Then we put all of it into the manifest, the
services, the metadata associated with each

00:52:55.209 --> 00:52:57.579
of them, and we're ready to go.

00:52:57.579 --> 00:52:59.829
So now we get back to the easy bit.

00:52:59.829 --> 00:53:04.609
Once we want to request a sync, we simply
specify the account and the content provider

00:53:04.609 --> 00:53:09.400
that we want to sync against, access the content
resolver, request a sync, and that's it.

00:53:09.400 --> 00:53:11.119
It will do all of the hard work for you.

00:53:11.119 --> 00:53:14.549
It will figure out when it should initiate
that synchronization, it will handle being

00:53:14.549 --> 00:53:18.569
offline and online, all of those things will
be done for you.

00:53:18.569 --> 00:53:20.709
And you can use this as well to do periodic
things.

00:53:20.709 --> 00:53:24.440
By default, it's going to sync every 24 hours.

00:53:24.440 --> 00:53:27.900
So you can have it more often than that if
that's appropriate for your app.

00:53:27.900 --> 00:53:32.049
Now, there's a few good reasons for doing
this.

00:53:32.049 --> 00:53:36.380
But if we're talking about periodic synchronization,
I feel like it would be remiss of me again

00:53:36.380 --> 00:53:41.280
not to mention one of the reasons why it's
important not to try and sync your application

00:53:41.280 --> 00:53:42.859
at a specific time.

00:53:42.859 --> 00:53:43.969
Because there's that temptation.

00:53:43.969 --> 00:53:46.949
You know when your server is going to update,
2:00 a.m. every morning.

00:53:46.949 --> 00:53:51.039
So why don't we set an alarm so that we wake
the device and perform that sync at exactly

00:53:51.039 --> 00:53:52.059
that time.

00:53:52.059 --> 00:53:56.799
Well, if you do that, your server traffic
is going to look like this.

00:53:56.799 --> 00:53:57.799
That's fine; right?

00:53:57.799 --> 00:53:58.799
You don't care.

00:53:58.799 --> 00:53:59.799
You're in the cloud.

00:53:59.799 --> 00:54:00.799
You've got bandwidth.

00:54:00.799 --> 00:54:01.799
It's fine.

00:54:01.799 --> 00:54:04.559
Of course, everyone else's app who is also
running on the same device and waiting for

00:54:04.559 --> 00:54:10.050
the device to wake up before they do a synchronization,
well, their server traffic is going to look

00:54:10.050 --> 00:54:11.819
like this, too.

00:54:11.819 --> 00:54:12.819
That sucks to be them.

00:54:12.819 --> 00:54:13.819
They should have scaled.

00:54:13.819 --> 00:54:14.819
You did.

00:54:14.819 --> 00:54:16.150
They should be able to handle it as well.

00:54:16.150 --> 00:54:19.869
But what happens when you get your traffic
and all the traffic from every other app on

00:54:19.869 --> 00:54:23.119
every device where your app is installed and
add them all together?

00:54:23.119 --> 00:54:27.180
Well, then the carrier has a spike that looks
like this.

00:54:27.180 --> 00:54:29.209
And that makes them very sad.

00:54:29.209 --> 00:54:30.209
This is a bad thing.

00:54:30.209 --> 00:54:34.039
This is what makes people's pagers go off
at exactly 2:00 a.m. every morning.

00:54:34.039 --> 00:54:40.359
You want to make sure you don't synchronize
anything based on time.

00:54:40.359 --> 00:54:45.290
If we're creating something like the synchronized
Sync Adapter we just talked about, that's

00:54:45.290 --> 00:54:48.250
going to happen 24 hours from whenever your
app was installed.

00:54:48.250 --> 00:54:50.249
So it's kind of pseudo random.

00:54:50.249 --> 00:54:55.019
If you do want to manually create something
around a specific time because this just makes

00:54:55.019 --> 00:54:58.859
sense, even if you're not looking to transfer
data, even if you just want to wake the phone

00:54:58.859 --> 00:55:03.740
up at 2:00 a.m. every morning to do something
else, not related to the Internet, you'll

00:55:03.740 --> 00:55:05.949
still have that follow-on effect to all of
the other apps.

00:55:05.949 --> 00:55:09.749
So you want to create a bit of randomized
jitter, something to spread that out across

00:55:09.749 --> 00:55:15.660
an hour or two, whatever you can handle, the
wider, the better, to try and spread that

00:55:15.660 --> 00:55:19.750
load, both for your servers, your -- the servers
of everyone else, not to mention the carrier

00:55:19.750 --> 00:55:25.910
bandwidth.

00:55:25.910 --> 00:55:30.499
Another approach you can take is to be a little
bit clever and use sort of completely randomized

00:55:30.499 --> 00:55:31.959
information.

00:55:31.959 --> 00:55:35.300
So maybe it's -- you know what time the person
gets up every morning, so you schedule it

00:55:35.300 --> 00:55:38.789
to happen between an hour and two hours before
they get up.

00:55:38.789 --> 00:55:43.729
Or maybe you can use the Activity Recognition
and say, look, I don't care, until they pick

00:55:43.729 --> 00:55:47.289
their phone up first thing in the morning,
then I want to perform the synchronization

00:55:47.289 --> 00:55:48.380
straightaway.

00:55:48.380 --> 00:55:53.719
So we can use this API to find out when that
happens and perform our syncs accordingly.

00:55:53.719 --> 00:55:57.650
What does that leave us with?

00:55:57.650 --> 00:55:58.650
On-demand downloads.

00:55:58.650 --> 00:55:59.920
So there's not a lot we can do there.

00:55:59.920 --> 00:56:02.509
On-demand downloads need to happen on demand.

00:56:02.509 --> 00:56:04.319
But we can be a little bit clever.

00:56:04.319 --> 00:56:08.769
We can build all of that into your Sync Adapter
so we can bundle and batch everything together

00:56:08.769 --> 00:56:13.240
so every time we're doing a download because
it has to happen, we request that sync and

00:56:13.240 --> 00:56:15.069
it'll happen within 30 seconds.

00:56:15.069 --> 00:56:17.360
We're going to upload everything we need to.

00:56:17.360 --> 00:56:19.130
We're going to prefetch everything we need
to.

00:56:19.130 --> 00:56:22.039
We're going to transmit our analytics, we're
going to download any ads, we're going to

00:56:22.039 --> 00:56:23.849
do our next prefetch ahead of time.

00:56:23.849 --> 00:56:27.880
All of that is going to happen whenever we
do any kind of download, so we're batching

00:56:27.880 --> 00:56:31.420
that all, create a much more efficient app.

00:56:31.420 --> 00:56:34.709
All right, you've all been very patient.

00:56:34.709 --> 00:56:36.359
It's been a full hour.

00:56:36.359 --> 00:56:41.759
We started this session talking about how
to create magical apps.

00:56:41.759 --> 00:56:47.190
And we're trying to do that in a world where
time moves exponentially, or at least progress

00:56:47.190 --> 00:56:48.190
does.

00:56:48.190 --> 00:56:50.400
So that becomes a real challenge.

00:56:50.400 --> 00:56:56.660
Because we're trying to create apps that are
so advanced that they seem as though they

00:56:56.660 --> 00:57:01.369
are magic, something which, if you showed
the teenaged version of yourself, they'd be

00:57:01.369 --> 00:57:03.930
left speechless, how does that work?

00:57:03.930 --> 00:57:05.180
Is that even possible?

00:57:05.180 --> 00:57:09.920
And, in fact, that's really what we're trying
to do is create something that is impossible,

00:57:09.920 --> 00:57:13.489
something that seems impossible to everyone
else.

00:57:13.489 --> 00:57:19.369
So, hopefully, from today's session, you come
away knowing how to use context to create

00:57:19.369 --> 00:57:23.720
these delightful experiences that are visceral,
that speak to us on an emotional level.

00:57:23.720 --> 00:57:28.180
And, of course, being good magicians, never
giving away our tricks.

00:57:28.180 --> 00:57:34.239
So I'm hoping that when you leave this session
today, you're not just developing new apps

00:57:34.239 --> 00:57:39.650
for the future, you're helping to define the
future itself.

00:57:39.650 --> 00:57:43.419
Thank you.

00:57:43.419 --> 00:57:52.849
[ Applause ]
&gt;&gt;Reto Meier: All right.

00:57:52.849 --> 00:57:54.380
We are totally out of time for questions.

00:57:54.380 --> 00:57:57.410
I'm going to head to office hours in about
30 minutes.

00:57:57.410 --> 00:57:59.289
I have something I need to do in between.

00:57:59.289 --> 00:58:01.479
But do please join us there.

00:58:01.479 --> 00:58:04.600
And do take an opportunity to rate the session,
particularly if you liked it.

00:58:04.600 --> 00:58:07.299
If you didn't like it, maybe keep it to yourself.

00:58:07.299 --> 00:58:08.339
[ Laughter ]

