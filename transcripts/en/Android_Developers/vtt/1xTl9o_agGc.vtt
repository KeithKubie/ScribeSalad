WEBVTT
Kind: captions
Language: en

00:00:04.515 --> 00:00:06.390
CHRIS FOLEY: Today,
we're going to talk about

00:00:06.390 --> 00:00:10.450
From Systrace to Safety Net,
Android Game Development Case

00:00:10.450 --> 00:00:10.950
Studies.

00:00:13.680 --> 00:00:14.890
My name is Chris Foley.

00:00:14.890 --> 00:00:19.240
I'm a developer advocate working
with games here at Google.

00:00:19.240 --> 00:00:23.040
And today, I'm joined onstage
by Damien Mabin, who is

00:00:23.040 --> 00:00:25.650
a game engineer from Supercell.

00:00:28.650 --> 00:00:32.530
And today, I wanted to
talk about a few things--

00:00:32.530 --> 00:00:35.340
it's not just one topic,
it's actually a few topics--

00:00:35.340 --> 00:00:37.890
about experiences that
some of the partners

00:00:37.890 --> 00:00:41.790
that we've worked with have had
in Android game development.

00:00:41.790 --> 00:00:44.340
And some of the topics that
we'll be covering today

00:00:44.340 --> 00:00:47.970
will be Systrace.

00:00:47.970 --> 00:00:52.410
Then we'll also be talking
about Instant Games.

00:00:52.410 --> 00:00:55.470
And, thirdly, we'll be going
over a few case studies

00:00:55.470 --> 00:00:57.000
and examples of
how developers have

00:00:57.000 --> 00:01:01.440
used app licensing and
SafetyNET Attestation API

00:01:01.440 --> 00:01:03.150
in order to
safeguard their game.

00:01:05.690 --> 00:01:10.090
So, first of all, I wanted to
talk a little bit about frame

00:01:10.090 --> 00:01:15.130
pacing and using Systrace to fix
some issues that Supercell had

00:01:15.130 --> 00:01:16.720
with their game "Brawl Stars."

00:01:16.720 --> 00:01:19.090
So up here is Damien.

00:01:19.090 --> 00:01:22.930
And Damien will be happy
to walk through us what

00:01:22.930 --> 00:01:25.870
they did with frame
pacing, or fixing the frame

00:01:25.870 --> 00:01:27.130
pacing with Systrace.

00:01:27.130 --> 00:01:29.170
And I'll hand it over to him.

00:01:29.170 --> 00:01:30.720
And he can start over right now.

00:01:33.240 --> 00:01:34.490
DAMIEN MABIN: Hi, everyone.

00:01:34.490 --> 00:01:36.760
I'm Damien.

00:01:36.760 --> 00:01:37.260
OK.

00:01:37.260 --> 00:01:40.290
You might know at Supercell
we have different teams

00:01:40.290 --> 00:01:43.650
that are fairly autonomous.

00:01:43.650 --> 00:01:45.570
And I work in the
game engineering team.

00:01:45.570 --> 00:01:48.750
So I am trying to help
game's team focus on what

00:01:48.750 --> 00:01:50.470
they do best, making the game.

00:01:50.470 --> 00:01:55.970
I'm trying to deal with platform
issues or technical issues.

00:01:55.970 --> 00:02:02.594
And one of them is input latency
in Android has been quite big.

00:02:02.594 --> 00:02:08.670
So while investigating
input latancy,

00:02:08.670 --> 00:02:11.210
one topic that came very
quickly is frame pacing.

00:02:11.210 --> 00:02:13.390
So let's talk a little
bit about frame pacing.

00:02:13.390 --> 00:02:15.400
It's just a very
quick intro before we

00:02:15.400 --> 00:02:17.800
do more technical explanation.

00:02:17.800 --> 00:02:23.020
So here you see the yellow line
is the timeline in the game.

00:02:23.020 --> 00:02:27.580
And the green bars are the
Vsync when the display actually

00:02:27.580 --> 00:02:29.110
refresh the image.

00:02:29.110 --> 00:02:33.160
And what happens
in many games is

00:02:33.160 --> 00:02:37.170
the game is going to draw one
frame, frame number one here.

00:02:37.170 --> 00:02:39.480
And at the end, it's
going to put it--

00:02:39.480 --> 00:02:41.860
that bar is going to
show the number of buffer

00:02:41.860 --> 00:02:43.750
being queued for display.

00:02:43.750 --> 00:02:46.180
So after drawing
frame number one,

00:02:46.180 --> 00:02:47.770
it's going to be
unqueued for display.

00:02:47.770 --> 00:02:51.520
And hopefully it's going to
get displayed at the next Vsync

00:02:51.520 --> 00:02:54.110
here.

00:02:54.110 --> 00:02:57.090
While it's waiting for the
first frame to be displayed,

00:02:57.090 --> 00:03:01.040
it's going to draw a second
frame, which will get unqueued

00:03:01.040 --> 00:03:03.080
when it's finished drawing.

00:03:03.080 --> 00:03:04.970
And the game is
not idle, so it's

00:03:04.970 --> 00:03:08.090
going to start during the third
frame, which, in Android, will

00:03:08.090 --> 00:03:10.050
also get unqueued,
because Android

00:03:10.050 --> 00:03:11.660
allows triple buffering.

00:03:11.660 --> 00:03:14.060
So right now we have two
buffer in the queue waiting

00:03:14.060 --> 00:03:16.590
to be displayed and one
buffer currently displayed

00:03:16.590 --> 00:03:18.090
to the user.

00:03:18.090 --> 00:03:22.650
At the next Vsync, frame number
two is going to get displayed.

00:03:22.650 --> 00:03:23.490
Sorry.

00:03:23.490 --> 00:03:26.228
That's an interesting
bit, actually.

00:03:26.228 --> 00:03:28.020
What should happen is
that you should start

00:03:28.020 --> 00:03:29.740
during frame number four there.

00:03:29.740 --> 00:03:33.360
However, it's going to get
delayed until after the Vsync

00:03:33.360 --> 00:03:36.010
because you cannot
acquire one more buffer.

00:03:36.010 --> 00:03:37.590
Android doesn't allow it.

00:03:37.590 --> 00:03:40.520
It's only triple buffering.

00:03:40.520 --> 00:03:44.910
So after the Vsync, frame
number two is being displayed.

00:03:44.910 --> 00:03:49.000
Frame number three is
still in the queue.

00:03:49.000 --> 00:03:51.510
And you can start draw frame
number four because you

00:03:51.510 --> 00:03:53.790
can acquire when buffered.

00:03:53.790 --> 00:03:55.780
At the end of drawing
frame number four,

00:03:55.780 --> 00:03:57.360
it's going to get unqueued.

00:03:57.360 --> 00:04:01.320
And you are in a constant state
of triple buffering right now.

00:04:01.320 --> 00:04:04.937
So the next frame is going
to be drawn after the Vsync.

00:04:04.937 --> 00:04:06.270
And you are going to unqueue it.

00:04:06.270 --> 00:04:10.790
And you are in a constant
state of triple buffering.

00:04:10.790 --> 00:04:13.550
I guess the reason
why it's bad is

00:04:13.550 --> 00:04:16.579
when you start considering
inputs and the user

00:04:16.579 --> 00:04:19.700
feeling of latency between when
the user touches the screen

00:04:19.700 --> 00:04:22.500
and does something and when
it happened on the screen.

00:04:22.500 --> 00:04:27.200
So let's overlay on that
this yellow-orange bar.

00:04:27.200 --> 00:04:30.440
These orange bar represent
the time when Android tell us

00:04:30.440 --> 00:04:33.050
something, some input happened.

00:04:33.050 --> 00:04:36.060
It's actually tightly
coupled with the Vsync.

00:04:36.060 --> 00:04:39.060
So it happened a little
bit after the Vsync.

00:04:39.060 --> 00:04:43.130
And if you look at the first
image and the first buffer

00:04:43.130 --> 00:04:47.000
on the one, the draw
one, well, the input

00:04:47.000 --> 00:04:49.070
happened after the
drawing has started.

00:04:49.070 --> 00:04:51.620
So you can imagine the game
cannot really handle the input

00:04:51.620 --> 00:04:52.670
right there.

00:04:52.670 --> 00:04:54.440
So the game is actually
going to consume

00:04:54.440 --> 00:04:57.920
the input on the next
frame, which will then

00:04:57.920 --> 00:05:02.960
be rendered during that
frame, which will be unqueued,

00:05:02.960 --> 00:05:05.900
which will be consumed
only in the next Vsync.

00:05:05.900 --> 00:05:09.290
So here, you are looking at
the latency of one full Vsync

00:05:09.290 --> 00:05:11.120
plus maybe 10
milliseconds, which

00:05:11.120 --> 00:05:13.610
is 26 milliseconds latency.

00:05:13.610 --> 00:05:16.003
It wouldn't be terribly bad.

00:05:16.003 --> 00:05:18.170
But if you look at the case
where the game is triple

00:05:18.170 --> 00:05:22.030
buffering, for
example, this one,

00:05:22.030 --> 00:05:27.255
you start seeing that, between
the time where you receive

00:05:27.255 --> 00:05:31.140
the inputs and the time
where it is unqueued,

00:05:31.140 --> 00:05:35.370
there is maybe around 18
milliseconds roughly there.

00:05:35.370 --> 00:05:37.840
But it is unqueued.

00:05:37.840 --> 00:05:39.620
It's not the next
buffer to be displayed.

00:05:39.620 --> 00:05:43.180
It's actually the
third-- the second one.

00:05:43.180 --> 00:05:45.970
So you are looking at the
whole end-to-end latency

00:05:45.970 --> 00:05:49.500
around 40 milliseconds,
which start being noticeable

00:05:49.500 --> 00:05:53.500
as a player, especially when you
look at a fast-pace action game

00:05:53.500 --> 00:05:56.950
like "Brawl Stars."

00:05:56.950 --> 00:05:58.390
So what can we do?

00:05:58.390 --> 00:06:02.340
Well, let's take
a look first at--

00:06:02.340 --> 00:06:02.840
sorry.

00:06:02.840 --> 00:06:04.750
Can we switch to
the laptop, please?

00:06:04.750 --> 00:06:07.140
CHRIS FOLEY: Yeah.

00:06:07.140 --> 00:06:08.740
DAMIEN MABIN: Oh yeah, good.

00:06:08.740 --> 00:06:12.460
Let's take a look
quickly at Systrace.

00:06:12.460 --> 00:06:15.780
So when I was
investigating this issue--

00:06:19.120 --> 00:06:19.930
sorry.

00:06:19.930 --> 00:06:22.560
Give me one second.

00:06:22.560 --> 00:06:26.886
OK, when I was investigating
this issue, one thing I was--

00:06:26.886 --> 00:06:28.380
better.

00:06:28.380 --> 00:06:31.710
One thing I took really
right away is Systrace.

00:06:31.710 --> 00:06:35.550
So from far away, it
looks slightly scary.

00:06:35.550 --> 00:06:39.840
I am going to try and explain
a bit what's happening there.

00:06:39.840 --> 00:06:44.470
OK, so here at the top,
you can see the CPU usage,

00:06:44.470 --> 00:06:47.950
which you can see have some
spike on the bottom line that

00:06:47.950 --> 00:06:50.610
is pretty constant.

00:06:50.610 --> 00:06:53.550
There we can see details about
what's happening on each core.

00:06:53.550 --> 00:06:55.740
But we don't care
too much about it.

00:06:55.740 --> 00:06:58.680
And then there is two
interesting bits in Systrace.

00:06:58.680 --> 00:07:00.990
The first one is something
called SurfaceFlinger.

00:07:00.990 --> 00:07:02.460
You can see the name there.

00:07:02.460 --> 00:07:04.350
That's an Android
process that is

00:07:04.350 --> 00:07:10.430
responsible for composing
the final image drawn

00:07:10.430 --> 00:07:12.210
on the screen of your device.

00:07:12.210 --> 00:07:14.780
So if you use a
normal app, you will

00:07:14.780 --> 00:07:17.030
see that most of the time
you have the UI of the app.

00:07:17.030 --> 00:07:18.680
But you also have
the notification bar

00:07:18.680 --> 00:07:21.410
at the top on some other
element on the screen.

00:07:21.410 --> 00:07:24.950
So SurfaceFlinger
is the one that

00:07:24.950 --> 00:07:27.530
takes the notification
bar, the image of the app,

00:07:27.530 --> 00:07:30.520
put both of them together
on display on the screen.

00:07:30.520 --> 00:07:33.020
So we are going to look into a
bit of the detail of Systrace

00:07:33.020 --> 00:07:35.700
later.

00:07:35.700 --> 00:07:37.970
And at the bottom
here, we have com

00:07:37.970 --> 00:07:40.290
dot Supercell dot
"Brawl Stars," which is

00:07:40.290 --> 00:07:43.170
the game I was profiling there.

00:07:43.170 --> 00:07:46.780
OK, let's go back to
Systrace a little bit.

00:07:46.780 --> 00:07:48.730
And let's zoom a little bit.

00:07:48.730 --> 00:07:52.150
So the cool part
of Systrace tool,

00:07:52.150 --> 00:07:54.760
if you open it in
Chrome or whatever,

00:07:54.760 --> 00:07:58.420
you can navigate it the same
way you navigate in a game.

00:07:58.420 --> 00:08:01.270
So W and S lets you
zoom in and out.

00:08:01.270 --> 00:08:05.580
And A and D let you go left
and right, which is convenient.

00:08:05.580 --> 00:08:08.130
OK, let's take a look here.

00:08:08.130 --> 00:08:13.780
So the first thing to notice is
these big gray and white bands

00:08:13.780 --> 00:08:17.210
are one frame being
displayed on the screen.

00:08:17.210 --> 00:08:21.110
So if you try to measure, each
of these is 16 milliseconds,

00:08:21.110 --> 00:08:21.610
right?

00:08:21.610 --> 00:08:23.511
It's running at 60 FPS.

00:08:23.511 --> 00:08:26.670
So, yeah.

00:08:26.670 --> 00:08:31.330
And in SurfaceFlinger,
there is one line here,

00:08:31.330 --> 00:08:34.799
SurfaceView com dot
Supercell, which

00:08:34.799 --> 00:08:39.198
is all of the buffers that are
being unqueued for rendering.

00:08:42.010 --> 00:08:43.679
So if I click on this
one, for example,

00:08:43.679 --> 00:08:46.020
you can see there is a value
of two, which means there

00:08:46.020 --> 00:08:47.850
is two buffer in the queue.

00:08:47.850 --> 00:08:49.590
If you look at here,
there is one buffer

00:08:49.590 --> 00:08:52.890
in the queue,
which you can guess

00:08:52.890 --> 00:08:54.810
means we are triple buffering.

00:08:54.810 --> 00:08:58.060
Two buffer in the queue on
one displayed to the user,

00:08:58.060 --> 00:08:58.905
which is pretty bad.

00:08:58.905 --> 00:09:00.780
It's the worst case I
was explaining earlier.

00:09:03.750 --> 00:09:11.410
OK, and if we look a little
bit more in SurfaceFlinger,

00:09:11.410 --> 00:09:16.940
you can see, at the
end of that Vsync here,

00:09:16.940 --> 00:09:18.710
there is a whole
lot of things that

00:09:18.710 --> 00:09:22.570
are happening in the UI thread.

00:09:22.570 --> 00:09:26.045
So this whole lot of things
is what I was explaining.

00:09:26.045 --> 00:09:29.450
If I zoom a lot, we can
see dual composition here.

00:09:29.450 --> 00:09:34.030
It's taking the different buffer
being displayed in the device

00:09:34.030 --> 00:09:39.588
and undoing the composition
to draw it on the screen.

00:09:39.588 --> 00:09:41.130
There is an interesting
bit about it.

00:09:44.130 --> 00:09:47.450
If you look at that
Vsync here, you

00:09:47.450 --> 00:09:53.490
can see that our count
of buffer in the queue

00:09:53.490 --> 00:09:55.720
drop a little bit
after the Vsync,

00:09:55.720 --> 00:10:00.560
like about 500 microseconds.

00:10:00.560 --> 00:10:03.967
The interesting bit
is, naively, when

00:10:03.967 --> 00:10:05.550
I looked at it the
first time, I would

00:10:05.550 --> 00:10:11.480
believe that drop would happen
at the same time as the Vsync.

00:10:11.480 --> 00:10:14.300
It's really interesting,
because what it means

00:10:14.300 --> 00:10:19.780
is that that buffer here is
consumed by the UI thread

00:10:19.780 --> 00:10:24.380
about there when it's
returned [INAUDIBLE] buffer.

00:10:24.380 --> 00:10:27.320
It's later being
composed here, which

00:10:27.320 --> 00:10:31.320
means it's only going
to be drawn there.

00:10:31.320 --> 00:10:35.850
We will see why it's really
important a little bit later.

00:10:35.850 --> 00:10:37.950
But on Android, what
happened is, instead

00:10:37.950 --> 00:10:43.550
of consuming that buffer--

00:10:43.550 --> 00:10:44.160
yeah, sorry.

00:10:44.160 --> 00:10:46.380
Instead of consuming
that buffer here

00:10:46.380 --> 00:10:48.210
in order to draw
it on the screen,

00:10:48.210 --> 00:10:55.030
it's consuming it here in
order to draw it there,

00:10:55.030 --> 00:10:59.890
which have a small impact
on how latency work.

00:10:59.890 --> 00:11:02.220
But I am going to
come back to it later.

00:11:02.220 --> 00:11:04.800
It's just interesting to
notice that the hardware

00:11:04.800 --> 00:11:09.940
composition happened so
much earlier than the Vsync.

00:11:09.940 --> 00:11:12.110
OK, now let's take
a look at the game.

00:11:12.110 --> 00:11:15.940
That's the current game
that is currently live.

00:11:15.940 --> 00:11:20.490
If we looked at it, you
can see our game there

00:11:20.490 --> 00:11:23.010
with our open GLThread.

00:11:23.010 --> 00:11:26.700
And you see our frame that is
being drawn under all frames

00:11:26.700 --> 00:11:28.700
there.

00:11:28.700 --> 00:11:31.580
One thing that I
discovered is, at the top,

00:11:31.580 --> 00:11:36.460
you can see a thin line that
is either green or red there.

00:11:36.460 --> 00:11:38.650
Red is meaning that our
thread is sleeping and not

00:11:38.650 --> 00:11:39.910
doing any work.

00:11:39.910 --> 00:11:43.000
And green is meaning we are
actually doing some stuff.

00:11:43.000 --> 00:11:46.750
So you can see this
Android frame is actually

00:11:46.750 --> 00:11:52.420
in a sleep state for a long
while, like 6.5 milliseconds.

00:11:52.420 --> 00:11:56.760
And I was wondering
what's happening there.

00:11:56.760 --> 00:11:58.710
And what's happening
is that it's not

00:11:58.710 --> 00:12:01.680
able to draw because we are in
that state of triple buffering.

00:12:01.680 --> 00:12:04.318
So we cannot acquire
one more buffer.

00:12:04.318 --> 00:12:08.190
OK, enough talk about
the current state.

00:12:08.190 --> 00:12:13.180
Let's look at how it is after
we did some fixes and the frame

00:12:13.180 --> 00:12:15.150
facing.

00:12:15.150 --> 00:12:18.600
That's a trace that is taken
after we did some fixes.

00:12:18.600 --> 00:12:20.670
The first thing that is
interesting to notice

00:12:20.670 --> 00:12:26.470
is, from far away, if you
look at the SurfaceFlinger

00:12:26.470 --> 00:12:30.280
for the SurfaceView, there
is no more triple buffering.

00:12:30.280 --> 00:12:32.980
We are constantly in a
state of double buffering.

00:12:32.980 --> 00:12:34.630
Here we have one
buffer in the queue

00:12:34.630 --> 00:12:36.790
and then zero,
one and then zero.

00:12:36.790 --> 00:12:38.874
So we are constantly
double buffering.

00:12:41.840 --> 00:12:47.420
OK, as I was saying earlier,
that frame being consumed here

00:12:47.420 --> 00:12:50.870
is being displayed
at that Vsync.

00:12:50.870 --> 00:12:54.320
Now, let's take a look at
what are the inputs being

00:12:54.320 --> 00:12:57.500
used to draw that frame, because
that's really what matters here

00:12:57.500 --> 00:12:59.620
to reduce input latency.

00:12:59.620 --> 00:13:07.320
So let me highlight that moment
where we unqueued one buffer

00:13:07.320 --> 00:13:09.920
and looked down in the game.

00:13:09.920 --> 00:13:12.110
So in that trace, I did a
little bit of information

00:13:12.110 --> 00:13:14.180
about what's
happening in the game.

00:13:14.180 --> 00:13:18.900
So you can see that, at that
time, we are swapping buffer.

00:13:18.900 --> 00:13:22.470
That buffer being swapped
is being drawn there.

00:13:22.470 --> 00:13:24.580
And the logic of the
game is being executed

00:13:24.580 --> 00:13:27.230
in the game update here.

00:13:27.230 --> 00:13:30.220
The interesting bit is
if I keep zooming a bit,

00:13:30.220 --> 00:13:33.130
the game update here
is using the inputs

00:13:33.130 --> 00:13:36.890
that are delivered
at that point here.

00:13:36.890 --> 00:13:38.740
So between that moment--

00:13:41.962 --> 00:13:42.860
sorry.

00:13:42.860 --> 00:13:47.940
Between that moment when
the frame was being drawn,

00:13:47.940 --> 00:13:49.010
when it has been queued--

00:13:55.630 --> 00:13:56.520
sorry.

00:13:56.520 --> 00:13:59.130
OK, so it has been queued here.

00:13:59.130 --> 00:14:00.660
It has been dequeued there.

00:14:00.660 --> 00:14:03.030
It will be rendered
here on the screen.

00:14:03.030 --> 00:14:05.400
We are at about 32
milliseconds latency

00:14:05.400 --> 00:14:12.660
for the input, which is pretty
much the best I could find.

00:14:12.660 --> 00:14:15.030
If we look back at
the previous game

00:14:15.030 --> 00:14:18.810
and we try to look
at the same number--

00:14:18.810 --> 00:14:20.915
OK, here we have
triple buffering.

00:14:20.915 --> 00:14:22.290
So let's take a
look at this one.

00:14:27.690 --> 00:14:33.270
We have our Android
frame happening here,

00:14:33.270 --> 00:14:35.900
which is actually using
the input being delivered--

00:14:38.610 --> 00:14:41.880
the previous frame, which
happened around here.

00:14:41.880 --> 00:14:46.760
And then, if I look at the
queue, it's being dequeued.

00:14:50.290 --> 00:14:52.960
This buffer that is
unqueued there at the top

00:14:52.960 --> 00:14:54.630
is not the one being
dequeued there.

00:14:54.630 --> 00:14:57.610
It's the one being dequeued
at the next frame, which is

00:14:57.610 --> 00:15:00.020
actually being rendered here.

00:15:00.020 --> 00:15:02.590
So if I look at the
overall input latency,

00:15:02.590 --> 00:15:06.330
we were looking at
something around--

00:15:06.330 --> 00:15:08.910
one too many--

00:15:08.910 --> 00:15:11.170
47 milliseconds.

00:15:11.170 --> 00:15:13.290
So we dropped about
one frame of latency.

00:15:15.845 --> 00:15:18.220
Let's take a look at how it
looks in the game in the end,

00:15:18.220 --> 00:15:22.780
because, well, that's what
player experience is, right?

00:15:22.780 --> 00:15:24.810
I made a small video.

00:15:24.810 --> 00:15:26.950
I am not really good
at editing video.

00:15:26.950 --> 00:15:29.680
So it's not my primary skill.

00:15:29.680 --> 00:15:30.790
I did the best.

00:15:30.790 --> 00:15:33.442
So if you look very
carefully, it's

00:15:33.442 --> 00:15:34.650
really clear, obvious, right?

00:15:34.650 --> 00:15:35.770
No, joking.

00:15:35.770 --> 00:15:38.240
I have a frame by
frame thing happening.

00:15:38.240 --> 00:15:42.980
OK, so look on the left.

00:15:42.980 --> 00:15:45.220
Here, we have our
virtual joystick.

00:15:45.220 --> 00:15:49.940
And there, that
white circle is where

00:15:49.940 --> 00:15:52.900
the finger is, or pretty much--

00:15:52.900 --> 00:15:58.060
it's actually displaying where
Android thinks the finger is.

00:15:58.060 --> 00:16:01.780
So I am going to put my
mouse on that white circle.

00:16:01.780 --> 00:16:05.590
And I am going to move
forward by one frame.

00:16:05.590 --> 00:16:09.080
So you can see my
mouse is still not--

00:16:09.080 --> 00:16:11.420
and there is the
virtual joystick.

00:16:11.420 --> 00:16:15.560
If I move by one
frame more, now I

00:16:15.560 --> 00:16:17.870
have the virtual joystick
under the mouse, which

00:16:17.870 --> 00:16:23.060
means that I have two frame
latency between the user input

00:16:23.060 --> 00:16:26.130
and the game reacting to it.

00:16:26.130 --> 00:16:28.910
Now, if you look on the right--

00:16:28.910 --> 00:16:29.660
yeah.

00:16:29.660 --> 00:16:32.810
If you look here, for
example, you have the--

00:16:32.810 --> 00:16:34.490
that's after the fix.

00:16:34.490 --> 00:16:37.440
So you have the user
finger being here.

00:16:37.440 --> 00:16:41.805
And if I move by one
frame, the virtual joystick

00:16:41.805 --> 00:16:43.430
is on it, which means
we have one frame

00:16:43.430 --> 00:16:46.200
latency in the display
between the user input

00:16:46.200 --> 00:16:47.970
and the display on the screen.

00:16:47.970 --> 00:16:51.440
It's also interesting if I
move a little bit forward

00:16:51.440 --> 00:16:53.564
or backward in time, actually.

00:16:53.564 --> 00:16:55.630
Ah, sorry.

00:16:55.630 --> 00:17:00.070
If you look here, the
distance between the joystick

00:17:00.070 --> 00:17:02.170
and the finger is quite big.

00:17:02.170 --> 00:17:05.950
If you look at this one,
the distance is quite a lot

00:17:05.950 --> 00:17:07.146
shorter.

00:17:07.146 --> 00:17:08.010
Ah, sorry.

00:17:08.010 --> 00:17:10.150
Yeah, it's quite a
lot shorter, which

00:17:10.150 --> 00:17:14.650
means that that also translates
into the latency felt

00:17:14.650 --> 00:17:15.310
by the user.

00:17:18.180 --> 00:17:20.720
Yeah, that's a result
of the input latency

00:17:20.720 --> 00:17:24.160
fix, one frame less.

00:17:24.160 --> 00:17:28.192
OK, can we switch back
to the slide, please?

00:17:28.192 --> 00:17:30.988
Yeah.

00:17:30.988 --> 00:17:33.100
CHRIS FOLEY: Can we
hop on back to the uh--

00:17:33.100 --> 00:17:34.205
yeah, thank you.

00:17:34.205 --> 00:17:36.200
DAMIEN MABIN: Oh yeah,
so that's about it

00:17:36.200 --> 00:17:40.790
for my part on Systrace, on
the Dark Art of Systrace,

00:17:40.790 --> 00:17:42.960
on how to understand it.

00:17:42.960 --> 00:17:47.190
If you have any questions, I am
happy to chat after the talk.

00:17:47.190 --> 00:17:47.940
CHRIS FOLEY: Cool.

00:17:47.940 --> 00:17:51.530
DAMIEN MABIN: I am
handing it back to Chris.

00:17:51.530 --> 00:17:52.530
CHRISTOPHER FOLEY: Cool.

00:17:52.530 --> 00:17:53.762
DAMIEN MABIN: There you are.

00:17:53.762 --> 00:17:55.720
CHRISTOPHER FOLEY: Oh
yeah, actually Da-- here,

00:17:55.720 --> 00:17:56.428
I had that water.

00:17:56.428 --> 00:17:59.210
[LAUGHS]

00:17:59.210 --> 00:17:59.710
Cool.

00:17:59.710 --> 00:18:01.410
Thank you, Damien.

00:18:01.410 --> 00:18:02.380
[APPLAUSE]

00:18:02.380 --> 00:18:02.880
Yeah.

00:18:06.800 --> 00:18:09.000
Yeah, Systrace, it
can be a little bit

00:18:09.000 --> 00:18:10.030
frightening at first.

00:18:10.030 --> 00:18:12.780
But it's a really powerful
tool for really optimizing

00:18:12.780 --> 00:18:14.880
the performance of your game.

00:18:14.880 --> 00:18:16.470
So it's all available.

00:18:16.470 --> 00:18:18.060
I would encourage
looking into it

00:18:18.060 --> 00:18:19.110
if that's something
that you're really

00:18:19.110 --> 00:18:20.777
interested in an
really making your game

00:18:20.777 --> 00:18:23.430
run smoother and really better.

00:18:23.430 --> 00:18:26.580
So moving on, we're going
to move into something

00:18:26.580 --> 00:18:28.030
a little more high level.

00:18:28.030 --> 00:18:32.470
And this will be Instant
Game referral tracking.

00:18:32.470 --> 00:18:36.960
So let me first
talk a little bit

00:18:36.960 --> 00:18:40.770
about why you would want to
have Instant Games anyways.

00:18:40.770 --> 00:18:45.810
So the traditional game install
flow looks something like this.

00:18:45.810 --> 00:18:47.580
There's a user
acquisition event,

00:18:47.580 --> 00:18:50.640
like somebody clicks on an ad.

00:18:50.640 --> 00:18:51.510
They click on it.

00:18:51.510 --> 00:18:53.880
It takes them to the Play
Store, nice big banner

00:18:53.880 --> 00:18:55.680
up in the top, Install.

00:18:55.680 --> 00:18:56.520
And this is great.

00:18:56.520 --> 00:18:59.140
The player wants to
try and play your game.

00:18:59.140 --> 00:19:01.543
The idea is they try it,
they find it really exciting,

00:19:01.543 --> 00:19:02.460
and they want to play.

00:19:02.460 --> 00:19:05.710
Or they go into it
and play, right?

00:19:05.710 --> 00:19:07.000
But now they have to install.

00:19:07.000 --> 00:19:10.150
Now, that's actually a lot
of friction right there.

00:19:10.150 --> 00:19:12.880
You know, it could be up to
100 megabyte download there.

00:19:12.880 --> 00:19:14.770
And maybe they're not on Wi-Fi.

00:19:14.770 --> 00:19:16.540
Maybe they're on
mobile somewhere.

00:19:16.540 --> 00:19:18.880
And if you're a
game developer, I'm

00:19:18.880 --> 00:19:21.130
sure you all really know
that, really, the end

00:19:21.130 --> 00:19:25.090
result is that often
just getting an install

00:19:25.090 --> 00:19:26.170
can be the challenge.

00:19:26.170 --> 00:19:28.420
You know that once they play
the game they'll love it.

00:19:28.420 --> 00:19:30.560
But you can't even
get to that point.

00:19:30.560 --> 00:19:33.500
So this is where
Instant Games come in.

00:19:33.500 --> 00:19:36.880
So starting with your
user acquisition flow,

00:19:36.880 --> 00:19:39.320
imagine you instead click.

00:19:39.320 --> 00:19:41.440
And instead of having
to go to a store,

00:19:41.440 --> 00:19:44.200
it just immediately
goes to, well,

00:19:44.200 --> 00:19:48.160
this screen right here, which is
Google Play Instant, installing

00:19:48.160 --> 00:19:50.780
a game right there.

00:19:50.780 --> 00:19:53.300
And they have a demo
version of the game.

00:19:53.300 --> 00:19:56.220
This is an instant game that
they can play right away.

00:19:56.220 --> 00:19:57.140
There's no install.

00:19:57.140 --> 00:20:00.110
They're immediately into
the gameplay experience.

00:20:00.110 --> 00:20:03.800
And you can use this
moment to really sell

00:20:03.800 --> 00:20:05.750
your game to your player.

00:20:05.750 --> 00:20:08.390
And in fact, here on the top
here, there's a little button.

00:20:08.390 --> 00:20:09.348
It's hard to read here.

00:20:09.348 --> 00:20:10.850
But it says Install Now.

00:20:10.850 --> 00:20:15.530
And the instant game is
where you prompt the player

00:20:15.530 --> 00:20:17.060
to actually install the game.

00:20:17.060 --> 00:20:19.700
But this is after they've had
a chance to really experience

00:20:19.700 --> 00:20:21.482
it and really enjoy the game.

00:20:21.482 --> 00:20:22.940
And really, this
is why you've made

00:20:22.940 --> 00:20:24.710
the game in the first place.

00:20:24.710 --> 00:20:27.170
Once they actually decide
that they want to try it,

00:20:27.170 --> 00:20:29.040
then you do the install.

00:20:29.040 --> 00:20:30.560
Then you actually prompt them.

00:20:30.560 --> 00:20:32.390
The game begins to download.

00:20:32.390 --> 00:20:34.830
But it doesn't matter
so much at this point,

00:20:34.830 --> 00:20:37.070
because you've already
gotten the player involved,

00:20:37.070 --> 00:20:39.870
and they're already
really committed to it.

00:20:39.870 --> 00:20:42.350
Now, as I'm talking
about this, this

00:20:42.350 --> 00:20:45.920
is obviously about
optimizing user acquisition.

00:20:45.920 --> 00:20:48.890
And I'm sure that you all
know, if you've done any user

00:20:48.890 --> 00:20:52.700
acquisition, that a key part of
this is knowing your analytics,

00:20:52.700 --> 00:20:55.430
knowing your metrics, how
effective are your different ad

00:20:55.430 --> 00:20:58.670
campaigns, knowing where your
sources of those clicks are.

00:20:58.670 --> 00:21:02.450
But the issue is that if you
have an instant game just

00:21:02.450 --> 00:21:04.820
naively, the game
will not know where

00:21:04.820 --> 00:21:08.090
that source is, because
there's that intervening step.

00:21:08.090 --> 00:21:11.450
And so if you look at the
game from its point of view,

00:21:11.450 --> 00:21:13.860
it doesn't know
where the source is.

00:21:13.860 --> 00:21:17.550
However, there's
a way to fix this.

00:21:17.550 --> 00:21:21.600
And that is forwarding the
referral from the Instant Game.

00:21:21.600 --> 00:21:24.630
So as it turns out,
the Instant Game

00:21:24.630 --> 00:21:26.640
gets the same
referral information

00:21:26.640 --> 00:21:28.990
that a regular
game install would.

00:21:28.990 --> 00:21:32.580
So the problem or, really,
the issue is, at that point,

00:21:32.580 --> 00:21:34.350
you just have to
collect that data

00:21:34.350 --> 00:21:36.810
and somehow get that
to the full game.

00:21:36.810 --> 00:21:38.880
And this is how it's done.

00:21:38.880 --> 00:21:42.720
So you first collect
the referral data

00:21:42.720 --> 00:21:46.560
by adding this code to the
Instant Games onCreate.

00:21:46.560 --> 00:21:48.470
And you can see
we get the intent.

00:21:48.470 --> 00:21:50.400
We do a little
processing about it.

00:21:50.400 --> 00:21:55.140
Then at the bottom, you pull the
parameters out of the intent.

00:21:55.140 --> 00:21:58.320
And then here, they even
add an extra parameter

00:21:58.320 --> 00:22:03.630
onto that, which is from IG,
Instant Game, equals true.

00:22:03.630 --> 00:22:07.320
Then you then include
this referral data

00:22:07.320 --> 00:22:11.400
as an additional parameter
for showInstallPrompt,

00:22:11.400 --> 00:22:13.140
which is the part
in the Instant Game

00:22:13.140 --> 00:22:15.690
where you actually are prompting
the user, well, to obviously

00:22:15.690 --> 00:22:17.310
install the full game.

00:22:17.310 --> 00:22:21.100
And then the full game
will get those parameters

00:22:21.100 --> 00:22:24.030
and then can use those to send
those on and track your user

00:22:24.030 --> 00:22:26.452
acquisition referral
information.

00:22:26.452 --> 00:22:30.650
So this is how it
works in real life.

00:22:30.650 --> 00:22:33.470
So forwarding Instant
Game referral strings,

00:22:33.470 --> 00:22:35.380
let's say we have ad
campaign number two.

00:22:35.380 --> 00:22:37.180
And here I have it.

00:22:37.180 --> 00:22:42.070
So say somebody in Columbia here
clicks on an ad for your game.

00:22:42.070 --> 00:22:46.630
Now, the referral link will
look something like this.

00:22:46.630 --> 00:22:48.010
This is obviously a generic one.

00:22:48.010 --> 00:22:50.590
But there's your
link to the store.

00:22:50.590 --> 00:22:53.350
Now, at the bottom, you
have your referral source.

00:22:53.350 --> 00:22:54.880
And it's a little
bit URL encoded.

00:22:54.880 --> 00:22:58.630
But it says source will
equal the AdCampaign2.

00:22:58.630 --> 00:23:00.580
That's where the
source came from.

00:23:00.580 --> 00:23:03.520
And then down at the
bottom is launch=true,

00:23:03.520 --> 00:23:06.668
which tells the Instant Game
to immediately start installing

00:23:06.668 --> 00:23:08.710
and downloading the game,
which is what you want,

00:23:08.710 --> 00:23:12.480
lowers the amount of friction
for getting into the game.

00:23:12.480 --> 00:23:14.130
Now, in the Instant
Game, there's

00:23:14.130 --> 00:23:17.100
the code I just showed you
that pulls the parameter out.

00:23:17.100 --> 00:23:21.360
Then at the bottom, you
show the InstallPrompt.

00:23:21.360 --> 00:23:25.370
Now, the full game now
has the full information.

00:23:25.370 --> 00:23:28.140
It has the source, AdCampaign2.

00:23:28.140 --> 00:23:33.210
And there's even our additional
source which is fromIG=true.

00:23:33.210 --> 00:23:35.310
Now you have even
more information

00:23:35.310 --> 00:23:37.780
about your acquisition.

00:23:37.780 --> 00:23:40.450
And lastly then, of
course, you send that back

00:23:40.450 --> 00:23:42.400
to your own servers,
your own analytics.

00:23:42.400 --> 00:23:46.480
And this is how you can actually
see the full impact of your ad

00:23:46.480 --> 00:23:48.310
campaign and with Instant Games.

00:23:53.060 --> 00:23:56.260
So onto my last
topic today, which

00:23:56.260 --> 00:24:00.550
is talking about ensuring
the integrity of your game.

00:24:00.550 --> 00:24:03.970
So I'm sure you're all
aware, as game developers,

00:24:03.970 --> 00:24:05.860
that you want people
to play your game.

00:24:05.860 --> 00:24:06.770
And that's great.

00:24:06.770 --> 00:24:08.480
But when you have
a game out there,

00:24:08.480 --> 00:24:11.710
it's also going to
attract bad actors, people

00:24:11.710 --> 00:24:14.620
who want to cheat, people
who want to hack the game,

00:24:14.620 --> 00:24:17.560
maybe people who want to maybe
take advantage of other players

00:24:17.560 --> 00:24:20.070
or maybe hurt their experience.

00:24:20.070 --> 00:24:21.820
There's lots of different
areas out there.

00:24:21.820 --> 00:24:24.370
And these all come in from
different modes of attack,

00:24:24.370 --> 00:24:29.380
which are like modded
APKs, or pirated APKs,

00:24:29.380 --> 00:24:32.560
or emulators out there, which
are not bad in themselves,

00:24:32.560 --> 00:24:37.030
obviously, but can be used
in various attempts, too.

00:24:37.030 --> 00:24:40.630
You have rooted devices,
once again, not bad in itself

00:24:40.630 --> 00:24:45.370
but can be used to launch
various attacks onto the game,

00:24:45.370 --> 00:24:48.050
such as memory attacks.

00:24:48.050 --> 00:24:53.570
And so if you're thinking about,
how do I keep my game safe?

00:24:53.570 --> 00:24:55.430
How do I protect the integrity?

00:24:55.430 --> 00:24:58.310
How do I protect my player
base from having our ecosystem

00:24:58.310 --> 00:24:59.550
hacked in some way?

00:24:59.550 --> 00:25:02.100
And it really boils
down to two parts.

00:25:02.100 --> 00:25:04.850
First of all, can the
binary be trusted?

00:25:04.850 --> 00:25:08.420
In particular, did the
binary come from somewhere

00:25:08.420 --> 00:25:09.470
that I trust?

00:25:09.470 --> 00:25:11.540
Is it from a known source?

00:25:11.540 --> 00:25:15.110
And the second part is, can
the device itself be trusted?

00:25:15.110 --> 00:25:17.120
Because, obviously,
if you're just

00:25:17.120 --> 00:25:20.400
listening to the app itself, if
you an APK, and the APK says,

00:25:20.400 --> 00:25:22.460
hey, I'm great, I came
from a great place,

00:25:22.460 --> 00:25:24.815
but you don't own the
device, and the device

00:25:24.815 --> 00:25:26.690
might be hacked or
modified in some way, that

00:25:26.690 --> 00:25:27.800
could change that.

00:25:27.800 --> 00:25:31.470
So you want to make sure that
the device is OK as well.

00:25:31.470 --> 00:25:36.320
So for the first part,
can the binary be trusted,

00:25:36.320 --> 00:25:38.370
there is app licensing.

00:25:38.370 --> 00:25:42.920
And for the second part,
can the device be trusted,

00:25:42.920 --> 00:25:45.530
there's the SafetyNet
Attestation API.

00:25:45.530 --> 00:25:48.320
And these two
parts work together

00:25:48.320 --> 00:25:51.620
to help ensure the
integrity of your game.

00:25:51.620 --> 00:25:56.520
And let me talk a little
bit more about how this is.

00:25:56.520 --> 00:25:59.200
App licensing works like this.

00:25:59.200 --> 00:26:02.230
Say you have a game
and you want to know,

00:26:02.230 --> 00:26:06.340
did this game-- was this APK
downloaded from the Play Store?

00:26:06.340 --> 00:26:09.010
So the game at startup,
you're launching,

00:26:09.010 --> 00:26:11.670
and it's doing all its
setup and initialization.

00:26:11.670 --> 00:26:15.640
And at this point, it calls
the app licensing, API,

00:26:15.640 --> 00:26:19.780
checkAccess, which reaches out
to the license verification

00:26:19.780 --> 00:26:23.860
server for Play and says,
does the Google user here

00:26:23.860 --> 00:26:25.480
or does the Play user--

00:26:25.480 --> 00:26:30.070
have they ever downloaded
this game from the store?

00:26:30.070 --> 00:26:33.040
Assuming it says
yes, then it returns

00:26:33.040 --> 00:26:36.010
with a valid license, which
triggers the license checker

00:26:36.010 --> 00:26:37.250
callback.

00:26:37.250 --> 00:26:41.750
And the player is
allowed into the game.

00:26:41.750 --> 00:26:45.490
Likewise, suppose they
don't have a license.

00:26:45.490 --> 00:26:48.940
Suppose they haven't downloaded
the APK from Play Store.

00:26:48.940 --> 00:26:50.440
Maybe they side
loaded it somewhere.

00:26:50.440 --> 00:26:52.510
Maybe it was distributed
somewhere else.

00:26:52.510 --> 00:26:55.990
Then it returns with no license,
which comes back to the license

00:26:55.990 --> 00:26:56.800
checker callback.

00:26:56.800 --> 00:27:00.125
And you have a mechanism
of blocking-- keeping

00:27:00.125 --> 00:27:01.250
the player out of the game.

00:27:04.640 --> 00:27:08.300
The second thing is
SafetyNet integrity check.

00:27:08.300 --> 00:27:11.240
And this is a little
bit more complicated.

00:27:11.240 --> 00:27:14.760
As I said, you don't really want
to trust anything on the device

00:27:14.760 --> 00:27:16.760
if you're checking to
see if the device itself

00:27:16.760 --> 00:27:18.360
has been compromised.

00:27:18.360 --> 00:27:20.677
So this has to be
initialized from the backend.

00:27:20.677 --> 00:27:22.510
So in this case, here
we have "Brawl Stars."

00:27:22.510 --> 00:27:24.350
And there's Supercell backend.

00:27:24.350 --> 00:27:27.590
And that initializes--
initiates the check.

00:27:27.590 --> 00:27:32.600
It does that by sending a nonce,
a small, unique ID that you're

00:27:32.600 --> 00:27:35.300
going to associate
with this request

00:27:35.300 --> 00:27:37.405
all the way through
this process.

00:27:37.405 --> 00:27:40.190
And I'll get to the
why in a second.

00:27:40.190 --> 00:27:43.740
The backend sends a
nonce to the game.

00:27:43.740 --> 00:27:46.640
The game at this point
uses that nonce, adds it

00:27:46.640 --> 00:27:50.930
onto the API call, which goes
to the SafetyNet Attestation API

00:27:50.930 --> 00:27:54.320
on the device,
which then forwards

00:27:54.320 --> 00:27:59.090
that back onto the Google
Attestation API backend.

00:27:59.090 --> 00:28:03.980
Now, this backend has a lot
of different signals and ways

00:28:03.980 --> 00:28:07.580
of checking if the device
itself has been compromised

00:28:07.580 --> 00:28:10.940
or if it hasn't been certified,
if it is not certified,

00:28:10.940 --> 00:28:12.590
or if it is certified.

00:28:12.590 --> 00:28:14.510
And it uses all these
different signals

00:28:14.510 --> 00:28:16.970
to basically return back to you.

00:28:16.970 --> 00:28:21.770
It says, this device is good
or maybe it isn't so good.

00:28:21.770 --> 00:28:23.780
Whatever that response
is gets sent back

00:28:23.780 --> 00:28:26.060
to the SafetyNet
Attestation API,

00:28:26.060 --> 00:28:28.730
which then comes
back to the game

00:28:28.730 --> 00:28:32.530
itself forward or
back onto the backend.

00:28:32.530 --> 00:28:35.500
Now, the backend here
is going to then check

00:28:35.500 --> 00:28:38.620
to see whether or not this--
this is where you actually

00:28:38.620 --> 00:28:40.000
are checking the response here.

00:28:40.000 --> 00:28:43.910
Like I said, you don't want
to trust the device just yet.

00:28:43.910 --> 00:28:46.600
So if you have a
valid attestation

00:28:46.600 --> 00:28:48.160
and the nonce matches--

00:28:48.160 --> 00:28:49.930
now, the reason
you have that nonce

00:28:49.930 --> 00:28:52.300
is to protect against
replay attacks.

00:28:52.300 --> 00:28:54.670
Because there could be
a hack, for example,

00:28:54.670 --> 00:28:58.070
that takes a valid attestation
and responds back and says,

00:28:58.070 --> 00:29:00.220
hey, everything's good,
even though it isn't.

00:29:00.220 --> 00:29:02.258
However, they won't
have the corrected nonce

00:29:02.258 --> 00:29:03.550
that you've attached with that.

00:29:03.550 --> 00:29:06.370
And that's why you initiate
that from the backend.

00:29:06.370 --> 00:29:09.130
You also want to check a few
other things like timestamps,

00:29:09.130 --> 00:29:10.905
just in case something else is--

00:29:10.905 --> 00:29:13.030
there's a few other checks
that you put into there.

00:29:13.030 --> 00:29:16.460
But assuming
everything works out,

00:29:16.460 --> 00:29:19.520
says good, lets the
player into the game.

00:29:19.520 --> 00:29:23.800
So this is how SafetyNet
Integrity Check works.

00:29:23.800 --> 00:29:26.120
So how does this work
in the real life?

00:29:26.120 --> 00:29:27.870
And how can you use
this to try your game?

00:29:27.870 --> 00:29:30.880
So I have a couple of
interesting cases here.

00:29:30.880 --> 00:29:33.090
The first is from Rovio.

00:29:33.090 --> 00:29:35.910
Now, Rovio has a game
named "Angry Birds 2,"

00:29:35.910 --> 00:29:38.040
which maybe you've heard of.

00:29:38.040 --> 00:29:42.660
Now, obviously, "Angry Birds 2,"
a huge game, global, worldwide.

00:29:42.660 --> 00:29:46.080
And it also has a
global leaderboard.

00:29:46.080 --> 00:29:48.260
Now, if you're thinking
if it is a popular game

00:29:48.260 --> 00:29:50.760
and it has a leaderboard that
everyone in the world to see--

00:29:50.760 --> 00:29:54.660
wants to see, there are
going to be a lot of attacks

00:29:54.660 --> 00:29:55.530
on this leaderboard.

00:29:55.530 --> 00:29:57.863
Because a lot of people want
to cheat and get their name

00:29:57.863 --> 00:29:59.160
on the top of that leaderboard.

00:29:59.160 --> 00:30:02.850
So Rovio was seeing a
lot of attacks coming in.

00:30:02.850 --> 00:30:06.750
And there were two main ways
of attacking the leaderboard

00:30:06.750 --> 00:30:07.890
that they saw.

00:30:07.890 --> 00:30:12.120
The first was tampered APKs,
modified APKs somewhere

00:30:12.120 --> 00:30:13.560
that people were side loading.

00:30:13.560 --> 00:30:17.160
And the second one was a
memory attack, an access

00:30:17.160 --> 00:30:18.720
to the memory of the game.

00:30:18.720 --> 00:30:22.270
Now, this is only possible
on a rooted device.

00:30:22.270 --> 00:30:25.830
So this is a perfect
use case for SafetyNet,

00:30:25.830 --> 00:30:28.690
which is checking to see if the
device has been rooted or not.

00:30:28.690 --> 00:30:30.232
Because if it's been
rooted, then you

00:30:30.232 --> 00:30:33.330
can't really trust that
the device is really

00:30:33.330 --> 00:30:34.080
as it always was.

00:30:34.080 --> 00:30:36.510
Maybe there was a custom
ROM or something else.

00:30:36.510 --> 00:30:41.610
So Rovio implemented
SafetyNet Attestation API.

00:30:41.610 --> 00:30:46.760
And the results were
pretty good for them.

00:30:46.760 --> 00:30:49.090
What they saw was,
first of all, right off

00:30:49.090 --> 00:30:54.100
the top, 40% fewer hack
attempts on their leaderboard.

00:30:54.100 --> 00:30:57.260
I mean, if you think about
it, that's 40% fewer attacks

00:30:57.260 --> 00:30:58.670
you have to defend against.

00:30:58.670 --> 00:31:02.290
It's a much more safer
environment for their game.

00:31:02.290 --> 00:31:03.790
It's less that they
have to work on.

00:31:03.790 --> 00:31:04.900
Whoops, sorry.

00:31:04.900 --> 00:31:07.410
Clicked a little bit.

00:31:07.410 --> 00:31:09.783
It helps with their
resource management

00:31:09.783 --> 00:31:10.950
as far as managing the game.

00:31:10.950 --> 00:31:13.290
It's less effort for
protecting the game.

00:31:13.290 --> 00:31:15.360
And then second of
all, what they saw

00:31:15.360 --> 00:31:17.580
was there was a higher
degree of spenders

00:31:17.580 --> 00:31:18.930
in their top leaderboard.

00:31:18.930 --> 00:31:21.510
Which if you think
about, this makes sense.

00:31:21.510 --> 00:31:23.370
And this is really what
they wanted to see.

00:31:23.370 --> 00:31:24.810
Because you don't
want to see hackers

00:31:24.810 --> 00:31:25.840
in the top of the leaderboard.

00:31:25.840 --> 00:31:28.020
You don't want to see people
who are there who don't really

00:31:28.020 --> 00:31:28.770
care about the game.

00:31:28.770 --> 00:31:31.170
They just want to show off
like, hey, I'm great at this.

00:31:31.170 --> 00:31:33.390
Instead, the
leaderboard was actually

00:31:33.390 --> 00:31:36.630
showing real players, people
who were really committed

00:31:36.630 --> 00:31:38.123
and dedicated to the game.

00:31:38.123 --> 00:31:40.290
Those are the ones that you
would expect to actually

00:31:40.290 --> 00:31:41.220
be on the leaderboard.

00:31:41.220 --> 00:31:43.830
And that's actually
what Rovio got.

00:31:43.830 --> 00:31:45.852
So as a result, it
really helped the game.

00:31:45.852 --> 00:31:46.935
It helped their community.

00:31:46.935 --> 00:31:48.460
It helped their leaderboard.

00:31:48.460 --> 00:31:50.502
It helped the ecosystem
of their game.

00:31:50.502 --> 00:31:52.335
They were very, very
happy with the results.

00:31:55.000 --> 00:31:58.570
And finally, for the
last case I wanted

00:31:58.570 --> 00:32:03.130
to talk about today, which is
reducing beta leakage with app

00:32:03.130 --> 00:32:05.230
licensing and
SafetyNet together.

00:32:05.230 --> 00:32:10.490
Now, first of all,
what is beta leakage?

00:32:10.490 --> 00:32:12.460
So some people call it beta.

00:32:12.460 --> 00:32:14.470
Some call it a soft launch.

00:32:14.470 --> 00:32:17.200
But the idea is before
you do your full launch,

00:32:17.200 --> 00:32:20.140
before you give your game
out to the rest of world,

00:32:20.140 --> 00:32:23.380
you might want to try a limited
release, a soft launch where

00:32:23.380 --> 00:32:27.520
you have maybe a few territories
where people are trying out

00:32:27.520 --> 00:32:28.270
the game.

00:32:28.270 --> 00:32:29.830
You start getting
feedback on it.

00:32:29.830 --> 00:32:31.420
You start getting
some information

00:32:31.420 --> 00:32:33.307
about the resources
used by the game,

00:32:33.307 --> 00:32:35.890
maybe how many servers you need
for it, and so on, and kind of

00:32:35.890 --> 00:32:38.153
see if the game is actually
working like you think.

00:32:38.153 --> 00:32:39.320
So that's what your beta is.

00:32:39.320 --> 00:32:40.490
But you want to keep it limited.

00:32:40.490 --> 00:32:41.920
You don't want
everyone out there,

00:32:41.920 --> 00:32:43.720
because your game--
well, this isn't really

00:32:43.720 --> 00:32:46.000
ready for the full world.

00:32:46.000 --> 00:32:49.030
But beta leakage is when
that doesn't happen,

00:32:49.030 --> 00:32:51.280
where instead of having
a few territories playing

00:32:51.280 --> 00:32:53.170
the game, now you have
people from everywhere

00:32:53.170 --> 00:32:54.220
playing the game.

00:32:54.220 --> 00:32:56.920
And this can be really bad
for your game management,

00:32:56.920 --> 00:32:59.860
because now all of your
projections on how much

00:32:59.860 --> 00:33:02.690
server usage, or the
demographics of your users,

00:33:02.690 --> 00:33:06.220
or, say, the actions or the
behavior of your audience

00:33:06.220 --> 00:33:08.680
are going to be completely
out of whack from what you may

00:33:08.680 --> 00:33:10.840
have expected to begin with.

00:33:10.840 --> 00:33:15.200
And this is a real problem.

00:33:15.200 --> 00:33:18.710
Because especially for games
that are very, very, very

00:33:18.710 --> 00:33:21.620
popular or really highly
anticipated games,

00:33:21.620 --> 00:33:25.490
you get a lot of people who
might want to get that APK even

00:33:25.490 --> 00:33:27.440
if they're not in one
of those territories

00:33:27.440 --> 00:33:28.830
where they're allowed to.

00:33:28.830 --> 00:33:31.340
And in fact, one of our
partners that we worked with

00:33:31.340 --> 00:33:33.150
saw a real issue with this.

00:33:33.150 --> 00:33:36.260
So they saw in our past
Android soft launches

00:33:36.260 --> 00:33:42.565
that 90% of their beta users
came from non-beta countries.

00:33:42.565 --> 00:33:43.940
Because they're
able to see where

00:33:43.940 --> 00:33:45.500
these players were
playing normally.

00:33:45.500 --> 00:33:47.840
But in this case, now, when
they want to play the beta,

00:33:47.840 --> 00:33:50.360
suddenly they're able to
play even though they're not

00:33:50.360 --> 00:33:52.480
in that place?

00:33:52.480 --> 00:33:56.070
And the reason for this is that,
well, Android is really open.

00:33:56.070 --> 00:33:57.170
I mean, that's very cool.

00:33:57.170 --> 00:33:59.545
I mean, that's one of the best
things about the platform.

00:33:59.545 --> 00:34:03.410
And sharing APKs is also
quite straightforward.

00:34:03.410 --> 00:34:04.810
You can pull an APK.

00:34:04.810 --> 00:34:07.630
You can share it around,
distribute it to your friends,

00:34:07.630 --> 00:34:10.090
and so on, and maybe
on different forums.

00:34:10.090 --> 00:34:12.699
And so, really, the challenge
for the game developer

00:34:12.699 --> 00:34:14.469
who wants to keep
their beta limited

00:34:14.469 --> 00:34:17.949
is, how do you prevent your
soft launch from unintentionally

00:34:17.949 --> 00:34:20.630
becoming a global launch?

00:34:20.630 --> 00:34:25.520
And this is where app licensing
comes in and SafetyNet.

00:34:25.520 --> 00:34:28.580
So as I mentioned, sharing
outside of beta regions

00:34:28.580 --> 00:34:31.460
typically happens
via sharing APKs.

00:34:31.460 --> 00:34:34.418
Now, in this beta,
only the people

00:34:34.418 --> 00:34:35.960
that were in those
few beta countries

00:34:35.960 --> 00:34:39.239
could actually legitimately
download the APK

00:34:39.239 --> 00:34:41.090
from the Play Store.

00:34:41.090 --> 00:34:44.420
So if you had the APK and
you're not from a beta country,

00:34:44.420 --> 00:34:47.320
you would not have a
valid license for it.

00:34:47.320 --> 00:34:49.210
As a result, app
licensing, which

00:34:49.210 --> 00:34:52.455
ensures that that APK actually
came from the Play Store, well,

00:34:52.455 --> 00:34:54.080
that's the first
thing you want to use.

00:34:54.080 --> 00:34:55.900
And that is how you
can prevent people

00:34:55.900 --> 00:35:01.240
from playing the game in places
where you maybe didn't intend.

00:35:01.240 --> 00:35:04.240
Now, as I mentioned,
SafetyNet, of course,

00:35:04.240 --> 00:35:07.570
is needed to check
your device integrity.

00:35:07.570 --> 00:35:09.760
Make sure that you can
trust that app licensing

00:35:09.760 --> 00:35:11.500
to begin with.

00:35:11.500 --> 00:35:14.790
Now, what was the
result of this?

00:35:14.790 --> 00:35:16.850
Well, the developer
we worked with on this

00:35:16.850 --> 00:35:21.560
saw a huge reduction in the
number of non-beta users.

00:35:21.560 --> 00:35:25.730
They saw a 50% reduction in the
number of their beta players

00:35:25.730 --> 00:35:28.400
who came from
non-beta countries.

00:35:28.400 --> 00:35:31.505
And 50%, that's huge.

00:35:31.505 --> 00:35:32.880
The developer was
really, really,

00:35:32.880 --> 00:35:34.370
really happy about this.

00:35:34.370 --> 00:35:37.130
And for me, this was
actually the first time

00:35:37.130 --> 00:35:40.010
I'd seen a developer use this
for locking down their beta.

00:35:40.010 --> 00:35:42.260
And I think it's actually a
very, very interesting use

00:35:42.260 --> 00:35:42.930
case.

00:35:42.930 --> 00:35:44.190
So if you have a game
that's coming out

00:35:44.190 --> 00:35:45.800
and you're worried about
maybe keeping it only

00:35:45.800 --> 00:35:47.570
in a certain region, this is
something I would actually

00:35:47.570 --> 00:35:48.220
take a look at.

00:35:51.680 --> 00:35:55.310
So finally, just
kind of recover--

00:35:55.310 --> 00:35:58.190
talk again about
what I covered today.

00:35:58.190 --> 00:36:01.020
So first of all, we
talked about Systrace.

00:36:01.020 --> 00:36:03.210
And Damien was very
helpful on going

00:36:03.210 --> 00:36:06.030
through very in-depth on how
they use Systrace to help fix

00:36:06.030 --> 00:36:09.470
some of the frame pacing as
they saw in "Brawl Stars."

00:36:09.470 --> 00:36:11.180
Next, we talked
about Instant Game

00:36:11.180 --> 00:36:13.460
and how you can forward
your referral information

00:36:13.460 --> 00:36:15.500
from the instant
game to the full game

00:36:15.500 --> 00:36:20.480
to really take full advantage of
the increased user acquisition

00:36:20.480 --> 00:36:23.797
that Instant Games provides.

00:36:23.797 --> 00:36:25.380
And then lastly, we
went over a couple

00:36:25.380 --> 00:36:29.070
interesting use cases of using
app licensing and SafetyNet

00:36:29.070 --> 00:36:30.840
to help protect
your game and really

00:36:30.840 --> 00:36:33.518
protect your ecosystem
against bad actors that

00:36:33.518 --> 00:36:34.310
might be out there.

00:36:37.180 --> 00:36:39.750
So with that, I'd like
to conclude my talk.

00:36:39.750 --> 00:36:44.430
And first of all, I'd like to
give a huge thanks to Supercell

00:36:44.430 --> 00:36:46.770
and Rovio for allowing
me to discuss their games

00:36:46.770 --> 00:36:49.770
and use some of their images
to help spice up my talk.

00:36:49.770 --> 00:36:51.480
And I'd also like
to thank all of you

00:36:51.480 --> 00:36:53.580
for sitting through my
talk and listening to me.

00:36:53.580 --> 00:36:54.960
I hope it's been instructive.

00:36:54.960 --> 00:36:57.450
And I would
encourage you to look

00:36:57.450 --> 00:36:59.130
into these issues
on the Play Store

00:36:59.130 --> 00:37:01.657
or in the Android documentation
if you're interested.

00:37:01.657 --> 00:37:02.490
Thank you very much.

00:37:02.490 --> 00:37:05.840
[MUSIC PLAYING]

