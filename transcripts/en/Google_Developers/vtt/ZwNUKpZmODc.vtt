WEBVTT
Kind: captions
Language: en

00:00:07.133 --> 00:00:08.701
Kocher: All right,
Hello everyone.

00:00:08.701 --> 00:00:11.067
Welcome to App Engine
Nitty Gritty.

00:00:11.067 --> 00:00:14.367
Um, we put up one of those
Google Moderator things.

00:00:14.367 --> 00:00:16.267
So if you want to jump
over there 

00:00:16.267 --> 00:00:18.467
tinyurl.com/
AppEngineNittyGritty

00:00:18.467 --> 00:00:19.734
You're welcome
to submit questions

00:00:19.734 --> 00:00:21.634
and we'll take them
from the mikes as well.

00:00:21.634 --> 00:00:25.434
Um...as people
are trickling in here,

00:00:25.434 --> 00:00:26.901
probably people
are grabbing food.

00:00:26.901 --> 00:00:28.200
I'm just gonna tell you a bit

00:00:28.200 --> 00:00:30.033
about what we're
covering today.

00:00:30.033 --> 00:00:33.667
Um, one is that for folks who
went to Brett's session

00:00:33.667 --> 00:00:36.400
yesterday afternoon,
he had a session

00:00:36.400 --> 00:00:38.167
on scaling Apps on App Engine.

00:00:38.167 --> 00:00:39.901
There is gonna be no overlap
at all with that one.

00:00:39.901 --> 00:00:43.367
Um, we will be covering,
you know,

00:00:43.367 --> 00:00:46.167
also things about scalability,
but none of the same things.

00:00:46.167 --> 00:00:47.567
We definitely recommend

00:00:47.567 --> 00:00:49.567
his talk to us both if you
didn't catch it.

00:00:49.567 --> 00:00:52.934
Um, so we're gonna talk about
things that are unique

00:00:52.934 --> 00:00:54.567
about building an App Engine.

00:00:54.567 --> 00:00:57.567
How you can--you know,
when you're on a system

00:00:57.567 --> 00:00:59.367
where you expect to have
some errors,

00:00:59.367 --> 00:01:01.100
how you can build something
that's stable and reliable

00:01:01.100 --> 00:01:02.501
on top of that.

00:01:02.501 --> 00:01:05.133
Um, knowing that, you know,
some of those parts

00:01:05.133 --> 00:01:08.133
can and will at times fail.

00:01:08.133 --> 00:01:10.567
We'll also talk about some of
the lessons we learned

00:01:10.567 --> 00:01:12.968
and recommendations about how to
make your Apps scale well.

00:01:12.968 --> 00:01:15.834
And we'll also talk about
integrating external services.

00:01:15.834 --> 00:01:18.200
In our case
that was AmazonEC2.

00:01:18.200 --> 00:01:20.601
We'll talk about
why we did that,

00:01:20.601 --> 00:01:21.934
why you might want to do that.

00:01:21.934 --> 00:01:23.634
It could be
a different service.

00:01:23.634 --> 00:01:26.567
Uh, but just looking
at how you might have things

00:01:26.567 --> 00:01:28.400
that don't fit
on to App Engine that,

00:01:28.400 --> 00:01:33.167
you know, are important
to your App.

00:01:33.167 --> 00:01:35.133
We are from FrontSeat.org,

00:01:35.133 --> 00:01:37.834
which is a civic software
company up in Seattle.

00:01:37.834 --> 00:01:41.501
And we were founded around
the idea that software

00:01:41.501 --> 00:01:42.968
is getting cheaper
and cheaper to build.

00:01:42.968 --> 00:01:45.200
And because of that, we can
start applying software

00:01:45.200 --> 00:01:47.467
to, you know, civic issues.

00:01:47.467 --> 00:01:49.033
Things where, in the past

00:01:49.033 --> 00:01:50.801
it might have been
prohibitively expensive,

00:01:50.801 --> 00:01:52.267
but with the falling costs,

00:01:52.267 --> 00:01:55.000
there really are some new
opportunities out there.

00:01:55.000 --> 00:01:58.367
Um, I'm Jesse.
This is Dave and Josh.

00:01:58.367 --> 00:02:00.701
And I'm the lead developer
at Front Seat.

00:02:00.701 --> 00:02:02.567
These guys each run their own
consulting companies

00:02:02.567 --> 00:02:04.267
and have been working with us
for a long time.

00:02:04.267 --> 00:02:07.267
And they've been very involved
in all of our work

00:02:07.267 --> 00:02:09.701
with App Engine.

00:02:09.701 --> 00:02:11.167
Uh, I'm going to give you
a couple examples

00:02:11.167 --> 00:02:12.834
of the kinds of things
I'm talking about

00:02:12.834 --> 00:02:14.734
with Civic Software before
we dive in.

00:02:14.734 --> 00:02:18.734
Uh, this is a site we did just
after the election last fall.

00:02:18.734 --> 00:02:21.067
Where Obama had said,

00:02:21.067 --> 00:02:23.567
"I want to appoint
a Chief Technical Officer

00:02:23.567 --> 00:02:24.767
for the country,"

00:02:24.767 --> 00:02:26.367
but nobody had defined
what that role was.

00:02:26.367 --> 00:02:29.234
And so we put up a site
just really quickly.

00:02:29.234 --> 00:02:31.367
It took us about a day
to launch this.

00:02:31.367 --> 00:02:34.801
And let people submit,
discuss and vote on ideas

00:02:34.801 --> 00:02:36.567
for what that position
should be about.

00:02:36.567 --> 00:02:38.968
What the priorities for that
position should be.

00:02:38.968 --> 00:02:41.801
So you can see that the top
result here

00:02:41.801 --> 00:02:43.734
was about the combination

00:02:43.734 --> 00:02:47.834
of net neutrality
and accessibility .

00:02:47.834 --> 00:02:50.467
Uh, earlier last summer
we did a site

00:02:50.467 --> 00:02:53.434
where students
who went to school in a state

00:02:53.434 --> 00:02:55.300
other than their home state
could go and say,

00:02:55.300 --> 00:02:56.634
you know,
"I'm from this state.

00:02:56.634 --> 00:02:58.100
I'm at school
in this other state."

00:02:58.100 --> 00:03:00.734
And the website will tell them
where your presidential vote

00:03:00.734 --> 00:03:02.000
will count more.

00:03:02.000 --> 00:03:03.400
And then it would help them
register to vote

00:03:03.400 --> 00:03:06.501
and get an absentee ballot.

00:03:06.501 --> 00:03:08.667
So we have
a whole bunch of projects.

00:03:08.667 --> 00:03:10.067
I'm gonna skip over these
other ones.

00:03:10.067 --> 00:03:12.000
If you want to know about
the kind of stuff we are doing,

00:03:12.000 --> 00:03:14.634
you can check out frontseat.org.
It links to all these things.

00:03:14.634 --> 00:03:17.901
Um, everything from
utility bill designs

00:03:17.901 --> 00:03:20.434
that promote conservation

00:03:20.434 --> 00:03:24.501
to satire about
the payday loan industry.

00:03:24.501 --> 00:03:25.534
The project we're gonna
talk about today

00:03:25.534 --> 00:03:27.467
is called Walk Score.

00:03:27.467 --> 00:03:30.200
And, uh--

00:03:30.200 --> 00:03:31.934
before we dive into that,
you know,

00:03:31.934 --> 00:03:35.067
the context of all this is
that we're a very small team,

00:03:35.067 --> 00:03:36.934
we have a lot of projects,
and we need to minimize

00:03:36.934 --> 00:03:38.634
our overhead
and our maintenance.

00:03:38.634 --> 00:03:41.701
And that's the context
for our use of App Engine.

00:03:41.701 --> 00:03:46.334
So we wanted to bring a civic
software service to scale,

00:03:46.334 --> 00:03:48.701
on a budget
with a very small staff.

00:03:48.701 --> 00:03:51.133
You know, no sysadmin staff
to sit around

00:03:51.133 --> 00:03:54.234
and monitor it all the time.

00:03:54.234 --> 00:03:57.367
Um--so on to Walk Score.

00:03:57.367 --> 00:04:00.367
Walk Score is a web site
that lets you measure

00:04:00.367 --> 00:04:02.734
the walkability
of any neighborhood

00:04:02.734 --> 00:04:04.234
in terms
of access to amenities.

00:04:04.234 --> 00:04:07.767
So it's, how much can you do
without getting in to a car?

00:04:07.767 --> 00:04:11.634
Um, it's--

00:04:11.634 --> 00:04:13.033
I'm gonna give you
a demo really quickly

00:04:13.033 --> 00:04:16.968
of the original
Walk Score website.

00:04:16.968 --> 00:04:21.767
Uh, it started out
with a Google Maps smash up.

00:04:21.767 --> 00:04:24.000
So I'm gonna search here.
You can search for any address.

00:04:24.000 --> 00:04:26.167
I'm going to search
for the Moscone Center address

00:04:26.167 --> 00:04:30.000
so you can see
if our network cooperates.

00:04:30.000 --> 00:04:33.501
Um...

00:04:33.501 --> 00:04:35.534
My monitor also seems
to be a little bit confused 

00:04:35.534 --> 00:04:36.701
about what size it is.

00:04:36.701 --> 00:04:38.767
So sorry that
it's off-center here.

00:04:38.767 --> 00:04:40.601
So as these searches complete,

00:04:40.601 --> 00:04:42.868
it pulls up a bunch of amenities
in the neighborhood

00:04:42.868 --> 00:04:46.033
and it calculates the score
up here at the top.

00:04:46.033 --> 00:04:48.234
From 0 to 100 of how walkable
that neighborhood is.

00:04:48.234 --> 00:04:50.200
So there's a ton of stuff
around here.

00:04:50.200 --> 00:04:51.934
You can do a lot of things
without getting in a car.

00:04:51.934 --> 00:04:54.601
So you get a very high score.
98 out of 100.

00:04:54.601 --> 00:04:56.000
And then on the side here
you can see things

00:04:56.000 --> 00:04:59.701
like the restaurants,
the coffee shops.

00:04:59.701 --> 00:05:02.501
Um, you've got parks
and schools.

00:05:02.501 --> 00:05:04.100
All these different amenities.

00:05:04.100 --> 00:05:07.934
And, we've got
integration with Yelp.

00:05:07.934 --> 00:05:11.667
So, if you look
at the Yorba Buena,

00:05:11.667 --> 00:05:13.334
it'll search for reviews.

00:05:13.334 --> 00:05:17.133
And it pops up
a little picture there.

00:05:17.133 --> 00:05:18.434
You can click through
the reviews.

00:05:18.434 --> 00:05:19.667
And we also have Street View.

00:05:19.667 --> 00:05:22.934
So, maybe we wanted to go
to coffee and see,

00:05:22.934 --> 00:05:24.501
you know,
what's the closest thing

00:05:24.501 --> 00:05:25.901
that's not Starbucks.

00:05:25.901 --> 00:05:28.667
Um, jump over here.

00:05:28.667 --> 00:05:32.868
And...that's it.

00:05:32.868 --> 00:05:36.100
Yeah.
There's that coffee shop.

00:05:36.100 --> 00:05:39.501
Um...

00:05:39.501 --> 00:05:42.601
So this walk score indicates,
you know,

00:05:42.601 --> 00:05:44.067
how much can you do
without getting in to a car,

00:05:44.067 --> 00:05:45.300
and it's also an indicator

00:05:45.300 --> 00:05:46.834
of the vibrancy
of the neighborhood.

00:05:46.834 --> 00:05:49.267
And this part
that I just showed you,

00:05:49.267 --> 00:05:51.100
this is great for checking out
a specific address.

00:05:51.100 --> 00:05:52.834
But what if you want to
get to know a city

00:05:52.834 --> 00:05:54.801
on a larger scale.

00:05:54.801 --> 00:05:57.000
We did some work where
we generated these heat maps

00:05:57.000 --> 00:05:59.968
that can show you in green
the most walkable areas

00:05:59.968 --> 00:06:02.801
and fading out to red,
the least walkable.

00:06:02.801 --> 00:06:04.167
So this is the map
for Seattle.

00:06:04.167 --> 00:06:05.501
You can see,

00:06:05.501 --> 00:06:07.400
those who know the city
a little bit,

00:06:07.400 --> 00:06:10.968
downtown, Capitol Hill,
University District.

00:06:10.968 --> 00:06:12.133
And then you have
these little pockets.

00:06:12.133 --> 00:06:13.567
These little neighborhoods
that are

00:06:13.567 --> 00:06:15.267
down in Columbia City
and West Seattle

00:06:15.267 --> 00:06:17.033
where you have some kind of
little neighborhood.

00:06:17.033 --> 00:06:19.501
And this is a great way
to get a quick insight

00:06:19.501 --> 00:06:21.367
in to the shape of a city
in terms of,

00:06:21.367 --> 00:06:23.534
you know, where people actually
hang out on the streets

00:06:23.534 --> 00:06:25.934
and where the--
where the street life is.

00:06:25.934 --> 00:06:29.868
So why are we doing all this
work about walkability?

00:06:29.868 --> 00:06:31.434
Well, it turns out
the walkability encapsulates

00:06:31.434 --> 00:06:35.367
a whole bunch of great things
into one concept

00:06:35.367 --> 00:06:37.300
that's very easy for people
to understand.

00:06:45.834 --> 00:06:48.234
So a few of those benefits
very quickly.

00:06:48.234 --> 00:06:50.534
Climate--If people walk more
they drive less,

00:06:50.534 --> 00:06:52.334
they emit less
greenhouse gases.

00:06:52.334 --> 00:06:53.667
Health.

00:06:53.667 --> 00:06:55.300
People way about seven pounds
on average--

00:06:55.300 --> 00:06:59.133
seven pounds less on average
in walkable neighborhoods.

00:06:59.133 --> 00:07:01.167
These neighborhoods tend to have
strong social capital,

00:07:01.167 --> 00:07:04.968
good transit options,
very few auto-related deaths.

00:07:04.968 --> 00:07:06.767
Also a lot
of economic benefits.

00:07:06.767 --> 00:07:09.934
home values tend to be higher
or appreciate faster.

00:07:09.934 --> 00:07:12.701
Or in this climate,
fall more slowly.

00:07:12.701 --> 00:07:14.767
[chuckles]

00:07:14.767 --> 00:07:16.934
And transportation costs
are a big part.

00:07:16.934 --> 00:07:18.701
They're about 18%
of household income.

00:07:18.701 --> 00:07:20.601
Much less
in walkable neighborhoods.

00:07:20.601 --> 00:07:22.567
And they tend to have very
strong local economies

00:07:22.567 --> 00:07:24.667
where local businesses
can thrive.

00:07:24.667 --> 00:07:26.601
It's also something
that people rank very highly

00:07:26.601 --> 00:07:28.868
in terms of choosing
where to live.

00:07:28.868 --> 00:07:31.467
They say walkability
or access to amenities

00:07:31.467 --> 00:07:32.868
is one of the top two things.

00:07:32.868 --> 00:07:36.267
Higher than property taxes
or schools.

00:07:36.267 --> 00:07:38.300
So what we try to do
is create demand

00:07:38.300 --> 00:07:39.734
for walkable neighborhoods

00:07:39.734 --> 00:07:41.534
by educating people
about the benefits,

00:07:41.534 --> 00:07:44.267
and then fill that demand
by providing transparency

00:07:44.267 --> 00:07:45.934
about the walkability
of every property.

00:07:45.934 --> 00:07:49.501
And we want to, you know, help
people find these places

00:07:49.501 --> 00:07:51.801
and also create more of them.

00:07:51.801 --> 00:07:54.667
So walkability matters most,

00:07:54.667 --> 00:07:57.167
and this kind
of transparency matters most,

00:07:57.167 --> 00:07:58.868
when people are choosing
a place to live.

00:07:58.868 --> 00:08:01.968
And that means we need to be
on real estate sites.

00:08:01.968 --> 00:08:05.067
So the first thing we did
for that is

00:08:05.067 --> 00:08:09.634
built this widget that is
very easy for people to embed.

00:08:09.634 --> 00:08:11.067
And this is basically
a miniature version

00:08:11.067 --> 00:08:12.501
of what I showed you before.

00:08:12.501 --> 00:08:14.934
It's uh, that rectangle part

00:08:14.934 --> 00:08:17.501
is what can be embedded
into a real estate site.

00:08:17.501 --> 00:08:18.868
And we've seen
a lot of adoption with that.

00:08:18.868 --> 00:08:23.100
We've got about twice as much
traffic to that tile

00:08:23.100 --> 00:08:25.267
as we do to our website.

00:08:25.267 --> 00:08:26.767
So it's been
very successful.

00:08:26.767 --> 00:08:28.567
But they often put us down

00:08:28.567 --> 00:08:30.634
in the kind of "about
the neighborhood" section,

00:08:30.634 --> 00:08:32.367
and it's not really
the ideal placement.

00:08:32.367 --> 00:08:36.000
So what we really want
is this.

00:08:36.000 --> 00:08:37.968
We want to be right
in the primary information

00:08:37.968 --> 00:08:39.200
about a property.

00:08:39.200 --> 00:08:41.167
3 bedrooms, 3 bathrooms,
Walk Score: 86

00:08:41.167 --> 00:08:43.868
and we want
"Search by Walk Score."

00:08:43.868 --> 00:08:46.133
And so to do those things,
we need to build an API

00:08:46.133 --> 00:08:47.767
that gives the scores back

00:08:47.767 --> 00:08:49.534
to a real estate site
very quickly

00:08:49.534 --> 00:08:51.267
so they can just pass us
latitude, longitude

00:08:51.267 --> 00:08:53.200
and we give them a score.

00:08:53.200 --> 00:08:55.534
They don't want to wait for all
those local searches to happen

00:08:55.534 --> 00:08:57.667
and all the restaurants to load
and all that.

00:08:57.667 --> 00:08:59.834
Uh...
so we're gonna jump

00:08:59.834 --> 00:09:01.167
into the tech stuff now. 

00:09:01.167 --> 00:09:03.400
And, we'll talk
a little bit about

00:09:03.400 --> 00:09:05.534
why we brought EC2
into picture.

00:09:05.534 --> 00:09:07.968
Why we didn't just do everything
that we built for the API

00:09:07.968 --> 00:09:09.334
on App Engine.

00:09:09.334 --> 00:09:11.634
And we'll talk a little bit
about, uh, some guidance

00:09:11.634 --> 00:09:12.968
on making Apps scale.

00:09:12.968 --> 00:09:15.133
And some issues that
we ran into and thoughts

00:09:15.133 --> 00:09:17.901
about working
in the App Engine environment.

00:09:17.901 --> 00:09:20.434
I'm gonna hand it over
to Josh to take us in.

00:09:20.434 --> 00:09:22.934
Livni: Thanks, Jesse.

00:09:22.934 --> 00:09:25.234
All right,
so when we first

00:09:25.234 --> 00:09:26.534
were talking about the API,

00:09:26.534 --> 00:09:27.868
this is pretty much

00:09:27.868 --> 00:09:30.968
our ideal workflow
for the entire API.

00:09:30.968 --> 00:09:34.300
All we really want to do
is have a request come in--

00:09:34.300 --> 00:09:35.901
latitude, longitude,
location.

00:09:35.901 --> 00:09:38.000
It goes through this magic box.

00:09:38.000 --> 00:09:39.067
It spits out a score response.

00:09:39.067 --> 00:09:40.467
That--that's pretty much it.

00:09:40.467 --> 00:09:42.267
And, of course, things get

00:09:42.267 --> 00:09:43.734
a little bit more
complicated than that.

00:09:43.734 --> 00:09:45.267
But before we get
to the complications,

00:09:45.267 --> 00:09:46.501
we had to figure out where
we're gonna host this.

00:09:46.501 --> 00:09:47.801
It's pretty straight forward.

00:09:47.801 --> 00:09:49.634
We could've run
our own servers.

00:09:49.634 --> 00:09:50.767
And so
when we were considering

00:09:50.767 --> 00:09:52.667
where to put it,
these were some of the--

00:09:52.667 --> 00:09:54.968
These are unfortunately just
the negative considerations

00:09:54.968 --> 00:09:56.667
at first glance of App Engine.

00:09:56.667 --> 00:09:57.767
But some of the things
we thought about

00:09:57.767 --> 00:09:59.100
were vendor lock-in.

00:09:59.100 --> 00:10:00.534
If we write code
for App Engine

00:10:00.534 --> 00:10:03.968
are going to be able to, uh--
is it portable a little bit?

00:10:03.968 --> 00:10:05.334
Because it's similar
to Django,

00:10:05.334 --> 00:10:07.267
but we're going to have to
rewrite some things

00:10:07.267 --> 00:10:08.734
in case we had to move.

00:10:08.734 --> 00:10:10.667
The cost, when we started
this and launched it

00:10:10.667 --> 00:10:12.501
there was
no pricing announced.

00:10:12.501 --> 00:10:14.501
So we didn't know what
we were in for.

00:10:14.501 --> 00:10:17.634
We assumed here it would be,
you now, a competitive cost

00:10:17.634 --> 00:10:19.167
to host on App Engine.

00:10:19.167 --> 00:10:20.767
And, it's a BETA product.

00:10:20.767 --> 00:10:22.367
So, we didn't know.

00:10:22.367 --> 00:10:24.734
Is it going to potentially go
down for six to eight hours,

00:10:24.734 --> 00:10:25.968
make us look bad?

00:10:25.968 --> 00:10:27.567
Are we gonna have
various other problems?

00:10:27.567 --> 00:10:29.100
And we decided
after all of this

00:10:29.100 --> 00:10:31.000
uh, you know,
that Google engineers

00:10:31.000 --> 00:10:32.567
probably are gonna keep
things up better

00:10:32.567 --> 00:10:34.667
than we would
with a series of EC2

00:10:34.667 --> 00:10:36.100
or other virtual machines.

00:10:36.100 --> 00:10:37.534
Cost would be good.

00:10:37.534 --> 00:10:38.634
And we weren't super worried

00:10:38.634 --> 00:10:40.100
about the portability
of the code.

00:10:40.100 --> 00:10:42.167
So we went with App Engine.

00:10:42.167 --> 00:10:44.434
And the next step then
is to figure out

00:10:44.434 --> 00:10:47.234
what I considered kind of that
core functionality

00:10:47.234 --> 00:10:48.767
and the core functionality is
just this.

00:10:48.767 --> 00:10:50.400
This is really what we need.

00:10:50.400 --> 00:10:53.601
Ability to return responses
really fast.

00:10:53.601 --> 00:10:57.267
So the criteria for us
is always, um,

00:10:57.267 --> 00:10:59.067
let's go ahead and separate out
this core functionality

00:10:59.067 --> 00:11:00.501
from these other pieces.

00:11:00.501 --> 00:11:01.968
And I'm gonna show you
some of these other pieces

00:11:01.968 --> 00:11:03.901
that we considered
secondary functionality.

00:11:03.901 --> 00:11:06.200
Do we put the secondary
functionality on App Engine

00:11:06.200 --> 00:11:08.234
where it might conflict
potentially?

00:11:08.234 --> 00:11:11.400
Or cause of problems
are core functionality

00:11:11.400 --> 00:11:13.234
of returning responses
would fail.

00:11:13.234 --> 00:11:14.434
Should we put it
somewhere else?

00:11:14.434 --> 00:11:16.434
How do we integrate
these other pieces?

00:11:16.434 --> 00:11:18.767
I'm gonna spend
a little time just talking

00:11:18.767 --> 00:11:20.434
about some of these
secondary pieces

00:11:20.434 --> 00:11:22.601
that we decided
not to put on App Engine

00:11:22.601 --> 00:11:24.000
and some that we did.

00:11:24.000 --> 00:11:26.200
So App Engine, of course,
is really really good

00:11:26.200 --> 00:11:27.901
for simple operations.

00:11:27.901 --> 00:11:30.033
Request comes in,
does something basic

00:11:30.033 --> 00:11:31.400
such as look at the score,
return it.

00:11:31.400 --> 00:11:33.267
Not so good
for certain other things

00:11:33.267 --> 00:11:35.434
that it's just maybe not
designed for.

00:11:35.434 --> 00:11:37.434
Some of these things Jesse
mentioned,

00:11:37.434 --> 00:11:39.033
such as, the rankings.

00:11:39.033 --> 00:11:41.400
We have a fairly
complex procedure

00:11:41.400 --> 00:11:42.834
to figure out the rankings.

00:11:42.834 --> 00:11:44.901
It's not just counting out
points in the polygon

00:11:44.901 --> 00:11:46.734
for the different neighborhoods
in the cities.

00:11:46.734 --> 00:11:48.934
We bring in all kinds of
demographic data

00:11:48.934 --> 00:11:51.868
and weight by population
for each Walk Score.

00:11:51.868 --> 00:11:54.133
And App Engine's
not really set up

00:11:54.133 --> 00:11:57.033
for that kind of
geo-capabilities.

00:11:57.033 --> 00:11:59.767
Some folks I know have done
some backend work with this.

00:11:59.767 --> 00:12:03.501
But we do all offloaded
on a PostGIS database.

00:12:03.501 --> 00:12:05.100
And so that's offline.

00:12:05.100 --> 00:12:07.467
The other is, what if we just
want to look at the API usage.

00:12:07.467 --> 00:12:09.968
Who's using stuff in a day,
or a week, or a month.

00:12:09.968 --> 00:12:11.501
And where are
the queries coming in?

00:12:11.501 --> 00:12:14.767
So this is Seattle API usage
over a given time.

00:12:14.767 --> 00:12:16.501
And we want to know
a little bit--

00:12:16.501 --> 00:12:20.167
Are people coming in and doing
a--kind of, a survey

00:12:20.167 --> 00:12:22.667
or an academic study
where they are going to request

00:12:22.667 --> 00:12:24.834
a couple 100,000 points
in a specific area?

00:12:24.834 --> 00:12:27.467
Is it people just looking at
houses all over the place

00:12:27.467 --> 00:12:28.834
and when?

00:12:28.834 --> 00:12:32.367
And this helps us decide
where to pre-calculate points.

00:12:32.367 --> 00:12:34.968
We want to make sure we can
respond really fast to places.

00:12:34.968 --> 00:12:37.701
So we seed the API
with some obvious things.

00:12:37.701 --> 00:12:41.300
Such as all of the sort of,
current places or cities.

00:12:41.300 --> 00:12:42.634
Maybe the top 1,000 cities

00:12:42.634 --> 00:12:45.968
will score all of the possible
Walk Scores there.

00:12:45.968 --> 00:12:47.734
But where else
could we go next?

00:12:47.734 --> 00:12:50.534
Uh, by looking at the usage,
we could see things like,

00:12:50.534 --> 00:12:52.734
oh, people query for houses

00:12:52.734 --> 00:12:55.400
mostly within two miles
of a city center.

00:12:55.400 --> 00:12:56.834
And also when we're doing
the rankings,

00:12:56.834 --> 00:12:58.701
are we going to rank
over urban areas?

00:12:58.701 --> 00:13:00.400
Are we gonna rank over
the statistical

00:13:00.400 --> 00:13:02.601
metropolitan stuff
from the census?

00:13:02.601 --> 00:13:03.634
So we do this offline

00:13:03.634 --> 00:13:07.167
and then precede
the cache offline

00:13:07.167 --> 00:13:09.434
with places of interest.

00:13:09.434 --> 00:13:10.834
And all this
pre-calculation stuff

00:13:10.834 --> 00:13:12.234
brings in a complication

00:13:12.234 --> 00:13:13.634
to that really, really
simple work flow,

00:13:13.634 --> 00:13:15.734
which is we have
to actually calculate the score

00:13:15.734 --> 00:13:17.100
to give it out.

00:13:17.100 --> 00:13:20.734
And so the API gets
a little more complicated

00:13:20.734 --> 00:13:22.467
if we don't have a score.

00:13:22.467 --> 00:13:24.934
We return saying,
"We don't have a score."

00:13:24.934 --> 00:13:27.467
Then we have to go
do something about that.

00:13:27.467 --> 00:13:28.868
And to just explain
a little bit

00:13:28.868 --> 00:13:32.934
why we decided to offload
the scoring portion

00:13:32.934 --> 00:13:38.334
outside of App Engine,
I'll hand it over to Dave.

00:13:38.334 --> 00:13:40.767
Peck: Okay so, Josh showed us
a number of reasons

00:13:40.767 --> 00:13:43.200
that we couldn't strictly
build the Walk Score API

00:13:43.200 --> 00:13:44.934
on top of App Engine.

00:13:44.934 --> 00:13:47.000
And I'm gonna talk through
sort of the central reason

00:13:47.000 --> 00:13:49.434
that we had to make use
of Amazon EC2.

00:13:49.434 --> 00:13:51.234
And that's
that as Josh hinted at,

00:13:51.234 --> 00:13:53.434
that Walk Score calculation
takes time.

00:13:53.434 --> 00:13:56.801
Now calculating the Walk Score
is not CPU intensive,

00:13:56.801 --> 00:13:58.901
but it is rather IO intensive.

00:13:58.901 --> 00:14:01.934
At a minimum, a Walk Score
requires us to make

00:14:01.934 --> 00:14:04.567
17 URL fetches
to Google Local Search

00:14:04.567 --> 00:14:06.534
and potentially talk
to other services.

00:14:06.534 --> 00:14:09.400
Census services,
Geocoding, et cetera.

00:14:09.400 --> 00:14:10.734
Now if you're
an individual user

00:14:10.734 --> 00:14:13.234
and you go to our website
and type in an address,

00:14:13.234 --> 00:14:14.968
your browser
and our java script

00:14:14.968 --> 00:14:16.734
will do most of the work
for you.

00:14:16.734 --> 00:14:18.000
But if you're
a real estate company,

00:14:18.000 --> 00:14:19.934
what you really want is
programmatic access

00:14:19.934 --> 00:14:21.234
and you want us to do the work

00:14:21.234 --> 00:14:23.467
of calculating the Walk Score
on your behalf.

00:14:23.467 --> 00:14:25.167
And so that's why we built
this API.

00:14:25.167 --> 00:14:27.334
So from a customer's
perspective,

00:14:27.334 --> 00:14:29.267
the request-response cycle
as Josh mentioned is,

00:14:29.267 --> 00:14:31.367
give us the latitude
and longitude,

00:14:31.367 --> 00:14:33.934
get back a score
if we've already calculated it.

00:14:33.934 --> 00:14:35.400
Otherwise, queue it up.

00:14:35.400 --> 00:14:36.868
And, we've actually built

00:14:36.868 --> 00:14:38.834
a reliable message
queue abstraction

00:14:38.834 --> 00:14:41.133
on top of the App Engine
datastore,

00:14:41.133 --> 00:14:44.100
um, to hold on to
the latitudes and longitudes

00:14:44.100 --> 00:14:45.934
that we haven't
yet calculated.

00:14:45.934 --> 00:14:47.501
Of course, at some point
we have to turn around

00:14:47.501 --> 00:14:49.334
and actually service
that queue.

00:14:49.334 --> 00:14:51.100
And so we looked at
a few options when we were

00:14:51.100 --> 00:14:52.834
building our API.

00:14:52.834 --> 00:14:55.901
The first option we looked at
was App Engine cron jobs.

00:14:55.901 --> 00:14:59.167
Um, and as you know,
App Engine cron jobs

00:14:59.167 --> 00:15:02.367
allow you to regularly ping
an App Engine URL handler.

00:15:02.367 --> 00:15:04.200
Um, that URL handler
is subject

00:15:04.200 --> 00:15:07.701
to many of the same restrictions
that standard URL handlers

00:15:07.701 --> 00:15:09.767
are subject to on App Engine.

00:15:09.767 --> 00:15:12.667
So in our case,
making 17 URL fetches

00:15:12.667 --> 00:15:14.601
is probably
not going to happen

00:15:14.601 --> 00:15:16.901
in the time frame
that App Engine

00:15:16.901 --> 00:15:19.033
request response are allowed.

00:15:19.033 --> 00:15:20.701
So unfortunately,
cron jobs didn't look like

00:15:20.701 --> 00:15:22.234
a particularly good answer.

00:15:22.234 --> 00:15:24.968
Um, and of course,
the second thing we looked at

00:15:24.968 --> 00:15:27.133
is whether App Engines
supported background tasks.

00:15:27.133 --> 00:15:31.000
And obviously if you were
at Brett's talk earlier,

00:15:31.000 --> 00:15:32.934
you'll know
that the new task queue API

00:15:32.934 --> 00:15:34.434
is going online
in a few weeks.

00:15:34.434 --> 00:15:35.801
And we're very excited
about that.

00:15:35.801 --> 00:15:38.334
We believe
that we can, uh, move

00:15:38.334 --> 00:15:41.467
a lot of our functionality
of our Walk Score calculation

00:15:41.467 --> 00:15:43.000
on to App Engine.

00:15:43.000 --> 00:15:45.968
But six months ago when we
started building this API,

00:15:45.968 --> 00:15:48.601
background tasks weren't
available on App Engine,

00:15:48.601 --> 00:15:50.400
so it wasn't
really an option for us.

00:15:50.400 --> 00:15:52.367
So where do we turn to?

00:15:52.367 --> 00:15:54.968
Well, we turn to Amazon EC2.

00:15:54.968 --> 00:15:57.901
For those who don't know,
EC2 is Amazon's API

00:15:57.901 --> 00:15:59.634
to spin up virtual servers.

00:15:59.634 --> 00:16:00.901
You have full control
of the machine.

00:16:00.901 --> 00:16:03.801
You can choose whatever
operating system image you want.

00:16:03.801 --> 00:16:06.667
And for us, the things that it
gave us was a place

00:16:06.667 --> 00:16:08.801
to do background processing.

00:16:08.801 --> 00:16:11.367
The ability to do a number of
arbitrary URL fetches.

00:16:11.367 --> 00:16:14.200
Of course, just arbitrary IOs
since you own the machine.

00:16:14.200 --> 00:16:17.901
Um, and the design of our
calculator is very parallel.

00:16:17.901 --> 00:16:19.400
We have lots
of processes running,

00:16:19.400 --> 00:16:21.200
working on different latitudes
and longitudes,

00:16:21.200 --> 00:16:23.067
making different
network requests.

00:16:23.067 --> 00:16:26.234
We needed a place to run lots
of processes and parallel.

00:16:26.234 --> 00:16:28.234
So another words,
the Walk Score API is built

00:16:28.234 --> 00:16:30.934
with both App Engine and EC2.

00:16:30.934 --> 00:16:32.367
And when you start
to build a service

00:16:32.367 --> 00:16:35.901
with multiple cloud
computing environments,

00:16:35.901 --> 00:16:39.000
there are a few important
considerations to keep in mind.

00:16:39.000 --> 00:16:41.234
So I just want to show
this perspective.

00:16:41.234 --> 00:16:43.501
Here we've got the customer's
code on the left.

00:16:43.501 --> 00:16:44.701
Our AppEngine code
in the middle

00:16:44.701 --> 00:16:47.167
and our Amazon EC2 code
on the right.

00:16:47.167 --> 00:16:49.467
Um...and here's
a customer request

00:16:49.467 --> 00:16:51.033
where we have already
calculated the score.

00:16:51.033 --> 00:16:53.400
They give us the latitude
and longitude.

00:16:53.400 --> 00:16:54.934
We check to see that it is
already calculated.

00:16:54.934 --> 00:16:57.834
We package up a response and
send it back to them.

00:16:57.834 --> 00:16:59.801
And here's the other type of
customer request.

00:16:59.801 --> 00:17:01.334
We haven't actually seen it.

00:17:01.334 --> 00:17:03.100
The details of what we do
on the App Engine side

00:17:03.100 --> 00:17:04.434
aren't really important.

00:17:04.434 --> 00:17:06.501
And as Josh mentioned,
it's not very complex.

00:17:06.501 --> 00:17:07.934
The important thing
to see here

00:17:07.934 --> 00:17:11.367
is that, during the customer
request response cycle,

00:17:11.367 --> 00:17:13.367
Amazon EC2 has never
been touched.

00:17:13.367 --> 00:17:16.467
So Amazon EC2 is simply
our queue servicing code.

00:17:16.467 --> 00:17:19.567
And customer requests
never get to Amazon.

00:17:19.567 --> 00:17:22.133
And that's a really important
design point

00:17:22.133 --> 00:17:24.434
that I'd urge you to think
about if you're architecting

00:17:24.434 --> 00:17:27.534
a API for multiple
cloud services.

00:17:27.534 --> 00:17:29.834
Um, for us, what it means is
that our up time

00:17:29.834 --> 00:17:33.334
and our scalability is not
a function of both App Engine

00:17:33.334 --> 00:17:35.400
and EC2's upside up-time.

00:17:35.400 --> 00:17:38.334
Or rather, our down-time is not
a function of both of them.

00:17:38.334 --> 00:17:41.601
It's only strictly tied
to App Engine for us.

00:17:41.601 --> 00:17:44.734
If Amazon EC2 goes offline,
what that means is that

00:17:44.734 --> 00:17:46.133
it'll take a little longer
for us

00:17:46.133 --> 00:17:49.133
to process requests
in our queue.

00:17:51.801 --> 00:17:54.267
So we've architected this API,

00:17:54.267 --> 00:17:56.000
and it's been running
for the last six months.

00:17:56.000 --> 00:17:58.968
And I want to talk a little bit
about the behavior we've seen

00:17:58.968 --> 00:18:02.801
during the last six months.

00:18:02.801 --> 00:18:05.334
So this is sort of
the bottom line thing

00:18:05.334 --> 00:18:06.534
that I'd like to stress.

00:18:06.534 --> 00:18:08.734
And, of course, App Engine
is a beta service,

00:18:08.734 --> 00:18:12.234
so some amount of unpredictable
performance is predictable.

00:18:12.234 --> 00:18:16.133
But, uh, we saw
a number of concerning things

00:18:16.133 --> 00:18:18.067
along the way
which have really smoothed out

00:18:18.067 --> 00:18:20.934
over this beta period.

00:18:20.934 --> 00:18:23.234
So the number one thing
that we struggled with

00:18:23.234 --> 00:18:25.634
while running our API
in production

00:18:25.634 --> 00:18:27.467
is high datastore contention.

00:18:27.467 --> 00:18:29.334
And by contention,
what I mean is

00:18:29.334 --> 00:18:32.100
when we make a fetch or a put
to the datastore,

00:18:32.100 --> 00:18:33.400
we see a time out.

00:18:33.400 --> 00:18:35.834
So contention was the percentage
of time outs we saw

00:18:35.834 --> 00:18:37.334
in a given set of requests.

00:18:37.334 --> 00:18:39.634
And in particular for us,
where we saw contention

00:18:39.634 --> 00:18:41.501
was accessing
our queue data structure.

00:18:41.501 --> 00:18:43.400
So obviously, customer requests
are coming in

00:18:43.400 --> 00:18:44.667
at a rather rapid rate.

00:18:44.667 --> 00:18:46.334
They're adding
new latitudes and longitudes

00:18:46.334 --> 00:18:48.701
that we haven't calculated yet
to the queue.

00:18:48.701 --> 00:18:49.934
At the same time,

00:18:49.934 --> 00:18:51.734
our calculator
is trying to pull them off,

00:18:51.734 --> 00:18:53.701
computing them,
and then pushing them

00:18:53.701 --> 00:18:56.334
back to App Engine,

00:18:56.334 --> 00:18:58.367
and removing those entries
from the queue

00:18:58.367 --> 00:18:59.701
once they're calculated.

00:18:59.701 --> 00:19:01.801
So a typical day for us today

00:19:01.801 --> 00:19:03.901
is about a half
of a percent failure

00:19:03.901 --> 00:19:05.634
on reading from the queue.

00:19:05.634 --> 00:19:09.367
Just two days ago,
at around 1:00am I think,

00:19:09.367 --> 00:19:11.834
We saw
App Engine contention rise

00:19:11.834 --> 00:19:15.100
up to about 50 or 60 percent
for about six hours.

00:19:15.100 --> 00:19:16.634
So a really big surprise.

00:19:16.634 --> 00:19:18.434
Something that we had to
architect for

00:19:18.434 --> 00:19:20.133
on the Amazon EC2 side

00:19:20.133 --> 00:19:21.367
where we are servicing
our queue.

00:19:21.367 --> 00:19:22.601
Obviously, we buffer up

00:19:22.601 --> 00:19:24.667
a lot of latitudes
and longitudes there

00:19:24.667 --> 00:19:27.701
so that if we do--
if we're unable to get data

00:19:27.701 --> 00:19:29.801
from App Engine for a while,

00:19:29.801 --> 00:19:34.567
we can still continue to
calculate Walk Scores.

00:19:34.567 --> 00:19:37.467
So another thing
that could happen during--

00:19:37.467 --> 00:19:38.734
especially during
the beta period--

00:19:38.734 --> 00:19:40.434
is that the datastore
goes offline

00:19:40.434 --> 00:19:42.234
or simply goes
in to Read Only mode.

00:19:42.234 --> 00:19:44.234
For those of you who have
running applications

00:19:44.234 --> 00:19:45.868
over the last six months,

00:19:45.868 --> 00:19:47.734
you'll know that this
has happened from time to time.

00:19:47.734 --> 00:19:50.467
What you see normally
in this case,

00:19:50.467 --> 00:19:53.834
is when you make a database--
a datastore request,

00:19:53.834 --> 00:19:57.634
you see a capability
disabled exception.

00:19:57.634 --> 00:19:59.567
Another thing
that we've seen a lot

00:19:59.567 --> 00:20:01.968
is that the App Engine
response time increases.

00:20:01.968 --> 00:20:04.067
We measured this
on the EC2 side.

00:20:04.067 --> 00:20:05.834
So as our calculator
pulls new points

00:20:05.834 --> 00:20:07.734
from our App Engine queue,

00:20:07.734 --> 00:20:09.834
normally those requests
take about

00:20:09.834 --> 00:20:11.000
a half a second to a second.

00:20:11.000 --> 00:20:12.801
Every once in a while,
the response time

00:20:12.801 --> 00:20:14.634
goes up to several seconds.

00:20:14.634 --> 00:20:17.133
So in other words,
latency increases.

00:20:17.133 --> 00:20:19.367
Um, App Engine is
a bit of a black box,

00:20:19.367 --> 00:20:20.667
so it's hard to always
understand

00:20:20.667 --> 00:20:21.834
why this is happening.

00:20:21.834 --> 00:20:23.667
You know, with no changes
to your code

00:20:23.667 --> 00:20:25.634
and with no changes to your
underlying data models,

00:20:25.634 --> 00:20:27.033
you might see this.

00:20:27.033 --> 00:20:28.601
And this is
a very rare occurrence,

00:20:28.601 --> 00:20:34.300
but has happened once or twice
in the last half-year.

00:20:34.300 --> 00:20:37.767
So with those
performance issues in mind,

00:20:37.767 --> 00:20:41.534
what can you do to make sure
that your application scales

00:20:41.534 --> 00:20:43.033
as far as you need it to?

00:20:43.033 --> 00:20:44.801
And so what I'm gonna
talk about here

00:20:44.801 --> 00:20:46.434
are sort of the steps
that you can follow

00:20:46.434 --> 00:20:49.167
to make your application scale
as far as you'd like.

00:20:49.167 --> 00:20:51.767
Um, these steps are distilled
from our experience

00:20:51.767 --> 00:20:53.167
building the Walk Score API,

00:20:53.167 --> 00:20:55.601
but also building other APIs
on top of App Engine

00:20:55.601 --> 00:20:57.167
that we're working on.

00:20:57.167 --> 00:20:59.601
So they may not apply
in your condition.

00:20:59.601 --> 00:21:02.934
they're just good
rules of thumb to keep in mind

00:21:02.934 --> 00:21:05.501
as you're building
your application.

00:21:05.501 --> 00:21:08.567
So scalability on any system

00:21:08.567 --> 00:21:10.167
is really about stair-steps.

00:21:10.167 --> 00:21:13.067
You do a certain amount of work,
you get to the next step.

00:21:13.067 --> 00:21:14.434
To get to the step higher

00:21:14.434 --> 00:21:17.167
might require substantially
more work on your part.

00:21:17.167 --> 00:21:19.901
And so at the bottom rung
for App Engine

00:21:19.901 --> 00:21:21.634
when you're just getting
your feet wet,

00:21:21.634 --> 00:21:26.000
here are some of the things
that you're code might have.

00:21:26.000 --> 00:21:28.334
So first of all,
inconsistent model design.

00:21:28.334 --> 00:21:29.901
Either your models
are very large

00:21:29.901 --> 00:21:31.334
and you only access
one or two properties

00:21:31.334 --> 00:21:32.767
in them at a time.

00:21:32.767 --> 00:21:35.300
Or your models are
very small and distributed

00:21:35.300 --> 00:21:37.834
and you end up accessing
a cluster of different models

00:21:37.834 --> 00:21:39.367
in a single request.

00:21:39.367 --> 00:21:41.501
In that case, you probably
want to re-think

00:21:41.501 --> 00:21:42.734
the design of your models,

00:21:42.734 --> 00:21:44.601
shape them
a little bit differently.

00:21:44.601 --> 00:21:47.000
So this is a characteristic
that I've seen

00:21:47.000 --> 00:21:49.300
in just starting out
App Engine applications.

00:21:49.300 --> 00:21:50.567
Especially for people
who've worked

00:21:50.567 --> 00:21:52.033
in the SQL world before

00:21:52.033 --> 00:21:53.934
and they're just sort of
starting to move over.

00:21:53.934 --> 00:21:56.133
Uneven or no memcache use.

00:21:56.133 --> 00:21:57.501
It's a lot of fun
and it's a lot easier

00:21:57.501 --> 00:21:58.667
to rate your application

00:21:58.667 --> 00:22:00.934
without thinking
about memcache at first.

00:22:00.934 --> 00:22:04.334
Unfortunately, pretty much
all good App Engine applications

00:22:04.334 --> 00:22:06.934
are going to make some
or very heavy use of memcache

00:22:06.934 --> 00:22:09.033
early on in their lifecycle.

00:22:09.033 --> 00:22:12.601
Um, and the final thing
is, for those who don't know,

00:22:12.601 --> 00:22:14.467
every time you make
a datastore request,

00:22:14.467 --> 00:22:16.033
a fetch or a put,

00:22:16.033 --> 00:22:18.200
you're effectively making
an RPC request

00:22:18.200 --> 00:22:19.801
somewhere in Google's
data center.

00:22:19.801 --> 00:22:22.767
So you're able to batch
these requests,

00:22:22.767 --> 00:22:25.067
but it can be difficult
to design your code that way.

00:22:25.067 --> 00:22:27.901
So a lot of early stage code
that I've seen

00:22:27.901 --> 00:22:29.400
doesn't do that.

00:22:29.400 --> 00:22:32.200
So with this sort of
naive style of coding

00:22:32.200 --> 00:22:35.267
with App Engine,
we've been able to see

00:22:35.267 --> 00:22:37.767
something like
five queries a second handled,

00:22:37.767 --> 00:22:39.434
which is actually
really rather amazing.

00:22:39.434 --> 00:22:40.934
I should point out
that this number is

00:22:40.934 --> 00:22:43.133
in our experience--depending
on the type of application

00:22:43.133 --> 00:22:44.801
that you're building, you may
see something different,

00:22:44.801 --> 00:22:46.400
but this is approximately
what we saw

00:22:46.400 --> 00:22:48.434
when we were starting out
with the Walk Score API.

00:22:48.434 --> 00:22:49.601
Five queries a second

00:22:49.601 --> 00:22:51.501
is over 10,000,000 requests
a month.

00:22:51.501 --> 00:22:54.467
It's already a really rather
large application.

00:22:54.467 --> 00:22:57.067
And it speaks to the power
of App Engine as a platform

00:22:57.067 --> 00:23:01.667
to get you scaling very fast
right out the door.

00:23:01.667 --> 00:23:04.601
So where do you go from there
once you want to go past

00:23:04.601 --> 00:23:09.901
that five or so queries
a second?

00:23:09.901 --> 00:23:13.000
Well, uh, the very first thing
I'd urge you to think about

00:23:13.000 --> 00:23:14.334
is starting to use memcache.

00:23:14.334 --> 00:23:16.501
And the easiest way
to use memcache

00:23:16.501 --> 00:23:19.000
is just slather it on
everywhere you read data

00:23:19.000 --> 00:23:20.267
from your datastore.

00:23:20.267 --> 00:23:22.234
So the basic behavior,
of course, is

00:23:22.234 --> 00:23:24.000
if you're going to read
an entity from the datastore,

00:23:24.000 --> 00:23:26.067
check to see
if you've cached it first.

00:23:26.067 --> 00:23:27.801
If you have--
great, you're done.

00:23:27.801 --> 00:23:30.133
If you haven't--read it,
add it to the cache.

00:23:30.133 --> 00:23:31.934
Oh, and be sure
when you're writing back

00:23:31.934 --> 00:23:33.567
or updating
an entity in the datastore

00:23:33.567 --> 00:23:35.767
to either clear your memcache
or update it.

00:23:35.767 --> 00:23:37.701
And if you actually go
and look at

00:23:37.701 --> 00:23:39.701
the Google App Engine
Cookbook, somebody uploaded

00:23:39.701 --> 00:23:41.434
I think about
a month or two ago

00:23:41.434 --> 00:23:44.834
a really great Shim
for the App Engine datastore.

00:23:44.834 --> 00:23:48.367
That just causes memcache
on read to happen everywhere.

00:23:48.367 --> 00:23:49.701
So as a first step,

00:23:49.701 --> 00:23:53.467
that might be something
to look in to.

00:23:53.467 --> 00:23:55.400
Um, another thing
to think about

00:23:55.400 --> 00:23:58.234
is to batch your datastore
requests where easy.

00:23:58.234 --> 00:24:00.734
"Where easy" for us
was anywhere we had

00:24:00.734 --> 00:24:02.467
non-nested loops.

00:24:02.467 --> 00:24:03.734
So anywhere we had a loop

00:24:03.734 --> 00:24:05.467
that we were putting
single entities,

00:24:05.467 --> 00:24:06.767
we inverted that.

00:24:06.767 --> 00:24:10.434
Now we call "one put"
with lots of entities.

00:24:10.434 --> 00:24:11.901
And I should mention
that batching

00:24:11.901 --> 00:24:14.434
is a little bit tricky
because you can only fetch

00:24:14.434 --> 00:24:17.300
up to a 1,000 entities
of time from the datastore.

00:24:17.300 --> 00:24:20.400
And puts are limited
based on the size

00:24:20.400 --> 00:24:21.968
of the entities you're putting
in the datastore.

00:24:21.968 --> 00:24:24.100
A good rule of thumb is
50 at a time.

00:24:24.100 --> 00:24:25.868
So you may need
to have multiple batches

00:24:25.868 --> 00:24:27.200
depending on the size

00:24:27.200 --> 00:24:29.667
of the operations
you're performing.

00:24:29.667 --> 00:24:32.367
So with that work, we saw

00:24:32.367 --> 00:24:34.334
pretty much a doubling
of our ability to handle load,

00:24:34.334 --> 00:24:36.667
which is actually, again,
really rather impressive.

00:24:36.667 --> 00:24:39.934
And that's not so much
engineering work on our part.

00:24:39.934 --> 00:24:41.567
But we wanted to go
a lot further.

00:24:41.567 --> 00:24:43.501
And of course,
the running Walk Score API

00:24:43.501 --> 00:24:45.434
sees substantially more
than ten queries a second

00:24:45.434 --> 00:24:47.467
on any given day.

00:24:47.467 --> 00:24:49.200
So what do we
have to do next?

00:24:49.200 --> 00:24:51.934
And the next of the tips
are really a grab bag of things

00:24:51.934 --> 00:24:53.033
that you might
want to think about

00:24:53.033 --> 00:24:55.567
as you really scale out
your application.

00:24:55.567 --> 00:24:58.534
The first is that I'd urge you
to think long and hard

00:24:58.534 --> 00:25:00.634
about how your datastore
is accessed

00:25:00.634 --> 00:25:03.801
and what type
of usage patterns you see.

00:25:03.801 --> 00:25:06.033
So memcache is really great
in particular

00:25:06.033 --> 00:25:07.734
for two types
of usage patterns.

00:25:07.734 --> 00:25:11.067
One is repeated requests
to the same data,

00:25:11.067 --> 00:25:14.234
and the other is predictable
sequential access to data.

00:25:14.234 --> 00:25:16.634
So for repeated requests
to the same data,

00:25:16.634 --> 00:25:18.067
if you know your customer
is gonna hit that

00:25:18.067 --> 00:25:20.434
same entity again and again,
cache on read,

00:25:20.434 --> 00:25:21.934
like we discussed
from the previous step,

00:25:21.934 --> 00:25:24.033
is actually really
a great strategy.

00:25:24.033 --> 00:25:26.934
But if you have a predictable
sequential access--

00:25:26.934 --> 00:25:29.968
For example, in the case
of the Walk Score queue,

00:25:29.968 --> 00:25:32.133
we know that we're gonna pull
out those queue items in order.

00:25:32.133 --> 00:25:33.734
Our calculator code
is going to request them

00:25:33.734 --> 00:25:35.000
in a certain order.

00:25:35.000 --> 00:25:37.534
So our calculator
talks to App Engine

00:25:37.534 --> 00:25:41.167
and it requests 50 items
at a time from the queue.

00:25:41.167 --> 00:25:43.334
But on the App Engine side,
what we do is we actually

00:25:43.334 --> 00:25:45.667
pull out a full 1,000 items
from our queue,

00:25:45.667 --> 00:25:47.734
put that entire list
in the memcache.

00:25:47.734 --> 00:25:49.801
And that obviously
cuts down substantially

00:25:49.801 --> 00:25:53.100
on the number of datastore
accesses we need to make.

00:25:53.100 --> 00:25:56.000
So think about memcache
usage patterns.

00:25:56.000 --> 00:25:58.634
Um...batch all
of your datastore calls.

00:25:58.634 --> 00:26:02.400
This went a long way for us
to scaling outward.

00:26:02.400 --> 00:26:06.434
And for us, what that meant
is unraveling nested loops.

00:26:06.434 --> 00:26:08.367
Sometimes they were loops

00:26:08.367 --> 00:26:10.467
that were basically
across method boundaries,

00:26:10.467 --> 00:26:12.601
so we had to flatten
a lot of our code out.

00:26:12.601 --> 00:26:15.567
But it really
helped us a lot.

00:26:15.567 --> 00:26:18.434
As important as using
memcache carefully is,

00:26:18.434 --> 00:26:20.534
sometimes it's just not
the right thing to do

00:26:20.534 --> 00:26:21.701
to use memcache.

00:26:21.701 --> 00:26:23.534
Depending on
your access pattern,

00:26:23.534 --> 00:26:25.734
it may not--
memcache may not provide

00:26:25.734 --> 00:26:27.901
a very meaningful barrier
between your users

00:26:27.901 --> 00:26:29.200
and the datastore.

00:26:29.200 --> 00:26:31.667
And that's--
memcache is a limited resource.

00:26:31.667 --> 00:26:33.334
You obviously don't want
to populate memcache

00:26:33.334 --> 00:26:36.334
with entities
that aren't useful to you

00:26:36.334 --> 00:26:40.200
and--and lose
the entities that are.

00:26:40.200 --> 00:26:43.067
And, of course, memcache--
when you add items to memcache,

00:26:43.067 --> 00:26:45.133
you can, of course, think about
how long they stay there.

00:26:45.133 --> 00:26:46.567
Sometimes that's
a very great way

00:26:46.567 --> 00:26:50.100
to keep memcache
pressure low.

00:26:50.100 --> 00:26:53.133
And then I would urge you
to load test your application.

00:26:53.133 --> 00:26:54.701
We actually built
a load testing harness

00:26:54.701 --> 00:26:56.334
on Amazon EC2.

00:26:56.334 --> 00:26:58.868
We're able to hit our running
Walk Score instances

00:26:58.868 --> 00:27:00.734
with over 100 queries
a second.

00:27:00.734 --> 00:27:04.968
And that's real load
talking to real URL handlers

00:27:04.968 --> 00:27:07.400
that actually do real work
with the datastore.

00:27:07.400 --> 00:27:08.901
Um, so load testing.

00:27:08.901 --> 00:27:11.200
There are third party products
to help you with that too.

00:27:11.200 --> 00:27:15.033
Um, App Engine load
tends to be surprising

00:27:15.033 --> 00:27:17.334
once you get pretty high,

00:27:17.334 --> 00:27:19.167
past ten queries a second.

00:27:19.167 --> 00:27:21.133
And the last thing is,
of course,

00:27:21.133 --> 00:27:22.601
monitor your performance.

00:27:22.601 --> 00:27:24.734
Now the front line of defense
for monitoring performance

00:27:24.734 --> 00:27:28.501
is the--is the App Engine
dashboard,

00:27:28.501 --> 00:27:29.868
which is a great place to go.

00:27:29.868 --> 00:27:31.000
And, of course, your logs

00:27:31.000 --> 00:27:32.400
to look at
individual requests

00:27:32.400 --> 00:27:35.000
that, for example, gave you
a datastore time out.

00:27:35.000 --> 00:27:36.834
Um, also the system status,

00:27:36.834 --> 00:27:38.267
if you're seeing
a lot of latency,

00:27:38.267 --> 00:27:39.601
is a good place to go

00:27:39.601 --> 00:27:41.801
to just look at the overall
behavior of App Engine.

00:27:41.801 --> 00:27:44.067
We actually built our own
performance dashboard

00:27:44.067 --> 00:27:46.000
for the Walk Score API,
which we're happy to show you

00:27:46.000 --> 00:27:48.067
if you'd like
after this talk.

00:27:48.067 --> 00:27:51.767
Um, and it monitors specific
things about the behavior

00:27:51.767 --> 00:27:54.901
of our EC2's calculator code

00:27:54.901 --> 00:27:58.334
communication with App Engine.

00:27:58.334 --> 00:28:00.133
And just sort of one
last technique

00:28:00.133 --> 00:28:02.534
if you're getting started
with App Engine coding

00:28:02.534 --> 00:28:04.968
that I think everybody
should know, which is,

00:28:04.968 --> 00:28:07.534
If at first you don't succeed,
try, try again.

00:28:07.534 --> 00:28:10.267
Uh, what we have here
is basically an attempt

00:28:10.267 --> 00:28:12.734
to write to the datastore
that time--if it times out,

00:28:12.734 --> 00:28:16.100
we're going to turn around
right away and write again.

00:28:16.100 --> 00:28:17.868
Just a few
milliseconds later,

00:28:17.868 --> 00:28:19.834
you might not
get a time out exception.

00:28:19.834 --> 00:28:21.701
And this is something we do
everywhere is our code base now,

00:28:21.701 --> 00:28:23.067
both on the read
and write side.

00:28:23.067 --> 00:28:27.634
And it's actually
extremely helpful.

00:28:27.634 --> 00:28:30.167
So I've talked a little bit
about general principles

00:28:30.167 --> 00:28:32.267
for scaling out
App Engine applications.

00:28:32.267 --> 00:28:34.801
And what I want to do now
is turn it back over to Josh,

00:28:34.801 --> 00:28:37.367
who's going to talk about
one specific instance

00:28:37.367 --> 00:28:39.701
where we had some difficult
scalability issues

00:28:39.701 --> 00:28:41.100
that we needed to tackle

00:28:41.100 --> 00:28:44.300
and the sort of unorthodox
technique we used to solve them.

00:28:44.300 --> 00:28:46.534
So thanks.

00:28:46.534 --> 00:28:48.067
Livni: Thanks, Dave.

00:28:48.067 --> 00:28:50.100
So, yeah,
I started out talking

00:28:50.100 --> 00:28:51.968
about kind of
the core functionality

00:28:51.968 --> 00:28:53.400
and secondary functionality.

00:28:53.400 --> 00:28:55.467
Obviously, you guys'
applications are gonna have

00:28:55.467 --> 00:28:57.534
different pieces of secondary
functionality

00:28:57.534 --> 00:28:59.434
that may or may not fit
different places.

00:28:59.434 --> 00:29:03.567
A really common use case
on App Engine is counting stuff.

00:29:03.567 --> 00:29:06.567
I'm gonna talk about
a specific issue we have

00:29:06.567 --> 00:29:09.367
counting our users' requests.

00:29:09.367 --> 00:29:12.367
We have a basic quota system.
We have an API key.

00:29:12.367 --> 00:29:14.501
We want to know
who's basically doing what.

00:29:14.501 --> 00:29:16.200
So certain folks might get

00:29:16.200 --> 00:29:17.901
a couple hundred thousand
requests a day.

00:29:17.901 --> 00:29:19.434
Others might get, 
you know,

00:29:19.434 --> 00:29:21.334
maybe a couple million a day.

00:29:21.334 --> 00:29:24.000
But we want to make sure
that people can't just run away

00:29:24.000 --> 00:29:25.300
and abuse the system.

00:29:25.300 --> 00:29:27.834
And again, we understand
who's doing what where.

00:29:27.834 --> 00:29:29.834
So counting every request
that comes in,

00:29:29.834 --> 00:29:32.300
matching it to a user, should be
pretty straight forward.

00:29:32.300 --> 00:29:34.200
And the answer that's
usually given for this is,

00:29:34.200 --> 00:29:35.767
"Oh, just use
sharded counters."

00:29:35.767 --> 00:29:37.267
Every time a request comes in,

00:29:37.267 --> 00:29:38.734
write it to
one of these shards.

00:29:38.734 --> 00:29:39.834
You're good to go.

00:29:39.834 --> 00:29:41.400
But every time a request
comes in,

00:29:41.400 --> 00:29:43.968
if that request is, you know,
a 100 requests a second,

00:29:43.968 --> 00:29:45.534
that's a lot of shards,
and you're gonna really

00:29:45.534 --> 00:29:47.400
hit a lot of datastore
contention.

00:29:47.400 --> 00:29:50.167
So we found that the sharded
counters didn't scale

00:29:50.167 --> 00:29:51.434
as well as we had hoped.

00:29:51.434 --> 00:29:52.734
And what happened,
in our case--

00:29:52.734 --> 00:29:54.734
This was from
about six months ago

00:29:54.734 --> 00:29:56.567
and things are
a little bit different now.

00:29:56.567 --> 00:29:58.501
Around 30,
40 queries a second,

00:29:58.501 --> 00:30:01.033
our response time
started creeping up.

00:30:01.033 --> 00:30:03.033
You know, two, four,
six plus seconds.

00:30:03.033 --> 00:30:04.868
And then
along with the error rates--

00:30:04.868 --> 00:30:07.267
And then all of the sudden
everything was 503s.

00:30:07.267 --> 00:30:09.567
And this was a really
big problem, because again,

00:30:09.567 --> 00:30:11.100
core functionality
should not be hurt

00:30:11.100 --> 00:30:12.701
by this sort of
icing on the cake

00:30:12.701 --> 00:30:14.434
of counting
who's doing what.

00:30:14.434 --> 00:30:16.634
So we were finding
that just because we wanted

00:30:16.634 --> 00:30:19.100
to have a quota system,
now nobody can even get a score

00:30:19.100 --> 00:30:22.501
because all of the requests
are just bombing out entirely.

00:30:22.501 --> 00:30:24.767
So a solution
that we came up with--

00:30:24.767 --> 00:30:26.367
How many of you guys
were in the talk

00:30:26.367 --> 00:30:27.501
just before this?

00:30:27.501 --> 00:30:29.801
Brett's talk next-door?
So a few guys.

00:30:29.801 --> 00:30:32.601
So one of the things
I thought--

00:30:32.601 --> 00:30:35.734
a really interesting example
of the new task queue

00:30:35.734 --> 00:30:39.534
was the backend
sort of writing to a cache.

00:30:39.534 --> 00:30:41.968
We implemented something--
a similar concept.

00:30:41.968 --> 00:30:43.767
Dave talked a little bit
about using memcache

00:30:43.767 --> 00:30:45.367
cleverly on read,

00:30:45.367 --> 00:30:47.601
and this is
using memcache on write,

00:30:47.601 --> 00:30:50.601
which in the Google group
discussions and other places,

00:30:50.601 --> 00:30:52.033
people generally say,
"Oh, don't do that."

00:30:52.033 --> 00:30:53.501
You know,
"Memcache is unreliable,

00:30:53.501 --> 00:30:54.734
Things might go away."

00:30:54.734 --> 00:30:56.734
But in my opinion,
there are certain cases,

00:30:56.734 --> 00:30:58.334
and this is one of them
for us,

00:30:58.334 --> 00:31:03.000
where you don't absolutely
need to have exact accuracy.

00:31:03.000 --> 00:31:04.601
If your writing
a banking application

00:31:04.601 --> 00:31:07.067
and counting people's pennies,
you know, don't do this.

00:31:07.067 --> 00:31:08.968
But for a lot of cases,

00:31:08.968 --> 00:31:10.767
if you're just getting
a general idea for a quota,

00:31:10.767 --> 00:31:12.667
how many things are,
you know, generally around

00:31:12.667 --> 00:31:13.968
at a given time.

00:31:13.968 --> 00:31:15.634
And again,
knowing things might fail,

00:31:15.634 --> 00:31:17.300
you have other processes
to come in place

00:31:17.300 --> 00:31:19.334
and check
things happened accurately,

00:31:19.334 --> 00:31:20.834
do things twice
and so forth.

00:31:20.834 --> 00:31:23.334
Using memcache on write can be
a really interesting idea.

00:31:23.334 --> 00:31:25.934
So this diagram
basically shows

00:31:25.934 --> 00:31:28.167
that request comes in
with the API.

00:31:28.167 --> 00:31:29.734
Rather than writing you
a sharded counter,

00:31:29.734 --> 00:31:32.000
a datastore counter,

00:31:32.000 --> 00:31:34.467
we write to the sharded
memcache counters.

00:31:34.467 --> 00:31:36.834
When the memcache counters
fill up to 100,

00:31:36.834 --> 00:31:39.434
200, whatever,
only then do we write

00:31:39.434 --> 00:31:42.200
that bit of information
to the datastore.

00:31:42.200 --> 00:31:45.601
And then the task queue is
a little bit nicer that this.

00:31:45.601 --> 00:31:49.667
In the talk just before this,
you notice between the memcache

00:31:49.667 --> 00:31:51.868
and the datastore
there's this pass queue,

00:31:51.868 --> 00:31:55.067
and it's a lot faster to write
to the upcoming pass queue

00:31:55.067 --> 00:31:57.100
that we certainly
weren't expecting

00:31:57.100 --> 00:31:58.901
when we started writing this.

00:31:58.901 --> 00:32:00.901
But you still
have the same issue

00:32:00.901 --> 00:32:03.033
writing to a task queue
or writing to the datastore,

00:32:03.033 --> 00:32:05.434
which is there's
this small time period

00:32:05.434 --> 00:32:08.133
where requests can come in,
hit your memcache shard,

00:32:08.133 --> 00:32:10.300
increment the count
before you've written,

00:32:10.300 --> 00:32:11.968
and then cleared
the memcache shard.

00:32:11.968 --> 00:32:13.434
So you just have to
sort of keep track

00:32:13.434 --> 00:32:16.300
of the delta of what you are
writing the datastore

00:32:16.300 --> 00:32:18.033
and then the amount of things
that came in

00:32:18.033 --> 00:32:19.534
before you got confirmation.

00:32:19.534 --> 00:32:21.200
The same with task queue.

00:32:21.200 --> 00:32:24.434
So as I mentioned,
the solution is really nice.

00:32:24.434 --> 00:32:26.033
The advantage is really nice.

00:32:26.033 --> 00:32:30.300
You get instead of, you know,
100 datastore hits a second,

00:32:30.300 --> 00:32:32.300
you get a couple orders
of magnitude less.

00:32:32.300 --> 00:32:34.901
And that just scales up
really, really, really nicely.

00:32:34.901 --> 00:32:38.267
But the disadvantage is
there is a, uh--

00:32:38.267 --> 00:32:40.100
I don't know where
my disadvantage went.

00:32:40.100 --> 00:32:41.334
But there's the possibility

00:32:41.334 --> 00:32:42.667
that you could lose
a little bit.

00:32:42.667 --> 00:32:44.868
And so for our use case,
we were okay

00:32:44.868 --> 00:32:46.100
if it was off a little bit

00:32:46.100 --> 00:32:47.634
as long as we didn't
over-count.

00:32:47.634 --> 00:32:49.834
We didn't want to accidentally
send someone over a quota

00:32:49.834 --> 00:32:51.234
that they didn't use.

00:32:51.234 --> 00:32:52.868
And so we're just really,
really careful

00:32:52.868 --> 00:32:54.300
that in case
of a loss of data,

00:32:54.300 --> 00:32:55.767
it's always
a subtle undercount.

00:32:55.767 --> 00:32:58.667
And again, memcache has proven
really, really reliable.

00:32:58.667 --> 00:33:01.367
There's a couple of, you know,
two-or-three-hour knockouts

00:33:01.367 --> 00:33:03.968
that we had that we just
lost counters for.

00:33:03.968 --> 00:33:06.100
But aside from that,
as a general rule

00:33:06.100 --> 00:33:08.534
you can pretty much
rely on it.

00:33:08.534 --> 00:33:10.334
So after we implement
the memcache,

00:33:10.334 --> 00:33:11.634
things went like this.

00:33:11.634 --> 00:33:13.300
And again, this graph
is from a while ago.

00:33:13.300 --> 00:33:15.767
These days, it's smoother
and things stay

00:33:15.767 --> 00:33:17.701
well under a second
for the response time.

00:33:17.701 --> 00:33:18.934
But it's really a huge
difference.

00:33:18.934 --> 00:33:21.467
What it means is, we can
actually count stuff now

00:33:21.467 --> 00:33:24.400
at a very, very high
rate per second

00:33:24.400 --> 00:33:27.534
and not have to worry
about hitting these issues

00:33:27.534 --> 00:33:30.200
where our core functionality
is compromised.

00:33:30.200 --> 00:33:32.267
So the summary here is

00:33:32.267 --> 00:33:33.767
it's not necessarily
a bad idea

00:33:33.767 --> 00:33:35.767
to think about using memcache
on write.

00:33:35.767 --> 00:33:39.267
Again, possibility
of lossiness is always there.

00:33:39.267 --> 00:33:42.667
But in many cases
that you might come across,

00:33:42.667 --> 00:33:45.234
it can really save
not only the possibility

00:33:45.234 --> 00:33:47.534
of just datastore contention,
but also some money

00:33:47.534 --> 00:33:49.567
because you're charged
for the CPU time

00:33:49.567 --> 00:33:50.834
on the datastore.

00:33:50.834 --> 00:33:52.367
And if you're not
in the datastore,

00:33:52.367 --> 00:33:53.801
you know that can add up,

00:33:53.801 --> 00:33:55.634
a few bucks a day
over time.

00:33:55.634 --> 00:33:59.667
And then, uh, the other piece
is early on decide,

00:33:59.667 --> 00:34:02.200
is this functionality
a good fit for App Engine?

00:34:02.200 --> 00:34:04.968
Certain things--for example,
we could've offloaded

00:34:04.968 --> 00:34:06.934
the quota, parsed logs

00:34:06.934 --> 00:34:09.467
every couple of hours offline
and come back on.

00:34:09.467 --> 00:34:10.801
And we decided,

00:34:10.801 --> 00:34:12.334
"Oh, this is a good piece
to fit on App Engine."

00:34:12.334 --> 00:34:13.667
We ought to be able
to count stuff.

00:34:13.667 --> 00:34:15.467
Other things we decided,
"No, this piece,

00:34:15.467 --> 00:34:18.434
although integrated
with App Engine and the API,

00:34:18.434 --> 00:34:19.667
maybe we'll move off."

00:34:19.667 --> 00:34:22.067
So just deciding
which pieces fit in App Engine

00:34:22.067 --> 00:34:23.300
is important.

00:34:23.300 --> 00:34:24.868
And then the final one
is, of course,

00:34:24.868 --> 00:34:26.567
when you're putting
those pieces into App Engine,

00:34:26.567 --> 00:34:28.934
make sure that you
write them in such a way

00:34:28.934 --> 00:34:30.667
that should strange
and weird things happen--

00:34:30.667 --> 00:34:32.033
like all of the sudden
you get popular,

00:34:32.033 --> 00:34:34.667
80 queries a second,
datastore contention hits--

00:34:34.667 --> 00:34:36.767
those features that you wanted
to have in App Engine

00:34:36.767 --> 00:34:38.868
don't compromise
the really core functionality

00:34:38.868 --> 00:34:41.767
that your application
may have.

00:34:41.767 --> 00:34:43.934
And so with that, I'm gonna
turn it back to Jesse

00:34:43.934 --> 00:34:48.000
and talk about
some of the over-all results.

00:34:48.000 --> 00:34:50.567
Kocher: So you've seen some
of the, you know, stair-steps

00:34:50.567 --> 00:34:52.901
to scalability hotness
that Dave went through.

00:34:52.901 --> 00:34:55.467
Um...where has all of that
gotten us?

00:34:55.467 --> 00:34:58.567
Well, the three of us--
very small team--

00:34:58.567 --> 00:35:00.534
have built an App engine API

00:35:00.534 --> 00:35:04.234
that handles over 1.5 million
requests a day.

00:35:04.234 --> 00:35:07.200
And, uh, peak rates up to
about 80 requests per second.

00:35:07.200 --> 00:35:10.033
So quit a bit higher
than where we started.

00:35:10.033 --> 00:35:13.167
Um, and we've come to think
of App Engine

00:35:13.167 --> 00:35:15.567
as really being a black box.

00:35:15.567 --> 00:35:19.334
It's a place
where things may shift in,

00:35:19.334 --> 00:35:21.334
you know,
unexpected ways internally.

00:35:21.334 --> 00:35:23.367
And you may not always know
what's going on in there.

00:35:23.367 --> 00:35:27.334
Um, but it's also
very well-documented.

00:35:27.334 --> 00:35:29.567
And not just the main
documentation online,

00:35:29.567 --> 00:35:33.033
but also this dynamic support
with the IRC channel,

00:35:33.033 --> 00:35:35.534
the Google Groups,
the issue tracker.

00:35:35.534 --> 00:35:38.300
And the App Engine team
is really--

00:35:38.300 --> 00:35:40.801
They're--they frequent
all of these places.

00:35:40.801 --> 00:35:43.601
So the degree of communication
is pretty amazing,

00:35:43.601 --> 00:35:45.868
and it makes working
inside a black box

00:35:45.868 --> 00:35:47.868
considerably less daunting.

00:35:47.868 --> 00:35:50.000
So our amended statement
would be--

00:35:50.000 --> 00:35:51.968
It's a very good black box.

00:35:51.968 --> 00:35:54.400
Um, I think looking back
we would make the same choice

00:35:54.400 --> 00:35:57.367
that we made, you know,
not knowing a lot of the things

00:35:57.367 --> 00:35:58.767
that we've learned
along the way.

00:35:58.767 --> 00:36:01.334
And I can say
that having watched App Engine

00:36:01.334 --> 00:36:03.467
progress over
these last few months,

00:36:03.467 --> 00:36:05.601
the work that we've done

00:36:05.601 --> 00:36:07.801
would be considerably easier
starting now

00:36:07.801 --> 00:36:09.801
than it was
starting back then.

00:36:09.801 --> 00:36:12.767
Um, so we hope this talk
has helped you understand

00:36:12.767 --> 00:36:15.334
some of the risks and rewards
of using App Engine

00:36:15.334 --> 00:36:17.300
and some things about

00:36:17.300 --> 00:36:19.133
how to get your Apps
to scale well.

00:36:19.133 --> 00:36:23.133
Um, we have--

00:36:23.133 --> 00:36:25.467
I'm gonna put up our contact
info for a second here.

00:36:25.467 --> 00:36:28.634
So if you want to get
with us, you can jot that down.

00:36:28.634 --> 00:36:31.834
We will also--got some time
for questions here.

00:36:31.834 --> 00:36:34.601
And we also will be
out at the demo spot

00:36:34.601 --> 00:36:37.334
for most of the rest of
the afternoon until about 4:00.

00:36:37.334 --> 00:36:41.133
So if you want to catch us
there, please do.

00:36:43.567 --> 00:36:45.701
And we'll move
in to Q&amp;A now.

00:36:45.701 --> 00:36:47.667
So we're happy to take
questions on anything.

00:36:47.667 --> 00:36:49.067
Uh, we'll take them
at the mic.

00:36:49.067 --> 00:36:52.133
And also, I'll flip over
to the, uh,

00:36:52.133 --> 00:36:54.167
the Moderator site
in a few minutes.

00:36:54.167 --> 00:36:55.634
But before I do that,
I want to put up--

00:36:55.634 --> 00:36:57.634
these are a few things
we didn't put into our talk

00:36:57.634 --> 00:36:59.200
but we definitely
have more to say about.

00:36:59.200 --> 00:37:00.601
So if any of those
interest you,

00:37:00.601 --> 00:37:02.534
uh, feel free
to ask about those.

00:37:02.534 --> 00:37:04.701
And then, Google sent us
a note earlier today

00:37:04.701 --> 00:37:08.734
asking us to direct you all
to havasec.com/io.

00:37:08.734 --> 00:37:11.167
And if you go there,
you can put in the time slot

00:37:11.167 --> 00:37:12.601
and the session
and you can give feedback.

00:37:12.601 --> 00:37:14.968
So we'd appreciate
any feedback you have for us.

00:37:14.968 --> 00:37:18.133
Um, and with that, we will
move to questions, so...

00:37:18.133 --> 00:37:21.567
man: A two part question
about your counters.

00:37:21.567 --> 00:37:25.734
Why did you still shard them
when you put them on memcache?

00:37:25.734 --> 00:37:28.868
Kocher: Uh, there actually can
be contention with memcache

00:37:28.868 --> 00:37:31.367
when you're hitting it
very intensively.

00:37:31.367 --> 00:37:34.767
man: At how many requests
per second would you put that?

00:37:34.767 --> 00:37:36.567
Kocher: I don't know.
Do you guys recall?

00:37:36.567 --> 00:37:40.000
Livni: Well, we found that
once we hit a--

00:37:40.000 --> 00:37:41.434
There's a couple
of reasons we sharded

00:37:41.434 --> 00:37:42.901
the memcache counter
originally.

00:37:42.901 --> 00:37:45.801
One is, there is that
possibility of contention.

00:37:45.801 --> 00:37:48.667
Another is, it's cheap to make
lots of memcache shards.

00:37:48.667 --> 00:37:50.801
And one of the issues
I mentioned in that slide

00:37:50.801 --> 00:37:54.367
is that as you're writing
the shard to the datastore,

00:37:54.367 --> 00:37:55.667
you might not get
a response back

00:37:55.667 --> 00:37:57.501
for a half-second
to four seconds.

00:37:57.501 --> 00:37:59.801
So all of that time
you're having

00:37:59.801 --> 00:38:01.567
a lot more requests
coming in.

00:38:01.567 --> 00:38:04.033
We wanted to minimize
to some degree

00:38:04.033 --> 00:38:06.067
in order to keep the count
a little--

00:38:06.067 --> 00:38:08.100
as accurate as possible.

00:38:08.100 --> 00:38:10.234
That very, very small
time frame

00:38:10.234 --> 00:38:12.467
from when we clear
the memcache shard is,

00:38:12.467 --> 00:38:14.033
"Okay, we got
a confirmation back

00:38:14.033 --> 00:38:15.534
and then we've
written it out."

00:38:15.534 --> 00:38:17.234
We don't want
30 new requests

00:38:17.234 --> 00:38:18.434
coming in
at that time frame

00:38:18.434 --> 00:38:20.334
because there is still
a little bit of latency

00:38:20.334 --> 00:38:21.901
even writing to memcache.

00:38:21.901 --> 00:38:23.100
It's, you know,
much, much faster

00:38:23.100 --> 00:38:24.434
that writing the datastore.

00:38:24.434 --> 00:38:25.934
And so,
by making lots of shards,

00:38:25.934 --> 00:38:28.667
it's not really any overhead
for the system,

00:38:28.667 --> 00:38:31.267
but we can sort of spread out
the number of requests

00:38:31.267 --> 00:38:33.400
in that just
couple of milliseconds,

00:38:33.400 --> 00:38:35.200
it's less likely
we will lose something.

00:38:35.200 --> 00:38:36.701
Does that make sense?

00:38:36.701 --> 00:38:39.267
man: Okay, the second part is,
before this morning

00:38:39.267 --> 00:38:41.234
I--you know,
I didn't really know

00:38:41.234 --> 00:38:44.801
how many memcache instances
Google would have for my App.

00:38:44.801 --> 00:38:47.467
But now it sounds like
I have to assume

00:38:47.467 --> 00:38:48.567
if I write with a key,

00:38:48.567 --> 00:38:50.801
it will always be
the same one memcached,

00:38:50.801 --> 00:38:53.434
because otherwise
these counters wouldn't work.

00:38:53.434 --> 00:38:56.300
You know, if I have
one instance of my Java App

00:38:56.300 --> 00:38:57.834
running in Australia--

00:38:57.834 --> 00:39:00.434
Peck: No, that's correct.
Memcache is a distributed API.

00:39:00.434 --> 00:39:03.534
And so, if you write on--
you don't have any knowledge

00:39:03.534 --> 00:39:05.467
of what CPUs your code
is executing on

00:39:05.467 --> 00:39:07.934
inside the App Engine
data center.

00:39:07.934 --> 00:39:09.801
man: Right, but now it sounds
like I have a guarantee

00:39:09.801 --> 00:39:14.167
that when I write to memcache,
all my 500 App instances

00:39:14.167 --> 00:39:15.701
write to the same--

00:39:15.701 --> 00:39:17.767
Peck: Yeah, they're effectively
writing to the same store.

00:39:17.767 --> 00:39:19.567
That's correct.

00:39:19.567 --> 00:39:22.901
I don't know how they propagate
that data across.

00:39:22.901 --> 00:39:24.200
I don't know how long
it takes.

00:39:24.200 --> 00:39:25.767
So, if you're running code--

00:39:25.767 --> 00:39:27.200
not that you can specify
when you're writing

00:39:27.200 --> 00:39:28.801
an App Engine application
right now.

00:39:28.801 --> 00:39:30.267
But if some of your code's
running in Australia

00:39:30.267 --> 00:39:31.667
and some of it's
running here,

00:39:31.667 --> 00:39:33.567
I don't know how long
that would take to propagate.

00:39:33.567 --> 00:39:35.667
But, yes, it looks like
you see a consistent view

00:39:35.667 --> 00:39:38.367
of the memcache world regardless
of where your code is.

00:39:38.367 --> 00:39:40.701
man: Just surprised
that that's future-proof,

00:39:40.701 --> 00:39:43.767
because, you know, once you get
to the Facebook scale,

00:39:43.767 --> 00:39:45.901
maybe you guys--maybe you
need multiple memcache...

00:39:45.901 --> 00:39:47.501
Peck: Yeah!

00:39:47.501 --> 00:39:49.000
man: for the same writer.

00:39:49.000 --> 00:39:50.400
Livni: Yeah, I mean,
we've had good luck with it,

00:39:50.400 --> 00:39:51.868
but I'd say that's
a really good question

00:39:51.868 --> 00:39:53.400
for the folks
who actually built it.

00:39:53.400 --> 00:39:55.567
Would have, uh,
better answers than we would.

00:39:55.567 --> 00:39:58.033
Kocher: They also have a--
you know, the memcache

00:39:58.033 --> 00:39:59.734
has a certain size
and, you know,

00:39:59.734 --> 00:40:00.934
the more you put in there,

00:40:00.934 --> 00:40:02.567
the more you increase pressure
on your memcache

00:40:02.567 --> 00:40:04.400
and the sooner things
will expire from it.

00:40:04.400 --> 00:40:06.434
So there's really
a--a balancing act

00:40:06.434 --> 00:40:08.467
about figuring out
which things to put in there.

00:40:08.467 --> 00:40:10.834
Um, and, you know,,
the size of your entities

00:40:10.834 --> 00:40:12.734
matters when you're
putting things in.

00:40:12.734 --> 00:40:14.901
So choosing that, you're--

00:40:14.901 --> 00:40:17.000
you're making
a lot of decisions

00:40:17.000 --> 00:40:18.734
that will affect
how available that data is

00:40:18.734 --> 00:40:20.133
when you go back
to look for it later.

00:40:20.133 --> 00:40:21.267
Livni: I think there's one
actually small thing

00:40:21.267 --> 00:40:22.434
I should mention on that,

00:40:22.434 --> 00:40:24.234
which is when you write
to a memcache,

00:40:24.234 --> 00:40:25.701
I believe it gets deleted.

00:40:25.701 --> 00:40:27.434
First created, first out.

00:40:27.434 --> 00:40:30.300
Not last updated, uh, out.

00:40:30.300 --> 00:40:34.033
And so when we refresh
on memcache key,

00:40:34.033 --> 00:40:36.601
I believe we delete the key
and then recreate it.

00:40:36.601 --> 00:40:38.968
rather than just updating it.

00:40:38.968 --> 00:40:41.133
So that way,
it's got a fresher date

00:40:41.133 --> 00:40:43.200
and is less likely
to get migrated

00:40:43.200 --> 00:40:47.501
should more contention
happen in memcache.

00:40:47.501 --> 00:40:50.501
man: I have a couple
of questions.

00:40:50.501 --> 00:40:54.234
First is about your API.

00:40:54.234 --> 00:40:56.133
You sort of had
a very simple diagram,

00:40:56.133 --> 00:40:59.868
but the queuing that you do

00:40:59.868 --> 00:41:01.968
when you don't have
the latitude and the longitude,

00:41:01.968 --> 00:41:05.267
does your API
just return queued up?

00:41:05.267 --> 00:41:08.801
Like, I mean,
in case the query is for--

00:41:08.801 --> 00:41:12.067
for a latitude and longitude
that you haven't calculated,

00:41:12.067 --> 00:41:13.968
do you just return queued up?

00:41:13.968 --> 00:41:15.300
Peck: Yeah, that's right.

00:41:15.300 --> 00:41:16.567
Our API returns
to the customer

00:41:16.567 --> 00:41:18.033
"Try back later" basically.

00:41:18.033 --> 00:41:19.901
If you think
about the typical use case

00:41:19.901 --> 00:41:21.667
of embedding
in a real estate site,

00:41:21.667 --> 00:41:24.033
what that means is
the customer doesn't display

00:41:24.033 --> 00:41:25.534
the walk score that time,

00:41:25.534 --> 00:41:26.968
but the next time
that one of their users

00:41:26.968 --> 00:41:28.667
comes and looks
at that same property,

00:41:28.667 --> 00:41:30.467
we'll probably have
that walk score queued up

00:41:30.467 --> 00:41:31.534
and ready for them.

00:41:31.534 --> 00:41:32.901
Man: Okay.

00:41:32.901 --> 00:41:35.400
And the other question
is about, uh--

00:41:35.400 --> 00:41:39.767
So you use this metric
of queries per second

00:41:39.767 --> 00:41:43.567
when you were describing
the techniques to speed up,

00:41:43.567 --> 00:41:46.033
like using memcache
and everything.

00:41:46.033 --> 00:41:47.300
Kocher: Yeah.

00:41:47.300 --> 00:41:49.000
man: So this queries
per second I'm assuming

00:41:49.000 --> 00:41:51.067
is like datastore queries
that you are saying, right?

00:41:51.067 --> 00:41:52.367
Peck: Oh, no.

00:41:52.367 --> 00:41:53.667
When I was showing those
queries per second numbers,

00:41:53.667 --> 00:41:55.567
what I was showing
is the number

00:41:55.567 --> 00:41:57.934
of your successful
URL requests

00:41:57.934 --> 00:42:00.934
that someone outside of our--
of the App Engine data center

00:42:00.934 --> 00:42:04.334
can make to our application
and get running correctly.

00:42:04.334 --> 00:42:05.901
And those numbers were rough.

00:42:05.901 --> 00:42:07.767
They won't apply
to your application exactly,

00:42:07.767 --> 00:42:09.868
but that's approximately what
we saw in the development

00:42:09.868 --> 00:42:11.067
of the Walk Score API.

00:42:11.067 --> 00:42:12.467
Livni: They're also a little
bit better now.

00:42:12.467 --> 00:42:13.767
If you were
to write the same App

00:42:13.767 --> 00:42:15.033
that we did early on,

00:42:15.033 --> 00:42:17.267
you would get, I think,
much higher queries

00:42:17.267 --> 00:42:20.934
per second today
than eight months ago.

00:42:20.934 --> 00:42:22.701
Peck: Yeah, I mean,
the bottom line message is that

00:42:22.701 --> 00:42:24.901
with---even with naive code
you can actually scale out

00:42:24.901 --> 00:42:26.167
pretty far with App Engine.

00:42:26.167 --> 00:42:27.601
It's pretty impressive.

00:42:27.601 --> 00:42:28.934
man: I have two questions.

00:42:28.934 --> 00:42:31.300
The first one is,
are you now running

00:42:31.300 --> 00:42:34.801
your entire production
frontend off of App Engine?

00:42:34.801 --> 00:42:36.234
Peck: Yes, we do.

00:42:36.234 --> 00:42:39.367
man: So if we go to
www.walkscore.com, it's--

00:42:39.367 --> 00:42:40.701
Kocher: Oh, right.

00:42:40.701 --> 00:42:43.033
No, we're only doing
the API there.

00:42:43.033 --> 00:42:44.701
Uh, we are looking at--

00:42:44.701 --> 00:42:47.367
we're considering
moving other parts.

00:42:47.367 --> 00:42:48.534
You know, either the tile

00:42:48.534 --> 00:42:50.400
or potentially even
the whole website over.

00:42:50.400 --> 00:42:54.467
And, uh, you could mention
quickly the Caucho stuff.

00:42:54.467 --> 00:42:56.901
Peck: Yeah, yesterday--
so the Walk Score website itself

00:42:56.901 --> 00:42:58.434
is actually written in PHP.

00:42:58.434 --> 00:43:02.300
Um, and as you know,
JVM now on App Engine.

00:43:02.300 --> 00:43:03.734
And there's a company here
called Caucho

00:43:03.734 --> 00:43:07.133
which makes a PHP implementation
for--for the JVM.

00:43:07.133 --> 00:43:09.367
And actually yesterday,
we're able to

00:43:09.367 --> 00:43:14.033
port our entire PHP website
over to App Engine.

00:43:14.033 --> 00:43:16.734
And we just started
testing it,

00:43:16.734 --> 00:43:18.501
but it looks like
it's extremely performing,

00:43:18.501 --> 00:43:19.934
which is impressive.

00:43:19.934 --> 00:43:21.334
It's a lot faster
than running Apache

00:43:21.334 --> 00:43:23.868
on a private server
at some randomized P.

00:43:23.868 --> 00:43:26.901
Um, yeah, the API itself,
however, is all,

00:43:26.901 --> 00:43:29.534
of course, Python
and App Engine code.

00:43:29.534 --> 00:43:31.601
man: And second question is,

00:43:31.601 --> 00:43:35.334
have you run into any of
the big limits of App Engine

00:43:35.334 --> 00:43:36.968
in terms of the storage index

00:43:36.968 --> 00:43:39.334
as you mentioned
in your last slide?

00:43:39.334 --> 00:43:41.534
Have there been
any big things

00:43:41.534 --> 00:43:42.901
where you end up
having to be billed

00:43:42.901 --> 00:43:45.467
for a lot more
than you expected?

00:43:45.467 --> 00:43:47.634
Kocher: Uh, we haven't.

00:43:47.634 --> 00:43:52.200
They--they gave us, you know,
as early users of--

00:43:52.200 --> 00:43:54.667
early high traffic users,
they gave us access

00:43:54.667 --> 00:43:57.501
to go beyond those
initial free quotas,

00:43:57.501 --> 00:44:00.501
you know, before
the billing was enabled.

00:44:00.501 --> 00:44:02.300
Now that billing is enabled,

00:44:02.300 --> 00:44:05.100
there's a lot more
flexibility to go,

00:44:05.100 --> 00:44:06.801
and you can use a lot.

00:44:06.801 --> 00:44:08.767
So we haven't really run
into those limits.

00:44:08.767 --> 00:44:12.033
I think the things
that are interesting

00:44:12.033 --> 00:44:14.934
are the per request limits
of, you know,

00:44:14.934 --> 00:44:16.334
how much CPU time you can use

00:44:16.334 --> 00:44:18.567
and how much time
you can use it.

00:44:18.567 --> 00:44:20.801
We have, uh,

00:44:20.801 --> 00:44:24.400
some of the EC2
to App Engine communication.

00:44:24.400 --> 00:44:27.367
Some of those things do--
they use way more CPU time

00:44:27.367 --> 00:44:29.234
than App Engine
is really happy with.

00:44:29.234 --> 00:44:32.501
But because they're much less
frequent than the public calls

00:44:32.501 --> 00:44:34.534
that come in at
a much higher rate,

00:44:34.534 --> 00:44:36.234
we can manage those.

00:44:36.234 --> 00:44:39.234
And we use some backing off
techniques where if EC2

00:44:39.234 --> 00:44:40.901
has trouble communicating
it can say,

00:44:40.901 --> 00:44:42.100
"Oh, we're gonna stop

00:44:42.100 --> 00:44:43.534
talking to App Engine
for a little while.

00:44:43.534 --> 00:44:47.300
Stop hitting it with these
high CPU-intensive requests."

00:44:47.300 --> 00:44:49.100
Peck: If you want,
I can take this.

00:44:49.100 --> 00:44:51.067
Kocher: Um, sure.

00:44:51.067 --> 00:44:53.467
Peck: Uh, so considering
that calculating walk scores

00:44:53.467 --> 00:44:55.133
requires considerable time,

00:44:55.133 --> 00:44:57.200
would you consider
using web hooks?

00:44:57.200 --> 00:45:00.133
And actually,
I was in Brett's talk

00:45:00.133 --> 00:45:03.033
just--just previous,
and the answer is yes.

00:45:03.033 --> 00:45:04.701
I think we'd love
to use web hooks.

00:45:04.701 --> 00:45:06.234
We haven't used them yet.

00:45:06.234 --> 00:45:08.100
Uh, but it might be something
for us to look at.

00:45:08.100 --> 00:45:10.167
And certainly
for those who were there,

00:45:10.167 --> 00:45:11.334
I think you've
probably guessed

00:45:11.334 --> 00:45:12.934
that a lot
of our calculator code

00:45:12.934 --> 00:45:16.534
fits nicely with the task queue
API that he described.

00:45:19.434 --> 00:45:21.033
Kocher: Um, yes, go ahead.

00:45:21.033 --> 00:45:23.234
man: Could you please
elaborate a little bit

00:45:23.234 --> 00:45:28.133
into how you implemented
the, um--

00:45:28.133 --> 00:45:29.601
how you implemented

00:45:29.601 --> 00:45:31.567
between the queries
of your App Engine

00:45:31.567 --> 00:45:36.734
and the computational intensive
part of Amazon EC2?

00:45:36.734 --> 00:45:38.701
Peck: Sure, I mean,
I can dig a little more

00:45:38.701 --> 00:45:41.100
into the design
of the calculator.

00:45:41.100 --> 00:45:43.400
Um...basically,
the calculator is currently--

00:45:43.400 --> 00:45:45.734
Wow, okay we got
a bunch of random stuff.

00:45:45.734 --> 00:45:48.033
Um, so the calculator is,
of course,

00:45:48.033 --> 00:45:51.033
completely running on at EC2.

00:45:51.033 --> 00:45:52.734
And it's actually running
on a single machine,

00:45:52.734 --> 00:45:54.634
but it's lots
and lots of processes.

00:45:54.634 --> 00:45:55.934
Kocher: Do you want to jump
to the slide in here?

00:45:55.934 --> 00:45:58.000
Peck: Actually, I wanted
to jump to that one.

00:45:58.000 --> 00:46:00.067
And so
the key thing that we saw

00:46:00.067 --> 00:46:02.033
because of the unpredictable
performance reading

00:46:02.033 --> 00:46:03.501
from the queue
that we've implemented

00:46:03.501 --> 00:46:05.133
on the App Engine side

00:46:05.133 --> 00:46:07.901
is that we wanted
to decouple the computation

00:46:07.901 --> 00:46:10.200
of a walk score
from the IO address we made.

00:46:10.200 --> 00:46:12.033
So what we have
is a master process

00:46:12.033 --> 00:46:13.501
that spawns off
a ton of slaves.

00:46:13.501 --> 00:46:14.734
Some of those slaves
are responsible

00:46:14.734 --> 00:46:16.601
for talking to App Engine

00:46:16.601 --> 00:46:18.367
and requesting
new latitudes and longitudes

00:46:18.367 --> 00:46:20.033
that we need to calculate.

00:46:20.033 --> 00:46:23.300
Um, and what we do is we
have a rather large buffer

00:46:23.300 --> 00:46:24.767
on the Amazon EC2 side

00:46:24.767 --> 00:46:26.701
of latitudes and longitudes
coming in

00:46:26.701 --> 00:46:29.100
so that if we can't talk
to App Engine for a while,

00:46:29.100 --> 00:46:31.434
we can continue
to calculate scores.

00:46:31.434 --> 00:46:32.868
Uh, so that's
one major thing.

00:46:32.868 --> 00:46:34.300
We basically decoupled
our IO

00:46:34.300 --> 00:46:35.901
from our computation
on the EC2 side

00:46:35.901 --> 00:46:37.901
and we buffered all our IO.

00:46:37.901 --> 00:46:40.901
Um, and sort of one last point
which Jesse alluded to

00:46:40.901 --> 00:46:44.167
is that we dynamically respond
to the changing IO conditions.

00:46:44.167 --> 00:46:47.767
So if App Engine is--
if contention is very high

00:46:47.767 --> 00:46:50.400
for more than, say,
10 or 15 requests in a row,

00:46:50.400 --> 00:46:52.667
what we do
is we actually back off

00:46:52.667 --> 00:46:54.767
and stop talking
to App Engine for a while.

00:46:54.767 --> 00:46:56.767
And, um, for various reasons

00:46:56.767 --> 00:46:58.868
based on the internal design
of the datastore,

00:46:58.868 --> 00:47:00.801
that's something that can
actually alleviate contention

00:47:00.801 --> 00:47:02.701
if we come back
20 minutes later

00:47:02.701 --> 00:47:04.200
and just work through
the buffer--

00:47:04.200 --> 00:47:06.901
the data that's buffered
on the EC2 side.

00:47:06.901 --> 00:47:09.067
So that's--that's sort of
the big picture of the design

00:47:09.067 --> 00:47:11.167
of of the calculator.

00:47:11.167 --> 00:47:13.667
man: All right so it was--
it was roughly one database

00:47:13.667 --> 00:47:16.400
and you used rsync or something
like that between--

00:47:16.400 --> 00:47:18.133
Peck: Oh, so--so
actually App Engine

00:47:18.133 --> 00:47:19.534
is our data master.

00:47:19.534 --> 00:47:21.300
All of our data is there.

00:47:21.300 --> 00:47:23.701
Um, all of the points
that we're working on

00:47:23.701 --> 00:47:25.634
on the EC2 side
are simply held in RAM.

00:47:25.634 --> 00:47:29.767
If that process crashes,
it's not the end of the world.

00:47:29.767 --> 00:47:31.901
We basically
might redo a few points.

00:47:31.901 --> 00:47:35.133
Um, we actually--
the EC2 code is also Python,

00:47:35.133 --> 00:47:38.334
so if we--
if we except out of a process,

00:47:38.334 --> 00:47:42.400
we actually just pickle out
all the current data.

00:47:42.400 --> 00:47:43.601
So...

00:47:43.601 --> 00:47:45.534
man: Okay, thanks.

00:47:48.000 --> 00:47:49.400
Kocher: Any other questions?

00:47:49.400 --> 00:47:50.834
Peck: Do we have
Moderator questions?

00:47:50.834 --> 00:47:51.901
Kocher: That was
the only one.

00:47:51.901 --> 00:47:54.868
Peck: That was it.
Thanks, guys.

00:47:54.868 --> 00:47:56.534
Livni: Yep, thanks, guys.

00:47:56.534 --> 00:47:58.801
[applause]

