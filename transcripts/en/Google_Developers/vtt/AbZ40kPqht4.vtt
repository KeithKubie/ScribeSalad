WEBVTT
Kind: captions
Language: en

00:00:01.112 --> 00:00:02.320
DAMIEN MABIN: So I am Damien.

00:00:02.320 --> 00:00:05.103
I am a developer advocate for
video games here at Google.

00:00:05.103 --> 00:00:07.270
And before that, I have
been doing games development

00:00:07.270 --> 00:00:10.120
for about eight years.

00:00:10.120 --> 00:00:12.440
We all try to build
games that are unique.

00:00:12.440 --> 00:00:14.500
We all try to build
games that are special.

00:00:14.500 --> 00:00:17.980
And yet they all have one common
point-- they all have bugs.

00:00:17.980 --> 00:00:21.430
So I'm going to talk a little
bit about how to handle them,

00:00:21.430 --> 00:00:22.490
especially on Android.

00:00:22.490 --> 00:00:25.030
Android is well-known for
being a platform where

00:00:25.030 --> 00:00:26.440
apps are made in Java.

00:00:26.440 --> 00:00:29.380
Making games is
mostly C++'s job,

00:00:29.380 --> 00:00:33.370
although some game engines use
scripting languages, like C#.

00:00:33.370 --> 00:00:36.310
In most cases, either you
are working with C++ directly

00:00:36.310 --> 00:00:39.280
or with a scripting
language debugging bugs.

00:00:39.280 --> 00:00:41.720
And Android can be a challenge.

00:00:41.720 --> 00:00:45.585
So let's see how we
can make that fairly--

00:00:45.585 --> 00:00:47.290
a little bit easier.

00:00:47.290 --> 00:00:48.870
There are three
parts in fixing bugs.

00:00:48.870 --> 00:00:50.820
The first one is
obviously collecting them.

00:00:50.820 --> 00:00:52.987
If you don't know about the
bug, and if they are not

00:00:52.987 --> 00:00:55.170
properly clustered, you
can't really fix them.

00:00:55.170 --> 00:00:56.820
After you have your
collection of bugs,

00:00:56.820 --> 00:01:00.120
you need to find out which
one you should be fixing next.

00:01:00.120 --> 00:01:02.790
It's rare that
someone has the time

00:01:02.790 --> 00:01:05.080
to fix every single
bug out there.

00:01:05.080 --> 00:01:09.060
And finally, you need to
get done with it and fix it.

00:01:09.060 --> 00:01:13.572
So let's see, a little bit,
how the collection part works.

00:01:13.572 --> 00:01:15.030
While you are
developing your game,

00:01:15.030 --> 00:01:18.360
there is multiple staging in it,
obviously, during development.

00:01:18.360 --> 00:01:20.130
You will likely be
using a debug build.

00:01:20.130 --> 00:01:25.020
And hopefully you are
used to adb logcat

00:01:25.020 --> 00:01:27.360
so you can collect
the bugs through that.

00:01:27.360 --> 00:01:30.780
Then later, during
QA, mostly, you

00:01:30.780 --> 00:01:32.260
will be using a release build.

00:01:32.260 --> 00:01:35.470
And also, you will have
access to adb and logcat.

00:01:35.470 --> 00:01:37.080
And finally, during
production, it's

00:01:37.080 --> 00:01:38.820
a slightly different
story, right?

00:01:38.820 --> 00:01:41.860
Because your user out there
will not connect a USB cable,

00:01:41.860 --> 00:01:46.870
install a Android SDK, launch
adb, and send you a stack trace

00:01:46.870 --> 00:01:47.760
by email.

00:01:47.760 --> 00:01:49.860
So you are going to have
to rely on Android vitals

00:01:49.860 --> 00:01:52.250
or Crashlytics to get the
stack trace back to you.

00:01:55.350 --> 00:01:57.628
OK, let's start
with development.

00:01:57.628 --> 00:01:59.420
There is a little bit
of text on the slide.

00:01:59.420 --> 00:02:00.970
Sometimes it's a
little bit small.

00:02:00.970 --> 00:02:03.050
Don't read it too much.

00:02:03.050 --> 00:02:05.470
So that's what you
get out of logcat

00:02:05.470 --> 00:02:09.110
get right when you debug--

00:02:09.110 --> 00:02:11.830
when you have a crash
in the debuggable build,

00:02:11.830 --> 00:02:14.795
a build that contained
the bugs in [INAUDIBLE]..

00:02:14.795 --> 00:02:17.170
Pretty much, right away, it
gives you all the information

00:02:17.170 --> 00:02:18.010
you need, right?

00:02:18.010 --> 00:02:20.600
I think if you have read that
multiple times in the past,

00:02:20.600 --> 00:02:22.420
you can see that
it's a signal 11.

00:02:22.420 --> 00:02:24.340
You can see that
there is, somewhere,

00:02:24.340 --> 00:02:26.890
someone that is freeing a
pointer that has already been

00:02:26.890 --> 00:02:29.560
freed before, or not allocated.

00:02:29.560 --> 00:02:30.740
Who knows?

00:02:30.740 --> 00:02:32.560
And if you look at
the bottom part,

00:02:32.560 --> 00:02:34.570
you can see that there
is a function called

00:02:34.570 --> 00:02:38.770
MainActivity_button2 that is
calling another function called

00:02:38.770 --> 00:02:42.880
hdr_record_value, in turn,
calling hdr_record_values.

00:02:42.880 --> 00:02:46.340
And somewhere it's crashing
in counts_index_for.

00:02:46.340 --> 00:02:49.630
Well, that's quite nice to
understand which function

00:02:49.630 --> 00:02:51.490
is crashing right
away without having

00:02:51.490 --> 00:02:55.230
to do much more work than
looking at your logcat.

00:02:55.230 --> 00:02:59.580
During QA, that stack
trace turned out into that.

00:02:59.580 --> 00:03:02.280
That's a little bit less digest.

00:03:02.280 --> 00:03:04.640
You get function address.

00:03:04.640 --> 00:03:10.080
And I'm not so good with
understanding that 841e should

00:03:10.080 --> 00:03:15.280
be some name for a C++ function.

00:03:15.280 --> 00:03:17.385
So we will see, a little bit--

00:03:17.385 --> 00:03:18.930
we'll see, just
after that, how you

00:03:18.930 --> 00:03:21.455
can take that stack
trace and symbolicate it

00:03:21.455 --> 00:03:24.330
so that you have the real name
and even the line of code that

00:03:24.330 --> 00:03:25.720
is crashing.

00:03:25.720 --> 00:03:28.470
And if you look at production,
well, in production,

00:03:28.470 --> 00:03:30.590
when you launch--

00:03:30.590 --> 00:03:34.040
sorry, in production, when you
launch a-- oh no, sorry, wait,

00:03:34.040 --> 00:03:37.230
there is actually no
adb in production.

00:03:37.230 --> 00:03:41.570
So in production, you will
have to use either Crashlytics

00:03:41.570 --> 00:03:43.950
or Android vitals.

00:03:43.950 --> 00:03:46.010
So I think you already
heard about both of them

00:03:46.010 --> 00:03:47.200
earlier today.

00:03:47.200 --> 00:03:50.460
I'm just going to quickly
brush through the difference

00:03:50.460 --> 00:03:52.536
between each of these.

00:03:52.536 --> 00:03:56.140
So Android vitals is
pretty much out-of-the-box.

00:03:56.140 --> 00:03:58.080
If you publish a
game on Play Store,

00:03:58.080 --> 00:03:59.920
and you go in the Play
Developer Console,

00:03:59.920 --> 00:04:02.090
and you look at the
Android vitals section,

00:04:02.090 --> 00:04:04.113
you will see, right
away, your crashes.

00:04:04.113 --> 00:04:05.530
And the crashes
there will already

00:04:05.530 --> 00:04:07.137
contain the stack trace.

00:04:07.137 --> 00:04:08.970
However the stack trace
is not symbolicated,

00:04:08.970 --> 00:04:10.690
so you will just have--

00:04:10.690 --> 00:04:13.150
as we had during AQ
with the release build--

00:04:13.150 --> 00:04:15.960
you will just have the
C++ function address.

00:04:19.649 --> 00:04:22.580
If you look at Crashlytics
on the other side,

00:04:22.580 --> 00:04:24.550
Crashlytics will call
your own SDK integration.

00:04:24.550 --> 00:04:27.630
So if you haven't integrated
it, obviously, it's not working.

00:04:27.630 --> 00:04:29.230
It's cross-platform--
iOS, Android--

00:04:29.230 --> 00:04:32.870
and supports Java,
C++, and Unity.

00:04:32.870 --> 00:04:35.370
And it will symbolicate
the stack trace right away

00:04:35.370 --> 00:04:36.870
in Crashlytics console.

00:04:36.870 --> 00:04:39.630
So if you go there and you
look at your stack traces,

00:04:39.630 --> 00:04:42.340
you will already have the
name of the function where--

00:04:42.340 --> 00:04:46.230
of the stack as well as the
line where it's crashing.

00:04:46.230 --> 00:04:48.270
There is one little
detail in Android vitals

00:04:48.270 --> 00:04:50.010
that makes it slightly unique.

00:04:50.010 --> 00:04:53.590
It's that it uploads
the crash independently

00:04:53.590 --> 00:04:55.900
from your game execution.

00:04:55.900 --> 00:04:57.820
It's really important
for one reason--

00:04:57.820 --> 00:05:01.600
the worst crash you can have in
a game is when you launch it,

00:05:01.600 --> 00:05:03.010
and it's crashing right away.

00:05:03.010 --> 00:05:05.660
And you try to launch it
again, and it's crashing again.

00:05:05.660 --> 00:05:07.690
If you are in the boot
loop-- in a crash that

00:05:07.690 --> 00:05:10.080
happened during the
boot, it's very difficult

00:05:10.080 --> 00:05:13.470
to detect if you are relying
on SDK being integrated.

00:05:13.470 --> 00:05:15.900
Because the SDK will
upload the crash while

00:05:15.900 --> 00:05:17.420
the game is running.

00:05:17.420 --> 00:05:19.670
But if its crashing
at start, there

00:05:19.670 --> 00:05:22.270
is no way for the SDK
to upload the crash.

00:05:22.270 --> 00:05:23.990
Android vitals,
however-- what happened

00:05:23.990 --> 00:05:26.450
is that your game
crashed during the boot.

00:05:26.450 --> 00:05:29.180
The crash is being--
the stack trace

00:05:29.180 --> 00:05:31.760
is being registered by
the OS, by Android itself.

00:05:31.760 --> 00:05:34.290
And Play Store will
upload it later.

00:05:34.290 --> 00:05:36.920
So even if you have a crash
that happened during boot,

00:05:36.920 --> 00:05:38.840
Android vitals will surface it.

00:05:38.840 --> 00:05:41.360
It makes it very unique.

00:05:41.360 --> 00:05:45.342
OK, so now let's see how it
looks like for Android vitals.

00:05:45.342 --> 00:05:47.300
As I was saying earlier,
it doesn't symbolicate

00:05:47.300 --> 00:05:49.250
the stack trace, which
means that you will

00:05:49.250 --> 00:05:50.840
have to do some manual work.

00:05:50.840 --> 00:05:52.930
The first thing is,
go in Android vitals,

00:05:52.930 --> 00:05:54.650
copy the stack trace.

00:05:54.650 --> 00:05:57.760
The second thing is, when
you compile your game,

00:05:57.760 --> 00:05:59.530
you need to keep
the debug symbol

00:05:59.530 --> 00:06:02.980
and store it somewhere in
your favorite file system.

00:06:02.980 --> 00:06:05.620
And after that, you will
use an [INAUDIBLE] table

00:06:05.620 --> 00:06:08.550
called ndk-stack that is
part of the Android NDK.

00:06:08.550 --> 00:06:11.520
And with the stack trace
plus the debug symbol,

00:06:11.520 --> 00:06:14.140
you will be able to
symbolicate the stack trace.

00:06:14.140 --> 00:06:17.790
And once you did that once, you
just repeat with the next bug.

00:06:17.790 --> 00:06:19.470
Let's see how it looks like.

00:06:19.470 --> 00:06:20.730
You go in Android vitals.

00:06:20.730 --> 00:06:23.030
You can see that, in
this simple game I made,

00:06:23.030 --> 00:06:26.910
there is two crashes, one
that says, "New in version 4."

00:06:26.910 --> 00:06:29.130
if you click on
that one, you can

00:06:29.130 --> 00:06:31.780
see the highlighted
blue part at the bottom.

00:06:31.780 --> 00:06:32.820
That is the stack trace.

00:06:32.820 --> 00:06:34.680
As you can see there,
the stack trace

00:06:34.680 --> 00:06:38.160
doesn't contain any
name for any function.

00:06:38.160 --> 00:06:40.520
So you copy-paste
that stack trace

00:06:40.520 --> 00:06:45.090
wherever you want in a text file
in your development machine.

00:06:45.090 --> 00:06:48.650
And then you use ndk-stack,
that is part of the Android NDK,

00:06:48.650 --> 00:06:50.700
with your debug
symbol on one side.

00:06:50.700 --> 00:06:52.310
And the last part
of the argument

00:06:52.310 --> 00:06:55.320
will be the text file
containing the stack trace.

00:06:55.320 --> 00:06:58.410
And what you get out
of it is a lot of text.

00:06:58.410 --> 00:07:01.270
Let's zoom a little bit.

00:07:01.270 --> 00:07:03.810
So that's what I had in
my text file originally.

00:07:03.810 --> 00:07:07.630
You can see, pretty much
no information for a human.

00:07:07.630 --> 00:07:10.910
And what you get after executing
ndk-stack is quite a lot

00:07:10.910 --> 00:07:11.610
better.

00:07:11.610 --> 00:07:14.000
You can see that it's
crashing in Game.cpp,

00:07:14.000 --> 00:07:17.990
line 26 when it's indicating a
function called Button2() that

00:07:17.990 --> 00:07:21.110
is, itself, calling a
function in Game.cpp,

00:07:21.110 --> 00:07:25.010
line 31 calling
TrackStats(), and et cetera.

00:07:25.010 --> 00:07:27.530
You can see that, at the end,
it's crashing in a function

00:07:27.530 --> 00:07:32.570
called hdr_record_value,
line 404.

00:07:32.570 --> 00:07:35.230
Hopefully you can find 404.

00:07:35.230 --> 00:07:39.090
OK, let's see, now, how it
looks like in Crashlytics.

00:07:39.090 --> 00:07:40.820
In Crashlytics,
it's a lot easier.

00:07:40.820 --> 00:07:42.980
As I was saying earlier,
in Crashlytics console,

00:07:42.980 --> 00:07:45.810
you will already have this
stack trace being symbolicated.

00:07:45.810 --> 00:07:48.110
So right away, you can
see that, for this craft,

00:07:48.110 --> 00:07:50.590
it is a little bit different
from the previous one.

00:07:50.590 --> 00:07:54.020
It's crashing line 104
of hdr_histogram.c.

00:07:54.020 --> 00:07:56.690
So that helps you
pinpoint exactly where

00:07:56.690 --> 00:07:58.620
the crash happened.

00:07:58.620 --> 00:08:01.110
Now that you know exactly
where the crash happened,

00:08:01.110 --> 00:08:03.260
how do you prioritize them?

00:08:03.260 --> 00:08:06.980
90% of the time, when I look at
games that people haven't been

00:08:06.980 --> 00:08:09.950
too careful about crashes
in the past, what I see

00:08:09.950 --> 00:08:12.040
is this kind of separation.

00:08:12.040 --> 00:08:15.440
I see, on the right side,
the blue part, very few bugs

00:08:15.440 --> 00:08:16.790
that impact a lot of users.

00:08:16.790 --> 00:08:20.220
Obviously, these ones are very
important to fix right now.

00:08:20.220 --> 00:08:24.160
And the green ones are
somewhat medium amount

00:08:24.160 --> 00:08:27.430
of crashes that impact
quite some users,

00:08:27.430 --> 00:08:29.652
but not nearly as
many as the blue one.

00:08:29.652 --> 00:08:32.110
And obviously, you will have
a lot of bugs that impact very

00:08:32.110 --> 00:08:33.760
few users.

00:08:33.760 --> 00:08:36.070
So it's easy to
prioritize the blue ones

00:08:36.070 --> 00:08:37.400
if there is five of them.

00:08:37.400 --> 00:08:39.700
But what happens if
there is 100 of them?

00:08:39.700 --> 00:08:41.980
Or what happens if you
have very few blue ones

00:08:41.980 --> 00:08:45.462
that you can fix very quickly,
but you have 500 green ones.

00:08:45.462 --> 00:08:47.170
So let's see how you
can prioritize them.

00:08:47.170 --> 00:08:51.033
I think the secret there lies
into planning for the future.

00:08:51.033 --> 00:08:53.200
And you need to ask yourself
three questions to plan

00:08:53.200 --> 00:08:56.380
for the future of your game
in the coming months or years.

00:08:56.380 --> 00:08:57.968
The first one is how--

00:08:57.968 --> 00:09:00.010
to understand the future,
it's nice to understand

00:09:00.010 --> 00:09:01.090
where you are now.

00:09:01.090 --> 00:09:05.140
So understand how many impacted
users exist right now for one

00:09:05.140 --> 00:09:06.690
specific cluster of game--

00:09:06.690 --> 00:09:08.990
of crash.

00:09:08.990 --> 00:09:13.040
Once you know how many users
are impacted, you need to think,

00:09:13.040 --> 00:09:16.590
are these users growing in
size or decreasing in size?

00:09:16.590 --> 00:09:19.960
A good example is,
maybe all these users

00:09:19.960 --> 00:09:22.060
are using an old
version of Android that

00:09:22.060 --> 00:09:23.840
is decreasing in popularity.

00:09:23.840 --> 00:09:28.240
So maybe this crash will resolve
by itself if you wait a week.

00:09:28.240 --> 00:09:33.190
Or maybe they are all
happening on Android 8.0,

00:09:33.190 --> 00:09:35.090
and it's growing over months.

00:09:35.090 --> 00:09:38.120
So it's going to be
worse in a month.

00:09:38.120 --> 00:09:39.970
And finally, it's
really important

00:09:39.970 --> 00:09:41.710
to try and understand,
based on where

00:09:41.710 --> 00:09:43.240
the crash is
happening, when does

00:09:43.240 --> 00:09:45.430
it happen in the user session.

00:09:45.430 --> 00:09:48.280
If it happened very early
on, it's probably really bad.

00:09:48.280 --> 00:09:51.040
If it happened after 15
minutes of gameplay, maybe

00:09:51.040 --> 00:09:53.590
the user will just
relaunch the game.

00:09:53.590 --> 00:09:56.380
So let's see, a bit, how you
can understand better if it's

00:09:56.380 --> 00:09:59.800
going to grow or decrease--

00:09:59.800 --> 00:10:02.110
for one specific bug,
if it's going to occur

00:10:02.110 --> 00:10:03.590
more or less in a month.

00:10:03.590 --> 00:10:06.430
If you go in Android vitals,
you have this information

00:10:06.430 --> 00:10:07.890
for your game right away.

00:10:07.890 --> 00:10:09.810
That gives you, for
each version of Android,

00:10:09.810 --> 00:10:12.850
how many weekly active
users you have--

00:10:12.850 --> 00:10:15.740
sorry, in this case, it's
monthly active users.

00:10:15.740 --> 00:10:18.800
And it gives you how it
compared to the previous month.

00:10:18.800 --> 00:10:23.870
So there you can see
that 8.0 had 7,500 users.

00:10:23.870 --> 00:10:28.870
And it increased by 4.7%
compared to previous month.

00:10:28.870 --> 00:10:31.300
And you can see that for
each version of Android.

00:10:31.300 --> 00:10:32.900
I find that a little
bit hard to read,

00:10:32.900 --> 00:10:35.350
so I usually extract
it in that format.

00:10:35.350 --> 00:10:37.870
For each version of Android,
I have the amount of users

00:10:37.870 --> 00:10:39.910
and if it's increasing
or decreasing

00:10:39.910 --> 00:10:43.433
in amount month over month.

00:10:43.433 --> 00:10:45.350
So I highlight, in red,
the version of Android

00:10:45.350 --> 00:10:46.870
I care the most about.

00:10:46.870 --> 00:10:48.310
And I highlight,
in green, the one

00:10:48.310 --> 00:10:51.330
that I care a bit less about.

00:10:51.330 --> 00:10:53.040
And then I take each crash--

00:10:53.040 --> 00:10:56.700
that's one crash-- and I look
at which-- from Android vitals--

00:10:56.700 --> 00:10:59.182
and I look at which Android
versions are impacted.

00:10:59.182 --> 00:11:01.140
In this one, I just put
some circles on it that

00:11:01.140 --> 00:11:02.440
reflect the color on the left.

00:11:02.440 --> 00:11:04.620
And you can see that
Android 8.0 is there.

00:11:04.620 --> 00:11:06.120
7.0 is there.

00:11:06.120 --> 00:11:08.730
That crash is probably
somewhat important.

00:11:08.730 --> 00:11:10.100
However, there are crashes.

00:11:10.100 --> 00:11:12.630
And I'm pretty sure you
have some in your game

00:11:12.630 --> 00:11:14.260
that are much worse.

00:11:14.260 --> 00:11:18.590
That's a crash that
was in one of my games.

00:11:18.590 --> 00:11:20.715
It impacted only--
all the crashes--

00:11:20.715 --> 00:11:22.090
all the occurrences
of this crash

00:11:22.090 --> 00:11:24.090
happened on Android 8.0 users.

00:11:24.090 --> 00:11:27.352
And if you see, over the
last month, Android 8.0,

00:11:27.352 --> 00:11:30.190
I had 7,500 users.

00:11:30.190 --> 00:11:34.022
This crash happened 7,400
times over the last month.

00:11:34.022 --> 00:11:35.980
I am not sure if it's a
one-to-one relationship

00:11:35.980 --> 00:11:38.650
between users and crashes,
but it's pretty close.

00:11:38.650 --> 00:11:42.730
So I would say nearly all my
Android 8.0 users are impacted.

00:11:42.730 --> 00:11:45.830
And this crash, month over
month, is going to grow by 5%,

00:11:45.830 --> 00:11:47.070
more or less.

00:11:47.070 --> 00:11:49.070
So it's really important
for me to focus my time

00:11:49.070 --> 00:11:50.750
on fixing that crash,
although the number

00:11:50.750 --> 00:11:52.167
of occurrences of
this crash might

00:11:52.167 --> 00:11:53.390
be a bit lower than others.

00:11:57.040 --> 00:12:00.320
If you look at
some other crashes,

00:12:00.320 --> 00:12:01.910
sometimes it's a lot easier.

00:12:01.910 --> 00:12:06.380
This one, well, there is
only one Android 7.0 crash

00:12:06.380 --> 00:12:08.720
that really matters there.

00:12:08.720 --> 00:12:10.670
So maybe it's not
super high-priority.

00:12:10.670 --> 00:12:12.440
Because month over
month, this crash

00:12:12.440 --> 00:12:14.030
will decrease in
occurrences by 5%.

00:12:17.820 --> 00:12:20.970
OK, so now that we see
how you collect crashes,

00:12:20.970 --> 00:12:24.840
and you have a bit of an idea
how you prioritize them, well,

00:12:24.840 --> 00:12:27.450
for fixing them, there
is really no trick there.

00:12:27.450 --> 00:12:29.497
Sadly, that's your job.

00:12:29.497 --> 00:12:30.330
I can't really help.

00:12:30.330 --> 00:12:33.462
It's really game-specific there.

00:12:33.462 --> 00:12:35.832
So let's recap a
little bit for today.

00:12:35.832 --> 00:12:37.290
There is three
things I really want

00:12:37.290 --> 00:12:39.270
you to remember from this talk.

00:12:39.270 --> 00:12:41.662
First one is please
keep the debug symbol.

00:12:41.662 --> 00:12:43.870
How many times I have seen
the developers, at launch,

00:12:43.870 --> 00:12:47.940
in an APK have critical crashes,
and didn't keep the debug

00:12:47.940 --> 00:12:50.520
symbol, and is left over
with stack traces that

00:12:50.520 --> 00:12:54.010
contain function addresses
and no way how to read them.

00:12:54.010 --> 00:12:55.300
It's quite sad.

00:12:55.300 --> 00:12:57.180
So even if it's
just by pure safety

00:12:57.180 --> 00:12:59.200
because your game has
zero crashes right now,

00:12:59.200 --> 00:13:03.036
every time you compile an
APK, keep the debug symbol.

00:13:03.036 --> 00:13:05.120
If you don't know how
to get the debug symbol,

00:13:05.120 --> 00:13:06.740
you can search for it.

00:13:06.740 --> 00:13:09.770
It's really not that difficult.

00:13:09.770 --> 00:13:11.870
Second thing is Android vitals--

00:13:11.870 --> 00:13:15.270
even if you don't care
about your crashes too much,

00:13:15.270 --> 00:13:16.970
go take a look at
Android vitals.

00:13:16.970 --> 00:13:20.430
It will help you understand
how bad the problem is.

00:13:20.430 --> 00:13:23.270
The truth is that,
hopefully, the problem is not

00:13:23.270 --> 00:13:24.710
so bad for you,
and you don't need

00:13:24.710 --> 00:13:26.240
to focus too much time on it.

00:13:26.240 --> 00:13:29.420
But maybe you will find
out that your users are

00:13:29.420 --> 00:13:32.090
having 5% crashes every day.

00:13:32.090 --> 00:13:33.980
And in that case,
Android vitals will

00:13:33.980 --> 00:13:36.830
be able to help you
understand if you

00:13:36.830 --> 00:13:40.700
need the help of Crashlytics
to debug all these crashes.

00:13:40.700 --> 00:13:43.520
As I showed earlier, Android
vitals plus ndk-stack

00:13:43.520 --> 00:13:46.940
can be a little bit cumbersome
to work with the stack traces,

00:13:46.940 --> 00:13:47.990
but it works.

00:13:47.990 --> 00:13:50.240
If you see that you have
50 crashes, that's fine.

00:13:50.240 --> 00:13:52.600
If you have 500, maybe
you want to think

00:13:52.600 --> 00:13:55.200
into getting Crashlytics
so that it symbolicates

00:13:55.200 --> 00:13:58.160
the stack trace right away.

00:13:58.160 --> 00:13:59.800
And finally, well,
now that you know

00:13:59.800 --> 00:14:04.858
that there is a way to fix your
crashes in your game, well,

00:14:04.858 --> 00:14:06.900
you should really come to
the next session, where

00:14:06.900 --> 00:14:08.670
Bill will talk about
how you optimize

00:14:08.670 --> 00:14:10.527
the performance of your game.

00:14:10.527 --> 00:14:11.360
Thank you very much.

00:14:11.360 --> 00:14:14.790
[APPLAUSE]

00:14:21.020 --> 00:14:22.920
BILL BILODEAU: Thanks, Damien.

00:14:22.920 --> 00:14:26.610
So let's talk a little
bit about why you might

00:14:26.610 --> 00:14:29.350
want to optimize your game.

00:14:29.350 --> 00:14:33.490
One of the obvious reasons is
to get better-looking games.

00:14:33.490 --> 00:14:36.760
Who here doesn't want
their game to look better?

00:14:36.760 --> 00:14:39.590
Now with all that extra
rendering you need to do,

00:14:39.590 --> 00:14:44.280
you'll have to optimize the
game to still make it run fast.

00:14:44.280 --> 00:14:47.070
Another reason is to make
the game more responsive.

00:14:47.070 --> 00:14:49.610
And this is important
for games that

00:14:49.610 --> 00:14:52.400
are very competitive,
like multiplayer games,

00:14:52.400 --> 00:14:56.060
or games that require quick
response time because they're

00:14:56.060 --> 00:14:57.170
fast-paced games.

00:14:59.790 --> 00:15:01.800
You should also
optimize for memory.

00:15:01.800 --> 00:15:03.880
Because you don't want
your game crashing

00:15:03.880 --> 00:15:05.130
because it runs out of memory.

00:15:07.930 --> 00:15:10.610
And you should consider
optimizing for power.

00:15:10.610 --> 00:15:12.790
Because these are
mobile devices.

00:15:12.790 --> 00:15:14.500
They have a battery.

00:15:14.500 --> 00:15:16.840
And you want the players
to be able to play

00:15:16.840 --> 00:15:20.080
the game a long time without
running down the battery.

00:15:20.080 --> 00:15:24.580
The other reason is because
power is related to heat.

00:15:24.580 --> 00:15:29.590
And when the device
heats up, the system

00:15:29.590 --> 00:15:32.920
will throttle the CPU, which
will cause it to run slower.

00:15:36.180 --> 00:15:40.800
So let's look at some CPU
performance optimizations.

00:15:40.800 --> 00:15:45.570
One of the best things you can
do is to do multithreading.

00:15:45.570 --> 00:15:49.080
So high-end Android
devices have eight cores.

00:15:49.080 --> 00:15:54.060
And it's really a waste to just
not use some of those cores.

00:15:54.060 --> 00:15:57.060
A single-threaded core--
single-threaded game

00:15:57.060 --> 00:15:58.320
is a waste.

00:15:58.320 --> 00:16:02.760
So one of the things we know
is that multithreading--

00:16:02.760 --> 00:16:04.740
and of course, concurrent
multithreading,

00:16:04.740 --> 00:16:08.640
which is really the optimal
way of doing multithreading--

00:16:08.640 --> 00:16:12.430
has better performance per
watt than single-threading.

00:16:12.430 --> 00:16:13.810
So it affects perform--

00:16:13.810 --> 00:16:14.860
affects power as well.

00:16:17.560 --> 00:16:20.800
You've probably all heard
that it's good to batch.

00:16:20.800 --> 00:16:22.720
And this is still true.

00:16:22.720 --> 00:16:25.900
Every draw call has
overhead with it,

00:16:25.900 --> 00:16:27.920
driver overhead with it.

00:16:27.920 --> 00:16:32.740
So if you can combine draw
calls into a single draw call,

00:16:32.740 --> 00:16:35.450
that's going to help
with that CPU overhead.

00:16:38.710 --> 00:16:41.230
Game engines like
Unity, they have

00:16:41.230 --> 00:16:44.890
options for doing dynamic
and static batching, which

00:16:44.890 --> 00:16:46.640
can help with that.

00:16:46.640 --> 00:16:48.852
The other thing you want
to do is not draw things

00:16:48.852 --> 00:16:50.060
that you're not going to see.

00:16:50.060 --> 00:16:54.480
So things like frustrum
culling and occlusion culling

00:16:54.480 --> 00:16:55.585
are important.

00:16:58.200 --> 00:17:02.010
Vulkan is a good API for
reducing the draw call

00:17:02.010 --> 00:17:03.180
overhead.

00:17:03.180 --> 00:17:06.569
The Vulkan API doesn't
require validation

00:17:06.569 --> 00:17:08.220
being done for every draw call.

00:17:08.220 --> 00:17:11.800
And that's how it saves time.

00:17:11.800 --> 00:17:15.390
The other thing that's good
about Vulkan is you can do--

00:17:15.390 --> 00:17:19.359
you can build command buffers
using multiple threads.

00:17:19.359 --> 00:17:21.661
And so now this takes
advantage of multithreading,

00:17:21.661 --> 00:17:22.619
as I mentioned earlier.

00:17:26.510 --> 00:17:29.262
You don't want to
overlook loading times.

00:17:29.262 --> 00:17:30.720
The reason is
because loading times

00:17:30.720 --> 00:17:32.310
can affect if your
players are going

00:17:32.310 --> 00:17:34.110
to continue to play the game.

00:17:34.110 --> 00:17:37.300
If it takes too long
to load the game,

00:17:37.300 --> 00:17:39.760
it may not be worth it to them.

00:17:39.760 --> 00:17:43.170
So some of the things you can
do to improve loading time

00:17:43.170 --> 00:17:46.940
include, just pick a
good compression format--

00:17:46.940 --> 00:17:49.710
so one that decompresses fast.

00:17:49.710 --> 00:17:51.210
An example could be LZ4.

00:17:53.715 --> 00:17:57.680
The other thing you want to
do is only load what you need.

00:17:57.680 --> 00:17:59.590
You don't want to
load the entire level

00:17:59.590 --> 00:18:01.060
when you're only going to be--

00:18:01.060 --> 00:18:03.910
sorry, you don't want to
load the entire game when

00:18:03.910 --> 00:18:07.610
you're only playing one level.

00:18:07.610 --> 00:18:10.460
The other thing you should
do is to hide the loading.

00:18:10.460 --> 00:18:13.393
So even though you're
still loading the game,

00:18:13.393 --> 00:18:14.810
you don't want to
make it obvious,

00:18:14.810 --> 00:18:19.590
like having a big loading
bar like in this diagram.

00:18:19.590 --> 00:18:21.620
So something you
could do is like, when

00:18:21.620 --> 00:18:23.780
the user is navigating
through the menus,

00:18:23.780 --> 00:18:27.200
you can load things
in the background.

00:18:27.200 --> 00:18:31.250
And for Unity,
IL2CPP has been shown

00:18:31.250 --> 00:18:32.990
to have really good performance.

00:18:32.990 --> 00:18:39.500
So even for not just loading,
general CPU performance,

00:18:39.500 --> 00:18:40.250
you should IL2CPP.

00:18:44.270 --> 00:18:47.300
So we're going to
be asking developers

00:18:47.300 --> 00:18:52.490
to use 64-bit and have a
64-bit version of their APK

00:18:52.490 --> 00:18:55.010
later this year.

00:18:55.010 --> 00:18:59.590
And this is also a good thing,
because 64-bit gives you

00:18:59.590 --> 00:19:01.990
better performance.

00:19:01.990 --> 00:19:07.200
It can because the 64-bit
instruction set has access

00:19:07.200 --> 00:19:12.510
to twice as many registers
as a 32-bit instruction set,

00:19:12.510 --> 00:19:15.820
even though they're
running on the same device.

00:19:15.820 --> 00:19:18.100
Because of this,
the compiler can

00:19:18.100 --> 00:19:20.920
use those registers to
do better optimizations

00:19:20.920 --> 00:19:22.240
and make your code run faster.

00:19:24.985 --> 00:19:27.110
So now let's take a look
at the GPU side of things.

00:19:30.230 --> 00:19:35.940
One of the most common reasons
for a game to be GPU-bound

00:19:35.940 --> 00:19:38.350
and to spend a lot
of time on a GPU

00:19:38.350 --> 00:19:43.050
is when it spends time
in the fragment shaders.

00:19:43.050 --> 00:19:45.560
So the more pixels
you're rendering,

00:19:45.560 --> 00:19:48.970
the more time it's
going to take.

00:19:48.970 --> 00:19:55.300
Now modern devices, they have
incredibly dense displays.

00:19:55.300 --> 00:19:58.780
And so it's really
overkill for most games.

00:19:58.780 --> 00:20:01.900
You can render a game at
a much lower resolution,

00:20:01.900 --> 00:20:05.080
and it'll still look just fine.

00:20:05.080 --> 00:20:07.600
Now you might be
thinking that, well,

00:20:07.600 --> 00:20:10.120
when I render it at
a lower resolution,

00:20:10.120 --> 00:20:12.880
the problem is the text
starts to look blurry.

00:20:12.880 --> 00:20:14.510
Well, a couple of
things you can do--

00:20:14.510 --> 00:20:17.470
one is you can
reduce the resolution

00:20:17.470 --> 00:20:21.220
in one dimension, just either
vertically or horizontally.

00:20:21.220 --> 00:20:22.360
That can help.

00:20:22.360 --> 00:20:24.490
Another thing you
can do is you can

00:20:24.490 --> 00:20:28.240
render the text, or the HUD,
at full-screen resolution

00:20:28.240 --> 00:20:32.990
and composite it with the
lower-resolution version.

00:20:32.990 --> 00:20:36.200
Now you can do this
in a fragment shader.

00:20:36.200 --> 00:20:40.510
For example, if you're doing
post-processing anyway,

00:20:40.510 --> 00:20:43.400
what you can do is combine
that with the upscaling

00:20:43.400 --> 00:20:44.840
and the compositing.

00:20:44.840 --> 00:20:48.710
And then in one step, you
can get that combined.

00:20:48.710 --> 00:20:50.390
The other thing you
can do in some cases

00:20:50.390 --> 00:20:53.810
is to use the hardware composer.

00:20:53.810 --> 00:20:58.160
All Android devices
have hardware composers

00:20:58.160 --> 00:21:01.740
that can composite
multiple layers of images.

00:21:05.770 --> 00:21:09.060
So if it's not fill-rate-bound
and pixel-shader-bound,

00:21:09.060 --> 00:21:12.960
it's the other end,
which is geometry-bound.

00:21:12.960 --> 00:21:17.260
So you want to reduce
the number of vertices.

00:21:17.260 --> 00:21:19.390
And the way to do this,
the common way to do this,

00:21:19.390 --> 00:21:21.770
is, of course, to use LODs.

00:21:21.770 --> 00:21:25.710
Now some GPUs are more
capable than others.

00:21:25.710 --> 00:21:28.640
So what you can do is adjust
that LOD distance based

00:21:28.640 --> 00:21:31.380
on the capability of the GPU.

00:21:31.380 --> 00:21:37.970
So higher-end GPUs, you can
extend that high-detailed LOD

00:21:37.970 --> 00:21:38.600
out further.

00:21:41.650 --> 00:21:43.900
The other thing you can do
is take that to the extreme

00:21:43.900 --> 00:21:50.050
and have imposters, which are
just 2D geometry with textures

00:21:50.050 --> 00:21:51.970
to represent 3D geometry.

00:21:51.970 --> 00:21:56.170
And when something is far out
in the distance, it looks fine.

00:21:59.900 --> 00:22:04.590
So now, getting back
to responsiveness,

00:22:04.590 --> 00:22:06.720
the important thing
about responsiveness

00:22:06.720 --> 00:22:09.690
is consistent responsiveness.

00:22:09.690 --> 00:22:12.510
One of the things that happens
is, if that responsiveness

00:22:12.510 --> 00:22:15.980
is not consistent, if that
touch latency isn't consistent,

00:22:15.980 --> 00:22:17.700
the game just kind
of feels wrong.

00:22:17.700 --> 00:22:21.250
Like, it has a bad feel to it.

00:22:21.250 --> 00:22:26.670
Here's an example of a game
that was captured with systrace.

00:22:26.670 --> 00:22:31.440
And you can see the actual frame
times for individual frames.

00:22:31.440 --> 00:22:32.740
Some of the frames are fast.

00:22:32.740 --> 00:22:34.290
Some are slow.

00:22:34.290 --> 00:22:36.510
But interestingly,
it all averages out

00:22:36.510 --> 00:22:38.290
to 30 frames per second.

00:22:38.290 --> 00:22:39.535
So if all of your--

00:22:39.535 --> 00:22:41.160
if the only thing
that you're measuring

00:22:41.160 --> 00:22:43.200
is average frames
per second, this

00:22:43.200 --> 00:22:46.880
could be completely overlooked.

00:22:46.880 --> 00:22:48.710
With Android, one of
the things you can do

00:22:48.710 --> 00:22:51.420
is use the choreographer API.

00:22:51.420 --> 00:22:53.360
And this allows you
to register callbacks

00:22:53.360 --> 00:22:56.210
that happen every
Vsync, which you can use

00:22:56.210 --> 00:22:57.816
to synchronize your rendering.

00:23:01.080 --> 00:23:02.750
Now, you want to
optimize for power,

00:23:02.750 --> 00:23:06.500
as I said, because it's
important on mobile devices.

00:23:06.500 --> 00:23:10.880
Some games really do work better
with 60 frames per second.

00:23:10.880 --> 00:23:14.330
But most games-- you know,
slower-paced games that

00:23:14.330 --> 00:23:16.400
aren't fighting games
or something like that--

00:23:16.400 --> 00:23:18.990
they can run well at
30 frames per second.

00:23:18.990 --> 00:23:22.343
So even if your game can
run at 60 frames per second,

00:23:22.343 --> 00:23:24.260
it's better for it to
run at 30 because you're

00:23:24.260 --> 00:23:25.700
saving so much power.

00:23:25.700 --> 00:23:27.020
You're doing half as much work.

00:23:30.800 --> 00:23:33.860
Also you want to consider
offloading things to the GPU.

00:23:33.860 --> 00:23:36.830
The reason is the GPU
is more power-efficient.

00:23:36.830 --> 00:23:41.240
It does more things in
parallel than the CPU.

00:23:41.240 --> 00:23:43.700
an example could
be doing animation

00:23:43.700 --> 00:23:46.040
on the GPU like GPU skinning.

00:23:49.590 --> 00:23:53.390
Thread affinity is a
great way to manage power.

00:23:53.390 --> 00:23:56.920
Linux gives you the
ability to manage threads

00:23:56.920 --> 00:23:59.450
with thread affinity.

00:23:59.450 --> 00:24:02.033
And as you can see
in this example,

00:24:02.033 --> 00:24:03.950
you don't want to schedule
all of your threads

00:24:03.950 --> 00:24:06.230
necessarily on the big cores.

00:24:06.230 --> 00:24:09.965
The big cores are typically
cores four through seven.

00:24:09.965 --> 00:24:13.460
The little cores are the first
cores, zero through three.

00:24:13.460 --> 00:24:17.360
The little cores aren't
as fast, but they

00:24:17.360 --> 00:24:19.140
are more power-efficient.

00:24:19.140 --> 00:24:21.920
So if you had something-- a
thread, say, for example--

00:24:21.920 --> 00:24:24.910
that wasn't really
performance-critical,

00:24:24.910 --> 00:24:29.120
and say it was doing something
like asynchronous loading

00:24:29.120 --> 00:24:32.828
for streaming assets
for future frames,

00:24:32.828 --> 00:24:34.370
then you could
probably put something

00:24:34.370 --> 00:24:35.495
like that on a little core.

00:24:39.950 --> 00:24:43.140
So now let's look at memory.

00:24:43.140 --> 00:24:47.565
Optimizing for memory can be
difficult on mobile devices.

00:24:47.565 --> 00:24:49.190
One of the reasons
is you're not always

00:24:49.190 --> 00:24:51.590
sure how much memory you
have available to you.

00:24:51.590 --> 00:24:54.800
Because you're sharing the
memory with the system,

00:24:54.800 --> 00:24:56.390
with other apps.

00:24:56.390 --> 00:25:00.800
And so you can't expect to use
all of that physical memory.

00:25:03.470 --> 00:25:05.555
So let's take a look
at this, for example.

00:25:05.555 --> 00:25:07.660
This is a Pixel 3.

00:25:07.660 --> 00:25:12.720
And it has 1.6 gigabytes
for system memory--

00:25:12.720 --> 00:25:14.820
that's used by the system.

00:25:14.820 --> 00:25:17.320
Now, you can't expect
to evict all that memory

00:25:17.320 --> 00:25:18.910
and use it all for your game.

00:25:18.910 --> 00:25:21.260
So on a 4-gigabyte
system, in this case,

00:25:21.260 --> 00:25:24.250
you might be able to use
2 gigabytes of memory.

00:25:27.692 --> 00:25:29.650
Now, if you want to reduce
the amount of memory

00:25:29.650 --> 00:25:31.870
that your game is using,
one of the things you can do

00:25:31.870 --> 00:25:35.320
is use a shader cache.

00:25:35.320 --> 00:25:37.840
The shade cache--
an LRU shader cache

00:25:37.840 --> 00:25:40.240
is actually used by
the Unreal Engine.

00:25:40.240 --> 00:25:41.950
So you could use that feature.

00:25:44.480 --> 00:25:50.880
So the way it works is you can
make sure that only the shaders

00:25:50.880 --> 00:25:53.140
that you're interested
in, that you're using,

00:25:53.140 --> 00:25:56.390
are cached in the GPU memory.

00:25:56.390 --> 00:26:00.210
OpenGL with Vulkan, both,
you can extract shaders

00:26:00.210 --> 00:26:02.930
from the GPU memory,
compress the binaries,

00:26:02.930 --> 00:26:06.050
and store them in CPU memory.

00:26:06.050 --> 00:26:08.430
Now you're trading off
GPU memory for CPU memory.

00:26:08.430 --> 00:26:12.230
But that's OK, because it's
all the same physical memory,

00:26:12.230 --> 00:26:15.078
because it's a unified
memory architecture.

00:26:18.220 --> 00:26:21.630
And finally, for testing memory,
one thing you want to consider

00:26:21.630 --> 00:26:25.180
is testing on
real-world situations.

00:26:25.180 --> 00:26:28.650
For example, you want
to test on devices which

00:26:28.650 --> 00:26:32.050
have a lot of apps installed.

00:26:32.050 --> 00:26:35.770
We found that when you
have some apps installed,

00:26:35.770 --> 00:26:40.147
they can take up memory, even
though you may not expect that.

00:26:40.147 --> 00:26:41.980
So you don't want to
test on a clean device.

00:26:44.332 --> 00:26:46.290
DANIEL GALPIN: So I'm
here for the comic relief

00:26:46.290 --> 00:26:49.396
part of our day.

00:26:49.396 --> 00:26:51.360
And this talk is about
rogue permissions.

00:26:51.360 --> 00:26:54.070
And I'm sure you're wondering
exactly what that really means.

00:26:54.070 --> 00:26:57.690
And so I have a visual aid.

00:26:57.690 --> 00:27:02.628
And essentially, what we're
about here is what happens--

00:27:02.628 --> 00:27:04.170
you know, when you're
writing a game,

00:27:04.170 --> 00:27:06.420
much of the code that is
actually going into your game

00:27:06.420 --> 00:27:09.420
is stuff that you
actually haven't written.

00:27:09.420 --> 00:27:11.730
And so rogue permissions,
in this case--

00:27:11.730 --> 00:27:13.730
DANIEL GALPIN (PIRATE
ACCENT): --are permissions

00:27:13.730 --> 00:27:15.360
that are not used
by the game itself,

00:27:15.360 --> 00:27:18.030
but are instead used by
the libraries and tools

00:27:18.030 --> 00:27:19.950
that your game depends on.

00:27:19.950 --> 00:27:21.900
So for this talk,
"rogue" really refers

00:27:21.900 --> 00:27:23.557
to code that you didn't write.

00:27:23.557 --> 00:27:25.140
And I probably should
have entitled it

00:27:25.140 --> 00:27:28.710
something like, you know,
"Be wary of rogue code,"

00:27:28.710 --> 00:27:29.830
but I digress.

00:27:29.830 --> 00:27:31.390
And you're also
probably wondering,

00:27:31.390 --> 00:27:33.510
am I to keep this accent
for the rest of the talk?

00:27:33.510 --> 00:27:36.730
And the answer is, I will not.

00:27:36.730 --> 00:27:39.930
DANIEL GALPIN: So what
I wanted to point out

00:27:39.930 --> 00:27:45.150
here is that when we're
talking about these things,

00:27:45.150 --> 00:27:48.510
we are talking about this
combination of privacy

00:27:48.510 --> 00:27:51.840
and performance equals
policy-- or to alliterate,

00:27:51.840 --> 00:27:53.220
we passionately
pledge to promote

00:27:53.220 --> 00:27:56.520
privacy and performance, which
leads to pertinent policy.

00:27:56.520 --> 00:28:00.120
And an example of
this, when you're

00:28:00.120 --> 00:28:02.400
looking at a library
or SDK, you really

00:28:02.400 --> 00:28:05.910
need to be asking yourself
a bunch of questions.

00:28:05.910 --> 00:28:09.270
One is, does this library
or SDK actually want

00:28:09.270 --> 00:28:12.090
unnecessary access
to sensitive data?

00:28:12.090 --> 00:28:14.370
And the second thing
is, what impact

00:28:14.370 --> 00:28:16.620
does it have on the app
performance, or even worse,

00:28:16.620 --> 00:28:18.850
on system health in general?

00:28:18.850 --> 00:28:20.640
And so let's say
something that a--

00:28:20.640 --> 00:28:22.890
DANIEL GALPIN (PIRATE ACCENT):
--possibly rogue code--

00:28:22.890 --> 00:28:25.642
DANIEL GALPIN: --might need
is the location permission.

00:28:25.642 --> 00:28:27.600
Now first of all, there's
two types of location

00:28:27.600 --> 00:28:28.392
that it might need.

00:28:28.392 --> 00:28:31.290
There's course location
and find location.

00:28:31.290 --> 00:28:34.440
And honestly, to your game,
it really doesn't matter.

00:28:34.440 --> 00:28:37.670
Because on Android M,
they're both kind of bad.

00:28:37.670 --> 00:28:40.170
Because you end up having to
pop up this runtime permission,

00:28:40.170 --> 00:28:41.212
and it's really terrible.

00:28:41.212 --> 00:28:44.730
And most likely,
your libraries aren't

00:28:44.730 --> 00:28:47.610
going to be needing
this because of that.

00:28:47.610 --> 00:28:50.310
But if they do, it's
really important.

00:28:50.310 --> 00:28:51.990
Because users need
to be informed

00:28:51.990 --> 00:28:56.620
that not only is this app able
to track sensitive information,

00:28:56.620 --> 00:28:59.820
such as their location,
but also that the device

00:28:59.820 --> 00:29:02.280
is likely to drain their
battery much faster.

00:29:08.621 --> 00:29:11.170
A-ha, and in Android
O, we actually

00:29:11.170 --> 00:29:14.080
attempted to mitigate
some of the battery drain

00:29:14.080 --> 00:29:16.120
problems with
location by limiting

00:29:16.120 --> 00:29:18.460
how often background
apps actually get access

00:29:18.460 --> 00:29:19.660
to this location data.

00:29:19.660 --> 00:29:22.090
And we honestly still
have more work to do here.

00:29:22.090 --> 00:29:25.550
So the moral of this
story, so to speak,

00:29:25.550 --> 00:29:29.890
is that location, as an
example, is an intersection

00:29:29.890 --> 00:29:31.600
of performance and privacy.

00:29:31.600 --> 00:29:37.900
And this influences both the way
that the Play Store as well as

00:29:37.900 --> 00:29:41.480
the platform look at policy.

00:29:41.480 --> 00:29:45.520
So again, there's a whole
bunch of these permissions.

00:29:45.520 --> 00:29:47.020
And if you need to
get access to any

00:29:47.020 --> 00:29:49.000
of these kind of
sensitive permissions,

00:29:49.000 --> 00:29:52.700
you really need to understand
why this is happening.

00:29:52.700 --> 00:29:55.322
It's very, very important.

00:29:55.322 --> 00:29:57.030
Now one of the things
you should look for

00:29:57.030 --> 00:29:58.738
is that Android library
projects, these--

00:29:58.738 --> 00:30:00.780
DANIEL GALPIN (PIRATE
ACCENT): --SDKs and tools--

00:30:00.780 --> 00:30:03.240
DANIEL GALPIN: --can
include library permissions.

00:30:03.240 --> 00:30:06.940
So they actually have their
own Android manifests.

00:30:06.940 --> 00:30:09.900
And once again, we can use
our favorite tool, the APK

00:30:09.900 --> 00:30:12.480
Analyzer, to actually look
at all of the permissions

00:30:12.480 --> 00:30:15.665
that your app is actually
going to end up requesting.

00:30:15.665 --> 00:30:17.040
And it's really
important, again,

00:30:17.040 --> 00:30:20.100
for you to understand why
your game ends up requesting

00:30:20.100 --> 00:30:22.690
each one of these permissions.

00:30:22.690 --> 00:30:25.320
Now plugins also are libraries.

00:30:25.320 --> 00:30:27.940
And so they can also contain
permissions in native code.

00:30:27.940 --> 00:30:31.240
So we to make sure
they're also compliant.

00:30:31.240 --> 00:30:34.900
And finally, we
want to make sure

00:30:34.900 --> 00:30:38.785
that you are testing with
the latest target SDK.

00:30:38.785 --> 00:30:39.910
These things are important.

00:30:39.910 --> 00:30:42.100
If you saw in
Damien's talk earlier,

00:30:42.100 --> 00:30:44.470
you can actually
end up with crashes

00:30:44.470 --> 00:30:48.670
that only impact certain SDKs.

00:30:48.670 --> 00:30:50.930
So you want to make sure
everything works as expected.

00:30:50.930 --> 00:30:53.590
So you can use things
like Play test tracks,

00:30:53.590 --> 00:30:55.150
which are very, very useful.

00:30:55.150 --> 00:30:58.480
And now for something that can
also be a real problem for code

00:30:58.480 --> 00:31:01.050
that you don't write,
and that is 64-bit.

00:31:01.050 --> 00:31:02.490
And now I know
what you're saying.

00:31:02.490 --> 00:31:04.240
You know, you're
thinking, OK, this

00:31:04.240 --> 00:31:06.040
has nothing to do
with permissions.

00:31:06.040 --> 00:31:09.232
I'm totally going off
the reservation here.

00:31:09.232 --> 00:31:10.690
But it really is
something you have

00:31:10.690 --> 00:31:13.390
to think about when
choosing a library or SDK.

00:31:13.390 --> 00:31:17.200
And besides, we know, from the
history of video game console

00:31:17.200 --> 00:31:22.120
marketing, that
64-bit is just cool.

00:31:22.120 --> 00:31:24.910
So moving to 64-bit
will actually

00:31:24.910 --> 00:31:27.100
make your APK size larger.

00:31:27.100 --> 00:31:29.810
But it will also typically
make your game run faster.

00:31:29.810 --> 00:31:31.715
And there's lots of
reasons for that.

00:31:31.715 --> 00:31:33.340
The 64-bit instruction
set was actually

00:31:33.340 --> 00:31:37.420
designed for performance
over things like code

00:31:37.420 --> 00:31:38.450
size and other things.

00:31:38.450 --> 00:31:40.630
And it actually has
double the registers.

00:31:40.630 --> 00:31:42.490
But more importantly,
it actually

00:31:42.490 --> 00:31:45.430
does things like supports
double precision floating

00:31:45.430 --> 00:31:47.170
point in neon code.

00:31:47.170 --> 00:31:50.355
So your compiler can actually
do really clever vectorization

00:31:50.355 --> 00:31:52.480
and really, really improve
the performance of a lot

00:31:52.480 --> 00:31:54.190
of heavy floating point stuff.

00:31:54.190 --> 00:31:57.550
And you know, it just turns
out that games actually

00:31:57.550 --> 00:32:00.457
take a lot of advantage
of floating point.

00:32:00.457 --> 00:32:02.290
So the good news is
that this won't actually

00:32:02.290 --> 00:32:05.890
make your APK size that much
larger, having a 64-bit binary,

00:32:05.890 --> 00:32:08.375
if you move to
Android app bundles.

00:32:08.375 --> 00:32:10.000
We've talked about
these a whole bunch.

00:32:10.000 --> 00:32:13.420
These are great, because
it actually strips out

00:32:13.420 --> 00:32:15.700
the unnecessary binaries
when you distribute

00:32:15.700 --> 00:32:18.670
your game with an app bundle and
using Google Play app signing.

00:32:18.670 --> 00:32:23.020
So if you have a 32-bit and
a 64-bit binary in your app,

00:32:23.020 --> 00:32:25.600
the device will only get
the one that it actually

00:32:25.600 --> 00:32:27.982
needs the most.

00:32:27.982 --> 00:32:29.690
And while you're at
it, you can do things

00:32:29.690 --> 00:32:34.070
like bundling x86 and
x86-64 support with no size

00:32:34.070 --> 00:32:35.180
penalty to your ARM apps.

00:32:35.180 --> 00:32:37.280
And these versions will
actually work better

00:32:37.280 --> 00:32:40.490
on a lot of Chrome OS devices.

00:32:40.490 --> 00:32:42.680
So with performance
implications,

00:32:42.680 --> 00:32:44.990
this has, of course,
become a Google Play policy

00:32:44.990 --> 00:32:47.310
decision, at least initially.

00:32:47.310 --> 00:32:50.660
So by this August, all
new and updated games

00:32:50.660 --> 00:32:54.610
must include a 64-bit version.

00:32:54.610 --> 00:32:57.760
Now there is an
exception for Unity

00:32:57.760 --> 00:33:01.000
when targeting
Unity 5.6 or less.

00:33:01.000 --> 00:33:02.680
Google Play will
continue to allow

00:33:02.680 --> 00:33:06.100
updating games built with
these older Unity versions

00:33:06.100 --> 00:33:07.720
for another two years.

00:33:07.720 --> 00:33:10.090
And then it won't
deliver any 32-bit games

00:33:10.090 --> 00:33:12.290
to any 64-bit-capable devices.

00:33:12.290 --> 00:33:18.280
Please do not go out and import
your games back to Unity 5.6.

00:33:18.280 --> 00:33:20.590
There's a lot of really
good reasons to actually run

00:33:20.590 --> 00:33:22.590
the newer versions of Unity.

00:33:22.590 --> 00:33:25.120
Now of course, Google also
hasn't made any guarantee that

00:33:25.120 --> 00:33:28.510
we're actually going to have
non-64-bit-only devices by this

00:33:28.510 --> 00:33:30.520
point either.

00:33:30.520 --> 00:33:38.110
And note that you need 27.4.16
if you want to run 64-bit code,

00:33:38.110 --> 00:33:41.290
or 2018.2 or higher.

00:33:41.290 --> 00:33:45.513
Because 64-bit was actually
ported back to 2017.4.16.

00:33:45.513 --> 00:33:46.930
Another thing
you'll need to do is

00:33:46.930 --> 00:33:49.420
switch to the IL2CPP back end.

00:33:49.420 --> 00:33:51.620
And that'll mostly make
your game run faster.

00:33:51.620 --> 00:33:53.290
So it's actually a win-win.

00:33:55.910 --> 00:33:57.660
So some tips for
going to 64-bit--

00:33:57.660 --> 00:34:00.940
one is that, once again, you can
use our favorite tool, the APK

00:34:00.940 --> 00:34:04.690
analyzer, to see what 32-bit
dependencies you might have.

00:34:04.690 --> 00:34:06.900
And you can examine all the
files in the lib folder.

00:34:06.900 --> 00:34:11.340
The 32-bit libraries
or in the armeabi-v7a--

00:34:11.340 --> 00:34:15.270
or even v5, if you still have
them-- and x86 directories.

00:34:15.270 --> 00:34:18.159
Next, you can do a 64-bit build.

00:34:18.159 --> 00:34:21.690
So you know, Cocos, and
Unreal, and Unity all

00:34:21.690 --> 00:34:25.330
support 64-bit code on Android
with the correct settings.

00:34:25.330 --> 00:34:27.480
And also, Gradle,
CMake, and ndk-build

00:34:27.480 --> 00:34:29.280
can easily add 64-bit targets.

00:34:29.280 --> 00:34:31.320
Now obviously,
there's a lot of work

00:34:31.320 --> 00:34:32.790
that you do have
to do to make sure

00:34:32.790 --> 00:34:35.130
that everything in
your native code

00:34:35.130 --> 00:34:37.500
is going to work
correctly with 64-bit.

00:34:37.500 --> 00:34:39.810
I'm under the assumption
that since many of you

00:34:39.810 --> 00:34:42.639
do publish on other
64-bit platforms,

00:34:42.639 --> 00:34:46.030
that most of this code and this
work has already been done.

00:34:46.030 --> 00:34:47.820
But there is
definitely some work

00:34:47.820 --> 00:34:51.000
to make sure that you are doing
all the right things in 64-bit.

00:34:55.540 --> 00:34:58.720
You also may need to
upgrade SDKs and libraries

00:34:58.720 --> 00:35:00.880
to more recent versions.

00:35:00.880 --> 00:35:03.880
And this is an opportunity to
reach out to library owners

00:35:03.880 --> 00:35:07.912
if there are 64-bit-ready
versions that aren't available.

00:35:07.912 --> 00:35:09.370
And this is also
a really good time

00:35:09.370 --> 00:35:13.060
to examine the real need for all
of these external dependencies.

00:35:13.060 --> 00:35:15.040
It's amazing to see,
when you actually

00:35:15.040 --> 00:35:17.650
go through an audit, all of
the things that are in a game.

00:35:17.650 --> 00:35:20.860
All of a sudden, it's like, oh,
my APK size is now 20% smaller.

00:35:20.860 --> 00:35:23.390
Because it turns out we didn't
really need this anymore.

00:35:23.390 --> 00:35:26.740
So it's really good to go back
and do this on a regular basis,

00:35:26.740 --> 00:35:31.610
and take a look at all the stuff
you're putting into your APKs.

00:35:31.610 --> 00:35:33.470
And finally, there is testing.

00:35:33.470 --> 00:35:35.020
You'll want to test locally.

00:35:35.020 --> 00:35:38.950
This is another great example
of using Google Play's test

00:35:38.950 --> 00:35:41.200
tracks.

00:35:41.200 --> 00:35:43.490
You'd also take
advantage of things,

00:35:43.490 --> 00:35:48.100
once you're doing this, like
Android vitals and Crashlytics.

00:35:48.100 --> 00:35:50.890
All these things can help
you get a really good idea

00:35:50.890 --> 00:35:53.837
of how your game is actually
performing in the real world.

00:35:53.837 --> 00:35:55.420
Now, once you've
actually tested this,

00:35:55.420 --> 00:35:57.730
you can leverage staged
rollouts to make sure

00:35:57.730 --> 00:36:00.195
that your users have the
smoothest experience.

00:36:00.195 --> 00:36:01.570
So again, there's
a lot of things

00:36:01.570 --> 00:36:04.300
you can do to test this to
make this experience great.

00:36:04.300 --> 00:36:07.750
Again, mostly 64-bit should
be a win-win for both you

00:36:07.750 --> 00:36:10.040
and your users--

00:36:10.040 --> 00:36:15.200
so four straightforward steps
to get your game to 64-bit.

00:36:15.200 --> 00:36:17.970
Now there is a
moral to this story.

00:36:17.970 --> 00:36:21.207
And that is, performance matters
to us, and hopefully, to you.

00:36:21.207 --> 00:36:22.790
And it's something
you should consider

00:36:22.790 --> 00:36:25.130
when choosing any
code that you didn't

00:36:25.130 --> 00:36:26.865
write to ship with your game.

00:36:26.865 --> 00:36:28.490
So when you're
examining whether or not

00:36:28.490 --> 00:36:31.100
to use a new
library or SDK, make

00:36:31.100 --> 00:36:34.860
sure that it works
with a true 64-bit app.

00:36:34.860 --> 00:36:38.570
Another thing to think about
is API-level targeting.

00:36:38.570 --> 00:36:40.550
Now, for an app or
game to be permitted

00:36:40.550 --> 00:36:42.800
to update on Google
Play, it needs

00:36:42.800 --> 00:36:45.020
to target the latest
Android release

00:36:45.020 --> 00:36:46.940
within a year of its release.

00:36:46.940 --> 00:36:51.080
Now currently, that means
targeting 2017's Oreo,

00:36:51.080 --> 00:36:52.610
but not for much longer.

00:36:52.610 --> 00:36:54.350
Because as of August,
it will actually

00:36:54.350 --> 00:36:57.170
mean targeting 2018's Pie.

00:36:57.170 --> 00:36:59.630
And you need to make sure
that any library or SDK

00:36:59.630 --> 00:37:01.520
that your game
depends upon actually

00:37:01.520 --> 00:37:04.730
supports targeting the
latest API release.

00:37:04.730 --> 00:37:06.650
And this is important,
because there actually

00:37:06.650 --> 00:37:09.590
are some Android
behavior changes that are

00:37:09.590 --> 00:37:11.980
tied to the target SDK version.

00:37:11.980 --> 00:37:14.600
Now Android, in many
cases, actually preserves

00:37:14.600 --> 00:37:17.630
some out-of-date
functionality for apps

00:37:17.630 --> 00:37:21.020
that are targeting older SDK
versions for the purposes

00:37:21.020 --> 00:37:23.870
of compatibility.

00:37:23.870 --> 00:37:25.675
Now, libraries and
SDKs can also do things

00:37:25.675 --> 00:37:27.915
like impacting launch speed.

00:37:27.915 --> 00:37:29.540
You can often mitigate
this, of course,

00:37:29.540 --> 00:37:32.050
by deferring lowering
of these libraries.

00:37:32.050 --> 00:37:33.820
But some libraries
will do things

00:37:33.820 --> 00:37:37.390
like requiring initialization
in the application class, which

00:37:37.390 --> 00:37:39.610
gets initialized before
most of your code.

00:37:39.610 --> 00:37:43.240
Or less obviously, they'll
even contain a content provider

00:37:43.240 --> 00:37:45.700
that makes sure that
the app is initialized

00:37:45.700 --> 00:37:48.050
before even the
libraries-- excuse me,

00:37:48.050 --> 00:37:52.100
is even initialized even before
the application code runs.

00:37:52.100 --> 00:37:54.700
And this is really only
a reasonable solution

00:37:54.700 --> 00:37:57.062
if you're doing things
like crash analytics.

00:37:57.062 --> 00:37:59.020
Because obviously, you
want your crash provider

00:37:59.020 --> 00:38:00.910
to be initialized
very, very early.

00:38:03.530 --> 00:38:05.540
And there we are.

00:38:05.540 --> 00:38:08.120
Fortunately, you can
use the systrace tool

00:38:08.120 --> 00:38:11.600
to profile your launch speed
and see the impacts of libraries

00:38:11.600 --> 00:38:12.170
and SDKs.

00:38:12.170 --> 00:38:15.140
Now sometimes, you might have
so much data coming in here

00:38:15.140 --> 00:38:17.400
that, actually, systrace
isn't a great tool for that.

00:38:17.400 --> 00:38:21.290
So you can also
leverage simpleperf.

00:38:21.290 --> 00:38:23.870
Launching faster, as
we have said before,

00:38:23.870 --> 00:38:26.570
means your game will
likely be played more.

00:38:26.570 --> 00:38:29.500
and with any luck, that'll
translate into dollars.

00:38:29.500 --> 00:38:31.250
And we've got some
great videos on YouTube

00:38:31.250 --> 00:38:34.520
that show how to use systrace
to optimize launch speed

00:38:34.520 --> 00:38:37.710
and profile other
performance problems.

00:38:37.710 --> 00:38:39.670
Now Google Play has
its own policies.

00:38:39.670 --> 00:38:41.753
And you need to make sure
that the library doesn't

00:38:41.753 --> 00:38:42.470
violate those.

00:38:42.470 --> 00:38:44.140
And this is because
Google Play really

00:38:44.140 --> 00:38:46.690
does have a critical role
in protecting the privacy

00:38:46.690 --> 00:38:48.460
and safety of Android devices.

00:38:48.460 --> 00:38:50.530
As an example,
apps aren't allowed

00:38:50.530 --> 00:38:52.603
to sideload code changes.

00:38:52.603 --> 00:38:54.520
Google Play has actually
had to unpublish apps

00:38:54.520 --> 00:38:56.830
when SDK providers
have done things

00:38:56.830 --> 00:38:58.803
that violate Play policies.

00:38:58.803 --> 00:39:00.220
And of course,
multiple violations

00:39:00.220 --> 00:39:01.553
get an account banned from Play.

00:39:01.553 --> 00:39:05.060
So this is really
important stuff.

00:39:05.060 --> 00:39:08.200
And then there are things
that I have absolutely

00:39:08.200 --> 00:39:12.850
no ability whatsoever to advise
you on, other than I strongly

00:39:12.850 --> 00:39:15.400
do encourage you to make sure
that code that you don't write

00:39:15.400 --> 00:39:18.250
is compliant with all
necessary policies

00:39:18.250 --> 00:39:22.740
and regulations from various
entities around the world.

00:39:22.740 --> 00:39:24.490
And of course, you
should test the library

00:39:24.490 --> 00:39:26.810
against the latest
Android version you can,

00:39:26.810 --> 00:39:29.260
such as our recently
released Q beta.

00:39:29.260 --> 00:39:34.540
These are all of the desserts
I could find that begin with Q.

00:39:34.540 --> 00:39:37.330
And Q actually
makes changes that

00:39:37.330 --> 00:39:41.920
continue to improve Android's
speed, privacy, and safety.

00:39:41.920 --> 00:39:44.110
Now, it continues
our work on location

00:39:44.110 --> 00:39:46.810
by actually giving the user
an option to allow a game

00:39:46.810 --> 00:39:50.580
or app to only access location
when in the foreground.

00:39:50.580 --> 00:39:53.850
It also limits access to device
and hardware identifiers,

00:39:53.850 --> 00:39:57.390
such as IMEI, or
serial number, IMSI.

00:39:57.390 --> 00:40:00.360
And it actually
automatically randomizes

00:40:00.360 --> 00:40:04.273
MAC address across
different Wi-Fi networks.

00:40:04.273 --> 00:40:05.190
And this is important.

00:40:05.190 --> 00:40:07.020
Because a lot of
ads in analytics

00:40:07.020 --> 00:40:09.240
packages may not
function correctly

00:40:09.240 --> 00:40:14.220
if they weren't already using
the appropriate identifiers.

00:40:14.220 --> 00:40:16.590
And of course, Q is
bringing a whole bunch

00:40:16.590 --> 00:40:19.140
of updates around
performance, including--

00:40:19.140 --> 00:40:23.612
very exciting to me--
support for Vulkan 1.1.

00:40:23.612 --> 00:40:25.320
We are also doing
something kind of cool.

00:40:25.320 --> 00:40:27.653
I don't know if you've noticed
this in our announcement.

00:40:27.653 --> 00:40:29.670
We're actually supporting,
experimentally,

00:40:29.670 --> 00:40:33.300
OpenGLES 2.0 running
on top of Vulkan

00:40:33.300 --> 00:40:36.120
through the ANGLE project.

00:40:36.120 --> 00:40:36.870
And this is great.

00:40:36.870 --> 00:40:38.703
It's not really going
to affect performance.

00:40:38.703 --> 00:40:40.890
But we hope it will actually
lead, in the long term,

00:40:40.890 --> 00:40:45.358
to more stable OpenGL drivers
and more stable Vulkan drivers.

00:40:45.358 --> 00:40:47.150
And we're also doing
this really cool thing

00:40:47.150 --> 00:40:51.240
in Q called cloud-based,
profile-guided optimizations

00:40:51.240 --> 00:40:52.230
for ART.

00:40:52.230 --> 00:40:55.050
So this means that code
that's actually running inside

00:40:55.050 --> 00:40:58.530
of managed code on
your app will actually

00:40:58.530 --> 00:41:01.380
get profiled and optimized more
quickly, which, of course, just

00:41:01.380 --> 00:41:04.110
means that your users are going
to see better performance more

00:41:04.110 --> 00:41:06.043
quickly.

00:41:06.043 --> 00:41:07.710
And of course, the
best thing you can do

00:41:07.710 --> 00:41:10.290
is to test your game
against the current beta.

00:41:10.290 --> 00:41:12.030
Try running your current build.

00:41:12.030 --> 00:41:14.790
And consider running
a build that actually

00:41:14.790 --> 00:41:17.052
targets the Android Q SDK.

00:41:17.052 --> 00:41:18.510
And you can find
out all about this

00:41:18.510 --> 00:41:21.540
at google.com/android/beta.

00:41:21.540 --> 00:41:24.630
And right now, we're currently
supporting Pixel, and Pixel 2,

00:41:24.630 --> 00:41:28.410
and Pixel 3, and the various
XL versions of all of them.

00:41:28.410 --> 00:41:31.547
So at least this is a
good start with devices.

00:41:31.547 --> 00:41:32.880
And you can sign up right there.

00:41:32.880 --> 00:41:38.490
And we will deliver the beta
to your device wirelessly.

00:41:38.490 --> 00:41:39.120
And that's it.

00:41:39.120 --> 00:41:41.100
So here's a bunch of
resources to find out

00:41:41.100 --> 00:41:43.560
about getting your
apps ready for 64-bit

00:41:43.560 --> 00:41:46.000
as well as some best practices
around that, and of course,

00:41:46.000 --> 00:41:46.710
the beta.

00:41:46.710 --> 00:41:48.840
Up next is our
final talk from Ben

00:41:48.840 --> 00:41:52.198
about how you can extend
your games beyond mobile.

00:41:52.198 --> 00:41:55.410
[APPLAUSE]

00:41:55.558 --> 00:41:57.350
BEN GABLE: As Dan
mentioned, I'm Ben Gable.

00:41:57.350 --> 00:41:59.750
I'm a partner developer
advocate at Google

00:41:59.750 --> 00:42:01.400
working with game developers.

00:42:01.400 --> 00:42:04.850
And today, I'm going to
be talking about extending

00:42:04.850 --> 00:42:07.040
Android games beyond mobile.

00:42:07.040 --> 00:42:09.180
And what do I mean by that?

00:42:09.180 --> 00:42:15.370
So-- whoops, that's
the laser button.

00:42:15.370 --> 00:42:16.680
So mobile gaming is evolving.

00:42:16.680 --> 00:42:19.530
And just a few years
ago, mobile gaming

00:42:19.530 --> 00:42:22.600
used to mean games you
play on your phone.

00:42:22.600 --> 00:42:25.470
But now it's not
so clear anymore.

00:42:25.470 --> 00:42:29.540
The Android ecosystem
is evolving.

00:42:29.540 --> 00:42:31.970
And Android now runs
not only on phones,

00:42:31.970 --> 00:42:35.480
but on tablets, desktop
extension devices like Chrome

00:42:35.480 --> 00:42:38.180
OS and Samsung DeX,
and coming very soon,

00:42:38.180 --> 00:42:43.590
the exciting world of foldables
like the Samsung Galaxy Fold.

00:42:43.590 --> 00:42:47.120
So maybe just a quick
question for the crowd--

00:42:47.120 --> 00:42:51.050
how many of you
have purposefully

00:42:51.050 --> 00:42:53.980
optimized your game for
a device that's not just

00:42:53.980 --> 00:42:55.310
a mobile device?

00:42:55.310 --> 00:42:57.770
Show of hands, anybody?

00:42:57.770 --> 00:42:59.080
I see, like, two hands.

00:42:59.080 --> 00:43:01.700
OK, how many of you are actually
planning on maybe, this year,

00:43:01.700 --> 00:43:05.090
with your next game, adapting
your Android game for a device

00:43:05.090 --> 00:43:06.140
that's not just mobile?

00:43:06.140 --> 00:43:07.740
Anybody?

00:43:07.740 --> 00:43:09.258
OK, a few more
hands-- so hopefully,

00:43:09.258 --> 00:43:11.800
at the end of this talk, there's
a lot more hands that go up.

00:43:11.800 --> 00:43:14.650
But the key point that I
want to drive home here

00:43:14.650 --> 00:43:16.690
is that, as game
developers, you need

00:43:16.690 --> 00:43:19.060
to consider that
your game is not just

00:43:19.060 --> 00:43:23.950
going to be being played
on mobile devices anymore.

00:43:23.950 --> 00:43:26.377
Players might be playing it
on a phone in a portrait mode.

00:43:26.377 --> 00:43:28.210
They might be playing
on a Chromebook or DeX

00:43:28.210 --> 00:43:30.980
with a keyboard and
mouse attached to it.

00:43:30.980 --> 00:43:32.500
They could be
playing on a foldable

00:43:32.500 --> 00:43:33.640
with multiple displays.

00:43:33.640 --> 00:43:35.557
So when they switch open
from the small screen

00:43:35.557 --> 00:43:37.780
to the large screen, the
resolution and aspect ratio

00:43:37.780 --> 00:43:39.118
changes.

00:43:39.118 --> 00:43:41.410
This is really important, to
start thinking about this.

00:43:41.410 --> 00:43:44.020
Because as game
developers, you guys

00:43:44.020 --> 00:43:46.930
want to provide the best
possible gaming experience

00:43:46.930 --> 00:43:48.847
for your players no
matter what device

00:43:48.847 --> 00:43:50.680
they happen to be
experiencing your game on.

00:43:53.310 --> 00:43:56.100
Now I realize that the
words "new platform"

00:43:56.100 --> 00:43:58.070
or "supporting an
additional platform"

00:43:58.070 --> 00:44:00.138
is kind of scary for
a lot of developers.

00:44:00.138 --> 00:44:01.680
But what I really
want to stress here

00:44:01.680 --> 00:44:03.810
is that this is
all still Android.

00:44:03.810 --> 00:44:07.560
And by following the
Android best practices,

00:44:07.560 --> 00:44:10.270
you're going to get a
great baseline experience

00:44:10.270 --> 00:44:14.650
and compatibility across
all these different devices.

00:44:14.650 --> 00:44:19.320
So certainly there's things you
can add specific to foldables,

00:44:19.320 --> 00:44:20.848
or tablets, or Chrome OS.

00:44:20.848 --> 00:44:22.765
But I really want to
focus on the core things,

00:44:22.765 --> 00:44:24.480
the stuff in the middle there.

00:44:24.480 --> 00:44:27.065
That's going to give you a
great experience with the least

00:44:27.065 --> 00:44:27.690
amount of work.

00:44:31.390 --> 00:44:33.970
And hopefully, I've boiled
it down to three main areas

00:44:33.970 --> 00:44:35.150
you need to consider.

00:44:35.150 --> 00:44:37.240
And that is screen
considerations,

00:44:37.240 --> 00:44:40.930
input considerations, and how
to build and set up your APK

00:44:40.930 --> 00:44:43.420
so that when it's
distributed, it can support

00:44:43.420 --> 00:44:45.518
the most devices possible.

00:44:45.518 --> 00:44:47.560
So let's start off with
talking about some screen

00:44:47.560 --> 00:44:48.670
considerations.

00:44:48.670 --> 00:44:50.530
What do I mean by that?

00:44:50.530 --> 00:44:54.830
So when your game is launched
on some of these other devices,

00:44:54.830 --> 00:44:57.345
like a Chromebook or
Samsung DeX, by default,

00:44:57.345 --> 00:44:58.720
your game is going
to be launched

00:44:58.720 --> 00:45:02.980
in a windowed environment where
it can be dynamically resized.

00:45:02.980 --> 00:45:05.470
And on foldables, it'll be
launched in an environment

00:45:05.470 --> 00:45:07.330
where, if the user
opens the device up

00:45:07.330 --> 00:45:10.060
from the smaller screen to
the larger internal screen,

00:45:10.060 --> 00:45:13.840
the aspect ratio and
resolution is going to change.

00:45:13.840 --> 00:45:17.340
So the most important
thing here to support

00:45:17.340 --> 00:45:19.235
is what we call
configuration changes.

00:45:19.235 --> 00:45:20.610
And for those of
you that are not

00:45:20.610 --> 00:45:23.070
familiar with the idea
of configuration changes,

00:45:23.070 --> 00:45:25.860
basically, the Android system
will restart an activity

00:45:25.860 --> 00:45:28.025
every time it detects
that something

00:45:28.025 --> 00:45:29.400
has changed about
the environment

00:45:29.400 --> 00:45:31.890
that your game is running in.

00:45:31.890 --> 00:45:35.250
By default, the system does
this automatically by invoking

00:45:35.250 --> 00:45:38.430
onSaveInstanceState() before
your activity is restarted.

00:45:38.430 --> 00:45:40.860
However, for a lot of
resource-heavy games,

00:45:40.860 --> 00:45:42.120
this is not the best approach.

00:45:42.120 --> 00:45:43.500
It can be really slow.

00:45:43.500 --> 00:45:46.732
And especially in the cases of
things like dynamic resizing,

00:45:46.732 --> 00:45:48.690
where you could be getting
configuration change

00:45:48.690 --> 00:45:51.700
events every frame,
it just doesn't work.

00:45:51.700 --> 00:45:54.330
So what we recommend
as a best practice is

00:45:54.330 --> 00:45:57.000
to handle these configuration
changes yourself.

00:45:57.000 --> 00:46:00.300
And you can do so really easily
by, inside your manifest,

00:46:00.300 --> 00:46:02.400
declaring all of the
configuration changes

00:46:02.400 --> 00:46:04.840
that you want to handle in code.

00:46:04.840 --> 00:46:06.990
So in this example,
we've said we

00:46:06.990 --> 00:46:12.520
want to handle screen size and
orientation changes ourselves.

00:46:12.520 --> 00:46:15.020
So then, once you declare all
the configuration changes that

00:46:15.020 --> 00:46:18.830
you want to support, inside
onConfigurationChanged()

00:46:18.830 --> 00:46:21.140
in your activity, you can--

00:46:21.140 --> 00:46:24.410
whenever that change happens,
you now get an event.

00:46:24.410 --> 00:46:27.260
And you can handle
whatever that change was.

00:46:27.260 --> 00:46:30.320
So for example, you could
scale your OpenGL content

00:46:30.320 --> 00:46:33.260
to match the new resolution
or the aspect ratio

00:46:33.260 --> 00:46:36.170
to prevent things like
inaccessible UI elements

00:46:36.170 --> 00:46:38.930
or input areas that
don't make sense anymore

00:46:38.930 --> 00:46:40.880
with the new resolution
of your game.

00:46:46.150 --> 00:46:48.190
And if your game is
always intended to be run

00:46:48.190 --> 00:46:52.240
in full-screen for example, or
maybe you've got some bugs you

00:46:52.240 --> 00:46:56.410
need to quickly iron them out,
you can always prevent resizing

00:46:56.410 --> 00:46:59.050
by specifying
resizeableActivity="false"

00:46:59.050 --> 00:47:00.100
in your manifest.

00:47:00.100 --> 00:47:03.430
But keep in mind that this will
prevent split-screen operations

00:47:03.430 --> 00:47:04.000
of your game.

00:47:04.000 --> 00:47:05.410
And we don't really
recommend it,

00:47:05.410 --> 00:47:08.290
because it is a
valid user experience

00:47:08.290 --> 00:47:11.230
to have your game running
with Twitch chat or something

00:47:11.230 --> 00:47:14.140
else in those kinds of
windowed environments.

00:47:14.140 --> 00:47:16.650
So we recommend supporting
it whenever you can.

00:47:24.460 --> 00:47:28.210
For orientation--
for mobile devices,

00:47:28.210 --> 00:47:30.760
orientation is, by
default, portrait.

00:47:30.760 --> 00:47:33.230
But on other devices,
it could be landscape.

00:47:33.230 --> 00:47:36.850
So it's important to make
sure that-- in your manifest,

00:47:36.850 --> 00:47:41.020
the best way to handle and
tell the system what kind

00:47:41.020 --> 00:47:44.320
of orientations you support
is to specify your sensor

00:47:44.320 --> 00:47:47.050
orientations in your manifest.

00:47:47.050 --> 00:47:50.350
Now if you're handling
orientation changes yourself

00:47:50.350 --> 00:47:52.750
in code, you want to make
sure that you're using

00:47:52.750 --> 00:47:56.700
Display.getRotation(), as that
will give you the accurate

00:47:56.700 --> 00:47:59.200
information you need in order
to determine which orientation

00:47:59.200 --> 00:48:00.400
the device is in.

00:48:00.400 --> 00:48:03.460
But be aware that the
values you're expecting with

00:48:03.460 --> 00:48:06.730
Display.getRotation() might
be swapped depending on what

00:48:06.730 --> 00:48:09.218
the hardware's default
orientation is.

00:48:09.218 --> 00:48:10.260
So just be aware of that.

00:48:12.970 --> 00:48:14.742
Also consider the
resolution of the device

00:48:14.742 --> 00:48:15.700
that you're playing on.

00:48:15.700 --> 00:48:17.860
So a bigger screen
means you should

00:48:17.860 --> 00:48:20.460
provide high-resolution assets.

00:48:20.460 --> 00:48:22.930
You can use app bundles--
has been mentioned many times

00:48:22.930 --> 00:48:26.200
today-- to package all your
assets and have Google Play

00:48:26.200 --> 00:48:29.080
deliver only the assets that
are relevant to the device that

00:48:29.080 --> 00:48:30.760
your player is playing on--

00:48:30.760 --> 00:48:33.568
so for example, emitting
ultra-high-resolution assets

00:48:33.568 --> 00:48:35.110
if they're playing
on a mobile device

00:48:35.110 --> 00:48:37.450
or only serving up the
ultra-high-resolution assets

00:48:37.450 --> 00:48:40.060
they're playing on
something like a Chromebook

00:48:40.060 --> 00:48:43.430
or a high-resolution tablet.

00:48:43.430 --> 00:48:46.460
This saves you valuable download
space, which is always a win,

00:48:46.460 --> 00:48:49.120
and also the trouble of
maintaining multiple APKs

00:48:49.120 --> 00:48:53.430
for all these different
screen densities.

00:48:53.430 --> 00:48:55.590
And with more pixels
comes greater flexibility

00:48:55.590 --> 00:48:57.660
on UI and HUD design.

00:48:57.660 --> 00:49:00.060
So if your players are
playing on a larger screen,

00:49:00.060 --> 00:49:03.640
consider what kinds of
elements you can expand, add,

00:49:03.640 --> 00:49:07.500
change to take advantage
of that particular display.

00:49:07.500 --> 00:49:10.260
Also, players tend to sit
farther away from a screen

00:49:10.260 --> 00:49:11.350
the bigger it is.

00:49:11.350 --> 00:49:13.890
So make sure that all of
your fonts and elements

00:49:13.890 --> 00:49:15.240
are identifiable and readable.

00:49:15.240 --> 00:49:16.740
Nothing more
frustrating than having

00:49:16.740 --> 00:49:18.120
to squint at a large screen.

00:49:20.698 --> 00:49:22.240
So that's some screen
considerations.

00:49:22.240 --> 00:49:24.000
Let's talk about input now.

00:49:24.000 --> 00:49:27.210
So more and more games are
delivering a console or PC-like

00:49:27.210 --> 00:49:28.710
experience on mobile.

00:49:28.710 --> 00:49:31.050
And more Android
devices are now offering

00:49:31.050 --> 00:49:32.800
multiple ways of input.

00:49:32.800 --> 00:49:36.870
So although Android has had APIs
around for a while for things

00:49:36.870 --> 00:49:39.810
like keyboard, mouse
support, and controllers,

00:49:39.810 --> 00:49:41.880
most game developers
just assume that they're

00:49:41.880 --> 00:49:43.920
going to be playing
with touch controls.

00:49:43.920 --> 00:49:46.350
And that gets really
frustrating when

00:49:46.350 --> 00:49:49.160
players download a game that's
been even ported from a PC

00:49:49.160 --> 00:49:51.508
or console, and they
try to use a keyboard

00:49:51.508 --> 00:49:53.550
or mouse on a Chromebook,
or something like that,

00:49:53.550 --> 00:49:54.670
and it doesn't work.

00:49:54.670 --> 00:49:57.030
It's a pretty
frustrating experience.

00:49:57.030 --> 00:49:58.970
So the other thing
to keep in mind

00:49:58.970 --> 00:50:02.330
is that, also, many of these
devices are convertibles.

00:50:02.330 --> 00:50:05.180
So they can change between
different configurations

00:50:05.180 --> 00:50:09.800
on the fly, such as clamshell
with keyboard to tablet mode.

00:50:09.800 --> 00:50:12.800
So it's important to kind
of detect those changes

00:50:12.800 --> 00:50:17.030
and support on-the-fly control
schemes that provide the best

00:50:17.030 --> 00:50:18.680
user experience at
the time, and try

00:50:18.680 --> 00:50:21.080
to anticipate what you
think the users might

00:50:21.080 --> 00:50:24.230
be expecting the control scheme
to be at that particular time.

00:50:27.150 --> 00:50:29.140
So the best way to do
this, as I mentioned,

00:50:29.140 --> 00:50:31.010
is to detect the
hardware that's available

00:50:31.010 --> 00:50:33.510
and support a control scheme
that will give players the best

00:50:33.510 --> 00:50:35.130
experience.

00:50:35.130 --> 00:50:36.990
So to start, you
might declare, again,

00:50:36.990 --> 00:50:39.630
support in your manifest
to handle configuration

00:50:39.630 --> 00:50:42.690
changes related to
inputs like keyboards

00:50:42.690 --> 00:50:45.770
being attached and detached.

00:50:45.770 --> 00:50:47.270
And there's many
ways of doing this.

00:50:47.270 --> 00:50:51.000
But essentially, you could
then query input manager

00:50:51.000 --> 00:50:54.060
whenever that input change is
detected, or at game start-up,

00:50:54.060 --> 00:50:55.770
and figure out what
kinds of hardware

00:50:55.770 --> 00:50:57.990
are available for
the players to use,

00:50:57.990 --> 00:51:00.690
and then switch the
control scheme on the fly

00:51:00.690 --> 00:51:01.990
based on that.

00:51:01.990 --> 00:51:03.480
Now another key
point to remember

00:51:03.480 --> 00:51:05.620
here is that just because
input manager says

00:51:05.620 --> 00:51:08.080
that something is available,
it might not be usable.

00:51:08.080 --> 00:51:10.290
So it could be like a
Chromebook with a keyboard

00:51:10.290 --> 00:51:11.760
that's actually in tablet mode.

00:51:11.760 --> 00:51:14.220
So the keyboard's on the
back, and it's not usable.

00:51:14.220 --> 00:51:18.210
So again, just keep in mind that
these devices are convertibles

00:51:18.210 --> 00:51:21.450
and that your players may switch
between any number of control

00:51:21.450 --> 00:51:23.930
inputs at any time.

00:51:26.750 --> 00:51:28.790
And if you don't
think keyboard support

00:51:28.790 --> 00:51:30.778
makes sense for your
game, fair enough.

00:51:30.778 --> 00:51:32.570
But you might consider
that implementing it

00:51:32.570 --> 00:51:34.820
will improve the
accessibility of your game

00:51:34.820 --> 00:51:36.330
for lots of people.

00:51:36.330 --> 00:51:39.140
So some ideas could
be skill key bindings,

00:51:39.140 --> 00:51:41.603
menu, player navigation.

00:51:41.603 --> 00:51:43.020
If you really
wanted to get fancy,

00:51:43.020 --> 00:51:44.690
you could implement
custom key mapping

00:51:44.690 --> 00:51:48.800
so players can set up whatever
they want for specific keys

00:51:48.800 --> 00:51:50.130
to do certain actions.

00:51:50.130 --> 00:51:51.248
So it's all up to you.

00:51:51.248 --> 00:51:52.790
We highly recommend
that you do think

00:51:52.790 --> 00:51:54.860
of this for players
that are playing

00:51:54.860 --> 00:51:59.538
on these devices with keyboards.

00:51:59.538 --> 00:52:01.830
And also, if you haven't
implemented controller support

00:52:01.830 --> 00:52:05.430
yet, consider that the
standard Android controller

00:52:05.430 --> 00:52:08.610
APIs work on devices like
Chromebooks and Samsung Dex

00:52:08.610 --> 00:52:10.500
where controllers might
be more widely used.

00:52:16.980 --> 00:52:20.277
So we've talked about screen
and input considerations.

00:52:20.277 --> 00:52:22.610
So finally, let's talk about
some general considerations

00:52:22.610 --> 00:52:25.893
around building and
configuring your APK

00:52:25.893 --> 00:52:28.310
to make sure it supports all
these various devices running

00:52:28.310 --> 00:52:30.400
Android.

00:52:30.400 --> 00:52:32.500
So first off, review
the permissions

00:52:32.500 --> 00:52:33.500
that you're asking for.

00:52:33.500 --> 00:52:35.890
And determine if you really
need them, as Dan alluded to

00:52:35.890 --> 00:52:37.360
in the previous talk.

00:52:37.360 --> 00:52:40.210
Some permissions are not
supported on certain devices

00:52:40.210 --> 00:52:41.260
like Chrome OS.

00:52:41.260 --> 00:52:44.200
So blindly asking for
permissions or features that

00:52:44.200 --> 00:52:46.337
aren't supported will
put you in a scenario

00:52:46.337 --> 00:52:47.920
where the user will
try to download it

00:52:47.920 --> 00:52:49.545
from Google Play on
that device, and it

00:52:49.545 --> 00:52:51.620
will show up as not compatible.

00:52:51.620 --> 00:52:52.850
And they'll have no idea why.

00:52:52.850 --> 00:52:54.430
So it's kind of a bummer.

00:52:54.430 --> 00:52:58.073
Good examples of this might
be GPS or SMS permissions.

00:52:58.073 --> 00:52:59.740
And what we recommend
is, basically, you

00:52:59.740 --> 00:53:01.510
can list these
features or permissions

00:53:01.510 --> 00:53:04.230
as not required in the
manifest and then just check,

00:53:04.230 --> 00:53:06.310
in code, to see if that's
actually available.

00:53:06.310 --> 00:53:08.200
So that way, users
can download it.

00:53:08.200 --> 00:53:10.710
And then you, on your
end, inside your code,

00:53:10.710 --> 00:53:13.900
dynamically adapt the game
to either use those features

00:53:13.900 --> 00:53:17.430
or not depending on what device
the players are playing on.

00:53:20.370 --> 00:53:25.680
Also consider the hardware
and performance capabilities

00:53:25.680 --> 00:53:27.610
of the different devices
you're running on.

00:53:27.610 --> 00:53:31.000
So if you have an automatic
quality control system,

00:53:31.000 --> 00:53:33.840
or you have different
performance profiles,

00:53:33.840 --> 00:53:36.420
try to set them
up in such a way--

00:53:36.420 --> 00:53:38.970
well, first of all, test them
on these different devices,

00:53:38.970 --> 00:53:41.790
like Chromebooks, and
tablets, and foldables.

00:53:41.790 --> 00:53:44.160
But then consider setting
up different profiles

00:53:44.160 --> 00:53:46.230
to take advantage of
all the extra hardware

00:53:46.230 --> 00:53:49.380
and performance capabilities
of those devices.

00:53:49.380 --> 00:53:51.160
You want to make
sure that players--

00:53:51.160 --> 00:53:53.490
when they buy a
bigger device, they're

00:53:53.490 --> 00:53:55.300
expecting more
performance out of it.

00:53:55.300 --> 00:53:58.730
So make sure that you're
thinking about that.

00:53:58.730 --> 00:54:00.770
Additionally, try to
provide an x86 build.

00:54:00.770 --> 00:54:03.680
So many Chromebooks
are x86 only.

00:54:03.680 --> 00:54:05.400
And while ARM will
still run on them,

00:54:05.400 --> 00:54:08.480
you're going to be
incurring the instruction

00:54:08.480 --> 00:54:10.460
translation overhead.

00:54:10.460 --> 00:54:12.718
And it will degrade
performance a bit.

00:54:12.718 --> 00:54:15.010
And for those looking-- for
those of you looking to get

00:54:15.010 --> 00:54:17.110
the maximum graphics
performance, again,

00:54:17.110 --> 00:54:20.140
we suggest that you use Vulkan,
as they're now supported across

00:54:20.140 --> 00:54:20.980
many devices--

00:54:20.980 --> 00:54:27.380
at least 1.0-- with 1.1
support coming very soon.

00:54:27.380 --> 00:54:29.720
And finally, test across
all these different devices

00:54:29.720 --> 00:54:33.270
is probably the biggest
suggestion we can make.

00:54:33.270 --> 00:54:36.020
So add test cases that cover
all the additional flows

00:54:36.020 --> 00:54:41.510
like resizing, minimizing,
maximizing, switching

00:54:41.510 --> 00:54:43.390
between the small
and large screens.

00:54:43.390 --> 00:54:46.100
You want to make sure that you
see how your game is behaving

00:54:46.100 --> 00:54:47.210
in all these scenarios.

00:54:47.210 --> 00:54:48.585
Because you might
only be testing

00:54:48.585 --> 00:54:52.080
on a mobile device, and bad
things could be happening.

00:54:52.080 --> 00:54:55.250
You can use things like the
Android or Chrome OS emulators

00:54:55.250 --> 00:54:57.980
to get a sense of how your
game might behave if you don't

00:54:57.980 --> 00:55:00.103
have those devices available.

00:55:00.103 --> 00:55:01.520
Or you could use
Firebase Test Lab

00:55:01.520 --> 00:55:03.830
to help you automate the
process, since probably,

00:55:03.830 --> 00:55:05.690
not a lot of you
are too thrilled

00:55:05.690 --> 00:55:08.480
about having to expand
your QA teams to test

00:55:08.480 --> 00:55:09.800
all these different devices.

00:55:09.800 --> 00:55:10.760
So there are a few
tools out there

00:55:10.760 --> 00:55:12.718
that you can use to help
yourself in that area.

00:55:15.960 --> 00:55:19.280
So in closing, the thing that
I really want to stress here

00:55:19.280 --> 00:55:22.310
is that Android gaming is
not just phones anymore.

00:55:22.310 --> 00:55:23.930
Players are
experiencing your game

00:55:23.930 --> 00:55:27.290
on a wide variety of
devices and form factors

00:55:27.290 --> 00:55:28.610
with different inputs.

00:55:28.610 --> 00:55:31.220
And by following these
Android best practices

00:55:31.220 --> 00:55:34.190
and spending just a little
bit of time considering

00:55:34.190 --> 00:55:38.060
the additional use cases that
players might be coming across,

00:55:38.060 --> 00:55:40.250
you can really take
your game beyond mobile

00:55:40.250 --> 00:55:41.750
and provide the
best possible gaming

00:55:41.750 --> 00:55:43.640
experience for your players.

00:55:43.640 --> 00:55:45.819
And they will thank you for it.

