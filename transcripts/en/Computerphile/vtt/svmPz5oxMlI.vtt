WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.740
Lisp is a language that was invented back in the 1950s.

00:00:04.740 --> 00:00:08.800
It is capable of doing functional programming, but it's actually

00:00:08.800 --> 00:00:12.180
often misattributed as being a functional programming language.

00:00:12.180 --> 00:00:17.480
In general, it's a so-called metaprogramming language, or a symbolic programming language.

00:00:17.480 --> 00:00:22.720
It can be used for any sort of task that you might want do. It's a general-purpose language, Lisp.

00:00:25.160 --> 00:00:29.280
It's been said that learning Lisp just helps you be a better programmer in general.

00:00:29.280 --> 00:00:33.900
It opens up a lot of different ways of thinking that are sort of

00:00:33.900 --> 00:00:38.060
locked away in languages like Java or C++ or what have you.

00:00:38.060 --> 00:00:43.360
It has a few interesting ideas, such as this idea of homoiconicity,

00:00:43.360 --> 00:00:49.600
where the language itself is written as a data structure that you can represent in that language..

00:00:49.600 --> 00:00:55.140
This idea of metaprogramming, where not only are you programming in the language to solve a problem,

00:00:55.140 --> 00:01:00.700
but you can program the language itself. You can change the structure of the language itself

00:01:00.700 --> 00:01:04.180
to make it more suitable for a particular application.

00:01:04.180 --> 00:01:10.500
And even if it was just for learning those concepts, you'd become a better programmer in other languages.

00:01:10.500 --> 00:01:14.580
Nonetheless, it still remains a language... Common Lisp, in particular

00:01:14.580 --> 00:01:19.380
remains a language that's very, very good at solving modern real-world problems.

00:01:19.380 --> 00:01:23.160
I actually would draw an analogy to physics a little bit.

00:01:23.160 --> 00:01:28.920
Like, good ideas, ideas that are fundamentally good are usually ones that stand the test of time.

00:01:28.920 --> 00:01:33.620
Now, computer science and computer programming is not a very old art, so to speak.

00:01:33.620 --> 00:01:36.460
It's, you know, less than a century old.

00:01:36.460 --> 00:01:42.120
However, there are lots of theories in physics, for instance, that were sensible,

00:01:42.120 --> 00:01:46.740
they allowed you to make predictions. For example, the sun going around the Earth.

00:01:46.740 --> 00:01:51.940
It seems reasonable. You see it. But there's a kernel of an idea later that the Earth goes around the sun.

00:01:51.940 --> 00:01:57.520
And that is a physical theory that, one, turned out to be true, but also stands the test of time.

00:01:57.520 --> 00:02:00.780
There are good ideas in it that are fundamentally good.

00:02:00.780 --> 00:02:07.380
And so I think that just the fact that Lisp started in the 1950s and still has something,

00:02:07.380 --> 00:02:13.260
still has some kernel of an idea that's good, I think makes it worth learning, even if it's not used day to day.

00:02:13.260 --> 00:02:16.200
(off) You do use it day to day, don't you?
(Smith) Yes.

00:02:16.200 --> 00:02:22.920
So, Lisp, even still, going back to this kernel of an idea, is good at building a language that I want.

00:02:22.920 --> 00:02:31.200
I can't think of anything that's better than using a programming language that allows me to build the language that I need to express my problem.

00:02:31.200 --> 00:02:35.680
The stuff that I work on day to day is quantum computing, where there isn't a lot of literature

00:02:35.680 --> 00:02:40.120
on how to wrangle the problems that come up in quantum computing.

00:02:40.120 --> 00:02:48.860
Quantum computing uses quantum mechanics, which is a very, very different mathematical language than just addition of numbers, for instance.

00:02:48.860 --> 00:02:54.040
It is a very strange world, where things have all different types of rules.

00:02:54.040 --> 00:03:00.260
So, modern programming languages don't support expressing these constructs in a very fluid way.

00:03:00.260 --> 00:03:08.020
Often, I need to sort of build my own sort of language in order to express solutions to problems that I'm having.

00:03:08.020 --> 00:03:13.320
Now, you can do this in a language like C++ or Java. You can build your own parser, you can build your own

00:03:13.320 --> 00:03:18.520
compiler, you can build all of the things you need just to be able to write solutions to problems.

00:03:18.520 --> 00:03:23.000
But in Lisp, it allows you to grow the language ever so slightly in a very easy way,

00:03:23.000 --> 00:03:26.640
so that in Lisp directly I can express these new constructs.

00:03:26.640 --> 00:03:29.240
And it's very helpful for these types of new domains.

00:03:29.240 --> 00:03:32.660
We're actually extending the syntax of the language.

00:03:32.660 --> 00:03:36.980
So, one example that I like to bring up is, back in the days of programming Assembly,

00:03:36.980 --> 00:03:43.860
if you wanted to do something like a "for" loop, you wrote down this structure where you'd have this explicit

00:03:43.860 --> 00:03:47.740
"jump" statement, and then you'd have a separate counter somewhere,

00:03:47.740 --> 00:03:50.220
and it's all just a bunch of lines of Assembly.

00:03:50.220 --> 00:03:55.420
Nowhere in the Assembly code are you actually saying, like, "for i from 1 to 10", or something like that,

00:03:55.420 --> 00:04:01.620
but you know the concept is there. You know as the programmer what you mean by these instructions is a "for" loop.

00:04:01.620 --> 00:04:07.880
What Lisp does is allow you to take that idea of a "for" loop and actually syntactically be able to write a "for" loop.

00:04:07.880 --> 00:04:13.960
So it's not just a library of functions. It's actually new syntax and new functionality in the language.

00:04:13.960 --> 00:04:17.680
(off) But it all does come down to Assembly in the end, doesn't it?
(Smith) Yes, absolutely.

00:04:17.680 --> 00:04:20.540
Yeah, it all gets compiled to Assembly in the end.

00:04:20.540 --> 00:04:24.020
(off) So this is a way of organizing your thoughts as a programmer.
(Smith) Correct, yes.

00:04:24.020 --> 00:04:29.700
That's, I think, ultimately what it's optimizing for, allowing you the programmer to organize your thoughts.

00:04:29.700 --> 00:04:37.080
Most of the time in programming is spent thinking, so that's the progress that I want to optimize in programming.

00:04:37.080 --> 00:04:41.940
Not necessarily the efficiency of the program, although you can do that, and other things.

00:04:41.940 --> 00:04:48.620
It's being able to even get the solution to the problem out on paper or on the screen in the first place.

00:04:48.620 --> 00:04:51.100
(off) And would you say you're faster doing it this way?

00:04:51.100 --> 00:04:54.420
(off) There might be somebody out there going, "Yeah, I could do that in Haskell, I could do that in C."

00:04:54.420 --> 00:05:01.960
(Smith) So, instead of taking my word for it, we did this little program where I work where we had

00:05:01.960 --> 00:05:09.620
college students, interns, come in and try the language, then try to use it for solving some of these quantum problems.

00:05:09.620 --> 00:05:13.080
And the first reaction is, like, "Whoa, there are lots of parentheses."

00:05:13.080 --> 00:05:17.460
If you look at Lisp code, there are lots of parentheses. And then it's... Well, the documentation is sometimes

00:05:17.460 --> 00:05:19.960
a little bit shaky in certain places.

00:05:19.960 --> 00:05:23.940
But once they kind of got through that first bit of the learning curve,

00:05:23.940 --> 00:05:29.320
the feedback that I got is that they could think about their problems in a more fundamental,

00:05:29.320 --> 00:05:34.320
or more structural fashion, that the language itself wasn't getting in the way of solving their problems.

00:05:34.320 --> 00:05:40.740
It's that now they could express what they think in a more direct fashion, without so much of an impedance mismatch.

00:05:40.740 --> 00:05:46.080
Fortunately, Lisp was originally defined in, like, half a page of code. Like, the entire language.

00:05:46.080 --> 00:05:53.520
And in that page of code, they had very few concepts that bring to light all of these things that I'm discussing.

00:05:53.520 --> 00:05:59.760
Namely, the notion of S expressions, which is how the Lisp language itself is built, how you write it.

00:05:59.760 --> 00:06:05.580
And following that, this notion of macros and metaprogramming, how we can extend the language.

00:06:05.580 --> 00:06:11.020
And I think these two things really bring to light how all this stuff works.

00:06:15.240 --> 00:06:19.160
The special thing about this is that we can interpret it in two ways.

00:06:19.160 --> 00:06:22.720
It can be looked at as code. It looks like we're doing 1+2*3.

00:06:22.720 --> 00:06:29.500
But it can also be looked at as data. Remember that in Lisp we write out a list using parentheses, here.

00:06:29.500 --> 00:06:35.880
We write out symbols just as their names here. So in Lisp, actually have this explicit bridge...

