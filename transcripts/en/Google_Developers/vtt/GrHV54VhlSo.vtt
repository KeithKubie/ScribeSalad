WEBVTT
Kind: captions
Language: en

00:00:01.467 --> 00:00:03.267
Bruce Johnson:
Well, good morning.

00:00:03.267 --> 00:00:05.834
What did you think about Wave?

00:00:05.834 --> 00:00:08.267
[cheers and applause]

00:00:08.267 --> 00:00:09.567
Thanks very much.

00:00:09.567 --> 00:00:12.000
Yesterday, about the same time
in this same room,

00:00:12.000 --> 00:00:15.567
we talked about the features
coming in GWT 2.0.

00:00:15.567 --> 00:00:18.734
And as I think you can
probably see now,

00:00:18.734 --> 00:00:22.834
a lot of those features
were developed--yes, thank you.

00:00:22.834 --> 00:00:24.467
I have to switch the monitors.

00:00:24.467 --> 00:00:29.767
But a lot of those features
were developed

00:00:29.767 --> 00:00:33.267
because of the really extreme

00:00:33.267 --> 00:00:34.901
level of sophistication

00:00:34.901 --> 00:00:37.834
that teams like the Wave team

00:00:37.834 --> 00:00:41.567
and some other really large
Google Apps including AdWords--

00:00:41.567 --> 00:00:43.767
they're really,
really trying to do

00:00:43.767 --> 00:00:46.100
cutting-edge types of things,
as you've seen.

00:00:46.100 --> 00:00:50.334
So these technologies that
we were working on in G-W-T,

00:00:50.334 --> 00:00:52.801
they happen
because there's a need.

00:00:52.801 --> 00:00:54.534
And then we figure out
the best solution

00:00:54.534 --> 00:00:56.067
that we can come up with

00:00:56.067 --> 00:00:59.400
and then they are able
to take our improvements

00:00:59.400 --> 00:01:01.000
and continue working,

00:01:01.000 --> 00:01:04.801
but another barrier
has been removed.

00:01:04.801 --> 00:01:06.334
So we're really excited
about Wave,

00:01:06.334 --> 00:01:10.634
and if you want to see
in more detail

00:01:10.634 --> 00:01:12.901
how the Wave client team

00:01:12.901 --> 00:01:15.467
built that really nice
UI with GWT

00:01:15.467 --> 00:01:17.200
and how they take advantage
of code splitting,

00:01:17.200 --> 00:01:19.667
which is the topic
of our talk today,

00:01:19.667 --> 00:01:21.667
go see the talk later on

00:01:21.667 --> 00:01:24.934
about building a Wave client
with GWT.

00:01:24.934 --> 00:01:26.400
My name is Bruce Johnson,
again.

00:01:26.400 --> 00:01:28.300
I work on G-W-T.

00:01:28.300 --> 00:01:31.534
This is...ahem...

00:01:31.534 --> 00:01:33.334
mostly about compiler output,

00:01:33.334 --> 00:01:34.934
mostly focusing on
code splitting,

00:01:34.934 --> 00:01:37.501
but there are a few other things
that we'll cover too, today.

00:01:37.501 --> 00:01:41.734
But first, in the spirit
of what I was just describing,

00:01:41.734 --> 00:01:43.701
it's leverage, right?

00:01:43.701 --> 00:01:47.200
You use
the Java language, IDEs

00:01:47.200 --> 00:01:49.868
to construct your client code.

00:01:49.868 --> 00:01:52.734
And GWT cross-compiles it
and optimizes things for you,

00:01:52.734 --> 00:01:57.300
and we add fancy new APIs.

00:01:57.300 --> 00:01:59.934
You recompile as the new
version of GWT comes out,

00:01:59.934 --> 00:02:02.734
and, you know, good things
happen to your code,

00:02:02.734 --> 00:02:05.000
and often you have to do
very little work.

00:02:05.000 --> 00:02:06.434
That is what I would call
leverage,

00:02:06.434 --> 00:02:08.801
and that's the basic
promise of GWT.

00:02:08.801 --> 00:02:12.000
So would you take this deal?

00:02:12.000 --> 00:02:16.033
Tweak your app for one hour...

00:02:16.033 --> 00:02:21.100
and you get in return
50% script size reduction.

00:02:21.100 --> 00:02:23.801
Well, that's exactly what
you get with code splitting.

00:02:23.801 --> 00:02:25.434
We did this with the showcase.

00:02:25.434 --> 00:02:28.501
The showcase sample
was available as of GWT 1.5,

00:02:28.501 --> 00:02:29.834
and we said, you know,

00:02:29.834 --> 00:02:31.834
we should really use code
splitting in showcase.

00:02:31.834 --> 00:02:34.801
One hour later, showcase
downloads twice as fast.

00:02:34.801 --> 00:02:36.534
That is high leverage.

00:02:36.534 --> 00:02:40.367
Similarly, with Wave, actually,
Wave on the iPhone,

00:02:40.367 --> 00:02:43.601
those guys came from Sydney
to visit us in Atlanta,

00:02:43.601 --> 00:02:45.167
and they were talking about

00:02:45.167 --> 00:02:48.534
wanting to compile their
client code for the iPhone.

00:02:48.534 --> 00:02:51.000
And it was, at that time,
a very large amount of code,

00:02:51.000 --> 00:02:54.000
and it was bringing the iPhone
browser to its knees.

00:02:54.000 --> 00:02:56.300
Well, fortunately, Lex here

00:02:56.300 --> 00:02:58.033
had just put the wraps

00:02:58.033 --> 00:03:00.100
on the first version
of code splitting,

00:03:00.100 --> 00:03:02.868
and he spent a day or two
with them.

00:03:02.868 --> 00:03:06.267
And two days later, their app
was working on the iPhone.

00:03:06.267 --> 00:03:07.868
And it's just really phenomenal

00:03:07.868 --> 00:03:10.734
to see the kind of leverage
that you can get.

00:03:10.734 --> 00:03:14.334
So...starting to become
redundant now,

00:03:14.334 --> 00:03:18.167
but just to actually show you
quantitatively,

00:03:18.167 --> 00:03:22.267
one hour prior,
showcase was 100K.

00:03:22.267 --> 00:03:26.100
An hour later,
it was 50K to download.

00:03:26.100 --> 00:03:28.334
Another really interesting
aspect of code splitting is

00:03:28.334 --> 00:03:29.767
you've probably seen it now.

00:03:29.767 --> 00:03:32.667
We've talked about it in several
talks in the keynote.

00:03:32.667 --> 00:03:35.467
Another aspect is it doesn't
download code that doesn't run,

00:03:35.467 --> 00:03:37.667
because it actually
is based on

00:03:37.667 --> 00:03:41.367
the control flow of your code.

00:03:41.367 --> 00:03:44.133
So you don't spend time

00:03:44.133 --> 00:03:45.334
downloading bytes
over the network

00:03:45.334 --> 00:03:46.767
that don't actually
end up running,

00:03:46.767 --> 00:03:48.801
which is really important
from a usability

00:03:48.801 --> 00:03:50.868
and latency standpoint.

00:03:50.868 --> 00:03:53.167
When you do download, you know,
additional code,

00:03:53.167 --> 00:03:55.367
even if users ultimately use

00:03:55.367 --> 00:03:58.367
every bit of functionality
in your entire application,

00:03:58.367 --> 00:04:02.100
you can amortize the cost
of downloading that code

00:04:02.100 --> 00:04:04.033
as they use the app.

00:04:04.033 --> 00:04:06.033
In Kelly Norton's talk about

00:04:06.033 --> 00:04:08.133
Measuring in Milliseconds
yesterday--

00:04:08.133 --> 00:04:09.501
which if you didn't catch
yesterday,

00:04:09.501 --> 00:04:11.801
you should check out
on YouTube later--

00:04:11.801 --> 00:04:13.868
he talks about certain
threshold numbers

00:04:13.868 --> 00:04:16.534
for turnaround time,

00:04:16.534 --> 00:04:19.601
and 100 milliseconds
is a key number.

00:04:19.601 --> 00:04:22.801
So if you do five things
that take 20 milliseconds each,

00:04:22.801 --> 00:04:25.033
the user's not even aware
that anything happens.

00:04:25.033 --> 00:04:27.367
But if you do one thing
that takes 100 milliseconds,

00:04:27.367 --> 00:04:28.801
the user is aware,

00:04:28.801 --> 00:04:31.033
and they start to have
worse perceptions

00:04:31.033 --> 00:04:32.801
about the quality
of what you're doing.

00:04:32.801 --> 00:04:36.000
So if you can spread the cost
of downloading code around,

00:04:36.000 --> 00:04:39.267
then it's basically nothing
but a good user experience

00:04:39.267 --> 00:04:40.934
the whole time.

00:04:40.934 --> 00:04:42.868
Another subtle
but important point is

00:04:42.868 --> 00:04:45.767
don't think that when
you download a code fragment

00:04:45.767 --> 00:04:47.868
it means you're hitting
the network.

00:04:47.868 --> 00:04:51.834
If you set up your HTTP response
caching headers correctly,

00:04:51.834 --> 00:04:53.868
you can feel confident that

00:04:53.868 --> 00:04:56.667
you can cache those code
fragments permanently.

00:04:56.667 --> 00:05:00.367
You can say this thing can be
cached until the sun explodes

00:05:00.367 --> 00:05:02.067
because each fragment has

00:05:02.067 --> 00:05:04.801
a guaranteed
unique identifier, right?

00:05:04.801 --> 00:05:06.167
So no two fragments
would ever be confused

00:05:06.167 --> 00:05:07.501
with each other.

00:05:07.501 --> 00:05:09.434
Even when you redeploy
the application,

00:05:09.434 --> 00:05:11.400
if there's anything
that has changed,

00:05:11.400 --> 00:05:14.701
it will definitely download
the right new fragments.

00:05:17.767 --> 00:05:19.868
Okay, so...

00:05:19.868 --> 00:05:22.434
again, if you ever hear us
talk about GWT,

00:05:22.434 --> 00:05:23.901
we always talk about
optimization

00:05:23.901 --> 00:05:25.901
because, really, GWT is about

00:05:25.901 --> 00:05:28.467
making the end user experience
the best that it can be.

00:05:28.467 --> 00:05:31.934
It's...
it is our mission.

00:05:31.934 --> 00:05:33.400
If some other technology
came out

00:05:33.400 --> 00:05:35.934
that produced
a better user experience,

00:05:35.934 --> 00:05:38.267
we would either try
to do better than that

00:05:38.267 --> 00:05:40.567
or we would become fans
of that technology.

00:05:40.567 --> 00:05:42.467
It's not that we want you
to use GWT.

00:05:42.467 --> 00:05:44.901
We want you to build
excellent web applications

00:05:44.901 --> 00:05:47.434
for end users.

00:05:47.434 --> 00:05:49.767
So should you really care
about optimization?

00:05:49.767 --> 00:05:53.234
This is the last I'll say it.

00:05:53.234 --> 00:05:54.534
Yes.

00:05:54.534 --> 00:05:56.234
Again, as Kelly explained
really well

00:05:56.234 --> 00:05:58.133
in Measure in Milliseconds
yesterday,

00:05:58.133 --> 00:06:00.400
if you don't think about
optimization

00:06:00.400 --> 00:06:01.901
pretty much
from the beginning,

00:06:01.901 --> 00:06:04.067
you're guaranteed
to end up with

00:06:04.067 --> 00:06:07.767
patterns that are very,
very hard to optimize later.

00:06:07.767 --> 00:06:09.667
And later,
if you think about it,

00:06:09.667 --> 00:06:11.767
is the time when
you're about to ship,

00:06:11.767 --> 00:06:13.334
which is exactly the time

00:06:13.334 --> 00:06:15.968
you don't wanna make
architectural types of changes.

00:06:15.968 --> 00:06:17.567
So the best thing to do is

00:06:17.567 --> 00:06:20.434
the first few days,
just get something going.

00:06:20.434 --> 00:06:22.634
And then the second week,
you're working on your app.

00:06:22.634 --> 00:06:24.801
Start thinking about
how to measure things

00:06:24.801 --> 00:06:28.334
and make sure that
the resulting application

00:06:28.334 --> 00:06:30.000
is as fast and as small
as it can be.

00:06:30.000 --> 00:06:31.400
So the rest of the talk

00:06:31.400 --> 00:06:35.067
is about tools to help you
analyze that in great detail.

00:06:35.067 --> 00:06:36.968
There's a couple things
we should have said last year

00:06:36.968 --> 00:06:39.834
that aren't strictly related
to code-splitting

00:06:39.834 --> 00:06:44.167
but that do help you analyze
what the compiler's doing.

00:06:44.167 --> 00:06:45.701
So the first thing is RPC.

00:06:45.701 --> 00:06:48.200
It's a very convenient way

00:06:48.200 --> 00:06:51.467
to send Java objects back
and forth across the wire.

00:06:51.467 --> 00:06:53.834
It makes it easy to share
source code

00:06:53.834 --> 00:06:55.901
between your server side code
and your client side code.

00:06:55.901 --> 00:06:58.133
Lots of benefits.

00:06:58.133 --> 00:07:01.868
But it also generates
client side proxy code

00:07:01.868 --> 00:07:05.400
to serialize and deserialize
these various objects.

00:07:05.400 --> 00:07:06.868
And if you're not careful,

00:07:06.868 --> 00:07:09.367
you know, 20% or 30%
of your total script size

00:07:09.367 --> 00:07:12.501
can be this generated RPC code.

00:07:12.501 --> 00:07:15.734
The RPC code generator
as part of GWT

00:07:15.734 --> 00:07:17.567
actually produces files
to help you understand

00:07:17.567 --> 00:07:21.167
what is going into the RPC
serializer code,

00:07:21.167 --> 00:07:24.901
and so it allows you to...
make better decisions

00:07:24.901 --> 00:07:28.067
about exactly how to define
your RPC interfaces,

00:07:28.067 --> 00:07:30.167
where to use broader
polymorphism

00:07:30.167 --> 00:07:33.300
or more specific types
in your RPC interfaces

00:07:33.300 --> 00:07:36.067
and use the new feature
in GWT 2.0,

00:07:36.067 --> 00:07:38.000
which is RPC blacklisting.

00:07:38.000 --> 00:07:39.868
So there's two files.

00:07:39.868 --> 00:07:42.400
There's a .gwt.rpc file

00:07:42.400 --> 00:07:44.567
that you're supposed to deploy
onto your server

00:07:44.567 --> 00:07:47.067
which acts as sort of
a safeguard

00:07:47.067 --> 00:07:50.033
so that
an incoming RPC payload

00:07:50.033 --> 00:07:52.501
is only allowed to ask
to instantiate types

00:07:52.501 --> 00:07:56.300
that this whiteless file,
the gwt.rpc file,

00:07:56.300 --> 00:07:58.567
says are okay to instantiate
on your server.

00:07:58.567 --> 00:08:00.968
So it's somewhat
of a security measure.

00:08:00.968 --> 00:08:02.634
But it also helps you know

00:08:02.634 --> 00:08:07.100
exactly which classes
the RPC system is considering

00:08:07.100 --> 00:08:10.334
being available
in the serialization process.

00:08:10.334 --> 00:08:12.701
And then
the module.rpc.log file

00:08:12.701 --> 00:08:15.801
explains,
in excruciating detail,

00:08:15.801 --> 00:08:18.400
the logic that the code--
the RPC generator used

00:08:18.400 --> 00:08:21.400
to decide whether something
should be part of

00:08:21.400 --> 00:08:24.200
the serialization
proxy logic or not.

00:08:24.200 --> 00:08:27.901
So I'll just show you an example
of these files from DynaTable.

00:08:32.534 --> 00:08:35.701
We have...

00:08:35.701 --> 00:08:37.701
there's the first one.

00:08:43.367 --> 00:08:46.667
So these are meant--
these in particular

00:08:46.667 --> 00:08:49.000
are meant for use
by software on the server,

00:08:49.000 --> 00:08:50.767
but you can look at them
as well.

00:08:50.767 --> 00:08:54.334
So you can just basically
read the first column and see,

00:08:54.334 --> 00:08:56.300
okay, so there's
a person class.

00:08:56.300 --> 00:08:58.501
That's serializable.

00:08:58.501 --> 00:09:00.834
There's a professor class.
There's a schedule class.

00:09:00.834 --> 00:09:02.434
There's a time slot class.

00:09:02.434 --> 00:09:05.734
And these all correlate to
the DTO classes that I'm using

00:09:05.734 --> 00:09:09.334
within the DynaTable sample
that's part of G-W-T.

00:09:09.334 --> 00:09:11.434
I can see that there's several
different exception types

00:09:11.434 --> 00:09:15.567
that get pulled in here,
and so on.

00:09:15.567 --> 00:09:17.901
So in this case,
those all make sense.

00:09:17.901 --> 00:09:19.567
But it's also possible

00:09:19.567 --> 00:09:23.334
that you'll look and find...
classes in there

00:09:23.334 --> 00:09:27.200
that you're absolutely sure
don't make sense.

00:09:27.200 --> 00:09:30.767
Sometimes if you use
very broad polymorphism,

00:09:30.767 --> 00:09:32.868
if you were to have
an RPC method

00:09:32.868 --> 00:09:35.400
that returned serializable,
for example,

00:09:35.400 --> 00:09:37.767
the co-generator
is basically forced

00:09:37.767 --> 00:09:40.634
to generate code
onto the client

00:09:40.634 --> 00:09:44.400
that can de-serialize
anything the server might send

00:09:44.400 --> 00:09:46.100
that is serializable.

00:09:46.100 --> 00:09:48.100
And so that's
an explosion of code.

00:09:48.100 --> 00:09:50.834
And so you would look
at the .gwt.rpc file

00:09:50.834 --> 00:09:52.501
to get a sense of

00:09:52.501 --> 00:09:54.901
what is the RPC system

00:09:54.901 --> 00:09:57.734
really allowing me
to serialize?

00:09:57.734 --> 00:10:00.501
And then you understand the cost
for it a little bit more.

00:10:00.501 --> 00:10:02.300
Then...if you find something

00:10:02.300 --> 00:10:04.534
that just doesn't look
like it ought to be there,

00:10:04.534 --> 00:10:08.434
you can look at
the .rpc.log file.

00:10:08.434 --> 00:10:10.200
And you want to look at
this one second,

00:10:10.200 --> 00:10:14.033
because there's
a bunch of data here.

00:10:14.033 --> 00:10:20.000
But it goes through,
and for any particular class...

00:10:20.000 --> 00:10:23.634
it will tell you
whether it's serializable--

00:10:23.634 --> 00:10:25.234
Oops.

00:10:25.234 --> 00:10:27.567
Let me try that again.

00:10:27.567 --> 00:10:28.968
Whether it's serializable

00:10:28.968 --> 00:10:31.400
and how it decided
that it was serializable.

00:10:34.000 --> 00:10:35.467
So in this case,

00:10:35.467 --> 00:10:38.667
student is reachable because
it's a subtype of person,

00:10:38.667 --> 00:10:40.100
and I had an RPC method

00:10:40.100 --> 00:10:42.534
that returned a person
polymorphically.

00:10:42.534 --> 00:10:45.934
And so the code generator
looks at person and says,

00:10:45.934 --> 00:10:49.100
well, the server can send
either a student or a professor

00:10:49.100 --> 00:10:50.634
as a person,

00:10:50.634 --> 00:10:53.000
and so I have to generate
serialization code for both.

00:10:53.000 --> 00:10:54.868
Anyway, this is
one of the ways

00:10:54.868 --> 00:10:57.167
that you can sort of start
to learn to read the tea leaves

00:10:57.167 --> 00:11:00.567
and optimize the size
of your client code.

00:11:03.334 --> 00:11:06.334
Another thing, when you're
really trying to eke out

00:11:06.334 --> 00:11:11.567
every bit of size and speed
performance that you can get

00:11:11.567 --> 00:11:14.901
is you can actually watch
the compiler optimize a method.

00:11:14.901 --> 00:11:16.467
So this is pretty interesting.

00:11:16.467 --> 00:11:19.901
So I just created
a simple ShapeExample...

00:11:19.901 --> 00:11:22.901
and this is what
it looks like.

00:11:22.901 --> 00:11:25.067
In onModuleLoad
we have this

00:11:25.067 --> 00:11:30.834
local variable s
of type Shape.

00:11:30.834 --> 00:11:32.501
And of course,
there's the Shape class.

00:11:32.501 --> 00:11:35.334
There's this method
on the ShapeExample class

00:11:35.334 --> 00:11:37.534
that returns the shape,
which is a reference to a field

00:11:37.534 --> 00:11:39.167
which is defined to be a shape

00:11:39.167 --> 00:11:42.133
but is actually instantiated
as a SmallSquare.

00:11:42.133 --> 00:11:44.434
And a SmallSquare
derives from Square,

00:11:44.434 --> 00:11:46.601
which defines area to be

00:11:46.601 --> 00:11:48.734
the product of
the lengths of the sides,

00:11:48.734 --> 00:11:52.634
and then the SmallSquare class
returns the lengths of the sides

00:11:52.634 --> 00:11:54.334
which good programming practice

00:11:54.334 --> 00:11:59.334
has us making a constant
of two, right?

00:11:59.334 --> 00:12:02.133
So if you run the GWT compiler

00:12:02.133 --> 00:12:06.767
and you provide
the -Dgwt.jjs.traceMethod=

00:12:06.767 --> 00:12:10.601
and then the name of the method
that you want to watch,

00:12:10.601 --> 00:12:12.234
you can see what it does.

00:12:12.234 --> 00:12:15.834
In this case,
the onModuleLoad method,

00:12:15.834 --> 00:12:19.834
the final compiler logic just
before it turns into JavaScript

00:12:19.834 --> 00:12:21.968
looks like this.

00:12:24.234 --> 00:12:29.067
And so...
the purpose of the flag

00:12:29.067 --> 00:12:32.300
is so that you can actually
understand why it's doing that.

00:12:32.300 --> 00:12:33.968
Even more importantly,

00:12:33.968 --> 00:12:36.701
if you look at some code and you
think it should be optimized,

00:12:36.701 --> 00:12:39.200
it will help you see
what's happening step-by-step

00:12:39.200 --> 00:12:41.601
so that if, in fact,
it isn't getting optimized,

00:12:41.601 --> 00:12:44.367
you can figure out where in
the chain that it's going wrong.

00:12:44.367 --> 00:12:48.834
So let me show you
what that looks like.

00:12:48.834 --> 00:12:50.801
Let's see...

00:12:54.701 --> 00:12:56.133
Oops.

00:12:56.133 --> 00:12:58.400
Just gonna make this
a little bit bigger here.

00:13:02.701 --> 00:13:04.467
How's that?

00:13:04.467 --> 00:13:06.701
Okay.

00:13:06.701 --> 00:13:09.400
So what I've done
in each pass here...

00:13:09.400 --> 00:13:12.300
you've got each of these
sections marked here.

00:13:12.300 --> 00:13:14.467
Like the things
I'm highlighting

00:13:14.467 --> 00:13:17.133
are examples
of different passes

00:13:17.133 --> 00:13:20.167
that the compiler's
optimization does.

00:13:20.167 --> 00:13:22.701
And we're gonna be able
to trace

00:13:22.701 --> 00:13:25.100
what the Java code looks like
at each step.

00:13:25.100 --> 00:13:27.467
So here's how it starts out.

00:13:27.467 --> 00:13:31.634
And what I've done to help you
follow the changes--

00:13:31.634 --> 00:13:34.834
something that's going to
be changed is underlined.

00:13:34.834 --> 00:13:38.367
And then when that thing changes
in the next step, it's blue.

00:13:38.367 --> 00:13:41.901
Okay?
So underline become blue.

00:13:41.901 --> 00:13:43.868
So the first thing
that happens is

00:13:43.868 --> 00:13:46.467
we realize
that this variable s

00:13:46.467 --> 00:13:50.701
is actually never reassigned,
so we can call it final.

00:13:50.701 --> 00:13:52.400
Okay, that's kind of useful.

00:13:52.400 --> 00:13:54.267
Maybe that can serve us
down the road.

00:13:54.267 --> 00:13:56.234
And the next thing
that happens is...

00:13:56.234 --> 00:14:00.834
the compiler realizes
that this actually...

00:14:00.834 --> 00:14:03.400
it does this trick
to rewrite call sites

00:14:03.400 --> 00:14:06.667
so that instead of it being
a call to this .getShape,

00:14:06.667 --> 00:14:10.200
it can be a call to
a static method .getShape

00:14:10.200 --> 00:14:11.901
and pass in this as a parameter.

00:14:11.901 --> 00:14:13.400
There's a really tricky
reason for this.

00:14:13.400 --> 00:14:18.367
In JavaScript, the key word
"this" is four bytes.

00:14:18.367 --> 00:14:20.801
T-h-i-s.
That's way too costly.

00:14:20.801 --> 00:14:22.601
If you can turn that
into a parameter

00:14:22.601 --> 00:14:25.334
and you can then obfuscate it
to the letter a...

00:14:25.334 --> 00:14:29.701
it's the same object,
but you save 75% of the code.

00:14:32.968 --> 00:14:34.834
And that's only
scratching the surface,

00:14:34.834 --> 00:14:36.200
but I won't bore you
with the details

00:14:36.200 --> 00:14:37.901
of those kinds of tricks.

00:14:37.901 --> 00:14:41.200
Okay. The next step...

00:14:41.200 --> 00:14:44.767
we had decided
that the type of s was final,

00:14:44.767 --> 00:14:46.901
and so that means
it's not gonna be reassigned.

00:14:46.901 --> 00:14:49.667
That means we can actually
tighten the type

00:14:49.667 --> 00:14:51.467
because we know for a fact

00:14:51.467 --> 00:14:55.334
that the getShape method,
as it was defined,

00:14:55.334 --> 00:14:59.100
returns a Square,
and then we can actually see

00:14:59.100 --> 00:15:02.133
that it ultimately returns
a SmallSquare.

00:15:02.133 --> 00:15:04.467
So we tighten the type
all the way down

00:15:04.467 --> 00:15:07.801
to the exact type that
it's going to be assigned to.

00:15:07.801 --> 00:15:09.734
The next thing
the compiler looks at

00:15:09.734 --> 00:15:11.667
is this getArea call.

00:15:14.000 --> 00:15:15.701
It does the same thing
with getArea,

00:15:15.701 --> 00:15:20.501
and you can see here
that it makes it a static call.

00:15:20.501 --> 00:15:21.901
And the next thing it does--

00:15:21.901 --> 00:15:24.033
both of these lines
are underlined--

00:15:24.033 --> 00:15:25.601
I have no idea

00:15:25.601 --> 00:15:29.400
if it's easy to follow what
I'm doing here or not, but...

00:15:29.400 --> 00:15:30.868
the next thing it does,

00:15:30.868 --> 00:15:33.667
is these two underlined lines
get replaced

00:15:33.667 --> 00:15:37.801
so the getShape call
gets inlined.

00:15:37.801 --> 00:15:41.400
Because if you remember,
getShape was a simple method

00:15:41.400 --> 00:15:44.100
that simply returned
the shape field,

00:15:44.100 --> 00:15:46.267
and so why not just make that
a direct field reference

00:15:46.267 --> 00:15:48.167
and get rid of that method
all together?

00:15:48.167 --> 00:15:49.734
So we've just made it faster

00:15:49.734 --> 00:15:51.033
because we don't have
a method call,

00:15:51.033 --> 00:15:52.667
and we've just made
the code smaller

00:15:52.667 --> 00:15:54.901
because we don't have to define
that extra function.

00:15:54.901 --> 00:15:58.434
And every function you define
costs bytes in the download.

00:15:58.434 --> 00:16:00.868
So we've inlined
the field reference,

00:16:00.868 --> 00:16:03.567
an then we've actually
inlined the definition

00:16:03.567 --> 00:16:06.000
of the getArea function.

00:16:06.000 --> 00:16:08.267
But if you'll remember
when we started out,

00:16:08.267 --> 00:16:09.934
getArea was polymorphic.

00:16:09.934 --> 00:16:12.467
But because we were able
to de-virtualize,

00:16:12.467 --> 00:16:13.968
remove the polymorphism,

00:16:13.968 --> 00:16:15.734
we can actually see
that getArea call

00:16:15.734 --> 00:16:19.234
is the getArea call
on SmallSquare

00:16:19.234 --> 00:16:21.300
which it inherits from Square

00:16:21.300 --> 00:16:23.801
to be side lengths
multiplied by each other.

00:16:23.801 --> 00:16:26.167
And then recursively,
we make the same change,

00:16:26.167 --> 00:16:30.234
and we recognize that, okay,
getSideLength

00:16:30.234 --> 00:16:33.167
actually is on the
SmallSquare class definitely,

00:16:33.167 --> 00:16:34.767
and it's not overridden.

00:16:34.767 --> 00:16:38.234
And it definitely returns
the field...

00:16:38.234 --> 00:16:40.601
which happens to be 2,

00:16:40.601 --> 00:16:43.133
and we can propagate
the constant 2

00:16:43.133 --> 00:16:45.667
back into the method
and then inline the method.

00:16:45.667 --> 00:16:47.501
So then it turns into this.

00:16:47.501 --> 00:16:51.467
And then 2x2--we can do that
math in the compiler.

00:16:51.467 --> 00:16:53.601
Why not do that at compile time?

00:16:53.601 --> 00:16:55.167
Why make the JavaScript
interpreter

00:16:55.167 --> 00:16:58.234
waste time doing that,
so we go ahead and do that.

00:16:58.234 --> 00:16:59.734
And then it becomes something

00:16:59.734 --> 00:17:02.334
that we can actually
concatenate the string,

00:17:02.334 --> 00:17:03.701
'cause there's
a well-defined way

00:17:03.701 --> 00:17:05.667
to transform a number
into a string.

00:17:05.667 --> 00:17:07.801
Then we've got string literal
plus string literal.

00:17:07.801 --> 00:17:10.300
Why not concatenate that
at compile time as well?

00:17:10.300 --> 00:17:12.868
And then the last thing is

00:17:12.868 --> 00:17:15.934
we don't need this variable
Shape anymore

00:17:15.934 --> 00:17:18.100
because we've inlined
everything it did

00:17:18.100 --> 00:17:20.334
all the way down
into the call site.

00:17:20.334 --> 00:17:24.133
And so why not just get rid
of that variable all together?

00:17:24.133 --> 00:17:27.367
And so you're left with
optimized code.

00:17:27.367 --> 00:17:29.868
And it really is convenient
for the compiler

00:17:29.868 --> 00:17:33.133
to do that sort of work
on your behalf

00:17:33.133 --> 00:17:36.634
so that, as Lars said today
in the keynote,

00:17:36.634 --> 00:17:39.200
you can think about
your application

00:17:39.200 --> 00:17:41.934
and be more ambitious
and try to build more, you know,

00:17:41.934 --> 00:17:44.734
more functionality
that's useful for the end users

00:17:44.734 --> 00:17:47.067
instead of having
to fiddle with

00:17:47.067 --> 00:17:48.968
the specifics
of hand optimizing

00:17:48.968 --> 00:17:52.267
little bits of JavaScript,
and so on.

00:17:52.267 --> 00:17:53.801
All right...that's the stuff

00:17:53.801 --> 00:17:55.434
we really should have
told you about last year.

00:17:55.434 --> 00:17:57.000
The stuff we're gonna tell you
more about this year

00:17:57.000 --> 00:17:58.834
is code splitting.

00:17:58.834 --> 00:18:00.968
Okay, so why is
code splitting useful?

00:18:00.968 --> 00:18:03.701
It's kind of obvious,
but let's get really specific.

00:18:03.701 --> 00:18:06.634
Traditionally, you download
the HTML host page,

00:18:06.634 --> 00:18:09.367
then you download
a large chunk of JavaScript,

00:18:09.367 --> 00:18:11.834
and then the code
starts to run.

00:18:11.834 --> 00:18:14.968
So this yellow area here,
the JS,

00:18:14.968 --> 00:18:16.467
we really would rather

00:18:16.467 --> 00:18:18.100
the code start running
before all that's loaded.

00:18:18.100 --> 00:18:19.634
But you can't generally do that

00:18:19.634 --> 00:18:23.133
unless there's a sound way
to split the code apart.

00:18:23.133 --> 00:18:26.067
So what happens
with code splitting

00:18:26.067 --> 00:18:28.634
is you can break
that JavaScript into chunks.

00:18:28.634 --> 00:18:32.400
And so the user experience
goes...load the HTML host page,

00:18:32.400 --> 00:18:33.968
load the startup fragment,

00:18:33.968 --> 00:18:37.701
which is the left-most
JavaScript that you see here.

00:18:37.701 --> 00:18:40.067
Then the code
can start running.

00:18:40.067 --> 00:18:42.968
And because the code splitting
API is designed to be

00:18:42.968 --> 00:18:45.868
an asynchronous fetch of code,

00:18:45.868 --> 00:18:48.767
the user can continue using
the application

00:18:48.767 --> 00:18:52.400
even while the lazily loaded
fragment of code

00:18:52.400 --> 00:18:54.334
is still being fetched
in the background.

00:18:54.334 --> 00:18:58.000
because the network, you know,
might take a long time, right?

00:18:58.000 --> 00:19:00.567
So the application
remains usable

00:19:00.567 --> 00:19:03.901
even while more code
is loading.

00:19:03.901 --> 00:19:06.534
I guess that's kind of obvious,
but the net effect is

00:19:06.534 --> 00:19:09.100
that you see the sum
of all the green

00:19:09.100 --> 00:19:10.667
is the amount of time

00:19:10.667 --> 00:19:12.267
that the user's able
to use the application.

00:19:12.267 --> 00:19:14.734
And there's a significantly
longer amount of time

00:19:14.734 --> 00:19:16.334
that the application
is active,

00:19:16.334 --> 00:19:18.434
and it stays active
the whole time.

00:19:18.434 --> 00:19:22.234
So...ultimately, when you're
designing big applications,

00:19:22.234 --> 00:19:24.534
you should try to get used
to the idea

00:19:24.534 --> 00:19:28.000
of the app never being,
you know, fully loaded.

00:19:28.000 --> 00:19:31.300
It means that the more
you can think about

00:19:31.300 --> 00:19:34.834
various pieces of functionality
as being able to be broken off

00:19:34.834 --> 00:19:37.534
and pulled in on demand,

00:19:37.534 --> 00:19:40.667
generally,
the better off you'll be.

00:19:40.667 --> 00:19:43.100
It's not always strictly true,
obviously.

00:19:43.100 --> 00:19:46.234
I mean, some cases, you
definitely want functionality

00:19:46.234 --> 00:19:48.801
to be immediately available
from the very beginning.

00:19:48.801 --> 00:19:51.567
And that's why this is developer
guided code splitting.

00:19:51.567 --> 00:19:54.767
You can decide where you're
willing to tolerate

00:19:54.767 --> 00:19:56.868
you know, a delay
under some circumstances,

00:19:56.868 --> 00:19:58.467
or where you're not willing
to tolerate it.

00:19:58.467 --> 00:20:02.968
And you indicate that
by having a split point or not.

00:20:02.968 --> 00:20:05.501
But you've probably already
seen this API a lot now.

00:20:05.501 --> 00:20:07.767
GWT.runAsync,
it has a Callback.

00:20:07.767 --> 00:20:10.667
onSuccess happens
when the code loads,

00:20:10.667 --> 00:20:12.367
and then the failure path

00:20:12.367 --> 00:20:15.901
if the code cannot be loaded
for some reason.

00:20:15.901 --> 00:20:18.501
So now I'd like to introduce
Lex Spoon.

00:20:18.501 --> 00:20:22.801
Lex is the guy who actually
invented code splitting

00:20:22.801 --> 00:20:24.200
and made it all work,

00:20:24.200 --> 00:20:26.000
and he's gonna take you
through an example

00:20:26.000 --> 00:20:27.400
of how to benefit from it

00:20:27.400 --> 00:20:30.534
and how to understand
exactly what's happening

00:20:30.534 --> 00:20:32.968
if your code isn't splitting
the way that you want to.

00:20:32.968 --> 00:20:35.667
Take it away, Lex.
Spoon: Thanks, Bruce. So...

00:20:35.667 --> 00:20:40.801
[applause]

00:20:40.801 --> 00:20:43.133
Let's maybe start
on the optimistic side

00:20:43.133 --> 00:20:45.501
and imagine that the code
splitting goes the way you want.

00:20:45.501 --> 00:20:49.467
So as a running example,
you might have an application

00:20:49.467 --> 00:20:52.901
that can both read and write
something similar to an email.

00:20:52.901 --> 00:20:55.000
It might be an advanced email

00:20:55.000 --> 00:20:58.634
that Google's about to release
later this year.

00:20:58.634 --> 00:21:01.834
So, as you can imagine,
the code to compose an email

00:21:01.834 --> 00:21:03.534
is actually pretty hefty,

00:21:03.534 --> 00:21:05.567
especially if you've put
a lot of effort into

00:21:05.567 --> 00:21:08.234
really making each keystroke
do exactly what you want.

00:21:08.234 --> 00:21:12.367
So that's kind of unfortunate
if you don't use code splitting

00:21:12.367 --> 00:21:15.167
because if you think about
the way your app is structured,

00:21:15.167 --> 00:21:17.133
all the code in yellow
in this diagram

00:21:17.133 --> 00:21:19.300
is code used
for composing email,

00:21:19.300 --> 00:21:21.300
and yet,
if you don't split any code,

00:21:21.300 --> 00:21:24.567
all that has to download
before the inbox shows up

00:21:24.567 --> 00:21:26.434
on your user screen.

00:21:26.434 --> 00:21:29.701
So this is a good scenario
for code splitting

00:21:29.701 --> 00:21:32.501
because there's a lot of code
that's not needed initially

00:21:32.501 --> 00:21:35.300
that you'd like to let them
start reading email

00:21:35.300 --> 00:21:38.000
while you download the rest
of the code and background.

00:21:38.000 --> 00:21:39.901
So to see how that looks,

00:21:39.901 --> 00:21:41.434
in the initial version
of your app,

00:21:41.434 --> 00:21:43.400
you might have
a button somewhere...

00:21:43.400 --> 00:21:46.033
it has a callback
that calls this little method

00:21:46.033 --> 00:21:48.000
onComposeEmailButtonClicked.

00:21:48.000 --> 00:21:49.200
And in the initial version,

00:21:49.200 --> 00:21:52.501
it simply opens
the ComposeView.

00:21:52.501 --> 00:21:54.501
Well, you'd like
to split this out,

00:21:54.501 --> 00:21:56.834
so instead, what you can do

00:21:56.834 --> 00:22:00.667
is wrap that exact same code
inside a call to runAsync.

00:22:00.667 --> 00:22:03.000
So this is just like
setting up an event handler

00:22:03.000 --> 00:22:05.033
in a GUI framework,

00:22:05.033 --> 00:22:09.234
except the event in this case
is that more code has arrived.

00:22:09.234 --> 00:22:12.901
Now, it is also possible
that the code never arrives,

00:22:12.901 --> 00:22:14.934
so one downside
of code splitting

00:22:14.934 --> 00:22:17.300
is you have to think about
that extra possibility.

00:22:17.300 --> 00:22:18.968
And we force you to also write

00:22:18.968 --> 00:22:21.968
an onFailure branch
of your Callback.

00:22:21.968 --> 00:22:26.234
And that's really gonna be
app-specific handler.

00:22:26.234 --> 00:22:28.734
So that's pretty simple code,
we think.

00:22:28.734 --> 00:22:31.534
And as a result, you end up
with something like this.

00:22:31.534 --> 00:22:34.868
In the initial download,
you download the green parts

00:22:34.868 --> 00:22:37.667
and you download
the yellow parts later.

00:22:37.667 --> 00:22:40.267
You also initially download
this extra failure code

00:22:40.267 --> 00:22:42.434
which we all hate
to think about.

00:22:42.434 --> 00:22:44.567
But it is an extra
code path that you get.

00:22:44.567 --> 00:22:46.634
But usually that's pretty small,

00:22:46.634 --> 00:22:49.133
and so in some, the initial
download of your app's

00:22:49.133 --> 00:22:51.467
gotten a lot smaller.

00:22:51.467 --> 00:22:53.367
Something we like to brag about
about the system

00:22:53.367 --> 00:22:56.534
is that it's not just your code
that gets split up either.

00:22:56.534 --> 00:23:01.067
The two different parts
of your reader...

00:23:01.067 --> 00:23:02.934
the email reading code

00:23:02.934 --> 00:23:04.801
might use one part
of the standard library.

00:23:04.801 --> 00:23:07.300
The email composing code
might use a different part.

00:23:07.300 --> 00:23:10.501
And we'll actually
split that up for you too.

00:23:10.501 --> 00:23:11.901
So as you can see,

00:23:11.901 --> 00:23:14.334
2 and 4 are actually
from the same library,

00:23:14.334 --> 00:23:17.000
but they got split in half.

00:23:17.000 --> 00:23:19.968
So that's when things
are going good.

00:23:19.968 --> 00:23:21.501
If you'll forgive me,

00:23:21.501 --> 00:23:23.000
I'll dwell
for the rest of the talk

00:23:23.000 --> 00:23:24.567
on things
that don't go so well

00:23:24.567 --> 00:23:26.968
and what you can do about it.

00:23:26.968 --> 00:23:29.501
So maybe you're the guy who
did the initial code splitting,

00:23:29.501 --> 00:23:30.767
and you're thinking,

00:23:30.767 --> 00:23:32.501
"Code splitting, code splitting,
code splitting."

00:23:32.501 --> 00:23:34.801
And you got it split out
and you bragged about it

00:23:34.801 --> 00:23:36.868
at the weekly group meeting.

00:23:36.868 --> 00:23:38.901
And you sent some nice graphs.

00:23:38.901 --> 00:23:41.901
Next week, another teammate
of yours is thinking,

00:23:41.901 --> 00:23:44.267
"Keystroke handling, keystroke
handling, keystroke handling."

00:23:44.267 --> 00:23:46.067
And they come into the meeting
and they show you

00:23:46.067 --> 00:23:48.033
some great keystroke
handling code

00:23:48.033 --> 00:23:50.334
they've written
down on the bottom right.

00:23:50.334 --> 00:23:52.267
You'll notice this looks
suspiciously like

00:23:52.267 --> 00:23:55.434
the original code I showed you
for mouseClick handling.

00:23:55.434 --> 00:23:57.267
And the result
of writing this code

00:23:57.267 --> 00:24:00.334
is that your app's
gonna look like this again.

00:24:00.334 --> 00:24:03.234
This is a little difficult
to deal with, I must admit,

00:24:03.234 --> 00:24:05.901
because the two different
developers,

00:24:05.901 --> 00:24:08.701
they're just not thinking
about the same thing.

00:24:08.701 --> 00:24:10.734
And so they've both
accomplished their task,

00:24:10.734 --> 00:24:12.133
but unfortunately,

00:24:12.133 --> 00:24:14.467
the second guy has undone
your good work.

00:24:14.467 --> 00:24:15.868
So first of all,

00:24:15.868 --> 00:24:17.434
I'll show you what to do
in this situation,

00:24:17.434 --> 00:24:19.534
'cause no matter
how well you plan,

00:24:19.534 --> 00:24:21.667
things are gonna get messed up.

00:24:21.667 --> 00:24:23.501
And then I'll try to show you

00:24:23.501 --> 00:24:25.367
some engineering practices
you might try

00:24:25.367 --> 00:24:27.467
to prevent this from happening
in the first place

00:24:27.467 --> 00:24:30.400
or at least reduce the odds.

00:24:30.400 --> 00:24:32.033
So first of all,

00:24:32.033 --> 00:24:34.534
imagine you noticed
you've got some build metrics,

00:24:34.534 --> 00:24:36.667
and you notice that, gee,

00:24:36.667 --> 00:24:38.200
my initial download
just went back up

00:24:38.200 --> 00:24:40.200
to almost
the whole program again.

00:24:40.200 --> 00:24:44.801
GWT 2.0 will include a tool
called the Story of Your Compile

00:24:44.801 --> 00:24:48.334
or, as we like to pronounce
our acronyms,

00:24:48.334 --> 00:24:49.968
it's SOYC.

00:24:49.968 --> 00:24:52.000
I think it sounds like

00:24:52.000 --> 00:24:56.133
some kind of vitamin
breakfast shake.

00:24:56.133 --> 00:24:58.567
And it tells you...

00:24:58.567 --> 00:25:00.901
a few really useful things
about your program,

00:25:00.901 --> 00:25:03.467
including how to debug
this particular problem.

00:25:03.467 --> 00:25:05.567
So it tells you--
first of all, it tells you

00:25:05.567 --> 00:25:08.734
which parts of your code
download initially versus later.

00:25:08.734 --> 00:25:11.701
It tells you how big
each one of those is.

00:25:11.701 --> 00:25:14.534
So this is pretty useful
outside of code splitting

00:25:14.534 --> 00:25:16.267
because you want to--

00:25:16.267 --> 00:25:19.100
when you're measuring your
latencies in milliseconds,

00:25:19.100 --> 00:25:20.934
every kilobyte counts,

00:25:20.934 --> 00:25:22.767
and you'd like to know
where to focus your efforts

00:25:22.767 --> 00:25:25.067
on shrinking
your code down.

00:25:25.067 --> 00:25:26.968
And importantly,
for code splitting,

00:25:26.968 --> 00:25:28.601
if something's
in the initial download,

00:25:28.601 --> 00:25:29.968
it'll tell you why.

00:25:29.968 --> 00:25:32.100
It'll tell you what
the compiler was thinking

00:25:32.100 --> 00:25:34.200
when it...

00:25:34.200 --> 00:25:36.200
when it screwed up
your code splitting

00:25:36.200 --> 00:25:38.300
and put it in
the initial download.

00:25:38.300 --> 00:25:40.367
So let's take a quick tour.

00:25:40.367 --> 00:25:44.601
If you had a simple
sample app that was...

00:25:44.601 --> 00:25:46.634
reading and composing email,

00:25:46.634 --> 00:25:49.267
if you open up
a Story of Your Compile,

00:25:49.267 --> 00:25:51.834
you'll see something
that looks like this.

00:25:51.834 --> 00:25:53.868
So the front page of it
tells you

00:25:53.868 --> 00:25:56.100
the overall size in bytes

00:25:56.100 --> 00:25:59.100
of the code that's gonna
download to users,

00:25:59.100 --> 00:26:03.033
of the different downloadable
chunks of code you've got.

00:26:03.033 --> 00:26:06.400
So the top line is the entire
amount of code you've got.

00:26:06.400 --> 00:26:07.701
That's if they hit

00:26:07.701 --> 00:26:09.234
every single runAsync
in the program

00:26:09.234 --> 00:26:11.067
and they end up
downloading everything.

00:26:11.067 --> 00:26:14.667
This case, it's 30 kilobytes.
It's pretty small.

00:26:14.667 --> 00:26:17.334
The next line shows you
what they download to start with

00:26:17.334 --> 00:26:20.834
and in this case...
it's almost the whole thing.

00:26:20.834 --> 00:26:22.801
So the bar's pretty far over.

00:26:22.801 --> 00:26:25.734
This is
an unfortunate situation.

00:26:25.734 --> 00:26:28.200
The last line
just further rubs in the fact

00:26:28.200 --> 00:26:30.000
that this is
what downloads later

00:26:30.000 --> 00:26:31.534
after they reach
that split point,

00:26:31.534 --> 00:26:33.234
and you'll notice it's such
a small amount of code

00:26:33.234 --> 00:26:36.300
that the graphics didn't even
render quite right for the bar.

00:26:36.300 --> 00:26:38.501
So...

00:26:38.501 --> 00:26:41.901
all right, so this
is what you'll discover,

00:26:41.901 --> 00:26:43.467
and you'll say, okay,

00:26:43.467 --> 00:26:45.100
what's going on
in the initial download

00:26:45.100 --> 00:26:47.267
that looks wrong?

00:26:47.267 --> 00:26:50.033
This is a view we expect
you'll be staring at a lot

00:26:50.033 --> 00:26:53.434
as you try to optimize
your program in the future.

00:26:53.434 --> 00:26:56.634
This shows you the size
of different parts of your code

00:26:56.634 --> 00:27:00.100
broken down
in four different ways.

00:27:00.100 --> 00:27:03.634
Today, I'd like to just focus
on the top left breakdown,

00:27:03.634 --> 00:27:06.367
which is a breakdown
by Java packages.

00:27:06.367 --> 00:27:08.367
So if you go down
that top list--

00:27:08.367 --> 00:27:10.601
it's probably hard to read
on the screen--

00:27:10.601 --> 00:27:13.934
but the top one is java.util.

00:27:13.934 --> 00:27:15.100
So this is a pretty small app.

00:27:15.100 --> 00:27:17.067
It turns out
that the collection overhead

00:27:17.067 --> 00:27:20.000
or the implementation
of collection classes

00:27:20.000 --> 00:27:22.534
is actually pretty heavyweight
for this app.

00:27:22.534 --> 00:27:25.601
Then you'll see the third entry
is java.lang,

00:27:25.601 --> 00:27:28.634
so it's more runtime support.

00:27:28.634 --> 00:27:32.601
You'll see a lot of
com/google.gwt user stuff.

00:27:32.601 --> 00:27:35.100
That's the widget
implementation.

00:27:35.100 --> 00:27:37.567
All of this is probably
not what went wrong,

00:27:37.567 --> 00:27:39.868
assuming you kept
a fixed version of GWT

00:27:39.868 --> 00:27:40.901
for all of these samples.

00:27:40.901 --> 00:27:42.100
It must be the fact

00:27:42.100 --> 00:27:44.501
that something went wrong
in this package,

00:27:44.501 --> 00:27:48.434
which is--let's imagine
the implementation of your...

00:27:48.434 --> 00:27:50.868
of your application.

00:27:50.868 --> 00:27:52.767
Well, if you select that item,

00:27:52.767 --> 00:27:54.367
it gives you
a breakdown of each

00:27:54.367 --> 00:27:56.000
on a class-by-class basis.

00:27:56.000 --> 00:27:57.701
So we're drilling down into

00:27:57.701 --> 00:28:00.367
where we suspect
a problem might lie.

00:28:00.367 --> 00:28:03.100
And actually now,
it's pretty obvious.

00:28:03.100 --> 00:28:05.000
If you're someone
who knows your own app,

00:28:05.000 --> 00:28:07.234
you'll see that this top bar
is humongous.

00:28:07.234 --> 00:28:09.567
It's the EmailCompositionView.

00:28:09.567 --> 00:28:11.868
And especially
if you go talk to the person,

00:28:11.868 --> 00:28:14.334
the code splitter, code
splitter, code splitter person,

00:28:14.334 --> 00:28:16.067
they're gonna say
that's crazy.

00:28:16.067 --> 00:28:17.634
We don't use the CompositionView
initially.

00:28:17.634 --> 00:28:19.234
And you say, well, yes, we do.

00:28:19.234 --> 00:28:21.167
If you click on this guy,

00:28:21.167 --> 00:28:23.501
it will go to each method
in that class,

00:28:23.501 --> 00:28:27.667
and it'll tell you why
the compiler thinks you need it.

00:28:27.667 --> 00:28:30.601
So if I can draw your
attention to the third entry,

00:28:30.601 --> 00:28:34.968
the show method...you'll see
it's called directly by

00:28:34.968 --> 00:28:36.300
onComposeKeystrokeClick.

00:28:36.300 --> 00:28:37.601
That's the method

00:28:37.601 --> 00:28:39.667
that this fellow
just implemented last week.

00:28:39.667 --> 00:28:42.000
You finally figured it out
on Tuesday or Wednesday.

00:28:42.000 --> 00:28:43.868
And you can go chase
that guy down

00:28:43.868 --> 00:28:45.400
and say, what you should
have done

00:28:45.400 --> 00:28:47.801
is you should have
coded it like this.

00:28:47.801 --> 00:28:50.334
So you show him
your ComposeEmail method,

00:28:50.334 --> 00:28:51.667
and then they do
the same thing

00:28:51.667 --> 00:28:54.133
in their
ComposeKeystroke method.

00:28:54.133 --> 00:28:56.701
I call this the Whack-a-Mole
solution to code splitting.

00:28:56.701 --> 00:29:00.334
You get it the way
you want it to work.

00:29:00.334 --> 00:29:02.601
You find out
there's something wrong.

00:29:02.601 --> 00:29:05.234
And then you just go
look at your dependencies.

00:29:05.234 --> 00:29:07.334
You pick some method
in the chain.

00:29:07.334 --> 00:29:09.167
In this case, we picked
onComposeKeystrokeClick.

00:29:09.167 --> 00:29:11.634
And you put a cut point
right there.

00:29:11.634 --> 00:29:13.434
It won't always work
the first time.

00:29:13.434 --> 00:29:14.901
Sometimes it'll still be
in the initial download.

00:29:14.901 --> 00:29:16.267
You'll go to here,

00:29:16.267 --> 00:29:18.033
and you'll get a different
set of dependencies.

00:29:18.033 --> 00:29:21.267
So this is a very reactionary
kind of way

00:29:21.267 --> 00:29:22.767
to improve your code splitting.

00:29:22.767 --> 00:29:24.133
It will eventually work.

00:29:24.133 --> 00:29:26.567
You will eventually cut out
enough little pieces

00:29:26.567 --> 00:29:30.033
that you got the part off
that you wanted.

00:29:30.033 --> 00:29:32.767
You'll eventually
get back to here again.

00:29:32.767 --> 00:29:36.601
However, the Whack-a-Mole style
of problem solving

00:29:36.601 --> 00:29:37.968
leaves a little bit to desired

00:29:37.968 --> 00:29:41.133
from sound software
engineering practices.

00:29:41.133 --> 00:29:43.133
You just don't wanna be
a manager

00:29:43.133 --> 00:29:46.434
who's watching your product
regularly degrade

00:29:46.434 --> 00:29:48.334
and then having your developers
go scramble

00:29:48.334 --> 00:29:50.000
to figure out, okay,
what went wrong,

00:29:50.000 --> 00:29:53.234
and then fix it back again.

00:29:53.234 --> 00:29:55.267
So...

00:29:55.267 --> 00:29:57.501
we'd like to come up with
some kind of systematic solution

00:29:57.501 --> 00:29:58.968
to this problem,

00:29:58.968 --> 00:30:01.434
and I want to tell you about one
we've been thinking about.

00:30:01.434 --> 00:30:05.701
This is a fairly new...

00:30:05.701 --> 00:30:07.367
programming permitted
we think,

00:30:07.367 --> 00:30:09.667
so maybe there'll be other ones
coming down the road.

00:30:09.667 --> 00:30:11.000
But let me show you one

00:30:11.000 --> 00:30:15.067
that we call the async package
coding pattern.

00:30:15.067 --> 00:30:19.934
This is actually in use by
multiple GWT clients already,

00:30:19.934 --> 00:30:23.367
and they seem pretty happy
with it, so...

00:30:23.367 --> 00:30:24.834
The goal of this pattern

00:30:24.834 --> 00:30:26.868
is that you don't want
everyone on the application--

00:30:26.868 --> 00:30:30.200
you don't want every developer
to have to understand

00:30:30.200 --> 00:30:33.667
what every library did
to get its code split out.

00:30:33.667 --> 00:30:35.400
What you'd like to do

00:30:35.400 --> 00:30:37.601
is you'd like to at least
narrow the focus down

00:30:37.601 --> 00:30:39.767
to the developer
of a library.

00:30:39.767 --> 00:30:40.968
So in this case,

00:30:40.968 --> 00:30:42.601
we want to make the email
composition guy

00:30:42.601 --> 00:30:44.667
think about how to get
the code split out.

00:30:44.667 --> 00:30:46.200
And we want everybody else

00:30:46.200 --> 00:30:48.067
to just get the splitting
automatically.

00:30:48.067 --> 00:30:51.267
We don't want them to have
this tempting method called show

00:30:51.267 --> 00:30:53.300
that they're not
supposed to call.

00:30:53.300 --> 00:30:55.167
Except very carefully.

00:30:55.167 --> 00:30:58.434
So to accomplish this,
what you can do is...

00:30:58.434 --> 00:31:01.801
remove all direct access
to the classes in that package.

00:31:01.801 --> 00:31:06.167
So just don't have a public
static method called show.

00:31:06.167 --> 00:31:09.400
Instead, provide them
one gateway class

00:31:09.400 --> 00:31:11.901
called email composition,

00:31:11.901 --> 00:31:15.067
and make sure everybody has
to go through that gateway class

00:31:15.067 --> 00:31:17.234
to do anything
with your package.

00:31:17.234 --> 00:31:20.767
You can use Java protections
to accomplish this.

00:31:23.567 --> 00:31:26.400
Make sure that the only way
to create that gateway class

00:31:26.400 --> 00:31:28.901
is inside a runAsync somewhere.

00:31:28.901 --> 00:31:31.000
If you can write your app
using this pattern,

00:31:31.000 --> 00:31:32.234
you're in pretty good shape,

00:31:32.234 --> 00:31:34.100
because you can only get at
the functionality

00:31:34.100 --> 00:31:35.501
through the gateway,

00:31:35.501 --> 00:31:37.968
and the gateway's only
constructed inside a runAsync,

00:31:37.968 --> 00:31:39.934
so therefore, there's no way
to access the code

00:31:39.934 --> 00:31:43.734
except after a runAsync
has been called.

00:31:43.734 --> 00:31:46.701
So that probably sounded
a little abstract.

00:31:46.701 --> 00:31:48.200
I'd like to walk through

00:31:48.200 --> 00:31:50.901
the way this code looks
real quick.

00:31:50.901 --> 00:31:53.901
So...make a gateway class

00:31:53.901 --> 00:31:56.667
usually named the same thing
as your actual module.

00:31:56.667 --> 00:31:58.467
And make a constructor private

00:31:58.467 --> 00:32:02.467
so that nobody but itself
can create it.

00:32:02.467 --> 00:32:04.467
Take all the static
methods you have,

00:32:04.467 --> 00:32:06.501
and make them instance methods.

00:32:06.501 --> 00:32:08.234
This way, if anybody
tries to call it,

00:32:08.234 --> 00:32:10.334
they're gonna get a complaint
from the Java compiler

00:32:10.334 --> 00:32:12.567
instead of getting
a complaint from

00:32:12.567 --> 00:32:14.734
whoever's watching
the performance of your app

00:32:14.734 --> 00:32:17.868
who noticed that it just
suddenly degraded.

00:32:17.868 --> 00:32:20.067
Now, to provide access
to this thing,

00:32:20.067 --> 00:32:21.801
make a static method,

00:32:21.801 --> 00:32:24.567
which is conventionally called
createAsync.

00:32:24.567 --> 00:32:27.634
It takes
a user supply callback

00:32:27.634 --> 00:32:29.801
and then inside a runAsync,

00:32:29.801 --> 00:32:32.067
it creates an instance
of the gateway,

00:32:32.067 --> 00:32:36.200
and it calls the callback
with that instance.

00:32:36.200 --> 00:32:38.300
The rest of this
is pretty straightforward.

00:32:38.300 --> 00:32:39.601
If there's a failure
to download the code,

00:32:39.601 --> 00:32:42.033
you just buck that
back to the user.

00:32:42.033 --> 00:32:44.968
And the actual callback
interface, as you can see,

00:32:44.968 --> 00:32:48.701
looks pretty much the same
as a RunAsyncCallback interface

00:32:48.701 --> 00:32:50.334
except that
in the success branch,

00:32:50.334 --> 00:32:51.567
there's now an argument.

00:32:51.567 --> 00:32:52.868
onCreated takes an argument

00:32:52.868 --> 00:32:56.400
which is an instance
of the gateway.

00:32:56.400 --> 00:32:58.467
On the user side,
it also looks a lot like

00:32:58.467 --> 00:33:00.767
just using a regular old
runAsync, so...

00:33:00.767 --> 00:33:02.434
this coding pattern,
we don't think,

00:33:02.434 --> 00:33:06.200
is gonna be very difficult
for users to have to deal with

00:33:06.200 --> 00:33:08.334
compared to what
they'd write anyway.

00:33:08.334 --> 00:33:09.868
The only difference is that

00:33:09.868 --> 00:33:12.133
in their onCreated
success branch

00:33:12.133 --> 00:33:13.634
they get an instance
of the gateway,

00:33:13.634 --> 00:33:15.601
which is called view
in this case.

00:33:15.601 --> 00:33:17.200
And then once they've got
that instance,

00:33:17.200 --> 00:33:18.901
they can do stuff with it
like...

00:33:18.901 --> 00:33:23.901
they can call "show"
and pop up a composition window.

00:33:23.901 --> 00:33:26.300
So that's a pretty fun pattern.

00:33:26.300 --> 00:33:28.133
That's the basics of it.

00:33:28.133 --> 00:33:29.434
I'd like to mention

00:33:29.434 --> 00:33:32.534
that once you're writing
your own gateway class,

00:33:32.534 --> 00:33:35.567
you can...

00:33:35.567 --> 00:33:37.400
you're in a position
to improve on it.

00:33:37.400 --> 00:33:40.100
For example, the way I showed it
to you the first time,

00:33:40.100 --> 00:33:43.901
you create a new instance of it
every time in every callback.

00:33:43.901 --> 00:33:45.300
You may as well cache
that instance

00:33:45.300 --> 00:33:47.767
as a private static field
of the gateway

00:33:47.767 --> 00:33:50.167
so that if they call it again,
they'll get the same one.

00:33:50.167 --> 00:33:52.234
That way, you can have
the equivalent of

00:33:52.234 --> 00:33:55.501
variables that are
scoped to the module.

00:33:55.501 --> 00:33:58.667
Another fun one is that...

00:33:58.667 --> 00:34:00.033
the caller doesn't have to

00:34:00.033 --> 00:34:01.501
always go through
the createAsync.

00:34:01.501 --> 00:34:04.167
They only need to do it once
and get an actual instance.

00:34:04.167 --> 00:34:07.968
So what you can do
is you can arrange your code

00:34:07.968 --> 00:34:10.667
such that it takes instances
of that class--

00:34:10.667 --> 00:34:13.868
key parts of your code require
an instance of that class

00:34:13.868 --> 00:34:14.968
as a prerequisite to even

00:34:14.968 --> 00:34:16.868
constructing
that part of the code.

00:34:16.868 --> 00:34:18.701
This is a dependency
injection style

00:34:18.701 --> 00:34:20.234
where you're injecting
dependencies

00:34:20.234 --> 00:34:23.100
via constructor parameters.

00:34:23.100 --> 00:34:25.701
So just as an example,

00:34:25.701 --> 00:34:28.467
if you're writing
a SpellCheckingPlugin

00:34:28.467 --> 00:34:31.334
to your CompositionView,
you might--

00:34:31.334 --> 00:34:33.267
suppose it takes
an instance of the gateway

00:34:33.267 --> 00:34:34.467
as a constructor parameter

00:34:34.467 --> 00:34:36.267
and then just says
this.view=view.

00:34:36.267 --> 00:34:37.934
It just hangs onto it.

00:34:37.934 --> 00:34:41.067
Well, now anywhere
in this plugin that you want,

00:34:41.067 --> 00:34:43.868
you can make direct calls
onto the view object.

00:34:43.868 --> 00:34:45.734
So by having the forethought

00:34:45.734 --> 00:34:48.534
to save aside the instance
of that module,

00:34:48.534 --> 00:34:51.000
you've made the rest of the code
as plug-in pretty convenient.

00:34:51.000 --> 00:34:53.267
You don't have to sprinkle
createAsyncs

00:34:53.267 --> 00:34:54.634
all over your code

00:34:54.634 --> 00:34:57.167
if you save
the instance of the view.

00:34:57.167 --> 00:34:58.667
It still turns out

00:34:58.667 --> 00:35:01.133
that dependency injection
will help you in other ways.

00:35:01.133 --> 00:35:04.067
If you can stick around
for Ray Ryan's talk after this,

00:35:04.067 --> 00:35:05.934
you'll see how it helps you
with testing.

00:35:05.934 --> 00:35:10.501
You can mock out the view
to a testing style pretty easily

00:35:10.501 --> 00:35:12.767
once you're using this style.

00:35:14.934 --> 00:35:17.567
So yeah, and once you're
writing your own,

00:35:17.567 --> 00:35:19.434
you can improve it
in various ways.

00:35:19.434 --> 00:35:21.367
Like one of the common things
you want to do

00:35:21.367 --> 00:35:24.534
as a app writer
to be user friendly,

00:35:24.534 --> 00:35:26.133
if you're about to hit
a network delay,

00:35:26.133 --> 00:35:27.801
you'd like to tell the user

00:35:27.801 --> 00:35:29.834
that the app hasn't
just frozen up.

00:35:29.834 --> 00:35:32.834
So...and that can happen

00:35:32.834 --> 00:35:35.667
if you call a runAsync
and the code's not available.

00:35:35.667 --> 00:35:37.100
However, if the code
is available,

00:35:37.100 --> 00:35:38.634
you don't want to flash
an indication up

00:35:38.634 --> 00:35:40.501
that immediately flashes away.

00:35:40.501 --> 00:35:42.734
So you could put the onus
on the gateway class

00:35:42.734 --> 00:35:45.734
to figure out whether it needs
any more code to download.

00:35:45.734 --> 00:35:48.100
And you could, for example,
add an extra method

00:35:48.100 --> 00:35:49.701
to the callback interface
that says,

00:35:49.701 --> 00:35:51.634
hey, I need to actually
do a download.

00:35:51.634 --> 00:35:53.834
You might want to pop up
an indicator.

00:35:53.834 --> 00:35:55.801
And then otherwise
leave it alone.

00:35:55.801 --> 00:35:57.100
That's just an example.

00:35:57.100 --> 00:35:58.801
We don't know exactly what

00:35:58.801 --> 00:36:01.534
the optimal gateway class
looks like.

00:36:01.534 --> 00:36:04.601
But it looks like a promising
kind of coding pattern

00:36:04.601 --> 00:36:08.634
to think about.

00:36:08.634 --> 00:36:12.300
So that's what we wanted
to show you today.

00:36:12.300 --> 00:36:14.767
We wanted to show you
some tools that we provide

00:36:14.767 --> 00:36:17.534
so that you can help improve
your own performance.

00:36:17.534 --> 00:36:19.834
As much as possible,
we try to make GWT

00:36:19.834 --> 00:36:22.067
just make your app rock.

00:36:22.067 --> 00:36:25.801
But to the extent it doesn't,
we provide several tools

00:36:25.801 --> 00:36:28.000
that'll help you debug
what's going on

00:36:28.000 --> 00:36:29.634
and then incrementally
improve.

00:36:29.634 --> 00:36:32.567
So we showed you how to
reduce the code size

00:36:32.567 --> 00:36:35.133
due to RPC transmissions.

00:36:35.133 --> 00:36:37.534
This is an extraordinarily
common thing to happen

00:36:37.534 --> 00:36:39.667
with people who use GWT RPC

00:36:39.667 --> 00:36:44.033
is that they just
accidentally put a type...

00:36:44.033 --> 00:36:47.033
they try to pass
class exception across the wire.

00:36:47.033 --> 00:36:50.267
And GWT dutifully
gives you code

00:36:50.267 --> 00:36:52.000
to serialize
every kind of exception

00:36:52.000 --> 00:36:54.000
that you have available
in your class path.

00:36:54.000 --> 00:36:55.067
If you look at these files,

00:36:55.067 --> 00:36:56.367
you can figure out
pretty quickly

00:36:56.367 --> 00:36:57.534
that you didn't mean to send

00:36:57.534 --> 00:36:59.133
an illegal argument exception
across the wire

00:36:59.133 --> 00:37:01.167
and improve that.

00:37:01.167 --> 00:37:03.501
We're showing you how you can

00:37:03.501 --> 00:37:08.033
look into what
the optimizer's doing.

00:37:08.033 --> 00:37:11.067
A lot of times,
a small tweak to your code

00:37:11.067 --> 00:37:13.200
will yield just dramatically
better output.

00:37:13.200 --> 00:37:16.200
You love it when you get output
that looks like window.alert

00:37:16.200 --> 00:37:18.467
and then a literal,
a string literal.

00:37:18.467 --> 00:37:21.801
So...it's worth trying
to tease the optimizer

00:37:21.801 --> 00:37:23.734
into doing those sort of things,

00:37:23.734 --> 00:37:25.534
and the only real way
you can do that

00:37:25.534 --> 00:37:28.234
is to actually look
at what it's doing.

00:37:28.234 --> 00:37:29.901
And finally,
we've shown you

00:37:29.901 --> 00:37:33.167
how to use code splitting
and how to...

00:37:33.167 --> 00:37:34.667
how to debug
what's going wrong with it

00:37:34.667 --> 00:37:36.133
if it doesn't do
the right thing,

00:37:36.133 --> 00:37:39.100
and we've suggested
a coding pattern.

00:37:39.100 --> 00:37:40.868
So if you all have
any questions,

00:37:40.868 --> 00:37:42.534
we have plenty of time.

00:37:42.534 --> 00:37:44.334
You want to come up?

00:37:44.334 --> 00:37:47.267
[applause]

00:37:51.367 --> 00:37:54.067
Yeah, you wanna
come up here and...

00:37:54.067 --> 00:37:56.834
answer questions together?
[chuckles]

00:37:56.834 --> 00:37:58.801
man:...mike?

00:37:58.801 --> 00:38:00.934
Spoon: Oh, uh...yeah.

00:38:00.934 --> 00:38:02.701
They'd like you to go
to the mikes

00:38:02.701 --> 00:38:05.567
because this is all taped
and, uh...

00:38:05.567 --> 00:38:08.000
man: Okay. What happens
if you're...

00:38:08.000 --> 00:38:12.434
you call the runAsync
from one point in your code--

00:38:12.434 --> 00:38:13.901
like you load the code

00:38:13.901 --> 00:38:15.801
and you wanna go get
something else right away

00:38:15.801 --> 00:38:17.667
while the user's staring
at your initial page.

00:38:17.667 --> 00:38:19.234
Spoon: Sure.

00:38:19.234 --> 00:38:21.334
man: And then the user's quick,
clicks the button.

00:38:21.334 --> 00:38:23.000
You call runAsync again.

00:38:23.000 --> 00:38:27.434
Is it smart enough to know that
the first one's been called?

00:38:27.434 --> 00:38:30.501
Or was it gonna go
try to get it two times?

00:38:30.501 --> 00:38:34.534
Spoon: Oh...the implementation
won't download it twice.

00:38:34.534 --> 00:38:37.934
But that is a tricky situation
for your app to deal with.

00:38:37.934 --> 00:38:41.300
So in fact, one of the things
that people do

00:38:41.300 --> 00:38:42.968
with these gateway classes--

00:38:42.968 --> 00:38:45.467
like a common name for them
is an asynchronous provider--

00:38:45.467 --> 00:38:47.868
is they'll track the fact...

00:38:47.868 --> 00:38:49.601
they'll track
outstanding requests

00:38:49.601 --> 00:38:51.767
and then be able
to do something smart.

00:38:51.767 --> 00:38:54.834
If you get a request
to the same thing twice.

00:38:54.834 --> 00:38:57.434
The system doesn't help you
program around that,

00:38:57.434 --> 00:39:00.200
but...if you do nothing,
what'll happen is

00:39:00.200 --> 00:39:02.133
the code'll load one time,

00:39:02.133 --> 00:39:04.100
and then it'll run
your callback--

00:39:04.100 --> 00:39:07.033
both instances
of the callback you passed in.

00:39:07.033 --> 00:39:10.801
But you might want to code
your app carefully to...

00:39:10.801 --> 00:39:12.234
to deal with that.

00:39:12.234 --> 00:39:14.601
Johnson: You wouldn't get
redundant requests

00:39:14.601 --> 00:39:16.501
for the same fragment, though,
to be clear.

00:39:16.501 --> 00:39:20.367
man: Okay.
Johnson: Yeah.

00:39:20.367 --> 00:39:22.300
man: Hi. Thanks, great talk.

00:39:22.300 --> 00:39:26.467
So far, you've shown how
the, uh, the GWT Toolkit,

00:39:26.467 --> 00:39:32.567
it optimizes the Java
in really tight JavaScript code.

00:39:32.567 --> 00:39:35.133
And using the code splitting,
you can, you know,

00:39:35.133 --> 00:39:37.467
not download more
JavaScript code than you need.

00:39:37.467 --> 00:39:39.467
But I've also heard
numerous mentions

00:39:39.467 --> 00:39:42.567
that it also packages

00:39:42.567 --> 00:39:46.200
and processes
the style sheet code, CSS code,

00:39:46.200 --> 00:39:48.267
and any other includes
that you put in there.

00:39:48.267 --> 00:39:49.601
So one question I had is

00:39:49.601 --> 00:39:51.534
what happens if you have,
say, a style sheet

00:39:51.534 --> 00:39:54.934
that is, uh...you're using
sort of a cross-project

00:39:54.934 --> 00:39:56.834
because it's got
all the different styles

00:39:56.834 --> 00:39:58.767
on objects you want,

00:39:58.767 --> 00:40:00.868
but you don't need it
for the page that's loading.

00:40:00.868 --> 00:40:05.100
Does the GWT understand that
and not load all that code?

00:40:05.100 --> 00:40:07.467
Spoon: Do we have dead--
It's not very good at it.

00:40:07.467 --> 00:40:09.133
Does it at least do
dead code removing?

00:40:09.133 --> 00:40:10.534
Johnson: Yeah,
so if you noticed--

00:40:10.534 --> 00:40:12.801
Did you see the client bundle
stuff yesterday?

00:40:12.801 --> 00:40:14.367
man: Yeah.
Johnson: Yeah. So...

00:40:14.367 --> 00:40:17.767
that pattern of
resource bundling...

00:40:17.767 --> 00:40:19.334
it's based on
you call a method

00:40:19.334 --> 00:40:21.367
in order to get the resource.

00:40:21.367 --> 00:40:23.601
And so...you know what I mean?
man: Yeah, yeah.

00:40:23.601 --> 00:40:24.968
Johnson: You call a method,

00:40:24.968 --> 00:40:27.300
and it returns
a text resource, okay?

00:40:27.300 --> 00:40:30.300
So one of the benefits
of that approach,

00:40:30.300 --> 00:40:32.367
aside from just simplicity,

00:40:32.367 --> 00:40:36.033
is that you can use normal
compiler control flow,

00:40:36.033 --> 00:40:40.200
dead code elimination-type
analysis to decide...

00:40:40.200 --> 00:40:43.200
whether a given method
is called at all.

00:40:43.200 --> 00:40:46.501
And so take code splitting out
of the equation for a second.

00:40:46.501 --> 00:40:49.667
If you don't call
a particular method

00:40:49.667 --> 00:40:52.133
that would return
text resource,

00:40:52.133 --> 00:40:55.868
that text resource need not
be bundled in, first of all.

00:40:55.868 --> 00:40:58.467
So code splitting--
I mean, sorry.

00:40:58.467 --> 00:41:00.267
But resource bundling
in general

00:41:00.267 --> 00:41:02.868
can work well
with dead code elimination.

00:41:02.868 --> 00:41:04.834
That's code splitting aside.

00:41:04.834 --> 00:41:07.734
When you bring code splitting
into it,

00:41:07.734 --> 00:41:09.767
it gets really exciting
because,

00:41:09.767 --> 00:41:11.868
as Lex pointed out
in one of the slides,

00:41:11.868 --> 00:41:13.567
code splitting can work
even at the level

00:41:13.567 --> 00:41:16.234
of individual methods
on the same class.

00:41:16.234 --> 00:41:20.200
So if you've got one
uber-client bundle

00:41:20.200 --> 00:41:22.300
that's got a whole bunch
of different methods,

00:41:22.300 --> 00:41:23.868
it is possible, in theory--

00:41:23.868 --> 00:41:25.400
I'm not sure if it does this
in practice--

00:41:25.400 --> 00:41:27.367
Spoon: I'm not sure
how the bundling works.

00:41:27.367 --> 00:41:28.934
Johnson: Yeah.
Spoon: Strings is great.

00:41:28.934 --> 00:41:30.968
Johnson: Yeah, to be able
to split

00:41:30.968 --> 00:41:33.033
some of those methods
into the start-up fragments,

00:41:33.033 --> 00:41:34.834
some of those other methods
into--

00:41:34.834 --> 00:41:36.868
man: And the same with
style sheet information?

00:41:36.868 --> 00:41:39.934
Johnson: Right.
So it works generally for...

00:41:39.934 --> 00:41:43.934
But it's based
on the interaction

00:41:43.934 --> 00:41:47.434
between the client bundle
code generator and runAsync.

00:41:47.434 --> 00:41:49.901
It's possible that in
its current state

00:41:49.901 --> 00:41:53.467
we haven't fiddled with exactly
the way it generates code

00:41:53.467 --> 00:41:56.267
to perfect that yet,
but it is possible.

00:41:56.267 --> 00:41:57.667
So if the co-generator

00:41:57.667 --> 00:42:01.000
generates a different field
per method that gets called

00:42:01.000 --> 00:42:02.734
and each of those
are independent,

00:42:02.734 --> 00:42:04.467
fields can be split
across fragments.

00:42:04.467 --> 00:42:05.667
man: Interesting.

00:42:05.667 --> 00:42:07.200
Johnson: And so you can
automatically

00:42:07.200 --> 00:42:09.400
distribute the resources
across the fragment.

00:42:09.400 --> 00:42:11.100
man: And will the debug app
that you showed--

00:42:11.100 --> 00:42:12.701
I can't remember
the name of it now--

00:42:12.701 --> 00:42:14.367
for saying where the compiler

00:42:14.367 --> 00:42:17.634
thought the code needed to be
optimized and whatnot,

00:42:17.634 --> 00:42:19.701
does it do the same
for other things

00:42:19.701 --> 00:42:22.234
besides the JavaScript classes?

00:42:22.234 --> 00:42:24.167
Spoon: Yeah. Is that
sample on here, Bruce?

00:42:24.167 --> 00:42:26.167
Johnson: I'm sorry,
were you talking about

00:42:26.167 --> 00:42:27.634
the Story of Your Compile?

00:42:27.634 --> 00:42:29.200
man: Yeah, Story of Your
Compile, right.

00:42:29.200 --> 00:42:30.701
Johnson: Yeah, that one
definitely is there.

00:42:30.701 --> 00:42:32.300
man: SOYC.

00:42:32.300 --> 00:42:34.534
Spoon: So the code splitter
works really well with strings,

00:42:34.534 --> 00:42:37.033
but it can only work on
actual Java code.

00:42:37.033 --> 00:42:38.467
man: Okay.
Spoon: So...

00:42:38.467 --> 00:42:39.667
it depends on the particular
generator.

00:42:39.667 --> 00:42:43.200
The translation one
works really well

00:42:43.200 --> 00:42:45.267
because each message
that you translate

00:42:45.267 --> 00:42:46.667
ends up as an individual
string letter.

00:42:46.667 --> 00:42:48.567
So in your initial download

00:42:48.567 --> 00:42:50.200
you'll get the ones
you need initially,

00:42:50.200 --> 00:42:52.300
and then when you load
the CompositionView,

00:42:52.300 --> 00:42:58.334
you'll get all the tool tips
for the CompositionView later.

00:42:58.334 --> 00:43:02.501
Johnson: Unless the incredibly
polished aesthetics of this

00:43:02.501 --> 00:43:06.033
fool you,
this is still very early.

00:43:06.033 --> 00:43:10.067
But what we hope to do
is provide better visibility

00:43:10.067 --> 00:43:12.334
for each of the code
generators as well.

00:43:12.334 --> 00:43:15.467
So you'd be able to attribute

00:43:15.467 --> 00:43:18.067
this amount of code
to the RPC code generator,

00:43:18.067 --> 00:43:20.400
this amount of code
to the client bundle generator.

00:43:20.400 --> 00:43:23.634
We'd like to provide drill-downs
for all the different mechanisms

00:43:23.634 --> 00:43:26.767
and also make that
a generally sensible mechanism

00:43:26.767 --> 00:43:28.200
so if you write your own
code generators,

00:43:28.200 --> 00:43:30.167
it can participate
in the same way.

00:43:30.167 --> 00:43:31.667
But it's, you know,
we're sort of

00:43:31.667 --> 00:43:34.467
still at the beginning of this,
and that's the vision for it.

00:43:34.467 --> 00:43:35.534
man: thank you.

00:43:37.567 --> 00:43:39.334
man: Hi.
Spoon: Hey.

00:43:39.334 --> 00:43:41.701
man: Uh, could you share
any thoughts about

00:43:41.701 --> 00:43:43.934
the prospects for precompiled

00:43:43.934 --> 00:43:49.167
sharable or shared libraries
in GWT?

00:43:49.167 --> 00:43:52.701
Spoon: Yeah, so...

00:43:52.701 --> 00:43:54.634
I just wanted to share something
real quick

00:43:54.634 --> 00:43:56.334
is that if you click on--
it does list--

00:43:56.334 --> 00:43:57.634
show you
the individual strings

00:43:57.634 --> 00:43:59.200
that you're downloading
at different points.

00:43:59.200 --> 00:44:02.334
But...

00:44:02.334 --> 00:44:04.000
philosophically,

00:44:04.000 --> 00:44:06.300
when you're providing
a web server,

00:44:06.300 --> 00:44:09.067
your users are all gonna
funnel through a website anyway.

00:44:09.067 --> 00:44:10.634
And it seems like
you might as well

00:44:10.634 --> 00:44:13.667
inset a compilation step,
at least at the funnel point.

00:44:13.667 --> 00:44:18.234
So for most of the time,
you're really better off

00:44:18.234 --> 00:44:21.868
if you can figure out a way
to arrange your application

00:44:21.868 --> 00:44:24.267
so that there's a place
where all the code gathers

00:44:24.267 --> 00:44:27.567
and you can run a cross app
compile right there.

00:44:27.567 --> 00:44:29.734
So that's by far
where GWT focuses

00:44:29.734 --> 00:44:33.834
is you can write modules
for programmer consumption,

00:44:33.834 --> 00:44:35.801
but then when you do
your real compile,

00:44:35.801 --> 00:44:37.234
you put 'em all together.

00:44:37.234 --> 00:44:40.167
Now, it is possible
to arrange to have

00:44:40.167 --> 00:44:43.033
run-time linkups
of various kinds.

00:44:43.033 --> 00:44:45.067
You have to use--

00:44:45.067 --> 00:44:48.033
you have to make a bridge
through JavaScript yourself,

00:44:48.033 --> 00:44:49.367
but it does work.

00:44:49.367 --> 00:44:52.000
But as an example,
you can compile a Google Gadget

00:44:52.000 --> 00:44:54.801
for people who've looked
on iGoogle or things like that.

00:44:54.801 --> 00:44:57.567
You can provide a gadget
with a GWT App,

00:44:57.567 --> 00:45:00.901
and you could even write
a gadget host as a GWT App.

00:45:00.901 --> 00:45:05.033
And that's gonna require
that you do a run-time linkup.

00:45:05.033 --> 00:45:07.267
Johnson: I mean, in terms
of our own roadmap,

00:45:07.267 --> 00:45:09.100
we really aren't very bullish

00:45:09.100 --> 00:45:11.434
about the idea of
precompiled libraries.

00:45:11.434 --> 00:45:13.667
Because soon as you do that,

00:45:13.667 --> 00:45:15.634
you basically
prevent the opportunity

00:45:15.634 --> 00:45:17.634
to do dead code elimination,
for example,

00:45:17.634 --> 00:45:19.501
'cause that's something
the compiler would do.

00:45:19.501 --> 00:45:21.000
So in other words, you know,

00:45:21.000 --> 00:45:22.801
you saw, in fact,
from the Story of Your Compile

00:45:22.801 --> 00:45:26.534
that just the java.util classes

00:45:26.534 --> 00:45:30.901
were the single largest part
of this particular application.

00:45:30.901 --> 00:45:33.667
That's with dead code
elimination already happening.

00:45:33.667 --> 00:45:36.334
So if we don't call
arraylist.remove,

00:45:36.334 --> 00:45:39.501
the code for that
doesn't get pulled in, right?

00:45:39.501 --> 00:45:41.467
And it's still
the biggest chunk.

00:45:41.467 --> 00:45:45.367
Imagine we cross-compiled
everything in java.util, right?

00:45:45.367 --> 00:45:47.167
That's a lot of code.

00:45:47.167 --> 00:45:48.767
And it would be
really unfortunate

00:45:48.767 --> 00:45:50.667
to download that
to the client

00:45:50.667 --> 00:45:53.767
when, in fact, you're only using
a small subset of it.

00:45:53.767 --> 00:45:55.801
So I'm not saying never,

00:45:55.801 --> 00:45:57.767
but we think
that this approach,

00:45:57.767 --> 00:46:00.434
doing lots of optimization
at compile time

00:46:00.434 --> 00:46:01.968
and using code splitting,

00:46:01.968 --> 00:46:04.534
is going to be ultimately
more fruitful.

00:46:04.534 --> 00:46:06.400
man: yeah,
I guess it depends on,

00:46:06.400 --> 00:46:07.934
you know, how many
applications you have

00:46:07.934 --> 00:46:10.100
and how big they are,
right?

00:46:10.100 --> 00:46:11.334
Johnson: Yeah, that's true.

00:46:11.334 --> 00:46:14.667
There's also, though,
the sort of...

00:46:14.667 --> 00:46:17.767
we don't want to create
the web version of DLL hell.

00:46:17.767 --> 00:46:20.200
I think we've all, or many
of us have been there too.

00:46:20.200 --> 00:46:22.133
And that's a really
dangerous thing to--

00:46:22.133 --> 00:46:24.300
so we're
trying to avoid that.

00:46:26.934 --> 00:46:30.067
man: My question, I'm using,
let's say, third-party library.

00:46:30.067 --> 00:46:34.067
Sometimes now it's pretty huge
and takes a lot of time.

00:46:34.067 --> 00:46:37.033
I'm using probably
10% of this library.

00:46:37.033 --> 00:46:40.200
How in the future are those
library gonna split,

00:46:40.200 --> 00:46:43.667
even libraries that guys
from Google are writing?

00:46:43.667 --> 00:46:48.267
And I suppose they optimize it
for split or...

00:46:48.267 --> 00:46:52.167
how I can deal with this...
as a developer?

00:46:52.167 --> 00:46:54.834
Spoon: So far, libraries
usually aren't split up,

00:46:54.834 --> 00:46:56.267
for whatever reason.

00:46:56.267 --> 00:46:58.133
The standard GWT library

00:46:58.133 --> 00:47:00.734
doesn't have a single call
to runAsync internally.

00:47:00.734 --> 00:47:02.300
man: No.
Spoon: It just happens.

00:47:02.300 --> 00:47:04.634
So usually--so far what
people have done

00:47:04.634 --> 00:47:08.634
is split off...components
at the application level.

00:47:08.634 --> 00:47:12.000
Things like...
like for the showcase demo,

00:47:12.000 --> 00:47:15.267
there's a separate runAsync

00:47:15.267 --> 00:47:17.534
called for each page
of the demo.

00:47:17.534 --> 00:47:20.000
And for Google Wave,
there's a separate split out

00:47:20.000 --> 00:47:21.934
for the Wave editor,
you know,

00:47:21.934 --> 00:47:23.801
so their application level
of chunks

00:47:23.801 --> 00:47:25.634
are being split out so far.

00:47:25.634 --> 00:47:27.567
But in the future,
I don't know.

00:47:27.567 --> 00:47:30.667
Johnson: To clarify too,
there is a difference--

00:47:30.667 --> 00:47:32.834
Lex was saying there's not
a gwt.runAsync call

00:47:32.834 --> 00:47:34.567
within our libraries.

00:47:34.567 --> 00:47:37.033
But that doesn't mean
that your runAsync calls

00:47:37.033 --> 00:47:41.267
won't be able to split apart
your usage of our libraries,

00:47:41.267 --> 00:47:42.567
of the GWT libraries.

00:47:42.567 --> 00:47:44.501
man: It's up to me
to split kind of in...

00:47:44.501 --> 00:47:46.100
Johnson: Right.
But we feel like

00:47:46.100 --> 00:47:48.267
because the decision
about where to split

00:47:48.267 --> 00:47:51.701
is completely tied in
with the user experience,

00:47:51.701 --> 00:47:53.767
we should generally provide

00:47:53.767 --> 00:47:55.634
just a traditional code base,

00:47:55.634 --> 00:47:57.000
and you should make
the splitting decisions

00:47:57.000 --> 00:47:58.334
and then the compiler will--

00:47:58.334 --> 00:47:59.767
man: I'm talking about
simple stuff.

00:47:59.767 --> 00:48:02.834
Let's say I'm using Table
or I'm using Tree.

00:48:02.834 --> 00:48:05.367
Tree has a bunch
of related classes

00:48:05.367 --> 00:48:07.834
that's supposed to come
together.

00:48:07.834 --> 00:48:09.501
That's natural packaging.

00:48:09.501 --> 00:48:12.100
But because
it's a huge library

00:48:12.100 --> 00:48:14.767
they have Tree,
they have, uh, GRE.

00:48:14.767 --> 00:48:16.734
They have all this stuff.

00:48:16.734 --> 00:48:19.200
So I need to split,

00:48:19.200 --> 00:48:23.200
because I know the Tree coming
all those classes together--

00:48:23.200 --> 00:48:24.501
Obvious.
Johnson: Right.

00:48:24.501 --> 00:48:26.000
man: Yes, so...
Johnson: Yeah, that's, I mean,

00:48:26.000 --> 00:48:27.567
basically code splitting
will help.

00:48:27.567 --> 00:48:29.534
man: And I still need
to do this by myself, yes?

00:48:29.534 --> 00:48:32.734
Johnson: Until we can find
a way to help you more.

00:48:32.734 --> 00:48:35.100
We will be thinking of ways.
man: Yes. Please find.

00:48:35.100 --> 00:48:36.801
Johnson: Well, you have
to try it first,

00:48:36.801 --> 00:48:39.501
then you have to complain.

00:48:39.501 --> 00:48:44.133
man: Hi. Um...I have a question
about the...like the failure.

00:48:44.133 --> 00:48:45.501
Like in all the examples

00:48:45.501 --> 00:48:48.100
that you guys have been showing
yesterday and today,

00:48:48.100 --> 00:48:50.200
basically what you seem
to be showing

00:48:50.200 --> 00:48:51.901
is like
when it says onFailure,

00:48:51.901 --> 00:48:53.701
you just make a little
alert to the user,

00:48:53.701 --> 00:48:56.868
which I think we can all agree
is not really realistic

00:48:56.868 --> 00:48:59.501
for a running application.

00:48:59.501 --> 00:49:01.133
So I'm wondering
if there's any like

00:49:01.133 --> 00:49:02.868
paradigms you guys
have thought of

00:49:02.868 --> 00:49:04.200
for dealing with that.

00:49:04.200 --> 00:49:06.133
'Cause the way that we
write code now,

00:49:06.133 --> 00:49:08.934
you assume that you have
all the code,

00:49:08.934 --> 00:49:11.067
and this is changing that.

00:49:11.067 --> 00:49:14.334
I'm wondering what
you guys are doing about that.

00:49:14.334 --> 00:49:17.000
Johnson: Ray, are you here?
In the audience?

00:49:17.000 --> 00:49:18.634
Ray Ryan?

00:49:18.634 --> 00:49:23.968
So Ray Ryan worked on the new
AdWords rewrite with G-W-T,

00:49:23.968 --> 00:49:27.367
and that's something they
definitely have to think about.

00:49:27.367 --> 00:49:29.601
What tends to happen
in large applications

00:49:29.601 --> 00:49:34.567
is that there's a centralized
error reporting mechanism.

00:49:34.567 --> 00:49:37.167
So, you know, we showed
window.alert

00:49:37.167 --> 00:49:38.667
just to be succinct,
obviously,

00:49:38.667 --> 00:49:41.434
but really, what that would
probably look like is,

00:49:41.434 --> 00:49:45.267
you know, call the global
app instance onError event.

00:49:45.267 --> 00:49:47.701
Or maybe there's
some specialized

00:49:47.701 --> 00:49:50.067
you know,
method that specifies

00:49:50.067 --> 00:49:52.167
exactly the error id
or something.

00:49:52.167 --> 00:49:53.934
But typically,
it would funnel to

00:49:53.934 --> 00:49:56.901
one consolidated ErrorHandler
that would show some UI

00:49:56.901 --> 00:49:59.400
to indicate something
to the user.

00:49:59.400 --> 00:50:01.934
man: And what causes
the failure?

00:50:01.934 --> 00:50:03.801
It's like if the file
doesn't load,

00:50:03.801 --> 00:50:05.567
it's like a network error?

00:50:05.567 --> 00:50:07.167
Johnson: Right.
Like a network error.

00:50:07.167 --> 00:50:09.033
There wouldn't be
spurious errors

00:50:09.033 --> 00:50:11.200
due to the compiler
making a mistake

00:50:11.200 --> 00:50:12.534
or something like that.
man: No, never.

00:50:12.534 --> 00:50:13.834
Johnson: Right. Like that's--

00:50:13.834 --> 00:50:16.467
code splitting wouldn't work
at all reliably

00:50:16.467 --> 00:50:18.200
if the compiler
could screw that up.

00:50:18.200 --> 00:50:19.767
Spoon:
But it's perfectly normal

00:50:19.767 --> 00:50:22.567
that you open your email reader
at the airport.

00:50:22.567 --> 00:50:24.200
and then you walk
down the aisle,

00:50:24.200 --> 00:50:27.534
and you reopen your laptop
at the same page,

00:50:27.534 --> 00:50:29.567
and you're not on
the network anymore.

00:50:29.567 --> 00:50:32.501
Johnson: So it's really
transient network failures.

00:50:32.501 --> 00:50:35.501
The server, you know,
crashed for a minute,

00:50:35.501 --> 00:50:37.767
but it comes back up 'cause
it's a cluster or something.

00:50:37.767 --> 00:50:39.434
man: Yeah. I guess
I was just wondering

00:50:39.434 --> 00:50:41.234
if there's any sort of
like general paradigm

00:50:41.234 --> 00:50:44.234
of like try again,
you know what I'm saying?

00:50:44.234 --> 00:50:46.334
Johnson: Yeah, have you
been thinking about that,

00:50:46.334 --> 00:50:47.901
like having--
Spoon: I have.

00:50:47.901 --> 00:50:49.567
Most apps I look at
don't do a very good job

00:50:49.567 --> 00:50:51.133
if they lose network access.

00:50:51.133 --> 00:50:52.767
This is aside
from code splitting.

00:50:52.767 --> 00:50:54.701
If the server's not there,

00:50:54.701 --> 00:50:56.734
they tend to give you
bad behavior.

00:50:56.734 --> 00:50:58.334
Good stuff I've seen, though,

00:50:58.334 --> 00:51:00.801
is they pop up a loading dialog
when they're trying.

00:51:00.801 --> 00:51:02.434
Good ones will actually
remove that,

00:51:02.434 --> 00:51:04.801
once they realize
it's not gonna work.

00:51:04.801 --> 00:51:06.834
a lot of them leave it running.
man: Gmail.

00:51:06.834 --> 00:51:10.033
Spoon: Some cool apps will show

00:51:10.033 --> 00:51:11.934
whether they think the network
is there or not,

00:51:11.934 --> 00:51:14.267
so if a download fails,
they'll toggle it off,

00:51:14.267 --> 00:51:16.667
and you can click on it again
to basically indicate,

00:51:16.667 --> 00:51:18.801
okay, I think I've got
a network now.

00:51:18.801 --> 00:51:21.033
But it's all very speculative.

00:51:21.033 --> 00:51:22.501
Johnson: One thing I've actually
heard just, I don't know,

00:51:22.501 --> 00:51:24.167
random email
that rides around Google

00:51:24.167 --> 00:51:25.934
is that sometimes you get
spurious failures

00:51:25.934 --> 00:51:29.133
and just a simple retry,
and it will succeed.

00:51:29.133 --> 00:51:31.267
Not with code splitting,
but even RPCs

00:51:31.267 --> 00:51:33.501
or XHR or HTTP requests
in general.

00:51:33.501 --> 00:51:35.767
Sometimes the best thing to do
is just try it twice

00:51:35.767 --> 00:51:37.467
before you declare
a failure,

00:51:37.467 --> 00:51:40.067
and the code fragment loader
could do that.

00:51:40.067 --> 00:51:42.400
I don't know if it does, but...
Spoon: We might want to do that.

00:51:42.400 --> 00:51:44.133
Johnson: You know,
it's a little dicey, though,

00:51:44.133 --> 00:51:48.000
to have your libraries
do too much magic

00:51:48.000 --> 00:51:49.567
without your control.

00:51:49.567 --> 00:51:51.033
So if we can find
the right balance,

00:51:51.033 --> 00:51:52.534
we probably would do that.

00:51:52.534 --> 00:51:55.334
Spoon: We did go so far as
if your app retries,

00:51:55.334 --> 00:51:58.634
the low level support
will retry the network request.

00:51:58.634 --> 00:52:02.167
So if your onFailure retries,
it will actually try again.

00:52:02.167 --> 00:52:03.934
Johnson: It's really exactly
the same issue

00:52:03.934 --> 00:52:05.501
when we talk about RPC,

00:52:05.501 --> 00:52:07.367
'cause RPCs can fail
in exactly the same way.

00:52:07.367 --> 00:52:10.501
So if your app is one designed
so that retry makes sense,

00:52:10.501 --> 00:52:12.367
then...there you go.

00:52:12.367 --> 00:52:13.801
man: Thanks.

00:52:13.801 --> 00:52:16.634
Johnson: Yeah, this is a very
low-level, primitive thing.

00:52:16.634 --> 00:52:19.501
It's intended to be the absolute
kernel of functionality,

00:52:19.501 --> 00:52:21.400
and then you'll build,
you know,

00:52:21.400 --> 00:52:24.400
patterns and frameworks
on top of it.

00:52:24.400 --> 00:52:28.133
man: Yeah, so during the demo
you showed

00:52:28.133 --> 00:52:30.868
using the dependency
injection pattern.

00:52:30.868 --> 00:52:33.000
And that's a wonderful pattern.

00:52:33.000 --> 00:52:35.033
We use it on
the server side a lot.

00:52:35.033 --> 00:52:38.133
But we haven't been able
to use it on the GWT side

00:52:38.133 --> 00:52:40.934
because there didn't seem
to be a good library for it,

00:52:40.934 --> 00:52:43.501
or at least, I mean,
I haven't looked too hard.

00:52:43.501 --> 00:52:46.467
But is there any projects
out there that you know about?

00:52:46.467 --> 00:52:49.234
Johnson: Yeah, come
to Ray Ryan's talk called

00:52:49.234 --> 00:52:51.467
Architecture: Best Practices.

00:52:51.467 --> 00:52:52.634
There is such a library.

00:52:52.634 --> 00:52:53.968
It's based on Guice,

00:52:53.968 --> 00:52:56.033
which is Google's
dependency injection.

00:52:56.033 --> 00:52:57.467
It's called Gin.

00:52:57.467 --> 00:52:59.400
So Gin and Guice
are quite the pair.

00:52:59.400 --> 00:53:02.067
And Ray's gonna talk through
how you can use that

00:53:02.067 --> 00:53:04.167
to build the kind of app
you're talking about

00:53:04.167 --> 00:53:05.167
on the client.

00:53:05.167 --> 00:53:06.501
man: Okay, excellent.

00:53:06.501 --> 00:53:09.100
man: Uh, well, that was
exactly my question.

00:53:09.100 --> 00:53:12.367
We use Gin in 1.5
and Suko in 1.6,

00:53:12.367 --> 00:53:13.801
and I was just wondering
if there was

00:53:13.801 --> 00:53:18.501
a more general API?

00:53:18.501 --> 00:53:20.534
Johnson: Gin is the one,
it looks like the one

00:53:20.534 --> 00:53:22.901
that everybody
seems to be liking a lot, so...

00:53:22.901 --> 00:53:24.968
man: Thanks.
Johnson: Yeah.

00:53:24.968 --> 00:53:28.000
man: Hi. It strikes me
that the process

00:53:28.000 --> 00:53:32.667
of getting your--
what would you call it--

00:53:32.667 --> 00:53:36.100
your sections done
is an iterative process

00:53:36.100 --> 00:53:38.100
where you compile your app,

00:53:38.100 --> 00:53:40.501
you inspect the decisions
that were made

00:53:40.501 --> 00:53:41.767
with Story of Your Compile,

00:53:41.767 --> 00:53:43.467
and then you break the
dependencies where you can

00:53:43.467 --> 00:53:45.934
and then you try it again.

00:53:45.934 --> 00:53:47.634
And the first thought
that comes to my mind

00:53:47.634 --> 00:53:49.534
when I see
Story of Your Compile is,

00:53:49.534 --> 00:53:51.267
since this is
an iterative process

00:53:51.267 --> 00:53:53.033
and the issues are sort of--

00:53:53.033 --> 00:53:55.067
like with hosted mode
versus web mode,

00:53:55.067 --> 00:53:56.968
what effect does
Story of Your Compile

00:53:56.968 --> 00:53:58.467
have on compile time?

00:53:58.467 --> 00:54:00.133
'Cause it's
an iterative process.

00:54:00.133 --> 00:54:02.801
It seems that's important.

00:54:02.801 --> 00:54:04.734
Spoon: I didn't quite--
clearly understand.

00:54:04.734 --> 00:54:06.234
It is a compile time tool,
actually.

00:54:06.234 --> 00:54:07.300
man: Yeah.
Spoon: So, um...

00:54:07.300 --> 00:54:08.567
man: But the point is

00:54:08.567 --> 00:54:10.801
it's generating
a lot of data, right?

00:54:10.801 --> 00:54:12.734
How does it affect
my compile time

00:54:12.734 --> 00:54:14.434
when I turn on
Story of Your Compile?

00:54:14.434 --> 00:54:16.267
Spoon: Ah, well...[laughs]

00:54:16.267 --> 00:54:19.234
Katherine is laughing
in the back row, I see.

00:54:19.234 --> 00:54:21.534
Johnson: Some folks who--
Spoon: It increases--

00:54:21.534 --> 00:54:23.634
it increases the compile time.

00:54:23.634 --> 00:54:26.434
And we try to keep the increase
as small as possible

00:54:26.434 --> 00:54:27.834
and on different days.

00:54:27.834 --> 00:54:29.834
But then we wanted
to output more information,

00:54:29.834 --> 00:54:31.501
and it gets worse again.

00:54:31.501 --> 00:54:33.167
So...it is optional right now.

00:54:33.167 --> 00:54:35.400
If you want the fastest compile,
you disable it.

00:54:35.400 --> 00:54:36.767
man: I see.

00:54:36.767 --> 00:54:39.100
Johnson: Yeah, we would
love to make that fast,

00:54:39.100 --> 00:54:40.667
as fast as we can.

00:54:40.667 --> 00:54:43.734
And, you know, there's now
the Google plugin for Eclipse,

00:54:43.734 --> 00:54:45.834
and it does sort of
incremental, you know,

00:54:45.834 --> 00:54:48.834
ongoing compiles as you make
source code changes.

00:54:48.834 --> 00:54:50.567
Maybe possibly
in the future one day,

00:54:50.567 --> 00:54:53.167
we can kind of build that
Story of Your Compile--

00:54:53.167 --> 00:54:56.501
man: Or maybe consider having
an analysis mode, compile mode

00:54:56.501 --> 00:54:58.968
where you don't actually
generate a code

00:54:58.968 --> 00:55:01.567
but you just do
the dependence analysis

00:55:01.567 --> 00:55:02.834
and write that out.

00:55:02.834 --> 00:55:04.367
Johnson: Right.
Basically more control

00:55:04.367 --> 00:55:06.501
over how much stuff
you track in.

00:55:06.501 --> 00:55:08.234
That's a good point.
Spoon: That's a good idea.

00:55:08.234 --> 00:55:09.801
Johnson: I think I really
see the gist

00:55:09.801 --> 00:55:11.100
of your question
and point now

00:55:11.100 --> 00:55:12.868
which is you don't always want
all the data

00:55:12.868 --> 00:55:15.868
for different types
of use cases of using it.

00:55:15.868 --> 00:55:17.200
I gotcha.

00:55:17.200 --> 00:55:18.667
man: Do you have any suggestions

00:55:18.667 --> 00:55:22.267
on how to get your code splits
to preload in the background?

00:55:25.200 --> 00:55:26.567
Spoon:
Well, you do wanna do it,

00:55:26.567 --> 00:55:28.601
and it doesn't do it
automatically, so...

00:55:28.601 --> 00:55:30.167
[laughter]

00:55:30.167 --> 00:55:31.868
A common trend with GWT

00:55:31.868 --> 00:55:33.868
is that we provide
a very low-level tool,

00:55:33.868 --> 00:55:36.100
and then we try to figure out
the best practices

00:55:36.100 --> 00:55:37.400
and then we import them back.

00:55:37.400 --> 00:55:38.701
Is that fair to say?

00:55:38.701 --> 00:55:40.000
As we figure out
what they are.

00:55:40.000 --> 00:55:43.868
Right now,
what you can do to...

00:55:43.868 --> 00:55:45.801
if you use
the async package pattern,

00:55:45.801 --> 00:55:48.234
what you can do is have
some part in your code

00:55:48.234 --> 00:55:51.234
that just does
a chain of these calls

00:55:51.234 --> 00:55:53.367
in the order
you'd like to preload them.

00:55:53.367 --> 00:55:55.601
So it's a little bit
verbose to do that,

00:55:55.601 --> 00:55:57.434
but that's a pretty
effective way

00:55:57.434 --> 00:55:59.334
that you preload
one at a time.

00:55:59.334 --> 00:56:01.968
And you can even have
these preloaders check

00:56:01.968 --> 00:56:06.868
if your app has
any indication of...

00:56:06.868 --> 00:56:08.901
there's something the user
is actually doing,

00:56:08.901 --> 00:56:11.601
then you can even like
not do the preload yet

00:56:11.601 --> 00:56:14.167
until the app quiesces.

00:56:14.167 --> 00:56:16.634
Johnson: Like you could set--
you could set a timer

00:56:16.634 --> 00:56:18.300
and then cancel the timer

00:56:18.300 --> 00:56:20.033
if there's any interaction
with the app.

00:56:20.033 --> 00:56:21.634
Spoon: That kinda thing, yeah.

00:56:21.634 --> 00:56:23.968
Johnson: 'Cause you wouldn't
want an RPC to be usurped

00:56:23.968 --> 00:56:27.901
by a pre-fetch
of a code fragment.

00:56:27.901 --> 00:56:29.601
And that's why
we don't do it automatically,

00:56:29.601 --> 00:56:32.100
even though it's kind of obvious
that you might want to.

00:56:32.100 --> 00:56:34.400
But the network connection's
so precious,

00:56:34.400 --> 00:56:36.634
you might have like
real-time RPCs

00:56:36.634 --> 00:56:38.534
that need to happen
in response to user action.

00:56:38.534 --> 00:56:41.133
You don't wanna do that--

00:56:41.133 --> 00:56:43.934
you don't wanna usurp that by
loading code in the background.

00:56:43.934 --> 00:56:46.067
Spoon: Especially if you
think about mobile devices.

00:56:46.067 --> 00:56:48.367
If you start downloading code,
the network is swamped.

00:56:48.367 --> 00:56:51.067
Johnson: Right. So it's really
easy to saturate the connection

00:56:51.067 --> 00:56:52.934
with stuff that
you might not even use.

00:56:52.934 --> 00:56:54.200
man: No, I see where
you're coming from.

00:56:54.200 --> 00:56:55.667
I'm just thinking like
from a user perspective

00:56:55.667 --> 00:56:57.667
if they know they're gonna
walk away, to use your example,

00:56:57.667 --> 00:56:59.634
from where they have
connectivity,

00:56:59.634 --> 00:57:01.534
they might want to,
you know, click a button

00:57:01.534 --> 00:57:03.000
that says
let me go offline with this.

00:57:03.000 --> 00:57:04.501
Johnson:
Actually, I think the way

00:57:04.501 --> 00:57:07.567
we might wanna solve that
is through the HTML5 AppCache.

00:57:07.567 --> 00:57:11.267
There's already a link--
I think it's in the incubator--

00:57:11.267 --> 00:57:13.934
that can take a GWT module

00:57:13.934 --> 00:57:17.400
and produce the AppCache
manifest in everything.

00:57:17.400 --> 00:57:19.834
We haven't done this yet
with code splitting in mind,

00:57:19.834 --> 00:57:21.868
but it would be possible
to create such a manifest

00:57:21.868 --> 00:57:23.734
so that you can essentially
download the whole app,

00:57:23.734 --> 00:57:26.734
including its fragments,
to the AppCache locally.

00:57:26.734 --> 00:57:29.434
And then it would just--
it would be a fetch,

00:57:29.434 --> 00:57:30.968
but it would be a fetch
from the local AppCache,

00:57:30.968 --> 00:57:32.200
not over the network.

00:57:32.200 --> 00:57:33.734
That would be really cool.
man: Thanks.

00:57:33.734 --> 00:57:36.267
Johnson: Yeah.

00:57:36.267 --> 00:57:39.267
man: This is somewhat
of a vague question,

00:57:39.267 --> 00:57:40.934
but I'll ask anyway.

00:57:40.934 --> 00:57:43.467
Going back to the point
you were just making

00:57:43.467 --> 00:57:48.000
about sort of...
modulating what you download

00:57:48.000 --> 00:57:50.300
based on user activity

00:57:50.300 --> 00:57:52.501
or potentially
what else is going on

00:57:52.501 --> 00:57:54.934
in the, uh,
in the application.

00:57:54.934 --> 00:57:58.801
What do you see as being
sort of the other type of input

00:57:58.801 --> 00:58:01.667
that you would put into
that decision?

00:58:01.667 --> 00:58:05.133
In other words, we talked--
in discussion about

00:58:05.133 --> 00:58:07.901
two images sort of
blocking up all the connections,

00:58:07.901 --> 00:58:10.601
other activities going on,
some information,

00:58:10.601 --> 00:58:12.934
maybe, you know, I was trying
to render something heavy.

00:58:12.934 --> 00:58:16.801
Do you see that
the G-W-T App itself

00:58:16.801 --> 00:58:20.767
would ever get more information
of what's going on on the page

00:58:20.767 --> 00:58:22.234
or with the browser

00:58:22.234 --> 00:58:24.334
that would help drive
that sort of a thing?

00:58:24.334 --> 00:58:26.300
What kind of things
are going on there?

00:58:26.300 --> 00:58:29.701
I guess that's my question.
Johnson: Right.

00:58:31.567 --> 00:58:34.767
Hardware telepathy interface.
That would be awesome.

00:58:34.767 --> 00:58:36.501
Spoon:
Yeah. Seeing the future.

00:58:36.501 --> 00:58:39.467
I always thought of it
as app input mostly,

00:58:39.467 --> 00:58:41.734
not browser input,
but I'm not sure.

00:58:41.734 --> 00:58:43.701
Johnson: Well, the thing
that's tricky about it to me

00:58:43.701 --> 00:58:46.801
is that sometimes
if nothing is happening,

00:58:46.801 --> 00:58:50.901
it's 'cause the user is deciding
what they're just about to do.

00:58:50.901 --> 00:58:52.901
So just because they haven't
done something for two seconds,

00:58:52.901 --> 00:58:54.634
that might be the indication

00:58:54.634 --> 00:58:56.534
that they are about to do
something,

00:58:56.534 --> 00:58:58.434
not that they're not about
to do something.

00:58:58.434 --> 00:59:01.067
And so I'm not sure what
the right answer is at all.

00:59:01.067 --> 00:59:02.767
Spoon: You know, it would help
if you could tell a browser

00:59:02.767 --> 00:59:04.734
that is a low-priority download.

00:59:04.734 --> 00:59:06.767
Johnson: That would be cool.
Spoon: I don't think you can.

00:59:06.767 --> 00:59:08.634
Johnson: That would be cool.

00:59:08.634 --> 00:59:12.234
Also, you know, the pressure is
being reduced somewhat.

00:59:12.234 --> 00:59:14.434
The newer generation
of browsers

00:59:14.434 --> 00:59:17.133
do allow many more
than two outgoing connections.

00:59:17.133 --> 00:59:22.200
So that will be, you know,
mitigated, I guess, somewhat.

00:59:22.200 --> 00:59:24.067
Well, we are out of time.

00:59:24.067 --> 00:59:27.267
Now, there's one thing
that we need to do here,

00:59:27.267 --> 00:59:30.734
which is to ask you
to fill out the...

00:59:30.734 --> 00:59:32.067
this.

00:59:32.067 --> 00:59:34.467
Provide your feedback and...

00:59:34.467 --> 00:59:36.834
if you have anything to say,
we would really like to know it

00:59:36.834 --> 00:59:39.367
so we can make IO even better
for you next year.

00:59:39.367 --> 00:59:41.400
Thanks very much for coming.
Spoon: Thanks, guys.

00:59:41.400 --> 00:59:43.934
[applause]

