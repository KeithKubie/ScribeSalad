WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.982
[MUSIC PLAYING]

00:00:07.867 --> 00:00:08.950
[? XAVIER DUCOY: ?] Hello.

00:00:08.950 --> 00:00:10.580
Good afternoon.

00:00:10.580 --> 00:00:12.040
My name is Xavier [? Ducoy. ?]

00:00:12.040 --> 00:00:14.380
JEROME DOCHEZ: And my
name is Jerome Dochez.

00:00:14.380 --> 00:00:15.100
[? XAVIER DUCOY: ?]
So today we're

00:00:15.100 --> 00:00:17.020
going to talk about
what's new in the Android

00:00:17.020 --> 00:00:19.690
build system since last year.

00:00:19.690 --> 00:00:21.790
We're going to start
with variant aware

00:00:21.790 --> 00:00:23.300
dependency management.

00:00:23.300 --> 00:00:26.470
So it shipped last year
in 3.0 in the fall.

00:00:26.470 --> 00:00:28.630
And, you know, the
whole concept is

00:00:28.630 --> 00:00:30.550
that all the
variants of a module

00:00:30.550 --> 00:00:32.920
can depend on matching
variant in another model,

00:00:32.920 --> 00:00:35.340
so debug depends on
debug in the library

00:00:35.340 --> 00:00:37.720
and release depends
on release, and it

00:00:37.720 --> 00:00:39.640
works well as long
as you have matching

00:00:39.640 --> 00:00:40.820
variants on both sides.

00:00:40.820 --> 00:00:45.257
But when it doesn't happen,
even though we have a DSL

00:00:45.257 --> 00:00:46.840
to help you fix the
problem, but we've

00:00:46.840 --> 00:00:49.330
seen a lot of developers
over the last six,

00:00:49.330 --> 00:00:52.540
nine months who just
see an error message

00:00:52.540 --> 00:00:54.890
like this and just don't
know what to do with it.

00:00:54.890 --> 00:00:56.650
So we wanted to
take a few minutes

00:00:56.650 --> 00:00:59.230
to explain exactly
what's going on

00:00:59.230 --> 00:01:01.970
and help you solve
such a problem.

00:01:01.970 --> 00:01:03.910
So the first thing to
look at is this line

00:01:03.910 --> 00:01:06.590
that says could not
resolve project library.

00:01:06.590 --> 00:01:09.040
So that's the project that
publishes the artifact

00:01:09.040 --> 00:01:10.792
that you're trying to consume.

00:01:10.792 --> 00:01:12.250
And the project
that's consuming it

00:01:12.250 --> 00:01:15.255
is the one that says
required by project app.

00:01:15.255 --> 00:01:16.630
And in the top
right section, you

00:01:16.630 --> 00:01:19.290
can see it says the name of
the configuration that we

00:01:19.290 --> 00:01:21.940
are trying to resolve, which
is staging runtime class pass.

00:01:21.940 --> 00:01:24.730
And it's always the name
of the variant followed

00:01:24.730 --> 00:01:27.340
by compiler run time,
followed by class pass,

00:01:27.340 --> 00:01:29.140
so here, it's the
runtime class pass.

00:01:29.140 --> 00:01:33.340
And the error is unable to
find a matching configuration.

00:01:33.340 --> 00:01:35.500
And so the way it's
working, really,

00:01:35.500 --> 00:01:37.540
is that the library
project is publishing

00:01:37.540 --> 00:01:40.030
a whole bunch of artifacts
for different variants

00:01:40.030 --> 00:01:42.700
in different configurations,
and each of those configurations

00:01:42.700 --> 00:01:46.840
has attributes associated with
it so that Gradle can match it.

00:01:46.840 --> 00:01:50.110
On the app side, the request
has similar attributes,

00:01:50.110 --> 00:01:51.910
and it's trying to
do a mapping, and it

00:01:51.910 --> 00:01:53.530
needs to find an exact match.

00:01:53.530 --> 00:01:55.510
And here, it can't
find any match.

00:01:55.510 --> 00:01:58.942
So if you go through
those for configuration,

00:01:58.942 --> 00:02:00.400
you can look at
all the attributes,

00:02:00.400 --> 00:02:02.470
and basically, by
process of elimination,

00:02:02.470 --> 00:02:03.825
find out what the problem is.

00:02:03.825 --> 00:02:05.950
So here, the first thing
that we see is two of them

00:02:05.950 --> 00:02:08.259
have an API--

00:02:08.259 --> 00:02:11.710
their API used by
compile class pass--

00:02:11.710 --> 00:02:13.120
and the other two are runtime.

00:02:13.120 --> 00:02:16.020
And you can see that the
attribute name usage, we

00:02:16.020 --> 00:02:18.880
request Java runtime, and some
of them are using Java API,

00:02:18.880 --> 00:02:22.670
so they are not compatible,
so we can just ignore them.

00:02:22.670 --> 00:02:24.282
Then we have a few
more attributes.

00:02:24.282 --> 00:02:25.990
There's one here,
android type attribute,

00:02:25.990 --> 00:02:28.430
that is compatible
on both sides,

00:02:28.430 --> 00:02:29.472
so we can just ignore it.

00:02:29.472 --> 00:02:31.013
It's something that
we use internally

00:02:31.013 --> 00:02:33.070
to match different type
of plug-in application

00:02:33.070 --> 00:02:37.420
versus library versus features,
so you can just ignore it.

00:02:37.420 --> 00:02:39.830
The other one, variant
attribute, is not required.

00:02:39.830 --> 00:02:42.220
It's actually never
required, and you can just

00:02:42.220 --> 00:02:43.360
ignore it always.

00:02:43.360 --> 00:02:46.420
We use that only when
we build the model when

00:02:46.420 --> 00:02:47.650
we do a studio sync.

00:02:47.650 --> 00:02:49.270
So you can always ignore it.

00:02:49.270 --> 00:02:51.200
And then we find
the final attribute,

00:02:51.200 --> 00:02:53.860
which is always incompatible.

00:02:53.860 --> 00:02:57.190
We ask for staging, and it's
finding two other values.

00:02:57.190 --> 00:03:00.370
And the name or type
of the attribute here,

00:03:00.370 --> 00:03:04.630
which is package name.build
type attribute, is the key part.

00:03:04.630 --> 00:03:06.730
It's basically, hopefully,
self-explanatory.

00:03:06.730 --> 00:03:08.580
This is the build
type attribute,

00:03:08.580 --> 00:03:10.987
and we're requesting staging,
and it's not finding it.

00:03:10.987 --> 00:03:12.820
So basically, it means
your library does not

00:03:12.820 --> 00:03:16.690
have the staging build type,
and that's why it's failing.

00:03:16.690 --> 00:03:18.670
So you can't trade it
there, or you can just

00:03:18.670 --> 00:03:21.965
use the DSL that allows
you to create a fallback.

00:03:21.965 --> 00:03:23.590
So in that case here
on the app, you're

00:03:23.590 --> 00:03:28.486
saying if staging is not
sound, just use debug.

00:03:28.486 --> 00:03:29.860
You have the same
exact principle

00:03:29.860 --> 00:03:33.040
if you have a missing
flavor dimension value.

00:03:33.040 --> 00:03:36.400
Here, the error message
is a little bit different

00:03:36.400 --> 00:03:38.110
because there's
multiple flavors,

00:03:38.110 --> 00:03:39.840
potentially, so they're named--

00:03:39.840 --> 00:03:42.540
tier being the name of
the flavor dimension--

00:03:42.540 --> 00:03:44.020
but that's the same
problem, right?

00:03:44.020 --> 00:03:46.930
It's not finding trial when
you're searching for it,

00:03:46.930 --> 00:03:49.540
and so the fix is basically
exactly the same one.

00:03:49.540 --> 00:03:54.460
You're just assigning matching
fallback on the trial run,

00:03:54.460 --> 00:03:56.320
and we do that on the
consuming side, right?

00:03:56.320 --> 00:03:58.060
On the app side,
not the library.

00:03:58.060 --> 00:04:00.380
Or if it's a library that
depends on the library,

00:04:00.380 --> 00:04:03.340
you put it always on
the consuming side.

00:04:03.340 --> 00:04:05.470
You can have another
type of problem.

00:04:05.470 --> 00:04:08.170
Here, it's saying cannot
choose between the following

00:04:08.170 --> 00:04:09.050
configuration.

00:04:09.050 --> 00:04:10.670
So instead of
finding zero matches,

00:04:10.670 --> 00:04:15.392
it finds two compatible
matches, and so it's only

00:04:15.392 --> 00:04:17.100
going to show the two
configurations that

00:04:17.100 --> 00:04:17.740
are matching.

00:04:17.740 --> 00:04:19.323
It's going to hide
all the other ones,

00:04:19.323 --> 00:04:20.651
so that's a little bit easier.

00:04:20.651 --> 00:04:22.150
And if you look at
it, there's going

00:04:22.150 --> 00:04:24.760
to be a lot of attributes
that are compatible,

00:04:24.760 --> 00:04:26.380
so you can just ignore them.

00:04:26.380 --> 00:04:28.120
And then you're down
to those two here,

00:04:28.120 --> 00:04:31.870
and it says it found an
attribute on the producing

00:04:31.870 --> 00:04:35.770
side on the library, but it was
not required by the consumer.

00:04:35.770 --> 00:04:37.540
And so here, basically
what's happening

00:04:37.540 --> 00:04:42.730
is that your library has defined
a flavor dimension that is not

00:04:42.730 --> 00:04:45.130
defined in the app or
the consuming module,

00:04:45.130 --> 00:04:47.380
and therefore, it doesn't
know how to choose this one.

00:04:47.380 --> 00:04:50.350
So you can, again, create the
flavor dimension in your app

00:04:50.350 --> 00:04:54.520
or in the consuming model,
or you can just go and say

00:04:54.520 --> 00:04:57.970
missing dimension strategy, name
of the flavor dimension, name

00:04:57.970 --> 00:04:59.480
of the value, and
all it's doing,

00:04:59.480 --> 00:05:01.450
really, is just adding
that attribute directly

00:05:01.450 --> 00:05:04.660
to the request so that it's
able to match the other one.

00:05:04.660 --> 00:05:08.290
And you can add these either
to the default config, which

00:05:08.290 --> 00:05:10.360
applies to all your
variants, you kind apply it

00:05:10.360 --> 00:05:13.521
to a specific flavor, which
will apply only to that flavor,

00:05:13.521 --> 00:05:15.270
or you can add it to
a particular variant.

00:05:19.694 --> 00:05:21.110
JEROME DOCHEZ: All
right, so let's

00:05:21.110 --> 00:05:22.940
talk about some of
the notable changes

00:05:22.940 --> 00:05:26.940
that we've introduced in
the compilation pipeline.

00:05:26.940 --> 00:05:30.470
The first thing that we
have changed lately is aapt,

00:05:30.470 --> 00:05:34.100
and this is a new incremental
resource compiler.

00:05:34.100 --> 00:05:37.790
And compared to aapt1, aapt2
is really dividing its work

00:05:37.790 --> 00:05:38.970
into two phases.

00:05:38.970 --> 00:05:41.150
There is an incremental
capable compilation

00:05:41.150 --> 00:05:44.900
phase, where it's changing your
resources into a binary format,

00:05:44.900 --> 00:05:47.482
and then there is a
final linking phase

00:05:47.482 --> 00:05:49.190
where it's going to
generate the resource

00:05:49.190 --> 00:05:51.650
table and the final IDs.

00:05:51.650 --> 00:05:54.410
Now, if you want to use the
latest platform features,

00:05:54.410 --> 00:05:56.090
you need to use aapt2.

00:05:56.090 --> 00:06:01.190
And in theory, aapt2 is
entirely compatible with aapt1.

00:06:01.190 --> 00:06:04.310
However, it's a lot stricter, so
you might run into issues when

00:06:04.310 --> 00:06:07.190
you change from aapt1 to appt2.

00:06:07.190 --> 00:06:09.140
So we have given you
a flag so that you

00:06:09.140 --> 00:06:11.690
can disable if you
have issues, but you

00:06:11.690 --> 00:06:14.480
should be aware that
those issues may not

00:06:14.480 --> 00:06:16.650
be in aapt2 itself.

00:06:16.650 --> 00:06:18.570
It may be in your project.

00:06:18.570 --> 00:06:22.257
So you should find bugs if
you find issues with aapt2,

00:06:22.257 --> 00:06:23.840
but you should do
your homework first.

00:06:23.840 --> 00:06:25.310
You should look
into, well, maybe

00:06:25.310 --> 00:06:27.750
the problem is in my project.

00:06:27.750 --> 00:06:28.340
So let's look.

00:06:28.340 --> 00:06:33.200
Maybe you have invalid resources
and reference to stuff.

00:06:33.200 --> 00:06:35.390
aapt2 will catch those.

00:06:35.390 --> 00:06:38.600
So we're going to phase
out aapt1 pretty soon,

00:06:38.600 --> 00:06:40.550
so it's really important
that you switch

00:06:40.550 --> 00:06:44.310
and that you find bugs
if you still find some.

00:06:44.310 --> 00:06:46.570
Next thing is desugar.

00:06:46.570 --> 00:06:48.900
So this is a tool
which is used to remove

00:06:48.900 --> 00:06:52.590
all the syntactic sugar
that was added by Java 8,

00:06:52.590 --> 00:06:55.710
like [INAUDIBLE]
and stuff like that.

00:06:55.710 --> 00:06:57.910
We've delivered, again,
into two different versions.

00:06:57.910 --> 00:06:59.940
So the first version
we shipped was 3.0,

00:06:59.940 --> 00:07:02.260
was an external process.

00:07:02.260 --> 00:07:05.010
It used a lot of
resource, was pretty slow.

00:07:05.010 --> 00:07:07.639
Now with the D8,
the new Dexer, we've

00:07:07.639 --> 00:07:09.180
introduced a newer
version where it's

00:07:09.180 --> 00:07:13.470
integrated inside its pipeline,
so it's better, it's faster.

00:07:13.470 --> 00:07:16.380
Again, we're going to
phase out the old version.

00:07:16.380 --> 00:07:18.860
In theory, you should all be
switching to the integrated

00:07:18.860 --> 00:07:19.360
version.

00:07:19.360 --> 00:07:21.480
You shouldn't be
seeing any difference.

00:07:21.480 --> 00:07:22.819
If you do, please file a bug.

00:07:22.819 --> 00:07:24.360
It's most likely
our fault this time.

00:07:24.360 --> 00:07:26.880
It's probably not your
fault. But file a bug

00:07:26.880 --> 00:07:30.080
because we're going to phase
out the old external process

00:07:30.080 --> 00:07:33.350
version very soon.

00:07:33.350 --> 00:07:35.330
Talking about Dexer,
you should all

00:07:35.330 --> 00:07:39.320
be using the new D8
compiler right now.

00:07:39.320 --> 00:07:41.660
It was introduced in 3.0.

00:07:41.660 --> 00:07:45.320
It's now default in 3.1.

00:07:45.320 --> 00:07:46.670
If you use DX--

00:07:46.670 --> 00:07:50.440
if you still use DX because you
have errors, translation errors

00:07:50.440 --> 00:07:54.410
or runtime errors, you
should definitely file bugs.

00:07:54.410 --> 00:07:58.070
They are extremely responsive
at fixing those issues.

00:07:58.070 --> 00:08:01.010
And again, we're going to
be phasing out the old DX

00:08:01.010 --> 00:08:04.190
very soon, and we
would like you to be

00:08:04.190 --> 00:08:06.190
still capable of building
your applications,

00:08:06.190 --> 00:08:08.000
so please file bugs.

00:08:08.000 --> 00:08:12.770
Now, we've just introduced
R8, which is a new shrinker

00:08:12.770 --> 00:08:16.340
obfuscator, but it's a slightly
different thing than what

00:08:16.340 --> 00:08:17.560
it used to be, was ProGuard.

00:08:17.560 --> 00:08:19.351
So ProGuard used to
operate on class files.

00:08:19.351 --> 00:08:22.340
It was transforming class
files and making them minified

00:08:22.340 --> 00:08:24.160
to be ready to be dexed.

00:08:24.160 --> 00:08:28.070
R8 takes over the entire
pipeline from class files

00:08:28.070 --> 00:08:30.470
to text files, so that
means it's doing desugar,

00:08:30.470 --> 00:08:34.580
it's doing minification, and
dexing all in one operation,

00:08:34.580 --> 00:08:38.600
and it can reuse a lot of
the data, so it's faster.

00:08:38.600 --> 00:08:39.770
So we introduced it.

00:08:39.770 --> 00:08:42.380
You should try it, and you
should see if it works well.

00:08:42.380 --> 00:08:44.830
Again, please file bugs
because at some point,

00:08:44.830 --> 00:08:48.730
we will stop supporting the
old shrinkers-- maybe not soon,

00:08:48.730 --> 00:08:50.360
but very mid-term, I would say.

00:08:52.940 --> 00:08:55.850
Now, these are the flags you
can use to enable or disable

00:08:55.850 --> 00:08:59.890
R8 and D8, so please use
these if you run into trouble,

00:08:59.890 --> 00:09:01.610
but please also file bugs, OK?

00:09:04.150 --> 00:09:06.460
Now let's talk a little
bit about performance.

00:09:06.460 --> 00:09:10.180
We know very well that it is a
subject that you are extremely

00:09:10.180 --> 00:09:13.290
interested in, and so are we.

00:09:13.290 --> 00:09:16.030
One of the problems
we have is that we

00:09:16.030 --> 00:09:18.144
have a lot of trouble
reproducing issues

00:09:18.144 --> 00:09:19.310
that may happen in the wild.

00:09:19.310 --> 00:09:20.810
We don't have that
many applications

00:09:20.810 --> 00:09:23.110
internally that we can use.

00:09:23.110 --> 00:09:27.190
However, here is an example
using the Nest mobile app.

00:09:27.190 --> 00:09:31.570
And you can see that a Nest full
build has improved about 13%

00:09:31.570 --> 00:09:34.870
from 3.0 to 3.1, and about 18%--

00:09:34.870 --> 00:09:36.290
obviously this is not final--

00:09:36.290 --> 00:09:38.830
with 3.2 versus 3.1.

00:09:38.830 --> 00:09:41.177
That's if you keep the
same set of features

00:09:41.177 --> 00:09:42.010
in your application.

00:09:42.010 --> 00:09:43.420
Obviously you're not
changing the application,

00:09:43.420 --> 00:09:45.010
just changing the plug-in.

00:09:45.010 --> 00:09:48.190
If you start adding features
like Java A dot Kotlin,

00:09:48.190 --> 00:09:49.754
things may very, obviously.

00:09:52.540 --> 00:09:56.202
Now, if you look a little
deeper at performance,

00:09:56.202 --> 00:09:57.910
things are a little
bit more complicated.

00:09:57.910 --> 00:10:00.980
So in particular, when you
look at incremental builds,

00:10:00.980 --> 00:10:04.960
you can see that Java C for a
full build was about 10% to 15%

00:10:04.960 --> 00:10:07.900
of the overall build, but when
you went incremental build,

00:10:07.900 --> 00:10:13.130
it jumps to a really bad 38%
of the overall build time.

00:10:13.130 --> 00:10:17.300
So really, we can see that
in incremental scenarios,

00:10:17.300 --> 00:10:20.140
Java C compilation is
the dominating factor.

00:10:20.140 --> 00:10:20.770
Why is that?

00:10:20.770 --> 00:10:22.510
It's because it's
not incremental.

00:10:22.510 --> 00:10:23.980
Why is it not incremental?

00:10:23.980 --> 00:10:26.410
It's because people are
using annotation processors,

00:10:26.410 --> 00:10:30.010
and so far, they are
not incremental-capable.

00:10:30.010 --> 00:10:33.910
So we started a joint
effort with Gradle

00:10:33.910 --> 00:10:37.490
to have incremental
annotation processors.

00:10:37.490 --> 00:10:39.222
It's called InCAP.

00:10:39.222 --> 00:10:39.805
So it's ready.

00:10:39.805 --> 00:10:41.920
It's been shipped in 4.7.

00:10:41.920 --> 00:10:44.950
And now we are in
the process of trying

00:10:44.950 --> 00:10:47.620
to move all of Google's
annotation processors

00:10:47.620 --> 00:10:50.410
to be incremental-capable.

00:10:50.410 --> 00:10:52.810
There is an action
required from you.

00:10:52.810 --> 00:10:55.550
If you have in-house
annotation processors,

00:10:55.550 --> 00:10:57.850
then you should move them
to be inCAP-capable to use

00:10:57.850 --> 00:10:58.720
this library.

00:10:58.720 --> 00:11:00.430
It's not very complicated.

00:11:00.430 --> 00:11:01.992
For the simple
annotation processors

00:11:01.992 --> 00:11:04.450
where there is just, like, one
source file and it generates

00:11:04.450 --> 00:11:06.130
something from one
source, there's

00:11:06.130 --> 00:11:07.830
a need to see the entire world.

00:11:07.830 --> 00:11:11.590
It's just adding a few manifest
entries, so it's very simple.

00:11:11.590 --> 00:11:15.520
And that will, if all of
your annotation processors

00:11:15.520 --> 00:11:20.279
are inCAP-capable, be able
to switch the compilation

00:11:20.279 --> 00:11:21.820
to be incremental,
and that will have

00:11:21.820 --> 00:11:25.720
a huge impact on the performance
of your incremental builds.

00:11:25.720 --> 00:11:28.105
[AUDIENCE APPLAUSE]

00:11:28.105 --> 00:11:29.059
Thank you.

00:11:31.930 --> 00:11:33.560
Let's talk a little
bit about Jetpack.

00:11:33.560 --> 00:11:37.790
You've heard about it a
lot, so how does it work?

00:11:37.790 --> 00:11:39.800
Let's just take
the first example

00:11:39.800 --> 00:11:43.340
where you want to move
to a pure androidx.

00:11:43.340 --> 00:11:44.190
project.

00:11:44.190 --> 00:11:45.770
So here, you've got
your old project.

00:11:45.770 --> 00:11:47.870
It's using the old
[INAUDIBLE] support.

00:11:47.870 --> 00:11:51.140
What you should do is to use
the refactoring tool in studio

00:11:51.140 --> 00:11:54.830
to actually move your
project to use the new stuff.

00:11:54.830 --> 00:11:59.229
One of the issues is that
we add some dependencies

00:11:59.229 --> 00:12:01.645
to your project automatically,
so you use legacy multi-dex

00:12:01.645 --> 00:12:03.530
or you use data binding.

00:12:03.530 --> 00:12:08.360
We're going to add automatically
the multi-dex support library.

00:12:08.360 --> 00:12:11.940
Now, if you move to
a new pure androidx.

00:12:11.940 --> 00:12:16.140
world, Where you now
suddenly have the androidx.

00:12:16.140 --> 00:12:19.160
constraint layout instead
of the old com.support, we

00:12:19.160 --> 00:12:21.840
need to know that we must
use the word androidx.

00:12:21.840 --> 00:12:25.250
multi-dex runtime library so
that the two worlds do not

00:12:25.250 --> 00:12:26.090
collide, right?

00:12:26.090 --> 00:12:30.260
So we need to have an indication
of which one we want to inject.

00:12:30.260 --> 00:12:34.340
And you need to tell to
plug-in through this flag which

00:12:34.340 --> 00:12:36.357
of the two versions
you want us to use, OK?

00:12:36.357 --> 00:12:37.940
So if you want to
move to an androidx.

00:12:37.940 --> 00:12:42.070
world, please use this flag.

00:12:42.070 --> 00:12:44.050
If you are in a
hybrid world, which

00:12:44.050 --> 00:12:46.420
is most likely what's going
to happen to most people--

00:12:46.420 --> 00:12:48.310
so yes, you've moved
your application,

00:12:48.310 --> 00:12:51.040
you moved all your projects
to use the new androidx.

00:12:51.040 --> 00:12:53.470
Stuff, but you use
some external library

00:12:53.470 --> 00:12:56.080
that you have no control
over, that still uses

00:12:56.080 --> 00:13:00.580
the old com.support
libraries, you

00:13:00.580 --> 00:13:03.380
have no control over the
sources, so what can you do?

00:13:03.380 --> 00:13:05.470
So we're going to provide
a build time translation

00:13:05.470 --> 00:13:09.550
facility that will just
basically change automatically

00:13:09.550 --> 00:13:12.580
the dependency from the
old [INAUDIBLE] support

00:13:12.580 --> 00:13:17.020
to the new one, and will
change the library itself

00:13:17.020 --> 00:13:21.605
by changing all the import
statements to the new ones.

00:13:21.605 --> 00:13:22.605
So this is done locally.

00:13:22.605 --> 00:13:25.000
It's not like we're going
to republish this library.

00:13:25.000 --> 00:13:27.170
But locally, you
will be able to have

00:13:27.170 --> 00:13:30.460
an illusion of a pure world
where everybody is depending

00:13:30.460 --> 00:13:31.600
on the new androidx.

00:13:31.600 --> 00:13:33.040
Library.

00:13:33.040 --> 00:13:34.740
Again, there is a
flag-enabled Jetifier.

00:13:38.080 --> 00:13:40.370
XAVIER DUCOY: OK, so let's
talk about the app bundle.

00:13:40.370 --> 00:13:42.370
I'm sure you've heard
about the app bundle a lot

00:13:42.370 --> 00:13:44.680
over the last two days,
so we're going to tell you

00:13:44.680 --> 00:13:48.050
a few greater, specific things.

00:13:48.050 --> 00:13:50.860
So the first thing is that
on the application plug-in--

00:13:50.860 --> 00:13:53.080
not on the library or
the feature plug-in,

00:13:53.080 --> 00:13:54.820
but on the application
plug-in, on top

00:13:54.820 --> 00:13:57.070
of all the assemble
tasks that you see here,

00:13:57.070 --> 00:13:58.830
we have bundled tasks.

00:13:58.830 --> 00:14:02.590
And so you'll be able to very
quickly, without any change,

00:14:02.590 --> 00:14:04.370
just go and build a bundle.

00:14:04.370 --> 00:14:08.050
And remember that the bundle
is a way to upload that

00:14:08.050 --> 00:14:10.150
to the Play Store and
get out-of-the-box,

00:14:10.150 --> 00:14:13.300
much smaller APKs
targeting API, density,

00:14:13.300 --> 00:14:16.800
and languages for
a specific device.

00:14:16.800 --> 00:14:20.160
So you'll get much
smaller [INAUDIBLE]..

00:14:20.160 --> 00:14:24.580
Locally, you can also
build an APK exactly

00:14:24.580 --> 00:14:28.660
the same way the Play Store does
it when it creates those APK.

00:14:28.660 --> 00:14:30.460
So if you want to
verify something,

00:14:30.460 --> 00:14:32.410
saying, you know,
I have a device,

00:14:32.410 --> 00:14:34.630
I don't want to build
an APK directly,

00:14:34.630 --> 00:14:36.300
I want to build an
APK the way the Play

00:14:36.300 --> 00:14:40.410
Store would create an APK from
the bundle, you can do that.

00:14:40.410 --> 00:14:42.370
So this step is definitely
a little bit more

00:14:42.370 --> 00:14:44.710
involved than directly
building the APK, right?

00:14:44.710 --> 00:14:46.646
We first build a
bundle, then we use

00:14:46.646 --> 00:14:49.270
a tool called Bundle tool, which
is also available as a command

00:14:49.270 --> 00:14:52.930
line tool, to create a ZIP
of all possibility cases,

00:14:52.930 --> 00:14:55.330
and then based on a
device configuration,

00:14:55.330 --> 00:14:57.290
we can go and create those APKs.

00:14:57.290 --> 00:14:59.950
In general, we don't
really necessarily want

00:14:59.950 --> 00:15:04.530
you to create that manually
using a greater task.

00:15:04.530 --> 00:15:08.140
However, a lot of Studio
Android itself can

00:15:08.140 --> 00:15:10.750
use that flow when you need it.

00:15:10.750 --> 00:15:12.940
So for example,
the install task,

00:15:12.940 --> 00:15:15.640
if you have just a basic
Android application

00:15:15.640 --> 00:15:19.540
with no dynamic features, is
going to directly build an APK.

00:15:19.540 --> 00:15:21.910
As soon as you create
dynamic features, which

00:15:21.910 --> 00:15:23.980
we'll talk about
in a little bit,

00:15:23.980 --> 00:15:26.320
then the install task
will go through the bundle

00:15:26.320 --> 00:15:29.380
in order to ensure that we can
install that on any device.

00:15:29.380 --> 00:15:31.510
Because remember, if you
have a dynamic feature

00:15:31.510 --> 00:15:34.300
and you try to install
on a pre-L device, so API

00:15:34.300 --> 00:15:39.070
less than 21, we need to
fuse those APKs together

00:15:39.070 --> 00:15:40.605
in order to install
it, and we don't

00:15:40.605 --> 00:15:42.980
want to do it a way that's
different from the Play Store.

00:15:42.980 --> 00:15:44.521
We want to do it
exactly the same way

00:15:44.521 --> 00:15:46.510
the Play Store does it.

00:15:46.510 --> 00:15:49.630
If you try to run test from
the command line calling

00:15:49.630 --> 00:15:51.400
connected check,
it's always going

00:15:51.400 --> 00:15:53.290
to go directly to the APKs.

00:15:53.290 --> 00:15:55.960
We're going to work
later on adding support

00:15:55.960 --> 00:15:58.720
to run test [INAUDIBLE]
the bundle in order

00:15:58.720 --> 00:16:01.810
to simulate better exactly
the type of APKs that

00:16:01.810 --> 00:16:04.660
are created by the Play Store.

00:16:04.660 --> 00:16:06.970
Deploying from Studio,
you have a choice, right?

00:16:06.970 --> 00:16:09.560
You can either
directly deploy APKs

00:16:09.560 --> 00:16:12.160
or you can deploy APKs
[INAUDIBLE] the bundle.

00:16:12.160 --> 00:16:16.120
And here, the run
configuration inside Studio

00:16:16.120 --> 00:16:18.400
has a checkbox
that you can check.

00:16:18.400 --> 00:16:20.620
We recommend to not
check it when you

00:16:20.620 --> 00:16:23.080
do your regular development.

00:16:23.080 --> 00:16:26.500
As we saw earlier, building
an APK from the bundle

00:16:26.500 --> 00:16:28.840
is much complicated than
building it directly.

00:16:28.840 --> 00:16:31.210
And on top of that, when
you deploy from Studio,

00:16:31.210 --> 00:16:34.120
we actually look at the
device you want to target,

00:16:34.120 --> 00:16:36.370
and then we inject that
information into Gradle,

00:16:36.370 --> 00:16:37.930
and then Gradle
takes some shortcuts.

00:16:37.930 --> 00:16:40.902
So for example, if you require
legacy multi-dex, which

00:16:40.902 --> 00:16:42.610
takes a while to build,
but you deploy it

00:16:42.610 --> 00:16:44.532
to device that's
21 or above, we're

00:16:44.532 --> 00:16:46.240
actually going to use
[INAUDIBLE],, which

00:16:46.240 --> 00:16:47.439
is much faster.

00:16:47.439 --> 00:16:49.480
We can't take that kind
of shortcut when we build

00:16:49.480 --> 00:16:52.584
a bundle, so we recommend to
have two different types of run

00:16:52.584 --> 00:16:54.250
configuration, just
create two of them--

00:16:54.250 --> 00:16:56.530
one with and one
without the option--

00:16:56.530 --> 00:16:59.884
and then use the APK as often
as you can, and only use

00:16:59.884 --> 00:17:01.300
the other one when
you really have

00:17:01.300 --> 00:17:04.240
to, when you want to try exactly
the APK that will be delivered

00:17:04.240 --> 00:17:05.410
by the Play Store.

00:17:05.410 --> 00:17:08.710
If you push to a device,
again, that's pre-21,

00:17:08.710 --> 00:17:10.599
then we're going to use
that option any way,

00:17:10.599 --> 00:17:13.000
and we're always going
to go through the bundle,

00:17:13.000 --> 00:17:16.730
as soon as you have
dynamic features.

00:17:16.730 --> 00:17:21.510
So you may already be doing
manual multi-APK using the DSL,

00:17:21.510 --> 00:17:23.270
and also, there's
a variant API that

00:17:23.270 --> 00:17:26.369
allows you to compute
version code dynamically

00:17:26.369 --> 00:17:28.286
for all the different
APKs that get generated.

00:17:28.286 --> 00:17:29.869
If you're doing that
right now and you

00:17:29.869 --> 00:17:31.770
want to switch to the
bundle, you can't just

00:17:31.770 --> 00:17:33.660
erase all of that DSL.

00:17:33.660 --> 00:17:35.260
It's completely
unnecessary, right?

00:17:35.260 --> 00:17:36.514
There's nothing to do.

00:17:36.514 --> 00:17:38.430
All you have to do-- you
call the bundle task,

00:17:38.430 --> 00:17:40.460
get your bundle, you're done.

00:17:40.460 --> 00:17:43.400
And on the server side, we will
do all the splits by density,

00:17:43.400 --> 00:17:46.730
ABI long wedge by
default. We do have

00:17:46.730 --> 00:17:49.980
a DSL to allow you to
maybe disable it if you're

00:17:49.980 --> 00:17:51.510
running into a problem.

00:17:51.510 --> 00:17:53.850
We expect that there will be
very, very few cases where

00:17:53.850 --> 00:17:57.490
you actually need to do that,
but you have the ability

00:17:57.490 --> 00:17:58.920
if you really have to.

00:17:58.920 --> 00:18:00.360
If you have that,
also file a bug

00:18:00.360 --> 00:18:03.660
and talk to the Play Store team
and see if you can actually

00:18:03.660 --> 00:18:07.040
solve the problem with them.

00:18:07.040 --> 00:18:09.140
So I mentioned dynamic
feature earlier.

00:18:09.140 --> 00:18:11.110
So what are dynamic features?

00:18:11.110 --> 00:18:14.770
They are smaller APKs that
are downloaded on-demand side

00:18:14.770 --> 00:18:16.300
by side with your main APK.

00:18:16.300 --> 00:18:19.700
So if you have a feature that
only 10% of all users need,

00:18:19.700 --> 00:18:22.120
no need to install
it for the other 90%.

00:18:22.120 --> 00:18:23.786
Just type in download on-demand.

00:18:23.786 --> 00:18:25.660
So the way you're going
to organize your code

00:18:25.660 --> 00:18:29.107
is it's a separate
sub-project in Gradle.

00:18:29.107 --> 00:18:30.940
You have a different
plug-in, a new plug-in,

00:18:30.940 --> 00:18:33.539
called dynamic
feature, and the layout

00:18:33.539 --> 00:18:35.580
is a little bit different
compared to, let's say,

00:18:35.580 --> 00:18:36.570
a library.

00:18:36.570 --> 00:18:38.830
Normally, in a library,
your application depends

00:18:38.830 --> 00:18:41.790
on your library and cannot
refer the code of the library.

00:18:41.790 --> 00:18:44.950
Here, the features are
actually sitting on top

00:18:44.950 --> 00:18:46.900
and depend on the base.

00:18:46.900 --> 00:18:50.200
So we can see here the
two dynamic features

00:18:50.200 --> 00:18:53.380
in blue applying the
plug-in Dynamic Feature.

00:18:53.380 --> 00:18:57.160
Have a dependency on the project
app, which is your base one.

00:18:57.160 --> 00:18:59.410
Now, the base one
also has to refer

00:18:59.410 --> 00:19:00.550
to those dynamic features.

00:19:00.550 --> 00:19:04.957
It needs to list them
because the way we build--

00:19:04.957 --> 00:19:05.790
I'll show you later.

00:19:05.790 --> 00:19:08.050
It's a little bit
complicated, it's unusual.

00:19:08.050 --> 00:19:09.910
But you need to list
those dynamic features,

00:19:09.910 --> 00:19:11.451
and it's just a list
of strings which

00:19:11.451 --> 00:19:16.120
are the greater path of all
of your dynamic features.

00:19:16.120 --> 00:19:19.150
If you used Instant
App since last year,

00:19:19.150 --> 00:19:21.930
it probably looks
somewhat similar.

00:19:21.930 --> 00:19:24.520
You know, Instant App you have
the feature plug-in, which

00:19:24.520 --> 00:19:27.490
is used both for your features
and for your base feature,

00:19:27.490 --> 00:19:31.000
except you have a small flag
using base feature equals true.

00:19:31.000 --> 00:19:34.060
But the base feature also has to
refer to all of those features

00:19:34.060 --> 00:19:36.970
using a slightly different
DSL, which is not great,

00:19:36.970 --> 00:19:40.150
and we'll probably migrate to
the Dynamic Feature version

00:19:40.150 --> 00:19:42.820
soon, but right now, you
do it using the feature

00:19:42.820 --> 00:19:44.560
configuration.

00:19:44.560 --> 00:19:47.570
And you probably heard
that in the future,

00:19:47.570 --> 00:19:50.530
you'll be able to Instant-enable
your app bundle in order

00:19:50.530 --> 00:19:53.407
to deliver dynamic apps
using the app bundle,

00:19:53.407 --> 00:19:55.990
and this is why it's going to
be possible, because the Feature

00:19:55.990 --> 00:19:59.340
plug-in and the Dynamic Feature
plug-in are very, very similar.

00:19:59.340 --> 00:20:01.840
In fact, the application Dynamic
Feature and Feature plug-in

00:20:01.840 --> 00:20:04.840
share probably over
95% of their code.

00:20:04.840 --> 00:20:06.100
They are extremely similar.

00:20:06.100 --> 00:20:08.107
And so if you're already
architecturing your app

00:20:08.107 --> 00:20:09.940
for Instant App, switching
to the app bundle

00:20:09.940 --> 00:20:12.070
would be exactly the same
architecture with slightly

00:20:12.070 --> 00:20:12.890
different plug-ins.

00:20:12.890 --> 00:20:15.760
And if you're doing
Dynamic Feature right now,

00:20:15.760 --> 00:20:18.340
then also enabling that
to be done in Instant App

00:20:18.340 --> 00:20:19.840
would be very similar
in the future.

00:20:22.740 --> 00:20:25.620
OK, so I mentioned that
bidirectional dependency

00:20:25.620 --> 00:20:27.630
where the app bundle
needs to know about--

00:20:27.630 --> 00:20:30.580
the base app needs to
know about the feature.

00:20:30.580 --> 00:20:33.540
So if you have those two
modules that I had before,

00:20:33.540 --> 00:20:36.030
if you're building the APK,
just looks normal, right?

00:20:36.030 --> 00:20:38.490
There's a bunch of
intermediates in each module,

00:20:38.490 --> 00:20:40.290
and each output an APK.

00:20:40.290 --> 00:20:45.990
What happens is that the bundle
task belongs to the app module.

00:20:45.990 --> 00:20:48.780
And so when you actually
build the bundle,

00:20:48.780 --> 00:20:51.360
we have to publish things
from the Feature back

00:20:51.360 --> 00:20:54.262
into the base module,
and that's why

00:20:54.262 --> 00:20:55.970
we need to have all
of those dependencies

00:20:55.970 --> 00:20:57.990
be available on the base module.

00:20:57.990 --> 00:21:01.020
If you don't add a dynamic
feature to your base module,

00:21:01.020 --> 00:21:03.860
it's just not going to show
up in your bundle at all.

00:21:08.226 --> 00:21:10.350
JEROME DOCHEZ: So when
developing dynamic features,

00:21:10.350 --> 00:21:11.766
it's important to
understand there

00:21:11.766 --> 00:21:15.431
are some differences with
traditional Android application

00:21:15.431 --> 00:21:15.930
building.

00:21:15.930 --> 00:21:17.730
In particular, there's
some attributes

00:21:17.730 --> 00:21:19.530
of your application
which are invariant,

00:21:19.530 --> 00:21:21.690
which won't change
between the base module

00:21:21.690 --> 00:21:24.000
and the features--
application-id, versionName,

00:21:24.000 --> 00:21:25.200
versionCode.

00:21:25.200 --> 00:21:28.560
All of those should be
set in the base module,

00:21:28.560 --> 00:21:33.450
and we will then publish
them back to the features

00:21:33.450 --> 00:21:35.400
so that they can be
used in the task when,

00:21:35.400 --> 00:21:37.920
for instance, generating
the manifest or whatever.

00:21:37.920 --> 00:21:40.680
So it's important to understand
that you set them in the base,

00:21:40.680 --> 00:21:42.570
you do not repeat
them in the features.

00:21:42.570 --> 00:21:44.700
We will automatically
transfer them, OK?

00:21:47.420 --> 00:21:49.160
Let's talk a little
bit about multi-dex.

00:21:49.160 --> 00:21:51.440
So let's say you're in
a multi-dex situation

00:21:51.440 --> 00:21:53.270
and you're not
using any features,

00:21:53.270 --> 00:21:55.460
but you're still doing
the bundle thing.

00:21:55.460 --> 00:21:57.840
In this case, there's
really not much difference.

00:21:57.840 --> 00:21:58.920
It's the same behavior.

00:21:58.920 --> 00:22:01.128
The only difference is that
instead of shipping stuff

00:22:01.128 --> 00:22:05.000
into an APK, we are now shipping
into a bundle, which eventually

00:22:05.000 --> 00:22:06.140
gets uploaded.

00:22:06.140 --> 00:22:08.880
The dynamic delivery
will not do much.

00:22:08.880 --> 00:22:10.670
They will just take
these dex files

00:22:10.670 --> 00:22:14.690
and store them on the
device before execution.

00:22:14.690 --> 00:22:17.220
So same behavior.

00:22:17.220 --> 00:22:20.270
If you have Feature, still
not a lot of difference.

00:22:20.270 --> 00:22:23.330
Basically, each feature
can develop and grow,

00:22:23.330 --> 00:22:27.030
can become itself
multiple dex files.

00:22:27.030 --> 00:22:30.290
Everything gets merged
onto the base module,

00:22:30.290 --> 00:22:33.860
and then you get all packaged
inside the bundle again.

00:22:33.860 --> 00:22:36.090
And, you know, same
thing as without Feature.

00:22:36.090 --> 00:22:37.400
It gets delivered on the phone.

00:22:37.400 --> 00:22:39.410
Not a big difference.

00:22:39.410 --> 00:22:43.280
By default, we enable
the native multi-dexing.

00:22:43.280 --> 00:22:45.860
Now, things get a little
bit more complicated

00:22:45.860 --> 00:22:48.230
if your minSdk is below 21.

00:22:48.230 --> 00:22:51.890
So if it's below 21, we need to
have the flexibility to still

00:22:51.890 --> 00:22:54.260
deliver the application
in native multi-dex

00:22:54.260 --> 00:22:59.270
if you are suddenly deploying
on a device which is 25,

00:22:59.270 --> 00:23:03.020
but if you're
deploying on 15, now we

00:23:03.020 --> 00:23:05.390
need to do something
specific for that.

00:23:05.390 --> 00:23:09.110
And what will happen is
that a dynamic delivery

00:23:09.110 --> 00:23:14.090
will fuse all of your dex
files into a single one that

00:23:14.090 --> 00:23:15.510
will be delivered.

00:23:15.510 --> 00:23:17.630
So this is important
to realize that even

00:23:17.630 --> 00:23:20.690
if none of your modules,
including the base

00:23:20.690 --> 00:23:23.480
module or your Feature
modules, if none of them

00:23:23.480 --> 00:23:27.590
use multi-dexing itself,
because we combine those

00:23:27.590 --> 00:23:30.680
into a single one,
this may actually

00:23:30.680 --> 00:23:35.030
go over to the dex limit, and
this may require multi-dexing.

00:23:35.030 --> 00:23:37.580
So you need to manually
enable multi-dex

00:23:37.580 --> 00:23:38.990
in the base application.

00:23:38.990 --> 00:23:41.780
And what that will
do is basically

00:23:41.780 --> 00:23:45.650
create the maindex list that
it will ship along with all

00:23:45.650 --> 00:23:47.840
the dex files into the bundle.

00:23:47.840 --> 00:23:50.502
So now the dynamic delivery
will take that bundle,

00:23:50.502 --> 00:23:52.460
and it will be capable
that, if suddenly you're

00:23:52.460 --> 00:23:55.520
trying to deploy this
bundle on a 15 device,

00:23:55.520 --> 00:23:58.460
it will use the maindex
list to do the fusing,

00:23:58.460 --> 00:24:03.520
create the correct maindex, and
then create the [INAUDIBLE] dex

00:24:03.520 --> 00:24:04.740
correctly, all right?

00:24:07.800 --> 00:24:09.370
Shrinking and obfuscation.

00:24:09.370 --> 00:24:11.430
So it's the same as before--

00:24:11.430 --> 00:24:14.670
you set it on the base module,
just like the application ID.

00:24:14.670 --> 00:24:16.050
So you say, minifyEnabled.

00:24:16.050 --> 00:24:19.530
This is not a lot of changes,
but how we actually implement

00:24:19.530 --> 00:24:22.230
it is really, really different.

00:24:22.230 --> 00:24:23.730
So let's go through
the motion here.

00:24:24.230 --> 00:24:25.760
First of all, this
is only supported

00:24:25.760 --> 00:24:27.780
with R8, which is our
whole new shrinker I

00:24:27.780 --> 00:24:29.320
talked about earlier.

00:24:29.320 --> 00:24:32.690
So what we do is that we
take all the rules that

00:24:32.690 --> 00:24:35.660
will be defined close to
the classes they apply to.

00:24:35.660 --> 00:24:37.440
So we'll need the
rules in the features.

00:24:37.440 --> 00:24:39.648
We're going to merge all
the rules into a single one.

00:24:39.648 --> 00:24:42.840
Then we'll take all the class
files, we filled this into R8.

00:24:42.840 --> 00:24:45.650
R8 will create a combined dex.

00:24:45.650 --> 00:24:48.400
Big dex files with everything.

00:24:48.400 --> 00:24:51.480
And then we're going to feed
that dex file into a dex

00:24:51.480 --> 00:24:56.070
splitter, which will
re-split this dex for all

00:24:56.070 --> 00:24:58.980
of the features
plus for the base.

00:24:58.980 --> 00:25:01.540
So it's a very different
mechanism as before.

00:25:01.540 --> 00:25:04.110
Now we have-- again, this
dex has been shrinked.

00:25:04.110 --> 00:25:05.670
It's been obfuscated.

00:25:05.670 --> 00:25:08.010
Now there's two
scenarios possible.

00:25:08.010 --> 00:25:10.940
Either you're using the bundle
or you're using the APK.

00:25:10.940 --> 00:25:13.200
If you're using the
bundle, it's pretty simple.

00:25:13.200 --> 00:25:14.700
These dex files
are automatically

00:25:14.700 --> 00:25:18.180
transferred into the
bundle like we saw earlier.

00:25:18.180 --> 00:25:21.240
If you're using feature
it's slightly different.

00:25:21.240 --> 00:25:23.370
The dex files need to
be republished back

00:25:23.370 --> 00:25:25.800
to each of the feature.

00:25:25.800 --> 00:25:31.210
And then they will be
packaged into the APKs.

00:25:31.210 --> 00:25:31.710
Right?

00:25:31.710 --> 00:25:33.600
So it's a slightly
different mechanism

00:25:33.600 --> 00:25:35.067
as we must have
seen in the past.

00:25:35.067 --> 00:25:36.650
There's a lot of
going back and forth,

00:25:36.650 --> 00:25:38.350
and that's why we need to
have these dependencies

00:25:38.350 --> 00:25:39.391
between features and app.

00:25:43.610 --> 00:25:45.510
XAVIER DUCOY: OK,
so we wanted to talk

00:25:45.510 --> 00:25:47.718
a little bit about a few
things that actually are not

00:25:47.718 --> 00:25:49.590
shipping in 3.2.

00:25:49.590 --> 00:25:50.590
We are working on it.

00:25:50.590 --> 00:25:52.680
We've been working
on it for a while.

00:25:52.680 --> 00:25:55.260
We expect they will ship soon--

00:25:55.260 --> 00:25:56.880
you know, 3.3 Canary.

00:25:56.880 --> 00:25:58.780
And they have a lot of changes.

00:25:58.780 --> 00:26:01.100
And so we wanted to kind
of give you a heads up

00:26:01.100 --> 00:26:04.134
and also we want feedback
as soon as it's available.

00:26:04.134 --> 00:26:06.300
So I want to talk about the
way we process resources

00:26:06.300 --> 00:26:07.730
right now in the boot.

00:26:07.730 --> 00:26:11.980
So if you have a first
library or library two,

00:26:11.980 --> 00:26:13.740
in the current flow
what happens is

00:26:13.740 --> 00:26:16.085
that we're going to
process those resources

00:26:16.085 --> 00:26:17.460
and we are just
going to generate

00:26:17.460 --> 00:26:19.650
another java and nothing else.

00:26:19.650 --> 00:26:25.140
So when these get consumed by
another library, library one,

00:26:25.140 --> 00:26:27.840
this one may be referencing
resources from library two.

00:26:27.840 --> 00:26:31.200
And so in order to really
validate all those resource

00:26:31.200 --> 00:26:34.825
references, and also this
with some overlay mechanism,

00:26:34.825 --> 00:26:36.450
we're going to merge
those two resource

00:26:36.450 --> 00:26:38.730
folders into a single
resource folder

00:26:38.730 --> 00:26:41.670
and process it, and then
generate another R class.

00:26:41.670 --> 00:26:43.500
We actually generate
two R classes, right?

00:26:43.500 --> 00:26:46.209
One is called the library
itself, library one,

00:26:46.209 --> 00:26:48.750
which contains all the resources
from library one and library

00:26:48.750 --> 00:26:49.452
two.

00:26:49.452 --> 00:26:50.910
And then we have
another one, which

00:26:50.910 --> 00:26:52.826
is just a new version
of the R class generated

00:26:52.826 --> 00:26:54.720
by library two,
that is used in case

00:26:54.720 --> 00:26:57.555
you want to run tests and things
like that you need the final ID

00:26:57.555 --> 00:26:59.430
version of it.

00:26:59.430 --> 00:27:03.469
So then that gets consumed
by an application.

00:27:03.469 --> 00:27:05.260
We kind of have to do
the same thing again.

00:27:05.260 --> 00:27:08.400
So we're going to re-merge the
app and library one, library

00:27:08.400 --> 00:27:11.160
two, and process all of that.

00:27:11.160 --> 00:27:14.690
And then we generate the final
resource binary format as well

00:27:14.690 --> 00:27:18.180
as all our final classes
that are needed by the code

00:27:18.180 --> 00:27:21.070
from the app, library
one and library two.

00:27:21.070 --> 00:27:23.430
So as you can see, this is
not exactly efficient, right?

00:27:23.430 --> 00:27:25.140
This is probably one
of the last thing

00:27:25.140 --> 00:27:28.550
that is very inefficient
in the way we build things.

00:27:28.550 --> 00:27:30.210
The resources from
library two is

00:27:30.210 --> 00:27:32.670
basically merged and
processed three times.

00:27:32.670 --> 00:27:34.260
We generate a lot
of our classes.

00:27:34.260 --> 00:27:37.230
In fact, we're seeing some
projects with a few hundred

00:27:37.230 --> 00:27:39.355
modules generating
several thousands

00:27:39.355 --> 00:27:43.450
of classes, which is too many.

00:27:43.450 --> 00:27:45.000
And so we really
need to solve this.

00:27:45.000 --> 00:27:47.370
So as I said, we've been
working on a new flow

00:27:47.370 --> 00:27:49.650
and this is what the
new flow looks like.

00:27:49.650 --> 00:27:51.690
So first, when we
compile the library two

00:27:51.690 --> 00:27:54.600
we're going to generate a
binary version of resources.

00:27:54.600 --> 00:27:57.330
And this is because
AAPT2 has that feature.

00:27:57.330 --> 00:27:58.800
We can't make that
work with AAPT,

00:27:58.800 --> 00:28:01.660
so that's why Jerome was
saying, AAPT is going away.

00:28:01.660 --> 00:28:03.930
AAPT2 is really the future.

00:28:03.930 --> 00:28:05.312
We also create the R class.

00:28:05.312 --> 00:28:07.770
And this time we just integrate
the R class directly rather

00:28:07.770 --> 00:28:10.186
than just source code so that
we don't have to compile it.

00:28:10.186 --> 00:28:11.910
That's more efficient.

00:28:11.910 --> 00:28:14.460
When we depend on
it and consume it

00:28:14.460 --> 00:28:17.010
in library one, what
we're going to do

00:28:17.010 --> 00:28:18.510
is that we are only
going to process

00:28:18.510 --> 00:28:20.430
the resources of that module.

00:28:20.430 --> 00:28:23.580
And then we use the output
of the previous module

00:28:23.580 --> 00:28:26.155
the same way, basically, you
use a jar during Java C, right?

00:28:26.155 --> 00:28:28.230
It's just a compile test class.

00:28:28.230 --> 00:28:32.250
It's mostly there to validate
again resource references

00:28:32.250 --> 00:28:34.050
and regenerate a new
resource package that

00:28:34.050 --> 00:28:35.550
only contains those resources.

00:28:35.550 --> 00:28:36.780
Not the merge version.

00:28:36.780 --> 00:28:38.160
There's no merge anymore.

00:28:38.160 --> 00:28:40.110
And the R class only
of that library.

00:28:40.110 --> 00:28:43.560
Now, that library R class
only contain the resources

00:28:43.560 --> 00:28:44.460
of that library.

00:28:44.460 --> 00:28:47.750
It does not contain the resource
IDs of the previous library

00:28:47.750 --> 00:28:48.660
and this one.

00:28:48.660 --> 00:28:51.810
We don't know merge
those IDs anymore.

00:28:51.810 --> 00:28:55.850
When an app depends on
library one and library

00:28:55.850 --> 00:28:58.590
two, same exact principles.

00:28:58.590 --> 00:29:00.930
At the end, we have
an additional step

00:29:00.930 --> 00:29:03.000
because we need to
take all those binaries

00:29:03.000 --> 00:29:06.030
and binary format
of the resources

00:29:06.030 --> 00:29:10.575
and merge it into the final one
and create the final R class.

00:29:10.575 --> 00:29:13.200
So as you can see, we're merging
everything a lot less classes.

00:29:13.200 --> 00:29:14.658
And also it's a
lot more efficient.

00:29:14.658 --> 00:29:18.500
For example if I change
a resource in library two

00:29:18.500 --> 00:29:21.270
by just editing,
let's say, a string,

00:29:21.270 --> 00:29:24.170
there's no reason that I need
to compile library one again.

00:29:24.170 --> 00:29:26.940
Right, it's just
the list of ideas

00:29:26.940 --> 00:29:28.920
that I need to check
against for reference

00:29:28.920 --> 00:29:31.717
is exactly the same
one as with no changes.

00:29:31.717 --> 00:29:34.050
So we can use the same thing,
like combination avoidance

00:29:34.050 --> 00:29:35.670
that we use for Java C.

00:29:35.670 --> 00:29:37.770
And then we don't need
to recompile every one.

00:29:37.770 --> 00:29:40.060
We don't need to recompile
the app [INAUDIBLE]..

00:29:40.060 --> 00:29:43.260
All we have to do is do the
final link, and that's it.

00:29:43.260 --> 00:29:47.040
And we can do that also because
the outlasts for the app

00:29:47.040 --> 00:29:49.510
does not use final IDs anymore.

00:29:49.510 --> 00:29:52.600
So let's look at some of
the impact of that change.

00:29:52.600 --> 00:29:55.170
So first I said that the
R class of each module

00:29:55.170 --> 00:29:57.180
only contain the
resources of that module.

00:29:57.180 --> 00:29:58.990
It doesn't contain all of them.

00:29:58.990 --> 00:30:00.698
That means that if
you're inside a module

00:30:00.698 --> 00:30:02.610
and you want to reference
another resource

00:30:02.610 --> 00:30:04.440
from another module,
you have to use the R

00:30:04.440 --> 00:30:08.700
class from that module instead
of the R class of your app.

00:30:08.700 --> 00:30:11.210
That means you're likely to
have to import more than one R

00:30:11.210 --> 00:30:15.230
class, which is [INAUDIBLE]
solved easily with [INAUDIBLE]..

00:30:15.230 --> 00:30:17.220
We're looking at ways to
make that work in Java

00:30:17.220 --> 00:30:18.480
easily, because
technically there's

00:30:18.480 --> 00:30:20.430
no reason for the R
class to be called R. It

00:30:20.430 --> 00:30:21.940
could be called whatever else.

00:30:21.940 --> 00:30:24.360
So each library would
define its own name

00:30:24.360 --> 00:30:26.640
to reduce the
amount of conflicts.

00:30:26.640 --> 00:30:29.200
And again as I said, you know
the R class IDs are not final

00:30:29.200 --> 00:30:32.130
anymore, even in [INAUDIBLE]
out to inside libraries, which

00:30:32.130 --> 00:30:37.620
means that you can't use
Java switch cases anymore.

00:30:37.620 --> 00:30:40.180
I mentioned that we are not
doing resource measure anymore.

00:30:40.180 --> 00:30:45.490
So if you have a module that
redefined a resource already

00:30:45.490 --> 00:30:48.620
present in your library, that's
not going to work anymore.

00:30:48.620 --> 00:30:51.542
And there's some
good reason for that.

00:30:51.542 --> 00:30:53.500
We definitely want to
hear from you, if you are

00:30:53.500 --> 00:30:55.562
using that in a strange way.

00:30:55.562 --> 00:30:57.020
If what you're
doing is when you're

00:30:57.020 --> 00:30:59.620
debugging my app I want to
overwrite an icon that's

00:30:59.620 --> 00:31:01.277
coming from one
of my library, you

00:31:01.277 --> 00:31:03.610
can just use variant aware
dependency management, right?

00:31:03.610 --> 00:31:07.430
In that library you have a
debug version of that icon,

00:31:07.430 --> 00:31:10.450
and then the app will consume
the debug question anyway,

00:31:10.450 --> 00:31:12.500
which was not the
case before 3.0.

00:31:12.500 --> 00:31:14.064
So that solves that problem.

00:31:14.064 --> 00:31:15.730
If you have another
use case, definitely

00:31:15.730 --> 00:31:17.563
talk to us because we
want to hear about it.

00:31:20.680 --> 00:31:22.150
So I mentioned namespace, right?

00:31:22.150 --> 00:31:25.229
You know, I haven't talked
about any namespace so far.

00:31:25.229 --> 00:31:26.770
But when you think
about it, you know

00:31:26.770 --> 00:31:29.145
I just said we don't have any
resource merger or resource

00:31:29.145 --> 00:31:30.140
pavilion.

00:31:30.140 --> 00:31:31.697
So what happens is
your application

00:31:31.697 --> 00:31:34.280
depends on a third party library
here or a third party library

00:31:34.280 --> 00:31:37.870
here, and both of them declare
exactly the same resource

00:31:37.870 --> 00:31:39.920
with the same name, but
with a different value.

00:31:39.920 --> 00:31:42.580
You know, a string midi
or a layout or [INAUDIBLE]

00:31:42.580 --> 00:31:43.600
or something like that.

00:31:43.600 --> 00:31:44.974
In the past, the
resource manager

00:31:44.974 --> 00:31:47.689
would just pick one
of them, basically.

00:31:47.689 --> 00:31:49.480
The first one that you
find your dependency

00:31:49.480 --> 00:31:51.280
would have a higher
priority, and it would just

00:31:51.280 --> 00:31:53.280
merge on top of the other
one it each would just

00:31:53.280 --> 00:31:56.572
replace the other one, which
is probably not what you want.

00:31:56.572 --> 00:31:58.030
And so here what's
happening now is

00:31:58.030 --> 00:31:59.530
that what we really
want to do is we

00:31:59.530 --> 00:32:00.950
want to package both of them.

00:32:00.950 --> 00:32:02.616
So both of them are
going to be compiled

00:32:02.616 --> 00:32:03.970
in their own namespace.

00:32:03.970 --> 00:32:05.710
And then we're going
to package that.

00:32:05.710 --> 00:32:08.620
Internally, the R classes
from those two libraries

00:32:08.620 --> 00:32:10.030
will have different--

00:32:10.030 --> 00:32:13.900
will have the same R.string.foo,
but with different values.

00:32:13.900 --> 00:32:15.910
And internally, the
resource stabilizer, they we

00:32:15.910 --> 00:32:17.800
really point to two
different resources which

00:32:17.800 --> 00:32:20.305
is much better so now
when you reference

00:32:20.305 --> 00:32:23.230
to a resource from
a library, you

00:32:23.230 --> 00:32:25.150
have to use the namespace
of that library.

00:32:25.150 --> 00:32:26.950
And using the R
class of that library

00:32:26.950 --> 00:32:30.070
is already a way to access
the site's namespace, right?

00:32:30.070 --> 00:32:31.540
It's like you don't
have a secure R

00:32:31.540 --> 00:32:33.257
class with all the IDs.

00:32:33.257 --> 00:32:34.840
So when you do that
from the manifest,

00:32:34.840 --> 00:32:36.770
it's a little bit different.

00:32:36.770 --> 00:32:40.660
You have to use the manifest--

00:32:40.660 --> 00:32:43.920
when you start from XML you have
to use the namespace directly

00:32:43.920 --> 00:32:45.800
in the resources.

00:32:45.800 --> 00:32:48.830
So add colon dot library
one, colon strings-fixed,

00:32:48.830 --> 00:32:51.580
which is very similar now to
when you access an Android.

00:32:51.580 --> 00:32:52.670
Namespace resource, right?

00:32:52.670 --> 00:32:55.150
At Android colon something.

00:32:55.150 --> 00:32:58.957
If you do have
custom attributes,

00:32:58.957 --> 00:33:00.040
you have to do same thing.

00:33:00.040 --> 00:33:03.190
So you're probably using res
auto everywhere now, not really

00:33:03.190 --> 00:33:05.780
bothering what
your limb space is.

00:33:05.780 --> 00:33:07.180
Now you actually have to care.

00:33:07.180 --> 00:33:09.580
You can say, hey, you know
this is construct layout,

00:33:09.580 --> 00:33:15.070
this XML prefix constraint is
that namespace of that library.

00:33:15.070 --> 00:33:18.160
And then I can use
those attributes.

00:33:18.160 --> 00:33:20.640
So we're hoping to
bring in 3.3 Canary.

00:33:20.640 --> 00:33:21.640
It's going to be opt-in.

00:33:21.640 --> 00:33:24.690
Obviously some breaking changes.

00:33:24.690 --> 00:33:26.880
We're going to label
that with a flag.

00:33:26.880 --> 00:33:29.220
We're going to include
refactoring support in studio,

00:33:29.220 --> 00:33:30.969
so that you know all
those references will

00:33:30.969 --> 00:33:32.069
be changed for you.

00:33:32.069 --> 00:33:34.110
And we're going to want
a lot of feedback, right?

00:33:34.110 --> 00:33:37.020
It's not going to be turned
on in 3.3 Final by default.

00:33:37.020 --> 00:33:39.870
Either there's going to be
several revisions where there

00:33:39.870 --> 00:33:43.918
will be changes and improvement,
but we want a lot of feedback.

00:33:47.275 --> 00:33:49.150
JEROME DOCHEZ: OK, last
thing we want to talk

00:33:49.150 --> 00:33:51.970
about today is our public API.

00:33:51.970 --> 00:33:55.400
We are painfully aware that
the public API that we provide

00:33:55.400 --> 00:33:57.220
is not very good.

00:33:57.220 --> 00:33:59.980
It has very poor documentation.

00:33:59.980 --> 00:34:02.170
The plugin DSL is very bad.

00:34:02.170 --> 00:34:03.922
It's not specific
to the module type,

00:34:03.922 --> 00:34:05.380
so there's plenty
of things to kind

00:34:05.380 --> 00:34:10.120
of set in different modules,
yet the DSL is still there.

00:34:10.120 --> 00:34:12.400
There's no mechanism to
access the intermediate files.

00:34:12.400 --> 00:34:14.230
So some people would like to
have access to the [INAUDIBLE]

00:34:14.230 --> 00:34:16.690
manifest, class files,
dex files when they make,

00:34:16.690 --> 00:34:19.639
you can't really do
it in a nice way.

00:34:19.639 --> 00:34:23.662
The variant model doesn't give
access to a lot of information

00:34:23.662 --> 00:34:25.120
coming from the
variant properties.

00:34:25.120 --> 00:34:27.957
So you only have access to
part of the [? Truth. ?]

00:34:27.957 --> 00:34:30.040
And then there's just too
many things that require

00:34:30.040 --> 00:34:32.679
internal APIs, hacking tasks.

00:34:32.679 --> 00:34:35.570
The separation between
public and internal API

00:34:35.570 --> 00:34:37.000
is not well defined,
so you don't

00:34:37.000 --> 00:34:39.590
know when you're switching
from one to the other.

00:34:39.590 --> 00:34:41.949
So it's a mess.

00:34:41.949 --> 00:34:45.520
And to give you an example,
this is how the configuration

00:34:45.520 --> 00:34:46.330
works today, right?

00:34:46.330 --> 00:34:48.639
So we have the
DSL parsing first,

00:34:48.639 --> 00:34:51.850
and then we create
a variant, right?

00:34:51.850 --> 00:34:55.119
A bunch of variants are created
and we create all the tasks

00:34:55.119 --> 00:34:56.860
that go to those variants.

00:34:56.860 --> 00:34:58.570
And eventually we
call the variant API.

00:34:58.570 --> 00:35:01.570
So that's where a lot of
these customization scripts

00:35:01.570 --> 00:35:02.590
are running.

00:35:02.590 --> 00:35:04.810
But you can see here the
problem is right there.

00:35:04.810 --> 00:35:06.490
It's right in front of you.

00:35:06.490 --> 00:35:09.460
It's happening after the
tasks have been created.

00:35:09.460 --> 00:35:12.670
So there's no way you
can change anything that

00:35:12.670 --> 00:35:14.890
will influence tasks creation.

00:35:14.890 --> 00:35:16.740
Say you want to switch
from legacy multidex

00:35:16.740 --> 00:35:17.997
to native multidex?

00:35:17.997 --> 00:35:20.330
You don't do that anymore,
because we've already created

00:35:20.330 --> 00:35:23.560
the tasks for legacy multidex.

00:35:23.560 --> 00:35:26.740
Say you want to change some
of the information in the DSL

00:35:26.740 --> 00:35:29.146
programmatically instead
of putting it in the DSL?

00:35:29.146 --> 00:35:31.270
You can't really do that
either, because we already

00:35:31.270 --> 00:35:34.210
created the tasks and chances
are that the inputs have

00:35:34.210 --> 00:35:36.350
already been finalized.

00:35:36.350 --> 00:35:38.830
So it's happening
too late, and then

00:35:38.830 --> 00:35:40.320
eventually the
[INAUDIBLE] evaluate

00:35:40.320 --> 00:35:43.120
scripts, the custom
ones, run even later.

00:35:43.120 --> 00:35:45.980
So there's really no way you
can do a lot of things here.

00:35:45.980 --> 00:35:48.904
And so what people do is that
they access the tasks and then

00:35:48.904 --> 00:35:51.070
they try to figure out where
the files are generated

00:35:51.070 --> 00:35:53.350
and it's a mess.

00:35:53.350 --> 00:35:59.080
So what we would like to do
is to have a simple Gradle API

00:35:59.080 --> 00:36:02.050
interface that would be
the only module that you

00:36:02.050 --> 00:36:02.920
should depend on.

00:36:02.920 --> 00:36:05.650
And if you start depending
on some of our older modules

00:36:05.650 --> 00:36:07.780
like other call, you
should talk to us

00:36:07.780 --> 00:36:10.580
and you should tell us
what are your needs.

00:36:10.580 --> 00:36:12.910
Why are you doing this?

00:36:12.910 --> 00:36:14.530
Don't think that we
are not listening.

00:36:14.530 --> 00:36:16.450
We are interested
in figuring out

00:36:16.450 --> 00:36:18.290
why you need to
customize things,

00:36:18.290 --> 00:36:22.130
and we are interested in
providing you a good solution.

00:36:22.130 --> 00:36:24.460
So one of the things we
are looking for instance

00:36:24.460 --> 00:36:28.120
is to give you access to all
of the intermediate files.

00:36:28.120 --> 00:36:31.550
So each intermediate file really
is associated with a type,

00:36:31.550 --> 00:36:32.050
right?

00:36:32.050 --> 00:36:34.960
You've got classes, you've
got merged manifest,

00:36:34.960 --> 00:36:37.450
you've got dex files,
you've got resources.

00:36:37.450 --> 00:36:40.000
All of those should
be able to be accessed

00:36:40.000 --> 00:36:42.880
and should be safely
capable of being replaced.

00:36:42.880 --> 00:36:47.060
So you should be able to say,
give me the merged manifest,

00:36:47.060 --> 00:36:49.300
change it a little
bit, and I'm giving you

00:36:49.300 --> 00:36:50.500
back this new version.

00:36:50.500 --> 00:36:52.000
And that's the
one you should use

00:36:52.000 --> 00:36:54.050
to continue the build process.

00:36:54.050 --> 00:36:55.360
So it should be replaceable.

00:36:55.360 --> 00:36:56.560
It should be appendable.

00:36:56.560 --> 00:36:59.020
Maybe you want to add
class files directly.

00:36:59.020 --> 00:37:00.970
And eventually
all of this should

00:37:00.970 --> 00:37:04.030
be done through very
well-defined extension points.

00:37:04.030 --> 00:37:06.130
So we started working
on it, and we would

00:37:06.130 --> 00:37:08.955
like to have feedbacks on this.

00:37:08.955 --> 00:37:11.080
So the proposed phases
would be slightly different.

00:37:11.080 --> 00:37:13.120
Now you've got a DSL parsing.

00:37:13.120 --> 00:37:16.250
We would then start invoking
your custom code right there.

00:37:16.250 --> 00:37:17.890
So you would have
the ability to stop

00:37:17.890 --> 00:37:20.470
changing DSL objects
programmatically,

00:37:20.470 --> 00:37:23.710
even before we start
creating variants.

00:37:23.710 --> 00:37:25.720
Then we would lock them up.

00:37:25.720 --> 00:37:27.500
That means you can't
change them anymore.

00:37:27.500 --> 00:37:29.830
Once that code has
run, it's locked up.

00:37:29.830 --> 00:37:33.430
We would then create variants
from this information.

00:37:33.430 --> 00:37:37.270
From the variant we can then
code directly to variant API.

00:37:37.270 --> 00:37:40.570
So that's the ability
for you to change

00:37:40.570 --> 00:37:43.240
variant-related information.

00:37:43.240 --> 00:37:46.130
Now be aware that this is
happening now before the tasks

00:37:46.130 --> 00:37:46.960
creation, right?

00:37:46.960 --> 00:37:48.730
There's no tasks created yet.

00:37:48.730 --> 00:37:52.420
So this is really the ability
to say, it was using multidex,

00:37:52.420 --> 00:37:55.510
now I want it to
use legacy multidex.

00:37:55.510 --> 00:37:59.110
Once these scripts have
run, we will lock up

00:37:59.110 --> 00:38:00.980
the variant object.

00:38:00.980 --> 00:38:03.730
So again, if you use [INAUDIBLE]
scripts on like enough

00:38:03.730 --> 00:38:06.340
to evaluate, that starts
to change the DSL parsing

00:38:06.340 --> 00:38:08.100
of the variant, it's too late.

00:38:08.100 --> 00:38:11.290
We will not allow it
with one exception.

00:38:11.290 --> 00:38:13.280
Then eventually
we create the task

00:38:13.280 --> 00:38:15.010
and we will lock
them up immediately.

00:38:15.010 --> 00:38:17.686
We will not allow you to
modify the tasks anymore.

00:38:17.686 --> 00:38:19.060
The way to modify
things would be

00:38:19.060 --> 00:38:20.830
to go through the
buildable artifact,

00:38:20.830 --> 00:38:23.680
to inject, to
replace, to append,

00:38:23.680 --> 00:38:25.299
but not mucking with the tasks.

00:38:25.299 --> 00:38:26.840
Because we replace
them all the time.

00:38:26.840 --> 00:38:29.744
We merge them, we delete
them, we split them,

00:38:29.744 --> 00:38:31.660
whatever we need to do
to support new features

00:38:31.660 --> 00:38:33.881
or make things more efficient.

00:38:33.881 --> 00:38:35.880
And then eventually the
after evaluate will run.

00:38:38.920 --> 00:38:41.500
So the compatibility will
be a painful subject.

00:38:41.500 --> 00:38:45.470
We will try to make obviously
the DSL mostly unchanged.

00:38:45.470 --> 00:38:47.680
We're going to try to make
an effort to also becoming

00:38:47.680 --> 00:38:49.510
more Kotlin-friendly.

00:38:49.510 --> 00:38:52.240
And unfortunately we
think that the variant API

00:38:52.240 --> 00:38:53.350
will change heavily.

00:38:53.350 --> 00:38:55.970
But since we already realized
that it was not so great,

00:38:55.970 --> 00:38:58.660
hopefully you would be
sympathetic to the idea

00:38:58.660 --> 00:39:00.850
that you would have to
change the script using

00:39:00.850 --> 00:39:04.180
the variant API.

00:39:04.180 --> 00:39:06.430
So we want to hear from you.

00:39:06.430 --> 00:39:08.200
It's very important
that we get feedback

00:39:08.200 --> 00:39:09.830
from the community for us.

00:39:09.830 --> 00:39:12.210
And I want to thank
you for coming tonight.

00:39:12.210 --> 00:39:13.330
I know it's late session.

00:39:13.330 --> 00:39:15.830
It was very nice to see so
many people here tonight.

00:39:15.830 --> 00:39:16.476
Thank you.

00:39:16.476 --> 00:39:18.260
XAVIER DUCOY: Thank you.

00:39:18.260 --> 00:39:22.248
[MUSIC PLAYING]

