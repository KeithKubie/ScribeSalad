WEBVTT
Kind: captions
Language: en

00:00:01.100 --> 00:00:02.501
Lee: All right, thanks,
everyone, for coming.

00:00:02.501 --> 00:00:05.767
Um, first off,
my name's Bob Lee.

00:00:05.767 --> 00:00:09.000
And I'll be introducing you
to your speakers today.

00:00:09.000 --> 00:00:11.067
Before we get started,
I just want to remind you

00:00:11.067 --> 00:00:12.534
at the end of the session

00:00:12.534 --> 00:00:14.767
if you'd share your thoughts
and give us some feedback,

00:00:14.767 --> 00:00:17.534
we'd really appreciate it.

00:00:17.534 --> 00:00:20.567
Um, so I created Guice
about three years ago.

00:00:20.567 --> 00:00:23.501
And we open sourced it
two years ago.

00:00:23.501 --> 00:00:25.267
And it went on to win
the Jolt Award.

00:00:25.267 --> 00:00:30.701
And just last week,
we introduced Guice 2.

00:00:30.701 --> 00:00:33.467
And nowadays at Google,

00:00:33.467 --> 00:00:36.033
pretty much just about every
Java application

00:00:36.033 --> 00:00:38.501
also happens to be
a Guice application.

00:00:38.501 --> 00:00:40.000
And there are--
we found that they're

00:00:40.000 --> 00:00:43.100
a lot smaller and a lot more
maintainable for it.

00:00:43.100 --> 00:00:46.334
So our first speaker
is Dhanji.

00:00:46.334 --> 00:00:48.767
And Dhanji has been
working on Guice

00:00:48.767 --> 00:00:50.567
since before he even
came to Google.

00:00:50.567 --> 00:00:52.367
And he's responsible
for kind of our

00:00:52.367 --> 00:00:53.567
more Enterprise layer.

00:00:53.567 --> 00:00:55.767
You know, it integrates
Guice with servlets

00:00:55.767 --> 00:00:57.133
and whatnot.

00:00:57.133 --> 00:00:58.701
And Dhanji's also
written a book

00:00:58.701 --> 00:01:00.033
on dependency injection,

00:01:00.033 --> 00:01:01.767
which is heavily
focused on Guice,

00:01:01.767 --> 00:01:05.167
and I sure hope
he'll plug it in the talk.

00:01:05.167 --> 00:01:08.534
And Dhanji also works
on Google Wave,

00:01:08.534 --> 00:01:10.100
which you guys
learned about this morning,

00:01:10.100 --> 00:01:12.767
and, uh...

00:01:12.767 --> 00:01:14.467
which also happens to be
a Guice user.

00:01:14.467 --> 00:01:16.501
Next, we have Jesse Wilson.

00:01:16.501 --> 00:01:18.767
Uh, Jesse Wilson's
kind of the Guice star.

00:01:18.767 --> 00:01:22.200
He is responsible for--
"player."

00:01:22.200 --> 00:01:24.367
[laughing] He's responsible
for most of the development

00:01:24.367 --> 00:01:27.501
on Guice 2,
and he did an incredible job.

00:01:27.501 --> 00:01:29.767
Thanks.
Jesse: Cool.

00:01:29.767 --> 00:01:32.133
All right, uh...

00:01:32.133 --> 00:01:33.534
you've already got our names.

00:01:33.534 --> 00:01:37.300
Um, so I guess we should
get started.

00:01:37.300 --> 00:01:40.300
Uh, so we'll start out
by just saying

00:01:40.300 --> 00:01:41.734
what are you
expecting to get

00:01:41.734 --> 00:01:43.634
by sitting with us
for the next hour?

00:01:43.634 --> 00:01:46.467
Um, Guice is all about
dependency injection,

00:01:46.467 --> 00:01:48.767
and that is
the Hollywood principle.

00:01:48.767 --> 00:01:51.467
You know, don't call us,
we'll call you.

00:01:51.467 --> 00:01:53.300
So if you take
that principle

00:01:53.300 --> 00:01:56.467
and apply it to your
Java classes,

00:01:56.467 --> 00:01:59.133
Guice is sort of
what comes out of it.

00:01:59.133 --> 00:02:04.701
It's dependency injection
invented by Martin Fowler,

00:02:04.701 --> 00:02:07.167
and we'll just talk about
how Guice works

00:02:07.167 --> 00:02:08.734
and what you will--

00:02:08.734 --> 00:02:10.400
by applying Guice
to your application,

00:02:10.400 --> 00:02:13.300
you'll get more reusable code,
more modular code,

00:02:13.300 --> 00:02:14.667
more testable code,

00:02:14.667 --> 00:02:16.467
and you'll actually write
less code to do this.

00:02:16.467 --> 00:02:18.801
So...

00:02:18.801 --> 00:02:20.300
uh, do you want to do...

00:02:20.300 --> 00:02:22.167
Dhanji: Okay, so our talk
is split up

00:02:22.167 --> 00:02:23.334
into three parts.

00:02:23.334 --> 00:02:25.767
The Motivation,
Using Guice,

00:02:25.767 --> 00:02:27.434
and Leveraging Guice.

00:02:27.434 --> 00:02:30.534
So most of it's gonna
be introductory.

00:02:30.534 --> 00:02:32.400
We're gonna talk about
why we think

00:02:32.400 --> 00:02:34.234
you need
dependency injection

00:02:34.234 --> 00:02:36.701
or what the drawbacks are

00:02:36.701 --> 00:02:38.534
of not using
dependency injection.

00:02:38.534 --> 00:02:42.000
Uh, most applications,
sadly, even today

00:02:42.000 --> 00:02:43.767
don't make use of dependency
injection,

00:02:43.767 --> 00:02:46.467
and by that, I mean
the design pattern,

00:02:46.467 --> 00:02:47.767
not necessarily Guice

00:02:47.767 --> 00:02:50.033
or any of the other frameworks
that are out there.

00:02:50.033 --> 00:02:52.033
So it's important
to understand

00:02:52.033 --> 00:02:53.267
where we're coming from
when we say

00:02:53.267 --> 00:02:55.067
Guice makes your lives
easier

00:02:55.067 --> 00:02:57.000
by first looking
at how your lives

00:02:57.000 --> 00:02:58.100
are currently difficult.

00:02:58.100 --> 00:02:59.200
[Jesse laughs]

00:02:59.200 --> 00:03:00.767
Uh, so, and then we're
gonna talk about

00:03:00.767 --> 00:03:02.567
the API itself,

00:03:02.567 --> 00:03:04.100
what @Inject means.

00:03:04.100 --> 00:03:07.467
How @Inject replaces
your factory code.

00:03:07.467 --> 00:03:09.567
And, uh, and then finally
we'll take a look

00:03:09.567 --> 00:03:11.400
at the ecosystem

00:03:11.400 --> 00:03:12.734
and we'll spend some time
looking at

00:03:12.734 --> 00:03:14.767
all the extensions
that people have built

00:03:14.767 --> 00:03:18.767
around Guice that make
your lives really easy.

00:03:18.767 --> 00:03:22.200
Jesse: Okay, so we're gonna
write a Twitter client.

00:03:22.200 --> 00:03:23.334
Um, Twitter is taking
the world by storm,

00:03:23.334 --> 00:03:24.667
including Google.

00:03:24.667 --> 00:03:27.767
And so just to demo
the code that you might write,

00:03:27.767 --> 00:03:29.467
we'll use Twitter
as our example.

00:03:29.467 --> 00:03:30.767
We'll start by writing
some code

00:03:30.767 --> 00:03:32.033
using the factory pattern,

00:03:32.033 --> 00:03:34.267
and we'll show
all the drawbacks.

00:03:34.267 --> 00:03:36.267
And then we'll move to Guice
and show what happens

00:03:36.267 --> 00:03:37.634
and how your code changes.

00:03:37.634 --> 00:03:39.501
So hopefully, the code
that you're looking at

00:03:39.501 --> 00:03:41.868
will be familiar,
and you can see, you know,

00:03:41.868 --> 00:03:43.767
"Oh, that's code I would have
written," or something.

00:03:43.767 --> 00:03:46.100
And then we'll show
how your code would change

00:03:46.100 --> 00:03:47.534
if you were to use
dependency injection,

00:03:47.534 --> 00:03:51.133
and then if you were to use
dependency injection and Guice.

00:03:51.133 --> 00:03:53.000
So here's some code
you might write.

00:03:53.000 --> 00:03:56.767
This is the ClickHandler
for a--

00:03:56.767 --> 00:03:58.534
the post button on
a Twitter client.

00:03:58.534 --> 00:04:00.701
And so the idea is
is that

00:04:00.701 --> 00:04:02.400
when somebody clicks "post,"

00:04:02.400 --> 00:04:04.133
we pull the text
out of the text field,

00:04:04.133 --> 00:04:05.601
see if it's too long.

00:04:05.601 --> 00:04:07.300
If it's too long,
we try to shorten it

00:04:07.300 --> 00:04:09.767
using TinyURL shortener.

00:04:09.767 --> 00:04:11.567
And then we tweet it off,

00:04:11.567 --> 00:04:14.200
and we're using SMS
as our transport

00:04:14.200 --> 00:04:16.767
to send our tweet
to Twitter servers.

00:04:16.767 --> 00:04:19.701
So you may have noticed
that the code

00:04:19.701 --> 00:04:21.167
in this example

00:04:21.167 --> 00:04:24.067
actually builds
its dependencies immediately.

00:04:24.067 --> 00:04:27.167
So we say
new TinyUrl.Shortener

00:04:27.167 --> 00:04:28.767
and new SmsTweeter.

00:04:28.767 --> 00:04:31.334
And this is--
this is really convenient

00:04:31.334 --> 00:04:32.501
and it's really terse

00:04:32.501 --> 00:04:33.834
but there's a lot
of problems with it.

00:04:33.834 --> 00:04:36.567
Most notably, this code
doesn't lend itself to testing.

00:04:36.567 --> 00:04:39.467
Um, we can't run this code
and say,

00:04:39.467 --> 00:04:40.601
"I'm gonna write a test

00:04:40.601 --> 00:04:41.667
to make sure
everything's working,"

00:04:41.667 --> 00:04:43.767
because every time
you run that test

00:04:43.767 --> 00:04:45.767
you're actually gonna end up
doing an SMS.

00:04:45.767 --> 00:04:47.601
So that means that you have
to have a device

00:04:47.601 --> 00:04:50.067
that has an SMS
to run the code on,

00:04:50.067 --> 00:04:51.767
and you have to pay the SMS
bill at the end of the month

00:04:51.767 --> 00:04:53.100
if you do that.

00:04:53.100 --> 00:04:54.767
And also, you're also
sort of at the mercy

00:04:54.767 --> 00:04:57.767
of whether or not
Tiny URL is working today.

00:04:57.767 --> 00:04:58.834
Dhanji: And it
doesn't really help

00:04:58.834 --> 00:05:00.767
with testing automation.

00:05:00.767 --> 00:05:03.000
Jesse: Yeah.

00:05:03.000 --> 00:05:05.767
So tell us
what factories are, Dhanji.

00:05:05.767 --> 00:05:07.601
Dhanji: Okay,
so the traditional solution

00:05:07.601 --> 00:05:09.567
to that problem
has been factories.

00:05:09.567 --> 00:05:11.767
So a factory
is a third-party object

00:05:11.767 --> 00:05:15.267
it's just--it's another
class that we've written--

00:05:15.267 --> 00:05:19.067
that separates
the post button clicked method

00:05:19.067 --> 00:05:20.267
and the class
that it contains

00:05:20.267 --> 00:05:22.767
from the actual services
that it requires.

00:05:22.767 --> 00:05:25.334
So here, we don't have
a direct dependency.

00:05:25.334 --> 00:05:27.033
We have
an indirect dependency.

00:05:27.033 --> 00:05:30.133
So the shortener is now
not necessarily

00:05:30.133 --> 00:05:31.634
a tiny URL shortener.

00:05:31.634 --> 00:05:34.133
It's just something we get
from the shortener factory.

00:05:34.133 --> 00:05:36.334
And similarly,
for the tweeter factory.

00:05:36.334 --> 00:05:38.400
All right?

00:05:38.400 --> 00:05:40.501
Now, the factory itself

00:05:40.501 --> 00:05:43.634
is directly dependent
on the SMS tweeter,

00:05:43.634 --> 00:05:44.734
for instance.

00:05:44.734 --> 00:05:46.667
Uh, so in this case,
what we've done

00:05:46.667 --> 00:05:48.667
is we've taken
that hard dependency

00:05:48.667 --> 00:05:52.267
that we had between
the post button handler

00:05:52.267 --> 00:05:54.767
and the actual services
that we want,

00:05:54.767 --> 00:05:57.767
and we've inserted
one layer of abstraction

00:05:57.767 --> 00:05:58.868
in between.

00:05:58.868 --> 00:06:01.534
It helps us, but not quite.

00:06:01.534 --> 00:06:03.234
Let's see why not.

00:06:03.234 --> 00:06:04.767
Jesse: So immediately,
one problem is

00:06:04.767 --> 00:06:06.434
you have to actually write
this factory class.

00:06:06.434 --> 00:06:08.434
And so, if you have
a whole bunch of classes,

00:06:08.434 --> 00:06:10.167
that means you have to write
a whole bunch of factories.

00:06:10.167 --> 00:06:11.300
And this is code
that slows you down.

00:06:11.300 --> 00:06:12.767
It's not very interesting.

00:06:12.767 --> 00:06:16.200
Uh, it's another thing that
you have to version control

00:06:16.200 --> 00:06:18.300
and code review,
and it's just more code

00:06:18.300 --> 00:06:20.067
that doesn't actually
get you anywhere

00:06:20.067 --> 00:06:22.767
in writing tweet--
Twitter clients.

00:06:22.767 --> 00:06:25.767
So, uh,
as Dhanji alluded to,

00:06:25.767 --> 00:06:28.267
the factory adds
an interaction layer

00:06:28.267 --> 00:06:30.701
between the Tweet client
and the SMS twit--tweeter

00:06:30.701 --> 00:06:33.367
that is actually going to be
doing the implementation for us.

00:06:33.367 --> 00:06:35.767
But, unfortunately,
the dependency is still there,

00:06:35.767 --> 00:06:37.267
indirectly.

00:06:37.267 --> 00:06:39.467
And so what happens is
when we write applications

00:06:39.467 --> 00:06:41.033
in this style,

00:06:41.033 --> 00:06:42.400
anything that you depend on

00:06:42.400 --> 00:06:44.400
you need to compile
at the same time.

00:06:44.400 --> 00:06:47.000
So you've got this
compilation time dependency,

00:06:47.000 --> 00:06:48.267
and what ends up happening

00:06:48.267 --> 00:06:50.601
is you have to build
your entire application

00:06:50.601 --> 00:06:52.767
any time you want to build
any part of your application.

00:06:52.767 --> 00:06:54.667
Your application
isn't very modular.

00:06:54.667 --> 00:06:57.634
And so if we take this
to the logical extreme,

00:06:57.634 --> 00:06:59.200
what happens
is your application blows up

00:06:59.200 --> 00:07:01.367
in a firestorm of pain
and dependencies

00:07:01.367 --> 00:07:05.501
because now everything
depends on everything.

00:07:05.501 --> 00:07:07.767
So the other problem
with the factory

00:07:07.767 --> 00:07:09.000
is it's awkward to test.

00:07:09.000 --> 00:07:11.701
So I was writing a test
for our tweeter client,

00:07:11.701 --> 00:07:12.767
and I wrote this.

00:07:12.767 --> 00:07:15.501
And so I set up,
uh, a mock tweeter,

00:07:15.501 --> 00:07:17.634
which lets me intercept
the text that gets tweeted.

00:07:17.634 --> 00:07:19.167
Instead of sending it to SMS,

00:07:19.167 --> 00:07:21.234
I can actually just take
an in-memory object

00:07:21.234 --> 00:07:22.234
and get the tweet from there.

00:07:22.234 --> 00:07:24.767
So I wrote this test.

00:07:24.767 --> 00:07:27.767
Dhanji: Well, that's a good
start that you have there.

00:07:27.767 --> 00:07:30.100
So you're using
a special mock tweeter

00:07:30.100 --> 00:07:31.133
in your factory.

00:07:31.133 --> 00:07:32.234
So now, when you call "get,"

00:07:32.234 --> 00:07:35.033
it's gonna get
the mock instance.

00:07:35.033 --> 00:07:36.767
But I'm not quite
satisfied with this.

00:07:36.767 --> 00:07:38.534
Can you tell me
what's wrong?

00:07:38.534 --> 00:07:40.767
Jesse: So the problem is that

00:07:40.767 --> 00:07:42.367
when I'm using
this mock tweeter,

00:07:42.367 --> 00:07:43.767
my test is gonna run,

00:07:43.767 --> 00:07:45.000
we're gonna click
the post button,

00:07:45.000 --> 00:07:46.400
we're gonna get the text
out of the tweet--

00:07:46.400 --> 00:07:47.767
out of the mock tweeter
at the very end

00:07:47.767 --> 00:07:49.267
on this last line.

00:07:49.267 --> 00:07:51.767
But the problem is
is that, now,

00:07:51.767 --> 00:07:53.434
I've left
my mock tweeter behind.

00:07:53.434 --> 00:07:55.167
I forgot to clean up
after myself.

00:07:55.167 --> 00:07:57.200
Fortunately,
there's an easy fix,

00:07:57.200 --> 00:07:59.667
and that is that you have
to actually add code

00:07:59.667 --> 00:08:01.434
to tear down the mock tweeter
at the end.

00:08:01.434 --> 00:08:03.534
So whenever you write
this factory pattern,

00:08:03.534 --> 00:08:04.801
you don't even need to worry

00:08:04.801 --> 00:08:06.167
about just setting up
your mocks

00:08:06.167 --> 00:08:08.267
and getting your tests--
your application testable,

00:08:08.267 --> 00:08:09.467
you have to also worry

00:08:09.467 --> 00:08:11.367
about tearing everything down
afterwards.

00:08:11.367 --> 00:08:14.601
Dhanji: This is a lot better,
but it's still not perfect.

00:08:14.601 --> 00:08:16.033
Jesse: Oh, okay.

00:08:16.033 --> 00:08:17.200
So...it turns out

00:08:17.200 --> 00:08:18.501
that this still
isn't sufficient

00:08:18.501 --> 00:08:19.767
to test with factories

00:08:19.767 --> 00:08:21.100
because you still
need to worry about

00:08:21.100 --> 00:08:23.467
the case where,
if my test fails,

00:08:23.467 --> 00:08:25.100
it'll throw in
the assert method

00:08:25.100 --> 00:08:27.033
and it won't actually
get to tear down my fac--

00:08:27.033 --> 00:08:28.834
tear down my mock tweeter.

00:08:28.834 --> 00:08:30.067
So you actually need
to put it

00:08:30.067 --> 00:08:31.400
try finally clause.

00:08:31.400 --> 00:08:32.734
This is really ugly code.

00:08:32.734 --> 00:08:34.367
You don't want to see it
in your application.

00:08:34.367 --> 00:08:36.300
It adds another layer
of control flow

00:08:36.300 --> 00:08:37.767
that you don't really
have to think about.

00:08:37.767 --> 00:08:39.400
And we haven't even gotten
to the point

00:08:39.400 --> 00:08:43.200
of setting up
the TinyURL mock yet, so...

00:08:43.200 --> 00:08:46.200
Dhanji: So you guys see
it's not just your factories

00:08:46.200 --> 00:08:48.467
that get polluted with
all this extra code

00:08:48.467 --> 00:08:50.601
in order to enable testing.

00:08:50.601 --> 00:08:52.400
But even your tests
are polluted

00:08:52.400 --> 00:08:54.567
with all this extra code
in order to enable testing.

00:08:54.567 --> 00:08:55.834
Jesse: Yeah, yeah.

00:08:55.834 --> 00:08:57.567
Uh...the problem is
is that

00:08:57.567 --> 00:09:00.234
when testing becomes
this complicated,

00:09:00.234 --> 00:09:02.033
you just don't want
to write any tests.

00:09:02.033 --> 00:09:03.367
And if you don't write tests,

00:09:03.367 --> 00:09:04.601
you don't have confidence
in your application,

00:09:04.601 --> 00:09:06.267
and you don't
get to ship Wave on time.

00:09:06.267 --> 00:09:08.767
So, uh, Dependency Injection
by hand.

00:09:08.767 --> 00:09:11.667
And Dependency Injection
is sort of

00:09:11.667 --> 00:09:13.334
a technology
or design pattern

00:09:13.334 --> 00:09:16.133
that addresses this problem
very delicately.

00:09:16.133 --> 00:09:19.167
So the principle is
instead of saying,

00:09:19.167 --> 00:09:21.434
"Hey, shortener factory,
give me a shortener;

00:09:21.434 --> 00:09:23.000
hey, tweeter factory,
give me a tweeter,"

00:09:23.000 --> 00:09:24.534
we pass those in.

00:09:24.534 --> 00:09:26.501
So here's the constructive
for TweetClient.

00:09:26.501 --> 00:09:29.033
And it actually takes
a shortener and a tweeter.

00:09:29.033 --> 00:09:31.434
And now it's the caller's
responsibility to decide

00:09:31.434 --> 00:09:33.501
which implementations
to use.

00:09:33.501 --> 00:09:35.767
This is this Hollywood
principle again.

00:09:35.767 --> 00:09:37.300
We'll call you
with your dependencies.

00:09:37.300 --> 00:09:40.400
Don't ask for them.
They'll just be passed in.

00:09:40.400 --> 00:09:42.567
And what's absolutely
brilliant about this

00:09:42.567 --> 00:09:44.400
is that now we don't need
to worry about

00:09:44.400 --> 00:09:46.767
passing in real dependencies
in our, uh,

00:09:46.767 --> 00:09:47.767
we don't
have to worry about

00:09:47.767 --> 00:09:49.767
setting up teardown
in our test.

00:09:49.767 --> 00:09:51.467
And since we're passing them
into the constructer

00:09:51.467 --> 00:09:52.701
of TweetClient here--

00:09:52.701 --> 00:09:54.000
so I say new TweetClient,

00:09:54.000 --> 00:09:55.767
and I pass in the dependencies
I want to use--

00:09:55.767 --> 00:09:58.601
not only do I have to not
worry about tearing it down,

00:09:58.601 --> 00:10:01.601
but I also don't have to worry
about forgetting something.

00:10:01.601 --> 00:10:03.767
So you may have written
applications where,

00:10:03.767 --> 00:10:05.567
you know, you get your test,
you get everything compiled,

00:10:05.567 --> 00:10:06.767
and you run your test,

00:10:06.767 --> 00:10:08.434
and then at runtime
it fails immediately

00:10:08.434 --> 00:10:11.267
because you forgot
to prepare some factory.

00:10:11.267 --> 00:10:13.234
You know, you forgot
to initialize something

00:10:13.234 --> 00:10:15.100
or get something started up.

00:10:15.100 --> 00:10:17.667
And so now your application
gets this sort of gross,

00:10:17.667 --> 00:10:19.234
bootstrap system where

00:10:19.234 --> 00:10:20.767
in order to actually
write a test,

00:10:20.767 --> 00:10:22.534
you need to, you know,
start the service,

00:10:22.534 --> 00:10:24.767
connect to the database,
do this, the other thing,

00:10:24.767 --> 00:10:26.501
test that the SMS radio
is turned on,

00:10:26.501 --> 00:10:27.534
and now we can test.

00:10:27.534 --> 00:10:29.234
Well,
with dependency injection,

00:10:29.234 --> 00:10:31.000
your dependencies
are obvious

00:10:31.000 --> 00:10:34.767
and they're part
of your API.

00:10:34.767 --> 00:10:39.367
But this is where dependency
injection breaks down.

00:10:39.367 --> 00:10:43.200
Okay, so what we have here
is a client factory,

00:10:43.200 --> 00:10:45.734
and it does all of the work
of providing

00:10:45.734 --> 00:10:48.534
the dependencies
to our object.

00:10:48.534 --> 00:10:50.601
But we've just moved it
one step further.

00:10:50.601 --> 00:10:52.501
We had the tweeter factory

00:10:52.501 --> 00:10:53.868
and we had
the shortener factory.

00:10:53.868 --> 00:10:57.000
Uh, but now we've, like,
pushed it one step further

00:10:57.000 --> 00:10:59.267
in order to make
our tweet client

00:10:59.267 --> 00:11:00.968
dependency injectable.

00:11:00.968 --> 00:11:02.767
So, I mean,
we've saved a little,

00:11:02.767 --> 00:11:05.167
but we've still got our
factory code

00:11:05.167 --> 00:11:06.534
to write and maintain,

00:11:06.534 --> 00:11:07.701
and it still looks ugly,

00:11:07.701 --> 00:11:10.501
and there's still
the same problem.

00:11:10.501 --> 00:11:12.000
It's just one step removed.

00:11:12.000 --> 00:11:15.434
So the idea of all
this dependency injection

00:11:15.434 --> 00:11:17.400
is we've broken
this hard dependency

00:11:17.400 --> 00:11:20.734
from tweet client onto
its TinyURL shortener

00:11:20.734 --> 00:11:22.334
and SMS tweeter,

00:11:22.334 --> 00:11:25.200
and by moving it, we only
depend on the interfaces,

00:11:25.200 --> 00:11:26.501
which is just fantastic.

00:11:26.501 --> 00:11:29.334
It means we can compile and test
and do all these things.

00:11:29.334 --> 00:11:32.133
But we've really just
shifted the dependency

00:11:32.133 --> 00:11:34.200
over to our tweet clients
in our factories,

00:11:34.200 --> 00:11:36.033
and we just had to write
a lot of factories

00:11:36.033 --> 00:11:37.200
to get this done, right?

00:11:37.200 --> 00:11:38.767
There's--there's
three factors here.

00:11:38.767 --> 00:11:40.734
That's a lot of code
that you have to write.

00:11:40.734 --> 00:11:43.501
And so we have to have
something else.

00:11:43.501 --> 00:11:44.934
There's got to be
something better.

00:11:44.934 --> 00:11:47.267
And that something is Guice.

00:11:47.267 --> 00:11:49.767
So with Guice,
you take your factories

00:11:49.767 --> 00:11:51.767
and you replace them

00:11:51.767 --> 00:11:54.367
with a combination
of injectors and modules.

00:11:54.367 --> 00:11:57.400
And so instead of writing
all about

00:11:57.400 --> 00:11:58.801
imperative code
to figure out

00:11:58.801 --> 00:12:01.367
how to build an SMS tweeter,
and, uh,

00:12:01.367 --> 00:12:03.133
an URL shortener,

00:12:03.133 --> 00:12:04.267
instead, you create a module,

00:12:04.267 --> 00:12:06.667
and this maps
the implementations,

00:12:06.667 --> 00:12:08.334
the interfaces
to their implementations.

00:12:08.334 --> 00:12:10.767
And injector
is a Guice-applied class

00:12:10.767 --> 00:12:13.601
that basically acts
as your factory,

00:12:13.601 --> 00:12:15.434
and it's one-stop-does-
everything factory

00:12:15.434 --> 00:12:16.801
for your application,

00:12:16.801 --> 00:12:20.334
and it does it in
a dependency injection idiom.

00:12:20.334 --> 00:12:21.701
Dhanji:
And, more importantly,

00:12:21.701 --> 00:12:23.534
it's a factory
that you don't have to write

00:12:23.534 --> 00:12:25.367
and you never
have to maintain.

00:12:25.367 --> 00:12:26.868
Jesse: Yeah, yeah.

00:12:26.868 --> 00:12:29.968
All right, so now can
configure our dependencies

00:12:29.968 --> 00:12:31.634
using a module.

00:12:31.634 --> 00:12:33.567
And so, instead of writing
that 12 lines of factory

00:12:33.567 --> 00:12:35.767
for tweeter and 12 lines
of factory for shortener

00:12:35.767 --> 00:12:37.767
and 12 lines of factory
for everything else,

00:12:37.767 --> 00:12:40.267
instead,
we have one statement

00:12:40.267 --> 00:12:43.100
which is bind interface
to implementation.

00:12:43.100 --> 00:12:44.767
And this is how
you configure Guice,

00:12:44.767 --> 00:12:49.200
and that creates an injector
that works the way you'd like.

00:12:49.200 --> 00:12:52.133
So the change
to the client code

00:12:52.133 --> 00:12:54.234
is you add
the inject annotation,

00:12:54.234 --> 00:12:56.767
and that just is a signal
to Guice to say

00:12:56.767 --> 00:12:59.501
whenever somebody
wants to factory construct

00:12:59.501 --> 00:13:01.100
a tweet client,

00:13:01.100 --> 00:13:04.300
call this constructor,
so...

00:13:04.300 --> 00:13:06.701
Dhanji: So it's--we've
taken that entire factory

00:13:06.701 --> 00:13:08.767
with all
of that boilerplate code

00:13:08.767 --> 00:13:11.434
and that testing code
that accompanied it,

00:13:11.434 --> 00:13:14.434
and shortened it to the one
little @Inject annotation

00:13:14.434 --> 00:13:15.734
that you see there.

00:13:15.734 --> 00:13:16.934
And that's all Guice needs

00:13:16.934 --> 00:13:18.767
in order to be able
to provide this class

00:13:18.767 --> 00:13:20.701
with its dependencies.

00:13:20.701 --> 00:13:22.267
Now, that's a great saving.

00:13:22.267 --> 00:13:23.667
Jesse: [whispering]
Yeah, yeah!

00:13:23.667 --> 00:13:26.634
Especially since
it's such a savings encode,

00:13:26.634 --> 00:13:27.968
you'll actually
tend to do it.

00:13:27.968 --> 00:13:30.067
And we believe that when
you use dependency injection,

00:13:30.067 --> 00:13:31.400
you'll write better codes.

00:13:31.400 --> 00:13:32.634
You'll write better code,
more testable code,

00:13:32.634 --> 00:13:33.934
more modular code.

00:13:33.934 --> 00:13:36.534
Um, here are the four lines
of code that you need

00:13:36.534 --> 00:13:38.234
to bootstrap Guice.

00:13:38.234 --> 00:13:40.033
Uh, you need to create
an injector

00:13:40.033 --> 00:13:43.367
with your module
or your list of modules.

00:13:43.367 --> 00:13:44.767
Then you can
use that injector

00:13:44.767 --> 00:13:46.100
to get an instance
of something.

00:13:46.100 --> 00:13:49.234
So this is just like
your factory used to do.

00:13:49.234 --> 00:13:51.701
Now you can say, "Hey, injector,
give me a tweet client,"

00:13:51.701 --> 00:13:54.767
and it's parameterized on
what you want it to construct.

00:13:54.767 --> 00:13:56.501
And it's fully type-safe.

00:13:56.501 --> 00:13:58.267
So if you've ever used

00:13:58.267 --> 00:14:00.100
Spring dependency
injection tools,

00:14:00.100 --> 00:14:02.667
then you'll notice that
it's not type-safe,

00:14:02.667 --> 00:14:03.767
and you'll to do
a lot of casting

00:14:03.767 --> 00:14:05.734
and you need to do
a little finger crossing

00:14:05.734 --> 00:14:07.567
to make sure that what
you ask the injector for

00:14:07.567 --> 00:14:08.701
is what you get.

00:14:08.701 --> 00:14:10.100
With Guice,
it's fully type-safe.

00:14:10.100 --> 00:14:12.767
The type that you pass in
is the type it will return.

00:14:12.767 --> 00:14:15.434
And if it's not there,
it'll blow up spectacularly

00:14:15.434 --> 00:14:19.200
and tell you all of the details
of what went wrong.

00:14:19.200 --> 00:14:22.767
So that's
the motivation for Guice.

00:14:22.767 --> 00:14:24.634
And now we're gonna just
dive into

00:14:24.634 --> 00:14:27.367
all of the minutiae
of the Guice API

00:14:27.367 --> 00:14:28.767
and explain how you use it,

00:14:28.767 --> 00:14:32.701
what the day-to-day life
of Guice development is like.

00:14:32.701 --> 00:14:35.767
So why?

00:14:35.767 --> 00:14:38.767
Dhanji: Okay, so we've already
said that boilerplate code

00:14:38.767 --> 00:14:42.400
is messy and it's difficult
to test and maintain.

00:14:42.400 --> 00:14:44.467
And it's just
nothing that, uh, we--

00:14:44.467 --> 00:14:47.400
as a developer, you want
to spend your time doing.

00:14:47.400 --> 00:14:49.767
But there are also
other reasons to use Guice.

00:14:49.767 --> 00:14:52.701
Like Jesse said,
there's a lot of type safety

00:14:52.701 --> 00:14:54.300
that you gain from Guice.

00:14:54.300 --> 00:14:56.434
And this is because
when you tell Guice,

00:14:56.434 --> 00:14:58.767
when you give it
that bind statement,

00:14:58.767 --> 00:15:00.267
that's actually
a signal to Guice

00:15:00.267 --> 00:15:02.534
to go out there
and look at that class

00:15:02.534 --> 00:15:04.501
and make sure that
all the dependencies

00:15:04.501 --> 00:15:06.467
for that class
are also available,

00:15:06.467 --> 00:15:09.567
and that's valid in a way
in which

00:15:09.567 --> 00:15:11.667
it can construct it
at runtime for you.

00:15:11.667 --> 00:15:13.100
And that's--
that's really useful.

00:15:13.100 --> 00:15:14.601
More often than not,
you'll find

00:15:14.601 --> 00:15:17.767
that fixing one small error
by hand in a factory

00:15:17.767 --> 00:15:20.200
and then recompiling--

00:15:20.200 --> 00:15:21.734
you go a bit further
down the line,

00:15:21.734 --> 00:15:22.868
you find another error,

00:15:22.868 --> 00:15:24.767
but Guice does
all of this type checking

00:15:24.767 --> 00:15:26.133
upfront for you

00:15:26.133 --> 00:15:27.767
and gives you
a long error list

00:15:27.767 --> 00:15:30.634
the first time
you deploy it.

00:15:30.634 --> 00:15:32.767
Jesse: It gives you
JavaC-style errors

00:15:32.767 --> 00:15:34.267
that you can even click on

00:15:34.267 --> 00:15:35.501
and navigate
right in your code

00:15:35.501 --> 00:15:37.467
to the bind statement
that didn't work.

00:15:37.467 --> 00:15:39.701
Um, in addition,
when you use Guice--

00:15:39.701 --> 00:15:42.100
this is really
the real value of Guice,

00:15:42.100 --> 00:15:46.367
and this is growing
as our community matures.

00:15:46.367 --> 00:15:49.534
You get scopes, which is
an absolutely humungous,

00:15:49.534 --> 00:15:50.701
cool feature.

00:15:50.701 --> 00:15:53.067
You get aspect-oriented
programming,

00:15:53.067 --> 00:15:55.133
which is something
that you may like.

00:15:55.133 --> 00:15:56.767
It turns out to be
very, very convenient

00:15:56.767 --> 00:15:58.400
in your larger,

00:15:58.400 --> 00:15:59.734
Enterprisey-style
applications,

00:15:59.734 --> 00:16:01.667
as well as any application
where you have

00:16:01.667 --> 00:16:02.767
cross-cutting concerns.

00:16:02.767 --> 00:16:04.467
And there's
tight integration

00:16:04.467 --> 00:16:06.300
with a whole bunch
of different APIs

00:16:06.300 --> 00:16:07.734
that you already
are using,

00:16:07.734 --> 00:16:10.267
such as servlets
and databases

00:16:10.267 --> 00:16:12.901
and RPC systems, et cetera.

00:16:12.901 --> 00:16:14.767
Oh! And, uh--

00:16:14.767 --> 00:16:16.467
Dhanji: Google Wave.

00:16:16.467 --> 00:16:18.701
Jesse: If all these technical
reasons weren't enough,

00:16:18.701 --> 00:16:20.234
well, Wave uses Guice,

00:16:20.234 --> 00:16:22.701
so why aren't you, right?

00:16:22.701 --> 00:16:26.100
All right,
so in a nutshell,

00:16:26.100 --> 00:16:29.033
classes have dependencies.

00:16:29.033 --> 00:16:30.334
And modules define

00:16:30.334 --> 00:16:31.734
how these dependencies
are resolved.

00:16:31.734 --> 00:16:34.067
This is the--this
is the whole concept, right?

00:16:34.067 --> 00:16:36.400
You have code,
it has dependencies.

00:16:36.400 --> 00:16:38.033
Today, you use factories,

00:16:38.033 --> 00:16:40.100
And with Guice,
it's the same thing.

00:16:40.100 --> 00:16:41.567
You have dependencies.

00:16:41.567 --> 00:16:43.434
And then you configure it
with Guice.

00:16:43.434 --> 00:16:44.767
You configure
your dependencies

00:16:44.767 --> 00:16:46.767
and the resolution
using modules.

00:16:46.767 --> 00:16:50.467
So let's investigate
that, uh, module resolution.

00:16:50.467 --> 00:16:53.767
And that's called a binding.

00:16:53.767 --> 00:16:55.701
Dhanji: Okay, so--

00:16:55.701 --> 00:16:57.000
Jesse: I'll go.
Dhanji: You want to do it?

00:16:57.000 --> 00:16:59.033
Jesse: All right,
so we've got a module

00:16:59.033 --> 00:17:00.601
with four bindings here.

00:17:00.601 --> 00:17:02.767
Uh, there are the three
statements in the code,

00:17:02.767 --> 00:17:05.234
the bind tweak line--
the bind tweeter,

00:17:05.234 --> 00:17:06.634
bind string,
those lines.

00:17:06.634 --> 00:17:10.100
And then method that has
@Provides annotation.

00:17:10.100 --> 00:17:11.767
And so these
are four bindings

00:17:11.767 --> 00:17:12.767
and we'll go into detail

00:17:12.767 --> 00:17:15.601
and explain how
each of them works.

00:17:15.601 --> 00:17:16.767
All right, so...

00:17:16.767 --> 00:17:18.767
Dhanji: [laughs]

00:17:18.767 --> 00:17:21.400
Okay, so this
is a simple bind statement.

00:17:21.400 --> 00:17:24.434
All this says
is it tells Guice

00:17:24.434 --> 00:17:27.701
to look in that class
and use it any time

00:17:27.701 --> 00:17:30.701
it appears as a dependency
in any other code

00:17:30.701 --> 00:17:32.033
that you have.

00:17:32.033 --> 00:17:34.767
So what you need to do
in the tweet client

00:17:34.767 --> 00:17:37.267
is place an @Inject
annotation,

00:17:37.267 --> 00:17:38.634
like we saw just earlier,

00:17:38.634 --> 00:17:40.767
on the constructor
that you want to use,

00:17:40.767 --> 00:17:43.167
and all the dependencies
of that constructor

00:17:43.167 --> 00:17:46.300
will be filled in
for you by Guice.

00:17:46.300 --> 00:17:48.200
Jesse: So, uh...

00:17:48.200 --> 00:17:51.300
Whoops, this one.

00:17:51.300 --> 00:17:53.100
All right, so the next
type of binding

00:17:53.100 --> 00:17:54.267
is called a provider method,

00:17:54.267 --> 00:17:55.567
and this is really,
really handy,

00:17:55.567 --> 00:17:57.100
and its new
in Guice version 2,

00:17:57.100 --> 00:17:58.767
which we released last week.

00:17:58.767 --> 00:18:01.534
So a provider method is

00:18:01.534 --> 00:18:04.400
whenever somebody
asks me for this type,

00:18:04.400 --> 00:18:05.801
run this little bit of code

00:18:05.801 --> 00:18:07.767
in order to calculate it
or to compute it

00:18:07.767 --> 00:18:09.767
or to fetch it
or to construct it.

00:18:09.767 --> 00:18:12.667
So this sort of is your
traditional factory method

00:18:12.667 --> 00:18:15.634
type of operation where
you can create something,

00:18:15.634 --> 00:18:17.334
configure it,
and then return it.

00:18:17.334 --> 00:18:19.334
And the way you do
a provider method binding

00:18:19.334 --> 00:18:22.133
is somewhere
in your module class

00:18:22.133 --> 00:18:25.267
you have a method with
the @Provides annotation

00:18:25.267 --> 00:18:27.200
and the return type
that you'd like to bind.

00:18:27.200 --> 00:18:29.100
So in this case, we say,

00:18:29.100 --> 00:18:30.601
@Provides Shortener,

00:18:30.601 --> 00:18:33.701
which says this method
is a binding for Shortener,

00:18:33.701 --> 00:18:36.100
and then whenever Guice
needs to inject

00:18:36.100 --> 00:18:37.667
a shortener or to find
a shortener

00:18:37.667 --> 00:18:39.067
for somebody else's
dependency,

00:18:39.067 --> 00:18:40.601
it will run this code.

00:18:40.601 --> 00:18:42.767
And what's really handy
about provider methods

00:18:42.767 --> 00:18:45.534
is that they can have
dependencies of their own.

00:18:45.534 --> 00:18:47.501
So if you want to provide
a shortener

00:18:47.501 --> 00:18:50.400
and it has a dependency
on some HTP factory

00:18:50.400 --> 00:18:51.601
or something like that,

00:18:51.601 --> 00:18:53.367
you can pass
that dependency in

00:18:53.367 --> 00:18:55.000
via the parameter
of the method.

00:18:55.000 --> 00:18:58.000
So not only can
your classes have methods,

00:18:58.000 --> 00:19:01.000
but your providers--your
provider methods themselves

00:19:01.000 --> 00:19:02.067
can have dependencies,

00:19:02.067 --> 00:19:05.100
because your application
is effectively

00:19:05.100 --> 00:19:07.767
a big graph
of this depends on that.

00:19:07.767 --> 00:19:09.000
You know, my user interface

00:19:09.000 --> 00:19:11.000
depends on the components
inside of it.

00:19:11.000 --> 00:19:13.501
Et cetera.

00:19:13.501 --> 00:19:17.434
All right.

00:19:17.434 --> 00:19:20.767
Dhanji: Okay, so this
is a slightly longer form

00:19:20.767 --> 00:19:22.133
of the bind statement.

00:19:22.133 --> 00:19:25.234
And what we're saying here
is bind this interface

00:19:25.234 --> 00:19:26.767
to this implementation.

00:19:26.767 --> 00:19:29.400
So tweeter is the interface
that we have.

00:19:29.400 --> 00:19:31.767
We don't know how the tweets
actually go out.

00:19:31.767 --> 00:19:34.067
Um, but SmsTweeter
does now.

00:19:34.067 --> 00:19:37.367
SmsTweeter sends them
over the short message service.

00:19:37.367 --> 00:19:39.667
So all this is saying
is every place

00:19:39.667 --> 00:19:41.701
that you see tweeter
as a dependency,

00:19:41.701 --> 00:19:44.767
make sure that SmsTweeter
is provided.

00:19:44.767 --> 00:19:47.234
And the great saving here is,
of course,

00:19:47.234 --> 00:19:48.667
none of the client code

00:19:48.667 --> 00:19:50.767
knows that there
is an SmsTweeter

00:19:50.767 --> 00:19:52.234
being used underneath.

00:19:52.234 --> 00:19:55.200
It just uses it when
it's available at runtime.

00:19:55.200 --> 00:19:57.767
Jesse: Yeah, so, you know,
six months down the road,

00:19:57.767 --> 00:20:00.000
if we decide that
the SmsTweeter isn't optimal,

00:20:00.000 --> 00:20:02.067
or if we want to use
a JSONTweeter

00:20:02.067 --> 00:20:03.601
or some other protocol,

00:20:03.601 --> 00:20:05.767
all we have to do is change
this one statement

00:20:05.767 --> 00:20:08.234
and say, "Okay, now I'm gonna
bind my tweeter

00:20:08.234 --> 00:20:11.200
"to my JSONTweeter
of my AJAXTweeter

00:20:11.200 --> 00:20:13.033
or my XML,"
or something like that,

00:20:13.033 --> 00:20:15.434
any transport
that would be used.

00:20:15.434 --> 00:20:19.133
Uh, so what's actually happening
behind the scenes here

00:20:19.133 --> 00:20:20.467
is there's two bindings.

00:20:20.467 --> 00:20:22.734
There's the binding
for tweeter to SmsTweeter.

00:20:22.734 --> 00:20:24.133
And then there's
a second binding,

00:20:24.133 --> 00:20:27.000
which is SmsTweeter
to its own constructor.

00:20:27.000 --> 00:20:28.767
So when Guice sees this,

00:20:28.767 --> 00:20:30.300
it's actually going to create
a binding for tweeter,

00:20:30.300 --> 00:20:32.767
and then it'll look
at the SmsTweeter's binding.

00:20:32.767 --> 00:20:36.501
And in this case, it'll just
use that class as constructor.

00:20:36.501 --> 00:20:38.534
All right.

00:20:38.534 --> 00:20:39.734
Uh, Binding Annotations.

00:20:39.734 --> 00:20:42.767
So, so far, we've always
been talking about

00:20:42.767 --> 00:20:45.234
the unit of a dependency
is a type.

00:20:45.234 --> 00:20:47.400
So you can say, "Okay,
I depend on a tweeter

00:20:47.400 --> 00:20:48.767
or a shortener."

00:20:48.767 --> 00:20:52.534
But oftentimes, the type
doesn't uniquely identify

00:20:52.534 --> 00:20:54.601
what you really want
in your dependency.

00:20:54.601 --> 00:20:58.200
So if you say, "Okay,
I want my database address,"

00:20:58.200 --> 00:21:01.100
or, "I want the port
I'm supposed to bind on,"

00:21:01.100 --> 00:21:02.767
it's not really
sufficient to say,

00:21:02.767 --> 00:21:03.767
"Just inject a string,"

00:21:03.767 --> 00:21:05.400
because there may be
multiple strings

00:21:05.400 --> 00:21:06.767
and you need to really
identify,

00:21:06.767 --> 00:21:09.267
"Okay, I want the string
that is the database addressed,

00:21:09.267 --> 00:21:10.767
"or the string that is--

00:21:10.767 --> 00:21:12.501
the integer
that is the port number."

00:21:12.501 --> 00:21:15.100
And so Guice uses
a type-safe way

00:21:15.100 --> 00:21:16.601
to identify bindings

00:21:16.601 --> 00:21:19.234
in addition
to the bindings type itself.

00:21:19.234 --> 00:21:21.200
And these are called
binding annotations.

00:21:21.200 --> 00:21:24.501
And so you can annotate
a parameter

00:21:24.501 --> 00:21:26.801
with an annotation
that you define

00:21:26.801 --> 00:21:30.934
that identifies which instance
of that type you want.

00:21:30.934 --> 00:21:35.400
So in this case,
I'm binding the string "jesse"

00:21:35.400 --> 00:21:37.234
annotated with Username.

00:21:37.234 --> 00:21:38.767
And this is, again, indirect.

00:21:38.767 --> 00:21:41.234
So we can say,
"Okay, I want a...

00:21:41.234 --> 00:21:43.667
uh, an annotation
called port number

00:21:43.667 --> 00:21:45.701
or an annotation called
database address."

00:21:45.701 --> 00:21:47.567
So you can use Guice
to configure not only

00:21:47.567 --> 00:21:49.200
your class dependencies,

00:21:49.200 --> 00:21:51.267
but also, all of your
configuration dependencies.

00:21:51.267 --> 00:21:52.767
So you can--you don't
have to worry about

00:21:52.767 --> 00:21:55.100
having these
separate mechanisms

00:21:55.100 --> 00:21:56.501
for how you connect
to your database,

00:21:56.501 --> 00:21:58.167
how you connect
to remote services,

00:21:58.167 --> 00:22:01.767
you can use Guice
to configure everything.

00:22:01.767 --> 00:22:04.767
And this is the standard
boilerplate you need

00:22:04.767 --> 00:22:06.767
to define user annotation.

00:22:06.767 --> 00:22:09.133
I'm not gonna go too much
into detail on it,

00:22:09.133 --> 00:22:11.767
but this is just--every time
you want to define

00:22:11.767 --> 00:22:13.501
a custom name
for something,

00:22:13.501 --> 00:22:14.734
use this boilerplate.

00:22:14.734 --> 00:22:17.033
You're saying
about his and hers?

00:22:17.033 --> 00:22:19.634
Dhanji: Oh, yeah,
so the great thing about this

00:22:19.634 --> 00:22:21.767
is it does look like
a little bit of boilerplate,

00:22:21.767 --> 00:22:25.367
but the awesome saving
is it's purely

00:22:25.367 --> 00:22:26.767
a bit of metadata, right?

00:22:26.767 --> 00:22:29.200
You can reuse it
across your application

00:22:29.200 --> 00:22:30.767
for several purposes.

00:22:30.767 --> 00:22:34.067
You might bind
"jesse" to the user name,

00:22:34.067 --> 00:22:37.634
where you use it
in a login-style scenario.

00:22:37.634 --> 00:22:39.634
But you might
bind something else

00:22:39.634 --> 00:22:41.534
to a user name somewhere else
for a different type.

00:22:41.534 --> 00:22:43.334
So it's completely flexible,

00:22:43.334 --> 00:22:46.334
and it doesn't force you
to bind directly

00:22:46.334 --> 00:22:48.734
to the actual implementation
that's underneath.

00:22:48.734 --> 00:22:50.367
So in the tweeter case,

00:22:50.367 --> 00:22:53.300
you might bind it
to a current transporter,

00:22:53.300 --> 00:22:54.567
paid transport,

00:22:54.567 --> 00:22:57.767
and, really, that paid transport
is an SMS transport.

00:22:57.767 --> 00:22:59.767
But you can reuse
the paid annotation

00:22:59.767 --> 00:23:03.300
to bind, say, a credit card
transport--

00:23:03.300 --> 00:23:05.033
or a credit card
service, sorry--

00:23:05.033 --> 00:23:07.767
or any number of other
dependencies.

00:23:07.767 --> 00:23:09.234
Jesse: And one really
nice thing about the way

00:23:09.234 --> 00:23:10.701
Guice does dependency
injection is that

00:23:10.701 --> 00:23:14.100
this annotation is compiled
into your code.

00:23:14.100 --> 00:23:16.367
So this is just standard
Java code,

00:23:16.367 --> 00:23:17.767
and if you spell
user name wrong,

00:23:17.767 --> 00:23:19.767
the compiler will tell you,
or, more likely,

00:23:19.767 --> 00:23:22.267
if you're using an IDE
like IntelliJ or Eclipse,

00:23:22.267 --> 00:23:23.767
it'll highlight it in red,

00:23:23.767 --> 00:23:25.767
and make sure you spell
everything properly.

00:23:25.767 --> 00:23:27.901
All right, so the last
type of binding

00:23:27.901 --> 00:23:29.667
we're gonna talk about
is an instance binding.

00:23:29.667 --> 00:23:32.767
And we already sort of saw this
with the "jesse" example,

00:23:32.767 --> 00:23:35.367
where you can give
an actual value

00:23:35.367 --> 00:23:36.734
that you want to bind to.

00:23:36.734 --> 00:23:40.534
So, in this case,
instead of hard coating 8080

00:23:40.534 --> 00:23:43.200
as a public data constant
in 10,000 classes,

00:23:43.200 --> 00:23:45.767
you can configure it
once in your module,

00:23:45.767 --> 00:23:47.701
and then everywhere
that you need that constant,

00:23:47.701 --> 00:23:48.767
you just inject it.

00:23:48.767 --> 00:23:50.467
And this really
overcomes this problem

00:23:50.467 --> 00:23:51.701
where, you know,

00:23:51.701 --> 00:23:53.767
if you decide you want
to run your FTP server

00:23:53.767 --> 00:23:55.767
on Port 22
instead of 21,

00:23:55.767 --> 00:23:58.267
you have to go in and change
10,000 pieces of code

00:23:58.267 --> 00:23:59.400
where that's wired.

00:23:59.400 --> 00:24:02.534
And the, uh,
the main problem is that

00:24:02.534 --> 00:24:04.100
when you do
that type of approach,

00:24:04.100 --> 00:24:07.601
you either have the 10,000
different definitions of that

00:24:07.601 --> 00:24:09.534
or you have some file
called "constants"

00:24:09.534 --> 00:24:11.467
that everything else
has to depend on.

00:24:11.467 --> 00:24:15.067
So this is a nice balance.

00:24:15.067 --> 00:24:16.634
All right,
you talk about scopes.

00:24:16.634 --> 00:24:19.267
Dhanji: Okay, so scopes
are very interesting.

00:24:19.267 --> 00:24:22.067
They're really hard for me
to define

00:24:22.067 --> 00:24:23.634
in one, simple way.

00:24:23.634 --> 00:24:26.167
So I'll use the simplest
explanation

00:24:26.167 --> 00:24:29.000
that I could think of.

00:24:29.000 --> 00:24:32.000
For me, scopes
are about duration, right?

00:24:32.000 --> 00:24:36.033
You can talk about scopes
as a context,

00:24:36.033 --> 00:24:38.167
for instance,
an HTP request

00:24:38.167 --> 00:24:39.767
is a scope in Guice.

00:24:39.767 --> 00:24:42.734
Or an HTTP session,
which is a series of requests

00:24:42.734 --> 00:24:45.067
that come in a sequence.

00:24:45.067 --> 00:24:46.767
Or you can talk
about singletons,

00:24:46.767 --> 00:24:50.400
objects that live throughout
the life of an application.

00:24:50.400 --> 00:24:52.167
That is a Scope
in itself.

00:24:52.167 --> 00:24:55.767
So these are short
or longer durations

00:24:55.767 --> 00:24:59.300
during which any dependency
injection that's performed

00:24:59.300 --> 00:25:02.033
will always receive
the same instance

00:25:02.033 --> 00:25:03.767
of the dependency.

00:25:03.767 --> 00:25:07.501
Jesse: So, uh, when you
do your factory pattern,

00:25:07.501 --> 00:25:10.634
you'll often have, you know,
a private static constant

00:25:10.634 --> 00:25:12.767
that is, you know,
the tweeter.

00:25:12.767 --> 00:25:15.033
And when you say,
"Give me the tweeter,"

00:25:15.033 --> 00:25:16.767
you might lazily
instantiate it.

00:25:16.767 --> 00:25:18.467
And then, for the rest
of your application,

00:25:18.467 --> 00:25:19.767
you always get
the same instance.

00:25:19.767 --> 00:25:22.334
With scopes, you can
get that sort of

00:25:22.334 --> 00:25:24.234
application-wide constant

00:25:24.234 --> 00:25:26.300
without having to actually
write the statics

00:25:26.300 --> 00:25:27.567
and without
having to compromise

00:25:27.567 --> 00:25:29.000
your application's
testability.

00:25:29.000 --> 00:25:31.267
In our cute diagram here,

00:25:31.267 --> 00:25:33.534
we have this sort of long,
blue line,

00:25:33.534 --> 00:25:35.234
which is the duration
of the application.

00:25:35.234 --> 00:25:38.667
Um, this is a very abstract
example, without a legend,

00:25:38.667 --> 00:25:40.634
so I'll describe
what I'm thinking

00:25:40.634 --> 00:25:41.767
when I'm drawing this.

00:25:41.767 --> 00:25:44.767
Um, the red bars
are HTTP sessions,

00:25:44.767 --> 00:25:46.701
and the blue bars
are HTTP requests.

00:25:46.701 --> 00:25:48.200
And so you can see
that the scopes

00:25:48.200 --> 00:25:49.634
nest inside of each other.

00:25:49.634 --> 00:25:52.601
So you can have, like,
your application lives

00:25:52.601 --> 00:25:54.467
for several hours
or several days

00:25:54.467 --> 00:25:55.534
or several months,

00:25:55.534 --> 00:25:57.067
depending on how
your uptime is.

00:25:57.067 --> 00:26:00.701
And then every session
gets its own context,

00:26:00.701 --> 00:26:02.567
and then every request

00:26:02.567 --> 00:26:03.601
gets its own context.

00:26:03.601 --> 00:26:05.767
And this
is the HTTP example,

00:26:05.767 --> 00:26:07.167
but you can come up
with scopes

00:26:07.167 --> 00:26:09.367
for any number
of different contexts

00:26:09.367 --> 00:26:11.534
that exist
in your application.

00:26:11.534 --> 00:26:13.734
Uh, so we've already
sort of talked about this.

00:26:13.734 --> 00:26:15.167
These are the common scopes.

00:26:15.167 --> 00:26:18.033
So the most natural one
is Unscoped,

00:26:18.033 --> 00:26:20.767
and that means that any time
you want a value,

00:26:20.767 --> 00:26:22.567
it will be created,
you use it,

00:26:22.567 --> 00:26:23.767
and then you throw it away.

00:26:23.767 --> 00:26:25.467
Uh, the opposite
is Singleton,

00:26:25.467 --> 00:26:26.734
where any time
you need a value

00:26:26.734 --> 00:26:28.567
it's created exactly once,

00:26:28.567 --> 00:26:30.234
and you always, always
use the same one.

00:26:30.234 --> 00:26:32.334
This is great if your
application is stateful,

00:26:32.334 --> 00:26:33.667
and you want
to do something like

00:26:33.667 --> 00:26:35.567
track the number of hits
on your sever

00:26:35.567 --> 00:26:36.767
since it was started.

00:26:36.767 --> 00:26:38.767
Because you can just say,
"Use a singleton,"

00:26:38.767 --> 00:26:40.367
and every time
somebody does something,

00:26:40.367 --> 00:26:41.667
you call increment.

00:26:41.667 --> 00:26:44.367
Uh, RequestScope
is fantastic.

00:26:44.367 --> 00:26:47.767
And it says, "For the duration
of my HTTP request,

00:26:47.767 --> 00:26:49.067
remember this value."

00:26:49.067 --> 00:26:50.434
This is particularly handy

00:26:50.434 --> 00:26:53.300
if you're doing
a several-tier application

00:26:53.300 --> 00:26:54.701
where you want to say,

00:26:54.701 --> 00:26:56.701
"I don't really want
to go back to the database

00:26:56.701 --> 00:26:58.133
"every single time
I want to remember

00:26:58.133 --> 00:26:59.667
who the current user is."

00:26:59.667 --> 00:27:01.667
You can just put that
in a RequestScoped object

00:27:01.667 --> 00:27:03.200
and it remembers.

00:27:03.200 --> 00:27:06.200
And SessionScoped
is the same process

00:27:06.200 --> 00:27:07.767
for the HTTP session.

00:27:07.767 --> 00:27:10.234
So if you have, uh,
if you have any session data,

00:27:10.234 --> 00:27:14.601
like a cache, this works
very nicely for that.

00:27:14.601 --> 00:27:18.400
So that's how you apply scopes
to your objects in Guice.

00:27:18.400 --> 00:27:21.434
Uh, you just annotate them
with the name of the Scope.

00:27:21.434 --> 00:27:23.501
We're very annotation happy
in Guice.

00:27:23.501 --> 00:27:27.234
And this is both
functional, because it says,

00:27:27.234 --> 00:27:28.934
"Okay, there will only be
one tweet client

00:27:28.934 --> 00:27:30.400
for the duration
of the application."

00:27:30.400 --> 00:27:32.534
But it's also documentation.

00:27:32.534 --> 00:27:35.367
So when you're seeing this
class tweet client,

00:27:35.367 --> 00:27:36.734
and you're maintaining it,

00:27:36.734 --> 00:27:38.634
the singleton annotation
is a really good hint

00:27:38.634 --> 00:27:40.000
that you may have to think
about concurrency

00:27:40.000 --> 00:27:41.300
when you're maintaining this.

00:27:41.300 --> 00:27:43.534
Because singletons
are naturally--

00:27:43.534 --> 00:27:48.167
uh, need to be multithreaded
in multithreaded applications.

00:27:48.167 --> 00:27:50.667
All right, um, if you want
to apply a scope

00:27:50.667 --> 00:27:52.300
in a binding instead,

00:27:52.300 --> 00:27:53.567
you can also do that.

00:27:53.567 --> 00:27:55.467
So here we're saying,

00:27:55.467 --> 00:27:58.834
"Bind my ConnectionPool
to the ExecutorServicePool

00:27:58.834 --> 00:28:00.100
as a Singleton,"

00:28:00.100 --> 00:28:02.000
which is
.in(Singleton.class).

00:28:02.000 --> 00:28:04.634
Or in your provide method
you just annotate the method.

00:28:04.634 --> 00:28:05.701
And that'll mean that Guice

00:28:05.701 --> 00:28:07.801
will only call that method
one time,

00:28:07.801 --> 00:28:09.367
and then it'll just
remember the value.

00:28:09.367 --> 00:28:11.000
And any time anybody
wants a shortener,

00:28:11.000 --> 00:28:16.634
it just uses
that same instance.

00:28:16.634 --> 00:28:18.868
Dhanji: Uh...cool, okay.

00:28:18.868 --> 00:28:21.300
So there are different
kinds of injections

00:28:21.300 --> 00:28:22.868
that Guice supports,

00:28:22.868 --> 00:28:25.634
and constructor injection
is the most obvious one.

00:28:25.634 --> 00:28:27.334
This is the one that
we've been talking about.

00:28:27.334 --> 00:28:29.033
This is where you pass in
all your dependencies

00:28:29.033 --> 00:28:30.400
via constructor,

00:28:30.400 --> 00:28:32.300
and you place
an @Inject annotation

00:28:32.300 --> 00:28:34.000
on the constructor

00:28:34.000 --> 00:28:36.467
to tell Guice to use it.

00:28:36.467 --> 00:28:38.901
Now, the advantage
to constructor injection

00:28:38.901 --> 00:28:40.667
is--is really great,

00:28:40.667 --> 00:28:44.868
because you can declare
your dependencies as final,

00:28:44.868 --> 00:28:46.534
which makes them immutable.

00:28:46.534 --> 00:28:50.100
Now, this is great
for any concurrent class

00:28:50.100 --> 00:28:51.400
where you have
multiple threads

00:28:51.400 --> 00:28:54.200
accessing the code
in the same class.

00:28:54.200 --> 00:28:57.200
Then you have no danger
of state leaking

00:28:57.200 --> 00:28:58.501
between these threads,

00:28:58.501 --> 00:28:59.834
because there
is no state, right?

00:28:59.834 --> 00:29:02.100
You don't change the values.

00:29:02.100 --> 00:29:04.601
It's also great
for publication,

00:29:04.601 --> 00:29:07.534
which is--which means
that once the value is set,

00:29:07.534 --> 00:29:09.133
it's seen by all threads,

00:29:09.133 --> 00:29:10.767
and you never have
any danger

00:29:10.767 --> 00:29:13.367
of a NullPointerException.

00:29:13.367 --> 00:29:15.467
You also have
method injection,

00:29:15.467 --> 00:29:18.234
which is traditionally
called setter injection.

00:29:18.234 --> 00:29:21.300
And this is almost exactly
like constructor injection,

00:29:21.300 --> 00:29:24.801
but it's called after
the constructors have run.

00:29:24.801 --> 00:29:28.234
And what this is
is just a simple setter method,

00:29:28.234 --> 00:29:30.934
so you pass in your dependency
via a setter.

00:29:30.934 --> 00:29:33.634
And the method doesn't
have to be called

00:29:33.634 --> 00:29:35.300
Set Shortener
or Set whatever.

00:29:35.300 --> 00:29:36.801
It can be called
anything you like,

00:29:36.801 --> 00:29:38.968
so long as it has
an @Inject annotation

00:29:38.968 --> 00:29:41.400
and it doesn't only
have to take

00:29:41.400 --> 00:29:43.534
the one parameter.

00:29:43.534 --> 00:29:45.133
It can take as many
arguments as you like,

00:29:45.133 --> 00:29:47.234
just like a constructor.

00:29:47.234 --> 00:29:49.467
Jesse: All right,
and lastly.

00:29:49.467 --> 00:29:52.501
Dhanji: Lastly, we have
this horrible form of injection

00:29:52.501 --> 00:29:54.167
that we don't
want you to use,

00:29:54.167 --> 00:29:55.868
but we're gonna talk about
anyway.

00:29:55.868 --> 00:29:58.367
And this is field injection.

00:29:58.367 --> 00:29:59.868
The thing
about field injection

00:29:59.868 --> 00:30:03.167
is that it's
really concise, right?

00:30:03.167 --> 00:30:06.334
It's an @Inject annotation
directly on the member

00:30:06.334 --> 00:30:08.567
that you're, uh,
that you depend on.

00:30:08.567 --> 00:30:10.133
You don't need
to set anything.

00:30:10.133 --> 00:30:12.400
Guice will set it for you
by reflection.

00:30:12.400 --> 00:30:13.901
The problem with this,

00:30:13.901 --> 00:30:15.601
and the reason
we discourage it,

00:30:15.601 --> 00:30:18.901
is that it makes testing
very, very difficult.

00:30:18.901 --> 00:30:21.901
Now, you have
to expose your fields.

00:30:21.901 --> 00:30:25.100
In this case, we've
exposed them as PackageLocal

00:30:25.100 --> 00:30:28.067
in order to access them
from a test class

00:30:28.067 --> 00:30:29.701
in the same package.

00:30:29.701 --> 00:30:31.467
Now, not only
is that ugly,

00:30:31.467 --> 00:30:35.400
it's, um, it's also difficult
for other tests

00:30:35.400 --> 00:30:36.734
that don't
sit in the same package

00:30:36.734 --> 00:30:38.434
to get access to it.

00:30:38.434 --> 00:30:40.801
So we discourage this,
but in a pinch

00:30:40.801 --> 00:30:43.934
or in tutorial code,
it looks nice and it works.

00:30:43.934 --> 00:30:45.267
Jesse: It's very,
very concise.

00:30:45.267 --> 00:30:46.901
So a lot of the intro
in the talk

00:30:46.901 --> 00:30:48.567
was about removing
boilerplate.

00:30:48.567 --> 00:30:50.367
And if you get--
if that's why you're here,

00:30:50.367 --> 00:30:52.300
I invite you to use
field injection.

00:30:52.300 --> 00:30:54.701
Although you're losing out
on a lot of other benefits

00:30:54.701 --> 00:30:56.534
of dependency injection.

00:30:56.534 --> 00:30:59.000
All right, uh, let's talk
about injecting providers.

00:30:59.000 --> 00:31:01.267
So thus far, we've always
been talking about

00:31:01.267 --> 00:31:02.667
I have a dependency.

00:31:02.667 --> 00:31:04.200
You get a single instance
of that dependency

00:31:04.200 --> 00:31:05.734
and you use it.

00:31:05.734 --> 00:31:09.133
Um, the provider interface
permits something new.

00:31:09.133 --> 00:31:11.467
And the interface
is very, very simple.

00:31:11.467 --> 00:31:13.734
It's parameterized on "T."

00:31:13.734 --> 00:31:16.100
So you can have a provider
of string

00:31:16.100 --> 00:31:17.434
and then "get"
will return string,

00:31:17.434 --> 00:31:19.267
or you can have a provider
of shortener,

00:31:19.267 --> 00:31:20.601
and "get"
will return shortener.

00:31:20.601 --> 00:31:22.534
So the provider's type,

00:31:22.534 --> 00:31:25.834
it's a factory
for a given value.

00:31:25.834 --> 00:31:28.067
So when you inject a provider
into your code--

00:31:28.067 --> 00:31:29.601
and I'm using
field injection here,

00:31:29.601 --> 00:31:30.834
shame on me--

00:31:30.834 --> 00:31:33.033
um, you can see that

00:31:33.033 --> 00:31:34.934
we don't have to actually
get our shortener

00:31:34.934 --> 00:31:36.501
until we need it.

00:31:36.501 --> 00:31:39.434
So if we have somebody
who's very terse

00:31:39.434 --> 00:31:42.434
and doesn't ever write
tweets that are shorter than--

00:31:42.434 --> 00:31:44.334
that are longer
than 140 characters,

00:31:44.334 --> 00:31:47.000
we can avoid the cost
of constructing our shortener

00:31:47.000 --> 00:31:48.701
until we actually need it.

00:31:48.701 --> 00:31:50.300
So in this case, we say,
you know,

00:31:50.300 --> 00:31:52.100
if text length
is greater than 140,

00:31:52.100 --> 00:31:53.801
then go ahead and ask
the shortener provider

00:31:53.801 --> 00:31:55.334
for a value.

00:31:55.334 --> 00:31:57.367
We'll use it, and then
we'll let it go out of scope.

00:31:57.367 --> 00:32:00.434
So there's a bunch of reasons
why you would use providers.

00:32:00.434 --> 00:32:02.200
Um, first is to load lazily,

00:32:02.200 --> 00:32:03.467
which is what
we just saw.

00:32:03.467 --> 00:32:04.767
So we don't actually
have to worry

00:32:04.767 --> 00:32:06.267
about constructing
the shortener

00:32:06.267 --> 00:32:07.834
until it's actually needed.

00:32:07.834 --> 00:32:09.167
It's also useful
if you want to get

00:32:09.167 --> 00:32:10.734
multiple instances
of a value.

00:32:10.734 --> 00:32:13.067
So if you need multiple
database connections,

00:32:13.067 --> 00:32:15.467
instead of injecting
a database connection

00:32:15.467 --> 00:32:17.067
in your constructor,
you can inject a provider

00:32:17.067 --> 00:32:18.767
of the database connection,

00:32:18.767 --> 00:32:21.033
and then you can call "get"
once for each thread

00:32:21.033 --> 00:32:22.267
that you want to use
to connect,

00:32:22.267 --> 00:32:24.868
or once for each, uh,
each query

00:32:24.868 --> 00:32:26.400
that you need to run.

00:32:26.400 --> 00:32:29.067
Finally, providers
let you mix scopes.

00:32:29.067 --> 00:32:31.000
And so this
is where you have, uh,

00:32:31.000 --> 00:32:32.501
a singleton object

00:32:32.501 --> 00:32:34.267
that's sort of the overseer
of everything.

00:32:34.267 --> 00:32:36.400
But it kind of wants to know
who's asking

00:32:36.400 --> 00:32:38.033
who the current user is

00:32:38.033 --> 00:32:39.667
or what
their session contains.

00:32:39.667 --> 00:32:42.400
And so you can inject
a provider of user

00:32:42.400 --> 00:32:43.701
or a provider of session,

00:32:43.701 --> 00:32:46.667
and then use that
to look inside.

00:32:46.667 --> 00:32:48.200
All right, so thus far,

00:32:48.200 --> 00:32:49.801
we've talked about a lot
of the mechanics

00:32:49.801 --> 00:32:51.334
of using Guice.

00:32:51.334 --> 00:32:53.267
Now it's time to get into
the real exciting stuff,

00:32:53.267 --> 00:32:56.133
which is how do we really start
to take advantage of Guice,

00:32:56.133 --> 00:32:58.200
and how does this really
change our applications?

00:32:58.200 --> 00:32:59.434
We've removed the boilerplate.

00:32:59.434 --> 00:33:01.167
We've become testable.

00:33:01.167 --> 00:33:02.767
But now let's really start

00:33:02.767 --> 00:33:04.467
to figure out
how you can build

00:33:04.467 --> 00:33:07.400
absolutely fantastic
applications with Guice.

00:33:07.400 --> 00:33:11.567
All right, so this
is a fairly abstract diagram

00:33:11.567 --> 00:33:13.834
of a fairly abstract, uh--

00:33:13.834 --> 00:33:16.801
This is--imagine that this
is Google AdWords, okay?

00:33:16.801 --> 00:33:18.033
[laughs]

00:33:18.033 --> 00:33:19.067
So these
are all of the classes

00:33:19.067 --> 00:33:20.334
in Google AdWords.

00:33:20.334 --> 00:33:23.367
And we are in sort of
dependency, uh,

00:33:23.367 --> 00:33:25.133
dependency
nightmare mode here,

00:33:25.133 --> 00:33:27.000
where we can't compile
a single module

00:33:27.000 --> 00:33:28.601
without having
to build the whole world.

00:33:28.601 --> 00:33:30.267
Everything depends
on everything.

00:33:30.267 --> 00:33:32.634
And it's really hard
to figure out, you know,

00:33:32.634 --> 00:33:34.868
how do I--how do I isolate
this one component

00:33:34.868 --> 00:33:36.567
so that I can reuse it
in AdSense

00:33:36.567 --> 00:33:38.634
or so that I can reuse it
in some other system?

00:33:38.634 --> 00:33:41.000
So you want
to avoid creating

00:33:41.000 --> 00:33:44.701
this really complex
spaghetti dependency, uh,

00:33:44.701 --> 00:33:45.767
application.

00:33:45.767 --> 00:33:48.033
So with Guice,

00:33:48.033 --> 00:33:50.601
the idea is that you

00:33:50.601 --> 00:33:52.567
are encouraged to divide
your application

00:33:52.567 --> 00:33:53.968
up into modules.

00:33:53.968 --> 00:33:56.434
So, in this case,
we have five modules,

00:33:56.434 --> 00:33:57.667
and they all communicate
with each other

00:33:57.667 --> 00:33:59.467
via the public API.

00:33:59.467 --> 00:34:02.000
And, uh, this is possible
with factories

00:34:02.000 --> 00:34:03.400
and it's possible with
really good

00:34:03.400 --> 00:34:04.968
software engineering
discipline.

00:34:04.968 --> 00:34:06.934
But when you're using
dependency injection,

00:34:06.934 --> 00:34:08.434
and Guice in particular,

00:34:08.434 --> 00:34:09.734
it becomes very easy

00:34:09.734 --> 00:34:11.033
to have
this type of discipline

00:34:11.033 --> 00:34:12.267
where you're saying,

00:34:12.267 --> 00:34:14.334
"Okay, only
my API is exposed."

00:34:14.334 --> 00:34:15.634
And the reason that this
is possible

00:34:15.634 --> 00:34:17.400
is because Guice lets you

00:34:17.400 --> 00:34:19.334
hide your
implementation details.

00:34:19.334 --> 00:34:21.334
So you only--
only your module knows

00:34:21.334 --> 00:34:23.067
about your
implementation classes.

00:34:23.067 --> 00:34:26.701
And then your interfaces
and your domain classes

00:34:26.701 --> 00:34:30.300
and all that can be
in your public API.

00:34:30.300 --> 00:34:32.801
All right, so did you see
that cool transition?

00:34:32.801 --> 00:34:35.734
All right, so here's--
here's where we're at.

00:34:35.734 --> 00:34:37.567
We--we've written
this application,

00:34:37.567 --> 00:34:40.033
and we want to swap out
this entire component

00:34:40.033 --> 00:34:42.267
in the top right
with a new component,

00:34:42.267 --> 00:34:44.067
and when you use
dependency injection,

00:34:44.067 --> 00:34:46.100
it's about
writing modular code.

00:34:46.100 --> 00:34:48.267
And modular code
really means

00:34:48.267 --> 00:34:49.534
that I can swap out
this blue one

00:34:49.534 --> 00:34:51.234
for a yellow one.

00:34:51.234 --> 00:34:52.901
And that can be a completely
different implementation

00:34:52.901 --> 00:34:54.634
written by a completely
different team.

00:34:54.634 --> 00:34:56.234
This is extremely powerful,
you know.

00:34:56.234 --> 00:34:58.467
You're writing these really,
really big applications,

00:34:58.467 --> 00:35:00.834
things get slow,
things get complicated,

00:35:00.834 --> 00:35:03.934
and you know you want to say,
"Rewrite!"

00:35:03.934 --> 00:35:05.601
Well, Guice helps you
avoid the rewrite

00:35:05.601 --> 00:35:07.000
and all of the costs
with it

00:35:07.000 --> 00:35:09.000
because you don't have
to rewrite the whole thing.

00:35:09.000 --> 00:35:10.434
You can just rewrite
this module,

00:35:10.434 --> 00:35:12.434
the particularly
painful one.

00:35:12.434 --> 00:35:15.133
Um, so that's really handy,
but the other thing is

00:35:15.133 --> 00:35:17.667
is that not only can you take
an entire module,

00:35:17.667 --> 00:35:20.033
airlift it, and put in
a different implementation.

00:35:20.033 --> 00:35:21.767
You can also take that module
and reuse it

00:35:21.767 --> 00:35:23.767
in a completely
different application.

00:35:23.767 --> 00:35:25.534
So we can take our,
you know,

00:35:25.534 --> 00:35:27.767
our yellow module
from AdWords,

00:35:27.767 --> 00:35:29.534
and then go and use it
exactly the same

00:35:29.534 --> 00:35:30.667
in AdSense.

00:35:30.667 --> 00:35:31.968
And this
is extremely powerful.

00:35:31.968 --> 00:35:33.300
And this is the type
of reuse

00:35:33.300 --> 00:35:34.634
that was sort of
promised to us

00:35:34.634 --> 00:35:36.200
with object-oriented
programming,

00:35:36.200 --> 00:35:37.667
but hasn't really
been within reach.

00:35:37.667 --> 00:35:39.334
You know, you write
the customer class

00:35:39.334 --> 00:35:40.767
in every,
single application

00:35:40.767 --> 00:35:43.334
because you don't have
a customer module.

00:35:43.334 --> 00:35:45.801
And this sort of permits

00:35:45.801 --> 00:35:48.434
sort of your service-oriented
application

00:35:48.434 --> 00:35:50.601
where you can actually have
a module that says,

00:35:50.601 --> 00:35:51.868
you know, these are all
the APIs

00:35:51.868 --> 00:35:54.501
talking to my service.

00:35:54.501 --> 00:35:56.300
That's...

00:35:56.300 --> 00:35:59.000
Dhanji: Okay,
so Wave is famously

00:35:59.000 --> 00:36:00.400
a GWT application.

00:36:00.400 --> 00:36:03.334
GWT is Google Web Toolkit.

00:36:03.334 --> 00:36:06.200
And, uh, for Wave,

00:36:06.200 --> 00:36:08.267
we don't use this
in particular,

00:36:08.267 --> 00:36:12.968
but, um, GWT does support
Guice-like behavior

00:36:12.968 --> 00:36:15.667
using a library called GIN.

00:36:15.667 --> 00:36:18.767
GIN was written
by one of our Googlers

00:36:18.767 --> 00:36:21.467
and it provides
very similar functionality

00:36:21.467 --> 00:36:22.767
to Guice.

00:36:22.767 --> 00:36:24.968
When GWT is running
in Java mode,

00:36:24.968 --> 00:36:27.334
or hosted mode,
as they like to call it,

00:36:27.334 --> 00:36:28.934
it will defer to Guice

00:36:28.934 --> 00:36:31.000
to do all of the dependency
injection.

00:36:31.000 --> 00:36:33.367
And when it's compiled
into JavaScript

00:36:33.367 --> 00:36:34.634
GIN will provide

00:36:34.634 --> 00:36:37.934
the intermediary
JavaScript Code

00:36:37.934 --> 00:36:39.834
to do
the dependency injection

00:36:39.834 --> 00:36:42.334
just like it would
work in Java.

00:36:42.334 --> 00:36:44.100
Now, it does everything

00:36:44.100 --> 00:36:46.667
without any runtime cost
whatsoever

00:36:46.667 --> 00:36:49.300
because the source code
that's generated by GIN

00:36:49.300 --> 00:36:50.634
is exactly the same
source code

00:36:50.634 --> 00:36:52.300
you would write
in JavaScript

00:36:52.300 --> 00:36:54.501
to wire up all those objects
with one another.

00:36:54.501 --> 00:36:56.300
So that's fantastic.

00:36:56.300 --> 00:36:59.434
The other great thing
is it's the same API you use

00:36:59.434 --> 00:37:00.667
for Guice.

00:37:00.667 --> 00:37:03.868
So if you have a module
that you use

00:37:03.868 --> 00:37:05.667
in a server environment,

00:37:05.667 --> 00:37:09.334
and you'd like to port it
to the GWT environment,

00:37:09.334 --> 00:37:11.000
something that would have
been unheard of

00:37:11.000 --> 00:37:12.968
before GWT
and before Guice,

00:37:12.968 --> 00:37:14.267
you can do this today.

00:37:14.267 --> 00:37:15.667
It is a reality.

00:37:15.667 --> 00:37:16.667
Things like GWT-RPC,

00:37:16.667 --> 00:37:17.868
where you share code

00:37:17.868 --> 00:37:19.601
between the client
and the server

00:37:19.601 --> 00:37:21.033
really becomes possible

00:37:21.033 --> 00:37:28.367
now that you have GIN
sitting in this dual use mode.

00:37:28.367 --> 00:37:32.000
Okay, so the other
cool thing about Guice is--

00:37:32.000 --> 00:37:33.701
and particularly,
Guice 2,

00:37:33.701 --> 00:37:35.567
is the Guice
servlet extension.

00:37:35.567 --> 00:37:37.501
Now, the Guice
servlet extension

00:37:37.501 --> 00:37:39.334
is available in trunk.

00:37:39.334 --> 00:37:40.834
You can check it out,

00:37:40.834 --> 00:37:42.968
and there's a separate jar
that you need to download it

00:37:42.968 --> 00:37:44.434
and use it.

00:37:44.434 --> 00:37:47.200
Jesse: It's a separate jar,
but it comes with Guice.

00:37:47.200 --> 00:37:48.434
Dhanji: Comes with Guice.
Jesse: Yep.

00:37:48.434 --> 00:37:51.300
Dhanji: And it gives you
the request

00:37:51.300 --> 00:37:54.834
and session HTTP scopes
that we saw just earlier,

00:37:54.834 --> 00:37:56.601
just as an annotation,

00:37:56.601 --> 00:37:58.601
just like @Singleton was.

00:37:58.601 --> 00:38:00.701
that you get out of
the box of Guice.

00:38:00.701 --> 00:38:02.234
Now, these are really cool,

00:38:02.234 --> 00:38:05.000
but the servlet module
has a lot, lot more to it.

00:38:05.000 --> 00:38:08.067
As you see here,
you extend servlet module

00:38:08.067 --> 00:38:10.033
rather than abstract module

00:38:10.033 --> 00:38:12.300
when you're creating
your Guice module.

00:38:12.300 --> 00:38:14.534
And what this gives you
is the whole extension

00:38:14.534 --> 00:38:15.834
to the binding language

00:38:15.834 --> 00:38:18.300
to configure servlets
and filters.

00:38:18.300 --> 00:38:21.000
Now, if you guys have ever
used web.xml

00:38:21.000 --> 00:38:24.534
in a HTTP sever,
like Tomcat or JEDI,

00:38:24.534 --> 00:38:27.701
you find yourself writing
a lot of declarative XML rules

00:38:27.701 --> 00:38:29.367
to tell you
how to route requests

00:38:29.367 --> 00:38:31.634
based on their URLs.

00:38:31.634 --> 00:38:34.534
Now, you can do all of that
with idiomatic Java.

00:38:34.534 --> 00:38:36.968
Just like you're used to
with, you know,

00:38:36.968 --> 00:38:40.634
with bindings and how JEDI
would work under the covers

00:38:40.634 --> 00:38:42.968
without all this XML
in the middle.

00:38:42.968 --> 00:38:45.634
Now, that's great because
we're Java programmers,

00:38:45.634 --> 00:38:47.067
and we like to write Java.

00:38:47.067 --> 00:38:49.667
But it's also great
because it's type-safe.

00:38:49.667 --> 00:38:52.567
I can't serve
a particular URL

00:38:52.567 --> 00:38:55.067
with something
that's not a servlet.

00:38:55.067 --> 00:38:57.667
So you have all these
minor little enforcements

00:38:57.667 --> 00:39:00.334
that come into play
that add--

00:39:00.334 --> 00:39:03.434
give you this extra
level of confidence, yeah.

00:39:03.434 --> 00:39:05.367
Now, the other great thing
about the servlet module

00:39:05.367 --> 00:39:07.200
is that it has
a lot more extensions

00:39:07.200 --> 00:39:08.534
than just this.

00:39:08.534 --> 00:39:10.400
It allows you
to match URIs

00:39:10.400 --> 00:39:12.534
based on
regular expressions.

00:39:12.534 --> 00:39:15.267
It allows you
to bind keys

00:39:15.267 --> 00:39:17.534
so you can have
multiple servlets

00:39:17.534 --> 00:39:20.133
that are matched
in a dispatch order.

00:39:20.133 --> 00:39:23.300
All the power of web.xml
and a lot, lot more,

00:39:23.300 --> 00:39:25.334
and none of the pain.

00:39:25.334 --> 00:39:28.000
Jesse: Yeah, the part
that Dhanji was talking about--

00:39:28.000 --> 00:39:29.400
me about earlier

00:39:29.400 --> 00:39:31.501
is that when you move
your servlet configuration

00:39:31.501 --> 00:39:33.934
out of the XML file
and into modules,

00:39:33.934 --> 00:39:35.968
you get a modular design
for your servlets.

00:39:35.968 --> 00:39:37.367
And so what
that lets you do

00:39:37.367 --> 00:39:40.200
is you can actually create
a prepackaged module

00:39:40.200 --> 00:39:42.701
for some aspect
of your application,

00:39:42.701 --> 00:39:47.167
like authentication
or your admin servlet,

00:39:47.167 --> 00:39:49.133
and you can say, okay,
we've written the, you know,

00:39:49.133 --> 00:39:51.367
the single sign-on
servlet package,

00:39:51.367 --> 00:39:52.501
and we use that module

00:39:52.501 --> 00:39:54.734
in a whole bunch
of different applications,

00:39:54.734 --> 00:39:56.000
and you don't
have to worry about

00:39:56.000 --> 00:39:58.000
configuring web.xml
for each.

00:39:58.000 --> 00:40:00.767
So if you're
the single sign-on team

00:40:00.767 --> 00:40:02.100
or the security team

00:40:02.100 --> 00:40:03.734
and you have your own
servlet filters

00:40:03.734 --> 00:40:05.901
and your own servlets,

00:40:05.901 --> 00:40:08.701
you can give this to your
entire development staff

00:40:08.701 --> 00:40:10.033
at your company and say,

00:40:10.033 --> 00:40:13.367
"Okay, use this module
in your servlet application,

00:40:13.367 --> 00:40:15.033
"and you'll automatically
get our filters

00:40:15.033 --> 00:40:16.400
"and our servlets applied,

00:40:16.400 --> 00:40:18.167
and there's no other
integration work."

00:40:18.167 --> 00:40:19.334
Whereas the alternative is

00:40:19.334 --> 00:40:21.000
is you have
to actually go in

00:40:21.000 --> 00:40:22.734
and edit
the web.xml for each.

00:40:22.734 --> 00:40:24.801
And that means that you're
sort of discouraged

00:40:24.801 --> 00:40:26.467
from changing
your filters over time

00:40:26.467 --> 00:40:28.133
as your business needs
change.

00:40:28.133 --> 00:40:30.501
Dhanji: The other great thing
is we do this

00:40:30.501 --> 00:40:31.968
in Google Wave,
by the way.

00:40:31.968 --> 00:40:34.501
So we use
this modular design,

00:40:34.501 --> 00:40:38.334
so we have particular servers
that sit on the front end,

00:40:38.334 --> 00:40:40.501
and the single sign-on
is the same code

00:40:40.501 --> 00:40:42.000
that's used all over Google,

00:40:42.000 --> 00:40:44.634
and we bring that into
Google Wave this way.

00:40:44.634 --> 00:40:47.400
And--and this morning's demo,

00:40:47.400 --> 00:40:49.934
when you saw Lars doing
all those fancy, cool things

00:40:49.934 --> 00:40:52.367
with the collaborative
editing stuff,

00:40:52.367 --> 00:40:54.701
every single character
that he typed

00:40:54.701 --> 00:40:57.400
went through a Guice servlet
dispatch rule.

00:40:57.400 --> 00:40:59.534
Yeah, so is it fast?

00:40:59.534 --> 00:41:01.534
Jesse: [laughs]
It's way fast.

00:41:01.534 --> 00:41:04.334
Okay, all right,
so one of the features

00:41:04.334 --> 00:41:07.300
I hinted at earlier is
aspect-oriented programming.

00:41:07.300 --> 00:41:09.934
And this is a very,
very powerful,

00:41:09.934 --> 00:41:11.367
very, very complex domain.

00:41:11.367 --> 00:41:13.501
And Guice gives you
sort of the sweet spot

00:41:13.501 --> 00:41:14.801
of what you want,

00:41:14.801 --> 00:41:17.100
which is method
interceptors.

00:41:17.100 --> 00:41:21.868
Um, so suppose you're
writing a database thing,

00:41:21.868 --> 00:41:24.200
and you--you're writing
this boilerplate

00:41:24.200 --> 00:41:26.667
where you need to set up
and tear down a transaction

00:41:26.667 --> 00:41:28.634
for every method called.

00:41:28.634 --> 00:41:30.100
So, traditionally,
what you'll do

00:41:30.100 --> 00:41:32.467
is you'll say
database connection.open,

00:41:32.467 --> 00:41:35.000
try, then do
your actual work.

00:41:35.000 --> 00:41:37.234
And then you'll have,
you know, a catch clause

00:41:37.234 --> 00:41:38.434
and a finally clause

00:41:38.434 --> 00:41:40.067
and some teardowns
and rollbacks

00:41:40.067 --> 00:41:42.200
to handle the cases
where your business logic

00:41:42.200 --> 00:41:45.000
either failed or there was
an optimistic problem

00:41:45.000 --> 00:41:47.133
with your, um, your commit.

00:41:47.133 --> 00:41:49.100
So with aspect-oriented
programming,

00:41:49.100 --> 00:41:51.667
instead of doing all that stuff
all over the place,

00:41:51.667 --> 00:41:53.534
you separate
the cross-cutting concerns

00:41:53.534 --> 00:41:55.000
into interceptors,

00:41:55.000 --> 00:41:57.467
and they run
around your method.

00:41:57.467 --> 00:41:59.501
So in this case,
we've annotated

00:41:59.501 --> 00:42:02.701
database tweet storage
with @Transactional.

00:42:02.701 --> 00:42:04.167
And what this will do
is it'll make sure

00:42:04.167 --> 00:42:06.267
that before and after
saveTweet is called,

00:42:06.267 --> 00:42:08.467
we set up a transaction
and then we make sure

00:42:08.467 --> 00:42:09.701
to commit or roll back,

00:42:09.701 --> 00:42:13.167
depending on how that,
uh, method completed.

00:42:13.167 --> 00:42:15.567
Jesse: Uh, do you want
to talk more about this?

00:42:15.567 --> 00:42:18.868
Dhanji: Well, this
is another extension to Guice

00:42:18.868 --> 00:42:22.367
that's not available
in the Guice code project,

00:42:22.367 --> 00:42:25.934
but you can find it
in our documentation.

00:42:25.934 --> 00:42:28.834
It's a very,
very convenient thing

00:42:28.834 --> 00:42:33.534
for people who use Hibernate
or Java Persistence API,

00:42:33.534 --> 00:42:36.334
which is the foundation
of Google App Engine's

00:42:36.334 --> 00:42:38.000
persistence framework.

00:42:38.000 --> 00:42:40.701
So this is a bit
of boilerplate code,

00:42:40.701 --> 00:42:42.534
very much like the factories,

00:42:42.534 --> 00:42:44.968
but something that sits
in every method

00:42:44.968 --> 00:42:47.868
that does any work
with the database session.

00:42:47.868 --> 00:42:49.601
And it can all be
abstracted away

00:42:49.601 --> 00:42:51.434
with this one,
single annotation.

00:42:51.434 --> 00:42:54.334
And Guice enables us
to do this, yeah.

00:42:54.334 --> 00:42:56.767
Jesse: The other thing is
is that this AOP,

00:42:56.767 --> 00:42:59.734
it really fits hand-in-glove
for transactions.

00:42:59.734 --> 00:43:01.267
And there's a handful
of other cases

00:43:01.267 --> 00:43:03.000
where it also fits
very nicely.

00:43:03.000 --> 00:43:05.801
So on my former project
in billing,

00:43:05.801 --> 00:43:09.367
we used AOP and Guice
to do security.

00:43:09.367 --> 00:43:11.267
And so you'd have a method
that says, you know,

00:43:11.267 --> 00:43:12.534
"Make payment,"

00:43:12.534 --> 00:43:14.133
and you would have
an annotation on that method

00:43:14.133 --> 00:43:16.801
that said @Secure.

00:43:16.801 --> 00:43:18.000
And that would require

00:43:18.000 --> 00:43:19.801
that whoever
was calling that method

00:43:19.801 --> 00:43:21.501
had a prior login.

00:43:21.501 --> 00:43:22.834
And you can
annotate your methods

00:43:22.834 --> 00:43:24.734
and configure
all this stuff

00:43:24.734 --> 00:43:27.267
just exactly as you need it
to fit your application.

00:43:27.267 --> 00:43:29.501
So you can define
your own annotations,

00:43:29.501 --> 00:43:32.567
and you can define
how those annotations behave.

00:43:32.567 --> 00:43:34.000
Uh, it's fully pluggable,

00:43:34.000 --> 00:43:37.400
and in its core, Guice knows
nothing about transactions,

00:43:37.400 --> 00:43:38.801
it knows nothing about
servlets,

00:43:38.801 --> 00:43:40.467
it knows nothing
about security.

00:43:40.467 --> 00:43:42.634
But it supports all these things
to be added on

00:43:42.634 --> 00:43:46.167
with its own modular
architecture.

00:43:46.167 --> 00:43:48.167
All right, so the last part

00:43:48.167 --> 00:43:52.701
is that Guice
is fairly open

00:43:52.701 --> 00:43:55.300
to extension
and manipulation.

00:43:55.300 --> 00:43:58.167
So we've talked about
binding so far,

00:43:58.167 --> 00:44:00.334
and we've talked
about injections.

00:44:00.334 --> 00:44:02.667
All of this information,
all this metadata

00:44:02.667 --> 00:44:04.267
about your application
is exposed

00:44:04.267 --> 00:44:08.133
through Guice's Introspection
Service Provider interface.

00:44:08.133 --> 00:44:10.000
And so, when you
define your module

00:44:10.000 --> 00:44:12.467
and you set everything up,

00:44:12.467 --> 00:44:14.767
Guice will actually give you
all of the metadata

00:44:14.767 --> 00:44:16.200
that is has internally

00:44:16.200 --> 00:44:19.767
so that you can take that
and analyze your application.

00:44:19.767 --> 00:44:21.467
Uh, the most interesting
one so far

00:44:21.467 --> 00:44:24.000
has been that we've been
graphing our applications.

00:44:24.000 --> 00:44:25.434
You find
really interesting things

00:44:25.434 --> 00:44:28.934
when you can take your entire
10,000 class application

00:44:28.934 --> 00:44:31.501
and spit it out
into a graph and say,

00:44:31.501 --> 00:44:32.767
"You know what?

00:44:32.767 --> 00:44:35.300
"That dependency there,
that one's broken.

00:44:35.300 --> 00:44:36.467
We need to fix that."

00:44:36.467 --> 00:44:37.467
And you can't
do that type of thing

00:44:37.467 --> 00:44:38.501
by just
inspecting the code,

00:44:38.501 --> 00:44:40.234
reading line by line,

00:44:40.234 --> 00:44:43.100
because the modules are,
you know, modular.

00:44:43.100 --> 00:44:44.601
One's over here,
one's over here.

00:44:44.601 --> 00:44:46.334
The introspection API
lets you see it all

00:44:46.334 --> 00:44:47.601
at the same time.

00:44:47.601 --> 00:44:49.567
Uh, it's also
used internally by Guice

00:44:49.567 --> 00:44:53.100
to do some of the more,
uh, testy,

00:44:53.100 --> 00:44:55.067
easy,
configuration-type things.

00:44:55.067 --> 00:44:58.334
So when Guice--when you
have a module

00:44:58.334 --> 00:44:59.334
and you know, you say,

00:44:59.334 --> 00:45:02.100
"Okay, I want 90%
of this module,

00:45:02.100 --> 00:45:05.033
"but instead of that binding
to the production database,

00:45:05.033 --> 00:45:08.534
I'd rather bind to
the QA environment database."

00:45:08.534 --> 00:45:11.801
Or you know, the, uh,
the canary database.

00:45:11.801 --> 00:45:13.501
So you can take that module,

00:45:13.501 --> 00:45:15.667
override it with just
the stuff that you want,

00:45:15.667 --> 00:45:17.167
and you can
create a new module.

00:45:17.167 --> 00:45:19.501
And this all uses
the introspection SPI.

00:45:19.501 --> 00:45:23.601
It's sort of built on top
of Guice's own, uh...

00:45:23.601 --> 00:45:25.234
APIs.

00:45:25.234 --> 00:45:28.267
All right, so wrapping up.

00:45:28.267 --> 00:45:30.567
Dependency injection leads
to testable,

00:45:30.567 --> 00:45:34.434
reusable, modular,
maintainable code.

00:45:34.434 --> 00:45:37.100
And we love
dependency injection,

00:45:37.100 --> 00:45:39.267
but you really
want a framework.

00:45:39.267 --> 00:45:41.567
And Guice makes
dependency injection easy.

00:45:41.567 --> 00:45:44.000
It's a, you know,
it's very concise.

00:45:44.000 --> 00:45:45.567
You add that annotation.

00:45:45.567 --> 00:45:47.534
Very little boilerplate
that you have write.

00:45:47.534 --> 00:45:51.801
And once you've got Guice
independency injection in play,

00:45:51.801 --> 00:45:55.167
then there's a whole new
avenue of components

00:45:55.167 --> 00:45:56.767
and modules that you can
use as well.

00:45:56.767 --> 00:46:00.367
So this is, you know,
your scopes, your AOP,

00:46:00.367 --> 00:46:03.634
your warp-persist,
your app engine integration,

00:46:03.634 --> 00:46:06.701
your Google App Toolkit
integration.

00:46:06.701 --> 00:46:08.701
And Guice is also
really lightweight.

00:46:08.701 --> 00:46:10.801
So we're serious about this,

00:46:10.801 --> 00:46:12.200
and we don't think
that it makes sense

00:46:12.200 --> 00:46:16.100
to include a sort of
large kernel in applications.

00:46:16.100 --> 00:46:17.767
So although Guice drives,
you know,

00:46:17.767 --> 00:46:20.000
some of the bigger
applications at Google,

00:46:20.000 --> 00:46:21.434
it also works
on Android.

00:46:21.434 --> 00:46:23.868
It's a fairly lightweight,
simple library.

00:46:23.868 --> 00:46:25.834
And then it's a got a sort
of pluggable thing

00:46:25.834 --> 00:46:29.434
so you can put the servlets
for App Engine

00:46:29.434 --> 00:46:32.534
or the UI stuff for Android,

00:46:32.534 --> 00:46:35.000
and it all just
sort of works seamlessly.

00:46:35.000 --> 00:46:38.434
All right,
and the book plug.

00:46:38.434 --> 00:46:40.434
Dhanji: Yep, so I've got
a book coming out

00:46:40.434 --> 00:46:42.100
called &lt;i&gt;Dependency Injection.&lt;/i&gt;

00:46:42.100 --> 00:46:44.400
It's mostly
a design patterns book,

00:46:44.400 --> 00:46:46.200
but it has a lot
of focus on Guice

00:46:46.200 --> 00:46:48.300
and another
framer of Spring,

00:46:48.300 --> 00:46:50.133
and if you use
that discount code

00:46:50.133 --> 00:46:51.400
and go to that URL,

00:46:51.400 --> 00:46:54.734
I believe you get
a 40% discount for one week.

00:46:54.734 --> 00:46:56.534
Jesse: Yep, Google I/O only.

00:46:56.534 --> 00:46:58.634
So, uh, you can get the book

00:46:58.634 --> 00:47:00.968
in Manning Early Access
right away.

00:47:00.968 --> 00:47:02.901
Dhanji: Yep, and then once
it's ready,

00:47:02.901 --> 00:47:04.234
it'll be
shipped out to you.

00:47:04.234 --> 00:47:07.367
Jesse: Yeah, the book
really goes into full detail

00:47:07.367 --> 00:47:09.701
about all of the stuff
that we've just breezed through

00:47:09.701 --> 00:47:11.200
in the last hour.

00:47:11.200 --> 00:47:14.100
And I guess now
we should open the poll up

00:47:14.100 --> 00:47:15.234
for questions.

00:47:15.234 --> 00:47:17.501
Um, we're using
Google moderator.

00:47:17.501 --> 00:47:19.133
So if you guys
have your laptops handy

00:47:19.133 --> 00:47:20.634
and the Wi-Fi
is working well,

00:47:20.634 --> 00:47:21.868
you can
post questions there.

00:47:21.868 --> 00:47:23.667
Otherwise, please use
the microphones here.

00:47:23.667 --> 00:47:27.133
Um, thank you.

00:47:27.133 --> 00:47:28.534
All right.

00:47:28.534 --> 00:47:29.767
Question.

00:47:29.767 --> 00:47:31.968
man: How do I
compose modules?

00:47:31.968 --> 00:47:33.834
Jesse: How do you
compose modules?

00:47:33.834 --> 00:47:37.267
man: Take several small modules
and build a big one.

00:47:37.267 --> 00:47:39.167
Jesse: Yeah, so, um,

00:47:39.167 --> 00:47:42.934
the, uh, the--
the module API

00:47:42.934 --> 00:47:44.167
actually has a method

00:47:44.167 --> 00:47:46.567
where one module can
install another module.

00:47:46.567 --> 00:47:47.801
So you can say,

00:47:47.801 --> 00:47:50.968
"Okay, here's my entire
front end module."

00:47:50.968 --> 00:47:52.667
And then you may
have multiple teams, you know.

00:47:52.667 --> 00:47:53.868
You've got
your team in New York

00:47:53.868 --> 00:47:55.100
working on
the billing system,

00:47:55.100 --> 00:47:56.400
and your team in L.A.

00:47:56.400 --> 00:47:58.033
working on the user
authentication system,

00:47:58.033 --> 00:48:00.033
and a team in Mountain View
working on the features.

00:48:00.033 --> 00:48:03.167
Your front end module can
just install each of those.

00:48:03.167 --> 00:48:04.801
And what's really nice
about that approach

00:48:04.801 --> 00:48:06.534
is that those modules

00:48:06.534 --> 00:48:07.968
are independently reusable.

00:48:07.968 --> 00:48:10.367
So those teams can work
independently of one another

00:48:10.367 --> 00:48:11.634
as well as, you know,
when you actually need

00:48:11.634 --> 00:48:12.801
to go out in production

00:48:12.801 --> 00:48:14.434
and you need
the whole team's code

00:48:14.434 --> 00:48:15.934
all in one binary.

00:48:15.934 --> 00:48:17.634
You just compose it all
into one system.

00:48:17.634 --> 00:48:19.934
Um, now, if you have
multiple bindings

00:48:19.934 --> 00:48:21.167
for the same type--

00:48:21.167 --> 00:48:24.834
So if Dhanji binds his tweeter
to SmsTweeter,

00:48:24.834 --> 00:48:26.767
and I bind it
to JSONTweeter,

00:48:26.767 --> 00:48:28.968
Guice will detect that
at start-up time,

00:48:28.968 --> 00:48:31.267
when you call that
guice.createinjector method,

00:48:31.267 --> 00:48:32.534
and it'll say, you know,

00:48:32.534 --> 00:48:33.701
these are the old
falling bindings

00:48:33.701 --> 00:48:35.200
that we had problems with.

00:48:35.200 --> 00:48:37.400
And, you know, this one
happened on line 45

00:48:37.400 --> 00:48:38.701
of SMS module,

00:48:38.701 --> 00:48:41.868
and this one happened
on line 32 of JSON module.

00:48:41.868 --> 00:48:44.434
And it'll help you
to resolve that.

00:48:44.434 --> 00:48:45.834
Dhanji: There's also
a really simple way

00:48:45.834 --> 00:48:47.267
to compose modules.

00:48:47.267 --> 00:48:48.868
And that is when you're
bootstrapping Guice,

00:48:48.868 --> 00:48:50.934
you just give it a list
of modules,

00:48:50.934 --> 00:48:53.634
and it's just a simple
Java tool list.

00:48:53.634 --> 00:48:55.133
Give it as many modules
you like,

00:48:55.133 --> 00:48:56.634
it'll be installed
in order.

00:48:56.634 --> 00:48:57.667
Jesse: Yep.

00:48:57.667 --> 00:49:00.133
Uh, so we got a question
from a moderator

00:49:00.133 --> 00:49:03.133
that Jesse
in Mountain View wrote.

00:49:03.133 --> 00:49:05.200
Uh, what apps
use Google Guice?

00:49:05.200 --> 00:49:08.534
So the ones at Google
that use it are, uh,

00:49:08.534 --> 00:49:10.100
you know, we started out
with Adwords.

00:49:10.100 --> 00:49:12.167
We had this really big
application

00:49:12.167 --> 00:49:16.200
fairly hard to maintain.

00:49:16.200 --> 00:49:19.734
You know, we had a lot of,
um, factories

00:49:19.734 --> 00:49:21.501
and a lot of static state

00:49:21.501 --> 00:49:23.634
and a lot of, you know,
database connections

00:49:23.634 --> 00:49:24.868
that were required for tests

00:49:24.868 --> 00:49:26.567
that had nothing to do
with the database.

00:49:26.567 --> 00:49:29.667
And so Guice really
rescued Adwords front end

00:49:29.667 --> 00:49:31.400
and gave it a couple more
years of life

00:49:31.400 --> 00:49:33.267
by making it so that,
all of a sudden,

00:49:33.267 --> 00:49:35.701
you could use certain components
of Adwords independently,

00:49:35.701 --> 00:49:37.901
and that's breathed
new life into it.

00:49:37.901 --> 00:49:40.601
Um, there's also Gmail,

00:49:40.601 --> 00:49:44.801
um, Orkut, Docs,
YouTube,

00:49:44.801 --> 00:49:48.167
Wave, um...
the...

00:49:48.167 --> 00:49:50.701
Dhanji: Pretty much every
new Google application

00:49:50.701 --> 00:49:52.334
these days.

00:49:52.334 --> 00:49:53.734
Jesse: All right,
"Is Guice Servlet module

00:49:53.734 --> 00:49:55.634
now a superset
of warp-core?"

00:49:55.634 --> 00:49:57.801
So, uh...

00:49:57.801 --> 00:49:58.801
Good question.

00:49:58.801 --> 00:49:59.834
[both laugh]

00:49:59.834 --> 00:50:00.834
Uh, so...

00:50:00.834 --> 00:50:03.701
Dhanji: The answer
to that is no.

00:50:03.701 --> 00:50:06.901
It's--it has very similar
functionality.

00:50:06.901 --> 00:50:09.033
But warp-core
is now defunct.

00:50:09.033 --> 00:50:11.267
So Guice Servlet
takes precedence.

00:50:11.267 --> 00:50:12.367
It supersedes it.

00:50:12.367 --> 00:50:14.133
Jesse: Yep,
warp is still useful

