WEBVTT
Kind: captions
Language: en

00:00:07.936 --> 00:00:09.200
ANDREW WALES: Hi, everyone.

00:00:09.200 --> 00:00:11.940
Welcome to "Behind the Code." In
this week's episode, we're

00:00:11.940 --> 00:00:13.700
going to be talking all
about Google Tag

00:00:13.700 --> 00:00:15.440
Manager for Mobile Apps.

00:00:15.440 --> 00:00:16.329
My name's Andrew Wales.

00:00:16.329 --> 00:00:19.260
I'm on the analytics developer
relations team.

00:00:19.260 --> 00:00:21.930
And with me in the studio
today is Neil Rhodes.

00:00:21.930 --> 00:00:25.600
He's the tech lead on Google Tag
Manager for Mobile Apps.

00:00:25.600 --> 00:00:26.780
Neil, thanks for joining us.

00:00:26.780 --> 00:00:28.090
NEIL RHODES: Well, thanks
for having me.

00:00:28.090 --> 00:00:29.430
I look forward to doing this.

00:00:29.430 --> 00:00:29.930
ANDREW WALES: Great.

00:00:29.930 --> 00:00:32.820
So Google Tag Manager for Mobile
Apps launched publicly

00:00:32.820 --> 00:00:34.370
a couple weeks ago.

00:00:34.370 --> 00:00:35.460
NEIL RHODES: It was
August, yes.

00:00:35.460 --> 00:00:37.130
ANDREW WALES: August.

00:00:37.130 --> 00:00:41.960
And beyond doing all of the very
nice flexible tagging of

00:00:41.960 --> 00:00:46.490
analytics tools and conversion
tools, as you might know that

00:00:46.490 --> 00:00:50.530
GTM does on the web, there's
actually a lot in GTM, Tag

00:00:50.530 --> 00:00:53.930
Manager for Mobile Apps, that's
really designed to make

00:00:53.930 --> 00:00:56.650
life a lot simpler for app
developers as well.

00:00:56.650 --> 00:00:59.760
So I'm excited to have you here
and go through everything

00:00:59.760 --> 00:01:03.150
that's available for all of
you app developers to take

00:01:03.150 --> 00:01:05.600
advantage of.

00:01:05.600 --> 00:01:08.686
So let's take a quick look
at what's on tap.

00:01:08.686 --> 00:01:12.480
Neil's going to give you a quick
overview of what Tag

00:01:12.480 --> 00:01:15.670
Manager for Mobile is designed
to do and what problems it's

00:01:15.670 --> 00:01:17.340
designed to help you solve.

00:01:17.340 --> 00:01:20.410
We'll talk a little bit about
how you can work with the SDK,

00:01:20.410 --> 00:01:24.210
how you do some of the core
things you need to do with it.

00:01:24.210 --> 00:01:26.220
And we'll show you some code
snippets there as well, just

00:01:26.220 --> 00:01:28.230
to make things more clear.

00:01:28.230 --> 00:01:32.180
We'll talk about containers,
macros, rules and tags.

00:01:32.180 --> 00:01:36.730
And these are the four building
blocks in GTM.

00:01:36.730 --> 00:01:38.820
These are the things you're
going to be working with in

00:01:38.820 --> 00:01:40.400
the web interface.

00:01:40.400 --> 00:01:42.130
And just so you know where to
go, we'll also walk you

00:01:42.130 --> 00:01:44.510
through the web interface, how
to use that to do some of the

00:01:44.510 --> 00:01:46.870
very basic tasks when you're
working with GTM in your

00:01:46.870 --> 00:01:48.240
containers.

00:01:48.240 --> 00:01:51.000
And then lastly I'll show you
guys some resources that you

00:01:51.000 --> 00:01:54.490
can use after the GDL to go
check out more information and

00:01:54.490 --> 00:01:56.225
get started with GTM as well.

00:01:56.225 --> 00:01:56.680
Cool.

00:01:56.680 --> 00:01:59.840
So let's get started We'll start
at a very high level,

00:01:59.840 --> 00:02:02.810
just to give everyone who's not
already familiar with GTM

00:02:02.810 --> 00:02:06.180
for Mobile Apps an idea of
what this is all about.

00:02:06.180 --> 00:02:08.810
So Neil, can you give us an
overview of what are the

00:02:08.810 --> 00:02:11.470
problems that Tag Manager
for Mobile Apps

00:02:11.470 --> 00:02:13.020
was designed to solve?

00:02:13.020 --> 00:02:13.770
NEIL RHODES: Sure.

00:02:13.770 --> 00:02:17.080
So a big problem with mobile
apps is unlike, let's say, a

00:02:17.080 --> 00:02:20.530
web application, a mobile
application is really frozen.

00:02:20.530 --> 00:02:22.270
So you ship the application.

00:02:22.270 --> 00:02:26.200
Until you ship a new version, it
maintains its behavior and

00:02:26.200 --> 00:02:27.480
appearance.

00:02:27.480 --> 00:02:30.480
And that's part of what GTM
for Mobile Apps addresses.

00:02:30.480 --> 00:02:36.150
So the idea is normally
what happens is

00:02:36.150 --> 00:02:37.415
you ship a new version.

00:02:37.415 --> 00:02:39.380
In order to ship a new version,
you've got to secure

00:02:39.380 --> 00:02:41.790
approvals, either from your
own people or also from

00:02:41.790 --> 00:02:43.150
application stores.

00:02:43.150 --> 00:02:45.990
You've then got an upgrade
cycle, where people may or may

00:02:45.990 --> 00:02:47.290
not be upgrading.

00:02:47.290 --> 00:02:48.800
And so out in the field,
you've got a lot

00:02:48.800 --> 00:02:49.465
of different versions.

00:02:49.465 --> 00:02:52.550
We're not quite sure what
versions you have.

00:02:52.550 --> 00:02:56.660
What happens with GTM is we
actually go ahead and have a

00:02:56.660 --> 00:03:01.140
single representation of
configuration information

00:03:01.140 --> 00:03:03.690
that's stored up in the web,
and that gets downloaded to

00:03:03.690 --> 00:03:04.590
each container.

00:03:04.590 --> 00:03:07.550
So once you want to make
a change, that will get

00:03:07.550 --> 00:03:09.130
downloaded to your
application.

00:03:09.130 --> 00:03:12.710
And then your application has
access to these new values

00:03:12.710 --> 00:03:14.460
pretty much immediately.

00:03:14.460 --> 00:03:15.290
So what are the sorts
of things you

00:03:15.290 --> 00:03:16.470
might want to configure?

00:03:16.470 --> 00:03:18.110
Well, the first thing is you've
got to actually write

00:03:18.110 --> 00:03:20.800
your application so that it
is highly configurable.

00:03:20.800 --> 00:03:24.190
So if you've got things like how
often you want to show an

00:03:24.190 --> 00:03:27.530
ad, where you want to show an
ad, a host you need to talk to

00:03:27.530 --> 00:03:31.280
on a back end or a timeout in
talking to that host, if you

00:03:31.280 --> 00:03:35.250
have a game, how many points do
you get when you kill a bad

00:03:35.250 --> 00:03:39.680
guy, any URLs for help or
something else-- all of that's

00:03:39.680 --> 00:03:42.260
configurable, and really you
just need to make sure that in

00:03:42.260 --> 00:03:45.840
your application you have an
API call to get that value.

00:03:45.840 --> 00:03:48.530
So you pass in a string,
you get back a value.

00:03:48.530 --> 00:03:51.550
And the key point that GTM for
Mobile Apps provides is you're

00:03:51.550 --> 00:03:54.610
always getting the latest and
greatest value, not what's

00:03:54.610 --> 00:03:55.860
just locked into the
application.

00:03:58.820 --> 00:04:05.250
As well, GTM also provides
tagging, like its name says.

00:04:05.250 --> 00:04:09.650
So Google Tag Manager for Web
was intended to provide the

00:04:09.650 --> 00:04:12.640
ability to do tagging-- that is,
do things like analytics

00:04:12.640 --> 00:04:15.950
calls or AdWords conversion
calls or

00:04:15.950 --> 00:04:17.620
third-party type calls.

00:04:17.620 --> 00:04:21.209
And you just have to tag
your pages once.

00:04:21.209 --> 00:04:24.850
And then you can go ahead and
make changes using GTM and

00:04:24.850 --> 00:04:26.160
have those affected.

00:04:26.160 --> 00:04:29.030
The same thing is sort of
true on applications.

00:04:29.030 --> 00:04:34.680
So what you do is you add to
your application calls when

00:04:34.680 --> 00:04:37.240
anything interesting is
happening in your application.

00:04:37.240 --> 00:04:40.920
And then there's this level of
indirection so that later on

00:04:40.920 --> 00:04:42.980
you can go ahead and say when
this particular interesting

00:04:42.980 --> 00:04:44.720
thing happens, I want
to go ahead and make

00:04:44.720 --> 00:04:45.850
an analytics call.

00:04:45.850 --> 00:04:48.320
Or when this happens, I want to
make an AdWords conversion

00:04:48.320 --> 00:04:49.260
tracking call.

00:04:49.260 --> 00:04:53.640
Or when this happens, I want to
ping this particular URL,

00:04:53.640 --> 00:04:55.130
so hit this particular URL.

00:04:55.130 --> 00:04:57.410
So that's really the universal
analytics, the AdWords

00:04:57.410 --> 00:05:00.500
conversion tracking, and then
these custom image tags.

00:05:00.500 --> 00:05:02.560
As we'll see later on, there's
also the possibility of having

00:05:02.560 --> 00:05:04.900
just a custom function
that gets executed.

00:05:04.900 --> 00:05:09.400
So you have a call that happens
in your application

00:05:09.400 --> 00:05:12.810
based on rules that you
specified after the fact.

00:05:12.810 --> 00:05:13.040
ANDREW WALES: Great.

00:05:13.040 --> 00:05:16.110
So let's talk about working
with the Tag Manager SDK.

00:05:16.110 --> 00:05:19.070
And actually, this is part of
the analytic services SDK,

00:05:19.070 --> 00:05:22.270
which is Tag Manager and Google
Analytics combined into

00:05:22.270 --> 00:05:23.960
one package.

00:05:23.960 --> 00:05:27.950
So maybe we'll walk through some
of the basic tasks that

00:05:27.950 --> 00:05:29.700
you're going to want to do
with the SDK-- opening a

00:05:29.700 --> 00:05:34.370
container, getting configuration
values, pushing

00:05:34.370 --> 00:05:37.180
the data layer, and also
previewing a container.

00:05:37.180 --> 00:05:37.920
That's be great.

00:05:37.920 --> 00:05:38.460
NEIL RHODES: Sure.

00:05:38.460 --> 00:05:40.490
Well, what we've tried to do is
make this really as simple

00:05:40.490 --> 00:05:41.480
as possible.

00:05:41.480 --> 00:05:44.700
So first, initialization--

00:05:44.700 --> 00:05:46.270
the first thing you
do is actually

00:05:46.270 --> 00:05:47.390
just get the Tag Manager.

00:05:47.390 --> 00:05:49.380
So TagManager.getInstance.

00:05:49.380 --> 00:05:50.800
And from there, then,
you need to open

00:05:50.800 --> 00:05:52.070
a particular container.

00:05:52.070 --> 00:05:56.630
So a container is these
collections of macros, tags,

00:05:56.630 --> 00:05:58.620
and rules we'll talk about
a little bit later.

00:05:58.620 --> 00:06:02.290
But it's identified by a
particular container ID of the

00:06:02.290 --> 00:06:06.760
form GTM-dash some four, five,
or six-character sequence.

00:06:06.760 --> 00:06:10.550
So the first thing you do
is open your container.

00:06:10.550 --> 00:06:12.660
And you just provide
the container ID.

00:06:12.660 --> 00:06:13.940
You can provide a timeout.

00:06:13.940 --> 00:06:15.900
Although if you don't provide
one, a default

00:06:15.900 --> 00:06:17.480
is going to be used.

00:06:17.480 --> 00:06:19.260
That doesn't actually return.

00:06:19.260 --> 00:06:21.750
So let's make clear
what happens.

00:06:21.750 --> 00:06:24.680
When you are first running your
app for the very first

00:06:24.680 --> 00:06:27.580
time, there's been no
communication to the web.

00:06:27.580 --> 00:06:31.560
So you run your application, and
it needs to actually go to

00:06:31.560 --> 00:06:35.650
the web to get the current
version of a container.

00:06:35.650 --> 00:06:37.600
Now, we don't know how long
that's going to take, and we

00:06:37.600 --> 00:06:38.450
also don't even know
whether we're

00:06:38.450 --> 00:06:41.000
connected to the network.

00:06:41.000 --> 00:06:46.630
So what we do is when you call
openSaved, we return what's

00:06:46.630 --> 00:06:47.580
called a future--

00:06:47.580 --> 00:06:51.540
that is, in the background it's
going to be going through

00:06:51.540 --> 00:06:54.260
and doing its network
communication so that we don't

00:06:54.260 --> 00:06:57.460
stall while we're waiting
to open the container.

00:06:57.460 --> 00:06:59.510
While that's going on, you
could do additional

00:06:59.510 --> 00:07:02.230
initialization of your
application.

00:07:02.230 --> 00:07:04.700
And then when you're ready and
actually need a container

00:07:04.700 --> 00:07:07.490
value, you'll call
containerfuture.get, and that

00:07:07.490 --> 00:07:11.630
will, if necessary, wait until
the download has happened.

00:07:14.670 --> 00:07:17.780
Once you have a container,
four basic calls--

00:07:17.780 --> 00:07:21.740
you can getLong, getString,
getDouble, or getBoolean.

00:07:21.740 --> 00:07:24.060
You provide a string, and it
gives you back something of

00:07:24.060 --> 00:07:25.780
the same type.

00:07:25.780 --> 00:07:29.020
So if you have specified, for
instance, your timeout for

00:07:29.020 --> 00:07:32.560
talking to a backend host,
timeout in milliseconds, call

00:07:32.560 --> 00:07:36.420
container to getLong, and
that'll return that value, the

00:07:36.420 --> 00:07:39.180
latest and greatest value
that has been

00:07:39.180 --> 00:07:43.290
set up on the website.

00:07:43.290 --> 00:07:45.190
One thing just to point out
about that, actually--

00:07:45.190 --> 00:07:47.790
when you're calling getLong
or any of these get calls,

00:07:47.790 --> 00:07:50.050
there's no network communication
happening.

00:07:50.050 --> 00:07:52.770
So the network communication
has already happened.

00:07:52.770 --> 00:07:55.630
And we download the entire
container, and now we're just

00:07:55.630 --> 00:07:56.670
doing local calls.

00:07:56.670 --> 00:07:58.975
So these are not terribly
expensive calls.

00:08:02.290 --> 00:08:06.080
If you run your application
and there is no network

00:08:06.080 --> 00:08:06.860
connection--

00:08:06.860 --> 00:08:11.110
so let's say in fact your user
has never connected to the

00:08:11.110 --> 00:08:13.840
network, what value should
be used for this?

00:08:13.840 --> 00:08:17.210
You don't want to force that
your application has to be

00:08:17.210 --> 00:08:19.490
connected to the network the
first time you run, so

00:08:19.490 --> 00:08:21.210
therefore there's a
default container.

00:08:21.210 --> 00:08:24.230
And the default container
is a JSON file.

00:08:24.230 --> 00:08:28.320
Or you can also create your
container on the website and

00:08:28.320 --> 00:08:31.160
just download and use
that binary format.

00:08:31.160 --> 00:08:35.650
And that has initial values
for all of your keys that

00:08:35.650 --> 00:08:38.770
you've set up that you want to
be getting the values of.

00:08:38.770 --> 00:08:41.150
So that way when you ship your
application, you're shipping

00:08:41.150 --> 00:08:43.919
not just the application, you're
also shipping this

00:08:43.919 --> 00:08:45.440
default container.

00:08:45.440 --> 00:08:48.970
And that way your application
can run as is without any

00:08:48.970 --> 00:08:50.260
network connection.

00:08:50.260 --> 00:08:52.590
Once you make a network
connection-- so once a network

00:08:52.590 --> 00:08:54.985
connection happens and we
download a newer version of

00:08:54.985 --> 00:08:57.450
that container, that newer
version of the container will

00:08:57.450 --> 00:08:59.070
be used until there's
an even newer

00:08:59.070 --> 00:09:01.210
version of the container.

00:09:01.210 --> 00:09:03.760
And what happens is the
application or the SDK will

00:09:03.760 --> 00:09:07.880
check twice a day and see if
there's even a newer version.

00:09:07.880 --> 00:09:10.750
So normally, as long as there's
a network connection,

00:09:10.750 --> 00:09:13.650
you're no more than 12
hours out of date.

00:09:17.080 --> 00:09:19.400
The final calls you want to
make-- so the first ones we

00:09:19.400 --> 00:09:22.120
just saw are all you need
to do from within your

00:09:22.120 --> 00:09:27.200
application to access these
configuration values.

00:09:27.200 --> 00:09:30.680
The next thing you also
want to do is tagging.

00:09:30.680 --> 00:09:35.100
And tags are executed in
response to interesting things

00:09:35.100 --> 00:09:36.940
happening in your application.

00:09:36.940 --> 00:09:39.320
How do you specify an
interesting thing happening?

00:09:39.320 --> 00:09:41.130
You push to the data layer.

00:09:41.130 --> 00:09:45.810
So the data layer is a
collection of values which you

00:09:45.810 --> 00:09:51.080
can write to and which then the
GTM runtime can actually

00:09:51.080 --> 00:09:53.230
have access to.

00:09:53.230 --> 00:09:54.840
The data layer is used
for two things.

00:09:54.840 --> 00:09:57.500
So the first thing it's used
for is just to provide

00:09:57.500 --> 00:10:00.060
interesting runtime
information.

00:10:00.060 --> 00:10:03.160
As an example, you might want to
provide how many times does

00:10:03.160 --> 00:10:06.260
the user run this application,
if you might want to have some

00:10:06.260 --> 00:10:08.390
rule based on that.

00:10:08.390 --> 00:10:13.450
Or what's the user's lifetime
value, again, so that later on

00:10:13.450 --> 00:10:15.600
you can have rules that
deal with that.

00:10:15.600 --> 00:10:18.420
And then the second thing you
use the data layer for is

00:10:18.420 --> 00:10:20.060
pushing events.

00:10:20.060 --> 00:10:25.800
So an event is a map of values,
one of which has the

00:10:25.800 --> 00:10:26.710
name event.

00:10:26.710 --> 00:10:30.010
That's really what makes it
different from any other data

00:10:30.010 --> 00:10:31.530
layer push.

00:10:31.530 --> 00:10:36.820
And then once an event is
pushed, any associated tags

00:10:36.820 --> 00:10:42.910
that have been registered for
that event will get executed.

00:10:42.910 --> 00:10:45.620
As an example, then, you might
want to push an event here

00:10:45.620 --> 00:10:47.030
when you open a screen.

00:10:47.030 --> 00:10:49.610
So every time you go to a new
screen or new activity, when

00:10:49.610 --> 00:10:52.270
you open a dialogue, something
like that, push an event that

00:10:52.270 --> 00:10:54.780
says this is happening.

00:10:54.780 --> 00:10:57.410
You can add additional data,
as we have here--

00:10:57.410 --> 00:10:59.520
like, which screen name is it?

00:10:59.520 --> 00:11:02.510
And that'll be useful then when
you get to the actual tag

00:11:02.510 --> 00:11:06.310
so that you can specify
that screen name.

00:11:06.310 --> 00:11:08.980
This is also a cheap call, so
pushing to the data layer is

00:11:08.980 --> 00:11:10.160
quite inexpensive.

00:11:10.160 --> 00:11:13.170
If there are no tags that have
rules associated with that

00:11:13.170 --> 00:11:15.200
event, it's a very simple
and easy call.

00:11:15.200 --> 00:11:18.760
So you can afford to push data
layer events really any time

00:11:18.760 --> 00:11:22.530
anything interesting is
happening in your application.

00:11:22.530 --> 00:11:27.080
Everything else really happens
on the web side as you're

00:11:27.080 --> 00:11:28.900
editing your container
and creating

00:11:28.900 --> 00:11:30.860
rules, tags, and macros.

00:11:34.860 --> 00:11:36.340
Now, one thing that happens--

00:11:36.340 --> 00:11:40.910
let's say you make a change on
the website to update your

00:11:40.910 --> 00:11:43.630
container values.

00:11:43.630 --> 00:11:45.280
How do you know they're right?

00:11:45.280 --> 00:11:47.830
You don't really want to go
publish that container live to

00:11:47.830 --> 00:11:49.360
the world without testing it.

00:11:49.360 --> 00:11:52.660
And so the way to test
it is by previewing.

00:11:52.660 --> 00:11:54.510
The way preview happens
is on the website.

00:11:54.510 --> 00:11:57.530
You say, I want to preview the
container, and it'll give you

00:11:57.530 --> 00:11:58.740
the new URL.

00:11:58.740 --> 00:12:02.280
And you go to that URL on a
device, and you can see, how

00:12:02.280 --> 00:12:04.990
would this application act if
this particular version of the

00:12:04.990 --> 00:12:07.910
container were to be the
published version?

00:12:07.910 --> 00:12:10.490
So that's useful for you
to do debugging.

00:12:10.490 --> 00:12:13.100
It's useful if you hand off
to someone, like a product

00:12:13.100 --> 00:12:15.560
manager who wants to say, what's
this going to look like

00:12:15.560 --> 00:12:18.240
if I turn on these values,
and you can show them.

00:12:18.240 --> 00:12:21.810
And finally, it's also useful
for application stores if

00:12:21.810 --> 00:12:24.010
you're going through
a review process.

00:12:24.010 --> 00:12:26.800
You may want to show them,
look, here's my initial

00:12:26.800 --> 00:12:28.460
version of the application.

00:12:28.460 --> 00:12:33.060
And I have these other UI
alternatives that I may be

00:12:33.060 --> 00:12:34.780
turning on.

00:12:34.780 --> 00:12:39.430
And let me give you a URL to
show you what those different

00:12:39.430 --> 00:12:42.390
UI alternatives look like.

00:12:42.390 --> 00:12:44.720
So that way you don't have any
hidden features that you're

00:12:44.720 --> 00:12:48.710
trying to somehow sneak
by an app store.

00:12:52.350 --> 00:12:55.140
In order to preview a container,
you do need a

00:12:55.140 --> 00:12:56.770
little additional code.

00:12:56.770 --> 00:13:03.990
So in your main XML file, you
will need to add an activity

00:13:03.990 --> 00:13:09.350
that basically specifies, when
a certain URL occurs, go

00:13:09.350 --> 00:13:11.550
execute this preview activity.

00:13:11.550 --> 00:13:14.390
There's something similar that
happens on iOS as well.

00:13:17.940 --> 00:13:20.810
Once you're in the website,
you've chosen the version of

00:13:20.810 --> 00:13:23.090
the container, made your
changes, and then say you want

00:13:23.090 --> 00:13:28.900
to preview it, it will go ahead
and generate a URL along

00:13:28.900 --> 00:13:30.190
with a QR code.

00:13:30.190 --> 00:13:33.240
And then you can just go to your
device and scan that QR

00:13:33.240 --> 00:13:36.410
code or enter that URL.

00:13:36.410 --> 00:13:39.180
And then, as I say,
your application--

00:13:39.180 --> 00:13:41.260
from then on until your
application exits--

00:13:41.260 --> 00:13:44.540
will be using that version of
the container rather than the

00:13:44.540 --> 00:13:47.150
published version of
the container.

00:13:47.150 --> 00:13:50.170
ANDREW WALES: Let's talk a bit
about containers, tags, rules,

00:13:50.170 --> 00:13:51.280
and macros.

00:13:51.280 --> 00:13:53.340
And Neil, you've mentioned each
of these a couple times

00:13:53.340 --> 00:13:56.550
now in talking about how you
might want to configure your

00:13:56.550 --> 00:14:01.540
application to receive updated
configuration values or to

00:14:01.540 --> 00:14:03.900
fire tags, for example, when
you're pushing events to the

00:14:03.900 --> 00:14:05.370
data layer.

00:14:05.370 --> 00:14:06.690
So let's walk through
each of these four.

00:14:06.690 --> 00:14:08.290
Maybe you can give us some
more details about what

00:14:08.290 --> 00:14:11.550
exactly containers, tags,
rules, and macros are.

00:14:11.550 --> 00:14:13.370
NEIL RHODES: I'm happy to.

00:14:13.370 --> 00:14:18.250
So a container is a collection
of these values.

00:14:18.250 --> 00:14:20.890
The idea is you would normally
have one container for a

00:14:20.890 --> 00:14:25.200
website or one container
for an application.

00:14:25.200 --> 00:14:27.710
So if you publish three
different applications, you'd

00:14:27.710 --> 00:14:29.230
probably want to have
a container

00:14:29.230 --> 00:14:31.170
separate for each one.

00:14:31.170 --> 00:14:34.050
It's possible to have multiple
containers for an application,

00:14:34.050 --> 00:14:37.650
but that's not a very
common occurrence.

00:14:37.650 --> 00:14:40.810
So a container has a container
ID associated with it.

00:14:40.810 --> 00:14:43.280
And as you remember, when we
initialized our container, we

00:14:43.280 --> 00:14:45.970
provided that ID and
then got back that

00:14:45.970 --> 00:14:51.140
container on the device.

00:14:51.140 --> 00:14:53.170
For mobile, again, these
containers are

00:14:53.170 --> 00:14:54.640
updated twice a day.

00:14:54.640 --> 00:14:59.180
So when your application first
starts, it looks, sees what

00:14:59.180 --> 00:15:01.940
version of the container it
has and how old it is, and

00:15:01.940 --> 00:15:06.940
then goes and talks to a
back-end server to see whether

00:15:06.940 --> 00:15:08.130
there's a new version.

00:15:08.130 --> 00:15:10.520
If there is a new version,
it downloads it.

00:15:10.520 --> 00:15:12.140
If not, it waits.

00:15:12.140 --> 00:15:16.350
12 hours later, it'll try
and do that again.

00:15:16.350 --> 00:15:21.960
Tags, as I mentioned, are
evaluated when you push an

00:15:21.960 --> 00:15:23.800
event to the data layer.

00:15:23.800 --> 00:15:26.730
That's the only time tags ever
fire, is when events are

00:15:26.730 --> 00:15:28.030
pushed to the data layer.

00:15:28.030 --> 00:15:30.090
And they're only pushed to the
data layer when you've got a

00:15:30.090 --> 00:15:33.750
rule that associates a
particular tag with a

00:15:33.750 --> 00:15:36.450
particular event.

00:15:36.450 --> 00:15:39.750
Examples of tags include Google
Analytics tracking.

00:15:39.750 --> 00:15:40.670
What does this mean?

00:15:40.670 --> 00:15:42.570
Well, this means you can
actually take your mobile

00:15:42.570 --> 00:15:45.650
application and get rid
of all the explicit

00:15:45.650 --> 00:15:48.760
Google Analytics calls.

00:15:48.760 --> 00:15:52.650
Instead you want to
have pushes of

00:15:52.650 --> 00:15:54.860
events to the data layer.

00:15:54.860 --> 00:15:59.350
And then in the UI you're going
to set up, when this

00:15:59.350 --> 00:16:02.950
event happens, I want this
GA call to happen.

00:16:02.950 --> 00:16:04.200
That's a tag.

00:16:06.910 --> 00:16:10.585
As well, there are AdWords,
conversion remarketing tags in

00:16:10.585 --> 00:16:11.380
the same way.

00:16:11.380 --> 00:16:16.500
So this removes the requirement
for having to have

00:16:16.500 --> 00:16:21.260
explicit GA calls and then a new
SDK and explicit AdWords

00:16:21.260 --> 00:16:23.690
in conversion tracking calls.

00:16:23.690 --> 00:16:27.100
Instead, you have a unified
model where all you're doing

00:16:27.100 --> 00:16:28.880
is pushing events to
the data layer.

00:16:28.880 --> 00:16:31.790
And then you have a separate
place in the UI where you're

00:16:31.790 --> 00:16:35.805
associating as you want
those events for

00:16:35.805 --> 00:16:37.850
the particular tags--

00:16:37.850 --> 00:16:40.640
be it GA, be it AdWords.

00:16:40.640 --> 00:16:44.890
Other possibility, maybe you
have some back end that you're

00:16:44.890 --> 00:16:50.260
using, and you want particular
URLs to be hit when certain

00:16:50.260 --> 00:16:52.100
things happen in your
application.

00:16:52.100 --> 00:16:53.630
That's the idea of
a custom image.

00:16:53.630 --> 00:16:58.070
So you're actually, in the
UI, building up a URL.

00:16:58.070 --> 00:17:05.434
And that URL is going
to be retrieved.

00:17:05.434 --> 00:17:08.140
You'll do an HTTP get
on that URL--

00:17:08.140 --> 00:17:10.790
again, when an event occurs
that matches the

00:17:10.790 --> 00:17:13.069
rule for that tag.

00:17:13.069 --> 00:17:16.619
Finally, you can just have
arbitrary code executed.

00:17:16.619 --> 00:17:22.540
So you can actually in your
application register with the

00:17:22.540 --> 00:17:30.030
Tag Manager to say when you're
writing a particular function

00:17:30.030 --> 00:17:32.420
associated with a particular
function name.

00:17:32.420 --> 00:17:35.920
And so that can cause, then,
this indirection where you

00:17:35.920 --> 00:17:38.520
push an event to the data
layer, you have a rule

00:17:38.520 --> 00:17:42.140
associated with a particular
function tag that calls back

00:17:42.140 --> 00:17:43.880
into your application,
and then you can

00:17:43.880 --> 00:17:45.130
do something custom.

00:17:47.320 --> 00:17:52.680
Unlike on the web, tags in
applications can't be executed

00:17:52.680 --> 00:17:53.130
synchronously.

00:17:53.130 --> 00:17:56.760
That is, we can't actually do
the HTTP get necessarily

00:17:56.760 --> 00:17:57.740
immediately.

00:17:57.740 --> 00:17:59.430
And the reason for that is
your application may be

00:17:59.430 --> 00:18:03.600
running without any network
connectivity.

00:18:03.600 --> 00:18:07.020
So in all three of these first
cases, where we're dealing

00:18:07.020 --> 00:18:14.620
with URLs, the URL doesn't
actually get retrieved until

00:18:14.620 --> 00:18:15.970
we actually have
network access.

00:18:15.970 --> 00:18:19.650
So what happens is these URLs
get queued, and then we go

00:18:19.650 --> 00:18:23.420
ahead and about 15 minutes
later go ahead

00:18:23.420 --> 00:18:24.750
and retrieve those.

00:18:24.750 --> 00:18:27.930
Part of the advantage of that
is better battery usage,

00:18:27.930 --> 00:18:30.870
because we're clumping together
multiple tags and

00:18:30.870 --> 00:18:33.280
retrieving those all at once,
rather than doing that, let's

00:18:33.280 --> 00:18:36.720
say, once every five minutes.

00:18:36.720 --> 00:18:42.430
Macros are name value pairs, and
the values are determined

00:18:42.430 --> 00:18:44.270
at runtime.

00:18:44.270 --> 00:18:45.940
It's easy to see with some
pre-defined macros.

00:18:45.940 --> 00:18:50.730
So one macro, for instance, is
the language the user has set.

00:18:50.730 --> 00:18:53.890
Another is the version of
the operating system.

00:18:53.890 --> 00:18:54.850
Another is the platform.

00:18:54.850 --> 00:18:57.930
That is, are we on iOS
or are we on Android?

00:18:57.930 --> 00:19:03.900
So these are values that can
be retrieved at runtime and

00:19:03.900 --> 00:19:05.620
for which you can write
rules against.

00:19:05.620 --> 00:19:08.090
So you can write rules against
them, and you can also use any

00:19:08.090 --> 00:19:09.925
of these macro within a tag.

00:19:13.790 --> 00:19:16.280
Another important pre-defined
macro is a data layer macro.

00:19:16.280 --> 00:19:19.190
So this says, actually, I want
to retrieve a value from the

00:19:19.190 --> 00:19:20.220
data layer.

00:19:20.220 --> 00:19:24.150
So that provides a way to write
a rule that retrieves

00:19:24.150 --> 00:19:26.020
data from your application.

00:19:26.020 --> 00:19:28.390
So as long as your application
has put it in the data layer,

00:19:28.390 --> 00:19:30.290
you can have a macro, then,
that retrieves it from the

00:19:30.290 --> 00:19:32.570
data layer.

00:19:32.570 --> 00:19:36.810
Value collection macros are
special in that they are the

00:19:36.810 --> 00:19:39.600
way that we have these
configuration values that are

00:19:39.600 --> 00:19:41.130
accessible at runtime.

00:19:41.130 --> 00:19:46.470
So when you on your container
call getString or getBoolean,

00:19:46.470 --> 00:19:50.600
what we're looking for are
macros in the value

00:19:50.600 --> 00:19:52.490
collection.

00:19:52.490 --> 00:19:55.930
And we define basically JSON--

00:19:55.930 --> 00:20:01.660
so we have multiple key value
pairs on a hierarchy.

00:20:01.660 --> 00:20:04.690
Just like we had the function
tag where you have custom code

00:20:04.690 --> 00:20:07.330
in your application that
executes in response to

00:20:07.330 --> 00:20:10.590
pushing a particular event,
similarly, we have function

00:20:10.590 --> 00:20:15.740
macros, which are custom code
that executes for a particular

00:20:15.740 --> 00:20:17.290
macro you've registered.

00:20:17.290 --> 00:20:20.280
So you register you want to
handle some particular kind,

00:20:20.280 --> 00:20:22.180
and then when that kind happens,
it'll call back into

00:20:22.180 --> 00:20:26.060
your application and it'll
ask for a value.

00:20:26.060 --> 00:20:28.400
And then finally what
really puts it all

00:20:28.400 --> 00:20:30.650
together are the rules.

00:20:30.650 --> 00:20:34.300
So you specify rules for
when value collections

00:20:34.300 --> 00:20:36.160
are going to be active.

00:20:36.160 --> 00:20:37.830
So an example--

00:20:37.830 --> 00:20:40.910
well, we'll see an example,
when we look at our UI

00:20:40.910 --> 00:20:44.490
overview where you might have
one value if you're on a

00:20:44.490 --> 00:20:47.130
particular version of the
operating system and another

00:20:47.130 --> 00:20:49.410
value in a different version.

00:20:49.410 --> 00:20:53.900
What rules get to do is tests
macro values, so you can do

00:20:53.900 --> 00:20:57.730
both numerical comparisons as
well as string comparisons,

00:20:57.730 --> 00:21:00.660
like regexes and so on.

00:21:00.660 --> 00:21:03.180
For a given tag, you
can specify--

00:21:03.180 --> 00:21:06.810
it will execute if any of these
rules are true and as

00:21:06.810 --> 00:21:09.560
long as none of these other
rules are true.

00:21:09.560 --> 00:21:12.750
So you can have both enabling
and disabling or allowing and

00:21:12.750 --> 00:21:15.720
blocking rules.

00:21:15.720 --> 00:21:18.420
ANDREW WALES: Yeah, one
follow-up question, Neil,

00:21:18.420 --> 00:21:19.810
about function tags.

00:21:19.810 --> 00:21:23.260
So it gives you the
ability to--

00:21:23.260 --> 00:21:25.960
based on some event that's
pushed into the data layer, so

00:21:25.960 --> 00:21:28.480
something interesting happens
in the app, it lets you then

00:21:28.480 --> 00:21:32.890
create a rule that says, when
this event occurs, I want to

00:21:32.890 --> 00:21:34.255
call this particular function.

00:21:34.255 --> 00:21:35.200
NEIL RHODES: That's right.

00:21:35.200 --> 00:21:37.490
ANDREW WALES: But when you do
that, you're actually calling

00:21:37.490 --> 00:21:38.490
back into the app.

00:21:38.490 --> 00:21:42.760
You're not actually providing
code via the web interface

00:21:42.760 --> 00:21:43.230
that's going to run it.

00:21:43.230 --> 00:21:43.790
NEIL RHODES: That's
a good point.

00:21:43.790 --> 00:21:47.880
So yeah, when you have a
function tag, what's happening

00:21:47.880 --> 00:21:50.650
is the code has to be in your
application already.

00:21:50.650 --> 00:21:54.540
So you have to have prepared
your application to have this

00:21:54.540 --> 00:21:55.830
custom function.

00:21:55.830 --> 00:21:57.380
an example where you might
want to have this custom

00:21:57.380 --> 00:22:00.370
function would be, let's say
you have a third-party SDK

00:22:00.370 --> 00:22:04.210
that does some other form of
tracking that GTM doesn't

00:22:04.210 --> 00:22:05.820
currently support.

00:22:05.820 --> 00:22:10.080
So you could go ahead and have
a custom function that calls

00:22:10.080 --> 00:22:13.460
into that third-party SDK, and
then you can write rules, just

00:22:13.460 --> 00:22:15.820
as you normally would for GA.

00:22:15.820 --> 00:22:16.080
ANDREW WALES: Right.

00:22:16.080 --> 00:22:17.660
So that would be way
to extend it.

00:22:17.660 --> 00:22:21.750
So if you're not using GA or if
you want to use something

00:22:21.750 --> 00:22:23.770
else, you could use these
function tags to enforce that.

00:22:23.770 --> 00:22:25.080
NEIL RHODES: Exactly.

00:22:25.080 --> 00:22:25.730
ANDREW WALES: Cool.

00:22:25.730 --> 00:22:27.120
So let's actually take a look
at the web interface where

00:22:27.120 --> 00:22:30.500
you're going to be creating
all of these containers,

00:22:30.500 --> 00:22:33.350
macros, tags, and rules.

00:22:33.350 --> 00:22:35.730
So Neil, I think you can give us
a little run through on the

00:22:35.730 --> 00:22:37.450
UI if we can switch
to your screen.

00:22:37.450 --> 00:22:40.040
NEIL RHODES: Sure,
I'd be happy to.

00:22:40.040 --> 00:22:44.060
So google.com/tagmanager
is where we're at.

00:22:44.060 --> 00:22:44.800
And I'm going to go ahead--

00:22:44.800 --> 00:22:46.490
I've already created
an account.

00:22:46.490 --> 00:22:48.520
I'm going to create
a container.

00:22:48.520 --> 00:22:50.020
So containers all have names.

00:22:50.020 --> 00:22:51.370
This is just for your use.

00:22:51.370 --> 00:22:55.150
I'm going to call it GDL Demo.

00:22:55.150 --> 00:22:56.820
And as you can see, there are
two different kinds of

00:22:56.820 --> 00:22:57.480
containers--

00:22:57.480 --> 00:22:59.455
those for web pages and
those for mobile apps.

00:22:59.455 --> 00:23:02.910
We, of course, are interested
in mobile apps here.

00:23:02.910 --> 00:23:04.680
And we're going to go ahead
and have this container

00:23:04.680 --> 00:23:08.590
support both Android and iOS.

00:23:08.590 --> 00:23:11.860
Now, you can share a container
between your iOS and your

00:23:11.860 --> 00:23:14.700
Android app, and you'd want to
do so if they are fairly

00:23:14.700 --> 00:23:16.080
similar to each other.

00:23:16.080 --> 00:23:19.990
If they're using completely
different sorts of tagging and

00:23:19.990 --> 00:23:22.420
different sorts of configuration
values, then you

00:23:22.420 --> 00:23:25.300
really want to have two
separate containers.

00:23:25.300 --> 00:23:27.570
In this case, we're
going to use one.

00:23:27.570 --> 00:23:31.150
And you can see we can
now download the SDK.

00:23:31.150 --> 00:23:35.140
As Andrew mentioned, it's a
combined Google Analytics and

00:23:35.140 --> 00:23:37.890
Google Tag Manager SDK.

00:23:37.890 --> 00:23:39.320
I don't need to do that right
now because we're just

00:23:39.320 --> 00:23:41.510
looking at the UI.

00:23:41.510 --> 00:23:43.190
And we can now configure
the container.

00:23:43.190 --> 00:23:44.480
So in fact, let's just
look at what the

00:23:44.480 --> 00:23:46.210
container has already.

00:23:46.210 --> 00:23:47.790
It has a rule--

00:23:47.790 --> 00:23:50.630
always, which is basically a
rule that's always true--

00:23:50.630 --> 00:23:55.440
and then a bunch of macros for
all of the built-in things,

00:23:55.440 --> 00:23:57.830
like finding out the application
ID, the name of

00:23:57.830 --> 00:24:03.270
the version, finding out what
device name we are on, the

00:24:03.270 --> 00:24:11.036
language, ID for advertising,
and resolutions and so on.

00:24:11.036 --> 00:24:14.900
What I'd like to do is
create a new macro.

00:24:14.900 --> 00:24:18.710
I want to do some configuration
in my

00:24:18.710 --> 00:24:24.250
application to be able
to get a string.

00:24:24.250 --> 00:24:28.310
So this is going to be my
configuration values.

00:24:28.310 --> 00:24:31.310
And I'm going to create
a value collection.

00:24:31.310 --> 00:24:35.155
In this value collection,
we're going to have--

00:24:35.155 --> 00:24:37.290
so what are we going
to be customizing?

00:24:37.290 --> 00:24:39.360
Well, actually, let's
not get a string.

00:24:39.360 --> 00:24:40.130
Let's get a Boolean.

00:24:40.130 --> 00:24:43.700
So I've got a new UI
element that I want

00:24:43.700 --> 00:24:44.720
to be able to display.

00:24:44.720 --> 00:24:45.970
So enableMyNewUIFeature.

00:24:48.840 --> 00:24:55.810
Feature And we're going to set
that to be false, because we

00:24:55.810 --> 00:25:00.020
don't want people to actually
see this new UI feature yet.

00:25:00.020 --> 00:25:05.740
And then we also have a back-end
timeout value for a

00:25:05.740 --> 00:25:13.320
back-end server we talk to
of 2,000 milliseconds.

00:25:13.320 --> 00:25:15.910
So this specifies a value
collection, however we need to

00:25:15.910 --> 00:25:17.950
also specify rules for it.

00:25:17.950 --> 00:25:22.990
If we don't specify any rules,
it won't have any effect.

00:25:22.990 --> 00:25:25.100
I'm going to go ahead and create
an enabling rule which

00:25:25.100 --> 00:25:30.190
says it's always true
and say this.

00:25:30.190 --> 00:25:32.350
So as I look at my overview,
I can see I now have my

00:25:32.350 --> 00:25:36.230
configuration values, and I can
see what I have set up.

00:25:36.230 --> 00:25:38.300
What's the next thing to do?

00:25:38.300 --> 00:25:40.090
Create a version.

00:25:40.090 --> 00:25:41.940
And I can go ahead
and publish it.

00:25:41.940 --> 00:25:45.870
So that means that my
application out there will now

00:25:45.870 --> 00:25:49.180
be using this value.

00:25:49.180 --> 00:25:53.400
Let's create a modification
list.

00:25:53.400 --> 00:25:57.740
Let's actually make it so it's
targeted as to when this

00:25:57.740 --> 00:26:01.720
feature is on or off.

00:26:01.720 --> 00:26:03.640
So I'm going to create
a macro.

00:26:03.640 --> 00:26:05.470
Let's call this enableUIFeature.

00:26:09.880 --> 00:26:15.690
Let's disable it on iOS, and
we'll enable it on Android.

00:26:20.860 --> 00:26:22.850
So I'm going to go ahead
and set this--

00:26:22.850 --> 00:26:26.780
let's see, I want
iOS to be false.

00:26:26.780 --> 00:26:28.690
And when is this going
to be true?

00:26:28.690 --> 00:26:30.610
This is going to
be true on iOS.

00:26:30.610 --> 00:26:32.740
I don't have a rule for iOS,
but I can create one.

00:26:37.300 --> 00:26:39.540
And what I can do is look
at the platform.

00:26:39.540 --> 00:26:49.810
So if the platform is equal to
iOS, then that rule is true.

00:26:49.810 --> 00:26:55.860
And if this rule is true, this
macro is going to be true.

00:26:55.860 --> 00:26:58.530
Therefore, it's going to
be used, I should say.

00:27:02.450 --> 00:27:06.430
And I want to create also a
version of this for Android.

00:27:06.430 --> 00:27:08.605
So enabled on Android.

00:27:11.990 --> 00:27:13.610
So enable the UI feature.

00:27:20.324 --> 00:27:23.840
And this was-- now, I have to
make sure to get this right--

00:27:23.840 --> 00:27:25.090
enableUIFeature.

00:27:29.380 --> 00:27:30.590
When do we want this
to be true?

00:27:30.590 --> 00:27:33.120
Well, we want this to be
true only in Android.

00:27:33.120 --> 00:27:36.290
We could write a separate on
Android rule, or we can take

00:27:36.290 --> 00:27:37.820
advantage of the disabling
rules.

00:27:37.820 --> 00:27:41.500
So we can say it's always going
to be true, except we're

00:27:41.500 --> 00:27:43.060
disabling it when it's on iOS.

00:27:47.550 --> 00:27:53.510
So we now have enable the UI
feature on iOS, and enable the

00:27:53.510 --> 00:27:55.100
UI feature on Android.

00:27:55.100 --> 00:27:57.060
And you can see here, I've
spelled one of them wrong.

00:27:57.060 --> 00:27:59.600
One is enable my new UI feature,
and one is just

00:27:59.600 --> 00:28:00.960
enable UI feature.

00:28:00.960 --> 00:28:03.680
So I better go edit that to make
sure they're the same.

00:28:08.950 --> 00:28:12.040
And the last change we want to
make is we actually have some

00:28:12.040 --> 00:28:13.370
overlap right now.

00:28:13.370 --> 00:28:18.300
So enable my new UI feature, if
we're on iOS, is going to

00:28:18.300 --> 00:28:21.590
be false due to this macro, but
it's actually going to be

00:28:21.590 --> 00:28:24.150
true due to my configuration
values.

00:28:24.150 --> 00:28:27.610
And we really don't want
to multiply specify.

00:28:27.610 --> 00:28:29.810
So we just want to remove
it from here.

00:28:34.210 --> 00:28:35.530
So what do we have set up?

00:28:35.530 --> 00:28:39.270
Now back-end timeout is going to
be 2,000 on all platforms,

00:28:39.270 --> 00:28:42.630
enable my new UI feature is
going to be false on iOS, and

00:28:42.630 --> 00:28:45.760
it's going to be true on
anything but iOS--

00:28:45.760 --> 00:28:49.150
in this case, that's
just Android.

00:28:49.150 --> 00:28:53.160
OK, so let's go ahead and look
at creating a tag to call

00:28:53.160 --> 00:28:56.940
Google Analytics when a new
screen occurs-- that is, when

00:28:56.940 --> 00:29:01.460
we have an event for
tracking a screen.

00:29:01.460 --> 00:29:06.026
So this is going to be, let's
say, our GA screen view.

00:29:06.026 --> 00:29:09.140
And we're going to use
Universal Analytics.

00:29:09.140 --> 00:29:12.370
We need to provide a course for
Google Analytics to the

00:29:12.370 --> 00:29:15.190
tracking ID.

00:29:15.190 --> 00:29:18.850
I'm of course not putting in
a real tracking ID here.

00:29:18.850 --> 00:29:20.210
And what do we want to do?

00:29:20.210 --> 00:29:22.690
We want the tracking type--
so again, this is just for

00:29:22.690 --> 00:29:23.540
universal analytics.

00:29:23.540 --> 00:29:26.670
What are the different types of
things that you can track?

00:29:26.670 --> 00:29:28.220
In our case, we're going
to track an app view.

00:29:31.540 --> 00:29:33.160
And what do we want to track?

00:29:33.160 --> 00:29:35.240
Well, we want to provide
the app name.

00:29:35.240 --> 00:29:38.060
Rather than typing in the app
name here, it's a little more

00:29:38.060 --> 00:29:41.490
flexible to go ahead and use the
pre-existing macro for the

00:29:41.490 --> 00:29:48.200
app name that's going to get
it from the actual APK.

00:29:48.200 --> 00:29:50.410
Similarly for that version.

00:29:50.410 --> 00:29:52.030
Now, the screen name, where
do we get that?

00:29:52.030 --> 00:29:53.670
That's not a fixed value.

00:29:53.670 --> 00:29:56.310
If you remember, when we pushed
to the data layer, we

00:29:56.310 --> 00:30:01.460
pushed a map containing an
event, map to open screen, and

00:30:01.460 --> 00:30:03.970
screen name mapped to whatever
the name of the screen was.

00:30:03.970 --> 00:30:07.260
So we actually want from
the data layer

00:30:07.260 --> 00:30:08.510
a screen name value.

00:30:11.530 --> 00:30:12.620
That's not pre-defined.

00:30:12.620 --> 00:30:15.320
We're going to have
to create it.

00:30:15.320 --> 00:30:17.750
So we can have a data
layer value here.

00:30:17.750 --> 00:30:21.100
And this is going to
be a screen name.

00:30:21.100 --> 00:30:24.800
And this name here, the delayed
variable name, that's

00:30:24.800 --> 00:30:27.740
exactly the name that we used
when we pushed the event.

00:30:36.340 --> 00:30:38.110
So we've set up what the tag's
going to look like.

00:30:38.110 --> 00:30:40.660
We're going to be doing an app
view tag, and it's going to

00:30:40.660 --> 00:30:43.390
have the app name, app version,
and screen name, and

00:30:43.390 --> 00:30:45.290
that's all we really need.

00:30:45.290 --> 00:30:48.502
However, now we need a rule
when we fire this.

00:30:48.502 --> 00:30:50.660
Do we want it always?

00:30:50.660 --> 00:30:53.430
No, that would say on every
single event that gets pushed

00:30:53.430 --> 00:30:55.300
to the data layer,
this would fire.

00:30:55.300 --> 00:30:57.330
And that's not really
appropriate.

00:30:57.330 --> 00:30:58.670
We don't want an iOS.

00:30:58.670 --> 00:30:59.920
We need a new rule.

00:31:01.960 --> 00:31:09.845
So this is going to be on
an open screen event.

00:31:12.430 --> 00:31:14.270
So how do we tell when it's
an open screen event?

00:31:14.270 --> 00:31:21.300
Well, that is if the event
is equal to open screen.

00:31:21.300 --> 00:31:27.330
And again, open screen was the
name that we used when we

00:31:27.330 --> 00:31:30.490
actually pushed the
data layer event.

00:31:34.900 --> 00:31:42.080
So your application is going to
call the data layer push.

00:31:42.080 --> 00:31:46.570
It'll be pushing an event called
open screen with a

00:31:46.570 --> 00:31:49.200
screen name called
home screen.

00:31:49.200 --> 00:31:51.310
This rule is going to make
sure that this tag guess

00:31:51.310 --> 00:31:57.120
fired, and the screen data layer
macro is going to pull

00:31:57.120 --> 00:31:58.620
that screen name from
that push value.

00:32:03.390 --> 00:32:05.470
So from here we can create
a version, and

00:32:05.470 --> 00:32:06.310
we can publish it.

00:32:06.310 --> 00:32:10.090
But as I mentioned, let's say
we want to test it first.

00:32:10.090 --> 00:32:12.880
So we can go ahead
and use preview.

00:32:12.880 --> 00:32:15.210
And here we knew the name
of the application.

00:32:15.210 --> 00:32:19.850
This name has to match what is
in your XML file that was

00:32:19.850 --> 00:32:24.850
associated with setting up
the preview activity.

00:32:24.850 --> 00:32:27.930
So I'm going to just call it my
app for right now, and it

00:32:27.930 --> 00:32:30.130
generates a preview link.

00:32:30.130 --> 00:32:32.960
So basically what we need
to do in the device

00:32:32.960 --> 00:32:35.130
is go to this link--

00:32:35.130 --> 00:32:38.040
or alternatively scan
this QR code--

00:32:38.040 --> 00:32:40.470
and that will then start using
this version of the container

00:32:40.470 --> 00:32:45.120
we just created that has the
extra tag and also has a

00:32:45.120 --> 00:32:47.716
differential UI future
based on whether

00:32:47.716 --> 00:32:50.750
on iOS or on Android.

00:32:50.750 --> 00:32:56.070
Once we're happy with it, then
we can go ahead and publish.

00:32:56.070 --> 00:32:58.300
The last thing I want to show
you is Download here.

00:32:58.300 --> 00:33:02.940
So Download is actually going
to download this version of

00:33:02.940 --> 00:33:03.860
the container.

00:33:03.860 --> 00:33:06.630
And this can then be used as
your default container.

00:33:06.630 --> 00:33:08.870
So not only can you have a
default container that just

00:33:08.870 --> 00:33:11.770
contains values, you can also
have a default container that

00:33:11.770 --> 00:33:14.990
needs values, tags,
rules, macros--

00:33:14.990 --> 00:33:17.320
the whole shebang.

00:33:17.320 --> 00:33:18.470
ANDREW WALES: And I think that's
an important point.

00:33:18.470 --> 00:33:23.510
Because if you have rules set
up, for example, or tags, and

00:33:23.510 --> 00:33:27.500
you want to have a default
container that has all those

00:33:27.500 --> 00:33:29.870
things, then you should use
the binary version.

00:33:29.870 --> 00:33:31.800
Obviously the JSON version
is not going to be

00:33:31.800 --> 00:33:33.030
sufficient in that case.

00:33:33.030 --> 00:33:35.210
NEIL RHODES: Yeah, the JSON
version might be OK if you

00:33:35.210 --> 00:33:37.880
just have configuration
type values.

00:33:37.880 --> 00:33:41.130
But if you're doing tagging,
then you probably really do

00:33:41.130 --> 00:33:45.220
want to go ahead and have an
initial set of tags that are

00:33:45.220 --> 00:33:47.590
pre-configured in your
application.

00:33:47.590 --> 00:33:49.690
And then you can always go ahead
and override those by

00:33:49.690 --> 00:33:51.240
going to the UI.

00:33:51.240 --> 00:33:51.530
ANDREW WALES: Great.

00:33:51.530 --> 00:33:55.520
So that brings us towards
the end of the program.

00:33:55.520 --> 00:33:59.260
I did want to pass off some
resources to you guys.

00:33:59.260 --> 00:34:02.700
But before we did to that, I
just want to quickly recap

00:34:02.700 --> 00:34:04.920
what we talked about, because
Neil just ran through a whole

00:34:04.920 --> 00:34:06.700
bunch of information.

00:34:06.700 --> 00:34:10.219
And I want to make sure that
it's not lost on anybody how

00:34:10.219 --> 00:34:12.020
powerful this stuff can be.

00:34:12.020 --> 00:34:15.520
So we talked a little bit
about being able to push

00:34:15.520 --> 00:34:20.110
configuration values to your
app via this web interface.

00:34:20.110 --> 00:34:24.120
And Neil, this basically means
that you can actually update

00:34:24.120 --> 00:34:27.469
your app in the wild, in
the hands of users.

00:34:27.469 --> 00:34:29.429
And it's under 12
hours, right?

00:34:29.429 --> 00:34:30.030
NEIL RHODES: That's right.

00:34:30.030 --> 00:34:33.659
ANDREW WALES: And that's much
quicker than having to rebuild

00:34:33.659 --> 00:34:36.840
the app, resubmit it for review,
and then follow that

00:34:36.840 --> 00:34:40.694
long tail out of adoption as
people decide to update the

00:34:40.694 --> 00:34:42.719
app or not.

00:34:42.719 --> 00:34:44.510
On that point, is there any--

00:34:44.510 --> 00:34:45.560
some people might be
wondering, does

00:34:45.560 --> 00:34:48.699
this cause any issues--

00:34:48.699 --> 00:34:51.820
when you submit your app to be
approved or reviewed and

00:34:51.820 --> 00:34:54.840
approved by Google or Apple or
somebody else, does this is

00:34:54.840 --> 00:34:57.010
cause any issues to
have this kind of

00:34:57.010 --> 00:34:58.930
logic with Tag Manager?

00:34:58.930 --> 00:35:01.800
You mentioned the preview URLs
were one way to solve that.

00:35:01.800 --> 00:35:03.810
NEIL RHODES: That's really
the way to deal with.

00:35:03.810 --> 00:35:09.930
We do not recommend that you
have inside your application

00:35:09.930 --> 00:35:13.930
different features or different
UI that's sort of

00:35:13.930 --> 00:35:19.410
hidden behind a flag
that you don't tell

00:35:19.410 --> 00:35:21.420
Google or Apple about.

00:35:21.420 --> 00:35:24.400
And the way to expose that and
allow them to look at it is

00:35:24.400 --> 00:35:25.720
really with those
preview links.

00:35:25.720 --> 00:35:27.420
So you could actually have
multiple preview

00:35:27.420 --> 00:35:28.700
links if you want.

00:35:28.700 --> 00:35:31.170
You have five different
features, let's say, and you

00:35:31.170 --> 00:35:33.240
might go ahead and have five
different preview links and

00:35:33.240 --> 00:35:37.070
just say, here's these things
that could be exposed in the

00:35:37.070 --> 00:35:40.100
future or even tell them when
they would be exposed.

00:35:40.100 --> 00:35:41.610
ANDREW WALES: And then when
you're ready to make them go

00:35:41.610 --> 00:35:44.720
live, it's just enabling it in
the interface and that's

00:35:44.720 --> 00:35:46.221
pretty much it.

00:35:46.221 --> 00:35:47.930
That's very cool.

00:35:47.930 --> 00:35:49.450
The other thing we talked
about, not just getting

00:35:49.450 --> 00:35:54.170
configuration values from the
web, but also tagging.

00:35:54.170 --> 00:35:57.260
So you can create these tags
that will basically--

00:35:57.260 --> 00:36:00.380
when interesting things happen
in the app, you can have this

00:36:00.380 --> 00:36:01.300
layer of indirection--

00:36:01.300 --> 00:36:04.110
which you called it, Neil--
where you push the events into

00:36:04.110 --> 00:36:06.510
the data layer, and then you
decide what you want to do

00:36:06.510 --> 00:36:07.550
when those events get fired.

00:36:07.550 --> 00:36:11.560
So maybe you want to fire some
analytics tags, or maybe you

00:36:11.560 --> 00:36:16.340
want to track an AdWords
conversion, and so forth.

00:36:16.340 --> 00:36:17.150
Maybe one question--

00:36:17.150 --> 00:36:18.825
I know some people might
be wondering--

00:36:18.825 --> 00:36:24.130
and you talked about it a little
bit, but obviously

00:36:24.130 --> 00:36:25.870
there's going to be some people
who are uneasy about

00:36:25.870 --> 00:36:30.640
the idea of it might slow down
the application, for example,

00:36:30.640 --> 00:36:33.400
to be pushing things into
the data layer.

00:36:33.400 --> 00:36:36.100
Or even just refreshing the
container in general--

00:36:36.100 --> 00:36:39.120
I might be concerned with the
app starts up, how long is

00:36:39.120 --> 00:36:39.850
that going to take?

00:36:39.850 --> 00:36:41.850
Is it going to block?

00:36:41.850 --> 00:36:44.690
What if I have UI values that I
need right away, and I don't

00:36:44.690 --> 00:36:46.980
want to see the screen shifting
in front of anybody

00:36:46.980 --> 00:36:48.850
as the values change or
anything like that?

00:36:48.850 --> 00:36:52.250
Can you just speak generally to

00:36:52.250 --> 00:36:55.410
anybody's performance concerns?

00:36:55.410 --> 00:36:55.990
NEIL RHODES: Sure.

00:36:55.990 --> 00:36:58.290
So there are a couple aspect.

00:36:58.290 --> 00:37:01.340
So let's start with the
easier ones first.

00:37:01.340 --> 00:37:04.640
So getting a value, when you
make a get call, getString or

00:37:04.640 --> 00:37:07.050
so on, those are really
very fast.

00:37:07.050 --> 00:37:10.740
All they're doing is evaluating
a subset of small

00:37:10.740 --> 00:37:16.550
rules and then figuring out what
to do and returning that.

00:37:16.550 --> 00:37:21.810
Pushing to the data layer is
also relatively quick, in that

00:37:21.810 --> 00:37:24.095
first it's just looking
and seeing--

00:37:24.095 --> 00:37:27.490
well, first off, if there's no
event, nothing gets executed.

00:37:27.490 --> 00:37:31.260
Well, no specific extra
code gets executed.

00:37:31.260 --> 00:37:33.600
It writes to a data layer, which
is very simple in memory

00:37:33.600 --> 00:37:35.740
data structure.

00:37:35.740 --> 00:37:39.700
If it's an event, we look and
see, are there any tags

00:37:39.700 --> 00:37:42.180
associated with that for which
we have to try to figure out

00:37:42.180 --> 00:37:43.480
the rules and so on.

00:37:43.480 --> 00:37:46.010
And if so, same simple
rule evaluation.

00:37:46.010 --> 00:37:48.150
And then tag execution
is fairly quick.

00:37:48.150 --> 00:37:51.040
So it's not, for instance,
like our tags are

00:37:51.040 --> 00:37:52.510
synchronously waiting
and trying to

00:37:52.510 --> 00:37:54.300
send over the network.

00:37:54.300 --> 00:37:57.680
Really, we just quickly store
it and then later on in a

00:37:57.680 --> 00:37:59.470
separate thread, that's
going to be sent.

00:37:59.470 --> 00:38:01.510
ANDREW WALES: How long do
those stay queued up?

00:38:01.510 --> 00:38:04.320
So if the device doesn't
have connection, a

00:38:04.320 --> 00:38:06.000
couple tags are fired.

00:38:06.000 --> 00:38:08.480
We queue up those requests.

00:38:08.480 --> 00:38:11.230
And then if somewhere were to,
for example, close the app and

00:38:11.230 --> 00:38:14.810
restart it, would it then make
those requests, or are they

00:38:14.810 --> 00:38:16.660
gone after the app is closed?

00:38:16.660 --> 00:38:19.900
NEIL RHODES: So couple
different answers--

00:38:19.900 --> 00:38:23.490
the short answer is no,
they do stay there.

00:38:23.490 --> 00:38:25.690
So we save them in a
persistent storage.

00:38:25.690 --> 00:38:27.850
And when the application
reopens, then we would try to

00:38:27.850 --> 00:38:29.150
resend them again.

00:38:29.150 --> 00:38:32.520
It's not even so bad as that on
Android, because on Android

00:38:32.520 --> 00:38:35.730
your application, even when
you leave the application,

00:38:35.730 --> 00:38:37.920
it's normally still running
in the background.

00:38:37.920 --> 00:38:41.200
And so it should
still be sent.

00:38:41.200 --> 00:38:44.700
It's only if your application
actually forcibly quit, if

00:38:44.700 --> 00:38:46.810
you're sort of memory or
something like that, that we

00:38:46.810 --> 00:38:48.290
would then have to wait until
the next time the

00:38:48.290 --> 00:38:51.040
application was run.

00:38:51.040 --> 00:38:54.480
As far as the container opening,
you really have to

00:38:54.480 --> 00:39:02.970
decide how important it is, for
one thing, that you get

00:39:02.970 --> 00:39:06.980
the current version of the
container before you

00:39:06.980 --> 00:39:08.930
display your UI.

00:39:08.930 --> 00:39:11.670
One possibility-- and we have an
example of this-- is have a

00:39:11.670 --> 00:39:12.720
splash screen.

00:39:12.720 --> 00:39:15.830
So have a quick splash screen
that then can-- you can do all

00:39:15.830 --> 00:39:17.410
of your initialization
including container

00:39:17.410 --> 00:39:18.440
initialization.

00:39:18.440 --> 00:39:19.885
And once the container
is there, you

00:39:19.885 --> 00:39:21.790
can continue forward.

00:39:21.790 --> 00:39:24.120
In some extreme examples, you
might say if I can't get a

00:39:24.120 --> 00:39:27.310
container from the network
I don't want to run.

00:39:27.310 --> 00:39:30.220
That would be an extreme case.

00:39:30.220 --> 00:39:33.460
If you're just using your
container for things like host

00:39:33.460 --> 00:39:36.220
names or values or things like
that, you probably want to go

00:39:36.220 --> 00:39:39.560
ahead and issue the request to
get the container and then

00:39:39.560 --> 00:39:40.830
continue on your way.

00:39:40.830 --> 00:39:43.020
And when it comes in, you'll
get those values.

00:39:43.020 --> 00:39:45.800
And if not, you'll revert
to the default.

00:39:45.800 --> 00:39:48.620
If you've got a UI issue, where
for instance you have a

00:39:48.620 --> 00:39:52.420
complete new UI based on the
version of the container,

00:39:52.420 --> 00:39:54.420
that's the case where you
probably want to wait.

00:39:54.420 --> 00:39:57.640
Because it would look kind of
funny to use the default

00:39:57.640 --> 00:40:01.430
version, which might have UI
version A, and then when the

00:40:01.430 --> 00:40:03.740
container actually downloads and
says to use version B, you

00:40:03.740 --> 00:40:06.240
suddenly start switching to
version B. So I think that's

00:40:06.240 --> 00:40:07.520
the flashing you talked about.

00:40:07.520 --> 00:40:11.390
ANDREW WALES: But that's kind
of important to notice that

00:40:11.390 --> 00:40:15.560
you could actually ship a whole
new UI by pushing all

00:40:15.560 --> 00:40:17.060
these updated configuration
values.

00:40:17.060 --> 00:40:20.030
It kind of speaks to the power
of the product that you could

00:40:20.030 --> 00:40:21.350
actually do that.

00:40:21.350 --> 00:40:24.910
NEIL RHODES: Well, yes and no.

00:40:24.910 --> 00:40:27.730
You're the one that was having
to do it in your application.

00:40:27.730 --> 00:40:32.860
So if you have two different
versions of your UI, maybe all

00:40:32.860 --> 00:40:34.890
it is is you just have a Boolean
that you're sending

00:40:34.890 --> 00:40:36.900
down, and you have a
lot of code there.

00:40:36.900 --> 00:40:39.030
On the other hand, you could
also make it fairly

00:40:39.030 --> 00:40:41.870
configurable and send down all
sorts of information, like

00:40:41.870 --> 00:40:44.940
what belongs on a particular
screen or how it's laid out.

00:40:44.940 --> 00:40:48.740
It could be quite
configurable.

00:40:48.740 --> 00:40:51.240
So the Google Analytics app,
in fact, takes advantage of

00:40:51.240 --> 00:40:52.720
that, the mobile application.

00:40:52.720 --> 00:40:55.950
They go ahead and have a very
configurable information they

00:40:55.950 --> 00:40:59.860
said down via GTM, and they can
add new reports, remove

00:40:59.860 --> 00:41:02.890
reports, modify reports,
all using GTM.

00:41:02.890 --> 00:41:06.600
And it'll just affect all of the
applications in the wild.

00:41:06.600 --> 00:41:08.830
ANDREW WALES: And in about
12 hours or so.

00:41:08.830 --> 00:41:10.400
Very cool.

00:41:10.400 --> 00:41:11.115
Awesome.

00:41:11.115 --> 00:41:14.590
Well, I think that brings us
to the end of the time.

00:41:14.590 --> 00:41:16.650
Just a few resources--

00:41:16.650 --> 00:41:19.180
obviously, if you want to just
get started with the product,

00:41:19.180 --> 00:41:20.070
you can just go right to it.

00:41:20.070 --> 00:41:22.360
It's google.com/tagmanager.

00:41:22.360 --> 00:41:25.500
We also have getting started
guides for Android and iOS.

00:41:25.500 --> 00:41:27.930
A lot of the examples we gave
today and a lot of the code we

00:41:27.930 --> 00:41:30.440
showed was specific to Android,
but there are

00:41:30.440 --> 00:41:31.640
equivalents for everything
that we

00:41:31.640 --> 00:41:33.890
showed for iOS as well.

00:41:33.890 --> 00:41:37.680
So you can find those guides
on the developer site.

00:41:37.680 --> 00:41:39.140
Other than that, thank
you for joining us.

00:41:39.140 --> 00:41:42.100
We're talking this week about
Google Tag Manager for Mobile.

00:41:42.100 --> 00:41:43.520
And we'll catch you next time.

