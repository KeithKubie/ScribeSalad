WEBVTT
Kind: captions
Language: en-GB

00:00:00.000 --> 00:00:03.929
I've been in a recent set of videos that
we've done,

00:00:03.929 --> 00:00:08.189
related to HTML, I really have taken a
severe beating in the latest one that

00:00:08.189 --> 00:00:12.630
I'm a disgrace to Full Professors as I
don't know what a programming language is

00:00:12.630 --> 00:00:17.609
and how it differs from a markup
language. And my attitude is going to be:

00:00:17.609 --> 00:00:20.609
"Well I stand by what I say".

00:00:21.330 --> 00:00:26.580
HTML is a very restricted form of
programming language, in my view, so we

00:00:26.580 --> 00:00:28.050
need to justify that.

00:00:28.050 --> 00:00:33.420
And I need to say at the outset that you
don't need to see all the previous HTML

00:00:33.420 --> 00:00:37.320
videos in order to understand this one,
because it really comes down to

00:00:37.320 --> 00:00:42.540
something that's actually very
fundamental. In the end it comes down to

00:00:42.540 --> 00:00:47.610
two different styles of programming
language that are interrelated that you

00:00:47.610 --> 00:00:52.739
can differentiate, in a way, between them.
And when does one merge into the other? And

00:00:52.739 --> 00:00:59.699
these two ways of doing programming are
known in the trade, generically, as either

00:00:59.699 --> 00:01:04.229
the imperative style or the dclarative.

00:01:05.510 --> 00:01:14.300
Now the one that most of you will be the
more familiar with is the imperative so

00:01:14.300 --> 00:01:15.680
we'll do that first.

00:01:15.680 --> 00:01:20.120
This is really just programming as you
and I understand it you take your

00:01:20.120 --> 00:01:21.740
language of your choice

00:01:21.740 --> 00:01:28.580
Assembler, Java, C, Basic, whatever and
you are required to give a detailed

00:01:28.580 --> 00:01:33.500
specification of how you are going to do
this problem. And, as we know, this

00:01:33.500 --> 00:01:38.270
detailed specification might be simple
arithmetic programming statements;

00:01:38.270 --> 00:01:41.360
it might require going round things in
loops;

00:01:41.360 --> 00:01:45.500
it would certainly require taking
decisions. So it will have 'if' statements

00:01:45.500 --> 00:01:46.490
inside it.

00:01:46.490 --> 00:01:53.210
So, if you like, ordinary straightforward
detailed nuts-and-bolts programming is

00:01:53.210 --> 00:01:58.790
in an imperative style, because you
have to say how you are going to solve

00:01:58.790 --> 00:02:05.030
the problem. I'll put "How" in quotes here
saying that leads you to 'if', 'for',

00:02:05.030 --> 00:02:08.179
arithmetic statements, whatever you need.

00:02:08.179 --> 00:02:11.270
&gt;&gt; SEAN: So this is setting out how you are going to
do something. If this button is pressed

00:02:11.270 --> 00:02:12.800
then do this?

00:02:12.800 --> 00:02:17.180
&gt;&gt; DFB: Yes! Yes! And the vast majority of
programs that most people think of, in

00:02:17.180 --> 00:02:19.940
terms of programming, are done in this style.

00:02:19.940 --> 00:02:27.019
Now what about declarative then?  Well
'declarative' -  it's a more functional style

00:02:27.019 --> 00:02:32.510
of programming, where the interpreter for
your language does the details and

00:02:32.510 --> 00:02:39.019
actually one style can merge into another
And I've got a very good example of my

00:02:39.019 --> 00:02:44.600
own and we've done it on Computerphile.
I wrote a program to do the Ackermann

00:02:44.600 --> 00:02:50.570
function. I think it's my biggest hit so
far - that particular video. And within the

00:02:50.570 --> 00:02:57.380
function 'ackermann' we saw program
statements, we saw use of recursion,

00:02:57.380 --> 00:03:00.800
we saw 'ackermann' calling 'ackermann' and
all this kind of stuff. And finally

00:03:00.800 --> 00:03:03.110
returning and delivering back an answer.

00:03:03.110 --> 00:03:08.239
However, back in the main program where I
call up 'ackermann'

00:03:08.819 --> 00:03:14.280
with certain arguments and I call up the
'ackermann function' as the arguments ....

00:03:14.280 --> 00:03:18.209
I don't worry about the
implementation details of 'ackermann'

00:03:18.209 --> 00:03:23.879
I just call it up - at the end of a big
printf statement as i recall. I say

00:03:23.879 --> 00:03:26.819
declaratively "Give me 'ackermann' -

00:03:26.819 --> 00:03:31.560
do it for me! I forgot the details of how
I did it". Many of you know this. The whole

00:03:31.560 --> 00:03:36.299
idea of writing your own library full of
functions for a particular job is that

00:03:36.299 --> 00:03:40.680
you can then work more abstractly.  and
at a higher level. You can say "I wrote

00:03:40.680 --> 00:03:45.209
those 20 years ago. I've forgotten how I did them.
But it doesn't matter. Do me 'ackermann' with

00:03:45.209 --> 00:03:47.280
parameters "thing" and "thing" --  something like that.

00:03:47.280 --> 00:03:53.099
So you see the one can merge into the
other as you take a more functional

00:03:53.099 --> 00:03:57.959
approach. You could argue, loosely, every
time you use a library of functions that

00:03:57.959 --> 00:04:02.669
you bought in from somewhere then you
are becoming more declarative in the way

00:04:02.669 --> 00:04:03.750
that you use it.

00:04:03.750 --> 00:04:07.439
So the point about declarative is you
don't have to go into the nuts and bolts

00:04:07.439 --> 00:04:11.579
details. You just ask for what you want
and magically it happens.

00:04:11.579 --> 00:04:17.849
Typical examples of real declarative
languages are things like Haskell.

00:04:17.849 --> 00:04:22.409
what are the trade-offs about this? Well,
you could probably say that most of

00:04:22.409 --> 00:04:24.630
these declarative languages

00:04:24.630 --> 00:04:29.130
don't work on the bare metal, like your
C program could do eventually. They are

00:04:29.130 --> 00:04:35.430
interpreted, with a layer of software
between you and the bare metal. Now that

00:04:35.430 --> 00:04:41.280
gives you flexibility because the
Haskell interpreter can be basically

00:04:41.280 --> 00:04:44.880
ported to all sorts of architectures.
Somebody's got to do the hard work but

00:04:44.880 --> 00:04:48.150
then you know that if you take the Haskell
program along

00:04:48.150 --> 00:04:52.229
you can just run it. You don't have to
convert it into a binary. It just runs on

00:04:52.229 --> 00:04:57.419
the interpretive mode. So it's trade-offs
And other things being equal (it's less

00:04:57.419 --> 00:05:01.920
true now it used to be) you lose a little
bit of efficiency in an

00:05:01.920 --> 00:05:06.930
interpreter whereas, y' know, if you refine
a thing right down to a hard-core binary

00:05:06.930 --> 00:05:09.270
it'll go off like a Maserati,

00:05:09.270 --> 00:05:16.470
we hope. And some languages, as we know,
have a compromise here. Java started life

00:05:16.470 --> 00:05:23.430
as being a portable interpreted system
but with a syntax that's really pretty much

00:05:23.430 --> 00:05:28.560
like C. But it's notable that now, when
you've developed from the Java, there's very

00:05:28.560 --> 00:05:32.880
often an option to say 'If you want to
compile this and make a real executable

00:05:32.880 --> 00:05:33.720
binary of it

00:05:33.720 --> 00:05:39.510
yes, you can do that'. But during
development you get a lot of flexibility

00:05:39.510 --> 00:05:44.040
by just being able to do things and try
them out instantly . That then, I hope, has

00:05:44.040 --> 00:05:48.810
given you a bit more insight into what
the imperative vs. the declarative

00:05:48.810 --> 00:05:54.960
approach is. And that's very relevant to
discussions of whether

00:05:54.960 --> 00:05:58.260
HTML is, or is not, a programming language.

00:05:59.340 --> 00:06:08.670
We all know &lt;h1&gt; means
give me a heading, level one.

00:06:08.670 --> 00:06:15.930
Now, of course, I have to show where the
stuff that is your heading - the text -

00:06:15.930 --> 00:06:21.690
ends. But to me you can say "Look, I'm
calling up the function &lt;h1&gt;, I'm giving it

00:06:21.690 --> 00:06:23.400
the argument

00:06:23.400 --> 00:06:28.380
'this is my heading' to be done in h1
style". And &lt;/h1&gt; is really just

00:06:28.380 --> 00:06:32.760
to say, "Oh! by the way, there's no other
way I can signify where my text string

00:06:32.760 --> 00:06:35.009
ends, It's not semicolon or anything like that".

00:06:35.009 --> 00:06:39.629
Conventionally its &lt;/h1&gt;. So to me,

00:06:39.629 --> 00:06:43.349
yes, you can think of that as being a
function call in a way.

00:06:43.349 --> 00:06:48.059
However, some of you really did hit home
a bit more accurately, I think, when you

00:06:48.059 --> 00:06:51.899
said "It can't be a programming language,

00:06:52.439 --> 00:06:56.249
really, because it's not Turing Complete.

00:06:56.849 --> 00:07:02.460
Now that is a topic - I'm sorry I hate
doing cliffhangers, you know I do! -

00:07:02.460 --> 00:07:05.999
that's a topic that we have mentioned
from time to time but it's big enough

00:07:05.999 --> 00:07:11.129
that we need to do a separate video,
really, on that, It's perfectly correct that

00:07:11.129 --> 00:07:15.419
HTML could never be thought of as a
full-blown programming language.

00:07:15.419 --> 00:07:18.719
It can't do 'if' statements in its raw
vanilla form!

00:07:18.719 --> 00:07:23.460
There's no way inside HTML that you
can say "Give me a megabyte more space to

00:07:23.460 --> 00:07:26.370
work with". It's just not part of the language.

00:07:26.370 --> 00:07:31.740
Somebody has pointed out, I think, that
HTML with CSS does become a very

00:07:31.740 --> 00:07:35.669
powerful Turing-Complete language but
you wouldn't want to use it.

00:07:35.669 --> 00:07:40.860
It's not general purpose - that's another
thing. It's really is a question of "Is it

00:07:40.860 --> 00:07:46.620
imperative; is it declarative?"  This is
declarative but is it general purpose?

00:07:46.620 --> 00:07:50.610
No, this is really for programming Web pages.

00:07:50.610 --> 00:07:56.279
That's the way I think of it and also,
like I say, it's not Turing Complete, but

00:07:56.279 --> 00:08:02.699
you can certainly argue that anything
that takes tags as if they were function

00:08:02.699 --> 00:08:09.029
calls and interprets them and does them for
you is, in some restricted sense, in my

00:08:09.029 --> 00:08:10.169
view anyway,

00:08:10.169 --> 00:08:13.169
a programming language.

