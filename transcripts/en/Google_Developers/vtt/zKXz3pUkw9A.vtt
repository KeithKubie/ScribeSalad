WEBVTT
Kind: captions
Language: en

00:00:00.806 --> 00:00:03.560
BRIAN EGAN: All right, thank you
so much for joining me today.

00:00:03.560 --> 00:00:04.690
My name is Brian Egan.

00:00:04.690 --> 00:00:08.109
And I'm going to be discussing
Flutter architecture, or what

00:00:08.109 --> 00:00:10.450
I call Keep it simple, State.

00:00:10.450 --> 00:00:13.520
Hopefully that'll
live up to its name.

00:00:13.520 --> 00:00:17.220
So before I begin, I'll
just introduce myself.

00:00:17.220 --> 00:00:20.080
I'm formerly a senior software
engineer at SoundCloud,

00:00:20.080 --> 00:00:22.120
and before that at
Zappos, and so I

00:00:22.120 --> 00:00:24.790
was working on large
scale consumer facing

00:00:24.790 --> 00:00:28.180
like applications
for Android and web.

00:00:28.180 --> 00:00:30.730
And so I kind of found Flutter
about a year and a half

00:00:30.730 --> 00:00:33.310
ago and just started throwing
as much spaghetti at the wall

00:00:33.310 --> 00:00:35.800
as I could, so I've kind
of developed the Redux

00:00:35.800 --> 00:00:37.720
package with John.

00:00:37.720 --> 00:00:39.850
I've also been helping to
contribute to the RxDart

00:00:39.850 --> 00:00:40.622
package.

00:00:40.622 --> 00:00:42.580
And then I started applying
all of these things

00:00:42.580 --> 00:00:46.630
to flutter and to see what
really worked for Flutter.

00:00:46.630 --> 00:00:49.090
And so I kind of wanted to talk
about my journey with that,

00:00:49.090 --> 00:00:51.490
and introduce you to
a couple of concepts

00:00:51.490 --> 00:00:53.660
that I found really helpful.

00:00:53.660 --> 00:00:56.320
So I think two concepts
that are really fundamental

00:00:56.320 --> 00:00:58.930
is that, number one,
your architecture

00:00:58.930 --> 00:01:01.570
for your applications will
change over time, right?

00:01:01.570 --> 00:01:03.850
Your requirements
are going to change.

00:01:03.850 --> 00:01:06.940
You know, what you use
for an MVP or a prototype

00:01:06.940 --> 00:01:09.970
won't quite be the same thing
that you use for, you know,

00:01:09.970 --> 00:01:13.420
your app with like 400
to 600,000 lines of code

00:01:13.420 --> 00:01:15.370
with a team of 20 people.

00:01:15.370 --> 00:01:17.260
Those things are
just naturally going

00:01:17.260 --> 00:01:19.127
to be different
from one another.

00:01:19.127 --> 00:01:21.460
And so when you find yourself
sort of progressing, maybe

00:01:21.460 --> 00:01:24.190
from a prototype
or an idea stage

00:01:24.190 --> 00:01:27.880
into more of a team phase
or a maintenance phase,

00:01:27.880 --> 00:01:31.344
I really recommend the technique
of layering your architectures.

00:01:31.344 --> 00:01:33.760
I think this is a fundamental
concept we heard a bit about

00:01:33.760 --> 00:01:35.470
yesterday, and I
kind of want to dive

00:01:35.470 --> 00:01:38.210
a bit more into that as well.

00:01:38.210 --> 00:01:40.480
So let's look at just
sort of some basics.

00:01:40.480 --> 00:01:42.294
We've got a flutter
app, we want to start

00:01:42.294 --> 00:01:43.960
updating the state
of the app, and then,

00:01:43.960 --> 00:01:46.376
of course, when that happens
we want to rebuild our widget

00:01:46.376 --> 00:01:49.630
tree, so you know we're
actually showing the changes.

00:01:49.630 --> 00:01:51.329
Then, of course, as
we start to progress

00:01:51.329 --> 00:01:52.870
we're going to need
to start to share

00:01:52.870 --> 00:01:55.000
some data between
different widgets,

00:01:55.000 --> 00:01:57.730
between different
screens in our app.

00:01:57.730 --> 00:02:00.010
And then that's pretty
cool, but then we'll

00:02:00.010 --> 00:02:02.710
actually need to start talking
to web services and databases,

00:02:02.710 --> 00:02:03.430
of course, right?

00:02:03.430 --> 00:02:05.346
You don't want this like
closed-off little app

00:02:05.346 --> 00:02:08.449
that's just kind of
hanging out by itself.

00:02:08.449 --> 00:02:10.960
And so how do we kind
of use some techniques

00:02:10.960 --> 00:02:13.210
to make that work well?

00:02:13.210 --> 00:02:16.420
Finally, as you're sort of
progressing past that ideation

00:02:16.420 --> 00:02:18.940
and MVP stage, you're
going to want to make

00:02:18.940 --> 00:02:21.070
your apps easy to maintain.

00:02:21.070 --> 00:02:23.410
And of course, what comes
along with that is how do you

00:02:23.410 --> 00:02:25.180
test these apps, right?

00:02:25.180 --> 00:02:27.820
So if you're working for
a company like Zappos

00:02:27.820 --> 00:02:30.106
and people are adding
items to the cart,

00:02:30.106 --> 00:02:31.480
you want to make
sure that works,

00:02:31.480 --> 00:02:33.646
right, you don't want them
to get to a checkout page

00:02:33.646 --> 00:02:36.220
and all of a sudden
there's no products there.

00:02:36.220 --> 00:02:38.860
No one's going to
be happy about that.

00:02:38.860 --> 00:02:41.547
So yeah, let's kind of walk
through these challenges.

00:02:41.547 --> 00:02:43.630
And I want to start first
with the building blocks

00:02:43.630 --> 00:02:45.040
that Flutter provides.

00:02:45.040 --> 00:02:47.020
So I think it's
important to sort of see

00:02:47.020 --> 00:02:50.260
what the framework gives you and
think about when we can keep it

00:02:50.260 --> 00:02:53.080
simple and when we can
use these building blocks,

00:02:53.080 --> 00:02:55.190
and then when we might
need to naturally progress

00:02:55.190 --> 00:02:58.952
past these building blocks
to more advanced solutions.

00:02:58.952 --> 00:03:01.160
So the first thing, of
course, is the StatefulWidget.

00:03:01.160 --> 00:03:03.493
This is sort of the bread and
butter of state management

00:03:03.493 --> 00:03:05.830
for Flutter, right, and the
StatefulWidgets themselves

00:03:05.830 --> 00:03:06.650
are pretty simple.

00:03:06.650 --> 00:03:09.640
They just sort of take
in some properties,

00:03:09.640 --> 00:03:11.500
and the constructor perams.

00:03:11.500 --> 00:03:13.900
You know, in this case
it includes a title,

00:03:13.900 --> 00:03:16.017
but it could include
some other information.

00:03:16.017 --> 00:03:18.100
And then they sort of just
create this state class

00:03:18.100 --> 00:03:20.655
that you write, and they
kind of get out of the way.

00:03:20.655 --> 00:03:22.030
So let's look at
the state class,

00:03:22.030 --> 00:03:24.446
because that's where actually
the interesting stuff starts

00:03:24.446 --> 00:03:25.540
to happen.

00:03:25.540 --> 00:03:27.907
So we've got MyHomePageState.

00:03:27.907 --> 00:03:29.740
I literally stole this
just from the Flutter

00:03:29.740 --> 00:03:33.820
create example, just to
keep it simple, you know.

00:03:33.820 --> 00:03:36.670
And so now we've got, for
example, just our counter.

00:03:36.670 --> 00:03:38.500
So this is the
first responsibility

00:03:38.500 --> 00:03:40.360
of the state class,
is to define,

00:03:40.360 --> 00:03:41.860
hey, what kind of
information does

00:03:41.860 --> 00:03:44.957
my application need to render.

00:03:44.957 --> 00:03:47.290
The second thing that the
state class will often contain

00:03:47.290 --> 00:03:49.622
are methods to update the state.

00:03:49.622 --> 00:03:51.580
And this is where it gets
a little interesting,

00:03:51.580 --> 00:03:53.650
because we're not just
incrementing the counter,

00:03:53.650 --> 00:03:55.960
but then you're also
using the set state method

00:03:55.960 --> 00:03:58.401
from the state class.

00:03:58.401 --> 00:04:00.400
And what that will do is
it'll run that function

00:04:00.400 --> 00:04:01.390
that you give it.

00:04:01.390 --> 00:04:03.130
And then after it
runs that function,

00:04:03.130 --> 00:04:04.930
it'll actually tell
Flutter hey, go ahead

00:04:04.930 --> 00:04:07.510
and rebuild this widget
tree, or mark this tree

00:04:07.510 --> 00:04:09.546
for needing a rebuild.

00:04:09.546 --> 00:04:11.920
Then finally, the third thing
that your state class often

00:04:11.920 --> 00:04:14.250
does, or needs to
do, is actually

00:04:14.250 --> 00:04:16.837
define the UI in
the build method.

00:04:16.837 --> 00:04:18.670
So in this case, we'll
just pass the counter

00:04:18.670 --> 00:04:20.529
that we've got to a text widget.

00:04:20.529 --> 00:04:21.910
We'll pass that
increment counter

00:04:21.910 --> 00:04:24.520
to a button of some sort so
that when you press on it,

00:04:24.520 --> 00:04:26.290
it'll go ahead and
increment the counter,

00:04:26.290 --> 00:04:28.540
tell Flutter to
rebuild that widget,

00:04:28.540 --> 00:04:30.820
and then everything works.

00:04:30.820 --> 00:04:33.670
So I think maybe some of you are
thinking like, OK, that's like,

00:04:33.670 --> 00:04:34.840
a super simple example.

00:04:34.840 --> 00:04:36.745
But I actually
think it has a lot

00:04:36.745 --> 00:04:38.620
of really interesting
little concepts wrapped

00:04:38.620 --> 00:04:40.390
up inside of it.

00:04:40.390 --> 00:04:44.080
So you know our widget tree at
this point is really simple.

00:04:44.080 --> 00:04:45.580
We've got a
StatefulWidget, and it's

00:04:45.580 --> 00:04:48.340
sort of handing some information
off to a text widget,

00:04:48.340 --> 00:04:49.840
and a count button.

00:04:49.840 --> 00:04:53.320
It's handing off the increment
counter to a button widget.

00:04:53.320 --> 00:04:55.720
But more often than
not, our widget trees

00:04:55.720 --> 00:04:57.936
are going to be more
complex or interesting.

00:04:57.936 --> 00:05:00.310
Your designers are going to
throw some cool stuff at you,

00:05:00.310 --> 00:05:02.500
and they're going to ask you
to make some cool layouts.

00:05:02.500 --> 00:05:04.750
And so you're going to start
nesting widgets a bit more,

00:05:04.750 --> 00:05:07.041
and you might need to send
that data little bit further

00:05:07.041 --> 00:05:08.650
down your widget tree.

00:05:08.650 --> 00:05:11.080
And the most common way, and
the simplest way to do that,

00:05:11.080 --> 00:05:14.650
is to simply pass the state
from your StatefulWidget

00:05:14.650 --> 00:05:16.480
down the widget tree, right.

00:05:16.480 --> 00:05:19.330
So say we need some
information, or we

00:05:19.330 --> 00:05:21.190
want to pass our counter
and our increment

00:05:21.190 --> 00:05:23.410
counter down to these
widgets that I'm

00:05:23.410 --> 00:05:25.460
trying to highlight here.

00:05:25.460 --> 00:05:29.920
So what we can do is, maybe
you've got a stateless widget,

00:05:29.920 --> 00:05:32.140
you can create another
constructor parameter,

00:05:32.140 --> 00:05:33.670
and it will take the counter.

00:05:33.670 --> 00:05:35.080
It will pass that
counter further

00:05:35.080 --> 00:05:37.570
down the tree to
another stateless widget

00:05:37.570 --> 00:05:39.650
that takes in the counter,
and then finally that

00:05:39.650 --> 00:05:43.349
will get rendered by a text
widget or something in the end.

00:05:43.349 --> 00:05:44.890
On the other side
of our widget tree,

00:05:44.890 --> 00:05:46.720
we want to pass down
increment counter,

00:05:46.720 --> 00:05:48.790
and we can do this
infinitely deep.

00:05:48.790 --> 00:05:52.660
We can actually continue to pass
values down the widget tree.

00:05:52.660 --> 00:05:54.430
And this is a really
nice and kind of tidy

00:05:54.430 --> 00:05:59.114
way to go ahead and
actually pass state around.

00:05:59.114 --> 00:06:01.030
So then when you tap on
the increment counter,

00:06:01.030 --> 00:06:03.699
or on the button that we've
passed increment counter to,

00:06:03.699 --> 00:06:05.740
it will go ahead and call
that method, of course,

00:06:05.740 --> 00:06:07.090
on the StatefulWidget.

00:06:07.090 --> 00:06:08.620
The StatefulWidget
will say, hey,

00:06:08.620 --> 00:06:10.960
I need a redraw at this point.

00:06:10.960 --> 00:06:13.150
And then it'll once again
pass the counter back down

00:06:13.150 --> 00:06:15.671
and display the new value.

00:06:15.671 --> 00:06:16.170
Cool.

00:06:16.170 --> 00:06:19.620
So this is actually a
really fundamental concept

00:06:19.620 --> 00:06:23.100
of state management,
and it comes from React.

00:06:23.100 --> 00:06:26.400
And it's a concept
called Lifting State Up.

00:06:26.400 --> 00:06:29.130
And so the idea behind this is
that if you need to share data

00:06:29.130 --> 00:06:31.110
amongst different
widgets, what you can do

00:06:31.110 --> 00:06:34.080
is you can create a
StatefulWidget at the parent

00:06:34.080 --> 00:06:36.150
or the root of those
different widgets

00:06:36.150 --> 00:06:38.280
that need the
information, and then you

00:06:38.280 --> 00:06:40.650
can pass the information
from the StatefulWidget

00:06:40.650 --> 00:06:44.126
down to the different
parts that need it.

00:06:44.126 --> 00:06:45.750
The interesting thing
is that this also

00:06:45.750 --> 00:06:48.390
applies to sharing
data across screens,

00:06:48.390 --> 00:06:51.000
because what you can
do is you can actually

00:06:51.000 --> 00:06:54.820
pull the StatefulWidget all the
way up above your application.

00:06:54.820 --> 00:06:56.550
So this is really cool.

00:06:56.550 --> 00:06:58.800
We just heard Phil talk
about how everything

00:06:58.800 --> 00:07:00.985
is a widget in Flutter,
and so what we can do

00:07:00.985 --> 00:07:02.610
is we can just pull
that StatefulWidget

00:07:02.610 --> 00:07:05.490
above your widgets app,
or your material app,

00:07:05.490 --> 00:07:07.710
and that's the
actual widget that's

00:07:07.710 --> 00:07:09.540
responsible for creating
different screens

00:07:09.540 --> 00:07:10.530
in your application.

00:07:10.530 --> 00:07:13.380
That's where you like
navigator.push some new route,

00:07:13.380 --> 00:07:15.150
or navigator pop.

00:07:15.150 --> 00:07:18.570
And so we can actually use this
technique to pass information

00:07:18.570 --> 00:07:21.000
down to different screens.

00:07:21.000 --> 00:07:24.210
So while it might seem simple
at first, you actually,

00:07:24.210 --> 00:07:25.830
using this basic
technique, can start

00:07:25.830 --> 00:07:28.200
to share data
amongst your screens

00:07:28.200 --> 00:07:32.570
and have it re-render
every time data changes.

00:07:32.570 --> 00:07:33.700
So let's keep going.

00:07:33.700 --> 00:07:34.690
Let's progress.

00:07:34.690 --> 00:07:38.419
We want to start calling web
APIs or maybe a database.

00:07:38.419 --> 00:07:40.210
So now what we'll do
is we'll sort of start

00:07:40.210 --> 00:07:42.280
to enhance our state class.

00:07:42.280 --> 00:07:46.000
We'll throw a Boolean in there
of whether it's loading or not.

00:07:46.000 --> 00:07:49.200
And that way our UI can show
a loading status or maybe,

00:07:49.200 --> 00:07:52.756
or the actual counter,
if it's true or false.

00:07:52.756 --> 00:07:54.130
And then what
we'll have is we'll

00:07:54.130 --> 00:07:57.220
actually have a method within
our state class, that goes

00:07:57.220 --> 00:08:00.010
ahead and talks to the API.

00:08:00.010 --> 00:08:02.530
So we'll just call this
fetchIncrement for right now.

00:08:02.530 --> 00:08:06.970
It'll return a future
with an integer involved.

00:08:06.970 --> 00:08:09.600
And then we'll create
an HTTP client in there.

00:08:09.600 --> 00:08:11.800
We'll actually go ahead
and wait for the client

00:08:11.800 --> 00:08:14.119
to get the information
from our web server.

00:08:14.119 --> 00:08:15.910
This is just some pseudo
code, but I'm just

00:08:15.910 --> 00:08:17.770
trying to get the idea across.

00:08:17.770 --> 00:08:20.710
Finally, we'll go ahead
decode that, that JSON,

00:08:20.710 --> 00:08:25.650
and then we'll return the value
of the counter from the JSON.

00:08:25.650 --> 00:08:29.140
Then actually, the method
we'll want to use in our UI

00:08:29.140 --> 00:08:30.824
is called increment Async.

00:08:30.824 --> 00:08:32.740
And so what this will
do is it'll immediately,

00:08:32.740 --> 00:08:34.690
as soon as it gets
called, it'll go ahead

00:08:34.690 --> 00:08:38.130
and say, hey, set state, I want
to show my loading spinners,

00:08:38.130 --> 00:08:40.539
so show my state as loading.

00:08:40.539 --> 00:08:42.880
Then we'll fetch the
increment from the API using

00:08:42.880 --> 00:08:44.666
the method we just created.

00:08:44.666 --> 00:08:46.540
And then after that
returns, we'll once again

00:08:46.540 --> 00:08:49.480
set the state with the
counter set to the value

00:08:49.480 --> 00:08:53.507
that we got back from the API,
and we'll set loading to false.

00:08:53.507 --> 00:08:55.840
And so what this looks like,
again, with our widget tree

00:08:55.840 --> 00:08:58.600
is that we'll pass
increment Async down.

00:08:58.600 --> 00:09:00.910
When we tap on that,
then we'll go ahead

00:09:00.910 --> 00:09:02.560
and re-render the widget tree.

00:09:02.560 --> 00:09:04.150
The first render
will of course have

00:09:04.150 --> 00:09:07.420
the loading state involved,
and we'll show the spinner.

00:09:07.420 --> 00:09:10.090
And then when the data
comes back from the API

00:09:10.090 --> 00:09:13.720
it'll go ahead and pass the
counter down, down, down,

00:09:13.720 --> 00:09:15.670
and we'll see that the
new value is actually

00:09:15.670 --> 00:09:17.780
rendered at this point.

00:09:17.780 --> 00:09:18.280
Cool.

00:09:18.280 --> 00:09:20.560
So you know,
looking good, right?

00:09:20.560 --> 00:09:22.450
Some of you might be
breathing into a paper

00:09:22.450 --> 00:09:24.130
bag with this architecture.

00:09:24.130 --> 00:09:25.900
You might be like,
what is this guy doing?

00:09:25.900 --> 00:09:27.670
Where's he going with this?

00:09:27.670 --> 00:09:29.800
He's throwing everything
into one class.

00:09:29.800 --> 00:09:30.780
Don't worry, friends.

00:09:30.780 --> 00:09:33.040
We'll get there.

00:09:33.040 --> 00:09:35.140
So we're actually updating
the state of our app,

00:09:35.140 --> 00:09:37.420
we're talking to web APIs,
we're sharing information

00:09:37.420 --> 00:09:38.800
across screens.

00:09:38.800 --> 00:09:40.120
Not so bad, right?

00:09:40.120 --> 00:09:41.800
If you're just
writing a prototype,

00:09:41.800 --> 00:09:44.770
or you're just learning Flutter,
this is a totally great way

00:09:44.770 --> 00:09:45.850
to get started.

00:09:45.850 --> 00:09:48.232
You're going to start making
progress really quickly.

00:09:48.232 --> 00:09:49.690
But you know, you're
going to start

00:09:49.690 --> 00:09:51.314
running into these
issues, where if you

00:09:51.314 --> 00:09:53.200
want to make your app
easier to maintain,

00:09:53.200 --> 00:09:55.090
to bring team
members on, to share

00:09:55.090 --> 00:09:57.250
code between different things.

00:09:57.250 --> 00:10:00.070
Throwing everything in this
class might get a little hairy.

00:10:00.070 --> 00:10:04.580
And we'll also look at how this
can be a challenge for testing.

00:10:04.580 --> 00:10:06.860
So let's start to challenge
our UI a little bit.

00:10:06.860 --> 00:10:08.380
Let's make a UI change.

00:10:08.380 --> 00:10:10.270
So we want to move
the widget that

00:10:10.270 --> 00:10:13.210
displays the counter from
this part of our tree

00:10:13.210 --> 00:10:15.450
to this part of our tree.

00:10:15.450 --> 00:10:17.574
Oh god.

00:10:17.574 --> 00:10:18.490
What do we need to do?

00:10:18.490 --> 00:10:20.260
We need to change this widget.

00:10:20.260 --> 00:10:23.710
It no longer needs to accept a
counter, neither does this one.

00:10:23.710 --> 00:10:25.690
The StatefulWidget
is actually lifted up

00:10:25.690 --> 00:10:28.750
too high right now, so we can
make that a StatefulWidget.

00:10:28.750 --> 00:10:31.910
Then we push the
StatefulWidget down one level.

00:10:31.910 --> 00:10:33.730
Then we add a counter
parameter here,

00:10:33.730 --> 00:10:36.730
and then we can pass it down.

00:10:36.730 --> 00:10:39.790
So maybe not the best if
you want to start really

00:10:39.790 --> 00:10:42.210
revving on UI changes.

00:10:42.210 --> 00:10:44.210
You know, this can be a
good way to get started.

00:10:44.210 --> 00:10:46.360
But if you want to start
making UI changes quickly

00:10:46.360 --> 00:10:48.550
you're going to find hey,
this is actually maybe not

00:10:48.550 --> 00:10:51.640
the cleanest or the
easiest way to do this,

00:10:51.640 --> 00:10:54.710
because it requires a
lot of plumbing changes.

00:10:54.710 --> 00:10:56.560
So let's take a look
at one solution, right,

00:10:56.560 --> 00:10:58.296
and that's the inherited widget.

00:10:58.296 --> 00:10:59.920
This is another
building block actually

00:10:59.920 --> 00:11:02.080
that's provided by Flutter.

00:11:02.080 --> 00:11:04.180
And so what it will do
is rather than having

00:11:04.180 --> 00:11:07.780
the StatefulWidget pass state
directly down to its children,

00:11:07.780 --> 00:11:09.550
the StatefulWidget
will actually pass data

00:11:09.550 --> 00:11:12.220
to an inherited widget,
and then the responsibility

00:11:12.220 --> 00:11:14.620
of that widget is to pass
that information down

00:11:14.620 --> 00:11:18.100
to all of its ancestors
in the widget tree.

00:11:18.100 --> 00:11:20.620
So we'll pass the private
counter and increment

00:11:20.620 --> 00:11:22.180
counter down from
the StatefulWidget

00:11:22.180 --> 00:11:24.370
to the inherited
widget, and then it

00:11:24.370 --> 00:11:26.710
will expose those publicly.

00:11:26.710 --> 00:11:29.320
So now, if we want that
data down our widget tree,

00:11:29.320 --> 00:11:32.680
we can just say, My
Inherited Widget of context,

00:11:32.680 --> 00:11:34.180
give me the counter.

00:11:34.180 --> 00:11:37.420
On the other side we can say,
My Inherited Widget of context,

00:11:37.420 --> 00:11:39.710
give me the increment
counter method.

00:11:39.710 --> 00:11:40.960
And this makes it really easy.

00:11:40.960 --> 00:11:43.244
So if we try that
challenge again,

00:11:43.244 --> 00:11:45.160
let's say we want to
move the button this time

00:11:45.160 --> 00:11:47.810
from this part of the tree
to this part of the tree.

00:11:47.810 --> 00:11:50.050
OK, so we're just moving it.

00:11:50.050 --> 00:11:51.860
Now this time it's really easy.

00:11:51.860 --> 00:11:54.280
We don't have to do any of
that crazy plumbing or changes,

00:11:54.280 --> 00:11:57.070
because we're still just
relying on the inherited widget

00:11:57.070 --> 00:12:00.130
to pass that information
down the tree for us.

00:12:00.130 --> 00:12:01.584
All right, it's not bad, right?

00:12:01.584 --> 00:12:04.000
There's a lot less plumbing
now that we have to deal with.

00:12:04.000 --> 00:12:06.460
It's easier to move widgets
around and change up

00:12:06.460 --> 00:12:07.975
your UI quickly.

00:12:07.975 --> 00:12:09.850
But you'll start to see
that there's actually

00:12:09.850 --> 00:12:12.070
some interesting
duplication between what

00:12:12.070 --> 00:12:15.070
lives in the state
class and then also

00:12:15.070 --> 00:12:16.750
in the inherited widget.

00:12:16.750 --> 00:12:19.510
And you'll also see that the
entire widget tree is actually

00:12:19.510 --> 00:12:20.625
rebuilt when this happens.

00:12:20.625 --> 00:12:22.000
You might have
seen that actually

00:12:22.000 --> 00:12:24.389
with all of the
StatefulWidget examples.

00:12:24.389 --> 00:12:25.930
And then, of course,
the big question

00:12:25.930 --> 00:12:29.590
is, how do we test
all of this, right?

00:12:29.590 --> 00:12:33.410
So let's look at another
challenge, which is testing.

00:12:33.410 --> 00:12:35.320
So if we want to
test this thing,

00:12:35.320 --> 00:12:37.000
like this was my
initial dream, is

00:12:37.000 --> 00:12:40.150
I was just going to write
a plain old dart test.

00:12:40.150 --> 00:12:43.112
I was going to instantiate a
new version of the state class.

00:12:43.112 --> 00:12:45.070
I was going to run the
increment counter method

00:12:45.070 --> 00:12:47.650
and then just be able to
expect that the counter has

00:12:47.650 --> 00:12:49.910
gone from 0 to 1.

00:12:49.910 --> 00:12:52.810
Now unfortunately, that's
not quite the way it works.

00:12:52.810 --> 00:12:55.240
Because this is a
state class and it's

00:12:55.240 --> 00:12:57.280
kind of tied to
Flutter, you actually

00:12:57.280 --> 00:12:59.080
have to use the Flutter
testing utilities

00:12:59.080 --> 00:13:01.400
to test this type of logic.

00:13:01.400 --> 00:13:05.260
So what do we actually have to
do is we have to pump a widget.

00:13:05.260 --> 00:13:07.912
In this case, I'll
pump the entire app.

00:13:07.912 --> 00:13:09.370
I'm just doing that
for simplicity,

00:13:09.370 --> 00:13:10.911
but you know sometimes
you might need

00:13:10.911 --> 00:13:12.640
to add some extra
information in there,

00:13:12.640 --> 00:13:15.610
like a directionality widget,
to get your stuff to render.

00:13:15.610 --> 00:13:19.240
Then you have to find the
button on screen that actually

00:13:19.240 --> 00:13:21.880
does the tapping and tap that.

00:13:21.880 --> 00:13:26.020
You wait for Flutter to
re-draw the widget by saying,

00:13:26.020 --> 00:13:29.470
OK, let's pump the tester,
and then finally you

00:13:29.470 --> 00:13:31.480
would basically look
at the widget tree

00:13:31.480 --> 00:13:34.520
that Flutter is rendering in the
test environment and say, hey,

00:13:34.520 --> 00:13:38.930
is there a widget that's
displaying this text?

00:13:38.930 --> 00:13:40.990
So if we kind of look
at that challenge,

00:13:40.990 --> 00:13:45.670
we start to see that it's a
little bit harder to work with.

00:13:45.670 --> 00:13:48.399
I don't want to judge the
widget inspector at all,

00:13:48.399 --> 00:13:50.440
or the widget tester at
all, because it's amazing

00:13:50.440 --> 00:13:51.523
that this actually exists.

00:13:51.523 --> 00:13:54.160
If you come from Android,
it can be really a pain

00:13:54.160 --> 00:13:56.170
to do this type of testing.

00:13:56.170 --> 00:13:58.330
And it becomes clear
that this type of testing

00:13:58.330 --> 00:14:01.150
is great for you
UIs and UI logic.

00:14:01.150 --> 00:14:03.626
But you can start to see how
our architecture that we've

00:14:03.626 --> 00:14:06.250
got right now, which might have
been great if you were starting

00:14:06.250 --> 00:14:08.680
out, or great if
you've got an MVP,

00:14:08.680 --> 00:14:10.390
is starting to break
down a little bit

00:14:10.390 --> 00:14:14.130
because we're mixing so
many things into one class.

00:14:14.130 --> 00:14:16.630
So hopefully for those of you
breathing into your paper bags

00:14:16.630 --> 00:14:19.060
earlier, you're starting
to see that we will

00:14:19.060 --> 00:14:21.580
overcome this challenge, right?

00:14:21.580 --> 00:14:23.290
And so the other thing
is that if you're

00:14:23.290 --> 00:14:26.324
testing complex scenarios, this
is almost impossible, right.

00:14:26.324 --> 00:14:28.240
Say you're doing some
sort of interesting list

00:14:28.240 --> 00:14:29.980
transformations,
or something like

00:14:29.980 --> 00:14:32.170
that, to be able to test
it with the widget tester

00:14:32.170 --> 00:14:35.140
would be really difficult.
And it becomes even messier

00:14:35.140 --> 00:14:37.480
when Async code is
involved, and the reason

00:14:37.480 --> 00:14:40.000
is that the test
widgets function does

00:14:40.000 --> 00:14:41.560
some interesting
stuff to override

00:14:41.560 --> 00:14:44.560
the way Async works in Dart,
which makes it a really--

00:14:44.560 --> 00:14:47.594
makes it work really well for
widget tests, but not so--

00:14:47.594 --> 00:14:49.260
it makes it a lot
more complex if you're

00:14:49.260 --> 00:14:52.840
dealing with databases or APIs.

00:14:52.840 --> 00:14:55.090
So what's the solution
to this problem?

00:14:55.090 --> 00:14:57.070
And that is layering.

00:14:57.070 --> 00:14:59.240
And so we heard a bit
about this yesterday,

00:14:59.240 --> 00:15:02.470
and so let's dive into
this a bit more as well.

00:15:02.470 --> 00:15:05.930
So you know, you might have
seen the layers in action.

00:15:05.930 --> 00:15:08.900
This is a Flutter sort
of layered diagram.

00:15:08.900 --> 00:15:12.070
But we can actually use layers
in our own apps as well.

00:15:12.070 --> 00:15:14.680
And so if we look at the
responsibilities of our state

00:15:14.680 --> 00:15:17.650
widget, it's got sort of three
responsibilities right now.

00:15:17.650 --> 00:15:21.220
It's sort of defining
the state and learning

00:15:21.220 --> 00:15:23.200
how to fetch data for that.

00:15:23.200 --> 00:15:25.960
It's also got some logic
about how the counter should

00:15:25.960 --> 00:15:26.800
get incremented.

00:15:26.800 --> 00:15:29.110
You know, in a real
world application

00:15:29.110 --> 00:15:31.230
you might have some
interesting rules around when

00:15:31.230 --> 00:15:32.980
that counter can
actually get incremented,

00:15:32.980 --> 00:15:35.020
or how it gets incremented.

00:15:35.020 --> 00:15:37.810
And then finally, we
want to draw the UI.

00:15:37.810 --> 00:15:41.260
And so all of that right now
is contained within one class.

00:15:41.260 --> 00:15:42.760
So let's look at
how we can actually

00:15:42.760 --> 00:15:44.930
start to break this out.

00:15:44.930 --> 00:15:47.850
The first thing we'll
look at is the data layer.

00:15:47.850 --> 00:15:51.410
So the data layer, the easiest
thing we can actually do

00:15:51.410 --> 00:15:55.460
is just extract that function
out into its own file,

00:15:55.460 --> 00:15:57.300
or something like that.

00:15:57.300 --> 00:15:59.960
And then what we'll do is,
rather than creating the HTTP

00:15:59.960 --> 00:16:01.940
client internally,
we'll actually

00:16:01.940 --> 00:16:04.140
inject the HTTP client.

00:16:04.140 --> 00:16:07.814
So you might have also seen this
exact technique used yesterday.

00:16:07.814 --> 00:16:09.230
And the reason
it's so powerful is

00:16:09.230 --> 00:16:12.140
because if you're in
a browser context,

00:16:12.140 --> 00:16:13.970
you can provide
the browser client.

00:16:13.970 --> 00:16:17.629
If you're in Flutter itself,
you can provide the I/O client.

00:16:17.629 --> 00:16:19.670
And if you want to actually
test these functions,

00:16:19.670 --> 00:16:21.770
you can provide a mock client.

00:16:21.770 --> 00:16:23.360
And so this gives
you full control

00:16:23.360 --> 00:16:26.300
over how and the
environment that you're

00:16:26.300 --> 00:16:27.950
executing these
things in, and it's

00:16:27.950 --> 00:16:31.250
really powerful for testing
and for sharing code.

00:16:31.250 --> 00:16:32.660
Now, this function
could actually

00:16:32.660 --> 00:16:34.040
be used cross-platform as well.

00:16:34.040 --> 00:16:36.290
That's just a
natural sort of thing

00:16:36.290 --> 00:16:38.810
that happens when
you extract it.

00:16:38.810 --> 00:16:41.092
The rest of the function
is basically the same.

00:16:41.092 --> 00:16:42.800
You know, we'll use
the client that we're

00:16:42.800 --> 00:16:44.870
given instead of
creating it internally,

00:16:44.870 --> 00:16:48.320
but the function remains
essentially unchanged.

00:16:48.320 --> 00:16:50.614
So then we kind of come
to this domain layer.

00:16:50.614 --> 00:16:53.030
And this is where you actually
have a ton of good options,

00:16:53.030 --> 00:16:53.738
I actually think.

00:16:53.738 --> 00:16:56.300
So I've been working
a lot with RxDart

00:16:56.300 --> 00:16:58.880
and stream-based architectures.

00:16:58.880 --> 00:17:01.280
There's also some other
interesting projects

00:17:01.280 --> 00:17:04.579
called scoped model, which comes
from the Fuchsia code base.

00:17:04.579 --> 00:17:06.295
I've just ripped
that out shamelessly

00:17:06.295 --> 00:17:07.670
and published it
as a pub package

00:17:07.670 --> 00:17:10.160
if you want to give it a shot.

00:17:10.160 --> 00:17:11.547
And then the final thing is--

00:17:11.547 --> 00:17:13.130
I mean, there's a
lot of options here.

00:17:13.130 --> 00:17:15.740
But one of the popular ones
that I've seen coming up

00:17:15.740 --> 00:17:18.145
is different types of
Redux architectures.

00:17:18.145 --> 00:17:20.270
So I'll focus on that,
because that's a library I'm

00:17:20.270 --> 00:17:22.250
helping to develop.

00:17:22.250 --> 00:17:25.430
And so it's just the
Redux package on pub.

00:17:25.430 --> 00:17:28.050
And so let's take a look
at how that would work.

00:17:28.050 --> 00:17:31.660
So Redux itself is going
to be all pure Dart.

00:17:31.660 --> 00:17:33.170
And so in this
case, what we'll do

00:17:33.170 --> 00:17:35.542
is we'll define the
state of our application.

00:17:35.542 --> 00:17:38.000
And so this is a little bit
different than the state class.

00:17:38.000 --> 00:17:41.510
This just means what sort of
data does my application need.

00:17:41.510 --> 00:17:43.280
And this might be
a list of to do's

00:17:43.280 --> 00:17:47.330
or you know a list of
products, things like that.

00:17:47.330 --> 00:17:50.000
But basically it's just
a plain old Dart object,

00:17:50.000 --> 00:17:52.410
and it should be an
immutable Dart object.

00:17:52.410 --> 00:17:55.460
And so you can use just
the immutable annotation,

00:17:55.460 --> 00:17:58.700
or you can use built value, if
you like that kind of thing,

00:17:58.700 --> 00:18:01.850
to create these sort of
immutable state objects.

00:18:01.850 --> 00:18:03.560
In this case, we
only need to counter,

00:18:03.560 --> 00:18:06.450
so we've got a super simple one.

00:18:06.450 --> 00:18:08.249
The second thing
you'll need is, OK,

00:18:08.249 --> 00:18:10.040
so you're like, OK,
your state's immutable.

00:18:10.040 --> 00:18:11.580
How do you change it?

00:18:11.580 --> 00:18:15.140
And so you change state in
Redux by dispatching actions.

00:18:15.140 --> 00:18:17.070
And so for now we'll
keep it simple,

00:18:17.070 --> 00:18:19.310
and we'll only have the
one action in our app.

00:18:19.310 --> 00:18:22.310
Eventually you can define
many more of these.

00:18:22.310 --> 00:18:26.030
And in Redux, these are
just simple either enums,

00:18:26.030 --> 00:18:27.440
or maybe classes.

00:18:27.440 --> 00:18:28.880
Classes are
necessary if you want

00:18:28.880 --> 00:18:32.270
to deliver some payload
information, such as an ID,

00:18:32.270 --> 00:18:34.880
along with the action.

00:18:34.880 --> 00:18:36.872
So in our case,
we actually don't

00:18:36.872 --> 00:18:38.330
need any payload
information, so we

00:18:38.330 --> 00:18:41.330
can make it just a simple enum.

00:18:41.330 --> 00:18:43.824
Then what we'll have is, in
order to update the state,

00:18:43.824 --> 00:18:45.740
we'll have a function
that's called a reducer.

00:18:45.740 --> 00:18:47.270
Now, this is kind
of a crazy name.

00:18:47.270 --> 00:18:50.840
It's just a function that takes
in two parameters and returns

00:18:50.840 --> 00:18:51.350
something.

00:18:51.350 --> 00:18:53.750
So I don't know, reducer, don't
let that name is scare you.

00:18:53.750 --> 00:18:55.333
I think it scares a
lot of people off.

00:18:55.333 --> 00:18:58.045
It's like a monad or something.

00:18:58.045 --> 00:18:58.920
Don't worry about it.

00:18:58.920 --> 00:19:00.620
It's not a functor or
anything, or it probably is.

00:19:00.620 --> 00:19:01.460
I don't know.

00:19:01.460 --> 00:19:03.860
[LAUGHTER]

00:19:04.820 --> 00:19:06.380
But yeah, so all
this function does

00:19:06.380 --> 00:19:09.170
is take in the previous app
state and the current action

00:19:09.170 --> 00:19:12.440
that's been dispatched, and it
will return a new app state.

00:19:12.440 --> 00:19:14.660
And that's all there
is to it, really.

00:19:14.660 --> 00:19:16.460
So in our case, once
again, because this is

00:19:16.460 --> 00:19:19.124
a simple application,
we'll just say like, hey,

00:19:19.124 --> 00:19:20.540
if the action that
was dispatched,

00:19:20.540 --> 00:19:22.200
it was an increment
action, we'll

00:19:22.200 --> 00:19:24.470
want to return a new
version of the app state

00:19:24.470 --> 00:19:26.944
and increment the
counter while we do so.

00:19:26.944 --> 00:19:29.360
If we don't know how to handle
the action like some jokers

00:19:29.360 --> 00:19:32.099
just dispatching
some crazy actions,

00:19:32.099 --> 00:19:33.640
we'll just return
the previous state,

00:19:33.640 --> 00:19:36.230
you know, no harm, no foul.

00:19:36.230 --> 00:19:39.530
And then we tie all this
together with the store.

00:19:39.530 --> 00:19:43.220
So the store itself just takes
in one required parameter,

00:19:43.220 --> 00:19:45.200
which is the reducer,
and you can optionally

00:19:45.200 --> 00:19:47.520
provide an initial state.

00:19:47.520 --> 00:19:49.280
And so what we can do
with this is then we

00:19:49.280 --> 00:19:52.066
can immediately create the
store and start using it.

00:19:52.066 --> 00:19:53.690
And so we can just
actually immediately

00:19:53.690 --> 00:19:55.934
print out the store's state.

00:19:55.934 --> 00:19:58.100
In this case, we just want
to print out the counter.

00:19:58.100 --> 00:20:02.030
Since we're initializing
it with a counter of 0

00:20:02.030 --> 00:20:03.609
it'll print that.

00:20:03.609 --> 00:20:05.150
And then we want to
change the state,

00:20:05.150 --> 00:20:07.040
so we'll start
dispatching actions.

00:20:07.040 --> 00:20:10.580
So we can do a dispatch, we'll
dispatch our increment action,

00:20:10.580 --> 00:20:13.040
and then at that point we can
print out the state again,

00:20:13.040 --> 00:20:15.150
and it will be 1.

00:20:15.150 --> 00:20:17.180
Notice that this
is all synchronous,

00:20:17.180 --> 00:20:20.180
and that's sort of by
choice, because that

00:20:20.180 --> 00:20:23.870
makes it a little bit easier
to work with and reason about.

00:20:23.870 --> 00:20:27.757
So now let's take a look at
that testing challenge again.

00:20:27.757 --> 00:20:29.840
Because we're just dealing
with a simple function,

00:20:29.840 --> 00:20:33.140
we can actually write a really
easy test for this reducer.

00:20:33.140 --> 00:20:37.220
So we'll actually
just test the reducer.

00:20:37.220 --> 00:20:39.890
We'll just call that
function with a given app

00:20:39.890 --> 00:20:43.010
state, the previous app state.

00:20:43.010 --> 00:20:46.015
The action we give to it
will be an increment action.

00:20:46.015 --> 00:20:48.390
And then we can expect that
the new state that's returned

00:20:48.390 --> 00:20:50.350
from that is equal to 1.

00:20:50.350 --> 00:20:52.560
And so you've actually
gained a lot of testability

00:20:52.560 --> 00:20:55.380
here, because all of
this is just pure Dart.

00:20:55.380 --> 00:20:57.870
It's all extracted out
of this state class.

00:20:57.870 --> 00:21:00.360
You can actually really
easily test this,

00:21:00.360 --> 00:21:04.127
and you can also share this
type of code cross-platform.

00:21:04.127 --> 00:21:06.460
You know, that's not necessarily
the point of this talk,

00:21:06.460 --> 00:21:09.600
but it's just a cool benefit
that you get for kind

00:21:09.600 --> 00:21:12.820
of extracting this layer out.

00:21:12.820 --> 00:21:14.820
So then let's talk
about the UI layer.

00:21:14.820 --> 00:21:17.730
Because this is a Flutter talk,
I'm going to discuss Flutter.

00:21:17.730 --> 00:21:21.460
But this stuff could also be
hooked up to Angular as well.

00:21:21.460 --> 00:21:24.780
So in this case what we'll
do is we'll actually use

00:21:24.780 --> 00:21:26.760
a library called
Flutter_Redux, which

00:21:26.760 --> 00:21:29.670
sort of melds
Redux with Flutter,

00:21:29.670 --> 00:21:32.711
and it provides something
called a store provider.

00:21:32.711 --> 00:21:34.710
And that's a widget that
you put at the very top

00:21:34.710 --> 00:21:36.150
of your hierarchy.

00:21:36.150 --> 00:21:38.230
And guess what, it's
an inherited widget.

00:21:38.230 --> 00:21:39.810
So that's really
cool, because that

00:21:39.810 --> 00:21:41.610
means that the store
is being passed down

00:21:41.610 --> 00:21:45.270
to all of the descendants.

00:21:45.270 --> 00:21:48.270
So now if we need the data
at these points again,

00:21:48.270 --> 00:21:51.240
we could just be
naive and actually use

00:21:51.240 --> 00:21:52.950
the power of inherited widget.

00:21:52.950 --> 00:21:54.810
So we could say,
hey, store provider,

00:21:54.810 --> 00:21:58.000
give me the state of
the counter right now.

00:21:58.000 --> 00:22:00.180
And on the other side,
we could have our button,

00:22:00.180 --> 00:22:02.730
and when it's tapped
we'll say, OK, store,

00:22:02.730 --> 00:22:05.652
I want you to
dispatch that action.

00:22:05.652 --> 00:22:07.110
So this is going
to be interesting,

00:22:07.110 --> 00:22:10.110
because then if we tap on this
thing, you might have noticed,

00:22:10.110 --> 00:22:11.430
where's the StatefulWidget?

00:22:11.430 --> 00:22:14.190
So how do we actually
tell Flutter to redraw?

00:22:14.190 --> 00:22:16.590
So it will actually
dispatch this action.

00:22:16.590 --> 00:22:18.240
The store will be updated.

00:22:18.240 --> 00:22:21.630
But what about state
changes for Flutter, right?

00:22:21.630 --> 00:22:23.850
So this is where we'll
introduce another concept

00:22:23.850 --> 00:22:27.030
from Flutter_Redux, which is
called the store connector.

00:22:27.030 --> 00:22:29.910
And this widget is actually
hopefully pretty simple.

00:22:29.910 --> 00:22:33.040
But what it has is two
required parameters.

00:22:33.040 --> 00:22:35.530
The first parameter is
what's called the converter.

00:22:35.530 --> 00:22:38.520
So this will actually
be given the full store.

00:22:38.520 --> 00:22:41.590
And you can convert that
into some type of view model.

00:22:41.590 --> 00:22:44.700
So in this case, our widget
only cares about the counter.

00:22:44.700 --> 00:22:47.840
So we'll just extract the
counter out of the state.

00:22:47.840 --> 00:22:50.264
The next required parameter
is a builder method,

00:22:50.264 --> 00:22:52.680
or builder function, and you
might have used these before.

00:22:52.680 --> 00:22:55.020
There's like widget
builders, or if you've

00:22:55.020 --> 00:22:57.690
worked with StreamBuilder,
it's got its own sort

00:22:57.690 --> 00:23:00.890
of Async snapshot builder.

00:23:00.890 --> 00:23:05.007
And so this will actually have
a builder method or function

00:23:05.007 --> 00:23:06.090
that takes two parameters.

00:23:06.090 --> 00:23:07.673
And the first is,
of course, the build

00:23:07.673 --> 00:23:09.300
context which you always need.

00:23:09.300 --> 00:23:11.730
And the second is
actually the view model

00:23:11.730 --> 00:23:13.997
that you've gotten
from the converter.

00:23:13.997 --> 00:23:16.080
So in this case we're just
extracting the counter,

00:23:16.080 --> 00:23:17.840
so I'll just name the
view model counter.

00:23:17.840 --> 00:23:19.170
It's the integer.

00:23:19.170 --> 00:23:22.830
And then you can render whatever
widgets you want from this.

00:23:22.830 --> 00:23:26.110
So if we try that tapping
action one more time,

00:23:26.110 --> 00:23:30.510
we can go ahead and swap out
the store provider of context,

00:23:30.510 --> 00:23:31.980
and grabbing the
counter directly

00:23:31.980 --> 00:23:34.440
for our store connector widget.

00:23:34.440 --> 00:23:37.770
Now when we tap on this,
it will update the store.

00:23:37.770 --> 00:23:39.864
And the store will
actually emit changes,

00:23:39.864 --> 00:23:42.030
and that's what the store
connector is listening to.

00:23:42.030 --> 00:23:44.460
It's listening to
changes to the store.

00:23:44.460 --> 00:23:47.100
And then it'll say, OK,
now that I'm connected,

00:23:47.100 --> 00:23:49.620
I know that I need to redraw.

00:23:49.620 --> 00:23:52.860
And so it will go ahead and
just redraw that one widget

00:23:52.860 --> 00:23:55.700
that you provide.

00:23:55.700 --> 00:23:59.060
All right, so if we try that
UI challenge we had earlier,

00:23:59.060 --> 00:24:02.510
if we want to move the counter
that we're displaying from here

00:24:02.510 --> 00:24:04.267
to here, we're all good.

00:24:04.267 --> 00:24:05.600
We're using the store connector.

00:24:05.600 --> 00:24:08.280
We're using our inherited
widgets that we used earlier,

00:24:08.280 --> 00:24:09.860
and it's all good.

00:24:09.860 --> 00:24:13.170
We can just do
that super easily.

00:24:13.170 --> 00:24:14.372
All right, so we did it.

00:24:14.372 --> 00:24:15.830
We can update the
state of our app.

00:24:15.830 --> 00:24:18.620
We can rebuild when
the widget changes.

00:24:18.620 --> 00:24:21.860
We're sharing data across
screens and across widgets.

00:24:21.860 --> 00:24:24.802
We're hooking our widgets up
to databases or web services.

00:24:24.802 --> 00:24:27.260
Now unfortunately, because this
is a bit of a shorter talk,

00:24:27.260 --> 00:24:29.879
I couldn't describe the methods
that Redux has to do that.

00:24:29.879 --> 00:24:31.670
But there's a good,
there's a good solution

00:24:31.670 --> 00:24:32.997
for that with Redux.

00:24:32.997 --> 00:24:34.580
And the other cool
thing is that we're

00:24:34.580 --> 00:24:36.538
starting to gain some
really nice things, which

00:24:36.538 --> 00:24:39.590
is that we're going to make
our app easier to maintain,

00:24:39.590 --> 00:24:42.290
because we can test all
these things really easily.

00:24:42.290 --> 00:24:44.570
They're all isolated,
so if you've

00:24:44.570 --> 00:24:46.970
heard of the single
responsibility principle,

00:24:46.970 --> 00:24:50.090
we don't have everything's sort
of stored in one class anymore.

00:24:50.090 --> 00:24:52.160
We're sort of splitting
that logic out

00:24:52.160 --> 00:24:55.460
into different logical units.

00:24:55.460 --> 00:24:59.030
The other cool thing is
we get some bonuses here.

00:24:59.030 --> 00:25:00.770
So the Redux code
itself can actually

00:25:00.770 --> 00:25:03.260
be shared across the platforms.

00:25:03.260 --> 00:25:05.180
And actually even,
in our data layer,

00:25:05.180 --> 00:25:06.780
we can share that
across platforms,

00:25:06.780 --> 00:25:09.184
which is really pretty cool.

00:25:09.184 --> 00:25:11.100
We're getting some other
interesting benefits,

00:25:11.100 --> 00:25:13.790
which is that you might have
seen we're only redrawing

00:25:13.790 --> 00:25:15.560
part of the widget tree now.

00:25:15.560 --> 00:25:17.810
Because the store connector
is the only thing that

00:25:17.810 --> 00:25:20.900
cares about the state changes
and we haven't lifted our state

00:25:20.900 --> 00:25:24.260
up to the very top, the only
widgets that will get rebuilt

00:25:24.260 --> 00:25:26.810
are the store connector widgets.

00:25:26.810 --> 00:25:28.519
Another really kind
of cool bonus of this

00:25:28.519 --> 00:25:30.934
is that you can actually get
some really interesting crash

00:25:30.934 --> 00:25:31.470
reporting.

00:25:31.470 --> 00:25:34.239
So if you're working
with a big consumer app,

00:25:34.239 --> 00:25:35.780
it's really natural
to have something

00:25:35.780 --> 00:25:39.050
like Crashlytics or
Sentry so that when

00:25:39.050 --> 00:25:40.730
users encounter errors.

00:25:40.730 --> 00:25:42.950
It'll send a crash report
up, and you can actually

00:25:42.950 --> 00:25:44.570
start to aggregate
those crash reports

00:25:44.570 --> 00:25:46.670
and say like, oh
man, all of our users

00:25:46.670 --> 00:25:50.580
are crashing on this screen
and this part of our app.

00:25:50.580 --> 00:25:52.820
But a lot of times you're
like, how did that happen?

00:25:52.820 --> 00:25:53.930
How do I reproduce it?

00:25:53.930 --> 00:25:56.240
You know, you might be
getting some user reports,

00:25:56.240 --> 00:25:59.930
or you might just have this
random line and a huge stack

00:25:59.930 --> 00:26:02.630
trace in Crashlytics,
and you're like, oh god,

00:26:02.630 --> 00:26:04.207
how do I deal with this?

00:26:04.207 --> 00:26:06.290
And so this is really cool
because what you can do

00:26:06.290 --> 00:26:08.220
is, if you use
something like Redux

00:26:08.220 --> 00:26:10.340
or this type of
pattern, what you can do

00:26:10.340 --> 00:26:12.590
is you could actually
say, OK, let's

00:26:12.590 --> 00:26:15.200
send up the state
of the application,

00:26:15.200 --> 00:26:18.620
and let's send up the last 10
actions that actually happened.

00:26:18.620 --> 00:26:20.660
And now what you can do
is, you as a developer,

00:26:20.660 --> 00:26:22.910
you can read that in
addition to the stack trace,

00:26:22.910 --> 00:26:25.010
and you can actually
reproduce the actions

00:26:25.010 --> 00:26:28.250
that the user took
really easily.

00:26:28.250 --> 00:26:30.650
Another kind of interesting
benefit that I didn't quite

00:26:30.650 --> 00:26:33.320
have time to talk about
is Redux was basically

00:26:33.320 --> 00:26:35.930
built to work with hot
reload, and so you actually

00:26:35.930 --> 00:26:37.820
have some Redux dev tools.

00:26:37.820 --> 00:26:40.460
And so as you're
modifying your reducers,

00:26:40.460 --> 00:26:43.160
if you have your Flutter
app running live next to it,

00:26:43.160 --> 00:26:45.080
you can actually
change your reducers,

00:26:45.080 --> 00:26:48.230
and it'll replay all of the
actions that have happened up

00:26:48.230 --> 00:26:49.430
until that point.

00:26:49.430 --> 00:26:52.792
And then it'll actually go
ahead and just redisplay that.

00:26:52.792 --> 00:26:54.500
So it's really kind
of an interesting way

00:26:54.500 --> 00:26:56.780
to work because maybe
you've added five

00:26:56.780 --> 00:26:59.144
to do's to your to do
lists, and then you decide,

00:26:59.144 --> 00:27:00.560
oh actually, I
want to add to do's

00:27:00.560 --> 00:27:02.570
the top rather than the bottom.

00:27:02.570 --> 00:27:05.420
It'll actually just go ahead,
recompute all of those things,

00:27:05.420 --> 00:27:08.602
and show you the result of that.

00:27:08.602 --> 00:27:11.060
The other, I think, thing that's
really kind of interesting

00:27:11.060 --> 00:27:12.822
is that this is Redux is like--

00:27:12.822 --> 00:27:15.280
I'm not, I'm not only trying
to sell Redux at love streams.

00:27:15.280 --> 00:27:17.780
I actually think there's
some interesting stuff.

00:27:17.780 --> 00:27:19.500
But I think it's
a proven concept.

00:27:19.500 --> 00:27:22.310
You have a lot of big companies
like Airbnb and Netflix

00:27:22.310 --> 00:27:24.920
and these types of companies
using this type of pattern

00:27:24.920 --> 00:27:26.720
for a couple of years,
and they've sort of

00:27:26.720 --> 00:27:28.790
done the hard work of
solving the challenges that

00:27:28.790 --> 00:27:31.467
come with these types
of architectures.

00:27:31.467 --> 00:27:33.050
And so there's a lot
of good resources

00:27:33.050 --> 00:27:37.520
out there for how you can
structure your apps by feature,

00:27:37.520 --> 00:27:39.650
how you can share code
across different apps,

00:27:39.650 --> 00:27:41.930
things like that.

00:27:41.930 --> 00:27:45.380
All right, so let's look
at a recap real quick.

00:27:45.380 --> 00:27:49.340
So we started out with a really,
you know, it's not great code

00:27:49.340 --> 00:27:50.830
but don't worry about it.

00:27:50.830 --> 00:27:53.210
It's working for you,
if you have prototype

00:27:53.210 --> 00:27:54.640
or if you're just
getting started,

00:27:54.640 --> 00:27:58.910
feel free to throw everything
in your state class.

00:27:58.910 --> 00:28:02.750
Like I said, don't worry if
that just like freaks you out.

00:28:02.750 --> 00:28:04.280
It's not a big deal.

00:28:04.280 --> 00:28:07.070
We want encourage newcomers
to learn these things

00:28:07.070 --> 00:28:08.450
and to get better with them.

00:28:08.450 --> 00:28:10.430
And if they can see
successes really quickly,

00:28:10.430 --> 00:28:12.690
that's totally cool.

00:28:12.690 --> 00:28:14.810
So the second thing
is that once you

00:28:14.810 --> 00:28:16.700
start to run into some
maintenance issues,

00:28:16.700 --> 00:28:20.850
consider layering as a
solution to that problem.

00:28:20.850 --> 00:28:23.420
So yeah, this was a super simple
example with just a counter.

00:28:23.420 --> 00:28:25.610
If you want to see a more
advanced version of this,

00:28:25.610 --> 00:28:27.110
I've actually been
trying to publish

00:28:27.110 --> 00:28:30.890
a few different examples of
how to build a to-do app using

00:28:30.890 --> 00:28:33.350
lifting state up, using
inherited widgets,

00:28:33.350 --> 00:28:35.210
using scoped model.

00:28:35.210 --> 00:28:38.522
I've also got a couple of Redux
packages on there as well.

00:28:38.522 --> 00:28:40.730
So yeah, please, please
check out fluttersamples.com.

00:28:40.730 --> 00:28:43.760
I've got links to all these
different resources and all

00:28:43.760 --> 00:28:45.980
these different
examples, in addition to

00:28:45.980 --> 00:28:50.420
maybe just demonstrating how you
can write integration tests as

00:28:50.420 --> 00:28:53.960
well, and how you can
share that data layer.

00:28:53.960 --> 00:28:55.220
All right, thank you so much.

00:28:55.220 --> 00:28:57.070
[APPLAUSE]

