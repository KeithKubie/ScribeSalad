WEBVTT
Kind: captions
Language: en

00:00:04.334 --> 00:00:07.100
Pruett: Hi, folks.
So, this is

00:00:07.100 --> 00:00:11.133
Building Aggressively
Compatible Android Games.

00:00:11.133 --> 00:00:12.567
And you're all
in the right spot.

00:00:12.567 --> 00:00:15.200
Great.
Nobody got [indistinct].

00:00:15.200 --> 00:00:17.400
Hi.
My name is Chris.

00:00:17.400 --> 00:00:24.100
I am the CEO of a company
called Robot Invader,

00:00:24.100 --> 00:00:26.667
which is
a mobile game developer

00:00:26.667 --> 00:00:29.367
for Android
and other mobile platforms.

00:00:29.367 --> 00:00:31.801
And actually,
up until about a month ago,

00:00:31.801 --> 00:00:34.934
I was a Google employee.

00:00:34.934 --> 00:00:37.067
I worked
on the Android team

00:00:37.067 --> 00:00:40.133
as a developer advocate
for game developers.

00:00:40.133 --> 00:00:44.100
My role was basically to go
to game developers and say,

00:00:44.100 --> 00:00:46.767
hey, you should make
a cool game for Android,

00:00:46.767 --> 00:00:48.467
and here,
here's how to do it.

00:00:48.467 --> 00:00:51.334
I'll help you do it.

00:00:51.334 --> 00:00:53.501
If you've been to previous IOs,
you might have seen me

00:00:53.501 --> 00:00:57.133
or if you ever, you know,
watch IO sessions on YouTube,

00:00:57.133 --> 00:00:58.501
I've spoke a couple of times
about a game

00:00:58.501 --> 00:01:02.400
that I built while at Google
called Replica Island.

00:01:02.400 --> 00:01:04.367
This talk is not about
Replica Island.

00:01:04.367 --> 00:01:05.667
This talk is about games

00:01:05.667 --> 00:01:07.767
that are aggressively compatible
across devices.

00:01:07.767 --> 00:01:10.701
But I think that Replica Island
fits that description

00:01:10.701 --> 00:01:15.067
and so I'm going to reference it
in my talk and try to,

00:01:15.067 --> 00:01:17.801
you know, use it
as a case study

00:01:17.801 --> 00:01:23.400
of how a game can run
on everything.

00:01:23.400 --> 00:01:27.567
So like I said, the topic today
is device diversity

00:01:27.567 --> 00:01:28.868
and we all know
that there are

00:01:28.868 --> 00:01:31.234
a lot of Android devices
out there, and guess what?

00:01:31.234 --> 00:01:32.334
The common factor is

00:01:32.334 --> 00:01:34.367
that on every single one
of those devices,

00:01:34.367 --> 00:01:35.801
every single one
of those devices

00:01:35.801 --> 00:01:39.133
is owned by somebody who would
like to play video games.

00:01:39.133 --> 00:01:40.901
And they would probably
like to pay you money

00:01:40.901 --> 00:01:42.267
to play those video games,

00:01:42.267 --> 00:01:44.200
and that's why you should be
interested in this.

00:01:44.200 --> 00:01:46.467
Replica Island,
I released about a year ago,

00:01:46.467 --> 00:01:50.501
it's getting close to 2 million
installs at this point.

00:01:50.501 --> 00:01:53.033
We're not quite there yet.
But it's doing pretty well.

00:01:53.033 --> 00:01:54.901
The ratings
are pretty good.

00:01:54.901 --> 00:01:57.334
And I think that,
um, part of the reason

00:01:57.334 --> 00:01:59.968
that it's been
as successful as it is

00:01:59.968 --> 00:02:02.234
is that it runs
on all of these phones.

00:02:02.234 --> 00:02:04.033
You know, we've got
over here on one side,

00:02:04.033 --> 00:02:05.200
we got the G1.

00:02:05.200 --> 00:02:06.934
That's pretty much
the minimum spec.

00:02:06.934 --> 00:02:09.501
I put the Nexus S
as the high end,

00:02:09.501 --> 00:02:11.534
although they are
very quickly phones

00:02:11.534 --> 00:02:13.667
that are coming out
that are faster than that.

00:02:13.667 --> 00:02:16.767
But that's the range, right?
It runs on all those phones.

00:02:16.767 --> 00:02:18.467
It doesn't just run on
those phones, actually.

00:02:18.467 --> 00:02:21.334
It runs on
all these phones too.

00:02:21.334 --> 00:02:23.267
I tried to get this slide
to go faster,

00:02:23.267 --> 00:02:24.701
and this is the maximum speed

00:02:24.701 --> 00:02:26.968
that KeyNote would allow me
to show these phones to you.

00:02:26.968 --> 00:02:28.300
There's a lot of them.

00:02:28.300 --> 00:02:30.300
There's like, 160 or something,
the last time I checked.

00:02:30.300 --> 00:02:32.834
And actually, that data point
is probably three months old,

00:02:32.834 --> 00:02:36.167
which is an eon
in this industry.

00:02:36.167 --> 00:02:37.634
It runs on
all these devices.

00:02:37.634 --> 00:02:39.567
And actually, this is
not an exhaustive list.

00:02:39.567 --> 00:02:42.601
There's quite a number of
Android phones out there today

00:02:42.601 --> 00:02:44.934
that Replica Island
works fine on.

00:02:44.934 --> 00:02:46.400
Oh, yeah.

00:02:46.400 --> 00:02:48.734
It runs on tablets
and TVs and stuff too.

00:02:48.734 --> 00:02:50.300
I didn't really plan this.

00:02:50.300 --> 00:02:54.033
I, of course, I wanted
the game to run on everything

00:02:54.033 --> 00:02:55.167
but when I wrote the game,

00:02:55.167 --> 00:02:57.868
you know,
it was designed for a G1.

00:02:57.868 --> 00:03:00.133
That was the platform
that I was building it on.

00:03:00.133 --> 00:03:03.300
It just turned out that I made
some correct assumptions

00:03:03.300 --> 00:03:04.968
and because I made
those correct assumptions,

00:03:04.968 --> 00:03:07.400
it was very easy to run
on all devices

00:03:07.400 --> 00:03:10.033
and in a couple of cases,
extend what I'd already written

00:03:10.033 --> 00:03:11.601
to work on all devices.

00:03:11.601 --> 00:03:14.133
So today I'll tell you about
what those assumptions were

00:03:14.133 --> 00:03:18.300
and how you can replicate
that on your own games.

00:03:18.300 --> 00:03:21.033
There's also a bunch of stuff
that I did for Replica Island

00:03:21.033 --> 00:03:22.767
that isn't relevant
any longer.

00:03:22.767 --> 00:03:26.334
For example, I spent a long time
on Java optimization.

00:03:26.334 --> 00:03:28.234
Java optimization
matters a whole lot

00:03:28.234 --> 00:03:29.734
if you are targeting a G1.

00:03:29.734 --> 00:03:32.534
It doesn't matter very much
anymore for any other device,

00:03:32.534 --> 00:03:33.901
and there's two reasons
for that.

00:03:33.901 --> 00:03:35.667
One, Java has gotten
a whole lot faster

00:03:35.667 --> 00:03:37.167
with different versions
of Android,

00:03:37.167 --> 00:03:40.234
and number two, the phones have
gotten a whole lot faster.

00:03:40.234 --> 00:03:41.801
Actually, I'll say
three reasons.

00:03:41.801 --> 00:03:43.734
Number three is,
how many game developers

00:03:43.734 --> 00:03:45.100
do we actually have
in the room here

00:03:45.100 --> 00:03:46.601
who are writing games right now?

00:03:46.601 --> 00:03:47.934
Okay. Okay.
That's a pretty good number.

00:03:47.934 --> 00:03:49.901
How many of you
are writing them in Java?

00:03:49.901 --> 00:03:51.734
How many
are using Dalvik

00:03:51.734 --> 00:03:53.367
in the Java language
to build your games?

00:03:53.367 --> 00:03:54.767
Yeah, that's right.

00:03:54.767 --> 00:03:56.400
How many of you are using
C++ and NDK, right? Okay.

00:03:56.400 --> 00:03:59.000
So, that's why Java optimization
doesn't matter any longer.

00:03:59.000 --> 00:04:00.234
And I'm not gonna
talk about it.

00:04:00.234 --> 00:04:02.167
Dalvik is really fast.

00:04:02.167 --> 00:04:04.434
If you want to do that, you can.

00:04:04.434 --> 00:04:06.601
I'll skip it in this talk.

00:04:06.601 --> 00:04:09.267
Before we start talking about
diverse diversity,

00:04:09.267 --> 00:04:10.701
you need to understand

00:04:10.701 --> 00:04:12.667
how the Android compatibility
program works.

00:04:12.667 --> 00:04:14.167
So, let's do another
show of hands.

00:04:14.167 --> 00:04:15.434
How many people
actually knew

00:04:15.434 --> 00:04:18.367
that Android has
a compatibility program?

00:04:18.367 --> 00:04:19.367
Okay.
That's not bad.

00:04:19.367 --> 00:04:21.167
What? 30%, maybe?

00:04:21.167 --> 00:04:22.667
Yeah, Android has
a compatibility program.

00:04:22.667 --> 00:04:26.534
And if you want to build
an Android device

00:04:26.534 --> 00:04:29.234
that's considered compatible,
you have to pay attention to it.

00:04:29.234 --> 00:04:31.467
This is an open source
program.

00:04:31.467 --> 00:04:34.400
You can go check the spec out,
you know, online.

00:04:34.400 --> 00:04:36.000
It's compatibility.Android.com

00:04:36.000 --> 00:04:37.534
and you can read through
the whole spec.

00:04:37.534 --> 00:04:39.968
And any Android phone that's
gonna be considered compatible

00:04:39.968 --> 00:04:43.334
has to meet that spec.

00:04:43.334 --> 00:04:44.501
It's pretty detailed too.

00:04:44.501 --> 00:04:48.100
I mean, it gives
a device manufacturer

00:04:48.100 --> 00:04:50.267
areas where they can make
modifications.

00:04:50.267 --> 00:04:52.000
Like, say they want to have
a different sized screen.

00:04:52.000 --> 00:04:53.467
Well, there's a range
of screen sizes

00:04:53.467 --> 00:04:54.634
that you can support

00:04:54.634 --> 00:04:56.334
and still be considered
Android compatible,

00:04:56.334 --> 00:04:57.801
but it goes into
a lot of detail

00:04:57.801 --> 00:04:59.300
about what you can
and cannot do.

00:04:59.300 --> 00:05:02.901
And the purpose of this spec
is to require

00:05:02.901 --> 00:05:04.334
that people
who are building phones

00:05:04.334 --> 00:05:06.767
to build phones that are
gonna run applications

00:05:06.767 --> 00:05:09.834
for Android Market
that are written correctly.

00:05:09.834 --> 00:05:11.033
So, remember,
I had mentioned, you know,

00:05:11.033 --> 00:05:12.701
all these phones back here?

00:05:12.701 --> 00:05:14.868
Well, guess what?
They're all compatible.

00:05:14.868 --> 00:05:16.033
Every single one of these

00:05:16.033 --> 00:05:20.300
has met the Android
compatibility spec.

00:05:20.300 --> 00:05:22.133
Well, how do we
enforce that? Right?

00:05:22.133 --> 00:05:25.834
How does--how do you know
if a device has passed

00:05:25.834 --> 00:05:28.267
this arbitrary
open source spec?

00:05:28.267 --> 00:05:30.400
Well, Google provides
something called CTS,

00:05:30.400 --> 00:05:32.534
which is a Compatibility
Test Suite.

00:05:32.534 --> 00:05:35.934
This is about
20,000 plus tests

00:05:35.934 --> 00:05:37.834
that a device manufacturer
can download.

00:05:37.834 --> 00:05:40.167
It's also open source,
can run on their device

00:05:40.167 --> 00:05:42.567
and get output from.

00:05:42.567 --> 00:05:44.400
And that output basically says,
yes, I passed,

00:05:44.400 --> 00:05:45.667
or no, I did not.

00:05:45.667 --> 00:05:47.000
And if there were failures,
it says,

00:05:47.000 --> 00:05:49.200
well, you screwed this up,
and you screwed this up,

00:05:49.200 --> 00:05:50.767
and you screwed this up.

00:05:50.767 --> 00:05:54.501
And if the OEM doesn't go back
and correct those failures,

00:05:54.501 --> 00:05:58.467
then there's no chance for them
to access Google services

00:05:58.467 --> 00:06:04.501
like Android Market
and GMAIL and Maps.

00:06:04.501 --> 00:06:07.234
These services are not part
of the Android open source.

00:06:07.234 --> 00:06:12.367
They are given to OEMs on the
condition that they pass CTS.

00:06:12.367 --> 00:06:14.367
So, if you don't have
a compatible device,

00:06:14.367 --> 00:06:16.467
you don't have any of these
installed.

00:06:16.467 --> 00:06:18.901
Another way to think about that
from a developer's perspective

00:06:18.901 --> 00:06:20.868
is that you're using
Android Market

00:06:20.868 --> 00:06:22.534
as your distribution platform,

00:06:22.534 --> 00:06:25.067
you're guaranteed that you're
only going to be distributing

00:06:25.067 --> 00:06:29.667
to devices that have passed
Google's 20,000 tests

00:06:29.667 --> 00:06:34.434
that are required
for compatibility.

00:06:34.434 --> 00:06:35.801
So, that's the basis.

00:06:35.801 --> 00:06:37.767
That's the bedrock stuff
you need to know

00:06:37.767 --> 00:06:41.200
before thinking about
how a single binary

00:06:41.200 --> 00:06:46.400
can be compatible with
all these different devices.

00:06:46.400 --> 00:06:47.834
I'm gonna say
there's three steps

00:06:47.834 --> 00:06:50.067
to aggressive compatibility.

00:06:50.067 --> 00:06:52.100
The first step is
check your assumptions.

00:06:52.100 --> 00:06:53.601
I worked with
a lot of developers

00:06:53.601 --> 00:06:56.834
in my role at Google who had
trouble with compatibility,

00:06:56.834 --> 00:06:59.567
and it wasn't because
they wrote bad code

00:06:59.567 --> 00:07:01.467
and it wasn't because
the devices were broken.

00:07:01.467 --> 00:07:03.467
It's because they originally
wrote that code

00:07:03.467 --> 00:07:04.667
for some other platform,

00:07:04.667 --> 00:07:06.300
and they made a bunch
of assumptions

00:07:06.300 --> 00:07:08.033
that were specific
to that other platform.

00:07:08.033 --> 00:07:10.000
And when they ported the code
over to Android,

00:07:10.000 --> 00:07:11.868
they didn't change
those assumptions,

00:07:11.868 --> 00:07:13.701
and those assumptions
turned out not to be

00:07:13.701 --> 00:07:16.234
the same set of assumptions that
you have to make on Android.

00:07:16.234 --> 00:07:19.934
So, the first point here is
check your assumptions.

00:07:19.934 --> 00:07:21.601
The second is
follow the rules.

00:07:21.601 --> 00:07:23.267
We'll talk about
what these rules are

00:07:23.267 --> 00:07:24.501
in a little bit of detail.

00:07:24.501 --> 00:07:26.501
But the main message here
is there are rules

00:07:26.501 --> 00:07:28.200
that you must maintain
to be compatible,

00:07:28.200 --> 00:07:29.400
and if you break them

00:07:29.400 --> 00:07:32.167
you will crash
on certain devices.

00:07:32.167 --> 00:07:33.667
And the third rule is
manage your spec.

00:07:33.667 --> 00:07:35.601
I'll get into a lot of detail
about that.

00:07:35.601 --> 00:07:38.267
But basically, you can tell
Android Market

00:07:38.267 --> 00:07:41.767
what kind of requirements
your application has.

00:07:41.767 --> 00:07:45.534
There's a secret fourth rule
that's specific to video games,

00:07:45.534 --> 00:07:46.901
and I'll talk about it later,

00:07:46.901 --> 00:07:48.901
but I'm not gonna tell you
what it is right now.

00:07:48.901 --> 00:07:53.267
So, let's talk about
assumptions.

00:07:53.267 --> 00:07:55.334
There's a lot of weird hardware
out there, right?

00:07:55.334 --> 00:07:58.300
I mean, there's weird hardware
out there right now.

00:07:58.300 --> 00:08:00.300
And the thing is,
Android devices

00:08:00.300 --> 00:08:02.234
are coming out really,
really, really fast.

00:08:02.234 --> 00:08:05.767
So you can be guaranteed
that whatever is normal today,

00:08:05.767 --> 00:08:08.067
or whatever is weird today,
will be normal tomorrow

00:08:08.067 --> 00:08:11.634
and something weirder
will have shipped.

00:08:11.634 --> 00:08:13.567
And I had that idea in mind

00:08:13.567 --> 00:08:15.033
when I was working on
Replica Island.

00:08:15.033 --> 00:08:17.234
I didn't know
what was gonna ship,

00:08:17.234 --> 00:08:18.801
but I knew that it wasn't
gonna be exactly the same

00:08:18.801 --> 00:08:20.400
as what had already shipped.

00:08:20.400 --> 00:08:22.534
And I made four
basic assumptions

00:08:22.534 --> 00:08:26.634
that sort of future-proofed my
application for compatibility.

00:08:26.634 --> 00:08:29.534
You have to understand
that I shipped Replica Island,

00:08:29.534 --> 00:08:31.934
I want to say
just over a year ago,

00:08:31.934 --> 00:08:33.834
and most of those phones
on that mega slide

00:08:33.834 --> 00:08:35.734
were not out yet.

00:08:35.734 --> 00:08:40.234
Most of those phones shipped
after I released Replica Island.

00:08:40.234 --> 00:08:43.934
And without me doing anything,
they are still compatible.

00:08:43.934 --> 00:08:46.868
So, I'm gonna chalk that up to
these sort of basic assumptions

00:08:46.868 --> 00:08:48.667
that I made.

00:08:48.667 --> 00:08:53.601
First assumption--there's
no standard for screen size.

00:08:53.601 --> 00:08:56.000
Your screen can be any size
and it can be any resolution.

00:08:56.000 --> 00:09:00.300
Now, there are requirements
in the spec that I mentioned,

00:09:00.300 --> 00:09:02.033
the compatibility spec,

00:09:02.033 --> 00:09:04.467
that require physical size
and density,

00:09:04.467 --> 00:09:06.734
so there's a range that you're
gonna be working within,

00:09:06.734 --> 00:09:09.300
but you can't be guaranteed
that, say,

00:09:09.300 --> 00:09:13.234
all of your devices
are gonna match 480x320.

00:09:13.234 --> 00:09:14.434
That's what the G1 is.

00:09:14.434 --> 00:09:16.267
Nor can you be guaranteed
that all devices

00:09:16.267 --> 00:09:19.200
will match 800x480,
or something like that.

00:09:19.200 --> 00:09:22.501
There's basically
no standard at all.

00:09:22.501 --> 00:09:24.133
And so you need to deal
with that.

00:09:24.133 --> 00:09:25.300
And the best way
to deal with it

00:09:25.300 --> 00:09:29.067
is to allow your graphics
to scale.

00:09:29.067 --> 00:09:30.534
If you're using OpenGL

00:09:30.534 --> 00:09:33.467
and if you've attended my other
IO sessions in the past--

00:09:33.467 --> 00:09:35.167
you should be--

00:09:35.167 --> 00:09:37.767
it's very easy
to scale your graphics.

00:09:37.767 --> 00:09:41.667
Very often, it can come down
to a GL viewport call.

00:09:41.667 --> 00:09:46.534
In my case, I actually change
the GL viewport,

00:09:46.534 --> 00:09:49.300
and I also scale the content
of my scene a little bit

00:09:49.300 --> 00:09:52.834
to match the aspect ratio
of the display.

00:09:52.834 --> 00:09:56.434
You can see here that at
the 480x320 version of the game,

00:09:56.434 --> 00:09:58.634
you can see a little bit
less to the right

00:09:58.634 --> 00:10:01.334
than the 800x480 version.

00:10:01.334 --> 00:10:05.434
A more dramatic example is
the QVGA versus FYVGA

00:10:05.434 --> 00:10:06.634
versus the game.

00:10:06.634 --> 00:10:10.033
Same game, same graphics,
but what I do is

00:10:10.033 --> 00:10:12.701
I look at the size
of the screen at runtime.

00:10:12.701 --> 00:10:15.400
I have a fixed height
that I want to align to

00:10:15.400 --> 00:10:18.701
that I've fixed
for game design purposes.

00:10:18.701 --> 00:10:23.300
It's basically 480 pixels tall
because that's what the G1 had.

00:10:23.300 --> 00:10:24.834
I scale everything up
to match that height

00:10:24.834 --> 00:10:28.067
and then I allow the left
and right sides of the screen

00:10:28.067 --> 00:10:31.000
to grow or stretch
or stretch or contract.

00:10:31.000 --> 00:10:32.968
And for my particular
game design,

00:10:32.968 --> 00:10:34.534
that's completely acceptable.

00:10:34.534 --> 00:10:37.133
Allows the game to run
on any device.

00:10:37.133 --> 00:10:40.267
If I'd been using, if I'd made
a 3D game that has perspective,

00:10:40.267 --> 00:10:41.767
this would have been
a lot simpler.

00:10:41.767 --> 00:10:44.434
I could just change the viewport
to match the display,

00:10:44.434 --> 00:10:47.067
no problem, just a matrix,
no big deal.

00:10:47.067 --> 00:10:52.133
But if I wasn't using OpenGL,
the actual Android layout system

00:10:52.133 --> 00:10:55.167
has all kinds of tools
for scaling graphics

00:10:55.167 --> 00:10:56.801
and moving things around
and adjusting them.

00:10:56.801 --> 00:10:58.400
But I think probably most people
in the room here

00:10:58.400 --> 00:10:59.734
are using OpenGL.

00:10:59.734 --> 00:11:01.167
Key message is not
that it's hard

00:11:01.167 --> 00:11:05.434
but you have to think about it
before you write your game.

00:11:05.434 --> 00:11:08.033
The other thing
that I did correctly

00:11:08.033 --> 00:11:09.334
but I would do better next time

00:11:09.334 --> 00:11:12.601
is I shipped one set of
resolution of graphics

00:11:12.601 --> 00:11:14.000
and I scale up.

00:11:14.000 --> 00:11:16.934
And the resolution
that I shipped was HVGA.

00:11:16.934 --> 00:11:20.534
HVGA scaled up on a wide
VGA display like a Nexus One

00:11:20.534 --> 00:11:22.300
or Galaxy S.

00:11:22.300 --> 00:11:23.734
It looks okay.

00:11:23.734 --> 00:11:25.701
The space, still pretty small
so I can get away with it.

00:11:25.701 --> 00:11:27.334
When you run Replica Island
on a zoom,

00:11:27.334 --> 00:11:28.634
you'll see it looks
a little bit pixilated

00:11:28.634 --> 00:11:30.834
and that's because
pretty low resolution art

00:11:30.834 --> 00:11:34.200
is being scaled up to a
pretty large resolution display.

00:11:34.200 --> 00:11:36.901
So if I were smarter
when I built this game,

00:11:36.901 --> 00:11:38.934
what I would have done is made
higher resolution graphics

00:11:38.934 --> 00:11:42.133
and scaled down
on smaller screens.

00:11:42.133 --> 00:11:44.767
Ship with, say,
zoom compliant graphics

00:11:44.767 --> 00:11:46.968
and then plan to scale
everything down, you know,

00:11:46.968 --> 00:11:51.534
when you run on a G1 or
when you run on the Nexus One.

00:11:51.534 --> 00:11:53.334
That way, scaling down
always looks good.

00:11:53.334 --> 00:11:57.133
Scaling up, not so much.

00:11:57.133 --> 00:11:58.467
Second major assumption
that I made

00:11:58.467 --> 00:12:00.601
was that the G1 was
going to be the minimum spec.

00:12:00.601 --> 00:12:02.200
That turned out to be
pretty true.

00:12:02.200 --> 00:12:03.701
There are two devices
in the world

00:12:03.701 --> 00:12:06.367
that I know to be slower
than the G1 for games.

00:12:06.367 --> 00:12:08.667
Those are the HTC Tattoo
and HTC Wildfire,

00:12:08.667 --> 00:12:11.267
and those devices are slower
because they do not have a GPU.

00:12:11.267 --> 00:12:12.934
Game still runs
on those devices

00:12:12.934 --> 00:12:15.734
because Android provides
a software renderer

00:12:15.734 --> 00:12:18.567
for OpenGL ES1.0

00:12:18.567 --> 00:12:20.467
which is what you use
if you use the emulator.

00:12:20.467 --> 00:12:21.901
But as you know,
if you use the emulator,

00:12:21.901 --> 00:12:23.000
it's a little bit slow.

00:12:23.000 --> 00:12:24.968
So, game is playable
on those devices.

00:12:24.968 --> 00:12:26.033
It's a little bit slower
than I'd like,

00:12:26.033 --> 00:12:28.334
but you know, no big deal.

00:12:28.334 --> 00:12:32.033
For all intents and purposes,
the G1 is the minimum spec.

00:12:32.033 --> 00:12:33.701
For the vast majority of devices
out there,

00:12:33.701 --> 00:12:39.167
it doesn't get any slower
than that.

00:12:39.167 --> 00:12:43.234
I assumed that OpenGL, yes,
was going to be the fastest way

00:12:43.234 --> 00:12:45.934
across all devices
to draw 2D content.

00:12:45.934 --> 00:12:50.801
This turned out to be true,
but it's a subtle point.

00:12:50.801 --> 00:12:55.934
It's a subtle point because
the way to draw fast 2D graphics

00:12:55.934 --> 00:13:00.701
on a Nexus One might actually be
to use the CPU.

00:13:00.701 --> 00:13:04.367
That's because the Nexus One CPU
is really, really fast.

00:13:04.367 --> 00:13:07.601
It's in fact so fast
that it can outrun its GPU

00:13:07.601 --> 00:13:10.100
for doing 2D blitz.

00:13:10.100 --> 00:13:11.501
There are actually
a lot of devices

00:13:11.501 --> 00:13:13.534
that have really fast CPUs
that you can do this on.

00:13:13.534 --> 00:13:15.100
But it's only
the high-end devices.

00:13:15.100 --> 00:13:19.434
I say the Nexus One,
probably the Galaxy S,

00:13:19.434 --> 00:13:21.367
those are about the two that
I've tested, the Nexus S.

00:13:21.367 --> 00:13:22.767
Right?

00:13:22.767 --> 00:13:24.367
There are devices out there
that have real fast CPUs

00:13:24.367 --> 00:13:27.767
and can--you can render
the same thing in software

00:13:27.767 --> 00:13:28.801
faster than you can
render in hardware.

00:13:28.801 --> 00:13:30.601
But the reason to use
OpenGL ES

00:13:30.601 --> 00:13:32.334
is that you want to be
compatible with every device,

00:13:32.334 --> 00:13:34.934
not just those superfast
CPU devices.

00:13:34.934 --> 00:13:37.434
And generally, the GPU
is the way to go.

00:13:37.434 --> 00:13:41.000
It is the fastest path
for rendering 2D concept.

00:13:41.000 --> 00:13:43.400
I wrote this application
called Sprite Method Test,

00:13:43.400 --> 00:13:44.868
which is open source.

00:13:44.868 --> 00:13:46.767
You can search for it if you
want to test this stuff out.

00:13:46.767 --> 00:13:48.701
But it lets you draw the
same scene with CPU and GPU

00:13:48.701 --> 00:13:51.667
and, you know,
see what the differences are.

00:13:51.667 --> 00:13:53.200
I also--this is
my fourth assumption.

00:13:53.200 --> 00:13:54.501
I assumed that all the devices

00:13:54.501 --> 00:13:56.267
were gonna kind of be
like the G1.

00:13:56.267 --> 00:13:57.968
I knew that they were
gonna change and be faster

00:13:57.968 --> 00:13:59.267
and have different sized
screens,

00:13:59.267 --> 00:14:01.434
but I assumed that they were
gonna have a trackball

00:14:01.434 --> 00:14:03.000
and that they were gonna
have single touch displays

00:14:03.000 --> 00:14:06.033
like the G1 and that they might
have a keyboard or not.

00:14:06.033 --> 00:14:08.667
You know, that was totally
false, as we know now, right?

00:14:08.667 --> 00:14:11.167
There's a whole lot of
different phones out there.

00:14:11.167 --> 00:14:13.033
And they've got a lot of
different interfaces

00:14:13.033 --> 00:14:15.167
that people are gonna
play with.

00:14:15.167 --> 00:14:19.968
Some of them like the Nexus One
actually do have a trackball.

00:14:19.968 --> 00:14:21.434
Some of them
have keyboards.

00:14:21.434 --> 00:14:25.033
Some of them have little dinky
D-Pads on those keyboards.

00:14:25.033 --> 00:14:30.033
Some have really nice
multifinger multitouch.

00:14:30.033 --> 00:14:33.400
Some of them are weird, like
this device up in the top left.

00:14:33.400 --> 00:14:36.734
That has a track pad
on the back of the display

00:14:36.734 --> 00:14:38.701
that the Xperia Play
of course,

00:14:38.701 --> 00:14:42.033
has real game controls,
a D-Pad and buttons.

00:14:42.033 --> 00:14:45.767
And then there are devices--
so far only one that I know of--

00:14:45.767 --> 00:14:47.634
like the original Xperia

00:14:47.634 --> 00:14:49.334
which are problematic
for game developers

00:14:49.334 --> 00:14:51.834
because it doesn't have
really any hardware buttons

00:14:51.834 --> 00:14:54.167
except for back
and menu and home.

00:14:54.167 --> 00:14:56.200
It doesn't support
multitouch.

00:14:56.200 --> 00:14:57.667
So, where do you put
your game controls?

00:14:57.667 --> 00:14:59.200
If you have a game you can play
with a single finger,

00:14:59.200 --> 00:15:00.267
you're all right.

00:15:00.267 --> 00:15:02.000
But if you are--
if you're like my game,

00:15:02.000 --> 00:15:06.467
which is--requires at least
motion and jump, you know,

00:15:06.467 --> 00:15:09.934
how do you deal with that?

00:15:09.934 --> 00:15:12.767
Well, a solution for me was to
provide customizable controls.

00:15:12.767 --> 00:15:14.501
This is a solution
I did not come to

00:15:14.501 --> 00:15:16.234
until after I'd shipped the game
'cause like I said,

00:15:16.234 --> 00:15:19.200
a lot of those devices came out
after I shipped Replica Island.

00:15:19.200 --> 00:15:21.267
But in all of the updates
I've made since shipping

00:15:21.267 --> 00:15:24.100
have been to add more
customizable controls.

00:15:24.100 --> 00:15:25.567
So now if you download
Replica Island

00:15:25.567 --> 00:15:27.000
and go into the options,

00:15:27.000 --> 00:15:28.767
you can set up how you want
to control the game

00:15:28.767 --> 00:15:31.033
with a lot of granularity.

00:15:31.033 --> 00:15:33.901
Breaks down into
four major spots.

00:15:33.901 --> 00:15:35.467
There's the trackball support,

00:15:35.467 --> 00:15:37.734
which is the original version
of the controls that I wrote.

00:15:37.734 --> 00:15:40.467
There's keyboard support
which gives me access

00:15:40.467 --> 00:15:42.934
to things like the Xperia Play
without any changes.

00:15:42.934 --> 00:15:44.501
Virtual pad which are for

00:15:44.501 --> 00:15:47.567
just buttons on the screen
but requires multitouch.

00:15:47.567 --> 00:15:51.167
And Tilt for devices like
the original Xperia

00:15:51.167 --> 00:15:53.067
that only have single touch.

00:15:53.067 --> 00:15:54.534
And between these four,

00:15:54.534 --> 00:15:55.934
I pretty much
seem to have covered

00:15:55.934 --> 00:15:58.200
all of the devices
in the world.

00:15:58.200 --> 00:16:02.200
Like I said, as far as I know,
all devices out there

00:16:02.200 --> 00:16:05.501
that are compatible and have
Android Market installed

00:16:05.501 --> 00:16:08.133
you can play this game on.

00:16:08.133 --> 00:16:10.767
The original control scheme
that I came up with

00:16:10.767 --> 00:16:12.300
was designed around the idea

00:16:12.300 --> 00:16:15.100
that some displays
are gonna be single touch.

00:16:15.100 --> 00:16:16.734
So I had the trackball
for motion

00:16:16.734 --> 00:16:19.167
and I have these two mutually
exclusive buttons on the screen

00:16:19.167 --> 00:16:20.901
for jump and attack,

00:16:20.901 --> 00:16:23.934
and that way, you never have to
have two fingers on the screen.

00:16:23.934 --> 00:16:25.567
But nowadays, you know,

00:16:25.567 --> 00:16:27.167
now we know that there's
a lot more devices out there

00:16:27.167 --> 00:16:30.300
that have all kinds of
multitouch points.

00:16:30.300 --> 00:16:31.834
So it's probably important
to talk a little bit

00:16:31.834 --> 00:16:33.601
about the different types
of multitouch screens

00:16:33.601 --> 00:16:36.334
that are out there.

00:16:36.334 --> 00:16:38.767
Multitouch screens basically
come in three flavors.

00:16:38.767 --> 00:16:41.667
There's single touch.
Right?

00:16:41.667 --> 00:16:44.300
Multitouch.

00:16:44.300 --> 00:16:47.367
And then there's what I call
crappy multitouch.

00:16:47.367 --> 00:16:49.400
And crappy multitouch
is what my best friend,

00:16:49.400 --> 00:16:52.467
the Nexus One, has.

00:16:52.467 --> 00:16:54.834
Crappy multitouch
is a multitouch display

00:16:54.834 --> 00:16:57.701
that can--that can detect
two fingers at the same time.

00:16:57.701 --> 00:17:00.100
But when those pointers
are moving,

00:17:00.100 --> 00:17:03.300
it can swap the components
of one pointer for the other

00:17:03.300 --> 00:17:04.701
in a very specific case.

00:17:04.701 --> 00:17:06.667
And that case is
when the two pointers

00:17:06.667 --> 00:17:09.200
cross the same horizontal
or vertical axis.

00:17:09.200 --> 00:17:12.400
So the caonical problem case
for this type of display

00:17:12.400 --> 00:17:14.434
is if you have a finger
on one side of the display

00:17:14.434 --> 00:17:15.701
and another finger on
the other side of the display

00:17:15.701 --> 00:17:17.334
and you drag them across,

00:17:17.334 --> 00:17:19.834
at that vertical line
where they pass

00:17:19.834 --> 00:17:21.334
you may get
component swapping.

00:17:21.334 --> 00:17:23.634
So, your X from pointer one
may suddenly become

00:17:23.634 --> 00:17:25.033
your X from pointer two.

00:17:25.033 --> 00:17:27.100
And if you're drawing a line
on the display

00:17:27.100 --> 00:17:29.067
where those fingers are,
you'll see them go like this,

00:17:29.067 --> 00:17:30.834
which is really frustrating
for game developers

00:17:30.834 --> 00:17:33.467
because if you want to have
a dual stick control scheme--

00:17:33.467 --> 00:17:35.167
which I recommend
you not do anyway--

00:17:35.167 --> 00:17:37.534
but if you wanted to have
a dual stick control scheme,

00:17:37.534 --> 00:17:40.267
you know, that's gonna be
two fingers

00:17:40.267 --> 00:17:42.434
that are passing
the same horizontal axis,

00:17:42.434 --> 00:17:44.100
and you're gonna get
component swapping,

00:17:44.100 --> 00:17:48.501
and it's gonna be
very difficult to control.

00:17:48.501 --> 00:17:50.934
So you can still deal with
crappy multitouch displays.

00:17:50.934 --> 00:17:53.000
My solution was just to get rid
of all vertical motion

00:17:53.000 --> 00:17:55.200
in the fingers...
you know, I have a slider

00:17:55.200 --> 00:17:58.400
that moves left and right
with one finger

00:17:58.400 --> 00:18:00.067
and buttons
on the other side.

00:18:00.067 --> 00:18:01.467
And there's
this horizontal line

00:18:01.467 --> 00:18:02.667
that they are both on,

00:18:02.667 --> 00:18:04.367
but they never move vertically
to cross it.

00:18:04.367 --> 00:18:07.901
And so, this actually works
pretty well on the Nexus One.

00:18:07.901 --> 00:18:10.701
In fact, when I showed it
to some colleagues

00:18:10.701 --> 00:18:13.767
who were aware of the crappy
multitouch problem,

00:18:13.767 --> 00:18:15.167
they were impressed

00:18:15.167 --> 00:18:16.767
that I was actually able
to get this to work.

00:18:16.767 --> 00:18:18.901
They thought I'd done some
complicated heuristic,

00:18:18.901 --> 00:18:21.200
you know, to unswap my control
points or something.

00:18:21.200 --> 00:18:22.567
Nothing like that.

00:18:22.567 --> 00:18:26.133
Just made sure that there was
no vertical motion.

00:18:26.133 --> 00:18:29.033
Couple of other tricks
related to screens.

00:18:29.033 --> 00:18:33.634
The back and menu keys
on a lot of devices like,

00:18:33.634 --> 00:18:37.267
again, my friend, the Nexus One,
are flush with the display.

00:18:37.267 --> 00:18:38.868
And that means
if you have buttons

00:18:38.868 --> 00:18:40.133
on the right side
of the display

00:18:40.133 --> 00:18:41.834
or you're gonna use
a trackball for control,

00:18:41.834 --> 00:18:44.801
it's pretty easy
to slip off the track pad

00:18:44.801 --> 00:18:46.300
and hit the back or menu
buttons.

00:18:46.300 --> 00:18:47.901
And that's a pretty bad
user interface

00:18:47.901 --> 00:18:50.534
because usually those buttons
take you out of the game.

00:18:50.534 --> 00:18:53.901
So, for Replica Island,
I ignore those buttons

00:18:53.901 --> 00:18:56.200
if they happen to occur
within 400 milliseconds

00:18:56.200 --> 00:18:57.534
of a game event.

00:18:57.534 --> 00:18:59.334
A game event is the user
touched the screen

00:18:59.334 --> 00:19:01.167
or the user touched
the trackball.

00:19:01.167 --> 00:19:02.634
So that means if the user's
touching the screen

00:19:02.634 --> 00:19:04.968
and they slide off
and they hit the back button,

00:19:04.968 --> 00:19:06.234
nothing is gonna happen,

00:19:06.234 --> 00:19:07.501
'cause I'm gonna ignore
that back button.

00:19:07.501 --> 00:19:08.834
But if they pick
their finger up

00:19:08.834 --> 00:19:10.400
and they put it back down
on the back button,

00:19:10.400 --> 00:19:12.200
that actually takes longer
than 400 milliseconds.

00:19:12.200 --> 00:19:14.334
So the back when we read it,
it'll be fine.

00:19:14.334 --> 00:19:18.234
There's no mis-clicking.

00:19:18.234 --> 00:19:20.234
You should also be aware
that these devices

00:19:20.234 --> 00:19:22.167
have really small buses,
right?

00:19:22.167 --> 00:19:24.501
The memory bandwidth
is not good.

00:19:24.501 --> 00:19:27.334
That means loading your texture
to VRAM takes time,

00:19:27.334 --> 00:19:30.400
and you probably can't do it
at runtime.

00:19:30.400 --> 00:19:32.734
One solution to that is to use
texture compression.

00:19:32.734 --> 00:19:34.234
There's about four types
of texture compression

00:19:34.234 --> 00:19:35.834
in the world
out there today.

00:19:35.834 --> 00:19:40.767
There's ATITC, which
is proprietary to ATI devices--

00:19:40.767 --> 00:19:42.801
Snap Dragon, okay,
things like that,

00:19:42.801 --> 00:19:44.734
stuff that Qualcomm makes
mostly.

00:19:44.734 --> 00:19:48.367
There's PVRTC, which is
proprietary to power VR devices

00:19:48.367 --> 00:19:51.701
like the Droid.

00:19:51.701 --> 00:19:55.267
There is DXT which you'll find
in video devices

00:19:55.267 --> 00:19:57.267
like the Zoom,
also proprietary.

00:19:57.267 --> 00:19:58.801
There's ETC1.

00:19:58.801 --> 00:20:03.200
ETC1 is a non-proprietary format
that's supported by all devices

00:20:03.200 --> 00:20:05.234
that support OpenGL ES2.0.

00:20:05.234 --> 00:20:06.934
So it's great.
You can use it.

00:20:06.934 --> 00:20:10.167
Its fatal flaw is
that it doesn't support Alpha.

00:20:10.167 --> 00:20:12.067
You can't have
an Alpha Channel

00:20:12.067 --> 00:20:13.968
or do any sort of transparency
with ETC1.

00:20:13.968 --> 00:20:15.534
So, some developers are
really tricky. Right?

00:20:15.534 --> 00:20:17.968
Some developers have shown me
that they take their Colormap

00:20:17.968 --> 00:20:19.734
and they take their Alpha map
and they save it

00:20:19.734 --> 00:20:20.968
as two different textures
and they put them back together

00:20:20.968 --> 00:20:22.100
in the shader.

00:20:22.100 --> 00:20:24.000
Solved. Okay.

00:20:24.000 --> 00:20:28.634
You know, or you can
choose to do what I did

00:20:28.634 --> 00:20:31.367
which is just not compress
your textures.

00:20:31.367 --> 00:20:33.968
I was actually able to fit
the whole game uncompressed

00:20:33.968 --> 00:20:35.767
in VRAM, so didn't
have to worry about it.

00:20:35.767 --> 00:20:38.901
But if you are not like me,
and you're worried about

00:20:38.901 --> 00:20:40.567
fitting into VRAM
on all devices,

00:20:40.567 --> 00:20:43.801
you should be aware that texture
compression is device specific.

00:20:43.801 --> 00:20:46.767
Now, there is a little solution
that's better than ETC1

00:20:46.767 --> 00:20:48.267
that we'll talk about
in a little bit.

00:20:48.267 --> 00:20:52.501
But you should know that
if you do decide to use ETC1,

00:20:52.501 --> 00:20:56.767
OpenGL ES represents a 2.0,
which is what is required.

00:20:56.767 --> 00:20:59.067
It represents the vast majority
of devices out there,

00:20:59.067 --> 00:21:00.634
over--greater than 70%.

00:21:00.634 --> 00:21:02.667
There's some question marks
on this slide

00:21:02.667 --> 00:21:04.901
because the parsing tool we used
to generate this data,

00:21:04.901 --> 00:21:06.033
like, totally failed.

00:21:06.033 --> 00:21:10.267
But even if we assigned
OpenGL ES1.0

00:21:10.267 --> 00:21:12.067
to that question mark part,

00:21:12.067 --> 00:21:14.000
we could see that the vast
majority of devices

00:21:14.000 --> 00:21:15.234
are 2.0 capable.

00:21:15.234 --> 00:21:17.701
So if you want to rely on
something like ETC1,

00:21:17.701 --> 00:21:20.167
you can safely do it.

00:21:20.167 --> 00:21:22.868
Same goes for
OpenGL extensions.

00:21:22.868 --> 00:21:24.300
Extensions are a system

00:21:24.300 --> 00:21:26.501
by which the OpenGL spec
can be extended.

00:21:26.501 --> 00:21:27.968
They're optional.

00:21:27.968 --> 00:21:30.434
Some hardware's going to
support them, some is not.

00:21:30.434 --> 00:21:33.701
There's a GL extension string
which contains at runtime

00:21:33.701 --> 00:21:35.567
which extensions
a current device supports,

00:21:35.567 --> 00:21:37.067
and you can query that.

00:21:37.067 --> 00:21:39.067
You should definitely do it
before using any extensions,

00:21:39.067 --> 00:21:40.434
otherwise you may
crash on a device

00:21:40.434 --> 00:21:42.634
that doesn't support the
extensions you want to use.

00:21:42.634 --> 00:21:44.701
I used two in Replica Island,

00:21:44.701 --> 00:21:46.868
Draw Texture
and Vertex Buffer Objects.

00:21:46.868 --> 00:21:48.067
Both of those are optional,

00:21:48.067 --> 00:21:50.534
and support for them
seems to be universal.

00:21:50.534 --> 00:21:55.367
But I still check for them
just in case.

00:21:55.367 --> 00:21:56.868
So, let's move on
to rules.

00:21:56.868 --> 00:21:59.734
We talked about assumptions
you need to--you can make,

00:21:59.734 --> 00:22:01.300
and those assumptions
that you cannot make

00:22:01.300 --> 00:22:02.767
to build a compatible game.

00:22:02.767 --> 00:22:04.167
Now, what are the rules?

00:22:04.167 --> 00:22:08.267
What are the borderline things
you should totally not do?

00:22:08.267 --> 00:22:10.334
Probably, at least three
other people at Google IO

00:22:10.334 --> 00:22:12.334
have talked about this
because it ended up affecting

00:22:12.334 --> 00:22:14.234
a lot of apps
when the Zoom came out.

00:22:14.234 --> 00:22:16.667
But if you didn't know,

00:22:16.667 --> 00:22:19.567
it turns out that devices have
different default orientations.

00:22:19.567 --> 00:22:20.701
If you're holding a tablet,

00:22:20.701 --> 00:22:22.934
its default orientation
is landscape,

00:22:22.934 --> 00:22:25.234
and if you have a phone or
something like the Galaxy Tab,

00:22:25.234 --> 00:22:27.100
its default orientation
is portrait.

00:22:27.100 --> 00:22:28.868
And you're like,
like, why do I care, right?

00:22:28.868 --> 00:22:30.133
Because when you
run your game,

00:22:30.133 --> 00:22:31.767
you're gonna just
set the orientation

00:22:31.767 --> 00:22:33.767
to whatever you want,
and that's what's gonna display.

00:22:33.767 --> 00:22:36.000
Well, you care because
accelerometer data

00:22:36.000 --> 00:22:37.367
that you get
out of the hardware

00:22:37.367 --> 00:22:40.834
is relative to the default
orientation of the device.

00:22:40.834 --> 00:22:43.434
So if you have any sort of
tilt or orientation controls

00:22:43.434 --> 00:22:47.100
in your game, and your method
is just to suck those

00:22:47.100 --> 00:22:48.934
out of the hardware
and say, okay,

00:22:48.934 --> 00:22:50.167
it looks like Y decreased--

00:22:50.167 --> 00:22:52.601
that means the user
is tilting left--

00:22:52.601 --> 00:22:53.834
you're gonna be
sorely disappointed

00:22:53.834 --> 00:22:55.300
when you run on a device

00:22:55.300 --> 00:22:56.634
that has a different
default orientation

00:22:56.634 --> 00:23:00.100
because your controls
will all be 90 degrees off.

00:23:00.100 --> 00:23:02.000
This is really easy to fix
once you know about it.

00:23:02.000 --> 00:23:04.133
In fact, NVIDIA
has provided a useful function

00:23:04.133 --> 00:23:06.434
to just convert between

00:23:06.434 --> 00:23:09.234
the device specific
accelerometer data

00:23:09.234 --> 00:23:12.534
and a canonical screen space
accelerometer version.

00:23:12.534 --> 00:23:15.701
And this is my sort of
Java language

00:23:15.701 --> 00:23:17.234
version of their function.

00:23:17.234 --> 00:23:21.167
But if you check out their
Tegra Zone developer area

00:23:21.167 --> 00:23:22.601
on their website,

00:23:22.601 --> 00:23:23.968
you can find the original
C++ version.

00:23:23.968 --> 00:23:26.133
I just dropped this
into Replica Island,

00:23:26.133 --> 00:23:29.000
and it solved all my problems.
It was great.

00:23:29.000 --> 00:23:30.834
Another rule--
if you're using JNI,

00:23:30.834 --> 00:23:32.667
which is
the Java Native Interface,

00:23:32.667 --> 00:23:35.901
that's the system by which you
call from some other language,

00:23:35.901 --> 00:23:37.367
like the Java language,

00:23:37.367 --> 00:23:39.133
through Dalvik
into native code.

00:23:39.133 --> 00:23:40.701
If you're using it,
you need to be careful

00:23:40.701 --> 00:23:43.601
because it's a little fragile.

00:23:43.601 --> 00:23:46.567
In particular,
the JNIEnv variable,

00:23:46.567 --> 00:23:48.434
which comes down
with every callback,

00:23:48.434 --> 00:23:49.834
you can't cache that.

00:23:49.834 --> 00:23:52.200
It changes every time,
or it could potentially change

00:23:52.200 --> 00:23:55.033
every time you make
that callback.

00:23:55.033 --> 00:23:56.968
And it could change
if the callback is called

00:23:56.968 --> 00:23:58.167
from a different thread.

00:23:58.167 --> 00:24:01.133
And just for a lot of fun,
if you cache it,

00:24:01.133 --> 00:24:03.501
and if you use the wrong
environment variable

00:24:03.501 --> 00:24:04.868
in the wrong context,

00:24:04.868 --> 00:24:07.434
you will get extremely difficult
to debug crashes,

00:24:07.434 --> 00:24:09.067
and they won't be universal.

00:24:09.067 --> 00:24:11.000
They'll be things like
horrible race conditions

00:24:11.000 --> 00:24:12.868
that work on some devices
and not others.

00:24:12.868 --> 00:24:14.567
Don't ever cache
this variable.

00:24:14.567 --> 00:24:17.400
I worked with one
very well known developer

00:24:17.400 --> 00:24:19.501
who had released
a popular Android game,

00:24:19.501 --> 00:24:22.033
and it worked
on all devices except for one.

00:24:22.033 --> 00:24:23.634
And the developer
was positive that

00:24:23.634 --> 00:24:25.100
that device was broken
because...

00:24:25.100 --> 00:24:26.434
it just didn't work
on that thing.

00:24:26.434 --> 00:24:27.667
Everything else worked.

00:24:27.667 --> 00:24:30.734
Just the one device...
didn't work on.

00:24:30.734 --> 00:24:32.534
And we debugged it together

00:24:32.534 --> 00:24:34.167
and when we got
to the bottom of it,

00:24:34.167 --> 00:24:35.667
it turned out that he was
caching this variable

00:24:35.667 --> 00:24:38.234
and on that particular device,
there's a race condition where,

00:24:38.234 --> 00:24:40.000
you know, thread one won
before thread two

00:24:40.000 --> 00:24:41.634
and it caused a crash.
On every other device,

00:24:41.634 --> 00:24:44.033
it happened to be thread two
won before thread one.

00:24:44.033 --> 00:24:46.100
By not caching this variable
any longer

00:24:46.100 --> 00:24:48.300
and just passing it through
when and he got a callback,

00:24:48.300 --> 00:24:51.868
problems went away.

00:24:51.868 --> 00:24:54.033
I think this is old news
for most people here,

00:24:54.033 --> 00:24:55.467
so I won't spend
too long on it.

00:24:55.467 --> 00:24:58.033
But there's different
versions of Android.

00:24:58.033 --> 00:25:00.501
Each new version of Android
introduces new APIs.

00:25:00.501 --> 00:25:02.234
If you're going to be
backwards compatible

00:25:02.234 --> 00:25:04.934
across a bunch of different
versions of Android,

00:25:04.934 --> 00:25:07.801
you need to only call APIs
that are available

00:25:07.801 --> 00:25:09.033
in your minimum version.

00:25:09.033 --> 00:25:10.400
So you know, you go
into AndroidManifest

00:25:10.400 --> 00:25:12.133
and you say, oh,
I have min SDK S3.

00:25:12.133 --> 00:25:14.300
That means I can run on
Android 1.5 or higher.

00:25:14.300 --> 00:25:18.968
But I compiled against eight,
which is Android 2.2, I believe.

00:25:18.968 --> 00:25:22.767
So what happens
if you want to call a function

00:25:22.767 --> 00:25:25.067
that was added
in Android 2.2?

00:25:25.067 --> 00:25:27.300
Well, if you just call it,
it'll compile okay.

00:25:27.300 --> 00:25:30.501
But when you run on the G1
or that other 1.5 device,

00:25:30.501 --> 00:25:31.934
it's gonna crash.

00:25:31.934 --> 00:25:36.634
If you use Dalvik reflection--
or you could even branch

00:25:36.634 --> 00:25:38.667
on the build ID
or the version ID--

00:25:38.667 --> 00:25:42.300
just be careful not to call
methods that may not exist

00:25:42.300 --> 00:25:44.234
in your minimum supported
system version.

00:25:44.234 --> 00:25:46.100
And actually, the docs
are really useful for this

00:25:46.100 --> 00:25:48.467
because they will show you
exactly how--

00:25:48.467 --> 00:25:50.067
exactly which version

00:25:50.067 --> 00:25:53.634
every function
in the Android API was added.

00:25:53.634 --> 00:25:55.234
Another rule.

00:25:55.234 --> 00:25:57.167
You should be frugal
with your RAM use.

00:25:57.167 --> 00:25:59.767
If you are writing
to Dalvik,

00:25:59.767 --> 00:26:02.767
you have a fixed size heap
and you know what it's gonna be.

00:26:02.767 --> 00:26:04.634
On a minimum spec,
it's gonna be 16 megabytes

00:26:04.634 --> 00:26:07.334
and on newer devices,
it's much larger than that.

00:26:07.334 --> 00:26:09.501
So you can deal with
that memory stuff pretty easily.

00:26:09.501 --> 00:26:12.133
If you are allocating
from native code,

00:26:12.133 --> 00:26:14.968
which most of you said you are,
there is no fixed size heap.

00:26:14.968 --> 00:26:16.834
You can allocate as much memory
as you'd like

00:26:16.834 --> 00:26:20.868
until the device runs out
of RAM, which is great, right?

00:26:20.868 --> 00:26:22.734
Because you're not
limited to 16 megabytes.

00:26:22.734 --> 00:26:25.200
But it also means that if your
application needs 100 megabytes

00:26:25.200 --> 00:26:27.300
to run at its high watermark
and your user is on a phone

00:26:27.300 --> 00:26:29.133
that doesn't quite have
that much free,

00:26:29.133 --> 00:26:30.734
you may run into
an out-of-memory situation

00:26:30.734 --> 00:26:32.234
that you didn't expect.

00:26:32.234 --> 00:26:36.267
So the message here is be
frugal and fail gracefully.

00:26:36.267 --> 00:26:39.200
Try to fit into as little
runtime memory as possible.

00:26:39.200 --> 00:26:43.767
For reference, Replica Island
runs at 6 megs.

00:26:43.767 --> 00:26:46.000
Keep your application
as small as possible.

00:26:46.000 --> 00:26:48.934
Older phones, especially the G1,
but some other older phones

00:26:48.934 --> 00:26:50.534
have very little
internal flash.

00:26:50.534 --> 00:26:52.567
You should also absolutely
support the apps

00:26:52.567 --> 00:26:55.133
to SD configuration
in your Android manifest

00:26:55.133 --> 00:26:57.133
because that'll let people
to move the application

00:26:57.133 --> 00:26:58.501
to the SD card.

00:26:58.501 --> 00:27:00.200
You don't want to be
non-compatible with a device

00:27:00.200 --> 00:27:04.801
just because you just don't have
enough space to install it.

00:27:04.801 --> 00:27:07.501
If you are coding in C++,

00:27:07.501 --> 00:27:09.834
you may have considered
using Neon.

00:27:09.834 --> 00:27:15.901
Neon is a special architecture
instruction set that allows

00:27:15.901 --> 00:27:19.934
the optimization of certain
floating point operations.

00:27:19.934 --> 00:27:22.467
Now, Neon is only supported
on devices

00:27:22.467 --> 00:27:24.968
that have RMV7 chipsets.

00:27:24.968 --> 00:27:28.267
But the trick is
not all RMV7 chipsets

00:27:28.267 --> 00:27:29.868
support Neon.

00:27:29.868 --> 00:27:32.601
So if you assumed that by
building against RMV7

00:27:32.601 --> 00:27:34.834
you are guaranteed Neon support,
you are wrong.

00:27:34.834 --> 00:27:40.434
For example, the Zoom
does not support Neon.

00:27:40.434 --> 00:27:43.334
Now, there is a library
that comes with the NDK

00:27:43.334 --> 00:27:45.100
called CPU Features
which you can use

00:27:45.100 --> 00:27:46.834
to check at runtime,

00:27:46.834 --> 00:27:50.234
whether or not this particular
instruction set is available.

00:27:50.234 --> 00:27:51.868
But do that.

00:27:51.868 --> 00:27:53.434
Make sure you check.

00:27:53.434 --> 00:27:57.167
Otherwise, it will crash
on the device [indistinct].

00:27:57.167 --> 00:27:59.934
And, you know, I think
everybody here knows this

00:27:59.934 --> 00:28:02.767
because we pounded it into
their heads at every Google IO,

00:28:02.767 --> 00:28:05.234
but don't call on
documented code.

00:28:05.234 --> 00:28:06.734
Don't use private APIs.

00:28:06.734 --> 00:28:08.634
You can go into the Android
open source tree

00:28:08.634 --> 00:28:10.934
and you can find a bunch
of interesting-looking functions

00:28:10.934 --> 00:28:13.000
and you can find tricky ways
to call them from your code,

00:28:13.000 --> 00:28:14.334
and if you do that,

00:28:14.334 --> 00:28:17.501
you guarantee that your game
will crash at least--

00:28:17.501 --> 00:28:20.434
if not now, then in the future,
when those APIs change.

00:28:20.434 --> 00:28:21.868
APIs that are private
are private

00:28:21.868 --> 00:28:22.934
because they're
likely to change.

00:28:22.934 --> 00:28:24.200
They're not ready
for primetime.

00:28:24.200 --> 00:28:27.901
And if you rely upon them,
you will crash.

00:28:27.901 --> 00:28:30.200
So the main message here
is lots of diversity.

00:28:30.200 --> 00:28:32.400
Right? I mean,
there's lots of rules.

00:28:32.400 --> 00:28:34.400
There's lots of flexibility

00:28:34.400 --> 00:28:36.167
and this is probably
the point in the lecture

00:28:36.167 --> 00:28:38.300
where everybody in the room
is like, oh, my God.

00:28:38.300 --> 00:28:39.601
How am I gonna deal with this?

00:28:39.601 --> 00:28:41.067
This sounds horrible.

00:28:41.067 --> 00:28:42.234
Like, for example,

00:28:42.234 --> 00:28:44.667
maybe you have some weirdo
control scheme

00:28:44.667 --> 00:28:47.634
that only works
on a subset of devices.

00:28:47.634 --> 00:28:51.334
Right? Like, maybe you require
discreet multitouch

00:28:51.334 --> 00:28:53.534
which is the non-crappy
multitouch.

00:28:53.534 --> 00:28:56.033
Or more likely,
maybe you just want to use

00:28:56.033 --> 00:28:58.467
OpenGL ES2.0
because you want to write

00:28:58.467 --> 00:29:00.067
your whole graphics back end
in shaders,

00:29:00.067 --> 00:29:02.534
and there's no way that's ever
gonna work on a device

00:29:02.534 --> 00:29:03.901
that doesn't support
OpenGL ES2.0.

00:29:03.901 --> 00:29:06.367
What are you gonna do,
right?

00:29:06.367 --> 00:29:09.834
That's the segue
into our next talk,

00:29:09.834 --> 00:29:14.167
and the segue itself is that
Market has a solution for you

00:29:14.167 --> 00:29:18.934
and it's called
AndroidManifest.xml.

00:29:18.934 --> 00:29:20.701
So, what is
AndroidManifest.xml?

00:29:20.701 --> 00:29:23.434
I mean, everybody fills it out
when you build your application.

00:29:23.434 --> 00:29:24.534
You put your app name in there

00:29:24.534 --> 00:29:26.033
and you describe your activities
and stuff.

00:29:26.033 --> 00:29:28.801
And it's metadata
about your application,

00:29:28.801 --> 00:29:31.100
but what is it really?

00:29:31.100 --> 00:29:35.100
As far as Market is concerned,
it's your minimum spec.

00:29:35.100 --> 00:29:39.701
For example, say we say,
oh, I require this feature

00:29:39.701 --> 00:29:42.300
called Android.Hardware.
Touchscreen.Multitouch.

00:29:42.300 --> 00:29:43.534
And I really do require it,

00:29:43.534 --> 00:29:46.133
'cause I put the required field
to true.

00:29:46.133 --> 00:29:47.934
That means I cannot run--

00:29:47.934 --> 00:29:50.834
this application is not
compatible with devices

00:29:50.834 --> 00:29:53.133
that do not support
multitouch.

00:29:53.133 --> 00:29:54.534
And if you put this
in your manifest

00:29:54.534 --> 00:29:55.934
and you upload it
to Android Market,

00:29:55.934 --> 00:29:57.868
Android Market will not
distribute it to devices

00:29:57.868 --> 00:29:59.467
that don't meet
that requirement.

00:29:59.467 --> 00:30:01.200
So, your G1 users are not
even gonna be able

00:30:01.200 --> 00:30:03.033
to find your app
in Android Market.

00:30:03.033 --> 00:30:04.033
It's just not there.

00:30:04.033 --> 00:30:05.601
If you use the web interface,

00:30:05.601 --> 00:30:07.767
find the app and try to
install it to your G1,

00:30:07.767 --> 00:30:09.234
it'll say, oh, sorry.

00:30:09.234 --> 00:30:11.067
Your phone is not
high enough spec.

00:30:11.067 --> 00:30:13.801
It doesn't meet the requirements
set by this application.

00:30:13.801 --> 00:30:16.667
There's tons of stuff you can
require in Android manifest.

00:30:16.667 --> 00:30:18.501
This is why I call it
a minimum spec.

00:30:18.501 --> 00:30:20.200
There's all kinds of
requirements

00:30:20.200 --> 00:30:21.601
you can put in here.

00:30:21.601 --> 00:30:24.067
Here's a little taste.

00:30:24.067 --> 00:30:25.701
Say you want to
only ship to phones

00:30:25.701 --> 00:30:27.000
that have auto focusing cameras.

00:30:27.000 --> 00:30:28.501
Okay, you can do that.

00:30:28.501 --> 00:30:32.133
Or say you want to ship
to phones that support Wi-Fi.

00:30:32.133 --> 00:30:34.601
You might think that all phones
support Wi-Fi,

00:30:34.601 --> 00:30:36.868
but it's probably
an optional part of the spec.

00:30:36.868 --> 00:30:38.234
So maybe if you require it,

00:30:38.234 --> 00:30:41.334
you won't be getting
user reports from your users

00:30:41.334 --> 00:30:43.400
who are on the crazy
non-Wi-Fi supporting device

00:30:43.400 --> 00:30:46.467
that comes out in six months.

00:30:46.467 --> 00:30:49.000
Or here's a more common
requirement for game developers.

00:30:49.000 --> 00:30:50.968
Say, you do want to use one
of those proprietary

00:30:50.968 --> 00:30:52.667
texture formats
that I talked about.

00:30:52.667 --> 00:30:53.667
You can require it.

00:30:53.667 --> 00:30:55.033
You can say,
well, you know,

00:30:55.033 --> 00:30:56.701
I know I'm gonna cut out
some of my users

00:30:56.701 --> 00:30:58.701
but I want to use
PVRTC.

00:30:58.701 --> 00:31:00.300
Put this in your manifest

00:31:00.300 --> 00:31:04.000
and Market will not ship
your game to a device

00:31:04.000 --> 00:31:07.534
that can't support that version
of texture compression.

00:31:07.534 --> 00:31:09.300
We talked about
crappy multitouch.

00:31:09.300 --> 00:31:11.100
You can cut out crappy
multitouch devices.

00:31:11.100 --> 00:31:13.234
Say, I'm sorry, I have my
dual sticks and I like it,

00:31:13.234 --> 00:31:15.467
and I don't want to even want to
deal with you Nexus One users.

00:31:15.467 --> 00:31:17.968
Whatever. However many
other crappy multitouch devices

00:31:17.968 --> 00:31:19.467
might be out there.

00:31:19.467 --> 00:31:20.801
Set this stuff
to require it,

00:31:20.801 --> 00:31:24.501
and they will never see it
at Market.

00:31:24.501 --> 00:31:28.133
By the way, if you said
require to false here,

00:31:28.133 --> 00:31:29.868
it means
that you want that feature

00:31:29.868 --> 00:31:32.267
but you can deal with it
at runtime.

00:31:32.267 --> 00:31:34.834
You can say, oh, well,
I really wanted multitouch,

00:31:34.834 --> 00:31:37.434
but since you don't have it,
here's another configuration

00:31:37.434 --> 00:31:40.701
you can use,
some other way.

00:31:40.701 --> 00:31:42.467
If you set it to required,
Market will be real strict

00:31:42.467 --> 00:31:44.634
about how it filters
your application.

00:31:44.634 --> 00:31:46.033
Couple other examples.

00:31:46.033 --> 00:31:48.968
We talked about requiring
a minimum SDK version

00:31:48.968 --> 00:31:50.467
and a maximum SDK version.

00:31:50.467 --> 00:31:52.334
You could also require
combinations

00:31:52.334 --> 00:31:54.901
of different screen size
and density.

00:31:54.901 --> 00:31:57.567
That's physical size,
physical density,

00:31:57.567 --> 00:31:59.767
and this is
the most common one.

00:31:59.767 --> 00:32:03.567
If you want to require
OpenGL ES2.0,

00:32:03.567 --> 00:32:05.667
that's that one at the bottom,
you just say,

00:32:05.667 --> 00:32:06.901
well, I need an open
OpenGL ES2.0

00:32:06.901 --> 00:32:09.801
and those old devices
won't appear.

00:32:09.801 --> 00:32:12.667
So by carefully
managing your spec,

00:32:12.667 --> 00:32:14.834
you can effectively
cut out devices

00:32:14.834 --> 00:32:16.501
that you don't want to manage.

00:32:16.501 --> 00:32:18.434
You know, we talked about
a lot of assumptions

00:32:18.434 --> 00:32:20.834
and a lot of ground rules, and
a lot of them have to do with,

00:32:20.834 --> 00:32:22.501
well, there's a device
over here that's this,

00:32:22.501 --> 00:32:24.400
and there's a device
over here that's this.

00:32:24.400 --> 00:32:25.968
And if you would like to say,
you know,

00:32:25.968 --> 00:32:27.234
I don't even care
about this stuff over here,

00:32:27.234 --> 00:32:28.667
I only want to focus
on these guys--

00:32:28.667 --> 00:32:32.634
AndroidManifest and Android
Market will let you do that.

00:32:32.634 --> 00:32:34.000
If you think about this,

00:32:34.000 --> 00:32:35.501
this is actually
really powerful.

00:32:35.501 --> 00:32:37.501
Because if we look at
the low end and the high end--

00:32:37.501 --> 00:32:39.234
what I'm gonna call the G1
and the Zoom

00:32:39.234 --> 00:32:41.701
are probably the good
representations

00:32:41.701 --> 00:32:43.567
of those two parts
of the spectrum--

00:32:43.567 --> 00:32:45.501
that's a pretty big delta
like in terms of--

00:32:45.501 --> 00:32:47.067
let's just talk about
performance.

00:32:47.067 --> 00:32:48.667
That's a pretty big
performance delta.

00:32:48.667 --> 00:32:50.200
Right?

00:32:50.200 --> 00:32:52.167
But let's say we require
OpenGL ES2.0,

00:32:52.167 --> 00:32:53.434
say in our manifest.

00:32:53.434 --> 00:32:55.067
Now we have to have
OpenGL ES2.0.

00:32:55.067 --> 00:32:56.634
Now the delta is
a lot smaller.

00:32:56.634 --> 00:32:58.434
Now the minimum spec
is the Droid,

00:32:58.434 --> 00:33:00.300
because that was
the first device

00:33:00.300 --> 00:33:02.601
to ship with
OpenGL ES2.0.

00:33:02.601 --> 00:33:04.434
Doesn't even matter
if you use OpenGL.

00:33:04.434 --> 00:33:07.601
Your whole thing might be
like this 2D CPU game.

00:33:07.601 --> 00:33:09.000
Who cares?

00:33:09.000 --> 00:33:11.133
If you say in manifest,
in the manifest file,

00:33:11.133 --> 00:33:15.901
that you require OpenGL ES2.0,
it will cut out the low end.

00:33:15.901 --> 00:33:18.701
You know, the caveat
to this approach, right,

00:33:18.701 --> 00:33:20.267
is that every time
you do this,

00:33:20.267 --> 00:33:23.367
you are cutting out
some number of users, right?

00:33:23.367 --> 00:33:27.367
The size of your user base
is getting smaller.

00:33:27.367 --> 00:33:29.200
And of course, you know,

00:33:29.200 --> 00:33:30.701
in addition to writing
awesome games,

00:33:30.701 --> 00:33:32.367
we'd probably all like to
also, you know,

00:33:32.367 --> 00:33:33.834
make money
off of those games.

00:33:33.834 --> 00:33:36.734
So having more users
is always a good thing.

00:33:36.734 --> 00:33:40.000
So it's in your interest to try
to be as compatible as possible.

00:33:40.000 --> 00:33:42.267
But when there's
an area of diversity

00:33:42.267 --> 00:33:43.701
that's just too open for you,

00:33:43.701 --> 00:33:46.100
you can put your foot down
with manifest

00:33:46.100 --> 00:33:48.367
and require something
in the spec.

00:33:48.367 --> 00:33:49.901
Here's the spec
for Replica Island.

00:33:49.901 --> 00:33:51.634
I don't really require anything.

00:33:51.634 --> 00:33:52.968
I work on all screen sizes.

00:33:52.968 --> 00:33:58.000
I run on everything
Android 1.5 and higher.

00:34:00.734 --> 00:34:04.534
Now because I'm able to support
such a wide variety of devices,

00:34:04.534 --> 00:34:07.634
you can see that
in my install information,

00:34:07.634 --> 00:34:09.934
I have more Android 1.5 users,

00:34:09.934 --> 00:34:12.334
a lot more than what's normal
for this category.

00:34:12.334 --> 00:34:14.200
I have 15%
versus the standard,

00:34:14.200 --> 00:34:15.734
which is 4%.

00:34:15.734 --> 00:34:18.968
And I believe that this is
because if you are a...

00:34:18.968 --> 00:34:20.868
user has a two-year-old device

00:34:20.868 --> 00:34:23.601
and it's only got
Android 1.5 on it

00:34:23.601 --> 00:34:25.834
and you go to Android Market
looking for some games to play,

00:34:25.834 --> 00:34:27.300
it's a little bit slim pickings,
you know.

00:34:27.300 --> 00:34:29.834
Like, most developers
have moved on and said,

00:34:29.834 --> 00:34:31.400
well, I'm gonna require
Android 2.0

00:34:31.400 --> 00:34:33.534
or I'm gonna require
Android 1.6.

00:34:33.534 --> 00:34:35.901
But since I was able to support
those users,

00:34:35.901 --> 00:34:38.300
that makes my app very visible,

00:34:38.300 --> 00:34:43.200
and so as a result
I have a lot of 1.5 users.

00:34:43.200 --> 00:34:44.200
It's up to you.

00:34:44.200 --> 00:34:45.334
If you want to
support everybody

00:34:45.334 --> 00:34:47.200
or you only want to
support a subset,

00:34:47.200 --> 00:34:50.567
you can control that
with AndroidManifest.xml.

00:34:50.567 --> 00:34:53.834
Okay, now, I want to talk about
the secret fourth rule.

00:34:53.834 --> 00:34:55.300
This is specific to games.

00:34:55.300 --> 00:34:57.934
This is a subtle point
that I did not understand

00:34:57.934 --> 00:35:00.667
until after I shipped
Replica Island.

00:35:00.667 --> 00:35:03.434
It is true that these devices
are very different.

00:35:03.434 --> 00:35:05.400
It's true that there's a lot
of device diversity.

00:35:05.400 --> 00:35:07.734
It's also true
that you can solve it.

00:35:07.734 --> 00:35:09.801
There's Dalvik reflection,

00:35:09.801 --> 00:35:12.000
there's scaling your graphics,
there's, you know,

00:35:12.000 --> 00:35:16.234
using the Android APIs
to do automatic scaling for you

00:35:16.234 --> 00:35:19.267
or adding customizable controls,
things like that.

00:35:19.267 --> 00:35:20.834
Those are all
technical problems.

00:35:20.834 --> 00:35:22.234
You can solve them.

00:35:22.234 --> 00:35:23.567
You sit down,
write some more code.

00:35:23.567 --> 00:35:25.267
It'll work.

00:35:25.267 --> 00:35:27.334
Much harder problem
is that your users

00:35:27.334 --> 00:35:29.501
are also gonna be
a very diverse group.

00:35:29.501 --> 00:35:31.000
It used to be--

00:35:31.000 --> 00:35:32.834
you know, my background
before I went to Google

00:35:32.834 --> 00:35:34.267
was writing
console games.

00:35:34.267 --> 00:35:36.434
So, I wrote a lot of games
for Game Boy Advance.

00:35:36.434 --> 00:35:38.067
Game Boy Advance,
you pretty much know

00:35:38.067 --> 00:35:39.434
who your target group is.

00:35:39.434 --> 00:35:42.501
It's kids between the age of
6 and 12. Right?

00:35:42.501 --> 00:35:44.434
Or if you're gonna write
an Xbox 360 game,

00:35:44.434 --> 00:35:47.033
you can be
pretty much guaranteed

00:35:47.033 --> 00:35:49.534
that your target audience
is males between 15 and 30.

00:35:49.534 --> 00:35:50.968
All right?

00:35:50.968 --> 00:35:56.033
Just by the market segment that
the console itself controls.

00:35:56.033 --> 00:35:58.000
But on a phone, I mean,
everybody's got a phone.

00:35:58.000 --> 00:35:59.767
Right? What do you know
about your user?

00:35:59.767 --> 00:36:01.434
How much do you know
about what they want

00:36:01.434 --> 00:36:03.400
or what kind of games
they want to play?

00:36:03.400 --> 00:36:05.033
You know very little.

00:36:05.033 --> 00:36:06.133
I found out
that when I added

00:36:06.133 --> 00:36:11.033
all this customization
for controls,

00:36:11.033 --> 00:36:13.067
what surprised me about it
was that users

00:36:13.067 --> 00:36:14.667
who didn't need to
customize their controls,

00:36:14.667 --> 00:36:16.667
because I'd already
provided a solution for them,

00:36:16.667 --> 00:36:18.601
were going in
and customizing them anyway.

00:36:18.601 --> 00:36:21.000
You know, I added
like the tilt stuff in there

00:36:21.000 --> 00:36:23.067
for the basically
the Xperia users.

00:36:23.067 --> 00:36:24.767
And I kind of think
that that's a difficult

00:36:24.767 --> 00:36:26.100
control scheme to use.

00:36:26.100 --> 00:36:28.667
But I had users telling me
that they preferred tilt

00:36:28.667 --> 00:36:30.133
over the original
trackball control scheme

00:36:30.133 --> 00:36:32.734
even though they had
like an Nexus One or a G1.

00:36:32.734 --> 00:36:33.901
That surprised me.

00:36:33.901 --> 00:36:37.000
The user was different,
not just the device.

00:36:37.000 --> 00:36:39.033
You know,
in designing Replica Island,

00:36:39.033 --> 00:36:42.300
I had some idea that users
are gonna want different things.

00:36:42.300 --> 00:36:44.934
So in the game design,
I tried to provide

00:36:44.934 --> 00:36:46.934
different aspects
of interestingness,

00:36:46.934 --> 00:36:50.601
different poles by which
people could, you know,

00:36:50.601 --> 00:36:52.100
become interested
in the game.

00:36:52.100 --> 00:36:54.567
One of those things
was just a game play, right?

00:36:54.567 --> 00:36:57.467
Some users are gonna
like crushing stuff

00:36:57.467 --> 00:36:59.100
and moving through the level

00:36:59.100 --> 00:37:00.467
and trying to
figure out the puzzle

00:37:00.467 --> 00:37:01.734
and making it
to the next level.

00:37:01.734 --> 00:37:02.734
That's the whole game
for them.

00:37:02.734 --> 00:37:04.000
That's enough.
Right?

00:37:04.000 --> 00:37:05.501
So try to make that part good.

00:37:05.501 --> 00:37:07.601
Another aspect of
interestingness

00:37:07.601 --> 00:37:08.868
was a story, right?

00:37:08.868 --> 00:37:10.033
Some people might not

00:37:10.033 --> 00:37:11.767
care very much
about crushing stuff,

00:37:11.767 --> 00:37:13.467
but they want to find out
who they can trust

00:37:13.467 --> 00:37:17.300
or who's the real bad guy?
What's the secret ending?

00:37:17.300 --> 00:37:18.901
You know, art style
was another thing.

00:37:18.901 --> 00:37:23.167
I tried to go for a retro
16-bit game look

00:37:23.167 --> 00:37:25.467
even though the game
plays very differently

00:37:25.467 --> 00:37:27.033
than a retro game,
because I thought

00:37:27.033 --> 00:37:28.434
that that would draw
some users in.

00:37:28.434 --> 00:37:30.334
That's what they're gonna be
interested in.

00:37:30.334 --> 00:37:32.434
And recently,
I've actually added

00:37:32.434 --> 00:37:35.567
explicit difficulty
settings for new users.

00:37:35.567 --> 00:37:38.901
I had some dynamic difficulty
adjustment in there before,

00:37:38.901 --> 00:37:42.300
but it turns out that the user
base is so wide here

00:37:42.300 --> 00:37:43.634
that I can make
a much better game

00:37:43.634 --> 00:37:44.834
if the user
tells me upfront

00:37:44.834 --> 00:37:46.267
what kind of game
they'd like to play.

00:37:46.267 --> 00:37:48.133
Some people want to put
their pride on the line.

00:37:48.133 --> 00:37:50.133
They want a challenge
and they want to feel awesome

00:37:50.133 --> 00:37:51.734
when they've completed
that challenge.

00:37:51.734 --> 00:37:53.167
And other people are like,
you know what?

00:37:53.167 --> 00:37:54.434
I'm just gonna play this
for five minutes.

00:37:54.434 --> 00:37:55.567
I don't really want
to play the same level

00:37:55.567 --> 00:37:56.901
over and over
and over again.

00:37:56.901 --> 00:37:59.567
I just want to
sort of glide through.

00:37:59.567 --> 00:38:02.734
So by providing specific
difficulty levels,

00:38:02.734 --> 00:38:04.534
I was able to access
not just more devices,

00:38:04.534 --> 00:38:07.467
but more users.

00:38:07.467 --> 00:38:10.267
One thing I didn't have to do
but you should think about

00:38:10.267 --> 00:38:12.100
is I did not provide an option

00:38:12.100 --> 00:38:14.868
to customize
the graphics quality.

00:38:14.868 --> 00:38:16.968
If you want to customize the
graphics quality in your game

00:38:16.968 --> 00:38:19.067
and you're using OpenGL,
it should be really easy.

00:38:19.067 --> 00:38:23.300
It's one call to the
SurfaceHolder.setFixedFunction.

00:38:23.300 --> 00:38:26.200
Sorry.
setFixedSize method.

00:38:26.200 --> 00:38:29.400
What that does is
it makes your window

00:38:29.400 --> 00:38:32.334
that you're rendering to smaller
than the window of the display,

00:38:32.334 --> 00:38:35.300
and then the system
will automatically scale it up.

00:38:35.300 --> 00:38:37.734
So the effect is
you're filling fewer pixels,

00:38:37.734 --> 00:38:40.033
and actually fill is the part
that's slow on these devices.

00:38:40.033 --> 00:38:41.601
So you're filling
fewer pixels,

00:38:41.601 --> 00:38:43.100
but it still takes up
the whole screen.

00:38:43.100 --> 00:38:44.434
The graphics
look chunkier.

00:38:44.434 --> 00:38:45.534
I don't know
if you can tell,

00:38:45.534 --> 00:38:47.400
but on the left
is native resolution

00:38:47.400 --> 00:38:50.801
and on the right is 50%
reduced and scaled back up.

00:38:50.801 --> 00:38:52.868
It does look
a lot chunkier.

00:38:52.868 --> 00:38:56.067
Although at 75%
most users probably can't tell.

00:38:56.067 --> 00:38:58.167
If you need to get
some speed back

00:38:58.167 --> 00:39:00.467
or you want to give
the user an option

00:39:00.467 --> 00:39:02.133
to dial down
the graphics quality

00:39:02.133 --> 00:39:04.367
because maybe they're on a phone
that is lower quality

00:39:04.367 --> 00:39:07.133
than you anticipated,
you can give them an option

00:39:07.133 --> 00:39:09.234
to set this value,
and that would let them play

00:39:09.234 --> 00:39:14.467
even if they have
kind of a crappy phone.

00:39:14.467 --> 00:39:17.767
So the goal is
target all devices, right?

00:39:17.767 --> 00:39:19.901
That's a technical problem.
You can deal with it.

00:39:19.901 --> 00:39:21.968
I did.
I kind of got lucky,

00:39:21.968 --> 00:39:26.200
but you follow the assumptions
that we talked about today

00:39:26.200 --> 00:39:27.534
and the rules
that we talked about today,

00:39:27.534 --> 00:39:29.200
and, you know,
I think any game

00:39:29.200 --> 00:39:31.100
that's on
the Android Market today

00:39:31.100 --> 00:39:34.400
can be aggressively
compatible.

00:39:34.400 --> 00:39:39.100
Much harder is to understand
your user base.

00:39:39.100 --> 00:39:41.133
Building a game
that is compatible

00:39:41.133 --> 00:39:43.234
across
a large number of people

00:39:43.234 --> 00:39:45.033
is actually
a very difficult problem.

00:39:45.033 --> 00:39:46.667
And it's not just
about controls,

00:39:46.667 --> 00:39:48.767
and it's not just
about game content.

00:39:48.767 --> 00:39:50.734
So I urge you when building
Android games

00:39:50.734 --> 00:39:53.634
to think not just about the
technical side of compatibility

00:39:53.634 --> 00:39:56.100
but also who your users are.

00:39:56.100 --> 00:39:58.033
You know,
who is this market?

00:39:58.033 --> 00:39:59.400
And what do they
want to play?

00:39:59.400 --> 00:40:01.601
And give them options
to tune the game

00:40:01.601 --> 00:40:02.934
the way that they like.

00:40:02.934 --> 00:40:05.534
And I think if you do that,
you have a lot more--

00:40:05.534 --> 00:40:07.467
bigger chance of success.

00:40:07.467 --> 00:40:09.534
This is the end
of my remarks.

00:40:09.534 --> 00:40:10.901
I sped through it
a little bit

00:40:10.901 --> 00:40:12.334
'cause we're running
a little late,

00:40:12.334 --> 00:40:14.367
but we do have time
for some questions.

00:40:14.367 --> 00:40:16.067
If you're interested
in what I'm up to next,

00:40:16.067 --> 00:40:17.934
my company is called
Robot Invader.

00:40:17.934 --> 00:40:19.567
We're at robotinvader.com.

00:40:19.567 --> 00:40:22.100
At Twitter,
I'm at c_pruett.

00:40:22.100 --> 00:40:24.267
And we don't have
anything to show quite yet.

00:40:24.267 --> 00:40:25.267
We're only a month old.

00:40:25.267 --> 00:40:26.601
But we will have
some pretty cool stuff.

00:40:26.601 --> 00:40:27.901
So please stay tuned.

00:40:27.901 --> 00:40:29.133
If you'd like to ask questions,

00:40:29.133 --> 00:40:31.133
please come up
to one of these microphones.

00:40:31.133 --> 00:40:33.033
Thank you very much.

00:40:33.033 --> 00:40:39.133
[applause]

00:40:39.133 --> 00:40:41.267
man: You mentioned
putting restrictions

00:40:41.267 --> 00:40:44.334
in the manifest to limit
the number of devices

00:40:44.334 --> 00:40:46.767
and there was
the required true-false.

00:40:46.767 --> 00:40:48.601
It's obvious what happens
when it's true.

00:40:48.601 --> 00:40:51.868
Well, how does the Market
respond to that requirement

00:40:51.868 --> 00:40:53.934
when it's required
to be false?

00:40:53.934 --> 00:40:56.434
Are you just saying,
I would like this

00:40:56.434 --> 00:40:58.033
but I can deal with it?

00:40:58.033 --> 00:40:59.200
What's the point of just--

00:40:59.200 --> 00:41:00.834
what's the point
of even saying that?

00:41:00.834 --> 00:41:02.834
Pruett: Right.
So, the question is about

00:41:02.834 --> 00:41:04.334
what does
the true-false thing do?

00:41:04.334 --> 00:41:07.167
Now, I believe you said
that the false market

00:41:07.167 --> 00:41:09.033
will not treat it
as a strict filter

00:41:09.033 --> 00:41:11.868
so it will allow devices--
it'll basically ignore it.

00:41:11.868 --> 00:41:14.901
But the purpose of the manifest
is not just Android Market.

00:41:14.901 --> 00:41:17.234
Right? The manifest is supposed
to be all metadata

00:41:17.234 --> 00:41:18.767
about your application.

00:41:18.767 --> 00:41:21.701
And Android applications are
designed to be self-describing.

00:41:21.701 --> 00:41:23.000
So you should be able to look
at the binary,

00:41:23.000 --> 00:41:25.734
understand what kind of devices
you can install this on.

00:41:25.734 --> 00:41:29.200
If you set that requirement
to true, I don't think

00:41:29.200 --> 00:41:31.167
you'll even be able to install
like over ADB...

00:41:31.167 --> 00:41:33.033
man: Right.
Pruett: a device--or application

00:41:33.033 --> 00:41:35.067
that doesn't meet
the requirements of that phone.

00:41:35.067 --> 00:41:39.000
So I think that if you have
the field set to false,

00:41:39.000 --> 00:41:42.200
you're just giving Android more
data about your application,

00:41:42.200 --> 00:41:44.834
whether or not
it acts upon it or now,

00:41:44.834 --> 00:41:47.000
or maybe in the future,
I don't know.

00:41:47.000 --> 00:41:48.434
I don't think that Market
in particular

00:41:48.434 --> 00:41:50.133
does anything with it
if you set it to false.

00:41:50.133 --> 00:41:56.534
But it's probably a good idea
to give your...

00:41:56.534 --> 00:42:00.467
give Android or Market
or any of those systems

00:42:00.467 --> 00:42:03.567
as much information about
what you want as possible.

00:42:03.567 --> 00:42:05.534
man: Okay.
Pruett: Over here.

00:42:05.534 --> 00:42:07.634
man: So when you parse
the extension string--

00:42:07.634 --> 00:42:09.000
Pruett: Yes.
man: If you come across devices

00:42:09.000 --> 00:42:10.367
that don't support
the extensions that you need,

00:42:10.367 --> 00:42:11.734
how do you fail gracefully?

00:42:11.734 --> 00:42:13.000
Do you just tell them
you can't do it?

00:42:13.000 --> 00:42:14.167
Or do you have a backup?
Pruett: Sure.

00:42:14.167 --> 00:42:15.434
Depends on the extension.

00:42:15.434 --> 00:42:17.033
But, generally,
extensions are fast paths

00:42:17.033 --> 00:42:18.467
for stuff
that's in the spec already.

00:42:18.467 --> 00:42:22.634
So, for example, draw texture
just takes a texture

00:42:22.634 --> 00:42:25.534
and blitz it, you know,
access-oriented to the screen

00:42:25.534 --> 00:42:28.000
at the scale
that you specify.

00:42:28.000 --> 00:42:29.968
Now, if draw texture
is not available,

00:42:29.968 --> 00:42:31.033
you could fall back on a quad

00:42:31.033 --> 00:42:32.667
that's orthographically
projected.

00:42:32.667 --> 00:42:34.133
It's the same thing.

00:42:34.133 --> 00:42:35.801
man: Is that what you do, or...
Pruett: That's what I do.

00:42:35.801 --> 00:42:37.100
man: Yeah.
Pruett: Yes.

00:42:37.100 --> 00:42:39.300
Or another example
is vertex buffer objects.

00:42:39.300 --> 00:42:41.567
Fast path for regular
vertex buffers, right?

00:42:41.567 --> 00:42:43.267
Now,
there are some things

00:42:43.267 --> 00:42:45.567
like you will see
the texture compression formats

00:42:45.567 --> 00:42:47.734
that are supported
in the GL extension string.

00:42:47.734 --> 00:42:50.367
And if your textures
are all in some format that

00:42:50.367 --> 00:42:52.767
that device doesn't support,
I don't know what you can do.

00:42:52.767 --> 00:42:54.067
You can try to
ranscode them,

00:42:54.067 --> 00:42:55.534
but I think you're
pretty much up a creek.

00:42:55.534 --> 00:42:57.901
So, that's probably
where you want to start

00:42:57.901 --> 00:42:58.901
putting requirements
in the manifest.

00:42:58.901 --> 00:43:00.601
man:
Right. Thanks.

00:43:00.601 --> 00:43:03.000
man: Before I ask my question
to play off his a little bit,

00:43:03.000 --> 00:43:05.000
then that's assuming you're
not filtering in your manifest.

00:43:05.000 --> 00:43:06.467
Pruett: That's right.
man: Therefore...

00:43:06.467 --> 00:43:08.467
not filtering in the Market.
Pruett: That's right.

00:43:08.467 --> 00:43:10.200
man: And then you would want
to handle it at runtime.

00:43:10.200 --> 00:43:11.667
Pruett: That's right.
So when I--

00:43:11.667 --> 00:43:13.033
one developer
that I spoke with

00:43:13.033 --> 00:43:15.334
was interested in transcoding
between ATITC and DXT

00:43:15.334 --> 00:43:17.400
because those formats are
actually at a binary level

00:43:17.400 --> 00:43:18.701
pretty similar.

00:43:18.701 --> 00:43:20.667
So there might be like
tricky things you could do.

00:43:20.667 --> 00:43:22.734
Like, oh, I encoded
all my stuff in DXT

00:43:22.734 --> 00:43:24.133
but I'm finding out,

00:43:24.133 --> 00:43:26.434
I'm actually running
on an ATITC device.

00:43:26.434 --> 00:43:28.534
At runtime, I can transcode
this or something.

00:43:28.534 --> 00:43:31.434
But probably what most
developers are gonna do

00:43:31.434 --> 00:43:33.400
is not anything
that complicated.

00:43:33.400 --> 00:43:36.400
They're either just gonna
use a non-proprietary format

00:43:36.400 --> 00:43:37.534
like ATC1,

00:43:37.534 --> 00:43:40.334
or they're gonna require
their manifest.

00:43:40.334 --> 00:43:42.300
man: Okay.
So, my question.

00:43:42.300 --> 00:43:44.701
Say I'm really motivated
and a little bit crazy

00:43:44.701 --> 00:43:47.901
and I want to do a game
or a graphical app

00:43:47.901 --> 00:43:49.367
that's really, you know,

00:43:49.367 --> 00:43:51.334
it's taking advantage
of OpenGL ES2.0.

00:43:51.334 --> 00:43:52.968
It's targeted at, say,
tablets.

00:43:52.968 --> 00:43:54.467
It's really high end.
Pruett: Hmm-mm.

00:43:54.467 --> 00:43:57.701
man: But I also want to appeal
to the lower-end devices.

00:43:57.701 --> 00:44:01.267
Would I, I guess,
in more general terms,

00:44:01.267 --> 00:44:04.267
would I develop two separate
apps with different manifests

00:44:04.267 --> 00:44:06.601
just so that it could appear
to any given user

00:44:06.601 --> 00:44:08.767
to be the same app
but only be exposed

00:44:08.767 --> 00:44:10.868
to the devices
that are necessary?

00:44:10.868 --> 00:44:12.300
Pruett: You could.
You shouldn't.

00:44:12.300 --> 00:44:14.601
Yeah, I mean, you certainly
have the ability to do that.

00:44:14.601 --> 00:44:16.467
The problem
with that approach

00:44:16.467 --> 00:44:18.567
is that then you'll have
two apps on Market.

00:44:18.567 --> 00:44:21.067
They will have two different
sets of ratings information.

00:44:21.067 --> 00:44:22.734
They'll have to have
slightly different names.

00:44:22.734 --> 00:44:24.334
And if one of your apps
gets voted way up,

00:44:24.334 --> 00:44:27.000
it won't change the rating
of the other application.

00:44:27.000 --> 00:44:28.667
man: What's the right way
to do that?

00:44:28.667 --> 00:44:30.367
Pruett:
The right way to do that

00:44:30.367 --> 00:44:33.167
is preferably to have a single
binary that you can do both in.

00:44:33.167 --> 00:44:35.400
I mean, what would you change
between the low-end version

00:44:35.400 --> 00:44:36.901
and the high-end version?

00:44:36.901 --> 00:44:40.501
Well, you'd probably change
the resolution of the textures.

00:44:40.501 --> 00:44:41.767
You can do that
at runtime.

00:44:41.767 --> 00:44:43.334
If you were gonna switch
between, say,

00:44:43.334 --> 00:44:45.767
a fixed function renderer
and a shader renderer,

00:44:45.767 --> 00:44:47.467
that actually might be
quite a lot of work.

00:44:47.467 --> 00:44:50.801
But it's also you know, a class
you can swap out at runtime.

00:44:50.801 --> 00:44:56.934
The trick is...to understand
that you can control, you know,

00:44:56.934 --> 00:45:00.501
which devices get your
application based on the spec.

00:45:00.501 --> 00:45:04.234
But if at all possible,
your ideal scenario

00:45:04.234 --> 00:45:06.267
is a single binary
that supports

00:45:06.267 --> 00:45:08.067
as wide a range of devices
as possible.

00:45:08.067 --> 00:45:10.834
man: So then the concept of
a minimum spec in the manifest

00:45:10.834 --> 00:45:13.000
gets real tricky because
it may not so much be minimum

00:45:13.000 --> 00:45:16.000
as I can do this
with a low-end device

00:45:16.000 --> 00:45:18.334
but otherwise I can do this
with a really high-end device.

00:45:18.334 --> 00:45:19.767
How do you filter?

00:45:19.767 --> 00:45:21.934
Pruett: So in that case,
you don't need to filter, right?

00:45:21.934 --> 00:45:24.667
If you can actually span
whatever you're doing,

00:45:24.667 --> 00:45:27.133
if you can run on the low-end
device and the high-end device,

00:45:27.133 --> 00:45:28.701
you don't need to tell
the manifest anything.

00:45:28.701 --> 00:45:30.067
You're available to everybody.
Right?

00:45:30.067 --> 00:45:32.067
That's a runtime
computation.

00:45:32.067 --> 00:45:34.934
So what the manifest is for
is for areas

00:45:34.934 --> 00:45:37.767
where you couldn't make
any concessions at runtime.

00:45:37.767 --> 00:45:39.234
You can't just degrade
the graphics quality

00:45:39.234 --> 00:45:41.267
or you know,
resize the textures.

00:45:41.267 --> 00:45:43.567
Like, if you have
a shader based rendering engine

00:45:43.567 --> 00:45:46.801
and you don't care
about fixed function, you know,

00:45:46.801 --> 00:45:49.200
rendering engines,
you can require OpenGL ES2.0,

00:45:49.200 --> 00:45:51.534
and then those devices
just won't get it.

00:45:51.534 --> 00:45:53.167
Does that make sense?
man: I think so.

00:45:53.167 --> 00:45:55.100
Thank you.
Pruett: Thank you.

00:45:55.100 --> 00:45:57.100
man: A little bit more
of a gut question.

00:45:57.100 --> 00:45:58.234
Pruett:
Sure.

00:45:58.234 --> 00:46:01.000
man: How do you balance
those factors

00:46:01.000 --> 00:46:02.868
when you want to make
those changes like you did

00:46:02.868 --> 00:46:06.334
for the difficulty settings
and really you know, deciding,

00:46:06.334 --> 00:46:08.734
okay, well, this market
isn't big enough.

00:46:08.734 --> 00:46:12.434
I want to include
lower-end devices.

00:46:12.434 --> 00:46:14.334
What do you use?
Hard data?

00:46:14.334 --> 00:46:15.567
You know,
do you get feedback?

00:46:15.567 --> 00:46:16.868
Pruett:
Yeah.

00:46:16.868 --> 00:46:18.667
man: You know, are you looking
at the competition?

00:46:18.667 --> 00:46:19.934
You know,
those are the tough choices

00:46:19.934 --> 00:46:21.300
where you decide, okay,

00:46:21.300 --> 00:46:23.300
now I'm gonna spend
two extra weeks working on this.

00:46:23.300 --> 00:46:27.334
Pruett:
That's a good question.

00:46:27.334 --> 00:46:29.767
In my case, the game was written
against the low end.

00:46:29.767 --> 00:46:31.167
So all I had to do
was scale upwards,

00:46:31.167 --> 00:46:32.267
and that wasn't very hard.

00:46:32.267 --> 00:46:34.167
In fact, it pretty much
worked out

00:46:34.167 --> 00:46:35.901
without me doing anything.

00:46:35.901 --> 00:46:38.767
If you have shipped something,
and now you go back and decide,

00:46:38.767 --> 00:46:40.868
well, you know,
I shipped something

00:46:40.868 --> 00:46:43.634
and I required OpenGL ES2.0,
but I don't really need that

00:46:43.634 --> 00:46:45.167
and boy, there's
a lot of users out there

00:46:45.167 --> 00:46:47.100
who have older phones
I'd like to support,

00:46:47.100 --> 00:46:49.200
That's a little bit trickier.

00:46:49.200 --> 00:46:53.267
Google does publish information
at developer.android.com.

00:46:53.267 --> 00:46:55.868
about the distribution
of screen sizes

00:46:55.868 --> 00:46:59.634
and also of Android
installed versions.

00:46:59.634 --> 00:47:02.133
So you can get a sense
from that data, you know,

00:47:02.133 --> 00:47:03.934
what the whole landscape
looks like.

00:47:03.934 --> 00:47:05.868
You can also use...
there's a bunch of metrics

00:47:05.868 --> 00:47:07.634
that just got added
a couple of months ago

00:47:07.634 --> 00:47:10.467
to Android Market to see
who your users really are.

00:47:10.467 --> 00:47:13.167
So if you got complaints
that like, oh,

00:47:13.167 --> 00:47:15.000
it crashes
on wide VGA displays

00:47:15.000 --> 00:47:17.000
and you went and you looked
and saw that 30% of users

00:47:17.000 --> 00:47:18.501
have wide VGA displays,

00:47:18.501 --> 00:47:21.767
that's probably an important
bug that you want to fix.

00:47:21.767 --> 00:47:24.133
Above and beyond that,
I highly recommend

00:47:24.133 --> 00:47:26.968
that you do
your own analytics.

00:47:26.968 --> 00:47:28.567
You know,
actually Android can--

00:47:28.567 --> 00:47:31.000
there's an Android version
of Google Analytics

00:47:31.000 --> 00:47:32.267
which you can plug in.

00:47:32.267 --> 00:47:33.834
It's about
three lines of code.

00:47:33.834 --> 00:47:35.033
Super simple.

00:47:35.033 --> 00:47:36.701
You can send whatever data
you like back

00:47:36.701 --> 00:47:38.634
and it'll aggregate you
on a webpage

00:47:38.634 --> 00:47:40.434
and give you graphs
and all kinds of information.

00:47:40.434 --> 00:47:43.400
And it'll tell you
in excruciating detail,

00:47:43.400 --> 00:47:44.968
depending on what values
you send back,

00:47:44.968 --> 00:47:47.968
who your users are and
what they're doing, you know.

00:47:47.968 --> 00:47:50.968
I worked with a developer
who tracks how long it takes

00:47:50.968 --> 00:47:52.901
for users to complete
each level.

00:47:52.901 --> 00:47:55.033
And they found out
that everybody completes

00:47:55.033 --> 00:47:56.501
the first level,

00:47:56.501 --> 00:47:58.501
and 80% of users
complete the second level

00:47:58.501 --> 00:48:00.601
and 10% of users
complete the third level.

00:48:00.601 --> 00:48:03.400
Okay. There's a problem
with the third level, right?

00:48:03.400 --> 00:48:08.601
Doing your own analytic tracking
is super useful anyway.

00:48:08.601 --> 00:48:13.167
That said, if you are talking
about a group of users

00:48:13.167 --> 00:48:15.300
that you're not
shipping to now

00:48:15.300 --> 00:48:17.801
and you don't know
how large they are,

00:48:17.801 --> 00:48:22.000
it's pretty hard to tell,
because absent data

00:48:22.000 --> 00:48:27.067
which only aggressively
compatible applications have,

00:48:27.067 --> 00:48:30.567
you kind of have to either take
a chance and ship something

00:48:30.567 --> 00:48:32.300
and try to make it
as compatible as possible

00:48:32.300 --> 00:48:34.267
and ship it
and see what happens.

00:48:34.267 --> 00:48:36.367
or try to rely
on third party data.

00:48:36.367 --> 00:48:38.234
You know,
in addition to Google,

00:48:38.234 --> 00:48:39.901
there's a flurry
and there's, you know, AdMob

00:48:39.901 --> 00:48:41.467
and other people
who will publish data as well

00:48:41.467 --> 00:48:43.200
help you
make those decisions.

00:48:43.200 --> 00:48:46.300
My suggestion would be to,
you know,

00:48:46.300 --> 00:48:48.701
choose a minimum spec
as low down as possible,

00:48:48.701 --> 00:48:51.367
you know, try to make
your minimum spec

00:48:51.367 --> 00:48:52.667
as old a phone
as you possibly can

00:48:52.667 --> 00:48:55.467
and then work from there.

00:48:57.567 --> 00:48:59.067
man: Hey, Chris.
Pruett: What's going on?

00:48:59.067 --> 00:49:00.400
man:
Everything's been pretty good

00:49:00.400 --> 00:49:02.467
for us native developers
for ARM so far,

00:49:02.467 --> 00:49:05.000
but Intel announced
maybe a month ago

00:49:05.000 --> 00:49:07.033
that they're gonna start
doing X86-Android.

00:49:07.033 --> 00:49:08.467
Pruett:
Sure.

00:49:08.467 --> 00:49:10.601
man: So what do you recommend
we do for compatibility

00:49:10.601 --> 00:49:12.734
for you know, ARM?

00:49:12.734 --> 00:49:15.234
Because right now, as it stands,
my native games are

00:49:15.234 --> 00:49:16.734
I'm gonna have to do
something quickly.

00:49:16.734 --> 00:49:18.000
Pruett:
Sure. Sure.

00:49:18.000 --> 00:49:20.033
Well, you know, the NDK

00:49:20.033 --> 00:49:23.334
will have to support ARM.
or I'm sorry--

00:49:23.334 --> 00:49:25.334
other architectures like X86--

00:49:25.334 --> 00:49:27.000
before you can
really do anything.

00:49:27.000 --> 00:49:28.234
If you look at the NDK,

00:49:28.234 --> 00:49:30.467
there's actually already
some preliminary support

00:49:30.467 --> 00:49:32.868
for X86 chain in there.

00:49:32.868 --> 00:49:35.033
And what's gonna happen
when that support shows up

00:49:35.033 --> 00:49:37.100
or support for any other
architecture, say, you know,

00:49:37.100 --> 00:49:40.767
like a power PC device comes out
tomorrow or something, right?

00:49:40.767 --> 00:49:43.934
The way it's gonna work
is your...

00:49:43.934 --> 00:49:45.267
if you look inside
your application

00:49:45.267 --> 00:49:46.601
that you built with
the NDK,

00:49:46.601 --> 00:49:49.167
you end up with a folder
called libraries

00:49:49.167 --> 00:49:52.267
and in that folder,
you have the output

00:49:52.267 --> 00:49:53.801
of your compilation,
your libraries.

00:49:53.801 --> 00:49:55.968
And actually, you can have
multiples versions

00:49:55.968 --> 00:49:57.100
for different architectures.

00:49:57.100 --> 00:49:59.000
So, right now,
you can choose to compile

00:49:59.000 --> 00:50:01.133
against both ARM 5
and ARM 7.

00:50:01.133 --> 00:50:03.467
And it will automatically
load the correct one.

00:50:03.467 --> 00:50:05.033
In the future,
what I would expect is

00:50:05.033 --> 00:50:06.901
that you hit the same
indicate build command

00:50:06.901 --> 00:50:09.434
and if you set
your make file up correctly,

00:50:09.434 --> 00:50:13.133
you will get a library
for X86

00:50:13.133 --> 00:50:15.133
as well as for ARM.

00:50:15.133 --> 00:50:18.567
Now, that makes a lot of
assumptions, right?

00:50:18.567 --> 00:50:20.367
It assumes that your code
is first of all

00:50:20.367 --> 00:50:23.100
just gonna compile against
an X86 code base

00:50:23.100 --> 00:50:24.534
and that your, you know,

00:50:24.534 --> 00:50:26.167
data is a little [indistinct]
or whatever.

00:50:26.167 --> 00:50:28.734
But I think that functionally
the way it'll work

00:50:28.734 --> 00:50:30.467
is that your application--

00:50:30.467 --> 00:50:32.033
it's already a sort of
a fat binary, right?

00:50:32.033 --> 00:50:35.067
It's already able to
support multiple architectures,

00:50:35.067 --> 00:50:37.567
and they will just add
architectures onto that.

00:50:37.567 --> 00:50:38.767
man:
But do you think the Market--

00:50:38.767 --> 00:50:39.767
that makes perfect sense.

00:50:39.767 --> 00:50:40.968
But do you think
the Market is gonna have

00:50:40.968 --> 00:50:42.467
an opt in
or an opt out?

00:50:42.467 --> 00:50:44.734
Because the one thing I don't
want to have happen is,

00:50:44.734 --> 00:50:46.868
you know, all the new
X86 devices roll out,

00:50:46.868 --> 00:50:49.033
and just we're crashing
on them.

00:50:49.033 --> 00:50:51.000
Pruett: Right.
That's actually already there.

00:50:51.000 --> 00:50:54.100
If you...one thing I didn't
mention in this talk

00:50:54.100 --> 00:50:56.200
is that Market will
look at your manifest

00:50:56.200 --> 00:50:59.133
to figure out its filters,
but it also draws filters

00:50:59.133 --> 00:51:01.667
from intrinsic information
about your application.

00:51:01.667 --> 00:51:04.767
So for example, if you target
ARM v7 right now,

00:51:04.767 --> 00:51:06.868
you will not appear
on ARM v5 devices

00:51:06.868 --> 00:51:09.901
'cause you said I can't support
ARM v5 by nature

00:51:09.901 --> 00:51:11.133
of you compiling only against
ARM v7.

00:51:11.133 --> 00:51:12.934
So, if you have
a native application

00:51:12.934 --> 00:51:15.667
and some other architecture
shifts, by default,

00:51:15.667 --> 00:51:17.067
you're not gonna show up
on that device

00:51:17.067 --> 00:51:18.834
until you explicitly
go back and recompile

00:51:18.834 --> 00:51:21.300
and then ship an update.

00:51:21.300 --> 00:51:22.701
Did that answer
your question?

00:51:22.701 --> 00:51:24.133
man:
Oh, yeah.

00:51:24.133 --> 00:51:26.200
Pruett: Okay. Are there
any other questions?

00:51:26.200 --> 00:51:27.801
If not, thank you very much
for coming.

00:51:27.801 --> 00:51:30.901
Appreciate it.

