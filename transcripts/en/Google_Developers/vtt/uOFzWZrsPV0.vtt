WEBVTT
Kind: captions
Language: en

00:00:08.067 --> 00:00:09.067
Hannon: Welcome.

00:00:09.067 --> 00:00:10.567
Thank you for coming
to our session,

00:00:10.567 --> 00:00:12.467
Google Wave: Under the Hood.

00:00:12.467 --> 00:00:14.767
We hope you enjoyed
the demo this morning

00:00:14.767 --> 00:00:16.567
And we're really excited
to tell you

00:00:16.567 --> 00:00:18.868
about the technology
that makes this all possible.

00:00:18.868 --> 00:00:22.267
We have four amazing engineers
coming up here to talk to you

00:00:22.267 --> 00:00:25.033
starting with David Wang,
then Alex Mah,

00:00:25.033 --> 00:00:29.100
then Dan Danilatos,
then Casey Whitelaw.

00:00:29.100 --> 00:00:31.801
They're going to show you
those algorithms and technology

00:00:31.801 --> 00:00:34.501
that make the real time
collaboration possible.

00:00:34.501 --> 00:00:36.300
They're going to talk
about the extensibility

00:00:36.300 --> 00:00:38.534
of our editor,
and--and how we built it,

00:00:38.534 --> 00:00:40.234
and what's special about it.

00:00:40.234 --> 00:00:42.968
And finally, you saw
our spell checker this morning.

00:00:42.968 --> 00:00:44.667
And, um, Casey will come
and talk about,

00:00:44.667 --> 00:00:46.267
uh, the technology

00:00:46.267 --> 00:00:47.934
and--and what makes that
possible.

00:00:47.934 --> 00:00:50.133
And we just really, really
appreciate you being here

00:00:50.133 --> 00:00:51.634
and for all your interest
and excitement

00:00:51.634 --> 00:00:53.133
about Google Wave.

00:00:53.133 --> 00:00:54.934
I just want to remind you
before I turn it over to them

00:00:54.934 --> 00:00:57.367
that you can give feedback
at haveasecond--

00:00:57.367 --> 00:01:01.667
haveasec--sorry--
haveasec.com/io--

00:01:01.667 --> 00:01:04.200
feedback about this sessions,
any of the other Wave sessions,

00:01:04.200 --> 00:01:06.200
and we really look forward
to hearing from you.

00:01:06.200 --> 00:01:08.300
So here's David.

00:01:11.467 --> 00:01:13.801
Wang: Thank you,
Stephanie.

00:01:16.100 --> 00:01:17.767
All right.

00:01:17.767 --> 00:01:20.534
So by now
you're probably thinking

00:01:20.534 --> 00:01:24.200
what are Waves in terms
of a technology perspective?

00:01:24.200 --> 00:01:28.267
Waves are essentially
hosted XML documents.

00:01:28.267 --> 00:01:31.501
Um, they can be used
to represent rich text content

00:01:31.501 --> 00:01:34.033
and system data as well.

00:01:34.033 --> 00:01:36.767
Waves also support
live collaboration,

00:01:36.767 --> 00:01:38.868
which you've seen
in Lars' demos.

00:01:38.868 --> 00:01:42.801
And that means being able
to look at the same Wave

00:01:42.801 --> 00:01:44.367
on multiple clients.

00:01:44.367 --> 00:01:46.767
And in one client,
being able to type.

00:01:46.767 --> 00:01:48.000
And on the other clients,

00:01:48.000 --> 00:01:50.067
being able to see those typing
coming out

00:01:50.067 --> 00:01:53.667
character by character
and in real time as well.

00:01:53.667 --> 00:01:57.200
Wave is also a robust
and extendable platform

00:01:57.200 --> 00:01:59.334
which allows you to build
extensions on top.

00:01:59.334 --> 00:02:00.701
And I hope that you visited

00:02:00.701 --> 00:02:05.834
the, uh, Extensions talk
previously.

00:02:05.834 --> 00:02:09.133
Okay. So in this talk,
we'll first talk

00:02:09.133 --> 00:02:10.767
about concurrency control,

00:02:10.767 --> 00:02:14.234
which makes the live,
collaborative editing possible.

00:02:14.234 --> 00:02:16.567
And then we'll talk
about the editor,

00:02:16.567 --> 00:02:20.467
which actually allows you
to input and display

00:02:20.467 --> 00:02:22.000
the live characters.

00:02:22.000 --> 00:02:24.200
And at the very end
of the talk,

00:02:24.200 --> 00:02:27.467
uh, we'll tell you
about our cool spelling agent,

00:02:27.467 --> 00:02:30.667
um, which is enabled
by this web technology.

00:02:35.767 --> 00:02:36.968
All right,
so let me start off

00:02:36.968 --> 00:02:40.534
by talking
about concurrency control.

00:02:40.534 --> 00:02:44.334
So some of you guys
who's, um, familiar

00:02:44.334 --> 00:02:45.801
with concurrent editors,

00:02:45.801 --> 00:02:47.734
the real--you'll realize
there's actually a number

00:02:47.734 --> 00:02:51.367
of concurrent editors
on a--um, out there already.

00:02:51.367 --> 00:02:55.100
There's, uh, EtherPad
and there's Subetha Edit.

00:02:55.100 --> 00:02:58.000
They support live,
concurrent editing,

00:02:58.000 --> 00:03:01.000
but they don't support
rich text.

00:03:01.000 --> 00:03:03.033
There are other
rich text editors

00:03:03.033 --> 00:03:04.834
like Google Documents.

00:03:04.834 --> 00:03:09.267
But it doesn't really support
live and concurrent editing.

00:03:09.267 --> 00:03:12.000
For Google Wave,
we wanted both.

00:03:12.000 --> 00:03:13.234
And so we looked
to this technology

00:03:13.234 --> 00:03:16.033
called Operational
Transformation.

00:03:16.033 --> 00:03:19.133
And our starting point
was the paper called

00:03:19.133 --> 00:03:21.634
"High-Latency,
Low-Bandwith Windowing

00:03:21.634 --> 00:03:24.067
in the Jupiter
Collaboration System."

00:03:24.067 --> 00:03:26.534
Two of these two--
um, two of the four authors,

00:03:26.534 --> 00:03:28.901
uh, Mike--uh, Michael Dixon
and John Lamping,

00:03:28.901 --> 00:03:30.400
actually worked for Google

00:03:30.400 --> 00:03:33.467
and they've been very helpful
to us in the early establishment

00:03:33.467 --> 00:03:36.667
of our concurrency control.

00:03:36.667 --> 00:03:39.434
So how does Operational
Transformation work?

00:03:39.434 --> 00:03:43.267
So let me explain it
through a very simple example.

00:03:43.267 --> 00:03:46.634
Imagine there is
a client and server

00:03:46.634 --> 00:03:51.901
who wants to concurrently modify
a single piece of text ABCDE.

00:03:51.901 --> 00:03:55.968
Now imagine the client
wants to delete character four.

00:03:55.968 --> 00:03:59.234
Uh, in this case,
um, you want to delete D.

00:03:59.234 --> 00:04:00.868
So the client deletes
the character

00:04:00.868 --> 00:04:03.400
and sends the operation
on the wire.

00:04:03.400 --> 00:04:06.534
And the client
is now at a state ABCE.

00:04:06.534 --> 00:04:08.334
Now the client sends
an operational wire

00:04:08.334 --> 00:04:10.167
because it's much cheaper
than sending the entire document

00:04:10.167 --> 00:04:11.367
on the wire.

00:04:11.367 --> 00:04:12.801
Um, the server,
on the other hand,

00:04:12.801 --> 00:04:14.901
wants to actually delete
character two.

00:04:14.901 --> 00:04:16.534
So it goes ahead
and deletes it.

00:04:16.534 --> 00:04:20.601
Ends up in a state A, C,
uh, D and E.

00:04:20.601 --> 00:04:24.501
And now those two operations
cross on the wire.

00:04:24.501 --> 00:04:27.367
If the server goes
and naively executes

00:04:27.367 --> 00:04:29.834
the client operation
"delete character four,"

00:04:29.834 --> 00:04:33.634
the server ends up
in a state A, C and D.

00:04:33.634 --> 00:04:36.968
It didn't actually perform
the correct operation

00:04:36.968 --> 00:04:38.501
at the end of the day
because it deleted

00:04:38.501 --> 00:04:39.534
the wrong character.

00:04:39.534 --> 00:04:40.968
Why did that happen?

00:04:40.968 --> 00:04:44.701
That was because the server
previously executed an operation

00:04:44.701 --> 00:04:46.100
before
"delete character four."

00:04:46.100 --> 00:04:47.501
So how do we solve this?

00:04:47.501 --> 00:04:49.467
This is where Operational
Transformation comes in.

00:04:49.467 --> 00:04:51.133
In Operational Transformation,

00:04:51.133 --> 00:04:54.400
there is a process
called, uh, transform

00:04:54.400 --> 00:04:59.334
where you look at your,
um, received operation

00:04:59.334 --> 00:05:02.801
and then you transform it,
uh, against operations

00:05:02.801 --> 00:05:04.767
that you have already
applied.

00:05:04.767 --> 00:05:07.367
So in this case,
the "delete 4"

00:05:07.367 --> 00:05:09.701
is transformed
against "delete 2"

00:05:09.701 --> 00:05:12.234
to recei--to become
a new operation

00:05:12.234 --> 00:05:14.167
called "delete 3."

00:05:14.167 --> 00:05:16.200
And now the server applies
this new operation

00:05:16.200 --> 00:05:17.501
and it ends up
in a correct state

00:05:17.501 --> 00:05:19.400
of A, C and E.

00:05:19.400 --> 00:05:22.367
Now the client does the same
transformation process.

00:05:22.367 --> 00:05:24.467
And it just happens
that the transformation

00:05:24.467 --> 00:05:27.133
of "delete 2" against "delete 4"
for the client

00:05:27.133 --> 00:05:29.567
is still the same operation,
"delete 2."

00:05:29.567 --> 00:05:32.534
And magically,
both the client and the server

00:05:32.534 --> 00:05:35.334
arrives at the same state,
ACE.

00:05:35.334 --> 00:05:38.100
Now hopefully you realize
that it's very important

00:05:38.100 --> 00:05:40.167
that both the client
and the server

00:05:40.167 --> 00:05:42.167
executes the exact same
algorithm

00:05:42.167 --> 00:05:43.701
to make this happen.

00:05:46.267 --> 00:05:47.934
So here's
a more formal statement

00:05:47.934 --> 00:05:49.934
about Operational
Transformation.

00:05:49.934 --> 00:05:53.467
And it says that any changes
to the shared object

00:05:53.467 --> 00:05:55.334
are described as operations.

00:05:55.334 --> 00:05:56.367
So, for example,

00:05:56.367 --> 00:05:58.901
insert character "a"
at position x.

00:05:58.901 --> 00:06:01.868
And there must be a function
called transform()

00:06:01.868 --> 00:06:04.200
with the following behavior

00:06:04.200 --> 00:06:07.701
where if you're taking
a server operation, S,

00:06:07.701 --> 00:06:10.067
and a client operation, C,

00:06:10.067 --> 00:06:12.534
you must be able to produce
a pair of operations,

00:06:12.534 --> 00:06:14.133
S' and C'

00:06:14.133 --> 00:06:15.934
with the following
characteristic

00:06:15.934 --> 00:06:19.501
that if you apply
the server operation first,

00:06:19.501 --> 00:06:21.167
then the client operation

00:06:21.167 --> 00:06:23.000
and the transformed
client operation,

00:06:23.000 --> 00:06:24.534
you end up
in the same state

00:06:24.534 --> 00:06:26.801
as if you apply
the client operation,

00:06:26.801 --> 00:06:29.400
then the transformed
server operation.

00:06:29.400 --> 00:06:32.067
Now this can be represented
in a two-dimensional diagram,

00:06:32.067 --> 00:06:33.634
um, to the right

00:06:33.634 --> 00:06:35.434
where they both start off
in the same state.

00:06:35.434 --> 00:06:37.434
When--as the client
executes an operation,

00:06:37.434 --> 00:06:39.567
it moves to a diff--
a-a state to the left.

00:06:39.567 --> 00:06:41.801
And the server executes
it's own operation.

00:06:41.801 --> 00:06:44.100
It moves the state,
uh, to the right.

00:06:44.100 --> 00:06:45.868
And later on,
they converge again

00:06:45.868 --> 00:06:48.467
when they apply
the transform operation.

00:06:54.067 --> 00:06:57.868
Okay. So this a,
um, state space diagram

00:06:57.868 --> 00:07:00.934
representation
of the previous example

00:07:00.934 --> 00:07:02.267
where in this--
in this diagram,

00:07:02.267 --> 00:07:04.734
you can see
that any left transversal

00:07:04.734 --> 00:07:06.334
is caused
by client operations

00:07:06.334 --> 00:07:07.667
and any right traversal,

00:07:07.667 --> 00:07:10.267
um, is caused
by server operations.

00:07:10.267 --> 00:07:13.133
And in--in this example
that you've seen previously,

00:07:13.133 --> 00:07:14.868
the client goes
on the solid line

00:07:14.868 --> 00:07:17.234
where it goes,
um, ABCDE,

00:07:17.234 --> 00:07:20.000
then it goes into ABC--
uh, ABCE state,

00:07:20.000 --> 00:07:21.734
and then finally goes
into the ACE state.

00:07:21.734 --> 00:07:25.767
And the server follows
the, uh, state on the right.

00:07:25.767 --> 00:07:27.634
Now this
is a very simple example.

00:07:27.634 --> 00:07:29.367
But in a real
running system,

00:07:29.367 --> 00:07:32.634
the, uh, state algorithm
looks a lot more complex.

00:07:32.634 --> 00:07:34.868
But the important thing
to point out here

00:07:34.868 --> 00:07:37.701
is you can see
that the client and the server

00:07:37.701 --> 00:07:39.701
can diverge
more than one operation.

00:07:39.701 --> 00:07:42.667
In fact, they can diverge
arbitrary number of operations.

00:07:42.667 --> 00:07:44.100
And this is
an excellent property

00:07:44.100 --> 00:07:47.667
of Operational Transformation,
which makes the client resilient

00:07:47.667 --> 00:07:49.734
to, uh, latency
to the server.

00:07:49.734 --> 00:07:52.968
In fact, an offline client
essentially is a client

00:07:52.968 --> 00:07:55.567
that pretends to have very long
latency to the server.

00:07:55.567 --> 00:07:57.300
And when it finally goes back
onto the server,

00:07:57.300 --> 00:07:59.701
it uploads all operations
and voila,

00:07:59.701 --> 00:08:04.067
you have a merged document.

00:08:04.067 --> 00:08:07.567
Now we have actually made,
uh, a number of changes

00:08:07.567 --> 00:08:09.334
to the standard
Operation Transformation

00:08:09.334 --> 00:08:12.133
that you find in the literature
out there.

00:08:12.133 --> 00:08:14.834
The number one change we made
to Operational Transformation

00:08:14.834 --> 00:08:18.534
is that the client must wait
for acknowledgment

00:08:18.534 --> 00:08:21.567
from the server
before it sends more operations

00:08:21.567 --> 00:08:23.334
to the server.

00:08:23.334 --> 00:08:24.934
Uh, why do we need
to do that?

00:08:24.934 --> 00:08:26.167
The reason
we want to do that

00:08:26.167 --> 00:08:28.000
is because
in Operational Transformation,

00:08:28.000 --> 00:08:30.000
a client and the server
works in pairs

00:08:30.000 --> 00:08:32.934
because their state space
is unique to the pair.

00:08:32.934 --> 00:08:35.534
That means for every connected
client to the server,

00:08:35.534 --> 00:08:37.334
you need to keep a state space
for the client.

00:08:37.334 --> 00:08:39.434
Now if an end client
is collected to the server

00:08:39.434 --> 00:08:40.868
I have to keep
end state spaces.

00:08:40.868 --> 00:08:42.501
That's pretty expensive
to keep in the server's memory

00:08:42.501 --> 00:08:43.968
all the time.

00:08:43.968 --> 00:08:47.601
So by making the client wait
for the server to acknowledge,

00:08:47.601 --> 00:08:49.434
the server
no longer have to keep

00:08:49.434 --> 00:08:51.000
those state spaces around

00:08:51.000 --> 00:08:54.000
because the client
can always infer

00:08:54.000 --> 00:08:55.567
where the server is.

00:08:55.567 --> 00:08:57.767
And that means
the client infers

00:08:57.767 --> 00:09:00.100
the dotted line, okay?

00:09:00.100 --> 00:09:01.501
And by doing this,

00:09:01.501 --> 00:09:03.567
the server only has
to transform

00:09:03.567 --> 00:09:04.868
the received operation

00:09:04.868 --> 00:09:08.067
against it's own
operation history.

00:09:08.067 --> 00:09:10.901
It's a very straightforward,
simple server implementation.

00:09:13.000 --> 00:09:16.200
Another improvement we made
to Operational Transformation,

00:09:16.200 --> 00:09:19.000
um, is that we've added
support for recovery.

00:09:19.000 --> 00:09:21.367
And that means
a server can crash,

00:09:21.367 --> 00:09:22.634
a client can disconnect.

00:09:22.634 --> 00:09:25.334
But in fact, any form
of communication failure,

00:09:25.334 --> 00:09:27.033
uh, we can recover
from that.

00:09:27.033 --> 00:09:30.067
And this is probably,
um, one of the starting points

00:09:30.067 --> 00:09:31.901
how we can do
offline client.

00:09:31.901 --> 00:09:34.167
Essentially, when on offline
client goes back online,

00:09:34.167 --> 00:09:35.667
its as though
it has disconnected

00:09:35.667 --> 00:09:37.000
or a server's crashed,

00:09:37.000 --> 00:09:39.367
and just recovers gracefully
from that.

00:09:39.367 --> 00:09:42.334
Okay, now let me introduce
Alex Mah,

00:09:42.334 --> 00:09:44.501
who will actually talk
about the operations

00:09:44.501 --> 00:09:46.701
we've actually used
in Google Wave,

00:09:46.701 --> 00:09:48.534
uh, in particular,
how we've w--

00:09:48.534 --> 00:09:53.434
we made them really efficient
to working a large scale system.

00:09:53.434 --> 00:09:57.300
[applause]

00:09:57.300 --> 00:10:01.367
Mah: Okay. Uh...

00:10:01.367 --> 00:10:05.067
Sorry. Sorry.

00:10:05.067 --> 00:10:06.734
Um...

00:10:06.734 --> 00:10:09.334
can you control this?

00:10:09.334 --> 00:10:12.801
Okay, um...

00:10:12.801 --> 00:10:16.033
Sorry.

00:10:16.033 --> 00:10:19.300
Uh, w--uh, we've introduced
several, um, interesting,

00:10:19.300 --> 00:10:21.501
uh, capabilities
to our, uh, Wave operations

00:10:21.501 --> 00:10:24.000
to make them more powerful
and more efficient.

00:10:24.000 --> 00:10:27.534
Um, one of the major,
um, improvements we've made--

00:10:27.534 --> 00:10:29.767
one of the major capabilities
we've added in

00:10:29.767 --> 00:10:34.634
is the ability for, um, a--any--
any two consecutive operations

00:10:34.634 --> 00:10:36.467
to, uh, compose together

00:10:36.467 --> 00:10:38.400
to form another single
operation.

00:10:38.400 --> 00:10:39.834
Okay? What that--
what that means

00:10:39.834 --> 00:10:42.834
is if you have an operation A
followed by an operation B,

00:10:42.834 --> 00:10:45.467
um, then their composition
B dot A,

00:10:45.467 --> 00:10:49.968
uh, can be expressed
as a single operation.

00:10:49.968 --> 00:10:55.234
Um, okay, uh, um,
this--this gives us a--

00:10:55.234 --> 00:10:56.701
there's a lot
of really interesting things

00:10:56.701 --> 00:10:58.267
we can do
with this capability.

00:10:58.267 --> 00:11:02.501
Um, one of them, uh, relates
to how you can use these,

00:11:02.501 --> 00:11:05.067
uh, this capability
to speed up transformations

00:11:05.067 --> 00:11:06.400
quite a lot.

00:11:06.400 --> 00:11:11.934
Um, in a traditional,
uh, uh, operational transform,

00:11:11.934 --> 00:11:15.000
uh, um, frameworks,

00:11:15.000 --> 00:11:18.567
uh, when the client and server,
uh, get too far off sync,

00:11:18.567 --> 00:11:23.367
then, uh, resolving,
uh, the, uh, um, their states

00:11:23.367 --> 00:11:26.767
through concurrency control,
uh, can become quite, uh,

00:11:26.767 --> 00:11:28.367
uh, ex--expensive.

00:11:28.367 --> 00:11:32.534
So for example, if you have,
um, M client operations

00:11:32.534 --> 00:11:34.367
and N server operations--

00:11:34.367 --> 00:11:35.934
Uh, if you have M client
operations

00:11:35.934 --> 00:11:38.033
which the server hasn't yet
had, uh, seen

00:11:38.033 --> 00:11:40.801
and--and server operations
which the--which the client

00:11:40.801 --> 00:11:42.234
hasn't yet seen,

00:11:42.234 --> 00:11:45.267
uh, then in order to resolve,
uh, the concurrency control,

00:11:45.267 --> 00:11:50.834
uh, um, uh, you need
to do NM transformations.

00:11:50.834 --> 00:11:52.300
Okay?
So that's quite a lot.

00:11:52.300 --> 00:11:54.601
For example, if you--if there's
a thousand server operations

00:11:54.601 --> 00:11:56.300
and a thousand
client operations,

00:11:56.300 --> 00:11:59.267
which, uh, need to transform
against each other,

00:11:59.267 --> 00:12:01.534
uh, that's already
a million, uh, transformations.

00:12:01.534 --> 00:12:03.534
So it's quite expensive.

00:12:03.534 --> 00:12:07.200
Uh, but with, uh, ab--
uh, ability

00:12:07.200 --> 00:12:10.901
to compose operations together,
uh, efficiently,

00:12:10.901 --> 00:12:12.167
what you can actually do

00:12:12.167 --> 00:12:13.534
is you can,
uh, compose together

00:12:13.534 --> 00:12:16.601
all the client operations,
um, beforehand

00:12:16.601 --> 00:12:19.501
and compose to all the ser--
uh, server operations beforehand

00:12:19.501 --> 00:12:21.734
and do a single
transformation.

00:12:21.734 --> 00:12:24.334
Um, of course, this is only
an, uh, efficiency improvement

00:12:24.334 --> 00:12:28.033
if we can, uh, both compose,
uh, operations efficiently

00:12:28.033 --> 00:12:31.834
and also transform the compose
operations efficiently.

00:12:34.100 --> 00:12:36.100
Okay. Um, and we have
actually managed

00:12:36.100 --> 00:12:37.968
to, uh, make them both
very efficient, okay?

00:12:37.968 --> 00:12:40.634
And I'm about to explain
how we actually do that.

00:12:40.634 --> 00:12:43.901
Um, first of all,
the document interface,

00:12:43.901 --> 00:12:46.968
um, this is an interface
that operations apply to.

00:12:46.968 --> 00:12:49.667
Um, I'm showing it,
uh, I'm showing it here now

00:12:49.667 --> 00:12:51.467
because it gives you some idea
what the operations

00:12:51.467 --> 00:12:53.133
actually look like
and how the operations

00:12:53.133 --> 00:12:54.534
actually work.

00:12:54.534 --> 00:12:56.901
Um, the way the operations
actually, uh, apply

00:12:56.901 --> 00:13:00.200
to the document
is the operation stream

00:13:00.200 --> 00:13:03.667
are linearly ordered,
uh, uh, list of modifications

00:13:03.667 --> 00:13:05.901
into the do--
uh, document, okay?

00:13:05.901 --> 00:13:08.400
So these are--the--
uh, these operations

00:13:08.400 --> 00:13:12.200
look like, uh, uh, uh,
an ordered list

00:13:12.200 --> 00:13:15.267
of--of modifications,
uh, which are linearly ordered

00:13:15.267 --> 00:13:18.033
depending, uh, uh, relative
to their location

00:13:18.033 --> 00:13:19.701
in the document.

00:13:23.000 --> 00:13:26.267
Okay. And the way
we can actually use this,

00:13:26.267 --> 00:13:31.400
uh, linear order, uh, to, um,
compose them efficiently,

00:13:31.400 --> 00:13:34.133
uh, is by--by just zipping.

00:13:34.133 --> 00:13:36.801
If you have two, uh,
two, uh, operations--

00:13:36.801 --> 00:13:38.434
two consecutive operations,

00:13:38.434 --> 00:13:42.467
um, which are in this
ordered, uh, list format,

00:13:42.467 --> 00:13:44.300
then all it takes
to compose them together

00:13:44.300 --> 00:13:47.100
is to linearly traverse
the two lists

00:13:47.100 --> 00:13:49.834
and zip them together, okay?

00:13:49.834 --> 00:13:52.567
Uh, so this,

00:13:52.567 --> 00:13:56.300
uh, uh, effectively,
uh, com--combines

00:13:56.300 --> 00:13:59.934
the--the effects of the two,
uh, uh, two operations

00:13:59.934 --> 00:14:03.067
in a very--
very efficient way.

00:14:03.067 --> 00:14:05.801
And similarly, um, when,
uh, this gives us

00:14:05.801 --> 00:14:08.367
also a very efficient way
to do transformations

00:14:08.367 --> 00:14:10.801
because, um, to do
transformations,

00:14:10.801 --> 00:14:13.701
um, instead of just,
uh, traversing two--

00:14:13.701 --> 00:14:17.534
uh, sucking in two--
two, uh, uh, linear lists,

00:14:17.534 --> 00:14:19.734
and spitting out
a single linear list,

00:14:19.734 --> 00:14:21.968
uh, we--we're spitting out
two linearly lists this time.

00:14:21.968 --> 00:14:26.868
Okay? Uh, so the operation--
uh, so composition

00:14:26.868 --> 00:14:28.968
and transformations,
uh, they work

00:14:28.968 --> 00:14:31.901
in a--using a very similar,
um, mechanism.

00:14:31.901 --> 00:14:33.834
They just, uh,
pull in two--

00:14:33.834 --> 00:14:36.400
uh, traverse two--two,
uh, ordered lists

00:14:36.400 --> 00:14:39.234
in--simultaneously,
um, and spit out

00:14:39.234 --> 00:14:41.367
the--the result.

00:14:41.367 --> 00:14:43.167
Okay?

00:14:43.167 --> 00:14:47.968
Um, this gives you a--

00:14:47.968 --> 00:14:51.033
Um, because--because the--
uh, when you're composing,

00:14:51.033 --> 00:14:54.267
uh, the two, uh,
operations,

00:14:54.267 --> 00:14:56.968
uh, the--the little
modifications

00:14:56.968 --> 00:14:59.067
in the two operations
can actually overlap

00:14:59.067 --> 00:15:02.200
and, um, interfere
with ea--each other,

00:15:02.200 --> 00:15:05.434
uh, you can't just zip together
the modifications directly.

00:15:05.434 --> 00:15:08.067
Uh, what you have to do
is you have to do a-a proper zip

00:15:08.067 --> 00:15:10.434
similar to how you might
do a zip

00:15:10.434 --> 00:15:13.367
in an, uh, uh,
a-a functional ordered--

00:15:13.367 --> 00:15:16.300
func--sorry, a functional
programming language.

00:15:16.300 --> 00:15:19.100
If you're used to functional
programming languages,

00:15:19.100 --> 00:15:20.767
you might know
a lot of zip functions

00:15:20.767 --> 00:15:22.367
are quite common.

00:15:22.367 --> 00:15:25.133
Um, but, uh--

00:15:25.133 --> 00:15:26.434
so what actually
happens here

00:15:26.434 --> 00:15:30.200
is, uh, if you look at
the diagram here,

00:15:30.200 --> 00:15:33.701
the top bar in the diagram--
diagram represents the--

00:15:33.701 --> 00:15:37.634
the document before
the first operation is applied.

00:15:37.634 --> 00:15:40.033
The middle horizontal bar

00:15:40.033 --> 00:15:42.033
represents the document
after the first operation

00:15:42.033 --> 00:15:43.133
has been applied.

00:15:43.133 --> 00:15:46.000
And the bottom,
uh, bottom horizontal bar

00:15:46.000 --> 00:15:49.000
represents the up--uh, document
after the second operation

00:15:49.000 --> 00:15:50.801
has been applied.

00:15:50.801 --> 00:15:54.334
So what the--the white
parallelograms represents,

00:15:54.334 --> 00:15:59.400
um, just content that just
pass through by the operation.

00:15:59.400 --> 00:16:04.801
Uh, the, uh, the orange,
uh, triangles

00:16:04.801 --> 00:16:07.400
represents content
that has been deleted.

00:16:07.400 --> 00:16:09.467
And the green triangles
represents content

00:16:09.467 --> 00:16:12.100
that has been added
to the document, okay?

00:16:12.100 --> 00:16:15.934
So if you--
um, so this is--

00:16:15.934 --> 00:16:17.367
this is a--
uh, these horizontal bars

00:16:17.367 --> 00:16:20.801
are just linear views
of the document.

00:16:20.801 --> 00:16:22.267
Okay, so--so this is actually

00:16:22.267 --> 00:16:24.601
a very greatly simplified,
uh, document view.

00:16:24.601 --> 00:16:26.167
In actual fact,
our--our real document

00:16:26.167 --> 00:16:27.767
is quite a bit
more complicated.

00:16:27.767 --> 00:16:30.234
But, uh, for the purpose
of illustration,

00:16:30.234 --> 00:16:33.834
uh, this is, uh, roughly
what the documents look like.

00:16:33.834 --> 00:16:37.834
Um, so what we do
is we spit out these, um,

00:16:37.834 --> 00:16:43.000
these, uh, these operations,
uh, into smaller bits,

00:16:43.000 --> 00:16:45.901
uh, such that you
can perfectly match

00:16:45.901 --> 00:16:48.067
every bit in the top,
uh, in the first operation

00:16:48.067 --> 00:16:49.901
with every bit
in the second operation.

00:16:49.901 --> 00:16:54.200
Uh, that's what's illustrated
by the b--uh, bottom diagram.

00:16:54.200 --> 00:16:56.868
Um, and then what we do
is we pretty much glue

00:16:56.868 --> 00:16:58.667
the top and bottom
operations together

00:16:58.667 --> 00:17:01.234
along the middle document,
okay?

00:17:01.234 --> 00:17:03.067
And when you,
uh, if you think of it,

00:17:03.067 --> 00:17:06.234
uh, these, um, operations
as little rubber sheets--

00:17:06.234 --> 00:17:07.868
uh, if you glue along
the middle line

00:17:07.868 --> 00:17:09.200
and let the rubber sheets go,

00:17:09.200 --> 00:17:10.434
you get something
which looks a bit

00:17:10.434 --> 00:17:13.701
like the--the bottom,
uh, diagram.

00:17:13.701 --> 00:17:16.901
And these, uh, this gives you
a better illustration

00:17:16.901 --> 00:17:19.133
of which--which bits
are matched--

00:17:19.133 --> 00:17:20.634
which bits
in the first operation

00:17:20.634 --> 00:17:22.667
are matched with which bits
in the second operation.

00:17:22.667 --> 00:17:26.701
So for example,
uh, the two A's, um,

00:17:26.701 --> 00:17:27.968
they just
pass through content.

00:17:27.968 --> 00:17:31.200
Uh, their composition
is, uh, just a single A,

00:17:31.200 --> 00:17:32.968
which passes through
content.

00:17:32.968 --> 00:17:35.133
Um, if content is deleted

00:17:35.133 --> 00:17:36.534
either by the first
op--operation

00:17:36.534 --> 00:17:39.033
or the second operation,
uh, that content

00:17:39.033 --> 00:17:41.968
still remains deleted
in the--in their composition.

00:17:41.968 --> 00:17:44.667
Okay. That--that content
is, uh, um, deleted

00:17:44.667 --> 00:17:45.701
by their composition.

00:17:45.701 --> 00:17:47.501
And if anything
is inserted

00:17:47.501 --> 00:17:49.167
by the--the first
or second operation,

00:17:49.167 --> 00:17:53.667
um, then, uh, that--
that content is inserted

00:17:53.667 --> 00:17:55.033
by the composition.

00:17:55.033 --> 00:17:58.467
Uh, now the interesting bit
is, uh, uh, the--the K,

00:17:58.467 --> 00:18:01.934
um, since the K--
the--what the K represents

00:18:01.934 --> 00:18:04.000
is the K represents content
that has been inserted

00:18:04.000 --> 00:18:05.100
by the first operation,

00:18:05.100 --> 00:18:06.901
but deleted
by the second operation.

00:18:06.901 --> 00:18:10.968
When--when you glue
those two together, um,

00:18:10.968 --> 00:18:12.601
they just disappear, okay?

00:18:12.601 --> 00:18:15.901
So that's why K doesn't appear
in the bottom, um, diagram.

00:18:15.901 --> 00:18:19.567
Okay. So that gives you a, um,
a more detail, uh, idea

00:18:19.567 --> 00:18:24.267
of how our composition
actually works so efficiently.

00:18:24.267 --> 00:18:27.000
Um, another--
another interesting things

00:18:27.000 --> 00:18:29.267
you can, uh, you--you can do
with composition tree is--

00:18:29.267 --> 00:18:30.667
Sorry.

00:18:30.667 --> 00:18:33.400
Another interesting thing
you can do with compositions,

00:18:33.400 --> 00:18:35.167
is to create
a composition tree.

00:18:35.167 --> 00:18:38.367
And the way you actually create
a composition tree,

00:18:38.367 --> 00:18:43.901
um, suppose you have
a linear sequence of operations.

00:18:43.901 --> 00:18:46.934
Um, what you do
is you group each,

00:18:46.934 --> 00:18:50.601
uh, these operations
into adjacent pairs,

00:18:50.601 --> 00:18:53.167
and you compose each pair
to give you the next level

00:18:53.167 --> 00:18:54.501
up in the tree.

00:18:54.501 --> 00:18:56.534
So, um, all the--
all the operations

00:18:56.534 --> 00:19:00.601
in your sequence are--
make up your--your leaf notes

00:19:00.601 --> 00:19:02.067
of the--of your tree.

00:19:02.067 --> 00:19:04.067
Um, you compare
each adjacent pair

00:19:04.067 --> 00:19:06.234
to get--give you the next
level up.

00:19:06.234 --> 00:19:10.567
And--and, uh, so on,
up the levels, okay?

00:19:10.567 --> 00:19:13.834
Uh, for each level, you com--
just compose the, uh, operations

00:19:13.834 --> 00:19:15.634
in the next level down,
okay?

00:19:15.634 --> 00:19:17.734
So what that gives you
is it gives you a tree,

00:19:17.734 --> 00:19:22.234
uh, where each node,
uh, represents the composition

00:19:22.234 --> 00:19:24.434
of its two child nodes.

00:19:24.434 --> 00:19:27.267
And, uh, what
you can actually do

00:19:27.267 --> 00:19:29.033
with this data structure
is you can jump

00:19:29.033 --> 00:19:32.234
from any point in history
to any other point in history

00:19:32.234 --> 00:19:35.234
using only a logarithmic number
of operations.

00:19:35.234 --> 00:19:39.334
Uh, uh, is this,
uh, working?

00:19:39.334 --> 00:19:41.501
Okay, so, um, for example,

00:19:41.501 --> 00:19:43.200
if you want to jump
from the point

00:19:43.200 --> 00:19:44.434
just before operation 4

00:19:44.434 --> 00:19:47.067
to the point just after
operation 14,

00:19:47.067 --> 00:19:51.267
you only need to apply
four operations.

00:19:51.267 --> 00:19:56.067
Um, this is a-a huge saving,
um, if you--if you--

00:19:56.067 --> 00:19:59.634
if you want to de--
um, play back,

00:19:59.634 --> 00:20:00.901
jump to any point--

00:20:00.901 --> 00:20:04.033
if you want to play back
an operation's history,

00:20:04.033 --> 00:20:06.667
uh, and you want to jump
to any point in that playback,

00:20:06.667 --> 00:20:08.901
it only takes a logarithmic
number of operations

00:20:08.901 --> 00:20:10.701
to jump to that point.

00:20:10.701 --> 00:20:12.033
Uh, if you want to find
the difference

00:20:12.033 --> 00:20:14.234
between any points--
uh, any two points

00:20:14.234 --> 00:20:17.100
in the history,
um, you can just,

00:20:17.100 --> 00:20:20.634
uh, create a logarithmic
number of operations,

00:20:20.634 --> 00:20:22.133
which represent the ju--

00:20:22.133 --> 00:20:24.501
represents the jump
between the two points

00:20:24.501 --> 00:20:26.901
and compose them together
to--to give you the difference

00:20:26.901 --> 00:20:29.033
between two points, okay?

00:20:29.033 --> 00:20:30.934
So it's very,
uh, very efficient,

00:20:30.934 --> 00:20:34.033
um, to jump around.

00:20:34.033 --> 00:20:37.267
Okay, uh, that's...

00:20:37.267 --> 00:20:38.801
uh, the--the end
of my segment.

00:20:38.801 --> 00:20:43.734
And, uh, I'll hand you over
to Dan, our editor guy.

00:20:43.734 --> 00:20:47.334
[applause]

00:20:50.100 --> 00:20:51.501
Danilatos:
Uh, thanks, Alex.

00:20:51.501 --> 00:20:53.234
Uh, hi, everyone.
I'm Dan.

00:20:53.234 --> 00:20:56.434
So Dave and Alex
just gave you a quick overview

00:20:56.434 --> 00:20:59.434
of how, uh, we use
concurrency control

00:20:59.434 --> 00:21:01.200
and Operational Transform

00:21:01.200 --> 00:21:04.767
to shuffle these operations
between clients and agents.

00:21:04.767 --> 00:21:08.634
Um, now one of the end points,
uh, sitting on top of that,

00:21:08.634 --> 00:21:10.234
uh, is--is the editor.

00:21:10.234 --> 00:21:13.100
So that's a source and a sync
of these operations.

00:21:13.100 --> 00:21:15.767
Uh, just to show you
a bit of context here,

00:21:15.767 --> 00:21:17.467
um, you can see the editor
sitting on top of that.

00:21:17.467 --> 00:21:19.868
So it just gets
a serial, uh, stream

00:21:19.868 --> 00:21:23.334
of--of operations
coming in and out of it.

00:21:23.334 --> 00:21:25.400
Um, so what kind
of properties--

00:21:25.400 --> 00:21:26.567
what--what are the--
what are the goals

00:21:26.567 --> 00:21:27.801
of--of an editor?

00:21:27.801 --> 00:21:29.300
You guys saw the demo,
I suppose,

00:21:29.300 --> 00:21:31.334
so, um, the kinds of things

00:21:31.334 --> 00:21:33.767
that we want it
to be capable of.

00:21:33.767 --> 00:21:36.601
So obviously we want
a high granularity

00:21:36.601 --> 00:21:38.601
of--of extraction
and application

00:21:38.601 --> 00:21:41.467
of outgoing and incoming
operations.

00:21:41.467 --> 00:21:42.934
At the same time,

00:21:42.934 --> 00:21:46.400
we want to support
rich text and media

00:21:46.400 --> 00:21:49.267
and--and we want to make--
be able to make it extensible.

00:21:49.267 --> 00:21:51.267
Have users ex--
have developers extend it

00:21:51.267 --> 00:21:53.467
with their custom,
uh, widgets, gadgets,

00:21:53.467 --> 00:21:55.467
and so forth.

00:21:55.467 --> 00:21:59.200
And so to do this,
um, and--and to be able

00:21:59.200 --> 00:22:01.467
to interact with--
with this rich environment,

00:22:01.467 --> 00:22:02.834
it doesn't really make
much sense

00:22:02.834 --> 00:22:05.567
to use HTML as our--
as our data format.

00:22:05.567 --> 00:22:07.100
So--so we want to be able
to define

00:22:07.100 --> 00:22:08.334
our own abstract data model.

00:22:08.334 --> 00:22:09.534
And that's what we've done.

00:22:09.534 --> 00:22:11.400
And so the editor needs
to, uh, be able to map

00:22:11.400 --> 00:22:13.567
between that
and the display format,

00:22:13.567 --> 00:22:16.501
which is HTML,
because you're in a browser.

00:22:16.501 --> 00:22:18.701
Uh, at the same--
and furthermore,

00:22:18.701 --> 00:22:20.968
we want to have full control
over what's going on.

00:22:20.968 --> 00:22:22.601
We don't want to be
at the mercy of the browser.

00:22:22.601 --> 00:22:24.734
We want
to, uh, define exactly

00:22:24.734 --> 00:22:27.200
what the interactive
experience is like.

00:22:27.200 --> 00:22:31.234
And international, uh, support
is also, uh, a top priority.

00:22:31.234 --> 00:22:32.667
So we want to be able
to support RTL,

00:22:32.667 --> 00:22:35.467
Input Method Editors,
so and so forth.

00:22:35.467 --> 00:22:36.801
So how do we do all that?

00:22:36.801 --> 00:22:38.901
Okay. Firstly,
um, our document model

00:22:38.901 --> 00:22:43.033
that we happen to choose,
uh, is XML plus annotations.

00:22:43.033 --> 00:22:45.100
So XML we use
for the structured,

00:22:45.100 --> 00:22:47.567
uh, for the structure
of our document,

00:22:47.567 --> 00:22:50.901
and then we annotate regions
of that XML,

00:22:50.901 --> 00:22:53.000
uh, with annotations.

00:22:53.000 --> 00:22:54.834
So here's a simple example.

00:22:54.834 --> 00:22:57.100
I'll talk a bit more
about annotations in a sec.

00:22:57.100 --> 00:23:00.734
Um, but, uh, here's a simple
example of that.

00:23:00.734 --> 00:23:03.601
So we have--uh, in the demo,
you probably saw

00:23:03.601 --> 00:23:05.934
a whole bunch of images
being uploaded into a Wave.

00:23:05.934 --> 00:23:07.334
So here's an example
of that.

00:23:07.334 --> 00:23:09.367
And as you can see here,
it's very simple.

00:23:09.367 --> 00:23:10.767
It's just a w:image--

00:23:10.767 --> 00:23:12.400
just a namespace
we're arbitrarily using

00:23:12.400 --> 00:23:14.501
at the moment--
and an attachment

00:23:14.501 --> 00:23:15.968
and the caption.

00:23:15.968 --> 00:23:17.467
So that's nice
and straightforward.

00:23:17.467 --> 00:23:19.334
And the HTML for that
is, you know, all this junk.

00:23:19.334 --> 00:23:22.334
So you don't want to be having
that in your data model.

00:23:22.334 --> 00:23:25.400
Annotations, as I mentioned,
uh, they're simply,

00:23:25.400 --> 00:23:29.834
basically, key-value pairs
over regions of the document.

00:23:29.834 --> 00:23:32.067
Uh, each item conceptually--

00:23:32.067 --> 00:23:34.634
an item in the document
is a start tag, a character,

00:23:34.634 --> 00:23:35.834
and an end tag.

00:23:35.834 --> 00:23:37.834
Each--each item
conceptually has a map

00:23:37.834 --> 00:23:38.968
of key-value pairs.

00:23:38.968 --> 00:23:40.367
But if they're adjacent
and contiguous,

00:23:40.367 --> 00:23:41.901
you can think of them
as ranges.

00:23:41.901 --> 00:23:43.801
So we have some styled
red text

00:23:43.801 --> 00:23:45.400
overlapping with link.

00:23:45.400 --> 00:23:47.801
So, um, nice properties
of these annotations

00:23:47.801 --> 00:23:50.067
as you can see
is that they can overlap

00:23:50.067 --> 00:23:52.234
and they don't contribute
to the size of the content.

00:23:52.234 --> 00:23:54.801
So if we had to put
all these &lt;bold&gt; &lt;/bold&gt;

00:23:54.801 --> 00:23:56.968
and &lt;link&gt; &lt;/link&gt; tags
in there,

00:23:56.968 --> 00:23:58.467
um, firstly,
they don't overlap nicely.

00:23:58.467 --> 00:23:59.801
We'd have to split them up.

00:23:59.801 --> 00:24:01.501
And it sort of pollutes our--
the--the clean structure

00:24:01.501 --> 00:24:02.601
of the XML.

00:24:02.601 --> 00:24:03.934
So clients can ignore
the annotations

00:24:03.934 --> 00:24:05.200
they're not interested in.

00:24:05.200 --> 00:24:07.000
If you're not interested
in spelling annotations,

00:24:07.000 --> 00:24:08.400
for example,
you just don't render them.

00:24:08.400 --> 00:24:09.667
If you are, you do.

00:24:09.667 --> 00:24:14.234
Um, yeah, so uses,
uh, if--if you saw those carets

00:24:14.234 --> 00:24:16.767
and--and highlighting
of other people's selections,

00:24:16.767 --> 00:24:18.701
we just use annotations
for that.

00:24:18.701 --> 00:24:22.234
Uh, yeah, rich links.
Robot-specific data.

00:24:22.234 --> 00:24:24.434
So, for example, if a metadata
doesn't have to be rendered,

00:24:24.434 --> 00:24:27.100
it's up to, uh, the client
or the--the robot

00:24:27.100 --> 00:24:28.767
to interpret this stuff.

00:24:28.767 --> 00:24:31.200
Uh, diff highlighting
as well.

00:24:31.200 --> 00:24:33.634
Uh, and also the value
in the annotation.

00:24:33.634 --> 00:24:35.567
You could by convention
have that reference

00:24:35.567 --> 00:24:36.868
some other structured piece
of data

00:24:36.868 --> 00:24:39.334
and another document
to store more information.

00:24:39.334 --> 00:24:42.501
Okay, so how do we actually
render this stuff,

00:24:42.501 --> 00:24:44.367
um, from XML to HTML?

00:24:44.367 --> 00:24:46.200
XSLT anyone?

00:24:46.200 --> 00:24:47.434
Ha ha ha ha.

00:24:47.434 --> 00:24:49.400
Uh, well,
so we don't do that.

00:24:49.400 --> 00:24:50.400
Um, we...

00:24:50.400 --> 00:24:52.167
[laughter]

00:24:52.167 --> 00:24:56.033
We--we maintain
a-a-a nice mapping

00:24:56.033 --> 00:24:58.300
from--so we have a--
we have our DOM,

00:24:58.300 --> 00:25:00.968
which is our XML model
over here.

00:25:00.968 --> 00:25:04.100
And in the browser,
we have an actual tight mapping

00:25:04.100 --> 00:25:07.400
to the corresponding
HTML rendering here.

00:25:07.400 --> 00:25:09.400
Uh, so this is act--
an actual object reference.

00:25:09.400 --> 00:25:12.300
So by default, where--
where our model is the same--

00:25:12.300 --> 00:25:14.067
so P for paragraph,
and text nodes,

00:25:14.067 --> 00:25:15.167
and so and so on--

00:25:15.167 --> 00:25:16.801
when that--
when that matches HTML,

00:25:16.801 --> 00:25:18.067
it's very efficient.

00:25:18.067 --> 00:25:20.167
Uh, when you want
to append a child to the XML,

00:25:20.167 --> 00:25:22.167
we just get the corresponding
HTML node appended

00:25:22.167 --> 00:25:24.834
to the corresponding place
in the DOM.

00:25:24.834 --> 00:25:26.033
So that happens
very quickly.

00:25:26.033 --> 00:25:29.801
But if you want
to do something fancier,

00:25:29.801 --> 00:25:31.300
of course,
you can do that as well.

00:25:31.300 --> 00:25:33.667
So, uh, with the image
thumbnail example,

00:25:33.667 --> 00:25:35.601
again, we have this image
corresponding to a div

00:25:35.601 --> 00:25:37.367
and some very complicated stuff
in here.

00:25:37.367 --> 00:25:39.634
And that attribute here
maps to--to this source

00:25:39.634 --> 00:25:40.834
attributing the image.

00:25:40.834 --> 00:25:44.634
So you can define any custom,
uh, rendering

00:25:44.634 --> 00:25:47.000
that you--that you wish,
okay?

00:25:47.000 --> 00:25:49.167
And so now a bit
about annotations.

00:25:49.167 --> 00:25:50.234
So--so we have that content

00:25:50.234 --> 00:25:52.434
and we want
to annotate it thusly.

00:25:52.434 --> 00:25:55.234
We have,
uh, a spelling error here.

00:25:55.234 --> 00:25:57.200
We have a link.

00:25:57.200 --> 00:25:59.667
Uh, some styled text
with overlapping styles.

00:25:59.667 --> 00:26:01.033
See how he--
we just annotate them

00:26:01.033 --> 00:26:03.734
and the annotations overlap
quite nicely.

00:26:03.734 --> 00:26:05.167
And we want it to render
like this.

00:26:05.167 --> 00:26:06.901
And I just want to emphasize
the fact that we want

00:26:06.901 --> 00:26:09.067
to render it like this
is merely the choice

00:26:09.067 --> 00:26:10.501
of our particular client.

00:26:10.501 --> 00:26:12.000
You can render it or interpret
this information

00:26:12.000 --> 00:26:13.534
however you want.

00:26:13.534 --> 00:26:15.801
Uh, so the way
we actually do that,

00:26:15.801 --> 00:26:18.367
um, is we just have a little--
in our editor,

00:26:18.367 --> 00:26:20.234
we have a little utility
that goes through

00:26:20.234 --> 00:26:24.701
and does the actual--
renders those annotations

00:26:24.701 --> 00:26:28.767
into additional XML,
which is only stored locally.

00:26:28.767 --> 00:26:30.100
It's not sent to the server.

00:26:30.100 --> 00:26:31.701
And this does
all the resolution

00:26:31.701 --> 00:26:34.000
of the overlapping
annotations.

00:26:34.000 --> 00:26:35.767
So as you can see here,
we've got bold,

00:26:35.767 --> 00:26:38.300
bold and italic,
and just italic.

00:26:38.300 --> 00:26:40.834
Uh, and there's an extra node
here to--to control

00:26:40.834 --> 00:26:42.934
this little drop down
that we--we want.

00:26:42.934 --> 00:26:44.467
And then to render that
to HTML,

00:26:44.467 --> 00:26:46.000
we do that thing
I showed earlier,

00:26:46.000 --> 00:26:48.767
um, where we have a nice,
uh, usually one-to-one,

00:26:48.767 --> 00:26:51.934
but it--often,
arbitrary mapping.

00:26:51.934 --> 00:26:53.434
Okay, so quick summary.

00:26:53.434 --> 00:26:57.467
Um, from document to HTML DOM,
we have the fast path for--

00:26:57.467 --> 00:26:59.267
which is be--beneficial

00:26:59.267 --> 00:27:01.133
for when you're just pressing
enter a lot, or typing,

00:27:01.133 --> 00:27:02.300
or backspacing.

00:27:02.300 --> 00:27:03.767
But--and then also,

00:27:03.767 --> 00:27:06.033
uh, you can set up your own
mutation handling

00:27:06.033 --> 00:27:07.701
and custom rendering.

00:27:07.701 --> 00:27:10.033
And this stuff can also be used,
uh, for server-side rendering,

00:27:10.033 --> 00:27:11.968
so on and so forth,
not just the editor.

00:27:11.968 --> 00:27:14.334
Okay, so, now, the other side
of the coin

00:27:14.334 --> 00:27:15.868
is extracting operations.

00:27:15.868 --> 00:27:17.567
So how do we do this?

00:27:17.567 --> 00:27:21.534
Um, well, step one

00:27:21.534 --> 00:27:24.167
is you...

00:27:24.167 --> 00:27:27.234
make yourself
a little test harness.

00:27:27.234 --> 00:27:32.334
Uh, and you go, uh--
so that's the events I got.

00:27:32.334 --> 00:27:34.601
Okay. So I get that.
And then I did a key there.

00:27:34.601 --> 00:27:37.000
And then
the DOM actually changed.

00:27:37.000 --> 00:27:41.267
Um, and then let's say
I want to type in Chinese.

00:27:41.267 --> 00:27:45.934
And I go, oh, that's nice,
browser changed with DOM first

00:27:45.934 --> 00:27:47.968
and then gave me
a-a key event.

00:27:47.968 --> 00:27:49.167
How handy.

00:27:49.167 --> 00:27:50.367
Um, so anyway,

00:27:50.367 --> 00:27:52.434
so you--you figure
all this stuff out first,

00:27:52.434 --> 00:27:56.200
and then--and then you, um,
you--you decide,

00:27:56.200 --> 00:27:59.701
okay, some of these things,
uh, the browser does nicely.

00:27:59.701 --> 00:28:01.634
Others it--
it doesn't deal well.

00:28:01.634 --> 00:28:04.133
So, for example, bullet points
are a notorious example.

00:28:04.133 --> 00:28:05.634
Um, some things
we can't handle.

00:28:05.634 --> 00:28:06.834
Like IME input.

00:28:06.834 --> 00:28:08.300
Uh, if--if you get
a key event,

00:28:08.300 --> 00:28:10.567
it's not going to tell you
what the user's doing.

00:28:10.567 --> 00:28:13.100
So what we do is we--we try
to strike a balance

00:28:13.100 --> 00:28:16.367
between, uh,
allowing the browser

00:28:16.367 --> 00:28:20.100
to do its thing
in a contentEditable region

00:28:20.100 --> 00:28:24.200
and, um, handling events
ourselves.

00:28:24.200 --> 00:28:29.100
So, um, here's
a quick summary.

00:28:29.100 --> 00:28:30.901
So here's the browser
doing things.

00:28:30.901 --> 00:28:32.501
We get events, usually.

00:28:32.501 --> 00:28:34.567
Sometimes does
arbitrary things.

00:28:34.567 --> 00:28:38.334
Uh, and, uh, our event router
decides to funnel stuff off

00:28:38.334 --> 00:28:43.067
to handlers
or to notify extractors--

00:28:43.067 --> 00:28:44.667
I'm just moving
very quickly here--

00:28:44.667 --> 00:28:48.033
sorry, um, which--
which will inspect the HTML

00:28:48.033 --> 00:28:49.601
and then update our model
accordingly.

00:28:49.601 --> 00:28:51.534
If--if, uh, it goes
to a handler,

00:28:51.534 --> 00:28:53.567
we just update
the document directly,

00:28:53.567 --> 00:28:55.300
which then reflects
the change in the HTML.

00:28:55.300 --> 00:28:57.968
So, for example, I'll give you
a little demo here

00:28:57.968 --> 00:29:01.534
to hopefully illustrate this
a bit better.

00:29:01.534 --> 00:29:06.934
Um, this is--

00:29:06.934 --> 00:29:09.000
this is a little demonstration
of two editors here.

00:29:09.000 --> 00:29:10.467
So I've got one on one side
and one on the other.

00:29:10.467 --> 00:29:12.167
So I just type in.
Stuff appears.

00:29:12.167 --> 00:29:16.267
You can see, we have a P here
and a P there.

00:29:16.267 --> 00:29:19.801
And this extra BR
is just needed for Firefox to--

00:29:19.801 --> 00:29:21.234
it's just the way
it needs it.

00:29:21.234 --> 00:29:22.601
So if it's just the HTML,

00:29:22.601 --> 00:29:24.601
we don't have to keep that
in our--in our content.

00:29:24.601 --> 00:29:29.133
Um, and so--
so as you can see,

00:29:29.133 --> 00:29:33.534
uh, down here,
we have notifying extractor,

00:29:33.534 --> 00:29:37.000
and then we--we--we get
an operation from that.

00:29:37.000 --> 00:29:41.601
Whereas if I press enter,
um, you can see here,

00:29:41.601 --> 00:29:43.267
we prevented
that--that event.

00:29:43.267 --> 00:29:44.734
We didn't want
the, uh, the browser

00:29:44.734 --> 00:29:47.033
to do that because it's going
to munge up the--the DOM.

00:29:47.033 --> 00:29:50.400
So instead, we handle that
ourselves programmatically.

00:29:50.400 --> 00:29:54.400
Um, yeah,
so that's a rough overview.

00:29:54.400 --> 00:29:57.033
So that's,
um, just a summary there.

00:29:57.033 --> 00:30:00.501
Um, and do I--yeah.

00:30:00.501 --> 00:30:02.801
So--so in summary,
what we do,

00:30:02.801 --> 00:30:06.934
um, we--we've got an editor
that allows an arbitrary mapping

00:30:06.934 --> 00:30:10.167
from, uh, some document model
that we choose to HTML

00:30:10.167 --> 00:30:13.534
and--and, uh, fine-grained
extraction of operations.

00:30:13.534 --> 00:30:16.501
And we leverage the browser
where possible for layout

00:30:16.501 --> 00:30:18.701
or for IME support,
for example.

00:30:18.701 --> 00:30:21.734
But--but for other things,
uh, where possible,

00:30:21.734 --> 00:30:23.667
where the browser doesn't do
exactly what we want,

00:30:23.667 --> 00:30:26.667
we--we simply handle that
programmatically ourselves.

00:30:26.667 --> 00:30:30.267
So hopefully, uh, that gives you
a quick overview.

00:30:30.267 --> 00:30:32.701
And now
I'll introduce Casey,

00:30:32.701 --> 00:30:34.501
who will talk
about all the cool things

00:30:34.501 --> 00:30:37.667
you can do with--with all this
when you put it all together.

00:30:37.667 --> 00:30:42.367
[applause]

00:30:42.367 --> 00:30:43.968
Whitelaw: Thanks, Dan.

00:30:43.968 --> 00:30:45.234
So, uh, I'm Casey.

00:30:45.234 --> 00:30:47.300
I work on the Natural Language
Processing Team

00:30:47.300 --> 00:30:49.834
for--for Walkabout--
for, uh, Wave.

00:30:49.834 --> 00:30:50.834
We, uh, we had

00:30:50.834 --> 00:30:52.100
a Natural Language
Processing Team

00:30:52.100 --> 00:30:53.267
from really early on.

00:30:53.267 --> 00:30:54.667
And I think
that's really interesting.

00:30:54.667 --> 00:30:56.234
That's something I'll talk
about a little bit.

00:30:56.234 --> 00:30:58.767
Um, I'm in the enviable position
of having all of the hard work

00:30:58.767 --> 00:30:59.834
done for me already.

00:30:59.834 --> 00:31:01.801
Um, these guys
have given me a system

00:31:01.801 --> 00:31:04.701
that, uh, has already got,
uh, you know,

00:31:04.701 --> 00:31:06.601
uh, concurrency control,
live editing,

00:31:06.601 --> 00:31:09.000
and an incredible editor
to show this in.

00:31:09.000 --> 00:31:11.133
Um, so today,
I'm going to talk,

00:31:11.133 --> 00:31:15.167
uh, mostly about--
about spelling,

00:31:15.167 --> 00:31:17.300
which hopefully
was on the demo this morning.

00:31:17.300 --> 00:31:18.968
But I also want
to use that as an example

00:31:18.968 --> 00:31:22.267
of how you can build
smarter tools on top of Wave.

00:31:22.267 --> 00:31:23.934
Um, this is the thing
that I'm personally

00:31:23.934 --> 00:31:25.033
most excited about.

00:31:25.033 --> 00:31:26.334
So I want you
to keep this in mind

00:31:26.334 --> 00:31:27.701
while I'm talking
about spelling

00:31:27.701 --> 00:31:29.567
that this is not something
that's spelling specific.

00:31:29.567 --> 00:31:31.667
So the properties
of Wave that--

00:31:31.667 --> 00:31:33.133
So I really think
that--that Wave

00:31:33.133 --> 00:31:36.234
is an incredible platform
for building smarter tools.

00:31:36.234 --> 00:31:38.400
Um, and the reason for this,
first and foremost,

00:31:38.400 --> 00:31:39.934
is structure.

00:31:39.934 --> 00:31:41.400
So like we've been
talking about,

00:31:41.400 --> 00:31:44.300
Wave's XML with annotations
on top of them.

00:31:44.300 --> 00:31:46.234
Um, this lets you represent
the information

00:31:46.234 --> 00:31:48.367
that you want to put
in a Wave explicitly, right?

00:31:48.367 --> 00:31:49.968
So we're not storing
munged up HTML.

00:31:49.968 --> 00:31:51.033
We're not storing
plain text.

00:31:51.033 --> 00:31:52.367
You can put the content
that you want--

00:31:52.367 --> 00:31:53.701
it's XML,
so it's extensible--

00:31:53.701 --> 00:31:54.734
right there in the Wave

00:31:54.734 --> 00:31:56.400
and then you can collaborate
on it.

00:31:56.400 --> 00:31:58.400
That's the second one.
Collaboration.

00:31:58.400 --> 00:32:01.000
Um, collaboration
doesn't just involve people.

00:32:01.000 --> 00:32:02.234
It involves robots too

00:32:02.234 --> 00:32:03.334
as Dan told you
in the API talk

00:32:03.334 --> 00:32:05.234
and--and I'll get to
as well.

00:32:05.234 --> 00:32:06.367
And it's live, right?

00:32:06.367 --> 00:32:08.501
So you can be doing this
in exactly the same data

00:32:08.501 --> 00:32:09.634
at the same time.

00:32:09.634 --> 00:32:10.868
And last of all
is the fact

00:32:10.868 --> 00:32:12.200
that 'cause Waves are hosted

00:32:12.200 --> 00:32:13.634
and robots can live
in the cloud,

00:32:13.634 --> 00:32:16.400
you can do
some really exciting things.

00:32:16.400 --> 00:32:19.200
Um, so spelling,
if this goes well

00:32:19.200 --> 00:32:20.334
and I've got the network,

00:32:20.334 --> 00:32:23.834
I'm going
to give you a brief demo.

00:32:23.834 --> 00:32:26.467
Oh, dear.
Um, just a second.

00:32:26.467 --> 00:32:28.968
I'll just log in.

00:32:28.968 --> 00:32:33.467
Uh, Dan,
I'm typing Chinese.

00:32:33.467 --> 00:32:36.634
[laughter]

00:32:36.634 --> 00:32:38.200
It's all right.
I got it.

00:32:38.200 --> 00:32:41.701
Um, that Euro didn't exist.

00:32:41.701 --> 00:32:43.534
I don't know why.

00:32:43.534 --> 00:32:44.901
Okay, I'll just be a second.

00:32:44.901 --> 00:32:48.767
So, uh, uh, Lars got to do
all the--the cute demos

00:32:48.767 --> 00:32:50.801
this morning
with, uh, Iceland and so on.

00:32:50.801 --> 00:32:53.434
But, uh, I'm going to see
if I can just,

00:32:53.434 --> 00:32:56.934
uh, turn up the screen size
so you can see it.

00:32:56.934 --> 00:33:01.601
And...okay.

00:33:03.601 --> 00:33:09.334
All right.
Maybe a little bit too big.

00:33:09.334 --> 00:33:13.767
Smaller. Smaller.

00:33:13.767 --> 00:33:15.200
Something like that.
All right.

00:33:15.200 --> 00:33:16.901
So actually having this
not on my screen

00:33:16.901 --> 00:33:18.934
is going to make this
a perfect demo.

00:33:18.934 --> 00:33:21.767
Um, usually what I do

00:33:21.767 --> 00:33:26.300
is just kind of type
for awhile

00:33:26.300 --> 00:33:30.033
and see what happens.

00:33:30.033 --> 00:33:32.367
Uh, right.
I scrolled off to the right.

00:33:32.367 --> 00:33:33.701
So you can see here,

00:33:33.701 --> 00:33:36.467
we've got, uh, spelling
corrections coming in here.

00:33:36.467 --> 00:33:39.767
Jinda?
Yeah, nothing good there.

00:33:39.767 --> 00:33:44.567
Um, so, uh, let me see
if I can make my--

00:33:44.567 --> 00:33:47.100
let me see if I can just,
uh, get this--

00:33:47.100 --> 00:33:49.534
That's better.
Um, okay.

00:33:49.534 --> 00:33:54.467
So how's everyone going
out there?

00:33:54.467 --> 00:33:56.467
Right. So you saw--
oh, dear--

00:33:56.467 --> 00:33:58.868
um, you saw a bad example
of autocorrection

00:33:58.868 --> 00:34:00.667
doubling up a word.

00:34:00.667 --> 00:34:01.968
How's everyone going
out there?

00:34:01.968 --> 00:34:06.634
It's pretty nerve-racking

00:34:06.634 --> 00:34:09.968
on stage here.

00:34:09.968 --> 00:34:12.968
And...

00:34:12.968 --> 00:34:14.667
All right.

00:34:14.667 --> 00:34:16.334
So maybe I'll go back
to the canned demos then,

00:34:16.334 --> 00:34:18.000
uh, you know.

00:34:18.000 --> 00:34:21.200
Uh, so, uh, let me--
let me give this one more shot.

00:34:21.200 --> 00:34:27.167
Um, let me give this
one more shot.

00:34:27.167 --> 00:34:28.334
All right.

00:34:28.334 --> 00:34:29.934
So everything apart
from that little thing--

00:34:29.934 --> 00:34:31.067
it's going on right there--

00:34:31.067 --> 00:34:32.601
uh, you can--you can see
the intention here.

00:34:32.601 --> 00:34:34.133
So what we're doing
with spelling--

00:34:34.133 --> 00:34:36.801
um, doesn't always do this.

00:34:36.801 --> 00:34:39.734
Uh, what we're doing
with the spelling,

00:34:39.734 --> 00:34:44.067
uh, is, uh, trying to--
trying to, uh, do a better job

00:34:44.067 --> 00:34:45.400
of spelling in context

00:34:45.400 --> 00:34:47.767
so that you don't have
to, uh, slow down

00:34:47.767 --> 00:34:49.367
and you can just keep on
typing.

00:34:49.367 --> 00:34:52.868
Um, the--the reason behind this
is, you know, with Wave,

00:34:52.868 --> 00:34:55.033
we're really trying
to increase your productivity.

00:34:55.033 --> 00:34:57.701
In the same way that we transmit
your keystrokes straight away,

00:34:57.701 --> 00:34:58.968
we figure
that if you can just relax

00:34:58.968 --> 00:35:00.634
and type 5% faster,

00:35:00.634 --> 00:35:02.667
that's 5% less time
that you spend typing

00:35:02.667 --> 00:35:03.934
and it's 5% more time
you can spend

00:35:03.934 --> 00:35:05.234
doing something else.

00:35:05.234 --> 00:35:08.367
Um, so, uh, you know,
uh, not only do we want

00:35:08.367 --> 00:35:10.968
to be able to recognize
your spell--spelling mistakes

00:35:10.968 --> 00:35:13.334
more accurately,
um, when we're confident,

00:35:13.334 --> 00:35:15.868
we'll actually try
and autocorrect them as well.

00:35:15.868 --> 00:35:19.100
Um, so, uh,
how do we do that?

00:35:19.100 --> 00:35:20.767
Uh, that was--right.

00:35:20.767 --> 00:35:23.300
So the--the--the pieces
of this puzzle,

00:35:23.300 --> 00:35:25.300
um, first you're going
to need some way

00:35:25.300 --> 00:35:27.701
for, uh, spelling suggestions
to interact with the user,

00:35:27.701 --> 00:35:28.934
um, and that's what
we've got here.

00:35:28.934 --> 00:35:29.934
So you saw the dropdown.

00:35:29.934 --> 00:35:30.934
You saw the autocorrection

00:35:30.934 --> 00:35:32.434
that--that misfired slightly.

00:35:32.434 --> 00:35:34.901
Um, so here, you know,
is a quick example

00:35:34.901 --> 00:35:36.234
of a word
that's been flagged

00:35:36.234 --> 00:35:37.367
and a set of suggestions.

00:35:37.367 --> 00:35:38.767
And they are--
each of those suggestions

00:35:38.767 --> 00:35:40.267
is more or less likely.

00:35:40.267 --> 00:35:42.467
Um, and then, so, you know,
this is the kind of thing

00:35:42.467 --> 00:35:43.601
you want to see
in the client.

00:35:43.601 --> 00:35:45.567
And Dan told you
how we can extend our client

00:35:45.567 --> 00:35:46.868
on the editor.

00:35:46.868 --> 00:35:48.534
And then you need some way of
representing it.

00:35:48.534 --> 00:35:49.734
So I said it's just XML.

00:35:49.734 --> 00:35:50.868
So, you know, represent it

00:35:50.868 --> 00:35:52.267
exactly the way
that--that you want to.

00:35:52.267 --> 00:35:53.934
Get a spell tag in there
with suggestions

00:35:53.934 --> 00:35:55.133
and then use this
as an annotation

00:35:55.133 --> 00:35:56.334
for the range.

00:35:56.334 --> 00:35:57.934
You know, there's a set
of suggestions here.

00:35:57.934 --> 00:35:59.934
They're the words
and the--the scores

00:35:59.934 --> 00:36:02.534
that, you know, we think,
uh, which ones are how likely.

00:36:02.534 --> 00:36:03.934
So this is
straightforward, right?

00:36:03.934 --> 00:36:05.701
You know, there's--
there's nothing particular--

00:36:05.701 --> 00:36:07.200
it's exactly just representing
the problem

00:36:07.200 --> 00:36:09.501
that we're trying to represent
in the Wave.

00:36:09.501 --> 00:36:10.901
Um, and then there's
the third bit.

00:36:10.901 --> 00:36:13.834
So this is a little bit
trickier than the first two.

00:36:13.834 --> 00:36:15.601
We're going to make Spelly,
the spelling robot.

00:36:15.601 --> 00:36:17.434
So, uh, so Spelly
is an agent--

00:36:17.434 --> 00:36:19.834
uh, the same as the ones
that you can build on App Engine

00:36:19.834 --> 00:36:21.868
except we have built it
inside Google Data Centers--

00:36:21.868 --> 00:36:24.033
um, that is a participant
on your Wave,

00:36:24.033 --> 00:36:26.100
um, and can see changes
as they arrive--

00:36:26.100 --> 00:36:27.767
as--as they happen
on the Wave,

00:36:27.767 --> 00:36:29.667
um, check your spelling,
and then make suggestions

00:36:29.667 --> 00:36:31.200
by--all it does is write
those suggestions

00:36:31.200 --> 00:36:33.033
back into the Wave.

00:36:33.033 --> 00:36:36.267
Um, uh, so here's a--
here's a example.

00:36:36.267 --> 00:36:37.601
I'll walk through this
from end to end

00:36:37.601 --> 00:36:39.200
just so you can see
what's going on.

00:36:39.200 --> 00:36:41.467
Um, so here's an example,
uh, with a-a Wave.

00:36:41.467 --> 00:36:43.701
I said, you know, uh, "let's
meet for lunch tomorrow."

00:36:43.701 --> 00:36:45.734
Um, and in the split,
I've written,

00:36:45.734 --> 00:36:47.234
"Let's meet tomorrow morning,"

00:36:47.234 --> 00:36:48.467
although
I misspelled "meet."

00:36:48.467 --> 00:36:50.100
I spelled it M-E-T here.

00:36:50.100 --> 00:36:51.868
Um, so imagine
that I just typed this,

00:36:51.868 --> 00:36:54.067
um, you know, and it's being
live transmitted.

00:36:54.067 --> 00:36:56.100
Um, so what
actually happens is,

00:36:56.100 --> 00:36:58.501
uh, as, uh, David and Alex
told you,

00:36:58.501 --> 00:37:01.300
um, we bundle these changes up
into operations

00:37:01.300 --> 00:37:02.367
and we merge these

00:37:02.367 --> 00:37:03.868
and send them to the--
to the server.

00:37:03.868 --> 00:37:06.234
So let's imagine that the delta
that we've got right now

00:37:06.234 --> 00:37:07.801
is just the--this chunk
of letters

00:37:07.801 --> 00:37:10.634
from--from the E of "met"
through to, you--you know,

00:37:10.634 --> 00:37:11.834
the O of "morning,"
right?

00:37:11.834 --> 00:37:13.300
So, you know, we--we're batching
these up,

00:37:13.300 --> 00:37:14.367
we're sending them.

00:37:14.367 --> 00:37:15.567
Um, one of the key things
about Wave

00:37:15.567 --> 00:37:16.767
is efficiency
and scalability.

00:37:16.767 --> 00:37:18.667
So I'll mention this
a few times here.

00:37:18.667 --> 00:37:20.701
We're not--we're not sending
the entire text around.

00:37:20.701 --> 00:37:22.100
We're not sending things,
necessarily,

00:37:22.100 --> 00:37:23.467
character by character.

00:37:23.467 --> 00:37:25.200
You know, we're sending
these deltas through.

00:37:25.200 --> 00:37:26.667
Or the--the delta
gets sent back

00:37:26.667 --> 00:37:28.167
to the Google Wave service.

00:37:28.167 --> 00:37:30.133
And the delta--
either the same one

00:37:30.133 --> 00:37:33.234
or a transformed delta--
then gets passed on to Spelly.

00:37:33.234 --> 00:37:34.334
So Spelly already has some--

00:37:34.334 --> 00:37:36.534
some pre-existing Wave state
that it has.

00:37:36.534 --> 00:37:38.968
And it just has to apply
that transformed delta

00:37:38.968 --> 00:37:41.267
so that it now has
the up-to-date Wave state.

00:37:41.267 --> 00:37:42.734
So again, it's just sending
a delta.

00:37:42.734 --> 00:37:44.234
This is not
a special connection.

00:37:44.234 --> 00:37:45.534
This is, you know,
exactly the same connection

00:37:45.534 --> 00:37:47.534
that any client would use

00:37:47.534 --> 00:37:50.200
with the Google Wave service
as well.

00:37:50.200 --> 00:37:52.367
Um, so then--
so Spelly gets it and knows

00:37:52.367 --> 00:37:53.868
where these changes
have happened in the document.

00:37:53.868 --> 00:37:55.367
And because
it's interested in words,

00:37:55.367 --> 00:37:56.968
it's going
to tokenize it now.

00:37:56.968 --> 00:37:59.567
So I've highlighted in yellow
the area that it's changed here.

00:37:59.567 --> 00:38:01.634
The--the same thing happens
for every word

00:38:01.634 --> 00:38:03.167
that we're interested
in spell checking.

00:38:03.167 --> 00:38:05.334
So let's just concentrating
on the interesting word here,

00:38:05.334 --> 00:38:06.801
which is "met."

00:38:06.801 --> 00:38:09.534
Um, so for the word "met,"

00:38:09.534 --> 00:38:12.701
uh, let's say that we don't know
anything about language,

00:38:12.701 --> 00:38:14.267
um, and we don't know
which words

00:38:14.267 --> 00:38:15.701
are well spelled
or misspelled.

00:38:15.701 --> 00:38:17.300
That's exactly the situation
that Spelly's in.

00:38:17.300 --> 00:38:19.100
It doesn't have
a single dictionary in it.

00:38:19.100 --> 00:38:21.100
There's no hard-coded
information at all.

00:38:21.100 --> 00:38:23.000
It's a completely
statistical system

00:38:23.000 --> 00:38:24.634
that we learned
from the web.

00:38:24.634 --> 00:38:26.934
So the first part
of that is an error model,

00:38:26.934 --> 00:38:28.868
which is a context-free model.

00:38:28.868 --> 00:38:30.634
Given any word, um, it--

00:38:30.634 --> 00:38:32.567
let's assume that that word
is misspelled

00:38:32.567 --> 00:38:35.968
and let's find other words
that are likely corrections

00:38:35.968 --> 00:38:37.067
for this word.

00:38:37.067 --> 00:38:38.334
So, of course,
likely corrections

00:38:38.334 --> 00:38:40.000
are things that are going
to be relatively close

00:38:40.000 --> 00:38:41.767
in edit distance space,
you know,

00:38:41.767 --> 00:38:43.734
depending on how you define
edit distance.

00:38:43.734 --> 00:38:45.033
Um, and so there are going
to be things

00:38:45.033 --> 00:38:46.400
like the word "meat,"
the food, you know,

00:38:46.400 --> 00:38:47.701
which you would get--

00:38:47.701 --> 00:38:49.868
if you accidentally left
an A off, you would get "met."

00:38:49.868 --> 00:38:52.467
And "meet," which is the one
we're interested in--M-E-E-T.

00:38:52.467 --> 00:38:53.901
You know, and "net"
and "get" and "me."

00:38:53.901 --> 00:38:55.467
You know,
there's all these words,

00:38:55.467 --> 00:38:58.601
that you could have meant
when you actually typed "met."

00:38:58.601 --> 00:39:00.400
Um, so the likelihood

00:39:00.400 --> 00:39:01.901
of these various misspellings
and so on, as I said,

00:39:01.901 --> 00:39:03.567
this is a context-free
error model.

00:39:03.567 --> 00:39:04.901
We're just considering
the word "met"

00:39:04.901 --> 00:39:06.200
and nothing else.

00:39:06.200 --> 00:39:08.868
But we get a-a list of these
and their likelihoods.

00:39:08.868 --> 00:39:11.567
Second, for each
of these candidates,

00:39:11.567 --> 00:39:12.934
we evaluate them
in the context.

00:39:12.934 --> 00:39:14.267
So this is, you know,
part of the magic

00:39:14.267 --> 00:39:16.067
that we can do with Spelly.

00:39:16.067 --> 00:39:17.901
Um, so we look
at the context here.

00:39:17.901 --> 00:39:19.567
I'm just using a single word
of context on either side

00:39:19.567 --> 00:39:20.901
to illustrate this.

00:39:20.901 --> 00:39:23.801
Um, and you--
you look at how likely

00:39:23.801 --> 00:39:25.167
each of these phrases are.

00:39:25.167 --> 00:39:27.868
So "let's met tomorrow,"
uh, doesn't sound so good.

00:39:27.868 --> 00:39:29.133
"Let's meat tomorrow."

00:39:29.133 --> 00:39:31.033
Well, maybe if you're going
to a barbecue.

00:39:31.033 --> 00:39:34.200
Um, "let's meet tomorrow."
That sounds better.

00:39:34.200 --> 00:39:35.300
"Let's net, let's get,"
and so on, you know.

00:39:35.300 --> 00:39:36.300
So as you can see,

00:39:36.300 --> 00:39:38.501
the combination
of this--the error model

00:39:38.501 --> 00:39:39.901
and the language model
together

00:39:39.901 --> 00:39:42.534
gives us enough information
to work out how likely

00:39:42.534 --> 00:39:44.934
each of these is,
um, as the original--

00:39:44.934 --> 00:39:47.167
as a--as the intended word.

00:39:47.167 --> 00:39:49.834
Um, so just a note
about the language models here.

00:39:49.834 --> 00:39:51.367
These language models
are really big.

00:39:51.367 --> 00:39:53.534
So they're the same kinds
of things that we use

00:39:53.534 --> 00:39:55.868
for the Rosetta machine
translation service,

00:39:55.868 --> 00:39:59.167
um, which is what you saw
in Rosy in the demo as well.

00:39:59.167 --> 00:40:01.100
Um, and we literally,
you know,

00:40:01.100 --> 00:40:02.701
train these from the web
from all the data

00:40:02.701 --> 00:40:03.968
that we can get
our hands on.

00:40:03.968 --> 00:40:06.467
Billions of web pages,
billions of words

00:40:06.467 --> 00:40:08.934
turned into
multi-multigigabyte models.

00:40:08.934 --> 00:40:10.801
Um, these are not the kind
of things

00:40:10.801 --> 00:40:12.567
that you can run
on your desktop

00:40:12.567 --> 00:40:13.834
and they're certainly not
the kind of things

00:40:13.834 --> 00:40:15.133
that you can run
on your mobile phone.

00:40:15.133 --> 00:40:16.434
Um, so it's lucky
that somebody else

00:40:16.434 --> 00:40:17.667
is doing that for you.

00:40:17.667 --> 00:40:19.367
It actually works out
pretty cheap

00:40:19.367 --> 00:40:20.767
on a per user basis

00:40:20.767 --> 00:40:22.234
because they're--
they're large share models

00:40:22.234 --> 00:40:24.167
that everyone can use
together.

00:40:24.167 --> 00:40:26.601
Um, okay, so, uh,
so language models.

00:40:26.601 --> 00:40:27.934
We get to pick the word.

00:40:27.934 --> 00:40:30.601
So we've--we've chosen
that "meet" with two Es

00:40:30.601 --> 00:40:32.067
is correct.

00:40:32.067 --> 00:40:35.234
And all that Spelly has to do
is send back to the,

00:40:35.234 --> 00:40:38.634
uh, to the server,
uh, a-a new delta,

00:40:38.634 --> 00:40:40.968
which says annotate
the original word "met"

00:40:40.968 --> 00:40:42.667
with this, you know,
piece of XML

00:40:42.667 --> 00:40:44.100
that says this is
a spelling mistake

00:40:44.100 --> 00:40:45.801
and these are the suggestions
that I've got for it.

00:40:45.801 --> 00:40:48.567
And these are how likely
they all are.

00:40:48.567 --> 00:40:51.100
Um, and that's it.
So it just sends it back.

00:40:51.100 --> 00:40:53.234
And that gets propagated out
to all the rest of the clients

00:40:53.234 --> 00:40:55.434
just like any other change.

00:40:55.434 --> 00:40:58.400
So spelling works
really, uh, quite well

00:40:58.400 --> 00:40:59.901
in--in Google Wave.

00:40:59.901 --> 00:41:02.200
Um, this isn't just
coincidence.

00:41:02.200 --> 00:41:04.067
Um, like I said, you know,
we started looking

00:41:04.067 --> 00:41:07.200
at natural language applications
early on--early on in Wave.

00:41:07.200 --> 00:41:11.767
Um, and you might think--
so, uh, uh, the--the liveness

00:41:11.767 --> 00:41:14.133
of--of Wave,
you know, is great

00:41:14.133 --> 00:41:15.400
when you can see
multiple people

00:41:15.400 --> 00:41:16.701
editing nearby each other.

00:41:16.701 --> 00:41:18.567
And it's actually very useful
in practice.

00:41:18.567 --> 00:41:20.701
But the, uh,
you might think

00:41:20.701 --> 00:41:22.033
that the lengths
that we've gone to

00:41:22.033 --> 00:41:23.200
with our concurrency control

00:41:23.200 --> 00:41:24.400
are not really
all that necessary

00:41:24.400 --> 00:41:25.701
'cause how often
are you actually,

00:41:25.701 --> 00:41:27.434
you know, kind of styling
somebody else's text

00:41:27.434 --> 00:41:28.534
at the same time?

00:41:28.534 --> 00:41:29.968
We always wanted
to be able to do

00:41:29.968 --> 00:41:31.334
this kind of thing.

00:41:31.334 --> 00:41:33.200
We always wanted to be able
to do server-side spelling

00:41:33.200 --> 00:41:34.367
and then a whole lot
of other rich,

00:41:34.367 --> 00:41:36.467
smart applications
on top of Wave.

00:41:36.467 --> 00:41:37.834
Um, and so when we started,
we're like,

00:41:37.834 --> 00:41:39.167
"Oh, well, if we want
to do that,

00:41:39.167 --> 00:41:40.634
"then we're going
to have to build in some way

00:41:40.634 --> 00:41:42.868
"of, you know, like, letting
this special spelling service

00:41:42.868 --> 00:41:45.567
get in there and, like, make
these really tight changes."

00:41:45.567 --> 00:41:47.234
And it turns out, you know,
you get it all for free

00:41:47.234 --> 00:41:49.234
if you just--like, if you're
going to do that for spelling,

00:41:49.234 --> 00:41:50.901
then you can do it
for everything, right?

00:41:50.901 --> 00:41:52.167
Or if you're going to do it
for people,

00:41:52.167 --> 00:41:53.734
you get to do it
for spelling for free, right?

00:41:53.734 --> 00:41:56.000
So this one system supports
exactly the kind of things

00:41:56.000 --> 00:41:58.434
that--that you need to be able
to support this kind

00:41:58.434 --> 00:42:00.133
of--of system.

00:42:00.133 --> 00:42:01.601
Again, with the XML as well,

00:42:01.601 --> 00:42:03.901
if we hadn't gone down
that rich structured path,

00:42:03.901 --> 00:42:05.167
um, doing this kind
of thing

00:42:05.167 --> 00:42:07.434
would've been much more
difficult.

00:42:07.434 --> 00:42:10.234
Uh, so I just wanted
to talk a little bit

00:42:10.234 --> 00:42:12.734
about, you know,
why it's different

00:42:12.734 --> 00:42:14.501
to solve this problem
in this way.

00:42:14.501 --> 00:42:17.601
So the--the biggest thing,
like I said,

00:42:17.601 --> 00:42:21.000
uh, so you--you can get
the same quality spell checking

00:42:21.000 --> 00:42:23.234
from any device that you're
accessing Google Wave from.

00:42:23.234 --> 00:42:24.968
So if you're accessing it
on your mobile device

00:42:24.968 --> 00:42:26.601
or on your desktop
or on your laptop,

00:42:26.601 --> 00:42:29.300
you get access
to exactly the same Spelly

00:42:29.300 --> 00:42:31.234
as ever--as everywhere else.

00:42:31.234 --> 00:42:32.834
And this is
really powerful, right,

00:42:32.834 --> 00:42:34.734
'cause there's no way,
you know, even if we can pack

00:42:34.734 --> 00:42:36.767
some kind of language model
into your, you know,

00:42:36.767 --> 00:42:38.300
into your Android,

00:42:38.300 --> 00:42:39.801
we can't do that
for 40 languages,

00:42:39.801 --> 00:42:40.934
or, you know,
100 languages,

00:42:40.934 --> 00:42:42.334
but we can do that
in a Data Center.

00:42:42.334 --> 00:42:44.501
So that's a huge advantage.

00:42:44.501 --> 00:42:48.000
Um, we can, again, uh,
get better quality

00:42:48.000 --> 00:42:49.267
by using more data.

00:42:49.267 --> 00:42:51.033
And I think this is the way
that statistical natural

00:42:51.033 --> 00:42:52.834
language processing
is moving in general.

00:42:52.834 --> 00:42:54.567
We're just saying
that the more data

00:42:54.567 --> 00:42:56.167
that you use--you know,
if Peter Norvig was here,

00:42:56.167 --> 00:42:58.234
he would, uh, accuse me
of stealing his lines.

00:42:58.234 --> 00:43:00.267
But, you know,
the more data that you use,

00:43:00.267 --> 00:43:02.667
the easier it is to solve
these--to solve these problems

00:43:02.667 --> 00:43:04.467
and you see improvements
in quality.

00:43:04.467 --> 00:43:07.334
Um, like I said,
so we can share the resources

00:43:07.334 --> 00:43:09.300
as we--when we put
these, uh, smart services

00:43:09.300 --> 00:43:10.601
in the cloud.

00:43:10.601 --> 00:43:12.534
We can share the relatively
expensive resources

00:43:12.534 --> 00:43:15.100
between many users who are all
using the same system,

00:43:15.100 --> 00:43:17.934
um, which makes it feasible
to do this in the first place.

00:43:17.934 --> 00:43:19.934
Um, one thing
I didn't mention

00:43:19.934 --> 00:43:22.100
when I was going through the--
the Spelly demo just before,

00:43:22.100 --> 00:43:24.200
the walkthrough--
is you'll notice

00:43:24.200 --> 00:43:25.501
that we are only--

00:43:25.501 --> 00:43:27.567
we know exactly where
the changes happen in the text,

00:43:27.567 --> 00:43:29.667
which means we don't have
to respell the entire document,

00:43:29.667 --> 00:43:31.000
right?

00:43:31.000 --> 00:43:32.767
So, you know, this is
another efficiency thing.

00:43:32.767 --> 00:43:34.801
We're not shipping
whole documents around.

00:43:34.801 --> 00:43:36.434
We're not reannotating
entire documents the whole time.

00:43:36.434 --> 00:43:37.701
Right?

00:43:37.701 --> 00:43:39.367
If you--if you look
at the--the system naively,

00:43:39.367 --> 00:43:40.434
you'll think there is no way

00:43:40.434 --> 00:43:41.601
that you can possibly
scale this.

00:43:41.601 --> 00:43:43.067
There's no way that you can
possibly do this

00:43:43.067 --> 00:43:44.434
for millions of documents,
you know,

00:43:44.434 --> 00:43:46.434
for millions of people
all the time.

00:43:46.434 --> 00:43:48.634
And--and--and so
we didn't do the naive thing.

00:43:48.634 --> 00:43:50.367
Just--just in case
you were wondering.

00:43:50.367 --> 00:43:52.934
Um, one other thing
about robots here, you know,

00:43:52.934 --> 00:43:55.367
as--as a way of implementing
services like spelling,

00:43:55.367 --> 00:43:56.968
uh, is that
they're interactive.

00:43:56.968 --> 00:43:59.067
So not only can Spelly
write into the Wave,

00:43:59.067 --> 00:44:01.434
but it's continuing to interact
with you on the Wave.

00:44:01.434 --> 00:44:03.968
So it can see
what you do later on.

00:44:03.968 --> 00:44:06.534
So, for instance, if it flags
a word as a misspelling,

00:44:06.534 --> 00:44:09.634
uh, and then you, uh,
accept its correction,

00:44:09.634 --> 00:44:10.968
then that's positive feedback

00:44:10.968 --> 00:44:12.234
that you've done
the right thing.

00:44:12.234 --> 00:44:13.467
You know,
congratulations.

00:44:13.467 --> 00:44:15.801
If you autocorrect something

00:44:15.801 --> 00:44:17.567
and then they go back
and they, uh, say, "Actually,

00:44:17.567 --> 00:44:19.434
no, that wasn't what I meant,
I meant something else,"

00:44:19.434 --> 00:44:22.534
that's really strong negative,
uh, negative, uh, signal

00:44:22.534 --> 00:44:23.667
that you've done
the wrong thing

00:44:23.667 --> 00:44:25.200
and you should probably
never do that again.

00:44:25.200 --> 00:44:26.868
Um, so, that's not
what you're seeing

00:44:26.868 --> 00:44:28.300
at the moment in Spelly,

00:44:28.300 --> 00:44:29.701
but that's something
that we can certainly do.

00:44:29.701 --> 00:44:31.400
And that's something that you
generally can't do

00:44:31.400 --> 00:44:33.434
with these kind of systems.

00:44:33.434 --> 00:44:35.467
Uh, okay, so I--
like I said,

00:44:35.467 --> 00:44:37.200
this is about
more than, uh, spelling.

00:44:37.200 --> 00:44:38.868
It's about a whole range
of other applications,

00:44:38.868 --> 00:44:40.801
uh, that you can think of
and I can think of.

00:44:40.801 --> 00:44:43.234
And, you know, if you've got
a background in this stuff,

00:44:43.234 --> 00:44:45.334
you're already thinking
of 100 things that you can do,

00:44:45.334 --> 00:44:46.734
if you're anything like me.

00:44:46.734 --> 00:44:49.701
Uh, so, an interesting thing
about Wave

00:44:49.701 --> 00:44:51.033
is also that it provides
a platform

00:44:51.033 --> 00:44:52.434
for collaboration
between robots.

00:44:52.434 --> 00:44:53.868
So forget about people
for a second.

00:44:53.868 --> 00:44:56.567
Um, you know, you can get
a language identification robot,

00:44:56.567 --> 00:44:58.734
working together
with spellchecker

00:44:58.734 --> 00:45:00.334
so you know
which language model to use.

00:45:00.334 --> 00:45:03.067
Um, you can bring,
uh, Rosy the translator in

00:45:03.067 --> 00:45:04.534
so that it uses
the language ID.

00:45:04.534 --> 00:45:06.200
And if there's
a spelling mistake,

00:45:06.200 --> 00:45:07.934
it can, you know, consider
the spelling mistakes as well

00:45:07.934 --> 00:45:09.434
when it's doing
a translation.

00:45:09.434 --> 00:45:11.234
You know, all of these things
can interact.

00:45:11.234 --> 00:45:12.501
You know,
if you can identify names

00:45:12.501 --> 00:45:15.100
in the text,
then you might know

00:45:15.100 --> 00:45:16.534
that when you're
translating names,

00:45:16.534 --> 00:45:18.334
for instance,
you can treat names specially.

00:45:18.334 --> 00:45:20.033
You know, you can use
transliteration

00:45:20.033 --> 00:45:22.501
instead of trying to do
normal--normal work.

00:45:22.501 --> 00:45:24.100
And you can do this,
you know, in a traditional,

00:45:24.100 --> 00:45:25.868
kind of multi-agent system
kind of a way

00:45:25.868 --> 00:45:27.501
by making specialist agents
which are all good

00:45:27.501 --> 00:45:28.868
at what they do.

00:45:28.868 --> 00:45:30.467
And, remember, these don't
all have to be written

00:45:30.467 --> 00:45:31.801
by the same person,
right?

00:45:31.801 --> 00:45:33.667
They're just collaborating
in one Wave.

00:45:33.667 --> 00:45:35.734
Uh, and they can all work
together.

00:45:35.734 --> 00:45:38.100
Uh, the most important thing
in this though,

00:45:38.100 --> 00:45:41.367
uh, I think, you know, that many
multi-agent systems lack

00:45:41.367 --> 00:45:43.367
is that there are users
in this system

00:45:43.367 --> 00:45:45.267
doing live interaction
as well.

00:45:45.267 --> 00:45:46.868
And the purpose
of all these,

00:45:46.868 --> 00:45:48.467
you know,
of all these agents,

00:45:48.467 --> 00:45:50.434
the robots,
um, is that they're there

00:45:50.434 --> 00:45:53.067
to help you be more productive
and get your work done.

00:45:53.067 --> 00:45:56.367
So it gives a real focus
to the tasks that they're doing,

00:45:56.367 --> 00:45:57.734
which I think sometimes
are lacking

00:45:57.734 --> 00:45:59.300
in these kinds of systems.

00:45:59.300 --> 00:46:01.801
So this is--
this is really exciting.

00:46:01.801 --> 00:46:04.868
I-I think that,
uh, this model

00:46:04.868 --> 00:46:07.534
of being able to represent
your structure explicitly,

00:46:07.534 --> 00:46:11.901
um, being able to, uh,
host services that are smart,

00:46:11.901 --> 00:46:13.734
uh, that you can--
that you can use

00:46:13.734 --> 00:46:15.534
a large amount of data
to build,

00:46:15.534 --> 00:46:18.133
and that you can deploy
to many, many users

00:46:18.133 --> 00:46:20.033
and then interact
collaboratively with them,

00:46:20.033 --> 00:46:21.634
um, is really powerful.

00:46:21.634 --> 00:46:23.167
And I think, you know,
spelling and things like that

00:46:23.167 --> 00:46:25.234
are only just the beginning.

00:46:25.234 --> 00:46:27.234
That's all I got.

00:46:27.234 --> 00:46:32.133
[applause]

00:46:32.133 --> 00:46:36.300
So, we've--we've got
13 minutes and 47 seconds

00:46:36.300 --> 00:46:37.734
for questions.

00:46:37.734 --> 00:46:39.801
Please use the microphones
if you questions

00:46:39.801 --> 00:46:41.033
for any of us.

00:46:41.033 --> 00:46:42.801
Um, and I would like
to remind you again

00:46:42.801 --> 00:46:47.934
to go to www.haveasec.com/io
for feedback about this session.

00:46:47.934 --> 00:46:49.734
Um, also feel free
to grab any of us

00:46:49.734 --> 00:46:51.901
after the--well, me,
I'm volunteering me.

00:46:51.901 --> 00:46:53.400
I'm volunteering
all of these guys as well.

00:46:53.400 --> 00:46:54.734
Feel free to grab us
after this

00:46:54.734 --> 00:46:58.300
if you can find us and ask
those questions then too.

00:46:58.300 --> 00:47:01.267
man: Do you see any down sides
to applying these concepts

00:47:01.267 --> 00:47:04.234
of, let's see,
your composition algorithm

00:47:04.234 --> 00:47:09.234
and your natural language model
to source code

00:47:09.234 --> 00:47:11.234
to kind of replace SVN

00:47:11.234 --> 00:47:13.901
and other burgeoning software
to look at diffs

00:47:13.901 --> 00:47:15.000
more efficiently?

00:47:15.000 --> 00:47:16.400
Whitelaw: Um, well,
I'll take th--

00:47:16.400 --> 00:47:18.200
man: I guess, that's,
you know, a two-part question

00:47:18.200 --> 00:47:19.400
for both of you guys.

00:47:19.400 --> 00:47:20.901
Whitelaw: I'll take
the natural language

00:47:20.901 --> 00:47:22.467
and then you guys can take
the--the OT stuff.

00:47:22.467 --> 00:47:24.534
Um, so you can use--

00:47:24.534 --> 00:47:27.033
so, you know, many people
have had the idea

00:47:27.033 --> 00:47:28.434
of using this
to build an ID.

00:47:28.434 --> 00:47:29.734
And--and we think
that's fantastic.

00:47:29.734 --> 00:47:31.467
And, you know,
if we had a lot of time,

00:47:31.467 --> 00:47:33.534
which we don't, we would
probably have built one too.

00:47:33.534 --> 00:47:35.767
Um, and so the way
that you could do this

00:47:35.767 --> 00:47:37.167
kind of, you know,
smarter assistance

00:47:37.167 --> 00:47:38.801
is the same kind of things
that you see in Eclipse

00:47:38.801 --> 00:47:39.801
and so on, you know.

00:47:39.801 --> 00:47:40.934
They're trying to help you.

00:47:40.934 --> 00:47:42.934
But if you can imagine
having, you know,

00:47:42.934 --> 00:47:45.734
a data center behind, uh,
Eclipse autosuggest instead,

00:47:45.734 --> 00:47:48.267
I think
that's really powerful.

00:47:48.267 --> 00:47:51.868
Mah: Okay, um...
what's your question?

00:47:51.868 --> 00:47:56.434
Whether you could, uh, use,
uh, the concurrency control

00:47:56.434 --> 00:47:58.934
for SV--uh, as a replacement
for search control?

00:47:58.934 --> 00:48:01.601
man: A little more efficiently
at the, uh, differences.

00:48:01.601 --> 00:48:04.767
Mah: Um, I don't know.

00:48:04.767 --> 00:48:07.300
Because the--our--
our algorithms,

00:48:07.300 --> 00:48:10.601
um, they never fail, in--

00:48:10.601 --> 00:48:14.100
[laughter and applause]

00:48:14.100 --> 00:48:15.734
Whitelaw: That's the--
that's the down side.

00:48:15.734 --> 00:48:17.133
Mah: Yeah, that--
that's the down side.

00:48:17.133 --> 00:48:18.534
Because, uh, when you--
when you--

00:48:18.534 --> 00:48:20.067
in--in source control,

00:48:20.067 --> 00:48:22.067
um, their--
their merge algorithms

00:48:22.067 --> 00:48:24.767
are--are designed,
uh, so that, um,

00:48:24.767 --> 00:48:27.234
if you--it--
you'll detect conflicts.

00:48:27.234 --> 00:48:30.167
And, uh, if there's
any conflicts,

00:48:30.167 --> 00:48:34.434
um, you'll--you'll--
you'll have a merge failure

00:48:34.434 --> 00:48:36.167
and you have
to resolve it manually.

00:48:36.167 --> 00:48:37.634
Um, the--the reason
is because,

00:48:37.634 --> 00:48:42.801
uh, these source controls,
uh, they actually emphasize,

00:48:42.801 --> 00:48:45.434
um, the actual
document states, okay?

00:48:45.434 --> 00:48:47.200
They don't actually emphasize
the changes

00:48:47.200 --> 00:48:48.534
between the documents.

00:48:48.534 --> 00:48:50.968
Um, so what you--what you do
is, uh, in the search--

00:48:50.968 --> 00:48:54.667
source control, um,
um, the--the document states

00:48:54.667 --> 00:48:58.067
are the primary objects
and the changes between them

00:48:58.067 --> 00:48:59.200
are the secondary.

00:48:59.200 --> 00:49:00.634
You generate
the changes between

00:49:00.634 --> 00:49:03.767
by looking at the--the, um,
the--the documents states

00:49:03.767 --> 00:49:05.701
before and after
and you do some sort of,

00:49:05.701 --> 00:49:07.467
uh, diff algorithm.

00:49:07.467 --> 00:49:09.200
Uh, but what we--
what we have here

00:49:09.200 --> 00:49:13.501
is, uh, our operations
are actually the primary object.

00:49:13.501 --> 00:49:16.467
The document states
are only the, um, the result

00:49:16.467 --> 00:49:18.534
of performing operations.

00:49:18.534 --> 00:49:22.567
Um, all, um,
all our--all our algorithms,

00:49:22.567 --> 00:49:25.601
um, our transformations
are on composition.

00:49:25.601 --> 00:49:30.234
Um, they're performed,
um, directly on the operations.

00:49:30.234 --> 00:49:32.300
Um, so it's impossible
for them to fail

00:49:32.300 --> 00:49:35.901
because the operations
are primary objects.

00:49:35.901 --> 00:49:38.467
Um...

00:49:38.467 --> 00:49:39.834
man: That's great.
That's exciting.

00:49:39.834 --> 00:49:41.601
Mah: Yeah. [laughs]

00:49:41.601 --> 00:49:43.334
Whitelaw: Uh, someone
from over here.

00:49:43.334 --> 00:49:47.367
man: His question sort of,
uh, got ahead of mine.

00:49:47.367 --> 00:49:50.834
But I was interested
in terms of especially

00:49:50.834 --> 00:49:52.834
in programming languages,
but really in anything

00:49:52.834 --> 00:49:56.033
where you have a community
that has their own language.

00:49:56.033 --> 00:49:57.934
You know, people in a company
throwing around

00:49:57.934 --> 00:49:59.667
their own set of TLAs,

00:49:59.667 --> 00:50:02.567
or two doctors
throwing around medical terms,

00:50:02.567 --> 00:50:06.000
or two of somebody else
throwing something else around.

00:50:06.000 --> 00:50:09.534
How does the, uh, lang--
the natural language cope

00:50:09.534 --> 00:50:11.400
with essentially communities

00:50:11.400 --> 00:50:15.234
with--with divergent
vocabularies?

00:50:15.234 --> 00:50:17.100
Whitelaw: So that's--
that's a really good question.

00:50:17.100 --> 00:50:18.868
Um, and there are a couple
of variants on that.

00:50:18.868 --> 00:50:20.167
Your people also discuss,
you know,

00:50:20.167 --> 00:50:22.567
things like the, uh,
di--regional variance.

00:50:22.567 --> 00:50:24.033
You know, uh,
British and American English

00:50:24.033 --> 00:50:25.200
and so on.

00:50:25.200 --> 00:50:28.834
Um, so I think the--
we have one generous--

00:50:28.834 --> 00:50:30.267
and so as I said, we're--
we're learning from the web.

00:50:30.267 --> 00:50:31.868
So we're very up-to-date
with the, you know,

00:50:31.868 --> 00:50:33.567
the kinds of words
that we know about.

00:50:33.567 --> 00:50:35.234
Um, that means that,
you know,

00:50:35.234 --> 00:50:37.734
we can correct--
correct LOL Speak quite well.

00:50:37.734 --> 00:50:40.167
Um, uh, but it doesn't help us
with, you know,

00:50:40.167 --> 00:50:41.667
organizational jargon.

00:50:41.667 --> 00:50:43.901
Um, there's the user
personalization

00:50:43.901 --> 00:50:45.067
that I talked about

00:50:45.067 --> 00:50:46.901
is one avenue
that you can attack that by

00:50:46.901 --> 00:50:48.968
where you can do
per user models.

00:50:48.968 --> 00:50:51.334
Um, it's not--
but it's not as efficient

00:50:51.334 --> 00:50:54.300
as if you could have
a domain-wide,

00:50:54.300 --> 00:50:55.601
you know,
corporation-wide model.

00:50:55.601 --> 00:50:56.801
Um, and I think that,
you know,

00:50:56.801 --> 00:50:58.868
together, the kind of,
uh, Google Apps field

00:50:58.868 --> 00:51:01.300
domain model, you know,

00:51:01.300 --> 00:51:03.033
where we, uh, already know
about, you know,

00:51:03.033 --> 00:51:05.100
the--the organizational
structure and so on

00:51:05.100 --> 00:51:07.801
and you know about the--
the domain of accounts,

00:51:07.801 --> 00:51:09.467
um, that that's a really
exciting way to do.

00:51:09.467 --> 00:51:12.300
So you--if you start--
talking about particular TLAs,

00:51:12.300 --> 00:51:14.400
Spelly will stop flagging them

00:51:14.400 --> 00:51:17.434
as mistakes for everybody
in the company.

00:51:17.434 --> 00:51:20.200
man: Thank you.

00:51:20.200 --> 00:51:22.767
man: Uh, yeah,
so one question is,

00:51:22.767 --> 00:51:25.033
um, like, to--

00:51:25.033 --> 00:51:29.167
uh, whether the sort
of Operational Transform

00:51:29.167 --> 00:51:33.267
magic stuff is available
in the form of white papers

00:51:33.267 --> 00:51:34.968
or source code
that might be available

00:51:34.968 --> 00:51:36.934
to other just random people
trying to do--

00:51:36.934 --> 00:51:39.000
Wang: I'm glad you asked
that exact question

00:51:39.000 --> 00:51:42.400
because if you go to,
I believe, Waveprotocols.org...

00:51:42.400 --> 00:51:44.334
Whitelaw: Yeah, Wave--
Waveprotocol.org.

00:51:44.334 --> 00:51:46.534
Wang: Waveprotocol.org,
there's actually white papers

00:51:46.534 --> 00:51:48.334
for OT available right now.

00:51:48.334 --> 00:51:50.834
And, um, it also has,

00:51:50.834 --> 00:51:52.901
um, the actual federation
protocol as well

00:51:52.901 --> 00:51:55.100
if you're interested
in working with Wave.

00:51:55.100 --> 00:51:56.267
Um, what was
the other question?

00:51:56.267 --> 00:51:57.534
I think you had two.

00:51:57.534 --> 00:51:59.300
man: Okay, so the other question
sort of relates

00:51:59.300 --> 00:52:00.634
to the source code thing,

00:52:00.634 --> 00:52:02.300
which is just
the really pragmatic one

00:52:02.300 --> 00:52:04.133
of if you're using Wave
and you're sending

00:52:04.133 --> 00:52:05.801
source code around,

00:52:05.801 --> 00:52:08.968
it's going to start flagging
all kinds of words

00:52:08.968 --> 00:52:10.300
as being misspellings.

00:52:10.300 --> 00:52:12.467
How do you tell Spelly
to ignore parts

00:52:12.467 --> 00:52:13.901
of the document, say?

00:52:13.901 --> 00:52:15.267
Whitelaw: Yeah,
so--so I mentioned,

00:52:15.267 --> 00:52:16.534
uh, you know,
like a language ID agent

00:52:16.534 --> 00:52:18.634
as part of the system
that we have already.

00:52:18.634 --> 00:52:20.300
Um, so that's a way
that we can automatically try

00:52:20.300 --> 00:52:21.467
and detect those differences.

00:52:21.467 --> 00:52:23.667
But we will have, um,
uh, manual overrides

00:52:23.667 --> 00:52:25.868
where you can eventually--
essentially flag off

00:52:25.868 --> 00:52:27.667
areas of a text and,
you know,

00:52:27.667 --> 00:52:29.200
say, "No, Spelly,
don't come in here.

00:52:29.200 --> 00:52:31.000
"Don't--don't correct my,
you know,

00:52:31.000 --> 00:52:34.100
Is to Js in my, uh,
my folders."

00:52:34.100 --> 00:52:35.501
Danilatos: Can I just add
to that?

00:52:35.501 --> 00:52:37.767
Um, as I--
as I mentioned earlier,

00:52:37.767 --> 00:52:40.067
the--the interpretation
of those annotations

00:52:40.067 --> 00:52:41.601
is up to the client.

00:52:41.601 --> 00:52:44.300
So you could easily
have your client just ignore

00:52:44.300 --> 00:52:47.300
spelling errors,
um, in the document

00:52:47.300 --> 00:52:50.000
or in regions of the document
that you choose.

00:52:53.734 --> 00:52:55.968
man: Is there any plans
to expose APIs

00:52:55.968 --> 00:52:58.701
for things like Polly
so that outside of Wave,

00:52:58.701 --> 00:52:59.968
you can use these services

00:52:59.968 --> 00:53:01.801
for doing
really intelligent spelling

00:53:01.801 --> 00:53:05.033
based on your wonderful Google
data set?

00:53:05.033 --> 00:53:07.701
Whitelaw: Um, I'd say,
uh, you know,

00:53:07.701 --> 00:53:09.234
we--we love exposing APIs.

00:53:09.234 --> 00:53:10.868
I don't have anything
particular to say.

00:53:10.868 --> 00:53:12.334
But, um, you know,
obviously,

00:53:12.334 --> 00:53:13.834
better spelling
is not something

00:53:13.834 --> 00:53:15.434
that we only need in Wave.

00:53:15.434 --> 00:53:20.934
You know, there's lots of other
applications for it as well.

00:53:20.934 --> 00:53:22.634
man: So, uh,
another major problem

00:53:22.634 --> 00:53:25.601
with collaboration
and--and email and identity,

00:53:25.601 --> 00:53:27.033
yeah, well, is identity.

00:53:27.033 --> 00:53:29.434
And from what I've heard,
the only thing I see

00:53:29.434 --> 00:53:32.434
is kind of email-like strings
out there.

00:53:32.434 --> 00:53:34.901
You know, phishing is probably
the biggest problem

00:53:34.901 --> 00:53:36.234
with email these days.

00:53:36.234 --> 00:53:39.667
Uh, you're doing
a federated model here.

00:53:39.667 --> 00:53:42.167
I--can you wade,
uh, quite a ways more

00:53:42.167 --> 00:53:45.467
into your security vision
on authentication

00:53:45.467 --> 00:53:48.200
and how do I know
that Bill Gates

00:53:48.200 --> 00:53:51.100
didn't actually write that flame
about, you know, whatever?

00:53:51.100 --> 00:53:52.467
Whitelaw: Do you want
to take that, Dave?

00:53:52.467 --> 00:53:53.701
Wang: Yeah.

00:53:53.701 --> 00:53:57.067
So, um, if you do go
to, um, Waveprotocol.org,

00:53:57.067 --> 00:53:58.834
there's a white paper
exactly addressing

00:53:58.834 --> 00:54:00.667
this particular question.

00:54:00.667 --> 00:54:03.067
Um, so once you federate,

00:54:03.067 --> 00:54:06.667
operations that gets exchanged
between service providers

00:54:06.667 --> 00:54:07.801
do get signed.

00:54:07.801 --> 00:54:10.634
And even if you propagate
the operation

00:54:10.634 --> 00:54:13.067
across service providers,

00:54:13.067 --> 00:54:16.667
um, you can still verify
it came from a specific source.

00:54:16.667 --> 00:54:20.901
So, um, so in a sense,
you--you can--

00:54:20.901 --> 00:54:24.200
you're protected in some way
to know who you want to allow

00:54:24.200 --> 00:54:25.434
into your system

00:54:25.434 --> 00:54:27.234
and who you don't want to allow
in the system.

00:54:27.234 --> 00:54:29.300
And it's completely up to you,
the service provider,

00:54:29.300 --> 00:54:31.634
to provide the protection
if you want to.

00:54:31.634 --> 00:54:32.901
Whitelaw: I should add
that in the--

00:54:32.901 --> 00:54:34.534
in the short term
for Wavesandbox.com,

00:54:34.534 --> 00:54:37.000
so the--the initial, you know,
release to developers,

00:54:37.000 --> 00:54:39.100
accounts will be white listed.

00:54:39.100 --> 00:54:42.868
Uh, so you'll add acc--
contacts explicitly.

00:54:42.868 --> 00:54:44.133
So, but, yeah,

00:54:44.133 --> 00:54:46.801
where--you should
check out a white paper.

00:54:46.801 --> 00:54:49.267
man: So example,
is there any registry

00:54:49.267 --> 00:54:50.767
of domain names

00:54:50.767 --> 00:54:54.000
and which, uh,
federation providers

00:54:54.000 --> 00:54:56.334
get to claim
a domain name?

00:54:56.334 --> 00:54:58.634
Is it just their own
or, you know?

00:54:58.634 --> 00:55:00.567
Whitelaw: Yeah, I think
it's really early--early days.

00:55:00.567 --> 00:55:02.267
Wang: I think it's still
very early in the stage.

00:55:02.267 --> 00:55:04.300
So, um, best to start off
with white papers.

00:55:04.300 --> 00:55:06.634
And there are questions,
um, feel free to email us

00:55:06.634 --> 00:55:08.601
and we can work
through that.

00:55:08.601 --> 00:55:12.100
Whitelaw: Send us a Wave.
Wang: [laughs]

00:55:12.100 --> 00:55:16.901
man: So you've got these
really giant language models

00:55:16.901 --> 00:55:18.634
for the spelling thing,
right?

00:55:18.634 --> 00:55:20.601
And so, I mean,
for English,

00:55:20.601 --> 00:55:22.367
you're just crawling the web
and that's huge.

00:55:22.367 --> 00:55:24.100
And maybe for Chinese,
you might get a lot.

00:55:24.100 --> 00:55:26.000
Maybe for Korean,
you might get a lot.

00:55:26.000 --> 00:55:28.701
What are the roadblocks
to onboarding,

00:55:28.701 --> 00:55:30.968
you know, small,
third world country languages

00:55:30.968 --> 00:55:33.167
in places where we're really
trying to get people

00:55:33.167 --> 00:55:35.167
onto the internet,
onto all the new technology?

00:55:35.167 --> 00:55:37.200
But you're not going to find
eight billion web pages

00:55:37.200 --> 00:55:38.667
in [indistinct]?

00:55:38.667 --> 00:55:40.234
Right?
You're going to find two.

00:55:40.234 --> 00:55:42.367
Whitelaw: So that's a--that's
a really fantastic question.

00:55:42.367 --> 00:55:43.601
And I'm really glad
you asked that

00:55:43.601 --> 00:55:45.300
because, you know,
the Wave isn't just

00:55:45.300 --> 00:55:46.834
for first world countries

00:55:46.834 --> 00:55:48.868
where we've already got plenty
of content out there, right?

00:55:48.868 --> 00:55:50.334
Um, so to be fair,

00:55:50.334 --> 00:55:51.834
I don't think that better
spelling correction

00:55:51.834 --> 00:55:53.367
isn't what's keeping
third world countries

00:55:53.367 --> 00:55:54.434
off the web.

00:55:54.434 --> 00:55:57.033
man: No. Sure.
[laughter and applause]

00:55:57.033 --> 00:56:00.033
Whitelaw: So, um, uh,
you know,

00:56:00.033 --> 00:56:03.367
what--what I would love
is, uh, so we're using the web

00:56:03.367 --> 00:56:05.467
because we don't have
a better understanding so far

00:56:05.467 --> 00:56:07.067
of the way that people
actually communicate

00:56:07.067 --> 00:56:08.367
with one another.

00:56:08.367 --> 00:56:11.067
Um, for whatever communities
start communic--

00:56:11.067 --> 00:56:13.501
start communicating
with each other in Wave,

00:56:13.501 --> 00:56:15.634
um, we can learn explicitly
from that

00:56:15.634 --> 00:56:17.801
rather than from the web
as a whole.

00:56:17.801 --> 00:56:21.934
I'd be happy to follow up
with you after this too.

00:56:21.934 --> 00:56:24.400
man: Do you provide
the integration possibility

00:56:24.400 --> 00:56:25.834
with third party system--

00:56:25.834 --> 00:56:27.601
uh, third party
account systems

00:56:27.601 --> 00:56:30.334
or would you have to, uh,
roll your own Wave server

00:56:30.334 --> 00:56:34.434
in order to, uh,
use third party accounts?

00:56:34.434 --> 00:56:36.701
Wang: Um, um, let me--
let me try--

00:56:36.701 --> 00:56:38.267
I don't completely understand
the question,

00:56:38.267 --> 00:56:39.767
but let me get a stab at it.

00:56:39.767 --> 00:56:42.434
You mean third party
email systems like, um...

00:56:42.434 --> 00:56:44.501
Whitelaw: I--I've used
everything else on my site

00:56:44.501 --> 00:56:47.801
and I-I want to be able
to use Wave

00:56:47.801 --> 00:56:51.067
without making my users,
uh, have Google accounts.

00:56:51.067 --> 00:56:52.200
Wang: Right.

00:56:52.200 --> 00:56:54.067
So, um, so I guess
there's many ways

00:56:54.067 --> 00:56:57.300
you can, uh,
solve this problem.

00:56:57.300 --> 00:57:00.567
Uh, one problem
is run your own Wave server.

00:57:00.567 --> 00:57:03.100
I mean, that's, uh,
a bit hard, I think.

00:57:03.100 --> 00:57:06.701
But much easier thing to do
is, perhaps, to go to robot.

00:57:06.701 --> 00:57:09.667
Um, if you've been
to Gary's talk previously,

00:57:09.667 --> 00:57:11.300
um, I think there's
a very nice API already

00:57:11.300 --> 00:57:12.601
for building robots.

00:57:12.601 --> 00:57:14.367
I think it's very easy path

00:57:14.367 --> 00:57:17.200
to enter into that sort
of messaging service

00:57:17.200 --> 00:57:18.934
if you wanted to do that.

00:57:18.934 --> 00:57:21.267
Does that answer
your question?

00:57:21.267 --> 00:57:25.968
man: Um, so building a robot
can, um--

00:57:25.968 --> 00:57:29.167
So--but you don't require
somebody to have an account

00:57:29.167 --> 00:57:32.200
in the system
to send a message?

00:57:32.200 --> 00:57:33.801
Whitelaw: Sure please.
Wang: Yeah, sure.

00:57:33.801 --> 00:57:34.934
Hannon:
'Cause I'm not miked up,

00:57:34.934 --> 00:57:36.200
I just thought I'd stand
over here.

00:57:36.200 --> 00:57:37.868
Today, I think his question
was about logging in

00:57:37.868 --> 00:57:39.901
and whether people required
Google accounts.

00:57:39.901 --> 00:57:41.767
Today for this early
developer preview

00:57:41.767 --> 00:57:44.567
and probably for a little while,
it is a Google account.

00:57:44.567 --> 00:57:46.334
Um, so you--you--
probably a lot of people

00:57:46.334 --> 00:57:47.834
in this room
already have Google accounts.

00:57:47.834 --> 00:57:49.601
You can use that
to get into Wave.

00:57:49.601 --> 00:57:51.133
In the end,
we'd like to integrate

00:57:51.133 --> 00:57:52.467
with something
like Friend Connect

00:57:52.467 --> 00:57:54.334
and let people use different
authentication systems

00:57:54.334 --> 00:57:55.634
to get to Wave.

00:57:55.634 --> 00:57:56.968
So we'd like to get there,

00:57:56.968 --> 00:58:00.534
but, um, we're not quite
there yet.

00:58:00.534 --> 00:58:02.534
Whitelaw: Thanks.
That was our PM.

00:58:04.400 --> 00:58:06.901
Uh, yes.
man: Just a simple request.

00:58:06.901 --> 00:58:08.501
Is there any chance
of turning on Spelly

00:58:08.501 --> 00:58:10.167
for YouTube comments?

00:58:10.167 --> 00:58:12.801
[laughter]

00:58:12.801 --> 00:58:15.767
[scattered applause]

00:58:15.767 --> 00:58:17.067
man: No, seriously,
a question,

00:58:17.067 --> 00:58:19.267
uh, about the simple,
uh, features,

00:58:19.267 --> 00:58:21.200
uh, that we do have
in email accounts

00:58:21.200 --> 00:58:25.834
like, uh, distribution lists
and CC and BCC lines.

00:58:25.834 --> 00:58:30.634
And what about,
uh, spam prevention?

00:58:30.634 --> 00:58:33.534
Whitelaw: So--so notions
like CC and BCC

00:58:33.534 --> 00:58:36.133
don't really apply
directly to the Wave model.

00:58:36.133 --> 00:58:37.934
You know, we have
a different kind

00:58:37.934 --> 00:58:39.868
of participation model
as you might have heard already

00:58:39.868 --> 00:58:41.133
in Dell's talk.

00:58:41.133 --> 00:58:43.567
Uh, so we definitely
support groups.

00:58:43.567 --> 00:58:45.767
Um, and I hope
that you'll get to see

00:58:45.767 --> 00:58:47.501
a lot more about groups
in the future.

00:58:47.501 --> 00:58:48.767
We'll--we'll talk
about them more.

00:58:48.767 --> 00:58:49.868
You know,
we already have groups

00:58:49.868 --> 00:58:50.934
implemented now.

00:58:50.934 --> 00:58:52.667
Groups are a really
powerful way

00:58:52.667 --> 00:58:54.901
of managing things like
distribution lists and so on.

00:58:54.901 --> 00:58:56.133
There's a lot
of groups features

00:58:56.133 --> 00:58:57.667
that we're working on.

00:58:57.667 --> 00:58:59.501
Uh, again,
this is something--

00:58:59.501 --> 00:59:01.534
I think you'll hear
a lot more about this

00:59:01.534 --> 00:59:05.534
in the near future.

00:59:05.534 --> 00:59:08.501
man: So now you have
only one server for now.

00:59:08.501 --> 00:59:11.767
But later, you will allow
people from different servers

00:59:11.767 --> 00:59:13.167
to communicate with them?

00:59:13.167 --> 00:59:14.501
Wang: That's correct.

00:59:14.501 --> 00:59:17.067
So--so it is--we're still
a work in progress.

00:59:17.067 --> 00:59:20.801
So with this, uh, federation,
um, process, uh, protocol,

00:59:20.801 --> 00:59:23.133
you can actually have
very different servers

00:59:23.133 --> 00:59:25.434
that's run by completely
different organizations

00:59:25.434 --> 00:59:27.634
that essentially communicate
with each other.

00:59:27.634 --> 00:59:30.601
And more--more importantly
with this federation protocol,

00:59:30.601 --> 00:59:32.701
information don't get leaked
between organizations

00:59:32.701 --> 00:59:34.467
if you don't want them
to be.

00:59:34.467 --> 00:59:35.934
man: Your open source
implementation

00:59:35.934 --> 00:59:37.734
that at some point
you will release,

00:59:37.734 --> 00:59:41.467
will it work on a servlet Tomcat
bare bone or do I have to have--

00:59:41.467 --> 00:59:43.033
Wang: Yes. Yes.

00:59:43.033 --> 00:59:47.033
So, uh, we--we do plan
to release, um, source code

00:59:47.033 --> 00:59:48.767
in some form or another
that will help everyone

00:59:48.767 --> 00:59:50.033
get started.

00:59:50.033 --> 00:59:51.601
man: On the ser--
on the server side, yes?

00:59:51.601 --> 00:59:52.767
Wang:
On the server side, yes.

00:59:52.767 --> 00:59:54.234
man: And then I can start it
on my Tomcat

00:59:54.234 --> 00:59:57.901
and then--but you--you will have
all your magic there.

00:59:57.901 --> 01:00:00.634
Wang: [laughs].
It's going to be magic.

01:00:00.634 --> 01:00:02.367
Yes. It's going to be released
in some form.

01:00:02.367 --> 01:00:03.701
We're--we--
still work in progress.

01:00:03.701 --> 01:00:05.501
We don't know what kind
of form we're releasing,

01:00:05.501 --> 01:00:07.033
but eventually
we will release something.

01:00:07.033 --> 01:00:08.300
man: Okay. Thanks.

01:00:08.300 --> 01:00:09.834
Hannon: Sorry,
I'm going to be interrupting,

01:00:09.834 --> 01:00:11.334
like, and just say
that we have office hours

01:00:11.334 --> 01:00:12.434
going on still.

01:00:12.434 --> 01:00:14.033
So there's a Wave office hour
earlier.

01:00:14.033 --> 01:00:15.367
If you want to talk
about federation,

01:00:15.367 --> 01:00:16.868
if you want to talk
about the APIs,

01:00:16.868 --> 01:00:18.701
it's just out the door
and around the corner.

01:00:18.701 --> 01:00:20.634
There's lots of people
from the Wave team there.

01:00:20.634 --> 01:00:22.367
And we're really, really
excited to talk to you.

01:00:22.367 --> 01:00:24.167
Whitelaw: Um, and that's
a great way to wrap this up.

01:00:24.167 --> 01:00:26.000
We're out of time.
So thank you very much.

01:00:26.000 --> 01:00:28.934
[applause]

