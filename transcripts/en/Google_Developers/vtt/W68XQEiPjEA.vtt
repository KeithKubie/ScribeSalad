WEBVTT
Kind: captions
Language: en

00:00:01.133 --> 00:00:02.968
Mawson: So welcome, everybody,
to Google I/O.

00:00:02.968 --> 00:00:04.901
First session of the morning.

00:00:04.901 --> 00:00:06.300
My name is Sven Mawson.

00:00:06.300 --> 00:00:07.801
I'm gonna be
talking to you about

00:00:07.801 --> 00:00:10.133
some of the new stuff
we've been working on,

00:00:10.133 --> 00:00:11.834
the Google Data Protocol.

00:00:11.834 --> 00:00:15.501
I'm a member of
the Google Data APIs team.

00:00:15.501 --> 00:00:17.534
So the thing
we're concerned with today

00:00:17.534 --> 00:00:20.901
is how to build
more efficient applications.

00:00:20.901 --> 00:00:23.234
How many of you guys
are familiar, first of all,

00:00:23.234 --> 00:00:25.901
with the Google Data APIs
and have used them?

00:00:25.901 --> 00:00:28.501
So a fair number, okay.

00:00:28.501 --> 00:00:30.100
For those you that haven't,

00:00:30.100 --> 00:00:31.534
I'm gonna give
a quick background.

00:00:31.534 --> 00:00:34.033
The Google Data APIs
are a set of APIs

00:00:34.033 --> 00:00:36.133
that are based
on some common standards

00:00:36.133 --> 00:00:37.667
like AtomPub,

00:00:37.667 --> 00:00:40.734
Atom Publishing Protocol
and Atom.

00:00:40.734 --> 00:00:42.300
And then RSS,
we also support.

00:00:42.300 --> 00:00:45.868
And we support some JSON.

00:00:45.868 --> 00:00:48.234
This set of APIs is supported

00:00:48.234 --> 00:00:50.234
by many, many Google services,

00:00:50.234 --> 00:00:54.067
including YouTube,
Picasa Web Albums,

00:00:54.067 --> 00:00:56.901
Calendar, Docs,
et cetera.

00:00:56.901 --> 00:00:58.667
There's many, many of them.

00:00:58.667 --> 00:01:00.133
You can find
the whole list at

00:01:00.133 --> 00:01:03.634
code.google.com/apis/gdata.

00:01:03.634 --> 00:01:06.467
So for more information
on that.

00:01:06.467 --> 00:01:09.901
So the sort of
starter question is:

00:01:09.901 --> 00:01:11.634
what kind of applications
are we talking about

00:01:11.634 --> 00:01:13.734
that we're worried
about efficiency?

00:01:13.734 --> 00:01:15.767
Well, of course the answer
is every application

00:01:15.767 --> 00:01:17.701
should be worried
about efficiency, right?

00:01:17.701 --> 00:01:19.167
Everything costs money,

00:01:19.167 --> 00:01:20.667
so the faster
the application is,

00:01:20.667 --> 00:01:23.033
the more users you'll get,

00:01:23.033 --> 00:01:25.100
the more your users
will be happy,

00:01:25.100 --> 00:01:26.834
you know, the more money
you'll save on bandwidth.

00:01:26.834 --> 00:01:28.067
All kinds of stuff.

00:01:28.067 --> 00:01:30.634
So within that,
there actually are

00:01:30.634 --> 00:01:31.968
some sets of applications

00:01:31.968 --> 00:01:33.434
that this matters
even more than others.

00:01:33.434 --> 00:01:35.033
For example,
mobile applications

00:01:35.033 --> 00:01:36.968
really, really need efficiency

00:01:36.968 --> 00:01:39.634
because they're limited
by their bandwidth,

00:01:39.634 --> 00:01:41.133
they're limited by latency,

00:01:41.133 --> 00:01:43.234
they're limited by the memory
on the client.

00:01:43.234 --> 00:01:45.100
So everything
really matters there.

00:01:45.100 --> 00:01:46.701
And AJAX applications
in general

00:01:46.701 --> 00:01:48.934
are also very sensitive
to efficiency.

00:01:48.934 --> 00:01:52.000
So what kind of things
can we do

00:01:52.000 --> 00:01:53.667
to make them more efficient?

00:01:53.667 --> 00:01:55.167
The first thing we can do,
of course,

00:01:55.167 --> 00:01:56.901
is to reduce
the number of requests.

00:01:56.901 --> 00:02:00.567
So the less round trips
you make to the server,

00:02:00.567 --> 00:02:02.634
the faster your application's
gonna be.

00:02:02.634 --> 00:02:05.434
Another thing you can do
is to reduce the bandwidth.

00:02:05.434 --> 00:02:11.000
The less wire size
your requests are taking,

00:02:11.000 --> 00:02:13.534
the quicker the server
will be able to respond,

00:02:13.534 --> 00:02:15.300
the quicker your application
will work,

00:02:15.300 --> 00:02:17.834
the less money your users
will spend on bandwidth,

00:02:17.834 --> 00:02:19.534
if they're mobile users

00:02:19.534 --> 00:02:21.334
and they actually pay
for bandwidth,

00:02:21.334 --> 00:02:23.534
and the less money
you'll pay for bandwidth

00:02:23.534 --> 00:02:25.234
if you're using,
for example, App Engine,

00:02:25.234 --> 00:02:26.434
and you pay by bandwidth.

00:02:26.434 --> 00:02:27.934
So bandwidth
is very important.

00:02:27.934 --> 00:02:29.767
And of course latency
is also very important.

00:02:29.767 --> 00:02:32.634
So reducing the amount of time
between making a request

00:02:32.634 --> 00:02:34.300
and getting a response back.

00:02:34.300 --> 00:02:35.901
Any way you can reduce that,

00:02:35.901 --> 00:02:38.501
your users will be happy,
and you'll be happy.

00:02:38.501 --> 00:02:41.801
Okay, so I'm gonna show
a quick little demo

00:02:41.801 --> 00:02:44.167
of something I built called
Photo Shuffle.

00:02:44.167 --> 00:02:47.100
It's a very, very simple
App Engine app

00:02:47.100 --> 00:02:49.501
on photoshuffle.appspot.com

00:02:49.501 --> 00:02:51.033
if you want to look at it.

00:02:51.033 --> 00:02:52.734
The source is actually
just an HTML page.

00:02:52.734 --> 00:02:54.000
So if you want
to get the source,

00:02:54.000 --> 00:02:56.033
just go to it and view source,
and there it is.

00:02:56.033 --> 00:02:57.400
It doesn't use
anything exciting,

00:02:57.400 --> 00:02:59.801
so here it is.

00:02:59.801 --> 00:03:01.300
It asks for a username

00:03:01.300 --> 00:03:03.567
in the Picasa Web Album
service.

00:03:03.567 --> 00:03:08.367
So I'm gonna use a username
I created for today.

00:03:08.367 --> 00:03:10.567
And click Load Albums,

00:03:10.567 --> 00:03:13.434
and it loads up all your albums
from Picasa Web Albums

00:03:13.434 --> 00:03:15.100
using the Google Data API.

00:03:15.100 --> 00:03:16.834
This is actually running--

00:03:16.834 --> 00:03:18.567
This version is running
using all the stuff

00:03:18.567 --> 00:03:20.434
I'm gonna talk about today.

00:03:20.434 --> 00:03:22.434
So it's actually pretty fast.

00:03:22.434 --> 00:03:24.267
If it was not running
with the stuff

00:03:24.267 --> 00:03:25.767
I'm talking about today,
it would be a bit slower.

00:03:25.767 --> 00:03:28.767
But for example, this
photos from Yosemite album

00:03:28.767 --> 00:03:31.367
is I think 500 photos.

00:03:31.367 --> 00:03:33.767
So you can see
it loaded all of these

00:03:33.767 --> 00:03:35.367
very, very quickly.

00:03:35.367 --> 00:03:36.934
And that's all because
of the stuff

00:03:36.934 --> 00:03:38.133
I'm gonna talk about today.

00:03:38.133 --> 00:03:40.400
So the application is called
Photo Shuffle

00:03:40.400 --> 00:03:43.000
because I added this button
that lets you shuffle.

00:03:43.000 --> 00:03:45.300
So it just
moves the photos around.

00:03:45.300 --> 00:03:46.634
Not very exciting,
but it's,

00:03:46.634 --> 00:03:48.133
you know, it's an AJAX app.

00:03:48.133 --> 00:03:49.834
It loads data using
the APIs.

00:03:49.834 --> 00:03:51.400
It does what
it's supposed to do.

00:03:51.400 --> 00:03:53.067
You know, you can load up
a different album.

00:03:53.067 --> 00:03:54.467
It'll shuffle those.

00:03:54.467 --> 00:03:55.801
This is from
the tour of California

00:03:55.801 --> 00:03:58.033
that was in the area
recently.

00:03:58.033 --> 00:04:03.634
Okay, so that's
the little demo application.

00:04:03.634 --> 00:04:06.033
Let's quickly take
a look back

00:04:06.033 --> 00:04:09.100
at sort of what
the Google Data APIs

00:04:09.100 --> 00:04:10.400
had before this.

00:04:10.400 --> 00:04:12.701
So how many of you guys
have used the JSON output

00:04:12.701 --> 00:04:15.767
of the Google Data APIs
that we have right now?

00:04:15.767 --> 00:04:17.868
So a fair number,
but, you know,

00:04:17.868 --> 00:04:20.100
maybe that was a sixth,
a seventh.

00:04:20.100 --> 00:04:21.400
Not too many.
Okay.

00:04:21.400 --> 00:04:23.067
So a quick background.

00:04:23.067 --> 00:04:24.968
The way we set up
our JSON output

00:04:24.968 --> 00:04:27.300
was as a direct translation
of the XML.

00:04:27.300 --> 00:04:29.634
So this is an XML to JSON

00:04:29.634 --> 00:04:32.467
back to XML
translation conversion.

00:04:32.467 --> 00:04:35.067
And the reason we did this
is for read-write support.

00:04:35.067 --> 00:04:39.167
So if you have
an Atom Publishing Protocol API

00:04:39.167 --> 00:04:40.767
like the Google Data APIs,

00:04:40.767 --> 00:04:43.100
you support full round-trips
of reading data,

00:04:43.100 --> 00:04:45.300
modifying it, and writing it
back to the server.

00:04:45.300 --> 00:04:48.067
Instead of having to support
parsing of the JSON,

00:04:48.067 --> 00:04:50.200
all we support
is outputting JSON,

00:04:50.200 --> 00:04:52.801
and then on the client
we can convert that JSON

00:04:52.801 --> 00:04:54.367
back to XML and send that
back to the server

00:04:54.367 --> 00:04:55.667
for an update.

00:04:55.667 --> 00:04:57.701
So that's why we did things
the way we did it.

00:04:57.701 --> 00:04:59.667
Although it's not that great.

00:04:59.667 --> 00:05:02.200
So here's an example
of a conversion.

00:05:02.200 --> 00:05:04.567
See the XML on the left,
the JSON on the right.

00:05:04.567 --> 00:05:06.834
It looks very, very similar.

00:05:06.834 --> 00:05:08.868
We just replaced things
around a little bit.

00:05:08.868 --> 00:05:10.400
You know,
there's the media content.

00:05:10.400 --> 00:05:12.067
It's easy to see
how you can convert

00:05:12.067 --> 00:05:13.601
back and forth
between them.

00:05:13.601 --> 00:05:16.501
So what we did
is any XML element,

00:05:16.501 --> 00:05:19.000
we just take and turn it
directly into a JSON object.

00:05:19.000 --> 00:05:21.200
So there are the elements.

00:05:21.200 --> 00:05:22.667
Every single one
is an object

00:05:22.667 --> 00:05:24.968
in our current JSON format.

00:05:24.968 --> 00:05:26.934
It's pretty inefficient.

00:05:26.934 --> 00:05:28.934
Attributes
are a little bit nicer.

00:05:28.934 --> 00:05:30.434
They're just JSON properties.

00:05:30.434 --> 00:05:31.968
So we have an attribute

00:05:31.968 --> 00:05:33.367
like the url,
the type, medium.

00:05:33.367 --> 00:05:35.534
Those are all translated
directly across.

00:05:35.534 --> 00:05:37.200
And then when you send it
off to the server,

00:05:37.200 --> 00:05:38.868
it's translated back
the other direction.

00:05:38.868 --> 00:05:40.834
So it's very simple.

00:05:40.834 --> 00:05:42.367
The other thing we had to do

00:05:42.367 --> 00:05:44.167
is because in XML you have--

00:05:44.167 --> 00:05:45.868
you have attributes
and you have elements,

00:05:45.868 --> 00:05:48.067
but the elements themselves
also have content.

00:05:48.067 --> 00:05:50.200
So elements can have content
and attributes

00:05:50.200 --> 00:05:52.133
and child elements,
although the combination

00:05:52.133 --> 00:05:53.434
isn't really supported.

00:05:53.434 --> 00:05:54.801
But so what we had to do

00:05:54.801 --> 00:05:56.334
is whenever you have
text content,

00:05:56.334 --> 00:05:58.534
we had to have
a special property called $t

00:05:58.534 --> 00:06:00.467
that stores
the text content then.

00:06:00.467 --> 00:06:03.300
So here's an example
of the media credit.

00:06:03.300 --> 00:06:04.968
The content of that element

00:06:04.968 --> 00:06:06.968
is a property
on the media credit object

00:06:06.968 --> 00:06:08.434
called $t.

00:06:08.434 --> 00:06:10.000
So it's a direct translation.

00:06:10.000 --> 00:06:12.033
It's about the same size.

00:06:12.033 --> 00:06:13.667
It's not that exciting.

00:06:13.667 --> 00:06:16.701
So this is what
that Photo Shuffle application

00:06:16.701 --> 00:06:19.100
looks like when you're
using that JSON.

00:06:19.100 --> 00:06:20.434
So that application
I just showed,

00:06:20.434 --> 00:06:22.667
this is the code from it.

00:06:22.667 --> 00:06:25.000
This is how you would load up
data using a script tag.

00:06:25.000 --> 00:06:26.501
So how many people
are familiar

00:06:26.501 --> 00:06:29.234
with using script tags
for loading data?

00:06:29.234 --> 00:06:33.067
Okay, so that's more than
have used our JSON.

00:06:33.067 --> 00:06:34.501
Anyway, this is what you do.

00:06:34.501 --> 00:06:36.934
You create a script tag.
You stick it in the head.

00:06:36.934 --> 00:06:40.334
You set the source of it
to your script source.

00:06:40.334 --> 00:06:42.033
In this case, we're using

00:06:42.033 --> 00:06:44.834
the Picasa Web Albums
data API

00:06:44.834 --> 00:06:47.667
with the username
that I typed into that box.

00:06:47.667 --> 00:06:50.734
And then I'm getting
the JSON alt format.

00:06:50.734 --> 00:06:52.701
And the callback
I just called "callback"

00:06:52.701 --> 00:06:54.133
for simplicity.

00:06:54.133 --> 00:06:55.968
So here's that callback.

00:06:55.968 --> 00:06:58.601
This is what--so what happens
is you load that script.

00:06:58.601 --> 00:07:00.167
It goes to the server,
gets the data.

00:07:00.167 --> 00:07:01.567
it comes back,

00:07:01.567 --> 00:07:03.868
And that callback gets called
with your data.

00:07:03.868 --> 00:07:06.067
So this callback
will get called with it.

00:07:06.067 --> 00:07:07.934
We have to pull out
the albums from it,

00:07:07.934 --> 00:07:10.567
which are in
data.feed.entry.

00:07:10.567 --> 00:07:11.834
We loop through those,

00:07:11.834 --> 00:07:13.734
and we call this method
addAlbum,

00:07:13.734 --> 00:07:15.567
which we see here.

00:07:15.567 --> 00:07:18.467
And here's where things
get kind of ugly.

00:07:18.467 --> 00:07:20.501
To get the ID of the album,

00:07:20.501 --> 00:07:24.033
we have to do
entry.gphoto$id.$t.

00:07:24.033 --> 00:07:28.400
So that that $ notation
that we saw earlier

00:07:28.400 --> 00:07:31.367
is actually for
XML namespace support.

00:07:31.367 --> 00:07:33.000
So we actually have--

00:07:33.000 --> 00:07:35.801
That gphoto is actually
an XML namespace alias,

00:07:35.801 --> 00:07:38.834
and we include in the response
the XML namespaces.

00:07:38.834 --> 00:07:40.601
And I'm gonna talk
about that a little bit more.

00:07:40.601 --> 00:07:43.300
But there's a couple
important things here.

00:07:43.300 --> 00:07:47.033
One is that to get
the feed link, which--

00:07:47.033 --> 00:07:49.167
So the way that
the API is structured,

00:07:49.167 --> 00:07:50.534
you get the albums.

00:07:50.534 --> 00:07:52.434
And then each entry
in that feed

00:07:52.434 --> 00:07:55.634
has a link to the list
of photos in that feed.

00:07:55.634 --> 00:07:57.000
So that's that link there.

00:07:57.000 --> 00:07:59.200
And it happens
to be the first link.

00:07:59.200 --> 00:08:01.167
But the actual
right way to do this

00:08:01.167 --> 00:08:02.534
would be to loop
through the links

00:08:02.534 --> 00:08:05.067
looking for the one
with the rel value of feed

00:08:05.067 --> 00:08:07.300
and pulling that one out
and getting its href.

00:08:07.300 --> 00:08:10.033
But this is a lot easier
just to do an array index.

00:08:10.033 --> 00:08:12.234
Of course it would break
if the server

00:08:12.234 --> 00:08:13.968
ever returned things
in a different order.

00:08:13.968 --> 00:08:15.968
But we know for a fact
that many people

00:08:15.968 --> 00:08:17.501
have applications
coded this way,

00:08:17.501 --> 00:08:19.033
so we actually
won't change the order.

00:08:19.033 --> 00:08:21.167
But it's really not ideal
to do things this way,

00:08:21.167 --> 00:08:23.534
and you probably shouldn't
if you were coding JSON.

00:08:23.534 --> 00:08:25.167
But today I'm gonna announce
a much better way

00:08:25.167 --> 00:08:27.834
to do this anyway, so...

00:08:27.834 --> 00:08:29.834
The other sort of
thing to notice

00:08:29.834 --> 00:08:34.100
is how long and ugly
that album thumbnail

00:08:34.100 --> 00:08:36.400
sort of dereferencing is.

00:08:36.400 --> 00:08:38.767
It's a media$group,
a media$thumbnail,

00:08:38.767 --> 00:08:40.100
which is an array,

00:08:40.100 --> 00:08:41.334
and then you have
to get the URL.

00:08:41.334 --> 00:08:43.634
It's just kind of a pain.

00:08:43.634 --> 00:08:45.534
So we need
to make this better.

00:08:45.534 --> 00:08:47.534
So let's quickly
just go over

00:08:47.534 --> 00:08:49.534
all of the reasons
why this isn't that great.

00:08:49.534 --> 00:08:52.400
The first problem is you're
creating way too many objects.

00:08:52.400 --> 00:08:54.100
This isn't as much
of a problem

00:08:54.100 --> 00:08:55.501
on some of the modern browsers,

00:08:55.501 --> 00:08:58.067
but older browsers
had huge problems

00:08:58.067 --> 00:08:59.801
if you created a lot
of JavaScript objects.

00:08:59.801 --> 00:09:01.200
So it's really good
to reduce those,

00:09:01.200 --> 00:09:03.067
and a lot of people
still use those.

00:09:03.067 --> 00:09:05.167
So we want to reduce that.

00:09:05.167 --> 00:09:06.501
And it's really
not that great

00:09:06.501 --> 00:09:08.067
that we're creating
all of these objects.

00:09:08.067 --> 00:09:09.400
So in this example,

00:09:09.400 --> 00:09:13.067
we have one, two, three, four,
five different objects.

00:09:13.067 --> 00:09:14.567
And some of them just--

00:09:14.567 --> 00:09:17.234
You know, the media credit,
all it has is a $t

00:09:17.234 --> 00:09:18.734
with a credit in there.

00:09:18.734 --> 00:09:20.701
It's not very exciting.
There's--

00:09:20.701 --> 00:09:22.267
You know, it doesn't look
like there should be

00:09:22.267 --> 00:09:24.367
a reason to actually do that,
but because we had to do

00:09:24.367 --> 00:09:26.868
a complete XML to JSON
and back again,

00:09:26.868 --> 00:09:28.400
that was necessitated.

00:09:28.400 --> 00:09:31.067
So another problem
is of course--

00:09:31.067 --> 00:09:32.567
I touched on this earlier--

00:09:32.567 --> 00:09:34.501
how ugly that programming was.

00:09:34.501 --> 00:09:36.667
So, you know,
here's getting the ID.

00:09:36.667 --> 00:09:39.234
Here's getting that image.
It's really not fun.

00:09:39.234 --> 00:09:41.767
The other big problem
is that we send a lot of stuff

00:09:41.767 --> 00:09:44.234
that really is
completely unnecessary.

00:09:44.234 --> 00:09:46.868
So this is actually the JSON

00:09:46.868 --> 00:09:50.167
even though we're sending things
that look like XML, right?

00:09:50.167 --> 00:09:52.167
So this is like
the XML version,

00:09:52.167 --> 00:09:54.167
XML encoding,
all the XML namespaces.

00:09:54.167 --> 00:09:55.501
Do you really
need that stuff?

00:09:55.501 --> 00:09:57.667
No, you don't,
but we send it anyway

00:09:57.667 --> 00:09:58.968
just because that's--

00:09:58.968 --> 00:10:00.968
you know,
it's a direct translation.

00:10:00.968 --> 00:10:04.133
So it just, in the end,
takes up way too much space.

00:10:04.133 --> 00:10:07.234
So here's the Atom and--

00:10:07.234 --> 00:10:08.901
the Atom compared
to the JSON,

00:10:08.901 --> 00:10:11.100
and you can see they're
actually exactly the same.

00:10:11.100 --> 00:10:12.901
One thing to note on this,

00:10:12.901 --> 00:10:14.701
if you're not using
gzip compression

00:10:14.701 --> 00:10:16.968
on your request to the server
you should be,

00:10:16.968 --> 00:10:19.467
because it's a factor
of about 20 there,

00:10:19.467 --> 00:10:21.334
that it makes it
much, much smaller.

00:10:21.334 --> 00:10:22.801
So first thing you should do,

00:10:22.801 --> 00:10:24.968
make sure you're getting gzip
to request responses.

00:10:24.968 --> 00:10:26.234
And if you're not,
find out why,

00:10:26.234 --> 00:10:27.901
because it's huge.

00:10:27.901 --> 00:10:30.033
But even when compressed,
they compress about the same.

00:10:30.033 --> 00:10:32.868
So there's really
no difference there.

00:10:32.868 --> 00:10:34.968
So we can do better
than that.

00:10:34.968 --> 00:10:36.634
So now I want
to introduce something

00:10:36.634 --> 00:10:38.868
called JSONC to you guys.

00:10:38.868 --> 00:10:43.167
And this is a clean, compact,
and customizable JSON format.

00:10:43.167 --> 00:10:45.367
So one of the goals
that we had

00:10:45.367 --> 00:10:47.934
was to minimize the number
of JavaScript objects

00:10:47.934 --> 00:10:50.300
to reduce that.

00:10:50.300 --> 00:10:52.167
And there's many ways
that we do that.

00:10:52.167 --> 00:10:54.734
One thing--We have sort of
a set of standard rules,

00:10:54.734 --> 00:10:56.300
and then we can customize
beyond that.

00:10:56.300 --> 00:10:57.968
But I'm gonna go over
the standard rules here.

00:10:57.968 --> 00:11:01.734
The first is for things that
are simple, single elements--

00:11:01.734 --> 00:11:03.234
and by that I mean an element

00:11:03.234 --> 00:11:04.667
that just
has a single attribute

00:11:04.667 --> 00:11:06.100
or that just
has text content

00:11:06.100 --> 00:11:08.300
and is not repeating--
there's only one of them.

00:11:08.300 --> 00:11:10.033
It's really easy
to translate that

00:11:10.033 --> 00:11:11.901
into something much better
than we were doing.

00:11:11.901 --> 00:11:14.167
So we were doing
the thing on the left there,

00:11:14.167 --> 00:11:16.701
which is to create an object
and have a $t.

00:11:16.701 --> 00:11:20.434
But why not just output it
directly as the credit

00:11:20.434 --> 00:11:21.767
with the name?

00:11:21.767 --> 00:11:23.200
I mean, much simpler.

00:11:23.200 --> 00:11:24.767
So that's what we're doing.

00:11:24.767 --> 00:11:26.567
And the reason
we can get away with this

00:11:26.567 --> 00:11:28.801
is that we know
on the server that

00:11:28.801 --> 00:11:31.033
that element will never
have additional attributes.

00:11:31.033 --> 00:11:33.167
It will never have
foreign elements under it.

00:11:33.167 --> 00:11:35.334
We know because we're
the ones writing the code

00:11:35.334 --> 00:11:37.567
what it's going to have
and what it's not going to have.

00:11:37.567 --> 00:11:39.067
So we can actually say,

00:11:39.067 --> 00:11:40.734
"Okay, we can output this
as a property."

00:11:40.734 --> 00:11:42.567
It's really simple.

00:11:42.567 --> 00:11:45.400
So we do that for those
simple, single elements.

00:11:45.400 --> 00:11:47.133
But what about
for complex elements,

00:11:47.133 --> 00:11:48.667
elements that have
maybe a couple attributes

00:11:48.667 --> 00:11:50.734
and a text content, right?

00:11:50.734 --> 00:11:54.334
So we can actually get rid of
the object there too.

00:11:54.334 --> 00:11:58.100
What we do is actually pull
the additional attributes up

00:11:58.100 --> 00:12:00.667
next to the property.

00:12:00.667 --> 00:12:02.934
So you have--Where before
you had a summary object

00:12:02.934 --> 00:12:05.601
with text
and a type attribute,

00:12:05.601 --> 00:12:08.667
now we have a summary
and a summary type.

00:12:08.667 --> 00:12:10.234
So it's very simple.

00:12:10.234 --> 00:12:11.767
It makes it much easier
to use.

00:12:11.767 --> 00:12:13.200
It gets rid of an object,

00:12:13.200 --> 00:12:14.634
and it saves space
on the wire.

00:12:14.634 --> 00:12:16.367
So it's pretty nice.

00:12:16.367 --> 00:12:18.033
Things get a little bit
more complicated

00:12:18.033 --> 00:12:19.801
when you start talking
about repeating elements,

00:12:19.801 --> 00:12:22.634
because in XML
when something repeats,

00:12:22.634 --> 00:12:24.400
you just see multiple of them.

00:12:24.400 --> 00:12:25.901
There's nothing exciting
there.

00:12:25.901 --> 00:12:27.400
In JSON
when something repeats,

00:12:27.400 --> 00:12:29.167
you have to actually wrap them
all in an array.

00:12:29.167 --> 00:12:30.434
So you have to know
ahead of time

00:12:30.434 --> 00:12:31.968
what is repeating
and what is not.

00:12:31.968 --> 00:12:33.300
But of course, again,
we're on the server.

00:12:33.300 --> 00:12:35.234
We know these things.

00:12:35.234 --> 00:12:37.834
We can make some things
a little bit nicer.

00:12:37.834 --> 00:12:40.434
So something like
this keywords element

00:12:40.434 --> 00:12:42.200
where it only
has text content,

00:12:42.200 --> 00:12:43.667
it doesn't have
anything else,

00:12:43.667 --> 00:12:45.801
we can just create
a simple array for you.

00:12:45.801 --> 00:12:48.400
So, you know, keywords,
Google, I/O,

00:12:48.400 --> 00:12:49.801
exactly like you'd expect.

00:12:49.801 --> 00:12:51.767
This is the kind of JSON
you probably want to use.

00:12:51.767 --> 00:12:53.701
Much nicer.

00:12:53.701 --> 00:12:56.300
What about when you have
complex repeating elements?

00:12:56.300 --> 00:12:59.267
So this is where things
fall apart in this model.

00:12:59.267 --> 00:13:01.133
You can't actually come up

00:13:01.133 --> 00:13:03.100
with any
standard set of rules

00:13:03.100 --> 00:13:05.801
where, you know,
you can automatically convert

00:13:05.801 --> 00:13:08.501
these complex
repeating elements

00:13:08.501 --> 00:13:10.367
into a nice JSON format.

00:13:10.367 --> 00:13:12.300
So here's where
the customization comes in.

00:13:12.300 --> 00:13:15.133
So for something
like the links element,

00:13:15.133 --> 00:13:17.501
we actually completely
customize the output.

00:13:17.501 --> 00:13:19.334
And this is what I was--
also what I was saying

00:13:19.334 --> 00:13:21.534
about how using
that array notation is bad,

00:13:21.534 --> 00:13:23.033
but we have something better.

00:13:23.033 --> 00:13:24.734
So before,
you had an array of links,

00:13:24.734 --> 00:13:27.300
and they each had
a bunch of attributes.

00:13:27.300 --> 00:13:28.968
They had the rel value,
which tells you,

00:13:28.968 --> 00:13:30.300
you know, the name of it.

00:13:30.300 --> 00:13:31.868
And then they had a type,
which tells you

00:13:31.868 --> 00:13:33.434
what the MIME type will be

00:13:33.434 --> 00:13:35.067
and then they actually
had the href.

00:13:35.067 --> 00:13:38.901
In this case, the edit link
on the feed we're looking at

00:13:38.901 --> 00:13:42.000
will always be of type
application/atom+xml.

00:13:42.000 --> 00:13:43.734
So actually
sending that to you

00:13:43.734 --> 00:13:44.968
is completely useless.

00:13:44.968 --> 00:13:46.167
We don't need to do that.

00:13:46.167 --> 00:13:47.601
So we can just
throw that away.

00:13:47.601 --> 00:13:49.834
And then the other thing
we can do is we can take

00:13:49.834 --> 00:13:51.901
that rel value and actually
make that the name of the link,

00:13:51.901 --> 00:13:55.467
rather than making there
be a property for that.

00:13:55.467 --> 00:13:58.400
And then the href, we used
the value of that property.

00:13:58.400 --> 00:14:00.334
So now we just have
a links object

00:14:00.334 --> 00:14:02.100
with edit equals whatever.

00:14:02.100 --> 00:14:04.133
And all of those other links
will show up

00:14:04.133 --> 00:14:05.801
as named properties.

00:14:05.801 --> 00:14:08.200
So to dereference it,
you just do links.edit,

00:14:08.200 --> 00:14:11.601
rather than find the link
with the rel value of edit

00:14:11.601 --> 00:14:13.167
and then get the href.

00:14:13.167 --> 00:14:14.567
So it's much nicer.

00:14:14.567 --> 00:14:17.467
And this is what we do for these
complex repeating elements.

00:14:17.467 --> 00:14:19.767
And actually, we customized
some other things too.

00:14:19.767 --> 00:14:21.534
So it's very customizable.

00:14:21.534 --> 00:14:23.501
Here's a complete example.

00:14:23.501 --> 00:14:25.734
You can see this is
the media group element

00:14:25.734 --> 00:14:27.234
within an entry.

00:14:27.234 --> 00:14:30.567
For example,
a Picasa Web Albums photo.

00:14:30.567 --> 00:14:32.834
You have that media group.

00:14:32.834 --> 00:14:34.834
It had a media content,
it had a media credit,

00:14:34.834 --> 00:14:36.067
media description.

00:14:36.067 --> 00:14:38.300
There were--
what did I say--

00:14:38.300 --> 00:14:39.534
five objects?

00:14:39.534 --> 00:14:41.000
Now there's just one object.

00:14:41.000 --> 00:14:42.601
It just has a bunch
of properties.

00:14:42.601 --> 00:14:44.868
You just do "entry.media.
whatever you want,"

00:14:44.868 --> 00:14:46.100
and it's there.

00:14:46.100 --> 00:14:48.200
Much nicer to use.

00:14:48.200 --> 00:14:50.534
The other thing we can do
is actually get rid of

00:14:50.534 --> 00:14:52.334
some more of that data
that wasn't useful.

00:14:52.334 --> 00:14:53.667
So I talked about
that edit link

00:14:53.667 --> 00:14:56.367
where the type was--
you know, we didn't need it.

00:14:56.367 --> 00:14:58.734
So we can do the same
kinda thing in other places.

00:14:58.734 --> 00:15:00.834
The content medium,
in this case, always image.

00:15:00.834 --> 00:15:02.067
Throw that away.

00:15:02.067 --> 00:15:03.801
A description type,
always plain.

00:15:03.801 --> 00:15:05.000
Throw it away.

00:15:05.000 --> 00:15:06.534
So we can make things
a lot easier.

00:15:06.534 --> 00:15:07.868
Now we're down
to four properties,

00:15:07.868 --> 00:15:09.234
one object.

00:15:09.234 --> 00:15:10.400
Really simple to use.

00:15:10.400 --> 00:15:13.567
Kind of what we want to do.

00:15:13.567 --> 00:15:15.934
All right, so let's
see this in action.

00:15:15.934 --> 00:15:18.434
Let's take a look
at that code that we had

00:15:18.434 --> 00:15:20.200
for the Photo Shuffle
application,

00:15:20.200 --> 00:15:23.167
and let's change it to use
this new JSON format.

00:15:23.167 --> 00:15:26.033
So all you do is change
from alt=json

00:15:26.033 --> 00:15:27.534
to alt=jsonc,

00:15:27.534 --> 00:15:29.167
and then you're gonna
get that back.

00:15:29.167 --> 00:15:31.601
Of course, the model
that you get back--

00:15:31.601 --> 00:15:33.100
Those JSON objects
have changed,

00:15:33.100 --> 00:15:35.501
so you have to go change
how you dereference that data.

00:15:35.501 --> 00:15:37.834
So when we get
the result back,

00:15:37.834 --> 00:15:39.767
rather than having
a wrapper element

00:15:39.767 --> 00:15:41.567
and then the feed
and then the entries,

00:15:41.567 --> 00:15:43.033
we got rid of that
wrapper element,

00:15:43.033 --> 00:15:45.434
so it's just a feed
and its entries.

00:15:45.434 --> 00:15:47.267
So rather than
data.feed.entry,

00:15:47.267 --> 00:15:48.667
you'd just do data--

00:15:48.667 --> 00:15:50.734
Well, you would do entry,
but we made it even nicer

00:15:50.734 --> 00:15:53.100
and we actually named it
based on what it is.

00:15:53.100 --> 00:15:54.667
It's albums.
So we named it albums.

00:15:54.667 --> 00:15:58.467
So you just do data.albums.

00:15:58.467 --> 00:16:01.334
The other thing that
gets into it a little bit more

00:16:01.334 --> 00:16:04.400
is when you're actually
processing those albums.

00:16:04.400 --> 00:16:06.234
As you can see
on the right there,

00:16:06.234 --> 00:16:07.968
all the things are much
nicer to look at.

00:16:07.968 --> 00:16:10.234
So before we had
the gphoto$id

00:16:10.234 --> 00:16:11.767
with the namespaces
and the $t.

00:16:11.767 --> 00:16:13.901
It's just entry.id.

00:16:13.901 --> 00:16:15.367
The links,
as I mentioned before,

00:16:15.367 --> 00:16:16.701
it's just links.feed.

00:16:16.701 --> 00:16:18.234
And then the thumbnails
is also simpler.

00:16:18.234 --> 00:16:21.167
It's media.thumbnails.

00:16:21.167 --> 00:16:25.934
So things have gotten
a lot nicer to use.

00:16:25.934 --> 00:16:28.367
And of course the bandwidth
has gone way down.

00:16:28.367 --> 00:16:30.901
So you can see
in the uncompressed case,

00:16:30.901 --> 00:16:32.534
the bandwidth's about half.

00:16:32.534 --> 00:16:35.734
In the compressed case,
it's about 2/3.

00:16:35.734 --> 00:16:39.100
And the uncompressed is actually
still important to look at,

00:16:39.100 --> 00:16:41.667
because that's the memory
that's gonna be used

00:16:41.667 --> 00:16:44.868
by the browser after
it decompresses the feed.

00:16:44.868 --> 00:16:46.501
So that's actually
what it's gonna--

00:16:46.501 --> 00:16:48.934
what the browser's gonna
be using for memory.

00:16:48.934 --> 00:16:51.000
So that's also important.

00:16:51.000 --> 00:16:52.634
It's good that we have
both of those going

00:16:52.634 --> 00:16:54.267
much, much smaller.

00:16:54.267 --> 00:16:56.000
Another thing we can look at
is the request time.

00:16:56.000 --> 00:16:58.501
So how long did the request
actually take?

00:16:58.501 --> 00:17:00.133
And this is actually
from my house

00:17:00.133 --> 00:17:01.834
with a really slow
internet connection.

00:17:01.834 --> 00:17:03.501
Not from here,
which you saw,

00:17:03.501 --> 00:17:05.334
you know,
it took on the order

00:17:05.334 --> 00:17:07.567
of maybe 600 milliseconds.

00:17:07.567 --> 00:17:09.567
At my house, it takes
four seconds with the JSON.

00:17:09.567 --> 00:17:14.601
With the JSONC,
it takes roughly 2 3/4 or so.

00:17:14.601 --> 00:17:17.067
So the request is faster,

00:17:17.067 --> 00:17:18.968
and the parsing time
is faster.

00:17:18.968 --> 00:17:20.467
This is in Firefox 3,

00:17:20.467 --> 00:17:22.033
which is actually
a pretty fast parser.

00:17:22.033 --> 00:17:24.801
But even in that, you can see
there's an improvement.

00:17:24.801 --> 00:17:26.167
On older browsers,

00:17:26.167 --> 00:17:27.901
which I didn't actually
get a chance to test--

00:17:27.901 --> 00:17:29.767
on something like IE 6
or Firefox 2,

00:17:29.767 --> 00:17:32.701
this would be
even more significant

00:17:32.701 --> 00:17:36.400
just 'cause they took
so much time to parse.

00:17:36.400 --> 00:17:39.267
Okay, so that was JSONC

00:17:39.267 --> 00:17:41.601
and how you'd use it
in the photo shuffler.

00:17:41.601 --> 00:17:43.100
And now I want to touch
on another thing

00:17:43.100 --> 00:17:46.334
we're introducing,
which we call Partial GET.

00:17:46.334 --> 00:17:48.934
So to understand this,

00:17:48.934 --> 00:17:50.601
first we have to go
into a little background

00:17:50.601 --> 00:17:52.767
on how REST does updates.

00:17:52.767 --> 00:17:55.501
So how updating an entry
works in REST

00:17:55.501 --> 00:17:57.801
to understand sort of
why things work

00:17:57.801 --> 00:17:59.133
they way they do right now

00:17:59.133 --> 00:18:01.133
and how we're
gonna change that.

00:18:01.133 --> 00:18:04.234
So right now
when you want to do

00:18:04.234 --> 00:18:05.901
a read, modify, write cycle,

00:18:05.901 --> 00:18:08.000
the first thing you have to do
is get that whole document.

00:18:08.000 --> 00:18:12.000
And in REST, each URL
represents a document.

00:18:12.000 --> 00:18:14.067
In our case,
they're entries.

00:18:14.067 --> 00:18:16.501
But you can think of it
as, you know,

00:18:16.501 --> 00:18:18.467
you're updating
an entire document at once.

00:18:18.467 --> 00:18:21.667
So you get the entry
you want to update.

00:18:21.667 --> 00:18:24.133
In this case,
we're going a GET

00:18:24.133 --> 00:18:26.033
on feeds/myfeed/myentry.

00:18:26.033 --> 00:18:27.667
The important things
to notice here

00:18:27.667 --> 00:18:29.968
are the edit link.

00:18:29.968 --> 00:18:32.234
So the edit link has

00:18:32.234 --> 00:18:34.534
an additional piece
of information appended to it,

00:18:34.534 --> 00:18:36.200
which is a version string.

00:18:36.200 --> 00:18:38.300
And that lets us do
optimistic and currency,

00:18:38.300 --> 00:18:39.601
which we'll see
in a second.

00:18:39.601 --> 00:18:41.567
But we need that--
We need to use that edit link

00:18:41.567 --> 00:18:43.334
when we're updating
the entry.

00:18:43.334 --> 00:18:44.968
And then it's gonna
have a title,

00:18:44.968 --> 00:18:46.567
and then it's gonna have
a bunch of other fields.

00:18:46.567 --> 00:18:48.000
And let's say
all we want to do

00:18:48.000 --> 00:18:49.467
is change the title.

00:18:49.467 --> 00:18:52.033
Unfortunately, we're operating
at the level of documents,

00:18:52.033 --> 00:18:53.667
not at the level of XML.

00:18:53.667 --> 00:18:55.701
So we actually need to save
all of that stuff,

00:18:55.701 --> 00:18:57.701
'cause we're sending entire
documents back and forth.

00:18:57.701 --> 00:18:59.601
We're not actually
just sending fields.

00:18:59.601 --> 00:19:01.868
So no matter what
that other junk is,

00:19:01.868 --> 00:19:05.534
we actually need to keep
track of it unfortunately.

00:19:05.534 --> 00:19:07.167
So then once
we have this data,

00:19:07.167 --> 00:19:08.567
we need to change the fields

00:19:08.567 --> 00:19:09.901
that we actually
want to modify.

00:19:09.901 --> 00:19:11.534
So let's say we just want
to change the title

00:19:11.534 --> 00:19:14.634
of the favorite picture,
leave everything else alone.

00:19:14.634 --> 00:19:16.567
Then we need to put that
back to the server

00:19:16.567 --> 00:19:18.434
using that edit link.

00:19:18.434 --> 00:19:20.734
So we do a PUT to that link.

00:19:20.734 --> 00:19:23.334
You can see that version string
at the end there

00:19:23.334 --> 00:19:26.100
with that new title and all
those other fields we had.

00:19:26.100 --> 00:19:29.968
We need to include
everything again.

00:19:29.968 --> 00:19:32.234
Now unfortunately,
sometimes someone else

00:19:32.234 --> 00:19:34.467
may have changed that element
at the same time--

00:19:34.467 --> 00:19:36.567
that entry at the same time
you were,

00:19:36.567 --> 00:19:39.801
which means the server will
return a 409 conflict.

00:19:39.801 --> 00:19:42.133
And it will be
a little bit nice

00:19:42.133 --> 00:19:43.601
and return
the new entry for you.

00:19:43.601 --> 00:19:45.067
It'll return
that new document.

00:19:45.067 --> 00:19:47.400
So you don't have to do a whole
read, modify, write again.

00:19:47.400 --> 00:19:49.334
You just do
the modify, write.

00:19:49.334 --> 00:19:50.934
But it's still
kind of a pain.

00:19:50.934 --> 00:19:53.033
You get that--
You see in this case

00:19:53.033 --> 00:19:54.667
the title actually
didn't change,

00:19:54.667 --> 00:19:56.334
and that was all
we cared about.

00:19:56.334 --> 00:19:57.634
We just wanted
to change the title.

00:19:57.634 --> 00:19:59.200
The title didn't change,
but we still need

00:19:59.200 --> 00:20:01.667
to go through this whole
conflict resolution.

00:20:01.667 --> 00:20:03.834
The edit link changed
because there's a new version

00:20:03.834 --> 00:20:05.434
and maybe the summary changed,

00:20:05.434 --> 00:20:07.000
but everything else
was the same.

00:20:07.000 --> 00:20:08.934
So it's kind of annoying
that we have to go through

00:20:08.934 --> 00:20:14.200
all this just to be able
to update a simple field

00:20:14.200 --> 00:20:16.033
And the reason
this actually matters

00:20:16.033 --> 00:20:18.100
in terms of GETs in general

00:20:18.100 --> 00:20:21.100
is all GETs
in the Google Data APIs

00:20:21.100 --> 00:20:23.000
need to support update.

00:20:23.000 --> 00:20:26.334
So you can't just ask for some
small subset of what you want.

00:20:26.334 --> 00:20:28.334
You have to ask
for the whole thing...

00:20:28.334 --> 00:20:30.000
until now.

00:20:30.000 --> 00:20:33.701
So we're introducing something
we call Partial GET.

00:20:33.701 --> 00:20:35.701
And you can't always
get what you want.

00:20:35.701 --> 00:20:39.467
But if you try sometimes,
you might get what you need.

00:20:39.467 --> 00:20:41.701
Okay, so what
a Partial GET does

00:20:41.701 --> 00:20:43.934
is it allows the clients
to actually ask for

00:20:43.934 --> 00:20:48.067
exactly what they want
and nothing else,

00:20:48.067 --> 00:20:50.067
which is the key part.

00:20:50.067 --> 00:20:52.534
So what we did is we added
a query parameter

00:20:52.534 --> 00:20:54.133
called the fields
query parameter

00:20:54.133 --> 00:20:56.000
that lets you say
exactly what you want.

00:20:56.000 --> 00:20:58.834
So in this first case,
you have a feed.

00:20:58.834 --> 00:21:02.667
You want the ID, title,
and entries in that feed.

00:21:02.667 --> 00:21:04.133
And in the second case--

00:21:04.133 --> 00:21:05.567
this is a request
for a particular entry,

00:21:05.567 --> 00:21:07.267
not a whole feed of entries--

00:21:07.267 --> 00:21:09.534
you just want the ID,
title, the media:group,

00:21:09.534 --> 00:21:10.934
and the georss:where.

00:21:10.934 --> 00:21:14.033
And this is actually a request
for the add on version

00:21:14.033 --> 00:21:16.467
of that entry in that feed.

00:21:16.467 --> 00:21:18.367
So those fields
are actually relative

00:21:18.367 --> 00:21:19.934
to the Atom names of things.

00:21:19.934 --> 00:21:21.934
So there's actually--
It's media:group

00:21:21.934 --> 00:21:24.133
because that's what
you'd be getting back

00:21:24.133 --> 00:21:25.567
as the name of that field.

00:21:25.567 --> 00:21:27.367
And we'll see when we look
at this for JSON,

00:21:27.367 --> 00:21:30.767
it actually uses
the JSON names.

00:21:30.767 --> 00:21:32.200
So but what if--

00:21:32.200 --> 00:21:34.667
What if you actually want
to specify, you know,

00:21:34.667 --> 00:21:36.601
that you only want
the IDs and title

00:21:36.601 --> 00:21:39.400
of those entries
within that feed?

00:21:39.400 --> 00:21:41.801
We allow you to use
a parenthetical notation

00:21:41.801 --> 00:21:43.501
to actually request that.

00:21:43.501 --> 00:21:46.634
So if you want
the entries in a feed,

00:21:46.634 --> 00:21:48.133
and you want just
the media:group,

00:21:48.133 --> 00:21:49.434
and in that media:group

00:21:49.434 --> 00:21:50.767
you just want
the media thumbnails,

00:21:50.767 --> 00:21:52.133
that's how you'd do it.

00:21:52.133 --> 00:21:56.067
You'd say entry(media:group
(media:thumbnail)).

00:21:56.067 --> 00:21:58.200
And this is only
element level selection,

00:21:58.200 --> 00:21:59.801
so there's no
attribute selection.

00:21:59.801 --> 00:22:01.934
All attributes
in anything you select

00:22:01.934 --> 00:22:03.367
will always come along.

00:22:03.367 --> 00:22:04.901
And this was actually
a simplification

00:22:04.901 --> 00:22:07.734
to make things
a lot easier.

00:22:07.734 --> 00:22:10.133
And it turns out that we have
so few attributes

00:22:10.133 --> 00:22:11.767
and they tend
to be so small

00:22:11.767 --> 00:22:13.300
that it doesn't really
significantly affect

00:22:13.300 --> 00:22:14.901
the size of things.

00:22:14.901 --> 00:22:16.200
Here's the second example.

00:22:16.200 --> 00:22:18.000
For the entry itself,

00:22:18.000 --> 00:22:19.567
you want the author's name.

00:22:19.567 --> 00:22:20.901
That leaves
everything else out.

00:22:20.901 --> 00:22:24.133
And you want the gml:pos
out of the georss:where.

00:22:24.133 --> 00:22:26.234
Leaves everything else out.

00:22:26.234 --> 00:22:28.300
So it's pretty simple
to specify

00:22:28.300 --> 00:22:30.167
what set of elements
you want.

00:22:30.167 --> 00:22:31.667
But there's
one more thing we added,

00:22:31.667 --> 00:22:33.701
which is conditional filters.

00:22:33.701 --> 00:22:35.367
And this is based--

00:22:35.367 --> 00:22:37.033
Well, it's similar to XPath.

00:22:37.033 --> 00:22:40.200
It's a very strict subset
of some of the XPath selection

00:22:40.200 --> 00:22:42.801
and conditional filtering.

00:22:42.801 --> 00:22:44.434
So it lets you actually say

00:22:44.434 --> 00:22:46.167
that you want,
in the first case here,

00:22:46.167 --> 00:22:50.801
only the thumbnail
whose height URL is 144.

00:22:50.801 --> 00:22:53.334
And this will leave--
anything that doesn't match that

00:22:53.334 --> 00:22:54.701
will not get sent.

00:22:54.701 --> 00:22:57.167
So this is a great way
to select a particular element

00:22:57.167 --> 00:23:00.167
out of an array of elements.

00:23:00.167 --> 00:23:04.133
And another example is when
you're selecting entries

00:23:04.133 --> 00:23:05.667
when you're getting
that feed of entries,

00:23:05.667 --> 00:23:07.501
suppose you only
want those entries

00:23:07.501 --> 00:23:09.033
that were authored by Sam,

00:23:09.033 --> 00:23:11.200
and the server doesn't give you
a way to query that.

00:23:11.200 --> 00:23:13.667
We can actually use a filter
after the query

00:23:13.667 --> 00:23:16.901
to only get back the ones
that have the name Sam.

00:23:16.901 --> 00:23:18.300
The important thing
about this

00:23:18.300 --> 00:23:20.634
is that filters
are not queries.

00:23:20.634 --> 00:23:25.200
So if you're doing a query
on a feed,

00:23:25.200 --> 00:23:27.467
and you're asking
for 100 results,

00:23:27.467 --> 00:23:29.100
and then you say
you only want the entries

00:23:29.100 --> 00:23:32.767
whose author's name was Sam
and that only matched ten,

00:23:32.767 --> 00:23:34.400
you only get ten back,

00:23:34.400 --> 00:23:37.033
even if on the server
there were maybe

00:23:37.033 --> 00:23:39.601
100 out of 2,000 that matched.

00:23:39.601 --> 00:23:42.334
So it's a filter
after the query matches.

00:23:42.334 --> 00:23:44.000
So the query matches
the first 100,

00:23:44.000 --> 00:23:46.634
and then the filter gets applied
and pares that down.

00:23:46.634 --> 00:23:49.868
So it's very important
to remember that.

00:23:49.868 --> 00:23:53.000
The other thing to notice here
is in the response

00:23:53.000 --> 00:23:56.000
we actually wrap the response
in a gd:partial element,

00:23:56.000 --> 00:23:58.400
and we include the fields
that you selected.

00:23:58.400 --> 00:24:00.467
And we'll see later--

00:24:00.467 --> 00:24:02.501
At the end of the talk,
I'm gonna talk about

00:24:02.501 --> 00:24:04.767
some of the new stuff
we're working on after this,

00:24:04.767 --> 00:24:06.467
and this comes
into play there.

00:24:06.467 --> 00:24:08.267
But it's also
useful for parsers

00:24:08.267 --> 00:24:11.467
to know that you're getting
a partial response

00:24:11.467 --> 00:24:14.400
and to know, in that case,
that, for example,

00:24:14.400 --> 00:24:17.534
some of the entry fields
that usually required--

00:24:17.534 --> 00:24:19.968
Like Atom ID is required.
It's actually here.

00:24:19.968 --> 00:24:22.467
And feed ID is required,
and it's not here.

00:24:22.467 --> 00:24:25.601
Those elements are required,
but they may not show up

00:24:25.601 --> 00:24:28.200
because you actually didn't
select them in the partial.

00:24:28.200 --> 00:24:30.868
So this is actually
not a valid feed,

00:24:30.868 --> 00:24:33.334
but it's
a valid partial feed.

00:24:33.334 --> 00:24:36.834
So that's why
that wrap element exists.

00:24:36.834 --> 00:24:39.801
Okay, so let's
go ahead and use this

00:24:39.801 --> 00:24:42.667
in our Photo Shuffle
application.

00:24:42.667 --> 00:24:44.734
It's pretty simple.

00:24:44.734 --> 00:24:47.000
That source
that we requested,

00:24:47.000 --> 00:24:50.400
we just add this fields=.

00:24:50.400 --> 00:24:52.400
And here you see
what I was saying before

00:24:52.400 --> 00:24:53.734
about how the JSONC

00:24:53.734 --> 00:24:55.567
is actually based
on the JSONC names,

00:24:55.567 --> 00:24:57.834
it's not "entry,"
it's "albums."

00:24:57.834 --> 00:24:59.534
So you say
I want the albums

00:24:59.534 --> 00:25:02.968
and I want their
ID, title, their feed link,

00:25:02.968 --> 00:25:06.133
and that was links(feed),
not link with the rel

00:25:06.133 --> 00:25:08.267
where, you know,
this long condition, right--

00:25:08.267 --> 00:25:09.601
It's much simpler
in this case.

00:25:09.601 --> 00:25:12.467
You just want the feed link,
and you want

00:25:12.467 --> 00:25:15.234
the media(thumbnails)
and nothing else.

00:25:15.234 --> 00:25:17.267
And those are the only things
the application uses,

00:25:17.267 --> 00:25:18.801
so that's what we request.

00:25:18.801 --> 00:25:20.567
We just ask for what
we actually want

00:25:20.567 --> 00:25:23.667
and leave everything else.

00:25:23.667 --> 00:25:26.400
And then the only other change
we have to make

00:25:26.400 --> 00:25:28.667
is that we now have
that wrapper element,

00:25:28.667 --> 00:25:30.534
that gd:partial
wrapper around things.

00:25:30.534 --> 00:25:33.634
So rather than having
the feed be the top level,

00:25:33.634 --> 00:25:34.934
the wrapper's the top level.

00:25:34.934 --> 00:25:36.334
So you have to do
data.feed.albums

00:25:36.334 --> 00:25:37.968
rather than data.albums.

00:25:37.968 --> 00:25:42.200
But otherwise, everything
else stays the same.

00:25:42.200 --> 00:25:44.734
So how does this
affect the size?

00:25:44.734 --> 00:25:46.634
In a pretty big way.

00:25:46.634 --> 00:25:48.701
We went from our original
770 kilobytes

00:25:48.701 --> 00:25:53.133
down to, you know,
I think it was 380ish

00:25:53.133 --> 00:25:55.601
for the JSONC.

00:25:55.601 --> 00:25:57.400
Now we're down
to I think it was

00:25:57.400 --> 00:26:00.100
70 kilobytes uncompressed
in the partial,

00:26:00.100 --> 00:26:02.567
because we got rid of all that
other stuff we didn't want.

00:26:02.567 --> 00:26:04.734
Even compressed,
it's actually pretty good.

00:26:04.734 --> 00:26:07.133
It went from about 38
down to 10.

00:26:07.133 --> 00:26:09.734
So it's
a factor of four there.

00:26:09.734 --> 00:26:12.100
Really, really makes
a huge difference,

00:26:12.100 --> 00:26:16.033
and it affects
the request time.

00:26:16.033 --> 00:26:17.834
So it takes about--

00:26:17.834 --> 00:26:19.701
it was about two seconds,
a little over two,

00:26:19.701 --> 00:26:22.901
rather than taking
almost four for the JSON

00:26:22.901 --> 00:26:26.100
and 2 1/2ish for the JSONC.

00:26:26.100 --> 00:26:27.701
So the request time's good,

00:26:27.701 --> 00:26:29.300
and the parse time
is even better.

00:26:29.300 --> 00:26:31.834
There's so much less data
that it's just a lot quicker.

00:26:31.834 --> 00:26:34.334
Part of the reason that
the request time didn't drop

00:26:34.334 --> 00:26:36.534
as much as you'd expect
is that, of course,

00:26:36.534 --> 00:26:38.400
there's a fixed
amount of time

00:26:38.400 --> 00:26:40.400
that is going to happen
between your round-trip.

00:26:40.400 --> 00:26:42.467
Regardless that's just
your latency,

00:26:42.467 --> 00:26:44.434
and then also the server
has to do some work

00:26:44.434 --> 00:26:47.634
so that--
that takes up some time.

00:26:47.634 --> 00:26:49.567
So the actual
amount of time spent

00:26:49.567 --> 00:26:53.234
sending the data
back and forth is smaller.

00:26:53.234 --> 00:26:55.167
So the parse time is smaller.

00:26:55.167 --> 00:26:57.968
Okay, so that was--
that was Partial GET.

00:26:57.968 --> 00:26:59.934
We're very excited about that.

00:26:59.934 --> 00:27:01.767
The last thing
I want to talk about

00:27:01.767 --> 00:27:04.968
is actually something
that came out a little bit ago

00:27:04.968 --> 00:27:06.734
but some of you may not
be familiar with,

00:27:06.734 --> 00:27:08.434
which is our ETag support.

00:27:08.434 --> 00:27:12.100
So you may have seen this,
and you may not have.

00:27:12.100 --> 00:27:14.267
How many of you guys
are familiar with ETags?

00:27:14.267 --> 00:27:16.934
Hopefully most of you.
Okay.

00:27:16.934 --> 00:27:19.100
Okay, well, I'll go in
a little bit on it,

00:27:19.100 --> 00:27:23.133
but again I'm gonna
first do a little background

00:27:23.133 --> 00:27:27.100
into sort of why things are
the way they are right now

00:27:27.100 --> 00:27:29.434
in our service
and then talk about

00:27:29.434 --> 00:27:31.000
what we're doing
in the future.

00:27:31.000 --> 00:27:33.801
So our initial service
was based

00:27:33.801 --> 00:27:37.767
on the HTTP/1.0 support
for client-side caching,

00:27:37.767 --> 00:27:39.834
which uses
the Last-Modified

00:27:39.834 --> 00:27:41.100
and If-Modified-Since.

00:27:41.100 --> 00:27:43.434
So when you're doing
a Conditional GET,

00:27:43.434 --> 00:27:45.400
you want to say, you know,
give me this feed

00:27:45.400 --> 00:27:47.667
or give me this entry
if it hasn't changed

00:27:47.667 --> 00:27:49.534
since this time.

00:27:49.534 --> 00:27:51.567
The way you get that time

00:27:51.567 --> 00:27:54.000
is by the Last-Modified
data on the response.

00:27:54.000 --> 00:27:55.501
So you'll get back a feed.

00:27:55.501 --> 00:27:57.300
One of the headers
will be Last-Modified.

00:27:57.300 --> 00:27:59.501
It will have this date.

00:27:59.501 --> 00:28:01.133
You record that,

00:28:01.133 --> 00:28:03.234
and then when you're doing
your next request

00:28:03.234 --> 00:28:06.200
for that feed or entry,
you send that along with it

00:28:06.200 --> 00:28:08.300
in a header,
in the If-Modified-Since header.

00:28:08.300 --> 00:28:11.334
And then if it hasn't changed,

00:28:11.334 --> 00:28:13.534
the server will respond
with a 304 Not Modified.

00:28:13.534 --> 00:28:15.033
So this is pretty basic.

00:28:15.033 --> 00:28:16.934
It should be 1.0.

00:28:16.934 --> 00:28:18.267
It's pretty simple.

00:28:18.267 --> 00:28:19.567
You just use a date.

00:28:19.567 --> 00:28:21.968
You just send it up.
It tells you if it changed.

00:28:21.968 --> 00:28:24.200
But unfortunately, there are
some problems with it.

00:28:24.200 --> 00:28:27.868
The biggest problem is that
it has one-second granularity.

00:28:27.868 --> 00:28:30.667
So this was kind of
a huge mistake,

00:28:30.667 --> 00:28:32.634
especially as things
have gotten faster,

00:28:32.634 --> 00:28:34.067
it's pretty easy nowadays

00:28:34.067 --> 00:28:36.067
to actually make multiple
updates within a second.

00:28:36.067 --> 00:28:37.734
So if you had--

00:28:37.734 --> 00:28:40.634
If your time stamp
on your element--

00:28:40.634 --> 00:28:42.567
Maybe you have millisecond,

00:28:42.567 --> 00:28:45.400
maybe you have nanosecond
granularity in your back-end,

00:28:45.400 --> 00:28:46.901
so that will change.

00:28:46.901 --> 00:28:49.968
But if it's within
the same second,

00:28:49.968 --> 00:28:53.300
the client can actually
think it has the newest version

00:28:53.300 --> 00:28:56.100
and not because it changed
twice in the same second.

00:28:56.100 --> 00:28:57.934
So that the client
can make a request

00:28:57.934 --> 00:28:59.934
halfway through that second
and get it back.

00:28:59.934 --> 00:29:01.567
It's pretty rare,
but it does happen,

00:29:01.567 --> 00:29:02.901
especially at that scale.

00:29:02.901 --> 00:29:04.801
So this is kind
of a problem.

00:29:04.801 --> 00:29:06.100
There are some ways
you can fix it.

00:29:06.100 --> 00:29:07.934
You can have the server
delay the response

00:29:07.934 --> 00:29:09.567
until a second has elapsed.

00:29:09.567 --> 00:29:11.200
You could use
days in the future,

00:29:11.200 --> 00:29:12.834
except the spec
doesn't allow it.

00:29:12.834 --> 00:29:14.968
So there's issues there.

00:29:14.968 --> 00:29:18.434
And another problem is that
we're dealing with time,

00:29:18.434 --> 00:29:20.067
but at the same time

00:29:20.067 --> 00:29:22.234
the server is the only
valid source of that.

00:29:22.234 --> 00:29:24.167
So it's really--
It's a time stamp,

00:29:24.167 --> 00:29:25.767
but it's actually--

00:29:25.767 --> 00:29:27.067
It can't be used
as a time stamp.

00:29:27.067 --> 00:29:28.734
You can't, you know,
do date computations.

00:29:28.734 --> 00:29:30.434
The server could change dates.

00:29:30.434 --> 00:29:32.667
You know, you can't use it
to judge when things change.

00:29:32.667 --> 00:29:35.133
It's actually
not useful as time.

00:29:35.133 --> 00:29:37.400
And you can't use it
on the client

00:29:37.400 --> 00:29:39.200
as if it was actually time.

00:29:39.200 --> 00:29:41.300
You have to actually send
exactly what you got back.

00:29:41.300 --> 00:29:42.667
You can't, you know--

00:29:42.667 --> 00:29:44.334
If something is similar,
you can't take it.

00:29:44.334 --> 00:29:45.601
You can't do less thans.

00:29:45.601 --> 00:29:47.133
It has to be equal.

00:29:47.133 --> 00:29:51.868
So that's kind of a problem.

00:29:51.868 --> 00:29:57.801
Okay, so my slides
had a little issue there.

00:29:57.801 --> 00:30:01.501
All right,
so how do we fix this?

00:30:01.501 --> 00:30:04.000
HTTP/1.1 introduced
something called ETags,

00:30:04.000 --> 00:30:05.267
which some of you
are familiar with

00:30:05.267 --> 00:30:07.000
but many of you aren't.

00:30:07.000 --> 00:30:08.300
They're pretty simple.

00:30:08.300 --> 00:30:10.968
They're actually
just an opaque quoted string.

00:30:10.968 --> 00:30:14.100
So rather than having a date
that looks like a date

00:30:14.100 --> 00:30:15.734
but you can't use it
as a date,

00:30:15.734 --> 00:30:17.667
you have to just treat it
as an opaque string.

00:30:17.667 --> 00:30:19.801
ETags are an opaque string
to start with,

00:30:19.801 --> 00:30:22.334
and they can be much smaller
because of that.

00:30:22.334 --> 00:30:23.901
You can encode data in there.

00:30:23.901 --> 00:30:25.667
You can encode a lot more
than just time stamps.

00:30:25.667 --> 00:30:26.968
You can code whatever
you want.

00:30:26.968 --> 00:30:28.934
You can do hashes.

00:30:28.934 --> 00:30:33.901
They're just a string
with two quotes.

00:30:33.901 --> 00:30:35.767
Very, very simple.

00:30:35.767 --> 00:30:37.434
There's one additional
complication.

00:30:37.434 --> 00:30:39.767
They may be what's called
strong or weak.

00:30:39.767 --> 00:30:41.601
The difference
is that strong ETags

00:30:41.601 --> 00:30:44.067
can be used
for conditional updates,

00:30:44.067 --> 00:30:45.367
which I'll talk about
in a little bit.

00:30:45.367 --> 00:30:47.400
And weak ETags can only
be used for conditional gets,

00:30:47.400 --> 00:30:48.868
not for updates.

00:30:48.868 --> 00:30:50.133
So here's a weak ETag.

00:30:50.133 --> 00:30:52.901
There's just a w/ before it.

00:30:52.901 --> 00:30:55.167
Nothing too exciting there.

00:30:55.167 --> 00:30:56.734
Just think of them
as opaque strings,

00:30:56.734 --> 00:30:58.167
and you'll be fine.

00:30:58.167 --> 00:31:01.167
The way it works
is that a server will--

00:31:01.167 --> 00:31:05.133
HTTP/1.1 server will respond
with an ETag header

00:31:05.133 --> 00:31:06.667
in the response,

00:31:06.667 --> 00:31:08.968
and our Google Data APIs
will return that

00:31:08.968 --> 00:31:12.567
on our new versions as well
on feed and entry requests.

00:31:12.567 --> 00:31:15.234
So here's an example response.

00:31:15.234 --> 00:31:17.534
You see the ETag header,

00:31:17.534 --> 00:31:19.367
and then there's also
two other things.

00:31:19.367 --> 00:31:21.734
So we actually
also return the ETag

00:31:21.734 --> 00:31:24.000
at the feed level
and at the entry level.

00:31:24.000 --> 00:31:25.601
So when you request a feed,

00:31:25.601 --> 00:31:28.901
we'll give you back
the ETag for the feed itself

00:31:28.901 --> 00:31:30.667
both in the header
and on the element,

00:31:30.667 --> 00:31:32.067
and the reason
it's on the element

00:31:32.067 --> 00:31:33.534
is in case you don't
have access to the headers

00:31:33.534 --> 00:31:35.334
it's easy to get to.

00:31:35.334 --> 00:31:37.234
But we also give you it
on each of the entries.

00:31:37.234 --> 00:31:39.234
And that's really useful
because that way

00:31:39.234 --> 00:31:41.234
you can use that ETag

00:31:41.234 --> 00:31:43.534
for both conditional get
of that entry itself

00:31:43.534 --> 00:31:45.601
and conditional update
without having to go back

00:31:45.601 --> 00:31:47.300
and make a separate request
for the entry.

00:31:47.300 --> 00:31:50.901
So just the feed
gives you all you need.

00:31:50.901 --> 00:31:54.734
So how do we actually do our
client-side caching with this?

00:31:54.734 --> 00:31:56.601
So instead of using
If-Modified-Since,

00:31:56.601 --> 00:31:59.133
which is what we used
to the Last-Modified,

00:31:59.133 --> 00:32:03.267
we're gonna use
If-None-Match.

00:32:03.267 --> 00:32:04.701
Oops.

00:32:04.701 --> 00:32:06.868
I think that was
out of order but--

00:32:06.868 --> 00:32:10.167
All right, so--

00:32:10.167 --> 00:32:11.968
Yeah, I have a slide
out of order.

00:32:11.968 --> 00:32:13.300
Sorry about that.

00:32:13.300 --> 00:32:14.634
I'll go back to that
in a second.

00:32:14.634 --> 00:32:16.567
Here's what it looks like
with the If-None-Match.

00:32:16.567 --> 00:32:18.701
So you send
an If-None-Match request

00:32:18.701 --> 00:32:21.467
with that ETag,
either weak or strong.

00:32:21.467 --> 00:32:22.767
So in this example
it's for a feed,

00:32:22.767 --> 00:32:24.100
so it was weak.

00:32:24.100 --> 00:32:25.601
And then if it
has not changed,

00:32:25.601 --> 00:32:28.167
the server will respond
with a 304 Not Modified.

00:32:28.167 --> 00:32:29.534
And I'll go back to that.

00:32:29.534 --> 00:32:32.367
You can see the only thing
to really think about here

00:32:32.367 --> 00:32:34.300
is the request time.

00:32:34.300 --> 00:32:36.400
On a Not Modified,
the server doesn't send you

00:32:36.400 --> 00:32:37.868
any data back.

00:32:37.868 --> 00:32:39.734
And in fact,
back-ends can be quicker

00:32:39.734 --> 00:32:41.734
to respond
with a Not Modified

00:32:41.734 --> 00:32:42.934
than with the full data.

00:32:42.934 --> 00:32:44.267
They don't have
to go fetch everything.

00:32:44.267 --> 00:32:46.634
They can just see:
Oh, did the version change?

00:32:46.634 --> 00:32:48.334
No. Okay, just respond
with the 304.

00:32:48.334 --> 00:32:49.400
You're done.

00:32:49.400 --> 00:32:51.400
Things are much quicker.

00:32:51.400 --> 00:32:53.667
And then on the client,
for example in the browser,

00:32:53.667 --> 00:32:55.334
the browser will just
pull that data

00:32:55.334 --> 00:32:56.701
out of its local cache.

00:32:56.701 --> 00:32:58.434
So you don't have to worry
about the request time.

00:32:58.434 --> 00:33:00.133
You don't have to worry
about the bandwidth.

00:33:00.133 --> 00:33:02.667
There's no bandwidth used.
Much, much nicer.

00:33:02.667 --> 00:33:07.434
Okay, so that was
Conditional GET.

00:33:07.434 --> 00:33:09.367
But the other thing
you can use ETags for,

00:33:09.367 --> 00:33:12.334
which you couldn't use
the If-Modified-Since for

00:33:12.334 --> 00:33:14.701
was--is for
optimistic concurrency.

00:33:14.701 --> 00:33:16.801
So rather than using
If-None-Match,

00:33:16.801 --> 00:33:18.200
use If-Match.

00:33:18.200 --> 00:33:19.767
And that lets you say,

00:33:19.767 --> 00:33:23.100
modify this document
or this entry

00:33:23.100 --> 00:33:26.400
only if the ETag matches
the one I'm gonna send you.

00:33:26.400 --> 00:33:29.467
So here's an example.

00:33:29.467 --> 00:33:35.200
We want to put a new version
of some entry.

00:33:35.200 --> 00:33:37.467
We give it the URL,
and in this case--

00:33:37.467 --> 00:33:39.501
Well, it looks sort of
like the old one,

00:33:39.501 --> 00:33:40.901
but in this case
there's actually

00:33:40.901 --> 00:33:42.601
no longer a version string
at the end of it.

00:33:42.601 --> 00:33:43.868
It's just the entry ID,

00:33:43.868 --> 00:33:45.400
so it doesn't change
between versions,

00:33:45.400 --> 00:33:46.767
which is very nice.

00:33:46.767 --> 00:33:48.100
And you just say,
"If-Match,"

00:33:48.100 --> 00:33:49.434
and you give it
the strong ETag,

00:33:49.434 --> 00:33:50.834
not the weak ETag.

00:33:50.834 --> 00:33:52.901
And if nothing--
If it matched,

00:33:52.901 --> 00:33:55.234
if that ETag was okay,
you get a 200 OK.

00:33:55.234 --> 00:33:57.734
You successfully
change that entry.

00:33:57.734 --> 00:34:01.000
If it didn't, you get
a 412 Precondition Failed,

00:34:01.000 --> 00:34:03.267
and again it will
send you back

00:34:03.267 --> 00:34:04.534
the new version
of the entry,

00:34:04.534 --> 00:34:07.868
so you know what changed,
and you get the new one.

00:34:07.868 --> 00:34:09.501
One other thing
you can do with this

00:34:09.501 --> 00:34:11.434
that you couldn't do
with the old system

00:34:11.434 --> 00:34:13.434
is use If-Match:*.

00:34:13.434 --> 00:34:15.300
And what this does
is it allows you

00:34:15.300 --> 00:34:17.734
to force an update
even if someone else

00:34:17.734 --> 00:34:19.501
has changed
that entry between.

00:34:19.501 --> 00:34:24.000
So this is actually
kind of dangerous

00:34:24.000 --> 00:34:26.467
unless you're using
something

00:34:26.467 --> 00:34:28.400
I'm gonna talk about
at the end of the talk.

00:34:28.400 --> 00:34:31.133
But if you're just using
a regular update,

00:34:31.133 --> 00:34:32.968
the problem with this
is you'll overwrite

00:34:32.968 --> 00:34:36.400
anyone else's changes
without keeping them in,

00:34:36.400 --> 00:34:38.767
because you're putting
an entire entry back.

00:34:38.767 --> 00:34:41.100
So use with caution.

00:34:41.100 --> 00:34:44.734
Okay, so we've seen--

00:34:44.734 --> 00:34:46.734
We've seen ETags now.
We know what they are.

00:34:46.734 --> 00:34:49.334
How do we actually
add ETag support

00:34:49.334 --> 00:34:52.234
to our application?

00:34:52.234 --> 00:34:53.567
It's not very complicated.

00:34:53.567 --> 00:34:58.267
you just do &amp;v=2
and you're done.

00:34:58.267 --> 00:35:01.534
And this is actually
our versioning support, which--

00:35:01.534 --> 00:35:04.067
So who's familiar
with the Google Data APIs'

00:35:04.067 --> 00:35:06.501
versioning support
that was added?

00:35:06.501 --> 00:35:07.734
Okay, only a couple of you.

00:35:07.734 --> 00:35:09.167
So you can go look at
the docs,

00:35:09.167 --> 00:35:11.000
but basically
we've been rolling out

00:35:11.000 --> 00:35:12.801
new versions of services,

00:35:12.801 --> 00:35:14.133
and the way we version them

00:35:14.133 --> 00:35:16.701
is using
a version parameter, V.

00:35:16.701 --> 00:35:18.601
In this case,
the Picasa Web Album's API

00:35:18.601 --> 00:35:20.067
is on version two.

00:35:20.067 --> 00:35:21.968
And version two
includes ETag support.

00:35:21.968 --> 00:35:24.501
So if you want ETags,
you just change to version two,

00:35:24.501 --> 00:35:27.267
and there you are.

00:35:27.267 --> 00:35:29.968
Okay, that was--

00:35:29.968 --> 00:35:31.300
that was ETags.

00:35:31.300 --> 00:35:33.300
And now I'm gonna
talk about stuff

00:35:33.300 --> 00:35:35.100
that doesn't quite exist yet.

00:35:35.100 --> 00:35:37.400
So ETags is already out.

00:35:37.400 --> 00:35:43.167
JSONC is on Picasa Web Albums.

00:35:43.167 --> 00:35:46.834
Probably this week it will
launch the final version.

00:35:46.834 --> 00:35:49.701
I'm actually using a sort of
preview version of it

00:35:49.701 --> 00:35:50.934
that's in production,

00:35:50.934 --> 00:35:52.767
but it's going to change
a little bit.

00:35:52.767 --> 00:35:54.801
And then YouTube
is actually working

00:35:54.801 --> 00:35:56.467
on their JSONC support
right now.

00:35:56.467 --> 00:35:57.901
So that'll be out soon.

00:35:57.901 --> 00:36:00.367
And we're gonna keep rolling out
more services to that.

00:36:00.367 --> 00:36:02.367
Partial GET
will actually roll out

00:36:02.367 --> 00:36:04.334
a little bit faster
than that.

00:36:04.334 --> 00:36:06.434
So as we roll that out,

00:36:06.434 --> 00:36:08.367
we'll let you know
on the blogs

00:36:08.367 --> 00:36:10.000
and on code.google.com.

00:36:10.000 --> 00:36:12.934
So an eye out for that.

00:36:12.934 --> 00:36:14.400
But now I'm gonna
look at some stuff

00:36:14.400 --> 00:36:16.534
that's not quite there yet.

00:36:16.534 --> 00:36:18.667
So it'll be a little bit
farther in the future.

00:36:18.667 --> 00:36:20.801
So the first thing
is that JSONC

00:36:20.801 --> 00:36:23.868
is not a read only protocol.

00:36:23.868 --> 00:36:26.033
We actually meant for this
to be both read and write.

00:36:26.033 --> 00:36:28.033
So unlike our existing JSON

00:36:28.033 --> 00:36:31.767
where we convert on the server
from XML to JSON,

00:36:31.767 --> 00:36:34.634
and then on the client convert
from JSON back to XML

00:36:34.634 --> 00:36:36.167
and turn it back to XML,

00:36:36.167 --> 00:36:39.100
you can actually send back
the JSONC.

00:36:39.100 --> 00:36:41.400
You don't need to translate
back to XML for update.

00:36:41.400 --> 00:36:43.767
You can send it directly.

00:36:43.767 --> 00:36:45.467
And this supports
all write operations,

00:36:45.467 --> 00:36:50.534
including match
and the regular putsand posts.

00:36:50.534 --> 00:36:53.501
And one nice thing
is that the new browsers

00:36:53.501 --> 00:36:56.934
are actually adding
capabilities for reading

00:36:56.934 --> 00:36:59.534
and more importantly writing
in JSON directly,

00:36:59.534 --> 00:37:00.968
which makes it much nicer.

00:37:00.968 --> 00:37:03.133
You can actually just call
a browser method,

00:37:03.133 --> 00:37:05.300
JSON.stringify(data),

00:37:05.300 --> 00:37:06.701
and that'll give you
a JSON string

00:37:06.701 --> 00:37:10.234
that can be sent to the client,
to the server.

00:37:10.234 --> 00:37:11.767
One other thing
we're gonna do

00:37:11.767 --> 00:37:14.200
is roll all this
into our client library,

00:37:14.200 --> 00:37:16.467
so you won't actually
have to do any of that.

00:37:16.467 --> 00:37:18.200
Excuse me.

00:37:18.200 --> 00:37:20.000
Another thing
that this gives us

00:37:20.000 --> 00:37:22.067
is it lets us
make the client libraries

00:37:22.067 --> 00:37:26.100
much, much smaller
than they are right now.

00:37:26.100 --> 00:37:27.567
So currently
our client libraries

00:37:27.567 --> 00:37:30.133
actually contain a bunch
of data model classes.

00:37:30.133 --> 00:37:32.234
So there's, like,
a photo entry class

00:37:32.234 --> 00:37:33.767
and a media group class

00:37:33.767 --> 00:37:36.767
and all these other
JavaScript objects

00:37:36.767 --> 00:37:39.300
with functions and things
to make life easier

00:37:39.300 --> 00:37:42.534
basically because
the existing format

00:37:42.534 --> 00:37:44.167
was so hard to work with.

00:37:44.167 --> 00:37:47.334
It's much nicer to call,
you know,

00:37:47.334 --> 00:37:48.667
entry.getmedia:group

00:37:48.667 --> 00:37:51.567
than it is to call
entry.media$group

00:37:51.567 --> 00:37:54.000
and actually try to do
the XML stuff yourself

00:37:54.000 --> 00:37:55.234
and all that.

00:37:55.234 --> 00:37:56.901
But of course with JSONC,
it's much nicer.

00:37:56.901 --> 00:37:58.601
We don't need all that,
so we can throw that out

00:37:58.601 --> 00:38:00.767
and just give you
the bare-bones client library

00:38:00.767 --> 00:38:02.701
that does
the interesting stuff,

00:38:02.701 --> 00:38:05.400
including, you know,
read-write JSON,

00:38:05.400 --> 00:38:08.834
marshaling things
on the wire.

00:38:08.834 --> 00:38:11.033
Very importantly, giving you
authentication support.

00:38:11.033 --> 00:38:14.067
So giving you auth support
in the client library.

00:38:14.067 --> 00:38:16.000
And also giving you
cross-domain support,

00:38:16.000 --> 00:38:18.300
so that's the other big thing
that our client library does.

00:38:18.300 --> 00:38:20.033
So you can actually do
read-write requests

00:38:20.033 --> 00:38:21.667
cross-domain
using our library,

00:38:21.667 --> 00:38:24.467
which is very nice.

00:38:24.467 --> 00:38:28.100
The other big thing is that
that Partial document

00:38:28.100 --> 00:38:29.701
I was talking about,
that gd:partial,

00:38:29.701 --> 00:38:31.534
you can actually
send those back to the server.

00:38:31.534 --> 00:38:33.400
So Partial
isn't just for GET.

00:38:33.400 --> 00:38:35.934
And this is--
this is a huge part

00:38:35.934 --> 00:38:39.067
of our goal of making--
making it so you only need

00:38:39.067 --> 00:38:41.033
to work with the data
you really, really care about.

00:38:41.033 --> 00:38:42.734
So you can get
a partial document,

00:38:42.734 --> 00:38:44.868
modify just that field
you want to modify,

00:38:44.868 --> 00:38:46.334
and send that back
to the server

00:38:46.334 --> 00:38:49.167
using PATCH instead of PUT.

00:38:49.167 --> 00:38:51.200
So it's really nice.

00:38:51.200 --> 00:38:52.501
And the other thing
it gives you

00:38:52.501 --> 00:38:54.133
is that If-Match: *
I was talking about

00:38:54.133 --> 00:38:56.067
that was dangerous
is now safe

00:38:56.067 --> 00:38:58.033
because you're only
changing the field

00:38:58.033 --> 00:39:00.334
that you know the truth
about.

00:39:00.334 --> 00:39:02.834
So it doesn't matter if other
people changed other fields.

00:39:02.834 --> 00:39:04.200
Like, if the summary changed,

00:39:04.200 --> 00:39:05.534
and all you're modifying
is the title,

00:39:05.534 --> 00:39:06.801
you can actually do that now.

00:39:06.801 --> 00:39:08.868
You can just send the title.
You can send a dif.

00:39:08.868 --> 00:39:10.501
Makes it much nicer,

00:39:10.501 --> 00:39:12.734
and the client only needs
to store the stuff

00:39:12.734 --> 00:39:14.033
it actually cares about.

00:39:14.033 --> 00:39:15.367
So you only need to store
those difs.

00:39:15.367 --> 00:39:17.601
You don't need to store
all of the entries.

00:39:17.601 --> 00:39:19.200
You don't need to store
all these fields

00:39:19.200 --> 00:39:21.000
you don't know about
or care about.

00:39:21.000 --> 00:39:24.033
You just store what you want.

00:39:24.033 --> 00:39:26.901
All right, so that's it.

00:39:26.901 --> 00:39:30.734
That's the new stuff
we're introducing.

00:39:30.734 --> 00:39:32.567
If any of you have questions,

00:39:32.567 --> 00:39:34.367
please come up
to the microphones,

00:39:34.367 --> 00:39:35.968
because this
is being recorded,

00:39:35.968 --> 00:39:38.334
so for the recording

00:39:38.334 --> 00:39:41.167
and so everyone can hear you.

00:39:41.167 --> 00:39:43.100
[applause]

00:39:49.367 --> 00:39:52.167
While you're waiting,
I can shuffle some more stuff.

00:39:52.167 --> 00:39:54.868
[laughter]

00:39:54.868 --> 00:39:58.000
If it works.

00:39:58.000 --> 00:40:01.534
I needed a worker thread
like they had this morning.

00:40:01.534 --> 00:40:02.868
There we go.

00:40:02.868 --> 00:40:04.801
All right.

00:40:09.901 --> 00:40:12.167
Okay.

00:40:12.167 --> 00:40:16.033
man: So are you going to
implement a patch for XML too?

00:40:16.033 --> 00:40:19.801
Mawson: Yes, so Patch
is going to be both XML,

00:40:19.801 --> 00:40:25.534
um, and JSONC based.

00:40:25.534 --> 00:40:28.601
man: You said
that you supported

00:40:28.601 --> 00:40:33.200
cross-domain rights.

00:40:33.200 --> 00:40:35.367
What did you do
to support that?

00:40:35.367 --> 00:40:38.601
Mawson: So the existing
JSON library

00:40:38.601 --> 00:40:40.133
supports cross-domain rights.

00:40:40.133 --> 00:40:42.834
We actually use
some browser tricks

00:40:42.834 --> 00:40:45.767
to get data back and forth
between a script running

00:40:45.767 --> 00:40:48.634
on our domain and the script
running on your domain.

00:40:48.634 --> 00:40:50.367
So those two scripts
communicate,

00:40:50.367 --> 00:40:52.234
and then the script
running on our domain

00:40:52.234 --> 00:40:55.167
can actually do
a regular XML HTTP request

00:40:55.167 --> 00:40:56.567
with the data.

00:40:56.567 --> 00:40:58.567
And so that's how
you get cross-domain.

00:40:58.567 --> 00:41:01.434
So you marshal it
between domains.

00:41:01.434 --> 00:41:02.601
man: Thanks.

00:41:02.601 --> 00:41:04.234
Mawson: And all
the information on that

00:41:04.234 --> 00:41:08.000
should be on the
code.google.com/apis/gdata site.

00:41:08.000 --> 00:41:12.367
man: Okay.
Thank you, sir.

00:41:12.367 --> 00:41:13.534
second man:
Uh, hi.

00:41:13.534 --> 00:41:15.501
I'm Charlie Wood
from [indistinct].

00:41:15.501 --> 00:41:17.534
Are all of these
going to be supported

00:41:17.534 --> 00:41:19.501
across all
of the product APIs,

00:41:19.501 --> 00:41:22.634
or are they sort of optional
for each product to implement?

00:41:22.634 --> 00:41:24.067
Mawson: Excellent question.

00:41:24.067 --> 00:41:28.467
So they actually are
somewhat optional,

00:41:28.467 --> 00:41:30.601
although we're
pushing very hard

00:41:30.601 --> 00:41:32.934
to get every single
product to use them.

00:41:32.934 --> 00:41:37.133
The problem is that,
especially for the JSONC,

00:41:37.133 --> 00:41:39.200
we're actually customizing it.

00:41:39.200 --> 00:41:41.200
And I didn't really go into
too much detail on this,

00:41:41.200 --> 00:41:43.400
but we're
customizing the output

00:41:43.400 --> 00:41:45.434
specifically
for each product.

00:41:45.434 --> 00:41:48.534
So things are gonna look
like you'd expect.

00:41:48.534 --> 00:41:51.868
So a photo in Picasa Web
looks like you'd expect

00:41:51.868 --> 00:41:53.267
JSON for a photo to look.

00:41:53.267 --> 00:41:54.901
And in YouTube,
a video's gonna look

00:41:54.901 --> 00:41:56.734
like you'd expect
a video to look.

00:41:56.734 --> 00:41:59.334
So that's
a bit more work to do,

00:41:59.334 --> 00:42:01.067
so it does take more time,

00:42:01.067 --> 00:42:02.534
and it does require
extra effort

00:42:02.534 --> 00:42:05.033
on the part
of our services.

00:42:05.033 --> 00:42:08.234
So we're pushing on them
to get it done

00:42:08.234 --> 00:42:11.501
as quickly as they can, so...

00:42:11.501 --> 00:42:14.100
But if you guys
want particular services

00:42:14.100 --> 00:42:16.267
to have this support,
you know,

00:42:16.267 --> 00:42:17.834
go on their boards
and ask for it,

00:42:17.834 --> 00:42:19.767
and that'll give them pressure
to come to us

00:42:19.767 --> 00:42:22.667
and ask for help,
so it'll be good.

00:42:28.868 --> 00:42:30.434
man: Hi.

00:42:30.434 --> 00:42:32.968
Are you going to support
APIs for Google Reader

00:42:32.968 --> 00:42:34.200
anytime soon?

00:42:34.200 --> 00:42:35.968
Mawson: For what?
man: For Google Reader.

00:42:35.968 --> 00:42:37.234
Mawson: Google Reader.

00:42:37.234 --> 00:42:39.601
I don't know of any plans
to support any,

00:42:39.601 --> 00:42:42.234
but even if I did,
I wouldn't know.

00:42:42.234 --> 00:42:45.200
So, yeah,
I don't actually know.

00:42:45.200 --> 00:42:47.467
I don't know about that.

00:42:51.901 --> 00:42:55.067
Any other questions?

00:42:55.067 --> 00:42:56.901
All right, well,
thank you guys for coming.

00:42:56.901 --> 00:42:58.834
[applause]

