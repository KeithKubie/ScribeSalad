WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.437
[MUSIC PLAYING]

00:00:07.860 --> 00:00:10.920
JOEL NEWMAN: Good afternoon,
everybody, and welcome.

00:00:10.920 --> 00:00:14.130
Today's session is all
about app performance.

00:00:14.130 --> 00:00:16.560
My name is Joel Newman, and
I'm a product specialist

00:00:16.560 --> 00:00:19.200
on the Google Play
business development team.

00:00:19.200 --> 00:00:21.660
In that capacity, I've worked
with Android developers

00:00:21.660 --> 00:00:24.030
of all shapes and
sizes, helping them

00:00:24.030 --> 00:00:27.450
to leverage the tools available
in the Google Play Console

00:00:27.450 --> 00:00:29.962
to build successful
app businesses.

00:00:29.962 --> 00:00:32.580
Now I'm going to kick things
off with a quick reminder

00:00:32.580 --> 00:00:35.520
of just how important
performance is to app business

00:00:35.520 --> 00:00:38.040
success, and why
Android Vitals could

00:00:38.040 --> 00:00:41.550
be a critical tool in helping
you improve your performance.

00:00:41.550 --> 00:00:43.530
Then my colleague
Fergus, product manager

00:00:43.530 --> 00:00:46.710
for Android Vitals, will join
me on stage to talk about some

00:00:46.710 --> 00:00:48.840
of the ways we're
enhancing the platform

00:00:48.840 --> 00:00:52.260
to make it easier to understand
and to action your performance

00:00:52.260 --> 00:00:53.469
information.

00:00:53.469 --> 00:00:56.010
Then my colleague, [INAUDIBLE],,
from our developer relations

00:00:56.010 --> 00:00:59.160
team will come onstage
for a technical deep dive

00:00:59.160 --> 00:01:01.590
to talk through some of the
common causes of performance

00:01:01.590 --> 00:01:04.420
issues and how to address them.

00:01:04.420 --> 00:01:07.830
Finally, we'll wrap things
up by talking about some

00:01:07.830 --> 00:01:10.350
of the resources available
within the Play Console

00:01:10.350 --> 00:01:13.860
itself and beyond to
improve your performance.

00:01:13.860 --> 00:01:17.500
And if we have time, we'll
try to do a brief Q&amp;A.

00:01:17.500 --> 00:01:19.750
Now, first, I think it's
important to remind ourselves

00:01:19.750 --> 00:01:21.857
of why performance is important.

00:01:21.857 --> 00:01:23.440
Now, I think this
is intuitive, right?

00:01:23.440 --> 00:01:25.570
Like we, as users,
nobody wants to deal

00:01:25.570 --> 00:01:28.570
with an app that crashes
frequently or freezes

00:01:28.570 --> 00:01:29.770
or is janky.

00:01:29.770 --> 00:01:31.630
But at Google Play,
we have data that

00:01:31.630 --> 00:01:35.080
drives home just how
important performance is.

00:01:35.080 --> 00:01:37.630
We did an analysis of all the
reviews on the Google Play

00:01:37.630 --> 00:01:40.120
Store over the
past year and found

00:01:40.120 --> 00:01:44.230
that when leaving a one-star
review, over 40% of the time,

00:01:44.230 --> 00:01:47.230
users cited negative
performance indicators

00:01:47.230 --> 00:01:49.060
like stability and bugs.

00:01:49.060 --> 00:01:51.940
In fact, this was the
number one cited issue

00:01:51.940 --> 00:01:54.430
within one-star reviews.

00:01:54.430 --> 00:01:57.340
Now, on the flip side, when
leaving five-star reviews,

00:01:57.340 --> 00:02:00.760
over 70% of users mentioned
positive performance

00:02:00.760 --> 00:02:05.260
indicators, things like
speed, design, and usability.

00:02:05.260 --> 00:02:06.980
Now, why is this important?

00:02:06.980 --> 00:02:09.610
Well, not only are
ratings and reviews

00:02:09.610 --> 00:02:12.850
a direct and leading indicator
of customer satisfaction,

00:02:12.850 --> 00:02:15.790
and not only do ratings figure
heavily in the Play Store

00:02:15.790 --> 00:02:20.170
search algorithm, but ratings
and reviews correlate strongly

00:02:20.170 --> 00:02:22.720
with downstream
business KPIs, things

00:02:22.720 --> 00:02:26.890
like engagement, retention,
and monetization.

00:02:26.890 --> 00:02:29.470
A great example of
how that performance

00:02:29.470 --> 00:02:33.730
can impact key business
KPIs comes from this study.

00:02:33.730 --> 00:02:36.940
We did an analysis of all
of the games in Google Play.

00:02:36.940 --> 00:02:39.900
And we compared those with the
lowest crash rate versus those

00:02:39.900 --> 00:02:41.260
of the highest crash rate.

00:02:41.260 --> 00:02:43.870
And we found apps with
the lower crash rate

00:02:43.870 --> 00:02:46.480
saw almost two and
a half minutes more

00:02:46.480 --> 00:02:49.280
of game play per day.

00:02:49.280 --> 00:02:51.730
And this was even
a bigger trend when

00:02:51.730 --> 00:02:54.460
we looked at ANRs, which are
more frequently looked over

00:02:54.460 --> 00:02:55.930
relative to crash rate.

00:02:55.930 --> 00:02:59.620
We found that users spent almost
three minutes more per day

00:02:59.620 --> 00:03:01.500
in the more stable apps.

00:03:01.500 --> 00:03:04.050
Now, this may not sound
like a ton of time.

00:03:04.050 --> 00:03:06.160
But when you look at
this over a yearly basis,

00:03:06.160 --> 00:03:08.470
this would translate
into 18 hours

00:03:08.470 --> 00:03:11.740
of additional gameplay
per user for games that

00:03:11.740 --> 00:03:13.300
are played on a daily basis.

00:03:16.810 --> 00:03:18.810
Now, another reason
why performance

00:03:18.810 --> 00:03:20.970
is incredibly
important is that it's

00:03:20.970 --> 00:03:23.850
becoming an increasingly
important signal

00:03:23.850 --> 00:03:27.390
within Google Play for
both search and discovery.

00:03:27.390 --> 00:03:31.380
As Google Play is committed
to servicing only the highest

00:03:31.380 --> 00:03:34.530
content to our users,
we're increasingly

00:03:34.530 --> 00:03:37.980
taking into account performance
signals, particularly

00:03:37.980 --> 00:03:41.850
those related to stability
and battery consumption,

00:03:41.850 --> 00:03:44.280
in both our Play Store
search algorithm,

00:03:44.280 --> 00:03:48.450
as well as our algorithmically
generated recommendations.

00:03:48.450 --> 00:03:52.500
In addition to that,
performance signals factor

00:03:52.500 --> 00:03:57.000
heavily into our decisions
around our editorially curated

00:03:57.000 --> 00:03:58.230
content.

00:03:58.230 --> 00:04:01.710
This includes our featured new
and updated apps collection,

00:04:01.710 --> 00:04:04.280
as well as editors' choice
and coveted Google Play

00:04:04.280 --> 00:04:06.720
Awards and Android Excellence.

00:04:06.720 --> 00:04:09.390
If you want your app
business to succeed,

00:04:09.390 --> 00:04:11.640
your app needs to be discovered.

00:04:11.640 --> 00:04:15.090
And technical performance
is an increasing part

00:04:15.090 --> 00:04:18.029
of that discovery
within the Play Store.

00:04:18.029 --> 00:04:20.700
Now, it's exactly because of
that increasing importance

00:04:20.700 --> 00:04:23.910
of technical performance that
we launched Android Vitals

00:04:23.910 --> 00:04:25.230
last year.

00:04:25.230 --> 00:04:27.780
Android Vitals is an
initiative by Google

00:04:27.780 --> 00:04:31.530
to improve the stability and
performance of Android devices

00:04:31.530 --> 00:04:34.650
by servicing to
developers in an easily

00:04:34.650 --> 00:04:37.590
understandable and
readily accessible

00:04:37.590 --> 00:04:40.970
way the most important
performance metrics

00:04:40.970 --> 00:04:44.370
in battery, stability,
and rendering.

00:04:44.370 --> 00:04:47.310
This comes from over
100 million users

00:04:47.310 --> 00:04:50.280
who have opted in to
share the data with Google

00:04:50.280 --> 00:04:54.270
and with you, our
developer partners.

00:04:54.270 --> 00:04:56.880
And since the program's
launch a year ago, it's

00:04:56.880 --> 00:04:58.860
been an incredible success.

00:04:58.860 --> 00:05:02.400
We have over 100,000 developers,
including some of the biggest

00:05:02.400 --> 00:05:05.760
names on the Android
platform, regularly engaging

00:05:05.760 --> 00:05:08.730
with the Vitals Console to
understand their performance

00:05:08.730 --> 00:05:12.342
issue and create fixes.

00:05:12.342 --> 00:05:14.300
Now, it's because of this
incredible engagement

00:05:14.300 --> 00:05:17.630
that we've seen some really nice
gains at an ecosystem level.

00:05:17.630 --> 00:05:21.290
When we compared reviews in the
Play Store today versus a year

00:05:21.290 --> 00:05:23.390
ago before we
launched Vitals, we

00:05:23.390 --> 00:05:26.000
see a really nice uptick
in those people leaving

00:05:26.000 --> 00:05:29.180
five-star reviews talking about
things like speed, design,

00:05:29.180 --> 00:05:30.710
and usability.

00:05:30.710 --> 00:05:32.780
But perhaps more
importantly, when

00:05:32.780 --> 00:05:35.400
we look at people
leaving one-star reviews,

00:05:35.400 --> 00:05:37.970
we've seen an
almost 20% decrease

00:05:37.970 --> 00:05:41.090
in the number of people talking
about things like stability

00:05:41.090 --> 00:05:43.550
and bugs and
battery consumption.

00:05:43.550 --> 00:05:45.980
And that's only possible
because of the incredible work

00:05:45.980 --> 00:05:48.590
that you have done as
a developer community

00:05:48.590 --> 00:05:50.870
to up the quality
of Android apps.

00:05:50.870 --> 00:05:53.270
And for those of you who
are new to the platform,

00:05:53.270 --> 00:05:55.430
it's really important
that you keep pace

00:05:55.430 --> 00:05:57.530
with the rest of the
developer community who

00:05:57.530 --> 00:06:01.290
is helping us move in a
positive performance direction.

00:06:01.290 --> 00:06:03.630
Now, I think, while these
gains at an ecosystem level

00:06:03.630 --> 00:06:05.550
are interesting,
you might wonder

00:06:05.550 --> 00:06:07.290
as an individual
developer, yeah,

00:06:07.290 --> 00:06:09.570
but how does that
really matter to me?

00:06:09.570 --> 00:06:11.970
Well, I want to showcase
a couple of examples

00:06:11.970 --> 00:06:15.420
of where individual developers
have seen incredible gains

00:06:15.420 --> 00:06:18.790
because of Android Vitals.

00:06:18.790 --> 00:06:20.730
One of my favorite case
studies is Starbucks.

00:06:20.730 --> 00:06:23.170
Now, Starbucks is obviously
an incredibly popular app.

00:06:23.170 --> 00:06:25.410
They have over 15
million downloads

00:06:25.410 --> 00:06:27.450
on the Google Play Store.

00:06:27.450 --> 00:06:30.930
They started using Android
Vitals in December,

00:06:30.930 --> 00:06:33.660
admittedly, several months
after the launch of the program.

00:06:33.660 --> 00:06:35.820
Now, when they started
using Android Vitals,

00:06:35.820 --> 00:06:37.980
they were alerted
to ANR issues that

00:06:37.980 --> 00:06:40.290
were not even on their radar.

00:06:40.290 --> 00:06:43.080
And they were able to use
the reporting in the console

00:06:43.080 --> 00:06:46.220
to identify common underlying
causes for the ANRs

00:06:46.220 --> 00:06:48.540
that were caused by a
third party library.

00:06:48.540 --> 00:06:50.250
They removed that
third party library,

00:06:50.250 --> 00:06:54.827
and saw a 70% reduction
in ANR rate within a week.

00:06:54.827 --> 00:06:56.910
Now, they saw a similar,
and actually even better,

00:06:56.910 --> 00:06:58.620
experience with crash rate.

00:06:58.620 --> 00:07:01.800
Because Android Vitals
is a platform-level tool,

00:07:01.800 --> 00:07:06.270
it's able to detect crashes that
were not detected by Starbucks'

00:07:06.270 --> 00:07:09.900
third party crash SDK, because
these crashes were happening

00:07:09.900 --> 00:07:12.900
at app start before
Starbucks' third party

00:07:12.900 --> 00:07:16.020
crash SDK had even initiated.

00:07:16.020 --> 00:07:18.060
Using the Vitals
reporting, they were

00:07:18.060 --> 00:07:21.570
able to identify an
underlying cause, push a fix,

00:07:21.570 --> 00:07:25.590
and they saw an 85% reduction
in crash rate within a week.

00:07:25.590 --> 00:07:28.370
These are impressive stats.

00:07:28.370 --> 00:07:30.480
Now, it's worth calling
out that Vitals,

00:07:30.480 --> 00:07:32.070
and this is the
common misconception,

00:07:32.070 --> 00:07:33.210
is not just for apps.

00:07:33.210 --> 00:07:35.640
It's equally relevant for games.

00:07:35.640 --> 00:07:38.790
A great example comes
from Kiloo, developers

00:07:38.790 --> 00:07:41.820
of the super popular Subway
Surfers app, which was actually

00:07:41.820 --> 00:07:44.010
the first game to
pass the 1 billion

00:07:44.010 --> 00:07:47.520
install mark on Google Play.

00:07:47.520 --> 00:07:50.640
When Subway Surfers started
using Android Vitals,

00:07:50.640 --> 00:07:53.690
they discovered a sudden
increase in ANR rate,

00:07:53.690 --> 00:07:57.480
used the reports to identify
a cause, and pushed a fix,

00:07:57.480 --> 00:08:00.720
and saw a reduction of
their ANR rate from 2%

00:08:00.720 --> 00:08:05.012
to below 0.1%, a 95% reduction.

00:08:05.012 --> 00:08:06.720
But I think what's
worth calling out here

00:08:06.720 --> 00:08:08.340
is what we found afterward.

00:08:08.340 --> 00:08:10.550
So we did an analysis
at Google Play

00:08:10.550 --> 00:08:12.990
of what was the change of
engagement with the app

00:08:12.990 --> 00:08:15.060
before and after the fix.

00:08:15.060 --> 00:08:17.400
And we saw really
substantive gains

00:08:17.400 --> 00:08:21.150
in both daily active users
and in sessions for users

00:08:21.150 --> 00:08:23.040
across the board.

00:08:23.040 --> 00:08:25.350
Now, these are just two
examples of developers

00:08:25.350 --> 00:08:27.540
who have been able to
leverage the platform

00:08:27.540 --> 00:08:30.510
to see really significant
gains both at a performance

00:08:30.510 --> 00:08:32.190
and a business level.

00:08:32.190 --> 00:08:33.720
Now I'm going to
invite up Fergus,

00:08:33.720 --> 00:08:36.270
product manager for Vitals,
who's going to talk about some

00:08:36.270 --> 00:08:39.150
of the ways that we're enhancing
the platform to make it even

00:08:39.150 --> 00:08:40.650
more powerful for developers.

00:08:44.479 --> 00:08:45.520
FERGUS HURLEY: Great job.

00:08:49.420 --> 00:08:50.800
Hey, everyone.

00:08:50.800 --> 00:08:53.440
I'm Fergus Hurley, product
manager for Android Vitals.

00:08:53.440 --> 00:08:55.450
It's been incredible
to see the improvements

00:08:55.450 --> 00:08:57.910
that app developers, like
yourselves, have made

00:08:57.910 --> 00:09:00.475
over the past year as a
result of using the tools

00:09:00.475 --> 00:09:01.910
that we've made available.

00:09:01.910 --> 00:09:04.469
It's also been incredible to
get all the feedback from you as

00:09:04.469 --> 00:09:06.010
to how we can improve
Android Vitals.

00:09:06.010 --> 00:09:08.290
I'm really excited to
show you the new features

00:09:08.290 --> 00:09:10.640
we have available today as
a result of your feedback.

00:09:10.640 --> 00:09:11.515
So thank you so much.

00:09:15.147 --> 00:09:16.980
Last year, when we
announced Android Vitals,

00:09:16.980 --> 00:09:20.010
as Joel mentioned, we launched
three performance areas,

00:09:20.010 --> 00:09:22.290
battery, stability,
and rendering.

00:09:22.290 --> 00:09:25.800
Today, we're announcing
two new areas, startup time

00:09:25.800 --> 00:09:26.950
and permissions.

00:09:29.759 --> 00:09:32.050
Battery is probably the most
important performance area

00:09:32.050 --> 00:09:32.980
to focus on.

00:09:32.980 --> 00:09:35.200
This is where you
should not unnecessarily

00:09:35.200 --> 00:09:39.040
use the CPU or the radios
on the device, which

00:09:39.040 --> 00:09:41.080
drains the users'
batteries, which means they

00:09:41.080 --> 00:09:44.350
can't use your app as long.

00:09:44.350 --> 00:09:46.840
Stability is all about
building a robust and reliable

00:09:46.840 --> 00:09:50.530
application, so the users
are using your application

00:09:50.530 --> 00:09:53.950
without freezes or crashes.

00:09:53.950 --> 00:09:56.890
And rendering is all about
building a fast and responsive

00:09:56.890 --> 00:10:00.920
application that's silky
smooth and doesn't lag or stall

00:10:00.920 --> 00:10:01.420
on users.

00:10:04.170 --> 00:10:05.889
With startup time,
we're enabling

00:10:05.889 --> 00:10:07.680
you to be able to
provide a quick launching

00:10:07.680 --> 00:10:10.560
application to your users, no
matter what state your app has

00:10:10.560 --> 00:10:11.565
been in.

00:10:11.565 --> 00:10:13.440
There's three different
metrics we have here.

00:10:13.440 --> 00:10:15.850
And I'm going to go
through each one.

00:10:15.850 --> 00:10:18.000
So, first, we have
slow cold start.

00:10:18.000 --> 00:10:20.670
Slow here is defined as
five seconds or more.

00:10:20.670 --> 00:10:23.400
And cold start is
when your app has not

00:10:23.400 --> 00:10:25.050
been launched in a
while, and is going

00:10:25.050 --> 00:10:27.380
from activity launched
to activity running,

00:10:27.380 --> 00:10:30.720
and the app is not in memory.

00:10:30.720 --> 00:10:33.870
Slow warm start is where it
takes two seconds or more

00:10:33.870 --> 00:10:37.490
for your app to go from activity
launched to activity running,

00:10:37.490 --> 00:10:39.330
where your app is in memory.

00:10:42.060 --> 00:10:45.540
Final startup time metric
we have is slow hot start.

00:10:45.540 --> 00:10:50.400
This is where your app goes from
onRestart to activity running.

00:10:50.400 --> 00:10:52.540
And it takes longer
than 1.5 seconds.

00:10:52.540 --> 00:10:55.490
This is where your app and
your activity is in memory.

00:10:58.670 --> 00:11:01.350
Another new performance
area we have is permissions.

00:11:01.350 --> 00:11:04.770
This is where we want to help
you be able to only request

00:11:04.770 --> 00:11:07.560
permissions that users
think are required

00:11:07.560 --> 00:11:09.930
for the core value
of your application

00:11:09.930 --> 00:11:11.410
to be provided to them.

00:11:11.410 --> 00:11:14.064
And if they don't think so,
then provide them justification

00:11:14.064 --> 00:11:15.480
why you think they
should actually

00:11:15.480 --> 00:11:19.510
provide that information.

00:11:19.510 --> 00:11:21.190
When we ask users,
"What are the reasons

00:11:21.190 --> 00:11:24.140
that you deny permissions
for applications?",

00:11:24.140 --> 00:11:26.519
what we find is that the
vast majority of them

00:11:26.519 --> 00:11:28.810
just think that the app
doesn't need those permissions.

00:11:28.810 --> 00:11:30.610
So really providing
a justification

00:11:30.610 --> 00:11:34.654
is critical for you to get
users to be able to give you

00:11:34.654 --> 00:11:36.070
the permission
that you need to be

00:11:36.070 --> 00:11:38.050
able to offer the best
functionality possible

00:11:38.050 --> 00:11:40.610
in your application.

00:11:40.610 --> 00:11:43.270
In the details view
for permissions,

00:11:43.270 --> 00:11:45.970
we provide a breakdown
by permission group.

00:11:45.970 --> 00:11:48.040
So, maybe one of your
permissions users

00:11:48.040 --> 00:11:51.070
think your app does need,
and you get a high percentage

00:11:51.070 --> 00:11:52.859
of acceptance for that one.

00:11:52.859 --> 00:11:54.900
And then another one,
users don't think you need,

00:11:54.900 --> 00:11:57.070
and you get a high
denial rate for that one.

00:11:57.070 --> 00:11:58.950
And maybe you don't need that
permission in the first place.

00:11:58.950 --> 00:11:59.930
So maybe you should rethink it.

00:11:59.930 --> 00:12:02.221
Or maybe you just need to
explain to users why your app

00:12:02.221 --> 00:12:05.910
does need that permission.

00:12:05.910 --> 00:12:09.070
We have many other breakdowns
across the Vitals product.

00:12:09.070 --> 00:12:12.400
For most Vitals, we break
it down by app version,

00:12:12.400 --> 00:12:15.250
by device, and by
Android version.

00:12:15.250 --> 00:12:18.670
For wake locks and
wakeups, we provide by tag.

00:12:18.670 --> 00:12:24.730
For ANRs, we provide by
ANR type and ANR name.

00:12:24.730 --> 00:12:27.460
We also provide
the clusters view

00:12:27.460 --> 00:12:29.800
for grouping your
ANRs together, so you

00:12:29.800 --> 00:12:32.170
can be able to see
which ones are similar,

00:12:32.170 --> 00:12:35.160
and be able to debug
those clusters.

00:12:35.160 --> 00:12:36.760
For crashes, we also
provide clusters.

00:12:40.110 --> 00:12:43.200
When I've been building
apps at Google, and prior

00:12:43.200 --> 00:12:45.660
to Google, one of the things
I struggled with the most was

00:12:45.660 --> 00:12:47.310
being able to
understand, how do I

00:12:47.310 --> 00:12:50.290
compare with other apps that
offer similar functionality?

00:12:50.290 --> 00:12:52.020
Who else has struggled
with understanding

00:12:52.020 --> 00:12:55.495
if their app is performing
well compared to other apps?

00:12:55.495 --> 00:12:59.580
OK, lots of people share the
same struggle as I've had.

00:12:59.580 --> 00:13:03.300
We are now going to announce
category level benchmarks

00:13:03.300 --> 00:13:04.830
in the Play Console.

00:13:04.830 --> 00:13:08.430
This enables you to be able
to see, OK, for start time,

00:13:08.430 --> 00:13:11.790
you can see here, that
board games are much faster

00:13:11.790 --> 00:13:14.190
at starting than racing games.

00:13:14.190 --> 00:13:19.530
And we also provide the 25th,
50th and 75th percentile

00:13:19.530 --> 00:13:22.730
breakdown for each of the
category level benchmarks.

00:13:22.730 --> 00:13:25.080
We'll default to the category
that you list yourself

00:13:25.080 --> 00:13:27.257
in the store, but you can
select any other category

00:13:27.257 --> 00:13:29.340
that you want to be able
to compare yourself with,

00:13:29.340 --> 00:13:31.710
in case you don't think
that your app is as related

00:13:31.710 --> 00:13:34.380
to that category.

00:13:34.380 --> 00:13:36.330
On the details page
for every vital,

00:13:36.330 --> 00:13:39.600
we show you this breakdown
for the category benchmark.

00:13:39.600 --> 00:13:41.100
And then you can
be able to also see

00:13:41.100 --> 00:13:44.640
what exact percentage you are
relative to the other apps

00:13:44.640 --> 00:13:45.714
in that category.

00:13:50.460 --> 00:13:54.160
On the redesigned Android
Vitals overview page,

00:13:54.160 --> 00:13:57.010
we show you each of the metrics
in the performance area.

00:13:57.010 --> 00:13:59.320
We show you what was your
percentage of users impacted

00:13:59.320 --> 00:14:02.230
in the last 30 days, what
was the percentage of users

00:14:02.230 --> 00:14:04.270
impacted in the
previous 30 days,

00:14:04.270 --> 00:14:07.270
and we show you the
benchmark comparison.

00:14:07.270 --> 00:14:09.070
This enables you to
be to quickly see, OK,

00:14:09.070 --> 00:14:10.570
which one of these
performance areas

00:14:10.570 --> 00:14:11.800
should I actually look into?

00:14:11.800 --> 00:14:14.487
And which specific metric
might require more attention?

00:14:14.487 --> 00:14:16.570
And so you can see here,
the last one on the list.

00:14:16.570 --> 00:14:17.715
You're in the bottom 12%.

00:14:17.715 --> 00:14:19.589
That's probably when
you want to investigate.

00:14:23.744 --> 00:14:25.910
The Weather Channel has
been an early access partner

00:14:25.910 --> 00:14:28.250
for these features that
we're showing today

00:14:28.250 --> 00:14:29.730
for the past couple of weeks.

00:14:29.730 --> 00:14:31.813
And one of the pieces of
feedback that they've had

00:14:31.813 --> 00:14:33.470
is it's been really
great for them

00:14:33.470 --> 00:14:35.660
to be able to use
category level benchmarks

00:14:35.660 --> 00:14:37.970
to make the case
within their company

00:14:37.970 --> 00:14:40.640
as to why they should invest
in performance, because they

00:14:40.640 --> 00:14:44.570
can show how they stack
up versus competing apps.

00:14:44.570 --> 00:14:46.950
I hope you're able to use
similar data to be able to make

00:14:46.950 --> 00:14:49.595
the case within your company.

00:14:49.595 --> 00:14:52.220
If you want to learn more about
benchmarks in the Play Console,

00:14:52.220 --> 00:14:54.940
we have a session
tomorrow at 9:30 AM.

00:14:58.390 --> 00:15:00.700
Although all Android
Vitals should

00:15:00.700 --> 00:15:05.020
be viewed as ways to
be able to enhance

00:15:05.020 --> 00:15:06.610
the experience of
your application,

00:15:06.610 --> 00:15:09.970
some vitals are more important
to offering the best user

00:15:09.970 --> 00:15:11.310
experience possible.

00:15:11.310 --> 00:15:14.740
And so that's why we're
putting this feature

00:15:14.740 --> 00:15:16.840
at the top of the
Android Vitals overview

00:15:16.840 --> 00:15:18.730
page, which is core vitals.

00:15:18.730 --> 00:15:21.250
These are the vitals that you
should pay most attention to.

00:15:21.250 --> 00:15:24.910
These are the ones that will
impact your promotability

00:15:24.910 --> 00:15:27.610
and ranking in the store,
along with many other signals.

00:15:27.610 --> 00:15:29.875
But you should really pay
attention to these signals.

00:15:33.210 --> 00:15:37.020
You'll see the
list of the vitals.

00:15:37.020 --> 00:15:38.476
Here we have the initial four.

00:15:38.476 --> 00:15:39.850
So, stop partial
wakelocks, where

00:15:39.850 --> 00:15:42.330
you hold a wakelock for over
an hour in the background.

00:15:42.330 --> 00:15:43.830
Excessive wakeups,
where you have

00:15:43.830 --> 00:15:45.570
10 wakeups happening per hour.

00:15:45.570 --> 00:15:49.980
ANR rate, where you have
a user experience the app

00:15:49.980 --> 00:15:52.442
not responding for five
seconds or more in a day.

00:15:52.442 --> 00:15:54.650
And a crash rate, where they
have one crash in a day.

00:15:57.990 --> 00:16:03.050
If you're in the bottom 25%
for any of these core vitals,

00:16:03.050 --> 00:16:05.340
then you'll be flagged
as having a bad behavior.

00:16:05.340 --> 00:16:09.260
This is where you'll
see a tile at the top

00:16:09.260 --> 00:16:11.500
of the core vital
section to alert you.

00:16:11.500 --> 00:16:13.190
And when you click
on that tile, you'll

00:16:13.190 --> 00:16:15.020
be able to go into
the details view,

00:16:15.020 --> 00:16:18.554
and see which specific APK is
exhibiting that bad behavior.

00:16:18.554 --> 00:16:19.970
And we provide you
the information

00:16:19.970 --> 00:16:21.290
to help you debug that issue.

00:16:24.410 --> 00:16:25.970
One of the major
requests that we've

00:16:25.970 --> 00:16:28.370
had over the past
year is to get alerted

00:16:28.370 --> 00:16:31.970
when there is an issue that's
introduced with their vitals.

00:16:31.970 --> 00:16:34.890
And so we're really happy to
announce anomaly detection.

00:16:34.890 --> 00:16:37.160
So this is where
you'll get flagged

00:16:37.160 --> 00:16:40.790
with an alert at the top of
your Android Vital section,

00:16:40.790 --> 00:16:44.210
are they in crash clusters,
to let you know what

00:16:44.210 --> 00:16:45.999
is the issue that you have.

00:16:45.999 --> 00:16:47.540
And you can click
on that tile and be

00:16:47.540 --> 00:16:50.760
able to go in and see details.

00:16:50.760 --> 00:16:53.620
You can also be able to
sign up to get email alerts,

00:16:53.620 --> 00:16:56.660
when one of these
anomalis is detected.

00:16:56.660 --> 00:16:58.400
And when you get
one of those emails,

00:16:58.400 --> 00:17:01.334
there's a link
directly to the issue.

00:17:01.334 --> 00:17:02.750
So you can be able
to investigate.

00:17:02.750 --> 00:17:04.669
OK, when did this issue occur?

00:17:04.669 --> 00:17:05.960
And for how long did it happen?

00:17:09.359 --> 00:17:12.140
The Big Fish games team that
have built many games that

00:17:12.140 --> 00:17:14.060
have reached over
10 million installs

00:17:14.060 --> 00:17:17.000
have found great results
using these tools

00:17:17.000 --> 00:17:19.280
by being an early access
partner for these features

00:17:19.280 --> 00:17:20.730
over the past couple of months.

00:17:20.730 --> 00:17:22.229
And they've reduced
their crash rate

00:17:22.229 --> 00:17:25.430
by 45% for one of
their top games.

00:17:25.430 --> 00:17:27.530
I'm now going to
hand over to Wojtek

00:17:27.530 --> 00:17:30.757
to talk about how you can debug
and improve your specific core

00:17:30.757 --> 00:17:31.340
vitals issues.

00:17:35.469 --> 00:17:37.010
WOJTEK KALICINSKI:
Thank you, Fergus.

00:17:37.010 --> 00:17:38.060
So, hi, everyone.

00:17:38.060 --> 00:17:39.020
My name is Wojtek.

00:17:39.020 --> 00:17:41.030
I work on the Developer
Relations team.

00:17:41.030 --> 00:17:43.670
And I work closely with
the Android teams at Google

00:17:43.670 --> 00:17:46.160
to help you developers
build better apps.

00:17:46.160 --> 00:17:48.050
And today I want
to talk about how

00:17:48.050 --> 00:17:49.880
you can fix some of
these core vitals

00:17:49.880 --> 00:17:54.050
that Fergus mentioned in
your apps, in your code.

00:17:54.050 --> 00:17:57.660
And, first, I want to
start with stability.

00:17:57.660 --> 00:18:00.180
And let's talk a
little bit about ANRs.

00:18:00.180 --> 00:18:02.550
So we keep saying this
acronym, right, ANRs,

00:18:02.550 --> 00:18:03.840
but what are they really?

00:18:03.840 --> 00:18:06.180
So ANRs, in other
words, application not

00:18:06.180 --> 00:18:07.410
responding events.

00:18:07.410 --> 00:18:10.680
Now this happens
whenever in your app

00:18:10.680 --> 00:18:13.834
some long running operation
blocks your main thread.

00:18:13.834 --> 00:18:15.750
Now, the main thread is
responsible for things

00:18:15.750 --> 00:18:18.930
like responding to user
events, such as taps

00:18:18.930 --> 00:18:21.730
or redrawing the
UI for every frame.

00:18:21.730 --> 00:18:25.110
So if we block it, if the
main thread cannot do that

00:18:25.110 --> 00:18:28.470
in a timely manner, the
app will just seem frozen.

00:18:28.470 --> 00:18:31.520
And then after a few seconds,
the system will notice that,

00:18:31.520 --> 00:18:33.630
and will pop up this
annoying dialogue

00:18:33.630 --> 00:18:36.040
that lets the user
actually close the app.

00:18:36.040 --> 00:18:39.460
And as developers, we really
don't want that to happen.

00:18:39.460 --> 00:18:42.090
So what are some
common causes of ANRs.

00:18:42.090 --> 00:18:46.270
What kind of operations
can block our main thread?

00:18:46.270 --> 00:18:50.470
Well, probably the most common
ones are network and disk

00:18:50.470 --> 00:18:54.840
operations, also call this I/O.
Now, networks are congested.

00:18:54.840 --> 00:18:57.320
Remote servers are slow.

00:18:57.320 --> 00:18:59.820
So can be our flash
drives, or the file system

00:18:59.820 --> 00:19:02.430
can be busy with
other operations.

00:19:02.430 --> 00:19:06.240
And so, as developers, we should
never, never do network or disk

00:19:06.240 --> 00:19:08.490
operations on the main thread.

00:19:08.490 --> 00:19:11.130
But I just prepared
two code examples

00:19:11.130 --> 00:19:14.340
to show you that it's not always
easy to do the right thing.

00:19:14.340 --> 00:19:17.190
Even though you all
probably agree with me,

00:19:17.190 --> 00:19:19.160
we can still make mistakes.

00:19:19.160 --> 00:19:22.230
So here, for example,
in my activity onCreate,

00:19:22.230 --> 00:19:24.450
I decided, well, I'm
just going to prepare

00:19:24.450 --> 00:19:26.530
this shared preferences
object to use later.

00:19:26.530 --> 00:19:28.530
I'm just going to
create it and not

00:19:28.530 --> 00:19:30.354
do anything with it right now.

00:19:30.354 --> 00:19:31.770
And then somewhere
else in my app,

00:19:31.770 --> 00:19:33.252
probably on a
background thread, I

00:19:33.252 --> 00:19:34.710
will actually get
some information,

00:19:34.710 --> 00:19:37.350
like read an integer,
or string, or whatever.

00:19:37.350 --> 00:19:39.510
And I thought, OK, that's good.

00:19:39.510 --> 00:19:42.810
I will not be doing disk
operations on a main thread.

00:19:42.810 --> 00:19:44.490
What I didn't
realize, though, is

00:19:44.490 --> 00:19:47.370
that the implementation of
shared preferences on Android

00:19:47.370 --> 00:19:49.800
actually eagerly
reads data from disk

00:19:49.800 --> 00:19:52.080
the moment you create them.

00:19:52.080 --> 00:19:55.980
So that's actually the line
of code that does disk access.

00:19:55.980 --> 00:19:56.730
So I was wrong.

00:19:56.730 --> 00:19:58.830
It's not always obvious.

00:19:58.830 --> 00:20:02.140
And let me show you another,
even trickier example.

00:20:02.140 --> 00:20:06.180
So here, I'm doing some
hypothetical network operations

00:20:06.180 --> 00:20:07.150
in my app.

00:20:07.150 --> 00:20:09.540
So let's say I want to
check if my intent contains

00:20:09.540 --> 00:20:12.420
some kind of URL So
I'm comparing the two.

00:20:12.420 --> 00:20:15.780
And then I say I want to
open connection to that URL.

00:20:15.780 --> 00:20:20.040
I'm going to save the headers
to some variable for later use.

00:20:20.040 --> 00:20:22.050
And then I actually
open an input stream.

00:20:22.050 --> 00:20:23.540
And finally,
finally, in the end,

00:20:23.540 --> 00:20:26.110
I am reading bytes
from the network.

00:20:26.110 --> 00:20:28.920
So this is a pretty
complicated API, to be honest.

00:20:28.920 --> 00:20:30.930
And how am I as a
developer supposed

00:20:30.930 --> 00:20:34.260
to know if that first line,
openConnection, creates

00:20:34.260 --> 00:20:38.310
the network request and
actually blocks my thread?

00:20:38.310 --> 00:20:40.320
Or is it the last
one, where I actually

00:20:40.320 --> 00:20:44.310
request to read bytes of
data, to actually read them

00:20:44.310 --> 00:20:46.680
into my application?

00:20:46.680 --> 00:20:48.220
Or is it something else?

00:20:48.220 --> 00:20:49.830
And, well, it's not obvious.

00:20:49.830 --> 00:20:52.890
Actually, in this
example, this line of code

00:20:52.890 --> 00:20:55.060
will perform a
network operation.

00:20:55.060 --> 00:20:57.540
The first time I'm
trying to access headers,

00:20:57.540 --> 00:20:59.700
only then will the
connection be opened,

00:20:59.700 --> 00:21:01.680
and the first
bytes will be read.

00:21:01.680 --> 00:21:04.320
And so, as a developer,
again, I failed.

00:21:04.320 --> 00:21:09.770
I didn't know which operation
does the network access.

00:21:09.770 --> 00:21:14.620
But, fun fact, on an even older
Android version, this line,

00:21:14.620 --> 00:21:19.470
just checking if URLs are equal,
can perform network operations.

00:21:19.470 --> 00:21:22.740
OK, so why am I
showing you all this?

00:21:22.740 --> 00:21:26.640
Because I want to convince
you that, as developers,

00:21:26.640 --> 00:21:27.900
we cannot know everything.

00:21:27.900 --> 00:21:29.910
And you will use
libraries that you're not

00:21:29.910 --> 00:21:32.160
familiar with, or other APIs.

00:21:32.160 --> 00:21:35.250
And that's why I suggest you
use StrictMode for your debug

00:21:35.250 --> 00:21:37.440
builds while you
develop your apps.

00:21:37.440 --> 00:21:39.780
Now, StrictMode is an API
that existed on Android

00:21:39.780 --> 00:21:41.850
for a long time.

00:21:41.850 --> 00:21:43.330
And it's pretty easy to set up.

00:21:43.330 --> 00:21:45.960
You just set a thread
policy in your application

00:21:45.960 --> 00:21:49.230
on Create, or in your
activity onCreate,

00:21:49.230 --> 00:21:51.030
and you tell
StrictMode, I want you

00:21:51.030 --> 00:21:55.380
to detect all disk operations in
my application on this thread.

00:21:55.380 --> 00:21:58.530
And I also want you to
detect network operations.

00:21:58.530 --> 00:22:01.690
And then you tell StrictMode
what you want the result to be.

00:22:01.690 --> 00:22:04.770
So, first of all, of course,
we want to see it in logs,

00:22:04.770 --> 00:22:06.520
so we can debug it later.

00:22:06.520 --> 00:22:10.770
But logs are easy to miss, like
LogCat can be noisy sometimes.

00:22:10.770 --> 00:22:12.420
So for my debug
builds, I'm also going

00:22:12.420 --> 00:22:14.760
to go and say penaltyDeath,
which will actually

00:22:14.760 --> 00:22:17.790
crash my app whenever I do the
wrong thing and access network

00:22:17.790 --> 00:22:19.657
or disk on the main thread.

00:22:19.657 --> 00:22:21.240
Now, like I said,
you don't want to do

00:22:21.240 --> 00:22:23.430
any of that in your
production release builds,

00:22:23.430 --> 00:22:25.890
because you don't want
your users app to crash.

00:22:25.890 --> 00:22:29.460
OK, so now I go back and run
my code that I just showed you

00:22:29.460 --> 00:22:32.670
and look at my logs, because
my app obviously crashed.

00:22:32.670 --> 00:22:34.560
And I see the exact cause.

00:22:34.560 --> 00:22:36.180
And I can go and debug that.

00:22:36.180 --> 00:22:39.700
So I can see there was a
StrictMode discrete violation.

00:22:39.700 --> 00:22:41.370
And I can see in
the stack trace,

00:22:41.370 --> 00:22:44.670
the culprit is, yeah, it's the
getDefaultSharedPreferences

00:22:44.670 --> 00:22:47.210
call that I did in my
activity on Create.

00:22:47.210 --> 00:22:51.536
So, great, this lets me
actually go and fix that.

00:22:51.536 --> 00:22:53.410
OK, so we covered network
and disk operations

00:22:53.410 --> 00:22:54.940
and how to catch them.

00:22:54.940 --> 00:22:59.530
Sometimes you don't even need
to hit remote servers or disk

00:22:59.530 --> 00:23:01.270
to cause a long
running operation.

00:23:01.270 --> 00:23:03.970
All it takes is literally
just calculating something

00:23:03.970 --> 00:23:07.210
for a long time, doing a
very long loop, and something

00:23:07.210 --> 00:23:08.380
like that.

00:23:08.380 --> 00:23:11.860
So here, in this example,
this is a simple Sudoku game.

00:23:11.860 --> 00:23:15.560
And how it works is, when
the user opens the app,

00:23:15.560 --> 00:23:18.640
the Sudoku board is actually
generated in memory.

00:23:18.640 --> 00:23:19.960
It's not read from disk.

00:23:19.960 --> 00:23:22.630
It's not pulled down
from a server somewhere.

00:23:22.630 --> 00:23:25.150
There's actually a pretty
long complex calculation

00:23:25.150 --> 00:23:27.860
happening to show that
first board to the user,

00:23:27.860 --> 00:23:29.520
so they can play it.

00:23:29.520 --> 00:23:31.670
And so it's just one
call, generateBoard.

00:23:31.670 --> 00:23:33.820
And, as you can see,
on a slow device,

00:23:33.820 --> 00:23:35.320
this could cause
an ANR, because I'm

00:23:35.320 --> 00:23:37.282
doing that on the main thread.

00:23:37.282 --> 00:23:38.740
So, first of all,
how am I supposed

00:23:38.740 --> 00:23:42.190
to know, as a developer, that
this call, generateBoard, can

00:23:42.190 --> 00:23:43.030
be long?

00:23:43.030 --> 00:23:47.080
Well, I really suggest that you
use Android Profiler regularly

00:23:47.080 --> 00:23:49.030
if you ever suspect
there is any performance

00:23:49.030 --> 00:23:50.240
problem in your app.

00:23:50.240 --> 00:23:52.510
So here, for example,
I took a CPU trace

00:23:52.510 --> 00:23:55.690
of the method generateBoard
in the Android Profiler,

00:23:55.690 --> 00:23:57.340
and I can immediately
see that it's

00:23:57.340 --> 00:23:59.470
a complex, recursive
call that takes

00:23:59.470 --> 00:24:02.200
a long, long time to finish.

00:24:02.200 --> 00:24:04.300
And so now I know I
should not be running it

00:24:04.300 --> 00:24:05.620
on the main thread

00:24:05.620 --> 00:24:07.390
Oh, and by the way,
there's a new thing

00:24:07.390 --> 00:24:09.430
in the Android
Profiler that we just

00:24:09.430 --> 00:24:10.840
released in [INAUDIBLE] today.

00:24:10.840 --> 00:24:14.660
Now you can debug and profile
your app startup time.

00:24:14.660 --> 00:24:16.840
So that's pretty handy.

00:24:16.840 --> 00:24:20.320
OK, so going back to our problem
with our generateBoard call.

00:24:20.320 --> 00:24:21.700
What can I do with it?

00:24:21.700 --> 00:24:27.040
So StrictMode has this
method of telling it

00:24:27.040 --> 00:24:29.150
that a call can be slow.

00:24:29.150 --> 00:24:34.090
So here, as a developer, as the
person who created this Sudoku

00:24:34.090 --> 00:24:36.430
algorithm, I will
tell StrictMode

00:24:36.430 --> 00:24:37.930
to note the slow call.

00:24:37.930 --> 00:24:41.080
And now whoever else touches
my code, and is using it,

00:24:41.080 --> 00:24:43.360
and uses StrictMode
as well, if they also

00:24:43.360 --> 00:24:47.680
set the detectCustomSlowCalls
thread policy,

00:24:47.680 --> 00:24:48.940
again, they will get notified.

00:24:48.940 --> 00:24:50.060
Their app will crash.

00:24:50.060 --> 00:24:51.100
They will get the log.

00:24:51.100 --> 00:24:54.010
And they will know to never
call that generateBoard method

00:24:54.010 --> 00:24:55.870
on the main thread.

00:24:55.870 --> 00:25:00.082
All right, so what are
some other causes of ANRs?

00:25:00.082 --> 00:25:01.540
Be careful if you're
doing any kind

00:25:01.540 --> 00:25:04.480
of interprocess communication,
and expect a result.

00:25:04.480 --> 00:25:06.872
Don't do it synchronously
on the main thread.

00:25:06.872 --> 00:25:08.580
If you're calling some
other application,

00:25:08.580 --> 00:25:11.050
if that call is
leading your process,

00:25:11.050 --> 00:25:14.550
you basically don't control
what happens on the other side.

00:25:14.550 --> 00:25:17.230
IPC goes through layers
of the operating system.

00:25:17.230 --> 00:25:19.960
The other process can
access network and disk

00:25:19.960 --> 00:25:22.146
to service your request.

00:25:22.146 --> 00:25:24.270
So just remember to do it
on the background thread.

00:25:27.380 --> 00:25:29.330
The next thing is
multi-threaded programming.

00:25:29.330 --> 00:25:31.970
And that's a really,
really difficult topic.

00:25:31.970 --> 00:25:35.120
We could have a whole
other session about this.

00:25:35.120 --> 00:25:40.040
But if you ever find yourself
touching low level, primitives

00:25:40.040 --> 00:25:42.620
such as locks and
synchronization,

00:25:42.620 --> 00:25:44.300
eventually, there's
a high chance

00:25:44.300 --> 00:25:46.175
you'll create a deadlock
in your application,

00:25:46.175 --> 00:25:49.250
or hit some other problem
that blocks your main thread.

00:25:49.250 --> 00:25:52.260
And these are very
tricky to debug.

00:25:52.260 --> 00:25:56.012
However, Android
Vitals does give you

00:25:56.012 --> 00:25:57.470
some information
that will help you

00:25:57.470 --> 00:25:59.130
debug these kinds of problems.

00:25:59.130 --> 00:26:02.450
So if you open any ANR
in the Vitals console,

00:26:02.450 --> 00:26:04.640
we actually provide you
with the trace files,

00:26:04.640 --> 00:26:08.960
pulled from the devices that
suffered from these ANRs.

00:26:08.960 --> 00:26:10.940
So you can look at
thread states and see

00:26:10.940 --> 00:26:13.010
if they were blocked
waiting on any resource

00:26:13.010 --> 00:26:14.150
to become available.

00:26:14.150 --> 00:26:16.190
And we even highlight
the problems

00:26:16.190 --> 00:26:20.430
that we think might be
happening in this trace.

00:26:20.430 --> 00:26:23.460
OK, and then last thing I
want to mention is, as a cause

00:26:23.460 --> 00:26:26.490
of ANRs, is slow
BroadcastReceiver handling.

00:26:26.490 --> 00:26:29.940
Now, not every developer
realizes that if you set up

00:26:29.940 --> 00:26:32.470
a BroadcastReceiver in
your Android manifest,

00:26:32.470 --> 00:26:35.280
and then it gets cold, that
the onReceive method actually

00:26:35.280 --> 00:26:36.470
happens on the main thread.

00:26:36.470 --> 00:26:39.120
And you're not supposed to
perform any long running

00:26:39.120 --> 00:26:40.410
operations in it.

00:26:40.410 --> 00:26:43.200
And there is a time
out, about 10 seconds,

00:26:43.200 --> 00:26:45.720
that the system will
allow this method to run.

00:26:45.720 --> 00:26:48.400
And then it will
kill your process.

00:26:48.400 --> 00:26:51.810
And so sometimes,
though, whenever

00:26:51.810 --> 00:26:54.300
you're using a
BroadcastReceiver, maybe

00:26:54.300 --> 00:26:56.400
to show a notification
to the user,

00:26:56.400 --> 00:26:59.070
maybe you still need
a little piece of data

00:26:59.070 --> 00:27:03.630
maybe from the disk, reading
some name or a profile picture

00:27:03.630 --> 00:27:05.490
to show you a notification,
so you actually

00:27:05.490 --> 00:27:07.380
need to do that
this disk access.

00:27:07.380 --> 00:27:09.690
So what can you do in this case?

00:27:09.690 --> 00:27:13.410
Now, BroadcastReceivers have
this method called goAsync.

00:27:13.410 --> 00:27:16.170
It's basically a way to
tell the BroadcastReceiver

00:27:16.170 --> 00:27:18.915
from the onReceive method
that you need to do

00:27:18.915 --> 00:27:20.910
some longer running operation.

00:27:20.910 --> 00:27:23.670
And then you spin up a
separate thread yourself.

00:27:23.670 --> 00:27:26.070
You do the operation,
and then remember

00:27:26.070 --> 00:27:27.900
to call finish when you're done.

00:27:27.900 --> 00:27:30.120
If you don't do that,
the system will still

00:27:30.120 --> 00:27:32.820
realize that you're blocking
and might potentially

00:27:32.820 --> 00:27:34.890
kill your app.

00:27:34.890 --> 00:27:36.960
And, remember, don't
treat this as some kind

00:27:36.960 --> 00:27:38.160
of long running service.

00:27:38.160 --> 00:27:40.830
This is not the case
for BroadcastReceivers.

00:27:40.830 --> 00:27:43.120
And a reasonable time
limit still applies.

00:27:43.120 --> 00:27:45.510
So you should literally just
grab the things you need,

00:27:45.510 --> 00:27:49.910
and the separate thread, and
finish as soon as possible

00:27:49.910 --> 00:27:52.870
OK, let's talk a little
bit about crashes.

00:27:52.870 --> 00:27:56.460
You know, it's really difficult
to give general advice on how

00:27:56.460 --> 00:27:58.560
to avoid crashes in
a setting like this,

00:27:58.560 --> 00:28:00.060
because every app
will be different.

00:28:00.060 --> 00:28:01.840
Every crash will be different.

00:28:01.840 --> 00:28:03.630
However, I can give
you some advice

00:28:03.630 --> 00:28:05.990
that I think might be helpful.

00:28:05.990 --> 00:28:08.940
So for years, as an
Android developer,

00:28:08.940 --> 00:28:12.510
I've seen my code, or
code from other people,

00:28:12.510 --> 00:28:14.300
start very simple.

00:28:14.300 --> 00:28:16.860
And we release something,
and then things

00:28:16.860 --> 00:28:18.630
start crashing on
users' devices.

00:28:18.630 --> 00:28:20.910
And so we add all
these safety measures,

00:28:20.910 --> 00:28:23.850
like checking for nulls
everywhere, and checking

00:28:23.850 --> 00:28:25.770
for activity life cycles.

00:28:25.770 --> 00:28:29.160
And then if that fails, we just
drop everything in a try-catch,

00:28:29.160 --> 00:28:32.460
and just hope that this problem
doesn't hit too many users.

00:28:32.460 --> 00:28:35.250
But that's not is not the
greatest solution, right?

00:28:35.250 --> 00:28:39.064
It doesn't actually solve
the underlying problem.

00:28:39.064 --> 00:28:40.980
And that's why my first
piece of advice to you

00:28:40.980 --> 00:28:43.320
is don't try to
reinvent the wheel.

00:28:43.320 --> 00:28:48.690
And use readily available
libraries that solve problems

00:28:48.690 --> 00:28:50.490
that you, as developers, face.

00:28:50.490 --> 00:28:54.950
Now, some of the most
difficult parts of Android--

00:28:54.950 --> 00:28:57.120
we heard about it from
you, from developers--

00:28:57.120 --> 00:28:59.140
is handling life cycles.

00:28:59.140 --> 00:29:04.140
And that's why, last year,
we released the architecture

00:29:04.140 --> 00:29:08.190
components such as LiveData,
ViewModel, for handling that.

00:29:08.190 --> 00:29:12.030
And also, we released
Room and Paging components

00:29:12.030 --> 00:29:15.780
for loading data into your
application, into your UI.

00:29:15.780 --> 00:29:18.750
This year at I/O, we're
announcing two new components

00:29:18.750 --> 00:29:21.250
as part of the Android
Jetpack initiative.

00:29:21.250 --> 00:29:23.520
This is Navigation
for handling all kinds

00:29:23.520 --> 00:29:25.920
of fragmented activity
transitions and navigation

00:29:25.920 --> 00:29:29.160
problems, and the WorkManager
for scheduling work

00:29:29.160 --> 00:29:30.810
in the background.

00:29:30.810 --> 00:29:32.820
But, you know, you don't
have to use components

00:29:32.820 --> 00:29:33.990
provided by Google.

00:29:33.990 --> 00:29:36.720
There are a lot of great third
party libraries out there.

00:29:36.720 --> 00:29:40.350
And if you think they're useful
to you and your application

00:29:40.350 --> 00:29:41.940
and they will solve
your problems,

00:29:41.940 --> 00:29:45.126
feel free to use them as well.

00:29:45.126 --> 00:29:47.250
OK, the second thing I want
to mention when talking

00:29:47.250 --> 00:29:49.140
about crashes is Kotlin.

00:29:49.140 --> 00:29:51.140
Now, also last year
at I/O, we announced

00:29:51.140 --> 00:29:53.610
Kotlin as a first class
supported language

00:29:53.610 --> 00:29:55.300
for Android developers.

00:29:55.300 --> 00:29:57.690
And, before I say
anything more, let

00:29:57.690 --> 00:30:00.220
me just say that I know
it's not a silver bullet.

00:30:00.220 --> 00:30:03.340
It will not solve all your
crashes in your application.

00:30:03.340 --> 00:30:05.490
However, because
of the null safety

00:30:05.490 --> 00:30:07.620
that's built right
into the language,

00:30:07.620 --> 00:30:10.830
it can save you from some
common classes of errors

00:30:10.830 --> 00:30:13.380
that you might
otherwise hit if you

00:30:13.380 --> 00:30:15.570
build your apps with just Java.

00:30:15.570 --> 00:30:18.210
And some of the other
nice things about Kotlin

00:30:18.210 --> 00:30:21.150
are that it's highly
interoperable with existing

00:30:21.150 --> 00:30:22.020
Java code.

00:30:22.020 --> 00:30:25.440
So you don't have to go all
in and transform all your apps

00:30:25.440 --> 00:30:26.010
into Kotlin.

00:30:26.010 --> 00:30:28.740
You can start slowly adding
it into your applications

00:30:28.740 --> 00:30:30.290
and see if it helps you.

00:30:30.290 --> 00:30:33.270
And actually,
developers love Kotlin.

00:30:33.270 --> 00:30:35.460
And we are seeing
a steady uptake

00:30:35.460 --> 00:30:37.540
in Kotlin usage in Android apps.

00:30:37.540 --> 00:30:39.190
And it's also easy
and fun to learn.

00:30:39.190 --> 00:30:41.460
So I really encourage, if
you haven't tried it yet,

00:30:41.460 --> 00:30:43.410
it's fully supported
by us, and you're

00:30:43.410 --> 00:30:46.124
free to use it in
your applications.

00:30:46.124 --> 00:30:48.540
And the last thing about crashes
that I want to talk about

00:30:48.540 --> 00:30:51.300
is private and hidden APIs.

00:30:51.300 --> 00:30:54.090
Now we offer an
SDK to developers

00:30:54.090 --> 00:30:57.540
that's backed by
documentation and, basically,

00:30:57.540 --> 00:31:00.240
public methods, public
interfaces, that you can use.

00:31:00.240 --> 00:31:03.450
But developers are finding
ways to access methods

00:31:03.450 --> 00:31:06.510
in the Android framework that
exist on devices that were

00:31:06.510 --> 00:31:08.550
never intended for you to use.

00:31:08.550 --> 00:31:12.180
And that's not because we
don't like you, as developers,

00:31:12.180 --> 00:31:14.310
we don't want to
give you nice things.

00:31:14.310 --> 00:31:17.900
It's just because these APIs
are not ready to be used.

00:31:17.900 --> 00:31:19.710
They're not guaranteed to exist.

00:31:19.710 --> 00:31:23.640
They might be implementation
details on a certain device.

00:31:23.640 --> 00:31:26.490
We might even remove them
on the next Android version.

00:31:26.490 --> 00:31:30.120
Or a device manufacturer
can go and customize Android

00:31:30.120 --> 00:31:31.770
to remove them as well.

00:31:31.770 --> 00:31:35.220
The thing is, you should never
use private or hidden APIs

00:31:35.220 --> 00:31:36.300
in your apps.

00:31:36.300 --> 00:31:38.760
But, in order to enforce
that, and to actually

00:31:38.760 --> 00:31:41.540
help you make your
apps crash less,

00:31:41.540 --> 00:31:44.985
in case these APIs change,
we're introducing restrictions

00:31:44.985 --> 00:31:49.500
and Android P developer
preview that means,

00:31:49.500 --> 00:31:52.470
basically, you have to stop
using private and hidden APIs

00:31:52.470 --> 00:31:53.490
in your apps.

00:31:53.490 --> 00:31:58.230
And we did a similar thing in
Android Nougat with the NDK,

00:31:58.230 --> 00:32:01.500
where we said you can no
longer access libraries that

00:32:01.500 --> 00:32:03.990
exist on the system
partition if they're not

00:32:03.990 --> 00:32:07.890
exposed by public NDK APIs.

00:32:07.890 --> 00:32:10.575
So, please, if you can
migrate from private APIs

00:32:10.575 --> 00:32:13.350
to public API, they are
documented and guaranteed

00:32:13.350 --> 00:32:15.945
to work to make your apps safer.

00:32:18.740 --> 00:32:21.660
And let's talk a little bit
about battery and stuck wake

00:32:21.660 --> 00:32:22.390
locks.

00:32:22.390 --> 00:32:25.850
So wake locks, it's an API
that lets you basically

00:32:25.850 --> 00:32:28.670
keep the device from
entering deep sleep, so,

00:32:28.670 --> 00:32:30.890
from conserving the battery.

00:32:30.890 --> 00:32:33.849
And a stuck wake lock
is when you use the API,

00:32:33.849 --> 00:32:35.390
and, because of a
bug, or because you

00:32:35.390 --> 00:32:38.930
forgot, you acquire wake lock,
but you never release it.

00:32:38.930 --> 00:32:41.750
So it just keeps
the CPU running,

00:32:41.750 --> 00:32:45.050
and it keeps draining the
battery on your users' devices.

00:32:45.050 --> 00:32:48.139
So what's the best way to
avoid having a stuck wake

00:32:48.139 --> 00:32:49.180
lock on your application?

00:32:49.180 --> 00:32:51.980
Well, you can't have one if
you don't use wake locks.

00:32:51.980 --> 00:32:54.050
That's literally
the simplest thing.

00:32:54.050 --> 00:32:56.720
And actually, in modern
Android development,

00:32:56.720 --> 00:33:00.269
there's rarely a situation when
you have to use a wake lock.

00:33:00.269 --> 00:33:02.810
If we think about activity-- so
whenever the user is actually

00:33:02.810 --> 00:33:04.550
using your app, and
for some reason,

00:33:04.550 --> 00:33:06.620
you want to keep the screen on--

00:33:06.620 --> 00:33:08.900
instead of setting a wake
lock programmatically,

00:33:08.900 --> 00:33:11.300
just use a flag on the window
that will tell the system

00:33:11.300 --> 00:33:12.470
to keep screen on.

00:33:12.470 --> 00:33:14.540
There's no way to leak it.

00:33:14.540 --> 00:33:16.520
For services, if
you schedule them

00:33:16.520 --> 00:33:19.820
as jobs instead of having your
custom free running services,

00:33:19.820 --> 00:33:22.640
the JobScheduler will hold
the wake lock for you.

00:33:22.640 --> 00:33:26.900
And so, again, you don't
have to do that yourselves.

00:33:26.900 --> 00:33:28.910
Similarly, with
AlarmManager, if you

00:33:28.910 --> 00:33:32.127
use it to schedule an alarm
in a BroadcastReceiver,

00:33:32.127 --> 00:33:33.710
there will be a wake
lock held for you

00:33:33.710 --> 00:33:35.184
for the duration of onReceive.

00:33:35.184 --> 00:33:37.100
So if you don't use wake
locks, you don't even

00:33:37.100 --> 00:33:38.720
need the permission
in your manifest,

00:33:38.720 --> 00:33:41.280
and you can't leak them.

00:33:41.280 --> 00:33:42.180
So that's great.

00:33:42.180 --> 00:33:43.804
But if you must use
a wake lock, if you

00:33:43.804 --> 00:33:45.600
find a situation where
you have to use it,

00:33:45.600 --> 00:33:47.840
remember to always choose
a partial wake lock.

00:33:47.840 --> 00:33:49.310
All the other
types of wake locks

00:33:49.310 --> 00:33:52.010
are deprecated on
your Android versions.

00:33:52.010 --> 00:33:55.040
And then, always set a timeout
value in wait wakeLock_acquire

00:33:55.040 --> 00:33:57.350
so that, in case you
leak it, the system

00:33:57.350 --> 00:34:02.060
will clean up the wake lock for
you after the timeout expires.

00:34:02.060 --> 00:34:04.160
Remember to give it a
static, descriptive tag

00:34:04.160 --> 00:34:07.070
without any counters,
or, even worse,

00:34:07.070 --> 00:34:08.570
private, sensitive information.

00:34:08.570 --> 00:34:10.760
That way, we can
service the name

00:34:10.760 --> 00:34:13.310
of the wakeLock in
the Android Vitals

00:34:13.310 --> 00:34:15.800
for you for easier debugging.

00:34:15.800 --> 00:34:18.800
And then remember to always
code defensively, and assume

00:34:18.800 --> 00:34:22.310
things can go wrong, and
use things try-and-finally

00:34:22.310 --> 00:34:24.739
blocks to make sure that
you release the wake lock as

00:34:24.739 --> 00:34:27.206
soon as you're done with it.

00:34:27.206 --> 00:34:28.580
And the last thing
I want to talk

00:34:28.580 --> 00:34:31.980
about today is
excessive wakeups.

00:34:31.980 --> 00:34:34.719
And I think the biggest
cause for excessive wakeups

00:34:34.719 --> 00:34:38.920
is the use of this old, old
API called AlarmManager,

00:34:38.920 --> 00:34:41.620
and specifically, the
wakeup type of alarms.

00:34:41.620 --> 00:34:46.030
Now let me give you the
three Rs of AlarmManager.

00:34:46.030 --> 00:34:50.620
Remove calls to wakeup
alarms, if possible.

00:34:50.620 --> 00:34:54.429
Reduce the frequency if you have
to use them for some reason.

00:34:54.429 --> 00:34:56.590
And, if you can,
replace your alarms

00:34:56.590 --> 00:34:59.830
with other APIs, such as
Firebase Cloud Messaging,

00:34:59.830 --> 00:35:02.890
whenever the wakeup has to
happen for something that

00:35:02.890 --> 00:35:06.460
changed on your server, and you
can send it as a push message.

00:35:06.460 --> 00:35:08.410
Or use one of the
job scheduling APIs,

00:35:08.410 --> 00:35:11.380
such as the newly announced
WorkManager, or even

00:35:11.380 --> 00:35:14.110
JobScheduler or SyncManager.

00:35:14.110 --> 00:35:16.210
And with intelligent
job scheduling,

00:35:16.210 --> 00:35:19.270
you get a lot of things for
free, such as automatic backoff

00:35:19.270 --> 00:35:22.450
and retry, if your job
fails for any reason.

00:35:22.450 --> 00:35:24.070
You get criteria
based scheduling,

00:35:24.070 --> 00:35:25.990
so you can only wake
up the device when

00:35:25.990 --> 00:35:28.870
it has network or is charging,
so that you don't actually

00:35:28.870 --> 00:35:31.570
run your code unnecessarily.

00:35:31.570 --> 00:35:34.270
You get doze and
standby compliance,

00:35:34.270 --> 00:35:35.830
and, like I mentioned
before, even

00:35:35.830 --> 00:35:38.659
automatic wake lock handling.

00:35:38.659 --> 00:35:40.950
And there's a whole session
about background processing

00:35:40.950 --> 00:35:44.860
and WorkManager API specifically
where you can learn more

00:35:44.860 --> 00:35:47.790
about this today.

00:35:47.790 --> 00:35:50.120
So I mentioned the
Android Profiler before.

00:35:50.120 --> 00:35:53.240
And I'm happy to say that
today, in Android Studio,

00:35:53.240 --> 00:35:55.820
we're also announcing
the new Energy Profiler,

00:35:55.820 --> 00:35:59.000
so that you can debug any kinds
of problems with wake locks,

00:35:59.000 --> 00:36:00.800
if you use them in
your app, and also

00:36:00.800 --> 00:36:04.040
see detailed information about
alarms and jobs scheduled

00:36:04.040 --> 00:36:06.630
in your application.

00:36:06.630 --> 00:36:09.530
If you're interested to hear
more about the Profiler,

00:36:09.530 --> 00:36:12.110
please go to the
session tomorrow.

00:36:12.110 --> 00:36:15.430
And with that, let me
invite Fergus back onstage

00:36:15.430 --> 00:36:17.630
to talk to you about what
more you can do to improve

00:36:17.630 --> 00:36:19.310
the quality of your apps.

00:36:19.310 --> 00:36:20.226
FERGUS HURLEY: Thanks.

00:36:26.220 --> 00:36:26.740
Great.

00:36:26.740 --> 00:36:28.000
So we've covered
a lot about what's

00:36:28.000 --> 00:36:29.800
available in Android
Vitals in the Play Console.

00:36:29.800 --> 00:36:31.840
I'm just quickly going to go
through some of the other tools

00:36:31.840 --> 00:36:33.423
that you can be able
to use to be able

00:36:33.423 --> 00:36:36.940
improve the performance
of your application.

00:36:36.940 --> 00:36:38.980
All of Android Vitals
is based on data that's

00:36:38.980 --> 00:36:41.450
collected from users' devices.

00:36:41.450 --> 00:36:44.530
So these are uses that
are actually being

00:36:44.530 --> 00:36:46.905
affected by the issue itself.

00:36:46.905 --> 00:36:49.030
We would love for users
not to actually be impacted

00:36:49.030 --> 00:36:50.690
by any of these issues at all.

00:36:50.690 --> 00:36:53.530
And so we'd encourage you to
do more pre-launch testing

00:36:53.530 --> 00:36:56.380
of your application to find
these issues before rolling it

00:36:56.380 --> 00:36:57.690
out to users.

00:36:57.690 --> 00:36:59.740
There's a session on
this on Thursday at 9:30,

00:36:59.740 --> 00:37:03.537
and I encourage you
to attend that one.

00:37:03.537 --> 00:37:06.120
Over the past couple of years,
we've made radical improvements

00:37:06.120 --> 00:37:09.460
to the Android operating
system to help users

00:37:09.460 --> 00:37:12.510
be able to get more out of their
device in terms of performance,

00:37:12.510 --> 00:37:14.820
and for the battery
to last longer.

00:37:14.820 --> 00:37:17.660
There's major improvements with
the latest version of Android,

00:37:17.660 --> 00:37:19.410
and that was covered
in the keynote today.

00:37:19.410 --> 00:37:21.368
You can learn a lot more
about that on Thursday

00:37:21.368 --> 00:37:23.168
at 11:30 in the session here.

00:37:25.800 --> 00:37:27.900
Wojtek covered a bunch
of different tools

00:37:27.900 --> 00:37:29.840
within Android
Studio to help you

00:37:29.840 --> 00:37:31.300
with improving your core vitals.

00:37:31.300 --> 00:37:33.300
But there's a bunch of
other profilers and tools

00:37:33.300 --> 00:37:35.746
available to improve all
the rest of your vitals.

00:37:35.746 --> 00:37:37.620
And so I encourage you
to use Android Studio,

00:37:37.620 --> 00:37:39.879
even if you're using
another ID, for example,

00:37:39.879 --> 00:37:40.670
to build your game.

00:37:43.850 --> 00:37:46.820
Firebase offers
many tools to help

00:37:46.820 --> 00:37:48.590
you be able to track
the performance

00:37:48.590 --> 00:37:51.650
of your application, Crashlytics
and Firebase Performance

00:37:51.650 --> 00:37:55.700
Monitoring being the most
relevant ones for this talk.

00:37:55.700 --> 00:37:57.650
We encourage you
to use those SDKs

00:37:57.650 --> 00:38:00.980
if you want to be able to do
custom logging of your issues

00:38:00.980 --> 00:38:03.080
that you might be having
with your application.

00:38:03.080 --> 00:38:05.204
Note, there will be a
difference in the data that's

00:38:05.204 --> 00:38:08.330
collected from the
Firebase SDK versus what's

00:38:08.330 --> 00:38:11.130
collected through Android
Vitals, which is from users

00:38:11.130 --> 00:38:13.820
who've opted in to sharing
the data with Google

00:38:13.820 --> 00:38:18.380
and our partners at [INAUDIBLE].

00:38:18.380 --> 00:38:21.320
If you want to learn more about
Firebase Performance Monitoring

00:38:21.320 --> 00:38:24.961
and Crashlytics, you can attend
this talk at 11:30 tomorrow.

00:38:27.910 --> 00:38:29.650
We covered a lot
in terms of what's

00:38:29.650 --> 00:38:32.247
available in Android Vitals
in the Play Console today.

00:38:32.247 --> 00:38:33.580
But there's a lot more to learn.

00:38:33.580 --> 00:38:35.770
And you can hear
all about that on

00:38:35.770 --> 00:38:40.820
developers.android.com/vitals.

00:38:40.820 --> 00:38:42.290
Just to quickly
recap, we started

00:38:42.290 --> 00:38:45.050
by covering why performance
is vital overall.

00:38:45.050 --> 00:38:46.700
And hopefully you
all agree that it is.

00:38:46.700 --> 00:38:49.489
That's why you're here
today, so thank you.

00:38:49.489 --> 00:38:51.030
Then we covered
what's new in Vitals.

00:38:51.030 --> 00:38:53.640
And I hope you take
advantage of these new tools.

00:38:53.640 --> 00:38:57.390
Then we talked about how you can
debug these core vitals issues.

00:38:57.390 --> 00:39:00.180
And, finally, what's available
beyond Play Console Android

00:39:00.180 --> 00:39:01.476
Vitals.

00:39:01.476 --> 00:39:03.350
We'd love to hear your
feedback on this talk.

00:39:03.350 --> 00:39:06.150
If you can be able to go to
this URL, provide your feedback,

00:39:06.150 --> 00:39:08.576
we'd love to hear from you.

00:39:08.576 --> 00:39:09.950
If you have any
questions for us,

00:39:09.950 --> 00:39:15.680
you can meet us from 4 o'clock
to 5 o'clock at this stand.

00:39:15.680 --> 00:39:18.170
It's on the other
side of the lot.

00:39:18.170 --> 00:39:21.440
And we'll also be available at
the Google Play Console Sandbox

00:39:21.440 --> 00:39:23.900
from 2:00 PM to 5:00
PM tomorrow to answer

00:39:23.900 --> 00:39:25.687
any of your questions.

00:39:25.687 --> 00:39:27.770
Thank you all very much
for joining us here today.

00:39:34.406 --> 00:39:36.280
We hope that you'll make
radical improvements

00:39:36.280 --> 00:39:37.750
to your application
over the next year,

00:39:37.750 --> 00:39:39.990
and that you'll get covered
in our I/O talk next year.

00:39:39.990 --> 00:39:41.920
So, best of luck to you all
with improving your application.

00:39:41.920 --> 00:39:42.623
Thank you.

00:39:42.623 --> 00:39:47.005
[MUSIC PLAYING]

