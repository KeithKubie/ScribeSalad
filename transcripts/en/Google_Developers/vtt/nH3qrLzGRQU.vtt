WEBVTT
Kind: captions
Language: en

00:00:00.120 --> 00:00:01.400
MARC COHEN: We're going to spend
some time talking this

00:00:01.400 --> 00:00:04.490
afternoon about building robust
systems on top of

00:00:04.490 --> 00:00:06.120
Google Compute Engine.

00:00:06.120 --> 00:00:07.030
My name is Mark Cohen.

00:00:07.030 --> 00:00:09.540
I'm a Developer Programs
Engineer at Google, and I'm

00:00:09.540 --> 00:00:10.500
joined by--

00:00:10.500 --> 00:00:11.120
JOE BEDA: I'm Joe Beda.

00:00:11.120 --> 00:00:15.100
I'm the lead engineer
for Compute Engine.

00:00:15.100 --> 00:00:17.300
MARC COHEN: So we'll hope to
give you some good ideas,

00:00:17.300 --> 00:00:19.370
things to think about,
techniques and approaches to

00:00:19.370 --> 00:00:21.340
building reliable systems.

00:00:21.340 --> 00:00:23.210
This is a quick overview of
what we're going to talk

00:00:23.210 --> 00:00:26.300
about, just a quick review
of background.

00:00:26.300 --> 00:00:29.150
I'm assuming most of you have
probably heard about Google

00:00:29.150 --> 00:00:31.180
Compute Engine and know about
it, so we'll just give a real

00:00:31.180 --> 00:00:33.170
quick overview.

00:00:33.170 --> 00:00:35.340
We'll talk a little bit about
why you should care about this

00:00:35.340 --> 00:00:37.680
subject, what sorts of bad
things can happen when you

00:00:37.680 --> 00:00:40.270
build these large,
complex systems.

00:00:40.270 --> 00:00:42.040
We'll review a bunch
of power tools.

00:00:42.040 --> 00:00:45.640
These are unique capabilities
and techniques that we believe

00:00:45.640 --> 00:00:48.060
really bring some value to the
table when you're building

00:00:48.060 --> 00:00:49.990
these sorts of distributed
systems.

00:00:49.990 --> 00:00:52.860
And then we'll review a
prototypes application.

00:00:55.770 --> 00:00:57.970
So a little bit of background.

00:00:57.970 --> 00:01:01.560
So this is a photograph of
Google's Council Bluffs, Iowa

00:01:01.560 --> 00:01:04.280
data center.

00:01:04.280 --> 00:01:06.750
This comes from a very
informative website,

00:01:06.750 --> 00:01:08.300
google.com/datacenters.

00:01:08.300 --> 00:01:10.240
So it's a great resource if
you're interested in learning

00:01:10.240 --> 00:01:11.290
more about the data centers.

00:01:11.290 --> 00:01:14.410
But the quote here is from an
article Steven Levy wrote for

00:01:14.410 --> 00:01:17.980
"Wired" magazine last year, and
it speaks to the enormous

00:01:17.980 --> 00:01:21.530
scale and just the incredible
magnitude

00:01:21.530 --> 00:01:23.540
of these data centers.

00:01:23.540 --> 00:01:26.740
And I like this as a way of
thinking about Google Compute

00:01:26.740 --> 00:01:30.210
Engine because at its core, what
Google Compute Engine is

00:01:30.210 --> 00:01:33.040
about is getting you into that
room, giving you access to

00:01:33.040 --> 00:01:35.505
some of the world's most
advanced computing resources.

00:01:38.590 --> 00:01:42.030
So a quick run-through of
a description of what

00:01:42.030 --> 00:01:43.140
Compute Engine is.

00:01:43.140 --> 00:01:46.180
Before I launch into this, how
many people have already heard

00:01:46.180 --> 00:01:49.700
about Compute Engine and
know what it is?

00:01:49.700 --> 00:01:50.770
OK, cool.

00:01:50.770 --> 00:01:52.680
And how many people
have actually used

00:01:52.680 --> 00:01:55.220
Google Compute Engine?

00:01:55.220 --> 00:01:58.520
OK, that's awesome.

00:01:58.520 --> 00:02:01.880
It's an Infrastructure as a
Service product, and for most

00:02:01.880 --> 00:02:04.870
people, that immediately
connotes virtual machines,

00:02:04.870 --> 00:02:06.300
Linux boxes, things like that.

00:02:06.300 --> 00:02:10.610
And that's certainly the heart
of the offer, but we like to

00:02:10.610 --> 00:02:13.120
think of it as a very
comprehensive package of

00:02:13.120 --> 00:02:13.790
capabilities.

00:02:13.790 --> 00:02:16.980
So in addition to the virtual
machines, you get some very

00:02:16.980 --> 00:02:18.580
advanced networking
capabilities.

00:02:18.580 --> 00:02:22.330
You get a private network with
a built-in DNS server, a lot

00:02:22.330 --> 00:02:24.550
of built-in security
capabilities like

00:02:24.550 --> 00:02:27.230
automatically encrypted hard
drive and things of that

00:02:27.230 --> 00:02:31.990
nature, and an array of pretty
advanced storage capabilities,

00:02:31.990 --> 00:02:35.140
which we're going to
review shortly.

00:02:35.140 --> 00:02:38.130
But at a broader level, it's
all built with Google's

00:02:38.130 --> 00:02:38.960
fingerprint.

00:02:38.960 --> 00:02:44.810
So all of the experience,
knowledge, engineering insight

00:02:44.810 --> 00:02:47.540
and operational management type
know-how how that's gone

00:02:47.540 --> 00:02:52.570
into building out all of the
services that Google provides

00:02:52.570 --> 00:02:56.420
serving billions of queries a
day all around the world--

00:02:56.420 --> 00:03:00.160
all of that's gone into Google
Compute Engine, both in terms

00:03:00.160 --> 00:03:06.530
of technology at the design
level and also the technology

00:03:06.530 --> 00:03:07.620
that we're building on top of.

00:03:07.620 --> 00:03:09.230
So we're really taking advantage
of a lot of the

00:03:09.230 --> 00:03:10.760
history here.

00:03:10.760 --> 00:03:12.920
As well, it's part of a
broader platform of

00:03:12.920 --> 00:03:15.510
capabilities we call Google
Compute Engine.

00:03:15.510 --> 00:03:18.640
So as you'll see, it enables
you to work really well and

00:03:18.640 --> 00:03:22.600
easily with other aspects
of the platform.

00:03:22.600 --> 00:03:25.200
So I have been given talks about
Google Compute Engine

00:03:25.200 --> 00:03:28.580
for a while, and at the end of
the talk, I often see this

00:03:28.580 --> 00:03:30.430
expression.

00:03:30.430 --> 00:03:33.990
And frankly, it's been
frustrating because my answer

00:03:33.990 --> 00:03:38.120
is always very measured
and complex.

00:03:38.120 --> 00:03:41.020
And I'm really, really happy--

00:03:41.020 --> 00:03:43.000
I may be one of the happiest
people here--

00:03:43.000 --> 00:03:45.600
to be able to answer this
question more simply than I

00:03:45.600 --> 00:03:47.120
ever have before.

00:03:47.120 --> 00:03:48.820
So the answer is yes,
if you would like to

00:03:48.820 --> 00:03:49.940
try this, it's available.

00:03:49.940 --> 00:03:52.200
We announced Wednesday it's
available for anyone who would

00:03:52.200 --> 00:03:54.250
like to sign up and try
it, and I'd strongly

00:03:54.250 --> 00:03:55.500
encourage you to do.

00:03:57.980 --> 00:04:05.510
So it's really important to
switch gears a little bit to

00:04:05.510 --> 00:04:08.210
building complex systems and
what sorts of problems we

00:04:08.210 --> 00:04:11.590
might have and what sort
of things can go wrong.

00:04:11.590 --> 00:04:14.000
Anything can go wrong, and
everything can go wrong.

00:04:14.000 --> 00:04:18.220
And I think it's really
important to realize that your

00:04:18.220 --> 00:04:20.589
hardware is never going to be
perfect, your software is

00:04:20.589 --> 00:04:23.200
never going to be perfect, and
your processes are never going

00:04:23.200 --> 00:04:23.920
to be perfect.

00:04:23.920 --> 00:04:28.910
So there's a mindset shift that
I think is a little bit

00:04:28.910 --> 00:04:32.030
subtle but really important,
which is instead of focusing

00:04:32.030 --> 00:04:35.040
on building perfect things and
writing perfect code, it's

00:04:35.040 --> 00:04:38.600
also really important to build
and design systems that

00:04:38.600 --> 00:04:42.430
tolerate and deal well with
failures because they're

00:04:42.430 --> 00:04:43.360
certainly going to happen.

00:04:43.360 --> 00:04:46.040
And that's a big part of
Google's legacy, the whole

00:04:46.040 --> 00:04:49.400
concept of MapReduce and these
huge data centers that I've

00:04:49.400 --> 00:04:50.790
been talking about.

00:04:50.790 --> 00:04:55.640
The core principle there is
deploying huge numbers of

00:04:55.640 --> 00:04:58.550
inexpensive computing devices
and dealing gracefully with

00:04:58.550 --> 00:05:01.960
the fact that in that sort of
volume, bad things are going

00:05:01.960 --> 00:05:04.050
to happen and are in fact
happening all the time.

00:05:06.660 --> 00:05:08.810
So to be a little bit
more specific--

00:05:08.810 --> 00:05:10.590
whoops, didn't mean
to reveal that.

00:05:10.590 --> 00:05:11.570
I think you guys
already saw it.

00:05:11.570 --> 00:05:14.440
I was going to ask the audience
if you had any idea

00:05:14.440 --> 00:05:18.170
what the single most
common factor is

00:05:18.170 --> 00:05:19.450
in outages and failures.

00:05:19.450 --> 00:05:21.080
You guys already saw
it I think, right?

00:05:23.770 --> 00:05:24.790
So it's the human error.

00:05:24.790 --> 00:05:27.770
It's making mistakes with
configuration, procedures, or

00:05:27.770 --> 00:05:30.000
just accidental operation
snafu.

00:05:30.000 --> 00:05:34.190
And so that's one big factor,
one big type of failure that

00:05:34.190 --> 00:05:34.890
you'll encounter.

00:05:34.890 --> 00:05:37.280
Then of course there are
software errors like resource

00:05:37.280 --> 00:05:39.760
exhaustion, logic bugs.

00:05:39.760 --> 00:05:43.650
Bad recovery code is a fairly
interesting scenario because

00:05:43.650 --> 00:05:45.630
it's the situation where
you've written code

00:05:45.630 --> 00:05:48.010
specifically to deal
with problems.

00:05:48.010 --> 00:05:50.940
By its very nature, that sort of
code doesn't typically get

00:05:50.940 --> 00:05:53.640
exercised very often and often
is not tested thoroughly.

00:05:53.640 --> 00:05:56.380
And so what you can have there
is a situation where the code

00:05:56.380 --> 00:05:59.240
that's dealing with a problem
makes the problem even worse

00:05:59.240 --> 00:06:01.810
if it's not behaving properly.

00:06:01.810 --> 00:06:04.790
Of course, we have scheduled
maintenance events and

00:06:04.790 --> 00:06:08.030
unexpected, unplanned
maintenance outages-- or not

00:06:08.030 --> 00:06:10.060
maintenance outages but
simple outages.

00:06:10.060 --> 00:06:12.720
And then there's a wide
range of security

00:06:12.720 --> 00:06:15.010
failures that we can have.

00:06:15.010 --> 00:06:19.240
So there's a lot of things
that can go wrong.

00:06:19.240 --> 00:06:23.810
And there's really three
dimensions to this problem of

00:06:23.810 --> 00:06:25.800
dealing with these
sort of outages.

00:06:25.800 --> 00:06:30.040
There's the infrastructure
layer, there's the application

00:06:30.040 --> 00:06:32.200
layer, which you guys are
responsible for, and then

00:06:32.200 --> 00:06:34.980
there's the process layer
or the people layer.

00:06:34.980 --> 00:06:39.190
And we're going to focus today
on the infrastructure and the

00:06:39.190 --> 00:06:39.850
application.

00:06:39.850 --> 00:06:42.580
We're going to talk about the
infrastructure that we provide

00:06:42.580 --> 00:06:45.390
and share some tips about how
you can take advantage of

00:06:45.390 --> 00:06:46.880
those capabilities.

00:06:46.880 --> 00:06:49.470
But I do want to spend a few
minutes on the human and the

00:06:49.470 --> 00:06:51.430
process element, because
I think that's a really

00:06:51.430 --> 00:06:53.250
important aspect
of it as well.

00:06:53.250 --> 00:06:55.800
This quote captures a lot of
what I've been thinking about

00:06:55.800 --> 00:06:56.840
in this space.

00:06:56.840 --> 00:07:00.290
If you get a chance to check out
this article, "How Complex

00:07:00.290 --> 00:07:01.910
Systems Fail," I highly
recommend it.

00:07:01.910 --> 00:07:03.200
It's by Richard Cook.

00:07:03.200 --> 00:07:05.350
It's about a four-page
article.

00:07:05.350 --> 00:07:07.470
It's hot-linked off of these
slides, which I'll release

00:07:07.470 --> 00:07:08.880
after the talk.

00:07:08.880 --> 00:07:11.700
But anyway, it's a very nice
taxonomy of how complex

00:07:11.700 --> 00:07:12.440
systems fail.

00:07:12.440 --> 00:07:16.380
And one of the points in this
document is, "Recognizing

00:07:16.380 --> 00:07:18.720
hazard and successfully
operating inside tolerable

00:07:18.720 --> 00:07:21.260
performance boundaries requires
intimate contact with

00:07:21.260 --> 00:07:23.960
failure." So what he's really
talking about is, practice

00:07:23.960 --> 00:07:24.620
makes perfect.

00:07:24.620 --> 00:07:28.480
It's really important to have
people who are well trained in

00:07:28.480 --> 00:07:31.680
this area and have good
monitoring tools and are

00:07:31.680 --> 00:07:34.700
following processes that are
going to help you navigate

00:07:34.700 --> 00:07:38.610
that fine balance between--

00:07:38.610 --> 00:07:40.150
it's not a binary, everything's
working,

00:07:40.150 --> 00:07:42.640
everything's not working, but
you're trying to make sure

00:07:42.640 --> 00:07:45.740
that small failures that are
happening all the time are

00:07:45.740 --> 00:07:46.990
well contained.

00:07:49.070 --> 00:07:52.430
So here are a few process
guidelines that we've learned

00:07:52.430 --> 00:07:55.960
at Google have been very helpful
for us with managing

00:07:55.960 --> 00:07:58.000
our systems effectively.

00:07:58.000 --> 00:08:00.010
Set reliability goals
and track metrics.

00:08:00.010 --> 00:08:03.220
So make sure to delineate what
it is you want to accomplish

00:08:03.220 --> 00:08:06.000
in the space of your reliable
systems and then have good

00:08:06.000 --> 00:08:06.510
measurements.

00:08:06.510 --> 00:08:08.950
If you just state a bunch of
goals, and then you don't

00:08:08.950 --> 00:08:11.140
measure it and track how you're
doing, then it's not

00:08:11.140 --> 00:08:13.160
really buying you
all that much.

00:08:13.160 --> 00:08:14.660
Document everything.

00:08:14.660 --> 00:08:25.600
So any problems you're having
or issues you're overcoming,

00:08:25.600 --> 00:08:28.300
it's really important to capture
those with postmortems

00:08:28.300 --> 00:08:30.310
and to make sure you're
documenting all of the

00:08:30.310 --> 00:08:32.740
learnings that you're having,
sharing it with

00:08:32.740 --> 00:08:34.120
your team and so on.

00:08:34.120 --> 00:08:36.510
Otherwise, you're going to
repeat those problems.

00:08:36.510 --> 00:08:38.159
Automating everything
is really important.

00:08:38.159 --> 00:08:41.159
Any time you have a manual
procedure in your operations

00:08:41.159 --> 00:08:41.770
processes--

00:08:41.770 --> 00:08:44.400
so somebody has to go click a
button or write a script or

00:08:44.400 --> 00:08:45.690
run a script--

00:08:45.690 --> 00:08:47.220
that's an error waiting
to happen.

00:08:47.220 --> 00:08:50.010
So this is an ideal.

00:08:50.010 --> 00:08:53.110
It's very hard to do this
perfectly, but this should be

00:08:53.110 --> 00:08:55.850
the goal that we're
all striving for.

00:08:55.850 --> 00:08:57.290
Preparing for maintenance
events and

00:08:57.290 --> 00:08:58.620
outages is really important.

00:08:58.620 --> 00:09:01.930
At Google, we have regular
events where we simulate

00:09:01.930 --> 00:09:06.090
outages and actually break
things fairly intrusively.

00:09:06.090 --> 00:09:09.170
And it's a great way to not only
prepare for but also to

00:09:09.170 --> 00:09:11.960
test outages and events.

00:09:11.960 --> 00:09:14.380
And build a really strong
capacity planning model and

00:09:14.380 --> 00:09:16.910
allocation of your resources and
zones so that you have the

00:09:16.910 --> 00:09:20.100
ability to move things around
as and when you need and to

00:09:20.100 --> 00:09:23.640
adapt to outages on the fly.

00:09:23.640 --> 00:09:25.140
So that's by way
of background.

00:09:25.140 --> 00:09:27.010
I'm going to turn it over to Joe
now to talk about some of

00:09:27.010 --> 00:09:29.200
the power tools.

00:09:29.200 --> 00:09:30.920
JOE BEDA: Thanks, Marc.

00:09:30.920 --> 00:09:34.410
So I'm going to cover a little
bit of the unique capabilities

00:09:34.410 --> 00:09:37.380
of Compute Engine and how you
can use those to solve some

00:09:37.380 --> 00:09:40.690
problems in this space, but also
some things that exist

00:09:40.690 --> 00:09:43.570
outside of Compute Engine proper
and how you can go

00:09:43.570 --> 00:09:45.680
ahead and use those.

00:09:45.680 --> 00:09:47.770
To start with, you have
to know your storage.

00:09:47.770 --> 00:09:51.210
So much of reliability comes
down to making sure that your

00:09:51.210 --> 00:09:52.070
data is there.

00:09:52.070 --> 00:09:55.410
It's frequently the bottleneck
that you're going to hit.

00:09:55.410 --> 00:09:57.850
And so I want to review some
of the storage options with

00:09:57.850 --> 00:10:00.360
Compute Engine and with
the Cloud platform.

00:10:00.360 --> 00:10:03.580
So to start with, starting at
the least reliable level, we

00:10:03.580 --> 00:10:04.890
have Scratch Disk.

00:10:04.890 --> 00:10:09.000
This is a block device attached
to a virtual machine.

00:10:09.000 --> 00:10:11.290
It lives and dies with
that virtual machine.

00:10:11.290 --> 00:10:14.890
It's cheap and cheerful, but
it's also not very durable.

00:10:14.890 --> 00:10:18.410
And one of the things that you
should be aware of is that

00:10:18.410 --> 00:10:21.870
it's also prone to correlated
failures.

00:10:21.870 --> 00:10:25.430
So you don't know that you won't
see a lot of Scratch

00:10:25.430 --> 00:10:27.030
Disks dying at the same time.

00:10:27.030 --> 00:10:29.520
So something to keep
in mind as you're

00:10:29.520 --> 00:10:30.870
building your processes.

00:10:30.870 --> 00:10:33.160
So things like good backups,
even if you're using

00:10:33.160 --> 00:10:36.350
replication, is a good idea.

00:10:36.350 --> 00:10:38.360
Next is our Persistent
Disk offering.

00:10:38.360 --> 00:10:41.400
This is replicated off of the
local machine over the

00:10:41.400 --> 00:10:43.830
network, and it's
very flexible.

00:10:43.830 --> 00:10:46.920
And we've built it for fast,
consistent performance.

00:10:46.920 --> 00:10:48.950
I'm going to go into a little
bit more detail in the next

00:10:48.950 --> 00:10:51.650
slide here.

00:10:51.650 --> 00:10:52.760
So the next is Cloud Storage.

00:10:52.760 --> 00:10:56.650
This is the first thing that
actually goes outside of the

00:10:56.650 --> 00:10:59.430
zone that the virtual machines
are running in.

00:10:59.430 --> 00:11:02.300
And this is a blob storage, and
it's really a Swiss Army

00:11:02.300 --> 00:11:04.640
knife when building
your application.

00:11:04.640 --> 00:11:06.360
It's great for getting
information in

00:11:06.360 --> 00:11:07.560
and out of the cloud.

00:11:07.560 --> 00:11:09.780
It's great for storing
things for backups.

00:11:09.780 --> 00:11:12.510
It's great also for serving.

00:11:12.510 --> 00:11:14.900
So it really can play all those
different roles, and

00:11:14.900 --> 00:11:19.410
it's really a great tool
in the tool box.

00:11:19.410 --> 00:11:22.560
Next are hosted databases.

00:11:22.560 --> 00:11:26.580
And so with Google, we have
Google Cloud SQL, and we have

00:11:26.580 --> 00:11:30.150
the newly announced Cloud
Datastore, which is the App

00:11:30.150 --> 00:11:34.210
Engine Datastore built on top of
BigTable exposed as an API

00:11:34.210 --> 00:11:36.500
to anybody who wants
to use it.

00:11:36.500 --> 00:11:39.430
And we use lead the Data Store
and the technology underlying

00:11:39.430 --> 00:11:41.760
the Datastore all over the
place inside of Google.

00:11:41.760 --> 00:11:45.150
And so the best thing to do is
let it be somebody else's

00:11:45.150 --> 00:11:47.810
problem to worry about
reliability

00:11:47.810 --> 00:11:49.750
and to hold the pager.

00:11:49.750 --> 00:11:51.700
And so finally, you can bring
your own Datastore.

00:11:51.700 --> 00:11:54.100
I mean building on top of
these tools, you can run

00:11:54.100 --> 00:11:55.130
something like Cassandra.

00:11:55.130 --> 00:11:56.990
You can run Mongo.

00:11:56.990 --> 00:11:59.720
You can run whatever you're
comfortable with and whatever

00:11:59.720 --> 00:12:01.870
solution actually
fits your needs.

00:12:01.870 --> 00:12:03.910
Obviously, it's going to be a
little bit more complicated

00:12:03.910 --> 00:12:07.680
the deeper you get, but
your freedom's there.

00:12:07.680 --> 00:12:10.990
So just focusing in a little
bit on Persistent Disk.

00:12:10.990 --> 00:12:13.080
It's really a sweet spot
in terms of durability,

00:12:13.080 --> 00:12:15.240
flexibility and consistency.

00:12:15.240 --> 00:12:17.740
That's what we really
built it for.

00:12:17.740 --> 00:12:20.720
One of the interesting
capabilities here is the

00:12:20.720 --> 00:12:22.530
ability to take snapshots.

00:12:22.530 --> 00:12:25.320
This is great for backups.

00:12:25.320 --> 00:12:27.570
There was a talk earlier at
I/O-- and you can watch the

00:12:27.570 --> 00:12:30.410
video-- that goes deep into this
system and some of the

00:12:30.410 --> 00:12:32.020
best practices on
how to use it.

00:12:32.020 --> 00:12:36.080
I encourage you to take
a look at that.

00:12:36.080 --> 00:12:40.070
And it's also a very useful
thing to move data between

00:12:40.070 --> 00:12:41.560
different zones and
different regions.

00:12:41.560 --> 00:12:44.790
So if you take a snapshot in
Compute Engine of a Persistent

00:12:44.790 --> 00:12:47.820
Disk, that snapshot is
available globally.

00:12:47.820 --> 00:12:51.010
And so it really starts to
approach a disaster recovery,

00:12:51.010 --> 00:12:54.020
or at least a piece of a
disaster recovery plan.

00:12:54.020 --> 00:12:55.580
And so you can use this for
anything that you would use a

00:12:55.580 --> 00:12:59.300
disk for, database storage, fast
boot, static data that

00:12:59.300 --> 00:13:03.870
you want to share widely, and
for being able to move data

00:13:03.870 --> 00:13:08.700
between different zones
and different regions.

00:13:08.700 --> 00:13:15.110
So, "Tooling should be used
automate every step." So

00:13:15.110 --> 00:13:16.940
Adrian's actually here
in the audience.

00:13:16.940 --> 00:13:19.170
He's see the Cloud Architect
for Netflix.

00:13:19.170 --> 00:13:20.210
Is that your right title?

00:13:20.210 --> 00:13:21.710
Yeah, OK.

00:13:21.710 --> 00:13:24.590
And I was talking to him last
night, and he said, "automate

00:13:24.590 --> 00:13:26.500
all the everythings," which
is pretty much what

00:13:26.500 --> 00:13:27.180
it comes down to.

00:13:27.180 --> 00:13:29.920
So here are some building blocks
that we can use to

00:13:29.920 --> 00:13:33.080
automate your deployments
in Compute Engine.

00:13:33.080 --> 00:13:34.030
So the first thing
I want to talk

00:13:34.030 --> 00:13:38.160
about is Instance Metadata.

00:13:38.160 --> 00:13:40.600
There are other clouds out there
that provide a way to

00:13:40.600 --> 00:13:44.060
provide a passive blob into
your virtual machine.

00:13:44.060 --> 00:13:47.010
We've taken it to the next
step and added a few more

00:13:47.010 --> 00:13:47.570
features there.

00:13:47.570 --> 00:13:49.740
And it's really a pretty simple
feature, but it's very

00:13:49.740 --> 00:13:51.250
powerful also.

00:13:51.250 --> 00:13:55.030
The idea is that from the API,
you can specify some simple

00:13:55.030 --> 00:13:59.030
key/value pairs, and those
key/value pairs are then made

00:13:59.030 --> 00:14:02.400
available inside the
VM at a very early

00:14:02.400 --> 00:14:04.100
stage of the boot cycle.

00:14:04.100 --> 00:14:08.050
And so you can then use this
to pass in all sorts of

00:14:08.050 --> 00:14:10.880
information that can configure
your system and make your

00:14:10.880 --> 00:14:12.130
systems be more reactive.

00:14:14.730 --> 00:14:18.040
And you can set it both on an
instance by instance basis, or

00:14:18.040 --> 00:14:20.780
you can set it across
your entire project.

00:14:20.780 --> 00:14:23.710
And so this is what we use to
distribute, say SSH keys into

00:14:23.710 --> 00:14:25.520
the virtual machine.

00:14:25.520 --> 00:14:27.300
And so we give you some
quick examples here.

00:14:29.960 --> 00:14:31.950
So this is using the gcutil
command line tool.

00:14:31.950 --> 00:14:35.390
Obviously, you can do all of
this stuff with the API also.

00:14:35.390 --> 00:14:37.660
But here I'm passing in
two metadata values.

00:14:37.660 --> 00:14:41.330
One of them is a role with the
value of master, and then the

00:14:41.330 --> 00:14:45.450
other one is a configuration
file coming from a text file.

00:14:45.450 --> 00:14:48.520
And then once I boot up my
virtual machine with that

00:14:48.520 --> 00:14:50.540
information, I can
SSH into it.

00:14:50.540 --> 00:14:54.050
And then with a simple curl
command to a local metadata

00:14:54.050 --> 00:14:56.450
server that's available only to
that virtual machine-- so

00:14:56.450 --> 00:14:58.950
it's a private metadata server
for that virtual machine--

00:14:58.950 --> 00:15:00.960
I can then go ahead
and retrieve

00:15:00.960 --> 00:15:01.940
these key/value pairs.

00:15:01.940 --> 00:15:05.570
So this is a really critical
building block for building

00:15:05.570 --> 00:15:08.820
automated, self-configuring
systems.

00:15:08.820 --> 00:15:12.140
So building on top of that, we
have simple Start Up Scripts.

00:15:12.140 --> 00:15:14.600
So this is the next
level here.

00:15:14.600 --> 00:15:18.690
And so this is like rc.local
if you're familiar with

00:15:18.690 --> 00:15:23.290
traditional Unix
init processes.

00:15:23.290 --> 00:15:26.030
And you can use this to install
packages, download

00:15:26.030 --> 00:15:28.280
things from Google Storage
using our service account

00:15:28.280 --> 00:15:31.140
feature to do so securely,
or bootstrap

00:15:31.140 --> 00:15:32.290
other management systems.

00:15:32.290 --> 00:15:35.100
So if you're using something
like Puppet or Chef, this can

00:15:35.100 --> 00:15:39.060
be a great way to get those
things installed and working.

00:15:39.060 --> 00:15:41.920
So here's a quick example
of what this is.

00:15:41.920 --> 00:15:45.330
On a CentOS machine, it
will install node.

00:15:45.330 --> 00:15:50.770
And so the first four lines
there are providing access to

00:15:50.770 --> 00:15:53.440
an extended repository,
installing node.

00:15:53.440 --> 00:15:58.170
And then the next three lines
are getting the specific role

00:15:58.170 --> 00:16:00.973
that this thing should be
running, downloading the Start

00:16:00.973 --> 00:16:03.870
Up Script or the program from
cloud storage, and then

00:16:03.870 --> 00:16:05.700
running that.

00:16:05.700 --> 00:16:08.390
And so with a few lines of code,
you can turn something

00:16:08.390 --> 00:16:11.300
from being something that you
have to SSH into and push

00:16:11.300 --> 00:16:13.910
configuration for to something
that can actually draw and

00:16:13.910 --> 00:16:16.850
automatically run what
it needs to run.

00:16:16.850 --> 00:16:20.740
And you can see how you can just
simply pass this in as a

00:16:20.740 --> 00:16:23.670
metadata value for Start Up
Script, and our stock images

00:16:23.670 --> 00:16:27.270
know how to check for that
metadata value and start

00:16:27.270 --> 00:16:29.300
running the script
for you at boot.

00:16:29.300 --> 00:16:33.360
And then the log gets written
to var/log/Google so you can

00:16:33.360 --> 00:16:37.110
debug it when things go wrong.

00:16:37.110 --> 00:16:40.040
And then on top of that, how
do you manage images?

00:16:40.040 --> 00:16:42.250
Images can be a real problem.

00:16:42.250 --> 00:16:45.600
And so this is a quick pattern
I'd like to show you of

00:16:45.600 --> 00:16:48.970
creating a script that can be
used both for customizing a

00:16:48.970 --> 00:16:51.820
system at runtime, initializing
something for

00:16:51.820 --> 00:16:55.340
creating an image, or
initializing a Persistent Disk

00:16:55.340 --> 00:16:57.390
that you're booting off of.

00:16:57.390 --> 00:17:00.320
So it's an easy way to mark--

00:17:00.320 --> 00:17:03.880
this was left over from my
fractal demo that I gave on a

00:17:03.880 --> 00:17:05.300
previous talk--

00:17:05.300 --> 00:17:08.319
it's an easy way to mark whether
you've done a set of

00:17:08.319 --> 00:17:09.119
steps so far.

00:17:09.119 --> 00:17:11.140
And if you have, skip that--

00:17:11.140 --> 00:17:13.450
those are generally the time
consuming, one-time set up

00:17:13.450 --> 00:17:14.390
type of things--

00:17:14.390 --> 00:17:16.810
and then actually run
the program that

00:17:16.810 --> 00:17:18.060
you're looking to run.

00:17:20.140 --> 00:17:24.300
And so finally, you can do a lot
with these set of tools,

00:17:24.300 --> 00:17:26.109
but it'll only take
you so far.

00:17:26.109 --> 00:17:30.270
And so the next step is this
broad category of systems that

00:17:30.270 --> 00:17:32.210
I've been calling
orchestration.

00:17:32.210 --> 00:17:34.520
You can start with something
simple like doing a bunch of

00:17:34.520 --> 00:17:37.520
what I've provided here through
App Engine, which is a

00:17:37.520 --> 00:17:41.150
good way to have a system in the
sky managing it for you.

00:17:41.150 --> 00:17:43.110
But if you want to move past
that, there are a whole bunch

00:17:43.110 --> 00:17:47.290
of systems like Chef and Puppet,
or commercial partners

00:17:47.290 --> 00:17:50.280
like RightScale and Scalr that
can really help you take this

00:17:50.280 --> 00:17:51.400
to the next level.

00:17:51.400 --> 00:17:54.260
And they all offer a different
set of features, but here's a

00:17:54.260 --> 00:17:57.580
good smattering of the types of
things that you can expect

00:17:57.580 --> 00:18:00.690
once you start taking advantage
of higher-level

00:18:00.690 --> 00:18:01.940
systems like that.

00:18:04.560 --> 00:18:07.360
Now, the next thing is that
scaling and stability really

00:18:07.360 --> 00:18:09.940
go hand in hand.

00:18:09.940 --> 00:18:12.470
If you're building for scale,
a lot of times you're also

00:18:12.470 --> 00:18:13.640
building for stability.

00:18:13.640 --> 00:18:17.080
And all the problems that only
happen once in a while all of

00:18:17.080 --> 00:18:19.830
a sudden start happening
all the time.

00:18:19.830 --> 00:18:21.730
And so these things really
do go hand in hand.

00:18:21.730 --> 00:18:23.750
And so one of the key things
here is use Load Balancers.

00:18:23.750 --> 00:18:24.760
I mean it seems obvious.

00:18:24.760 --> 00:18:26.060
Load Balancers give you scale.

00:18:26.060 --> 00:18:28.550
But Load Balancers also give
you the ability to route

00:18:28.550 --> 00:18:30.680
around failures, and so they're
really going to be a

00:18:30.680 --> 00:18:32.570
key part of any architecture
that's going to

00:18:32.570 --> 00:18:34.250
be built for stability.

00:18:34.250 --> 00:18:38.960
And then finally, plan to
actually distribute yourself

00:18:38.960 --> 00:18:41.600
both across zones and
across regions.

00:18:41.600 --> 00:18:47.560
That's both insuring against a
meteor hitting or software or

00:18:47.560 --> 00:18:48.830
hardware failures.

00:18:48.830 --> 00:18:51.620
And if you do it right, and if
you build an advanced enough

00:18:51.620 --> 00:18:54.500
architecture, you can actually
provide lower latencies to the

00:18:54.500 --> 00:18:55.750
people where they are.

00:18:58.570 --> 00:19:00.630
And then the last feature I
want to talk about is our

00:19:00.630 --> 00:19:02.680
startup times, our Fast Startup
Times at Google.

00:19:02.680 --> 00:19:06.370
This lets you build more dynamic
applications that can

00:19:06.370 --> 00:19:07.690
start and stop instances.

00:19:07.690 --> 00:19:09.650
And if you get into the mode
of thinking about these

00:19:09.650 --> 00:19:15.690
instances as being ephemeral
workers, as stateless as

00:19:15.690 --> 00:19:17.540
possible, something that you
can manage and that can

00:19:17.540 --> 00:19:20.650
self-configure, then you're
well on your way towards

00:19:20.650 --> 00:19:22.550
building a much more
reliable system.

00:19:22.550 --> 00:19:25.360
And being able to spin things
up and down and build that

00:19:25.360 --> 00:19:27.000
into the fabric of the
application that you're

00:19:27.000 --> 00:19:30.460
building really encourages
you to do the right

00:19:30.460 --> 00:19:32.720
things along the way.

00:19:32.720 --> 00:19:36.090
So with that, I want to turn it
back over to Marc to give a

00:19:36.090 --> 00:19:38.060
demo that he's been
working on.

00:19:38.060 --> 00:19:39.310
MARC COHEN: Thanks, Joe.

00:19:41.520 --> 00:19:44.550
So I'd like to review a very
simple app that I've written

00:19:44.550 --> 00:19:46.550
to try to illustrate some of
the concepts we've been

00:19:46.550 --> 00:19:47.330
talking about today.

00:19:47.330 --> 00:19:48.780
I call it Ping Me!

00:19:48.780 --> 00:19:52.190
And the idea behind this app is
that we're going to serve a

00:19:52.190 --> 00:19:57.030
web service from a
cluster of VMs.

00:19:57.030 --> 00:20:00.120
We will deploy it on a very
simple stack, very

00:20:00.120 --> 00:20:05.910
lightweight, Node.js, the
Express web framework, and

00:20:05.910 --> 00:20:10.090
WebSockets to have some fun
with interactivity.

00:20:10.090 --> 00:20:12.410
What will happen is the server
that you reach will be

00:20:12.410 --> 00:20:16.510
selected by our Load Balancing
capability with built-in

00:20:16.510 --> 00:20:18.510
health checking.

00:20:18.510 --> 00:20:22.490
So to be clear, I'm previewing
something that we're in

00:20:22.490 --> 00:20:24.920
testing mode with right now.

00:20:24.920 --> 00:20:27.350
So it's not an openly available
feature of the

00:20:27.350 --> 00:20:28.470
product, but it's something
that we're

00:20:28.470 --> 00:20:30.010
actively working on.

00:20:30.010 --> 00:20:31.850
And I'll give you some
information at the end of the

00:20:31.850 --> 00:20:35.570
talk about how you can find out
more about that feature.

00:20:35.570 --> 00:20:38.920
So the way it'll work is you'll
connect to the Load

00:20:38.920 --> 00:20:41.900
Balancer-- or we'll connect
to the Load Balancer.

00:20:41.900 --> 00:20:44.700
A random server will
be selected among

00:20:44.700 --> 00:20:46.670
the available resources.

00:20:46.670 --> 00:20:49.810
And once you have the page
drawn, we'll click a button to

00:20:49.810 --> 00:20:51.140
ping the entire concept.

00:20:51.140 --> 00:20:53.100
And the idea is that
your pings are not

00:20:53.100 --> 00:20:55.140
really TCP/IP pings.

00:20:55.140 --> 00:20:57.700
They're not ICMP layer pings.

00:20:57.700 --> 00:20:59.380
They're application
layer pings.

00:20:59.380 --> 00:21:03.010
We're just sending a little
short text message to the

00:21:03.010 --> 00:21:06.140
selected server via WebSockets,
and that server is

00:21:06.140 --> 00:21:10.310
going to turn around and
distribute those pings to all

00:21:10.310 --> 00:21:15.360
of the client web apps connected
to the same server.

00:21:15.360 --> 00:21:19.400
As well, it's going to
distribute those messages to

00:21:19.400 --> 00:21:20.850
all of the connected servers.

00:21:20.850 --> 00:21:24.100
So basically, your messages will
get shared throughout the

00:21:24.100 --> 00:21:25.540
entire cluster.

00:21:25.540 --> 00:21:28.580
And it's going to be built on a
very simple self-configuring

00:21:28.580 --> 00:21:29.995
dynamic, shared-nothing
cluster.

00:21:32.890 --> 00:21:35.030
And the other interesting thing
about it, it's only 200

00:21:35.030 --> 00:21:35.740
lines of code.

00:21:35.740 --> 00:21:39.550
So this is a trivial app in
many ways, but I think it

00:21:39.550 --> 00:21:41.860
illustrates how much you can do
with Google Compute Engine.

00:21:41.860 --> 00:21:43.950
I think the reason it's so
small is a lot of the

00:21:43.950 --> 00:21:46.520
capabilities you might have to
build yourself are built right

00:21:46.520 --> 00:21:48.870
into the fabric of
the product.

00:21:48.870 --> 00:21:51.340
This is what it looks
like in action.

00:21:51.340 --> 00:21:54.280
And we'll actually run it live
in a few minutes, but I want

00:21:54.280 --> 00:21:56.850
to first take a few minutes
to show you some code.

00:21:56.850 --> 00:22:01.210
So it's built on two files,
app.js, a typical node server

00:22:01.210 --> 00:22:06.030
app, and index.html, the file
that it's serving up when you

00:22:06.030 --> 00:22:07.010
connect to this app.

00:22:07.010 --> 00:22:11.630
So we listen on port 80, and we
use the Express framework

00:22:11.630 --> 00:22:14.530
to wrap a few type
of get requests.

00:22:14.530 --> 00:22:17.480
The first one is just
a simple route path.

00:22:17.480 --> 00:22:20.920
Get request will return
index.html.

00:22:20.920 --> 00:22:24.510
And this health path, it gives
us the ability to respond to a

00:22:24.510 --> 00:22:27.350
health check from the
Load Balancer.

00:22:27.350 --> 00:22:30.560
This is nice because we can
define the semantics of what

00:22:30.560 --> 00:22:32.910
it means to be healthy at
the application layer.

00:22:32.910 --> 00:22:36.030
So we can just have that
blindly return OK--

00:22:36.030 --> 00:22:37.950
200 OK, I'm happy.

00:22:37.950 --> 00:22:40.475
Or we can build any sort of
application logic we want to,

00:22:40.475 --> 00:22:44.690
to fine-tune what it means to be
healthy and thereby affect

00:22:44.690 --> 00:22:46.970
whether we get requests
routed to us or not.

00:22:53.540 --> 00:22:56.350
We're going to listen for two
types of events on the

00:22:56.350 --> 00:22:57.290
connected sockets.

00:22:57.290 --> 00:23:01.210
So after we've served up the
index.html, the client's going

00:23:01.210 --> 00:23:04.380
to make a WebSockets call
back to the server.

00:23:04.380 --> 00:23:06.680
And we're also going
to get incoming

00:23:06.680 --> 00:23:08.860
connections from our peers.

00:23:08.860 --> 00:23:10.630
So the first type of event
is a browser ping.

00:23:10.630 --> 00:23:12.180
That's when someone
presses the button

00:23:12.180 --> 00:23:13.860
to send us a message.

00:23:13.860 --> 00:23:16.680
And what we're going to do
there is turn around and

00:23:16.680 --> 00:23:18.360
forward that to all
the connected

00:23:18.360 --> 00:23:21.200
browsers and all the peers.

00:23:21.200 --> 00:23:24.400
And so right away, that raises
the specter of things

00:23:24.400 --> 00:23:27.010
traveling around through loops
in a directed graph, and we

00:23:27.010 --> 00:23:27.700
don't want that.

00:23:27.700 --> 00:23:32.470
So you'll notice that the
forwarded ping event handler,

00:23:32.470 --> 00:23:36.770
ie, incoming pings that come
from peers in the cluster,

00:23:36.770 --> 00:23:39.250
will only be distributed
to the browsers, not

00:23:39.250 --> 00:23:40.150
to any other peers.

00:23:40.150 --> 00:23:41.770
So that's how we avoid loops.

00:23:41.770 --> 00:23:44.790
And of course, that implies that
all of the clusters are

00:23:44.790 --> 00:23:46.220
strongly connected
and in a mesh.

00:23:46.220 --> 00:23:49.130
And we've got a bit of logic
here to make sure that that

00:23:49.130 --> 00:23:52.356
happens, and it happens
automatically and dynamically.

00:23:52.356 --> 00:23:55.200
And here's the index.html
that gets served up.

00:23:55.200 --> 00:24:00.780
So here's the ping button, the
all important ping button And

00:24:00.780 --> 00:24:03.750
we have two divs to hold the
display of the servers and the

00:24:03.750 --> 00:24:06.050
incoming pings, and that's going
to be a real-time stream

00:24:06.050 --> 00:24:07.476
of the pings.

00:24:07.476 --> 00:24:10.120
The connect function is defined
here and called at the

00:24:10.120 --> 00:24:14.670
bottom, and that is going to do
the WebSockets connection.

00:24:14.670 --> 00:24:18.720
So I'm using the Socket.IO
library.

00:24:18.720 --> 00:24:21.550
And here are two event
handlers for on.ping.

00:24:21.550 --> 00:24:26.170
That's where a message comes in
to us from the server we're

00:24:26.170 --> 00:24:27.380
connected to.

00:24:27.380 --> 00:24:29.780
And all we want to do
is prepend that

00:24:29.780 --> 00:24:31.810
to the ping's div.

00:24:31.810 --> 00:24:34.250
And that way, we'll put it
at the top of the list.

00:24:34.250 --> 00:24:38.720
And so everything is going to
stream upward, I guess.

00:24:38.720 --> 00:24:40.680
It's like a stack essentially.

00:24:40.680 --> 00:24:42.880
The newest stuff
will be on top.

00:24:42.880 --> 00:24:50.450
And this is the action
to do when you

00:24:50.450 --> 00:24:51.710
click the ping button.

00:24:56.930 --> 00:24:59.320
Yeah, I think I messed up the
name there, but that's

00:24:59.320 --> 00:25:02.242
basically just sending
a ping to the server.

00:25:02.242 --> 00:25:04.770
OK, this is just a
system diagram.

00:25:04.770 --> 00:25:07.630
The user fetches the index.html
going through the

00:25:07.630 --> 00:25:08.300
Load Balancer.

00:25:08.300 --> 00:25:10.920
It gets assigned a web server,
and then it can ping and have

00:25:10.920 --> 00:25:13.700
the pings distributed locally.

00:25:13.700 --> 00:25:16.850
And then we'll show also a
multi-server capability where

00:25:16.850 --> 00:25:19.940
we fetch the page, we do the
ping, we get the local update,

00:25:19.940 --> 00:25:21.710
and then it also gets forwarded
to the peer, and we

00:25:21.710 --> 00:25:23.200
have remote updates happening.

00:25:23.200 --> 00:25:24.490
So let's take a look
at that now.

00:25:32.040 --> 00:25:34.260
So this is actually going to
fail because I don't have any

00:25:34.260 --> 00:25:35.960
VMs created.

00:25:35.960 --> 00:25:38.360
I'm going to start by
creating some VMs.

00:25:38.360 --> 00:25:42.630
So I have a little script
here called Add,

00:25:42.630 --> 00:25:44.820
which looks like this.

00:25:44.820 --> 00:25:49.100
And the gc.util command that you
see here is doing all the

00:25:49.100 --> 00:25:49.960
heavy lifting here.

00:25:49.960 --> 00:25:52.430
I'm just looping over
the input arguments.

00:25:52.430 --> 00:25:58.890
I'm going to put 0 and 1 in the
US Central 1A zone, 2 and

00:25:58.890 --> 00:26:00.620
3 in the Central 1B zone.

00:26:00.620 --> 00:26:02.710
And I'll just create
0, 1 and 2 for now,

00:26:02.710 --> 00:26:05.050
and we'll add 3 later.

00:26:05.050 --> 00:26:07.590
JOE BEDA: One thing to note
here is that command line

00:26:07.590 --> 00:26:09.360
looks pretty complex,
but that was

00:26:09.360 --> 00:26:10.940
generated using our console.

00:26:10.940 --> 00:26:14.010
So when you actually go to
launch a VM from the console,

00:26:14.010 --> 00:26:16.910
you can go ahead and do it
right there or actually

00:26:16.910 --> 00:26:19.520
capture a command that you
can go ahead and script.

00:26:19.520 --> 00:26:20.480
MARC COHEN: Right, thanks.

00:26:20.480 --> 00:26:22.890
And I wasn't quick enough to
show you, but those things

00:26:22.890 --> 00:26:25.970
that are spinning weren't
there a second ago.

00:26:25.970 --> 00:26:28.570
They immediately came into view,
and they started up.

00:26:28.570 --> 00:26:29.590
And you see they're all green.

00:26:29.590 --> 00:26:30.550
They've actually come up.

00:26:30.550 --> 00:26:32.740
That's how fast we start VMs.

00:26:32.740 --> 00:26:36.920
And as Joe said, there are some
really nice capabilities

00:26:36.920 --> 00:26:38.430
built right into--

00:26:38.430 --> 00:26:44.400
this is our new Cloud Console,
and it's a very nice, updated

00:26:44.400 --> 00:26:46.650
web user interface
for administering

00:26:46.650 --> 00:26:47.840
things across the cloud.

00:26:47.840 --> 00:26:51.130
So you can use this for lots
of the Cloud product, but

00:26:51.130 --> 00:26:53.680
we're going to focus
specifically on Compute Engine

00:26:53.680 --> 00:26:55.390
here today.

00:26:55.390 --> 00:27:00.610
So we now have Servers 0, 1 and
2, and we have this model,

00:27:00.610 --> 00:27:03.010
which is the genesis
of those servers.

00:27:03.010 --> 00:27:04.790
I'll try to talk about that a
little bit, but I've done a

00:27:04.790 --> 00:27:06.700
trick similar to what Joe showed
you where I have a

00:27:06.700 --> 00:27:08.250
model server.

00:27:08.250 --> 00:27:11.520
I customize it, add packages, do
everything I want to get it

00:27:11.520 --> 00:27:14.180
ready, and then I take
a snapshot of

00:27:14.180 --> 00:27:14.830
the Persistent Disk.

00:27:14.830 --> 00:27:17.410
I have a root-mounted Persistent
Disk on that model.

00:27:17.410 --> 00:27:20.510
I take a snapshot of it, and
then I can create Persistent

00:27:20.510 --> 00:27:24.670
Disks from that snapshot and
start up VMs very fast off of

00:27:24.670 --> 00:27:26.760
those Persistent Disks.

00:27:26.760 --> 00:27:30.830
I can also create a disk on the
fly with the VM targeted

00:27:30.830 --> 00:27:31.780
off of the snapshot.

00:27:31.780 --> 00:27:33.920
So there are a lot of nice
configuration options.

00:27:33.920 --> 00:27:36.290
I'm not going to go through
that in depth, but if you

00:27:36.290 --> 00:27:39.820
click New Instance, you get
prompted for all kinds of

00:27:39.820 --> 00:27:42.360
interesting ways to create
a new instance.

00:27:42.360 --> 00:27:44.200
So let's go back to Instances.

00:27:44.200 --> 00:27:46.195
And this failed because I
didn't have any servers.

00:27:46.195 --> 00:27:49.980
If I'm lucky, when I click
it, it does connect.

00:27:49.980 --> 00:27:53.240
OK, so what happened
was it served me a

00:27:53.240 --> 00:27:55.160
connection through that.

00:27:55.160 --> 00:27:58.490
So the 161 is a--

00:27:58.490 --> 00:28:01.770
other people may
be connecting.

00:28:01.770 --> 00:28:05.550
The 161 is the Load Balancer,
and it connected me

00:28:05.550 --> 00:28:07.010
through to Server 0.

00:28:07.010 --> 00:28:13.110
So let's clone that window and
pull it out of the Chrome

00:28:13.110 --> 00:28:18.100
frame and take a look at some
of the other servers.

00:28:18.100 --> 00:28:23.320
So I can actually click on
Server 1, and that reroutes my

00:28:23.320 --> 00:28:25.920
WebSocket connection
over to Server 1.

00:28:25.920 --> 00:28:27.870
And as you can see, if
I click Ping here, it

00:28:27.870 --> 00:28:29.930
shows up on my server.

00:28:29.930 --> 00:28:32.140
It's showing up on anybody
who's already connected.

00:28:32.140 --> 00:28:34.570
You guys are fast.

00:28:34.570 --> 00:28:36.300
I didn't say anything about the
address, and it's like,

00:28:36.300 --> 00:28:38.220
bam, you guys are in.

00:28:38.220 --> 00:28:41.340
And then if I ping here as well,
you can see it sends it.

00:28:41.340 --> 00:28:43.400
So what's happening is these
pings are getting distributed

00:28:43.400 --> 00:28:46.760
locally and throughout the
network, which is cool.

00:28:46.760 --> 00:28:51.910
Now let's try-- you guys are
going to try to DoS me here.

00:28:51.910 --> 00:28:53.330
So let's try something
interesting.

00:28:53.330 --> 00:28:54.940
Let's add a VM.

00:28:58.860 --> 00:29:01.130
And while we're waiting for that
to happen, let's take a

00:29:01.130 --> 00:29:02.740
look at the Cloud console.

00:29:02.740 --> 00:29:03.140
There it is.

00:29:03.140 --> 00:29:04.610
It's already starting.

00:29:04.610 --> 00:29:08.020
And I'll show you the
disks that I have.

00:29:08.020 --> 00:29:10.980
I have one disk for
each server here.

00:29:10.980 --> 00:29:11.805
You can see the zones.

00:29:11.805 --> 00:29:14.120
So the disks are
zone-affiliated, and then I

00:29:14.120 --> 00:29:16.550
have my master snapshot.

00:29:16.550 --> 00:29:24.320
So if I wanted to create
something with the

00:29:24.320 --> 00:29:27.420
characteristics of this
instance, there are two links

00:29:27.420 --> 00:29:29.650
down here that I want to
call your attention to.

00:29:29.650 --> 00:29:31.090
The first one is REST.

00:29:31.090 --> 00:29:37.530
And so this is the JSON
equivalent of how you would

00:29:37.530 --> 00:29:38.420
specify this.

00:29:38.420 --> 00:29:41.190
And technically, I'm not
saying this correctly.

00:29:41.190 --> 00:29:46.860
This is the JSON response from
a get.instance call.

00:29:46.860 --> 00:29:48.910
A better way to show this would
be to say, let's create

00:29:48.910 --> 00:29:52.070
a new instance, and I would
give some characteristics,

00:29:52.070 --> 00:29:53.430
select a bunch of stuff.

00:29:53.430 --> 00:29:59.340
And then down at the
bottom somewhere--

00:29:59.340 --> 00:30:02.200
there it is, Equivalent
REST or Command Line.

00:30:02.200 --> 00:30:05.350
I can click Command Line, and I
get the gcutil equivalent of

00:30:05.350 --> 00:30:07.990
that creation, and it'll adjust
to reflect all the

00:30:07.990 --> 00:30:09.640
specifications I give.

00:30:09.640 --> 00:30:14.270
And then the rest is, as I said
earlier, it's the JSON

00:30:14.270 --> 00:30:20.380
equivalent of the RESTful API
to do that instance add.

00:30:20.380 --> 00:30:22.000
This is really super-duper
powerful.

00:30:22.000 --> 00:30:24.000
I'm really excited about this,
and that's why I'm spending a

00:30:24.000 --> 00:30:25.310
lot of time on it.

00:30:25.310 --> 00:30:27.810
You can go through the UI and
use it as a very simple

00:30:27.810 --> 00:30:30.740
point-and-click mechanism to
specify what you want to do,

00:30:30.740 --> 00:30:33.790
and then you have immediate
access to things that tell you

00:30:33.790 --> 00:30:36.530
how to do the equivalent of
what you've just done

00:30:36.530 --> 00:30:39.890
interactively via code
and via command line.

00:30:39.890 --> 00:30:43.090
I think this is totally awesome,
and I'm really proud

00:30:43.090 --> 00:30:45.860
of what the engineering team
has done to make that

00:30:45.860 --> 00:30:47.820
available to you guys.

00:30:47.820 --> 00:30:49.380
Let's check on the instance.

00:30:49.380 --> 00:30:50.870
It's now up and running.

00:30:53.520 --> 00:30:59.170
So now, you see we have Server
0, 1, 2 and 3, and you may

00:30:59.170 --> 00:31:03.770
note that I didn't
refresh anything.

00:31:03.770 --> 00:31:09.110
So these web pages just
magically from WebSockets

00:31:09.110 --> 00:31:13.220
found out, oh, there's a new
server in the group and we're

00:31:13.220 --> 00:31:15.450
getting stuff from it.

00:31:15.450 --> 00:31:19.010
And as you can see, we're
still able to send--

00:31:19.010 --> 00:31:22.200
actually, there we go.

00:31:22.200 --> 00:31:25.170
You guys are hitting this so
hard that I couldn't see the

00:31:25.170 --> 00:31:26.850
ping I just sent.

00:31:26.850 --> 00:31:30.740
But the other thing I want to
show you very quickly is if I

00:31:30.740 --> 00:31:33.460
refresh that whole page,
I end up on Server 1.

00:31:33.460 --> 00:31:34.635
So it's just showing you
the Load Balancer

00:31:34.635 --> 00:31:36.270
is doing its thing.

00:31:36.270 --> 00:31:39.660
Now, one last thing I want to
show is I'm going to kill--

00:31:39.660 --> 00:31:44.035
actually, let me do the delete
using the console.

00:31:44.035 --> 00:31:47.000
So I'm going to select
Server 3.

00:31:47.000 --> 00:31:47.800
I'll scroll down there.

00:31:47.800 --> 00:31:48.970
And one thing to
note here, this

00:31:48.970 --> 00:31:52.250
robust-io13, that's a tag.

00:31:52.250 --> 00:31:55.680
And that gives us the ability
to refer collectively to a

00:31:55.680 --> 00:31:59.070
group of servers via the tag,
which is very convenient when

00:31:59.070 --> 00:32:02.960
you're administering networking
capabilities.

00:32:02.960 --> 00:32:05.110
For example, you could have a
firewall rule that says, let

00:32:05.110 --> 00:32:08.340
this traffic in for any VM
with that particular tag.

00:32:08.340 --> 00:32:09.260
That's a nice capability.

00:32:09.260 --> 00:32:10.990
I won't go too far into
that right now.

00:32:10.990 --> 00:32:15.625
But I'm going to delete this
instance, and Cloud Console

00:32:15.625 --> 00:32:17.695
will show it spinning.

00:32:20.240 --> 00:32:22.530
And let's see if there's
anything else I wanted to show

00:32:22.530 --> 00:32:24.030
you on the Cloud Console.

00:32:24.030 --> 00:32:26.610
I am going a little late on
time, so let me see what I

00:32:26.610 --> 00:32:28.180
have coming up here.

00:32:33.290 --> 00:32:34.540
OK.

00:32:38.246 --> 00:32:40.790
It's still deleting, so let's
come back to that.

00:32:43.300 --> 00:32:46.690
Just in the name of time here,
let's keep marching ahead.

00:32:46.690 --> 00:32:49.810
So I've shown you a multi-server
configuration.

00:32:49.810 --> 00:32:51.795
We talked about the
single server.

00:32:51.795 --> 00:32:54.980
Let me enlarge that for you
guys, and let's look at the

00:32:54.980 --> 00:32:56.020
multi server.

00:32:56.020 --> 00:32:57.740
We've talked about that.

00:32:57.740 --> 00:32:59.880
If you're a real world
application, of course you

00:32:59.880 --> 00:33:01.430
never have just a
pure web server.

00:33:01.430 --> 00:33:04.880
You have some sort of back-end
datastore, and it's really

00:33:04.880 --> 00:33:08.300
important to have that
capability also be resilient

00:33:08.300 --> 00:33:11.280
and fault tolerant and
nicely scalable.

00:33:11.280 --> 00:33:15.600
And so a typical approach here
is to choose one of many

00:33:15.600 --> 00:33:19.440
popular open source or
commercial database servers--

00:33:19.440 --> 00:33:21.360
there are a lot of great
choices out there--

00:33:21.360 --> 00:33:24.270
and deploy them in this
sort of a fashion.

00:33:24.270 --> 00:33:26.730
If you get big enough, you
probably want some sort of a

00:33:26.730 --> 00:33:29.520
load balancing capability, an
internal load balancing

00:33:29.520 --> 00:33:32.230
capability between your
front-ends and your back-ends.

00:33:32.230 --> 00:33:36.600
This is a widely known practiced
standard throughout

00:33:36.600 --> 00:33:37.610
the industry.

00:33:37.610 --> 00:33:39.590
But there's another option which
I want to talk about,

00:33:39.590 --> 00:33:41.830
which is to replace the
whole back-end tier

00:33:41.830 --> 00:33:43.510
with a managed service.

00:33:43.510 --> 00:33:47.320
And Joe talked earlier about
some of the capabilities we

00:33:47.320 --> 00:33:50.740
either have been offering or
have recently announced like

00:33:50.740 --> 00:33:53.790
Google Cloud Storage, the Cloud

00:33:53.790 --> 00:33:55.970
Datastore, and Cloud SQL.

00:33:55.970 --> 00:33:58.590
And the beauty of this approach
is that you tap

00:33:58.590 --> 00:34:00.850
into-- it's like what I was
talking about earlier about

00:34:00.850 --> 00:34:03.480
taking advantage of Google's DNA
and everything that's gone

00:34:03.480 --> 00:34:04.250
into our designs.

00:34:04.250 --> 00:34:09.909
You get to tap into a ton of
expertise and technology that

00:34:09.909 --> 00:34:13.560
makes it super easy to access
services that are just super

00:34:13.560 --> 00:34:18.710
scalable from day one, super
high availability, extremely

00:34:18.710 --> 00:34:21.860
replicated, geo-replicated,
all that good stuff.

00:34:21.860 --> 00:34:25.600
And you don't have to worry
about managing servers and

00:34:25.600 --> 00:34:26.850
processes anymore.

00:34:29.360 --> 00:34:29.860
So that's it.

00:34:29.860 --> 00:34:34.510
Let me jump back to the demo and
see if it actually worked.

00:34:34.510 --> 00:34:36.530
OK, so Server 4 went away.

00:34:36.530 --> 00:34:38.690
Again, I didn't refresh
the app.

00:34:38.690 --> 00:34:39.520
I didn't do anything.

00:34:39.520 --> 00:34:40.976
Let's see if this guy's--

00:34:40.976 --> 00:34:41.710
yes.

00:34:41.710 --> 00:34:45.500
So you're probably wondering,
did that really work?

00:34:45.500 --> 00:34:47.670
It would be nice to have seen
that go away, but anyway,

00:34:47.670 --> 00:34:49.070
you'll have to trust
me on that.

00:34:49.070 --> 00:34:51.040
But these guys are talking
to each other.

00:34:51.040 --> 00:34:52.620
They're exchanging information
dynamically.

00:34:52.620 --> 00:34:55.170
They're using a lot of the
capabilities that Joe talked

00:34:55.170 --> 00:34:57.160
about earlier using metadata.

00:34:57.160 --> 00:34:59.510
The color that they use
is configured as

00:34:59.510 --> 00:35:00.340
part of their metadata.

00:35:00.340 --> 00:35:03.400
So when I create a new server, I
can assign it a color in its

00:35:03.400 --> 00:35:05.580
instance-specific metadata,
and it'll do

00:35:05.580 --> 00:35:06.910
that or change it.

00:35:06.910 --> 00:35:10.690
So a lot of nice capabilities
here along with the load

00:35:10.690 --> 00:35:15.380
balancing and the snapshots
and all that good stuff.

00:35:15.380 --> 00:35:18.170
So I'll try to finish up here
because I want to leave a

00:35:18.170 --> 00:35:19.950
little bit of time
for questions.

00:35:19.950 --> 00:35:24.620
The last thing I wanted to
mention is just a few simple

00:35:24.620 --> 00:35:27.090
takeaways that I want
to leave you with.

00:35:30.070 --> 00:35:33.870
So it's a summary of what we
felt were the key points we

00:35:33.870 --> 00:35:35.220
were sharing today.

00:35:35.220 --> 00:35:37.570
One is that reliable systems
are really a combination of

00:35:37.570 --> 00:35:38.400
infrastructure--

00:35:38.400 --> 00:35:39.630
that's what we're trying
to give you and

00:35:39.630 --> 00:35:40.960
do a great job of--

00:35:40.960 --> 00:35:41.520
design--

00:35:41.520 --> 00:35:45.520
that's your apps and all the
logic and business processes

00:35:45.520 --> 00:35:47.550
that you guys work with every
day-- and then people.

00:35:47.550 --> 00:35:49.270
And we talked about that
earlier, some of the good

00:35:49.270 --> 00:35:51.620
people processes that you need
to think about when you're

00:35:51.620 --> 00:35:53.740
building reliable systems.

00:35:53.740 --> 00:35:56.310
It's super important to manage
your config, your deployment,

00:35:56.310 --> 00:36:00.550
and your scaling as if were
code, as it were one of the

00:36:00.550 --> 00:36:03.810
critical artifacts of your
business because it really is.

00:36:03.810 --> 00:36:09.400
So the app I've shown is a toy,
and I think it shows a

00:36:09.400 --> 00:36:12.730
fairly cool amount of stuff that
you can do on your own.

00:36:12.730 --> 00:36:14.500
But as Joe mentioned earlier,
there are a lot of great

00:36:14.500 --> 00:36:18.660
options out there to do more
sophisticated and declarative

00:36:18.660 --> 00:36:21.810
type processes around that.

00:36:21.810 --> 00:36:23.670
Fast-starting servers
are awesome.

00:36:23.670 --> 00:36:24.690
They rock.

00:36:24.690 --> 00:36:25.820
They help you scale better.

00:36:25.820 --> 00:36:28.550
They help with your
availability, and we're

00:36:28.550 --> 00:36:31.940
looking forward to making
resources available even

00:36:31.940 --> 00:36:33.890
faster in the future.

00:36:33.890 --> 00:36:36.620
Power tools to build
self-configuring, shared,

00:36:36.620 --> 00:36:39.110
little, stateless servers along
the lines of what Joe

00:36:39.110 --> 00:36:42.150
showed you earlier are
really important.

00:36:42.150 --> 00:36:43.700
Take advantage of managed
services.

00:36:43.700 --> 00:36:47.460
As I just mentioned, there's a
real value, I think, in terms

00:36:47.460 --> 00:36:50.260
of not having to reinvent
the wheel there.

00:36:50.260 --> 00:36:52.350
And plan for all the
different types of

00:36:52.350 --> 00:36:54.330
outages that are possible.

00:36:54.330 --> 00:36:55.300
I didn't actually show this.

00:36:55.300 --> 00:36:58.400
I'd meant to, but I just
killed one server.

00:36:58.400 --> 00:37:00.860
I'm not going to take any more
time on it, but if I had

00:37:00.860 --> 00:37:05.990
killed 2 and 3, which were the
two in the 1 zone, you would

00:37:05.990 --> 00:37:08.300
have seen that the Load Balancer
was still happy, and

00:37:08.300 --> 00:37:10.550
all the service requests would
have just gone to one zone.

00:37:10.550 --> 00:37:13.340
So it perfectly would have
tolerated losing an entire

00:37:13.340 --> 00:37:16.610
zone in that model.

00:37:16.610 --> 00:37:18.610
And finally, stay tuned
for more awesomeness.

00:37:18.610 --> 00:37:20.400
We've mentioned the
Load Balancing.

00:37:20.400 --> 00:37:22.430
We haven't mentioned System
Monitoring, but that's another

00:37:22.430 --> 00:37:24.140
thing that we're working
on actively.

00:37:24.140 --> 00:37:27.880
And we're really excited about
continuing to add great value

00:37:27.880 --> 00:37:29.450
to this product.

00:37:29.450 --> 00:37:31.970
And we have something called the
Early Access Program that

00:37:31.970 --> 00:37:33.750
you can link to here.

00:37:33.750 --> 00:37:37.310
It's a way to sign up to get
access to some of these

00:37:37.310 --> 00:37:38.560
capabilities.

00:37:43.400 --> 00:37:45.510
And finally, your homework
is to take some of these

00:37:45.510 --> 00:37:47.910
guidelines and build super
awesome systems.

00:37:47.910 --> 00:37:49.980
We're really excited to see what
you guys are going to do

00:37:49.980 --> 00:37:51.710
with Google Compute Engine
and the Google

00:37:51.710 --> 00:37:54.540
Cloud Platform in general.

00:37:54.540 --> 00:37:57.950
Here's a few places you can
learn some more about the

00:37:57.950 --> 00:37:59.890
Compute Engine and
Cloud Platform.

00:37:59.890 --> 00:38:01.640
I'm going to make these
slides available via

00:38:01.640 --> 00:38:02.650
that link at the top.

00:38:02.650 --> 00:38:03.660
They're not there right now.

00:38:03.660 --> 00:38:05.770
If you go there right
now, it won't work.

00:38:05.770 --> 00:38:08.460
Within about an hour from the
end of this talk, I'll upload

00:38:08.460 --> 00:38:10.955
the slides, and you'll be
able to find them at

00:38:10.955 --> 00:38:14.710
bit.ly/robust-io13.

00:38:14.710 --> 00:38:16.040
And with that, I'd
like to thank you

00:38:16.040 --> 00:38:17.300
guys for coming today.

00:38:17.300 --> 00:38:18.840
And thank you, Joe.

00:38:18.840 --> 00:38:20.297
So we'll take--

00:38:20.297 --> 00:38:25.167
[APPLAUSE]

00:38:25.167 --> 00:38:27.560
MARC COHEN: And I think we
have one minute and eight

00:38:27.560 --> 00:38:28.550
seconds for questions.

00:38:28.550 --> 00:38:31.200
I apologize for that, but we'll
stay here and talk as

00:38:31.200 --> 00:38:33.740
long as you guys would like.

00:38:33.740 --> 00:38:34.990
Any questions?

00:38:36.925 --> 00:38:38.175
AUDIENCE: [INAUDIBLE]?

00:38:43.780 --> 00:38:47.010
MARC COHEN: So the question was,
to manage infrastructure

00:38:47.010 --> 00:38:49.850
and code, what kind of
tools do we use?

00:38:49.850 --> 00:38:53.710
So we have a bunch of internal,
as you would guess,

00:38:53.710 --> 00:38:56.940
elaborate tools and processes
at Google that we use to

00:38:56.940 --> 00:38:59.650
manage our code and our
development cycles and

00:38:59.650 --> 00:39:01.080
deployments and all
that stuff.

00:39:01.080 --> 00:39:03.620
I don't think we're allowed
to go into too

00:39:03.620 --> 00:39:06.520
much depth on that.

00:39:06.520 --> 00:39:08.750
Joe was talking about some of
the open source options like

00:39:08.750 --> 00:39:11.440
Chef and Puppet, as well as
the commercial Scalr and

00:39:11.440 --> 00:39:12.482
Rightscale.

00:39:12.482 --> 00:39:13.732
AUDIENCE: [INAUDIBLE]?

00:39:15.720 --> 00:39:18.160
JOE BEDA: We're always looking
at new opportunities to take

00:39:18.160 --> 00:39:20.360
some of our internal technology
and learnings and

00:39:20.360 --> 00:39:20.870
externalize them.

00:39:20.870 --> 00:39:24.040
We just have to prioritize what
we think will provide the

00:39:24.040 --> 00:39:25.670
most value and work our
way down the list.

00:39:25.670 --> 00:39:29.640
So eventually, hopefully we'll
find a way to get that stuff

00:39:29.640 --> 00:39:30.890
out to everybody.

00:39:32.920 --> 00:39:34.170
MARC COHEN: Other questions?

00:39:36.920 --> 00:39:39.750
We've either put you guys to
sleep, or we've answered--

00:39:39.750 --> 00:39:41.110
oh, here's a question.

00:39:41.110 --> 00:39:43.160
JOE BEDA: Do you mind
using the mic?

00:39:43.160 --> 00:39:44.410
Thank you.

00:39:47.870 --> 00:39:49.340
AUDIENCE: The scheduled
maintenance that Google

00:39:49.340 --> 00:39:52.060
undertakes regularly, just if
you could speak to patterns

00:39:52.060 --> 00:39:55.620
for designing robust systems
around that?

00:39:55.620 --> 00:39:57.705
JOE BEDA: Around the scheduled
maintenance?

00:39:57.705 --> 00:39:58.600
AUDIENCE: Yeah.

00:39:58.600 --> 00:40:00.350
JOE BEDA: Well, it's
essentially

00:40:00.350 --> 00:40:01.540
practicing for failure.

00:40:01.540 --> 00:40:04.410
I think you get some warning.

00:40:04.410 --> 00:40:05.720
It's a way for you to test your

00:40:05.720 --> 00:40:07.100
procedures and your systems.

00:40:07.100 --> 00:40:11.430
I think because we do have those
types of maintenances

00:40:11.430 --> 00:40:16.200
internally also, it leads us to
build systems that you have

00:40:16.200 --> 00:40:18.070
to be honest with yourself,
and you can't cheat.

00:40:18.070 --> 00:40:19.260
You can't get away with it.

00:40:19.260 --> 00:40:22.510
MARC COHEN: Were you referring
to the specific schedule that

00:40:22.510 --> 00:40:23.170
Google has?

00:40:23.170 --> 00:40:23.670
AUDIENCE: Yeah.

00:40:23.670 --> 00:40:26.710
MARC COHEN: Yeah, so the rule
of thumb is the zones

00:40:26.710 --> 00:40:30.130
currently go into a maintenance
window roughly

00:40:30.130 --> 00:40:31.540
twice a year.

00:40:31.540 --> 00:40:37.850
And they go into that state
for up to two weeks.

00:40:37.850 --> 00:40:41.250
AUDIENCE: A live service
at that point, you

00:40:41.250 --> 00:40:42.630
would move it across?

00:40:42.630 --> 00:40:45.780
MARC COHEN: Right, and so we
have some capabilities in that

00:40:45.780 --> 00:40:48.970
area to help, like the gcutil
command that I was using to

00:40:48.970 --> 00:40:53.350
show how to create instances
also has a capability for

00:40:53.350 --> 00:40:57.840
migrating virtual machines with
attached Persistent Disks

00:40:57.840 --> 00:40:59.410
from one zone to another.

00:40:59.410 --> 00:41:02.370
But we're continuing to work
on that area to make the

00:41:02.370 --> 00:41:05.690
process simpler and less
impactful on people.

00:41:05.690 --> 00:41:09.830
But we also feel like if you
design your system so that it

00:41:09.830 --> 00:41:13.260
tolerates a scheduled outage,
then you're doing the right

00:41:13.260 --> 00:41:15.780
thing for any eventuality.

00:41:15.780 --> 00:41:17.030
AUDIENCE: Thank you.

00:41:22.250 --> 00:41:24.685
MARC COHEN: I think
we're all done?

00:41:24.685 --> 00:41:25.935
Oh, one more.

00:41:27.870 --> 00:41:28.470
AUDIENCE: Hi, I'm [? Adi. ?]

00:41:28.470 --> 00:41:28.940
MARC COHEN: Hi.

00:41:28.940 --> 00:41:30.320
AUDIENCE: Now, right now,
there is a limitation in

00:41:30.320 --> 00:41:33.540
Google App Engine, like
60 seconds for

00:41:33.540 --> 00:41:36.430
processing a request.

00:41:36.430 --> 00:41:38.720
That is an App Engine.

00:41:38.720 --> 00:41:41.350
MARC COHEN: So the question was
about the 60 second limit

00:41:41.350 --> 00:41:41.960
on Google--

00:41:41.960 --> 00:41:44.100
AUDIENCE: In App Engine, but
the question is, does the

00:41:44.100 --> 00:41:46.580
limitation still continue when
you introduce the Load

00:41:46.580 --> 00:41:48.890
Balancer in Compute Engine?

00:41:48.890 --> 00:41:52.500
MARC COHEN: So is the 60 second
time out manifested in

00:41:52.500 --> 00:41:53.880
Google Compute Engine?

00:41:53.880 --> 00:41:56.070
AUDIENCE: No, in App Engine.

00:41:56.070 --> 00:41:59.540
So in Google Compute Engine,
if you introduce a Load

00:41:59.540 --> 00:42:05.910
Balancer, would that still be
a 60 second limitation?

00:42:05.910 --> 00:42:08.030
JOE BEDA: The type of Load
Balancer that we're demoing

00:42:08.030 --> 00:42:12.120
here is a low enough level
that it just forwards TCP

00:42:12.120 --> 00:42:12.730
connections.

00:42:12.730 --> 00:42:17.330
And so it's up to you to
implement whatever you want on

00:42:17.330 --> 00:42:18.150
top of that.

00:42:18.150 --> 00:42:21.360
So you can use it for things
beyond just HTTP also.

00:42:21.360 --> 00:42:22.610
AUDIENCE: OK.

00:42:25.280 --> 00:42:27.240
JOE BEDA: All right.

00:42:27.240 --> 00:42:28.100
MARC COHEN: So we'll
be around.

00:42:28.100 --> 00:42:29.470
You'll be here for
a little bit?

00:42:29.470 --> 00:42:29.610
JOE BEDA: Yeah.

00:42:29.610 --> 00:42:30.730
MARC COHEN: We'll hang out for
a little while if anybody

00:42:30.730 --> 00:42:31.820
wants to come down and talk.

00:42:31.820 --> 00:42:33.110
But thank you guys very much.

00:42:33.110 --> 00:42:34.010
Hope you had a great
conference,

00:42:34.010 --> 00:42:34.910
and have a good time.

00:42:34.910 --> 00:42:36.710
[APPLAUSE]

