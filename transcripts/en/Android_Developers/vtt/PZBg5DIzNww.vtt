WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.230
[MUSIC PLAYING]

00:00:03.793 --> 00:00:05.460
YIGIT BOYAR: Today,
we are going to talk

00:00:05.460 --> 00:00:08.490
about how to create a
modular Android application

00:00:08.490 --> 00:00:09.990
architecture.

00:00:09.990 --> 00:00:12.630
Obviously, the first question
we should ask ourselves

00:00:12.630 --> 00:00:14.717
is, why do we even
want to do it?

00:00:14.717 --> 00:00:16.050
And there's a couple of reasons.

00:00:16.050 --> 00:00:18.370
So we'll quickly
go through them.

00:00:18.370 --> 00:00:20.920
The first one is scale.

00:00:20.920 --> 00:00:23.580
So if you're writing an
application with you and maybe

00:00:23.580 --> 00:00:25.530
with your friend, it's easy.

00:00:25.530 --> 00:00:26.770
It's not going to be too big.

00:00:26.770 --> 00:00:29.950
Both of you can know everything
about the application.

00:00:29.950 --> 00:00:31.770
But as your application
grows, you're

00:00:31.770 --> 00:00:33.660
going to hire more developers.

00:00:33.660 --> 00:00:36.630
And it will be very hard
to work on the application

00:00:36.630 --> 00:00:39.490
without stepping on
each other's toes.

00:00:39.490 --> 00:00:42.360
So what you can do is you can
create these modules where

00:00:42.360 --> 00:00:46.200
people can specialize in certain
sections of the application,

00:00:46.200 --> 00:00:50.990
and they can work independently
without swarming down others.

00:00:50.990 --> 00:00:53.800
A similar benefit
is maintainability.

00:00:53.800 --> 00:00:56.200
So if you have a monolithic
application like this,

00:00:56.200 --> 00:00:57.580
where you have
all these layouts,

00:00:57.580 --> 00:01:00.680
and when you reach to dozens
and hundreds of layouts,

00:01:00.680 --> 00:01:02.650
it's going to be very
hard to look at it

00:01:02.650 --> 00:01:05.050
and understand what's going on.

00:01:05.050 --> 00:01:08.080
Instead, if you
group those layouts

00:01:08.080 --> 00:01:10.050
based on what
feature they're in,

00:01:10.050 --> 00:01:11.500
now it will be so much easier.

00:01:11.500 --> 00:01:12.980
When you're looking
for something,

00:01:12.980 --> 00:01:14.210
you will find it there.

00:01:14.210 --> 00:01:18.570
It will never be a long
list of weird names.

00:01:18.570 --> 00:01:21.730
And that has a new added
benefit, which is faster

00:01:21.730 --> 00:01:23.540
incremental compilation.

00:01:23.540 --> 00:01:25.510
So if we go back to
the previous example

00:01:25.510 --> 00:01:29.110
where you have this monolithic
application on the left

00:01:29.110 --> 00:01:31.720
and the modularized
application on the right,

00:01:31.720 --> 00:01:35.540
and we change the same file
in both of these scenarios,

00:01:35.540 --> 00:01:37.930
this is how much it's
going to invalidate.

00:01:37.930 --> 00:01:39.760
This is how much
Gradle needs to do--

00:01:39.760 --> 00:01:42.580
OK, check all of that
group, run more tasks.

00:01:42.580 --> 00:01:44.710
And those tasks will
have more inputs,

00:01:44.710 --> 00:01:46.480
and they will take
longer to run.

00:01:46.480 --> 00:01:50.640
The smaller they are,
the faster it is.

00:01:50.640 --> 00:01:54.160
Similarly, you can also run your
continuous integration service

00:01:54.160 --> 00:01:55.762
faster.

00:01:55.762 --> 00:01:57.220
So if you have an
application where

00:01:57.220 --> 00:01:58.870
we have properly modularized--

00:01:58.870 --> 00:02:00.758
we have a couple
of small modules,

00:02:00.758 --> 00:02:02.800
and there are bigger
modules that depend on them.

00:02:02.800 --> 00:02:06.230
And the application at the
end depends on all of them.

00:02:06.230 --> 00:02:10.030
If you made a change in
this, let's say, module5,

00:02:10.030 --> 00:02:14.200
which test do you need to run to
make sure that change is good?

00:02:14.200 --> 00:02:15.880
The answer is very simple--

00:02:15.880 --> 00:02:19.450
only that one and anything
else that depends on it.

00:02:19.450 --> 00:02:21.140
This is the only
test you need to run.

00:02:21.140 --> 00:02:23.830
You don't need to run all of
your tests because the other

00:02:23.830 --> 00:02:27.370
modules cannot be impacted.

00:02:27.370 --> 00:02:30.520
You might say, well, we
don't have incremental CI.

00:02:30.520 --> 00:02:32.640
Many people are
in this situation.

00:02:32.640 --> 00:02:35.950
And it's the same
situation for AndroidX.

00:02:35.950 --> 00:02:40.090
So this is what we do
in AndroidX development.

00:02:40.090 --> 00:02:44.560
We wrote a plugin that
discovers the dependency graph.

00:02:44.560 --> 00:02:47.500
And then this plugin looks
at the Git history, figures

00:02:47.500 --> 00:02:50.470
out which files are changed,
which modules include

00:02:50.470 --> 00:02:53.950
those files, and then
discovers which modules

00:02:53.950 --> 00:02:56.500
are affected by those changes.

00:02:56.500 --> 00:03:00.250
And then it only builds the
tests for those modules.

00:03:00.250 --> 00:03:03.820
And our test runner
runs only those tests.

00:03:03.820 --> 00:03:05.890
You can go and check
it from this URL.

00:03:05.890 --> 00:03:07.780
We will add it to the notes.

00:03:07.780 --> 00:03:10.420
And you can retrofit
for your own build.

00:03:10.420 --> 00:03:13.720
Before we did this change,
our pre-summit in AndroidX.

00:03:13.720 --> 00:03:15.910
was taking around two hours.

00:03:15.910 --> 00:03:17.560
After we made this
change, it now

00:03:17.560 --> 00:03:19.660
takes from 10 to 20
minutes, depending

00:03:19.660 --> 00:03:22.840
on what you have changed.

00:03:22.840 --> 00:03:26.500
Last but not least, it's
also good for business.

00:03:26.500 --> 00:03:29.290
When you modularize your
application with app bundles

00:03:29.290 --> 00:03:32.270
and dynamic delivery-- we
will talk about that later--

00:03:32.270 --> 00:03:35.410
you can significantly
reduce your install size.

00:03:35.410 --> 00:03:38.110
From Play Store stats,
we know that many

00:03:38.110 --> 00:03:40.900
of your users drop between
the time they clicked on

00:03:40.900 --> 00:03:44.540
install to the time they
start using your application.

00:03:44.540 --> 00:03:47.350
So the smaller your
application, the less it takes.

00:03:47.350 --> 00:03:50.680
And you will have
just more sign-ups.

00:03:50.680 --> 00:03:53.740
Similarly, it also lets
you test different things.

00:03:53.740 --> 00:03:55.930
Let's say you have
an application that

00:03:55.930 --> 00:03:57.130
has a camera feature.

00:03:57.130 --> 00:03:59.980
And your PM comes
with this idea like, I

00:03:59.980 --> 00:04:01.960
found this amazing library.

00:04:01.960 --> 00:04:05.020
It's 10 megabytes, but it
takes beautiful photos.

00:04:05.020 --> 00:04:07.780
Now, you don't need to argue
whether it's good or not.

00:04:07.780 --> 00:04:10.000
You can implement it as
a dynamically delivered

00:04:10.000 --> 00:04:13.420
feature, A/B test
it, see if it helps,

00:04:13.420 --> 00:04:15.620
and then distribute it
to all of your users.

00:04:15.620 --> 00:04:18.040
This gives you a
lot more flexibility

00:04:18.040 --> 00:04:21.040
in trying out different
things in your application

00:04:21.040 --> 00:04:23.870
without hurting your users.

00:04:23.870 --> 00:04:25.870
FLORINA MUNTENENSCU:
Modules, modules, modules--

00:04:25.870 --> 00:04:29.330
you'll be hearing a lot
this word in this talk.

00:04:29.330 --> 00:04:32.522
So what kind of modules are we
actually talking about here?

00:04:32.522 --> 00:04:34.480
Well, we're going to talk
about greater library

00:04:34.480 --> 00:04:37.420
modules but also dynamic
feature modules that

00:04:37.420 --> 00:04:41.390
are part of the Android App
Bundle packaging concept.

00:04:41.390 --> 00:04:45.160
So let's see how we define
what we put inside a module?

00:04:45.160 --> 00:04:47.560
How should we modularize?

00:04:47.560 --> 00:04:51.520
So we can do this either
by feature or by layer.

00:04:51.520 --> 00:04:54.220
So let's start with
feature modularization.

00:04:54.220 --> 00:04:57.190
Let's see what module types
would work for features,

00:04:57.190 --> 00:05:00.070
and also what are the
different options for packaging

00:05:00.070 --> 00:05:04.400
that we would have, and what
are the implications of these.

00:05:04.400 --> 00:05:07.690
So we would have a base app.

00:05:07.690 --> 00:05:10.540
That's just an
Android application.

00:05:10.540 --> 00:05:14.050
And then we could have a module
that's an Android library.

00:05:14.050 --> 00:05:16.820
The app would depend
on this library.

00:05:16.820 --> 00:05:18.580
So this means that
app would have

00:05:18.580 --> 00:05:23.080
access to the code and
resources from module1.

00:05:23.080 --> 00:05:26.500
But the other modules can
be dynamic feature modules.

00:05:26.500 --> 00:05:29.200
And dynamic feature modules
can be used for on-demand code

00:05:29.200 --> 00:05:32.110
loading via dynamic delivery.

00:05:32.110 --> 00:05:34.490
And they would
also depend on app.

00:05:34.490 --> 00:05:36.580
So this means that
module1 and module2

00:05:36.580 --> 00:05:40.530
would have access to the
code and resources from app.

00:05:40.530 --> 00:05:43.270
But then app would
declare these modules

00:05:43.270 --> 00:05:48.280
in the build.gradle file
as dynamic feature modules.

00:05:48.280 --> 00:05:49.780
So what's important
to remember here

00:05:49.780 --> 00:05:54.040
is that app doesn't actually
depend on module2 or module3.

00:05:54.040 --> 00:05:56.620
This is actually the main
restriction of the feature

00:05:56.620 --> 00:05:58.790
modules in the app.

00:05:58.790 --> 00:06:01.090
So even if the
app doesn't really

00:06:01.090 --> 00:06:03.220
have access to the
code and resources,

00:06:03.220 --> 00:06:08.410
I think this allows the option
to have the on-demand delivery

00:06:08.410 --> 00:06:10.390
of feature modules.

00:06:10.390 --> 00:06:14.440
So through dynamic delivery,
users can download and install

00:06:14.440 --> 00:06:17.230
dynamic features on demand.

00:06:17.230 --> 00:06:20.310
Modules that have
onDemand turned off

00:06:20.310 --> 00:06:23.710
are by default added
as part of your APK,

00:06:23.710 --> 00:06:25.810
of the one that's
downloaded or installed

00:06:25.810 --> 00:06:28.520
on your device by the users.

00:06:28.520 --> 00:06:30.400
And if you enable
on-demand delivery,

00:06:30.400 --> 00:06:32.710
it means that you
as developers also

00:06:32.710 --> 00:06:35.440
need to manage the
download of the module

00:06:35.440 --> 00:06:38.520
from Google Play Store.

00:06:38.520 --> 00:06:41.130
Then shared code
and resources would

00:06:41.130 --> 00:06:43.320
be part of the core library.

00:06:43.320 --> 00:06:47.280
And a nice benefit of
on-demand delivered modules

00:06:47.280 --> 00:06:50.940
is that you can depend
on a third-party library

00:06:50.940 --> 00:06:53.160
and only download it
when you're actually

00:06:53.160 --> 00:06:54.670
downloading that module.

00:06:54.670 --> 00:06:57.900
So this means that you're able
to decrease your APK size even

00:06:57.900 --> 00:06:59.940
more.

00:06:59.940 --> 00:07:03.920
OK, but how do we decide what
is a dynamic feature module

00:07:03.920 --> 00:07:05.270
and what's not?

00:07:05.270 --> 00:07:08.630
So for this, I'd like to look
at the 80/20 principle that

00:07:08.630 --> 00:07:13.340
says that 80% of your users
are using 20% of your app.

00:07:13.340 --> 00:07:17.210
So look at the other 80%, look
at those features that are not

00:07:17.210 --> 00:07:19.940
part of your core flow
of the app, things

00:07:19.940 --> 00:07:23.150
like expert features
or paid features

00:07:23.150 --> 00:07:25.590
that can be downloaded later.

00:07:25.590 --> 00:07:27.980
Similarly, you
can have a feature

00:07:27.980 --> 00:07:31.500
like onboarding that can be
afterwards uninstalled later.

00:07:31.500 --> 00:07:34.230
So here, the onDemand
will be false.

00:07:34.230 --> 00:07:38.000
And then you would be able
to clean up a bit the space.

00:07:38.000 --> 00:07:41.065
But how about something
like an About screen.

00:07:41.065 --> 00:07:42.440
This is something
that's not part

00:07:42.440 --> 00:07:44.900
of the core flow of the app.

00:07:44.900 --> 00:07:46.590
Should this be on demand or not?

00:07:46.590 --> 00:07:49.880
Should this be a
dynamic feature or not?

00:07:49.880 --> 00:07:52.880
I think rather this is a
better candidate for an Android

00:07:52.880 --> 00:07:53.660
library.

00:07:53.660 --> 00:07:56.930
Because what you want is
to have an instant access

00:07:56.930 --> 00:07:58.130
to that About screen.

00:07:58.130 --> 00:07:59.005
It's something small.

00:07:59.005 --> 00:08:01.463
You want to make sure that you
have a good user experience.

00:08:01.463 --> 00:08:03.500
You don't want the
users to wait for this.

00:08:03.500 --> 00:08:07.490
And also, I don't think it's
worth having all the trouble

00:08:07.490 --> 00:08:09.890
that dynamic feature
modules bring for something

00:08:09.890 --> 00:08:13.060
simple like About.

00:08:13.060 --> 00:08:15.100
In Plaid, one of
our sample apps,

00:08:15.100 --> 00:08:17.270
we took a different approach.

00:08:17.270 --> 00:08:20.110
So Plaid is a news application.

00:08:20.110 --> 00:08:22.690
It aggregates data from
three different sources--

00:08:22.690 --> 00:08:25.990
Designer News, Dribble,
and Product Hunt.

00:08:25.990 --> 00:08:28.960
And each of these sources
have their own presentation

00:08:28.960 --> 00:08:30.860
and business logic.

00:08:30.860 --> 00:08:33.580
So what we wanted to do
is to have the possibility

00:08:33.580 --> 00:08:35.620
of on-demand delivery.

00:08:35.620 --> 00:08:38.289
So we wanted to be able
to download these data

00:08:38.289 --> 00:08:39.880
sources whenever we need them.

00:08:39.880 --> 00:08:42.340
We wanted to be able
to add in the future.

00:08:42.340 --> 00:08:43.990
others.

00:08:43.990 --> 00:08:48.240
So this means that designernews
and dribble are dynamic feature

00:08:48.240 --> 00:08:49.540
modules.

00:08:49.540 --> 00:08:53.350
But then we looked at something
like search and about.

00:08:53.350 --> 00:08:56.750
These wouldn't benefit
from on-demand delivery.

00:08:56.750 --> 00:09:00.650
So we left these
as library modules.

00:09:00.650 --> 00:09:03.176
Now, let's see how we
can modularize per layer.

00:09:03.176 --> 00:09:05.360
YIGIT BOYAR: Thank you.

00:09:05.360 --> 00:09:07.540
So one option is to
modularize your application

00:09:07.540 --> 00:09:08.900
based on features.

00:09:08.900 --> 00:09:11.320
Another, albeit
simpler option is

00:09:11.320 --> 00:09:14.060
to use a layered modularization.

00:09:14.060 --> 00:09:15.710
So what do I mean by this?

00:09:15.710 --> 00:09:17.740
So let's look at the
Plaid application

00:09:17.740 --> 00:09:19.630
again that Florina talked about.

00:09:19.630 --> 00:09:22.090
Let's look at what kind
of user features we have

00:09:22.090 --> 00:09:25.130
and what technologies
we need for them.

00:09:25.130 --> 00:09:27.050
So we said we have
stream of news.

00:09:27.050 --> 00:09:29.350
So we need a place
to process them.

00:09:29.350 --> 00:09:31.510
We need API clients
to fetch them.

00:09:31.510 --> 00:09:34.450
And we also need a UI
that shows those feeds.

00:09:34.450 --> 00:09:36.340
Now, we have multiple
news providers,

00:09:36.340 --> 00:09:39.610
so we need probably different
web service clients.

00:09:39.610 --> 00:09:41.890
We want to have custom
styles because we

00:09:41.890 --> 00:09:45.610
want to style these news
based on their source.

00:09:45.610 --> 00:09:47.790
So we need the custom
styling library.

00:09:47.790 --> 00:09:50.230
And we need
authentication because we

00:09:50.230 --> 00:09:54.680
want people to be able to vote
and comment on these stories.

00:09:54.680 --> 00:09:56.950
Which means we also need
a post UI where people

00:09:56.950 --> 00:10:00.220
can see the details of a story
and the comments associated

00:10:00.220 --> 00:10:01.700
with it.

00:10:01.700 --> 00:10:04.420
So we'll take a
bottom-up approach here.

00:10:04.420 --> 00:10:08.740
We start with the
database, using Room,

00:10:08.740 --> 00:10:10.800
I guess, as a [INAUDIBLE].

00:10:10.800 --> 00:10:12.640
And then, inside
this database module,

00:10:12.640 --> 00:10:16.100
we have our entities
and data access objects.

00:10:16.100 --> 00:10:17.830
And then we have a
web service module

00:10:17.830 --> 00:10:21.820
on the site that depends
on Retrofit and JSON Parser

00:10:21.820 --> 00:10:25.030
because all of the API we
use here use JSON Parser.

00:10:25.030 --> 00:10:28.660
We can use Moshi, and it also
has data transfer objects.

00:10:28.660 --> 00:10:30.368
We will talk about them later.

00:10:30.368 --> 00:10:31.910
Now we may move over
to repositories.

00:10:31.910 --> 00:10:36.430
This is where most of our
actual business logic lives in.

00:10:36.430 --> 00:10:39.100
And now we have things like
user repository or Dribble

00:10:39.100 --> 00:10:42.340
repository for stuff
coming from Dribble.

00:10:42.340 --> 00:10:44.830
On top, we have our
user interfaces,

00:10:44.830 --> 00:10:47.440
which just talk to
these repositories

00:10:47.440 --> 00:10:49.900
to display whatever
is necessary.

00:10:49.900 --> 00:10:51.640
Last but not least,
we said we also

00:10:51.640 --> 00:10:53.320
need a custom styling library.

00:10:53.320 --> 00:10:55.690
But it can be a
module just by itself

00:10:55.690 --> 00:10:59.750
because it's not really
related to our application.

00:10:59.750 --> 00:11:03.500
Now let's see how we can benefit
from this kind of layering.

00:11:03.500 --> 00:11:07.050
One option is isolation.

00:11:07.050 --> 00:11:09.575
So there's a little
crash course here.

00:11:09.575 --> 00:11:12.380
When a module says, I
depend on another module,

00:11:12.380 --> 00:11:17.440
it can either say "API"
or "implementation."

00:11:17.440 --> 00:11:20.250
I know it's confusing, so I'm
going to quickly explain them.

00:11:20.250 --> 00:11:23.390
When a module A says, I
have an API dependence

00:11:23.390 --> 00:11:26.780
on module B, that means all
of the public functionality

00:11:26.780 --> 00:11:30.350
provided by module B
is also provided my B.

00:11:30.350 --> 00:11:35.060
So my dependence can access
module B's public API.

00:11:35.060 --> 00:11:38.900
But if it says it's an
implementation detail,

00:11:38.900 --> 00:11:42.740
then modules that depend
on A cannot see B.

00:11:42.740 --> 00:11:46.180
They should know about B.
And this gives us some power.

00:11:46.180 --> 00:11:48.260
So let's get to a
practical example

00:11:48.260 --> 00:11:52.460
where we have an API that
returns us a list of comments.

00:11:52.460 --> 00:11:54.830
Each comment has
some data inside it.

00:11:54.830 --> 00:11:58.790
And we have a user object
about who made that comment.

00:11:58.790 --> 00:12:00.740
Now, if you want to move
this to our database,

00:12:00.740 --> 00:12:04.330
we want to persist it,
so we create an entity.

00:12:04.330 --> 00:12:05.810
It's our Comment entity.

00:12:05.810 --> 00:12:11.200
Inside that, we have an id,
we have the text and the user.

00:12:11.200 --> 00:12:14.720
Now, if you look at this entity,
there is a little problem here

00:12:14.720 --> 00:12:17.120
because probably we have
the same users commenting

00:12:17.120 --> 00:12:18.090
all the time.

00:12:18.090 --> 00:12:20.480
So it's not a very good idea
to keep that information

00:12:20.480 --> 00:12:22.100
inside the Comment object.

00:12:22.100 --> 00:12:24.740
Because if a user changes
their profile photo,

00:12:24.740 --> 00:12:26.930
you need to go and
update all of them.

00:12:26.930 --> 00:12:30.360
Another option we can do is
just create the user table.

00:12:30.360 --> 00:12:32.720
But then we cannot do it
because our server says,

00:12:32.720 --> 00:12:35.010
the user's inside
the Comment object.

00:12:35.010 --> 00:12:37.610
There's a really easy solution
for this kind of problems.

00:12:37.610 --> 00:12:40.390
We can make this a
data transfer object.

00:12:40.390 --> 00:12:42.320
A data transfer
object is specifically

00:12:42.320 --> 00:12:45.530
designed to get the data from
your back end to a format

00:12:45.530 --> 00:12:47.900
that your application
can understand.

00:12:47.900 --> 00:12:51.110
Now, we can have a separate
object for our database.

00:12:51.110 --> 00:12:52.790
We'll call that one Comment.

00:12:52.790 --> 00:12:54.440
And that one can
have the userid.

00:12:54.440 --> 00:12:56.710
It'll also have a user table.

00:12:56.710 --> 00:12:58.580
But now, why did we
do this separation?

00:12:58.580 --> 00:13:01.260
Let's see how it
plays in practice.

00:13:01.260 --> 00:13:03.050
So we'll go through
this scenario.

00:13:03.050 --> 00:13:06.950
Our repository calls the web
service to get the comments.

00:13:06.950 --> 00:13:09.200
We get the list of Comment DTOs.

00:13:09.200 --> 00:13:11.500
Then the repository
divides these into two--

00:13:11.500 --> 00:13:14.240
it divides them into
users and comments

00:13:14.240 --> 00:13:17.850
and pushes them back
to the database.

00:13:17.850 --> 00:13:21.620
Now let's look at how we
declare our dependencies now.

00:13:21.620 --> 00:13:24.655
Our web service says, I have
an implementation dependency

00:13:24.655 --> 00:13:27.410
on Retrofit because
the repository doesn't

00:13:27.410 --> 00:13:28.910
need to know about that.

00:13:28.910 --> 00:13:30.740
It doesn't matter.

00:13:30.740 --> 00:13:33.080
Similarly, database
says, I'm using Room,

00:13:33.080 --> 00:13:37.120
but no one else needs to know
about it Repository says,

00:13:37.120 --> 00:13:39.760
I'm using the web services
and implementation dependency

00:13:39.760 --> 00:13:43.840
because UI doesn't need to know
where the data is coming from.

00:13:43.840 --> 00:13:46.870
But then here, we say,
we have an API dependency

00:13:46.870 --> 00:13:47.720
on the database.

00:13:47.720 --> 00:13:49.360
So in this example,
we are doing it

00:13:49.360 --> 00:13:51.880
because it's very likely
that the same object we

00:13:51.880 --> 00:13:54.730
are using in the
database is what we also

00:13:54.730 --> 00:13:56.260
want to use in the UI.

00:13:56.260 --> 00:13:59.440
Or it might be pulling
these objects as different

00:13:59.440 --> 00:14:02.660
[INAUDIBLE] from the
database for our UI.

00:14:02.660 --> 00:14:08.770
So we need to set it as an API
dependency now, which is fine.

00:14:08.770 --> 00:14:11.710
But not that fine because
now our user interface

00:14:11.710 --> 00:14:12.910
can't see the entities.

00:14:12.910 --> 00:14:14.090
We want that.

00:14:14.090 --> 00:14:15.970
But we don't want
our user interfaces

00:14:15.970 --> 00:14:17.350
to have access to the database.

00:14:17.350 --> 00:14:19.570
Because if they
access the database,

00:14:19.570 --> 00:14:21.700
now we lost the layering
because they know

00:14:21.700 --> 00:14:23.440
where the data is coming from.

00:14:23.440 --> 00:14:25.550
They shouldn't, [INAUDIBLE].

00:14:25.550 --> 00:14:27.530
Now, there's two
options you can do here.

00:14:27.530 --> 00:14:29.193
You can be fine with this.

00:14:29.193 --> 00:14:30.610
You know, if someone
writes a code

00:14:30.610 --> 00:14:33.280
that makes a database query
in the UI layer, you're like,

00:14:33.280 --> 00:14:35.200
no, no, no, you
shouldn't do this.

00:14:35.200 --> 00:14:38.330
Or you can take this
one step further.

00:14:38.330 --> 00:14:41.470
We could create another module
for all of our common value

00:14:41.470 --> 00:14:44.230
objects that we use
across the application.

00:14:44.230 --> 00:14:46.340
Some of them might be entities.

00:14:46.340 --> 00:14:48.560
Some of them might be just
regular value objects.

00:14:48.560 --> 00:14:50.440
And in your database
module, you can have

00:14:50.440 --> 00:14:52.960
other entities and your DAOs.

00:14:52.960 --> 00:14:54.520
Now, the repository
can say, I have

00:14:54.520 --> 00:14:57.340
an API dependency on
these value objects

00:14:57.340 --> 00:15:00.950
versus just an implementation
dependency on the database.

00:15:00.950 --> 00:15:04.750
Once we do that, our UI only
has access to the classes

00:15:04.750 --> 00:15:06.800
we wanted to be able to access.

00:15:06.800 --> 00:15:09.980
So we get finer
control over them.

00:15:09.980 --> 00:15:12.790
Another nice benefit of
this kind of modularization

00:15:12.790 --> 00:15:15.270
is testing.

00:15:15.270 --> 00:15:17.340
So we say we have
repositories, and we

00:15:17.340 --> 00:15:19.710
have a user repository here.

00:15:19.710 --> 00:15:21.570
Whoever is writing
user repository

00:15:21.570 --> 00:15:24.630
can also create a fake
implementation of it.

00:15:24.630 --> 00:15:27.120
A fake implementation
has the same API,

00:15:27.120 --> 00:15:30.120
probably extends or
implements the user interface,

00:15:30.120 --> 00:15:32.860
but provides additional
functionality.

00:15:32.860 --> 00:15:36.970
So our user repository has
a getUser function that

00:15:36.970 --> 00:15:39.000
returns live data for user.

00:15:39.000 --> 00:15:41.320
The fake one has the
same functionality

00:15:41.320 --> 00:15:44.040
but can have other
things like put this user

00:15:44.040 --> 00:15:46.212
or put this user as an error.

00:15:46.212 --> 00:15:48.170
These are the things you
will need when you are

00:15:48.170 --> 00:15:50.940
trying to write your UI tests.

00:15:50.940 --> 00:15:53.380
Once we have that
in our application,

00:15:53.380 --> 00:15:55.050
we can make the
main UI component

00:15:55.050 --> 00:15:58.230
dependent on the actual
implementation and the test UI

00:15:58.230 --> 00:16:00.240
competent dependent
on the fakes.

00:16:00.240 --> 00:16:01.510
This will make it very easy.

00:16:01.510 --> 00:16:04.500
This is a much better approach
than trying to mock it.

00:16:04.500 --> 00:16:06.000
Because when you
mock something, you

00:16:06.000 --> 00:16:08.280
don't know how it is
supposed to behave.

00:16:08.280 --> 00:16:10.740
Versus the person who is
writing the repository

00:16:10.740 --> 00:16:12.840
knows how it will behave,
so they can create

00:16:12.840 --> 00:16:15.108
a much better fake for you.

00:16:15.108 --> 00:16:16.650
FLORINA MUNTENENSCU:
OK, so we looked

00:16:16.650 --> 00:16:19.740
at how to modularize by
feature and by layer.

00:16:19.740 --> 00:16:21.450
Feature modularization
brings you

00:16:21.450 --> 00:16:23.640
encapsulation and
the possibility

00:16:23.640 --> 00:16:25.730
of on-demand delivery.

00:16:25.730 --> 00:16:29.250
Modularization by layer
brings you isolation,

00:16:29.250 --> 00:16:31.710
allows you to isolate your
third-party dependencies

00:16:31.710 --> 00:16:33.810
or the layers in
your app, and also

00:16:33.810 --> 00:16:36.720
brings structure to our app.

00:16:36.720 --> 00:16:40.350
But you can also mix and
match a feature and a layer

00:16:40.350 --> 00:16:41.655
modularization.

00:16:41.655 --> 00:16:44.340
But if you're starting from
a monolithic application,

00:16:44.340 --> 00:16:46.590
we think that the
first that you could do

00:16:46.590 --> 00:16:49.290
is to start with a
layer modularization.

00:16:49.290 --> 00:16:53.040
And then, as time goes by, you
can go more towards a feature

00:16:53.040 --> 00:16:55.860
modularization.

00:16:55.860 --> 00:16:58.670
So let's see how to work
with dynamic feature modules.

00:16:58.670 --> 00:17:02.270
Because even if this
enables on-demand delivery,

00:17:02.270 --> 00:17:05.250
it also brings a few challenges.

00:17:05.250 --> 00:17:07.530
So the first one
is with navigation.

00:17:07.530 --> 00:17:09.859
So let's say that
our about feature is

00:17:09.859 --> 00:17:12.000
inside a dynamic feature.

00:17:12.000 --> 00:17:14.869
So from our main activity
that's part of app,

00:17:14.869 --> 00:17:17.390
we need to navigate to
this about activity.

00:17:17.390 --> 00:17:20.780
What we would usually do
is just launch an intent,

00:17:20.780 --> 00:17:23.810
saying, hey, start
this about activity.

00:17:23.810 --> 00:17:27.680
But I said that the app doesn't
have a reference to the code

00:17:27.680 --> 00:17:29.060
from about.

00:17:29.060 --> 00:17:32.090
So this means that you'll
get the compile error.

00:17:32.090 --> 00:17:33.770
To overcome this,
what you can do

00:17:33.770 --> 00:17:38.210
is just use Intent.setClassName
and pass the component name.

00:17:38.210 --> 00:17:40.910
I know this looks a bit
strange because it's hardcoded.

00:17:40.910 --> 00:17:44.120
And indeed, it means that when
you have to refactor your code,

00:17:44.120 --> 00:17:45.830
you need to make
sure that you're also

00:17:45.830 --> 00:17:48.260
updating this string.

00:17:48.260 --> 00:17:50.120
If you're working
with fragments,

00:17:50.120 --> 00:17:51.580
you have to do
something similar.

00:17:51.580 --> 00:17:54.500
You would have to use
reflection to create

00:17:54.500 --> 00:17:56.570
an instance of the Fragment.

00:17:56.570 --> 00:17:58.467
And with fragments,
there is an extra thing

00:17:58.467 --> 00:17:59.300
that you need to do.

00:17:59.300 --> 00:18:01.675
You need to make sure that
you also exclude the Fragment.

00:18:01.675 --> 00:18:05.110
names from [INAUDIBLE].

00:18:05.110 --> 00:18:06.393
We know that this is not nice.

00:18:06.393 --> 00:18:08.060
But at the same time,
we know that there

00:18:08.060 --> 00:18:11.050
are no runtime
performance hits for this.

00:18:11.050 --> 00:18:14.300
And we also want to help
improve this process

00:18:14.300 --> 00:18:17.060
to make navigation
between feature modules

00:18:17.060 --> 00:18:18.390
as natural as possible.

00:18:18.390 --> 00:18:21.410
So we are working on this as
part of the Navigation Jetpack

00:18:21.410 --> 00:18:23.700
library.

00:18:23.700 --> 00:18:26.540
OK, let's see how we can
discover dependencies

00:18:26.540 --> 00:18:28.380
in our app.

00:18:28.380 --> 00:18:29.960
Let's take the
following example.

00:18:29.960 --> 00:18:33.200
We have a search activity that
is part of the search module.

00:18:33.200 --> 00:18:36.830
And we want to be able to
search for news in Designer News

00:18:36.830 --> 00:18:38.370
and Dribble.

00:18:38.370 --> 00:18:42.470
So for now, let's consider
that these two feature modules,

00:18:42.470 --> 00:18:45.190
designernews and dribble,
are already downloaded,

00:18:45.190 --> 00:18:46.790
so are part of your app.

00:18:46.790 --> 00:18:49.730
But still, designernews,
dribble, and search

00:18:49.730 --> 00:18:52.280
are three completely
different modules.

00:18:52.280 --> 00:18:54.050
You don't have references.

00:18:54.050 --> 00:18:56.850
You don't know how
to use, how to call,

00:18:56.850 --> 00:18:58.990
which classes you should call.

00:18:58.990 --> 00:19:02.090
And we also want to make sure
that in the future, if we

00:19:02.090 --> 00:19:05.540
add another data source, we
can easily plug in that one

00:19:05.540 --> 00:19:06.900
as well.

00:19:06.900 --> 00:19:09.050
So we kind of want
somehow search

00:19:09.050 --> 00:19:12.150
to depend on
designernews and dribble.

00:19:12.150 --> 00:19:15.020
So what we do is we use the
Common Core library that

00:19:15.020 --> 00:19:16.920
is shared between all of these.

00:19:16.920 --> 00:19:20.360
So here, we're defining
the DataSource interface.

00:19:20.360 --> 00:19:22.630
And then designernews
and dribble

00:19:22.630 --> 00:19:24.740
implement that interface.

00:19:24.740 --> 00:19:28.100
And search holds a set
of these data sources,

00:19:28.100 --> 00:19:31.860
so it knows how
to query the data.

00:19:31.860 --> 00:19:33.900
But things are not
that easy because when

00:19:33.900 --> 00:19:36.450
we ought to instantiate
the DesignerNewsDataSource,

00:19:36.450 --> 00:19:38.440
we see that it depends
on other things.

00:19:38.440 --> 00:19:41.190
It works with the
StoriesRepository that on a row

00:19:41.190 --> 00:19:44.130
works with the RemoteDataSource
and the LocalDataSource that

00:19:44.130 --> 00:19:47.280
also work with Services,
SharedPreferences, maybe

00:19:47.280 --> 00:19:48.300
even Room.

00:19:48.300 --> 00:19:50.040
So there are a lot
of classes that you

00:19:50.040 --> 00:19:51.570
need to instantiate
when you want

00:19:51.570 --> 00:19:54.510
to create an instance of
DesignerNewsDataSource.

00:19:54.510 --> 00:19:56.255
So how do we do this?

00:19:56.255 --> 00:19:57.630
In general, what
we actually want

00:19:57.630 --> 00:20:00.540
is to have one single
entry point for creating

00:20:00.540 --> 00:20:02.620
the DesignerNewsDataSource.

00:20:02.620 --> 00:20:06.120
So we would have something like
a DataSourceProvider interface

00:20:06.120 --> 00:20:09.570
that would define the core
and getDataSource method that

00:20:09.570 --> 00:20:11.520
would allow us to retrieve it.

00:20:11.520 --> 00:20:13.770
And then, in
designernews, we would

00:20:13.770 --> 00:20:16.050
implement this
DataSourceProvider

00:20:16.050 --> 00:20:19.960
and then build the dependencies.

00:20:19.960 --> 00:20:22.510
In search, we would
need to provide

00:20:22.510 --> 00:20:24.800
the set of data sources.

00:20:24.800 --> 00:20:28.270
So we would check whether
a feature is installed.

00:20:28.270 --> 00:20:31.720
And then if it is,
we try to create

00:20:31.720 --> 00:20:35.500
an instance via the reflection
of that data source provider.

00:20:35.500 --> 00:20:38.160
And then we get the data
source from the provider

00:20:38.160 --> 00:20:42.180
and add it to our
set of data sources.

00:20:42.180 --> 00:20:49.160
Alternatively, you can also
do this via ServiceLoader.

00:20:49.160 --> 00:20:51.530
And you can check out both
versions, the reflection

00:20:51.530 --> 00:20:53.510
and the ServiceLoader,
in one of the samples

00:20:53.510 --> 00:20:57.080
that we released recently.

00:20:57.080 --> 00:20:59.440
OK, so we said
that we would need

00:20:59.440 --> 00:21:02.020
to create the dependencies.

00:21:02.020 --> 00:21:04.900
And chances are, a lot of you
here are also using Dagger.

00:21:04.900 --> 00:21:08.235
So let's see how you
could do this with Dagger.

00:21:08.235 --> 00:21:09.610
So if you're using
Dagger, you're

00:21:09.610 --> 00:21:11.350
most likely use
another component

00:21:11.350 --> 00:21:13.810
that you define in core.

00:21:13.810 --> 00:21:18.040
So then, in your designernews
DatSourceProvider,

00:21:18.040 --> 00:21:21.340
you would need to create
the graph for that component

00:21:21.340 --> 00:21:25.285
and then from that graph to
actually get the data source.

00:21:28.380 --> 00:21:30.470
So we said that
for the first case,

00:21:30.470 --> 00:21:34.260
our dynamic feature modules
were already installed.

00:21:34.260 --> 00:21:35.480
But what if they're not?

00:21:35.480 --> 00:21:37.850
What if when we're launching
the search activity,

00:21:37.850 --> 00:21:40.010
we only have designernews?

00:21:40.010 --> 00:21:42.050
And we want whenever
dribble was also

00:21:42.050 --> 00:21:46.380
installed to also start
searching for data in dribble.

00:21:46.380 --> 00:21:48.360
So we start from the same case.

00:21:48.360 --> 00:21:49.890
We still have a
data source that's

00:21:49.890 --> 00:21:52.280
implemented in
designernews and dribble.

00:21:52.280 --> 00:21:56.340
But now having just a set of
data sources is not enough.

00:21:56.340 --> 00:21:58.460
So we also use live
data to make sure

00:21:58.460 --> 00:22:00.350
that we're also
notifying whatever

00:22:00.350 --> 00:22:04.040
classes are interested
in these data sources.

00:22:04.040 --> 00:22:09.390
And then for convenience, we
wrap this inside the registry.

00:22:09.390 --> 00:22:12.170
So Play Core gives
us the possibility

00:22:12.170 --> 00:22:14.940
to react on modules that
have been installed.

00:22:14.940 --> 00:22:17.330
So this means that we can
register our own listener,

00:22:17.330 --> 00:22:19.720
and then this
listener also tells us

00:22:19.720 --> 00:22:21.570
when a module was installed.

00:22:21.570 --> 00:22:25.100
So this is the point where
we're getting the data source,

00:22:25.100 --> 00:22:26.610
as we've shown previously.

00:22:26.610 --> 00:22:30.400
And then we just add
it to the registry.

00:22:30.400 --> 00:22:32.460
Now let's see how we
work with databases.

00:22:32.460 --> 00:22:34.410
YIGIT BOYAR: Thank you.

00:22:34.410 --> 00:22:36.910
So when you start
modularizing your application,

00:22:36.910 --> 00:22:39.840
you're going to face this
problem with databases.

00:22:39.840 --> 00:22:42.250
I'm like, where do I put them?

00:22:42.250 --> 00:22:44.650
And there is no perfect
answer for this.

00:22:44.650 --> 00:22:47.610
So we're going to go
through some examples

00:22:47.610 --> 00:22:50.830
and options we can do here.

00:22:50.830 --> 00:22:53.850
So one option is-- it's the
easier one-- you can just

00:22:53.850 --> 00:22:56.370
have one database for all
of your application, which

00:22:56.370 --> 00:22:58.070
is what you usually
do when you're

00:22:58.070 --> 00:23:00.180
in monolithic application.

00:23:00.180 --> 00:23:01.950
Or you can create
a core database

00:23:01.950 --> 00:23:04.170
for the common
functionality and then

00:23:04.170 --> 00:23:07.410
have separate databases
for your features.

00:23:07.410 --> 00:23:09.930
And we also have
some plans with Room

00:23:09.930 --> 00:23:12.490
which are not ready yet, but
I want to talk about them

00:23:12.490 --> 00:23:14.500
because it's fun

00:23:14.500 --> 00:23:19.030
So how do we do it if we
have just one database?

00:23:19.030 --> 00:23:19.690
It's very easy.

00:23:19.690 --> 00:23:23.070
So we have this database
module that depends on Room.

00:23:23.070 --> 00:23:27.000
We put all of our entities and
all of our database objects

00:23:27.000 --> 00:23:28.810
into that, very simple.

00:23:28.810 --> 00:23:31.760
And then you have
modules depending on it.

00:23:31.760 --> 00:23:34.330
Now, if you have an
architecture like this,

00:23:34.330 --> 00:23:37.290
the nice thing is, it is
super simple to understand.

00:23:37.290 --> 00:23:39.660
You don't need to guess
where do I put it.

00:23:39.660 --> 00:23:41.100
You just put it there.

00:23:41.100 --> 00:23:43.320
And then you have only
one database connection

00:23:43.320 --> 00:23:44.580
to maintain.

00:23:44.580 --> 00:23:46.920
And then you can just keep
it open for the duration

00:23:46.920 --> 00:23:48.240
of your application.

00:23:48.240 --> 00:23:50.010
Database connections
are not cheap.

00:23:50.010 --> 00:23:54.370
So if you have multiple ones,
you need to be closing them.

00:23:54.370 --> 00:23:57.290
And this also gives you the
possibility to share tables.

00:23:57.290 --> 00:23:59.970
Like if you have
queries across modules,

00:23:59.970 --> 00:24:04.540
you can easily write them in
this common shared database.

00:24:04.540 --> 00:24:06.150
Now, the problem
with this approach

00:24:06.150 --> 00:24:09.570
is there's absolutely no
isolation between your modules.

00:24:09.570 --> 00:24:13.530
So description of a post
for one of the modules

00:24:13.530 --> 00:24:16.300
might be significantly
different than the other one.

00:24:16.300 --> 00:24:18.570
So now we need to rename
these tables to make

00:24:18.570 --> 00:24:20.350
sure they don't conflict.

00:24:20.350 --> 00:24:23.810
That would be hard when
you look at the code base.

00:24:23.810 --> 00:24:24.720
And even worse.

00:24:24.720 --> 00:24:27.180
Let's say you use the
dynamically delivered features

00:24:27.180 --> 00:24:28.650
that Florina mentioned.

00:24:28.650 --> 00:24:31.620
Now, even if you are delivering
the feature dynamically,

00:24:31.620 --> 00:24:34.230
you need to put all of
its entities and data

00:24:34.230 --> 00:24:37.930
access objects into this core
module that ships with the app.

00:24:37.930 --> 00:24:40.260
So it creates an
awkward division

00:24:40.260 --> 00:24:42.840
between the module
with these entities

00:24:42.840 --> 00:24:43.960
and the rest of its code.

00:24:43.960 --> 00:24:46.270
This is not something you want.

00:24:46.270 --> 00:24:48.460
OK, so let's go back
to the other extreme

00:24:48.460 --> 00:24:50.950
where we create a
database per module

00:24:50.950 --> 00:24:52.990
to achieve the
perfect isolation.

00:24:52.990 --> 00:24:54.820
So we have this each database.

00:24:54.820 --> 00:24:57.370
Authentication module
has own database,

00:24:57.370 --> 00:25:01.930
feed has own database, and
the post has own database.

00:25:01.930 --> 00:25:04.090
If we do that, we
reach our goal.

00:25:04.090 --> 00:25:08.020
There is perfect isolation
between all of these modules.

00:25:08.020 --> 00:25:10.990
But now we have many
database connections

00:25:10.990 --> 00:25:12.160
that we need to maintain.

00:25:12.160 --> 00:25:15.950
We cannot keep it open for the
duration of the app anymore.

00:25:15.950 --> 00:25:17.680
We need to start
tracking [INAUDIBLE],,

00:25:17.680 --> 00:25:20.620
querying the database,
and make sure to close it

00:25:20.620 --> 00:25:22.960
when we are not using it.

00:25:22.960 --> 00:25:25.750
Also, if you want to write
a query that touches two

00:25:25.750 --> 00:25:28.790
different databases,
you simply cannot.

00:25:28.790 --> 00:25:32.120
I mean, SQLite allows you to
attach databases to each other,

00:25:32.120 --> 00:25:34.270
but there are some
difficulties with that.

00:25:34.270 --> 00:25:37.440
And beside that, you will find
yourself implementing SQLite

00:25:37.440 --> 00:25:41.080
in your own [INAUDIBLE] code.

00:25:41.080 --> 00:25:43.280
And one of the other
problems is you will end up

00:25:43.280 --> 00:25:45.380
duplicating some data
because they will probably

00:25:45.380 --> 00:25:47.870
have shared data, and you
will just be writing it

00:25:47.870 --> 00:25:51.260
into both of these databases.

00:25:51.260 --> 00:25:54.340
Of course, an obvious iteration
after looking at these two

00:25:54.340 --> 00:25:57.090
is, why don't we just
do a hybrid approach?

00:25:57.090 --> 00:25:58.880
To go back to this
example where we

00:25:58.880 --> 00:26:01.850
create a database
for each module,

00:26:01.850 --> 00:26:05.390
and you look at the feed
and the post databases,

00:26:05.390 --> 00:26:07.250
they probably have
the same data.

00:26:07.250 --> 00:26:10.430
You know, the feed
shows them in a list,

00:26:10.430 --> 00:26:14.570
and the post UI shows them as
an individual one with comments.

00:26:14.570 --> 00:26:15.570
So it is more data.

00:26:15.570 --> 00:26:19.240
But you can basically put all
of them into one database.

00:26:19.240 --> 00:26:21.320
Now you can share the data.

00:26:21.320 --> 00:26:23.420
And it will be a
lot more efficient

00:26:23.420 --> 00:26:27.390
while we can keep the
authentication just by itself.

00:26:27.390 --> 00:26:29.780
Now, this option is
great because it gives us

00:26:29.780 --> 00:26:31.670
full flexibility.

00:26:31.670 --> 00:26:34.710
But the problem is
it's very flexible.

00:26:34.710 --> 00:26:38.510
So you always find yourself, all
right, where do I put this one?

00:26:38.510 --> 00:26:41.360
Should we merge these two or
should we keep them separate?

00:26:41.360 --> 00:26:44.400
And you're always going
through those decision points,

00:26:44.400 --> 00:26:49.290
and it's always a challenge
as part of your application.

00:26:49.290 --> 00:26:52.700
Now, for Room, this is
an important problem

00:26:52.700 --> 00:26:54.110
that we want to solve.

00:26:54.110 --> 00:26:56.860
Similar to how we want to
solve the dynamic library

00:26:56.860 --> 00:26:59.105
navigation in the Jetpack
Navigation component,

00:26:59.105 --> 00:27:02.930
we want to provide support
for multimodule applications

00:27:02.930 --> 00:27:04.280
in Room.

00:27:04.280 --> 00:27:06.670
So this is what we want to do.

00:27:06.670 --> 00:27:09.920
We are going to allow you
to define smaller databases

00:27:09.920 --> 00:27:12.110
in these modules in
a way that you can

00:27:12.110 --> 00:27:13.530
let them depend on each other.

00:27:13.530 --> 00:27:16.310
So Room can merge
them at runtime,

00:27:16.310 --> 00:27:20.810
while, in your code base, you
can get the isolation benefits.

00:27:20.810 --> 00:27:24.150
And then this way, because we
know which database depends

00:27:24.150 --> 00:27:26.280
on which other
database, we can let

00:27:26.280 --> 00:27:29.160
you create queries in
your DAOs that query

00:27:29.160 --> 00:27:32.610
across multiple databases.

00:27:32.610 --> 00:27:34.740
And we want to support
on-demand delivery

00:27:34.740 --> 00:27:38.070
so that even if your entities
and DAOs look like they're

00:27:38.070 --> 00:27:41.130
inside the feature module,
when it gets installed,

00:27:41.130 --> 00:27:45.390
Room will basically merge them,
depending on how you set it up.

00:27:45.390 --> 00:27:47.520
Unfortunately, it's
not available yet.

00:27:47.520 --> 00:27:49.770
FLORINA MUNTENENSCU: So one
thing we haven't discussed

00:27:49.770 --> 00:27:53.070
here is whether these modules
should be Android free modules

00:27:53.070 --> 00:27:54.010
or not.

00:27:54.010 --> 00:27:57.880
And I think there are advantages
and disadvantages to this.

00:27:57.880 --> 00:28:00.382
So the first thing is that
you could reuse the modules.

00:28:00.382 --> 00:28:02.340
You could use something
like [INAUDIBLE] native

00:28:02.340 --> 00:28:05.220
and then share that library
between multiple platforms--

00:28:05.220 --> 00:28:09.145
between Android, iOS,
between mobile and back end.

00:28:09.145 --> 00:28:10.770
YIGIT BOYAR: Well,
that's a great idea.

00:28:10.770 --> 00:28:13.600
But make sure you
have that use case.

00:28:13.600 --> 00:28:16.230
So if you start like, oh,
let me remove all the Android

00:28:16.230 --> 00:28:18.900
from this code base, so maybe
three years in the future,

00:28:18.900 --> 00:28:20.810
we're going to have
cross-platform,

00:28:20.810 --> 00:28:22.440
how do you even
know that code is

00:28:22.440 --> 00:28:24.210
going to survive three years?

00:28:24.210 --> 00:28:27.340
So don't do it if you
don't have the use case.

00:28:27.340 --> 00:28:29.340
FLORINA MUNTENENSCU:
Having Android free modules

00:28:29.340 --> 00:28:31.380
means that for that
module, we just

00:28:31.380 --> 00:28:32.970
need to implement a unit test.

00:28:32.970 --> 00:28:33.600
That's all.

00:28:33.600 --> 00:28:36.420
We don't need to implement this
Android instrumentation test.

00:28:36.420 --> 00:28:39.640
That can be quite slow.

00:28:39.640 --> 00:28:42.210
YIGIT BOYAR: It's
true, I don't disagree.

00:28:42.210 --> 00:28:44.940
But writing an
Android application

00:28:44.940 --> 00:28:47.820
that doesn't use the Android
framework is a challenge.

00:28:47.820 --> 00:28:50.100
You'll find yourself
duplicating things

00:28:50.100 --> 00:28:52.570
or start mocking
things in your tests.

00:28:52.570 --> 00:28:56.940
So if you're doing it just for
the testing benefits, don't.

00:28:56.940 --> 00:29:00.840
Just use Robolectric, and you
can get the same speed benefits

00:29:00.840 --> 00:29:04.488
without trying to reinvent the
Android framework yourself.

00:29:04.488 --> 00:29:06.030
FLORINA MUNTENENSCU:
Then in general,

00:29:06.030 --> 00:29:08.160
when you read about the
architecture and the theory

00:29:08.160 --> 00:29:10.770
around architecture and clean
architecture, one of the things

00:29:10.770 --> 00:29:12.353
that you'll see, one
of the guidelines

00:29:12.353 --> 00:29:15.180
is that you should minimize
dependencies to make sure

00:29:15.180 --> 00:29:18.277
that you're not depending on
classes that you're not using.

00:29:18.277 --> 00:29:19.860
This also means that
you're able to do

00:29:19.860 --> 00:29:22.380
a clear separation of
concerns, making sure

00:29:22.380 --> 00:29:25.840
that your business logic doesn't
depend on any UI classes,

00:29:25.840 --> 00:29:26.830
for example.

00:29:26.830 --> 00:29:30.450
It allows you to build
better abstractions.

00:29:30.450 --> 00:29:33.000
YIGIT BOYAR: Abstractions
are great, I agree.

00:29:33.000 --> 00:29:35.430
But you need to be careful.

00:29:35.430 --> 00:29:38.400
Just like as you add more
and more abstractions,

00:29:38.400 --> 00:29:41.230
your code base will get
more and more complicated.

00:29:41.230 --> 00:29:43.620
So as you add these
abstractions, always

00:29:43.620 --> 00:29:49.160
think about it like, what
benefit am I gaining from this?

00:29:49.160 --> 00:29:53.930
So the TLDR off this talk is,
you go back home after I/O

00:29:53.930 --> 00:29:57.250
and start rewriting your
application in modules.

00:29:57.250 --> 00:29:59.080
[LAUGHTER]

00:29:59.925 --> 00:30:03.570
No, we're not done yet.

00:30:03.570 --> 00:30:06.660
So it's someone responsible
in the Android team

00:30:06.660 --> 00:30:09.150
to show you these options.

00:30:09.150 --> 00:30:12.810
But it's your responsibility
to learn them, investigate,

00:30:12.810 --> 00:30:14.940
see if they work
for your use case,

00:30:14.940 --> 00:30:17.790
and then decide
for your use case.

00:30:17.790 --> 00:30:18.610
These are options.

00:30:18.610 --> 00:30:19.500
These are not rules.

00:30:19.500 --> 00:30:22.410
There is no perfect solution
that someone figured out.

00:30:22.410 --> 00:30:24.480
It depends.

00:30:24.480 --> 00:30:27.210
And also, when you're
doing this kind of changes,

00:30:27.210 --> 00:30:30.930
you should always compare
your short-term costs

00:30:30.930 --> 00:30:34.920
with your long-term benefits
and make a proper decision.

00:30:34.920 --> 00:30:38.130
Speaking of cost and
benefit, the modularization

00:30:38.130 --> 00:30:41.560
or this abstraction graph
usually looks like this.

00:30:41.560 --> 00:30:44.400
So, once you start doing
some modularization, maybe

00:30:44.400 --> 00:30:47.410
the layered one, which
is like super easy to do,

00:30:47.410 --> 00:30:49.800
you're going to get a
lot of benefits out of it

00:30:49.800 --> 00:30:52.630
without spending too
much time doing it.

00:30:52.630 --> 00:30:54.870
But then, if your
project grows, maybe you

00:30:54.870 --> 00:30:57.450
can start looking at
modularizing by features,

00:30:57.450 --> 00:31:00.390
spend more time on
those kinds of things

00:31:00.390 --> 00:31:02.650
because you need
to scale the team.

00:31:02.650 --> 00:31:07.200
But then, if you're in the world
of Googles Facebooks, evils

00:31:07.200 --> 00:31:10.740
of the world, then we spend
a lot of time on these things

00:31:10.740 --> 00:31:12.780
because we have hundreds
of engineers trying

00:31:12.780 --> 00:31:14.830
to work on the same code base.

00:31:14.830 --> 00:31:16.930
So it's OK for us
to spend this time.

00:31:16.930 --> 00:31:18.750
So if you're in a
similar situation,

00:31:18.750 --> 00:31:21.030
yes, go as far as you
can go because you're

00:31:21.030 --> 00:31:22.080
going to gain something.

00:31:22.080 --> 00:31:26.070
But if you're not in that
world, don't try to do it.

00:31:26.070 --> 00:31:30.090
Because will your users
say, oh, this application

00:31:30.090 --> 00:31:32.670
is very well architected?

00:31:32.670 --> 00:31:36.810
No, no one will ever put that
five-star comment saying that.

00:31:36.810 --> 00:31:39.640
They're going to say things
like, this is very sleek,

00:31:39.640 --> 00:31:40.950
it's very robust.

00:31:40.950 --> 00:31:44.440
Or this application has
great features, I love it.

00:31:44.440 --> 00:31:47.010
So all of these things
we're talking about

00:31:47.010 --> 00:31:48.570
are a means to an end.

00:31:48.570 --> 00:31:51.820
We want to have happy customers
and want to have more of them.

00:31:51.820 --> 00:31:54.870
So when you make your
architectural modularization

00:31:54.870 --> 00:31:58.500
decisions, always keep
your customers and users

00:31:58.500 --> 00:31:59.990
in your mind.

00:31:59.990 --> 00:32:00.550
Thank you.

00:32:00.550 --> 00:32:01.842
FLORINA MUNTENENSCU: Thank you.

00:32:01.842 --> 00:32:03.850
[APPLAUSE]

00:32:03.850 --> 00:32:07.800
[MUSIC PLAYING]

