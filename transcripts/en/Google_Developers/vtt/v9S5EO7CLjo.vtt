WEBVTT
Kind: captions
Language: en

00:00:02.567 --> 00:00:04.033
Guy: Good morning,
and welcome

00:00:04.033 --> 00:00:10.033
to this Android Accelerated
Rendering session.

00:00:10.033 --> 00:00:11.667
Yes, Chet
worked really hard

00:00:11.667 --> 00:00:13.667
on that sound effect
once again.

00:00:13.667 --> 00:00:15.200
Haase:
[laughter]

00:00:15.200 --> 00:00:17.734
Guy: And I believe, yeah,
if you want to tweet

00:00:17.734 --> 00:00:20.834
because we're boring,
you have hashtags

00:00:20.834 --> 00:00:21.934
at the bottom of the--
of the slide

00:00:21.934 --> 00:00:23.200
that you can use so we can,

00:00:23.200 --> 00:00:25.300
you know, see what
you are saying about us later.

00:00:25.300 --> 00:00:26.567
If you have feedback,

00:00:26.567 --> 00:00:30.567
there's this
incredibly-hard-to-parse link,

00:00:30.567 --> 00:00:34.200
so go there, tell us what you
think about the presentation.

00:00:34.200 --> 00:00:36.767
And, for those of you
who don't know me,

00:00:36.767 --> 00:00:38.000
I'm Romain Guy.

00:00:38.000 --> 00:00:40.234
I've been working on the
Android UI Toolkit team

00:00:40.234 --> 00:00:44.234
for about four years now and,
on Android 3.0, I was in charge

00:00:44.234 --> 00:00:47.534
of designing and implementing
the OpenGL pipeline

00:00:47.534 --> 00:00:50.200
that we're going to talk about
in this presentation.

00:00:50.200 --> 00:00:53.200
And joining me today
is Chet Haase,

00:00:53.200 --> 00:00:54.434
who's been working
on animation

00:00:54.434 --> 00:00:59.267
and was helping me
on the pipeline as well.

00:00:59.267 --> 00:01:01.667
Haase: Oh, I thought
I was going to do this in mime.

00:01:01.667 --> 00:01:03.968
Okay, so contrary to
popular belief,

00:01:03.968 --> 00:01:06.634
we've actually been doing
GPU stuff for a long time.

00:01:06.634 --> 00:01:10.100
People keep asking us for
GPU support for the platform.

00:01:10.100 --> 00:01:11.934
We--we've actually got it
all over the place.

00:01:11.934 --> 00:01:14.167
It just may not be
quite obvious to you.

00:01:14.167 --> 00:01:17.567
For one thing, most of the games
are being written using the GPU,

00:01:17.567 --> 00:01:22.767
either using the NDK,
OpenGL ES1 or OpenGL--

00:01:22.767 --> 00:01:26.868
OpenGL ES2 are both
supported for the NDK,

00:01:26.868 --> 00:01:29.133
or they could be using
the STK APIs,

00:01:29.133 --> 00:01:31.934
which are basically wrappers
around those same libraries.

00:01:31.934 --> 00:01:33.801
We also use it
for window compositing,

00:01:33.801 --> 00:01:36.200
so we do software
rasterization of everything,

00:01:36.200 --> 00:01:37.334
all the graphics
that we draw,

00:01:37.334 --> 00:01:38.834
and that gets drawn
into a buffer

00:01:38.834 --> 00:01:41.100
that is then composited
by the hardware,

00:01:41.100 --> 00:01:43.534
so there's lots of GPU stuff
happening already.

00:01:43.534 --> 00:01:45.400
Oh, and including
live wallpapers

00:01:45.400 --> 00:01:47.434
which were written
with an earlier version

00:01:47.434 --> 00:01:49.968
of Render Script,
which uses the GPU.

00:01:49.968 --> 00:01:53.100
So there's all kinds of stuff
that's actually using the GPU.

00:01:53.100 --> 00:01:58.267
However, the basic UI
is not using it.

00:01:58.267 --> 00:02:01.567
So everything that we draw
on the screen in the framework

00:02:01.567 --> 00:02:05.634
when--when you say
"Canvas.drawLine" or "Canvas."

00:02:05.634 --> 00:02:06.834
you know, "drawRect,"
or, you know,

00:02:06.834 --> 00:02:08.200
any of these shape operations,

00:02:08.200 --> 00:02:11.400
all of the stuff that
the standard views are using.

00:02:11.400 --> 00:02:13.133
That goes through
our Canvas APIs.

00:02:13.133 --> 00:02:15.434
None of that stuff
is accelerated. Right?

00:02:15.434 --> 00:02:18.267
And, on top of that,
the entire UI that you're using

00:02:18.267 --> 00:02:19.601
in all the apps that--

00:02:19.601 --> 00:02:22.901
that ship with the core platform
are not accelerated,

00:02:22.901 --> 00:02:24.300
and that's kind of
what people mean,

00:02:24.300 --> 00:02:27.300
is when is that stuff
going to get faster?

00:02:27.300 --> 00:02:30.734
But, do we really need it?

00:02:30.734 --> 00:02:32.834
Because all the CPUs
are getting faster,

00:02:32.834 --> 00:02:35.868
the tablets are coming out
with multi-cores.

00:02:35.868 --> 00:02:37.634
I mean, there's lots of devices
that are coming out

00:02:37.634 --> 00:02:40.400
with faster CPUs,
more, bigger, better,

00:02:40.400 --> 00:02:43.667
lots of memory to use,
multi-core,

00:02:43.667 --> 00:02:45.934
so do we actually need
this thing accelerated,

00:02:45.934 --> 00:02:48.868
because maybe we can
just depend upon the hardware

00:02:48.868 --> 00:02:52.701
that we're getting
to speed it up for us.

00:02:52.701 --> 00:02:54.434
Guy: And one of
the key differences

00:02:54.434 --> 00:02:56.400
between tablets and phones
is that now we have--

00:02:56.400 --> 00:02:58.634
we have much more pixels
onscreen,

00:02:58.634 --> 00:03:01.601
and the difference
is pretty staggering, actually,

00:03:01.601 --> 00:03:05.133
between a--a Nexus S
that has a high-density display

00:03:05.133 --> 00:03:07.734
and the Motorola's tablet
that you see here

00:03:07.734 --> 00:03:10.834
or the Samsung tablet that--
that you got yesterday.

00:03:10.834 --> 00:03:14.100
I think we have more than
two times the amount of pixels

00:03:14.100 --> 00:03:17.934
on the tablet and, you know,
now it's 2011

00:03:17.934 --> 00:03:19.868
and you're expecting
richer experiences.

00:03:19.868 --> 00:03:21.334
You want more animations
everywhere,

00:03:21.334 --> 00:03:23.434
you want smoother animations,
and--

00:03:23.434 --> 00:03:25.434
and just in general,
you know, you want the UI

00:03:25.434 --> 00:03:29.367
to be perfectly smooth
and nice to use.

00:03:29.367 --> 00:03:31.467
So here's the problem
that we've run into.

00:03:31.467 --> 00:03:33.734
This is a little graphics--
a little graphic

00:03:33.734 --> 00:03:38.567
that shows you the expansion
of the number of pixels

00:03:38.567 --> 00:03:41.133
since the G1
that shipped in 2008

00:03:41.133 --> 00:03:45.100
up until the Motorola Zoom
that shipped a couple month ago,

00:03:45.100 --> 00:03:46.734
and that's the red line.

00:03:46.734 --> 00:03:49.000
So you can see that between
the Nexus S and the Zoom,

00:03:49.000 --> 00:03:53.033
we've seen a dramatic increase
in the number of pixels,

00:03:53.033 --> 00:03:56.634
and the yellow line shows you
the available bandwidth

00:03:56.634 --> 00:03:59.200
that we have
to move pixels around

00:03:59.200 --> 00:04:02.167
between the CPU
and the memory,

00:04:02.167 --> 00:04:05.400
and unfortunately, the bandwidth
itself has always been, like,

00:04:05.400 --> 00:04:06.901
on par with
the number of pixels,

00:04:06.901 --> 00:04:10.634
so it was good enough,
but now we have more pixels

00:04:10.634 --> 00:04:14.200
than we can afford to move
on--on the bus.

00:04:14.200 --> 00:04:16.734
So software rendering
is not enough.

00:04:16.734 --> 00:04:19.534
So with Honeycomb,
we've introduced

00:04:19.534 --> 00:04:22.067
a new rendering pipeline
for the UI,

00:04:22.067 --> 00:04:24.067
so all the standard
drawing operations

00:04:24.067 --> 00:04:25.734
that Chet mentioned
on the Canvas,

00:04:25.734 --> 00:04:28.133
for instance "drawLine,"
"drawBitmap," "drawText,"

00:04:28.133 --> 00:04:32.000
are now hardware accelerated
if you opt in,

00:04:32.000 --> 00:04:33.868
and to give you an idea
of the level of compatibility

00:04:33.868 --> 00:04:35.234
that we have,

00:04:35.234 --> 00:04:38.767
all the standard applications
running on Android 3.0

00:04:38.767 --> 00:04:40.501
are running
with this new pipeline.

00:04:40.501 --> 00:04:44.367
So the browser,
which includes the web view,

00:04:44.367 --> 00:04:46.167
Gmail, contacts, books,

00:04:46.167 --> 00:04:48.934
they all run with hardware
acceleration turned on.

00:04:48.934 --> 00:04:50.501
Haase: They--the acronym
that we have here

00:04:50.501 --> 00:04:52.501
we're trying to popularize.

00:04:52.501 --> 00:04:54.801
It's actually pronounced
"guh-poo-ee."

00:04:54.801 --> 00:04:56.667
[laughter]

00:04:56.667 --> 00:04:59.033
Haase: So it's--it's
user interface on the GPU.

00:04:59.033 --> 00:05:00.334
That's the whole idea, so--

00:05:00.334 --> 00:05:01.534
Guy: I'm sure
it will have a lot of success.

00:05:01.534 --> 00:05:03.434
Haase: --you can start
using that today.

00:05:03.434 --> 00:05:07.968
[laughter]

00:05:07.968 --> 00:05:10.367
Haase:
So it helps to understand

00:05:10.367 --> 00:05:11.968
how the rendering model
used to work,

00:05:11.968 --> 00:05:15.200
and then how it works now
under this wonderful

00:05:15.200 --> 00:05:17.033
new world
of GPU acceleration.

00:05:17.033 --> 00:05:21.100
So in the releases
prior to 3.0,

00:05:21.100 --> 00:05:23.567
a view would be redrawn.

00:05:23.567 --> 00:05:25.634
So let's say a button
is being drawn and so

00:05:25.634 --> 00:05:27.901
its onDraw method
gets called,

00:05:27.901 --> 00:05:29.767
and then it calls
rendering operations,

00:05:29.767 --> 00:05:33.133
it calls these drawing
operations on the Canvas API.

00:05:33.133 --> 00:05:36.267
It's going to draw a border,
it's going to draw a background,

00:05:36.267 --> 00:05:37.667
gradient fill,
or a bitmap,

00:05:37.667 --> 00:05:39.501
it's going to draw
some text, whatever.

00:05:39.501 --> 00:05:41.167
And then we go into
the software rasterizer.

00:05:41.167 --> 00:05:43.534
We happen to use a library
internally called Skia,

00:05:43.534 --> 00:05:47.167
and that basically turns
these operations into pixels

00:05:47.167 --> 00:05:49.968
in the frame buffer.
So it, you know, does a little

00:05:49.968 --> 00:05:51.801
Bresenham algorithm
or whatever it does,

00:05:51.801 --> 00:05:54.367
and actually lights up the
pixels in the appropriate color

00:05:54.367 --> 00:05:56.567
and then it gets copied
onto the display.

00:05:56.567 --> 00:05:58.434
So all of that's
very straightforward.

00:05:58.434 --> 00:06:02.267
In the new model,
we have this alternative way

00:06:02.267 --> 00:06:03.334
of doing it instead.

00:06:03.334 --> 00:06:04.667
So we go through
the same process

00:06:04.667 --> 00:06:07.167
from the views perspective.
Nothing changes there.

00:06:07.167 --> 00:06:09.400
The button's onDraw method
will get called,

00:06:09.400 --> 00:06:11.834
it'll issue the rendering calls
into the Canvas API,

00:06:11.834 --> 00:06:14.901
but instead of going through the
software rasterization route,

00:06:14.901 --> 00:06:16.868
we go through
an alternative path

00:06:16.868 --> 00:06:19.133
that turns those
into GPU operations,

00:06:19.133 --> 00:06:21.434
essentially
calls into OpenGL.

00:06:21.434 --> 00:06:23.567
So instead of walking
the line and--

00:06:23.567 --> 00:06:25.434
and casting out pixels,
we say,

00:06:25.434 --> 00:06:27.801
"Hey, OpenGL, why don't
you draw a line for us."

00:06:27.801 --> 00:06:30.300
And this is basically the
pattern of all the operations,

00:06:30.300 --> 00:06:32.567
all the GPU acceleration stuff
that we do,

00:06:32.567 --> 00:06:33.934
and there's different ways
of doing it

00:06:33.934 --> 00:06:36.667
that Romain
is about to talk about,

00:06:36.667 --> 00:06:39.567
but basically everything
becomes a series of operations

00:06:39.567 --> 00:06:45.567
that we send down to the GPU
via the OpenGL ES2 library.

00:06:45.567 --> 00:06:47.167
Guy:
So with OpenGL,

00:06:47.167 --> 00:06:49.567
the only primitives
we have available are points,

00:06:49.567 --> 00:06:51.501
lines, triangles,
and textures.

00:06:51.501 --> 00:06:53.400
I mean, it's a simplification
of OpenGL,

00:06:53.400 --> 00:06:54.868
but that's pretty much
what we have to work with.

00:06:54.868 --> 00:06:58.267
So we wanted to show you--
we wanted to give you a peek

00:06:58.267 --> 00:07:00.601
behind the scenes, like,
what happens when we draw

00:07:00.601 --> 00:07:04.167
some of the standard elements,
UI elements on Android.

00:07:04.167 --> 00:07:08.734
So this is a simple ListView
running on Android 3.0,

00:07:08.734 --> 00:07:12.968
and that list is turned into
a combination of those points,

00:07:12.968 --> 00:07:16.767
lines, triangles, and textures
that I just mentioned.

00:07:16.767 --> 00:07:18.534
So for instance,
that ListView,

00:07:18.534 --> 00:07:22.501
once it goes through the OpenGL
pipeline, looks like this.

00:07:22.501 --> 00:07:24.868
This is a screen shot I took
using one of our debugging tools

00:07:24.868 --> 00:07:28.534
that shows us what exactly is--
is used by the GPU.

00:07:28.534 --> 00:07:31.300
So you can see the mesh
that we're using to draw

00:07:31.300 --> 00:07:32.934
all the icons,
the pieces of text,

00:07:32.934 --> 00:07:34.033
and at the bottom of--

00:07:34.033 --> 00:07:35.534
at the top and bottom
of the list,

00:07:35.534 --> 00:07:37.267
you can see these
really wide rectangles.

00:07:37.267 --> 00:07:40.200
Those are for the fade regions
that you see at the top

00:07:40.200 --> 00:07:41.968
and bottom of the list
when you scroll them.

00:07:41.968 --> 00:07:43.601
Haase: I actually like
this version better.

00:07:43.601 --> 00:07:45.300
I think it's very geeky-cool.

00:07:45.300 --> 00:07:46.834
You can't read the text
very well, but it--

00:07:46.834 --> 00:07:49.100
it looks really neat.
[laughter]

00:07:49.100 --> 00:07:51.734
Guy: It's--
it's a new style of UI.

00:07:51.734 --> 00:07:53.667
Here's an example
of a button.

00:07:53.667 --> 00:07:56.000
So we will ignore the text
in the--the--

00:07:56.000 --> 00:07:59.067
the GPU transformation,
but a button uses something

00:07:59.067 --> 00:08:00.067
we call "nine patches."

00:08:00.067 --> 00:08:02.567
So nine patches
are pretty much textures

00:08:02.567 --> 00:08:06.334
we stretch in--in--in--
in very specific ways,

00:08:06.334 --> 00:08:07.701
and it's made
very easy by OpenGL

00:08:07.701 --> 00:08:10.100
because we can just
map that texture onto a mesh

00:08:10.100 --> 00:08:12.234
that looks like this,
and OpenGL will do

00:08:12.234 --> 00:08:15.067
the work for us of stretching
the texture correctly.

00:08:15.067 --> 00:08:19.634
The text itself is drawn
in a very similar way to path.

00:08:19.634 --> 00:08:22.100
So here we have this beautiful
blue line with a--

00:08:22.100 --> 00:08:25.634
with curves, and to render
a path like that,

00:08:25.634 --> 00:08:28.701
what we do is we generate a--
an alpha texture, so--

00:08:28.701 --> 00:08:30.400
so it's a mask.
And we apply this mask

00:08:30.400 --> 00:08:32.701
on a very simple piece
of geometry, or quads.

00:08:32.701 --> 00:08:34.167
We have only
two triangles.

00:08:34.167 --> 00:08:35.334
And then with
our fragmentators,

00:08:35.334 --> 00:08:37.133
we colorize the path.

00:08:37.133 --> 00:08:38.167
So this is what
it looks like.

00:08:38.167 --> 00:08:40.234
This is our mask.

00:08:40.234 --> 00:08:44.200
This is the--the contents
of the OpenGL texture,

00:08:44.200 --> 00:08:47.601
and we just draw it on top
of the simple piece of geometry.

00:08:47.601 --> 00:08:49.334
And text is drawn
exactly the same way.

00:08:49.334 --> 00:08:50.968
Our--our text--
this is a--

00:08:50.968 --> 00:08:53.701
a very common way
of drawing text in GL.

00:08:53.701 --> 00:08:56.467
You have this mask
that contains your font

00:08:56.467 --> 00:08:59.701
and you just apply it on
very simple pieces of geometry.

00:08:59.701 --> 00:09:03.133
For those of you geeks
who love OpenGL

00:09:03.133 --> 00:09:05.534
and have used OpenGL before,
I just wanted to show you

00:09:05.534 --> 00:09:09.868
a couple of the shaders that are
generated by the renderer,

00:09:09.868 --> 00:09:11.400
and if you don't know anything
about OpenGL,

00:09:11.400 --> 00:09:13.634
you probably don't care
about those next two slides,

00:09:13.634 --> 00:09:15.767
so we won't go
into the details.

00:09:15.767 --> 00:09:18.400
But, the--the--
one of the difficulties

00:09:18.400 --> 00:09:21.434
of implementing the--
the OpenGL renderer was

00:09:21.434 --> 00:09:24.100
we have so many different
combinations, you know,

00:09:24.100 --> 00:09:27.434
API, that we could not write
all the shaders by hand,

00:09:27.434 --> 00:09:28.701
so we have a--

00:09:28.701 --> 00:09:30.667
a program that generates
those shaders at run time.

00:09:30.667 --> 00:09:33.467
And I think we have, like,
several millions of combinations

00:09:33.467 --> 00:09:36.133
of--of shaders possible.
So this is an example.

00:09:36.133 --> 00:09:38.367
If you draw a piece of text
and you colorize

00:09:38.367 --> 00:09:40.601
the inside of the text
with a gradient,

00:09:40.601 --> 00:09:42.834
this is the vertex shader
that's generated by the--

00:09:42.834 --> 00:09:45.367
the system.
And the vertex shader,

00:09:45.367 --> 00:09:46.801
for those of you
who don't know that,

00:09:46.801 --> 00:09:50.501
is applied to every single
vertex inside a mesh.

00:09:50.501 --> 00:09:52.200
So with a triangle,
you have three vertices

00:09:52.200 --> 00:09:55.334
and each vertex
runs this code.

00:09:55.334 --> 00:09:58.868
This is the fragment shader.
Again, just an example.

00:09:58.868 --> 00:10:00.634
You can see that we have
two textures.

00:10:00.634 --> 00:10:03.267
Let me show you.
Two textures right here.

00:10:03.267 --> 00:10:05.267
So that's the texture
that contains the font,

00:10:05.267 --> 00:10:07.334
and that's the texture
that contains the gradient,

00:10:07.334 --> 00:10:09.667
and the shader simply
combines them

00:10:09.667 --> 00:10:12.467
into something
that looks awesome.

00:10:12.467 --> 00:10:15.167
Haase: So obviously
this is really complicated stuff

00:10:15.167 --> 00:10:17.067
and we did a lot of work
to make this work and--

00:10:17.067 --> 00:10:19.868
and there's all these really
gnarly meshes being sent down

00:10:19.868 --> 00:10:22.901
with texture maps and--
and complicated shaders.

00:10:22.901 --> 00:10:25.467
So then the question is,
"How do you actually access it?"

00:10:25.467 --> 00:10:27.467
What is the--
the complicated API

00:10:27.467 --> 00:10:29.067
that you need
to be aware of

00:10:29.067 --> 00:10:32.234
to enable hardware acceleration
in your applications?

00:10:32.234 --> 00:10:36.667
So first of all--
no, actually that's it.

00:10:36.667 --> 00:10:38.100
Basically, opt in.

00:10:38.100 --> 00:10:40.701
The only trick
is that you need to choose

00:10:40.701 --> 00:10:43.467
to have hardware acceleration
for your application,

00:10:43.467 --> 00:10:46.067
because, as we'll get into
a little bit later,

00:10:46.067 --> 00:10:48.167
there may be some stuff
that doesn't work quite--

00:10:48.167 --> 00:10:50.100
quite correctly for you.

00:10:50.100 --> 00:10:53.234
You may be using capabilities
of the Canvas API

00:10:53.234 --> 00:10:55.901
that we simply haven't enabled
on the GPU at this time.

00:10:55.901 --> 00:10:57.033
So you need to test
your application,

00:10:57.033 --> 00:10:58.300
make sure it works for you,

00:10:58.300 --> 00:11:00.868
and then go ahead and opt in
at the application level

00:11:00.868 --> 00:11:03.868
by issuing this
in your manifest file.

00:11:03.868 --> 00:11:06.901
There's a little bit more detail
to it than--than that,

00:11:06.901 --> 00:11:09.701
which is that you can enable it
at the application level

00:11:09.701 --> 00:11:12.601
or at the activity level,
or at the window level.

00:11:12.601 --> 00:11:15.467
You can also disable it
at either the activity

00:11:15.467 --> 00:11:16.901
or the application level.

00:11:16.901 --> 00:11:18.801
And then, finally,
if your overall application

00:11:18.801 --> 00:11:21.234
is running with hardware
acceleration enabled,

00:11:21.234 --> 00:11:25.501
you can disable it for
particular views if you need to.

00:11:25.501 --> 00:11:26.834
You can't enable it per view,

00:11:26.834 --> 00:11:28.634
but once the application
has it running,

00:11:28.634 --> 00:11:30.167
then you can disable it
per view,

00:11:30.167 --> 00:11:33.033
and this turns out to be useful
for particular situations

00:11:33.033 --> 00:11:35.067
where you really want
to use GPU acceleration

00:11:35.067 --> 00:11:38.167
but your custom view clips
against a path

00:11:38.167 --> 00:11:40.367
which is not currently
supported.

00:11:40.367 --> 00:11:42.868
Well, what you can do
is just have that single view

00:11:42.868 --> 00:11:44.133
use software rasterization.

00:11:44.133 --> 00:11:45.334
Everything else
in your application

00:11:45.334 --> 00:11:49.167
is happily using the GPU.

00:11:49.167 --> 00:11:51.334
So here's a little bit
more detail

00:11:51.334 --> 00:11:54.000
about how to actually opt
into this stuff.

00:11:54.000 --> 00:11:55.734
So at the application level,
as I said,

00:11:55.734 --> 00:11:58.234
you can opt in, say
"hardwareAccelerated = true."

00:11:58.234 --> 00:11:59.801
Maybe there's
a particular activity

00:11:59.801 --> 00:12:01.634
that can't use it
for some reason,

00:12:01.634 --> 00:12:04.000
so you can disable it
at the activity label--

00:12:04.000 --> 00:12:06.834
at--at the activity level
by setting the same flag

00:12:06.834 --> 00:12:08.133
equal to "false."

00:12:08.133 --> 00:12:11.567
You can actually see this
in the STK API demos.

00:12:11.567 --> 00:12:14.300
There are some API demos
that used Canvas APIs

00:12:14.300 --> 00:12:16.567
that were not accelerated at
the time that they were written,

00:12:16.567 --> 00:12:20.000
so the activities opt out
by setting this flag to "false,"

00:12:20.000 --> 00:12:22.200
even though
the overall application

00:12:22.200 --> 00:12:25.033
is hardware accelerated.

00:12:25.033 --> 00:12:28.901
And so you can also opt in
at run time on a window level

00:12:28.901 --> 00:12:30.601
by setting this flag,

00:12:30.601 --> 00:12:33.567
the "FLAG HARDWARE ACCELERATED"
flag.

00:12:33.567 --> 00:12:36.968
And, finally, you can disable it
at the view level

00:12:36.968 --> 00:12:38.534
by using a software layer.

00:12:38.534 --> 00:12:41.567
We're going to learn more
about layers in a few minutes.

00:12:41.567 --> 00:12:43.901
There's more to it
than simply being able

00:12:43.901 --> 00:12:46.200
to disable hardware
acceleration for a view.

00:12:46.200 --> 00:12:49.467
But, basically, if you want
to draw your view into a bitmap,

00:12:49.467 --> 00:12:50.801
you can do this,

00:12:50.801 --> 00:12:54.300
and that will use
software rasterization.

00:12:54.300 --> 00:12:56.601
Guy: And if you plan on using
hardware acceleration,

00:12:56.601 --> 00:12:58.834
you might run
into several issues

00:12:58.834 --> 00:12:59.968
where you are using an API

00:12:59.968 --> 00:13:02.334
that is not currently supported
by the pipeline,

00:13:02.334 --> 00:13:04.934
so you might want to use
one of those two methods

00:13:04.934 --> 00:13:06.767
to check whether
hardware acceleration

00:13:06.767 --> 00:13:08.234
is currently enabled.

00:13:08.234 --> 00:13:11.234
For instance, the team working
on the launcher application

00:13:11.234 --> 00:13:13.133
for Android 3.0,
they wanted the code

00:13:13.133 --> 00:13:16.734
to still be able to run
on our phones

00:13:16.734 --> 00:13:19.300
that don't have hardware
acceleration at this time,

00:13:19.300 --> 00:13:23.033
so their code contains
some of these checks to--

00:13:23.033 --> 00:13:25.734
to perform some operations
in one situation and--and--

00:13:25.734 --> 00:13:28.534
and some other operations
in the other case.

00:13:28.534 --> 00:13:30.033
So for instance,
if the hardware acceleration

00:13:30.033 --> 00:13:32.100
is on at the view level,
you might want to display,

00:13:32.100 --> 00:13:35.234
you know, fancier graphics
or enable more animations,

00:13:35.234 --> 00:13:37.434
but what's very important is to
check the hardware acceleration

00:13:37.434 --> 00:13:38.767
at the Canvas level,

00:13:38.767 --> 00:13:41.601
because even if your application
is hardware accelerated,

00:13:41.601 --> 00:13:44.234
the Canvas that's patched
to your view for drawing

00:13:44.234 --> 00:13:45.801
may be a software canvas.

00:13:45.801 --> 00:13:49.067
If the view for some reason
is rendered into a bitmap,

00:13:49.067 --> 00:13:51.434
then the view will be rendered
in software.

00:13:51.434 --> 00:13:53.133
So just remember
those two methods.

00:13:53.133 --> 00:13:56.968
You should not have to use them
in many situations.

00:13:56.968 --> 00:13:59.334
I haven't used them myself in--
in any place,

00:13:59.334 --> 00:14:02.834
I think, so far,
but it can be very useful.

00:14:02.834 --> 00:14:05.801
And, like we mentioned,
we did not--

00:14:05.801 --> 00:14:09.067
we do not cover 100%
of the existing 2-D API

00:14:09.067 --> 00:14:10.234
with the hardware pipeline,

00:14:10.234 --> 00:14:12.267
and there are various
reasons for that.

00:14:12.267 --> 00:14:13.834
We had, you know,
time constraints,

00:14:13.834 --> 00:14:16.367
there are some APIs
that are very rarely used,

00:14:16.367 --> 00:14:18.434
if at all, by applications,

00:14:18.434 --> 00:14:20.100
and there are also
some of the APIs

00:14:20.100 --> 00:14:23.100
that we have on the Canvas
are difficult to implement

00:14:23.100 --> 00:14:27.300
efficiently on the GPU so we--
we had to--to make a decision,

00:14:27.300 --> 00:14:28.934
and some of these APIs
were left out.

00:14:28.934 --> 00:14:30.234
Download that menu.

00:14:30.234 --> 00:14:32.501
Haase: Yeah, it--it's important
to point out that,

00:14:32.501 --> 00:14:33.901
before you get too worried
about all the stuff

00:14:33.901 --> 00:14:35.434
that we don't support
on the GPU,

00:14:35.434 --> 00:14:37.300
everything you see
on the tablets

00:14:37.300 --> 00:14:39.167
that you got yesterday
is hardware accelerated

00:14:39.167 --> 00:14:40.534
in the home screen,
the launcher,

00:14:40.534 --> 00:14:43.200
the all apps view,
everything in the basic UI,

00:14:43.200 --> 00:14:45.234
also everything
in the applications we ship,

00:14:45.234 --> 00:14:47.868
so that's the level of support
that we have

00:14:47.868 --> 00:14:49.167
for graphics acceleration,
you know.

00:14:49.167 --> 00:14:51.267
Everything you're seeing
in contacts and Gmail

00:14:51.267 --> 00:14:54.000
and YouTube and, you know,
all the API--all the--

00:14:54.000 --> 00:14:55.667
all the UIs
for all these applications

00:14:55.667 --> 00:14:56.968
in the home screen itself,

00:14:56.968 --> 00:14:58.801
that's all supportable
by the GPU.

00:14:58.801 --> 00:15:02.701
These are more like corner cases
that you should be aware of,

00:15:02.701 --> 00:15:05.868
but won't run into with--
with the standard views

00:15:05.868 --> 00:15:08.400
and probably won't run into
with your custom views either.

00:15:08.400 --> 00:15:09.701
Guy: Yeah, if--if you use
the standard views

00:15:09.701 --> 00:15:12.467
and the standard drawables,
you'll be fine.

00:15:12.467 --> 00:15:15.033
So this is the complete list
of APIs we do not support

00:15:15.033 --> 00:15:19.801
in Android 3.0
and I believe 3.1,

00:15:19.801 --> 00:15:22.767
so when you clip, you can
only clip with the rectangles.

00:15:22.767 --> 00:15:25.000
Clipping with "path"
and "regions"

00:15:25.000 --> 00:15:26.701
is not currently supported.

00:15:26.701 --> 00:15:28.334
Drawing pictures
is not supported,

00:15:28.334 --> 00:15:29.601
although this--

00:15:29.601 --> 00:15:32.634
this should be pretty easy
to add in the future.

00:15:32.634 --> 00:15:36.601
DrawPoints was added either
in 3.1 or ICS,

00:15:36.601 --> 00:15:39.567
I don't remember exactly,
but it's coming.

00:15:39.567 --> 00:15:43.133
The DrawPosText and TextOnPath
are currently not supported,

00:15:43.133 --> 00:15:44.968
but we probably will.

00:15:44.968 --> 00:15:47.467
There's no technical reason
why we wouldn't.

00:15:47.467 --> 00:15:50.534
DrawVertices is the same thing;
we can support it,

00:15:50.534 --> 00:15:52.467
we just didn't have time
to do it.

00:15:52.467 --> 00:15:56.767
And on the paints, you can't set
a MaskFilter or Rasterizer,

00:15:56.767 --> 00:15:59.934
and I don't even remember
what the Rasterizer does,

00:15:59.934 --> 00:16:01.133
so it's probably
not very useful.

00:16:01.133 --> 00:16:02.601
Haase: Yeah, I think
it rasterizes.

00:16:02.601 --> 00:16:06.000
Guy: I'm sure it does.
[laughter]

00:16:06.000 --> 00:16:07.200
On top of that,

00:16:07.200 --> 00:16:10.300
some of the supported APIs
have limitations.

00:16:10.300 --> 00:16:12.000
So if you clip
with a rectangle

00:16:12.000 --> 00:16:14.267
and you have a 3-D
transformation on the canvas,

00:16:14.267 --> 00:16:17.701
the 3-D transform will not
be applied to the clipRect.

00:16:17.701 --> 00:16:20.267
And there are some operations
that you can't do

00:16:20.267 --> 00:16:21.434
on the clipRect.

00:16:21.434 --> 00:16:22.934
You can't do an "x"
or a "difference"

00:16:22.934 --> 00:16:24.100
or a "reverse difference."

00:16:24.100 --> 00:16:25.434
Those are currently
not supported,

00:16:25.434 --> 00:16:28.467
and I've never seen
an application use them.

00:16:28.467 --> 00:16:31.501
DrawBitmapMesh, we ignored
the colors array at--

00:16:31.501 --> 00:16:35.167
at--at this time.
Again, we can't support it.

00:16:35.167 --> 00:16:37.434
DrawLines we don't have
anti-aliasing,

00:16:37.434 --> 00:16:40.033
although ICS will add
support for that.

00:16:40.033 --> 00:16:42.234
Haase: I--I hope so or else
I've been wasting my life

00:16:42.234 --> 00:16:44.567
for the last three weeks.

00:16:44.567 --> 00:16:45.601
Guy:
That was part of my plan.

00:16:45.601 --> 00:16:47.767
Haase: [laughter]
Ha ha ha ha.

00:16:47.767 --> 00:16:50.133
Guy: SetDrawFilter,
we completely ignore it,

00:16:50.133 --> 00:16:51.868
and on the Paint,
if you try to use--

00:16:51.868 --> 00:16:55.133
to enable dithering or to
disable filtering on bitmaps,

00:16:55.133 --> 00:16:56.467
we ignore that.

00:16:56.467 --> 00:16:59.267
We--those--those flags
are here to lower the quality

00:16:59.267 --> 00:17:01.501
of the rendering,
which makes sense in software

00:17:01.501 --> 00:17:04.801
because you want to save memory
and you want to save CPU time.

00:17:04.801 --> 00:17:07.934
On the GPU,
we have enough horsepower

00:17:07.934 --> 00:17:11.000
that we can always choose
the high-quality version.

00:17:11.000 --> 00:17:15.334
And finally, shadows work
only on text at the moment.

00:17:15.334 --> 00:17:18.801
And finally, there's this thing
called a "ComposeShader."

00:17:18.801 --> 00:17:22.801
How many of you have ever used
a shader in--on Android?

00:17:22.801 --> 00:17:24.434
Yeah, that's not many.

00:17:24.434 --> 00:17:26.868
In a way, that's good,
but the other--you know--

00:17:26.868 --> 00:17:27.868
Haase: I counted four.
Guy: Yeah.

00:17:27.868 --> 00:17:29.133
Shame on you,
the other guys.

00:17:29.133 --> 00:17:30.601
[laughter]

00:17:30.601 --> 00:17:32.667
A ComposeShader lets you
combine two different shaders,

00:17:32.667 --> 00:17:35.400
so if you want to draw
a gradient that's a shader,

00:17:35.400 --> 00:17:37.501
if you want to draw--
to texture something,

00:17:37.501 --> 00:17:38.901
you use a shader
and you can compose them

00:17:38.901 --> 00:17:40.100
in one operation.

00:17:40.100 --> 00:17:41.467
So the limitations we have

00:17:41.467 --> 00:17:45.000
is that you can't recursively
use ComposeShaders,

00:17:45.000 --> 00:17:47.067
and the two shaders
inside of ComposeShader

00:17:47.067 --> 00:17:48.667
have to be of different types.

00:17:48.667 --> 00:17:50.934
So you can't use two bitmap
shaders at the same time

00:17:50.934 --> 00:17:53.801
or two linear or gradient
shaders.

00:17:53.801 --> 00:17:57.167
And the workaround
for all these limitations,

00:17:57.167 --> 00:17:58.467
pretty easy
if you have custom code

00:17:58.467 --> 00:17:59.834
that uses any of these APIs,

00:17:59.834 --> 00:18:03.133
or that requires any of
those limited functionalities.

00:18:03.133 --> 00:18:07.801
Just use software layers
on your view.

00:18:07.801 --> 00:18:10.934
And so we told you that you
should not worry too much about,

00:18:10.934 --> 00:18:12.934
you know, the compatibility
of your app with the--

00:18:12.934 --> 00:18:15.400
the--the rendering pipeline
because obviously it works for--

00:18:15.400 --> 00:18:19.267
for--for--for very complex
applications that we ship,

00:18:19.267 --> 00:18:24.100
but you have to be aware of--
of the--the new drawing model.

00:18:24.100 --> 00:18:26.100
We--we had to make--
make some changes

00:18:26.100 --> 00:18:30.200
to the rendering model that
exposed bugs in applications.

00:18:30.200 --> 00:18:33.234
Those bugs were--
were actual bugs,

00:18:33.234 --> 00:18:35.868
but they did not show up
as bugs onscreen,

00:18:35.868 --> 00:18:37.567
so Chet will take you
through the new--

00:18:37.567 --> 00:18:39.467
the old rendering model,
and the new rendering model,

00:18:39.467 --> 00:18:41.133
and you will understand
what you should do,

00:18:41.133 --> 00:18:43.501
and what you should not do
in your app.

00:18:43.501 --> 00:18:45.434
Haase: So in the old
rendering model,

00:18:45.434 --> 00:18:48.467
if a view changed--
so let's say, somebody--

00:18:48.467 --> 00:18:50.000
you changed the text
on a button--

00:18:50.000 --> 00:18:52.567
then internally we're going to
invalidate that view and--

00:18:52.567 --> 00:18:54.467
and tell the system
that it needs to be redrawn.

00:18:54.467 --> 00:18:57.067
If it's a custom view,
you--some property changes

00:18:57.067 --> 00:18:59.534
and you call invalidate
on the view yourself.

00:18:59.534 --> 00:19:02.534
Same model.
So the view gets invalidated,

00:19:02.534 --> 00:19:05.300
and it propagates
that information up the tree.

00:19:05.300 --> 00:19:07.434
It says, "Okay, parent,
I need to be invalidated.

00:19:07.434 --> 00:19:08.934
You need to invalidate
yourself,"

00:19:08.934 --> 00:19:12.234
and it walks all the way
up the tree to the ViewRoot,

00:19:12.234 --> 00:19:14.067
and the ViewRoot says,
"Okay, things are invalid.

00:19:14.067 --> 00:19:15.167
They need to be redrawn,

00:19:15.167 --> 00:19:17.200
so I'm going to
tell the children

00:19:17.200 --> 00:19:18.701
that need to be redrawn
to redraw themselves."

00:19:18.701 --> 00:19:21.267
So we're going to tell
the parent to redraw itself

00:19:21.267 --> 00:19:23.467
and then the parent redraws
its children,

00:19:23.467 --> 00:19:25.868
and everything
is very happy.

00:19:25.868 --> 00:19:28.167
Now, the--
the thing that we did

00:19:28.167 --> 00:19:32.367
to make some of the GPU stuff
more efficient

00:19:32.367 --> 00:19:37.601
was basically to not redraw
anything that hasn't changed.

00:19:37.601 --> 00:19:40.200
So we created this thing
that we called "DisplayList,"

00:19:40.200 --> 00:19:43.300
which is basically a cache
of the rendering operations

00:19:43.300 --> 00:19:46.033
that are going to happen
for a particular view.

00:19:46.033 --> 00:19:47.400
So there's no logic
in this thing,

00:19:47.400 --> 00:19:49.701
it's just the rendering
operations themselves.

00:19:49.701 --> 00:19:51.200
For a button,
there's going to be, you know,

00:19:51.200 --> 00:19:53.434
drawing a border
or filling the background,

00:19:53.434 --> 00:19:55.467
drawing the text,
whatever it is. Right?

00:19:55.467 --> 00:19:57.601
So for instance, we can
take a look at the--the code.

00:19:57.601 --> 00:19:59.767
This actually output from a--
a logcat

00:19:59.767 --> 00:20:01.400
when we've got
a debug mode

00:20:01.400 --> 00:20:03.467
where we can actually see
what the display lists are

00:20:03.467 --> 00:20:05.234
to help chase
some issues down.

00:20:05.234 --> 00:20:09.601
So we're saving a context,
and then we're drawing the patch

00:20:09.601 --> 00:20:11.767
that the--
the button is using.

00:20:11.767 --> 00:20:13.868
We're saving the context again
because we're about to change

00:20:13.868 --> 00:20:16.234
some transform information.
We have a ClipRect.

00:20:16.234 --> 00:20:17.734
We translate
to get to the interior

00:20:17.734 --> 00:20:19.067
because we're
about to draw the--

00:20:19.067 --> 00:20:21.367
the label itself
of the button,

00:20:21.367 --> 00:20:24.000
and then we restore the contexts
that were saved.

00:20:24.000 --> 00:20:26.601
So this is basically the way
all of our DisplayLists look,

00:20:26.601 --> 00:20:31.067
is--is this list of commands
for any particular view,

00:20:31.067 --> 00:20:32.267
and then if it's a parent,

00:20:32.267 --> 00:20:34.467
it's going to be a list
of its drawing commands

00:20:34.467 --> 00:20:37.067
and then all of the stuff
that references

00:20:37.067 --> 00:20:40.634
to the DisplayList inside
the parent of--of the children.

00:20:40.634 --> 00:20:44.133
So the new rendering model
looks like this.

00:20:44.133 --> 00:20:45.901
You invalidate a view.

00:20:45.901 --> 00:20:47.534
Something in the view changes,
you invalidate it.

00:20:47.534 --> 00:20:49.033
That marks its
DisplayList "dirty."

00:20:49.033 --> 00:20:50.267
Now, one of the things
to note here

00:20:50.267 --> 00:20:52.133
is the parallel nature
of this thing,

00:20:52.133 --> 00:20:54.934
so for every view, we have
a matching DisplayList.

00:20:54.934 --> 00:20:57.534
So every view knows how
to draw itself with its--

00:20:57.534 --> 00:20:58.667
its DisplayList.

00:20:58.667 --> 00:21:00.400
So the view gets invalidated,

00:21:00.400 --> 00:21:01.901
it marks its DisplayList
"dirty,"

00:21:01.901 --> 00:21:04.734
which means, "My DisplayList
needs to be recreated."

00:21:04.734 --> 00:21:06.467
It invalidates its parent.

00:21:06.467 --> 00:21:10.200
Now, notice, the parent didn't
actually get dimmed out here

00:21:10.200 --> 00:21:11.934
because the parent does not
need to be redrawn.

00:21:11.934 --> 00:21:14.300
The parent simply needs
to redraw its children

00:21:14.300 --> 00:21:15.801
which have changed.
Right?

00:21:15.801 --> 00:21:18.067
So we're basically propagating
the information up the tree

00:21:18.067 --> 00:21:20.701
to say, "Something in the tree
has been invalidated,

00:21:20.701 --> 00:21:23.167
and it needs its DisplayList
recreated."

00:21:23.167 --> 00:21:25.634
So the ViewRoot gets
this information and says,

00:21:25.634 --> 00:21:28.167
"Okay, tree,
recreate the DisplayLists

00:21:28.167 --> 00:21:29.400
that need to be recreated."

00:21:29.400 --> 00:21:31.334
That does not recreate
the DisplayList

00:21:31.334 --> 00:21:33.067
at the top for the ViewGroup,

00:21:33.067 --> 00:21:34.534
it just recreates
the DisplayList

00:21:34.534 --> 00:21:36.934
for the child
that got invalidated

00:21:36.934 --> 00:21:39.033
and then it tells everybody
to draw

00:21:39.033 --> 00:21:41.367
and that basically issues
the DisplayLists again,

00:21:41.367 --> 00:21:42.834
which is a very quick operation

00:21:42.834 --> 00:21:45.133
compared to actually
redrawing everything.

00:21:45.133 --> 00:21:47.434
So notice the ViewGroup
didn't get redrawn here.

00:21:47.434 --> 00:21:49.934
Instead, the ViewGroup
just issued its DisplayList

00:21:49.934 --> 00:21:51.200
and the DisplayLists
of the children.

00:21:51.200 --> 00:21:53.901
The only thing that got redrawn
was the actual view

00:21:53.901 --> 00:21:56.033
that got invalidated.

00:21:56.033 --> 00:21:58.534
Guy: And to better understand
why this is so important,

00:21:58.534 --> 00:21:59.968
we're going to look
at a simple example.

00:21:59.968 --> 00:22:02.534
So here, this is the--
the settings application

00:22:02.534 --> 00:22:05.901
running on Android 3.0,
and we're going to just click

00:22:05.901 --> 00:22:10.501
on the Wi-Fi setting list item,
and when you click--

00:22:10.501 --> 00:22:13.934
when we click on this item,
it turns blue.

00:22:13.934 --> 00:22:16.334
So now I'm going to show you
a simplified version

00:22:16.334 --> 00:22:19.033
of what happened
before Android 3.0.

00:22:19.033 --> 00:22:22.734
So just to turn that item blue,
we had to redraw everything

00:22:22.734 --> 00:22:25.000
that intersected
with the list item.

00:22:25.000 --> 00:22:28.067
That meant--that means that we
had to draw the background,

00:22:28.067 --> 00:22:31.534
so the background texture
in the back of the window.

00:22:31.534 --> 00:22:32.801
We had to redraw the panel;
there--

00:22:32.801 --> 00:22:34.801
there was a gray panel
behind the list.

00:22:34.801 --> 00:22:36.734
Then we had to redraw the--
the text selector.

00:22:36.734 --> 00:22:39.734
We had to redraw the text
on top of--of the list item,

00:22:39.734 --> 00:22:41.968
and then we had to redraw
the checkbox on the right.

00:22:41.968 --> 00:22:44.267
And that is a lot
of code to run.

00:22:44.267 --> 00:22:46.267
If you look at the source code
of the Android platform

00:22:46.267 --> 00:22:49.934
and you go look at what's in
the drawing methods of ListView,

00:22:49.934 --> 00:22:52.133
of TextView, you will see
there's a lot of logic.

00:22:52.133 --> 00:22:54.367
It's not just simple, you know,
like, Canvas or drawLine.

00:22:54.367 --> 00:22:57.033
There's a lot of--
of information there.

00:22:57.033 --> 00:22:59.701
With the new model,
what you are able to do

00:22:59.701 --> 00:23:02.434
is run only the drawing method
for the selector

00:23:02.434 --> 00:23:04.501
because only the selector
turned blue

00:23:04.501 --> 00:23:07.868
and then we can just callDraw
on the DisplayLists themselves.

00:23:07.868 --> 00:23:10.934
So we run a lot less code
at the dyadic level

00:23:10.934 --> 00:23:14.501
and then we can just run these
very simplified native list

00:23:14.501 --> 00:23:17.634
of drawing commands in--
in native code.

00:23:17.634 --> 00:23:19.567
Very fast.

00:23:19.567 --> 00:23:21.934
So this is very important.

00:23:21.934 --> 00:23:26.934
With the old model, if you
call invalidate on a view,

00:23:26.934 --> 00:23:30.234
that view will redraw,
but if you call invalidate

00:23:30.234 --> 00:23:33.767
on a view that intersects
with another view,

00:23:33.767 --> 00:23:36.200
that other view
would also redraw.

00:23:36.200 --> 00:23:38.667
And I've seen applications--
we run into this issue

00:23:38.667 --> 00:23:41.501
internally
in some of our applications.

00:23:41.501 --> 00:23:43.834
Our developers turned on
the hardware acceleration

00:23:43.834 --> 00:23:46.501
and suddenly they had views
that would not redraw

00:23:46.501 --> 00:23:48.634
because they were
relying on the fact

00:23:48.634 --> 00:23:52.067
that by redrawing another view,
you know,

00:23:52.067 --> 00:23:53.501
a second view
would draw as well.

00:23:53.501 --> 00:23:56.033
With the new system,
we will only redraw views

00:23:56.033 --> 00:23:57.133
on which you call invalidate,

00:23:57.133 --> 00:23:59.133
and that was always
the contract.

00:23:59.133 --> 00:24:01.133
The framework should
only redraw views

00:24:01.133 --> 00:24:02.701
on which you call invalidate.

00:24:02.701 --> 00:24:04.367
There was just
this weird side effect

00:24:04.367 --> 00:24:08.400
that made it work in--
in that special case here.

00:24:08.400 --> 00:24:09.968
So if you turn on
the hardware acceleration

00:24:09.968 --> 00:24:11.868
on your application
and you have views

00:24:11.868 --> 00:24:13.033
that suddenly don't refresh,

00:24:13.033 --> 00:24:14.901
make sure you call
invalidate on--

00:24:14.901 --> 00:24:16.434
on any view
that requires it.

00:24:16.434 --> 00:24:18.434
And most of the time, you
don't have to worry about it.

00:24:18.434 --> 00:24:21.434
If you change a view property
like the background drawable,

00:24:21.434 --> 00:24:23.968
the text, the framework
will do it for you.

00:24:23.968 --> 00:24:28.501
So most of the time, this issue
arises in custom views.

00:24:28.501 --> 00:24:30.801
Haase: So an important case
of this is--

00:24:30.801 --> 00:24:32.434
is worth understanding more.

00:24:32.434 --> 00:24:34.000
It's not just views
that intersect,

00:24:34.000 --> 00:24:38.234
it's also the parents that--
that get in the way here.

00:24:38.234 --> 00:24:41.367
It used to be the case that
if you invalidated a parent,

00:24:41.367 --> 00:24:42.868
your child
would get redrawn.

00:24:42.868 --> 00:24:45.267
So if your custom view changed,
you could invalidate

00:24:45.267 --> 00:24:47.400
the container it was in
and everything would get redrawn

00:24:47.400 --> 00:24:49.167
and--
and life would be good.

00:24:49.167 --> 00:24:53.667
In the new GPU model,
we do not redraw that view

00:24:53.667 --> 00:24:56.000
because we haven't been told
that it changed.

00:24:56.000 --> 00:24:58.100
We will redraw the parent,
and then the parent

00:24:58.100 --> 00:25:00.100
will reissue the DisplayList
for the children.

00:25:00.100 --> 00:25:01.868
So we can visualize this
by saying,

00:25:01.868 --> 00:25:04.200
"Okay, we invalidate
the ViewGroup."

00:25:04.200 --> 00:25:07.234
That gets dimmed out because
it's going to be recreated here.

00:25:07.234 --> 00:25:08.934
That invalidates
all the way up.

00:25:08.934 --> 00:25:11.400
ViewRoot says,
"Okay, redraw yourself,"

00:25:11.400 --> 00:25:15.400
and the ViewGroup
happily does that.

00:25:15.400 --> 00:25:17.000
I--actually,
this is the old model, right?

00:25:17.000 --> 00:25:19.067
So it's actually going
to redraw the children and--

00:25:19.067 --> 00:25:20.534
you know, life--
life was good.

00:25:20.534 --> 00:25:23.033
I wanted to redraw
that view anyway, so--

00:25:23.033 --> 00:25:24.834
so the correct thing
happened.

00:25:24.834 --> 00:25:27.834
However, in the new model,
we now have these DisplayLists.

00:25:27.834 --> 00:25:29.200
We invalidate the ViewGroup,

00:25:29.200 --> 00:25:31.601
it marks its own DisplayList
"dirty,"

00:25:31.601 --> 00:25:34.100
and invalidates all the way
up to the ViewRoot,

00:25:34.100 --> 00:25:36.868
knows what to do next and it
says, "Okay, redraw yourself,"

00:25:36.868 --> 00:25:39.601
and the ViewGroup happily
rebuilds its display list

00:25:39.601 --> 00:25:41.167
and that's it.
Right?

00:25:41.167 --> 00:25:44.400
It did not actually
rebuild the DisplayLists

00:25:44.400 --> 00:25:48.234
of its children, which means if
one of those children changed,

00:25:48.234 --> 00:25:50.834
we haven't done anything
to update the display of it

00:25:50.834 --> 00:25:52.567
because we weren't told
that it changed.

00:25:52.567 --> 00:25:55.601
This is a very important element
in getting the performance

00:25:55.601 --> 00:25:56.901
that we needed
for the platform

00:25:56.901 --> 00:25:58.834
because we really
don't want to do anything

00:25:58.834 --> 00:26:00.667
that we absolutely
don't have to do.

00:26:00.667 --> 00:26:02.801
It's one of the ways that we get
the performance that--

00:26:02.801 --> 00:26:05.067
that we do on these devices.
Right?

00:26:05.067 --> 00:26:07.334
So you need
to be aware of that

00:26:07.334 --> 00:26:09.167
and construct your application
accordingly.

00:26:09.167 --> 00:26:11.334
If you're using standard views,
they do the right thing.

00:26:11.334 --> 00:26:13.100
They--they do invalidation
internally.

00:26:13.100 --> 00:26:14.634
You do not need
to worry about that,

00:26:14.634 --> 00:26:16.934
and in general, you're probably
doing the correct thing anyway,

00:26:16.934 --> 00:26:19.000
but if you notice
that a custom view

00:26:19.000 --> 00:26:21.334
is not actually
getting redrawn correctly,

00:26:21.334 --> 00:26:23.868
then you might examine this
a little bit more closely.

00:26:23.868 --> 00:26:25.200
Guy:
So we mentioned before,

00:26:25.200 --> 00:26:27.834
software layers to work
around some of the limitations

00:26:27.834 --> 00:26:30.334
of the hardware pipeline,
but we have other type--

00:26:30.334 --> 00:26:31.567
another type of layers.

00:26:31.567 --> 00:26:32.634
So we want to
talk about that

00:26:32.634 --> 00:26:34.300
because they're
extremely useful.

00:26:34.300 --> 00:26:36.801
So there's a new API on View
called "SetLayerType."

00:26:36.801 --> 00:26:39.067
You can specify the type.
We have three different types,

00:26:39.067 --> 00:26:40.534
and you can also pass in
optional Paint,

00:26:40.534 --> 00:26:42.901
and we'll see what the--
the paint is used for,

00:26:42.901 --> 00:26:45.834
but most of the time,
you'll probably pass No.

00:26:45.834 --> 00:26:47.434
So even with the new model--

00:26:47.434 --> 00:26:49.200
So here we have the example
of drawing a button.

00:26:49.200 --> 00:26:50.534
So the button
has a DisplayList

00:26:50.534 --> 00:26:52.267
and the DisplayList contains
a series of, you know,

00:26:52.267 --> 00:26:54.434
drawing operations where
we save the--

00:26:54.434 --> 00:26:57.667
the context, we draw a patch,
we draw the text, and so on.

00:26:57.667 --> 00:26:59.367
But when we--we need to draw
the DisplayList,

00:26:59.367 --> 00:27:01.501
we still need to run
a fair amount of code

00:27:01.501 --> 00:27:04.234
at the OpenGL renderer level
to convert those--

00:27:04.234 --> 00:27:08.767
those--those calls
into OpenGL code.

00:27:08.767 --> 00:27:11.634
And that can be--that can be
a little bit too much

00:27:11.634 --> 00:27:13.000
when you are trying,
for instance,

00:27:13.000 --> 00:27:17.367
to animate very complex views,
like ListView.

00:27:17.367 --> 00:27:21.434
So with layers, you can
think of layers as caches.

00:27:21.434 --> 00:27:23.534
With layers, what we're going--
what we're going to do

00:27:23.534 --> 00:27:25.067
is we're going to use
that DisplayList,

00:27:25.067 --> 00:27:27.767
we're going to render it
inside this layer.

00:27:27.767 --> 00:27:30.234
This will be, for instance,
an OpenGL text here.

00:27:30.234 --> 00:27:32.234
And then when we need to
redraw the button onscreen,

00:27:32.234 --> 00:27:33.567
if the button hasn't changed,

00:27:33.567 --> 00:27:35.601
if you haven't called
invalidate on the button,

00:27:35.601 --> 00:27:37.400
and you're only moving it,

00:27:37.400 --> 00:27:40.033
we're simply going to
draw the layer itself.

00:27:40.033 --> 00:27:45.000
So it's one operation,
it's very fast to do on the GPU.

00:27:45.000 --> 00:27:47.067
And here are the three
types of layers.

00:27:47.067 --> 00:27:49.400
We have the layer of "NONE."
This is the default value.

00:27:49.400 --> 00:27:51.968
That means the view
does not have a layer.

00:27:51.968 --> 00:27:54.200
We have the software layer
that we talked about.

00:27:54.200 --> 00:27:55.968
So when you--
when you use a software layer,

00:27:55.968 --> 00:27:58.400
the view will be rendered
into a bitmap.

00:27:58.400 --> 00:28:01.267
So it will use the--
the old software rendering model

00:28:01.267 --> 00:28:02.968
to render the view
inside the bitmap.

00:28:02.968 --> 00:28:04.701
The bitmap
will then be converted

00:28:04.701 --> 00:28:05.934
into an OpenGL texture,

00:28:05.934 --> 00:28:07.634
and then will render
that texture onscreen.

00:28:07.634 --> 00:28:09.767
Haase: That's basically
equivalent to what--

00:28:09.767 --> 00:28:11.067
Guy: Yeah, they--
they use--used it--

00:28:11.067 --> 00:28:12.634
Haase: --render cache.
Guy: Yeah, there's a--

00:28:12.634 --> 00:28:14.334
an API called
"setDrawingCacheEnabled."

00:28:14.334 --> 00:28:16.567
It does the exact
same thing.

00:28:16.567 --> 00:28:18.767
And now we--and we also have
the hardware layer.

00:28:18.767 --> 00:28:20.300
So the hardware layers
are very interesting

00:28:20.300 --> 00:28:23.634
because we can use the GPU
to render the view inside an--

00:28:23.634 --> 00:28:25.300
an OpenGL texture

00:28:25.300 --> 00:28:27.467
and then we can render
the OpenGL textures--

00:28:27.467 --> 00:28:29.968
texture with the GPU.
So it's extremely fast.

00:28:29.968 --> 00:28:34.501
It costs GPU memory, but it's
something that we can afford.

00:28:34.501 --> 00:28:38.133
The reason why you should use
these different types of layers,

00:28:38.133 --> 00:28:39.300
we have several reasons.

00:28:39.300 --> 00:28:40.701
The first one
is performance.

00:28:40.701 --> 00:28:43.167
So if you need performance,
especially during animations,

00:28:43.167 --> 00:28:44.634
you should use
hardware layers.

00:28:44.634 --> 00:28:46.868
And we'll see an example
of how to--

00:28:46.868 --> 00:28:49.200
on how to use them properly.

00:28:49.200 --> 00:28:51.234
And to give you an idea
of how useful the--

00:28:51.234 --> 00:28:52.701
the hardware layers can be,

00:28:52.701 --> 00:28:57.601
this is a small comparison of
performance to draw a ListView.

00:28:57.601 --> 00:29:00.834
So if we render a simple
ListView on Android 3.0--

00:29:00.834 --> 00:29:02.501
3.0 using software,

00:29:02.501 --> 00:29:04.300
it's going to take
about ten milliseconds,

00:29:04.300 --> 00:29:08.534
which is way too much to get
nice, smooth frame rate.

00:29:08.534 --> 00:29:11.000
If you use--if we use
DisplayList on the GPU,

00:29:11.000 --> 00:29:13.901
it takes only two milliseconds,
but that's still a fair bit--

00:29:13.901 --> 00:29:15.567
a fair amount of time
if you're moving, you know,

00:29:15.567 --> 00:29:18.133
other complex views
onscreen at the same time.

00:29:18.133 --> 00:29:20.501
And if we turn that--
that ListView inside the--

00:29:20.501 --> 00:29:23.968
into a hardware layer,
it takes only a fraction

00:29:23.968 --> 00:29:25.501
of a millisecond to do it.

00:29:25.501 --> 00:29:27.033
So it's
extremely efficient.

00:29:27.033 --> 00:29:29.767
Haase: Like, it's like
a factor of 1,000 speed-up

00:29:29.767 --> 00:29:31.100
by using a hardware layer.

00:29:31.100 --> 00:29:33.601
Guy: Tiny tiny fraction.
Haase: That's pretty cool.

00:29:33.601 --> 00:29:35.501
Guy: Software layers
and hardware layers

00:29:35.501 --> 00:29:37.133
can be used for
visual effects.

00:29:37.133 --> 00:29:39.133
I mentioned before
the optional "Paint"

00:29:39.133 --> 00:29:41.734
that you can pass
to the LayerType API,

00:29:41.734 --> 00:29:44.033
and it can be used
to control how you blend,

00:29:44.033 --> 00:29:45.934
how you composite
the layer onscreen.

00:29:45.934 --> 00:29:47.868
So you can use it
to apply color filters,

00:29:47.868 --> 00:29:48.868
for instance.

00:29:48.868 --> 00:29:50.634
You can also apply
transparency,

00:29:50.634 --> 00:29:52.601
and you can change
the blending mode.

00:29:52.601 --> 00:29:54.667
So here I have
a screenshot

00:29:54.667 --> 00:29:57.267
of a modified version
of the launcher.

00:29:57.267 --> 00:30:00.634
So I modified the launcher
to apply one of those

00:30:00.634 --> 00:30:03.834
special color filters
onto hardware layers.

00:30:03.834 --> 00:30:08.033
When you go onto the All Apps
list in the launcher,

00:30:08.033 --> 00:30:11.634
each page of your All Apps is--
is one hardware layer.

00:30:11.634 --> 00:30:14.167
So all I had to do
was add a few lines of code

00:30:14.167 --> 00:30:16.567
to turn the page
into a grayscale page.

00:30:16.567 --> 00:30:18.667
Haase: This is the launcher
that came out in 1930s

00:30:18.667 --> 00:30:20.634
before they had color.
[laughter]

00:30:20.634 --> 00:30:23.300
Guy: Yeah.
Now we can afford colors.

00:30:23.300 --> 00:30:26.234
So this is the code I added.

00:30:26.234 --> 00:30:28.167
First, we--we created
a simple color matrix.

00:30:28.167 --> 00:30:31.801
We set the saturation to "zero,"
then we create a new "Paint."

00:30:31.801 --> 00:30:34.634
We set that color matrix
as a color filter,

00:30:34.634 --> 00:30:37.234
and then, when we enabled
the hardware layer,

00:30:37.234 --> 00:30:38.634
we just pass that Paint,
which means,

00:30:38.634 --> 00:30:39.734
"When you draw that layer,

00:30:39.734 --> 00:30:42.400
please set the saturation
to zero."

00:30:42.400 --> 00:30:45.400
And that's all
you have to do.

00:30:45.400 --> 00:30:48.033
Layers are also useful
for compatibility reasons.

00:30:48.033 --> 00:30:49.767
We mention--
we mentioned it before.

00:30:49.767 --> 00:30:51.634
Just use software layers
if you rely on stuff

00:30:51.634 --> 00:30:53.868
that we do not support.

00:30:53.868 --> 00:30:56.234
And animations--

00:30:56.234 --> 00:30:58.133
if you use hardware layers
and software layers,

00:30:58.133 --> 00:31:00.400
you can get really good
performance when animating,

00:31:00.400 --> 00:31:03.501
and Chet will tell you
a little bit more about that.

00:31:03.501 --> 00:31:08.701
Haase: So one of the things
that we did in 3.0

00:31:08.701 --> 00:31:11.000
was to add a bunch of properties
to View.

00:31:11.000 --> 00:31:12.968
This was as part of the work
that I was doing

00:31:12.968 --> 00:31:14.634
on the animation framework.

00:31:14.634 --> 00:31:16.334
The way that you used
to change properties

00:31:16.334 --> 00:31:20.934
like the translucency of a view
was by using an AlphaAnimation,

00:31:20.934 --> 00:31:24.234
which was nice if you wanted to
actually fade-in or fade-out,

00:31:24.234 --> 00:31:27.100
but if you actually wanted
the view to just be translucent,

00:31:27.100 --> 00:31:28.801
there was really no way
to do that without a--

00:31:28.801 --> 00:31:30.467
a really sort of,
hacky workaround

00:31:30.467 --> 00:31:33.367
of using an animation
as a side effect.

00:31:33.367 --> 00:31:36.234
So we've actually put
properties on Views

00:31:36.234 --> 00:31:38.133
where, frankly,
they belong.

00:31:38.133 --> 00:31:39.701
So there's some very simple
properties

00:31:39.701 --> 00:31:42.100
that effect the way
that a view is--is displayed.

00:31:42.100 --> 00:31:45.701
There is the Alpha property
that affects the translucency,

00:31:45.701 --> 00:31:48.801
there is some post-layout
translation properties,

00:31:48.801 --> 00:31:50.934
so you can move the view
around within the layout

00:31:50.934 --> 00:31:52.501
after the layout
positions it.

00:31:52.501 --> 00:31:54.000
You can scale it,
you can rotate it,

00:31:54.000 --> 00:31:56.033
including rotating it
around the "y" and "z"--

00:31:56.033 --> 00:31:59.234
"y" and "x" axis
for 3D rotation,

00:31:59.234 --> 00:32:00.701
and finally you can
declare the pivot point

00:32:00.701 --> 00:32:03.434
around which scaling
and rotation happen.

00:32:03.434 --> 00:32:06.234
So all of these properties
share the common attribute

00:32:06.234 --> 00:32:08.734
that they are actually set
by the parent

00:32:08.734 --> 00:32:10.567
prior to drawing
the view.

00:32:10.567 --> 00:32:13.367
Now, the--the nuance there
that's important for animations

00:32:13.367 --> 00:32:14.868
in the layers is that,

00:32:14.868 --> 00:32:17.367
that means that the view
itself is not changing,

00:32:17.367 --> 00:32:19.634
only the display attributes
of the view

00:32:19.634 --> 00:32:21.367
that are handled
by the parent change.

00:32:21.367 --> 00:32:24.501
Which means that if you draw
your view to a layer,

00:32:24.501 --> 00:32:25.767
and then change the attribute,

00:32:25.767 --> 00:32:27.434
well, that layer
can simply be copied

00:32:27.434 --> 00:32:29.734
after the parent
sets the attribute.

00:32:29.734 --> 00:32:33.701
So we can visualize this
a little bit here.

00:32:33.701 --> 00:32:38.267
So if you set the rotation
"y" property, for instance,

00:32:38.267 --> 00:32:41.601
you're going to rotate by
45 degrees around the "y-axis."

00:32:41.601 --> 00:32:43.000
That invalidates
the parent.

00:32:43.000 --> 00:32:45.434
Note that it didn't
invalidate the view itself.

00:32:45.434 --> 00:32:47.567
The view knows that this is
one of those properties,

00:32:47.567 --> 00:32:48.834
those magical properties,

00:32:48.834 --> 00:32:50.434
that are actually handled
at the parent level.

00:32:50.434 --> 00:32:52.868
So it says, "Hey, parent,
you need to be invalidated

00:32:52.868 --> 00:32:54.834
and you need to recreate
your DisplayList and--

00:32:54.834 --> 00:32:57.000
and reissue your childrens'
DisplayLists.

00:32:57.000 --> 00:33:01.167
So the ViewGroup marks
its own DisplayList as "dirty"

00:33:01.167 --> 00:33:03.968
and it gets recreated,
and everything happens.

00:33:03.968 --> 00:33:05.167
It's all good.

00:33:05.167 --> 00:33:06.734
So we can see the code
that actually happens

00:33:06.734 --> 00:33:08.400
in the DisplayList level here.

00:33:08.400 --> 00:33:12.167
The original DisplayList was
the ViewGroup drawing itself,

00:33:12.167 --> 00:33:15.567
and then drawing the--
the DisplayList for "A"

00:33:15.567 --> 00:33:18.100
and then drawing "B's" layer.

00:33:18.100 --> 00:33:20.567
So if you "setRotationY"

00:33:20.567 --> 00:33:22.667
then it's going to
reissue the DisplayList,

00:33:22.667 --> 00:33:25.267
but before it does that,
it's going to set

00:33:25.267 --> 00:33:27.167
the rotation property
and then reissue the layer.

00:33:27.167 --> 00:33:28.567
And--and the key here

00:33:28.567 --> 00:33:30.901
is that we didn't need
to recreate the DisplayList.

00:33:30.901 --> 00:33:32.934
Right? So this could be
a really complicated view

00:33:32.934 --> 00:33:34.634
that you have drawn
to a layer,

00:33:34.634 --> 00:33:36.033
and then whenever
we need to redraw it,

00:33:36.033 --> 00:33:37.400
all we need to do
is copy the layer,

00:33:37.400 --> 00:33:40.100
which is an incredibly fast
operation on the GPU,

00:33:40.100 --> 00:33:41.434
and that's how
we got the, you know,

00:33:41.434 --> 00:33:42.901
three orders
of magnitude speed-up

00:33:42.901 --> 00:33:47.968
on that ListView example
that we saw.

00:33:47.968 --> 00:33:51.834
So we could touch
on the animation a little bit.

00:33:51.834 --> 00:33:53.701
So this is--we're not
really going to get

00:33:53.701 --> 00:33:55.033
into the animation
framework here.

00:33:55.033 --> 00:33:56.501
There's articles
and presentations

00:33:56.501 --> 00:33:57.767
about that you can
check out otherwise.

00:33:57.767 --> 00:33:59.701
But, this is
a little bit of code

00:33:59.701 --> 00:34:01.901
that animates
the "rotationY" property

00:34:01.901 --> 00:34:05.067
using the new animation
framework in 3.0.

00:34:05.067 --> 00:34:08.267
So what you want to do,
especially for complex views,

00:34:08.267 --> 00:34:11.834
is set a hardware layer
temporarily. Right?

00:34:11.834 --> 00:34:13.334
Layers
tend to be expensive

00:34:13.334 --> 00:34:14.968
because they are
large objects,

00:34:14.968 --> 00:34:17.300
so only use them
when you need them,

00:34:17.300 --> 00:34:19.634
and in general,
probably use them temporarily

00:34:19.634 --> 00:34:20.667
during an animation.

00:34:20.667 --> 00:34:21.934
Guy:
They are also expensive

00:34:21.934 --> 00:34:23.934
because if you would--
you might be tempted

00:34:23.934 --> 00:34:25.634
to enable hardware layers
all the time,

00:34:25.634 --> 00:34:27.334
but if you have a ListView

00:34:27.334 --> 00:34:28.367
and you enable
the hardware layer

00:34:28.367 --> 00:34:30.834
and the user starts
calling the list

00:34:30.834 --> 00:34:33.067
on every frame
of this callAnimation,

00:34:33.067 --> 00:34:35.367
we will redraw the list
into the hardware layer

00:34:35.367 --> 00:34:37.434
and then we will draw
the hardware layer onscreen,

00:34:37.434 --> 00:34:40.434
so we will--will be doing
twice the amount of work.

00:34:40.434 --> 00:34:41.801
Haase:
Right.

00:34:41.801 --> 00:34:45.434
So what you want to do
is to set the layer,

00:34:45.434 --> 00:34:47.667
enable the layer,
and then run the animation.

00:34:47.667 --> 00:34:49.400
But there's a little more to it
because then,

00:34:49.400 --> 00:34:50.767
you want to disable the layer
when you're done.

00:34:50.767 --> 00:34:52.934
So the way you do that
in the new animation framework

00:34:52.934 --> 00:34:55.968
is by setting
the hardware layer,

00:34:55.968 --> 00:34:57.234
declaring the animation.

00:34:57.234 --> 00:34:59.667
So if you can't read
the animation code here,

00:34:59.667 --> 00:35:01.400
it's basically saying,

00:35:01.400 --> 00:35:03.534
"I'm going to create an
animation on the view "Object,"

00:35:03.534 --> 00:35:05.801
I'm going to animate
the "rotationY" property,

00:35:05.801 --> 00:35:10.300
and I'm going to animate it
to the value of 180 degrees."

00:35:10.300 --> 00:35:12.000
We're going to add a listener
to the animation

00:35:12.000 --> 00:35:14.267
so that we know
when the animation is done,

00:35:14.267 --> 00:35:15.501
and then,
inside that listener,

00:35:15.501 --> 00:35:17.267
we're going to
disable the layer.

00:35:17.267 --> 00:35:19.067
We're going to set
the layer type to "none"

00:35:19.067 --> 00:35:20.300
when the animation finishes,

00:35:20.300 --> 00:35:23.534
and then we start the animation
when we're done.

00:35:23.534 --> 00:35:26.033
Guy: And, so now we have
a few tips and tricks

00:35:26.033 --> 00:35:28.868
that you should be aware of
if you plan on using

00:35:28.868 --> 00:35:31.267
the new hardware
accelerated pipeline.

00:35:31.267 --> 00:35:33.000
They're general tips and tricks
that you can also use

00:35:33.000 --> 00:35:34.234
when you're doing
software rendering,

00:35:34.234 --> 00:35:35.601
so the first one
is pretty obvious.

00:35:35.601 --> 00:35:37.667
Don't use too many views.

00:35:37.667 --> 00:35:40.367
The deeper your hierarchy
is going to be,

00:35:40.367 --> 00:35:43.334
the harder it will be for
the system to render your--

00:35:43.334 --> 00:35:46.000
your UI
in a very efficient way.

00:35:46.000 --> 00:35:48.100
You can have really wide
view hierarchies,

00:35:48.100 --> 00:35:49.934
as long as they are flat,
that's okay.

00:35:49.934 --> 00:35:51.267
But, if they are really deep,

00:35:51.267 --> 00:35:54.167
then it's going to be
very costly.

00:35:54.167 --> 00:35:55.334
It's--again,
it's also an issue

00:35:55.334 --> 00:35:56.868
when you're doing
software rendering.

00:35:56.868 --> 00:35:58.501
It's even more of an issue when
you're doing software rendering

00:35:58.501 --> 00:36:00.367
because we have to redraw
every single level

00:36:00.367 --> 00:36:02.934
when we need to redraw,
like, one of the views

00:36:02.934 --> 00:36:04.434
at the bottom of the tree.

00:36:04.434 --> 00:36:08.501
So I gave a talk,
I think in 2009, at Google IO.

00:36:08.501 --> 00:36:09.968
The presentation
is available on YouTube.

00:36:09.968 --> 00:36:13.100
I--I gave--I explained
how you can, you know,

00:36:13.100 --> 00:36:15.167
keep the number of views
to a minimal amount.

00:36:15.167 --> 00:36:18.267
So you should refer to that talk
and make sure

00:36:18.267 --> 00:36:22.100
that your application
does not use too many views.

00:36:22.100 --> 00:36:23.534
Be very careful
of setAlpha.

00:36:23.534 --> 00:36:24.801
So setAlpha
is this new property

00:36:24.801 --> 00:36:27.000
that we've introduced
in Android 3.0.

00:36:27.000 --> 00:36:28.901
It's really cool
'cause you can, you know,

00:36:28.901 --> 00:36:30.300
change the translucency
of your view,

00:36:30.300 --> 00:36:33.534
you can animate your view,
you can fade it in, fade it out.

00:36:33.534 --> 00:36:35.634
The problem with setAlpha is,

00:36:35.634 --> 00:36:38.033
if the view is not backed
by a layer--

00:36:38.033 --> 00:36:39.934
software layer
or hardware layer--

00:36:39.934 --> 00:36:41.767
we'll have to draw
the view twice.

00:36:41.767 --> 00:36:44.000
We're going to first render
the view inside an--

00:36:44.000 --> 00:36:46.133
an OpenGL texture,
and then we're going to render

00:36:46.133 --> 00:36:49.367
that texture with the Alpha ID
that you gave us onscreen.

00:36:49.367 --> 00:36:51.667
So that means
that we're going to have to

00:36:51.667 --> 00:36:53.767
process twice
the amount of pixels.

00:36:53.767 --> 00:36:56.234
We have really cool
optimizations

00:36:56.234 --> 00:36:58.934
to minimize the amount of
blending that we're going to do,

00:36:58.934 --> 00:37:04.133
but it will cost you twice the--
the fill-rate.

00:37:04.133 --> 00:37:06.701
Haase: Reusing objects is
a good idea in general anyway,

00:37:06.701 --> 00:37:08.234
especially if you're
inner loop,

00:37:08.234 --> 00:37:10.501
and particularly if you're
running an inner loop

00:37:10.501 --> 00:37:12.267
in an animation.

00:37:12.267 --> 00:37:14.868
The VM is really good
at collecting garbage,

00:37:14.868 --> 00:37:17.267
however, it does take
some effort. Right?

00:37:17.267 --> 00:37:18.734
So if you're creating
a little bit of garbage

00:37:18.734 --> 00:37:20.767
every time you're running it--
the animation frame

00:37:20.767 --> 00:37:22.534
because your inner loop
is creating a new object,

00:37:22.534 --> 00:37:23.767
and then you're
getting rid of it,

00:37:23.767 --> 00:37:25.067
eventually you're
going to get a GC

00:37:25.067 --> 00:37:27.801
and if that GC happens
in the middle of the animation,

00:37:27.801 --> 00:37:29.200
it may be noticeable
to the user.

00:37:29.200 --> 00:37:30.734
It'll just cause
a little hiccup there.

00:37:30.734 --> 00:37:32.601
So that's just kind of
a general tip anyway,

00:37:32.601 --> 00:37:34.033
but there's
another subtlety here

00:37:34.033 --> 00:37:36.300
with GPU acceleration
that these objects,

00:37:36.300 --> 00:37:37.667
the paints
and the bitmaps,

00:37:37.667 --> 00:37:39.467
may be expensive
for us to create

00:37:39.467 --> 00:37:41.834
because we're doing stuff
at the GPU level

00:37:41.834 --> 00:37:45.267
of recreating these textures,
re-uploading the textures,

00:37:45.267 --> 00:37:48.300
that you don't really want us
to do all the time.

00:37:48.300 --> 00:37:50.601
So keep these objects around
and reuse them

00:37:50.601 --> 00:37:55.200
as opposed to creating them
new every time.

00:37:55.200 --> 00:37:57.834
A link to that is, don't modify
the bitmaps very often.

00:37:57.834 --> 00:37:59.634
Every time you modify a bitmap,

00:37:59.634 --> 00:38:02.701
even if it's just
a little bit of the bitmap,

00:38:02.701 --> 00:38:04.267
we actually need to
upload a texture.

00:38:04.267 --> 00:38:07.601
That tends to be an expensive
operation with GPUs.

00:38:07.601 --> 00:38:09.901
So you may have not changed
much on that bitmap,

00:38:09.901 --> 00:38:12.868
but we basically need to send
the entire thing over the GPU,

00:38:12.868 --> 00:38:14.200
which is expensive.

00:38:14.200 --> 00:38:16.000
So don't do it
if you don't need to.

00:38:16.000 --> 00:38:18.167
Guy: It's actually a problem
we ran into,

00:38:18.167 --> 00:38:20.033
I believe it was
in the web browser

00:38:20.033 --> 00:38:21.934
during the development
of Android 3.0,

00:38:21.934 --> 00:38:23.033
we noticed
that the frame rate

00:38:23.033 --> 00:38:25.901
was not what
it was supposed to be and,

00:38:25.901 --> 00:38:26.901
so we're, you know,
looking at the code

00:38:26.901 --> 00:38:28.334
and said, "Web viewing,"

00:38:28.334 --> 00:38:31.334
we're wondering why is the web
page so slow to render,

00:38:31.334 --> 00:38:33.000
until we realized
that the tabs at the bottom--

00:38:33.000 --> 00:38:34.434
at the top of the screen

00:38:34.434 --> 00:38:37.868
were modifying a bitmap
on every single frame.

00:38:37.868 --> 00:38:39.534
And we were spending,
actually, most of our time

00:38:39.534 --> 00:38:43.167
just rendering the tab
at the top, not the page.

00:38:43.167 --> 00:38:45.367
So that was an easy fix.

00:38:45.367 --> 00:38:46.534
Haase: Actually,
it's really cool

00:38:46.534 --> 00:38:48.167
to have bugs like that
during a release,

00:38:48.167 --> 00:38:49.567
because then,
toward the end of the release,

00:38:49.567 --> 00:38:51.501
you can make
a very simple fix,

00:38:51.501 --> 00:38:53.701
and just
up the performance tremendously.

00:38:53.701 --> 00:38:55.934
I--there--
[laughter]

00:38:55.934 --> 00:38:57.834
there was an awesome
speed up that we had

00:38:57.834 --> 00:38:59.701
in the animation system
because early on

00:38:59.701 --> 00:39:01.334
in the development of
the animation framework,

00:39:01.334 --> 00:39:03.300
I, you know, put in
an arbitrary value

00:39:03.300 --> 00:39:04.734
that basically said,

00:39:04.734 --> 00:39:06.167
"Okay, we're going to get
30 frames a second here."

00:39:06.167 --> 00:39:07.501
And then,
a couple months later,

00:39:07.501 --> 00:39:08.801
I'd forgotten
that I'd put this thing in,

00:39:08.801 --> 00:39:10.133
and we're trying
to figure out,

00:39:10.133 --> 00:39:11.801
"How come we can't get
to 60 frames a second?

00:39:11.801 --> 00:39:14.000
Everything has been optimized.
We've tuned everything here."

00:39:14.000 --> 00:39:15.934
And then,
I saw my little value there,

00:39:15.934 --> 00:39:17.200
and I changed it
and I checked it in,

00:39:17.200 --> 00:39:19.100
and we got 2x
the animation performance.

00:39:19.100 --> 00:39:20.400
[laughter]
Pretty awesome.

00:39:20.400 --> 00:39:21.400
Guy:
And actually, I've--

00:39:21.400 --> 00:39:22.701
I have one more
little story like that.

00:39:22.701 --> 00:39:25.133
The Maps application
tried hardware acceleration

00:39:25.133 --> 00:39:28.133
and they were disappointed
by the--the results.

00:39:28.133 --> 00:39:30.234
And it's back and forth
on the bug reporting.

00:39:30.234 --> 00:39:32.901
We're wondering what's going on
because it didn't make sense.

00:39:32.901 --> 00:39:35.300
I think it was taking, like,
taking 300 milliseconds

00:39:35.300 --> 00:39:39.767
to load one frame, until
I finally used the Traceview,

00:39:39.767 --> 00:39:41.567
which is an awesome tool
in the SDK,

00:39:41.567 --> 00:39:44.734
and I realized that on every
frame when you scrolled the map,

00:39:44.734 --> 00:39:49.267
they were reloading their XML,
their menu from XML, 96 times.

00:39:49.267 --> 00:39:51.267
[laughter]

00:39:51.267 --> 00:39:52.567
So that took
a little bit of time,

00:39:52.567 --> 00:39:55.634
and it had nothing to do
with drawing.

00:39:55.634 --> 00:39:57.367
And that happens
so many times.

00:39:57.367 --> 00:40:01.033
Like, very often,
like, the kind of bug,

00:40:01.033 --> 00:40:03.801
performance bugs that we have,
like, use Traceview

00:40:03.801 --> 00:40:06.167
and look at how much time
you're spending drawing

00:40:06.167 --> 00:40:08.133
and how much time you're
spending doing other stuff.

00:40:08.133 --> 00:40:12.767
You'll be really surprised by
what's going on in applications.

00:40:12.767 --> 00:40:15.334
So you can't always
blame the drawing.

00:40:15.334 --> 00:40:16.601
Haase:
Was it Traceview I used

00:40:16.601 --> 00:40:17.667
to trace down
the memory thing too?

00:40:17.667 --> 00:40:20.467
The--
Was that--

00:40:20.467 --> 00:40:21.601
Guy: LX?
Haase: Allocation tracker.

00:40:21.601 --> 00:40:22.434
Guy: Yeah.
Haase: Also in the tools.

00:40:22.434 --> 00:40:23.601
Very useful.

00:40:23.601 --> 00:40:26.067
If the element I was mentioning
about animations

00:40:26.067 --> 00:40:27.701
creating a little bit of garbage
and eventually getting a GC,

00:40:27.701 --> 00:40:32.033
allocation tracker
in the tools in DDMS,

00:40:32.033 --> 00:40:33.567
is very useful
for figuring out

00:40:33.567 --> 00:40:36.200
what is actually being allocated
on the fly,

00:40:36.200 --> 00:40:38.367
'cause it may not be obvious
from looking at your code,

00:40:38.367 --> 00:40:41.267
but it is when you look
at the output of the tool.

00:40:41.267 --> 00:40:43.801
Guy: So similar to not
modifying bitmaps too often,

00:40:43.801 --> 00:40:45.400
if you're drawing your path

00:40:45.400 --> 00:40:46.901
and you change the path
all the time,

00:40:46.901 --> 00:40:48.567
if you remember the example

00:40:48.567 --> 00:40:49.868
of the path
that we showed you

00:40:49.868 --> 00:40:51.534
at the beginning
of the presentation,

00:40:51.534 --> 00:40:53.834
we have this texture mask,

00:40:53.834 --> 00:40:55.067
and to generate
that texture mask,

00:40:55.067 --> 00:40:56.801
we have
to upload a texture

00:40:56.801 --> 00:40:59.167
and we have to render the path
inside the texture.

00:40:59.167 --> 00:41:00.934
So if you change the path
on every frame,

00:41:00.934 --> 00:41:03.400
we'll have to regenerate
the texture on every frame,

00:41:03.400 --> 00:41:05.701
and it will be
the equivalent

00:41:05.701 --> 00:41:07.934
of modifying
the bitmap on every frame.

00:41:07.934 --> 00:41:10.334
If your path
is relatively small,

00:41:10.334 --> 00:41:12.133
it's going to be just fine,

00:41:12.133 --> 00:41:13.901
but be very careful
if you have a really large path

00:41:13.901 --> 00:41:15.467
that's pretty much,
you know,

00:41:15.467 --> 00:41:19.234
half the size of the screen
or more.

00:41:19.234 --> 00:41:20.667
Avoid overdraw.

00:41:20.667 --> 00:41:23.601
This is extremely important
with the GPU because,

00:41:23.601 --> 00:41:26.067
I mean, we all think,
that, you know,

00:41:26.067 --> 00:41:27.067
that GPUs are
this awesome things

00:41:27.067 --> 00:41:28.801
that can run the 3-D games,

00:41:28.801 --> 00:41:31.200
but games are
really well optimized

00:41:31.200 --> 00:41:34.167
to draw each pixel
once if they can.

00:41:34.167 --> 00:41:36.300
It's much harder to do that
with a UI

00:41:36.300 --> 00:41:38.734
where we have several layers,
and very often,

00:41:38.734 --> 00:41:40.300
we have anti-aliasing
and translucency,

00:41:40.300 --> 00:41:41.501
and so we have to draw
each layer.

00:41:41.501 --> 00:41:43.000
There's nothing
we can skip.

00:41:43.000 --> 00:41:48.033
So to give you an idea
on the current generation GPUs,

00:41:48.033 --> 00:41:52.000
you can render about 2.5 times
the number of pixels onscreen

00:41:52.000 --> 00:41:54.801
per frame and run
at 60 frames per second.

00:41:54.801 --> 00:41:56.968
So if you draw
a background image

00:41:56.968 --> 00:41:58.934
and you draw a second
background image on top of it

00:41:58.934 --> 00:42:01.801
and you can't see the one
that was behind, like,

00:42:01.801 --> 00:42:02.968
you have a background texture

00:42:02.968 --> 00:42:04.634
and then you put a white
rectangle on top of it,

00:42:04.634 --> 00:42:06.534
that's already
two times

00:42:06.534 --> 00:42:08.868
the number of pixels onscreen,
and you only--

00:42:08.868 --> 00:42:11.167
and most of your frame rate
is gone.

00:42:11.167 --> 00:42:13.200
And actually,
that's one of the optimizations

00:42:13.200 --> 00:42:16.067
we did in some of our apps.

00:42:16.067 --> 00:42:18.167
We have a default background
texture in Android 3.0

00:42:18.167 --> 00:42:20.467
and some of the apps
were just covering it.

00:42:20.467 --> 00:42:22.434
And they were losing
a lot of frame rate

00:42:22.434 --> 00:42:23.968
just because
they were not removing

00:42:23.968 --> 00:42:25.734
that background texture.

00:42:25.734 --> 00:42:27.601
We have some optimizations
to take care of it.

00:42:27.601 --> 00:42:29.534
They cannot
always be applied.

00:42:29.534 --> 00:42:32.834
So make sure that you draw
only what you have to draw.

00:42:32.834 --> 00:42:36.133
And finally, we just told you
a few stories.

00:42:36.133 --> 00:42:37.834
If there's one thing
you should take away

00:42:37.834 --> 00:42:40.434
from this presentation
is profile your application.

00:42:40.434 --> 00:42:43.434
We have tools in the SDK.
We have DDMS and Traceview.

00:42:43.434 --> 00:42:44.734
Use them.

00:42:44.734 --> 00:42:46.434
They will give you a lot of
really cool information

00:42:46.434 --> 00:42:47.534
about what's going on
in your app,

00:42:47.534 --> 00:42:49.801
and very often,
you may be surprised

00:42:49.801 --> 00:42:50.934
by what's going on.

00:42:50.934 --> 00:42:52.334
It's not necessarily
your fault.

00:42:52.334 --> 00:42:54.334
Sometimes it's, you know,
you're calling an API

00:42:54.334 --> 00:42:55.701
and you don't realize
that this very simple API,

00:42:55.701 --> 00:42:56.901
just one line of code

00:42:56.901 --> 00:42:59.033
is going to do
something very expensive.

00:42:59.033 --> 00:43:01.000
So if you have any doubts
about the performance

00:43:01.000 --> 00:43:03.901
of your application,
run Traceview, run DDMS,

00:43:03.901 --> 00:43:08.000
and go to the talk
this afternoon about the tools.

00:43:08.000 --> 00:43:10.467
That's about it for today.
If you want more information,

00:43:10.467 --> 00:43:14.000
there's an article
that recaps all of this on

00:43:14.000 --> 00:43:15.300
"d.android.com,"

00:43:15.300 --> 00:43:18.234
the official development
website for Android.

00:43:18.234 --> 00:43:20.234
We also post technical articles
from time to times

00:43:20.234 --> 00:43:24.100
on our personal blogs,
and we have times--

00:43:24.100 --> 00:43:25.968
time for Q&amp;A,
so if you have questions,

00:43:25.968 --> 00:43:28.267
please come to the mics.

00:43:28.267 --> 00:43:30.234
Haase: And that's the end
of the main talk, anyway.

00:43:30.234 --> 00:43:35.634
[clapping]
Thank you.

00:43:38.133 --> 00:43:39.901
Yep?
man: So quick question.

00:43:39.901 --> 00:43:42.901
So in the hardware
acceleration thing

00:43:42.901 --> 00:43:44.734
you generate shaders.

00:43:44.734 --> 00:43:47.000
Have you found any benefit
compiling those shaders

00:43:47.000 --> 00:43:49.934
for the individual GPUs?

00:43:49.934 --> 00:43:51.067
Guy:
Compiling them to--?

00:43:51.067 --> 00:43:52.767
man: Compiling them,
for example,

00:43:52.767 --> 00:43:57.634
I know PowerVR offers
a GL/SL compiler.

00:43:57.634 --> 00:43:59.033
Have you found
any benefit there,

00:43:59.033 --> 00:44:01.634
or is it just good enough
to hand it off to the driver?

00:44:01.634 --> 00:44:04.300
Guy: I mean, the driver
will do the compilation.

00:44:04.300 --> 00:44:06.868
We thought about
caching the results.

00:44:06.868 --> 00:44:10.868
The problem is,
caching the result

00:44:10.868 --> 00:44:14.167
of a shader compilation
is a proprietary extension.

00:44:14.167 --> 00:44:15.434
Haase:
Right.

00:44:15.434 --> 00:44:16.901
Guy: And, for instance,
the one that NVIDIA offers

00:44:16.901 --> 00:44:19.167
has severe limitations,
like it takes--

00:44:19.167 --> 00:44:21.634
it contains the
cron blend mode.

00:44:21.634 --> 00:44:24.067
So we decided against it
because it was too complicated

00:44:24.067 --> 00:44:25.734
and it didn't offer
any real benefit for us.

00:44:25.734 --> 00:44:29.634
man: So are you talking
about caching the result

00:44:29.634 --> 00:44:32.000
from on the on device
compilation

00:44:32.000 --> 00:44:33.000
or actually compiling it?

00:44:33.000 --> 00:44:33.968
Guy:
From the on device compilation.

00:44:33.968 --> 00:44:35.167
man:
Okay.

00:44:35.167 --> 00:44:36.767
Guy: We can't afford to do--

00:44:36.767 --> 00:44:38.367
We're going to run on so many
devices that we can't do the--

00:44:38.367 --> 00:44:40.534
compilation
ahead of time.

00:44:40.534 --> 00:44:42.133
man: I--I just didn't know
if you were--

00:44:42.133 --> 00:44:43.334
Guy: Yeah, sure.
No, no.

00:44:43.334 --> 00:44:45.133
man: Yeah.
And another question.

00:44:45.133 --> 00:44:48.067
Romain, what's your score
on Stack Overflow?

00:44:48.067 --> 00:44:52.300
Guy: My score?
Uhhhh, I don't know.

00:44:52.300 --> 00:44:53.868
I can look if you want.
Haase: He cheats anyway.

00:44:53.868 --> 00:44:55.901
He totally votes up
his own answers.

00:44:55.901 --> 00:44:57.801
man: Well, I don't know how
you get any work done.

00:44:57.801 --> 00:45:00.901
I mean, every time
I Google an Android problem,

00:45:00.901 --> 00:45:03.868
I--it's all--
It's honestly like that's,

00:45:03.868 --> 00:45:06.801
I might as well just Google
"problem + Romain," so anyways.

00:45:06.801 --> 00:45:09.501
Guy: I just don't sleep
very much.

00:45:09.501 --> 00:45:12.701
man: Okay.
Fair enough.

00:45:12.701 --> 00:45:15.133
man: Hi.
Do you know, with 3.0,

00:45:15.133 --> 00:45:17.767
is it possible to get
hardware acceleration

00:45:17.767 --> 00:45:21.067
of the HTML5 Canvas element
in the browser

00:45:21.067 --> 00:45:22.534
when you're drawing to it?

00:45:22.534 --> 00:45:23.934
Guy:
No, it's--it does--

00:45:23.934 --> 00:45:25.534
it's one of the few things
that it doesn't do,

00:45:25.534 --> 00:45:28.300
but I know that the browser team
has plans for that.

00:45:28.300 --> 00:45:29.968
man:
Okay.

00:45:29.968 --> 00:45:31.968
Haase: And our Q&amp;A
is going to be cut short

00:45:31.968 --> 00:45:33.667
because we were very late
in starting,

00:45:33.667 --> 00:45:35.868
so we will probably go
a couple more minutes here

00:45:35.868 --> 00:45:37.467
and we're going to be
in and out of office hours,

00:45:37.467 --> 00:45:40.968
which is go across the hall
and upstairs.

00:45:40.968 --> 00:45:43.601
man: So one thing
I noticed while using fragments

00:45:43.601 --> 00:45:47.501
is when you add fragments or
if you're replacing fragments,

00:45:47.501 --> 00:45:50.567
in Honeycomb,
the animation is just terrible.

00:45:50.567 --> 00:45:52.667
It stutters a lot
and, you know,

00:45:52.667 --> 00:45:54.634
it kind of tries
to hide

00:45:54.634 --> 00:45:57.100
one of the fragments
and kind of readjusts the size

00:45:57.100 --> 00:45:59.234
and starts to show
the other fragment

00:45:59.234 --> 00:46:01.901
and it's really slow.
I mean, why is that?

00:46:01.901 --> 00:46:04.167
And I'm not using
any custom animations

00:46:04.167 --> 00:46:05.200
on the fragments.

00:46:05.200 --> 00:46:06.667
Guy: That sounds weird
because, I mean,

00:46:06.667 --> 00:46:08.234
we use Fragments
in a similar application

00:46:08.234 --> 00:46:09.801
and we don't have
these issues.

00:46:09.801 --> 00:46:12.100
So that's why
you should profile.

00:46:12.100 --> 00:46:14.267
So profile the application
and try to see where

00:46:14.267 --> 00:46:16.934
the time is spent,

00:46:16.934 --> 00:46:18.601
and then you can probably
do stuff like enable

00:46:18.601 --> 00:46:21.234
hardware layers or try to reduce
the number of views

00:46:21.234 --> 00:46:23.334
you have to improve
the performance.

00:46:23.334 --> 00:46:25.634
I mean, it's great
to run on the GPU,

00:46:25.634 --> 00:46:27.434
but GPUs have
their limitations.

00:46:27.434 --> 00:46:29.834
If you give us
too much work to do,

00:46:29.834 --> 00:46:31.901
we'll happily send it
to the GPU, but, you know,

00:46:31.901 --> 00:46:33.133
it's going to choke on it.

00:46:33.133 --> 00:46:34.467
Haase: It could be
that the fragment

00:46:34.467 --> 00:46:36.701
is doing something like,
you know,

00:46:36.701 --> 00:46:38.968
the animation that's happening
is resizing the fragment

00:46:38.968 --> 00:46:40.601
and if you have
a really complex layout,

00:46:40.601 --> 00:46:43.934
well, resizing it is going to
cause a layout on every frame.

00:46:43.934 --> 00:46:45.300
man: I don't have
a very complex layout.

00:46:45.300 --> 00:46:47.667
It's a simple list
which, I mean,

00:46:47.667 --> 00:46:50.133
even the list items itself
is just, like, you know,

00:46:50.133 --> 00:46:51.467
probably just text
or probably just two lines--

00:46:51.467 --> 00:46:52.734
two text labels.

00:46:52.734 --> 00:46:54.167
Guy: Have you turned on
the hardware acceleration?

00:46:54.167 --> 00:46:55.300
man: Yes, of course.
Guy: Okay.

00:46:55.300 --> 00:46:56.667
Then profile
the application.

00:46:56.667 --> 00:46:58.567
See what's going on.

00:46:58.567 --> 00:46:59.667
man:
Okay.

00:46:59.667 --> 00:47:01.033
Guy: You know, file bugs
if it's awful.

00:47:01.033 --> 00:47:02.767
man: And the other question
I had is, I mean,

00:47:02.767 --> 00:47:05.067
why do you need to turn on
hardware acceleration?

00:47:05.067 --> 00:47:06.200
Why can't the system be--

00:47:06.200 --> 00:47:07.200
Guy: I mean,
that's pretty obvious.

00:47:07.200 --> 00:47:08.567
I mean, we showed
the limitations.

00:47:08.567 --> 00:47:10.467
Like, we can't guarantee
100% compatibility of the--

00:47:10.467 --> 00:47:14.033
with the apps,
so if you have an app on market

00:47:14.033 --> 00:47:15.934
and we turn on the hardware
acceleration for you

00:47:15.934 --> 00:47:17.567
but it makes your app crash,

00:47:17.567 --> 00:47:20.000
then your users won't be
very happy with you,

00:47:20.000 --> 00:47:21.067
and it's going to be
our fault.

00:47:21.067 --> 00:47:22.300
So we don't want
that to happen.

00:47:22.300 --> 00:47:23.667
man: Shouldn't it be transparent
to the user

00:47:23.667 --> 00:47:26.734
if a hardware acceleration
is turned on automatically?

00:47:26.734 --> 00:47:28.300
Haase: It can't be transparent
to the user

00:47:28.300 --> 00:47:30.868
if we don't support something
that the application depends on,

00:47:30.868 --> 00:47:33.067
and we don't know that
the application depends on it.

00:47:33.067 --> 00:47:35.968
Right? So we could either
opt in--we could either

00:47:35.968 --> 00:47:38.734
opt in everybody by default
and end up really messing up

00:47:38.734 --> 00:47:40.767
some applications that weren't
doing anything wrong

00:47:40.767 --> 00:47:41.934
to begin with.
man: Right.

00:47:41.934 --> 00:47:43.534
Haase: Or we could have you
choose to opt-in

00:47:43.534 --> 00:47:44.901
after you test
your applications,

00:47:44.901 --> 00:47:47.200
which is probably
a more robust model.

00:47:47.200 --> 00:47:49.701
Guy: But, our goal
is somehow, someday to,

00:47:49.701 --> 00:47:51.300
you know,
make it a default.

00:47:51.300 --> 00:47:52.634
Haase:
Yeah.

00:47:52.634 --> 00:47:53.868
man: Because, I've seen
that there are lots of--

00:47:53.868 --> 00:47:55.834
Haase: Sir, Sorry.
If you can catch us later.

00:47:55.834 --> 00:47:57.100
man: I'll catch you later.

00:47:57.100 --> 00:47:59.968
Haase: We can't debug it
anymore from there,

00:47:59.968 --> 00:48:01.267
but, we'll take
one more question

00:48:01.267 --> 00:48:03.367
and then we should
shut this down.

00:48:03.367 --> 00:48:04.801
man:
Yeah, sorry.

00:48:04.801 --> 00:48:07.901
I apologize if this was covered,
but was there any enhancements

00:48:07.901 --> 00:48:11.501
that would benefit apps
that still have to target

00:48:11.501 --> 00:48:13.567
older platforms?

00:48:13.567 --> 00:48:14.901
Like 1.6 and up,
let's say.

00:48:14.901 --> 00:48:16.167
Guy:
So yeah.

00:48:16.167 --> 00:48:17.868
If you target an older platform,
you will have to do

00:48:17.868 --> 00:48:21.634
some trickery to enable
hardware acceleration,

00:48:21.634 --> 00:48:23.968
but that's doable,
and if you're--

00:48:23.968 --> 00:48:25.868
we can't simply
optimize the framework,

00:48:25.868 --> 00:48:28.734
so if you don't use the hardware
acceleration, you know,

00:48:28.734 --> 00:48:31.033
we try to make
the software pipeline faster.

00:48:31.033 --> 00:48:32.667
I can't give you
any number, but--

00:48:32.667 --> 00:48:34.033
man: So I would
be able to

00:48:34.033 --> 00:48:37.767
add the line in the manifest
and that still would work,

00:48:37.767 --> 00:48:39.000
and then reflection?

00:48:39.000 --> 00:48:40.200
Guy: Yeah. Yes, if your target--

00:48:40.200 --> 00:48:42.534
If you change
your target SDK to 11,

00:48:42.534 --> 00:48:44.667
you can add
the attributes,

00:48:44.667 --> 00:48:46.601
or you can do it from code,
you know,

00:48:46.601 --> 00:48:47.801
you can have a special case,

00:48:47.801 --> 00:48:50.000
like, if you're running
on Honeycomb then...

00:48:50.000 --> 00:48:51.067
man:
Turn it on?

00:48:51.067 --> 00:48:52.067
Guy: You can run
that line of code.

00:48:52.067 --> 00:48:53.501
man: Okay.
Thanks.

00:48:53.501 --> 00:48:57.133
Haase: And that's it.
Thank you.

