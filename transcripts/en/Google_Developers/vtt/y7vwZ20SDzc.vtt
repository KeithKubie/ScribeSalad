WEBVTT
Kind: captions
Language: en

00:00:01.200 --> 00:00:03.434
Alex Martelli: Welcome back
to the second part,

00:00:03.434 --> 00:00:08.601
and now we're starting
to speak about functions.

00:00:08.601 --> 00:00:12.300
A function is defined
by the key word def,

00:00:12.300 --> 00:00:15.334
def, name, open paren,
parameters, close paren,

00:00:15.334 --> 00:00:17.334
colon, body.

00:00:17.334 --> 00:00:20.133
Note that the parentheses
are mandatory.

00:00:20.133 --> 00:00:21.667
Even if you have
no parameters,

00:00:21.667 --> 00:00:24.634
you just write
def, name, open, close.

00:00:24.634 --> 00:00:26.167
That's all there is to it.

00:00:26.167 --> 00:00:28.534
The body gets compiled

00:00:28.534 --> 00:00:31.501
at the time
you execute def.

00:00:31.501 --> 00:00:33.467
It gets compiled
and connected

00:00:33.467 --> 00:00:36.334
to the function object
that is created.

00:00:36.334 --> 00:00:39.167
The function object
is also assigned

00:00:39.167 --> 00:00:42.234
to the name
that you're giving.

00:00:42.234 --> 00:00:45.267
It's not executed
at this time.

00:00:45.267 --> 00:00:50.868
Later, as in not necessarily
after that in your program text,

00:00:50.868 --> 00:00:54.634
but later in time,
you can call the function.

00:00:54.634 --> 00:00:57.901
The call is--
the syntax is simply

00:00:57.901 --> 00:01:01.567
name, open paren,
arguments, close paren.

00:01:01.567 --> 00:01:04.000
Again, the parentheses
are what makes a call.

00:01:04.000 --> 00:01:08.133
This is going to be familiar
to any C or C++ programmer.

00:01:08.133 --> 00:01:10.868
If you just mention the name,
you're mentioning the object.

00:01:10.868 --> 00:01:12.400
You could put
the function object

00:01:12.400 --> 00:01:13.667
in a list or something.

00:01:13.667 --> 00:01:15.033
If you want to call it,

00:01:15.033 --> 00:01:17.901
you have to have
parentheses there.

00:01:17.901 --> 00:01:22.000
The arguments and parameters
must respond.

00:01:22.000 --> 00:01:23.968
Arguments are
what you are--

00:01:23.968 --> 00:01:27.100
are values that you are
initializing the names

00:01:27.100 --> 00:01:30.234
in the parameters with.

00:01:30.234 --> 00:01:34.067
Their correspondence is
typically one to one,

00:01:34.067 --> 00:01:35.434
but there is a few ways

00:01:35.434 --> 00:01:38.033
that you can use
more flexibility there.

00:01:38.033 --> 00:01:40.868
The parameters at the end

00:01:40.868 --> 00:01:44.100
can have default values
like in C++.

00:01:44.100 --> 00:01:50.801
So, you can use the syntax
parameter name equal expression

00:01:50.801 --> 00:01:53.501
meaning,
unless otherwise specified,

00:01:53.501 --> 00:01:57.334
this object is the value
for this parameter.

00:01:57.334 --> 00:02:00.534
Be careful, this expression
is evaluated once

00:02:00.534 --> 00:02:04.367
at the time
you run the def statement

00:02:04.367 --> 00:02:09.501
and that object is going
to be used for every call

00:02:09.501 --> 00:02:13.234
that doesn't specify
that name.

00:02:13.234 --> 00:02:16.033
You may or may not
override this

00:02:16.033 --> 00:02:18.501
by explicitly specifying
a corresponding argument

00:02:18.501 --> 00:02:20.200
in the call.

00:02:20.200 --> 00:02:22.567
Similarly,
the last few arguments

00:02:22.567 --> 00:02:25.033
you give can be named.

00:02:25.033 --> 00:02:29.534
Instead of just taking
the positional correspondent

00:02:29.534 --> 00:02:31.968
first argument goes
to first parameter,

00:02:31.968 --> 00:02:34.667
second argument goes
to second parameter,

00:02:34.667 --> 00:02:37.300
you can say explicitly

00:02:37.300 --> 00:02:41.334
what parameter name
you're setting

00:02:41.334 --> 00:02:44.100
to the value
you're passing.

00:02:44.100 --> 00:02:47.634
Finally,
you may define a function

00:02:47.634 --> 00:02:49.267
that takes
arbitrary positional

00:02:49.267 --> 00:02:52.667
and/or arbitrary
named arguments.

00:02:52.667 --> 00:02:55.367
The syntax is star-named.

00:02:55.367 --> 00:03:00.167
It will give you a tuple name
of extra positional arguments,

00:03:00.167 --> 00:03:03.234
and star, star, name
will give you a dictionary

00:03:03.234 --> 00:03:06.234
of optional named args.

00:03:06.234 --> 00:03:08.567
So, there's a lot
of flexibility there,

00:03:08.567 --> 00:03:10.767
which is typically used,
for example,

00:03:10.767 --> 00:03:12.634
to wrap a function
in another function

00:03:12.634 --> 00:03:13.834
and pass arguments through

00:03:13.834 --> 00:03:17.100
without needing to know
which ones they are.

00:03:17.100 --> 00:03:21.968
Here's a simple example.
A totally elementary function,

00:03:21.968 --> 00:03:26.133
takes two arguments,
does the sum of squares.

00:03:26.133 --> 00:03:28.601
So, that's all
there is to it,

00:03:28.601 --> 00:03:29.968
but it's not very general.

00:03:29.968 --> 00:03:32.100
It will work
if we're in the middle

00:03:32.100 --> 00:03:34.968
of computing a hypotenuse,

00:03:34.968 --> 00:03:38.334
but what if we have
more than two numbers

00:03:38.334 --> 00:03:40.400
and we want the sum
of their squares?

00:03:40.400 --> 00:03:44.734
This is the Pythonic way
of expressing that.

00:03:44.734 --> 00:03:48.434
The sum of squares,
arbitrary arguments,

00:03:48.434 --> 00:03:50.501
is the sum of the square

00:03:50.501 --> 00:03:53.100
for every item
in the arguments.

00:03:53.100 --> 00:03:54.501
So, the sum of all squares

00:03:54.501 --> 00:03:56.367
is the sum of the square
of each item.

00:03:56.367 --> 00:03:58.801
That's just about
as high-level

00:03:58.801 --> 00:04:00.834
as you can get
and stay general.

00:04:00.834 --> 00:04:04.467
If you're used
to lower level languages,

00:04:04.467 --> 00:04:06.334
you may think
in these terms.

00:04:06.334 --> 00:04:08.734
Well, start
with a total of zero,

00:04:08.734 --> 00:04:11.467
then go
over all arguments

00:04:11.467 --> 00:04:14.033
incrementing the total
by the square,

00:04:14.033 --> 00:04:15.534
and finally
return the total.

00:04:15.534 --> 00:04:17.634
That will work, too.

00:04:17.634 --> 00:04:20.400
As I said,
we do bend over backwards

00:04:20.400 --> 00:04:24.100
to try and support people
who are so attuned

00:04:24.100 --> 00:04:25.701
to lower level
programming languages

00:04:25.701 --> 00:04:28.634
that they can't just express
their problem anymore.

00:04:28.634 --> 00:04:31.601
But the problem you're trying
to solve is this one,

00:04:31.601 --> 00:04:36.334
and this is much faster and
much more natural in Python.

00:04:36.334 --> 00:04:39.067
So, if you find yourself
basically writing

00:04:39.067 --> 00:04:43.133
for turning Python,
try and write Python instead.

00:04:43.133 --> 00:04:47.601
It's going to be much faster
and make you much happier.

00:04:47.601 --> 00:04:49.667
Generators are functions

00:04:49.667 --> 00:04:52.200
which instead
of returning a value

00:04:52.200 --> 00:04:54.868
yield values.

00:04:54.868 --> 00:04:58.467
The key word is yield,
y-i-e-l-d,

00:04:58.467 --> 00:05:00.167
instead of return.

00:05:00.167 --> 00:05:01.701
What's the difference?

00:05:01.701 --> 00:05:05.033
A return gives a result

00:05:05.033 --> 00:05:08.501
and terminates the execution
of the function.

00:05:08.501 --> 00:05:11.033
A yield gives a result

00:05:11.033 --> 00:05:14.701
and suspends the execution
of the function

00:05:14.701 --> 00:05:18.200
at that very spot
until further notice.

00:05:18.200 --> 00:05:20.300
Specifically,
the mechanism we've used

00:05:20.300 --> 00:05:22.934
to let you resume
and get the next result,

00:05:22.934 --> 00:05:27.834
the next thing to be yielded,
is iterators,

00:05:27.834 --> 00:05:32.000
which are basically objects
with a next method.

00:05:32.000 --> 00:05:35.868
So, when you call the generator,
you get the iterator.

00:05:35.868 --> 00:05:38.868
Every time you call next
on the iterator,

00:05:38.868 --> 00:05:41.934
you get the next thing
to be yielded.

00:05:41.934 --> 00:05:44.434
And when everything is done,

00:05:44.434 --> 00:05:47.400
when there is
no more next value,

00:05:47.400 --> 00:05:52.667
the iterator will raise
a StopIteration exception.

00:05:52.667 --> 00:05:54.901
If you use a for loop,
remember to finish out

00:05:54.901 --> 00:05:57.467
the for loop that
we gave in the first half,

00:05:57.467 --> 00:06:01.901
this is basically done
for you for free.

00:06:01.901 --> 00:06:06.100
So, I mentioned enumerate before
is actually a built-in,

00:06:06.100 --> 00:06:08.200
but if it wasn't a built-in,

00:06:08.200 --> 00:06:11.100
these are two ways
we could actually program it.

00:06:11.100 --> 00:06:14.200
One is the lower-level way,

00:06:14.200 --> 00:06:16.968
the other one is
the higher obstruction

00:06:16.968 --> 00:06:19.968
and faster way.

00:06:19.968 --> 00:06:23.567
So, the job of enumerate
is yielding each item

00:06:23.567 --> 00:06:25.534
of the sequence
with its index.

00:06:25.534 --> 00:06:28.934
So, zero, first item,
that's the first yield.

00:06:28.934 --> 00:06:32.067
One, second item,
second yield and so on.

00:06:32.067 --> 00:06:34.467
So, you could think,
well, I'll start at zero,

00:06:34.467 --> 00:06:36.067
loop over the sequence,

00:06:36.067 --> 00:06:39.234
and yield the current index,
n, and the item,

00:06:39.234 --> 00:06:42.000
and then increment
for the next item.

00:06:42.000 --> 00:06:45.667
So, when the yield executes,
the function freezes.

00:06:45.667 --> 00:06:47.434
The execution
of that particular run

00:06:47.434 --> 00:06:49.901
of the function freezes.

00:06:49.901 --> 00:06:55.701
And when the next method is
called on the iterator,

00:06:55.701 --> 00:06:59.267
it can by incrementing
and going back.

00:06:59.267 --> 00:07:05.100
This is the higher abstraction
way of doing it.

00:07:05.100 --> 00:07:08.400
It uses the standard
library module itertools,

00:07:08.400 --> 00:07:11.234
these tools for iteration,

00:07:11.234 --> 00:07:17.434
by doing a element by element
parallel zipping and count,

00:07:17.434 --> 00:07:22.601
which is an iterator which
yields the unending sequence

00:07:22.601 --> 00:07:27.968
zero, one, two, three,
and so on forever.

00:07:27.968 --> 00:07:30.567
What we're doing is
zipping the sequence,

00:07:30.567 --> 00:07:32.701
zero, one, two, three,

00:07:32.701 --> 00:07:35.367
with the sequence we were
giving as an argument.

00:07:35.367 --> 00:07:41.033
So, this single statement
does the job of these four.

00:07:41.033 --> 00:07:45.000
Again, think in these terms
when you're programming Python.

00:07:45.000 --> 00:07:47.834
You'll be so much happier.

00:07:47.834 --> 00:07:50.400
Let's give a slightly
less elementary example.

00:07:50.400 --> 00:07:53.300
One of my favorite
mathematicians of all times,

00:07:53.300 --> 00:07:56.267
Leonardo Pisano
known as Fibonacci,

00:07:56.267 --> 00:07:59.000
wrote an exercise
in his "Liber Abaci"

00:07:59.000 --> 00:08:02.067
about computing the number
of rabbits produced

00:08:02.067 --> 00:08:06.100
by a hypothetical
rabbit warren.

00:08:06.100 --> 00:08:08.367
You're maybe familiar
with a Fibonacci sequence,

00:08:08.367 --> 00:08:10.734
basically the sequence here.

00:08:10.734 --> 00:08:12.267
So, we start with one, one,

00:08:12.267 --> 00:08:16.234
and then every item is the sum
of the previous two.

00:08:16.234 --> 00:08:19.400
So, this is a low-level,

00:08:19.400 --> 00:08:21.868
but perfectly acceptable way
of programming.

00:08:21.868 --> 00:08:24.634
We'll start with i and j
both equal to one.

00:08:24.634 --> 00:08:26.968
Note something
I hadn't mentioned before,

00:08:26.968 --> 00:08:29.334
you can change assignment
like in C.

00:08:29.334 --> 00:08:34.234
I equal j equal one
gives both names, i and j,

00:08:34.234 --> 00:08:36.234
to the object one.

00:08:36.234 --> 00:08:39.200
And then while true,
which of course means

00:08:39.200 --> 00:08:44.267
this loop will never terminate,
not per se,

00:08:44.267 --> 00:08:49.200
we do another form
of multiple assignment.

00:08:49.200 --> 00:08:56.267
We assign i, j, and i plus j
to r, i, and j respectively.

00:08:56.267 --> 00:08:58.467
If this isn't
perfectly obvious,

00:08:58.467 --> 00:09:01.501
the right hand side
with the multiple values

00:09:01.501 --> 00:09:03.100
is evaluated left to right.

00:09:03.100 --> 00:09:05.734
So, i and then j
and then the sum,

00:09:05.734 --> 00:09:09.300
and after all the evaluations,
then all the name bindings.

00:09:09.300 --> 00:09:10.734
So, r is i,

00:09:10.734 --> 00:09:12.100
i is j,

00:09:12.100 --> 00:09:13.734
j is i plus j.

00:09:13.734 --> 00:09:15.334
You could write it
as three assignments,

00:09:15.334 --> 00:09:17.567
but there's no point.

00:09:17.567 --> 00:09:21.767
And finally, we yield
this current result.

00:09:21.767 --> 00:09:26.100
If you just did a for on this,
this will run forever.

00:09:26.100 --> 00:09:27.767
So, it is crucial
that the for

00:09:27.767 --> 00:09:30.601
has a break inside it
at some point

00:09:30.601 --> 00:09:33.901
when you have enough stuff.

00:09:33.901 --> 00:09:37.901
So, this is,
as I mentioned,

00:09:37.901 --> 00:09:40.300
the purpose of the exercise
was computing

00:09:40.300 --> 00:09:43.634
the number of rabbits born
in a farm, in a certain year.

00:09:43.634 --> 00:09:45.534
So, for rabbits
and Fibonacci,

00:09:45.534 --> 00:09:50.400
note we have to call it
to get the iterator,

00:09:50.400 --> 00:09:54.000
we just print it with a comma
to avoid breaking the line,

00:09:54.000 --> 00:09:55.801
and then we decide
when to break.

00:09:55.801 --> 00:09:58.133
We break when we have
more than 100 rabbits

00:09:58.133 --> 00:10:01.667
because that's
a large enough farm

00:10:01.667 --> 00:10:05.067
and this is
the result sequence.

00:10:05.067 --> 00:10:06.667
Another trick,

00:10:06.667 --> 00:10:11.767
which will be very familiar
to JavaScript programmers,

00:10:11.767 --> 00:10:15.067
but is not common
in the other language,

00:10:15.067 --> 00:10:16.868
def is
an executable statement.

00:10:16.868 --> 00:10:18.801
I did mention there's
no such thing as a declaration,

00:10:18.801 --> 00:10:20.501
everything is a statement.

00:10:20.501 --> 00:10:22.067
Def is an executable statement.

00:10:22.067 --> 00:10:25.033
Every time def execute,

00:10:25.033 --> 00:10:29.901
it builds a new function object
and binds it to that name.

00:10:29.901 --> 00:10:32.701
Also, scoping is lexical.

00:10:32.701 --> 00:10:35.534
That is, if I'm looking
for a variable name

00:10:35.534 --> 00:10:37.934
and it's not bound
in my current context,

00:10:37.934 --> 00:10:39.567
I go to the context
containing it,

00:10:39.567 --> 00:10:42.901
where contexts are functions
in Python.

00:10:42.901 --> 00:10:49.701
So, consider this:
Def makeAdder given an addend.

00:10:49.701 --> 00:10:55.000
When def makeAdder compiles,
it just compiles this--

00:10:55.000 --> 00:10:58.701
when def, the outer def,
executed just compiles this.

00:10:58.701 --> 00:11:02.901
When makeAdder gets called,
this def executes,

00:11:02.901 --> 00:11:06.634
meaning this code gets compiled
and bound to name adder

00:11:06.634 --> 00:11:09.033
and that name adder,
of an inner function,

00:11:09.033 --> 00:11:11.000
is returned
from the outer function.

00:11:11.000 --> 00:11:14.567
This is known as a closure.

00:11:14.567 --> 00:11:18.133
The inner function adder doesn't
have anything named addend,

00:11:18.133 --> 00:11:19.434
and so it looks outside

00:11:19.434 --> 00:11:22.501
and finds it
in the outer function.

00:11:22.501 --> 00:11:26.367
So, for example,
a23 equal makeAdder(23).

00:11:26.367 --> 00:11:28.267
Now, a23 is a function

00:11:28.267 --> 00:11:30.968
that will sum 23
to whatever it's given.

00:11:30.968 --> 00:11:34.234
And similarly makeAdder(42),
so now a42 is function

00:11:34.234 --> 00:11:36.901
that will sum 42
to whatever is given.

00:11:36.901 --> 00:11:41.501
So, we can print a23(100),
a42(100) or compose them,

00:11:41.501 --> 00:11:44.501
they're totally independent now,
because every def,

00:11:44.501 --> 00:11:48.133
every time the inner def runs,
it builds a new function object,

00:11:48.133 --> 00:11:49.767
but you don't interfere,

00:11:49.767 --> 00:11:53.434
so we have
the expected results.

00:11:53.434 --> 00:11:57.133
A syntax form known
as decorators makes

00:11:57.133 --> 00:12:01.834
higher order functions
even smoother to use in Python.

00:12:01.834 --> 00:12:06.567
Basically, whenever you write
at decorator def something

00:12:06.567 --> 00:12:10.934
or in Python 2-6,
which is about to go beta now,

00:12:10.934 --> 00:12:13.601
similarly for
at decorator class something,

00:12:13.601 --> 00:12:17.100
but we won't be covering
anything beyond 2-5.

00:12:17.100 --> 00:12:18.667
Whenever you write this,

00:12:18.667 --> 00:12:22.567
it's as if you've done your defs
or created your function object,

00:12:22.567 --> 00:12:28.033
and then rebound the same name,
which you used in the def,

00:12:28.033 --> 00:12:30.434
to whatever happens
passing the function object

00:12:30.434 --> 00:12:33.234
as the argument
to the decorator.

00:12:33.234 --> 00:12:36.868
So, basically, decorator has
to be a higher order function

00:12:36.868 --> 00:12:39.334
or it could be
a call to a function

00:12:39.334 --> 00:12:41.234
returning a higher
order function,

00:12:41.234 --> 00:12:44.901
a higher order
squared function.

00:12:44.901 --> 00:12:48.300
This is a very handy syntax
for all sorts of things.

00:12:48.300 --> 00:12:52.434
Particularly it's used
in side classes as we'll see.

00:12:52.434 --> 00:12:55.334
Okay, there's new-style classes
and old-style classes.

00:12:55.334 --> 00:12:59.767
I will not be mentioning
old-style classes at all.

00:12:59.767 --> 00:13:00.868
They're totally obsolete,

00:13:00.868 --> 00:13:02.601
only exist
for backwards compatibility.

00:13:02.601 --> 00:13:05.300
We'll talk
about new-style ones.

00:13:05.300 --> 00:13:06.767
A class is similar to a def.

00:13:06.767 --> 00:13:09.801
In a sense,
it's also a key word.

00:13:09.801 --> 00:13:12.767
Class, the name,
and then bases in parenthesis.

00:13:12.767 --> 00:13:14.367
If you have no bases--

00:13:14.367 --> 00:13:18.267
Well, you should always have
at least object as a base.

00:13:18.267 --> 00:13:19.767
So, at the very least,

00:13:19.767 --> 00:13:24.634
you'll have open paren, object,
close paren, and then a body.

00:13:24.634 --> 00:13:27.834
So, it's different
from a def in this sense:

00:13:27.834 --> 00:13:31.767
As I mentioned, when you call--
when you execute def,

00:13:31.767 --> 00:13:35.000
the body only gets compiled,
not executed yet.

00:13:35.000 --> 00:13:38.634
When you execute class,
the body gets executed.

00:13:38.634 --> 00:13:41.801
The body's typically a series
of assignment and def

00:13:41.801 --> 00:13:43.868
and possibly other statements

00:13:43.868 --> 00:13:46.534
and it's executed at the time
you execute class.

00:13:46.534 --> 00:13:50.567
It basically binds names
to values

00:13:50.567 --> 00:13:54.601
and those names become
attributes of the class.

00:13:54.601 --> 00:13:59.400
So, functions, for example,
become methods for the class.

00:13:59.400 --> 00:14:02.901
Also, anything that is
an attribute of a base

00:14:02.901 --> 00:14:07.567
is also found when you look up
things on the class itself,

00:14:07.567 --> 00:14:12.133
except that you can override
just like in C++ or Java.

00:14:12.133 --> 00:14:14.501
If something is defined
in a base class

00:14:14.501 --> 00:14:17.901
and you define it differently
in the drive class,

00:14:17.901 --> 00:14:21.000
the drive class wins.

00:14:21.000 --> 00:14:23.033
So, in C++,
this is likely different

00:14:23.033 --> 00:14:24.601
because you explicitly
have to say

00:14:24.601 --> 00:14:27.801
that something is virtual
in Python.

00:14:27.801 --> 00:14:30.067
Like in Java,
there's no such need.

00:14:30.067 --> 00:14:33.033
Everything can
be overridden.

00:14:33.033 --> 00:14:36.167
Let's give a very boring example
just to show.

00:14:36.167 --> 00:14:40.033
So, class eg,
that's just an example,

00:14:40.033 --> 00:14:42.868
iterates from object,
that means it has no real basis,

00:14:42.868 --> 00:14:46.100
just the multi-generic object
of them all.

00:14:46.100 --> 00:14:49.868
It starts with assigning
an empty list to cla,

00:14:49.868 --> 00:14:51.534
so that's a class attribute.

00:14:51.534 --> 00:14:54.267
The class itself
holds the list,

00:14:54.267 --> 00:14:56.901
and then it has a def

00:14:56.901 --> 00:14:59.701
with the special name
dunder init dunder.

00:14:59.701 --> 00:15:01.501
That's the initializer

00:15:01.501 --> 00:15:04.234
for the instance of the class
which is called self.

00:15:04.234 --> 00:15:07.667
And so it binds
the new dictionary,

00:15:07.667 --> 00:15:11.834
empty dictionary,
to self.ins,

00:15:11.834 --> 00:15:13.834
which is an attribute
of the instance,

00:15:13.834 --> 00:15:15.934
not of the whole class.

00:15:15.934 --> 00:15:18.467
And then,
we have two methods.

00:15:18.467 --> 00:15:22.300
One does append
to the class attribute,

00:15:22.300 --> 00:15:27.634
and this one does an insertion
into the instance attribute.

00:15:27.634 --> 00:15:30.567
How we instantly change classes
is simply by calling them.

00:15:30.567 --> 00:15:31.634
There is no need

00:15:31.634 --> 00:15:34.000
for such redundant operators
as new.

00:15:34.000 --> 00:15:35.601
We just call the class

00:15:35.601 --> 00:15:41.033
and each time we call the class,
we get a fresh new instance.

00:15:41.033 --> 00:15:42.801
So, having
just initiated them,

00:15:42.801 --> 00:15:46.400
I see that the cla
of the instances

00:15:46.400 --> 00:15:47.701
is the empty list

00:15:47.701 --> 00:15:51.701
because since the instance
doesn't have one,

00:15:51.701 --> 00:15:53.601
it goes back to the class

00:15:53.601 --> 00:15:57.801
and the ins
our empty dictionary,

00:15:57.801 --> 00:15:59.567
there's one per instance.

00:15:59.567 --> 00:16:01.868
Once I've called
a few methods,

00:16:01.868 --> 00:16:05.467
note that the cla is
the same for both

00:16:05.467 --> 00:16:08.901
while the ins has changed
because one is a class attribute

00:16:08.901 --> 00:16:11.200
and the other is
the instance attribute.

00:16:11.200 --> 00:16:13.834
So, if I ask
are they identical objects?

00:16:13.834 --> 00:16:16.968
Are they the same object
for the cla?

00:16:16.968 --> 00:16:19.934
The answer is true because
they both go to the class,

00:16:19.934 --> 00:16:21.534
while if I ask it
for the ins,

00:16:21.534 --> 00:16:25.267
which is by instance,
then the answer is false.

00:16:25.267 --> 00:16:29.167
They're not the same object.

00:16:29.167 --> 00:16:32.267
When, uh--
Python is kind of peculiar

00:16:32.267 --> 00:16:35.501
among very high-level languages
because it tries to make

00:16:35.501 --> 00:16:37.267
everything very explicit
for you.

00:16:37.267 --> 00:16:40.601
Remember that rule
in the Zen of Python:

00:16:40.601 --> 00:16:43.300
explicit is better
than implicit.

00:16:43.300 --> 00:16:45.501
In particular,
what does it mean

00:16:45.501 --> 00:16:48.701
to look up an attribute
on something

00:16:48.701 --> 00:16:52.300
that is very clearly,
very detailedly specified?

00:16:52.300 --> 00:16:53.801
So, for example,

00:16:53.801 --> 00:16:58.300
normally something like inst,
dot, method, arg1, arg2

00:16:58.300 --> 00:17:01.634
will be exactly like
looking at the method

00:17:01.634 --> 00:17:04.434
on the type of the instance
and passing the instance

00:17:04.434 --> 00:17:07.968
as an implied
first paragraph.

00:17:07.968 --> 00:17:11.868
More generally, whenever
you do inst dot name,

00:17:11.868 --> 00:17:15.667
whether you are about to call it
or not doesn't matter.

00:17:15.667 --> 00:17:17.267
There's a single namespace

00:17:17.267 --> 00:17:21.767
for executable
and non-executable attributes.

00:17:21.767 --> 00:17:26.667
First of all,
the string name is looked up

00:17:26.667 --> 00:17:29.000
as a possible key
into a dictionary

00:17:29.000 --> 00:17:30.467
which belongs
to the instance.

00:17:30.467 --> 00:17:33.300
Every object,
just about every object,

00:17:33.300 --> 00:17:35.934
owns a dictionary
with a special name,

00:17:35.934 --> 00:17:38.834
dunder, dict, dunder,
which is basically

00:17:38.834 --> 00:17:42.367
where all of its attributes
are organized.

00:17:42.367 --> 00:17:44.567
If it's not there,
then we try the same thing

00:17:44.567 --> 00:17:46.334
for the type
that is the class.

00:17:46.334 --> 00:17:49.033
Type and class are more or less
synonyms in Python,

00:17:49.033 --> 00:17:50.300
except class is a key word

00:17:50.300 --> 00:17:53.000
and type is
a normal identifier.

00:17:53.000 --> 00:17:55.801
If it's there, then we try
exactly the same thing

00:17:55.801 --> 00:17:57.601
along all the bases.

00:17:57.601 --> 00:18:00.467
The base classes
are recorded as one

00:18:00.467 --> 00:18:01.834
of the attributes
of the type,

00:18:01.834 --> 00:18:03.634
as part
of the class statement.

00:18:03.634 --> 00:18:07.133
If we haven't found it
in any of the bases,

00:18:07.133 --> 00:18:11.467
then we try a special method,
dunder getattr dunder,

00:18:11.467 --> 00:18:14.400
which is basically there
to let you compute

00:18:14.400 --> 00:18:17.033
attributes on the fly

00:18:17.033 --> 00:18:19.734
just in time
when necessary.

00:18:19.734 --> 00:18:22.167
If that works,
then it's a result,

00:18:22.167 --> 00:18:25.901
otherwise you finally get
an attribute error

00:18:25.901 --> 00:18:27.400
which is
an exception meaning

00:18:27.400 --> 00:18:30.767
that attribute name
does not exist anywhere

00:18:30.767 --> 00:18:33.734
in the search space,
for this instance.

00:18:33.734 --> 00:18:34.834
Now, subclassing,

00:18:34.834 --> 00:18:37.901
and this is where
overriding gets in,

00:18:37.901 --> 00:18:43.400
means you can specify that eg
is a base class of sub,

00:18:43.400 --> 00:18:47.334
and then you can define
the same thing,

00:18:47.334 --> 00:18:49.934
the same name,
meth 2 in this case,

00:18:49.934 --> 00:18:51.934
that you had already defined
in the base class

00:18:51.934 --> 00:18:54.501
and this is an override.

00:18:54.501 --> 00:18:57.701
In the override,
you can call the method

00:18:57.701 --> 00:19:02.534
on the base class explicitly
by base class dot meth2.

00:19:02.534 --> 00:19:03.968
And remember, in this case,

00:19:03.968 --> 00:19:06.200
you have to pass
self explicitly

00:19:06.200 --> 00:19:08.734
or you can do it implicitly
with a super,

00:19:08.734 --> 00:19:11.901
which is a kind
of magical piece of--

00:19:11.901 --> 00:19:14.734
a magic built-in
which does the look-up

00:19:14.734 --> 00:19:18.634
in the base classes
for you.

00:19:18.634 --> 00:19:21.634
So, another example is that
you can override data as well.

00:19:21.634 --> 00:19:24.234
So, I've defined
a subclass of list

00:19:24.234 --> 00:19:28.434
where every append is
actually done twice.

00:19:28.434 --> 00:19:30.667
So, basically every time
you append something,

00:19:30.667 --> 00:19:32.601
it's appended twice
to the list.

00:19:32.601 --> 00:19:35.200
Not particularly useful,
just an example.

00:19:35.200 --> 00:19:39.667
The point is to show
that when you subclass,

00:19:39.667 --> 00:19:41.467
you can override
a piece of data,

00:19:41.467 --> 00:19:42.901
in this case cla,

00:19:42.901 --> 00:19:45.767
just as much as
you can override a method.

00:19:45.767 --> 00:19:47.267
Again, there is
no distinction,

00:19:47.267 --> 00:19:49.033
just define it
with a different name.

00:19:49.033 --> 00:19:50.501
Every use
of that attribute

00:19:50.501 --> 00:19:53.467
will use
the overridden attribute.

00:19:53.467 --> 00:19:58.200
Another very useful concept
is that of a property.

00:19:58.200 --> 00:20:01.868
Suppose you have two method,
call them getter and setter.

00:20:01.868 --> 00:20:05.200
Getter just takes the object
and returns a value.

00:20:05.200 --> 00:20:07.501
Setter takes the object
and a value

00:20:07.501 --> 00:20:09.934
and somehow sets
the value appropriately

00:20:09.934 --> 00:20:11.567
into the object.

00:20:11.567 --> 00:20:15.000
You can give
a very nice syntax

00:20:15.000 --> 00:20:18.067
by calling the built-in property
with a getter and setter,

00:20:18.067 --> 00:20:20.701
as part of the class
assigning it to a name.

00:20:20.701 --> 00:20:24.734
Now, every time
you access that name,

00:20:24.734 --> 00:20:27.868
Python internally calls
the getter method for you.

00:20:27.868 --> 00:20:30.901
And every time you assign
something to that name,

00:20:30.901 --> 00:20:34.334
it calls the setter method
for you.

00:20:34.334 --> 00:20:37.033
So, that's very nice syntax

00:20:37.033 --> 00:20:39.601
to be substituted
to do function calls,

00:20:39.601 --> 00:20:41.701
do method calls.

00:20:41.701 --> 00:20:45.300
Note that I did say
you cannot override the equal.

00:20:45.300 --> 00:20:46.434
That only applies

00:20:46.434 --> 00:20:49.434
when the left hand side
is a simple identifier.

00:20:49.434 --> 00:20:51.901
When the left hand side
is like here,

00:20:51.901 --> 00:20:54.734
a attribute excess,
you can actually do

00:20:54.734 --> 00:20:58.133
pretty advanced stuff
even to the assignment,

00:20:58.133 --> 00:21:00.901
and property does it
for you.

00:21:00.901 --> 00:21:04.267
Why am I dwelling so much
on properties?

00:21:04.267 --> 00:21:07.868
Because there's a bean
going around

00:21:07.868 --> 00:21:08.901
particularly in Java,

00:21:08.901 --> 00:21:11.767
but to some extent
in C++ as well,

00:21:11.767 --> 00:21:13.734
that you should not
expose attribute.

00:21:13.734 --> 00:21:17.767
To keep flexibility,
you should hide attributes

00:21:17.767 --> 00:21:20.767
behind getter
and setter methods.

00:21:20.767 --> 00:21:24.067
Thanks to properties,
this is useless in Python.

00:21:24.067 --> 00:21:27.667
You just expose the interesting
attributes directly.

00:21:27.667 --> 00:21:30.667
If and when you need
a getter and a setter,

00:21:30.667 --> 00:21:31.734
you write them

00:21:31.734 --> 00:21:33.367
and you drop them
into a property,

00:21:33.367 --> 00:21:35.567
so that all client-code
using your class

00:21:35.567 --> 00:21:37.000
doesn't need to be changed.

00:21:37.000 --> 00:21:40.601
It can still assign
to attributes C attributes,

00:21:40.601 --> 00:21:43.934
and then method calls
will happen intrinsically

00:21:43.934 --> 00:21:46.167
on your behalf.

00:21:46.167 --> 00:21:48.801
Avoid boilerplate.
Don't waste pixels.

00:21:48.801 --> 00:21:53.634
Do not code this kind of thing,
just name the attribute

00:21:53.634 --> 00:21:56.667
without the leading underscore
so it's visible

00:21:56.667 --> 00:21:59.534
and let people
use them and rapid,

00:21:59.534 --> 00:22:02.767
if and when
that becomes necessary.

00:22:02.767 --> 00:22:05.067
I did mention Python
has operator overloading.

00:22:05.067 --> 00:22:07.334
How does it do
operator overloading

00:22:07.334 --> 00:22:10.434
is by defining a huge number
of special names.

00:22:10.434 --> 00:22:13.033
Special names start and end
with two underscores.

00:22:13.033 --> 00:22:14.234
Two underscores,

00:22:14.234 --> 00:22:16.000
you could say
underscore-underscore,

00:22:16.000 --> 00:22:17.234
but that's a bit long,

00:22:17.234 --> 00:22:19.234
so a common way
of pronouncing it

00:22:19.234 --> 00:22:23.534
is dunder,
for double-underscore.

00:22:23.534 --> 00:22:27.534
Anything beginning and ending
with dunder is reserved

00:22:27.534 --> 00:22:28.634
to the Python language.

00:22:28.634 --> 00:22:32.067
Do not use this form
of identifier

00:22:32.067 --> 00:22:33.734
for your own
arbitrary names.

00:22:33.734 --> 00:22:35.901
They could conflict
with special names

00:22:35.901 --> 00:22:38.100
in the future.

00:22:38.100 --> 00:22:40.534
There's a lot of things
you can do with special method.

00:22:40.534 --> 00:22:43.901
There's a constructor, new,
initializer, init.

00:22:43.901 --> 00:22:45.033
Note there is a difference

00:22:45.033 --> 00:22:46.734
between constructing
and initializing.

00:22:46.734 --> 00:22:48.133
If you're familiar

00:22:48.133 --> 00:22:52.634
with the so-called two-step
constructor design pattern,

00:22:52.634 --> 00:22:54.300
Python gives that to you.

00:22:54.300 --> 00:22:56.834
New actually makes a new object
that's still bare,

00:22:56.834 --> 00:23:00.133
and init let's you
initialize the object.

00:23:00.133 --> 00:23:04.634
Del, which is what happens
when the object goes away.

00:23:04.634 --> 00:23:07.501
It's not a destructor,
it's more of a finalizer.

00:23:07.501 --> 00:23:10.567
If you're familiar
with C++ destructors,

00:23:10.567 --> 00:23:12.033
that's a bit different.

00:23:12.033 --> 00:23:15.701
This is more like
a Java finalized.

00:23:15.701 --> 00:23:18.033
And then, there is a way
to convert things,

00:23:18.033 --> 00:23:22.400
not just to wrap
a string into flow,

00:23:22.400 --> 00:23:25.100
too complex, and so on.

00:23:25.100 --> 00:23:26.834
Many ways
to compare things:

00:23:26.834 --> 00:23:29.000
less than,
greater than, equal.

00:23:29.000 --> 00:23:31.100
A lot of method
for arithmetic:

00:23:31.100 --> 00:23:35.000
addition, subtraction,
multiplication.

00:23:35.000 --> 00:23:36.667
Methods to make it
like a function,

00:23:36.667 --> 00:23:38.534
so callable, hashable,

00:23:38.534 --> 00:23:43.334
so it can go
into a setattr dictionary.

00:23:43.334 --> 00:23:46.701
Dealing with attempts to get
set and delete attributes

00:23:46.701 --> 00:23:53.300
or items as in a container,
other container stuff.

00:23:53.300 --> 00:23:57.200
Getting set to define
what are called descriptors.

00:23:57.200 --> 00:23:59.901
Enter and exit describe
what are called contexts.

00:23:59.901 --> 00:24:04.467
So, there's a huge number
of special methods

00:24:04.467 --> 00:24:07.167
you may want to define.

00:24:07.167 --> 00:24:09.267
The point to retain,

00:24:09.267 --> 00:24:11.400
you will find out
the special methods,

00:24:11.400 --> 00:24:14.067
which are basically
a high syntax convenience,

00:24:14.067 --> 00:24:16.234
if and when
you need them.

00:24:16.234 --> 00:24:20.400
Python will call the type
special method for you

00:24:20.400 --> 00:24:23.534
when you attempt
the appropriate operation.

00:24:23.534 --> 00:24:24.634
So, for example,

00:24:24.634 --> 00:24:27.901
when you write
foo, open, close,

00:24:27.901 --> 00:24:30.567
Python looks up
the type of foo,

00:24:30.567 --> 00:24:36.567
finds the dunder call method,
and that's what gets called.

00:24:36.567 --> 00:24:42.267
It would be like operator,
open, close, paren in C++

00:24:42.267 --> 00:24:45.801
and sometimes it does so
in a more structured way.

00:24:45.801 --> 00:24:52.167
For example, if you ask
if a greater than b,

00:24:52.167 --> 00:24:56.734
and a doesn't
have a gt method,

00:24:56.734 --> 00:25:01.234
Python continues by looking
if b as an lt method,

00:25:01.234 --> 00:25:03.934
so that it's basically
going to compute

00:25:03.934 --> 00:25:06.400
as a second possibility
if b is less than a

00:25:06.400 --> 00:25:09.033
rather than if a
is greater than b.

00:25:09.033 --> 00:25:12.467
More generally, built-ins
do things right for you,

00:25:12.467 --> 00:25:16.267
but let's get
a simple example first.

00:25:16.267 --> 00:25:19.968
Remember the Fibonacci generator
we did a few minutes ago?

00:25:19.968 --> 00:25:25.200
This is the same thing done
much more detailedly as a class.

00:25:25.200 --> 00:25:28.567
At initialization,
we set one to i and j.

00:25:28.567 --> 00:25:30.400
It's got to be self.i
and self.j

00:25:30.400 --> 00:25:32.834
because of
their instance attribute.

00:25:32.834 --> 00:25:37.601
We have to specify
an iterator by saying

00:25:37.601 --> 00:25:41.501
if somebody wants to iterate
and use me directly.

00:25:41.501 --> 00:25:43.167
And then there's the next,

00:25:43.167 --> 00:25:46.968
which is unfortunately
not marked by dunder.

00:25:46.968 --> 00:25:52.367
This is fixed in Python 3.0,
but this is in Python 2.

00:25:52.367 --> 00:25:54.467
We didn't place
the double-underscore,

00:25:54.467 --> 00:25:56.901
but it is a special method
because it's called,

00:25:56.901 --> 00:25:59.200
for example,
by the for loop.

00:25:59.200 --> 00:26:01.968
And this does essentially
the same thing

00:26:01.968 --> 00:26:05.267
that we did more simply
in the generator,

00:26:05.267 --> 00:26:09.567
but it does it explicitly
with self dot variables,

00:26:09.567 --> 00:26:12.133
and this is basically
intended to be used

00:26:12.133 --> 00:26:15.501
in exactly the same way
as the generator I gave before.

00:26:15.501 --> 00:26:17.200
So, it's exactly
the same semantics.

00:26:17.200 --> 00:26:19.033
Basically,
what the generator does

00:26:19.033 --> 00:26:23.033
is generate for you an object
which is more or less like this.

00:26:23.033 --> 00:26:29.801
Okay, built-in functions are
what calls the special methods.

00:26:29.801 --> 00:26:34.300
You never call a special method
directly, essentially.

00:26:34.300 --> 00:26:35.534
Think
of the double-underscore

00:26:35.534 --> 00:26:38.501
as a way to make
special method ugly,

00:26:38.501 --> 00:26:40.901
so you're not even tempted
to call them.

00:26:40.901 --> 00:26:45.701
Never call x, dot, dunder,
len, open, close.

00:26:45.701 --> 00:26:49.701
Call len, open, x, close,
it will do the right job,

00:26:49.701 --> 00:26:52.534
which in this case is
calling dunder len.

00:26:52.534 --> 00:26:58.000
Another example, abs,
don't call this directly.

00:26:58.000 --> 00:27:00.634
You don't really know
what the abs built-in does.

00:27:00.634 --> 00:27:02.267
It will probably call
dunder abs,

00:27:02.267 --> 00:27:03.667
but suppose
it doesn't find it?

00:27:03.667 --> 00:27:07.400
It may be able to do
a change sign test

00:27:07.400 --> 00:27:10.367
if greater than zero changes
the sign for you.

00:27:10.367 --> 00:27:11.567
It may or may not,

00:27:11.567 --> 00:27:13.734
but always go through
the built-in function.

00:27:13.734 --> 00:27:15.467
There are a lot
of built-in functions,

00:27:15.467 --> 00:27:20.567
not just ones corresponding
directly to special methods.

00:27:20.567 --> 00:27:23.534
We'll see some of them
in examples.

00:27:23.534 --> 00:27:25.567
And also, these are
just the ones

00:27:25.567 --> 00:27:27.601
that are always
available to you,

00:27:27.601 --> 00:27:29.534
but there's a lot
in the standard library

00:27:29.534 --> 00:27:32.300
that you want to use
just as much,

00:27:32.300 --> 00:27:36.767
and these are all
absolutely crucial modules

00:27:36.767 --> 00:27:37.968
in the standard library

00:27:37.968 --> 00:27:40.367
you'll need to be
very familiar with

00:27:40.367 --> 00:27:44.033
to do effective use
of Python.

00:27:44.033 --> 00:27:47.868
As I said, rather than going
into these in details,

00:27:47.868 --> 00:27:50.367
I like to give an example.

00:27:50.367 --> 00:27:53.567
Suppose we have
a readable file somewhere.

00:27:53.567 --> 00:27:58.100
We'd like to make an index
that is a map

00:27:58.100 --> 00:28:01.434
from the words
in the file

00:28:01.434 --> 00:28:06.267
to the line numbers
where that word is found.

00:28:06.267 --> 00:28:09.234
So, first we build the map,
and then we emit it.

00:28:09.234 --> 00:28:11.567
To build a map, we start
with an empty dictionary.

00:28:11.567 --> 00:28:14.767
A dictionary is natural way
to represent a mapping.

00:28:14.767 --> 00:28:18.067
We use
with open, filename, as f,

00:28:18.067 --> 00:28:20.834
syntaxed to open it
and guarantee it's closed

00:28:20.834 --> 00:28:23.634
as soon as we're out
out of this block.

00:28:23.634 --> 00:28:28.133
We use enumerate
to get line numbers

00:28:28.133 --> 00:28:29.968
and generally looping
on a file

00:28:29.968 --> 00:28:33.868
gives you the lines
of the files or strings.

00:28:33.868 --> 00:28:35.667
And then, we call
the split method

00:28:35.667 --> 00:28:39.267
which breaks a line
into a list of words

00:28:39.267 --> 00:28:41.167
and to loop over that.

00:28:41.167 --> 00:28:44.968
And here, we use the setdefault,
which is a bit complicated

00:28:44.968 --> 00:28:47.267
because basically
what it does is

00:28:47.267 --> 00:28:50.901
it looks up this key
in the dictionary.

00:28:50.901 --> 00:28:54.234
If it's there, it returns
what corresponds to it,

00:28:54.234 --> 00:28:55.534
The corresponding value.

00:28:55.534 --> 00:28:59.734
If it's not, then it sets
the second argument

00:28:59.734 --> 00:29:02.834
as the new value
for the key.

00:29:02.834 --> 00:29:04.167
So, it's kind
of complicated,

00:29:04.167 --> 00:29:06.934
but basically
you take either a list

00:29:06.934 --> 00:29:09.200
already corresponding
to the word

00:29:09.200 --> 00:29:10.801
or a new empty list.

00:29:10.801 --> 00:29:13.300
In either case, you append
the line number to it,

00:29:13.300 --> 00:29:16.734
so the line numbers
accumulate.

00:29:16.734 --> 00:29:19.501
And then,
once we have our index,

00:29:19.501 --> 00:29:23.133
we can just emit it
to standard output

00:29:23.133 --> 00:29:24.934
in alphabetical order.

00:29:24.934 --> 00:29:27.067
So, for that,
we use a sorted built-in

00:29:27.067 --> 00:29:31.834
which let's you loop on it
in a sorted way,

00:29:31.834 --> 00:29:36.367
so sorted order for strings
is alphabetical,

00:29:36.367 --> 00:29:41.868
so you loop on the words
in order and you print them.

00:29:41.868 --> 00:29:44.234
I'm using the percent
for marking here

00:29:44.234 --> 00:29:47.501
just to have a colon
attached to it,

00:29:47.501 --> 00:29:49.300
and then we print
the line numbers.

00:29:49.300 --> 00:29:51.934
Note the comma here,
so we don't break the line,

00:29:51.934 --> 00:29:53.734
and finally a print
without anything

00:29:53.734 --> 00:29:56.701
just to break the line
at the very end.

00:29:56.701 --> 00:29:58.767
We can do it
slightly simpler

00:29:58.767 --> 00:30:05.801
if we're familiar
with the standard library

00:30:05.801 --> 00:30:10.667
because the collections module
has a sub-type of dict

00:30:10.667 --> 00:30:12.300
known as a defaultdict.

00:30:12.300 --> 00:30:16.434
A defaultdict is something
that if you try to index it

00:30:16.434 --> 00:30:18.334
and the index isn't there,
the key isn't there,

00:30:18.334 --> 00:30:21.133
instead of raising
a key error

00:30:21.133 --> 00:30:24.100
it calls something
to make the new item.

00:30:24.100 --> 00:30:27.601
In this case, we want to call
the type list without arguments

00:30:27.601 --> 00:30:29.901
to make an empty list
and set it there.

00:30:29.901 --> 00:30:33.634
So, once we've made
a collections defaultdict list

00:30:33.634 --> 00:30:36.667
instead of a plain dictionary,
we can simply use

00:30:36.667 --> 00:30:39.501
index word append(n)
instead of having to go

00:30:39.501 --> 00:30:41.667
the complicated
set default route.

00:30:41.667 --> 00:30:42.801
Everything else,

00:30:42.801 --> 00:30:45.133
every other bit of code
in this slide,

00:30:45.133 --> 00:30:46.601
is just the same.

00:30:46.601 --> 00:30:48.901
Other things we could do
that could be interesting:

00:30:48.901 --> 00:30:52.234
once we have this index,
what about getting

00:30:52.234 --> 00:30:55.367
the seven most popular words
in the text files?

00:30:55.367 --> 00:30:59.267
What are the seven words

00:30:59.267 --> 00:31:03.434
that appear on most lines
in this file?

00:31:03.434 --> 00:31:07.000
Well, for this purpose,
we want to use heapq.

00:31:07.000 --> 00:31:10.100
Typically, it's a typical
priority heap operation,

00:31:10.100 --> 00:31:13.000
if you're familiar
with your algorithms,

00:31:13.000 --> 00:31:17.367
and specifically it exposes
heapq.nlargest.

00:31:17.367 --> 00:31:21.801
Give me the n largest items
of a certain collection

00:31:21.801 --> 00:31:25.567
and the n we want is seven,
the collection is indx,

00:31:25.567 --> 00:31:30.000
and we get to define
what is the key extractor

00:31:30.000 --> 00:31:31.400
for the comparison.

00:31:31.400 --> 00:31:33.601
So, key equal index.get means

00:31:33.601 --> 00:31:37.734
 we're not getting the seven
alphabetically largest,

00:31:37.734 --> 00:31:40.667
but the seven
whose corresponding value index

00:31:40.667 --> 00:31:45.234
is largest,
and this will work.

00:31:45.234 --> 00:31:48.968
And this is an end walk form
that is--

00:31:48.968 --> 00:31:52.834
I don't want all the lines
with the word rabbit

00:31:52.834 --> 00:31:55.534
or all the lines
with the word hare.

00:31:55.534 --> 00:31:59.667
I want the lines
with both rabbit and hare.

00:31:59.667 --> 00:32:01.267
How am I gonna find them?

00:32:01.267 --> 00:32:04.267
This is a set
intersection problem.

00:32:04.267 --> 00:32:08.067
So, I'm basically going
to simply make a list

00:32:08.067 --> 00:32:09.901
of all the words
I'm looking for,

00:32:09.901 --> 00:32:11.200
pop the first item,

00:32:11.200 --> 00:32:14.801
and make a set out of
the corresponding line numbers,

00:32:14.801 --> 00:32:17.367
and then I'm using
the ampersand operator

00:32:17.367 --> 00:32:19.100
to do intersection

00:32:19.100 --> 00:32:21.400
specifically in the form
ampersand equals,

00:32:21.400 --> 00:32:23.133
so intersect in place.

00:32:23.133 --> 00:32:26.434
Basically, all binary operators
have an equal form,

00:32:26.434 --> 00:32:29.767
so, for example,
plus equal increments in place

00:32:29.767 --> 00:32:33.067
and ampersand equal
intersects in place.

00:32:33.067 --> 00:32:35.634
And, in the end, of course,
I'm careful to sort it

00:32:35.634 --> 00:32:39.567
so it will print out nicely
in alphabet, in line order.

00:32:39.567 --> 00:32:42.033
Because the set,
by making a set,

00:32:42.033 --> 00:32:44.567
I get very fast intersection
and so on,

00:32:44.567 --> 00:32:47.601
but I lose significant order

00:32:47.601 --> 00:32:51.467
because a set is a hush table,
so it basically, as I mentioned,

00:32:51.467 --> 00:32:53.367
doesn't have
an intrinsic order.

00:32:53.367 --> 00:32:57.801
But when I do need it,
I can always sort it on the fly.

00:32:57.801 --> 00:33:01.601
So, I mentioned that
that standard library

00:33:01.601 --> 00:33:04.634
is full
of very useful modules.

00:33:04.634 --> 00:33:08.067
To access anything
in the standard library

00:33:08.067 --> 00:33:10.968
or any other module,
you have to import the module

00:33:10.968 --> 00:33:12.400
and this is
how you do it.

00:33:12.400 --> 00:33:15.834
I already showed it
in a couple of examples,

00:33:15.834 --> 00:33:20.300
but import modulename
is the economical way.

00:33:20.300 --> 00:33:21.534
So, for example,

00:33:21.534 --> 00:33:24.133
when I wanted to use
something in collections,

00:33:24.133 --> 00:33:26.767
I started
with import collections.

00:33:26.767 --> 00:33:29.467
This basically makes the name
collections available

00:33:29.467 --> 00:33:31.534
to my program.

00:33:31.534 --> 00:33:33.734
And the name collections
refers to that module,

00:33:33.734 --> 00:33:36.667
so then I can use
the attributes of the module

00:33:36.667 --> 00:33:38.467
in my program.

00:33:38.467 --> 00:33:41.000
If a module is contained
in a package,

00:33:41.000 --> 00:33:44.934
you will see exactly what
a package is in a second,

00:33:44.934 --> 00:33:47.334
then I cannot
just import it

00:33:47.334 --> 00:33:50.067
because it's hiding
inside a package.

00:33:50.067 --> 00:33:51.234
I have to tell Python

00:33:51.234 --> 00:33:54.501
from what package
to import it.

00:33:54.501 --> 00:33:57.334
This would be a package
named package

00:33:57.334 --> 00:33:59.000
inside a package
named given

00:33:59.000 --> 00:34:01.400
inside a package named some.

00:34:01.400 --> 00:34:04.100
So, some dot given
dot package,

00:34:04.100 --> 00:34:06.767
Python would look for some
inside of given,

00:34:06.767 --> 00:34:11.767
inside of package,
and inside that for modulename.

00:34:11.767 --> 00:34:15.634
In either way,
you basically get the modulename

00:34:15.634 --> 00:34:19.334
as part of your namespace
and you can access it.

00:34:19.334 --> 00:34:21.934
And then,
you want function blah

00:34:21.934 --> 00:34:23.133
from the module,

00:34:23.133 --> 00:34:26.234
just do modulename dot blah
and you're done.

00:34:26.234 --> 00:34:28.734
So, there are
some other ways.

00:34:28.734 --> 00:34:31.801
I did mention that we'd
rather have only one way,

00:34:31.801 --> 00:34:34.133
but sometimes
it's kind of inevitable

00:34:34.133 --> 00:34:35.701
to offer more than one.

00:34:35.701 --> 00:34:37.267
Although in practice
these two will

00:34:37.267 --> 00:34:39.634
make you happy
all the time,

00:34:39.634 --> 00:34:41.100
you should be aware
of the others

00:34:41.100 --> 00:34:45.100
because you'll see them used
in Python examples and code.

00:34:45.100 --> 00:34:50.467
One possibility is
you can import the module

00:34:50.467 --> 00:34:53.534
under an assumed name.

00:34:53.534 --> 00:34:55.968
Basically, put a false mustache
on the module

00:34:55.968 --> 00:34:58.367
so it makes believe
in your namespace

00:34:58.367 --> 00:35:00.200
that it's named
something different

00:35:00.200 --> 00:35:03.400
and that is the as clause.

00:35:03.400 --> 00:35:04.501
So, for example,

00:35:04.501 --> 00:35:07.334
suppose somebody gives you
a name that is--

00:35:07.334 --> 00:35:09.033
this name is far too long

00:35:09.033 --> 00:35:12.334
and this name is far too long
to use conveniently,

00:35:12.334 --> 00:35:16.100
and you would like to have
a shorter name for it.

00:35:16.100 --> 00:35:17.400
Well, this is
how you do it.

00:35:17.400 --> 00:35:20.133
Import thisnameisfartoolong
as a set,

00:35:20.133 --> 00:35:23.834
and now instead of 
thisnameisfartoolong dot blah,

00:35:23.834 --> 00:35:25.367
you can use zed dot blah.

00:35:25.367 --> 00:35:27.567
And this is indeed
sometimes useful

00:35:27.567 --> 00:35:29.901
if you ever have
to handle modules

00:35:29.901 --> 00:35:33.334
whose names
are far too long.

00:35:33.334 --> 00:35:35.567
Tips I don't recommend is

00:35:35.567 --> 00:35:42.334
instead of getting the module
into your namespace,

00:35:42.334 --> 00:35:46.868
reach into the module namespace
and grab one thing into yours

00:35:46.868 --> 00:35:49.634
from thisnameisfartoolong
import blah.

00:35:49.634 --> 00:35:55.067
This will work, but throughout
the rest of your code

00:35:55.067 --> 00:35:56.801
people who are reading it,
including yourself

00:35:56.801 --> 00:35:58.667
when you're maintaining it
in six months,

00:35:58.667 --> 00:36:01.701
will wonder
where's this blah from,

00:36:01.701 --> 00:36:06.334
and you will have to go and
look for when it was imported.

00:36:06.334 --> 00:36:10.434
So, I'd rather always see
modulename.blah or z.blah

00:36:10.434 --> 00:36:12.434
to get the immediate thing.

00:36:12.434 --> 00:36:16.367
It's not a top level name,
it's coming from something else.

00:36:16.367 --> 00:36:19.868
And the very worst thing
is to import star,

00:36:19.868 --> 00:36:23.467
which basically grabs all
of the items in the namespace

00:36:23.467 --> 00:36:25.133
and injects them into yours.

00:36:25.133 --> 00:36:26.634
Don't do that.

00:36:26.634 --> 00:36:30.968
That is a guaranteed way
to cause yourself headaches.

00:36:30.968 --> 00:36:33.868
It's handy if you're
at the interpreter prompt

00:36:33.868 --> 00:36:37.501
because say you're doing a lot
of math interpreter prompt,

00:36:37.501 --> 00:36:38.934
you don't want to say

00:36:38.934 --> 00:36:44.667
math dot syn, math dot cos,
math dot tan, math dot atan.

00:36:44.667 --> 00:36:47.133
You want
syn, cos, tan, atan

00:36:47.133 --> 00:36:49.067
and all
the mathematical functions

00:36:49.067 --> 00:36:52.400
to be part
of the top namespace

00:36:52.400 --> 00:36:55.634
because it's too much
typing otherwise.

00:36:55.634 --> 00:36:57.901
That's possibly
the only reasonable way

00:36:57.901 --> 00:37:02.033
to use the import star.

00:37:02.033 --> 00:37:04.667
And this is,
to clarify what I just--

00:37:04.667 --> 00:37:10.234
So, I want to compute
an arctan with two inputs.

00:37:10.234 --> 00:37:12.167
The normal way is
to import math,

00:37:12.167 --> 00:37:16.400
and then use math.atan2
of x and y,

00:37:16.400 --> 00:37:19.234
which in this case
is this value.

00:37:19.234 --> 00:37:23.367
If I tried even after importing
to just use atan2,

00:37:23.367 --> 00:37:25.801
this would give
a NameError exception

00:37:25.801 --> 00:37:28.868
because,
in my current namespace,

00:37:28.868 --> 00:37:31.567
there is no name
atan2 defined.

00:37:31.567 --> 00:37:35.234
Remember, I got math
into my namespace,

00:37:35.234 --> 00:37:40.234
but atan2 is still
within namespace math.

00:37:40.234 --> 00:37:43.334
I could do,
from math import, atan2.

00:37:43.334 --> 00:37:45.934
In this case,
this would inject atan2

00:37:45.934 --> 00:37:49.868
in my namespace.

00:37:49.868 --> 00:37:53.133
Sometimes, when you're doing
this interactively

00:37:53.133 --> 00:37:55.567
like at the prompt,
it's kind of nice.

00:37:55.567 --> 00:37:57.000
In real programs,

00:37:57.000 --> 00:38:00.734
it tends to be confusing
and this goes squared.

00:38:00.734 --> 00:38:02.300
From math import star,

00:38:02.300 --> 00:38:05.934
now you have
25 mathematical functions

00:38:05.934 --> 00:38:08.868
in your namespace
which is handy,

00:38:08.868 --> 00:38:11.367
but don't do it
in real programs,

00:38:11.367 --> 00:38:14.767
only in interactive use.

00:38:14.767 --> 00:38:19.167
So, this is nice about
how I use other modules,

00:38:19.167 --> 00:38:20.934
but how do I make
my own modules?

00:38:20.934 --> 00:38:22.300
Well, that's easy.

00:38:22.300 --> 00:38:25.767
Any Python program
is a module.

00:38:25.767 --> 00:38:29.300
Any dot py--wot dot py
is a module.

00:38:29.300 --> 00:38:32.868
Just put it
in the appropriate directory,

00:38:32.868 --> 00:38:34.901
say the same directory
as the one

00:38:34.901 --> 00:38:40.067
it's being imported from,
the rules depend a bit on--

00:38:40.067 --> 00:38:42.400
but for Google App Engine
that's what you do.

00:38:42.400 --> 00:38:45.234
And then, any other module
in that directory

00:38:45.234 --> 00:38:47.400
can do import wot

00:38:47.400 --> 00:38:51.534
and Python will look
for wot.py.

00:38:51.534 --> 00:38:56.334
The directories are listed
in sys.path,

00:38:56.334 --> 00:38:59.634
and they need not
be directories strictly.

00:38:59.634 --> 00:39:02.000
In general,
they could be zipped files.

00:39:02.000 --> 00:39:04.567
So, instead of having
a file system, 

00:39:04.567 --> 00:39:06.267
you can basically
zip everything up

00:39:06.267 --> 00:39:07.767
and Python will
find it anyway.

00:39:07.767 --> 00:39:11.267
That's kind of handy.

00:39:11.267 --> 00:39:13.601
There are other things
that you can import.

00:39:13.601 --> 00:39:16.501
You could import
byte code files.

00:39:16.501 --> 00:39:20.234
You could import files
coded in C

00:39:20.234 --> 00:39:24.234
or other languages
for Python.

00:39:24.234 --> 00:39:27.367
So, the extensions
are pyc, pyd,

00:39:27.367 --> 00:39:32.100
or sometimes dot so
on Linux,

00:39:32.100 --> 00:39:35.834
but this wouldn't work
in Google App Engine.

00:39:35.834 --> 00:39:40.133
Google App Engine
only accepts the dot py files,

00:39:40.133 --> 00:39:44.234
so you want to make sure
you place the dot py itself.

00:39:44.234 --> 00:39:47.100
It handles the compilation
to bytecode

00:39:47.100 --> 00:39:50.167
in making sure
the bytecode is secure

00:39:50.167 --> 00:39:54.400
and everything else
under the covers.

00:39:54.400 --> 00:39:57.534
So, this variant is nice

00:39:57.534 --> 00:40:00.033
for other kind
of uses of Python,

00:40:00.033 --> 00:40:04.667
but don't rely on it
on the application engine.

00:40:04.667 --> 00:40:06.100
So, what's a module?

00:40:06.100 --> 00:40:10.901
Well, it's an object.
Everything is an object.

00:40:10.901 --> 00:40:13.100
It's got attributes.

00:40:13.100 --> 00:40:14.901
That's basically
everything it has.

00:40:14.901 --> 00:40:17.100
It doesn't have
anything sophisticated,

00:40:17.100 --> 00:40:19.200
only attributes.

00:40:19.200 --> 00:40:22.901
The attributes
of the module object

00:40:22.901 --> 00:40:26.667
are what you could see
as the top-level names

00:40:26.667 --> 00:40:28.434
of the module as a source.

00:40:28.434 --> 00:40:32.300
So, for example,
say we have a module

00:40:32.300 --> 00:40:37.400
whose dot py source
is only x equals 23.

00:40:37.400 --> 00:40:40.934
This is called
wot dot py.

00:40:40.934 --> 00:40:42.400
If we import wot,

00:40:42.400 --> 00:40:45.601
then the only thing there is
in it is wot dot x,

00:40:45.601 --> 00:40:49.934
which is 23
and that's all.

00:40:49.934 --> 00:40:52.300
Besides assignment,
names can be bound

00:40:52.300 --> 00:40:55.667
by class, def,
import, and from.

00:40:55.667 --> 00:41:00.100
Class name binds the name,
def name binds the name,

00:41:00.100 --> 00:41:01.901
import name binds the name,

00:41:01.901 --> 00:41:06.968
from foo bar import name
binds the name.

00:41:06.968 --> 00:41:09.267
The attributes of a module
are also known

00:41:09.267 --> 00:41:12.367
as the global variables
of that module.

00:41:12.367 --> 00:41:17.734
Note there are no such things
as global globals in Python.

00:41:17.734 --> 00:41:20.901
Globals are always
per module.

00:41:20.901 --> 00:41:23.367
Within that module,
you can of course access them

00:41:23.367 --> 00:41:25.434
as bare names
from other modules,

00:41:25.434 --> 00:41:30.968
who will access them by
modulename dot variablename.

00:41:30.968 --> 00:41:33.067
Note again,
well, variables,

00:41:33.067 --> 00:41:34.767
but can they be
functions or classes?

00:41:34.767 --> 00:41:37.300
Yes, there's no distinction.

00:41:37.300 --> 00:41:39.934
Names are names are names.

00:41:39.934 --> 00:41:45.200
Whether they're callable or not,
they're just attributes.

00:41:45.200 --> 00:41:49.267
You can also bind and unbind
module attributes

00:41:49.267 --> 00:41:50.801
from the outside,

00:41:50.801 --> 00:41:54.901
a practice known
as monkey patching.

00:41:54.901 --> 00:41:57.901
I would strongly
recommend against that

00:41:57.901 --> 00:41:59.167
in production code.

00:41:59.167 --> 00:42:01.467
Unless you're fixing some bug
in a library

00:42:01.467 --> 00:42:06.133
which you're not allowed
to edit, don't do it.

00:42:06.133 --> 00:42:08.367
Sometimes it's handy
for testing,

00:42:08.367 --> 00:42:11.534
but there are better ways.

00:42:11.534 --> 00:42:15.067
Use the dependency injection
design pattern,

00:42:15.067 --> 00:42:20.067
you will do your testing
in a much more systematic way.

00:42:20.067 --> 00:42:24.067
I would strongly recommend
avoiding monkey patching.

00:42:24.067 --> 00:42:26.701
If you look 
for monkey patching on the web,

00:42:26.701 --> 00:42:30.968
you'll find very strong
diatribes for and against it

00:42:30.968 --> 00:42:34.567
for every language
that's supported besides Python

00:42:34.567 --> 00:42:37.334
including Ruby, JavaScript,
and so on.

00:42:37.334 --> 00:42:39.767
It moves a lot of emotion.

00:42:39.767 --> 00:42:42.901
Basically, people who are
programmers at heart

00:42:42.901 --> 00:42:44.400
don't want to do it,

00:42:44.400 --> 00:42:47.501
but all these languages
are used by people

00:42:47.501 --> 00:42:50.501
who need to program
but aren't programmers.

00:42:50.501 --> 00:42:52.334
They're like hardware experts

00:42:52.334 --> 00:42:55.968
or web experts and so on,
and they don't see why

00:42:55.968 --> 00:42:57.767
they should do things
the proper way,

00:42:57.767 --> 00:43:02.601
but I'll leave that
to the web.

00:43:02.601 --> 00:43:06.834
It's important to notice
that modules are singletons.

00:43:06.834 --> 00:43:11.267
They are the most natural
and Pythonic form of singletons.

00:43:11.267 --> 00:43:13.667
They're automatic singletons.
What does it mean?

00:43:13.667 --> 00:43:17.934
It means that if you import
a module more than once,

00:43:17.934 --> 00:43:20.567
the first import is treated
very differently

00:43:20.567 --> 00:43:22.701
from all the following ones.

00:43:22.701 --> 00:43:26.667
The first import finds
the module somewhere,

00:43:26.667 --> 00:43:30.367
loads its composite
on the fly if needed

00:43:30.367 --> 00:43:32.901
or takes the compiled form,

00:43:32.901 --> 00:43:34.901
executes the body
of the module,

00:43:34.901 --> 00:43:38.534
so the module object
is properly populated,

00:43:38.534 --> 00:43:43.701
and places the module
in a system directory

00:43:43.701 --> 00:43:45.801
known as sys dot modules.

00:43:45.801 --> 00:43:49.601
Sys is itself a module,
so you can import sys

00:43:49.601 --> 00:43:51.634
if you want to play
around with it,

00:43:51.634 --> 00:43:53.934
and sys dot modules
is a dictionary.

00:43:53.934 --> 00:43:56.200
The keys are the names
of modules.

00:43:56.200 --> 00:43:59.901
The values are
the module objects.

00:43:59.901 --> 00:44:03.300
So, when you import
the module again,

00:44:03.300 --> 00:44:05.400
Python will first look
into sys.modules.

00:44:05.400 --> 00:44:08.367
It's very, very fast to check
if something is in a dictionary.

00:44:08.367 --> 00:44:10.133
If it finds the name,

00:44:10.133 --> 00:44:12.334
that's what it
gives you immediately,

00:44:12.334 --> 00:44:14.968
basically one instruction.

00:44:14.968 --> 00:44:19.501
No second loading,
no further execution--instant.

00:44:19.501 --> 00:44:23.501
Your singleton
is right there.

00:44:23.501 --> 00:44:28.434
So, some people who love
the singleton design pattern

00:44:28.434 --> 00:44:31.167
say, "Well, yeah,
this kind of works,

00:44:31.167 --> 00:44:32.968
"but it only
gives me a module.

00:44:32.968 --> 00:44:36.901
It can't--I can choose
a class instance there."

00:44:36.901 --> 00:44:40.367
So, for example,
I want my singleton object

00:44:40.367 --> 00:44:45.534
to support addition
or greater than comparison,

00:44:45.534 --> 00:44:48.467
and I can't do that because
modules are simple objects.

00:44:48.467 --> 00:44:50.300
Even if you define
a function called 

00:44:50.300 --> 00:44:53.667
under, under, add, under, under,
it won't do anything.

00:44:53.667 --> 00:44:55.200
It's not as special

00:44:55.200 --> 00:44:58.234
because it's not part
of the type of the module.

00:44:58.234 --> 00:45:01.601
Remember,
the special methods only work

00:45:01.601 --> 00:45:04.601
if they're in the type,
not in the instance.

00:45:04.601 --> 00:45:12.667
So, this is how you stick
something that's not a module

00:45:12.667 --> 00:45:14.667
into sys.modules.

00:45:14.667 --> 00:45:16.501
Some people
consider it a trick,

00:45:16.501 --> 00:45:19.000
I consider it
a perfectly legitimate use

00:45:19.000 --> 00:45:21.801
of a mechanism that Python
exposes for your users.

00:45:21.801 --> 00:45:23.701
Of course,
it's a very advanced one,

00:45:23.701 --> 00:45:27.567
but it's a way to make--

00:45:27.567 --> 00:45:30.734
Oh, by the way, dunder name
is a special attribute,

00:45:30.734 --> 00:45:33.667
which is the name
of the current module.

00:45:33.667 --> 00:45:36.901
And that's how you
basically make your class

00:45:36.901 --> 00:45:38.267
and underscoring front

00:45:38.267 --> 00:45:40.467
just to indicate
it's actually private

00:45:40.467 --> 00:45:42.934
and intended
for internal purposes,

00:45:42.934 --> 00:45:45.100
and there you go.

00:45:45.100 --> 00:45:48.934
Packages are essentially modules
containing other modules

00:45:48.934 --> 00:45:51.667
and, of course,
there is no limit

00:45:51.667 --> 00:45:54.501
to nesting
you can do this way.

00:45:54.501 --> 00:45:57.334
So, you can have sub-packages
and so on.

00:45:57.334 --> 00:46:00.801
In practice, it lives typically
in a file system

00:46:00.801 --> 00:46:02.501
or it could be
in a zipped file.

00:46:02.501 --> 00:46:04.133
In a directory--

00:46:04.133 --> 00:46:05.801
And how you
distinguish directories,

00:46:05.801 --> 00:46:07.100
which are just directories

00:46:07.100 --> 00:46:09.400
from directories
which are packages,

00:46:09.400 --> 00:46:11.667
is by the presence
of a file called

00:46:11.667 --> 00:46:17.734
dunder, init, under, under,
init, under, under, dot, py.

00:46:17.734 --> 00:46:21.400
Python will only consider
for a package as such

00:46:21.400 --> 00:46:24.334
a directory which has a file
by that name.

00:46:24.334 --> 00:46:30.400
So, that file contains
the module body.

00:46:30.400 --> 00:46:33.534
It's often empty because
you don't necessarily want

00:46:33.534 --> 00:46:35.734
the package to do
anything else

00:46:35.734 --> 00:46:37.567
than containing other modules.

00:46:37.567 --> 00:46:41.100
And so, you don't need
to do anything in init py,

00:46:41.100 --> 00:46:43.000
but you still need
to have it there

00:46:43.000 --> 00:46:45.701
because it acts as a flag
to Python

00:46:45.701 --> 00:46:48.400
that, yes, this is not
just any directory,

00:46:48.400 --> 00:46:51.100
this is a package.

00:46:51.100 --> 00:46:54.100
The modules
inside the packages are

00:46:54.100 --> 00:46:57.400
basically all the py files
in that directory.

00:46:57.400 --> 00:47:00.501
And that is done for you
by Python,

00:47:00.501 --> 00:47:02.267
so you don't need
to worry about it.

00:47:02.267 --> 00:47:03.734
And if you want sub-packages,

00:47:03.734 --> 00:47:07.767
you will have sub-directories
which in turn need to contain

00:47:07.767 --> 00:47:11.300
the special dunder init
dunder file.

00:47:11.300 --> 00:47:14.868
Note that the parent directory
of the directory package

00:47:14.868 --> 00:47:17.901
must be on sys.path.

00:47:17.901 --> 00:47:23.100
And once you have a package
with a module bar inside it,

00:47:23.100 --> 00:47:26.067
you could import
foo dot bar,

00:47:26.067 --> 00:47:29.300
that will work,
it will bind foo dot bar.

00:47:29.300 --> 00:47:32.567
So, you'll bind foo
and give it an attribute bar,

00:47:32.567 --> 00:47:35.534
but a more normal,
more common approach is

00:47:35.534 --> 00:47:38.801
to use
a from foo import bar

00:47:38.801 --> 00:47:40.667
that only binds
the name bar directly.

00:47:40.667 --> 00:47:43.334
So, basically,
I like my imports

00:47:43.334 --> 00:47:46.501
to always bind a module
to a name,

00:47:46.501 --> 00:47:50.534
and this is what it does.

00:47:50.534 --> 00:47:53.300
Okay, now we've
basically covered,

00:47:53.300 --> 00:47:55.968
well, so to speak
the Python language

00:47:55.968 --> 00:47:57.767
and a little bit
of the built-ins

00:47:57.767 --> 00:48:02.100
in a very tiny fraction
of the standard libraries.

00:48:02.100 --> 00:48:06.434
One of the mottos of Python
is "Batteries Included."

00:48:06.434 --> 00:48:08.634
It means that the standard
Python library

00:48:08.634 --> 00:48:11.367
has more than 200 modules.

00:48:11.367 --> 00:48:12.834
That's production modules.

00:48:12.834 --> 00:48:14.601
There is many more
for unit-tests,

00:48:14.601 --> 00:48:19.434
encoders, decoders, demos
of various kinds, and so on.

00:48:19.434 --> 00:48:22.701
Some are pure Python,
some are coded in C.

00:48:22.701 --> 00:48:24.467
The application engine
will support

00:48:24.467 --> 00:48:30.000
any pure Python module
and most C-coded modules

00:48:30.000 --> 00:48:31.734
that are part
of the standard library.

00:48:31.734 --> 00:48:33.868
There are specific limitations

00:48:33.868 --> 00:48:38.334
that will be covered
in the App Engine sessions.

00:48:38.334 --> 00:48:41.434
App Engine does not
allow you to do threads,

00:48:41.434 --> 00:48:44.067
does not allow you
to do sockets.

00:48:44.067 --> 00:48:45.834
That's not because
they're encoded in C,

00:48:45.834 --> 00:48:50.634
it's because of its very
specific execution model.

00:48:50.634 --> 00:48:54.234
Moreover, App Engine will add
some specific APIs

00:48:54.234 --> 00:48:58.234
such as datastore, users,
urlfetch, mail,

00:48:58.234 --> 00:49:02.567
and will support any pure
Python module you use.

00:49:02.567 --> 00:49:06.100
You just put as part
of your App Engine application

00:49:06.100 --> 00:49:13.067
any dot py that doesn't use
anything except other dot pys,

00:49:13.067 --> 00:49:14.033
and you'll be fine.

00:49:14.033 --> 00:49:15.868
It will be supported.

00:49:15.868 --> 00:49:19.167
But back
to the standard library,

00:49:19.167 --> 00:49:22.367
the standard library is
so much larger than language

00:49:22.367 --> 00:49:24.801
that the time it takes
for an expert programmer

00:49:24.801 --> 00:49:29.734
to master Python the language
is maybe a couple of days.

00:49:29.734 --> 00:49:31.534
Unfortunately,
when he's done that,

00:49:31.534 --> 00:49:33.234
he's still got
a lot of work to do

00:49:33.234 --> 00:49:36.534
because he probably wants
to know the built-ins

00:49:36.534 --> 00:49:38.367
and the special methods,

00:49:38.367 --> 00:49:41.934
and the metaprogramming
introspection and so on

00:49:41.934 --> 00:49:44.267
and that takes another
say three days.

00:49:44.267 --> 00:49:46.701
Good, but now he needs
to get started

00:49:46.701 --> 00:49:48.267
with a standard library.

00:49:48.267 --> 00:49:51.234
Out of the 200 modules,
there's maybe 20 or 30

00:49:51.234 --> 00:49:53.300
which are an absolute must

00:49:53.300 --> 00:49:58.567
and those will take another
10 days or a bit more.

00:49:58.567 --> 00:49:59.868
And when those are done,

00:49:59.868 --> 00:50:02.701
to really claim
they've mastered Python

00:50:02.701 --> 00:50:04.801
as opposed
to the Python language,

00:50:04.801 --> 00:50:07.334
they probably really want
to have a pretty good idea

00:50:07.334 --> 00:50:09.501
of what's everywhere
in the standard library

00:50:09.501 --> 00:50:13.100
that's longer than
all of the above.

00:50:13.100 --> 00:50:15.834
And when they're done
with all this,

00:50:15.834 --> 00:50:21.934
well, there's
third-party offerings.

00:50:21.934 --> 00:50:24.267
I don't know how familiar
you are with Monty Python,

00:50:24.267 --> 00:50:27.634
in honor of which
Python the language is named.

00:50:27.634 --> 00:50:31.801
This is a scene
from their cheese shop sketch,

00:50:31.801 --> 00:50:34.501
which I strongly recommend.

00:50:34.501 --> 00:50:39.000
Cheeseshop dot python dot org
is a little bit less green,

00:50:39.000 --> 00:50:43.767
but better supplies
than this cheese shop.

00:50:43.767 --> 00:50:46.200
It's got 4,000 packages
and counting,

00:50:46.200 --> 00:50:50.167
but I've given up
on printing the exact name

00:50:50.167 --> 00:50:51.701
because whatever
I looked up yesterday

00:50:51.701 --> 00:50:53.767
would probably already
be false today.

00:50:53.767 --> 00:50:57.200
There's more than one package
being added every day.

00:50:57.200 --> 00:50:58.667
It's always fun
to roll your own.

00:50:58.667 --> 00:51:01.167
I mean,
if we're programmers,

00:51:01.167 --> 00:51:02.501
it is because
we like to program.

00:51:02.501 --> 00:51:08.167
Say I need this functionality,
I'll roll my own.

00:51:08.167 --> 00:51:10.501
Unfortunately, that's not
a very professional attitude.

00:51:10.501 --> 00:51:14.067
You probably want to see
who else already spent

00:51:14.067 --> 00:51:17.267
person-years of effort
into doing this,

00:51:17.267 --> 00:51:20.801
and this is likely to be
on the cheese shop.

00:51:20.801 --> 00:51:24.267
How long does it take
to learn all 4,000 packages?

00:51:24.267 --> 00:51:25.567
Well, I have no idea.

00:51:25.567 --> 00:51:28.567
I suspect that if you
put yourself to it,

00:51:28.567 --> 00:51:31.567
by the time you're finished
there will be 4,000 more,

00:51:31.567 --> 00:51:33.934
so you'd never be finished.

00:51:33.934 --> 00:51:38.801
So, I have no real suggestion
here except ask around.

00:51:38.801 --> 00:51:44.234
Go to the mailing list
or go to the usenet group

00:51:44.234 --> 00:51:46.634
and just ask,
"I need to do this and that.

00:51:46.634 --> 00:51:48.968
Is there some good module
you could recommend?"

00:51:48.968 --> 00:51:50.767
You'll probably get
several recommendations.

00:51:50.767 --> 00:51:53.467
That's still a lot of work
for you to pick the best one,

00:51:53.467 --> 00:51:55.467
but better than nothing.

00:51:55.467 --> 00:52:00.267
Remember, online resources,
don't forget those.

00:52:00.267 --> 00:52:01.300
They're all great.

00:52:01.300 --> 00:52:03.200
You really need that

00:52:03.200 --> 00:52:06.767
to do really good work
in Python.

00:52:06.767 --> 00:52:10.167
And here we are.

00:52:10.167 --> 00:52:12.167
We're ready
for questions and answers.

00:52:12.167 --> 00:52:16.934
We've got about eight minutes,
so I can field quite a few.

00:52:16.934 --> 00:52:21.601
If you can please walk
to the mic in the corridor

00:52:21.601 --> 00:52:23.734
and speak your question
in the mic.

00:52:30.434 --> 00:52:33.067
man: One question.

00:52:33.067 --> 00:52:35.634
Google is hosting
Dojo and jQuery,

00:52:35.634 --> 00:52:36.834
the JavaScript libraries.

00:52:36.834 --> 00:52:38.534
Martelli: I'm sorry?

00:52:38.534 --> 00:52:42.334
man: Google is right now hosting
for JavaScript development--

00:52:42.334 --> 00:52:44.434
Martelli: I can barely--
There's a lot of--

00:52:44.434 --> 00:52:45.434
man: Is this better?

00:52:45.434 --> 00:52:46.434
Martelli: Yes, please.

00:52:46.434 --> 00:52:47.634
man: Okay.

00:52:47.634 --> 00:52:50.300
Google is hosting
some JavaScript libraries

00:52:50.300 --> 00:52:52.267
that you can load
directly from Google

00:52:52.267 --> 00:52:55.400
like jQuery and Dojo
and so forth.

00:52:55.400 --> 00:52:58.133
I wonder if there's plans
for hosting

00:52:58.133 --> 00:53:02.033
the stack of third-party
modules from Python

00:53:02.033 --> 00:53:03.334
that you can pull directly?

00:53:03.334 --> 00:53:04.934
Martelli: The reason
it makes sense--

00:53:04.934 --> 00:53:07.467
I'm not a JavaScript expert,
but I believe

00:53:07.467 --> 00:53:11.067
that the JavaScript libraries
you require, you mentioned,

00:53:11.067 --> 00:53:16.000
would typically be mentioned
in another JavaScript file

00:53:16.000 --> 00:53:18.367
or a web page
and having a url,

00:53:18.367 --> 00:53:20.634
at which there's certain
to be some use.

00:53:20.634 --> 00:53:22.601
Python doesn't work
like that.

00:53:22.601 --> 00:53:27.100
Python doesn't load
code transparently

00:53:27.100 --> 00:53:29.367
from across the web.

00:53:29.367 --> 00:53:31.400
You put your code
right there.

00:53:31.400 --> 00:53:36.200
So, there's a lot of hosting
of open source code

00:53:36.200 --> 00:53:39.067
that we do
at code.google.com,

00:53:39.067 --> 00:53:40.968
but that's something
you download

00:53:40.968 --> 00:53:43.634
and integrate
with your programs.

00:53:43.634 --> 00:53:46.033
It doesn't live
at any specific url

00:53:46.033 --> 00:53:49.033
because that basically would
serve no useful purposes.

00:53:49.033 --> 00:53:50.267
man: Yeah, I know.

00:53:50.267 --> 00:53:51.834
I just thought it would
be a cool idea, sorry.

00:53:55.534 --> 00:53:57.200
Second man: I see a lot 
of similarities

00:53:57.200 --> 00:53:59.868
between Python and Ruby,

00:53:59.868 --> 00:54:01.434
and I'm wondering
what you think are

00:54:01.434 --> 00:54:04.234
the major distinctions
between the two languages?

00:54:04.234 --> 00:54:07.567
Martelli: You could look
for my name

00:54:07.567 --> 00:54:09.234
and the words
Ruby and Python,

00:54:09.234 --> 00:54:11.434
and you'll find
about half a dozen places

00:54:11.434 --> 00:54:14.200
where I've written
pretty long essays.

00:54:14.200 --> 00:54:18.334
But to summarize,
if I was doing a spanning tree

00:54:18.334 --> 00:54:23.834
on the dag of distances
of programming languages,

00:54:23.834 --> 00:54:27.267
I think the first two qualities
as being the closest

00:54:27.267 --> 00:54:28.834
would be Ruby and Python.

00:54:28.834 --> 00:54:31.100
From the point of view of
just about anybody experienced

00:54:31.100 --> 00:54:33.267
in just about
any other languages,

00:54:33.267 --> 00:54:34.567
they're closer

00:54:34.567 --> 00:54:38.133
than any two other languages
could possibly be.

00:54:38.133 --> 00:54:44.300
My favorite, being Italian,
is that they're like

00:54:44.300 --> 00:54:48.033
spaghettini
and capelli d'angelo.

00:54:48.033 --> 00:54:51.868
Yes, I could explain
the difference.

00:54:51.868 --> 00:54:53.934
It's gonna be hard
if you're not Italian,

00:54:53.934 --> 00:54:55.033
but I could.

00:54:55.033 --> 00:54:57.901
Like whether
the microscopical round

00:54:57.901 --> 00:55:00.300
are rounded or squared,

00:55:00.300 --> 00:55:03.267
but in practice,
if you're eating them,

00:55:03.267 --> 00:55:05.133
I challenge you
to tell the difference

00:55:05.133 --> 00:55:07.200
unless you're Italian,
in which case you can.

00:55:07.200 --> 00:55:08.467
But it's like
in the genes.

00:55:08.467 --> 00:55:10.267
Second man chuckling:
So, I guess my question--

00:55:10.267 --> 00:55:13.300
Martelli:
So, they're so similar.

00:55:13.300 --> 00:55:15.467
You can dwell
on the differences,

00:55:15.467 --> 00:55:17.567
but why?

00:55:17.567 --> 00:55:20.400
In terms
of practical consideration,

00:55:20.400 --> 00:55:22.634
Python is much more mature,

00:55:22.634 --> 00:55:26.534
so the implementation are
of a much higher quality

00:55:26.534 --> 00:55:28.934
because they've been around
so much longer

00:55:28.934 --> 00:55:31.901
and Ruby's very fashionable.

00:55:31.901 --> 00:55:34.601
So, do you want something
solid and working

00:55:34.601 --> 00:55:38.334
or do you want something
that's, like,

00:55:38.334 --> 00:55:41.667
in the news
and top of fashion?

00:55:41.667 --> 00:55:42.667
Your pick.

00:55:42.667 --> 00:55:44.067
[audience laughing]

00:55:44.067 --> 00:55:46.868
I'm an engineer.
I want solid working stuff.

00:55:46.868 --> 00:55:51.734
Somebody who'd rather be cool
can make a different choice.

00:55:51.734 --> 00:55:55.834
Second man: Are rails and jango
also sort of analogs?

00:55:55.834 --> 00:55:57.701
Martelli: Yes,
except in this case

00:55:57.701 --> 00:55:59.400
rails has been
around longer.

00:55:59.400 --> 00:56:06.601
So, in this case, rails is
more mature than jango.

00:56:06.601 --> 00:56:07.801
Jango's getting there,

00:56:07.801 --> 00:56:13.300
but it's not quite as rich
as rails is.

00:56:13.300 --> 00:56:14.534
Second man: Thank you.

00:56:14.534 --> 00:56:17.701
Martelli: Mm-hmm.

00:56:17.701 --> 00:56:20.400
Third man: How much of this
would we have to unlearn

00:56:20.400 --> 00:56:22.601
when Python 3 comes out?

00:56:22.601 --> 00:56:27.567
Martelli: [sighs]
So, I did specifically mention

00:56:27.567 --> 00:56:30.267
that you can finally
unlearn the distinction

00:56:30.267 --> 00:56:34.667
between plain strings
and unicode strings.

00:56:34.667 --> 00:56:37.067
Just about everything else
I mentioned

00:56:37.067 --> 00:56:40.467
is still true
in Python 3.

00:56:40.467 --> 00:56:44.567
Python 3 removes
a lot of stuff

00:56:44.567 --> 00:56:48.334
that has to be kept around
for backwards compatibility

00:56:48.334 --> 00:56:53.067
because as long as we're talking
about Python 2-dot-something,

00:56:53.067 --> 00:56:56.100
well, it has
to keep compatibility.

00:56:56.100 --> 00:56:58.901
That's a constraint
we gave ourselves.

00:56:58.901 --> 00:57:00.501
Python 3 can
break compatibility

00:57:00.501 --> 00:57:03.968
and therefore can eliminate
redundant ways to do things

00:57:03.968 --> 00:57:05.934
that you don't
really need anymore.

00:57:05.934 --> 00:57:09.767
You do have--I did mention
the next gains

00:57:09.767 --> 00:57:13.767
double-underscores
before and after,

00:57:13.767 --> 00:57:15.334
that's about it.

00:57:15.334 --> 00:57:18.467
Third man: Well, I've heard
that very simple programs

00:57:18.467 --> 00:57:21.467
like
the "Hello World" program--

00:57:21.467 --> 00:57:23.100
Martelli: Oh, yeah,
print becomes a function

00:57:23.100 --> 00:57:24.601
instead
of a statement, right,

00:57:24.601 --> 00:57:25.901
so you'd need
parentheses then.

00:57:25.901 --> 00:57:28.133
Third man:
Okay. All right.

00:57:28.133 --> 00:57:31.567
Martelli: Pretty simple.

00:57:31.567 --> 00:57:32.834
Fourth man: So, you mentioned

00:57:32.834 --> 00:57:36.968
that monkey patching
is considered bad, but--

00:57:36.968 --> 00:57:38.300
Martelli: By some,

00:57:38.300 --> 00:57:41.801
and it's considered wonderful
by others and--

00:57:41.801 --> 00:57:46.634
Fourth man:
In the Python community,

00:57:46.634 --> 00:57:48.367
I guess you in particular
have an issue

00:57:48.367 --> 00:57:51.501
with monkey patching,
but not directly assigning

00:57:51.501 --> 00:57:54.467
to a module to add
additional functionality.

00:57:54.467 --> 00:57:58.367
Is there a fundamental
difference there

00:57:58.367 --> 00:58:02.300
that you see or--

00:58:02.300 --> 00:58:04.434
Martelli: Fundamental difference
between what and what?

00:58:04.434 --> 00:58:06.234
Fourth man:
Between monkey patching

00:58:06.234 --> 00:58:10.334
and directly assigning
to a module?

00:58:10.334 --> 00:58:12.434
Um, or are they--

00:58:12.434 --> 00:58:13.567
From my point of view,
they're both--

00:58:13.567 --> 00:58:15.434
Martelli: Assigning--
assigning--

00:58:15.434 --> 00:58:18.200
modifying a module
from outside

00:58:18.200 --> 00:58:19.734
is monkey patching.

00:58:19.734 --> 00:58:22.901
That's my definition
of monkey patching.

00:58:22.901 --> 00:58:24.167
Fourth man: I guess,
in particular,

00:58:24.167 --> 00:58:27.100
is there a reason that one
is a useful feature

00:58:27.100 --> 00:58:32.667
of the language and one
is something to avoid?

00:58:32.667 --> 00:58:36.067
Martelli: Mm, I--
It's useful

00:58:36.067 --> 00:58:43.033
to be able to fix bugs
without editing the buggy code,

00:58:43.033 --> 00:58:46.868
but it's not something
that you should need to do

00:58:46.868 --> 00:58:48.767
in the long run
in production.

00:58:48.767 --> 00:58:51.267
I'd much rather
fix the code,

00:58:51.267 --> 00:58:53.801
edit the source code
and fix it.

00:58:53.801 --> 00:58:55.367
Fourth man: Okay, thank you.

00:58:59.067 --> 00:59:00.334
Fifth man: Are there any plans

00:59:00.334 --> 00:59:03.133
to formally support
the notion of interfaces?

00:59:03.133 --> 00:59:04.534
I know frameworks like--

00:59:04.534 --> 00:59:10.334
Martelli: Python 3 has
a standard library module

00:59:10.334 --> 00:59:13.367
called Abstract Base Classes,
ABC,

00:59:13.367 --> 00:59:17.667
which is more powerful
than interfaces in some way,

00:59:17.667 --> 00:59:22.067
although some people think
it's less powerful than others.

00:59:22.067 --> 00:59:25.000
That's basically what
we'll have as part

00:59:25.000 --> 00:59:27.234
of the standard library.

00:59:27.234 --> 00:59:29.701
Otherwise, you can get
third-party packages

00:59:29.701 --> 00:59:31.467
which support
interfaces strictly,

00:59:31.467 --> 00:59:32.868
but there's some stuff

00:59:32.868 --> 00:59:35.501
that adds absolutely
no functionality,

00:59:35.501 --> 00:59:38.100
but it makes
you look good.

00:59:38.100 --> 00:59:39.467
Fifth man: Is this
somehow at odds

00:59:39.467 --> 00:59:45.300
with the idea that
you want to trust programmers?

00:59:45.300 --> 00:59:49.100
Martelli: No,
actually it's--it's--

00:59:49.100 --> 00:59:52.434
There's nothing against
trusting programmers

00:59:52.434 --> 00:59:55.067
and letting people use
abstract base classes.

00:59:55.067 --> 00:59:59.334
The point is eliminate
some redundancy.

00:59:59.334 --> 01:00:03.033
An interface per se
is a structural--

01:00:03.033 --> 01:00:04.601
well, a way
to structure your stuff.

01:00:04.601 --> 01:00:06.367
It doesn't really eliminate
much redundancy.

01:00:06.367 --> 01:00:08.133
So, I'd normally rather--

01:00:08.133 --> 01:00:11.701
I mean, if you look at some
of the ABCs in Python 3.0,

01:00:11.701 --> 01:00:13.300
they don't actually
use the ability

01:00:13.300 --> 01:00:14.567
to add functionality.

01:00:14.567 --> 01:00:18.300
They work as if
they were interfaces, so...

01:00:18.300 --> 01:00:19.767
And you can use--

01:00:19.767 --> 01:00:21.767
So, basically, instead
of just having one way

01:00:21.767 --> 01:00:25.200
when you're asking me
is something a container,

01:00:25.200 --> 01:00:27.501
I can tell you,
well, it is a container

01:00:27.501 --> 01:00:32.434
if and only if
it matches the container

01:00:32.434 --> 01:00:35.133
of such base classes,
that kind of thing.

01:00:35.133 --> 01:00:36.567
Fifth man: Thanks.

01:00:36.567 --> 01:00:37.567
woman: We're out of time.

01:00:37.567 --> 01:00:40.801
Martelli: Okay. Sorry.

01:00:40.801 --> 01:00:43.200
Right, so we're done.
Thank you very much.

01:00:43.200 --> 01:00:45.567
[audience applauding]

