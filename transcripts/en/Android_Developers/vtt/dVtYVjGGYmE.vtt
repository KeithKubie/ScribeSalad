WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.437
[MUSIC PLAYING]

00:00:07.860 --> 00:00:10.620
DAVE SMITH: Well, good
afternoon, everybody.

00:00:10.620 --> 00:00:11.660
Oh, come on.

00:00:11.660 --> 00:00:12.702
I got nothing?

00:00:12.702 --> 00:00:13.785
Good afternoon, everybody!

00:00:13.785 --> 00:00:14.760
[APPLAUSE]

00:00:14.760 --> 00:00:15.690
There we go.

00:00:15.690 --> 00:00:17.550
There we go.

00:00:17.550 --> 00:00:19.800
Well, thank you so much for
spending your time with me

00:00:19.800 --> 00:00:20.500
today.

00:00:20.500 --> 00:00:21.570
My name is Dave Smith.

00:00:21.570 --> 00:00:23.220
I'm a Developer
Advocate here at Google

00:00:23.220 --> 00:00:25.329
working on the Android
Things platform.

00:00:25.329 --> 00:00:27.870
And I'm here today to talk to
you a little bit about building

00:00:27.870 --> 00:00:30.120
apps for the Android
Things platform

00:00:30.120 --> 00:00:32.189
and how you can be more
effective in the apps

00:00:32.189 --> 00:00:34.650
that you build using
the Android SDK.

00:00:34.650 --> 00:00:37.080
So whether you're new to
Android or whether you've

00:00:37.080 --> 00:00:39.300
been building Android
apps since the beginning,

00:00:39.300 --> 00:00:41.612
targeting Android
Things devices--

00:00:41.612 --> 00:00:44.070
it has some subtle differences
from what you may or may not

00:00:44.070 --> 00:00:46.170
be used to in
working with Android.

00:00:46.170 --> 00:00:48.000
Understanding these
differences is

00:00:48.000 --> 00:00:49.470
what will ensure
that you can build

00:00:49.470 --> 00:00:51.540
better apps on the platform.

00:00:51.540 --> 00:00:53.670
But before we jump
into too much of that,

00:00:53.670 --> 00:00:56.460
let me just do a quick overview
of what Android Things is,

00:00:56.460 --> 00:00:58.380
maybe for the uninitiated.

00:00:58.380 --> 00:01:01.110
So Android Things is a
fully-managed platform

00:01:01.110 --> 00:01:03.780
for building connected
devices at scale.

00:01:03.780 --> 00:01:05.550
It's a variant of
the Android platform

00:01:05.550 --> 00:01:08.430
that is optimized for
use in embedded devices.

00:01:08.430 --> 00:01:10.830
It enables you to
build apps for embedded

00:01:10.830 --> 00:01:14.340
in IoT using the same
Android SDK and Google Play

00:01:14.340 --> 00:01:17.280
services that you use to
build for [INAUDIBLE] mobile.

00:01:17.280 --> 00:01:20.130
You can develop apps using the
same tools, such as Android

00:01:20.130 --> 00:01:24.990
Studio, to deploy and debug
your apps to devices as well.

00:01:24.990 --> 00:01:27.870
It includes the Android
Things Developer Console.

00:01:27.870 --> 00:01:30.210
This is a place where
you can securely

00:01:30.210 --> 00:01:33.060
manage your software
stability and security

00:01:33.060 --> 00:01:35.200
updates for your devices.

00:01:35.200 --> 00:01:38.430
You simply upload your
apps, choose the OS version

00:01:38.430 --> 00:01:40.710
that you want to
run on your device,

00:01:40.710 --> 00:01:44.400
and then deploy those updates
to those devices over the air.

00:01:44.400 --> 00:01:47.220
Security updates are even
deployed automatically

00:01:47.220 --> 00:01:50.070
to those devices for you.

00:01:50.070 --> 00:01:53.370
Android Things also
supports powerful hardware

00:01:53.370 --> 00:01:56.130
that's suitable for edge
computing and production,

00:01:56.130 --> 00:01:59.220
capable of driving artificial
intelligence and machine

00:01:59.220 --> 00:02:01.530
learning out to the edge.

00:02:01.530 --> 00:02:05.100
This hardware is packaged
into system-on modules that

00:02:05.100 --> 00:02:06.726
make it easy for
you to integrate

00:02:06.726 --> 00:02:08.184
into your final
production designs.

00:02:10.979 --> 00:02:12.960
So when you look at all
these things together,

00:02:12.960 --> 00:02:15.300
the process is a little
bit different than when

00:02:15.300 --> 00:02:17.520
you were building apps
on a mobile device.

00:02:17.520 --> 00:02:19.680
Building a typical app
for Android devices

00:02:19.680 --> 00:02:22.230
means distributing a
single app binary--

00:02:22.230 --> 00:02:24.780
through the Google
Play Store, typically.

00:02:24.780 --> 00:02:29.580
Apps have to work on multiple
devices made by multiple OEMs

00:02:29.580 --> 00:02:33.030
targeting multiple versions of
the Android operating system,

00:02:33.030 --> 00:02:35.670
typically requiring you to
do various compatibility

00:02:35.670 --> 00:02:37.590
checks and other things
like that to make sure

00:02:37.590 --> 00:02:40.320
that your app runs well
across that entire breadth

00:02:40.320 --> 00:02:42.210
of the ecosystem.

00:02:42.210 --> 00:02:45.510
With Android Things,
you are the device OEM.

00:02:45.510 --> 00:02:47.970
You control when the
OS on your device

00:02:47.970 --> 00:02:50.130
gets upgraded, and
the various apps that

00:02:50.130 --> 00:02:53.190
are bundled into that
system image along with it.

00:02:53.190 --> 00:02:56.610
And you do all of this through
the Android Things Console

00:02:56.610 --> 00:02:58.950
instead of through
the Google Play Store.

00:02:58.950 --> 00:03:01.650
This can greatly
simplify your code,

00:03:01.650 --> 00:03:03.330
because you don't
need to incorporate

00:03:03.330 --> 00:03:05.820
a lot of those same
compatibility checks.

00:03:05.820 --> 00:03:08.430
But there are some things
to consider that are going

00:03:08.430 --> 00:03:10.150
to be a little bit different.

00:03:10.150 --> 00:03:12.600
Let's start with displays.

00:03:12.600 --> 00:03:15.090
In Android Things,
displays are optional.

00:03:15.090 --> 00:03:19.140
They're supported, and you can
use the full Android UI toolkit

00:03:19.140 --> 00:03:22.140
to build applications
that have a Graphical User

00:03:22.140 --> 00:03:25.620
Interface, whether it's
touch-enabled or not.

00:03:25.620 --> 00:03:28.650
But we've removed a lot
of the default system UI

00:03:28.650 --> 00:03:31.500
and disabled or reworked
some of the APIs

00:03:31.500 --> 00:03:33.840
that assume that
graphical displays are

00:03:33.840 --> 00:03:36.720
in place, because many
IoT devices will not

00:03:36.720 --> 00:03:38.580
have these pieces,
and we don't want

00:03:38.580 --> 00:03:40.650
to place those
requirements in there.

00:03:40.650 --> 00:03:44.910
The best example of this in
practice is App Permissions.

00:03:44.910 --> 00:03:47.040
So in Android
Things, permissions

00:03:47.040 --> 00:03:50.790
are not granted at
runtime by the end user,

00:03:50.790 --> 00:03:53.430
because we can't assume that
there's a graphical display

00:03:53.430 --> 00:03:55.430
to show things like this dialog.

00:03:55.430 --> 00:03:58.290
And we can't even really
assume that user granting

00:03:58.290 --> 00:04:03.250
specific types of permissions is
appropriate for an IoT device.

00:04:03.250 --> 00:04:06.150
So instead, these
permissions are actually

00:04:06.150 --> 00:04:09.330
granted by you, the developer,
using the Android Things

00:04:09.330 --> 00:04:10.620
Console, OK?

00:04:10.620 --> 00:04:13.380
So as the owner of
your device, you're

00:04:13.380 --> 00:04:16.376
responsible for taking
control of the apps that

00:04:16.376 --> 00:04:18.000
run on this device,
and the permissions

00:04:18.000 --> 00:04:22.290
that those particular
applications have, OK?

00:04:22.290 --> 00:04:24.690
Now, because of
this, permissions

00:04:24.690 --> 00:04:28.140
may not be granted by end users.

00:04:28.140 --> 00:04:29.760
So that means you
don't necessarily

00:04:29.760 --> 00:04:32.700
have to check whether or not
those permissions were grant--

00:04:32.700 --> 00:04:34.950
or you don't have to request
for those permissions

00:04:34.950 --> 00:04:36.510
to be granted at runtime.

00:04:36.510 --> 00:04:39.570
But since they are still
granted dynamically,

00:04:39.570 --> 00:04:41.490
the best practice is
still for your code

00:04:41.490 --> 00:04:45.390
to verify that you have
that permission, OK?

00:04:45.390 --> 00:04:47.220
Because that
permission could have

00:04:47.220 --> 00:04:49.994
been revoked by one
of the console users,

00:04:49.994 --> 00:04:51.660
and you don't want
your application code

00:04:51.660 --> 00:04:54.250
to behave improperly
in those cases.

00:04:54.250 --> 00:04:56.100
So you'll still
want to have checks

00:04:56.100 --> 00:04:58.860
like this one in your code
when you are accessing

00:04:58.860 --> 00:05:01.830
dangerous permissions that
could be granted or revoked

00:05:01.830 --> 00:05:04.080
by the console,
but you won't have

00:05:04.080 --> 00:05:06.840
to include the code that
requests those permissions

00:05:06.840 --> 00:05:09.420
upfront from the end user.

00:05:09.420 --> 00:05:12.210
Not doing this will result in
the same security exception

00:05:12.210 --> 00:05:14.070
that you would
otherwise see by trying

00:05:14.070 --> 00:05:16.909
to access those protected
permissions if, in fact,

00:05:16.909 --> 00:05:18.075
that permission is disabled.

00:05:20.680 --> 00:05:23.530
Additionally, in
Android Things 1.0,

00:05:23.530 --> 00:05:26.560
permissions are no longer
granted automatically

00:05:26.560 --> 00:05:27.439
on reboot.

00:05:27.439 --> 00:05:29.980
This is something that we did
in some of the earlier previews

00:05:29.980 --> 00:05:31.820
and is no longer the case.

00:05:31.820 --> 00:05:33.550
So that means that
as a developer,

00:05:33.550 --> 00:05:35.977
you can't simply just
reboot your device

00:05:35.977 --> 00:05:37.810
to try and get all those
permissions brought

00:05:37.810 --> 00:05:39.430
into your app automatically.

00:05:39.430 --> 00:05:42.520
You have to actually use the
tooling to make that happen.

00:05:42.520 --> 00:05:44.770
So during development, what
you're going to want to do

00:05:44.770 --> 00:05:48.700
is provide the -g flag when
installing the applications

00:05:48.700 --> 00:05:50.020
on your device.

00:05:50.020 --> 00:05:52.600
And this will grant all
the permissions requested

00:05:52.600 --> 00:05:57.040
by your app by default.
Android Studio actually

00:05:57.040 --> 00:05:59.000
does this for you automatically.

00:05:59.000 --> 00:06:01.840
So whenever you click Build
and Run out of the IDE,

00:06:01.840 --> 00:06:04.039
this process is taken
care of for you.

00:06:04.039 --> 00:06:06.080
But if you want to do this
from the command line,

00:06:06.080 --> 00:06:08.410
you're going to have to
add that flag yourself.

00:06:08.410 --> 00:06:11.650
Another option is to use the
[? pm ?] [? (grant) ?] command

00:06:11.650 --> 00:06:16.120
to individually grant or
revoke permissions inside

00:06:16.120 --> 00:06:17.510
of your application.

00:06:17.510 --> 00:06:19.360
You can do this
during development,

00:06:19.360 --> 00:06:22.570
or maybe just to test what
the individual behavior is

00:06:22.570 --> 00:06:24.490
of a certain
permission if you deny

00:06:24.490 --> 00:06:28.090
that inside of your application.

00:06:28.090 --> 00:06:30.490
If you prefer to use
the Gradle command line,

00:06:30.490 --> 00:06:32.920
or perhaps you're running
automated tests or other things

00:06:32.920 --> 00:06:35.140
where the IDE is
not involved, you

00:06:35.140 --> 00:06:38.260
can actually add this to
your build.gradle file using

00:06:38.260 --> 00:06:42.910
an adbOptions block to apply
that same -g flag any time

00:06:42.910 --> 00:06:46.610
your application is installed.

00:06:46.610 --> 00:06:49.250
Speaking of UI, we should
probably talk a little bit

00:06:49.250 --> 00:06:50.960
about activities.

00:06:50.960 --> 00:06:53.390
Most developers think that
activities are essentially

00:06:53.390 --> 00:06:54.530
screens.

00:06:54.530 --> 00:06:58.730
So if we remove displays, why
do we need to keep them around?

00:06:58.730 --> 00:07:00.980
And it turns out that
activities are a little bit more

00:07:00.980 --> 00:07:01.760
than that.

00:07:01.760 --> 00:07:03.650
An activity
represents a component

00:07:03.650 --> 00:07:05.770
of user focus in Android.

00:07:05.770 --> 00:07:08.240
For devices with
graphical displays,

00:07:08.240 --> 00:07:11.330
that does mean that it will
render the contents of the view

00:07:11.330 --> 00:07:13.040
onto the window.

00:07:13.040 --> 00:07:15.740
But even for devices
without displays,

00:07:15.740 --> 00:07:19.290
activities also handle all
of the user input events,

00:07:19.290 --> 00:07:21.350
whether that's coming from
a touch screen input--

00:07:21.350 --> 00:07:24.170
or maybe it's a game
controller or a keyboard--

00:07:24.170 --> 00:07:25.880
or any other
external input device

00:07:25.880 --> 00:07:27.530
that you may have connected.

00:07:27.530 --> 00:07:30.500
All of those events are going to
be delivered to the foreground

00:07:30.500 --> 00:07:31.860
activity.

00:07:31.860 --> 00:07:34.550
So even without a
graphical display,

00:07:34.550 --> 00:07:37.850
activities are still a
very important portion

00:07:37.850 --> 00:07:41.120
of Android user interface,
even though the user interface

00:07:41.120 --> 00:07:45.170
might not actually
include the Graphical UI.

00:07:45.170 --> 00:07:46.640
It's important to
note, also, when

00:07:46.640 --> 00:07:49.550
we're talking about activities
that activities are still

00:07:49.550 --> 00:07:52.430
vulnerable to configuration
changes the same way

00:07:52.430 --> 00:07:54.170
that they are on Android.

00:07:54.170 --> 00:07:56.060
So as an Android
developer, you're

00:07:56.060 --> 00:07:58.250
probably used to, at
least at some point,

00:07:58.250 --> 00:08:01.340
having to deal with an
orientation change of a device

00:08:01.340 --> 00:08:03.080
and having that
destroy your activity

00:08:03.080 --> 00:08:05.270
and recreate a new
instance of it.

00:08:05.270 --> 00:08:07.970
That's effectively a very
common configuration change

00:08:07.970 --> 00:08:09.680
on Android mobile devices.

00:08:09.680 --> 00:08:12.500
While on Android Things,
that specific instance

00:08:12.500 --> 00:08:14.180
probably is not very common--

00:08:14.180 --> 00:08:16.040
if it would happen at all--

00:08:16.040 --> 00:08:18.620
there are still a number of
other configuration changes

00:08:18.620 --> 00:08:21.600
that might still happen
on Android Things devices.

00:08:21.600 --> 00:08:23.990
Things like changing
the default locale

00:08:23.990 --> 00:08:26.750
or connecting or
disconnecting a keyboard--

00:08:26.750 --> 00:08:29.180
a physical keyboard--
from the device.

00:08:29.180 --> 00:08:32.929
All of these events
have the same net effect

00:08:32.929 --> 00:08:36.230
in that that activity will
be destroyed and recreated

00:08:36.230 --> 00:08:38.580
if it happens to be
in the foreground.

00:08:38.580 --> 00:08:41.030
So generally speaking, if
you're working with activities

00:08:41.030 --> 00:08:43.610
on Android Things,
the same rules

00:08:43.610 --> 00:08:46.460
apply to activities
in terms of the logic

00:08:46.460 --> 00:08:48.650
that you put into
those components.

00:08:48.650 --> 00:08:51.020
They're effectively
just as fragile in terms

00:08:51.020 --> 00:08:52.340
of their lifecycle.

00:08:52.340 --> 00:08:55.880
So you're only going to want to
have view-based logic or user

00:08:55.880 --> 00:08:58.820
interface-based logic
inside of these activities.

00:08:58.820 --> 00:09:01.730
Try not to put too
much additional state

00:09:01.730 --> 00:09:02.780
into these components.

00:09:02.780 --> 00:09:04.321
You're going to want
to push that out

00:09:04.321 --> 00:09:07.430
into other parts of
your application.

00:09:07.430 --> 00:09:09.500
Android Things even
uses activities

00:09:09.500 --> 00:09:12.260
to launch your
primary application

00:09:12.260 --> 00:09:14.090
as part of the boot process.

00:09:14.090 --> 00:09:16.340
We do this using the
HOME intent, which

00:09:16.340 --> 00:09:19.220
is the same intent that's used
to trigger the App Launcher

00:09:19.220 --> 00:09:21.230
on an Android mobile device.

00:09:21.230 --> 00:09:24.440
This intent starts your
app automatically on boot--

00:09:24.440 --> 00:09:28.100
and specifically the activity
inside of that application--

00:09:28.100 --> 00:09:30.080
started automatically on boot.

00:09:30.080 --> 00:09:32.090
And in addition to that,
if that application

00:09:32.090 --> 00:09:35.060
crashes or terminates
for any reason,

00:09:35.060 --> 00:09:39.000
Android is going to restart
that application automatically.

00:09:39.000 --> 00:09:41.360
So this becomes the
main entry point

00:09:41.360 --> 00:09:44.360
into your application that
is automatically managed

00:09:44.360 --> 00:09:47.780
by the Android Things platform.

00:09:47.780 --> 00:09:51.590
So we don't want to forget
about activities just yet.

00:09:51.590 --> 00:09:54.020
Couple other things about
Android Things devices.

00:09:54.020 --> 00:09:56.330
Android Things devices
are also relatively

00:09:56.330 --> 00:09:58.670
memory-constrained
when you compare them

00:09:58.670 --> 00:10:00.140
to an Android phone.

00:10:00.140 --> 00:10:02.590
A typical Android
Things device may have

00:10:02.590 --> 00:10:05.510
512 megabytes of RAM or so.

00:10:05.510 --> 00:10:08.144
Compare that with the
multiple gigabytes of RAM

00:10:08.144 --> 00:10:10.310
that you would have on an
Android phone-- like, say,

00:10:10.310 --> 00:10:12.770
a Pixel or a Pixel 2.

00:10:12.770 --> 00:10:15.740
What this translates to
for you, the developer

00:10:15.740 --> 00:10:19.460
is that there's actually a
much lower per-process heap

00:10:19.460 --> 00:10:22.560
size for your
individual application.

00:10:22.560 --> 00:10:25.070
So if you're not
familiar with this idea,

00:10:25.070 --> 00:10:28.640
Android sets a fixed heap level
on every application running

00:10:28.640 --> 00:10:31.310
on that device, and
it's significantly lower

00:10:31.310 --> 00:10:35.130
than the total available
memory on that device.

00:10:35.130 --> 00:10:36.950
And since the Android
Things devices

00:10:36.950 --> 00:10:39.050
are relatively
memory-constrained,

00:10:39.050 --> 00:10:41.750
that per-process limit
is significantly lower

00:10:41.750 --> 00:10:44.060
than it would be on
an Android phone.

00:10:44.060 --> 00:10:46.850
Because of that, if you're
porting code from an Android

00:10:46.850 --> 00:10:49.516
mobile device over
to Android Things,

00:10:49.516 --> 00:10:51.140
you just have to
realize that if you're

00:10:51.140 --> 00:10:53.540
using the same amount
of memory in your app,

00:10:53.540 --> 00:10:55.490
there's going to be a
lot less free memory

00:10:55.490 --> 00:10:58.490
in that same process
available to you, OK?

00:10:58.490 --> 00:11:00.150
So you have to
keep that in mind.

00:11:00.150 --> 00:11:02.540
And you also want to
realize that this can also

00:11:02.540 --> 00:11:07.010
translate into a significantly
larger amount of garbage

00:11:07.010 --> 00:11:11.030
collection events happening as
you allocate new objects, OK?

00:11:11.030 --> 00:11:14.270
So you want to keep a close
eye on object allocations,

00:11:14.270 --> 00:11:17.000
how often you're doing
object allocations.

00:11:17.000 --> 00:11:18.890
Because you may run
into that ceiling

00:11:18.890 --> 00:11:20.540
much more quickly
than you otherwise

00:11:20.540 --> 00:11:22.430
would on an Android
device, or you

00:11:22.430 --> 00:11:25.740
might see the garbage collector
kicking in quite a bit more.

00:11:25.740 --> 00:11:27.830
The Memory Profiler
in Android Studio

00:11:27.830 --> 00:11:31.190
is a really great resource to
help you keep an eye on what's

00:11:31.190 --> 00:11:32.750
going on inside your memory.

00:11:32.750 --> 00:11:35.690
It will allow you to track
those allocations over time,

00:11:35.690 --> 00:11:38.720
as well as see, overlaid into
it, the individual garbage

00:11:38.720 --> 00:11:39.920
collection events.

00:11:39.920 --> 00:11:42.410
So you can get a really
good idea of whether or not

00:11:42.410 --> 00:11:44.637
your application is
allocating too much memory

00:11:44.637 --> 00:11:45.470
and causing trouble.

00:11:47.784 --> 00:11:49.200
Some of the things
that you can do

00:11:49.200 --> 00:11:51.600
to help understand your
device a little bit better

00:11:51.600 --> 00:11:53.730
is use some of the
ActivityManager methods

00:11:53.730 --> 00:11:57.120
to do some inspection on
the memory capabilities

00:11:57.120 --> 00:11:59.230
of your particular device.

00:11:59.230 --> 00:12:02.100
So for example, you can use
the MemoryClass attribute

00:12:02.100 --> 00:12:03.390
on ActivityManager.

00:12:03.390 --> 00:12:06.240
This will give you the
exact heap size that's

00:12:06.240 --> 00:12:08.110
available to your application.

00:12:08.110 --> 00:12:10.320
The value that is returned
is the value in megabytes.

00:12:10.320 --> 00:12:12.360
That is how much
memory you have.

00:12:12.360 --> 00:12:15.690
The largeMemoryClass attribute
is what your application

00:12:15.690 --> 00:12:18.270
would have if you
added the large heap

00:12:18.270 --> 00:12:20.790
attribute to your manifest.

00:12:20.790 --> 00:12:24.690
I would caution you against
doing this on Android Things.

00:12:24.690 --> 00:12:28.500
Generally speaking, because
Android Things devices are

00:12:28.500 --> 00:12:30.720
memory-constrained,
the MemoryClass

00:12:30.720 --> 00:12:32.940
and the largeMemoryClass
of these devices

00:12:32.940 --> 00:12:35.710
are generally configured
to be the same value.

00:12:35.710 --> 00:12:37.770
So adding this attribute
to your manifest

00:12:37.770 --> 00:12:41.690
is essentially not going
to do anything, OK?

00:12:41.690 --> 00:12:45.560
You also want to inspect the low
memory threshold of this device

00:12:45.560 --> 00:12:48.020
to get a sense for what
that actually looks like.

00:12:48.020 --> 00:12:50.030
When the available
memory on the device

00:12:50.030 --> 00:12:52.670
falls below that
memory threshold,

00:12:52.670 --> 00:12:55.085
the device is in a state
that we call memory pressure.

00:12:55.085 --> 00:12:57.710
And we're going to talk a little
bit more about what that means

00:12:57.710 --> 00:12:59.420
and why it's important
in a little bit,

00:12:59.420 --> 00:13:00.794
but just keep it
in mind for now.

00:13:02.617 --> 00:13:04.200
So I want you to
notice something else

00:13:04.200 --> 00:13:06.660
about this diagram
that I had up before.

00:13:06.660 --> 00:13:08.850
Because of this
per-process heap limit

00:13:08.850 --> 00:13:11.850
that's a fixed value for
a single application,

00:13:11.850 --> 00:13:15.570
if you try to put all
of your application code

00:13:15.570 --> 00:13:19.230
into a single process
or a single APK,

00:13:19.230 --> 00:13:21.960
you're going to be severely
limited in your ability

00:13:21.960 --> 00:13:26.430
to fully utilize the memory that
is available on this device,

00:13:26.430 --> 00:13:27.000
OK?

00:13:27.000 --> 00:13:29.550
Now, keep in mind,
with Android Things,

00:13:29.550 --> 00:13:33.280
the only apps on the
device are your apps.

00:13:33.280 --> 00:13:36.450
So you should be able to take
full advantage of those memory

00:13:36.450 --> 00:13:39.610
resources as much
as you possibly can.

00:13:39.610 --> 00:13:43.690
The way to do that is to
split your application

00:13:43.690 --> 00:13:45.730
into multiple processes, OK?

00:13:45.730 --> 00:13:49.390
Because that limit essentially
will apply to each one of those

00:13:49.390 --> 00:13:50.990
processes individually.

00:13:50.990 --> 00:13:53.770
So if you can federate the
design of your application

00:13:53.770 --> 00:13:56.680
out into multiple
components that are actually

00:13:56.680 --> 00:13:58.840
running in separate
APKs, you're going

00:13:58.840 --> 00:14:02.080
to have a much better
ability to fully utilize

00:14:02.080 --> 00:14:06.810
the memory available on whatever
device that you're running.

00:14:06.810 --> 00:14:09.840
To make the most effective
use of our device,

00:14:09.840 --> 00:14:12.930
we're going to break this
app up into multiple APKs,

00:14:12.930 --> 00:14:14.520
with the primary
activity running

00:14:14.520 --> 00:14:18.660
in the foreground and additional
apps running in the background

00:14:18.660 --> 00:14:21.660
with support services
running inside.

00:14:21.660 --> 00:14:24.300
The additional benefit of
running this architecture

00:14:24.300 --> 00:14:26.880
is that it actually insulates
these various components

00:14:26.880 --> 00:14:28.150
from one another.

00:14:28.150 --> 00:14:31.140
So in this scenario,
if a crash happens

00:14:31.140 --> 00:14:35.190
in one of these components, it's
localized just to that element.

00:14:35.190 --> 00:14:37.800
And it won't bring down
your entire application

00:14:37.800 --> 00:14:41.440
and have you have to restart
all of that from the beginning.

00:14:41.440 --> 00:14:43.920
So you can manage those
individual issues just

00:14:43.920 --> 00:14:46.770
within that component and leave
the rest of the applications

00:14:46.770 --> 00:14:50.400
or components running on
your device to be unaffected.

00:14:50.400 --> 00:14:53.160
It also means that you
can launch or relaunch

00:14:53.160 --> 00:14:57.460
these components individually
as needed by your application.

00:14:57.460 --> 00:15:00.780
So if you don't need to load
everything at once at boot,

00:15:00.780 --> 00:15:03.150
you can launch various
services and components

00:15:03.150 --> 00:15:04.140
just as you need them.

00:15:06.900 --> 00:15:09.750
Now, it turns out the decision
to put some of your components

00:15:09.750 --> 00:15:13.020
into background apps has
consequences as well.

00:15:13.020 --> 00:15:15.960
Android treats foreground
and background processes

00:15:15.960 --> 00:15:17.670
a little bit
differently, and we need

00:15:17.670 --> 00:15:20.430
to be aware of what's going
on under the hood here.

00:15:20.430 --> 00:15:22.800
Android marks
application processes

00:15:22.800 --> 00:15:26.580
by priority based on how
closely they are related

00:15:26.580 --> 00:15:28.980
to the foreground application.

00:15:28.980 --> 00:15:31.980
And this is very important
because of a system process

00:15:31.980 --> 00:15:34.520
known as the low memory killer.

00:15:34.520 --> 00:15:36.390
The low memory
killer is a process

00:15:36.390 --> 00:15:38.740
that is constantly
prowling in the background,

00:15:38.740 --> 00:15:41.370
looking for new
processes to devour.

00:15:41.370 --> 00:15:45.330
Its job is to ensure that
the free memory on the system

00:15:45.330 --> 00:15:49.240
is available to the foreground
app at any given time.

00:15:49.240 --> 00:15:52.290
So if the foreground app needs
new memory and the device

00:15:52.290 --> 00:15:55.140
happens to be in a system
of memory pressure,

00:15:55.140 --> 00:15:58.560
low memory killer is going to
go hunting around for processes

00:15:58.560 --> 00:16:01.380
that it can terminate to
allocate that memory back

00:16:01.380 --> 00:16:04.320
to the foreground, OK?

00:16:04.320 --> 00:16:07.050
On an Android device-- like
a typical user-driven Android

00:16:07.050 --> 00:16:07.870
device--

00:16:07.870 --> 00:16:09.510
this can be somewhat
of a nuisance

00:16:09.510 --> 00:16:11.730
to developers, because
their app may get

00:16:11.730 --> 00:16:13.600
terminated from the background.

00:16:13.600 --> 00:16:16.020
But at some point, the user's
going to relaunch it later,

00:16:16.020 --> 00:16:18.060
and everything will be fine.

00:16:18.060 --> 00:16:20.760
On Android Things,
the low memory killer

00:16:20.760 --> 00:16:24.180
could mean that you have
critical device functionality

00:16:24.180 --> 00:16:26.910
that is being terminated
out from underneath you,

00:16:26.910 --> 00:16:28.260
and you didn't even know it.

00:16:28.260 --> 00:16:30.800
Perhaps there's a device
driver running in that service

00:16:30.800 --> 00:16:32.280
and Android killed
that because it

00:16:32.280 --> 00:16:35.910
thought it was low enough
priority in the background, OK?

00:16:35.910 --> 00:16:38.700
So something to keep in mind
as you're moving through this.

00:16:38.700 --> 00:16:42.060
In addition, Android Oreo
introduced execution limits

00:16:42.060 --> 00:16:43.720
for background apps.

00:16:43.720 --> 00:16:45.990
So applications can
no longer be started

00:16:45.990 --> 00:16:48.060
into a background state.

00:16:48.060 --> 00:16:51.090
They must either be launched
from the foreground app

00:16:51.090 --> 00:16:54.760
or bound to it in some way.

00:16:54.760 --> 00:16:56.880
So because of these
two things, there's

00:16:56.880 --> 00:16:58.410
a number of
different common ways

00:16:58.410 --> 00:17:00.660
that you may or may not
have used in the past

00:17:00.660 --> 00:17:03.585
to launch components
into the background, OK?

00:17:03.585 --> 00:17:05.710
And we're going to walk
through those a little bit.

00:17:05.710 --> 00:17:07.543
So the first that you
might be familiar with

00:17:07.543 --> 00:17:09.930
is using the
BOOT_COMPLETED broadcast

00:17:09.930 --> 00:17:13.410
to listen for a final boot
message coming from the Android

00:17:13.410 --> 00:17:15.960
framework saying that the
system is up and running,

00:17:15.960 --> 00:17:19.170
you can launch other
apps if you would like.

00:17:19.170 --> 00:17:21.599
Do not use this
on Android Things.

00:17:21.599 --> 00:17:24.450
The primary reason is because
of those background execution

00:17:24.450 --> 00:17:27.329
limits, your background
services actually

00:17:27.329 --> 00:17:30.200
can't be properly
started into that state.

00:17:30.200 --> 00:17:32.970
In a lot of cases, it
won't even work, OK?

00:17:32.970 --> 00:17:35.130
And in addition to
that, this background

00:17:35.130 --> 00:17:37.260
broadcast-- this
BOOT_COMPLETED broadcast--

00:17:37.260 --> 00:17:40.950
is very unpredictable
in terms of its timing.

00:17:40.950 --> 00:17:44.160
In a lot of cases, this
BOOT_COMPLETED broadcast

00:17:44.160 --> 00:17:46.710
actually triggers
much, much later

00:17:46.710 --> 00:17:48.870
than when the home intent
and the home activity

00:17:48.870 --> 00:17:51.714
are fully up and running
in the foreground, OK?

00:17:51.714 --> 00:17:53.880
So if you're trying to
synchronize between these two

00:17:53.880 --> 00:17:57.610
things, it's not a very
good mechanism to rely on.

00:17:57.610 --> 00:18:01.140
In addition, I would recommend
you don't use startService.

00:18:01.140 --> 00:18:03.160
For a similar
reason, startService

00:18:03.160 --> 00:18:07.350
is limited by those same
background execution limits

00:18:07.350 --> 00:18:10.980
unless you are starting a
service in foreground mode.

00:18:10.980 --> 00:18:14.370
Now, foreground services
require you, as a developer,

00:18:14.370 --> 00:18:17.250
to actually build in
a notification that

00:18:17.250 --> 00:18:19.020
would typically
display to the user

00:18:19.020 --> 00:18:20.880
when that service is running.

00:18:20.880 --> 00:18:23.550
Well, we took away the system
UI where that notification would

00:18:23.550 --> 00:18:26.130
display, so you end up
doing a bunch of work

00:18:26.130 --> 00:18:29.010
for displaying the service
that doesn't actually

00:18:29.010 --> 00:18:31.110
gain you anything.

00:18:31.110 --> 00:18:33.690
And in addition to that,
there are some difficulties

00:18:33.690 --> 00:18:35.520
with started services
when it comes

00:18:35.520 --> 00:18:37.360
to managing their lifecycle.

00:18:37.360 --> 00:18:41.430
A started service-- if that
crashes for some reason,

00:18:41.430 --> 00:18:42.900
you don't have a
direct connection

00:18:42.900 --> 00:18:45.300
to understand that that
occurred and that you

00:18:45.300 --> 00:18:47.340
need to restart that
service so that you

00:18:47.340 --> 00:18:49.830
can manage that process
a little bit better.

00:18:49.830 --> 00:18:53.700
Now, Android does have this
thing that services can return

00:18:53.700 --> 00:18:55.890
this START_STICKY
attribute, and that's

00:18:55.890 --> 00:18:58.530
a way for applications
to tell Android

00:18:58.530 --> 00:19:01.950
that this service is important,
and if it crashes or terminates

00:19:01.950 --> 00:19:05.170
for some reason, I need
it to be restarted.

00:19:05.170 --> 00:19:09.450
However, Android usually only
does this about once or twice

00:19:09.450 --> 00:19:11.730
for a given service before
they just sort of give

00:19:11.730 --> 00:19:14.200
up and realize
that at some point,

00:19:14.200 --> 00:19:16.080
the user will launch
this app again.

00:19:16.080 --> 00:19:19.080
Maybe this will start again and
everything will be fine, OK?

00:19:19.080 --> 00:19:21.330
That type of thinking
doesn't go well

00:19:21.330 --> 00:19:22.890
for those background
services that

00:19:22.890 --> 00:19:26.360
have critical functionality in
them-- like a device driver,

00:19:26.360 --> 00:19:27.660
OK?

00:19:27.660 --> 00:19:30.600
So we recommend you use
bindService instead.

00:19:30.600 --> 00:19:32.820
By using bound
services, this gives

00:19:32.820 --> 00:19:36.000
the background processes
an active connection

00:19:36.000 --> 00:19:38.220
to that foreground app, OK?

00:19:38.220 --> 00:19:41.950
So you have a good indication
of when that service is running

00:19:41.950 --> 00:19:43.950
and when that service
has died for some reason

00:19:43.950 --> 00:19:47.250
so that you can manage that,
relaunch it if you need to,

00:19:47.250 --> 00:19:48.850
do any of those things.

00:19:48.850 --> 00:19:51.810
This also has the added benefit
of a built-in communication

00:19:51.810 --> 00:19:54.690
channel between the
applications that are bound.

00:19:54.690 --> 00:19:58.230
So you can do some more direct
communication with that service

00:19:58.230 --> 00:20:00.510
without having to use
intents or other mechanisms

00:20:00.510 --> 00:20:02.170
like that to pass
data back and forth.

00:20:04.760 --> 00:20:06.190
So looking at this
diagram again,

00:20:06.190 --> 00:20:09.310
one of the other important
reasons to use bound services

00:20:09.310 --> 00:20:11.710
is that pure background
applications--

00:20:11.710 --> 00:20:14.440
like those that would have
been started by BOOT_COMPLETED

00:20:14.440 --> 00:20:16.450
or just startService
on its own--

00:20:16.450 --> 00:20:20.200
are very low priority
on the scale, OK?

00:20:20.200 --> 00:20:22.900
Whereas bound
service applications

00:20:22.900 --> 00:20:26.430
are almost as high priority
as the foreground app.

00:20:26.430 --> 00:20:28.400
They are literally
the highest priority

00:20:28.400 --> 00:20:31.670
you can get without
being the foreground app.

00:20:31.670 --> 00:20:34.600
So this ensures that
those background processes

00:20:34.600 --> 00:20:37.960
stay safe from something
like low memory killer

00:20:37.960 --> 00:20:41.610
if the device ever does get into
a memory pressure situation,

00:20:41.610 --> 00:20:42.220
OK?

00:20:42.220 --> 00:20:44.510
So you get better management
of those services,

00:20:44.510 --> 00:20:46.780
and you get better protection
from a memory management

00:20:46.780 --> 00:20:48.607
perspective.

00:20:48.607 --> 00:20:50.940
All right, let's take a look
at what this would actually

00:20:50.940 --> 00:20:52.270
look like in code.

00:20:52.270 --> 00:20:55.170
So I have just a basic
example of a service here

00:20:55.170 --> 00:20:57.200
that has a device
driver inside of it.

00:20:57.200 --> 00:20:58.950
In this case, this is
just a device driver

00:20:58.950 --> 00:21:01.980
to take some button inputs and
convert them into key events

00:21:01.980 --> 00:21:04.470
like they were coming
off of a keyboard.

00:21:04.470 --> 00:21:06.930
All of this logic can
be fully encapsulated

00:21:06.930 --> 00:21:10.120
into this external service
and can run on its own.

00:21:10.120 --> 00:21:12.720
So we can build this
service component.

00:21:12.720 --> 00:21:14.460
And then from the
foreground app,

00:21:14.460 --> 00:21:17.710
we can construct an intent
to that service component,

00:21:17.710 --> 00:21:19.960
and we can bind to it.

00:21:19.960 --> 00:21:22.900
Notice that I'm doing this
from the Application class

00:21:22.900 --> 00:21:25.650
and not from the
primary activity.

00:21:25.650 --> 00:21:28.170
Remember our discussion
from activities before

00:21:28.170 --> 00:21:30.420
and the lifecycle
associated with those.

00:21:30.420 --> 00:21:32.220
If this is a service
that needs to be

00:21:32.220 --> 00:21:34.800
as persistent as
possible, we want

00:21:34.800 --> 00:21:37.320
to bind to it from a
component that is expected

00:21:37.320 --> 00:21:39.480
to be around just as long, OK?

00:21:39.480 --> 00:21:41.520
So that you don't end
up with lifecycle issues

00:21:41.520 --> 00:21:42.978
where your activity
gets destroyed,

00:21:42.978 --> 00:21:46.800
recreated, and you're rebinding
to that service unnecessarily.

00:21:46.800 --> 00:21:49.420
Doesn't necessarily
cause a major problem,

00:21:49.420 --> 00:21:52.410
but it's not the best idea.

00:21:52.410 --> 00:21:54.300
In addition, with
bound services,

00:21:54.300 --> 00:21:57.260
this also means that you get
this feedback mechanism coming

00:21:57.260 --> 00:21:59.450
through the service
connection callback.

00:21:59.450 --> 00:22:01.130
So when you bind
to a service, you

00:22:01.130 --> 00:22:03.870
provide this callback
as a service connection.

00:22:03.870 --> 00:22:06.080
And when the service
is up and running,

00:22:06.080 --> 00:22:08.840
you will be notified through
the onServiceConnected method.

00:22:08.840 --> 00:22:10.670
So you know exactly
when this is now

00:22:10.670 --> 00:22:13.070
something you can interact
with or communicate

00:22:13.070 --> 00:22:14.720
with if you need to.

00:22:14.720 --> 00:22:17.570
In addition,
onServiceDisconnected

00:22:17.570 --> 00:22:21.380
tells us anytime that
service stops unexpectedly--

00:22:21.380 --> 00:22:24.420
maybe because it has crashed
or something else has occurred.

00:22:24.420 --> 00:22:26.234
And at that point,
we probably need

00:22:26.234 --> 00:22:27.650
to take a look at
restarting this,

00:22:27.650 --> 00:22:29.900
especially if it's running
some critical functionality

00:22:29.900 --> 00:22:31.070
on our device.

00:22:31.070 --> 00:22:35.090
So we now have the information
we need to properly manage

00:22:35.090 --> 00:22:37.430
this functionality from
within our applications, which

00:22:37.430 --> 00:22:40.790
we wouldn't get with started
services or other of these more

00:22:40.790 --> 00:22:44.080
independent mechanisms.

00:22:44.080 --> 00:22:47.520
So here's a final picture
of that architecture again.

00:22:47.520 --> 00:22:50.970
Android is going to manage
for us automatically

00:22:50.970 --> 00:22:53.630
that foreground app
using the HOME intent.

00:22:53.630 --> 00:22:55.710
It will launch it
automatically on boot,

00:22:55.710 --> 00:22:57.990
and it will relaunch it if
that application crashes

00:22:57.990 --> 00:22:59.280
for any reason.

00:22:59.280 --> 00:23:01.770
And then our application
code can then

00:23:01.770 --> 00:23:05.160
manage these additional
background support services

00:23:05.160 --> 00:23:09.130
through the bound
service mechanism.

00:23:09.130 --> 00:23:11.940
All right, the last thing that
I want to share with you today

00:23:11.940 --> 00:23:14.400
are just a couple of
quick tips on doing

00:23:14.400 --> 00:23:17.160
this type of development
from within Android Studio,

00:23:17.160 --> 00:23:20.490
or within the development tools.

00:23:20.490 --> 00:23:24.690
So you can manage multiple APKs
from within a single Android

00:23:24.690 --> 00:23:27.990
Studio project by adding
each additional package

00:23:27.990 --> 00:23:29.610
as a new module.

00:23:29.610 --> 00:23:32.370
You can add multiple
modules to the same project,

00:23:32.370 --> 00:23:35.040
and all of those modules
can represent an APK

00:23:35.040 --> 00:23:37.930
or an individual app process.

00:23:37.930 --> 00:23:40.890
This allows you to manage all
of your code in one place,

00:23:40.890 --> 00:23:44.040
even though they're
technically separate apps.

00:23:44.040 --> 00:23:47.040
Now, by default,
Android Studio does not

00:23:47.040 --> 00:23:50.280
allow you to deploy an
app module that does not

00:23:50.280 --> 00:23:53.490
contain a launcher activity,
or an activity that

00:23:53.490 --> 00:23:57.000
has that main launcher
intent filter on it.

00:23:57.000 --> 00:23:59.400
This doesn't work so well
for background service

00:23:59.400 --> 00:24:02.100
apps that don't have any
activities at all in them

00:24:02.100 --> 00:24:03.720
in some cases.

00:24:03.720 --> 00:24:05.970
But you can modify
this behavior.

00:24:05.970 --> 00:24:07.860
For a background
services app, you

00:24:07.860 --> 00:24:10.320
can edit the run
configuration and simply

00:24:10.320 --> 00:24:14.760
adjust the launch options for
that particular module, set

00:24:14.760 --> 00:24:18.600
that target to Nothing
instead of Default Activity.

00:24:18.600 --> 00:24:22.860
This will enable Android Studio
to deploy that service-only app

00:24:22.860 --> 00:24:24.900
to your device, and
it won't complain.

00:24:27.800 --> 00:24:30.170
You can also do this
from the command line.

00:24:30.170 --> 00:24:32.360
And one of the advantages
of doing it this way

00:24:32.360 --> 00:24:36.110
is that Android Studio does
require that you deploy

00:24:36.110 --> 00:24:37.940
only one module at a time--

00:24:37.940 --> 00:24:40.640
by selecting that module
from the run configuration

00:24:40.640 --> 00:24:42.080
list in the UI.

00:24:42.080 --> 00:24:43.850
So if you have an
application that's

00:24:43.850 --> 00:24:46.310
constructed of four or
five different modules

00:24:46.310 --> 00:24:49.394
all as individual APKs,
it can be a bit cumbersome

00:24:49.394 --> 00:24:50.810
if you have to try
and deploy them

00:24:50.810 --> 00:24:53.400
all individually all the time.

00:24:53.400 --> 00:24:56.150
One of the advantages of
using the Gradle command line

00:24:56.150 --> 00:24:59.930
is that by default, when you
run a command like installDebug

00:24:59.930 --> 00:25:02.900
with no other modifiers,
it builds and installs

00:25:02.900 --> 00:25:05.730
every module in that project.

00:25:05.730 --> 00:25:08.150
So with one command, you
can deploy everything

00:25:08.150 --> 00:25:10.550
on the latest version
to that device.

00:25:10.550 --> 00:25:12.890
And you can still do
individual modules,

00:25:12.890 --> 00:25:15.500
if you would prefer to do that,
by just adding the module name

00:25:15.500 --> 00:25:16.458
to the command as well.

00:25:18.940 --> 00:25:20.922
Once you've got the
modules on the device,

00:25:20.922 --> 00:25:22.380
the other thing
you can do directly

00:25:22.380 --> 00:25:24.004
from the command line
that isn't really

00:25:24.004 --> 00:25:25.980
supported in
Android Studio today

00:25:25.980 --> 00:25:28.870
is the ability to start
those individual components,

00:25:28.870 --> 00:25:31.470
whether their
activities or services.

00:25:31.470 --> 00:25:33.630
So using the am
shell commands, you

00:25:33.630 --> 00:25:35.790
can trigger those
services manually

00:25:35.790 --> 00:25:38.100
if you want to test out
some of that behavior

00:25:38.100 --> 00:25:40.319
independently from the
rest of the system,

00:25:40.319 --> 00:25:42.360
even though they may be
managed by the foreground

00:25:42.360 --> 00:25:45.690
app in production.

00:25:45.690 --> 00:25:48.030
All right, so let's quickly
review some of the tips

00:25:48.030 --> 00:25:50.010
that we've gone
through here today.

00:25:50.010 --> 00:25:52.500
Don't assume a graphical UI.

00:25:52.500 --> 00:25:55.470
Design for your memory
constraints on these devices.

00:25:55.470 --> 00:25:57.990
Break your app up into modules.

00:25:57.990 --> 00:26:00.780
Bind your background services
to the foreground app.

00:26:00.780 --> 00:26:02.970
Don't use started services.

00:26:02.970 --> 00:26:04.830
And use the Gradle
command line if you

00:26:04.830 --> 00:26:06.720
want to have more
control over deploying

00:26:06.720 --> 00:26:07.965
your modules to the device.

00:26:11.080 --> 00:26:13.890
Now, if you're just as excited
about Android Things as we are,

00:26:13.890 --> 00:26:16.140
I want to remind everyone
that we're doing a scavenger

00:26:16.140 --> 00:26:19.020
hunt here at Google I/O. If
you visit the link here or use

00:26:19.020 --> 00:26:22.050
the Google I/O app, you can
follow the instructions to find

00:26:22.050 --> 00:26:24.060
various items around
the conference.

00:26:24.060 --> 00:26:27.210
And once you've completed
those challenges,

00:26:27.210 --> 00:26:29.680
you can then receive a free
Android Things developer kit

00:26:29.680 --> 00:26:32.200
to take home.

00:26:32.200 --> 00:26:34.090
To learn more about
Android Things,

00:26:34.090 --> 00:26:35.860
visit the developer
site and make

00:26:35.860 --> 00:26:39.340
sure to visit the Codelabs,
office hours, and other demos

00:26:39.340 --> 00:26:41.440
that we have here
in the Sandbox.

00:26:41.440 --> 00:26:44.620
Also be sure to visit Android
Things with Google.com

00:26:44.620 --> 00:26:47.860
to find featured community
projects and additional sample

00:26:47.860 --> 00:26:48.580
code.

00:26:48.580 --> 00:26:50.826
You'll also find a
lot of the sample code

00:26:50.826 --> 00:26:52.450
available for some
of the demos that we

00:26:52.450 --> 00:26:55.210
have here at the conference on
androidthings.withgoogle.com

00:26:55.210 --> 00:26:56.650
as well.

00:26:56.650 --> 00:26:58.490
So thank you, everyone,
for your time today,

00:26:58.490 --> 00:26:59.830
and I'm really excited
to see the apps

00:26:59.830 --> 00:27:01.288
that you build with
Android Things.

00:27:01.288 --> 00:27:02.501
[APPLAUSE]

00:27:02.501 --> 00:27:07.020
[MUSIC PLAYING]

