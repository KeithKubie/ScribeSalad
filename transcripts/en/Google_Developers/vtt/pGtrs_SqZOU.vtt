WEBVTT
Kind: captions
Language: en

00:00:05.370 --> 00:00:06.070
SHAWN SIMISTER: Thank
you, everyone,

00:00:06.070 --> 00:00:07.650
for coming out today.

00:00:07.650 --> 00:00:12.010
It's a great turnout, so I
really appreciate that on the

00:00:12.010 --> 00:00:13.620
last day of I/O here.

00:00:13.620 --> 00:00:15.610
Today I'm going to be talking
about knowledge-based

00:00:15.610 --> 00:00:19.020
application design patterns.

00:00:19.020 --> 00:00:20.180
My name is Shawn Simister.

00:00:20.180 --> 00:00:22.460
I work in developer relations
here at Google.

00:00:22.460 --> 00:00:25.640
I work with the knowledge group,
which, as you might

00:00:25.640 --> 00:00:27.180
know, includes search.

00:00:27.180 --> 00:00:30.560
But it also covers a lot of
other developer products like

00:00:30.560 --> 00:00:35.370
Freebase, Google Refine,
Schema.org, and now, the

00:00:35.370 --> 00:00:37.390
Knowledge Graph.

00:00:37.390 --> 00:00:40.370
I've been building web apps for
over 10 years now, working

00:00:40.370 --> 00:00:42.820
in developer relations
for a year.

00:00:42.820 --> 00:00:45.740
I've been a member of Freebase
community since it started

00:00:45.740 --> 00:00:47.560
five years ago.

00:00:47.560 --> 00:00:51.490
And this presentation is sort of
collections of lessons that

00:00:51.490 --> 00:00:53.510
I've learned from building
applications on top of a

00:00:53.510 --> 00:00:56.100
Knowledge Graph, and also from
helping developers like

00:00:56.100 --> 00:01:00.670
yourselves build applications
on top of a Knowledge Graph.

00:01:00.670 --> 00:01:06.470
So what does it mean to be a
knowledge-based application?

00:01:06.470 --> 00:01:07.610
The web is changing.

00:01:07.610 --> 00:01:12.040
The web is changing from being
a web documents to becoming a

00:01:12.040 --> 00:01:14.510
web of things.

00:01:14.510 --> 00:01:16.435
The users expect applications
that know

00:01:16.435 --> 00:01:18.230
about real world things.

00:01:18.230 --> 00:01:21.300
Real world things that they care
about and not just pages

00:01:21.300 --> 00:01:25.000
and links that they can
do things with.

00:01:25.000 --> 00:01:26.930
This creates opportunities
to build new types of

00:01:26.930 --> 00:01:30.320
applications and enhance
existing applications.

00:01:30.320 --> 00:01:32.840
So today I'm going to show you
some examples of applications

00:01:32.840 --> 00:01:35.210
built on top of a
Knowledge Graph.

00:01:35.210 --> 00:01:37.710
I'm going to show you some
design patterns help you tap

00:01:37.710 --> 00:01:40.240
into the power of the
Knowledge Graph.

00:01:40.240 --> 00:01:41.330
And we're going to
look at some code

00:01:41.330 --> 00:01:44.840
samples to get started.

00:01:44.840 --> 00:01:47.070
So most of you have probably
seen this now.

00:01:47.070 --> 00:01:50.010
This is the Knowledge Graph,
Google's Knowledge Graph,

00:01:50.010 --> 00:01:51.510
showing up in search.

00:01:51.510 --> 00:01:53.330
We've launched this
this month.

00:01:53.330 --> 00:01:57.060
And if you search for a thing in
Google, most likely you'll

00:01:57.060 --> 00:01:59.940
see one of these cards here
that gives you some

00:01:59.940 --> 00:02:02.410
information about that entity

00:02:02.410 --> 00:02:06.410
Google's Knowledge Graph has
over 500 million entities, 3.5

00:02:06.410 --> 00:02:09.919
billion facts about those
entities, and it's being

00:02:09.919 --> 00:02:11.700
integrated into more and
more parts of Google.

00:02:11.700 --> 00:02:15.350
So on Wednesday's keynote, I'm
sure you saw the Knowledge

00:02:15.350 --> 00:02:19.720
Graph showing up in
Android as well.

00:02:19.720 --> 00:02:21.680
So what is a Knowledge Graph?

00:02:21.680 --> 00:02:25.410
A Knowledge Graph is a
collection of entities--

00:02:25.410 --> 00:02:27.310
well, first and foremost,
it's a graph.

00:02:27.310 --> 00:02:30.910
And, as you can see here, this
is the graph representation of

00:02:30.910 --> 00:02:34.440
that knowledge panel
that we just saw.

00:02:34.440 --> 00:02:37.350
And so each one of these little
circles, or nodes in

00:02:37.350 --> 00:02:40.400
the graph, are the real world
things, the entities that

00:02:40.400 --> 00:02:41.620
we're talking about.

00:02:41.620 --> 00:02:44.900
And then the lines to connect
them together are the edges,

00:02:44.900 --> 00:02:47.240
those 3.5 billion facts.

00:02:47.240 --> 00:02:49.020
And these are actual meaningful
relationships

00:02:49.020 --> 00:02:49.790
between entities.

00:02:49.790 --> 00:02:51.500
We're not just saying that
they're related in some way,

00:02:51.500 --> 00:02:53.630
we're saying exactly how
they're related.

00:02:53.630 --> 00:02:56.380
So you can see, here,
all the information

00:02:56.380 --> 00:02:58.740
that we had in search.

00:02:58.740 --> 00:03:00.910
This is how it looks
in the graph.

00:03:00.910 --> 00:03:03.980
Some of the topics are entities,
or some of the nodes

00:03:03.980 --> 00:03:04.760
are entities.

00:03:04.760 --> 00:03:07.230
Some of the nodes are actually
mediator nodes.

00:03:07.230 --> 00:03:11.920
So you can see, like a film
performance, it shows what

00:03:11.920 --> 00:03:13.620
character he played
in that film.

00:03:13.620 --> 00:03:17.410
Or for his spouse, it'll show
what time period and that

00:03:17.410 --> 00:03:19.990
person was married to him.

00:03:19.990 --> 00:03:23.080
And so all this data gets pulled
together and displayed

00:03:23.080 --> 00:03:24.730
in search or other
applications.

00:03:27.740 --> 00:03:28.770
And this is really useful.

00:03:28.770 --> 00:03:31.780
This can be really useful for
your applications as well.

00:03:31.780 --> 00:03:35.480
Because Knowledge Graph is
very high quality data.

00:03:35.480 --> 00:03:38.840
It's deduplicated, so
there's no ambiguity

00:03:38.840 --> 00:03:41.980
between different entities.

00:03:41.980 --> 00:03:46.150
We know that this is the Chuck
Norris the acts in Walker

00:03:46.150 --> 00:03:48.920
Texas Ranger, not some other
Chuck Norris just because the

00:03:48.920 --> 00:03:50.710
name matches.

00:03:50.710 --> 00:03:52.010
And most importantly,
it's searchable.

00:03:52.010 --> 00:03:53.760
So we've come up with some
really interesting ways of

00:03:53.760 --> 00:03:57.640
letting you use this data
in your application.

00:03:57.640 --> 00:03:59.420
Now I'm going to talk
a little bit about

00:03:59.420 --> 00:04:01.350
Freebase's Knowledge Graph.

00:04:01.350 --> 00:04:05.750
So Freebase started off as a
local startup called Metaweb.

00:04:05.750 --> 00:04:09.790
Metaweb was acquired by Google
in 2010 and that team went on

00:04:09.790 --> 00:04:12.250
to help build the Knowledge
Graph here at Google.

00:04:12.250 --> 00:04:15.960
Freebase lives on as the open,
public facing part of the

00:04:15.960 --> 00:04:17.100
Knowledge Graph.

00:04:17.100 --> 00:04:19.769
It's crowd-sourced,
so anyone can

00:04:19.769 --> 00:04:21.959
contribute, like Wikipedia.

00:04:21.959 --> 00:04:26.220
There's 2.3 million topics, and
those are organized into

00:04:26.220 --> 00:04:28.990
over 2000 different types of
things, people, places,

00:04:28.990 --> 00:04:31.610
locations, events, all
that sort of stuff.

00:04:31.610 --> 00:04:34.790
We have RESTful APIs that let
you tap into that, and I'll

00:04:34.790 --> 00:04:37.640
show that a little bit later
in the presentation.

00:04:37.640 --> 00:04:40.340
Everything is licensed under a
Creative Commons attribution

00:04:40.340 --> 00:04:43.530
license, so it's very easy to
take it out, use it, use it

00:04:43.530 --> 00:04:45.340
commercially, as long
as you give

00:04:45.340 --> 00:04:47.400
attribution back to Freebase.

00:04:47.400 --> 00:04:49.800
There's complete data dumps,
so at any point you can

00:04:49.800 --> 00:04:52.940
download everything, all those
23 million topics, and do

00:04:52.940 --> 00:04:55.000
whatever you want with them.

00:04:55.000 --> 00:04:57.920
And most importantly, it's one
of the major sources for

00:04:57.920 --> 00:05:00.260
Google's Knowledge Graph.

00:05:00.260 --> 00:05:04.080
So a lot of that high quality
data from Freebase winds up

00:05:04.080 --> 00:05:05.970
being in the Knowledge
Graph and in

00:05:05.970 --> 00:05:08.230
those products at Google.

00:05:08.230 --> 00:05:10.680
So this is what freebase
looks like.

00:05:10.680 --> 00:05:13.370
Every one of those 23 million
entities and Freebase has its

00:05:13.370 --> 00:05:15.530
own page as well as a schema.

00:05:15.530 --> 00:05:18.150
All the types, those 2000
commons types, have their own

00:05:18.150 --> 00:05:19.470
page, like this.

00:05:19.470 --> 00:05:21.710
And every property even
has its own page.

00:05:21.710 --> 00:05:24.290
And anyone with a Google
account can login.

00:05:24.290 --> 00:05:28.410
Anyone with a Gmail account
can log in and contribute

00:05:28.410 --> 00:05:33.370
data, create new schema, add
topics, fix errors, much like

00:05:33.370 --> 00:05:34.795
you would with something
like Wikipedia.

00:05:38.940 --> 00:05:42.290
So let's imagine what sort of
applications you can build

00:05:42.290 --> 00:05:45.640
with this type of
Knowledge Graph.

00:05:45.640 --> 00:05:47.990
You could build applications
that understand real world

00:05:47.990 --> 00:05:50.750
entities, the real people,
places, and things that the

00:05:50.750 --> 00:05:52.370
users care about.

00:05:52.370 --> 00:05:54.940
You can build applications that
allow users to interact

00:05:54.940 --> 00:05:56.680
with these entities
in new ways that

00:05:56.680 --> 00:05:58.250
they couldn't before.

00:05:58.250 --> 00:06:01.380
You can build applications the
scale to millions of topics,

00:06:01.380 --> 00:06:05.710
rather than just a small list
of hand curated topics.

00:06:05.710 --> 00:06:07.700
So next, we're going to look
at some ways you can build

00:06:07.700 --> 00:06:10.430
these sorts of applications
right now.

00:06:10.430 --> 00:06:13.870
We're going to look at some
discovery patterns, which are

00:06:13.870 --> 00:06:16.100
ways to convert strings
into things.

00:06:16.100 --> 00:06:18.340
We'll go into that shortly.

00:06:18.340 --> 00:06:20.540
We'll look at interaction
patterns, which are ways of

00:06:20.540 --> 00:06:23.180
navigating through the Knowledge
Graph to find

00:06:23.180 --> 00:06:25.240
interesting pieces of data.

00:06:25.240 --> 00:06:27.470
And finally, we'll look at
presentation patterns, which

00:06:27.470 --> 00:06:30.540
is ways to display that
data to the user

00:06:30.540 --> 00:06:32.130
in informative ways.

00:06:32.130 --> 00:06:33.870
Put it in context with
your content.

00:06:36.950 --> 00:06:39.920
So discovery patterns.

00:06:39.920 --> 00:06:43.520
Discovery patterns cover,
as I said, turning

00:06:43.520 --> 00:06:44.470
strings into things.

00:06:44.470 --> 00:06:46.770
Taking the user input and
figuring out which entities

00:06:46.770 --> 00:06:48.830
they're talking about.

00:06:48.830 --> 00:06:51.620
And so this is usually the
first step in your

00:06:51.620 --> 00:06:52.860
application.

00:06:52.860 --> 00:07:00.050
This is usually how you start,
how you go from user input to

00:07:00.050 --> 00:07:00.800
a Knowledge Graph.

00:07:00.800 --> 00:07:04.390
But it's not just limited
to strings, either.

00:07:04.390 --> 00:07:07.020
As we've seen, you can
have voice input.

00:07:07.020 --> 00:07:08.720
You can give it a URL.

00:07:08.720 --> 00:07:10.980
We'll see some examples of
taking documents and getting

00:07:10.980 --> 00:07:13.610
entities out of them.

00:07:13.610 --> 00:07:14.990
So the first pattern we'll
look at is the

00:07:14.990 --> 00:07:16.620
reconciliation pattern.

00:07:16.620 --> 00:07:20.880
And the problem that this
addresses is, when a user has

00:07:20.880 --> 00:07:23.280
an entity in mind, they have
some key words, they want to

00:07:23.280 --> 00:07:26.490
describe it to you, but they
don't know what the identifier

00:07:26.490 --> 00:07:28.420
of that entity is
in your graph.

00:07:28.420 --> 00:07:30.300
How to look it up in your
Knowledge Graph

00:07:30.300 --> 00:07:33.470
of 500 million entities.

00:07:33.470 --> 00:07:35.250
Keywords can be ambiguous.

00:07:35.250 --> 00:07:39.570
If they type in "John Smith,"
what do you give them back.

00:07:39.570 --> 00:07:45.480
And there are some problems,
too, of, even when you show

00:07:45.480 --> 00:07:48.120
them the entity, how do you know
that this is the one that

00:07:48.120 --> 00:07:49.370
they're looking for.

00:07:51.610 --> 00:07:53.820
So there's a couple solutions
that we've come up with.

00:07:53.820 --> 00:07:56.490
The first is the easiest one,
which is just to come up with

00:07:56.490 --> 00:07:58.100
a list of matching entities.

00:07:58.100 --> 00:08:00.070
Show them all the John
Smith's and let them

00:08:00.070 --> 00:08:01.540
pick from that list.

00:08:01.540 --> 00:08:04.990
That doesn't always scale, you
need some way to rank the

00:08:04.990 --> 00:08:07.490
matches as well.

00:08:07.490 --> 00:08:10.680
But we'll show you
how that works.

00:08:10.680 --> 00:08:13.290
The other way is to use
reconciliation algorithms to

00:08:13.290 --> 00:08:14.960
do it automatically.

00:08:14.960 --> 00:08:17.190
So we have a number of
techniques that we use

00:08:17.190 --> 00:08:21.630
internally, and we're working
on ways to open that up to

00:08:21.630 --> 00:08:22.260
developers.

00:08:22.260 --> 00:08:24.580
But basically, you look at the
different properties and you

00:08:24.580 --> 00:08:27.530
say, do these people have the
same dirth date, does this

00:08:27.530 --> 00:08:31.420
company have the same location
for their headquarters, and

00:08:31.420 --> 00:08:32.670
you match them that way.

00:08:35.429 --> 00:08:37.360
And then, what we've found is
the best technique is to

00:08:37.360 --> 00:08:38.250
combine both of those.

00:08:38.250 --> 00:08:42.900
So, use the algorithm to match
80% of them, and then use

00:08:42.900 --> 00:08:46.020
humans to match the last 20%,
the really hard ones that the

00:08:46.020 --> 00:08:48.550
algorithms can't match.

00:08:48.550 --> 00:08:50.700
So let's look at an
example of that.

00:08:50.700 --> 00:08:55.610
Ranker.com is a site that lets
you create and share ranked

00:08:55.610 --> 00:08:57.580
lists of things.

00:08:57.580 --> 00:09:01.110
And so they use Freebase data as
a source for those things.

00:09:01.110 --> 00:09:05.500
And here we see their list
editor where I'm creating a

00:09:05.500 --> 00:09:08.540
new list of the best movie
villains of all time, and I

00:09:08.540 --> 00:09:10.980
want to add Goldfinger.

00:09:10.980 --> 00:09:13.330
So here they're using the
reconciliation pattern to let

00:09:13.330 --> 00:09:16.380
me type in some text, give me
some suggestions of entities

00:09:16.380 --> 00:09:19.880
that match in their site, and
then let me select those.

00:09:24.030 --> 00:09:26.705
And you can see here that
it also gives the--

00:09:26.705 --> 00:09:27.920
it's a little bit small
at the bottom--

00:09:27.920 --> 00:09:31.060
But it also gives us the option
to create a new entity

00:09:31.060 --> 00:09:32.500
if it doesn't exist.

00:09:32.500 --> 00:09:35.150
So that lets them grow their
Knowledge Graph as well.

00:09:38.160 --> 00:09:40.210
This is Freebase Suggest.

00:09:40.210 --> 00:09:42.910
This is an open-source jQuery
plug-in that we created.

00:09:42.910 --> 00:09:47.930
And let me just show you why we
created this to help you do

00:09:47.930 --> 00:09:51.740
reconciliation in your apps.

00:09:51.740 --> 00:09:55.255
So say I'm looking for
a film director.

00:09:55.255 --> 00:09:59.080
I'm looking for Francis
Ford Coppola.

00:09:59.080 --> 00:10:03.710
I'm going to start typing
in "Francis" "Ford"--

00:10:03.710 --> 00:10:06.540
All right, so now you
see, it's come up

00:10:06.540 --> 00:10:08.970
with a couple matches.

00:10:08.970 --> 00:10:11.960
And I can hover over those and
see a short description of

00:10:11.960 --> 00:10:14.610
what that entity is like.

00:10:14.610 --> 00:10:17.300
You can see it's giving me
some clues, like a photo.

00:10:17.300 --> 00:10:18.600
That's a pretty strong clue.

00:10:18.600 --> 00:10:20.270
Date of birth, again,
another strong clue.

00:10:22.940 --> 00:10:24.890
So I'll click on this one.

00:10:24.890 --> 00:10:28.490
And you can see here, this
is the code that I used.

00:10:28.490 --> 00:10:32.280
Very simple, one line of
JavaScript jQuery.

00:10:32.280 --> 00:10:33.760
And this is the data
that I get back.

00:10:33.760 --> 00:10:36.190
So I'm getting back to name, but
I'm also getting back the

00:10:36.190 --> 00:10:37.890
unique ID in the Freebase
Knowledge

00:10:37.890 --> 00:10:39.890
Graph for that entity.

00:10:39.890 --> 00:10:41.680
And then I can use that
application to do a whole

00:10:41.680 --> 00:10:44.620
bunch of things, which we'll
see in a second.

00:10:44.620 --> 00:10:46.550
This also has an API,
so RESTful API,

00:10:46.550 --> 00:10:47.360
where you call this.

00:10:47.360 --> 00:10:50.170
So you can just pass text
and get back those

00:10:50.170 --> 00:10:53.210
suggestions as JSON data.

00:10:53.210 --> 00:10:55.360
So it's very easy to add this
reconciliation to your

00:10:55.360 --> 00:10:58.520
application, and to do that
sort of entity-based

00:10:58.520 --> 00:10:59.770
recommendation.

00:11:06.080 --> 00:11:08.300
So when would you use this?

00:11:08.300 --> 00:11:10.420
Like I said, when we
need entity IDs for

00:11:10.420 --> 00:11:11.480
known entity names.

00:11:11.480 --> 00:11:14.450
So when the user has an entity
in mind, but they don't know

00:11:14.450 --> 00:11:17.760
which ID it corresponds to in
our database or our graph.

00:11:17.760 --> 00:11:20.850
When we need to disambiguate,
when we don't know which John

00:11:20.850 --> 00:11:22.820
Smith they're talking about.

00:11:22.820 --> 00:11:25.640
And when we can use tags to
organize our content.

00:11:25.640 --> 00:11:28.650
When we have too much content
that tagging would lead to too

00:11:28.650 --> 00:11:32.180
many ambiguities, then we can
actually annotate content with

00:11:32.180 --> 00:11:34.090
entities instead.

00:11:34.090 --> 00:11:36.010
Now let's see one more
example of that

00:11:36.010 --> 00:11:37.930
reconciliation pattern.

00:11:37.930 --> 00:11:42.940
This is a social app called
Amen, and it lets you state

00:11:42.940 --> 00:11:44.990
strong opinions about
real world things.

00:11:44.990 --> 00:11:48.970
And they actually use Freebase
data to let people select an

00:11:48.970 --> 00:11:52.430
entity, and then state a strong
opinion about it, and

00:11:52.430 --> 00:11:54.110
then share that with
their friends.

00:11:54.110 --> 00:11:56.280
And one of the interesting
things about that is that,

00:11:56.280 --> 00:11:58.985
once you share that, they
actually know about the

00:11:58.985 --> 00:12:00.630
entities that you're sharing
your opinion about.

00:12:00.630 --> 00:12:02.770
So you can click on an entity.

00:12:02.770 --> 00:12:07.020
Say it says, Blue Bottle Coffee
is the best place for

00:12:07.020 --> 00:12:08.260
coffee in San Francisco.

00:12:08.260 --> 00:12:10.660
You can click on that Blue
Bottle Coffee and see all the

00:12:10.660 --> 00:12:15.010
other opinions that people have
had about that entity.

00:12:15.010 --> 00:12:17.080
So it opens up some new
possibilities for how you want

00:12:17.080 --> 00:12:18.780
to interact with the data.

00:12:22.620 --> 00:12:24.910
The second discovery pattern
we're going to look at is

00:12:24.910 --> 00:12:26.880
called the detection pattern.

00:12:26.880 --> 00:12:29.700
And this is where the user wants
to learn more about some

00:12:29.700 --> 00:12:31.420
subject matter, but it's
not just a string.

00:12:31.420 --> 00:12:35.760
It's maybe an article, or
an image, or a video.

00:12:35.760 --> 00:12:37.920
Something that they couldn't
just easily just type into a

00:12:37.920 --> 00:12:40.930
text box, like we saw.

00:12:40.930 --> 00:12:43.090
So there are a number of
solutions for this.

00:12:43.090 --> 00:12:46.740
The most common one is called
named entity recognition.

00:12:46.740 --> 00:12:50.150
So this is a family of
logarithms to people use to

00:12:50.150 --> 00:12:54.700
automatically detect name
densities, these things, from

00:12:54.700 --> 00:12:56.750
an article.

00:12:56.750 --> 00:12:59.540
Another way to do is to
use structured markup.

00:12:59.540 --> 00:13:01.860
So there's a lot more web pages
these days using things

00:13:01.860 --> 00:13:05.900
like schema.org, RDFA,
micro formats.

00:13:05.900 --> 00:13:07.880
And you can actually use that to
pull the things out of the

00:13:07.880 --> 00:13:10.400
page, and then use the
reconciliation pattern that we

00:13:10.400 --> 00:13:13.420
just saw to figure out which
entities they correspond to in

00:13:13.420 --> 00:13:14.670
the Knowledge Graph.

00:13:16.680 --> 00:13:19.260
This is DBPedia Spotlight.

00:13:19.260 --> 00:13:22.610
This is an open-source project
built on top of DBPedia.

00:13:22.610 --> 00:13:27.370
DBPedia is a project that's goal
is to extract structured

00:13:27.370 --> 00:13:28.960
data from Wikipedia.

00:13:28.960 --> 00:13:31.360
So it's a lot like Freebase in
that sense, except for it's

00:13:31.360 --> 00:13:35.600
limited to just Wikipedia, and
they produce RDF data.

00:13:35.600 --> 00:13:38.250
And they've created this
incredible tool to do

00:13:38.250 --> 00:13:41.830
named-entity recognition
using DBPedia data.

00:13:41.830 --> 00:13:45.220
The great thing is that, because
Freebase and DBPedia

00:13:45.220 --> 00:13:49.560
are both using Wikipedia data,
all of our IDs link together

00:13:49.560 --> 00:13:50.120
quite easily.

00:13:50.120 --> 00:13:53.200
So you can actually use DBPedia
to get the IDs out,

00:13:53.200 --> 00:13:56.220
and then convert those into
Freebase IDs quite easily and

00:13:56.220 --> 00:13:58.335
use that data in your
application.

00:14:01.710 --> 00:14:02.900
So when do you use this?

00:14:02.900 --> 00:14:06.460
You use this when you have a lot
of content, thousands of

00:14:06.460 --> 00:14:10.440
articles, or more content then
you could annotate by hand.

00:14:10.440 --> 00:14:13.520
When you need to identify
relevant

00:14:13.520 --> 00:14:14.560
entities with your content.

00:14:14.560 --> 00:14:16.960
So say you have a lot of user
generated content, and you

00:14:16.960 --> 00:14:20.900
want to be able to navigate that
in ways, like we saw with

00:14:20.900 --> 00:14:23.190
Amen, that are related to the
entities being discussed.

00:14:23.190 --> 00:14:25.870
You can use this.

00:14:25.870 --> 00:14:27.240
And like I said, when
we just have too

00:14:27.240 --> 00:14:28.490
much content to markup.

00:14:30.810 --> 00:14:34.510
A number of other services,
OpenCalais, AlchemyAPI,

00:14:34.510 --> 00:14:37.510
Zemanta, they all use Freebase
identifiers to look up

00:14:37.510 --> 00:14:38.850
entities in text.

00:14:38.850 --> 00:14:42.750
So a lot of great API that you
can use to mash up that data

00:14:42.750 --> 00:14:44.000
with other sources.

00:14:48.650 --> 00:14:49.780
So that was discovery
patterns.

00:14:49.780 --> 00:14:54.940
That's how you go from raw
content, or user input, to IDs

00:14:54.940 --> 00:14:56.140
in your Knowledge Graph.

00:14:56.140 --> 00:14:57.990
Now we're going to look at
interaction patterns, which

00:14:57.990 --> 00:15:01.710
is, once you have those entity
IDs, what sort of interesting

00:15:01.710 --> 00:15:02.600
things can you do with them.

00:15:02.600 --> 00:15:05.140
How can you use that
to find interesting

00:15:05.140 --> 00:15:06.620
paths through the graph.

00:15:10.220 --> 00:15:12.130
So the first pattern that we're
going to look at is

00:15:12.130 --> 00:15:15.290
called the faceting pattern.

00:15:15.290 --> 00:15:20.080
And the problem is that the
first step might overturn a

00:15:20.080 --> 00:15:21.070
lot of results.

00:15:21.070 --> 00:15:25.480
You might have said, I want to
find computer programmers.

00:15:25.480 --> 00:15:27.530
And it returns thousands
of results.

00:15:27.530 --> 00:15:30.460
Now what do you do?

00:15:30.460 --> 00:15:35.800
A lot of times, the data
that the user is

00:15:35.800 --> 00:15:37.990
looking for is large.

00:15:37.990 --> 00:15:41.410
It's not all that it's
that interesting.

00:15:41.410 --> 00:15:45.570
You want to find a way to filter
it down, but there's no

00:15:45.570 --> 00:15:47.240
specific way that you
can filter it down.

00:15:47.240 --> 00:15:50.860
If you're dealing with an entity
of 500 million topics,

00:15:50.860 --> 00:15:54.630
thousands of different types of
topics, there's no single

00:15:54.630 --> 00:15:57.030
way to organize that.

00:15:57.030 --> 00:16:00.640
So facets are a very flexible
way to let the user drill down

00:16:00.640 --> 00:16:01.820
into that data.

00:16:01.820 --> 00:16:04.310
Basically how it works is, you
look at all the different

00:16:04.310 --> 00:16:07.840
properties of the data, and you
count up how frequently

00:16:07.840 --> 00:16:10.690
each one occurs, and you
let the user choose.

00:16:10.690 --> 00:16:13.120
So you can see here, this image
I have is from Google

00:16:13.120 --> 00:16:17.490
Refine, which is a product that
we've open sourced for

00:16:17.490 --> 00:16:19.830
working with messy data.

00:16:19.830 --> 00:16:24.930
And it's taken some zip codes,
counted them up, and we let

00:16:24.930 --> 00:16:28.590
the user click on those to see
just the data that concerns

00:16:28.590 --> 00:16:34.760
that zip code, or, political
party, here.

00:16:34.760 --> 00:16:38.110
And so the idea is, you give the
user a broad overview of

00:16:38.110 --> 00:16:39.810
what sort of data they're
looking at, let

00:16:39.810 --> 00:16:41.230
them click on it.

00:16:41.230 --> 00:16:44.780
Filter down those results until
they find a smaller set

00:16:44.780 --> 00:16:48.210
of entities that they're
really interested in.

00:16:48.210 --> 00:16:50.110
One of the areas where we've
done this is actually in

00:16:50.110 --> 00:16:51.010
Google search.

00:16:51.010 --> 00:16:52.850
If you do a Google search
for something that

00:16:52.850 --> 00:16:54.050
looks like an entity--

00:16:54.050 --> 00:16:59.070
or something that looks
like a recipe--

00:16:59.070 --> 00:17:00.990
We actually do faceted
search on the side.

00:17:00.990 --> 00:17:04.490
So here, I've done a search for
"margarita recipe." And

00:17:04.490 --> 00:17:07.829
you can see that we faceted
popular ingredients, the

00:17:07.829 --> 00:17:12.069
cooking time, the number of
calories in the recipe.

00:17:12.069 --> 00:17:13.219
I don't know why you'd
be concerned with

00:17:13.219 --> 00:17:14.469
calories for a margarita.

00:17:18.069 --> 00:17:21.020
And so if you click on any one
of those facets, you can

00:17:21.020 --> 00:17:22.730
actually filter that down.

00:17:22.730 --> 00:17:26.020
It automatically does a
constrained Google search, and

00:17:26.020 --> 00:17:27.869
really lets you dig into that
data quite quickly.

00:17:31.940 --> 00:17:36.560
So this is an example of the
"miquel," MQL, query language

00:17:36.560 --> 00:17:39.870
that Freebase uses to
search entities.

00:17:39.870 --> 00:17:43.780
At the top here, we have
a query for our API.

00:17:43.780 --> 00:17:46.080
And at the bottom
is the result.

00:17:46.080 --> 00:17:49.390
You can see it's just a
simple JSON structure.

00:17:49.390 --> 00:17:50.630
It's query by example.

00:17:50.630 --> 00:17:55.240
So here we're asking for the ID
and the name of things in

00:17:55.240 --> 00:17:57.280
our graph which have the
profession "software

00:17:57.280 --> 00:18:00.610
developer" and the type
"people person."

00:18:00.610 --> 00:18:03.880
And you can see, the bottom half
with the results, it's

00:18:03.880 --> 00:18:05.940
filled in some of those
null values.

00:18:05.940 --> 00:18:08.860
We have ESR, Sergey Brin.

00:18:08.860 --> 00:18:10.990
But if you actually run that
on the Freebase API, you'll

00:18:10.990 --> 00:18:16.610
get over 100 results of
famous programmers.

00:18:16.610 --> 00:18:19.010
So this sort of query could
easily be used to generate

00:18:19.010 --> 00:18:23.740
those facets, using Freebase
data, in your application.

00:18:26.380 --> 00:18:28.670
Here we can see using
the Google API

00:18:28.670 --> 00:18:31.240
client library in Python.

00:18:31.240 --> 00:18:33.440
It's very simple to take that
same query that we had on the

00:18:33.440 --> 00:18:39.960
previous slide here, the top,
and pass that in to the

00:18:39.960 --> 00:18:44.530
Freebase API service, and get
that data back in Python.

00:18:44.530 --> 00:18:46.900
It's not just Python, there's
libraries for Java,

00:18:46.900 --> 00:18:50.458
JavaScript, PHP, Ruby.

00:18:50.458 --> 00:18:54.530
It's quite a few, and
we're creating more.

00:18:54.530 --> 00:18:57.060
So when would you use this?

00:18:57.060 --> 00:18:59.110
Again, when you have too many
facts about an entity, you're

00:18:59.110 --> 00:19:03.500
not sure which ones users are
interested in, you need to

00:19:03.500 --> 00:19:05.720
filter down a little bit more.

00:19:05.720 --> 00:19:08.170
Or also when you have sparse
or undifferentiated data.

00:19:08.170 --> 00:19:12.090
So maybe you have 2 million
topics called "John Smith,"

00:19:12.090 --> 00:19:14.710
and 80% of them don't really
have any interesting data

00:19:14.710 --> 00:19:15.570
associated with them.

00:19:15.570 --> 00:19:18.980
And you're looking for the most
notable, famous ones.

00:19:18.980 --> 00:19:22.190
You can use faceting to narrow
it down that way.

00:19:22.190 --> 00:19:24.640
And mostly, just when you have
so many results that you can't

00:19:24.640 --> 00:19:26.790
provide pages and pages
of results that

00:19:26.790 --> 00:19:28.040
people can go through.

00:19:30.760 --> 00:19:31.870
So as I was talking
about earlier,

00:19:31.870 --> 00:19:33.320
this is Google Refine.

00:19:33.320 --> 00:19:36.730
This is a tool that we built
to clean up messy data.

00:19:36.730 --> 00:19:42.120
And it relies extensively on
faceting to let users drill

00:19:42.120 --> 00:19:44.630
down into large data
sets, hundreds of

00:19:44.630 --> 00:19:47.390
thousands of rows of data.

00:19:47.390 --> 00:19:50.170
And so they can create custom
facets on the left hand side

00:19:50.170 --> 00:19:52.800
there, to drill down
into this data.

00:19:52.800 --> 00:19:55.360
And we actually created this
tool as a way to load entities

00:19:55.360 --> 00:19:57.368
into the Freebase
Knowledge Graph.

00:20:06.830 --> 00:20:08.140
The next pattern we're going
to look at is the

00:20:08.140 --> 00:20:10.950
recommendation pattern.

00:20:10.950 --> 00:20:13.620
So this is when you have a large
Knowledge Graph, and you

00:20:13.620 --> 00:20:17.420
want to encourage people
to explore through it.

00:20:17.420 --> 00:20:19.480
If you have 500 million
entities, how are you going to

00:20:19.480 --> 00:20:23.560
get people to visit all those
entities when they might just

00:20:23.560 --> 00:20:24.860
look for the most
popular ones.

00:20:27.480 --> 00:20:31.490
So the great thing is, because
everything in our graph is a

00:20:31.490 --> 00:20:34.840
node connected with edges, we
know how they're related, and

00:20:34.840 --> 00:20:37.270
we know how closely
they're related.

00:20:37.270 --> 00:20:38.660
So we can actually come
up with meaningful

00:20:38.660 --> 00:20:41.240
recommendations for what other
entities you might be

00:20:41.240 --> 00:20:43.640
interested in, or what other
content you might be

00:20:43.640 --> 00:20:45.270
interested in based
on the entities

00:20:45.270 --> 00:20:47.080
that are being discussed.

00:20:47.080 --> 00:20:49.010
And not only can we say that
they're related, but we can

00:20:49.010 --> 00:20:50.880
even tell you how
they're related.

00:20:50.880 --> 00:20:53.730
So that makes really strong
recommendations for why you

00:20:53.730 --> 00:20:56.640
should check out that
other content.

00:20:56.640 --> 00:20:58.900
We can go back to the example
with the Knowledge Graph here,

00:20:58.900 --> 00:21:01.430
which is what we've done.

00:21:01.430 --> 00:21:03.480
So we say, all right you're
interested in Chuck Norris.

00:21:03.480 --> 00:21:06.240
You might also be interested
in some of the movies or TV

00:21:06.240 --> 00:21:07.750
shows that he's done.

00:21:07.750 --> 00:21:10.670
So we can recommend some of the
most notable ones here.

00:21:10.670 --> 00:21:14.300
And we can actually tell you
that we know they're movies

00:21:14.300 --> 00:21:16.190
and TV shows with
Chuck Norris.

00:21:16.190 --> 00:21:19.380
It's a stronger recommendation
than the one before, which is

00:21:19.380 --> 00:21:22.280
just things that you've
also searched for.

00:21:27.890 --> 00:21:29.980
So when would you use this?

00:21:29.980 --> 00:21:32.470
Like I said, when there are
too many possible ways to

00:21:32.470 --> 00:21:34.190
organize the content.

00:21:34.190 --> 00:21:38.060
You can't just come up with
a single hierarchy for

00:21:38.060 --> 00:21:39.720
browsing the data.

00:21:39.720 --> 00:21:43.460
Especially when you have things,
like music or movies,

00:21:43.460 --> 00:21:47.260
which users have are really
personalized preference for.

00:21:47.260 --> 00:21:51.350
You're going to want to use
recommendation in that case.

00:21:51.350 --> 00:21:56.600
Because there's no single way
to give users the best movie

00:21:56.600 --> 00:21:58.200
for every user without
using recommendation.

00:22:01.730 --> 00:22:02.730
This is one more example.

00:22:02.730 --> 00:22:04.400
This is a service
called ookaboo.

00:22:04.400 --> 00:22:07.240
It's a repository of freely
licensed images

00:22:07.240 --> 00:22:08.890
organized by entity.

00:22:08.890 --> 00:22:12.140
So the data all comes
from Freebase and

00:22:12.140 --> 00:22:14.310
the Wikimedia Commons.

00:22:14.310 --> 00:22:16.510
Every entity in ookaboo
has its own page.

00:22:16.510 --> 00:22:20.270
So here, you can see this page
for F-22 Raptor pictures.

00:22:20.270 --> 00:22:22.700
There's pictures about that
entity, and then over on the

00:22:22.700 --> 00:22:25.800
right hand side, there's related
entities as well.

00:22:25.800 --> 00:22:31.380
So you can see it's not just
keyword matches, it's actually

00:22:31.380 --> 00:22:32.600
related to the same domain.

00:22:32.600 --> 00:22:36.130
So either US Air Force
or F-16, F-35,

00:22:36.130 --> 00:22:38.430
that sort of thing.

00:22:38.430 --> 00:22:41.740
So ookaboo uses Freebase data
to figure out which entities

00:22:41.740 --> 00:22:44.060
might be related.

00:22:44.060 --> 00:22:47.710
And that makes it easier to
explore this large corpus of

00:22:47.710 --> 00:22:50.430
images in interesting ways.

00:22:53.420 --> 00:22:54.880
So those were the interaction
patterns.

00:22:54.880 --> 00:22:58.070
That's how you can kind of dig
through a large amount of

00:22:58.070 --> 00:23:00.220
content using entities.

00:23:00.220 --> 00:23:02.110
Now we're going to look at
presentation patterns, which

00:23:02.110 --> 00:23:04.195
is kind of the last stage
of your application.

00:23:07.640 --> 00:23:10.970
This is how you take this entity
data, present it to the

00:23:10.970 --> 00:23:14.680
user, show them that you know
which things they're talking

00:23:14.680 --> 00:23:16.880
about, which things they care
about, and let them do

00:23:16.880 --> 00:23:18.700
interesting things with that.

00:23:18.700 --> 00:23:23.550
It's not just a shiny,
distraction visualization.

00:23:23.550 --> 00:23:26.490
All this data coming from the
graph is real, factual data.

00:23:26.490 --> 00:23:28.080
So when you're putting that on
the screen, that's really

00:23:28.080 --> 00:23:31.180
helping the user out and
showing them something

00:23:31.180 --> 00:23:34.440
interesting about
these topics.

00:23:34.440 --> 00:23:37.970
This is really the key to using
a Knowledge Graph with

00:23:37.970 --> 00:23:41.530
existing content or user
generated content by being

00:23:41.530 --> 00:23:44.290
able to mash it up with the data
from the Knowledge Graph.

00:23:44.290 --> 00:23:46.045
So let's see some examples
of how that works.

00:23:48.690 --> 00:23:53.270
So the first pattern is
the simplest one.

00:23:53.270 --> 00:23:56.050
This is a summarization
pattern.

00:23:56.050 --> 00:23:59.610
And this is just when we want
to describe an entity.

00:23:59.610 --> 00:24:03.310
So the user has done a search
for something, or the user has

00:24:03.310 --> 00:24:05.500
selected something from
Freebase suggest.

00:24:05.500 --> 00:24:07.820
And we want to give them that
confirmation that we know

00:24:07.820 --> 00:24:09.280
which entity they're
talking about.

00:24:09.280 --> 00:24:12.310
And we need to come up with a
short, concise description of

00:24:12.310 --> 00:24:13.560
what it is.

00:24:16.070 --> 00:24:23.020
So the solution is to show
things like image description,

00:24:23.020 --> 00:24:30.250
disambiguating properties like
date of birth, what year a

00:24:30.250 --> 00:24:31.070
movie came out in.

00:24:31.070 --> 00:24:35.530
Sometimes there's multiple
movies with the same name, but

00:24:35.530 --> 00:24:39.720
came in different years,
remakes, that sort of thing.

00:24:39.720 --> 00:24:43.140
So let's see an example
of how that works.

00:24:43.140 --> 00:24:45.240
So you'll recognize
this is Freebase

00:24:45.240 --> 00:24:48.280
Suggest, like we had before.

00:24:48.280 --> 00:24:51.990
But we're actually going to use
brand new Freebase topic

00:24:51.990 --> 00:24:58.380
API, which we're launching today
to get a nice, little

00:24:58.380 --> 00:25:00.210
summary of that topic.

00:25:00.210 --> 00:25:04.030
So let's look for "Chuck
Norris." You can see it's

00:25:04.030 --> 00:25:07.080
suggesting entities here.

00:25:07.080 --> 00:25:09.530
And this is all live, this is
going off of the Freebase

00:25:09.530 --> 00:25:11.260
Knowledge Graph right now.

00:25:11.260 --> 00:25:13.990
So you can try this yourself.

00:25:13.990 --> 00:25:16.720
So we'll select first
result there.

00:25:16.720 --> 00:25:18.260
Looks like the right one.

00:25:18.260 --> 00:25:21.910
You can see it's provided a
little summary here for us.

00:25:21.910 --> 00:25:28.290
But we actually used the topic
API with some jQuery.

00:25:28.290 --> 00:25:32.470
I didn't show the whole code
snippet here, but you can do

00:25:32.470 --> 00:25:36.800
view source on the slides to see
how you build this little

00:25:36.800 --> 00:25:39.880
topic summary to confirm with
the user that this is actually

00:25:39.880 --> 00:25:41.130
the entity that they're
talking about.

00:25:48.390 --> 00:25:51.640
So when would we use this?

00:25:51.640 --> 00:25:54.860
When we have content that needs
to be put in context.

00:25:54.860 --> 00:25:58.870
So we'll see an example
of that in a second.

00:25:58.870 --> 00:26:03.320
But, basically, when you want
to say, this article or this

00:26:03.320 --> 00:26:05.910
video talks about the
specific content.

00:26:05.910 --> 00:26:10.270
Not just a tag like "John
Smith," but an actual entity

00:26:10.270 --> 00:26:14.530
that you can click on and find
out more information about.

00:26:14.530 --> 00:26:16.800
And also, when we want to
encourage users to navigate

00:26:16.800 --> 00:26:18.800
the site in a way which
relates to entities.

00:26:18.800 --> 00:26:24.450
So we've seen this with search,
when we start showing

00:26:24.450 --> 00:26:26.210
the knowledge cards.

00:26:26.210 --> 00:26:28.880
People started clicking a lot
on all those blue links,

00:26:28.880 --> 00:26:32.080
navigating search in new ways
based on things in the

00:26:32.080 --> 00:26:35.220
relationships between things,
rather than just

00:26:35.220 --> 00:26:38.590
searching by keyword.

00:26:38.590 --> 00:26:41.700
So this is an example from
the Wall Street Journal.

00:26:41.700 --> 00:26:46.280
And they're using Freebase
data to add that sort of

00:26:46.280 --> 00:26:49.440
navigation structure
to their content.

00:26:49.440 --> 00:26:53.260
So this is an article that
does their weekly movie

00:26:53.260 --> 00:26:57.360
reviews, and there's four
different movies, all being

00:26:57.360 --> 00:26:58.255
reviewed in this article.

00:26:58.255 --> 00:27:01.130
But you can see on the right
hand side here, they have a

00:27:01.130 --> 00:27:03.410
little summary of each entity.

00:27:03.410 --> 00:27:04.820
That data's all coming
from Freebase.

00:27:04.820 --> 00:27:07.070
And that gives you a quick
snapshot of which entities are

00:27:07.070 --> 00:27:09.350
being talked about
in this article.

00:27:09.350 --> 00:27:11.560
But it also lets you click
through to find out more

00:27:11.560 --> 00:27:15.140
information about the director
or related reviews.

00:27:15.140 --> 00:27:17.410
So this is a great way that they
can encourage their users

00:27:17.410 --> 00:27:20.880
to navigate their content based
on the entities that are

00:27:20.880 --> 00:27:22.870
being discussed.

00:27:22.870 --> 00:27:26.360
I should also mention that none
of this would be possible

00:27:26.360 --> 00:27:28.440
if they hadn't reconciled
their entities.

00:27:28.440 --> 00:27:32.040
So that first reconciliation
pattern that we saw in the

00:27:32.040 --> 00:27:35.420
discovery patterns at
the beginning--

00:27:35.420 --> 00:27:38.870
They're only able to display
these recommendations and

00:27:38.870 --> 00:27:42.540
these entities because they've
matched all the things in

00:27:42.540 --> 00:27:44.935
their knowledge base to the
things in Freebase.

00:27:48.920 --> 00:27:52.200
It's also a great example of a
mashup pattern, which is what

00:27:52.200 --> 00:27:54.330
we're going to see next.

00:27:54.330 --> 00:27:57.230
Where they're combining their
content with content from the

00:27:57.230 --> 00:28:00.430
Knowledge Graph.

00:28:00.430 --> 00:28:03.240
So the mashup pattern.

00:28:03.240 --> 00:28:07.240
The mashup pattern is when a
user wants to see different

00:28:07.240 --> 00:28:10.850
types of information about
this same entity.

00:28:10.850 --> 00:28:16.780
So it could be that they want to
know, videos from YouTube,

00:28:16.780 --> 00:28:20.420
text from Wikipedia, facts
from Freebase.

00:28:20.420 --> 00:28:24.620
They want to mash that all up
in one location and see

00:28:24.620 --> 00:28:27.320
everything there is to know
about this entity.

00:28:27.320 --> 00:28:32.530
Or it could all be from the same
source, but it could be

00:28:32.530 --> 00:28:35.110
different perspectives
on the same entity.

00:28:35.110 --> 00:28:39.510
So some entities, some people,
are also politicians, are also

00:28:39.510 --> 00:28:41.390
authors, have also appeared
in films.

00:28:41.390 --> 00:28:45.700
And you might want to break that
down by different genres,

00:28:45.700 --> 00:28:48.390
different perspectives
on the same entity.

00:28:48.390 --> 00:28:52.140
The problem is, it's hard to
combine this data from all

00:28:52.140 --> 00:28:55.410
these different sources if
you're not using strong

00:28:55.410 --> 00:28:55.990
identifiers.

00:28:55.990 --> 00:28:59.660
If you just do a keyword search
on YouTube for your

00:28:59.660 --> 00:29:02.470
John Smith entity, you're not
going to get back high

00:29:02.470 --> 00:29:06.650
quality, relevant data that
you could mash up with

00:29:06.650 --> 00:29:09.050
whatever you found with the
keyword search for John Smith

00:29:09.050 --> 00:29:09.940
on Wikipedia.

00:29:09.940 --> 00:29:12.980
But if you have strong
identifiers, ways to link that

00:29:12.980 --> 00:29:18.570
together, you can create
really good mashups.

00:29:18.570 --> 00:29:24.850
So the solution is to create
those links, either through

00:29:24.850 --> 00:29:28.230
manual reconciliation or those
automatic reconciliation

00:29:28.230 --> 00:29:30.770
algorithms we saw.

00:29:30.770 --> 00:29:36.120
Or, to use existing links in
a source like Freebase.

00:29:36.120 --> 00:29:38.430
And this encourages users to
jump between the different

00:29:38.430 --> 00:29:42.640
contexts for that same entity.

00:29:42.640 --> 00:29:45.090
When they know that they can
rely on it being the exact

00:29:45.090 --> 00:29:49.300
same topic, they're more
likely to click around.

00:29:49.300 --> 00:29:52.170
So let's see an example here.

00:29:52.170 --> 00:29:58.310
This is seevl, which is a Chrome
extension that works

00:29:58.310 --> 00:29:59.320
with YouTube.

00:29:59.320 --> 00:30:03.520
And so what seevl's done is,
when you go to YouTube, when

00:30:03.520 --> 00:30:08.460
you're looking at say, a music
video, they'll reconcile that

00:30:08.460 --> 00:30:11.850
to the artist in Freebasee,
figure out which artist you're

00:30:11.850 --> 00:30:14.680
talking about, and then display
some recommendations

00:30:14.680 --> 00:30:16.840
here on the side.

00:30:16.840 --> 00:30:25.240
Additional videos, facts about
it, and links to more

00:30:25.240 --> 00:30:28.940
information about that artist.

00:30:28.940 --> 00:30:32.030
They're able to make really
strong recommendations using

00:30:32.030 --> 00:30:34.360
the recommendation pattern,
because they have that

00:30:34.360 --> 00:30:39.070
information in the Freebase
graph about how this artist

00:30:39.070 --> 00:30:40.320
relates to other artists.

00:30:43.620 --> 00:30:46.440
So this is an example, using
that topic API that I showed

00:30:46.440 --> 00:30:49.750
you earlier, of how to just go
into Freebase and get all

00:30:49.750 --> 00:30:53.800
these identifiers So right here,
we're looking up San

00:30:53.800 --> 00:30:57.250
Francisco, and we're saying,
give me all the foreign keys,

00:30:57.250 --> 00:30:59.820
all these identifiers on other
sites that you know about for

00:30:59.820 --> 00:31:01.880
San Francisco.

00:31:01.880 --> 00:31:06.870
And so we have a number of
different key sources.

00:31:06.870 --> 00:31:09.780
It's going to return
the Wikipedia URL.

00:31:09.780 --> 00:31:15.980
t's going to return a number of
different sources that all

00:31:15.980 --> 00:31:19.210
talk about that San Francisco
entity, and not just things

00:31:19.210 --> 00:31:20.640
that match the San Francisco
keyword.

00:31:26.610 --> 00:31:29.140
So when would you use this?

00:31:29.140 --> 00:31:30.970
When you need to see information
from different

00:31:30.970 --> 00:31:35.030
perspectives, and when you
need to mashup data from

00:31:35.030 --> 00:31:37.560
different sources.

00:31:37.560 --> 00:31:40.640
So when you can't get all the
information from one source,

00:31:40.640 --> 00:31:43.070
you need to combine it
on your website.

00:31:43.070 --> 00:31:45.050
You need to be able to have
these identifiers to look it

00:31:45.050 --> 00:31:47.640
up on other websites.

00:31:47.640 --> 00:31:51.890
A great resource for this is
a site called sameas.org.

00:31:51.890 --> 00:31:54.590
Sameas.org is a data hub that
links together all these

00:31:54.590 --> 00:31:57.070
different data sets
on the web.

00:31:57.070 --> 00:32:00.070
It's completely open, so anyone
who owns a data set can

00:32:00.070 --> 00:32:04.430
contribute their links
to this data set.

00:32:04.430 --> 00:32:07.330
So Freebase has contributed
all their entity IDs to

00:32:07.330 --> 00:32:08.770
sameas.org.

00:32:08.770 --> 00:32:10.200
There's a simple JSON API.

00:32:10.200 --> 00:32:16.560
So you can see here, I've looked
up the Freebase RDF URL

00:32:16.560 --> 00:32:19.470
for the San Francisco topic
we were just looking at.

00:32:19.470 --> 00:32:22.840
And its returned a list of all
the equivalent identifiers on

00:32:22.840 --> 00:32:23.930
the web for that entity.

00:32:23.930 --> 00:32:30.350
So the identifiers at New York
Times, you can see ookaboo's

00:32:30.350 --> 00:32:34.140
in there, GeoNames, Wikipedia.

00:32:37.030 --> 00:32:38.540
There's quite a few data
sets, and they're

00:32:38.540 --> 00:32:39.790
always adding more.

00:32:39.790 --> 00:32:42.250
So this is a great example of
how you can easily combine

00:32:42.250 --> 00:32:45.700
data from different sources
once you have those entity

00:32:45.700 --> 00:32:46.950
identifiers.

00:32:50.680 --> 00:32:52.110
Last pattern we're going
to look at is the

00:32:52.110 --> 00:32:54.200
visualization pattern.

00:32:54.200 --> 00:32:57.600
And this is when you have many
different entities that you

00:32:57.600 --> 00:32:58.850
want to display.

00:33:00.710 --> 00:33:03.720
More than just the four entities
that you saw in that

00:33:03.720 --> 00:33:05.250
Wall Street Journal article.

00:33:05.250 --> 00:33:08.230
What if you have 40, how
do you display those?

00:33:08.230 --> 00:33:11.980
And also, the different entities
on the Wall Street

00:33:11.980 --> 00:33:15.170
Journal article were only
related because they came out

00:33:15.170 --> 00:33:15.840
in the same week.

00:33:15.840 --> 00:33:17.890
But what if there's more
meaningful relationships

00:33:17.890 --> 00:33:19.000
between the entities?

00:33:19.000 --> 00:33:21.760
How do you show the
relationships as well as the

00:33:21.760 --> 00:33:24.300
facts and the image related
to those entities?

00:33:28.730 --> 00:33:31.140
So there are number of different
solutions to this,

00:33:31.140 --> 00:33:34.810
but basically, you can use data
visualization techniques

00:33:34.810 --> 00:33:38.830
to display a lot of entities at
the same time, while also

00:33:38.830 --> 00:33:42.150
keeping some of the semantics
about how they're related.

00:33:42.150 --> 00:33:47.230
So for example, if you have
families or organizations with

00:33:47.230 --> 00:33:49.960
people in it, you can visualize
that as a tree.

00:33:49.960 --> 00:33:51.800
If you have places or
events, you can

00:33:51.800 --> 00:33:54.270
visualize that on a map.

00:33:54.270 --> 00:33:56.450
Events can also be vizualized
on a timeline, as

00:33:56.450 --> 00:33:59.360
we'll see in a second.

00:33:59.360 --> 00:34:00.840
One of the easiest ways
is, you can just

00:34:00.840 --> 00:34:02.090
visualize it as a graph.

00:34:02.090 --> 00:34:04.410
So that slide I showed you at
the beginning, where Chuck

00:34:04.410 --> 00:34:09.960
Norris is a node connected to
other nodes with edges, that's

00:34:09.960 --> 00:34:12.770
one way of visualizing it.

00:34:12.770 --> 00:34:16.540
And also, bubble charts are a
really interesting way to

00:34:16.540 --> 00:34:21.150
visualize a lot of information
about entities when there's no

00:34:21.150 --> 00:34:25.190
easier way to do it, like
maps or timelines.

00:34:25.190 --> 00:34:26.510
So this is Thinkbase.

00:34:26.510 --> 00:34:28.449
This is an interface
that someone

00:34:28.449 --> 00:34:30.920
built on top of Freebase.

00:34:30.920 --> 00:34:33.270
I'd encourage you to check
it out afterwards.

00:34:33.270 --> 00:34:36.070
There's a link there
at the bottom.

00:34:36.070 --> 00:34:38.644
It's an interactive interface
to Freebase.

00:34:41.179 --> 00:34:44.980
So here I've looked up
Prometheus, the movie, and

00:34:44.980 --> 00:34:47.500
it's expanded a number of the
relationships for me.

00:34:47.500 --> 00:34:50.389
And I can see the different
related

00:34:50.389 --> 00:34:52.010
entities, how they're related.

00:34:52.010 --> 00:34:56.264
I can click on those to explore
what other entities

00:34:56.264 --> 00:34:58.010
are related to those.

00:34:58.010 --> 00:35:01.790
So it's a really interesting
way to explore the data.

00:35:01.790 --> 00:35:04.290
If you get to some really dense
topics, like United

00:35:04.290 --> 00:35:07.260
States, that have a lot of
entities connected to them, it

00:35:07.260 --> 00:35:09.930
can get a little
bit confusing.

00:35:09.930 --> 00:35:12.980
But in most cases, it's pretty
cool way to navigate.

00:35:16.970 --> 00:35:19.540
So we use visualization patterns
when it's important

00:35:19.540 --> 00:35:21.410
to be able to see the
relationships between multiple

00:35:21.410 --> 00:35:23.510
entities at the same time.

00:35:23.510 --> 00:35:26.330
And like I said, when there's
far too many different

00:35:26.330 --> 00:35:29.350
entities that we want to show to
be able to just list them,

00:35:29.350 --> 00:35:31.990
like you saw in the Wall
Street Journal article.

00:35:31.990 --> 00:35:34.980
The last example I want to show
you here is an amazing

00:35:34.980 --> 00:35:37.290
site called conflict history.

00:35:37.290 --> 00:35:40.930
Again, they're using Freebase
data to mashup a lot of

00:35:40.930 --> 00:35:45.120
different entities about
different military conflicts

00:35:45.120 --> 00:35:47.420
over the centuries.

00:35:47.420 --> 00:35:51.960
And actually, you can see
here, they've got a map.

00:35:51.960 --> 00:35:54.860
So they've plotted all these
different events on a map, but

00:35:54.860 --> 00:35:58.610
they're also plotting them on
a timeline at the same time.

00:35:58.610 --> 00:36:01.497
So let me see if I can just
open that up here.

00:36:30.380 --> 00:36:33.230
This is actually a great example
of using a lot of

00:36:33.230 --> 00:36:34.810
these different visualization
techniques

00:36:34.810 --> 00:36:36.060
together in the same app.

00:36:39.470 --> 00:36:42.590
So here we can see that that map
is pulling data out of the

00:36:42.590 --> 00:36:44.960
Knowledge Graph, planting
it on the map.

00:36:44.960 --> 00:36:47.600
We've also got this timeline.

00:36:47.600 --> 00:36:50.650
So we can drag the window
at the bottom.

00:36:50.650 --> 00:36:55.290
Or we can expand it, as well, to
see military conflicts that

00:36:55.290 --> 00:36:59.970
happened in this time period and
in this part of the world.

00:36:59.970 --> 00:37:03.270
We can hover over any of the
entities, and you can see it's

00:37:03.270 --> 00:37:05.240
pointing to the item
in the list that

00:37:05.240 --> 00:37:08.500
corresponds to this conflict.

00:37:08.500 --> 00:37:10.815
And then, you can actually go
here and click on "more

00:37:10.815 --> 00:37:14.970
information," and they're using
that mashup pattern to

00:37:14.970 --> 00:37:18.060
pull in data from Wikipedia
using those identifiers in

00:37:18.060 --> 00:37:22.010
Freebase to tell you more about
the Battle of Ty-ho Bay.

00:37:36.290 --> 00:37:39.970
So to sum things up here, we
first looked at discovery

00:37:39.970 --> 00:37:42.140
patterns, which was a way to
surface entities in your

00:37:42.140 --> 00:37:42.990
application.

00:37:42.990 --> 00:37:47.620
To take this the strings or
the input that the user is

00:37:47.620 --> 00:37:49.780
giving you, and convert
that into things.

00:37:49.780 --> 00:37:52.180
We then looked at interaction
patterns, which is a way to

00:37:52.180 --> 00:37:55.600
navigate through a Knowledge
Graph to facet, or to make

00:37:55.600 --> 00:37:58.160
recommendations based on what
you think the user might be

00:37:58.160 --> 00:37:59.320
interested in.

00:37:59.320 --> 00:38:02.620
And then we finished with
presentation patterns as a way

00:38:02.620 --> 00:38:06.400
to create informative user
interfaces and surface those

00:38:06.400 --> 00:38:08.520
entities in your content.

00:38:08.520 --> 00:38:13.310
So I hope that this encourages
you to consider adding entity

00:38:13.310 --> 00:38:16.240
data to your application,
consider building applications

00:38:16.240 --> 00:38:20.220
on top of Freebase or other
Knowledge Graphs.

00:38:20.220 --> 00:38:24.650
And I've put together a list of
links here to the APIs that

00:38:24.650 --> 00:38:28.360
I mentioned, to some of the code
libraries, and also tools

00:38:28.360 --> 00:38:31.840
like Google Refine and DBPedia
Spotlight, so you can dig in

00:38:31.840 --> 00:38:33.410
and try out some of these
examples that

00:38:33.410 --> 00:38:35.870
I've showed you today.

00:38:35.870 --> 00:38:38.690
And this is not just for
creating new apps, this is

00:38:38.690 --> 00:38:42.870
also a great way to extend
existing apps and create new

00:38:42.870 --> 00:38:45.290
ways of exploring data that
you've already collected.

00:38:48.560 --> 00:38:50.720
So thank you very much
for coming out.

00:38:50.720 --> 00:38:58.810
[APPLAUSE]

00:38:58.810 --> 00:39:00.680
I've put a copy of
the slides at

00:39:00.680 --> 00:39:03.090
knowledgedesignpatterns.com, so
you can check out all the

00:39:03.090 --> 00:39:06.240
examples, click through
to all the links.

00:39:06.240 --> 00:39:10.685
This is my Google+ profile, so
feel free to follow me and ask

00:39:10.685 --> 00:39:11.780
me questions.

00:39:11.780 --> 00:39:14.260
I know, but if you go to
the URL, then you can

00:39:14.260 --> 00:39:16.020
click on the link.

00:39:16.020 --> 00:39:18.290
And you can also follow me on
Twitter, which is a little bit

00:39:18.290 --> 00:39:20.260
shorter, I guess.

00:39:20.260 --> 00:39:22.920
So I'm going to invite my
colleague Mike Masouras up

00:39:22.920 --> 00:39:24.520
here on stage.

00:39:24.520 --> 00:39:26.280
Michael works on Freebase
and the Knowledge

00:39:26.280 --> 00:39:28.140
Graph here at Google.

00:39:28.140 --> 00:39:31.020
And we'd have to take any of
your questions, or we'll be

00:39:31.020 --> 00:39:35.340
hanging around here afterwards
if you have more questions.

00:39:35.340 --> 00:39:38.700
We have microphones here and in
the aisles, if you would.

00:39:50.640 --> 00:39:53.150
AUDIENCE: I am not all that
familiar with Freebase,

00:39:53.150 --> 00:39:54.040
although it looks great.

00:39:54.040 --> 00:39:57.330
I was just wondering, is there
the concept of a schema when

00:39:57.330 --> 00:39:58.940
you have something of
a certain type?

00:39:58.940 --> 00:40:00.850
Like you showed all these movies
on the Wall Street

00:40:00.850 --> 00:40:01.870
Journal site.

00:40:01.870 --> 00:40:04.480
Are they able to assume
there's going to be a

00:40:04.480 --> 00:40:07.510
director, and producer, and
actors and actresses, and

00:40:07.510 --> 00:40:14.550
stuff, or is there not really
that sort of structure to the

00:40:14.550 --> 00:40:15.840
information?

00:40:15.840 --> 00:40:16.380
SHAWN SIMISTER: Yeah,
absolutely.

00:40:16.380 --> 00:40:22.550
So every entity in Freebase
can have one or more types

00:40:22.550 --> 00:40:23.530
applied to it.

00:40:23.530 --> 00:40:27.830
And the types are actually nodes
in the graph as well.

00:40:27.830 --> 00:40:31.180
So you can go to Freebase, and
you can look up that people

00:40:31.180 --> 00:40:34.650
person type, or the movie type,
or the director type,

00:40:34.650 --> 00:40:38.010
and you can see which properties
are suggested for

00:40:38.010 --> 00:40:40.460
that type of entity.

00:40:40.460 --> 00:40:44.260
And so yeah, it's really cool
the way that the topics, and

00:40:44.260 --> 00:40:46.690
the types, and the properties
are all modeled as

00:40:46.690 --> 00:40:47.360
nodes in the graph.

00:40:47.360 --> 00:40:51.040
And you can query any of
them using the APIs.

00:40:51.040 --> 00:40:52.160
AUDIENCE: That sounds
very open-ended.

00:40:52.160 --> 00:40:54.940
I was wondering, though, is it
that there's a structure,

00:40:54.940 --> 00:40:57.100
something that is a movie is
going to have certain types

00:40:57.100 --> 00:40:58.970
filled in, or else it's
just considered

00:40:58.970 --> 00:41:00.170
an incomplete record.

00:41:00.170 --> 00:41:02.090
And maybe you could filter that
out in your results and

00:41:02.090 --> 00:41:06.030
say, only give me the ones
that have been properly--

00:41:06.030 --> 00:41:08.380
is there a constraint,
sort of?

00:41:08.380 --> 00:41:12.000
SHAWN SIMISTER: Yeah, so there
aren't any really hard

00:41:12.000 --> 00:41:15.130
constraints on which properties
have to be there.

00:41:15.130 --> 00:41:16.950
Because this data's coming from
a number of different

00:41:16.950 --> 00:41:21.610
sources, we can never really
guarantee that every book we

00:41:21.610 --> 00:41:25.540
find is going to have the
author, or every film we have

00:41:25.540 --> 00:41:28.070
is going to have the
release date on it.

00:41:28.070 --> 00:41:30.710
But that's the value of having
kind of a crowd source

00:41:30.710 --> 00:41:32.930
knowledge base, like Freebase,
is that people can come along

00:41:32.930 --> 00:41:34.730
afterwards and fill
in those facts.

00:41:34.730 --> 00:41:36.780
So all the types have properties
associated with

00:41:36.780 --> 00:41:39.090
them, but they're
not required.

00:41:39.090 --> 00:41:41.490
AUDIENCE: Gotcha.

00:41:41.490 --> 00:41:42.060
AUDIENCE: Yes, hi.

00:41:42.060 --> 00:41:46.030
I was wondering if there's any
kind of call back API.

00:41:46.030 --> 00:41:49.180
So as this data changes,
is there any way to

00:41:49.180 --> 00:41:52.540
subscribe to that?

00:41:52.540 --> 00:41:56.090
SHAWN SIMISTER: There's no
specific API to do it, but one

00:41:56.090 --> 00:42:03.020
of the things we have in our
MQL search API is, you can

00:42:03.020 --> 00:42:05.070
query based on a time stamp.

00:42:05.070 --> 00:42:07.210
So you can say, give me all the
things that have changed

00:42:07.210 --> 00:42:09.120
since this time stamp.

00:42:09.120 --> 00:42:11.320
So that's one way of doing it.

00:42:11.320 --> 00:42:14.450
It won't ping you when it's
done, you have to kind

00:42:14.450 --> 00:42:16.710
of pull that data.

00:42:16.710 --> 00:42:20.040
But all the time stamps for
every fact, for every topic

00:42:20.040 --> 00:42:21.930
when it was created, are
recorded in the graph.

00:42:21.930 --> 00:42:24.210
And you can query that
through the APIs

00:42:24.210 --> 00:42:24.846
AUDIENCE: Thank you.

00:42:24.846 --> 00:42:27.030
SHAWN SIMISTER: You're
welcome.

00:42:27.030 --> 00:42:30.030
AUDIENCE: This is a little bit
of a high level question.

00:42:30.030 --> 00:42:35.150
I attended some or your
presentation at Freeweb and

00:42:35.150 --> 00:42:36.760
the RDF thing.

00:42:36.760 --> 00:42:40.353
With the emergence of all these
platforms, you always

00:42:40.353 --> 00:42:43.300
see an implication that you must
use this data to display

00:42:43.300 --> 00:42:47.650
and certainly increase the power
of your presentations.

00:42:47.650 --> 00:42:50.760
But are there any projects that
are trying to use this to

00:42:50.760 --> 00:42:54.055
do some sort of reasoning?

00:42:54.055 --> 00:42:57.690
The most obvious thing would be
something like Siri where

00:42:57.690 --> 00:43:01.190
we're actually trying to
actively answer a question or

00:43:01.190 --> 00:43:02.460
help the user.

00:43:02.460 --> 00:43:06.160
Is there anything like that?

00:43:06.160 --> 00:43:08.190
SHAWN SIMISTER: Yeah, the stuff
that you saw in the

00:43:08.190 --> 00:43:10.730
keynote on Wednesday
was powered by

00:43:10.730 --> 00:43:12.350
Google's Knowledge Graph.

00:43:12.350 --> 00:43:12.960
AUDIENCE: OK.

00:43:12.960 --> 00:43:14.170
So you're doing it.

00:43:14.170 --> 00:43:17.660
But these projects are internal,
so there's no

00:43:17.660 --> 00:43:21.380
outside developers trying to
do that based on these new

00:43:21.380 --> 00:43:22.630
data platforms.

00:43:25.010 --> 00:43:26.150
MICHAEL MASOURAS: We don't
actually start this

00:43:26.150 --> 00:43:26.780
relationship.

00:43:26.780 --> 00:43:28.210
So if you want to do
inference, you

00:43:28.210 --> 00:43:29.830
have to do it yourself.

00:43:29.830 --> 00:43:31.760
But there's other projects
out there, like

00:43:31.760 --> 00:43:33.940
CYC are more academic.

00:43:33.940 --> 00:43:36.220
And they are trying to model,
actually, intelligence and

00:43:36.220 --> 00:43:38.690
relationships in the real
world between things

00:43:38.690 --> 00:43:38.790
AUDIENCE: OK.

00:43:38.790 --> 00:43:39.060
Academic.

00:43:39.060 --> 00:43:39.150
OK.

00:43:39.150 --> 00:43:39.710
Thank you.

00:43:39.710 --> 00:43:41.720
SHAWN SIMISTER: I know there's
actually a start up, True

00:43:41.720 --> 00:43:44.700
Knowledge, that does question
answering based

00:43:44.700 --> 00:43:46.120
on a Knowledge Graph.

00:43:46.120 --> 00:43:48.490
And they use data from Freebase
to be able to do that

00:43:48.490 --> 00:43:49.740
question answering.

00:43:52.220 --> 00:43:53.900
AUDIENCE: So you mentioned
that anyone can

00:43:53.900 --> 00:43:55.680
contribute to Freebase.

00:43:55.680 --> 00:43:58.110
So you have your app and
you start getting

00:43:58.110 --> 00:44:00.200
information from Freebase.

00:44:00.200 --> 00:44:03.930
Maybe you store in your database
some IDs of entities

00:44:03.930 --> 00:44:05.790
that you're users
have been using.

00:44:05.790 --> 00:44:10.550
What happens when Freebase gets
updated and an entity

00:44:10.550 --> 00:44:12.160
gets deleted from Freebase.

00:44:12.160 --> 00:44:14.400
But you already have an idea,
and then you do a query.

00:44:14.400 --> 00:44:18.180
And the entity's not there, or
maybe the entity was merged

00:44:18.180 --> 00:44:19.170
with another entity.

00:44:19.170 --> 00:44:23.290
So what happens with the
updates on that?

00:44:23.290 --> 00:44:25.150
SHAWN SIMISTER: So there
are a number of

00:44:25.150 --> 00:44:27.260
different parts to that.

00:44:27.260 --> 00:44:29.240
The first is that, we recommend
that if you're

00:44:29.240 --> 00:44:32.540
building an application, you
just store the Freebase ID in

00:44:32.540 --> 00:44:36.140
your database and whatever other
data you're going to add

00:44:36.140 --> 00:44:37.440
to that entity.

00:44:37.440 --> 00:44:39.770
But if you cache some of the
Freebase data locally, then it

00:44:39.770 --> 00:44:41.620
gets very complicated.

00:44:41.620 --> 00:44:44.220
So it is preferable to just
store the ID and then pull it

00:44:44.220 --> 00:44:45.920
live from Freebase.

00:44:45.920 --> 00:44:48.240
But again, there is still the
issue of, what if it gets

00:44:48.240 --> 00:44:51.530
deleted, what if it gets merged
or changed in some way.

00:44:51.530 --> 00:44:55.700
Because a lot of entities do
split and merge over time.

00:44:55.700 --> 00:44:57.450
And we actually store all those

00:44:57.450 --> 00:44:59.320
relationships in the graph.

00:44:59.320 --> 00:45:04.810
So if an entity gets merged with
another one, if you call

00:45:04.810 --> 00:45:07.800
up at that previous identifier
through the API, you'll get

00:45:07.800 --> 00:45:09.840
redirected to the new entity.

00:45:09.840 --> 00:45:12.650
So, as much as we can, we handle
that in the graph.

00:45:12.650 --> 00:45:15.240
MICHAEL MASOURAS: And to add to
that, the Freebase graph is

00:45:15.240 --> 00:45:17.440
append only, which means the
entire history of the graph is

00:45:17.440 --> 00:45:19.100
available to you in Query BOL.

00:45:19.100 --> 00:45:20.810
So at any point, you can
actually find out what

00:45:20.810 --> 00:45:23.400
happened to any entity,
or any piece of data.

00:45:23.400 --> 00:45:24.650
AUDIENCE: That's cool, thanks.

00:45:28.450 --> 00:45:32.000
AUDIENCE: The edges between
nodes, are they just sort of

00:45:32.000 --> 00:45:34.100
like there's only one kind
of relationship?

00:45:34.100 --> 00:45:37.380
Or are there more than
just like is a--?

00:45:37.380 --> 00:45:42.982
You mentioned the moderator
nodes, which I guess, can act

00:45:42.982 --> 00:45:45.490
as that sort of function.

00:45:45.490 --> 00:45:46.960
SHAWN SIMISTER: There are
thousands of different types

00:45:46.960 --> 00:45:48.650
of properties, relationships.

00:45:51.470 --> 00:45:54.560
Go back to the beginning,
here.

00:45:54.560 --> 00:45:57.970
You can see here, I've labeled
the different edges.

00:45:57.970 --> 00:46:01.890
AUDIENCE: The coloring
is hard to see there.

00:46:01.890 --> 00:46:03.490
Earlier--

00:46:03.490 --> 00:46:05.910
SHAWN SIMISTER: Yeah,
if you go to

00:46:05.910 --> 00:46:08.250
knowledgedesignpatterns.com,
you can zoom in on that a

00:46:08.250 --> 00:46:09.430
little bit more.

00:46:09.430 --> 00:46:11.250
But we have thousands of
different types of

00:46:11.250 --> 00:46:13.600
edges in the graph.

00:46:13.600 --> 00:46:15.930
There's all schema
for each of them.

00:46:15.930 --> 00:46:18.050
AUDIENCE: Do you know
if any of those more

00:46:18.050 --> 00:46:22.060
academically-oriented projects
are using this for seeding

00:46:22.060 --> 00:46:26.510
formal ontology construction,
or anything like that?

00:46:26.510 --> 00:46:27.760
SHAWN SIMISTER: Off the
top of my head--

00:46:30.410 --> 00:46:31.660
MICHAEL MASOURAS: I
think CYC and--

00:46:35.526 --> 00:46:39.930
SHAWN SIMISTER: We have
a Freebase group on

00:46:39.930 --> 00:46:42.900
mendeley.com, and there's a
collection of, like, over 100

00:46:42.900 --> 00:46:45.790
papers now of people who are
using Freebase data in an

00:46:45.790 --> 00:46:47.390
academic setting.

00:46:47.390 --> 00:46:49.730
So I know there's a lot of
natural language programming

00:46:49.730 --> 00:46:52.210
stuff, and some people that have
done things around schema

00:46:52.210 --> 00:46:53.270
and ontology.

00:46:53.270 --> 00:46:55.550
But I can't think of anything
off the top of my head.

00:46:55.550 --> 00:46:56.032
AUDIENCE: OK.

00:46:56.032 --> 00:46:58.930
Thanks.

00:46:58.930 --> 00:46:59.690
AUDIENCE: Hi.

00:46:59.690 --> 00:47:04.800
How often is the data in
Freebase being updated?

00:47:04.800 --> 00:47:06.840
Like, are you guys pulling
in data constantly?

00:47:06.840 --> 00:47:10.540
Like, if I go update a Wikipedia
page, how long does

00:47:10.540 --> 00:47:12.810
it take before that
information makes

00:47:12.810 --> 00:47:14.790
its way into Freebase?

00:47:14.790 --> 00:47:15.850
SHAWN SIMISTER: Right,
so there's a lot

00:47:15.850 --> 00:47:17.800
of different sources.

00:47:17.800 --> 00:47:21.230
Obviously, the user
contributions are real time.

00:47:21.230 --> 00:47:25.390
So some of those parts of my
presentation were live and

00:47:25.390 --> 00:47:29.580
someone might have changed that
data as I was speaking.

00:47:29.580 --> 00:47:31.300
Luckily, that didn't happen.

00:47:31.300 --> 00:47:37.420
But the Wikipedia data, I
believe, comes in weekly now.

00:47:37.420 --> 00:47:39.470
So we have a process that
looks for new topics and

00:47:39.470 --> 00:47:43.420
Wikipedia automatically extracts
them, cleans them up,

00:47:43.420 --> 00:47:45.850
and imports them
into Freebase.

00:47:45.850 --> 00:47:49.760
There's also a little bit of
a lag, in that, we'll only

00:47:49.760 --> 00:47:51.730
important new topics if they've
been filled out a

00:47:51.730 --> 00:47:53.440
certain amount to try
and prevent--

00:47:53.440 --> 00:47:54.520
MICHAEL MASOURAS: To prevent
spam and abuse.

00:47:54.520 --> 00:47:56.780
SHAWN SIMISTER: Spam
and stub pages.

00:47:56.780 --> 00:47:58.470
AUDIENCE: Just a real quick
second question.

00:47:58.470 --> 00:48:02.000
What are the API limits
around using Freebase?

00:48:02.000 --> 00:48:03.920
MICHAEL MASOURAS: Well,
currently there, you can do

00:48:03.920 --> 00:48:05.920
100,000 requests per
day for free.

00:48:05.920 --> 00:48:07.630
But there's also a form
there where you can

00:48:07.630 --> 00:48:09.090
request more quota.

00:48:09.090 --> 00:48:11.210
And you can describe your
project and we're usually

00:48:11.210 --> 00:48:13.690
pretty generous and you
can go from there.

00:48:13.690 --> 00:48:14.940
AUDIENCE: Thank you.

00:48:17.290 --> 00:48:20.950
AUDIENCE: It's really cool
to see how we can extract

00:48:20.950 --> 00:48:23.020
recognizable terms
out of text.

00:48:23.020 --> 00:48:27.490
But I'm curious as to what
projects are out there for

00:48:27.490 --> 00:48:29.920
using these extraction patterns
on fuzzier data, for

00:48:29.920 --> 00:48:33.540
example images and sounds,
to identify elements in a

00:48:33.540 --> 00:48:35.260
Knowledge Graph and in those
types of inputs.

00:48:38.050 --> 00:48:40.250
SHAWN SIMISTER: Yeah, that's
a good question.

00:48:40.250 --> 00:48:43.590
I don't have any resources
off the top of my head.

00:48:43.590 --> 00:48:45.100
MICHAEL MASOURAS: No I
don't know if any--

00:48:45.100 --> 00:48:48.020
for media, none, neither.

00:48:48.020 --> 00:48:51.980
I think that a good way to find
out is to find out which

00:48:51.980 --> 00:48:55.390
projects are out there that
extract just text, or any

00:48:55.390 --> 00:48:57.240
piece of information
out of media.

00:48:57.240 --> 00:48:59.580
And then do a second pass where
you reconcile that text

00:48:59.580 --> 00:49:01.390
with entities.

00:49:01.390 --> 00:49:05.770
So it's not an extra step to
reconclie with Freebase.

00:49:05.770 --> 00:49:07.002
Sorry, it's not a different
process to

00:49:07.002 --> 00:49:07.470
reconcile with Freebase.

00:49:07.470 --> 00:49:10.160
You just follow the process
you're already following to

00:49:10.160 --> 00:49:12.290
extract information, but then
you just reconcile that

00:49:12.290 --> 00:49:13.900
information with Freebase.

00:49:13.900 --> 00:49:15.820
SHAWN SIMISTER: We've seen
that in some cases, with

00:49:15.820 --> 00:49:20.130
people that had a large
collection of videos.

00:49:20.130 --> 00:49:22.350
And so they would actually
extract the entities from the

00:49:22.350 --> 00:49:24.190
comments, or the text around
the videos as a

00:49:24.190 --> 00:49:26.390
way of doing that.

00:49:26.390 --> 00:49:29.170
But yeah, I'm sorry, I don't
have some examples right now

00:49:29.170 --> 00:49:31.800
of images or video
recognition.

00:49:31.800 --> 00:49:33.050
AUDIENCE: Thank you.

00:49:35.530 --> 00:49:37.560
AUDIENCE: Is there any kind of
moderation on the data that

00:49:37.560 --> 00:49:38.650
goes into Freebase?

00:49:38.650 --> 00:49:41.660
So can anyone just chuck stuff
in, and does someone check

00:49:41.660 --> 00:49:42.990
that it's actually correct?

00:49:42.990 --> 00:49:43.620
SHAWN SIMISTER: Absolutely.

00:49:43.620 --> 00:49:47.360
So we have a number of ways
of checking data.

00:49:47.360 --> 00:49:50.680
We have a Freebase experts
group, which is kind of like a

00:49:50.680 --> 00:49:54.310
community moderation group,
which monitors edits coming

00:49:54.310 --> 00:49:56.120
into Freebase.

00:49:56.120 --> 00:49:59.330
Because, as Michael said,
everything is append only.

00:49:59.330 --> 00:50:02.420
With time stamps and attribution
for which user

00:50:02.420 --> 00:50:05.770
wrote something, it's very easy
for us to go in there and

00:50:05.770 --> 00:50:08.550
roll back any malicious edits
or bad data that's been

00:50:08.550 --> 00:50:09.740
contributed.

00:50:09.740 --> 00:50:11.490
So we have a number of
dashboards where we'll look

00:50:11.490 --> 00:50:14.570
for suspicious stuff
coming in.

00:50:14.570 --> 00:50:17.530
And then there are further steps
that we do later on to

00:50:17.530 --> 00:50:21.480
identify bad data, clean that
up, and that sort of thing.

00:50:21.480 --> 00:50:24.150
MICHAEL MASOURAS: Indeed, and
there's also tools that help

00:50:24.150 --> 00:50:27.660
you do loads where other members
of the community will

00:50:27.660 --> 00:50:30.460
QA the quality of the load
that you're doing.

00:50:30.460 --> 00:50:32.480
So that's also helpful
to prevent

00:50:32.480 --> 00:50:34.230
bad data from entering.

00:50:34.230 --> 00:50:39.110
But in terms of malicious
use, like spam or--

00:50:39.110 --> 00:50:41.950
Not only intentionally
malicious, we also have spam

00:50:41.950 --> 00:50:43.190
filters post-fact.

00:50:43.190 --> 00:50:46.090
So once the data is written in,
we recognize that certain

00:50:46.090 --> 00:50:46.950
patterns are not right.

00:50:46.950 --> 00:50:49.860
And then we flag them, and
then we review them.

00:50:49.860 --> 00:50:52.680
AUDIENCE: So if I had, say,
an application that did

00:50:52.680 --> 00:50:55.060
informations about books or
something, then would you

00:50:55.060 --> 00:50:56.350
encourage--

00:50:56.350 --> 00:50:59.320
Would it be a good thing to
get my users to post stuff

00:50:59.320 --> 00:51:00.435
back up there, as
well as comsume?

00:51:00.435 --> 00:51:02.340
Is that something that you want
to encourage, or do you

00:51:02.340 --> 00:51:04.960
want it to be more separate?

00:51:04.960 --> 00:51:06.770
Someone puts stuff in
and it's separate.

00:51:06.770 --> 00:51:08.940
Someone takes stuff out.

00:51:08.940 --> 00:51:11.400
MICHAEL MASOURAS: You mean,
from your own site?

00:51:11.400 --> 00:51:15.000
AUDIENCE: Yes, let's say I have
a web app or an Android

00:51:15.000 --> 00:51:17.950
app or something like that.

00:51:17.950 --> 00:51:19.280
SHAWN SIMISTER: We certainly
want to encourage as much

00:51:19.280 --> 00:51:21.360
contribution as possible.

00:51:21.360 --> 00:51:24.170
Everyone benefits when people
are cleaning up that data and

00:51:24.170 --> 00:51:25.640
contributing more facts.

00:51:25.640 --> 00:51:28.720
There's one tricky part, which
is that, when you have kind of

00:51:28.720 --> 00:51:34.160
distributed communities, if
someone is cleaning up a fact

00:51:34.160 --> 00:51:38.180
on your site in your community
of books, and someone else on

00:51:38.180 --> 00:51:40.950
Freebase disagrees with that
edit, and they get into a

00:51:40.950 --> 00:51:42.570
little bit of an edit
war, how does that

00:51:42.570 --> 00:51:44.280
communication happen?

00:51:44.280 --> 00:51:47.490
But in general, we want to
encourage as much contribution

00:51:47.490 --> 00:51:49.780
from other communities and
apps using Freebase.

00:51:49.780 --> 00:51:50.870
MICHAEL MASOURAS: They actually
had a platform where

00:51:50.870 --> 00:51:53.920
people could write
small web apps.

00:51:53.920 --> 00:51:56.360
And it's all customized to the
particular use case and

00:51:56.360 --> 00:51:58.900
encourages other users
to contribute data.

00:51:58.900 --> 00:52:01.370
So we have a quota for writing,
because we try to

00:52:01.370 --> 00:52:04.070
prevent this sort of
writing bad data.

00:52:04.070 --> 00:52:06.730
And so what really happens is
that you ask for an extended

00:52:06.730 --> 00:52:09.600
quota, because the base quota
for writing doesn't really

00:52:09.600 --> 00:52:10.330
give you much.

00:52:10.330 --> 00:52:12.720
And at that point, we're in the
conversation where we see

00:52:12.720 --> 00:52:15.560
how you present your site and
how you teach your users to

00:52:15.560 --> 00:52:18.220
enter correct data, because it's
not very straightforward.

00:52:18.220 --> 00:52:22.090
And if everything's OK, then
we increase the quota and

00:52:22.090 --> 00:52:24.400
that's very beneficial
for Freebase.

00:52:24.400 --> 00:52:24.680
AUDIENCE: OK.

00:52:24.680 --> 00:52:25.930
Thanks.

00:52:27.400 --> 00:52:29.000
AUDIENCE: Are there topics that
have been identified as

00:52:29.000 --> 00:52:30.250
very controversial?

00:52:32.470 --> 00:52:33.970
How you deal with controversy?

00:52:33.970 --> 00:52:36.900
SHAWN SIMISTER: Yeah, so one
of the things that so we do

00:52:36.900 --> 00:52:40.670
is, we don't really have
any notability

00:52:40.670 --> 00:52:43.120
requirements like Wikipedia.

00:52:43.120 --> 00:52:50.180
So Wikipedia's around 2 million
and change topics, and

00:52:50.180 --> 00:52:52.290
Freebase is 23 million topics.

00:52:52.290 --> 00:52:53.510
So part of that is
that we don't

00:52:53.510 --> 00:52:55.230
have notability standards.

00:52:55.230 --> 00:52:59.640
People have added detailed
collections of porn stars, and

00:52:59.640 --> 00:53:01.490
various things in there.

00:53:01.490 --> 00:53:05.920
And we're creating schema that
will mark the objectionable

00:53:05.920 --> 00:53:08.990
content so that developers can
filter that out in their

00:53:08.990 --> 00:53:14.060
application, or filter it
in as the need may be.

00:53:14.060 --> 00:53:17.000
AUDIENCE: How about things that
are of very high academic

00:53:17.000 --> 00:53:19.380
quality, but they're still
controversial in the academic

00:53:19.380 --> 00:53:20.930
circles and so forth?

00:53:20.930 --> 00:53:24.550
SHAWN SIMISTER: So actually,
motivated by some of the use

00:53:24.550 --> 00:53:27.510
cases we have here at Google
for using data from the

00:53:27.510 --> 00:53:32.530
Knowledge Graph, we're looking
at ways to come up with much

00:53:32.530 --> 00:53:35.470
more detailed categorizations
of different types of

00:53:35.470 --> 00:53:37.200
objectionable content.

00:53:37.200 --> 00:53:39.120
And we already have some
expertise in that area from

00:53:39.120 --> 00:53:41.260
image search and other
parts like YouTube.

00:53:43.810 --> 00:53:48.190
AUDIENCE: Do you have plans to
include authoritative sources

00:53:48.190 --> 00:53:50.950
of information, government
sources?

00:53:50.950 --> 00:53:54.900
SHAWN SIMISTER: Yeah, so we've
been talking to the World Bank

00:53:54.900 --> 00:53:58.930
about loading some statistical
data and actually indicating,

00:53:58.930 --> 00:54:02.830
in the graph, which facts come
from the World Bank.

00:54:02.830 --> 00:54:05.660
So that people know where
that number comes from.

00:54:05.660 --> 00:54:07.730
MICHAEL MASOURAS: We have
already loaded some data from

00:54:07.730 --> 00:54:11.460
the World Bank and we have
authorities coming up, yeah.

00:54:11.460 --> 00:54:14.970
And we plan to support this
as an official use case.

00:54:14.970 --> 00:54:19.445
AUDIENCE: Do you have any sort
of plans for creating forms to

00:54:19.445 --> 00:54:23.675
go and save data and put
it into entities?

00:54:27.030 --> 00:54:29.745
SHAWN SIMISTER: We've been
experimenting with that.

00:54:29.745 --> 00:54:32.870
I mean, the topic pages here--

00:54:32.870 --> 00:54:34.870
AUDIENCE: A series of templates
as well, maybe you

00:54:34.870 --> 00:54:38.580
want to have templates to go
and pull together all these

00:54:38.580 --> 00:54:41.580
entities and present them
in a certain way.

00:54:41.580 --> 00:54:44.000
Semantic MediaWiki does
something similar like that,

00:54:44.000 --> 00:54:48.170
but there's performance issues
for very large data sets.

00:54:48.170 --> 00:54:50.610
SHAWN SIMISTER: Yeah, in
the early versions of

00:54:50.610 --> 00:54:53.270
freebase.com, we experimented
with a number of different

00:54:53.270 --> 00:54:56.210
ways, tables, and maps, and
timelines, like I was talking

00:54:56.210 --> 00:54:59.830
about, for filtering down
entities and displaying them.

00:54:59.830 --> 00:55:03.400
It got very complicated, and we
found that developers could

00:55:03.400 --> 00:55:06.270
do a better job in their
application than we could in

00:55:06.270 --> 00:55:09.140
freebase.com trying
to serve everyone.

00:55:09.140 --> 00:55:12.890
So right now, we just kind of
target the API use case.

00:55:12.890 --> 00:55:16.100
MICHAEL MASOURAS: Yeah, and I
mean, there's a variety of

00:55:16.100 --> 00:55:18.480
tools that get you from
anything, one single fact for

00:55:18.480 --> 00:55:21.470
a single entity, all the way
to uploading of data set of

00:55:21.470 --> 00:55:24.880
100,000 entities
into Freebase.

00:55:24.880 --> 00:55:29.460
And in that spectrum, we have
all sorts of actual apps that

00:55:29.460 --> 00:55:31.140
can help you do what
you want to do.

00:55:31.140 --> 00:55:33.270
In the new freebase.com, that's
coming up soon, there's

00:55:33.270 --> 00:55:35.120
actually an application that
works a little bit like you

00:55:35.120 --> 00:55:38.730
described, where you you make a
query with the data that you

00:55:38.730 --> 00:55:41.490
want to see and the data
that you want to enter.

00:55:41.490 --> 00:55:43.910
And it presents you with a grid
sort of view where you

00:55:43.910 --> 00:55:46.610
can go in, and then edit,
a property for every

00:55:46.610 --> 00:55:47.430
entity, let's say.

00:55:47.430 --> 00:55:48.340
Or something like that.

00:55:48.340 --> 00:55:49.725
So that tool exists, yes.

00:55:56.400 --> 00:55:57.650
SHAWN SIMISTER: One more.

00:55:59.740 --> 00:56:02.460
AUDIENCE: It seems like named
entity extraction is kind of

00:56:02.460 --> 00:56:05.300
the key to being able
to use Freebase from

00:56:05.300 --> 00:56:08.560
just freeform data.

00:56:08.560 --> 00:56:12.520
Are you aware of any tools for
doing named entity extraction

00:56:12.520 --> 00:56:17.780
from small form content, like
tweets or Google+ posts,

00:56:17.780 --> 00:56:19.030
things like that.

00:56:22.570 --> 00:56:25.590
SHAWN SIMISTER: Nothing that you
could use right now, that

00:56:25.590 --> 00:56:26.240
I can think of.

00:56:26.240 --> 00:56:28.670
I know it's a very active
area of research.

00:56:28.670 --> 00:56:30.460
I've seen papers using
Freebase data to do

00:56:30.460 --> 00:56:32.220
that sort of thing.

00:56:32.220 --> 00:56:36.020
I also know of a startup that's
using our data to try

00:56:36.020 --> 00:56:36.920
and do that.

00:56:36.920 --> 00:56:38.620
But I don't think that they've
announced anything yet.

00:56:38.620 --> 00:56:39.940
AUDIENCE: OK thanks

00:56:39.940 --> 00:56:41.190
SHAWN SIMISTER: Thank you.

00:56:44.500 --> 00:56:45.760
SHAWN SIMISTER: Alright, well
thank you all very much for

00:56:45.760 --> 00:56:46.300
coming out.

00:56:46.300 --> 00:56:47.550
I really appreciate that.

