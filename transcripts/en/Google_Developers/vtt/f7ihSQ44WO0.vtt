WEBVTT
Kind: captions
Language: en

00:00:31.132 --> 00:00:32.590
JAMAL EASON: We're
happy to launch,

00:00:32.590 --> 00:00:41.820
last December,
Android Studio 1.0.

00:00:41.820 --> 00:00:44.300
So since launch, the
majority of our users

00:00:44.300 --> 00:00:47.190
have made the transition
over to Android Studio.

00:00:47.190 --> 00:00:49.040
So if you haven't
had the time, now

00:00:49.040 --> 00:00:51.170
is a good time to
make that transition.

00:00:51.170 --> 00:00:53.680
Our team is fully focused on
working on Android Studio,

00:00:53.680 --> 00:00:55.680
and we're constantly
listening to your feedback.

00:00:55.680 --> 00:00:57.221
We want you to make
the features that

00:00:57.221 --> 00:01:00.845
work best for you and your
development environment.

00:01:00.845 --> 00:01:02.470
So when we launched
Android Studio 1.0,

00:01:02.470 --> 00:01:05.974
we asked you developers,
hey, what do you what?

00:01:05.974 --> 00:01:08.140
We did a survey, and this
is what sort of panned out

00:01:08.140 --> 00:01:09.100
from those results.

00:01:09.100 --> 00:01:12.020
Number one, a lot of people
asked about Design Tools.

00:01:12.020 --> 00:01:14.940
Number two, a faster
Emulator Experience.

00:01:14.940 --> 00:01:16.860
Number three, NDK support.

00:01:16.860 --> 00:01:18.360
And number four, app testing.

00:01:18.360 --> 00:01:20.590
And we really appreciated
hearing all this feedback,

00:01:20.590 --> 00:01:22.177
so we can really
prioritize our work

00:01:22.177 --> 00:01:24.510
to making sure we do the right
stuff that works for you.

00:01:27.089 --> 00:01:29.380
So in this talk, we'll talk
about three different types

00:01:29.380 --> 00:01:32.130
of tools that we've be working
on for the last couple months.

00:01:32.130 --> 00:01:33.794
We'll talk a little
bit about design,

00:01:33.794 --> 00:01:35.460
a little bit about
developing and tests,

00:01:35.460 --> 00:01:37.455
and we'll cap it off
of the demo showcasing

00:01:37.455 --> 00:01:39.705
the work that we've been
working on in Android Studio.

00:01:43.030 --> 00:01:47.530
So design-- so Chet talked about
this a little bit in the what's

00:01:47.530 --> 00:01:50.490
new section, but as you know,
we launched Material Design

00:01:50.490 --> 00:01:51.927
with Android 5.0.

00:01:51.927 --> 00:01:54.260
And I'm really excited about
this Android Design Support

00:01:54.260 --> 00:01:55.968
Library, because what
it allows you to do

00:01:55.968 --> 00:01:57.329
is really focus on your content.

00:01:57.329 --> 00:01:59.620
Instead of worrying about
meeting the specs of material

00:01:59.620 --> 00:02:01.953
design, you can literally
drag and drop these components

00:02:01.953 --> 00:02:03.480
into your application,
and you're

00:02:03.480 --> 00:02:06.260
on your way to having a
high quality application.

00:02:06.260 --> 00:02:07.890
And as we've talked
before, we've

00:02:07.890 --> 00:02:10.330
included a few elements--
things like the Floating Action

00:02:10.330 --> 00:02:12.280
Button, the Toolbar
with Motion--

00:02:12.280 --> 00:02:14.821
so that's the toolbar you see
with a lot of Google Apps that,

00:02:14.821 --> 00:02:15.740
sort of, expand grow.

00:02:15.740 --> 00:02:17.030
Now that is for free.

00:02:17.030 --> 00:02:19.380
You can now drag in that
into your application.

00:02:19.380 --> 00:02:22.110
We've also include the Snack
Bar, the Navigation View,

00:02:22.110 --> 00:02:23.600
and Text Input.

00:02:23.600 --> 00:02:27.830
And of course, as always,
it's backwards compatible,

00:02:27.830 --> 00:02:31.620
Meaning that if you target
Android L and higher,

00:02:31.620 --> 00:02:33.720
you can still get that
same material look and feel

00:02:33.720 --> 00:02:35.178
for all your previous
applications.

00:02:37.905 --> 00:02:43.690
[APPLAUSE]

00:02:43.690 --> 00:02:45.110
And so Vector Images.

00:02:45.110 --> 00:02:47.610
So last year, as well, we
introduced Vector Drawables

00:02:47.610 --> 00:02:48.320
with Lollipop.

00:02:48.320 --> 00:02:49.945
Now I don't know
about you, it's really

00:02:49.945 --> 00:02:53.580
kind of painful to manage an
update-- lots of raster images

00:02:53.580 --> 00:02:55.760
and bitmaps across
different densities.

00:02:55.760 --> 00:02:59.660
And so see, with Android Studio,
you can now import an SVG file

00:02:59.660 --> 00:03:01.690
or work directly with
the vector drawable.

00:03:01.690 --> 00:03:04.980
And during build time, we will
generate all the assets for you

00:03:04.980 --> 00:03:06.696
automatically.

00:03:06.696 --> 00:03:12.917
[APPLAUSE]

00:03:12.917 --> 00:03:14.500
So, if you're not
aware, if you wanted

00:03:14.500 --> 00:03:17.370
to change an asset
or some sizing,

00:03:17.370 --> 00:03:19.120
you just change the
vector drawable,

00:03:19.120 --> 00:03:21.706
and we'll build that
for the PNG asset.

00:03:21.706 --> 00:03:23.580
And a couple things that
this helps you with.

00:03:23.580 --> 00:03:25.290
Hopefully it saves
you time and hassle

00:03:25.290 --> 00:03:27.390
in generating all these assets.

00:03:27.390 --> 00:03:30.460
And then, lastly, hopefully
decrease your APK size.

00:03:30.460 --> 00:03:33.350
In many cases, if you just
include a vector drawable,

00:03:33.350 --> 00:03:35.960
you can add a tint to
it and it increase--

00:03:35.960 --> 00:03:40.860
sorry it decreases your
APK size for most apps.

00:03:40.860 --> 00:03:43.300
And then, lastly, for
divisional design editors.

00:03:43.300 --> 00:03:45.460
So looking at the
results of the survey,

00:03:45.460 --> 00:03:49.340
we thought about how do we help
you design your application?

00:03:49.340 --> 00:03:50.880
We know a lot of
you enjoy, maybe,

00:03:50.880 --> 00:03:52.750
working directly with XML.

00:03:52.750 --> 00:03:55.390
But for me, and a
lot of developers,

00:03:55.390 --> 00:03:57.910
I like using visual tools
to do visual elements

00:03:57.910 --> 00:03:59.262
of my application.

00:03:59.262 --> 00:04:01.220
So we pretty much looked
at all different files

00:04:01.220 --> 00:04:04.516
you had to work with-- things
like styles.xml, colors.xml--

00:04:04.516 --> 00:04:06.640
and came to the conclusion
that, well, you know, we

00:04:06.640 --> 00:04:08.320
need to write it from scratch.

00:04:08.320 --> 00:04:09.820
And so we're going
to show you today

00:04:09.820 --> 00:04:12.370
a few demos of the work we've
been doing to make it easier

00:04:12.370 --> 00:04:14.800
for you to maintain
easier UI, without having

00:04:14.800 --> 00:04:20.385
to solely rely on using XML
to work with your UI elements.

00:04:20.385 --> 00:04:21.760
And so with that,
I'll transition

00:04:21.760 --> 00:04:24.290
to Xav to talk a little bit
about our development tools.

00:04:24.290 --> 00:04:25.623
XAVIER DUCROHET: Thank you, Jay.

00:04:27.630 --> 00:04:29.730
All right, so core
to our strategy

00:04:29.730 --> 00:04:31.140
is our unified build system.

00:04:31.140 --> 00:04:34.150
So whether you're building from
Studio from the command line

00:04:34.150 --> 00:04:35.950
or from your build
server, you're

00:04:35.950 --> 00:04:38.440
going to use a single build
and that's based on Gradle.

00:04:38.440 --> 00:04:42.430
So since 1.0, we
focused on a few items.

00:04:42.430 --> 00:04:45.600
The first one was correctness.

00:04:45.600 --> 00:04:47.000
We fixed a lot of bugs first.

00:04:47.000 --> 00:04:50.320
And a lot of those issues
were on dependency management.

00:04:50.320 --> 00:04:53.930
For example, for properly
handling the test dependencies.

00:04:53.930 --> 00:04:55.900
When you have an
application and a test that

00:04:55.900 --> 00:04:58.040
have the same dependency,
you need to make sure

00:04:58.040 --> 00:04:59.090
that you only package it once.

00:04:59.090 --> 00:05:01.548
There's a lot of corner cases
there that we had to support,

00:05:01.548 --> 00:05:02.850
so we dumped a lot of those.

00:05:02.850 --> 00:05:06.400
So if you had some issues, you
can upgrade to a later version.

00:05:06.400 --> 00:05:09.360
We've also added support--
we also fixed a lot of issue

00:05:09.360 --> 00:05:11.830
regarding the provided scopes.

00:05:11.830 --> 00:05:14.635
And new in 1.3, we
are adding support

00:05:14.635 --> 00:05:18.610
for optional dependencies
in library projects.

00:05:18.610 --> 00:05:21.390
The other thing that we're
focusing a lot on right

00:05:21.390 --> 00:05:22.440
now is performance.

00:05:22.440 --> 00:05:25.290
And we know that's on
a lot of your minds.

00:05:25.290 --> 00:05:28.686
And so there's really two
aspects to performance.

00:05:28.686 --> 00:05:30.560
The first one is just
the build steps, right,

00:05:30.560 --> 00:05:34.540
like the compilation steps, the
DX steps, the packaging steps.

00:05:34.540 --> 00:05:37.100
So here we have a few
different things going on.

00:05:37.100 --> 00:05:40.210
The first one is we have these
new compiler called Jack.

00:05:40.210 --> 00:05:42.510
And Jack is a compiler
that's replaced DX

00:05:42.510 --> 00:05:45.730
and goes directly from Java
source code to DEX file.

00:05:45.730 --> 00:05:49.940
We've already had a first
preview a few months back.

00:05:49.940 --> 00:05:51.540
And so we'll have a
new preview in 1.3

00:05:51.540 --> 00:05:53.100
with both the new
version of Jack

00:05:53.100 --> 00:05:55.150
and a new version
of our plug in that,

00:05:55.150 --> 00:05:58.000
offering incremental support
when you're building.

00:05:58.000 --> 00:06:01.260
And in some of our tests we've
seen some good performance

00:06:01.260 --> 00:06:02.900
increase in that step.

00:06:02.900 --> 00:06:04.920
Which is one,
probably, of the steps

00:06:04.920 --> 00:06:07.810
that takes the longest time.

00:06:07.810 --> 00:06:10.124
[APPLAUSE]

00:06:12.380 --> 00:06:13.790
We're also looking
at other steps

00:06:13.790 --> 00:06:15.331
that we are doing
and improving them.

00:06:15.331 --> 00:06:16.990
So for example, the
PNG cruncher is one

00:06:16.990 --> 00:06:20.910
that we fixed, starting
with build tools 22.

00:06:20.910 --> 00:06:23.447
We looked at it
and the old one--

00:06:23.447 --> 00:06:25.030
if you did-- you
know if you had about

00:06:25.030 --> 00:06:26.947
500 PNGs in your
application-- and they

00:06:26.947 --> 00:06:28.780
need to be processed
in order to be packaged

00:06:28.780 --> 00:06:30.420
with your application,
especially

00:06:30.420 --> 00:06:34.170
if they are nine patches--
500 PNG could take, like,

00:06:34.170 --> 00:06:36.780
four seconds and we are
down to 400 milliseconds.

00:06:36.780 --> 00:06:38.002
So it's much better.

00:06:38.002 --> 00:06:41.100
[APPLAUSE]

00:06:41.100 --> 00:06:43.160
And then, finally,
APT, which is the tool

00:06:43.160 --> 00:06:46.400
and that packages is all of your
resources, create binary XML,

00:06:46.400 --> 00:06:48.756
and all of that-- we
are working heavily

00:06:48.756 --> 00:06:51.380
to actually make the stapler so
incremental, because right now,

00:06:51.380 --> 00:06:55.240
it always recompile
all of your resources.

00:06:55.240 --> 00:06:57.710
So that's the first
aspect the performance--

00:06:57.710 --> 00:06:59.730
the signal aspect
is Gradle itself.

00:06:59.730 --> 00:07:01.740
And we know that, right
now, when you build,

00:07:01.740 --> 00:07:04.490
you get a feeling that it
takes a long time to start up,

00:07:04.490 --> 00:07:06.590
and you know, it's like,
what is going, right?

00:07:06.590 --> 00:07:11.290
So the thing that Gradle
does when you start

00:07:11.290 --> 00:07:14.360
is it creates a model of your
project-- of every single

00:07:14.360 --> 00:07:16.040
of your module,
it's going to create

00:07:16.040 --> 00:07:19.610
a model that contains all the
variant created from build

00:07:19.610 --> 00:07:21.259
types and product flavors.

00:07:21.259 --> 00:07:23.550
It's going to create the task
to build every single one

00:07:23.550 --> 00:07:24.300
of your variant.

00:07:24.300 --> 00:07:26.370
It's going to resolve
all of the dependencies

00:07:26.370 --> 00:07:28.350
for every single one
of your variants.

00:07:28.350 --> 00:07:30.694
And it's like-- if it's
a lot of work, right?

00:07:30.694 --> 00:07:32.110
And then if you
have custom logic,

00:07:32.110 --> 00:07:34.340
it's going to run that
custom logic every time.

00:07:34.340 --> 00:07:37.320
And your custom logic
could tweak the model,

00:07:37.320 --> 00:07:40.220
could tweak the task, add new
task, and do things like that.

00:07:40.220 --> 00:07:42.120
So let's look at an example.

00:07:42.120 --> 00:07:44.500
Here we have a
project that has 10

00:07:44.500 --> 00:07:47.990
modules with 25 variant each.

00:07:47.990 --> 00:07:50.860
One the first
line, the help task

00:07:50.860 --> 00:07:52.380
does nothing build related.

00:07:52.380 --> 00:07:54.860
It just output a static text.

00:07:54.860 --> 00:07:57.730
And then the second line,
assemble one variant.

00:07:57.730 --> 00:08:00.840
So by assemble here, we
actually run that benchmark

00:08:00.840 --> 00:08:03.252
with the dry run mode,
where it actually

00:08:03.252 --> 00:08:05.210
skips all the build steps,
like the compilation

00:08:05.210 --> 00:08:06.000
and the packaging.

00:08:06.000 --> 00:08:11.810
So we really look at the time
that Gradle itself takes.

00:08:11.810 --> 00:08:13.840
And you can see that
on those two lines--

00:08:13.840 --> 00:08:15.359
it's the same exact
amount of time.

00:08:15.359 --> 00:08:17.150
And that's because
Gradle is a little bit--

00:08:17.150 --> 00:08:18.618
that it's not very smart here.

00:08:18.618 --> 00:08:20.951
It doesn't really know that
they help task is not really

00:08:20.951 --> 00:08:21.614
build related.

00:08:21.614 --> 00:08:24.520
And so it's still to
build all of that model.

00:08:24.520 --> 00:08:27.530
And then the third
line we're running

00:08:27.530 --> 00:08:31.170
every variant of every module,
and that takes a bit more time,

00:08:31.170 --> 00:08:33.424
because in the end you
still have a bigger task

00:08:33.424 --> 00:08:37.429
graph that needs to be
prepared and run through.

00:08:37.429 --> 00:08:40.110
And then the two column that
we have-- so the first column

00:08:40.110 --> 00:08:43.970
is Gradle plug-in 1.0
with Gradle 2.2.1,

00:08:43.970 --> 00:08:45.640
which is a minimum requirement.

00:08:45.640 --> 00:08:49.589
And the second one is 1.2
with, also, Gradle 2.2.1.

00:08:49.589 --> 00:08:51.880
And you can see here that
we, actually, we're not going

00:08:51.880 --> 00:08:53.589
in the right direction here.

00:08:53.589 --> 00:08:55.380
And that's because
we're doing more things.

00:08:55.380 --> 00:08:58.020
I mentioned a lot about more
dependency management check,

00:08:58.020 --> 00:08:59.430
support, test, and scope.

00:08:59.430 --> 00:09:02.420
And that's just more
work equals longer time.

00:09:02.420 --> 00:09:04.190
And that's really not
what we what to do.

00:09:04.190 --> 00:09:06.290
So we worked very
closely with Gradleware,

00:09:06.290 --> 00:09:10.380
the company behind Gradle,
to solve the problem.

00:09:10.380 --> 00:09:12.760
And so we did a lot of
optimization and with Gradle

00:09:12.760 --> 00:09:16.810
1-- the plug-in 1.3 and with
Gradle 2.4, which was just

00:09:16.810 --> 00:09:18.670
released like a few weeks ago.

00:09:18.670 --> 00:09:22.535
And so, the numbers
already look much better.

00:09:22.535 --> 00:09:24.355
[APPLAUSE]

00:09:27.090 --> 00:09:28.680
Let's look at another example.

00:09:28.680 --> 00:09:32.000
This project here is a single
module with 400 variants.

00:09:32.000 --> 00:09:33.429
Now this is really
a corner case.

00:09:33.429 --> 00:09:35.970
Not a lot of people would have
400 variants in their project,

00:09:35.970 --> 00:09:37.540
I hope.

00:09:37.540 --> 00:09:40.350
And clearly, when you look
at the time, it's pretty bad.

00:09:40.350 --> 00:09:42.160
Definitely some
scalability issue.

00:09:42.160 --> 00:09:45.430
So if we look at the
result, that's even better.

00:09:45.430 --> 00:09:47.855
[APPLAUSE]

00:09:50.770 --> 00:09:53.380
So if you notice though--
in that case-- in both

00:09:53.380 --> 00:09:55.700
of those cases,
if you will still

00:09:55.700 --> 00:09:57.879
run only help or
a single variant,

00:09:57.879 --> 00:09:59.670
that's still about the
same amount of time.

00:09:59.670 --> 00:10:02.550
We haven't solved that issue
of Gradle still building

00:10:02.550 --> 00:10:03.517
the whole model.

00:10:03.517 --> 00:10:05.350
And so we've been-- for
the past year or so,

00:10:05.350 --> 00:10:07.920
we've been working very
closely with the Gradle team

00:10:07.920 --> 00:10:09.510
to fix that problem.

00:10:09.510 --> 00:10:11.200
They've been
working on a new API

00:10:11.200 --> 00:10:14.610
to build plug-in
that will solve this.

00:10:14.610 --> 00:10:18.360
So on top of that--
on top those new APIs,

00:10:18.360 --> 00:10:21.200
we are building a next
generation plug-in.

00:10:21.200 --> 00:10:23.170
And the goal here
is to have Gradle

00:10:23.170 --> 00:10:27.230
be more involved in the model
that our plug-in creates.

00:10:27.230 --> 00:10:30.160
Basically Gradle is going
to manage that model for us.

00:10:30.160 --> 00:10:32.550
It's going to manage the
variants and the task

00:10:32.550 --> 00:10:34.430
and all that, in
order to do less.

00:10:34.430 --> 00:10:36.840
The goal here is to
make Gradle do only

00:10:36.840 --> 00:10:41.250
what's needed to build what
you requested to build.

00:10:41.250 --> 00:10:43.710
And then because Gradle
also managed that model,

00:10:43.710 --> 00:10:45.730
it can cache it and
make incremental upgrade

00:10:45.730 --> 00:10:49.270
to the cache when only
some things have changed.

00:10:49.270 --> 00:10:51.020
And then finally It
will have also opened

00:10:51.020 --> 00:10:52.722
the door for more optimization.

00:10:52.722 --> 00:10:55.180
For example, right now, if you
have a multi-module project,

00:10:55.180 --> 00:11:00.342
every single module you is
evaluated sequentially--

00:11:00.342 --> 00:11:01.300
there's no parallelism.

00:11:01.300 --> 00:11:03.690
So that's something
we can improve.

00:11:03.690 --> 00:11:06.960
So let's look at
the new numbers.

00:11:06.960 --> 00:11:08.570
That's even better, right.

00:11:08.570 --> 00:11:11.670
And what you notice here is
that when you run just the help

00:11:11.670 --> 00:11:14.990
task on a small project,
those 0.9 signals

00:11:14.990 --> 00:11:15.990
is really what it takes.

00:11:15.990 --> 00:11:18.910
When you run them from the
command line to start Gradle,

00:11:18.910 --> 00:11:21.300
have it communicate with
a demand, out to the text,

00:11:21.300 --> 00:11:21.940
and then quit.

00:11:21.940 --> 00:11:24.230
It's basically the
doing nothing else.

00:11:24.230 --> 00:11:27.060
And when you start building
only a single variant,

00:11:27.060 --> 00:11:28.790
it's just a little
bit more time.

00:11:28.790 --> 00:11:31.100
And the difference between
building a single variant

00:11:31.100 --> 00:11:33.010
and building all the
variants is actually

00:11:33.010 --> 00:11:36.410
bigger than in the previous case
because that's the case where

00:11:36.410 --> 00:11:38.950
suddenly we do a lot more.

00:11:38.950 --> 00:11:41.300
The interesting point--
oh, big caveat here,

00:11:41.300 --> 00:11:43.410
there is no caching in here.

00:11:43.410 --> 00:11:45.310
They haven't implemented,
yet, caching.

00:11:45.310 --> 00:11:48.835
So you can see that those number
will get even smaller when

00:11:48.835 --> 00:11:51.460
you're building all the variance
and the model has been cached.

00:11:51.460 --> 00:11:53.376
All we have to do is
reload it from the cache,

00:11:53.376 --> 00:11:56.030
and so that will be even faster.

00:11:56.030 --> 00:11:57.800
The interesting point
here is that when

00:11:57.800 --> 00:12:00.720
you're building from
Studio, when you do deploy,

00:12:00.720 --> 00:12:02.880
you're actually building
a single variant

00:12:02.880 --> 00:12:04.580
from a single module.

00:12:04.580 --> 00:12:06.510
Plus [INAUDIBLE] dependencies.

00:12:06.510 --> 00:12:09.560
So it's really the best
scenario where you only

00:12:09.560 --> 00:12:12.419
have Gradle do the minimum
that it needs to do.

00:12:12.419 --> 00:12:13.960
And so that will
really speed up your

00:12:13.960 --> 00:12:18.930
build when you're developing
from within Studio.

00:12:18.930 --> 00:12:22.560
So what's the deal
with the new plug-in?

00:12:22.560 --> 00:12:24.090
The first thing to
know is that it's

00:12:24.090 --> 00:12:26.630
new APIs-- the DSL
will be-- so the DSL is

00:12:26.630 --> 00:12:30.010
the language that you use to
drive the build at Gradle 5.

00:12:30.010 --> 00:12:32.090
It will be slightly
different, and that's

00:12:32.090 --> 00:12:33.900
because Gradle,
as I said earlier,

00:12:33.900 --> 00:12:35.390
managed part of the model.

00:12:35.390 --> 00:12:40.300
So we have to use a DSL
that works with those APIs.

00:12:40.300 --> 00:12:44.380
We're going to ship that as a
preview in 1.3 in a few weeks.

00:12:44.380 --> 00:12:47.460
It's not part of the current
1.3 release that we did today.

00:12:47.460 --> 00:12:49.874
Just a week or two and
we'll release a preview.

00:12:49.874 --> 00:12:52.290
And then from then on, we'll
keep releasing, as a preview,

00:12:52.290 --> 00:12:55.360
alongside 1.3, 1.4, et cetera.

00:12:55.360 --> 00:12:57.440
Still as a preview--
alongside the old plug-in

00:12:57.440 --> 00:12:58.720
that will still be there.

00:12:58.720 --> 00:13:01.053
And then later this year that
we'll replace, officially,

00:13:01.053 --> 00:13:02.120
the current plug-in.

00:13:02.120 --> 00:13:04.200
If you're using Studio,
whether you're using,

00:13:04.200 --> 00:13:06.450
the old plug-in or the new
plug-in, it doesn't matter.

00:13:06.450 --> 00:13:07.700
They work the same with Studio.

00:13:07.700 --> 00:13:08.533
Studio doesn't care.

00:13:08.533 --> 00:13:11.960
It's the same model
that's exposed to the ID.

00:13:11.960 --> 00:13:14.500
So that's on the
performance side.

00:13:14.500 --> 00:13:16.819
Let's talk at little
bit about Data Binding.

00:13:16.819 --> 00:13:18.360
You probably heard
about that already

00:13:18.360 --> 00:13:20.150
in the previous session.

00:13:20.150 --> 00:13:21.530
So we have Data Binding.

00:13:21.530 --> 00:13:23.070
It's purely build time.

00:13:23.070 --> 00:13:25.140
All you have to do is
set up your build system

00:13:25.140 --> 00:13:27.140
and then it will just
generate the code for you,

00:13:27.140 --> 00:13:28.600
and then it just works.

00:13:28.600 --> 00:13:31.890
There is a support library
also that's part of that.

00:13:31.890 --> 00:13:34.610
So right now it's part
of a separate plug-in,

00:13:34.610 --> 00:13:36.799
and then, hopefully,
for 1.3 we will

00:13:36.799 --> 00:13:39.090
include that in the main
plug-in so that you don't even

00:13:39.090 --> 00:13:41.050
have to go and install
another plug-in.

00:13:41.050 --> 00:13:43.380
So for now though you have
to install that plug-in.

00:13:43.380 --> 00:13:45.924
It's available on launch center.

00:13:45.924 --> 00:13:47.340
You install that
plug-in, then you

00:13:47.340 --> 00:13:49.710
start adding Date Binding
event in your resources,

00:13:49.710 --> 00:13:50.380
and that's it.

00:13:50.380 --> 00:13:53.040
It adds the dependency
for you-- nothing to do.

00:13:53.040 --> 00:13:54.920
It will just do
what it has to do.

00:13:57.870 --> 00:14:05.960
NDK C/C++ Support-- Gradle has
support for Native Support now.

00:14:05.960 --> 00:14:08.120
And so we are building a
new integration in Gradle

00:14:08.120 --> 00:14:09.510
based on that.

00:14:09.510 --> 00:14:13.740
And because it's somewhat tied
to the new component model

00:14:13.740 --> 00:14:15.942
that-- those new API I
just talked about-- that's

00:14:15.942 --> 00:14:17.900
going to be tied to the
next generation plug-in

00:14:17.900 --> 00:14:19.950
we're working on.

00:14:19.950 --> 00:14:25.226
And that will allow us to--
that integration in Gradle

00:14:25.226 --> 00:14:27.600
will allow us to have a really
good integration in studio

00:14:27.600 --> 00:14:29.620
where everything
that Studio needs

00:14:29.620 --> 00:14:33.540
to know about your project for
editing we come from Gradle,

00:14:33.540 --> 00:14:35.490
and then we'll have a
great experience there.

00:14:35.490 --> 00:14:37.140
And so for the
experience in Studio,

00:14:37.140 --> 00:14:39.780
we really wanted to provide
the best possible experience

00:14:39.780 --> 00:14:41.690
for editing and debugging.

00:14:41.690 --> 00:14:45.050
And so we partnered with
JetBrains to package,

00:14:45.050 --> 00:14:50.280
in Studio, their brand new ID
for C/C++ directly in Studio

00:14:50.280 --> 00:14:52.326
and it will be free for
Android development.

00:14:52.326 --> 00:14:53.200
I don't know if you--

00:14:53.200 --> 00:14:58.457
[APPLAUSE]

00:14:58.457 --> 00:15:00.040
We did not want to
start from scratch.

00:15:00.040 --> 00:15:05.300
They have a great solution, and
we are just offering it to you.

00:15:05.300 --> 00:15:08.560
And you have full
debugging, full refactoring.

00:15:08.560 --> 00:15:12.420
It's really a great tool.

00:15:12.420 --> 00:15:15.540
All right, so, let's talk a
little bit about testing now.

00:15:15.540 --> 00:15:18.950
So since 1.0 we added a
few features for testing.

00:15:18.950 --> 00:15:21.330
The first one that we added
was unit test support.

00:15:21.330 --> 00:15:23.480
So, what I mean by
unit test support

00:15:23.480 --> 00:15:27.120
here is unit test that
worked directly natively

00:15:27.120 --> 00:15:29.870
on the desktop JVM, rather than
having to be compiled into NPK

00:15:29.870 --> 00:15:31.840
and sent to the device.

00:15:31.840 --> 00:15:34.450
That's to speedup
round tripping-- your

00:15:34.450 --> 00:15:39.480
fixing your bugs-- your bugs and
your test and seeing results.

00:15:39.480 --> 00:15:42.750
The big point here
is that this is not

00:15:42.750 --> 00:15:47.190
meant to run Android platform
code on the Desktop JVM.

00:15:47.190 --> 00:15:49.170
We do provide a custom
Android Java where

00:15:49.170 --> 00:15:51.070
you can go and mock everything.

00:15:51.070 --> 00:15:52.660
The normal Android
Java, actually,

00:15:52.660 --> 00:15:54.090
has a lot of class
that are final.

00:15:54.090 --> 00:15:56.010
So we can upstream
the final or so

00:15:56.010 --> 00:15:57.694
that you can go and mock them.

00:15:57.694 --> 00:15:59.110
But you have to
mock what you use.

00:15:59.110 --> 00:16:01.107
So it's strictly for
your business logic.

00:16:01.107 --> 00:16:03.690
It's up to you to figure out how
much you want to mock on out.

00:16:03.690 --> 00:16:06.650
The goal is not to
replace [INAUDIBLE] here.

00:16:06.650 --> 00:16:08.400
But if you want to use
that-- just opening

00:16:08.400 --> 00:16:10.570
your test in source test Java.

00:16:10.570 --> 00:16:13.100
There's unique test
specific dependencies

00:16:13.100 --> 00:16:16.430
and you can just add that, and
then you can run your test.

00:16:16.430 --> 00:16:20.890
The other thing that we
added in Gradle-- in 1.3--

00:16:20.890 --> 00:16:22.351
is External Test Project.

00:16:22.351 --> 00:16:23.850
We had a lot of
developer telling us

00:16:23.850 --> 00:16:25.920
that they wanted more
flexibility in how

00:16:25.920 --> 00:16:28.129
they organize their
app and their test.

00:16:28.129 --> 00:16:30.420
And they wanted to make the
test in a different module.

00:16:30.420 --> 00:16:32.100
So you can now do that.

00:16:32.100 --> 00:16:36.310
That test project
targets a specific module

00:16:36.310 --> 00:16:38.920
and a specific variant
of that module.

00:16:38.920 --> 00:16:42.520
There's no support for flavors
or variant in a test module.

00:16:42.520 --> 00:16:43.990
If you want a test
multiple variant

00:16:43.990 --> 00:16:45.406
of your same
application, you have

00:16:45.406 --> 00:16:48.876
to use different
test module for now.

00:16:48.876 --> 00:16:50.500
And those features
are really like part

00:16:50.500 --> 00:16:53.200
of our overarching
story of improving

00:16:53.200 --> 00:16:54.600
testing story on Android.

00:16:54.600 --> 00:16:57.620
So it goes from
Studio and Gradle

00:16:57.620 --> 00:17:01.990
having better support at the
project level and in the tools.

00:17:01.990 --> 00:17:04.880
Having better
testing libraries--

00:17:04.880 --> 00:17:08.730
Espresso, the Android Testing
Library, the Unit Test support,

00:17:08.730 --> 00:17:09.342
and all that.

00:17:09.342 --> 00:17:10.800
Then the test lab
that we announced

00:17:10.800 --> 00:17:12.869
this morning, all the
way to which we in

00:17:12.869 --> 00:17:17.900
have in play-- the play console
about testing your application.

00:17:17.900 --> 00:17:19.750
And our goal is to
make it very easy

00:17:19.750 --> 00:17:23.030
for you to write tests,
run them-- right,

00:17:23.030 --> 00:17:26.050
that's very important too--
to help you make high quality

00:17:26.050 --> 00:17:27.810
application.

00:17:27.810 --> 00:17:29.810
Part of making high
quality application

00:17:29.810 --> 00:17:32.160
is also performance.

00:17:32.160 --> 00:17:35.740
And so when investing a lot
and adding things into studio,

00:17:35.740 --> 00:17:40.160
since 1.0 we added a live
CPU and memory profiling.

00:17:40.160 --> 00:17:42.990
And then, in 1.3 we're
announcing a new viewer

00:17:42.990 --> 00:17:44.320
to view your memory heap.

00:17:44.320 --> 00:17:45.750
We'll have a demo
of that letter.

00:17:48.950 --> 00:17:55.480
Emulator-- so, we've mostly been
focused on stability in order

00:17:55.480 --> 00:17:57.070
to enable performance.

00:17:57.070 --> 00:18:00.320
Now if properly configured, and
running on a compatible system,

00:18:00.320 --> 00:18:03.290
the Emulator can
actually be fast.

00:18:03.290 --> 00:18:05.150
The prime is making
sure that most people

00:18:05.150 --> 00:18:08.140
can run the properly
configured Emulator.

00:18:08.140 --> 00:18:11.740
And so we've been
looking a lot at adding--

00:18:11.740 --> 00:18:12.960
helping you configure it.

00:18:12.960 --> 00:18:15.540
So for example,
Studio out of the box

00:18:15.540 --> 00:18:19.700
will now install-- download
and install HAXM for you

00:18:19.700 --> 00:18:22.980
in order to run it, you
know, at native speed on x86.

00:18:22.980 --> 00:18:24.430
The AVD manager
will automatically

00:18:24.430 --> 00:18:25.494
configure it for you.

00:18:25.494 --> 00:18:27.660
And the other thing that
we've done recently-- we've

00:18:27.660 --> 00:18:31.170
fixed literally thousands of
issues in the GL renderer-- the

00:18:31.170 --> 00:18:33.560
how to our GL renderer
Because if you're

00:18:33.560 --> 00:18:35.210
forced to move to
the software renderer

00:18:35.210 --> 00:18:37.630
because you're graphic
driver isn't compatible,

00:18:37.630 --> 00:18:39.514
the experience is much worse.

00:18:39.514 --> 00:18:40.930
So we've done a
lot of improvement

00:18:40.930 --> 00:18:44.610
there in order to help
you, basically, run

00:18:44.610 --> 00:18:46.182
as fast as it can be.

00:18:46.182 --> 00:18:47.640
And then, specifically,
for M we're

00:18:47.640 --> 00:18:50.610
adding some new features like
the fingerprint emuation--

00:18:50.610 --> 00:18:53.880
where you can add fingerprints,
register fingerprint, and then

00:18:53.880 --> 00:18:57.090
use them when your
application request them.

00:18:57.090 --> 00:18:59.560
Talking about Emulator,
later this year we're

00:18:59.560 --> 00:19:03.010
going to launch a new Emulator
specifically for Android Auto.

00:19:03.010 --> 00:19:04.970
So it will be a
head unit Emulator.

00:19:04.970 --> 00:19:07.750
You will be able to take either
an Android-- like a phone

00:19:07.750 --> 00:19:10.950
emulator or physical
device-- just connect them

00:19:10.950 --> 00:19:13.820
to your machine and then
the head unit will basically

00:19:13.820 --> 00:19:17.415
show what you would see on
a car with Android Auto.

00:19:20.540 --> 00:19:23.730
All right and I give
it to Tor for demos.

00:19:23.730 --> 00:19:26.985
TOR NORBYE: All right, who
wants to see the C++ report?

00:19:26.985 --> 00:19:28.925
[APPLAUSE]

00:19:30.870 --> 00:19:33.120
All right, can we switch
to-- yes, you already have.

00:19:33.120 --> 00:19:35.295
So this is C++.

00:19:35.295 --> 00:19:38.200
You remember pointers?

00:19:38.200 --> 00:19:40.700
So what you're looking at here
is a game that's been written

00:19:40.700 --> 00:19:41.200
in C++.

00:19:41.200 --> 00:19:44.230
And as you can see, the source
editor is fully aware of that.

00:19:44.230 --> 00:19:47.020
It's warming us that these
include statements are actually

00:19:47.020 --> 00:19:49.230
unused, because none of
the symbols in the Include

00:19:49.230 --> 00:19:51.620
are actually used
in the source file.

00:19:51.620 --> 00:19:53.857
So I can invoke the action
to just clean that up,

00:19:53.857 --> 00:19:54.940
and that gets rid of that.

00:19:57.510 --> 00:19:59.760
I can use the normal
navigation commands.

00:19:59.760 --> 00:20:03.770
So with F12 I can filter
and jump to the right method

00:20:03.770 --> 00:20:05.570
that I'm looking for.

00:20:05.570 --> 00:20:08.700
I can use the action to jump
to related symbol, which

00:20:08.700 --> 00:20:10.820
will navigate to the
header file prototype.

00:20:10.820 --> 00:20:13.720
And I can use that to jump back.

00:20:13.720 --> 00:20:14.800
Yay!

00:20:14.800 --> 00:20:18.540
I can use the action to
jump to the super method.

00:20:18.540 --> 00:20:21.570
I can also use find usages.

00:20:21.570 --> 00:20:24.930
So if I do find usages
on the symbol right here,

00:20:24.930 --> 00:20:27.660
you can see it's doing and non
textual-- an actual accurate

00:20:27.660 --> 00:20:29.360
search through the symbols.

00:20:29.360 --> 00:20:34.340
And related to find usages,
of course, is refactoring.

00:20:34.340 --> 00:20:37.150
So I can do a rename on
this method, right here.

00:20:37.150 --> 00:20:41.690
Get instance-- let's
call it, get singleton.

00:20:41.690 --> 00:20:43.784
And when I do that the
ID-- it looks at everything

00:20:43.784 --> 00:20:46.200
and discovers that, hey, there's
some textual occurrences.

00:20:46.200 --> 00:20:47.610
Do you want those as well?

00:20:47.610 --> 00:20:50.940
So I can pull up the
show usages window.

00:20:50.940 --> 00:20:53.105
Here I can see that we
have some text files that

00:20:53.105 --> 00:20:55.062
are using this API,
but I don't, actually,

00:20:55.062 --> 00:20:56.770
want to include those
in the refactoring.

00:20:56.770 --> 00:20:57.970
So I'll just delete it.

00:20:57.970 --> 00:21:00.560
And then we have all the
accurate matches here.

00:21:00.560 --> 00:21:03.380
So I can just apply the
refactoring, and voila,

00:21:03.380 --> 00:21:07.050
change has been made in C++.

00:21:07.050 --> 00:21:09.180
All right, as you can
see here the editor

00:21:09.180 --> 00:21:10.680
is also doing things
like telling me

00:21:10.680 --> 00:21:13.310
that this symbol is unused.

00:21:13.310 --> 00:21:15.610
Actually, let's
just use it instead.

00:21:15.610 --> 00:21:20.110
So we have code completion.

00:21:20.110 --> 00:21:21.670
And I can use the
normal stuff you're

00:21:21.670 --> 00:21:23.590
used to from Java
programming, where you type

00:21:23.590 --> 00:21:24.756
some of the capital letters.

00:21:24.756 --> 00:21:28.180
So if I type O, P, M-- it's
matching on pointer move,

00:21:28.180 --> 00:21:31.320
and I can, then, insert
that and perform--

00:21:31.320 --> 00:21:34.200
insert whatever the parameters
are that I need for this method

00:21:34.200 --> 00:21:36.350
call.

00:21:36.350 --> 00:21:39.350
Furthermore, them I can
select some expressions,

00:21:39.350 --> 00:21:43.410
and I can extract
this into a variable.

00:21:43.410 --> 00:21:45.300
It picks a suitable name for me.

00:21:45.300 --> 00:21:49.860
Or I can go in, in-line
it back into the code,

00:21:49.860 --> 00:21:51.900
and it'll do that.

00:21:51.900 --> 00:21:54.460
And take a look at this here,
I have two local variables.

00:21:54.460 --> 00:21:58.000
I can actually extract
this into a method.

00:21:58.000 --> 00:22:01.470
And even though I have multiple
outputs from this method,

00:22:01.470 --> 00:22:04.880
that's not a problem in C++
because it can just do pass

00:22:04.880 --> 00:22:07.516
by reference.

00:22:07.516 --> 00:22:08.890
So if I now jump
in here, you can

00:22:08.890 --> 00:22:12.920
see that we have the
variables passed in.

00:22:12.920 --> 00:22:16.440
So the key thing here is that
this is not just a port of all

00:22:16.440 --> 00:22:17.850
the Java features of C++.

00:22:17.850 --> 00:22:20.550
They have a lot of unique
C++ features as well.

00:22:20.550 --> 00:22:22.500
So for a factory,
for example, I can

00:22:22.500 --> 00:22:26.680
extract into macros-- I
can extract type typedefs

00:22:26.680 --> 00:22:28.390
and so forth.

00:22:28.390 --> 00:22:31.650
So there's a lot of C++ features
that I could get into and I

00:22:31.650 --> 00:22:33.380
could spend the
whole demo on that--

00:22:33.380 --> 00:22:37.480
on code styles and formatting,
on intentions, inspections.

00:22:37.480 --> 00:22:38.550
We have a debugger.

00:22:38.550 --> 00:22:39.810
We support GDB and LLDB.

00:22:39.810 --> 00:22:41.320
I just want to show
one more thing,

00:22:41.320 --> 00:22:42.820
and this is,
specifically, for those

00:22:42.820 --> 00:22:46.200
of you doing JNI development
with the Android NDK.

00:22:46.200 --> 00:22:50.990
So let me jump into my JNI file.

00:22:50.990 --> 00:22:52.720
So here is a JNICALL.

00:22:52.720 --> 00:22:56.090
So if I do find
usages on this method,

00:22:56.090 --> 00:22:58.285
you can see that it's
highlighting not just the C

00:22:58.285 --> 00:23:01.630
code, but also the native
declaration in Java,

00:23:01.630 --> 00:23:04.690
as well as calls to
that Java method.

00:23:04.690 --> 00:23:07.090
[APPLAUSE]

00:23:09.844 --> 00:23:11.510
And notice that there's
this little icon

00:23:11.510 --> 00:23:12.650
and then you might
be able to see,

00:23:12.650 --> 00:23:14.550
but this is for jumping
between related symbols.

00:23:14.550 --> 00:23:17.190
So just like I can jump between
an implementation and a header

00:23:17.190 --> 00:23:18.620
file, I can use
the same keystroke

00:23:18.620 --> 00:23:22.050
to jump between JNI method
and the declaration.

00:23:22.050 --> 00:23:25.290
And look what happens if
I break this signature.

00:23:25.290 --> 00:23:27.010
If I type in some
random thing here

00:23:27.010 --> 00:23:28.580
and I go back to
Java-- you could

00:23:28.580 --> 00:23:32.130
see now we know in editor, this
is no longer a valid binding.

00:23:32.130 --> 00:23:34.080
And this is actually
really good way

00:23:34.080 --> 00:23:35.950
for me to create
new Native methods.

00:23:35.950 --> 00:23:39.155
I just make the method
declaration that I want.

00:23:39.155 --> 00:23:40.780
Let's make it a little
more interesting

00:23:40.780 --> 00:23:43.540
to input some parameters into
it like a string and an integer

00:23:43.540 --> 00:23:46.320
array.

00:23:46.320 --> 00:23:48.290
And now there's a
quick fix, which

00:23:48.290 --> 00:23:50.210
will create the
right JNI binding,

00:23:50.210 --> 00:23:51.780
insert it into the C code--

00:23:51.780 --> 00:23:54.095
[APPLAUSE]

00:23:57.340 --> 00:23:59.790
And you can see, we're also
inserting things like, hey,

00:23:59.790 --> 00:24:01.590
we're passing you a
Java unicode string.

00:24:01.590 --> 00:24:03.480
It will convert that
into a const char

00:24:03.480 --> 00:24:06.202
for C. Ditto for erase, and then
don't forget to release them

00:24:06.202 --> 00:24:06.910
when you're done.

00:24:06.910 --> 00:24:08.368
So we hope the
feature will make it

00:24:08.368 --> 00:24:10.250
a lot easier to work with JNI.

00:24:10.250 --> 00:24:13.970
Now I want to jump over
to discuss editing Java.

00:24:13.970 --> 00:24:19.169
So let's see, today we
are releasing-- actually

00:24:19.169 --> 00:24:20.460
I think we already released it.

00:24:20.460 --> 00:24:22.335
There's a new version
of the Support Library.

00:24:22.335 --> 00:24:24.550
And it has the Design
Library, and so forth.

00:24:24.550 --> 00:24:28.290
But there are now
13 new annotations

00:24:28.290 --> 00:24:31.615
you can use in your code to,
basically, catch more bugs.

00:24:31.615 --> 00:24:33.990
And we've used these annotations
in the Android framework

00:24:33.990 --> 00:24:36.980
and the support libraries
to catch your bugs, as well.

00:24:36.980 --> 00:24:39.890
So first of all, there's
some threading annotations.

00:24:39.890 --> 00:24:42.510
So here we're saying that
this method is a worker thread

00:24:42.510 --> 00:24:43.010
method.

00:24:43.010 --> 00:24:45.260
That means we expect it be
called in a worker thread.

00:24:45.260 --> 00:24:47.780
And we've already annotated the
framework with the knowledge

00:24:47.780 --> 00:24:50.800
that view code has to be
invoked in the UI thread.

00:24:50.800 --> 00:24:52.950
So we can instantly
tell here, hey, you're

00:24:52.950 --> 00:24:55.955
calling a UI thread method from
a worker thread-- that's bad.

00:24:55.955 --> 00:24:58.580
And you don't have to go and put
worker thread on your own code

00:24:58.580 --> 00:24:59.829
because we've already done it.

00:24:59.829 --> 00:25:01.170
For example, AsyncTask.

00:25:01.170 --> 00:25:02.930
If you make an
AsyncTask, and you

00:25:02.930 --> 00:25:05.230
do something in the
doInBackground method,

00:25:05.230 --> 00:25:06.657
notice there's no
annotation here.

00:25:06.657 --> 00:25:08.490
We still flag this code
as, well, this one's

00:25:08.490 --> 00:25:10.198
supposed to be called
on the main thread.

00:25:10.198 --> 00:25:11.660
And this one, you
know, UI thread.

00:25:11.660 --> 00:25:14.284
So that's the
threading annotations.

00:25:14.284 --> 00:25:15.450
There's the size annotation.

00:25:15.450 --> 00:25:17.776
Here you can say things like,
well, I want this string

00:25:17.776 --> 00:25:19.400
to be a certain length
or this an array

00:25:19.400 --> 00:25:21.960
to be a certain size--
maybe max, maybe

00:25:21.960 --> 00:25:23.652
an exact number, maybe a min.

00:25:23.652 --> 00:25:25.110
Or you could even
say, multiple of.

00:25:25.110 --> 00:25:27.735
So if you take an array, and you
want it to be XYZ coordinates,

00:25:27.735 --> 00:25:29.432
you could say multiple of three.

00:25:29.432 --> 00:25:31.390
So here for example I'm
passing a string that's

00:25:31.390 --> 00:25:33.320
too long for this constraint.

00:25:33.320 --> 00:25:37.230
And here, we're passing an
array that is of the wrong size.

00:25:37.230 --> 00:25:40.340
So similar to size we have int
and range-- int range and float

00:25:40.340 --> 00:25:41.300
range annotations.

00:25:41.300 --> 00:25:43.570
Here you can say that
this value needs to be

00:25:43.570 --> 00:25:45.020
in this constrained range.

00:25:45.020 --> 00:25:48.000
This is really useful
for things like alpha.

00:25:48.000 --> 00:25:50.110
So it turns out
that for image view,

00:25:50.110 --> 00:25:53.080
the alpha value is a integer
between zero and 255.

00:25:53.080 --> 00:25:56.150
But for view, it's a floating
point between zero and one.

00:25:56.150 --> 00:25:59.020
So what we're doing here is,
I thought, opacity-- 128.

00:25:59.020 --> 00:26:00.620
That should be half
opacity, right?

00:26:00.620 --> 00:26:03.320
That's correct for Image
View but not for Button.

00:26:03.320 --> 00:26:04.900
And so this,
basically, tells you

00:26:04.900 --> 00:26:08.140
that you're passing a parameter
that's not the right range.

00:26:08.140 --> 00:26:10.107
Check results--
basically you can

00:26:10.107 --> 00:26:12.690
use this to tell the client code
that they better do something

00:26:12.690 --> 00:26:14.570
with the return value.

00:26:14.570 --> 00:26:16.890
And call super
says that if anyone

00:26:16.890 --> 00:26:21.460
overwrites your method they
better invoke super dot method.

00:26:21.460 --> 00:26:23.510
And then there's color
int, which is used to say,

00:26:23.510 --> 00:26:24.860
this integer represents a color.

00:26:24.860 --> 00:26:26.560
And we'll see that
a little bit later.

00:26:26.560 --> 00:26:29.280
Last but not least--
requires permission.

00:26:29.280 --> 00:26:32.090
So this let's you, say, that
a certain method requires

00:26:32.090 --> 00:26:33.390
a particular permission.

00:26:33.390 --> 00:26:35.350
Or maybe all of a
set of permissions,

00:26:35.350 --> 00:26:37.570
or any of a set of permissions.

00:26:37.570 --> 00:26:39.480
So we've already
added to the framework

00:26:39.480 --> 00:26:42.240
with some of these
permission requirements.

00:26:42.240 --> 00:26:44.070
So for example,
Location Manager--

00:26:44.070 --> 00:26:47.102
if I'm trying to invoke
at last known location,

00:26:47.102 --> 00:26:49.560
we will say that, hey, you
don't hold the right permissions

00:26:49.560 --> 00:26:50.435
for this method call.

00:26:50.435 --> 00:26:51.960
Would you like to add them?

00:26:51.960 --> 00:26:52.820
Yes, I would.

00:26:52.820 --> 00:26:55.060
So there's a quick fix for that.

00:26:55.060 --> 00:26:58.420
And so I can say please add the
find location to my manifest.

00:26:58.420 --> 00:27:02.070
And so I do that, but sadly
there's still the red line.

00:27:02.070 --> 00:27:03.746
What does that line mean?

00:27:03.746 --> 00:27:05.620
Well if you watched the
keynote this morning,

00:27:05.620 --> 00:27:09.380
M is, basically, now supporting
revocable permissions.

00:27:09.380 --> 00:27:12.000
So here, because my
app is targeting M,

00:27:12.000 --> 00:27:14.520
this method can throw
security exception,

00:27:14.520 --> 00:27:16.740
even though I specifically
requested the permission

00:27:16.740 --> 00:27:17.740
in the manifest.

00:27:17.740 --> 00:27:20.540
So what I should do is actually
check for the permission first.

00:27:20.540 --> 00:27:23.290
So we track that I'm not
actually doing that check,

00:27:23.290 --> 00:27:24.957
and there's a quick
fix to add it.

00:27:24.957 --> 00:27:27.290
Which, basically, looking at
the permission requirements

00:27:27.290 --> 00:27:29.269
will add the right
checks and also suggest

00:27:29.269 --> 00:27:30.810
what you should do
if you really want

00:27:30.810 --> 00:27:32.890
to ask the user with
the callback, and all

00:27:32.890 --> 00:27:34.280
that good stuff.

00:27:34.280 --> 00:27:35.830
So that's the static analysis.

00:27:35.830 --> 00:27:38.640
We're also taking that
into the debugger.

00:27:38.640 --> 00:27:42.840
So here I am in the middle
of debugging this code.

00:27:42.840 --> 00:27:47.270
And you can see here I'm looking
at this variable here-- flags.

00:27:47.270 --> 00:27:49.220
It's a local variable
and the value is five.

00:27:49.220 --> 00:27:51.010
What this five mean?

00:27:51.010 --> 00:27:51.870
Anyone?

00:27:51.870 --> 00:27:53.520
Well let's ask the debugger.

00:27:53.520 --> 00:27:55.380
So I can right click
on this and say view

00:27:55.380 --> 00:27:58.060
as Android type integer.

00:27:58.060 --> 00:27:59.478
And when I do that--

00:27:59.478 --> 00:28:01.918
[APPLAUSE]

00:28:05.570 --> 00:28:07.070
So for those of you
who didn't clap,

00:28:07.070 --> 00:28:09.330
let me show you
what just happened.

00:28:09.330 --> 00:28:12.375
Basically this local variable--
we traced this to this field.

00:28:12.375 --> 00:28:13.540
We look at the field.

00:28:13.540 --> 00:28:15.336
We see that it has a getter.

00:28:15.336 --> 00:28:17.210
We see that the getter
has a type annotation.

00:28:17.210 --> 00:28:20.187
The type annotation says that
we had these possible constants.

00:28:20.187 --> 00:28:22.520
And we check the constants
and find the ones that match.

00:28:22.520 --> 00:28:24.060
And that's how we produced this.

00:28:24.060 --> 00:28:25.890
So that's pretty neat.

00:28:25.890 --> 00:28:29.570
[APPLAUSE]

00:28:29.570 --> 00:28:31.264
And this is not
just for typedefs.

00:28:31.264 --> 00:28:33.180
For example, here I have
another integer field

00:28:33.180 --> 00:28:37.330
which-- minus 65,408-- I don't
know if that rings a bell,

00:28:37.330 --> 00:28:40.990
but I can ask it to do a
type conversion on this one.

00:28:40.990 --> 00:28:42.540
Oh, it's a color.

00:28:42.540 --> 00:28:45.210
Because color int puts the
annotation that we saw earlier,

00:28:45.210 --> 00:28:46.482
and that's been an annotated.

00:28:46.482 --> 00:28:48.190
Text ID is another
one of those integers,

00:28:48.190 --> 00:28:49.347
and I can convert this one.

00:28:49.347 --> 00:28:51.430
And it figures out, well,
that's a resource string

00:28:51.430 --> 00:28:54.410
and it corresponds to this
specific string object.

00:28:54.410 --> 00:28:59.120
[APPLAUSE]

00:28:59.120 --> 00:29:00.120
So that's a new feature.

00:29:00.120 --> 00:29:01.550
I hope you'll find that useful.

00:29:01.550 --> 00:29:04.080
Now I'm going to show you Data
Binding very, very briefly.

00:29:04.080 --> 00:29:06.560
So here I am in an activity.

00:29:06.560 --> 00:29:09.110
And this activity-- I
actually have a layout

00:29:09.110 --> 00:29:10.664
called main activity
in my project.

00:29:10.664 --> 00:29:12.080
If you ever made
a Studio project,

00:29:12.080 --> 00:29:13.930
you probably have one, too.

00:29:13.930 --> 00:29:15.910
And so the Gradle
plug-in actually

00:29:15.910 --> 00:29:18.020
creates this class
main activity binding,

00:29:18.020 --> 00:29:21.060
which takes all the
fields in your layout

00:29:21.060 --> 00:29:24.890
and produces getters-- or
actually field accessors.

00:29:24.890 --> 00:29:27.706
You can see here I have
something called Robot list.

00:29:27.706 --> 00:29:29.830
I forgot to tell you, the
Data Binder is done here.

00:29:29.830 --> 00:29:33.530
Here we're actually associating
this activity with this layout.

00:29:33.530 --> 00:29:36.220
So once I've done that,
we get these magic fields.

00:29:36.220 --> 00:29:38.020
And these are just
IDs in my layout.

00:29:38.020 --> 00:29:40.541
If I do go to declaration,
I jump right into my layout.

00:29:40.541 --> 00:29:43.040
You can see it's just a recycler
view and robot list is just

00:29:43.040 --> 00:29:43.860
the ID.

00:29:43.860 --> 00:29:46.514
So if I change that ID to
something else, and I go back,

00:29:46.514 --> 00:29:49.180
you could see now that it knows,
hey, that's not the right field

00:29:49.180 --> 00:29:50.096
on this class anymore.

00:29:50.096 --> 00:29:51.680
This is a dynamically
generated code.

00:29:51.680 --> 00:29:54.140
So I can go and fix it.

00:29:54.140 --> 00:29:57.160
And there's code completion
on this, as well, of course.

00:29:57.160 --> 00:29:58.300
So that's the Binder.

00:29:58.300 --> 00:30:00.749
This handles all the fine
findViewByID binding for you.

00:30:00.749 --> 00:30:02.040
You now longer have to do that.

00:30:02.040 --> 00:30:04.248
You get getters and setters
and everything is handled

00:30:04.248 --> 00:30:07.240
in the thread safe correct way.

00:30:07.240 --> 00:30:08.820
So if I look in the
layout file, you

00:30:08.820 --> 00:30:10.900
can see here that there's
a bunch of new tags.

00:30:10.900 --> 00:30:12.250
I can create variables.

00:30:12.250 --> 00:30:13.880
And I can even do imports.

00:30:13.880 --> 00:30:15.980
And I can alias them,
so I have simpler thing

00:30:15.980 --> 00:30:18.300
to refer to in my code below.

00:30:18.300 --> 00:30:21.510
And then, in the layout,
I can do things like this.

00:30:21.510 --> 00:30:25.930
I can take methods, like
the onts-- all the setters

00:30:25.930 --> 00:30:28.450
and getters on the views are
accessible here as properties,

00:30:28.450 --> 00:30:30.840
and, likewise, on the activity.

00:30:30.840 --> 00:30:32.330
And I can also compute value.

00:30:32.330 --> 00:30:34.420
So I can bind the
Android text attribute

00:30:34.420 --> 00:30:35.870
to this expression,
which is using

00:30:35.870 --> 00:30:37.770
the variable I declared
above and mapping

00:30:37.770 --> 00:30:39.180
two properties Natively.

00:30:39.180 --> 00:30:41.810
So this takes out a lot
of the Plumbing Code,

00:30:41.810 --> 00:30:45.280
and I can't actually do
this justice in 90 seconds.

00:30:45.280 --> 00:30:49.088
But it's available
now, so please, try it.

00:30:49.088 --> 00:30:50.920
[APPLAUSE]

00:30:53.210 --> 00:30:55.310
So now my talk about
performance for a second.

00:30:55.310 --> 00:30:58.027
So as Xav showed
in the screenshot,

00:30:58.027 --> 00:31:00.110
you can go and capture
performance snapshots here,

00:31:00.110 --> 00:31:02.390
now, in the Android view,
from your connected device.

00:31:02.390 --> 00:31:04.620
And once you do
that, we basically

00:31:04.620 --> 00:31:07.987
show the performance data files
here in the captures view.

00:31:07.987 --> 00:31:09.570
So you can, basically,
accumulate them

00:31:09.570 --> 00:31:11.150
here for later
analysis, or if you

00:31:11.150 --> 00:31:13.260
want to compare two
different captures.

00:31:13.260 --> 00:31:15.520
So let me first open up
the allocation tracker.

00:31:15.520 --> 00:31:17.980
So here I can see
that for this capture,

00:31:17.980 --> 00:31:20.530
thread one was responsible
for most of their RAM--

00:31:20.530 --> 00:31:22.150
or most of the allocations.

00:31:22.150 --> 00:31:25.119
And I can start drilling in
here to see what was happening.

00:31:25.119 --> 00:31:27.660
And I can find that, well, looks
like full screen activity is

00:31:27.660 --> 00:31:29.130
doing something bad.

00:31:29.130 --> 00:31:32.300
It's calling a lot of string
builder stuff with text view.

00:31:32.300 --> 00:31:34.680
We also have a way to show
that as a sunburst chart.

00:31:34.680 --> 00:31:37.550
So if I invoke that, you can see
we get this little nice chart

00:31:37.550 --> 00:31:38.660
below here.

00:31:38.660 --> 00:31:43.220
And I can sort by, for
example, size or count.

00:31:43.220 --> 00:31:46.320
And we also have this
other layout representation

00:31:46.320 --> 00:31:46.820
of the data.

00:31:46.820 --> 00:31:48.194
So you can use
this and basically

00:31:48.194 --> 00:31:51.700
drill over to see what's going
on with your allocations.

00:31:51.700 --> 00:31:54.740
We can also grab a heap
dump from your app.

00:31:54.740 --> 00:31:56.810
Or maybe one of your
customer sends you one,

00:31:56.810 --> 00:31:58.710
and, you know, you
can ask for this,

00:31:58.710 --> 00:32:00.560
if you want to find
out what's going on.

00:32:00.560 --> 00:32:02.990
So you no longer have to
convert your H profiles.

00:32:02.990 --> 00:32:04.720
We read them directly now.

00:32:04.720 --> 00:32:08.320
And so all have to do
is click it to open it.

00:32:08.320 --> 00:32:10.730
And-- let me get
myself some more room,

00:32:10.730 --> 00:32:13.710
I'm using really large
font so you can see.

00:32:13.710 --> 00:32:16.104
So, here we have
several columns.

00:32:16.104 --> 00:32:17.520
And the most
important one, maybe,

00:32:17.520 --> 00:32:18.930
is the retained size column.

00:32:18.930 --> 00:32:21.680
So if I sort by descending
order of retained size,

00:32:21.680 --> 00:32:24.510
this is telling me the
cumulative amount of memory

00:32:24.510 --> 00:32:26.770
I could save if I could
get rid of these objects.

00:32:26.770 --> 00:32:28.910
So here you can see we
have a lot of bitmaps,

00:32:28.910 --> 00:32:31.840
and when I select
the class, I get

00:32:31.840 --> 00:32:34.140
an instance view on the right.

00:32:34.140 --> 00:32:38.070
In here we're using the
debugger UI to basically--

00:32:38.070 --> 00:32:40.520
you could now inspect
objects from the heap dump

00:32:40.520 --> 00:32:42.900
as if you're debugging them
and look at the values.

00:32:42.900 --> 00:32:44.690
That perhaps the most
important part here

00:32:44.690 --> 00:32:46.930
is the reference tree below.

00:32:46.930 --> 00:32:49.450
So this is showing you all
the incoming references

00:32:49.450 --> 00:32:50.609
to this object.

00:32:50.609 --> 00:32:52.150
And we're always
sorting it so that's

00:32:52.150 --> 00:32:55.645
the nearest garbage collection
root is the first field.

00:32:55.645 --> 00:32:56.520
So look what happens.

00:32:56.520 --> 00:32:58.580
When I start expanding
the first child here.

00:32:58.580 --> 00:33:00.100
You see the depth column?

00:33:00.100 --> 00:33:02.640
This is counting down
to the nearest GC root,

00:33:02.640 --> 00:33:03.750
as I'm going down.

00:33:03.750 --> 00:33:05.290
And so here I found it.

00:33:05.290 --> 00:33:07.550
Basically, this is
the static instance

00:33:07.550 --> 00:33:10.520
that is causing all the chain
of pointers to my object

00:33:10.520 --> 00:33:11.630
and keeping in memory.

00:33:11.630 --> 00:33:14.130
So if you have a memory leak,
and you want to get rid of it,

00:33:14.130 --> 00:33:16.030
or if you're wondering where's
most the memory coming,

00:33:16.030 --> 00:33:17.770
this is an, I think,
an invaluable tool.

00:33:17.770 --> 00:33:20.646
And this is now available
in the 1.3 preview.

00:33:20.646 --> 00:33:23.061
[APPLAUSE]

00:33:26.450 --> 00:33:28.409
All right, let's talk
about Developer Services.

00:33:28.409 --> 00:33:29.950
So first of all,
let me just show you

00:33:29.950 --> 00:33:31.660
that I'm logged into
my Google account,

00:33:31.660 --> 00:33:32.520
in the upper right corner.

00:33:32.520 --> 00:33:34.370
That's going to become
relevant in a second.

00:33:34.370 --> 00:33:37.960
So I can open up the project
structure dialogue here,

00:33:37.960 --> 00:33:40.830
and you could see the modulus
that you're used to seeing,

00:33:40.830 --> 00:33:43.850
it's now below this new
developer services section.

00:33:43.850 --> 00:33:47.010
So here we're integrating
various developer services.

00:33:47.010 --> 00:33:48.990
So for example,
there's GCM, there's

00:33:48.990 --> 00:33:51.155
authentication,
analytics, and ads.

00:33:51.155 --> 00:33:53.780
Most of these are just adding a
dependency on the Play Services

00:33:53.780 --> 00:33:54.430
library.

00:33:54.430 --> 00:33:56.440
But we've fleshed out
the analytics integration

00:33:56.440 --> 00:33:57.640
in a bit more detail.

00:33:57.640 --> 00:34:00.430
So now I can, basically,
say that I want

00:34:00.430 --> 00:34:03.170
to add analytics to my project.

00:34:03.170 --> 00:34:05.590
When I do that, because
I'm logged in-- otherwise

00:34:05.590 --> 00:34:07.550
it would say please
login first--

00:34:07.550 --> 00:34:11.520
it's now made a connection to
the Google Analytics console.

00:34:11.520 --> 00:34:13.800
It's pulling down the
Google analytics projects

00:34:13.800 --> 00:34:15.190
associated with my account.

00:34:15.190 --> 00:34:16.040
I can choose it.

00:34:16.040 --> 00:34:18.010
It fetches the right tracker ID.

00:34:18.010 --> 00:34:21.310
And when I say, OK, it
now goes and creates

00:34:21.310 --> 00:34:24.392
this analytics tracker
class in my project.

00:34:24.392 --> 00:34:26.850
This is very similar to the
code that you would find online

00:34:26.850 --> 00:34:29.540
if you go to Google
Analytics documentation that

00:34:29.540 --> 00:34:30.969
says what to do.

00:34:30.969 --> 00:34:34.510
It also creates a
app tracker file

00:34:34.510 --> 00:34:36.810
which records the tracker
ID for my project.

00:34:36.810 --> 00:34:39.236
Please don't use it.

00:34:39.236 --> 00:34:41.110
And so now there's this
class that, you then,

00:34:41.110 --> 00:34:42.989
will have to initialize
from your context.

00:34:42.989 --> 00:34:44.739
And of course the
callback to whenever you

00:34:44.739 --> 00:34:46.280
want to record an
analytics event.

00:34:46.280 --> 00:34:48.613
So this is something we're
planning to do a lot more of.

00:34:48.613 --> 00:34:50.870
We're going to build out
more services, and so forth.

00:34:50.870 --> 00:34:53.080
But we think this is a
pretty useful start, so let

00:34:53.080 --> 00:34:55.110
us know how this works for you.

00:34:55.110 --> 00:34:57.647
We've also done
something to help

00:34:57.647 --> 00:34:59.980
you stay up to date on all
the SDK components that we're

00:34:59.980 --> 00:35:00.870
releasing.

00:35:00.870 --> 00:35:03.430
So in the past, with
the old SDK manager,

00:35:03.430 --> 00:35:05.152
you had to regularly
open it and see,

00:35:05.152 --> 00:35:06.360
is there anything new for me?

00:35:06.360 --> 00:35:08.130
Well, we're now using
the same mechanism

00:35:08.130 --> 00:35:10.195
that we push IDE
notifications up to,

00:35:10.195 --> 00:35:12.479
to also notify that
there's new SDK components.

00:35:12.479 --> 00:35:14.020
So here it's telling
me, hey, there's

00:35:14.020 --> 00:35:16.490
a new M preview platform.

00:35:16.490 --> 00:35:19.130
And I can now click
to use the ID patching

00:35:19.130 --> 00:35:20.670
mechanism to update this.

00:35:20.670 --> 00:35:22.780
We've also ported
the SDK manager,

00:35:22.780 --> 00:35:25.070
so that it's not fully
integrated with IDE

00:35:25.070 --> 00:35:26.700
with, sort of, a
newer fresher-- yes

00:35:26.700 --> 00:35:27.420
[APPLAUSE]

00:35:27.420 --> 00:35:28.420
--I agree.

00:35:28.420 --> 00:35:31.790
A new fresh IDE-- UI
on it that I can then

00:35:31.790 --> 00:35:32.930
use to install stuff.

00:35:32.930 --> 00:35:34.638
And so hopefully this
will make it easier

00:35:34.638 --> 00:35:38.030
to stay up to date with all the
stuff that we are releasing.

00:35:38.030 --> 00:35:40.870
OK, so everything
I've showed you today

00:35:40.870 --> 00:35:42.730
is going to be in 1.3.

00:35:42.730 --> 00:35:46.166
Now it turns out the C++ support
is not in the first preview.

00:35:46.166 --> 00:35:48.540
It's-- we didn't make it, but
it'll be in the next couple

00:35:48.540 --> 00:35:51.750
weeks-- next couple weeks, it'll
be in the next preview build.

00:35:51.750 --> 00:35:54.220
But everything else I've
showed you is in 1.3 preview.

00:35:54.220 --> 00:35:56.386
Now I'm going to show you
a couple of things they're

00:35:56.386 --> 00:35:58.810
coming in upcoming versions.

00:35:58.810 --> 00:36:02.880
So the first thing
is the Theme Editor.

00:36:02.880 --> 00:36:07.280
So this is the styles at XML
file for the I/O scheduling

00:36:07.280 --> 00:36:08.580
application.

00:36:08.580 --> 00:36:09.080
Right?

00:36:09.080 --> 00:36:10.410
It's pretty complicated.

00:36:10.410 --> 00:36:13.350
And this is just one of
four overloaded files.

00:36:13.350 --> 00:36:15.820
So we now have a Theme Editor.

00:36:15.820 --> 00:36:18.210
Well will have-- we have a
prototype-- we're working on

00:36:18.210 --> 00:36:20.880
it-- have a Theme Editor, which
basically takes select data,

00:36:20.880 --> 00:36:23.676
analyzes it-- Yeah,
you're allowed to clap.

00:36:23.676 --> 00:36:26.006
[APPLAUSE]

00:36:28.572 --> 00:36:30.780
You could see this, basically,
analyzes the projects,

00:36:30.780 --> 00:36:32.400
figures out what's going on.

00:36:32.400 --> 00:36:34.600
I can choose between
different themes here.

00:36:34.600 --> 00:36:37.270
And I can also make edits.

00:36:37.270 --> 00:36:39.140
So it's showing me
here, for example,

00:36:39.140 --> 00:36:43.250
that I have a state list
here-- the checkerboard is

00:36:43.250 --> 00:36:46.510
trying to show the alpha
value of the color.

00:36:46.510 --> 00:36:48.385
It's showing me how the
colors were resolved.

00:36:48.385 --> 00:36:50.843
And perhaps, most importantly,
I can use this to, actually,

00:36:50.843 --> 00:36:51.600
tweak the colors.

00:36:51.600 --> 00:36:54.110
So if I open up a
color chooser here--

00:36:54.110 --> 00:36:56.810
oh this screen resolution
is not helping--

00:36:56.810 --> 00:36:58.970
you can see that as I'm
tweaking the colors,

00:36:58.970 --> 00:37:02.557
I can see a live preview
of what these widgets will

00:37:02.557 --> 00:37:03.640
look like with that color.

00:37:03.640 --> 00:37:07.680
This should make it a lot
easier to tweak your themes.

00:37:07.680 --> 00:37:11.430
All right last but not
least, the Layout Editor.

00:37:11.430 --> 00:37:14.210
We are working to
completely rewrite it,

00:37:14.210 --> 00:37:16.870
with a lot of new features.

00:37:16.870 --> 00:37:18.830
So it's early days
still, but one

00:37:18.830 --> 00:37:20.730
of the things we're
working on is possibly

00:37:20.730 --> 00:37:22.572
having a blueprint
mode for your layout.

00:37:22.572 --> 00:37:24.280
So you can, sort of,
see what's going on.

00:37:24.280 --> 00:37:28.670
And you can, sort of, work
in both modes the same time.

00:37:28.670 --> 00:37:31.220
We're integrating the
Google design library.

00:37:31.220 --> 00:37:33.710
So for example, I can
drag an app bar layout

00:37:33.710 --> 00:37:35.249
on to this layout.

00:37:35.249 --> 00:37:37.540
And so-- oh, I shouldn't have
changed the color to red.

00:37:37.540 --> 00:37:39.070
That looks so ugly.

00:37:39.070 --> 00:37:42.140
All right, anyway, I'm
now going to go and pull

00:37:42.140 --> 00:37:45.150
in, for example, a--
didn't I have a--

00:37:45.150 --> 00:37:46.330
what's the name of the logo?

00:37:46.330 --> 00:37:47.290
Yeah, there it is.

00:37:47.290 --> 00:37:49.470
I can pull in an I/O
logo, which doesn't really

00:37:49.470 --> 00:37:51.790
work with the red, but fine.

00:37:51.790 --> 00:37:54.260
And also a floating action
button, which is also red.

00:37:54.260 --> 00:37:57.270
And when I choose this, you get
this beautiful UI right here.

00:37:57.270 --> 00:37:59.484
You see it before and after.

00:37:59.484 --> 00:38:01.412
[APPLAUSE]

00:38:04.790 --> 00:38:08.440
So we've had the XML
preview mode for awhile,

00:38:08.440 --> 00:38:10.090
whereas you can
mostly work in XML

00:38:10.090 --> 00:38:12.540
and sort of see what's
going on the right.

00:38:12.540 --> 00:38:15.230
And we've expanded that recently
so that you can now use it

00:38:15.230 --> 00:38:17.532
for System Preferences as well.

00:38:17.532 --> 00:38:18.990
So this is a system
preference file

00:38:18.990 --> 00:38:21.330
and it's just rendered the
way the UI is going to look.

00:38:21.330 --> 00:38:22.979
But one important
improvement now

00:38:22.979 --> 00:38:24.770
is that this is no
longer a preview window.

00:38:24.770 --> 00:38:26.310
This is the Layout Editor.

00:38:26.310 --> 00:38:29.730
So I can go over here and
even if-- while editing

00:38:29.730 --> 00:38:32.130
I can, instead, go over
start dragging things around

00:38:32.130 --> 00:38:33.410
and make edits.

00:38:33.410 --> 00:38:36.140
I can even pull in the
pallet right here locally.

00:38:36.140 --> 00:38:39.330
The minute I start dragging
the pallet goes away,

00:38:39.330 --> 00:38:41.760
and I'm editing the layout.

00:38:41.760 --> 00:38:43.870
So that's the Layout Editor.

00:38:43.870 --> 00:38:46.130
And, you know, I'm
not sure exactly when

00:38:46.130 --> 00:38:47.190
it's going to be done.

00:38:47.190 --> 00:38:50.880
But hopefully--
hopefully not too long.

00:38:50.880 --> 00:38:54.400
All right, with that, I'm going
to turn it back over to Jay

00:38:54.400 --> 00:38:55.080
to wrap up.

00:38:55.080 --> 00:38:55.580
Thanks.

00:38:55.580 --> 00:38:57.930
[APPLAUSE]

00:39:02.160 --> 00:39:04.470
JAMAL EASON: So
great-- great demos.

00:39:04.470 --> 00:39:06.360
So what's next?

00:39:06.360 --> 00:39:08.536
I guess before digging
into the specific features,

00:39:08.536 --> 00:39:10.910
I think it might be helpful
to understand how we actually

00:39:10.910 --> 00:39:11.720
developed Android Studio.

00:39:11.720 --> 00:39:13.636
So you've probably seen
these release channels

00:39:13.636 --> 00:39:17.230
and are thinking about what
do these channels even mean?

00:39:17.230 --> 00:39:19.260
For us we have a series
release channels.

00:39:19.260 --> 00:39:21.215
So today we're
launching 1.3 preview

00:39:21.215 --> 00:39:23.730
in Canary, which means it's,
sort of, the first release.

00:39:23.730 --> 00:39:27.480
So then every couple weeks we do
a series of tests and feedback.

00:39:27.480 --> 00:39:29.810
And then we promote those
releases all the way

00:39:29.810 --> 00:39:30.900
through Dev, Beta.

00:39:30.900 --> 00:39:32.610
and to finally the Stable.

00:39:32.610 --> 00:39:35.780
And throughout that process,
we get your feedback.

00:39:35.780 --> 00:39:37.290
So if you want to
see if something

00:39:37.290 --> 00:39:39.120
is broken or something
needs to be fixed,

00:39:39.120 --> 00:39:40.460
we actually look at
the feedback to make

00:39:40.460 --> 00:39:41.970
sure it reaches
the Stable channel

00:39:41.970 --> 00:39:45.850
when we release the final
version of Android Studio.

00:39:45.850 --> 00:39:49.450
So looking forward, today
we did 1.3 and we're

00:39:49.450 --> 00:39:52.190
looking at some 1.4, 1.5
features today at the demo.

00:39:52.190 --> 00:39:53.900
And so if you think
about it, basically,

00:39:53.900 --> 00:39:57.084
most of our odd releases are
or more focused on features.

00:39:57.084 --> 00:39:58.500
And then or even
releases are more

00:39:58.500 --> 00:40:00.895
focused on the polished
aspect of the ID.

00:40:03.890 --> 00:40:06.050
So again, kind of
looking at what's next.

00:40:06.050 --> 00:40:07.540
So Xav talked
about the Emulator.

00:40:07.540 --> 00:40:09.540
So we're definitely-- we
know we have some work to do,

00:40:09.540 --> 00:40:10.740
and we're definitely
going to focus on that

00:40:10.740 --> 00:40:13.156
and making sure it's a great
performing experience for you

00:40:13.156 --> 00:40:16.420
to do to your local testing on.

00:40:16.420 --> 00:40:18.960
As Tor mentioned, we're also
really working on the Developer

00:40:18.960 --> 00:40:20.220
Service Integration.

00:40:20.220 --> 00:40:23.182
Where we're initially adding the
Google services into that flow.

00:40:23.182 --> 00:40:25.390
But we're also opening up
to other third party tools,

00:40:25.390 --> 00:40:27.140
because we know you use
a lot of different tools,

00:40:27.140 --> 00:40:29.765
we want to make it easy for you
to integrate that your project.

00:40:31.679 --> 00:40:33.220
And then last thing
I want to mention

00:40:33.220 --> 00:40:34.490
in my previous slide--
it's about the Polish

00:40:34.490 --> 00:40:35.492
and Performance.

00:40:35.492 --> 00:40:37.700
Really making sure that we
provide a great experience

00:40:37.700 --> 00:40:40.640
for you-- this is a
part of the flow for us

00:40:40.640 --> 00:40:44.140
in the Android Studio team.

00:40:44.140 --> 00:40:44.690
Great.

00:40:44.690 --> 00:40:46.518
And that's it.

00:40:46.518 --> 00:40:49.422
[APPLAUSE]

00:40:54.760 --> 00:40:57.290
So please leave feedback for us.

00:40:57.290 --> 00:41:00.570
We're also having office
hours today from four to five,

00:41:00.570 --> 00:41:01.700
at the end of the day.

00:41:01.700 --> 00:41:02.750
And I think it's
going to be, actually,

00:41:02.750 --> 00:41:03.880
on that side of building.

00:41:03.880 --> 00:41:05.600
And then again, leave
feedback for us in the app

00:41:05.600 --> 00:41:06.480
or on the website.

00:41:06.480 --> 00:41:10.497
So we have, maybe, three or
four minutes for some questions.

00:41:10.497 --> 00:41:13.080
XAVIER DUCROHET: Before we start
questions, we also have today

00:41:13.080 --> 00:41:16.410
and tomorrow some box talks
throughout the Playground.

00:41:16.410 --> 00:41:18.110
There some about testing.

00:41:18.110 --> 00:41:22.290
There's one about the
Profiler-- the Memory Profiler.

00:41:22.290 --> 00:41:23.870
So check the
schdule-- they are--

00:41:23.870 --> 00:41:25.560
usually they're repeated twice.

00:41:25.560 --> 00:41:27.945
So you can check it when
it's convenient for you.

00:41:27.945 --> 00:41:29.320
TOR NORBYE: And
I think they also

00:41:29.320 --> 00:41:31.630
wanted us to say that after
this we will be outside,

00:41:31.630 --> 00:41:33.420
so don't talk to
us by the stage.

00:41:33.420 --> 00:41:36.145
We're supposed to go outside
for a follow up questions.

00:41:36.145 --> 00:41:37.167
All right.

00:41:37.167 --> 00:41:38.250
XAVIER DUCROHET: Question.

00:41:38.250 --> 00:41:39.970
AUDIENCE: So earlier
you mentioned

00:41:39.970 --> 00:41:42.695
automating install of
HEXM Is there any option

00:41:42.695 --> 00:41:46.610
to automate the setting of
the BIOS setting in Windows

00:41:46.610 --> 00:41:48.562
necessary enable that?

00:41:48.562 --> 00:41:50.020
XAVIER DUCROHET:
I think would be--

00:41:50.020 --> 00:41:51.740
JAMAL EASON: So if we
notice in your BIOS

00:41:51.740 --> 00:41:52.760
that you don't have
it set, we actually

00:41:52.760 --> 00:41:55.149
give you a warning about,
hey, you need to update that.

00:41:55.149 --> 00:41:56.940
So 1.3 is actually now
a prompt to tell you

00:41:56.940 --> 00:41:59.200
that you need to, actually,
set that your BIOS.

00:41:59.200 --> 00:42:01.170
AUDIENCE: OK, thanks.

00:42:01.170 --> 00:42:04.391
AUDIENCE: Any
thoughts on Java 1.8?

00:42:04.391 --> 00:42:05.390
XAVIER DUCROHET: Java 8?

00:42:05.390 --> 00:42:06.015
AUDIENCE: Yeah.

00:42:06.015 --> 00:42:07.030
XAVIER DUCROHET: No.

00:42:07.030 --> 00:42:08.890
Java 8--

00:42:08.890 --> 00:42:11.784
TOR NORBYE: Is that
what comes after seven?

00:42:11.784 --> 00:42:13.700
XAVIER DUCROHET: It's a
platform issue, right?

00:42:13.700 --> 00:42:15.660
It's like you have to
talk to the platforms.

00:42:15.660 --> 00:42:16.529
AUDIENCE: OK.

00:42:16.529 --> 00:42:18.320
XAVIER DUCROHET: But
we don't have anything

00:42:18.320 --> 00:42:21.360
to say about that.

00:42:21.360 --> 00:42:24.060
AUDIENCE: Has there been any
changes to the NDK Build Model?

00:42:24.060 --> 00:42:27.460
Are we still relying on
Android.MK and all that stuff?

00:42:27.460 --> 00:42:30.250
XAVIER DUCROHET: So the
integration in Gradle

00:42:30.250 --> 00:42:32.470
will replace the Android.MK.

00:42:32.470 --> 00:42:36.800
Gradle has Native Support
to handle Native code.

00:42:36.800 --> 00:42:39.370
All you have to do is tell
Gradle where the two chain is

00:42:39.370 --> 00:42:42.210
so it will, basically, do
the bridge between the two

00:42:42.210 --> 00:42:43.990
a chain of the NDK are here.

00:42:43.990 --> 00:42:45.900
And then we tell Gradle
use those two chains

00:42:45.900 --> 00:42:46.884
and compile it.

00:42:46.884 --> 00:42:48.300
TOR NORBYE: That's
the main reason

00:42:48.300 --> 00:42:49.950
why we couldn't include
in the first preview-- is

00:42:49.950 --> 00:42:52.190
we were still wanting that
experimental plug-in to be

00:42:52.190 --> 00:42:52.690
hooked up.

00:42:52.690 --> 00:42:57.020
Because we really don't want
to continue that all the way.

00:42:57.020 --> 00:42:59.894
AUDIENCE: You know the
issue with the unit tests

00:42:59.894 --> 00:43:02.060
on the instrumentation
test-- both being on the path

00:43:02.060 --> 00:43:03.090
at the same time?

00:43:03.090 --> 00:43:07.755
You had to switch the flavor
to get them on the path?

00:43:07.755 --> 00:43:08.880
XAVIER DUCROHET: In Studio?

00:43:08.880 --> 00:43:09.440
AUDIENCE: Yeah.

00:43:09.440 --> 00:43:10.830
XAVIER DUCROHET: Yeah
we're working on that.

00:43:10.830 --> 00:43:12.621
AUDIENCE: So-- it's
with a separate module?

00:43:12.621 --> 00:43:14.730
Does that mean they're
both on at the same time

00:43:14.730 --> 00:43:15.320
if you move things
from one module?

00:43:15.320 --> 00:43:16.370
XAVIER DUCROHET: Well you
would-- yeah-- because it's

00:43:16.370 --> 00:43:17.370
just a different module.

00:43:17.370 --> 00:43:21.140
The issue is that Studio does
not have a concept of, like,

00:43:21.140 --> 00:43:23.889
to test cope that are separate.

00:43:23.889 --> 00:43:25.680
So we're working on
figuring something out.

00:43:25.680 --> 00:43:28.130
But if use a test
module, then you

00:43:28.130 --> 00:43:31.950
could unit test in you main
module, and a separate module,

00:43:31.950 --> 00:43:33.097
and that would work.

00:43:33.097 --> 00:43:33.930
AUDIENCE: OK, great.

00:43:33.930 --> 00:43:36.030
XAVIER DUCROHET: All
right, probably-- alright--

00:43:36.030 --> 00:43:36.821
AUDIENCE: One last?

00:43:36.821 --> 00:43:37.860
AUDIENCE: Yeah.

00:43:37.860 --> 00:43:40.360
AUDIENCE: Really excited about
the H profile analysis stuff.

00:43:40.360 --> 00:43:42.030
Is that thing--
the code itself--

00:43:42.030 --> 00:43:45.020
is that going to be open
source, and is the UI code

00:43:45.020 --> 00:43:48.712
separated from the thing
that does the analysis?

00:43:48.712 --> 00:43:50.170
XAVIER DUCROHET:
Yeah, all the UI--

00:43:50.170 --> 00:43:55.110
I mean everything except for
Native-- all stuff in Studio

00:43:55.110 --> 00:43:56.507
is open source, so it in there.

00:43:56.507 --> 00:43:57.340
AUDIENCE: Thank you.

00:43:57.340 --> 00:43:58.840
XAVIER DUCROHET: All
right, thank you everyone.

00:43:58.840 --> 00:44:00.570
We'll be over there, so if
you have more questions,

00:44:00.570 --> 00:44:01.560
we'll answer them.

00:44:01.560 --> 00:44:02.090
Thank you.

00:44:02.090 --> 00:44:03.740
JAMAL EASON: Thank you.

