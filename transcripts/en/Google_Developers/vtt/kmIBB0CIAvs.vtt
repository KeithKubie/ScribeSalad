WEBVTT
Kind: captions
Language: en

00:14:58.499 --> 00:15:03.057
 [ Applause ]
&gt;&gt; Good morning, Krakow.  My

00:15:09.143 --> 00:15:15.371
 name east Michael, I am Irish. 
 I work in the office.  Google 

00:15:15.372 --> 00:15:19.530
is a fun place for engineers to 
work and helped to create 

00:15:19.531 --> 00:15:23.689
products that have a really 
global impact.  But before I get

00:15:23.690 --> 00:15:27.841
 into the talk, I want you to 
think a bit about what end users

00:15:27.842 --> 00:15:34.104
 of Google products think about 
Google.  Probably the first 

00:15:34.105 --> 00:15:38.254
thing thing about is Google's 
search engine.  And then I want 

00:15:38.255 --> 00:15:44.491
you to think about what sort of 
company is Google?  What are we?

00:15:44.492 --> 00:15:46.570
  We're one of the biggest 
companies in the world in terms 

00:15:46.571 --> 00:15:50.728
of revenues and market cap and 
so on.

00:15:50.729 --> 00:15:52.821
But if you think about what sort
 of company we are, we started 

00:15:52.822 --> 00:15:56.954
out as a search company.  But 
now we're much more than a 

00:15:56.955 --> 00:15:59.029
search company.  People in this 
audience probably have a good 

00:15:59.030 --> 00:16:05.268
idea of what we are.  We're a 
company that produces a lot of 

00:16:05.269 --> 00:16:09.412
products.  And all of these 
products are this strange new 

00:16:09.413 --> 00:16:13.565
thing that didn't exist a 
hundred years ago -- software 

00:16:13.566 --> 00:16:17.741
products.  Strangely ephemeral 
based on layers of abstraction 

00:16:17.742 --> 00:16:21.899
that keep changing every five 
years or every two months if 

00:16:21.900 --> 00:16:26.037
you're in JavaScript.
Now, the -- if you think about 

00:16:26.038 --> 00:16:30.186
what it takes to build these 
products, essentially this means

00:16:30.187 --> 00:16:34.348
 that we're a software company. 
 And so we know about software, 

00:16:34.349 --> 00:16:40.590
and we love our own developers 
and we love you, our developer 

00:16:40.591 --> 00:16:48.892
community.  So this means that 
our products are more than just 

00:16:48.893 --> 00:16:50.975
products -- they're things that 
people use to help create real 

00:16:50.976 --> 00:16:55.131
impact globally.  And every one 
of our hundreds of products has 

00:16:55.132 --> 00:16:59.289
potentially billions of success 
stories of people using them to 

00:16:59.290 --> 00:17:05.509
really change their lives.  And 
very importantly, in terms of 

00:17:05.510 --> 00:17:09.644
Google's philosophy, even though
 we started as an American 

00:17:09.645 --> 00:17:13.811
company in Silicon Valley like 
many other software companies, 

00:17:13.812 --> 00:17:15.876
from the get-go, our vision has 
been a global  vision.

00:17:17.962 --> 00:17:20.047
And our vision has been that the
 Internet and the services and 

00:17:20.048 --> 00:17:24.186
products that we provide, are 
for absolutely everyone on the 

00:17:24.187 --> 00:17:30.420
planet.  Not just for English 
speakers.  Not just for North 

00:17:30.421 --> 00:17:34.575
Americans.  Not just for 
Europeans -- but globally.  And 

00:17:34.576 --> 00:17:40.794
we've put a huge amount of 
investment of time and effort 

00:17:40.795 --> 00:17:44.963
and energy into trying to make 
this vision real.  And we 

00:17:44.964 --> 00:17:49.129
certainly have gone a long way 
there.  If you look at the 

00:17:49.130 --> 00:17:53.310
globe, we have users in all 
corners of the globe using all 

00:17:53.311 --> 00:17:57.497
of our products.
Now, I'm going to focus in on 

00:17:57.498 --> 00:17:59.559
what we're doing here in Europe 
in terms of engineering.  

00:17:59.560 --> 00:18:01.635
Because you may think that our 
engineering products are all 

00:18:01.636 --> 00:18:07.836
developed in America.  But, in 
fact, we're a global company and

00:18:07.837 --> 00:18:09.913
 we have a very, very 
significant presence here in 

00:18:09.914 --> 00:18:14.060
Europe.  The dots represent our 
engineering offices, not all of 

00:18:14.061 --> 00:18:20.280
our offices, in  AMEA.  Europe, 
the Middle East and Africa.  

00:18:20.281 --> 00:18:28.574
Includes Zurich, Dublin, Munich,
 Paris, Stockholm and Warsaw and

00:18:30.654 --> 00:18:34.804
 Tel Aviv in Israel.  Famously 
Google has seven products that 

00:18:34.805 --> 00:18:38.957
have more than a billion users 
and some of them with more than 

00:18:38.958 --> 00:18:43.093
2 billion users.  And every one 
of these products has a 

00:18:43.094 --> 00:18:45.182
significant engineering effort 
here in Europe.

00:18:45.183 --> 00:18:49.343
At its simplest, there's two 
main types of engineers in 

00:18:49.344 --> 00:18:57.647
Google.  There are what we call 
"SWEs," software engineers.  And

00:18:57.648 --> 00:19:03.865
 there are what we call"  SREs,"
 site reliability engineers.  

00:19:03.866 --> 00:19:05.936
Because so many of our products 
are hosted Internet services, we

00:19:05.937 --> 00:19:12.122
 need to place just as much 
emphasis on keeping  things up 

00:19:12.123 --> 00:19:16.319
and running, so on and so forth,
 as we go on actually building 

00:19:16.320 --> 00:19:18.320
and developing the

00:19:20.438 --> 00:19:24.607
 software itself.  It takes both
 types of engineers to keep it 

00:19:24.608 --> 00:19:26.683
going.  And the whole slew of 
engineers includes UX and design

00:19:26.684 --> 00:19:32.892
 and all types of security and 
all sorts of things.  But 

00:19:32.893 --> 00:19:37.028
principlely Google thinks of 
these engineers as falling into 

00:19:37.029 --> 00:19:41.181
these two categories.  If you 
think about where some of this 

00:19:41.182 --> 00:19:45.324
activity takes place, just to 
call out three.  Android has a 

00:19:45.325 --> 00:19:53.616
huge base in London.  Chrome has
 a huge base in Paris and 

00:19:53.617 --> 00:19:59.854
London.  And Play has a big base
 in London and in Zurich.  Now, 

00:19:59.855 --> 00:20:01.919
as well as creating products for
 consumers, we also create 

00:20:01.920 --> 00:20:06.121
products for developers.
And there's a number of 

00:20:06.122 --> 00:20:10.289
different types of products that
 we create for developers.  So 

00:20:10.290 --> 00:20:14.424
probably the most obvious one --
 which has a huge presence at 

00:20:14.425 --> 00:20:16.507
this event -- is the Google 
Cloud Platform.  And much of 

00:20:16.508 --> 00:20:22.753
that effort takes place here in 
Poland in Warsaw.  And the next 

00:20:22.754 --> 00:20:26.910
speaker, Ewa, will be giving 
details about what's actually 

00:20:26.911 --> 00:20:33.149
going on there in that office.  
As well as that, we very sort of

00:20:33.150 --> 00:20:37.315
 APIs that can be reused by 
Googles that are part of the 

00:20:37.316 --> 00:20:41.468
platform, but come from a 
separate engineering effort.  In

00:20:41.469 --> 00:20:47.682
 Europe, a lot of that effort is
 focused in Zurich.  After Ewa, 

00:20:47.683 --> 00:20:49.683
we have

00:20:55.818 --> 00:20:59.960
 Behshad talking about it.  And 
you can use AI in your own 

00:20:59.961 --> 00:21:02.031
services.
We have a set of external 

00:21:02.032 --> 00:21:06.179
developer tools that we link to 
the Google Cloud Platform.  And 

00:21:06.180 --> 00:21:08.269
because we need to support them,
 we have a set of internal 

00:21:08.270 --> 00:21:12.406
developer tools.  And a lot of 
that effort goes on in my home 

00:21:12.407 --> 00:21:14.490
office in Munich.  And then we 
have, like any company does, 

00:21:14.491 --> 00:21:18.637
corporate applications that are 
for all users, not just for 

00:21:18.638 --> 00:21:22.779
developers.  And a lot of that 
effort happens in Munich and 

00:21:22.780 --> 00:21:26.946
London.  And why do we do all 
this?  So that you have the 

00:21:26.947 --> 00:21:31.084
tools to build cool products and
 services for your own users.

00:21:33.152 --> 00:21:35.226
Now, as this is mainly a 
developer audience, I just to 

00:21:35.227 --> 00:21:39.429
want give you a bit of a feel 
about the scale that we operate 

00:21:39.430 --> 00:21:45.671
in our own software inside 
Google.  For comparison, let's 

00:21:45.672 --> 00:21:53.983
just look at the Linux 4.2 code 
base.  Roughly 29 million lines 

00:21:53.984 --> 00:22:00.201
of code in 50,000 files.  Quite 
a big code base.  We changed 

00:22:00.202 --> 00:22:06.415
that amount of code in our code 
base in Google every week.  In 

00:22:06.416 --> 00:22:10.572
fact, more than that number of 
files gets changed every week.  

00:22:10.573 --> 00:22:14.721
If you look at the bigger stats,
 internally we have more than  

00:22:14.722 --> 00:22:23.021
40,000 developers working on a 
single integrated monocode base 

00:22:23.022 --> 00:22:27.167
that's made up of a billion 
files and 9 million source files

00:22:27.168 --> 00:22:31.311
 and 2 billion lines of code.  
And we're working furiously at 

00:22:31.312 --> 00:22:35.457
this every day.  And code review
 is a critical part of Google's 

00:22:35.458 --> 00:22:39.606
code culture.  So we have over 
20,000 code reviews happening 

00:22:39.607 --> 00:22:43.759
per workday.  Nobody is allowed 
to check stuff into the master 

00:22:43.760 --> 00:22:45.838
repo without it being reviewed 
on a number of different vectors

00:22:47.917 --> 00:22:49.996
.
And this leads to thousands of 

00:22:49.997 --> 00:22:54.136
commits per  week.  And 
interestingly, over time we've 

00:22:54.137 --> 00:22:58.285
invested so much in our internal
 tooling that there's a much 

00:22:58.286 --> 00:23:02.462
huer growth rate of automated 
changes to our code base than 

00:23:02.463 --> 00:23:06.604
the human-based changes.  But 
also quite interestingly, these 

00:23:06.605 --> 00:23:10.732
automated changes also seem to 
have breaks in the holidays, 

00:23:10.733 --> 00:23:14.888
right?  So the robots take 
holidays too.

00:23:16.962 --> 00:23:21.103
Our tooling is vast.  We've 
invested very, very heavily in 

00:23:21.104 --> 00:23:27.319
it.  And the tooling group they 
work for is called Dev Task 

00:23:27.320 --> 00:23:31.466
Developer Tools and Signals.  
We're in charge of this internal

00:23:31.467 --> 00:23:35.625
 tooling for internal code base 
that we call Google 3.  And 

00:23:35.626 --> 00:23:39.789
there's a set of probably 20 to 
50 tools in these various 

00:23:39.790 --> 00:23:43.949
categories that help build our 
software and keep it currently 

00:23:43.950 --> 00:23:48.105
and keep it regular.  I want to 
call out just one of these tools

00:23:50.193 --> 00:23:54.340
 that we've  externalized as 
open source.  It's a tool called

00:23:56.416 --> 00:24:00.571
  Basel.  It will be interesting
 to you working on large code 

00:24:00.572 --> 00:24:02.662
bases and you want to optimize 
build  times because it allows 

00:24:02.663 --> 00:24:06.832
you to store a graph of all the 
builds that anyone in the 

00:24:06.833 --> 00:24:08.915
company has done.  And if you 
can cache those builds, when the

00:24:08.916 --> 00:24:13.060
 builds are then done again, 
only the stuff that hasn't 

00:24:13.061 --> 00:24:17.214
already been compiled needs to 
be recompiled and you can reuse 

00:24:17.215 --> 00:24:19.299
the binaries from anywhere in 
the  organization.  And we use a

00:24:19.300 --> 00:24:23.440
 version of this had internally 
in Google called

00:24:23.441 --> 00:24:27.585
 "Blaze."  And it's one of the 
core productivity tools that we 

00:24:27.586 --> 00:24:33.790
have.  Now,  Basal is open 
source and not yet version 1.0. 

00:24:33.791 --> 00:24:37.952
 But already being used by 
companies like Dropbox and 

00:24:37.953 --> 00:24:42.158
Stripe.  So especially you're 
working on large code bases, you

00:24:44.230 --> 00:24:46.290
 might be really interested in 
Basal.

00:24:46.291 --> 00:24:52.521
In terms of our philosophy, we 
have a slightly unique way of 

00:24:52.522 --> 00:24:56.642
doing things in Google using our
 single monorepo.  It's our own 

00:24:56.643 --> 00:25:00.803
tool called Piper.  Again, one 
of my teams works on that.  We 

00:25:00.804 --> 00:25:04.953
of the static sitessed off using
 per force and we needed to 

00:25:04.954 --> 00:25:09.090
build our own replacement for it
.  Mandatory code reviews, fast 

00:25:09.091 --> 00:25:11.170
builds from source at head using
  Blaze, ruthless

00:25:15.252 --> 00:25:19.412
 refactoring and identifying 
breaking changes with automated 

00:25:19.413 --> 00:25:21.490
testing.  Maintaining a green 
build and frequent releases.  In

00:25:21.491 --> 00:25:25.630
 fact, anything  running in our 
own internal cloud that's 

00:25:25.631 --> 00:25:29.760
running for more than six months
 without an update is a red flag

00:25:29.761 --> 00:25:31.843
 and people have to revisit it. 
 This is to make sure that we're

00:25:33.931 --> 00:25:36.012
 constantly recompiling all of 
our  services with the latest 

00:25:36.013 --> 00:25:40.154
libraries to make sure we're not
 opening any vulnerabilities.

00:25:40.155 --> 00:25:42.251
If you look at the news today, 
anyone who develops in Java, 

00:25:42.252 --> 00:25:48.464
check out the struts 
vulnerability that was just 

00:25:48.465 --> 00:25:50.543
announced.  It's quite scary.  
You may be recompiling some code

00:25:52.603 --> 00:26:00.912
 tonight.  So to take it all 
back, then, we are trying to 

00:26:00.913 --> 00:26:05.068
invest in software.  We have an 
internal community and we have 

00:26:05.069 --> 00:26:07.142
an external community.  And 
we're trying to take as much 

00:26:07.143 --> 00:26:09.218
knowledge from our internal 
community to share with the 

00:26:09.219 --> 00:26:13.404
external community in terms of 
tools, services and products.

00:26:13.405 --> 00:26:17.530
And now we've realized that we 
need to also invest in 

00:26:17.531 --> 00:26:21.693
communication and events like 
this.  And this event is one 

00:26:21.694 --> 00:26:27.912
example of this, trying to hold 
-- host more events here in 

00:26:27.913 --> 00:26:29.974
Europe where -- as was mentioned
 in the opening keynote on day 

00:26:29.975 --> 00:26:38.268
one -- we know there there are 
more software developers than in

00:26:38.269 --> 00:26:42.431
 North America, U.S. and Canada 
combined.  Last month we had the

00:26:42.432 --> 00:26:48.654
 Polymer Summit in Copenhagen in
 Denmark.  And next month, the 

00:26:48.655 --> 00:26:54.924
Firebase Summit in Amsterdam, 
the Netherlands.  It's cool how 

00:26:54.925 --> 00:26:59.166
you can cook up the Firebase 
with cloud functions from the 

00:26:59.167 --> 00:27:01.235
Google Cloud Platform to create 
a lightweight, serverless, 

00:27:01.236 --> 00:27:05.375
backend to very complex 
applications.  And any who work 

00:27:05.376 --> 00:27:07.448
mobile might be interested in 
that.

00:27:07.449 --> 00:27:11.604
So I'm now going to pass you 
over to someone who will do a 

00:27:11.605 --> 00:27:15.746
deeper dive into the Google 
Cloud Platform and who works 

00:27:15.747 --> 00:27:21.969
here in Europe,Ewa, who works in
 our Warsaw office.  Thank you.

00:27:24.044 --> 00:27:30.264
[ Applause ]
EWA: Thank you.  Hello.  My name

00:27:30.265 --> 00:27:34.416
 is Ewa Macias.  And I'm leading
 Cloud frontend team.  One of 

00:27:34.417 --> 00:27:40.654
the engineering teams we have in
 Poland.  I'm very happy to be 

00:27:40.655 --> 00:27:44.808
here today in Krakow.  I counted
 and I spent about 43% of my 

00:27:44.809 --> 00:27:53.113
entire life in Krakow.  And 88% 
of my adult life.  I was 

00:27:53.114 --> 00:27:59.329
studying here and then spent the
 first eight years at Google 

00:27:59.330 --> 00:28:03.474
here.  It's really good to be 
back.

00:28:03.475 --> 00:28:07.622
And I'm proud that I'm 
representing our Google Poland 

00:28:07.623 --> 00:28:11.760
office here today.  And tell you
 a little bit about what we are 

00:28:11.761 --> 00:28:17.992
focusing on.  Over the last  
decade, Google Poland has 

00:28:17.993 --> 00:28:24.231
focused its efforts on technical
 infrastructure.  We built 

00:28:24.232 --> 00:28:28.399
products and systems that are 
part of the Google Internet  

00:28:28.400 --> 00:28:32.548
Platform.  Google services like 
search and YouTube and Gmail are

00:28:34.614 --> 00:28:38.783
 running.  We build software 
throughout multiple layers.  

00:28:38.784 --> 00:28:42.945
From an agent running on every 
single machine in Google data 

00:28:42.946 --> 00:28:49.172
centers through a  massive data 
collection and process, to web 

00:28:49.173 --> 00:28:53.337
user interface.
A major theme for us over the 

00:28:53.338 --> 00:28:59.600
years has been automation.  And 
improving user interaction with 

00:28:59.601 --> 00:29:03.736
the infrastructure so that the 
internal teams can spend less 

00:29:03.737 --> 00:29:09.962
time doing operations work and 
more time developing actual 

00:29:09.963 --> 00:29:16.238
logic.  Here's one example of 
our automation focus.  We build 

00:29:16.239 --> 00:29:20.383
a system that, for a service, 
automatically chooses a data 

00:29:20.384 --> 00:29:24.548
center to run on based on the 
service requirements.  It also 

00:29:24.549 --> 00:29:32.844
decides how many resources to 
allocate for a  service.  And 

00:29:32.845 --> 00:29:37.002
decides how many copies of the 
service to run.  When we get 

00:29:37.003 --> 00:29:41.156
started here in Poland, over ten
 years ago, the industry was 

00:29:41.157 --> 00:29:47.371
running mostly on private data 
centers.  Maintaining large,  

00:29:47.372 --> 00:29:51.508
specialized servers.  These days
 almost everyone is looking at 

00:29:51.509 --> 00:29:55.690
how to move to Cloud.
Because it's expensive and time-

00:29:57.781 --> 00:29:59.873
consuming to maintain 
infrastructure.  And it also 

00:29:59.874 --> 00:30:04.027
takes you away from your core 
business.  So for the last four 

00:30:04.028 --> 00:30:08.170
years we focused our efforts on 
exposing the Internet 

00:30:08.171 --> 00:30:12.332
infrastructure to our external 
users.  And the resulting 

00:30:12.333 --> 00:30:18.554
product is known today as Google
 Cloud Platform.  Why developers

00:30:20.614 --> 00:30:22.680
 choose cloud?  Because it's 
built on the same infrastructure

00:30:24.751 --> 00:30:30.995
 as all  other services at 
Google.  And it offers security,

00:30:33.092 --> 00:30:37.249
 scale and consistency, access 
to a global network.  Best in 

00:30:37.250 --> 00:30:43.503
class data processing tools.  
Access to services like machine 

00:30:43.504 --> 00:30:49.711
learning and most importantly,  
velocity.  You can see here on 

00:30:49.712 --> 00:30:55.944
the slides some quotes directly 
from our customers.

00:30:55.945 --> 00:31:02.200
I could stand here probably for 
all day telling you about GCP, 

00:31:02.201 --> 00:31:04.281
but since we don't have that 
much time, the rest of my talk 

00:31:04.282 --> 00:31:10.517
will focus on the product known 
as Cloud Compute.  This is what 

00:31:10.518 --> 00:31:12.584
our team in Poland is working on
.  In Cloud Compute, our mission

00:31:14.645 --> 00:31:20.900
 is to help you find a perfect 
engine for your workloads.  From

00:31:20.901 --> 00:31:29.220
 from serverless environments to
 containers to machines, we are 

00:31:29.221 --> 00:31:33.360
working to create a range of 
options to match your needs.  

00:31:33.361 --> 00:31:37.515
Specifically, Cloud Compute 
offers four places where you can

00:31:37.516 --> 00:31:43.752
 run your software.  Compute 
engine, container engine, app 

00:31:43.753 --> 00:31:50.015
engine and cloud functions.
Now, when I look at this slide, 

00:31:50.016 --> 00:31:56.240
maybe Cloud functioning should 
be we named to engine, the slide

00:31:56.241 --> 00:32:00.416
 would look much better then.  
Look at the slide as at a 

00:32:00.417 --> 00:32:04.557
spectrum.   The lower in the 
stack, the more flexibility and 

00:32:04.558 --> 00:32:08.730
control you have.  The higher in
 the stack, the more automation 

00:32:08.731 --> 00:32:14.952
Google provides.  In other words
, in the lower layer, you get 

00:32:14.953 --> 00:32:19.110
almost no infrastructure.  In 
the highest layer, you just 

00:32:19.111 --> 00:32:21.181
bring your code, your business 
logic, and Google will do the 

00:32:21.182 --> 00:32:27.433
rest for you.
I'm going to walk you through 

00:32:27.434 --> 00:32:29.502
the four  platforms to give you 
an understanding of what they 

00:32:29.503 --> 00:32:33.667
are and how you might want to 
use them.  And I will also point

00:32:33.668 --> 00:32:37.800
 out some specific things that 
we are working on here in 

00:32:37.801 --> 00:32:46.101
Poland.  So let's start from the
 bottom.  Compute Engine.  

00:32:46.102 --> 00:32:52.306
Compute Engine offers virtual 
machines.  Think of virtual 

00:32:52.307 --> 00:32:56.450
machines as your personal 
computer.  Only that it's not on

00:32:56.451 --> 00:33:00.613
 your desk but that it's remote.
  It's in a Google data center 

00:33:00.614 --> 00:33:02.614
and you can access it remotely

00:33:04.697 --> 00:33:08.877
.  So let me now show you how to
 get a server on GC in a few 

00:33:08.878 --> 00:33:15.107
seconds.
I will do a live demo, so 

00:33:15.108 --> 00:33:17.178
fingers crossed.

00:33:25.286 --> 00:33:29.427
  So this is Cloud Console.  
It's a web interface where you 

00:33:29.428 --> 00:33:35.691
can create and manage your GCP 
resources.  It's a really good 

00:33:35.692 --> 00:33:39.850
place to start exploring the 
platform.  See here I've got 

00:33:39.851 --> 00:33:43.996
four platforms I'm presenting 
today.  But you can get access 

00:33:43.997 --> 00:33:48.142
to many more like storage and 
networking and machine learning 

00:33:48.143 --> 00:33:52.297
-- everything.  So let's go to 
the Compute Engine.  And create 

00:33:52.298 --> 00:33:58.554
an instance.  When you -- when 
you create an instance you can 

00:33:58.555 --> 00:34:04.787
decide how big it is.  You can 
get anything from one core to 64

00:34:04.788 --> 00:34:11.005
 cores.  And you can get up to 
416 gigabytes of memory.  We 

00:34:11.006 --> 00:34:15.155
have a wide range of pre-cooked 
images.  Linux distributions and

00:34:15.156 --> 00:34:21.357
 Windows Server.  You can also 
bring your own image.

00:34:21.358 --> 00:34:25.524
If you want this instance to run
 with traffic, you will probably

00:34:25.525 --> 00:34:31.729
 enable HTTP/HTTPS.  By default,
 all are protected by firewalls 

00:34:31.730 --> 00:34:33.803
from the traffic from the 
Internet.  Before I go ahead and

00:34:35.880 --> 00:34:40.032
 create this VM I want to show 
you one cool thing.  Many users,

00:34:40.033 --> 00:34:44.183
 when they get more familiar 
with GCP, they tend to prefer 

00:34:44.184 --> 00:34:48.330
command line over the UI.  And 
it's natural process.  But this 

00:34:48.331 --> 00:34:52.488
web UI  is a very good way to 
learn command line tool and 

00:34:52.489 --> 00:34:56.627
transition to command line 
later.  For almost everything 

00:34:56.628 --> 00:35:02.848
that you can do in this UI, you 
can get in the valid command 

00:35:02.849 --> 00:35:04.921
line.  This is the command line 
for the VM.  And the cool thing 

00:35:04.922 --> 00:35:11.183
is that you can run it directly 
from the browser.  Whoops.

00:35:11.184 --> 00:35:15.357
So we don't have to restart the 
Cloud or configure anything on 

00:35:15.358 --> 00:35:19.518
your computer.  All you need is 
the browser.  So let's go ahead 

00:35:19.519 --> 00:35:23.693
and create a VM.  Putting the VM
 and programming the network 

00:35:23.694 --> 00:35:27.865
takes like 20, 30 seconds.  And 
so there's one more cool thing I

00:35:27.866 --> 00:35:32.010
 want to show.  So when you have
 the server up and running, you 

00:35:32.011 --> 00:35:36.188
want to SSH to it and you want 
to -- and you can start 

00:35:36.189 --> 00:35:40.350
installing basically any 
software you like on the server.

00:35:40.351 --> 00:35:48.673
  And you can also  SSH directly
 from the UI.  Okay.

00:35:50.751 --> 00:35:52.814
It will take a couple of 
seconds.  Maybe I will be 

00:35:52.815 --> 00:35:56.971
waiting for that.  Okay.  Black 
screen.  I don't know what 

00:35:56.972 --> 00:36:01.114
happened.  Okay.  Okay.  Let's 
go -- okay.  We are in the -- 

00:36:01.115 --> 00:36:05.260
inside of the VM and you can, 
you know, start browsing as a 

00:36:05.261 --> 00:36:07.336
normal virtual machine.  I 
really also wanted to do this 

00:36:07.337 --> 00:36:15.659
demo, because the frontend for 
Cloud Compute is being built in 

00:36:15.660 --> 00:36:17.740
Warsaw.
[ Applause ]

00:36:23.807 --> 00:36:27.970
 one thing that I would like to 
point out is that sometimes it 

00:36:27.971 --> 00:36:30.043
can be hard to decide up front 
what is the right size of the 

00:36:30.044 --> 00:36:36.309
machine for your service.  To 
help with that, GCP will observe

00:36:36.310 --> 00:36:40.475
 the load of the VM and the 
traffic and will recommend you 

00:36:40.476 --> 00:36:42.553
the best size.  Either decrease 
it to save you money, or 

00:36:42.554 --> 00:36:48.776
increase it for a better 
performance.  This 

00:36:48.777 --> 00:36:52.919
recommendation engine is being 
built in Poland as well.

00:36:52.920 --> 00:36:54.920
[ Applause ]

00:36:58.996 --> 00:37:03.130
Together with the V Ms and 
access to a global network, you 

00:37:03.131 --> 00:37:09.340
also get a set of tools that 
help you manage the service.  

00:37:09.341 --> 00:37:15.580
One of them is auto-scaling 
groups of instances.  You can 

00:37:15.581 --> 00:37:17.648
configure it so it always keeps 
a certain amount of instances up

00:37:17.649 --> 00:37:23.874
 and running.  The system does 
it by observing the health and 

00:37:23.875 --> 00:37:30.099
re-creating the VM if they go 
unhealthy.  You can also attach 

00:37:30.100 --> 00:37:37.158
an auto-scaler that will observe
 the CPU load and add or remove 

00:37:37.159 --> 00:37:43.953
the servers based on your metric
 or on the traffic on the CPU 

00:37:43.954 --> 00:37:48.111
load.  So you still have full 
control offer what is running on

00:37:48.112 --> 00:37:52.272
 the VM, but you apply an 
automation that helps you run 

00:37:52.273 --> 00:38:00.582
the service in a cost-efficient 
and reliable way.  And 

00:38:00.583 --> 00:38:06.820
auto-scaler and many other tools
 that help you manage GCP are 

00:38:06.821 --> 00:38:08.904
also being built in Poland.
[ Applause ]

00:38:12.985 --> 00:38:19.219
All right.  Let's go one little 
up to Container  Engine.  

00:38:19.220 --> 00:38:23.356
Container Engine is our hosted 
Kubernetes environment.  And you

00:38:23.357 --> 00:38:27.516
 might guess from its name, it's
 a platform running a large 

00:38:27.517 --> 00:38:31.675
number of  containers.  It 
handles a lot of infrastructure 

00:38:31.676 --> 00:38:35.814
for you like virtual machines 
and networking.  And by using 

00:38:35.815 --> 00:38:39.966
the open source Kubernetes, it 
also manages the containers for 

00:38:39.967 --> 00:38:46.213
you automatically.  What are 
containers?  I like thinking 

00:38:46.214 --> 00:38:50.364
about containers as a lighter 
version of virtual machines.  

00:38:50.365 --> 00:38:54.503
They're software packaging units
 that only take your code and 

00:38:54.504 --> 00:38:56.569
libraries and make them 
independent from the operating 

00:38:56.570 --> 00:39:02.787
system so that you can run 
multiple containers on one VM in

00:39:02.788 --> 00:39:06.965
 isolation.
Unlike virtual machines, they do

00:39:06.966 --> 00:39:13.197
 not contain operating systems. 
 So they are much smaller in 

00:39:13.198 --> 00:39:19.438
bytes and they start much 
faster.  What are Kubernetes?  

00:39:19.439 --> 00:39:23.597
Usually put just one thing into 
a container, like web server or 

00:39:23.598 --> 00:39:27.792
database, for example.  So when 
you want to start building a 

00:39:27.793 --> 00:39:29.851
system out of your containers, 
you usually end up having a lot 

00:39:29.852 --> 00:39:34.007
of them.  And maintaining a lot 
of containers can be 

00:39:34.008 --> 00:39:38.144
challenging.  So let me give you
 one example.  Let's say I want 

00:39:38.145 --> 00:39:44.392
to have a three layers data 
application.  Database, backend 

00:39:44.393 --> 00:39:48.536
and frontend.  So I package them
 into three containers.  For 

00:39:48.537 --> 00:39:52.673
redundancy, I want to have a 
couple of instances of each.  I 

00:39:52.674 --> 00:39:56.814
want to have a frontend 
accessible by a static IP 

00:39:56.815 --> 00:40:03.030
address.  And two layers.  And 
even with this simple service, 

00:40:03.031 --> 00:40:07.168
it can be challenging to 
maintain.  So here's where 

00:40:07.169 --> 00:40:11.317
Kubernetes comes in.
They will start that app for you

00:40:11.318 --> 00:40:19.620
 and make sure it stays up and 
running.  Some of you may have 

00:40:19.621 --> 00:40:25.838
heard or played the game, 
Pokemon Go!  This slide will 

00:40:25.839 --> 00:40:29.991
show how fast the game was 
growing in the first days of its

00:40:29.992 --> 00:40:36.238
 popularity.  So this line shows
 the estimated traffic.  The 

00:40:36.239 --> 00:40:42.477
green line is the disaster 
scenario.  And the blue line is 

00:40:42.478 --> 00:40:46.639
the real traffic.  So it was the
 huge success of the game, and 

00:40:46.640 --> 00:40:52.982
it was also a huge success of 
the Google Container Engine 

00:40:52.983 --> 00:40:57.164
because the platform actually 
managed to scale for the game.  

00:40:57.165 --> 00:41:01.322
And I'm very proud to say that 
Google Poland is contributing to

00:41:01.323 --> 00:41:09.646
 both Kubernetes and GKE, and 
specifically they are working on

00:41:09.647 --> 00:41:13.806
 the platform.
Now let's go another layer up

00:41:17.893 --> 00:41:22.051
 to App Engine.  It's optimized 
to run your web code extremely 

00:41:22.052 --> 00:41:28.289
well.  The motto of App Engine 
is: bring your code, and we'll 

00:41:28.290 --> 00:41:32.439
do the rest for you.  So you 
don't have to think about 

00:41:32.440 --> 00:41:36.598
operating system or virtual 
machines or any other piece of 

00:41:36.599 --> 00:41:38.679
infrastructure when you use App 
Engine.  This is called 

00:41:38.680 --> 00:41:42.819
serverless environment.  It 
doesn't mean that the server 

00:41:42.820 --> 00:41:46.976
doesn't exist.  It only means 
that from the perspective of a 

00:41:46.977 --> 00:41:53.216
developer, the server is 
invisible.  All you see when you

00:41:53.217 --> 00:41:59.438
 implement and manage and deploy
 your app are application-level 

00:41:59.439 --> 00:42:01.509
tracks.
App Engine also

00:42:05.585 --> 00:42:09.727
 offers a set of tools crafted 
for web productions like traffic

00:42:09.728 --> 00:42:15.963
 splitting, security scanner, an
 incredibly rapid scaling.  The 

00:42:15.964 --> 00:42:22.214
last piece of our spectrum is 
Cloud Functions.  It also is a 

00:42:22.215 --> 00:42:24.290
serverless environment, but from
 the perspective of a developer,

00:42:24.291 --> 00:42:30.502
 it's even simpler than App 
Engine.  And it can be seen as a

00:42:30.503 --> 00:42:32.566
 glue that enables you to very

00:42:36.644 --> 00:42:44.960
 easily use many Google services
 like vision API or listen for 

00:42:44.961 --> 00:42:51.204
changes in the database.  With 
Cloud Functions you can almost 

00:42:51.205 --> 00:42:55.343
forget about the conflict of an 
application.  All you see or all

00:42:55.344 --> 00:42:59.469
 you think about when you use 
Cloud Functions is your code, 

00:42:59.470 --> 00:43:03.625
your function.  And then event 
on which the functions should be

00:43:03.626 --> 00:43:11.990
 executed.  So let me show you 
how you do it.  A classical 

00:43:11.991 --> 00:43:18.214
example is sending an email to a
 user when they upload an image 

00:43:18.215 --> 00:43:20.276
to a database.

00:43:24.363 --> 00:43:26.363
All right.

00:43:30.446 --> 00:43:38.741
  So let's go to Cloud 
Functions.  I will create a 

00:43:38.742 --> 00:43:42.901
function, upload an image to a 
storage and observe that the 

00:43:42.902 --> 00:43:51.190
function was executed.  So I 
choose a trigger.  Cloud storage

00:43:51.191 --> 00:43:53.270
 bucket.  I specify the bucket 
that will be observed for 

00:43:53.271 --> 00:43:57.414
changes.  And here is my code.  
I will not be sending -- 

00:43:57.415 --> 00:44:01.615
emailing this demo.  We don't 
have that much time.  I will 

00:44:01.616 --> 00:44:03.706
just pretend.

00:44:07.796 --> 00:44:11.951
  And one small detail.  And 
just specify a bucket where my 

00:44:11.952 --> 00:44:16.103
source code would be  stored.  
And create.

00:44:22.188 --> 00:44:28.424
  Now I will go to the  storage 
-- let's see the trigger -- 

00:44:28.425 --> 00:44:34.649
let's go so that we are in the 
storage UI.  And I'm loading a 

00:44:34.650 --> 00:44:38.784
file.  Let's say a dog image.

00:44:44.864 --> 00:44:46.935
  Please upload.

00:44:51.026 --> 00:44:57.245
  Okay.  It doesn't want to 
upload the file.  Woohoo.  Oh!  

00:44:57.246 --> 00:45:01.417
Woohoo!  Yes.  The file is 
there.

00:45:01.418 --> 00:45:09.757
[ Applause ]
Success.  So now let's go and 

00:45:09.758 --> 00:45:18.084
see whether the function was 
executed.  And I go to logs.  

00:45:18.085 --> 00:45:20.152
Since we are in the source code,
 we are logging the fact that 

00:45:20.153 --> 00:45:26.386
the function has been executed. 
 And -- all right.  The log is 

00:45:26.387 --> 00:45:30.529
not there.  Not there yet.  All 
right.  We have something.  Do 

00:45:30.530 --> 00:45:38.839
we have a dog?  We have a  dog. 
 And we have a cat.  Okay.  So 

00:45:38.840 --> 00:45:43.001
let's go back to the 
presentation.  So you see?  That

00:45:43.002 --> 00:45:45.075
 was easy.  That was like, a 
couple of clicks and lines of 

00:45:45.076 --> 00:45:53.385
code.  And all the glue between 
your code and the storage, in 

00:45:53.386 --> 00:45:57.558
particular, listening to the 
changes, and making sure that 

00:45:57.559 --> 00:46:01.711
your function is really getting 
executed at least once.  Alled 

00:46:01.712 --> 00:46:07.949
that handled for you by the 
platform.  As some of you may 

00:46:07.950 --> 00:46:12.086
have heard yesterday, Cloud 
Functions also can be used with 

00:46:12.087 --> 00:46:16.240
Firebase and it's a very 
powerful way for the mobile 

00:46:16.241 --> 00:46:20.380
developers to build a server 
side extension without having to

00:46:20.381 --> 00:46:26.625
 learn or manage or understand 
any of the -- or deal with any 

00:46:26.626 --> 00:46:32.862
servers.  And Cloud Functions 
are 100% designed and bullet

00:46:32.863 --> 00:46:39.106
in Warsaw.
[ Applause ]

00:46:41.189 --> 00:46:47.416
All right.  So a quick recap of 
the presentation.  When you use 

00:46:49.498 --> 00:46:53.651
Compute Engine, you think about 
people and machines operating 

00:46:53.652 --> 00:46:57.837
and a network.  Basically, 
virtual infrastructure.  

00:46:57.838 --> 00:46:59.916
Containers take you from the 
world of virtual machines to 

00:46:59.917 --> 00:47:04.056
microservices, containers and 
application.  When you use App 

00:47:06.149 --> 00:47:08.234
Engine, you choose to abstract 
away from the infrastructure.  

00:47:08.235 --> 00:47:14.474
And all you see or hear about is
 application and HTTP requests. 

00:47:14.475 --> 00:47:18.610
 And, finally, when you use 
Cloud Functions, you saw that it

00:47:18.611 --> 00:47:22.780
 operates on a piece of code -- 
your function

00:47:26.883 --> 00:47:28.959
 function -- and that's it.
Now that I've highlighted the 

00:47:28.960 --> 00:47:33.129
differences between the four 
platforms, you might be asking 

00:47:33.130 --> 00:47:37.280
yourself.  So which one should I
 be using?  My recommendation is

00:47:37.281 --> 00:47:41.413
 that you go from the top.  
Check whether the platforms work

00:47:41.414 --> 00:47:45.564
 for you and whether it's not 
constraining you too much.  And 

00:47:45.565 --> 00:47:49.694
if it's not, just take it.  If 
it is constraining you too much,

00:47:49.695 --> 00:47:51.804
 it means that you need more 
flexibility and control, so go 

00:47:51.805 --> 00:48:00.111
one level down.
Google Cloud Platform has really

00:48:00.112 --> 00:48:04.280
 a lot to  offer, and we are 
very excited about its future.  

00:48:04.281 --> 00:48:06.370
So if you are interested in 
learning more about it, I 

00:48:06.371 --> 00:48:14.662
encourage you to go to the Cloud
 Console or to  Cloud.google.com

00:48:14.663 --> 00:48:16.663
 and start exploring.

00:48:18.752 --> 00:48:22.913
 I also will be around here 
today if you want to ask me any 

00:48:22.914 --> 00:48:31.218
 questions.  So now I would like
 to introduce my colleague, 

00:48:31.219 --> 00:48:35.392
Behshad Behzadi from the Zurich 
office.  He's a senior 

00:48:35.393 --> 00:48:39.544
engineering director and he's 
leading a team of over 100 

00:48:39.545 --> 00:48:47.859
engineers building Google 
Assistant., Behshad

00:48:49.930 --> 00:48:54.076
, on stage.
[ Applause ]

00:48:54.077 --> 00:48:58.236
BEHSHAD: Hello, everybody.  My 
name is Behshad and I work on 

00:48:58.237 --> 00:49:04.464
the Google Assistant team in the
 Zurich office.  Yesterday Tilke

00:49:04.465 --> 00:49:08.641
 talked about the different ways
 that you can bring Google 

00:49:08.642 --> 00:49:12.786
Assistant into your own 
applications through the actions

00:49:12.787 --> 00:49:14.851
 in Google Platform.  Today I 
want to talk about what we in 

00:49:14.852 --> 00:49:19.005
Google are doing to improve the 
Google Assistant across devices.

00:49:19.006 --> 00:49:25.190
So in Google I/O, Sundar sent 
this key message, which is the 

00:49:25.191 --> 00:49:29.364
next ten years is going to be an
  AI-first world.  I'm 

00:49:29.365 --> 00:49:31.433
personally very excited about 
that because I consider Google 

00:49:31.434 --> 00:49:35.589
Assistant and  building an 
Assistant is actually one of the

00:49:35.590 --> 00:49:39.752
 core implementations of such an
 AI world.  So in some  ways we 

00:49:39.753 --> 00:49:43.887
feel that we are part of 
building this next revolution.  

00:49:43.888 --> 00:49:50.123
But before going and talking 
more about the Google Assistant 

00:49:50.124 --> 00:49:52.191
itself, I want to talk about a 
little bit about this AI 

00:49:52.192 --> 00:49:56.343
revolution.  The AI revolution 
is in some ways similar to some 

00:49:56.344 --> 00:50:00.485
of the bigger revolutions in the
 past hundred years.  These were

00:50:00.486 --> 00:50:04.676
 revolutions where they changed 
the lives of lots of people.  

00:50:04.677 --> 00:50:08.824
They made lots of companies 
disappear, lots of new companies

00:50:08.825 --> 00:50:12.998
 appear, and saving lots of time
 for people.  If you think about

00:50:12.999 --> 00:50:17.141
 phone, car, plane and 
transistor.  They were 

00:50:17.142 --> 00:50:21.290
considered a plague.  Going from
 the U.S. to Europe, you needed 

00:50:21.291 --> 00:50:27.498
a month on a ship, and only some
 people could do that.  Today, 

00:50:27.499 --> 00:50:31.662
less than a day, ten hours.
That's about saving time.  Life 

00:50:31.663 --> 00:50:35.816
of people is changing.
Now, if we move fast forward to 

00:50:35.817 --> 00:50:39.956
newer types of revolutions which
 happened around 20 years ago, 

00:50:39.957 --> 00:50:44.099
the PC and Internet.  So all of 
a sudden at home you get 

00:50:44.100 --> 00:50:46.170
connected to the information.  
So we didn't need to go to the 

00:50:46.171 --> 00:50:52.413
library if you wanted to find 
how tall is the Empire State 

00:50:52.414 --> 00:50:56.567
Building.  If you think, 20 
years ago, that was the only way

00:50:56.568 --> 00:50:58.651
 to find the answers to such 
questions.  This is a big 

00:50:58.652 --> 00:51:02.825
change, again, into people's 
lives.  You don't need to go to 

00:51:02.826 --> 00:51:06.971
a bank to check what is your 
bank account.  You can buy 

00:51:06.972 --> 00:51:09.055
things from home and don't need 
to wait for the next news on TV 

00:51:09.056 --> 00:51:13.204
to know what the weather is 
going to be tomorrow.  You can 

00:51:13.205 --> 00:51:17.350
just ask it.  But the next 
revolution happened soon after, 

00:51:17.351 --> 00:51:19.430
less than ten years, and that's 
the mobile revolution, which was

00:51:19.431 --> 00:51:23.589
 even bigger than the previous 
one.  The huge PC which was in 

00:51:23.590 --> 00:51:27.796
the corner of your home before 
now is replaced by these mobile 

00:51:27.797 --> 00:51:29.875
phones, which is smaller and in 
your pocket and you can bring it

00:51:29.876 --> 00:51:31.943
 everywhere.  It's actually, in 
some ways, more powerful. 

00:51:31.944 --> 00:51:36.107
It has a camera, it has a 
microphone and it's more 

00:51:36.108 --> 00:51:38.194
personal.  You can take 
pictures, share, communicate and

00:51:38.195 --> 00:51:42.348
 more.
Mobile made our thinking at 

00:51:42.349 --> 00:51:48.606
Google about productive.  We 
became a mobile-first company 

00:51:48.607 --> 00:51:50.673
from those moments.  However, 
the mobile revolution is still 

00:51:50.674 --> 00:51:56.920
ongoing and we kind of predict 
that by 2020 there is going to 

00:51:56.921 --> 00:52:01.079
be 5 billion mobile users on 
this planet, which means that 

00:52:01.080 --> 00:52:03.157
really the scale is bigger than 
the PC and

00:52:07.252 --> 00:52:09.334
 Internet revolution that was 
happening before.  This is 

00:52:09.335 --> 00:52:13.515
because the cost in an emerging 
market is much easier.  This 

00:52:13.516 --> 00:52:15.608
revolution is ongoing, but the 
next revolution is happening now

00:52:15.609 --> 00:52:19.751
 and bringing this revolution to
 the next level.  This is the AI

00:52:19.752 --> 00:52:23.911
 revolution.  This is where, in 
the example of mobiles, we are 

00:52:23.912 --> 00:52:30.117
trying to make interactions with
 mobiles conversational, much 

00:52:30.118 --> 00:52:34.247
natural.  Make the smartphones 
smart and make them to 

00:52:34.248 --> 00:52:36.322
understand intents and 
understand context and answer 

00:52:36.323 --> 00:52:38.407
things based on what they hear 
and what they see.

00:52:38.408 --> 00:52:44.625
When we have these 
conversational types of 

00:52:44.626 --> 00:52:48.781
experiences through -- slide is 
not changing -- through the -- 

00:52:48.782 --> 00:52:55.007
when we have these experiences 
through the -- through a 

00:52:55.008 --> 00:52:59.137
conversation with mobiles, we 
can expand to other devices.  If

00:52:59.138 --> 00:53:03.259
 you have a car, your watch at 
home, you can use the same 

00:53:03.260 --> 00:53:05.333
conversational experience and 
try to add that intelligence in 

00:53:05.334 --> 00:53:09.486
a very consistent way through 
all your devices at -- in 

00:53:09.487 --> 00:53:13.612
different places.  And now  the 
-- I repeatedly say 

00:53:13.613 --> 00:53:17.780
conversation, conversation, and 
this is really the core of what 

00:53:17.781 --> 00:53:21.921
we think about Google Assistant.
  Because we kind of think a 

00:53:21.922 --> 00:53:26.063
conversation is the most-used 
interface human beings have.  

00:53:26.064 --> 00:53:30.217
The most interface that human 
beings have  used.  We know how 

00:53:30.218 --> 00:53:34.370
to talk from a kid to when we 
are old.  But from different 

00:53:34.371 --> 00:53:38.514
race, different ages.  People 
know how to interact with each 

00:53:38.515 --> 00:53:42.670
other through talking.  So if we
 solved that problem of 

00:53:42.671 --> 00:53:44.756
conversational understanding, we
 have solved a big problem and 

00:53:44.757 --> 00:53:48.940
can expand that in many use 
cases.  The best would

00:53:48.941 --> 00:53:51.028
be -- I want to show you Google 
 Assistant.  And I would like to

00:53:51.029 --> 00:53:55.174
 invite the cameraman to come 
and I will go to my live demos, 

00:53:55.175 --> 00:53:59.320
which is going to be quite risky
 for me.  They're all live demos

00:53:59.321 --> 00:54:05.535
 and you will have fun seeing me
 being scared, I guess.

00:54:05.536 --> 00:54:07.536
So

00:54:09.627 --> 00:54:11.701
 here I'm own my phone.  I'm 
going to show you lots of demos 

00:54:11.702 --> 00:54:17.947
of showing where we are.  Where 
in Google we are, and different 

00:54:17.948 --> 00:54:24.166
aspects of what the Assistant is
 doing.  So the first thing I 

00:54:24.167 --> 00:54:28.329
would show is about how Google 
Assistant is answering thing

00:54:32.430 --> 00:54:38.656
s.  Let's start with, hi, 
Google, how are you doing?

00:54:38.657 --> 00:54:44.887
&gt;&gt; I'm doing great.  Thanks for 
asking.  Anything I can help you

00:54:44.888 --> 00:54:46.980
 with?
&gt;&gt; Can you please tell me how is

00:54:46.981 --> 00:54:53.182
 the weather going to be 
tomorrow in Krakow?  Always -- 

00:54:53.183 --> 00:54:57.332
it's --
[ Applause ]

00:54:57.333 --> 00:55:01.509
I don't think it uploaded to 
work.  Can you please tell me 

00:55:01.510 --> 00:55:05.665
how is the weather going to be 
tomorrow in Krakow.

00:55:05.666 --> 00:55:09.800
&gt;&gt; Partly cloudy.
[ Applause ]

00:55:13.883 --> 00:55:18.044
BEHSHAD: So as -- this is a 
rather more language, the longer

00:55:18.045 --> 00:55:20.107
 types of questions.  As opposed
 to when you type on a machine, 

00:55:20.108 --> 00:55:26.353
you say, weather, Krakow, 
tomorrow.  Here I use a long 

00:55:26.354 --> 00:55:28.425
sentence in a conversation way. 
 We're trying to understand -- 

00:55:28.426 --> 00:55:32.591
there's machine learning behind 
which understands that sentence 

00:55:32.592 --> 00:55:36.733
is the same thing that's weather
 in Krakow tomorrow.  So let's 

00:55:36.734 --> 00:55:42.943
do more questions.  Show me 
tourist attractions in Krakow.

00:55:42.944 --> 00:55:49.194
&gt;&gt; Awe tractions --
BEHSHAD: Okay.  So this is a 

00:55:49.195 --> 00:55:53.359
more popular question about 
weather or attractions.  But now

00:55:53.360 --> 00:55:57.512
 I want to show you how we 
actually try to expand the 

00:55:57.513 --> 00:56:01.667
answering capabilities to really
 more specific and long type of 

00:56:01.668 --> 00:56:03.765
questions.  For example, show me
 a list of rides

00:56:07.860 --> 00:56:16.167
 in Europa Park.
&gt;&gt; Silver star, others.

00:56:16.168 --> 00:56:18.239
BEHSHAD: We know about the rides
 in an attraction park.  I'm 

00:56:18.240 --> 00:56:22.385
going to ask questions about one
 particular ride there.  What is

00:56:22.386 --> 00:56:26.543
 the height restriction for Blue
 Fire?

00:56:26.544 --> 00:56:34.866
&gt;&gt; You must be at least one 
meter tall to ride.

00:56:34.867 --> 00:56:39.019
BEHSHAD: Thanks.  So what I'm 
try to show here is the range of

00:56:41.088 --> 00:56:45.234
 examples that we get.  But we 
really are trying to expand to a

00:56:45.235 --> 00:56:47.291
 long -- wide range of questions
.  And that's what you expect 

00:56:47.292 --> 00:56:51.433
from an automated Assistant.  
Now, the next example I'm  

00:56:51.434 --> 00:56:55.587
showing you, and actually across
 my demos, it's a mixture of 

00:56:55.588 --> 00:56:57.669
things which is live and 
launched, and some of the things

00:56:57.670 --> 00:56:59.748
 which is not yet launched but 
are like internal prototypes 

00:56:59.749 --> 00:57:03.903
that we have.  And they're going
 to launch either in the next 

00:57:03.904 --> 00:57:08.036
few months -- and in some cases,
 next year.  So the next one is 

00:57:08.037 --> 00:57:12.198
one of them which we are trying 
to handle more complex natural 

00:57:12.199 --> 00:57:16.365
language understanding.
What is the name of the movie 

00:57:16.366 --> 00:57:20.546
where Tom Cruise acts in it and 
he plays pool and while he plays

00:57:20.547 --> 00:57:28.840
  pool, he dances?
&gt;&gt; Here is the info.  Color of 

00:57:30.924 --> 00:57:32.924
Money --

00:57:35.024 --> 00:57:37.024
[ Applause ]
BEHSHAD: 

00:57:39.121 --> 00:57:41.210
So this is possible through 
merging like the power of search

00:57:43.292 --> 00:57:47.433
.  The signal is coming from 
Google Search, with mission 

00:57:47.434 --> 00:57:49.498
learning.  It's a combined 
system that's capable of doing 

00:57:49.499 --> 00:57:55.733
these  things.  We consider a 
task for example.  So now let me

00:57:57.806 --> 00:58:01.954
 show you how this voice 
interface could be used for 

00:58:01.955 --> 00:58:06.101
connecting to other services 
from first-party Google or some 

00:58:06.102 --> 00:58:10.271
type of other outside Google.
So first I will show an example 

00:58:10.272 --> 00:58:14.427
of how the integration would 
translate and look like in this 

00:58:14.428 --> 00:58:22.752
Assistant world.  Be my 
Vietnamese translator.

00:58:22.753 --> 00:58:26.907
&gt;&gt; Understood.  I will translate
 all of the following messages 

00:58:26.908 --> 00:58:31.052
to Vietnamese.  To stop, just  
say, stop translation.

00:58:31.053 --> 00:58:35.205
BEHSHAD: Hey, I have a problem. 
 Can you help me?

00:58:35.206 --> 00:58:39.368
&gt;&gt; [speaking in Vietnamese]
BEHSHAD: I lost my luggage in 

00:58:39.369 --> 00:58:45.600
the train.
&gt;&gt; [Speaking in Vietnamese]

00:58:45.601 --> 00:58:51.803
BEHSHAD: Stop translation.
&gt;&gt; Okay!

00:58:51.804 --> 00:58:53.804
[ Applause ]

00:58:55.881 --> 00:59:00.040
BEHSHAD: So you can use this 
natural language and talking and

00:59:00.041 --> 00:59:02.125
 get connected to these services
 and applications.  Now, I show 

00:59:02.126 --> 00:59:08.354
another example, this time with 
the street view again to show a 

00:59:08.355 --> 00:59:10.450
combination of voice input and 
the natural language 

00:59:10.451 --> 00:59:12.525
understanding connected to this 
service.  In this case I would 

00:59:12.526 --> 00:59:18.757
say something like, I would like
 to be on the top of the Eiffel 

00:59:18.758 --> 00:59:22.931
Tower now, can you please bring 
me there.

00:59:22.932 --> 00:59:25.011
&gt;&gt; Okay.
BEHSHAD: We call this project 

00:59:25.012 --> 00:59:33.303
internally  "Teleport."  It's --
[ Applause ]

00:59:35.368 --> 00:59:39.526
I think that's as good as we can
 do for a teleport.  So now I 

00:59:39.527 --> 00:59:41.598
want to show you how this could 
be, for example, with integrated

00:59:43.679 --> 00:59:49.924
 with a service which is not 
developed at Google.  Talk to 

00:59:52.023 --> 00:59:58.278
WebMD.
&gt;&gt; Sure.  Getting webML.  

00:59:58.279 --> 01:00:02.413
Welcome to WebMD.  I can tell 
you about health conditions, 

01:00:02.414 --> 01:00:06.566
drugs and even side effects.  
What would you like to know?

01:00:06.567 --> 01:00:10.715
BEHSHAD: What are the side 
effects of Aspirin?

01:00:10.716 --> 01:00:14.877
&gt;&gt; Here is a list.

01:00:18.964 --> 01:00:23.097
BEHSHAD: It actually failed.  We
 can try one more time, maybe.  

01:00:23.098 --> 01:00:29.338
What are the side effects of 
Aspirin?

01:00:29.339 --> 01:00:31.410
&gt;&gt; Here are --
BEHSHAD: Okay.  But you know it 

01:00:31.411 --> 01:00:35.610
works.  I guess we are 
developing this too.  But really

01:00:35.611 --> 01:00:39.772
 in the core of what we need is 
also to be able to talk to 

01:00:39.773 --> 01:00:48.083
different services developed by 
the Google Platform to the 

01:00:48.084 --> 01:00:50.176
Assistant itself.  So in the 
next part of my demos, I want to

01:00:50.177 --> 01:00:54.350
 show how the Assistant should 
be ultra personal.  This is kind

01:00:54.351 --> 01:00:56.429
 of a personal assistant.  These
 are answers and things which 

01:00:56.430 --> 01:01:00.570
the Assistant can do about the 
world for me, but we want it to 

01:01:00.571 --> 01:01:04.755
also be answering things which 
are spoke me.  For example, I 

01:01:04.756 --> 01:01:10.991
can do things like, how is the 
traffic from Zurich Airport to 

01:01:10.992 --> 01:01:15.928
my home?
&gt;&gt; There is light traffic on the

01:01:15.929 --> 01:01:18.009
 way home.
BEHSHAD: So I don't need to say 

01:01:18.010 --> 01:01:22.154
what is the address of my home. 
 My Assistant knows that and 

01:01:22.155 --> 01:01:26.328
that's helpful for me.  I can 
ask for things like, when is my 

01:01:26.329 --> 01:01:32.535
flight today?
&gt;&gt; Your flight is at --

01:01:32.536 --> 01:01:36.675
BEHSHAD: So note that these are 
all happening automatic and 

01:01:36.676 --> 01:01:40.832
through a different machine 
learning system detecting that 

01:01:40.833 --> 01:01:49.130
from Gmail.  We have ways to do 
explicit in an explicit way.  

01:01:49.131 --> 01:01:51.208
For example, how is my team 
doing?

01:01:51.209 --> 01:01:53.271
&gt;&gt; They're only --
BEHSHAD: It's only the 

01:01:53.272 --> 01:01:55.355
beginning.
[ Applause ]

01:01:55.356 --> 01:02:01.562
But these are all -- I think 
that's -- these are all the 

01:02:01.563 --> 01:02:03.635
personal ones I have.  But I 
think the reason I can actually 

01:02:03.636 --> 01:02:05.708
do that is because I explicit

01:02:09.787 --> 01:02:16.022
 lilysaid this.  Or I can say 
what is my favorite team?

01:02:16.023 --> 01:02:20.196
&gt;&gt; You told me that you like 
Barcelona.  Biggest I liked 

01:02:20.197 --> 01:02:26.439
Barcelona a few months back, and
 when I say how is my team 

01:02:26.440 --> 01:02:30.606
doing, it considers Barcelona.  
Now I want to show you -- this 

01:02:30.607 --> 01:02:32.683
is a way that we can actually 
improve the Assistant by  

01:02:32.684 --> 01:02:36.827
teaching something to it about 
myself.  I'm going to show you a

01:02:36.828 --> 01:02:40.984
 more fancy version of that 
which is coming next year.  When

01:02:40.985 --> 01:02:47.203
 the weather is more than 25 
degrees, I can swim in the Lake 

01:02:47.204 --> 01:02:53.429
of Zurich.
&gt;&gt; Okay.  Understood.

01:02:53.430 --> 01:02:57.615
BEHSHAD: Can I swim in the Lake 
of Zurich this weekend?

01:02:57.616 --> 01:03:01.794
&gt;&gt; No, you can't.  The 
temperature is less than 25 

01:03:01.795 --> 01:03:03.860
degrees.
[ Applause ]

01:03:03.861 --> 01:03:05.927
BEHSHAD: What's the weather in 
Zurich this weekend?

01:03:05.928 --> 01:03:12.156
&gt;&gt; Here's the forecast.
BEHSHAD: So that's kind of -- 

01:03:12.157 --> 01:03:14.233
really, if you think about a 
personal assistant which you can

01:03:14.234 --> 01:03:18.366
 improve it through natural 
language, this is going to be 

01:03:18.367 --> 01:03:22.537
much more powerful and easier to
 use for many people.  So the 

01:03:22.538 --> 01:03:26.689
next part of my demo is I want 
to talk about context.  Context 

01:03:26.690 --> 01:03:28.764
is very important.  The 
different meanings of context is

01:03:30.839 --> 01:03:32.925
 used to make the interactions 
with the Assistant easier and 

01:03:32.926 --> 01:03:37.080
more natural.  And we use it in 
different place.  One of the 

01:03:37.081 --> 01:03:39.147
places that we use context is 
speech recognition itself.  

01:03:39.148 --> 01:03:45.386
Trying to understand the words. 
 So now I try to say an example 

01:03:45.387 --> 01:03:49.522
where first I don't give it a 
context.  Normally it fails.  

01:03:49.523 --> 01:03:53.658
And then I try to give it 
context and see whether it works

01:03:53.659 --> 01:03:57.802
 or not.  Something like, how 
high is the rice?

01:03:57.803 --> 01:04:04.053
&gt;&gt; Here you go.
BEHSHAD: How high is the rice?  

01:04:04.054 --> 01:04:08.207
So the point here is that I 
don't -- if context -- it's hard

01:04:10.288 --> 01:04:14.448
 to even hand it sometimes.
&gt;&gt; Here is the weather in Zurich

01:04:16.518 --> 01:04:18.594
.
BEHSHAD: It tries to do 

01:04:18.595 --> 01:04:24.847
something because it dunce 
understand what it says.  Now 

01:04:24.848 --> 01:04:28.994
let's see if I give some context
 to it.  Highest Tatra mountain

01:04:33.085 --> 01:04:39.318
s.  So as you see now, there is 
a Rysy there.  And now I will 

01:04:39.319 --> 01:04:43.482
ask and hopefully it should 
work.  How high is the Rysy?

01:04:43.483 --> 01:04:47.610
&gt;&gt; I can search the web for 
answers.

01:04:47.611 --> 01:04:49.699
BEHSHAD: Highest Tatra mountains

01:04:53.775 --> 01:05:02.073
.  How high is the Rysy?
&gt;&gt; The Rysy is --

01:05:02.074 --> 01:05:06.237
[ Applause ]
BEHSHAD: So this shows that 

01:05:06.238 --> 01:05:10.383
contextual voice recognition is 
actually going to play a big 

01:05:10.384 --> 01:05:12.455
role.  Because people actually 
always try to continue talking 

01:05:12.456 --> 01:05:16.618
about things which is related 
and things which are also 

01:05:16.619 --> 01:05:20.794
personal and location-specific 
and contextually relevant.  Now 

01:05:20.795 --> 01:05:24.914
let me show you another use of 
context when context is used to 

01:05:24.915 --> 01:05:26.985
understand the entities itself. 
 For example, pictures of

01:05:31.082 --> 01:05:33.159
 Thomas.  I think without a 
context, that's perhaps the best

01:05:33.160 --> 01:05:41.476
 we can come up with.  Bayern 
Munich team roster.

01:05:41.477 --> 01:05:45.624
&gt;&gt; The roster for Bayern Munich

01:05:49.709 --> 01:05:51.709
.  Bogey see

01:05:55.806 --> 01:05:57.875
BEHSHAD:  you see Thomas is 
here.  Pictures of Thomas.  So 

01:05:57.876 --> 01:06:02.020
in the context of --
[ Applause ]

01:06:04.134 --> 01:06:06.218
In the context of the previous 
sentence, then Thomas should be 

01:06:06.219 --> 01:06:10.362
interpreted as a different 
entity in this case.  Now, I 

01:06:10.363 --> 01:06:14.504
want to show you how context is 
helping to have

01:06:18.582 --> 01:06:20.663
 conversations.  Something like,
 where is the Empire State 

01:06:20.664 --> 01:06:24.806
Building.
&gt;&gt; The Empire State Building in 

01:06:24.807 --> 01:06:28.964
New York, New York.
BEHSHAD: I want to see pictures.

01:06:31.033 --> 01:06:37.266
&gt;&gt; Pictures of the Empire State 
Building, okay.

01:06:37.267 --> 01:06:43.495
BEHSHAD: How tall is it?
&gt;&gt; The Empire State Building is 

01:06:43.496 --> 01:06:45.496
443 meters

01:06:47.587 --> 01:06:49.652
  tall.
BEHSHAD: Who built it?

01:06:49.653 --> 01:06:53.803
&gt;&gt; Saret

01:06:57.885 --> 01:07:02.074
t Corporation.
BEHSHAD: When?

01:07:02.075 --> 01:07:04.075
&gt;&gt; 1930.
BEHSHAD:

01:07:06.165 --> 01:07:08.245
 what are the Italian 
restaurants around there?

01:07:08.246 --> 01:07:14.449
&gt;&gt; I found these places.
BEHSHAD: Call the first one.  

01:07:14.450 --> 01:07:18.621
It's in New York.  So you can 
see that I'm having a 

01:07:18.622 --> 01:07:24.859
conversation back and forth with
 -- I will stop there.

01:07:26.948 --> 01:07:28.948
[ Applause ]

01:07:31.022 --> 01:07:35.155
So you can see that I have like 
seven, ought sentences about the

01:07:35.156 --> 01:07:39.336
 Empire State Building I  
mentioned only one time.  This 

01:07:39.337 --> 01:07:43.500
is through the power of context 
and trying to put context in the

01:07:43.501 --> 01:07:47.683
 conversational understanding.  
This is closer to how people 

01:07:47.684 --> 01:07:49.776
talk.  Still, there are lots of 
problems Tor solved there, but 

01:07:49.777 --> 01:07:53.915
we are excited about the steps 
in the right direction.  Still, 

01:07:53.916 --> 01:07:58.062
I want to show another example 
of context, which is the context

01:07:58.063 --> 01:08:02.220
 of what you see.  So for that 
I'm basically trying to show 

01:08:02.221 --> 01:08:06.374
some examples of Google lens 
with the Assistant where we are 

01:08:06.375 --> 01:08:08.464
adding visual input to the 
Assistant.  I don't know what 

01:08:08.465 --> 01:08:12.614
you're seeing here.  I'm putting
 an apple here.  And I'm going 

01:08:12.615 --> 01:08:18.824
to the Google Lens part of the 
Assistant.  And I would ask, how

01:08:18.825 --> 01:08:25.026
 many calories does it have?
&gt;&gt; There are 95 calories in one 

01:08:25.027 --> 01:08:29.180
medium apple.
BEHSHAD: So that's the --

01:08:29.181 --> 01:08:31.247
[ Applause ]
This is an experience that you 

01:08:31.248 --> 01:08:35.407
can have where you have visual 
input and voice input together. 

01:08:35.408 --> 01:08:41.650
 So let me show you one other 
example.  I can try to get some 

01:08:41.651 --> 01:08:45.808
money.  The input.  Okay.

01:08:51.876 --> 01:08:56.031
  Okay.  This is -- yeah.  How 
much is this in Swiss

01:09:00.114 --> 01:09:02.114
 Franc?

01:09:04.180 --> 01:09:06.252
&gt;&gt; 250 --

01:09:12.338 --> 01:09:16.463
[ Applause ]
BEHSHAD: So you can see that -- 

01:09:16.464 --> 01:09:20.615
and this combination can be very
 useful.  I was actually walking

01:09:20.616 --> 01:09:24.770
 in Krakow yesterday seeing 
buildings and  trying to go 

01:09:24.771 --> 01:09:28.920
through Google Lens and ask 
questions about what was around.

01:09:28.921 --> 01:09:33.051
  That's going to be a more 
powerful experience for the 

01:09:33.052 --> 01:09:37.202
future of the Assistant.  The 
last example I want to show you 

01:09:37.203 --> 01:09:41.378
is -- the speech recognition 
often worked here.  I want to 

01:09:41.379 --> 01:09:45.532
show you we have worked on 
improving the speech recognition

01:09:45.533 --> 01:09:49.684
 in a noisy environment.  I want
 your help.  And the setup is we

01:09:49.685 --> 01:09:55.906
 will cut your mic, and you will
 make as much noise as you can. 

01:09:55.907 --> 01:10:00.056
 You want to make me fail.  I 
will ask when my favorite team 

01:10:00.057 --> 01:10:04.220
is playing next.  And we can put
 some music to make the noise to

01:10:04.221 --> 01:10:08.370
 be  higher.  It's okay if I 
fail.  It's just fun.  Let's do 

01:10:08.371 --> 01:10:10.491
it.
So please make as much noise as 

01:10:10.492 --> 01:10:14.692
you can, and please cut the mic.

01:10:18.775 --> 01:10:22.965
[Crowd making noise

01:10:27.065 --> 01:10:29.137
]
Can you have the mic?  We have 

01:10:29.138 --> 01:10:33.293
to spend lots of time on trying 
to improve the speech 

01:10:33.294 --> 01:10:35.363
recognition in a announcey 
environment.  Added lots of data

01:10:37.450 --> 01:10:41.606
 to the systems behind with the 
automatically generated noise 

01:10:41.607 --> 01:10:45.774
like fake noise of a stadium or 
people or  cars.  And that's how

01:10:45.775 --> 01:10:49.924
 we have significantly managed 
to improve this.  Thank you, the

01:10:49.925 --> 01:10:54.207
 cameraman.  So I can go back to
 my slides for -- thank you.

01:10:56.288 --> 01:10:58.288
[ Applause ]

01:11:02.383 --> 01:11:08.600
So what you have seen in the 
previous days in these demos is 

01:11:08.601 --> 01:11:12.771
actually lots of technologies 
going behind.  A lot of it's 

01:11:12.772 --> 01:11:18.993
being built in Zurich, in 
Europe.  Speech recognition, 

01:11:18.994 --> 01:11:21.064
understanding natural language, 
understanding the world, 

01:11:21.065 --> 01:11:23.154
understanding the user, 
understanding the context, image

01:11:23.155 --> 01:11:25.216
 recognition and 
personalization.  And many more.

01:11:25.217 --> 01:11:29.380
  But these were the ones that I
 put on the slides.  And this is

01:11:29.381 --> 01:11:33.555
  all -- these are all early 
steps of the Google Assistant 

01:11:33.556 --> 01:11:35.631
and the age of the Assistant.  
But it's a very exciting moment.

01:11:37.697 --> 01:11:41.843
  I want to remind you that I 
talked about AI revolution, and 

01:11:41.844 --> 01:11:43.927
that doesn't mean Google 
Assistant or age of assistant is

01:11:43.928 --> 01:11:48.073
 the AI revolution.  It's one of
 the things which is happening 

01:11:48.074 --> 01:11:52.230
in this AI revolution.  The AI 
and machine learning is being 

01:11:52.231 --> 01:11:56.385
used heavily and going to be 
used much many in many 

01:11:56.386 --> 01:12:00.532
industries such as health, 
agriculture, smart cities, smart

01:12:02.619 --> 01:12:04.689
 cars and many more.  It's time 
to invest in different 

01:12:04.690 --> 01:12:08.830
industries in the  AI.  And 
while at Google we're -- I'm

01:12:08.831 --> 01:12:10.920
working -- and we're working on 
the Google Assistant, I feel 

01:12:10.921 --> 01:12:15.080
very excited about adding these 
types of intelligences into the 

01:12:15.081 --> 01:12:19.214
Google Assistant.  But I think 
in the end the Google Assistant 

01:12:19.215 --> 01:12:21.291
will be more powerful depending 
on how many different services 

01:12:21.292 --> 01:12:25.467
and applications it can have.  
And this is where you all can 

01:12:25.468 --> 01:12:29.604
help by integrating with a 
Google Assistant with the 

01:12:29.605 --> 01:12:31.712
different use cases that you 
have and applications that you 

01:12:31.713 --> 01:12:35.866
have.  And take part with us in 
building this AI revolution.  

01:12:35.867 --> 01:12:40.022
Thank you.
[ Applause ]

01:12:48.121 --> 01:12:54.324
And I would like to invite 
Michael back to the stage.

01:12:54.325 --> 01:12:56.325
[ Applause ]

01:12:58.403 --> 01:13:02.542
MICHAEL: So we've had two great 
talks to kick off the day today.

01:13:02.543 --> 01:13:08.766
  And I would especially like to
 thank those two speakers, 

01:13:08.767 --> 01:13:12.923
Behshad who is very brave with 
all those demonstrations -- 

01:13:12.924 --> 01:13:15.169
thank you.
[ Applause ]

01:13:15.170 --> 01:13:21.379
And Ewa who showed us the very 
exciting work that's going on in

01:13:21.380 --> 01:13:27.606
 Warsaw in Poland.
[ Applause ]

01:13:27.607 --> 01:13:31.750
I was reminded of one of my 
favorite geeky  T-shirts as I 

01:13:31.751 --> 01:13:37.998
was listening to Ewa, which is, 
there's no such thing as cloud 

01:13:37.999 --> 01:13:42.145
computing.  Only someone else's 
computers.  And the thing is, 

01:13:42.146 --> 01:13:44.232
when that is true, you want the 
people running those computers 

01:13:44.233 --> 01:13:50.484
to know what they're doing.  And
 so trust in Google.  Use our 

01:13:50.485 --> 01:13:54.622
Google Cloud Platform.
Now, I'd advise you all to make 

01:13:54.623 --> 01:13:58.763
best use of the  Codelabs that 
allow you to sort of do 

01:13:58.764 --> 01:14:00.844
follow-up activities, especially

01:14:04.910 --> 01:14:07.000
 on the Google Cloud Platform 
stuff that Ewa was talking 

01:14:07.001 --> 01:14:11.138
about.  But also the open 
sourced stuff that relates to 

01:14:11.139 --> 01:14:15.284
what Behshad was talking about. 
 And for the rest of the day you

01:14:15.285 --> 01:14:19.444
 can join in sessions and 
trainings and explore the  

01:14:19.445 --> 01:14:23.593
sandboxes scattered around.  And
 don't forget,  wrapping up at a

01:14:23.594 --> 01:14:29.820
 quarter past five, 17:15, back 
here in the main auditorium with

01:14:29.821 --> 01:14:33.984
 the closing keynote.  Thanks 
very much, and enjoy the rest of

01:14:33.985 --> 01:14:36.076
 the conference.
[ Applause ]

01:29:17.912 --> 01:29:22.452
[ Applause ]
FLORINA: Hello, everyone.  My 

01:29:22.453 --> 01:29:26.602
name is Florina Muntenescu.  I'm
 a developer at Google.  At 

01:29:26.603 --> 01:29:30.746
Google I/O earlier this year we 
launched architecture 

01:29:30.747 --> 01:29:34.920
components.  A collection of 
libraries that help you design 

01:29:34.921 --> 01:29:39.078
robust, testable and 
maintainable apps.   Since then 

01:29:39.079 --> 01:29:43.230
we have been discussing with a 
lot of  you.  And then we saw a 

01:29:43.231 --> 01:29:47.362
lot of the requests that kept on
 repeating.  Stuff like, okay, 

01:29:47.363 --> 01:29:51.512
I'm already using Java in my 
application.  Should I start 

01:29:51.513 --> 01:29:55.663
using live beta also?  Or my 
architecture is implemented and 

01:29:55.664 --> 01:30:03.971
you're saying MVP, should I move
 to MVVM?  Or I need to display

01:30:06.040 --> 01:30:08.110
 a large list.  What should I 
do?  I want to tell you our 

01:30:08.111 --> 01:30:10.174
suggestions of how to handle all
 of these.

01:30:10.175 --> 01:30:14.349
But before I go into this, I 
want to go a little bit over the

01:30:14.350 --> 01:30:18.493
 architecture components just to
 make sure that we're all on the

01:30:18.494 --> 01:30:22.633
 same page.  And also I want to 
mention a few of these dos and 

01:30:22.634 --> 01:30:26.787
don'ts of the of the 
architecture components.  So 

01:30:26.788 --> 01:30:28.863
let's say that this is an 
activity that displays 

01:30:28.864 --> 01:30:33.015
information about the user.  One
 of the biggest problems for us 

01:30:33.016 --> 01:30:39.236
and our developers is 
configuration change.  So, for 

01:30:39.237 --> 01:30:41.314
example, when you take your 
device, the activity gets 

01:30:41.315 --> 01:30:47.539
destroyed and then re-created.
So to help with this, we 

01:30:47.540 --> 01:30:51.706
introduced a lifecycle and the 
lifecycle owner.  So an activity

01:30:51.707 --> 01:30:57.933
 or a fragment has a life cycle.
  Therefore, they are autolife 

01:30:57.934 --> 01:31:00.013
cycle owner.  And the life cycle
 of a

01:31:04.094 --> 01:31:06.186
  lifecycleownerring with can be
 observed by a  

01:31:06.187 --> 01:31:12.427
lifepsycherobserver.  In that 
observer, we can define methods 

01:31:12.428 --> 01:31:14.513
that will be called whenever 
life cycle events are triggered.

01:31:14.514 --> 01:31:20.759
  All you need to do is annotate
 with lifecycle.event, plus the 

01:31:20.760 --> 01:31:26.998
event name that you're 
interested in.  Architecture 

01:31:26.999 --> 01:31:29.073
components provides one such 
component, which is live data.  

01:31:29.074 --> 01:31:33.238
Live data is a data holder.  So 
it can hold information about 

01:31:33.239 --> 01:31:39.454
the user, for example.  And 
other components can set the 

01:31:39.455 --> 01:31:47.725
value that is being called.
And activities and fragments 

01:31:47.726 --> 01:31:51.894
with so objects that have a life
 cycle can observe that live 

01:31:51.895 --> 01:31:56.038
data.  And then they can react 
on the changes of that live 

01:31:56.039 --> 01:32:02.268
data.  And then they can update 
the UI, for example.  But when 

01:32:02.269 --> 01:32:08.462
the activities are destroyed, 
the subscriber is removed.  So 

01:32:08.463 --> 01:32:12.607
the live data is considered 
enactive, and the events are not

01:32:14.689 --> 01:32:16.758
 propagated.  But once the 
activity is re-created, we 

01:32:16.759 --> 01:32:22.990
subscribe again and we can 
update the UI.

01:32:22.991 --> 01:32:27.161
The Cloud is designed to store 
and manage the  UI data that 

01:32:27.162 --> 01:32:33.377
survives configuration changes, 
it's the ViewModel.  So let's 

01:32:33.378 --> 01:32:37.545
see how the life cycle of the 
ViewModel look like compared to 

01:32:37.546 --> 01:32:41.703
the activity life cycle.  We can
 see that we can create a 

01:32:41.704 --> 01:32:43.786
ViewModel only once the activity
 is created.  And then the 

01:32:43.787 --> 01:32:50.040
ViewModel will only be destroyed
 from the activity is finished. 

01:32:50.041 --> 01:32:54.196
 So more precisely, the 
ViewModel survives configuration

01:32:56.272 --> 01:32:58.339
 changes, but it will not 
survive pressing back on your 

01:32:58.340 --> 01:33:02.509
phone,  killing the application 
from recess, or when the 

01:33:02.510 --> 01:33:06.653
fragment kills your application.
  So this means that the 

01:33:06.654 --> 01:33:10.808
ViewModel is perfect for 
handling long-running 

01:33:10.809 --> 01:33:12.876
operations.  Because the 
ViewModel will be updated 

01:33:12.877 --> 01:33:14.947
independent on whether the data 
is observed or not.

01:33:14.948 --> 01:33:21.165
So this means that you will no 
longer get these null pointer 

01:33:21.166 --> 01:33:25.316
exceptions when trying to update
 a nonexistent view.  So make 

01:33:25.317 --> 01:33:31.529
sure you avoid  referencing 
Views in ViewModels because they

01:33:31.530 --> 01:33:33.606
 can lead to memory leaks or 
crashes.

01:33:35.672 --> 01:33:37.743
So the mind-set here changes a 
little bit because instead of 

01:33:37.744 --> 01:33:41.916
pushing the data to the UI, you 
let the UI observe the changes. 

01:33:41.917 --> 01:33:46.064
 So just make sure you don't 
hold any UI logic in the view, 

01:33:46.065 --> 01:33:50.233
but rather move this in the 
ViewModel so it can be easily 

01:33:50.234 --> 01:33:56.452
unit tested.  So, for example, 
it will be the ViewModel's 

01:33:56.453 --> 01:33:58.526
responsibility to get the user, 
prepare it to be displayed, and 

01:33:58.527 --> 01:34:02.687
hold it for the UI.  And then 
the UI will notify the ViewModel

01:34:04.767 --> 01:34:11.006
 of the user's actions.
The ViewModel would work with a 

01:34:11.007 --> 01:34:13.074
repository.  This will be a 
class that you define.  To get 

01:34:13.075 --> 01:34:17.246
and set the data.  So the 
repository models are -- modules

01:34:19.312 --> 01:34:23.439
 -- are responsible for handling
 data operations.  They provide 

01:34:23.440 --> 01:34:25.522
clean API to the rest of the 
application.  They know where to

01:34:25.523 --> 01:34:29.693
 get the data, what the API  is 
called to make when the data is 

01:34:29.694 --> 01:34:35.907
updated.  So you can see them as
 mediators between different 

01:34:35.908 --> 01:34:40.046
data sources.  So it's a good 
idea to have a data point in 

01:34:40.047 --> 01:34:44.188
your app completely unaware of 
the presentation layer.  Because

01:34:44.189 --> 01:34:50.416
 algorithms that synchronize or 
keep caches or make database 

01:34:50.417 --> 01:34:52.527
synchronizations are quite 
complicated.  So you want to add

01:34:54.628 --> 01:34:56.714
 a single point of entry to your
 data.

01:34:56.715 --> 01:35:00.876
So this means that the 
repository will know which API 

01:35:00.877 --> 01:35:05.031
to call to get the user from the
 network.  And because you want 

01:35:05.032 --> 01:35:07.106
to make sure that we don't 
request the data too many times,

01:35:07.107 --> 01:35:13.319
 we also want to save it locally
 in the database.  But to save 

01:35:13.320 --> 01:35:15.320
the data in the database

01:35:17.400 --> 01:35:23.599
, architecture components comes 
with a new one -- room.  It's an

01:35:23.600 --> 01:35:29.843
 object mapping library that 
provides data assistance with 

01:35:29.844 --> 01:35:31.924
minimum boiler code.  So, for 
example, let's say this is our 

01:35:31.925 --> 01:35:36.086
user's table that has a user ID,
 which is a primary ID and a 

01:35:36.087 --> 01:35:40.228
name and all sorts of other 
information about the user.

01:35:40.229 --> 01:35:46.474
And what we want is actually 
every instance of that -- of the

01:35:46.475 --> 01:35:50.615
 row should be an instance of a 
user object.  So to do this, we 

01:35:50.616 --> 01:35:56.828
define a user data model that we
 just annotate with entity.  

01:35:56.829 --> 01:36:03.075
Here we define the primary key 
and the column influence.  To 

01:36:03.076 --> 01:36:09.295
actually access the data in the 
database, we work with DAOs.  

01:36:09.296 --> 01:36:17.599
Data access objects.  We use DAO
 and define access points, 

01:36:17.600 --> 01:36:21.751
queries, inserts, updates and 
deletes.  Queries can also 

01:36:21.752 --> 01:36:25.935
return live data objects.  So 
they're making this query an 

01:36:25.936 --> 01:36:30.090
observable query.  So what's an 
observable query?  Let's say we 

01:36:30.091 --> 01:36:32.169
have this user's table and we 
want to get the users by  ID.

01:36:34.249 --> 01:36:36.314
So let's say that we're 
interested in the user with ID 4

01:36:38.382 --> 01:36:42.523
.  So live data will get the 
initial data from the database, 

01:36:42.524 --> 01:36:46.684
which is the user with the name,
 John.  But then, when we update

01:36:46.685 --> 01:36:52.929
 the data in the table with -- 
let's say -- Mark, instead of 

01:36:52.930 --> 01:36:57.092
John -- the live data will 
automatically fit that new 

01:36:57.093 --> 01:37:01.241
information.  So using 
observable queries means that we

01:37:01.242 --> 01:37:05.395
 have a UI that observes -- that
 reflects the latest changes in 

01:37:05.396 --> 01:37:09.559
the databases.  Because the 
repository would expose a live 

01:37:09.560 --> 01:37:13.704
data object.  And then the 
ViewModel will also expose a 

01:37:13.705 --> 01:37:19.950
live data object for the UI.  So
 what I have been mentioning 

01:37:19.951 --> 01:37:24.108
before until now was the 
ViewModels and with the 

01:37:24.109 --> 01:37:28.273
repositories is what we call a 
guide to app architecture.

01:37:28.274 --> 01:37:32.419
It provides testability and 
separations of concerns.  When I

01:37:34.502 --> 01:37:38.650
 saw the questions about this.  
So, for example, how many 

01:37:38.651 --> 01:37:44.898
LiveData objects should I expose
 from my ViewModel?  Should I 

01:37:44.899 --> 01:37:49.043
have -- let's say that the 
LiveData contains the model for 

01:37:49.044 --> 01:37:53.192
the screen.  Should I expose 
only one?  Should I expose 

01:37:53.193 --> 01:37:57.354
multiple?  So let's say that the
 top part contains some user 

01:37:57.355 --> 01:38:01.517
information, and then the bottom
 part, some general settings 

01:38:01.518 --> 01:38:03.594
data.  So you can see that 
actually these are two different

01:38:03.595 --> 01:38:07.740
 logical units.
So what you could do is group 

01:38:07.741 --> 01:38:13.956
together these logical units so 
you could expose a LiveData from

01:38:13.957 --> 01:38:18.090
 the user info, and then another
 LiveData for the  settings.  

01:38:18.091 --> 01:38:26.403
What if I'm using a MVP?  Should
 I switch to MVVM?  Should

01:38:28.472 --> 01:38:34.722
 you replace with the ViewModel?
  It depends.  How much logic 

01:38:34.723 --> 01:38:38.851
you have on how testable your 
classes are.  The main idea is 

01:38:38.852 --> 01:38:40.935
you should keep the logic in 
activities and in fragments to a

01:38:40.936 --> 01:38:47.178
 minimum.  What you could do is 
put a ViewModel between the 

01:38:47.179 --> 01:38:49.254
presenter and the repository and
 still let the presenter work 

01:38:49.255 --> 01:38:53.424
with the view.  But what's 
extremely important is not to 

01:38:53.425 --> 01:38:55.500
let ViewModels and the 
presenters know about the end 

01:38:55.501 --> 01:38:59.649
framework classes.  And make 
sure you distribute 

01:38:59.650 --> 01:39:01.729
responsibilities.  Don't be 
afraid to create new classes.

01:39:01.730 --> 01:39:10.039
Should I use LiveData if I'm 
already using RX Java?  If 

01:39:10.040 --> 01:39:12.118
you're already using RX Java, 
your project looks

01:39:16.205 --> 01:39:20.397
 is something like this.  You're
 using it on the database part, 

01:39:20.398 --> 01:39:22.477
the network part.  You have a 
repository that exposes 

01:39:22.478 --> 01:39:26.657
observables and ViewModels that 
also do that.  So one way you 

01:39:26.658 --> 01:39:30.800
could do this is split the 
responsibility.  LiveData was 

01:39:30.801 --> 01:39:37.034
made for the UI.  So you could 
leverage that and let the 

01:39:37.035 --> 01:39:39.106
LiveData handle the connection 
between the ViewModel and your 

01:39:39.107 --> 01:39:47.383
activities or fragments.  You 
could use a composite disposal 

01:39:47.384 --> 01:39:51.517
where you keep your positions to
 the RX Java.  And then in the 

01:39:51.518 --> 01:39:55.670
ViewModel all clear, you just 
clear those disposables.  How 

01:39:55.671 --> 01:39:59.827
about the data?  How do we save 
it?  Where do we save it?  

01:39:59.828 --> 01:40:04.000
Should you save it in the 
database?  In the ViewModel?  

01:40:04.001 --> 01:40:08.161
What should you save on save 
instance?  So before going over 

01:40:08.162 --> 01:40:10.242
the few scenarios, let's look at
 this again.

01:40:12.320 --> 01:40:14.401
So only when the activity is 
finished, only then the 

01:40:14.402 --> 01:40:20.607
ViewModel is cleared.  So let's 
remember this.  So let's see 

01:40:20.608 --> 01:40:22.686
what happens when the 
application starts.  When the 

01:40:22.687 --> 01:40:24.764
activity starts, you call

01:40:28.858 --> 01:40:33.027
 OnCreate.  And then the 
ViewModel.  It will talk to the 

01:40:33.028 --> 01:40:35.125
repository to get the user.  So 
the repository will do a request

01:40:37.201 --> 01:40:41.339
 to the network calling a get 
user from your backend.  The 

01:40:41.340 --> 01:40:43.412
repository will save that user 
information in the database.  

01:40:43.413 --> 01:40:45.544
And then it will expose that 
information to the ViewModel.

01:40:47.618 --> 01:40:51.771
The ViewModel will create the 
model for the UI because maybe 

01:40:51.772 --> 01:40:53.844
you don't want to enclose all of
 that information that you have 

01:40:53.845 --> 01:40:55.917
about your user.  Maybe on the 
first one and the last one.  And

01:40:57.991 --> 01:41:02.158
 then the activity will use that
 information and will display 

01:41:02.159 --> 01:41:08.363
it.  Let's see what happens when
 you do configuration changes.  

01:41:08.364 --> 01:41:14.582
So, for example, when we are 
rotating the device.  So on 

01:41:14.583 --> 01:41:18.754
configuration change, the OnStop
 is being called.  But the 

01:41:18.755 --> 01:41:24.988
ViewModel still exists, still 
holds a reference to the UI 

01:41:24.989 --> 01:41:27.084
model.  When the application 
goes to foreground, it's 

01:41:27.085 --> 01:41:35.454
re-created, the OnStart is 
created.  And we get the reasons

01:41:35.455 --> 01:41:39.589
 from the ViewModel.  That's it.
  We don't need to work with the

01:41:39.590 --> 01:41:43.725
 repository at all.  Let's say 
that our application goes to 

01:41:43.726 --> 01:41:47.866
background and then the user 
navigates back to the app.

01:41:49.935 --> 01:41:54.080
So in this case, when the 
activity goes to background, 

01:41:54.081 --> 01:42:00.299
OnSaveed instancestate is 
called.  And when then when the 

01:42:00.300 --> 01:42:04.449
activity goes to foreground, we 
display the user information 

01:42:04.450 --> 01:42:08.594
based on whatever we have in the
 ViewModel.  Again, without 

01:42:08.595 --> 01:42:10.673
requesting anything from the 
network.  So now we are on 

01:42:10.674 --> 01:42:12.751
three.  Application goes to 
background.  And then the 

01:42:12.752 --> 01:42:18.983
process is killed.  So in this 
case, when the data goes to 

01:42:18.984 --> 01:42:25.227
background, we should OnSaveed 
Instance state, we should save 

01:42:25.228 --> 01:42:29.368
the user ID.  This is why -- 
because when the process is 

01:42:29.369 --> 01:42:33.514
killed, the ViewModel is also 
killed.  So when the activity 

01:42:33.515 --> 01:42:41.810
starts in the  OnCreate, we have
 it in the user ID.  We can 

01:42:41.811 --> 01:42:43.891
inform the ViewModel about the 
user ID we're interested in and 

01:42:43.892 --> 01:42:45.955
the ViewModel will talk to the 
repository to get the user.  But

01:42:48.043 --> 01:42:50.121
 the repository already has that
 information in the database, so

01:42:50.122 --> 01:42:52.180
 we no longer need to do another
 network request just to get the

01:42:54.258 --> 01:42:58.414
 user.
So the 

01:43:02.493 --> 01:43:04.594
OnSaveinstance state allows us 
to have the information to 

01:43:04.595 --> 01:43:08.775
restore the UI without network 
requests.  So what should you 

01:43:08.776 --> 01:43:12.909
put in each of them?  In the 
database, put the data that 

01:43:12.910 --> 01:43:17.045
survives process death.  In the 
ViewModel, put the data that's 

01:43:17.046 --> 01:43:19.124
needed by the UI.  And then in

01:43:25.196 --> 01:43:27.262
 onSavedinstancestate, put the 
minimum information needed to 

01:43:27.263 --> 01:43:29.337
restore the data.  Instead of 
just the user, let's consider 

01:43:29.338 --> 01:43:35.563
that we have a list of users.
Many applications need to load a

01:43:35.564 --> 01:43:37.655
 lot of information from the 
database.  Database queries can 

01:43:37.656 --> 01:43:41.822
take a long time to run and use 
a lot of memory.  And we have a 

01:43:41.823 --> 01:43:48.062
new paging library that we will 
release soon that can help you 

01:43:48.063 --> 01:43:54.328
with all of this.  So the main 
components of the paging library

01:43:54.329 --> 01:44:02.637
 are, the  PagedList adapters 
that extends the adapter, a list

01:44:02.638 --> 01:44:08.854
 and a data source.  The 
datasource is an interface for 

01:44:08.855 --> 01:44:10.926
the sources to provide 
information gradually.  But 

01:44:10.927 --> 01:44:15.063
you'll need to implement one of 
the two  datasources.  Either a 

01:44:15.064 --> 01:44:21.323
keyed datasource when you need 
to load based on the item and 

01:44:21.324 --> 01:44:27.539
minus one, or a tiled datasource
 which allows you to jump in any

01:44:27.540 --> 01:44:29.622
 state of your data set 
instantly.  And you also need to

01:44:31.710 --> 01:44:35.850
 implement another method, 
loadcount.  This will be the one

01:44:35.851 --> 01:44:40.016
 that tells whether you have an 
infinite or a finite amount of 

01:44:40.017 --> 01:44:42.090
items that you need to display 
in your list.

01:44:42.091 --> 01:44:48.311
The pagedlist is a component 
that loads the data 

01:44:48.312 --> 01:44:52.478
automatically and can provide 
update signals, for example, to 

01:44:52.479 --> 01:44:56.618
the adapt.  The data is loaded 
automatically from a data source

01:44:56.619 --> 01:45:00.779
 on the background thread, but 
then it's consumed on the main 

01:45:00.780 --> 01:45:04.945
thread.  And it supports both an
 infinite scrolling list, but 

01:45:04.946 --> 01:45:09.105
also countable lists.  And you 
can configure several things.  

01:45:09.106 --> 01:45:13.263
You can configure the initial 
load size, the page size, but 

01:45:13.264 --> 01:45:19.511
also the prefetch distance.
So here's the data flow.  Let's 

01:45:19.512 --> 01:45:23.657
say that we have some data that 
we put on the datasource on the 

01:45:23.658 --> 01:45:27.824
background thread.  The 
datasource invalidates the page 

01:45:27.825 --> 01:45:36.127
list and updates its value.  And
 then, on the main thread, the 

01:45:36.128 --> 01:45:40.283
pagelist notifies the otherrers 
of the new value.  Now the page 

01:45:40.284 --> 01:45:46.501
knows about the new  one.  On 
the background thread, the 

01:45:46.502 --> 01:45:48.589
pagelistadapter needs to compute
 what changed?  What's the 

01:45:48.590 --> 01:45:52.738
difference?  And then back on 
the UI thread, the view is 

01:45:52.739 --> 01:45:58.965
updieted in the onBind 
viewholder.  This happens 

01:45:58.966 --> 01:46:01.044
automatically.  You just insert 
an item in the database and see 

01:46:01.045 --> 01:46:05.182
it animated in, and no UI code 
is required.

01:46:05.183 --> 01:46:11.415
Okay.  Let's look at the code a 
bit.  So to tell the adapter how

01:46:11.416 --> 01:46:17.647
 to compute between the two 
elements, you need a new class. 

01:46:17.648 --> 01:46:25.949
 Diff callback.  You will define
 two things, to compute whether 

01:46:25.950 --> 01:46:28.042
the contents are the same, and 
how to define whether the items 

01:46:28.043 --> 01:46:34.303
are the same.  Simplify the 
connection between the 

01:46:34.304 --> 01:46:36.373
datasource and the recyclerview,
 we can use the

01:46:40.455 --> 01:46:42.542
 livepaged listprovider.  This 
will expose live data of a paged

01:46:42.543 --> 01:46:48.828
 list of our user.  So all you 
will need to do is provide a 

01:46:48.829 --> 01:46:52.966
datasource.  But if that  
datasource is true, then it will

01:46:52.967 --> 01:46:57.122
 be generated for you.  You 
don't need to write any 

01:46:57.123 --> 01:47:01.282
invalidating handling code.  You
 can simply bind the livedata to

01:47:01.283 --> 01:47:05.409
 the page list and get updates 
and validates and life cycle 

01:47:05.410 --> 01:47:07.496
cleanup with a single line of 
binding code.

01:47:07.497 --> 01:47:15.813
So in our user DAO, we would 
return a live page list provider

01:47:15.814 --> 01:47:19.956
 of our users to get the users 
by the last name.  And then, in 

01:47:19.957 --> 01:47:24.114
the ViewModel, we would extend 
from the architectural component

01:47:28.200 --> 01:47:32.326
 ViewModel, and then keep the 
live page list.  And we will get

01:47:32.327 --> 01:47:36.504
 that reference from the DAO by 
calling get users by the last 

01:47:36.505 --> 01:47:38.564
name.  And then calling create, 
using the configuration that you

01:47:38.565 --> 01:47:44.792
 want.  So, for example,  
setting the page size to 50, 

01:47:44.793 --> 01:47:48.925
setting the prefetch distance to
 50 and so on.

01:47:48.926 --> 01:47:55.139
In our activity, the activity 
needs to be, of course, a 

01:47:55.140 --> 01:47:59.294
lifecycleowner.  And then in the
 onCreate, we get to reference 

01:47:59.295 --> 01:48:03.455
our ViewModel.  We get a 
reference to the recyclerview, 

01:48:03.456 --> 01:48:09.668
and we create our adapter.  And 
then we use another handy class 

01:48:09.669 --> 01:48:11.669
from the architecture 
components.

01:48:13.756 --> 01:48:15.826
  LivelistadapterUtil.  This 
provides hooks for live data and

01:48:15.827 --> 01:48:19.976
 life cycle so you can bind with
 just one line of code and not 

01:48:19.977 --> 01:48:24.116
worry about the cleanup.
And then we are just setting the

01:48:24.117 --> 01:48:28.285
 adapter to the recyclerview.  
Let's look at the adapter.  So 

01:48:28.286 --> 01:48:34.507
our adapter will extend page 
list adapter and then connect 

01:48:34.508 --> 01:48:38.660
the user, the information they 
need to supply, with the user.  

01:48:38.661 --> 01:48:42.794
And then we define the  
callback, the diff callback for 

01:48:42.795 --> 01:48:46.954
our user objects.  And then in 
onBind

01:48:51.063 --> 01:48:55.209
viewholder, we bind the item to 
the view.  That's all.  We have 

01:48:55.210 --> 01:48:57.288
a lot of new  concepts and 
components with architecture  

01:48:57.289 --> 01:49:01.448
components, but the thing is, 
you can use them separately.  So

01:49:01.449 --> 01:49:09.825
 if you want, you only will be 
able to use lifecycle, livedata 

01:49:09.826 --> 01:49:13.975
or pagelist.  Or only ViewModel.
  But you can also use them 

01:49:13.976 --> 01:49:18.139
together.  So start using the 
architecture components to 

01:49:18.140 --> 01:49:22.294
create a more testable 
architecture for your 

01:49:22.295 --> 01:49:24.372
application.  Thank you.
[ Applause ]

01:59:39.246 --> 01:59:45.878
&gt;&gt; Hello.  Hello.  It's great to
 see so many of you here.  My 

01:59:45.879 --> 01:59:52.137
name is Mete Atamel.  I'm at 
Google based in London.

01:59:52.138 --> 01:59:54.138
[ Applause ]

01:59:58.219 --> 02:00:02.355
&gt;&gt; [speaking many another 
language]

02:00:02.356 --> 02:00:04.435
&gt;&gt; I don't know what you said, 
but I hope it was good.

02:00:04.436 --> 02:00:08.581
&gt;&gt; I'm not sure either, but I 
think I said, good morning, and 

02:00:08.582 --> 02:00:12.727
welcome you to our session.
&gt;&gt; Great.  First of all, before 

02:00:12.728 --> 02:00:16.884
we start the talk, you might be 
wondering, what's a developer 

02:00:16.885 --> 02:00:21.053
advocate?  One of my good 
friends basically said a 

02:00:21.054 --> 02:00:25.210
developer advocate is a software
 engineer who has license to 

02:00:25.211 --> 02:00:27.288
speak.  I think that kind of 
captures what we do.  We are 

02:00:27.289 --> 02:00:29.368
software engineers by  
experience.  But we come to 

02:00:29.369 --> 02:00:33.581
events like this and talk about 
Google Cloud-related 

02:00:33.582 --> 02:00:35.670
technologies.  At the same time 
we want to get your feedback, so

02:00:37.741 --> 02:00:39.818
 -- and bring that back to 
engineering.  So after this talk

02:00:39.819 --> 02:00:43.974
 we have office hours on level 
three.  So if you have questions

02:00:43.975 --> 02:00:48.129
 or feedback about Google Cloud,
 come and see us.  Today we want

02:00:48.130 --> 02:00:52.275
 to talk about the fundamentals 
of the Google Cloud Platform.  

02:00:52.276 --> 02:00:56.438
We have a Bitly link for the 
slides, if you want the slides, 

02:00:56.439 --> 02:00:58.509
get it there.  I have been with 
Google for one and a half years.

02:00:58.510 --> 02:01:02.655
  But Marc has been around more 
than me.  Since 2011.  Marc, you

02:01:02.656 --> 02:01:06.814
 want to tell us about the good 
old days in 2011?  How it was?

02:01:08.923 --> 02:01:13.056
&gt;&gt; Sure.  So back when I started
, Google Cloud Platform was 

02:01:13.057 --> 02:01:17.211
quite a bit simpler.  This is 
actually what the platform 

02:01:17.212 --> 02:01:23.482
Website looked like in 2012.  
There were four products, Appear

02:01:25.563 --> 02:01:29.698
 Engine, compute engine, Cloud 
storage and big query.  You 

02:01:29.699 --> 02:01:33.848
could get your head around the 
entire product offering.  Those 

02:01:33.849 --> 02:01:38.028
were the good old days for me.  
This is what it's like nowadays.

02:01:38.029 --> 02:01:44.244
  We have more than 60 Google 
Cloud product services and so 

02:01:44.245 --> 02:01:48.393
many that I can't even fit them 
all on one slide.  So there's a 

02:01:48.394 --> 02:01:52.592
lot of choices out there.
&gt;&gt; That's good, right?  Marc?  

02:01:52.593 --> 02:01:56.767
More tools, more choice, that 
can be only good, right?

02:01:56.768 --> 02:02:00.922
&gt;&gt; It's a mixed bag, actually.  
The good news is we have tons of

02:02:00.923 --> 02:02:07.166
 capables.  You can build almost
 anything you can imagine now.  

02:02:07.167 --> 02:02:11.302
It's a powerful platform.  But 
there's a high cognitive load.  

02:02:11.303 --> 02:02:15.460
You have to think and understand
 a little bit more to understand

02:02:15.461 --> 02:02:19.621
 what tool to use, when to use 
it and how to use it.  Greg 

02:02:19.622 --> 02:02:23.767
Wilson came up with this chart, 
which I think is really nice as 

02:02:23.768 --> 02:02:27.922
a reference.  And by the way, 
for anybody photographing, we 

02:02:27.923 --> 02:02:32.096
have the slides online right 
now.  Feel free to photograph, 

02:02:32.097 --> 02:02:36.248
but we'll share this with you.  
It's actually up  now.  But this

02:02:36.249 --> 02:02:40.391
 chart summarizes every Cloud  
product -- every Google Cloud 

02:02:40.392 --> 02:02:46.647
product in four words or less.  
So it's a really nice synopsis. 

02:02:46.648 --> 02:02:48.714
 Today we're going to focus on 
the four highlighted areas.  And

02:02:48.715 --> 02:02:52.851
 even there we're not going to 
get to go too  deeply because we

02:02:52.852 --> 02:02:54.941
 have 30 minutes to cover all of
 this stuff.  And each of the 

02:02:54.942 --> 02:02:59.079
products, we could spend hours 
on.  But we'll focus on those 

02:02:59.080 --> 02:03:01.150
four  areas.  We'll probably 
touch on

02:03:01.151 --> 02:03:03.237
a few others.  And we'll try to 
just give you a high-level view,

02:03:05.312 --> 02:03:07.383
 essentially a roadmap, of all 
the capabilities of

02:03:11.465 --> 02:03:15.654
 Google Cloud Platform.
&gt;&gt; First, let's talk about 

02:03:15.655 --> 02:03:19.805
compute.  I heard in the keynote
 there was a compute section.  

02:03:19.806 --> 02:03:23.959
Hopefully new stuff.  And you 
have code and want to run on 

02:03:23.960 --> 02:03:26.067
Google Cloud, what options do 
you have?  That's what we're 

02:03:26.068 --> 02:03:30.207
trying to answer.  At the high 
level, you have three separate 

02:03:30.208 --> 02:03:32.279
buckets when it comes to how to 
deploy your code.   The first 

02:03:32.280 --> 02:03:38.503
one is virtual  machines.  You 
can think of these as physical 

02:03:38.504 --> 02:03:40.586
machines, except their 
virtualized and running in 

02:03:40.587 --> 02:03:44.756
someone else's data center.  You
 can pick and choose the CPU, 

02:03:44.757 --> 02:03:46.825
the memory you want.  And the 
operating system, Linux or 

02:03:46.826 --> 02:03:50.975
Windows-based.  And once you 
have the machine, you can 

02:03:50.976 --> 02:03:55.129
install whatever you want so you
 have full control, but at the 

02:03:55.130 --> 02:03:57.219
same time you have full 
responsibility with virtual 

02:03:57.220 --> 02:03:59.312
machines.  So virtual machines 
are great, but kind of heavy 

02:03:59.313 --> 02:04:03.453
weight because you need to 
virtualize the whole operating 

02:04:03.454 --> 02:04:07.586
system and everything on top of 
that.  So more recently, 

02:04:07.587 --> 02:04:09.682
something called containers.  So
 the idea with containers, 

02:04:09.683 --> 02:04:13.843
instead of virtualizing
 the  operating system, you're 

02:04:13.844 --> 02:04:17.992
running the process that runs.  
You're virtualizing the 

02:04:17.993 --> 02:04:20.084
application and its 
dependencies.  And from there, 

02:04:20.085 --> 02:04:22.166
you create a  container image.  
And this container image is much

02:04:24.232 --> 02:04:26.310
 more lightweight than virtual 
machines.  So  containers are 

02:04:26.311 --> 02:04:30.477
really easy to move around.  
They're really fast to start.  

02:04:30.478 --> 02:04:32.552
They're much quicker and agile 
way of running your 

02:04:32.553 --> 02:04:34.622
applications.
And if you're like me, you 

02:04:34.623 --> 02:04:38.770
usually don't care about 
infrastructure.  You don't want 

02:04:38.771 --> 02:04:40.837
to care about virtual machineses
 or containers, you want to 

02:04:40.838 --> 02:04:45.001
deploy your code and let someone
 else manage it for you, that's 

02:04:45.002 --> 02:04:49.126
when serverless comes in.  In 
serverless, create a function, 

02:04:49.127 --> 02:04:53.262
deploy it, and let someone else 
scale it for you, run it for 

02:04:53.263 --> 02:04:57.404
you.  All that kind of stuff.
&gt;&gt; So as Matt just said, 

02:04:57.405 --> 02:05:01.549
containers have really changed 
everything.  That's another 

02:05:01.550 --> 02:05:03.626
thing I have noticed over the 
last five years has had a huge 

02:05:03.627 --> 02:05:05.712
impact on the entire industry 
and the cloud in particular.  It

02:05:05.713 --> 02:05:09.875
 kind of really picked up steam 
when Docker was released in 2013

02:05:11.946 --> 02:05:16.102
.  So containers really enable a
 bunch of things that we didn't 

02:05:16.103 --> 02:05:20.264
have before.  But containers by 
themselves are not enough.  If 

02:05:20.265 --> 02:05:22.340
you think about deploying your 
applications in  containers, 

02:05:22.341 --> 02:05:28.559
these entirely self-contained 
modular units that you can kind 

02:05:28.560 --> 02:05:32.701
of scale incrementally, it's 
wonderful.  But if you have a 

02:05:32.702 --> 02:05:36.872
complex application with a bunch
 of frontend servers, a bunch of

02:05:36.873 --> 02:05:41.028
 backend servers, maybe some 
middleware.  It's difficult to 

02:05:41.029 --> 02:05:45.183
get it to work together, to 
monitor it and restart when they

02:05:45.184 --> 02:05:51.415
 fail.  That's where 
orchestraters come in.  The most

02:05:51.416 --> 02:05:55.582
 popular is Kubernetes.  And 
another piece you kind of have 

02:05:55.583 --> 02:05:57.659
to reinvent if somebody hasn't 
created a nice pattern for you 

02:05:57.660 --> 02:05:59.744
to reuse is the service access 
layer.  So if you

02:05:59.745 --> 02:06:05.968
want to apply some security 
policies, telemetry, capture 

02:06:05.969 --> 02:06:10.112
analytics.  Customize how your 
service is accessed, it's really

02:06:10.113 --> 02:06:14.280
 nice to have a server layer on 
top of it.  And that's what 

02:06:14.281 --> 02:06:18.402
Istio is as a service mesh.  The
 combination of all these 

02:06:18.403 --> 02:06:24.618
together: containers, 
orchestraters and a service mesh

02:06:24.619 --> 02:06:28.789
 give you a way to manage and 
deploy your apps, especially in 

02:06:28.790 --> 02:06:30.861
the  Cloud.
&gt;&gt; Yep.  Let's look at what you 

02:06:30.862 --> 02:06:35.008
have on Google Cloud as products
 to deploy your applications.  

02:06:35.009 --> 02:06:37.089
The first thing that you want to
 decide is how much 

02:06:37.090 --> 02:06:41.242
customization you want and how 
much management you want.  So 

02:06:41.243 --> 02:06:43.323
there's a spectrum.  The more 
highly managed things are, the 

02:06:43.324 --> 02:06:49.576
less customizable.  And if you 
want them customized, you have 

02:06:49.577 --> 02:06:51.692
to maintain it yourself.  So if 
you want to have things  

02:06:51.693 --> 02:06:55.854
customizable, you have compute 
engine.  So the idea of the 

02:06:57.923 --> 02:07:02.057
Compute Engine, you heard in the
 keynote, a  VM and the memory 

02:07:02.058 --> 02:07:06.213
you choose.  Once you have the 
VM, it's yours and you can do 

02:07:06.214 --> 02:07:08.301
whatever you want with it.  You 
get the machine and the 

02:07:08.302 --> 02:07:12.462
operating system with  it.
At some point you might want to 

02:07:12.463 --> 02:07:14.537
put some software on it.  One 
way of doing that is you can 

02:07:14.538 --> 02:07:18.691
install that yourself manually, 
but we also have something 

02:07:18.692 --> 02:07:22.855
called Cloud Launcher.  It's 
kind you have like a marketplace

02:07:22.856 --> 02:07:24.924
 for solutions to apply to 
Google Cloud.  So you can 

02:07:24.925 --> 02:07:29.059
install things like Mongo DB, 
framework, and there's a bunch 

02:07:29.060 --> 02:07:33.197
of other solutions from Google 
and from outside Google.  So the

02:07:33.198 --> 02:07:37.357
 ideas of Cloud Launcher is that
 with one click, you can get a 

02:07:37.358 --> 02:07:41.513
solution for the Compute Engine.
  So let me show you some of 

02:07:41.514 --> 02:07:45.678
this quickly.  Here I am nor 
Google Cloud Console.  You have 

02:07:45.679 --> 02:07:47.755
probably seen this before.  We 
have a bunch of products on 

02:07:47.756 --> 02:07:53.977
Google Cloud.  But the one we 
are interested in is the Compute

02:07:53.978 --> 02:07:58.126
 Engine.  And I can see the VMs.
  And these are the VMs I have 

02:07:58.127 --> 02:08:00.219
running.  If I want to create a 
VM, create instance and this 

02:08:00.220 --> 02:08:04.373
takes me to a new page.  I'll 
give my instance a name.  So 

02:08:04.374 --> 02:08:08.524
let's call this instance  
GDDkrakow.  And then you can 

02:08:08.525 --> 02:08:12.672
choose a zone.  So we have zones
 all over the world, but

02:08:12.673 --> 02:08:14.740
since we're in Europe, let's 
choose west.  So for machine 

02:08:14.741 --> 02:08:18.894
type, you can customize it, you 
can pick and choose how many 

02:08:18.895 --> 02:08:25.145
cores you want and how much 
memory you want from one CPU to 

02:08:25.146 --> 02:08:29.294
64 CPU.  And you can choose 
preconfigured instances.  I'm 

02:08:29.295 --> 02:08:35.512
going to choose M1 standard with
 one CPU and 4 gigs of memory.  

02:08:35.513 --> 02:08:43.816
And then choose the operating 
system.  Linux, containerized 

02:08:43.817 --> 02:08:47.958
optimized system.  And even 
Windows servers -- 2008, 12, 16.

02:08:47.959 --> 02:08:54.187
  If you want the SQL server, 
you can install that.  Choose 

02:08:54.188 --> 02:09:00.420
autoLinux instance and standard.
  And then you can allow HTTPS 

02:09:00.421 --> 02:09:04.593
and create.  And this will give 
you a VM within a few seconds.  

02:09:04.594 --> 02:09:08.746
So I have analytics running.  
You can easily access that.  

02:09:08.747 --> 02:09:10.818
Just click this button and you 
don't have to worry about keys 

02:09:10.819 --> 02:09:12.887
and everything is fully managed.
  So this will launch within a 

02:09:12.888 --> 02:09:17.031
few seconds and you can get into
 it and do all that stuff.  But 

02:09:17.032 --> 02:09:21.203
if you're a Windows person, I 
have a Windows app running here.

02:09:21.204 --> 02:09:27.456
  You can add VP into that.  And
 right from the browser, and 

02:09:27.457 --> 02:09:29.520
just enter my
password.  And then -- boom.  

02:09:29.521 --> 02:09:33.672
You're in and you can do all the
 Windows stuff that you need to 

02:09:33.673 --> 02:09:35.741
do.
So that's how you get VMs.  But 

02:09:35.742 --> 02:09:41.986
if you want to install something
 on these VMs, then there's 

02:09:41.987 --> 02:09:46.157
Cloud Launcher.  So go here.  
Cloud Launcher.  This is -- as I

02:09:46.158 --> 02:09:50.427
 mentioned before, a marketplace
 for different solutions.  You 

02:09:50.428 --> 02:09:54.605
can install WordPress with one 
click.  I'll search for asp.net.

02:09:54.606 --> 02:10:00.829
  I want to install the asp.net 
framework.  So this solution 

02:10:00.830 --> 02:10:07.075
give use a Windows server, and 
SQL express.  So just launch 

02:10:07.076 --> 02:10:13.307
compute engine, and give a name,
 choose my zone as west again.  

02:10:13.308 --> 02:10:17.489
I'll keep my machine type as it 
is, and Windows server, choose 

02:10:17.490 --> 02:10:21.642
the latest one and keep the 
default.  Keep deploy.  This 

02:10:21.643 --> 02:10:27.906
will give me a Windows server 
with IIS and SQL server express 

02:10:27.907 --> 02:10:32.058
deployed.  It will take a couple
 minutes, but it's right there.

02:10:32.059 --> 02:10:36.212
So that's that, but as we 
mentioned, virtual machines are 

02:10:36.213 --> 02:10:40.386
kind of old school now, so we 
have containers.  And how you 

02:10:40.387 --> 02:10:44.552
run containers on Google Cloud? 
 The easiest way to do that is 

02:10:44.553 --> 02:10:50.765
with App  Engine.  Take the code
 and deploy it using G Cloud.  

02:10:50.766 --> 02:10:56.968
And take the code and create a 
container and host it on 

02:10:56.969 --> 02:10:59.053
container repository and deploy 
to App Engine.  So with App 

02:10:59.054 --> 02:11:03.201
Engine you get dashboards by 
default.  You get versions.  

02:11:03.202 --> 02:11:05.270
Every time you have the 
application, you get different 

02:11:05.271 --> 02:11:09.416
versions.  You get traffic 
splitting.  So you have multiple

02:11:09.417 --> 02:11:13.582
 versions, you can split them.  
And scaling.  And you can scale 

02:11:13.583 --> 02:11:17.747
all the way to 20.  It's the 
easiest way to start with 

02:11:17.748 --> 02:11:19.842
containers on Google Cloud.  But
 at some point you might need 

02:11:19.843 --> 02:11:21.960
more control.
Sometimes you want to be able to

02:11:24.033 --> 02:11:26.138
 define multiple containers and 
you want to be able to scale 

02:11:26.139 --> 02:11:30.295
them independently.  So you 
basically want to create a 

02:11:30.296 --> 02:11:34.464
container cluster.  For that we 
have container engine.  So 

02:11:34.465 --> 02:11:38.604
container engine is basically 
managed Kubernetes.  We manage 

02:11:38.605 --> 02:11:42.748
Kubernetes for you.  And with 
one command, you can get a 

02:11:42.749 --> 02:11:46.931
Kubernetes class and a master 
and nodes and you can use the 

02:11:46.932 --> 02:11:49.013
SQL command line tool to 
schedule containers.  And we 

02:11:49.014 --> 02:11:51.081
have tools around containers.  
So we have container building 

02:11:51.082 --> 02:11:53.154
which is a way to build 
containers in the cloud really 

02:11:53.155 --> 02:11:59.374
fast.  And then we have 
container registry.  So once you

02:11:59.375 --> 02:12:03.520
 build the containers, they get 
hosted into a private space for 

02:12:03.521 --> 02:12:07.685
the project.  And once you have 
the image, you can deploy to App

02:12:07.686 --> 02:12:11.839
 Engine or you can deploy to 
Container Engine.  Anything you 

02:12:11.840 --> 02:12:13.910
want.  It's available to 
everything that you have.

02:12:13.911 --> 02:12:18.054
And then finally, my favorite is
 Cloud  Functions.  So in Cloud 

02:12:18.055 --> 02:12:24.285
Functions, you create a function
 that does some functionality 

02:12:24.286 --> 02:12:28.458
and define what triggers the 
function.  It gets triggered by 

02:12:28.459 --> 02:12:32.621
calls, or by messages, and then 
you just deploy that and don't 

02:12:32.622 --> 02:12:36.764
worry about containers or VMs.  
Everything is fully managed for 

02:12:36.765 --> 02:12:38.833
you.  Take a quick look at these
 as well.

02:12:38.834 --> 02:12:42.967
So I already deployed an App 
Engine  application.  So I'll 

02:12:42.968 --> 02:12:47.124
take a look at that.  So go to 
App Engine.  First I will click 

02:12:47.125 --> 02:12:49.194
on versions and then you can see
 that I have two versions 

02:12:49.195 --> 02:12:51.263
already  deployed.  Let's say 
this version 3 is the one  

02:12:51.264 --> 02:12:55.440
getting the traffic and it's 
being run on two instances.  

02:12:55.441 --> 02:12:57.519
Version 4 is not getting any 
traffic.  I can easily change 

02:12:57.520 --> 02:13:03.758
that so I can come here, reduce 
traffic.  I will do IP-based 

02:13:03.759 --> 02:13:07.927
traffic splitting.  I'll add my 
version and let's say this got 

02:13:07.928 --> 02:13:12.098
50%.  So now each version will 
get 50% of the traffic so I can 

02:13:12.099 --> 02:13:14.181
do my testing and make sure 
everything works.  So if we go 

02:13:14.182 --> 02:13:20.403
back here, they are both getting
 50% of the traffic.  If I go to

02:13:20.404 --> 02:13:22.475
 dashboard, this app is not 
being used, you don't see much. 

02:13:22.476 --> 02:13:26.657
 Under here you see the 
different versions and click on 

02:13:26.658 --> 02:13:28.749
the version.  And you can see 
the latency, traffic, VM 

02:13:28.750 --> 02:13:32.907
traffic.  All this stuff comes 
for free.  You can see the 

02:13:32.908 --> 02:13:37.039
instances.  So by default the 
apps run on two instances and 

02:13:37.040 --> 02:13:41.206
these are regular VMs.
You can add App Engine if you 

02:13:41.207 --> 02:13:45.366
want, but it measures for you 
and this will be auto-scaled 

02:13:45.367 --> 02:13:47.439
from two to 20 if there's a need
.  So that's kind of App Engine.

02:13:47.440 --> 02:13:53.677
  And then if you look at 
Container Engine, I can take the

02:13:53.678 --> 02:13:57.860
 same container image and upload
 into Container Engine and 

02:13:57.861 --> 02:13:59.925
manage by Kubernetes.  Here I 
have a cluster already defined. 

02:13:59.926 --> 02:14:04.083
 And look under workloads, you 
basically take your container 

02:14:04.084 --> 02:14:08.240
and put it in what's called a 
pod.  So I have a pod running 

02:14:08.241 --> 02:14:12.403
with the same app.  And once you
 have the pod, you can expose 

02:14:12.404 --> 02:14:14.483
that to the outside world using 
something called service.  With 

02:14:14.484 --> 02:14:20.685
service you get a load balancer 
and a public  IP.  If I click on

02:14:20.686 --> 02:14:22.767
 this, I have hello world.   
Exciting application.  And you 

02:14:22.768 --> 02:14:29.000
can take the same app and move 
it around from App Engine to 

02:14:29.001 --> 02:14:31.083
Container Engine easily.  What I
 really like is Cloud

02:14:35.165 --> 02:14:39.308
  Functions.  It's a hello world
 cloud function.  And if you 

02:14:39.309 --> 02:14:43.459
click on it, it's running in the
 cloud.  I don't know or care 

02:14:43.460 --> 02:14:45.528
anyway.  I can see the
trigger.  This is a triggered 

02:14:45.529 --> 02:14:49.701
function, meaning if there's a 
topic, and a message that goes 

02:14:49.702 --> 02:14:53.866
to the topic, it will be 
triggered.  I can even see the 

02:14:53.867 --> 02:14:58.011
source of it.  Here is my 
function and basically gets an 

02:14:58.012 --> 02:15:00.103
event and displayed the message.
  And you can test from here.  

02:15:00.104 --> 02:15:04.248
In here, I can send the message,
 let's say this is message.  And

02:15:04.249 --> 02:15:08.419
 then I'll say, "Hello world."  
And test the function and this 

02:15:08.420 --> 02:15:12.573
will invoke my function.  And 
when it's done, I can see the 

02:15:12.574 --> 02:15:18.811
output, everything right here.  
It's really easy and a fully 

02:15:18.812 --> 02:15:20.879
managed product.
So go back.

02:15:20.880 --> 02:15:25.019
&gt;&gt; So, thanks.  I'd like to 
briefly touch on something that 

02:15:25.020 --> 02:15:29.233
I think is largely invisible to 
most people when they're using 

02:15:29.234 --> 02:15:33.379
our Cloud Platform.  When you 
deploy one of the computing 

02:15:33.380 --> 02:15:37.538
elements that Mete just talked 
about, the data moving around 

02:15:37.539 --> 02:15:41.712
either from the outside world 
into Google's Cloud or between 

02:15:41.713 --> 02:15:43.781
systems into our Cloud is riding
 on top of the same network that

02:15:45.839 --> 02:15:49.992
 powers the seven products.  
Each with a billion users.  So 

02:15:49.993 --> 02:15:54.130
we don't have like a separate 
network where we're transporting

02:15:54.131 --> 02:15:58.298
 all the information for your 
cloud, you know, compute 

02:15:58.299 --> 02:16:02.454
elements and another network 
that we make good for our 

02:16:02.455 --> 02:16:06.622
internal use.  It's the same 
network fabric.  Extremely high 

02:16:06.623 --> 02:16:08.700
performance.  And, you know, 
it's the same network that's 

02:16:08.701 --> 02:16:12.884
serving up all those YouTube 
videos, to Gmail, Google Search,

02:16:12.885 --> 02:16:17.028
 Maps, et cetera.  And the 
reason it's so high-performance 

02:16:17.029 --> 02:16:21.165
is that Google has built its own
 private network.  Massive 

02:16:21.166 --> 02:16:26.025
internal private network.  It 
contains dedicated fiber links 

02:16:26.026 --> 02:16:28.026
around the world.  We

02:16:29.056 --> 02:16:31.056
 even own our
own undersea cables.

02:16:31.110 --> 02:16:33.191
And as a result, I mean, it's 
not just the facilities.  A ton 

02:16:33.192 --> 02:16:35.192
of

02:16:37.281 --> 02:16:41.429
 engineering work has made it be
 high performance and low 

02:16:41.430 --> 02:16:43.507
latency and you're  taking 
advantage of all that power when

02:16:43.508 --> 02:16:45.583
 you're  running your 
applications in our cloud.  

02:16:45.584 --> 02:16:51.800
Another kind of key design piece
 of our network is that we built

02:16:51.801 --> 02:16:58.031
 it so that when users want to 
access our cloud platform, App 

02:16:58.032 --> 02:17:02.196
Engine apps or Compute Engine or
 containers or any of that 

02:17:02.197 --> 02:17:06.370
stuff, we have it designed so 
that we route their connections 

02:17:06.371 --> 02:17:08.431
to the closest point of presence
 to that user.  The idea being 

02:17:08.432 --> 02:17:12.580
that we want to get them on this
 high-speed Google backbone as 

02:17:12.581 --> 02:17:14.655
fast as possible so that the 
bulk of the communication is 

02:17:14.656 --> 02:17:18.817
taking place over this very 
optimized network.  And as a 

02:17:18.818 --> 02:17:25.053
result, we not only get a very 
high throughput and low latency,

02:17:25.054 --> 02:17:29.221
 but we get very predictable 
response time.  And this is a 

02:17:29.222 --> 02:17:33.366
little map of the extension of 
our data centers around the 

02:17:33.367 --> 02:17:37.506
world.  As you can see, we're in
 a lot of areas, but we're 

02:17:37.507 --> 02:17:41.657
constantly trying to expand
the footprint to accommodate 

02:17:41.658 --> 02:17:43.745
platform needs all around the 
world.  We also have several 

02:17:43.746 --> 02:17:47.896
higher end  networking 
capabilities which I'm not going

02:17:47.897 --> 02:17:52.065
 into today.  But we will have 
resources at the end so you can 

02:17:52.066 --> 02:17:54.532
dive into those if you're 
interested.

02:17:52.066 --> 02:17:56.255
So we've talked about computing 
and talked a little bit about 

02:17:56.256 --> 02:18:02.482
networking.  And now I want to 
turn to how you store your data.

02:18:02.483 --> 02:18:04.553
  Something everybody has to -- 
everybody application has to do.

02:18:06.635 --> 02:18:08.699
  And I'm going to try to cover 
everything you can do in that 

02:18:08.700 --> 02:18:14.926
domain in one slide.  So it's 
going to get a little bit busy. 

02:18:14.927 --> 02:18:16.988
 We have several products.  It's
 really like tools in a tool 

02:18:16.989 --> 02:18:21.124
kit.  And it just -- some really
 powerful options, but it's just

02:18:21.125 --> 02:18:27.350
 a matter of knowing what to use
 for what situation.  The first 

02:18:27.351 --> 02:18:31.496
is in memory storage.  This is 
caching for your app.  Think of 

02:18:31.497 --> 02:18:39.823
Redis or mem cache, those 
services.  And then the 

02:18:39.824 --> 02:18:48.100
traditional SQL-based databases.
  And Cloud SQL, think of 

02:18:48.101 --> 02:18:54.303
managed MySQL or postgres.  It's
  backed up, but you're thinking

02:18:54.304 --> 02:18:58.448
 about database servers at the 
end of the day.  And then 

02:18:58.449 --> 02:19:02.596
Spanner which takes it up a 
level which you can think about 

02:19:02.597 --> 02:19:04.676
just the database independent of
 the service.  It's database as 

02:19:04.677 --> 02:19:08.879
a service with a lot of other 
nice features as well.  And then

02:19:08.880 --> 02:19:15.141
 on the no
SQL side, Cloud Datastore, a 

02:19:15.142 --> 02:19:19.268
hierarchical store that comes 
out of the App Engine world but 

02:19:19.269 --> 02:19:23.442
now is generalized and can be 
used anywhere.  And Cloud 

02:19:25.523 --> 02:19:29.687
Bigtable similarly schema less 
and no SQL.  Suited for 

02:19:29.688 --> 02:19:33.841
high-capacity storage jobs and 
for very high-volume read and 

02:19:33.842 --> 02:19:38.009
write scenarios like an event 
log or page views and, you know,

02:19:38.010 --> 02:19:40.101
 detailed telemetry 
applications.

02:19:42.181 --> 02:19:46.344
We have an object store called 
Google Cloud  Storage.  This is 

02:19:46.345 --> 02:19:48.424
one of the very first products 
that came out as part of the 

02:19:48.425 --> 02:19:52.594
Google Cloud Platform.  It was 
the first product I work on back

02:19:52.595 --> 02:19:58.820
 in 2011.  It's a very powerful 
binary object storage facility. 

02:19:58.821 --> 02:20:02.964
 Global scope, replication, and 
strong consistency.  Very nice 

02:20:02.965 --> 02:20:09.203
features.  And then we have 
block storage device.  We call 

02:20:09.204 --> 02:20:13.368
these persistent disk.  This is 
a network device for attaching 

02:20:13.369 --> 02:20:17.520
you to your VMs.  And the idea 
is it's network resident and 

02:20:17.521 --> 02:20:21.671
lives on its own life cycle.  So
 if your VM goes down, or you 

02:20:21.672 --> 02:20:25.810
delete the VM, your data is 
still persistent on that disk.  

02:20:25.811 --> 02:20:29.960
And you can get those in SSD 
format or  spinning disks.  Lots

02:20:29.961 --> 02:20:34.102
 more to say about that, but I'm
 trying -- for time -- get 

02:20:34.103 --> 02:20:40.354
through it.  And, of course, Big
 Query which we'll see more.  

02:20:40.355 --> 02:20:44.477
That's a good way to store data 
as well as analyze it 

02:20:44.478 --> 02:20:46.555
interactively.
&gt;&gt; That's a lot of options.  But

02:20:46.556 --> 02:20:50.701
 Spanner -- can you tell us 
what's special about Spanner?

02:20:50.702 --> 02:20:54.855
&gt;&gt; Funny you should ask.  I 
actually have a slide about 

02:20:54.856 --> 02:20:56.932
Spanner, Mete, thank you.  And 
it would have been good if I 

02:20:56.933 --> 02:21:03.185
didn't advance to it early.   So
 -- yeah.  Cloud

02:21:07.273 --> 02:21:09.357
 Spanner is very new.  It was 
announced earlier this year.  

02:21:09.358 --> 02:21:13.510
It's a really interesting new 
database type.  It's basically a

02:21:15.609 --> 02:21:19.736
 managed, unlimited scaling 
effectively database as a 

02:21:19.737 --> 02:21:23.881
service in the cloud.  Now, 
whereas traditional relational 

02:21:23.882 --> 02:21:28.048
databases are very strong in 
terms of asset compliance and 

02:21:28.049 --> 02:21:32.208
strong consistency and data 
semantics, but they are often 

02:21:32.209 --> 02:21:34.290
difficult to scale.  A lot of 
times you'll see companies 

02:21:34.291 --> 02:21:40.516
having to shard multiple 
concurrent instances of an

02:21:44.592 --> 02:21:48.755
 ArcVMS.  Traditional no SQL is 
the inverse of that.  Scales 

02:21:48.756 --> 02:21:50.835
easily.  You add additional 
nodes to a cluster.  But you 

02:21:50.836 --> 02:21:54.999
often have consistency 
challenges trying to make sure 

02:21:55.000 --> 02:21:59.149
everything is strongly 
consistent and updates are seen 

02:21:59.150 --> 02:22:03.302
at the same time.  Spanner gives
 you the best of both worlds.  

02:22:03.303 --> 02:22:07.480
The scalability of a no-SQL 
system and gives you the

02:22:07.481 --> 02:22:09.568
semantics of a traditional 
relationship database management

02:22:11.650 --> 02:22:13.717
.
And I would like to actually 

02:22:13.718 --> 02:22:17.886
show you real quick what it 
looks like to work with Spanner.

02:22:17.887 --> 02:22:22.016
  So this is the same platform 
-- or same console,  rather, 

02:22:22.017 --> 02:22:30.362
that Mete was just showing you. 
 But I'm in the Spanner domain. 

02:22:30.363 --> 02:22:34.523
 We create instances.  Instances
 are simply collections of 

02:22:34.524 --> 02:22:36.651
databases.  But they're 
completely abstract.  I don't 

02:22:36.652 --> 02:22:38.730
have to think about how the 
software is configured or 

02:22:38.731 --> 02:22:42.898
anything like  that.  Within the
 instance, I create a database. 

02:22:42.899 --> 02:22:47.041
 So I'm going to take this sort 
of imagery example that a 

02:22:47.042 --> 02:22:49.136
university administer -- and I 
need to keep track of the data 

02:22:49.137 --> 02:22:53.317
for all the students in the 
university.  So I've created a 

02:22:53.318 --> 02:22:57.472
database I call University.  And
 I have two tables in that 

02:22:57.473 --> 02:22:59.548
database -- departments -- so 
these are the different subjects

02:22:59.549 --> 02:23:03.697
 areas.  They have a department 
ID and a budget and a name.  And

02:23:03.698 --> 02:23:07.856
 students.  So these are an 
enumeration of all the students.

02:23:07.857 --> 02:23:11.997
  So I have a department ID, 
which is inherited.  So every 

02:23:11.998 --> 02:23:14.070
student affiliated with a 
department.  And

02:23:14.071 --> 02:23:20.293
an SID, the student ID, you need
 key for this table.  And a 

02:23:20.294 --> 02:23:22.374
student name.  Now, one of the 
nice things about Spanner, I can

02:23:24.454 --> 02:23:26.531
 dynamically change the schema. 
 Let's say I want to add a 

02:23:26.532 --> 02:23:32.771
column to this table.  So I'll 
say edit schema.  Anybody have 

02:23:32.772 --> 02:23:34.836
something they would like to add
 to the student record?  What's 

02:23:34.837 --> 02:23:39.019
the -- what's the attribute that
 causes college students the 

02:23:39.020 --> 02:23:43.166
most stress?
&gt;&gt; GPA.

02:23:43.167 --> 02:23:51.464
&gt;&gt; Let's add a GPA column.  
Let's make it a float.  Add that

02:23:51.465 --> 02:23:57.731
 and say save.  It's now 
updating the schema.  There can 

02:23:57.732 --> 02:24:01.879
be tons of data there.  It's 
going to update all the data we 

02:24:01.880 --> 02:24:06.032
have now as well as make it 
possible for me to store new 

02:24:06.033 --> 02:24:08.113
data.  And the database is 
continuing to run.  There's no 

02:24:08.114 --> 02:24:12.256
down  time.  So it's not 
stopping ongoing operations.  

02:24:12.257 --> 02:24:14.334
It's continuing to request as we
 speak.  And while it's doing 

02:24:14.335 --> 02:24:18.528
that schema upgrade, I'm going 
to show you another thing.  

02:24:18.529 --> 02:24:22.675
Let's say I'm wildly successful 
with my new database and I have 

02:24:22.676 --> 02:24:24.763
more load than I can possibly 
take.  And I just told you 

02:24:24.764 --> 02:24:28.926
earlier that it's really 
scalable.  So what I can do is 

02:24:28.927 --> 02:24:37.214
go to the instance page.  Maybe.
  There we go.  And I can say, 

02:24:37.215 --> 02:24:41.360
edit instance.  And I can simply
 change the number of nodes from

02:24:41.361 --> 02:24:49.682
 one to three.
Save.  And I now have tripled my

02:24:49.683 --> 02:24:55.927
 capacity that easily.  I now 
have three times as much as 

02:24:55.928 --> 02:25:00.075
database capacity as I did 
before.  That's -- I think the 

02:25:00.076 --> 02:25:04.233
schema update is done.  You can 
see.  And being able to turn 

02:25:04.234 --> 02:25:08.401
that knob is really one of the 
major advantages of Spanner's 

02:25:08.402 --> 02:25:12.568
scalability.  All right?
&gt;&gt; So now let's talk about big 

02:25:12.569 --> 02:25:16.719
data in the last four minutes 
that we have.  So big data at 

02:25:16.720 --> 02:25:22.970
Google started with MapReduce.  
Back in the day we were  trying 

02:25:22.971 --> 02:25:25.041
to preserve data.  And there was
 a paper on 

02:25:29.127 --> 02:25:33.302
 MapReduce that explained how to
 take lots of data and break it 

02:25:33.303 --> 02:25:35.388
into small chunks and map them 
to different machines and apply 

02:25:35.389 --> 02:25:41.603
an aggregation and get a result 
back.  After MapReduce, there 

02:25:41.604 --> 02:25:45.744
was a lot of innovation at 
Google.  These were either 

02:25:45.745 --> 02:25:51.965
papers or internal 
implementations that people 

02:25:51.966 --> 02:25:56.121
couldn't use outside of Google. 
 We have papers, we have things 

02:25:56.122 --> 02:26:02.348
like Spark and Hive.  And 
because of the split in 

02:26:02.349 --> 02:26:04.432
innovation, we have two products
 on Google Cloud.  We have 

02:26:06.517 --> 02:26:10.679
Dataflow, basic the way the 
state of the art pipeline that 

02:26:10.680 --> 02:26:12.757
came up at Google and now we are
  making available to people.  

02:26:12.758 --> 02:26:14.830
But at the same time, if you are
 using Hadoop

02:26:18.907 --> 02:26:25.129
 and Spark, there's Cloud  
Dataproc.  It's a way to run 

02:26:25.130 --> 02:26:29.270
jobs on Google Cloud.
&gt;&gt; So if we think about the big 

02:26:29.271 --> 02:26:33.454
data world, the typical thing we
 want to do is have a processing

02:26:33.455 --> 02:26:35.560
 pipeline.  So I'm just going to
 briefly walk through that 

02:26:35.561 --> 02:26:39.706
pipeline.  The first phase would
 be capturing your data.  And 

02:26:39.707 --> 02:26:41.777
we'll come up with an example of
 how you might do this.  Imagine

02:26:43.852 --> 02:26:50.121
 you wanted to track all the 
activity on Wikipedia.  You had 

02:26:50.122 --> 02:26:54.281
an event firing, HTTP post or 
something.  And any time they 

02:26:54.282 --> 02:27:00.499
pulled up the PDF, Cloud Pub/Sub
 is a high-capacity repository 

02:27:00.500 --> 02:27:04.640
and it's a message queue and can
 publish the events to any 

02:27:04.641 --> 02:27:10.833
number of downstream consumers. 
 We might feed that downstream 

02:27:10.834 --> 02:27:14.986
into dataprep, a way to cleanse 
your data and add semantic 

02:27:14.987 --> 02:27:21.202
checking and add things.  And 
that might speed too dataflow, a

02:27:21.203 --> 02:27:23.278
 very flexible pipeline building
 tool.  You can use Apache

02:27:27.397 --> 02:27:31.536
 Beam there.  And it can go on 
large batches of data or 

02:27:31.537 --> 02:27:33.609
streaming data so you could use 
it in sort of a  real-time 

02:27:33.610 --> 02:27:37.753
fashion.
The output of that would be the 

02:27:37.754 --> 02:27:39.831
process data.  We want to store 
in one of the storage facilities

02:27:39.832 --> 02:27:43.972
 I mentioned earlier.  We could 
do real-time analysis on it 

02:27:43.973 --> 02:27:50.199
using big query, I'll show you 
an example of that in a second. 

02:27:50.200 --> 02:27:54.350
 And might want to take it and 
work on it interactively in a 

02:27:54.351 --> 02:28:00.552
user friendly way.  And we have 
the ability to use Jupiter 

02:28:00.553 --> 02:28:06.819
notebooks to play with the data,
 and Data Studio, a nice tool 

02:28:06.820 --> 02:28:10.996
for building interactive 
dashboards and other  

02:28:10.997 --> 02:28:13.077
visualizations.
So let's hop over to the console

02:28:13.078 --> 02:28:15.147
 again.  This is a different 
part of the console.  But this 

02:28:15.148 --> 02:28:21.366
is for running Big Query.  And I
 have preloaded a month's worth 

02:28:21.367 --> 02:28:27.587
of Wikipedia page views into 
this particular database.  Here 

02:28:27.588 --> 02:28:31.735
is my query.  I can format it  
nicely.  I'm going to turn off 

02:28:31.736 --> 02:28:35.863
use cached results.  I don't 
want to cheat.  It will come 

02:28:35.864 --> 02:28:40.027
back blindingly fast, but won't 
be true.  I want to run this 

02:28:40.028 --> 02:28:44.195
query.  What this is doing is 
scanning every line in the 

02:28:44.196 --> 02:28:46.276
database and looking for 
occurrences of "Krakow."  

02:28:46.277 --> 02:28:50.443
Because the O can be written in 
different ways, depending on 

02:28:50.444 --> 02:28:54.566
language, I've used a regular 
expression to avoid that.

02:28:54.567 --> 02:28:58.704
So not only am I scanning every 
row in the table, I'm running a 

02:28:58.705 --> 02:29:02.865
regular expression on every 
single row in this table.  I got

02:29:02.866 --> 02:29:09.103
 any output.  And if we look at 
the job information, we see that

02:29:11.191 --> 02:29:15.341
 it's scanned almost 50 
gigabytes of data.  And the 

02:29:15.342 --> 02:29:19.478
query explanation shows the 
number of rows.  It scanned  1.8

02:29:21.550 --> 02:29:25.725
 billion -- with a B -- didn't 
just scan them  all, ran a 

02:29:25.726 --> 02:29:29.879
regular expression on them.  I 
didn't mention the punchline, it

02:29:29.880 --> 02:29:34.034
 was under 5 seconds.  In under 
5 seconds, we ran regular 

02:29:34.035 --> 02:29:40.296
expression queries on 1.8 
billion rows.  Hopefully that 

02:29:40.297 --> 02:29:44.419
gives you an idea of the speed 
you'll get with big query.

02:29:44.420 --> 02:29:48.585
&gt;&gt; And last, but not least, 
machine learning.  Machine 

02:29:48.586 --> 02:29:52.733
learning is big and this graph 
shows why.  This is the model 

02:29:52.734 --> 02:29:54.814
initial learning at Google and 
all the different products that 

02:29:54.815 --> 02:29:58.968
use machine learning.  You can 
see exponential growth in the 

02:29:58.969 --> 02:30:03.116
last few  years.  When it comes 
to using machine learning in 

02:30:03.117 --> 02:30:05.200
your applications, you have two 
ways of using machine learning. 

02:30:05.201 --> 02:30:09.350
 The easy way is to let someone 
build a new model and give you 

02:30:09.351 --> 02:30:11.419
an API and use that machine 
learning for your application.  

02:30:11.420 --> 02:30:17.659
So you're not really building 
machine learning yourself, 

02:30:17.660 --> 02:30:19.660
you're consuming someone else

02:30:21.749 --> 02:30:25.899
's machine learning model.  And 
sometimes the model is not good 

02:30:25.900 --> 02:30:30.064
enough or you need to customize 
things.  You need to create your

02:30:30.065 --> 02:30:34.218
 own machine model.  You can 
create and serve your own 

02:30:34.219 --> 02:30:38.374
machine model.  So in terms of 
using models at Google Cloud, we

02:30:38.375 --> 02:30:42.512
 have machine learning APIs for 
the different models over the 

02:30:42.513 --> 02:30:48.749
years.  Speech API for speech, 
and vision API for vision 

02:30:48.750 --> 02:30:52.928
recognition.  We have built
these over the years and we're 

02:30:52.929 --> 02:30:55.002
making it available to you with 
an API call.  I want to show a 

02:30:55.003 --> 02:31:03.346
quick demo on an API.  So in 
vision API, you pass an image 

02:31:03.347 --> 02:31:07.482
and then you get information 
about the image using machine 

02:31:07.483 --> 02:31:09.553
learning.  Here I have a picture
 of a cute cat.  Sorry for the 

02:31:09.554 --> 02:31:13.706
dog lovers, I don't have a dog 
picture.  But in this one, I 

02:31:13.707 --> 02:31:17.850
pass this image to vision API 
and then I get a JSON back.  

02:31:17.851 --> 02:31:21.996
Look at the JSON in a graphical 
way, the machine figured out 

02:31:21.997 --> 02:31:26.154
this is a cat.  And even figured
 out this is a British 

02:31:26.155 --> 02:31:28.230
short-haired cat.  From there, 
you can extract the color, 

02:31:28.231 --> 02:31:32.430
whether it's an adult or medical
 image.  If you pass in more 

02:31:32.431 --> 02:31:36.579
complicated things, like a 
stadium, it figures out it's a 

02:31:36.580 --> 02:31:40.767
baseball stadium.  It picks up 
the text from different places. 

02:31:40.768 --> 02:31:44.920
 It even picks up people's 
expressions.  It picked up this 

02:31:44.921 --> 02:31:49.085
guy and the fact that he is 
joyful.  And even knows the 

02:31:49.086 --> 02:31:51.159
location.  You can see the kinds
 of things you can get from 

02:31:51.160 --> 02:31:53.251
vision API.
&gt;&gt; Thanks.  So underlying all of

02:31:55.322 --> 02:31:59.461
 those products that you saw, 
that exponential curve that Mete

02:31:59.462 --> 02:32:05.700
 just showed, is TensorFlow.  
And for those who have 

02:32:05.701 --> 02:32:11.953
encountered it, it's a framework
 for building machine learning 

02:32:11.954 --> 02:32:16.105
models that Google open sourced 
almost two years ago.  It's 

02:32:16.106 --> 02:32:20.254
become a communal open source 
project.  Tremendous 

02:32:20.255 --> 02:32:24.425
contributions and tremendous 
popularity.  It's particularly  

02:32:24.426 --> 02:32:28.580
well-suited for building complex
 deep learning  models and 

02:32:28.581 --> 02:32:32.728
neural networks and those sorts 
of  things.  And when you start 

02:32:32.729 --> 02:32:38.949
to get into that domain, you 
really need power.  You need 

02:32:38.950 --> 02:32:41.010
computational  power.  It's not 
one of those models you can just

02:32:41.011 --> 02:32:45.157
 run on the laptop or something.
  And that's where Cloud Machine

02:32:45.158 --> 02:32:49.298
 Learning Engine comes in.  We 
have built this product to make 

02:32:49.299 --> 02:32:53.431
it really easy to build and 
serve models -- TensorFlow 

02:32:53.432 --> 02:32:55.501
models -- in the cloud.  So the 
idea here is you get a fully-

02:32:57.581 --> 02:32:59.660
managed infrastructure.  You 
build your model prototype, 

02:32:59.661 --> 02:33:01.752
perhaps on your
workstation or wherever.  And 

02:33:01.753 --> 02:33:05.914
then you upload it to the cloud 
and you'll benefit from very 

02:33:05.915 --> 02:33:08.027
optimized environment for 
training and for serving your 

02:33:08.028 --> 02:33:14.266
requests.
The other advantage you get is 

02:33:14.267 --> 02:33:18.404
the TensorFlow processing unit, 
which is optimized hardware we 

02:33:18.405 --> 02:33:26.700
have built ourselves, custom 
ASICs that do the Tensor math 

02:33:26.701 --> 02:33:28.778
faster than we have been able to
 do in the  past.  The result of

02:33:28.779 --> 02:33:32.929
 all this is that we're making 
it easier for people to build a 

02:33:32.930 --> 02:33:35.005
complex model so that you can 
really focus on the model and 

02:33:35.006 --> 02:33:41.212
not worry about things like, 
where do I run it?  How do 

02:33:41.213 --> 02:33:49.529
gigabytes of the CPUs I need?  
How do I get the  GP   Us?

02:33:51.611 --> 02:33:53.710
  Coordinate parallel processing
?  You can focus on your own 

02:33:53.711 --> 02:33:55.776
model.
&gt;&gt; That's it.  That's a lot of 

02:33:55.777 --> 02:33:59.947
information.   The main page is 
cloud.google.com.  But there's 

02:33:59.948 --> 02:34:04.104
other links as well.  We have a 
free trial if you want to try it

02:34:04.105 --> 02:34:10.353
 out, it's 
cloud.google.com/free.  You get 

02:34:10.354 --> 02:34:14.501
to try for free.  See what you 
like and don't like.

02:34:14.502 --> 02:34:18.663
&gt;&gt; That's the best way to learn.
  We're trying to tell you what 

02:34:18.664 --> 02:34:22.831
it's all about.  But learn but 
doing is a great way to go.  

02:34:22.832 --> 02:34:26.968
Avail yourself of the three 
tier.  Try some things out, try 

02:34:26.969 --> 02:34:29.039
building something.  We think 
you'll have a lot of fun.  And 

02:34:29.040 --> 02:34:31.138
maybe you'll build the next 
amazing application.  And with 

02:34:31.139 --> 02:34:33.223
that -- thank you very much.
&gt;&gt; Thank you.

02:34:55.372 --> 02:34:57.372
[ Applause ]

02:38:54.897 --> 02:38:59.051
This is a captioning test.  
Testing testing testing, this is

02:38:59.052 --> 02:39:01.052
 a captioning test.  

02:40:41.703 --> 02:40:43.771
testing.  
FOERFS

02:44:53.502 --> 02:44:59.734
Thank you for joining us for 
this exciting talk about 

02:44:59.735 --> 02:45:05.998
Kubernetes and the Container 
Cloud.  We will talk about how 

02:45:05.999 --> 02:45:14.322
to deploy Kubernetes at FlixBus.
I'm also a Google Cloud

02:45:16.439 --> 02:45:18.524
 developer, so we understand 
ourselves as software developers

02:45:18.525 --> 02:45:22.690
 with a license to speak, or a 
way that I like to introduce 

02:45:22.691 --> 02:45:26.834
myself is the bi-directional 
interface between you guys, who 

02:45:26.835 --> 02:45:28.835
develop

02:45:30.922 --> 02:45:35.060
 on our platform and the 
software engineers at Google 

02:45:35.061 --> 02:45:37.144
that develop the products.  So 
please reach out to us with good

02:45:39.215 --> 02:45:43.365
 and bad feedback so we can 
improve our products.

02:45:43.366 --> 02:45:45.433
Let's go back a little bit in 
the history, some of you might 

02:45:45.434 --> 02:45:47.434
remember 

02:45:49.709 --> 02:45:55.937
these, I have one of these here,
 the flopy disks, and that is 

02:45:55.938 --> 02:46:02.164
what we used in the '80s and 
'90s to install operating 

02:46:02.165 --> 02:46:08.407
systems and things like Word 
Perfect on machines.  And you 

02:46:08.408 --> 02:46:14.655
basically had your machine and 
your programs all on that.

02:46:14.656 --> 02:46:18.813
And fast forward, today, it is 
not that easy anymore.  We live 

02:46:18.814 --> 02:46:22.971
in a mobile world and everyone 
wants access to everything at 

02:46:22.972 --> 02:46:25.055
any time, if you develop a 
really popular app, you want to 

02:46:25.056 --> 02:46:29.212
scale the demand based on, like,
 if people are waking up, or 

02:46:29.213 --> 02:46:37.548
throughout the day, or playing 
throughout the coffee and lunch 

02:46:37.549 --> 02:46:41.698
break.  Applications look like 
this, you have multiservices, 

02:46:41.699 --> 02:46:45.883
you need load balancing and 
things like that.  We heard 

02:46:45.884 --> 02:46:50.025
about the storage options we had
 in the Google Cloud platform we

02:46:50.026 --> 02:46:52.096
 had before. 
And as a developer, myself, I 

02:46:52.097 --> 02:46:54.171
don't want to really deal with 
operating that, I don't want to 

02:46:54.172 --> 02:46:58.343
look at, like, is my app still 
running, do I have to move my 

02:46:58.344 --> 02:47:00.419
app from A to B because I do 
maintenance, or things like 

02:47:00.420 --> 02:47:04.568
that.  All I really care about 
is adding more features and 

02:47:04.569 --> 02:47:08.727
innovating and pushing it out to
 the users as fast as possible.

02:47:08.728 --> 02:47:12.864
So, how can we do that? So if we
 look at a little bit of the 

02:47:12.865 --> 02:47:19.078
history how apps work, and the 
apps we are deplaying -- 

02:47:19.079 --> 02:47:23.230
deploying on machines, basically
 on hardware, back in the days, 

02:47:23.231 --> 02:47:27.371
we started with installing the 
operating system directly on 

02:47:27.372 --> 02:47:29.445
your physical machine and adding
 all the apps and dependencies 

02:47:29.446 --> 02:47:35.684
of the apps to this machine.  
And now, usually one app might 

02:47:35.685 --> 02:47:39.828
not have exhausted that machine,
 you will add multiple apps to 

02:47:39.829 --> 02:47:41.907
that machine and they might 
interfere.

02:47:41.908 --> 02:47:46.090
And you know the term, never 
change a running system, that is

02:47:48.148 --> 02:47:50.223
 from the status.  When you have
 it running, you don't want to 

02:47:50.224 --> 02:47:54.362
touch it.  That hinders 
innovation and rolling out new 

02:47:54.363 --> 02:47:56.458
features. 
So, to get a little bit more 

02:47:56.459 --> 02:48:00.599
isolation between your 
applications and to make it a 

02:48:00.600 --> 02:48:04.754
little bit safer in terms of 
iterating to new versions, 

02:48:04.755 --> 02:48:08.947
there's a new thing that came 
out a decade ago, maybe a little

02:48:08.948 --> 02:48:15.193
 bit more than that, where we 
lookeded at, okay, how can we 

02:48:15.194 --> 02:48:17.267
not disrupt the physical 
hardware and run the operating 

02:48:17.268 --> 02:48:23.534
system in a virtual environment 
and have more than one on a 

02:48:23.535 --> 02:48:27.692
virtual machine? That's where 
virtual machines came in.  But 

02:48:27.693 --> 02:48:29.760
this virtual machine still had 
an operating system, you still 

02:48:29.761 --> 02:48:33.925
had to install patches for 
security and things like that. 

02:48:33.926 --> 02:48:36.001
So this took a while, if you 
wanted to iterate, if you wanted

02:48:38.072 --> 02:48:40.150
 to start up a new version of 
your application, it still took,

02:48:40.151 --> 02:48:46.371
 like, a minute to start up this
 operating system, so it took 

02:48:46.372 --> 02:48:48.460
quite some time if you had to 
react to the demands in your 

02:48:48.461 --> 02:48:50.553
applications. 
And now, the new way to do 

02:48:50.554 --> 02:48:56.779
things is actually to go another
 layer above and really 

02:48:56.780 --> 02:48:58.875
encapsulating all of the things 
you really need for the 

02:48:58.876 --> 02:49:03.037
application and sharing more of 
what you had before.  So if you 

02:49:03.038 --> 02:49:07.243
look more, you had the operating
 system and the kernel that you 

02:49:07.244 --> 02:49:11.394
actually can share, and you have
 the container that we package 

02:49:11.395 --> 02:49:13.476
our application in the 
container.  It is pretty much 

02:49:13.477 --> 02:49:17.637
just running as a process in 
your operating system.  And with

02:49:17.638 --> 02:49:21.792
 this, it is super lightweight 
and can be started and stopped 

02:49:21.793 --> 02:49:25.949
within seconds.
And now, I have all of these 

02:49:25.950 --> 02:49:30.122
containers, which enable me to 
innovate and roll out changes 

02:49:32.204 --> 02:49:34.281
quickly.  But as I mentioned 
before, applications are 

02:49:34.282 --> 02:49:36.351
complex.  So what I wanted to 
do, I want a system that helps 

02:49:36.352 --> 02:49:42.569
me to run all of these 
containers.  And that is where 

02:49:42.570 --> 02:49:44.647
Kubernetes comes into play.  
Kubernetes was inspired by how 

02:49:44.648 --> 02:49:48.796
we are running containers inside
 of Google.  We are running 

02:49:48.797 --> 02:49:52.933
billions of containers, starting
 and stopping them, every week. 

02:49:57.092 --> 02:49:59.166
containers in Google in a system
 that is called bulk.

02:49:59.167 --> 02:50:03.331
And we did not want to bore you,
 there is technical depth, but 

02:50:03.332 --> 02:50:09.546
what we wanted to do, out of 
what we learned building this, 

02:50:09.547 --> 02:50:11.650
we wanted to show the things 
that we learned to manage 

02:50:13.724 --> 02:50:15.798
containers, and that is how 
Kubernetes first started from 

02:50:15.799 --> 02:50:19.943
scratch in Google and was 
open-sourced two years ago, and 

02:50:19.944 --> 02:50:21.944
then was one of

02:50:24.045 --> 02:50:26.117
 the founding -- 
was the founding project for the

02:50:26.118 --> 02:50:28.200
 cloud native computing 
computation. 

02:50:28.201 --> 02:50:34.416
And what Kubernetes does, it 
handles failures, it manages 

02:50:34.417 --> 02:50:36.503
your containers, and there's a 
couple core prince

02:50:40.588 --> 02:50:44.740
  principals for us that are 
important in running Kubernetes.

02:50:46.815 --> 02:50:50.990
 we don't want you to force you 
to re-write your applications.  

02:50:50.991 --> 02:50:53.062
Your You want it as easy as 
possible to have your 

02:50:53.063 --> 02:50:57.221
applications and cull in 
Kubernetes.  So containerize 

02:50:57.222 --> 02:51:01.371
them, and once it is 
containerize, your containers 

02:51:01.372 --> 02:51:05.533
don't need to be special, they 
can just run by themselves with 

02:51:05.534 --> 02:51:09.667
the Docker engine.
And the next thing, we didn't 

02:51:09.668 --> 02:51:11.749
want to couple parts in 
Kubernetes.  If you wanted to 

02:51:11.750 --> 02:51:15.875
change those things, if united 
to change the schedule or things

02:51:15.876 --> 02:51:20.020
 like that, you can go and check
 out the Kubernetes repository 

02:51:20.021 --> 02:51:22.110
in GitHub and just change the 
schedule as you like it. 

02:51:22.111 --> 02:51:26.274
So it is really about being open
 and being able to have everyone

02:51:26.275 --> 02:51:30.405
 who uses this system to modify 
it in a way that they want to. 

02:51:30.406 --> 02:51:32.466
And really, what is really 
really important, what I like to

02:51:32.467 --> 02:51:38.741
 talk about, is that Kubernetes 
is about running applications in

02:51:38.742 --> 02:51:42.878
 a declarative way, versus an 
imperative way.  And that means,

02:51:42.879 --> 02:51:47.009
 you cell Kubernetes how the 
landscape should look like, but 

02:51:47.010 --> 02:51:49.091
you don't tell it how to get 
there, Kubernetes will figure it

02:51:49.092 --> 02:51:55.293
 out by itself.  And with new 
versions of Kubernetes, you get 

02:51:55.294 --> 02:51:59.436
how to make this even more 
efficient. 

02:51:59.437 --> 02:52:03.599
And another important part for 
Kubernetes is supportability, 

02:52:03.600 --> 02:52:05.670
you can run it on any public 
Google Cloud, we make it very 

02:52:05.671 --> 02:52:11.891
easy to get started, and it is 
actually my opinion the easiest 

02:52:11.892 --> 02:52:16.031
way to get started, and you can 
also run it on things like this.

02:52:16.032 --> 02:52:24.297
And this is the a Raspberry Pi 
cluster, I

02:52:26.375 --> 02:52:30.530
 installed Kubernetes on this, 
and then I can pretty much play 

02:52:30.531 --> 02:52:34.673
live Chaos Monkey on this Pi 
cluster.  If you want to learn 

02:52:34.674 --> 02:52:36.749
Kubernetes, this is a good bay 
to start. 

02:52:36.750 --> 02:52:40.922
And the core concepts to run 
KubernetesKubernetes in the 

02:52:40.923 --> 02:52:45.092
containers are what I want to 
touch on in this session.  First

02:52:45.093 --> 02:52:51.313
 one, I want to focus on, is 
pods.  That is a small group of 

02:52:53.400 --> 02:52:55.476
tightly couples containers, it 
moves through the cluster and 

02:52:55.477 --> 02:53:01.736
gets an IP, you should never 
talk to it because a pod can 

02:53:01.737 --> 02:53:05.890
start and die at any time.
And now, to make sure that there

02:53:05.891 --> 02:53:10.075
 are always as many pods 
available as you declared in 

02:53:10.076 --> 02:53:16.321
your configuration files, we 
have replicas, or deployments.  

02:53:16.322 --> 02:53:20.469
And it will say, I want to have 
5 pods of this kind, and the 

02:53:20.470 --> 02:53:24.625
replicas will make sure that 
there are only five pods of this

02:53:24.626 --> 02:53:26.694
 time. 
And to make it accessible and to

02:53:26.695 --> 02:53:28.757
 be able to talk to these pods, 
you use services.  And service 

02:53:28.758 --> 02:53:32.908
is pretty much a load balance 
over the pods that you have 

02:53:34.978 --> 02:53:39.142
available.  And it routes the 
travel to the  traffic to the 

02:53:39.143 --> 02:53:43.324
pods that are available. 
And the service and the replica 

02:53:45.416 --> 02:53:47.496
set, they want to know what they
 are responsible for.  And that 

02:53:47.497 --> 02:53:51.654
is where labels come into play, 
it is an orthoginal set on top 

02:53:51.655 --> 02:53:57.876
of this that you can attach to 
any API set in Kubernetes and 

02:53:57.877 --> 02:54:02.038
run on top of this.  So it runs 
on a set of labels to know which

02:54:02.039 --> 02:54:06.191
 pods it is responsible for, or 
a service has a set of labels 

02:54:06.192 --> 02:54:10.337
can matches to see what kind of 
pods to route traffic to. 

02:54:10.338 --> 02:54:14.476
But this is a lot of words, and 
I like living on the edge, so I 

02:54:14.477 --> 02:54:16.560
actually like to show you a 
little live demo. 

02:54:16.561 --> 02:54:22.799
And now, every live demo has to 
start with some kind of, like, 

02:54:22.800 --> 02:54:26.950
what I want to show or run.  So 
in this case, I hope that it is 

02:54:26.951 --> 02:54:33.174
readable, I have a Go App, 
actually.  My language of choice

02:54:33.175 --> 02:54:35.266
 nowadays is go, it is simple 
and easy to get started with it,

02:54:35.267 --> 02:54:39.413
 if you get the hang of it.  And
 in this application, I have two

02:54:39.414 --> 02:54:43.555
 end points that you see down 
here, where I have the host name

02:54:43.556 --> 02:54:49.768
 and the hello endpoint, and I 
let this run on port 8000.

02:54:49.769 --> 02:54:51.841
And now, you can see the 
implementations of the functions

02:54:51.842 --> 02:54:58.067
 here, and they basically -- I'm
 just returning a string, hello 

02:54:58.068 --> 02:55:00.134
from GDD Europe, and the other, 
I'm responding with the host 

02:55:00.135 --> 02:55:04.296
name and the version of the 
application that I'm running.

02:55:04.297 --> 02:55:10.519
And now, the first step that I 
want to do is, I actually want 

02:55:10.520 --> 02:55:12.592
to build a container, I want to 
build this app and then put it 

02:55:12.593 --> 02:55:16.755
into a container that I can run 
on Kubernetes.  That is where 

02:55:16.756 --> 02:55:18.876
Docker File comes in, so in 
Kubernetes, you can run 

02:55:18.877 --> 02:55:25.076
different engines, Docker or 
Rocket or two of the supportive 

02:55:25.077 --> 02:55:29.218
ones that are supported. 
And now, since Docker is the 

02:55:29.219 --> 02:55:31.316
most popular one, I'm going to 
run a Docker container.  And 

02:55:31.317 --> 02:55:35.475
what I'm doing here is actually 
something that just recently 

02:55:35.476 --> 02:55:37.543
came into Docker is a 
multi-stage build.  Why am I 

02:55:37.544 --> 02:55:39.627
doing this? Well, if you build 
your application, you need a lot

02:55:41.700 --> 02:55:43.782
 of build tools, you need your, 
like, your compiler and the 

02:55:43.783 --> 02:55:47.937
linker and all the libraries and
 things like that, and your 

02:55:47.938 --> 02:55:52.102
container is really big.  But I 
want to have my container as 

02:55:52.103 --> 02:55:54.179
small as possible. 
As you can see, in the first 

02:55:54.180 --> 02:55:58.327
step that I'm  I'm doing, I have
 the build container and I'm 

02:56:00.407 --> 02:56:02.485
loading the source code in there
 and in the run command that you

02:56:02.486 --> 02:56:08.721
 see there, I'm building my 
staticly-linked binary.  And in 

02:56:08.722 --> 02:56:12.858
the second stop, I'm copying 
from the build container the 

02:56:12.859 --> 02:56:19.091
binary into the L pine 
container, version 3.6.  And L 

02:56:19.092 --> 02:56:23.251
pine, this base image is really 
small, like 8MB.  And even if I 

02:56:23.252 --> 02:56:29.491
had bad WiFi at a conference, I 
could still do this demo most of

02:56:29.492 --> 02:56:33.644
 the time. 
So let's go ahead and do this, I

02:56:33.645 --> 02:56:35.719
 will build the demo here, you 
can see that I have it built.  

02:56:35.720 --> 02:56:37.801
It goes through all the steps 
and builds my 

02:56:39.871 --> 02:56:41.943
applicationapplication.  Now I 
have the container built and 

02:56:41.944 --> 02:56:48.166
where  I have my container tag, 
and I need to make it available 

02:56:48.167 --> 02:56:52.371
for Kubernetes on Google Cloud.
And so first, before I get 

02:56:52.372 --> 02:56:56.511
started, I will show in the 
upper left a little command that

02:56:56.512 --> 02:57:00.684
 you see there, that's the 
command to get started with 

02:57:00.685 --> 02:57:04.810
Google Container engine on 
Google Cloud, clusters GDD, and 

02:57:04.811 --> 02:57:08.964
then you wait three minutes and 
you have the cluster ready. 

02:57:08.965 --> 02:57:13.109
And now, what I'm going to do 
is, I actually want to push this

02:57:13.110 --> 02:57:17.257
 to my private registry.  So 
what I'm going to do here, I'm 

02:57:17.258 --> 02:57:21.399
going to push it to my private 
registry, and since I pushed it 

02:57:21.400 --> 02:57:23.476
before it should be pretty 
quick, and I'm going to go 

02:57:23.477 --> 02:57:25.555
through there. 
And so now I have it pushed on 

02:57:25.556 --> 02:57:29.712
my prior registry, I will show 
you really quick here, this is 

02:57:29.713 --> 02:57:31.780
my private registry, it shows 
you the container that is 

02:57:31.781 --> 02:57:33.854
pushed, the versions, and you 
can athlete them

02:57:37.943 --> 02:57:42.080
 delete them and other text. 
And the first thing that I'm 

02:57:42.081 --> 02:57:46.226
going to do, I will show you I 
have a Kubernetes cluster 

02:57:46.227 --> 02:57:50.370
running, is that I have three 
nodes in my Kubernetes cluster. 

02:57:50.371 --> 02:57:56.585
And now, I use cube CDL, which 
is like the magic CI tool to 

02:57:56.586 --> 02:58:02.798
interact with Kubernetes to run 
my application. 

02:58:02.799 --> 02:58:06.951
In this case, I use run, I give 
it a name, I point to an image 

02:58:06.952 --> 02:58:11.094
and I point to the port that I 
exposed for this application. 

02:58:11.095 --> 02:58:15.265
And now, when we do this, I want
 to actually show you what is 

02:58:15.266 --> 02:58:19.411
happening here.
And so, on the upper right, you 

02:58:19.412 --> 02:58:23.556
see actually three kinds of API 
objects that are going to show. 

02:58:23.557 --> 02:58:27.704
And in the very first, you have 
the pods that are running, and 

02:58:27.705 --> 02:58:29.784
now we have the version one of 
the demo app running, and the 

02:58:29.785 --> 02:58:31.867
second is all the services that 
I have, and the third is all the

02:58:35.953 --> 02:58:38.038
 deployments I have.  And what I
 don't have now is a way to talk

02:58:40.131 --> 02:58:42.197
 to my application.  I have to 
make that available to the 

02:58:44.276 --> 02:58:46.359
outside. And that is where 
services come into play. 

02:58:46.360 --> 02:58:50.516
So what I'm going to do, I will 
do cube CDL expose, which gives 

02:58:50.517 --> 02:58:56.772
me the chance to expose my 
service -- either inside the 

02:58:56.773 --> 02:59:00.952
cluster, or to the outside.  And
 how do I make it exposable to 

02:59:00.953 --> 02:59:05.106
the outside? That is where dash 
dash type load balance comes in,

02:59:05.107 --> 02:59:11.318
 and that tells the Google Cloud
 platform to make the external 

02:59:11.319 --> 02:59:15.474
and internal load balancer 
available on the application 

02:59:15.475 --> 02:59:21.670
outside. 
So I have the cluster IP and 

02:59:21.671 --> 02:59:23.737
internal IP, and it takes a 
little bit of time. 

02:59:23.738 --> 02:59:29.964
And now you might want to de-bug
 your application.  And now I 

02:59:29.965 --> 02:59:36.183
will exit into my container, in 
this case, I have to of course 

02:59:36.184 --> 02:59:40.334
use the ID that you see in the 
upper right corner on the top.

02:59:40.335 --> 02:59:42.409
And I am going to do

02:59:46.483 --> 02:59:48.554
 an execute dash, and in the 
lower, you can see I'm in the 

02:59:48.555 --> 02:59:54.788
container, you can see what is 
running, my app is running, and 

02:59:54.789 --> 02:59:56.789
you can do -- 
and say 

03:00:04.897 --> 03:00:09.068
http//localhost: 8000.
And it says hello, and it works.

03:00:09.069 --> 03:00:13.208
And this givs you the 
opportunity to debug and see 

03:00:13.209 --> 03:00:15.299
what is going on inside the 
container. 

03:00:15.300 --> 03:00:19.442
And now what I'm going to do 
next, I will see if it is 

03:00:19.443 --> 03:00:21.530
externally available.  You can 
see that I have an external IP 

03:00:21.531 --> 03:00:25.683
over there on the right side.  
So I'm going to copy this 

03:00:25.684 --> 03:00:31.946
external IP really quick.
I will put it in here, and run 

03:00:31.947 --> 03:00:34.024
this, and this refreshes every 
second.  And now what I want to 

03:00:34.025 --> 03:00:38.176
do is, with Kubernetes, is it 
makes it very easy to actually 

03:00:38.177 --> 03:00:42.313
do rolling updates.  So you push
 a new version of your 

03:00:42.314 --> 03:00:44.375
application. 
And so, what I want to do here 

03:00:44.376 --> 03:00:50.641
in this case, I say, okay, you 
are an awesome crowd, because 

03:00:50.642 --> 03:00:54.775
the audience is always awesome.
And then I'm going to save this.

03:00:54.776 --> 03:01:03.084
And I'm going to go back to my 
shell and build this, so I do a 

03:01:03.085 --> 03:01:07.241
Docker build and, in this case, 
I want to have, of course, a new

03:01:07.242 --> 03:01:09.311
 version.
So let me go back and give you 

03:01:09.312 --> 03:01:13.491
version two.  I'm going to build
 this, and now you can see that 

03:01:13.492 --> 03:01:17.653
I made a change, it takes a 
little bit longer.  So you are 

03:01:17.654 --> 03:01:19.735
just going to wait for a second 
until it is done.  And, once 

03:01:19.736 --> 03:01:25.964
it's done, I can now push that 
to my container registry.  So I 

03:01:25.965 --> 03:01:30.110
have G Cloud Docker, push, and 
now I push version two.  And now

03:01:30.111 --> 03:01:36.344
 we wait again a little bit, 
while we are waiting, with 

03:01:36.345 --> 03:01:40.487
Google container engine, you 
have a lot of things that are 

03:01:40.488 --> 03:01:42.566
managed by Google that otherwise
 you have to manage yourself.  

03:01:42.567 --> 03:01:48.794
You have outer scaling, you have
 the monitoringinate  

03:01:48.795 --> 03:01:50.857
integrated, and things like 
that. 

03:01:50.858 --> 03:01:54.996
I want to push out the next 
version, and before consider do 

03:01:54.997 --> 03:02:01.200
 -- I do this, I want to show 
how easy it is to scale an 

03:02:01.201 --> 03:02:03.276
application. 
So say you have Christmas coming

03:02:03.277 --> 03:02:07.435
 up and you want to scale up 
your application.  You scale up 

03:02:07.436 --> 03:02:11.565
the deployment, and over on the 
right, you have the desired one,

03:02:11.566 --> 03:02:15.731
 and you can see it coming up on
 the right, two new containers 

03:02:15.732 --> 03:02:19.873
and we are live.  You can see 
that we are live on the low and 

03:02:19.874 --> 03:02:21.972
top left, the host name is 
changing, but you still have 

03:02:21.973 --> 03:02:26.135
version 0.1.  And what I want to
 do really quick is actually 

03:02:26.136 --> 03:02:30.272
edit my deployment, and go to my
 version 2.

03:02:30.273 --> 03:02:34.414
So this is the configuration 
file that you see here, I just 

03:02:34.415 --> 03:02:38.578
changed live in my configuration
 file the version, and I'm 

03:02:38.579 --> 03:02:42.723
crossing fingers that it will 
work, and you can see it is 

03:02:42.724 --> 03:02:46.876
terminating version 0.1, now it 
is running version 0.2 and, as 

03:02:46.877 --> 03:02:53.112
you can see, up there on the 
right it did the rolling update 

03:02:53.113 --> 03:02:57.288
of my application. 
(Applause). 

03:02:57.289 --> 03:02:59.390
So this hopefully gave you a 
brief introduction, thank you 

03:02:59.391 --> 03:03:03.542
very much.
This hopefully gave you a brief 

03:03:03.543 --> 03:03:07.679
introduction into what 
Kubernetes is capable of.  But 

03:03:07.680 --> 03:03:11.817
what I'm delighted and excited 
about to have here is Steffen 

03:03:11.818 --> 03:03:18.051
from FlixBus who can talk about 
how to implement Kubernetes in 

03:03:18.052 --> 03:03:20.152
production and talk about the 
experience of running Kubernetes

03:03:22.217 --> 03:03:24.283
 in their company and how it 
enabled them to innovate and 

03:03:24.284 --> 03:03:30.517
grow really, really quick.
So, let's welcome Steffen.

03:03:36.616 --> 03:03:40.769
(Applause).  
&gt;&gt; Thanks, Robert.  I'm Steffen,

03:03:40.770 --> 03:03:46.988
 I'm an engineer at FlixBus and 
we will talk about how we use 

03:03:46.989 --> 03:03:49.069
Kubernetes in production. 
So first, who is 

03:03:53.164 --> 03:03:57.378
Flixbus? 200 of you actually 
traveled here by bus, that is 

03:03:57.379 --> 03:04:01.528
really cool, we're a 
long-distance travel bus 

03:04:01.529 --> 03:04:05.683
company, but we are not a bus 
company.  So even though we have

03:04:05.684 --> 03:04:09.839
 1100 buses on the streets, we 
don't actually own any of those 

03:04:09.840 --> 03:04:11.911
buses.  You can compare it to 
the Uber model, we are doing all

03:04:11.912 --> 03:04:16.065
 the marketing, planning, the 
booking engine, but we do not 

03:04:16.066 --> 03:04:20.209
operate the buses and we do not 
employ any of the bus drivers.

03:04:20.210 --> 03:04:26.442
So we cooperate with small- to 
mid-sized bus operators for 

03:04:26.443 --> 03:04:30.575
that.  We have pretty good 
growth, the first commit was in 

03:04:30.576 --> 03:04:34.719
2011.
And now, we have around 40 

03:04:34.720 --> 03:04:36.802
millionmillion passengers this 
year, as an estimate.

03:04:36.803 --> 03:04:40.965
And this, at the bottom, this is
 a graph of the fleck users in 

03:04:40.966 --> 03:04:45.111
IT.  And when I joined the 
company two years ago, we had 

03:04:45.112 --> 03:04:51.328
150 people there, and now all 
together, it is like 200.

03:04:51.329 --> 03:04:55.496
And they are not all engineers, 
but it is challenging to grow 

03:04:55.497 --> 03:04:59.648
that fast.
And so, how did we start? 

03:04:59.649 --> 03:05:07.921
So, we build a big monolith, 
made out of PhP and MySQL and 

03:05:07.922 --> 03:05:12.091
mem cache and the external 
services you have and all the 

03:05:12.092 --> 03:05:16.247
developers are working on this 
monolith, this is challenging 

03:05:16.248 --> 03:05:20.398
because you want to grow the 
engineering power, so we cannot 

03:05:20.399 --> 03:05:22.465
just work on the single 
monolith.  So what do you do? 

03:05:22.466 --> 03:05:28.679
You sake the newest, fancy 
solution that is called 

03:05:28.680 --> 03:05:32.827
self-contained systems, you 
split up the teams and the codes

03:05:32.828 --> 03:05:36.974
 and the code base by business 
domains, and each one of the 

03:05:36.975 --> 03:05:41.110
self Contained Systems might be 
multiple microservices that work

03:05:43.180 --> 03:05:45.258
 together, and that means 
splitting the code base into the

03:05:45.259 --> 03:05:49.414
 messaging base, you need to 
handle data migration and have 

03:05:49.415 --> 03:05:51.490
new team and new 
responsibilities, there's a lot 

03:05:51.491 --> 03:05:55.636
of challenge in doing that.  And
 one of the challenges is 

03:05:55.637 --> 03:05:57.701
infrastructure.
And so, we use a two-person 

03:05:57.702 --> 03:06:01.839
team, managing our 
infrastructure, and this works 

03:06:01.840 --> 03:06:06.014
pretty fine.  Over the years, we
 are pretty stable.

03:06:06.015 --> 03:06:08.114
And of course, that is not a 
sustainable solution, especially

03:06:08.115 --> 03:06:12.276
 if we want to grow the number 
of applications that we have.

03:06:12.277 --> 03:06:20.601
And so, a small and centralized 
team, anytime you need to do 

03:06:20.602 --> 03:06:24.740
something, you walk to the team 
and say, can we upgrade to this 

03:06:24.741 --> 03:06:28.886
version, can you install this 
extension, can you do something 

03:06:28.887 --> 03:06:30.965
else. 
And we were running on Bear 

03:06:30.966 --> 03:06:37.206
Metal and it was hard to do 
system upgrades, we were two 

03:06:37.207 --> 03:06:39.287
versions behind because there 
were more important things to 

03:06:39.288 --> 03:06:43.439
do.  And, of course, at some 
point you cannot scale the 

03:06:43.440 --> 03:06:47.612
system anymore.
So this, there was low velocity 

03:06:47.613 --> 03:06:51.773
of new applications and 
services.  You need to change it

03:06:51.774 --> 03:06:53.859
 if you want to do 
microservices.

03:06:53.860 --> 03:06:55.918
And the goals, in picking a new 
infrastructure, in looking for a

03:06:57.984 --> 03:07:02.132
 solution there, we are a few 
goals here.  And it was to be 

03:07:02.133 --> 03:07:06.280
reproducible and unified 
environment for applications 

03:07:06.281 --> 03:07:08.359
including development.  We have 
a lot of boxes, people moving 

03:07:10.421 --> 03:07:12.485
around, and they are not up to 
date with the staging 

03:07:12.486 --> 03:07:14.573
environment and the production 
environment and it is hard to 

03:07:14.574 --> 03:07:20.783
keep in sync, and containers are
 a good fit so they are the same

03:07:20.784 --> 03:07:24.932
 version and all consistent. 
And all teams must iterate their

03:07:24.933 --> 03:07:27.000
 environment quickly and 
independently.  This is really 

03:07:27.001 --> 03:07:31.148
important, so teams can -- if 
one team wants to build PhP5, 

03:07:31.149 --> 03:07:35.315
and the other PhP7, it is no 
problem.  And we want it to be 

03:07:35.316 --> 03:07:39.471
future proof, we don't want to 
re-do everything every two year 

03:07:41.542 --> 03:07:45.692
years, and what is also really 
important is independence. 

03:07:45.693 --> 03:07:49.842
So Kubernetes is a really great 
fit here, and I can talk about a

03:07:51.912 --> 03:07:53.990
 lot of great stuff in 
Kubernetes, for example, pods.  

03:07:53.991 --> 03:07:58.137
They are a really great way to 
model entities in a cluster, and

03:07:58.138 --> 03:08:02.284
 robust access control is 
another great feature to use 

03:08:02.285 --> 03:08:04.367
overhead.  
The deployments are really 

03:08:04.368 --> 03:08:08.502
amazing in Kubernetes, the 
authentication model is really 

03:08:08.503 --> 03:08:12.661
good, and also the strong API in
 the ecosystem in the community 

03:08:12.662 --> 03:08:14.732
makes Kubernetes special.
And so, let's talk about how you

03:08:14.733 --> 03:08:18.884
 can use the API to build beyond
 grade applications.

03:08:18.885 --> 03:08:25.112
So in February 2016, we were 
dabbing around with Kubernetes 

03:08:25.113 --> 03:08:33.411
and there was no Ingress 
control, that is a way how to 

03:08:33.412 --> 03:08:35.487
specify the crowd into your 
cluster. 

03:08:35.488 --> 03:08:43.826
And it was around 200 lines of 
Go code, now 100 lines.  And we 

03:08:43.827 --> 03:08:47.986
wanted to get rid of it, but it 
is hard to get rid of temporary 

03:08:47.987 --> 03:08:52.144
solutions.  This is what the 
code looks like, we connect in 

03:08:52.145 --> 03:08:56.290
Vertigo, to the end point and 
say, hey, what is true? 

03:08:56.291 --> 03:08:58.371
So please give me all the 
updates, every time an end point

03:08:58.372 --> 03:09:02.551
 changes, please give me the new
 end points.

03:09:02.552 --> 03:09:06.699
And we do some more -- we open 
the reader for it.  And when you

03:09:08.778 --> 03:09:12.932
 connect to this end point, you 
get a JSON object per line.  So 

03:09:12.933 --> 03:09:17.099
we read up to a new line, we 
de-code the JSON object, we put 

03:09:17.100 --> 03:09:21.247
it through a templating engine, 
we put it to a directory on the 

03:09:21.248 --> 03:09:23.248
disk, and you basically

03:09:25.360 --> 03:09:29.504
 re-load the engine.  And of 
course, that's not all the error

03:09:29.505 --> 03:09:33.663
 handling that is missing there,
 but this is still running 

03:09:33.664 --> 03:09:37.809
production for us.  And it 
basically took an afternoon to 

03:09:37.810 --> 03:09:40.276
write. 
And another great part is the 

03:09:37.810 --> 03:09:39.810
community of

03:09:41.897 --> 03:09:48.138
 Kubernetes.
So we wanted to run the 

03:09:48.139 --> 03:09:54.383
integration part of Kubernetes 
with the open-ended connect.  

03:09:54.384 --> 03:10:00.621
And so we submitted a bug, and 
we found the corresponding pod 

03:10:00.622 --> 03:10:04.767
in the Kubernetes source.
And there was a fix in master 

03:10:04.768 --> 03:10:08.923
seven days later, and six days 
later, there was a new release 

03:10:08.924 --> 03:10:13.083
with the fix included.  So 14 
days from reporting to the bug, 

03:10:13.084 --> 03:10:17.236
to a new release that we can put
 into our infrastructure, and 

03:10:17.237 --> 03:10:21.365
usually you pay a lot of money 
for this.  But with Kubernetes, 

03:10:21.366 --> 03:10:23.443
you get it for free. 
And another part, the deployment

03:10:23.444 --> 03:10:29.697
 in the API.  We tried various 
approaches to deploy 

03:10:29.698 --> 03:10:35.936
applications.  Some developers 
use kubectl, some Jenkins, and 

03:10:35.937 --> 03:10:40.083
some Helm.  But the developers 
were saying, is this not working

03:10:40.084 --> 03:10:44.228
 too well, I think I can do it 
better.  And he started doing 

03:10:44.229 --> 03:10:48.387
it, he created Deployer, which 
we are using internally. And the

03:10:48.388 --> 03:10:52.541
 cool thing about Deployer, it 
creates a new staging 

03:10:52.542 --> 03:10:54.542
environment for every feature

03:10:56.624 --> 03:11:00.781
 branch.  So in the past, we had
 a problem, we would deploy 70 

03:11:00.782 --> 03:11:04.923
code a day, but people wanted to
 test it on a staging 

03:11:04.924 --> 03:11:06.996
environment, but if it is not 
free, then you are blocked.  And

03:11:09.077 --> 03:11:11.148
 now we have more than staging 
environment for a feature 

03:11:13.228 --> 03:11:15.289
branch.
So I will quick to a demo for 

03:11:15.290 --> 03:11:16.290
that.
Perfect. 

03:11:15.290 --> 03:11:19.460
So I will run every single 
application here, and the 

03:11:21.545 --> 03:11:27.807
Dockerfile, with engine X, and 
we are just e changing  -- 

03:11:27.808 --> 03:11:34.047
exchanging the index ht l file 
there.  I have the Kubernetes 

03:11:34.048 --> 03:11:38.214
definitions that I need, you put
 in the selves, service, you put

03:11:38.215 --> 03:11:42.368
 in the labels that you want to 
use, you probably want to use an

03:11:42.369 --> 03:11:46.504
 ingress controller now, and we 
have deployment.  We are using

03:11:50.600 --> 03:11:52.678
 templating to get it into our 
yama file.

03:11:52.679 --> 03:11:58.927
And we have the deployer file, 
so a bit like TravisCI, we are 

03:11:58.928 --> 03:12:03.066
looking at that as an 
inspiration, and what name 

03:12:03.067 --> 03:12:09.307
space, what containers are 
needing to be built, and we 

03:12:09.308 --> 03:12:13.435
configure to CI to trigger the 
CI pipeline.

03:12:13.436 --> 03:12:17.587
And now, let's make a change 
here.

03:12:17.588 --> 03:12:21.725
In the html file, I will create 
a new

03:12:27.828 --> 03:12:29.913
 branch.
Now it is 

03:12:38.003 --> 03:12:40.070
1307.
I commit the file, and say, 

03:12:40.071 --> 03:12:42.149
hello, GDD.  

03:12:46.234 --> 03:12:48.292
 I will push it, and now, so you
 can see the master branch is 

03:12:48.293 --> 03:12:54.532
already deployed.  
Everything works fine, and the 

03:12:54.533 --> 03:12:58.698
demo gods listened to my 
prayers. 

03:12:58.699 --> 03:13:04.935
There it is.
So the new deployment, it is the

03:13:04.936 --> 03:13:09.100
 same name space and prefix.  I 
will give it a few seconds, 

03:13:09.101 --> 03:13:13.232
because the load balancing is 
throttl throttling, we need to 

03:13:13.233 --> 03:13:15.233
give a little bit of time to 
show it 

03:13:17.326 --> 03:13:19.448
works.  This is the master 
branch.

03:13:19.449 --> 03:13:25.685
You can see that it works. 
And you can -- okay.

03:13:25.686 --> 03:13:29.827
So, I will open this, it takes a
 little bit of time to re-load. 

03:13:29.828 --> 03:13:34.000
So you get a feature branch for 
every environment, an 

03:13:34.001 --> 03:13:38.148
environment for every feature 
branch when you are developing, 

03:13:38.149 --> 03:13:39.815
automatically.
(Applause).

03:13:44.262 --> 03:13:46.262
Okay, let's go back to the

03:13:48.372 --> 03:13:52.555
 presentation.
So these things all fit very 

03:13:52.556 --> 03:13:56.710
well together in and help us 
solve the problems that we have 

03:13:56.711 --> 03:13:58.777
because every company is unique 
and sometimes you have to change

03:13:58.778 --> 03:14:05.040
 things and there is no 
one-size-fits-all solution and 

03:14:05.041 --> 03:14:07.121
Kubernetes gives you the tools 
to solve your problems. 

03:14:07.122 --> 03:14:11.263
So what does our infrastructure 
look like? So not everything is 

03:14:11.264 --> 03:14:19.551
running Kubernetes yet, but we 
have 60 namespaces for 12 teams.

03:14:19.552 --> 03:14:23.698
We have 800 containers running 
on 32 nodes. 

03:14:23.699 --> 03:14:27.875
We have multiple production 
services, including two mission 

03:14:27.876 --> 03:14:29.876
critical 

03:14:31.959 --> 03:14:36.131
ones, which push 100MBs of 
traffic at peak. 

03:14:36.132 --> 03:14:40.355
I think that Kubernetes is one 
of the most exciting projects in

03:14:42.439 --> 03:14:46.578
 the open-source project space 
since Linux itself, there is 

03:14:46.579 --> 03:14:48.641
such a supportive community and 
a lot of great stuff going on.  

03:14:48.642 --> 03:14:54.899
You should go to it, if you are 
looking to solve problems. 

03:14:54.900 --> 03:14:59.068
So thank you, if you have any 
questions or want to chat about 

03:14:59.069 --> 03:15:01.069
Kubernetes, you can find

03:15:03.165 --> 03:15:07.329
 us on the third floor after 
this talk.

03:15:07.330 --> 03:15:09.431
Thank you very much.   
(Applause).  

03:15:31.623 --> 03:15:33.623
Test.  Test.

03:23:23.819 --> 03:23:26.258
DANIELLE: Hello, everyone.  It's
 great to see you all here.  

03:23:26.259 --> 03:23:32.487
Thank you so much for joining my
 session.  The year ahead in 

03:23:32.488 --> 03:23:34.581
global tech policy.  My name is 
Danielle and I'm on the public 

03:23:34.582 --> 03:23:40.780
policy team here at Google.  So 
in addition to introducing what 

03:23:40.781 --> 03:23:42.852
we do on the public policy team 
and how we can help you, this 

03:23:42.853 --> 03:23:49.087
session is going to be a 
whirlwind tour, if you will, 

03:23:49.088 --> 03:23:51.170
through some of the big issues 
that we're thinking about at 

03:23:51.171 --> 03:23:55.320
Google.  Issues that are at the 
intersection of technology and 

03:23:55.321 --> 03:23:57.392
public policy.
So there's a lot that we could 

03:23:57.393 --> 03:24:01.538
cover today, but I'm going to 
highlight a few issues that 

03:24:01.539 --> 03:24:05.705
developers in particular will be
 impacted with.  And flag some 

03:24:05.706 --> 03:24:11.936
opportunities for you to make a 
difference on these issues.  So 

03:24:11.937 --> 03:24:16.080
just to get started, a bit about
 me.  I'm a lawyer.  Sorry.  But

03:24:16.081 --> 03:24:20.244
 I've spent much of my time 
practicing international law in 

03:24:20.245 --> 03:24:24.397
the U.S. Federal Government.  
But before I made the mistake of

03:24:24.398 --> 03:24:26.480
 going to law school, I was an 
electrical  engineer.  So as a 

03:24:26.481 --> 03:24:30.664
public policy adviser at Google,
 I get to explore the 

03:24:30.665 --> 03:24:32.739
intersections between two areas 
that I'm actually really 

03:24:32.740 --> 03:24:36.898
passionate about.  So this is 
the only code that I get to put 

03:24:36.899 --> 03:24:38.980
up on the screen today.  But I 
just wanted to point out that I 

03:24:38.981 --> 03:24:45.238
get the significance of the 
infamous leftbad code that broke

03:24:45.239 --> 03:24:49.383
 the Internet a few years back. 
 But also the obscure legal 

03:24:49.384 --> 03:24:55.593
reference here.  And if you're 
interested in it, see me 

03:24:55.594 --> 03:24:59.749
averwards and we can chat.
As I said, I lead global public 

03:24:59.750 --> 03:25:03.906
policy around two topics in 
particular relevant to 

03:25:03.907 --> 03:25:08.064
developers.  One is the Android 
operating system and related 

03:25:08.065 --> 03:25:12.233
platforms like Android auto and 
Android Wear.  And our thought 

03:25:12.234 --> 03:25:16.386
leadership on the Internet of 
things.  So we're going to focus

03:25:16.387 --> 03:25:20.526
 on what we see as having a 
real, immediate impact on 

03:25:20.527 --> 03:25:24.666
developers.  But I'm happy to 
talk about any public policy 

03:25:24.667 --> 03:25:26.746
topic that you'd like if you're 
interested after this 

03:25:26.747 --> 03:25:30.899
presentation.
Okay.  So let's just get to it. 

03:25:30.900 --> 03:25:32.967
 What is tech public policy 
anyway?  So I'm going to start 

03:25:32.968 --> 03:25:39.192
with a bit of background.  Now, 
when you say "Public  policy," 

03:25:39.193 --> 03:25:41.283
it can sound pretty abstract.  
Maybe you think of a bunch of 

03:25:41.284 --> 03:25:43.361
folks in powdered wigs,

03:25:47.463 --> 03:25:51.613
 perhaps, in a room.  Or a bunch
 of folks writing a bill 

03:25:51.614 --> 03:25:53.692
together in a slow process.  
This is a portrait depicting the

03:25:55.762 --> 03:25:59.909
 signing of the U.S. Declaration
 of  Independence.  Obviously 

03:25:59.910 --> 03:26:04.058
these folks never heard of 
GitHub.  It's 1776.  Or maybe 

03:26:04.059 --> 03:26:12.368
your favorite political TV show,
 House of Cards or Yes, 

03:26:12.369 --> 03:26:16.522
Minister.  My life is nothing 
like those.  Most folks think 

03:26:16.523 --> 03:26:18.592
public policy is something 
outside of the world of 

03:26:18.593 --> 03:26:22.762
technology.  That is the basic 
assumption.  There's policy, and

03:26:22.763 --> 03:26:24.843
 then there's tech.
But that is a big assumption.  

03:26:24.844 --> 03:26:28.997
As an engineer, I think that the
 usual idea is that you should 

03:26:28.998 --> 03:26:33.134
just build great products and 
let the chips fall where they 

03:26:33.135 --> 03:26:37.280
may.  There's a tendency to 
think about products as being 

03:26:37.281 --> 03:26:43.503
dependent upon users rather than
 larger outside forces.  But, of

03:26:43.504 --> 03:26:47.662
 course, lawmakers and policy 
makers are thinking about 

03:26:47.663 --> 03:26:53.901
technology all the time.  You 
might remember the SOPA/PIPA, 

03:26:53.902 --> 03:27:00.134
that's the stop online privacy 
act and protect IP debates.  

03:27:00.135 --> 03:27:04.284
Those were occurring a few years
 back.  So that was focused on 

03:27:04.285 --> 03:27:06.356
legislation in the United 
States.  But these initiatives 

03:27:06.357 --> 03:27:08.441
would have fundamentally changed
 how content is allowed to move 

03:27:08.442 --> 03:27:12.613
around the web.  And would have 
had a big impact on speech.

03:27:12.614 --> 03:27:16.746
You might also remember some of 
the battles around net 

03:27:16.747 --> 03:27:20.910
neutrality.  A debate about how 
people can access services and 

03:27:20.911 --> 03:27:22.994
the speed at which they can do 
so.  Various iterations of these

03:27:25.064 --> 03:27:27.130
 debates are continuing today.  
Now, these discussions and  

03:27:27.131 --> 03:27:31.289
debates have an impact at every 
level.  As a developer, what can

03:27:31.290 --> 03:27:35.416
 you build and what can you 
launch?  As a startup, what 

03:27:35.417 --> 03:27:39.574
kinds of users can you access 
and when can you access those 

03:27:39.575 --> 03:27:43.722
users?  And as a user, what can 
and can't you do with the 

03:27:43.723 --> 03:27:47.883
technology that you have?  So 
that's the work of public policy

03:27:49.963 --> 03:27:54.107
.  There are new rules, laws, 
and regulations and ideas for 

03:27:54.108 --> 03:27:58.285
those kinds of things  popping 
up all the time.  There are 

03:27:58.286 --> 03:28:00.364
great ideas.  There are bad 
ideas.  And everything in 

03:28:00.365 --> 03:28:02.437
between.
So our team plays the role of 

03:28:02.438 --> 03:28:06.589
monitoring those developments 
and figuring out the 

03:28:06.590 --> 03:28:08.659
implications of those for the 
greater ecosystem of which 

03:28:08.660 --> 03:28:10.660
Google is a

03:28:12.740 --> 03:28:16.893
 part.  Then we spend a lot of 
time telling people about it.  

03:28:16.894 --> 03:28:18.987
That sometimes involves 
explaining technology to 

03:28:18.988 --> 03:28:23.144
lawmakers or policy makers who 
want to learn about a new 

03:28:23.145 --> 03:28:27.294
emerging trend.  And sometimes 
involves talking to particular 

03:28:27.295 --> 03:28:31.466
groups.
Developers are particularly 

03:28:31.467 --> 03:28:33.520
important because they are a 
critical part of the ecosystem. 

03:28:33.521 --> 03:28:37.669
 And you're really influential 
when you speak out on these 

03:28:37.670 --> 03:28:41.843
issues.  So we want feedback 
from developers in particular as

03:28:41.844 --> 03:28:45.984
 we figure out our position on 
many of these issues.  But I 

03:28:45.985 --> 03:28:50.153
recognize, you all have day 
jobs.  You're busy, important 

03:28:50.154 --> 03:28:52.224
people.  And you're too busy 
trying to make sure that you 

03:28:52.225 --> 03:28:54.305
make great products and that 
they work to pay attention to 

03:28:54.306 --> 03:28:58.466
the myriad of developments that 
happen in the public policy 

03:28:58.467 --> 03:29:04.707
world.  A lot of it is dense 
legalese, a lot of it is 

03:29:04.708 --> 03:29:08.879
regulations, a lot of it's 
things that are promulgated into

03:29:08.880 --> 03:29:13.054
 the future.  That's not 
something you want to spend a 

03:29:13.055 --> 03:29:17.279
lot of time focus on, on the 
day-to-day.  So we think it's 

03:29:17.280 --> 03:29:21.430
important to lower the cost to 
you for finding out and taking 

03:29:21.431 --> 03:29:23.509
action on all of these policy 
initiatives.

03:29:23.510 --> 03:29:27.688
So let's jump into it.  As I 
mentioned, the world is big and 

03:29:27.689 --> 03:29:29.793
the universe of public policy 
issues around technology is also

03:29:29.794 --> 03:29:33.959
 very big.  And I just wantedded
 to pick three topics that are 

03:29:33.960 --> 03:29:38.111
at the top of mind for us here 
at Google that are likely going 

03:29:38.112 --> 03:29:42.249
to have the biggest impact on 
developers in the coming months.

03:29:44.331 --> 03:29:48.495
  So the Internet of Things.  
Fragmentation of the Android 

03:29:48.496 --> 03:29:50.590
ecosystem, and fair use of APIs.
Okay.  So let's start with the 

03:29:50.591 --> 03:29:56.830
Internet of  Things.  Or IoT.  
So I'm sure you've all heard of 

03:29:56.831 --> 03:30:03.057
 IoT, but let's face it, it's 
kind of a buzzword.  Really it 

03:30:03.058 --> 03:30:07.205
refers to the fact, if you break
 it down, to the idea that 

03:30:07.206 --> 03:30:11.353
everything -- big and small -- 
is converging into becoming one 

03:30:11.354 --> 03:30:15.521
connected computer.  And these 
things can take lots of 

03:30:15.522 --> 03:30:17.606
different shapes beyond the 
phones and laptops that we're 

03:30:17.607 --> 03:30:21.743
accustomed to these days.  So we
 don't think that the future is 

03:30:21.744 --> 03:30:25.898
going to be some sci-fi-looking 
world, but instead, might look 

03:30:25.899 --> 03:30:30.027
something like this.  Just 
devices that are seamlessly 

03:30:30.028 --> 03:30:36.341
integrated into every day life.
Now, IoT is a buzzword, it 

03:30:36.342 --> 03:30:38.407
doesn't mean much by itself.  
But for policy makers in 

03:30:38.408 --> 03:30:44.635
particular, the ubiquity of IoT 
devices raises all sorts of new 

03:30:44.636 --> 03:30:48.803
concerns.  So how should these 
devices be secured against 

03:30:48.804 --> 03:30:52.956
people with malicious intent?  
How should they be made to 

03:30:52.957 --> 03:30:55.026
protect user privacy?  How 
should devices signal that 

03:30:55.027 --> 03:30:59.181
things are going right or going 
wrong to those people who own 

03:30:59.182 --> 03:31:03.351
those devices or who are 
maintaining them?  So how should

03:31:03.352 --> 03:31:07.526
 we think about these problems? 
 How should we approach these 

03:31:07.527 --> 03:31:09.602
large topics?  So one approach 
is rather old fashioned.  Which 

03:31:09.603 --> 03:31:15.861
is to say we use the law to 
shape the behavior of people who

03:31:15.862 --> 03:31:17.920
 are making and coding these 
products.  That would be you.

03:31:17.921 --> 03:31:22.077
And, indeed, lots of policy 
makers around the world are 

03:31:22.078 --> 03:31:26.220
thinking about these questions, 
and they're starting to consider

03:31:26.221 --> 03:31:30.366
 regulations.  The recent DDoS 
attacks which involved IoT 

03:31:30.367 --> 03:31:34.554
devices that took down some 
popular Internet sites are a 

03:31:34.555 --> 03:31:36.621
pretty good example of how these
 things can catch the attention 

03:31:36.622 --> 03:31:40.767
of lawmakers and policy makers 
around the world.  And, of 

03:31:40.768 --> 03:31:44.915
course, this is why it matters 
to you.  But this picture isn't 

03:31:44.916 --> 03:31:49.071
just about lawmakers.  This is 
an area in which the people who 

03:31:49.072 --> 03:31:51.160
are  designing these 
technologies are going to play a

03:31:51.161 --> 03:31:57.380
 big role.
So this is Lawrence Lessig, he 

03:31:57.381 --> 03:31:59.448
is a professor at my old law 
school.  You might remember him 

03:31:59.449 --> 03:32:05.707
from creative commons or his 
recent ill-fated attempt to run 

03:32:05.708 --> 03:32:09.843
for President of the United 
States.  He is actually most 

03:32:09.844 --> 03:32:11.924
known in the public policy world
 for thinking about the various 

03:32:11.925 --> 03:32:16.103
forces that can influence human 
behavior.  So law is one force. 

03:32:16.104 --> 03:32:22.325
 But also  norms and markets and
 code.  So in certain  

03:32:22.326 --> 03:32:26.479
situations, some levers are 
going to be more powerful than 

03:32:26.480 --> 03:32:30.637
others.  And we think that, for 
the Internet of Things, code is 

03:32:30.638 --> 03:32:32.703
going to be particularly 
powerful because the space is 

03:32:32.704 --> 03:32:36.863
moving so fast.  And the 
standards and conventions that 

03:32:36.864 --> 03:32:41.075
developers land on will be the 
template for the norms and laws 

03:32:41.076 --> 03:32:47.310
that follow.
So if ubiquity is the challenge 

03:32:47.311 --> 03:32:51.468
in the IoT space, then trust is 
the solution.  So at Google we 

03:32:51.469 --> 03:32:53.537
have been thinking about three 
principles that should guide the

03:32:53.538 --> 03:32:59.751
 IoT space.  Interoperability, 
security and privacy, and the 

03:32:59.752 --> 03:33:03.894
need for new  interfaces.  So 
with respect to 

03:33:03.895 --> 03:33:08.058
interoperability, we are 
constantly considering how we 

03:33:08.059 --> 03:33:12.213
can develop and support open 
protocols that would allow 

03:33:12.214 --> 03:33:14.289
devices to connect easily to one
 another.  With respect to 

03:33:14.290 --> 03:33:18.455
privacy and security, we are 
thinking about what controls 

03:33:18.456 --> 03:33:22.618
actually need to be in place.  
Taking into account the 

03:33:22.619 --> 03:33:26.817
diversity and the various use 
cases for a plethora of IoT 

03:33:26.818 --> 03:33:30.942
devices even yet to be invented.
  And with respect to the human 

03:33:30.943 --> 03:33:33.016
interface, we are thinking about
 the implications for 

03:33:33.017 --> 03:33:39.229
transparency or consent, control
 and choice around data.   

03:33:39.230 --> 03:33:43.398
Particularly when the IoT device
 may have no screen or keyboard 

03:33:43.399 --> 03:33:47.558
for users to interact with.
So this is something that we are

03:33:47.559 --> 03:33:51.706
 really looking for developer 
feedback on.  No one has all the

03:33:51.707 --> 03:33:55.852
 answers.  But people who are 
closest to this technology have 

03:33:55.853 --> 03:34:00.005
the most practical experience.  
So in sum, we really think that 

03:34:00.006 --> 03:34:02.073
developers are going to be 
setting the norms for this new 

03:34:02.074 --> 03:34:06.229
IoT ecosystem.  And the 
practices that you develop will 

03:34:06.230 --> 03:34:10.366
guide policy and law as it's 
developed.

03:34:12.469 --> 03:34:14.543
So next up I want to talk about 
fragmentation and the Android

03:34:18.614 --> 03:34:22.780
 ecosystem and how it intersects
 with the law.  I'll talk a 

03:34:22.781 --> 03:34:25.981
little bit about how this 
impacts developers in 

03:34:22.781 --> 03:34:26.949
particular, and what you guys 
can do about it.  So for this 

03:34:26.950 --> 03:34:31.928
story, it's worth going back to 
the early days of Andy Ruben and

03:34:31.929 --> 03:34:36.993
 Android in the late 2000s.  
Ancient times.  I  know.  And 

03:34:36.994 --> 03:34:39.073
for those of you who are too 
young to remember or are just 

03:34:39.074 --> 03:34:43.228
living in the present and  
seeing out future developments 

03:34:43.229 --> 03:34:45.314
that have happened -- or will 
happen -- with devices, I think 

03:34:45.315 --> 03:34:49.464
it's really important to 
remember.  It was really 

03:34:49.465 --> 03:34:53.626
difficult to create apps for 
mobile devices back then.  So 

03:34:53.627 --> 03:34:59.829
first of all, there are millions
 of users that weren't 

03:34:59.830 --> 03:35:04.024
harnessing the potential of the 
mobile devices they had.  The 

03:35:04.025 --> 03:35:06.107
computers in their pockets 
because the software just wasn't

03:35:06.108 --> 03:35:08.184
 good enough.  Mobile phones had
 had really limited 

03:35:08.185 --> 03:35:12.328
functionality.  They had  
relatively low usage.  And many 

03:35:12.329 --> 03:35:14.389
users wouldn't even try to get 
on the Internet.  If

03:35:14.390 --> 03:35:18.538
you remember how hard it was to 
get on the Internet and do 

03:35:18.539 --> 03:35:20.607
something useful back then.  
That was a real issue.

03:35:20.608 --> 03:35:24.759
And the mobile industry was 
plagued with what we call "

03:35:26.852 --> 03:35:31.027
Walled gardens."  This created 
unlimited opportunities for app 

03:35:31.028 --> 03:35:35.185
developers to get their apps on 
to the devices and into the 

03:35:35.186 --> 03:35:37.272
hands of consumers.  So our 
objective was develop an open 

03:35:37.273 --> 03:35:41.429
operating system that would 
benefit all of the parts of the 

03:35:41.430 --> 03:35:43.514
ecosystem.  The phone 
manufacturers, the app 

03:35:43.515 --> 03:35:47.673
developers, and just every day 
people using phones.

03:35:47.674 --> 03:35:49.750
So this meant developing an 
operating system with some 

03:35:49.751 --> 03:35:55.980
common protocols that anyone 
could pick up and use for their 

03:35:55.981 --> 03:36:00.125
own purposes.  And would allow 
the same app to work across 

03:36:00.126 --> 03:36:04.317
different phones by different 
manufacturers.  The goal of 

03:36:04.318 --> 03:36:08.494
Android was to turbo charge the 
mobile development space by  

03:36:08.495 --> 03:36:12.635
aligning the standards around an
 open source  operating system. 

03:36:12.636 --> 03:36:14.709
 And as they say, that was  
super-effective.

03:36:14.710 --> 03:36:18.840
We have some amazing stats about
 the state of the Android 

03:36:18.841 --> 03:36:23.002
ecosystem.  And these are a 
little  dated, but I'm sure 

03:36:23.003 --> 03:36:27.181
you'll agree, we have more than 
400 different manufacturers, 

03:36:27.182 --> 03:36:31.352
more than 1.4 billion Android 
devices worldwide and more than 

03:36:31.353 --> 03:36:37.592
$14 billion paid to developers 
since the launch of Android.  

03:36:37.593 --> 03:36:41.733
But as the ecosystem got bigger 
and bigger, and I don't need to 

03:36:41.734 --> 03:36:43.809
tell you this, really, the 
ecosystem also became 

03:36:43.810 --> 03:36:50.022
increasingly fragmented.
So this is a visualization from 

03:36:50.023 --> 03:36:54.187
Open Signal.  It shows the great
 variety of Android devices -- 

03:36:54.188 --> 03:36:56.252
which is excellent for consumers
 and those who like choice -- 

03:36:56.253 --> 03:37:00.396
but it also shows all of the 
fragmentation that is in the 

03:37:00.397 --> 03:37:02.397
Android space.  So

03:37:04.502 --> 03:37:06.580
 in short, the  openness of the 
system itself generated 

03:37:06.581 --> 03:37:10.741
fragmentation as Android grew 
into more and more contexts.

03:37:12.809 --> 03:37:16.967
So the result is higher costs in
 ensuring performance on each 

03:37:16.968 --> 03:37:25.306
kind of Android device.  So Anna
 Mocha had a photo being passed 

03:37:25.307 --> 03:37:29.453
around a while back.  It shows 
all of the devices they keep on 

03:37:29.454 --> 03:37:31.523
hand to make sure that their 
games and products run across 

03:37:31.524 --> 03:37:35.667
all of the possible Android 
devices.  And this even impacts 

03:37:35.668 --> 03:37:39.828
us.  Little known fact is that 
when we were developing Google 

03:37:39.829 --> 03:37:43.990
Maps, we had a closet full of 
phones that we were testing them

03:37:43.991 --> 03:37:48.140
 on.
So that isn't all.  

03:37:48.141 --> 03:37:52.283
Fragmentation can impact 
security.  Now, Android is a 

03:37:52.284 --> 03:37:56.452
very secure platform.  We work 
to keep those 1.4 billion 

03:37:56.453 --> 03:37:58.508
Android devices safe.  And we 
start with the core Android 

03:37:58.509 --> 03:38:02.688
platform as a safe space for 
that.  Android is strengthened 

03:38:02.689 --> 03:38:06.848
by the regular security updates 
for the platform, for 

03:38:06.849 --> 03:38:08.914
applications, for the device 
themselves.  And it's constantly

03:38:10.995 --> 03:38:13.072
 evolving security services that
 monitor and protect the system.

03:38:13.073 --> 03:38:17.215
  But fragmentation does make it
 harder to ensure security 

03:38:17.216 --> 03:38:21.351
updates reach everyone.  And 
it's doubly hard to ensure that 

03:38:21.352 --> 03:38:25.506
those devices incorporate the 
latest patches quickly.  So this

03:38:25.507 --> 03:38:31.731
 certainly impacts users.  But 
it also impacts the ecosystem 

03:38:31.732 --> 03:38:33.804
more deeply -- namely you -- 
since developers need to spend 

03:38:33.805 --> 03:38:40.036
more time and resources to 
ensure security.  And another 

03:38:40.037 --> 03:38:44.318
big issue is that security 
failures can easily harm a 

03:38:44.319 --> 03:38:50.571
developer's reputation.
So as an open operating system, 

03:38:50.572 --> 03:38:52.661
the interesting and exciting 
design challenge here is how we 

03:38:52.662 --> 03:38:58.896
balance openness, which is in 
part what generated so much 

03:38:58.897 --> 03:39:03.056
success for so many who use the 
Android platform and in the 

03:39:03.057 --> 03:39:07.219
Android ecosystem with 
interoperability.  So these 

03:39:07.220 --> 03:39:09.280
decision and those tradeoffs had
 a huge impact on developers in 

03:39:09.281 --> 03:39:11.359
their day-to-day lives.  So we 
have a few levers for

03:39:15.443 --> 03:39:19.589
 ensuring interoperability.  
One, for example, is our Nexus 

03:39:19.590 --> 03:39:23.752
and Pixel phones.  Those really 
serve as an attempt to give the 

03:39:23.753 --> 03:39:27.913
Android platform a method for 
the operating system to be 

03:39:27.914 --> 03:39:32.110
uniform.  But the strongest 
lever that we have to

03:39:36.179 --> 03:39:40.329
 ensure interoperability is our 
relationship with phone makers. 

03:39:40.330 --> 03:39:44.483
 They get impacted with 
fragmentation too.  So we make 

03:39:44.484 --> 03:39:48.641
agreements with them to ensure 
certain practices that protect 

03:39:48.642 --> 03:39:52.793
interoperability.  So the worry 
is, without the ability to use 

03:39:52.794 --> 03:39:56.965
these  anti-fragmentation 
agreements, the Android 

03:39:56.966 --> 03:39:59.048
ecosystem will continue to 
fragment in ways that are really

03:40:01.133 --> 03:40:05.295
 unsustainable over time.  So
eventually you could imagine 

03:40:05.296 --> 03:40:07.370
devices diverging so much that 
it becomes difficult to tell 

03:40:07.371 --> 03:40:11.528
whether or not a begin app will 
run when you download it.

03:40:11.529 --> 03:40:15.669
We also think that it might 
particularly impact smaller 

03:40:15.670 --> 03:40:19.838
developers that don't have the 
resources to deal with big 

03:40:19.839 --> 03:40:26.096
cabinets full of phones.  So you
 may have heard that regulators 

03:40:26.097 --> 03:40:28.176
are interested in these 
agreements too because they have

03:40:28.177 --> 03:40:32.309
 a big impact on the mobile 
ecosystem.  At issue is whether 

03:40:32.310 --> 03:40:36.473
or not these types of agreements
 should be allowed at all.  

03:40:36.474 --> 03:40:40.634
These inquiries that we get from
 policy makers really give us a 

03:40:40.635 --> 03:40:42.717
chance to better understand what
 they're interested in and a 

03:40:42.718 --> 03:40:46.869
chance to talk about how the 
open source ecosystem and 

03:40:46.870 --> 03:40:48.956
Android really works.   But, of 
course, it isn't just about 

03:40:48.957 --> 03:40:53.161
Google.  Developers are a big 
part of the picture here.

03:40:53.162 --> 03:40:57.302
It turns out that regulators are
 just as interested in the 

03:40:57.303 --> 03:41:01.457
developers that make the Android
 ecosystem great.  So how do you

03:41:01.458 --> 03:41:03.458
 balance

03:41:05.534 --> 03:41:07.604
 openness and interoperability? 
 That is a question that's not 

03:41:07.605 --> 03:41:11.773
just for policy makers, but for 
developers too.  And the policy 

03:41:11.774 --> 03:41:15.927
makers really need to hear from 
you.

03:41:15.928 --> 03:41:24.225
So the last topic that I will 
briefly touch on is fair use of 

03:41:24.226 --> 03:41:28.386
APIs.  So the surest way for me 
to get booed off the stage, if 

03:41:28.387 --> 03:41:32.539
you're not asleep yet, is for me
 to launch into the intricacies 

03:41:32.540 --> 03:41:38.752
of copyright law.  So I will 
just simply say this: for 

03:41:38.753 --> 03:41:40.839
decades developers have relied 
on the open nature of APIs to 

03:41:40.840 --> 03:41:45.039
build their products and to have
  reimplemented those APIs to 

03:41:45.040 --> 03:41:49.205
create new software.  Think 
about, for example, the C 

03:41:49.206 --> 03:41:53.358
standard library  API.  That has
 reimplemented countless times 

03:41:53.359 --> 03:41:57.528
to allow differing operating 
systems to work with programs in

03:41:59.594 --> 03:42:03.748
 C.  So many developers have 
found that when they can freely 

03:42:03.749 --> 03:42:07.899
reimplement an API without  
getting a costly license, they 

03:42:07.900 --> 03:42:12.057
can create compatible software 
that maybe the original creator 

03:42:12.058 --> 03:42:16.216
had not ever envisioned before. 
 So we think the openness of 

03:42:16.217 --> 03:42:18.297
APIs supports innovation.  And 
that's innovation everywhere 

03:42:18.298 --> 03:42:24.579
from incumbents to startups.
Currently there is debate about 

03:42:24.580 --> 03:42:28.751
whether APIs should be 
copyrightable.  And if so 

03:42:28.752 --> 03:42:32.885
whether a doctrine called "Fair 
use" could be used so that 

03:42:32.886 --> 03:42:37.036
licenses would not be necessary 
in certain contexts.  So the 

03:42:37.037 --> 03:42:41.172
question is, what does the world
 look like if developers have to

03:42:41.173 --> 03:42:45.317
 get a license before  
reimplementing an API?  Or if 

03:42:45.318 --> 03:42:49.470
they can't rely on fair use 
doctrine.  I'm sure you're 

03:42:49.471 --> 03:42:53.603
building products and tools 
every day that can provide 

03:42:53.604 --> 03:42:57.751
concrete examples about how 
decisions policy makers make on 

03:42:57.752 --> 03:43:01.945
copyrightbility and the 
application of fair use would 

03:43:01.946 --> 03:43:04.041
really impact the world.  What 
products might get bullet and 

03:43:04.042 --> 03:43:08.185
what might not if you have to 
seek licenses to reimplement 

03:43:08.186 --> 03:43:12.328
APIs?  That would be something 
that would be really great for 

03:43:12.329 --> 03:43:16.482
you to communicate in a 
practical way to policy makers.

03:43:16.483 --> 03:43:20.640
So I'm going to wrap up soon.  I
 really hope that if you take 

03:43:20.641 --> 03:43:26.873
anything away from this 
presentation, it's really how 

03:43:26.874 --> 03:43:31.021
important you are to these 
debates and how important these 

03:43:31.022 --> 03:43:35.183
debates are to you.  So right 
now, if you're here in the 

03:43:35.184 --> 03:43:39.341
audience with us, we really 
invite you to visit the Google  

03:43:39.342 --> 03:43:43.495
Developer Video Studio which is 
on the third floor here, and 

03:43:43.496 --> 03:43:47.646
tell us your experiences 
developing with Android.  We'll 

03:43:47.647 --> 03:43:49.727
be there for the next couple of 
 hours.  And if you want to ask 

03:43:49.728 --> 03:43:51.794
me other public policy 
questions, I would be happy to 

03:43:51.795 --> 03:43:53.865
engage.
There we would love to record 

03:43:53.866 --> 03:43:58.014
your story.  Tell us about the 
work that you're doing.  How 

03:43:58.015 --> 03:44:00.097
Android has helped you do it.  
And please give us your honest 

03:44:00.098 --> 03:44:04.257
feedback.  Maybe there's some 
things you agreed with me on 

03:44:04.258 --> 03:44:06.346
here, some different point of 
view that you want to raise.  

03:44:06.347 --> 03:44:08.422
That is completely okay.  It's 
your honest

03:44:12.515 --> 03:44:16.680
in' opinions and thoughts about 
these issues that help us figure

03:44:18.771 --> 03:44:20.858
 out where we should be.  And 
for your time, I think we have a

03:44:20.859 --> 03:44:25.005
 small gift for the first 40 or 
so of you that are able to make 

03:44:25.006 --> 03:44:31.275
it up and share your thoughts 
with us.  If you don't have a 

03:44:31.276 --> 03:44:33.379
chance to stop by today, there 
are other things you can do to 

03:44:33.380 --> 03:44:37.544
contribute to the debate.  Feel 
free to Tweet and share on 

03:44:37.545 --> 03:44:41.711
social media some of the ideas 
you heard here.  We have a photo

03:44:41.712 --> 03:44:45.877
 booth that we would love for 
you to visit and share that on 

03:44:45.878 --> 03:44:47.957
social media as well.  To have 
people know that you're 

03:44:47.958 --> 03:44:50.042
interested in these issues so 
policy makers can start thinking

03:44:50.043 --> 03:44:54.202
 more fully about how developers
 might be

03:44:54.203 --> 03:44:56.264
integrated into this 
conversation.

03:44:56.265 --> 03:45:02.511
So that's it.  Thank you so much
 for your time.

03:45:02.512 --> 03:45:04.512
[ Applause ]

04:19:40.959 --> 04:19:49.573
STEPHEN: Good afternoon.  My 
name is Stephen  Fluin and I'm 

04:19:49.574 --> 04:19:53.736
on the developer Angular team at
 Google.  I have been entransed 

04:19:53.737 --> 04:19:55.821
by tools throughout my career.  
The right

04:19:59.403 --> 04:20:01.488
 tools used in the right way 
have the ability to improve our 

04:20:01.489 --> 04:20:05.645
lives as developers, but also to
 increase the quality of our 

04:20:05.646 --> 04:20:07.736
work.  Part of the reason I 
joined Google was to help 

04:20:07.737 --> 04:20:11.872
developers find and adopt great 
tools from across the  

04:20:11.873 --> 04:20:16.020
ecosystem.  We have heard a lot 
about progressive web 

04:20:16.021 --> 04:20:18.110
applications.  Part of what we 
have heard is some of the great 

04:20:18.111 --> 04:20:22.286
case decease.  About the 
outcomes we get from adopting 

04:20:22.287 --> 04:20:26.444
these technologies.  And we have
 also heard about some of the 

04:20:26.445 --> 04:20:30.586
ways these improve the user 
experience.  I want to peel back

04:20:30.587 --> 04:20:36.807
 the onion of PWAs and the way 
that we build progressive web 

04:20:36.808 --> 04:20:38.898
applications and the way that 
tools can help us do that.  I'm 

04:20:38.899 --> 04:20:40.987
going through this in basically 
four parts.

04:20:40.988 --> 04:20:43.065
First, I'm going it start off 
with an introduction to the 

04:20:43.066 --> 04:20:49.294
state of progressive web apps as
 they are today.  Then dive into

04:20:49.295 --> 04:20:53.473
 some of the goals of the tools.
  Why do we build them?  What 

04:20:53.474 --> 04:20:57.638
are the philosophies.  And then 
single page applications and the

04:20:57.639 --> 04:20:59.719
 libraries and frameworks that 
exist today to use these things.

04:20:59.720 --> 04:21:03.888
  And then we'll end with some 
best practices that you can take

04:21:03.889 --> 04:21:10.130
 back as you start  adopting 
these tools and look at adding 

04:21:10.131 --> 04:21:12.200
progressive web applications to 
your workflow.  So let's start 

04:21:12.201 --> 04:21:16.350
by looking at the state of PWA 
tooling as it is right now in 

04:21:16.351 --> 04:21:20.519
September of 2017.  We're all 
chasing after the perfect 

04:21:20.520 --> 04:21:22.606
progressive we can application, 
but a lot of us come from very 

04:21:22.607 --> 04:21:26.816
different journeys.  Some of us 
already have large applications.

04:21:26.817 --> 04:21:30.975
  Some of us have Greenfield 
projects where we can experiment

04:21:30.976 --> 04:21:37.298
 and try new things.  When we 
talk about the perfect 

04:21:37.299 --> 04:21:39.372
progressive web app, it's three 
things.  Building applications 

04:21:39.373 --> 04:21:43.514
that are fast, reliable and 
engaging.  And when we combine

04:21:43.515 --> 04:21:45.602
this with thinking about the 
tooling that exists for us as 

04:21:45.603 --> 04:21:49.771
developers, we're  looking at 
how do we get the best developer

04:21:49.772 --> 04:21:53.928
 experience for providing our 
users the best experience.  The 

04:21:53.929 --> 04:22:00.179
best DX for the best UX.
So what can tooling do to help 

04:22:00.180 --> 04:22:02.268
with these problems?  Well, 
whether we talk about our users,

04:22:02.269 --> 04:22:06.409
 their time is very, very 
important.  As we have heard 

04:22:06.410 --> 04:22:08.476
many times throughout the 
conference, even seconds or 

04:22:08.477 --> 04:22:10.557
milliseconds of time that you 
make your users wait for your 

04:22:10.558 --> 04:22:14.711
application or pieces of 
functionality can cost your 

04:22:14.712 --> 04:22:20.981
business money.  You can lose 
your conversions every time.  We

04:22:23.057 --> 04:22:25.131
 also talk about bandwidth.  In 
many cases and in many user 

04:22:25.132 --> 04:22:29.274
environments, the amount of 
bandwidth that your application 

04:22:29.275 --> 04:22:31.349
takes is a direct decision 
factor in terms of whether or 

04:22:31.350 --> 04:22:35.499
not they're going to use your 
product or service.  

04:22:35.500 --> 04:22:37.582
Additionally, tools can do some 
very interesting things.  By 

04:22:37.583 --> 04:22:39.685
giving a tool an understanding 
of the browsers that you're 

04:22:39.686 --> 04:22:41.759
looking to target, and by 
combining that with an 

04:22:41.760 --> 04:22:45.928
understanding of what tool or 
browser the user is using to 

04:22:45.929 --> 04:22:48.003
access your application, we can 
send down just the right code at

04:22:50.081 --> 04:22:52.160
 the right time.
Additionally, push notifications

04:22:52.161 --> 04:22:56.318
 are a really great way of 
building engagement with PWAs.  

04:22:56.319 --> 04:22:58.389
And tooling can help us 
understand these things a little

04:22:58.390 --> 04:23:02.539
 bit better.  As developers, a 
lot of the time we're writing 

04:23:02.540 --> 04:23:06.699
code and maintaining code.  And 
so using  PWAs to generate code 

04:23:06.700 --> 04:23:10.869
for us -- or using tools to 
generate code for PWAs -- can be

04:23:12.936 --> 04:23:15.008
 a huge impact for our lives.  
And lastly, tools really focus 

04:23:15.009 --> 04:23:19.159
on  allowing us to take 
advantage of best practices by 

04:23:19.160 --> 04:23:23.312
giving a deep understanding, 
using tools like  Lighthouse 

04:23:23.313 --> 04:23:27.468
that expose froms across the 
visit best practices collected 

04:23:27.469 --> 04:23:31.637
by the Chrome team.
Some of the technology behind 

04:23:31.638 --> 04:23:35.796
PWAs include the manifest which 
we'll talk a little bit about, 

04:23:35.797 --> 04:23:39.951
the service worker -- which I'll
 talk a lot about -- but it 

04:23:39.952 --> 04:23:42.017
comes down to you building great
 applications.  Tools can only 

04:23:42.018 --> 04:23:46.176
do so much to take advantage of 
the latest and greatest 

04:23:46.177 --> 04:23:52.389
capabilities was browser.  You 
still need to be thinking about 

04:23:52.390 --> 04:23:54.469
your use cases and worrying 
about your users.  So let's talk

04:23:54.470 --> 04:23:58.624
 about the web application 
manifest.  It's designed to let 

04:23:58.625 --> 04:24:02.768
browsers and the web at large 
know about your application.  

04:24:02.769 --> 04:24:06.917
We're really trying to elevate 
the code from a single page 

04:24:06.918 --> 04:24:11.103
that's served at a single time, 
or a set of JavaScript and HTML 

04:24:11.104 --> 04:24:13.172
into the concept of a collective
 application that we know 

04:24:13.173 --> 04:24:17.316
something about.  It has themes,
 it's got icons.  It's got a 

04:24:17.317 --> 04:24:21.484
starting place.  We can tell the
 browser or the device how it 

04:24:21.485 --> 04:24:23.554
should be accessing the site and
 how it should be presenting to 

04:24:23.555 --> 04:24:27.689
the user.  Some tools can do 
things like default generation. 

04:24:27.690 --> 04:24:29.761
 They can give us a manifest 
that we can then easily

04:24:29.762 --> 04:24:33.912
configure.  Other tools will 
actually guide you through the 

04:24:33.913 --> 04:24:35.991
entire process of making 
decisions.

04:24:35.992 --> 04:24:42.198
Service workers are the 
underlying API in browsers that 

04:24:42.199 --> 04:24:46.351
give us these modern super 
powers for building progressive 

04:24:46.352 --> 04:24:50.513
web applications.  By adding a 
service worker to my app, I can 

04:24:50.514 --> 04:24:56.767
do a lot of cool things.  I can 
proxy and intersect all the HTTP

04:24:56.768 --> 04:25:00.935
 requests.  I can decide if I 
want to be serving from the 

04:25:00.936 --> 04:25:03.022
Internet, a local cache, or 
general content stored in the 

04:25:03.023 --> 04:25:09.260
service worker.  But service 
wokers have a relatively long 

04:25:09.261 --> 04:25:13.407
life cycle, and caching can be 
done at any of the stages.  If 

04:25:13.408 --> 04:25:17.595
the user first visits the page 
and we're rendering, after the 

04:25:17.596 --> 04:25:19.674
service worker is installed and 
we're given a chance to actually

04:25:19.675 --> 04:25:25.912
 go and cache these things.  Or 
even later, maybe when a user is

04:25:25.913 --> 04:25:30.057
 visiting a page for a second or
 third time.  We can make these 

04:25:30.058 --> 04:25:32.148
 distinctions at each of the 
points of the life  cycle, but 

04:25:32.149 --> 04:25:34.149
tools

04:25:36.218 --> 04:25:40.360
 can help us make decisions.  
Now file caching.  Hey, as a 

04:25:40.361 --> 04:25:44.494
developer, I want to cache all 
the assets from the application 

04:25:44.495 --> 04:25:46.828
as part of the installation 
process

04:25:44.495 --> 04:25:47.352
because it's so important to my 
app.

04:25:47.353 --> 04:25:51.526
Or maybe I see caching as a nice
 to have for the application and

04:25:51.527 --> 04:25:55.683
 I want to install after the 
application has installed by 

04:25:55.684 --> 04:25:57.756
service worker.  This can be 
helpful by taking some of the 

04:25:57.757 --> 04:26:01.924
work that's being done by the 
browser out of the critical path

04:26:01.925 --> 04:26:06.077
 for rendering, giving users a 
great experience.  And run-time 

04:26:06.078 --> 04:26:10.219
caching.  We don't always know 
all of the data our application 

04:26:10.220 --> 04:26:14.393
is going to need when we write 
it.  A lot of the data is coming

04:26:14.394 --> 04:26:18.542
 from servers and backends.  And
 you could say, hey, I want to 

04:26:18.543 --> 04:26:22.730
cache these things so if the 
user is going offline, they can 

04:26:22.731 --> 04:26:24.803
access all of the content they 
have previously seen.  Finally, 

04:26:24.804 --> 04:26:28.957
there's also advanced caching 
strategies.  Because by 

04:26:28.958 --> 04:26:31.019
combining our knowledge of our 
applications with our tools 

04:26:31.020 --> 04:26:35.191
knowledge of the user, we can 
actually do far more advanced 

04:26:35.192 --> 04:26:39.333
things that really drive great 
user experiences.

04:26:39.334 --> 04:26:43.493
Another technology that we 
really want our  tools to help 

04:26:43.494 --> 04:26:47.629
us with is push notifications.  
As developers, there's a lot of 

04:26:47.630 --> 04:26:51.776
work that can be done if we want
 to take advantage of it.  And 

04:26:51.777 --> 04:26:53.864
there's best practices that the 
browsers are leaning  towards.  

04:26:53.865 --> 04:26:55.935
One of these best practices is 
we want different behaviors for 

04:26:55.936 --> 04:27:02.152
push notifications whether we're
 using the application actively 

04:27:02.153 --> 04:27:04.224
on the device or whether the 
service worker is being woken up

04:27:04.225 --> 04:27:08.376
 behind the scenes, when the 
user is not interacting with the

04:27:08.377 --> 04:27:10.447
 device.  When the user is not 
interacting with the device, we 

04:27:10.448 --> 04:27:14.625
want to show a notification.  
But when they're live and 

04:27:14.626 --> 04:27:18.771
engaging.  These sorts of best 
practices can be baked in via 

04:27:18.772 --> 04:27:20.838
tooling.  Another thing that I 
care a lot about is code 

04:27:20.839 --> 04:27:24.981
generation.  Where we want to 
giveout code that's going to 

04:27:24.982 --> 04:27:29.157
help you get the work done 
faster.  Good tools that do good

04:27:29.158 --> 04:27:33.326
 code generation are going to be
 fast by  default, great by 

04:27:33.327 --> 04:27:35.411
default and they can do things 
like help you with your build 

04:27:35.412 --> 04:27:39.562
pipeline.
So help you write code and ship 

04:27:39.563 --> 04:27:41.647
that great code to your users 
with all of the sorts of metrics

04:27:41.648 --> 04:27:43.721
 and things that you need to 
understand how your users are 

04:27:43.722 --> 04:27:45.803
going to consume your 
applications.

04:27:47.878 --> 04:27:52.040
I see code generation as a very 
interesting idea.  Because it 

04:27:52.041 --> 04:27:56.207
combines this idea to give a 
developer a great experience by 

04:27:56.208 --> 04:27:58.278
default without eliminating any 
of their flexibility or control 

04:27:58.279 --> 04:28:02.432
of what they actually ship to 
users.  So when we talk about 

04:28:02.433 --> 04:28:04.504
PWAs, there's a few different 
ways that Sam talked about 

04:28:04.505 --> 04:28:10.739
yesterday in terms of building 
them and adding to the existing 

04:28:10.740 --> 04:28:14.891
workflow.  Maybe write a new app
 from scratch, taking advantage 

04:28:14.892 --> 04:28:19.043
of PWAs.  Maybe I'm going to 
rewrite one feature of the 

04:28:19.044 --> 04:28:21.113
application and take advantage 
of PWAs fully.  Or maybe I want 

04:28:21.114 --> 04:28:25.868
to look at it a little bit 
differently and add one PWA 

04:28:25.869 --> 04:28:27.943
feature to my entire 
application.  Things are a 

04:28:27.944 --> 04:28:30.029
little bit simpler when we talk 
about both the generic tools and

04:28:30.030 --> 04:28:32.119
 the framework and 
library-specific tools.  Because

04:28:34.185 --> 04:28:36.271
 typically, as a developer, I'm 
targeting that library or 

04:28:36.272 --> 04:28:38.358
framework for my entire 
application.  And because of 

04:28:38.359 --> 04:28:42.525
this, it's much easier for us to
 take the best of PWA and apply 

04:28:42.526 --> 04:28:46.688
it holistically to my 
application all at one

04:28:46.689 --> 04:28:50.854
time.  But it's still possible 
to take advantage of some of 

04:28:50.855 --> 04:28:55.039
these tools and build a fully 
custom service worker or PWA 

04:28:55.040 --> 04:28:57.111
implementation that follows my 
business needs and the needs of 

04:28:57.112 --> 04:28:59.187
my users.
One of the really fantastic 

04:28:59.188 --> 04:29:03.338
tools is Chrome.  And the 
developer tools that we have 

04:29:03.339 --> 04:29:05.415
been building into them.  I'm 
going to come back to this a 

04:29:05.416 --> 04:29:07.500
couple times.  Because the 
application tab in the developer

04:29:09.571 --> 04:29:11.638
 tools is one of your best 
assets for understanding what's 

04:29:11.639 --> 04:29:13.713
going on when it comes to 
building a PWA.  It's there that

04:29:15.773 --> 04:29:17.854
 you can bypass the service 
worker for network calls so that

04:29:17.855 --> 04:29:19.933
 you make sure you're  getting 
the most fresh data.  You can 

04:29:19.934 --> 04:29:24.087
understand the life cycle.  Is 
there a service worker that's  

04:29:24.088 --> 04:29:26.151
pending install?  One that's 
already been installed in what's

04:29:26.152 --> 04:29:30.282
 the state of my cache?  Can I 
look and see what has been 

04:29:30.283 --> 04:29:36.516
cached and what the status is?  
And the Chrome developer tools 

04:29:36.517 --> 04:29:38.583
are awesome because we baked in 
some of the best practices such 

04:29:38.584 --> 04:29:42.743
as  Lighthouse.  Now, using 
Lighthouse, I can figure  out, 

04:29:42.744 --> 04:29:46.912
am I building a great 
progressive web application?  Is

04:29:46.913 --> 04:29:51.072
 my application doing well on 
performance?  Can I broaden any 

04:29:51.073 --> 04:29:53.145
audience by taking advantage of 
more accessibility best

04:29:53.146 --> 04:29:57.298
practices?  And overall, what 
are the best practices that we 

04:29:57.299 --> 04:29:59.378
have discovered across the 
ecosystem that I could be  

04:29:59.379 --> 04:30:03.527
taking advantage of in my app?
So we have a few generic tools. 

04:30:03.528 --> 04:30:07.715
 These are  tools that can be 
used for any web application 

04:30:07.716 --> 04:30:09.800
that exists today.  And one of 
the best for doing this is 

04:30:09.801 --> 04:30:13.958
called Workbox.  This is a 
project from the Chrome team 

04:30:13.959 --> 04:30:16.027
that takes the best of what 
we've got in terms of our 

04:30:16.028 --> 04:30:18.100
understanding of the use cases 
and the needs of developers and 

04:30:18.101 --> 04:30:24.340
packages that in a very easy to 
use library.  Workbox is 

04:30:24.341 --> 04:30:28.503
fantastic in the way that it 
embeds offline caching, offline 

04:30:28.504 --> 04:30:32.661
analytics and now APIs coming 
available in browsers such as 

04:30:32.662 --> 04:30:36.834
background sync.  Background 
sync is an important concept.  

04:30:36.835 --> 04:30:41.013
It allows us not only to get the
 freshest data when users are 

04:30:41.014 --> 04:30:43.092
interacting with the 
application, but we can do it 

04:30:43.093 --> 04:30:47.255
behind the scenes.  The moment 
the user accesses the 

04:30:47.256 --> 04:30:51.405
information -- even in offline 
mode -- we can give the freshest

04:30:51.406 --> 04:30:57.601
 data they expect.
I love Webpack.  There's a lot 

04:30:57.602 --> 04:31:01.725
of tools with PWA attributes.  
One of these is offline plugin 

04:31:01.726 --> 04:31:07.978
for Webpack.  Offline plugin 
focuses on the file impact of 

04:31:07.979 --> 04:31:12.143
service worker and PWAs.  You 
can do ahead of time caching, 

04:31:12.144 --> 04:31:16.308
give me the files up front.  
Deferred caching -- get the 

04:31:16.309 --> 04:31:22.537
files later.  Or make the files 
optional and base on user 

04:31:22.538 --> 04:31:24.638
behavior to cache the  files at 
the right times in the right way

04:31:26.703 --> 04:31:28.782
.
Another fantastic project to 

04:31:28.783 --> 04:31:30.848
look at with PWA is from 
Pinterest.  It's on their GitHub

04:31:32.930 --> 04:31:39.175
.   Pinterest/service worker.  
These are a collection of 

04:31:39.176 --> 04:31:41.241
utilitieses for creating and 
testing service worker.  Not 

04:31:41.242 --> 04:31:45.393
only code tools that give you a 
service worker under the hood 

04:31:45.394 --> 04:31:47.472
that helps you move faster as a 
developer, but they have done 

04:31:47.473 --> 04:31:49.561
something interesting.  They 
have built out a mock 

04:31:49.562 --> 04:31:53.730
environment generator that 
allows you to do testing of your

04:31:53.731 --> 04:31:59.949
 service  worker.  And this has 
historically been a little bit 

04:31:59.950 --> 04:32:02.023
of a problem because newness of 
the APIs.  And sometimes the 

04:32:02.024 --> 04:32:06.180
browser is ignoring the backend 
 entirely.  So mocking out these

04:32:06.181 --> 04:32:10.328
 and testing them can be very 
important for ensuring that we 

04:32:10.329 --> 04:32:12.398
have fantastic user experiences.
Another tool that you should be 

04:32:12.399 --> 04:32:16.568
aware of that you're going to 
see all over the place is a set 

04:32:16.569 --> 04:32:24.834
of tools called sw-precash and 
sw-toolbooks.  These were 

04:32:24.835 --> 04:32:26.910
utilities for building service 
workers.  They have the same 

04:32:26.911 --> 04:32:33.181
goals and values as Workbox, but
 less modular and extensible.  

04:32:33.182 --> 04:32:39.421
The team wanted to collect the 
tools and reflect on the best 

04:32:39.422 --> 04:32:41.494
practices we have learned and 
bake those into the new tools.  

04:32:41.495 --> 04:32:49.833
So  sw-precache and sw-toolbox 
have for the most part been

04:32:51.897 --> 04:32:56.031
 we placed by Workbox.  But sw
-precache is still a fantastic 

04:32:56.032 --> 04:33:02.247
tool for building PWAs.  Another
 tool to have in your tool mitt 

04:33:02.248 --> 04:33:08.484
hit is HackerNews PWA.  Or  
HNPWA.com.  This is a Website 

04:33:08.485 --> 04:33:10.602
where we're collecting the best 
practices across a number of 

04:33:10.603 --> 04:33:14.748
tools,  libraries and frameworks
 for building progressive web 

04:33:14.749 --> 04:33:18.930
applications.  For each 
submission we track both the 

04:33:18.931 --> 04:33:23.096
speed as well as some of the 
capabilities of it.  There's 

04:33:23.097 --> 04:33:25.161
tools from projects like React, 
Firebase, and Angular.  There's 

04:33:25.162 --> 04:33:31.378
more than 20 implementations of 
the hacker

04:33:31.379 --> 04:33:35.533
news client and tried to show 
off the PWA capabilities in a 

04:33:35.534 --> 04:33:37.618
way that's open-source and you 
can take advantage of and learn 

04:33:37.619 --> 04:33:41.788
from as a developer.
So now let's get into a little 

04:33:41.789 --> 04:33:43.865
bit about the goals and the 
philosophy behind these tools.  

04:33:43.866 --> 04:33:48.026
I like to think that technology 
tools are really about 

04:33:48.027 --> 04:33:50.118
simplifying the mental model in 
a good way.  It's very easy to 

04:33:50.119 --> 04:33:54.293
do this wrong.  Because what 
we're doing under the hood is 

04:33:54.294 --> 04:33:58.452
we're minding new abstractions 
for concepts that have existed 

04:33:58.453 --> 04:34:00.514
before in lower levels, but we, 
as developers, can't hold all of

04:34:00.515 --> 04:34:06.746
 the complexity in our heads at 
one time.  We have to focus on 

04:34:06.747 --> 04:34:10.908
smaller subsets in the tasks we 
are trying to accomplish.  And 

04:34:10.909 --> 04:34:15.078
tools are fantastic at taking an
 abstraction and saying, here is

04:34:15.079 --> 04:34:19.252
 the thing that I can help you 
with.  Additionally, tools can 

04:34:19.253 --> 04:34:21.333
help with edge cases.  And 
finally, tools can help you save

04:34:21.334 --> 04:34:25.514
 time.  Let's dig into these a 
little bit more.

04:34:25.515 --> 04:34:29.670
So when we simplify mental 
models, this is something that 

04:34:29.671 --> 04:34:31.752
we often have to do.  One of the
 common programming jokes, 

04:34:31.753 --> 04:34:38.002
there's two unsolved problems in
 computer science, naming things

04:34:38.003 --> 04:34:40.098
 and caching validation.  
Caching is a very, very hard 

04:34:40.099 --> 04:34:44.276
topic.  So if we focus via tools
 more on use cases than 

04:34:44.277 --> 04:34:46.361
underlying implementation, the 
tools can help us with that to a

04:34:48.437 --> 04:34:50.516
 huge degree.  The service 
worker life cycle I find to be a

04:34:50.517 --> 04:34:54.693
 little bit difficult.  So, 
again, focusing on use cases, 

04:34:54.694 --> 04:35:00.908
the tools can help with that.  
The last is an interesting 

04:35:00.909 --> 04:35:03.022
conversation that I have with 
developers.  Does web 

04:35:03.023 --> 04:35:09.240
development feel like I'm used 
to?  We're mapping few concepts 

04:35:09.241 --> 04:35:13.405
into concepts that came 
previously as developers.  I 

04:35:13.406 --> 04:35:15.479
talk to developers that are 
stuck in the web development 

04:35:15.480 --> 04:35:17.560
from five or six years ago 
because they haven't been able 

04:35:17.561 --> 04:35:21.728
to take advantage of the newer 
capabilities and the new APIs in

04:35:21.729 --> 04:35:25.869
 the browser.  So good tooling 
should be teaching you the 

04:35:25.870 --> 04:35:27.945
mental  models and guiding you 
into the new

04:35:27.946 --> 04:35:32.119
world while still empowering you
 to be effective from day one.

04:35:32.120 --> 04:35:38.362
There's also a lot of edge cases
 that end up coming up that you 

04:35:38.363 --> 04:35:42.548
might not expect when you start 
using progressive web apps or 

04:35:42.549 --> 04:35:46.695
service workers.  A lot of us 
talked about intermittent 

04:35:46.696 --> 04:35:50.842
connectivity and use cases.  
What if your app loses 

04:35:50.843 --> 04:35:54.974
connectivity during the service 
worker install?  An 

04:35:54.975 --> 04:35:59.130
implementation might fail out 
and say I can't use the assets. 

04:35:59.131 --> 04:36:01.202
 Let's uninstall, throw away 
what we've got and try again on 

04:36:01.203 --> 04:36:05.549
the next load.  But you can do 
something different.  Some of 

04:36:05.550 --> 04:36:07.637
the tools will allow you, for 
example, keep some of the cache 

04:36:07.638 --> 04:36:11.776
files through validation.  
They're using checks to know 

04:36:11.777 --> 04:36:13.861
that they've got the files and 
understand the integrity of 

04:36:13.862 --> 04:36:20.151
those files.  We have talked 
about a lot of offline use 

04:36:20.152 --> 04:36:24.311
cases, but there's online use 
cases.  What in your user has 

04:36:24.312 --> 04:36:28.494
full connectivity.  What I 
believe is an antipattern, the 

04:36:28.495 --> 04:36:32.646
box that says the object is 
updated, click to refresh.  This

04:36:32.647 --> 04:36:36.804
 wasn't on the web because 
applications were always fresh. 

04:36:36.805 --> 04:36:38.874
 Now in the modern web, because 
we have the

04:36:38.875 --> 04:36:43.045
new capabilities, we have 
introduced that if I update my 

04:36:43.046 --> 04:36:47.191
application every day, perhaps 
with a continuous integration 

04:36:47.192 --> 04:36:49.845
system, I don't want my user to 
be constantly assaulted with 

04:36:49.846 --> 04:36:51.921
this click to refresh just so 
they're getting the freshest 

04:36:51.922 --> 04:36:56.068
content of my app.
We also build applications now 

04:36:56.069 --> 04:37:00.211
in much larger environments.  
Many times, you may be building 

04:37:00.212 --> 04:37:02.302
the frontend of an application, 
but you have no control over the

04:37:02.303 --> 04:37:06.462
 backend of an application.  And
 so as y looking at adopting 

04:37:06.463 --> 04:37:10.623
things like service worker, you 
may want to be caching files.  

04:37:10.624 --> 04:37:14.765
But maybe the cache headers 
coming back from your API aren't

04:37:14.766 --> 04:37:16.841
 what you expect or need to 
build out the frontend.  So you 

04:37:16.842 --> 04:37:21.009
can look at things like tools to
 say, hey, maybe I need to 

04:37:21.010 --> 04:37:27.249
override the cache or ignore 
them and supply a different 

04:37:27.250 --> 04:37:29.316
policy that supports my frontend
 in a way that my backend can't.

04:37:31.390 --> 04:37:33.474
  And finally, we talk about 
saving time.  As developers, we 

04:37:33.475 --> 04:37:37.636
write a lot of code.  But we 
also have projects that have a 

04:37:37.637 --> 04:37:41.802
lot of DevOps.  It's not as easy
 adds writing code anymore.  How

04:37:41.803 --> 04:37:45.982
 am I going to write this?  
Build this and combine with what

04:37:45.983 --> 04:37:52.216
 other developers are doing and 
ship to the user?  Finding the 

04:37:52.217 --> 04:37:54.300
right abstractions and tools at 
each of these stages is very 

04:37:54.301 --> 04:37:56.387
important.
So now let's get into the world 

04:37:56.388 --> 04:38:00.566
of single page applications.  So
 libraries, frameworks and  

04:38:00.567 --> 04:38:04.698
platforms, oh, my.  So I'm going
 to go through these five 

04:38:04.699 --> 04:38:08.852
specific tools.  I apologize to 
anyone not on the list, there 

04:38:08.853 --> 04:38:13.006
are more tools than I can count 
and more frameworks than I can 

04:38:13.007 --> 04:38:15.068
go over in the limited time we 
have.

04:38:15.069 --> 04:38:19.197
But each of these share a number
 of things.  So each of these 

04:38:19.198 --> 04:38:23.347
tools use some sort of CLI in 
order to empower developers to 

04:38:23.348 --> 04:38:25.424
be more effective more  quickly.
  So let's go into each of these

04:38:27.503 --> 04:38:31.646
.  So in the React world, we 
have create-react-app which is a

04:38:31.647 --> 04:38:35.808
 fantastic CLI.  If you're using
 this CLI, you'll see it creates

04:38:35.809 --> 04:38:39.960
 a service worker and manifest 
by default.  It has a cache-

04:38:42.042 --> 04:38:44.118
first strategy under the hood so
 you get the are fastest 

04:38:44.119 --> 04:38:46.178
experience possible.  So for all
 of these examples, I'm going to

04:38:48.278 --> 04:38:55.346
 use Yarn.  You could use NPM or
 any package management tool to 

04:38:55.347 --> 04:38:57.347
fetch from the repository.  But 
installing

04:38:58.376 --> 04:39:02.532
 is Yarn global add.  You 
install create-react-app.  I'm 

04:39:02.533 --> 04:39:04.639
going to run it and give a it a 
project name.  Then see the end 

04:39:04.640 --> 04:39:08.798
of the folder and run a build 
command.  What this will give e 

04:39:08.799 --> 04:39:12.977
get me is a basic hello world, 
welcome to React application 

04:39:12.978 --> 04:39:17.146
that is awesome in terms of 
develop straiting how we get 

04:39:17.147 --> 04:39:19.240
started quickly and give 
developers the freedom and 

04:39:19.241 --> 04:39:21.298
flexibility to get into their 
application

04:39:21.299 --> 04:39:23.385
and start adding  functionality 
right away.

04:39:23.386 --> 04:39:27.546
And one thing that is beautiful 
to see, the moment you see that 

04:39:27.547 --> 04:39:29.620
application in your web browser,
 a service worker has been 

04:39:29.621 --> 04:39:33.770
installed and loaded.  So it is 
a PWA out of the box in a very 

04:39:33.771 --> 04:39:40.026
fantastic way.  Let's now talk a
 little bit about the Preact 

04:39:40.027 --> 04:39:44.165
project and CLI.  This goes a 
little bit further in terms of 

04:39:44.166 --> 04:39:48.322
helping developers take 
advantage of the modern web.  It

04:39:48.323 --> 04:39:54.575
 has the standard app correction
 but will also create an app 

04:39:54.576 --> 04:39:58.717
shell for your index.HTML.  It 
can make sure it's pre-rendered 

04:39:58.718 --> 04:40:00.798
as HTML and you can ship down to
 the browser

04:40:03.841 --> 04:40:05.915
 to increase perceived 
performance, an important 

04:40:05.916 --> 04:40:10.047
metric.  It's also  browserware,
 so if you tell it what browsers

04:40:10.048 --> 04:40:14.205
 to target, it can add the 
appropriate prefixes.  One thing

04:40:14.206 --> 04:40:20.439
 that's fantastic about the 
preact CLI, they have 

04:40:20.440 --> 04:40:24.633
preconfigured for Firebase and 
Server Push.  Combining its 

04:40:24.634 --> 04:40:26.706
knowledge with your application 
and the best practices across 

04:40:26.707 --> 04:40:28.802
the web in had terms of which 
files should be pushed down to 

04:40:28.803 --> 04:40:32.968
the browser and those waited for
 or requested

04:40:32.969 --> 04:40:37.122
when needed by the user.  And 
baking that into the Firebase 

04:40:37.123 --> 04:40:41.258
Hosting configuration.  All of 
the CLI  is using XW precache 

04:40:41.259 --> 04:40:45.432
under the hood today.  Just like
 before, I'm going to add the 

04:40:45.433 --> 04:40:51.647
preact-cli and run preact create
 and see the folder and run the 

04:40:51.648 --> 04:40:53.729
build.  Here, out of the box, 
we're going to get a beautiful 

04:40:53.730 --> 04:40:57.872
material-designed style app.  
Hello world.  And one of the 

04:40:57.873 --> 04:40:59.970
cool things about this 
application is that it includes 

04:40:59.971 --> 04:41:04.148
routing by default so you can 
see one of these very common 

04:41:04.149 --> 04:41:06.243
patterns and get started more 
quickly.

04:41:06.244 --> 04:41:10.412
Next, I want to talk about 
Polymer and the Polymer CLI.  

04:41:10.413 --> 04:41:14.548
Polymer does things differently.
  So while they have the 

04:41:14.549 --> 04:41:16.623
manifest generation and the 
optional service worker, they 

04:41:16.624 --> 04:41:18.717
actually do a set of 
distributions for you.  And this

04:41:18.718 --> 04:41:22.853
 is something that's unique to 
how they built their CLI.  When 

04:41:22.854 --> 04:41:27.015
you run a build, you won't get a
 single set of JavaScript that 

04:41:27.016 --> 04:41:29.113
you ship down to the browser.  
They're going to give three 

04:41:29.114 --> 04:41:35.337
options.  An ES5 bundled version
 that will work in any browser. 

04:41:35.338 --> 04:41:43.670
 And also an ES6 or ES2015 
version that's smaller and more 

04:41:43.671 --> 04:41:45.742
performant if the browsers have 
optimized for ES2015.  Most 

04:41:45.743 --> 04:41:52.030
have.  And then an unbundled 
code.  And they're helping you 

04:41:52.031 --> 04:41:54.114
take advantage of the latest and
 greatest from the browsers and 

04:41:54.115 --> 04:41:56.180
leaving behind some of the 
legacy that

04:42:00.254 --> 04:42:02.335
 we had to support with ES5 in 
the past.  One thing that's nice

04:42:02.336 --> 04:42:08.550
 about the Polymer CLI, they 
have PRPL defaults.  They 

04:42:08.551 --> 04:42:12.685
believe in the great injuries 
experiences.  I'm going to 

04:42:12.686 --> 04:42:16.841
install the polymer-cli.  And 
run it and run Polymer in

04:42:16.842 --> 04:42:23.056
it.  It's going to give me a set
 of choices of which starter 

04:42:23.057 --> 04:42:25.117
kit.  There's several options, 
and this one here out of the 

04:42:25.118 --> 04:42:29.342
box, polymer-2-starter-kit.  And
 as soon as I set up the 

04:42:29.343 --> 04:42:33.516
projects, I can run Polymer 
build.  I'm going to get 

04:42:33.517 --> 04:42:35.589
routeing and material design 
styling that out of the box gets

04:42:37.661 --> 04:42:39.748
 me started much quicker.
And as we like to see, it's a 

04:42:39.749 --> 04:42:43.886
service worker out of the box.  
Next, I'm going to talk a little

04:42:43.887 --> 04:42:48.033
 bit about view.  So there's two
 projects at play here.  There's

04:42:48.034 --> 04:42:56.336
 the Vue CLE as well as the  
Vuejs-templates for PWA.  It 

04:42:56.337 --> 04:42:58.406
handles manifest and service 
worker and app shell generation.

04:42:58.407 --> 04:43:02.556
  And one of the nice things 
about the Vue CLI, is 

04:43:02.557 --> 04:43:06.692
intelligently loads the bits of 
your application as needed.  So 

04:43:06.693 --> 04:43:10.842
if you have lazy-loaded routes, 
which chunks, based on a user 

04:43:10.843 --> 04:43:15.032
request, with need to load right
 away and which are asynchronous

04:43:15.033 --> 04:43:19.188
 and deferred to later.  Using 
the new CLI  is straightforward.

04:43:19.189 --> 04:43:25.393
  Install the CLI and run 
vulnerabilities, and choose the 

04:43:25.394 --> 04:43:29.551
template and the project name.  
The Vue CLI  is fantastic in a 

04:43:29.552 --> 04:43:33.693
guided setup.  It's going to be 
asking you questions about the 

04:43:33.694 --> 04:43:37.838
application and how you want to 
serve  users.  And as you're 

04:43:37.839 --> 04:43:39.927
going, teach you the different 
decisions you have to make as a 

04:43:39.928 --> 04:43:42.004
developer.  Then I'm going to 
install the dependencies and run

04:43:44.074 --> 04:43:46.139
 a build command.  Out of the
box, we have a helpful  

04:43:46.140 --> 04:43:50.289
tutorial.  Hey, here's some 
links that will get you started 

04:43:50.290 --> 04:43:52.367
as a Vue developer.  And, again,
 we have the beautiful service 

04:43:52.368 --> 04:43:56.518
worker.
Lastly, I'm going to talk a 

04:43:56.519 --> 04:44:00.689
little bit about Angular CLI.  
The Angular CLI handles app 

04:44:00.690 --> 04:44:04.858
creation and service worker 
generation.  One thing that's a 

04:44:04.859 --> 04:44:08.986
little bit different about the 
Angular CLI, instead of using 

04:44:08.987 --> 04:44:13.128
JavaScript to configure the 
service worker, is has a 

04:44:13.129 --> 04:44:19.333
declarative file, NGSW.  Another
 thing about the Angular 

04:44:19.334 --> 04:44:21.414
implementation and support for 
service workers, they have 

04:44:21.415 --> 04:44:23.473
wrapped push  notifications as a
 service that you can inject 

04:44:23.474 --> 04:44:25.560
into your application in order 
to do things like  registering 

04:44:25.561 --> 04:44:29.700
for push notifications or to 
observe or listen to on 

04:44:29.701 --> 04:44:33.824
observable that gives you the 
publishers that comes from your 

04:44:33.825 --> 04:44:35.900
application or understanding the
 life cycle entitles that are 

04:44:35.901 --> 04:44:37.963
coming from a service worker.
So use PWAs with Angular, you're

04:44:37.964 --> 04:44:46.245
 going to install the @
angular/cli, the

04:44:48.317 --> 04:44:50.384
 ng new.  And flip a flag saying
 I would like a service worker 

04:44:50.385 --> 04:44:54.528
worker, please.  And then when 
you run a production build, 

04:44:54.529 --> 04:44:56.605
you're going to automatically 
get service worker included in 

04:44:56.606 --> 04:45:00.767
the application that's going to 
create the static files 

04:45:00.768 --> 04:45:04.927
generated as part of the Webpack
 build process.  And you can 

04:45:04.928 --> 04:45:07.845
declare those saying these are 
the files to dynamically cache,

04:45:10.852 --> 04:45:12.925
 these are the files you can 
ignore.  So on.  When you 

04:45:12.926 --> 04:45:15.013
generate a project like this, 
it's going to give you a short 

04:45:15.014 --> 04:45:19.161
hello world page that has the 
necessary links to get you 

04:45:19.162 --> 04:45:21.219
further started as an Angular 
developer.  And, again, we have 

04:45:21.220 --> 04:45:25.366
the service worker.  The Angular
 team has decided to ship 

04:45:25.367 --> 04:45:31.596
basically a single service 
worker that is entirely reliant 

04:45:31.597 --> 04:45:37.809
on the configuration file.  It's
 on disk, but you can modify it 

04:45:37.810 --> 04:45:39.867
to your heart's content.  It's 
to show everything that the 

04:45:39.868 --> 04:45:44.012
service worker can do via that 
file so you can configure 

04:45:44.013 --> 04:45:46.136
easily.
There's a few other projects 

04:45:46.137 --> 04:45:48.213
that I want to mention briefly 
in the remaining time we have.  

04:45:48.214 --> 04:45:54.463
There's as, called PWA.rocks.  
There's a PWA builder you can 

04:45:54.464 --> 04:45:58.625
find online.  It's a web-based 
interface for generating 

04:45:58.626 --> 04:46:00.712
manifests.  You'll be able to 
upload images and it will 

04:46:00.713 --> 04:46:04.870
generate the right sizes, 
generate the JSON for you and 

04:46:04.871 --> 04:46:06.980
help you with  questions to 
understand what's going into the

04:46:09.046 --> 04:46:11.129
 web manifest.  And then ask you
 how do you want to generate a 

04:46:11.130 --> 04:46:15.273
service worker?  It will ask 
based on the use case.  For 

04:46:15.274 --> 04:46:21.508
example, are you trying to cache
 thes as sets so it works 

04:46:21.509 --> 04:46:25.663
offline?  Or more dynamic, we 
just cache what the application 

04:46:25.664 --> 04:46:31.876
uses, so as a user touches 
things, it can be accessed 

04:46:31.877 --> 04:46:38.094
offline.  And there's a set of 
tools, ng-PWA

04:46:38.095 --> 04:46:42.248
Tools that let you take 
advantage of server side 

04:46:42.249 --> 04:46:44.331
rendering.
And lastly, best practices for 

04:46:44.332 --> 04:46:46.406
building and debugging these 
things.  Remember, remember, 

04:46:46.407 --> 04:46:48.490
remember to check the 
applications tab.  I have heard 

04:46:48.491 --> 04:46:52.638
stories of developers restarting
 their browsers, uninstalling 

04:46:52.639 --> 04:46:56.797
Chrome, reformatting their 
machines because they can't 

04:46:56.798 --> 04:47:00.960
understand why their application
 isn't refreshing.  Service 

04:47:00.961 --> 04:47:07.190
workers are a powerful API, but 
favoring performance over  

04:47:07.191 --> 04:47:13.452
freshness, it can break the 
refresh cycle.  Rob Dodson --

04:47:17.528 --> 04:47:19.599
 bitly -- and another 
recommendation in terms of best 

04:47:19.600 --> 04:47:21.662
practices, make sure you're 
following the tools.  Tools are 

04:47:21.663 --> 04:47:25.819
useful because they provide 
abstractions.  But if those are 

04:47:25.820 --> 04:47:29.980
the wrong abstractions, you can 
spend more time fighting the 

04:47:29.981 --> 04:47:32.061
tools because you're going 
against their intention.  

04:47:32.062 --> 04:47:36.204
Whenever you adopt a new tool, 
try to understand what the tool 

04:47:36.205 --> 04:47:38.288
is trying to do.  Try to 
understand the pieces of the 

04:47:38.289 --> 04:47:42.433
workflow that it's trying to 
automate.  You're going to have 

04:47:42.434 --> 04:47:44.515
a much better time if you're 
using tools the way they intend,

04:47:44.516 --> 04:47:48.690
 so as you continually
evolving with they don't 

04:47:48.691 --> 04:47:52.917
continually break you.  While 
the Chrome tools are fantastic, 

04:47:52.918 --> 04:47:55.024
I would recommend you don't rely
 on them as the only way that 

04:47:55.025 --> 04:47:59.168
you debug and build your 
applications.  Throttling is one

04:47:59.169 --> 04:48:01.239
 of the cool features where I 
can say, hey, give me an 

04:48:01.240 --> 04:48:05.384
emulated 3G connection or an 
offline connection.  But they 

04:48:05.385 --> 04:48:09.513
aren't enough and won't create 
all the scenarios that users are

04:48:09.514 --> 04:48:13.667
 on the bus or on a plane, for 
example.  It's important to note

04:48:15.744 --> 04:48:19.892
 that as of today -- I believe 
this is true -- the offline 

04:48:19.893 --> 04:48:24.075
check box doesn't affect web 
sockets.  If you're building an 

04:48:24.076 --> 04:48:28.206
application with Firebase, for 
example, pulling down the data 

04:48:28.207 --> 04:48:32.371
via the web sockets.  It will 
not test the service worker with

04:48:32.372 --> 04:48:34.437
 the data because the data might
 come back when you expect it 

04:48:34.438 --> 04:48:36.551
not to.
One of the other cool techniques

04:48:38.630 --> 04:48:40.691
 that's just being developed 
right now is the idea of having 

04:48:40.692 --> 04:48:44.854
 end-to-end tests for your 
service worker.  It's possible 

04:48:44.855 --> 04:48:46.923
and important to think about how
 we understand the state of our 

04:48:46.924 --> 04:48:51.076
service worker as we're building
 applications.  There's two 

04:48:51.077 --> 04:48:53.146
projects to check out.  The 
first is the Pinterest project 

04:48:53.147 --> 04:48:57.289
that I talked about where 
they're mocking out the 

04:48:57.290 --> 04:49:01.441
environments.  You can do things
 in a more hermetic way.  And 

04:49:01.442 --> 04:49:05.582
they're building out a PWA 
harness where we can use the 

04:49:05.583 --> 04:49:09.723
standard end-to-end tools and 
using browser implementation 

04:49:09.724 --> 04:49:15.951
with the debugging mode, and 
check and verify and change the 

04:49:15.952 --> 04:49:18.032
service worker status in the way
 that the user could be doing.

04:49:18.033 --> 04:49:20.101
The lest recommendation I have 
is really make sure that you're 

04:49:20.102 --> 04:49:24.294
staying up to date.  Service  
workers are a fantastic API that

04:49:24.295 --> 04:49:28.461
 are on millions -- and possibly
 I think that's billions of 

04:49:28.462 --> 04:49:30.538
devices today.  But it's 
continuing to expand and evolve 

04:49:30.539 --> 04:49:34.713
as the web ecosystem always 
does.  A great example of this 

04:49:34.714 --> 04:49:38.867
is we have seen work done in 
Safari to support service 

04:49:38.868 --> 04:49:40.931
workers.  What that support 
looks like?  We don't actually 

04:49:40.932 --> 04:49:45.068
know.  But it's important to 
understand and use the latest 

04:49:45.069 --> 04:49:47.138
and greatest tools so you're 
reaching as many people as you 

04:49:47.139 --> 04:49:51.295
can and empowering as many users
 are fantastic experiences.  So 

04:49:51.296 --> 04:49:55.463
I would ask you, really, just 
give these tools a try and let 

04:49:55.464 --> 04:49:59.628
us know what your experiences 
are with them.  We all want to 

04:49:59.629 --> 04:50:03.784
make the web a better place.  
Thank you so much.

04:50:03.785 --> 04:50:05.785
[ Applause ]

05:08:28.037 --> 05:08:30.488
&gt;&gt; Hell low and welcome, 
everyone.  Thank you for joining

05:08:30.489 --> 05:08:34.587
 us.  We are excited to be here 
and really appreciate the 

05:08:34.588 --> 05:08:38.723
efforts especially after  lunch.
  We know it's not as easy as 

05:08:38.724 --> 05:08:42.835
the early morning hours.  We are
 here today to share with you 

05:08:42.836 --> 05:08:44.901
what's new and cool and 
interesting in the new platform 

05:08:44.902 --> 05:08:51.123
of the Google Assistant.  At 
Google, as we heard in the 

05:08:51.124 --> 05:08:55.233
keynote earlier, we believe that
 the future is AI first.  What 

05:08:55.234 --> 05:08:57.294
does it mean?  It means that we 
invested a lot in machine 

05:08:57.295 --> 05:08:59.350
learning, natural language 
processing and understanding 

05:08:59.351 --> 05:09:05.496
context and what the user wants.
  And it's boiling down to the 

05:09:05.497 --> 05:09:07.533
Assistant.  It's basically a way
 for you to have a conversation 

05:09:07.534 --> 05:09:11.644
with Google and get things done.
And the beauty of this new 

05:09:11.645 --> 05:09:15.774
platform is that basically it's 
everywhere.  So from really 

05:09:15.775 --> 05:09:19.893
small devices up to cars.  And 
very soon we're going to have 

05:09:19.894 --> 05:09:26.244
many more devices.  It's going 
to be  everywhere.  Why it's one

05:09:26.245 --> 05:09:30.391
 of the most important questions
 that every time when we have a 

05:09:30.392 --> 05:09:34.537
new platform or a new system we 
ask ourselves.  And there are 

05:09:34.538 --> 05:09:40.712
obvious questions and obvious 
answers to this new platform, 

05:09:40.713 --> 05:09:44.821
like it's running everywhere, 
it's very efficient.  It's a 

05:09:44.822 --> 05:09:46.888
great way to get things done.  
But to me, personally, there are

05:09:46.889 --> 05:09:50.975
 two things that I think if I 
were in your shoes I would look 

05:09:50.976 --> 05:09:55.081
at it very carefully.  One is 
the productivity aspect.  You 

05:09:55.082 --> 05:09:57.127
could really help your users 
interact with your service and 

05:09:57.128 --> 05:09:59.190
get to the result that they want
 efficiently and without too 

05:09:59.191 --> 05:10:05.392
much trouble.  And second, like 
the photo op there, it's blue 

05:10:05.393 --> 05:10:09.530
ocean right now.  So think about
 the early days in each big new 

05:10:09.531 --> 05:10:11.580
revolution, you could be one of 
the first there.  And we'll 

05:10:11.581 --> 05:10:15.677
touch on it later.  It's a great
way for you to be there with the

05:10:15.678 --> 05:10:19.837
 quality up and then reach more 
users.

05:10:19.838 --> 05:10:23.996
So what does it mean for us as 
developers?  There are lots of 

05:10:23.997 --> 05:10:26.097
new terms.  And it's great to 
understand at the beginning what

05:10:26.098 --> 05:10:32.272
 we mean with each and every 
one.  So first and foremost, we 

05:10:32.273 --> 05:10:34.312
have the surfaces.  Right now we
 have the Google home device 

05:10:34.313 --> 05:10:38.426
which is a smart speaker that 
the Assistant is  embedded in it

05:10:38.427 --> 05:10:42.524
 and it lets you talk and get 
things done with it and, of 

05:10:42.525 --> 05:10:44.576
course, mobile devices,  
Android, iPhones, it's embedded 

05:10:44.577 --> 05:10:46.640
there.  The Google Assistant is 
basically the conversation that 

05:10:46.641 --> 05:10:50.759
you are doing with Google.  And 
like we saw in the impress i 

05:10:50.760 --> 05:10:54.872
demos in the keynote, lots of 
new interesting things to 

05:10:54.873 --> 05:10:58.997
communicate and to express what 
is the intent and what you want 

05:10:58.998 --> 05:11:03.115
to do is get the results very 
efficiently and quickly back 

05:11:03.116 --> 05:11:05.189
you.
Action on Google is the way to 

05:11:05.190 --> 05:11:09.283
expose this new Assistant 
platform to third-party 

05:11:09.284 --> 05:11:11.326
developers -- so you.  So you 
could tap into the investment 

05:11:11.327 --> 05:11:15.406
that we did and leverage it when
 you are coming to serve your 

05:11:15.407 --> 05:11:21.577
services and product and you 
handed them to your users.  The 

05:11:21.578 --> 05:11:25.682
major important aspect here to 
remember is that when you 

05:11:25.683 --> 05:11:29.824
interact with the Assistant, 
it's very straightforward.  It's

05:11:29.825 --> 05:11:33.934
 a conversation.  And when you 
want to handle your service and 

05:11:33.935 --> 05:11:40.165
your users, you basically burst 
with, okay, Google, or, hey, 

05:11:40.166 --> 05:11:44.286
Google -- talk to and then give 
the specific brand name.  So 

05:11:44.287 --> 05:11:46.352
your users from then on will 
move and be in your hands and 

05:11:46.353 --> 05:11:48.427
you can interact with them and 
do -- and help them reach the 

05:11:48.428 --> 05:11:54.623
goal that you want to.
So how does the Assistant app 

05:11:54.624 --> 05:11:58.737
work?  And,  again, it's very 
important at the beginning to 

05:11:58.738 --> 05:12:02.866
have the basic understanding of 
the moving parts here and then 

05:12:02.867 --> 05:12:04.937
everything becomes much clearer.
  So as you can see here in our 

05:12:04.938 --> 05:12:11.120
example, we are did a small demo
 that's called Personal Chef to 

05:12:11.121 --> 05:12:15.215
give you suggestions to a recipe
 based on your flavor and what 

05:12:15.216 --> 05:12:17.268
you feel like in the right 
moment.  When you burst and say,

05:12:17.269 --> 05:12:23.483
 okay, Google, talk to Personal 
Chef, basically you're going to 

05:12:23.484 --> 05:12:25.525
go to Google and then the magic 
of language understanding and 

05:12:25.526 --> 05:12:31.677
gathering out from what the user
 said, the exact intents and 

05:12:31.678 --> 05:12:35.795
entities is being done for you. 
 And from that moment you  

05:12:35.796 --> 05:12:41.982
basically go to your service -- 
here it will be Google Cloud, 

05:12:41.983 --> 05:12:44.038
but it can be any cloud service 
out there -- and the user is in 

05:12:44.039 --> 05:12:48.163
your hand.  And you need to 
interpret what they wanted and 

05:12:48.164 --> 05:12:52.277
return back the text.  Google 
will take and produce a speech 

05:12:52.278 --> 05:12:54.323
out of it.
So all the interaction with the 

05:12:54.324 --> 05:12:58.439
users will be done through that 
layer that basically is giving 

05:12:58.440 --> 05:13:02.591
you the ability to work with 
nice JSON files in your server 

05:13:02.592 --> 05:13:06.723
that is easy to interpret and 
work with.  But the heavy 

05:13:06.724 --> 05:13:08.788
lifting of combining and going 
from text to speech is being 

05:13:08.789 --> 05:13:17.026
done through that layer.  Well, 
I think the best will be just to

05:13:17.027 --> 05:13:21.150
 look at this short demo.  It 
will make very clear what I just

05:13:21.151 --> 05:13:23.151
 said.

05:13:25.199 --> 05:13:33.383
&gt;&gt; Sure.  Hi, I'm -- 
&gt;&gt; Well, I was kind of --

05:13:35.492 --> 05:13:41.656
 [away from  microphone]
&gt;&gt; All right.

05:13:41.657 --> 05:13:47.800
&gt;&gt; Some chicken.
&gt;&gt; Okay.  You should try the -- 

05:13:47.801 --> 05:13:51.890
[away from microphone]

05:13:57.960 --> 05:14:00.029
&gt;&gt; All right.  So that was a 
pretty simple interaction.  It 

05:14:00.030 --> 05:14:04.133
was like a simple thing to be 
having a conversation about.  

05:14:04.134 --> 05:14:10.313
But the conversation itself was 
actually quite complex.  Wayne, 

05:14:10.314 --> 05:14:12.386
our developer advocate up there 
said cold, warm and hot all in 

05:14:12.387 --> 05:14:16.499
the same sentence.  And the app 
managed to capture the correct 

05:14:16.500 --> 05:14:22.651
one referring to the soup.  Can 
you imagine writing a regular 

05:14:22.652 --> 05:14:26.780
expression or parser that would 
extract meaning out of that?  

05:14:26.781 --> 05:14:28.833
There are so many difficult 
cases it's pretty much 

05:14:28.834 --> 05:14:32.973
impossible for anything beyond a
 trivial example.  So let's look

05:14:32.974 --> 05:14:35.031
 at some of the ways we could 
build this interaction.

05:14:35.032 --> 05:14:39.156
So one of the options is to use 
the conversation API and the 

05:14:39.157 --> 05:14:43.297
actions SDK.  And in this case 
your Assistant app receives a 

05:14:43.298 --> 05:14:47.400
request that contains the spoken
 text from the user as a string.

05:14:47.401 --> 05:14:51.517
  So Google handles the speech 
recognition for you, but you 

05:14:51.518 --> 05:14:55.619
pass the strings.  You generate 
a response.  And then Google 

05:14:55.620 --> 05:14:59.746
handles speaking this back to 
the user.  The thing is -- as we

05:14:59.747 --> 05:15:01.807
 just mentioned --  parsing 
natural language can be really 

05:15:01.808 --> 05:15:03.869
difficult.  So fortunately we 
have some tools that make 

05:15:03.870 --> 05:15:05.927
handling that type of thing a 
lot easier.

05:15:10.220 --> 05:15:12.220
  API.ai is one of these.  It's 
a platform

05:15:13.336 --> 05:15:15.394
 that makes it incredibly 
straightforward to build 

05:15:15.395 --> 05:15:19.518
conversational experiences.  You
 might not have to write any 

05:15:19.519 --> 05:15:21.587
code if you're  building 
something simple.  So we're 

05:15:21.588 --> 05:15:23.696
going to give you an overview of
 this today.  It's probably what

05:15:23.697 --> 05:15:27.826
 most of you should use if 
you're going to implement your 

05:15:27.827 --> 05:15:36.102
own Assistant app.  So api.ai 
uses a graphical experience to 

05:15:36.103 --> 05:15:40.215
have interfaces.  You put in 
sentences of the way a user 

05:15:40.216 --> 05:15:42.293
might express a
certain need.  And you can 

05:15:42.294 --> 05:15:46.411
specify the values you need to 
get from the user.  And then we 

05:15:46.412 --> 05:15:52.610
use machine learning to train a 
model -- or we train a machine 

05:15:52.611 --> 05:15:54.656
learning model to understand the
 sentences and manage the  

05:15:54.657 --> 05:15:58.786
conservation.  The key part is 
you no longer need to process 

05:15:58.787 --> 05:16:02.892
raw strings.  Api.ai will do 
that for you.  You can see in 

05:16:02.893 --> 05:16:09.071
the diagram where it fits in.  
It handles the conversation 

05:16:09.072 --> 05:16:11.125
fulfillment in between the 
Assistant itself and your 

05:16:11.126 --> 05:16:15.257
backend.
And api.ai handles the 

05:16:15.258 --> 05:16:19.369
conservation for you.  So 
another way of looking at this, 

05:16:19.370 --> 05:16:23.501
the user says something, maybe 
asking for a certain recipe.  

05:16:23.502 --> 05:16:27.625
The Assistant converts their 
voice into text, and api.ai 

05:16:27.626 --> 05:16:31.749
receives the text string.  It 
will decompose that and figure 

05:16:31.750 --> 05:16:35.870
out what it means and hand the 
meaning in structured data.  You

05:16:35.871 --> 05:16:39.983
 do whatever you need to do, 
like look it up in the database 

05:16:39.984 --> 05:16:44.090
and find a matching recipe, 
build a response and pass it 

05:16:44.091 --> 05:16:46.137
back to the system which will 
read it out to the user.

05:16:46.138 --> 05:16:50.262
So we're going to show you a 
short demo of how we would work 

05:16:50.263 --> 05:16:54.384
with api.ai to build this app.

05:17:00.468 --> 05:17:04.554
  All right.  So in api.ai we 
create an intent to represent 

05:17:04.555 --> 05:17:08.718
each thing that the user might 
want to do.  So in this case, 

05:17:08.719 --> 05:17:12.836
we've built an intent that 
covers the user asking for a 

05:17:12.837 --> 05:17:16.981
recipe.  So I'm going to open 
the intent here.  So right here 

05:17:16.982 --> 05:17:21.085
you can are see how we've 
provided examples of different 

05:17:21.086 --> 05:17:25.189
ways the user might express 
their desire for a recipe.  And 

05:17:25.190 --> 05:17:29.306
these examples are used to train
 a machine learning model that 

05:17:29.307 --> 05:17:31.573
can recognize what the user 
wants.

05:17:29.307 --> 05:17:35.514
And as we add examples, api.ai 
will  automatically pick out 

05:17:35.515 --> 05:17:37.575
important concepts that are 
mentioned by the user.  So the 

05:17:37.576 --> 05:17:41.718
system actually understands many
 concepts by itself.  But you 

05:17:41.719 --> 05:17:45.864
can add custom, domain-specific 
information.  Like, in this 

05:17:45.865 --> 05:17:49.973
case, recipe ingredients.  So 
I'm going to add a couple of 

05:17:49.974 --> 05:17:54.083
thing here is.
&gt;&gt; And as he types, you can see 

05:17:54.084 --> 05:17:58.193
that it will mark immediately 
the entities that it 

05:17:58.194 --> 05:18:00.246
understands.  And if it doesn't 
understand the entity that you 

05:18:00.247 --> 05:18:04.355
wish, you can mark it for it.  
You can see here, protein and 

05:18:04.356 --> 05:18:10.562
dish type are recognized because
 we have some examples beneath.

05:18:10.563 --> 05:18:16.752
&gt;&gt; So another example -- so 
these are all entities our 

05:18:16.753 --> 05:18:20.858
system knows about.  And api.ai 
is able to pluck those from the 

05:18:20.859 --> 05:18:24.970
user statement and figure out 
what nay mean.  So we can 

05:18:24.971 --> 05:18:29.111
actually also mark this 
information as "Required."  So 

05:18:29.112 --> 05:18:33.233
here we've put in a cooking 
speed and a dish type.  Down 

05:18:33.234 --> 05:18:41.483
here we've actually marked" Dish
 type" and "Protein" and"  

05:18:41.484 --> 05:18:45.614
Vegetable" as required.  In this
 case, the app is going to wait 

05:18:45.615 --> 05:18:49.717
for the user to ask if they 
didn't mention it.  So I'm going

05:18:49.718 --> 05:18:51.718
 to save the intent and wait

05:18:53.770 --> 05:18:56.636
 one moment for the machine 
learning model.

05:18:53.770 --> 05:18:59.938
&gt;&gt; Yeah, okay.
&gt;&gt; Okay.  So training is 

05:18:59.939 --> 05:19:01.997
completed.  So now I'm going to 
enter in our test console, which

05:19:01.998 --> 05:19:06.122
 is kind of how we work while 
we're developing the agent.  I 

05:19:06.123 --> 05:19:12.318
can just enter in "I want 
something with beef."  So in 

05:19:12.319 --> 05:19:16.435
this case I'm specifying a 
protein, but I didn't specify a 

05:19:16.436 --> 05:19:20.560
vegetable or a dish type.  So 
that the system actually knows 

05:19:20.561 --> 05:19:24.722
that it expects those things and
 it should prompt for them if 

05:19:24.723 --> 05:19:30.916
they weren't  supplied.  So I 
can now say," Potato."  And I 

05:19:30.917 --> 05:19:35.027
still need to know a dish type. 
 What kind of dish do you 

05:19:35.028 --> 05:19:37.082
prefer?  Let's have a main 
course.

05:19:37.083 --> 05:19:41.196
And so now this is where we 
would hand off to our backend 

05:19:41.197 --> 05:19:45.324
and we would use that structured
 data to look up a recipe in the

05:19:45.325 --> 05:19:49.448
 database and return it to the 
user.  So it's pretty amazing to

05:19:49.449 --> 05:19:51.551
 be able to conduct a 
conversation dynamically in this

05:19:51.552 --> 05:19:55.674
 way just based on the 
information the user provided on

05:19:55.675 --> 05:19:59.790
 the fly without knowing in 
advance what they're going to 

05:19:59.791 --> 05:20:03.899
say.  Once the intent has 
captured all of this 

05:20:03.900 --> 05:20:05.945
information, it becomes 
available to use on your 

05:20:05.946 --> 05:20:08.018
backend, which is where you're 
going to make stuff happen and 

05:20:08.019 --> 05:20:10.069
generate a response.  So you can
 see in here, we have the action

05:20:12.139 --> 05:20:16.280
 that we resolve to, which is 
the intent.  And we have this 

05:20:16.281 --> 05:20:18.338
parameter data that we captured 
from the user's query.

05:20:18.339 --> 05:20:22.463
And so because we have those 
values in a structured way, we 

05:20:22.464 --> 05:20:26.567
can look those up in our backend
 and return something useful.  

05:20:26.568 --> 05:20:32.743
So once we're done, it's only a 
few clicks to integrate the app 

05:20:32.744 --> 05:20:36.838
with a load of different 
platforms.  On the integration 

05:20:36.839 --> 05:20:40.931
tab here.  We want to integrate 
with actions on Google so this 

05:20:40.932 --> 05:20:45.048
is available via the Google 
Home.  And we can click here and

05:20:45.049 --> 05:20:51.230
 load up the simulator to test 
this out.  So the actions on 

05:20:51.231 --> 05:20:57.427
Google Web Simulator allows us 
to test out our action as if 

05:20:57.428 --> 05:20:59.490
it's running on the actual 
platform.

05:20:59.491 --> 05:21:05.684
So I can say, "Talk to my test 
app."

05:21:05.685 --> 05:21:09.780
&gt;&gt; All right.  Let's get the 
test version of my test app.

05:21:09.781 --> 05:21:11.883
&gt;&gt; And so here we're seeing how 
the app would be responding.  

05:21:11.884 --> 05:21:18.108
And I can say, "Let's try a 
recipe with chicken

05:21:22.152 --> 05:21:26.247
." And this is now communicating
 with  api.ai in the same way 

05:21:26.248 --> 05:21:32.426
that the Google Home might  be. 
 So it's asking what kind of 

05:21:32.427 --> 05:21:34.493
vegetables we have.  So let's 
say potato.  And, again, we want

05:21:34.494 --> 05:21:38.625
 a main course.  So you can see 
how it's really easy to develop 

05:21:38.626 --> 05:21:42.731
your app with an api.ai.  Test 
it out in the simulator.  And 

05:21:42.732 --> 05:21:48.938
then the magical thing is, if 
you're signed into a Google Home

05:21:48.939 --> 05:21:50.994
 or the Assistant app on your 
phone, this app is now 

05:21:50.995 --> 05:21:55.137
immediately available for you to
 test out.  So you can try it 

05:21:55.138 --> 05:21:57.191
straightaway and make 
modifications which is a really 

05:21:57.192 --> 05:21:59.192
fun work flow.  There's

05:22:01.252 --> 05:22:05.361
 not a deployment step.  This is
 for building an action.  And 

05:22:05.362 --> 05:22:09.503
you should go to the  following 
workshop session on building an 

05:22:09.504 --> 05:22:11.565
Assistant app to give it a try 
for yourself.

05:22:11.566 --> 05:22:13.602
So let's switch back over to our
 slides and talk a little more 

05:22:13.603 --> 05:22:15.672
about the platform.

05:22:19.755 --> 05:22:23.879
&gt;&gt; So we saw how we could 
leverage api.ai, and the goal 

05:22:23.880 --> 05:22:30.081
with any app is to have the wow 
effect and the best experience 

05:22:30.082 --> 05:22:32.146
that we can give our users.  So 
let's touch a bit on what can we

05:22:34.206 --> 05:22:36.288
 do.  Before we are starting to 
code our app, and it's actually 

05:22:36.289 --> 05:22:40.455
easy to do, I think one of the 
most important aspects is to 

05:22:40.456 --> 05:22:44.584
dive into all the grid content 
that our team produce around 

05:22:44.585 --> 05:22:50.742
design, voice, UIs.  It's 
totally different topic than 

05:22:50.743 --> 05:22:54.866
what we -- or most of us are 
used to in terms of graphical 

05:22:54.867 --> 05:22:59.014
user interface.  Coming to 
voice, there's lots of 

05:22:59.015 --> 05:23:03.143
constraints and limitations that
 we could take into 

05:23:03.144 --> 05:23:05.179
consideration.  And there's some
 great you went its there like a

05:23:05.180 --> 05:23:09.316
 checklist and tips that could 
really put you on the right 

05:23:09.317 --> 05:23:13.441
track when you're coming to 
design the conversation and see 

05:23:13.442 --> 05:23:17.565
how the working parts are going 
to work best in your specific 

05:23:17.566 --> 05:23:19.623
use case.
When we are coming to build it, 

05:23:19.624 --> 05:23:25.771
we need to take into 
consideration when, like we saw 

05:23:25.772 --> 05:23:30.128
in the earlier slide, we have 
different surfaces out there.  

05:23:30.129 --> 05:23:32.186
Right now we have Google Home 
and mobile devices.  Soon we 

05:23:32.187 --> 05:23:34.248
will have more.  On mobile 
devices we could and actually 

05:23:34.249 --> 05:23:36.249
should leverage

05:23:37.298 --> 05:23:39.351
 the real estate that the screen
 is giving us.  As you can see 

05:23:39.352 --> 05:23:43.470
here in the example, say the 
user wanted to get to someplace.

05:23:43.471 --> 05:23:47.588
  Google Home will tell them 
where to go.  And if we have the

05:23:47.589 --> 05:23:49.644
 screen and we know it in our 
app that we are now on this 

05:23:49.645 --> 05:23:53.766
surface, we could give them a 
small map and a URL to get the 

05:23:53.767 --> 05:23:57.899
directions immediately.
At the most basic, you can 

05:23:57.900 --> 05:24:02.017
specify on the screen what is 
the text that you are going to 

05:24:02.018 --> 05:24:06.148
speak.  And as you could see 
here in the example, that we 

05:24:06.149 --> 05:24:08.204
have what will be telling to the
 user and what

05:24:11.253 --> 05:24:13.310
 will be the text.  One of the 
most important aspects to 

05:24:13.311 --> 05:24:17.434
remember here is that we always 
want that the text will be a 

05:24:17.435 --> 05:24:19.483
summary or the executive summary
 of what we will talk to the 

05:24:19.484 --> 05:24:21.547
user.  So if the user is 
listening and getting the full 

05:24:21.548 --> 05:24:25.686
blown answer, and if they're 
just skimming with their eyes 

05:24:25.687 --> 05:24:27.745
the screen, they still get to 
see what we want.  Or the most 

05:24:27.746 --> 05:24:31.858
important aspect -- but like in 
the example here, we don't need 

05:24:31.859 --> 05:24:33.910
to give them the full blown 
answer.

05:24:35.969 --> 05:24:40.062
When we have one of the options 
or one of the most popular 

05:24:40.063 --> 05:24:44.158
options, one of the main design 
themes that we're giving is to 

05:24:44.159 --> 05:24:46.199
lead the conversation and give 
the user the ability to very 

05:24:46.200 --> 05:24:53.258
quickly go and route to the path
 that they want to.  So suggests

05:24:53.259 --> 05:24:55.324
 are one of the most efficient 
way to do it.  If you have 

05:24:55.325 --> 05:24:59.441
popular choices, you could 
suggest it to the user.  So on 

05:24:59.442 --> 05:25:01.545
the screen they have a nice 
button they can click on.  And 

05:25:01.546 --> 05:25:08.251
if we are on Google Home, you 
can suggest it and the user can 

05:25:08.252 --> 05:25:11.071
choose.  They're not forced to 
it, they can choose any number 

05:25:11.072 --> 05:25:17.244
out there.  But we are 
suggesting what to do.  And in 

05:25:17.245 --> 05:25:19.306
our example, it could be 
suggesting the most common 

05:25:19.307 --> 05:25:21.362
vegetables that are appearing in
 the recipe.

05:25:21.363 --> 05:25:25.472
Basic cards are actually quite 
holistic and complex in the 

05:25:25.473 --> 05:25:29.609
sense that they're giving the 
full blown image URL and text.  

05:25:29.610 --> 05:25:33.715
And it's giving you the ability 
to extend the experience.  So in

05:25:33.716 --> 05:25:37.843
 our case we could show a nice, 
big photo of the dish itself and

05:25:37.844 --> 05:25:39.887
 to give the user a link so that
 they could open it in their app

05:25:39.888 --> 05:25:44.020
 and see what we are going to 
cook.

05:25:44.021 --> 05:25:48.118
There are many cases where you 
want to set and show the user a 

05:25:48.119 --> 05:25:52.207
list of things.  And give the 
user a visual selection of

05:25:55.260 --> 05:25:59.060
 what's going on with the 
different types of things that 

05:25:55.260 --> 05:26:01.419
they could choose from.  And the
 carousel shows big images.  The

05:26:01.420 --> 05:26:03.466
 main difference is that we have
 a more limited set of items.  

05:26:03.467 --> 05:26:07.598
And the list will have smaller 
images and much longer lists 

05:26:07.599 --> 05:26:11.728
that we could show the user what
 are the different options.  And

05:26:11.729 --> 05:26:13.785
 in this example, you could 
think about showing a couple of 

05:26:13.786 --> 05:26:17.965
different options for type of 
dish.  And that would be -- 

05:26:17.966 --> 05:26:22.089
let's say that the user already 
chooses a chicken salad, we 

05:26:22.090 --> 05:26:26.193
could use the carousel to offer 
three, four different types of 

05:26:26.194 --> 05:26:28.248
recipes for chicken salad.  On 
the other hand, if we want to 

05:26:28.249 --> 05:26:34.407
show a dozen different dishes 
that feature chicken as an 

05:26:34.408 --> 05:26:36.464
ingredient, we could use the 
list.

05:26:36.465 --> 05:26:38.535
&gt;&gt; So you might have a 
conversation where you need to 

05:26:38.536 --> 05:26:42.644
know the user's name or 
location.  So one example might 

05:26:42.645 --> 05:26:44.714
be if you were helping the user 
find a local bookstore and you 

05:26:44.715 --> 05:26:48.843
want to know the zip code or the
 post code.  So you can use our 

05:26:48.844 --> 05:26:52.963
SDK to request permissions for 
the name, the course location, 

05:26:52.964 --> 05:26:57.061
and the precise location of the 
user.  And when you invoke this 

05:26:57.062 --> 05:27:01.177
function, the Assistant's going 
to ask the user for permission 

05:27:01.178 --> 05:27:03.242
in the voice of your app.  So 
it's really seamless.  The same 

05:27:03.243 --> 05:27:09.435
is the name of the user who is 
registered to the device.  The 

05:27:09.436 --> 05:27:11.498
precise location is the exact 
GPS coordinates and the street 

05:27:11.499 --> 05:27:15.625
address.  And then the course 
location is just the zip code or

05:27:15.626 --> 05:27:19.736
 post code and the city.
If you'd like to link a user 

05:27:19.737 --> 05:27:25.916
with their account on your own 
service, and you have an Oauth 

05:27:25.917 --> 05:27:30.042
server, they can prompt them to 
link their account.  They're 

05:27:30.043 --> 05:27:34.155
going to receive a card at the 
top of their Google  Home map on

05:27:34.156 --> 05:27:38.274
 the phone that provides a link 
to your login page.  They can 

05:27:38.275 --> 05:27:44.438
follow that, log in to your 
service.  And they can invoke 

05:27:44.439 --> 05:27:48.542
your action and your action can 
authenticate calls to your 

05:27:48.543 --> 05:27:52.651
services through our API.  So 
it's important that you provide 

05:27:52.652 --> 05:27:56.751
the OAuth endpoint.  Right now 
as part of the approval process 

05:27:56.752 --> 05:28:04.958
we basically want you to run 
your own OAuth server.  So if 

05:28:04.959 --> 05:28:07.025
your experience involves 
shopping or payments, we support

05:28:07.026 --> 05:28:11.122
 rich transactions and allow you
 to accept user payments.  And 

05:28:11.123 --> 05:28:15.263
the really cool part is 
customers can use whatever 

05:28:15.264 --> 05:28:17.347
payment information they have on
 file with Google.  Payments can

05:28:17.348 --> 05:28:23.524
 be super easy.  No reason to 
fumble around with a credit 

05:28:23.525 --> 05:28:27.641
card.  Although they can use 
your payment solution if they 

05:28:27.642 --> 05:28:31.789
prefer.  Autosummary and 
payments.  And the user can see 

05:28:31.790 --> 05:28:33.849
a history of
all their transactions.  The 

05:28:33.850 --> 05:28:40.046
Assistant also supports home 
automation via our smart home 

05:28:40.047 --> 05:28:44.155
automation.  If you're a device 
maker, you can easily integrate 

05:28:44.156 --> 05:28:46.205
your existing devices with the 
home graph.  The home graph 

05:28:46.206 --> 05:28:52.399
knows the state of all the 
connected devices.  When you're 

05:28:52.400 --> 05:28:56.519
asked to dim the lights, it does
 that intelligencely.  There's 

05:28:56.520 --> 05:29:00.642
endless possibilitieses how to 
interact with home automation.  

05:29:00.643 --> 05:29:04.757
We have announced the Google 
Assistant SDK which enables you 

05:29:04.758 --> 05:29:10.942
to embed the Assistant in your 
own custom hardware projects.  

05:29:10.943 --> 05:29:15.064
Magpie magazine with Google 
provides a card board housing 

05:29:15.065 --> 05:29:23.324
with a button, a speaker and 
wraps around a Ras berry PII.  

05:29:23.325 --> 05:29:27.481
And we demoed this mock tails 
mix from our partner, Deep Local

05:29:29.531 --> 05:29:31.600
, which embeds the S  did, K.  
And you can tell it what kind of

05:29:33.670 --> 05:29:35.734
 drink you want and it will mix 
it up for you.  You can embed 

05:29:35.735 --> 05:29:39.848
the Assistant pretty much into 
any hardware device.

05:29:39.849 --> 05:29:43.943
&gt;&gt; After we have built our 
Assistant up, it's time to reach

05:29:43.944 --> 05:29:48.056
 the user and see how we can 
drive traffic to it and what are

05:29:48.057 --> 05:29:52.168
 the different options for us at
 the moment.  So the basic way 

05:29:52.169 --> 05:29:56.273
to invoke that is to -- after, 
of course, you submitted the app

05:29:56.274 --> 05:29:58.274
 and it was

05:29:59.371 --> 05:30:02.334
 tested -- is to provide the set
 of triggers that it knows.  So,

05:30:02.335 --> 05:30:06.436
 okay, Google, talk to -- in our
 days -- Personal Chef, it could

05:30:06.437 --> 05:30:10.538
 be one or two different 
invocations, and the user will 

05:30:10.539 --> 05:30:12.649
ask according to your brand name
 or your app name and it will 

05:30:12.650 --> 05:30:18.829
invoke it.  We also support 
deep-linking.  As you can see in

05:30:18.830 --> 05:30:22.944
 the example, in one sentence, 
talk to the Personal Chef and 

05:30:22.945 --> 05:30:27.053
get the recipe or something else
.  There is also the ability to 

05:30:27.054 --> 05:30:31.125
ask Google  for -- I want to 
work out.  I want yoga or 

05:30:31.126 --> 05:30:35.260
something more.  And obviously 
if you have a quality good 

05:30:35.261 --> 05:30:39.420
Assistant up in the directory, 
Google will surface it.  And 

05:30:39.421 --> 05:30:41.483
that's come to the point which 
the blue ocean, great 

05:30:41.484 --> 05:30:45.614
opportunities there.
Last, but not least, we have a 

05:30:45.615 --> 05:30:49.755
full directory of apps that are 
sitting and living inside the 

05:30:49.756 --> 05:30:53.843
Assistant.  On the top right 
corner you have the ability to 

05:30:53.844 --> 05:30:55.925
click and open the directory.  
And,  again, it's opening and 

05:30:55.926 --> 05:31:00.178
giving the user, based on 
categories, and based on what 

05:31:00.179 --> 05:31:04.326
the Assistant thinks the user 
will enjoy most -- what are the 

05:31:04.327 --> 05:31:06.401
different variations of apps 
that are out there to try and  

05:31:06.402 --> 05:31:08.453
use?  There are quite a lot.  So
 I really suggest you to check 

05:31:08.454 --> 05:31:14.602
some of them out.
You could and should link.  And 

05:31:14.603 --> 05:31:18.710
we have a deep link so if you 
have a web service or another 

05:31:18.711 --> 05:31:22.804
app you could always link from 
it to the Assistant app.  So in 

05:31:22.805 --> 05:31:26.897
lots of cases where the service 
might be more efficient for your

05:31:28.939 --> 05:31:30.988
 users from the Assistant app, I
 highly encourage you to link to

05:31:30.989 --> 05:31:33.040
 it, and then, of course, they 
could use it.

05:31:33.041 --> 05:31:35.109
&gt;&gt; So we've seen all this 
awesome stuff you can do with 

05:31:35.110 --> 05:31:39.284
the actions platform, but let's 
talk a little bit about how you 

05:31:39.285 --> 05:31:43.392
can get started.  So we've got a
 series of videos that cover a 

05:31:43.393 --> 05:31:47.528
lot of content on how to get up 
and running with the Assistant. 

05:31:47.529 --> 05:31:51.635
 So we have an intro video that 
explains high-level concepts and

05:31:53.700 --> 05:31:57.810
 goes through the Perm Chef 
example.  And a video about 

05:31:57.811 --> 05:32:01.930
conversation design.  Worth  
checking out as you start to 

05:32:01.931 --> 05:32:06.024
design and build your app.  And 
we have a screencast of every 

05:32:06.025 --> 05:32:12.171
step needed to build our 
Personal Chef example.  We have 

05:32:12.172 --> 05:32:16.281
several Code Labs that will help
 you design and implement your 

05:32:16.282 --> 05:32:18.340
first Assistant app.  And 
finally, when you want to 

05:32:18.341 --> 05:32:22.426
discuss this stuff with other 
developers, we have a really 

05:32:22.427 --> 05:32:26.525
active action on Google 
developer community.  We keep up

05:32:26.526 --> 05:32:30.628
 with the latest news and answer
 questions from developers.  We 

05:32:30.629 --> 05:32:34.761
have a great community on Stack 
overflow if you have technical 

05:32:34.762 --> 05:32:36.817
questions.
After us, there's a great talk 

05:32:36.818 --> 05:32:41.757
that will guide you in many more
 detail how to build an 

05:32:41.758 --> 05:32:43.820
Assistant app.  Head upstairs 
and check that out after this 

05:32:43.821 --> 05:32:52.065
talk.  And our whole team of 
people are here.  So feel free 

05:32:52.066 --> 05:32:54.133
to come by and ask questions 
about the platform.  We can show

05:32:54.134 --> 05:32:58.284
 you the Google Home and show 
the Assistant SDK stuff.  Thank 

05:32:58.285 --> 05:33:02.414
you for coming and really 
encourage you to dive into this 

05:33:02.415 --> 05:33:04.460
new platform.
[ Applause ]

05:33:08.517 --> 05:33:10.583
&gt;&gt; Last, but not least, I forgot
 to mention it at the beginning 

05:33:10.584 --> 05:33:16.768
-- I saw people taking photos.  
All the slides are live.  You 

05:33:16.769 --> 05:33:20.979
would ping Dan or myself on any 
channel that you wish.  And you 

05:33:20.980 --> 05:33:25.097
could get all the slides there. 
 And if you have any questions, 

05:33:25.098 --> 05:33:29.211
we'll be at our booth at the 
Assistant app room.  So please 

05:33:29.212 --> 05:33:33.331
feel free to come over and give 
us your  feedback and thoughts. 

05:33:33.332 --> 05:33:35.389
 Thank you very much.
[ Applause ]

05:33:35.390 --> 05:33:37.440
&gt;&gt; Cheers.

05:50:07.039 --> 05:50:11.533
[ Applause ]
WOJTEK: Hello, everyone.  My 

05:50:11.534 --> 05:50:15.689
name is Wojtek.  I'm a developer
 advocate working with the 

05:50:15.690 --> 05:50:19.828
Android Studio team.  And today 
I want to tell you a little bit 

05:50:19.829 --> 05:50:23.939
about performance tooling that 
we're releasing soon with the 

05:50:23.940 --> 05:50:26.054
new Android Studio version, 3.0.
  And why

05:50:36.162 --> 05:50:40.428
 performance tooling?  Because I
 think we all know perf matters,

05:50:36.162 --> 05:50:40.428
 right?  That's not something I 
have to convince you developers 

05:50:36.162 --> 05:50:38.302
that's true.
So let me keep this intro short.

05:50:38.303 --> 05:50:46.627
  But I just want to tell you a 
little bit how I understand app 

05:50:46.628 --> 05:50:48.687
performance and what it means to
 me.  Imagine it's a measure of 

05:50:48.688 --> 05:50:52.839
your app quality.  A user 
downloads the app and installs 

05:50:52.840 --> 05:50:56.971
it because they want to use  
features.  The features that you

05:50:56.972 --> 05:50:59.034
 implemented, the benefits that 
the app gives them.

05:50:59.035 --> 05:51:01.137
You design a great UI because 
you want the user to be able

05:51:04.796 --> 05:51:06.847
 so access information quickly 
and you want them to -- you want

05:51:06.848 --> 05:51:08.903
 them to feel good about just 
using your app.  Think about the

05:51:10.955 --> 05:51:13.021
 other part of the user 
experience.  What if they want 

05:51:13.022 --> 05:51:17.109
to actually use it, but if 
they're frustrated, because they

05:51:17.110 --> 05:51:21.204
 keep the app open and the 
battery drains fast.  What if 

05:51:21.205 --> 05:51:25.324
just having the app installed 
means their phone dies twice as 

05:51:25.325 --> 05:51:29.457
fast as before.  The user cares 
about the responsiveness of the 

05:51:29.458 --> 05:51:31.458
device, a smooth

05:51:33.542 --> 05:51:37.708
 UI, about how fast the app 
installs and how much space it 

05:51:37.709 --> 05:51:39.780
take up on the device.  And all 
these things ultimately will 

05:51:39.781 --> 05:51:41.861
make your user happy or 
frustrated because they're using

05:51:43.919 --> 05:51:48.011
 your app and ultimately it's 
what they will feel about your 

05:51:48.012 --> 05:51:50.060
app and what rating they will 
give you on the Play Store.

05:51:50.061 --> 05:51:54.178
So whack we do about this as 
developers?  I see it as a two-

05:51:56.251 --> 05:51:58.303
way process.  You have to be 
proactive and you have to be 

05:51:58.304 --> 05:52:02.425
reactive.  Now, what does it 
really mean?  So even before you

05:52:02.426 --> 05:52:05.044
 start working on your app, you 
have to plan for performance.  

05:52:05.045 --> 05:52:09.169
When developing before the 
release, you have to keep 

05:52:09.170 --> 05:52:13.281
measuring and profiling.  What 
does it mean that your app is 

05:52:13.282 --> 05:52:15.339
performant?  How can you know if
 it's performing up to the 

05:52:15.340 --> 05:52:19.493
standards?  You have to actually
 plan for some numbers.  Just do

05:52:19.494 --> 05:52:23.600
 some benchmarking.  Look at 
your competitor's app.  See how 

05:52:23.601 --> 05:52:27.740
fast they work, how fast they 
start.  Write down some figures 

05:52:27.741 --> 05:52:32.732
and plan for this.  Then, when 
you relyse lease, maybe you will

05:52:32.733 --> 05:52:34.782
 not nail it the first time, but
 you will have something to 

05:52:34.783 --> 05:52:40.982
strive for and to try and fix 
it.  And then, be reactive.  

05:52:40.983 --> 05:52:43.051
This whole process doesn't end 
when you release your app and 

05:52:43.052 --> 05:52:45.114
you're done.  No.  It's all 
about monitoring and reacting to

05:52:45.115 --> 05:52:49.264
 any problems that arise.  And 
you have to have tools to be 

05:52:49.265 --> 05:52:53.368
able to debug and fix these
things.

05:52:53.369 --> 05:52:57.462
So today I'm going to talk a 
little bit about the new Android

05:52:57.463 --> 05:52:59.512
 profiler.  Available in Android
 Studio

05:53:03.573 --> 05:53:09.755
 3.0.  And this replaces the old
 Android monitor tab.  You can 

05:53:09.756 --> 05:53:13.872
see when you launch your app on 
a device or emulator, you open 

05:53:13.873 --> 05:53:15.911
the Android tab at the bottom 
and see this view.  This is what

05:53:15.912 --> 05:53:20.021
 we call the unified timeline.  
You can see three charts.  The 

05:53:20.022 --> 05:53:24.117
CPU, the memory, and the network
 charts.  But what's really cool

05:53:24.118 --> 05:53:26.178
 about this view is here at the 
top you can see an additional 

05:53:26.179 --> 05:53:32.338
track with some important app 
events that are happening such 

05:53:32.339 --> 05:53:36.422
as input events, rotations and 
activity state.  And looking at 

05:53:36.423 --> 05:53:38.491
these things gives you more 
context to actually analyze the 

05:53:38.492 --> 05:53:42.604
data that you see below.
So imagine here I'm touching the

05:53:44.668 --> 05:53:46.724
 screen, interacting with my 
app, and I can immediately see 

05:53:46.725 --> 05:53:50.851
on the CPU chart that my app is 
doing something.  It's actually 

05:53:50.852 --> 05:53:54.969
processing the input events.  
Then when I rotate, you can see 

05:53:54.970 --> 05:53:59.103
that activities are changing.  
The activities are getting 

05:53:59.104 --> 05:54:01.155
destroyed and it's being created
 and something is happening 

05:54:01.156 --> 05:54:05.261
there with the memory in CPU.  
Now, when you click on the 

05:54:05.262 --> 05:54:09.379
tracks, you can go to a detailed
 view.  And let's start with the

05:54:09.380 --> 05:54:13.468
 CPU profiler first.  The UI  is
 a little bit complicated.  It 

05:54:13.469 --> 05:54:17.585
can be hard to see from the back
 so let me walk you through the 

05:54:17.586 --> 05:54:23.773
main points here.  On the left, 
these are all threads that were 

05:54:23.774 --> 05:54:27.889
active when you were profiling 
the app using the CPU profiler. 

05:54:27.890 --> 05:54:32.000
 And you can see a chart of 
activity.  Spikes whenever there

05:54:32.001 --> 05:54:34.058
 was something happening in the 
app such as activity creation, 

05:54:34.059 --> 05:54:38.157
swipes, list  scrolling and so 
on.  And finally, you can see 

05:54:38.158 --> 05:54:42.275
thread state.  So you can see 
which of the threads were active

05:54:42.276 --> 05:54:46.399
 and their associated
states such as if they were 

05:54:46.400 --> 05:54:50.528
sleeping, active, waiting, so 
on.  And you can glance at this 

05:54:50.529 --> 05:54:54.640
and already figure out that 
something's happening.  But the 

05:54:54.641 --> 05:54:56.706
nice thing is you can also start
 method tracing from here using 

05:54:56.707 --> 05:55:00.867
this button.  Method tracing is 
basically recording all the 

05:55:00.868 --> 05:55:04.979
method calls on the app so you 
can analyze them better and 

05:55:04.980 --> 05:55:07.035
figure out which methods are 
taking up the most time in your 

05:55:07.036 --> 05:55:09.078
app.
Now, there's two ways you can do

05:55:09.079 --> 05:55:13.185
 this.  This drop down next to 
the report button.  You can 

05:55:13.186 --> 05:55:19.415
select the sample or instrument 
to trace.  The difference is -- 

05:55:19.416 --> 05:55:21.473
well, pretty small.  I mean, 
they both essentially do the 

05:55:21.474 --> 05:55:25.597
same thing, except the sampled 
one has a smaller overhead.  But

05:55:25.598 --> 05:55:29.688
 it can miss some very short 
lived methods sometimes because 

05:55:29.689 --> 05:55:35.885
it  samples every X milliseconds
 to check which methods were 

05:55:35.886 --> 05:55:37.945
run.  Whereas if you choose 
instrument traces, they will 

05:55:37.946 --> 05:55:42.074
record every method enter and 
exit.  But the overhead will be 

05:55:42.075 --> 05:55:46.156
bigger.  So what happens when I 
press the start method tracing 

05:55:46.157 --> 05:55:50.274
button, I interact with my app. 
 I swipe on the screen.  I do 

05:55:50.275 --> 05:55:54.388
some transitions.  I rotate my 
phone.  I press "Stop."  And 

05:55:54.389 --> 05:55:56.452
when Android Studio stops 
processing the trace, you can 

05:55:56.453 --> 05:56:02.647
see this view.
So here at the bottom we see a 

05:56:02.648 --> 05:56:04.705
call chart from the selected 
slice of time that you can see 

05:56:04.706 --> 05:56:10.867
on the timeline.  So here I 
selected the moment when I was 

05:56:10.868 --> 05:56:13.748
rotating my phone and the 
activity is getting destroyed 

05:56:13.749 --> 05:56:17.864
and re-created.  So imagine this
 is an image gallery app.  And I

05:56:17.865 --> 05:56:21.997
 notice that when I'm  looking 
at an image and I rotate my 

05:56:21.998 --> 05:56:26.089
phone, the activity takes an 
unusually long time to actually 

05:56:26.090 --> 05:56:28.135
restart and show me the image 
again.  So I want to see what's 

05:56:28.136 --> 05:56:32.265
happening there.  I can actually
 zoom in this chart because I 

05:56:32.266 --> 05:56:36.386
want to see the exact calls that
 were made.  Or I can just drag 

05:56:36.387 --> 05:56:40.517
and drop and select on the 
timeline a smaller slice of that

05:56:40.518 --> 05:56:44.698
 recording of that trace.
And here at the bottom on the 

05:56:44.699 --> 05:56:50.874
call chart you can see all 
Android framework methods 

05:56:50.875 --> 05:56:52.933
highlighted in yellow.  All 
methods from my code that were 

05:56:52.934 --> 05:56:59.106
called in this trace in green.  
And some other library methods 

05:56:59.107 --> 05:57:03.232
in blue.  So, again, for those 
who can't see the small text on 

05:57:03.233 --> 05:57:09.411
the screen, here I can see the 
whole oncreate method.  And 

05:57:09.412 --> 05:57:15.666
actually the width of the chart 
show for how long the 

05:57:15.667 --> 05:57:17.729
representative methods were 
running.  And the first thing 

05:57:17.730 --> 05:57:21.848
that runs in my oncreate is 
layout inflation.  It takes some

05:57:21.849 --> 05:57:26.145
 time.  That's okay.  I can't do
 anything about it.  But then I 

05:57:26.146 --> 05:57:30.263
notice there are two very long 
method calls in my code that 

05:57:30.264 --> 05:57:32.302
actually create disk caches for 
my images.  And first of all, I 

05:57:32.303 --> 05:57:36.404
can see that I'm actually 
hitting the disk.  I'm creating 

05:57:36.405 --> 05:57:42.582
caches.  I'm reading disk from 
my main thread.  I can see that 

05:57:42.583 --> 05:57:46.688
because I can see the thread 
highlighted on the top on the 

05:57:46.689 --> 05:57:50.783
list.  All of this takes almost 
twice the time it takes to 

05:57:50.784 --> 05:57:54.896
initialize my layout.  So I 
should not be doing that in 

05:57:54.897 --> 05:57:56.947
oncreate.
And that's it.  In 10 seconds I 

05:57:56.948 --> 05:58:03.106
was able to quickly glance and 
see what's happening in my 

05:58:03.107 --> 05:58:07.219
oncreate method and see what's 
taking so long.  I recommend to 

05:58:07.220 --> 05:58:09.285
try this for all the places 
where you need to finish 

05:58:09.286 --> 05:58:13.408
something quickly if you're 
doing any calls in layouts -- in

05:58:13.409 --> 05:58:17.533
 computing layouts.  In custom 
drawing for your  views.  Any 

05:58:17.534 --> 05:58:19.661
place, basically, that may be 
impacted by doing

05:58:22.708 --> 05:58:24.778
 a lot of work on the CPU, 
please check it out.

05:58:24.779 --> 05:58:28.895
There's always -- also other 
ways you can look at the data.  

05:58:28.896 --> 05:58:33.006
So the call chart is obviously a
 very visual way to analyze it. 

05:58:33.007 --> 05:58:37.151
 You can also open the top down 
view and see all the calls from 

05:58:37.152 --> 05:58:41.271
are the thread route, from the 
main method all the way down to 

05:58:41.272 --> 05:58:43.321
individual methods that were 
called in your app.  And also 

05:58:43.322 --> 05:58:47.431
see some data, like relative 
times of how long they ran.  And

05:58:49.495 --> 05:58:53.607
 there's another way of looking 
at it.  In the bottom up view, 

05:58:53.608 --> 05:58:55.664
that's the second  tab, I can 
actually sort all the methods 

05:58:55.665 --> 05:58:59.798
that were called by how long 
they ran.  And I can immediately

05:59:01.862 --> 05:59:05.996
 see the method I was telling 
you about, the create disk 

05:59:05.997 --> 05:59:08.068
caches method.  It's very high 
on the list.  I can immediately 

05:59:08.069 --> 05:59:12.166
see that method is actually 
making my oncreate slow.  And 

05:59:12.167 --> 05:59:16.280
then if I expand the nodes in 
the preview, I can actually see 

05:59:16.281 --> 05:59:18.343
where it was called.  So instead
 of going from the thread to the

05:59:18.344 --> 05:59:22.447
 individual methods, I'm going 
the other way around.  Starting 

05:59:22.448 --> 05:59:24.509
with the method I'm interested 
in and  finding out which place 

05:59:24.510 --> 05:59:26.575
in my
code I was calling it.

05:59:26.576 --> 05:59:34.815
Okay.  So let's move on to the 
memory profiler.  So here, 

05:59:34.816 --> 05:59:36.867
again, same situation.  I'm 
rotating my screen.  Something's

05:59:36.868 --> 05:59:40.978
 being recomputed, re-created, 
and my memory goes up.  You can 

05:59:40.979 --> 05:59:45.095
immediately see that from the 
chart.  You can also see some 

05:59:45.096 --> 05:59:49.191
more events.  So you can see 
when GC events were happening.  

05:59:49.192 --> 05:59:53.325
If you see too many of these 
small trash can icons in a short

05:59:53.326 --> 05:59:57.449
 amount of time, and if the 
memory is going up and down, up 

05:59:57.450 --> 06:00:01.563
and down, that means you might 
be  flashing the memory.  You 

06:00:01.564 --> 06:00:03.618
might be creating objects and 
destroying them, which, again, 

06:00:03.619 --> 06:00:05.652
might impact the performance of 
your app.

06:00:05.653 --> 06:00:11.857
Just for debugging, if you need 
to force a garbage collection 

06:00:11.858 --> 06:00:13.926
event, you can do that from 
here.  But the coolest part 

06:00:13.927 --> 06:00:18.029
about this memory view -- about 
this memory analyzer is -- by 

06:00:18.030 --> 06:00:20.081
the way, this is all live.  I 
know I'm presenting this on 

06:00:20.082 --> 06:00:24.213
screenshots, but this is all 
going live when you run your 

06:00:24.214 --> 06:00:28.325
app.  And at any given moment 
when you see something 

06:00:28.326 --> 06:00:32.478
interesting happening in many 
your app, you can drag and drop 

06:00:32.479 --> 06:00:34.567
on the timeline and select a 
slice of time without any pre-

06:00:36.619 --> 06:00:38.674
recording any -- pressing any 
buttons first.  And see all the 

06:00:38.675 --> 06:00:42.831
allocations and  de-allocations 
that happened at that time.

06:00:42.832 --> 06:00:46.953
So here you can see some input 
events in the top.  This is a 

06:00:46.954 --> 06:00:51.069
situation where I was just 
scrolling a long list of items. 

06:00:51.070 --> 06:00:57.253
 Again, of images.  And you can 
see -- just like I said -- 

06:00:57.254 --> 06:00:59.297
memory goes up, memory goes 
down.  There's a lot of garbage 

06:00:59.298 --> 06:01:01.366
collection events.  And for some
 reason my scrolling is very 

06:01:01.367 --> 06:01:07.550
janky.  I can see the app is 
loading something and just 

06:01:07.551 --> 06:01:11.666
thrashing memory.  So I'm  
expecting this place for a 

06:01:11.667 --> 06:01:13.727
possible culprit.  And at the 
bottom you can see a list of all

06:01:13.728 --> 06:01:18.709
 the classes that were either 
allocated or de-allocated within

06:01:18.710 --> 06:01:20.710
 that time

06:01:21.713 --> 06:01:23.763
 slice.  But the really helpful 
views are actually hidden under 

06:01:23.764 --> 06:01:27.890
a drop down.  So you can arrange
 this data in different ways.  

06:01:27.891 --> 06:01:29.891
So here I

06:01:31.943 --> 06:01:33.994
 selected arrange by call stack.
  And I can actually find the 

06:01:33.995 --> 06:01:38.087
place in my list adapter, the 
get view method.  Which if you 

06:01:38.088 --> 06:01:42.244
remember, when you have a long 
list, the adapter recycles views

06:01:42.245 --> 06:01:46.354
 and that has to provide them 
whenever a new view has to be 

06:01:46.355 --> 06:01:48.424
shown on the screen when you 
scroll it.  So I

06:01:48.425 --> 06:01:52.637
found the get view method that 
does exactly that.  And I can 

06:01:52.638 --> 06:01:54.638
see all the allocations that I'm
 making there

06:01:56.724 --> 06:02:00.724
.  And it turns out there's 
actually a lot.  You can see the

06:01:56.724 --> 06:02:00.849
 number of allocations.  You can
 see the memory sizes being 

06:02:00.850 --> 06:02:04.993
allocated.
Another way of looking at it is,

06:02:04.994 --> 06:02:07.061
 you can arrange by package.  
Let's say I'm not interested by 

06:02:07.062 --> 06:02:11.171
third-party libraries.  I'm not 
interested in other system 

06:02:11.172 --> 06:02:13.231
classes.  I'm only interested in
 classes from my code.  So 

06:02:13.232 --> 06:02:17.349
something that I wrote that is 
being allocated.  That's another

06:02:17.350 --> 06:02:21.486
 way to look at it.  So let's go
 back to analyzing the get view 

06:02:21.487 --> 06:02:25.596
method.  So when you actually 
select a class, you can see, on 

06:02:25.597 --> 06:02:29.713
the right, a new view opens and 
you can see all instances or all

06:02:31.779 --> 06:02:33.812
 objects of that class that were
 actually allocated and 

06:02:33.813 --> 06:02:37.958
de-allocated.  Even more, when 
you select any of these objects,

06:02:37.959 --> 06:02:42.065
 you get a call stack.  So you 
can see where -- exactly where 

06:02:42.066 --> 06:02:46.186
that object was allocated.  So 
you can track down these rogue 

06:02:46.187 --> 06:02:50.278
allocations and try and fix it 
somehow.  Maybe move it to some 

06:02:50.279 --> 06:02:56.461
warmup before or just some 
shared cache.

06:02:56.462 --> 06:03:00.592
Another thing you can do with 
the memory analyzer is you can 

06:03:00.593 --> 06:03:04.737
analyze heat dumps.  So whenever
 you want to examine a state in 

06:03:04.738 --> 06:03:08.887
your app -- let's say you were 
using your app.  You were just 

06:03:08.888 --> 06:03:13.011
using it as a normal user would,
 and something's wrong.  You got

06:03:13.012 --> 06:03:15.065
 the app into a weird state.  
Maybe some view is not showing, 

06:03:15.066 --> 06:03:19.180
maybe some image is not loading.
  And you want to figure out 

06:03:19.181 --> 06:03:23.321
what's going on.  Or you want to
 figure out, where is all that 

06:03:23.322 --> 06:03:27.412
memory coming from?  All these 
memory allocations?  What 

06:03:27.413 --> 06:03:31.546
objects actually exist in my 
app?  So just press this button,

06:03:31.547 --> 06:03:35.659
 wait a bit, and then you get a 
similar view as before.  Except 

06:03:35.660 --> 06:03:39.864
now you have a snapshot of 
memory from your app at the time

06:03:39.865 --> 06:03:41.923
 when you pressed the button.  
So, again, you have a list of 

06:03:41.924 --> 06:03:46.107
classes.  You can click on it.  
And you get a list of instances 

06:03:46.108 --> 06:03:50.223
of objects of those classes.  
And here the view looks slightly

06:03:50.224 --> 06:03:54.400
 different.  For every instance 
you can actually analyze all the

06:03:54.401 --> 06:03:58.525
 fields, all the values that 
were held there just as if you 

06:03:58.526 --> 06:04:00.576
were
debugging the app in Android 

06:04:00.577 --> 06:04:04.666
Studio.
So this is nice for figuring out

06:04:04.667 --> 06:04:10.861
 the state of the object.  But 
if you have another problem -- 

06:04:10.862 --> 06:04:12.932
if you know you have a memory 
leak, and, for example, you see 

06:04:12.933 --> 06:04:17.063
an object that shouldn't be 
there.  Let's say it's some 

06:04:17.064 --> 06:04:19.111
activity that you actually 
stopped interacting with a long 

06:04:19.112 --> 06:04:23.246
time ago and it should really be
 garbage collected by now, but 

06:04:23.247 --> 06:04:27.352
it's still there in the list, 
you can use the bottom view  

06:04:27.353 --> 06:04:29.388
here -- the references view -- 
to figure out who is holding 

06:04:29.389 --> 06:04:33.472
references to my view?  Who is 
preventing it from being garbage

06:04:33.473 --> 06:04:39.655
 collected?  And here by 
expanding the nodes, you can 

06:04:39.656 --> 06:04:45.857
find a chain of references.  
Usually to the Window object or 

06:04:45.858 --> 06:04:47.858
--

06:04:57.952 --> 06:05:02.056
And finally, the last profiler, 
network  profiler.  So this view

06:05:02.057 --> 06:05:06.151
 is quite interesting because 
you can see -- you can use it 

06:05:06.152 --> 06:05:10.266
for two purposes.  Analyzing 
network requests, obviously.  

06:05:10.267 --> 06:05:16.433
But the other one is -- it 
actually shows you the radio 

06:05:16.434 --> 06:05:18.493
power state and you can figure 
out battery problems that might 

06:05:18.494 --> 06:05:22.623
be created by your app.  So the 
radio state can be shown in 

06:05:22.624 --> 06:05:24.691
three states, really.  It's 
either Wi-Fi, low powered radio,

06:05:24.692 --> 06:05:26.692
 or

06:05:27.711 --> 06:05:29.763
 high-powered radio.  And the 
way the GSM radio on your 

06:05:29.764 --> 06:05:33.893
devices works, when it doesn't 
have to do any transmissions, 

06:05:33.894 --> 06:05:38.013
when you're not downloading or 
uploading data, it can go to a 

06:05:38.014 --> 06:05:42.117
low powered state to save 
battery life.  As soon as you 

06:05:42.118 --> 06:05:46.233
want to make a request -- if 
your app has to hit the network 

06:05:46.234 --> 06:05:50.342
-- the radio has to be powered 
up.  That already takes up some 

06:05:50.343 --> 06:05:52.415
battery.  Then you make your 
request and then it stays up for

06:05:52.416 --> 06:05:56.528
 some time just in case you want
 to request some more data from 

06:05:56.529 --> 06:06:00.646
the network.
And that can be wasteful.  But 

06:06:00.647 --> 06:06:02.697
you can actually minimize that, 
in fact, by batching your 

06:06:02.698 --> 06:06:08.899
requests.  And if you look here 
-- if you look at your

06:06:12.965 --> 06:06:15.026
 incomer profiler after using it
 for a while, after  interacting

06:06:15.027 --> 06:06:19.145
 with it, you can see if your 
requests were batched in one 

06:06:19.146 --> 06:06:23.246
place.  And you're downloading, 
and then the radio can go to a 

06:06:23.247 --> 06:06:27.365
low-powered state.  Or if you 
were waking the radio up every 

06:06:27.366 --> 06:06:31.469
minute, every 30 seconds, and 
then figure out how to fix it.

06:06:31.470 --> 06:06:33.640
Obviously the profiler is not 
only

06:06:36.746 --> 06:06:40.946
 about the radio state and the 
battery, it's all about network.

06:06:36.746 --> 06:06:40.858
  At the bottom you see the data
 transfer graph.  You see how 

06:06:40.859 --> 06:06:42.917
much data was sent.  When the 
requests were made.  And, again,

06:06:44.978 --> 06:06:47.028
 like on the previous profilers,
 you can select a chunk of time 

06:06:47.029 --> 06:06:53.220
and then see all the HTTP and 
HTTPS requests that were made in

06:06:53.221 --> 06:06:55.283
 that time.  It's a little bit 
similar to

06:06:59.355 --> 06:07:01.409
 Devtools that you know from, 
for example, the content type.  

06:07:01.410 --> 06:07:05.498
You can see a timeline with how 
long a request -- the time that 

06:07:05.499 --> 06:07:09.597
every request took.  But even 
more, if you click on any of 

06:07:09.598 --> 06:07:13.704
these, you can see the actual 
payload.  So if it was an image,

06:07:13.705 --> 06:07:21.922
 like a JPEG or a PNG.  Text, 
such as JSON on HTML, you can 

06:07:21.923 --> 06:07:23.982
see what was downloaded into 
your app through that request.  

06:07:23.983 --> 06:07:28.088
And you can see HTTP headers, 
very useful for debugging 

06:07:28.089 --> 06:07:32.206
problems with server APIs.  And 
finally, you can see the call 

06:07:32.207 --> 06:07:36.301
stack showing you where the call
 was made in your code.

06:07:36.302 --> 06:07:42.489
So that's pretty useful.  A few 
comments.  The profilers work 

06:07:42.490 --> 06:07:46.621
great on Android Oreo.  You 
don't have to literally do 

06:07:46.622 --> 06:07:50.736
anything.  They should just work
 with any debugable A, K.  They 

06:07:50.737 --> 06:07:54.861
work on lower AI versions.  But 
on

06:07:58.936 --> 06:08:03.056
 nougat and below, you have to 
build from Android Studio to use

06:08:03.057 --> 06:08:07.202
 the profilers.  And enable 
advanced profiling.  If you 

06:08:07.203 --> 06:08:11.334
don't have it enabled, don't 
worry.  The profiler will show a

06:08:11.335 --> 06:08:15.481
 prompt and it will literally be
 a one-click fix.  And there are

06:08:15.482 --> 06:08:17.541
 small differences in how 
profilers work.  So, for 

06:08:17.542 --> 06:08:23.724
example, in Nougat and below, to
 track, you have to press a 

06:08:23.725 --> 06:08:25.789
record button just like on the 
CPU chart.  Other than that, 

06:08:25.790 --> 06:08:27.847
most functions should be 
available for you.

06:08:27.848 --> 06:08:34.013
And there is one more new thing 
in Android Studio 3.0.  Is there

06:08:34.014 --> 06:08:36.053
 any, for example, game 
developers out there?  Or people

06:08:36.054 --> 06:08:40.162
 who use alternative ways to 
build your a, PKs such as 

06:08:40.163 --> 06:08:42.163
different

06:08:46.222 --> 06:08:48.286
 IDs or a different tool chain 
and you would like to use the 

06:08:48.287 --> 06:08:52.412
Android profiler or just use 
Android Studio to debug the app.

06:08:54.472 --> 06:09:00.633
  There's a new profile type to 
debug external APKs.  You can 

06:09:00.634 --> 06:09:02.674
select this from the Android 
Studio launcher.  The first 

06:09:02.675 --> 06:09:08.860
screen you see.  Select your APK
 and it a dummy project will be 

06:09:08.861 --> 06:09:12.992
created for you with the APK 
attached.  With the Java code 

06:09:12.993 --> 06:09:19.144
decompiled and you can even see 
the APK contents and the 

06:09:19.145 --> 06:09:23.267
analyzer for you.  And you can 
do that to load an external APK.

06:09:23.268 --> 06:09:25.320
  And you can attach Java 
sources and native libraries 

06:09:25.321 --> 06:09:33.532
with debug symbols that let you 
do step-by-step debugging.

06:09:35.584 --> 06:09:39.705
  And if you wanted to try 
Android Studio for debugging, 

06:09:39.706 --> 06:09:41.749
try it out.
The window on the right, it's 

06:09:41.750 --> 06:09:47.973
not new in Android Studio, 
however, Android Studio 3.0 

06:09:47.974 --> 06:09:52.100
brings some pretty notable 
improvements.  The way you 

06:09:52.101 --> 06:09:58.262
launch is you can select analyze
 APK from the build menu.  One 

06:09:58.263 --> 06:10:00.343
word of advice, if you build 
your

06:10:04.403 --> 06:10:08.525
 APKs using Android Studio, they
 don't contain all the classes 

06:10:08.526 --> 06:10:10.526
and resources

06:10:11.636 --> 06:10:13.636
 you want to look at and 
analyze.  Instead

06:10:14.714 --> 06:10:18.844
, press the build APK or 
generate.  Wait until APK builds

06:10:18.845 --> 06:10:24.994
 and you will get a nice 
generation.  APK is ready and 

06:10:24.995 --> 06:10:29.103
you can open it here or on the 
analyzer.  Press analyzer.  If 

06:10:29.104 --> 06:10:35.285
the analyzer goes through.  Just
 a short walk through.  It's 

06:10:35.286 --> 06:10:39.413
been in Android Studio for a 
time.

06:10:39.414 --> 06:10:41.465
And you can see the basic info 
such as the file sizes of the 

06:10:41.466 --> 06:10:47.637
APK, file size, the download 
size because Play Store 

06:10:47.638 --> 06:10:49.703
compresses the APK for delivery 
to devices.  And then you can 

06:10:49.704 --> 06:10:53.841
get to the classes that are in 
the class files and resources.  

06:10:53.842 --> 06:11:00.008
What we've added in Android 
Studio 3.0, you can now see a 

06:11:00.009 --> 06:11:04.166
third column showing you the 
size of the decks -- of the 

06:11:04.167 --> 06:11:08.291
decks in your APKs.  So you can 
actually see the size of a 

06:11:08.292 --> 06:11:10.349
package, the size of a class, 
and even the size that a method 

06:11:10.350 --> 06:11:14.484
adds to your class' next files. 
 So it's pretty good for 

06:11:14.485 --> 06:11:18.595
figuring out where all that 
space is going to.

06:11:18.596 --> 06:11:22.691
But there's a new thing I wanted
 to announce today.  And just 

06:11:22.692 --> 06:11:28.863
last night we updated the 
Android  apk tools and we are 

06:11:28.864 --> 06:11:30.864
now offering

06:11:32.718 --> 06:11:36.822
 the APK analyzer as a command 
tile for using your CI servers.

06:11:36.823 --> 06:11:38.864
[ Applause ]
So this was a long-standing 

06:11:38.865 --> 06:11:42.960
request.  I'm happy we are 
finally ready to preview.  I'm 

06:11:42.961 --> 06:11:45.019
hoping you'll try it out.  It 
does most of the things and even

06:11:47.102 --> 06:11:53.267
 more than the APK analyzer in 
Android Studio.  The syntax is 

06:11:53.268 --> 06:11:57.415
pretty basic.  It has commands 
that let you inspect things in 

06:11:57.416 --> 06:12:01.533
the manifest, in the APK, in the
 deck size and print out 

06:12:01.534 --> 06:12:05.643
resources from the resource 
table.  It will be great for 

06:12:05.644 --> 06:12:07.701
generating reports on your build
 servers.  It will be great for 

06:12:07.702 --> 06:12:11.798
comparing to APK versions to see
 where your request when it 

06:12:11.799 --> 06:12:15.922
comes to APK size.  And with 
some script through, you can 

06:12:15.923 --> 06:12:22.095
even figure out very, very 
specific changes in your APK 

06:12:22.096 --> 06:12:26.216
such as you take two APKs, list 
all the packages inside, all the

06:12:26.217 --> 06:12:30.337
 classes.  And you notice that 
between these two versions some 

06:12:30.338 --> 06:12:34.464
developer in your project added 
two new classes and they take up

06:12:34.465 --> 06:12:36.551
 X amount of space in those 
APKs.

06:12:36.552 --> 06:12:40.669
So these are only some ideas on 
how you can use them.  I'm 

06:12:40.670 --> 06:12:44.787
curious to hear your feedback on
 this tool.  So please come to 

06:12:44.788 --> 06:12:48.907
see me after this session and 
let's talk.

06:12:48.908 --> 06:12:53.037
And the last thing I wanted to 
mention in this session is 

06:12:53.038 --> 06:12:57.129
Android Vitals.  So this is a 
place in the Android -- in the 

06:12:57.130 --> 06:12:59.130
Google

06:13:01.190 --> 06:13:05.321
 -- that let's you track and 
feed some common problems with 

06:13:05.322 --> 06:13:11.542
your apps happening on user's 
devices.  Such as ANR rate -- 

06:13:11.543 --> 06:13:15.689
application not responding.  
This basically happens whenever 

06:13:15.690 --> 06:13:17.745
you use network or storage for 
the main thread.  You can see 

06:13:17.746 --> 06:13:21.840
the crash rate.  You can figure 
out things like slow rendering 

06:13:21.841 --> 06:13:23.892
or frozen frames.   Which 
usually means you're doing 

06:13:23.893 --> 06:13:27.986
something wrong with the CPU or 
memory as I showed you you can 

06:13:27.987 --> 06:13:34.181
analyze before.
And finally,s wait logs and 

06:13:34.182 --> 06:13:36.226
excessive wakeups which have an 
impact on the user's battery 

06:13:36.227 --> 06:13:43.213
life.  We also offer all this 
information on developers 

06:13:43.214 --> 06:13:47.324
Android com.  Every section has 
a dedicated page that explains 

06:13:47.325 --> 06:13:51.464
all the tools and debug methods 
that you can use to figure out 

06:13:51.465 --> 06:13:54.190
these things and fix them in 
your apps.  So I really 

06:13:54.191 --> 06:13:58.289
encourage you to look it up in 
the Play Store, in the Play 

06:14:00.365 --> 06:14:02.365
Console, and start working on 
it.

06:14:02.426 --> 06:14:04.489
So thank you very much.  I'll be
 here on level three in the 

06:14:04.490 --> 06:14:08.626
Android office hours booth.  If 
you want to talk about the new 

06:14:08.627 --> 06:14:12.742
profilers and the APK analyzer, 
please come talk to me.  And I'm

06:14:12.743 --> 06:14:16.861
 curious to hear what you think.
  Thank you.

06:14:16.862 --> 06:14:18.862
[ Applause ]

06:35:16.377 --> 06:35:22.946
JUAN: Hello, everyone.  My name 
is Juan Silveira.  I'm a 

06:35:22.947 --> 06:35:27.092
software engineer in the health 
team.  And I'm here to tell you 

06:35:27.093 --> 06:35:29.169
a little bit about DeepMind and 
the work we have been doing.  So

06:35:29.170 --> 06:35:37.411
 let me start by telling you who
 we are.  DeepMind is a British 

06:35:37.412 --> 06:35:41.537
artificial intelligence company 
that was founded in 2010 and 

06:35:41.538 --> 06:35:45.637
joined forces with Google in 
2014.  We're an unusual company 

06:35:45.638 --> 06:35:49.765
in that we have a two-part 
mission.   The first part of 

06:35:49.766 --> 06:35:51.827
that mission is to create 
general artificial intelligence.

06:35:51.828 --> 06:35:55.928
  Now, what do we mean by 
"General artificial  

06:35:55.929 --> 06:36:00.033
intelligence"?  And the key here
 is being able to create agents,

06:36:00.034 --> 06:36:04.153
 algorithms, that can work and 
do well in a variety of tasks 

06:36:04.154 --> 06:36:08.265
and environments.  And the key 
to that is to get them to learn 

06:36:08.266 --> 06:36:12.386
from their own experience.  So 
not to pre-program them with 

06:36:12.387 --> 06:36:16.458
behaviors, but to actually allow
 them to learn from what they 

06:36:16.459 --> 06:36:20.589
can see in their environment.
So that's the first part of our 

06:36:20.590 --> 06:36:24.687
mission.  But we also have a 
second part, which is to use 

06:36:24.688 --> 06:36:28.796
artificial general intelligence 
to address pressing social 

06:36:28.797 --> 06:36:37.066
challenges.  So we recognize the
 potential for AGI to really 

06:36:37.067 --> 06:36:39.127
make a change in the world.  And
 we want to make sure that that 

06:36:39.128 --> 06:36:45.326
is the -- the  benefits of that 
reach everyone and they can use 

06:36:45.327 --> 06:36:47.395
it to address things that we, as
 a society, have to deal with.

06:36:47.396 --> 06:36:55.604
So how -- that's our mission.  
How were we actually formed?  We

06:36:55.605 --> 06:37:01.905
 are at heart a research 
orientation.  Based in London, 

06:37:01.906 --> 06:37:08.096
King's Cross.  And we have 300 
of the best AI research 

06:37:08.097 --> 06:37:12.219
scientists in the world here in 
Europe.  We, like any research 

06:37:12.220 --> 06:37:14.306
extension, we do our research in
 the open.  So we actually 

06:37:14.307 --> 06:37:20.494
publish over a hundred papers on
 different research.  And we 

06:37:20.495 --> 06:37:28.736
joined forces with Google in 
2014 so that we could really 

06:37:28.737 --> 06:37:32.829
take our speed up to the next 
level.  And the mixture of these

06:37:32.830 --> 06:37:36.962
 two things means we're a bit of
 a hybrid organization.  On the 

06:37:36.963 --> 06:37:39.018
one hand, we have the really 
very long-term focus of academia

06:37:41.075 --> 06:37:43.132
.  Because AGI  is not something
 that's going to happen any time

06:37:45.180 --> 06:37:49.333
 soon.  But we're very, very 
focused on making that happen.  

06:37:49.334 --> 06:37:53.463
But at the same time we have the
 pace, the scale and the agility

06:37:53.464 --> 06:37:57.661
 of a very well-funded startup.
And because of the second part 

06:37:57.662 --> 06:37:59.727
of our mission, we also have a 
lot of people in our 

06:37:59.728 --> 06:38:03.846
organization that have the kind 
of social impact values that you

06:38:05.903 --> 06:38:10.004
 only find generally in the 
public sector.  Now, I talked 

06:38:10.005 --> 06:38:14.129
about AGI, artificial general 
intelligence.  How is that we're

06:38:14.130 --> 06:38:20.321
 trying to resolve this?  And 
we're trying to resolve this by 

06:38:20.322 --> 06:38:22.381
building general purpose 
learning systems.  And this -- 

06:38:22.382 --> 06:38:26.492
just to give you an idea -- 
involves creating agents that 

06:38:26.493 --> 06:38:32.700
interact with an environment.  
So these agents get signals and 

06:38:32.701 --> 06:38:36.859
make observations of the 
environment.  And decide on 

06:38:36.860 --> 06:38:38.933
actions to take that then get 
reflected into that environment.

06:38:40.988 --> 06:38:45.110
  And once they have taken those
  actions, they can actually 

06:38:45.111 --> 06:38:49.242
observe again how that affects 
the environment.  But the key 

06:38:49.243 --> 06:38:51.306
thing is that they have a goal. 
 A function that tells them 

06:38:51.307 --> 06:38:53.349
whether they're closer to 
actually achieving what it is 

06:38:53.350 --> 06:38:59.539
that they're trying to do.  And 
this whole process is called 

06:38:59.540 --> 06:39:01.582
deep reinforcement learning.  
I'm sure some of you have heard 

06:39:01.583 --> 06:39:05.696
about
it and it's key to what we're 

06:39:05.697 --> 06:39:09.787
doing at DeepMind.
The environment that we use for 

06:39:09.788 --> 06:39:13.872
this is key.  And we've already 
had quite a bit of success using

06:39:15.928 --> 06:39:22.114
 the older ones as a test bed, 
as an environment on which to 

06:39:22.115 --> 06:39:26.357
train agents, Atari games.  We 
have taken over a hundred games,

06:39:26.358 --> 06:39:32.538
 thing like Pong, Frogger,  
Breakout.  Some games I'm sure 

06:39:32.539 --> 06:39:34.606
many of you have  played.  And 
in the environment, what the 

06:39:34.607 --> 06:39:38.712
agent  sees, the inputs, are 
just the pixels on the screen.  

06:39:38.713 --> 06:39:44.859
So just gets a matrix of pixels.
  Not the values that you would 

06:39:44.860 --> 06:39:48.991
see on the screen.  And the 
outputs are the controllers, 

06:39:48.992 --> 06:39:53.113
which are simple controls.  So 
up, down, left, right and 

06:39:53.114 --> 06:39:55.176
trigger buttons.  But the really
 important thing is that the 

06:39:55.177 --> 06:39:59.317
agent is not told what to do.  
So it's not told the rules of 

06:39:59.318 --> 06:40:03.435
the different games.  It's not 
told, like, how it works.  Like 

06:40:03.436 --> 06:40:09.595
what are the internal function 
of the Atari game.  So any 

06:40:09.596 --> 06:40:13.707
knowledge needs to be learned 
from scratch with serial 

06:40:13.708 --> 06:40:17.824
pre-programming.  Like no 
strategies how to play the 

06:40:17.825 --> 06:40:19.880
different games.  We give it a 
goal.  And that is to

06:40:19.881 --> 06:40:24.009
maximize the score.
But the key thing that I think 

06:40:24.010 --> 06:40:28.129
is fantastic when I first 
learned about this was that one 

06:40:28.130 --> 06:40:32.318
agent plays all of the game.  So
 you don't train one agent for 

06:40:32.319 --> 06:40:34.371
each game, you train one agent 
in all of the games and have it 

06:40:34.372 --> 06:40:38.489
play all of the games.  So a 
good analogy of how this works 

06:40:38.490 --> 06:40:44.707
is that you could have a little 
robot in an arcade sitting in 

06:40:44.708 --> 06:40:46.758
front of the game looking at the
 screen and moving the  

06:40:46.759 --> 06:40:48.812
controller.  That's all.  It 
doesn't have any knowledge of 

06:40:48.813 --> 06:40:52.948
the internal works.
So let me show you how this 

06:40:52.949 --> 06:40:59.120
looks like.  As the agent is 
being trained on how it evolves.

06:40:59.121 --> 06:41:03.229
  So this is the game of 
Breakout.  I'm sure many of you 

06:41:03.230 --> 06:41:05.275
have played.  How many of you 
have played Breakout  before?  

06:41:05.276 --> 06:41:11.435
Great.  I won't explain it.  So 
the agent starts -- it starts 

06:41:11.436 --> 06:41:13.478
training.  After half an hour, 
it doesn't really know what's 

06:41:13.479 --> 06:41:17.610
happening.  So just loses quite 
quickly.  Sometimes it manages 

06:41:17.611 --> 06:41:21.727
to bounce the ball back.  Mostly
 just loses quite quickly.

06:41:21.728 --> 06:41:25.856
After an hour of training, it 
gets a little bit better.  It's 

06:41:25.857 --> 06:41:29.968
like, maybe survives two 
bounces.  But that's about it.  

06:41:29.969 --> 06:41:36.184
It actually still loses quite 
quickly.  But after two hours, 

06:41:36.185 --> 06:41:40.297
it's now doing how you would do 
probably if you started playing 

06:41:40.298 --> 06:41:46.497
 Breakout right now.  Runs 
around, bounces the ball back 

06:41:46.498 --> 06:41:48.557
and manages a basic level of 
competence.  But the great thing

06:41:50.615 --> 06:41:54.740
 is what happened unexpectedly 
after we let it play for four 

06:41:54.741 --> 06:41:56.806
hours and the agent started 
doing this.

06:42:00.882 --> 06:42:02.946
[ Laughter ]
So for those of you that have 

06:42:02.947 --> 06:42:05.016
actually played  Breakout for 
some time, you learned this is a

06:42:07.081 --> 06:42:09.146
  winning strategy.  Break the 
sides and push the ball up to 

06:42:09.147 --> 06:42:13.237
the top and it just does the 
work for you.  But this is not 

06:42:13.238 --> 06:42:15.296
something that was 
pre-programmed on the system.  

06:42:15.297 --> 06:42:19.407
It's not something that we told 
the agent about.  It's something

06:42:19.408 --> 06:42:21.471
 that the agent  discovered by 
playing the game thousands and 

06:42:21.472 --> 06:42:26.094
thousands of times with this 
goal function of improving the 

06:42:26.095 --> 06:42:28.095
score.  And this is a

06:42:29.206 --> 06:42:31.206
 power of deep reinforcement 
learning that allows these kinds

06:42:31.246 --> 06:42:37.394
 of behaviors to emerge.
So we use the Atari games for a 

06:42:37.395 --> 06:42:41.524
long time for research.  And we 
still use them today.  We  

06:42:41.525 --> 06:42:45.635
published papers about this 
research.  It was quite 

06:42:45.636 --> 06:42:49.750
successful.  But a few years ago
 there was a team at DeepMind 

06:42:49.751 --> 06:42:51.811
that started looking for a new 
challenge.  And that challenge 

06:42:51.812 --> 06:42:58.006
was the game of Go.  Let's see 
if I can --

06:42:58.007 --> 06:43:02.132
So for those of you that don't 
know Go, it's a very ancient 

06:43:02.133 --> 06:43:06.230
game originated in China about 3
,000 years ago.  And it's 

06:43:06.231 --> 06:43:10.350
considered by many to be more 
than just a game.  It's -- 

06:43:10.351 --> 06:43:16.514
people think about it as a 
spiritual dimension as poetry or

06:43:16.515 --> 06:43:20.624
 art.  It was considered to be 
one of the four arts that were 

06:43:20.625 --> 06:43:26.798
key to being mastered by a true 
scholar.  It is hugely popular 

06:43:26.799 --> 06:43:28.853
in many places, especially in 
Asia.  There's 40 million 

06:43:28.854 --> 06:43:32.974
players, 2,000 professional 
players.  And there's schools 

06:43:32.975 --> 06:43:39.150
throughout Japan, south Korea 
and China.  And the thing about 

06:43:39.151 --> 06:43:41.609
Go, why it's a great challenge, 
is because it has very simple 

06:43:41.610 --> 06:43:43.610
rules

06:43:44.656 --> 06:43:46.704
.  You can learn the rules of Go
 in a couple of minutes.  But 

06:43:46.705 --> 06:43:50.802
from those rules arises a huge 
profound complexity.  To give 

06:43:50.803 --> 06:43:54.930
you the idea of a scale, there's
 an estimate that there's about 

06:43:54.931 --> 06:43:56.989
10 to the 80 number of atoms in 
the universe.  But there are 10 

06:43:56.990 --> 06:44:05.232
to the 170 possible board 
configurations in Go.  So it's 

06:44:05.233 --> 06:44:09.345
impossible to play Go by brute 
forcing or  trying to explore 

06:44:09.346 --> 06:44:11.396
all of that
possibility space with no good 

06:44:11.397 --> 06:44:13.445
strategy.  And that means that 
Go has been one of the great 

06:44:13.446 --> 06:44:19.613
challenges for AI, because no 
computer program could beat a 

06:44:19.614 --> 06:44:21.690
professional -- human 
professional Go player.

06:44:23.758 --> 06:44:27.859
If you compared this to chess, 
which is something that computer

06:44:27.860 --> 06:44:31.948
 programs have been doing well 
for a while, the number of 

06:44:31.949 --> 06:44:36.071
possible moves at any time in 
chess is 20.  And in Go, it's 

06:44:36.072 --> 06:44:42.264
over it00.  So the team at 
DeepMind started creating 

06:44:42.265 --> 06:44:48.410
artificial intelligence program 
that's alled Alpha Go.  And 

06:44:48.411 --> 06:44:52.515
Alpha Go is composed of two 
neural networks.  You have the 

06:44:52.516 --> 06:44:54.572
policy network and the value 
network.  And the policy network

06:44:54.573 --> 06:45:01.087
 was initially trained using 
human games.  So we

06:45:04.173 --> 06:45:06.231
 took thousands of games from an
 online  Go server that we had 

06:45:06.232 --> 06:45:10.340
access to and trained this 
network by watching those games.

06:45:10.341 --> 06:45:12.396
And then trained it further by 
playing against itself.  And the

06:45:14.456 --> 06:45:19.170
 objective of the policy network
 is to given a particular 

06:45:19.171 --> 06:45:21.216
configuration of the board, to 
say which positions are most 

06:45:21.217 --> 06:45:24.164
likely to be played next.  And 
that allows you to

06:45:27.210 --> 06:45:29.264
 narrow down that branching 
factor.  The other network -- 

06:45:29.265 --> 06:45:31.335
the value network -- takes the 
configuration of the board and 

06:45:31.336 --> 06:45:37.498
what it tries to estimate is how
 likely is white or black to 

06:45:37.499 --> 06:45:39.553
win?  So instead of having to 
actually play out the entirety 

06:45:39.554 --> 06:45:43.698
of the game to try to figure out
 who is most likely to win, this

06:45:43.699 --> 06:45:47.827
 allows us to cut down how deep 
you need to go in order to 

06:45:47.828 --> 06:45:49.888
explore the possibilities.

07:19:48.147 --> 07:19:56.706
[ Applause ]
&gt;&gt; Wow.  That's pretty cool.  

07:19:56.707 --> 07:20:01.042
Two days of  learning.  Two days
 conversation.  I can't believe 

07:20:01.043 --> 07:20:03.043
it's over.  Can you?

07:20:04.183 --> 07:20:08.306
  It's like it just started.  
And we aspired to create a 

07:20:08.307 --> 07:20:10.370
conference for all of you that 
is more than just a technology 

07:20:10.371 --> 07:20:14.526
show.  We  aspired it to be 
European, to be a place of  

07:20:14.527 --> 07:20:16.581
learning, and to be an inclusive
 place where you can get 

07:20:16.582 --> 07:20:20.720
inspired and have conservations 
and just love being a developer 

07:20:20.721 --> 07:20:26.921
around a developer crowd.
So when you design something 

07:20:26.922 --> 07:20:28.977
like this, there are a couple of
 things that you try to get 

07:20:28.978 --> 07:20:33.123
right.  And then you wonder if 
you really got it right.  So 

07:20:33.124 --> 07:20:37.243
being a place of learning, kind 
of easy, right?  You ask the 

07:20:37.244 --> 07:20:41.359
audience -- in that case, you, 
developers, what would you like 

07:20:41.360 --> 07:20:45.491
to hear?  Invite experts, get 
sessions, put on an agenda, find

07:20:45.492 --> 07:20:51.676
 a place.  Check.  And after the
 event we ask how we did and how

07:20:51.677 --> 07:20:53.729
 we can improve.  Being a 
European conference, also kind 

07:20:53.730 --> 07:20:59.909
of easy.  So in this room we are
 actually more than European.  

07:20:59.910 --> 07:21:02.101
We are a global conference.  We 
have 71 nations sitting in the 

07:21:02.102 --> 07:21:06.204
room, and more than two-thirds 
of you come from countries 

07:21:06.205 --> 07:21:10.323
outside of Poland.  So this is 
truly an international European 

07:21:10.324 --> 07:21:14.431
concerns and that is what I 
heard from you all over the 

07:21:14.432 --> 07:21:18.554
place.  Among the good 
conversations, you liked the 

07:21:18.555 --> 07:21:20.617
perspectives from people from 
other countries.  The inclusive,

07:21:22.698 --> 07:21:24.759
 inspiring part is a tricky 
piece.

07:21:24.760 --> 07:21:28.890
Because, well, how do you test 
for that?  There are a million 

07:21:28.891 --> 07:21:33.003
little things you can do and 
try, and it's not easy to test. 

07:21:33.004 --> 07:21:37.539
 Some would say it's more a soft
 thing.  But wait a minute, we 

07:21:37.540 --> 07:21:39.540
can ask,

07:21:40.627 --> 07:21:42.679
 right?  So I can -- I can run a
 little experiment.  Maybe you 

07:21:42.680 --> 07:21:46.795
do it with me.  I am going to 
raise my hand, and everybody who

07:21:48.851 --> 07:21:50.920
 feels, like, inspired being -- 
learned something new and being 

07:21:50.921 --> 07:21:57.082
part of an inclusive conference 
just start cheering.  How about 

07:21:57.083 --> 07:22:01.173
that?  Let's try.
[ Applause ]

07:22:01.174 --> 07:22:07.314
That was like medium-size cheer.
  And it was kind of expected.  

07:22:07.315 --> 07:22:11.753
So if you look around and you 
were some -- in the cheering 

07:22:11.754 --> 07:22:15.881
crowd, you might have noticed 
some of you didn't cheer.  

07:22:15.882 --> 07:22:20.003
Because,  actually, we Europeans
 don't cheer that easily.  Just 

07:22:20.004 --> 07:22:26.171
because some clown on stage says
 cheer, we don't cheer.  And 

07:22:26.172 --> 07:22:30.294
that -- that is kind of a -- 
that's a well known stereotype. 

07:22:30.295 --> 07:22:38.524
 Actually, we, as Europeans, 
subscribe to that stereotype.  

07:22:38.525 --> 07:22:42.646
Others believe it and Europeans 
believe it and do it themselves.

07:22:42.647 --> 07:22:46.753
  And these kinds of stereotypes
 we know.  There are like a 

07:22:46.754 --> 07:22:48.802
million other things that are 
unconsciously baked into how we 

07:22:48.803 --> 07:22:50.877
behave, how we make decisions.  
Now, we are engineers.  So it's 

07:22:50.878 --> 07:22:55.006
like a decision through your 
filter, if you will.  Our brains

07:22:55.007 --> 07:22:59.131
 are remarkably good at that 
because that  helps us 

07:22:59.132 --> 07:23:03.309
navigating the world faster than
 we would without these 

07:23:03.310 --> 07:23:05.362
heuristics, if you will.
So these unconscious 

07:23:05.363 --> 07:23:09.482
stereotypes, these unconscious 
biases, they influence how you 

07:23:09.483 --> 07:23:13.597
make products, how you make 
decisions.  The conference is a 

07:23:13.598 --> 07:23:19.772
product, if you will.  Software 
is a product.  Hardware -- you 

07:23:19.773 --> 07:23:23.883
build products out of these  
elements.  And your stereotypes 

07:23:23.884 --> 07:23:25.948
influence your decisions.  Your 
conscious and unconscious biases

07:23:25.949 --> 07:23:28.026
 influence your decisions.  By 
extension, sometimes, they 

07:23:28.027 --> 07:23:32.143
influence what kind of product 
you build.

07:23:32.144 --> 07:23:36.268
We, at Google, we build products
 that have a global scale.  We 

07:23:36.269 --> 07:23:40.412
want everyone to be part of this
 technology build that we are 

07:23:40.413 --> 07:23:46.578
all creating together.  How do 
we build processes?  How do we 

07:23:46.579 --> 07:23:52.765
design software?  How do we 
design systems that are -- 

07:23:52.766 --> 07:23:54.809
without realizing, without 
wanting it -- maybe  biased as 

07:23:54.810 --> 07:23:58.917
well?  Our biases creep in.  And
 if you take an example of this 

07:23:58.918 --> 07:24:03.023
had conference, this was an 
important question when we 

07:24:03.024 --> 07:24:05.088
started building up the project 
team and started working towards

07:24:05.089 --> 07:24:07.147
 these two amazing days we just 
had.

07:24:09.210 --> 07:24:13.296
So we brought -- and we thought,
 in this last session of this 

07:24:13.297 --> 07:24:17.408
two day conference, we talk a 
little bit about how Google 

07:24:17.409 --> 07:24:21.525
tries to build software in a way
 that's more inclusive.  What 

07:24:21.526 --> 07:24:23.589
are the processes?  What are the
 practices?  What are the things

07:24:23.590 --> 07:24:25.666
 that we try to do in order to

07:24:28.681 --> 07:24:32.809
 overcome that challenge?  So 
please welcome to the stage 

07:24:32.810 --> 07:24:41.044
engineering lead at YouTube, 
Sowmya Subrama.

07:24:41.045 --> 07:24:43.045
[ Applause ]

07:24:47.113 --> 07:24:51.241
SOWMYA: Thank you, Kirk.  I'm 
super-excited to be here.  I 

07:24:51.242 --> 07:24:53.298
still remember my first 
technical conference 

07:24:53.299 --> 07:24:59.463
presentation.  Almost 17 years 
ago in Paris.  Where I, the 

07:24:59.464 --> 07:25:01.517
speaker, was pretty much the 
only female engineer in the 

07:25:01.518 --> 07:25:05.624
whole room.  To see so many 
women engineers at this 

07:25:05.625 --> 07:25:11.807
conference has been amazing.  We
 have come a really long way.  

07:25:11.808 --> 07:25:13.874
And let's give a big round of 
applause to that.

07:25:15.935 --> 07:25:17.935
[ Applause ]

07:25:26.032 --> 07:25:28.097
As Dirk mentioned, I'm an 
engineering director at YouTube 

07:25:28.098 --> 07:25:32.204
and I will be showing a lot of 
YouTube videos in my 

07:25:32.205 --> 07:25:38.360
presentation.  So let's start 
off with a video of a favorite 

07:25:38.361 --> 07:25:46.611
clip of mine.
&gt;&gt; Cookie!

07:26:00.724 --> 07:26:02.724
[ Applause ]

07:26:12.811 --> 07:26:16.922
SOWMYA: Oh!  The video's not 
playing on screen.

07:26:23.003 --> 07:26:27.132
  I can see it.
[ Laughter ]

07:26:49.252 --> 07:26:51.252
[ Applause ]

07:26:53.325 --> 07:26:55.362
Okay.

07:34:06.845 --> 07:34:11.351
SOWMYA: All right.  Okay.  Shall
 we get this started again?  

07:34:11.352 --> 07:34:15.489
Yes.  So sorry about the 
projection not showing up.  It's

07:34:17.548 --> 07:34:19.608
 a video you're going to enjoy, 
I promise.  So let's start with 

07:34:19.609 --> 07:34:23.748
the video.  Is it progressing?
[ Laughter ]

07:34:25.977 --> 07:34:30.093
It's not?
[ Applause ]

07:37:46.249 --> 07:37:48.700
SOWMYA: Are we doing the voice 
of God?  Okay.  All right.  

07:37:48.701 --> 07:37:54.869
Let's see if this works.  This 
is how we debug problems in 

07:37:54.870 --> 07:38:01.084
Google.  Let's try it.
[ Applause ]

07:38:03.132 --> 07:38:05.132
Yes!

07:38:21.263 --> 07:38:23.263
[Music

07:38:25.326 --> 07:38:27.326
 playing]

07:39:01.551 --> 07:39:05.671
This is --
[ Applause ]

07:39:07.711 --> 07:39:12.068
So this is a clip from my 
all-time favorite YouTube rewind

07:39:12.069 --> 07:39:18.226
 videos from 2015.  Because it 
really captures the essence of 

07:39:18.227 --> 07:39:22.346
YouTube.  YouTube started out 
with a very simple mission: 

07:39:22.347 --> 07:39:26.458
broadcast yourself.  And it has 
grown into a global platform 

07:39:26.459 --> 07:39:34.958
with global reach.  We have over
 1.5 billion users coming to 

07:39:34.959 --> 07:39:39.066
YouTube every month.  And over 
80% of our views come from 

07:39:39.067 --> 07:39:46.064
outside the United States.  We 
are an open and democratic 

07:39:46.065 --> 07:39:50.326
platform with over 400 hours of 
videos being uploaded every 

07:39:50.327 --> 07:39:54.431
minute by creators all around 
the world.  Making YouTube the 

07:39:54.432 --> 07:39:58.534
platform with the most diverse 
content.

07:39:58.535 --> 07:40:02.661
In the time that it took me to 
say this sentence, or for us to 

07:40:02.662 --> 07:40:06.784
debug that problem earlier, 
almost a full day's worth of 

07:40:06.785 --> 07:40:14.994
videos have been  uploaded to 
YouTube.  What makes YouTube 

07:40:14.995 --> 07:40:19.132
special is that unlike 
traditional media or television,

07:40:19.133 --> 07:40:25.285
 we have no gatekeepers.  Anyone
 can have a voice and reach and 

07:40:25.286 --> 07:40:31.437
build an audience.  While this 
is still very, very true about 

07:40:31.438 --> 07:40:35.557
YouTube, a few years ago when I 
was looking at some usage data 

07:40:35.558 --> 07:40:41.727
on YouTube, I realized that as 
our platform and usage have 

07:40:41.728 --> 07:40:47.888
grown, human dynamics and 
unconscious biases -- like what 

07:40:47.889 --> 07:40:49.968
Dirk was talking about -- are 
creeping in.  And on

07:40:56.681 --> 07:41:00.947
 YouTube, too, we see biases and
 gender gaps, for instance, like

07:40:56.681 --> 07:41:01.013
 traditional media.
On YouTube, too, we see a lot of

07:41:01.014 --> 07:41:05.145
 our makeup videos, for 
instance, are created by female 

07:41:05.146 --> 07:41:07.222
 creators.  And a lot of the 
science and engineering and 

07:41:07.223 --> 07:41:13.413
technology videos are made by 
male creators.  With this in 

07:41:13.414 --> 07:41:19.599
sight, I started a conservation 
and a pitch within YouTube and 

07:41:19.600 --> 07:41:21.669
across Google at large whose 
mission is to build products for

07:41:23.719 --> 07:41:28.009
 all about diversity in the 
context of product design.  And 

07:41:28.010 --> 07:41:30.010
how does

07:41:31.112 --> 07:41:33.167
 unconscious bias play into 
product engineering?

07:41:35.244 --> 07:41:37.304
What if -- in YouTube -- in 
addition to optimizing for the 

07:41:37.305 --> 07:41:43.463
growth of watch time, we became 
more intentional about our 

07:41:43.464 --> 07:41:49.631
demographic goals.  Such as 
gender reach or ethnicity reach.

07:41:49.632 --> 07:41:53.753
  That would unlock 
opportunities for deeper 

07:41:53.754 --> 07:41:57.857
engagement and onboard more 
users, thereby driving growth.  

07:41:57.858 --> 07:42:03.988
So for the first time at Google,
 we extended our dialogues 

07:42:03.989 --> 07:42:08.111
around diversity at Google from 
being about hiring and building 

07:42:08.112 --> 07:42:16.434
balanced teams, to about 
diversity becoming a core piece,

07:42:16.435 --> 07:42:18.509
 to defining the growth 
strategies for all our products.

07:42:20.561 --> 07:42:24.735
  And that brings me to today's 
topic of inclusive design as a 

07:42:24.736 --> 07:42:31.002
growth accelerator.
So what is inclusive design?  

07:42:31.003 --> 07:42:35.184
It's about engineering products 
for all your target users across

07:42:35.185 --> 07:42:41.406
 all demographics.  When you 
broaden your demographic reach, 

07:42:41.407 --> 07:42:45.633
you're increasing your user 
funnel and thereby driving 

07:42:45.634 --> 07:42:51.876
growth for your products.  
Inclusive design is not just 

07:42:51.877 --> 07:42:53.929
about user design or visual 
design, it is also about machine

07:42:56.016 --> 07:43:00.162
 learning and algorithms.  About
 the training data.  About  

07:43:00.163 --> 07:43:02.248
testing.  About how you launch 
the product.  The branding.  

07:43:02.249 --> 07:43:10.541
Marketing.  And more.  Inclusive
 design is about asking which 

07:43:10.542 --> 07:43:14.692
target user segments could you 
be doing more for?  It could be 

07:43:14.693 --> 07:43:18.824
gender-based.  It could also be 
that your products work great 

07:43:18.825 --> 07:43:23.011
when you have good connectivity.
  But then doesn't work that 

07:43:23.012 --> 07:43:27.167
well in the developing world.
It could be about optimizing 

07:43:27.168 --> 07:43:29.168
your products for certain 
ethnicity

07:43:31.262 --> 07:43:35.403
 groups.  As an industry, we all
 have been doing inclusive 

07:43:35.404 --> 07:43:39.539
design for lots of years now in 
the form of accessibility work. 

07:43:39.540 --> 07:43:45.695
 And this is about expanding 
that across other dimensions.  

07:43:45.696 --> 07:43:49.832
For instance, when airbags first
 came out, there were more 

07:43:49.833 --> 07:43:56.035
deaths and injuries in women and
 kids.  Why?  Because airbags 

07:43:56.036 --> 07:44:04.305
were tested with only tall, male
 crash test dummies.

07:44:06.368 --> 07:44:08.452
  Were the engineers who 
designed this sexist?  No.  It's

07:44:10.525 --> 07:44:12.626
 because of the unconscious 
biases that informed their 

07:44:12.627 --> 07:44:16.758
process.  Female drivers tend to
 have a smaller build.  And in 

07:44:16.759 --> 07:44:25.042
real crashes have 47% higher 
chance of severe injuries than 

07:44:25.043 --> 07:44:29.192
men.  So once the industry 
included women in their design 

07:44:29.193 --> 07:44:33.322
and started using female crash 
test dummies, the safety of 

07:44:33.323 --> 07:44:37.464
airbags went up significantly 
for women.  And not just for 

07:44:37.465 --> 07:44:41.600
women, but for anyone with a  
smaller build.

07:44:41.601 --> 07:44:48.731
So this is an example of 
gender-based inclusive design.  

07:44:48.732 --> 07:44:50.786
Airbags still don't work well 
for kids, and that is an 

07:44:50.787 --> 07:44:54.930
opportunity of growth.  For this
 next example that I want to 

07:44:54.931 --> 07:44:59.036
show you, I'll start with the 
video.

07:45:27.999 --> 07:45:32.142
[ Laughter ]
So anyone know what's going on 

07:45:32.143 --> 07:45:36.278
there?  For this we need to go 
back to the 1950s when Kodak was

07:45:38.333 --> 07:45:42.479
 dominating color photography.  
And they introduced the Shirley 

07:45:42.480 --> 07:45:46.600
color card which has become the 
standard for all photography.  

07:45:46.601 --> 07:45:50.724
But it works better with  
lighter skin tones.  So what 

07:45:50.725 --> 07:45:56.912
this means is, you often have 
exposure issues when taking 

07:45:56.913 --> 07:46:05.237
multi-racial photos.  This 
problem was recognized as a big 

07:46:05.238 --> 07:46:09.339
problem in the 1970s when 
chocolate makers and wood 

07:46:09.340 --> 07:46:13.471
manufacturers were having a hard
 time creating advertising 

07:46:13.472 --> 07:46:17.619
material for their products 
because they could not capture 

07:46:17.620 --> 07:46:23.832
in photos the different shades 
of brown.  So a funny way for 

07:46:23.833 --> 07:46:27.977
this problem to get surfaced.  
It also was becoming an 

07:46:27.978 --> 07:46:30.049
increasing problem in the media 
and television world was  

07:46:30.050 --> 07:46:36.254
starting to become more diverse.
  Finally, 25 years later, in 

07:46:36.255 --> 07:46:42.488
1995, a group of engineers took 
an inclusive design approach to 

07:46:42.489 --> 07:46:46.634
help bridge this gap.  And they 
launched multi-racial color 

07:46:46.635 --> 07:46:50.814
cards which have significantly 
improved camera and

07:46:50.815 --> 07:46:54.927
photo technology and helped 
unlock a lot of advertising 

07:46:54.928 --> 07:46:59.064
revenue and new business 
opportunities.

07:47:01.153 --> 07:47:05.294
While things have improved, 
there's still a slight light-had

07:47:05.295 --> 07:47:09.796
 skinned bias, which is what you
 saw in the video earlier.  The 

07:47:09.797 --> 07:47:13.977
black color skin is not 
recognized by the camera, which 

07:47:13.978 --> 07:47:18.115
is why, when the black person 
was moving, it seems so stable. 

07:47:18.116 --> 07:47:20.174
 But the face recognition was 
able to follow along with the 

07:47:20.175 --> 07:47:26.385
white-skinned person.  I'm 
really proud that at Google 

07:47:26.386 --> 07:47:28.386
we've taken a proactive

07:47:30.443 --> 07:47:32.521
, inclusive design approach to 
helping bridge this gap.  And 

07:47:32.522 --> 07:47:34.625
the Google camera team is 
helping solve this problem.  

07:47:34.626 --> 07:47:38.742
Let's watch a video on what the 
camera team has done.

07:49:21.113 --> 07:49:23.595
[ Applause ]

07:49:27.669 --> 07:49:31.785
SOWMYA: All right.  So this next
 example, how many of you know 

07:49:31.786 --> 07:49:38.034
of Cheeto?  A few.  Cheese 
puffs?  Or cheese -- the cheesy 

07:49:38.035 --> 07:49:47.082
snacks.  It's a very American 
snack, called Cheeto.  And when 

07:49:47.083 --> 07:49:51.216
it first came out, it was only 
available in one flavor.  The 

07:49:51.217 --> 07:49:55.334
cheesy flavor.  Cheese flavor.  
Until a janitor who worked for 

07:49:55.335 --> 07:49:59.552
the company started adding chili
 and lime to his pacts of Cheeto

07:49:59.553 --> 07:50:03.735
 to make it more flavorful for 
him.  He was Latino and loved 

07:50:03.736 --> 07:50:07.888
chili and lime.  His family and 
friends also liked the taste.  

07:50:07.889 --> 07:50:14.103
So he decided to pitch this new 
flavor idea to the president of 

07:50:14.104 --> 07:50:16.144
the company who actually 
listened to this janitor and 

07:50:16.145 --> 07:50:22.367
decided to experiment with this 
new flavor.  And that unlocked 

07:50:22.368 --> 07:50:24.444
huge opportunities and markets 
for

07:50:28.530 --> 07:50:32.668
 Cheetos.  I'm happy to say the 
janitor is now an executive at 

07:50:32.669 --> 07:50:34.760
the company.  It's a true  rags 
to riches story.  And more 

07:50:34.761 --> 07:50:43.030
importantly, it's a story that 
shows cultural inclusive design 

07:50:43.031 --> 07:50:47.182
thinking.
This next example is from 

07:50:47.183 --> 07:50:51.283
YouTube.  A few years ago, we 
wanted to increase engagement 

07:50:51.284 --> 07:50:55.461
with kids and families on 
YouTube.  So we brought kids 

07:50:55.462 --> 07:51:01.655
into our UX lab to see how do 
they use and interact with  

07:51:01.656 --> 07:51:07.845
YouTube?  This is what we see.  
Yeah?  Everyone uses YouTube 

07:51:07.846 --> 07:51:11.970
here?  Yes.  Many.  This is what
 we see.  But the kids, when 

07:51:11.971 --> 07:51:21.062
they saw the same thing, this is
 how they saw it.  They didn't 

07:51:21.063 --> 07:51:23.128
care about anything else on the 
screen other than the video 

07:51:23.129 --> 07:51:29.322
content that was there.  That is
 when we realized if we wanted 

07:51:29.323 --> 07:51:35.525
to increase engagement with kids
 and families, we had to 

07:51:35.526 --> 07:51:39.689
reimagine YouTube from the 
ground up and build a new app.  

07:51:39.690 --> 07:51:45.849
And that's when YouTube Kids App
 was born.  The YouTube Kids App

07:51:47.938 --> 07:51:52.074
 provides easy to use 
interactivity and safe, 

07:51:52.075 --> 07:51:54.170
enriching and engaging content 
for kids and families.  And 

07:51:54.171 --> 07:51:58.678
we've done this by improving our
 user design and visual design 

07:51:58.679 --> 07:52:04.917
and user interactions.  And also
 by making a lot of changes to 

07:52:04.918 --> 07:52:09.060
our algorithms, the backend 
systems, and our content 

07:52:09.061 --> 07:52:11.135
classification
systems.

07:52:11.136 --> 07:52:17.326
YouTube Kids now has over 11 
million weekly  active users.  

07:52:17.327 --> 07:52:21.464
And we see the engagement with 
kids and family content on the 

07:52:21.465 --> 07:52:27.691
YouTube Kids App to be 
significantly more than on main 

07:52:27.692 --> 07:52:31.828
YouTube.  This is a great 
example of age-based inclusive 

07:52:31.829 --> 07:52:38.047
design driving growth.  It also 
demonstrates, clearly, that 

07:52:38.048 --> 07:52:42.164
sometimes for you to meet the 
needs of specific target user 

07:52:42.165 --> 07:52:46.271
demographics, you might have to 
build a specialized product for 

07:52:46.272 --> 07:52:52.459
them.  How many of you have used
 a YouTube Kids App?  Hardly 

07:52:52.460 --> 07:52:56.650
any.  Okay.  Because we haven't 
launched in all the markets yet.

07:52:56.651 --> 07:53:00.770
  So I'm going to play the first
 launch video of YouTube Kids 

07:53:00.771 --> 07:53:04.901
App for you to get an idea of 
what I'm talking about.  Let's 

07:53:04.902 --> 07:53:07.003
roll the video.

07:54:28.648 --> 07:54:30.648
[ Applause ]

07:54:34.734 --> 07:54:36.734
SOWMYA: So how many of you use

07:54:38.830 --> 07:54:40.889
 emojis?  Yeah.  You are not 
alone.  90% of the world's 

07:54:40.890 --> 07:54:42.963
online population also uses 
emoji

07:54:47.136 --> 07:54:53.324
s.  Why there are many emojis to
 choose from, they're fairly 

07:54:53.325 --> 07:54:59.549
stereo  typical.  The boys are 
doctors or police and others.  

07:54:59.550 --> 07:55:01.607
And the girls are queens and 
princesses and giving haircuts 

07:55:01.608 --> 07:55:07.842
to people.  So it's fairly 
stereotypical.  So bridge that 

07:55:07.843 --> 07:55:12.029
gap and to also be inspiring for
 young girls, Google has added a

07:55:12.030 --> 07:55:16.133
 whole new set of emojis to 
represent women and men in 

07:55:16.134 --> 07:55:22.315
diverse roles.  And in a mix of 
hair and skin colors to be more 

07:55:22.316 --> 07:55:28.515
inclusive.  This is driving 
industry-wide change with iOS, 

07:55:28.516 --> 07:55:34.704
Facebook, Twitter and others 
embracing these new set of 

07:55:34.705 --> 07:55:38.884
emojis in their products and 
platforms.  This is a great case

07:55:38.885 --> 07:55:47.174
 of gender-based and ethnicity-
based inclusive design.

07:55:47.175 --> 07:55:51.318
[ Applause ]
This next example is, again, 

07:55:51.319 --> 07:55:55.436
from YouTube.  How many of you 
have heard of women harassment 

07:55:55.437 --> 07:56:01.625
in online communities?  Like the
 gaming community, through 

07:56:01.626 --> 07:56:05.794
hashtags and online commenting 
tools?  Some of you.  Yeah.  

07:56:05.795 --> 07:56:09.924
Many of you might have heard of 
Gamergate where women gamers 

07:56:09.925 --> 07:56:14.059
were even threatened for their 
lives using these online 

07:56:14.060 --> 07:56:20.254
commenting tools.
A few years ago in YouTube, we 

07:56:20.255 --> 07:56:22.323
organized a women at YouTube 
hack-a-thon around the theme of 

07:56:22.324 --> 07:56:28.570
bridging the gender gap to drive
 grassroots momentum around 

07:56:28.571 --> 07:56:32.747
inclusive design.  One of the 
salient projects in this 

07:56:32.748 --> 07:56:36.859
hack-a-thon focused on improving
 YouTube comments to help women 

07:56:36.860 --> 07:56:43.103
combat harassment and feel safer
 on YouTube.  As a result of 

07:56:43.104 --> 07:56:45.186
this  hack-a-thon project, we 
have launched several 

07:56:45.187 --> 07:56:49.884
enhancements to YouTube comments
 and our moderation tools such 

07:56:49.885 --> 07:56:56.743
as making it easier for creators
 to deal with inappropriate 

07:56:56.744 --> 07:57:00.914
comments, blacklist words, and 
also limit commenters who are 

07:57:00.915 --> 07:57:02.988
making those inappropriate 
comments.

07:57:02.989 --> 07:57:07.113
This is a great example of 
gender-based inclusive design 

07:57:07.114 --> 07:57:11.242
thinking to further deepen our 
engagement with our female 

07:57:11.243 --> 07:57:17.420
creators.  It also shows that 
many times grassroots ideas like

07:57:17.421 --> 07:57:21.571
 hack-a-thons can bring about 
change in many product direction

07:57:21.572 --> 07:57:25.737
 and strategy.
So now I've gone through several

07:57:25.738 --> 07:57:29.854
 examples of different kinds of 
inclusive design.  Some from the

07:57:29.855 --> 07:57:33.984
 non-technology world, and many 
from the technology world and 

07:57:33.985 --> 07:57:38.369
many from Google and YouTube.  
And now I want to talk about how

07:57:38.370 --> 07:57:46.607
 do you do inclusive design at 
scale

07:57:48.685 --> 07:57:53.491
 and become more proactive 
rather than  reactive.  These

07:57:56.615 --> 07:58:00.755
 are the project at Google, not 
linear.  These are the stages we

07:58:02.811 --> 07:58:04.886
 go through during product 
design and development.  In 

07:58:04.887 --> 07:58:09.098
Google we are starting to become
 more intentional about setting 

07:58:09.099 --> 07:58:13.211
demographic goals at every stage
 of product development.  So 

07:58:13.212 --> 07:58:17.336
when we are defining target 
users, instead of just saying 

07:58:17.337 --> 07:58:21.457
18-34 age group, we are also 
picking a demographic goal that 

07:58:21.458 --> 07:58:28.062
we would like to meet.  So we're
 saying, 18-34 age group with 

07:58:28.063 --> 07:58:34.264
equal engagement from male and 
female.  Or, 18-34 age group 

07:58:34.265 --> 07:58:36.329
with this level of ethnic reach 
that

07:58:39.366 --> 07:58:41.436
 we want to get on the platform.
Once we've set that demographic 

07:58:41.437 --> 07:58:45.587
goal, we propagate is through 
the rest of the stages of 

07:58:45.588 --> 07:58:49.723
product development.  So when 
we're doing testing, for 

07:58:49.724 --> 07:58:53.902
instance, we are very careful in
 picking our test user groups to

07:58:53.903 --> 07:58:58.048
 ensure that they are reflecting
 and mirroring the demographic 

07:58:58.049 --> 07:59:00.127
goals that we want to meet.  
Whether it is with user research

07:59:00.128 --> 07:59:06.322
 and user testing or training 
data for machine learning or 

07:59:06.323 --> 07:59:12.537
market research or more.  Over 
the last two days you've heard 

07:59:12.538 --> 07:59:16.670
that Google is a lot about 
algorithms and machine learning.

07:59:16.671 --> 07:59:20.794
  And you could ask, like, 
machines -- why are they biased?

07:59:20.795 --> 07:59:22.870
  They should all be like 
neutral.  And that's not the 

07:59:22.871 --> 07:59:27.006
case.  There are lots of 
different kinds of biases that 

07:59:27.007 --> 07:59:31.150
can come into your machine 
learning systems too.  And I 

07:59:31.151 --> 07:59:33.270
want to roll a video, now, to 
show you what those different 

07:59:33.271 --> 07:59:37.397
biases are and how we are 
tackling it at Google.  Let's 

07:59:37.398 --> 07:59:39.472
roll the video.

08:02:16.152 --> 08:02:18.152
[ Applause ]

08:02:22.668 --> 08:02:25.543
SOWMYA: Once you have designed 
the product and you're ready to 

08:02:25.544 --> 08:02:29.675
launch, it's really important 
that your marketing, branding, 

08:02:29.676 --> 08:02:34.701
and support systems all are 
making sure to echo the 

08:02:34.702 --> 08:02:37.534
demographic goals that you set 
out with.  Now, for inclusive 

08:02:37.535 --> 08:02:41.654
design to be a success, in 
addition to everything that we 

08:02:41.655 --> 08:02:43.731
talked about just now, it's 
really important to still have 

08:02:43.732 --> 08:02:47.870
diverse perspectives and diverse
 teams.  And to increase the 

08:02:47.871 --> 08:02:54.016
representation of diversity in 
technology.  So to this end, 

08:02:54.017 --> 08:02:58.111
Google is investing, through our
 computer science education and 

08:02:58.112 --> 08:03:00.186
media efforts, to increase the 
access of technology education 

08:03:00.187 --> 08:03:06.360
around the world to a diverse 
group.  And to help increase 

08:03:06.361 --> 08:03:10.494
awareness of unconscious biases.
  And also partnering with 

08:03:10.495 --> 08:03:16.650
Hollywood and other media 
producers to change how 

08:03:16.651 --> 08:03:20.780
scientists and engineers and 
computer scientists are 

08:03:20.781 --> 08:03:24.914
portrayed on the big screen.  
Because that can be a huge 

08:03:24.915 --> 08:03:29.032
influencer.  So another video, 
the last one in this 

08:03:29.033 --> 08:03:33.153
presentation, showing what we 
are doing with the media work.

08:03:33.154 --> 08:03:35.220
Let's roll the video.

08:04:17.382 --> 08:04:19.431
&gt;&gt; Is really a tool.

08:04:23.480 --> 08:04:29.684
&gt;&gt; Growing up, I was --

08:05:56.235 --> 08:05:58.235
[ Applause ]

08:06:04.333 --> 08:06:06.397
SOWMYA: So now it comes to you. 
 I hope I've shown you today the

08:06:06.398 --> 08:06:10.511
 value of inclusive design and 
how you can drive growth using 

08:06:10.512 --> 08:06:16.732
inclusive design.  I hope also 
that I've shown you the ways in 

08:06:16.733 --> 08:06:18.790
which Google is doing inclusive 
design.  And what are some of 

08:06:18.791 --> 08:06:22.907
the steps that we are taking by 
becoming more intentional?  Now,

08:06:22.908 --> 08:06:27.046
 you -- when you go back -- 
leave this room, go back to your

08:06:27.047 --> 08:06:31.230
 offices -- can follow the same 
similar approach that Google is 

08:06:31.231 --> 08:06:34.059
doing.  I would also like to 
leave you with a cheat sheet.

08:06:34.060 --> 08:06:38.150
Right?  The first thing is in 
your current products, it'll be 

08:06:38.151 --> 08:06:42.285
great if you can identify 
demographic gaps that you have. 

08:06:42.286 --> 08:06:46.401
 And the magnitude of these 
gaps, and if you were to bridge 

08:06:46.402 --> 08:06:50.526
them, what kind of impact they 
could be driving.  Once you have

08:06:50.527 --> 08:06:56.714
 that, prioritize which gap -- 
the one gap that you want to 

08:06:56.715 --> 08:07:00.858
fill because we are all resource
 constrained and can't solve 

08:07:00.859 --> 08:07:04.971
anything.  Pick one or two gaps 
and drives the biggest impact 

08:07:04.972 --> 08:07:09.072
for you.  As you bridge those 
gaps, make sure you have metrics

08:07:09.073 --> 08:07:11.137
 and logging and data to measure
 progress.  And

08:07:15.476 --> 08:07:18.676
 when you drive big impact, 
celebrate your wins.

08:07:15.476 --> 08:07:17.476
Also

08:07:19.608 --> 08:07:21.666
, it's really important to 
foster an inclusive culture in 

08:07:21.667 --> 08:07:25.817
your organizations.  You can do 
hack-a-thons around inclusive 

08:07:25.818 --> 08:07:27.890
design teams to drive more 
energy and momentum across your 

08:07:27.891 --> 08:07:32.043
entire team.  You can also do 
unconscious bias trainings to 

08:07:32.044 --> 08:07:36.145
make more people aware in your 
whole organization.  So with 

08:07:36.146 --> 08:07:40.351
that, now, I want you to take a 
moment and think about the one 

08:07:40.352 --> 08:07:44.478
thing you're going to do 
differently when you leave this 

08:07:44.479 --> 08:07:46.528
room.  And if you want to be 
bold, you can Tweet

08:07:50.616 --> 08:07:54.759
 it @googledevs and mark it with
 the #

08:07:58.813 --> 08:08:02.940
GDDeurope and women tech makers.
  Anyone to want shout out an 

08:08:02.941 --> 08:08:07.111
idea they might be doing 
differently?  It's okay.  

08:08:07.112 --> 08:08:09.112
Anyone?
[ Applause ]

08:08:09.186 --> 08:08:15.415
All right.  Okay.  So with that 
-- okay.  So with that I'm going

08:08:15.416 --> 08:08:21.587
 to invite Dirk back to wrap up.
  And I hope you enjoyed the 

08:08:21.588 --> 08:08:23.637
session.
[ Applause ]

08:08:31.737 --> 08:08:35.861
&gt;&gt; Thank you.  And I believe -- 
I need to do this.  There have 

08:08:35.862 --> 08:08:42.065
been a few people having quite 
an adrenaline rush back there.  

08:08:42.066 --> 08:08:44.123
And Sowmya certainly had the 
same, I think.  Even Europeans 

08:08:44.124 --> 08:08:50.297
can give them an extra cheer, 
right?  Come on.

08:08:50.298 --> 08:08:56.489
[ Applause ]
You know, that's like a 

08:08:56.490 --> 08:09:00.601
nightmare.  So I was really 
feeling with her.  The last step

08:09:00.602 --> 08:09:06.815
 on our two day's journey for me
 is now to say a very warm thank

08:09:06.816 --> 08:09:10.958
 you.  It has been incredible 
two days and we have a few 

08:09:10.959 --> 08:09:15.051
parting wishes.  You heard 
Sowmya's wish, I have an 

08:09:15.052 --> 08:09:19.166
additional.  Please, don't be a 
stranger.  There are several 

08:09:19.167 --> 08:09:21.221
ways to stay in touch with each 
other and with us.  Continue the

08:09:21.222 --> 08:09:25.351
 conversation that you take with
 you out of this conference.  

08:09:25.352 --> 08:09:32.443
The women tech makers, the GDGs.
  It's kind of hard if you have 

08:09:32.444 --> 08:09:36.602
walked the halls not to have 
bumped into them.  Maybe you are

08:09:36.603 --> 08:09:38.687
 a member already, maybe you are
 interested.  Stay in touch.

08:09:40.752 --> 08:09:42.828
On your way out, there are -- on
 the entrance, I have been told 

08:09:42.829 --> 08:09:49.048
-- a couple thing use might 
consider grabbing.  Apparently 

08:09:49.049 --> 08:09:51.113
there's some swag left.  If you 
keep your eyes open, might be 

08:09:51.114 --> 08:09:55.231
interesting what you see.  And 
with that, please travel safely.

08:09:55.232 --> 08:09:59.339
  Thank you for being with us 
today.  And -- yeah.  Maybe next

