WEBVTT
Kind: captions
Language: en

00:00:00.140 --> 00:00:03.220
&gt;&gt;Romain Guy: Good afternoon everyone. And
welcome to the world of ListView.

00:00:03.220 --> 00:00:06.160
My name is Romain Guy, and I'm an android
engineer at Google.

00:00:06.160 --> 00:00:10.770
I work on the UI toolkit and a few other things
and joining me today is Adam Powell, he's

00:00:10.770 --> 00:00:15.490
also an engineer at Google. He works also
on the UI toolkit if you've ever been mad

00:00:15.490 --> 00:00:20.529
at ListView, it's probably my fault and now
his fault So, if you have things to tell us

00:00:20.529 --> 00:00:28.179
at the end of the session, come talk to us
and you can do whatever you want to us.

00:00:28.179 --> 00:00:31.960
We have a Google Wave where you can share
notes during the presentation. You can also

00:00:31.960 --> 00:00:36.210
ask questions. You can vote on the questions
asked eight-by other people. You can also

00:00:36.210 --> 00:00:42.859
download the questions that you think are
stupid. And here is the URL. Once you will

00:00:42.859 --> 00:00:47.230
be able to see it, so try to write it down.
If you don't have the time to write it down

00:00:47.230 --> 00:00:51.120
right now, we will put the slide up at the
end of the session, and you can also go to

00:00:51.120 --> 00:00:58.499
the Google I/O Web site and link to that Wave.
And we will also take live questions, of course.

00:00:58.499 --> 00:01:02.699
So how many of you have ever used ListView
as a developer in an Android application?

00:01:02.699 --> 00:01:09.960
Raise your hand. That's scary and good.
How many of you have found ListView to be

00:01:09.960 --> 00:01:13.750
difficult to use?
You are the ones who are lying.

00:01:13.750 --> 00:01:20.270
And how many of you have swore at least during
the past few days. Yeah, I see some hands.

00:01:20.270 --> 00:01:23.180
That's good, that's good. That means you are
doing some complex stuff with it.

00:01:23.180 --> 00:01:27.100
For those of you who have never used ListView,
it's a pretty common widget on Android. It's

00:01:27.100 --> 00:01:31.700
used I think in almost every application we
ship. And you can see an example here on the

00:01:31.700 --> 00:01:37.840
slide on the left side, that's one of our
API demos. So it just stacks widgets vertically.

00:01:37.840 --> 00:01:42.330
Most of the time ListView shows simple text,
sometimes we have icon and text, but you can

00:01:42.330 --> 00:01:46.570
do very, very complex ListViews.
Before we shipped Android 1.0 we had a version

00:01:46.570 --> 00:01:51.950
of Gmail where when you opened an email we
were using a ListView made of Web views to

00:01:51.950 --> 00:01:56.180
display conversation.
We stopped doing that because it works, but

00:01:56.180 --> 00:01:59.149
it's not that great to use.
But if you really want to do something really

00:01:59.149 --> 00:02:03.320
crazy, you can.
And of course you can also do some very complex

00:02:03.320 --> 00:02:07.549
things with ListView. So on the right side
you see an example of an app I wrote that

00:02:07.549 --> 00:02:12.820
customizes the ListView. It's a grid view,
which is very similar, and you can customize

00:02:12.820 --> 00:02:17.860
the background, you can customize the selection,
you can have very complex items inside each

00:02:17.860 --> 00:02:21.931
row.
And just for the side note, everything we

00:02:21.931 --> 00:02:26.080
are going to talk about today applies to ListView
but also applies to grid view there are a

00:02:26.080 --> 00:02:30.780
couple of things that are specific to ListView
but pretty much be everything applies to grid

00:02:30.780 --> 00:02:33.560
view as well.
So if you ever need a grid view, you can refer

00:02:33.560 --> 00:02:37.379
to this talk, you can refer to the slides
and everything will be the same.

00:02:37.379 --> 00:02:41.750
Here is our agenda for this session. We are
going to talk about adapters and virtualization.

00:02:41.750 --> 00:02:52.920
We are going to talk about item properties,
headers and footers, selectors, and then we

00:02:52.920 --> 00:02:56.830
are going to finish the talk with a few other
features and what you should never ever ever

00:02:56.830 --> 00:03:02.390
do with a ListView. And I will ask during
the last slides who amongst the audience is

00:03:02.390 --> 00:03:04.459
doing the things you should never do, and
I will be really mad at you.

00:03:04.459 --> 00:03:11.739
Adam is going to start with adapters.
&gt;&gt;Adam Powell: Okay.

00:03:11.739 --> 00:03:16.080
So the problem present here is dealing with
large data sets. Specifically presenting those

00:03:16.080 --> 00:03:19.900
large data sets.
If you have 10,000 items available to you,

00:03:19.900 --> 00:03:24.060
how do you get that on screen so that the
user can peruse them, so that you can get

00:03:24.060 --> 00:03:28.780
through them relatively quickly?
The two big challenges for dealing with that

00:03:28.780 --> 00:03:33.080
is memory and performance. You don't want
to attach 10,000 views into your view hierarchy.

00:03:33.080 --> 00:03:37.440
Views are fairly heavyweight objects in that
sense. And you want to be able to fling through

00:03:37.440 --> 00:03:42.640
them quickly. People expect to be able to
navigate things quickly on touch screen devices

00:03:42.640 --> 00:03:46.920
especially.
So the solution we have implemented in ListView

00:03:46.920 --> 00:03:53.280
is that we populate views on demand. So we
only bring up new views as they are actually

00:03:53.280 --> 00:03:57.310
needed. Nothing actually gets added to the
view hierarchy that isn't going to be displayed

00:03:57.310 --> 00:04:00.930
on screen.
Secondly, we recycle those views.

00:04:00.930 --> 00:04:04.930
So we reuse the views that we have already
created and just fill in new content as they

00:04:04.930 --> 00:04:07.599
come through.
This helps us address a lot of the performance

00:04:07.599 --> 00:04:11.019
issues that come up when you are cycling through
things very quickly, when you are flinging

00:04:11.019 --> 00:04:15.870
through a very long list.
So a little bit of terminology to start off

00:04:15.870 --> 00:04:19.451
with. Just because there's a lot of different
ways to refer to data when you are working

00:04:19.451 --> 00:04:22.950
with a ListView.
When we talk about an index, we are talking

00:04:22.950 --> 00:04:27.320
about child views within the view group in
the hierarchy.

00:04:27.320 --> 00:04:31.470
So if you are calling get child at to go ahead
and fetch a view that's there, that's when

00:04:31.470 --> 00:04:36.220
we are talking about indices.
When we are talking about position, we are

00:04:36.220 --> 00:04:40.390
talking about a position of an element within
your adapter.

00:04:40.390 --> 00:04:46.110
And finally, when we talk about IDs, each
item within an adapter can have a unique identifier

00:04:46.110 --> 00:04:51.780
that refers to the value of the data stored
there. So if things start shuffling around,

00:04:51.780 --> 00:04:57.730
you perform insertions or deletions on the
data that's backing your adapter, then this

00:04:57.730 --> 00:05:01.660
lets us do a few extra tricks when you have
StableIDs.

00:05:01.660 --> 00:05:06.200
When you tell the ListView that you have StableIDs
by returning true from your adapter's has

00:05:06.200 --> 00:05:11.600
StableIDs function, then we are able to perform
a few extra tricks that just makes the presentation

00:05:11.600 --> 00:05:16.050
a little bit nicer when a lot of elements
get added or removed. We can try and keep

00:05:16.050 --> 00:05:20.690
the data relatively stable on screen.
&gt;&gt;Romain Guy: And understanding what the index

00:05:20.690 --> 00:05:26.170
position and ID do is very important because
I have got to admit, the documentation of

00:05:26.170 --> 00:05:29.690
ListView is somewhat lacking, to remain polite,
and it's entirely our fault. We are very sorry.

00:05:29.690 --> 00:05:35.180
But we have been very careful with respect
to the naming of our parameters.

00:05:35.180 --> 00:05:40.180
So whenever you see a method that talks about
position or you see a parameter of a method

00:05:40.180 --> 00:05:45.950
that's called index, you know it's currently
that it's going to be those meanings. Everything

00:05:45.950 --> 00:05:52.240
is pretty good in that regard.
&gt;&gt;Adam Powell: Definitely.

00:05:52.240 --> 00:05:57.060
So the meat of your adapter is going to be
the get view method. This is what takes your

00:05:57.060 --> 00:06:01.880
data from your data source, whatever that
may be, whether it be something you are fetching

00:06:01.880 --> 00:06:06.840
from a network, something from a database
that's local. It doesn't matter what it is.

00:06:06.840 --> 00:06:11.560
Get view gives you full presentation control
over your data. You can return any arbitrary

00:06:11.560 --> 00:06:15.290
view, and then that becomes your element within
the ListView.

00:06:15.290 --> 00:06:22.670
So within get view, we offer a lot of opportunities
to optimize this entire process. And kind

00:06:22.670 --> 00:06:26.500
of to go along with that, because we make
assumptions in order to make these optimizations,

00:06:26.500 --> 00:06:29.430
there's a lot of opportunity to shoot yourself
in the foot.

00:06:29.430 --> 00:06:34.130
And I'm sure that some of you have come across
one or more of these before. You know, why

00:06:34.130 --> 00:06:39.690
can't I click on this element that's a child
far down in this particular list item?

00:06:39.690 --> 00:06:44.660
We'll get into some of that. We will get into
why. And specifically, we'll get into the

00:06:44.660 --> 00:06:56.760
fairly narrow subset of things that you sudden
be doing within get view.

00:06:56.760 --> 00:07:03.990
So ListView tries to be smart. As you can
see, it's fairly easy to outsmart here and

00:07:03.990 --> 00:07:09.420
there, but through get view, we pass in an
extra view parameter called convert view.

00:07:09.420 --> 00:07:14.470
We talked about how ListView ends up reusing
some of these views as you are flinging through

00:07:14.470 --> 00:07:17.190
data quickly. Convert view is how it makes
that happen.

00:07:17.190 --> 00:07:21.740
ListView will keep track of all the extra
views that are moving off screen and then

00:07:21.740 --> 00:07:26.620
give you one back to fill out with your existing
data. This is the convert view parameter that

00:07:26.620 --> 00:07:31.850
we saw on this slide here.
So this will automatically match up item types

00:07:31.850 --> 00:07:36.030
for you as well. If you have multiple types
of different data within your adapter, then

00:07:36.030 --> 00:07:40.690
convert view will always be the correct type
as long as you tell ListView what type each

00:07:40.690 --> 00:07:44.040
position in your adapter is. And we will get
to that in a little bit as well.

00:07:44.040 --> 00:07:50.590
So if a convert view parameter, pass to your
get view is not null, please reuse it. It's

00:07:50.590 --> 00:07:52.761
going to help the performance of your application
quite a bit.

00:07:52.761 --> 00:07:58.660
&gt;&gt;Romain Guy: So there are different ways
to implement the get view method. We are going

00:07:58.660 --> 00:08:02.880
to see three of those different methods. There
is the slow way, the correct way and the fast

00:08:02.880 --> 00:08:05.440
way.
So first of all, look at this slide really

00:08:05.440 --> 00:08:08.930
quickly and please raise your hand, and that's
okay, don't be ashamed, if you have ever written

00:08:08.930 --> 00:08:14.390
a get view method like this. Some of you have
done it. Okay, at least there is someone honest

00:08:14.390 --> 00:08:17.060
in the room.
&gt;&gt;Adam Powell: There are a few over here,

00:08:17.060 --> 00:08:19.380
too.
&gt;&gt;Romain Guy: This is the native way you would

00:08:19.380 --> 00:08:24.460
implement get view. You would create a new
view every time get view is invoked.

00:08:24.460 --> 00:08:29.360
So you can see here at line number 2, we are
inflating a view from XML. This is a very

00:08:29.360 --> 00:08:33.060
expensive preparation. We have to parse the
XML, and even though this is highly optimized

00:08:33.060 --> 00:08:36.320
on Android, it still takes quite a bit of
time. We have to initialize the view, we have

00:08:36.320 --> 00:08:42.220
to allocate the memory, and it can be very
costly when the view is made of subviews.

00:08:42.220 --> 00:08:47.530
So here, for instance, the view inflating
in that example is contains an image view

00:08:47.530 --> 00:08:51.270
and a text view.
Once we have created it in line three and

00:08:51.270 --> 00:08:56.880
four we just bind some data to those two views.
So we put some text in the text view, an image

00:08:56.880 --> 00:09:00.310
on the image view, and then we return the
view we have created.

00:09:00.310 --> 00:09:05.320
The big problem with that is if the user is
flinging the list and is trying to scroll

00:09:05.320 --> 00:09:10.050
through thousands of items, then we are going
to create thousands of those views which is

00:09:10.050 --> 00:09:15.240
going to take a lot of memory.
To give you an idea, a view on Android costs

00:09:15.240 --> 00:09:20.840
about one or two kilobytes of RAM. So if you
have a thousand views, that's already a meg

00:09:20.840 --> 00:09:26.720
of RAM that you are wasting, which means that
the garbage collector is going to kick in

00:09:26.720 --> 00:09:30.840
and it's going to stop your UI thread. It's
going to make the animation stutter and the

00:09:30.840 --> 00:09:35.660
user will be really pissed at your application.
And don't believe that lists of thousands

00:09:35.660 --> 00:09:40.701
of items are rare, because, for instance,
I know many people who have thousands of contacts

00:09:40.701 --> 00:09:45.180
in their application -- in their address book,
and it's very easy to do when your e-mail

00:09:45.180 --> 00:09:49.740
application is set up to create contacts automatically
whenever you reply to an e-mail.

00:09:49.740 --> 00:09:56.270
So to fix this, the convention, you just have
to use the convert view. So simply check whether

00:09:56.270 --> 00:10:00.101
or not the convert view is null. If it's null,
then you have to create a new view. You can

00:10:00.101 --> 00:10:03.621
inflate from XML. You can create the view
programmatically. You do whatever you want,

00:10:03.621 --> 00:10:08.590
but you have to create a new view.
In the other case, if the convert view is

00:10:08.590 --> 00:10:12.680
already available, just reuse it.
Like we said, we guarantee that the convert

00:10:12.680 --> 00:10:16.220
view is the type of view that you want, so
you know you are going to have your text view,

00:10:16.220 --> 00:10:20.760
you know you are going to have your image
view and this is going to be much faster.

00:10:20.760 --> 00:10:24.490
Basically, with this method, you are going
to allocate only the number of views you need

00:10:24.490 --> 00:10:28.780
to fill the screen. Sometimes it's going to
allocate like one or two more, but most of

00:10:28.780 --> 00:10:32.520
the time it's going to be only like seven
or eight views on a Nexus One, for instance.

00:10:32.520 --> 00:10:39.010
So it's very little.
There's another technique to make that implement

00:10:39.010 --> 00:10:43.140
go faster. It's a pattern that we call the
view holder that we developed on the Android

00:10:43.140 --> 00:10:47.930
team just before 1.0 because we were running
into performance issues, especially with address

00:10:47.930 --> 00:10:52.820
books full of thousands of contacts.
So the idea is that you are going to create

00:10:52.820 --> 00:10:59.500
a small data structure in your application
that is going to hold data that's static for

00:10:59.500 --> 00:11:05.450
each given row of the list.
So in that example, for each item in the list,

00:11:05.450 --> 00:11:11.000
we are doing a find you by ID to find a text
view and an image view in lines five and six.

00:11:11.000 --> 00:11:15.170
So why should we bother doing it thousands
and thousands of times as we scroll through

00:11:15.170 --> 00:11:20.750
a big list. So instead we are just going to
hold the things once and forever in this little

00:11:20.750 --> 00:11:24.370
class called the view holder. So you can create
it wherever you want. Try to make that class

00:11:24.370 --> 00:11:31.010
static so you don't link the enclosing instance.
And this is what the code looks like when

00:11:31.010 --> 00:11:33.920
you use the view holder.
So the only difference is when you create

00:11:33.920 --> 00:11:37.790
a new view when the convert view is null,
you create your instance of the view holder,

00:11:37.790 --> 00:11:42.380
you do the work of finding the children of
the view. So here we find the text view and

00:11:42.380 --> 00:11:48.700
the image view, so that's line 5 to 9. And
then you can set the holder as the tag for

00:11:48.700 --> 00:11:51.260
the view.
So the tag is just a random object. It can

00:11:51.260 --> 00:11:54.660
be anything you want that you can put on a
view.

00:11:54.660 --> 00:11:59.260
And we use the tag facility here to store
extra data.

00:11:59.260 --> 00:12:03.960
When you have a convert view that's passed
to you by this view, you simply get the tag.

00:12:03.960 --> 00:12:08.990
You get it as a view holder, and then if you
like, at line 16 and 17 you can see we access

00:12:08.990 --> 00:12:14.040
the text view and image view directly. So
we save the cost of doing the find view.

00:12:14.040 --> 00:12:18.620
This is a very simple example, but in some
applications you can store even more data

00:12:18.620 --> 00:12:24.550
in there. You can store char arrays to do
database queries to allocating new arrays

00:12:24.550 --> 00:12:30.660
of characters every time do you a query.
And this is a comparison of the preference

00:12:30.660 --> 00:12:37.070
of the three methods. So would we took those
numbers using the Froyo build of Android that

00:12:37.070 --> 00:12:42.590
you guys don't have yet. This is running with
a fast CPU because we are on a Nexus One,

00:12:42.590 --> 00:12:48.180
and we created a list of 10,000 items. Each
item is a linear layer that contains an image

00:12:48.180 --> 00:12:54.250
and a text view. With the dumb implementation
of get view we get about 20 frames per second.

00:12:54.250 --> 00:13:00.210
When we implement get view correctly by reusing
the convert view, we go up to 50 frames per

00:13:00.210 --> 00:13:03.911
second. And finally when we use the view holder
we go up to 55 frames per second.

00:13:03.911 --> 00:13:07.850
To give you an idea on the Nexus One, the
maximum number of frames per second you can

00:13:07.850 --> 00:13:13.500
get is 60. So when you take into account the
overhead of just redrawing the view hierarchy,

00:13:13.500 --> 00:13:18.370
issuing all the commands, binding the views,
reading the bitmap, stuff like that. This

00:13:18.370 --> 00:13:22.250
is pretty much as fast as you can go inside
an adapter.

00:13:22.250 --> 00:13:26.650
So if you can reach those numbers inside your
application, you are good to go.

00:13:26.650 --> 00:13:33.370
If you are on the left side, then keep working.
&gt;&gt;Adam Powell: Okay.

00:13:33.370 --> 00:13:36.150
So as I mentioned before, there are a lot
of ways to shoot yourself in the foot during

00:13:36.150 --> 00:13:41.800
this process. Most of it has to do with trying
to outsmart the way that get view tries to

00:13:41.800 --> 00:13:46.460
optimize things for you.
So don't create any sort of local view cache.

00:13:46.460 --> 00:13:50.810
Don't try and be smart and say, okay, well,
I know that position one is always going to

00:13:50.810 --> 00:13:54.250
be this element, so I am just going to save
this view away in my adapter and always return

00:13:54.250 --> 00:14:00.470
this whenever I am asked for position one.
The problem with that is that due to the implementation

00:14:00.470 --> 00:14:06.451
of the recycler inside ListView, if you are
not passing back either a new view that was

00:14:06.451 --> 00:14:12.160
just created or exactly the convert view instance
that was passed to you, it's going to assume

00:14:12.160 --> 00:14:16.900
that anything else that was ever attached
to the ListView is dead. And it's just going

00:14:16.900 --> 00:14:20.730
to go ahead and throw it away.
Sometimes this can end up getting reattached

00:14:20.730 --> 00:14:26.040
in really strange ways, and it won't always
look like there's a problem at first until

00:14:26.040 --> 00:14:32.830
you start observing some very strange behavior.
So don't cache views locally like that, and

00:14:32.830 --> 00:14:36.740
don't access the views from the adapter that
way.

00:14:36.740 --> 00:14:40.550
Don't change convert view's structure, either.
Just because you have a view coming in, that

00:14:40.550 --> 00:14:43.860
doesn't necessarily mean that you need to
be adding and removing extra content from

00:14:43.860 --> 00:14:46.930
that view.
That's what the type system is for.

00:14:46.930 --> 00:14:52.351
We can actually have convert view pass you
back exactly the type of view that you need

00:14:52.351 --> 00:14:55.860
that already has all these other subviews
initialized for you. So just because you have

00:14:55.860 --> 00:14:59.540
different types of data within your adapter
doesn't necessarily mean that you need to

00:14:59.540 --> 00:15:05.110
try to perform all sorts of manipulations
on convert view when it comes in.

00:15:05.110 --> 00:15:09.970
And lastly, don't make assumptions about get
view calls. We have seen developers try to

00:15:09.970 --> 00:15:16.690
do things like, okay, get view was just called
for position 5, so I am going to store something

00:15:16.690 --> 00:15:21.990
about this particular view instance is position
5, and I am going to cache that someplace.

00:15:21.990 --> 00:15:26.420
I am going to -- just so that I can refer
back to that view quickly, whenever data behind

00:15:26.420 --> 00:15:30.630
it updates.
The problem with this is that the order of

00:15:30.630 --> 00:15:35.839
get view calls isn't guaranteed. So we may
end up calling get view behind the scenes

00:15:35.839 --> 00:15:40.420
to go ahead and measure out how big the ListView
can be, and we might do this with a throw-away

00:15:40.420 --> 00:15:44.120
convert view that we are passing to you. Again,
for performance reasons.

00:15:44.120 --> 00:15:50.100
So the view that you get -- the last view
that you get passed to you for a position

00:15:50.100 --> 00:15:52.750
may not actually be the one that ends up on
screen later on.

00:15:52.750 --> 00:15:57.860
&gt;&gt;Romain Guy: And, actually, a great example
of making assumptions about the ordering of

00:15:57.860 --> 00:16:02.960
the getView calls is something that happened
to us inside the Android team really recently.

00:16:02.960 --> 00:16:05.350
The GMail application was making one of these
assumptions.

00:16:05.350 --> 00:16:10.150
And so in Froyo, they changed something about
the UI that made them go through a different

00:16:10.150 --> 00:16:13.370
code path in ListView.
And suddenly the order of the getView calls

00:16:13.370 --> 00:16:16.880
changed.
And every single one of your e-mails in your

00:16:16.880 --> 00:16:19.160
inbox looked like the first e-mail of the
inbox.

00:16:19.160 --> 00:16:23.279
And that wasn't a bug ListView; that was a
problem in the application, because they were

00:16:23.279 --> 00:16:27.870
assuming that they would get you zero, get
you one, get you two, get you three, which

00:16:27.870 --> 00:16:32.589
wasn't the case anymore.
To give you any idea, I think we have at least

00:16:32.589 --> 00:16:36.460
four or five different ways to perform layout
in ListView, so sometimes we're going to start

00:16:36.460 --> 00:16:40.300
by doing the layout from the bottom of the
screen; sometimes we start from the top; sometimes

00:16:40.300 --> 00:16:43.930
we start from the middle.
So, again, don't make any assumption about

00:16:43.930 --> 00:16:49.450
the order of the calls.
&gt;&gt;Adam Powell: Okay.

00:16:49.450 --> 00:16:53.860
So what happens when your data changes?
Whenever your data changes, you need to update

00:16:53.860 --> 00:16:57.870
your adapter in some way.
And not only that, but you need to tell ListView

00:16:57.870 --> 00:17:02.850
that the adapter was updated.
You do this by calling notify data set changed.

00:17:02.850 --> 00:17:08.250
This basically triggers ListView to rescan
your adapter for the views that are onscreen,

00:17:08.250 --> 00:17:14.750
repopulate them, deal with any sort of manipulations
in terms of scrolling the lists if there's

00:17:14.750 --> 00:17:19.610
fewer data elements in there now or growing
it out if there's more.

00:17:19.610 --> 00:17:25.250
If your data set becomes unavailable, for
example, if, like, your backing file gets

00:17:25.250 --> 00:17:30.890
deleted, if your network access goes out,
notify data set invalidated will tell us that

00:17:30.890 --> 00:17:35.660
there is no more data, it's entirely gone
and we're not going to try and access it anymore.

00:17:35.660 --> 00:17:37.850
&gt;&gt;Romain Guy: And we'll talk about it more
later.

00:17:37.850 --> 00:17:40.830
But it's very, very important to call notify
data set change.

00:17:40.830 --> 00:17:45.080
Most of the bugs I see filed against ListView
usually come from the application not calling

00:17:45.080 --> 00:17:49.690
notify data set change correctly.
It has to be called on the UI thread and has

00:17:49.690 --> 00:17:54.030
to be called every time you modify your adapter,
especially when you change the number of items

00:17:54.030 --> 00:17:58.720
inside the adapter.
And, actually, I don't remember for what release,

00:17:58.720 --> 00:18:04.390
it was maybe Donut or Eclair, so 1.6 or 2.0,
we added a new exception in ListView, so it

00:18:04.390 --> 00:18:08.390
tries to detect the case when you change the
adapter without telling the ListView.

00:18:08.390 --> 00:18:12.260
When that happens, now we crash.
We throw an exception, and we have a very,

00:18:12.260 --> 00:18:17.390
very long and detailed message in the log
cat telling you that you're doing something

00:18:17.390 --> 00:18:21.230
wrong probably with the thread.
So if you see that message, pay attention

00:18:21.230 --> 00:18:23.050
to it.
It's very important that you fix this issue.

00:18:23.050 --> 00:18:30.290
&gt;&gt;Adam Powell: We mentioned before that ListView
will handle different view types for you.

00:18:30.290 --> 00:18:34.260
A lot of times, you have more than one type
of data that you want to display at once.

00:18:34.260 --> 00:18:37.390
Certain list elements you may want to include
images in.

00:18:37.390 --> 00:18:42.140
Certain ones may have extended quoted text.
All of these things end up being different

00:18:42.140 --> 00:18:45.640
types of data that you want to display within
the same list.

00:18:45.640 --> 00:18:51.280
And ListView will help you out with this.
The function get item view type on your adapter

00:18:51.280 --> 00:18:57.020
tells ListView what type the view at that
position should be.

00:18:57.020 --> 00:19:01.460
So generally, this is -- this is just an integer
parameter that you pass back.

00:19:01.460 --> 00:19:06.679
So however many types you have, return that
from getView type count.

00:19:06.679 --> 00:19:12.410
And ListView will maintain basically a recycler
for each of these different view types that

00:19:12.410 --> 00:19:14.580
you have.
And it will always be ready to hand you back

00:19:14.580 --> 00:19:18.750
the correct one when getView gets called.
&gt;&gt;Romain Guy: Something else very important

00:19:18.750 --> 00:19:22.440
about the item types, that the number of types
you have, so when you implement the getView

00:19:22.440 --> 00:19:28.290
type count method, that number has to be constant
throughout the life cycle of your adapter.

00:19:28.290 --> 00:19:32.300
You cannot make that number change.
It's okay if you say that you have ten types

00:19:32.300 --> 00:19:36.270
and you actually end up using only two.
It's not going to be -- it's not going to

00:19:36.270 --> 00:19:39.200
waste any resources.
But if you change that number, then very,

00:19:39.200 --> 00:19:42.930
very bad things will happen in ListView, and
you will see really weird behavior that might

00:19:42.930 --> 00:19:49.120
be very (inaudible) from time to time.
So try to figure out what is the maximum number

00:19:49.120 --> 00:19:53.720
of types you're going to need and return that
number from the getView type count method.

00:19:53.720 --> 00:20:02.340
&gt;&gt;Adam Powell: So what happens when you have
a data source that's really slow?

00:20:02.340 --> 00:20:08.220
You're bringing something in over a network,
you're reading a large file, one way or another,

00:20:08.220 --> 00:20:12.970
you're not going to be able to keep up with
it on your UI thread and still remain responsive.

00:20:12.970 --> 00:20:16.020
So fetching that data can actually happening
anywhere.

00:20:16.020 --> 00:20:19.630
You can spin off another thread, send a request
out to the network.

00:20:19.630 --> 00:20:23.270
It doesn't matter.
But the important thing to remember is that

00:20:23.270 --> 00:20:27.480
you always commit your adapter changes on
the UI thread.

00:20:27.480 --> 00:20:31.140
And, once again, make sure you call notify
data set changed.

00:20:31.140 --> 00:20:35.200
So any changes have to be reflected on that
UI thread.

00:20:35.200 --> 00:20:40.311
&gt;&gt;Romain Guy: And you also have to call notify
data set change in the same UI event where

00:20:40.311 --> 00:20:44.750
you commit the changes to the adapter.
You can't change the adapter and then sometime

00:20:44.750 --> 00:20:48.550
later send and notify data set change to the
ListView, because in between, there might

00:20:48.550 --> 00:20:51.670
be a request for a layout, and then ListView
will have conflicting data.

00:20:51.670 --> 00:20:57.661
Then we're going to talk about a couple of
item properties.

00:20:57.661 --> 00:21:02.610
So the first one is actually really simple.
It's the ability to disable list items.

00:21:02.610 --> 00:21:07.510
If you look at the adapter interface, so when
you create your own adapter, there's a method

00:21:07.510 --> 00:21:11.240
that lets you tell ListView whether or not
an item is enabled.

00:21:11.240 --> 00:21:15.920
By default, all items are enabled.
And having an enabled item lets you select

00:21:15.920 --> 00:21:20.580
it with a track ball, so you will get with
the default theme the orange highlight behind

00:21:20.580 --> 00:21:23.080
the item.
It lets you also click the item.

00:21:23.080 --> 00:21:27.740
And you can get a nonlist item click event.
In some cases, though, you want to disable

00:21:27.740 --> 00:21:30.410
these items.
Disabling items is not necessarily to show

00:21:30.410 --> 00:21:35.150
the user that this item is not available.
For instance, it may be a Web server that's

00:21:35.150 --> 00:21:39.000
not reachable.
It's also for -- simply to create different

00:21:39.000 --> 00:21:41.900
items -- items that have a different visual
appearance.

00:21:41.900 --> 00:21:44.850
So here's an example.
This is a market application.

00:21:44.850 --> 00:21:49.890
If you look at the green headers in the middle
of the ListView, those are disabled items.

00:21:49.890 --> 00:21:53.100
So they make them disabled because they serve
as headers.

00:21:53.100 --> 00:21:55.121
So they just indicate different sections of
the list.

00:21:55.121 --> 00:21:58.990
Obviously, it wouldn't make sense to be able
to select them with a track ball or to click

00:21:58.990 --> 00:22:02.679
on them.
So it's a very simple feature that's used

00:22:02.679 --> 00:22:08.080
heavily inside the Android platform, and you
can integrate user bits inside your own navigations.

00:22:08.080 --> 00:22:13.480
&gt;&gt;Adam Powell: So sometimes just getting a
click event on a specific list item isn't

00:22:13.480 --> 00:22:15.540
enough.
You want the user to be able to make choices

00:22:15.540 --> 00:22:19.320
within that list.
You may want that choice to be mutually exclusive.

00:22:19.320 --> 00:22:22.560
You can only select one item at a time.
You may want the user to be able to select

00:22:22.560 --> 00:22:28.549
multiple items out of a specific list.
So for that, we provide choice mode.

00:22:28.549 --> 00:22:32.221
You have single choice mode, which gives you
radio buttons, once again, for mutually exclusive

00:22:32.221 --> 00:22:36.470
choices, and you have multiple choice mode
which lets you check a number of items within

00:22:36.470 --> 00:22:39.700
the list.
So what happens when you want to get that

00:22:39.700 --> 00:22:43.860
checked state back out and read it in another
part of your application?

00:22:43.860 --> 00:22:50.340
You can call several methods on ListView.
Get checked item position will return the

00:22:50.340 --> 00:22:53.190
position of the item that you've selected
in single-choice mode.

00:22:53.190 --> 00:22:57.380
If you're in multiple-choice mode, you can
call get checked item positions, plural, and

00:22:57.380 --> 00:23:00.170
that will give you all of the positions that
are currently checked.

00:23:00.170 --> 00:23:06.299
But we mentioned before that there is this
concept of stableIDs within an adapter, where

00:23:06.299 --> 00:23:15.330
each value within the adapter has an integer
that specifies uniquely that value, no matter

00:23:15.330 --> 00:23:19.460
how the position may change due to other deletions
or insertions.

00:23:19.460 --> 00:23:24.780
So if you're going to have a lot of deletions
and insertions within your adapter over time

00:23:24.780 --> 00:23:29.880
and you're also making choices, then you can
use get checked item IDs to refer to those

00:23:29.880 --> 00:23:34.940
items by ID so that the positions don't get
out of alignment with your actual data.

00:23:34.940 --> 00:23:40.620
Come on.
There we go.

00:23:40.620 --> 00:23:44.140
Here's an example of each one of the choice
modes.

00:23:44.140 --> 00:23:47.130
You've probably seen these before in the ring
tone selector.

00:23:47.130 --> 00:23:52.110
And in the selector for which labels you want
to splay in GMail.

00:23:52.110 --> 00:23:56.600
So this is how it looks by default.
But as always, you're in control of the presentation

00:23:56.600 --> 00:23:59.101
through getView.
So you can make these look as fancy as you

00:23:59.101 --> 00:24:03.510
like.
&gt;&gt;Romain Guy: Now, something that's very (inaudible)

00:24:03.510 --> 00:24:08.450
is how we handle focusable items.
One of the big constraints we have on the

00:24:08.450 --> 00:24:12.059
UI is that we need to support track balls
and touch screens.

00:24:12.059 --> 00:24:17.040
We decided early on that as soon as we touched
the screen, the focus or the selection goes

00:24:17.040 --> 00:24:19.309
away.
That's why we have the choice mode.

00:24:19.309 --> 00:24:23.419
You can't just let the user tap an item in
the list and keep the selection on screen.

00:24:23.419 --> 00:24:27.020
ListView will fight really hard to make that
not happen.

00:24:27.020 --> 00:24:32.200
So something we've done is that, by default,
if you put a focusable item inside the -- if

00:24:32.200 --> 00:24:38.520
you have a row that contains a couple of buttons
but the entire row will be selected when you

00:24:38.520 --> 00:24:42.360
use the track ball.
The reason is that it will be very awkward

00:24:42.360 --> 00:24:46.670
to have track ball navigation that will go
from selecting the whole item to selecting

00:24:46.670 --> 00:24:51.410
little items inside the row itself.
So if you want more control over that, if

00:24:51.410 --> 00:24:57.210
you want to have selectable -- focusable items
inside the row, you can tell ListView that

00:24:57.210 --> 00:25:00.630
you want that to happen.
So if you call set items can focus, and you

00:25:00.630 --> 00:25:05.130
pass true, you're telling ListView, now, on
my rows, I don't want the entire row, I want

00:25:05.130 --> 00:25:11.740
to select stuff inside the row.
On the left side we have the content application.

00:25:11.740 --> 00:25:17.070
You can see there's a focusable item on the
left that's the quick contact action.

00:25:17.070 --> 00:25:21.440
But by default, they decided that they didn't
want the user to be able to select that with

00:25:21.440 --> 00:25:23.309
the track ball.
So when you use the track ball, you can only

00:25:23.309 --> 00:25:26.920
select the entire row, the entire contact.
On the other hand, in the Twitter application,

00:25:26.920 --> 00:25:32.240
they use that feature to be able to -- to
let you select the links inside each tweet.

00:25:32.240 --> 00:25:36.120
So you won't be able to select the entire
tweet, but you can navigate with the track

00:25:36.120 --> 00:25:40.900
ball from link to link.
So we realize that it's a bit awkward and

00:25:40.900 --> 00:25:45.470
sometimes it's difficult when you want to
have complex list items that have several

00:25:45.470 --> 00:25:49.020
touchable areas.
There are, like, good tutorials and explanations

00:25:49.020 --> 00:25:51.410
on various mailing lists and so on on the
Web.

00:25:51.410 --> 00:25:53.563
This is something we would like to improve
in the future.

00:25:53.563 --> 00:25:58.460
So if you have ideas on how we should do that,
feel free to contact us on the various Android

00:25:58.460 --> 00:26:03.130
groups, and we can talk about it.
My current idea is to maybe have a ListView

00:26:03.130 --> 00:26:07.260
2 that will support only touch mode and will
be closer to what you see on other platforms.

00:26:07.260 --> 00:26:13.550
&gt;&gt;Adam Powell: So it's pretty rare that you
have a list that you just want to show without

00:26:13.550 --> 00:26:16.490
context.
Generally, you want to say something to the

00:26:16.490 --> 00:26:19.799
user about what this list contains and what
they're supposed to do with it.

00:26:19.799 --> 00:26:25.380
So for this, again, we come back to the Twitter
application that was recently released.

00:26:25.380 --> 00:26:30.751
As you can see here, we've got several different
items that provide context for what it is

00:26:30.751 --> 00:26:33.070
you're looking at.
We have the tweets header up top.

00:26:33.070 --> 00:26:37.820
We say that we're looking at tweets by Google
I/O in this case.

00:26:37.820 --> 00:26:42.271
But also at the bottom, we have this extra
element that specifies that we're at the end

00:26:42.271 --> 00:26:46.030
of the list that and we're loading new content
on demand.

00:26:46.030 --> 00:26:50.429
So this is an example of several different
ways of handling headers and footers within

00:26:50.429 --> 00:26:55.480
ListView.
If you want to use a fixed header, this is

00:26:55.480 --> 00:26:58.860
pretty easy.
All you need to do is place other views either

00:26:58.860 --> 00:27:03.231
above or below your ListView.
And you've probably seen layouts quite a bit

00:27:03.231 --> 00:27:09.430
like this before.
If you want them to scroll, then things get

00:27:09.430 --> 00:27:12.919
a little bit more complex.
But we've done a little bit of the work for

00:27:12.919 --> 00:27:15.350
you so that you don't have to worry too much
about it.

00:27:15.350 --> 00:27:19.710
Add header view and add footer view both let
you specify a view that will appear at the

00:27:19.710 --> 00:27:23.799
very beginning and the very end of all the
other list content in your adapter.

00:27:23.799 --> 00:27:29.419
You can put whatever you want in here.
However, the trick to this is that you have

00:27:29.419 --> 00:27:33.340
to call these functions before set adapter.
And that might give you a little bit of a

00:27:33.340 --> 00:27:35.950
clue as to how this is implemented under the
hood.

00:27:35.950 --> 00:27:39.240
Both these functions also take an extra parameter
"is selectable."

00:27:39.240 --> 00:27:44.330
This corresponds to whether or not the final
adapter being used will report back to the

00:27:44.330 --> 00:27:47.290
list that these items are enabled.
There's a little bit of a naming conflict

00:27:47.290 --> 00:27:48.919
about that.
Sorry about it.

00:27:48.919 --> 00:27:55.410
It's not the most intuitive thing in the world.
So as you might have guessed, ListView does

00:27:55.410 --> 00:27:59.460
this by internally wrapping your adapter inside
another one, and it returns different view

00:27:59.460 --> 00:28:05.900
types for the first and last item.
So what you need to be careful of with this

00:28:05.900 --> 00:28:09.450
is that you don't make assumptions that if
you do get adapter on your list, that it's

00:28:09.450 --> 00:28:13.330
going to be the same object instance that
you passed in to set adapter in the first

00:28:13.330 --> 00:28:19.820
place.
&gt;&gt;Romain Guy: We're going to take a look at

00:28:19.820 --> 00:28:21.750
the list selectors.
That's what you see when you use the track

00:28:21.750 --> 00:28:25.340
ball to navigate around.
This is what you see when you prefer one click

00:28:25.340 --> 00:28:30.059
on an item or simply tap the item.
When you tap an item, you will see the selector

00:28:30.059 --> 00:28:34.940
appear on screen briefly for, like, 150 milliseconds
or something like that.

00:28:34.940 --> 00:28:38.429
You can customize the list selector.
But what's really important to realize, is

00:28:38.429 --> 00:28:40.880
that, first of all, the list selector is not
shown in touch mode.

00:28:40.880 --> 00:28:45.410
If you select an item with the track ball
then touch with the screen like I mentioned

00:28:45.410 --> 00:28:50.990
before, the selection appears.
Also, the selector by default is shown behind

00:28:50.990 --> 00:28:53.910
the items.
This can be a problem if your items have custom

00:28:53.910 --> 00:29:00.480
backgrounds, a texture or custom color, then
you won't see -- you won't be able to see

00:29:00.480 --> 00:29:04.120
the selector.
On the ListView, in XML, there's also an equivalent,

00:29:04.120 --> 00:29:07.080
you can use the selector called draw selector
on top.

00:29:07.080 --> 00:29:12.660
If you put true, it will be on the top.
If you do that with the default, you won't

00:29:12.660 --> 00:29:18.421
be able to see your item, because our selector
will -- that won't work well.

00:29:18.421 --> 00:29:21.730
Here we have an application on the market
called color note.

00:29:21.730 --> 00:29:29.740
It has a custom color, yellow background.
They've created their own selector, so they've

00:29:29.740 --> 00:29:35.039
created a simple orange border.
How they have done that was simply to set

00:29:35.039 --> 00:29:40.110
the draw selector on top equals true attribute
on ListView so that we move the selector back

00:29:40.110 --> 00:29:44.610
on top of the (inaudible).
Now if you wanted to have a selector that

00:29:44.610 --> 00:29:47.360
was a field -- 'cause you can see here that
it's hollow.

00:29:47.360 --> 00:29:51.161
So if you still want the orange highlights
but you also wanted to have a custom background

00:29:51.161 --> 00:29:55.790
color, you need to do a little more work,
and you will see how to do that in a couple

00:29:55.790 --> 00:29:59.070
of slides.
This is the kind of XML that you have to write

00:29:59.070 --> 00:30:01.642
to create a list selector.
How many of you have ever created your own

00:30:01.642 --> 00:30:04.360
custom selector?
Quite a few.

00:30:04.360 --> 00:30:09.980
And I'm sure that you were a bit puzzled at
first on how to make it work.

00:30:09.980 --> 00:30:17.200
Basically, the idea is that you create a drawable
that will tell the framework what (inaudible)

00:30:17.200 --> 00:30:20.840
so we have a bunch of different states whether
or not the window is the focus, whether or

00:30:20.840 --> 00:30:25.070
not the widget is focused, whether or not
the widget is (inaudible) or selected, et

00:30:25.070 --> 00:30:29.620
cetera.
As you can see here, usually you have to be

00:30:29.620 --> 00:30:33.789
extremely precise about the states.
So if you look at line number 6, we're saying,

00:30:33.789 --> 00:30:39.790
okay, if the item is focused and is not enabled
and is pressed, then we're going to use the

00:30:39.790 --> 00:30:45.360
drawable in the background is disabled.
So the best you can do is not to write those

00:30:45.360 --> 00:30:48.530
from scratch.
Just grab the source code of the Android platform

00:30:48.530 --> 00:30:53.270
or I think we have some examples in the API
demos and just copy and paste what we have

00:30:53.270 --> 00:30:55.520
and just replace everything with your own
drawables.

00:30:55.520 --> 00:31:02.120
There's also one little trick here.
If you look at line number 13, for instance,

00:31:02.120 --> 00:31:06.620
we are referring drawable called list selector
background transition.

00:31:06.620 --> 00:31:09.910
That's the drawable that animates when you
long click on an item in a list.

00:31:09.910 --> 00:31:13.110
It turns from orange to white.
And if you're interested in how to make that

00:31:13.110 --> 00:31:16.870
happen, you can just go check out our source
code and you will see how to declare that

00:31:16.870 --> 00:31:21.600
kind of animation.
Actually, it's pretty simple.

00:31:21.600 --> 00:31:27.340
Now, if your items on the list have a custom
background, custom opaque background like

00:31:27.340 --> 00:31:30.940
we just saw have in the screen shot, and you
still want to have an opaque selector that's

00:31:30.940 --> 00:31:37.630
from behind, there's a simple trick.
You can use select your drawable and give

00:31:37.630 --> 00:31:44.570
it a transparent when it's selected.
Here you can see it's only a few lines of

00:31:44.570 --> 00:31:47.230
XML.
And the state selected -- for the selected

00:31:47.230 --> 00:31:52.100
state, we use a transparent company which
is the number zero.

00:31:52.100 --> 00:31:57.600
And in every other case, we just use whatever
color we decide to use for our item.

00:31:57.600 --> 00:32:00.505
So this is a very simple trick, but it lets
you customize your ListView in whole new ways.

00:32:00.505 --> 00:32:02.490
So this is a very simple trick but it let's
you customize your ListView in whole new ways.

00:32:02.490 --> 00:32:08.740
&gt;&gt;Adam Powell: So coming into a few of the
other features of ListView.

00:32:08.740 --> 00:32:13.450
As many of you who have worked with ListView
will probably already know, there's a whole

00:32:13.450 --> 00:32:16.300
other grab bag of functionality that's available
for to you use.

00:32:16.300 --> 00:32:20.309
So we are going to go through a couple of
those really quickly.

00:32:20.309 --> 00:32:25.690
So transcript mode. How many of you have tried
to write anything resembling chat client?

00:32:25.690 --> 00:32:32.610
Anyone? Okay, we have a few.
So hopefully you found transcript mode useful.

00:32:32.610 --> 00:32:37.740
So this changes the behavior of the list when
the content changes. So when your call notify

00:32:37.740 --> 00:32:44.559
data set changed, your list performs another
layout pass. This defines where we are going

00:32:44.559 --> 00:32:49.900
to scroll to now that you have new content.
If it's disabled, which our default, then

00:32:49.900 --> 00:32:53.659
we don't scroll when anything changes in terms
of your adapter contents.

00:32:53.659 --> 00:32:59.060
If you set transcript mode to normal, however,
then if you are at the edge of the list and

00:32:59.060 --> 00:33:03.050
new content comes in, then we are going to
go ahead and scroll to the bottom if the last

00:33:03.050 --> 00:33:08.070
item is visible.
So this basically makes it such that if you

00:33:08.070 --> 00:33:11.980
are in the middle of a chat client and you
are scrolling back in history, and a new message

00:33:11.980 --> 00:33:16.530
comes in, you are not going to scroll to the
bottom immediately there. But if you are already

00:33:16.530 --> 00:33:21.190
at the bottom and sort of paying attention
to the live stream of things coming in, then

00:33:21.190 --> 00:33:25.660
we are going to go ahead and scroll down and
make that last item visible for you.

00:33:25.660 --> 00:33:31.870
So if you are doing a chat client, usually
you are also -- You don't want everything

00:33:31.870 --> 00:33:35.970
just stacking from the top. That's not usually
the way you view a chat client. So we have

00:33:35.970 --> 00:33:41.690
stack from bottom that makes all the elements
as described stack up from the bottom in terms

00:33:41.690 --> 00:33:45.710
of like a chat history to sort of match up
with any sort of input field you may have

00:33:45.710 --> 00:33:50.200
below it.
So we stack items in reverse order, and we

00:33:50.200 --> 00:33:55.080
start with the last item from the adapter.
So your order still stays the same, but we

00:33:55.080 --> 00:34:00.000
just sort of traverse it differently. Once
again, this comes down to don't make assumptions

00:34:00.000 --> 00:34:05.740
about the order of calls to getView.
So again this is really useful for any sort

00:34:05.740 --> 00:34:11.620
of chat client you might be trying to create.
Here is an example of it. You probably have

00:34:11.620 --> 00:34:16.690
seen something very similar before.
This is using both transcript mode and stack

00:34:16.690 --> 00:34:21.099
from bottom. As you can see, we're building
the list from the bottom, so we have the empty

00:34:21.099 --> 00:34:28.730
space at the top rather than down below.
&gt;&gt;Romain Guy: Every list supports a feature

00:34:28.730 --> 00:34:32.950
called text filtering. This is a feature that
was extremely useful on the first device,

00:34:32.950 --> 00:34:36.289
on the first Android device that came out,
the T-Mobile G1, because it had a keyboard,

00:34:36.289 --> 00:34:40.299
and if you have a Droid, you can actually
use that feature pretty easily. On other devices,

00:34:40.299 --> 00:34:44.799
you have to bring the soft keyboard by keeping
the menu key pressed to be able to use it.

00:34:44.799 --> 00:34:48.569
So what it does is it lets you -- Here is
a screen shot. So for instance, the music

00:34:48.569 --> 00:34:53.200
application, if you bring up the keyboard
and you start typing you are going to filter

00:34:53.200 --> 00:34:56.500
the content of the list. So we are going to
show you only the items that match whatever

00:34:56.500 --> 00:35:00.119
you typed.
And the matching rules depend entirely on

00:35:00.119 --> 00:35:03.769
your adapter.
We have some adapters that by default implement

00:35:03.769 --> 00:35:09.839
the filter. So for instance cursor adapter
and array adapter have a basic implement of

00:35:09.839 --> 00:35:14.000
the filter.
I think in the array adapter, we just do an

00:35:14.000 --> 00:35:18.769
equality comparison so if whatever you type
equals what the item contains, then we are

00:35:18.769 --> 00:35:21.171
going to show it. Otherwise, it's going to
be removed from the list.

00:35:21.171 --> 00:35:26.219
It's very simple to implement yourself if
you have a custom adapter. All you have to

00:35:26.219 --> 00:35:29.700
do is implement the filterable interface and
then the get filter method.

00:35:29.700 --> 00:35:35.650
From the get filter method, you have to return
a new instance of the filter class. And the

00:35:35.650 --> 00:35:40.980
filter class has only two methods. What's
nice about the filtering mechanism in Android

00:35:40.980 --> 00:35:47.059
and we do all the hard work for you, so we
handle everything on the background thread.

00:35:47.059 --> 00:35:50.800
When users stop typing, we are going to invoke
this method called perform filtering on the

00:35:50.800 --> 00:35:53.950
background thread. So you can do whatever
you want in there. It can be very expensive.

00:35:53.950 --> 00:35:56.020
It doesn't matter because you are not going
to bog UI.

00:35:56.020 --> 00:36:01.819
We are going to pass you as a trust sequence
whatever the user has typed, and then it's

00:36:01.819 --> 00:36:07.289
up to you to rebuild a new list of data you
want to display in the ListView.

00:36:07.289 --> 00:36:12.479
To display that new set of data, you have
to return a set of filter results. The filter

00:36:12.479 --> 00:36:16.680
result is a simple class that contains the
number of items that you want to show after

00:36:16.680 --> 00:36:20.971
filtering, and an object. So the object is
whatever you want.

00:36:20.971 --> 00:36:26.089
It's only used to be able -- it can be a cursor,
it can be an array, it can be whatever you

00:36:26.089 --> 00:36:28.749
need.
So then when you return that filter result,

00:36:28.749 --> 00:36:32.920
we are going to invoke the publish results
method on the UI thread and we are going to

00:36:32.920 --> 00:36:37.680
give you back the filter results object. And
your job in this method is simply to extract

00:36:37.680 --> 00:36:42.619
the data you put in the filter result and
communicate to the UI adapter. This is where

00:36:42.619 --> 00:36:48.219
modify the adapter. This is also where you
call notify that asset has changed.

00:36:48.219 --> 00:36:51.749
Implementing a filter is pretty simple. It
involves a couple of classes. But again, if

00:36:51.749 --> 00:36:55.460
you look at the Android source code and you
look at the code of the array adapter or the

00:36:55.460 --> 00:36:59.579
cursor adapter, you will see how we do it
and it's very simple.

00:36:59.579 --> 00:37:03.410
Something that's interesting here, if the
number of results is zero, you might want

00:37:03.410 --> 00:37:09.239
to call and notify that asset invalidated
to tell ListView that there is no more data

00:37:09.239 --> 00:37:16.259
to display.
So now we want to talk about a few issues

00:37:16.259 --> 00:37:19.160
that you might encounter with ListView.
How many of you have ever seen that, like

00:37:19.160 --> 00:37:22.550
you have a beautiful ListView, a custom background
and you start scrolling and everything is

00:37:22.550 --> 00:37:26.519
black?
So a few already. So the other ones have probably

00:37:26.519 --> 00:37:30.011
not tried to customize the background of the
ListView.

00:37:30.011 --> 00:37:34.749
The reason of that is simply because of an
optimization beef done.

00:37:34.749 --> 00:37:41.400
The problem we have with ListView, especially
on low-end devices such as the T-Mobile G1

00:37:41.400 --> 00:37:47.279
or even slower devices, is when you scroll
through a lot of items, especially when you

00:37:47.279 --> 00:37:52.640
are flinging and you see dozens and dozens
of items go by every second, we do a lot of

00:37:52.640 --> 00:37:57.200
blending on screen. And blending is a very
expensive operation. That's because list items

00:37:57.200 --> 00:38:01.200
by default are transparent.
So to avoid that, what we do is that we are

00:38:01.200 --> 00:38:05.520
trying to figure out what is the color behind
the list. And by default we know what that

00:38:05.520 --> 00:38:11.230
color is. It's some kind of black.
So we turn every item into a bitmap, and we

00:38:11.230 --> 00:38:15.289
fill the background of that bitmap with the
color that's behind the list.

00:38:15.289 --> 00:38:19.369
So once we have done that, we know that the
entire list is going to be opaque so we can

00:38:19.369 --> 00:38:23.680
do optimizations like not draw the window
that's behind the list and avoid the blending

00:38:23.680 --> 00:38:30.499
code path in our 2D library, which happened
to be slower than the nonbinding code path.

00:38:30.499 --> 00:38:34.119
And actually, that optimization happens as
soon as you touch the screen. As soon as your

00:38:34.119 --> 00:38:38.950
finger comes into contact with the screen,
it will turn all the items on the screen into

00:38:38.950 --> 00:38:41.440
bitmaps.
So the solution to that issue is simply to

00:38:41.440 --> 00:38:47.020
specify the cache color hint. This is an indication
for ListView about the background color. So

00:38:47.020 --> 00:38:51.279
if you specify the color zero, like in the
first line of the solution here, you are telling

00:38:51.279 --> 00:38:56.229
ListView, okay, I don't have a solid background.
I might have a texture or a complex background.

00:38:56.229 --> 00:39:00.539
Please don't do any optimization. So then
we are going to go through a slower code path

00:39:00.539 --> 00:39:04.890
but at least you will be able to see everything.
If you remember, one of the first slides when

00:39:04.890 --> 00:39:09.609
I showed you this app I wrote that had a wooden
texture, this is what I have done. I disabled

00:39:09.609 --> 00:39:14.940
the cache color hint.
If you have a solid background color and you

00:39:14.940 --> 00:39:17.460
know what is that background color -- for
instance, you are writing an application that

00:39:17.460 --> 00:39:21.690
is green in the background -- you can simply
specify that color and then you are going

00:39:21.690 --> 00:39:25.849
to get the optimization of ListView and you
are going to get the correct result.

00:39:25.849 --> 00:39:30.650
&gt;&gt;Adam Powell: So how many of you have been
flinging through a list before and seen that

00:39:30.650 --> 00:39:35.390
the scrollbar along the side of the screen
changes size?

00:39:35.390 --> 00:39:37.880
Yes? Okay.
&gt;&gt;Romain Guy: This is what you call the snake.

00:39:37.880 --> 00:39:42.619
&gt;&gt;Adam Powell: Right, the snake effect.
So the reason why this happens is, again,

00:39:42.619 --> 00:39:47.210
because we're only drawing as many views as
we need on screen. And when views have vastly

00:39:47.210 --> 00:39:52.759
differing heights, being able to measure that
such that we can estimate how much more space

00:39:52.759 --> 00:39:57.140
is left to scroll through across the rest
of the adapter becomes a really difficult

00:39:57.140 --> 00:40:02.640
problem. It's the sort of thing we have to
get some sort of approximation fast, and that's

00:40:02.640 --> 00:40:05.499
why you end up seeing the scrollbar changing
size.

00:40:05.499 --> 00:40:11.369
So if you don't like this effect, if this
is something that really sort of detracts

00:40:11.369 --> 00:40:16.719
from your app, then you can go ahead and set
smooth scrollbar equals false on your list.

00:40:16.719 --> 00:40:21.680
What this will do is it tells ListView don't
even try to bother measuring heights of items

00:40:21.680 --> 00:40:28.069
to give an estimate of how much scroll space
is left. Instead, just use your current position

00:40:28.069 --> 00:40:32.420
in terms of what items are on screen.
This will make it a little bit chunkier if

00:40:32.420 --> 00:40:37.509
you have small data sets, but across very
large data sets, this will really smooth out

00:40:37.509 --> 00:40:42.470
how the list looks in terms of scrollbars.
&gt;&gt;Romain Guy: Another solution is also just

00:40:42.470 --> 00:40:48.079
to remove the scrollbar.
Okay. So this is something I have seen many

00:40:48.079 --> 00:40:52.289
times, and every time I see it I start swearing
in front of my screen and then Joe hates me

00:40:52.289 --> 00:40:57.410
because he sits next to me.
This is when you set the la layout height

00:40:57.410 --> 00:41:02.130
of a view in XML to wrap content. So have
you ever done that? That's okay, I won't be

00:41:02.130 --> 00:41:09.079
mad at you. Just raise your hands. Okay. I
like when people admit their errors.

00:41:09.079 --> 00:41:13.579
The problem with wrap content is ListView
is virtualized. So ListView can have two items

00:41:13.579 --> 00:41:18.730
but it can have millions of items. So when
it tells us wrap contents it tells us I want

00:41:18.730 --> 00:41:23.759
ListView to be as big as it its content. Should
we go through the million items and measure

00:41:23.759 --> 00:41:27.839
them? That would probably not be a very good
idea.

00:41:27.839 --> 00:41:31.989
And because so many people are requesting
that or are trying do it, we made it work

00:41:31.989 --> 00:41:35.329
without making it work.
So if you set the height of your ListView

00:41:35.329 --> 00:41:39.041
to wrap content we are going to measure the
first three items of your list.

00:41:39.041 --> 00:41:43.549
And actually a lot of people are confused
by that behavior because sometimes I see messages

00:41:43.549 --> 00:41:49.799
on our groups saying, hey, when I put log
statements in the getView method, I see getView

00:41:49.799 --> 00:41:54.089
is requesting items number zero, one, two,
and then zero, one, two, three, four, five

00:41:54.089 --> 00:41:58.849
again. And they don't understand why. And
that's the reason. Because during the layout

00:41:58.849 --> 00:42:02.609
we are going to ask the adapter for the first
three items, we are going to measure them,

00:42:02.609 --> 00:42:06.030
put them in the recycler and then when we
need the real items we are going to ask for

00:42:06.030 --> 00:42:10.789
these items again.
It is expensive, especially if you have very

00:42:10.789 --> 00:42:15.240
complex items in your ListView. If you are
crazy and put Web items inside your list then

00:42:15.240 --> 00:42:19.839
it will take a lot of time for the ListView
to measure itself. And a lot of times that

00:42:19.839 --> 00:42:24.609
is really not what you want.
So either avoid it, either use fill parent

00:42:24.609 --> 00:42:27.920
as the height of your ListView or if you are
in a linear layout, you can set the height

00:42:27.920 --> 00:42:34.039
to zero and you can use the layout weight
to tell the list to fill your remaining available

00:42:34.039 --> 00:42:37.660
space. I was going to also say the height
view leads you to a fixed amount. Like you

00:42:37.660 --> 00:42:42.279
can say 200 DIP's to use 200 pixels on the
G1.

00:42:42.279 --> 00:42:48.200
&gt;&gt;Adam Powell: How many people have wanted
to do this before? A ListView inside of a

00:42:48.200 --> 00:42:58.829
scroll view? Don't be shy. Hands up.
So what happens here? A scroll view scrolls,

00:42:58.829 --> 00:43:04.109
a ListView scrolls. Which one should scroll
when you start moving? We actually got a moderator

00:43:04.109 --> 00:43:08.599
for this over the weekend for this session
already asking if we could add an element

00:43:08.599 --> 00:43:15.150
 -- or an attribute to ListView to say can
I make my ListView scrollable equals false

00:43:15.150 --> 00:43:19.869
so that I can put it inside a scrollView and
just let the scrollView take care of it? The

00:43:19.869 --> 00:43:26.099
quick answer is no, and the reason for that
is once again a ListView can have tens of

00:43:26.099 --> 00:43:31.029
thousands possibly even millions of items
inside of it and the correct answer in that

00:43:31.029 --> 00:43:36.890
case is almost never to open up that many
views, throw them all into a scrollView and

00:43:36.890 --> 00:43:42.759
just let the system die trying to chug along
processing all of that.

00:43:42.759 --> 00:43:49.709
So generally, this is where any engineer asks
the question, okay, what is it that you are

00:43:49.709 --> 00:43:54.299
trying to do? And generally the answer to
that is, well, I want to have something special,

00:43:54.299 --> 00:43:58.599
either above or below my list, but I want
to have mostly just my list content through

00:43:58.599 --> 00:44:02.380
this view.
So for that, we would really like to point

00:44:02.380 --> 00:44:06.130
you towards the existing header and footer
features that already exist.

00:44:06.130 --> 00:44:10.109
If you have a layout that you want to put
above or below a list and still have the entire

00:44:10.109 --> 00:44:13.759
thing scroll, you can go ahead and sit that
as a list header or footer.

00:44:13.759 --> 00:44:18.019
&gt;&gt;Romain Guy: And by the way, when we tell
you to not put the ListView inside the scrollView,

00:44:18.019 --> 00:44:21.910
don't put the scrollView inside the ListView.
&gt;&gt;Adam Powell: Yeah, that, too.

00:44:21.910 --> 00:44:30.740
&gt;&gt;Romain Guy: Yeah, so we mentioned that before
in the talk at the beginning, but we really

00:44:30.740 --> 00:44:34.120
want to insist on that point, like do not
try to cache views inside your adapter. I

00:44:34.120 --> 00:44:38.279
have seen that done way too many times.
There are various reasons why people try to

00:44:38.279 --> 00:44:44.660
do it. And the problem is that it might work,
and most of the time your list might work.

00:44:44.660 --> 00:44:48.599
And suddenly something really weird is going
to start happening like maybe you won't be

00:44:48.599 --> 00:44:53.040
able to click the item. Maybe you have an
animation in the item that doesn't work anymore.

00:44:53.040 --> 00:44:57.480
And the reason for that is that, again, ListView
has many optimizations. It has a very complex

00:44:57.480 --> 00:45:03.670
recycler. It makes a lot of assumptions about
the ownership of the views that are on screen.

00:45:03.670 --> 00:45:08.359
And to make things even faster is when you
put something in the recycler that view is

00:45:08.359 --> 00:45:12.619
not really off screen. Like the view still
thinks it's kind of on screen but the ListView

00:45:12.619 --> 00:45:17.900
knows that it's not really the case.
So we handle that very, very carefully. And

00:45:17.900 --> 00:45:24.479
again, for performance reasons. And as soon
as you try to play tricks on your adapter,

00:45:24.479 --> 00:45:28.259
we are going to end up with views that are
basically zombie views.

00:45:28.259 --> 00:45:32.440
For instance, if from the getView method you
return a view that we also have in our recycler,

00:45:32.440 --> 00:45:36.160
we are going to have a view that's supposed
to be on screen but at the same time that's

00:45:36.160 --> 00:45:41.469
not on screen. So then the framework just
gives up and says, hey, whatever. Like, I

00:45:41.469 --> 00:45:45.890
give up.
So just never ever ever ever ever ever do

00:45:45.890 --> 00:45:49.670
that.
If you need to access a view directly, we

00:45:49.670 --> 00:45:56.869
have a method called get first visible position.
It tells you what is the position in your

00:45:56.869 --> 00:46:02.720
adapter of the first view that's visible on
screen. So by using this method and get (inaudible)

00:46:02.720 --> 00:46:06.329
account that tells you how many items are
visible on screen, you can easily go back

00:46:06.329 --> 00:46:12.589
and forth between the index and the positions.
If you want to for some reason change the

00:46:12.589 --> 00:46:18.239
color of a view on screen without doing a
(inaudible) change, just use get child on

00:46:18.239 --> 00:46:26.789
the list to get the view that you need.
&gt;&gt;Adam Powell: So finally, after all of this,

00:46:26.789 --> 00:46:31.849
I'm sure that we have sort of hammered home
the point. ListView is a really complex widget.

00:46:31.849 --> 00:46:36.079
It's probably the most complex one that we
have across the entire Android framework.

00:46:36.079 --> 00:46:40.270
We spend a lot of time in there just not only
helping developers but just making sure that

00:46:40.270 --> 00:46:46.010
everything stays working, fast, optimized.
And really, it's optimized for repeating unbounded

00:46:46.010 --> 00:46:50.549
data.
It adds a lot of complexity to your app.

00:46:50.549 --> 00:46:54.990
So if you have a small amount of data that
you just want to have some sort of repeating

00:46:54.990 --> 00:46:59.609
presentation for, maybe you don't actually
need a ListView for it at all. Maybe all you

00:46:59.609 --> 00:47:05.420
need in this case is to dynamically generate
some views, put them inside a linear layout

00:47:05.420 --> 00:47:10.510
with a vertical orientation, and put that
layout inside a scrollView. And this is going

00:47:10.510 --> 00:47:15.099
to make your app a lot simpler if you have
a small data set with a bunch of special cases

00:47:15.099 --> 00:47:21.559
inside it rather than trying to bend the ListView
into whatever application you have for it.

00:47:21.559 --> 00:47:25.849
&gt;&gt;Romain Guy: And that's pretty much it for
today. We could go on for hours about ListView

00:47:25.849 --> 00:47:29.350
because there are many features we haven't
talked about. There are many stuff that you

00:47:29.350 --> 00:47:32.779
stud know about, but I'm sure by now you are
all pretty bored by ListView.

00:47:32.779 --> 00:47:36.630
We are going to start taking questions. If
you want to ask a question you can go to the

00:47:36.630 --> 00:47:41.059
microphones in the alleys, and we also have
questions on moderator.

00:47:41.059 --> 00:47:48.019
&gt;&gt;Adam Powell: Do we want to bring that up?
&gt;&gt;Romain Guy: Don't be shy. You can come ask

00:47:48.019 --> 00:47:53.029
questions.
You can ask about anything you want that's

00:47:53.029 --> 00:48:02.549
related to Android.
&gt;&gt;&gt; Hi. You said not to put ListViews in scroll

00:48:02.549 --> 00:48:08.949
views. But the assumption behind that was
that the scrollView be vertically scrolling.

00:48:08.949 --> 00:48:13.509
If we want to emulate something like the Palm
Pre's pager where we have vertical scrolling

00:48:13.509 --> 00:48:18.949
and horizontal paging, I have seen on forums
and stuff that some people are trying to do

00:48:18.949 --> 00:48:24.650
that, and that's also been done with Google
sports application. But that particular app,

00:48:24.650 --> 00:48:28.280
as far as I can tell, so far is closed source.
But we would like to know how to do that.

00:48:28.280 --> 00:48:33.289
&gt;&gt;Romain Guy: So basically, you have vertical
scrolling ListView and you want to go from

00:48:33.289 --> 00:48:36.979
page to page horizontally.
&gt;&gt;&gt; I have many pages of similar but different

00:48:36.979 --> 00:48:38.579
content --
&gt;&gt;Romain Guy: That's fine. You can use your

00:48:38.579 --> 00:48:43.729
horizontal scroll view. What matters is that
the two scrolls that you have on it on the

00:48:43.729 --> 00:48:46.770
same axis.
The whole screen, for instance, has a pager

00:48:46.770 --> 00:48:52.849
and when you open the folder on home it's
a list, and you can still page horizontally

00:48:52.849 --> 00:48:56.200
and scroll that list.
You can look at the source code of the launcher

00:48:56.200 --> 00:48:59.039
application.
&gt;&gt;Adam Powell: It's called workspace.java.

00:48:59.039 --> 00:49:04.059
&gt;&gt;Romain Guy: It's called workspace.java,
and I think we have that in other applications

00:49:04.059 --> 00:49:09.170
somewhere else. But look at workspace.java
in the launch source code and you will see

00:49:09.170 --> 00:49:11.509
it's pretty easy to do.
&gt;&gt;Adam Powell: We have had a number of discussions

00:49:11.509 --> 00:49:15.749
about specifically adding a widget capable
of doing this horizontal paging into the framework,

00:49:15.749 --> 00:49:20.900
and so far we haven't decided on the best
way to do it just in terms of getting it out

00:49:20.900 --> 00:49:26.529
there, making sure people are able to make
good use of it.

00:49:26.529 --> 00:49:33.369
&gt;&gt;&gt; Excuse me. I have a view in my app that
is -- I try to have been inspired from the

00:49:33.369 --> 00:49:38.339
market app the way for an individual app it
has some headers and some little lists inside

00:49:38.339 --> 00:49:44.640
it. I thought it was really great.
In implementing that myself without looking

00:49:44.640 --> 00:49:48.650
how the market source code did it, it was
really tricky, and it's a little too complicated

00:49:48.650 --> 00:49:53.789
for me to want to dot sort of LinearLayout
scrollView. It feels like a ListView, but

00:49:53.789 --> 00:50:01.269
in order to do that, I ended up having to
do a lot of Java code. Instead of one larger

00:50:01.269 --> 00:50:05.940
XML file, it's a lot of small ones that get
bound together through Java work. I ended

00:50:05.940 --> 00:50:11.400
up using a merge adapter, sort of a general
thing which Mark Murphy made which is helpful

00:50:11.400 --> 00:50:15.279
for that purpose.
So it's just unifying a lot of different adapters

00:50:15.279 --> 00:50:17.190
together.
It just feels like overkill.

00:50:17.190 --> 00:50:20.519
Am I missing something on how to do that?
&gt;&gt;Romain Guy: No. That's pretty much the way

00:50:20.519 --> 00:50:23.049
to do it.
The big problem, again, is that ListView was

00:50:23.049 --> 00:50:27.089
mostly designed to have a long list of data
and every item is pretty much the same.

00:50:27.089 --> 00:50:30.770
We do support very different items like you
mentioned.

00:50:30.770 --> 00:50:33.599
But, yeah, when you want to do that, unfortunately,
you'll have some work to do.

00:50:33.599 --> 00:50:40.049
&gt;&gt;&gt; And the merge adapter itself is really
nontrivial in how it has to track what -- the

00:50:40.049 --> 00:50:42.509
position of every item and show the right
one.

00:50:42.509 --> 00:50:44.449
It's just something I would never want to
do myself.

00:50:44.449 --> 00:50:47.190
But I guess that's just the way it is.
&gt;&gt;Romain Guy: Yeah.

00:50:47.190 --> 00:50:48.190
Sorry.
&gt;&gt;&gt; Okay.

00:50:48.190 --> 00:50:51.829
&gt;&gt;Romain Guy: But if you have suggestions,
like, I'm sure there are solutions that we

00:50:51.829 --> 00:50:55.180
haven't thought of, like, contact us, or file
bugs.

00:50:55.180 --> 00:51:01.749
We do look at them.
And we'll see what we can do in a future release.

00:51:01.749 --> 00:51:06.650
I'm going to take one of the Dory questions.
So someone, Larry, from China, asks, long

00:51:06.650 --> 00:51:10.670
click to get more actions for an item is very
weird for a normal user.

00:51:10.670 --> 00:51:15.740
Can we have similar UI widget, like contacts,
action menu, just like Twitter developed by

00:51:15.740 --> 00:51:17.930
themselves.
So I think he is referring to that little

00:51:17.930 --> 00:51:21.499
popup you get when you click on the contact
in the address book in Android 2.0.

00:51:21.499 --> 00:51:27.660
And the answer to that is, yes, sure, you
can have one.

00:51:27.660 --> 00:51:31.549
The Twitter app is going to be open source.
So you're going to have the source code for

00:51:31.549 --> 00:51:34.441
the widget so you'll be able to use it.
It's actually pretty easy to do.

00:51:34.441 --> 00:51:37.769
Maybe it's easy for me to say that because
I know it's done.

00:51:37.769 --> 00:51:41.059
But once you see the source code, you'll see
there's no magic in there.

00:51:41.059 --> 00:51:48.030
&gt;&gt;&gt; Thanks.
Any tips on how to do an adapter view where

00:51:48.030 --> 00:51:52.230
the length of the data set is not known?
&gt;&gt;Romain Guy: Pardon me?

00:51:52.230 --> 00:51:55.950
&gt;&gt;Adam Powell: The length of the data set
is not known.

00:51:55.950 --> 00:51:58.700
&gt;&gt;Romain Guy: Yeah, actually, that's what
the calendar does.

00:51:58.700 --> 00:52:04.029
The calendar, when disturb I think when you
go into the agenda mode, they have basically

00:52:04.029 --> 00:52:07.900
an infinite list.
And they do that by just playing with that

00:52:07.900 --> 00:52:12.640
change.
So they just say that they have integer at

00:52:12.640 --> 00:52:17.650
max value number of items and then they just
populate with number of stuff.

00:52:17.650 --> 00:52:21.979
Every time you have a change, you can change
the number of items in the adapter.

00:52:21.979 --> 00:52:26.700
You can grab a random number and later on
if you realize you have more items, you can

00:52:26.700 --> 00:52:31.180
change that number and keep going.
&gt;&gt;&gt; Thank you.

00:52:31.180 --> 00:52:37.299
&gt;&gt;&gt; I noticed when I used bit maps to load
or, like, (inaudible) also that the whole

00:52:37.299 --> 00:52:41.499
views have to be refreshed.
Is there any method, like, to say only one

00:52:41.499 --> 00:52:45.680
item, one specific item by ID is going to
be changed?

00:52:45.680 --> 00:52:49.309
&gt;&gt;Romain Guy: If you are trying to -- so if
you are trying to change one item and you

00:52:49.309 --> 00:52:53.119
call notify data set change, the whole view
is going to be refreshed.

00:52:53.119 --> 00:52:57.059
But, actually, ListView is pretty smart here,
and this is where we have our complex recycler.

00:52:57.059 --> 00:53:01.869
Because it's able to figure out that most
of what you're changing is actually the same

00:53:01.869 --> 00:53:04.979
and on screen.
So it's going to reuse everything it can.

00:53:04.979 --> 00:53:09.509
It's still going to redraw the entire screen.
But if that's a real issue for you, you can

00:53:09.509 --> 00:53:12.940
directly grab the view, you can call get child
at.

00:53:12.940 --> 00:53:16.700
And that's why you use get for a visible position,
to figure out what's the translation between

00:53:16.700 --> 00:53:20.589
the position and the index, and then you can
just call setImage or whatever you want on

00:53:20.589 --> 00:53:24.809
the view.
If you want a good example, if you look at

00:53:24.809 --> 00:53:29.090
code.google.com/p/shell, that's the application
that we showed in one of the first slides,

00:53:29.090 --> 00:53:34.599
I have very complex code to support that kind
of optimized code, and you can -- optimized

00:53:34.599 --> 00:53:37.670
operation, and you can look at it and see
how to do it.

00:53:37.670 --> 00:53:39.140
Over there.
&gt;&gt;&gt; Hi.

00:53:39.140 --> 00:53:43.910
I have two questions.
First is, we try to use a relative layout

00:53:43.910 --> 00:53:48.849
for the list.
And it seems to ignore the attributes not

00:53:48.849 --> 00:53:53.979
relative layout.
&gt;&gt;Romain Guy: I know why.

00:53:53.979 --> 00:53:56.199
And, actually, I put the answer on one of
the slides.

00:53:56.199 --> 00:54:01.759
Yes, so the problem is that you have a relative
layout and your layout attributes are ignored.

00:54:01.759 --> 00:54:07.699
It's having very simple.
The documentation for that sucks.

00:54:07.699 --> 00:54:12.029
And, again, that's totally our fault.
So I'm very sorry.

00:54:12.029 --> 00:54:17.819
So here, for instance, we're calling inflate.
And we're passing null as the last parameter.

00:54:17.819 --> 00:54:22.319
Null is the parent -- so that parameter is
the parent of the view you're inflating.

00:54:22.319 --> 00:54:26.730
By saying null, you're telling the frame,
I don't know what the parent is going to be.

00:54:26.730 --> 00:54:29.349
When we don't know what the parent is, we
don't know what the layout parameters will

00:54:29.349 --> 00:54:32.509
be.
So we give up and don't give the parameters.

00:54:32.509 --> 00:54:36.829
What we have to do is call this version of
inflate where you pass the parent.

00:54:36.829 --> 00:54:38.680
And that's why get view will give you the
parent.

00:54:38.680 --> 00:54:42.719
So you pass the parent.
But if you pass true at the end, we're going

00:54:42.719 --> 00:54:47.270
to call add view on the parent.
But if you do that on ListView, it's going

00:54:47.270 --> 00:54:50.900
to crash.
So you have to pass false.

00:54:50.900 --> 00:54:54.799
So whenever you're in getView and you get
something, always pass the parent and.

00:54:54.799 --> 00:55:03.979
&gt;&gt;&gt; We also try to use the alpha indexer for
fast scrolling.

00:55:03.979 --> 00:55:08.900
And if the data does change, it seems like
the alpha indexer can't be updated.

00:55:08.900 --> 00:55:13.729
&gt;&gt;Romain Guy: That's a current limitation.
We have a bug filed somewhere internally about

00:55:13.729 --> 00:55:15.660
that.
Maybe we will do it.

00:55:15.660 --> 00:55:17.809
But I don't think it's going to happen anytime
soon.

00:55:17.809 --> 00:55:22.229
So if you guys want to write a copatch, I'm
going to (inaudible) with myself and I will

00:55:22.229 --> 00:55:25.099
be very glad to accept it.
&gt;&gt;&gt; Okay.

00:55:25.099 --> 00:55:28.199
Thank you.
&gt;&gt;&gt; You said you were taking questions about

00:55:28.199 --> 00:55:30.940
Android in general?
&gt;&gt;Romain Guy: We can try.

00:55:30.940 --> 00:55:32.960
&gt;&gt;&gt; Okay.
Well, I'm playing catch-up, because a family

00:55:32.960 --> 00:55:36.229
emergency kept me out yesterday.
Has Froyo been addressed or is there word

00:55:36.229 --> 00:55:38.181
when it will be?
&gt;&gt;Romain Guy: Nothing has been announced.

00:55:38.181 --> 00:55:43.910
&gt;&gt;&gt; Is it true it has hit ASP already, though?
&gt;&gt;Romain Guy: Nothing has been announced?

00:55:43.910 --> 00:55:52.900
We are very, very good at dodging those questions.
So don't even try.

00:55:52.900 --> 00:55:55.410
The mike first.
Can you grab the mike.

00:55:55.410 --> 00:55:57.979
&gt;&gt;&gt; Real quick question.
(Off mike).

00:55:57.979 --> 00:56:03.040
&gt;&gt;Romain Guy: So the slides, every session
within the next few weeks will be available

00:56:03.040 --> 00:56:05.211
on the Google I/O Web site.
You'll get the video and the slides.

00:56:05.211 --> 00:56:14.609
&gt;&gt;&gt; (Off mike).
&gt;&gt;Romain Guy: I don't know.

00:56:14.609 --> 00:56:18.640
That's okay.
&gt;&gt;&gt; Okay.

00:56:18.640 --> 00:56:22.880
So I have a ListView that part of my apps
 -- part of my app is a -- it's a surveying

00:56:22.880 --> 00:56:28.740
app, so I'm using GPS between two devices.
So long story is, it takes -- exactly what

00:56:28.740 --> 00:56:31.829
it does and what I'm doing that for, I'll
just get right to the point with the ListView

00:56:31.829 --> 00:56:36.309
question.
So one of the things is, it -- part of this

00:56:36.309 --> 00:56:39.049
is, I'm using SMS to send messages back and
forth.

00:56:39.049 --> 00:56:46.430
So somebody can send you their current position,
GPS coordinates, or a message that says, could

00:56:46.430 --> 00:56:48.670
you move ten yards to the right or something
like that.

00:56:48.670 --> 00:56:54.319
Right now I'm using a Java reg X to sort out
when somebody sends you a pair of GPS coordinates

00:56:54.319 --> 00:56:59.430
and populating that in a ListView that has
the positional data, versus the chat window,

00:56:59.430 --> 00:57:07.410
which has the ListView.
You were talking earlier about a class which

00:57:07.410 --> 00:57:14.539
will do sort of like predictive -- some sort
of sorting out of as you're typing or as the

00:57:14.539 --> 00:57:15.539
data comes?
&gt;&gt;Romain Guy: Yeah.

00:57:15.539 --> 00:57:16.539
It's filtering.
So if you --

00:57:16.539 --> 00:57:20.719
&gt;&gt;&gt; I'm wondering, would the filter be more
appropriate with that or am I just better

00:57:20.719 --> 00:57:25.319
off -- is the reg X going to be faster?
&gt;&gt;Romain Guy: I mean, you can implement the

00:57:25.319 --> 00:57:28.319
filter with the reg X.
It's really up to you.

00:57:28.319 --> 00:57:34.239
I don't think it matters in your case.
&gt;&gt;&gt; I'm not losing or gaining anything just

00:57:34.239 --> 00:57:37.799
by going to Java.regX.
&gt;&gt;Romain Guy: Not at all.

00:57:37.799 --> 00:57:41.690
&gt;&gt;&gt; Is the filtering mostly for interactive?
Is that mostly for interactive?

00:57:41.690 --> 00:57:45.220
&gt;&gt;Romain Guy: Yes.
You can use it for noninteractive actions,

00:57:45.220 --> 00:57:48.240
but it's not really meant for that.
&gt;&gt;&gt; All right.

00:57:48.240 --> 00:57:51.319
Thanks.
&gt;&gt;Romain Guy: So question from Dory.

00:57:51.319 --> 00:57:55.690
So setting the adapter to the ListView can
become a blocking operation if the adapter

00:57:55.690 --> 00:57:57.729
gets the data from the network.
Any tips?

00:57:57.729 --> 00:58:02.769
Use threads.
That's pretty much all there is to it.

00:58:02.769 --> 00:58:05.509
Just don't block the UI thread.
&gt;&gt;Adam Powell: The trick here is to make sure

00:58:05.509 --> 00:58:10.740
that even if you're collecting your data from
the network, you have to perform the commit

00:58:10.740 --> 00:58:13.569
operation on the UI thread.
So you can go ahead and just post a message

00:58:13.569 --> 00:58:19.099
to your UI thread through the normal event
system and take your big blob of data that

00:58:19.099 --> 00:58:23.009
you have at the end and go ahead and commit
those changes to the adapter there and call

00:58:23.009 --> 00:58:25.079
note tie data set changed.
&gt;&gt;&gt; Hi.

00:58:25.079 --> 00:58:32.219
I have a list that I set the list adapter
from an array that I have in my program.

00:58:32.219 --> 00:58:35.579
And on click, you know, most of the time,
it works just great.

00:58:35.579 --> 00:58:38.309
I have the position.
And then you guys were talking about the filter.

00:58:38.309 --> 00:58:41.920
And then there's an ID.
I'm wondering, can I use that ID and will

00:58:41.920 --> 00:58:45.729
it correlate to my array in the position it
should be?

00:58:45.729 --> 00:58:49.420
Because the position, you know, if there are
filters and then there's three items, 100

00:58:49.420 --> 00:58:51.670
items in the array, then it picks the wrong
item.

00:58:51.670 --> 00:58:56.920
So can I guarantee that they'll correlate?
&gt;&gt;Romain Guy: So by default, in an array adapter,

00:58:56.920 --> 00:59:01.749
the ID is the index of the item inside the
array.

00:59:01.749 --> 00:59:04.839
So when you filter the array that you're -- the
IDs will change.

00:59:04.839 --> 00:59:08.579
So they are not stable.
So if you want them to be stable across filtering,

00:59:08.579 --> 00:59:12.270
you will have to implement your own adapter
and maybe change the filter to store some

00:59:12.270 --> 00:59:14.999
extra data in the items so you can know what
item it is.

00:59:14.999 --> 00:59:20.079
&gt;&gt;&gt; So I just basically have to cross reference
the data and just check?

00:59:20.079 --> 00:59:21.079
&gt;&gt;Romain Guy: Yeah.
&gt;&gt;&gt; Okay.

00:59:21.079 --> 00:59:22.599
Thank you.
&gt;&gt;Romain Guy: We know it's not great, but

00:59:22.599 --> 00:59:24.690
sorry.
And, unfortunately, we are out of time for

00:59:24.690 --> 00:59:27.049
the questions.
So if you have more questions, we have the

00:59:27.049 --> 00:59:30.740
Android Google Groups.
There is overflow where you can ask questions

00:59:30.740 --> 00:59:33.420
online.
A few of us are monitoring and will try to

00:59:33.420 --> 00:59:35.629
answer your questions when we have time.
Thank you very much.

00:59:35.629 --> 00:59:35.789
[ Applause ]

