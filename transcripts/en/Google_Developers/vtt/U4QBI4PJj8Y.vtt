WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.350
[MUSIC PLAYING]

00:00:07.050 --> 00:00:08.480
DARREN KRAHN: Welcome everyone.

00:00:08.480 --> 00:00:09.400
Thank you for coming.

00:00:09.400 --> 00:00:10.149
My name is Darren.

00:00:10.149 --> 00:00:12.040
I'm a software
engineer at Google.

00:00:12.040 --> 00:00:14.390
I work on Android
Things security.

00:00:14.390 --> 00:00:16.170
Today I want to talk
about our approach

00:00:16.170 --> 00:00:18.540
to security with Android
Things and why we

00:00:18.540 --> 00:00:20.240
think it can make a difference.

00:00:22.525 --> 00:00:24.400
I'm going to give a
little bit of background.

00:00:24.400 --> 00:00:26.775
If you've been to some of the
other Android Things talks,

00:00:26.775 --> 00:00:29.400
you've probably already
heard some of this.

00:00:29.400 --> 00:00:31.904
But in case anyone that
hasn't, one of the things

00:00:31.904 --> 00:00:33.820
we're doing is we're
doing a SoM architecture.

00:00:33.820 --> 00:00:35.710
SoM is a System on Module.

00:00:35.710 --> 00:00:37.414
It's a little board.

00:00:37.414 --> 00:00:38.830
And it has all the
core components

00:00:38.830 --> 00:00:40.660
that you need to
run Android Things.

00:00:40.660 --> 00:00:42.910
So it'll have your processor,
your memory, your flash,

00:00:42.910 --> 00:00:46.730
your Wi-Fi, Bluetooth
controller, and so forth.

00:00:46.730 --> 00:00:51.400
And the idea is that we support
some finite number of SoMs,

00:00:51.400 --> 00:00:53.044
a relatively few number.

00:00:53.044 --> 00:00:55.210
And then when you build a
product in Android Things,

00:00:55.210 --> 00:00:57.580
you pick one of these
SoMs, and the idea

00:00:57.580 --> 00:01:02.350
being that we can push
updates to the SoMs--

00:01:02.350 --> 00:01:03.680
a smaller number of SoMs--

00:01:03.680 --> 00:01:07.050
and that can fan out to a much
larger number of products,

00:01:07.050 --> 00:01:09.320
and we can reduce the
overhead that way.

00:01:09.320 --> 00:01:11.050
So when I say SoM,
that's what I mean.

00:01:11.050 --> 00:01:13.324
It's in pictures up
here on the slide.

00:01:13.324 --> 00:01:15.240
Now the other concept
that I want to introduce

00:01:15.240 --> 00:01:16.417
is Developer Console.

00:01:16.417 --> 00:01:18.250
And that's something
that doesn't exist now,

00:01:18.250 --> 00:01:20.400
but it will exist in
the coming months.

00:01:20.400 --> 00:01:25.000
And this is a place where
developers can go and manage

00:01:25.000 --> 00:01:25.720
their devices.

00:01:25.720 --> 00:01:27.969
They can manage updates to
their devices and so forth.

00:01:27.969 --> 00:01:31.610
And they'll have an account with
Google Android Things Developer

00:01:31.610 --> 00:01:32.110
Console.

00:01:36.140 --> 00:01:39.140
So our core strategy is to
build the security features

00:01:39.140 --> 00:01:42.859
into the platform, to
have them on by default,

00:01:42.859 --> 00:01:44.150
and to maintain them over time.

00:01:46.722 --> 00:01:48.680
We want Google to be
running the infrastructure

00:01:48.680 --> 00:01:50.450
and to take that
heavy lifting off

00:01:50.450 --> 00:01:54.510
of developers so they don't need
to have that additional cost.

00:01:57.632 --> 00:02:00.640
I'm going to talk about
five features today

00:02:00.640 --> 00:02:03.020
that we're building
into Android Things--

00:02:03.020 --> 00:02:08.490
OS hardening, updates, verified
boot, hardware-backed keys,

00:02:08.490 --> 00:02:10.667
and attestation.

00:02:10.667 --> 00:02:12.500
And I'm going to dig
into each one of these.

00:02:12.500 --> 00:02:15.762
But before I do that, I
want to talk about why

00:02:15.762 --> 00:02:16.970
we think these are important.

00:02:16.970 --> 00:02:19.360
What's the actual problem
that we're trying to solve?

00:02:22.680 --> 00:02:24.300
The main problem
with IoT security

00:02:24.300 --> 00:02:25.860
is an economic problem.

00:02:25.860 --> 00:02:29.280
We're not seeing so much
new technical problems--

00:02:29.280 --> 00:02:34.689
same old buffer overflows,
same old past reversals,

00:02:34.689 --> 00:02:36.480
the same kind of
technical problems applied

00:02:36.480 --> 00:02:38.920
to IoT as we've seen in
computer security historically.

00:02:38.920 --> 00:02:40.620
But historically in
computer security,

00:02:40.620 --> 00:02:44.760
there's always been a trade
off, an economic trade off,

00:02:44.760 --> 00:02:46.795
between the cost of
building a security in

00:02:46.795 --> 00:02:48.870
and the risk of not
building a security in.

00:02:48.870 --> 00:02:52.020
And with IoT, we're
increasingly and acutely seeing

00:02:52.020 --> 00:02:54.150
a skew towards lower costs.

00:02:54.150 --> 00:02:55.470
Lower cost matters.

00:02:55.470 --> 00:02:58.710
Devices are getting
cheaper and cheaper.

00:02:58.710 --> 00:03:00.660
Device makers, companies
making devices,

00:03:00.660 --> 00:03:03.430
are getting smaller and smaller.

00:03:03.430 --> 00:03:07.350
And we're seeing that skew
towards lower cost instead

00:03:07.350 --> 00:03:09.900
of building in the security.

00:03:09.900 --> 00:03:12.090
That's on the device maker side.

00:03:12.090 --> 00:03:13.590
But if we flip it
around, there's

00:03:13.590 --> 00:03:18.305
also an economic
side for attackers.

00:03:18.305 --> 00:03:20.430
There's a cost associated
with building an exploit,

00:03:20.430 --> 00:03:21.722
with building an attack.

00:03:21.722 --> 00:03:23.930
And there's also a value
that they can get out of it.

00:03:23.930 --> 00:03:26.870
For some hackers, it's
literally their business model.

00:03:26.870 --> 00:03:29.370
They find the exploits and they
sell them on whatever market

00:03:29.370 --> 00:03:30.720
they're working in.

00:03:30.720 --> 00:03:33.550
And they have those
two factors in play.

00:03:36.714 --> 00:03:40.610
So I want to talk a little bit
about three economic factors--

00:03:40.610 --> 00:03:42.850
attack costs, attack
return on investment--

00:03:42.850 --> 00:03:45.410
both of these from the
perspective of an attacker--

00:03:45.410 --> 00:03:49.300
and then security costs from the
perspective of a device maker.

00:03:52.000 --> 00:03:54.346
By attack cost, I really
mean, how much does it

00:03:54.346 --> 00:03:55.470
cost to engineer an attack?

00:03:55.470 --> 00:03:59.800
And this could be how much
does it cost with money--

00:03:59.800 --> 00:04:02.950
maybe I have to pay for compute
cycles, or what have you.

00:04:02.950 --> 00:04:07.390
Maybe it just takes a lot of
time, and that's a cost too.

00:04:07.390 --> 00:04:09.400
Sometimes it also
just costs skill.

00:04:09.400 --> 00:04:11.800
And sometimes skills
aren't readily available.

00:04:11.800 --> 00:04:14.170
Maybe our attacker
has access to a skill,

00:04:14.170 --> 00:04:15.460
or has the skill themselves.

00:04:15.460 --> 00:04:17.940
Maybe they don't.

00:04:17.940 --> 00:04:19.959
And there's also a
component of grit.

00:04:19.959 --> 00:04:21.795
And that is how
much frustration is

00:04:21.795 --> 00:04:23.420
an attacker going to
have to go through

00:04:23.420 --> 00:04:27.250
to build a particular attack.

00:04:27.250 --> 00:04:29.830
How much patience are
they going to have?

00:04:29.830 --> 00:04:33.357
And if we can sweep up all
the low hanging fruit, where

00:04:33.357 --> 00:04:35.440
an attacker's going to
have put a lot more effort,

00:04:35.440 --> 00:04:39.130
a lot more patience
into finding an exploit,

00:04:39.130 --> 00:04:40.750
we've raised the
bar in attack costs.

00:04:40.750 --> 00:04:45.360
And we want to raise the bar
on all of these categories.

00:04:45.360 --> 00:04:48.330
And the second thing is
attack return on investment.

00:04:48.330 --> 00:04:51.200
Once an attack is developed,
how much is it worth?

00:04:51.200 --> 00:04:53.570
What does it actually
get the attacker?

00:04:53.570 --> 00:04:55.206
Maybe they want to
use it themselves.

00:04:55.206 --> 00:04:56.330
Maybe they want to sell it.

00:04:56.330 --> 00:04:58.350
But ultimately,
what is it worth?

00:04:58.350 --> 00:04:59.950
And there's a list
of three things

00:04:59.950 --> 00:05:03.530
that make an attack valuable.

00:05:03.530 --> 00:05:05.390
One is whether an
attack is pervasive--

00:05:05.390 --> 00:05:08.275
that is, whether it scales
to a large number of devices.

00:05:10.950 --> 00:05:13.450
And let me give
you two examples.

00:05:13.450 --> 00:05:16.730
Let's consider an attack that
requires Wi-Fi injection.

00:05:16.730 --> 00:05:19.850
So to execute the attack, you
have all your radio equipment

00:05:19.850 --> 00:05:20.510
in the van.

00:05:20.510 --> 00:05:22.940
You pull up the van
outside your target.

00:05:22.940 --> 00:05:25.850
And you execute the
attack and you drive off.

00:05:25.850 --> 00:05:28.400
It might be a really
effective attack.

00:05:28.400 --> 00:05:32.380
But it only scales with the
number of hackers in vans.

00:05:32.380 --> 00:05:36.830
And so there's a real limit
to what you can do with that.

00:05:36.830 --> 00:05:39.230
On the other hand,
second example

00:05:39.230 --> 00:05:41.630
is you find a default
credential on the internet.

00:05:41.630 --> 00:05:43.088
You find a
vulnerability, where you

00:05:43.088 --> 00:05:44.990
can get into a
certain type of device

00:05:44.990 --> 00:05:48.920
and you can get it to any model
built on that sort of category.

00:05:48.920 --> 00:05:51.729
And you can just, from
the comfort of your sofa,

00:05:51.729 --> 00:05:53.270
scan around looking
for these devices

00:05:53.270 --> 00:05:55.610
and start adding hundreds
and thousands of devices

00:05:55.610 --> 00:05:58.430
to your botnet.

00:05:58.430 --> 00:06:02.030
That's a much more
pervasive attack.

00:06:02.030 --> 00:06:04.850
The second thing that can
make an attack valuable

00:06:04.850 --> 00:06:07.892
is whether it gives the
attacker some kind of privilege.

00:06:07.892 --> 00:06:10.100
So if they get execution on
device, what can they do?

00:06:10.100 --> 00:06:12.980
Do they have access
to valuable data?

00:06:12.980 --> 00:06:17.810
Do they have access to
valuable operations?

00:06:17.810 --> 00:06:19.630
Maybe want to
control an actuator.

00:06:19.630 --> 00:06:21.560
Maybe they want raw
access to that hardware.

00:06:21.560 --> 00:06:23.550
Maybe they want to
take cryptographic keys

00:06:23.550 --> 00:06:26.096
and exfiltrate them, copy
them off, and use them

00:06:26.096 --> 00:06:26.720
somewhere else.

00:06:31.020 --> 00:06:34.030
The third thing that
I have is persistent.

00:06:34.030 --> 00:06:36.660
An attack is persistent
when an attacker

00:06:36.660 --> 00:06:40.090
can stay in control of a device
for a long period of time.

00:06:40.090 --> 00:06:43.890
So can the attack
survive reboots?

00:06:43.890 --> 00:06:46.320
Can the attack survive updates?

00:06:46.320 --> 00:06:49.860
Can the attacks survive
factory resets, which

00:06:49.860 --> 00:06:53.710
is the ultimate persistence.

00:06:53.710 --> 00:06:56.910
And so if an attack is
all three of these--

00:06:56.910 --> 00:07:00.700
pervasive, privileged
and persistent--

00:07:00.700 --> 00:07:04.110
it get really high return on
investment for that attack.

00:07:06.947 --> 00:07:09.030
Let's flip it around and
talk about security cost.

00:07:09.030 --> 00:07:11.040
How much does it cost to
build the defenses in?

00:07:11.040 --> 00:07:13.206
How much does it cost to
build the security features

00:07:13.206 --> 00:07:14.340
into a product?

00:07:14.340 --> 00:07:18.510
And a lot of the costs are
associated with maintenance

00:07:18.510 --> 00:07:20.660
and ongoing costs.

00:07:20.660 --> 00:07:23.160
So there is definitely cost of
building in security features

00:07:23.160 --> 00:07:24.110
up front.

00:07:24.110 --> 00:07:26.520
But there's an even
more important cost

00:07:26.520 --> 00:07:29.720
built into maintaining
it going forward.

00:07:29.720 --> 00:07:31.560
And not every company
has the resources

00:07:31.560 --> 00:07:34.699
to build and/or maintain
these security features.

00:07:34.699 --> 00:07:36.990
And even large companies
often don't have the resources

00:07:36.990 --> 00:07:37.930
allocated to do this.

00:07:41.101 --> 00:07:43.796
So for the Android Things
ecosystem of devices,

00:07:43.796 --> 00:07:45.420
this is the effect
that we want to have

00:07:45.420 --> 00:07:46.740
on these economic factors.

00:07:46.740 --> 00:07:49.140
We want to push attack costs
up, like I was mentioning.

00:07:49.140 --> 00:07:50.680
We want to raise the bar.

00:07:50.680 --> 00:07:53.040
We want to push attack
return on investment

00:07:53.040 --> 00:07:56.161
down so for a
particular exploit,

00:07:56.161 --> 00:07:58.286
there's just less that an
attacker can do with that

00:07:58.286 --> 00:08:01.360
and it offers less value.

00:08:01.360 --> 00:08:03.970
We also want to push
security costs down.

00:08:03.970 --> 00:08:08.670
So for device makers, like
you all, a lot of the costs

00:08:08.670 --> 00:08:10.140
get taken care of
by the platform

00:08:10.140 --> 00:08:12.570
and so you just don't
have to worry about them.

00:08:15.670 --> 00:08:19.900
The first feature I want to
talk about is OS hardening.

00:08:19.900 --> 00:08:22.330
Hardening, in general,
is improving security

00:08:22.330 --> 00:08:26.530
by reducing attack surface.

00:08:26.530 --> 00:08:28.270
And for an operating
system, that

00:08:28.270 --> 00:08:31.562
means that programs
that it's running

00:08:31.562 --> 00:08:33.520
operate under the principle
of least privilege.

00:08:33.520 --> 00:08:37.990
It means that if they don't need
a privilege to do something,

00:08:37.990 --> 00:08:39.490
then they don't
have that privilege.

00:08:39.490 --> 00:08:41.049
And so if an attacker
gets execution

00:08:41.049 --> 00:08:43.809
in the context of that
application, for example,

00:08:43.809 --> 00:08:45.580
then they're limited
to the set of things

00:08:45.580 --> 00:08:49.830
that that application is
already allowed to do.

00:08:49.830 --> 00:08:53.140
So there's a lot of
examples of hardening

00:08:53.140 --> 00:08:54.850
that we do in Android.

00:08:54.850 --> 00:08:57.611
And because Android Things is
Android, all of that hardening

00:08:57.611 --> 00:08:59.110
just translates
into Android Things.

00:08:59.110 --> 00:09:00.910
When you build a device
on Android Things,

00:09:00.910 --> 00:09:04.700
you get all of that
built into your device.

00:09:04.700 --> 00:09:06.477
So we have permissions.

00:09:06.477 --> 00:09:07.810
We don't do runtime permissions.

00:09:07.810 --> 00:09:11.957
We don't expect users to be
interacting with these devices.

00:09:11.957 --> 00:09:13.540
But we do do install
time permissions.

00:09:13.540 --> 00:09:15.934
And it's declared in
the sense that when

00:09:15.934 --> 00:09:17.350
you build your
application, you're

00:09:17.350 --> 00:09:18.580
going to be declaring
the permissions that you

00:09:18.580 --> 00:09:20.380
want that application to have.

00:09:20.380 --> 00:09:23.890
And even though the user
doesn't approve that,

00:09:23.890 --> 00:09:25.300
it's still useful.

00:09:25.300 --> 00:09:27.232
Because if an attacker
does get execution

00:09:27.232 --> 00:09:28.690
in the context of
your application,

00:09:28.690 --> 00:09:30.606
they're going to be
limited by the permissions

00:09:30.606 --> 00:09:32.940
that you've declared.

00:09:32.940 --> 00:09:34.480
The application
sandbox the same.

00:09:34.480 --> 00:09:37.750
Every application is going
to run as its own UID.

00:09:37.750 --> 00:09:39.200
All the mandatory
access controls

00:09:39.200 --> 00:09:42.550
that we enforce with SELinux
are going to be there,

00:09:42.550 --> 00:09:45.070
all the kernel syscall
filtering that we put in.

00:09:45.070 --> 00:09:46.540
By the way, who's
ever tried this?

00:09:46.540 --> 00:09:49.330
Has anyone tried to roll their
own mandatory access controls?

00:09:49.330 --> 00:09:54.440
Anybody tried to use SELinux
or written their own seccomp

00:09:54.440 --> 00:09:56.560
BPF syscall filters?

00:09:56.560 --> 00:09:57.380
I see a few hands.

00:09:57.380 --> 00:09:58.921
And you probably
understand the pain.

00:09:58.921 --> 00:10:00.570
This is really,
really hard to do.

00:10:00.570 --> 00:10:03.700
And a lot of projects start
out with good intentions.

00:10:03.700 --> 00:10:05.077
They're going to build this in.

00:10:05.077 --> 00:10:07.660
And they get farther along, and
they need to ship the product,

00:10:07.660 --> 00:10:10.210
and they can't get this
working properly or reliably,

00:10:10.210 --> 00:10:12.160
and they turn it off.

00:10:12.160 --> 00:10:16.000
And with Android Things,
we get all of this working,

00:10:16.000 --> 00:10:18.790
and you get all of that built
right into your platform.

00:10:18.790 --> 00:10:20.250
So there's many,
many other things.

00:10:20.250 --> 00:10:23.450
And all the stuff,
all the ongoing work

00:10:23.450 --> 00:10:26.200
that is done for Android,
comes into Android Things--

00:10:26.200 --> 00:10:28.570
ASLR, Fortify Source.

00:10:28.570 --> 00:10:32.680
There's a good blog post on
Fortify Source in Android.

00:10:32.680 --> 00:10:36.660
Check that out-- just
last month, I think--

00:10:36.660 --> 00:10:38.560
stack-protector-strong,
if you're

00:10:38.560 --> 00:10:40.240
stack canaries, and so forth.

00:10:44.230 --> 00:10:46.440
So what do user
developers need to do

00:10:46.440 --> 00:10:48.030
to enable us in your platform?

00:10:48.030 --> 00:10:48.750
Almost nothing.

00:10:48.750 --> 00:10:49.950
Really, it's just
the permissions that

00:10:49.950 --> 00:10:51.060
apply to your applications.

00:10:51.060 --> 00:10:52.726
And then like I was
saying, declare them

00:10:52.726 --> 00:10:53.700
only as you need them.

00:10:53.700 --> 00:10:54.570
There's another thing
that you can do,

00:10:54.570 --> 00:10:56.640
is if you do have
something that's

00:10:56.640 --> 00:10:58.530
a very powerful permission
that you do need--

00:10:58.530 --> 00:11:01.260
for example, if you're writing
an Android Things user driver

00:11:01.260 --> 00:11:05.039
and it has access to a bus--

00:11:05.039 --> 00:11:06.330
you may want to split that out.

00:11:06.330 --> 00:11:08.790
Split out that privilege code
into a second application.

00:11:08.790 --> 00:11:11.165
And just give the code that
actually needs that privilege

00:11:11.165 --> 00:11:11.790
that privilege.

00:11:11.790 --> 00:11:14.724
And the rest of your code will
run without that privilege.

00:11:17.690 --> 00:11:20.330
So OS hardening really
goes after attack cost.

00:11:20.330 --> 00:11:23.050
It really puts hurdles
and barriers in the way.

00:11:23.050 --> 00:11:25.990
And it just makes it more and
more difficult for an attacker

00:11:25.990 --> 00:11:28.922
to get onto a device and
escalate from there--

00:11:28.922 --> 00:11:31.130
so more difficult to move
from the context of one app

00:11:31.130 --> 00:11:32.860
to another, move to
the context of route,

00:11:32.860 --> 00:11:34.250
move to the context of kernel.

00:11:34.250 --> 00:11:36.800
And there's just
barrier after barrier.

00:11:36.800 --> 00:11:41.930
And that really drives
up the attack cost.

00:11:41.930 --> 00:11:44.540
It also, on the right,
lowers the security cost.

00:11:44.540 --> 00:11:48.105
Because for developers, because
Google is taking care of this,

00:11:48.105 --> 00:11:50.188
they're doing the heavy
lifting for the hardening.

00:11:52.936 --> 00:11:54.990
The next feature I want
to talk about is updates.

00:11:54.990 --> 00:11:56.281
This is a pretty important one.

00:11:56.281 --> 00:11:59.447
It gets talked about a lot in
the context of IoT security.

00:11:59.447 --> 00:12:00.780
And it's also pretty hard to do.

00:12:00.780 --> 00:12:02.760
With Android Things,
we're building in updates.

00:12:02.760 --> 00:12:04.426
And updates are going
to be from Google.

00:12:04.426 --> 00:12:07.320
Every Android Things device
will be able to get updates

00:12:07.320 --> 00:12:07.830
from Google.

00:12:11.514 --> 00:12:13.930
So developers don't need to
run any update infrastructure.

00:12:13.930 --> 00:12:15.096
We'll serve all the updates.

00:12:15.096 --> 00:12:17.130
We'll build all the updates.

00:12:17.130 --> 00:12:20.750
And like I was mentioning
with the SoM architecture,

00:12:20.750 --> 00:12:23.220
this is what really
allows us to scale.

00:12:23.220 --> 00:12:25.109
So we can build for a
finite number of SoMs

00:12:25.109 --> 00:12:26.900
and then scale that
out to all the products

00:12:26.900 --> 00:12:28.233
that you want to build on those.

00:12:30.717 --> 00:12:32.050
It works a little bit like this.

00:12:32.050 --> 00:12:34.240
So a developer would
upload their app

00:12:34.240 --> 00:12:38.710
to their account on
Developer Console.

00:12:38.710 --> 00:12:42.010
Google has the OS
built for their SoM.

00:12:42.010 --> 00:12:44.530
This all gets packaged
together as an update.

00:12:44.530 --> 00:12:46.580
And then it goes
OTA to the device.

00:12:46.580 --> 00:12:49.330
So users don't install
apps on their IoT devices.

00:12:49.330 --> 00:12:52.480
Developers package the apps that
they want for their product,

00:12:52.480 --> 00:12:55.284
and that goes in an
OTA update to devices.

00:12:59.580 --> 00:13:01.080
Updates are automatic.

00:13:01.080 --> 00:13:02.610
We don't want any friction.

00:13:02.610 --> 00:13:05.070
Especially when we're fixing
a security vulnerability,

00:13:05.070 --> 00:13:08.220
we want that update to
go out to all the devices

00:13:08.220 --> 00:13:11.580
that are active and online.

00:13:11.580 --> 00:13:14.640
And as soon as you put any
kind of friction in there,

00:13:14.640 --> 00:13:16.230
then it gets neglected.

00:13:16.230 --> 00:13:18.216
People aren't sure
what to do with it.

00:13:18.216 --> 00:13:20.692
And so for users
at least, there's

00:13:20.692 --> 00:13:21.900
not going to be any friction.

00:13:21.900 --> 00:13:23.879
Devices will just
update themselves.

00:13:23.879 --> 00:13:25.170
They'll automatically download.

00:13:25.170 --> 00:13:28.050
They'll automatically
apply the update.

00:13:28.050 --> 00:13:32.220
And they'll automatically
do the restart.

00:13:32.220 --> 00:13:34.870
And we use the AB updates.

00:13:34.870 --> 00:13:37.660
So there's actually a
robustness built in.

00:13:37.660 --> 00:13:39.480
We'll have a second copy.

00:13:39.480 --> 00:13:40.752
And then we'll boot to that.

00:13:40.752 --> 00:13:42.960
If there is a problem with
if it, if it doesn't boot,

00:13:42.960 --> 00:13:45.270
we'll flip back and go back
to where it was before,

00:13:45.270 --> 00:13:47.790
and we can fix it from there.

00:13:50.507 --> 00:13:51.840
Updates are going to be regular.

00:13:51.840 --> 00:13:55.365
So Android has their monthly
cadence for security updates.

00:13:55.365 --> 00:13:58.360
And they do this for
Nexus Pixel devices.

00:13:58.360 --> 00:14:03.540
And we're going to be following
that same monthly cadence.

00:14:03.540 --> 00:14:06.570
But as a developer, when
you're writing applications,

00:14:06.570 --> 00:14:08.220
the application
portion of your device,

00:14:08.220 --> 00:14:09.844
you're not constrained
by this cadence.

00:14:09.844 --> 00:14:11.730
If you want to ship
an update mid-month,

00:14:11.730 --> 00:14:13.990
you can go ahead and
ship that update.

00:14:13.990 --> 00:14:17.430
If you want to wait till we
ship the OS update, that's--

00:14:17.430 --> 00:14:17.940
either way.

00:14:17.940 --> 00:14:19.110
You're not constrained
by this cadence,

00:14:19.110 --> 00:14:21.318
but this will be the update
cadence for the operating

00:14:21.318 --> 00:14:23.080
system.

00:14:23.080 --> 00:14:25.140
It's also worth noting
that we do a lot

00:14:25.140 --> 00:14:26.650
of looking for vulnerabilities.

00:14:26.650 --> 00:14:29.070
And updates have real
value when you're actually

00:14:29.070 --> 00:14:30.540
fixing those vulnerabilities.

00:14:30.540 --> 00:14:32.760
And if you're not
looking for them,

00:14:32.760 --> 00:14:36.070
and you just don't
know how secure it is.

00:14:36.070 --> 00:14:37.570
And so if you have
an update system,

00:14:37.570 --> 00:14:39.361
but you're not looking
for vulnerabilities,

00:14:39.361 --> 00:14:40.560
it really has limited value.

00:14:40.560 --> 00:14:43.890
And with Android,
all the resources

00:14:43.890 --> 00:14:46.140
that go into looking for
vulnerabilities for Android--

00:14:46.140 --> 00:14:47.730
we get that translating
into Android Things

00:14:47.730 --> 00:14:48.688
and we get those fixes.

00:14:51.727 --> 00:14:53.560
So some of you may be
thinking, I'm not sure

00:14:53.560 --> 00:14:55.650
if I want Google to be
automatically shipping

00:14:55.650 --> 00:14:58.510
and downloading and
rebooting my devices

00:14:58.510 --> 00:15:00.280
and updating this thing.

00:15:00.280 --> 00:15:01.870
And there's going
to be some controls.

00:15:01.870 --> 00:15:03.730
For the first one is
developer controls.

00:15:03.730 --> 00:15:05.410
So every time we
get an update, we're

00:15:05.410 --> 00:15:07.541
not just going to push
it down to your devices.

00:15:07.541 --> 00:15:09.290
There's going to be
no friction for users.

00:15:09.290 --> 00:15:10.810
But there is a little
bit for developers.

00:15:10.810 --> 00:15:13.180
And they're going to get a
chance to test their devices

00:15:13.180 --> 00:15:14.609
and say, yes, this
seems to work.

00:15:14.609 --> 00:15:16.150
And they're going
to be able to push.

00:15:16.150 --> 00:15:19.540
So when they get notification
there's a new version of the OS

00:15:19.540 --> 00:15:22.330
available for their device,
there's three options

00:15:22.330 --> 00:15:23.470
that they can take.

00:15:23.470 --> 00:15:25.400
The first action is
they can push it.

00:15:25.400 --> 00:15:27.040
And that as that they
do their testing.

00:15:27.040 --> 00:15:27.730
Everything seems to work.

00:15:27.730 --> 00:15:28.450
They can push it.

00:15:28.450 --> 00:15:30.616
And then the update system
will start pushing it out

00:15:30.616 --> 00:15:31.700
to their fleet of devices.

00:15:31.700 --> 00:15:33.574
The other thing that
they can do is block it.

00:15:33.574 --> 00:15:35.810
And this is what you would
do if something's wrong,

00:15:35.810 --> 00:15:39.660
if you test it, something's
broken, and you can say, whoa.

00:15:39.660 --> 00:15:41.730
Don't push that update
to any of my devices.

00:15:41.730 --> 00:15:43.600
And at that point, we're
going to want that feedback

00:15:43.600 --> 00:15:44.480
via the Developer Console.

00:15:44.480 --> 00:15:45.400
We're going to want bugs filed.

00:15:45.400 --> 00:15:46.450
We need to figure
out what's going on,

00:15:46.450 --> 00:15:48.070
because that shouldn't happen.

00:15:48.070 --> 00:15:52.660
And the third option is
developers can ignore it.

00:15:52.660 --> 00:15:55.292
This may happen if a
developer abandons a product.

00:15:55.292 --> 00:15:57.250
This may happen-- maybe
a company goes belly up

00:15:57.250 --> 00:15:58.640
or what have you.

00:15:58.640 --> 00:16:02.420
And in this case, the default
is going to be to push.

00:16:02.420 --> 00:16:03.840
There's going to
be a time window.

00:16:03.840 --> 00:16:05.631
And if we see no activity
from a developer,

00:16:05.631 --> 00:16:08.950
the default is going to
be to push the security

00:16:08.950 --> 00:16:10.750
fixes to those devices.

00:16:10.750 --> 00:16:13.180
And so potentially,
that abandoned device

00:16:13.180 --> 00:16:16.120
could still be getting
security fixes from Google.

00:16:19.540 --> 00:16:21.160
There's also on device controls.

00:16:21.160 --> 00:16:23.770
Because not every time is a
convenient time to be rebooting

00:16:23.770 --> 00:16:26.007
or a convenient time
to be doing a download.

00:16:26.007 --> 00:16:28.090
And maybe your device is
a drone, and it's flying,

00:16:28.090 --> 00:16:31.210
and rebooting would be bad.

00:16:31.210 --> 00:16:33.490
Maybe a user is actively
using the device

00:16:33.490 --> 00:16:37.030
and you don't want any
jank in the experience.

00:16:37.030 --> 00:16:39.759
So the device controls
basically-- there's

00:16:39.759 --> 00:16:40.550
going to be an API.

00:16:40.550 --> 00:16:42.650
And your application
will be able to say,

00:16:42.650 --> 00:16:44.500
I'm doing something
critical right now.

00:16:44.500 --> 00:16:46.229
Hold off on any updates.

00:16:46.229 --> 00:16:47.770
And so then it'll
be up to developers

00:16:47.770 --> 00:16:53.320
to actually have a sense
for when their device is--

00:16:53.320 --> 00:16:54.710
when is a good time to update.

00:16:59.500 --> 00:17:03.570
So if you were to label light
switches, like my kids use them

00:17:03.570 --> 00:17:07.484
around the house, it would
look a little bit like this.

00:17:07.484 --> 00:17:09.900
And I don't know if anyone
else has kids that leave lights

00:17:09.900 --> 00:17:12.329
on around the house,
but this is basically

00:17:12.329 --> 00:17:14.940
the same interpretation
we want for developers,

00:17:14.940 --> 00:17:18.210
when they're keeping
their devices up to date.

00:17:18.210 --> 00:17:19.829
Just leave the lights on.

00:17:19.829 --> 00:17:22.800
Just keep those updates
rolling for your products.

00:17:25.167 --> 00:17:27.000
And really, that's the
only developer action

00:17:27.000 --> 00:17:27.964
we have for updates.

00:17:27.964 --> 00:17:28.880
Just don't block them.

00:17:34.820 --> 00:17:38.210
The real economic impact here
is that return on investment

00:17:38.210 --> 00:17:39.625
for attacks is lowered.

00:17:39.625 --> 00:17:42.184
And that's because every time
we're fixing vulnerabilities,

00:17:42.184 --> 00:17:44.600
any exploits that were built
on top of the vulnerabilities

00:17:44.600 --> 00:17:45.550
are no longer useful.

00:17:45.550 --> 00:17:47.660
We can fix up the
whole fleet of devices

00:17:47.660 --> 00:17:52.115
and that exploit has
lost all of its value.

00:17:52.115 --> 00:17:54.740
Possibly, if the exploit didn't
get deep enough into the device

00:17:54.740 --> 00:17:56.630
to actually prevent
updates, the update

00:17:56.630 --> 00:18:00.650
may actually clean up
devices that were infected.

00:18:00.650 --> 00:18:02.770
It also lowers security
cost, once again,

00:18:02.770 --> 00:18:04.520
because Google's doing
the heavy lifting--

00:18:04.520 --> 00:18:05.960
doing the heavy lifting
on the infrastructure,

00:18:05.960 --> 00:18:08.390
serving all the updates,
building all the images,

00:18:08.390 --> 00:18:11.690
and also doing heavy
lifting on the device

00:18:11.690 --> 00:18:15.380
with robustly updating
devices and figuring out

00:18:15.380 --> 00:18:17.840
how to do that in the
best possible way.

00:18:22.550 --> 00:18:26.630
The next feature I want to
talk about is Verified Boot.

00:18:26.630 --> 00:18:29.550
We're building Verified Boot
into every Android device.

00:18:29.550 --> 00:18:31.610
And some you probably know
what Verified Boot is.

00:18:31.610 --> 00:18:32.600
Let me describe
it really quickly.

00:18:32.600 --> 00:18:34.474
It's basically using
cryptographic signatures

00:18:34.474 --> 00:18:36.571
to verify code before
it gets executed.

00:18:36.571 --> 00:18:37.820
So we'd start on the hardware.

00:18:37.820 --> 00:18:41.600
The hardware would load
the first level bootloader

00:18:41.600 --> 00:18:43.250
and check a signature on it.

00:18:43.250 --> 00:18:46.729
If it's authorized, then that
bootloader would execute.

00:18:46.729 --> 00:18:48.770
It would load the next
bootloader, or the kernel,

00:18:48.770 --> 00:18:51.000
or whatever's next, and
check the signature on that,

00:18:51.000 --> 00:18:52.500
and then execute
that, and so forth,

00:18:52.500 --> 00:18:54.340
until the entire
OS is booted up.

00:18:54.340 --> 00:18:58.220
And what you get in
the end is assurance

00:18:58.220 --> 00:18:59.720
that nobody's
modified this code.

00:18:59.720 --> 00:19:04.030
This code has been authorized
by you, the developer,

00:19:04.030 --> 00:19:06.050
and by Google.

00:19:06.050 --> 00:19:10.490
So again, Google does
the heavy lifting.

00:19:10.490 --> 00:19:12.757
The Developer Console
will take care

00:19:12.757 --> 00:19:14.590
of making sure all your
images are assigned.

00:19:14.590 --> 00:19:16.720
Google manages
the sign in keys--

00:19:16.720 --> 00:19:18.130
take care of proper
key rotation,

00:19:18.130 --> 00:19:20.320
take care of proper
protection for root keys.

00:19:20.320 --> 00:19:22.480
If there's a public
key that's fused

00:19:22.480 --> 00:19:24.520
into the device, making
sure that private key

00:19:24.520 --> 00:19:26.940
is sufficiently protected.

00:19:26.940 --> 00:19:29.050
And on the device,
also taking some

00:19:29.050 --> 00:19:33.430
of that heavy lifting, where we
have a Verified Boot reference

00:19:33.430 --> 00:19:35.600
code that does the actual
verification on a device.

00:19:35.600 --> 00:19:38.230
And this will be
running in bootloaders.

00:19:38.230 --> 00:19:41.250
And this is required on
every Android Things device,

00:19:41.250 --> 00:19:45.270
that the bootloaders need to
be running this reference code.

00:19:45.270 --> 00:19:46.270
So I put the link there.

00:19:46.270 --> 00:19:49.180
You can go take a look at it.

00:19:49.180 --> 00:19:51.580
That initial step
for every SoM is

00:19:51.580 --> 00:19:54.700
going to be hardware specific,
so the transition from hardware

00:19:54.700 --> 00:19:57.170
to initial bootloader
and so forth.

00:19:57.170 --> 00:20:01.240
But once the bootloader
executes the AVB code,

00:20:01.240 --> 00:20:03.349
then it's Google's
sign in mechanism

00:20:03.349 --> 00:20:05.890
and Google's verification code
that takes over at that point.

00:20:09.510 --> 00:20:11.200
There's going to be
per-product keys.

00:20:11.200 --> 00:20:13.080
So you don't want
some other product

00:20:13.080 --> 00:20:15.580
that's built on the same SoM
to be able to run your software

00:20:15.580 --> 00:20:17.107
images and vice versa.

00:20:17.107 --> 00:20:18.190
And so we're going to be--

00:20:18.190 --> 00:20:20.523
your keys will be associated
with your Developer Console

00:20:20.523 --> 00:20:21.460
account.

00:20:21.460 --> 00:20:25.990
And only your products be able
to run your software images.

00:20:25.990 --> 00:20:29.134
And other products-- it
simply just won't boot.

00:20:29.134 --> 00:20:30.550
There's going be
a product ID that

00:20:30.550 --> 00:20:31.674
gets fused into the device.

00:20:31.674 --> 00:20:34.959
So it'll be a permanent
association with that product

00:20:34.959 --> 00:20:36.000
once it gets locked down.

00:20:39.990 --> 00:20:41.550
We're building
rollback protection

00:20:41.550 --> 00:20:43.600
into Verified Boot
on every device.

00:20:43.600 --> 00:20:47.670
So a rollback attack is when
an attacker takes a device

00:20:47.670 --> 00:20:49.590
and moves it back to a
previously authorized

00:20:49.590 --> 00:20:50.970
but vulnerable state.

00:20:50.970 --> 00:20:53.820
So suppose you have
version 1 of your software.

00:20:53.820 --> 00:20:54.359
You sign it.

00:20:54.359 --> 00:20:55.900
You push it to your
fleet of devices.

00:20:55.900 --> 00:20:56.940
Everything's fine for a while.

00:20:56.940 --> 00:20:59.070
And then you discover
you have a vulnerability.

00:20:59.070 --> 00:21:00.028
And you want to fix it.

00:21:00.028 --> 00:21:01.930
And so you fix it in version 2.

00:21:01.930 --> 00:21:04.110
You update all your
devices to version 2.

00:21:04.110 --> 00:21:06.630
The rollback attack would be
the attacker takes the device,

00:21:06.630 --> 00:21:09.630
flashes it back to
version 1, reboots,

00:21:09.630 --> 00:21:11.490
signatures check
out OK, and then

00:21:11.490 --> 00:21:13.810
they exploit that
known vulnerability.

00:21:13.810 --> 00:21:17.010
And so what we want to happen
is once it moves to version 2,

00:21:17.010 --> 00:21:21.860
it refuses to boot
anything previous to that.

00:21:21.860 --> 00:21:23.820
And so we enforce that
for software images.

00:21:23.820 --> 00:21:25.110
We also enforce that
for sign in keys.

00:21:25.110 --> 00:21:27.109
I mentioned we'll do the
automated key rotation.

00:21:27.109 --> 00:21:29.520
Once a device sees a newer
key, it will no longer

00:21:29.520 --> 00:21:30.390
trust an older key.

00:21:36.850 --> 00:21:38.470
The Verfied Boot
Hash is something

00:21:38.470 --> 00:21:40.330
that we're building
into Android Things.

00:21:40.330 --> 00:21:42.790
And this is new
that we're doing.

00:21:42.790 --> 00:21:45.470
And this is tied in with
the Verified Boot system

00:21:45.470 --> 00:21:48.137
in the sense that at
every stage in the boot,

00:21:48.137 --> 00:21:49.720
whatever it is that's
being verified--

00:21:49.720 --> 00:21:54.390
whether that's a boot loader or
whether it's a kernel image--

00:21:54.390 --> 00:21:58.132
the hash of that gets mixed
into the cryptographic hash.

00:21:58.132 --> 00:21:59.590
And at the end of
the boot process,

00:21:59.590 --> 00:22:02.350
you have a value that represents
the exact software that's

00:22:02.350 --> 00:22:04.495
running on that system.

00:22:04.495 --> 00:22:07.510
And if you can remotely
verify that value,

00:22:07.510 --> 00:22:09.580
then you can tell not
only did this device,

00:22:09.580 --> 00:22:11.290
when it booted, did
it run signed code,

00:22:11.290 --> 00:22:13.750
but I know exactly which
signed code that it ran,

00:22:13.750 --> 00:22:16.600
which can be valuable,
especially when you're

00:22:16.600 --> 00:22:18.476
monitoring devices remotely.

00:22:24.030 --> 00:22:26.030
What do developers need
to do for Verified Boot?

00:22:26.030 --> 00:22:26.946
Really nothing at all.

00:22:26.946 --> 00:22:30.140
There's going to be a factory
step to lock this down.

00:22:30.140 --> 00:22:32.380
And after that, the Verified
Boot system's engaged,

00:22:32.380 --> 00:22:34.410
and there's no way
to un-engage it.

00:22:38.920 --> 00:22:42.860
Verify Boot, again, lowers
attack return on investment.

00:22:42.860 --> 00:22:44.630
It makes it hard
to get persistence.

00:22:44.630 --> 00:22:46.921
So an exploit that might have
had persistence before no

00:22:46.921 --> 00:22:48.510
longer has persistence.

00:22:48.510 --> 00:22:53.560
And so the attacker just
isn't able to get control

00:22:53.560 --> 00:22:56.330
of the device across reboots, or
it's much, much more difficult.

00:22:56.330 --> 00:22:58.030
So indirectly, you could say
it increases attack costs.

00:22:58.030 --> 00:22:59.860
Because if persistence
is what they need,

00:22:59.860 --> 00:23:03.790
they've got to work a lot, lot
harder to get it in this case.

00:23:03.790 --> 00:23:06.910
And again, Google's doing the
heavy lifting for the signing.

00:23:06.910 --> 00:23:08.472
So security costs go down.

00:23:08.472 --> 00:23:10.930
And so doing the heavy lifting
on both sides of the device,

00:23:10.930 --> 00:23:13.784
really, doing the signing
on the infrastructure

00:23:13.784 --> 00:23:15.700
and also doing the
verification on the device.

00:23:19.324 --> 00:23:21.540
The next feature is
hardware-backed cryptographic

00:23:21.540 --> 00:23:22.040
keys.

00:23:22.040 --> 00:23:25.680
And we're supporting this
on every Android Things SoM.

00:23:25.680 --> 00:23:28.770
So this really works the same
way as it does on Android.

00:23:28.770 --> 00:23:31.020
It's the same key master
hardware abstraction

00:23:31.020 --> 00:23:34.210
layer under the
hood for developers

00:23:34.210 --> 00:23:35.460
when you're building your app.

00:23:35.460 --> 00:23:40.020
It's the same keystore APIs
that you could use on Android.

00:23:40.020 --> 00:23:42.399
And really, it all
works the same.

00:23:42.399 --> 00:23:44.190
There's one thing that
I wanted to mention,

00:23:44.190 --> 00:23:46.980
is that is that we're not
doing full disk encryption.

00:23:46.980 --> 00:23:50.617
We're not expecting Android
Things devices to support that.

00:23:50.617 --> 00:23:52.950
And the reason is is because
we're not expecting devices

00:23:52.950 --> 00:23:53.790
to be attended.

00:23:53.790 --> 00:23:55.670
We're expecting them
to run unattended.

00:23:55.670 --> 00:23:59.610
And they're expecting them
to reboot automatically

00:23:59.610 --> 00:24:00.990
as part of these updates.

00:24:00.990 --> 00:24:02.854
And if you do full
disk encryption,

00:24:02.854 --> 00:24:04.770
and you don't do some
kind of pin or password,

00:24:04.770 --> 00:24:06.945
or some kind of credential
when you boot the device,

00:24:06.945 --> 00:24:09.320
you really lose almost all of
the value of that full disk

00:24:09.320 --> 00:24:10.230
encryption.

00:24:10.230 --> 00:24:15.837
And we don't want to support
a feature when we really

00:24:15.837 --> 00:24:16.920
can't get a lot out of it.

00:24:19.409 --> 00:24:21.450
But instead, if you feel
you have sensitive data,

00:24:21.450 --> 00:24:23.825
you do want to encrypt it when
you store it to the flash,

00:24:23.825 --> 00:24:25.670
you can just take a
hardware-backed key,

00:24:25.670 --> 00:24:28.170
encrypt it using
the keystore APIs,

00:24:28.170 --> 00:24:30.770
and you get not
a similar effect,

00:24:30.770 --> 00:24:31.770
you get a better effect.

00:24:31.770 --> 00:24:33.603
Because that key is
actually also associated

00:24:33.603 --> 00:24:35.044
with that particular
application.

00:24:40.370 --> 00:24:42.430
So for developers,
all you need to do

00:24:42.430 --> 00:24:45.830
is use that Android
keystore type provider.

00:24:45.830 --> 00:24:51.010
I put a link in to the existing
article on how to use keystore,

00:24:51.010 --> 00:24:52.980
if you haven't done that.

00:24:52.980 --> 00:24:54.730
But all the documentation
is already there

00:24:54.730 --> 00:24:58.817
on developer.android.com.

00:24:58.817 --> 00:25:01.150
Again, hardware-backed keys
lowers return on investment.

00:25:01.150 --> 00:25:02.608
It takes something
that's valuable,

00:25:02.608 --> 00:25:05.140
these cryptographic keys,
and it moves it somewhere

00:25:05.140 --> 00:25:07.960
where it's even more protected
and puts additional barriers

00:25:07.960 --> 00:25:09.100
in front of it--

00:25:09.100 --> 00:25:11.260
hardware-controlled barriers.

00:25:11.260 --> 00:25:14.860
And again, because
Google and our partners

00:25:14.860 --> 00:25:16.819
are supporting this
in all the devices,

00:25:16.819 --> 00:25:18.610
the security cost goes
down for developers.

00:25:18.610 --> 00:25:21.442
They can just call the APIs and
rest assured that everything

00:25:21.442 --> 00:25:22.150
is going to work.

00:25:26.700 --> 00:25:32.580
The last feature I want to
talk about is attestation.

00:25:32.580 --> 00:25:35.770
Attestation is a bit like
authentication for devices.

00:25:35.770 --> 00:25:38.030
A human might authenticate
with a password,

00:25:38.030 --> 00:25:41.650
with something they know,
or with a biometric--

00:25:41.650 --> 00:25:44.270
something that is part of them.

00:25:44.270 --> 00:25:46.490
But devices authenticate
with something

00:25:46.490 --> 00:25:48.680
that was given to them
in the factory, something

00:25:48.680 --> 00:25:53.170
where they can prove that they
are authentic in some way.

00:25:53.170 --> 00:25:55.850
And that sort of
cryptographic proof is--

00:25:55.850 --> 00:25:59.730
we call it an attestation.

00:25:59.730 --> 00:26:01.470
So for Android Things
we're supporting

00:26:01.470 --> 00:26:04.500
this for any devices.

00:26:04.500 --> 00:26:05.457
It will be optional.

00:26:05.457 --> 00:26:07.540
You don't have to key your
devices in the factory.

00:26:07.540 --> 00:26:11.010
But we will support it for
everyone that wants to.

00:26:11.010 --> 00:26:14.460
And a device will be able to
attest that they are authentic

00:26:14.460 --> 00:26:17.100
Android Things device,
be able to attest

00:26:17.100 --> 00:26:19.170
that they're an
authentic instance

00:26:19.170 --> 00:26:20.315
of a particular product.

00:26:20.315 --> 00:26:23.120
So this is bound to
that same product ID

00:26:23.120 --> 00:26:26.340
that your Verified Boot
system boots up with.

00:26:26.340 --> 00:26:29.050
So those are tied together.

00:26:29.050 --> 00:26:30.570
It can attest to
a device identity.

00:26:30.570 --> 00:26:32.790
So it can prove that
it's a particular device.

00:26:32.790 --> 00:26:34.980
And so if the system is
integrating with a device

00:26:34.980 --> 00:26:36.240
and they see that
same device twice,

00:26:36.240 --> 00:26:37.615
they know that's
the same device.

00:26:37.615 --> 00:26:40.760
It can attest to its identity.

00:26:40.760 --> 00:26:43.000
It can also attest to its state.

00:26:43.000 --> 00:26:44.860
So in particular, the
Verified Boot state

00:26:44.860 --> 00:26:46.462
is interesting,
where it can actually

00:26:46.462 --> 00:26:48.670
give a cryptographic statement
that the Verified Boot

00:26:48.670 --> 00:26:49.930
system is engaged.

00:26:49.930 --> 00:26:51.760
And potentially, like the
Verified Boot hash I mentioned,

00:26:51.760 --> 00:26:53.710
it can give a cryptographic
statement of the exact code

00:26:53.710 --> 00:26:55.709
that it booted with the
last time it was booted.

00:26:58.210 --> 00:27:00.170
Attestation's also tied
to cryptographic keys.

00:27:00.170 --> 00:27:04.190
So effectively, the statement
is that this particular key

00:27:04.190 --> 00:27:07.960
is protected by hardware
that has these attributes.

00:27:07.960 --> 00:27:09.210
It's that kind of a statement.

00:27:09.210 --> 00:27:11.810
So you can also make
statements about that key,

00:27:11.810 --> 00:27:14.665
statements like, and this
key expires in 48 hours,

00:27:14.665 --> 00:27:16.040
or this key is
only allowed to be

00:27:16.040 --> 00:27:19.230
used in these particular signing
modes, and things like that.

00:27:19.230 --> 00:27:21.480
So you can attest to those
kind of attributes as well.

00:27:25.810 --> 00:27:27.720
For the attestation,
certificate authority's

00:27:27.720 --> 00:27:29.020
going to be operated by Google.

00:27:29.020 --> 00:27:30.686
Again, Google's doing
the heavy lifting,

00:27:30.686 --> 00:27:34.810
doing the key management,
issuing key bundles

00:27:34.810 --> 00:27:40.384
for products, and Google's
providing that authority.

00:27:44.740 --> 00:27:46.335
Just doing the
factory provisioning

00:27:46.335 --> 00:27:48.460
though of these credentials
can be a real challenge

00:27:48.460 --> 00:27:49.610
in and of itself.

00:27:49.610 --> 00:27:52.090
And we also want to help there.

00:27:52.090 --> 00:27:54.580
So we're going to be
providing a factory appliance.

00:27:54.580 --> 00:27:58.180
And this will help
get keys safely

00:27:58.180 --> 00:28:01.810
from Google to your
factory partner

00:28:01.810 --> 00:28:04.090
and safely into the
device and really

00:28:04.090 --> 00:28:06.070
help with the management
of those keys,

00:28:06.070 --> 00:28:11.210
the auditing of that
process, and all of that.

00:28:11.210 --> 00:28:14.980
So the basic flow would
look like, if you're already

00:28:14.980 --> 00:28:16.510
working with a
factory partner who

00:28:16.510 --> 00:28:19.690
has one of these appliances,
you would get the identifier

00:28:19.690 --> 00:28:20.710
for that appliance.

00:28:20.710 --> 00:28:22.085
You go to your
Developer Console.

00:28:22.085 --> 00:28:24.610
You say, I want a key bundle
for this particular product.

00:28:24.610 --> 00:28:27.240
You would have to enter
that appliance ID.

00:28:27.240 --> 00:28:28.960
You would download that bundle.

00:28:28.960 --> 00:28:30.418
And that bundle
would be encrypted.

00:28:30.418 --> 00:28:33.437
And it can only be decrypted
by that particular appliance

00:28:33.437 --> 00:28:34.270
that you identified.

00:28:34.270 --> 00:28:37.090
And so then you send that bundle
off to your factory partner.

00:28:37.090 --> 00:28:39.423
And they know how to take it
take care of it from there.

00:28:42.798 --> 00:28:45.910
So again, I mentioned
it was optional.

00:28:45.910 --> 00:28:46.480
And it is.

00:28:46.480 --> 00:28:48.188
But there is going to
be some cases where

00:28:48.188 --> 00:28:51.910
if you're integrating
with certain applications,

00:28:51.910 --> 00:28:55.030
if you're integrating with
Cash or with Assistant,

00:28:55.030 --> 00:28:58.240
those keys are going
to be mandatory,

00:28:58.240 --> 00:29:00.650
just because you need to
work in that ecosystem.

00:29:06.200 --> 00:29:08.330
The last thing that
we're supporting

00:29:08.330 --> 00:29:10.345
is anonymous attestation.

00:29:12.919 --> 00:29:15.210
I don't know if anyone's
familiar with direct anonymous

00:29:15.210 --> 00:29:16.290
attestation.

00:29:16.290 --> 00:29:18.420
It's a cryptographic
mechanism that

00:29:18.420 --> 00:29:20.400
is a little bit like
asymmetric cryptography,

00:29:20.400 --> 00:29:22.350
if you're familiar with
that, where you have

00:29:22.350 --> 00:29:23.890
a public and a private key.

00:29:23.890 --> 00:29:25.680
But in this case,
you have a public key

00:29:25.680 --> 00:29:28.560
and you have a set
of private keys.

00:29:28.560 --> 00:29:30.530
And they're all bound
to that same public key.

00:29:30.530 --> 00:29:32.880
And so what happens is when
you verify a signature,

00:29:32.880 --> 00:29:36.570
there's no way to tell
which private key it was.

00:29:36.570 --> 00:29:39.390
So you get this attestation
of group membership.

00:29:39.390 --> 00:29:42.464
You don't get a side
effect of identity.

00:29:42.464 --> 00:29:44.130
And sometimes this
can work really well.

00:29:44.130 --> 00:29:47.110
If you need to do some
kind of attestation

00:29:47.110 --> 00:29:50.740
in an ecosystem, where they
don't need the exact identity,

00:29:50.740 --> 00:29:55.114
then it's nice not to pass that
along when it's not needed.

00:29:55.114 --> 00:29:56.780
And you can do an
anonymous attestation.

00:29:56.780 --> 00:29:59.310
And so this will be really
good in some cases, where

00:29:59.310 --> 00:30:01.350
you want to keep that privacy.

00:30:01.350 --> 00:30:03.690
But there's also cases where
you want that identity.

00:30:03.690 --> 00:30:06.750
For example, if you're
a large enterprise,

00:30:06.750 --> 00:30:09.602
you're managing a large
fleet of IoT devices,

00:30:09.602 --> 00:30:10.560
you're monitoring them.

00:30:10.560 --> 00:30:12.518
You want to know exactly
which device is which.

00:30:12.518 --> 00:30:16.240
And you want that attestation
of identity, if you can get it.

00:30:16.240 --> 00:30:18.600
And so we want to
support that flexibility,

00:30:18.600 --> 00:30:21.362
and so we're supporting
both mechanisms.

00:30:24.600 --> 00:30:25.906
I put a little bit of code up.

00:30:25.906 --> 00:30:27.280
I don't know if
anyone's actually

00:30:27.280 --> 00:30:32.309
ever coded with this
kind of thing in Android.

00:30:32.309 --> 00:30:33.850
There's basically
one method that you

00:30:33.850 --> 00:30:37.780
need to put in your
key pair generator.

00:30:37.780 --> 00:30:39.940
All of this slide is
pretty standard code,

00:30:39.940 --> 00:30:43.450
except for that set attestation
challenge method in the middle.

00:30:43.450 --> 00:30:46.120
And that's what
really tells a system

00:30:46.120 --> 00:30:49.300
you want an attestation
certificate chain for this key.

00:30:49.300 --> 00:30:52.390
And it'll issue one, if you
give it a non-null attestation

00:30:52.390 --> 00:30:53.320
challenge.

00:30:53.320 --> 00:30:55.990
So that challenge
value can be anything.

00:30:55.990 --> 00:30:59.080
Here I just have an
empty byte array.

00:30:59.080 --> 00:31:02.600
But this challenge value
will go into the certificate.

00:31:02.600 --> 00:31:06.880
So if you want to bind it with
some other system that you want

00:31:06.880 --> 00:31:10.270
integrate with , there could be
something really valuable that

00:31:10.270 --> 00:31:11.770
you can put into
that challenge--

00:31:11.770 --> 00:31:15.790
valuable as a binding token.

00:31:15.790 --> 00:31:18.070
And then at the end, when
you get the certificate

00:31:18.070 --> 00:31:20.420
chain for that key, that's
going to be full certificate

00:31:20.420 --> 00:31:22.630
chain that'll root up to
the Google attestation CA.

00:31:30.184 --> 00:31:32.350
There's one more thing I
wanted to remind developers

00:31:32.350 --> 00:31:33.790
to do when they're
working with attestation,

00:31:33.790 --> 00:31:35.180
and that is to use the key.

00:31:35.180 --> 00:31:38.610
There can be a temptation
to generate this key,

00:31:38.610 --> 00:31:42.280
get the certificate chain, and
then just validate that chain,

00:31:42.280 --> 00:31:44.410
or send that certificate
off to someone,

00:31:44.410 --> 00:31:46.210
and get them to validate it.

00:31:46.210 --> 00:31:48.370
But the real value comes
in when you actually

00:31:48.370 --> 00:31:51.285
use that key, when you use it
say, in a TLS client author,

00:31:51.285 --> 00:31:52.660
or use it to
connect to your VPN,

00:31:52.660 --> 00:31:56.800
or use it to engage in
some other protocol.

00:31:56.800 --> 00:31:59.350
That's what you get the real
value out of the attestation.

00:31:59.350 --> 00:32:00.641
So don't forget to use the key.

00:32:04.734 --> 00:32:06.150
So attestation
doesn't really make

00:32:06.150 --> 00:32:08.124
it harder to attack a device.

00:32:08.124 --> 00:32:09.540
It has more to do
with how devices

00:32:09.540 --> 00:32:11.790
interact with each
other and with the cloud

00:32:11.790 --> 00:32:14.250
or with other services.

00:32:14.250 --> 00:32:17.130
And again, it's really
just cost driven down,

00:32:17.130 --> 00:32:19.370
because Google is doing a
lot of this heavy lifting.

00:32:25.900 --> 00:32:27.452
So a quick summary--

00:32:27.452 --> 00:32:29.814
security is built in.

00:32:29.814 --> 00:32:31.605
And we're taking care
of the infrastructure

00:32:31.605 --> 00:32:34.166
and we're doing the heavy
lifting on OS hardening,

00:32:34.166 --> 00:32:35.790
heavy lifting on
updates, heavy lifting

00:32:35.790 --> 00:32:38.430
on Verified Boot,
hardware-backed keys,

00:32:38.430 --> 00:32:39.810
and attestation.

00:32:45.100 --> 00:32:48.500
So that's all I
have for you today.

00:32:48.500 --> 00:32:51.211
I want feedback so please
come and talk to me.

00:32:51.211 --> 00:32:53.710
I'm going to be in the office
hours, which is today at 1:30,

00:32:53.710 --> 00:32:56.200
in the office hours tent.

00:32:56.200 --> 00:33:01.515
And check out our Google+
community, g.ceo/iotdev.

00:33:01.515 --> 00:33:03.640
And if you want to go
started with Android Things--

00:33:03.640 --> 00:33:08.110
developer.android.com/things
is the right place to go.

00:33:08.110 --> 00:33:11.460
[MUSIC PLAYING]

