WEBVTT
Kind: captions
Language: en

00:00:00.376 --> 00:00:24.410
[SIDE CONVERSATION]

00:00:24.410 --> 00:02:58.416
[MUSIC PLAYING]

00:03:06.899 --> 00:03:07.710
CARY CLARK: Hi.

00:03:07.710 --> 00:03:11.280
My name is Cary Clark, and I'm
a member of the Skia team.

00:03:11.280 --> 00:03:14.400
Skia provides the graphics
for Android, the Android

00:03:14.400 --> 00:03:17.720
framework, and for Chrome.

00:03:17.720 --> 00:03:21.880
Skia draws the rectangles, the
bitmaps, the text, and paths.

00:03:21.880 --> 00:03:24.290
That's what I'm going
to talk about today,

00:03:24.290 --> 00:03:28.520
paths and path ops.

00:03:28.520 --> 00:03:34.220
I started working at Apple a
long time ago, and at that

00:03:34.220 --> 00:03:39.510
time, the Apple II really
started my love of graphics.

00:03:39.510 --> 00:03:43.430
The Apple II had a high
resolution bitmap with a 280

00:03:43.430 --> 00:03:45.520
by 192 screen--

00:03:45.520 --> 00:03:47.210
it had a pair of
them, actually.

00:03:47.210 --> 00:03:50.440
And with that, the world
was my oyster.

00:03:50.440 --> 00:03:51.820
I could draw anything I wanted,

00:03:51.820 --> 00:03:54.260
and it was just amazing.

00:03:54.260 --> 00:03:56.370
Unfortunately, the Apple II
didn't really have any

00:03:56.370 --> 00:04:00.820
built-in graphics routines
at that time.

00:04:00.820 --> 00:04:04.290
Sometime later, when I was
introduced to the Lisa and the

00:04:04.290 --> 00:04:08.190
Macintosh computers, I learned
about QuickDraw, and QuickDraw

00:04:08.190 --> 00:04:12.290
is the software on a Macintosh,
on the original

00:04:12.290 --> 00:04:15.820
Macintosh, that drew
to the screen.

00:04:15.820 --> 00:04:19.970
QuickDraw had arcs, and that was
my first introduction into

00:04:19.970 --> 00:04:24.030
a computer that had a curved
primitive, a circular arc.

00:04:26.530 --> 00:04:29.750
A little while later, the
Macintosh had the LaserWriter,

00:04:29.750 --> 00:04:32.670
which was a PostScript
printer.

00:04:32.670 --> 00:04:35.100
PostScript had a whole new class
of curves called cubic

00:04:35.100 --> 00:04:39.200
beziers, which were pretty
exotic, but they looked great,

00:04:39.200 --> 00:04:41.900
especially when they
were scaled up.

00:04:41.900 --> 00:04:46.070
And it was pretty mind-blowing
how well PostScript could take

00:04:46.070 --> 00:04:49.270
a document and rotate it
or skew it or scale it.

00:04:53.070 --> 00:04:57.065
In 1988, TrueType, and a little
before that, QuickDraw

00:04:57.065 --> 00:04:58.470
GX came out.

00:04:58.470 --> 00:05:01.750
I was fortunate enough to
work on QuickDraw GX.

00:05:01.750 --> 00:05:06.980
And at that time, I decided to
add quadratics to QuickDraw

00:05:06.980 --> 00:05:10.000
instead of cubics or arcs.

00:05:10.000 --> 00:05:13.080
The quadratic is a little bit
simpler than a cube-- it has

00:05:13.080 --> 00:05:16.580
one less control point, but
it has a lot of the same

00:05:16.580 --> 00:05:21.010
properties, and I was happy
that TrueType also chose

00:05:21.010 --> 00:05:24.400
quadratics and allowed me to
have some validation that my

00:05:24.400 --> 00:05:25.650
choice was a good one.

00:05:28.390 --> 00:05:30.100
Skia has all of these types.

00:05:30.100 --> 00:05:33.290
It has arcs, it has cubics,
quadratics, and now it has

00:05:33.290 --> 00:05:37.390
conics, which are sections
of a cone, which include

00:05:37.390 --> 00:05:39.200
quadratics.

00:05:39.200 --> 00:05:42.890
And a path op is a way to take
all of these curves and

00:05:42.890 --> 00:05:44.510
operate on them with
set operations.

00:05:48.000 --> 00:05:51.440
When QuickDraw was introduced
back in the '80s, it had a way

00:05:51.440 --> 00:05:53.800
of describing an area of the
screen that was called a

00:05:53.800 --> 00:05:57.260
region, and it was just a
collection of rectangles, but

00:05:57.260 --> 00:06:00.040
it was the basis for the
Macintosh windows and the

00:06:00.040 --> 00:06:02.200
windowing system.

00:06:02.200 --> 00:06:06.440
A little while later with
PostScript and QuickDraw GX

00:06:06.440 --> 00:06:11.040
and so forth, paths were
introduced, and paths, like

00:06:11.040 --> 00:06:13.220
regions, describe an
area of the screen.

00:06:13.220 --> 00:06:18.580
But that area can include
circles and triangles, and

00:06:18.580 --> 00:06:21.000
it's a control point
based area.

00:06:21.000 --> 00:06:23.850
So instead of a set of
rectangles, it's something

00:06:23.850 --> 00:06:26.935
that can have arbitrary curves
and arbitrary lines.

00:06:29.840 --> 00:06:34.270
QuickDraw used its
rectangle-based path, its

00:06:34.270 --> 00:06:37.680
region, to build a
windowing system.

00:06:37.680 --> 00:06:41.320
And the windowing system allowed
QuickDraw to draw to

00:06:41.320 --> 00:06:43.810
just the part of the window
that was visible.

00:06:43.810 --> 00:06:48.920
The way it did this is it had
operations called region ops

00:06:48.920 --> 00:06:51.710
that could do things like
intersect a pair of regions or

00:06:51.710 --> 00:06:54.350
take the difference of
one from the other.

00:06:54.350 --> 00:06:57.940
This was a very powerful concept
that Bill Atkinson,

00:06:57.940 --> 00:07:01.850
the author of QuickDraw,
invented.

00:07:01.850 --> 00:07:04.690
I liked it so much that I wanted
to do the same thing

00:07:04.690 --> 00:07:06.000
for QuickDraw GX.

00:07:06.000 --> 00:07:09.390
But instead of just making it
work for rectangles, I wanted

00:07:09.390 --> 00:07:12.850
it to work for any arbitrary
geometry and be able to rotate

00:07:12.850 --> 00:07:16.040
or skew a path and
operate on it.

00:07:20.080 --> 00:07:23.490
With ordinary paths-- say,
a pair of ovals--

00:07:23.490 --> 00:07:26.420
it's very difficult to translate
those ovals from one

00:07:26.420 --> 00:07:28.230
graphic system to another.

00:07:28.230 --> 00:07:30.840
For instance, Skia can describe
a path with a pair of

00:07:30.840 --> 00:07:34.350
ovals, but to do a hardware
acceleration and translate

00:07:34.350 --> 00:07:39.080
those ovals to something like
OpenGL, it's difficult,

00:07:39.080 --> 00:07:42.160
because OpenGL doesn't have a
primitive that will describe

00:07:42.160 --> 00:07:44.550
those curves.

00:07:44.550 --> 00:07:49.480
Worse, if each oval individually
is sent to

00:07:49.480 --> 00:07:54.180
OpenGL, the pair of curves may
not blend together well.

00:07:54.180 --> 00:07:57.310
If either one has transparency,
then you'll see

00:07:57.310 --> 00:08:00.060
the transparent addition of the
two rather than just the

00:08:00.060 --> 00:08:02.620
area that the two describe.

00:08:02.620 --> 00:08:08.290
That's why OpenGL systems often
create stencil buffers

00:08:08.290 --> 00:08:11.655
that have the bitmap that
describes, in this case, a

00:08:11.655 --> 00:08:15.480
pair of ovals and uploads that
rather than uploading the

00:08:15.480 --> 00:08:17.070
geometry of those
pair of ovals.

00:08:20.920 --> 00:08:25.850
The Blink portion of Chrome that
reads into the HTML web

00:08:25.850 --> 00:08:29.580
page can create some very
complicated geometries.

00:08:29.580 --> 00:08:35.240
CSS allows defining different
gradients for different parts

00:08:35.240 --> 00:08:37.360
of a rounded rectangle,
for instance.

00:08:37.360 --> 00:08:39.200
So the clip might look
something like this

00:08:39.200 --> 00:08:40.659
illustration.

00:08:40.659 --> 00:08:44.770
That clip is only the portion
of the gray--

00:08:44.770 --> 00:08:47.110
is the only portion that's
actually drawn.

00:08:47.110 --> 00:08:51.960
But the clip contains all the
other shapes as well.

00:08:51.960 --> 00:08:55.180
It's difficult to do an
acceleration of just the

00:08:55.180 --> 00:08:58.290
portion that's being drawn when
all the other geometries

00:08:58.290 --> 00:08:59.590
are present in the clip stack.

00:09:03.610 --> 00:09:09.360
Blink also allows drawing the
difference of a shape.

00:09:09.360 --> 00:09:16.410
So when going from Skia to PDF,
for instance, we have to

00:09:16.410 --> 00:09:21.280
draw the PDF data into an
off-screen bitmap and render

00:09:21.280 --> 00:09:24.580
that instead of being able to
calculate the geometry that

00:09:24.580 --> 00:09:27.420
would result from subtracting
a rectangle

00:09:27.420 --> 00:09:28.670
from another rectangle.

00:09:31.290 --> 00:09:34.950
Shape ops tries to address
this need.

00:09:34.950 --> 00:09:38.750
Here, this simplify operation
takes a pair of blue

00:09:38.750 --> 00:09:43.850
rectangles and will compute
the area that would result

00:09:43.850 --> 00:09:46.150
from drawing both of them.

00:09:46.150 --> 00:09:47.970
This is the simplest path op.

00:09:51.018 --> 00:09:56.270
Path ops also have binary
operations to compare paths.

00:09:56.270 --> 00:09:58.920
So in this case, we're computing
the intersection of

00:09:58.920 --> 00:10:01.610
a pair of rectangles from
two separate rectangles.

00:10:05.181 --> 00:10:09.200
The union operator looks a lot
like the simplify operator.

00:10:09.200 --> 00:10:13.080
It uses two paths, each with a
single contour, instead of one

00:10:13.080 --> 00:10:14.760
path with two contours.

00:10:14.760 --> 00:10:20.090
A contour is a closed portion
of a path, so it's a

00:10:20.090 --> 00:10:21.450
continuous closed loop.

00:10:24.020 --> 00:10:25.850
There's a pair of difference
operators.

00:10:25.850 --> 00:10:28.900
This difference operator
subtracts the dark green

00:10:28.900 --> 00:10:30.170
rectangle from the blue one.

00:10:30.170 --> 00:10:33.800
There's a reverse difference
that would subtract the blue

00:10:33.800 --> 00:10:35.070
rectangle from the
dark green one.

00:10:37.750 --> 00:10:40.300
For completeness, there's also
exclusive or, although this

00:10:40.300 --> 00:10:41.550
one isn't used very much.

00:10:44.990 --> 00:10:47.600
And finally, there's complement,
which describes

00:10:47.600 --> 00:10:51.550
all of the area that's
outside of a path.

00:10:51.550 --> 00:10:53.890
As it turns out, there's
no special function for

00:10:53.890 --> 00:10:59.610
complement because Skia's paths
have a way of describing

00:10:59.610 --> 00:11:02.190
whether it's the fill
or the inverse fill.

00:11:02.190 --> 00:11:05.635
So the complement is just
toggling those two attributes.

00:11:09.490 --> 00:11:12.430
There's no reason to implement
all of these path ops as

00:11:12.430 --> 00:11:14.600
separate functions since
they're really

00:11:14.600 --> 00:11:16.590
all the same thing.

00:11:16.590 --> 00:11:21.860
In this illustration, we have
the paths A and B and their

00:11:21.860 --> 00:11:25.830
complements running down the
column on the left and

00:11:25.830 --> 00:11:28.900
different path operations
running in the

00:11:28.900 --> 00:11:30.800
row across the top.

00:11:30.800 --> 00:11:34.780
So you can see that the
intersection of A and B is the

00:11:34.780 --> 00:11:41.610
same as the difference of A
complement B, or the exclusive

00:11:41.610 --> 00:11:46.590
or of A and B is the same as the
union of A minus B and B

00:11:46.590 --> 00:11:52.770
minus A is also the difference
between the

00:11:52.770 --> 00:11:54.020
intersection and the union.

00:11:57.900 --> 00:11:59.820
So what's all this good for?

00:11:59.820 --> 00:12:02.540
Back when fonts were originally
ported to

00:12:02.540 --> 00:12:06.600
computers, a lot of times the
complex characters were

00:12:06.600 --> 00:12:09.600
created by drawing individual
characters on top of each

00:12:09.600 --> 00:12:14.040
other, like a slash on top of
the letter O. If you drew the

00:12:14.040 --> 00:12:16.110
outline of those characters,
you'd get an undesirable

00:12:16.110 --> 00:12:19.780
result as shown here because you
would see both outlines at

00:12:19.780 --> 00:12:24.280
the same time where you'd really
like to see only the

00:12:24.280 --> 00:12:28.650
portion described by the area
of the two characters.

00:12:28.650 --> 00:12:32.420
So the question is how do we
get from there to here?

00:12:32.420 --> 00:12:36.280
When I first wrote this in the
'80s, my approach was very

00:12:36.280 --> 00:12:38.670
similar to the way I drew
these characters.

00:12:38.670 --> 00:12:40.120
I would start by finding
the maxima and

00:12:40.120 --> 00:12:43.510
minima of the curves.

00:12:43.510 --> 00:12:46.620
Once they were split, I would
then find all the vertical

00:12:46.620 --> 00:12:50.100
occurrences where either a new
curve started, a new curve

00:12:50.100 --> 00:12:53.210
stopped, or a pair of
intersections occurred.

00:12:56.930 --> 00:12:59.750
Given all those vertical events,
I would sort them and

00:12:59.750 --> 00:13:02.990
then walk across them
horizontally and find every

00:13:02.990 --> 00:13:05.830
place where one of the
curves intersected

00:13:05.830 --> 00:13:07.490
that horizontal line.

00:13:07.490 --> 00:13:09.200
Then I would have to
sort those as well.

00:13:12.300 --> 00:13:16.220
Finally, if a pair of curves or
a line and a curve had the

00:13:16.220 --> 00:13:22.060
same y value for some given x
value, I had to sort those to

00:13:22.060 --> 00:13:24.090
know which one would
contribute to

00:13:24.090 --> 00:13:25.340
the final path first.

00:13:28.300 --> 00:13:31.680
All of the sorting is required
because of something called

00:13:31.680 --> 00:13:33.060
the winding number rule.

00:13:33.060 --> 00:13:36.370
And the winding number rule says
that the direction of the

00:13:36.370 --> 00:13:41.670
path describes whether it
contributes or subtracts from

00:13:41.670 --> 00:13:43.190
the output.

00:13:43.190 --> 00:13:47.670
So in this case, the down arrows
contribute a plus 1 to

00:13:47.670 --> 00:13:50.030
the answer and the up
arrows contribute a

00:13:50.030 --> 00:13:53.250
minus 1 to the answer.

00:13:53.250 --> 00:13:55.910
If I sum those numbers as I
move across from left to

00:13:55.910 --> 00:13:59.900
right, every time that a 0
changes to a 1 or a 1 changes

00:13:59.900 --> 00:14:03.240
to a 0, that's a line
that I keep.

00:14:03.240 --> 00:14:06.160
If it changes from one positive
number to another,

00:14:06.160 --> 00:14:08.550
those are lines I discard.

00:14:08.550 --> 00:14:11.000
That will give me the desired
output that I want.

00:14:14.470 --> 00:14:17.470
This time around, it occurred
to me that all that sorting

00:14:17.470 --> 00:14:20.190
was a lot of work and took a
lot of time, and there was

00:14:20.190 --> 00:14:21.830
probably a simpler approach.

00:14:21.830 --> 00:14:24.290
In fact, there are really only
eight intersection points

00:14:24.290 --> 00:14:27.220
between these pairs of curves
and lines that I

00:14:27.220 --> 00:14:29.020
actually care about.

00:14:29.020 --> 00:14:31.600
All the other sorting
information is superfluous to

00:14:31.600 --> 00:14:32.850
the real answer.

00:14:34.950 --> 00:14:38.220
If I look at any one of those
intersections, instead of

00:14:38.220 --> 00:14:41.030
thinking about how the y-number
is affected as I

00:14:41.030 --> 00:14:44.530
traverse across the entire shape
from left to right, I

00:14:44.530 --> 00:14:47.420
can think about what the winding
number contribution is

00:14:47.420 --> 00:14:52.050
at that intersection point as
I move around in a circle.

00:14:52.050 --> 00:14:57.620
If I know what the intersection
is as each curve

00:14:57.620 --> 00:15:02.116
contributes to the answer, once
again, when 0 moves to 1

00:15:02.116 --> 00:15:05.350
or 1 moves to 0, those
are lines I keep.

00:15:05.350 --> 00:15:07.730
But when it goes from one
positive number to the next,

00:15:07.730 --> 00:15:08.980
those are lines I discard.

00:15:12.790 --> 00:15:16.600
The great benefit of this is
once I have one answer, that

00:15:16.600 --> 00:15:19.740
answer propagates around the
rest of the curve so I don't

00:15:19.740 --> 00:15:24.400
need to keep computing the
inside or outsideness of the

00:15:24.400 --> 00:15:27.640
shape, and I can keep all of
the information all the way

00:15:27.640 --> 00:15:29.535
around to the point I run into
another intersection.

00:15:33.530 --> 00:15:36.240
But before I can get there, I
have to be able to find the

00:15:36.240 --> 00:15:38.720
intersections.

00:15:38.720 --> 00:15:41.110
So let's take a look at one
of the curve types.

00:15:41.110 --> 00:15:44.350
This is a quadratic bezier
defined by a couple of control

00:15:44.350 --> 00:15:49.820
points on the ends and one
control point in the middle.

00:15:49.820 --> 00:15:54.670
The quadratic bezier is parallel
to the end points.

00:15:54.670 --> 00:15:57.580
The tangents of the quadratic
bezier from the first to the

00:15:57.580 --> 00:16:00.225
second point define how
the curve groups.

00:16:03.200 --> 00:16:06.550
A pair of quadratic beziers
are portions of a pair of

00:16:06.550 --> 00:16:08.630
parabolas, so they can
intersect in as

00:16:08.630 --> 00:16:11.960
many as four points.

00:16:11.960 --> 00:16:14.180
So that's a clue as to what the
answer's going to be to

00:16:14.180 --> 00:16:16.560
find the intersection of
a pair of quadratics.

00:16:16.560 --> 00:16:19.360
I'll need to be able to find
at least four solutions.

00:16:19.360 --> 00:16:21.920
So if there is a solution, it's
going to have to be able

00:16:21.920 --> 00:16:23.170
to find four roots.

00:16:26.500 --> 00:16:28.830
Back in the original
illustration, I mentioned that

00:16:28.830 --> 00:16:32.640
I have to divide the curves
into a pair--

00:16:32.640 --> 00:16:35.960
I had to divide the curves at a
maxima and a minima before I

00:16:35.960 --> 00:16:37.790
could proceed.

00:16:37.790 --> 00:16:40.570
This is because everything
was sorted in y.

00:16:40.570 --> 00:16:43.810
The first time I did this, I
thought that also meant that

00:16:43.810 --> 00:16:46.690
it simplified the solution
for the intersection

00:16:46.690 --> 00:16:48.320
of a pair of curves.

00:16:48.320 --> 00:16:51.440
I thought if there are four
intersections for a pair of

00:16:51.440 --> 00:16:54.560
parabolas, surely there are
only two intersections if

00:16:54.560 --> 00:16:58.990
they're subdivided so they
only increase in y.

00:16:58.990 --> 00:17:00.430
I was wrong.

00:17:00.430 --> 00:17:03.280
There are three intersections
for monotonically increasing

00:17:03.280 --> 00:17:06.540
curves, and this was quite
embarrassing when I figured it

00:17:06.540 --> 00:17:09.420
out for the first time
back in the '80s.

00:17:09.420 --> 00:17:11.980
So this time around, I decided
to be much more careful about

00:17:11.980 --> 00:17:15.260
the mathematics and the geometry
so I wouldn't fall

00:17:15.260 --> 00:17:16.770
into the same sort
of mistake again.

00:17:20.619 --> 00:17:25.220
So let's take a look at
intersecting a pair of curves.

00:17:25.220 --> 00:17:28.650
For these curves, I want to find
the intersection and I

00:17:28.650 --> 00:17:33.200
want to do so by creating the
mathematics that will solve

00:17:33.200 --> 00:17:35.600
the answer directly.

00:17:35.600 --> 00:17:37.640
Another approach would be to
subdivide the curves, but

00:17:37.640 --> 00:17:38.980
we'll talk about that
in just a moment.

00:17:42.750 --> 00:17:46.470
If I look at what the solution
is without looking at how I'm

00:17:46.470 --> 00:17:49.030
going to get there, I can
imagine that there's a value

00:17:49.030 --> 00:17:55.010
called t which varies
from 0 to 1 as I

00:17:55.010 --> 00:17:56.260
traverse across the curve.

00:17:59.830 --> 00:18:03.610
When t is equal to 0,
it's going to be at

00:18:03.610 --> 00:18:05.470
the C0 and C0 prime.

00:18:05.470 --> 00:18:08.085
When t is at 1, it's
going to be at C2.

00:18:08.085 --> 00:18:10.940
And anywhere in between, it's
going to describe a point

00:18:10.940 --> 00:18:13.340
along the curve.

00:18:13.340 --> 00:18:18.850
So for these sample pieces of
data, the t is a 1.25 for one

00:18:18.850 --> 00:18:21.390
curve and 0.623 for the other.

00:18:21.390 --> 00:18:23.750
And when I plug the t into some
equation, I'll get the

00:18:23.750 --> 00:18:25.625
same intersection point
for both curves.

00:18:28.440 --> 00:18:32.620
In Skia, by the way, the y
point's down instead of up, so

00:18:32.620 --> 00:18:34.520
things may look a little upside
down from the math

00:18:34.520 --> 00:18:35.770
you're used to.

00:18:38.550 --> 00:18:43.570
So let's get back to solving
curves by subdividing.

00:18:43.570 --> 00:18:46.330
This solution is the one that I
used originally in the '80s,

00:18:46.330 --> 00:18:48.800
and it's very popular today as
well, and there's been a lot

00:18:48.800 --> 00:18:52.760
of work to optimize this such as
the work by T. W. Sederberg

00:18:52.760 --> 00:19:00.730
at BYU using convex hulls
to optimize subdivision.

00:19:00.730 --> 00:19:04.300
I found this solution ultimately
unworkable because

00:19:04.300 --> 00:19:08.530
it falls down when two curves
are very close to the same.

00:19:08.530 --> 00:19:12.540
In this case, every time the
curves are subdivided, the

00:19:12.540 --> 00:19:15.220
pair of curves are still
very close to the same.

00:19:15.220 --> 00:19:18.190
And even though they don't
touch each other, it's

00:19:18.190 --> 00:19:21.520
impossible to tell without
further subdivision.

00:19:21.520 --> 00:19:26.590
So I found in this case that it
was a very long tail before

00:19:26.590 --> 00:19:29.650
I would know whether or not
the solution was found.

00:19:29.650 --> 00:19:31.500
So this is a solution I
tried and abandoned.

00:19:34.260 --> 00:19:37.110
So going back to the math
approach, this is the

00:19:37.110 --> 00:19:41.320
Bernstein equation for a
quadratic bezier, and it

00:19:41.320 --> 00:19:44.710
simply describes the x and y
values for some value of t

00:19:44.710 --> 00:19:46.960
from 0 to 1.

00:19:46.960 --> 00:19:49.900
As I said before, if t is
0, the answer is C0.

00:19:49.900 --> 00:19:52.635
If t is 1, the answer is C2.

00:19:52.635 --> 00:19:55.030
And if the t is any
other value, it's

00:19:55.030 --> 00:19:58.320
somewhere along the curve.

00:19:58.320 --> 00:20:02.480
The simplified form of the
equation collects the values

00:20:02.480 --> 00:20:07.430
together so that now I have a
simple quadratic which is very

00:20:07.430 --> 00:20:08.680
easy to solve.

00:20:11.150 --> 00:20:13.220
The implicit form of the
equation is a little more

00:20:13.220 --> 00:20:17.950
complicated, but it describes an
entire parabola instead of

00:20:17.950 --> 00:20:22.660
the quadratic section which is
a piece of that parabola.

00:20:22.660 --> 00:20:25.240
Even though the math looks
daunting, it turns out there's

00:20:25.240 --> 00:20:28.750
enough common terms that it only
takes about 28 multiplies

00:20:28.750 --> 00:20:31.460
and 11 adds to get from
the simple form to

00:20:31.460 --> 00:20:32.710
the implicit form.

00:20:35.550 --> 00:20:40.010
Once I have both the implicit
and parametric forms of the

00:20:40.010 --> 00:20:43.900
equation, I can plug
one into the other.

00:20:43.900 --> 00:20:48.080
So I can take the second
equation, which describes how

00:20:48.080 --> 00:20:52.900
x and y are in terms of t, and
I can plug that answer into

00:20:52.900 --> 00:20:57.160
the third equation to get rid
of the t altogether and have

00:20:57.160 --> 00:21:02.250
something I can solve for t.

00:21:02.250 --> 00:21:06.230
Once I have the quartic
equation, now I can find the

00:21:06.230 --> 00:21:08.820
solution that will give me
the intersection of one

00:21:08.820 --> 00:21:10.040
curve with the other.

00:21:10.040 --> 00:21:14.390
But this just gets me the t
values for the first curve.

00:21:14.390 --> 00:21:18.950
I have to do the reverse and
plug the second equation into

00:21:18.950 --> 00:21:23.340
the first in order to get the
complement, in order to get

00:21:23.340 --> 00:21:26.580
the t values for the
prime equation.

00:21:26.580 --> 00:21:29.860
Once I have the t values for
both equations, I can plug

00:21:29.860 --> 00:21:34.330
them in and ensure that they
return the same x and y values

00:21:34.330 --> 00:21:35.580
for each of the quadratics.

00:21:38.470 --> 00:21:40.950
Since I have a quadratic
solution that's robust and

00:21:40.950 --> 00:21:43.970
works well, you might think I
would also be able to use that

00:21:43.970 --> 00:21:45.990
same solution for cubics.

00:21:45.990 --> 00:21:48.170
After all, cubics are just
quadratics with one more

00:21:48.170 --> 00:21:50.635
control point, so they can't be
that much more complicated.

00:21:53.790 --> 00:21:56.140
Here's the Bernstein polynomial
for a cubic

00:21:56.140 --> 00:21:59.680
equation, which looks a lot
like the quadratic one.

00:21:59.680 --> 00:22:01.880
It just has one more
term, and this has

00:22:01.880 --> 00:22:03.130
cubes instead of squares.

00:22:06.460 --> 00:22:10.070
If I overlay a pair of cubics
on top of each other, I'll

00:22:10.070 --> 00:22:14.230
find that they can have as many
as nine intersections,

00:22:14.230 --> 00:22:17.960
and this ought to set off alarm
bells because it's going

00:22:17.960 --> 00:22:21.010
to be very hard to find nine
roots for an equation.

00:22:23.900 --> 00:22:26.940
If I plug the equation into
Mathematica, I get a rather

00:22:26.940 --> 00:22:29.020
daunting-looking result.

00:22:29.020 --> 00:22:31.620
And notice that this still has
everything in terms of x and

00:22:31.620 --> 00:22:34.950
y, so this is not the
complete solution.

00:22:34.950 --> 00:22:35.780
This is half of it--

00:22:35.780 --> 00:22:38.910
I still have to plug all of the
x and y values from the

00:22:38.910 --> 00:22:41.700
alternate equation into
this equation.

00:22:41.700 --> 00:22:44.370
So things are looking sad
for solving cubics with

00:22:44.370 --> 00:22:45.620
mathematics.

00:22:47.620 --> 00:22:50.930
Sure enough, if I work all the
way through, I'll end up with

00:22:50.930 --> 00:22:53.240
a ninth ordered equation
for which there

00:22:53.240 --> 00:22:55.250
is no general solution.

00:22:55.250 --> 00:22:57.630
And even though there's a lot
of advancements in root

00:22:57.630 --> 00:23:01.020
finding and computers are much
faster than they were 25 years

00:23:01.020 --> 00:23:04.830
ago, people haven't got a whole
lot smarter, so this

00:23:04.830 --> 00:23:08.030
sort of equation is impossible
to solve

00:23:08.030 --> 00:23:10.130
directly in a robust manner.

00:23:13.330 --> 00:23:16.100
So let's take a look
at the cubic again.

00:23:16.100 --> 00:23:20.010
This cubic intersects itself, so
not only do I need to find

00:23:20.010 --> 00:23:22.720
how the cubic intersects another
cubic, but I need to

00:23:22.720 --> 00:23:24.860
know its own intersection.

00:23:24.860 --> 00:23:27.180
This gives me a clue as to
how I might solve the

00:23:27.180 --> 00:23:28.430
intersection.

00:23:30.090 --> 00:23:33.160
Rather than try to solve the
cubic directly, I can

00:23:33.160 --> 00:23:36.440
approximate it with a series of
quadratics and then use my

00:23:36.440 --> 00:23:40.170
quadratic intersection to find
the actual solution.

00:23:40.170 --> 00:23:43.650
Once I get the intersection
values in t with quadratics, I

00:23:43.650 --> 00:23:46.930
can take those same t values
and apply them back to the

00:23:46.930 --> 00:23:49.810
cubic and then check to
see if they return the

00:23:49.810 --> 00:23:52.490
same x and y value.

00:23:52.490 --> 00:23:54.360
This turns out to be a pretty
robust solution

00:23:54.360 --> 00:23:55.610
that works very well.

00:23:59.930 --> 00:24:02.930
So here's a pair of cubics
that intersect each other

00:24:02.930 --> 00:24:04.990
connected to a line.

00:24:04.990 --> 00:24:07.540
For lines in cubics and lines
and the lines and the lines in

00:24:07.540 --> 00:24:10.020
quadratics, I can solve
those directly.

00:24:10.020 --> 00:24:12.570
I don't have to do
any special math.

00:24:12.570 --> 00:24:16.750
So this line does not intersect
cubic one-- it just

00:24:16.750 --> 00:24:17.940
misses touching it--

00:24:17.940 --> 00:24:19.660
but the pair of cubics
intersect each other.

00:24:22.370 --> 00:24:26.310
When I approximate one cubic
with a quadratic, the

00:24:26.310 --> 00:24:30.600
quadratic approximation is very
close, which is fine.

00:24:30.600 --> 00:24:33.040
It's just exactly what
I want it to be.

00:24:33.040 --> 00:24:35.640
The cubic continues off to the
right, and as the cubic

00:24:35.640 --> 00:24:38.430
continues, the quadratic
approximation drifts a little

00:24:38.430 --> 00:24:42.330
bit further away,
but not too far.

00:24:42.330 --> 00:24:45.950
But for the first cubic, its
endpoints are far off the

00:24:45.950 --> 00:24:49.780
screen, and so the quadratic
approximation at this point is

00:24:49.780 --> 00:24:51.490
the furthest it ever gets
from the cubic.

00:24:55.380 --> 00:24:59.240
So even though the line does not
intersect the cubic, it's

00:24:59.240 --> 00:25:02.000
also the case that the pair of
quadratics do not intersect

00:25:02.000 --> 00:25:04.240
each other.

00:25:04.240 --> 00:25:06.610
So using a straightforward
solution, I miss this

00:25:06.610 --> 00:25:08.940
intersection altogether,
and my path ops

00:25:08.940 --> 00:25:10.190
produce the wrong result.

00:25:12.980 --> 00:25:16.580
To find the intersection of the
cubics, I have to rely on

00:25:16.580 --> 00:25:18.050
the convex hull.

00:25:18.050 --> 00:25:20.540
The convex hull is what happens
when you connect all

00:25:20.540 --> 00:25:22.160
the control points of
the cubic together.

00:25:22.160 --> 00:25:25.830
It describes a polygon around
which the cubic is guaranteed

00:25:25.830 --> 00:25:27.600
to be contained by.

00:25:27.600 --> 00:25:30.550
If I look at the very end of
the convex hull, these tiny

00:25:30.550 --> 00:25:34.430
little line segments, then I can
find the intersections of

00:25:34.430 --> 00:25:38.430
those lines with the opposing
cubic and use that to find the

00:25:38.430 --> 00:25:40.710
intersections of the
pair of cubics.

00:25:40.710 --> 00:25:43.100
Since I only have to do this
at the very ends of the

00:25:43.100 --> 00:25:47.330
cubics, it's a trivial
computation, and it allows the

00:25:47.330 --> 00:25:49.480
entire calculation
to be robust.

00:25:52.240 --> 00:25:54.420
Now that I have the
intersections of cubics,

00:25:54.420 --> 00:25:57.910
quadratics, and lines, then I
can get back to performing my

00:25:57.910 --> 00:26:00.150
path operations.

00:26:00.150 --> 00:26:05.140
As before, I'd like to find
all of the places where an

00:26:05.140 --> 00:26:07.480
intersection travels, and I
would like compute all the

00:26:07.480 --> 00:26:09.670
crossings in a circle.

00:26:09.670 --> 00:26:13.250
And as I move counterclockwise
around all of those crossings,

00:26:13.250 --> 00:26:16.470
I'd like to accumulate the
winding number to know which

00:26:16.470 --> 00:26:21.130
edges to keep and which
edges to discard.

00:26:21.130 --> 00:26:24.070
In this example, a triangle and
a pair of circles touch at

00:26:24.070 --> 00:26:28.525
the same point, and there are
two lines and two quadratics

00:26:28.525 --> 00:26:32.460
that all descend from that
point, and I need to sort them

00:26:32.460 --> 00:26:36.070
as I move around
counterclockwise.

00:26:36.070 --> 00:26:39.015
When I sort the pair of lines,
the answer is straightforward.

00:26:39.015 --> 00:26:41.980
The direction of the line allows
me to know which line

00:26:41.980 --> 00:26:47.030
is to the left of the other
using a simple cross product.

00:26:47.030 --> 00:26:51.900
For the line in the quadratic, I
can't use that trick because

00:26:51.900 --> 00:26:53.680
the initial tangent of
the quadratic is

00:26:53.680 --> 00:26:55.280
the same as the line.

00:26:55.280 --> 00:26:57.580
But I can use the fact that the
quadratic curls away from

00:26:57.580 --> 00:27:00.140
the line to know whether it
curls to the right or the left

00:27:00.140 --> 00:27:02.700
of the line.

00:27:02.700 --> 00:27:06.180
For a pair of quadratics, the
answer is not so simple.

00:27:06.180 --> 00:27:09.540
This particular pair of
quadratics have exactly the

00:27:09.540 --> 00:27:10.870
same implicit equation--

00:27:10.870 --> 00:27:14.300
that is, they're part of the
same parabola, and for that

00:27:14.300 --> 00:27:18.280
matter, they're the exact same
part of that same parabola, so

00:27:18.280 --> 00:27:24.510
they have the same
curved shape.

00:27:24.510 --> 00:27:27.680
And if I take the derivative of
each curve, I won't get any

00:27:27.680 --> 00:27:30.470
more information because the
derivative will be identical

00:27:30.470 --> 00:27:32.270
for these two.

00:27:32.270 --> 00:27:36.120
So even though it's clear by
looking at them that Q2 is to

00:27:36.120 --> 00:27:39.120
the left of Q1, it's hard
to figure that out

00:27:39.120 --> 00:27:40.370
mathematically.

00:27:42.880 --> 00:27:47.100
My solution for now is to take
the shorter of the two

00:27:47.100 --> 00:27:52.820
tangents and bisect that with
the shorter of the start end

00:27:52.820 --> 00:27:56.860
points and sort those
intersections.

00:27:56.860 --> 00:28:00.980
Empirically, this produces the
right result, although there

00:28:00.980 --> 00:28:02.230
may be a better one.

00:28:05.960 --> 00:28:10.340
All of this sorting falls
apart when the

00:28:10.340 --> 00:28:12.730
numerics become small.

00:28:12.730 --> 00:28:16.342
So here I have a line that
travels between two points off

00:28:16.342 --> 00:28:21.260
screen, and here are the
approximations of that line as

00:28:21.260 --> 00:28:22.510
represented by little circles.

00:28:24.970 --> 00:28:28.970
This grid represents the
floating point resolution

00:28:28.970 --> 00:28:32.630
that's available to me, so if
my numbers are in doubles,

00:28:32.630 --> 00:28:38.200
then each grid line represents
the smallest possible value

00:28:38.200 --> 00:28:40.240
that that double
can represent.

00:28:40.240 --> 00:28:44.010
In other words, there's no way
to represent any value smaller

00:28:44.010 --> 00:28:45.260
than the grid lines.

00:28:47.250 --> 00:28:50.610
When I intersect a pair of
lines, I'm going to find at

00:28:50.610 --> 00:28:55.020
best the number that is the
truncation of the actual

00:28:55.020 --> 00:28:56.330
intersection.

00:28:56.330 --> 00:29:00.160
In other words, because double
precision is finite,

00:29:00.160 --> 00:29:01.700
everything's going
to round down.

00:29:05.030 --> 00:29:09.050
Here's the second line that
intersects the original line.

00:29:09.050 --> 00:29:12.060
And once again, the intersection
as the best

00:29:12.060 --> 00:29:15.910
possible approximation rounds
down, and it's represented by

00:29:15.910 --> 00:29:17.160
the red circle.

00:29:19.360 --> 00:29:23.350
When I consider which of these
lines I would encounter first

00:29:23.350 --> 00:29:27.120
when traveling from left to
right, I see visually that the

00:29:27.120 --> 00:29:30.980
blue line is to the left
of the red line.

00:29:30.980 --> 00:29:34.260
But when I walk across and look
at the answers that I

00:29:34.260 --> 00:29:36.830
received from the intersection,
I hit the red

00:29:36.830 --> 00:29:39.250
dot before I hit the blue dot.

00:29:39.250 --> 00:29:41.750
So basically, the
math lied to me.

00:29:41.750 --> 00:29:43.000
It gave me the wrong
intersection.

00:29:45.870 --> 00:29:49.560
As it turns out, this would not
be important because this

00:29:49.560 --> 00:29:52.490
little triangular sliver, even
though it would be incorrectly

00:29:52.490 --> 00:29:55.300
computed, is so small
it wouldn't draw.

00:29:55.300 --> 00:29:56.550
It would simply disappear.

00:29:58.980 --> 00:30:02.040
But if I'm doing the same work
with a curve instead a pair of

00:30:02.040 --> 00:30:06.110
lines, then all of a sudden the
area described between the

00:30:06.110 --> 00:30:09.540
blue line and the red curve can
become very large, and my

00:30:09.540 --> 00:30:11.980
error likewise becomes
very large.

00:30:11.980 --> 00:30:13.890
And now my answer is
wrong for a large

00:30:13.890 --> 00:30:15.334
portion of the path op.

00:30:18.970 --> 00:30:22.240
This means that for a lot of
computation, I need just to

00:30:22.240 --> 00:30:26.220
decide that the answer
is just unknowable.

00:30:26.220 --> 00:30:29.200
It may be unsortable, it may
be tiny, or it may be

00:30:29.200 --> 00:30:33.030
unorderable, but I can't
necessarily compute what the

00:30:33.030 --> 00:30:36.210
answer is for an intersection.

00:30:36.210 --> 00:30:40.000
To solve this in the general
case, I simply find another

00:30:40.000 --> 00:30:43.480
intersection that I do know and
propagate that answer back

00:30:43.480 --> 00:30:45.070
to the intersection
that I don't know.

00:30:49.300 --> 00:30:53.530
If a pair of shapes exactly
overlap each other as in the

00:30:53.530 --> 00:30:58.150
case of this pair of rectangles,
the path op is

00:30:58.150 --> 00:30:59.730
pretty straightforward
to compute.

00:30:59.730 --> 00:31:03.760
In this case, the dark green
rectangle is below the blue

00:31:03.760 --> 00:31:06.960
one, and so I just want to
return the top of the blue one

00:31:06.960 --> 00:31:09.470
as the answer.

00:31:09.470 --> 00:31:14.600
A lot of the online references
that I researched suggest that

00:31:14.600 --> 00:31:18.280
when points are difficult to
compute, that you could jiggle

00:31:18.280 --> 00:31:22.210
the points in order to compute
the actual answer, but this is

00:31:22.210 --> 00:31:25.820
a case where jiggling
is destructive.

00:31:25.820 --> 00:31:29.120
If I move the lower rectangle's
shapes around a

00:31:29.120 --> 00:31:34.140
little bit to avoid having
coincident points, then my

00:31:34.140 --> 00:31:37.480
answer will have extra little
spikes on them.

00:31:37.480 --> 00:31:40.580
All these spikes are so small
they may not draw.

00:31:40.580 --> 00:31:43.770
They prevent me from having a
convex result, which might be

00:31:43.770 --> 00:31:48.060
a special operation or a special
optimization when the

00:31:48.060 --> 00:31:49.720
shape is accelerated.

00:31:49.720 --> 00:31:53.010
Also, it prevents me from
knowing the actual balance of

00:31:53.010 --> 00:31:56.590
the resulting shape, and it
makes the testing hard,

00:31:56.590 --> 00:32:00.230
because I can't guarantee that
a tap on the shape won't

00:32:00.230 --> 00:32:03.520
accidentally be inside one of
those little triangles.

00:32:03.520 --> 00:32:06.530
So this is one reason why
jiggling, I think, is not a

00:32:06.530 --> 00:32:09.260
robust solution to path ops.

00:32:12.630 --> 00:32:16.630
While I can't do jiggling, I
also can't do precise math

00:32:16.630 --> 00:32:20.770
because there's enough error
term in all these calculations

00:32:20.770 --> 00:32:24.950
that I always have to worry
about what the error is.

00:32:24.950 --> 00:32:27.935
So I spent a lot of time
thinking about the unit of

00:32:27.935 --> 00:32:31.180
least precision, which
is the error term.

00:32:31.180 --> 00:32:34.990
When I compare numbers between
0 and 1, I can describe

00:32:34.990 --> 00:32:38.920
exactly what that error is, and
the error I chose is the

00:32:38.920 --> 00:32:41.320
smallest amount that a floating
point value can

00:32:41.320 --> 00:32:45.600
represent, a 32-bit float
can represent.

00:32:45.600 --> 00:32:49.610
This computation can be done all
in float space or in the

00:32:49.610 --> 00:32:49.820
[INAUDIBLE]

00:32:49.820 --> 00:32:53.030
registers or the [INAUDIBLE]
registers on an ARM chip, and

00:32:53.030 --> 00:32:57.030
it's a fairly fast computation
to make.

00:32:57.030 --> 00:33:01.670
When the values are arbitrary,
as an ordinary x and y point

00:33:01.670 --> 00:33:05.380
part of a Cartesian coordinate,
then the only

00:33:05.380 --> 00:33:11.570
reasonable way to determine the
equality is to look at the

00:33:11.570 --> 00:33:14.890
integer bit representation of
the floating point numbers.

00:33:14.890 --> 00:33:18.100
This is expensive because it
requires taking the original

00:33:18.100 --> 00:33:21.380
float values and moving them out
of the float registers and

00:33:21.380 --> 00:33:25.110
into the integer ALU before the
comparison can be done,

00:33:25.110 --> 00:33:27.640
and that will always stall
the float pipeline.

00:33:27.640 --> 00:33:32.120
So whenever possible, I work in
t space between 0 and 1 and

00:33:32.120 --> 00:33:35.750
avoid comparing x's and y's
as much as I possibly can.

00:33:38.500 --> 00:33:43.060
I have a whole lot of epsilon
values that I currently use,

00:33:43.060 --> 00:33:45.770
depending on the complexity
of the math.

00:33:45.770 --> 00:33:48.500
I hope over time to simplify
and reduce the number of

00:33:48.500 --> 00:33:51.690
epsilons required to perform
this calculation.

00:33:51.690 --> 00:33:54.560
And a lot of these are seat of
the pants numbers, but they're

00:33:54.560 --> 00:33:55.810
the best I know how to do.

00:33:58.940 --> 00:34:02.360
There's a lot of unanswered
questions in path ops.

00:34:02.360 --> 00:34:05.460
For instance, here's a shape
that has more than one

00:34:05.460 --> 00:34:06.840
possible solution.

00:34:06.840 --> 00:34:10.630
When I simplify it, it I might
end up with an L-shaped

00:34:10.630 --> 00:34:12.699
corner, or I might end
up with a small

00:34:12.699 --> 00:34:14.610
rectangle in the middle.

00:34:14.610 --> 00:34:17.460
Both of these are equally valid
answers, and there's no

00:34:17.460 --> 00:34:20.620
reason to prefer one over the
other, but one might be more

00:34:20.620 --> 00:34:23.580
desirable for graphics
acceleration, for instance.

00:34:23.580 --> 00:34:27.409
And currently, I don't have a
way for the algorithm or the

00:34:27.409 --> 00:34:28.889
user to choose one
over the other.

00:34:31.659 --> 00:34:35.710
Similarly, I don't have a way of
choosing winding direction.

00:34:35.710 --> 00:34:37.949
So here are two shapes with
different winding.

00:34:37.949 --> 00:34:43.469
The top one winds to the right
on the outer contour, and the

00:34:43.469 --> 00:34:45.620
bottom one winds to the left.

00:34:45.620 --> 00:34:49.929
While these draw equivalently
and are otherwise identical,

00:34:49.929 --> 00:34:51.800
they might have different
results-- for instance, if you

00:34:51.800 --> 00:34:54.739
dash the shapes, because the
dashing is going to start at a

00:34:54.739 --> 00:34:56.679
different point, and it's
going to travel

00:34:56.679 --> 00:34:58.880
in a different direction.

00:34:58.880 --> 00:35:03.320
This is another area where I
don't have a way to choose one

00:35:03.320 --> 00:35:07.225
over the other nor know what
the user's real intent was.

00:35:10.150 --> 00:35:14.390
Finally, right now I
only compute areas.

00:35:14.390 --> 00:35:18.290
So for instance, given this
rotated rectangle and a

00:35:18.290 --> 00:35:23.720
rectangular clip, I return a
parallelogram, which is the

00:35:23.720 --> 00:35:26.510
area of the intersection.

00:35:26.510 --> 00:35:28.970
But there may be some reason
to return a pair of lines

00:35:28.970 --> 00:35:32.620
instead because those lines
would be the part of the frame

00:35:32.620 --> 00:35:35.650
that's visible inside
the clip.

00:35:35.650 --> 00:35:38.140
This is another case where I
don't know what the user's

00:35:38.140 --> 00:35:42.330
intent was, and I also don't
know if the lower answer is an

00:35:42.330 --> 00:35:43.580
answer that's valuable.

00:35:46.350 --> 00:35:50.540
To this point, I'm only coding
the answers that actually have

00:35:50.540 --> 00:35:52.550
a practical use.

00:35:52.550 --> 00:35:55.320
Once there's a need for this
sort of computation, it's an

00:35:55.320 --> 00:35:58.970
easy thing to add, but I'll wait
until it shows up as an

00:35:58.970 --> 00:36:00.880
optimization for Skia
before I add it.

00:36:04.420 --> 00:36:06.010
Here's the current
source code.

00:36:06.010 --> 00:36:09.310
Everything is public, open
source, and checked in, and

00:36:09.310 --> 00:36:13.830
you can go get any of the path
ops code, the interfaces, or

00:36:13.830 --> 00:36:16.110
the sources here.

00:36:16.110 --> 00:36:19.520
And I'm going to spend a few
minutes talking about how I

00:36:19.520 --> 00:36:23.090
debugged and wrote path ops
and show you a small demo.

00:36:25.610 --> 00:36:26.965
And I'm going to do
my updates later.

00:36:30.630 --> 00:36:34.960
When I generate path ops, I do
a lot of printfs, and the

00:36:34.960 --> 00:36:37.460
printfs look a lot like this.

00:36:37.460 --> 00:36:39.600
And while these numbers are
helpful, sometimes they're

00:36:39.600 --> 00:36:46.320
very hard to visualize, so I
wrote a way to visualize them.

00:36:46.320 --> 00:36:48.175
Oops-- how do I get
there from here?

00:36:51.100 --> 00:36:52.350
There we go.

00:36:55.400 --> 00:37:00.570
This is a web page that contains
a canvas, and the

00:37:00.570 --> 00:37:04.400
canvas contains the printf
output that I showed earlier,

00:37:04.400 --> 00:37:07.250
which is at the bottom
of the screen.

00:37:07.250 --> 00:37:10.030
The top part of the screen shows
visualizing that output

00:37:10.030 --> 00:37:12.550
and visualizing pieces
of that output.

00:37:12.550 --> 00:37:16.420
So for instance, all of these
little circles show the

00:37:16.420 --> 00:37:19.970
winding values that are computed
for this shape.

00:37:19.970 --> 00:37:22.770
And if I look at a pair of these
shapes, a pair of these

00:37:22.770 --> 00:37:26.950
tests, I can see at least one
place where I computed a

00:37:26.950 --> 00:37:30.480
different answer on the
two different shapes.

00:37:30.480 --> 00:37:32.680
That's where the bug was that
I had to trace down here.

00:37:35.850 --> 00:37:40.530
This particular canvas allows me
to see a lot of information

00:37:40.530 --> 00:37:42.720
about the path ops
that I compute.

00:37:42.720 --> 00:37:48.490
For instance, I can see all of
the edges as they're first

00:37:48.490 --> 00:37:52.980
computed, and then I can step
through each set of edges and

00:37:52.980 --> 00:37:55.450
watch how they're processed.

00:37:55.450 --> 00:38:01.300
Or I can see the edges as
they're output so that I know

00:38:01.300 --> 00:38:04.290
at what point in the code
each edge is generated.

00:38:10.180 --> 00:38:13.780
So here's the output that this
particular test generated, and

00:38:13.780 --> 00:38:16.690
here's the output that the test
that failed generated.

00:38:16.690 --> 00:38:20.010
So I can compare the two and
have a pretty good idea where

00:38:20.010 --> 00:38:21.260
things went wrong.

00:38:24.450 --> 00:38:29.270
Here's another example that
shows a pair of cubics, and it

00:38:29.270 --> 00:38:32.010
also shows the quadratics that
were generated to approximate

00:38:32.010 --> 00:38:33.260
those cubics.

00:38:35.100 --> 00:38:37.390
So this is actually showing
both the cubics and the

00:38:37.390 --> 00:38:41.080
quadratics at the same time,
but I can look at just the

00:38:41.080 --> 00:38:44.590
quadratics, or I can look at
just the cubics and make sure

00:38:44.590 --> 00:38:46.400
that my answers are accurate.

00:38:46.400 --> 00:38:49.070
And as you can see here, there's
very little visible

00:38:49.070 --> 00:38:51.690
difference between the quadratic
approximation and

00:38:51.690 --> 00:38:52.940
the actual cubic curve.

00:38:58.060 --> 00:39:02.455
This one is going to show
the actual data that a

00:39:02.455 --> 00:39:04.670
web page passes me.

00:39:04.670 --> 00:39:09.790
So this comes off of
eldorado.com, and it contains

00:39:09.790 --> 00:39:14.140
a parallelogram containing a
rounded rect that is also a

00:39:14.140 --> 00:39:16.760
parallelogram, and this
is actual CSS data

00:39:16.760 --> 00:39:19.770
that describes a clip.

00:39:19.770 --> 00:39:23.640
This particular data is
deceptive because even though

00:39:23.640 --> 00:39:26.630
those lines look like they touch
each other, they don't.

00:39:26.630 --> 00:39:29.780
They're actually very close but
not the same, and makes

00:39:29.780 --> 00:39:32.890
the math hard to figure out.

00:39:32.890 --> 00:39:36.520
And here are some other examples
of actual web pages

00:39:36.520 --> 00:39:40.060
and the clips that they produce
that drive me crazy.

00:39:44.560 --> 00:39:49.250
For any of these, I can show the
data that's generated, and

00:39:49.250 --> 00:39:51.620
then I can also show
the printfs that

00:39:51.620 --> 00:39:53.730
generated that data.

00:39:53.730 --> 00:39:57.470
And by advancing through the
data visually and advancing

00:39:57.470 --> 00:40:00.745
through the text, I can then go
back to my C code and set

00:40:00.745 --> 00:40:04.640
break points and figure out
where things went wrong.

00:40:04.640 --> 00:40:06.160
This has been a very helpful
tool for me.

00:40:11.570 --> 00:40:14.200
So now I'd like to show
you a quick demo

00:40:14.200 --> 00:40:16.080
of path ops in action.

00:40:20.110 --> 00:40:23.170
So here we are running some of
the unit tests that I've

00:40:23.170 --> 00:40:25.580
written for path ops.

00:40:25.580 --> 00:40:28.200
At this point I have around 73
million tests, and we're

00:40:28.200 --> 00:40:31.060
seeing a few of them here.

00:40:31.060 --> 00:40:33.990
Each of these tests is drawing
the path ops and

00:40:33.990 --> 00:40:35.810
computing the result.

00:40:35.810 --> 00:40:40.320
It's also using Skia to create
a region with the original

00:40:40.320 --> 00:40:42.320
shapes and the result.

00:40:42.320 --> 00:40:46.600
Then I compare the bits drawn
by my path ops and the bits

00:40:46.600 --> 00:40:50.320
drawn by the region and make
sure there's not any

00:40:50.320 --> 00:40:54.100
conservable amount of error
between the two.

00:40:54.100 --> 00:40:56.930
This is part of the Skia Unit
Test Suite, and this is run

00:40:56.930 --> 00:41:00.750
every time Skia is built on
all platforms, including

00:41:00.750 --> 00:41:04.970
Android, Chrome OS, Mac,
Windows, and Linux in 32-bit

00:41:04.970 --> 00:41:07.060
and 64-bit.

00:41:07.060 --> 00:41:09.960
So I've made sure that this
code is robust and works

00:41:09.960 --> 00:41:11.210
across a lot of different
platforms.

00:41:14.490 --> 00:41:16.470
So that's it for the
presentation.

00:41:16.470 --> 00:41:17.960
I hope you enjoyed it.

00:41:17.960 --> 00:41:19.430
Please write me if you
have any questions.

00:41:19.430 --> 00:41:20.680
Thank you.

00:41:31.278 --> 00:42:31.083
[MUSIC PLAYING]

