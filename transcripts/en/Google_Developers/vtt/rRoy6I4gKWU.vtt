WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.250
ALFRED FULLER: Hi.

00:00:03.800 --> 00:00:04.105
Yeah.

00:00:04.105 --> 00:00:07.250
They just told me
to get started.

00:00:07.250 --> 00:00:09.140
So I'm presenting--

00:00:09.140 --> 00:00:09.435
well.

00:00:09.435 --> 00:00:13.650
I'm co-presenting No-SQL
versus SQL.

00:00:13.650 --> 00:00:18.200
My name is Alfred Fuller and my
co-presenter, Ken Ashcraft,

00:00:18.200 --> 00:00:20.170
he was just here.

00:00:20.170 --> 00:00:22.430
But I guess I'll get
started anyway.

00:00:22.430 --> 00:00:24.690
So I'll do the overview
at least.

00:00:31.840 --> 00:00:34.690
That's weird.

00:00:34.690 --> 00:00:35.940
Excellent.

00:00:37.610 --> 00:00:39.760
This is opposed be a debate.

00:00:39.760 --> 00:00:42.910
But Ken Ashcraft's not here
right now, so I guess it's

00:00:42.910 --> 00:00:44.160
going to be pretty easy.

00:00:46.400 --> 00:00:48.260
And I'm always telling myself
to talk slower in these

00:00:48.260 --> 00:00:49.830
things, and I guess I'm going
to have a lot of extra time.

00:00:49.830 --> 00:00:53.050
So this is going
to be awesome.

00:00:53.050 --> 00:00:56.250
So the first thing I'm going to
do is I'm going to give you

00:00:56.250 --> 00:00:58.700
a quick overview of
data in the cloud.

00:00:58.700 --> 00:01:00.700
So why in the cloud?

00:01:00.700 --> 00:01:04.769
Well first and foremost, the
cloud is excellent for fault

00:01:04.769 --> 00:01:08.260
tolerance, because when you use
Google's cloud, you know,

00:01:08.260 --> 00:01:09.680
we man the pages for you.

00:01:09.680 --> 00:01:12.550
We always have people looking
at these systems to try and

00:01:12.550 --> 00:01:17.310
keep them working without any
user visual interruptions.

00:01:17.310 --> 00:01:20.310
And we automate fault recovery
as much as possible.

00:01:20.310 --> 00:01:23.110
So most of the time when
something happens, no one ever

00:01:23.110 --> 00:01:24.080
need know about.

00:01:24.080 --> 00:01:26.430
It just automatically switches
over to another machine or

00:01:26.430 --> 00:01:31.080
something else, and it
just keeps working.

00:01:31.080 --> 00:01:33.860
And that means low
maintenance.

00:01:33.860 --> 00:01:36.880
And in addition to the fault
tolerance, low maintenance

00:01:36.880 --> 00:01:41.290
also means that we manage the
updates for you in the cloud.

00:01:41.290 --> 00:01:44.250
From a bare metal to software
patches you never have to

00:01:44.250 --> 00:01:47.950
worry, how will this patch
affect my systems, because

00:01:47.950 --> 00:01:51.100
you're using the same cloud
that we use at Google.

00:01:51.100 --> 00:01:53.750
And we vet these patches, we
make sure everything works,

00:01:53.750 --> 00:01:54.270
and then we push it.

00:01:54.270 --> 00:01:56.010
We go through that
whole process.

00:01:56.010 --> 00:01:57.860
And you don't have to
worry about that.

00:01:57.860 --> 00:02:01.330
So when you use the cloud, you
can focus on what you do best

00:02:01.330 --> 00:02:05.080
and not worry about the cloud.

00:02:05.080 --> 00:02:08.060
All of our cloud products also
have built in durability in

00:02:08.060 --> 00:02:09.389
terms of replication.

00:02:09.389 --> 00:02:10.750
There's nothing to configure.

00:02:10.750 --> 00:02:12.180
There's nothing to
think about.

00:02:12.180 --> 00:02:13.540
It's built in from
the ground up.

00:02:13.540 --> 00:02:16.410
These systems are designed
to work this way.

00:02:16.410 --> 00:02:19.260
And they're also geographically
distributed.

00:02:19.260 --> 00:02:22.850
So nothing is sensitive to a
single power outage or a

00:02:22.850 --> 00:02:26.670
single geographical location.

00:02:26.670 --> 00:02:29.410
And finally, accessibility.

00:02:29.410 --> 00:02:31.060
The cloud is always on.

00:02:31.060 --> 00:02:33.590
It's always available, at
least when you have an

00:02:33.590 --> 00:02:34.800
internet connection.

00:02:34.800 --> 00:02:36.710
And when you don't, when
you develop against

00:02:36.710 --> 00:02:38.870
Google cloud products--

00:02:38.870 --> 00:02:42.430
well, at least the Datastore
and Cloud SQL, which I'm

00:02:42.430 --> 00:02:43.190
talking about today--

00:02:43.190 --> 00:02:46.860
we have local development
environments so that you can

00:02:46.860 --> 00:02:49.000
test against those environments,
you can build

00:02:49.000 --> 00:02:51.430
against those environments, and
then you can deploy to the

00:02:51.430 --> 00:02:54.730
cloud and to production
without worrying.

00:02:54.730 --> 00:02:57.270
So I work on App Engine.

00:02:57.270 --> 00:02:59.350
How many of you use
App Engine?

00:02:59.350 --> 00:03:00.340
Show of hands.

00:03:00.340 --> 00:03:02.110
Oh, that's a lot.

00:03:02.110 --> 00:03:06.110
But for the people who don't
use App Engine, App Engine

00:03:06.110 --> 00:03:08.890
lets you build apps on Google's
infrastructure.

00:03:08.890 --> 00:03:12.260
Its Platform as a Service and
its goal is to make your app--

00:03:12.260 --> 00:03:16.160
whether it's a web app or a
cloud-enabled Android app---

00:03:16.160 --> 00:03:19.740
easy to build, easy to scale,
easy to maintain.

00:03:19.740 --> 00:03:21.830
So again, you can focus on what
makes your app great,

00:03:21.830 --> 00:03:24.450
what makes your app special.

00:03:24.450 --> 00:03:29.930
App Engine connects into some
storage APIs, primarily Cloud

00:03:29.930 --> 00:03:32.690
SQL, the Datastore, which again
is what I work on--

00:03:32.690 --> 00:03:36.900
Cloud SQL is what Ken was
supposed to talk about--

00:03:36.900 --> 00:03:39.740
and Cloud Storage, which they
have a talk on Friday.

00:03:39.740 --> 00:03:42.420
So if you're interested in Cloud
Storage, which is BLOB

00:03:42.420 --> 00:03:47.630
storage, I recommend
going to that talk.

00:03:47.630 --> 00:03:50.140
So the Datastore.

00:03:50.140 --> 00:03:53.280
Datastore is literally Google
storage infrastructure.

00:03:53.280 --> 00:03:56.280
So it's the same technology we
use for our own applications.

00:03:56.280 --> 00:03:59.350
So Gmail, Google Web Search,
you're using the same

00:03:59.350 --> 00:04:02.260
infrastructure pieces that we
use to keep those things up

00:04:02.260 --> 00:04:03.440
and running.

00:04:03.440 --> 00:04:06.460
And it's distilled into
well-documented APIs that are

00:04:06.460 --> 00:04:08.900
included in the App
Engine SDK.

00:04:08.900 --> 00:04:12.540
And it's built for scale, both
in terms of size and traffic.

00:04:12.540 --> 00:04:17.680
Right now we perform over 2
trillion operations per month

00:04:17.680 --> 00:04:19.740
in the Datastore alone.

00:04:19.740 --> 00:04:24.090
And it's a fully managed NoSQL
database solution.

00:04:24.090 --> 00:04:26.930
So you don't have to worry about
provisioning or scaling.

00:04:26.930 --> 00:04:29.000
It just kind of works.

00:04:29.000 --> 00:04:33.990
Cloud SQL, on the other hand,
it's fully managed, but it's

00:04:33.990 --> 00:04:35.610
pure MySQL.

00:04:35.610 --> 00:04:38.570
So it's kind of like that
computer you built at home to

00:04:38.570 --> 00:04:41.745
run your SQL instance, except
it's not in your basement.

00:04:44.340 --> 00:04:47.850
It's not on some island in some
VM somewhere with no one

00:04:47.850 --> 00:04:49.580
looking after it.

00:04:49.580 --> 00:04:54.860
It's in the cloud, it's fully
managed, and it's happy.

00:04:54.860 --> 00:04:55.620
KEN ASHCRAFT: Hey, I'm here.

00:04:55.620 --> 00:04:55.900
Hang on.

00:04:55.900 --> 00:04:56.840
Hang on.

00:04:56.840 --> 00:04:57.460
I'm here guys.

00:04:57.460 --> 00:04:58.385
Sorry.

00:04:58.385 --> 00:05:00.170
ALFRED FULLER: Oh, Ken.

00:05:00.170 --> 00:05:00.850
Great.

00:05:00.850 --> 00:05:04.230
KEN ASHCRAFT: Hey,
sorry I'm late.

00:05:04.230 --> 00:05:04.640
Sorry.

00:05:04.640 --> 00:05:06.560
We can get started now
that I'm here.

00:05:06.560 --> 00:05:09.680
My name is Ken Ashcraft and
I work on Cloud SQL.

00:05:09.680 --> 00:05:12.360
This is Alan Fuller and he
worked on the Datastore.

00:05:12.360 --> 00:05:12.665
ALFRED FULLER: Alfred.

00:05:12.665 --> 00:05:13.260
KEN ASHCRAFT: Oh, yeah.

00:05:13.260 --> 00:05:17.890
Anyway, so let me give you a
high-level overview of what

00:05:17.890 --> 00:05:20.660
running in Google Cloud is like
and App Engine and Cloud

00:05:20.660 --> 00:05:21.780
SQL and all of that.

00:05:21.780 --> 00:05:22.310
ALFRED FULLER: No, no.

00:05:22.310 --> 00:05:23.350
I just did that.

00:05:23.350 --> 00:05:24.890
You're a little bit late.

00:05:24.890 --> 00:05:25.460
KEN ASHCRAFT: Oh, Oh.

00:05:25.460 --> 00:05:26.850
Sorry about that.

00:05:26.850 --> 00:05:28.490
ALFRED FULLER: Yeah.

00:05:28.490 --> 00:05:30.090
KEN ASHCRAFT: You know,
it's been hard.

00:05:30.090 --> 00:05:31.150
I got distracted.

00:05:31.150 --> 00:05:33.370
I was talking with developers
outside.

00:05:33.370 --> 00:05:35.110
They just keep on mobbing me.

00:05:35.110 --> 00:05:39.570
Everybody's so excited about
using Cloud SQL.

00:05:39.570 --> 00:05:41.030
They're really loving
to have the

00:05:41.030 --> 00:05:43.740
expressiveness of a MySQL database.

00:05:43.740 --> 00:05:46.625
It's super easy to get started,
super easy to manage,

00:05:46.625 --> 00:05:49.420
and the best part is they don't
have to use any of that

00:05:49.420 --> 00:05:52.100
NoSQL silly Datastore stuff.

00:05:52.100 --> 00:05:54.940
They get to use a real
database, MySQL.

00:05:54.940 --> 00:05:55.320
ALFRED FULLER: Wow.

00:05:55.320 --> 00:05:56.595
Starting with the name
calling already.

00:05:56.595 --> 00:05:58.010
You know, I knew this was
supposed to be a debate.

00:05:58.010 --> 00:05:59.650
But I didn't think it'd get
so ugly so quickly.

00:05:59.650 --> 00:06:00.780
KEN ASHCRAFT: It's
not name calling.

00:06:00.780 --> 00:06:02.020
It's fact.

00:06:02.020 --> 00:06:04.100
Anything that you can do,
I can do it better.

00:06:04.100 --> 00:06:05.380
I can do anything
better than you.

00:06:05.380 --> 00:06:06.505
ALFRED FULLER: No you can't.

00:06:06.505 --> 00:06:07.260
KEN ASHCRAFT: Yes I can.

00:06:07.260 --> 00:06:08.580
ALFRED FULLER: No you can't.

00:06:08.580 --> 00:06:11.682
KEN ASHCRAFT: Yes I can.

00:06:11.682 --> 00:06:13.790
Let me show you.

00:06:13.790 --> 00:06:15.050
Let's talk about queries.

00:06:15.050 --> 00:06:16.780
Queries are important because
they're the way that you

00:06:16.780 --> 00:06:17.630
access your data.

00:06:17.630 --> 00:06:20.050
If you don't have a powerful
query language, you can't get

00:06:20.050 --> 00:06:24.290
to the data that you want, and
you can't get it quickly.

00:06:24.290 --> 00:06:26.720
Cloud SQL supports the
international standard for

00:06:26.720 --> 00:06:28.880
database manipulation,
structured query

00:06:28.880 --> 00:06:29.950
language, or SQL.

00:06:29.950 --> 00:06:32.780
It sounds like NoSQL databases
are proud not to

00:06:32.780 --> 00:06:34.320
support this standard.

00:06:34.320 --> 00:06:36.060
ALFRED FULLER: Actually, NoSQL
is kind of a misnomer for the

00:06:36.060 --> 00:06:39.810
Datastore as we support an
ever-growing subset of a

00:06:39.810 --> 00:06:42.390
structured query language
similar to SQL.

00:06:42.390 --> 00:06:44.780
Specifically, we support a
wide range of filters.

00:06:44.780 --> 00:06:48.760
We just added support for OR
in both Java and Python.

00:06:48.760 --> 00:06:51.350
So you can combine these
filters with OR and in

00:06:51.350 --> 00:06:52.630
sub-expressions.

00:06:52.630 --> 00:06:54.680
It supports arbitrary sorting.

00:06:54.680 --> 00:06:57.390
And we also added, recently,
projections or index-only

00:06:57.390 --> 00:07:01.790
queries, where you can only
retrieve a few properties from

00:07:01.790 --> 00:07:04.500
your entities, and it's much
faster and cheaper than

00:07:04.500 --> 00:07:07.150
retrieving the whole entity.

00:07:07.150 --> 00:07:10.280
And we actually go beyond SQL
in that we support repeated

00:07:10.280 --> 00:07:10.800
properties.

00:07:10.800 --> 00:07:13.450
So you can do set operators
like "contains all" or

00:07:13.450 --> 00:07:15.560
"contains any." And that's
incredibly useful when you're

00:07:15.560 --> 00:07:21.260
building tools like labels in
Gmail or tags for photos.

00:07:21.260 --> 00:07:24.600
And the best part about this is
this subset scales in the

00:07:24.600 --> 00:07:25.830
size of the result set.

00:07:25.830 --> 00:07:28.290
So you never have to worry, as
your database grows, if the

00:07:28.290 --> 00:07:29.670
performance of your queries
is actually going to

00:07:29.670 --> 00:07:31.610
degrade over time.

00:07:31.610 --> 00:07:32.530
KEN ASHCRAFT: I don't know.

00:07:32.530 --> 00:07:36.130
In Cloud SQL, we support all
those SQL queries that you

00:07:36.130 --> 00:07:37.730
just talked about
and then some.

00:07:37.730 --> 00:07:39.820
We can do things more powerful,
like aggregations.

00:07:39.820 --> 00:07:42.460
So let's say that you want to
compute the average age of

00:07:42.460 --> 00:07:44.150
people living in each city.

00:07:44.150 --> 00:07:47.450
In Cloud SQL, it's as
simple as this.

00:07:47.450 --> 00:07:49.540
All you have to do is select
the average age

00:07:49.540 --> 00:07:50.810
and group by city.

00:07:50.810 --> 00:07:52.250
ALFRED FULLER: Well, the
Datastore supports something

00:07:52.250 --> 00:07:55.050
like that too, except it has to
scale to enormous sizes, so

00:07:55.050 --> 00:07:57.460
we have a powerful framework
called MapReduce.

00:07:57.460 --> 00:07:58.340
And here's an example.

00:07:58.340 --> 00:08:01.040
You can see on the left
there's some data.

00:08:01.040 --> 00:08:04.660
I have each person, and it
has a city ID and an age.

00:08:04.660 --> 00:08:08.260
And we can use MapReduce
to compute the

00:08:08.260 --> 00:08:09.510
average age in each city.

00:08:09.510 --> 00:08:13.200
By simply mapping, we map this
to a key value pair.

00:08:13.200 --> 00:08:15.810
In this case, the key is
the city ID and the

00:08:15.810 --> 00:08:17.240
value is the age.

00:08:17.240 --> 00:08:20.170
Then we shuffle to
group by city ID.

00:08:20.170 --> 00:08:22.680
And then we reduce to calculate
the numbers that we

00:08:22.680 --> 00:08:25.990
need to compute the average,
namely the total number of

00:08:25.990 --> 00:08:28.180
people and the sum
of all the ages.

00:08:28.180 --> 00:08:30.780
And this case, the sample
set I chose is actually,

00:08:30.780 --> 00:08:32.030
apparently, quite young.

00:08:35.200 --> 00:08:39.179
But also, we can go beyond this
in that this required

00:08:39.179 --> 00:08:41.260
mapping over all your data,
and MapReduce is a very

00:08:41.260 --> 00:08:43.929
powerful framework to do that
because it computes this in

00:08:43.929 --> 00:08:47.060
parallel, so as a basic scatter
gather algorithm.

00:08:47.060 --> 00:08:50.670
But if you want to keep this
view that you've created of

00:08:50.670 --> 00:08:54.020
the result set up to date as
your entities change, you can

00:08:54.020 --> 00:08:57.030
do that using something called
a Materialized View.

00:08:57.030 --> 00:08:59.270
So what you do is you basically
track changes in

00:08:59.270 --> 00:09:01.270
your system as they happen.

00:09:01.270 --> 00:09:03.620
And you store them in
a separate entity.

00:09:03.620 --> 00:09:08.170
And then asynchronously, you fan
in those changes and apply

00:09:08.170 --> 00:09:09.220
them to your result set.

00:09:09.220 --> 00:09:10.340
And look.

00:09:10.340 --> 00:09:11.890
The results are now
up to date.

00:09:11.890 --> 00:09:15.550
Apparently, cities two and three
have been evacuated.

00:09:15.550 --> 00:09:17.020
And--

00:09:17.020 --> 00:09:19.930
whoa.

00:09:19.930 --> 00:09:21.180
KEN ASHCRAFT: Time to update.

00:09:23.360 --> 00:09:27.390
I don't know that all sounds
pretty complicated.

00:09:27.390 --> 00:09:29.070
In Cloud SQL, it's
much easier.

00:09:29.070 --> 00:09:31.870
And beyond that, you can do
more complicated things.

00:09:31.870 --> 00:09:36.480
Like let's say that you wanted
to put this average city age

00:09:36.480 --> 00:09:38.080
information on a map.

00:09:38.080 --> 00:09:40.450
Well, you need to be able to
have joins to do that.

00:09:40.450 --> 00:09:43.320
So you'd probably have a table
for your people and a table

00:09:43.320 --> 00:09:45.340
for your cities, and the cities
table will contain the

00:09:45.340 --> 00:09:46.920
latitude and longitude.

00:09:46.920 --> 00:09:49.270
And it's just as easy as this
SQL query that we've got on

00:09:49.270 --> 00:09:49.915
the screen.

00:09:49.915 --> 00:09:52.810
ALFRED FULLER: Yeah, it's not
as easy in the Datastore.

00:09:52.810 --> 00:09:54.840
But let's see what [? Appy ?]

00:09:54.840 --> 00:09:57.270
has to say about that
on the scoreboard.

00:09:57.270 --> 00:10:00.320
And I guess you're right.

00:10:00.320 --> 00:10:02.810
The Datastore actually has a
wide variety of queries that

00:10:02.810 --> 00:10:03.970
support most use cases.

00:10:03.970 --> 00:10:05.910
But if you really want to query
anything and everything,

00:10:05.910 --> 00:10:07.650
or in fact all of your data
when you do these

00:10:07.650 --> 00:10:09.940
aggregations, you really
have to use Cloud SQL.

00:10:09.940 --> 00:10:10.420
KEN ASHCRAFT: That's right.

00:10:10.420 --> 00:10:13.560
Let me tell you something else
that I can do better than you.

00:10:13.560 --> 00:10:14.960
Transactions.

00:10:14.960 --> 00:10:18.420
Transactions are important
because they ensure that you

00:10:18.420 --> 00:10:21.050
have atomically made changes
to your database.

00:10:21.050 --> 00:10:23.620
You don't want your machine
to crash in the middle and

00:10:23.620 --> 00:10:26.040
partially apply some changes.

00:10:26.040 --> 00:10:28.470
Lots of NoSQL databases,
they don't even support

00:10:28.470 --> 00:10:29.890
transactions.

00:10:29.890 --> 00:10:31.120
ALFRED FULLER: Actually,
the Datastore does.

00:10:31.120 --> 00:10:31.550
KEN ASHCRAFT: Well, OK.

00:10:31.550 --> 00:10:34.730
So you can do a transaction
on a single row.

00:10:34.730 --> 00:10:36.270
That's not a real transaction.

00:10:36.270 --> 00:10:38.040
ALFRED FULLER: Datastore
actually supports transactions

00:10:38.040 --> 00:10:40.520
across rows using something
called Entity Group.

00:10:40.520 --> 00:10:42.670
These are groupings of entities
under a single

00:10:42.670 --> 00:10:43.860
transaction log.

00:10:43.860 --> 00:10:45.960
And the thing they do incredibly
well is they

00:10:45.960 --> 00:10:49.000
provide ACID semantics
at scale.

00:10:49.000 --> 00:10:51.900
So all of these entity groups
can have transactions

00:10:51.900 --> 00:10:54.400
occurring simultaneously, and
you can have any number of

00:10:54.400 --> 00:10:56.310
these entity groups in
your application.

00:10:56.310 --> 00:11:00.280
For example, if you have a game,
and you have a player

00:11:00.280 --> 00:11:02.210
entity, and then you have
entities for items in that

00:11:02.210 --> 00:11:05.170
player's inventory, as long as
you structure it in such a way

00:11:05.170 --> 00:11:08.330
that the items in the player's
inventory are in the same

00:11:08.330 --> 00:11:11.700
entity group as the player,
you can act upon these

00:11:11.700 --> 00:11:12.370
transactionally.

00:11:12.370 --> 00:11:15.330
And this is very important,
because you never want a

00:11:15.330 --> 00:11:18.400
player to use an item and have
the item still be in their

00:11:18.400 --> 00:11:21.590
inventory afterwards or try to
use an item and have the

00:11:21.590 --> 00:11:23.890
effect not work.

00:11:23.890 --> 00:11:30.550
So for example, if a player
wanted to drink a potion--

00:11:30.550 --> 00:11:34.670
we have the player as the root
entity and the potion as a

00:11:34.670 --> 00:11:35.500
child entity.

00:11:35.500 --> 00:11:36.880
So they're in the same
entity group.

00:11:36.880 --> 00:11:39.190
And so we can easily act upon
these transactionally.

00:11:39.190 --> 00:11:44.760
So here's an example of how to
do this using the Python API

00:11:44.760 --> 00:11:45.480
for App Engine.

00:11:45.480 --> 00:11:50.300
There's APIs in many other
languages, well, Go and Java.

00:11:50.300 --> 00:11:53.000
And it's as simple as decorating
the function,

00:11:53.000 --> 00:11:55.780
use_potion, in db.transactional,
and it makes

00:11:55.780 --> 00:11:57.980
everything in that function
happen atomically.

00:11:57.980 --> 00:11:59.750
So you get the player.

00:11:59.750 --> 00:12:01.520
You get the potion from
its inventory.

00:12:01.520 --> 00:12:04.060
You transfer the health and
the potion to the player.

00:12:04.060 --> 00:12:06.010
You remove the potion from
the player's inventory.

00:12:06.010 --> 00:12:06.970
And then you put
the player in.

00:12:06.970 --> 00:12:08.180
It all happens atomically.

00:12:08.180 --> 00:12:09.170
KEN ASHCRAFT: I don't know.

00:12:09.170 --> 00:12:10.350
That sounds pretty limited.

00:12:10.350 --> 00:12:13.620
What happens when you want to
atomically move a potion from

00:12:13.620 --> 00:12:14.860
one player to another?

00:12:14.860 --> 00:12:15.890
You're stuck.

00:12:15.890 --> 00:12:18.110
I told you.

00:12:18.110 --> 00:12:18.990
Anything you can do,
I can do better.

00:12:18.990 --> 00:12:19.890
ALFRED FULLER: Wait,
wait, wait.

00:12:19.890 --> 00:12:20.600
No, no.

00:12:20.600 --> 00:12:23.940
We also support cross-entity
group transactions.

00:12:23.940 --> 00:12:26.570
So if you have two players, and
one player wants to sell a

00:12:26.570 --> 00:12:29.600
potion to that other player,
you can do so simply by

00:12:29.600 --> 00:12:32.080
setting the XG flag to true.

00:12:32.080 --> 00:12:38.270
And now in this scenario, you
can load the buyer, you load

00:12:38.270 --> 00:12:40.000
the seller, you load
the potion from

00:12:40.000 --> 00:12:41.000
the seller's inventory.

00:12:41.000 --> 00:12:43.150
You transfer money from the
buyer to the seller.

00:12:43.150 --> 00:12:45.130
You store the potion in
the buyer's inventory.

00:12:45.130 --> 00:12:47.540
You remove the potion from
the seller's inventory.

00:12:47.540 --> 00:12:49.920
And then you save both to the
buyer and the seller, and it

00:12:49.920 --> 00:12:50.480
just happens.

00:12:50.480 --> 00:12:52.200
It works atomically.

00:12:52.200 --> 00:12:53.960
KEN ASHCRAFT: Well, in Cloud
SQL, you can do the same

00:12:53.960 --> 00:12:56.440
thing, but you don't have
to define those

00:12:56.440 --> 00:12:57.720
relationships in advance.

00:12:57.720 --> 00:13:00.250
All you need is START
TRANSACTION, you run your

00:13:00.250 --> 00:13:02.000
queries, and then commit.

00:13:02.000 --> 00:13:03.070
It's as simple as that.

00:13:03.070 --> 00:13:05.510
Here's the exact same example
from the previous slide,

00:13:05.510 --> 00:13:07.840
except how you do
it in Cloud SQL.

00:13:07.840 --> 00:13:11.650
Now, these cross-entity entity
group transactions, are there

00:13:11.650 --> 00:13:13.210
any limitations to them?

00:13:13.210 --> 00:13:16.200
ALFRED FULLER: Well, actually we
had to do something called

00:13:16.200 --> 00:13:19.210
two-phase commit to make sure
that we commit to all the

00:13:19.210 --> 00:13:21.400
transaction logs atomically.

00:13:21.400 --> 00:13:23.370
And this doesn't actually
scale very well with the

00:13:23.370 --> 00:13:25.220
number of transaction
logs involved.

00:13:25.220 --> 00:13:27.960
So currently, we have a limit of
five entity groups that you

00:13:27.960 --> 00:13:30.610
can use in these cross-entity
group transactions, which is

00:13:30.610 --> 00:13:32.150
more than enough
for most cases.

00:13:32.150 --> 00:13:34.050
KEN ASHCRAFT: Well, there are
those other use cases where

00:13:34.050 --> 00:13:36.800
you want to transact over the
entire world, and in Cloud SQL

00:13:36.800 --> 00:13:38.000
you can do that.

00:13:38.000 --> 00:13:40.730
So let's say that you
wanted to give gold

00:13:40.730 --> 00:13:42.210
away to your friends.

00:13:42.210 --> 00:13:44.790
And it's amazing how your
friends just pop up out of

00:13:44.790 --> 00:13:47.880
nowhere when you're
giving stuff away.

00:13:47.880 --> 00:13:50.840
Again, all you need is START
TRANSACTION, you run your

00:13:50.840 --> 00:13:52.690
queries, and then you commit.

00:13:52.690 --> 00:13:55.720
There's no limitations, then, to
the number of entity groups

00:13:55.720 --> 00:13:58.050
or rows that they can be
involved in a transaction.

00:13:58.050 --> 00:13:59.250
ALFRED FULLER: Well let's see
what [? Appy ?] has to say

00:13:59.250 --> 00:13:59.780
about that.

00:13:59.780 --> 00:14:03.590
And that's [? Appy, ?]
by the way.

00:14:03.590 --> 00:14:06.540
App Engine logo.

00:14:06.540 --> 00:14:09.340
You know, I guess the Datastore
does support a wide

00:14:09.340 --> 00:14:11.670
range of transactions, and they
do meet most use cases.

00:14:11.670 --> 00:14:13.960
But if you really want to
transact in the world or lock

00:14:13.960 --> 00:14:17.210
your whole table, you can
use Cloud SQL for that.

00:14:17.210 --> 00:14:18.250
KEN ASHCRAFT: Yes, you can.

00:14:18.250 --> 00:14:21.380
Now, these transactions that
you have over here in the

00:14:21.380 --> 00:14:24.510
Datastore, what good are they
if they're broken by your

00:14:24.510 --> 00:14:26.110
cross-data center replication?

00:14:26.110 --> 00:14:29.660
We all know that the Datastore
is built on top of BigTable.

00:14:29.660 --> 00:14:33.130
And BigTable has this weird,
out-of-order, eventually

00:14:33.130 --> 00:14:37.660
consistent replication that
nobody really understands.

00:14:37.660 --> 00:14:42.860
ALFRED FULLER: Well, actually
the Datastore uses Megastore

00:14:42.860 --> 00:14:43.610
Replication.

00:14:43.610 --> 00:14:45.610
And Megastore Replication uses
those entity groups that I

00:14:45.610 --> 00:14:46.880
talked about earlier.

00:14:46.880 --> 00:14:48.480
And remember, they had parallel
transaction logs.

00:14:48.480 --> 00:14:51.010
Well they also replicate
in parallel as well.

00:14:51.010 --> 00:14:53.980
So we replicate on the
transaction level.

00:14:53.980 --> 00:14:56.440
Although the system does have
no master-- and that means

00:14:56.440 --> 00:14:59.960
that there's no replica in the
system at any given time that

00:14:59.960 --> 00:15:02.630
necessarily has all the most
up-to-date information.

00:15:02.630 --> 00:15:06.890
But if you use operations that
provide the entity group in

00:15:06.890 --> 00:15:10.010
their request, like a "get by
keys" or an ancestor query, we

00:15:10.010 --> 00:15:12.050
can make sure that you're
reading from a replica that

00:15:12.050 --> 00:15:13.720
has all the most up-to-date
information

00:15:13.720 --> 00:15:16.100
for that entity group.

00:15:16.100 --> 00:15:18.950
We do also provide really
powerful global queries.

00:15:18.950 --> 00:15:21.330
So you can query against all of
your data the Datastore no

00:15:21.330 --> 00:15:23.140
matter how much data you have.

00:15:23.140 --> 00:15:27.040
But these, they don't have
an entity group, and it's

00:15:27.040 --> 00:15:29.950
impossible to determine ahead
of time what entity groups

00:15:29.950 --> 00:15:31.070
you're going to see
in that query.

00:15:31.070 --> 00:15:34.400
So we can't make sure that
you're reading from a replica

00:15:34.400 --> 00:15:37.860
that has all the most up-to-date
information.

00:15:37.860 --> 00:15:42.470
But if you recall from
this same slide.

00:15:42.470 --> 00:15:43.760
We do parallel replication.

00:15:43.760 --> 00:15:46.180
And that means that we can scale
the replication based on

00:15:46.180 --> 00:15:48.190
the amount of resources
we have available.

00:15:48.190 --> 00:15:50.770
And that means the replication
actually happens very quickly.

00:15:50.770 --> 00:15:52.750
So these global queries are
only usually a few hundred

00:15:52.750 --> 00:15:54.440
milliseconds out of date.

00:15:54.440 --> 00:15:58.900
And speaking of replication, I
know that MySQL uses a single

00:15:58.900 --> 00:16:01.640
master to guarantee strong
consistency but then

00:16:01.640 --> 00:16:04.560
asynchronously replicates
changes to a slave.

00:16:04.560 --> 00:16:06.800
And if there's a lot of changes
queued up on a master

00:16:06.800 --> 00:16:08.360
and the master crashes,
you lose that data.

00:16:08.360 --> 00:16:10.490
I bet it's a lot of fun to
tell your developers that

00:16:10.490 --> 00:16:11.990
you've lost their data
every time there's

00:16:11.990 --> 00:16:12.650
a Datacenter outage.

00:16:12.650 --> 00:16:14.270
KEN ASHCRAFT: No, no, no.

00:16:14.270 --> 00:16:16.160
It isn't a whole lot of fun to
have those conversations.

00:16:16.160 --> 00:16:18.040
And that's why we don't have
them with Cloud SQL.

00:16:18.040 --> 00:16:20.940
In Cloud SQL, we use synchronous
replication.

00:16:20.940 --> 00:16:23.500
Let me show you how
this works.

00:16:23.500 --> 00:16:26.520
So we have our MySQL server
running here in data center A.

00:16:26.520 --> 00:16:29.640
A client sends some data
to the MySQL Server.

00:16:29.640 --> 00:16:32.560
Before responding to the client,
we synchronously

00:16:32.560 --> 00:16:35.390
replicate the data to the other
data centers, and then

00:16:35.390 --> 00:16:37.200
we respond to the client.

00:16:37.200 --> 00:16:39.390
What this means is that if we
lose the machine that's

00:16:39.390 --> 00:16:42.170
running MySQL server, or even
if we lose the entirety of

00:16:42.170 --> 00:16:45.710
data center A, we can quickly
restart the MySQL server in a

00:16:45.710 --> 00:16:50.120
different data center without
any data loss.

00:16:50.120 --> 00:16:50.280
ALFRED FULLER: Well,
I don't know.

00:16:50.280 --> 00:16:54.210
Let's see what [? Appy ?] has
to say about this one.

00:16:54.210 --> 00:16:55.480
KEN ASHCRAFT: Oh, man.

00:16:55.480 --> 00:16:57.590
I knew I was going to win this
debate, but I didn't think it

00:16:57.590 --> 00:16:58.490
would be this easy.

00:16:58.490 --> 00:16:59.800
ALFRED FULLER: It's
not over yet.

00:16:59.800 --> 00:17:01.730
Let's talk about scalability.

00:17:01.730 --> 00:17:04.619
In any dimension you can scale,
I can scale better.

00:17:04.619 --> 00:17:05.349
KEN ASHCRAFT: No you can't.

00:17:05.349 --> 00:17:06.300
ALFRED FULLER: Yes I can.

00:17:06.300 --> 00:17:06.810
KEN ASHCRAFT: No you can't.

00:17:06.810 --> 00:17:08.260
Let me show you.

00:17:08.260 --> 00:17:10.490
I'll give you some examples from
within Google about how

00:17:10.490 --> 00:17:12.069
we use Cloud SQL.

00:17:12.069 --> 00:17:14.880
The first one is the Google
Time Keeper application.

00:17:14.880 --> 00:17:17.700
It's used by an organization
within Google, the AdWords

00:17:17.700 --> 00:17:19.040
sales and support team.

00:17:19.040 --> 00:17:21.349
And they use it to track how
much time they're spending on

00:17:21.349 --> 00:17:24.470
chat support, email support,
or campaign optimization.

00:17:24.470 --> 00:17:26.930
And then they use this
information to optimize their

00:17:26.930 --> 00:17:28.180
own workflow.

00:17:28.180 --> 00:17:31.770
So this is a large organization
within Google

00:17:31.770 --> 00:17:34.650
that's using Cloud SQL for their
day-to-day jobs, and it

00:17:34.650 --> 00:17:36.340
works really well for them.

00:17:36.340 --> 00:17:38.460
Let me give you another
example.

00:17:38.460 --> 00:17:41.100
The Google company org chart
runs on Cloud SQL.

00:17:41.100 --> 00:17:44.450
So this is 30,000 employees,
their relationships to each

00:17:44.450 --> 00:17:47.360
other, and what they're
working on.

00:17:47.360 --> 00:17:49.710
To give you an idea of the
kind of load that we can

00:17:49.710 --> 00:17:52.000
handle, picture this.

00:17:52.000 --> 00:17:54.140
We've got these company
all-hands meetings.

00:17:54.140 --> 00:17:56.710
So all 30,000 employees are
listening to our upper

00:17:56.710 --> 00:17:57.500
management.

00:17:57.500 --> 00:18:00.060
And the upper management reminds
everyone, all right, I

00:18:00.060 --> 00:18:03.080
want you to go onto the org
chart application and update

00:18:03.080 --> 00:18:04.300
what you're working on.

00:18:04.300 --> 00:18:06.770
So this is a tech company
that we work at.

00:18:06.770 --> 00:18:07.840
Of course, everybody's
there with their

00:18:07.840 --> 00:18:08.880
laptops on their lap.

00:18:08.880 --> 00:18:12.150
So everybody simultaneously
opens their laptop and goes to

00:18:12.150 --> 00:18:12.810
this website.

00:18:12.810 --> 00:18:15.040
This is tens of thousands
of employees

00:18:15.040 --> 00:18:16.280
hammering on this website.

00:18:16.280 --> 00:18:18.330
All of a sudden, we get
tens to hundreds of

00:18:18.330 --> 00:18:19.920
QPS on the back end.

00:18:19.920 --> 00:18:22.180
And Cloud SQL handles
it just fine.

00:18:22.180 --> 00:18:24.690
So Cloud SQL works very well
for these sorts of large

00:18:24.690 --> 00:18:26.460
corporate environments.

00:18:26.460 --> 00:18:27.560
ALFRED FULLER: That's
not scalability.

00:18:27.560 --> 00:18:29.570
Let me show you scalability.

00:18:29.570 --> 00:18:33.210
Say you're building a hugely
popular mobile application.

00:18:33.210 --> 00:18:36.340
We're talking about thousands
and thousands of QPS and

00:18:36.340 --> 00:18:38.490
millions and millions
of users and

00:18:38.490 --> 00:18:40.460
billions of ruffled feathers.

00:18:40.460 --> 00:18:42.360
Well with the Datastore
there's no headaches.

00:18:42.360 --> 00:18:43.500
There's no provisioning.

00:18:43.500 --> 00:18:46.510
It just scales to your use
case, and it just works.

00:18:46.510 --> 00:18:48.260
Let me show you how.

00:18:48.260 --> 00:18:50.930
So the Datastore, as I said
earlier, is built on top of

00:18:50.930 --> 00:18:52.240
Google infrastructure.

00:18:52.240 --> 00:18:55.830
And each one of these layers
adds a key component to the

00:18:55.830 --> 00:18:56.960
Datastore scalability.

00:18:56.960 --> 00:19:01.290
For example, the lowest layer
Google File System, or GFS,

00:19:01.290 --> 00:19:05.140
provides huge capacity and
extremely good durability.

00:19:05.140 --> 00:19:07.310
And this allows your application
to get as large as

00:19:07.310 --> 00:19:09.330
it needs to get.

00:19:09.330 --> 00:19:11.490
And on top of that
we have BigTable.

00:19:11.490 --> 00:19:14.300
And BigTable automatically
splits your data based on

00:19:14.300 --> 00:19:16.480
loads and balances them
on the machines

00:19:16.480 --> 00:19:17.720
that we have available.

00:19:17.720 --> 00:19:19.820
And so say your traffic
changes.

00:19:19.820 --> 00:19:21.940
All of a sudden you have a
spike of writes in one

00:19:21.940 --> 00:19:22.820
part of your data.

00:19:22.820 --> 00:19:26.670
What BigTable will do is it will
take down that one shard,

00:19:26.670 --> 00:19:30.810
or tablet, and split it into two
pieces and then load those

00:19:30.810 --> 00:19:32.190
on different machines.

00:19:32.190 --> 00:19:33.450
And I'd like to thank
[? Ekie ?]

00:19:33.450 --> 00:19:38.830
for this very excellent comic
demonstration of this.

00:19:38.830 --> 00:19:40.800
And then on top of that
is Megastore.

00:19:40.800 --> 00:19:42.570
And Megastore works at scale.

00:19:42.570 --> 00:19:45.410
It is a truly distributed
database system, because it

00:19:45.410 --> 00:19:47.280
spans multiple data centers and

00:19:47.280 --> 00:19:48.930
multiple geographic regions.

00:19:48.930 --> 00:19:50.960
And that's the level
it operates.

00:19:50.960 --> 00:19:53.270
And if you want super into depth
detail about this, you

00:19:53.270 --> 00:19:58.200
can see my talk from last
year, "More 9s, Please."

00:19:58.200 --> 00:20:03.360
And at scale, the reliability
of the Datastore is hugely

00:20:03.360 --> 00:20:06.980
important, because even small
local issues can cause outages

00:20:06.980 --> 00:20:09.310
for many, many, many users.

00:20:09.310 --> 00:20:12.520
And the Megastore just handles
this by automatically failing

00:20:12.520 --> 00:20:14.850
over to different data
centers and reading

00:20:14.850 --> 00:20:15.870
the data from there.

00:20:15.870 --> 00:20:18.200
And it's guaranteed, if you're
using the entity groups, to

00:20:18.200 --> 00:20:21.110
always have that strong
consistency, because it makes

00:20:21.110 --> 00:20:22.820
sure that whatever replica
you're reading

00:20:22.820 --> 00:20:23.900
from is up to date.

00:20:23.900 --> 00:20:26.580
It also handles catastrophic
failures.

00:20:26.580 --> 00:20:29.730
So if one or more data centers
all a sudden goes offline--

00:20:29.730 --> 00:20:31.140
they fall into the ocean
or the power

00:20:31.140 --> 00:20:33.550
outage happens nearby--

00:20:33.550 --> 00:20:35.890
well, those types of
failures are still

00:20:35.890 --> 00:20:38.780
hidden from your users.

00:20:38.780 --> 00:20:42.300
So let's see what the
score on this one.

00:20:42.300 --> 00:20:44.430
Oh yeah.

00:20:44.430 --> 00:20:44.920
KEN ASHCRAFT: All right.

00:20:44.920 --> 00:20:47.900
I'll let you have this one just
because I'm so far ahead.

00:20:47.900 --> 00:20:48.260
ALFRED FULLER: Good.

00:20:48.260 --> 00:20:49.740
Let's talk about management,
then.

00:20:52.920 --> 00:20:54.850
Remember at the beginning of
this presentation, I talked

00:20:54.850 --> 00:20:56.300
about the benefits
of the cloud.

00:20:56.300 --> 00:20:58.570
No software patches
to worry about.

00:20:58.570 --> 00:21:01.050
No hard drives to replace.

00:21:01.050 --> 00:21:02.690
No systems to purchase.

00:21:02.690 --> 00:21:04.790
KEN ASHCRAFT: And all of that
applies equally to Cloud SQL.

00:21:04.790 --> 00:21:06.640
Let me show you just how
easy it is to get

00:21:06.640 --> 00:21:07.880
started with Cloud SQL.

00:21:07.880 --> 00:21:09.960
But the very first thing we need
to do is create an App

00:21:09.960 --> 00:21:11.090
Engine application.

00:21:11.090 --> 00:21:13.960
And rather than doing a live
demo and worrying about WiFi

00:21:13.960 --> 00:21:15.640
and all that stuff, I'm just
going to show you some

00:21:15.640 --> 00:21:16.980
screenshots.

00:21:16.980 --> 00:21:20.260
So we go first to the App Engine
website where we have

00:21:20.260 --> 00:21:22.070
the form for creating
an application.

00:21:22.070 --> 00:21:24.150
We need to pick an app ID.

00:21:24.150 --> 00:21:26.890
So we're going to go with
SQL vs. NoSQL and

00:21:26.890 --> 00:21:27.820
an application title.

00:21:27.820 --> 00:21:30.980
And then I go down here to
create an application.

00:21:30.980 --> 00:21:32.940
All right, that worked
just fine.

00:21:32.940 --> 00:21:35.400
And so I can click on
the dashboard to see

00:21:35.400 --> 00:21:37.100
what we would see.

00:21:37.100 --> 00:21:39.120
But we haven't uploaded
any code yet.

00:21:39.120 --> 00:21:41.390
We don't have any traffic, so
the dashboard isn't very

00:21:41.390 --> 00:21:42.300
interesting.

00:21:42.300 --> 00:21:44.640
The next step that I'm going to
do now, that I've created

00:21:44.640 --> 00:21:45.560
this application--

00:21:45.560 --> 00:21:48.460
and let's keep in mind the SQL
vs. NoSQL ID, because we're

00:21:48.460 --> 00:21:50.310
going to use that in
just a second.

00:21:50.310 --> 00:21:53.550
The next step is I'm going to go
over to the API's console.

00:21:53.550 --> 00:21:57.640
And if you've used the Maps API
or the Translate API, you

00:21:57.640 --> 00:21:59.812
probably have this
already set up.

00:21:59.812 --> 00:22:01.560
I've just created
a new project.

00:22:01.560 --> 00:22:04.710
And so it's telling me that I
need to set up my billing.

00:22:04.710 --> 00:22:07.750
So I'm going to go here to the
Billing tab, and I click on

00:22:07.750 --> 00:22:10.090
the Checkout button and go
through the billing flow.

00:22:10.090 --> 00:22:12.000
I enter in my credit
card information.

00:22:12.000 --> 00:22:14.030
Once I'm done with that, I come
back here to the main

00:22:14.030 --> 00:22:17.200
page, and I can set up my
Cloud SQL instance.

00:22:17.200 --> 00:22:20.190
So I go to the Cloud SQL tab.

00:22:20.190 --> 00:22:22.700
And I don't have any instances
yet, so I click on Create a

00:22:22.700 --> 00:22:24.480
New Instance.

00:22:24.480 --> 00:22:26.760
And it pops up this dialogue for
me, and I need to pick an

00:22:26.760 --> 00:22:29.510
instance name.

00:22:29.510 --> 00:22:33.270
I think I'll come up with
"sql is better."

00:22:33.270 --> 00:22:36.350
And now I need to authorize
that application.

00:22:36.350 --> 00:22:38.110
Oh, I also can pick a size.

00:22:38.110 --> 00:22:40.940
The size basically controls how
much CPU and RAM you're

00:22:40.940 --> 00:22:43.780
going to allocate to
the MySQL process.

00:22:43.780 --> 00:22:46.990
So remembering that application
that we just

00:22:46.990 --> 00:22:50.280
created of SQL vs. NoSQL,
I type that in.

00:22:50.280 --> 00:22:52.730
And I click on Create
The Instance.

00:22:52.730 --> 00:22:54.760
Oh, it wants me to
do a Project ID.

00:22:54.760 --> 00:22:56.350
I type that one in.

00:22:56.350 --> 00:22:59.640
Again, "sql is better," of
course, and I choose this ID.

00:22:59.640 --> 00:23:01.510
And it starts to create
my instance.

00:23:01.510 --> 00:23:05.110
After a few seconds, the MySQL
instance will be provisioned,

00:23:05.110 --> 00:23:07.190
and we'll see a dashboard
like this.

00:23:07.190 --> 00:23:10.290
You can see down here we have a
little bit of storage usage

00:23:10.290 --> 00:23:13.160
already, and that's because
MySQL needs to format some of

00:23:13.160 --> 00:23:15.200
its data files.

00:23:15.200 --> 00:23:18.540
Now we want to get started using
our Cloud SQL instance.

00:23:18.540 --> 00:23:22.220
We have a SQL prompt built into
the web UI that I can

00:23:22.220 --> 00:23:25.030
easily use for simple queries.

00:23:25.030 --> 00:23:27.790
So first thing we need to
do is create a database.

00:23:27.790 --> 00:23:32.500
So I type in CREATE DATABASE,
and I can click on Execute.

00:23:32.500 --> 00:23:33.380
That works just fine.

00:23:33.380 --> 00:23:35.100
Now I need to create a table.

00:23:35.100 --> 00:23:37.280
So I can type in that
SQL statement and

00:23:37.280 --> 00:23:39.520
execute that as well.

00:23:39.520 --> 00:23:41.740
You can imagine how I can
continue to use this to

00:23:41.740 --> 00:23:45.100
populate the data or query
the data as well.

00:23:45.100 --> 00:23:47.540
And if I need to create
development or staging

00:23:47.540 --> 00:23:51.000
instances, I just go through
those last few steps, and

00:23:51.000 --> 00:23:53.210
everything is already
provisioned for me.

00:23:53.210 --> 00:23:57.140
So let's see you make that any
easier for the Datastore.

00:23:57.140 --> 00:23:59.010
ALFRED FULLER: Oh,
it's easier.

00:23:59.010 --> 00:23:59.920
KEN ASHCRAFT: Then show us.

00:23:59.920 --> 00:24:00.600
ALFRED FULLER: Oh,
I don't need to.

00:24:00.600 --> 00:24:02.820
You already showed us
about 20 slides ago.

00:24:02.820 --> 00:24:03.570
KEN ASHCRAFT: Oh.

00:24:03.570 --> 00:24:05.090
ALFRED FULLER: When you created
that app originally,

00:24:05.090 --> 00:24:08.350
the Datastore was ready right
then to accept rights from

00:24:08.350 --> 00:24:08.940
your application.

00:24:08.940 --> 00:24:13.170
There's nothing to provision,
nothing to configure.

00:24:13.170 --> 00:24:14.290
You just start writing data.

00:24:14.290 --> 00:24:16.540
And if you want to use different
tables-- or in the

00:24:16.540 --> 00:24:18.240
Datastore, they're called
"kinds"-- you just define

00:24:18.240 --> 00:24:19.370
those kinds in your code.

00:24:19.370 --> 00:24:20.560
You don't have to tell
the Datastore about

00:24:20.560 --> 00:24:21.480
him ahead of time.

00:24:21.480 --> 00:24:22.620
And you start putting data.

00:24:22.620 --> 00:24:26.890
If you want isolation, you
can use Namespaces for

00:24:26.890 --> 00:24:30.260
multi-tenancy or to isolate
a development instance.

00:24:30.260 --> 00:24:33.790
Or you can even use an entirely
different app to

00:24:33.790 --> 00:24:36.690
completely isolate your
staging instance from

00:24:36.690 --> 00:24:37.710
everything else.

00:24:37.710 --> 00:24:40.920
So let's see what [? Appy ?]
has to say about that.

00:24:40.920 --> 00:24:42.850
Oh, yeah.

00:24:42.850 --> 00:24:43.220
KEN ASHCRAFT: All right.

00:24:43.220 --> 00:24:44.770
I'll let you have another one.

00:24:44.770 --> 00:24:47.000
Let's see what's up
next, though.

00:24:47.000 --> 00:24:47.640
Ah, schema.

00:24:47.640 --> 00:24:48.300
I got this one.

00:24:48.300 --> 00:24:50.500
I got this one.

00:24:50.500 --> 00:24:51.550
All right.

00:24:51.550 --> 00:24:54.510
So the schema's important
because it defines what your

00:24:54.510 --> 00:24:55.240
data looks like.

00:24:55.240 --> 00:24:56.960
What are the data types?

00:24:56.960 --> 00:24:59.310
What are the relationships
between the data?

00:24:59.310 --> 00:25:02.800
And you saw in my recent example
how I created a table.

00:25:02.800 --> 00:25:05.820
Well, in Cloud SQL, this schema
is strictly enforced.

00:25:05.820 --> 00:25:07.800
And that means that you have to
create the table before you

00:25:07.800 --> 00:25:09.400
can start working
with your data.

00:25:09.400 --> 00:25:11.800
And some people think of this
as a benefit of having this

00:25:11.800 --> 00:25:13.280
strictly enforced schema.

00:25:13.280 --> 00:25:15.930
It means that you don't have
typos in your code where you

00:25:15.930 --> 00:25:18.910
write to some non-existent
column, and then when you try

00:25:18.910 --> 00:25:21.610
to read from the column that
you're supposed to read from,

00:25:21.610 --> 00:25:24.170
there's no data there.

00:25:24.170 --> 00:25:26.460
Let me give you an example
of how to do a

00:25:26.460 --> 00:25:27.510
schema change, then.

00:25:27.510 --> 00:25:32.900
Let's go back to our previous
example of a player with a

00:25:32.900 --> 00:25:35.840
name and some integer
amount of health.

00:25:35.840 --> 00:25:37.860
We're going to want to add
magic to this game.

00:25:37.860 --> 00:25:40.040
So we need to add
a mana column.

00:25:40.040 --> 00:25:42.420
All we need to do in
Cloud SQL is alter

00:25:42.420 --> 00:25:44.430
table and add the column.

00:25:44.430 --> 00:25:45.200
Just like that.

00:25:45.200 --> 00:25:47.630
ALFRED FULLER: You know, that
sounds a little too magical.

00:25:47.630 --> 00:25:48.230
KEN ASHCRAFT: You're right.

00:25:48.230 --> 00:25:50.510
We do have to be careful with
these ALTER TABLE statements,

00:25:50.510 --> 00:25:52.450
because they can lock
up the table for the

00:25:52.450 --> 00:25:55.530
duration of the change.

00:25:55.530 --> 00:25:58.160
And the reason why that happens
is that MySQL has

00:25:58.160 --> 00:26:03.260
tightly packed the row data so
that one row is right adjacent

00:26:03.260 --> 00:26:03.760
to the next.

00:26:03.760 --> 00:26:06.660
And when we add that extra
column, there's not room for

00:26:06.660 --> 00:26:09.400
that new field in that
tightly packed space.

00:26:09.400 --> 00:26:12.070
So it needs to copy everything
to a new location.

00:26:12.070 --> 00:26:14.500
So for the duration of the time
that it takes to copy

00:26:14.500 --> 00:26:18.460
everything, you're going
to lock the table up.

00:26:18.460 --> 00:26:22.750
Now there are some tricks that
we can play to minimize this

00:26:22.750 --> 00:26:25.060
lock time or even hide
it entirely.

00:26:25.060 --> 00:26:27.000
And it's called an Online
Schema Change.

00:26:27.000 --> 00:26:29.770
And what we do is we have
our old table, and

00:26:29.770 --> 00:26:30.990
we have a new table.

00:26:30.990 --> 00:26:33.490
We do a background copy of
the data from the old

00:26:33.490 --> 00:26:35.260
table to the new table.

00:26:35.260 --> 00:26:39.160
And while that background copy
is going on, we don't want to

00:26:39.160 --> 00:26:42.260
miss any changes that are
happening to the old table.

00:26:42.260 --> 00:26:45.150
So we set up a trigger on the
old table so that if any of

00:26:45.150 --> 00:26:46.800
those changes come through,
they'll get

00:26:46.800 --> 00:26:48.440
propagated to the new table.

00:26:48.440 --> 00:26:52.660
Once everything is copied, we
just do an atomic rename and

00:26:52.660 --> 00:26:54.070
it just works.

00:26:54.070 --> 00:26:57.030
So if you want to see how that
works, there's a company

00:26:57.030 --> 00:26:57.840
called Percona.

00:26:57.840 --> 00:27:00.880
And they have a tool called
pt-online-schema-change that

00:27:00.880 --> 00:27:03.950
works with MySQL to make
that very, very easy.

00:27:03.950 --> 00:27:06.770
ALFRED FULLER: Well, in the
Datastore, schema changes are

00:27:06.770 --> 00:27:08.190
actually magical.

00:27:08.190 --> 00:27:09.625
Well, not really.

00:27:09.625 --> 00:27:11.100
They're not actually magical.

00:27:11.100 --> 00:27:11.840
You have to do something.

00:27:11.840 --> 00:27:15.870
But the schema enforcement
actually happens---

00:27:15.870 --> 00:27:18.790
or you can enable a schema
enforcement in your code.

00:27:18.790 --> 00:27:20.590
The Datastore doesn't actually
enforce this schema for you.

00:27:20.590 --> 00:27:23.590
What this means is if you want
to add that mana field, all

00:27:23.590 --> 00:27:26.170
you do is change your
code and it's there.

00:27:26.170 --> 00:27:28.420
You can set a default value, and
you can just start using

00:27:28.420 --> 00:27:28.750
this stuff.

00:27:28.750 --> 00:27:32.460
If you need to back fill any
of the previously stored

00:27:32.460 --> 00:27:36.940
entities to, say, do some sort
of complicated calculation to

00:27:36.940 --> 00:27:39.750
figure out what initial mana
every character should have,

00:27:39.750 --> 00:27:42.170
you can do that using the
powerful MapReduce framework

00:27:42.170 --> 00:27:43.840
that I described earlier.

00:27:43.840 --> 00:27:45.630
And let's see how this
one turns out.

00:27:45.630 --> 00:27:46.615
And I win.

00:27:46.615 --> 00:27:50.031
KEN ASHCRAFT: No, it's a tie.

00:27:50.031 --> 00:27:52.690
ALFRED FULLER: Oh, that didn't
turn out how I thought.

00:27:52.690 --> 00:27:53.210
KEN ASHCRAFT: No.

00:27:53.210 --> 00:27:55.880
ALFRED FULLER: Who could
have predicted a tie?

00:27:55.880 --> 00:27:58.210
KEN ASHCRAFT: You know, maybe
there is room for both of our

00:27:58.210 --> 00:27:59.760
products in the world.

00:28:02.330 --> 00:28:05.660
Actually, let me give you an
example of where the Datastore

00:28:05.660 --> 00:28:10.160
probably is a better
fit than Cloud SQL.

00:28:10.160 --> 00:28:13.310
These file sharing applications
are really

00:28:13.310 --> 00:28:14.650
popular nowadays.

00:28:14.650 --> 00:28:16.990
If we wanted to build one, well,
first we need to come up

00:28:16.990 --> 00:28:18.540
with a good name.

00:28:18.540 --> 00:28:23.430
I think the DropRectangle.net
would be a good one.

00:28:23.430 --> 00:28:28.020
If you were to use Cloud SQL
to store this data, this is

00:28:28.020 --> 00:28:31.120
probably how you would structure
your schema.

00:28:31.120 --> 00:28:33.170
You'd have a table
for your users.

00:28:33.170 --> 00:28:34.830
Of course, they'd have
an ID and a name.

00:28:34.830 --> 00:28:37.710
You'd have a table
for your files.

00:28:37.710 --> 00:28:40.700
The owner_id would reference
back to the users.

00:28:40.700 --> 00:28:44.800
And you'd also have a table
for your access control

00:28:44.800 --> 00:28:47.780
specifying who is allowed
to access which files.

00:28:47.780 --> 00:28:50.270
So with this schema, you can
imagine how you could run

00:28:50.270 --> 00:28:53.500
queries like, show me all of the
files that I have access

00:28:53.500 --> 00:28:57.820
to, or atomically transfer
ownership of this file from

00:28:57.820 --> 00:28:59.480
one owner to another.

00:28:59.480 --> 00:29:03.080
And this works great until your
site gets popular and you

00:29:03.080 --> 00:29:06.290
have lots and lots of users and
lots and lots of files.

00:29:06.290 --> 00:29:10.070
And the data no longer fits
on a single machine.

00:29:10.070 --> 00:29:12.450
At that point you can
shard your data.

00:29:12.450 --> 00:29:16.380
And the natural way to shard
the data would be by user.

00:29:16.380 --> 00:29:19.350
Unfortunately, we have this
operation of transferring

00:29:19.350 --> 00:29:21.610
ownership between users.

00:29:21.610 --> 00:29:24.920
And if you shard your data by
user, you don't know whether

00:29:24.920 --> 00:29:27.240
the two users are on
the same shard.

00:29:27.240 --> 00:29:30.290
And if they're not on the same
shard, it gets really hard to

00:29:30.290 --> 00:29:34.000
atomically move that file
ownership between shards.

00:29:34.000 --> 00:29:35.750
And this is where the Datastore
actually would

00:29:35.750 --> 00:29:39.940
probably do better
than Cloud SQL.

00:29:39.940 --> 00:29:43.325
You structure the user
as the root entity.

00:29:43.325 --> 00:29:45.680
You'd have files beneath
that and access

00:29:45.680 --> 00:29:47.930
control underneath that.

00:29:47.930 --> 00:29:52.070
So with the global queries, you
could easily find all the

00:29:52.070 --> 00:29:53.790
files that you have access to.

00:29:53.790 --> 00:29:57.640
And if you want to atomically
transfer files between users,

00:29:57.640 --> 00:30:00.390
you can use the cross-entity
group transactions that Alfred

00:30:00.390 --> 00:30:01.705
described earlier.

00:30:01.705 --> 00:30:03.280
ALFRED FULLER: And you know,
when I was working on this

00:30:03.280 --> 00:30:06.180
presentation with you, it really
became kind of clear to

00:30:06.180 --> 00:30:09.480
me that there are also some
use cases for Cloud SQL,

00:30:09.480 --> 00:30:11.710
especially if you
want to support

00:30:11.710 --> 00:30:12.930
off-the-shelf solutions.

00:30:12.930 --> 00:30:17.240
So there's this entire
ecosystem built up of

00:30:17.240 --> 00:30:19.980
frameworks that are available
that were built to work with

00:30:19.980 --> 00:30:21.680
relational databases.

00:30:21.680 --> 00:30:27.790
And it doesn't always make
sense to modify these

00:30:27.790 --> 00:30:29.490
solutions or roll your
own solutions.

00:30:29.490 --> 00:30:32.230
So if you just want to use these
off the shelf, Cloud SQL

00:30:32.230 --> 00:30:34.370
is obviously a better
choice there.

00:30:34.370 --> 00:30:37.040
KEN ASHCRAFT: So do you think
there are ways that our two

00:30:37.040 --> 00:30:38.960
products could work together?

00:30:38.960 --> 00:30:41.500
ALFRED FULLER: You now, we
have this PM, or product

00:30:41.500 --> 00:30:42.960
manager on our team, Greg.

00:30:42.960 --> 00:30:45.370
He's always sending us these
emails, like selling stuff

00:30:45.370 --> 00:30:45.995
from his garage.

00:30:45.995 --> 00:30:47.090
And I don't know what those--

00:30:47.090 --> 00:30:49.060
KEN ASHCRAFT: He does send
a lot of emails.

00:30:49.060 --> 00:30:52.380
It'd be really great if he had
some sort of web application

00:30:52.380 --> 00:30:55.270
where he could post things for
sale or list things for sale,

00:30:55.270 --> 00:30:58.020
and people could search for
what they want to buy.

00:30:58.020 --> 00:30:58.183
ALFRED FULLER: Yeah, yeah.

00:30:58.183 --> 00:31:00.250
And he could call
it Greg's List.

00:31:00.250 --> 00:31:01.382
KEN ASHCRAFT: That's
a good idea.

00:31:01.382 --> 00:31:03.400
ALFRED FULLER: And if he did
this, what he could do is he

00:31:03.400 --> 00:31:07.210
could use Cloud SQL to store all
of his active listings so

00:31:07.210 --> 00:31:10.480
that you have all the speed of
the in-memory operations and

00:31:10.480 --> 00:31:13.750
in-memory performance
of a single machine.

00:31:13.750 --> 00:31:19.340
And then when a listing expires
or is sold, you can

00:31:19.340 --> 00:31:21.400
use the Datastore to archive
all those listings.

00:31:21.400 --> 00:31:23.380
And they're always available,
and you can still query

00:31:23.380 --> 00:31:25.500
against them, and you could
still use them.

00:31:25.500 --> 00:31:27.530
KEN ASHCRAFT: One of the big
benefits of putting the active

00:31:27.530 --> 00:31:30.320
listings in Cloud SQL would be
that you get to take advantage

00:31:30.320 --> 00:31:33.450
of the powerful query language
and all of those aggregations

00:31:33.450 --> 00:31:36.590
and lots of flexibility so that
you could run queries

00:31:36.590 --> 00:31:38.330
like, show me the
average price of

00:31:38.330 --> 00:31:40.980
a sofa in San Francisco.

00:31:40.980 --> 00:31:43.390
ALFRED FULLER: Yeah, and Cloud
SQL works best when your

00:31:43.390 --> 00:31:45.820
entire data set fits into memory
so it doesn't have to

00:31:45.820 --> 00:31:48.730
page the disk or do any sort
of heavy lifting there.

00:31:48.730 --> 00:31:52.060
And the active set of listings
is relatively small to all the

00:31:52.060 --> 00:31:53.570
listings throughout time.

00:31:53.570 --> 00:31:55.110
So it really makes a lot
of sense to keep

00:31:55.110 --> 00:31:56.620
them in Cloud SQL.

00:31:56.620 --> 00:31:58.780
KEN ASHCRAFT: And storing the
archive listings in the

00:31:58.780 --> 00:32:02.480
Datastore makes sense, because
when you have schema changes,

00:32:02.480 --> 00:32:04.900
you, of course, want to apply
it to the data that you're

00:32:04.900 --> 00:32:06.300
actually going to be working
with, the stuff

00:32:06.300 --> 00:32:07.810
that's in Cloud SQL.

00:32:07.810 --> 00:32:11.090
But all of those archive
listings, you don't really

00:32:11.090 --> 00:32:13.390
want to apply the schema changes
and do the back fill

00:32:13.390 --> 00:32:14.240
and everything.

00:32:14.240 --> 00:32:17.240
And so with the flexible schema
of the Datastore, you

00:32:17.240 --> 00:32:19.432
can get that to work as well.

00:32:19.432 --> 00:32:20.380
Wait, hang on.

00:32:20.380 --> 00:32:23.610
The guys in the back are trying
to say something to me.

00:32:27.070 --> 00:32:31.780
So I guess there's a talk on
BLOB storage after this one.

00:32:31.780 --> 00:32:34.130
And they're worried that we're
running over time.

00:32:34.130 --> 00:32:35.410
And they're kind of
rushing us along.

00:32:35.410 --> 00:32:36.790
ALFRED FULLER: Isn't
that on Friday?

00:32:36.790 --> 00:32:37.310
KEN ASHCRAFT: I know.

00:32:37.310 --> 00:32:39.310
I guess they're worried that if
we run long, then the next

00:32:39.310 --> 00:32:40.890
one's going to run long, and
they're just going to get

00:32:40.890 --> 00:32:42.255
bumped off the schedule
entirely.

00:32:42.255 --> 00:32:43.410
ALFRED FULLER: Oh,
that's rude.

00:32:43.410 --> 00:32:45.120
Can't they just hold up
a sign or something?

00:32:45.120 --> 00:32:45.960
KEN ASHCRAFT: I know, right?

00:32:45.960 --> 00:32:47.150
ALFRED FULLER: And
for BLOB storage?

00:32:47.150 --> 00:32:49.840
More like boring storage.

00:32:49.840 --> 00:32:50.790
KEN ASHCRAFT: Like
that's so hard.

00:32:50.790 --> 00:32:52.075
I can store pictures of cats.

00:32:52.075 --> 00:32:53.250
Yippie.

00:32:53.250 --> 00:32:55.455
ALFRED FULLER: Well, I guess
we better finish up.

00:32:55.455 --> 00:32:58.080
You know, going back to this
scoreboard, it's really clear

00:32:58.080 --> 00:33:01.420
to me that the Datastore does
provide a lot of query

00:33:01.420 --> 00:33:04.330
capability, really good
transactions, a great

00:33:04.330 --> 00:33:05.300
consistency model.

00:33:05.300 --> 00:33:07.660
But if you really want to query
anything and everything,

00:33:07.660 --> 00:33:11.360
or you want to transact on the
world, or you need strong

00:33:11.360 --> 00:33:14.570
consistency for all of your
operations, or you rely on a

00:33:14.570 --> 00:33:17.300
solution that assumes these
things, you really need

00:33:17.300 --> 00:33:18.430
to use Cloud SQL.

00:33:18.430 --> 00:33:20.850
KEN ASHCRAFT: And on the flip
side, Cloud SQL does quite

00:33:20.850 --> 00:33:23.050
well in terms of scalability,
ease of

00:33:23.050 --> 00:33:25.570
management, and schema changes.

00:33:25.570 --> 00:33:28.670
But the Datastore really
shines in these areas--

00:33:28.670 --> 00:33:32.450
super scalable, really flexible
schema management,

00:33:32.450 --> 00:33:33.910
and really easy to
get started.

00:33:33.910 --> 00:33:35.620
ALFRED FULLER: And the best part
is that you can use these

00:33:35.620 --> 00:33:37.400
solutions together.

00:33:37.400 --> 00:33:38.600
KEN ASHCRAFT: That's right.

00:33:38.600 --> 00:33:41.600
ALFRED FULLER: And
closing remarks.

00:33:41.600 --> 00:33:41.970
KEN ASHCRAFT: All right.

00:33:41.970 --> 00:33:44.529
So thanks for taking the time
to come to our talk.

00:33:44.529 --> 00:33:49.380
[APPLAUSE]

00:33:49.380 --> 00:33:50.640
ALFRED FULLER: Yeah, we'd like
to open it up to questions.

00:33:50.640 --> 00:33:52.130
KEN ASHCRAFT: There
are microphones

00:33:52.130 --> 00:33:52.970
in each of the aisles.

00:33:52.970 --> 00:33:55.990
And if you liked the talks,
there are some +1 cards that

00:33:55.990 --> 00:33:58.390
you can drop in the
box at the end.

00:33:58.390 --> 00:33:58.730
ALFRED FULLER: Oh, I didn't
know we were doing that.

00:33:58.730 --> 00:33:59.980
That's high tech.

00:34:02.180 --> 00:34:04.240
KEN ASHCRAFT: Can you use
the microphone, please?

00:34:16.590 --> 00:34:18.210
Sure, go ahead.

00:34:18.210 --> 00:34:20.920
AUDIENCE: In the scheme where
you described that MySQL will

00:34:20.920 --> 00:34:23.690
synchronously replicate to the
slaves before responding to

00:34:23.690 --> 00:34:26.960
the client, what is the range
of latency that we should

00:34:26.960 --> 00:34:31.300
expect, and how does that
compare to the Datastore?

00:34:31.300 --> 00:34:33.260
KEN ASHCRAFT: They're
pretty comparable.

00:34:33.260 --> 00:34:36.610
The latencies would be somewhere
between 50 and 100

00:34:36.610 --> 00:34:37.719
milliseconds.

00:34:37.719 --> 00:34:40.150
ALFRED FULLER: Although, since
Cloud SQL uses a single

00:34:40.150 --> 00:34:44.150
master, it can commit a whole
bunch of inserts at one time,

00:34:44.150 --> 00:34:48.469
so the bandwidth
is much larger.

00:34:48.469 --> 00:34:52.170
AUDIENCE: Is there any thought
being given to readjusting the

00:34:52.170 --> 00:34:55.080
beginning prices
on SQL storage?

00:34:55.080 --> 00:34:59.110
Because it's kind
of right now--

00:34:59.110 --> 00:35:02.460
you can go out and get
third-party storage, which may

00:35:02.460 --> 00:35:06.130
not be Google, but run on
[INAUDIBLE] the $9 a month.

00:35:06.130 --> 00:35:08.680
And you can't get started
for 24 hours for

00:35:08.680 --> 00:35:10.490
less than $38 on this.

00:35:10.490 --> 00:35:15.240
KEN ASHCRAFT: So one of the big
benefits of Cloud SQL is

00:35:15.240 --> 00:35:17.900
the data durability and the fact
that we have synchronous

00:35:17.900 --> 00:35:18.940
replication.

00:35:18.940 --> 00:35:22.320
And the other cloud providers
don't have that.

00:35:22.320 --> 00:35:24.410
And they don't have
that assurance

00:35:24.410 --> 00:35:26.700
that the data is secure.

00:35:26.700 --> 00:35:31.190
ALFRED FULLER: And I've set up
a SQL instance before, and if

00:35:31.190 --> 00:35:34.090
you really want replication and
that kind of durability--

00:35:34.090 --> 00:35:36.220
even if you want to do
asynchronous replication--

00:35:36.220 --> 00:35:37.820
it's a huge pain to set up.

00:35:37.820 --> 00:35:42.360
And Cloud SQL kind of
simplifies all that.

00:35:42.360 --> 00:35:44.330
Robert?

00:35:44.330 --> 00:35:46.630
AUDIENCE: So, I guess my
question is kind of related to

00:35:46.630 --> 00:35:47.450
the first one.

00:35:47.450 --> 00:35:50.450
With the Datastore, the
replication across data

00:35:50.450 --> 00:35:53.190
centers is on an entity
group basis.

00:35:53.190 --> 00:35:57.130
With Cloud SQL, it sounds like
the whole database is

00:35:57.130 --> 00:35:58.610
replicated across.

00:35:58.610 --> 00:36:03.690
Are there any nuances to how
that limits your concurrency

00:36:03.690 --> 00:36:06.120
or anything?

00:36:06.120 --> 00:36:08.210
KEN ASHCRAFT: As mentioned
earlier, your write latencies

00:36:08.210 --> 00:36:10.480
will go up a bit.

00:36:10.480 --> 00:36:13.990
And if you need to do
long-running transactions,

00:36:13.990 --> 00:36:16.810
that can affect you, because
those long-running

00:36:16.810 --> 00:36:19.330
transactions that are doing
writes will hold locks for a

00:36:19.330 --> 00:36:20.580
longer period of time.

00:36:24.400 --> 00:36:28.660
AUDIENCE: So my question is
about the fix the schema from

00:36:28.660 --> 00:36:31.280
the Cloud SQL.

00:36:31.280 --> 00:36:35.280
When we do some operation, like
we add some schema in the

00:36:35.280 --> 00:36:40.860
data storage using the NoSQL
strategy, so how can we map

00:36:40.860 --> 00:36:41.820
the schema back?

00:36:41.820 --> 00:36:44.840
Something I could already change
in the other level.

00:36:44.840 --> 00:36:49.610
But on the top, it's still
fixed to Cloud SQL.

00:36:49.610 --> 00:36:52.780
So how can we handle
this problem?

00:36:52.780 --> 00:36:55.730
KEN ASHCRAFT: So I think the
question was, how can we map

00:36:55.730 --> 00:36:58.910
from a Datastore schema back
to the Cloud SQL schema?

00:36:58.910 --> 00:36:59.340
AUDIENCE: Yes.

00:36:59.340 --> 00:37:03.020
ALFRED FULLER: So we do provide
metadata queries to

00:37:03.020 --> 00:37:05.930
query the live schema that you
have in the Datastore that

00:37:05.930 --> 00:37:08.890
you've decided to have by
putting data in the Datastore.

00:37:08.890 --> 00:37:11.320
And you can use that to
actually automatically

00:37:11.320 --> 00:37:14.610
generate a strict schema
in a MySQL database.

00:37:14.610 --> 00:37:16.790
Or you can decide what
the schema should be.

00:37:16.790 --> 00:37:18.960
And when you're doing the
MapReduce, you can do an

00:37:18.960 --> 00:37:21.970
arbitrary code in the MapReduce,
and you can fix up

00:37:21.970 --> 00:37:24.260
your data and convert it to
whatever schema you need it to

00:37:24.260 --> 00:37:27.550
be in or just drop the data that
doesn't fit your schema.

00:37:30.630 --> 00:37:33.000
AUDIENCE: If you have an
application which runs with

00:37:33.000 --> 00:37:35.490
Datastore and is [INAUDIBLE] in
the Cloud, can you make a

00:37:35.490 --> 00:37:39.080
transaction across
both storages?

00:37:39.080 --> 00:37:40.010
KEN ASHCRAFT: No you cannot.

00:37:40.010 --> 00:37:41.030
They're independent.

00:37:41.030 --> 00:37:43.820
ALFRED FULLER: Yeah, but there
are algorithms you can use to

00:37:43.820 --> 00:37:47.830
make sure that one is eventually
updated in a

00:37:47.830 --> 00:37:49.120
transactional fashion.

00:37:49.120 --> 00:37:51.250
It's guaranteed to be
updated eventually.

00:37:51.250 --> 00:37:55.470
You just have to store some
versioning for, like, what

00:37:55.470 --> 00:37:57.410
version does the Cloud SQL have,
and what version does

00:37:57.410 --> 00:37:58.000
the Datastore have?

00:37:58.000 --> 00:37:59.930
And you can use that
as a basis to make

00:37:59.930 --> 00:38:02.620
sure it gets updated.

00:38:02.620 --> 00:38:05.050
AUDIENCE: We built an
application on App Engine

00:38:05.050 --> 00:38:10.080
using the NoSQL database, and
we wanted to back it up.

00:38:10.080 --> 00:38:12.160
And we weren't worried about
Google losing it.

00:38:12.160 --> 00:38:14.230
We were worried about making
a programming error and

00:38:14.230 --> 00:38:16.080
destroying our own database.

00:38:16.080 --> 00:38:18.820
And it seemed like the only way
to do that was to write a

00:38:18.820 --> 00:38:22.060
custom app that would take
our data down and then

00:38:22.060 --> 00:38:22.680
bring them back up.

00:38:22.680 --> 00:38:25.190
And there were some limitations
on transferring

00:38:25.190 --> 00:38:26.060
large amounts of data.

00:38:26.060 --> 00:38:27.410
It seemed very difficult.

00:38:27.410 --> 00:38:28.970
ALFRED FULLER: Yes, and that's
a problem we're addressing.

00:38:28.970 --> 00:38:31.290
We actually have an
experimental--

00:38:31.290 --> 00:38:33.910
a backup that you can just
enable from the admin console.

00:38:33.910 --> 00:38:36.940
And you can actually use
the cron jobs to

00:38:36.940 --> 00:38:39.110
schedule these backups.

00:38:39.110 --> 00:38:44.150
And you can back them
up to BLOB Store or

00:38:44.150 --> 00:38:45.310
Google Cloud Store.

00:38:45.310 --> 00:38:47.210
And then you can download
those or do whatever

00:38:47.210 --> 00:38:48.780
you want with them.

00:38:48.780 --> 00:38:51.090
And we are working to make
that much better.

00:38:51.090 --> 00:38:52.930
So right now, it runs a
MapReduce that doesn't

00:38:52.930 --> 00:38:55.240
guarantee any sort
of consistency.

00:38:55.240 --> 00:38:56.675
And we're working on solving
that problem.

00:38:59.980 --> 00:39:03.680
AUDIENCE: I started using
Cloud SQL very recently.

00:39:03.680 --> 00:39:07.820
And the tools, they
fall a bit short.

00:39:07.820 --> 00:39:10.720
So I was wondering if there's
any plans to maybe let

00:39:10.720 --> 00:39:15.530
something like phpMyAdmin or
something that's already

00:39:15.530 --> 00:39:19.470
established that we can maybe
map to the Cloud SQL and start

00:39:19.470 --> 00:39:22.110
using that way?

00:39:22.110 --> 00:39:24.950
KEN ASHCRAFT: So the problem is
that we have a proprietary

00:39:24.950 --> 00:39:33.710
connection that uses OAuth to
get into the Google cloud.

00:39:33.710 --> 00:39:36.450
And I recognize that this is
a shortcoming, and it's

00:39:36.450 --> 00:39:38.140
something that we would
like to fix.

00:39:38.140 --> 00:39:42.740
But nothing that I can announce
at this point.

00:39:42.740 --> 00:39:44.550
AUDIENCE: What kind of
availability numbers are you

00:39:44.550 --> 00:39:47.470
offering for each of these?

00:39:47.470 --> 00:39:48.610
KEN ASHCRAFT: What sort
of availability

00:39:48.610 --> 00:39:49.460
numbers are we offering--

00:39:49.460 --> 00:39:51.520
AUDIENCE: How many lines?

00:39:51.520 --> 00:39:54.890
ALFRED FULLER: Availability
numbers for HRD?

00:39:54.890 --> 00:39:57.250
KEN ASHCRAFT: Yeah.

00:39:57.250 --> 00:39:59.520
ALFRED FULLER: It's echoy.

00:39:59.520 --> 00:40:03.360
So right now we have an SLA on
App Engine which includes the

00:40:03.360 --> 00:40:06.100
high replication Datastore
of four and a half nine.

00:40:06.100 --> 00:40:08.840
So 99.994.

00:40:08.840 --> 00:40:11.750
The Datastore itself, actually
it's better than that.

00:40:11.750 --> 00:40:14.240
But the SLA is on the
entire stack.

00:40:14.240 --> 00:40:19.530
So any issue will affect the
numbers as you read them.

00:40:19.530 --> 00:40:23.540
So that's like eight minutes
of downtime per year of

00:40:23.540 --> 00:40:25.800
unexpected downtime
in our timeouts.

00:40:25.800 --> 00:40:28.470
KEN ASHCRAFT: And on the Cloud
SQL side, we do not have an

00:40:28.470 --> 00:40:29.670
SLA at this point.

00:40:29.670 --> 00:40:31.350
ALFRED FULLER: But if you want
to know how that works,

00:40:31.350 --> 00:40:38.090
Definitely "More 9s, Please"
is a good talk on--

00:40:38.090 --> 00:40:38.500
well, sorry.

00:40:38.500 --> 00:40:38.910
It's my talk.

00:40:38.910 --> 00:40:40.996
I shouldn't say that.

00:40:40.996 --> 00:40:45.200
But it goes into a very low
level of the details of how

00:40:45.200 --> 00:40:46.160
that works.

00:40:46.160 --> 00:40:48.430
AUDIENCE: In one of the previous
diagrams, you showed

00:40:48.430 --> 00:40:54.410
that when a write hits the
data center it's getting

00:40:54.410 --> 00:40:56.050
written to multiple
data centers.

00:40:56.050 --> 00:40:57.695
Do you also keep local copies?

00:41:00.270 --> 00:41:03.350
KEN ASHCRAFT: So the way that we
do replication in Cloud SQL

00:41:03.350 --> 00:41:04.790
is at the file system level.

00:41:04.790 --> 00:41:09.000
So we write to a distributed
reliable file system, and then

00:41:09.000 --> 00:41:11.350
we replicate that as well.

00:41:11.350 --> 00:41:16.040
So by writing to the file system
at all, it is writing

00:41:16.040 --> 00:41:17.210
to the local copy.

00:41:17.210 --> 00:41:19.370
ALFRED FULLER: Yeah, and it's
also updating the in-memory

00:41:19.370 --> 00:41:22.940
running instance so that your
reads are incredibly fast.

00:41:22.940 --> 00:41:25.225
It's not like it has to touch
the disk or wait for

00:41:25.225 --> 00:41:28.010
replication or anything
to do reads.

00:41:28.010 --> 00:41:30.410
AUDIENCE: I was wondering if
you're keeping multiple local

00:41:30.410 --> 00:41:33.780
copies other than relying on
multiple data centers to

00:41:33.780 --> 00:41:34.850
[? archive ?] the copies.

00:41:34.850 --> 00:41:37.820
ALFRED FULLER: So Google File
System, which is also a

00:41:37.820 --> 00:41:42.390
foundation of Cloud SQL,
manages that type

00:41:42.390 --> 00:41:44.770
of stuff for us.

00:41:44.770 --> 00:41:47.120
I don't know how much detail
I can go into there.

00:41:47.120 --> 00:41:49.010
KEN ASHCRAFT: That's fine.

00:41:49.010 --> 00:41:50.760
AUDIENCE: Hi, my question
actually ties in a

00:41:50.760 --> 00:41:51.550
little bit with you.

00:41:51.550 --> 00:41:55.620
I work with developing one
of the [INAUDIBLE] for--

00:41:55.620 --> 00:41:58.820
sorry, I shouldn't mention
the name--

00:41:58.820 --> 00:42:01.010
a development tool for MySQL
and I would love to

00:42:01.010 --> 00:42:02.340
support Cloud SQL.

00:42:02.340 --> 00:42:05.130
Is there a .NET driver for it?

00:42:05.130 --> 00:42:05.825
KEN ASHCRAFT: There
is a document.

00:42:05.825 --> 00:42:07.720
It's a JDBC driver.

00:42:07.720 --> 00:42:11.340
You can also get one in
Python, though our

00:42:11.340 --> 00:42:12.560
documentation isn't so great.

00:42:12.560 --> 00:42:13.805
AUDIENCE: So no .NET driver?

00:42:13.805 --> 00:42:14.380
ALFRED FULLER: .NET, no.

00:42:14.380 --> 00:42:15.510
KEN ASHCRAFT: Oh, sorry.

00:42:15.510 --> 00:42:15.790
.NET.

00:42:15.790 --> 00:42:16.190
I thought you said

00:42:16.190 --> 00:42:21.180
"documented." No, no .NET driver.

00:42:21.180 --> 00:42:23.700
AUDIENCE: Given that the driver
is open source for

00:42:23.700 --> 00:42:28.450
MySQL, once you've
authenticated, is it the same

00:42:28.450 --> 00:42:30.410
transport layer as MySQL?

00:42:30.410 --> 00:42:31.390
KEN ASHCRAFT: No, it's
not the same.

00:42:31.390 --> 00:42:31.670
AUDIENCE: OK.

00:42:31.670 --> 00:42:33.530
So it's a completely
different driver.

00:42:33.530 --> 00:42:34.770
It's nothing that--

00:42:34.770 --> 00:42:37.365
any plans on developing
a .NET driver?

00:42:40.100 --> 00:42:42.700
KEN ASHCRAFT: We would like to
support the MySQL protocol and

00:42:42.700 --> 00:42:46.340
make it much easier so that it
doesn't matter what language

00:42:46.340 --> 00:42:48.380
you're actually running in.

00:42:48.380 --> 00:42:50.790
You just can connect to
something that looks like

00:42:50.790 --> 00:42:52.380
MySQL and it just works.

00:42:52.380 --> 00:42:53.630
AUDIENCE: OK thank you.

00:42:56.370 --> 00:42:57.620
ALFRED FULLER: Any
more questions.

00:42:59.675 --> 00:43:00.110
Wow.

00:43:00.110 --> 00:43:01.740
We're well ahead of time.

00:43:01.740 --> 00:43:02.220
KEN ASHCRAFT: All right.

00:43:02.220 --> 00:43:03.470
Thank you so much for coming.

