WEBVTT
Kind: captions
Language: en

00:00:02.340 --> 00:00:03.340
&gt;&gt;Boris Smus: Hi, folks.

00:00:03.340 --> 00:00:04.340
&gt;&gt;&gt; Hey!
&gt;&gt;Boris Smus: All right.

00:00:04.340 --> 00:00:09.200
Welcome to Point, Click, Tap, Touch, a session
about building multi-device web interfaces.

00:00:09.200 --> 00:00:15.280
My name is Boris, and I'm a research engineer
working on user interfaces in the Google research

00:00:15.280 --> 00:00:16.280
group.

00:00:16.280 --> 00:00:17.280
&gt;&gt;Rick Byers: And I'm Rick.

00:00:17.280 --> 00:00:21.500
I work on touchscreen support in Chrome and
I'm a member of the W3C standards groups working

00:00:21.500 --> 00:00:23.580
on standardizing touchscreen support on the
web.

00:00:23.580 --> 00:00:29.650
&gt;&gt;Boris Smus: So today's talk is mostly going
to be about input and we'll talk a bit about

00:00:29.650 --> 00:00:34.260
mouse space input but the bulk of it is going
to be about touchscreens.

00:00:34.260 --> 00:00:38.440
So just to motivate that, I'm sure you've
all got a touchscreen device, or maybe two,

00:00:38.440 --> 00:00:44.560
or maybe three, now that you've got Pixels,
and so touch is becoming even more ubiquitous

00:00:44.560 --> 00:00:46.880
than it was a year ago.

00:00:46.880 --> 00:00:52.130
Mobile touch -- mobile use in general is projected
to overtake the desktop sometime early next

00:00:52.130 --> 00:00:57.670
year, and the revenue forecast of touchscreen
modules only corroborate that.

00:00:57.670 --> 00:01:01.940
You can see it's a very up-and-to-the-right
kind of graph.

00:01:01.940 --> 00:01:07.549
Also we've got this new -- relatively new
form factor of touch laptops, of which the

00:01:07.549 --> 00:01:12.979
Pixel is one, and also Windows -- Windows
machines are becoming increasingly touch-enabled.

00:01:12.979 --> 00:01:18.869
Something like a quarter of Windows 8 laptop
sales have a touchscreen.

00:01:18.869 --> 00:01:24.420
So if you're a developer working on the web,
you should expect your users to have a touchscreen

00:01:24.420 --> 00:01:26.219
device increasingly.

00:01:26.219 --> 00:01:30.600
And the good thing here is that the web has
a very powerful touch event API and it's been

00:01:30.600 --> 00:01:35.560
around for something like five, six years
and has become standard over the last two

00:01:35.560 --> 00:01:40.759
years or so, and the basics of this API is
we've got a touchstart event which fires when

00:01:40.759 --> 00:01:46.039
your finger hits the screen, touchmove continually
fires as you're moving around, touchend and

00:01:46.039 --> 00:01:49.249
touchcancel are two different ways of ending
that interaction.

00:01:49.249 --> 00:01:53.709
So touchend is the natural thing that happens
when your finger is raised and touchcancel

00:01:53.709 --> 00:01:59.039
happens if your finger was -- if your touch
gesture was cancelled for some other reason.

00:01:59.039 --> 00:02:05.400
On Android, for example, if you start scrolling
an area, touchcancel will fire as the browser

00:02:05.400 --> 00:02:08.709
begins to scroll.

00:02:08.709 --> 00:02:15.489
So to distinguish between these multiple touches,
each one has a consistent identifier, and

00:02:15.489 --> 00:02:21.770
this API that I'm describing works really
well across a number of devices.

00:02:21.770 --> 00:02:25.040
Basically across the whole modern mobile browser
landscape.

00:02:25.040 --> 00:02:27.239
So let me quickly show you how this looks.

00:02:27.239 --> 00:02:32.500
On a Pixel, which is what I'm demoing from,
I've got this paint application.

00:02:32.500 --> 00:02:39.129
You can see that as soon as I lower my fingers,
I can do this amazing finger-painting exercise.

00:02:39.129 --> 00:02:46.069
And we support up to 10 points and you can
see each finger has a unique color which is

00:02:46.069 --> 00:02:47.640
because they have unique IDs.

00:02:47.640 --> 00:02:55.359
Now, if I didn't have a touchscreen, I could
emulate this behavior with just a mouse, and

00:02:55.359 --> 00:03:01.450
you can see I can override this by turning
on emulate touch events in the Chrome developer

00:03:01.450 --> 00:03:07.530
tools, and when I do that, I get this little
finger-like thing on the screen every time

00:03:07.530 --> 00:03:08.530
I move the mouse.

00:03:08.530 --> 00:03:13.510
And it's just a good reminder that says, "Hey,
there's a certain size to your finger," that

00:03:13.510 --> 00:03:14.790
it's not as precise as your mouse.

00:03:14.790 --> 00:03:16.739
And I'll talk more about that.

00:03:16.739 --> 00:03:24.840
Now, of course because this is a standard
API, it works just as well across a variety

00:03:24.840 --> 00:03:32.180
of devices, so here I've got the same exact
code running on a phone, and you can see that

00:03:32.180 --> 00:03:37.480
the behavior of this application is the same.

00:03:37.480 --> 00:03:41.250
Okay.

00:03:41.250 --> 00:03:46.840
So I'll run through a couple of design suggestions,
because designing for touch is quite different

00:03:46.840 --> 00:03:52.260
from designing for mouse and keyboard.

00:03:52.260 --> 00:03:58.219
So the first tip here is obviously touch interfaces
require bigger targets.

00:03:58.219 --> 00:04:03.499
Your finger is inherently far less precise
than a mouse, which can give you one- or two-pixel

00:04:03.499 --> 00:04:06.599
precision, but exactly how big?

00:04:06.599 --> 00:04:10.800
So extensive research has been done to suggest
that 9-by-9 millimeters is something like

00:04:10.800 --> 00:04:18.079
the optimal touch target size, but the web
has a few things that complicate matters.

00:04:18.079 --> 00:04:25.039
First, we've got a whole variety of devices
to support, and they vary hugely in their

00:04:25.039 --> 00:04:31.160
device density, so DPI varies, and therefore
it's hard to map physical size to device pixels.

00:04:31.160 --> 00:04:36.480
And secondly, the web has this concept of
CSS pixels not necessarily being the same

00:04:36.480 --> 00:04:41.530
as device pixels because they're modified
by something called device Pixel ratio.

00:04:41.530 --> 00:04:47.080
So with these two things in mind, we can do
some calculations for a variety of popular

00:04:47.080 --> 00:04:48.080
devices.

00:04:48.080 --> 00:04:52.930
Here we've got the Nexus line where we convert
9 millimeters into pixels and we can see what

00:04:52.930 --> 00:04:55.400
that looks like on these devices.

00:04:55.400 --> 00:05:02.310
On the Chromebook Pixel, it's something -- because
of further distance of interaction, you end

00:05:02.310 --> 00:05:12.610
up with screwy -- with a slightly bigger -- with
fewer pixels required to represent the same

00:05:12.610 --> 00:05:14.069
physical size.

00:05:14.069 --> 00:05:19.210
So while we don't have like a clear guideline
in this case of what size you should use,

00:05:19.210 --> 00:05:22.729
something between 42 and 58 pixels is our
recommendation.

00:05:22.729 --> 00:05:28.150
And this is fairly consistent with other guidelines.

00:05:28.150 --> 00:05:31.180
Second tip is related to hover.

00:05:31.180 --> 00:05:36.319
So hover we can activate in two ways, generally
with a mouse-based interface, so with CSS,

00:05:36.319 --> 00:05:41.550
using the colon hover pseudo-selector and
with JavaScript using mouseover and mouseout

00:05:41.550 --> 00:05:42.550
events.

00:05:42.550 --> 00:05:48.669
With touchscreens, generally, with some exceptions
like the Samsung S4 which has above-surface

00:05:48.669 --> 00:05:53.130
hover, basically we don't have access to hover
state.

00:05:53.130 --> 00:05:57.740
And even in the case of the S4, that hover
state is only in hardware and available in

00:05:57.740 --> 00:05:58.740
Android.

00:05:58.740 --> 00:06:00.900
It's not exposed to the web yet.

00:06:00.900 --> 00:06:07.460
So what do we do in the case of -- in the
case of touch for hover?

00:06:07.460 --> 00:06:12.330
Basically, here's an example of a hover test
page.

00:06:12.330 --> 00:06:14.060
We've got two hover areas.

00:06:14.060 --> 00:06:16.419
One of them has a link, the other does not.

00:06:16.419 --> 00:06:19.030
And I can just activate hover by -- by tapping.

00:06:19.030 --> 00:06:23.800
So a single tap activates hover on mobile
devices with touchscreens.

00:06:23.800 --> 00:06:28.210
The problem is if you have a hover and a link
underlying that.

00:06:28.210 --> 00:06:33.479
So in this case, if I click this area that
has a link, the hover state was triggered

00:06:33.479 --> 00:06:37.580
but for so brief a time that the user didn't
actually get to see it.

00:06:37.580 --> 00:06:42.810
So this happens a lot when you have menus,
hierarchical menus that are activated on hover,

00:06:42.810 --> 00:06:46.599
and it's something to definitely avoid.

00:06:46.599 --> 00:06:49.129
Okay.

00:06:49.129 --> 00:06:55.159
The last designing kind of thing that I want
to talk about is the touch laptop form factor

00:06:55.159 --> 00:06:59.289
and the kind of untapped potential that this
form factor can bring.

00:06:59.289 --> 00:07:01.780
So there's two sort of axes here.

00:07:01.780 --> 00:07:07.910
First, we can think about switching between
these two modalities of touch and not touch,

00:07:07.910 --> 00:07:11.020
and it might look something like this.

00:07:11.020 --> 00:07:14.949
So here's a gallery of photos.

00:07:14.949 --> 00:07:21.539
In this case, I've got photos of celebrities.

00:07:21.539 --> 00:07:29.289
You can see it's a very standard kind of interface
and I can pick new pictures with my mouse.

00:07:29.289 --> 00:07:30.490
It's great.

00:07:30.490 --> 00:07:35.629
So what happens if I want to use a touch device,
or my touchscreen in this case?

00:07:35.629 --> 00:07:38.000
This is way too small for me to tap.

00:07:38.000 --> 00:07:43.480
So you can see if -- as soon as I tap this
-- this page, I get this responsive input

00:07:43.480 --> 00:07:47.710
effect and now everything is far more tappable.

00:07:47.710 --> 00:07:50.650
So when I switch back to mouse, the page readjusts
back.

00:07:50.650 --> 00:07:55.509
So this is an interesting concept that you
might want to explore.

00:07:55.509 --> 00:08:00.689
Another possibility is to use both modes together.

00:08:00.689 --> 00:08:06.340
So in this page, I have a map that I have
pointer-locked so whenever I pan around with

00:08:06.340 --> 00:08:14.160
my trackpad or pinch zoom -- or sorry, two-finger
scroll, I can navigate the map.

00:08:14.160 --> 00:08:18.220
And I can also place waypoints on this map
using my touchscreen.

00:08:18.220 --> 00:08:24.190
So it's sort of an interesting interaction
using both -- both touch surfaces simultaneously.

00:08:24.190 --> 00:08:29.830
And along the same veins, in this example
I have a small green rectangle that I can

00:08:29.830 --> 00:08:36.520
move around as you'd expect, but I can also
simultaneously move my trackpad to rotate

00:08:36.520 --> 00:08:41.010
it and with two fingers I'll create a scaling
effect.

00:08:41.010 --> 00:08:42.420
And I can do these things simultaneously.

00:08:42.420 --> 00:08:46.600
So it's kind of an interesting interaction
that's only possible with these two touch

00:08:46.600 --> 00:08:50.820
surfaces simultaneously.

00:08:50.820 --> 00:08:56.780
So with that, I'll hand over to Rick to talk
about some common problems and their solutions.

00:08:56.780 --> 00:09:01.290
&gt;&gt;Rick Byers: So in getting the Pixel ready
to ship, we worked with a lot of different

00:09:01.290 --> 00:09:05.160
web properties to help them make their Web
sites that were designed for desktop work

00:09:05.160 --> 00:09:06.160
better with touch.

00:09:06.160 --> 00:09:09.220
So what I want to go through here is some
of the common issues that we came across that

00:09:09.220 --> 00:09:10.800
people hit regularly.

00:09:10.800 --> 00:09:13.950
The first one is this code.

00:09:13.950 --> 00:09:16.990
Does anyone realize off the bat what the problem
is with this code?

00:09:16.990 --> 00:09:19.140
&gt;&gt; (Speaker is off microphone.)

00:09:19.140 --> 00:09:20.750
&gt;&gt;Rick Byers: Right.

00:09:20.750 --> 00:09:23.030
If you use it on a Pixel, you can't use the
trackpad.

00:09:23.030 --> 00:09:24.500
And really this isn't about the Pixel.

00:09:24.500 --> 00:09:29.320
This code was -- you know, the assumption
here is if I've got touch support, like in

00:09:29.320 --> 00:09:33.310
particular the touch event APIs are supported
on this browser, then I must be on a mobile

00:09:33.310 --> 00:09:35.010
device and I shouldn't listen to mouse events.

00:09:35.010 --> 00:09:36.420
And this was actually never correct.

00:09:36.420 --> 00:09:40.060
BlackBerry devices have a little trackball
that sends mouse events, so this would also

00:09:40.060 --> 00:09:41.320
disable that.

00:09:41.320 --> 00:09:43.390
But this is really bad for touchscreen laptops.

00:09:43.390 --> 00:09:46.880
It means someone's got their laptop and they
upgrade to their spiffy new touchscreen laptop

00:09:46.880 --> 00:09:50.500
and now a site that they're used to using
with their trackpad no longer works with the

00:09:50.500 --> 00:09:51.710
trackpad.

00:09:51.710 --> 00:09:54.560
Just because someone has a touchscreen on
their laptop doesn't mean they're going to

00:09:54.560 --> 00:09:55.560
use it all the time.

00:09:55.560 --> 00:10:00.081
In fact, a lot of users only use it for special
circumstances, like maps and whatnot, and

00:10:00.081 --> 00:10:02.880
it really varies how much people use their
touchscreen on their laptop.

00:10:02.880 --> 00:10:07.490
So you really don't want to disable mouse
support just because there's touch support.

00:10:07.490 --> 00:10:09.460
Let me show you an example of that.

00:10:09.460 --> 00:10:13.330
Not to pick on any particular site in particular,
but this page, this site, just to show you

00:10:13.330 --> 00:10:18.220
how frustrating it is, I move my mouse over
these buttons and clearly I should be able

00:10:18.220 --> 00:10:21.940
to click on these, but when I click, nothing
happens, and it's really frustrating and you

00:10:21.940 --> 00:10:23.370
say, "Why the heck can't I click on this?"

00:10:23.370 --> 00:10:28.300
Until you realize, "Oh, actually, I can tap
with touch."

00:10:28.300 --> 00:10:35.100
And that's just because they've stopped listening
to the click event because it detects a touchscreen.

00:10:35.100 --> 00:10:36.690
So don't do that.

00:10:36.690 --> 00:10:38.190
So how do you -- what do you do instead?

00:10:38.190 --> 00:10:41.410
So when you limit, don't try to predict whether
or not the user is going to do touch.

00:10:41.410 --> 00:10:42.940
In the limit, you can't predict it.

00:10:42.940 --> 00:10:46.970
For example, they might have a USB touchscreen
that's connected to a KVM switch, so it might

00:10:46.970 --> 00:10:50.490
come and go during the lifetime of the page,
so you can't predict whether or not the user's

00:10:50.490 --> 00:10:51.490
going to use touch.

00:10:51.490 --> 00:10:54.840
Instead, what you should do is always listen
for touch events and mouse events and then

00:10:54.840 --> 00:10:58.390
you can decide dynamically, when you see a
touch event get used, then you know the user

00:10:58.390 --> 00:10:59.840
is using touch.

00:10:59.840 --> 00:11:04.330
So in this case, we listened for both all
the time, and I think the main reason people

00:11:04.330 --> 00:11:08.940
don't do this is for compatibility, touch
events by default, if I tap the screen, it

00:11:08.940 --> 00:11:13.640
will send a series of mouse events to emulate
a mouse click, so all these Web sites that

00:11:13.640 --> 00:11:17.380
were designed just for mouse will still work
by tapping the touchscreen.

00:11:17.380 --> 00:11:21.050
And so I think the reason people stop listening
for mouse events is they want to avoid hitting

00:11:21.050 --> 00:11:25.530
that redundant click event, but the right
way to do that is when you've consumed a touch

00:11:25.530 --> 00:11:28.530
event is to call preventDefault on the event.

00:11:28.530 --> 00:11:31.370
PreventDefault tells the browser "I've handled
this, please don't do something else with

00:11:31.370 --> 00:11:32.370
it."

00:11:32.370 --> 00:11:34.600
And this is generally what you want to do
anyway in most scenarios.

00:11:34.600 --> 00:11:38.700
You know, if you're using touch to manipulate
an object, you don't want the browser to also

00:11:38.700 --> 00:11:42.610
use that touch to pan the page, scroll the
page, for example.

00:11:42.610 --> 00:11:45.390
So let me show you concretely what that looks
like.

00:11:45.390 --> 00:11:50.180
This is a really simple application that just
registers an event handler on this blue box

00:11:50.180 --> 00:11:54.790
here, so you can see if I move my mouse over,
it just lists the events that are fired.

00:11:54.790 --> 00:12:01.450
So if I touch and drag, I get touchstart,
touchmove, and then -- oops -- if I touch

00:12:01.450 --> 00:12:05.370
and drag, you can see I get touchmove and
then touchend.

00:12:05.370 --> 00:12:11.500
But if I tap on this, you see I get touchstart,
touchend, as you'd expect, but then I also

00:12:11.500 --> 00:12:15.060
get this compatibility mouse move -- mousedown,
mouseout click -- sequence that's emulated

00:12:15.060 --> 00:12:16.180
in the click.

00:12:16.180 --> 00:12:21.500
So to prevent that, I just go into my event
handler here and say ease out preventDefault,

00:12:21.500 --> 00:12:24.540
just say "I've handled the event, please don't
do anything else with it."

00:12:24.540 --> 00:12:30.190
And now when I tap I just get the touch events.

00:12:30.190 --> 00:12:34.730
So if you leave here knowing -- remembering
nothing else, this is the most important thing:

00:12:34.730 --> 00:12:38.950
Don't make your users suffer just because
they happen to have a touchscreen.

00:12:38.950 --> 00:12:41.111
And now that you all have Pixels, this will
probably become pretty obvious to you.

00:12:41.111 --> 00:12:42.111
Try it at your sites.

00:12:42.111 --> 00:12:43.950
Now, you don't have to have a Pixel to test
this out.

00:12:43.950 --> 00:12:48.080
So those of you watching the extended or on
YouTube that weren't as lucky to get a Pixel

00:12:48.080 --> 00:12:52.630
yet, just go to Chrome flags and turn on enable
touch events.

00:12:52.630 --> 00:12:56.010
We'd actually like to -- we'd actually like
Chrome to always support touch events and

00:12:56.010 --> 00:13:00.350
the only reason we don't today is because
so many Web sites have this bug, but hopefully

00:13:00.350 --> 00:13:02.520
at some point in the future we'll make this
the default mode.

00:13:02.520 --> 00:13:05.260
So you should turn this on and test your Web
sites to make sure the mouse still works on

00:13:05.260 --> 00:13:08.890
your Web sites with this on.

00:13:08.890 --> 00:13:17.200
Another problem we see a lot is there's a
subtle difference in how the events are targeted,

00:13:17.200 --> 00:13:21.550
so a lot of people will often in many scenarios
want to delegate to the same code for touch

00:13:21.550 --> 00:13:26.001
and mouse, and there's a difference between
the mouse event model and the touch event

00:13:26.001 --> 00:13:28.610
model in where the events go.

00:13:28.610 --> 00:13:32.170
So as you probably know, with the mouse if
I move my mouse cursor over like this blue

00:13:32.170 --> 00:13:37.500
rectangle here and press down and then drag
outside the rectangle, I'll get a mousedown,

00:13:37.500 --> 00:13:42.450
some mouse moves, and a mouseout event targeted
at the rectangle, and then -- and then I'll

00:13:42.450 --> 00:13:45.700
continue receiving events on whatever the
background element is, the white element in

00:13:45.700 --> 00:13:46.700
this case.

00:13:46.700 --> 00:13:49.380
It will get the mouseover, mousemoves, and
mouseup when I lift.

00:13:49.380 --> 00:13:51.390
This isn't the same for touch.

00:13:51.390 --> 00:13:56.320
For touch, the events always target the node
where the touch started, as opposed to the

00:13:56.320 --> 00:13:58.980
node that's currently under the cursor as
for mouse.

00:13:58.980 --> 00:14:03.900
So for touch, if I touch on this blue rectangle
and drag across and lift, the touch old events

00:14:03.900 --> 00:14:05.850
are going to go to the rectangle, including
the end.

00:14:05.850 --> 00:14:08.250
And this make a lot of sense for common scenarios.

00:14:08.250 --> 00:14:10.310
I've got a slider that I'm manipulating with
touch.

00:14:10.310 --> 00:14:13.500
You'd really rather not have to worry about
what happens if the user's finger falls off

00:14:13.500 --> 00:14:15.221
the slider slightly as they're sliding it.

00:14:15.221 --> 00:14:19.000
It make sense to say conceptually when the
user starts touching something, they're manipulating

00:14:19.000 --> 00:14:21.250
that thing for the duration of their touch.

00:14:21.250 --> 00:14:24.830
But this gets tricky if you think about what
if -- what if you have got a container with

00:14:24.830 --> 00:14:28.130
some elements inside of it and it's changing
over time.

00:14:28.130 --> 00:14:33.800
In particular, what if the element the user
touched on happens to get deleted while the

00:14:33.800 --> 00:14:34.920
user's in the middle of their touch.

00:14:34.920 --> 00:14:40.180
And this actually happened to me in some code
I was working on, and I was really surprised.

00:14:40.180 --> 00:14:42.450
I didn't know what was going on.

00:14:42.450 --> 00:14:44.690
What happens is we followed this model.

00:14:44.690 --> 00:14:47.140
The events continue to go to the element where
you started touching.

00:14:47.140 --> 00:14:49.670
Even if that element is no longer in the DOM,
that's where the events go.

00:14:49.670 --> 00:14:52.790
They'll bubble up to the point that there's
no ancestor and they'll fall on the floor.

00:14:52.790 --> 00:14:58.730
So if you've got an event handler on the container,
you're not going to get the events once the

00:14:58.730 --> 00:15:02.800
inner node is removed, and that will look
to your app like a finger is just stuck down.

00:15:02.800 --> 00:15:09.990
I've got a demo of that, so this is a really
simple app that just transforms this rectangle

00:15:09.990 --> 00:15:11.780
to match with my touch events.

00:15:11.780 --> 00:15:15.450
And this is -- this works fine because it's
just a simple rectangle.

00:15:15.450 --> 00:15:19.530
But, you know, if this was a ticker or something
with some changing content inside of it or

00:15:19.530 --> 00:15:22.230
a list of email or something, then it would
be more complicated.

00:15:22.230 --> 00:15:27.260
So I'm going to simulate that by just adding
this red div every two seconds and then deleting

00:15:27.260 --> 00:15:28.750
it and then adding a new one.

00:15:28.750 --> 00:15:33.390
So if I happen to start touching on the red
div and drag around, as soon as the red div's

00:15:33.390 --> 00:15:37.540
removed from the DOM, it's what's receiving
the events and so the container doesn't know

00:15:37.540 --> 00:15:42.870
about the events anymore and it thinks my
finger is stuck down and now my code gets

00:15:42.870 --> 00:15:43.870
confused.

00:15:43.870 --> 00:15:46.190
If I try to touch it again, it's confused
because it missed the end.

00:15:46.190 --> 00:15:47.190
It never got an end.

00:15:47.190 --> 00:15:49.640
You see I got touchstart and I got another
touchstart, which is really confusing for

00:15:49.640 --> 00:15:51.180
the code.

00:15:51.180 --> 00:15:55.640
So to fix that, an easy way to fix it is to
just take my event handlers here, my move,

00:15:55.640 --> 00:15:57.100
end, and cancel event handlers.

00:15:57.100 --> 00:15:59.550
Really I don't want those on the container.

00:15:59.550 --> 00:16:03.420
In this case, I want to take them -- instead
of putting them on the container, I can go

00:16:03.420 --> 00:16:10.100
up here to my touchstart handler and I'll
put the event handlers instead on whatever

00:16:10.100 --> 00:16:13.750
the target of the touchstart was.

00:16:13.750 --> 00:16:16.520
So in this case, it's going to be -- if I
started touching on the red element, it's

00:16:16.520 --> 00:16:17.560
going to be on the red element.

00:16:17.560 --> 00:16:21.870
Now, in theory you might also want to go and
remove these event handlers and the end event

00:16:21.870 --> 00:16:25.000
but actually it's not necessary because adding
the same event handler more than once is a

00:16:25.000 --> 00:16:26.000
"no op."

00:16:26.000 --> 00:16:28.380
So there's no disadvantage here to just adding
them and leaving them there.

00:16:28.380 --> 00:16:32.050
So now you can see if I start touching this
red guy, now it's removed from the DOM.

00:16:32.050 --> 00:16:36.560
It doesn't really exist anywhere except it's
being kept alive by the events that are being

00:16:36.560 --> 00:16:40.840
sent to it, and so the JavaScript code can
still be fired and see those events even though

00:16:40.840 --> 00:16:45.850
the node is not reachable in the DOM anywhere.

00:16:45.850 --> 00:16:50.730
So that's how to fix that one.

00:16:50.730 --> 00:16:53.160
Just like that.

00:16:53.160 --> 00:16:55.990
Another common problem is dealing with small
targets.

00:16:55.990 --> 00:16:59.970
Lots of the web is designed for a mouse today,
so the browser's got to do something to make

00:16:59.970 --> 00:17:03.070
it easier for touchscreen users to hit small
things.

00:17:03.070 --> 00:17:07.220
If we just relied on looking at the center
point of your finger, it would be way too

00:17:07.220 --> 00:17:08.220
small.

00:17:08.220 --> 00:17:11.299
As Boris said, you know, you ideally have
larger targets.

00:17:11.299 --> 00:17:15.120
But if it's a site that's designed for a mouse
or if you want to try to strike some compromise

00:17:15.120 --> 00:17:18.919
on your site where you don't want things to
be giant, then the browser's got to do something

00:17:18.919 --> 00:17:22.610
to make it easier for people to touch large
-- touch small targets.

00:17:22.610 --> 00:17:26.069
So what Chrome does, it's got a feature called
touch adjustment, and what it does, the green

00:17:26.069 --> 00:17:29.730
rectangle here represents the bounding box
of my touch.

00:17:29.730 --> 00:17:33.710
You know, using the radius from the hardware
on Pixel, we know the radius of the touch,

00:17:33.710 --> 00:17:37.500
but if we don't know the radius on other hardware,
we can use a suitable default.

00:17:37.500 --> 00:17:41.600
And then we look at all of the elements inside
that bounding box and we look at -- we'd find

00:17:41.600 --> 00:17:45.450
every one that has some signal that it's activatable
by tapping somehow.

00:17:45.450 --> 00:17:50.039
So it's got a click event handler or it's
got an active CSS pseudo-class.

00:17:50.039 --> 00:17:53.159
Anything that we expect something will happen
when it's tapped.

00:17:53.159 --> 00:17:58.740
And we score those based on how far away the
edge of that element is from the center of

00:17:58.740 --> 00:18:02.789
the touch and how much of that element gets
overlapped by the touch.

00:18:02.789 --> 00:18:06.510
And we pick the one with the highest score
and then we adjust the touch.

00:18:06.510 --> 00:18:07.701
We don't change the raw touch events.

00:18:07.701 --> 00:18:08.900
Touch events are a low-level API.

00:18:08.900 --> 00:18:10.679
We don't want to muck with those.

00:18:10.679 --> 00:18:13.200
But for the compatibility of most events,
we'll shift them.

00:18:13.200 --> 00:18:18.230
We'll change what element is targeted and
we'll change the coordinates so that it actually

00:18:18.230 --> 00:18:20.360
gets delivered to what we think the user is
trying to touch.

00:18:20.360 --> 00:18:23.150
Let me show you that in a demo.

00:18:23.150 --> 00:18:26.610
Oh, pro tip, by the way, for all of you with
your new Pixels.

00:18:26.610 --> 00:18:27.610
Control shift plus.

00:18:27.610 --> 00:18:30.730
We haven't put in the UI yet but we have a
nice UI restore feature.

00:18:30.730 --> 00:18:32.620
You can zoom in and out the whole Chrome OS
UI.

00:18:32.620 --> 00:18:37.371
So I'm going to do that for this demo and
show you -- well, let me just show -- if I

00:18:37.371 --> 00:18:41.179
just tap here, I've got the rectangle showing
where my tap was, and the blue shows where

00:18:41.179 --> 00:18:46.230
the click event went, and in this case, there's
nothing touchable underneath so there's nothing

00:18:46.230 --> 00:18:48.279
unusual here.

00:18:48.279 --> 00:18:51.960
And if I tap on top of a link, again, there's
nothing really unusual.

00:18:51.960 --> 00:18:55.629
But if I tap on the boundary of a link like
this, you can see my touchend event, which

00:18:55.629 --> 00:19:01.750
is the red dot, occurred on the "x" and "t"
in the word "text" here and down in the log

00:19:01.750 --> 00:19:06.179
you can see the touchend event occurred on
this ID called "content," which is the text

00:19:06.179 --> 00:19:07.720
content.

00:19:07.720 --> 00:19:12.350
But I overlapped the link and so the browser
sees that overlap and it adjusts the click

00:19:12.350 --> 00:19:15.820
event, so that the click is actually going
to the link, which is the blue dot next to

00:19:15.820 --> 00:19:16.820
it.

00:19:16.820 --> 00:19:19.340
And there's also two different signals that
we use so, you know, the link is the obvious

00:19:19.340 --> 00:19:23.900
one but anything with a hover effect, like
right here, this text turns red when you hover

00:19:23.900 --> 00:19:27.940
on top of it, so you can see I'm adjusting
down towards it.

00:19:27.940 --> 00:19:29.639
Or something with a tab index, right?

00:19:29.639 --> 00:19:33.889
A tab index indicates that you can focus it
by tapping -- by clicking on it or activating

00:19:33.889 --> 00:19:34.889
it.

00:19:34.889 --> 00:19:37.860
Or even just a mousedown event handler because
we fired those on tap as well.

00:19:37.860 --> 00:19:40.890
These are all signals to tell us that something
is touchable.

00:19:40.890 --> 00:19:46.279
And so this works great most of the time,
but it is possible to confuse it.

00:19:46.279 --> 00:19:50.669
In particular, we need some signal that -- that
what you've got is designed to be activated

00:19:50.669 --> 00:19:56.270
somehow, and if you're relying on event delegation,
so for example, you've got an event handler

00:19:56.270 --> 00:20:01.050
on your entire document and then in JavaScript
you're deciding, oh, this event actually really

00:20:01.050 --> 00:20:05.450
was on this element and I'm imperatively in
JavaScript going to rewrite the event to the

00:20:05.450 --> 00:20:10.970
right element, that gives the browsers no
real signal of -- of where -- what is touchable

00:20:10.970 --> 00:20:13.450
and what isn't.

00:20:13.450 --> 00:20:17.720
Not only is that going to disable touch adjustment,
but if there's other signals like hover effect

00:20:17.720 --> 00:20:21.789
and active effects, it might actually make
touch adjustment behave worse than not having

00:20:21.789 --> 00:20:22.789
it at all.

00:20:22.789 --> 00:20:24.299
My favorite example of this is Gmail, unfortunately.

00:20:24.299 --> 00:20:26.519
And we will get this fixed at some point soon.

00:20:26.519 --> 00:20:27.519
Oops.

00:20:27.519 --> 00:20:30.070
Let me go back here.

00:20:30.070 --> 00:20:33.250
So I can tap these stars and activate them,
no problem.

00:20:33.250 --> 00:20:38.269
And that's because the star in its unactive
state has a hover effect that makes it look

00:20:38.269 --> 00:20:40.740
slightly different when you hover over it.

00:20:40.740 --> 00:20:42.299
So it looks tappable to us.

00:20:42.299 --> 00:20:44.470
Every time I touch near it, it will adjust
towards it.

00:20:44.470 --> 00:20:48.409
If I try to tap to turn off the star, it is
incredibly frustrating.

00:20:48.409 --> 00:20:50.289
I just keep hitting the things next to it.

00:20:50.289 --> 00:20:54.020
That's because these other things on either
side of it appear to us to be tappable, but

00:20:54.020 --> 00:20:58.360
there is no longer any signal on the star
telling us that it is tappable.

00:20:58.360 --> 00:21:01.260
Gmail is using event delegations, so there
is no event handler on it and there is no

00:21:01.260 --> 00:21:05.590
longer a hover effect or anything to tell
us it is random background content.

00:21:05.590 --> 00:21:13.720
And so we don't think it is something the
user is trying to touch.

00:21:13.720 --> 00:21:17.149
Another question I get a lot is how should
you recognize more complex gestures like pinch

00:21:17.149 --> 00:21:19.490
or rotate.

00:21:19.490 --> 00:21:23.320
Mobile Safari has a proprietary API for this
called gestureevent.

00:21:23.320 --> 00:21:28.010
And IE10 has a proprietary API for this called
MSGestureevent.

00:21:28.010 --> 00:21:32.210
So in Chrome, we are not going to add another
proprietary gesture API.

00:21:32.210 --> 00:21:34.249
We think proprietary APIs are bad for the
Web.

00:21:34.249 --> 00:21:36.639
We would love to have a standardized API that
works across all browsers.

00:21:36.639 --> 00:21:41.070
[ Applause ]
That's the first time I got a applause for

00:21:41.070 --> 00:21:42.610
not doing a feature.

00:21:42.610 --> 00:21:45.480
I love it.

00:21:45.480 --> 00:21:47.850
We love to have a standard API that all browsers
can implement.

00:21:47.850 --> 00:21:52.740
But for various reasons, that's not going
to happen any time soon.

00:21:52.740 --> 00:21:55.980
So -- but the good news is, you actually don't
need the browser to do this for you.

00:21:55.980 --> 00:21:59.650
This is something that can be done perfectly
well by libraries, built on top of the touch

00:21:59.650 --> 00:22:00.650
events.

00:22:00.650 --> 00:22:02.240
There is a wide variety of different libraries.

00:22:02.240 --> 00:22:05.230
And then you can use one of these libraries
and have it work across all these browsers,

00:22:05.230 --> 00:22:07.740
not have to worry about the differences in
the browsers.

00:22:07.740 --> 00:22:11.980
So I wrote a little demo here using hammer.js
which exposes a whole slew of different types

00:22:11.980 --> 00:22:13.570
of gestures.

00:22:13.570 --> 00:22:16.749
But the transform gesture in particular recognizes
pinch and rotate.

00:22:16.749 --> 00:22:19.070
Let me just show you what this looks like.

00:22:19.070 --> 00:22:24.909
So with a very small amount of code, I can
handle moving this box around, pinching it

00:22:24.909 --> 00:22:26.870
to zoom it, and rotating it.

00:22:26.870 --> 00:22:28.409
I haven't had to listen to touch events at
all.

00:22:28.409 --> 00:22:32.679
I have just done this and listened for transformer
events and imported the hammer library.

00:22:32.679 --> 00:22:36.590
So if you want to do it with gestures, I encourage
you to explore these libraries and contribute

00:22:36.590 --> 00:22:37.590
to them.

00:22:37.590 --> 00:22:39.890
Most of them I believe are open source projects.

00:22:39.890 --> 00:22:45.289
Much better than a proprietary browser API
in my opinion.

00:22:45.289 --> 00:22:49.289
And now back to Boris to talk about performance.

00:22:49.289 --> 00:22:52.690
&gt;&gt;Boris Smus: All right.

00:22:52.690 --> 00:22:58.259
So, one performance issue you may have seen
are heard of is this infamous click delay.

00:22:58.259 --> 00:23:04.210
So the idea here is the clicks on mobile browsers
are generally delayed by something like 300

00:23:04.210 --> 00:23:08.299
milliseconds because the browser needs to
decide if your click was a genuine click or

00:23:08.299 --> 00:23:10.269
if it was actually a double tap.

00:23:10.269 --> 00:23:13.830
So there is this gesture where you want to
zoom into some content that's very small and

00:23:13.830 --> 00:23:16.340
you double tapped that and the browser zooms
in.

00:23:16.340 --> 00:23:22.270
And so This behavior can cause pages to feel
very slow and unresponsive.

00:23:22.270 --> 00:23:25.480
And if you have been working in this space,
you have probably heard of fastclick as a

00:23:25.480 --> 00:23:26.899
solution for this.

00:23:26.899 --> 00:23:31.880
What fastclick basically does is instead of
using click, it uses just the touchend event,

00:23:31.880 --> 00:23:34.059
which is something we described earlier.

00:23:34.059 --> 00:23:39.929
So, of course, you know now that there's some
drawbacks to using touchend versus click such

00:23:39.929 --> 00:23:43.610
as the touchfuzzing that Rick described earlier.

00:23:43.610 --> 00:23:47.150
And you lose that if you use a fastclick library.

00:23:47.150 --> 00:23:51.789
In cases where we don't need a fastclick library,
we should avoid it.

00:23:51.789 --> 00:23:55.419
A couple things also changed over the last
year or os in Chrome.

00:23:55.419 --> 00:24:02.169
Firstly, Chrome desktop, which has touch support
in some cases, like in this Pixel or on Windows

00:24:02.169 --> 00:24:06.720
devices, there's no click delay because we
don't actually support the double tap to zoom

00:24:06.720 --> 00:24:07.720
gesture.

00:24:07.720 --> 00:24:10.190
&gt;&gt;Rick Byers: That's another feature, by the
way, we are never going to support because

00:24:10.190 --> 00:24:11.509
we are not going to add 300 milliseconds to
the click events.

00:24:11.509 --> 00:24:12.509
&gt;&gt;Boris Smus: Excellent.

00:24:12.509 --> 00:24:15.490
&gt;&gt;Rick Byers: If I have anything to say about
it.

00:24:15.490 --> 00:24:16.490
Sorry.

00:24:16.490 --> 00:24:19.620
&gt;&gt;Boris Smus: In Chrome for Android, we have
an optimization that landed over the last

00:24:19.620 --> 00:24:25.909
year that doesn't create a click delay in
the case of a fixed viewport.

00:24:25.909 --> 00:24:29.039
So you can fix your viewport with user scalable
equals no.

00:24:29.039 --> 00:24:32.230
And in that case, again, the double tap gesture
doesn't exist.

00:24:32.230 --> 00:24:33.590
So there is no need for us to delay.

00:24:33.590 --> 00:24:37.620
So it is important that the fastclick library
that you use is aware of these changes.

00:24:37.620 --> 00:24:39.539
Otherwise, you lose the benefits.

00:24:39.539 --> 00:24:44.929
So we worked with FT Labs, which support one
of the most popular fastclick libraries.

00:24:44.929 --> 00:24:50.140
And they've patched their code to make sure
that their library is smart about this.

00:24:50.140 --> 00:24:56.509
So keep that in mind next time you're using
a fastclick approach.

00:24:56.509 --> 00:24:59.499
Okay.

00:24:59.499 --> 00:25:04.210
Another performance issue, you may have written
or seen code that looks like this.

00:25:04.210 --> 00:25:09.559
So this code essentially just renders every
time you get a touchmove event.

00:25:09.559 --> 00:25:14.340
The problem with this is that touchmove can
fire very quickly.

00:25:14.340 --> 00:25:20.889
Often it fires much faster than your render
loop, which is 60 hertz if you're getting

00:25:20.889 --> 00:25:25.559
a smooth performance -- smooth visual display.

00:25:25.559 --> 00:25:32.140
In some browsers, this problem is mitigated
by coalescing multiple touch events into one.

00:25:32.140 --> 00:25:34.619
So there's touch arrays that come with every
touch event.

00:25:34.619 --> 00:25:40.940
And it is up to the browser, basically, to
decide if it should put all the events together

00:25:40.940 --> 00:25:44.009
or if it should create separate touchmove
events.

00:25:44.009 --> 00:25:52.919
So let me just quickly show you here on a
mobile device the possible issue.

00:25:52.919 --> 00:25:58.009
So here I've got some code that basically
does this naive approach where it renders

00:25:58.009 --> 00:25:59.009
everything on touch.

00:25:59.009 --> 00:26:00.559
You can see I have got one finger.

00:26:00.559 --> 00:26:03.650
I'm just drawing the point and that works
really well.

00:26:03.650 --> 00:26:06.850
I can add a second finger and a third finger.

00:26:06.850 --> 00:26:09.100
You can sort of see the slowdown now.

00:26:09.100 --> 00:26:13.349
But as I add the fourth finger, things really
degrade.

00:26:13.349 --> 00:26:14.349
&gt;&gt;&gt; Ahhh.

00:26:14.349 --> 00:26:17.999
&gt;&gt;Boris Smus: So this is not what we want.

00:26:17.999 --> 00:26:22.880
[ Laughter ]
So touch events are piling up and, basically,

00:26:22.880 --> 00:26:26.389
we're not able to render quickly enough and
there is a big backlog of touches which is

00:26:26.389 --> 00:26:29.889
why you see this delay.

00:26:29.889 --> 00:26:39.309
So the solution to this is to avoid expense
operations in your touch handlers.

00:26:39.309 --> 00:26:40.919
In general, this is good practice.

00:26:40.919 --> 00:26:43.320
But this is especially important for touch.

00:26:43.320 --> 00:26:47.700
So rather than rendering, you can store the
touches and then set up a separate animation

00:26:47.700 --> 00:26:52.620
loop with something like requestAnimationframe
which makes sure that every single render

00:26:52.620 --> 00:26:56.500
is tied to the vsync of your display.

00:26:56.500 --> 00:27:00.419
Just by doing this small optimization, let
me show you the difference.

00:27:00.419 --> 00:27:03.779
So I will switch to the requestAnimationframe
version.

00:27:03.779 --> 00:27:07.490
There we go.

00:27:07.490 --> 00:27:14.289
And you can see that same four-finger gesture
is now extremely responsive just with that

00:27:14.289 --> 00:27:18.559
one small change.

00:27:18.559 --> 00:27:22.090
Okay.

00:27:22.090 --> 00:27:25.110
Another performance issue is related to scroll
jank.

00:27:25.110 --> 00:27:30.799
So in case you are not familiar with scroll
jank, the basic idea is sometimes scrolling

00:27:30.799 --> 00:27:36.120
can be very uneven and just not be very responsive
to your actual input.

00:27:36.120 --> 00:27:37.950
This can come in many forms.

00:27:37.950 --> 00:27:42.750
But we've done some studies, and it's very
important for engagement.

00:27:42.750 --> 00:27:49.230
So if your users are dealing with a janky
site, it's likely that they won't come back.

00:27:49.230 --> 00:27:52.929
And Chrome team has spent a lot of effort
of trying to optimize this scrolling.

00:27:52.929 --> 00:27:59.600
And the big push has been to move scrolling
to a separate hardware-accelerated GPU thread.

00:27:59.600 --> 00:28:02.690
Event handling, though, is still, of course,
on the main thread.

00:28:02.690 --> 00:28:08.450
So there's something that can happen if you
have fairly busy main thread because every

00:28:08.450 --> 00:28:14.129
time you scroll, as Rick pointed out earlier,
you can prevent the default behavior of the

00:28:14.129 --> 00:28:15.210
scroll.

00:28:15.210 --> 00:28:18.590
And the way we do that is in JavaScript by
using event prevent default.

00:28:18.590 --> 00:28:23.989
What happens is every time you scroll, we
need to call back -- well, Chrome calls back

00:28:23.989 --> 00:28:27.450
into the main thread to see if it is allowed
to.

00:28:27.450 --> 00:28:32.520
And if the main thread is really busy, that
causes the GPU thread to wait.

00:28:32.520 --> 00:28:33.850
So here's how this looks.

00:28:33.850 --> 00:28:39.090
I have got an artificially busy main thread
in this page.

00:28:39.090 --> 00:28:42.239
And I have also enabled an empty touchmove
handler.

00:28:42.239 --> 00:28:43.320
So it just it looks like this.

00:28:43.320 --> 00:28:46.220
It is a no op.

00:28:46.220 --> 00:28:54.970
And if you see me scrolling here, my finger
is moving smoothly, it's very janky.

00:28:54.970 --> 00:29:00.509
So by simply turning this off, I have a very
different experience.

00:29:00.509 --> 00:29:03.639
And that's a no op touch handler.

00:29:03.639 --> 00:29:06.789
So what's the story here?

00:29:06.789 --> 00:29:08.149
How can we avoid this?

00:29:08.149 --> 00:29:14.529
Well, first, and quite obviously, we can just
not use that touch event handler.

00:29:14.529 --> 00:29:18.710
If it is unnecessary, there's no need for
you to put it there and you will save -- you

00:29:18.710 --> 00:29:20.999
will save yourself from seeing this issue
at all.

00:29:20.999 --> 00:29:28.619
And, of course, remember that in some cases,
it's not so bad to have -- to rely on synthesized

00:29:28.619 --> 00:29:33.240
DOM events like click, scroll, and context
menu which all fire on touch devices.

00:29:33.240 --> 00:29:39.139
So, basically, what I'm saying is, you don't
need to implement touch-specific event handlers

00:29:39.139 --> 00:29:43.389
necessarily to have a good experience on touchscreens.

00:29:43.389 --> 00:29:48.460
And another approach to solving this problem
is if you definitely do need a touch handler,

00:29:48.460 --> 00:29:52.889
make sure you've contained that touch region
to be as small as possible.

00:29:52.889 --> 00:29:59.149
So Chrome has optimizations that says if the
part of the page that the user is scrolling

00:29:59.149 --> 00:30:03.159
doesn't have a touch handler, then there is
no need for us to call back to the main thread.

00:30:03.159 --> 00:30:05.639
And we can just do the thing very quickly.

00:30:05.639 --> 00:30:10.789
So, essentially, if you think of your page
-- if you think of subdividing your page into

00:30:10.789 --> 00:30:17.070
regions, you can decide whether or not you
want to optimize for smooth scrolling or for

00:30:17.070 --> 00:30:18.869
touch event handling.

00:30:18.869 --> 00:30:24.419
So this example that I showed you earlier
is the worst case where you've got a touch

00:30:24.419 --> 00:30:28.179
handler on your whole body for not good reason.

00:30:28.179 --> 00:30:29.360
Okay.

00:30:29.360 --> 00:30:32.919
Back to Rick.

00:30:32.919 --> 00:30:37.600
&gt;&gt;Rick Byers: So we told you a bit about the
state of touch on the Web today.

00:30:37.600 --> 00:30:42.379
I want to touch briefly on some of the directions
that we want to head going forward.

00:30:42.379 --> 00:30:47.059
So, first of all, here's just a rough idea
of some of the goals that we've got.

00:30:47.059 --> 00:30:50.149
First of all, as we talked before, touch events
are pretty low-level API.

00:30:50.149 --> 00:30:54.090
And a lot of times you want to express your
intent in a higher-level fashion.

00:30:54.090 --> 00:30:57.169
So we would like to do more to eliminate the
need for you to drop down to this low-level

00:30:57.169 --> 00:30:58.169
API.

00:30:58.169 --> 00:31:03.029
For example, a really common scenario is to
want to support dragging things around, right,

00:31:03.029 --> 00:31:04.289
drag and drop-type UIs.

00:31:04.289 --> 00:31:08.489
There is actually a high-level drag and drop
API for the Web today.

00:31:08.489 --> 00:31:11.070
Unfortunately, it is only implemented from
mouse.

00:31:11.070 --> 00:31:15.019
Every browser that's drag and drop only does
it with mouse input, which seems a real shame.

00:31:15.019 --> 00:31:17.369
So we are starting to experiment with this
in Chrome OS.

00:31:17.369 --> 00:31:18.379
You can try it on your Pixel.

00:31:18.379 --> 00:31:19.679
You can turn it on in "about" flags.

00:31:19.679 --> 00:31:21.559
It is touch-based drag and drop.

00:31:21.559 --> 00:31:24.179
Long press will initiate a drag and drop.

00:31:24.179 --> 00:31:31.529
And we are hoping we will get that on by default
in M29, which is coming up in a little bit.

00:31:31.529 --> 00:31:33.999
And then once we're happy with it there, we
will turn it on in the other platforms as

00:31:33.999 --> 00:31:37.440
well, Android and Windows.

00:31:37.440 --> 00:31:40.929
We also want to give you more control over
the browser's default behavior so you don't

00:31:40.929 --> 00:31:42.419
have to fall back to touch events.

00:31:42.419 --> 00:31:45.789
A really common scenario with touch events
is an image carousel where you want to support

00:31:45.789 --> 00:31:47.990
swiping between the different images.

00:31:47.990 --> 00:31:52.639
And really that's just a scrollable div except
that you really want to snap where it stops

00:31:52.639 --> 00:31:54.490
to image boundaries.

00:31:54.490 --> 00:31:57.529
And so what people end up doing is they use
a library or they write custom code to listen

00:31:57.529 --> 00:32:01.200
for touch events and then they have to implement
all the scrolling themselves, which doesn't

00:32:01.200 --> 00:32:04.929
sound that bad until you realize that there
is a certain physics that people are used

00:32:04.929 --> 00:32:08.600
to and they are used to a certain momentum
when you fling and then trying to match that

00:32:08.600 --> 00:32:12.580
to the browser's behavior which is changing
in between browsers is very hard.

00:32:12.580 --> 00:32:16.119
And then this whole -- all the work we do
to try to do to scroll on a GPU thread so

00:32:16.119 --> 00:32:19.239
we're not subject to jank for the main thread,
all that goes out the window when you implement

00:32:19.239 --> 00:32:20.929
scrolling in JavaScript.

00:32:20.929 --> 00:32:23.309
So we love for common scrolling scenarios
like that.

00:32:23.309 --> 00:32:26.809
We would like to just give you features that
let you customize the behavior like add snap

00:32:26.809 --> 00:32:27.809
points.

00:32:27.809 --> 00:32:32.029
IE10 has a feature for this, so we are talking
with Microsoft about how we can standardize

00:32:32.029 --> 00:32:35.759
that and bring it to the standard Web.

00:32:35.759 --> 00:32:40.909
And we're working with other browser vendors
to bring new Web standards to help with touch

00:32:40.909 --> 00:32:41.909
as well.

00:32:41.909 --> 00:32:46.980
So, in particular, IE10 has a number of touch
features that are pretty nice.

00:32:46.980 --> 00:32:50.039
So we're talking with Microsoft about those.

00:32:50.039 --> 00:32:52.529
In particular, pointer events is a new input
model in IE10.

00:32:52.529 --> 00:32:55.820
IE10 doesn't support the touch event model
that we have been talking throughout this

00:32:55.820 --> 00:32:56.820
slide for.

00:32:56.820 --> 00:32:58.880
They have got a different input model called
pointer events.

00:32:58.880 --> 00:33:01.999
It has some design properties that we are
pretty excited about.

00:33:01.999 --> 00:33:05.600
First of all, it abstracts different types
of input.

00:33:05.600 --> 00:33:08.639
You still need to think to think about touch
and mouse separately when you are designing

00:33:08.639 --> 00:33:09.639
your site.

00:33:09.639 --> 00:33:11.399
Sometimes the right thing to do is to handle
them the same.

00:33:11.399 --> 00:33:14.531
If the right thing to do is to handle touch
and mouse the same, you should be able to

00:33:14.531 --> 00:33:17.309
use the same code to do it.

00:33:17.309 --> 00:33:20.549
This model extends the mouse even model, which
means if you have already got a big investment

00:33:20.549 --> 00:33:24.590
in code that's designed for the mouse model,
you can -- rather than having to worry about

00:33:24.590 --> 00:33:28.320
things like the difference in targeting model
and the lack of over-and-out events, you can

00:33:28.320 --> 00:33:30.710
update that code to work with point events
very easily.

00:33:30.710 --> 00:33:33.539
We would love to see more discussion on pointer
events.

00:33:33.539 --> 00:33:36.600
This is the mailing list for the standards
group.

00:33:36.600 --> 00:33:37.779
Love to hear discussion there.

00:33:37.779 --> 00:33:41.840
The implementation, obviously, IE has implementation
and Firefox has said they have started to

00:33:41.840 --> 00:33:43.179
work on an implementation.

00:33:43.179 --> 00:33:46.529
Microsoft built a prototype for Chrome, which
is great.

00:33:46.529 --> 00:33:50.739
And now we have just announced that we're
going to start landing some experimental support

00:33:50.739 --> 00:33:53.999
in Blink for pointer events.

00:33:53.999 --> 00:33:58.380
But adding a new input model isn't something
we take lightly especially when it is redundant

00:33:58.380 --> 00:34:02.720
with existing models and not necessarily something
that browser vendors are going to embrace.

00:34:02.720 --> 00:34:08.260
We are starting by adding some features that
are going to make it easy to build high-performance,

00:34:08.260 --> 00:34:10.440
high-quality polyfills for pointer events.

00:34:10.440 --> 00:34:12.450
And then we really want to get feedback from
you guys.

00:34:12.450 --> 00:34:16.550
We want to see if you vote with your feet
by using the polyfills and send us signals

00:34:16.550 --> 00:34:21.100
that you really want this model natively in
the browser, then we will add it to Chrome.

00:34:21.100 --> 00:34:22.820
So today there is a few early polyfills.

00:34:22.820 --> 00:34:27.320
None of them are perfect, Butt hey are all
pretty good and a good way to get a handle

00:34:27.320 --> 00:34:29.950
on how pointer events work.

00:34:29.950 --> 00:34:35.300
If you went to the Web components talk earlier,
the application of Web components, the polymer

00:34:35.300 --> 00:34:38.770
framework, they decided that pointer events
was the right input model for polymer.

00:34:38.770 --> 00:34:46.700
So they built a polyfill that emulates pointer
events that you can use completely independently.

00:34:46.700 --> 00:34:48.620
So please check those out and send us feedback.

00:34:48.620 --> 00:34:51.919
I will not go into full details of the pointer
events API.

00:34:51.919 --> 00:34:53.590
Microsoft has a bunch of good links.

00:34:53.590 --> 00:34:55.320
There's lots of full talks on their own.

00:34:55.320 --> 00:34:57.900
I want to touch on two things I'm particularly
excited about.

00:34:57.900 --> 00:35:02.810
First of all, I said that you can -- they
let you specify declaratively what to do with

00:35:02.810 --> 00:35:03.810
touch.

00:35:03.810 --> 00:35:05.540
And this is done through a CSS property called
touch action.

00:35:05.540 --> 00:35:08.980
When you say touch action none, it means you
don't want the browser to take a default action

00:35:08.980 --> 00:35:10.540
on touch, like scrolling.

00:35:10.540 --> 00:35:12.410
And instead you just want to deliver events.

00:35:12.410 --> 00:35:16.480
Where if you say touch action auto, then that
means you want the browser to determine what

00:35:16.480 --> 00:35:17.480
to do.

00:35:17.480 --> 00:35:19.890
So, for example, as soon as you start scrolling,
the browser says I'm supposed to scroll now

00:35:19.890 --> 00:35:23.250
and it can start scrolling immediately and
just send a cancel event to JavaScript to

00:35:23.250 --> 00:35:25.700
say you will not get any more events now that
these started scrolling.

00:35:25.700 --> 00:35:27.890
And it doesn't have to block on the main thread.

00:35:27.890 --> 00:35:31.510
So that scroll jank problem that Boris showed
which can be a real problem especially on

00:35:31.510 --> 00:35:37.610
mobile devices just goes away completely with
this.

00:35:37.610 --> 00:35:39.770
I also said that this can be better for code
sharing.

00:35:39.770 --> 00:35:44.930
We want to enable you to build sites that
work well across a range of devices.

00:35:44.930 --> 00:35:47.090
And so let me show you an example here.

00:35:47.090 --> 00:35:54.630
This is a really simple demo of -- this is
a really simple demo of drag and drop that's

00:35:54.630 --> 00:35:56.550
kind of modeled after the Google+ circle editor.

00:35:56.550 --> 00:36:01.910
The idea is I can touch on a card and drag
it -- let me get all three of the circles

00:36:01.910 --> 00:36:05.330
-- touch on a card and drag it to one of these
circles.

00:36:05.330 --> 00:36:07.280
This is designed to work with multiple inputs.

00:36:07.280 --> 00:36:12.800
I can touch two cards at once, or I can even
use a mouse and touchscreen at once to drag

00:36:12.800 --> 00:36:14.440
things around.

00:36:14.440 --> 00:36:16.920
And so let me show you what was involved to
make this work.

00:36:16.920 --> 00:36:17.920
There's a bit of code here.

00:36:17.920 --> 00:36:18.940
I won't go through all of it.

00:36:18.940 --> 00:36:22.160
The move handlers perhaps is the most interesting.

00:36:22.160 --> 00:36:26.250
When the mouse moves, I just have a little
bit of work to do really and then I delegate

00:36:26.250 --> 00:36:27.850
to this common move function.

00:36:27.850 --> 00:36:32.760
But when I get a touchmove event, I am going
to delegate to the common move function.

00:36:32.760 --> 00:36:35.490
But then I have got to do a lot of other stuff
to compensate for the difference in targeting

00:36:35.490 --> 00:36:36.900
model.

00:36:36.900 --> 00:36:39.120
This is all specific to the touchmodel.

00:36:39.120 --> 00:36:42.630
And then the common function for handling
movements is, like, a couple of lines.

00:36:42.630 --> 00:36:45.380
It is unfortunate, this is the only thing
I can do in common.

00:36:45.380 --> 00:36:47.350
The start and end events are like that as
well.

00:36:47.350 --> 00:36:50.730
It is a pretty small amount of common code
for the two cases.

00:36:50.730 --> 00:36:57.150
If I use pointer events, I can get the amount
of shared code for about half the lines of

00:36:57.150 --> 00:37:00.780
code being shared for the two scenarios up
to 97% in this case.

00:37:00.780 --> 00:37:04.560
And get the number of lines of code I had
to write down from 131 down to 89.

00:37:04.560 --> 00:37:06.540
Let me show you what that looks like.

00:37:06.540 --> 00:37:10.870
In this case, since Chrome here doesn't have
pointer event support, I'm using the points.js

00:37:10.870 --> 00:37:12.300
polyfill.

00:37:12.300 --> 00:37:18.220
So with much less code, now I can still support
dragging things around with touch and a mouse

00:37:18.220 --> 00:37:20.350
simultaneously.

00:37:20.350 --> 00:37:23.600
And you can see that there is very little
code here that to handle the difference between

00:37:23.600 --> 00:37:24.700
mouse events and pointer events.

00:37:24.700 --> 00:37:27.360
I basically just have to check to see if the
browser supports pointer events.

00:37:27.360 --> 00:37:31.650
If so, I will use events that start with the
word "pointer" instead of the word "mouse."

00:37:31.650 --> 00:37:33.450
Otherwise, the events are the same.

00:37:33.450 --> 00:37:38.500
And in order to handle multiple things moving
around at once, if I'm using pointer events,

00:37:38.500 --> 00:37:40.280
I'm using the unique identifier for pointer.

00:37:40.280 --> 00:37:43.900
Otherwise, if I am using mouse events, I will
just use this constant one.

00:37:43.900 --> 00:37:45.670
And, otherwise, all the code is the same.

00:37:45.670 --> 00:37:48.970
The move event handler is just this here.

00:37:48.970 --> 00:37:51.500
And then I have over-and-out handlers.

00:37:51.500 --> 00:37:55.110
And so for this scenario where I really want
the same thing to happen regardless the type

00:37:55.110 --> 00:37:59.630
of input, I can dramatically reduce the amount
of code I have to write and have to test,

00:37:59.630 --> 00:38:00.630
which is a big part of it.

00:38:00.630 --> 00:38:01.630
That's a big part of it.

00:38:01.630 --> 00:38:03.230
So those are the reasons that I'm exciting
about pointer events.

00:38:03.230 --> 00:38:06.760
We would love to get your feedback, start
using the polyfills.

00:38:06.760 --> 00:38:11.860
And, hopefully, we will see it in Chrome at
some point in the future.

00:38:11.860 --> 00:38:13.400
That's it for the future.

00:38:13.400 --> 00:38:17.310
And we have given you a few tips now for how
to make your site work great on touch.

00:38:17.310 --> 00:38:21.500
Now that you all have Pixels, please try out
your Web sites and apply these tips and make

00:38:21.500 --> 00:38:24.920
your sites awesome on touchscreen laptops.

00:38:24.920 --> 00:38:27.630
If you have any problems doing that, we want
to hear about them.

00:38:27.630 --> 00:38:30.360
This is an area of the Web we are trying to
make better and make more consistent across

00:38:30.360 --> 00:38:31.720
different form factors and different browsers.

00:38:31.720 --> 00:38:33.550
So, please, we want to hear about it.

00:38:33.550 --> 00:38:37.780
The public Web events mailing list, this the
group of the W3C that I'm a member of that

00:38:37.780 --> 00:38:40.150
works on touch events.

00:38:40.150 --> 00:38:42.850
That's a great mailing list to give us feedback
on the touch event model.

00:38:42.850 --> 00:38:47.570
You can also reach out to me directly on Google+
or Twitter.

00:38:47.570 --> 00:38:50.780
And Boris and I are going to be to available
to take questions.

00:38:50.780 --> 00:38:53.280
We have got, like, one minute, I guess.

00:38:53.280 --> 00:38:56.180
Why don't we take one question from our extended
audience.

00:38:56.180 --> 00:39:00.340
We have got thousands of people watching around
the world and take one quick question.

00:39:00.340 --> 00:39:04.060
Please submit feedback using this URL, and
then we will be down here to take any live

00:39:04.060 --> 00:39:06.650
questions.

00:39:06.650 --> 00:39:08.300
You got the Dory up?

00:39:08.300 --> 00:39:09.640
Do we have any?

00:39:09.640 --> 00:39:13.000
&gt;&gt;Boris Smus: Maybe a live question, how's
that?

00:39:13.000 --> 00:39:14.000
We'll take one.

00:39:14.000 --> 00:39:16.070
&gt;&gt;Rick Byers: One live question.

00:39:16.070 --> 00:39:18.030
Okay.

00:39:18.030 --> 00:39:22.860
&gt;&gt;&gt; Do you know we're awesome?

00:39:22.860 --> 00:39:23.860
&gt;&gt;Rick Byers: We do now.

00:39:23.860 --> 00:39:24.860
Thank you very much.

00:39:24.860 --> 00:39:25.860
&gt;&gt;Boris Smus: Thank you very much.

00:39:25.860 --> 00:39:26.860
[ Applause ]
&gt;&gt;&gt; You were talking at the beginning about

00:39:26.860 --> 00:39:27.860
the hover.

00:39:27.860 --> 00:39:28.860
I was wondering if there is any standards
work going on of sort of creating an alternative

00:39:28.860 --> 00:39:29.860
to hover when you do the touchdown, that that
activates another style and touchup?

00:39:29.860 --> 00:39:30.860
Instead of hover, you know, have that in the
CSS rather than having to do that in JavaScript?

00:39:30.860 --> 00:39:31.860
&gt;&gt;Rick Byers: Right.

00:39:31.860 --> 00:39:32.860
That's what the active CSS pseudoclass is
for.

00:39:32.860 --> 00:39:33.860
The active CSS pseudoclass is defined in the
standard to say when the user is actively

00:39:33.860 --> 00:39:34.860
manipulating this thing, then active should
be applied.

00:39:34.860 --> 00:39:35.860
So we apply that -- on touchdown, we apply
that and we stop applying on touchup.

00:39:35.860 --> 00:39:36.860
There is a couple of details.

00:39:36.860 --> 00:39:37.860
We don't want to apply when you are scrolling,
so there is a slight delay before it kicks

00:39:37.860 --> 00:39:38.860
in.

00:39:38.860 --> 00:39:39.860
But that's effectively exactly what active
is for.

00:39:39.860 --> 00:39:40.860
&gt;&gt;&gt; Does that work in multiple -- does that
work in other browsers?

00:39:40.860 --> 00:39:41.860
&gt;&gt;Rick Byers: It works in many.

00:39:41.860 --> 00:39:42.860
I think there is a caveat with iOS that I'm
not too familiar with.

00:39:42.860 --> 00:39:43.860
But I think there is some detail where you
have to do something extra to make sure it

00:39:43.860 --> 00:39:44.860
works in iOS.

00:39:44.860 --> 00:39:45.860
Certainly in Chrome, it works fine.

00:39:45.860 --> 00:39:46.860
(Speaker off microphone.)

00:39:46.860 --> 00:39:47.860
&gt;&gt;Rick Byers: Depends upon your layout.

00:39:47.860 --> 00:39:48.860
It can be made to work.

00:39:48.860 --> 00:39:49.860
&gt;&gt;&gt; I seem to recall having tried that and
it didn't work.

00:39:49.860 --> 00:39:50.860
&gt;&gt;Rick Byers: Certainly, that's an example
of something we don't want you to have a touchevent

00:39:50.860 --> 00:39:51.860
handler to just change the style when something
is being touched like depressing a button.

00:39:51.860 --> 00:39:52.860
&gt;&gt;&gt; Thanks.

00:39:52.860 --> 00:39:53.860
&gt;&gt;Rick Byers: All right.

00:39:53.860 --> 00:39:54.860
Thanks very much.

00:39:54.860 --> 00:39:54.876
We will be down here for questions and then
up in the Chrome office hours area.

