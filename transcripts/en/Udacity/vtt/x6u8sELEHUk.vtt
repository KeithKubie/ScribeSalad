WEBVTT
Kind: captions
Language: en

00:00:00.120 --> 00:00:01.760
So let's go ahead and take a look at my

00:00:01.760 --> 00:00:05.970
test code for the Q class. So it doesn't actually take

00:00:05.970 --> 00:00:09.700
a whole lot to get full coverage on the Q

00:00:09.700 --> 00:00:12.350
class, and that's, this is a good point, we haven't tested

00:00:12.350 --> 00:00:15.310
the Q a huge amount here. It shows a little

00:00:15.310 --> 00:00:19.550
bit of the problems with S, especially just normal statement coverage,

00:00:19.550 --> 00:00:21.670
so let's go ahead and get started. So we start

00:00:21.670 --> 00:00:25.190
off with just a Q of size 2, we assert that

00:00:25.190 --> 00:00:27.410
it does actually get made and then we call check

00:00:27.410 --> 00:00:30.140
rep, we're going to be calling check rep after every single test

00:00:30.140 --> 00:00:33.210
that we do, just as a further test. And really, any

00:00:33.210 --> 00:00:36.880
of the test that we do that call the internals of

00:00:36.880 --> 00:00:40.500
the q class should probably be in check wrap, because

00:00:40.500 --> 00:00:43.200
we don't necessarily want our test code to have to worry

00:00:43.200 --> 00:00:46.620
about the internals of it, we want the internal testing to

00:00:46.620 --> 00:00:51.070
be taken care of by the class itself. Preferably all though

00:00:51.070 --> 00:00:54.510
you dont always get that. But after that we check

00:00:54.510 --> 00:00:56.290
the que it starts off as empty. Which it should

00:00:56.290 --> 00:00:59.150
be. And that the que is not full. Which it

00:00:59.150 --> 00:01:02.370
also should not be. And then we try the que from

00:01:02.370 --> 00:01:05.209
the empty que. And this should return none according to

00:01:05.209 --> 00:01:09.010
specification. Then we're going to que ten in to the

00:01:09.010 --> 00:01:12.630
que. And we should get a true. Result back and

00:01:12.630 --> 00:01:16.230
enqueue returns true if you successfully enqueue something, false, if it

00:01:16.230 --> 00:01:19.740
doesn't correctly enqueue for some reason or another. Then, we enqueue

00:01:19.740 --> 00:01:22.230
20 and again, it should be true. Now, we check that

00:01:22.230 --> 00:01:24.860
it's empty again. It should not be empty and we check

00:01:24.860 --> 00:01:27.510
that it's full. Since it's a queue of size two, the

00:01:27.510 --> 00:01:30.760
full method should return true. And that's what we asset here.

00:01:30.760 --> 00:01:34.370
Now, we further try to enqueue thirty, but since the queue

00:01:34.370 --> 00:01:37.250
should already be full, this should return false. And we go

00:01:37.250 --> 00:01:41.450
ahead and assert that. Now we try to dequeue from that, and

00:01:41.450 --> 00:01:44.340
we should get 10 out since this is a q. It's a

00:01:44.340 --> 00:01:48.580
first in, first out data structure. Then we try to dequeue again,

00:01:48.580 --> 00:01:52.130
and We should get 20 out. And, again, after each of these,

00:01:52.130 --> 00:01:55.360
we call tech rep. If I go ahead and submit this, we

00:01:55.360 --> 00:01:57.600
see that I got it right. Okay. Os, that's one way you

00:01:57.600 --> 00:01:59.880
could have done it. There are a number of different possibilities here.

00:01:59.880 --> 00:02:02.490
And like I said, it doesn't really take a huge amount of

00:02:02.490 --> 00:02:06.470
code to get full coverage of the queue class. If fact, what I

00:02:06.470 --> 00:02:11.110
did here is probably a bit much. But again. It doesn't necessarily tell us

00:02:11.110 --> 00:02:15.370
a whole lot about whether the Q class is, in fact, correct in any

00:02:15.370 --> 00:02:18.630
meaningful way. So, great. I hope you got it right and had fun with

00:02:18.630 --> 00:02:21.990
it. I hope it also wasn't too challenging. But I hope it made you think.

