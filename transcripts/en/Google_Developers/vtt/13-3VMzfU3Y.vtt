WEBVTT
Kind: captions
Language: en

00:00:01.000 --> 00:00:01.767
Steve Souders:
I'm Steve Souders.

00:00:01.767 --> 00:00:03.767
I work here
at Google on latency.

00:00:03.767 --> 00:00:07.133
And I'm very excited to have
John Resig here today.

00:00:07.133 --> 00:00:10.067
He lives in Boston
but works for Mozilla.

00:00:10.067 --> 00:00:12.367
So every once in a while
he's out here,

00:00:12.367 --> 00:00:13.901
and I asked him
a few months ago

00:00:13.901 --> 00:00:16.467
to let me know
when he was coming out,

00:00:16.467 --> 00:00:19.200
so we could get him to come
to Google and do a tech talk.

00:00:19.200 --> 00:00:23.100
For people who don't know,
John is the creator of jQuery.

00:00:23.100 --> 00:00:26.601
He works at Mozilla
as a JavaScript evangelist.

00:00:26.601 --> 00:00:31.634
He's an author; he wrote
 &lt;i&gt;Pro JavaScript Techniques.&lt;/i&gt;

00:00:31.634 --> 00:00:35.634
And now he's working on...

00:00:35.634 --> 00:00:37.767
 &lt;i&gt;Secrets&lt;/i&gt;
 &lt;i&gt;of the JavaScript Ninja.&lt;/i&gt;

00:00:37.767 --> 00:00:41.534
And, um, every once
in a while,

00:00:41.534 --> 00:00:44.767
I get these...

00:00:44.767 --> 00:00:48.467
basking-in-the-warm-glow moments
at conferences

00:00:48.467 --> 00:00:52.334
because I'm surrounded
by people like John

00:00:52.334 --> 00:00:56.667
who are at the forefront
of Web development today.

00:00:56.667 --> 00:01:01.467
And you can really see how much
they're personally putting

00:01:01.467 --> 00:01:03.534
into the work that they do.

00:01:03.534 --> 00:01:06.801
So, in addition to his work
with Mozilla

00:01:06.801 --> 00:01:11.868
and Firefox and jQuery,
John also works on Firebug,

00:01:11.868 --> 00:01:14.734
is pretty much leading
the Mozilla contributions

00:01:14.734 --> 00:01:15.934
to Firebug.

00:01:15.934 --> 00:01:19.467
Uh, he, I think, just--
his FireUnit released.

00:01:19.467 --> 00:01:21.033
FireUnit just came out.

00:01:21.033 --> 00:01:24.100
Um, and so we're all
in good hands

00:01:24.100 --> 00:01:26.367
with people like John
in the lead.

00:01:26.367 --> 00:01:29.000
Um, John, so I wanted
to present you with this bag

00:01:29.000 --> 00:01:30.100
of Google goodies.

00:01:30.100 --> 00:01:31.367
Resig: Thank you.

00:01:31.367 --> 00:01:32.801
man: And then I'll take that
away from you

00:01:32.801 --> 00:01:34.133
so you don't have to hold it.

00:01:34.133 --> 00:01:35.634
And, without any further ado,

00:01:35.634 --> 00:01:37.567
please help me welcome
John Resig.

00:01:37.567 --> 00:01:42.734
[applause]

00:01:42.734 --> 00:01:44.601
Resig: So I want to thank you
all for coming out today.

00:01:44.601 --> 00:01:46.868
I really appreciate it.

00:01:46.868 --> 00:01:51.033
So I wanted to talk
about a couple things today.

00:01:51.033 --> 00:01:53.934
Specifically, I wanted to talk
about pretty much

00:01:53.934 --> 00:01:56.567
all the new things
that are coming in browsers

00:01:56.567 --> 00:01:59.701
and the latest releases
of browsers.

00:01:59.701 --> 00:02:03.767
And I wanted to look at all
the performance improvements,

00:02:03.767 --> 00:02:08.167
especially related to JavaScript
and the DOM,

00:02:08.167 --> 00:02:10.834
and all the new APIs
that are starting to land.

00:02:10.834 --> 00:02:13.267
You know, trickle down
from like HTML 5

00:02:13.267 --> 00:02:15.067
and the new W3C specs.

00:02:15.067 --> 00:02:21.601
So a lot of my time lately,
at least with Mozilla,

00:02:21.601 --> 00:02:24.767
has been spent working
on this performance suite

00:02:24.767 --> 00:02:26.868
called Dromaeo.

00:02:26.868 --> 00:02:31.634
And this is a test suite
for doing performance analysis

00:02:31.634 --> 00:02:34.100
on JavaScript and DOM
with a browser.

00:02:34.100 --> 00:02:39.267
And doing this has really opened
my eyes to this issues

00:02:39.267 --> 00:02:43.467
that browser developers and,
you know, implementers face

00:02:43.467 --> 00:02:47.267
when they deal with all these,
you know, minutiae

00:02:47.267 --> 00:02:48.701
in these APIs.

00:02:48.701 --> 00:02:52.267
So it's really--I find it to be
really interesting.

00:02:52.267 --> 00:02:56.000
So I wanted to talk about some
of the upcoming browsers here

00:02:56.000 --> 00:02:58.033
that are on their way out

00:02:58.033 --> 00:03:02.767
and should be hitting the
streets here relatively soon.

00:03:02.767 --> 00:03:05.634
So there's...

00:03:05.634 --> 00:03:09.868
Firefox 3.1 coming out here
in just a little bit.

00:03:09.868 --> 00:03:12.200
And Safari 4, IE 8, Opera 10,

00:03:12.200 --> 00:03:14.334
and then the next release
of Chrome.

00:03:14.334 --> 00:03:17.067
Um, but the big thing
that is common

00:03:17.067 --> 00:03:21.067
amongst all these browsers
is that they are all actively

00:03:21.067 --> 00:03:24.501
iterating and rapidly improving
their performance.

00:03:24.501 --> 00:03:26.501
And this is--
this is really huge,

00:03:26.501 --> 00:03:27.667
and it's really exciting.

00:03:27.667 --> 00:03:30.133
It's a great time
to be developing.

00:03:30.133 --> 00:03:32.968
So I wanted
to just quickly draw through

00:03:32.968 --> 00:03:34.734
some of the new, big things
that are gonna be

00:03:34.734 --> 00:03:36.501
in these browsers
coming up.

00:03:36.501 --> 00:03:39.300
Um, and as I talk
about some of these APIs,

00:03:39.300 --> 00:03:41.534
please, if you have
a question, raise your hand

00:03:41.534 --> 00:03:45.601
so we can cover it
a little bit more in depth.

00:03:45.601 --> 00:03:49.133
But, um, so Firefox 3.1,
it's currently scheduled

00:03:49.133 --> 00:03:51.033
to come out here
pretty soon.

00:03:51.033 --> 00:03:54.934
Beta 3 is gonna be coming out,
I think,

00:03:54.934 --> 00:03:57.300
within just
the next couple weeks.

00:03:57.300 --> 00:04:00.634
And, but a lot of the big things
is that it's gonna be

00:04:00.634 --> 00:04:03.167
much, much faster
than Firefox 3.

00:04:03.167 --> 00:04:06.734
There's a whole new
JavaScript engine landing.

00:04:06.734 --> 00:04:08.968
There's the new video
and audio tags,

00:04:08.968 --> 00:04:11.467
which has been
in the news recently.

00:04:11.467 --> 00:04:13.167
And private browsing.

00:04:13.167 --> 00:04:15.167
Private browsing is
another feature

00:04:15.167 --> 00:04:17.300
that sort of just all browsers
are implementing it

00:04:17.300 --> 00:04:20.167
pretty much simultaneously now.

00:04:20.167 --> 00:04:23.033
Uh, Safari 4.

00:04:23.033 --> 00:04:26.501
The actual release date
isn't quite public yet,

00:04:26.501 --> 00:04:28.100
but it's pretty much assumed
that it's gonna be coming out

00:04:28.100 --> 00:04:31.334
whenever 10.6 comes out.

00:04:31.334 --> 00:04:34.701
Big things are that it's gonna
be completely ACID 3 compliant.

00:04:34.701 --> 00:04:37.167
It's gonna be much, much faster,

00:04:37.167 --> 00:04:39.200
even faster than before,

00:04:39.200 --> 00:04:41.734
and it's gonna have
this new concept of being able

00:04:41.734 --> 00:04:45.033
to deploy Web applications
to your desktop.

00:04:45.033 --> 00:04:46.801
You can--I showed you
a little menu up here

00:04:46.801 --> 00:04:49.467
where you can now do
a "Save as Web Application."

00:04:49.467 --> 00:04:51.868
You can take a Web page
and save it to your desktop

00:04:51.868 --> 00:04:55.567
and then load it up again
in sort of a quasi-offline mode.

00:04:55.567 --> 00:04:57.200
A lot of this is gonna be made
possible

00:04:57.200 --> 00:05:02.434
by the new HTML 5 offline
portion of the specification.

00:05:02.434 --> 00:05:05.601
And that's really great
in of itself.

00:05:05.601 --> 00:05:10.033
IE 8 is--this one's also coming
out here really soon.

00:05:10.033 --> 00:05:13.501
They just released
the new release candidate.

00:05:13.501 --> 00:05:16.467
But even--
while the performance of IE 8

00:05:16.467 --> 00:05:20.501
doesn't really, I wanna say,
compare to, you know,

00:05:20.501 --> 00:05:23.701
what's happening in Firefox
and Chrome and WebKit,

00:05:23.701 --> 00:05:29.167
it's dramatically faster than
their previous release IE 7.

00:05:29.167 --> 00:05:32.400
And, at the same time,
they are now doing

00:05:32.400 --> 00:05:35.334
what's called process per tab.

00:05:35.334 --> 00:05:38.300
And this--
in Chrome as well--

00:05:38.300 --> 00:05:41.467
but the concept
that each individual tab

00:05:41.467 --> 00:05:43.033
is running
in a separate process,

00:05:43.033 --> 00:05:45.400
rather than in a thread,
like what happens

00:05:45.400 --> 00:05:51.100
in Firefox
and WebKit for Safari.

00:05:51.100 --> 00:05:52.501
The--yes.

00:05:52.501 --> 00:05:54.434
employee: [inaudible]

00:06:06.100 --> 00:06:09.033
Resig: Okay, so the question
was--when Steve looked at it,

00:06:09.033 --> 00:06:10.400
it looked
like it was two processes:

00:06:10.400 --> 00:06:12.400
one for Chrome,
one for all tabs.

00:06:12.400 --> 00:06:13.767
Um, I'm not sure exactly.

00:06:13.767 --> 00:06:15.801
At least
from what Microsoft has said

00:06:15.801 --> 00:06:19.133
that they were splitting it up--

00:06:19.133 --> 00:06:23.367
maybe by splitting up
was only splitting twice.

00:06:23.367 --> 00:06:24.901
I know, at least
within the case of Chrome,

00:06:24.901 --> 00:06:28.501
it's definitely split
per tab.

00:06:28.501 --> 00:06:30.634
So...

00:06:30.634 --> 00:06:34.200
I would not be surprised
it's only split twice.

00:06:34.200 --> 00:06:38.868
Opera 10, the release date
for Opera 10 is not solid yet.

00:06:38.868 --> 00:06:40.801
They haven't made
any big announcements.

00:06:40.801 --> 00:06:43.501
A beta just came out recently.

00:06:43.501 --> 00:06:46.767
Another big--they are, as well,
are shooting

00:06:46.767 --> 00:06:50.968
for full ACID 3 compliance
and video and audio tag

00:06:50.968 --> 00:06:53.601
amongst some other APIs.

00:06:53.601 --> 00:06:58.334
And hopefully a new UI skin
as well.

00:06:58.334 --> 00:07:00.100
Um, and then,
Google Chrome.

00:07:00.100 --> 00:07:02.100
I'm sure everyone here is
well familiar with it.

00:07:02.100 --> 00:07:06.267
Um, but the new release here
should be coming out

00:07:06.267 --> 00:07:08.501
relatively soon,
but the big things--

00:07:08.501 --> 00:07:10.968
the big thing
that it really popularized

00:07:10.968 --> 00:07:12.934
was this process per tab.

00:07:12.934 --> 00:07:15.701
And this has really helped

00:07:15.701 --> 00:07:19.701
to change
how developers are able

00:07:19.701 --> 00:07:22.434
to look at Web applications.

00:07:22.434 --> 00:07:25.934
'Cause right now
browsers, generally,

00:07:25.934 --> 00:07:28.434
they have everything
in just a single process.

00:07:28.434 --> 00:07:32.901
Everything, you know,
each tab is split up

00:07:32.901 --> 00:07:34.334
amongst multiple threads,

00:07:34.334 --> 00:07:35.901
and they're all handling
different things.

00:07:35.901 --> 00:07:39.501
One might be handling rendering
or doing networking or...

00:07:39.501 --> 00:07:43.567
And the problem with that is
there's a tendency

00:07:43.567 --> 00:07:45.000
for a lot of collision
to occur.

00:07:45.000 --> 00:07:48.801
And if one tab is slowing down,
consuming a lot of resources--

00:07:48.801 --> 00:07:50.868
one page is consuming
a lot of resources,

00:07:50.868 --> 00:07:52.801
your other tabs will be blocked.

00:07:52.801 --> 00:07:54.968
So with this new process per tab
model,

00:07:54.968 --> 00:08:00.501
you start to confine everything,
uh, extremely.

00:08:00.501 --> 00:08:04.434
So what you end up having to do
is you sacrifice memory

00:08:04.434 --> 00:08:06.868
for the benefit
of performance.

00:08:06.868 --> 00:08:12.601
Um, but, so at the very least,
it's resulting in some--

00:08:12.601 --> 00:08:14.968
you can run some really
heavy-duty Web applications

00:08:14.968 --> 00:08:20.534
without interfering with
whatever else is going on.

00:08:20.534 --> 00:08:22.367
One thing that I really liked
about Chrome, though,

00:08:22.367 --> 00:08:26.334
was the fact
that you could monitor

00:08:26.334 --> 00:08:29.634
each individual tab
and see how much memory

00:08:29.634 --> 00:08:32.167
and resources
each tab was consuming.

00:08:32.167 --> 00:08:34.067
They included
this--this view.

00:08:34.067 --> 00:08:36.267
It's almost
like a Windows Task Manager

00:08:36.267 --> 00:08:38.601
but within Chrome itself.

00:08:38.601 --> 00:08:43.100
And that was very eye-opening.

00:08:43.100 --> 00:08:45.801
Because most Web developers
have no idea

00:08:45.801 --> 00:08:47.968
how much their Web site--
what their Web sites

00:08:47.968 --> 00:08:50.834
are actually, you know,
affecting the outside world.

00:08:50.834 --> 00:08:53.834
You know, they have no idea
if their Web site's, you know,

00:08:53.834 --> 00:08:57.033
consuming 40 megabytes of RAM
or, you know, 140.

00:08:57.033 --> 00:08:59.801
And it's really important
to know that

00:08:59.801 --> 00:09:01.634
if you want to do
a Web application

00:09:01.634 --> 00:09:05.834
that is actually going to be
deployed, you know, widely.

00:09:05.834 --> 00:09:08.968
A couple of other changes
that happened here

00:09:08.968 --> 00:09:12.400
with Chrome,
and they changed it such

00:09:12.400 --> 00:09:16.567
that timers can now run
at rates faster than normal.

00:09:16.567 --> 00:09:19.567
I know Mike Belshe is here.

00:09:19.567 --> 00:09:23.667
And he was responsible
for this.

00:09:23.667 --> 00:09:25.133
But this is very interesting

00:09:25.133 --> 00:09:30.033
because typically browsers have
a floor for how quickly

00:09:30.033 --> 00:09:31.367
a timer can run.

00:09:31.367 --> 00:09:34.501
It's usually around
13 milliseconds or so,

00:09:34.501 --> 00:09:37.133
how quickly it can be called
over and over again.

00:09:37.133 --> 00:09:40.334
What that means is
is that it's limiting

00:09:40.334 --> 00:09:42.033
the number of times--

00:09:42.033 --> 00:09:45.167
let's say your frame rate
for an animation

00:09:45.167 --> 00:09:47.934
or, you know, the number of
times to pre-read

00:09:47.934 --> 00:09:50.501
a particular object
or what have you.

00:09:50.501 --> 00:09:52.701
But what happened is now
that they've moved

00:09:52.701 --> 00:09:57.968
into a process per tab model,
you can now give a tab

00:09:57.968 --> 00:10:01.300
the ability to just check
as frequently as it needs to

00:10:01.300 --> 00:10:03.667
or update the page
as frequently as it needs to

00:10:03.667 --> 00:10:07.834
and without fear of it blocking
the resources of the other tabs.

00:10:07.834 --> 00:10:10.334
So this is really nice
because now you can get

00:10:10.334 --> 00:10:14.801
insanely high frame rates
in Chrome, for example,

00:10:14.801 --> 00:10:18.634
where you just do animations
at, you know, many hundreds

00:10:18.634 --> 00:10:22.934
of frames per second,
which is really quite exciting.

00:10:22.934 --> 00:10:25.734
Um...

00:10:25.734 --> 00:10:27.567
So I wanted to talk
a little bit

00:10:27.567 --> 00:10:33.234
about the new JavaScript
engines.

00:10:33.234 --> 00:10:35.634
So there's
three new Java Script engines

00:10:35.634 --> 00:10:39.868
that are coming out here in,
or are in various stages

00:10:39.868 --> 00:10:44.968
of release, in WebKit,
WebKit Safari, and Firefox,

00:10:44.968 --> 00:10:46.367
and in Chrome.

00:10:46.367 --> 00:10:50.601
And they're--so Firefox has...

00:10:50.601 --> 00:10:53.200
well, I should say
that all of them

00:10:53.200 --> 00:10:55.567
are competing very, very heavily
at this point.

00:10:55.567 --> 00:10:59.400
But this is really fantastic
in my opinion.

00:10:59.400 --> 00:11:02.400
Because when these browser
vendors compete

00:11:02.400 --> 00:11:05.968
and all try
to one-up each other

00:11:05.968 --> 00:11:08.734
for a performance,
the end result is

00:11:08.734 --> 00:11:11.767
that users just get
a better experience.

00:11:11.767 --> 00:11:14.834
The users--you know,
the pages load faster.

00:11:14.834 --> 00:11:17.667
You have developers--
their applications run faster.

00:11:17.667 --> 00:11:20.033
You know, everyone wins
so it's really great.

00:11:20.033 --> 00:11:24.567
I hope they keep battling it out
indefinitely.

00:11:24.567 --> 00:11:29.133
But all these engines have
a couple common features.

00:11:29.133 --> 00:11:33.534
At this point,
they all have virtual machines

00:11:33.534 --> 00:11:35.834
of some sort
so that they can run

00:11:35.834 --> 00:11:38.534
some sort
of optimized bytecode...

00:11:38.534 --> 00:11:42.267
representation
of the JavaScript.

00:11:42.267 --> 00:11:45.834
And additionally they also
almost all at this point

00:11:45.834 --> 00:11:47.734
do some sort of shaping.

00:11:47.734 --> 00:11:52.200
So looking at objects
to determine their general feel

00:11:52.200 --> 00:11:54.834
and structure
and being able to do--

00:11:54.834 --> 00:11:59.934
be able to do things
based upon that.

00:11:59.934 --> 00:12:03.167
So here's
just sort of a rough structure

00:12:03.167 --> 00:12:05.868
of how the engines currently
break down.

00:12:05.868 --> 00:12:08.267
I mean, when you write
your JavaScript code,

00:12:08.267 --> 00:12:10.300
you end up having--
it ends up going

00:12:10.300 --> 00:12:11.534
through multiple steps

00:12:11.534 --> 00:12:15.000
before finally
and eventually executing.

00:12:15.000 --> 00:12:17.434
But the result is, though,

00:12:17.434 --> 00:12:20.734
is that these engines
are breaking down

00:12:20.734 --> 00:12:23.334
into this, you know,
lower bytecode layer.

00:12:23.334 --> 00:12:27.133
They're able to optimize their
engines much more dramatically

00:12:27.133 --> 00:12:32.400
and, you know, make tweaks
that just unleash performance.

00:12:32.400 --> 00:12:34.801
I want to talk about this
a little bit

00:12:34.801 --> 00:12:38.067
because--
just to give an example here--

00:12:38.067 --> 00:12:42.033
This is my pseudo bytecode.

00:12:42.033 --> 00:12:45.801
This is not 100% accurate,
just to give you an idea.

00:12:45.801 --> 00:12:48.534
So, like, if you have
a very simple operation,

00:12:48.534 --> 00:12:51.801
you're adding
two variables together.

00:12:51.801 --> 00:12:53.901
The problem is
is that in JavaScript

00:12:53.901 --> 00:12:55.834
there is a lot of ambiguity.

00:12:55.834 --> 00:12:58.434
You know, when you add
two variables together,

00:12:58.434 --> 00:13:01.667
you may be concatenating 'em
if one of them is a string

00:13:01.667 --> 00:13:03.033
or, you know,
if they're numbers,

00:13:03.033 --> 00:13:04.234
if they're both numbers,

00:13:04.234 --> 00:13:05.868
then you'll be adding 'em.

00:13:05.868 --> 00:13:10.167
So--and you need to, like,
underneath the hood,

00:13:10.167 --> 00:13:13.334
all these options--
all these checks are occurring.

00:13:13.334 --> 00:13:15.901
You know, it's checking
if each variable's a string,

00:13:15.901 --> 00:13:17.767
and if so,
concatenating 'em together.

00:13:17.767 --> 00:13:19.033
If neither of 'em's a string,

00:13:19.033 --> 00:13:20.234
then it's gonna add them
together.

00:13:20.234 --> 00:13:21.834
And then, well, then you just
concat and add.

00:13:21.834 --> 00:13:23.400
There's a whole other set
of options

00:13:23.400 --> 00:13:26.534
that have to be executed.

00:13:26.534 --> 00:13:29.267
But the nice thing
is that they're starting

00:13:29.267 --> 00:13:32.033
to do some optimization here,

00:13:32.033 --> 00:13:34.868
so--what's roughly called
shaping--

00:13:34.868 --> 00:13:41.033
so that they can determine
if an object is--

00:13:41.033 --> 00:13:43.133
you know, if it looks
like a string,

00:13:43.133 --> 00:13:46.200
and if it probably is a string,
then make some assumptions

00:13:46.200 --> 00:13:48.334
and remove
some of these checks.

00:13:48.334 --> 00:13:51.501
So even here--
so like if we were trying

00:13:51.501 --> 00:13:54.934
to get the method property
of an object,

00:13:54.934 --> 00:13:57.567
there are a huge number
of checks that have to be done

00:13:57.567 --> 00:14:00.667
simply before we can even get
the property,

00:14:00.667 --> 00:14:04.000
and that's even
before actually executing it.

00:14:04.000 --> 00:14:07.667
But if we do
some sort of shaping,

00:14:07.667 --> 00:14:11.934
all this code ends up boiling
down to a simple, you know,

00:14:11.934 --> 00:14:14.434
couple pieces
of bytecode operation

00:14:14.434 --> 00:14:17.133
rather than, you know,
dozens and dozens of execution

00:14:17.133 --> 00:14:20.367
just to access
a single property.

00:14:20.367 --> 00:14:24.601
So all of this optimization
is dramatically improving

00:14:24.601 --> 00:14:28.434
the performance
of Web pages

00:14:28.434 --> 00:14:32.367
and on test suites.

00:14:32.367 --> 00:14:33.968
So I just wanted to talk
a little bit

00:14:33.968 --> 00:14:36.634
about some of the engines
in particular.

00:14:36.634 --> 00:14:38.634
There is TraceMonkey.

00:14:38.634 --> 00:14:42.701
This is the new engine
released by Mozilla

00:14:42.701 --> 00:14:45.100
replacing the old engine
SpiderMonkey.

00:14:45.100 --> 00:14:47.300
It's a variation
of SpiderMonkey.

00:14:47.300 --> 00:14:51.200
And this one is--
uses what's called

00:14:51.200 --> 00:14:55.434
tracing technology to optimize
commonly repeating patterns,

00:14:55.434 --> 00:14:58.300
things that happen
again and again.

00:14:58.300 --> 00:15:02.734
So, for example,
if you had some loop

00:15:02.734 --> 00:15:04.834
that was iterating
1,000 times

00:15:04.834 --> 00:15:08.367
and it was calling
some function within that loop,

00:15:08.367 --> 00:15:11.200
what it might do is remove

00:15:11.200 --> 00:15:14.434
some of the costly bytecode
checks that need to occur,

00:15:14.434 --> 00:15:19.000
making sure, for example,
the letter--

00:15:19.000 --> 00:15:21.534
the variable i--
making--

00:15:21.534 --> 00:15:23.634
it's probably gonna continue
to be a number

00:15:23.634 --> 00:15:24.901
throughout the lifespan
of this loop.

00:15:24.901 --> 00:15:27.067
So removing--you know,
just making assumptions,

00:15:27.067 --> 00:15:29.734
assuming that i's gonna remain
a number,

00:15:29.734 --> 00:15:35.534
that, you know, optimizing,
adding one to the variable i.

00:15:35.534 --> 00:15:38.667
All of these things.

00:15:38.667 --> 00:15:40.567
And so that when these loops
start to occur

00:15:40.567 --> 00:15:41.801
and when it starts
to go through

00:15:41.801 --> 00:15:43.801
and iterate back and forth,
back and forth,

00:15:43.801 --> 00:15:46.000
it can start
to remove that

00:15:46.000 --> 00:15:49.334
and optimize it down,
especially with inlining

00:15:49.334 --> 00:15:50.400
some of the function calls.

00:15:50.400 --> 00:15:52.634
So, taking
these external functions,

00:15:52.634 --> 00:15:54.234
pulling the code out of them,

00:15:54.234 --> 00:15:56.300
and essentially inlining
them into a single block.

00:15:56.300 --> 00:15:59.033
So that way it ends up being
just so much faster.

00:15:59.033 --> 00:16:03.334
You know, an empty loop--
I remember seeing

00:16:03.334 --> 00:16:08.467
some numbers that an empty loop
running in TraceMonkey

00:16:08.467 --> 00:16:11.734
was comparable to the speed
of the [indistinct] you can see.

00:16:11.734 --> 00:16:13.701
Of course, that means
pretty much nothing

00:16:13.701 --> 00:16:15.267
since you're just doing
an empty loop

00:16:15.267 --> 00:16:19.467
but the important part here is
that it's trying to strip away

00:16:19.467 --> 00:16:22.667
as much extraneous stuff
as possible.

00:16:22.667 --> 00:16:24.868
Which is really good.

00:16:24.868 --> 00:16:30.067
So SquirrelFish, the WebKit team
did all sorts of work

00:16:30.067 --> 00:16:33.834
to get good just-in-time
compilation working

00:16:33.834 --> 00:16:36.000
for their JavaScript engine.

00:16:36.000 --> 00:16:39.934
And they did a lot of work
on their bytecode

00:16:39.934 --> 00:16:41.901
and optimizing their bytecode.

00:16:41.901 --> 00:16:46.534
And you can especially see this
in their--in the performance

00:16:46.534 --> 00:16:47.801
on regular expressions.

00:16:47.801 --> 00:16:49.701
The regular expression
performances is

00:16:49.701 --> 00:16:51.100
pretty much insane.

00:16:51.100 --> 00:16:53.200
And they basically did
all sorts of optimization there

00:16:53.200 --> 00:16:56.434
in making that fast.

00:16:56.434 --> 00:17:01.734
Then Chrome V8, they--
in their engine

00:17:01.734 --> 00:17:04.934
they did a lot of work
in doing more shaping,

00:17:04.934 --> 00:17:06.601
which I talked about earlier.

00:17:06.601 --> 00:17:08.801
But that allowed them to do

00:17:08.801 --> 00:17:12.267
just really fast
property lookups on objects.

00:17:12.267 --> 00:17:14.200
And it was really
quite impressive

00:17:14.200 --> 00:17:18.367
when it was released.

00:17:18.367 --> 00:17:23.200
So there's a lot
of difficulty

00:17:23.200 --> 00:17:24.868
in trying to get
an accurate measure

00:17:24.868 --> 00:17:27.834
of performance,
trying to understand

00:17:27.834 --> 00:17:31.968
what exactly makes
a piece of JavaScript code

00:17:31.968 --> 00:17:36.400
accurate and representative
of JavaScript code as a whole.

00:17:36.400 --> 00:17:41.367
And especially so, does
optimizing this piece of code--

00:17:41.367 --> 00:17:43.934
will it actually help users?

00:17:43.934 --> 00:17:45.534
So there are
a couple test suites right now,

00:17:45.534 --> 00:17:48.901
each released
by the different vendors,

00:17:48.901 --> 00:17:52.400
and there's the SunSpider
test suite released by WebKit

00:17:52.400 --> 00:17:54.968
that includes a number
of different tests

00:17:54.968 --> 00:17:56.968
for testing pure JavaScript.

00:17:56.968 --> 00:17:58.968
Uh, the V8 Benchmark,
which was released

00:17:58.968 --> 00:18:02.000
at the same time as V8,
that also includes

00:18:02.000 --> 00:18:04.968
a number of pure JavaScript
tests.

00:18:04.968 --> 00:18:07.968
Then the Dromaeo tests
that I wrote and released,

00:18:07.968 --> 00:18:11.267
and this WebKit contains
a mix of JavaScript tests

00:18:11.267 --> 00:18:13.467
and DOM tests,
and it actually includes

00:18:13.467 --> 00:18:17.434
both the SunSpider
and V8 Benchmarks as well.

00:18:17.434 --> 00:18:19.667
Just to show some numbers,

00:18:19.667 --> 00:18:22.734
these are outdated
at this point.

00:18:22.734 --> 00:18:24.334
I don't think it would be
possible to give you numbers

00:18:24.334 --> 00:18:26.467
that were even up-to-date
since everything changes

00:18:26.467 --> 00:18:27.801
every single night.

00:18:27.801 --> 00:18:32.801
But the important part here
is that performance

00:18:32.801 --> 00:18:36.601
of old browsers used to be,
like, IE 7 level of performance

00:18:36.601 --> 00:18:39.901
and, like, I mean,
if you look at the difference

00:18:39.901 --> 00:18:41.701
between these couple browsers
on the left,

00:18:41.701 --> 00:18:43.934
it's miniscule
in comparison.

00:18:43.934 --> 00:18:47.400
I think these numbers are
a couple months out of date

00:18:47.400 --> 00:18:49.734
at this point.

00:18:49.734 --> 00:18:52.534
I mean, everything has just
gotten so dramatically faster

00:18:52.534 --> 00:18:54.534
in the last couple months
even

00:18:54.534 --> 00:18:56.634
that it's really just blowing
away.

00:18:56.634 --> 00:19:00.167
So this is
on the Chrome Benchmark.

00:19:00.167 --> 00:19:04.934
It's not completely clear
if the Chrome guys just happened

00:19:04.934 --> 00:19:07.033
to be really, really good
at their Benchmark

00:19:07.033 --> 00:19:09.033
or if they optimized
for the Benchmark.

00:19:09.033 --> 00:19:10.801
But, regardless,
they do really good

00:19:10.801 --> 00:19:12.968
in their Benchmark.

00:19:12.968 --> 00:19:14.934
And then on Dromaeo
as well.

00:19:14.934 --> 00:19:17.968
This one--again, this one tests
a mixture of JavaScript

00:19:17.968 --> 00:19:23.334
and DOM.

00:19:23.334 --> 00:19:25.033
All right, so wanted to talk

00:19:25.033 --> 00:19:29.167
about some
of the new improvements

00:19:29.167 --> 00:19:32.100
that are coming
outside of JavaScript engines

00:19:32.100 --> 00:19:36.234
in particular.

00:19:36.234 --> 00:19:40.133
Steve Souders released--
sitting right there--

00:19:40.133 --> 00:19:42.234
released an excellent tool

00:19:42.234 --> 00:19:46.367
for helping
browser developers determine

00:19:46.367 --> 00:19:50.801
what exactly is going on
at the...

00:19:50.801 --> 00:19:54.367
for loading items
over the network and browsers.

00:19:54.367 --> 00:19:58.200
And it's his UA tool--
I provide the URL there.

00:19:58.200 --> 00:20:03.300
But this is a rough breakdown
of the number of features--

00:20:03.300 --> 00:20:06.300
he breaks it down into a number
of different categories,

00:20:06.300 --> 00:20:08.067
which I'll go into here
in a second,

00:20:08.067 --> 00:20:12.334
and shows how well
each browser passes that.

00:20:12.334 --> 00:20:16.234
Um, for example,
for simultaneous connections,

00:20:16.234 --> 00:20:18.701
some meaning that,
if you have a number

00:20:18.701 --> 00:20:20.167
of images in your page,

00:20:20.167 --> 00:20:23.133
how many, you know, images can
be downloaded simultaneously?

00:20:23.133 --> 00:20:26.701
So the higher that number is,

00:20:26.701 --> 00:20:27.868
you know, theoretically
the faster

00:20:27.868 --> 00:20:30.400
a page is gonna be able
to load.

00:20:30.400 --> 00:20:34.234
Um, and you can see
the steps in improvement here.

00:20:34.234 --> 00:20:37.033
Older browsers, Firefox 2, IE 6,
IE 7,

00:20:37.033 --> 00:20:39.601
they all have a maximum
connection number of two.

00:20:39.601 --> 00:20:42.701
But as browsers, you know,
start to increase here,

00:20:42.701 --> 00:20:44.868
you see it goes up to four
in Safari

00:20:44.868 --> 00:20:47.767
and then other browsers,
you know, Firefox 3 and Opera,

00:20:47.767 --> 00:20:50.167
all have six to seven
connections,

00:20:50.167 --> 00:20:52.701
simultaneous connections.

00:20:52.701 --> 00:20:56.334
And I should say simultaneous
connections per domain.

00:20:56.334 --> 00:20:59.734
A maximum number
of connections, is

00:20:59.734 --> 00:21:01.501
so that, you know,
if you have images being loaded

00:21:01.501 --> 00:21:03.434
from multiple domains,
you know,

00:21:03.434 --> 00:21:05.234
how many can you be doing
at a time?

00:21:05.234 --> 00:21:06.734
And that's really high.

00:21:06.734 --> 00:21:07.901
So we're talking anywhere

00:21:07.901 --> 00:21:13.534
from 25 to 60
simultaneous connections.

00:21:13.534 --> 00:21:17.901
Um, another big thing
is being able to download

00:21:17.901 --> 00:21:21.434
scripts in parallel
so that if you have two scripts

00:21:21.434 --> 00:21:24.601
in a page, and, you know,
they both take, you know,

00:21:24.601 --> 00:21:28.400
200 milliseconds
to download over the network,

00:21:28.400 --> 00:21:30.634
that it won't take
400 seconds total.

00:21:30.634 --> 00:21:32.567
Instead, it'll just take
200 seconds--

00:21:32.567 --> 00:21:35.467
sorry, 200 milliseconds--since
they downloaded simultaneously

00:21:35.467 --> 00:21:37.400
and then execute
back to back.

00:21:37.400 --> 00:21:38.767
Um, there's another thing

00:21:38.767 --> 00:21:42.501
that's starting to be
implemented more widely.

00:21:42.501 --> 00:21:44.534
There's--it's called
the defer script.

00:21:44.534 --> 00:21:47.234
And this is actually gonna be
in Firefox 3.1.

00:21:47.234 --> 00:21:50.367
It's in Internet Explorer,
and it's also in Opera.

00:21:50.367 --> 00:21:55.033
And it allows you to say
that, given this script,

00:21:55.033 --> 00:21:58.367
to load it, you know,
asynchronously,

00:21:58.367 --> 00:22:01.767
and then execute it again
at a later time.

00:22:01.767 --> 00:22:05.133
It doesn't matter
when this script executes.

00:22:05.133 --> 00:22:07.200
But, additionally,
there's some properties

00:22:07.200 --> 00:22:08.300
of a deferred script.

00:22:08.300 --> 00:22:10.367
Like, it can still
document.write,

00:22:10.367 --> 00:22:12.200
and when it document.writes,
it still does it

00:22:12.200 --> 00:22:14.033
in the correct location
of the document.

00:22:14.033 --> 00:22:15.534
Things like that.

00:22:15.534 --> 00:22:19.100
So, but when browsers start
to implement this,

00:22:19.100 --> 00:22:20.767
you're gonna be able
to put this defer script

00:22:20.767 --> 00:22:24.667
on things like ads,
and the ads would be loaded--

00:22:24.667 --> 00:22:26.834
would be deferred-loaded
and then injected

00:22:26.834 --> 00:22:29.534
into the document, you know,
when they're finished loading,

00:22:29.534 --> 00:22:34.501
as opposed to blocking
the entire document load.

00:22:34.501 --> 00:22:37.067
Another big thing that browsers
are getting better at

00:22:37.067 --> 00:22:39.901
is redirect caching.

00:22:39.901 --> 00:22:42.300
So every time you access
a Web site,

00:22:42.300 --> 00:22:45.834
redirects occur
from adding in slashes

00:22:45.834 --> 00:22:48.601
or going to a document page.

00:22:48.601 --> 00:22:50.501
This can, you know,
it adds up.

00:22:50.501 --> 00:22:52.667
It's another network request.

00:22:52.667 --> 00:22:55.767
And some browsers are getting
better at this,

00:22:55.767 --> 00:22:56.968
like Chrome and Firefox.

00:22:56.968 --> 00:22:58.801
They're caching these redirects

00:22:58.801 --> 00:23:00.634
so they don't have to be done
over and over again.

00:23:00.634 --> 00:23:03.701
It's a tiny--
it seems really tiny,

00:23:03.701 --> 00:23:06.133
but it's little things
like this that really add up.

00:23:06.133 --> 00:23:09.834
And optimizing these and fixing
them can really improve

00:23:09.834 --> 00:23:12.701
the performance
of a Web application.

00:23:12.701 --> 00:23:17.300
So this is a nice thing.
It's called link prefetching.

00:23:17.300 --> 00:23:21.501
And it allows you to pre-load
resources on your site

00:23:21.501 --> 00:23:25.767
so that you can say
that at some point later on

00:23:25.767 --> 00:23:27.734
I'm gonna use this image.

00:23:27.734 --> 00:23:30.167
You're telling the browser,
load this ahead of time

00:23:30.167 --> 00:23:33.000
so that the user doesn't have
to watch it load

00:23:33.000 --> 00:23:35.901
whenever it pops in.

00:23:35.901 --> 00:23:37.534
So this is something
relatively new.

00:23:37.534 --> 00:23:41.300
And right now it's only
implemented in Firefox.

00:23:41.300 --> 00:23:46.067
But it's generally
a much better way

00:23:46.067 --> 00:23:48.300
of managing this,
as opposed to having

00:23:48.300 --> 00:23:50.534
to go through JavaScript
and using JavaScript

00:23:50.534 --> 00:23:53.601
to manage, you know, all this
downloading and prefetching

00:23:53.601 --> 00:23:57.968
in the background.

00:23:57.968 --> 00:24:01.334
All right. Any questions
before I keep going on?

00:24:01.334 --> 00:24:02.367
Yes.

00:24:02.367 --> 00:24:08.000
employee: [inaudible]

00:24:08.000 --> 00:24:10.000
Resig: So the question was

00:24:10.000 --> 00:24:11.534
"How is the performance

00:24:11.534 --> 00:24:14.067
of JavaScript parse time
increased?"

00:24:14.067 --> 00:24:20.000
So right now the test suites--
I should say--

00:24:20.000 --> 00:24:22.100
so out
of the different test suites,

00:24:22.100 --> 00:24:25.734
currently only SunSpider tests
parse time.

00:24:25.734 --> 00:24:29.968
But they don't test it separate
from actual execution time.

00:24:29.968 --> 00:24:31.801
It's all clumped together.

00:24:31.801 --> 00:24:37.934
So it's currently--currently no
suite analyzes just parse time

00:24:37.934 --> 00:24:42.033
versus, you know,
the total execution time.

00:24:42.033 --> 00:24:44.734
That is absolutely something
that should be analyzed

00:24:44.734 --> 00:24:47.400
since that affects
the initial load.

00:24:47.400 --> 00:24:48.801
You know, we wanna make sure
that, you know,

00:24:48.801 --> 00:24:51.334
when that first hit occurs,
you got 200k of JavaScript

00:24:51.334 --> 00:24:53.834
that gets parsed really fast.

00:24:53.834 --> 00:24:57.701
Um, so it's not completely clear
what the best ways

00:24:57.701 --> 00:25:02.868
of analyzing that are simply
because it's not something

00:25:02.868 --> 00:25:06.334
that can be easily done
in a browser context.

00:25:06.334 --> 00:25:08.434
You might have to move
to a command line context,

00:25:08.434 --> 00:25:10.400
and, at that point,
you know, if you're measuring

00:25:10.400 --> 00:25:12.200
on the command line, you know,
is that really

00:25:12.200 --> 00:25:15.033
a realistic test since you're
not in a browser anymore?

00:25:15.033 --> 00:25:17.234
There's a lot of questions,
but I agree

00:25:17.234 --> 00:25:19.934
there's not a good test there
yet.

00:25:19.934 --> 00:25:20.934
Yes.

00:25:20.934 --> 00:25:23.300
employee: [inaudible]

00:25:33.367 --> 00:25:34.801
Resig: So, just to repeat,

00:25:34.801 --> 00:25:37.734
so is this, you know, JITing,
does it, you know, slow down

00:25:37.734 --> 00:25:41.634
this initial load,
and, you know, is this cached?

00:25:41.634 --> 00:25:44.701
So at least
in my experience,

00:25:44.701 --> 00:25:47.801
looking at the numbers, the
JITing does not significantly

00:25:47.801 --> 00:25:49.834
slow down performance.

00:25:49.834 --> 00:25:53.934
At least not in a way
that the browser vendors

00:25:53.934 --> 00:25:56.200
are concerned about
because it ultimately wins

00:25:56.200 --> 00:25:58.567
much, much more later on.

00:25:58.567 --> 00:26:05.167
But the--as far as caching,
as I understand it,

00:26:05.167 --> 00:26:09.934
most cache within a page
but not from page to page.

00:26:09.934 --> 00:26:12.000
You know,
once you leave a page,

00:26:12.000 --> 00:26:13.501
you're pretty much done.

00:26:13.501 --> 00:26:18.234
It depends how much sharing
of execution context there is

00:26:18.234 --> 00:26:21.267
simply because--I guess
that might be a case

00:26:21.267 --> 00:26:26.000
where, you know, a threaded
environment might work better

00:26:26.000 --> 00:26:29.968
since they all know what's going
on with the other processes.

00:26:29.968 --> 00:26:32.100
employee: [inaudible]

00:26:39.167 --> 00:26:41.534
Resig: Yeah,
so that's another question is,

00:26:41.534 --> 00:26:43.634
if you're pulling something

00:26:43.634 --> 00:26:45.167
that's obviously
an identical piece of code

00:26:45.167 --> 00:26:48.267
every single time, you know,
jQuery or Dojo, YUI.

00:26:48.267 --> 00:26:51.734
You know, it's, um,
you know--

00:26:51.734 --> 00:26:54.601
if there was a way to send down
a straight bytecode,

00:26:54.601 --> 00:26:57.133
you know, just say,
"Hey, here's the lowest level

00:26:57.133 --> 00:26:58.934
you can get,"
but, at the same time,

00:26:58.934 --> 00:27:00.834
that would require
that all the browsers

00:27:00.834 --> 00:27:02.701
standardized
in a single bytecode.

00:27:02.701 --> 00:27:04.934
And they're having
a hard enough time standardizing

00:27:04.934 --> 00:27:07.167
in just JavaScript,
so, I mean, we'll see.

00:27:07.167 --> 00:27:08.968
Um, right there.

00:27:08.968 --> 00:27:10.901
employee: [inaudible]

00:27:22.968 --> 00:27:24.501
Resig: I couldn't say.

00:27:24.501 --> 00:27:26.334
I wouldn't feel comfortable
giving a good estimate,

00:27:26.334 --> 00:27:29.033
um, until I had good data.

00:27:29.033 --> 00:27:31.868
I mean, at least,
you know, this parse time

00:27:31.868 --> 00:27:34.200
is...

00:27:34.200 --> 00:27:35.834
at least, right now, at best,

00:27:35.834 --> 00:27:40.601
it's just clumped in
with execution time.

00:27:40.601 --> 00:27:43.567
employee: [inaudible]

00:28:13.701 --> 00:28:18.033
Resig: Um, yeah, so the question
was "If it's found out

00:28:18.033 --> 00:28:21.133
"that parse time is
a significant burden,

00:28:21.133 --> 00:28:24.901
that's something
that should be optimized."

00:28:24.901 --> 00:28:29.200
You know, I assume
that if solid numbers come out

00:28:29.200 --> 00:28:32.167
for all the major
JavaScript engines,

00:28:32.167 --> 00:28:34.434
you better believe that the
browsers are gonna be working

00:28:34.434 --> 00:28:37.100
to optimize that number.

00:28:37.100 --> 00:28:39.667
For developers,
I'm not sure.

00:28:39.667 --> 00:28:41.367
I mean, then again,
that's another case

00:28:41.367 --> 00:28:45.267
where better tooling would help,
you know,

00:28:45.267 --> 00:28:46.934
to answer those questions.

00:28:46.934 --> 00:28:49.367
Yes.

00:28:49.367 --> 00:28:51.334
employee: [inaudible]

00:29:51.901 --> 00:29:53.100
man: Could you repeat
the question

00:29:53.100 --> 00:29:55.167
for the remote sites?

00:29:55.167 --> 00:29:58.334
Resig: Yeah, when he's done.

00:29:58.334 --> 00:30:00.267
employee: [inaudible]

00:30:13.334 --> 00:30:17.234
Okay, so, just to repeat,
so the--

00:30:17.234 --> 00:30:19.067
at this point
with the new engines,

00:30:19.067 --> 00:30:21.434
the vast majority of time
isn't spent parsing.

00:30:21.434 --> 00:30:24.000
In fact, very little time
is spent parsing.

00:30:24.000 --> 00:30:26.567
And that these new engines
are trying to be

00:30:26.567 --> 00:30:29.367
as just fundamentally lazy
as possible

00:30:29.367 --> 00:30:32.334
to try and break parsing out
later

00:30:32.334 --> 00:30:34.501
and worry
about everything later.

00:30:34.501 --> 00:30:36.868
And, so, I mean,
there may be an initial hit,

00:30:36.868 --> 00:30:40.267
but it definitely isn't,
you know, a massive hit.

00:30:40.267 --> 00:30:44.701
At least not in comparison
to old engines.

00:30:44.701 --> 00:30:47.133
employee: [inaudible]

00:31:04.267 --> 00:31:06.901
Resig: So just that...
yeah, right.

00:31:06.901 --> 00:31:13.167
So that the initial parsing
in JITing isn't free,

00:31:13.167 --> 00:31:18.767
but, you know, the ultimate win
you get is pretty awesome, so...

00:31:20.334 --> 00:31:22.501
Okay, any more questions?

00:31:22.501 --> 00:31:23.567
All right.

00:31:23.567 --> 00:31:24.801
All right, so I wanted to talk

00:31:24.801 --> 00:31:26.434
a little bit
about the communication layer,

00:31:26.434 --> 00:31:30.501
some new communication APIs
that are landing.

00:31:30.501 --> 00:31:33.133
One of the ones that's actually
being implemented quite widely

00:31:33.133 --> 00:31:36.000
is postMessage.

00:31:36.000 --> 00:31:40.601
This method allows you to--
it exists on windows

00:31:40.601 --> 00:31:44.634
and allows you to communicate
from one window to another.

00:31:44.634 --> 00:31:47.200
So, like from a page
to an iframe.

00:31:47.200 --> 00:31:49.434
You know, an iframe
to a parent page.

00:31:49.434 --> 00:31:51.667
Things of that nature.

00:31:51.667 --> 00:31:55.200
But what's so good about it
is that it works across domain.

00:31:55.200 --> 00:31:58.267
It doesn't matter, you know,
if the frames are owned

00:31:58.267 --> 00:32:00.701
by different domains.

00:32:00.701 --> 00:32:04.434
So, for example, if you had
an iframe on your page,

00:32:04.434 --> 00:32:07.000
you could send it
a text message, you know, test

00:32:07.000 --> 00:32:10.367
or what have you
and a URL.

00:32:10.367 --> 00:32:14.501
The URL specifies--you're
saying, "Send this message

00:32:14.501 --> 00:32:19.400
to this iframe
only if it matches this URL."

00:32:19.400 --> 00:32:23.601
The iframe then would then
listen for messages

00:32:23.601 --> 00:32:26.567
to get passed into it
from postMessage.

00:32:26.567 --> 00:32:29.234
And so it listens
for a message event

00:32:29.234 --> 00:32:32.801
and then verifies the origin
of the incoming message.

00:32:32.801 --> 00:32:36.234
You know, makes sure that the
message is coming from a domain

00:32:36.234 --> 00:32:38.400
that it trusts,
and, if not, you know,

00:32:38.400 --> 00:32:40.901
just stops doing
whatever it was gonna do

00:32:40.901 --> 00:32:43.334
but otherwise uses the data
that's coming in.

00:32:43.334 --> 00:32:46.434
So using postMessage,
you can implement

00:32:46.434 --> 00:32:48.667
all sorts of interesting things.

00:32:48.667 --> 00:32:50.467
In some personal experiments
of mine,

00:32:50.467 --> 00:32:52.300
I've used postMessage
to implement, you know,

00:32:52.300 --> 00:32:55.167
a cross-domain XMLHttpRequest

00:32:55.167 --> 00:32:57.501
because you just insert
a little iframe,

00:32:57.501 --> 00:32:59.367
you start doing communication
back and forth.

00:32:59.367 --> 00:33:01.901
And it becomes, you know,
very usable.

00:33:01.901 --> 00:33:06.834
So this is, I think,
a very interesting new API.

00:33:06.834 --> 00:33:12.167
Then there's true cross-domain
XMLHttpRequest.

00:33:12.167 --> 00:33:17.300
This is using
the W3C Access Control API.

00:33:17.300 --> 00:33:21.901
And if on--
so what you do is you use

00:33:21.901 --> 00:33:24.534
XMLHttpRequest as normal,
and you would try

00:33:24.534 --> 00:33:26.667
to request
a remote document.

00:33:26.667 --> 00:33:31.067
It verifies if certain headers
are in place

00:33:31.067 --> 00:33:36.400
that will allow a piece
of XML, HTML, what have you

00:33:36.400 --> 00:33:37.601
to be requested.

00:33:37.601 --> 00:33:39.934
So in the case
of the Access Control,

00:33:39.934 --> 00:33:41.334
you can specify,
for example,

00:33:41.334 --> 00:33:42.767
Access-Control-Allow-Origin.

00:33:42.767 --> 00:33:45.234
And then you can specify
a single URL,

00:33:45.234 --> 00:33:46.434
so it'll, say, you know,

00:33:46.434 --> 00:33:47.934
only allow things
that come from Google,

00:33:47.934 --> 00:33:49.567
only allow requests that come
from Google,

00:33:49.567 --> 00:33:50.634
or, in this case, star,

00:33:50.634 --> 00:33:52.367
allow requests to come
from everywhere.

00:33:52.367 --> 00:33:56.000
And you can really filter down
this way.

00:33:56.000 --> 00:33:57.400
So what's interesting is that

00:33:57.400 --> 00:34:01.534
this new Access Control
specification is starting

00:34:01.534 --> 00:34:03.801
to be used, like, everywhere

00:34:03.801 --> 00:34:08.400
within the specifications
within HTML 5.

00:34:08.400 --> 00:34:12.400
And it's very likely
that--there's still a lot

00:34:12.400 --> 00:34:14.467
of debate, I should say,
over whether or not

00:34:14.467 --> 00:34:17.968
this should be specified
for like audio and video tags--

00:34:17.968 --> 00:34:21.133
so that if you want to include
a remote video,

00:34:21.133 --> 00:34:22.801
that, you know, does it have
to have these headers

00:34:22.801 --> 00:34:25.400
to allow you to access
that video?

00:34:25.400 --> 00:34:27.567
It's not really clear
at this point.

00:34:27.567 --> 00:34:32.267
employee: [inaudible]

00:34:32.267 --> 00:34:35.734
Resig: Uh, so, yeah, this is
the response header, correct.

00:34:35.734 --> 00:34:39.467
So in this case, yeah,
if you had an HTML page

00:34:39.467 --> 00:34:42.300
on a remote domain and you
tacked on that extra header,

00:34:42.300 --> 00:34:44.968
you would be able to--
any browser that supported

00:34:44.968 --> 00:34:47.267
this cross-domain XHR
would be able to request it.

00:34:47.267 --> 00:34:52.267
Yeah.

00:34:52.267 --> 00:34:54.234
Um, there's some
decent improvements coming

00:34:54.234 --> 00:34:57.200
in DOM Navigation.

00:34:57.200 --> 00:35:01.400
One of the early ones to land
was getElementsByClassName,

00:35:01.400 --> 00:35:05.334
you know, allowing you
to find all sorts of--

00:35:05.334 --> 00:35:08.300
you know, find elements on page
that have a specified class.

00:35:08.300 --> 00:35:12.601
This is in some current
browsers: Safari 3.1,

00:35:12.601 --> 00:35:18.000
Firefox 3.0, and Opera 9.6.

00:35:18.000 --> 00:35:20.501
We just found a bug,
just the other day,

00:35:20.501 --> 00:35:21.934
in Opera's implementation.

00:35:21.934 --> 00:35:26.467
It's unable to find--
actually, this example here

00:35:26.467 --> 00:35:28.033
doesn't work in Opera 9.6.

00:35:28.033 --> 00:35:31.567
Uh, it's not able to find the
second class in a class name.

00:35:31.567 --> 00:35:34.834
For whatever reason,
it can only find the first one.

00:35:34.834 --> 00:35:38.767
So, yeah, it's still a work
in progress.

00:35:38.767 --> 00:35:40.567
But at the very least,
it's very fast.

00:35:40.567 --> 00:35:43.467
It's way, way faster.
Just to show you...

00:35:43.467 --> 00:35:45.367
So like on the left--
on the right here,

00:35:45.367 --> 00:35:49.167
we have some old school methods,
just pure JavaScript DOM.

00:35:49.167 --> 00:35:50.901
We have an XPath implementation,

00:35:50.901 --> 00:35:53.367
but then there's the native
getElementsByClassName,

00:35:53.367 --> 00:35:58.334
and it's a tiny, tiny fraction
of the normal cost.

00:35:58.334 --> 00:36:00.667
And simply because of that,
JavaScript frameworks

00:36:00.667 --> 00:36:03.467
that take advantage of it
are instantly sped up.

00:36:03.467 --> 00:36:05.567
And, you know, using it
in your code is,

00:36:05.567 --> 00:36:09.601
you know, it's a huge win.

00:36:09.601 --> 00:36:11.968
One of the things
I'm really excited about now

00:36:11.968 --> 00:36:14.934
is the new Selectors API.

00:36:14.934 --> 00:36:20.100
This is the W3C specification,
Selectors API specification.

00:36:20.100 --> 00:36:25.334
And it gives you new methods
for finding elements on a page

00:36:25.334 --> 00:36:29.801
using CSS selectors.

00:36:29.801 --> 00:36:32.934
And so it's good because you get
the best of both worlds.

00:36:32.934 --> 00:36:34.634
You get an intuitive syntax.

00:36:34.634 --> 00:36:38.100
You know, developers already
familiar with CSS rules,

00:36:38.100 --> 00:36:39.567
you know,
for how they match elements--

00:36:39.567 --> 00:36:41.667
and, you know,
at the same time,

00:36:41.667 --> 00:36:46.701
you get just crazy, crazy speed.

00:36:46.701 --> 00:36:48.734
I'm really excited by the fact
that it's--

00:36:48.734 --> 00:36:50.234
everyone's implementing it.

00:36:50.234 --> 00:36:53.567
It's implemented in IE 8,
Opera 10...

00:36:53.567 --> 00:36:56.367
it's gonna be in Firefox 3.1,
in Safari 4.

00:36:56.367 --> 00:36:59.901
It's everywhere,
and I'm really excited by that.

00:36:59.901 --> 00:37:02.434
This is to show you
some performance.

00:37:02.434 --> 00:37:03.634
On the left here we have

00:37:03.634 --> 00:37:05.767
some traditional
JavaScript libraries

00:37:05.767 --> 00:37:09.067
that are just using
regular JavaScript quer--

00:37:09.067 --> 00:37:10.267
you know, JavaScript DOM.

00:37:10.267 --> 00:37:13.501
Then on the right is
querySelectorAll.

00:37:13.501 --> 00:37:16.133
And it's a tenth--

00:37:16.133 --> 00:37:19.434
you know, it's ten times faster
than the next closest library.

00:37:19.434 --> 00:37:22.434
Of course, all the libraries now
are adopting querySelectorAll,

00:37:22.434 --> 00:37:25.300
since it makes
a ton of sense to.

00:37:25.300 --> 00:37:29.734
So that's gonna be really great.

00:37:29.734 --> 00:37:32.868
One of the new specifications
that's just finishing up

00:37:32.868 --> 00:37:37.534
and starting to land in browsers
is called the Traversal API.

00:37:37.534 --> 00:37:41.534
Again, this is
a W3C specification.

00:37:41.534 --> 00:37:44.067
It's implemented in Firefox 3.1.

00:37:44.067 --> 00:37:46.267
But it gives you
a couple methods you can use

00:37:46.267 --> 00:37:50.501
to make navigating
around a DOM document easier.

00:37:50.501 --> 00:37:57.033
Roughly, it makes it so you can
access element siblings.

00:37:57.033 --> 00:38:00.634
'Cause traditionally there's--
if you access, you know,

00:38:00.634 --> 00:38:03.067
firstChild or lastChild
or, you know, what have you,

00:38:03.067 --> 00:38:06.701
you could get a comment node,
you could get a text node,

00:38:06.701 --> 00:38:08.467
you could get
any number of these things.

00:38:08.467 --> 00:38:12.400
And when--a lot of the time
developers just want to get

00:38:12.400 --> 00:38:13.701
the elements
that are there,

00:38:13.701 --> 00:38:17.634
since that's usually
what's visible.

00:38:17.634 --> 00:38:19.934
So those four things
are in the specification.

00:38:19.934 --> 00:38:21.667
They just landed
in Firefox 3.1.

00:38:21.667 --> 00:38:25.834
But one of the things that's
unrelated to that specification

00:38:25.834 --> 00:38:27.267
is .children.

00:38:27.267 --> 00:38:30.567
This was something that was
originally in Internet Explorer.

00:38:30.567 --> 00:38:33.834
But it is now implemented
in every browser.

00:38:33.834 --> 00:38:37.567
Every browser now implements it
and allows you to get

00:38:37.567 --> 00:38:41.434
only the child elements
of a parent element.

00:38:41.434 --> 00:38:44.133
And so, I mean,
in a lot of ways,

00:38:44.133 --> 00:38:47.033
having .children around
kind of removes the need

00:38:47.033 --> 00:38:48.400
for this new specification.

00:38:48.400 --> 00:38:53.100
But the nice thing
is that in Firefox 3.1,

00:38:53.100 --> 00:38:54.701
they actually implement
.children,

00:38:54.701 --> 00:39:00.100
so now it'll be
absolutely everywhere.

00:39:00.100 --> 00:39:02.434
All right, so drag and drop.

00:39:02.434 --> 00:39:06.567
There's--some browsers are
actually starting

00:39:06.567 --> 00:39:10.400
to implement the HTML 5 style
of drag and drop.

00:39:10.400 --> 00:39:13.501
There's--you get all sorts
of messages to indicate,

00:39:13.501 --> 00:39:16.701
you know, events to indicate
when dragging is occurring,

00:39:16.701 --> 00:39:18.501
starting, and stopping.

00:39:18.501 --> 00:39:21.767
And you can hook into this
and transfer data

00:39:21.767 --> 00:39:23.801
from different points
in the document.

00:39:23.801 --> 00:39:25.901
It's pretty cool

00:39:25.901 --> 00:39:30.534
and something that really should
have been done a long time ago.

00:39:30.534 --> 00:39:32.334
So we're starting
to see this now start

00:39:32.334 --> 00:39:34.734
to land in browsers.

00:39:34.734 --> 00:39:37.467
But in the meantime
we're kinda stuck

00:39:37.467 --> 00:39:39.300
since not everyone implements
yet.

00:39:39.300 --> 00:39:41.601
But in the meantime
we can use

00:39:41.601 --> 00:39:43.033
getBoundingClientRect.

00:39:43.033 --> 00:39:44.801
This is a method
that is starting

00:39:44.801 --> 00:39:46.434
to get implemented more.

00:39:46.434 --> 00:39:48.067
This is
an Internet Explorer method,

00:39:48.067 --> 00:39:49.601
historically.

00:39:49.601 --> 00:39:51.033
And it's starting to get
implemented more

00:39:51.033 --> 00:39:52.667
in more browsers.

00:39:52.667 --> 00:39:55.100
And what it allows you to do
is it allows you to find--

00:39:55.100 --> 00:39:58.667
get a pretty accurate
representation of the position

00:39:58.667 --> 00:39:59.801
of an element
in a document.

00:39:59.801 --> 00:40:01.634
And when you're doing
drag and drop,

00:40:01.634 --> 00:40:03.701
you need to determine
pretty accurately

00:40:03.701 --> 00:40:05.834
where that element
is currently located

00:40:05.834 --> 00:40:07.467
so that you can move it
accurately

00:40:07.467 --> 00:40:10.167
and so that you can position it
well.

00:40:10.167 --> 00:40:12.200
And so it's really fast,

00:40:12.200 --> 00:40:13.734
and it's starting
to get implemented more,

00:40:13.734 --> 00:40:18.100
which is awesome.

00:40:18.100 --> 00:40:22.234
Another great thing
that I'm really excited about

00:40:22.234 --> 00:40:26.901
is the inclusion
of threading in JavaScript.

00:40:26.901 --> 00:40:29.767
This is just starting
to come out here.

00:40:29.767 --> 00:40:33.868
And it's really, really exciting
to see this land.

00:40:33.868 --> 00:40:39.033
So what it's called--
it's called Web Workers.

00:40:39.033 --> 00:40:44.100
And it's not threading
in the true sense.

00:40:44.100 --> 00:40:47.367
But what you can do
is you can spawn scripts

00:40:47.367 --> 00:40:48.901
that can run in the background,

00:40:48.901 --> 00:40:50.200
and you can communicate
with them

00:40:50.200 --> 00:40:53.801
and, you know,
using message passing.

00:40:53.801 --> 00:40:57.601
So just to show you
a simple example,

00:40:57.601 --> 00:41:02.267
here we have a script
being loaded in externally,

00:41:02.267 --> 00:41:06.167
so in this case, it loads
into myWorker script file

00:41:06.167 --> 00:41:08.000
and executes it
in the background.

00:41:08.000 --> 00:41:12.167
Then, at the same time, whenever
the worker is done executing,

00:41:12.167 --> 00:41:15.067
a message will get passed back
to the message callback.

00:41:15.067 --> 00:41:18.067
So you can start to communicate
back and forth

00:41:18.067 --> 00:41:20.934
with these scripts
that are getting loaded

00:41:20.934 --> 00:41:23.367
in these workers.

00:41:23.367 --> 00:41:28.000
I just wanted to show
an example.

00:41:28.000 --> 00:41:31.667
So this is done
by Oliver Hunt.

00:41:31.667 --> 00:41:36.334
He's on the WebKit SquirrelFish
team.

00:41:36.334 --> 00:41:40.934
And he built a raytracer
in JavaScript.

00:41:40.934 --> 00:41:42.934
So I'm just gonna disable this.

00:41:42.934 --> 00:41:45.801
So right now,
it's using the canvas element

00:41:45.801 --> 00:41:47.033
to draw.

00:41:47.033 --> 00:41:49.968
If we run this,
we can see it truck along.

00:41:49.968 --> 00:41:51.868
So this is
just regular JavaScript

00:41:51.868 --> 00:41:53.801
communicating with Canvas,
you know,

00:41:53.801 --> 00:41:57.133
doing all the calculation,
and drawing everything out.

00:41:57.133 --> 00:41:59.067
It takes a while.

00:41:59.067 --> 00:42:01.133
It is...

00:42:01.133 --> 00:42:06.067
even in this right here,
this is Safari nightly.

00:42:06.067 --> 00:42:12.300
It's still gonna take, I'd say,
about 15, 20 seconds to run.

00:42:12.300 --> 00:42:15.234
So once that finishes...

00:42:15.234 --> 00:42:16.767
Okay, 27 seconds.

00:42:16.767 --> 00:42:18.734
All right, so let's reload,

00:42:18.734 --> 00:42:21.033
and let's add in
a couple worker threads.

00:42:21.033 --> 00:42:23.200
So what that's gonna do,
it's gonna break apart

00:42:23.200 --> 00:42:25.834
different portions
of the image to render,

00:42:25.834 --> 00:42:27.367
send it to each
of the workers,

00:42:27.367 --> 00:42:29.667
so that when they're done,
it'll report back and draw them.

00:42:29.667 --> 00:42:32.634
So let's run this now.

00:42:32.634 --> 00:42:34.000
There we go.

00:42:34.000 --> 00:42:37.834
All the worker threads did it
in 3 1/2 seconds.

00:42:37.834 --> 00:42:39.601
So almost ten times faster.

00:42:39.601 --> 00:42:41.267
And that was
with only four worker threads.

00:42:41.267 --> 00:42:44.501
We can probably up that
a little bit,

00:42:44.501 --> 00:42:49.701
figure out a sweet spot.

00:42:49.701 --> 00:42:54.434
[a cough and laughter]

00:42:54.434 --> 00:42:55.634
Say what?

00:42:55.634 --> 00:42:58.801
employee: [inaudible]

00:42:58.801 --> 00:43:00.234
Resig: I don't know.

00:43:00.234 --> 00:43:03.501
He was asking, "Is it because
of a set time out or something?"

00:43:03.501 --> 00:43:08.200
Not sure.

00:43:08.200 --> 00:43:10.701
I'm not...

00:43:10.701 --> 00:43:12.667
I'm not sure what the--like I
was talking to him before

00:43:12.667 --> 00:43:16.767
about his implementation
about why, you know,

00:43:16.767 --> 00:43:20.701
I guess--here, I guess we can go
down to one worker thread.

00:43:20.701 --> 00:43:22.367
We can't really see it.
It's not exciting.

00:43:22.367 --> 00:43:27.801
Hang on.

00:43:27.801 --> 00:43:31.734
So my guess, maybe just
the other implementation

00:43:31.734 --> 00:43:34.267
he had was just bad,
maybe.

00:43:34.267 --> 00:43:37.133
But even so,
using one worker thread

00:43:37.133 --> 00:43:40.667
took 6 1/2 seconds.

00:43:40.667 --> 00:43:44.367
Four worker threads was able
to speed it up to 3 1/2.

00:43:44.367 --> 00:43:47.300
So there's a definite room
for speedup.

00:43:47.300 --> 00:43:49.467
Unfortunately, there are a lot
of gotchas

00:43:49.467 --> 00:43:51.734
with this new worker thread
stuff,

00:43:51.734 --> 00:43:56.267
one of which is
that when you pass messages

00:43:56.267 --> 00:43:59.400
to one of these workers,

00:43:59.400 --> 00:44:01.200
it has to be as a string.

00:44:01.200 --> 00:44:05.200
A nice thing, though, is--I'm
glad they started to do this--

00:44:05.200 --> 00:44:08.000
that if you pass in
a JavaScript object,

00:44:08.000 --> 00:44:10.434
it'll serialize it
as JSON

00:44:10.434 --> 00:44:12.300
and then deserialize it
again.

00:44:12.300 --> 00:44:15.200
So the important thing here
is that they wanted to make sure

00:44:15.200 --> 00:44:18.133
there could be
no information leak.

00:44:18.133 --> 00:44:22.000
No access to external windows
or anything

00:44:22.000 --> 00:44:25.367
that an inner thread
shouldn't have access to.

00:44:25.367 --> 00:44:30.868
And, additionally, these inner
threads have a really limited...

00:44:30.868 --> 00:44:33.100
existence, let's say.

00:44:33.100 --> 00:44:35.901
They only have access
to basic JavaScript.

00:44:35.901 --> 00:44:37.534
They don't have access
to the DOM,

00:44:37.534 --> 00:44:39.000
they don't have access
to Canvas,

00:44:39.000 --> 00:44:40.534
they don't have access
to any of this stuff.

00:44:40.534 --> 00:44:43.667
So in the case
of these threads here,

00:44:43.667 --> 00:44:45.167
what's really happening is
they're probably just pushing

00:44:45.167 --> 00:44:47.701
around, you know, matrices
and numbers.

00:44:47.701 --> 00:44:52.167
Then the main thread,
the one in the window,

00:44:52.167 --> 00:44:55.133
is just, you know, is the one
that's actually doing

00:44:55.133 --> 00:44:56.534
the rendering
to the canvas.

00:44:56.534 --> 00:44:58.167
So...

00:44:58.167 --> 00:44:59.567
[yawns]

00:44:59.567 --> 00:45:02.133
I definitely hope
that at some point

00:45:02.133 --> 00:45:07.100
we'll be able to pass around
canvas objects--

00:45:07.100 --> 00:45:09.467
pass a canvas object
to a thread worker

00:45:09.467 --> 00:45:11.133
and then have it come back
with some results.

00:45:11.133 --> 00:45:14.133
That would be really awesome.

00:45:14.133 --> 00:45:17.267
Any questions
on the worker thread stuff?

00:45:22.000 --> 00:45:24.033
Okay, so...

00:45:24.033 --> 00:45:28.400
there are a lot
of different, I guess,

00:45:28.400 --> 00:45:33.701
CSS-related things
that started to get implemented,

00:45:33.701 --> 00:45:38.067
and these are different stylings
and effects you can apply

00:45:38.067 --> 00:45:41.300
to your site,
but while they don't provide

00:45:41.300 --> 00:45:46.267
an immediate, obvious,
JavaScripty performance boost,

00:45:46.267 --> 00:45:49.434
what they do is they allow you
to dramatically simplify

00:45:49.434 --> 00:45:53.367
your markup and remove
all sorts of [indistinct]

00:45:53.367 --> 00:45:56.501
you won't have to deal with
anymore.

00:45:56.501 --> 00:45:59.968
One of the popular ones is--
one of the ones

00:45:59.968 --> 00:46:01.167
that was implemented
really early

00:46:01.167 --> 00:46:03.634
was the ability
to do rounded corners.

00:46:03.634 --> 00:46:05.567
Traditionally, in order
to do rounded corners,

00:46:05.567 --> 00:46:08.167
either required loading in
extra images

00:46:08.167 --> 00:46:09.434
to represent the corners

00:46:09.434 --> 00:46:12.667
or doing all sorts
of really nasty hacks

00:46:12.667 --> 00:46:17.701
or lots of little divs
being spaced around.

00:46:17.701 --> 00:46:20.868
And either way,
the old methods were not good.

00:46:20.868 --> 00:46:25.534
But with the new CSS properties,
you can just add in corners

00:46:25.534 --> 00:46:28.434
as part of your style sheet.

00:46:28.434 --> 00:46:32.634
There's also the concept
of shadows.

00:46:32.634 --> 00:46:36.400
Both having shadows on text,
so a drop shadow,

00:46:36.400 --> 00:46:39.767
but being able to have shadows
around arbitrary elements.

00:46:39.767 --> 00:46:44.434
So if you have a div
that's supposed to be hovering

00:46:44.434 --> 00:46:46.701
somewhere on the page, you can
actually put a drop shadow

00:46:46.701 --> 00:46:51.801
behind it now
and give that extra appearance.

00:46:51.801 --> 00:46:56.734
And this is implemented
both in WebKit and Firefox.

00:46:56.734 --> 00:46:58.400
See, I wanted to show...

00:46:58.400 --> 00:47:00.267
I'll jump back
to the examples here real quick.

00:47:00.267 --> 00:47:05.200
But there's also the ability
to load in custom fonts.

00:47:05.200 --> 00:47:08.634
So right now most solutions
for loading in fonts

00:47:08.634 --> 00:47:11.601
are usually, you know,
Flash-based.

00:47:11.601 --> 00:47:16.701
Like there's sIFR
and other ones of that nature.

00:47:16.701 --> 00:47:18.634
And they load in a font file
and render it

00:47:18.634 --> 00:47:21.868
in a Flash context.

00:47:21.868 --> 00:47:24.167
But what's starting to happen
is actually getting

00:47:24.167 --> 00:47:28.267
some good font--
custom font support in CSS.

00:47:28.267 --> 00:47:29.767
Let's see.

00:47:29.767 --> 00:47:32.100
Oh, and then,
before I jump to the demo,

00:47:32.100 --> 00:47:35.868
there's also
a new transformations

00:47:35.868 --> 00:47:37.367
and animations
starting to land,

00:47:37.367 --> 00:47:39.834
so WebKit has been really
pushing forward here.

00:47:39.834 --> 00:47:42.968
It's starting to land
all sorts of new ways

00:47:42.968 --> 00:47:45.000
to do animations
from CSS,

00:47:45.000 --> 00:47:47.067
so no JavaScript involved
whatsoever.

00:47:47.067 --> 00:47:49.467
And it's really quite exciting.

00:47:49.467 --> 00:47:55.334
So let me show
some of these demos here.

00:47:55.334 --> 00:47:57.801
This is an example
of the box shadows.

00:47:57.801 --> 00:48:00.667
So these are
just normal little divs.

00:48:00.667 --> 00:48:04.767
You know, you can resize it
and the shadows persist.

00:48:04.767 --> 00:48:09.400
And these are all just styled
with this box shadow property.

00:48:09.400 --> 00:48:12.167
Here we have Text-Shadow.

00:48:12.167 --> 00:48:15.734
This guy made
a hilarious demo page

00:48:15.734 --> 00:48:19.634
of things you should not do
with Text-Shadow.

00:48:19.634 --> 00:48:23.100
And so he animated
the Text-Shadows,

00:48:23.100 --> 00:48:24.767
and so added a fire style.

00:48:24.767 --> 00:48:27.601
I like that one.

00:48:27.601 --> 00:48:29.334
And then, you know, just showed
all sorts of ways--

00:48:29.334 --> 00:48:31.234
using shadows,
you can get things that look

00:48:31.234 --> 00:48:37.801
like they've been embossed
or things of that nature.

00:48:37.801 --> 00:48:41.667
There's also the concept
of transformations.

00:48:41.667 --> 00:48:46.968
So, in this case,
these are set to animate

00:48:46.968 --> 00:48:49.234
when I move my mouse
over it

00:48:49.234 --> 00:48:51.167
and then start to transform
an element.

00:48:51.167 --> 00:48:53.100
So it transformed by position.

00:48:53.100 --> 00:48:55.234
This is all CSS.
There's no JavaScript.

00:48:55.234 --> 00:48:59.267
Rotate.
Grow in size.

00:48:59.267 --> 00:49:01.767
And then you can also combine
properties.

00:49:01.767 --> 00:49:04.868
So in this case it's actually
animating rounded corners,

00:49:04.868 --> 00:49:10.167
color, and size
all at the same time.

00:49:10.167 --> 00:49:14.334
Yeah, so it can get
pretty exciting.

00:49:14.334 --> 00:49:16.133
I'm sure that'll be abused
in many, many ways.

00:49:16.133 --> 00:49:17.701
[laughter]

00:49:17.701 --> 00:49:21.701
And then here's an example
using custom loaded fonts.

00:49:21.701 --> 00:49:24.934
So you can see
this is actual real text here.

00:49:24.934 --> 00:49:28.334
And it's all being styled
using True Type fonts

00:49:28.334 --> 00:49:29.934
that were dynamically loaded in.

00:49:29.934 --> 00:49:32.367
Let me see if I can hard reload
here, so you can see the--

00:49:32.367 --> 00:49:33.701
oh, yeah, it's all good.

00:49:33.701 --> 00:49:35.734
Yeah, it just gets
all pulled in there.

00:49:35.734 --> 00:49:40.334
Um, okay.

00:49:40.334 --> 00:49:43.200
One of the things that I've been
most excited about lately

00:49:43.200 --> 00:49:48.100
that's been getting
really good support in browsers

00:49:48.100 --> 00:49:51.334
has been
the new HTML 5 canvas element.

00:49:51.334 --> 00:49:54.434
And this new element allows--
essentially gives you

00:49:54.434 --> 00:49:59.868
a 2D just box,
which you can draw.

00:49:59.868 --> 00:50:03.601
You know, arbitrary shapes
and pixels and what have you.

00:50:03.601 --> 00:50:06.167
But it gives you
a ton of power

00:50:06.167 --> 00:50:09.000
to be able to actually draw
on a Web page.

00:50:09.000 --> 00:50:12.234
And the things that people
have been doing with it

00:50:12.234 --> 00:50:15.367
are really quite fantastic.

00:50:15.367 --> 00:50:17.968
There's also a library
that was produced here at Google

00:50:17.968 --> 00:50:20.968
called ExCanvas
that allows you to use Canvas

00:50:20.968 --> 00:50:23.400
in other browsers--
oh, sorry, use Canvas

00:50:23.400 --> 00:50:24.734
in processes
that don't support it

00:50:24.734 --> 00:50:26.334
like Internet Explorer.

00:50:26.334 --> 00:50:28.601
Unfortunately, it doesn't
support some of the new APIs,

00:50:28.601 --> 00:50:32.067
like being able to do work
with matrices of pixels

00:50:32.067 --> 00:50:34.200
and things of that nature.

00:50:34.200 --> 00:50:39.067
I wanted to show
a quick demo.

00:50:39.067 --> 00:50:44.033
I released early last year
something--

00:50:44.033 --> 00:50:47.868
I ported the processing
visualization language

00:50:47.868 --> 00:50:50.701
that was--it's a Java language.

00:50:50.701 --> 00:50:52.133
I put it in Java,
and it allows you to do

00:50:52.133 --> 00:50:54.100
all sorts of visualizations.

00:50:54.100 --> 00:50:57.667
I ported it to a JavaScript
running inside a canvas.

00:50:57.667 --> 00:51:04.334
I wanted to show
some examples here.

00:51:04.334 --> 00:51:05.734
This is a simple one.

00:51:05.734 --> 00:51:09.234
So this is just doing--
it's basic collision detection

00:51:09.234 --> 00:51:11.701
and multiple objects
being rendered.

00:51:11.701 --> 00:51:16.501
It's all in real time in a
canvas element using JavaScript.

00:51:16.501 --> 00:51:18.901
Oh, let's see here.

00:51:18.901 --> 00:51:20.834
Um...

00:51:24.834 --> 00:51:28.834
So this one is actually--
oops--it's scanning

00:51:28.834 --> 00:51:32.133
the pixels of an image and
rendering out the different--

00:51:32.133 --> 00:51:33.968
it's going by pixel by pixel
through an image

00:51:33.968 --> 00:51:37.367
that's loaded into a canvas and
drawing out the pixels of it.

00:51:37.367 --> 00:51:38.868
Uh, let's see.

00:51:38.868 --> 00:51:41.834
You can actually see
where exactly in the image

00:51:41.834 --> 00:51:47.167
it's currently pulling from.

00:51:47.167 --> 00:51:49.901
Let's see here.

00:51:49.901 --> 00:51:51.534
I like this one.

00:51:51.534 --> 00:51:53.133
This is a flock of birds.

00:51:53.133 --> 00:51:56.200
So this is--you can really
start to see the performance

00:51:56.200 --> 00:51:57.534
of these JavaScript engines.

00:51:57.534 --> 00:52:00.300
So it's doing all
the computation to figure out

00:52:00.300 --> 00:52:02.901
how the birds should be flocking
together

00:52:02.901 --> 00:52:06.901
and then rendering them
simultaneously to the canvas.

00:52:10.367 --> 00:52:11.934
I like this one too.

00:52:11.934 --> 00:52:15.968
This is sort of a blobby shape
that you can play around with.

00:52:15.968 --> 00:52:21.634
Yeah, I just have
way too much fun with this.

00:52:21.634 --> 00:52:23.033
But I love Canvas.

00:52:23.033 --> 00:52:26.400
I think it's definitely
one of the best things

00:52:26.400 --> 00:52:31.934
that come out in Web development
as a whole.

00:52:31.934 --> 00:52:34.234
Just showing you some examples
of what things you can do

00:52:34.234 --> 00:52:35.801
with Canvas.

00:52:35.801 --> 00:52:37.601
It gives you--
the important thing to realize

00:52:37.601 --> 00:52:39.534
is that Canvas is not SVG.

00:52:39.534 --> 00:52:41.267
You're not dealing
with vectors.

00:52:41.267 --> 00:52:45.133
And you can't mutate shapes
once you draw them.

00:52:45.133 --> 00:52:46.934
You can think of it
like Microsoft Paint.

00:52:46.934 --> 00:52:49.467
You put it down, it's there, and
the only way to get rid of it

00:52:49.467 --> 00:52:51.100
is to draw on top of it.

00:52:51.100 --> 00:52:55.234
So you're constantly just--
you have some basic primitives

00:52:55.234 --> 00:52:56.968
from drawing rectangles
and circles

00:52:56.968 --> 00:52:59.167
and, you know,
things of that nature.

00:52:59.167 --> 00:53:03.133
Then, when you draw it,
you can--you're given

00:53:03.133 --> 00:53:05.400
a series of fills
and strokes.

00:53:05.400 --> 00:53:07.234
You can fill a rectangle
with a color,

00:53:07.234 --> 00:53:09.434
set a stroke
on the outline,

00:53:09.434 --> 00:53:12.734
things like that.

00:53:12.734 --> 00:53:14.501
Yes.

00:53:14.501 --> 00:53:18.434
Okay, the thing that's nice
about Canvas, though,

00:53:18.434 --> 00:53:21.601
is that it behaves just like
a normal HTML element.

00:53:21.601 --> 00:53:25.868
You can embed it straight
in line.

00:53:25.868 --> 00:53:29.334
It handles zIndex properly,
opacity.

00:53:29.334 --> 00:53:31.801
It behaves completely normal,
so I've seen cases

00:53:31.801 --> 00:53:34.400
where people have used canvases
to do things

00:53:34.400 --> 00:53:36.300
like drop shadows
or rounded corners

00:53:36.300 --> 00:53:38.434
for browsers
that don't have them.

00:53:38.434 --> 00:53:42.567
Being able to draw
custom backgrounds

00:53:42.567 --> 00:53:48.701
and all sorts of things
dynamically

00:53:48.701 --> 00:53:51.033
using canvas elements.

00:53:51.033 --> 00:53:54.234
There's really a lot
of possibilities.

00:53:54.234 --> 00:53:56.467
Canvases themselves
can consume images,

00:53:56.467 --> 00:53:58.801
so you can port
an image into a canvas.

00:53:58.801 --> 00:54:02.400
And additionally,
in Firefox 3 and Safari 4,

00:54:02.400 --> 00:54:04.767
which have the video element,
you'll be able to take

00:54:04.767 --> 00:54:07.601
a frame of a video
and put it in a canvas element

00:54:07.601 --> 00:54:13.667
and manipulate it, so that
that'll be pretty exciting.

00:54:13.667 --> 00:54:17.200
One of the things that's
also seeing a lot of play

00:54:17.200 --> 00:54:19.868
is the ability
to have better control

00:54:19.868 --> 00:54:21.934
over data
on the client-side.

00:54:21.934 --> 00:54:25.234
And one of the big things
has been the introduction

00:54:25.234 --> 00:54:27.100
of some sort
of SQL storage

00:54:27.100 --> 00:54:28.400
on the client-side.

00:54:28.400 --> 00:54:31.868
And this was introduced
in HTML 5,

00:54:31.868 --> 00:54:35.133
and it was implemented
in WebKit.

00:54:35.133 --> 00:54:38.567
It gives you a full database,
so you can create a database

00:54:38.567 --> 00:54:42.100
for a Web site and then run SQL
queries against it.

00:54:42.100 --> 00:54:44.334
it's actually just a SQLite
implementation running

00:54:44.334 --> 00:54:45.434
in the background.

00:54:45.434 --> 00:54:47.834
I wanted to show
an example.

00:54:47.834 --> 00:54:53.300
Just the other day, Brandon
Aaron contributed a jQuery.

00:54:53.300 --> 00:54:55.400
He wrote a little API browser.

00:54:55.400 --> 00:54:56.801
This is actually for the iPhone,
but...

00:54:56.801 --> 00:54:59.300
You can browse
through the API,

00:54:59.300 --> 00:55:01.801
and you can view methods
and whatnot.

00:55:01.801 --> 00:55:04.033
But all of this information
was actually loaded up

00:55:04.033 --> 00:55:06.501
in the background.

00:55:06.501 --> 00:55:09.200
And it was actually stored
in a database.

00:55:09.200 --> 00:55:12.567
So if you look here,
and this isn't the console,

00:55:12.567 --> 00:55:14.567
you can see the database.

00:55:14.567 --> 00:55:17.434
And here's--let's see.
Here we go.

00:55:17.434 --> 00:55:19.834
I mean, it's a SQL database.

00:55:19.834 --> 00:55:23.267
And you can go through
and see everything

00:55:23.267 --> 00:55:25.634
that's powering the Web site.

00:55:25.634 --> 00:55:28.367
Additionally, this works
on the iPhone as well.

00:55:28.367 --> 00:55:31.100
So, in this case, when you first
loaded the application

00:55:31.100 --> 00:55:32.701
on the iPhone,
it would download all the data,

00:55:32.701 --> 00:55:34.734
store it in a SQL database
on the iPhone

00:55:34.734 --> 00:55:37.334
so that it would be able
to load faster in the future.

00:55:42.701 --> 00:55:47.534
And then--and then also there's
the native JSON support

00:55:47.534 --> 00:55:49.934
starting to land
in JavaScript engines.

00:55:49.934 --> 00:55:52.901
So this is giving you
the ability to parse JSON

00:55:52.901 --> 00:55:56.167
and be able to convert JSON
or a JavaScript object

00:55:56.167 --> 00:55:58.901
to a string and, you know,
just very, very quickly.

00:55:58.901 --> 00:56:03.534
Just want to show you
the performance breakdown.

00:56:03.534 --> 00:56:09.033
The yellow and purple lines
are traditional types

00:56:09.033 --> 00:56:13.200
of parsing JSON--or I should
say, encoding and then decoding.

00:56:13.200 --> 00:56:18.534
The red line, the one that has
virtually no spike to it,

00:56:18.534 --> 00:56:21.434
is the native one,
so it's dramatically faster.

00:56:21.434 --> 00:56:23.000
It's really quite excellent.

00:56:23.000 --> 00:56:24.300
So I think I'm running
out of time,

00:56:24.300 --> 00:56:26.100
so I just want
to quickly open up

00:56:26.100 --> 00:56:30.033
for questions at this point
if anyone has any questions

00:56:30.033 --> 00:56:33.234
about what I talked about
today.

00:56:33.234 --> 00:56:34.400
Yeah.

00:56:34.400 --> 00:56:36.334
employee: [inaudible]

00:57:29.934 --> 00:57:33.901
So the question was
"Does it make sense

00:57:33.901 --> 00:57:37.667
"to provide a strict mode
that will make it easier

00:57:37.667 --> 00:57:42.701
for interpreters to analyze?"

00:57:42.701 --> 00:57:46.300
Especially in the context
of JavaScript libraries.

00:57:46.300 --> 00:57:48.133
I'm not completely sold on it.

00:57:48.133 --> 00:57:51.701
I mean, the whole reason

00:57:51.701 --> 00:57:54.601
for like a lot
of the old ECMAscript 4 stuff

00:57:54.601 --> 00:57:56.734
was that there was
a huge assumption

00:57:56.734 --> 00:57:59.868
that you weren't gonna be able
to make JavaScript fast

00:57:59.868 --> 00:58:02.834
because JavaScript was--
it's a weird language.

00:58:02.834 --> 00:58:05.701
It isn't statically typed.

00:58:05.701 --> 00:58:09.067
And because of those--
and so they added things

00:58:09.067 --> 00:58:11.634
like classes and types
and all sorts of things.

00:58:11.634 --> 00:58:12.701
And then they found out that,

00:58:12.701 --> 00:58:14.667
hey,
we can make JavaScript fast.

00:58:14.667 --> 00:58:16.868
In fact, we can make JavaScript
really fast.

00:58:16.868 --> 00:58:21.234
So I'm not really sold
on there being restrictions

00:58:21.234 --> 00:58:23.167
to the language.

00:58:23.167 --> 00:58:25.501
Especially
since current browsers seem

00:58:25.501 --> 00:58:27.701
to be doing just fine anyway.

00:58:27.701 --> 00:58:30.801
I think it'll only just limit
what you can do.

00:58:30.801 --> 00:58:32.400
Yeah.

00:58:32.400 --> 00:58:34.267
Another question? Yeah.

00:58:34.267 --> 00:58:36.200
employee: [inaudible]

00:59:01.000 --> 00:59:03.968
&gt;&gt; Resig: So he was saying

00:59:03.968 --> 00:59:07.434
that the performance is getting
much faster,

00:59:07.434 --> 00:59:09.534
but the tools we have
for understanding it

00:59:09.534 --> 00:59:12.934
just aren't there yet
of what's available.

00:59:12.934 --> 00:59:16.734
So, I mean, it's incredibly
difficult at this moment.

00:59:16.734 --> 00:59:19.267
I think one of the big things
going forward

00:59:19.267 --> 00:59:21.601
is that we have to be able
to give developers

00:59:21.601 --> 00:59:24.567
more information
about Start,

00:59:24.567 --> 00:59:28.067
how much CPU and memory
their sites are using

00:59:28.067 --> 00:59:31.000
in all browsers,
not just Chrome

00:59:31.000 --> 00:59:34.400
or whatever browsers
are particularly blessed.

00:59:34.400 --> 00:59:36.167
I would say
it's much more important

00:59:36.167 --> 00:59:40.634
that browsers and browsers
that leak memory badly...

00:59:40.634 --> 00:59:43.200
and so you'll be able
to have good tools there

00:59:43.200 --> 00:59:47.400
so that we can better understand
how to write, let's just say,

00:59:47.400 --> 00:59:49.000
acceptable Web applications.

00:59:49.000 --> 00:59:50.367
All right.

00:59:50.367 --> 00:59:53.901
We'll be able to, I think,
expand a lot better

00:59:53.901 --> 00:59:55.267
from there.

00:59:55.267 --> 00:59:58.100
employee: [inaudible]

01:00:13.300 --> 01:00:16.534
Resig: So the question is
"How much can a site

01:00:16.534 --> 01:00:17.868
really start using these?"

01:00:17.868 --> 01:00:20.834
So the ones that I picked today
are all ones

01:00:20.834 --> 01:00:24.601
that can be used
in some context.

01:00:24.601 --> 01:00:30.067
I mean, obviously, it isn't
an all-or-nothing situation.

01:00:30.067 --> 01:00:33.033
So, for example,
the worker thread.

01:00:33.033 --> 01:00:35.400
You know, the Web Workers.

01:00:35.400 --> 01:00:38.133
You can write one
that works now.

01:00:38.133 --> 01:00:42.334
It draws--it draws very slowly,
but it draws.

01:00:42.334 --> 01:00:46.300
Or it's literally just a drop-in
and you can just start

01:00:46.300 --> 01:00:48.267
to use threads
and get a better performance.

01:00:48.267 --> 01:00:51.467
And, so, I think
there's a lot of cases:

01:00:51.467 --> 01:00:53.501
Workers, getElementByClassName,

01:00:53.501 --> 01:00:56.734
being able to do
the querySelectorAll.

01:00:56.734 --> 01:01:00.400
All that stuff, not only does it
make your stuff faster

01:01:00.400 --> 01:01:05.100
in a very simple way,
but since it's just JavaScript,

01:01:05.100 --> 01:01:06.667
you can just detect to see
if it exists

01:01:06.667 --> 01:01:07.868
and if it exists,
do your fast thing,

01:01:07.868 --> 01:01:09.734
if not,
do your slow thing.

01:01:09.734 --> 01:01:13.033
So I think
there's absolutely room

01:01:13.033 --> 01:01:15.200
for being able
to do all this now.

01:01:15.200 --> 01:01:17.167
And I think it's really
important for developers

01:01:17.167 --> 01:01:18.734
to be able to start
to do that.

01:01:18.734 --> 01:01:21.067
Because if they're able to show

01:01:21.067 --> 01:01:24.701
that newer browsers
not only are faster,

01:01:24.701 --> 01:01:28.467
but are just light years ahead
in performance,

01:01:28.467 --> 01:01:32.200
they'll be able to get users
of IE 6 and older browsers

01:01:32.200 --> 01:01:37.501
to be able to move
and upgrade.

01:01:37.501 --> 01:01:39.100
So I think that's all the time
we have.

01:01:39.100 --> 01:01:41.834
I'll be around for a little bit,
so if you have any questions,

01:01:41.834 --> 01:01:42.834
feel free to ask.

01:01:42.834 --> 01:01:44.434
Thanks for having me.

01:01:44.434 --> 01:01:45.868
[applause]

01:01:45.868 --> 01:01:47.100
&gt;&gt; Souders: Thank you very much,
John.

01:01:47.100 --> 01:01:49.200
 &lt;i&gt;Secrets&lt;/i&gt;
 &lt;i&gt;of the JavaScript Ninja,&lt;/i&gt;

01:01:49.200 --> 01:01:50.501
when do you think it'll be out?

01:01:50.501 --> 01:01:51.734
Resig: This year,
let's say.

01:01:51.734 --> 01:01:53.367
Souders: Okay,
thank you very much.

01:01:53.367 --> 01:01:56.667
Resig: Thank you.

01:01:56.667 --> 01:01:59.701
Souders: [inaudible]

01:01:59.701 --> 01:02:02.534
Resig: Um, not many.
I had like two.

01:02:02.534 --> 01:02:03.534
Yeah, there's two.

01:02:03.534 --> 01:02:06.133
The painting events
and reflow.

