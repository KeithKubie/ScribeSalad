WEBVTT
Kind: captions
Language: en

00:00:00.540 --> 00:00:01.956
AUDIENCE: We're
going to be trying

00:00:01.956 --> 00:00:05.150
to use Dart to handle tens or
hopefully hundreds of thousands

00:00:05.150 --> 00:00:07.790
of simultaneous
socket connections.

00:00:07.790 --> 00:00:12.540
So we looked at it with
Node.js, Dart, Java.

00:00:12.540 --> 00:00:18.070
You can make a C server
that uses epoll directly.

00:00:18.070 --> 00:00:21.380
So Dart was better than
node, but it wasn't better

00:00:21.380 --> 00:00:24.190
than Java or C by a long shot.

00:00:24.190 --> 00:00:25.980
And I was curious if
anybody on the team

00:00:25.980 --> 00:00:30.425
is looking at this problem to
make a super-scalable server.

00:00:30.425 --> 00:00:31.800
SETH LADD: Sorry,
one quick-- did

00:00:31.800 --> 00:00:34.702
everyone hear that or
do we need to repeat?

00:00:34.702 --> 00:00:35.650
OK.

00:00:35.650 --> 00:00:36.972
Cool, go ahead.

00:00:36.972 --> 00:00:38.020
Who would like to answer?

00:00:38.020 --> 00:00:39.576
IVAN POSVA: I didn't
hear the question.

00:00:39.576 --> 00:00:41.200
SETH LADD: Oh, I didn't ask
my panel if somebody heard it.

00:00:41.200 --> 00:00:41.700
Sorry.

00:00:44.500 --> 00:00:45.260
Can you repeat?

00:00:45.260 --> 00:00:46.880
And speak right into it, yeah.

00:00:46.880 --> 00:00:47.504
AUDIENCE: Yeah.

00:00:47.504 --> 00:00:51.840
Basically, we want 100,000
simultaneous socket connections

00:00:51.840 --> 00:00:56.000
to a Dart server and we
want it to scale well,

00:00:56.000 --> 00:00:58.900
within a factor of two
or three from what we

00:00:58.900 --> 00:01:01.370
would get with C and epoll.

00:01:01.370 --> 00:01:03.879
Is there anybody
looking at that?

00:01:03.879 --> 00:01:06.420
IVAN POSVA: I know we have been
looking at it with the server

00:01:06.420 --> 00:01:08.320
team.

00:01:08.320 --> 00:01:12.350
Probably should reach you
with Soren after the break

00:01:12.350 --> 00:01:16.010
here, but we've had ideas
on scaling with isolates

00:01:16.010 --> 00:01:20.870
and basically handing
off requests to isolates.

00:01:20.870 --> 00:01:22.620
AUDIENCE: It could be
in the same isolate.

00:01:22.620 --> 00:01:28.380
We basically-- probably I've
only looked at this problem

00:01:28.380 --> 00:01:30.660
very briefly, I'll admit.

00:01:30.660 --> 00:01:33.190
But when I looked
at it, I wanted

00:01:33.190 --> 00:01:36.510
to see where-- in Java, you
have NIO, which kind of you

00:01:36.510 --> 00:01:39.342
can see how that maps to
epoll on a Linux system.

00:01:39.342 --> 00:01:41.425
Other operation systems
have something like epoll.

00:01:44.440 --> 00:01:46.780
What does that interface
look like in Dart?

00:01:46.780 --> 00:01:50.930
There doesn't seem to be-- it's
very, very deep, kind of buried

00:01:50.930 --> 00:01:54.550
in lots of syncs and so forth.

00:01:54.550 --> 00:01:58.800
So is that maybe something
that can be exposed at a lower

00:01:58.800 --> 00:02:01.270
level to a Dart programmer?

00:02:01.270 --> 00:02:05.180
IVAN POSVA: So if you
use the raw socket API,

00:02:05.180 --> 00:02:08.864
then you get essentially what
epoll is behind the scenes.

00:02:08.864 --> 00:02:11.360
So that's how it works
behind the scenes.

00:02:11.360 --> 00:02:13.605
I don't know how
much of the streams

00:02:13.605 --> 00:02:15.230
and so on add as an overhead.

00:02:15.230 --> 00:02:18.750
That's something that we
should probably measure.

00:02:18.750 --> 00:02:20.190
But there is a raw
socket that you

00:02:20.190 --> 00:02:24.060
could use that is a little
bit more low-level, if you're

00:02:24.060 --> 00:02:26.599
looking forward to that.

00:02:26.599 --> 00:02:28.640
LARS BAK: I just want to
add that a good start is

00:02:28.640 --> 00:02:32.683
to send us a benchmark so
we see what the problem is.

00:02:32.683 --> 00:02:33.610
AUDIENCE: All right.

00:02:33.610 --> 00:02:36.837
Who do we thumb that to, or
can I talk to you later maybe?

00:02:36.837 --> 00:02:37.420
LARS BAK: Yes.

00:02:37.420 --> 00:02:43.302
Just file a bug with
a benchmark attached.

00:02:43.302 --> 00:02:44.130
SETH LADD: Cool.

00:02:44.130 --> 00:02:44.450
Thank you.

00:02:44.450 --> 00:02:45.950
Before we get to
the next question--

00:02:45.950 --> 00:02:47.960
and please keep
continuing to queue up--

00:02:47.960 --> 00:02:49.139
welcome to the panel.

00:02:49.139 --> 00:02:50.930
Again, we've had a lot
of great opportunity

00:02:50.930 --> 00:02:52.820
to talk to various
different engineers here

00:02:52.820 --> 00:02:54.290
and we hope to continue that.

00:02:54.290 --> 00:02:57.170
We're here for you,
so ask us questions.

00:02:57.170 --> 00:03:00.790
But we also asked online with
our moderators who queued up

00:03:00.790 --> 00:03:01.790
a lot of questions here.

00:03:01.790 --> 00:03:02.748
We want to talk to you.

00:03:02.748 --> 00:03:06.620
And to kick it off, I hope we
can introduce our panelists.

00:03:06.620 --> 00:03:09.120
So I could do it, but it'd be
a lot more interesting if they

00:03:09.120 --> 00:03:10.161
can introduce themselves.

00:03:10.161 --> 00:03:13.090
We can learn who they
are, what makes them tick.

00:03:13.090 --> 00:03:17.500
So Lars, can you
introduce yourself?

00:03:17.500 --> 00:03:18.750
LARS BAK: My name is Lars Bak.

00:03:18.750 --> 00:03:20.186
I barely tick.

00:03:20.186 --> 00:03:22.170
[LAUGHTER]

00:03:24.160 --> 00:03:25.750
I'm one of the
founders of Dart, has

00:03:25.750 --> 00:03:31.290
been working on virtual
machines the last 30 years.

00:03:31.290 --> 00:03:33.670
So I care about performance.

00:03:33.670 --> 00:03:35.410
I care about
predictable performance.

00:03:35.410 --> 00:03:40.090
I care about making
programs productive.

00:03:40.090 --> 00:03:41.350
That's it.

00:03:41.350 --> 00:03:43.822
KASPER LUND: Yeah, my
name is Kasper Lund

00:03:43.822 --> 00:03:46.030
and I've been working with
Lars for the last 15 years

00:03:46.030 --> 00:03:48.380
doing various different virtual
machine implementations.

00:03:48.380 --> 00:03:50.570
And the latest project
here is the Dart product

00:03:50.570 --> 00:03:52.290
that I co-founded.

00:03:52.290 --> 00:03:56.430
So right now, I'm working
on providing a good runtime

00:03:56.430 --> 00:03:59.860
system for iOS and
on investigating

00:03:59.860 --> 00:04:05.089
what we can do to make
isolates a lot easier to use.

00:04:05.089 --> 00:04:06.380
DAN RUBEL: My name's Dan Rubel.

00:04:06.380 --> 00:04:08.800
I work on the analyzer team.

00:04:08.800 --> 00:04:11.430
I care about making
sure that Dart

00:04:11.430 --> 00:04:14.890
is easy and understandable,
that the tooling is fast

00:04:14.890 --> 00:04:19.360
and provides useful
information to the user

00:04:19.360 --> 00:04:20.810
to increase the productivity.

00:04:24.170 --> 00:04:25.510
IVAN POSVA: I'm Ivan Posva.

00:04:25.510 --> 00:04:28.860
I'm the lead for the VM team.

00:04:28.860 --> 00:04:32.060
What I care about is
making sure that the Dart

00:04:32.060 --> 00:04:34.440
VM is applicable on
the tiniest devices

00:04:34.440 --> 00:04:38.190
that you'll see this afternoon
to services running an app

00:04:38.190 --> 00:04:40.590
engine and a massive server.

00:04:40.590 --> 00:04:45.150
So basically, being able to
be elastic between those two

00:04:45.150 --> 00:04:49.382
extremes with the VM is
what I really care about.

00:04:49.382 --> 00:04:50.590
DAN GROVE: And I'm Dan Grove.

00:04:50.590 --> 00:04:53.780
I work on the Dart for
Web team and obviously, I

00:04:53.780 --> 00:04:56.280
care about Dart for the web and
making web developers really

00:04:56.280 --> 00:04:57.562
productive.

00:04:57.562 --> 00:04:59.440
SETH LADD: And my
name is Seth Ladd.

00:04:59.440 --> 00:05:01.010
I'm a product manager on Dart.

00:05:01.010 --> 00:05:02.604
And just because
I'm on the Dart team

00:05:02.604 --> 00:05:04.270
doesn't mean I'm not
going to be sending

00:05:04.270 --> 00:05:06.620
the hard-hitting questions
to our panelists like,

00:05:06.620 --> 00:05:11.330
can Lars microwave a burrito
so hot even he can't eat it?

00:05:11.330 --> 00:05:13.840
I'm going to let that
sink in for a second.

00:05:13.840 --> 00:05:17.324
And Dart-- great language
or greatest language?

00:05:17.324 --> 00:05:19.810
[LAUGHTER]

00:05:19.810 --> 00:05:20.584
KASPER LUND: Yes.

00:05:20.584 --> 00:05:21.750
SETH LADD: Anyway, OK, cool.

00:05:21.750 --> 00:05:23.360
So let's turn it
back to questions.

00:05:23.360 --> 00:05:25.287
Yes, you have a
question for our panel.

00:05:25.287 --> 00:05:25.870
AUDIENCE: Yes.

00:05:25.870 --> 00:05:30.120
If you got "get out
of feature" card,

00:05:30.120 --> 00:05:32.590
what feature would you
like to remove from Dart?

00:05:32.590 --> 00:05:36.960
Just one feature for each
of the members, please.

00:05:36.960 --> 00:05:40.070
[LAUGHTER]

00:05:40.070 --> 00:05:41.020
SETH LADD: Cool, OK.

00:05:43.798 --> 00:05:44.724
[GRUNTS]

00:05:44.724 --> 00:05:45.934
[LAUGHTER]

00:05:45.934 --> 00:05:47.100
Are we still live streaming?

00:05:47.100 --> 00:05:47.683
LARS BAK: Yes.

00:05:50.440 --> 00:05:53.030
So I can take one.

00:05:53.030 --> 00:05:54.150
It's just my personal one.

00:05:58.150 --> 00:06:01.680
We took some features
from JavaScript

00:06:01.680 --> 00:06:03.640
and moved that into Dart.

00:06:03.640 --> 00:06:07.270
So it's easy to move
from JavaScript to Dart.

00:06:07.270 --> 00:06:11.660
One thing I don't like is
the implicit extraction

00:06:11.660 --> 00:06:13.592
of closures.

00:06:13.592 --> 00:06:15.050
I should like to
have that explicit

00:06:15.050 --> 00:06:18.240
so I can see in the code
if you extract a closure.

00:06:18.240 --> 00:06:20.450
Because often, if you forget
to put in parentheses,

00:06:20.450 --> 00:06:23.970
right, you take out a closure.

00:06:23.970 --> 00:06:27.370
I want that to be back.

00:06:27.370 --> 00:06:28.520
SETH LADD: Anyone else?

00:06:28.520 --> 00:06:29.437
KASPER LUND: I can go.

00:06:29.437 --> 00:06:30.936
I think one thing
that would be very

00:06:30.936 --> 00:06:32.560
interesting to try
to remove from Dart

00:06:32.560 --> 00:06:34.700
is all the asynchrony.

00:06:34.700 --> 00:06:37.674
It's a little bit
controversial, but it's

00:06:37.674 --> 00:06:39.340
kind of a thing that
would be fun to see

00:06:39.340 --> 00:06:41.950
how far we can take something
that isn't asynchronous.

00:06:41.950 --> 00:06:44.310
Clearly, there's a need for
asynchronous operations,

00:06:44.310 --> 00:06:46.280
but it would be
fun to take the--

00:06:46.280 --> 00:06:48.150
SETH LADD: What
would you put back?

00:06:48.150 --> 00:06:49.210
It feels like you're
taking something away.

00:06:49.210 --> 00:06:50.501
KASPER LUND: Yeah, synchronous.

00:06:50.501 --> 00:06:51.113
SETH LADD: OK.

00:06:51.113 --> 00:06:54.192
[LAUGHTER]

00:06:54.192 --> 00:06:55.650
LARS BAK: And Kasper
is fully aware

00:06:55.650 --> 00:06:57.474
that that will not
work in the browser.

00:06:57.474 --> 00:06:58.422
KASPER LUND: Yeah.

00:06:58.422 --> 00:07:02.690
[LAUGHTER]

00:07:02.690 --> 00:07:04.290
LARS BAK: Hey, Dan?

00:07:04.290 --> 00:07:06.142
SETH LADD: Sorry, for the what?

00:07:06.142 --> 00:07:06.975
DAN GROVE: Big nums.

00:07:13.188 --> 00:07:18.364
Those who are still working
the web, not really an option.

00:07:18.364 --> 00:07:19.030
SETH LADD: Cool.

00:07:19.030 --> 00:07:20.960
Thank you for the question.

00:07:20.960 --> 00:07:22.840
Let's go to the first
highest-voted question

00:07:22.840 --> 00:07:23.872
here in our moderator.

00:07:23.872 --> 00:07:25.830
And I think we touched
a little bit about this,

00:07:25.830 --> 00:07:29.106
but it'd be nice to get
the answer for the stream.

00:07:29.106 --> 00:07:30.980
With the Dart VM not
going in Chrome anymore,

00:07:30.980 --> 00:07:34.540
what kinds of JavaScript interop
improvements are we planning?

00:07:34.540 --> 00:07:37.840
For example, would we be able
to write functions or Polymer

00:07:37.840 --> 00:07:40.060
elements in Dart,
compile them to JS,

00:07:40.060 --> 00:07:42.590
and distribute them
as JS libraries?

00:07:42.590 --> 00:07:47.310
DAN GROVE: So yeah, very--
lots of JS improvements.

00:07:47.310 --> 00:07:52.065
Yes, yes, and yes
is the short answer.

00:07:54.294 --> 00:07:55.960
And we talked about
this some yesterday.

00:07:55.960 --> 00:07:58.647
Jacob Richman also hit
this in his lightning talk,

00:07:58.647 --> 00:07:59.980
for those of you that were here.

00:07:59.980 --> 00:08:02.430
We're doing a ton of
improvements to JS interop

00:08:02.430 --> 00:08:04.050
to make it feel really natural.

00:08:04.050 --> 00:08:05.570
And I should-- an
example of this

00:08:05.570 --> 00:08:07.100
in Kevin's and my
talk yesterday,

00:08:07.100 --> 00:08:08.734
it's going to actually
feel very good.

00:08:08.734 --> 00:08:10.400
As long as you're
calling into something

00:08:10.400 --> 00:08:13.791
that exposes sort of Dart-ish
interface to the outside world,

00:08:13.791 --> 00:08:15.540
it's going to feel
very natural and you're

00:08:15.540 --> 00:08:16.670
going to be able to
get all the tooling

00:08:16.670 --> 00:08:19.070
support that you're used
to, so code completion,

00:08:19.070 --> 00:08:20.810
all that kind of stuff.

00:08:20.810 --> 00:08:21.810
SETH LADD: Cool, thanks.

00:08:21.810 --> 00:08:24.329
DAN GROVE: And yes, all the
other questions are yes.

00:08:24.329 --> 00:08:26.120
You will be able to
write functions in Dart

00:08:26.120 --> 00:08:28.760
and compile and distribute
them to JS developers.

00:08:28.760 --> 00:08:30.039
SETH LADD: Great.

00:08:30.039 --> 00:08:32.289
Again, if there's any live
questions, please queue up.

00:08:32.289 --> 00:08:34.370
We'll go to the
next question here.

00:08:34.370 --> 00:08:37.380
Is it possible for the Dart VM
to match the JVM's performance

00:08:37.380 --> 00:08:39.314
on numeric computational
heavy benchmark--

00:08:39.314 --> 00:08:39.980
IVAN POSVA: Yes.

00:08:39.980 --> 00:08:40.646
SETH LADD: Yeah.

00:08:40.646 --> 00:08:41.890
OK, good.

00:08:41.890 --> 00:08:43.940
IVAN POSVA: Did
you want to finish?

00:08:43.940 --> 00:08:45.010
SETH LADD: On Box2D.

00:08:45.010 --> 00:08:46.190
So maybe we can
talk a little bit.

00:08:46.190 --> 00:08:47.610
We did something
with Box2D recently

00:08:47.610 --> 00:08:49.443
and what's your perspective
on the question?

00:08:49.443 --> 00:08:52.150
IVAN POSVA: So specifically
on numeric computations,

00:08:52.150 --> 00:08:54.620
we have a couple benchmarks
that are not Box2D.

00:08:54.620 --> 00:08:59.312
Box2D is kind of a special case,
where our internal benchmark

00:08:59.312 --> 00:09:01.645
harness, I don't think we
share those numbers externally

00:09:01.645 --> 00:09:04.580
because of licensing issues.

00:09:04.580 --> 00:09:07.510
But there's some fluid
motion simulation and stuff

00:09:07.510 --> 00:09:11.120
like that, where we
are essentially equal

00:09:11.120 --> 00:09:16.280
or on parity with the Java VM.

00:09:16.280 --> 00:09:18.240
For Box2D, it's a
little bit harder,

00:09:18.240 --> 00:09:21.030
because there are many different
implementations of Box2D.

00:09:21.030 --> 00:09:24.860
And a surgeon on my team-- he's
somewhere in the audience--

00:09:24.860 --> 00:09:27.560
just recently rewrote
the Dart version

00:09:27.560 --> 00:09:30.500
of Box2D based on
the Java version

00:09:30.500 --> 00:09:34.810
and the results are quite
impressive from both Dart

00:09:34.810 --> 00:09:35.550
to JS.

00:09:35.550 --> 00:09:38.910
And the VM significantly
improved on that.

00:09:38.910 --> 00:09:40.700
And I think the
numbers that he quoted

00:09:40.700 --> 00:09:48.260
me were around four milliseconds
per frame on the Java VM

00:09:48.260 --> 00:09:51.640
and about five and a bit
milliseconds per frame

00:09:51.640 --> 00:09:53.890
on the Dart VM.

00:09:53.890 --> 00:09:56.550
I hope we can basically
get more stuff going there.

00:09:56.550 --> 00:10:02.370
The Dart VM is much younger
than HotSpot or any of the JVMs

00:10:02.370 --> 00:10:03.180
that are out there.

00:10:03.180 --> 00:10:04.960
So we hope to catch up.

00:10:04.960 --> 00:10:08.260
But the tight feedback
that we get at runtime

00:10:08.260 --> 00:10:10.860
makes up for most of the or
all of the static feedback

00:10:10.860 --> 00:10:13.830
that you can get.

00:10:13.830 --> 00:10:14.330
Yes?

00:10:14.330 --> 00:10:16.110
LARS BAK: I have a
[INAUDIBLE] comment.

00:10:16.110 --> 00:10:19.989
So pretty sure that JVM
is doing a good job,

00:10:19.989 --> 00:10:22.000
because in Java,
you can do inlining

00:10:22.000 --> 00:10:24.490
or you basically
have basic types.

00:10:24.490 --> 00:10:26.320
In the Dart VM, it's
more complicated

00:10:26.320 --> 00:10:28.404
because you have to
offer-- or sometimes,

00:10:28.404 --> 00:10:29.820
if you're not
inlining everything,

00:10:29.820 --> 00:10:34.370
you have to sort of materialize
the results in the heap.

00:10:34.370 --> 00:10:36.030
So it varies with
benchmarks how fast

00:10:36.030 --> 00:10:38.600
we can get compared to the JVM.

00:10:38.600 --> 00:10:42.974
Now, the question is, is
Box2D a real problem for you

00:10:42.974 --> 00:10:43.640
Dart developers?

00:10:48.150 --> 00:10:50.415
Because when it
comes to benchmarks,

00:10:50.415 --> 00:10:54.130
we can always improve it by
just throwing resources at it.

00:10:54.130 --> 00:10:55.955
But does it matter?

00:10:55.955 --> 00:10:58.330
In the presentations I've seen
in the last one and a half

00:10:58.330 --> 00:11:01.860
days, I have not seen
that to be an issue.

00:11:01.860 --> 00:11:06.050
I'm more concerned about getting
performance of factored code

00:11:06.050 --> 00:11:10.270
for these kinds of
applications you are writing.

00:11:10.270 --> 00:11:13.127
So we can get as
fast as you want,

00:11:13.127 --> 00:11:14.960
but the question is
whether we want to spend

00:11:14.960 --> 00:11:16.894
the resources doing so.

00:11:16.894 --> 00:11:18.810
IVAN POSVA: But this
question was specifically

00:11:18.810 --> 00:11:21.286
about numeric
computation, right?

00:11:21.286 --> 00:11:21.910
LARS BAK: Yeah.

00:11:21.910 --> 00:11:24.326
IVAN POSVA: On factor code,
if it's a lot of virtual calls

00:11:24.326 --> 00:11:28.900
and so on, we are actually
at the speed of HotSpot

00:11:28.900 --> 00:11:30.420
and sometimes even better.

00:11:30.420 --> 00:11:32.130
LARS BAK: Yeah.

00:11:32.130 --> 00:11:33.270
SETH LADD: Ivan, I think
there's a question about this

00:11:33.270 --> 00:11:35.420
a little bit later, but it
segues in perfectly from here.

00:11:35.420 --> 00:11:37.878
It's something that we talked
to a lot of developers about.

00:11:37.878 --> 00:11:40.060
Maybe we can sort of get
on record and discuss this.

00:11:40.060 --> 00:11:41.820
I talked to a lot of
developers that say,

00:11:41.820 --> 00:11:42.820
Dart's not amply-typed.

00:11:42.820 --> 00:11:45.160
You can use var a lot,
so it has to be slower

00:11:45.160 --> 00:11:46.649
than statically-typed languages.

00:11:46.649 --> 00:11:48.940
So can you explain a little
bit from the VM engineering

00:11:48.940 --> 00:11:51.100
perspective or the language
design perspective,

00:11:51.100 --> 00:11:53.650
where the intersection is
for type annotations, how

00:11:53.650 --> 00:11:55.540
we use them, how
we don't, and how--

00:11:55.540 --> 00:11:59.700
what are the impacts of that for
performance, if there are any?

00:11:59.700 --> 00:12:00.300
That's a lot.

00:12:00.300 --> 00:12:01.841
IVAN POSVA: Is that
a question of me?

00:12:01.841 --> 00:12:03.240
SETH LADD: Of the panel.

00:12:03.240 --> 00:12:06.800
IVAN POSVA: Well, for
the VM specifically,

00:12:06.800 --> 00:12:10.362
whether you type your variables
or not doesn't matter at all.

00:12:10.362 --> 00:12:11.820
So basically, the
first thing we do

00:12:11.820 --> 00:12:14.090
when we parse it,
unless you run in

00:12:14.090 --> 00:12:16.760
checked mode, we throw
them away, right?

00:12:16.760 --> 00:12:19.600
We're not concerned about them
because based on the language

00:12:19.600 --> 00:12:22.970
spec, we cannot use
them at all, right?

00:12:22.970 --> 00:12:27.930
We have to think dynamically
whatever the selector was.

00:12:27.930 --> 00:12:31.537
So what we do collect
is as you keep running,

00:12:31.537 --> 00:12:33.620
we collect what are the
types that you're actually

00:12:33.620 --> 00:12:37.660
seeing here dynamically and make
optimizations based on that.

00:12:37.660 --> 00:12:43.470
And that basically gives us
the exact subtypes potentially

00:12:43.470 --> 00:12:46.570
that are being used
here to dispatch,

00:12:46.570 --> 00:12:49.120
versus if you do
static typing, it

00:12:49.120 --> 00:12:53.820
would be basically, OK, you're
calling this function on one

00:12:53.820 --> 00:12:56.765
of the subclasses that
is being passed here

00:12:56.765 --> 00:12:57.995
or could be passed here.

00:12:57.995 --> 00:13:01.400
And for us, since we collect
all of the information,

00:13:01.400 --> 00:13:04.060
we know exactly in
this case, it's only

00:13:04.060 --> 00:13:07.760
going to be this subclass
and we optimize for that.

00:13:07.760 --> 00:13:12.034
And we have to back out if
we made a misprediction.

00:13:12.034 --> 00:13:13.450
LARS BAK: An extra
comment here is

00:13:13.450 --> 00:13:16.130
that the types of
annotation you see

00:13:16.130 --> 00:13:17.874
in Dart programs,
the interface types,

00:13:17.874 --> 00:13:20.290
they're not implementation
types so they don't work really

00:13:20.290 --> 00:13:22.449
well for the VM, anyways.

00:13:22.449 --> 00:13:24.490
You need the actual
implementation types in order

00:13:24.490 --> 00:13:27.897
to do the proper inlining.

00:13:27.897 --> 00:13:29.230
IVAN POSVA: Yeah, it works well.

00:13:29.230 --> 00:13:30.670
It works well.

00:13:30.670 --> 00:13:32.120
LARS BAK: And I
think even if you

00:13:32.120 --> 00:13:37.097
look at what machines
like the JVMs,

00:13:37.097 --> 00:13:39.180
if you go back in time
when they got the big boost

00:13:39.180 --> 00:13:42.400
in performance, it was based
on dynamically analyzing

00:13:42.400 --> 00:13:44.660
what was going on at
runtime, not by doing

00:13:44.660 --> 00:13:46.310
ahead-of-time
compilation or basing it

00:13:46.310 --> 00:13:48.360
on the types of the program.

00:13:48.360 --> 00:13:51.000
So we are just
taking the Dart VM

00:13:51.000 --> 00:13:53.620
to the next level, where
everything is dynamic.

00:13:53.620 --> 00:13:56.580
But we can certainly get
the same kind of benefits.

00:13:56.580 --> 00:13:58.110
SETH LADD: Yep.

00:13:58.110 --> 00:13:59.780
Great, thank you.

00:13:59.780 --> 00:14:00.790
Question?

00:14:00.790 --> 00:14:02.169
AUDIENCE: Hi.

00:14:02.169 --> 00:14:03.710
I really love what
the Dart team does

00:14:03.710 --> 00:14:06.530
for making the tooling perfect.

00:14:06.530 --> 00:14:09.600
And from my point of
view, there is one kind

00:14:09.600 --> 00:14:14.520
of little step which left which
would be super cool to have,

00:14:14.520 --> 00:14:18.550
which is-- so is there any plans
on implementing hot swapping

00:14:18.550 --> 00:14:21.670
of the code in the VM?

00:14:21.670 --> 00:14:23.874
I understand this is a
super complex problem.

00:14:23.874 --> 00:14:25.540
KASPER LUND: So we
are certainly looking

00:14:25.540 --> 00:14:28.330
into interactive or
live programming, where

00:14:28.330 --> 00:14:30.256
you can change the
code as it's executing.

00:14:30.256 --> 00:14:32.380
It's something that actually
would work pretty well

00:14:32.380 --> 00:14:35.240
in the VM, too, I think, with
the very dynamic approach

00:14:35.240 --> 00:14:36.690
the VM takes to things.

00:14:36.690 --> 00:14:39.830
It's also something we think
has a real shot at making

00:14:39.830 --> 00:14:42.010
a big difference in a mobile
setting, where the tool

00:14:42.010 --> 00:14:44.330
chain's a little bit heavier
and where the ability

00:14:44.330 --> 00:14:47.160
to update code while it's
running on your smartphone

00:14:47.160 --> 00:14:49.630
without having to recompile
it would be pretty powerful.

00:14:49.630 --> 00:14:52.420
So I think it's in
the cards for us

00:14:52.420 --> 00:14:54.240
to explore that in
the coming months

00:14:54.240 --> 00:14:56.309
and have a good
solution for that.

00:14:56.309 --> 00:14:57.350
AUDIENCE: Oh, can't wait.

00:14:57.350 --> 00:14:59.280
Thank you.

00:14:59.280 --> 00:15:01.260
SETH LADD: Thank you
for the question.

00:15:01.260 --> 00:15:02.570
Let's go back to the moderator.

00:15:02.570 --> 00:15:04.736
And I think this touches
on some of the conversation

00:15:04.736 --> 00:15:07.709
I've had online or in person
here about Dart Editor.

00:15:07.709 --> 00:15:10.125
So this question's phrased as,
"Are there any improvements

00:15:10.125 --> 00:15:11.999
to the Dart Editor
coming with regard

00:15:11.999 --> 00:15:13.790
to working with other
JavaScript libraries,

00:15:13.790 --> 00:15:15.630
like code completion
with JavaScript?"

00:15:15.630 --> 00:15:16.560
But I think it's
also a good time

00:15:16.560 --> 00:15:18.518
for us to address the
various different tooling

00:15:18.518 --> 00:15:22.400
options we have and what is
the strategy for Dart tooling

00:15:22.400 --> 00:15:25.695
and what editors do we recommend
and will continue to support.

00:15:28.594 --> 00:15:30.510
DAN RUBEL: We're moving
away from Dart Editor.

00:15:30.510 --> 00:15:35.070
Dart Editor was designed
initially to serve two masters

00:15:35.070 --> 00:15:36.350
and that's a problem.

00:15:36.350 --> 00:15:39.110
One, you have an
early adopter who's

00:15:39.110 --> 00:15:41.960
learning Dart, who's literally
just getting started.

00:15:41.960 --> 00:15:44.590
And you want to provide
a really easy on-ramp.

00:15:44.590 --> 00:15:46.960
The other audience you
want to try to serve

00:15:46.960 --> 00:15:49.900
are the power developers
who are building big apps

00:15:49.900 --> 00:15:53.290
and want all of the power
at their fingertips.

00:15:53.290 --> 00:15:57.250
It is really difficult to serve
those two needs simultaneously

00:15:57.250 --> 00:15:58.550
with the same product.

00:15:58.550 --> 00:16:01.470
It was a conscious decision
to separate those two.

00:16:01.470 --> 00:16:05.150
Dart Pad, as you heard
earlier, is focused entirely

00:16:05.150 --> 00:16:09.470
on lowering the barrier
completely to almost a zero

00:16:09.470 --> 00:16:10.860
to get people started.

00:16:10.860 --> 00:16:12.010
You can try out things.

00:16:12.010 --> 00:16:14.700
It's low friction,
low resistance.

00:16:14.700 --> 00:16:15.620
You can share it.

00:16:15.620 --> 00:16:17.320
You can put things
in Stack Overflow,

00:16:17.320 --> 00:16:18.910
put references, et cetera.

00:16:18.910 --> 00:16:21.210
That serves one purpose.

00:16:21.210 --> 00:16:26.370
The other goal is to provide
rich experience in tools

00:16:26.370 --> 00:16:29.790
that developers are
already familiar with,

00:16:29.790 --> 00:16:32.730
Webstorm being the primary one.

00:16:32.730 --> 00:16:34.340
But that's not alone.

00:16:34.340 --> 00:16:36.600
The Webstorm is
our primary focus,

00:16:36.600 --> 00:16:38.750
but secondarily
would be continue

00:16:38.750 --> 00:16:42.550
to take that same infrastructure
that we have for Dart Editor

00:16:42.550 --> 00:16:43.990
and put it into Eclipse.

00:16:43.990 --> 00:16:47.090
So you have Eclipse,
Sublime-- which there already

00:16:47.090 --> 00:16:50.340
exists a plug-in
for that-- vi, Emax,

00:16:50.340 --> 00:16:52.440
our interest-- we don't
have anything there yet

00:16:52.440 --> 00:16:54.100
but they're of interest.

00:16:54.100 --> 00:16:58.950
So the key is to provide the
analysis, the infrastructure

00:16:58.950 --> 00:17:00.809
where the developers are.

00:17:00.809 --> 00:17:03.350
DAN GROVE: Yeah, and just to go
back to the original question

00:17:03.350 --> 00:17:06.391
here about JavaScript
libraries, one of the things

00:17:06.391 --> 00:17:08.849
that we showed yesterday is
that we're working on some stub

00:17:08.849 --> 00:17:11.420
generation, given type
script definition files,

00:17:11.420 --> 00:17:13.190
and that will make
it much easier.

00:17:13.190 --> 00:17:15.730
That'll fit right
into all the analysis

00:17:15.730 --> 00:17:18.400
services that are out there.

00:17:18.400 --> 00:17:20.260
SETH LADD: Great, thank you.

00:17:20.260 --> 00:17:21.190
Don, question?

00:17:21.190 --> 00:17:22.490
AUDIENCE: All right.

00:17:22.490 --> 00:17:24.825
So one of the things
we haven't really

00:17:24.825 --> 00:17:26.450
talked about too much
during the summit

00:17:26.450 --> 00:17:31.120
is what the roadmap
is for Polymer Dart.

00:17:31.120 --> 00:17:34.150
Obviously, Polymer
JS has the 0.8

00:17:34.150 --> 00:17:37.120
and there are a number of
performance improvements.

00:17:37.120 --> 00:17:39.260
And additionally,
at this time, you

00:17:39.260 --> 00:17:42.480
can actually share your
elements with other people

00:17:42.480 --> 00:17:46.050
unless they are using
the Dart ecosystem.

00:17:46.050 --> 00:17:48.610
So what's the game plan here?

00:17:48.610 --> 00:17:50.670
DAN GROVE: Well,
the game plan has

00:17:50.670 --> 00:17:51.940
a couple of different pieces.

00:17:51.940 --> 00:17:54.170
One is we're waiting
for the Polymer team

00:17:54.170 --> 00:17:56.774
to reach a point of
stability with Polymer, which

00:17:56.774 --> 00:17:58.690
sounds like it's coming
pretty soon, according

00:17:58.690 --> 00:18:00.980
to things I've heard recently.

00:18:00.980 --> 00:18:04.350
So we're not going to do
this kind of following around

00:18:04.350 --> 00:18:06.160
Polymer change by change.

00:18:06.160 --> 00:18:08.410
But as Polymer reaches
1.0, we are going

00:18:08.410 --> 00:18:10.400
to provide Polymer Dart 1.0.

00:18:10.400 --> 00:18:12.980
Second angle on this is
what we talked about some

00:18:12.980 --> 00:18:15.300
with Dev compiler and
JS interop yesterday,

00:18:15.300 --> 00:18:17.450
which is the ability
to take Dart libraries

00:18:17.450 --> 00:18:20.230
and ship them to JavaScript
developers or Dart

00:18:20.230 --> 00:18:21.360
developers for that matter.

00:18:21.360 --> 00:18:24.780
We don't really want to care who
the consumer of components is.

00:18:24.780 --> 00:18:26.080
So that's coming.

00:18:26.080 --> 00:18:29.780
So with the combo of Polymer
reaching stability and Dev

00:18:29.780 --> 00:18:32.610
compiler, I think we'll
actually be able to do the thing

00:18:32.610 --> 00:18:36.340
that you want to do, which is
shipping Polymer components

00:18:36.340 --> 00:18:38.314
and not caring who
your consumers are.

00:18:38.314 --> 00:18:38.980
SETH LADD: Cool.

00:18:38.980 --> 00:18:40.330
AUDIENCE: Thank you.

00:18:40.330 --> 00:18:42.550
SETH LADD: Thanks
for the question.

00:18:42.550 --> 00:18:43.550
So I like this question.

00:18:43.550 --> 00:18:46.110
So if Fletch and Sky
succeed as experiments,

00:18:46.110 --> 00:18:47.190
what are the next plan?

00:18:47.190 --> 00:18:51.062
But what of the outcome
counts as succeeding?

00:18:51.062 --> 00:18:52.520
KASPER LUND: Well,
it's hard for us

00:18:52.520 --> 00:18:55.722
to speak to the plans
for the Sky project.

00:18:55.722 --> 00:18:57.680
You should all come to
the presentation at 5:00

00:18:57.680 --> 00:19:00.430
and see what that is and
ask questions afterwards.

00:19:00.430 --> 00:19:04.270
But in terms of Fletch, there's
a very non-experimental part

00:19:04.270 --> 00:19:07.470
of Fletch, which is this
runtime system for iOS.

00:19:07.470 --> 00:19:09.100
And we showed in the
keynote yesterday

00:19:09.100 --> 00:19:11.930
that we're going to ship that
this year as a product you

00:19:11.930 --> 00:19:16.194
can use to ship mobile
apps for iOS on top of.

00:19:16.194 --> 00:19:17.860
There are experimental
things in Fletch,

00:19:17.860 --> 00:19:20.490
as well, for instance,
the isolate work

00:19:20.490 --> 00:19:21.490
that we've started.

00:19:21.490 --> 00:19:24.050
And clearly, if we find
that that is so compelling

00:19:24.050 --> 00:19:26.510
that people actually want
to and need to use it,

00:19:26.510 --> 00:19:28.750
we will find a way of
making that non-experimental

00:19:28.750 --> 00:19:30.970
and putting it into
our product offerings.

00:19:30.970 --> 00:19:34.967
So a success for
us would be people

00:19:34.967 --> 00:19:37.050
being able to actually use
this to build something

00:19:37.050 --> 00:19:40.580
truly fantastic on top of making
isolates a lot easier to use.

00:19:40.580 --> 00:19:42.024
So I think the answer's--

00:19:42.024 --> 00:19:43.940
SETH LADD: The developers
are more productive,

00:19:43.940 --> 00:19:46.315
developers are happy with
this, and developers are taking

00:19:46.315 --> 00:19:47.815
it to build really cool things.

00:19:47.815 --> 00:19:48.690
That's success to me.

00:19:48.690 --> 00:19:50.490
KASPER LUND: Yeah.

00:19:50.490 --> 00:19:51.661
SETH LADD: Cool, OK.

00:19:51.661 --> 00:19:52.660
This is a good one here.

00:19:52.660 --> 00:19:54.480
So what kind of
performance differences

00:19:54.480 --> 00:19:57.850
are expected between Fletch
Interpreter, JVM's JIT,

00:19:57.850 --> 00:20:01.122
Dart to JS in the
JavaScript VM--

00:20:01.122 --> 00:20:02.830
how will Fletch perform
relative to using

00:20:02.830 --> 00:20:04.130
iOS's built-in JavaScript JIT?

00:20:04.130 --> 00:20:05.754
So there's a lot in
there, but maybe we

00:20:05.754 --> 00:20:08.170
can talk about the different
fundamental ways we approach

00:20:08.170 --> 00:20:09.820
the compilation running.

00:20:09.820 --> 00:20:12.716
And what are the trade-offs for
these different environments?

00:20:12.716 --> 00:20:14.590
KASPER LUND: That's
probably for me, as well.

00:20:14.590 --> 00:20:18.520
So the Fletch system is a very
simple system designed to run

00:20:18.520 --> 00:20:20.880
really well in an iOS context,
where you cannot do any

00:20:20.880 --> 00:20:22.110
just-in-time compilation.

00:20:22.110 --> 00:20:24.691
So we do byte code
interpretation there,

00:20:24.691 --> 00:20:26.190
and that's sort of
inherently slower

00:20:26.190 --> 00:20:28.079
than doing just-in-time
compilation.

00:20:28.079 --> 00:20:30.370
We're focusing on actually
delivering something you can

00:20:30.370 --> 00:20:31.980
use to build real apps there.

00:20:31.980 --> 00:20:34.890
And later today, I'll show
something running on an iPad

00:20:34.890 --> 00:20:37.500
so you can see for yourself
that it's fast enough, at least

00:20:37.500 --> 00:20:38.292
for certain things.

00:20:38.292 --> 00:20:39.916
But it's going to be
really hard for us

00:20:39.916 --> 00:20:42.120
to compare the performance
between all these things.

00:20:42.120 --> 00:20:44.410
It really depends on
what you're running.

00:20:44.410 --> 00:20:47.140
For certain micro-benchmarks,
using an interpreter

00:20:47.140 --> 00:20:48.765
is a lot slower than
having a real JIT.

00:20:48.765 --> 00:20:50.223
But for other
things, it's probably

00:20:50.223 --> 00:20:51.830
fine for writing
real applications.

00:20:51.830 --> 00:20:56.560
So it's a really difficult
question to answer.

00:20:56.560 --> 00:21:00.040
The nice thing is that we all
dream about making performance

00:21:00.040 --> 00:21:02.300
faster and that's really
what we like to do.

00:21:02.300 --> 00:21:03.990
So we have a strong
background in that.

00:21:03.990 --> 00:21:06.580
So we expect to be able
to improve Fletch a lot

00:21:06.580 --> 00:21:09.360
in the performance
side, as well.

00:21:09.360 --> 00:21:11.100
LARS BAK: So one
comment about iOS

00:21:11.100 --> 00:21:13.190
is that you're
allowed to generate

00:21:13.190 --> 00:21:16.580
code inside an iOS app.

00:21:16.580 --> 00:21:19.100
So the question
about how will Fletch

00:21:19.100 --> 00:21:22.950
perform compared to the
built-in JavaScript JIT?

00:21:22.950 --> 00:21:25.070
It'll be slower, because
we cannot generate code

00:21:25.070 --> 00:21:27.240
on the fly.

00:21:27.240 --> 00:21:28.500
That's just how it is.

00:21:28.500 --> 00:21:30.470
We didn't make the
rules for that system.

00:21:33.530 --> 00:21:38.370
However, we also know how
to make interpretation fast.

00:21:38.370 --> 00:21:42.760
And you can actually do
some pre-compilation.

00:21:42.760 --> 00:21:45.790
You can do profiling of
the application and bundle

00:21:45.790 --> 00:21:49.660
pre-compiled code with the app,
if that turns out to be useful.

00:21:49.660 --> 00:21:52.540
And we'll soon be looking at
these options moving forward.

00:21:52.540 --> 00:21:54.290
SETH LADD: Ivan, can
you talk a little bit

00:21:54.290 --> 00:21:56.240
about what the VM's
general strategy is?

00:21:56.240 --> 00:21:57.390
Is there an interpreter
in the beginning

00:21:57.390 --> 00:21:58.630
before it does machine code?

00:21:58.630 --> 00:22:00.960
What happens when it starts
to look at that code?

00:22:00.960 --> 00:22:04.600
IVAN POSVA: Well, it
doesn't run in iOS.

00:22:04.600 --> 00:22:08.080
But in general,
what we do is we try

00:22:08.080 --> 00:22:09.870
to make the simple
thing happen, which

00:22:09.870 --> 00:22:14.600
is we use the same compiler in
multiple modes of optimization.

00:22:14.600 --> 00:22:17.440
One is just unoptimized code.

00:22:17.440 --> 00:22:21.120
We basically read and scan
the source code in parts

00:22:21.120 --> 00:22:24.190
and immediately
generate code out of it.

00:22:24.190 --> 00:22:28.500
That code is instrumented to
make all these optimizations

00:22:28.500 --> 00:22:30.720
that I talked about possible.

00:22:30.720 --> 00:22:35.540
So it collects the type
feedback for all the calls.

00:22:35.540 --> 00:22:37.460
Depending on what
calls there are,

00:22:37.460 --> 00:22:40.730
we actually collect feedback
on the types of parameters

00:22:40.730 --> 00:22:44.680
so that we know, this is
not just a plus on a double.

00:22:44.680 --> 00:22:48.820
It's also a plus on a double
with integer parameters

00:22:48.820 --> 00:22:49.540
all the time.

00:22:49.540 --> 00:22:54.500
So we can basically do
the upgrade to a double

00:22:54.500 --> 00:22:56.210
on the fly there, as well.

00:22:56.210 --> 00:23:00.170
All these kind of things are
collected in unoptimized code,

00:23:00.170 --> 00:23:00.970
what we call it.

00:23:00.970 --> 00:23:04.430
And then basically,
at some point,

00:23:04.430 --> 00:23:08.650
the VM decides this code is hard
enough and will optimize it.

00:23:08.650 --> 00:23:10.820
And as it optimizes
further and further,

00:23:10.820 --> 00:23:13.100
it will start
doing more inlining

00:23:13.100 --> 00:23:15.200
and basically collects
all these-- you've

00:23:15.200 --> 00:23:20.885
taken this branch all the time,
this cell's case is an unused,

00:23:20.885 --> 00:23:24.285
so we'll basically just
not compile it all.

00:23:24.285 --> 00:23:25.940
SETH LADD: Cool.

00:23:25.940 --> 00:23:29.000
I think this is a question
here for Dart for the web.

00:23:29.000 --> 00:23:31.330
With a shift away
from a VM in Chrome

00:23:31.330 --> 00:23:34.900
to compiling to JavaScript,
have the metrics for success

00:23:34.900 --> 00:23:37.560
or the metrics for quality or
the metrics for performance

00:23:37.560 --> 00:23:38.600
have changed?

00:23:38.600 --> 00:23:40.820
And another way
to ask this would

00:23:40.820 --> 00:23:42.940
be, we work with a lot
of internal customers.

00:23:42.940 --> 00:23:46.320
What are the things that are
important to them as a proxy

00:23:46.320 --> 00:23:48.410
or important to every developer?

00:23:48.410 --> 00:23:51.000
DAN GROVE: Yeah, I
think that's right.

00:23:51.000 --> 00:23:54.710
I didn't hear a lot of
people worry about Delta Blue

00:23:54.710 --> 00:23:57.834
performance yesterday,
but I do hear

00:23:57.834 --> 00:24:00.000
a lot of people talking
about things like code size.

00:24:00.000 --> 00:24:03.580
So when I look at the
metrics for success,

00:24:03.580 --> 00:24:05.080
I really think that
they're becoming

00:24:05.080 --> 00:24:06.846
more JavaScript-centric
in a lot of ways.

00:24:06.846 --> 00:24:08.220
So we're talking
about code size.

00:24:08.220 --> 00:24:09.540
It's really critical.

00:24:09.540 --> 00:24:11.166
We're talking about
readability of code

00:24:11.166 --> 00:24:12.873
and that's another
really critical thing.

00:24:12.873 --> 00:24:14.550
We're talking about
reusability of code.

00:24:14.550 --> 00:24:16.090
There are a bunch
of metrics there.

00:24:16.090 --> 00:24:18.480
And in addition, the benchmarks
that we're going to be running

00:24:18.480 --> 00:24:19.440
are going to be changing.

00:24:19.440 --> 00:24:21.690
And I think you're going to
be seeing the Dart for web

00:24:21.690 --> 00:24:23.810
benchmarks moving to be
much more web-centric

00:24:23.810 --> 00:24:25.490
and looking more like
components that we

00:24:25.490 --> 00:24:28.115
want to be able to operate with
a certain level of performance.

00:24:30.054 --> 00:24:31.970
SETH LADD: And this is
a related question here

00:24:31.970 --> 00:24:32.750
about Angular 2.0.

00:24:32.750 --> 00:24:35.130
If I parse this correctly,
I think we're asking,

00:24:35.130 --> 00:24:38.770
from Angular.I/O, the website
and the way Angular's being

00:24:38.770 --> 00:24:41.740
written, talk to me a little
bit about where the relationship

00:24:41.740 --> 00:24:43.280
between typescript
and Dart here.

00:24:43.280 --> 00:24:45.684
DAN GROVE: Yeah, so this
is an interesting question.

00:24:45.684 --> 00:24:47.850
If you visit Angular.I/O,
it's actually really nice.

00:24:47.850 --> 00:24:50.520
You'll see that Dart and
JavaScript are basically

00:24:50.520 --> 00:24:52.530
presented side by
side for users.

00:24:52.530 --> 00:24:55.790
The fact that Angular is being
written in typescript itself

00:24:55.790 --> 00:24:57.420
I think is not
really that relevant.

00:24:57.420 --> 00:24:59.211
What's relevant is what
kinds of interfaces

00:24:59.211 --> 00:25:01.200
they provide to Dart developers.

00:25:01.200 --> 00:25:04.870
And we have a number of internal
users at Google that are really

00:25:04.870 --> 00:25:07.680
pushing on the Angular team
to ensure that Angular Dart

00:25:07.680 --> 00:25:12.187
or Angular 2.0 Dart is just as
nice to use Angular 2.0 .JS.

00:25:12.187 --> 00:25:14.270
So I think that this is
going to be a great story.

00:25:14.270 --> 00:25:15.640
Developers who are
using Angular will

00:25:15.640 --> 00:25:17.080
be able to choose the
language they want.

00:25:17.080 --> 00:25:18.070
To some extent,
they're going to be

00:25:18.070 --> 00:25:19.290
able to mix and match things.

00:25:19.290 --> 00:25:20.831
So they'll be able
to use Angular 2.0

00:25:20.831 --> 00:25:23.740
components in an Angular
2.0 Dart app and vice versa.

00:25:23.740 --> 00:25:25.811
So I actually like
this story a lot here.

00:25:25.811 --> 00:25:28.060
We're not trying to dictate
to people what they should

00:25:28.060 --> 00:25:29.960
be using, but we're
about offering choices

00:25:29.960 --> 00:25:33.190
while still using
the same framework.

00:25:33.190 --> 00:25:34.360
SETH LADD: Little things.

00:25:34.360 --> 00:25:36.600
And again, if you want a
question for the panel,

00:25:36.600 --> 00:25:38.580
please come up to
the microphone.

00:25:38.580 --> 00:25:39.710
So I know Kenneth.

00:25:39.710 --> 00:25:43.510
I think what he's really
asking here is, ES6 I hear

00:25:43.510 --> 00:25:45.950
has a lot of things in it.

00:25:45.950 --> 00:25:47.700
Does it have all the
things that Dart has?

00:25:47.700 --> 00:25:49.300
And I think this is
actually really important,

00:25:49.300 --> 00:25:51.549
because I do talk to a lot
of developers who are like,

00:25:51.549 --> 00:25:53.830
ES6 is getting classes, so Dart?

00:25:53.830 --> 00:25:55.330
But when I look at
under the covers,

00:25:55.330 --> 00:25:57.871
there's a ton going on in Dart
and a lot more that I actually

00:25:57.871 --> 00:25:59.000
need and want.

00:25:59.000 --> 00:26:01.090
So this would be a good
time to say, what are some

00:26:01.090 --> 00:26:04.910
of the things that Dart brings
that ES6 isn't even touching?

00:26:04.910 --> 00:26:07.460
Or how do I evaluate the two?

00:26:07.460 --> 00:26:08.484
Lars?

00:26:08.484 --> 00:26:10.900
LARS BAK: This will, of course,
be a little bit of a color

00:26:10.900 --> 00:26:13.170
to answer.

00:26:13.170 --> 00:26:17.720
But I like to clear semantics
and I think Dart has that.

00:26:17.720 --> 00:26:20.064
There's no implicit
conversion of values,

00:26:20.064 --> 00:26:21.230
like there is in JavaScript.

00:26:21.230 --> 00:26:24.350
And ES6 is still JavaScript.

00:26:24.350 --> 00:26:26.400
Nothing has changed.

00:26:26.400 --> 00:26:28.300
Libraries can still
be manipulated

00:26:28.300 --> 00:26:32.180
on the fly and wreck
composition when

00:26:32.180 --> 00:26:33.880
you build up an application.

00:26:33.880 --> 00:26:38.680
So I still think that some
of the initial goals of Dart

00:26:38.680 --> 00:26:40.700
are still valid.

00:26:40.700 --> 00:26:49.580
And I don't want to make this
sort of into a religious war,

00:26:49.580 --> 00:26:52.930
but I still believe that we
have a good set of batteries

00:26:52.930 --> 00:26:57.820
included in Dart, which
is adding classes will not

00:26:57.820 --> 00:27:00.070
solve all problems in my mind.

00:27:00.070 --> 00:27:03.550
So I think Dart still
has a lot to offer.

00:27:03.550 --> 00:27:04.550
And we can ask you guys.

00:27:07.420 --> 00:27:08.470
What do you think?

00:27:08.470 --> 00:27:12.384
Have you tried ECMAScript 6?

00:27:12.384 --> 00:27:13.050
KASPER LUND: No?

00:27:13.050 --> 00:27:15.054
LARS BAK: Any of you?

00:27:15.054 --> 00:27:15.970
KASPER LUND: Wow.

00:27:15.970 --> 00:27:16.900
LARS BAK: Well--

00:27:16.900 --> 00:27:17.150
KASPER LUND: Two guys.

00:27:17.150 --> 00:27:18.441
LARS BAK: Oh, there's two guys.

00:27:18.441 --> 00:27:20.200
And what do you think?

00:27:26.390 --> 00:27:28.030
AUDIENCE: Dart is
more time-safe,

00:27:28.030 --> 00:27:32.538
so it gives you all the niceties
of using the tooling around it.

00:27:32.538 --> 00:27:37.498
But ECMAScript or ES6
is still really flexible

00:27:37.498 --> 00:27:39.482
and it's an improvement
on JavaScript.

00:27:39.482 --> 00:27:41.735
But for making a
large application,

00:27:41.735 --> 00:27:44.100
I still prefer Dart.

00:27:44.100 --> 00:27:45.024
LARS BAK: Yeah.

00:27:45.024 --> 00:27:45.690
SETH LADD: Cool.

00:27:45.690 --> 00:27:47.250
LARS BAK: I agree.

00:27:47.250 --> 00:27:49.699
[LAUGHTER]

00:27:49.699 --> 00:27:50.740
DAN RUBEL: OK, moving on.

00:27:50.740 --> 00:27:52.615
SETH LADD: Can you sum
that up for the people

00:27:52.615 --> 00:27:54.410
who didn't hear it?

00:27:54.410 --> 00:27:55.746
DAN RUBEL: Still prefers Dart.

00:27:55.746 --> 00:27:57.370
LARS BAK: Yes, the
audience do prefer--

00:27:57.370 --> 00:27:59.050
DAN RUBEL: A+++,
would use Dart again.

00:27:59.050 --> 00:28:03.250
LARS BAK: I think
the static types

00:28:03.250 --> 00:28:07.600
we have in Dart makes
the programs readable.

00:28:07.600 --> 00:28:11.350
It makes it easier
to maintain code.

00:28:11.350 --> 00:28:15.570
A lot of program languages
are easy to write

00:28:15.570 --> 00:28:17.970
the code in the first time.

00:28:17.970 --> 00:28:20.880
But when you have to go back
to the same piece of code

00:28:20.880 --> 00:28:22.640
two months later
or a year later,

00:28:22.640 --> 00:28:25.040
you want to be able to
understand what's going on.

00:28:25.040 --> 00:28:28.710
And I think in that scenario,
Dart really has an advantage.

00:28:31.415 --> 00:28:32.680
KASPER LUND: Well said.

00:28:32.680 --> 00:28:33.734
SETH LADD: OK.

00:28:33.734 --> 00:28:35.900
We answered a bunch of the
questions, so I moved on.

00:28:35.900 --> 00:28:36.980
And we're almost
out of time here.

00:28:36.980 --> 00:28:37.810
Oh, we have a live question.

00:28:37.810 --> 00:28:38.309
Great.

00:28:38.309 --> 00:28:40.136
Hey.

00:28:40.136 --> 00:28:42.510
AUDIENCE: I know we talk a
lot about the interoperability

00:28:42.510 --> 00:28:44.230
with JavaScript on
the client side,

00:28:44.230 --> 00:28:47.860
but I'm wondering about bridging
or other interoperability

00:28:47.860 --> 00:28:49.020
on the server side.

00:28:49.020 --> 00:28:51.710
I know that for the
work that we do,

00:28:51.710 --> 00:28:55.340
we have a lot of required
libraries and stuff that are

00:28:55.340 --> 00:29:00.410
built in C# or Java or something
else that we have no choice.

00:29:00.410 --> 00:29:02.420
I'm looking for ways
to try to bring that

00:29:02.420 --> 00:29:05.320
in with a Dart server.

00:29:05.320 --> 00:29:07.610
Is there any plans
in that direction?

00:29:07.610 --> 00:29:08.550
LARS BAK: Ivan?

00:29:08.550 --> 00:29:12.710
IVAN POSVA: So currently, if
you're running in a standalone

00:29:12.710 --> 00:29:18.320
VM, right, you can embed C++
libraries or C libraries or any

00:29:18.320 --> 00:29:21.330
native libraries with
just a shared object.

00:29:21.330 --> 00:29:26.080
So load that in and you have
basically some Dart interface

00:29:26.080 --> 00:29:27.880
that you can talk that way.

00:29:31.800 --> 00:29:33.700
Apart from-- sorry.

00:29:33.700 --> 00:29:38.200
Apart from that, maybe
having some RPC service

00:29:38.200 --> 00:29:40.395
would help you.

00:29:40.395 --> 00:29:41.020
AUDIENCE: Yeah.

00:29:41.020 --> 00:29:43.190
In general, it's about
speed, because we

00:29:43.190 --> 00:29:47.750
do a lot of heavy computation
for satellite mission planning

00:29:47.750 --> 00:29:49.380
and control applications.

00:29:49.380 --> 00:29:51.690
So we do a lot of--
we get requests

00:29:51.690 --> 00:29:57.190
in from the client and stuff
and we do a lot of work on it.

00:29:57.190 --> 00:30:00.340
Using an RPC service or
some other standard protocol

00:30:00.340 --> 00:30:02.900
takes a lot of time to
communicate that information

00:30:02.900 --> 00:30:03.670
around.

00:30:03.670 --> 00:30:05.730
So sometimes, they
provide us these libraries

00:30:05.730 --> 00:30:07.950
so that we can do a
lot of it very fast.

00:30:07.950 --> 00:30:11.500
So just in the idea of
maintaining as quick as we

00:30:11.500 --> 00:30:12.444
possibly can.

00:30:12.444 --> 00:30:13.860
IVAN POSVA: Yeah,
so basically, it

00:30:13.860 --> 00:30:16.650
sounds like the embedding
of a shared library

00:30:16.650 --> 00:30:19.830
is more the kind of stuff
that you would need, right?

00:30:19.830 --> 00:30:22.730
And you can import,
basically, these libraries

00:30:22.730 --> 00:30:26.190
with a special prefix
and the VM figures out

00:30:26.190 --> 00:30:28.470
that, oh, I need not just
to load the Dart code.

00:30:28.470 --> 00:30:30.370
I also need to bind
this shared library.

00:30:30.370 --> 00:30:34.750
And then, you have
similar to a JNI API.

00:30:34.750 --> 00:30:39.160
But we try to make it a
lot simpler than using JNI.

00:30:39.160 --> 00:30:41.000
AUDIENCE: I'll ask
you more after.

00:30:41.000 --> 00:30:42.215
Thank you.

00:30:42.215 --> 00:30:43.090
SETH LADD: Thank you.

00:30:43.090 --> 00:30:43.440
Question?

00:30:43.440 --> 00:30:44.053
Yes?

00:30:44.053 --> 00:30:44.780
AUDIENCE: Hi.

00:30:44.780 --> 00:30:47.330
Have you considered adding
support for algebraic data

00:30:47.330 --> 00:30:51.340
types or pattern marching
into the language at all?

00:30:55.730 --> 00:30:59.010
LARS BAK: I can take a
short stab at that one.

00:30:59.010 --> 00:31:01.020
We have considered
a lot of stuff.

00:31:01.020 --> 00:31:03.140
[LAUGHTER]

00:31:06.420 --> 00:31:09.100
There's been a lot
of requests for many

00:31:09.100 --> 00:31:11.960
of these advanced features.

00:31:11.960 --> 00:31:14.040
However, whenever we
add an advanced feature,

00:31:14.040 --> 00:31:17.780
it gets harder to use
the basic language.

00:31:17.780 --> 00:31:20.210
We designed Dart so it's
easier to understand what's

00:31:20.210 --> 00:31:22.369
going on when you execute it.

00:31:22.369 --> 00:31:23.910
So when you're
sitting inside a debug

00:31:23.910 --> 00:31:26.750
or you take a single step, you
know exactly what's going on.

00:31:26.750 --> 00:31:29.545
When you add these advanced
features like pattern matching,

00:31:29.545 --> 00:31:31.670
it gets a little bit more
complicated to figure out

00:31:31.670 --> 00:31:32.890
what's going on at one time.

00:31:35.440 --> 00:31:37.520
Of course, if there's not
enough requests for it,

00:31:37.520 --> 00:31:39.490
we will certainly
look at and put it in.

00:31:39.490 --> 00:31:41.865
We have a process called the
dev process, where everybody

00:31:41.865 --> 00:31:44.800
can add a proposal and send it
into us and we will look at it

00:31:44.800 --> 00:31:49.480
and put it in if it's
good for the language.

00:31:49.480 --> 00:31:53.560
However, whenever
you add something

00:31:53.560 --> 00:31:56.860
to a programming language,
it gets more complicated.

00:31:56.860 --> 00:32:00.600
And I really believe that if
you have a simple execution

00:32:00.600 --> 00:32:05.850
in your programming
language, then people

00:32:05.850 --> 00:32:08.620
will understand what's going on
and they'll be more productive.

00:32:08.620 --> 00:32:11.825
So that's the balance
we have to consider.

00:32:14.037 --> 00:32:14.870
AUDIENCE: Thank you.

00:32:14.870 --> 00:32:15.011
SETH LADD: Awesome.

00:32:15.011 --> 00:32:15.520
Good way to end it.

00:32:15.520 --> 00:32:16.894
And with that,
we're out of time.

00:32:16.894 --> 00:32:19.357
So thank you for everyone who
voted and asked questions.

00:32:19.357 --> 00:32:20.440
Let's thank our panelists.

00:32:20.440 --> 00:32:21.640
[APPLAUSE]

00:32:23.740 --> 00:32:25.890
We'll see you after the break.

