WEBVTT
Kind: captions
Language: en

00:00:00.310 --> 00:00:03.060
JEFFREY POSNICK: So, Yaniv,
have we started yet?

00:00:03.060 --> 00:00:03.770
YANIV INBAR: Not yet.

00:00:03.770 --> 00:00:06.660
You know, it's been such an
exciting day, so much

00:00:06.660 --> 00:00:09.280
incredible information, I would
just like to take a

00:00:09.280 --> 00:00:11.050
moment to meditate first.

00:00:11.050 --> 00:00:13.430
JEFFREY POSNICK: Yeah, OK,
but have we started yet?

00:00:13.430 --> 00:00:14.600
YANIV INBAR: Not quite yet.

00:00:14.600 --> 00:00:17.980
I really appreciate the
enthusiasm, but I'd just like

00:00:17.980 --> 00:00:20.701
a moment to meditate first.

00:00:20.701 --> 00:00:21.550
JEFFREY POSNICK:
How about now?

00:00:21.550 --> 00:00:22.580
Have we started yet?

00:00:22.580 --> 00:00:24.960
YANIV INBAR: Not quite yet.

00:00:24.960 --> 00:00:25.580
JEFFREY POSNICK:
How about now?

00:00:25.580 --> 00:00:26.750
YANIV INBAR: Yeah,
let's do it.

00:00:26.750 --> 00:00:27.110
JEFFREY POSNICK: OK.

00:00:27.110 --> 00:00:28.620
YANIV INBAR: Let's
get started.

00:00:28.620 --> 00:00:29.000
JEFFREY POSNICK: Awesome.

00:00:29.000 --> 00:00:30.190
So I'm Jeff Posnick.

00:00:30.190 --> 00:00:32.740
I'm a member of the Developer
Relations Team working on the

00:00:32.740 --> 00:00:34.140
YouTube API.

00:00:34.140 --> 00:00:35.440
YANIV INBAR: And I'm
Yaniv Inbar.

00:00:35.440 --> 00:00:38.070
I'm a technical lead
in the Google API

00:00:38.070 --> 00:00:39.540
Infrastructure Team.

00:00:39.540 --> 00:00:40.780
JEFFREY POSNICK: And today
we're going to be talking

00:00:40.780 --> 00:00:44.380
about YouTube API push
notifications.

00:00:44.380 --> 00:00:49.310
And people might be familiar
with the fact that asking the

00:00:49.310 --> 00:00:53.010
same question over and over
again is annoying, whether

00:00:53.010 --> 00:00:55.400
it's two presenters on stage
or whether it's your web

00:00:55.400 --> 00:00:57.780
application talking
to Google servers.

00:00:57.780 --> 00:01:00.940
So I'm sure tons of people have
written code that pretty

00:01:00.940 --> 00:01:01.650
much does this.

00:01:01.650 --> 00:01:03.030
Anything new?

00:01:03.030 --> 00:01:03.690
YANIV INBAR: No.

00:01:03.690 --> 00:01:05.170
JEFFREY POSNICK: Anything new?

00:01:05.170 --> 00:01:06.520
YANIV INBAR: No.

00:01:06.520 --> 00:01:08.450
JEFFREY POSNICK: Anything new?

00:01:08.450 --> 00:01:09.180
YANIV INBAR: Yes.

00:01:09.180 --> 00:01:09.360
JEFFREY POSNICK: Awesome.

00:01:09.360 --> 00:01:11.340
But anything new?

00:01:11.340 --> 00:01:12.060
YANIV INBAR: No.

00:01:12.060 --> 00:01:12.630
JEFFREY POSNICK: OK.

00:01:12.630 --> 00:01:16.880
So this is the polling paradigm
of writing code where

00:01:16.880 --> 00:01:18.790
your web application's trying
to figure out whether

00:01:18.790 --> 00:01:22.360
something's happened either in
the YouTube world or any of

00:01:22.360 --> 00:01:24.540
the other Google
APIs out there.

00:01:24.540 --> 00:01:27.060
And polling is bad.

00:01:27.060 --> 00:01:31.670
We want people to say no to
polling and change their way

00:01:31.670 --> 00:01:33.100
of writing applications.

00:01:33.100 --> 00:01:35.460
One of the problems with polling
is it's really hard to

00:01:35.460 --> 00:01:38.200
find the right interval
to poll.

00:01:38.200 --> 00:01:40.940
You could say, let's poll every
hour, where we ask the

00:01:40.940 --> 00:01:42.550
server whether anything's new.

00:01:42.550 --> 00:01:44.240
And there are problems
with that.

00:01:44.240 --> 00:01:47.570
You might receive your
events late.

00:01:47.570 --> 00:01:50.990
It could be up to 59 minutes in
between the time something

00:01:50.990 --> 00:01:53.980
happens and when you find out
about it, about 30 minutes on

00:01:53.980 --> 00:01:55.540
average for any event.

00:01:55.540 --> 00:01:58.440
So you really don't have
instant feedback.

00:01:58.440 --> 00:02:00.365
And you may miss events.

00:02:00.365 --> 00:02:03.060
If you have a really long poll
interval, there could be like

00:02:03.060 --> 00:02:05.770
three different things that
happened to a resource in

00:02:05.770 --> 00:02:06.610
between that interval.

00:02:06.610 --> 00:02:08.979
And maybe the final stage state
didn't change, so you

00:02:08.979 --> 00:02:12.430
can't really detect it once you
do get around to polling.

00:02:12.430 --> 00:02:14.510
So you're losing some
data there.

00:02:14.510 --> 00:02:18.120
So the next reaction that people
have is, OK, well,

00:02:18.120 --> 00:02:19.450
let's poll every minute.

00:02:19.450 --> 00:02:22.310
Let's poll at the other
end of the spectrum.

00:02:22.310 --> 00:02:23.790
And that's not great.

00:02:23.790 --> 00:02:26.040
You end up wasting network
bandwidth.

00:02:26.040 --> 00:02:27.840
And in that case,
you're sending a

00:02:27.840 --> 00:02:30.000
lot of extra requests.

00:02:30.000 --> 00:02:33.150
You might actually also
run into quota issues.

00:02:33.150 --> 00:02:38.100
As we're well aware, many of
Google's APIs and YouTube APIs

00:02:38.100 --> 00:02:41.150
are also in that category,
have quota

00:02:41.150 --> 00:02:42.070
associated with them.

00:02:42.070 --> 00:02:43.850
And you want to make your
API calls count.

00:02:43.850 --> 00:02:46.710
So you don't want to just have
calls that are asking the same

00:02:46.710 --> 00:02:49.760
thing and getting back the no
response again and again.

00:02:49.760 --> 00:02:52.310
So what can people do instead?

00:02:52.310 --> 00:02:54.700
And we're happy to say you
can now say yes to push

00:02:54.700 --> 00:02:55.600
notifications.

00:02:55.600 --> 00:02:58.440
And the whole model behind push
notifications is that

00:02:58.440 --> 00:03:01.050
instead of my web application
asking Google whether

00:03:01.050 --> 00:03:04.680
something's changed,
Google says, hey.

00:03:04.680 --> 00:03:05.460
YANIV INBAR: Guess what?

00:03:05.460 --> 00:03:07.240
I've got something new
for you, Jeff.

00:03:07.240 --> 00:03:09.080
JEFFREY POSNICK: And that's very
nice of Google to tell me

00:03:09.080 --> 00:03:09.790
when something is new.

00:03:09.790 --> 00:03:12.880
Because Google and the
YouTube APIs, we know

00:03:12.880 --> 00:03:13.980
when things have happened.

00:03:13.980 --> 00:03:15.800
So we can tell interested
parties,

00:03:15.800 --> 00:03:17.950
hey, something's changed.

00:03:17.950 --> 00:03:20.250
Benefits, hopefully,
are obvious.

00:03:20.250 --> 00:03:23.420
You have lower network bandwidth
that's used, lower

00:03:23.420 --> 00:03:27.450
quota consumption, almost
immediate notifications when

00:03:27.450 --> 00:03:28.870
something's changed.

00:03:28.870 --> 00:03:31.850
So it's a much better user
experience overall.

00:03:31.850 --> 00:03:33.870
And, I mean, honestly, it's
a much better developer

00:03:33.870 --> 00:03:34.520
experience.

00:03:34.520 --> 00:03:37.040
Nobody really likes writing
while loops that are just

00:03:37.040 --> 00:03:38.480
running in the background.

00:03:38.480 --> 00:03:42.090
So we have a much nicer
experience overall.

00:03:42.090 --> 00:03:44.060
And I'm going to hand things
over to Yaniv to talk about

00:03:44.060 --> 00:03:46.610
the life of a notification
channel.

00:03:46.610 --> 00:03:48.080
YANIV INBAR: That's a really
great explanation of the

00:03:48.080 --> 00:03:49.720
problem that we tried
to solve.

00:03:49.720 --> 00:03:51.800
So I'm on the Google API
Infrastructure Team.

00:03:51.800 --> 00:03:55.720
And we built a protocol, which
we're calling notification

00:03:55.720 --> 00:03:58.980
channels, not to be confused
with, say, YouTube channels.

00:03:58.980 --> 00:04:01.260
It's a totally different
thing.

00:04:01.260 --> 00:04:04.040
And I'll talk in detail about
how the protocol works, give

00:04:04.040 --> 00:04:06.460
you a good conceptual overview
of the life of a

00:04:06.460 --> 00:04:07.910
notification channel.

00:04:07.910 --> 00:04:10.360
And what I'll be talking
about today is webhook

00:04:10.360 --> 00:04:11.390
notifications.

00:04:11.390 --> 00:04:12.570
This is a common technique
that's

00:04:12.570 --> 00:04:14.540
actually used on the web.

00:04:14.540 --> 00:04:17.899
You'll see where a website
registers an endpoint where

00:04:17.899 --> 00:04:19.700
they can receive callbacks.

00:04:19.700 --> 00:04:23.330
And we're going to be using
webhook to register your

00:04:23.330 --> 00:04:25.350
application's notification
endpoint where you'll be

00:04:25.350 --> 00:04:28.370
receiving callbacks every time
something's changed.

00:04:28.370 --> 00:04:30.800
So let's take a look.

00:04:30.800 --> 00:04:34.220
The first thing you do whenever
using YouTube API, if

00:04:34.220 --> 00:04:37.580
you've ever built a web
application that uses the

00:04:37.580 --> 00:04:40.630
YouTube API, is you have to
register your application.

00:04:40.630 --> 00:04:41.965
And if you've ever done that,
you might be familiar with

00:04:41.965 --> 00:04:42.720
this already.

00:04:42.720 --> 00:04:44.910
We've renamed it the Google
Cloud Console.

00:04:44.910 --> 00:04:47.520
And this is a new URL.

00:04:47.520 --> 00:04:50.070
And the first thing you do
is you want to enable the

00:04:50.070 --> 00:04:51.640
YouTube Data API.

00:04:51.640 --> 00:04:54.740
You want to accept the
terms of service.

00:04:54.740 --> 00:04:57.520
You'll want to register your
application, give the name of

00:04:57.520 --> 00:05:01.680
your application, set up the
consent screen that is shown

00:05:01.680 --> 00:05:05.070
to your users, as well as define
what platform your

00:05:05.070 --> 00:05:06.750
application is running on.

00:05:06.750 --> 00:05:08.830
In this case, it's going to be a
web application, but we also

00:05:08.830 --> 00:05:12.290
support mobile applications or
native applications that are

00:05:12.290 --> 00:05:15.950
installed on desktop devices.

00:05:15.950 --> 00:05:18.440
And, finally, and the reason
why I showed you--

00:05:18.440 --> 00:05:21.720
went into details here is that
we're soon going to enable a

00:05:21.720 --> 00:05:25.390
requirement that you register
the domain where you're going

00:05:25.390 --> 00:05:27.450
to be receiving notification
endpoints.

00:05:27.450 --> 00:05:29.350
The reason we do that is we
want to make sure that you

00:05:29.350 --> 00:05:30.890
actually own that domain.

00:05:30.890 --> 00:05:34.250
If you're running on one of
Google's cloud platforms, say,

00:05:34.250 --> 00:05:36.780
an App Engine or Compute
Engine, we already know

00:05:36.780 --> 00:05:38.100
whether you own that domain.

00:05:38.100 --> 00:05:40.545
But if it's another domain,
you'll lead to register your

00:05:40.545 --> 00:05:43.360
endpoint domain.

00:05:43.360 --> 00:05:45.930
So I'm going to be talking about
OAuth 2 here because

00:05:45.930 --> 00:05:49.750
it's central to using the
YouTube API whenever you're

00:05:49.750 --> 00:05:50.620
making requests.

00:05:50.620 --> 00:05:52.430
And there are a variety
of different flows

00:05:52.430 --> 00:05:56.840
that OAuth 2 supports.

00:05:56.840 --> 00:05:58.790
And it's a standard protocol
on the web.

00:05:58.790 --> 00:06:00.780
This literally is now
a final standard.

00:06:00.780 --> 00:06:03.710
So you'll see a lot of different
sources use it.

00:06:03.710 --> 00:06:06.650
And I'll demonstrate here one
type of flow, which is where a

00:06:06.650 --> 00:06:08.580
user owns the data.

00:06:08.580 --> 00:06:14.640
And the key thing about OAuth 2
is that it is intended for a

00:06:14.640 --> 00:06:17.440
client application to access
protected resources.

00:06:17.440 --> 00:06:19.900
So how does Google know
that it's OK to

00:06:19.900 --> 00:06:21.670
access the user's data?

00:06:21.670 --> 00:06:22.430
Well, we start here.

00:06:22.430 --> 00:06:23.490
That's a picture of me.

00:06:23.490 --> 00:06:25.320
That's supposed to
be the user.

00:06:25.320 --> 00:06:28.680
And I think that picture needs
a little bit of enhancement,

00:06:28.680 --> 00:06:31.980
maybe take out some
of the wrinkles.

00:06:31.980 --> 00:06:34.090
JEFFREY POSNICK: Skin glow.

00:06:34.090 --> 00:06:34.530
YANIV INBAR: All right.

00:06:34.530 --> 00:06:36.950
So what happens when the user
goes to your web app?

00:06:36.950 --> 00:06:40.080
Well, you go to the web app,
says I'd like to use your

00:06:40.080 --> 00:06:41.060
application.

00:06:41.060 --> 00:06:44.440
So the web goes to Google and
says, is it OK to start--

00:06:44.440 --> 00:06:46.790
please start the authorization
process.

00:06:46.790 --> 00:06:50.650
So Google asks the user, is it
OK to grant access to this web

00:06:50.650 --> 00:06:51.370
application?

00:06:51.370 --> 00:06:53.960
And when the user grants
access, you

00:06:53.960 --> 00:06:55.810
get an access token.

00:06:55.810 --> 00:06:57.760
And this is really key, because
any time you're going

00:06:57.760 --> 00:07:00.470
to be accessing the
use-protected resources,

00:07:00.470 --> 00:07:02.560
you'll want to use that
access token.

00:07:02.560 --> 00:07:04.420
And I'll show you how
that works in detail

00:07:04.420 --> 00:07:05.730
a little bit later.

00:07:05.730 --> 00:07:09.900
And in this case, because this
is a sample of how a

00:07:09.900 --> 00:07:13.150
notification channel works, the
web app is going to ask

00:07:13.150 --> 00:07:18.540
the user which collection the
user would like that web app

00:07:18.540 --> 00:07:19.530
to listen for.

00:07:19.530 --> 00:07:20.800
So I'm using the word
collection.

00:07:20.800 --> 00:07:22.670
It might sound a little
bit abstract.

00:07:22.670 --> 00:07:23.860
Think of a YouTube playlist.

00:07:23.860 --> 00:07:25.850
That's a good example
of a collection.

00:07:25.850 --> 00:07:28.310
But the reason I chose the word
collection and not just a

00:07:28.310 --> 00:07:32.540
YouTube playlist is because we
built this is as a protocol.

00:07:32.540 --> 00:07:35.420
And you'll be able to use the
exact same protocol, say, with

00:07:35.420 --> 00:07:36.770
Google Cloud Storage API.

00:07:36.770 --> 00:07:38.920
We just recently announced
that they support push

00:07:38.920 --> 00:07:39.930
notifications.

00:07:39.930 --> 00:07:42.830
And maybe there'll be other
Google APIs that support push

00:07:42.830 --> 00:07:44.050
notifications in the future.

00:07:44.050 --> 00:07:46.530
So you'll be able to refer to
this presentation in the

00:07:46.530 --> 00:07:49.160
future as well.

00:07:49.160 --> 00:07:53.470
So let's take a look at the
start of watching for changes

00:07:53.470 --> 00:07:55.100
on that collection.

00:07:55.100 --> 00:07:58.080
The web app makes a
request to Google.

00:07:58.080 --> 00:08:00.320
It's calling the items.watch
request.

00:08:00.320 --> 00:08:03.440
And Jeff will later show you an
example of how to use our

00:08:03.440 --> 00:08:06.080
client libraries to make
this really simple.

00:08:06.080 --> 00:08:08.300
And Google will say, OK.

00:08:08.300 --> 00:08:09.550
It's all right.

00:08:11.660 --> 00:08:14.050
We started that notification
channel.

00:08:14.050 --> 00:08:16.780
And you can see there's all
the collection there that

00:08:16.780 --> 00:08:19.580
we're going to reference when
we call items.watch.

00:08:19.580 --> 00:08:20.940
And it's owned by the user.

00:08:20.940 --> 00:08:23.310
There's two items in
there already.

00:08:23.310 --> 00:08:27.040
And, at the same time, the
notifications endpoint, which

00:08:27.040 --> 00:08:29.420
is running that same domain that
you registered earlier,

00:08:29.420 --> 00:08:32.230
will receive what's called
a sync notification.

00:08:32.230 --> 00:08:35.330
This is an opportunity for the
notifications endpoint to then

00:08:35.330 --> 00:08:37.860
go to Google and say, give me
the current state of that

00:08:37.860 --> 00:08:38.820
collection.

00:08:38.820 --> 00:08:41.750
So whenever I receive
notifications in the future,

00:08:41.750 --> 00:08:43.190
I'll know what's changed.

00:08:43.190 --> 00:08:44.890
I'll be able to figure
that out.

00:08:44.890 --> 00:08:48.050
So think of this as a chance
to synchronize your web

00:08:48.050 --> 00:08:49.790
application with Google.

00:08:49.790 --> 00:08:52.340
And when you're done with that,
just return a 200 OK.

00:08:52.340 --> 00:08:54.300
Everything went fine.

00:08:54.300 --> 00:08:57.270
Now, let's go into more detail
what just happened here.

00:08:57.270 --> 00:09:01.010
When you make the items.watch
request, you have to specify a

00:09:01.010 --> 00:09:03.050
few things to Google.

00:09:03.050 --> 00:09:05.550
The first is a collection ID.

00:09:05.550 --> 00:09:08.990
This is an identifier that
specifies exactly what

00:09:08.990 --> 00:09:10.710
collection you're
listening to.

00:09:10.710 --> 00:09:14.180
Think of this as the
playlist ID.

00:09:14.180 --> 00:09:15.450
The second piece of information

00:09:15.450 --> 00:09:16.700
is that access token.

00:09:16.700 --> 00:09:19.850
As I mentioned earlier, at the
end of the OAuth 2 flow,

00:09:19.850 --> 00:09:21.010
you'll get an access token.

00:09:21.010 --> 00:09:24.350
That's what you'll use in the
authorization header.

00:09:24.350 --> 00:09:26.390
The third piece of information
is the

00:09:26.390 --> 00:09:28.100
notification endpoint address.

00:09:28.100 --> 00:09:31.300
That's a URL where you're going
to be receiving your

00:09:31.300 --> 00:09:34.240
notification running on one
of the domains that you

00:09:34.240 --> 00:09:36.600
registered with your
application.

00:09:36.600 --> 00:09:39.490
And, finally, there's the
universally unique identifier

00:09:39.490 --> 00:09:42.390
of the notification channel.

00:09:42.390 --> 00:09:44.890
This is unique for your
web application.

00:09:44.890 --> 00:09:49.440
And your application is the one
that has to specify it in

00:09:49.440 --> 00:09:51.810
order to make sure that
whenever you receive a

00:09:51.810 --> 00:09:55.490
notification, you'll be able
to know exactly which

00:09:55.490 --> 00:09:58.040
notification channel it's
receiving a notification for.

00:09:58.040 --> 00:10:00.150
So perhaps you have
a lot of users.

00:10:00.150 --> 00:10:02.280
You'll want to know exactly
which user this notification

00:10:02.280 --> 00:10:04.770
is associated with, and also
which collection it's

00:10:04.770 --> 00:10:05.660
associate with.

00:10:05.660 --> 00:10:07.950
And maybe multiple users are
sharing the same collection.

00:10:07.950 --> 00:10:10.200
So you really need something
that's unique.

00:10:10.200 --> 00:10:13.140
The good news is that most
programming languages provide

00:10:13.140 --> 00:10:16.530
a very simple way to
get a random UUID.

00:10:16.530 --> 00:10:18.460
And Jeff will show you
an example of that

00:10:18.460 --> 00:10:20.400
a little bit later.

00:10:20.400 --> 00:10:22.170
Finally, there is
a channel token.

00:10:22.170 --> 00:10:23.840
This is for your needs.

00:10:23.840 --> 00:10:24.690
It's optional.

00:10:24.690 --> 00:10:26.160
You don't have to specify it.

00:10:26.160 --> 00:10:28.570
It's just to make it much easier
for you to process the

00:10:28.570 --> 00:10:29.980
notification.

00:10:29.980 --> 00:10:31.320
It's going to be something
that's custom for your

00:10:31.320 --> 00:10:32.020
application.

00:10:32.020 --> 00:10:34.330
Maybe it helps the application
know how to process the

00:10:34.330 --> 00:10:35.540
notification.

00:10:35.540 --> 00:10:39.690
Maybe it helps identify
what user this is.

00:10:39.690 --> 00:10:42.190
There's a variety of things
you can use it for.

00:10:42.190 --> 00:10:44.210
But it's available to you.

00:10:44.210 --> 00:10:46.260
So this is what the
HTTP looks like.

00:10:46.260 --> 00:10:47.830
Now, if you're using one of
our client libraries, you

00:10:47.830 --> 00:10:49.640
don't really need to know
the HTTP protocol.

00:10:49.640 --> 00:10:51.850
But I still think it's useful
for you to understand, just

00:10:51.850 --> 00:10:54.180
conceptually, what's going on.

00:10:54.180 --> 00:10:57.520
You're making a post request
to a specific URL.

00:10:57.520 --> 00:10:59.900
It'll probably end
with /watch.

00:10:59.900 --> 00:11:01.240
And you're specifying
the Playlist

00:11:01.240 --> 00:11:03.290
ID and query parameter.

00:11:03.290 --> 00:11:05.060
The authorization header
is where you

00:11:05.060 --> 00:11:06.970
put that access token.

00:11:06.970 --> 00:11:09.130
Again, to access the user's
protect data, you've got to

00:11:09.130 --> 00:11:10.910
specify the access token.

00:11:10.910 --> 00:11:14.490
And because it's a post, there's
a JSON body here.

00:11:14.490 --> 00:11:16.010
And you specify a few things.

00:11:16.010 --> 00:11:17.930
One is that we're using
webhook and the

00:11:17.930 --> 00:11:19.290
notification URL.

00:11:19.290 --> 00:11:23.370
In this case it's /notifications
on my website.

00:11:23.370 --> 00:11:25.750
And I want to you to
notice is HTTPS.

00:11:25.750 --> 00:11:26.630
That's actually important.

00:11:26.630 --> 00:11:29.060
We want to make sure that these
requests are made to a

00:11:29.060 --> 00:11:31.060
secure location.

00:11:31.060 --> 00:11:33.000
The ID, that's that
unique identifier

00:11:33.000 --> 00:11:34.450
that's a channel ID.

00:11:34.450 --> 00:11:36.160
And, finally, there's
a custom token.

00:11:36.160 --> 00:11:37.570
You could leave that out.

00:11:37.570 --> 00:11:39.680
It's your choice.

00:11:39.680 --> 00:11:42.390
Now, the watch response
from Google will

00:11:42.390 --> 00:11:43.750
typically be a 200 OK.

00:11:43.750 --> 00:11:45.530
Everything went fine,
assuming the

00:11:45.530 --> 00:11:47.350
authorization check worked.

00:11:47.350 --> 00:11:49.610
And it'll give you a bunch
of information.

00:11:49.610 --> 00:11:52.010
The key information that I
want to highlight for you

00:11:52.010 --> 00:11:54.160
today is that expiration time.

00:11:54.160 --> 00:11:56.760
Now, this varies between
different Google APIs.

00:11:56.760 --> 00:11:58.715
You'll want to read their
documentation to

00:11:58.715 --> 00:12:00.360
learn how it works.

00:12:00.360 --> 00:12:03.230
It is possible to
set an infinite

00:12:03.230 --> 00:12:04.640
channel expiration time.

00:12:04.640 --> 00:12:07.430
But, typically, it's a one-hour
expiration time.

00:12:07.430 --> 00:12:09.790
That's what YouTube
has implemented.

00:12:09.790 --> 00:12:11.140
And it'll come back to you.

00:12:11.140 --> 00:12:14.830
Here is what the HTTP
response looks like.

00:12:14.830 --> 00:12:18.600
Some of this information, such
as the ID, is just giving you

00:12:18.600 --> 00:12:20.200
back what you sent Google.

00:12:20.200 --> 00:12:22.730
And there's some things like
the resource ID and the

00:12:22.730 --> 00:12:24.530
resource URI, which I just
don't have time to

00:12:24.530 --> 00:12:25.620
go into right now.

00:12:25.620 --> 00:12:27.660
But they might be
of use to you.

00:12:27.660 --> 00:12:30.080
But most important here is
that expiration time.

00:12:30.080 --> 00:12:34.970
This is the number of
milliseconds of Unix time.

00:12:34.970 --> 00:12:37.340
So you can look at that, too.

00:12:37.340 --> 00:12:40.320
And you maybe want to store that
information, for example.

00:12:40.320 --> 00:12:43.230
I'll talk a little more about
the end of notification

00:12:43.230 --> 00:12:45.620
channels a little bit later.

00:12:45.620 --> 00:12:47.780
So let's take a look at
the sync notification.

00:12:47.780 --> 00:12:49.620
This is what we built
this for.

00:12:49.620 --> 00:12:51.790
We want to receive a
notification the moment that

00:12:51.790 --> 00:12:54.440
you set up a notification
channel.

00:12:54.440 --> 00:12:56.280
You'll get a couple pieces
of information.

00:12:56.280 --> 00:12:57.920
The resource state
here is sync.

00:12:57.920 --> 00:13:00.850
I'll show you the two other
possible resource states in

00:13:00.850 --> 00:13:03.160
just a moment.

00:13:03.160 --> 00:13:04.990
There is that unique
identifier.

00:13:04.990 --> 00:13:07.750
Again, that's helping you
identify exactly which

00:13:07.750 --> 00:13:10.300
notifications this is
associated with.

00:13:10.300 --> 00:13:12.550
And that optional channel token
that might help you

00:13:12.550 --> 00:13:16.020
process the notification.

00:13:16.020 --> 00:13:18.740
So here is what the HTTP
request looks like.

00:13:18.740 --> 00:13:21.770
Again, this is Google calling
your web application

00:13:21.770 --> 00:13:23.560
notification endpoint.

00:13:23.560 --> 00:13:26.990
Most of the information
is in those headers.

00:13:26.990 --> 00:13:29.540
So one piece of information
is the resource state.

00:13:29.540 --> 00:13:31.440
In this case, it's sync.

00:13:31.440 --> 00:13:33.640
There's a channel ID and channel
token that I mentioned

00:13:33.640 --> 00:13:35.550
earlier, as well also some
of the other pieces of

00:13:35.550 --> 00:13:37.630
information.

00:13:37.630 --> 00:13:40.310
And there's also a message
number, which I won't have

00:13:40.310 --> 00:13:42.740
time to go into, but is
sometimes useful, especially

00:13:42.740 --> 00:13:43.990
in error cases.

00:13:46.320 --> 00:13:48.250
And a successful notification
response from your

00:13:48.250 --> 00:13:51.000
notification endpoint is just
going to be 200 OK.

00:13:51.000 --> 00:13:52.440
There's really nothing
more to it.

00:13:52.440 --> 00:13:54.600
I'll mention one neat trick
that you can use

00:13:54.600 --> 00:13:55.950
a little bit later.

00:13:55.950 --> 00:13:57.620
But here's the HTTP.

00:13:57.620 --> 00:14:00.570
Very simple, you don't really
need to give Google anything,

00:14:00.570 --> 00:14:02.310
just 200 OK.

00:14:02.310 --> 00:14:04.790
Make sure it's 200 and
not something else.

00:14:04.790 --> 00:14:08.310
And I'll tell you
why in a moment.

00:14:08.310 --> 00:14:12.180
So here's a typical app scenario
where the users uses

00:14:12.180 --> 00:14:14.900
some client application, maybe
it's on their mobile device,

00:14:14.900 --> 00:14:16.350
maybe it's somewhere else.

00:14:16.350 --> 00:14:18.430
That's not really important.

00:14:18.430 --> 00:14:20.540
My point is it doesn't need to
be your web application.

00:14:20.540 --> 00:14:21.780
It could be from anywhere.

00:14:21.780 --> 00:14:23.960
It's going to be making some
change to the collection.

00:14:23.960 --> 00:14:25.950
It's going to be inserting
a new item.

00:14:25.950 --> 00:14:28.280
It's going to call the
items.insert method.

00:14:28.280 --> 00:14:30.380
And you can see that little
animation, that new item,

00:14:30.380 --> 00:14:32.400
popping up in your collection.

00:14:32.400 --> 00:14:35.420
And Google is going to
then notify your

00:14:35.420 --> 00:14:36.820
notifications endpoint.

00:14:36.820 --> 00:14:38.390
The only thing that's different
between a sync

00:14:38.390 --> 00:14:41.590
notification and this scenario
is that the resource state

00:14:41.590 --> 00:14:43.850
will be exists.

00:14:43.850 --> 00:14:47.020
And, again, it returns
a 200 OK.

00:14:47.020 --> 00:14:49.690
So here's a little bit more
detail about the exists

00:14:49.690 --> 00:14:50.930
notification.

00:14:50.930 --> 00:14:52.250
The resource state is exists.

00:14:52.250 --> 00:14:54.060
I mentioned that earlier.

00:14:54.060 --> 00:14:59.930
The channel ID, channel token,
HTTP looks almost the same.

00:14:59.930 --> 00:15:01.780
The only thing that's really
changed here, other than the

00:15:01.780 --> 00:15:05.890
message number, which increases
every time, is the

00:15:05.890 --> 00:15:07.630
resource state.

00:15:07.630 --> 00:15:10.460
Now, you might be thinking,
what do I do if

00:15:10.460 --> 00:15:11.330
I receive an exists?

00:15:11.330 --> 00:15:12.620
Is there any more information
about

00:15:12.620 --> 00:15:13.870
exactly what just happened?

00:15:16.640 --> 00:15:19.200
I'm just displaying the
basic protocol.

00:15:19.200 --> 00:15:23.270
APIs have the option to give
more information, such as the

00:15:23.270 --> 00:15:27.350
JSON metadata about that new
item that was inserted.

00:15:27.350 --> 00:15:30.620
It might be a URL where you
can get more information.

00:15:30.620 --> 00:15:34.840
In the case of YouTube, there
won't be such a JSON payload,

00:15:34.840 --> 00:15:38.240
but it's useful to know, for
example, Google Cloud Storage

00:15:38.240 --> 00:15:41.270
API has chosen to use it.

00:15:41.270 --> 00:15:44.090
So here is a case where you've
got an update going on.

00:15:44.090 --> 00:15:45.900
And it's a very simple
scenario.

00:15:45.900 --> 00:15:50.235
The client application is
calling items.update.

00:15:50.235 --> 00:15:52.840
And the item got updated.

00:15:52.840 --> 00:15:56.790
And Google is going to send
an exists notification,

00:15:56.790 --> 00:15:58.040
just like an insert.

00:16:00.900 --> 00:16:02.010
OK.

00:16:02.010 --> 00:16:04.410
So the information
is the same.

00:16:04.410 --> 00:16:05.640
Message number increased.

00:16:05.640 --> 00:16:07.160
The resource state is exists.

00:16:07.160 --> 00:16:09.490
So you might be thinking, how
do I tell between an update

00:16:09.490 --> 00:16:10.870
and an insert?

00:16:10.870 --> 00:16:13.450
Well, we don't really have a way
to give you a difference.

00:16:13.450 --> 00:16:16.180
Again, that's going to be
specific to the scenario that

00:16:16.180 --> 00:16:16.750
you're talking about.

00:16:16.750 --> 00:16:19.450
So Jeff will show an example of
how he manages that in his

00:16:19.450 --> 00:16:22.740
demo just a little bit later.

00:16:22.740 --> 00:16:24.690
Now, what happens when
you delete an item?

00:16:24.690 --> 00:16:26.535
It's very similar
to an update.

00:16:26.535 --> 00:16:29.990
The item will now fly away.

00:16:29.990 --> 00:16:33.180
And Google will send a
notification to the

00:16:33.180 --> 00:16:35.670
notification endpoint
not.exists is

00:16:35.670 --> 00:16:36.750
the resource state.

00:16:36.750 --> 00:16:38.780
So those are the three
possible states--

00:16:38.780 --> 00:16:41.920
a sync, which is sent exactly
once at the beginning of a

00:16:41.920 --> 00:16:45.296
notification channel; an exists,
whenever an item got

00:16:45.296 --> 00:16:46.410
inserted or updated; or

00:16:46.410 --> 00:16:47.890
not.exists, when it got deleted.

00:16:50.640 --> 00:16:52.775
And here's some more
details about it.

00:16:52.775 --> 00:16:57.190
Again, the resource state is
not.exists, and channel ID,

00:16:57.190 --> 00:17:01.780
channel token, and HTTP
protocol, just showing you

00:17:01.780 --> 00:17:04.720
everything's pretty similar
except the resource state is

00:17:04.720 --> 00:17:08.130
not.exists and the message
number increased again.

00:17:08.130 --> 00:17:10.920
So what do we do if the server
is not reachable?

00:17:10.920 --> 00:17:12.390
This happens sometimes.

00:17:12.390 --> 00:17:14.270
Maybe the server is down.

00:17:14.270 --> 00:17:16.329
Maybe there is some
kind of problem.

00:17:16.329 --> 00:17:18.869
Who knows what could go wrong?

00:17:18.869 --> 00:17:22.140
We'll give you some assurance
that we'll make an attempt to

00:17:22.140 --> 00:17:24.380
still send that notification
to you.

00:17:24.380 --> 00:17:27.420
So if, say, it's a 503,
some server error.

00:17:27.420 --> 00:17:29.910
Google will wait a little bit of
time and then send you that

00:17:29.910 --> 00:17:30.980
notification again.

00:17:30.980 --> 00:17:35.340
If it's still an error, it'll
retry that notification up

00:17:35.340 --> 00:17:36.350
until some threshold.

00:17:36.350 --> 00:17:38.040
I don't remember exactly
what it is.

00:17:38.040 --> 00:17:39.760
Maybe it's 75 minutes.

00:17:39.760 --> 00:17:41.820
But whatever that threshold is,
it will make an attempt

00:17:41.820 --> 00:17:44.250
until it receives
an OK response.

00:17:44.250 --> 00:17:47.040
Now, that message number might
be useful, because that

00:17:47.040 --> 00:17:49.750
message number will be the same
every time it retries the

00:17:49.750 --> 00:17:50.280
notification.

00:17:50.280 --> 00:17:55.380
So you'll be able to catch the
case where there's duplicates.

00:17:55.380 --> 00:17:58.150
So, finally, in the life of a
notification channel, how do

00:17:58.150 --> 00:17:58.860
we stop it?

00:17:58.860 --> 00:18:00.960
Well, one possibility is the
notification channel might

00:18:00.960 --> 00:18:03.520
expire within an hour.

00:18:03.520 --> 00:18:06.450
Another possibility, if you
actually want to manually stop

00:18:06.450 --> 00:18:07.710
notifications--

00:18:07.710 --> 00:18:10.900
perhaps the user is no longer
using your application--

00:18:10.900 --> 00:18:14.330
one way to do that is in your
notification endpoint, you

00:18:14.330 --> 00:18:16.925
still return a 200 OK, but you
can add an additional header

00:18:16.925 --> 00:18:18.340
to tell it to stop.

00:18:18.340 --> 00:18:21.010
And this is what the HTTP
protocol looks like.

00:18:21.010 --> 00:18:24.260
X-Goog-Channel with
a value of stop.

00:18:24.260 --> 00:18:27.410
And Google simply stops sending
notifications for that

00:18:27.410 --> 00:18:30.285
one specific notification
channel for that one user with

00:18:30.285 --> 00:18:31.780
that one collection.

00:18:31.780 --> 00:18:34.510
It doesn't mean stop all
notifications, period--

00:18:34.510 --> 00:18:36.880
just that one channel.

00:18:36.880 --> 00:18:40.620
Now, the other option is, if
you're not in the notification

00:18:40.620 --> 00:18:45.120
endpoint, you can also simply
call the channels.stop method,

00:18:45.120 --> 00:18:48.270
where you have to specify
exactly what is, again, that

00:18:48.270 --> 00:18:51.430
access token that you used
earlier, as well as that

00:18:51.430 --> 00:18:53.980
channel ID to specify exactly
which channel you want to stop

00:18:53.980 --> 00:18:56.620
receiving notifications from.

00:18:56.620 --> 00:18:59.030
That's pretty much it
for the protocol.

00:18:59.030 --> 00:19:01.860
You will be able to get a
lot more details in the

00:19:01.860 --> 00:19:05.020
documentation that
we'll post later.

00:19:05.020 --> 00:19:08.480
And this is what the HTTP
request looks like when you

00:19:08.480 --> 00:19:10.270
stop a channel.

00:19:10.270 --> 00:19:13.960
And you just have to specify
the channel ID.

00:19:13.960 --> 00:19:16.860
But I'll have hand it off at
this point to Jeff to show you

00:19:16.860 --> 00:19:18.900
what this looks like
in practice.

00:19:18.900 --> 00:19:19.910
JEFFREY POSNICK:
Thanks, Yaniv.

00:19:19.910 --> 00:19:21.775
So we have a great
infrastructure to

00:19:21.775 --> 00:19:22.540
build on top of.

00:19:22.540 --> 00:19:24.940
And I'm sure everybody out there
has ideas for how they

00:19:24.940 --> 00:19:26.050
might want to use this.

00:19:26.050 --> 00:19:27.480
I want to demonstrate a sample

00:19:27.480 --> 00:19:29.670
application that I put together.

00:19:29.670 --> 00:19:33.530
This is going to be a Chrome
extension that allows you to

00:19:33.530 --> 00:19:36.610
subscribe to a specific playlist
and get notified when

00:19:36.610 --> 00:19:39.910
new videos are added to
that YouTube playlist.

00:19:39.910 --> 00:19:43.180
Just a little caveat, we don't
have the code available right

00:19:43.180 --> 00:19:46.390
now for folks to use, but we'll
release it shortly.

00:19:46.390 --> 00:19:49.580
So let's pull that up, and I'm
going to walk you through the

00:19:49.580 --> 00:19:55.490
entire flow of using it from
loading the local extension.

00:19:55.490 --> 00:19:58.300
Over here, we have our YouTube
playlist notifier.

00:19:58.300 --> 00:20:00.380
Unfortunately, it's a little
small over here in the corner

00:20:00.380 --> 00:20:01.240
of the screen.

00:20:01.240 --> 00:20:04.720
But the first thing that we
need to do is we have this

00:20:04.720 --> 00:20:07.230
little question mark
over here.

00:20:07.230 --> 00:20:10.370
And it just doesn't know which
playlist we want to listen to.

00:20:10.370 --> 00:20:13.760
So let's create a
new playlist.

00:20:13.760 --> 00:20:17.330
I'm going to use the Google
API's Explorer to do that.

00:20:17.330 --> 00:20:21.180
And I have everything already
pre-populated.

00:20:21.180 --> 00:20:22.770
And I'm going to click
Execute down here.

00:20:22.770 --> 00:20:26.300
And this is going to use the
YouTube API to create a new

00:20:26.300 --> 00:20:27.440
playlist for me.

00:20:27.440 --> 00:20:28.340
So that's great.

00:20:28.340 --> 00:20:31.870
I have my JSON resource
says returned.

00:20:31.870 --> 00:20:36.360
And the thing I care about is
the ID of that new playlist.

00:20:36.360 --> 00:20:41.220
I'm going to copy it, go back
to my application, and I can

00:20:41.220 --> 00:20:45.150
now paste that in
and click Save.

00:20:45.150 --> 00:20:48.800
And, at this point, what I get
presented with is this screen

00:20:48.800 --> 00:20:49.890
asking me for permission.

00:20:49.890 --> 00:20:53.150
So this is actually
the OAuth 2 flow

00:20:53.150 --> 00:20:54.580
that's built into Chrome.

00:20:54.580 --> 00:20:57.270
This is actually quite neat.

00:20:57.270 --> 00:20:58.740
If you're doing JavaScript
development, if you're running

00:20:58.740 --> 00:21:01.540
Chrome extensions, it makes it
really easy to get OAuth 2

00:21:01.540 --> 00:21:05.670
tokens for the currently
logged-in user to Chrome.

00:21:05.670 --> 00:21:09.280
And it's just saying it wants
to view my YouTube account.

00:21:09.280 --> 00:21:11.400
I'm going to click Allow.

00:21:11.400 --> 00:21:14.990
After I go through that, it's
going to establish the

00:21:14.990 --> 00:21:15.530
connection.

00:21:15.530 --> 00:21:18.300
And behind the scenes it's
doing the watch.

00:21:18.300 --> 00:21:20.140
We're going to dive into the
code in a little bit, but I

00:21:20.140 --> 00:21:23.720
just wanted to show off what
this could actually do.

00:21:23.720 --> 00:21:28.280
I'm going to now add a video to
the playlist I'm watching.

00:21:28.280 --> 00:21:30.280
So I have, again, the
API Explorer up.

00:21:30.280 --> 00:21:32.923
Most of these fields are already
there, but let me put

00:21:32.923 --> 00:21:34.520
in the new playlist ID.

00:21:34.520 --> 00:21:38.020
And before I click Execute, just
take a look in the upper

00:21:38.020 --> 00:21:41.050
right-hand corner
of the screen.

00:21:41.050 --> 00:21:42.300
That's where, hopefully,
the magic will happen.

00:21:49.170 --> 00:21:54.050
Click Execute and we have
over here, right now

00:21:54.050 --> 00:21:56.280
it's switched to one.

00:21:56.280 --> 00:21:59.450
So there is now one video that's
available to watch.

00:21:59.450 --> 00:22:03.550
And if I click over here, you
can see the new videos that

00:22:03.550 --> 00:22:07.300
are in the playlist, a shameless
plug for my I/O talk

00:22:07.300 --> 00:22:07.930
from last year.

00:22:07.930 --> 00:22:10.630
Everybody, I'm sure, wants to
watch that and be notified

00:22:10.630 --> 00:22:12.690
right away when that's
added to a playlist.

00:22:12.690 --> 00:22:16.770
So this happened, everything
behind the scenes, more or

00:22:16.770 --> 00:22:18.120
less in real time.

00:22:18.120 --> 00:22:21.450
And I want to dive in to how
we actually built that.

00:22:27.390 --> 00:22:30.830
So a number of different
components that went into this

00:22:30.830 --> 00:22:31.900
application.

00:22:31.900 --> 00:22:35.360
We have the user-facing client,
which is Chrome and

00:22:35.360 --> 00:22:36.480
Chrome Extension.

00:22:36.480 --> 00:22:39.880
There is some middleware,
which is the App Engine

00:22:39.880 --> 00:22:41.630
instance I have running, and
that's what's going to take

00:22:41.630 --> 00:22:44.930
care of receiving notifications
and doing some

00:22:44.930 --> 00:22:46.180
the API calls for us.

00:22:46.180 --> 00:22:48.770
And, obviously, we have
the YouTube API.

00:22:48.770 --> 00:22:51.300
This wouldn't be a YouTube talk
without the YouTube API

00:22:51.300 --> 00:22:53.040
factoring in somewhere.

00:22:53.040 --> 00:22:55.500
So first things going on, where
we went through the

00:22:55.500 --> 00:22:56.610
OAuth 2 flow.

00:22:56.610 --> 00:23:00.760
We have a access token
for the current user.

00:23:00.760 --> 00:23:04.000
And I'm going to, in my Chrome
Extension, make a call to my

00:23:04.000 --> 00:23:06.530
App Engine in instance saying,
hey, I want you

00:23:06.530 --> 00:23:07.420
to kick off a watch.

00:23:07.420 --> 00:23:09.530
I'm going to pass in
my OAuth 2 token.

00:23:09.530 --> 00:23:11.760
I'm going to also pass in the
playlist ID that I want to

00:23:11.760 --> 00:23:13.710
start watching.

00:23:13.710 --> 00:23:17.260
And the App Engine instance
will make a call to the

00:23:17.260 --> 00:23:19.320
YouTube API on my behalf.

00:23:19.320 --> 00:23:22.460
It'll call the
playlistItems.watch method.

00:23:22.460 --> 00:23:24.210
I'm actually going to be
using the Python client

00:23:24.210 --> 00:23:24.810
library to do that.

00:23:24.810 --> 00:23:27.330
And we'll show you the real
code in a second.

00:23:27.330 --> 00:23:30.975
And, at that point, once I get
a successful response, and

00:23:30.975 --> 00:23:35.236
once my push notification
subscription is active, I'm

00:23:35.236 --> 00:23:39.500
going to open up a channel
connection to Chrome from my

00:23:39.500 --> 00:23:39.990
App Engine.

00:23:39.990 --> 00:23:42.190
So this is using the App
Engine channel's API.

00:23:42.190 --> 00:23:45.090
And this provides a really easy
way for App Engine to

00:23:45.090 --> 00:23:48.740
push things down to Chrome
and to notify me when

00:23:48.740 --> 00:23:51.210
there's a new video.

00:23:51.210 --> 00:23:52.960
So that's the watch flow.

00:23:52.960 --> 00:23:55.890
And let's go through the actual
Python code that was

00:23:55.890 --> 00:23:58.850
used to create that
watch flow.

00:23:58.850 --> 00:24:00.990
Again, Python client library
makes this real easy.

00:24:00.990 --> 00:24:04.960
It's just a question, once you
have your YouTube object and

00:24:04.960 --> 00:24:08.070
it's already authenticated and
all that, you call the watch

00:24:08.070 --> 00:24:11.530
method, passing the
playlist ID, you

00:24:11.530 --> 00:24:13.370
pass in particle snippet.

00:24:13.370 --> 00:24:16.170
This is just your way of telling
YouTube that you care

00:24:16.170 --> 00:24:18.880
about general metadata about
the new video that's been

00:24:18.880 --> 00:24:20.380
added to the playlist.

00:24:20.380 --> 00:24:22.060
And there's a body.

00:24:22.060 --> 00:24:24.730
And this corresponds directly
to the body of the post

00:24:24.730 --> 00:24:26.970
request that Yaniv went
over earlier.

00:24:26.970 --> 00:24:29.810
So this shouldn't be a surprise
to anybody who saw

00:24:29.810 --> 00:24:32.660
the earlier portion
of the code.

00:24:32.660 --> 00:24:34.000
The two things I
wanted to note.

00:24:34.000 --> 00:24:38.220
I am making use of that optional
channel token that

00:24:38.220 --> 00:24:38.960
Yaniv mentioned.

00:24:38.960 --> 00:24:41.980
And I'm, in this case, passing
in the playlist ID as a

00:24:41.980 --> 00:24:43.680
channel token.

00:24:43.680 --> 00:24:46.180
The purpose is writing
application, I found it easier

00:24:46.180 --> 00:24:49.070
to use that value to store
that state about which

00:24:49.070 --> 00:24:50.890
playlist I'm going
to be watching.

00:24:50.890 --> 00:24:53.340
And that'll make it easier
to get the state of the

00:24:53.340 --> 00:24:56.720
collection later on when
I get notifications.

00:24:56.720 --> 00:25:00.640
The other thing I wanted to
point out is that unique UUID.

00:25:00.640 --> 00:25:03.310
To generate that in Python, it's
just a standard library

00:25:03.310 --> 00:25:07.710
call to UUID4, so pretty
straightforward.

00:25:07.710 --> 00:25:10.490
And we now want to call execute
so that request

00:25:10.490 --> 00:25:12.590
actually gets sent off.

00:25:12.590 --> 00:25:14.830
So I now have an active
subscription.

00:25:14.830 --> 00:25:17.990
Let's talk about what happens
during the sync.

00:25:17.990 --> 00:25:23.570
So I receive that initial sync
back saying, hey, YouTube API

00:25:23.570 --> 00:25:26.430
tells App Engine immediately
after the subscription, this

00:25:26.430 --> 00:25:29.870
is your chance to get state
about the current collection.

00:25:29.870 --> 00:25:31.010
So that's great.

00:25:31.010 --> 00:25:34.270
My App Engine app is going to
call playlistItems.list.

00:25:34.270 --> 00:25:36.900
In this example, there wasn't
any items in the playlist, so

00:25:36.900 --> 00:25:37.750
it's not super useful.

00:25:37.750 --> 00:25:39.580
But you can subscribe to
an existing playlist.

00:25:39.580 --> 00:25:42.020
So you might imagine maybe
there's five videos already in

00:25:42.020 --> 00:25:42.590
the playlist.

00:25:42.590 --> 00:25:44.850
Do you want to know about those
five videos ahead of

00:25:44.850 --> 00:25:47.650
time in your application, and
that's going to help you later

00:25:47.650 --> 00:25:51.610
on when your processing the
exists notifications.

00:25:51.610 --> 00:25:54.050
So we call playlistItems.list.

00:25:54.050 --> 00:25:56.970
And what I'm going to do is just
make use of the memcache

00:25:56.970 --> 00:26:01.270
instance within App Engine and
store the list of current

00:26:01.270 --> 00:26:03.160
videos there.

00:26:03.160 --> 00:26:05.590
I'm going to be using the
channel ID as a key.

00:26:05.590 --> 00:26:11.450
So this just lets me know what
the base starting state is.

00:26:11.450 --> 00:26:14.470
And now let's talk about what
happens during exists.

00:26:14.470 --> 00:26:18.470
So, again, YouTube API is
contacting my App Engine.

00:26:18.470 --> 00:26:21.600
It's hitting a URL that I've
defined during in the

00:26:21.600 --> 00:26:23.320
registration.

00:26:23.320 --> 00:26:25.110
And it says that this
is an exists.

00:26:25.110 --> 00:26:27.670
So, again, I'm going to call
playlistItems.list.

00:26:27.670 --> 00:26:29.520
In this particular case, I'm
going to make two different

00:26:29.520 --> 00:26:30.730
types of memcache calls.

00:26:30.730 --> 00:26:32.910
I want to first retrieve the
previous state of the

00:26:32.910 --> 00:26:36.030
playlist, because I'm going to
be using that to calculate the

00:26:36.030 --> 00:26:37.990
delta and figure out
what's changed.

00:26:37.990 --> 00:26:43.280
I also want to save the new
state within memcache, just so

00:26:43.280 --> 00:26:46.660
the next notification I get, I
could go based on this state.

00:26:46.660 --> 00:26:47.950
So two different things
going on.

00:26:47.950 --> 00:26:49.620
And we'll cover that soon.

00:26:49.620 --> 00:26:52.800
And assuming something is new in
the playlist, assuming the

00:26:52.800 --> 00:26:56.360
delta didn't turn up empty, I'm
going to use the channel

00:26:56.360 --> 00:26:58.940
API to push down notification
to Chrome.

00:26:58.940 --> 00:27:01.790
And then I end up using an
iframe embed within Chrome to

00:27:01.790 --> 00:27:03.840
play back that video.

00:27:03.840 --> 00:27:08.060
So let's take a little bit of a
dive into the code for that.

00:27:08.060 --> 00:27:09.870
I'm getting the playlist
ID from that

00:27:09.870 --> 00:27:11.500
X-Goog-Channel-Token header.

00:27:11.500 --> 00:27:13.690
So I know which playlist I'm
talking about when I get an

00:27:13.690 --> 00:27:15.890
incoming notification.

00:27:15.890 --> 00:27:20.620
And I'm just creating this empty
set of initial videos.

00:27:20.620 --> 00:27:24.120
So I want to populate that with
information about the

00:27:24.120 --> 00:27:26.440
current state of the playlist
by making a

00:27:26.440 --> 00:27:29.820
youtube.playlistItems.list
call, part of the Python

00:27:29.820 --> 00:27:31.060
client library.

00:27:31.060 --> 00:27:33.740
And I'm going to say part
snippet and get

00:27:33.740 --> 00:27:34.810
some general metadata.

00:27:34.810 --> 00:27:38.320
And the most I could get at
one time is 50 videos.

00:27:38.320 --> 00:27:40.470
So maxResults equals 50.

00:27:40.470 --> 00:27:44.310
But we do have some ways of
working around the fact that

00:27:44.310 --> 00:27:47.140
there might be more than 50
videos in the playlist.

00:27:47.140 --> 00:27:50.060
And that's by looping through
the request and using the nice

00:27:50.060 --> 00:27:53.030
native methods in the Python
client library for paging

00:27:53.030 --> 00:27:54.410
through a set of results.

00:27:54.410 --> 00:27:56.630
So I'm going to end up going
through a loop while the

00:27:56.630 --> 00:27:59.530
request is something
that's true.

00:27:59.530 --> 00:28:01.990
I'm going to make the request.

00:28:01.990 --> 00:28:04.440
I'm going to take a look at
each item in the request.

00:28:04.440 --> 00:28:07.550
I'm going to grab the video
ID, put it in my set.

00:28:07.550 --> 00:28:11.520
And then I'm going to call
list_next, which is the way of

00:28:11.520 --> 00:28:13.430
handling paging in the Python
client library.

00:28:13.430 --> 00:28:15.300
So this will keep going
until we run out of

00:28:15.300 --> 00:28:17.630
items in the video.

00:28:17.630 --> 00:28:22.620
And now that I've retrieved
the current state of the

00:28:22.620 --> 00:28:25.430
playlist, I want to get the
channel ID, which I'm going to

00:28:25.430 --> 00:28:27.380
use for my memcache lookups.

00:28:27.380 --> 00:28:29.970
I get that from their
request header.

00:28:29.970 --> 00:28:31.980
And I'm going to take two
different actions, depending

00:28:31.980 --> 00:28:33.940
upon whether this is a
sync or whether this

00:28:33.940 --> 00:28:35.340
as an exists action.

00:28:35.340 --> 00:28:38.720
So if it happens to be a sync,
what I'm going to be doing is

00:28:38.720 --> 00:28:42.130
just storing the current state
of the playlist in memcache

00:28:42.130 --> 00:28:43.980
using the channel
ID as the key.

00:28:43.980 --> 00:28:45.660
And if it's an exists,
I want to do

00:28:45.660 --> 00:28:46.960
something slightly different.

00:28:46.960 --> 00:28:49.860
I'm going to look up the
previous states.

00:28:49.860 --> 00:28:52.620
I'm going to then set
the current state.

00:28:52.620 --> 00:28:56.590
And I'm going to make use of
Python's nice set operations

00:28:56.590 --> 00:29:00.120
to calculate what's new
in the current that

00:29:00.120 --> 00:29:01.690
wasn't in the previous.

00:29:01.690 --> 00:29:06.220
Assuming something is new, I'm
going to basically make the

00:29:06.220 --> 00:29:09.430
appropriate Python App Engine
calls to use the channel API

00:29:09.430 --> 00:29:13.490
and tell Chrome, hey,
something changed.

00:29:13.490 --> 00:29:17.410
So that's a walk through of
how that works, and hand

00:29:17.410 --> 00:29:19.240
things over to Yaniv
to talk about how a

00:29:19.240 --> 00:29:20.770
client library is used.

00:29:20.770 --> 00:29:21.310
YANIV INBAR: Great, Jeff.

00:29:21.310 --> 00:29:23.970
That's a really great example
of using the Python client

00:29:23.970 --> 00:29:25.050
library in action.

00:29:25.050 --> 00:29:27.080
And I just wanted to let you
know I'm actually the leader

00:29:27.080 --> 00:29:30.950
of a team of engineers that
develops open source client

00:29:30.950 --> 00:29:33.890
libraries to make accessing
Google APIs easy.

00:29:33.890 --> 00:29:35.980
And that was a demonstration of
the Python client library.

00:29:35.980 --> 00:29:40.380
We actually also have Java and
Objective-C supported--

00:29:40.380 --> 00:29:42.250
Java including Android.

00:29:42.250 --> 00:29:44.200
And if you've seen the previous
session here in this

00:29:44.200 --> 00:29:48.820
room on best practices for
accessing YouTube on mobile

00:29:48.820 --> 00:29:51.940
devices, you've seen the Java
and Objective-C client

00:29:51.940 --> 00:29:53.010
libraries in action.

00:29:53.010 --> 00:29:56.520
We actually have a variety of
open source client libraries

00:29:56.520 --> 00:30:00.930
as well that are in beta that
we're developing for .NET, for

00:30:00.930 --> 00:30:03.020
JavaScript, for PHP.

00:30:03.020 --> 00:30:06.290
And just to make sure we try to
capture as many languages

00:30:06.290 --> 00:30:09.160
on as many platforms as
possible, we actually have, in

00:30:09.160 --> 00:30:12.430
early stages of alpha
development, libraries in Go,

00:30:12.430 --> 00:30:16.020
Dart, Node.js, Ruby, and
Google Web Toolkit.

00:30:16.020 --> 00:30:17.920
So I'd encourage you, if you're
going to build this in

00:30:17.920 --> 00:30:20.640
practice, to use our client
libraries, and that will

00:30:20.640 --> 00:30:24.750
automatically let you use
the best practices.

00:30:24.750 --> 00:30:27.980
So, we're going to move
on to questions now.

00:30:27.980 --> 00:30:29.020
Thank you very much
for attending.

00:30:29.020 --> 00:30:31.800
If you have questions, please
go up to microphones.

00:30:31.800 --> 00:30:34.680
JEFFREY POSNICK: Yeah, I'll warn
folks, we have really bad

00:30:34.680 --> 00:30:37.180
push and polling jokes that
we're going to start talking

00:30:37.180 --> 00:30:38.250
about if people don't
ask questions.

00:30:38.250 --> 00:30:40.990
So please come up and
spare everybody.

00:30:40.990 --> 00:30:42.090
So go right ahead.

00:30:42.090 --> 00:30:43.090
YANIV INBAR: Actually, if
you're interested in the

00:30:43.090 --> 00:30:46.020
slides, by the way, there's
a link there where they're

00:30:46.020 --> 00:30:47.560
actually publicly viewable.

00:30:47.560 --> 00:30:50.595
And, as well as you want to
follow us on Google+ where you

00:30:50.595 --> 00:30:55.150
can get more information and
followups, such as the sample

00:30:55.150 --> 00:30:56.472
that Jeff built.

00:30:56.472 --> 00:30:56.840
JEFFREY POSNICK:
Go right ahead.

00:30:56.840 --> 00:30:58.740
AUDIENCE: So I'm
with Machinima.

00:30:58.740 --> 00:31:02.060
We're a multi-channel network.

00:31:02.060 --> 00:31:04.900
Can I get a push notification
anytime somebody who's an

00:31:04.900 --> 00:31:08.720
affiliate uploads a video or
changes content on their page?

00:31:08.720 --> 00:31:10.180
On their channel, sorry.

00:31:10.180 --> 00:31:10.760
JEFFREY POSNICK: Yeah.

00:31:10.760 --> 00:31:14.180
So right now what we have built
in time for Google I/O

00:31:14.180 --> 00:31:17.840
is push notification support
for playlist items.

00:31:17.840 --> 00:31:21.660
Definitely, video uploads, which
would be like taking a

00:31:21.660 --> 00:31:27.990
look at playlist items for a
specific ID, like the uploads

00:31:27.990 --> 00:31:31.110
list, that is something that's
very much on the radar.

00:31:31.110 --> 00:31:32.160
We want to support that, too.

00:31:32.160 --> 00:31:34.215
AUDIENCE: When a video's
uploaded, it doesn't go into

00:31:34.215 --> 00:31:35.610
any default playlist, right?

00:31:35.610 --> 00:31:36.280
It's just uploaded.

00:31:36.280 --> 00:31:40.150
JEFFREY POSNICK: Yeah, so we
kind of treat it as if it were

00:31:40.150 --> 00:31:43.250
uploaded to playlist
with a special ID.

00:31:43.250 --> 00:31:44.070
It's going to be supported
shortly.

00:31:44.070 --> 00:31:48.190
AUDIENCE: What I mean, it's
not known ahead of time.

00:31:48.190 --> 00:31:51.380
There's no default playlist,
quote, unquote.

00:31:51.380 --> 00:31:53.340
JEFFREY POSNICK: It's a little
strange, but we do treat it as

00:31:53.340 --> 00:31:55.380
if it were uploaded
to a playlist that

00:31:55.380 --> 00:31:57.080
has a special ID.

00:31:57.080 --> 00:31:59.900
So it will be possible to follow
the same method to

00:31:59.900 --> 00:32:01.680
subscribe to new uploads.

00:32:01.680 --> 00:32:03.180
AUDIENCE: No, I mean, is
that a known ID, when

00:32:03.180 --> 00:32:03.925
you say it's a default?

00:32:03.925 --> 00:32:04.200
JEFFREY POSNICK: Mm-hmm.

00:32:04.200 --> 00:32:06.360
AUDIENCE: Oh, so that every
channel out there has that

00:32:06.360 --> 00:32:07.100
default ID.

00:32:07.100 --> 00:32:11.000
So like default ID 0 is the ID
where things are uploaded.

00:32:11.000 --> 00:32:11.916
JEFFREY POSNICK: Yeah, it's
like channel.contentd

00:32:11.916 --> 00:32:13.166
etails.relatedpl
aylists.uploads.

00:32:15.380 --> 00:32:19.060
AUDIENCE: So right now, so what
you just said would work

00:32:19.060 --> 00:32:20.970
for tracking new
video uploads.

00:32:20.970 --> 00:32:23.510
JEFFREY POSNICK: This will
work shortly for that

00:32:23.510 --> 00:32:24.380
scenario, yes.

00:32:24.380 --> 00:32:26.660
Not as of right now, but yes.

00:32:26.660 --> 00:32:28.750
It will soon.

00:32:28.750 --> 00:32:30.200
And that's a perfect use case.

00:32:30.200 --> 00:32:32.270
We want people to be
able to do that.

00:32:32.270 --> 00:32:32.760
AUDIENCE: Right.

00:32:32.760 --> 00:32:33.250
OK.

00:32:33.250 --> 00:32:35.720
Thanks.

00:32:35.720 --> 00:32:37.030
AUDIENCE: Hey, guys.

00:32:37.030 --> 00:32:38.920
That's actually really handy.

00:32:38.920 --> 00:32:40.830
Thanks.

00:32:40.830 --> 00:32:45.190
What I want to know is, when
you send back the exists

00:32:45.190 --> 00:32:49.340
response or the exists post
request, do you have plans to

00:32:49.340 --> 00:32:53.460
put in the delta or the current
state of what you have

00:32:53.460 --> 00:32:58.880
rather than me going back out to
get something from the API?

00:32:58.880 --> 00:33:01.340
JEFFREY POSNICK: So it varies
from API to API.

00:33:01.340 --> 00:33:03.530
Yaniv, you know a little bit
more about what cloud storage

00:33:03.530 --> 00:33:03.580
is doing right now.

00:33:03.580 --> 00:33:05.200
AUDIENCE: Like if I define
the resource

00:33:05.200 --> 00:33:09.870
type of what I'm tracking?

00:33:09.870 --> 00:33:11.090
YANIV INBAR: To repeat the
question, it's a great

00:33:11.090 --> 00:33:16.110
question, do we have plans to
add more information when you

00:33:16.110 --> 00:33:18.900
do receive an exists
notification about exactly

00:33:18.900 --> 00:33:20.530
what has changed the delta.

00:33:20.530 --> 00:33:21.880
It's actually a great
question.

00:33:21.880 --> 00:33:23.900
So the Google Cloud Storage
API actually

00:33:23.900 --> 00:33:25.390
does implement this.

00:33:25.390 --> 00:33:28.530
The JSON content includes a URL
where you can literally

00:33:28.530 --> 00:33:33.340
receive a feed of what
has changed for your

00:33:33.340 --> 00:33:36.060
notification channel.

00:33:36.060 --> 00:33:37.530
JEFFREY POSNICK: So for YouTube
APIs, I think what

00:33:37.530 --> 00:33:39.960
we're demonstrating today is
not really going to be the

00:33:39.960 --> 00:33:42.530
final version.

00:33:42.530 --> 00:33:44.830
I can't promise that there is
going to be adjacent payload

00:33:44.830 --> 00:33:46.080
with the delta.

00:33:46.080 --> 00:33:49.480
It's an obvious case that
it would be useful.

00:33:49.480 --> 00:33:51.690
We'll see what ends up
being implemented.

00:33:51.690 --> 00:33:52.990
YANIV INBAR: We appreciate
the feedback.

00:33:52.990 --> 00:33:55.690
And we'll take that in to
future development.

00:33:55.690 --> 00:33:57.915
We really think of this
as the start.

00:33:57.915 --> 00:33:59.040
AUDIENCE: Hi, there.

00:33:59.040 --> 00:34:00.945
So just to get a little bit
of clarification on

00:34:00.945 --> 00:34:02.110
the guy from Machinima.

00:34:02.110 --> 00:34:07.310
So you can subscribe to events
from other people that aren't

00:34:07.310 --> 00:34:09.610
necessarily owned by
your entity, right?

00:34:09.610 --> 00:34:11.179
So I could subscribe
to your channel?

00:34:11.179 --> 00:34:11.810
OK.

00:34:11.810 --> 00:34:12.119
JEFFREY POSNICK: Yeah.

00:34:12.119 --> 00:34:13.780
You can.

00:34:13.780 --> 00:34:15.800
AUDIENCE: So is there a limit
on how many things I can

00:34:15.800 --> 00:34:16.739
subscribe to?

00:34:16.739 --> 00:34:18.850
And is there going to be
any sort of API quota

00:34:18.850 --> 00:34:20.280
stuff around that?

00:34:20.280 --> 00:34:21.840
JEFFREY POSNICK: I'm
sure there will be.

00:34:21.840 --> 00:34:24.070
There are quotas associated
with making

00:34:24.070 --> 00:34:25.600
that initial watch.

00:34:25.600 --> 00:34:29.780
I mean, if you compare the quota
consumed by making a

00:34:29.780 --> 00:34:32.020
watch or refreshing a watch
every hour, because it does

00:34:32.020 --> 00:34:34.780
expire after an hour, versus
polling every minute, you're

00:34:34.780 --> 00:34:36.260
going to come out ahead
by doing this.

00:34:36.260 --> 00:34:40.550
So just to clarify that larger
question, so it does ask me

00:34:40.550 --> 00:34:44.590
for OAuth 2 credentials before I
could create a subscription.

00:34:44.590 --> 00:34:47.330
But I do not necessarily
need to subscribe to

00:34:47.330 --> 00:34:49.620
something that I own.

00:34:49.620 --> 00:34:53.210
So the OAuth 2 credentials
identify me, but I might want

00:34:53.210 --> 00:34:56.500
to subscribe to the uploads
for Google Developers or

00:34:56.500 --> 00:34:59.100
playlists like Google Developer
Zone or any other

00:34:59.100 --> 00:35:01.020
channel that's out there.

00:35:01.020 --> 00:35:02.010
That is possible.

00:35:02.010 --> 00:35:02.520
That's supported.

00:35:02.520 --> 00:35:02.893
AUDIENCE: OK.

00:35:02.893 --> 00:35:03.640
Thank you.

00:35:03.640 --> 00:35:06.620
YANIV INBAR: There's actually
one important point that we

00:35:06.620 --> 00:35:11.330
didn't have time to go into,
which is if you're watching

00:35:11.330 --> 00:35:14.710
for changes in a playlist that's
public, that's not

00:35:14.710 --> 00:35:19.260
actually only accessible by
single user, you don't

00:35:19.260 --> 00:35:21.070
necessarily need to ask for
consent from the user.

00:35:21.070 --> 00:35:24.300
But the way that you do
that is a bit complex.

00:35:24.300 --> 00:35:26.630
But we'll be able to follow up
with you later if you're

00:35:26.630 --> 00:35:28.030
interested in that.

00:35:28.030 --> 00:35:30.540
AUDIENCE: And just to clarify,
this isn't for comments or any

00:35:30.540 --> 00:35:33.330
other data aside from
video playlists?

00:35:33.330 --> 00:35:36.210
JEFFREY POSNICK: So this is
built on top of the YouTube

00:35:36.210 --> 00:35:39.110
Data API version 3, what we're
talking about with YouTube.

00:35:39.110 --> 00:35:41.170
Obviously, there are other
APIs out there.

00:35:41.170 --> 00:35:46.210
So what's fair game to
eventually support this is

00:35:46.210 --> 00:35:49.110
anything that the YouTube
Data API V3 supports.

00:35:49.110 --> 00:35:51.510
We can't commit right now
to every single type of

00:35:51.510 --> 00:35:55.010
collection will support it, but
things like the uploads

00:35:55.010 --> 00:35:56.790
playlist, that's obvious.

00:35:56.790 --> 00:35:58.600
I'm really hoping that we'll
soon have support for the

00:35:58.600 --> 00:36:02.020
activities, or if you're
subscriptions, when a new

00:36:02.020 --> 00:36:05.240
video is uploaded into a channel
you're subscribed to,

00:36:05.240 --> 00:36:06.870
that sort of thing.

00:36:06.870 --> 00:36:09.110
Right now, there isn't actually
support for comments

00:36:09.110 --> 00:36:13.330
in version 3 of the data API,
so we can't really offer any

00:36:13.330 --> 00:36:15.410
push notifications there.

00:36:15.410 --> 00:36:17.480
AUDIENCE: And what's the
timeline on what we just saw

00:36:17.480 --> 00:36:20.820
today versus what's going to
come down in the future?

00:36:20.820 --> 00:36:24.110
JEFFREY POSNICK: I don't have
a specific timeline.

00:36:24.110 --> 00:36:24.750
Yeah.

00:36:24.750 --> 00:36:26.270
It should be fairly soon.

00:36:26.270 --> 00:36:29.320
We scrambled a little bit to
get some working demos for

00:36:29.320 --> 00:36:31.580
Google I/O, and we're
really close.

00:36:31.580 --> 00:36:35.010
There are a couple remaining
engineering things that need

00:36:35.010 --> 00:36:35.890
to be taken care of.

00:36:35.890 --> 00:36:40.800
So, we'll post on our Plus
YouTube Dev Google+ page when

00:36:40.800 --> 00:36:44.890
things are available, and
we'll make it known.

00:36:44.890 --> 00:36:46.045
We'll push things out to you.

00:36:46.045 --> 00:36:47.160
You do not need to poll us.

00:36:47.160 --> 00:36:48.680
Basically, don't poll us.

00:36:48.680 --> 00:36:50.175
Don't email us every day.

00:36:50.175 --> 00:36:51.280
We'll let you know.

00:36:51.280 --> 00:36:52.560
YANIV INBAR: In terms of
timeline, I just wanted to

00:36:52.560 --> 00:36:55.640
make one other note, which is
the Google Cloud Storage APIs

00:36:55.640 --> 00:36:57.690
all have released availability
for push

00:36:57.690 --> 00:36:59.460
notifications with their API.

00:36:59.460 --> 00:37:03.210
And the other point is I
mentioned registering the

00:37:03.210 --> 00:37:05.470
domain where you receive
notification endpoints, that

00:37:05.470 --> 00:37:08.040
hasn't launched yet,
but will very soon.

00:37:08.040 --> 00:37:09.580
And we wanted to tell you about
it because it'll become

00:37:09.580 --> 00:37:10.460
a requirement.

00:37:10.460 --> 00:37:13.050
So you're not surprised by
that when it comes up.

00:37:13.050 --> 00:37:13.390
AUDIENCE: Hey.

00:37:13.390 --> 00:37:16.760
This isn't necessarily
directed towards push

00:37:16.760 --> 00:37:20.440
notifications, but are you guys
planning to add comment

00:37:20.440 --> 00:37:25.490
functionality to the
V3 API for YouTube?

00:37:25.490 --> 00:37:27.080
JEFFREY POSNICK: There's not
really anything about that

00:37:27.080 --> 00:37:29.600
that I can announce right now.

00:37:29.600 --> 00:37:30.850
Sorry.

00:37:34.690 --> 00:37:36.420
AUDIENCE: So I think I have
a little bit of a silly

00:37:36.420 --> 00:37:38.780
question, but you said this
current push notification

00:37:38.780 --> 00:37:41.740
system is built on the
YouTube Data API.

00:37:41.740 --> 00:37:45.220
Is there any chance that it'll
eventually be supported in the

00:37:45.220 --> 00:37:47.550
YouTube Analytics API?

00:37:47.550 --> 00:37:47.920
JEFFREY POSNICK: Hopefuly.

00:37:47.920 --> 00:37:50.970
AUDIENCE: Like changes in
uploads or number of views, et

00:37:50.970 --> 00:37:51.930
cetera and so forth?

00:37:51.930 --> 00:37:53.620
JEFFREY POSNICK: So off camera,
we have Christoph, who

00:37:53.620 --> 00:37:56.480
is the lead engineer for
the Analytics API.

00:37:56.480 --> 00:37:56.920
I don't know.

00:37:56.920 --> 00:37:58.000
Christoph, what do you say?

00:37:58.000 --> 00:37:59.250
AUDIENCE: [INAUDIBLE].

00:38:02.340 --> 00:38:05.180
JEFFREY POSNICK: Yes, poll
Christoph every few hours

00:38:05.180 --> 00:38:08.250
asking him when it's ready.

00:38:08.250 --> 00:38:11.760
But the more serious response
to that is that the YouTube

00:38:11.760 --> 00:38:15.590
Analytics API is built on top
of this common Google API

00:38:15.590 --> 00:38:17.500
infrastructure, things
like cloud storage.

00:38:17.500 --> 00:38:20.220
So they all use the same
client libraries.

00:38:20.220 --> 00:38:23.460
This push notification support
was added on the Google API

00:38:23.460 --> 00:38:27.705
infrastructure layer, so
theoretically, as more and

00:38:27.705 --> 00:38:31.810
more APIs support it, you'll
be able to get this benefit

00:38:31.810 --> 00:38:34.390
from all sorts of different
services.

00:38:34.390 --> 00:38:35.680
YANIV INBAR: I love
the question.

00:38:35.680 --> 00:38:39.180
I'm happy to hear enthusiasm
about adding more

00:38:39.180 --> 00:38:41.710
functionality that uses the
push qualifications.

00:38:41.710 --> 00:38:44.720
AUDIENCE: Similar idea, but with
live events, especially

00:38:44.720 --> 00:38:47.630
like the start of a live event,
would be great to get

00:38:47.630 --> 00:38:48.130
notifications.

00:38:48.130 --> 00:38:49.950
I don't know if you can
tell us anything.

00:38:49.950 --> 00:38:52.000
JEFFREY POSNICK: I'm sorry--
oh, for live events?

00:38:52.000 --> 00:38:55.660
Yeah, that's, again, falls into
the same bucket of things

00:38:55.660 --> 00:38:57.180
that theoretically
should be done.

00:38:57.180 --> 00:39:00.240
So it's just a question of
making sure the right folks

00:39:00.240 --> 00:39:01.427
can prioritize that
highly enough.

00:39:01.427 --> 00:39:04.370
So, y Yeah.

00:39:04.370 --> 00:39:06.870
Looks like we're done
with live questions.

00:39:06.870 --> 00:39:07.700
We're about out of time.

00:39:07.700 --> 00:39:08.970
So thanks so much, everybody.

00:39:08.970 --> 00:39:11.330
YANIV INBAR: And please rate
our session, especially

00:39:11.330 --> 00:39:11.980
if you liked it.

00:39:11.980 --> 00:39:14.790
There's a code over there
you can use, or

00:39:14.790 --> 00:39:16.400
on your mobile device.

00:39:16.400 --> 00:39:18.300
JEFFREY POSNICK: Even if you
didn't like it, we appreciate

00:39:18.300 --> 00:39:18.590
all your feedback.

00:39:18.590 --> 00:39:20.430
YANIV INBAR: We want your
feedback, absolutely.

00:39:20.430 --> 00:39:21.710
If you didn't like
it, let us know.

00:39:21.710 --> 00:39:22.140
[APPLAUSE]

00:39:22.140 --> 00:39:23.000
JEFFREY POSNICK: Yes.

00:39:23.000 --> 00:39:24.250
Thanks, everybody.

