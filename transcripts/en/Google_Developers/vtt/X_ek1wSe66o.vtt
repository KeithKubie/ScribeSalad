WEBVTT
Kind: captions
Language: en

00:00:01.010 --> 00:00:02.010
&gt;&gt;Eric Bidelman: All right.

00:00:02.010 --> 00:00:03.010
Are we ready?

00:00:03.010 --> 00:00:04.010
Android is processing my photo.

00:00:04.010 --> 00:00:05.010
Hold on.

00:00:05.010 --> 00:00:06.010
All right.

00:00:06.010 --> 00:00:07.010
Guys, I really want to thank you for coming
to my session.

00:00:07.010 --> 00:00:08.010
This is The Web Can Do That, in case you've
misplaced what session you should be in.

00:00:08.010 --> 00:00:11.460
Apparently none of you want to get free Android
hardware downstairs, so I do really appreciate

00:00:11.460 --> 00:00:13.930
your time for the next hour.

00:00:13.930 --> 00:00:17.820
This is going to be adventures into HTML5.

00:00:17.820 --> 00:00:20.730
Just so you know who you're talking to up
here, my name is Eric Bidelman and I work

00:00:20.730 --> 00:00:23.310
on the Google Chrome team.

00:00:23.310 --> 00:00:30.420
I'm an advocate for Chrome team, I teach developers
HTML5, help them use it by writing tutorials.

00:00:30.420 --> 00:00:35.649
Of course, if you want to contact me there's
Google+, there's the Twitter and there's also

00:00:35.649 --> 00:00:39.249
a blog that I don't write to very often, but
it does have some interesting things I think

00:00:39.249 --> 00:00:40.249
on it.

00:00:40.249 --> 00:00:43.600
So that's who is up on stage.

00:00:43.600 --> 00:00:45.329
I get this a lot.

00:00:45.329 --> 00:00:51.289
People are really skeptical about HTML5 still
and so they don't know what's possible.

00:00:51.289 --> 00:00:55.710
And so part of my job is to come up here and
teach you guys and you too, the folks at home,

00:00:55.710 --> 00:00:57.370
what is possible on the Web.

00:00:57.370 --> 00:01:02.039
So today's talk is that the agenda is there's
going to be no agenda whatsoever.

00:01:02.039 --> 00:01:06.870
So I'm going to sort of highlight really cool,
interesting use cases that HTML5 can now solve

00:01:06.870 --> 00:01:09.920
that you probably didn't know were possible
on the Web today.

00:01:09.920 --> 00:01:17.340
Things that you probably need to build a real
world application on the Web.

00:01:17.340 --> 00:01:19.270
So a little bit of convention about this slide
deck.

00:01:19.270 --> 00:01:20.740
This is a living, breathing slide deck.

00:01:20.740 --> 00:01:22.560
I'm doing something a little bit different
with this.

00:01:22.560 --> 00:01:27.150
You will see in the top right corner there's
a legend and there's a radar, and that signifies

00:01:27.150 --> 00:01:28.730
that stuff is on the radar.

00:01:28.730 --> 00:01:32.600
Keep it on your radar, it's still pretty new,
it's changing quickly.

00:01:32.600 --> 00:01:38.110
I can actually make CORs requests, cross origin
resource requests, [indiscernible] XHRs, to

00:01:38.110 --> 00:01:39.960
the WebKit issue tractor, which is really
nice.

00:01:39.960 --> 00:01:44.040
So as soon as a bug is fixed, I know it's
fixed, I can mark them, denote it with this

00:01:44.040 --> 00:01:45.590
little bug guy as it gets crossed off.

00:01:45.590 --> 00:01:48.820
So you kind of know when you go back to this
slide at greater@html5.com.

00:01:48.820 --> 00:01:51.560
It's not up right now.

00:01:51.560 --> 00:01:53.120
I'll post it after the slides.

00:01:53.120 --> 00:01:57.770
But there are spec links and you know the
stuff is up to date.

00:01:57.770 --> 00:01:58.770
Okay.

00:01:58.770 --> 00:02:03.810
So without further adieu let's jump into the
number one main awesome, sweet thing that

00:02:03.810 --> 00:02:04.810
the Web can do.

00:02:04.810 --> 00:02:06.700
The first is that we have CSS for Web apps.

00:02:06.700 --> 00:02:09.959
And you're probably like whoa -- yeah, Mythbuster
style.

00:02:09.959 --> 00:02:13.569
You're probably like, whoa, Eric, we've had
CSS for a long time.

00:02:13.569 --> 00:02:14.569
What's up with that?

00:02:14.569 --> 00:02:15.569
Well, we have.

00:02:15.569 --> 00:02:16.939
We had a lot of great stuff in CSS.

00:02:16.939 --> 00:02:20.760
We have floats and absolute positioning and
tables and all this stuff kind of working

00:02:20.760 --> 00:02:21.900
together.

00:02:21.900 --> 00:02:25.920
The real problem with that is it was all designed
in times of websites, not Web apps.

00:02:25.920 --> 00:02:31.400
So if you want to do complex Web layout it's
really, really hard until now.

00:02:31.400 --> 00:02:36.799
So I'm calling 2012 sort of the rise of CSS
for Web apps, and that's because the working

00:02:36.799 --> 00:02:40.840
groups have proposed a number, a slew of new
stuff that we can play with eventually as

00:02:40.840 --> 00:02:42.700
Web developers.

00:02:42.700 --> 00:02:47.459
Regions for things like flowing and magazine
type layout and design.

00:02:47.459 --> 00:02:50.260
Flexbox layout, which I will talk about, it's
one of my particular favorites, being able

00:02:50.260 --> 00:02:54.279
to easily position things on the page in a
flexible manner.

00:02:54.279 --> 00:02:58.170
Grid layouts and hierarchies in ASCII and
CSS so you can define where things show up

00:02:58.170 --> 00:02:59.310
on a page.

00:02:59.310 --> 00:03:00.310
It makes sense.

00:03:00.310 --> 00:03:04.650
If you're building something on top of CSS
you need engines and different mechanisms

00:03:04.650 --> 00:03:06.739
to do that for Web apps.

00:03:06.739 --> 00:03:09.769
And then there's the bells and whistles, there's
the hierarchies, there's the folders and effects

00:03:09.769 --> 00:03:13.090
and other really cool stuff coming down the
pipeline.

00:03:13.090 --> 00:03:14.090
CSS variables.

00:03:14.090 --> 00:03:18.450
If you guys attended the Web component session
earlier, that stuff is finally coming to CSS.

00:03:18.450 --> 00:03:20.549
You can finally use variables in CSS.

00:03:20.549 --> 00:03:24.499
It's not that exciting, but it's super exciting
as a Web developer that you don't have to

00:03:24.499 --> 00:03:28.930
use a Web processor anymore.

00:03:28.930 --> 00:03:32.840
So why am I picking on Flexbox out of all
this new stuff?

00:03:32.840 --> 00:03:37.739
Flexbox is really great for Web layout design
and it's really going to solve and is solving

00:03:37.739 --> 00:03:40.480
the sort of common use cases of a Web app.

00:03:40.480 --> 00:03:46.110
So that Holy Grail layout, that header, that
footer, that three-column tiered system, very

00:03:46.110 --> 00:03:49.510
hard to do with, notoriously hard to do with
CSS today.

00:03:49.510 --> 00:03:51.250
Very easy with Flexbox.

00:03:51.250 --> 00:03:55.709
And so the way Flexbox works is that there's
a new display property.

00:03:55.709 --> 00:03:59.980
So I can tell a container to be a Flexbox
container and I'm doing also something in

00:03:59.980 --> 00:04:02.659
this slide deck, nobody is going to catch
me on vendor prefixes.

00:04:02.659 --> 00:04:08.340
I'm using sort of a compile type syntax, a
mix-in syntax to denote that any time you

00:04:08.340 --> 00:04:12.810
see a + for CSS that means vendor prefixes
are involved.

00:04:12.810 --> 00:04:18.320
I can tell, for instance, this right container
to be a Flexbox container with display vendor

00:04:18.320 --> 00:04:19.640
prefix flex.

00:04:19.640 --> 00:04:23.670
And we can do things like center content horizontally
and vertically super easy.

00:04:23.670 --> 00:04:25.510
With three lines of CSS we can do this now.

00:04:25.510 --> 00:04:28.920
We don't have to use negative margins or JavaScript.

00:04:28.920 --> 00:04:32.420
So along my main access here -- this is a
little bit of Flexbox terminology.

00:04:32.420 --> 00:04:37.870
In my cross origin access, I can justify content
to the center, I can flex it to the start,

00:04:37.870 --> 00:04:40.120
I can say everything be adjusted far to the
right.

00:04:40.120 --> 00:04:44.750
And I can also align those items in that cross
access, so I can align items to the center,

00:04:44.750 --> 00:04:47.090
I can allow them to the bottom.

00:04:47.090 --> 00:04:51.000
I can do things like stretch to take up the
available content of your parent container.

00:04:51.000 --> 00:04:53.340
Very, very handy with layout.

00:04:53.340 --> 00:04:57.400
And I can do also things like distribute yourself
evenly in a container.

00:04:57.400 --> 00:05:06.030
Take up the available space and put an even
distribution of white space around yourself.

00:05:06.030 --> 00:05:09.820
Another cool thing about Flexbox is that it
completely takes away the sort of mapping

00:05:09.820 --> 00:05:12.870
of your source to how things are rendered
on the page.

00:05:12.870 --> 00:05:17.460
So typically what happens is that you define
your A, your B and your C div.

00:05:17.460 --> 00:05:20.950
These are just three divs inside of this flex
container.

00:05:20.950 --> 00:05:22.220
And that's how I've weighted out my markups,
right?

00:05:22.220 --> 00:05:23.720
I have an A, B and C in my markup.

00:05:23.720 --> 00:05:27.880
But maybe I don't want to render A, B and
C in that order, and I can do that through

00:05:27.880 --> 00:05:29.390
different properties of Flexbox.

00:05:29.390 --> 00:05:32.930
I have this flex direction property, so again
vendor prefix.

00:05:32.930 --> 00:05:37.310
So right now we're flexing in a row, but I
can choose to change the order of that row.

00:05:37.310 --> 00:05:40.740
I can reverse the order of the row using row
reverse.

00:05:40.740 --> 00:05:45.431
I can tell these items to be in a column so
A, B and C are not in a row now, but they

00:05:45.431 --> 00:05:48.470
can be rendered in a column.

00:05:48.470 --> 00:05:52.180
And then using the order property I can sort
of change the order depending on what value

00:05:52.180 --> 00:05:53.180
I set here.

00:05:53.180 --> 00:05:57.070
So by default these are all the same order
as they're laid out in markup, but I can tell

00:05:57.070 --> 00:06:02.870
the second div to come before A. So this is
independent of how I've got my markup out,

00:06:02.870 --> 00:06:06.950
just rendering it different next to the page
using the orientation and direction properties

00:06:06.950 --> 00:06:09.420
of Flexbox.

00:06:09.420 --> 00:06:13.120
I can also tell it to come after everything
as well.

00:06:13.120 --> 00:06:18.030
But another really cool thing that Flexbox
solves is sort of this type of use case where

00:06:18.030 --> 00:06:19.100
you have the same height columns.

00:06:19.100 --> 00:06:24.400
So in order to do same height columns -- this
is a great example of floating three divs

00:06:24.400 --> 00:06:25.400
across the page.

00:06:25.400 --> 00:06:30.240
But if I want to do something like make these
even, right, I have a really awesome UI, I

00:06:30.240 --> 00:06:34.030
can do that with a little bit of JavaScript
where I can set these and get the computed

00:06:34.030 --> 00:06:38.340
style of the content and know exactly how
tall they should be.

00:06:38.340 --> 00:06:43.620
But what happens if my UI is being rendered
through JSON, I'm porting in an RSS feed or

00:06:43.620 --> 00:06:46.750
something, and -- my content is dynamic.

00:06:46.750 --> 00:06:50.880
As soon as that happens, I put a little bit
more content, my columns are now out of sync,

00:06:50.880 --> 00:06:54.950
I have to recalculate, I have to touch JavaScript,
I have to set properties in CSS.

00:06:54.950 --> 00:06:58.980
It just feels super, super icky.

00:06:58.980 --> 00:07:02.570
So the way Flexbox solves that is through
its bread and butter, flexibility.

00:07:02.570 --> 00:07:04.370
So it's really nice.

00:07:04.370 --> 00:07:08.680
I can tell things to take up the available
amount of the parent container.

00:07:08.680 --> 00:07:13.640
In this case all of these items, A, B, and
C, are equally distributed in the Flexbox

00:07:13.640 --> 00:07:14.990
container.

00:07:14.990 --> 00:07:15.990
But I don't have to do that.

00:07:15.990 --> 00:07:20.430
I can tell the second difference to be two
times greater, grow to be two times as big

00:07:20.430 --> 00:07:23.920
as your siblings or three times as big or
four times as big.

00:07:23.920 --> 00:07:25.900
I can also tell it to shrink.

00:07:25.900 --> 00:07:30.800
So A and C will be equal size with a flex
property of one and then B is going to be

00:07:30.800 --> 00:07:33.080
a negative flex property.

00:07:33.080 --> 00:07:35.900
So it's really handy when it comes to that
Holy Grail layout.

00:07:35.900 --> 00:07:38.160
So I want to show you an example of this.

00:07:38.160 --> 00:07:39.540
This is a live page.

00:07:39.540 --> 00:07:44.830
Think of this as that Holy Grail layout, that
header, footer, that three column in the center.

00:07:44.830 --> 00:07:48.460
The first thing you will notice is this whole
thing, maybe not the resolution, but the whole

00:07:48.460 --> 00:07:53.150
thing is centered vertically and horizontally
in my page with three lines of CSS, right,

00:07:53.150 --> 00:07:55.190
the alignment and justification there.

00:07:55.190 --> 00:08:00.310
Next thing to happen on this page is a really
sweet navigation bar.

00:08:00.310 --> 00:08:04.680
You will notice that that last button up there
has more content than the rest of my buttons,

00:08:04.680 --> 00:08:05.940
but that's okay.

00:08:05.940 --> 00:08:09.210
We can tell the Flexbox items to grow and
shrink.

00:08:09.210 --> 00:08:11.160
So all my buttons are exactly the same size.

00:08:11.160 --> 00:08:15.760
I didn't set anything in CSS, particularly
the widths of those buttons, it's just flexing

00:08:15.760 --> 00:08:18.300
to take up the available space of that complete
Web app.

00:08:18.300 --> 00:08:23.320
But if I add more, all of these buttons will
continue to flex and be of equal weight and

00:08:23.320 --> 00:08:24.360
size and distributed evenly.

00:08:24.360 --> 00:08:27.940
It's great for navigation, it's great for
UI.

00:08:27.940 --> 00:08:33.790
We can also use some CSS transitions on the
flex property so I can do really cool UI flex

00:08:33.790 --> 00:08:38.640
here, little zippies here, so these are just
Flexbox items within a Flexbox container with

00:08:38.640 --> 00:08:40.740
the column orientation.

00:08:40.740 --> 00:08:44.204
And with the CSS hover I can tell them to
grow with the flex property to grow to be

00:08:44.204 --> 00:08:47.890
two times or three times greater than rest.

00:08:47.890 --> 00:08:52.320
My center content in the center of the article
content I can use transforms to do things

00:08:52.320 --> 00:08:55.010
with vertical alignment there on the side,
my navigation on my side.

00:08:55.010 --> 00:09:01.800
If I wanted to I could combine the media queries,
and you remember I could independently order

00:09:01.800 --> 00:09:04.210
my source and how things are presented using
that order property.

00:09:04.210 --> 00:09:07.710
So that combined media source may be in my
mobile UI.

00:09:07.710 --> 00:09:09.990
I have something that is different.

00:09:09.990 --> 00:09:15.040
If I scale this down to mobile UI, notice
in the case of my desktop, the article is

00:09:15.040 --> 00:09:16.040
in the center.

00:09:16.040 --> 00:09:20.150
That's my main content, that's what users
should be seeing, but when I scale on to mobile

00:09:20.150 --> 00:09:23.800
maybe the articles should come before that
navigation element, that zippy on the side.

00:09:23.800 --> 00:09:32.370
So I can do that with that ordering orientation
property, very handy when combined with media

00:09:32.370 --> 00:09:36.370
queries.

00:09:36.370 --> 00:09:37.370
So that's CSS Flexbox.

00:09:37.370 --> 00:09:38.750
And that's the new one.

00:09:38.750 --> 00:09:42.650
There is an older Flexbox if you've been following
this stuff closely.

00:09:42.650 --> 00:09:44.880
That's actually available in a number of browsers
right now.

00:09:44.880 --> 00:09:45.880
So WebKit, Chrome.

00:09:45.880 --> 00:09:47.350
IE 10 will have the new Flexbox as well.

00:09:47.350 --> 00:09:50.590
So you can expect to use this relatively soon.

00:09:50.590 --> 00:09:52.780
All right.

00:09:52.780 --> 00:09:54.840
Number two amazing thing is dynamic CSS.

00:09:54.840 --> 00:09:59.230
By dynamic CSS I actually mean -- that was
confirmed too.

00:09:59.230 --> 00:10:01.580
I actually mean the calc function.

00:10:01.580 --> 00:10:05.500
If you attended the session earlier today
on Web components, they have CSS variables

00:10:05.500 --> 00:10:06.500
coming.

00:10:06.500 --> 00:10:10.080
But we actually have the ability to do similar
things now with the calc function.

00:10:10.080 --> 00:10:14.530
It's been around in Firefox for a long time,
just came to WebKit very recently.

00:10:14.530 --> 00:10:18.880
What I have here is a live example of something
that's in the Flexbox specification.

00:10:18.880 --> 00:10:21.220
So I basically have a bunch of divs.

00:10:21.220 --> 00:10:27.150
I have a div within a div within a div, and
I put a border radius of 50% on this div,

00:10:27.150 --> 00:10:29.800
so that's what's creating the circles.

00:10:29.800 --> 00:10:34.840
I've specified the parent circle container
to be 300 wide and 300 tall.

00:10:34.840 --> 00:10:41.040
What's really nice about this is I can use
the CSS calc function, so again vendor prefix,

00:10:41.040 --> 00:10:44.850
to calculate each of these inner divs to be
100% minus 4 EM.

00:10:44.850 --> 00:10:49.870
Each of these children divs is 4 EM smaller
than its parent container and that's producing

00:10:49.870 --> 00:10:52.960
sort of this target effect.

00:10:52.960 --> 00:10:56.339
What's really neat about this is you combine
it with what we just talked about, which is

00:10:56.339 --> 00:11:00.029
Flexbox, and so that's what's doing the alignment
of the center and justifying the content to

00:11:00.029 --> 00:11:01.029
the center.

00:11:01.029 --> 00:11:04.620
So that vertical center, that horizontal center
with three lines of CSS now, combined with

00:11:04.620 --> 00:11:07.720
the calc function you can do something like
this, which you haven't been able to do before

00:11:07.720 --> 00:11:10.260
without a little bit of JavaScript.

00:11:10.260 --> 00:11:11.500
Really awesome.

00:11:11.500 --> 00:11:15.840
This stuff now can work together really easily
with a lot of new CSS stuff.

00:11:15.840 --> 00:11:21.390
And support is actually really good for this
as you can see by this slide.

00:11:21.390 --> 00:11:22.622
So that's what's happening with CSS.

00:11:22.622 --> 00:11:26.279
Number three amazing, awesome thing that the
Web can do is data binding.

00:11:26.279 --> 00:11:27.900
And you're like what?

00:11:27.900 --> 00:11:31.230
The web can't do data binding.

00:11:31.230 --> 00:11:33.540
Oh, but it can.

00:11:33.540 --> 00:11:35.720
This is actually old hat for JavaScript frameworks.

00:11:35.720 --> 00:11:41.980
If you use your framework like Angular JS,
for example, one of my favorites at the moment,

00:11:41.980 --> 00:11:43.650
data binding looks like this.

00:11:43.650 --> 00:11:46.270
This is how they define a template in Angular.

00:11:46.270 --> 00:11:47.580
It's just HTML, which is really, really nice.

00:11:47.580 --> 00:11:51.250
I don't have to learn a new API or markup.

00:11:51.250 --> 00:11:57.250
If I want to do one-way data binding I can
have an input, I can change the input, and

00:11:57.250 --> 00:11:59.050
as I change that my template is being re-rendered.

00:11:59.050 --> 00:12:02.230
I'm just re-rendering the value of the input
as it changes.

00:12:02.230 --> 00:12:05.630
And that's done through sort of Angular's
magic.

00:12:05.630 --> 00:12:07.470
My model in this case is this val.

00:12:07.470 --> 00:12:09.110
That's what I'm calling the model.

00:12:09.110 --> 00:12:13.100
And as I change the input, val is being re-rendered
to the template.

00:12:13.100 --> 00:12:16.660
So that's one-way data binding use a JavaScript
framework.

00:12:16.660 --> 00:12:21.089
But we can actually do a neat little trick
that I kind of discovered, which I'm calling

00:12:21.089 --> 00:12:25.030
it poor man's data binding, and it's using
data attributes, HTML data attributes.

00:12:25.030 --> 00:12:27.680
So we don't need a framework to do one-way
data binding.

00:12:27.680 --> 00:12:30.980
So the way this works is that you have a data
attribute.

00:12:30.980 --> 00:12:31.980
That's your data model.

00:12:31.980 --> 00:12:35.720
That's where you're going to be storing your
values.

00:12:35.720 --> 00:12:38.860
And then a lot of people don't know, but there's
this really awesome, amazing attribute that

00:12:38.860 --> 00:12:44.540
you can use to pull out values from the DOM
and use those values in CSS.

00:12:44.540 --> 00:12:47.040
So that's how we'll get the data from the
data model.

00:12:47.040 --> 00:12:51.260
Then our view from this case, what we're rendering
this data to, is generated content.

00:12:51.260 --> 00:12:56.480
So before and after pseudo elements and generating
that model to those elements.

00:12:56.480 --> 00:12:59.779
And so we don't have a JavaScript framework
to work for us in this case so we have to

00:12:59.779 --> 00:13:05.990
actually hook up Web event listeners to do
this and watch for the changes.

00:13:05.990 --> 00:13:09.740
So what you get back with the poor man's data
binding is exactly the same thing.

00:13:09.740 --> 00:13:15.040
So I can have an input, and as I change that
input, I can re-render that to my template,

00:13:15.040 --> 00:13:17.540
my pseudo elements, on the fly.

00:13:17.540 --> 00:13:20.360
So a small amount of code to do this.

00:13:20.360 --> 00:13:24.020
I set up an event change event on my input.

00:13:24.020 --> 00:13:27.399
And then as that input changes, the user changes
it, I'm sending a data attribute using the

00:13:27.399 --> 00:13:28.600
data set object.

00:13:28.600 --> 00:13:32.950
So data-values is my thing that I'm changing
to the new value.

00:13:32.950 --> 00:13:38.250
And the really cool part of this is that I'm
using before and after pseudo selectors for

00:13:38.250 --> 00:13:39.250
this.

00:13:39.250 --> 00:13:42.430
So I'm using that attribute method to rip
out that data element, that data attribute,

00:13:42.430 --> 00:13:46.320
from the DOM, dividing it by the max attribute,
in this case 100.

00:13:46.320 --> 00:13:49.110
So you get the exact same thing as the Angular
JS case.

00:13:49.110 --> 00:13:53.339
I don't need a framework to do the -- this
type of one-way data binding.

00:13:53.339 --> 00:13:58.530
You can do the exact same thing with an extra
span or DOM node and just render the inner

00:13:58.530 --> 00:13:59.770
text of that.

00:13:59.770 --> 00:14:00.770
That's cool.

00:14:00.770 --> 00:14:04.270
This is a little cooler in my opinion and
it illustrates that we can do this now in

00:14:04.270 --> 00:14:05.270
HTML5.

00:14:05.270 --> 00:14:09.750
But we can also use something better, which
is the dataless element, something new to

00:14:09.750 --> 00:14:12.730
WebKit, and Opera has had this for a slew
of time.

00:14:12.730 --> 00:14:15.800
This is sort of a semantic way to do one-way
data binding.

00:14:15.800 --> 00:14:18.700
So in this case your data model is actually
defined in markup.

00:14:18.700 --> 00:14:24.230
You have data list element, you can reference
it by an ID, so the browser's out, and each

00:14:24.230 --> 00:14:27.080
option is sort of the values of this data
list.

00:14:27.080 --> 00:14:32.000
And what we bind to in this case is an input
element, so we reference it by the list attribute

00:14:32.000 --> 00:14:36.890
of ID and so we're finding this data list
-- these values to this input element.

00:14:36.890 --> 00:14:39.730
So it's a great way to do things like auto
complete.

00:14:39.730 --> 00:14:41.410
So I have an example of that in here.

00:14:41.410 --> 00:14:43.120
I have the list of browsers.

00:14:43.120 --> 00:14:46.740
When I click on this I get the values from
that data list.

00:14:46.740 --> 00:14:48.760
We bound that data to this input.

00:14:48.760 --> 00:14:56.570
If I do things like -- if I start typing,
just as you expect I have auto complete behavior.

00:14:56.570 --> 00:14:57.570
That's super handy.

00:14:57.570 --> 00:15:00.580
That's the HTML5 way to do one-way data binding.

00:15:00.580 --> 00:15:05.740
You actually saw it in that blue column example,
you saw me use this data attribute trick as

00:15:05.740 --> 00:15:11.350
well to render out the heights of those columns
as they were changing when I clicked on them.

00:15:11.350 --> 00:15:15.200
And both of these methods for data binding
are actually all supported on all the bottom

00:15:15.200 --> 00:15:16.230
browsers, which is really, really sweet.

00:15:16.230 --> 00:15:19.839
But if you're doing something simple like
I just showed you, you can do one-way data

00:15:19.839 --> 00:15:23.410
binding just with HTML, just on the Web.

00:15:23.410 --> 00:15:27.480
How many people think HTML can access a file
system?

00:15:27.480 --> 00:15:30.959
It's hard to see up here, we have some believers.

00:15:30.959 --> 00:15:33.470
We have a lot of naysayers.

00:15:33.470 --> 00:15:34.470
It's cool.

00:15:34.470 --> 00:15:36.810
This one is totally confirmed.

00:15:36.810 --> 00:15:39.210
It's confirmed because I got really excited
about this one.

00:15:39.210 --> 00:15:41.060
I got so excited that I wrote a book.

00:15:41.060 --> 00:15:44.650
[Laughter]
&gt;&gt;Eric Bidelman: Shameless plug, I know.

00:15:44.650 --> 00:15:48.040
What we have now in HTML5 is a file system
API.

00:15:48.040 --> 00:15:51.090
This is something that you can do very easily
in a native app.

00:15:51.090 --> 00:15:55.210
You can read and write folders and persist
data.

00:15:55.210 --> 00:15:56.210
That's very common.

00:15:56.210 --> 00:15:59.431
We should be able to do this on the Web as
well and we can do that with the file system

00:15:59.431 --> 00:16:00.510
API.

00:16:00.510 --> 00:16:06.140
So there's a new property on the window method
called request file system, and this is vendor

00:16:06.140 --> 00:16:08.950
prefixes alluded to by this underline here.

00:16:08.950 --> 00:16:12.060
You can open the file system and read and
write files and folders.

00:16:12.060 --> 00:16:13.060
That's really huge.

00:16:13.060 --> 00:16:17.130
The security behind this is exactly like the
other offline storage API.

00:16:17.130 --> 00:16:19.279
So it's on a per-origin basis.

00:16:19.279 --> 00:16:23.440
You can't read and write to somebody else's
Web app and you certainly can't come out of

00:16:23.440 --> 00:16:27.550
the browser and write to somebody's My Pictures
folder or the system's My Documents folder.

00:16:27.550 --> 00:16:29.950
It's all on a per-origin for your Web app.

00:16:29.950 --> 00:16:31.910
But it's super powerful.

00:16:31.910 --> 00:16:38.089
And the real benefit of this is to get around
issues that something like App Cache does.

00:16:38.089 --> 00:16:40.769
So if you've used App Cache, it's kind of
clunky, it's hard to use.

00:16:40.769 --> 00:16:45.360
With the file system API we can easily and
dynamically cache individual files and folders

00:16:45.360 --> 00:16:46.360
very quickly.

00:16:46.360 --> 00:16:50.600
Store them in folders, arrange them in a hierarchy,
nuke that if we need to.

00:16:50.600 --> 00:16:55.580
So as a quick example of caching an image
file, for instance, just a png file, we're

00:16:55.580 --> 00:17:01.209
going to use a friend, XMLhtpp request, pull
that guy down, and we're not pulling it as

00:17:01.209 --> 00:17:04.640
a streamer, but we're pulling it as an array
buffer, so we'll set the response type and

00:17:04.640 --> 00:17:08.820
we're just going to get a raw byte array back
from that image.

00:17:08.820 --> 00:17:13.370
And we get the response and we'll open the
file system using WebKit file request file

00:17:13.370 --> 00:17:19.020
system, give it a store, so maybe we'll store
a megabyte worth of data in this.

00:17:19.020 --> 00:17:26.260
We'll use the file system's root directory,
just the root entry of my file system, and

00:17:26.260 --> 00:17:32.040
we'll call it image.png, we'll create it if
it doesn't exist using this param here.

00:17:32.040 --> 00:17:37.160
We'll get back a file entry, we'll then write
that response of the XHR out to the file system

00:17:37.160 --> 00:17:38.790
and save that data.

00:17:38.790 --> 00:17:40.990
So this is just creating a file writer object.

00:17:40.990 --> 00:17:45.210
We can set up events for when the write has
ended, if there's any errors that happened.

00:17:45.210 --> 00:17:48.260
And the important part is this guy right here,
this writer.write.

00:17:48.260 --> 00:17:53.520
We're gonna write out that data, the response
of the XHR, create a new blog from the response

00:17:53.520 --> 00:17:54.520
and that's going to be saved.

00:17:54.520 --> 00:17:57.990
The image is gonna be saved locally to our
Web app and we can use that as if it were

00:17:57.990 --> 00:18:04.620
a local resource to our Web app.

00:18:04.620 --> 00:18:06.210
So that's the final product.

00:18:06.210 --> 00:18:08.540
You can see there's a lot of callbacks that
are involved here.

00:18:08.540 --> 00:18:14.210
I have at least one, two, three, four -- four
to five levels of sort of callback -- callback

00:18:14.210 --> 00:18:16.530
spaghetti that's happening here.

00:18:16.530 --> 00:18:17.530
Callbacks are hard.

00:18:17.530 --> 00:18:18.660
People don't like to deal with them.

00:18:18.660 --> 00:18:23.700
This is a famous quote that I just said.

00:18:23.700 --> 00:18:24.700
[Laughter]
&gt;&gt;Eric Bidelman: Actually, I wanted to make

00:18:24.700 --> 00:18:25.700
it simpler for developers.

00:18:25.700 --> 00:18:27.540
Again, I'm really passionate about this API.

00:18:27.540 --> 00:18:29.240
It's very powerful.

00:18:29.240 --> 00:18:31.309
So I wrote this library called filer.js.

00:18:31.309 --> 00:18:33.540
You can check out the GitHub URL there.

00:18:33.540 --> 00:18:38.540
But essentially what it is is a library that
wraps common UNIX commands on top of the file

00:18:38.540 --> 00:18:40.550
system API calls.

00:18:40.550 --> 00:18:44.400
So we have things like LS and CD and copy
and the things that you know from interface

00:18:44.400 --> 00:18:47.510
that make it super easy to use this API.

00:18:47.510 --> 00:18:54.390
If I want to copy a file, for instance, filer.copy,
the file path you want to copy to and then

00:18:54.390 --> 00:18:56.220
renaming it as well.

00:18:56.220 --> 00:18:57.220
So super handy.

00:18:57.220 --> 00:18:59.410
It makes the whole thing much more approachable
if you're familiar with this sort of development.

00:18:59.410 --> 00:19:08.390
Let's see a demo of this guy.

00:19:08.390 --> 00:19:12.220
So this is called the file system API playground.

00:19:12.220 --> 00:19:15.770
Essentially what this is is a Web app that
sits on top of the file system API.

00:19:15.770 --> 00:19:19.770
So right now I don't have anything in this
guy, but you can easily use HTML5 Dragon drop

00:19:19.770 --> 00:19:23.810
to add some files, boom, I can add some text
files.

00:19:23.810 --> 00:19:29.770
I can open these files, right, so there's
this sort of notion of using this -- this

00:19:29.770 --> 00:19:32.550
resource locally with referencing it via URL.

00:19:32.550 --> 00:19:34.610
Can use that within my Web app.

00:19:34.610 --> 00:19:38.770
Can also read this file and preview it if
I wanted to using the file reader API, and

00:19:38.770 --> 00:19:43.080
get some metadata such as the date and last
modified times.

00:19:43.080 --> 00:19:46.960
Can use filer.js and API to rename the file.

00:19:46.960 --> 00:19:50.100
The best part about this is I've actually
cached these resources, so if I refresh this

00:19:50.100 --> 00:19:54.800
page, my Web app, right, has those values
and those resources saved in them, so all

00:19:54.800 --> 00:19:58.170
the changes I made are being persisted, which
is really awesome.

00:19:58.170 --> 00:20:00.290
Can create files and folders.

00:20:00.290 --> 00:20:02.690
Create a folder using the API.

00:20:02.690 --> 00:20:04.500
You can drill into it.

00:20:04.500 --> 00:20:08.480
Import some data here.

00:20:08.480 --> 00:20:12.120
Luckily it's after lunch so, you guys don't
have to get too hungry.

00:20:12.120 --> 00:20:13.170
But this is really great.

00:20:13.170 --> 00:20:15.470
I mean, this is native stuff, but it's on
the Web.

00:20:15.470 --> 00:20:20.430
We can write and read files and folders now
using the file system API.

00:20:20.430 --> 00:20:27.630
So you're probably asking yourself this: This
is great, but if it's only in Chrome, like

00:20:27.630 --> 00:20:29.010
why am I going to use it?

00:20:29.010 --> 00:20:32.460
Then I'm like, oh, yeah.

00:20:32.460 --> 00:20:37.880
So again, I really like this API, you guys,
so I decided to implement a polyfill stream

00:20:37.880 --> 00:20:42.840
library that sits on top of index DB that
then you can use in your Web app to have basically

00:20:42.840 --> 00:20:46.780
the file system API in browsers that support
index DB.

00:20:46.780 --> 00:20:47.910
So same Web app, right?

00:20:47.910 --> 00:20:50.419
Same Web app running in Chrome is running
in FireFox.

00:20:50.419 --> 00:20:59.710
And I can add files and folders to this guy,
maybe -- it's a nightly build, so I don't

00:20:59.710 --> 00:21:01.049
know -- there we go.

00:21:01.049 --> 00:21:09.100
And if I refresh this up, those files that
I just wrote to the Web app are preserved.

00:21:09.100 --> 00:21:12.510
So that library is called IDBfilesystem.js.

00:21:12.510 --> 00:21:17.540
And if you're interested in this API, the
file system API, check it out, it basically

00:21:17.540 --> 00:21:22.290
means that we can now use this API in a relatively
performant way in the browsers that do support

00:21:22.290 --> 00:21:23.740
index DB.

00:21:23.740 --> 00:21:24.740
Super Stoked about it.

00:21:24.740 --> 00:21:26.780
Hope you guys get Stoked about it, too.

00:21:26.780 --> 00:21:28.480
Files and folders, the Web can do that.

00:21:28.480 --> 00:21:30.490
All right, Number 5.

00:21:30.490 --> 00:21:32.470
This one looks suspicious.

00:21:32.470 --> 00:21:34.620
Totally is busted.

00:21:34.620 --> 00:21:38.010
Just making sure you guys are paying attention.

00:21:38.010 --> 00:21:41.240
[ Laughter ]
&gt;&gt;Eric Bidleman: The real Number 5 is serverless

00:21:41.240 --> 00:21:42.700
downloads.

00:21:42.700 --> 00:21:50.830
So we got data in the file system, we're storing
data in our Web app -- where is my clicker?

00:21:50.830 --> 00:21:54.440
What happens when you want to get data back
out of your Web app, right?

00:21:54.440 --> 00:21:59.910
So for a long time, if you wanted to download
a file and trick the browser into downloading

00:21:59.910 --> 00:22:03.010
a file from the response of your server, you
would have had to do something like this:

00:22:03.010 --> 00:22:07.929
You would send a content disposition header
as an attachment, give it a file name, and

00:22:07.929 --> 00:22:11.790
essentially what this did was when the browser
hit this response, the browser would sort

00:22:11.790 --> 00:22:15.900
of -- it would trick it into downloading a
file and it would invoke the browser's download

00:22:15.900 --> 00:22:18.190
manager.

00:22:18.190 --> 00:22:21.660
What we have now is a lot of people are writing
thick clients, right?

00:22:21.660 --> 00:22:24.220
Maybe there's no server involved whatsoever,
so how do you do this?

00:22:24.220 --> 00:22:27.700
How do you send a header if you don't have
a server?

00:22:27.700 --> 00:22:28.700
It's impossible.

00:22:28.700 --> 00:22:31.830
So smart folks in the Web community were like,
hey, we can solve this, we've got this great

00:22:31.830 --> 00:22:33.870
idea, let's make an attribute, we'll call
it "download".

00:22:33.870 --> 00:22:35.490
That makes a lot of sense.

00:22:35.490 --> 00:22:41.160
And what download does is you can use with
an anchor tag for instance, and so what happens

00:22:41.160 --> 00:22:48.010
is -- normally what happens is if you -- if
a user clicks on this H ref to this logo.png,

00:22:48.010 --> 00:22:52.059
what happens is the browser will open that
image in a new tab and you can view the image.

00:22:52.059 --> 00:22:53.309
That's cool.

00:22:53.309 --> 00:22:57.120
But what happens if you have download specified,
this attribute, and you can give it the name

00:22:57.120 --> 00:23:00.250
of the file you want to download as, is that
it's going to trick the browser into doing

00:23:00.250 --> 00:23:04.200
the exact same thing as the content disposition
header, and then you can download that file

00:23:04.200 --> 00:23:06.880
instead of navigating to that resource.

00:23:06.880 --> 00:23:14.670
So if none of that makes any sense to you,
I have an epic novel creator here, and this

00:23:14.670 --> 00:23:22.110
is just a text area that I'm typing into,
so let me bring this up a little bit.

00:23:22.110 --> 00:23:25.190
So just to show you that I'm typing live.

00:23:25.190 --> 00:23:26.190
I'm just typing in this.

00:23:26.190 --> 00:23:27.330
I'm composing my epic novel.

00:23:27.330 --> 00:23:32.340
And then I want to have the user save what
they've just done, so I can do that using

00:23:32.340 --> 00:23:34.419
the download attribute.

00:23:34.419 --> 00:23:39.340
When I click this button, I'm going to create
a txt file, a text file in JavaScript using

00:23:39.340 --> 00:23:41.620
the block builder API.

00:23:41.620 --> 00:23:44.130
Create a dynamic link in JavaScript.

00:23:44.130 --> 00:23:49.320
Attach that download attribute as my file
.txt as its value.

00:23:49.320 --> 00:23:53.740
When I click that, the browser is not going
to open that resource, it's actually going

00:23:53.740 --> 00:23:57.809
to download the file that I just created in
JavaScript, and if I open this, it's going

00:23:57.809 --> 00:24:01.760
to be native to my system, and as you can
see, the text content that I just pulled out

00:24:01.760 --> 00:24:03.100
from that text area has been saved.

00:24:03.100 --> 00:24:10.020
I've just downloaded a file in JavaScript,
all clientside, no servers.

00:24:10.020 --> 00:24:14.500
That's pretty sweet.

00:24:14.500 --> 00:24:18.951
So we have the ability to save data in the
file system, we have the ability to get it

00:24:18.951 --> 00:24:22.030
back out using the down attribute.

00:24:22.030 --> 00:24:24.840
What about getting data in between apps?

00:24:24.840 --> 00:24:29.160
Now, there's this thing called Web intense,
and I encourage you to go to Paul Kinlan and

00:24:29.160 --> 00:24:31.919
James' session later in the week.

00:24:31.919 --> 00:24:36.810
But one way to officially transfer data is
rocketships, of course.

00:24:36.810 --> 00:24:39.170
But another way is with post message.

00:24:39.170 --> 00:24:41.780
And in order to describe this and set this
up for you guys, I want to take you down sort

00:24:41.780 --> 00:24:44.539
of memory lane of post message.

00:24:44.539 --> 00:24:49.140
Post message started off as a way to communicate
with a Webworker or a window object, right?

00:24:49.140 --> 00:24:50.370
You could send a string.

00:24:50.370 --> 00:24:54.309
You could send "hello world" to a worker,
and then it could, I don't know, do something

00:24:54.309 --> 00:24:55.309
interesting with that.

00:24:55.309 --> 00:24:59.410
But what happened is, hey, people are gonna
-- the browsers are like -- developers got

00:24:59.410 --> 00:25:02.750
smart, they were like let's just send JSON
stringify data.

00:25:02.750 --> 00:25:07.570
So they'd stringify some JSON, and pass some
commands in and out of worker or to a window

00:25:07.570 --> 00:25:09.110
object.

00:25:09.110 --> 00:25:14.059
So it was totally cool, but then the browsers
were like, hey, like, we can do better, let's

00:25:14.059 --> 00:25:19.530
just do that for them, just not have the ability
to stringify JSON, but let's just do it under

00:25:19.530 --> 00:25:24.150
the hood, so what happens is the browser would
JSON stringify and JSON parse this message

00:25:24.150 --> 00:25:25.740
out, so that was cool.

00:25:25.740 --> 00:25:26.740
That got us one step further.

00:25:26.740 --> 00:25:32.289
Sort of this post message evolution, but then
the third step that came along was the ability

00:25:32.289 --> 00:25:33.720
to send more complex data, right?

00:25:33.720 --> 00:25:37.950
You just saw me send a file -- create a file
in JavaScript.

00:25:37.950 --> 00:25:41.140
Why can't I send a file into a Web worker
and do something interesting with it, or a

00:25:41.140 --> 00:25:43.179
Web GL texter as an array buffer?

00:25:43.179 --> 00:25:48.340
All right, we have binary data in -- on the
Web now; we should be able to do interesting

00:25:48.340 --> 00:25:49.610
things with it.

00:25:49.610 --> 00:25:52.380
So eventually , the browser is like, hey,
we'll open this up, we're going to use this

00:25:52.380 --> 00:25:56.660
structured cloning algorithm to pass a blob,
a file into the Web worker and process it.

00:25:56.660 --> 00:26:00.500
Or you can send an array buffer, so this is
really, really cool, right?

00:26:00.500 --> 00:26:02.730
And a lot of the modern browsers support this.

00:26:02.730 --> 00:26:05.789
You can send a massive, you know, data set
into a Web worker.

00:26:05.789 --> 00:26:10.730
Do some computation on it in this sort of
multi-thread environment and then get it back

00:26:10.730 --> 00:26:12.520
out and do something interesting.

00:26:12.520 --> 00:26:15.559
So the real problem with this, though, is
that these are all -- all the methods I just

00:26:15.559 --> 00:26:20.770
covered are copies, so that becomes very inefficient
when you're copying and sending amounts of

00:26:20.770 --> 00:26:22.120
data in and out of a Web worker.

00:26:22.120 --> 00:26:26.309
It's kind of pointless to have this awesome,
you know, multi-threaded Web worker doing

00:26:26.309 --> 00:26:30.960
its thing, but if you can't get data in and
out very quickly, then it defeats the purpose.

00:26:30.960 --> 00:26:36.250
So of course I wouldn't be up here if we can't
do better, and we can do better, and that

00:26:36.250 --> 00:26:38.370
comes via transferable objects.

00:26:38.370 --> 00:26:41.021
Transferable objects are something that the
Web GL community thought up because they need

00:26:41.021 --> 00:26:44.919
this ability to do processing on large amounts
of data.

00:26:44.919 --> 00:26:49.900
And so you can see this guy is using your
old friend, but it has different semantics,

00:26:49.900 --> 00:26:53.940
and that's why this method is prefixed with
WebKit post message.

00:26:53.940 --> 00:26:57.610
This is something that is supported in Chrome.

00:26:57.610 --> 00:27:02.290
So what happens with the new post message
is that it's a zero copy, so if you're familiar

00:27:02.290 --> 00:27:09.100
with like C++ or C, think of it as a pass-by
reference rather than a pass-by value.

00:27:09.100 --> 00:27:13.270
And so the ownership of this data is actually
transferred from your main app to the worker

00:27:13.270 --> 00:27:16.059
or window context that you're posting to.

00:27:16.059 --> 00:27:21.440
And so what happens is that this becomes actually
really, really efficient, up to 50 times faster.

00:27:21.440 --> 00:27:23.380
I measured this in Chrome 17.

00:27:23.380 --> 00:27:27.310
So Chrome 17, you know, that is sort of long
gone now, but it could even be faster.

00:27:27.310 --> 00:27:28.310
I don't know.

00:27:28.310 --> 00:27:32.390
But the important point of this graph are
these last two columns here.

00:27:32.390 --> 00:27:37.000
In Chrome 17 the difference between the regular
post message, which is on the left, the middle

00:27:37.000 --> 00:27:39.230
one, and the right, is orders and orders of
magnitude.

00:27:39.230 --> 00:27:42.530
This is a logarithmic scale, keep in mind.

00:27:42.530 --> 00:27:43.530
Faster.

00:27:43.530 --> 00:27:46.919
So basically what I did in this test was I
sent a 32 megabyte file into a Web worker.

00:27:46.919 --> 00:27:51.240
I didn't do any processing on that file, and
then I sent it right back just to see how

00:27:51.240 --> 00:27:52.240
fast that was.

00:27:52.240 --> 00:27:53.240
I measured that.

00:27:53.240 --> 00:28:00.539
And you can see the rate -- the round trip
simulated rate of that is super, super fast.

00:28:00.539 --> 00:28:06.020
So this is really sweet for things like physics
simulations and again Web GL, gaming.

00:28:06.020 --> 00:28:10.539
I have an example of this, and unfortunately
this is not super sexy to demo, but this is

00:28:10.539 --> 00:28:14.550
my awesome sexy demo for transferable object.

00:28:14.550 --> 00:28:16.980
This page has basically set up a Web worker.

00:28:16.980 --> 00:28:22.720
I got a worker ready to be post messaged to,
and when I hit this run button, it's going

00:28:22.720 --> 00:28:26.160
to use that new WebKit post message to send
data into Web worker.

00:28:26.160 --> 00:28:32.200
I think we're sending -- we're sending a 32
megabyte array buffer, so this 32 megabyte

00:28:32.200 --> 00:28:36.130
file into a web worker, and then sending that
right back, seeing how fast that is.

00:28:36.130 --> 00:28:39.840
So I'll hit this, ready?

00:28:39.840 --> 00:28:42.820
Boom, boom, boom, boom.

00:28:42.820 --> 00:28:44.299
6 milliseconds.

00:28:44.299 --> 00:28:46.260
5,000 megabytes a second simulated rate, right?

00:28:46.260 --> 00:28:47.850
I mean, that is kind of ridiculous, right?

00:28:47.850 --> 00:28:48.850
That's awesome.

00:28:48.850 --> 00:28:50.120
That's awesome for sending large amounts of
data.

00:28:50.120 --> 00:28:51.799
And that's a lot of data.

00:28:51.799 --> 00:28:55.000
32 megabytes is no joke.

00:28:55.000 --> 00:28:58.840
Pop up a full screen here.

00:28:58.840 --> 00:29:03.700
Just to show you the difference -- I'm not
picking on any browser in particular -- but

00:29:03.700 --> 00:29:07.420
a browser that doesn't support transferable
object, you can actually noticeably see the

00:29:07.420 --> 00:29:08.480
difference here.

00:29:08.480 --> 00:29:11.000
Let me zoom in.

00:29:11.000 --> 00:29:15.140
So when I hit this, run, boom, boom.

00:29:15.140 --> 00:29:21.429
So, not only do the numbers speak for themselves,
157 as opposed to 5,000 megabytes a second,

00:29:21.429 --> 00:29:25.710
you can actually see the delay, right, visually
the delay that it takes for this Web app to

00:29:25.710 --> 00:29:27.409
make that round trip request.

00:29:27.409 --> 00:29:32.500
So significant difference using transferable
objects and performance.

00:29:32.500 --> 00:29:37.030
In my opinion this is something that, you
know, the Web path form and workers in window

00:29:37.030 --> 00:29:40.690
and post message should have had available
in the first place, but this is sort of a

00:29:40.690 --> 00:29:42.250
common thing in the Web, right?

00:29:42.250 --> 00:29:45.590
We're sort of incrementally improving on what
we already had, making it better and better

00:29:45.590 --> 00:29:47.520
and better every time.

00:29:47.520 --> 00:29:50.059
This one's only in Chrome, again something
that should be in every browser.

00:29:50.059 --> 00:29:53.880
Efficiency is something we love in the Web.

00:29:53.880 --> 00:29:58.350
How many people think the Web can access native
hardware?

00:29:58.350 --> 00:30:00.550
Not using phone gap or something like that?

00:30:00.550 --> 00:30:01.550
Okay.

00:30:01.550 --> 00:30:02.550
Got some believers.

00:30:02.550 --> 00:30:03.550
I love it.

00:30:03.550 --> 00:30:05.220
You guys know this is when it's going to be
confirmed.

00:30:05.220 --> 00:30:06.240
It's confirmed.

00:30:06.240 --> 00:30:07.770
It's totally confirmed.

00:30:07.770 --> 00:30:10.409
What I mean by accessing hardware is device
APIs.

00:30:10.409 --> 00:30:14.679
There's a whole working group dedicated to
figuring this stuff out now.

00:30:14.679 --> 00:30:20.380
And what I mean by devices are things like
geolocation and accessing the accelerometer

00:30:20.380 --> 00:30:25.530
of this laptop, using web GL to access the
GPU, right, the graphics processor unit of

00:30:25.530 --> 00:30:28.160
the laptop, using a very high level JavaScript
API.

00:30:28.160 --> 00:30:30.309
I just showed you the file system API.

00:30:30.309 --> 00:30:33.940
We can read and write folders and files on
the Web now.

00:30:33.940 --> 00:30:40.270
Whether I'm online or offline, network connectivity,
all via JavaScript, battery API, game pad

00:30:40.270 --> 00:30:42.490
API, all super possible.

00:30:42.490 --> 00:30:45.919
Web RTC and Web audio, I want to briefly mention
on.

00:30:45.919 --> 00:30:50.860
There's two dedicated sessions to these two
topics, because they're very -- they're noteworthy

00:30:50.860 --> 00:30:53.140
and very complex and they should have a dedicated
session.

00:30:53.140 --> 00:30:58.110
Being able to access voice and video on the
Web is sort of this coveted grail, right?

00:30:58.110 --> 00:31:02.490
I mean, we've wanted to access the microphone
for a long time or get camera for a long time,

00:31:02.490 --> 00:31:07.190
but you've needed a plug in to do this, so
this is one example of being able to sort

00:31:07.190 --> 00:31:12.480
of -- the first step along this path to do
that, with one attribute, this x WebKit speech

00:31:12.480 --> 00:31:16.600
attribute, we can annotate an input, and the
browser is going to annotate it with this

00:31:16.600 --> 00:31:18.510
little microphone input.

00:31:18.510 --> 00:31:21.630
Instead of typing in this Web app, it can
actually interact with the microphone in this

00:31:21.630 --> 00:31:22.930
Web app.

00:31:22.930 --> 00:31:25.510
"I want some coffee".

00:31:25.510 --> 00:31:26.790
All right.

00:31:26.790 --> 00:31:28.070
It worked.

00:31:28.070 --> 00:31:29.990
Sometimes it doesn't.

00:31:29.990 --> 00:31:31.200
Or you get some weird rendition.

00:31:31.200 --> 00:31:33.000
But this is really great.

00:31:33.000 --> 00:31:35.150
A different way to interact with my Web app.

00:31:35.150 --> 00:31:37.020
I don't have much of an API to play with,
right?

00:31:37.020 --> 00:31:38.630
It's sort of happening under the hood.

00:31:38.630 --> 00:31:45.390
But I'm accessing the microphone of this laptop
using one attribute.

00:31:45.390 --> 00:31:47.220
So what we have now is something way better.

00:31:47.220 --> 00:31:51.279
We have camera and microphone access via Get
User Media.

00:31:51.279 --> 00:31:56.480
Get User Media is coming out of the Web RTC
project, navigator dot -- either Get User

00:31:56.480 --> 00:31:59.600
Media or the prefix version.

00:31:59.600 --> 00:32:02.751
Also Christian from FireFox tells me this
is coming to FireFox and nightly builds, so

00:32:02.751 --> 00:32:07.120
that should be on there as well.

00:32:07.120 --> 00:32:09.830
To the camera, the device and the microphone
device.

00:32:09.830 --> 00:32:14.250
With this call, I can specify that I want
audio access, I want video access, and what

00:32:14.250 --> 00:32:19.419
I'm going to get back is a stream object representing
that data that I get from both devices.

00:32:19.419 --> 00:32:23.190
And then what's really cool is again I'm using
different parts of the platform that have

00:32:23.190 --> 00:32:25.220
already existed for a long time.

00:32:25.220 --> 00:32:26.450
I'm using a video element.

00:32:26.450 --> 00:32:31.929
HTML video is one of the core features of
HTML5 when it first came out.

00:32:31.929 --> 00:32:38.059
Instead of setting the video source to, you
know, a movie file or an OVG file, I'm setting

00:32:38.059 --> 00:32:42.559
it to a blob URL created from the data I get
from the camera.

00:32:42.559 --> 00:32:46.350
So instead of a file, I'm just sending the
camera data and the microphone data directly

00:32:46.350 --> 00:32:51.779
into this video tag, so that's what's going
to give us the ability to render live to video

00:32:51.779 --> 00:32:52.779
tag.

00:32:52.779 --> 00:32:53.779
So a little demo.

00:32:53.779 --> 00:32:56.460
There's a lot of really cool demos people
created using Get User Media and the ability

00:32:56.460 --> 00:32:57.480
to access the camera.

00:32:57.480 --> 00:32:59.010
This is my demo.

00:32:59.010 --> 00:33:00.140
I do trust this app.

00:33:00.140 --> 00:33:01.140
I made it.

00:33:01.140 --> 00:33:02.140
I wrote it.

00:33:02.140 --> 00:33:03.820
So I'm gonna -- I can't see at the top.

00:33:03.820 --> 00:33:05.039
I'm going to allow access.

00:33:05.039 --> 00:33:08.279
We'll create a video element in JavaScript,
and there we go.

00:33:08.279 --> 00:33:11.700
My first stage -- you can see behind -- so
this is great, no plug-ins, right?

00:33:11.700 --> 00:33:16.220
This is just JavaScript on the Web, but again
I can combine this with different parts of

00:33:16.220 --> 00:33:21.580
the Web platform, so I can use CSS filters
in real time to overlay this video with effects

00:33:21.580 --> 00:33:23.160
like gray scale.

00:33:23.160 --> 00:33:25.940
How about a blur effect in real time?

00:33:25.940 --> 00:33:29.000
That's pretty -- that is pretty trippy.

00:33:29.000 --> 00:33:30.000
Version effects, right?

00:33:30.000 --> 00:33:33.679
Just using CSS, applying to this video, I
can do all that and still really awesome,

00:33:33.679 --> 00:33:34.690
looks great.

00:33:34.690 --> 00:33:36.150
I can combine it with a canvas, right, do
a photo booth effect.

00:33:36.150 --> 00:33:37.150
[chuckling]
&gt;&gt;Eric Bidleman: All right.

00:33:37.150 --> 00:33:38.279
That's enough of that.

00:33:38.279 --> 00:33:54.409
One of my favorites, though, is this one called
the Web cam toy, so I'll grant access to this.

00:33:54.409 --> 00:33:57.260
Okay, that uses my camera.

00:33:57.260 --> 00:34:01.450
This is not going to use CSS filters, but
it's going to use the power of camera, the

00:34:01.450 --> 00:34:03.000
power of Web GL, right?

00:34:03.000 --> 00:34:07.440
So with Web GL we can access the GPU, that
native access, and we can do things -- really

00:34:07.440 --> 00:34:08.440
awesome things with shaders.

00:34:08.440 --> 00:34:09.440
Shader technology is amazing.

00:34:09.440 --> 00:34:12.720
Again, this is all JavaScript using Web GL.

00:34:12.720 --> 00:34:13.900
No plug-ins.

00:34:13.900 --> 00:34:16.830
Look how fast it is.

00:34:16.830 --> 00:34:19.080
Really trippy things.

00:34:19.080 --> 00:34:27.429
Let me get to the cool stuff.

00:34:27.429 --> 00:34:28.950
There it is.

00:34:28.950 --> 00:34:29.960
[chuckling]
[ APPLAUSE ]

00:34:29.960 --> 00:34:31.490
&gt;&gt;Eric Bidleman: Yeah.

00:34:31.490 --> 00:34:33.520
This one is cool.

00:34:33.520 --> 00:34:34.520
Super trippy.

00:34:34.520 --> 00:34:35.520
Oh, yeah, 3D.

00:34:35.520 --> 00:34:40.350
This is after you've had a few drinks at the
party tonight.

00:34:40.350 --> 00:34:41.350
Just amazing things.

00:34:41.350 --> 00:34:44.250
People have done thing with augmented reality,
right, holding up a paper -- piece of paper

00:34:44.250 --> 00:34:48.020
with a QR code on it, the camera tracks you.

00:34:48.020 --> 00:34:49.020
So play around with those.

00:34:49.020 --> 00:34:52.820
When I put the slide up later, just really
awesome, amazing things.

00:34:52.820 --> 00:34:53.960
Support for this is actually really good.

00:34:53.960 --> 00:34:55.849
Opera just released Opera 12; it has this.

00:34:55.849 --> 00:34:57.710
They've had it in the mobile version for a
long time.

00:34:57.710 --> 00:35:01.820
It's coming to FireFox nightly I'm told, and
Chrome just released a stable version with

00:35:01.820 --> 00:35:05.920
Get User Media, so we can do camera access,
we can do microphone access without a plug-in

00:35:05.920 --> 00:35:09.349
now.

00:35:09.349 --> 00:35:18.150
HTML5 audio has had a little bit of a slack
-- been problematic, to say the least.

00:35:18.150 --> 00:35:23.100
But what we can do now with the Web audio,
guys, make it -- make it sexy again.

00:35:23.100 --> 00:35:27.410
So HTML5 audio is great.

00:35:27.410 --> 00:35:28.820
It's just like video, right?

00:35:28.820 --> 00:35:32.170
Without a plug-in, we can play audio on the
Web, just populate a source attribute of an

00:35:32.170 --> 00:35:33.170
audio tag.

00:35:33.170 --> 00:35:39.490
Play it, that's cool, we don't need a plug-in,
but what if you want to do something like

00:35:39.490 --> 00:35:40.500
this.

00:35:40.500 --> 00:35:47.210
[Music Playing]
What if you want to visualize that data in

00:35:47.210 --> 00:35:48.220
real time, get the frequency analysis as it
plays?

00:35:48.220 --> 00:35:50.490
Visualize that on two canvas tags, plus Web
GL transforms a little bit of a reflection

00:35:50.490 --> 00:35:51.860
on the bottom there.

00:35:51.860 --> 00:35:54.340
Can't do that with HTML5 audio.

00:35:54.340 --> 00:36:07.360
What we have now is ability to tie in to what's
called a Web audio API, tie in an audio tag

00:36:07.360 --> 00:36:08.360
as a source to that API, so instead of driving
the Web audio API, via, you know, an XHR request

00:36:08.360 --> 00:36:11.290
or something, we can just send data directly
to it -- sorry -- via -- via this audio tag,

00:36:11.290 --> 00:36:12.290
so it's really, really important.

00:36:12.290 --> 00:36:13.290
This doesn't have to just be a video.

00:36:13.290 --> 00:36:14.290
It could be a -- excuse me, an audio tag,
it could be a video tag, so imagine I had

00:36:14.290 --> 00:36:27.650
a HTML5 video playing, and that is the source
to the Web audio API, then you're visualizing

00:36:27.650 --> 00:36:34.530
sort of effects, as movie changes and dark
monsters pop out, you can really scare people.

00:36:34.530 --> 00:36:37.630
But the way the search works is really easy,
so we have the Web audio guy.

00:36:37.630 --> 00:36:41.600
I encourage you to go to Chris Wilson's session
later in the week about this, really amazing

00:36:41.600 --> 00:36:42.600
API.

00:36:42.600 --> 00:36:45.650
A lot of low level access to the core audio
of the system.

00:36:45.650 --> 00:36:48.860
High level JavaScript API on top of it.

00:36:48.860 --> 00:36:49.980
Create an audio context.

00:36:49.980 --> 00:36:59.290
Notifications -- I will create HTML5 audio
element, I will populate it with MP3 as its

00:36:59.290 --> 00:37:02.390
source, set up a couple of controls, some
auto play on it.

00:37:02.390 --> 00:37:06.580
The important integration point between these
two, sort of the old audio working with the

00:37:06.580 --> 00:37:12.770
new Web audio, the capabilities of that API
is this create element source, media element

00:37:12.770 --> 00:37:13.770
source.

00:37:13.770 --> 00:37:24.220
That's how the audio tag is sort of filtered
and piped into the Web audio API.

00:37:24.220 --> 00:37:27.210
Which leads us conveniently into Number 10.

00:37:27.210 --> 00:37:28.210
So I get this one a lot.

00:37:28.210 --> 00:37:32.770
A lot of people ask: "Hey, how come HTML5
can't do, you know, streaming audio?

00:37:32.770 --> 00:37:33.770
Or streaming media?"

00:37:33.770 --> 00:37:35.650
And it actually can.

00:37:35.650 --> 00:37:39.020
It can do that through another old friend,
WebSockets.

00:37:39.020 --> 00:37:40.790
So WebSockets have been around for a while.

00:37:40.790 --> 00:37:45.349
It sort of suffered from the same limitation
of Webworker, where you can only send just

00:37:45.349 --> 00:37:46.349
basic data.

00:37:46.349 --> 00:37:47.780
It can send string data.

00:37:47.780 --> 00:37:49.140
That's not so handy, right?

00:37:49.140 --> 00:37:53.770
We have things like files and array buffers
and ability to use complex data.

00:37:53.770 --> 00:37:58.540
We should be able to send and stream multi-media
or files to our web apps.

00:37:58.540 --> 00:38:01.760
So we can do that now with WebSockets.

00:38:01.760 --> 00:38:06.099
And WebSockets has a new sort of socket, that
binary type is the property you set on this.

00:38:06.099 --> 00:38:09.900
And you set it to a blob or you set it to
an array buffer, and that tells the WebSocket

00:38:09.900 --> 00:38:15.450
that's going to be speaking binary data instead
of just regular string data.

00:38:15.450 --> 00:38:21.250
What's awesome about this is on my on message
event, I can use that directly to set an image

00:38:21.250 --> 00:38:23.040
source, for instance, from a blog URL.

00:38:23.040 --> 00:38:27.810
Instead of having to base 64 encode data on
either end, decode it, which is, you know,

00:38:27.810 --> 00:38:32.910
the overhead associated with that, we can
just use the data directly that we get back.

00:38:32.910 --> 00:38:39.869
So I have a couple of demos of this.

00:38:39.869 --> 00:38:41.550
The first is a Chrome extension.

00:38:41.550 --> 00:38:44.660
So I have a little Chrome extension installed
here and top right corner.

00:38:44.660 --> 00:38:47.440
I'm going to click this guy.

00:38:47.440 --> 00:38:48.440
Imagine this is my viewer.

00:38:48.440 --> 00:38:52.770
I'm going to basically do a sort of screen
cast from the Web.

00:38:52.770 --> 00:38:55.340
This is my viewer, imagine this is somewhere
around the globe.

00:38:55.340 --> 00:38:59.230
I'm going to open a new window, pretend that's
here.

00:38:59.230 --> 00:39:05.400
So when I click this guy again, it's going
to fire up a Websocket, binary Websocket,

00:39:05.400 --> 00:39:10.050
and use the Chrome extension, screen capture
API to capture the current tab.

00:39:10.050 --> 00:39:11.160
Google.com.

00:39:11.160 --> 00:39:15.190
Sports, because sports is great.

00:39:15.190 --> 00:39:21.210
So on the right side, I have my presenter,
this is just capturing the current tab as

00:39:21.210 --> 00:39:22.670
a png as I scroll.

00:39:22.670 --> 00:39:26.390
It's sending that data through a WebSocket
to the remote party.

00:39:26.390 --> 00:39:27.390
You can see it's very performant.

00:39:27.390 --> 00:39:29.930
I don't have to do any basic 64 encoding.

00:39:29.930 --> 00:39:33.470
As I'm scrolling on the right on the live
page, that image is just being sent across

00:39:33.470 --> 00:39:37.300
the wire in near real-time using the WebSocket.

00:39:37.300 --> 00:39:38.400
That's really, really sweet, right?

00:39:38.400 --> 00:39:44.500
We can do this now thanks to the Chrome extension
API, yes, but also via a binary WebSocket.

00:39:44.500 --> 00:39:48.450
Whoa, inception.

00:39:48.450 --> 00:39:50.430
[Laughter].

00:39:50.430 --> 00:39:56.599
&gt;&gt;Eric Bidelman: We can also do other things
with different types of media.

00:39:56.599 --> 00:40:00.300
So I just showed you a little teaser preview
of the Web audio API.

00:40:00.300 --> 00:40:05.110
The API allows you to analyze sound in real-time
as it plays.

00:40:05.110 --> 00:40:10.640
What I have here is a page that sets up a
binary WebSocket, and it's going to use the

00:40:10.640 --> 00:40:16.321
file reader API to essentially cut an MP3
file up into multiple smaller chunks and then

00:40:16.321 --> 00:40:22.270
it's going to connect to that WebSocket, send
each of those chunks across the wire, on my

00:40:22.270 --> 00:40:28.220
-- on my left side here, the viewer side,
I'm going to use the Web audio API to schedule

00:40:28.220 --> 00:40:31.760
those chunks at very precise times exactly
when they should happen.

00:40:31.760 --> 00:40:36.210
So essentially I reconstruct the audio on
the other end and just sort of use the sequence

00:40:36.210 --> 00:40:40.119
that it should be in and then visualize that
using the Web audio API.

00:40:40.119 --> 00:40:47.260
I'm going to load up an MP3 file here on my
DJ machine, this guy in the right corner.

00:40:47.260 --> 00:40:49.930
Binary WebSocket, web audio API.

00:40:49.930 --> 00:40:50.960
No sound?

00:40:50.960 --> 00:40:53.530
There we go, there's sound.

00:40:53.530 --> 00:40:57.140
[ Music ]
&gt;&gt;Eric Bidelman: So again, streaming from

00:40:57.140 --> 00:41:08.339
one client, streaming audio data using a WebSocket,
using the Web to reconstruct it and then visualizing

00:41:08.339 --> 00:41:09.339
in real-time.

00:41:09.339 --> 00:41:11.163
You can see the chunks coming in, I'm receiving
sort of mini chunks of that MP3 file as I

00:41:11.163 --> 00:41:16.410
reconstruct the audio and sort of the current
time is playing.

00:41:16.410 --> 00:41:24.140
Just to prove to you this is streaming, I
refresh this, come back at the exact same

00:41:24.140 --> 00:41:25.140
spot.

00:41:25.140 --> 00:41:26.140
It's using two brand new search capabilities
on the Web platform together, something that

00:41:26.140 --> 00:41:32.790
you probably maybe not hopefully didn't think
was possible, in streaming audio on the Web.

00:41:32.790 --> 00:41:46.579
No more plug-ins for this, you can do is now
using the Web platform.

00:41:46.579 --> 00:41:48.099
[ Music ]
So that was really quick.

00:41:48.099 --> 00:41:49.099
I covered a lot.

00:41:49.099 --> 00:41:54.089
I just want to point out that we did cover,
you know, sort of everything under the sun.

00:41:54.089 --> 00:41:56.980
The Web can do really amazing things, I hope
you do agree.

00:41:56.980 --> 00:42:02.740
CSS, whether it's the new CSS stuff for Web
application layout and design, doing data

00:42:02.740 --> 00:42:08.891
binding, doing things like file access, accessing
the native hardware, using -- officially transferring

00:42:08.891 --> 00:42:12.650
data once you have it in your Web app, and
then doing really awesome things with some

00:42:12.650 --> 00:42:17.130
of the older capabilities of HTML5 multi-media,
and also some of the newer stuff, combine

00:42:17.130 --> 00:42:21.520
those two with the integration points.

00:42:21.520 --> 00:42:23.270
Just want to point out, we have a Google+
developers page.

00:42:23.270 --> 00:42:28.060
If you guys want to know more about what Chrome
is doing with HTML5, and the open web, check

00:42:28.060 --> 00:42:29.060
that out.

00:42:29.060 --> 00:42:32.230
If you are not using Chrome Canary, or the
developer channel, Chrome really does heart

00:42:32.230 --> 00:42:33.490
HTML5.

00:42:33.490 --> 00:42:35.950
A lot of this stuff I just showed you again
is very new.

00:42:35.950 --> 00:42:38.760
So play with the new Chrome file bugs on new.crbug.com.

00:42:38.760 --> 00:42:41.020
Let us know what you think.

00:42:41.020 --> 00:42:42.660
Give us the feedback.

00:42:42.660 --> 00:42:47.390
This presentation will be up on my GitHub
account at HTML5can, as soon as I exit this

00:42:47.390 --> 00:42:48.390
stage.

00:42:48.390 --> 00:42:54.200
You can also access these slides at HTMLfive,
with the five spelled out, can.com.

00:42:54.200 --> 00:42:56.460
There's my social stuff if you want to follow
or Tweet at me.

00:42:56.460 --> 00:43:00.520
I'm happy to take questions here and I will
also be available after the show, as well

00:43:00.520 --> 00:43:01.680
as office hours tomorrow.

00:43:01.680 --> 00:43:02.960
Thanks, guys, appreciate your time.

00:43:02.960 --> 00:43:03.150
[ Applause ]

