WEBVTT
Kind: captions
Language: en

00:00:05.955 --> 00:00:07.580
AGUSTIN FONTS: Good
morning, everybody.

00:00:07.580 --> 00:00:09.715
My name is Agustin
Fonts, and I am

00:00:09.715 --> 00:00:13.280
a product manager on the
Android UI Framework Team.

00:00:13.280 --> 00:00:16.600
And if you're wondering, I do
work on Android text and fonts.

00:00:16.600 --> 00:00:19.930
And, yes, Fonts is
my real last name.

00:00:19.930 --> 00:00:23.450
So, with that out of
the way, let's begin.

00:00:23.450 --> 00:00:25.850
So today we want to
cover a few things.

00:00:25.850 --> 00:00:27.910
First we want to
convey how we think

00:00:27.910 --> 00:00:29.620
about APK size in
a couple of metrics

00:00:29.620 --> 00:00:31.780
that we think you
really should care

00:00:31.780 --> 00:00:33.627
about for the
success of your app.

00:00:33.627 --> 00:00:35.710
We'll also walk through a
series of best practices

00:00:35.710 --> 00:00:38.950
that are going to help you
reduce your APK size today,

00:00:38.950 --> 00:00:42.610
as well as show you a number
of new tools and features

00:00:42.610 --> 00:00:45.460
that we are going to introduce
this week that will also help

00:00:45.460 --> 00:00:47.470
you keep your APK size down.

00:00:47.470 --> 00:00:49.444
So let's get started.

00:00:49.444 --> 00:00:50.860
One of the things
you'll see today

00:00:50.860 --> 00:00:53.860
is that we have a really diverse
group of people from Google--

00:00:53.860 --> 00:00:56.800
people from the Android
team, from the tools team,

00:00:56.800 --> 00:00:59.339
from the Play team, internal
developers at Google.

00:00:59.339 --> 00:01:00.880
And the reason we
have so many people

00:01:00.880 --> 00:01:02.338
on stage with
different backgrounds

00:01:02.338 --> 00:01:05.710
is because we really think that
APK size is super important.

00:01:05.710 --> 00:01:08.140
And it's something that
we see as something you

00:01:08.140 --> 00:01:10.664
have to take care of from the
design stage, the time you

00:01:10.664 --> 00:01:12.580
build your app, the time
you publish your app,

00:01:12.580 --> 00:01:15.560
and the time that that app
gets delivered to a device.

00:01:15.560 --> 00:01:17.710
So let me tell you a
little bit about kind

00:01:17.710 --> 00:01:19.600
of the two dimensions
that we think

00:01:19.600 --> 00:01:21.370
are important for APK size.

00:01:21.370 --> 00:01:23.040
First is the download size.

00:01:23.040 --> 00:01:25.120
So this is the size
of the application

00:01:25.120 --> 00:01:26.620
when it's in the
Play Store and it

00:01:26.620 --> 00:01:28.450
gets delivered to the device.

00:01:28.450 --> 00:01:31.240
This is highly compressed-- and
we'll tell you more about how

00:01:31.240 --> 00:01:32.120
we do that--

00:01:32.120 --> 00:01:34.510
and that allows us to save
a lot of size on the wire

00:01:34.510 --> 00:01:37.150
and in user's data.

00:01:37.150 --> 00:01:41.020
Now, as we said, download
size is pretty small,

00:01:41.020 --> 00:01:43.660
but there's another
concept that's important,

00:01:43.660 --> 00:01:45.530
which is installed size.

00:01:45.530 --> 00:01:47.770
So installed size is what
happens when you actually

00:01:47.770 --> 00:01:51.340
download the app, unpack
it, and then compile it

00:01:51.340 --> 00:01:55.420
and optimize it, which expands
the application significantly,

00:01:55.420 --> 00:01:59.440
yielding a download size that
is sometimes two to three times

00:01:59.440 --> 00:02:01.237
even bigger than
the download size.

00:02:01.237 --> 00:02:03.070
And so it's something
to really think about,

00:02:03.070 --> 00:02:04.903
is what is the footprint
of your application

00:02:04.903 --> 00:02:08.429
going to be once it's
installed on the device?

00:02:08.429 --> 00:02:09.970
Now let's talk a
little bit about why

00:02:09.970 --> 00:02:12.219
you should care about both
download size and installed

00:02:12.219 --> 00:02:13.000
size.

00:02:13.000 --> 00:02:16.090
On the download size front, this
is something really important,

00:02:16.090 --> 00:02:18.920
because what happens is when a
user goes and installs an app,

00:02:18.920 --> 00:02:20.561
they're going to
see that loading bar

00:02:20.561 --> 00:02:23.060
and they're going to see the
actual size of the application.

00:02:23.060 --> 00:02:24.643
And what we see is
the larger the app,

00:02:24.643 --> 00:02:27.070
the more sort of user
regret that happens.

00:02:27.070 --> 00:02:29.380
And a lot of people will go
and actually back out of it

00:02:29.380 --> 00:02:29.990
and cancel.

00:02:29.990 --> 00:02:34.510
And so what we see is that up
to 20% of downloads fail or get

00:02:34.510 --> 00:02:36.820
canceled, rather,
when applications

00:02:36.820 --> 00:02:38.140
are over a hundred megabytes.

00:02:38.140 --> 00:02:40.360
And so you really want
to keep that download

00:02:40.360 --> 00:02:42.190
size small to
ensure that you get

00:02:42.190 --> 00:02:45.512
as much distribution for
your app as possible.

00:02:45.512 --> 00:02:47.470
The other one to think
about is installed size.

00:02:47.470 --> 00:02:50.740
Now installed size has a sort
of a similar phenomenon, right?

00:02:50.740 --> 00:02:54.410
So users are going to be filling
up their phones with photos,

00:02:54.410 --> 00:02:56.020
videos, and more applications.

00:02:56.020 --> 00:02:57.970
And at some point, they're going
to try to install a new app,

00:02:57.970 --> 00:02:58.930
and they're going
to realize that they

00:02:58.930 --> 00:03:00.071
don't have space for it.

00:03:00.071 --> 00:03:01.570
What's going to
happen at that point

00:03:01.570 --> 00:03:02.710
is they're going to go hunting.

00:03:02.710 --> 00:03:03.810
They're going to go
to their settings.

00:03:03.810 --> 00:03:05.050
They're going to look
through their apps.

00:03:05.050 --> 00:03:06.499
Or if their disk
is full and they

00:03:06.499 --> 00:03:08.290
try to download an app
from the Play Store,

00:03:08.290 --> 00:03:10.870
even the Play Store
will suggest that they

00:03:10.870 --> 00:03:12.910
remove some applications,
and they give them

00:03:12.910 --> 00:03:14.160
a list of suggestions.

00:03:14.160 --> 00:03:16.660
What we see here is that, again,
apps that are pretty large,

00:03:16.660 --> 00:03:18.850
especially a hundred
megabytes or above,

00:03:18.850 --> 00:03:22.880
are eight times more likely
to be removed from the device.

00:03:22.880 --> 00:03:25.270
So this is really going
to hurt your re-engagement

00:03:25.270 --> 00:03:28.630
if your app is more
likely to get uninstalled.

00:03:28.630 --> 00:03:32.530
So I hope that I've given you
a little bit of motivation

00:03:32.530 --> 00:03:35.740
to think twice, maybe three
times, about your APK size.

00:03:35.740 --> 00:03:38.381
Go back and think
about what you can do.

00:03:38.381 --> 00:03:40.630
And what we want to show you
today is a number of ways

00:03:40.630 --> 00:03:43.627
you can follow to
reduce that APK size.

00:03:43.627 --> 00:03:45.460
Some are going to be
existing practices that

00:03:45.460 --> 00:03:46.390
have been out there
for a while, and we're

00:03:46.390 --> 00:03:47.780
going to hope to
summarize and make

00:03:47.780 --> 00:03:48.970
them really compact for you.

00:03:48.970 --> 00:03:52.030
And others are new, and we're
going to show you those.

00:03:52.030 --> 00:03:53.920
So let's roll up our sleeves.

00:03:53.920 --> 00:03:56.200
We're going to be working
with the Topeka app.

00:03:56.200 --> 00:04:02.180
You may have seen it in our
code labs or sample apps.

00:04:02.180 --> 00:04:04.860
Topeka is a quiz
app, so it has a lot

00:04:04.860 --> 00:04:06.940
of resources, a lot of assets.

00:04:06.940 --> 00:04:09.970
It also has a good
chunk of dex code.

00:04:09.970 --> 00:04:12.530
This is what gets compiled
and expanded on devices.

00:04:12.530 --> 00:04:15.310
It's definitely a good
opportunity to tackle dex code

00:04:15.310 --> 00:04:18.469
and make it smaller due
to its outsize impact.

00:04:18.469 --> 00:04:20.260
In a typical production
app, you might also

00:04:20.260 --> 00:04:21.259
see some shared objects.

00:04:21.259 --> 00:04:23.110
This doesn't happen
in Topeka, but we'll

00:04:23.110 --> 00:04:24.610
cover a little bit
also what you can

00:04:24.610 --> 00:04:26.050
do with your shared objects.

00:04:26.050 --> 00:04:27.280
So at this point, I'd
like to hand it over

00:04:27.280 --> 00:04:29.770
to Shai, who's going to run
through a lot of these concepts

00:04:29.770 --> 00:04:31.310
and best practices in real time.

00:04:31.310 --> 00:04:33.580
So hopefully you see that
it's not too difficult,

00:04:33.580 --> 00:04:35.810
and it's something you
can do with your app.

00:04:35.810 --> 00:04:37.101
SHAI BARACK: Thanks, Mr. Fonts.

00:04:39.220 --> 00:04:42.520
So here we have our
app built and running.

00:04:42.520 --> 00:04:47.680
I can press Build
APK to get an APK,

00:04:47.680 --> 00:04:50.680
and then press Analyze
APK to crack it open

00:04:50.680 --> 00:04:52.190
and see what it's made of.

00:04:52.190 --> 00:04:54.500
I already have it open here.

00:04:54.500 --> 00:04:57.880
So an APK is just a
glorified zip file.

00:04:57.880 --> 00:05:00.580
Here we can see all
of its contents.

00:05:00.580 --> 00:05:04.390
We can browse through
the resources folder

00:05:04.390 --> 00:05:08.040
to see all of the large
drawables that really dominate

00:05:08.040 --> 00:05:10.740
the most bytes in our app.

00:05:10.740 --> 00:05:13.710
We can look at classes.dex--
that stands for Dalvik

00:05:13.710 --> 00:05:14.820
Executable--

00:05:14.820 --> 00:05:18.570
and see all the
code for our app,

00:05:18.570 --> 00:05:23.220
as well as of some
of our dependencies.

00:05:23.220 --> 00:05:25.920
We can even look
inside resources.arsc

00:05:25.920 --> 00:05:30.240
and see, for instance, all the
translatable strings and styles

00:05:30.240 --> 00:05:33.150
and dimensions and
other resources that

00:05:33.150 --> 00:05:35.100
end up in the resources.arsc.

00:05:35.100 --> 00:05:37.640
We can even look at the
AndroidManifest binary XML

00:05:37.640 --> 00:05:40.820
and decode that.

00:05:40.820 --> 00:05:43.830
Notice that there are two
columns with size information.

00:05:43.830 --> 00:05:46.350
First we have raw file size.

00:05:46.350 --> 00:05:48.930
This is how much
every particular item

00:05:48.930 --> 00:05:52.350
contributes to the size of
the APK as a file on disk.

00:05:52.350 --> 00:05:55.470
The second is download size,
which better represents

00:05:55.470 --> 00:05:57.900
how much bytes the
user will actually

00:05:57.900 --> 00:06:00.210
have to download from
Play in order to install

00:06:00.210 --> 00:06:02.430
your app for the first time.

00:06:02.430 --> 00:06:05.520
Now you'll see, for
instance, that for resources

00:06:05.520 --> 00:06:07.860
these numbers aren't
very far apart,

00:06:07.860 --> 00:06:11.130
because resources are
dominated by large PNGs

00:06:11.130 --> 00:06:12.600
we have for drawables.

00:06:12.600 --> 00:06:15.150
These don't benefit from
further compression.

00:06:15.150 --> 00:06:18.930
Whereas for some other items,
entropy is typically lower,

00:06:18.930 --> 00:06:20.805
and so the gains from
compression are higher.

00:06:23.370 --> 00:06:25.380
We're going to show
you a bunch of tricks

00:06:25.380 --> 00:06:28.900
you can use for this
particular app, which we're

00:06:28.900 --> 00:06:31.470
going to use right now
on stage, and we're

00:06:31.470 --> 00:06:33.720
going to show you their
impact on the app size.

00:06:33.720 --> 00:06:37.050
For your own app,
your mileage may vary.

00:06:37.050 --> 00:06:40.080
Rather than memorizing
these particular steps,

00:06:40.080 --> 00:06:42.480
if there's one lesson
that you should take home

00:06:42.480 --> 00:06:45.570
from this talk, it's that
optimizing your own app size

00:06:45.570 --> 00:06:48.000
begins with sort of
finding out what's in it

00:06:48.000 --> 00:06:49.850
and tailoring to that.

00:06:49.850 --> 00:06:50.700
All right?

00:06:50.700 --> 00:06:54.920
So first step we're going
to take is to use ProGuard.

00:06:54.920 --> 00:06:59.450
ProGuard is enabled by
default for release builds,

00:06:59.450 --> 00:07:02.210
and it's a whole
program Java optimizer.

00:07:04.860 --> 00:07:08.380
What it does is
basically three things.

00:07:08.380 --> 00:07:11.190
So one thing it does is
it optimizes your code

00:07:11.190 --> 00:07:13.470
in ways that don't
change the functionality

00:07:13.470 --> 00:07:16.620
but do change the representation
to make it more compact.

00:07:16.620 --> 00:07:19.110
For instance, it might
inline certain methods

00:07:19.110 --> 00:07:21.960
to their call sites if it's
deemed to be more efficient.

00:07:21.960 --> 00:07:23.970
In some cases, it is.

00:07:23.970 --> 00:07:25.680
Another thing it
does is it obfuscates

00:07:25.680 --> 00:07:29.100
names of types and
methods and fields,

00:07:29.100 --> 00:07:33.240
where the original name doesn't
matter so that long names are

00:07:33.240 --> 00:07:36.330
replaced with short strings
like a and b for efficiency.

00:07:36.330 --> 00:07:37.920
I know we all like
to give our Java

00:07:37.920 --> 00:07:40.170
classes long names
in our packages,

00:07:40.170 --> 00:07:43.080
but they shouldn't get
in the way of efficiency.

00:07:43.080 --> 00:07:45.149
And then lastly, there's
dead code elimination.

00:07:45.149 --> 00:07:47.190
Now, this is the most
important role of ProGuard,

00:07:47.190 --> 00:07:48.990
so pay attention.

00:07:48.990 --> 00:07:53.490
Think of your program as a graph
of classes, methods, and fields

00:07:53.490 --> 00:07:58.380
as nodes, and calls or
references as edges.

00:07:58.380 --> 00:08:01.400
So Android apps have
well known entry points

00:08:01.400 --> 00:08:04.470
at activities, services,
broadcast receivers,

00:08:04.470 --> 00:08:06.840
content providers,
and optionally

00:08:06.840 --> 00:08:09.150
a custom application class.

00:08:09.150 --> 00:08:11.580
If these classes are
in your app manifest,

00:08:11.580 --> 00:08:13.530
then the platform
can call into them.

00:08:13.530 --> 00:08:16.170
So ProGuard marks them
as live because this code

00:08:16.170 --> 00:08:18.660
can execute at run time, right?

00:08:18.660 --> 00:08:20.640
ProGuard then
propagates liveness

00:08:20.640 --> 00:08:22.830
across the program
via references.

00:08:22.830 --> 00:08:26.040
So it's basically a tree
exploration sort of algorithm,

00:08:26.040 --> 00:08:28.470
and anything that is
reachable from those seeds

00:08:28.470 --> 00:08:31.050
is considered live.

00:08:31.050 --> 00:08:33.390
Then whatever code remains,
the complement to that

00:08:33.390 --> 00:08:36.809
is presumed dead and will
be deleted from your app

00:08:36.809 --> 00:08:38.700
unless you specify otherwise.

00:08:38.700 --> 00:08:41.140
This is important
to be aware of.

00:08:41.140 --> 00:08:42.750
So let's look at
the impact of that.

00:08:45.950 --> 00:08:48.550
Here's what happens when
we run ProGuard on Topeka.

00:08:48.550 --> 00:08:51.710
You'll see that most of the
code is now completely gone.

00:08:51.710 --> 00:08:54.790
So, for instance, if I look
at the support library here,

00:08:54.790 --> 00:08:58.255
I see that it's considerably
smaller than it was before.

00:09:01.960 --> 00:09:04.710
We can also get these results
using the APK analyzer.

00:09:04.710 --> 00:09:07.600
We can compare one
APK with another.

00:09:07.600 --> 00:09:12.030
Here we have numbers
in raw APK size.

00:09:12.030 --> 00:09:14.916
And over in the
charts on the slides

00:09:14.916 --> 00:09:16.040
I have it as download size.

00:09:16.040 --> 00:09:18.480
Thought you'd appreciate that.

00:09:18.480 --> 00:09:20.370
So if we look closely
inside a dex file,

00:09:20.370 --> 00:09:22.650
you'll see what I
just showed you,

00:09:22.650 --> 00:09:24.590
that most of the support
library code is gone,

00:09:24.590 --> 00:09:29.160
and most of the rest
is obfuscated, right?

00:09:29.160 --> 00:09:30.550
So what is going on?

00:09:30.550 --> 00:09:31.773
Why is this happening?

00:09:34.440 --> 00:09:35.280
There we go.

00:09:35.280 --> 00:09:37.020
Why is this happening?

00:09:37.020 --> 00:09:38.814
ProGuard allows
you to choose what

00:09:38.814 --> 00:09:40.980
libraries you want to use
without having to worry so

00:09:40.980 --> 00:09:43.110
much about all this stuff in the
libraries that you don't need,

00:09:43.110 --> 00:09:44.940
and how it might
bloat your app size.

00:09:44.940 --> 00:09:48.240
In this case, we're using the
support library, v4 and v7,

00:09:48.240 --> 00:09:51.810
and notifications and design,
and all kinds of assets.

00:09:51.810 --> 00:09:54.534
And we're only using a subset
of the support library,

00:09:54.534 --> 00:09:55.950
so everything we're
not using just

00:09:55.950 --> 00:10:00.150
gets torn away at build
time and eliminated.

00:10:00.150 --> 00:10:03.720
Now some of you might be
thinking, this is nice.

00:10:03.720 --> 00:10:05.760
It's a nice benefit,
but the optimizations

00:10:05.760 --> 00:10:07.770
make debugging more
difficult. So hold

00:10:07.770 --> 00:10:10.920
that thought until
the next demo.

00:10:10.920 --> 00:10:13.920
What we've done for code, we
can do for resources as well.

00:10:13.920 --> 00:10:15.360
Same principle here.

00:10:15.360 --> 00:10:19.140
Resource shrinking extends the
concept of ProGuard's dead code

00:10:19.140 --> 00:10:21.160
elimination to resources.

00:10:21.160 --> 00:10:23.370
So in this example,
drawables whose references

00:10:23.370 --> 00:10:27.240
are reachable from live
code are kept in your APK,

00:10:27.240 --> 00:10:29.325
and then everything
else is deleted.

00:10:33.660 --> 00:10:40.410
Now our app is
almost 4x smaller,

00:10:40.410 --> 00:10:42.450
and this is no mistake.

00:10:42.450 --> 00:10:44.430
All we've done is tweak
two lines of Gradle,

00:10:44.430 --> 00:10:47.430
but what we get is,
once again, things

00:10:47.430 --> 00:10:49.560
that go into sort of
the transitive closure

00:10:49.560 --> 00:10:51.330
of dependencies of
our app but are not

00:10:51.330 --> 00:10:53.527
actually useful to the app.

00:10:53.527 --> 00:10:55.110
So once again, this
is due to features

00:10:55.110 --> 00:10:57.120
included in our dependencies
that we don't need.

00:10:57.120 --> 00:10:59.536
The support libraries in this
case contain a lot of design

00:10:59.536 --> 00:11:01.890
assets that you could
use, but Topeka isn't.

00:11:01.890 --> 00:11:05.490
So we can just make all
the dead weight go away.

00:11:05.490 --> 00:11:07.210
But we can do even better.

00:11:07.210 --> 00:11:13.770
So if you recall, we saw that
in the resource folder when

00:11:13.770 --> 00:11:15.720
we were looking with
the APK analyzer,

00:11:15.720 --> 00:11:18.420
we have drawables for
different screen densities.

00:11:18.420 --> 00:11:19.800
What's going on?

00:11:19.800 --> 00:11:22.530
The Android ecosystem
is diverse with support

00:11:22.530 --> 00:11:25.020
for different displays
and different CPU

00:11:25.020 --> 00:11:27.690
types and other such things.

00:11:27.690 --> 00:11:30.660
By default, when you build
an APK with all the material

00:11:30.660 --> 00:11:33.390
to service as many
devices as possible,

00:11:33.390 --> 00:11:35.340
we call that the Universal APK.

00:11:35.340 --> 00:11:38.160
You get a larger APK than
what's actually needed

00:11:38.160 --> 00:11:40.050
on each particular device.

00:11:40.050 --> 00:11:42.270
Every specific device
that runs your app

00:11:42.270 --> 00:11:44.456
will only use files for
its particular density.

00:11:44.456 --> 00:11:45.830
And if you have
native code, then

00:11:45.830 --> 00:11:47.820
for its particular
CPU architecture

00:11:47.820 --> 00:11:51.060
and other such things
that APKs can vary on.

00:11:51.060 --> 00:11:54.990
Fortunately, you can split your
build across these dimensions,

00:11:54.990 --> 00:11:59.070
and then upload multiple APKs
to Play, each one tailored

00:11:59.070 --> 00:12:02.310
to a particular device type.

00:12:02.310 --> 00:12:05.970
Here we intentionally look
at the APK build for xxhdpi

00:12:05.970 --> 00:12:10.320
density screens, which contains
the largest PNGs, because this

00:12:10.320 --> 00:12:12.480
is the largest APK
that we're building

00:12:12.480 --> 00:12:14.620
for this app in this example.

00:12:14.620 --> 00:12:17.190
You will see that the difference
is significant even when

00:12:17.190 --> 00:12:20.915
comparing the Universal APK to
the largest split that we have.

00:12:20.915 --> 00:12:22.290
And, of course,
the difference is

00:12:22.290 --> 00:12:26.340
more pronounced for
hdpi and dpi, et cetera.

00:12:26.340 --> 00:12:28.260
Speaking of PNGs
and densities, we

00:12:28.260 --> 00:12:30.240
can do even better
with vector drawables.

00:12:30.240 --> 00:12:31.230
Tell them, Gus.

00:12:31.230 --> 00:12:32.749
AGUSTIN FONTS: Thanks, Shai.

00:12:32.749 --> 00:12:34.290
So now we just saw
that there's a way

00:12:34.290 --> 00:12:37.230
to deliver a smaller app by
chunking it up and delivering

00:12:37.230 --> 00:12:38.550
multiple of those apps.

00:12:38.550 --> 00:12:41.490
Now that's a great
benefit to APK size,

00:12:41.490 --> 00:12:44.370
but it does come at a cost for
your build process, as well

00:12:44.370 --> 00:12:47.310
as your QA process, and that
might be something that you're

00:12:47.310 --> 00:12:49.720
not quite ready to get into.

00:12:49.720 --> 00:12:51.600
So there's an
additional approach

00:12:51.600 --> 00:12:54.240
you can follow to reduce
the amount of size

00:12:54.240 --> 00:12:58.170
you carry with your assets, and
that's to use vector drawables.

00:12:58.170 --> 00:13:00.847
Vector drawables
would-- basically

00:13:00.847 --> 00:13:02.680
it's serving a vector
into your application.

00:13:02.680 --> 00:13:04.620
So there's a single
asset that can serve up

00:13:04.620 --> 00:13:06.390
all of the densities.

00:13:06.390 --> 00:13:08.370
For this particular
asset on screen,

00:13:08.370 --> 00:13:10.380
the vector drawable
is actually smaller

00:13:10.380 --> 00:13:14.437
than the smallest density
PNG, so it's quite nice.

00:13:14.437 --> 00:13:16.020
And this is, I would
consider it to be

00:13:16.020 --> 00:13:18.240
kind of a medium complexity
vector with somewhat

00:13:18.240 --> 00:13:21.600
complex paths, but not
necessarily gradients

00:13:21.600 --> 00:13:23.045
and things like that.

00:13:23.045 --> 00:13:25.170
The thing that makes, I
think, vector drawable very

00:13:25.170 --> 00:13:29.200
usable and exciting today is
that in Support Library 23.2,

00:13:29.200 --> 00:13:31.230
we introduced support
for vector drawables

00:13:31.230 --> 00:13:34.350
backwards compatible
all the way to API 14.

00:13:34.350 --> 00:13:37.000
Also, within, we
introduced gradient support

00:13:37.000 --> 00:13:38.940
of vector drawable,
so hopefully that

00:13:38.940 --> 00:13:41.200
gives you kind of a
wider range of things

00:13:41.200 --> 00:13:42.420
you can do with vectors.

00:13:42.420 --> 00:13:44.670
Now one thing to keep
in mind with vectors

00:13:44.670 --> 00:13:48.750
is that they can increase
your RAM and CPU load,

00:13:48.750 --> 00:13:51.190
especially when you first
start up the application.

00:13:51.190 --> 00:13:53.230
So if you have an app that is--

00:13:53.230 --> 00:13:55.314
sorry, a series of assets
that are pretty complex,

00:13:55.314 --> 00:13:57.771
then you probably want to do
kind of a bit of a performance

00:13:57.771 --> 00:13:59.250
test and make sure
that you're not

00:13:59.250 --> 00:14:03.140
sacrificing a lot of performance
in exchange for a smaller app

00:14:03.140 --> 00:14:04.920
size.

00:14:04.920 --> 00:14:06.270
Now let's look at the savings.

00:14:06.270 --> 00:14:08.130
After substituting
most of the PNGs

00:14:08.130 --> 00:14:10.200
with vector assets,
which this app is

00:14:10.200 --> 00:14:12.930
very good at because it's all
flat images with relatively

00:14:12.930 --> 00:14:15.060
low complexity, we see
that vector drawables

00:14:15.060 --> 00:14:17.914
is a little bit
better than multi-APK.

00:14:17.914 --> 00:14:19.830
That kind of makes sense,
right, because we're

00:14:19.830 --> 00:14:23.389
carrying just a single
asset in the application.

00:14:23.389 --> 00:14:24.930
Our advice would be
that you consider

00:14:24.930 --> 00:14:27.240
what kind of image assets
are in your application.

00:14:27.240 --> 00:14:29.730
So if they are relatively
simple and flat,

00:14:29.730 --> 00:14:31.440
you should definitely
consider it.

00:14:31.440 --> 00:14:34.200
And then that also
simplifies your build and QA

00:14:34.200 --> 00:14:37.590
process so that you only have
to produce one APK to upload

00:14:37.590 --> 00:14:38.490
to Play.

00:14:38.490 --> 00:14:42.746
So let me hand it back to Shai
for one more best practice.

00:14:42.746 --> 00:14:43.620
SHAI BARACK: Awesome.

00:14:43.620 --> 00:14:44.820
Thanks.

00:14:44.820 --> 00:14:47.130
So finally, we're going
to see a specialized

00:14:47.130 --> 00:14:49.590
trick for resources.arsc.

00:14:49.590 --> 00:14:51.770
That's Topeka's ARSC file.

00:14:51.770 --> 00:14:55.210
So Topeka's ARSC file,
as we saw, is small,

00:14:55.210 --> 00:14:59.010
but we'll make it 2x smaller
with one line, because we can.

00:15:08.980 --> 00:15:11.920
So here you can look
inside the ARSC file

00:15:11.920 --> 00:15:13.870
and view all the
strings translation,

00:15:13.870 --> 00:15:15.375
and also here live on stage.

00:15:26.650 --> 00:15:31.510
Now you'll notice that some
strings only appear in English.

00:15:31.510 --> 00:15:35.920
For instance, there's going to
be sign in here and sign out,

00:15:35.920 --> 00:15:41.120
but other strings have as many
as 82 translations for them.

00:15:41.120 --> 00:15:42.730
Why is this happening?

00:15:42.730 --> 00:15:45.160
So the Support Library
folks went out of their way

00:15:45.160 --> 00:15:46.960
to localize your strings.

00:15:46.960 --> 00:15:49.150
And kudos to them because
this is the right thing

00:15:49.150 --> 00:15:50.950
for a library to do.

00:15:50.950 --> 00:15:52.540
A lot of apps go
to similar lengths

00:15:52.540 --> 00:15:54.956
to translate their own strings,
and you want the libraries

00:15:54.956 --> 00:15:57.200
to kind of line up so
that the app isn't half

00:15:57.200 --> 00:15:59.140
translated, right?

00:15:59.140 --> 00:16:00.279
Not the case with Topeka.

00:16:00.279 --> 00:16:02.320
It didn't bother with
anything but English, which

00:16:02.320 --> 00:16:04.660
is typical of our sample apps.

00:16:04.660 --> 00:16:08.410
Translating your app is a good
way to reach out to more users,

00:16:08.410 --> 00:16:11.140
and we absolutely
encourage that.

00:16:11.140 --> 00:16:12.820
Google translates
all of its apps

00:16:12.820 --> 00:16:16.540
to as many languages as this,
but a half-translated app

00:16:16.540 --> 00:16:20.020
can make a poor user experience.

00:16:20.020 --> 00:16:23.860
And then what's worse is
these empty spaces actually

00:16:23.860 --> 00:16:27.760
use up bytes in our ARSC
file by indicating no entries

00:16:27.760 --> 00:16:30.160
across 82 locales
for all the strings

00:16:30.160 --> 00:16:32.316
that weren't translated.

00:16:32.316 --> 00:16:33.440
So what are we going to do?

00:16:33.440 --> 00:16:35.500
We're going to get rid of them.

00:16:35.500 --> 00:16:39.790
And we can fix all of this by
simply stating that we only

00:16:39.790 --> 00:16:42.140
want to retain English
strings, and then all

00:16:42.140 --> 00:16:46.960
the half translations
just disappear right out.

00:16:46.960 --> 00:16:49.280
So I know this is hard
to see the difference,

00:16:49.280 --> 00:16:50.950
but if you look
under your seats,

00:16:50.950 --> 00:16:54.880
you will find a pair
of binoculars each.

00:16:54.880 --> 00:16:56.980
Made you look.

00:16:56.980 --> 00:16:59.840
As promised, ARSC
is now 2x smaller.

00:16:59.840 --> 00:17:02.410
Although, in the big picture,
this doesn't do much since

00:17:02.410 --> 00:17:04.010
it was small to begin with.

00:17:04.010 --> 00:17:08.260
On the other hand, I've seen
real apps that are 40% ARSC.

00:17:08.260 --> 00:17:09.020
True story.

00:17:09.020 --> 00:17:11.930
So once again, your
mileage may vary.

00:17:11.930 --> 00:17:14.170
Now let's take a look back
and appreciate the fact

00:17:14.170 --> 00:17:17.740
that our Topeka app is
now 5x smaller than when

00:17:17.740 --> 00:17:20.740
we started-- over 5x, in fact--
and it's not even 10:00 AM.

00:17:24.121 --> 00:17:25.579
[APPLAUSE]

00:17:25.579 --> 00:17:26.109
Thank you.

00:17:26.109 --> 00:17:26.740
Thank you.

00:17:26.740 --> 00:17:27.240
Thank you.

00:17:27.240 --> 00:17:31.770
[APPLAUSE]

00:17:31.770 --> 00:17:35.140
What I've shown you so far is
all existing functionality.

00:17:35.140 --> 00:17:37.620
Now I'll hand it over
to Clara to tell us

00:17:37.620 --> 00:17:39.819
about some new stuff.

00:17:39.819 --> 00:17:41.110
CLARA BAYARRI: Thank you, Shai.

00:17:41.110 --> 00:17:42.909
SHAI BARACK: New stuff, Clara.

00:17:42.909 --> 00:17:44.450
CLARA BAYARRI: Hi,
I'm Clara Bayarri.

00:17:44.450 --> 00:17:46.740
I'm a tech lead on the
Android UI Toolkit Team,

00:17:46.740 --> 00:17:48.120
and I work on fonts.

00:17:48.120 --> 00:17:50.460
So here I'm very excited
to introduce, today we're

00:17:50.460 --> 00:17:52.410
presenting downloadable fonts.

00:17:52.410 --> 00:17:54.720
Fonts are a source of bloat
for apps, and we know that.

00:17:54.720 --> 00:17:55.630
They're heavy files.

00:17:55.630 --> 00:17:57.630
They're stuck into your
app, and you need them

00:17:57.630 --> 00:17:59.520
because you need it for your UX.

00:17:59.520 --> 00:18:00.450
That's fine.

00:18:00.450 --> 00:18:02.514
We figured out that,
actually, most fonts

00:18:02.514 --> 00:18:03.930
that you are
bundling in your apps

00:18:03.930 --> 00:18:05.940
are not even
optimized for mobile.

00:18:05.940 --> 00:18:09.150
So about half of the file
size that you're adding

00:18:09.150 --> 00:18:12.480
is not even something we're
going to use in Android.

00:18:12.480 --> 00:18:14.160
So that's a shame.

00:18:14.160 --> 00:18:16.390
Also, we looked
at the Play Store,

00:18:16.390 --> 00:18:19.700
and we figured out that the top
25 apps that bundle fonts are

00:18:19.700 --> 00:18:21.720
actually bundling
about an average of 500

00:18:21.720 --> 00:18:25.250
kilobytes in fonts that we own
in the Google Fonts catalog.

00:18:25.250 --> 00:18:27.750
We're like, OK, we should be
able to do something with that,

00:18:27.750 --> 00:18:28.320
right?

00:18:28.320 --> 00:18:29.970
Never mind the fact
that several apps

00:18:29.970 --> 00:18:32.303
are bundling the same fonts,
and you're duplicating them

00:18:32.303 --> 00:18:34.090
in your device.

00:18:34.090 --> 00:18:36.409
So that's where
downloadable fonts comes in.

00:18:36.409 --> 00:18:38.200
You've typically bundled
fonts in your app,

00:18:38.200 --> 00:18:40.560
and that causes your
APK size to increase.

00:18:40.560 --> 00:18:43.350
With downloadable fonts,
we're introducing the concept

00:18:43.350 --> 00:18:44.780
of a fonts provider.

00:18:44.780 --> 00:18:45.600
There you go.

00:18:45.600 --> 00:18:46.420
Ah.

00:18:46.420 --> 00:18:47.530
Can we go back, please?

00:18:47.530 --> 00:18:49.035
There you go.

00:18:49.035 --> 00:18:52.500
Fonts provider is a separate
app that is not yours that is--

00:18:52.500 --> 00:18:55.530
its own mission is to
fetch fonts for you,

00:18:55.530 --> 00:18:58.600
cache them, and serve them
to you when you need them.

00:18:58.600 --> 00:19:00.930
This means that you can stop
bundling fonts in your app

00:19:00.930 --> 00:19:03.390
and trust the font
provider to do it for you.

00:19:03.390 --> 00:19:05.550
The way this works
is all apps can just

00:19:05.550 --> 00:19:08.520
contact the font provider
via the font's contract APIs.

00:19:08.520 --> 00:19:10.290
These are available
in Android O,

00:19:10.290 --> 00:19:13.200
and in Support
Library 26-beta 1.

00:19:13.200 --> 00:19:15.720
By doing this, all of the apps
are contacting the same font

00:19:15.720 --> 00:19:19.170
provider, which means we
have one copy of the font

00:19:19.170 --> 00:19:21.870
that all apps are
using at the same time.

00:19:21.870 --> 00:19:23.010
What does this mean really?

00:19:23.010 --> 00:19:25.051
Well, it means we save
memory, because we're only

00:19:25.051 --> 00:19:26.760
loading the font
once and sharing

00:19:26.760 --> 00:19:28.770
that memory between all apps.

00:19:28.770 --> 00:19:31.470
We're also saving APK
size for all of these apps

00:19:31.470 --> 00:19:34.680
because they don't have
to bundle the font.

00:19:34.680 --> 00:19:36.420
We just have one copy.

00:19:36.420 --> 00:19:38.430
We're obviously saving
disk space for the user

00:19:38.430 --> 00:19:39.994
because all of your
apps are smaller.

00:19:39.994 --> 00:19:42.660
And we're also saving network if
you are actually fetching fonts

00:19:42.660 --> 00:19:44.909
from the network, as only
the font provider is the one

00:19:44.909 --> 00:19:47.730
responsible for pitching these.

00:19:47.730 --> 00:19:49.800
This is available in
Support Library today.

00:19:49.800 --> 00:19:52.660
And I'm very proud to announce
our very first font provider,

00:19:52.660 --> 00:19:53.580
which is available.

00:19:53.580 --> 00:19:56.038
It's a great collaboration
we've done with the Google Fonts

00:19:56.038 --> 00:19:58.770
Team, where we're providing the
entire Google Fonts catalog--

00:19:58.770 --> 00:20:00.800
and that is 800 fonts--

00:20:00.800 --> 00:20:03.930
available to your app to
use free from APK size.

00:20:03.930 --> 00:20:05.230
Isn't that amazing?

00:20:05.230 --> 00:20:07.590
That is done through
Google Play services.

00:20:07.590 --> 00:20:08.700
It has a tiny caveat.

00:20:08.700 --> 00:20:10.396
This is in Google
Play Services v11,

00:20:10.396 --> 00:20:11.520
which is currently in beta.

00:20:14.190 --> 00:20:15.930
Next I want to hand
it over to Wojtek

00:20:15.930 --> 00:20:18.660
to give you a very
smooth demo of how

00:20:18.660 --> 00:20:21.670
Android Studio has integrated
with downloadable fonts.

00:20:21.670 --> 00:20:23.170
WOJTEK KALICINSKI:
Thank you, Clara.

00:20:23.170 --> 00:20:25.110
[APPLAUSE]

00:20:30.930 --> 00:20:32.480
So hi, everyone.

00:20:32.480 --> 00:20:33.230
My name is Wojtek.

00:20:33.230 --> 00:20:35.660
I'm a developer advocate working
closely with the Android Studio

00:20:35.660 --> 00:20:37.310
Team, and today I
want to walk you

00:20:37.310 --> 00:20:39.726
through some of the new features
we have in Android Studio

00:20:39.726 --> 00:20:41.810
and Tools that are
relevant to APK size

00:20:41.810 --> 00:20:44.390
and hopefully will let you
keep your APK size down.

00:20:44.390 --> 00:20:47.150
So as Clara explained,
downloadable fonts

00:20:47.150 --> 00:20:50.810
are a great way to make your
apps look pretty without adding

00:20:50.810 --> 00:20:52.365
the bloat to your APK.

00:20:52.365 --> 00:20:54.740
So let me show you how easy
we can add downloadable fonts

00:20:54.740 --> 00:20:56.570
to your apps in Android Studio.

00:20:56.570 --> 00:20:58.730
So here I have open
one of the layout files

00:20:58.730 --> 00:21:00.389
from the Topeka app.

00:21:00.389 --> 00:21:02.180
And you can see if I
click on the Text View

00:21:02.180 --> 00:21:04.490
here on the right in
the layout inspector,

00:21:04.490 --> 00:21:07.040
I can actually go
and change the fonts.

00:21:07.040 --> 00:21:08.420
So I scroll down.

00:21:08.420 --> 00:21:09.950
And if I select More Fonts--

00:21:09.950 --> 00:21:12.620
there's this new picker
in Android Studio 3.0

00:21:12.620 --> 00:21:14.330
that we just
announced yesterday--

00:21:14.330 --> 00:21:16.700
and you can see
here, you have access

00:21:16.700 --> 00:21:20.060
to literally hundreds of fonts
from the Google Fonts catalog.

00:21:20.060 --> 00:21:23.300
And if I could just
choose one, here I

00:21:23.300 --> 00:21:26.420
can select the
downloadable font.

00:21:26.420 --> 00:21:29.720
I can see the font immediately
change in the preview.

00:21:29.720 --> 00:21:31.850
But then, what's
more, Android Studio

00:21:31.850 --> 00:21:34.500
also includes support
for binary and XML fonts

00:21:34.500 --> 00:21:39.050
project structure, and see
your preview or edit it.

00:21:39.050 --> 00:21:40.040
So that's one thing.

00:21:40.040 --> 00:21:43.450
But when we're on the
topic of resources,

00:21:43.450 --> 00:21:46.070
we are also making changes
to AAPT, which is the Android

00:21:46.070 --> 00:21:47.390
Asset Packaging Tool.

00:21:47.390 --> 00:21:49.580
This is the part
of the build system

00:21:49.580 --> 00:21:53.450
that processes and packages all
your resources into the APK.

00:21:53.450 --> 00:21:56.780
And with Android Studio 3.0, we
are introducing a new version

00:21:56.780 --> 00:22:01.370
of AAPT, AAPT 2, which has a
few neat tricks for reducing

00:22:01.370 --> 00:22:03.170
your APK size.

00:22:03.170 --> 00:22:08.000
So first up, we have something
we call version collapsing.

00:22:08.000 --> 00:22:10.250
So normally, when
you develop an app,

00:22:10.250 --> 00:22:13.580
you add resources for
various versions of Android.

00:22:13.580 --> 00:22:15.590
Typically, you want to
have different colors

00:22:15.590 --> 00:22:18.290
or different styles for
the different versions

00:22:18.290 --> 00:22:19.370
of the platform.

00:22:19.370 --> 00:22:21.400
And that also
happens, for example,

00:22:21.400 --> 00:22:23.390
in the Support Library,
which you normally

00:22:23.390 --> 00:22:24.860
bring into your apps.

00:22:24.860 --> 00:22:28.280
But as you develop your
app, and time passes,

00:22:28.280 --> 00:22:31.310
you normally start raising
your min SDK version and kind

00:22:31.310 --> 00:22:35.360
of restricting the versions of
Android that your apps run on.

00:22:35.360 --> 00:22:37.070
But these resources
still remain,

00:22:37.070 --> 00:22:40.970
especially if they come
from external dependencies,

00:22:40.970 --> 00:22:44.160
so they take up unnecessary
space in your APK.

00:22:44.160 --> 00:22:48.140
So with AAPT 2, we are
introducing version collapsing,

00:22:48.140 --> 00:22:51.200
where AAPT2 can actually figure
out the min SDK of your app

00:22:51.200 --> 00:22:53.960
and get rid of all these
resources that are unneeded.

00:22:53.960 --> 00:22:56.240
And what's more, it can
collapse the configurations

00:22:56.240 --> 00:22:58.700
in your app to reduce
the size of the resources

00:22:58.700 --> 00:23:00.440
file even further,
only including

00:23:00.440 --> 00:23:04.130
the resources that you
actually will need.

00:23:04.130 --> 00:23:07.020
Next up, we have
resource deduplication.

00:23:07.020 --> 00:23:08.720
So another example.

00:23:08.720 --> 00:23:11.900
Here I'm showing different
translations for your app.

00:23:11.900 --> 00:23:14.420
And it happens sometimes
that for some languages

00:23:14.420 --> 00:23:16.280
for some configurations,
like here--

00:23:16.280 --> 00:23:18.530
French and French Canadian--

00:23:18.530 --> 00:23:20.930
mostly the translations
will be the same.

00:23:20.930 --> 00:23:23.270
Most of the words
are exactly the same,

00:23:23.270 --> 00:23:25.160
except for just a few.

00:23:25.160 --> 00:23:27.410
And it doesn't make
sense to actually keep

00:23:27.410 --> 00:23:31.210
these duplicate resources
in the resources file.

00:23:31.210 --> 00:23:33.590
So what AAPT2 will
do now is it will

00:23:33.590 --> 00:23:36.140
find those duplicate
resources, get rid of them,

00:23:36.140 --> 00:23:41.500
and let the system default
to the default configuration.

00:23:41.500 --> 00:23:44.780
So this is version collapsing
and resource deduplication.

00:23:44.780 --> 00:23:48.830
AAPT2 does a couple of
more internal things.

00:23:48.830 --> 00:23:51.570
Like, it starts
using UTF-8 for text,

00:23:51.570 --> 00:23:54.330
for string resources
included in XML files,

00:23:54.330 --> 00:23:56.866
like layouts and the
binary resources file.

00:23:56.866 --> 00:23:59.130
It has a smarter cruncher.

00:23:59.130 --> 00:24:01.530
This is the part that reduces
the size of your images

00:24:01.530 --> 00:24:02.670
by optimizing them.

00:24:02.670 --> 00:24:04.770
And if it finds that
your images are actually

00:24:04.770 --> 00:24:08.550
already pre-optimized and
the output of AAPT2 crunching

00:24:08.550 --> 00:24:11.490
would be bigger, then it just
discards those bigger versions

00:24:11.490 --> 00:24:12.680
and uses smaller ones.

00:24:15.750 --> 00:24:20.980
So we aim to enable AAPT2 as the
default in Android Studio 3.0

00:24:20.980 --> 00:24:22.090
stable.

00:24:22.090 --> 00:24:24.900
However, you can try it now
with the [INAUDIBLE] release.

00:24:24.900 --> 00:24:27.090
All you have to do
is add this one line

00:24:27.090 --> 00:24:29.400
to your Gradle properties file.

00:24:29.400 --> 00:24:31.740
So I encourage you
to try it, and reduce

00:24:31.740 --> 00:24:34.020
the size of your APKs
without doing anything.

00:24:37.050 --> 00:24:40.260
So, like I said, you don't have
to change a single line of code

00:24:40.260 --> 00:24:42.900
when you use AAPT2, but
sometimes that's not enough.

00:24:42.900 --> 00:24:45.600
Sometimes you actually want
to go in, and in fact--

00:24:45.600 --> 00:24:48.255
and change things
in your app, and you

00:24:48.255 --> 00:24:51.210
need tools to help
you make decisions

00:24:51.210 --> 00:24:54.670
of where to actually go and
make those optimizations.

00:24:54.670 --> 00:24:58.410
So, like Shai mentioned before,
one of the biggest changes

00:24:58.410 --> 00:25:00.690
you can make to your
app to reduce APK size

00:25:00.690 --> 00:25:04.830
is enable ProGuard to shrink
away code and resources.

00:25:04.830 --> 00:25:08.550
But when talking to developers
at conferences like this,

00:25:08.550 --> 00:25:10.980
I often hear that it's
very difficult to debug

00:25:10.980 --> 00:25:12.870
build problems and
run time problems that

00:25:12.870 --> 00:25:16.140
can stem from enabling
ProGuard in your apps.

00:25:16.140 --> 00:25:18.000
And developers
were really lacking

00:25:18.000 --> 00:25:20.970
tools that will let them inspect
those problems in detail.

00:25:20.970 --> 00:25:23.220
That's why we were making
some improvements to the APK

00:25:23.220 --> 00:25:24.870
analyzer in Android Studio.

00:25:24.870 --> 00:25:27.054
Let me show you on an example.

00:25:27.054 --> 00:25:28.470
Can we switch to
the demo, please?

00:25:31.200 --> 00:25:33.170
So here I have Android
Studio 3.0 kind

00:25:33.170 --> 00:25:35.910
of running on my machine.

00:25:35.910 --> 00:25:40.319
And one of the first things--

00:25:40.319 --> 00:25:42.360
sorry, I'm going to walk
you through a few things

00:25:42.360 --> 00:25:46.110
that we're adding to let you
better debug program problems,

00:25:46.110 --> 00:25:48.090
but we've also
added some UI tweaks

00:25:48.090 --> 00:25:50.880
to the APK analyzer
that hopefully will make

00:25:50.880 --> 00:25:52.302
working with it even easier.

00:25:52.302 --> 00:25:53.760
So the first thing
you might notice

00:25:53.760 --> 00:25:56.040
is we now have multidex support.

00:25:56.040 --> 00:25:58.560
So I can select
multiple dex files

00:25:58.560 --> 00:26:00.210
and actually see
a combined preview

00:26:00.210 --> 00:26:02.110
of all the code in my app.

00:26:02.110 --> 00:26:03.526
So this is a very
simple example.

00:26:03.526 --> 00:26:04.650
This is not the Topeka app.

00:26:04.650 --> 00:26:08.300
This is just an APK I created
for the purpose of this demo.

00:26:08.300 --> 00:26:09.810
And you can see,
I can drill down

00:26:09.810 --> 00:26:14.220
to the source code of my app
here and actually see all

00:26:14.220 --> 00:26:15.646
the other classes that I have.

00:26:15.646 --> 00:26:17.020
And the app really
has two parts.

00:26:17.020 --> 00:26:17.740
It's very simple.

00:26:17.740 --> 00:26:20.370
It just has an activity
and it has a fragment.

00:26:20.370 --> 00:26:24.000
The thing is, the fragment,
the way I use it is I only

00:26:24.000 --> 00:26:25.950
use it from a layout XML file.

00:26:25.950 --> 00:26:28.580
And that will be
important later.

00:26:28.580 --> 00:26:31.320
We've also made some other
tweaks to the dex viewer.

00:26:31.320 --> 00:26:34.380
So, for example, we have
some filtering options,

00:26:34.380 --> 00:26:38.682
and I can, for example,
disable showing classes.

00:26:38.682 --> 00:26:40.890
They're a reference from my
file but are not actually

00:26:40.890 --> 00:26:42.120
defined in it.

00:26:42.120 --> 00:26:43.770
But moving onto ProGuard.

00:26:43.770 --> 00:26:46.250
So this is a debug build.

00:26:46.250 --> 00:26:49.120
For this, ProGuard
is not enabled.

00:26:49.120 --> 00:26:51.480
So I built my release APK.

00:26:51.480 --> 00:26:52.320
I run it.

00:26:52.320 --> 00:26:55.290
And the first big problem
with the app is it crashes.

00:26:55.290 --> 00:26:56.762
It crashes on startup.

00:26:56.762 --> 00:26:57.470
I don't know why.

00:26:57.470 --> 00:27:00.330
It failed the class
not found exception.

00:27:00.330 --> 00:27:02.940
And the second problem is,
if I actually go and try

00:27:02.940 --> 00:27:06.120
to debug the problem,
I can see, again,

00:27:06.120 --> 00:27:08.610
like Shai mentioned, that
all the names of my types,

00:27:08.610 --> 00:27:11.010
of my fields, methods,
they were all changed

00:27:11.010 --> 00:27:13.620
to strings like a, b, c.

00:27:13.620 --> 00:27:16.570
It's very difficult to
debug the problem here.

00:27:16.570 --> 00:27:19.470
So what I can do now with
the new Android Studio

00:27:19.470 --> 00:27:22.020
is I can actually load
the program mappings that

00:27:22.020 --> 00:27:26.310
were created when
my APK was built.

00:27:26.310 --> 00:27:29.890
So let me open the program
mapping folder here.

00:27:29.890 --> 00:27:34.230
And now you can see
the dex viewer changed.

00:27:34.230 --> 00:27:37.740
First, I can actually see all
the names of classes, packages.

00:27:37.740 --> 00:27:42.720
Everything's back like it was
in my original source code.

00:27:42.720 --> 00:27:45.870
Second, I can actually
go here and see now

00:27:45.870 --> 00:27:47.730
that my blank
fragment is missing.

00:27:47.730 --> 00:27:51.230
That's because ProGuard was not
able to automatically detect

00:27:51.230 --> 00:27:53.820
the text that is
being used in my code.

00:27:53.820 --> 00:27:56.200
What's more, I can
press this button here,

00:27:56.200 --> 00:27:59.220
which will let me show
all the removed nodes that

00:27:59.220 --> 00:28:00.360
were removed by ProGuard.

00:28:00.360 --> 00:28:01.764
[APPLAUSE]

00:28:01.764 --> 00:28:02.264
Yep.

00:28:02.264 --> 00:28:04.168
[APPLAUSE]

00:28:06.080 --> 00:28:08.030
So I found the
blank fragment here.

00:28:08.030 --> 00:28:09.810
It was removed.

00:28:09.810 --> 00:28:13.730
I right-click on it, and I can
actually generate a ProGuard

00:28:13.730 --> 00:28:15.210
rule that I can--

00:28:15.210 --> 00:28:17.110
[APPLAUSE]

00:28:20.910 --> 00:28:22.780
--that I can simply
copy and paste

00:28:22.780 --> 00:28:24.130
to my ProGuard configuration.

00:28:24.130 --> 00:28:26.470
So I'm going to
choose the first rule.

00:28:26.470 --> 00:28:27.580
It's the simplest one.

00:28:27.580 --> 00:28:29.980
I just want to keep the
class and all its members.

00:28:29.980 --> 00:28:31.810
So I copy it here.

00:28:31.810 --> 00:28:33.790
I rebuild my app.

00:28:33.790 --> 00:28:36.730
And I open the APK
after rebuilding it.

00:28:36.730 --> 00:28:38.650
I've loaded the
program mappings so

00:28:38.650 --> 00:28:40.960
that we can keep things brief.

00:28:40.960 --> 00:28:41.840
I open it.

00:28:41.840 --> 00:28:44.860
And what's more, I can see that
the blank fragment is not only

00:28:44.860 --> 00:28:49.300
here, it's shown in bold, which
means it was explicitly kept

00:28:49.300 --> 00:28:52.320
by the ProGuard configuration.

00:28:52.320 --> 00:28:55.570
So that's the ProGuard
support in Android Studio

00:28:55.570 --> 00:28:56.662
in APK analyzer.

00:28:56.662 --> 00:28:57.370
But there's more.

00:28:57.370 --> 00:29:01.720
For real power users, you can
actually now go and figure out

00:29:01.720 --> 00:29:06.140
how the classes that you use and
the dependencies that you have

00:29:06.140 --> 00:29:08.380
pull even more code
inside your app.

00:29:08.380 --> 00:29:10.820
So for example, I know
that in my source code

00:29:10.820 --> 00:29:12.760
I'm using this class
called Optional,

00:29:12.760 --> 00:29:15.770
but I've never used
this one or this one.

00:29:15.770 --> 00:29:17.050
So why is it here?

00:29:17.050 --> 00:29:21.280
I can now right-click
on any class or method,

00:29:21.280 --> 00:29:25.990
and actually find usages and
get a nice tree of dependencies

00:29:25.990 --> 00:29:28.900
and see that actually
this Present class is

00:29:28.900 --> 00:29:31.480
used by this method
from the Optional, which

00:29:31.480 --> 00:29:33.880
I'm using from my onCreate.

00:29:33.880 --> 00:29:37.960
What's more, I can
actually verify that

00:29:37.960 --> 00:29:43.210
by opening my onCreate
method, and looking

00:29:43.210 --> 00:29:45.370
at the exact bytecode
of that method.

00:29:45.370 --> 00:29:48.820
Now I know not every one of
you will need to use this,

00:29:48.820 --> 00:29:50.770
but if you work with
very complicated

00:29:50.770 --> 00:29:53.580
build system, if you do your
own bytecode transformations,

00:29:53.580 --> 00:29:55.290
now you can actually
analyze the bytecode

00:29:55.290 --> 00:29:58.160
that gets packaged in your APK.

00:29:58.160 --> 00:29:58.660
OK.

00:29:58.660 --> 00:30:01.780
Can we switch back
the slides please?

00:30:01.780 --> 00:30:04.810
So this is available
in Android Studio now.

00:30:04.810 --> 00:30:07.510
However, there are some more
things that we're working on,

00:30:07.510 --> 00:30:10.450
and hopefully you'll get to
play with them in the future,

00:30:10.450 --> 00:30:13.170
but now let me give
you a sneak peek.

00:30:13.170 --> 00:30:14.570
So in the dex viewer--

00:30:14.570 --> 00:30:16.095
previously, we had
only two columns

00:30:16.095 --> 00:30:18.220
showing the number of
defined methods and reference

00:30:18.220 --> 00:30:20.560
methods, which is useful if
you're debugging problems

00:30:20.560 --> 00:30:21.974
with multidex.

00:30:21.974 --> 00:30:23.390
Not really problems
with multidex,

00:30:23.390 --> 00:30:26.130
but problems with the
number of methods.

00:30:26.130 --> 00:30:28.120
We are adding a
third column that

00:30:28.120 --> 00:30:31.540
will show you the actual
byte size per package, class,

00:30:31.540 --> 00:30:34.990
and even method so you can see
how the functionality you add

00:30:34.990 --> 00:30:37.900
to your code, or the libraries
that you pull into your code

00:30:37.900 --> 00:30:44.290
base, impact the dex size
and APK size of your app.

00:30:44.290 --> 00:30:46.960
And, the last thing
is, Shai showed you

00:30:46.960 --> 00:30:49.900
how you can compare
two APKs, but so far

00:30:49.900 --> 00:30:52.300
the functionality was quite
limited and only worked

00:30:52.300 --> 00:30:54.490
on the raw APK size.

00:30:54.490 --> 00:30:57.640
We're expanding the
compare APK action

00:30:57.640 --> 00:31:01.960
to give you the actual update
size as delivered by the Play

00:31:01.960 --> 00:31:04.420
Store from one version
of your app to the other.

00:31:04.420 --> 00:31:07.030
And we even include the
new file-by-file support

00:31:07.030 --> 00:31:08.780
that's been added to Play.

00:31:08.780 --> 00:31:11.050
And if you're not familiar
with file-by-file patches,

00:31:11.050 --> 00:31:12.920
let me invite on stage
James from the Play

00:31:12.920 --> 00:31:15.260
Team who can explain it better.

00:31:15.260 --> 00:31:16.307
[APPLAUSE]

00:31:16.307 --> 00:31:17.140
JAMES SMITH: Thanks.

00:31:17.140 --> 00:31:19.020
[APPLAUSE]

00:31:20.900 --> 00:31:22.082
Hi, everyone.

00:31:22.082 --> 00:31:22.790
My name is James.

00:31:22.790 --> 00:31:25.910
I'm a product manager on
the Google Play Store.

00:31:25.910 --> 00:31:28.690
Play delivers a lot of apps.

00:31:28.690 --> 00:31:32.480
In the last year, we delivered
82 billion app installs,

00:31:32.480 --> 00:31:35.990
and even more patches to
keep those apps up to date.

00:31:35.990 --> 00:31:38.260
We saw earlier in
the presentation

00:31:38.260 --> 00:31:41.900
how app size directly
correlates with install success,

00:31:41.900 --> 00:31:44.990
so users couldn't be giving
us a more clear signal

00:31:44.990 --> 00:31:47.720
that they care about the
size of these downloads.

00:31:47.720 --> 00:31:50.450
So in the last year,
Play invested a lot

00:31:50.450 --> 00:31:54.530
in taking significant steps to
reduce APK size for downloads

00:31:54.530 --> 00:31:56.030
and updates.

00:31:56.030 --> 00:31:58.280
I'm delighted to say that
we had some great success,

00:31:58.280 --> 00:32:02.390
and I'd like to tell you about
two of those in particular.

00:32:02.390 --> 00:32:04.960
The first was
Brotli compression.

00:32:04.960 --> 00:32:08.660
Now, at Google, we're always
super proud of our interns,

00:32:08.660 --> 00:32:10.820
but this one's going
to take some beating.

00:32:10.820 --> 00:32:14.600
Our intern, Anna, took Brotli,
which is a new compression

00:32:14.600 --> 00:32:17.240
format from the Google
Research Europe Team,

00:32:17.240 --> 00:32:20.390
and applied it to
the Play Store.

00:32:20.390 --> 00:32:27.470
That one change reduced our data
usage by 1.5 petabytes a day,

00:32:27.470 --> 00:32:30.770
compared to our previous method
of using gzip for everything.

00:32:30.770 --> 00:32:33.406
This is crazy, right?

00:32:33.406 --> 00:32:35.030
We're super pleased
with these results.

00:32:35.030 --> 00:32:40.180
And you can be sure we made Anna
an offer to join us full-time.

00:32:40.180 --> 00:32:42.076
[APPLAUSE]

00:32:45.400 --> 00:32:47.880
Secondly, when Google
Play updates an app,

00:32:47.880 --> 00:32:52.050
as the guys said previously,
we deliver patches.

00:32:52.050 --> 00:32:55.860
So we started out by just
delivering the full APK

00:32:55.860 --> 00:32:57.900
for each update,
and then we switched

00:32:57.900 --> 00:33:00.360
to using diffing algorithms
to generate deltas

00:33:00.360 --> 00:33:03.420
between old APKs and new APKs.

00:33:03.420 --> 00:33:05.250
Now, there's an issue with this.

00:33:05.250 --> 00:33:08.820
As we know, APKs are zip
archives that are compressed.

00:33:08.820 --> 00:33:12.450
So take a look at
this blob of text.

00:33:12.450 --> 00:33:15.420
On the next slide, I
changed one character.

00:33:15.420 --> 00:33:16.360
Did you see it?

00:33:16.360 --> 00:33:18.690
It's in the top
left, second word.

00:33:18.690 --> 00:33:21.100
Can we go back a slide?

00:33:21.100 --> 00:33:22.480
And then we see it again.

00:33:22.480 --> 00:33:22.980
OK?

00:33:22.980 --> 00:33:23.910
Got it?

00:33:23.910 --> 00:33:28.360
Now let's look at the gzip minus
6 compressed version of that.

00:33:28.360 --> 00:33:31.960
Here's the first blob of text.

00:33:31.960 --> 00:33:33.870
And here's the
second blob of text.

00:33:33.870 --> 00:33:36.310
And, remember, we only
changed one character.

00:33:36.310 --> 00:33:39.180
So let's see that again?

00:33:39.180 --> 00:33:40.270
It's pretty crazy.

00:33:40.270 --> 00:33:44.370
So a compressed version produces
a massively different blob

00:33:44.370 --> 00:33:46.140
of compressed text.

00:33:46.140 --> 00:33:50.440
That means the patch between
the two is very inefficient.

00:33:50.440 --> 00:33:54.240
So we decided to get smarter
about how we generate patches.

00:33:54.240 --> 00:33:57.090
We launched the new system
called file-by-file patching.

00:33:57.090 --> 00:33:59.640
We decided to
uncompress the APKs

00:33:59.640 --> 00:34:03.330
and generate the deltas on
the uncompressed versions,

00:34:03.330 --> 00:34:05.940
every single file, file by file.

00:34:05.940 --> 00:34:08.550
This creates a far
more efficient patch.

00:34:08.550 --> 00:34:10.230
And then we reverse
the process when we

00:34:10.230 --> 00:34:13.710
apply the patch on the device.

00:34:13.710 --> 00:34:14.969
The result?

00:34:14.969 --> 00:34:19.949
We saved six petabytes
of user data per day.

00:34:19.949 --> 00:34:23.460
On average, patches
are now 65% smaller

00:34:23.460 --> 00:34:27.330
than the original app size,
and some are even smaller.

00:34:27.330 --> 00:34:30.690
Netflix's original
app is 16 megabytes,

00:34:30.690 --> 00:34:36.540
but the patch size was only
one megabyte-- a 92% saving.

00:34:36.540 --> 00:34:39.780
So with these two changes,
we've dropped our data usage

00:34:39.780 --> 00:34:43.060
by 7.5 petabytes per day.

00:34:43.060 --> 00:34:45.000
To put that in
context, that's roughly

00:34:45.000 --> 00:34:52.120
equivalent to a hundred years
of HDTV video every single day.

00:34:52.120 --> 00:34:54.480
If that doesn't give you an
idea of the scale of Android

00:34:54.480 --> 00:34:54.979
in Play--

00:34:54.979 --> 00:34:57.683
[APPLAUSE]

00:34:57.683 --> 00:35:00.440
[INAUDIBLE]

00:35:00.440 --> 00:35:03.320
So next, we're going to
take a different route.

00:35:03.320 --> 00:35:06.470
We're introducing
Google Play App Signing.

00:35:06.470 --> 00:35:08.390
If you join this
program, Google Play

00:35:08.390 --> 00:35:10.610
will manage your
key on your behalf

00:35:10.610 --> 00:35:14.520
and sign your app before
delivering it to users.

00:35:14.520 --> 00:35:16.820
Now, once Google
Play signs your app,

00:35:16.820 --> 00:35:19.580
we can go one step
further, and we can

00:35:19.580 --> 00:35:23.000
provide app size optimizations.

00:35:23.000 --> 00:35:26.240
Now you heard earlier about
multi-APK and the stuff that's

00:35:26.240 --> 00:35:28.400
not required in each device.

00:35:28.400 --> 00:35:33.560
If I have a 32-bit
architecture and a hdpi screen,

00:35:33.560 --> 00:35:36.530
then I only need the contents
of the boxes in blue,

00:35:36.530 --> 00:35:38.630
and the rest of the
APK is completely

00:35:38.630 --> 00:35:41.660
unnecessary for my device.

00:35:41.660 --> 00:35:45.710
With app optimizations, we
deliver just the right content

00:35:45.710 --> 00:35:47.040
for each device.

00:35:47.040 --> 00:35:50.330
So if multi-APK is too
difficult or too complicated,

00:35:50.330 --> 00:35:52.910
or you're doing it just knowing
you don't want to anymore,

00:35:52.910 --> 00:35:57.550
sign up for app optimizations,
and you never need to again.

00:35:57.550 --> 00:35:59.410
[APPLAUSE]

00:36:03.130 --> 00:36:07.090
You give us a Universal APK,
and we will automatically

00:36:07.090 --> 00:36:10.870
create an optimized APK
for different devices

00:36:10.870 --> 00:36:15.820
on screen density and
native architecture.

00:36:15.820 --> 00:36:19.390
Now, we're just getting
started exploring this area.

00:36:19.390 --> 00:36:21.000
It's really early.

00:36:21.000 --> 00:36:23.460
But we've tried this
out with a few apps that

00:36:23.460 --> 00:36:26.610
were in our Early Access
program for App Signing,

00:36:26.610 --> 00:36:30.360
and we expect the average
savings to be about 15%.

00:36:30.360 --> 00:36:34.060
However, some apps see
even better results.

00:36:34.060 --> 00:36:39.240
Deliveroo was 33% smaller
after the optimizations,

00:36:39.240 --> 00:36:43.200
and the 7 Minute Workout app
was nearly a half smaller.

00:36:43.200 --> 00:36:44.700
So we're really
excited about this.

00:36:44.700 --> 00:36:46.866
We think this is going to
be a huge benefit to users

00:36:46.866 --> 00:36:49.080
and developers.

00:36:49.080 --> 00:36:51.150
So how can you get
these benefits?

00:36:51.150 --> 00:36:54.130
Well, App Signing
is available today.

00:36:54.130 --> 00:36:56.580
You can go out and get
enrolled straight away.

00:36:56.580 --> 00:36:59.370
We are trialing app
optimizations in beta

00:36:59.370 --> 00:37:01.530
with a few select
partners at the moment,

00:37:01.530 --> 00:37:04.510
and we hope to widen the
beta in the near future.

00:37:04.510 --> 00:37:06.690
So if you're interested
in optimizations,

00:37:06.690 --> 00:37:08.430
please enroll in App Signing.

00:37:08.430 --> 00:37:10.860
And if you'd like to find
out more about these two,

00:37:10.860 --> 00:37:15.920
please come to our talk at 2:30
PM today on Stage 1 next door.

00:37:19.450 --> 00:37:21.960
So thank you very
much for listening.

00:37:21.960 --> 00:37:24.060
Today we've covered a
lot of the best practices

00:37:24.060 --> 00:37:26.730
that you can do to slim
down your APK size.

00:37:26.730 --> 00:37:29.259
It's really important
to users, so I really

00:37:29.259 --> 00:37:31.050
hope that you take
something away from this

00:37:31.050 --> 00:37:33.750
and go and invest in
making this better.

00:37:33.750 --> 00:37:35.220
If you'd like to
find out more, you

00:37:35.220 --> 00:37:39.750
can talk to the Android and Play
teams in Sandbox Dome C. Thanks

00:37:39.750 --> 00:37:40.467
again.

00:37:40.467 --> 00:37:43.705
[APPLAUSE]

