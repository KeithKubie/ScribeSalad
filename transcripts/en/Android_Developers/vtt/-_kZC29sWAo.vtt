WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:09.063
[MUSIC PLAYING]

00:00:09.063 --> 00:00:10.890
STEPHAN LINZNER: Hey, everybody.

00:00:10.890 --> 00:00:14.440
As they say the best goes last.

00:00:14.440 --> 00:00:19.870
And here we are to talk about
testing Android apps at scale.

00:00:19.870 --> 00:00:21.580
My name is Stephan
Linzner, and I'm

00:00:21.580 --> 00:00:23.260
a software engineer at Google.

00:00:23.260 --> 00:00:26.650
And with me backstage
is Visnal Sethia,

00:00:26.650 --> 00:00:30.480
who's also a software
engineer at Google.

00:00:30.480 --> 00:00:33.640
So at Google we believe in
diversity and inclusion.

00:00:33.640 --> 00:00:36.030
And we build our
products for everyone.

00:00:36.030 --> 00:00:38.640
But for us developers
this means we also

00:00:38.640 --> 00:00:40.780
have to test for everyone.

00:00:40.780 --> 00:00:43.410
So let me tell you a little
bit how we develop and test

00:00:43.410 --> 00:00:46.260
software at Google.

00:00:46.260 --> 00:00:49.260
But before I start, I
want to talk a little bit

00:00:49.260 --> 00:00:51.600
about the scale that we do
Android development here

00:00:51.600 --> 00:00:52.960
at Google.

00:00:52.960 --> 00:00:55.740
We have about 100
plus Android apps.

00:00:55.740 --> 00:00:57.510
This includes all
the billion user

00:00:57.510 --> 00:00:59.850
apps shot, such
as Google Photos,

00:00:59.850 --> 00:01:02.910
maps, YouTube, Gmails, search.

00:01:02.910 --> 00:01:06.270
We have a combined 2
billion lines of code,

00:01:06.270 --> 00:01:10.360
and we run 20,000 Android
builds every single day.

00:01:10.360 --> 00:01:13.260
And we have a
staggering 27 million

00:01:13.260 --> 00:01:16.712
test in locations per day.

00:01:16.712 --> 00:01:19.610
So how do we create
these high quality apps,

00:01:19.610 --> 00:01:24.820
and how do we maintain this
quality over such a long time?

00:01:24.820 --> 00:01:27.420
I think one of the
key things here

00:01:27.420 --> 00:01:30.120
is our engineering culture.

00:01:30.120 --> 00:01:32.340
A typical developer
workflow at Google

00:01:32.340 --> 00:01:34.003
looks a little bit like this.

00:01:34.003 --> 00:01:37.960
We have a strong code
reviewing culture.

00:01:37.960 --> 00:01:40.740
Code to use a very,
very thorough,

00:01:40.740 --> 00:01:43.630
and before you can
actually submit your change

00:01:43.630 --> 00:01:47.200
or pull request you have
to get at least reviewed

00:01:47.200 --> 00:01:50.350
by one of your peers.

00:01:50.350 --> 00:01:53.620
Another important thing is
that all development happens

00:01:53.620 --> 00:01:56.760
that hat, and everything
is built from source.

00:01:56.760 --> 00:01:58.900
And we have a large
amount of repo,

00:01:58.900 --> 00:02:03.480
which allows us to easily
search for code, reuse code,

00:02:03.480 --> 00:02:07.050
but it also allows us to keep
the repo healthy by sending

00:02:07.050 --> 00:02:11.220
so-called large scale changes.

00:02:11.220 --> 00:02:14.520
Also have a very
strong testing culture.

00:02:14.520 --> 00:02:19.320
At Google if you have a
change you have to have tests.

00:02:19.320 --> 00:02:21.930
Even more importantly,
all of those tests

00:02:21.930 --> 00:02:26.280
have to pass before
you submit your change.

00:02:26.280 --> 00:02:29.610
To run tests we use a
large scale distributed

00:02:29.610 --> 00:02:33.450
CI system, which does
not only run your tests,

00:02:33.450 --> 00:02:35.580
but also all of
the tests from code

00:02:35.580 --> 00:02:38.160
that depends on your change.

00:02:38.160 --> 00:02:40.590
Another thing that is
very unique about Google

00:02:40.590 --> 00:02:44.100
is that we have a strong
interviewing productivity

00:02:44.100 --> 00:02:44.600
culture.

00:02:44.600 --> 00:02:47.340
So that means we
have dedicated teams

00:02:47.340 --> 00:02:51.180
that only work on
infrastructure tools and APIs

00:02:51.180 --> 00:02:53.790
to make developers productive.

00:02:56.682 --> 00:02:59.750
We are part of such
a team, and we've

00:02:59.750 --> 00:03:03.050
been working on
testing Android apps,

00:03:03.050 --> 00:03:06.510
or Android app
testing at Google.

00:03:06.510 --> 00:03:09.260
So I want to take
you a walk down

00:03:09.260 --> 00:03:13.010
memory lane what we have done
at Google to scale Android

00:03:13.010 --> 00:03:14.360
testing.

00:03:14.360 --> 00:03:18.200
So in about 2011 a
lot of teams at Google

00:03:18.200 --> 00:03:20.720
actually started to
build for Android,

00:03:20.720 --> 00:03:24.030
because Android was becoming
more and more popular.

00:03:24.030 --> 00:03:27.080
So at the time they were just
using the standard tool chain.

00:03:27.080 --> 00:03:29.180
They were using ANT,
to build their apps

00:03:29.180 --> 00:03:32.130
and they were using
Eclipse as an editor.

00:03:32.130 --> 00:03:34.050
But with a growing
number of teams,

00:03:34.050 --> 00:03:36.920
we also added support to
our internal build system.

00:03:36.920 --> 00:03:41.240
One of the problems that
became obvious very early on

00:03:41.240 --> 00:03:44.640
was the need for
scalable testing.

00:03:44.640 --> 00:03:46.560
And so we actually
started off very

00:03:46.560 --> 00:03:50.504
simple by building a small
post site test runner that

00:03:50.504 --> 00:03:51.420
would run on the host.

00:03:51.420 --> 00:03:54.950
And in fact it was just
a JUnit three test suite

00:03:54.950 --> 00:03:58.260
that would literally scan
an APK, list the tests,

00:03:58.260 --> 00:04:00.030
and give it to our
instrumentation test

00:04:00.030 --> 00:04:04.910
runner that was running on the
device to execute the test.

00:04:04.910 --> 00:04:07.320
Once we had that,
we actually built it

00:04:07.320 --> 00:04:10.120
into our continuous
integration system.

00:04:10.120 --> 00:04:13.200
One of the key decisions
that we made very early on

00:04:13.200 --> 00:04:16.620
was to use emulators, we
called them virtual devices,

00:04:16.620 --> 00:04:18.630
to run tests at scale.

00:04:18.630 --> 00:04:20.850
Because obviously
it makes more sense,

00:04:20.850 --> 00:04:22.980
because you can
scale a data center,

00:04:22.980 --> 00:04:27.520
but you can probably not
scale a [INAUDIBLE] so easily.

00:04:27.520 --> 00:04:29.770
So we wrote this
little Python script,

00:04:29.770 --> 00:04:32.770
probably just 20 lines of code--
and I'm sure many of you have

00:04:32.770 --> 00:04:33.850
been there--

00:04:33.850 --> 00:04:38.140
that puts up an emulator for us
that allows us to run the tests

00:04:38.140 --> 00:04:42.180
and shut it down afterwards.

00:04:42.180 --> 00:04:44.100
So while we were working
on infrastructure,

00:04:44.100 --> 00:04:47.250
our engineers actually
started to write tests.

00:04:47.250 --> 00:04:49.300
And they wrote a lot of them.

00:04:49.300 --> 00:04:51.840
A key problem here
was especially

00:04:51.840 --> 00:04:54.170
around functional UI testing.

00:04:54.170 --> 00:04:57.660
And as many of you will remember
in the early days you only

00:04:57.660 --> 00:04:59.770
had the low level
framework APIs,

00:04:59.770 --> 00:05:03.000
you had activity monitor
to track activities.

00:05:03.000 --> 00:05:07.320
You had instrumentation run on
UI threat, or the infamous wait

00:05:07.320 --> 00:05:08.910
until idle sync.

00:05:08.910 --> 00:05:16.000
And even though these methods,
these APIs were easy to use,

00:05:16.000 --> 00:05:20.730
developers struggled a lot
writing reliable UI tests.

00:05:20.730 --> 00:05:23.779
And at the time we
thought, OK, maybe we

00:05:23.779 --> 00:05:26.070
could find something better,
and we actually found that

00:05:26.070 --> 00:05:28.050
in a community with Robotium.

00:05:28.050 --> 00:05:32.320
So we brought Robotium into
Google, and it improved things.

00:05:32.320 --> 00:05:36.600
And we used it for about a
year until the end of 2012.

00:05:36.600 --> 00:05:39.550
But it had its own issues
with the API surface,

00:05:39.550 --> 00:05:42.420
and it didn't solve one
of our key issues, which

00:05:42.420 --> 00:05:43.880
was synchronization.

00:05:43.880 --> 00:05:46.440
And that's when we started to
work on Espresso, because we

00:05:46.440 --> 00:05:49.800
wanted a framework that was
easy to use for developers,

00:05:49.800 --> 00:05:53.400
but more importantly was
hiding all the complexity

00:05:53.400 --> 00:05:58.010
of instrumentation testing
from the developer.

00:05:58.010 --> 00:06:00.770
At that point we kind
of had a decent setup

00:06:00.770 --> 00:06:02.960
for instrumentation
tests, but we still

00:06:02.960 --> 00:06:05.330
had to solve the
unit testing problem,

00:06:05.330 --> 00:06:08.280
because as you remember at the
time, all of your unit tests

00:06:08.280 --> 00:06:10.780
are usually random
on the device.

00:06:10.780 --> 00:06:12.560
But that is expensive,
and they tend

00:06:12.560 --> 00:06:15.870
to be slower than
running on the JVM.

00:06:15.870 --> 00:06:18.020
So again we're
reached for a solution

00:06:18.020 --> 00:06:20.900
that the community had already
built at the time, which

00:06:20.900 --> 00:06:22.310
was rogue Roboelectric.

00:06:22.310 --> 00:06:24.440
And Roboelectric
allowed our developers

00:06:24.440 --> 00:06:27.090
to do fast, iterative,
local development,

00:06:27.090 --> 00:06:30.530
and it's actually still one
of the most popular frameworks

00:06:30.530 --> 00:06:34.100
for unit testing within Google.

00:06:34.100 --> 00:06:38.120
So in 2014 we actually had
built a lot of experience

00:06:38.120 --> 00:06:40.850
in testing APIs,
but we were seeing

00:06:40.850 --> 00:06:43.100
that the community
was struggling

00:06:43.100 --> 00:06:45.680
from the same
problems that we did.

00:06:45.680 --> 00:06:48.290
That's why we decided to
bundle all of our libraries

00:06:48.290 --> 00:06:51.530
together in the Android testing
support library, which then

00:06:51.530 --> 00:06:54.140
quickly became the default
library for developers to write

00:06:54.140 --> 00:06:57.240
instrumentation tests.

00:06:57.240 --> 00:07:03.240
Fast forward to today, we just
launched Android X test 1.0.

00:07:03.240 --> 00:07:05.640
It's not only our
first stable release,

00:07:05.640 --> 00:07:07.890
it's also the
first time where we

00:07:07.890 --> 00:07:12.960
ship unified APIs that allow
you to write tests once, and run

00:07:12.960 --> 00:07:14.410
them anywhere.

00:07:14.410 --> 00:07:17.420
And by the way, we just
achieved a major milestone here

00:07:17.420 --> 00:07:18.330
at Google.

00:07:18.330 --> 00:07:22.430
We now run 10 billion unit
and instrumentation tests

00:07:22.430 --> 00:07:27.270
every year on our
infrastructure.

00:07:27.270 --> 00:07:29.880
So looking back at
those seven years,

00:07:29.880 --> 00:07:32.370
what would we do differently?

00:07:32.370 --> 00:07:35.330
There's a couple of things
I want to mention here.

00:07:35.330 --> 00:07:39.690
So we would probably design
for any build system.

00:07:39.690 --> 00:07:42.570
We made some key decisions very
early on that tightly coupled

00:07:42.570 --> 00:07:44.560
us to Google's
internal build system,

00:07:44.560 --> 00:07:47.460
but it quickly became a problem
because even at Google not

00:07:47.460 --> 00:07:50.000
everybody's using Google's
internal built system,

00:07:50.000 --> 00:07:53.040
and we weren't able to
share or build our host site

00:07:53.040 --> 00:07:56.910
infrastructure with them, but
also not with the community,

00:07:56.910 --> 00:07:59.940
and we couldn't open source it.

00:07:59.940 --> 00:08:01.800
Similarly, we didn't build--

00:08:01.800 --> 00:08:04.650
some of the tools that we
built weren't cross platform.

00:08:04.650 --> 00:08:09.552
So they only worked on Linux
but not Mac and Windows.

00:08:09.552 --> 00:08:12.900
Another thing that we would
probably do differently, even

00:08:12.900 --> 00:08:14.370
though retrospectively
it probably

00:08:14.370 --> 00:08:16.800
was a good thing that we
started off small, and then

00:08:16.800 --> 00:08:18.550
scaled up our testing.

00:08:18.550 --> 00:08:21.577
But while the apps grew
and the ecosystem grew,

00:08:21.577 --> 00:08:23.160
there were more and
more requirements,

00:08:23.160 --> 00:08:26.270
and we usually just built
them into our infrastructure,

00:08:26.270 --> 00:08:30.320
but we didn't had a mechanism
for teams to customize

00:08:30.320 --> 00:08:31.530
this infrastructure.

00:08:31.530 --> 00:08:33.330
This led to a point
where we suffered

00:08:33.330 --> 00:08:35.280
from high code complexity.

00:08:35.280 --> 00:08:38.220
It was hard to maintain,
and some features

00:08:38.220 --> 00:08:42.637
couldn't be removed, but
they weren't used anymore.

00:08:42.637 --> 00:08:44.970
The other thing I want to
mention here is configuration.

00:08:44.970 --> 00:08:47.500
Our host site infrastructure
was getting configuration

00:08:47.500 --> 00:08:49.360
from many different sources.

00:08:49.360 --> 00:08:52.660
So we had flags system
environment variables,

00:08:52.660 --> 00:08:53.860
and conflict files.

00:08:53.860 --> 00:08:57.880
And it's made it very
hard to track down bugs

00:08:57.880 --> 00:08:59.750
in the infrastructure itself.

00:08:59.750 --> 00:09:04.390
So about a year ago our team sat
down with app teams and Google,

00:09:04.390 --> 00:09:09.680
and we wanted to learn about
the past and the future,

00:09:09.680 --> 00:09:14.060
and especially how the Android
testing landscape had changed.

00:09:14.060 --> 00:09:16.840
So what we came up with to
solve some of the problems that

00:09:16.840 --> 00:09:20.590
came out of the discussion
was Project Nitrogen.

00:09:20.590 --> 00:09:24.000
Project Nitrogen is our new
unified testing platform,

00:09:24.000 --> 00:09:27.250
which we first talked
about at IO this year,

00:09:27.250 --> 00:09:31.210
and which we will
ship to you in 2019.

00:09:31.210 --> 00:09:33.250
Project Nitrogen
is currently used

00:09:33.250 --> 00:09:36.600
by a small number of
apps inside of Google,

00:09:36.600 --> 00:09:40.090
and we're slowly scaling it
up to some of the biggest apps

00:09:40.090 --> 00:09:41.070
in the world.

00:09:41.070 --> 00:09:42.550
And the reason why
we're doing this

00:09:42.550 --> 00:09:46.120
is simply because we want
it battle tested first

00:09:46.120 --> 00:09:47.920
before we ship it to you.

00:09:47.920 --> 00:09:49.960
But the point being
here is, we want

00:09:49.960 --> 00:09:52.080
to give all this
infrastructure that we use

00:09:52.080 --> 00:09:54.010
to run 10 billion tests to you.

00:09:56.650 --> 00:09:59.670
So Nitrogen solves
many problems,

00:09:59.670 --> 00:10:01.920
but two of the key
issues that we're

00:10:01.920 --> 00:10:04.380
trying to solve
with Nitrogen is,

00:10:04.380 --> 00:10:06.810
first, we want to
create a unified entry

00:10:06.810 --> 00:10:10.950
point into Android
development, and secondly, we

00:10:10.950 --> 00:10:14.430
want you to enable to write
test with a unified API

00:10:14.430 --> 00:10:16.860
and move them between layers.

00:10:16.860 --> 00:10:19.560
If you think about
Android testing today,

00:10:19.560 --> 00:10:22.380
it looks a little
bit like this, right?

00:10:22.380 --> 00:10:24.430
You have tools on
the left hand side,

00:10:24.430 --> 00:10:26.890
such as Android Studio, Gradle.

00:10:26.890 --> 00:10:29.940
You have UCI server,
and maybe even another

00:10:29.940 --> 00:10:32.640
build system such as Bazel.

00:10:32.640 --> 00:10:34.850
On the other end
of the spectrum,

00:10:34.850 --> 00:10:36.930
you have all the
different runtimes

00:10:36.930 --> 00:10:38.610
that you want to run on.

00:10:38.610 --> 00:10:42.172
We call runtime
devices in Nitrogen.

00:10:42.172 --> 00:10:45.170
So you want to run your
test on a simulated device,

00:10:45.170 --> 00:10:48.110
or a virtual or
physical device, or even

00:10:48.110 --> 00:10:50.870
on a remote device that
runs in a device left

00:10:50.870 --> 00:10:53.700
such as Firebase Test Lab.

00:10:53.700 --> 00:10:56.820
But in order to do so, you have
many different entry points,

00:10:56.820 --> 00:10:58.840
and it looks a
little bit like this.

00:10:58.840 --> 00:11:01.140
You have a different
configuration for every tool.

00:11:01.140 --> 00:11:03.906
You have different roles,
you have different tasks.

00:11:03.906 --> 00:11:07.514
And it just becomes a
nightmare to maintain.

00:11:07.514 --> 00:11:08.930
And actually what
we see in Google

00:11:08.930 --> 00:11:11.900
is, because it's so hard to
move from one to the other,

00:11:11.900 --> 00:11:14.930
they would skew towards one
type of a test or another.

00:11:17.620 --> 00:11:19.290
What we want to do
with Nitrogen is,

00:11:19.290 --> 00:11:21.670
we want to have a
unified entry point.

00:11:21.670 --> 00:11:26.190
And Nitrogen itself is
just a stand alone binary.

00:11:26.190 --> 00:11:30.370
A stand alone tool which
infrastructure developers

00:11:30.370 --> 00:11:34.470
can use to really customize
their infrastructure.

00:11:34.470 --> 00:11:37.540
But obviously there's also
all these other developers

00:11:37.540 --> 00:11:38.920
who don't work on
infrastructure,

00:11:38.920 --> 00:11:40.870
and work on actual app code.

00:11:40.870 --> 00:11:44.530
For them we want to
provide integrations

00:11:44.530 --> 00:11:47.470
into all the tools
on the left hand side

00:11:47.470 --> 00:11:50.500
to make it easy to run tests.

00:11:50.500 --> 00:11:52.600
And at that point, if
we have a single entry

00:11:52.600 --> 00:11:55.900
point and a unified
test, it fits very well

00:11:55.900 --> 00:11:57.970
within your developer
workflow, because you

00:11:57.970 --> 00:12:01.530
can do local, fast,
iterative development

00:12:01.530 --> 00:12:03.940
on a simulated device.

00:12:03.940 --> 00:12:07.120
Then in pre submit, before you
actually submit your change,

00:12:07.120 --> 00:12:09.954
you can run on an
emulator matrix.

00:12:09.954 --> 00:12:13.210
And lastly in post
submit you can

00:12:13.210 --> 00:12:17.320
run on a remote device, a
physical device in Firebase

00:12:17.320 --> 00:12:18.750
Test Lab.

00:12:18.750 --> 00:12:20.440
And that's really
what we're trying

00:12:20.440 --> 00:12:24.940
to do with Nitrogen.
Nitrogen allows

00:12:24.940 --> 00:12:27.040
you to run tests at scale.

00:12:27.040 --> 00:12:29.130
It is highly configurable.

00:12:29.130 --> 00:12:33.841
It was built with customization
and extensibility in mind.

00:12:33.841 --> 00:12:38.036
You can execute unit and
instrumentation tests.

00:12:38.036 --> 00:12:42.836
It vastly improves reporting,
and therefore debugging.

00:12:42.836 --> 00:12:45.000
And maybe one of the
most exciting things

00:12:45.000 --> 00:12:47.490
is, it ships with its own
virtual device management

00:12:47.490 --> 00:12:52.040
solution that manages
devices for you.

00:12:52.040 --> 00:12:53.750
And that's actually
something I think

00:12:53.750 --> 00:12:56.030
a lot of people in the
community have been asking

00:12:56.030 --> 00:12:57.620
for us for quite a while.

00:13:00.140 --> 00:13:02.830
Nitrogen is cross platform.

00:13:02.830 --> 00:13:04.880
And we really built
it from the ground up

00:13:04.880 --> 00:13:09.200
with all the experience that we
have, seven years in host site

00:13:09.200 --> 00:13:12.560
and device site infrastructure.

00:13:12.560 --> 00:13:16.150
It will support Mac,
Windows, and Linux,

00:13:16.150 --> 00:13:17.280
and is written in Kotlin.

00:13:17.280 --> 00:13:20.350
And we really built it
in a way such that we

00:13:20.350 --> 00:13:22.270
hopefully-- that it's
hopefully going to be

00:13:22.270 --> 00:13:24.260
good for the next seven years.

00:13:28.000 --> 00:13:32.170
Nitrogen, as I was saying,
it's just a standalone tool.

00:13:32.170 --> 00:13:37.436
So it can be easily integrated
into any build system.

00:13:37.436 --> 00:13:41.130
And we're working on
integrations for Gradle,

00:13:41.130 --> 00:13:43.850
and Bazel.

00:13:43.850 --> 00:13:48.070
We're adding shorting and
trail level test execution,

00:13:48.070 --> 00:13:50.530
and continuous
integration support

00:13:50.530 --> 00:13:53.700
will be there from the start.

00:13:53.700 --> 00:13:55.770
On the device site,
we are initially

00:13:55.770 --> 00:13:59.550
planning to have support for
at least simulated, virtual,

00:13:59.550 --> 00:14:03.790
and physical devices,
as well as device labs,

00:14:03.790 --> 00:14:07.150
such as Firebase Test Lan.

00:14:07.150 --> 00:14:10.080
You can even add
your custom devices,

00:14:10.080 --> 00:14:13.630
if you have custom hardware.

00:14:13.630 --> 00:14:16.600
Let's switch gears a little
bit and talk a little bit

00:14:16.600 --> 00:14:19.996
about the high level
architecture of nitrogen.

00:14:19.996 --> 00:14:23.510
So nitrogen is basically
split into two parts.

00:14:23.510 --> 00:14:25.870
We have a host site,
infrastructure,

00:14:25.870 --> 00:14:29.780
that is all the code
that runs on a host.

00:14:29.780 --> 00:14:31.780
And we've done
something new, we also

00:14:31.780 --> 00:14:33.850
have an on device
infrastructure.

00:14:33.850 --> 00:14:36.160
Which basically
means we've moved

00:14:36.160 --> 00:14:39.610
some of our infrastructure
onto the device, which

00:14:39.610 --> 00:14:43.200
is a much saner environment
to reason about.

00:14:43.200 --> 00:14:46.090
And the device is also
the main abstraction

00:14:46.090 --> 00:14:52.290
that we use in nitrogen
for different run times.

00:14:52.290 --> 00:14:54.630
So the host site
runner is mostly

00:14:54.630 --> 00:14:57.420
responsible for finding
a device for you,

00:14:57.420 --> 00:15:01.230
setting up the device
for test execution,

00:15:01.230 --> 00:15:03.950
and then requesting a test run.

00:15:03.950 --> 00:15:08.740
It can be easily configured with
a proto buffer configuration,

00:15:08.740 --> 00:15:11.960
and it allows you
to customize things

00:15:11.960 --> 00:15:16.650
like the test executer and
the whole test harness.

00:15:16.650 --> 00:15:19.660
To decouple the
host from the device

00:15:19.660 --> 00:15:22.290
we have a new
orchestrator service.

00:15:22.290 --> 00:15:26.130
You can think of it as the
brain of test execution

00:15:26.130 --> 00:15:30.150
that runs on a device, and
it's responsible for discovery,

00:15:30.150 --> 00:15:34.776
filtering and sorting,
and execution.

00:15:34.776 --> 00:15:39.920
An orchestrator service
is just a gRPC service

00:15:39.920 --> 00:15:42.776
that can be implemented
by any device.

00:15:42.776 --> 00:15:45.590
And we in fact use
gRPC to communicate

00:15:45.590 --> 00:15:48.650
between the host and the
device, which does not give us

00:15:48.650 --> 00:15:52.640
performance and speed, it also
gives us a lot of stability,

00:15:52.640 --> 00:15:55.100
and it allows us to
stream test results

00:15:55.100 --> 00:15:58.635
back to the host in real time.

00:15:58.635 --> 00:16:01.690
We also have a lot
of extension points.

00:16:01.690 --> 00:16:04.480
So we'll have hosts
plug ins that allow

00:16:04.480 --> 00:16:06.820
you to run code on a host.

00:16:06.820 --> 00:16:08.750
And we'll also have
device plugins,

00:16:08.750 --> 00:16:12.486
that allow you to
run code on a device.

00:16:12.486 --> 00:16:14.235
So let's dive into
each of these sections.

00:16:17.800 --> 00:16:21.490
As I mentioned before, we use
a single proto configuration,

00:16:21.490 --> 00:16:24.854
with a declarative
set of protos.

00:16:24.854 --> 00:16:30.330
This allows you to define
devices, your test fixtures.

00:16:30.330 --> 00:16:33.590
So you can define things like
APKs that you want to install,

00:16:33.590 --> 00:16:36.610
data dependencies that you
want to push on the device.

00:16:36.610 --> 00:16:41.090
And it can declare your
host and device plugins.

00:16:41.090 --> 00:16:45.080
We initially will have support
for single device executers,

00:16:45.080 --> 00:16:49.940
parallel device executers,
to run on multiple devices

00:16:49.940 --> 00:16:51.260
in parallel.

00:16:51.260 --> 00:16:55.290
And we'll also have a new
multi-device executer,

00:16:55.290 --> 00:16:58.910
which will allow you to do
things like orchestrating

00:16:58.910 --> 00:17:01.610
a test run between a
device and a device,

00:17:01.610 --> 00:17:04.040
or a device and a watch.

00:17:04.040 --> 00:17:06.349
Which is something
that we increasingly

00:17:06.349 --> 00:17:09.470
see as a requirement.

00:17:09.470 --> 00:17:13.660
The good news is, if you're
just an app developer,

00:17:13.660 --> 00:17:17.970
you usually don't have to deal
with any of this configuration,

00:17:17.970 --> 00:17:20.800
because it's built in
in the tool integration.

00:17:20.800 --> 00:17:23.410
But if you're an
infrastructure developer,

00:17:23.410 --> 00:17:25.619
this is where it gets
really interesting for you,

00:17:25.619 --> 00:17:32.770
because you can customize every
single bit of Nitrogen. Let's

00:17:32.770 --> 00:17:34.920
talk a little bit about plugins.

00:17:34.920 --> 00:17:36.880
So host plugins,
or plugins, they

00:17:36.880 --> 00:17:39.280
can execute code on the host.

00:17:39.280 --> 00:17:42.310
Plugins that we've already
built are the Android plugin.

00:17:42.310 --> 00:17:44.800
They just encapsulate
all the code

00:17:44.800 --> 00:17:48.560
that allows us to run
Android tests on a device.

00:17:48.560 --> 00:17:52.210
We have a data plugin that
allows us to stage data

00:17:52.210 --> 00:17:54.460
onto the device,
or a fixer script

00:17:54.460 --> 00:17:57.490
plugin which allows
us to execute

00:17:57.490 --> 00:17:59.290
fixer scripts on a device.

00:18:01.920 --> 00:18:04.110
And you can have
your custom plugins.

00:18:04.110 --> 00:18:08.836
Custom plugins can have
their own configuration.

00:18:08.836 --> 00:18:11.270
And with host plugins
you can actually

00:18:11.270 --> 00:18:14.080
run before the
test suite starts,

00:18:14.080 --> 00:18:16.760
and after the test
suite is finished.

00:18:16.760 --> 00:18:19.130
The reason why we
do it this way is

00:18:19.130 --> 00:18:22.940
because we want to avoid the
chattiness between the host

00:18:22.940 --> 00:18:25.085
and the device.

00:18:25.085 --> 00:18:27.470
If you look at the
after all method,

00:18:27.470 --> 00:18:30.350
you will also get
access to the whole test

00:18:30.350 --> 00:18:32.990
with results, which
is great if you

00:18:32.990 --> 00:18:36.490
want to do any post-processing
of your test results.

00:18:36.490 --> 00:18:40.370
And you even can submit
an edit request back to us

00:18:40.370 --> 00:18:43.580
if you want to attach new
artifacts to the test suite

00:18:43.580 --> 00:18:47.360
result.

00:18:47.360 --> 00:18:51.830
Device plugins, on the other
hand, like the name is saying,

00:18:51.830 --> 00:18:54.740
are running on an
actual device, which

00:18:54.740 --> 00:18:57.840
is a much more sane
environment to reason about.

00:18:57.840 --> 00:19:01.070
And in fact, most of
our host site code

00:19:01.070 --> 00:19:03.500
that we used to
configure the device

00:19:03.500 --> 00:19:07.400
is now moved to the device
with a device plugin.

00:19:07.400 --> 00:19:09.500
So plugins that
we've already built

00:19:09.500 --> 00:19:12.860
are a lock at plug-in,
that gives you a scope

00:19:12.860 --> 00:19:17.060
lock at for test method,
a screenshot plugin that

00:19:17.060 --> 00:19:20.372
takes screenshots in
case your tests fail,

00:19:20.372 --> 00:19:22.280
or a permission plugin.

00:19:22.280 --> 00:19:26.260
Which is pretty awesome, because
you can now grant and revoke

00:19:26.260 --> 00:19:28.480
runtime permissions,
which was not able before.

00:19:31.810 --> 00:19:36.400
And you can obviously also
have your custom plugins.

00:19:36.400 --> 00:19:39.900
So the difference from a device
plugin into a host plugin

00:19:39.900 --> 00:19:43.186
is that it runs on a device.

00:19:43.186 --> 00:19:46.362
But this allows us to
do things like that.

00:19:46.362 --> 00:19:50.460
We can give you a callback
before a single test

00:19:50.460 --> 00:19:54.534
method is executed, and
after it's finished.

00:19:54.534 --> 00:19:56.950
And this is great, because we
can avoid all the chattiness

00:19:56.950 --> 00:20:00.310
between the host and the
device, and it gives you

00:20:00.310 --> 00:20:02.020
a lot of control.

00:20:02.020 --> 00:20:05.410
And if you think about it, I
don't how you set up your test

00:20:05.410 --> 00:20:07.930
fixtures now, but usually
you would basically

00:20:07.930 --> 00:20:14.640
use something like @BeforeClass,
or @Before after class.

00:20:14.640 --> 00:20:16.800
If you want something
more reusable,

00:20:16.800 --> 00:20:19.680
you would probably
reach for a [INAUDIBLE]

00:20:19.680 --> 00:20:24.450
or there is some things you
can't do with these APIs.

00:20:24.450 --> 00:20:26.840
And then you have to
have your custom runner.

00:20:26.840 --> 00:20:28.530
And I think the great
thing about this

00:20:28.530 --> 00:20:34.410
is, we give you a whole
new way of writing plugins

00:20:34.410 --> 00:20:36.090
that actually run on
a device, and allow

00:20:36.090 --> 00:20:39.120
you to execute code on it.

00:20:42.380 --> 00:20:44.060
So let's move on to execution.

00:20:44.060 --> 00:20:49.840
So as I was saying, we moved the
execution to the actual device.

00:20:49.840 --> 00:20:52.520
We created a whole new
orchestrator service

00:20:52.520 --> 00:20:54.480
and protocol.

00:20:54.480 --> 00:20:57.490
What this does, it standardizes
is the communication

00:20:57.490 --> 00:21:02.350
between the host and
the device, and it can

00:21:02.350 --> 00:21:04.190
be implemented by any device.

00:21:04.190 --> 00:21:06.880
Which means if you have a
custom device you can implement

00:21:06.880 --> 00:21:11.660
the same protocol, and
you can still integrate

00:21:11.660 --> 00:21:13.450
with a host site easily.

00:21:13.450 --> 00:21:15.900
On Android the
orchestrator service

00:21:15.900 --> 00:21:20.565
is implemented by the
Android Test Orchestrator.

00:21:20.565 --> 00:21:23.690
And once you request the
test run on the host,

00:21:23.690 --> 00:21:28.820
it will then go, discover all
the tests, apply any filters

00:21:28.820 --> 00:21:32.120
and sorting that you
want, and then it

00:21:32.120 --> 00:21:37.024
will do either isolated
or best test execution.

00:21:37.024 --> 00:21:41.000
It will also call all
your device plugins,

00:21:41.000 --> 00:21:45.680
and it will stream results
back in real time to the host.

00:21:48.820 --> 00:21:54.130
So the last thing that I want
to talk about is reporting.

00:21:54.130 --> 00:21:57.030
With Nitrogen we will give
unified and consistent

00:21:57.030 --> 00:21:58.520
reporting.

00:21:58.520 --> 00:22:03.780
As I'm sure many of you have
seen this command at the top.

00:22:03.780 --> 00:22:06.690
What it does is, it runs
an instrumentation test

00:22:06.690 --> 00:22:08.550
from the command line.

00:22:08.550 --> 00:22:13.200
If you use the -r option,
which is verbose mode,

00:22:13.200 --> 00:22:16.156
you'll get an output like this.

00:22:16.156 --> 00:22:20.170
And as you can see, it's
not very human readable,

00:22:20.170 --> 00:22:21.714
I would say.

00:22:21.714 --> 00:22:24.820
And it's also quite chatty,
because this is just

00:22:24.820 --> 00:22:28.320
throwing a single test.

00:22:28.320 --> 00:22:29.680
This is showing a passing test.

00:22:29.680 --> 00:22:32.980
If it fails the only thing
that it gives you in addition

00:22:32.980 --> 00:22:34.640
is a stack trace.

00:22:34.640 --> 00:22:38.890
So there is not really a lot of
information or actionable data

00:22:38.890 --> 00:22:41.560
here to why the test failed.

00:22:44.630 --> 00:22:47.760
With Nitrogen we want to
move to something like this.

00:22:47.760 --> 00:22:50.750
A structured data
format which gives you

00:22:50.750 --> 00:22:54.560
access to the properties
of the test case,

00:22:54.560 --> 00:22:58.580
the status of the test, and
the list of artifacts that were

00:22:58.580 --> 00:23:02.320
collected during a test run.

00:23:02.320 --> 00:23:07.750
Things like screenshots, video,
[? lock@ ?] and any custom

00:23:07.750 --> 00:23:12.900
artifacts that you add
in your post processing.

00:23:12.900 --> 00:23:17.180
Again, this will also be
integrated in Android Studio,

00:23:17.180 --> 00:23:20.600
and we will surface this
in the Android Studio UI

00:23:20.600 --> 00:23:23.310
if you run tests.

00:23:23.310 --> 00:23:26.290
The last thing before I wrap
up what I want to mention

00:23:26.290 --> 00:23:30.660
is, we also have support
for custom reports.

00:23:30.660 --> 00:23:34.110
So you can do things
like [INAUDIBLE] or even

00:23:34.110 --> 00:23:36.750
your custom report
that integrates better

00:23:36.750 --> 00:23:38.950
with your own infrastructure.

00:23:38.950 --> 00:23:41.520
And with that I
want to hand over

00:23:41.520 --> 00:23:45.450
to Visnal, who's going to
talk about device management.

00:23:45.450 --> 00:23:46.320
All right.

00:23:46.320 --> 00:23:47.611
VISNAL SETHIA: Thanks, Stephan.

00:23:51.090 --> 00:23:53.120
Running any kind
of Android UI test

00:23:53.120 --> 00:23:54.470
generally happens in devices.

00:23:54.470 --> 00:23:55.970
There are two
different device types

00:23:55.970 --> 00:23:58.386
where you could run your test,
either on a physical device

00:23:58.386 --> 00:23:59.610
or a watchful device.

00:23:59.610 --> 00:24:02.380
Regardless of which device
type you run your test on,

00:24:02.380 --> 00:24:05.930
each of them has its own
sets of pros and cons.

00:24:05.930 --> 00:24:07.880
Let's just do a
quick show of hands.

00:24:07.880 --> 00:24:11.690
How many people around here have
had setup something like this,

00:24:11.690 --> 00:24:14.150
testing on physical devices?

00:24:14.150 --> 00:24:16.590
Looks like quite a few.

00:24:16.590 --> 00:24:20.850
Follow up question, how
easy was it to manage them?

00:24:20.850 --> 00:24:21.770
Hard?

00:24:21.770 --> 00:24:23.780
Another follow up question.

00:24:23.780 --> 00:24:27.070
Did you ever end up using a
fire extinguisher next to it?

00:24:27.070 --> 00:24:28.432
I seriously hope not.

00:24:28.432 --> 00:24:30.890
I have a funny story to share
that happened a few years ago

00:24:30.890 --> 00:24:32.990
at Google, when one
of the teams decided

00:24:32.990 --> 00:24:36.140
that they wanted to test their
stuff on physical devices.

00:24:36.140 --> 00:24:38.210
They procured a bunch
of devices, glued them

00:24:38.210 --> 00:24:42.390
onto the wall, and integrated
with their CI infrastructure.

00:24:42.390 --> 00:24:44.660
Everything was running
reasonably well until one

00:24:44.660 --> 00:24:48.080
fine day when the engineers came
back to work on Monday morning,

00:24:48.080 --> 00:24:49.700
and things were timing out.

00:24:49.700 --> 00:24:51.752
If you were to guess
what went wrong,

00:24:51.752 --> 00:24:53.210
what would be your
guess look like?

00:24:56.198 --> 00:24:59.690
[INAUDIBLE]

00:24:59.690 --> 00:25:03.420
So it turned out to be an
air conditioner problem.

00:25:03.420 --> 00:25:06.060
So what apparently
happened was the air

00:25:06.060 --> 00:25:08.901
conditioners in the building
in San Francisco went bad.

00:25:08.901 --> 00:25:10.650
And because the air
conditioners went bad,

00:25:10.650 --> 00:25:13.440
the facilities decided that
they want to switch off the air

00:25:13.440 --> 00:25:15.210
conditioner, so that
they could fix it,

00:25:15.210 --> 00:25:17.730
but tests were continuously
running on those devices,

00:25:17.730 --> 00:25:19.560
and the heat produced
in those devices

00:25:19.560 --> 00:25:22.110
caused the glue to
peel off from the wall,

00:25:22.110 --> 00:25:25.560
and all the devices
fell off to the ground.

00:25:25.560 --> 00:25:27.302
Managing physical
devices are hard.

00:25:27.302 --> 00:25:29.885
We just want to give out a huge
shout out to the Firebase test

00:25:29.885 --> 00:25:32.640
lab team, that makes
testing on Firebase Test Lab

00:25:32.640 --> 00:25:34.940
so much easier for you folks.

00:25:34.940 --> 00:25:36.680
How do we solve this at Google?

00:25:36.680 --> 00:25:39.810
At Google we use the virtual
device infrastructure.

00:25:39.810 --> 00:25:43.029
The test environment that
we use is extremely stable.

00:25:43.029 --> 00:25:44.570
The number that you
look at the right

00:25:44.570 --> 00:25:47.000
is the stability ratio
of our test environment,

00:25:47.000 --> 00:25:50.253
and that's right it's 99.9999%.

00:25:50.253 --> 00:25:53.190
The continuous integration
if the virtual device

00:25:53.190 --> 00:25:55.770
infrastructure that
we use has the ability

00:25:55.770 --> 00:25:58.230
to run locally or
in a CI environment.

00:25:58.230 --> 00:26:00.300
And it supports over
500 different device

00:26:00.300 --> 00:26:01.720
configurations.

00:26:01.720 --> 00:26:03.480
Let's dig in a little
deeper to see what

00:26:03.480 --> 00:26:05.910
is its current state at Google.

00:26:05.910 --> 00:26:08.280
It's used by over
100 first party

00:26:08.280 --> 00:26:11.310
apps such as Google
Photos, search, YouTube,

00:26:11.310 --> 00:26:13.090
and so on and so forth.

00:26:13.090 --> 00:26:17.820
Just in 2018 it had a staggering
$2.4 billion invocations,

00:26:17.820 --> 00:26:20.040
and that number is
growing year over year.

00:26:20.040 --> 00:26:24.660
There are over 120,000 targets
that use this infrastructure.

00:26:24.660 --> 00:26:27.030
Having a great test
infrastructure is a must

00:26:27.030 --> 00:26:29.420
if you want to release
high quality apps.

00:26:29.420 --> 00:26:31.420
You'd be thinking, this
is great infrastructure.

00:26:31.420 --> 00:26:34.440
How does this fit
in with Nitrogen?

00:26:34.440 --> 00:26:38.370
If you remember from slides that
Stephan presented a little bit

00:26:38.370 --> 00:26:42.855
earlier, Nitrogen has this
concept of device providers.

00:26:42.855 --> 00:26:45.160
So if you want to
run a UI test, you

00:26:45.160 --> 00:26:47.080
invoke Nitrogen,
Nitrogen in turn

00:26:47.080 --> 00:26:49.210
would invoke a device
provider, which in this case

00:26:49.210 --> 00:26:52.230
is going to be the virtual
device provider, which launches

00:26:52.230 --> 00:26:55.210
a device, does a bunch
of smart setup, returns

00:26:55.210 --> 00:26:57.730
the control back to
Nitrogen, which actually

00:26:57.730 --> 00:26:59.380
goes and executes the test.

00:26:59.380 --> 00:27:02.870
And once the test is done it
goes and tears on the device.

00:27:02.870 --> 00:27:06.190
So in that case you get a
completely stable environment

00:27:06.190 --> 00:27:08.470
which is launched by
nitrogen, runs the test,

00:27:08.470 --> 00:27:10.490
and shuts it down.

00:27:10.490 --> 00:27:12.910
So while designing this
particular infrastructure,

00:27:12.910 --> 00:27:15.670
there were 4 key things
that we kept in mind.

00:27:15.670 --> 00:27:17.230
That virtual device
infrastructure

00:27:17.230 --> 00:27:22.730
needs to be simple to use,
needs to be extremely stable,

00:27:22.730 --> 00:27:25.716
should be reproducible
regardless of which environment

00:27:25.716 --> 00:27:27.590
it runs in, whether
you're running it locally

00:27:27.590 --> 00:27:29.980
or whether you're running
it in RCI infrastructure.

00:27:29.980 --> 00:27:32.360
And it needs to
be extremely fast.

00:27:32.360 --> 00:27:34.160
Let's dig into a
little deeper as to how

00:27:34.160 --> 00:27:36.170
did we achieve each
of these four goals

00:27:36.170 --> 00:27:40.130
in building a virtual
device management solution.

00:27:40.130 --> 00:27:43.760
So the virtual
device infrastructure

00:27:43.760 --> 00:27:46.010
has a very simple
product configuration.

00:27:46.010 --> 00:27:46.880
What does that mean?

00:27:46.880 --> 00:27:48.380
It's just a
configuration file where

00:27:48.380 --> 00:27:51.210
you could go and add the
characteristics of the device.

00:27:51.210 --> 00:27:53.487
For example, what's the
horizontal screen resolution?

00:27:53.487 --> 00:27:55.070
What's the vertical
screen resolution?

00:27:55.070 --> 00:27:56.760
What's the memory of the device?

00:27:56.760 --> 00:27:59.150
So for each of these
different device types,

00:27:59.150 --> 00:28:02.846
like Nexus and Pixel, the
virtual device management

00:28:02.846 --> 00:28:04.470
solution already has
pretty [INAUDIBLE]

00:28:04.470 --> 00:28:06.532
in all of these different
device configurations.

00:28:06.532 --> 00:28:08.990
So you don't have to go and
figure out the different device

00:28:08.990 --> 00:28:11.700
resolutions for each
of those devices.

00:28:11.700 --> 00:28:15.140
It supports over 500 different
device configurations.

00:28:15.140 --> 00:28:16.970
And because it's a
configuration file

00:28:16.970 --> 00:28:20.060
it's a matter of just adding
or removing the changes

00:28:20.060 --> 00:28:21.590
to the configuration file.

00:28:21.590 --> 00:28:24.050
And it supports several
different form factors

00:28:24.050 --> 00:28:27.590
such as phones, tablets, TV
devices, in wear devices.

00:28:27.590 --> 00:28:29.840
But how is it simple?

00:28:29.840 --> 00:28:32.270
Launching it is as simple as
calling the virtual device

00:28:32.270 --> 00:28:34.860
binary, and specifying
the name of the device.

00:28:34.860 --> 00:28:38.330
If you want to launch a Pixel
2, you just say virtual device,

00:28:38.330 --> 00:28:40.800
device equals Pixel 2,
and on what API level.

00:28:40.800 --> 00:28:43.340
You don't have to worry
about creating AVDs,

00:28:43.340 --> 00:28:45.800
specifying configurations
and things like that.

00:28:45.800 --> 00:28:49.204
That makes things
extremely simple.

00:28:49.204 --> 00:28:50.099
Stability.

00:28:50.099 --> 00:28:52.140
This is probably one of
the biggest problems most

00:28:52.140 --> 00:28:54.330
of the Android app
developers face,

00:28:54.330 --> 00:28:57.240
like you running your
test, and an ANR pops up.

00:28:57.240 --> 00:28:59.070
And that ANR might
not even necessarily

00:28:59.070 --> 00:29:00.670
be the app that you're testing.

00:29:00.670 --> 00:29:03.840
We had the same problem
internally as well.

00:29:03.840 --> 00:29:05.800
How did we solve this?

00:29:05.800 --> 00:29:07.630
Well, sorry.

00:29:07.630 --> 00:29:10.860
I wrote has a nifty service
call as activity controller

00:29:10.860 --> 00:29:13.680
that lets you suppress
ANR's whenever it sees them.

00:29:13.680 --> 00:29:17.490
This is the exact same service
that Android Monkey uses

00:29:17.490 --> 00:29:19.140
while it runs Monkey tests.

00:29:19.140 --> 00:29:22.047
This increased stability
of our test [INAUDIBLE]

00:29:22.047 --> 00:29:23.880
like one of the things
that I forgot to say,

00:29:23.880 --> 00:29:26.300
when we started with this
particular infrastructure,

00:29:26.300 --> 00:29:28.290
our stability was around 95%.

00:29:28.290 --> 00:29:30.700
But that's no good when you're
running things at scale.

00:29:30.700 --> 00:29:33.000
So the first thing
that we saw were

00:29:33.000 --> 00:29:36.360
ANRs, and once we fixed that our
stability increased, but still

00:29:36.360 --> 00:29:39.450
not to the level that we wanted.

00:29:39.450 --> 00:29:41.130
The next [INAUDIBLE]
things that we saw

00:29:41.130 --> 00:29:44.850
was, we boot up a device, but
the screen is not unlocked.

00:29:44.850 --> 00:29:46.440
And if the screen
is not unlocked,

00:29:46.440 --> 00:29:48.000
all the key events
that you inject

00:29:48.000 --> 00:29:49.470
does not even reach your app.

00:29:49.470 --> 00:29:51.794
And if the key events
don't reach your app,

00:29:51.794 --> 00:29:53.460
your app is actually
not getting tested,

00:29:53.460 --> 00:29:55.110
and your test started to fail.

00:29:55.110 --> 00:29:57.720
And it turned out when
the device boots up,

00:29:57.720 --> 00:29:59.340
the screen is not locked.

00:29:59.340 --> 00:30:03.000
So when a screen is not
unlocked, in APL 23,

00:30:03.000 --> 00:30:06.970
I believe Android added an
API from our window manager,

00:30:06.970 --> 00:30:08.566
where you could
dismiss the key guard,

00:30:08.566 --> 00:30:09.940
and that would
unlock the screen.

00:30:09.940 --> 00:30:11.620
So every time you
boot up the device,

00:30:11.620 --> 00:30:14.670
we would call the Window Manager
API to unlock the screen.

00:30:14.670 --> 00:30:18.840
And this increase our
stability furthermore.

00:30:18.840 --> 00:30:21.300
A few years ago Android
changed the file system

00:30:21.300 --> 00:30:24.180
from via FFS, which meant
yet another flash file

00:30:24.180 --> 00:30:26.100
system, to EXD4.

00:30:26.100 --> 00:30:27.840
This was a great
improvement, but it

00:30:27.840 --> 00:30:29.690
had its own set of problems.

00:30:29.690 --> 00:30:32.670
EXD4 was known was
prone to disk corruption

00:30:32.670 --> 00:30:34.210
during a hard shutdown.

00:30:34.210 --> 00:30:36.320
So whenever we would
shut down the device,

00:30:36.320 --> 00:30:39.390
if it was not correctly shut
down and it had disk errors,

00:30:39.390 --> 00:30:42.570
your subsequent boot of the
virtual device would fail.

00:30:42.570 --> 00:30:45.070
Leading to test flakiness.

00:30:45.070 --> 00:30:46.750
How did we solve this problem?

00:30:46.750 --> 00:30:49.950
Well, all we had to do was
call in [INAUDIBLE] to the disk

00:30:49.950 --> 00:30:52.200
image that was
unmounted, and this

00:30:52.200 --> 00:30:54.780
guaranteed that when
the disk was unmounted

00:30:54.780 --> 00:30:57.630
it had no disk errors, and
if there were no disk errors

00:30:57.630 --> 00:31:00.900
your subsequent boot
would come up just fine.

00:31:00.900 --> 00:31:04.470
This increased the stability
of our test environment

00:31:04.470 --> 00:31:07.470
to close to 99%, but
that's still no good.

00:31:07.470 --> 00:31:10.260
When you're running a
$2.4 billion invocations,

00:31:10.260 --> 00:31:12.690
a one person failure
is 24 million.

00:31:12.690 --> 00:31:14.940
That's still a huge number.

00:31:14.940 --> 00:31:17.130
As you can see, there were
a bunch of optimizations

00:31:17.130 --> 00:31:18.960
that we did to
increase the stability.

00:31:18.960 --> 00:31:21.180
I'm not going to talk
about all of them,

00:31:21.180 --> 00:31:24.700
but there's one final thing
that I want to talk about.

00:31:24.700 --> 00:31:26.470
You would launch the
device, but for--

00:31:26.470 --> 00:31:29.550
and the virtual device would
set a boot properly saying

00:31:29.550 --> 00:31:31.380
that the device is
completely booted up.

00:31:31.380 --> 00:31:35.400
But for whatever reasons the
launcher would not kick in.

00:31:35.400 --> 00:31:37.060
So how did we
solve that problem?

00:31:37.060 --> 00:31:40.710
Well, all we had to do was send
out an intent to the launcher.

00:31:40.710 --> 00:31:42.810
If it was already launched
and it was a no op,

00:31:42.810 --> 00:31:45.570
if it wasn't launched then
it started the launcher,

00:31:45.570 --> 00:31:47.070
and then we would
return the control

00:31:47.070 --> 00:31:50.970
back to Nitrogen, which would
then go and run the test.

00:31:50.970 --> 00:31:53.340
Doing a bunch of
optimizations like this help

00:31:53.340 --> 00:31:58.180
us get to 99.9999% stability.

00:31:58.180 --> 00:32:04.539
The next big pillar that we had
in mind was reproducibility.

00:32:04.539 --> 00:32:06.705
So a lot of times when users
were running their test

00:32:06.705 --> 00:32:08.704
in [INAUDIBLE] environment,
if their test failed

00:32:08.704 --> 00:32:12.200
for whatever reasons, they had
no way of debugging it locally.

00:32:12.200 --> 00:32:14.860
So our virtual device
environment that we built

00:32:14.860 --> 00:32:17.530
had to make sure that the
environment was reproducible

00:32:17.530 --> 00:32:19.180
regardless of where
they are running.

00:32:19.180 --> 00:32:21.490
So the virtual device
management solution

00:32:21.490 --> 00:32:25.240
helps you launch things
locally, or on the cloud.

00:32:25.240 --> 00:32:28.690
And one of the big things
about this environment

00:32:28.690 --> 00:32:31.360
is the device starts in
a clean, pristine state

00:32:31.360 --> 00:32:32.710
for every indication.

00:32:32.710 --> 00:32:34.250
So there is no state
carried forward

00:32:34.250 --> 00:32:36.460
between different
invocations making sure

00:32:36.460 --> 00:32:38.380
like tests are going
to be extremely stable,

00:32:38.380 --> 00:32:41.275
and not fail because
of the device itself.

00:32:44.110 --> 00:32:45.150
Android Shell.

00:32:45.150 --> 00:32:48.330
There are several teams within
Google that write NDK code.

00:32:48.330 --> 00:32:49.980
Like when you're
writing native code.

00:32:49.980 --> 00:32:51.960
And they wanted to
test their native code.

00:32:51.960 --> 00:32:53.580
But to test their
native code, they

00:32:53.580 --> 00:32:55.620
wanted to boot up arm devices.

00:32:55.620 --> 00:32:58.080
And booting up arm devices
were extremely slow.

00:32:58.080 --> 00:33:00.720
For example on Nougat,
booting up an arm device

00:33:00.720 --> 00:33:02.050
takes about 10 minutes.

00:33:02.050 --> 00:33:04.740
And this was slowing
things down tremendously.

00:33:04.740 --> 00:33:07.410
This made us go back to the
drawing board to see what could

00:33:07.410 --> 00:33:09.514
we do to increase the--

00:33:09.514 --> 00:33:11.805
to decrease the time it takes
to boot up those devices.

00:33:16.630 --> 00:33:19.440
So we ended up going and
created a mini boot mode

00:33:19.440 --> 00:33:20.650
in the virtual device.

00:33:20.650 --> 00:33:22.420
What does mini boot mode mean?

00:33:22.420 --> 00:33:24.100
We, like for
testing native code,

00:33:24.100 --> 00:33:25.570
you don't need
the entire Android

00:33:25.570 --> 00:33:26.800
stack to be up and running.

00:33:26.800 --> 00:33:28.955
All you need is technically
the Linux kernel,

00:33:28.955 --> 00:33:30.580
and if the kernel is
up and running you

00:33:30.580 --> 00:33:32.320
could test your native API.

00:33:32.320 --> 00:33:36.100
So we ended up adding a mini
boot mode to our virtual device

00:33:36.100 --> 00:33:39.770
launcher which would come
up in less than 30 seconds,

00:33:39.770 --> 00:33:42.410
and that would
help the indicator

00:33:42.410 --> 00:33:45.700
upwards to test their native
code much more quickly.

00:33:45.700 --> 00:33:48.590
At Google we make a lot
of data driven decisions.

00:33:48.590 --> 00:33:50.980
So because we were
running things at scale,

00:33:50.980 --> 00:33:53.710
where we were spending
the bulk of our time

00:33:53.710 --> 00:33:54.700
while running our test.

00:33:54.700 --> 00:33:56.530
And it turned out
50% of our time

00:33:56.530 --> 00:34:00.370
was spent in booting up the
emulator, 30% of the time

00:34:00.370 --> 00:34:03.110
was spent in installing an app,
because of a process called

00:34:03.110 --> 00:34:04.300
list x tool.

00:34:04.300 --> 00:34:09.040
And 20% of the time was spent
in running the test itself.

00:34:09.040 --> 00:34:12.969
Android made a change
between Lollipop and Nougat

00:34:12.969 --> 00:34:15.219
where they wanted to do
ahead of time compilation

00:34:15.219 --> 00:34:18.570
using a tool called Dex2Oat.

00:34:18.570 --> 00:34:22.199
So because the app installation
times were so huge,

00:34:22.199 --> 00:34:25.590
what we ended up doing was,
you have the exact same device,

00:34:25.590 --> 00:34:28.290
the exact same app under
test that's being tested,

00:34:28.290 --> 00:34:30.360
and the exact same
Dex2Oat file--

00:34:30.360 --> 00:34:32.639
the exact Oat file
being generated

00:34:32.639 --> 00:34:34.350
for every test invocation.

00:34:34.350 --> 00:34:38.429
What we said was, what if we
move this as a single action

00:34:38.429 --> 00:34:41.360
as on the Bazel bell
graph, and reuse

00:34:41.360 --> 00:34:44.340
the old file that was generated
for all your test runs?

00:34:44.340 --> 00:34:47.010
This significantly reduced
the app install time

00:34:47.010 --> 00:34:51.170
from over 3 minutes for one
of the apps to under a minute.

00:34:51.170 --> 00:34:53.510
If you were here earlier
today when the emulator

00:34:53.510 --> 00:34:56.210
team presented about snapshots,
where you could boot up

00:34:56.210 --> 00:34:59.180
an emulator, safety
snapshot, and then shut down

00:34:59.180 --> 00:35:01.160
the emulator, and
when you restarted

00:35:01.160 --> 00:35:03.395
it restarts back
from the same state.

00:35:03.395 --> 00:35:05.660
Well, we integrated the
snapshot feature back

00:35:05.660 --> 00:35:08.990
into virtual device launcher
where you put up a device,

00:35:08.990 --> 00:35:12.020
take a snapshot, shut it
down, and then reuse it

00:35:12.020 --> 00:35:13.900
when the test actually runs.

00:35:13.900 --> 00:35:17.590
This significantly reduced
our test runtime by over 30%.

00:35:17.590 --> 00:35:21.660
Just imagine when you run tests
at 2.4 billion invocations,

00:35:21.660 --> 00:35:24.560
reducing test times
by 30% would yield

00:35:24.560 --> 00:35:26.780
a huge number of--
like you'd save

00:35:26.780 --> 00:35:29.600
huge amounts of CPOE resources.

00:35:29.600 --> 00:35:32.600
One of the other features that
we want to work out probably

00:35:32.600 --> 00:35:34.550
next year is Cloud
snapshots, which

00:35:34.550 --> 00:35:36.710
is a combination of
Textural on the Cloud,

00:35:36.710 --> 00:35:40.740
and snapshots called
Cloud snapshots.

00:35:40.740 --> 00:35:43.090
But this, we come to
our end of our talk

00:35:43.090 --> 00:35:46.000
where with Nitrogen you'd be
able to run your test at scale

00:35:46.000 --> 00:35:48.100
in a completely
stable environment,

00:35:48.100 --> 00:35:50.480
with all of these
different pillars.

00:35:50.480 --> 00:35:52.390
This is our next
generation platform

00:35:52.390 --> 00:35:55.880
that will help you test.

00:35:55.880 --> 00:35:57.860
In this talk we did
do a lot of technical,

00:35:57.860 --> 00:36:00.260
stuff like text
dump, [INAUDIBLE],,

00:36:00.260 --> 00:36:01.345
activity controller.

00:36:01.345 --> 00:36:02.720
You don't have to
worry about any

00:36:02.720 --> 00:36:04.700
of those things, because
all of these things

00:36:04.700 --> 00:36:07.130
are already incorporated
in Nitrogen as well

00:36:07.130 --> 00:36:09.110
as the virtual device
management solution,

00:36:09.110 --> 00:36:12.210
and all you have to
do is like use this.

00:36:12.210 --> 00:36:17.260
So we are hoping to release
Nitrogen alpha in Q1

00:36:17.260 --> 00:36:20.647
of next year of the virtual
device management solution

00:36:20.647 --> 00:36:22.480
is going to be at least
around the same time

00:36:22.480 --> 00:36:24.535
as well, with an alpha release.

00:36:24.535 --> 00:36:27.730
FireBase Test Lab is actually
integrating with Nitrogen

00:36:27.730 --> 00:36:29.850
as well to run your tests.

00:36:29.850 --> 00:36:31.600
One of the things that
Stephan pointed out

00:36:31.600 --> 00:36:34.810
earlier about integration
of Android Studio and Gradle

00:36:34.810 --> 00:36:37.180
with Nitrogen.
Just imagine you're

00:36:37.180 --> 00:36:39.340
sitting in front of
your Androids Studio,

00:36:39.340 --> 00:36:41.980
you hit the run test button,
which actually involves

00:36:41.980 --> 00:36:44.660
Nitrogen, which could actually
launch the virtual device,

00:36:44.660 --> 00:36:47.320
run your test, and give you
results back on your Android

00:36:47.320 --> 00:36:50.400
Studio itself.

00:36:50.400 --> 00:36:51.360
And that's about it.

00:36:51.360 --> 00:36:52.193
Thank you very much.

00:37:00.372 --> 00:37:01.330
DAN GALPIN: Is that it?

00:37:01.330 --> 00:37:01.830
All right.

00:37:01.830 --> 00:37:03.600
Well, hey everyone.

00:37:03.600 --> 00:37:07.660
I wanted to thank you all
for coming and attending

00:37:07.660 --> 00:37:09.010
the Android Dev Summit.

00:37:09.010 --> 00:37:13.657
It is a really, really amazing
to be able to do this again.

00:37:13.657 --> 00:37:15.240
We really want to
know what you think,

00:37:15.240 --> 00:37:16.448
and this is really important.

00:37:16.448 --> 00:37:19.060
So all of you should
by now or very soon

00:37:19.060 --> 00:37:20.860
will get a survey in your inbox.

00:37:20.860 --> 00:37:22.930
Please, please,
please, fill it out.

00:37:22.930 --> 00:37:25.480
Because it is--
we so much wanted

00:37:25.480 --> 00:37:27.190
to make this event amazing.

00:37:27.190 --> 00:37:31.030
Should we ever do it again we
really want to know what worked

00:37:31.030 --> 00:37:33.570
and what didn't work, what
you like what you didn't like.

00:37:33.570 --> 00:37:35.590
Less Dan Galpin, maybe.

00:37:35.590 --> 00:37:39.160
Second thing is, we are going--
we have these QR codes which

00:37:39.160 --> 00:37:42.601
we might build to put up
one more time, hopefully.

00:37:42.601 --> 00:37:44.590
And these are how you
rate the sessions.

00:37:44.590 --> 00:37:46.870
And so we want to know
what sessions you loved,

00:37:46.870 --> 00:37:49.000
what sessions you only liked.

00:37:49.000 --> 00:37:52.870
What sessions you sat through
because they were there

00:37:52.870 --> 00:37:54.520
in the same room,
and you were kind of

00:37:54.520 --> 00:37:56.090
comfortable in your seat.

00:37:56.090 --> 00:37:57.734
So please also fill
out these surveys

00:37:57.734 --> 00:37:58.900
and let us know what worked.

00:37:58.900 --> 00:38:02.120
I know it's a lot of work,
but I really appreciate that.

00:38:02.120 --> 00:38:06.370
And ultimately if you missed
anything, all of these talks

00:38:06.370 --> 00:38:09.170
are actually up
today right now--

00:38:09.170 --> 00:38:10.900
OK I guess that's gone.

00:38:10.900 --> 00:38:13.600
All the talks that we have are
up on the Android Developers

00:38:13.600 --> 00:38:14.790
YouTube channel.

00:38:14.790 --> 00:38:18.460
And so again, I think--
and from yesterday

00:38:18.460 --> 00:38:21.115
and most of them from
today are already going up.

00:38:21.115 --> 00:38:22.990
And by I think the end
of tonight all of them

00:38:22.990 --> 00:38:24.020
will be up on the channel.

00:38:24.020 --> 00:38:25.769
So you'll be able to
even go home tonight,

00:38:25.769 --> 00:38:28.930
if you haven't had enough
Android Dev Summit by now,

00:38:28.930 --> 00:38:30.760
you can even have
more from the comfort

00:38:30.760 --> 00:38:32.425
of your very own History Museum.

00:38:35.160 --> 00:38:38.680
And finally, we have a
little bit of a final reel

00:38:38.680 --> 00:38:43.330
here of just some of what was
going on here that we will

00:38:43.330 --> 00:38:47.680
share to you as you think about
wandering out here and going

00:38:47.680 --> 00:38:49.390
back to the real world.

00:38:49.390 --> 00:38:52.222
So thank you so much
for coming, again.

00:38:52.222 --> 00:38:53.164
[APPLAUSE]

00:38:53.164 --> 00:38:54.110
[VIDEO PLAYBACK]

00:38:54.110 --> 00:38:58.670
- Welcome to the 2018
Android Developer Summit.

00:38:58.670 --> 00:39:02.000
This is an event for
developers, by developers.

00:39:07.750 --> 00:39:13.660
- With 2 billion devices,
3/4 of a trillion apps

00:39:13.660 --> 00:39:16.570
downloaded every year,
Android developer community

00:39:16.570 --> 00:39:17.890
is growing hugely.

00:39:17.890 --> 00:39:20.520
We saw it more than double
just in the past few years.

00:39:36.490 --> 00:39:40.000
- So the Android App Bundle
makes it much simpler.

00:39:40.000 --> 00:39:42.820
With no additional
developer work needed,

00:39:42.820 --> 00:39:45.550
the App Bundle now
makes apps an average

00:39:45.550 --> 00:39:50.715
of 8% smaller for download
for end plus devices.

00:39:50.715 --> 00:39:53.160
- We simply could not
do this without you.

00:39:53.160 --> 00:39:55.140
So thank you.

00:39:55.140 --> 00:39:55.740
[END PLAYBACK]

00:39:55.740 --> 00:40:02.990
[MUSIC PLAYING]

