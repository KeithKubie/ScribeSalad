WEBVTT
Kind: captions
Language: en

00:00:01.500 --> 00:00:03.150
It's buffering, and we're live.

00:00:03.150 --> 00:00:07.610
Hi everyone, yep, my name's Mark,
I'm a coach at Udacity, and.

00:00:07.610 --> 00:00:10.950
&gt;&gt; I'm Andy, I'm helping guide
you through this Nanodegree.

00:00:10.950 --> 00:00:15.559
&gt;&gt; Awesome, yes, so today will be
having a live coding session with Andy,

00:00:15.559 --> 00:00:17.458
specifically about Python.

00:00:17.458 --> 00:00:22.155
So last week we had a coding session
with Andy about HTML and CSS, right?

00:00:22.155 --> 00:00:23.123
&gt;&gt; Yeah.
&gt;&gt; And now, and

00:00:23.123 --> 00:00:26.055
now we are diving into
the world of Python program.

00:00:26.055 --> 00:00:29.275
Now before we start having
Andy do our coding session,

00:00:29.275 --> 00:00:33.845
I want to have a little
announcement specially for

00:00:33.845 --> 00:00:38.880
Windows users who are having trouble
submitting their projects in our portal.

00:00:38.880 --> 00:00:41.090
There was an error for Windows users.

00:00:41.090 --> 00:00:44.875
They could not submit their file for
grading.

00:00:44.875 --> 00:00:46.810
That has been resolved.

00:00:46.810 --> 00:00:49.390
So, our engineers just fixed it today.

00:00:49.390 --> 00:00:54.320
They're pushing the code live to our
production servers right now, so,

00:00:54.320 --> 00:00:59.100
at the end of today, please resubmit
your file, again, and it should work.

00:00:59.100 --> 00:01:03.440
Now, if it does not work,
please let us know on the forums, or

00:01:03.440 --> 00:01:10.424
email us at
introprogramming-support@udacidy.com.

00:01:10.424 --> 00:01:17.690
Once again, it's
introprogramming-support@udacitycom.

00:01:17.690 --> 00:01:20.231
Okay, great now I'm just
going to hand over to Andy.

00:01:20.231 --> 00:01:25.482
&gt;&gt; All right, so the purpose of this
live coding session is to walk through

00:01:25.482 --> 00:01:30.663
how I think about solving large
problems that involves programming.

00:01:30.663 --> 00:01:32.703
I've heard a lot of
feedback in the forums,

00:01:32.703 --> 00:01:36.248
especially people who've made it
a decent ways through the second course.

00:01:36.248 --> 00:01:39.168
That you can read the code that
somebody else has written,

00:01:39.168 --> 00:01:41.969
you can see the solutions,
sort of get what it does, but

00:01:41.969 --> 00:01:45.160
have a hard time coming up
with an answer on your own.

00:01:45.160 --> 00:01:46.860
And that's very normal,

00:01:46.860 --> 00:01:49.580
that is a stage of learning to
program that you go through.

00:01:49.580 --> 00:01:53.484
This stuff takes a lot of practice and
it's going to take a lot of time before

00:01:53.484 --> 00:01:56.364
you get to the point where
you can create problems, or

00:01:56.364 --> 00:02:00.590
create solutions to big problems on your
own in any reasonable amount of time,

00:02:00.590 --> 00:02:02.148
but it comes with practice.

00:02:02.148 --> 00:02:05.457
And one way to get that practice is to
see how other people go about solving

00:02:05.457 --> 00:02:08.235
those problems, and so
that's what we're going to do today.

00:02:08.235 --> 00:02:12.253
If you're in the most recent cohort,
the one that began in March,

00:02:12.253 --> 00:02:16.220
you're probably still thinking
about HTML, and that's fine.

00:02:17.630 --> 00:02:19.170
This may not be as useful for

00:02:19.170 --> 00:02:21.810
you as it is for people who have
already started working on Python.

00:02:21.810 --> 00:02:22.890
It may be a little useful,

00:02:22.890 --> 00:02:27.320
seeing how I think about decomposing
a big problem into smaller pieces.

00:02:27.320 --> 00:02:30.260
But it's going to be hard to follow
along, so keep that in mind.

00:02:30.260 --> 00:02:32.858
Next week we'll do something
a little more HTML-friendly.

00:02:32.858 --> 00:02:36.704
But for now,
we're going to do this in Python, and so

00:02:36.704 --> 00:02:39.306
let me share my screen, so we can.

00:02:39.306 --> 00:02:40.646
&gt;&gt; Let me know when you share it so
I can,

00:02:40.646 --> 00:02:43.225
[BLANK_AUDIO]

00:02:43.225 --> 00:02:44.205
Put you online.

00:02:44.205 --> 00:02:46.933
[BLANK_AUDIO]

00:02:46.933 --> 00:02:48.700
Let's see.

00:02:48.700 --> 00:02:50.150
All right, you're sharing your screen.

00:02:50.150 --> 00:02:53.080
&gt;&gt; All right, so
the problem we want to solve today

00:02:55.080 --> 00:03:00.780
is writing something that we check to
see if a Sudoku solution is correct.

00:03:00.780 --> 00:03:05.240
I chose this because you can represent
a Sudoku puzzle pretty easily

00:03:05.240 --> 00:03:07.460
as it's just a list of lists.

00:03:07.460 --> 00:03:10.334
And I know that depending on how far
in the nanodegree you are so far,

00:03:10.334 --> 00:03:13.630
you know what lists are and
you have some familiarity with that.

00:03:13.630 --> 00:03:18.890
If you don't, that's okay, follow along
or save, come back to this video later.

00:03:18.890 --> 00:03:20.715
But Sudoku, it's a puzzle,

00:03:20.715 --> 00:03:24.298
you get a grid that's partially
filled out with numbers.

00:03:24.298 --> 00:03:28.736
And the goal,
you can see the red numbers here.

00:03:28.736 --> 00:03:32.690
You have to fill it out in such a way
that as you go across all of the rows,

00:03:32.690 --> 00:03:34.648
you use the numbers 1 through 9.

00:03:34.648 --> 00:03:38.026
As you go down all the columns,
you use the numbers 1 through 9.

00:03:38.026 --> 00:03:45.580
So in this column you'll see 1,
2, 3, 4, 5, 6, 7, 8, and 9.

00:03:45.580 --> 00:03:47.950
And then, likewise, there's all these,
you see these nine squares.

00:03:47.950 --> 00:03:51.928
Square 0, square 1, 2, 3, 4, 5, 6, 7, 8.

00:03:51.928 --> 00:03:53.188
Sorry, I counted from 0.

00:03:53.188 --> 00:03:55.520
Thatâ€™s me being a Python person.

00:03:55.520 --> 00:03:59.627
But you can tell that each of these
squares also uses the numbers 1 to 9.

00:03:59.627 --> 00:04:02.499
So, I just phrased to
you how to check and

00:04:02.499 --> 00:04:05.888
see if a solution is correct in Sudoku,
right?

00:04:05.888 --> 00:04:08.810
Check the rows, check the columns,
check the squares.

00:04:08.810 --> 00:04:10.160
How do we do that with programming?

00:04:10.160 --> 00:04:12.400
How do we begin to approach
this giant problem?

00:04:13.758 --> 00:04:16.339
So let me pull up Sublime Text.

00:04:16.339 --> 00:04:19.415
And feel free to ask
questions along the way.

00:04:19.415 --> 00:04:21.490
Mark's keeping an eye on the forum,
what you guys are saying so

00:04:21.490 --> 00:04:22.850
if there's any questions,
I'll try and get to them.

00:04:24.080 --> 00:04:25.690
So I hope you can see this.

00:04:25.690 --> 00:04:26.540
&gt;&gt; Yeah, it looks pretty good.

00:04:26.540 --> 00:04:27.090
&gt;&gt; It's good?
&gt;&gt; Yeah.

00:04:28.500 --> 00:04:33.420
&gt;&gt; So I wrote down three steps that I
like to follow when solving a problem.

00:04:33.420 --> 00:04:35.560
First I want to understand
the problem and

00:04:35.560 --> 00:04:38.770
I'm going to think of understanding
it in terms of inputs and outputs.

00:04:38.770 --> 00:04:41.522
This isn't how we think as humans,
but it's how we think as programmers,

00:04:41.522 --> 00:04:42.976
because that's how computers think.

00:04:42.976 --> 00:04:44.292
[BLANK_AUDIO]

00:04:44.292 --> 00:04:46.763
Then I'm going to plan a solution, and

00:04:46.763 --> 00:04:50.198
I'll show you how to go
about planning a solution.

00:04:50.198 --> 00:04:52.544
Then I'm going to fill it out,
and I said fill it out, and

00:04:52.544 --> 00:04:54.230
you'll see what I mean by that as we go.

00:04:56.430 --> 00:04:58.640
So, first,
let's understand the Sudoku problem.

00:04:58.640 --> 00:05:00.130
What are the inputs?

00:05:00.130 --> 00:05:04.905
I want to represent a Sudoku puzzle as
a grid like this, and I called this

00:05:04.905 --> 00:05:09.210
invalid_grid because this doesn't meet
some of the specifications of Sudoku.

00:05:09.210 --> 00:05:11.518
You can tell this grid is a list.

00:05:11.518 --> 00:05:16.829
So, here is the outermost
brackets to the list, and

00:05:16.829 --> 00:05:21.898
inside that list,
I have nine lists, one, two,

00:05:21.898 --> 00:05:27.232
three, four, five, six,
seven, eight, nine.

00:05:27.232 --> 00:05:31.708
And you can probably guess how this is
supposed to represent that Sudoku board.

00:05:31.708 --> 00:05:35.072
I didn't represent any squares in
here yet but that was a choice,

00:05:35.072 --> 00:05:36.428
we'll get to that later.

00:05:36.428 --> 00:05:40.860
And this code down here,
I just found a valid Sudoku puzzle.

00:05:40.860 --> 00:05:44.783
So this solution actually check out the
rows have the correct number of numbers,

00:05:44.783 --> 00:05:47.680
the columns do to and
the same with the squares, all right?

00:05:50.620 --> 00:05:54.060
So I understand the inputs in
the case of the Sudoku puzzle.

00:05:54.060 --> 00:05:59.984
I'll say it's a list of lists and
maybe I would give an example but

00:05:59.984 --> 00:06:05.820
I did that down here in invalid grid,
and then the outputs.

00:06:05.820 --> 00:06:11.970
Well, all I want to know is if a given
input is a good solution to a Sudoku,

00:06:11.970 --> 00:06:13.250
or if it's not.

00:06:13.250 --> 00:06:15.950
So, true or false.

00:06:15.950 --> 00:06:16.770
That's how it's going to output.

00:06:18.160 --> 00:06:22.560
I might have some print statements along
the way to help me as I think about

00:06:22.560 --> 00:06:24.300
debugging this thing, but
we'll get to that in a second.

00:06:25.400 --> 00:06:28.440
Now, let's plan a solution,
and since I don't have paper,

00:06:28.440 --> 00:06:30.830
I'm going to opt for
this pretend code version.

00:06:31.880 --> 00:06:33.120
Let me show you what that means.

00:06:34.470 --> 00:06:37.050
So I'm going to write code,
and I'm going to pretend

00:06:38.190 --> 00:06:40.720
like I have access to functions
that I haven't even written yet.

00:06:40.720 --> 00:06:41.910
And that turns out, for me,

00:06:41.910 --> 00:06:44.348
to be a really helpful way to
approach these big problems.

00:06:44.348 --> 00:06:49.108
Instead of diving into the details
first, I'm going to make a function.

00:06:49.108 --> 00:06:51.108
Let me just mark it in there.

00:06:51.108 --> 00:06:55.608
I'm going to call it check_sudoku.

00:06:55.608 --> 00:07:01.435
It's going to take as
input a sudoku_grid.

00:07:01.435 --> 00:07:04.215
Now, what do I want this
check_sudoku function to do?

00:07:04.215 --> 00:07:05.700
Let's see.

00:07:05.700 --> 00:07:11.070
Well, I want it to return
true if it's a valid Sudoku.

00:07:11.070 --> 00:07:12.700
So how will I tell if
it's a valid Sudoku?

00:07:12.700 --> 00:07:16.526
What we talked about earlier, we need
to check the rows, the columns, and

00:07:16.526 --> 00:07:17.268
the squares.

00:07:17.268 --> 00:07:18.228
So I'm going to write this.

00:07:18.228 --> 00:07:26.064
If check_rows(sudoku_grid).

00:07:26.064 --> 00:07:28.850
I'm going to write equals True,
you don't actually need that but

00:07:28.850 --> 00:07:30.180
I'm going to write that to
make it a little more clear.

00:07:32.070 --> 00:07:34.139
And then I'm going to
print just to let me know,

00:07:34.139 --> 00:07:36.926
let me keep track what's going on,
that the rows look good.

00:07:36.926 --> 00:07:39.818
[BLANK_AUDIO]

00:07:39.818 --> 00:07:43.751
Then I'm going to check the columns,

00:07:43.751 --> 00:07:48.880
check_columns of
the sudoku_grid is True.

00:07:48.880 --> 00:07:50.093
I'm also going to print
columns look good.

00:07:50.093 --> 00:07:57.537
[BLANK_AUDIO]

00:07:57.537 --> 00:07:59.964
And then,
I'm going to check the squares.

00:07:59.964 --> 00:08:01.983
[BLANK_AUDIO]

00:08:01.983 --> 00:08:06.581
There are other ways we could have Could
have written what I'm writing here.

00:08:06.581 --> 00:08:08.433
We could have done
this in a single line,

00:08:08.433 --> 00:08:11.870
I could have said if check_rows and
check_columns and check_squares.

00:08:11.870 --> 00:08:14.733
But I like this, because it's going to
slowly let us see rows are good,

00:08:14.733 --> 00:08:15.698
columns, and so on.

00:08:15.698 --> 00:08:21.728
[BLANK_AUDIO]

00:08:21.728 --> 00:08:25.420
Now I can just return true,
because now, we've made it all the way.

00:08:25.420 --> 00:08:26.870
This is a valid sudoku grid.

00:08:26.870 --> 00:08:30.030
We've checked squares, we checked
the columns, we checked the rows.

00:08:30.030 --> 00:08:32.780
But you're probably saying, but
you don't have those functions yet.

00:08:32.780 --> 00:08:34.760
You haven't written check rows,
you haven't written check columns.

00:08:34.760 --> 00:08:39.169
And that's actually true, and
if I try to run this function now,

00:08:39.169 --> 00:08:41.880
print check_sudoku.

00:08:41.880 --> 00:08:44.808
Let's look at the VALID_GRID
from up above.

00:08:44.808 --> 00:08:46.428
Actually, I'm going to
write these in all caps.

00:08:46.428 --> 00:08:49.488
[BLANK_AUDIO]

00:08:49.488 --> 00:08:53.343
It's a good practice, if you just have
variables hanging out there inside

00:08:53.343 --> 00:08:55.496
the function, to write them as all caps.

00:08:55.496 --> 00:09:02.248
[BLANK_AUDIO]

00:09:02.248 --> 00:09:05.010
Okay, so
let's see what's going to happen.

00:09:05.010 --> 00:09:07.010
I'm going to hit on my Mac,
Cmd+B on this.

00:09:07.010 --> 00:09:10.840
I think would be probably Ctrl or
Alt+B on Windows machine.

00:09:10.840 --> 00:09:13.540
&gt;&gt; Right, yeah, you see that little-
&gt;&gt; And then down here is my output.

00:09:13.540 --> 00:09:14.220
&gt;&gt; Yeah.

00:09:14.220 --> 00:09:15.620
&gt;&gt; And how am I going to read this?

00:09:15.620 --> 00:09:17.520
Okay, let's read through
this from the very top.

00:09:17.520 --> 00:09:21.911
Traceback (most recent call last), so
I actually want to go the other way,

00:09:21.911 --> 00:09:23.770
I'm going to start at the bottom.

00:09:23.770 --> 00:09:26.162
I usually start at the bottom of
on these things, so NameError,

00:09:26.162 --> 00:09:27.728
global name check_rows is not defined.

00:09:27.728 --> 00:09:29.118
[BLANK_AUDIO]

00:09:29.118 --> 00:09:32.160
So that means that I called
this function check_sudoku.

00:09:32.160 --> 00:09:35.070
It tried to call this, but
of course, it wasn't defined, and

00:09:35.070 --> 00:09:36.380
I should have known that
was going to happen.

00:09:36.380 --> 00:09:39.470
So, I did know that was going to happen,
but that's the error.

00:09:39.470 --> 00:09:41.980
That's okay, let's define it.

00:09:41.980 --> 00:09:45.400
In this system of gradually
flushing out your solution,

00:09:45.400 --> 00:09:49.187
you start from the biggest picture,
check_sudoku, right?

00:09:49.187 --> 00:09:51.447
Just means I'm going to check
the rows,the columns, and the rows.

00:09:51.447 --> 00:09:54.039
And then, as your code doesn't run,

00:09:54.039 --> 00:09:58.177
you just keep refining it until
it looks like it's working.

00:09:58.177 --> 00:10:02.377
So I'm going to write check_rows of,

00:10:02.377 --> 00:10:07.075
[BLANK_AUDIO]

00:10:07.075 --> 00:10:09.315
I'm just going to actually
[INAUDIBLE] this grid.

00:10:09.315 --> 00:10:13.111
I just want it to be clear which
variables are which you can get

00:10:13.111 --> 00:10:17.370
confusing me if similar words and
the same parameters and all that.

00:10:19.420 --> 00:10:22.920
So this sudoku_grid is a list of lists.

00:10:22.920 --> 00:10:27.840
So I can use a for loop,
to go through the rows of that list.

00:10:27.840 --> 00:10:31.948
So, for row in grid, and
to show you what that actually does,

00:10:31.948 --> 00:10:35.108
let's just print out
each of those rows first.

00:10:35.108 --> 00:10:37.080
[BLANK_AUDIO]

00:10:37.080 --> 00:10:37.700
And,

00:10:37.700 --> 00:10:39.860
[BLANK_AUDIO]

00:10:39.860 --> 00:10:40.850
I'm going to comment this out.

00:10:42.270 --> 00:10:49.649
And let's do check_rows(VALID_GRID).

00:10:49.649 --> 00:10:52.968
[BLANK_AUDIO]

00:10:52.968 --> 00:10:56.607
So you can see, for
row in grid, it prints the row,

00:10:56.607 --> 00:10:59.160
and it prints each one on a new line.

00:10:59.160 --> 00:11:03.230
You don't see those the brackets
at the very beginning and

00:11:03.230 --> 00:11:07.800
the very end because it's just printing
the things inside of that grid

00:11:07.800 --> 00:11:09.370
which are the elements of the rows.

00:11:10.660 --> 00:11:13.190
Okay, so now I know how to get
access to each of those rows.

00:11:13.190 --> 00:11:17.610
Now I'll call each of these numbers
a cell because it seems to make sense,

00:11:17.610 --> 00:11:20.070
we have rows, we have columns and
each of these little squares.

00:11:20.070 --> 00:11:21.313
The value inside we'll call cell.

00:11:21.313 --> 00:11:24.970
So I'm going to do another for

00:11:24.970 --> 00:11:29.030
loop, I'm going to do for cell in row.

00:11:29.030 --> 00:11:31.320
And just to remind you what
this is going to print,

00:11:31.320 --> 00:11:35.020
let's just look at
exactly what this does.

00:11:35.020 --> 00:11:38.950
And this is kind of a mess but
you can see 4 3 5 2 6 9,

00:11:38.950 --> 00:11:42.260
it's just printing out
each individual letter.

00:11:42.260 --> 00:11:48.790
I'm sorry, okay, so,
that's how we iterate through our grid.

00:11:48.790 --> 00:11:49.740
Now what do I actually want to do?

00:11:49.740 --> 00:11:55.342
I'm checking the row, I want to check
and make sure that each row is valid.

00:11:55.342 --> 00:11:55.982
So,

00:11:55.982 --> 00:11:58.402
[BLANK_AUDIO]

00:11:58.402 --> 00:12:04.366
If, let's say, is_valid_row, and again,
I'm making up a function, of row.

00:12:04.366 --> 00:12:07.888
[BLANK_AUDIO]

00:12:07.888 --> 00:12:09.220
So what do I want to do, actually.

00:12:09.220 --> 00:12:10.740
So this is where you have to stop and
think.

00:12:10.740 --> 00:12:15.430
I want to go through all of these rows,
and if one of them is bad,

00:12:15.430 --> 00:12:16.890
then the whole thing is bad.

00:12:16.890 --> 00:12:18.060
And I don't want to return a False.

00:12:18.060 --> 00:12:19.750
So actually,
I want to do if is_valid_row.

00:12:19.750 --> 00:12:21.100
If any of these are not valid,

00:12:21.100 --> 00:12:25.200
it any of them are false,
I'm going to return false.

00:12:25.200 --> 00:12:25.810
This is no good.
And

00:12:27.110 --> 00:12:31.560
only when I've gone through
this whole for loop and

00:12:31.560 --> 00:12:34.280
confirmed that none of them are false,
I haven't returned anything yet.

00:12:34.280 --> 00:12:38.470
Only then, will I make it down here and
be able to actually return true.

00:12:39.600 --> 00:12:41.466
And if I ran check_rows here,

00:12:41.466 --> 00:12:44.578
[BLANK_AUDIO]

00:12:44.578 --> 00:12:47.558
I'm getting the is_valid_row
is not defined, as expected.

00:12:47.558 --> 00:12:49.478
[BLANK_AUDIO]

00:12:49.478 --> 00:12:52.858
So, let's just write that def,
is_valid_row.

00:12:52.858 --> 00:12:56.948
[BLANK_AUDIO]

00:12:56.948 --> 00:12:58.588
And I'm going to make.

00:12:58.588 --> 00:13:00.690
[BLANK_AUDIO]

00:13:00.690 --> 00:13:03.530
I have my desired array here.

00:13:03.530 --> 00:13:04.710
That's not what I wanted, sorry.

00:13:05.730 --> 00:13:08.274
So required_numbers.

00:13:08.274 --> 00:13:11.488
[BLANK_AUDIO]

00:13:11.488 --> 00:13:13.420
These are the numbers that
I need to see in each row.

00:13:13.420 --> 00:13:16.548
I need to see 1,2, 3, 4, 5, 6, 7, 8, 9.

00:13:16.548 --> 00:13:19.737
I could have done that using something
called Python's range function, but

00:13:19.737 --> 00:13:21.466
I'm going to just write it out for
you guys.

00:13:21.466 --> 00:13:22.886
[BLANK_AUDIO]

00:13:22.886 --> 00:13:24.280
And let's see, what do I want to do?

00:13:24.280 --> 00:13:29.600
Let's do for number in required_numbers,

00:13:29.600 --> 00:13:33.750
so that's going to go through all
those numbers, 1, 2, 3, 4, 5.

00:13:33.750 --> 00:13:39.654
If that number is not in the row,

00:13:39.654 --> 00:13:42.288
that's bad.

00:13:42.288 --> 00:13:45.100
That's not a good row, so
it going to return false.

00:13:45.100 --> 00:13:46.730
And only if we've gone through and

00:13:46.730 --> 00:13:50.500
verified that all of those
numbers are can we return true.

00:13:51.770 --> 00:13:52.270
And look!

00:13:52.270 --> 00:13:53.388
Now, we've we've gotten somewhere.

00:13:53.388 --> 00:13:56.390
We haven't written anything that's fake.

00:13:56.390 --> 00:14:01.270
So, in theory, if we check
the rows of something of a grid,

00:14:02.310 --> 00:14:06.000
like VALID_GRID, maybe it'll return
true, if we haven't messed up.

00:14:07.368 --> 00:14:11.420
Let's do print check_rows.

00:14:11.420 --> 00:14:12.368
&gt;&gt; It's true.

00:14:12.368 --> 00:14:13.360
&gt;&gt; Cool.

00:14:13.360 --> 00:14:14.210
&gt;&gt; That worked.

00:14:14.210 --> 00:14:14.780
&gt;&gt; Wow.
&gt;&gt; So

00:14:14.780 --> 00:14:16.670
the VALID_GRID has valid rows, at least.

00:14:16.670 --> 00:14:17.910
We haven't checked its columns.

00:14:17.910 --> 00:14:19.940
Let's actually look at the INVALID_GRID.

00:14:19.940 --> 00:14:20.446
&gt;&gt; Yeah, let's check that.

00:14:20.446 --> 00:14:22.298
[BLANK_AUDIO]

00:14:22.298 --> 00:14:24.330
&gt;&gt; And that's true, too.

00:14:24.330 --> 00:14:25.250
But that's okay.

00:14:25.250 --> 00:14:27.424
That doesn't mean our code is bad
because if you look at the in

00:14:27.424 --> 00:14:30.096
VALID_GRID, I just made a bunch of 1,
2, 3, 4, 5, 6, 7, 8, 9.

00:14:30.096 --> 00:14:32.690
So those rows actually are all good.

00:14:32.690 --> 00:14:35.270
So that's I mean that's why we
have the column check because

00:14:35.270 --> 00:14:36.450
that's not enough for our sudoku.

00:14:37.530 --> 00:14:39.650
Okay cool, so
let's zoom out for a second.

00:14:39.650 --> 00:14:40.380
Let me pull this down.

00:14:42.270 --> 00:14:44.169
There's this thing you
can do in Sublime,

00:14:44.169 --> 00:14:47.246
you click these little triangles and
it just collapses everything.

00:14:47.246 --> 00:14:51.570
So check_rows gets kind of collapsed
down, check_sudoku gets collapsed down.

00:14:51.570 --> 00:14:54.570
I can collapse that,
collapse that, okay.

00:14:56.390 --> 00:14:58.536
So let's go back to check_sudoku.

00:14:58.536 --> 00:15:02.570
So we've gotten check_rows figured out.

00:15:02.570 --> 00:15:04.750
Now we need to do check_columns.

00:15:04.750 --> 00:15:06.567
So let's define that function.

00:15:06.567 --> 00:15:13.718
[BLANK_AUDIO]

00:15:13.718 --> 00:15:18.246
In the meta point, I've collapsed these
functions, I can open them up again by

00:15:18.246 --> 00:15:22.090
clicking the green arrow or
that little arrow next to it.

00:15:22.090 --> 00:15:23.180
I like leaving them collapsed.

00:15:23.180 --> 00:15:25.980
It's just less for
me to have to look at and think about.

00:15:25.980 --> 00:15:27.970
Keep my mind like workspace clean.

00:15:29.400 --> 00:15:30.360
So check_columns, wow!

00:15:30.360 --> 00:15:33.330
How am I going to check_columns?

00:15:33.330 --> 00:15:36.280
Rows were a little easier because
the lists themselves were in rows.

00:15:38.370 --> 00:15:42.046
&gt;&gt; Mm-hm, that's a very,
very good point.

00:15:42.046 --> 00:15:47.100
&gt;&gt; So, this is not, as easy.

00:15:47.100 --> 00:15:49.051
So one thing I could do,

00:15:49.051 --> 00:15:54.622
I could say well I know I want to
check index zero, whatever of a hero.

00:15:54.622 --> 00:15:55.158
&gt;&gt; Yeah.

00:15:55.158 --> 00:15:57.955
&gt;&gt; I want to check index one,
want to check index two.

00:15:57.955 --> 00:15:59.480
&gt;&gt; Thatâ€™s a systematic way of thinking.

00:15:59.480 --> 00:16:05.066
&gt;&gt; Okay, in case so, so
let's see, I'm going to do,

00:16:05.066 --> 00:16:10.120
for index in, and
this is where I'm actually

00:16:10.120 --> 00:16:15.443
going to use this range function,
range(9).

00:16:15.443 --> 00:16:17.440
I'm going to show you
what range(9) prints out.

00:16:17.440 --> 00:16:21.914
[BLANK_AUDIO]

00:16:21.914 --> 00:16:24.236
Sorry, let me do that right up here.

00:16:24.236 --> 00:16:29.494
[BLANK_AUDIO]

00:16:29.494 --> 00:16:32.350
So I just ran that, this code.

00:16:32.350 --> 00:16:35.007
Oops, and, perfect.

00:16:35.007 --> 00:16:35.879
Sorry.

00:16:35.879 --> 00:16:40.813
[CROSSTALK] So IndentationError,
this happens all the time with Python.

00:16:40.813 --> 00:16:46.203
I love Python, other languages use these
curly braces everywhere and brackets and

00:16:46.203 --> 00:16:51.640
parentheses and it's easy to forget
those too, but Python it has a problem.

00:16:51.640 --> 00:16:52.850
It's easy to mess up you notation.

00:16:52.850 --> 00:16:55.706
So let's go to line 61 and
see what the problem is.

00:16:55.706 --> 00:16:57.703
So here's 61.

00:16:57.703 --> 00:17:01.670
I wrote this for loop but
I don't have anything.

00:17:01.670 --> 00:17:06.425
Let me just comment
this whole thing out.

00:17:06.425 --> 00:17:07.550
Let me get rid of this, as well.

00:17:10.980 --> 00:17:15.338
Okay, so now let's try that again.

00:17:15.338 --> 00:17:19.509
Okay, so
range(9) generates a list of all

00:17:19.509 --> 00:17:23.253
the numbers between 0 and just up to 9.

00:17:23.253 --> 00:17:24.872
One less, so up to 8.

00:17:24.872 --> 00:17:25.766
&gt;&gt; Mm-hm.

00:17:25.766 --> 00:17:27.345
[BLANK_AUDIO]

00:17:27.345 --> 00:17:31.711
&gt;&gt; Okay, so let's do our check_columns.

00:17:31.711 --> 00:17:33.313
Where did check_columns go, here

00:17:33.313 --> 00:17:40.022
[BLANK_AUDIO]

00:17:40.022 --> 00:17:46.993
So what I want to do, so
index'll be 0 and then 1 then 2.

00:17:46.993 --> 00:17:52.195
And what I really want
is when index is 0,

00:17:52.195 --> 00:17:57.580
I want to check all of
these down at index 0.

00:17:57.580 --> 00:17:59.180
And I want to check all
the ones at index one.

00:18:01.350 --> 00:18:05.280
Okay, so I could do this with
another pretend function but

00:18:05.280 --> 00:18:06.590
I think I'm just
going to write this one.

00:18:07.600 --> 00:18:08.360
So let's see.

00:18:08.360 --> 00:18:12.827
Up above here,
I'm going to make an empty list,

00:18:12.827 --> 00:18:16.530
we're going to call it columns.

00:18:16.530 --> 00:18:18.250
And each of these,
I'm going to make a new column.

00:18:20.250 --> 00:18:22.595
So I'm going to go over
every row in the grid,

00:18:22.595 --> 00:18:26.154
[BLANK_AUDIO]

00:18:26.154 --> 00:18:29.939
And first I'm going to
make a new empty column.

00:18:29.939 --> 00:18:33.298
[BLANK_AUDIO]

00:18:33.298 --> 00:18:37.118
And for every row in the grid, I'm
going to get whatever the value is at

00:18:37.118 --> 00:18:40.570
that index, so either 0 or
1 or 2 or whatever.

00:18:40.570 --> 00:18:41.819
And I'm going to add
it to my new column.

00:18:41.819 --> 00:18:46.877
[BLANK_AUDIO]

00:18:46.877 --> 00:18:51.680
So, that's going to be row of index.

00:18:51.680 --> 00:18:54.199
Now, the code we have here,
this line of code.

00:18:55.280 --> 00:18:58.700
The only reason I could write this so
quickly and I'm not even sure it's

00:18:58.700 --> 00:19:01.100
going to work but I think it will, but
the only reason I can write this so

00:19:01.100 --> 00:19:05.330
quickly is because I've written lines
similar to this 100 times before.

00:19:05.330 --> 00:19:08.630
I've thought of going
through lists of lists and

00:19:08.630 --> 00:19:12.450
keeping track of an index and
if this looks very foreign or

00:19:12.450 --> 00:19:15.640
how do you ever come up with it
the answer is just practice.

00:19:15.640 --> 00:19:17.820
It's a new language,
Python is a new language for

00:19:17.820 --> 00:19:21.280
you and like anything,
fluency comes with practice.

00:19:21.280 --> 00:19:22.640
But here we go.

00:19:22.640 --> 00:19:26.845
So I'm going to add the right entry,
that's row at index,

00:19:26.845 --> 00:19:31.590
to my new column and actually gone
through every row in the grid.

00:19:32.640 --> 00:19:34.106
I'm going to add my new column.

00:19:34.106 --> 00:19:41.921
[BLANK_AUDIO]

00:19:41.921 --> 00:19:45.727
I'm going to add my new
column to these columns,

00:19:45.727 --> 00:19:48.467
because now what I have is these.

00:19:48.467 --> 00:19:54.162
Let's just print columns so we can show
you what we've done here, if this works.

00:19:54.162 --> 00:19:58.296
So I'm going to take back this invalid
grid, which is 1, 2, 3, 4, 5, 6, 7, 8,

00:19:58.296 --> 00:19:59.690
9, and so on.

00:19:59.690 --> 00:20:03.109
And I'm going to see what happens
when I do check_columns on that.

00:20:03.109 --> 00:20:04.294
[BLANK_AUDIO]

00:20:04.294 --> 00:20:05.943
It's not actually checking the columns.

00:20:05.943 --> 00:20:07.196
It's not complete.

00:20:07.196 --> 00:20:14.441
[BLANK_AUDIO]

00:20:14.441 --> 00:20:15.955
Any guesses on what
it's going to return?

00:20:15.955 --> 00:20:21.057
&gt;&gt; [SOUND] I guess, yeah.

00:20:21.057 --> 00:20:22.567
&gt;&gt; Okay, let me try this one more time.

00:20:22.567 --> 00:20:27.880
Actually let's do for column in, because
it was giving me this whole list.

00:20:27.880 --> 00:20:29.010
&gt;&gt; Yeah.
&gt;&gt; I just want to print out each

00:20:29.010 --> 00:20:30.020
column one time.

00:20:30.020 --> 00:20:31.434
&gt;&gt; Column.

00:20:31.434 --> 00:20:35.057
&gt;&gt; And I'm going to make this return.

00:20:35.057 --> 00:20:36.821
&gt;&gt; There we go.

00:20:36.821 --> 00:20:41.540
You've basically converted
all the columns into.

00:20:41.540 --> 00:20:44.380
&gt;&gt; Wait, let me get rid of this line,
thatâ€™s confusing.

00:20:44.380 --> 00:20:44.980
&gt;&gt; Whereâ€™s that line?

00:20:44.980 --> 00:20:46.570
&gt;&gt; Thatâ€™s the range Iine.

00:20:46.570 --> 00:20:48.783
&gt;&gt; Okay, okay.

00:20:48.783 --> 00:20:52.653
&gt;&gt; So, see what we had, before we had
ones going all the way down this side,

00:20:52.653 --> 00:20:55.400
and now we have ones going
all the way along the top.

00:20:55.400 --> 00:20:58.299
The reason I did this is because
I know how to check rows.

00:20:59.310 --> 00:21:01.110
I've already written the function.

00:21:01.110 --> 00:21:05.015
So now I'm actually not going to return
in the columns, I'm just going to return

00:21:05.015 --> 00:21:10.280
check_rows on those columns
because I know how to do that.

00:21:11.990 --> 00:21:15.389
So let's see what happens when we check

00:21:15.389 --> 00:21:20.541
the Sudoku VALID_GRID at this point and
let me get to this.

00:21:20.541 --> 00:21:25.471
[BLANK_AUDIO]

00:21:25.471 --> 00:21:28.160
Okay, rows look good,
the columns look good.

00:21:28.160 --> 00:21:31.635
So it looks like this check_columns
function and I should let you all know,

00:21:31.635 --> 00:21:33.830
I wrote this code before we did this.

00:21:33.830 --> 00:21:35.550
And there were a lot
of bugs along the way.

00:21:35.550 --> 00:21:38.550
I do not want you to think this
is how the coding process works.

00:21:38.550 --> 00:21:40.050
This took me a long
time to figure it out,

00:21:40.050 --> 00:21:44.300
and I'm just showing you, in a shortened
form, how I thought about it.

00:21:44.300 --> 00:21:46.240
Normally, there'd be a ton of errors.

00:21:46.240 --> 00:21:47.650
There were a ton of errors.

00:21:47.650 --> 00:21:48.780
That's how it actually goes.

00:21:50.060 --> 00:21:50.830
So, okay.

00:21:50.830 --> 00:21:52.740
The rows look good and
the columns look good.

00:21:52.740 --> 00:21:56.718
So let's zoom out again,
I'm a big fan of zooming out.

00:21:56.718 --> 00:22:00.971
[BLANK_AUDIO]

00:22:00.971 --> 00:22:06.320
All right, we've got a function
called check_sudoku.

00:22:06.320 --> 00:22:09.190
It takes its input, the grid,
that looks something like this,

00:22:09.190 --> 00:22:12.040
a list of lists, and it goes through.

00:22:12.040 --> 00:22:13.240
First it checks the rows

00:22:13.240 --> 00:22:15.942
to make sure that they each have
the values one through nine.

00:22:15.942 --> 00:22:16.620
Then it goes through and

00:22:16.620 --> 00:22:20.300
checks the columns to make sure that
each of the values one through nine.

00:22:20.300 --> 00:22:26.250
Then it goes through and, well, soon it
will go through and check the squares.

00:22:26.250 --> 00:22:27.926
We can see in our traceback error,

00:22:27.926 --> 00:22:29.911
[BLANK_AUDIO]

00:22:29.911 --> 00:22:33.689
All the way down here, global name
check_squares is not defined,

00:22:33.689 --> 00:22:35.420
check_squares not defined.

00:22:35.420 --> 00:22:36.809
Right, I hadn't defined it yet.

00:22:36.809 --> 00:22:38.541
[BLANK_AUDIO]

00:22:38.541 --> 00:22:40.110
So, it looks like we know
what we have to do next.

00:22:40.110 --> 00:22:43.189
Let me just put these all next to each
other, so we can see them all on screen.

00:22:43.189 --> 00:22:48.417
[BLANK_AUDIO]

00:22:48.417 --> 00:22:49.530
This is useless.

00:22:49.530 --> 00:22:50.990
I don't know why this
is floating around.

00:22:52.310 --> 00:22:55.260
So, you can see what we mean by
filling out our solution, by the way.

00:22:55.260 --> 00:22:57.350
So, this is us planning
slash filling it out.

00:22:57.350 --> 00:23:00.618
We're writing code hoping that we
have functions later, but we don't.

00:23:00.618 --> 00:23:03.550
So this check_squares function,

00:23:03.550 --> 00:23:07.720
I'm going to tell you in advance,
took me a long time to figure out.

00:23:09.460 --> 00:23:13.908
So if I have a grid and
I'm going to call this a grid that's

00:23:13.908 --> 00:23:19.670
nine by nine.

00:23:19.670 --> 00:23:23.513
And the reason I'm going to do that
to distinguish this sudoku grid from

00:23:23.513 --> 00:23:26.040
the grid of squares which
are three by three.

00:23:28.520 --> 00:23:30.850
So how I'm going to check the squares?

00:23:30.850 --> 00:23:36.617
So, let's see,
let's go back to our what it like.

00:23:36.617 --> 00:23:39.765
There's a few ways we could do this,

00:23:39.765 --> 00:23:45.262
I think what I want to do is I want
to first get this in square form.

00:23:45.262 --> 00:23:47.584
And what is square form
going to look like?

00:23:47.584 --> 00:23:50.881
Well, that's a good question.

00:23:50.881 --> 00:23:54.109
I think I'm going to think of this as,

00:23:54.109 --> 00:23:57.346
[BLANK_AUDIO]

00:23:57.346 --> 00:24:01.679
Here, we're going to have a row of three
squares, so the biggest list is going to

00:24:01.679 --> 00:24:06.099
contain Three rows, with these three,
they each have these three squares.

00:24:06.099 --> 00:24:10.607
This is going to be the first one,
that would be the second one, and

00:24:10.607 --> 00:24:12.620
this would be the third one.

00:24:12.620 --> 00:24:18.076
Then each of those, those three rows
are going to have three squares.

00:24:18.076 --> 00:24:26.205
So, this one's going to have
the square that's on here.

00:24:26.205 --> 00:24:26.734
[INAUDIBLE].

00:24:26.734 --> 00:24:29.814
I don't know how to highlight it that
way, but, it's going to have this,

00:24:29.814 --> 00:24:32.792
this, and this, and then each of
the squares are going to have rows, and

00:24:32.792 --> 00:24:34.630
each of those rows
are going to have entries.

00:24:34.630 --> 00:24:36.830
So, that's going to make a list,
of lists, of lists, of lists.

00:24:37.920 --> 00:24:40.460
If you didn't want to do it that way,
there's other ways to do it.

00:24:40.460 --> 00:24:43.090
This is the way I'm going to do it.

00:24:43.090 --> 00:24:44.090
You can go as deep as you want.

00:24:44.090 --> 00:24:48.746
You can have as many lists
inside of lists as you want, and

00:24:48.746 --> 00:24:51.561
I kind of like this approach, so.

00:24:51.561 --> 00:24:53.047
How are we going to to do it?

00:24:53.047 --> 00:24:58.643
Okay so, we said that this full grid
is made of rows of three squares.

00:24:58.643 --> 00:25:04.279
So, for row_of_3_squares, remember,

00:25:04.279 --> 00:25:09.649
each of the squares is three by three.

00:25:09.649 --> 00:25:10.950
Sorry.

00:25:10.950 --> 00:25:13.202
The grid is just a thing, man.

00:25:13.202 --> 00:25:15.037
I have to make squares first?

00:25:15.037 --> 00:25:25.037
[BLANK_AUDIO]

00:25:26.600 --> 00:25:29.618
So, I'm going to just try and convert
this grid, this nine by nine grid.

00:25:29.618 --> 00:25:33.403
[BLANK_AUDIO]

00:25:33.403 --> 00:25:36.143
Into a row of squares.

00:25:36.143 --> 00:25:36.956
Then,

00:25:36.956 --> 00:25:40.253
[BLANK_AUDIO]

00:25:40.253 --> 00:25:42.831
For row, for each of those, row,

00:25:42.831 --> 00:25:51.863
[BLANK_AUDIO]

00:25:51.863 --> 00:25:53.465
I'm going to have three
squares in each of those rows.

00:25:53.465 --> 00:25:56.508
So, I'm going to iterate over
those squares, for square.

00:25:56.508 --> 00:26:02.358
[BLANK_AUDIO]

00:26:02.358 --> 00:26:02.875
And now,

00:26:02.875 --> 00:26:07.740
I'm going to check that square, so that
square should be a three by three grid.

00:26:07.740 --> 00:26:10.190
Basically, it should
look similar to this.

00:26:10.190 --> 00:26:11.585
Let me just give you one example.

00:26:11.585 --> 00:26:13.605
[BLANK_AUDIO]

00:26:13.605 --> 00:26:21.361
EXAMPLE_SQUARE would be
something like 1, 2, 3.

00:26:21.361 --> 00:26:27.932
[BLANK_AUDIO]

00:26:27.932 --> 00:26:33.250
[4,5,6], [7,8,9].

00:26:33.250 --> 00:26:37.585
And that would, as just a square
that would be [INAUDIBLE], so

00:26:37.585 --> 00:26:39.798
[INAUDIBLE] squares look like.

00:26:39.798 --> 00:26:43.458
So, I now I'm going to do that thing
where I pretend I have a function, so

00:26:43.458 --> 00:26:45.208
I'm going to do if check_ square.

00:26:45.208 --> 00:26:47.484
Notice, that's just a single square.

00:26:47.484 --> 00:26:51.941
There's no s on the end here,
so it's a different function.

00:26:51.941 --> 00:26:54.090
And I'm just going refer to this square,
it's the same one.

00:26:55.420 --> 00:27:00.060
So if that's false, doesn't matter,
when one square's bad,

00:27:00.060 --> 00:27:01.680
the whole puzzle's bad.

00:27:01.680 --> 00:27:03.380
I can return false.

00:27:05.400 --> 00:27:10.909
And if I've gotten through
every square in every row,

00:27:10.909 --> 00:27:13.798
only then can I return true.

00:27:13.798 --> 00:27:19.016
[SOUND], okay, this is a lot, and
I'm not going to keep going with this,

00:27:19.016 --> 00:27:22.830
because I know this is hard
to follow at this point.

00:27:22.830 --> 00:27:25.584
The reason I'm able to do this
quickly is because, like I said,

00:27:25.584 --> 00:27:27.172
I kind of thought about this already.

00:27:27.172 --> 00:27:30.121
But let me show you what my
solution code looked like.

00:27:30.121 --> 00:27:35.879
[BLANK_AUDIO]

00:27:35.879 --> 00:27:39.001
Okay, that looks similar.

00:27:39.001 --> 00:27:41.410
Check rows.

00:27:41.410 --> 00:27:42.380
So this is actually,

00:27:42.380 --> 00:27:46.515
I had to change my solution because
I'm not really a fan of Sudoku.

00:27:46.515 --> 00:27:50.723
So actually earlier, I thought that
the only requirement was that the sum,

00:27:50.723 --> 00:27:52.750
the total of each row, had to be-
&gt;&gt; A certain number.

00:27:52.750 --> 00:27:53.609
&gt;&gt; 1 plus 2 plus 3 plus 4.

00:27:53.609 --> 00:27:55.838
That's not correct,
it actually needs one of each.

00:27:55.838 --> 00:27:56.720
&gt;&gt; At least one of each, yeah.

00:27:56.720 --> 00:27:58.090
&gt;&gt; So,
I had to modify this a little bit.

00:27:58.090 --> 00:27:59.182
&gt;&gt; Yeah.

00:27:59.182 --> 00:28:03.165
&gt;&gt; But, let's go with this,
it doesn't change the idea too much.

00:28:03.165 --> 00:28:07.330
Check columns, looks a little different.

00:28:07.330 --> 00:28:09.940
You can see I've got
these print statements.

00:28:09.940 --> 00:28:13.579
Those are there because
I had to debug this.

00:28:13.579 --> 00:28:16.654
I didn't put them in while I
was solving it from memory,

00:28:16.654 --> 00:28:18.300
because I didn't need them.

00:28:18.300 --> 00:28:19.420
I remembered what the solution was, and

00:28:19.420 --> 00:28:21.870
I had just gone through all
these problems an hour ago.

00:28:21.870 --> 00:28:25.810
But these were here to show me where
in the code things are failing.

00:28:25.810 --> 00:28:28.955
It wasn't working, and I didn't
know why, and I needed those there.

00:28:28.955 --> 00:28:31.560
So, my check_squares function.

00:28:31.560 --> 00:28:34.758
Okay, so, I call it get_squares
instead of make_squares, but

00:28:34.758 --> 00:28:35.915
similar sort of thing.

00:28:35.915 --> 00:28:38.263
The check_square function,

00:28:38.263 --> 00:28:40.213
[BLANK_AUDIO]

00:28:40.213 --> 00:28:42.907
It goes through each row
in a three by three.

00:28:42.907 --> 00:28:46.784
[BLANK_AUDIO]

00:28:46.784 --> 00:28:50.465
Again, remember, this is me thinking you
just had to add up to some desired sum,

00:28:50.465 --> 00:28:52.426
so this would require some modification.

00:28:52.426 --> 00:28:53.541
&gt;&gt; Right.

00:28:53.541 --> 00:28:54.850
&gt;&gt; Else return False.

00:28:56.660 --> 00:29:00.710
&gt;&gt; For those of you who are a little bit
confusing, we'll be sure to post this.

00:29:00.710 --> 00:29:01.733
&gt;&gt; Yeah,
we're going to definitely post this.

00:29:01.733 --> 00:29:04.263
&gt;&gt; We'll post this code
along with comments and

00:29:04.263 --> 00:29:08.659
the way that we're thinking, so don't
worry if you're trying to feverishly

00:29:08.659 --> 00:29:10.470
understand every line of code.

00:29:10.470 --> 00:29:11.150
&gt;&gt; Yeah, yeah.

00:29:11.150 --> 00:29:15.805
&gt;&gt; Just make sure that you
understand the bigger concept of,

00:29:15.805 --> 00:29:19.081
here we are, we are like-
&gt;&gt; This is the bigger concept, right?

00:29:19.081 --> 00:29:19.893
&gt;&gt; This is the bigger concept, yeah.

00:29:19.893 --> 00:29:21.751
&gt;&gt; The steps for solving a problem.

00:29:21.751 --> 00:29:25.831
&gt;&gt; Basically, that's the main thing
that we want you to get away from this

00:29:25.831 --> 00:29:27.185
exercise-
&gt;&gt; Yeah.

00:29:27.185 --> 00:29:27.997
&gt;&gt; Really.

00:29:27.997 --> 00:29:32.687
So Andy, do you want to have anything
else to show for this type of code?

00:29:32.687 --> 00:29:37.008
&gt;&gt; I think maybe I'm going to stop
sharing my screen so I can look,

00:29:37.008 --> 00:29:37.866
actually.

00:29:37.866 --> 00:29:40.010
&gt;&gt; Okay, we are broadcasting
live on this cam right now.

00:29:40.010 --> 00:29:44.970
Okay, great.
Yeah, so, we will for sure post

00:29:44.970 --> 00:29:49.280
this code, so you could follow along and
follow along the thinking process.

00:29:49.280 --> 00:29:51.240
That's the most important thing, and

00:29:51.240 --> 00:29:55.810
the main thing is really, specifically
we break things down, right?

00:29:55.810 --> 00:29:56.671
&gt;&gt; Yeah.

00:29:56.671 --> 00:29:59.190
We have a little more time.

00:29:59.190 --> 00:30:04.700
Can I quickly show you
how I would apply this.

00:30:04.700 --> 00:30:06.490
&gt;&gt; Yeah, you need to do screenshare.

00:30:06.490 --> 00:30:08.730
&gt;&gt; Yeah.
&gt;&gt; Hold it, yeah, you switched already.

00:30:08.730 --> 00:30:09.641
&gt;&gt; Okay.
&gt;&gt; We're good.

00:30:09.641 --> 00:30:10.594
Okay, we're good.

00:30:10.594 --> 00:30:11.661
&gt;&gt; Okay.

00:30:11.661 --> 00:30:14.110
So, if you've gotten through stage two,
to work session five.

00:30:14.110 --> 00:30:17.131
Let's just do this from scratch.

00:30:17.131 --> 00:30:21.993
This applies so
well to this last problem,

00:30:21.993 --> 00:30:25.513
where, what was the problem?

00:30:25.513 --> 00:30:29.228
&gt;&gt; Generate concept, HTML?

00:30:29.228 --> 00:30:31.086
&gt;&gt; I already set this.

00:30:31.086 --> 00:30:37.425
Okay, so this is where I wanted to,
I'm just going to get rid of all this.

00:30:37.425 --> 00:30:41.050
I want to write a function called
make_HTML from any concepts.

00:30:41.050 --> 00:30:45.827
because what I wanted to do was I wanted
to stop having Copy and Paste my divs.

00:30:45.827 --> 00:30:50.282
I want to be able to
specify the concepts I want

00:30:50.282 --> 00:30:53.830
in my my notes in one place.

00:30:53.830 --> 00:30:57.397
And just modify that instead
of having to keep modifying my

00:30:57.397 --> 00:31:02.140
actual HTML file by Copy and
Pasting which is error prone.

00:31:02.140 --> 00:31:06.691
So for example, let's say,
I had Python, so

00:31:06.691 --> 00:31:12.648
I'm just going to keep these very
minimal for illustration and

00:31:12.648 --> 00:31:17.224
then maybe it had another
entry that was HTML.

00:31:18.430 --> 00:31:25.189
I'll do, Stands for
HyperText Markup Language.

00:31:25.189 --> 00:31:30.240
Okay so
this is my choice of data structure.

00:31:30.240 --> 00:31:33.670
It's called for
how I want to represent concepts.

00:31:33.670 --> 00:31:37.434
Each concept is a list,
each list has a title.

00:31:37.434 --> 00:31:39.340
[INAUDIBLE] sorry, sorry.

00:31:39.340 --> 00:31:40.630
No.

00:31:40.630 --> 00:31:43.520
Has a title and a description,
title, description.

00:31:44.780 --> 00:31:49.945
And so, applying the same thought
process to solving this problem.

00:31:49.945 --> 00:31:56.048
I would say all right, let's do, Jeff,
what was it called, make_HTML_for_me.

00:31:56.048 --> 00:31:59.890
[BLANK_AUDIO]

00:31:59.890 --> 00:32:07.030
Many_concepts and
it's going to take Concept_list.

00:32:07.030 --> 00:32:10.746
I'm just calling it something
different to distinguish it from this

00:32:10.746 --> 00:32:14.920
even though I'm eventually going to
call this function with this argument.

00:32:16.000 --> 00:32:17.170
This can be tricky.

00:32:17.170 --> 00:32:18.750
There's a lot of stuff
floating around but

00:32:18.750 --> 00:32:22.140
I'm going to just call it concept_list.

00:32:22.140 --> 00:32:24.110
Okay, so what do I want to do?

00:32:24.110 --> 00:32:29.160
So, first, I want to iterate over this
big list that's in green right now.

00:32:29.160 --> 00:32:33.939
So, I'm going to do for
concept in concept_list.

00:32:33.939 --> 00:32:36.243
[BLANK_AUDIO]

00:32:36.243 --> 00:32:38.693
Hm, no, I'm making HTML, and
I want that as a string, so

00:32:38.693 --> 00:32:41.760
I should have to remember, I'm going to
first start with an empty string.

00:32:41.760 --> 00:32:43.350
And I'm going to just
keep adding to that.

00:32:44.830 --> 00:32:45.816
So let's what do we going to add?

00:32:45.816 --> 00:32:51.170
I'm going to add HTML is going to
equal whatever the previous HTML was,

00:32:51.170 --> 00:32:52.600
which right now is this.

00:32:52.600 --> 00:32:55.300
But remember it's not always going to be
this as we look through we're going to

00:32:55.300 --> 00:32:57.560
be making this bigger and
bigger so make.

00:33:00.460 --> 00:33:04.890
I'm going to call this function
make_html_for_concept,

00:33:04.890 --> 00:33:07.926
I forgot what it was actually called,
and

00:33:07.926 --> 00:33:12.200
that's going to take a single
concept as far as an argument.

00:33:12.200 --> 00:33:14.458
And remember,
single concept is a list like that.

00:33:14.458 --> 00:33:16.245
[BLANK_AUDIO]

00:33:16.245 --> 00:33:18.760
And then I'm going to return HTML.

00:33:18.760 --> 00:33:20.970
So, that looks pretty simple, right?

00:33:20.970 --> 00:33:22.900
This code is nice and readable.

00:33:22.900 --> 00:33:27.140
I know I have to go and find or
create make_html_for_concept, but

00:33:27.140 --> 00:33:27.800
I can go through.

00:33:27.800 --> 00:33:29.420
I can read through this.

00:33:29.420 --> 00:33:33.450
And sort of get what's going on and
somebody else could too.

00:33:33.450 --> 00:33:36.590
In fact someone else is you in a week
because it can often be hard to

00:33:36.590 --> 00:33:38.330
read your code a week later.

00:33:38.330 --> 00:33:41.816
Now I need to make this function.

00:33:41.816 --> 00:33:44.218
[BLANK_AUDIO]

00:33:44.218 --> 00:33:47.535
I just wanted to do a little commentary,
as Andy's coding.

00:33:47.535 --> 00:33:49.905
See, Andy's actually
breaking things down, and

00:33:49.905 --> 00:33:53.585
he's actually doing this
exercise called pseudocode, and

00:33:53.585 --> 00:33:58.025
he's actually thinking and
writing down as he types.

00:33:58.025 --> 00:34:02.215
And he's actually breaking things down
and actually creating these functions

00:34:04.125 --> 00:34:09.429
and naming them in a way that makes
sense in the regular English language.

00:34:10.969 --> 00:34:14.060
&gt;&gt; Thanks for doing that because I
have a lot of just boilerplate code to

00:34:14.060 --> 00:34:14.639
write itself.

00:34:14.639 --> 00:34:16.260
&gt;&gt; Yes, if you can keep riffing it.

00:34:16.260 --> 00:34:21.409
&gt;&gt; Yeah, exactly, so basically, really
it's a really good way for you to start

00:34:21.409 --> 00:34:26.260
thinking okay, how can I transfer
what's in my head to what's on paper?

00:34:26.260 --> 00:34:29.179
And then what's on paper to something

00:34:29.179 --> 00:34:34.310
that the computer program could
actually go and understand.

00:34:34.310 --> 00:34:37.340
So, the first step is to think about,
again, like understand the bigger issue,

00:34:37.340 --> 00:34:38.320
like what is the question?

00:34:38.320 --> 00:34:41.170
What is it that we're trying to do?

00:34:41.170 --> 00:34:42.530
What are the inputs that we're getting,

00:34:42.530 --> 00:34:45.190
and what are our outputs
that we're supposed to make?

00:34:45.190 --> 00:34:47.889
Really, if you think of it,

00:34:47.889 --> 00:34:51.370
it's just really that you
are basically the machine, right?

00:34:51.370 --> 00:34:57.070
You programmed the machine to take some
sort of input, some sort of raw input,

00:34:57.070 --> 00:35:00.150
it does its magic, and then it outputs

00:35:01.420 --> 00:35:05.400
the thing that you want, the string or
some sort of result that you want.

00:35:05.400 --> 00:35:08.910
So it's good to really just sit down and
think back and zoom out,

00:35:08.910 --> 00:35:10.550
what Andy often does.

00:35:10.550 --> 00:35:15.400
And really think about, okay,
what are the ins, inputs,

00:35:15.400 --> 00:35:19.530
what are the outputs, and what
are the required transformations that I

00:35:19.530 --> 00:35:23.040
need to be able to transform
this raw input into this output.

00:35:24.300 --> 00:35:26.320
Thank you yes great If you look, okay.

00:35:26.320 --> 00:35:29.629
So I think we can go
over this code of a bit.

00:35:29.629 --> 00:35:34.290
So here I define with HTML is for
a given concept and so

00:35:34.290 --> 00:35:39.380
first I have this div that captures
everything and has a class of concept

00:35:39.380 --> 00:35:43.010
inside of that there is div of
the class of concept-title.

00:35:43.010 --> 00:35:43.840
And here, ooh.

00:35:43.840 --> 00:35:44.870
Actually, I don't like this.

00:35:44.870 --> 00:35:46.250
I don't like this concept of zero.

00:35:46.250 --> 00:35:47.800
All I know os that if I come
back to this in a week,

00:35:47.800 --> 00:35:49.320
I'm going to forget
where that comes from,

00:35:49.320 --> 00:35:53.490
so let me just title equals concept.

00:35:53.490 --> 00:35:56.600
Concept of zero.

00:35:56.600 --> 00:35:58.510
There we go.
What Andy's doing is actually a very

00:35:58.510 --> 00:36:04.570
important best practices, that we need
define these helper variables that,

00:36:04.570 --> 00:36:06.540
instead of just accessing this array.

00:36:07.970 --> 00:36:14.230
Directly, we actually give it
another name, basically, like title,

00:36:14.230 --> 00:36:17.710
description, so we know exactly
conceptually what we're trying to do.

00:36:17.710 --> 00:36:19.510
&gt;&gt; Yes, so that the previous
code would have worked.

00:36:19.510 --> 00:36:21.940
&gt;&gt; Yeah.
&gt;&gt; But working isn't always enough.

00:36:21.940 --> 00:36:24.070
I mean, it's enough for
the computer, but

00:36:24.070 --> 00:36:26.880
there's two people involved in making
the code and you are one of them.

00:36:26.880 --> 00:36:29.090
And you're going to want to
do this again in a week, and

00:36:29.090 --> 00:36:31.230
it's going to be much,
you're going to love yourself.

00:36:31.230 --> 00:36:35.460
If you just were nice enough to
give things very descriptive names.

00:36:35.460 --> 00:36:39.940
&gt;&gt; Yeah, I love the fact that Andy's
saying program for your future self.

00:36:39.940 --> 00:36:41.720
I often tell my students that.

00:36:41.720 --> 00:36:43.680
Listen, you need to program for
your future self and

00:36:43.680 --> 00:36:46.335
make your future self love you,
like in the present.

00:36:46.335 --> 00:36:49.280
[LAUGH]
&gt;&gt; So, now, in theory,

00:36:49.280 --> 00:36:55.070
if I called this function on list
with list of concepts as an input.

00:36:55.070 --> 00:36:56.970
It should return some HTML.

00:36:56.970 --> 00:37:03.750
So let's do that
make_HTML_for_many_concepts.

00:37:03.750 --> 00:37:08.390
And, what was that, (list_of_concepts),
&gt;&gt; It was called process, and

00:37:08.390 --> 00:37:11.450
we need to print this out, right,
because this was being disputed.

00:37:11.450 --> 00:37:12.350
&gt;&gt; Yes.
Let's just actually,

00:37:12.350 --> 00:37:13.990
let's just show what happens
if you don't you don't.

00:37:13.990 --> 00:37:15.501
This is one of the most fresh,

00:37:15.501 --> 00:37:18.707
there's another [CROSSTALK]
&gt;&gt; [CROSSTALK] global single_concepts

00:37:18.707 --> 00:37:19.660
and
&gt;&gt; Where was single.

00:37:22.080 --> 00:37:22.730
Okay.

00:37:22.730 --> 00:37:26.480
I called this single_concept, but I was
calling it in the for loop just concept.

00:37:26.480 --> 00:37:27.690
&gt;&gt; Yeah.
It's just concept.

00:37:27.690 --> 00:37:30.020
&gt;&gt; So I'm going to just call it concept.

00:37:31.850 --> 00:37:32.350
Okay.

00:37:33.590 --> 00:37:34.900
Your code didn't display any output.

00:37:34.900 --> 00:37:35.750
&gt;&gt; Yeah.
There's nothing.

00:37:35.750 --> 00:37:38.075
&gt;&gt; You don't know how many times I've
looked at that output message, for

00:37:38.075 --> 00:37:40.450
hours, before I realized that this
function was returning something.

00:37:45.130 --> 00:37:47.250
&gt;&gt; But
return isn't quite the same as print.

00:37:47.250 --> 00:37:47.970
I need to print.

00:37:47.970 --> 00:37:48.470
&gt;&gt; Yeah, print.

00:37:50.840 --> 00:37:51.790
&gt;&gt; And sure enough, when I do that.

00:37:53.090 --> 00:37:54.450
&gt;&gt; Nice.
&gt;&gt; It looks pretty nice.

00:37:54.450 --> 00:37:57.740
&gt;&gt; Look at that,
auto-generated HTML code.

00:37:57.740 --> 00:38:02.850
&gt;&gt; And now, I mean in theory, I could
just keep track of all my notes up here.

00:38:02.850 --> 00:38:06.330
And as I add new notes, so
let's say I learned something new about,

00:38:06.330 --> 00:38:08.930
like, I don't know,
let's say I learned about,

00:38:08.930 --> 00:38:11.320
tomorrow I'm going to learn about
object oriented programming.

00:38:14.860 --> 00:38:16.190
Object oriented,

00:38:16.190 --> 00:38:20.470
this is what you learn in Course Three,
programming is the best.

00:38:23.900 --> 00:38:28.090
And should go, now,
said having a copy and paste.

00:38:29.250 --> 00:38:29.750
Boom.

00:38:29.750 --> 00:38:30.860
&gt;&gt; There you go, yeah.

00:38:30.860 --> 00:38:34.560
&gt;&gt; Iâ€™ve got a nice HTML
notoriety properly for.

00:38:34.560 --> 00:38:35.170
&gt;&gt; Awesome.

00:38:35.170 --> 00:38:37.180
&gt;&gt; Thatâ€™s the value of
avoiding repetition.

00:38:37.180 --> 00:38:38.970
&gt;&gt; Also, weâ€™re screening back for
the video camera.

00:38:38.970 --> 00:38:42.740
Hopeful everyone saw some
really good Frameworks,

00:38:42.740 --> 00:38:47.560
some true programming way of thinking.

00:38:47.560 --> 00:38:49.020
We have a couple of questions.

00:38:49.020 --> 00:38:51.350
&gt;&gt; Yeah, yes.
&gt;&gt; We got a couple of minutes like

00:38:51.350 --> 00:38:53.270
[INAUDIBLE].

00:38:53.270 --> 00:38:54.412
So the first one.

00:38:54.412 --> 00:38:57.840
[LAUGH] That was the most
highly uploaded.

00:38:57.840 --> 00:38:59.440
Iâ€™m late coming to office hours.

00:38:59.440 --> 00:39:02.130
Can you tell me where can I get
the recording for this once and

00:39:02.130 --> 00:39:02.990
also the once in the past?

00:39:02.990 --> 00:39:07.840
So basically after this office
hours has been, is finished,

00:39:07.840 --> 00:39:10.050
Google will actually
automatically record this video.

00:39:10.050 --> 00:39:13.780
So what you need to do is just,
after we end this session,

00:39:13.780 --> 00:39:16.240
go back to the same page.

00:39:16.240 --> 00:39:18.140
Refresh your page And

00:39:18.140 --> 00:39:22.460
then you can actually start from
start playing at the beginning.

00:39:22.460 --> 00:39:26.340
So all office hour sessions
will be on the Google Events

00:39:26.340 --> 00:39:28.930
site as well as in the discussion forum.

00:39:28.930 --> 00:39:33.221
So after every office hours,
we go into the discussion forums and

00:39:33.221 --> 00:39:38.138
actually post a link to the specific
office hour sessions as well as links to

00:39:38.138 --> 00:39:39.712
the code that Andy wrote

00:39:39.712 --> 00:39:43.647
[BLANK_AUDIO]

00:39:43.647 --> 00:39:47.920
So this one is, yeah, Joshua.

00:39:47.920 --> 00:39:49.680
Another question is,
please post this code and

00:39:49.680 --> 00:39:51.410
the rationale of your Python thinking.

00:39:51.410 --> 00:39:53.300
Please tell us where it is posted.

00:39:53.300 --> 00:39:57.677
So once again, we will post these on
the discussion forum, the code itself.

00:39:57.677 --> 00:40:00.778
So watch out for
that either tonight or tomorrow.

00:40:00.778 --> 00:40:06.327
And you could actually go ahead and
Go through the code and

00:40:06.327 --> 00:40:12.115
actually try to code it line by line,
the way that Andy did.

00:40:12.115 --> 00:40:17.994
So you can actually really
think the way that Andy did.

00:40:17.994 --> 00:40:19.800
So now you'd have a-
&gt;&gt; I mean,

00:40:19.800 --> 00:40:21.445
that style of thinking
takes practice too.

00:40:21.445 --> 00:40:22.525
&gt;&gt; Yeah.
&gt;&gt; I remember,

00:40:22.525 --> 00:40:25.835
I first saw this in a Udacity class
called Design of Computer Programs with

00:40:25.835 --> 00:40:27.455
an expert programmer named Peter Norvig.

00:40:27.455 --> 00:40:29.515
And it blew my mind that he
was thinking this way, but

00:40:29.515 --> 00:40:31.275
I loved the way of thinking.

00:40:31.275 --> 00:40:34.690
And I loved it enough to
stick with trying it out.

00:40:34.690 --> 00:40:37.480
But I really,
it was hard at first to write code for

00:40:37.480 --> 00:40:38.880
functions that didn't exist.

00:40:38.880 --> 00:40:40.640
But with practice you'll get it.

00:40:40.640 --> 00:40:44.370
&gt;&gt; Yeah, so it's a great way to
just think ahead and structure.

00:40:44.370 --> 00:40:47.550
&gt;&gt; And avoid details, make sure that
your big picture solution makes sense

00:40:47.550 --> 00:40:52.600
before you spend all this time and
energy writing the detailed solutions.

00:40:52.600 --> 00:40:53.100
&gt;&gt; Okay, great.

00:40:54.840 --> 00:40:56.670
Let's like this question.

00:40:57.670 --> 00:41:00.300
Is it true I can use Sublime
2 to write Python code?

00:41:00.300 --> 00:41:02.690
Sorry if you've already explained it.

00:41:02.690 --> 00:41:03.990
&gt;&gt; Yes, it's absolutely true.

00:41:03.990 --> 00:41:04.590
Can I share that screen?

00:41:04.590 --> 00:41:07.800
&gt;&gt; Yes, go ahead,
you are screen sharing.

00:41:07.800 --> 00:41:11.600
&gt;&gt; All right, so
let's do a new file with Sublime Text.

00:41:11.600 --> 00:41:12.950
So I did file, new file.

00:41:14.060 --> 00:41:16.778
So right now,
I'm going to float over here.

00:41:16.778 --> 00:41:19.740
If you look up on this tab
you just see untitled.

00:41:19.740 --> 00:41:21.970
So the first thing you need to do, so

00:41:21.970 --> 00:41:25.092
that I can actually code in Python,
is save this file as.

00:41:25.092 --> 00:41:30.380
I'm going to save in my
desktop as example code.

00:41:30.380 --> 00:41:33.850
But that name doesn't matter, what
matters is what's called the extension.

00:41:33.850 --> 00:41:36.573
So I saved as example code.py.

00:41:36.573 --> 00:41:39.740
And that tells any program
that knows about Python,

00:41:39.740 --> 00:41:42.740
hey this is a Python file,
treat it like a Python file.

00:41:42.740 --> 00:41:46.190
And then when I write something
like def it becomes blue.

00:41:47.462 --> 00:41:50.400
Def my_function, and
now my function is green.

00:41:50.400 --> 00:41:55.670
And the arguments are going to be hm,
orange, I guess.

00:41:55.670 --> 00:41:57.670
This is really nice,
this syntax highlighting.

00:41:57.670 --> 00:42:05.490
And it's something that you get, because
Sublime understands that this is Python.

00:42:05.490 --> 00:42:12.720
If you want to run this code, you can go
to project, or sorry, what is it, tools.

00:42:12.720 --> 00:42:18.109
It's actually build and
I didn't [INAUDIBLE] function.

00:42:18.109 --> 00:42:19.535
[CROSSTALK]
&gt;&gt; Return.

00:42:19.535 --> 00:42:20.341
&gt;&gt; I didn't actually call it.

00:42:20.341 --> 00:42:22.631
&gt;&gt; Yeah, yeah.

00:42:22.631 --> 00:42:25.420
&gt;&gt; This function doesnâ€™t do
anything with its inputs.

00:42:25.420 --> 00:42:29.540
It's a pretty terrible function,
but thatâ€™s okay.

00:42:29.540 --> 00:42:30.992
And sure enough thereâ€™s Hello.

00:42:30.992 --> 00:42:33.140
It shows up in the bottom.

00:42:33.140 --> 00:42:35.940
Yes.
&gt;&gt; So you can totally do that and

00:42:35.940 --> 00:42:37.700
that's a good way to code.

00:42:37.700 --> 00:42:41.270
If you're struggling with using,
this is a better

00:42:41.270 --> 00:42:46.175
place to code than in the Udacity
window that I showed you earlier.

00:42:46.175 --> 00:42:49.065
But the Udacity window is good for
short little functions.

00:42:49.065 --> 00:42:52.145
But this is nicer because the syntax
highlighting is a little better, and

00:42:52.145 --> 00:42:54.115
a few other reasons.

00:42:54.115 --> 00:42:55.775
&gt;&gt; Great, thanks for
the question, Joshua.

00:42:56.865 --> 00:43:00.145
Roberta had more of a comment,
and this is a very valid comment.

00:43:00.145 --> 00:43:03.245
I've been watching from the beginning,
but I'm afraid I'm lost.

00:43:03.245 --> 00:43:05.885
This is getting way more complex
than the Sublime 2 concept.

00:43:05.885 --> 00:43:07.075
Fun to watch, though.

00:43:07.075 --> 00:43:09.490
&gt;&gt; Well, I'm glad it's fun to watch,
at least.

00:43:09.490 --> 00:43:13.360
Honestly, I should have put more thought
into the choice of example, I think.

00:43:13.360 --> 00:43:15.940
The Sudoku one got pretty complicated,
pretty quick.

00:43:15.940 --> 00:43:17.960
I think if you're going to
take away anything from this,

00:43:19.400 --> 00:43:21.030
there's writing this function.

00:43:21.030 --> 00:43:22.320
&gt;&gt; So you're screen sharing again, Andy?

00:43:22.320 --> 00:43:25.227
&gt;&gt; Yeah.
[BLANK_AUDIO]

00:43:25.227 --> 00:43:28.301
It was that I wrote this function.

00:43:28.301 --> 00:43:32.110
Check Sudoku before I
wrote these functions.

00:43:32.110 --> 00:43:34.824
I said, I don't know what check
rows is going to look like.

00:43:34.824 --> 00:43:37.042
I don't know how I'm going
to write check columns.

00:43:37.042 --> 00:43:39.160
And I don't know how I'm going
to write checks squares.

00:43:39.160 --> 00:43:42.140
But I know that if it
passes all these tests.

00:43:42.140 --> 00:43:45.500
If my Sudoku grid passes check rows,
and it passes check columns, and

00:43:45.500 --> 00:43:48.430
it passes check squares,
I want to return true.

00:43:48.430 --> 00:43:50.185
&gt;&gt; And
that's basically the whole program.

00:43:50.185 --> 00:43:52.970
&gt;&gt; Mm-hm, and
I should have said otherwise.

00:43:52.970 --> 00:43:59.200
But that to me was
the big takeaway here.

00:43:59.200 --> 00:44:03.190
Now when you have a really big problem,
try and

00:44:03.190 --> 00:44:05.840
chop it up into the biggest
pieces you can at first.

00:44:05.840 --> 00:44:09.210
Then for each of those pieces,
chop them up as big as you can.

00:44:09.210 --> 00:44:12.100
And keep doing that and eventually
you'll get down to something where you

00:44:12.100 --> 00:44:13.515
don't need to chop it up any more.

00:44:13.515 --> 00:44:16.740
Where you just sort of
write a single function or

00:44:16.740 --> 00:44:18.722
flush out a single function and
you're good to go.

00:44:18.722 --> 00:44:25.640
So Roberta, we're going to be posting
this code and once you're free.

00:44:25.640 --> 00:44:30.870
Feel free to go through this code and
if you have any questions on

00:44:30.870 --> 00:44:33.300
this particular code,
post it up on the discussion forum and

00:44:33.300 --> 00:44:37.750
we'll be more than happy to help
you walk through the code as well.

00:44:37.750 --> 00:44:43.540
Okay, the last question of
today will be from Matt.

00:44:43.540 --> 00:44:45.350
Are you familiar with BBEdit?

00:44:45.350 --> 00:44:48.400
&gt;&gt; I'm not, so Matt, your question
is Sublime Text versus BBEdit.

00:44:48.400 --> 00:44:51.510
I assume BBEdit is a text editor.

00:44:51.510 --> 00:44:52.970
I honestly don't know.

00:44:52.970 --> 00:44:56.480
Assuming it supports Python and
it's got the features you need,

00:44:56.480 --> 00:44:58.710
you should use whatever
text editor you like.

00:44:58.710 --> 00:45:00.730
I really like Sublime.

00:45:00.730 --> 00:45:03.850
It's what I started using when I learned
to code and so it's just easy for

00:45:03.850 --> 00:45:05.310
me to continue using that.

00:45:05.310 --> 00:45:08.060
But, yeah, use whatever tools you want.

00:45:08.060 --> 00:45:10.920
&gt;&gt; Yeah, so I'll just preface that.

00:45:10.920 --> 00:45:12.000
Sublime is very good.

00:45:12.000 --> 00:45:13.830
A lot of people in the office use it.

00:45:13.830 --> 00:45:18.230
Other people also use other
text editors, like Notepad++.

00:45:18.230 --> 00:45:20.290
That's actually a decent one.

00:45:20.290 --> 00:45:23.560
Another one would be, I think.

00:45:23.560 --> 00:45:24.160
&gt;&gt; Eclipse.

00:45:24.160 --> 00:45:25.500
&gt;&gt; Eclipse is more heavy duty.

00:45:25.500 --> 00:45:26.730
Okay.
&gt;&gt; More heavy duty,

00:45:26.730 --> 00:45:30.110
just simple text editors with like add
on more brackets, things like that.

00:45:30.110 --> 00:45:37.100
So like you can actually just really,
really just look up on the Internet and

00:45:37.100 --> 00:45:41.269
basically just type in top top
five text editors for Python.

00:45:41.269 --> 00:45:43.050
&gt;&gt; You get lots.

00:45:43.050 --> 00:45:47.720
&gt;&gt; You could get a lot of articles,
research, and yeah.

00:45:47.720 --> 00:45:50.450
&gt;&gt; If you don't have any, if you're

00:45:50.450 --> 00:45:53.660
wondering what this conversation
is all about, use Sublime for now.

00:45:53.660 --> 00:45:54.810
If you don't have any preference,

00:45:54.810 --> 00:45:56.840
if you've never used
a programming environment,

00:45:56.840 --> 00:45:59.670
it's going to be easier to just use
Sublime because that's what we're going

00:45:59.670 --> 00:46:01.300
to be using throughout the course.

00:46:01.300 --> 00:46:03.830
So it will just look more familiar and
be a little easier.

00:46:03.830 --> 00:46:05.520
So stick with that.

00:46:05.520 --> 00:46:06.020
&gt;&gt; Okay.

00:46:07.110 --> 00:46:10.940
Great, so we're at 4:46 so
office hours are ending.

00:46:10.940 --> 00:46:14.170
Our live session has ended.

00:46:14.170 --> 00:46:17.210
Andy, do you have any final thoughts for
our students?

00:46:17.210 --> 00:46:18.950
&gt;&gt; No.
I hope you enjoyed this.

00:46:18.950 --> 00:46:23.240
And remember if you didn't take away
anything else, you can break big things

00:46:23.240 --> 00:46:27.403
into smaller pieces even if you haven't
solved those smaller pieces yet.

00:46:27.403 --> 00:46:28.683
&gt;&gt; Great, all right people.

00:46:28.683 --> 00:46:31.299
If you have any further questions for
follow ups,

00:46:31.299 --> 00:46:33.170
post it in the discussion forums.

00:46:33.170 --> 00:46:36.095
It's there for
you to reach out to us, Andy and

00:46:36.095 --> 00:46:38.424
I, as well as your fellow students.

00:46:38.424 --> 00:46:43.210
All right, so next week we'll have
another office hour session, same time,

00:46:43.210 --> 00:46:46.460
same day, and
we hope to see you next week.

00:46:46.460 --> 00:46:46.970
&gt;&gt; Bye.

00:46:46.970 --> 00:46:47.470
&gt;&gt; Bye everyone.

