WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.340
[MUSIC PLAYING]

00:00:07.020 --> 00:00:08.350
SUMIR KATARIA: Hi, everyone.

00:00:08.350 --> 00:00:09.810
My name is Sumir Kataria.

00:00:09.810 --> 00:00:12.450
And I'm an engineer
on the Android team.

00:00:12.450 --> 00:00:13.950
I work on architecture
components.

00:00:13.950 --> 00:00:16.450
And today, I want to talk to
you about a new library we have

00:00:16.450 --> 00:00:18.690
called work manager and
background processing

00:00:18.690 --> 00:00:20.080
in general on Android.

00:00:23.140 --> 00:00:28.030
So let's talk about
background processing in 2018.

00:00:28.030 --> 00:00:29.627
What are we trying
to do these days?

00:00:29.627 --> 00:00:31.210
Just this morning I
was trying to send

00:00:31.210 --> 00:00:33.340
a picture of my lovely
wife and my beautiful son

00:00:33.340 --> 00:00:35.600
to the rest of my family.

00:00:35.600 --> 00:00:37.570
So that's an example of
background processing.

00:00:37.570 --> 00:00:41.290
We're also sending logs, syncing
data, processing that data.

00:00:41.290 --> 00:00:45.722
All of this work is being
done in the background.

00:00:45.722 --> 00:00:47.680
And on Android, there's
a lot of different ways

00:00:47.680 --> 00:00:50.120
you can do this work.

00:00:50.120 --> 00:00:51.130
Here's a lot of them.

00:00:51.130 --> 00:00:53.740
You can do takes on
threads and executors using

00:00:53.740 --> 00:00:58.210
JobScheduler, AlarmManager,
AsyncTasks, et cetera.

00:00:58.210 --> 00:00:59.260
Which one should you use?

00:00:59.260 --> 00:01:02.830
And when should you use it?

00:01:02.830 --> 00:01:05.790
Meanwhile, Android also has a
lot of battery optimizations

00:01:05.790 --> 00:01:07.930
that we've introduced
over the last few years.

00:01:07.930 --> 00:01:11.110
For example, we introduced
doze mode in Marshmallow.

00:01:11.110 --> 00:01:13.360
If you've been
following Android P,

00:01:13.360 --> 00:01:15.070
we've had app standby buckets.

00:01:15.070 --> 00:01:17.340
In Oreo, we restricted
background apps,

00:01:17.340 --> 00:01:19.120
background services.

00:01:19.120 --> 00:01:21.460
So all of these
things have to be

00:01:21.460 --> 00:01:24.730
taken care of as a developer.

00:01:24.730 --> 00:01:26.410
And finally, we
always have to worry

00:01:26.410 --> 00:01:28.100
about backwards compatibility.

00:01:28.100 --> 00:01:32.080
So if you want to reach
90% of Android devices,

00:01:32.080 --> 00:01:34.510
you want to at least
have a minSdk of KitKat.

00:01:37.200 --> 00:01:40.540
So given all of this, what
tools do you use and when do you

00:01:40.540 --> 00:01:41.950
use them?

00:01:41.950 --> 00:01:43.950
And the trick behind
this is that you

00:01:43.950 --> 00:01:45.810
have to look at the
types of background work

00:01:45.810 --> 00:01:47.610
that you're doing.

00:01:47.610 --> 00:01:50.410
I like to split this
up into two axes.

00:01:50.410 --> 00:01:54.690
The vertical axis here is
the timing of the work.

00:01:54.690 --> 00:01:57.600
Does the work need to be done
right when it's specified?

00:01:57.600 --> 00:01:59.820
Or can it wait for a little bit?

00:01:59.820 --> 00:02:01.560
So that if your app--

00:02:01.560 --> 00:02:06.040
your device enters doze mode,
you can still do it after that.

00:02:06.040 --> 00:02:09.130
Also, on the
horizontal axis here,

00:02:09.130 --> 00:02:10.710
how important is the work?

00:02:10.710 --> 00:02:13.820
Does the work only need
to be done while your apps

00:02:13.820 --> 00:02:14.740
in the foreground?

00:02:14.740 --> 00:02:18.130
Or does it absolutely need
to be done at some point?

00:02:18.130 --> 00:02:21.690
So for example, if
you're taking a bitmap,

00:02:21.690 --> 00:02:24.210
and you decide that you want
to extract a color from it,

00:02:24.210 --> 00:02:26.460
and update your
UI with it, that's

00:02:26.460 --> 00:02:28.170
an example of
foreground-only work.

00:02:28.170 --> 00:02:32.290
You don't care about it once
the user hits home or back.

00:02:32.290 --> 00:02:34.014
That work is irrelevant.

00:02:34.014 --> 00:02:35.430
Meanwhile, if
you're sending logs,

00:02:35.430 --> 00:02:37.120
you always want that to happen.

00:02:37.120 --> 00:02:40.460
That's an example of
guaranteed execution.

00:02:40.460 --> 00:02:43.280
So for things that
are best-effort,

00:02:43.280 --> 00:02:46.790
you really want to use things
like ThreadPools, RxJava,

00:02:46.790 --> 00:02:48.770
or core routines.

00:02:48.770 --> 00:02:51.950
For things that require
exact timing and guaranteed

00:02:51.950 --> 00:02:54.470
execution, you want to
use a foreground service.

00:02:54.470 --> 00:02:56.860
So an example of this
would be that your--

00:02:56.860 --> 00:03:01.550
the user hits a button, and you
want to process a transaction,

00:03:01.550 --> 00:03:04.455
and update the UI and the
state of the app based on that.

00:03:04.455 --> 00:03:06.170
That really needs a
foreground service.

00:03:06.170 --> 00:03:07.503
That needs to happen right then.

00:03:07.503 --> 00:03:11.940
Your app cannot be killed by the
system while that's happening.

00:03:11.940 --> 00:03:14.090
This fourth category
is very interesting.

00:03:14.090 --> 00:03:16.220
So you want
guaranteed execution,

00:03:16.220 --> 00:03:19.930
but you're OK if it happens
later, doze mode can kick in.

00:03:19.930 --> 00:03:22.220
And there's a variety
of ways to solve it.

00:03:22.220 --> 00:03:25.730
On your APIs, you'll
use JobScheduler.

00:03:25.730 --> 00:03:27.530
If you want to go a
little further back,

00:03:27.530 --> 00:03:30.600
you can use Firebase
JobDispatcher to do that.

00:03:30.600 --> 00:03:32.690
And if you don't have
Google Play Services,

00:03:32.690 --> 00:03:34.550
you'll probably end
up using AlarmManager

00:03:34.550 --> 00:03:36.500
and BroadcastReceivers.

00:03:36.500 --> 00:03:38.930
And if you want to target
all of those things,

00:03:38.930 --> 00:03:41.600
well, you'll use some
mix of these four things.

00:03:41.600 --> 00:03:45.620
And that's a lot of APIs,
a lot of work to be done.

00:03:45.620 --> 00:03:47.570
WorkManager falls here.

00:03:47.570 --> 00:03:53.270
It's guaranteed execution
that's deferrable.

00:03:53.270 --> 00:03:55.960
So WorkManager, let's talk a
little bit about its features.

00:03:55.960 --> 00:03:58.360
I just mentioned guaranteed
execution is also

00:03:58.360 --> 00:03:59.620
constraint-aware.

00:03:59.620 --> 00:04:03.010
So if I want to upload that
photo that I talked about,

00:04:03.010 --> 00:04:05.320
I only want to do it
when I have a network.

00:04:05.320 --> 00:04:07.360
That's the constraint.

00:04:07.360 --> 00:04:09.850
It's also respectful of the
system background restrictions.

00:04:09.850 --> 00:04:13.330
So if your app is in doze
mode, it won't execute.

00:04:13.330 --> 00:04:17.300
It won't wake up your
phone just to do this work.

00:04:17.300 --> 00:04:19.649
It's backwards compatible
with or without Google Play

00:04:19.649 --> 00:04:21.160
Services.

00:04:21.160 --> 00:04:22.420
The API is queryable.

00:04:22.420 --> 00:04:24.700
So if you haven't
queued some work,

00:04:24.700 --> 00:04:26.750
you can actually check,
what is its state?

00:04:26.750 --> 00:04:27.940
Is it running right now?

00:04:27.940 --> 00:04:30.050
Has it succeeded or failed?

00:04:30.050 --> 00:04:33.340
These are things that you can
find out with WorkManager.

00:04:33.340 --> 00:04:34.320
It's also chainable.

00:04:34.320 --> 00:04:37.000
So you can create
graphs of work.

00:04:37.000 --> 00:04:40.570
So you can have Work A
depending on Work B and C, which

00:04:40.570 --> 00:04:45.060
in turn depends on Work D. Also
WorkManager's opportunistic.

00:04:45.060 --> 00:04:47.050
So this means that we
will try to execute

00:04:47.050 --> 00:04:50.860
that work in your process as
soon as the constraints are met

00:04:50.860 --> 00:04:53.320
without actually needing
JobScheduler to intervene

00:04:53.320 --> 00:04:55.354
or call you and wake you up.

00:04:55.354 --> 00:04:56.770
It doesn't wait
for a JobScheduler

00:04:56.770 --> 00:04:58.332
to batch your work
if your process is

00:04:58.332 --> 00:04:59.290
up and running already.

00:05:01.594 --> 00:05:03.510
So let's talk about a
little bit of the basics

00:05:03.510 --> 00:05:06.570
and talk through the code.

00:05:06.570 --> 00:05:08.460
So I just described the example.

00:05:08.460 --> 00:05:10.240
I want to upload that photo.

00:05:10.240 --> 00:05:12.780
So how would I do that
using WorkManager.

00:05:12.780 --> 00:05:14.890
Let's talk about
the core classes.

00:05:14.890 --> 00:05:15.900
There's a Worker class.

00:05:15.900 --> 00:05:17.770
This is the class
that does the work.

00:05:17.770 --> 00:05:18.270
OK.

00:05:18.270 --> 00:05:21.030
This is where you will write
most of your business logic.

00:05:21.030 --> 00:05:24.580
And there's a WorkRequest class,
which comes in two flavors--

00:05:24.580 --> 00:05:27.300
OneTimeWorkRequest for things
that just need to be done once,

00:05:27.300 --> 00:05:30.600
and PeriodicWorkRequest
for recurring work.

00:05:30.600 --> 00:05:32.340
And these will
both take a Worker.

00:05:32.340 --> 00:05:34.860
I'll show you just now.

00:05:34.860 --> 00:05:36.600
So here's my UploadPhotoWorker.

00:05:36.600 --> 00:05:41.165
It extends the Worker class, and
it overrides to doWork method.

00:05:41.165 --> 00:05:43.290
This is the method that
will run in the background.

00:05:43.290 --> 00:05:45.780
We'll take care of that
on the background thread.

00:05:45.780 --> 00:05:49.040
You don't need to put it
in a background thread.

00:05:49.040 --> 00:05:50.860
So you simply do your work.

00:05:50.860 --> 00:05:53.520
So in this case, we upload
the photo synchronously.

00:05:53.520 --> 00:05:55.450
And we return a result.
So in this case,

00:05:55.450 --> 00:05:57.510
let's say we succeeded.

00:05:57.510 --> 00:06:01.020
And the WorkerResult in here
has three values-- success

00:06:01.020 --> 00:06:04.470
and failure, which are fairly
obvious; and retry, which says,

00:06:04.470 --> 00:06:05.880
I encountered a transient error.

00:06:05.880 --> 00:06:08.940
Let's say that the device
lost network connection

00:06:08.940 --> 00:06:14.450
in the middle, so retry me after
a little bit with some backoff.

00:06:14.450 --> 00:06:18.500
So now that I have this, I can
create a OneTimeWorkRequest

00:06:18.500 --> 00:06:21.200
using the UploadPhotoWorker,
and then I

00:06:21.200 --> 00:06:24.920
can enqueue it using
WorkManager.getManager.enqueue.

00:06:24.920 --> 00:06:27.920
So soon after this is
enqueued, it'll start running.

00:06:27.920 --> 00:06:31.100
You'll upload your photo.

00:06:31.100 --> 00:06:32.309
But I just talked about this.

00:06:32.309 --> 00:06:34.474
What if you lose connectivity
in the middle of this,

00:06:34.474 --> 00:06:35.570
or even before it does?

00:06:35.570 --> 00:06:37.850
What if you've never
had connectivity?

00:06:37.850 --> 00:06:40.590
You actually want to use
constraints in this case.

00:06:40.590 --> 00:06:42.950
So an example of the
constraint here you want to use

00:06:42.950 --> 00:06:45.050
is you make a
Constraints Builder.

00:06:45.050 --> 00:06:47.450
And you say,
setRequiredNetworkType

00:06:47.450 --> 00:06:48.170
to be connected.

00:06:48.170 --> 00:06:50.570
So you need a connected
network connection.

00:06:50.570 --> 00:06:51.680
You build it.

00:06:51.680 --> 00:06:55.200
And you also set the
constraints on the request

00:06:55.200 --> 00:06:57.680
that you just built. So by
simply doing this, and then

00:06:57.680 --> 00:07:00.530
enqueuing it, you make sure
that this work only runs

00:07:00.530 --> 00:07:02.185
when your network is connected.

00:07:04.564 --> 00:07:06.480
So let's say you want
to observe this work now

00:07:06.480 --> 00:07:07.271
that we've done it.

00:07:07.271 --> 00:07:12.570
So I want to show a spinner
while this work is executing,

00:07:12.570 --> 00:07:15.210
and then I want to hide
the spinner when it's done.

00:07:15.210 --> 00:07:17.050
How would I do that?

00:07:17.050 --> 00:07:21.300
So as I said, I'll
enqueue this request.

00:07:21.300 --> 00:07:24.060
And then I can say,
getStatusByID on WorkManager

00:07:24.060 --> 00:07:25.980
using the request.id.

00:07:25.980 --> 00:07:28.080
So each request has an ID.

00:07:28.080 --> 00:07:30.720
And this returns a
LiveData out of WorkStatus.

00:07:30.720 --> 00:07:32.970
If you guys remember
architecture components,

00:07:32.970 --> 00:07:37.190
LiveData is a
lifecycle-aware observable.

00:07:37.190 --> 00:07:40.130
So now you can just hook
into that observable,

00:07:40.130 --> 00:07:43.380
and you can say, when
that work is finished,

00:07:43.380 --> 00:07:44.390
hide that progress bar.

00:07:47.442 --> 00:07:49.400
So what is this WorkStatus
object that you were

00:07:49.400 --> 00:07:51.110
looking at at the LiveData?

00:07:51.110 --> 00:07:52.470
It has an ID.

00:07:52.470 --> 00:07:55.010
This is the same
ID as the request.

00:07:55.010 --> 00:07:56.430
And it has a State.

00:07:56.430 --> 00:08:00.540
The State is the current
state of execution.

00:08:00.540 --> 00:08:02.780
There's six values
here enqueued, running,

00:08:02.780 --> 00:08:05.030
succeeded or failed,
locked and canceled.

00:08:05.030 --> 00:08:07.150
And we'll talk about
the last two later.

00:08:10.570 --> 00:08:12.839
So let's move a step
up in concepts here.

00:08:12.839 --> 00:08:14.130
Let's talk about chaining work.

00:08:14.130 --> 00:08:16.890
So I promised that you
can actually make directed

00:08:16.890 --> 00:08:18.580
[INAUDIBLE] graphs of work.

00:08:18.580 --> 00:08:20.416
How would you do that?

00:08:20.416 --> 00:08:21.790
Let's say this is
my problem now.

00:08:21.790 --> 00:08:23.490
I'm uploading a video.

00:08:23.490 --> 00:08:24.330
It's a huge video.

00:08:24.330 --> 00:08:26.910
I want to compress it
first, then upload it.

00:08:26.910 --> 00:08:29.460
So these are both eligible
for background work

00:08:29.460 --> 00:08:31.310
because they're time
intensive things.

00:08:33.909 --> 00:08:36.429
So let's say I have two
Workers, CompressPhotoWorker

00:08:36.429 --> 00:08:37.690
and UploadPhotoWorker.

00:08:37.690 --> 00:08:40.850
They're both defined to do
the things that I just said.

00:08:40.850 --> 00:08:43.360
So you can make
WorkRequests from them.

00:08:43.360 --> 00:08:46.600
And you can say workManager.begi
nWith(compressWork).

00:08:46.600 --> 00:08:48.890
Then uploadWork and enqueue it.

00:08:48.890 --> 00:08:51.620
So this ensures that
compressWork executes first.

00:08:51.620 --> 00:08:54.940
And once it's successful,
then uploadWork goes.

00:08:57.714 --> 00:08:59.130
And if you were
to write this out,

00:08:59.130 --> 00:09:01.230
because that was a very
fluent way of writing it,

00:09:01.230 --> 00:09:02.940
what happens behind
the scenes here

00:09:02.940 --> 00:09:06.770
is that begin with returns
of WorkContinuation.

00:09:06.770 --> 00:09:09.350
And a WorkContinuation
has a method called then

00:09:09.350 --> 00:09:11.160
that also returns
a WorkContinuation,

00:09:11.160 --> 00:09:12.430
a different one.

00:09:12.430 --> 00:09:16.410
So you're using that to
create, that's fluent API.

00:09:16.410 --> 00:09:18.510
So you can actually use
these WorkContinuations

00:09:18.510 --> 00:09:22.820
and pass them around
if you want, et cetera.

00:09:22.820 --> 00:09:24.834
So let's say that I'm
uploading multiple photos.

00:09:24.834 --> 00:09:25.750
I take lots of photos.

00:09:25.750 --> 00:09:28.270
No one takes only just
one photo of their child.

00:09:28.270 --> 00:09:33.070
So how would I upload
all of these in parallel?

00:09:33.070 --> 00:09:36.390
Well, so let's say I've got a
WorkRequest for all of them.

00:09:36.390 --> 00:09:39.592
I can literally just say,
.enqueue and put all of them

00:09:39.592 --> 00:09:40.091
there.

00:09:40.091 --> 00:09:40.882
It's a [INAUDIBLE].

00:09:40.882 --> 00:09:43.050
So you can pass more
than one thing there.

00:09:43.050 --> 00:09:46.402
And these are all eligible
for running in parallel.

00:09:46.402 --> 00:09:48.360
They may not actually
run in parallel depending

00:09:48.360 --> 00:09:50.970
on your device, and the executor
being used, and all of that,

00:09:50.970 --> 00:09:51.810
but they could be.

00:09:54.900 --> 00:09:57.840
So let's choose an even
more complex example.

00:09:57.840 --> 00:09:59.770
Now you want to
filter your photos.

00:09:59.770 --> 00:10:01.710
So you want to
apply some kind of--

00:10:01.710 --> 00:10:04.230
I don't know-- grayscale filter
or a sepia filter to them,

00:10:04.230 --> 00:10:07.170
then you want to compress them,
then you want to upload them.

00:10:07.170 --> 00:10:08.730
How would you do this?

00:10:08.730 --> 00:10:10.270
WorkManager makes
it very simple.

00:10:10.270 --> 00:10:12.240
So first you say, beginWith.

00:10:12.240 --> 00:10:14.790
You do all the filter
works in parallel.

00:10:14.790 --> 00:10:17.110
After those have all
completed successfully,

00:10:17.110 --> 00:10:19.440
then you do your
compression work.

00:10:19.440 --> 00:10:21.210
And after those have
completed-- that has

00:10:21.210 --> 00:10:24.486
completed successfully,
then you do your uploadWork.

00:10:24.486 --> 00:10:26.110
And don't forget to
enqueue at the end.

00:10:29.690 --> 00:10:31.290
So we've talked
about all of that,

00:10:31.290 --> 00:10:32.890
but there's a key
concept that I want

00:10:32.890 --> 00:10:35.180
to cover that's very
much related to chaining.

00:10:35.180 --> 00:10:36.420
This is inputs and outputs.

00:10:39.360 --> 00:10:42.500
So let's talk about this
problem that I have here.

00:10:42.500 --> 00:10:46.250
It's a MapReduce,
and really a good way

00:10:46.250 --> 00:10:49.075
of explaining a MapReduce
is to give an example.

00:10:49.075 --> 00:10:49.700
I love reading.

00:10:49.700 --> 00:10:51.470
I've loved reading
Sherlock Holmes novels

00:10:51.470 --> 00:10:53.150
since I was a kid.

00:10:53.150 --> 00:10:55.730
And the other day, I
was thinking, well,

00:10:55.730 --> 00:10:58.140
Arthur Conan Doyle has a
very specific way of writing.

00:10:58.140 --> 00:11:02.060
What are the top 10 words
he uses in his books?

00:11:02.060 --> 00:11:03.812
Well, how would I
figure that out?

00:11:03.812 --> 00:11:05.020
I would go through each book.

00:11:05.020 --> 00:11:07.430
I would count the
occurrence of each word,

00:11:07.430 --> 00:11:09.560
and then I would
combine all of that data

00:11:09.560 --> 00:11:13.400
and sort it so that I would
find the top 10 of those.

00:11:13.400 --> 00:11:16.520
This is a distributed problem
that we could call a MapReduce.

00:11:20.160 --> 00:11:24.190
And for inputs and outputs,
the common unit of operation

00:11:24.190 --> 00:11:25.700
here is a data.

00:11:25.700 --> 00:11:27.660
The data is a
simple class that's

00:11:27.660 --> 00:11:30.060
a key-value map under the hood.

00:11:30.060 --> 00:11:31.080
The keys are strings.

00:11:31.080 --> 00:11:33.300
The values are
primitives and strings,

00:11:33.300 --> 00:11:34.870
and the array versions of each.

00:11:34.870 --> 00:11:37.320
So this is kind of like
a bundle or parsable,

00:11:37.320 --> 00:11:38.880
but it's its own thing.

00:11:38.880 --> 00:11:41.220
It's serializable
by a WorkManager,

00:11:41.220 --> 00:11:43.530
and we limit it to
10 kilobytes in size.

00:11:43.530 --> 00:11:45.780
And I'll go more
into that part later.

00:11:48.696 --> 00:11:49.820
So how do we create a data?

00:11:49.820 --> 00:11:52.590
So in Kotlin, you can
make a map very easily.

00:11:52.590 --> 00:11:56.450
So in this case, we're mapping
the key file_name to the value

00:11:56.450 --> 00:11:58.610
a_study_in_scarlet.txt.

00:11:58.610 --> 00:12:00.854
That's the novel that
I'm going to look at.

00:12:00.854 --> 00:12:02.270
And I'll convert
it to a WorkData.

00:12:02.270 --> 00:12:03.790
So this is a data object.

00:12:06.330 --> 00:12:09.090
And once I create my
workRequest builder,

00:12:09.090 --> 00:12:10.660
I can set the InputData on it.

00:12:10.660 --> 00:12:14.340
So this is the
InputData of that map.

00:12:14.340 --> 00:12:16.000
And I pass it along.

00:12:16.000 --> 00:12:18.210
So inside my worker,
I can actually

00:12:18.210 --> 00:12:20.790
retrieve this InputData by
just calling the getInputData

00:12:20.790 --> 00:12:22.320
method.

00:12:22.320 --> 00:12:24.640
And from that I can get the
string for the file names.

00:12:24.640 --> 00:12:26.840
And now I have the fileName.

00:12:26.840 --> 00:12:28.690
And I can say,
count all the word

00:12:28.690 --> 00:12:30.204
occurrences in this fileName.

00:12:30.204 --> 00:12:32.370
That's some method that
I've written somewhere else,

00:12:32.370 --> 00:12:33.536
and I can return my success.

00:12:36.592 --> 00:12:38.050
But you don't want
to do just that.

00:12:38.050 --> 00:12:40.300
You actually want to
also have outputs, right?

00:12:40.300 --> 00:12:43.330
Now you've done all this
work, it should do something.

00:12:43.330 --> 00:12:45.100
There should be
an output for it.

00:12:45.100 --> 00:12:49.450
So let's say that data that
we have returns a map of words

00:12:49.450 --> 00:12:51.670
to their occurrences.

00:12:51.670 --> 00:12:54.610
We can convert that
map to a WorkData.

00:12:54.610 --> 00:12:57.100
And we can call a method
called setOutputData

00:12:57.100 --> 00:12:58.840
that sets this data--

00:12:58.840 --> 00:13:01.600
so getInputData, setOutputData.

00:13:04.530 --> 00:13:07.080
So the key observation
that you need to know here

00:13:07.080 --> 00:13:09.060
is that the worker's
outputs become

00:13:09.060 --> 00:13:11.620
the inputs for its children.

00:13:11.620 --> 00:13:16.560
So what happens is the
findTop10Words worker, which

00:13:16.560 --> 00:13:19.440
goes next, its
inputData is coming

00:13:19.440 --> 00:13:21.640
from the previous worker.

00:13:21.640 --> 00:13:26.550
So in this case, you can pass
the data all the way through,

00:13:26.550 --> 00:13:28.620
find the top 10
words, and return out.

00:13:28.620 --> 00:13:31.150
So the data flow for one
book becomes like this--

00:13:31.150 --> 00:13:34.170
I'll count all the word
occurrences in that book.

00:13:34.170 --> 00:13:36.920
I'll pass it to the
findTop10Words worker.

00:13:36.920 --> 00:13:40.080
It's inputData will be
whatever I pass through.

00:13:40.080 --> 00:13:44.070
And it will do the sorting
or whatever it needs to do.

00:13:44.070 --> 00:13:45.840
But here is a
really tricky thing,

00:13:45.840 --> 00:13:48.240
what happens when you
have multiple books?

00:13:48.240 --> 00:13:51.500
What's the input for the
findTop10Words worker?

00:13:51.500 --> 00:13:53.370
You're passing multiple
pieces of data,

00:13:53.370 --> 00:13:57.720
but I've only been able
to get one inputData.

00:13:57.720 --> 00:14:00.290
What happens to the rest of
them, or how do they combine?

00:14:02.940 --> 00:14:05.230
For this, you want to
look at InputMergers.

00:14:05.230 --> 00:14:07.720
So InputMerger is a
class that combines

00:14:07.720 --> 00:14:10.870
data from multiple sources
into one data object.

00:14:10.870 --> 00:14:12.730
And we provide two
implementations

00:14:12.730 --> 00:14:14.030
out of the box--

00:14:14.030 --> 00:14:16.790
OverwritingInputMerger,
which is the default,

00:14:16.790 --> 00:14:18.520
and ArrayCreatingInputMerger.

00:14:18.520 --> 00:14:23.560
You can also create your own,
but let's talk about these two.

00:14:23.560 --> 00:14:25.690
First,
OverwritingInputMerger-- so we

00:14:25.690 --> 00:14:30.100
have two data objects here, each
with their own keys and values.

00:14:30.100 --> 00:14:32.830
What does
OverwritingInputMerger do?

00:14:32.830 --> 00:14:35.410
It first takes the
first piece of data

00:14:35.410 --> 00:14:37.750
and it just puts everything
in a new data object.

00:14:37.750 --> 00:14:40.390
So it's an exact copy of this.

00:14:40.390 --> 00:14:42.730
Then it takes a
second piece of data

00:14:42.730 --> 00:14:45.070
and it copies it
over, so overwriting

00:14:45.070 --> 00:14:47.440
anything that's the same key.

00:14:47.440 --> 00:14:53.320
So in this case, the name Alice
becomes Bob, and the age of 30

00:14:53.320 --> 00:14:55.000
becomes Three Days.

00:14:55.000 --> 00:14:56.150
Note that it changed type.

00:14:56.150 --> 00:14:59.230
So a number became
a string here.

00:14:59.230 --> 00:15:03.370
The scores key was new,
so it just got added.

00:15:03.370 --> 00:15:06.760
Note that if we did this
in reverse, instead of Bob,

00:15:06.760 --> 00:15:08.510
you would have Alice
as the final output.

00:15:08.510 --> 00:15:10.749
So this is something
a little tricky.

00:15:10.749 --> 00:15:12.790
You want to make sure that
OverwritingInputMerger

00:15:12.790 --> 00:15:14.600
is the right tool for the job.

00:15:14.600 --> 00:15:16.720
But it is very simple.

00:15:16.720 --> 00:15:18.500
What about
ArrayCreatingInputMerger?

00:15:18.500 --> 00:15:20.080
This is the one
that actually takes

00:15:20.080 --> 00:15:23.010
care of those collision case.

00:15:23.010 --> 00:15:25.320
So in this case, let's
go just key by key.

00:15:25.320 --> 00:15:29.740
The name becomes an
array of Alice and Bob.

00:15:29.740 --> 00:15:31.950
Color becomes a
singleton array of blue

00:15:31.950 --> 00:15:35.460
because it's only
defined in one of them.

00:15:35.460 --> 00:15:38.910
Scores, notice that
there is one integer

00:15:38.910 --> 00:15:40.409
and one array of integers.

00:15:40.409 --> 00:15:42.450
These combine and they
just concatenate together.

00:15:42.450 --> 00:15:45.870
Order is not specified, but
all the values come through.

00:15:45.870 --> 00:15:47.250
What happens for age?

00:15:47.250 --> 00:15:51.730
So there's an integer,
and there's a string.

00:15:51.730 --> 00:15:53.100
This is an exception we do.

00:15:53.100 --> 00:15:55.770
Expect it to be the
same basic value type.

00:15:58.570 --> 00:16:01.150
So let's go back to that
example I was telling you about,

00:16:01.150 --> 00:16:02.980
Sherlock Holmes.

00:16:02.980 --> 00:16:07.120
Implicitly, there is an
InputMerger before the stage.

00:16:07.120 --> 00:16:08.980
So we combine all of that data.

00:16:08.980 --> 00:16:10.750
And which InputMerger
do we want to use?

00:16:10.750 --> 00:16:12.730
So we want to-- we
don't want to throw away

00:16:12.730 --> 00:16:14.410
any of this calculation
that we've done.

00:16:14.410 --> 00:16:17.020
So we actually want to use an
ArrayCreatingInputMerger, which

00:16:17.020 --> 00:16:20.820
preserves all of the
data and gets it through.

00:16:20.820 --> 00:16:22.650
So how do we do that?

00:16:22.650 --> 00:16:25.564
Well, we just say setInputMerger
on the request builder

00:16:25.564 --> 00:16:26.480
of the findTop10Words.

00:16:26.480 --> 00:16:30.950
So it merges data using an
ArrayCreatingInputMerger.

00:16:30.950 --> 00:16:33.770
So you say, beginWith
the countWords workers,

00:16:33.770 --> 00:16:39.340
then do the findTop10Words
worker, and then enqueue.

00:16:39.340 --> 00:16:41.470
So for example,
if the first book

00:16:41.470 --> 00:16:45.490
had 10 instances of the
word Sherlock, 5 of Watson,

00:16:45.490 --> 00:16:49.030
and 30 of elementary, and the
second one had 12, 15, and 5.

00:16:49.030 --> 00:16:50.770
You would get arrays like this.

00:16:50.770 --> 00:16:52.600
Sherlock would be 10, 12.

00:16:52.600 --> 00:16:54.250
Watson would be 5, 15.

00:16:54.250 --> 00:16:56.420
Elementary would be 35.

00:16:56.420 --> 00:16:58.120
So in your
findTop10Words worker,

00:16:58.120 --> 00:17:01.480
you would sum all of that up,
sort them, find the top 10,

00:17:01.480 --> 00:17:04.666
and that's your output.

00:17:04.666 --> 00:17:06.619
And I just said that's
your output, right?

00:17:06.619 --> 00:17:09.829
So you can actually observe
the output in your work status

00:17:09.829 --> 00:17:10.730
using that LiveData.

00:17:10.730 --> 00:17:13.339
So you can actually
get that output data.

00:17:13.339 --> 00:17:15.880
So that's super useful because
you can display it in your UI.

00:17:19.222 --> 00:17:20.180
How do you cancel work?

00:17:20.180 --> 00:17:22.669
So I just decided to
send up a picture,

00:17:22.669 --> 00:17:24.710
but I'm like, wait a sec,
this is not the picture

00:17:24.710 --> 00:17:26.940
I'm meant to send up.

00:17:26.940 --> 00:17:28.190
How do you cancel that upload?

00:17:31.010 --> 00:17:34.190
Very simple, you just
say, cancelWorkById.

00:17:34.190 --> 00:17:36.710
But do note that
cancellation is best effort.

00:17:36.710 --> 00:17:38.390
So the work may have
already finished.

00:17:38.390 --> 00:17:40.450
These are all
asynchronous things.

00:17:40.450 --> 00:17:42.620
They may be happening
in the background.

00:17:42.620 --> 00:17:44.960
Before you have had a chance
to do that cancelWork,

00:17:44.960 --> 00:17:47.320
it may already be
running or finished.

00:17:47.320 --> 00:17:48.450
So it's best effort.

00:17:51.190 --> 00:17:55.370
OK, so let's talk a little
bit more about tags.

00:17:55.370 --> 00:17:59.660
And tags are solving
this problem.

00:17:59.660 --> 00:18:02.600
IDs that I just told you
about are auto generated.

00:18:02.600 --> 00:18:03.870
They're not human readable.

00:18:03.870 --> 00:18:07.010
So they're actually
UUIDs under the hood.

00:18:07.010 --> 00:18:08.720
And you can't really
understand them.

00:18:08.720 --> 00:18:10.190
They're not useful
for debugging.

00:18:10.190 --> 00:18:12.431
If you log them, they're
not going to make sense.

00:18:12.431 --> 00:18:13.680
What kind of work was running?

00:18:13.680 --> 00:18:14.150
I don't know.

00:18:14.150 --> 00:18:15.290
It's just some big number.

00:18:15.290 --> 00:18:17.750
I don't know what that is.

00:18:17.750 --> 00:18:19.730
Tags solve this issue.

00:18:19.730 --> 00:18:23.060
Tags are a readable way
to identify your work.

00:18:23.060 --> 00:18:26.480
So tags are developer-specified
strings by you,

00:18:26.480 --> 00:18:29.990
and each work request can
have zero or more tags.

00:18:29.990 --> 00:18:33.629
You can query and
cancel work by tag.

00:18:33.629 --> 00:18:34.670
Let's look at an example.

00:18:34.670 --> 00:18:37.910
So I used to work
on the G+ team here.

00:18:37.910 --> 00:18:40.370
And the G+ app
supports multi-login.

00:18:40.370 --> 00:18:43.830
So you can have multiple users
logged in at the same time.

00:18:43.830 --> 00:18:46.569
And each of those users
could be doing several kinds

00:18:46.569 --> 00:18:47.360
of background work.

00:18:47.360 --> 00:18:48.370
You could be getting favorites.

00:18:48.370 --> 00:18:49.745
You could be
getting preferences.

00:18:49.745 --> 00:18:53.120
So if you have three users
logged in on your phone,

00:18:53.120 --> 00:18:54.770
and they're doing
two kinds of work,

00:18:54.770 --> 00:18:56.660
you have six things happening.

00:18:56.660 --> 00:18:59.330
How do you identify what you're
looking at any given time?

00:19:01.880 --> 00:19:03.050
Well, you can use tags.

00:19:03.050 --> 00:19:07.070
So for example, in this
workRequest builder,

00:19:07.070 --> 00:19:09.230
you can add tags to
say this is user1,

00:19:09.230 --> 00:19:12.030
and this is the
get_favorites operation.

00:19:12.030 --> 00:19:15.430
So now you can actually
identify that work.

00:19:15.430 --> 00:19:17.180
And if you wanted to
look at the statuses,

00:19:17.180 --> 00:19:19.760
you could say, give me
all of the work for user1.

00:19:19.760 --> 00:19:23.960
And this will return a list
of work statuses as a LiveData

00:19:23.960 --> 00:19:27.230
because each tag can correspond
to more than one workRequest.

00:19:27.230 --> 00:19:30.410
So this is a list
of work statuses.

00:19:30.410 --> 00:19:33.380
Similarly, you can also
cancel all work by tag.

00:19:33.380 --> 00:19:35.590
Cancellation is
best effort, again.

00:19:35.590 --> 00:19:38.180
But you can cancel all of
one particular kind of work,

00:19:38.180 --> 00:19:38.840
in this case.

00:19:42.410 --> 00:19:45.010
Tags are also useful for
a couple of other reasons.

00:19:45.010 --> 00:19:48.540
Tags namespace your type of
work, as I just told you.

00:19:48.540 --> 00:19:51.890
You can have tags for the kinds
of operations you're doing,

00:19:51.890 --> 00:19:56.090
get favorites, get
preferences, et cetera.

00:19:56.090 --> 00:19:58.220
But they also namespace
libraries and modules.

00:19:58.220 --> 00:20:01.550
So if you're a library
owner or a module owner,

00:20:01.550 --> 00:20:04.280
you should always tag your
work so you can get it later.

00:20:04.280 --> 00:20:06.560
Let's say that you
have a library,

00:20:06.560 --> 00:20:09.290
and you move to a new version
of that library in your app,

00:20:09.290 --> 00:20:11.206
maybe you want to cancel
all the work you had.

00:20:11.206 --> 00:20:13.790
You can cancel all
work by your tag.

00:20:13.790 --> 00:20:18.410
So always use tags when
you are using a library.

00:20:18.410 --> 00:20:20.690
And WorkStatus also has
tags available in it.

00:20:20.690 --> 00:20:22.440
So if you're ever
looking at a WorkStatus,

00:20:22.440 --> 00:20:23.856
you can get the
tags for that work

00:20:23.856 --> 00:20:28.500
and see what you yourself
called it in the past

00:20:28.500 --> 00:20:31.650
when you enqueued it.

00:20:31.650 --> 00:20:34.650
One more thing I wanted to
talk about is unique work.

00:20:34.650 --> 00:20:37.200
So unique work solves a
few different problems.

00:20:37.200 --> 00:20:40.950
But one of the common ones
that almost every app has

00:20:40.950 --> 00:20:42.660
is syncing.

00:20:42.660 --> 00:20:44.790
You want to sync when
you first launch the app.

00:20:44.790 --> 00:20:47.190
You want to sync maybe
every 12 to 24 hours

00:20:47.190 --> 00:20:48.930
to get the freshest data.

00:20:48.930 --> 00:20:51.510
And you may also want to sync
when your language changes.

00:20:51.510 --> 00:20:56.215
Maybe you have a version of your
data in a different language.

00:20:56.215 --> 00:20:57.840
So you want to sync
at that point, too.

00:20:57.840 --> 00:21:00.420
So you're doing
all this syncing,

00:21:00.420 --> 00:21:03.240
but you really only want
one sync active at a time.

00:21:03.240 --> 00:21:05.476
You don't want four
sync operations running.

00:21:05.476 --> 00:21:06.600
Which one is the right one?

00:21:06.600 --> 00:21:07.260
Which one wins?

00:21:07.260 --> 00:21:08.820
You don't know.

00:21:08.820 --> 00:21:11.070
You just want one.

00:21:11.070 --> 00:21:12.720
Unique work can solve this.

00:21:12.720 --> 00:21:17.400
So it is-- a chain of work
can be given a unique name.

00:21:17.400 --> 00:21:21.120
You can enqueue, query,
and cancel using that name,

00:21:21.120 --> 00:21:25.306
and there can only be one
chain of work with that name.

00:21:25.306 --> 00:21:26.930
Let's take a look at
that sync example.

00:21:26.930 --> 00:21:33.400
So if I say, beginUniqueWork
with my name, let's say sync,

00:21:33.400 --> 00:21:35.820
in this case.

00:21:35.820 --> 00:21:40.210
And that next argument is what
I call the existing work policy.

00:21:40.210 --> 00:21:44.119
So if there is work
with this name, sync,

00:21:44.119 --> 00:21:45.160
what should I do with it?

00:21:45.160 --> 00:21:47.560
In this case, I say, keep it.

00:21:47.560 --> 00:21:49.600
I want to keep the
existing work, ignore

00:21:49.600 --> 00:21:51.220
what I'm doing right now.

00:21:51.220 --> 00:21:54.190
The next argument is
actually your workRequest,

00:21:54.190 --> 00:21:56.730
in this case, a syncRequest
when you enqueue it.

00:21:56.730 --> 00:22:01.570
So if there's work with the
name sync already in flight,

00:22:01.570 --> 00:22:02.980
it will keep that.

00:22:02.980 --> 00:22:06.920
If there isn't, it will
enqueue this and execute it.

00:22:06.920 --> 00:22:09.870
So this is how you
dedupe your syncs.

00:22:09.870 --> 00:22:12.620
So here at Google,
we love chat apps.

00:22:12.620 --> 00:22:15.830
And maybe you're updating
your chat status.

00:22:15.830 --> 00:22:17.790
So you want to say, I'm bored.

00:22:17.790 --> 00:22:20.010
And then 10 seconds
later, I'm watching TV.

00:22:20.010 --> 00:22:21.110
Then, I'm bored again.

00:22:21.110 --> 00:22:23.350
OK, I'm going to sleep.

00:22:23.350 --> 00:22:25.490
And you're in a bad
network connection state.

00:22:25.490 --> 00:22:28.155
You have bad Wi-Fi, and
maybe the first thing

00:22:28.155 --> 00:22:30.530
hasn't gone through when you
type your second chat status

00:22:30.530 --> 00:22:31.070
update.

00:22:31.070 --> 00:22:33.090
And really the second
one should win,

00:22:33.090 --> 00:22:35.010
and the third one
should win over that.

00:22:35.010 --> 00:22:37.670
So you want to make sure
that the last one wins.

00:22:37.670 --> 00:22:40.609
How would you solve this?

00:22:40.609 --> 00:22:41.650
Here's a simple function.

00:22:41.650 --> 00:22:43.150
You don't even need to
read the rest of it.

00:22:43.150 --> 00:22:45.191
It's the last line that
I want you to care about,

00:22:45.191 --> 00:22:48.130
which is beginUniqueWork.

00:22:48.130 --> 00:22:51.400
Your name is update_status, and
you choose the REPLACE option.

00:22:51.400 --> 00:22:55.780
REPLACE cancels and deletes any
existing in flight operations

00:22:55.780 --> 00:22:57.130
off that name.

00:22:57.130 --> 00:22:59.080
So the last one always does win.

00:22:59.080 --> 00:23:02.850
In this case, if you have
two update chat status calls,

00:23:02.850 --> 00:23:04.060
the last one will win.

00:23:06.910 --> 00:23:08.610
And finally, I love music.

00:23:08.610 --> 00:23:10.189
I love the Foo Fighters.

00:23:10.189 --> 00:23:12.730
I was building a playlist the
other day with all their songs.

00:23:12.730 --> 00:23:13.688
There's a lot of songs.

00:23:13.688 --> 00:23:16.790
There's like 150 or 200 songs.

00:23:16.790 --> 00:23:18.120
And I was doing all of this.

00:23:18.120 --> 00:23:19.770
I was adding a song.

00:23:19.770 --> 00:23:21.629
I was shuffling
two songs around.

00:23:21.629 --> 00:23:23.670
I was moving something to
the bottom of the list.

00:23:23.670 --> 00:23:27.130
I was deleting a song because I
had it already somewhere else.

00:23:27.130 --> 00:23:30.180
These are all things that I
want to do using WorkManager,

00:23:30.180 --> 00:23:31.740
but how would I do that?

00:23:31.740 --> 00:23:34.810
These things all have
to execute in order.

00:23:34.810 --> 00:23:37.830
And so since the
order is important,

00:23:37.830 --> 00:23:41.730
we provided the ability to
use the APPEND existing work

00:23:41.730 --> 00:23:47.370
policy that says, do this
work at the end of the list

00:23:47.370 --> 00:23:49.260
of update_playlist operations.

00:23:49.260 --> 00:23:52.270
So append this to the
end of this thing,

00:23:52.270 --> 00:23:54.510
so everything else
must successfully

00:23:54.510 --> 00:23:56.680
execute before this executes.

00:23:56.680 --> 00:24:00.970
So you can add
operations to the end.

00:24:00.970 --> 00:24:03.280
So ExistingWorkPolicy,
as a summary,

00:24:03.280 --> 00:24:06.040
there are three types,
KEEP, REPLACE, and APPEND.

00:24:09.470 --> 00:24:11.090
A few notes about
PeriodicWork, it

00:24:11.090 --> 00:24:13.970
works very similarly to
everything you've seen so far.

00:24:13.970 --> 00:24:17.330
Just a couple of notes on it--
so the minimum period length

00:24:17.330 --> 00:24:18.620
is the same as JobScheduler.

00:24:18.620 --> 00:24:20.460
It is 15 minutes.

00:24:20.460 --> 00:24:23.360
It is still subject to doze mode
and OS background restrictions,

00:24:23.360 --> 00:24:25.940
just like any of the other
work we've talked about.

00:24:25.940 --> 00:24:29.210
It can't be chained, and it
can't have initial delays.

00:24:29.210 --> 00:24:32.930
And we think that that just
sort of makes good API sense.

00:24:32.930 --> 00:24:36.830
It's much more reasonable to
think of it in those terms.

00:24:39.157 --> 00:24:40.990
All right, so we've
talked a lot about code.

00:24:40.990 --> 00:24:43.830
Let's talk about how it
all works under the hood.

00:24:47.125 --> 00:24:48.000
So you've got a work.

00:24:48.000 --> 00:24:49.080
You enqueue it.

00:24:49.080 --> 00:24:51.150
We store it in our database.

00:24:51.150 --> 00:24:53.620
What happens after that?

00:24:53.620 --> 00:24:55.660
Well, if the work is
eligible for execution,

00:24:55.660 --> 00:24:57.630
we just send it to the
executor right away.

00:24:57.630 --> 00:25:00.290
By the way, this executor,
you can actually specify it,

00:25:00.290 --> 00:25:04.170
but we do provide
one that's default.

00:25:04.170 --> 00:25:06.590
But let's say that your
process gets killed.

00:25:06.590 --> 00:25:07.590
Well, what happens then?

00:25:07.590 --> 00:25:11.100
How does it get woken up, and
how does this work run again?

00:25:11.100 --> 00:25:16.290
So if you're on API 23+, we
send it to JobScheduler as well.

00:25:16.290 --> 00:25:20.060
And JobScheduler invokes an
IPC, wakes up your process.

00:25:20.060 --> 00:25:23.700
It goes to the same executor,
and that's where it runs.

00:25:23.700 --> 00:25:28.260
If it's an older device, and
you use Firebase JobDispatcher

00:25:28.260 --> 00:25:30.660
and user optional
dependency, we can send it

00:25:30.660 --> 00:25:32.100
to Firebase JobDispatcher.

00:25:32.100 --> 00:25:35.889
Same thing, invokes an IPC,
runs it on that executor.

00:25:35.889 --> 00:25:38.430
What if you don't have that or
you're not using a Google Play

00:25:38.430 --> 00:25:39.340
services device?

00:25:39.340 --> 00:25:41.970
So you're using something else.

00:25:41.970 --> 00:25:44.400
We have a custom AlarmManager
and Broadcast Receivers

00:25:44.400 --> 00:25:45.620
implementation.

00:25:45.620 --> 00:25:48.677
And the same thing,
uses an IPC, wakes up

00:25:48.677 --> 00:25:50.760
your app when the time is
right, and runs the job.

00:25:53.850 --> 00:25:55.350
A couple of
implementation details--

00:25:55.350 --> 00:25:57.615
so JobScheduler and
Firebase JobDispatcher

00:25:57.615 --> 00:26:00.120
are through Google
Play services.

00:26:00.120 --> 00:26:02.460
They provide central
load balancing mechanism

00:26:02.460 --> 00:26:03.380
for execution.

00:26:03.380 --> 00:26:08.017
So if every app on your
device is trying to run jobs,

00:26:08.017 --> 00:26:09.100
they'll load balance them.

00:26:09.100 --> 00:26:10.980
They'll make sure
that you're not

00:26:10.980 --> 00:26:12.480
running too much
work on your device

00:26:12.480 --> 00:26:14.310
and burning up your battery.

00:26:14.310 --> 00:26:16.470
The AlarmManager
implementation that we have,

00:26:16.470 --> 00:26:18.180
unfortunately, can't
do that because it's

00:26:18.180 --> 00:26:21.870
only there off your own app.

00:26:21.870 --> 00:26:24.780
Of course, your concepts,
like content URI triggers,

00:26:24.780 --> 00:26:27.660
idle, doze mode, et cetera,
are only available at the API

00:26:27.660 --> 00:26:29.160
levels that they
were introduced at.

00:26:29.160 --> 00:26:31.650
So those methods
will be marked with,

00:26:31.650 --> 00:26:35.680
requires API with the
appropriate API level.

00:26:35.680 --> 00:26:37.990
We take care of obtaining
wake locks when necessary.

00:26:37.990 --> 00:26:40.680
So especially, this is
true for the AlarmManager

00:26:40.680 --> 00:26:41.850
implementation.

00:26:41.850 --> 00:26:44.877
Don't take wake locks
in your workers.

00:26:44.877 --> 00:26:45.960
You don't need to do that.

00:26:45.960 --> 00:26:47.085
We take care of it for you.

00:26:49.950 --> 00:26:52.010
Finally, let's talk a
little bit about testing.

00:26:52.010 --> 00:26:54.590
You want to test this app.

00:26:54.590 --> 00:26:56.130
We provide a testing library.

00:26:56.130 --> 00:26:58.560
It has a synchronous executor.

00:26:58.560 --> 00:27:01.970
Use WorkManager as normal
to enqueue your requests.

00:27:01.970 --> 00:27:03.990
And we provide a class
called TestDriver,

00:27:03.990 --> 00:27:07.220
which executes enqueued
work that has constraints.

00:27:07.220 --> 00:27:10.440
So we can just pretend that
the constraint has been meant.

00:27:10.440 --> 00:27:12.920
Periodic and initial delay
triggers are coming soon.

00:27:12.920 --> 00:27:15.200
We don't have them yet.

00:27:15.200 --> 00:27:17.540
So if you wanted to
look at the code for it,

00:27:17.540 --> 00:27:20.460
you can
initializeTestWorkManager.

00:27:20.460 --> 00:27:23.300
You can get the TestDriver.

00:27:23.300 --> 00:27:25.490
Create and enqueue your
work as you normally would,

00:27:25.490 --> 00:27:27.170
with a constraint, in this case.

00:27:27.170 --> 00:27:29.270
And we can tell the
TestDriver, hey,

00:27:29.270 --> 00:27:32.400
all constraints are
met for this work.

00:27:32.400 --> 00:27:34.400
Your work executes at
that point, synchronously,

00:27:34.400 --> 00:27:35.900
and you can verify
the state of your app

00:27:35.900 --> 00:27:37.524
and make sure that
everything is right.

00:27:40.692 --> 00:27:42.900
I also want to talk a little
bit about best practices

00:27:42.900 --> 00:27:46.220
before I end here.

00:27:46.220 --> 00:27:49.430
It's very important to know
when to use WorkManager.

00:27:49.430 --> 00:27:52.930
WorkManager is for tasks that
can survive process death.

00:27:52.930 --> 00:27:55.970
It can even wake up your
app and your app's process

00:27:55.970 --> 00:27:58.410
to do the work.

00:27:58.410 --> 00:28:01.490
So for example, it's OK when you
want to use it to upload media

00:28:01.490 --> 00:28:03.180
to a server.

00:28:03.180 --> 00:28:05.390
It's also OK when you want
to parse data and store it

00:28:05.390 --> 00:28:07.410
in your database.

00:28:07.410 --> 00:28:10.050
It's not OK for that
example I gave earlier.

00:28:10.050 --> 00:28:12.440
You're extracting the
palette color from an image

00:28:12.440 --> 00:28:15.250
and updating an image view
with it, because that's

00:28:15.250 --> 00:28:16.580
foreground only work.

00:28:16.580 --> 00:28:19.042
It's also not OK when you're
parsing data and just updating

00:28:19.042 --> 00:28:20.000
the contents of a view.

00:28:20.000 --> 00:28:21.270
Because you could
switch screens.

00:28:21.270 --> 00:28:22.561
You could go in the background.

00:28:22.561 --> 00:28:25.910
It's not work that needs
to use WorkManager.

00:28:25.910 --> 00:28:28.520
It doesn't need to
survive process death.

00:28:28.520 --> 00:28:31.310
Also, it's not OK to process
payment transactions in it

00:28:31.310 --> 00:28:33.620
if they care about
timing right then.

00:28:33.620 --> 00:28:36.080
So if you click
buy, and you want

00:28:36.080 --> 00:28:39.590
to update the state of
the app, that really

00:28:39.590 --> 00:28:40.670
needs something else.

00:28:40.670 --> 00:28:42.950
So that last one needs
a foreground service.

00:28:42.950 --> 00:28:45.275
The other two may just
use thread pools or Rx.

00:28:50.090 --> 00:28:53.660
Also, WorkManager is
not your data store.

00:28:53.660 --> 00:28:56.390
Instances of data are
limited to 10 kilobytes each

00:28:56.390 --> 00:28:57.670
when serialized.

00:28:57.670 --> 00:29:00.920
So data is really meant
for light, intermediate

00:29:00.920 --> 00:29:03.320
transportation of information.

00:29:03.320 --> 00:29:06.680
You can put file URIs or keys
to other databases in there

00:29:06.680 --> 00:29:07.650
if you want.

00:29:07.650 --> 00:29:11.270
You can put simple
information to update your UI.

00:29:11.270 --> 00:29:13.430
If you want to use
a full data store,

00:29:13.430 --> 00:29:15.040
I would recommend using Room.

00:29:15.040 --> 00:29:17.240
Yit would be very happy
that I'm saying this.

00:29:17.240 --> 00:29:20.830
It's an awesome database.

00:29:20.830 --> 00:29:22.930
Finally, be opportunistic
with your work.

00:29:22.930 --> 00:29:28.000
So here's a filter compress
upload example again.

00:29:28.000 --> 00:29:30.630
The reason that these
are not just one big job

00:29:30.630 --> 00:29:32.880
is because they all have
different constraints.

00:29:32.880 --> 00:29:35.280
So they can execute
at different times.

00:29:35.280 --> 00:29:36.960
Let's say, I'm getting
on an airplane,

00:29:36.960 --> 00:29:39.420
and I'm uploading
a bunch of images

00:29:39.420 --> 00:29:41.430
and running this chain of work.

00:29:41.430 --> 00:29:42.690
Well, I go into airplane mode.

00:29:42.690 --> 00:29:45.000
Maybe I don't have network
for the next 12 hours

00:29:45.000 --> 00:29:46.990
because I'm flying
across the world.

00:29:46.990 --> 00:29:50.130
Well, the other work can
still execute, and it should.

00:29:50.130 --> 00:29:53.347
So if you architect like
this, you can do that.

00:29:53.347 --> 00:29:55.680
This also, by the way, makes
your code a little bit more

00:29:55.680 --> 00:29:57.480
testable because
you can write a test

00:29:57.480 --> 00:30:00.154
for filtering that
isn't conflated

00:30:00.154 --> 00:30:01.320
with compression and upload.

00:30:04.380 --> 00:30:08.130
All right, and I want to talk
about a few next steps for you.

00:30:08.130 --> 00:30:11.460
If you need to reach us and
talk to us about WorkManager,

00:30:11.460 --> 00:30:14.310
we are in the Android
Sandbox, just behind us,

00:30:14.310 --> 00:30:17.060
I think, over here.

00:30:17.060 --> 00:30:21.210
D.android.com/arch/work,
that's more information

00:30:21.210 --> 00:30:25.135
on the official developer
website about WorkManager.

00:30:25.135 --> 00:30:26.760
These are all the
greater dependencies.

00:30:26.760 --> 00:30:28.410
The first one's a required one.

00:30:28.410 --> 00:30:31.380
The second one is if you use
Firebase JobDispatcher, also

00:30:31.380 --> 00:30:32.577
include that.

00:30:32.577 --> 00:30:34.410
There's a testing
library, and of course, we

00:30:34.410 --> 00:30:35.730
have Kotlin extensions as well.

00:30:38.410 --> 00:30:41.240
WorkManager is part of the
architectural components

00:30:41.240 --> 00:30:43.210
in Android Jetpack.

00:30:43.210 --> 00:30:46.210
And we have a bunch of
talks here tomorrow,

00:30:46.210 --> 00:30:48.850
Navigation Controller, 8:30 AM.

00:30:48.850 --> 00:30:51.780
Hope you guys make it there.

00:30:51.780 --> 00:30:55.020
And thanks for being
part of this talk.

00:30:55.020 --> 00:30:56.950
We look forward to hearing
back from you soon.

00:30:56.950 --> 00:30:57.564
Thank you.

00:30:57.564 --> 00:31:02.132
[MUSIC PLAYING]

