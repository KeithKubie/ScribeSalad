WEBVTT
Kind: captions
Language: en

00:00:03.400 --> 00:00:07.000
PATRICK DUBROY: Hi everybody,
my name's Patrick Dubroy and

00:00:07.000 --> 00:00:08.600
today I'm going to talk
to you about memory

00:00:08.600 --> 00:00:10.580
management for Android.

00:00:10.580 --> 00:00:13.330
So I'm really happy to see so
many people here who care

00:00:13.330 --> 00:00:15.550
about memory management,
especially near

00:00:15.550 --> 00:00:18.500
the end of the day.

00:00:18.500 --> 00:00:21.210
So let's get started.

00:00:21.210 --> 00:00:23.080
So I'm sure you all remember
this device.

00:00:23.080 --> 00:00:25.490
This is the T-Mobile G1.

00:00:25.490 --> 00:00:28.400
Hugo talked about it in
the keynote yesterday.

00:00:28.400 --> 00:00:31.110
It was released about two
and a half years ago.

00:00:31.110 --> 00:00:35.650
So, is there anybody here who
actually developed on the G1?

00:00:35.650 --> 00:00:36.540
All right, impressive.

00:00:36.540 --> 00:00:40.050
That's about maybe
40% of the room.

00:00:40.050 --> 00:00:43.240
So you may remember that
the G1 came with 192

00:00:43.240 --> 00:00:45.010
megabytes of RAM.

00:00:45.010 --> 00:00:48.420
And in fact, most of that was
used up by the system.

00:00:48.420 --> 00:00:52.100
There wasn't a whole lot
left over for apps.

00:00:52.100 --> 00:00:55.300
Fast forward a few years later,
we have the Motorola

00:00:55.300 --> 00:00:58.180
Zoom released just a couple
of months ago.

00:00:58.180 --> 00:01:01.780
The Zoom comes with
a gigabyte of RAM.

00:01:01.780 --> 00:01:04.209
Now some people might hear
this and think, OK, my

00:01:04.209 --> 00:01:05.019
troubles are over.

00:01:05.019 --> 00:01:08.170
I never have to worry about
memory management again.

00:01:08.170 --> 00:01:11.730
And of course, given that we
have a whole room here, you

00:01:11.730 --> 00:01:13.230
guys are all smart people
and you realize

00:01:13.230 --> 00:01:15.940
that that's not true.

00:01:15.940 --> 00:01:17.950
And there are a couple
of reasons for this.

00:01:17.950 --> 00:01:21.940
First of all, the Zoom has
six and a half times the

00:01:21.940 --> 00:01:24.005
resolution that the G1 had.

00:01:24.005 --> 00:01:25.590
So you've got six and
a half times as

00:01:25.590 --> 00:01:27.500
many pixels on screen.

00:01:27.500 --> 00:01:28.540
That means you're probably
going to

00:01:28.540 --> 00:01:30.140
need to use more memory.

00:01:30.140 --> 00:01:34.110
You got more bitmaps
for example.

00:01:34.110 --> 00:01:36.470
The other thing is that on
tablets, you really want to

00:01:36.470 --> 00:01:40.300
create a new kind
of application.

00:01:40.300 --> 00:01:43.440
You know, the rich, immersive
applications, like this

00:01:43.440 --> 00:01:46.330
YouTube app, for example.

00:01:46.330 --> 00:01:47.940
These are going to take
a lot of memory.

00:01:47.940 --> 00:01:49.940
There's tons of bitmaps
in here.

00:01:49.940 --> 00:01:53.140
Those use up a lot of memory.

00:01:53.140 --> 00:01:56.600
Also, the Zoom we're talking
about a pretty new device.

00:01:56.600 --> 00:01:59.280
This is basically bleeding
edge hardware.

00:01:59.280 --> 00:02:01.560
Most your customers are not
going to be using something

00:02:01.560 --> 00:02:03.280
that's only two months old.

00:02:03.280 --> 00:02:05.750
So of course, you want to
support people who are using

00:02:05.750 --> 00:02:09.389
older hardware as well.

00:02:09.389 --> 00:02:13.270
Finally, maybe you're all
familiar with Parkinson's Law,

00:02:13.270 --> 00:02:17.070
which says that work always take
as much time as you have.

00:02:17.070 --> 00:02:21.400
And really, it's kind of
the same for software.

00:02:21.400 --> 00:02:23.880
So, no matter how much memory
you have, you're going to find

00:02:23.880 --> 00:02:26.510
a way to use it and wish you
had just a little bit more.

00:02:31.760 --> 00:02:34.860
What I want to talk about
today are basically two

00:02:34.860 --> 00:02:36.500
different things.

00:02:36.500 --> 00:02:38.870
First of all, I want to cover
some of the changes that we've

00:02:38.870 --> 00:02:41.890
made in Gingerbread and
Honeycomb that affect how your

00:02:41.890 --> 00:02:43.140
app uses memory.

00:02:58.480 --> 00:02:59.730
That's your cameo.

00:03:02.910 --> 00:03:06.130
All right, so as I was saying,
there are two different things

00:03:06.130 --> 00:03:07.650
I want to cover today.

00:03:07.650 --> 00:03:10.020
So first of all, I want to talk
about some of the changes

00:03:10.020 --> 00:03:13.240
we've made in Gingerbread and
Honeycomb that affect how your

00:03:13.240 --> 00:03:14.750
apps use memory.

00:03:14.750 --> 00:03:18.400
And basically, memory management
in general.

00:03:18.400 --> 00:03:20.890
In the second half of the talk
I want to talk about some

00:03:20.890 --> 00:03:24.200
tools you can use to better
understand how your app is

00:03:24.200 --> 00:03:25.420
using memory.

00:03:25.420 --> 00:03:28.340
And if you have memory leaks,
how you can figure out where

00:03:28.340 --> 00:03:31.570
those memory leaks are.

00:03:31.570 --> 00:03:35.160
So just to set expectations for
this talk, I'm going to

00:03:35.160 --> 00:03:39.320
make them some assumptions about
the stuff you've done

00:03:39.320 --> 00:03:42.470
and it'll really help you get
the most out of this if you're

00:03:42.470 --> 00:03:44.530
familiar with these concepts.

00:03:44.530 --> 00:03:47.270
So I'm hoping that you've all
written Android apps before.

00:03:47.270 --> 00:03:50.150
And it looked like about half
the room had developed on the

00:03:50.150 --> 00:03:54.050
G1, so that's probably true.

00:03:54.050 --> 00:03:56.960
I hope that most of you have
heard of the Dalvik heap.

00:03:56.960 --> 00:03:59.350
You have a basic idea of what
I'm talking about when I talk

00:03:59.350 --> 00:04:01.690
about heap memory.

00:04:01.690 --> 00:04:04.360
I'm sure you're familiar with
the garbage collector.

00:04:04.360 --> 00:04:06.860
You have a basic idea hopefully
of what garbage

00:04:06.860 --> 00:04:09.070
collection is and
how it works.

00:04:09.070 --> 00:04:11.960
And probably, most of you have
seen an OutOfMememoryError

00:04:11.960 --> 00:04:15.400
before and you have a basic
idea of why you get it and

00:04:15.400 --> 00:04:16.790
what you can do to
deal with it.

00:04:19.730 --> 00:04:22.590
So first, let's talk
about heap size.

00:04:22.590 --> 00:04:26.250
So you may know that in Android,
there's a hard limit

00:04:26.250 --> 00:04:28.896
on your application's
heap size.

00:04:28.896 --> 00:04:31.140
And there's a couple
reasons for this.

00:04:31.140 --> 00:04:34.596
So first of all, one of the
great features of Android is

00:04:34.596 --> 00:04:36.870
that it has full multitasking.

00:04:36.870 --> 00:04:40.160
So you actually have multiple
programs running at once.

00:04:40.160 --> 00:04:43.055
And so obviously, each
one can't use all of

00:04:43.055 --> 00:04:45.360
your devices memory.

00:04:45.360 --> 00:04:49.000
We also don't want a runaway
app to just start getting

00:04:49.000 --> 00:04:51.760
bigger and bigger and bloating
the entire system.

00:04:51.760 --> 00:04:54.830
You always want your dialer to
work, your launcher t work,

00:04:54.830 --> 00:04:57.610
that sort of thing.

00:04:57.610 --> 00:05:00.800
So there's this hard limit
on heap size and if your

00:05:00.800 --> 00:05:04.470
application needs to allocate
more memory and you've gone up

00:05:04.470 --> 00:05:06.540
to that heap size limit already,
then you're basically

00:05:06.540 --> 00:05:09.730
going to get an out
of memory error.

00:05:09.730 --> 00:05:12.710
So this heap size limit
is device dependent.

00:05:12.710 --> 00:05:14.500
It's changed a lot
over the years.

00:05:14.500 --> 00:05:18.040
On the G1 it was 16 megabytes.

00:05:18.040 --> 00:05:20.380
On the Zoom it's now
48 megabytes.

00:05:20.380 --> 00:05:22.890
So it's a little bit bigger.

00:05:22.890 --> 00:05:25.360
If you're writing an app and you
want to know, OK, how much

00:05:25.360 --> 00:05:26.850
heap space do I have
available?

00:05:26.850 --> 00:05:29.945
You know, maybe you want to
decide how much stuff to keep

00:05:29.945 --> 00:05:32.480
in a cache for example.

00:05:32.480 --> 00:05:35.170
There's a method you can
use in ActivityManager,

00:05:35.170 --> 00:05:38.040
getMemoryClass that will return
an integer value in

00:05:38.040 --> 00:05:42.570
megabytes, which is
your heap size.

00:05:42.570 --> 00:05:46.780
Now these limits were designed
assuming that you know almost

00:05:46.780 --> 00:05:49.160
any app that you would want to
build on Android should be

00:05:49.160 --> 00:05:51.860
able to fit under
these limits.

00:05:51.860 --> 00:05:53.440
Of course, there are
some apps that are

00:05:53.440 --> 00:05:56.920
really memory intensive.

00:05:56.920 --> 00:05:59.950
And as I said, on the tablet, we
really want to build almost

00:05:59.950 --> 00:06:01.430
a new class of application.

00:06:01.430 --> 00:06:04.050
It's quite a different than the
kind of things you were

00:06:04.050 --> 00:06:06.550
building on phones.

00:06:06.550 --> 00:06:08.750
So we thought, if someone
wants to build an image

00:06:08.750 --> 00:06:11.140
editor, for example, on
the Zoom, they should

00:06:11.140 --> 00:06:12.400
be able to do that.

00:06:12.400 --> 00:06:16.050
But an image editor's a really
memory intensive application.

00:06:16.050 --> 00:06:18.590
It's unlikely that you could
build a good one that used

00:06:18.590 --> 00:06:21.536
less than 48 megabytes
of heap.

00:06:21.536 --> 00:06:25.380
So in Honeycomb we've added
a new option that allows

00:06:25.380 --> 00:06:29.440
applications like this to
get a larger heap size.

00:06:29.440 --> 00:06:30.950
Basically, , you can put
something in your

00:06:30.950 --> 00:06:34.510
AndroidManifest, largeHeap
equals true.

00:06:34.510 --> 00:06:38.400
And that will allow your
application to use more heap.

00:06:38.400 --> 00:06:42.790
And similarly, there's a
method you can use to

00:06:42.790 --> 00:06:45.390
determine how much memory you
have available to you.

00:06:45.390 --> 00:06:48.100
The ActivityManager
getLargeMemoryClass method

00:06:48.100 --> 00:06:53.140
again, will return an integer
value of this large heap size.

00:06:53.140 --> 00:06:55.570
Now before we go any further,
I want to give

00:06:55.570 --> 00:06:57.490
a big warning here.

00:06:57.490 --> 00:06:59.430
You know, this is not something
you should be doing

00:06:59.430 --> 00:07:02.630
just because you got an out of
memory error, or you think

00:07:02.630 --> 00:07:05.160
that your app deserves
a bigger heap.

00:07:05.160 --> 00:07:08.130
You're not going to be doing
yourself any favors because

00:07:08.130 --> 00:07:11.480
your app is going to perform
more poorly because bigger

00:07:11.480 --> 00:07:13.270
heap means you're going to spend
more time at garbage

00:07:13.270 --> 00:07:14.530
collection.

00:07:14.530 --> 00:07:17.040
Also, your users are probably
going to notice because all

00:07:17.040 --> 00:07:20.450
their other apps are getting
kicked out of memory.

00:07:20.450 --> 00:07:23.620
It's really something you want
to reserve for when you really

00:07:23.620 --> 00:07:27.360
understand OK, I'm using tons
of memory and I know exactly

00:07:27.360 --> 00:07:29.050
why I'm using that memory,
and I really

00:07:29.050 --> 00:07:30.510
need to use that memory.

00:07:30.510 --> 00:07:32.710
That's the only time that you
should be using this large

00:07:32.710 --> 00:07:33.960
heap option.

00:07:38.450 --> 00:07:40.920
So I mentioned garbage
collection.

00:07:40.920 --> 00:07:45.126
And that it takes longer when
you have a bigger heap.

00:07:45.126 --> 00:07:47.940
Let's talk a little bit about
garbage collection.

00:07:47.940 --> 00:07:51.160
So I just want to go through a
quick explanation here of what

00:07:51.160 --> 00:07:52.180
[INAUDIBLE]

00:07:52.180 --> 00:07:55.540
garbage collection is doing.

00:07:55.540 --> 00:07:58.390
So basically, you have
a set of objects.

00:07:58.390 --> 00:08:01.190
First of all, let's say these
blue objects here, these are

00:08:01.190 --> 00:08:02.950
the objects in your heap.

00:08:02.950 --> 00:08:04.590
And they form a kind of graph.

00:08:04.590 --> 00:08:07.940
They've got references
to each other.

00:08:07.940 --> 00:08:09.920
Some of those objects are alive,
some of them are not

00:08:09.920 --> 00:08:11.190
used anymore.

00:08:11.190 --> 00:08:13.970
So what the GC does is it starts
from a set of objects

00:08:13.970 --> 00:08:15.440
that we call the roots.

00:08:15.440 --> 00:08:18.890
These are the objects that
the GC knows is alive.

00:08:18.890 --> 00:08:23.705
For example, variables that are
alive on a thread stack, J

00:08:23.705 --> 00:08:28.860
and I global references, we
treat objects in the zygote as

00:08:28.860 --> 00:08:31.670
heap, or as roots as well.

00:08:31.670 --> 00:08:35.460
So basically, the GC starts with
those objects and starts

00:08:35.460 --> 00:08:37.830
visiting the other objects.

00:08:37.830 --> 00:08:40.450
And basically, traversing
through the whole graph to

00:08:40.450 --> 00:08:43.169
find out which objects are
referenced directly or

00:08:43.169 --> 00:08:46.220
indirectly from the GC roots.

00:08:46.220 --> 00:08:48.990
At the end of this process,
you've got some objects left

00:08:48.990 --> 00:08:51.720
over, which the GC
never visited.

00:08:51.720 --> 00:08:53.260
Those are your garbage.

00:08:53.260 --> 00:08:55.090
They can be collected.

00:08:55.090 --> 00:08:57.650
So it's a pretty
simple concept.

00:08:57.650 --> 00:09:00.720
And you can see why when I
said that you have bigger

00:09:00.720 --> 00:09:03.840
heaps you're going to have
larger pause times.

00:09:03.840 --> 00:09:07.530
Because the garbage collector
basically has to traverse your

00:09:07.530 --> 00:09:10.940
entire live set of objects.

00:09:10.940 --> 00:09:14.850
If you're using say the large
heap option and you've got 256

00:09:14.850 --> 00:09:17.470
megs of heap, well, that's a lot
of memory for the garbage

00:09:17.470 --> 00:09:18.510
collector to walk over.

00:09:18.510 --> 00:09:22.370
You're going to see longer
pause times with that.

00:09:22.370 --> 00:09:24.280
We have some good news though.

00:09:24.280 --> 00:09:27.690
In Gingerbread, there have been
some great changes to the

00:09:27.690 --> 00:09:30.880
garbage collector that make
things a lot better.

00:09:30.880 --> 00:09:32.590
So in Gingerbre--

00:09:32.590 --> 00:09:35.610
sorry, pre-Gingerbread, the
state of the garbage collector

00:09:35.610 --> 00:09:37.902
was that we had to stop
the world collector.

00:09:37.902 --> 00:09:40.880
So what this means is that
basically, when a garbage

00:09:40.880 --> 00:09:44.510
collection is in progress, your
application is stopped.

00:09:44.510 --> 00:09:47.530
All your application threads are
completely stopped while

00:09:47.530 --> 00:09:49.060
the collection is proceeding.

00:09:49.060 --> 00:09:50.380
This is a pretty standard
things.

00:09:50.380 --> 00:09:53.895
These pauses generally tend
to be pretty short.

00:09:53.895 --> 00:09:57.220
What we found was that pause
times as heaps were getting

00:09:57.220 --> 00:10:00.440
bigger, these were getting to
be a little bit too long.

00:10:00.440 --> 00:10:04.480
So we were seeing stuff up
50 to 100 milliseconds.

00:10:04.480 --> 00:10:07.510
And if you're trying to build
a really responsive app that

00:10:07.510 --> 00:10:11.350
kind of pause time is not
really acceptable.

00:10:11.350 --> 00:10:13.580
So in Gingerbread,
we now have a

00:10:13.580 --> 00:10:15.350
concurrent garbage collector.

00:10:15.350 --> 00:10:18.230
It does most of its work
concurrently, which means that

00:10:18.230 --> 00:10:21.275
your application is not stopped
for the duration of

00:10:21.275 --> 00:10:22.610
the garbage collection.

00:10:22.610 --> 00:10:24.510
Basically, we have another
thread that's running at the

00:10:24.510 --> 00:10:27.420
same time as your application
that can perform garbage

00:10:27.420 --> 00:10:29.200
collection work.

00:10:29.200 --> 00:10:31.740
You'll see basically
two short pauses.

00:10:31.740 --> 00:10:33.590
One at the beginning
of a collection and

00:10:33.590 --> 00:10:35.260
one near the end.

00:10:35.260 --> 00:10:37.820
But these pause times are going
to be much, much lower.

00:10:37.820 --> 00:10:41.930
Usually you'll see two, three,
four, or five milliseconds for

00:10:41.930 --> 00:10:43.180
your pause time.

00:10:43.180 --> 00:10:45.140
So that's a significant
improvement.

00:10:45.140 --> 00:10:48.610
Pause times about 10% of
what they used to be.

00:10:48.610 --> 00:10:52.770
So that's a really good change
that we have in Gingerbread.

00:10:52.770 --> 00:10:55.000
Now if you're building memory
heavy apps, there's a good

00:10:55.000 --> 00:10:57.350
chance you're using
a lot of bitmaps.

00:10:57.350 --> 00:11:01.060
We found that in a lot of apps
you have maybe 50 or 75% of

00:11:01.060 --> 00:11:04.120
your heap is taken
up by bitmaps.

00:11:04.120 --> 00:11:06.840
And in Honeycomb because you're
going to be developing

00:11:06.840 --> 00:11:09.230
on tablets, this gets
even worse.

00:11:09.230 --> 00:11:14.820
Because your images are bigger
to fill the screen.

00:11:14.820 --> 00:11:19.170
So before Honeycomb, the way we
managed bitmaps was this.

00:11:19.170 --> 00:11:23.250
So the blue area up here is
the Dalvik heap and this

00:11:23.250 --> 00:11:25.820
yellow object is a
bitmap object.

00:11:25.820 --> 00:11:29.250
Now bitmap objects are always
the same size in the heap no

00:11:29.250 --> 00:11:31.750
matter what their
resolution is.

00:11:31.750 --> 00:11:34.240
The backing memory for the
bitmap is actually stored in

00:11:34.240 --> 00:11:35.780
another object.

00:11:35.780 --> 00:11:39.090
So the pixel data is
stored separately.

00:11:39.090 --> 00:11:42.250
Now before Honeycomb what we
did was this pixel data was

00:11:42.250 --> 00:11:43.480
actually native memory.

00:11:43.480 --> 00:11:47.860
It was allocated using malloc
outside the Dalvik heap.

00:11:47.860 --> 00:11:49.875
And this had a few
consequences.

00:11:49.875 --> 00:11:52.430
If you wanted to free this
memory you could either call

00:11:52.430 --> 00:11:56.510
recycle, which would free the
memory synchronously.

00:11:56.510 --> 00:11:58.610
But if you didn't call recycle
and you were waiting for your

00:11:58.610 --> 00:12:01.340
bitmap to get garbage collected,
we had to rely on

00:12:01.340 --> 00:12:05.070
the finalizer to free the
backing memory for the bitmap.

00:12:05.070 --> 00:12:07.330
And if you're familiar with
finalization, you probably

00:12:07.330 --> 00:12:10.580
know that it's an inherently
unreliable process.

00:12:10.580 --> 00:12:15.030
Just by its nature it takes
several collections, usually

00:12:15.030 --> 00:12:17.470
for finalization to complete.

00:12:17.470 --> 00:12:20.280
So this can cause problems with
bitmap heavy app as you

00:12:20.280 --> 00:12:23.020
had to wait for several garbage
collections before

00:12:23.020 --> 00:12:25.110
your pixel data was reclaimed.

00:12:25.110 --> 00:12:27.380
And this could be a lot of
memory because bitmap pixel

00:12:27.380 --> 00:12:32.080
data is quite a significant
portion of the heap.

00:12:32.080 --> 00:12:33.920
This also made things
harder to debug.

00:12:33.920 --> 00:12:37.140
If you were using standard
memory analysis tools like the

00:12:37.140 --> 00:12:40.690
Eclipse Memory Analyzer, it
couldn't actually see this

00:12:40.690 --> 00:12:41.230
native memory.

00:12:41.230 --> 00:12:43.390
You would see this tiny
bitmap object.

00:12:43.390 --> 00:12:45.190
Sure, but that doesn't
tell you very much.

00:12:45.190 --> 00:12:47.880
You don't mind if you have
a 10 by 10 bitmap.

00:12:47.880 --> 00:12:52.580
But if you have a 512 by 512
bitmap it's a big difference.

00:12:52.580 --> 00:12:55.010
Finally, the other problem that
we had with this approach

00:12:55.010 --> 00:12:58.180
was that it required full stop
the world garbage collections

00:12:58.180 --> 00:13:01.580
in order to reclaim the backing
memory, assuming that

00:13:01.580 --> 00:13:04.740
you didn't call recycle,
that is.

00:13:04.740 --> 00:13:06.590
The good news is in Honeycomb
we've changed

00:13:06.590 --> 00:13:07.820
the way this works.

00:13:07.820 --> 00:13:11.080
And the bitmap pixel data is
now allocated inside the

00:13:11.080 --> 00:13:12.310
Dalvik heap.

00:13:12.310 --> 00:13:15.780
So this means it can be freed
synchronously by the GC on the

00:13:15.780 --> 00:13:18.690
same cycle that your bitmap
gets collected.

00:13:18.690 --> 00:13:21.360
It's also easier to debug
because you can see this

00:13:21.360 --> 00:13:24.950
backing memory in standard
analysis tools like Eclipse

00:13:24.950 --> 00:13:25.962
Memory Analyzer.

00:13:25.962 --> 00:13:28.870
And I'm going to do a demo in
a few minutes and you'll see

00:13:28.870 --> 00:13:31.520
really, how much more useful
this is when you

00:13:31.520 --> 00:13:33.820
can see that memory.

00:13:33.820 --> 00:13:37.340
Finally, this strategy is more
amenable to concurrent and

00:13:37.340 --> 00:13:40.570
partial garbage collections,
which means we can generally

00:13:40.570 --> 00:13:42.160
keep those pause times down.

00:13:44.850 --> 00:13:47.100
So those are the two biggest
changes that we've introduced

00:13:47.100 --> 00:13:49.480
in Gingerbread and Honeycomb
that affect how

00:13:49.480 --> 00:13:51.600
your apps use memory.

00:13:51.600 --> 00:13:54.950
And now I want to dive in to
some tools that you can use to

00:13:54.950 --> 00:13:58.180
better understand how much
memory your app's using.

00:13:58.180 --> 00:14:02.250
And if you have memory leaks,
better understanding where

00:14:02.250 --> 00:14:05.400
those leaks are and generally,
how your app is using memory.

00:14:07.970 --> 00:14:10.360
The most basic tool you can
use for understanding your

00:14:10.360 --> 00:14:14.240
apps memory usage is to look
at your log messages.

00:14:14.240 --> 00:14:18.230
So these are the log messages
that you see in DDMS in the

00:14:18.230 --> 00:14:20.100
log cat view.

00:14:20.100 --> 00:14:21.760
You can also see them
at the command line

00:14:21.760 --> 00:14:24.610
using ADB log cat.

00:14:24.610 --> 00:14:26.610
And every time a garbage
collection happens in your

00:14:26.610 --> 00:14:29.520
process, you're going to see a
message that looks something

00:14:29.520 --> 00:14:30.490
like this one.

00:14:30.490 --> 00:14:32.570
And I just want to go through
the different parts of this

00:14:32.570 --> 00:14:34.630
message, so you can better
understand what

00:14:34.630 --> 00:14:37.300
it's telling you.

00:14:37.300 --> 00:14:39.830
The first thing we have is the
reason for the garbage

00:14:39.830 --> 00:14:40.800
collection.

00:14:40.800 --> 00:14:44.830
Kind of what triggered it and
what kind of collection is it.

00:14:44.830 --> 00:14:47.700
This one here was a concurrent
collection.

00:14:47.700 --> 00:14:53.400
So a concurrent collection is
triggered by basically, as

00:14:53.400 --> 00:14:56.690
your heap starts to fill up,
we kick off our concurrent

00:14:56.690 --> 00:14:59.960
garbage collection so that it
can hopefully complete before

00:14:59.960 --> 00:15:02.600
your heap gets full.

00:15:02.600 --> 00:15:04.300
Other kinds of collections
that you'll

00:15:04.300 --> 00:15:06.110
see in the log messages.

00:15:06.110 --> 00:15:08.420
GC for malloc is one of them.

00:15:08.420 --> 00:15:11.210
That's what happens when say,
we didn't complete the

00:15:11.210 --> 00:15:14.020
concurrent collection in time
and your application had to

00:15:14.020 --> 00:15:15.350
allocate more memory.

00:15:15.350 --> 00:15:17.610
The heap was full, so we had
to stop and do a garbage

00:15:17.610 --> 00:15:19.580
collection.

00:15:19.580 --> 00:15:23.060
You'll see GC external alloc,
which is for externally

00:15:23.060 --> 00:15:24.970
allocated memory, like
the bitmap pixel

00:15:24.970 --> 00:15:26.400
data which I mentioned.

00:15:26.400 --> 00:15:29.616
It's also used for NIO
direct byte buffers.

00:15:29.616 --> 00:15:32.080
Now this external memory
as I mentioned, has

00:15:32.080 --> 00:15:33.190
gone away in Honeycomb.

00:15:33.190 --> 00:15:34.950
Basically everything
is allocated inside

00:15:34.950 --> 00:15:35.920
the Dalvik heap now.

00:15:35.920 --> 00:15:38.600
So you won't see this in
your log messages in

00:15:38.600 --> 00:15:41.610
Honeycomb and later.

00:15:41.610 --> 00:15:46.630
You'll also see a message if you
do an HPROF, if you create

00:15:46.630 --> 00:15:48.810
an HPROF profile.

00:15:48.810 --> 00:15:50.000
And finally, the last
one I want to

00:15:50.000 --> 00:15:52.340
mention is GC explicit.

00:15:52.340 --> 00:15:56.930
You'll see this generally when
you're calling system.gc,

00:15:56.930 --> 00:15:58.520
which is something that
you know you really

00:15:58.520 --> 00:16:00.240
should avoid doing.

00:16:00.240 --> 00:16:02.400
In general, you should trust
in the garbage collector.

00:16:05.080 --> 00:16:07.060
We've got some information
also about the amount of

00:16:07.060 --> 00:16:08.565
memory that was freed
on this collection.

00:16:11.620 --> 00:16:13.880
There's some statistics
about the heap.

00:16:13.880 --> 00:16:17.330
So the heap in this case,
was 65% free after

00:16:17.330 --> 00:16:19.210
the collection completed.

00:16:19.210 --> 00:16:22.320
There's about three and a half
megs of live objects and the

00:16:22.320 --> 00:16:24.720
total heap size here
is listed as well.

00:16:24.720 --> 00:16:29.460
It's almost 10 megs, 9,991 K.

00:16:29.460 --> 00:16:32.912
There's some information about
externally allocated memory,

00:16:32.912 --> 00:16:35.450
which is the bitmap pixel
data and also,

00:16:35.450 --> 00:16:38.530
NIO direct byte buffers.

00:16:38.530 --> 00:16:41.710
The two numbers here, the first
number is the amount of

00:16:41.710 --> 00:16:44.380
external memory that your
app has allocated.

00:16:44.380 --> 00:16:47.420
The second number is a
sort of soft limit.

00:16:47.420 --> 00:16:49.430
When you've allocated that much
memory, we're going to

00:16:49.430 --> 00:16:50.680
kick off a GC.

00:16:52.830 --> 00:16:55.920
Finally, you'll see the pause
times for that collection.

00:16:55.920 --> 00:16:57.790
And this is where you're
going to see the effect

00:16:57.790 --> 00:16:59.320
of your heap size.

00:16:59.320 --> 00:17:02.540
Larger heaps are going to
have larger pause times.

00:17:02.540 --> 00:17:04.560
The good news is for a
concurrent collection, you're

00:17:04.560 --> 00:17:07.710
going to see these pause times
generally pretty low.

00:17:07.710 --> 00:17:11.470
Concurrent collections are going
to show two pause times.

00:17:11.470 --> 00:17:13.670
There's one short pause at the
beginning of the collection

00:17:13.670 --> 00:17:16.160
and one most of the
way through.

00:17:16.160 --> 00:17:18.390
Non-concurrent collections
you'll see a single pause

00:17:18.390 --> 00:17:19.630
time, and this is generally
going to

00:17:19.630 --> 00:17:23.480
be quite a bit higher.

00:17:23.480 --> 00:17:25.840
So looking at your log messages
is a really basic way

00:17:25.840 --> 00:17:28.580
to understand how much memory
your app is using.

00:17:28.580 --> 00:17:31.035
But it doesn't really
tell you, where am

00:17:31.035 --> 00:17:31.820
I using that memory?

00:17:31.820 --> 00:17:34.870
What objects are using
this memory?

00:17:34.870 --> 00:17:39.120
And the best way to do that
is using heap dumps.

00:17:39.120 --> 00:17:42.610
So a heap dump is basically a
binary file that contains

00:17:42.610 --> 00:17:46.510
information about all of the
objects in your heap.

00:17:46.510 --> 00:17:51.040
You can create a heap dump using
DDMS by clicking on the

00:17:51.040 --> 00:17:54.470
icon, this somewhat
cryptic icon.

00:17:54.470 --> 00:17:55.040
I think [INAUDIBLE]

00:17:55.040 --> 00:17:58.300
mentioned it in the
previous talk.

00:17:58.300 --> 00:18:01.200
There's also an API for
creating heap dumps.

00:18:01.200 --> 00:18:04.890
In general, I find using
DDMS is fine.

00:18:04.890 --> 00:18:06.830
There are times when you want
to create a heap dump at a

00:18:06.830 --> 00:18:09.250
very, very specific
point in time.

00:18:09.250 --> 00:18:11.500
Maybe when you're trying to
track down a memory leak.

00:18:11.500 --> 00:18:15.160
So it can be helpful
to use that API.

00:18:15.160 --> 00:18:18.190
You may need to convert the
heap dump to the standard

00:18:18.190 --> 00:18:19.310
HPROF format.

00:18:19.310 --> 00:18:21.960
You'll only need to do that if
you're using the standalone

00:18:21.960 --> 00:18:26.610
version of DDMS. If you're using
the Eclipse plug-in, the

00:18:26.610 --> 00:18:30.650
ADT plug-in, it will
automatically convert it.

00:18:30.650 --> 00:18:31.840
But the conversion
is pretty simple.

00:18:31.840 --> 00:18:34.080
There's a tool in the Android
SDK, which you

00:18:34.080 --> 00:18:35.740
can use to do it.

00:18:35.740 --> 00:18:38.780
And after you've converted it to
the standard HPROF format,

00:18:38.780 --> 00:18:41.950
you can analyze it with standard
heap analysis tools,

00:18:41.950 --> 00:18:46.120
like MAT or jhat.

00:18:46.120 --> 00:18:50.290
And I'm going to show an example
of MAT, which is the

00:18:50.290 --> 00:18:54.090
shorter way of saying the
Eclipse Memory Analyzer.

00:18:54.090 --> 00:18:56.300
And before I jump into the demo,
I want to talk about

00:18:56.300 --> 00:18:58.600
memory leaks.

00:18:58.600 --> 00:19:01.370
So there's kind of a
misconception that in a

00:19:01.370 --> 00:19:04.830
managed run time, you can't
have memory leaks.

00:19:04.830 --> 00:19:06.940
And I'm sure you guys know
that's not true.

00:19:06.940 --> 00:19:11.590
Having a garbage collector does
not prevent memory leaks.

00:19:11.590 --> 00:19:14.070
A memory leak in a managed run
time is a little bit different

00:19:14.070 --> 00:19:17.770
though, than a memory
leak in C or C++.

00:19:17.770 --> 00:19:20.550
Basically, a leak is when you
have a reference to an unused

00:19:20.550 --> 00:19:22.760
object that's preventing
that object from

00:19:22.760 --> 00:19:24.560
being garbage collected.

00:19:24.560 --> 00:19:27.220
And sometimes you can have a
reference to a single object,

00:19:27.220 --> 00:19:30.180
but that object points to a
bunch of other objects.

00:19:30.180 --> 00:19:33.320
And basically, that single
reference is preventing a

00:19:33.320 --> 00:19:37.400
large group of objects
from being collected.

00:19:37.400 --> 00:19:40.580
One thing to watch out
for in Android.

00:19:40.580 --> 00:19:43.530
I see people sometimes and
I've done this myself,

00:19:43.530 --> 00:19:46.060
accidentally create a memory
leak by holding a long lived

00:19:46.060 --> 00:19:48.600
reference to an activity.

00:19:48.600 --> 00:19:50.750
So you need to be really careful
with that and maybe

00:19:50.750 --> 00:19:53.230
it's you're holding a reference
to the context and

00:19:53.230 --> 00:19:54.540
that's what happens.

00:19:54.540 --> 00:19:57.590
You can also do it by keeping
a long lived reference to a

00:19:57.590 --> 00:20:00.240
view or to a drawable, because
these will also hold a

00:20:00.240 --> 00:20:05.530
reference to the activity that
they were originally in.

00:20:05.530 --> 00:20:08.170
And the reason that this is
a problem, the reason this

00:20:08.170 --> 00:20:11.070
causes a memory leak is this.

00:20:11.070 --> 00:20:14.680
So you've got your activity,
it contains a view group, a

00:20:14.680 --> 00:20:18.160
linear layout or something, and
it contains some views.

00:20:18.160 --> 00:20:20.910
And we've got a reference from
the framework to the currently

00:20:20.910 --> 00:20:22.160
visible activity.

00:20:24.250 --> 00:20:27.380
But in Android, when you have
a rotation event, so you

00:20:27.380 --> 00:20:31.870
rotate your device, what we do
is actually build up a new

00:20:31.870 --> 00:20:35.780
view hierarchy because you need
to load new resources,

00:20:35.780 --> 00:20:37.890
you may have a brand new
layout for landscape or

00:20:37.890 --> 00:20:39.980
portrait, you may
have differently

00:20:39.980 --> 00:20:43.040
sized icons or bitmaps.

00:20:43.040 --> 00:20:46.160
And then we basically remove the
reference to the old view

00:20:46.160 --> 00:20:49.190
hierarchy and point
to the new one.

00:20:49.190 --> 00:20:51.870
And the idea is that this old
view hierarchy sure get

00:20:51.870 --> 00:20:52.650
garbage collected.

00:20:52.650 --> 00:20:54.600
But if you're holding a
reference to that, you're

00:20:54.600 --> 00:20:57.410
going to prevent it from getting
garbage collected.

00:20:57.410 --> 00:20:59.440
And that's why it's a problem
to hold the long lived

00:20:59.440 --> 00:21:02.550
reference to an activity or
even to a view because in

00:21:02.550 --> 00:21:05.890
fact, the arrows connecting
these objects should be going

00:21:05.890 --> 00:21:06.740
in both directions.

00:21:06.740 --> 00:21:11.250
Because you've got pointers
all the way up.

00:21:11.250 --> 00:21:16.120
So if you do have a memory leak,
a really good way to

00:21:16.120 --> 00:21:17.480
figure out where it
is is using the

00:21:17.480 --> 00:21:19.510
Eclipse Memory Analyzer.

00:21:19.510 --> 00:21:21.700
I'm going to do a demo of that,
but I want to first

00:21:21.700 --> 00:21:26.330
cover some of the concepts
behind the Memory Analyzer, so

00:21:26.330 --> 00:21:28.950
that when I do the demo you'll
better understand what I'm

00:21:28.950 --> 00:21:31.250
showing you.

00:21:31.250 --> 00:21:34.040
So the Eclipse Memory Analyzer
can be downloaded from the

00:21:34.040 --> 00:21:35.175
eclipse.org site.

00:21:35.175 --> 00:21:37.020
It comes in a couple
of flavors.

00:21:37.020 --> 00:21:39.840
There's an Eclipse plug-in
version, there's also a

00:21:39.840 --> 00:21:41.510
standalone version.

00:21:41.510 --> 00:21:43.600
I'm going to be demonstrating
the standalone version.

00:21:43.600 --> 00:21:48.980
I just personally prefer not to
have Eclipse have all these

00:21:48.980 --> 00:21:49.690
different plug-ins.

00:21:49.690 --> 00:21:52.090
I kind of like to keep things
a little bit separate.

00:21:52.090 --> 00:21:55.210
But they're basically
the same.

00:21:55.210 --> 00:21:58.720
Now, Memory Analyzer has some
important concepts that

00:21:58.720 --> 00:22:00.080
you'll see a lot.

00:22:00.080 --> 00:22:03.920
It talks about shallow heap
and retained heap.

00:22:03.920 --> 00:22:06.940
So the shallow heap of an object
is just how large is

00:22:06.940 --> 00:22:09.360
this object, it's
size and bytes.

00:22:09.360 --> 00:22:10.620
It's really simple.

00:22:10.620 --> 00:22:14.420
So let's say that all of these
objects are 100 bytes.

00:22:14.420 --> 00:22:16.080
So they're shallow heap
is 100 bytes.

00:22:16.080 --> 00:22:17.532
It's easy.

00:22:17.532 --> 00:22:20.100
The retained heap is something
different.

00:22:20.100 --> 00:22:24.050
Basically, the retained heap
says, if I have an object here

00:22:24.050 --> 00:22:27.500
and I were to free this object,
what other objects is

00:22:27.500 --> 00:22:28.200
it pointing to?

00:22:28.200 --> 00:22:30.490
And could those be freed
at the same time?

00:22:30.490 --> 00:22:33.530
And so you calculate the
retained heap in terms of,

00:22:33.530 --> 00:22:36.790
what is the total size of
objects that could be freed by

00:22:36.790 --> 00:22:39.990
freeing this one object?

00:22:39.990 --> 00:22:43.170
So maybe it's best to understand
with an example.

00:22:43.170 --> 00:22:46.410
So this object down on the
right-hand side in yellow,

00:22:46.410 --> 00:22:48.210
this guy doesn't point
to any other objects.

00:22:48.210 --> 00:22:51.460
So his retained size is pretty
easy to calculate.

00:22:51.460 --> 00:22:54.580
His retained heap is 100.

00:22:54.580 --> 00:22:59.220
This guy on top, he has a
pointer to one other object.

00:22:59.220 --> 00:23:01.610
But he's not holding
that object alive.

00:23:01.610 --> 00:23:04.480
There are other pointers
to that same object.

00:23:04.480 --> 00:23:09.680
So this guy's retained heap
is also just 100 bytes.

00:23:09.680 --> 00:23:11.670
Because if we were to remove
this object, it's not going to

00:23:11.670 --> 00:23:15.110
free up any other objects.

00:23:15.110 --> 00:23:19.000
The object down at the end
however, it's basically

00:23:19.000 --> 00:23:22.050
keeping all the other
objects alive.

00:23:22.050 --> 00:23:25.020
So its retained heap is 400
because if we could free that

00:23:25.020 --> 00:23:28.360
object, we could free all the
other objects well, on this

00:23:28.360 --> 00:23:31.330
slide anyway.

00:23:31.330 --> 00:23:34.620
So you might be wondering, how
do you go about calculating

00:23:34.620 --> 00:23:35.405
the retain heap?

00:23:35.405 --> 00:23:37.570
So you're going to see this
in Memory Analyzer.

00:23:37.570 --> 00:23:40.455
And actually, knowing how it
calculates the retained heap

00:23:40.455 --> 00:23:43.060
is quite useful.

00:23:43.060 --> 00:23:46.090
So the Memory Analyzer
uses a concept called

00:23:46.090 --> 00:23:47.340
the denominator tree.

00:23:47.340 --> 00:23:50.490
This is a concept from
graph theory.

00:23:50.490 --> 00:23:55.650
Basically, if you have a node
A and a node B, A is said to

00:23:55.650 --> 00:24:01.660
be the dominator of B if every
path to B goes through A.

00:24:01.660 --> 00:24:05.120
And so you might see how that
could help us figure out what

00:24:05.120 --> 00:24:07.270
the retained heap
of an object is.

00:24:07.270 --> 00:24:09.290
So another example here.

00:24:09.290 --> 00:24:10.590
So let's start with A.

00:24:10.590 --> 00:24:12.770
It's kind of the root.

00:24:12.770 --> 00:24:16.260
B and C are only accessible
through A.

00:24:16.260 --> 00:24:17.830
So it's pretty straightforward.

00:24:17.830 --> 00:24:21.660
They're children of A and
the dominator tree.

00:24:21.660 --> 00:24:24.866
E is also only accessible
through C.

00:24:24.866 --> 00:24:28.460
So it's a child of C in
the dominator tree.

00:24:28.460 --> 00:24:30.930
D is a little bit interesting
here.

00:24:30.930 --> 00:24:35.740
D can be accessed through
B or C, but A is on

00:24:35.740 --> 00:24:38.270
every path to D.

00:24:38.270 --> 00:24:40.300
So that means that A is
the parent of D and

00:24:40.300 --> 00:24:42.260
the dominator tree.

00:24:42.260 --> 00:24:44.250
And now you're going to see this
dominator tree concept

00:24:44.250 --> 00:24:47.610
also pop up in Memory
Analyzer in its UI.

00:24:47.610 --> 00:24:49.110
And it can be really
helpful for

00:24:49.110 --> 00:24:50.430
tracking down memory leaks.

00:24:53.150 --> 00:24:56.530
So let's jump in and do a
demo of debugging and

00:24:56.530 --> 00:24:59.250
memory leak with MAT.

00:24:59.250 --> 00:25:03.180
So what I'm going to use for
this demo is the Honeycomb

00:25:03.180 --> 00:25:04.430
gallery's sample application.

00:25:07.420 --> 00:25:12.880
It's a simple application that
comes with the Android SDK the

00:25:12.880 --> 00:25:14.540
basically just demonstrates
some of

00:25:14.540 --> 00:25:15.790
the features of Honeycomb.

00:25:18.990 --> 00:25:22.850
And really, all it is is a
little app the lets you page

00:25:22.850 --> 00:25:25.420
through some photos.

00:25:25.420 --> 00:25:28.440
Pretty simple.

00:25:28.440 --> 00:25:31.750
Now I've done something
kind of naughty here.

00:25:31.750 --> 00:25:34.975
I've introduced a memory leak
into this application.

00:25:34.975 --> 00:25:38.875
And I'll show you how
I've done that.

00:25:38.875 --> 00:25:41.790
Sorry, I better switch
to the slides again.

00:25:46.990 --> 00:25:50.810
So you'll see here I have the
source code, an excerpt of the

00:25:50.810 --> 00:25:53.890
source code from the activity.

00:25:53.890 --> 00:25:57.100
And so what I've done here is
I've introduced this inner

00:25:57.100 --> 00:25:59.590
class called leaky.

00:25:59.590 --> 00:26:02.140
And this is not a static
inner class.

00:26:02.140 --> 00:26:06.720
So you may know that if you
create a non-static inner

00:26:06.720 --> 00:26:08.770
class, it actually keeps
a reference to

00:26:08.770 --> 00:26:10.722
the enclosing object.

00:26:10.722 --> 00:26:12.900
And this is because from a
non-static inner class, you

00:26:12.900 --> 00:26:16.310
can actually refer to the
instance variables of the

00:26:16.310 --> 00:26:17.120
enclosing object.

00:26:17.120 --> 00:26:18.870
So it's going to retain
a reference to

00:26:18.870 --> 00:26:21.160
the activity here.

00:26:21.160 --> 00:26:24.110
That's fine as long as this
object doesn't live longer

00:26:24.110 --> 00:26:26.210
than the activity.

00:26:26.210 --> 00:26:30.620
But I've got this static field
and statics live longer than

00:26:30.620 --> 00:26:33.270
any particular instance.

00:26:33.270 --> 00:26:36.550
And in my on create method, what
I've done is instantiated

00:26:36.550 --> 00:26:41.750
the leaky object and stored
it into the static field.

00:26:41.750 --> 00:26:44.330
So if you want to be able to
visualize this, I basically

00:26:44.330 --> 00:26:49.170
got my view hierarchy that
starts with the main activity.

00:26:49.170 --> 00:26:52.450
I've instantiated this leaky
object and he has a reference

00:26:52.450 --> 00:26:57.060
to the main activity because
that was its enclosing class.

00:26:57.060 --> 00:27:00.800
Finally, I have the main
activity class, which is

00:27:00.800 --> 00:27:02.730
conceptually a different
area of memory than

00:27:02.730 --> 00:27:05.320
any particular instance.

00:27:05.320 --> 00:27:08.790
And there's a static variable
pointing to the leaky object.

00:27:08.790 --> 00:27:10.980
So maybe you can see how this
is going to cause a memory

00:27:10.980 --> 00:27:12.720
leak when I rotate the screen.

00:27:15.660 --> 00:27:17.750
So let's jump in and take a
look at this memory leak.

00:27:25.180 --> 00:27:28.490
So if you want to figure out
whether you have a memory

00:27:28.490 --> 00:27:32.430
leak, one of the easiest ways
is to just kind of look at

00:27:32.430 --> 00:27:35.920
your log messages.

00:27:35.920 --> 00:27:38.270
So I'm just going to do that.

00:27:38.270 --> 00:27:39.660
I'm going to do it at
the command line.

00:27:42.540 --> 00:27:44.610
I can just type ADB log cat.

00:27:44.610 --> 00:27:48.940
And I want to restrict it to
the particular process that

00:27:48.940 --> 00:27:49.620
I've got running here.

00:27:49.620 --> 00:27:54.310
I don't want to see all of the
log messages on the system.

00:27:54.310 --> 00:27:56.690
So I'm just going to grab
on the process ID.

00:27:59.780 --> 00:28:02.310
There we see a bunch a log
messages, including some

00:28:02.310 --> 00:28:05.840
garbage collection messages.

00:28:05.840 --> 00:28:11.100
And the number you want to look
at is basically the first

00:28:11.100 --> 00:28:15.880
number here in the 9805K.

00:28:15.880 --> 00:28:17.800
The first number in
your heap size.

00:28:17.800 --> 00:28:20.970
This is the amount of live
objects in the system.

00:28:20.970 --> 00:28:23.180
And if you're looking for a
memory leak, that's what you

00:28:23.180 --> 00:28:25.940
want to look at.

00:28:25.940 --> 00:28:28.990
So I'm going to flip through
some of the photos here.

00:28:28.990 --> 00:28:31.115
And you'll see that that number
stays pretty constant.

00:28:31.115 --> 00:28:33.010
We're up to 9872.

00:28:33.010 --> 00:28:36.900
But basically, the heap usage
is pretty constant.

00:28:36.900 --> 00:28:40.160
Now when I rotate this device,
we're going to be a bunch of

00:28:40.160 --> 00:28:42.430
garbage collections happen.

00:28:42.430 --> 00:28:45.340
That heap usage goes up and
it doesn't go down again.

00:28:45.340 --> 00:28:48.160
So we're now up to
12 megs of heap.

00:28:48.160 --> 00:28:52.236
So we leaked about two
and a half megs.

00:28:52.236 --> 00:28:55.910
So whenever you see your memory
go up in kind of a step

00:28:55.910 --> 00:28:58.500
function like that, it steps
up and just never goes back

00:28:58.500 --> 00:29:03.300
down, that's a good sign
you have a memory leak.

00:29:03.300 --> 00:29:05.910
So once you know that you have a
leak, what you'll want to do

00:29:05.910 --> 00:29:09.620
is create a heap dump, so you
can go about debugging it.

00:29:09.620 --> 00:29:11.082
So I'm going to do
that right now.

00:29:11.082 --> 00:29:14.770
I'll open up DDMS.

00:29:14.770 --> 00:29:20.660
You just need to select the
process that you care about

00:29:20.660 --> 00:29:24.180
and click on this icon up in
the toolbar that says dump

00:29:24.180 --> 00:29:26.550
HPROF file.

00:29:26.550 --> 00:29:28.230
That'll create a heap dump.

00:29:28.230 --> 00:29:32.340
It takes a few seconds because
it's dumping basically a huge

00:29:32.340 --> 00:29:36.000
binary file out to disk.

00:29:36.000 --> 00:29:43.330
And then I can just save it in
a file called dump.hprof.

00:29:46.920 --> 00:29:49.570
And then, because I'm using
this standalone version of

00:29:49.570 --> 00:29:53.890
DDMS here, I need to
convert this file.

00:29:53.890 --> 00:29:55.980
As I mentioned, if you're using
the ADT plug-in for

00:29:55.980 --> 00:29:58.670
Eclipse and using DDMS in there,
you don't need to go

00:29:58.670 --> 00:30:00.530
through this conversion step.

00:30:00.530 --> 00:30:02.460
But it's really simple.

00:30:02.460 --> 00:30:05.390
Now that I've converted it, I
can open up the Eclipse Memory

00:30:05.390 --> 00:30:08.910
Analyzer and take a look
at this heap dump.

00:30:08.910 --> 00:30:11.830
So there's not much to see in
the Memory Analyzer until

00:30:11.830 --> 00:30:14.280
you've opened up a heap dump,
which we can do just

00:30:14.280 --> 00:30:15.670
from the file menu.

00:30:15.670 --> 00:30:17.710
Open heap dump.

00:30:17.710 --> 00:30:20.140
And I'll open up this converted
heap dump, which I

00:30:20.140 --> 00:30:21.390
just created.

00:30:24.460 --> 00:30:27.990
Doesn't take very long
for it to load up.

00:30:27.990 --> 00:30:31.210
And the first thing you'll
see is this pie chart.

00:30:31.210 --> 00:30:33.880
This is showing the biggest
objects in the system by

00:30:33.880 --> 00:30:36.930
retained size.

00:30:36.930 --> 00:30:39.600
Now this alone doesn't really
tell us too much.

00:30:39.600 --> 00:30:44.540
You can see that down in the
bottom left here, when I mouse

00:30:44.540 --> 00:30:46.980
over the various slices of the
pie, it's telling me what kind

00:30:46.980 --> 00:30:48.750
of object I've got.

00:30:48.750 --> 00:30:52.030
But that doesn't really
tell us too much.

00:30:52.030 --> 00:30:55.085
If we want to get some more
information, you want

00:30:55.085 --> 00:30:55.830
to look down here.

00:30:55.830 --> 00:30:56.870
There are two views.

00:30:56.870 --> 00:30:59.370
The histogram view and
the dominator tree.

00:30:59.370 --> 00:31:02.085
And these are the ones that I
find most useful and I'm going

00:31:02.085 --> 00:31:03.700
to show to you.

00:31:03.700 --> 00:31:05.480
Let's take a look at
the dominator tree.

00:31:05.480 --> 00:31:08.290
You remember the concept
I explained.

00:31:08.290 --> 00:31:09.950
This is how it can be
useful in tracking

00:31:09.950 --> 00:31:12.036
down a memory leak.

00:31:12.036 --> 00:31:16.110
So what we've got here is
basically a list of instances

00:31:16.110 --> 00:31:19.600
or a list of objects in
this system organized.

00:31:19.600 --> 00:31:21.010
There's a column here.

00:31:21.010 --> 00:31:23.565
Organized by the amount
of retained heap.

00:31:23.565 --> 00:31:25.890
So when you've got a memory
leak, looking at the amount of

00:31:25.890 --> 00:31:30.270
retained heap is often a good
way to look at things because

00:31:30.270 --> 00:31:32.650
that's going to have the biggest
effect on how much

00:31:32.650 --> 00:31:34.170
memory you're using.

00:31:34.170 --> 00:31:36.470
And chances are, if you've
noticed that you've got a

00:31:36.470 --> 00:31:40.320
leak, you're leaking a
significant amount.

00:31:40.320 --> 00:31:41.860
So let me just zoom in here.

00:31:41.860 --> 00:31:43.860
Hopefully you guys can see
this a bit better.

00:31:46.920 --> 00:31:50.530
So at the very top of the list
we have the resources class.

00:31:50.530 --> 00:31:53.230
That's not too surprising
because our resources we have

00:31:53.230 --> 00:31:55.440
to load lots of bitmaps.

00:31:55.440 --> 00:31:56.890
That's going to hold lots
of memory alive.

00:31:56.890 --> 00:31:58.180
That's fine.

00:31:58.180 --> 00:32:00.890
These two bitmap objects
are interesting.

00:32:00.890 --> 00:32:03.730
I've got these two large
bitmaps, more than two and a

00:32:03.730 --> 00:32:05.770
half megs each.

00:32:05.770 --> 00:32:08.300
It's funny because that sounds
about like the amount of

00:32:08.300 --> 00:32:12.130
memory that I was leaking.

00:32:12.130 --> 00:32:15.060
So if I want to investigate a
bit further, I can right click

00:32:15.060 --> 00:32:20.760
on one of these objects and
choose path to GC roots.

00:32:20.760 --> 00:32:24.250
And I'll chose excluding weak
references because I want to

00:32:24.250 --> 00:32:26.410
see what's keeping that
object alive.

00:32:26.410 --> 00:32:30.050
And a weak reference is not
going to keep it alive.

00:32:30.050 --> 00:32:34.270
So this opened up a new tab
and what do you know?

00:32:34.270 --> 00:32:37.650
It actually points
right to my leak.

00:32:37.650 --> 00:32:40.630
So when you're creating leaks in
your application, make sure

00:32:40.630 --> 00:32:44.200
you name it something really
helpful like this so you can

00:32:44.200 --> 00:32:45.070
find it easily.

00:32:45.070 --> 00:32:46.320
AUDIENCE: [LAUGHTER]

00:32:49.470 --> 00:32:53.320
PATRICK DUBROY: So some of you
might have noticed this, that

00:32:53.320 --> 00:32:56.800
if there's only a single path to
this object, because that's

00:32:56.800 --> 00:33:01.240
all I can see here, why didn't
this leak object show up in

00:33:01.240 --> 00:33:02.800
the dominator tree?

00:33:02.800 --> 00:33:05.670
I mentioned that the dominator
tree should show you the

00:33:05.670 --> 00:33:09.670
largest objects by their amount
of retained heap.

00:33:09.670 --> 00:33:12.470
And well this is a single object
that's responsible for

00:33:12.470 --> 00:33:14.620
retaining the bitmap.

00:33:14.620 --> 00:33:18.280
So the reason for that is that
the Eclipse Memory Analyzer,

00:33:18.280 --> 00:33:20.980
when it calculates the dominator
tree, it actually

00:33:20.980 --> 00:33:23.540
doesn't treat weak references
separately.

00:33:23.540 --> 00:33:26.300
It basically just treats them
like a normal reference.

00:33:26.300 --> 00:33:28.480
So you'll see that if I actually
right click on this

00:33:28.480 --> 00:33:33.430
guy again and say path to GC
roots, and say with all

00:33:33.430 --> 00:33:36.720
references, then there's
actually another

00:33:36.720 --> 00:33:38.640
path to this object.

00:33:38.640 --> 00:33:40.050
But it's a weak reference.

00:33:40.050 --> 00:33:42.020
Generally you don't need to be
too concerned about weak

00:33:42.020 --> 00:33:44.930
references because they're not
going to prevent your object

00:33:44.930 --> 00:33:47.050
from being garbage collected.

00:33:47.050 --> 00:33:50.190
But that's why the leak object
didn't show up in the

00:33:50.190 --> 00:33:51.440
dominator tree.

00:33:55.765 --> 00:33:59.020
So the dominator tree is one
really, really useful way of

00:33:59.020 --> 00:34:01.790
tracking down a memory leak.

00:34:01.790 --> 00:34:05.100
Another thing I like to use
is the histogram view.

00:34:05.100 --> 00:34:09.389
So I mentioned that in Android,
it's common to leak

00:34:09.389 --> 00:34:13.010
memory by keeping long lived
references to an activity.

00:34:13.010 --> 00:34:15.340
So you may want to actually
go and look at the number

00:34:15.340 --> 00:34:18.610
instances of your main activity
class that you have.

00:34:18.610 --> 00:34:21.260
And the histogram view
lets you do that.

00:34:21.260 --> 00:34:24.040
So the histogram view just
shows a list of all the

00:34:24.040 --> 00:34:28.500
classes in its system and right
now it's sorted based on

00:34:28.500 --> 00:34:30.400
the amount of shallow
heap occupied by

00:34:30.400 --> 00:34:33.469
classes in the system.

00:34:33.469 --> 00:34:37.050
So at the very top there, we
see we have byte arrays.

00:34:37.050 --> 00:34:38.929
And the reason for this is that
byte arrays are now the

00:34:38.929 --> 00:34:43.170
backing memory for pixel data.

00:34:43.170 --> 00:34:45.630
And you know, this is a perfect
example of why it's

00:34:45.630 --> 00:34:47.290
really useful that we
now have the pixel

00:34:47.290 --> 00:34:48.830
data inside the heap.

00:34:48.830 --> 00:34:53.350
Because if you're using this
on Gingerbread or earlier,

00:34:53.350 --> 00:34:55.139
you're not going to see byte
arrays at the top.

00:34:55.139 --> 00:35:01.350
Because that memory with
allocated in native memory.

00:35:01.350 --> 00:35:04.400
So we could also, if we were
concerned about these byte

00:35:04.400 --> 00:35:07.750
array objects, we might want to
right click on it and say

00:35:07.750 --> 00:35:12.820
list objects with incoming
references.

00:35:12.820 --> 00:35:16.720
And we've got our two large
byte array objects here.

00:35:16.720 --> 00:35:20.870
We can right click on one and
say, path to GC roots,

00:35:20.870 --> 00:35:22.120
excluding weak references.

00:35:25.250 --> 00:35:28.500
So this guy looks to
have several paths,

00:35:28.500 --> 00:35:30.770
which keep it alive.

00:35:30.770 --> 00:35:33.030
Nothing looks out of
the ordinary to me.

00:35:33.030 --> 00:35:36.740
And when you're trying to find
a memory leak, there's not

00:35:36.740 --> 00:35:39.080
really a magic answer for
how you find a leak.

00:35:39.080 --> 00:35:42.280
You really have to understand
your system and understand

00:35:42.280 --> 00:35:45.820
what objects are alive, why
they're alive, during the

00:35:45.820 --> 00:35:48.356
various parts of your
application.

00:35:48.356 --> 00:35:51.700
But you'll see if I look at this
other byte array object,

00:35:51.700 --> 00:35:57.080
and again, do path to GC roots
excluding weak references,

00:35:57.080 --> 00:35:59.270
well, I've found
my leak again.

00:35:59.270 --> 00:36:02.400
So this was another way that I
might have found this if it

00:36:02.400 --> 00:36:04.320
weren't so obvious from
the dominator tree.

00:36:09.340 --> 00:36:11.810
The histogram view can
also help us look for

00:36:11.810 --> 00:36:14.220
our activity instances.

00:36:14.220 --> 00:36:17.650
So there's a lot of classes
obviously in the system.

00:36:17.650 --> 00:36:19.080
Our activity is not here.

00:36:19.080 --> 00:36:21.650
There's 2,200 classes.

00:36:21.650 --> 00:36:24.810
But luckily, Eclipse Memory
Analyzer has this handy little

00:36:24.810 --> 00:36:26.600
filter view at the top.

00:36:26.600 --> 00:36:29.670
You can just start typing
a regular expression.

00:36:29.670 --> 00:36:34.386
And it'll return you all the
classes that match that.

00:36:34.386 --> 00:36:37.540
So here we've got our
main activity.

00:36:37.540 --> 00:36:41.960
And it tells us that there are
actually two instances of this

00:36:41.960 --> 00:36:43.370
main activity.

00:36:43.370 --> 00:36:45.860
And that should kind
of be a red flag.

00:36:45.860 --> 00:36:49.050
Normally you should expect to
see only a single instance of

00:36:49.050 --> 00:36:50.310
your main activity alive.

00:36:50.310 --> 00:36:54.450
Now I mentioned during the
screen rotation, we build up a

00:36:54.450 --> 00:36:57.100
new view hierarchy, there's
going to be a brief time where

00:36:57.100 --> 00:36:59.200
there's two instances alive.

00:36:59.200 --> 00:37:02.890
But for the most part, you
should expect to see one here.

00:37:02.890 --> 00:37:04.830
So I might think, OK,
this is a red flag.

00:37:04.830 --> 00:37:07.350
Let's take a look.

00:37:07.350 --> 00:37:11.720
So I can right click on this
object and list objects with

00:37:11.720 --> 00:37:12.695
incoming references.

00:37:12.695 --> 00:37:16.590
So I want to look at what
instances do I have and what's

00:37:16.590 --> 00:37:19.840
pointing to them?

00:37:19.840 --> 00:37:23.810
And so I've got two
instances here.

00:37:23.810 --> 00:37:27.070
If I right click on one of them
and choose path to GC

00:37:27.070 --> 00:37:31.850
roots, excluding weak
references, I've again, found

00:37:31.850 --> 00:37:34.400
my memory leak.

00:37:34.400 --> 00:37:37.640
And in looking at this, I might
realize that, oh, I

00:37:37.640 --> 00:37:38.970
really didn't intend
to do this.

00:37:38.970 --> 00:37:41.990
I didn't mean to keep this
reference there.

00:37:41.990 --> 00:37:44.470
So that's another way that you
could have found the leak.

00:37:47.090 --> 00:37:49.690
So now that we've discovered
where our memory leak is, why

00:37:49.690 --> 00:37:52.550
don't we actually go
ahead and fix it.

00:37:52.550 --> 00:37:57.600
So in this case, the problem was
that we had a non-static

00:37:57.600 --> 00:37:59.310
inner class.

00:37:59.310 --> 00:38:02.720
So we could fix this by making
it a static inner class.

00:38:02.720 --> 00:38:06.080
And then it wouldn't actually
keep a reference to the

00:38:06.080 --> 00:38:09.140
enclosing activity.

00:38:09.140 --> 00:38:14.010
The other thing we could do is
actually just not store it in

00:38:14.010 --> 00:38:15.500
a static variable.

00:38:15.500 --> 00:38:18.510
So it's fine if this leaky
object has a reference to the

00:38:18.510 --> 00:38:21.010
activity, as long as
it doesn't live

00:38:21.010 --> 00:38:23.170
longer than the activity.

00:38:23.170 --> 00:38:24.050
So let's do that.

00:38:24.050 --> 00:38:25.880
Let's just make this
a regular instance

00:38:25.880 --> 00:38:27.130
variable and not a static.

00:38:30.520 --> 00:38:35.670
So then I can go in here
recompile this and push it to

00:38:35.670 --> 00:38:36.920
the device.

00:38:39.530 --> 00:38:42.000
And hopefully, we should see
that our memory leak has been

00:38:42.000 --> 00:38:43.250
eliminated.

00:38:53.940 --> 00:38:56.420
Sorry, what we actually want
to do is look at our log

00:38:56.420 --> 00:38:59.990
output in order to see how
much memory we're using.

00:39:06.030 --> 00:39:11.620
So I'm just going to fire up the
process here, take a look

00:39:11.620 --> 00:39:12.870
at the process ID.

00:39:15.440 --> 00:39:26.140
And again, just do ADP log
cat just on that process.

00:39:26.140 --> 00:39:31.080
So as I page through the photos
again, we see lots of

00:39:31.080 --> 00:39:33.000
GC messages.

00:39:33.000 --> 00:39:36.050
When I rotate, we're going to
see the memory usage goes up

00:39:36.050 --> 00:39:38.440
for a minute there.

00:39:38.440 --> 00:39:42.530
But after a few collections,
it does go back down to its

00:39:42.530 --> 00:39:43.930
previous value.

00:39:43.930 --> 00:39:45.950
So we've successfully eliminated
the leak there.

00:39:48.740 --> 00:39:49.360
And this is great.

00:39:49.360 --> 00:39:51.550
You always want to eliminate
memory leaks.

00:39:57.550 --> 00:40:02.190
So that's an example of using
the Eclipse Memory Analyzer to

00:40:02.190 --> 00:40:04.100
debug a memory leak.

00:40:04.100 --> 00:40:07.190
Eclipse Memory Analyzer is
a really powerful tool.

00:40:07.190 --> 00:40:08.460
It's a little bit complex.

00:40:08.460 --> 00:40:11.660
It actually took me quite a
while to figure out that these

00:40:11.660 --> 00:40:13.460
were the two best tools
for the job.

00:40:16.430 --> 00:40:19.610
So you really want to watch out
for these memory leaks.

00:40:19.610 --> 00:40:22.580
So I gave an example here of
retaining a long lived

00:40:22.580 --> 00:40:25.250
reference to an activity.

00:40:25.250 --> 00:40:29.180
If you've got our context, a
view, a drawable, all of these

00:40:29.180 --> 00:40:30.480
things you need to
watch out for.

00:40:30.480 --> 00:40:34.410
Don't hold long lived
references to those.

00:40:34.410 --> 00:40:36.960
It can also happen with
non-static inner classes,

00:40:36.960 --> 00:40:39.770
which is what I demonstrated
there as well.

00:40:39.770 --> 00:40:42.570
Runnable is actually one that
can bite you sometimes.

00:40:42.570 --> 00:40:44.200
You know, you create
a new runnable.

00:40:44.200 --> 00:40:47.320
You have a deferred event that's
going to run in like

00:40:47.320 --> 00:40:48.005
five minutes.

00:40:48.005 --> 00:40:51.760
If user rotates the screen
that deferred runnable is

00:40:51.760 --> 00:40:55.130
going to hold your previous
activity instance alive for

00:40:55.130 --> 00:40:56.205
five minutes.

00:40:56.205 --> 00:40:58.300
So that's not good.

00:40:58.300 --> 00:41:00.220
You also want to watch
out for caches.

00:41:00.220 --> 00:41:04.620
Sometimes you have a cache and
you want to keep memory alive,

00:41:04.620 --> 00:41:08.540
so that you can load images
faster let's say.

00:41:08.540 --> 00:41:11.510
But you may inadvertently hold
things alive too long.

00:41:14.880 --> 00:41:21.270
So that covers basically, the
core parts of the Eclipse

00:41:21.270 --> 00:41:25.260
Memory Analyzer, and gives you
a basic understanding of

00:41:25.260 --> 00:41:27.120
memory leaks.

00:41:27.120 --> 00:41:30.140
If you'd like to get more
information about Memory

00:41:30.140 --> 00:41:34.850
Analyzer, the download link
you can find on the

00:41:34.850 --> 00:41:37.740
eclipse.org/mat site.

00:41:37.740 --> 00:41:40.580
Markus Kohler who's one of the
original team members of

00:41:40.580 --> 00:41:43.680
Eclipse Memory Analyzer, he
has a blog called the Java

00:41:43.680 --> 00:41:45.400
Performance Blog.

00:41:45.400 --> 00:41:46.190
This is really great.

00:41:46.190 --> 00:41:49.200
He's got tons of great articles
on there about MAT

00:41:49.200 --> 00:41:53.260
and different ways you can
use it to understand your

00:41:53.260 --> 00:41:55.860
applications memory usage.

00:41:55.860 --> 00:41:57.870
I've also got an article that
I wrote on the Android

00:41:57.870 --> 00:42:01.200
Developer Blog called memory
analysis for Android

00:42:01.200 --> 00:42:02.200
applications.

00:42:02.200 --> 00:42:03.890
It covers a lot of the
same stuff that I

00:42:03.890 --> 00:42:06.020
did in my demo here.

00:42:06.020 --> 00:42:09.200
And Romain Guy also has a good
article on avoiding memory

00:42:09.200 --> 00:42:11.640
leaks in Android.

00:42:11.640 --> 00:42:14.170
So I hope that's been helpful,
I hope you guys have a better

00:42:14.170 --> 00:42:17.490
understanding now of how you
can figure out your apps

00:42:17.490 --> 00:42:18.510
memory usage.

00:42:18.510 --> 00:42:21.740
And I've talked about two of the
biggest changes that we've

00:42:21.740 --> 00:42:24.360
made in Gingerbread and
Honeycomb that affect how your

00:42:24.360 --> 00:42:26.410
apps use memory.

00:42:26.410 --> 00:42:27.267
Thanks.

00:42:27.267 --> 00:42:28.517
[APPLAUSE]

00:42:35.560 --> 00:42:40.540
So I can take questions from the
floor if anyone has any.

00:42:40.540 --> 00:42:44.610
Or you all want to get out and
get to a pub and have a beer?

00:42:44.610 --> 00:42:49.250
AUDIENCE: Hi, you mentioned
that if you use NIO in

00:42:49.250 --> 00:42:52.150
Honeycomb your objects are
going to be not in native

00:42:52.150 --> 00:42:54.380
memory and now they're going
to be managed memory.

00:42:54.380 --> 00:42:57.600
How does that affect performance
if you're doing an

00:42:57.600 --> 00:43:01.860
IO, is that going to
be any slower, like

00:43:01.860 --> 00:43:05.060
very intense on network?

00:43:05.060 --> 00:43:07.390
PATRICK DUBROY: No, I mean
it shouldn't affect.

00:43:07.390 --> 00:43:12.290
So I should say that there is
still a way to allocate native

00:43:12.290 --> 00:43:14.980
memory for your NIO
byte buffers.

00:43:14.980 --> 00:43:19.380
I'm not that familiar with the
NIO APIs, but I believe

00:43:19.380 --> 00:43:22.970
there's a way in JNI you can
allocate your own memory.

00:43:22.970 --> 00:43:26.700
So in that case, you'll still
be using native memory.

00:43:26.700 --> 00:43:28.830
But either way, it's
just memory.

00:43:28.830 --> 00:43:30.790
It's just allocated in
a different place.

00:43:30.790 --> 00:43:34.050
So there's nothing that makes
the Dalvik heap memory slower

00:43:34.050 --> 00:43:37.860
than other memory.

00:43:37.860 --> 00:43:41.630
AUDIENCE: So you're saying how
in Honeycomb the bitmaps are

00:43:41.630 --> 00:43:45.560
stored in the Dalvik heap, but
in previous versions to that

00:43:45.560 --> 00:43:47.900
it was stored on
native memory.

00:43:47.900 --> 00:43:50.590
Does that mean that bitmaps
had a different

00:43:50.590 --> 00:43:51.690
amount of heap size?

00:43:51.690 --> 00:43:55.680
Or is that still all counted in
the 16 or 24 megabytes that

00:43:55.680 --> 00:43:56.960
previous versions had?

00:43:56.960 --> 00:43:58.850
PATRICK DUBROY: Yeah,
good question.

00:43:58.850 --> 00:44:00.550
The accounting limits
are still the same.

00:44:00.550 --> 00:44:02.920
That was accounted
for previously.

00:44:02.920 --> 00:44:06.100
You might have noticed if you
ever ran into your heap limit,

00:44:06.100 --> 00:44:08.880
you would be looking at your
heap size and like, I haven't

00:44:08.880 --> 00:44:11.740
hit the limit yet, why am I'm
getting out of memory?

00:44:11.740 --> 00:44:14.600
That was actually accounted for,
so it was your total heap

00:44:14.600 --> 00:44:18.040
size plus the amount of
externally allocated memory

00:44:18.040 --> 00:44:19.260
that was your limit.

00:44:19.260 --> 00:44:20.510
So that hasn't changed.

00:44:23.520 --> 00:44:24.480
AUDIENCE: Hello.

00:44:24.480 --> 00:44:28.080
I have a question on when
does the garbage

00:44:28.080 --> 00:44:30.200
collector kicks in.

00:44:30.200 --> 00:44:33.090
Is is when a number of
objects in memory or

00:44:33.090 --> 00:44:35.500
the size of the heap?

00:44:35.500 --> 00:44:37.330
PATRICK DUBROY: Well, it
depends on what kind of

00:44:37.330 --> 00:44:39.380
garbage collection you're
talking about.

00:44:39.380 --> 00:44:40.750
The concurrent garbage
collector--

00:44:40.750 --> 00:44:41.740
AUDIENCE: Yeah, the
concurrent.

00:44:41.740 --> 00:44:42.220
Yes.

00:44:42.220 --> 00:44:46.250
PATRICK DUBROY: Yeah, so that
I believe is the amount of

00:44:46.250 --> 00:44:48.760
basically, how full your
heap is getting.

00:44:48.760 --> 00:44:52.080
AUDIENCE: Because I noticed
that when you do a lot of

00:44:52.080 --> 00:44:52.370
[INAUDIBLE]

00:44:52.370 --> 00:44:54.640
provide operations, so you
have like [INAUDIBLE]

00:44:54.640 --> 00:45:00.250
list of operations, the garbage
collector kicks in.

00:45:00.250 --> 00:45:03.100
But actually don't collect any
objects because you're just

00:45:03.100 --> 00:45:05.130
filling in the array of objects
that you want to

00:45:05.130 --> 00:45:06.260
insert into a database.

00:45:06.260 --> 00:45:07.770
And that's grow quite quickly.

00:45:07.770 --> 00:45:10.820
And that tends to slow down a
bit, the application without

00:45:10.820 --> 00:45:14.010
actually solving
any heap size.

00:45:14.010 --> 00:45:20.670
PATRICK DUBROY: Yeah, I'm not
sure if the GC looks at--

00:45:20.670 --> 00:45:23.640
so you're basically saying, I
guess, that the collector is

00:45:23.640 --> 00:45:24.080
kicking in.

00:45:24.080 --> 00:45:27.400
It's not actually able to
collect anything, so it

00:45:27.400 --> 00:45:28.180
shouldn't--

00:45:28.180 --> 00:45:29.580
AUDIENCE: But it keeps trying.

00:45:29.580 --> 00:45:31.410
PATRICK DUBROY: Yeah, it
should be smart enough.

00:45:31.410 --> 00:45:35.070
Yeah, I don't believe we
actually look at those kind of

00:45:35.070 --> 00:45:37.170
statistics yet.

00:45:37.170 --> 00:45:39.280
But I mean it seems
reasonable.

00:45:39.280 --> 00:45:40.530
Yeah.

00:45:43.680 --> 00:45:46.880
AUDIENCE: I was wondering if you
guys have some plans for

00:45:46.880 --> 00:45:51.830
making a profiler for
applications or more tools for

00:45:51.830 --> 00:45:55.380
analyzing memory and
all that stuff?

00:45:55.380 --> 00:45:57.110
PATRICK DUBROY: No plans
that I know of.

00:46:00.210 --> 00:46:02.310
Is there anything in particular
that you need?

00:46:02.310 --> 00:46:05.660
I mean I think the Eclipse
Memory Analyzer is a really

00:46:05.660 --> 00:46:07.930
powerful tool and I use
it in my day-to-day

00:46:07.930 --> 00:46:09.570
work quite a bit.

00:46:09.570 --> 00:46:12.110
So I've certainly never found
that it it was missing certain

00:46:12.110 --> 00:46:13.590
features that I needed.

00:46:13.590 --> 00:46:15.900
AUDIENCE: Yeah, probably because
there are some old

00:46:15.900 --> 00:46:18.050
versions from Android that show

00:46:18.050 --> 00:46:19.390
memory leaks or something.

00:46:19.390 --> 00:46:23.960
But for example, on
Eclair, there were

00:46:23.960 --> 00:46:27.060
some stuff with the--

00:46:27.060 --> 00:46:29.200
something there.

00:46:29.200 --> 00:46:31.050
PATRICK DUBROY: Yeah, I mean
we don't have any immediate

00:46:31.050 --> 00:46:34.950
plans I don't think to running
specific tools.

00:46:34.950 --> 00:46:38.170
AUDIENCE: OK, thank you.

00:46:38.170 --> 00:46:39.360
PATRICK DUBROY: Oh,
sorry I've been--

00:46:39.360 --> 00:46:40.820
yeah.

00:46:40.820 --> 00:46:44.570
AUDIENCE: To my understanding,
the native part of a bitmap

00:46:44.570 --> 00:46:48.725
memory before was actually an
instance of the SKIA library,

00:46:48.725 --> 00:46:52.000
of one of the SKIA library
bitmap classes.

00:46:52.000 --> 00:46:56.080
So is this still there or is it
gone now that there is no

00:46:56.080 --> 00:46:58.890
more native memory allocated?

00:46:58.890 --> 00:47:01.290
PATRICK DUBROY: No,
SKIA is still part

00:47:01.290 --> 00:47:03.160
of this stack there.

00:47:03.160 --> 00:47:07.235
Basically at the point where
SKIA calls out to allocate

00:47:07.235 --> 00:47:11.440
memory, we actually just call
back into the VM and allocate

00:47:11.440 --> 00:47:14.220
the memory there rather
than calling malloc.

00:47:14.220 --> 00:47:19.280
So it's still basically the
same mechanism, but the

00:47:19.280 --> 00:47:21.460
memory's just coming from
a different place.

00:47:21.460 --> 00:47:22.710
AUDIENCE: OK.

00:47:25.150 --> 00:47:28.150
AUDIENCE: I thought that when I
was using my application, I

00:47:28.150 --> 00:47:29.440
checked the heap size.

00:47:29.440 --> 00:47:31.410
While using the application
the heap size was not

00:47:31.410 --> 00:47:33.700
significantly going up.

00:47:33.700 --> 00:47:36.380
But the amount of memory used
by the application, which is

00:47:36.380 --> 00:47:38.820
listed in the applications tab
under the running applications

00:47:38.820 --> 00:47:41.010
is going up significantly.

00:47:41.010 --> 00:47:44.110
Sometimes even doubling.

00:47:44.110 --> 00:47:45.270
I know that this is
a different heap

00:47:45.270 --> 00:47:46.150
that is shown there.

00:47:46.150 --> 00:47:49.340
It's actually the process
heap, right?

00:47:49.340 --> 00:47:51.050
Can you tell me what the
background of that is that

00:47:51.050 --> 00:47:54.630
this is shown there because
might like--

00:47:54.630 --> 00:47:57.460
I don't have a memory leak and
users complain about my

00:47:57.460 --> 00:48:01.650
application leaking memory.

00:48:01.650 --> 00:48:04.580
Because for the user it looks
like it's leaking memory.

00:48:04.580 --> 00:48:04.890
PATRICK DUBROY: Right.

00:48:04.890 --> 00:48:07.700
Because you're saying there's
stuff that's attributed to

00:48:07.700 --> 00:48:12.970
your process that are
showing up in the--

00:48:12.970 --> 00:48:14.560
basically, in system memory?

00:48:14.560 --> 00:48:14.950
AUDIENCE: Yeah.

00:48:14.950 --> 00:48:19.240
So it's showing the system
memory in the applications

00:48:19.240 --> 00:48:22.770
tab, which is not really linked
to my heap memory.

00:48:22.770 --> 00:48:26.100
So that is going up, but I can
only control the heap memory.

00:48:26.100 --> 00:48:28.350
If I don't have a native
application I cannot control

00:48:28.350 --> 00:48:30.480
everything else.

00:48:30.480 --> 00:48:31.760
PATRICK DUBROY: I mean there are
going to be various things

00:48:31.760 --> 00:48:34.950
in the system that are
going to get larger.

00:48:34.950 --> 00:48:38.240
For example, like your
JIT code caches.

00:48:38.240 --> 00:48:42.540
As the JIT kicks in and is
allocating memory, like it

00:48:42.540 --> 00:48:44.570
needs to store the compiled
code somewhere.

00:48:44.570 --> 00:48:48.380
So there's definitely other
parts of this system that

00:48:48.380 --> 00:48:51.040
allocate memory that's going to
kind of get charged to your

00:48:51.040 --> 00:48:51.710
application.

00:48:51.710 --> 00:48:55.290
But I can't think of why.

00:48:55.290 --> 00:48:58.770
I can't think of anything that
would be out of the ordinary

00:48:58.770 --> 00:49:00.590
really that should
cause problems.

00:49:00.590 --> 00:49:02.760
AUDIENCE: But do you know if
this will be changed maybe in

00:49:02.760 --> 00:49:03.120
the future?

00:49:03.120 --> 00:49:06.110
That this number is not shown
there because for me, it

00:49:06.110 --> 00:49:08.450
doesn't make sense to show this
number to the end user

00:49:08.450 --> 00:49:10.920
because he doesn't understand
what it means.

00:49:10.920 --> 00:49:11.670
PATRICK DUBROY: I see.

00:49:11.670 --> 00:49:13.520
Where is he seeing the number?

00:49:13.520 --> 00:49:15.110
AUDIENCE: In the running
applications tab.

00:49:15.110 --> 00:49:17.040
If he goes to settings, running
applications, he can

00:49:17.040 --> 00:49:19.470
see the memory usage per
application and that's

00:49:19.470 --> 00:49:21.380
actually the system memory.

00:49:21.380 --> 00:49:22.880
PATRICK DUBROY: I see.

00:49:22.880 --> 00:49:25.415
Yeah, I'm not sure what our
plans are with that.

00:49:25.415 --> 00:49:26.040
Sorry.

00:49:26.040 --> 00:49:29.600
I can take a look and I'm not
actually sure where it's

00:49:29.600 --> 00:49:30.760
getting that number from.

00:49:30.760 --> 00:49:32.010
AUDIENCE: OK, thanks.

00:49:34.510 --> 00:49:37.180
AUDIENCE: My question's about
reasonable expectations of out

00:49:37.180 --> 00:49:39.500
of memory errors.

00:49:39.500 --> 00:49:41.990
Is it possible to completely
eliminate them?

00:49:41.990 --> 00:49:44.980
We've been working for a while
in getting rid of all the out

00:49:44.980 --> 00:49:48.260
of memory errors and down
to one in about

00:49:48.260 --> 00:49:51.520
every 17,000 sessions.

00:49:51.520 --> 00:49:53.220
Should we keep troubleshooting.

00:49:53.220 --> 00:49:55.260
I mean, I'd like to get it
down to zero, but is that

00:49:55.260 --> 00:49:56.330
reasonable or?

00:49:56.330 --> 00:49:59.330
PATRICK DUBROY: So there are
certain scenarios where if

00:49:59.330 --> 00:50:01.760
you're really close to your
memory limit, so if your

00:50:01.760 --> 00:50:07.320
applications live memory size is
really close to that limit,

00:50:07.320 --> 00:50:09.310
the garbage collector's
fundamentally kind of

00:50:09.310 --> 00:50:10.965
asynchronous.

00:50:10.965 --> 00:50:15.010
So if you're really close to the
limit, there can be times

00:50:15.010 --> 00:50:16.980
where you're just trying to
allocate so fast that the

00:50:16.980 --> 00:50:19.060
garbage collector
can't keep up.

00:50:19.060 --> 00:50:20.340
So you can be actually
sort of out

00:50:20.340 --> 00:50:23.070
running the garbage collector.

00:50:23.070 --> 00:50:26.180
So certainly it's possible to
build applications that never

00:50:26.180 --> 00:50:28.180
see an out of memory error.

00:50:28.180 --> 00:50:30.080
But on the other hand, there
are certain types of

00:50:30.080 --> 00:50:34.960
applications that are going to
be running really, really

00:50:34.960 --> 00:50:38.180
close to the limits.

00:50:38.180 --> 00:50:41.800
One thing you can use if you
have caches or things that you

00:50:41.800 --> 00:50:45.590
can free up, there are several
ways to figure out that you're

00:50:45.590 --> 00:50:48.480
getting close to the
heap memory limit.

00:50:48.480 --> 00:50:52.240
I believe there's a callback you
can get notification that

00:50:52.240 --> 00:50:53.540
we're getting low on memory.

00:50:53.540 --> 00:50:55.360
Although, the name escapes me.

00:50:55.360 --> 00:50:59.600
But you can also look at that,
the Activity Manager, get

00:50:59.600 --> 00:51:02.350
memory class to get a sense of
how much memory you have

00:51:02.350 --> 00:51:03.900
available on the system.

00:51:03.900 --> 00:51:09.160
And you know, maybe you can keep
like smaller caches or

00:51:09.160 --> 00:51:12.030
leave the initialize objects
rather than initializing them

00:51:12.030 --> 00:51:15.530
all in the constructor or
something like that.

00:51:15.530 --> 00:51:20.055
It really depends on the
application whether you expect

00:51:20.055 --> 00:51:21.920
to be running close to that
heap limit or not.

00:51:26.590 --> 00:51:31.580
AUDIENCE: You recommended not to
call system.gc manually if

00:51:31.580 --> 00:51:32.910
you can help it.

00:51:32.910 --> 00:51:36.740
Is there any way to reliably
free bitmap memory

00:51:36.740 --> 00:51:37.990
pre-Honeycomb?

00:51:40.150 --> 00:51:40.600
PATRICK DUBROY: Yes.

00:51:40.600 --> 00:51:41.640
Pre-Honeycomb?

00:51:41.640 --> 00:51:42.230
AUDIENCE: Yes.

00:51:42.230 --> 00:51:43.860
PATRICK DUBROY: You can call
recycle on the bitmap.

00:51:43.860 --> 00:51:46.870
AUDIENCE: Yeah, but it can
still take several passes

00:51:46.870 --> 00:51:47.780
apparently.

00:51:47.780 --> 00:51:48.230
PATRICK DUBROY: No.

00:51:48.230 --> 00:51:50.610
If you call recycle that
will immediately

00:51:50.610 --> 00:51:51.730
free the backing memory.

00:51:51.730 --> 00:51:55.610
The bitmap itself, that's like
80 bytes or something.

00:51:55.610 --> 00:51:57.890
AUDIENCE: There are also bitmaps
like drawables that

00:51:57.890 --> 00:52:03.620
you can't manually recycle the
bitmaps that the drawable

00:52:03.620 --> 00:52:06.690
object creates.

00:52:06.690 --> 00:52:08.960
PATRICK DUBROY: OK.

00:52:08.960 --> 00:52:11.680
AUDIENCE: The backing
bitmaps for those.

00:52:11.680 --> 00:52:14.300
PATRICK DUBROY: I see.

00:52:14.300 --> 00:52:17.750
No, I mean there are still
some cases I guess where

00:52:17.750 --> 00:52:21.650
system.gc is the
right approach.

00:52:21.650 --> 00:52:22.900
[UNINTELLIGIBLE PHRASE]

00:52:26.010 --> 00:52:27.570
PATRICK DUBROY: OK, which
objects are you

00:52:27.570 --> 00:52:28.430
talking about in--

00:52:28.430 --> 00:52:34.360
AUDIENCE: My experience is when
I have image drawables

00:52:34.360 --> 00:52:38.020
that are used some where in my
layout and I know they're no

00:52:38.020 --> 00:52:40.430
longer needed.

00:52:40.430 --> 00:52:43.260
Some of them are fairly large
and it seems like--

00:52:43.260 --> 00:52:45.450
PATRICK DUBROY: You can call
recycle on those I believe.

00:52:45.450 --> 00:52:45.880
AUDIENCE: OK.

00:52:45.880 --> 00:52:50.690
My experience is that
it will cause other

00:52:50.690 --> 00:52:53.790
problems when I do that.

00:52:53.790 --> 00:52:54.850
PATRICK DUBROY: If you're
still using

00:52:54.850 --> 00:52:57.040
them, then you can't--

00:52:57.040 --> 00:52:59.350
I mean, you can only recycle
that when you're not using it.

00:52:59.350 --> 00:53:01.290
AUDIENCE: Sure.

00:53:01.290 --> 00:53:02.540
OK.

00:53:05.530 --> 00:53:09.150
AUDIENCE: For native code that
uses a lot of mallocs, what's

00:53:09.150 --> 00:53:13.540
the best way to manage
that memory?

00:53:13.540 --> 00:53:15.890
PATRICK DUBROY: That's
a very good question.

00:53:15.890 --> 00:53:17.930
When you've got native code,
I mean mostly what I was

00:53:17.930 --> 00:53:20.830
covering here was managing
memory from the

00:53:20.830 --> 00:53:23.710
Dalvik side of things.

00:53:23.710 --> 00:53:28.970
I don't know that I have
any real pointers.

00:53:28.970 --> 00:53:32.110
I mean that's one of the reasons
why programming in a

00:53:32.110 --> 00:53:34.450
managed run time is very nice.

00:53:34.450 --> 00:53:36.990
Is that you don't have
to deal with manually

00:53:36.990 --> 00:53:39.310
managing your memory.

00:53:39.310 --> 00:53:41.563
I don't have any great
advice for that.

00:53:44.500 --> 00:53:46.740
AUDIENCE: Does the app that
calls into the native

00:53:46.740 --> 00:53:52.340
libraries, is it aware of, at
least on an aggravate level,

00:53:52.340 --> 00:53:55.700
how much memory is being
used or is it

00:53:55.700 --> 00:53:58.190
completely a separate--

00:53:58.190 --> 00:53:59.850
PATRICK DUBROY: I don't believe
there's any way to

00:53:59.850 --> 00:54:02.030
account for if you're calling
into the library and it's

00:54:02.030 --> 00:54:02.760
calling malloc.

00:54:02.760 --> 00:54:05.740
I don't know that there's any
way to account for that memory

00:54:05.740 --> 00:54:07.390
from your application side.

00:54:07.390 --> 00:54:11.420
AUDIENCE: But that garbage
collector will run when you

00:54:11.420 --> 00:54:15.880
start allocating memory,
will it not?

00:54:15.880 --> 00:54:19.820
PATRICK DUBROY: It'll run when
you start allocating like

00:54:19.820 --> 00:54:21.070
objects in Dalvik.

00:54:25.210 --> 00:54:27.660
It doesn't have any knowledge
of calls to malloc.

00:54:30.500 --> 00:54:33.920
AUDIENCE: You'll just get an
out of memory or a failed

00:54:33.920 --> 00:54:37.680
malloc if you--

00:54:37.680 --> 00:54:38.090
PATRICK DUBROY: Yeah.

00:54:38.090 --> 00:54:38.590
Sure.

00:54:38.590 --> 00:54:40.510
It's going to be the
same mechanisms as

00:54:40.510 --> 00:54:42.740
any C or C++ program.

00:54:42.740 --> 00:54:46.250
Malloc is going to return
a null pointer.

00:54:46.250 --> 00:54:46.590
Yes?

00:54:46.590 --> 00:54:48.650
AUDIENCE:
[UNINTELLIGIBLE PHRASE]

00:54:48.650 --> 00:54:49.533
PATRICK DUBROY: Pardon me?

00:54:49.533 --> 00:54:51.800
AUDIENCE:
[UNINTELLIGIBLE PHRASE]

00:54:51.800 --> 00:54:52.220
PATRICK DUBROY: Oh, OK.

00:54:52.220 --> 00:54:53.420
That's news to me.

00:54:53.420 --> 00:54:54.910
Malloc can't fail on Android.

00:54:54.910 --> 00:54:56.160
AUDIENCE:
[UNINTELLIGIBLE PHRASE]

00:54:58.650 --> 00:54:59.360
PATRICK DUBROY: I see.

00:54:59.360 --> 00:55:00.360
OK.

00:55:00.360 --> 00:55:02.510
AUDIENCE: Can you repeat that?

00:55:02.510 --> 00:55:04.760
PATRICK DUBROY: Romain
tells me that malloc

00:55:04.760 --> 00:55:06.120
can't fail on Android.

00:55:06.120 --> 00:55:07.370
AUDIENCE:
[UNINTELLIGIBLE PHRASE]

00:55:10.100 --> 00:55:12.800
PATRICK DUBROY: I see.

00:55:12.800 --> 00:55:18.440
So I think this is the
old Linux lazy--

00:55:18.440 --> 00:55:19.690
yeah.

00:55:21.890 --> 00:55:26.780
It'll successfully allocate the
virtual memory, but Linux

00:55:26.780 --> 00:55:28.800
can actually hand out more
virtual memory than it can

00:55:28.800 --> 00:55:30.050
actually commit.

00:55:32.070 --> 00:55:38.240
So you can get problems. Like
when your system is totally,

00:55:38.240 --> 00:55:42.062
totally out of native memory,
you're going to see crashes.

00:55:42.062 --> 00:55:44.060
AUDIENCE: So native memory is
completely separate from

00:55:44.060 --> 00:55:45.030
anything Dalvik?

00:55:45.030 --> 00:55:46.280
PATRICK DUBROY: Yes.

00:55:48.400 --> 00:55:51.130
Well, I mean, sorry, I should
say, like Dalvik is still

00:55:51.130 --> 00:55:54.970
allocating its own memory like
for the heap through the

00:55:54.970 --> 00:55:59.320
native mechanisms. So it's
reserving the same virtual

00:55:59.320 --> 00:56:05.290
memory pages that other
applications are using.

00:56:05.290 --> 00:56:07.030
AUDIENCE: But if your
system memory is--

00:56:07.030 --> 00:56:09.070
PATRICK DUBROY: Yeah, if your
system memory is out, you're

00:56:09.070 --> 00:56:09.940
in trouble.

00:56:09.940 --> 00:56:13.230
AUDIENCE: But Dalvik won't get
a notice say, hey, better

00:56:13.230 --> 00:56:14.940
start garbage collecting?

00:56:14.940 --> 00:56:16.190
PATRICK DUBROY: Well, no.

00:56:22.300 --> 00:56:26.420
AUDIENCE: The flag for using
larger heap, does that require

00:56:26.420 --> 00:56:28.910
a permission, like users
permission or

00:56:28.910 --> 00:56:30.820
something like that?

00:56:30.820 --> 00:56:32.630
PATRICK DUBROY: I can't
remember whether we

00:56:32.630 --> 00:56:33.620
added that or not.

00:56:33.620 --> 00:56:36.820
I don't think that it does.

00:56:36.820 --> 00:56:37.890
AUDIENCE: Like the whole--

00:56:37.890 --> 00:56:40.860
could it been like a
permission thing?

00:56:40.860 --> 00:56:42.340
But if it's not then--

00:56:42.340 --> 00:56:46.440
PATRICK DUBROY: Yeah, I mean
the idea I think is that--

00:56:46.440 --> 00:56:47.010
yeah, you're right.

00:56:47.010 --> 00:56:49.280
I mean it can affect the system
as a whole because

00:56:49.280 --> 00:56:51.520
you're going to have apps that
are using a lot more memory,

00:56:51.520 --> 00:56:54.240
which is why I gave that big
warning, that this is not

00:56:54.240 --> 00:56:56.570
something that you should be
using unless you know that you

00:56:56.570 --> 00:56:58.050
really need it.

00:56:58.050 --> 00:56:58.680
AUDIENCE: Yeah.

00:56:58.680 --> 00:56:59.080
But [INAUDIBLE].

00:56:59.080 --> 00:57:00.390
OK.

00:57:00.390 --> 00:57:01.280
PATRICK DUBROY: I don't
think there's a

00:57:01.280 --> 00:57:02.530
permission for it, though.

00:57:06.210 --> 00:57:09.570
AUDIENCE: What if the app kind
of runs in the background for

00:57:09.570 --> 00:57:11.770
weeks at a time?

00:57:11.770 --> 00:57:16.400
So I do everything I can to
simulate a leak, click

00:57:16.400 --> 00:57:21.188
everywhere I can, but I see the
leaks if the app runs two

00:57:21.188 --> 00:57:24.420
or three days and then
I get [INAUDIBLE].

00:57:24.420 --> 00:57:29.810
PATRICK DUBROY: One thing you
could try is if you can use

00:57:29.810 --> 00:57:33.810
the APIs to determine how much
free memory you have. I don't

00:57:33.810 --> 00:57:36.370
know if there's any way you can
actually kind of notice in

00:57:36.370 --> 00:57:40.080
your application that
it started leaking.

00:57:40.080 --> 00:57:45.370
But you could write out an HPROF
file when you notice

00:57:45.370 --> 00:57:47.270
that you've gotten to a certain
point, your heap is

00:57:47.270 --> 00:57:49.960
getting smaller and smaller.

00:57:49.960 --> 00:57:51.720
So there is some debug
information there

00:57:51.720 --> 00:57:52.380
that you could use.

00:57:52.380 --> 00:57:55.120
So if you have like some beta
testers, who could actually

00:57:55.120 --> 00:57:58.490
send you these dumps, then
you could do that.

00:57:58.490 --> 00:58:03.100
So write out the HPROF file
to SD card or something.

00:58:03.100 --> 00:58:06.500
AUDIENCE: So maybe I can just
write an HPROF file every--

00:58:06.500 --> 00:58:07.170
PATRICK DUBROY: I wouldn't
do that.

00:58:07.170 --> 00:58:08.780
I mean they're quite large.

00:58:08.780 --> 00:58:10.860
You don't want to be doing
that on a regular basis.

00:58:10.860 --> 00:58:14.490
But if you detect that things
have gone really, really wrong

00:58:14.490 --> 00:58:21.100
and you're about to die, in an
alpha version or something for

00:58:21.100 --> 00:58:23.495
testing that's one way
you could do it.

00:58:23.495 --> 00:58:27.010
But I definitely wouldn't
recommend putting an app in

00:58:27.010 --> 00:58:31.270
the market that's dumping like
very large files to the SD

00:58:31.270 --> 00:58:32.930
card for no reason.

00:58:32.930 --> 00:58:34.180
AUDIENCE: OK.

00:58:36.620 --> 00:58:38.720
PATRICK DUBROY: OK,
thanks a lot.

