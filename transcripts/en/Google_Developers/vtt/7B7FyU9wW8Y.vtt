WEBVTT
Kind: captions
Language: en

00:00:05.850 --> 00:00:09.820
BO MAJEWSKI: Before I dive into
the API, let me quickly

00:00:09.820 --> 00:00:11.650
introduce ourselves.

00:00:11.650 --> 00:00:13.910
My name is Bo Majewski.

00:00:13.910 --> 00:00:16.620
I've been with Google for
five and a half years.

00:00:16.620 --> 00:00:20.555
I started on the Geocoding API,
joined the Wave, hence

00:00:20.555 --> 00:00:22.280
you didn't see me
for three years.

00:00:22.280 --> 00:00:25.930
And then right now I'm working
on App Engine.

00:00:25.930 --> 00:00:26.966
Ged?

00:00:26.966 --> 00:00:27.870
GED ELLIS: Yeah.

00:00:27.870 --> 00:00:29.270
Hi, I'm Ged Ellis.

00:00:29.270 --> 00:00:32.439
And I also worked on Wave for a
couple of years, working on

00:00:32.439 --> 00:00:34.330
search and notifications.

00:00:34.330 --> 00:00:36.160
And recently-- the last
six months or so--

00:00:36.160 --> 00:00:39.217
I've been working on search
in App Engine.

00:00:39.217 --> 00:00:40.467
All right.

00:00:43.129 --> 00:00:48.340
BO MAJEWSKI: So just to gauge
the audience, how many of you

00:00:48.340 --> 00:00:54.800
have used anything like
Lucene Solr, Whoosh?

00:00:54.800 --> 00:00:58.660
OK, so you're very much familiar
with the reasons for

00:00:58.660 --> 00:00:59.560
doing this.

00:00:59.560 --> 00:01:03.340
Any time you want to have
something like a bunch of

00:01:03.340 --> 00:01:07.100
documents, and you want to allow
users to find the right

00:01:07.100 --> 00:01:12.020
documents by entering just a few
key terms, you would use a

00:01:12.020 --> 00:01:12.670
text search API.

00:01:12.670 --> 00:01:17.780
If you have a feed, usually it's
filled with information

00:01:17.780 --> 00:01:20.680
about people eating breakfast
and going to sleep.

00:01:20.680 --> 00:01:23.470
And from time to time you want
something more relevant, so

00:01:23.470 --> 00:01:25.960
you would search it as well.

00:01:25.960 --> 00:01:31.920
Gmail changed the approach to
email by focusing on search

00:01:31.920 --> 00:01:34.790
rather than on foldering and
cataloging your email.

00:01:34.790 --> 00:01:38.820
So again, this pretty much
uses the search API, text

00:01:38.820 --> 00:01:40.120
search API.

00:01:40.120 --> 00:01:44.090
And finally, every time you go
to Amazon, eBay, where you

00:01:44.090 --> 00:01:48.640
have hundreds of thousands of
products, you use text search

00:01:48.640 --> 00:01:52.570
API to narrow your searches.

00:01:52.570 --> 00:01:58.410
So about three years ago, an
Issue 217 has been filed,

00:01:58.410 --> 00:02:00.450
which since then somehow
mysteriously

00:02:00.450 --> 00:02:02.850
drifted to number two.

00:02:02.850 --> 00:02:06.410
And the person who filed it--
noted that, since we are

00:02:06.410 --> 00:02:11.770
Google, we pretty much should
provide the text search API.

00:02:11.770 --> 00:02:12.962
So we actually agree--

00:02:12.962 --> 00:02:14.770
[APPLAUSE]

00:02:14.770 --> 00:02:16.803
BO MAJEWSKI: It just took
us a while to get to it.

00:02:20.460 --> 00:02:23.470
What I'm going to talk about
today, and Ged, first we're

00:02:23.470 --> 00:02:25.472
going to present you
with a core--

00:02:25.472 --> 00:02:27.220
what we call core--

00:02:27.220 --> 00:02:28.610
search API.

00:02:28.610 --> 00:02:32.720
This is a more low-level
approach.

00:02:32.720 --> 00:02:36.720
Those who do not use
Datastore directly.

00:02:36.720 --> 00:02:39.410
The second part of our talk is
going to be integrating this

00:02:39.410 --> 00:02:40.030
with Datastore.

00:02:40.030 --> 00:02:42.500
How do you use it
with Datastore?

00:02:42.500 --> 00:02:46.070
And finally we're going to
mention our plans for REST

00:02:46.070 --> 00:02:49.060
API, which allows you to exist
outside the app engine

00:02:49.060 --> 00:02:50.310
altogether.

00:02:53.250 --> 00:02:56.780
As you might be aware, what is
available today, you have

00:02:56.780 --> 00:02:58.210
essentially two possibilities.

00:02:58.210 --> 00:03:02.520
You can either rely
on the Datastore.

00:03:02.520 --> 00:03:04.980
And Datastore allows you to
store texts and strings.

00:03:04.980 --> 00:03:07.050
And you can use the
equality/inequality.

00:03:07.050 --> 00:03:11.920
And in case of lists, you
can test for membership.

00:03:11.920 --> 00:03:14.670
Or you can do anything
you can do over HTTP.

00:03:14.670 --> 00:03:18.970
So you either do a self-hosted
solution, where you put up

00:03:18.970 --> 00:03:22.020
your instance of Lucene and just
query it, or you go to a

00:03:22.020 --> 00:03:23.900
third party.

00:03:23.900 --> 00:03:26.406
However, this is not the
most convenient thing.

00:03:28.920 --> 00:03:32.510
What Ged is going to
show you is what is

00:03:32.510 --> 00:03:33.530
available right now.

00:03:33.530 --> 00:03:36.180
We actually have it working.

00:03:36.180 --> 00:03:41.145
And there is no more appropriate
way of showing it

00:03:41.145 --> 00:03:45.060
than showing you with a '90s
style application, the guest

00:03:45.060 --> 00:03:46.530
book you can put on
your webpage.

00:03:46.530 --> 00:03:47.780
OK.

00:03:49.946 --> 00:03:50.790
GED ELLIS: OK.

00:03:50.790 --> 00:03:52.330
So, yeah.

00:03:52.330 --> 00:03:54.810
We have some guest book
application built on top of

00:03:54.810 --> 00:03:56.290
search API.

00:03:56.290 --> 00:04:00.550
There's three sections, I guess,
to this demo page.

00:04:00.550 --> 00:04:02.945
There's a little comment box
here, where you can type in

00:04:02.945 --> 00:04:07.210
comments, a search box where you
can search for comments,

00:04:07.210 --> 00:04:10.500
and then a list of search
results, which is the comments

00:04:10.500 --> 00:04:13.020
which match the current
search.

00:04:13.020 --> 00:04:15.670
So the current search
is all comments.

00:04:15.670 --> 00:04:18.579
And then you've got some other
fields here, like the author

00:04:18.579 --> 00:04:21.460
who wrote it and the
date published.

00:04:21.460 --> 00:04:25.060
So let's go ahead and
make a comment.

00:04:25.060 --> 00:04:30.935
So "I'll be back." So we're
making comments basically just

00:04:30.935 --> 00:04:32.600
quotes from movies.

00:04:32.600 --> 00:04:35.040
And we'll hashtag it
with #terminator.

00:04:35.040 --> 00:04:37.840
And I'm going to shout
out to Bo.

00:04:37.840 --> 00:04:41.850
So that gets added to the index
and is returned in the

00:04:41.850 --> 00:04:45.220
current search, which
is all comments.

00:04:45.220 --> 00:04:46.410
So you've got the
comment there.

00:04:46.410 --> 00:04:47.432
I said, who wrote it.

00:04:47.432 --> 00:04:49.240
So it's anonymous.

00:04:49.240 --> 00:04:50.906
And published today.

00:04:50.906 --> 00:04:55.270
And you can see that I'm
currently signed in anonymous.

00:04:55.270 --> 00:04:57.110
No one is signed in.

00:04:57.110 --> 00:04:58.270
So let's do some searches.

00:04:58.270 --> 00:05:01.590
So I could search for simple
terms, like fish.

00:05:01.590 --> 00:05:04.580
So that'll find all the comments
that mention fish.

00:05:08.590 --> 00:05:12.930
You can see that it supports
CJK, so I can search for just

00:05:12.930 --> 00:05:16.830
the character fish.

00:05:16.830 --> 00:05:21.560
I can do more complicated
searches like combinations of

00:05:21.560 --> 00:05:25.720
terms. Like "be back." And
you'll see it'll match the

00:05:25.720 --> 00:05:28.140
comment I wrote before.

00:05:28.140 --> 00:05:31.310
Also, it's "I'll be back"--

00:05:31.310 --> 00:05:35.060
back "to be or not to
be" is a best quote.

00:05:35.060 --> 00:05:37.530
But if I want to actually
match this, I

00:05:37.530 --> 00:05:38.700
can do a phrase query.

00:05:38.700 --> 00:05:41.800
So that's just showing some of
the sorts of queries we can do

00:05:41.800 --> 00:05:43.118
that this supports.

00:05:43.118 --> 00:05:47.210
So it'll only find "be back."

00:05:47.210 --> 00:05:49.420
You can restrict
your searches.

00:05:49.420 --> 00:05:53.642
So I can search for things
that I wrote.

00:05:53.642 --> 00:05:58.310
So you can see that, in fact,
it searches for Ged in the

00:05:58.310 --> 00:06:00.980
author field.

00:06:00.980 --> 00:06:07.340
So you can restrict to,
obviously, anonymous, so

00:06:07.340 --> 00:06:11.330
things that have been
anonymously written.

00:06:11.330 --> 00:06:14.700
You could also search for
other things, like tags.

00:06:14.700 --> 00:06:16.950
So if I want to search
for gladiator--

00:06:19.760 --> 00:06:22.730
oops, that's actually in
the wrong syntax--

00:06:22.730 --> 00:06:23.980
so tag gladiator.

00:06:26.250 --> 00:06:29.380
And so that finds all the
hashtags, all the comments

00:06:29.380 --> 00:06:32.260
with hashtags and gladiator.

00:06:32.260 --> 00:06:37.995
Similarly, if I want to find
out shout outs to Bo, that

00:06:37.995 --> 00:06:41.600
will find all the shout outs.

00:06:41.600 --> 00:06:44.540
So in terms of some of the more
complicated searches, so

00:06:44.540 --> 00:06:51.090
you can search for combinations
using logical

00:06:51.090 --> 00:06:52.900
operators like and,
or, and not.

00:06:52.900 --> 00:06:58.100
So here we're searching for
anonymous comments that

00:06:58.100 --> 00:07:03.540
contain the word "back" or
"machete." But I can also do

00:07:03.540 --> 00:07:10.310
things like restrict
it to not Macbeth--

00:07:10.310 --> 00:07:11.952
tag with #macbeth.

00:07:11.952 --> 00:07:15.010
So it shows some of the standard
things you'd probably

00:07:15.010 --> 00:07:21.260
find in a search site.

00:07:21.260 --> 00:07:24.010
So, some of the other
things you can do.

00:07:24.010 --> 00:07:25.260
Search for published ranges.

00:07:27.690 --> 00:07:31.610
So I could find "give me all
comments that are being

00:07:31.610 --> 00:07:36.675
written up to and including the
6th of May." And if I want

00:07:36.675 --> 00:07:40.945
to do exclusive ranges, use
the curly brace syntax.

00:07:40.945 --> 00:07:45.970
So that would exclude
the 6th of May.

00:07:45.970 --> 00:07:50.410
And you can do things like
delete documents.

00:07:50.410 --> 00:07:52.603
So I delete that comment,
and now it's no

00:07:52.603 --> 00:07:53.470
longer in the index.

00:07:53.470 --> 00:07:57.790
So that's showing, basically,
documents being indexed

00:07:57.790 --> 00:08:00.900
immediately and matching
searches.

00:08:00.900 --> 00:08:03.220
There's also pagination.

00:08:03.220 --> 00:08:05.210
So I can just paginate
through the results.

00:08:08.030 --> 00:08:08.570
OK.

00:08:08.570 --> 00:08:12.290
So let's have a look at some
of the code behind that and

00:08:12.290 --> 00:08:13.470
the concepts.

00:08:13.470 --> 00:08:16.570
So there's two processes
in search.

00:08:16.570 --> 00:08:17.726
There's the indexing process.

00:08:17.726 --> 00:08:21.320
So, for example, we're
taking user data--

00:08:21.320 --> 00:08:25.540
in our case, the user data was
the comment, the author, so

00:08:25.540 --> 00:08:29.800
the person logged in, the
date and things like

00:08:29.800 --> 00:08:32.150
tags and shout outs.

00:08:32.150 --> 00:08:35.383
So there's some of the fields
that are added to documents.

00:08:35.383 --> 00:08:39.580
So the document would be
this comment document.

00:08:39.580 --> 00:08:42.470
That document is then given
to the indexer, which will

00:08:42.470 --> 00:08:48.710
tokenize it and then build the
inverted file in the index.

00:08:48.710 --> 00:08:52.560
In the search phase, you're
taking user-- or application

00:08:52.560 --> 00:08:55.425
input in our case-- that we were
taking exactly the query

00:08:55.425 --> 00:08:57.440
that was typed in.

00:08:57.440 --> 00:09:00.000
That's given to a query builder,
which will build a

00:09:00.000 --> 00:09:04.130
more formal query and give it
to the indexer back end.

00:09:04.130 --> 00:09:08.480
And execute it against
the index.

00:09:08.480 --> 00:09:10.530
And return a search
response, which

00:09:10.530 --> 00:09:13.810
contains a set of documents.

00:09:13.810 --> 00:09:18.160
And then, those documents
use a result builder and

00:09:18.160 --> 00:09:23.350
construct, in our case, the
three little comments shown at

00:09:23.350 --> 00:09:24.600
the bottom of the page.

00:09:27.340 --> 00:09:28.815
So the architecture.

00:09:28.815 --> 00:09:31.030
So I'm going to discuss
the left hand

00:09:31.030 --> 00:09:31.780
side of this diagram.

00:09:31.780 --> 00:09:35.340
Bo is going to talk about the
Datastore side in the second

00:09:35.340 --> 00:09:37.070
half of the talk.

00:09:37.070 --> 00:09:41.160
So with the application, you
construct the document.

00:09:41.160 --> 00:09:46.020
Then you ask the indexer
to index that document.

00:09:46.020 --> 00:09:49.630
The indexer then will write that
document to Megastore,

00:09:49.630 --> 00:09:52.800
which will then tokenize it
and build the indexes.

00:09:55.340 --> 00:10:00.930
An application will send
a query to the indexer.

00:10:00.930 --> 00:10:05.020
The indexer will then issue that
query to Megastore, read

00:10:05.020 --> 00:10:07.610
the set of results, the
entities, and convert them

00:10:07.610 --> 00:10:09.800
into a search response.

00:10:09.800 --> 00:10:12.020
And then the search response
is sent back up to the

00:10:12.020 --> 00:10:13.270
application.

00:10:16.880 --> 00:10:18.270
So you have full control
over the

00:10:18.270 --> 00:10:19.640
document schema and content.

00:10:19.640 --> 00:10:23.770
There is no up-front declaration
of the schema in

00:10:23.770 --> 00:10:25.320
the gamma files.

00:10:25.320 --> 00:10:28.380
It's actually done as you
add fields to documents.

00:10:28.380 --> 00:10:33.490
So document content can be
arbitrarily transformed.

00:10:33.490 --> 00:10:37.450
So in our case, we were taking
those comments, and we were

00:10:37.450 --> 00:10:42.550
also extracting out the tags
and the shout outs.

00:10:42.550 --> 00:10:46.530
But it could be a product
document, and you could unify

00:10:46.530 --> 00:10:51.980
with that pricing data shipping
and offers and

00:10:51.980 --> 00:10:53.680
reviews, et cetera, so
we could build a

00:10:53.680 --> 00:10:57.050
full product page.

00:10:57.050 --> 00:10:59.350
So, a typical sequence.

00:10:59.350 --> 00:11:00.940
Create a document.

00:11:00.940 --> 00:11:02.920
Add the documents to an index.

00:11:02.920 --> 00:11:07.950
And then use a query to match
against that index and return

00:11:07.950 --> 00:11:09.200
documents or snippets.

00:11:11.860 --> 00:11:14.200
So for those who--

00:11:14.200 --> 00:11:15.700
this should be reasonably
familiar, who've

00:11:15.700 --> 00:11:18.890
used Lucene, et cetera.

00:11:18.890 --> 00:11:22.170
So the document is a collection
of fields plus a

00:11:22.170 --> 00:11:23.310
document ID.

00:11:23.310 --> 00:11:25.990
Document ID has to be unique.

00:11:25.990 --> 00:11:29.640
You may have language
specifications, so you can add

00:11:29.640 --> 00:11:33.590
an indication on how it
should be tokenized.

00:11:33.590 --> 00:11:38.010
And then there's order IDs
should also be supplied.

00:11:38.010 --> 00:11:41.620
The order ID is used to sort
the documents by default.

00:11:41.620 --> 00:11:44.840
And you saw with the
demonstration that those

00:11:44.840 --> 00:11:50.810
documents were sorted from most
recent to oldest. And

00:11:50.810 --> 00:11:53.570
that's using the default
ordering, which is the number

00:11:53.570 --> 00:12:00.250
of seconds since January 2011.

00:12:00.250 --> 00:12:06.185
So fields are simply a named
and typed value.

00:12:06.185 --> 00:12:08.790
The name doesn't have to be
unique, so you can add

00:12:08.790 --> 00:12:09.450
multiple values.

00:12:09.450 --> 00:12:13.350
So you can have as many tags
as you want, for example.

00:12:13.350 --> 00:12:18.380
You can specify the language
so that you can override if

00:12:18.380 --> 00:12:19.690
you want for that particular
field.

00:12:19.690 --> 00:12:22.710
Or you can specify
at this level.

00:12:22.710 --> 00:12:25.410
And as mentioned before, the
schema is built as you

00:12:25.410 --> 00:12:27.440
introduce new field
names and types.

00:12:31.560 --> 00:12:33.750
Some of the field values
we support.

00:12:33.750 --> 00:12:35.650
Plain text.

00:12:35.650 --> 00:12:35.970
HTML.

00:12:35.970 --> 00:12:39.160
So it can use a HTML parser.

00:12:39.160 --> 00:12:39.595
Dates.

00:12:39.595 --> 00:12:42.840
So up to a day-level granularity
in date/time, so

00:12:42.840 --> 00:12:44.750
you have milliseconds.

00:12:44.750 --> 00:12:45.660
Geopoints.

00:12:45.660 --> 00:12:46.840
Numeric.

00:12:46.840 --> 00:12:49.270
And Atom, so you can have fields
that you don't want any

00:12:49.270 --> 00:12:51.650
tokenization and treat
as a single value.

00:12:56.840 --> 00:12:59.020
So let's look at how you
can create a document.

00:12:59.020 --> 00:13:00.270
Here's the Python code.

00:13:06.430 --> 00:13:07.590
So, we have a document ID.

00:13:07.590 --> 00:13:09.050
Set the document ID.

00:13:09.050 --> 00:13:12.310
In this case, you'll need some
way of generating a unique

00:13:12.310 --> 00:13:13.900
document ID.

00:13:13.900 --> 00:13:16.250
And then you basically just
add a set of fields--

00:13:16.250 --> 00:13:20.530
let's say there was text, HTML
and dates and Atoms. We'd

00:13:20.530 --> 00:13:24.190
probably have two more here,
which were the tags and the

00:13:24.190 --> 00:13:26.310
two fields.

00:13:26.310 --> 00:13:28.470
But essentially you
name each one.

00:13:28.470 --> 00:13:29.830
You type it.

00:13:29.830 --> 00:13:31.410
And you give it some value.

00:13:31.410 --> 00:13:34.275
So, the author, which is
the user nickname.

00:13:34.275 --> 00:13:38.450
The comment, which is the actual
text from the text box.

00:13:38.450 --> 00:13:40.960
And the date field, which
is the date today.

00:13:44.390 --> 00:13:50.370
The Java is pretty similar
except we're using builders.

00:13:50.370 --> 00:13:51.400
So just get a builder.

00:13:51.400 --> 00:13:53.340
Set the document ID.

00:13:53.340 --> 00:13:54.135
And then add a field.

00:13:54.135 --> 00:13:57.350
And then for each field,
you have a builder.

00:13:57.350 --> 00:13:58.150
So, you have a field builder.

00:13:58.150 --> 00:13:59.096
You set the name.

00:13:59.096 --> 00:14:01.526
And you set the type
of value it is.

00:14:01.526 --> 00:14:03.480
If it's text, HTML, or date.

00:14:10.210 --> 00:14:11.750
So as I said, the index
is fully dynamic.

00:14:11.750 --> 00:14:16.560
So as you add those new field
names with the types, and you

00:14:16.560 --> 00:14:19.080
index that document, that will
introduce that to the schema.

00:14:19.080 --> 00:14:22.800
So that'll extend the schema.

00:14:22.800 --> 00:14:25.430
We support versions.

00:14:25.430 --> 00:14:27.580
So you can have an existing
version of an index.

00:14:27.580 --> 00:14:29.210
You don't need to do
this, but you can.

00:14:29.210 --> 00:14:31.240
And you could build in
a background process.

00:14:31.240 --> 00:14:33.240
Rebuild the index.

00:14:33.240 --> 00:14:35.070
And then hot-swap
that index out.

00:14:37.650 --> 00:14:40.723
There's two levels of
consistency supported.

00:14:40.723 --> 00:14:43.350
This is global or
per document.

00:14:43.350 --> 00:14:46.670
So global is like
an inbox style.

00:14:46.670 --> 00:14:50.740
And basically if you're putting
a label on a document,

00:14:50.740 --> 00:14:55.380
for example like your email or
something, and you put it on

00:14:55.380 --> 00:14:55.916
that document.

00:14:55.916 --> 00:14:59.330
If you search for that,
you expect that

00:14:59.330 --> 00:15:01.150
document to be retrieved.

00:15:01.150 --> 00:15:06.475
So that all rights are committed
up to before that

00:15:06.475 --> 00:15:09.300
search is executed.

00:15:09.300 --> 00:15:13.570
And then there's per document,
which in a feed style, it's

00:15:13.570 --> 00:15:16.640
not that important that if
there's other content you

00:15:16.640 --> 00:15:21.280
aren't aware of, then if it
turns up a few seconds later,

00:15:21.280 --> 00:15:23.340
then that's OK.

00:15:27.560 --> 00:15:30.005
This is an issue around
Megastore, and you see the

00:15:30.005 --> 00:15:30.920
same thing around Datastore.

00:15:30.920 --> 00:15:34.140
It's like selecting entities.

00:15:34.140 --> 00:15:39.940
So global basically has
around one QPS of

00:15:39.940 --> 00:15:42.340
rights that it can support.

00:15:42.340 --> 00:15:47.800
But per document can support
thousands QPS

00:15:47.800 --> 00:15:50.430
throughput of rights.

00:15:53.640 --> 00:15:58.950
So the sort of operations we
support are index and re-index

00:15:58.950 --> 00:16:01.600
the document.

00:16:01.600 --> 00:16:02.670
Search.

00:16:02.670 --> 00:16:06.570
So you can search with a simple
query string or a

00:16:06.570 --> 00:16:09.840
complex search request. So you
can override all the features

00:16:09.840 --> 00:16:11.895
like sorting, scoring,
et cetera.

00:16:14.840 --> 00:16:16.560
Delete document.

00:16:16.560 --> 00:16:21.430
So you can delete by document
ID, or you can delete by

00:16:21.430 --> 00:16:22.150
issuing a search query.

00:16:22.150 --> 00:16:24.040
So all the documents
that match the

00:16:24.040 --> 00:16:27.000
query will be deleted.

00:16:27.000 --> 00:16:31.540
You can iterate through all
documents in an index.

00:16:31.540 --> 00:16:32.810
You can get the metadata.

00:16:32.810 --> 00:16:36.590
So the metadata would consist of
the index name, consistency

00:16:36.590 --> 00:16:39.220
level, the schema.

00:16:39.220 --> 00:16:41.170
Or you can activate
a version of an

00:16:41.170 --> 00:16:42.700
index so you can hot-swap.

00:16:47.130 --> 00:16:49.720
So how do you index documents?

00:16:49.720 --> 00:16:54.540
Essentially, you access the
index by the index name.

00:16:54.540 --> 00:16:59.450
If that index is not already in
the cache or has not been

00:16:59.450 --> 00:17:04.860
created, you then create the
index using the metadata.

00:17:04.860 --> 00:17:07.349
So you're specifying
the index name and

00:17:07.349 --> 00:17:08.599
the consistency level.

00:17:11.160 --> 00:17:14.310
Once you have the index, you
can add each index, each

00:17:14.310 --> 00:17:18.117
document, or you can do a bulk
index of all your documents.

00:17:22.230 --> 00:17:26.000
So the Java is pretty much the
same except you're using the

00:17:26.000 --> 00:17:28.980
factory to get the index
to create it.

00:17:28.980 --> 00:17:30.580
And then you're using
a builder to

00:17:30.580 --> 00:17:32.930
construct the metadata.

00:17:32.930 --> 00:17:36.610
Otherwise you just, again, can
iterate through the documents

00:17:36.610 --> 00:17:37.510
and index them.

00:17:37.510 --> 00:17:38.760
Or you can do a bulk index.

00:17:42.480 --> 00:17:48.130
So as shown in the
demonstration, we had some of

00:17:48.130 --> 00:17:49.936
the queries you could support.

00:17:49.936 --> 00:17:52.390
So, simple terms like hello.

00:17:52.390 --> 00:17:55.160
Phrases, so where you care
about the order.

00:17:55.160 --> 00:18:01.890
And whether they're adjacent,
logical searches, using and,

00:18:01.890 --> 00:18:03.590
or, and not.

00:18:03.590 --> 00:18:06.360
Or you can restrict search
to particular fields.

00:18:06.360 --> 00:18:11.332
Like find all the comments
written by Bob in this case.

00:18:11.332 --> 00:18:14.022
So you can do closed
intervals.

00:18:14.022 --> 00:18:18.160
So find all comments
published up to and

00:18:18.160 --> 00:18:20.950
including the 1st of May.

00:18:20.950 --> 00:18:22.940
Or you can do exclusive
ranges.

00:18:22.940 --> 00:18:23.820
Open intervals.

00:18:23.820 --> 00:18:28.170
So find all the products priced
between $100 and $200,

00:18:28.170 --> 00:18:32.690
but not including
$100 and $200.

00:18:32.690 --> 00:18:37.310
So for search, again,
you get the index.

00:18:37.310 --> 00:18:40.060
You search.

00:18:40.060 --> 00:18:44.490
You could either construct this
query from some source,

00:18:44.490 --> 00:18:46.390
or you could just enter
the string.

00:18:46.390 --> 00:18:48.920
In our case, we would have just
taken the string the user

00:18:48.920 --> 00:18:53.140
entered, and then we would
get a search response.

00:18:53.140 --> 00:18:56.660
The search response contains
things like the number of

00:18:56.660 --> 00:19:03.635
documents matched, the actual
count in returned documents,

00:19:03.635 --> 00:19:06.550
the documents--

00:19:06.550 --> 00:19:09.850
and you essentially iterate
through that response to get

00:19:09.850 --> 00:19:13.450
the results and get each
document and their scores.

00:19:17.370 --> 00:19:20.720
The Java is pretty similar.

00:19:20.720 --> 00:19:22.260
Again, you get the index.

00:19:22.260 --> 00:19:24.250
You get a search response
when you issue the

00:19:24.250 --> 00:19:27.550
query to the index.

00:19:27.550 --> 00:19:31.140
And then you iterate and get
back search results, which

00:19:31.140 --> 00:19:33.238
contain, amongst other
things, the document.

00:19:36.990 --> 00:19:38.890
Some of the other features that
we didn't show in the

00:19:38.890 --> 00:19:40.940
demonstration were things
like snippeting.

00:19:40.940 --> 00:19:44.360
So, in fact, this technology
was sitting

00:19:44.360 --> 00:19:45.690
behind Wave as well.

00:19:48.820 --> 00:19:52.590
Here we have Sydney karaoke
as the query issued.

00:19:52.590 --> 00:19:56.030
And snippet is basically giving
you the context of

00:19:56.030 --> 00:20:00.140
where the best matches
in the text are.

00:20:00.140 --> 00:20:03.960
And so, for example, here it
found karaoke and Sydney

00:20:03.960 --> 00:20:11.710
together in a short segment of
text out of this Wave. And by

00:20:11.710 --> 00:20:16.370
default it would give you back
snippets up to 160 characters,

00:20:16.370 --> 00:20:19.400
and at most three snippets.

00:20:19.400 --> 00:20:24.090
So you can build some small
representation of the document

00:20:24.090 --> 00:20:28.870
that you wanted showing
results.

00:20:28.870 --> 00:20:33.090
So to do snippeting, essentially
you issue a search

00:20:33.090 --> 00:20:36.210
request. You have the query.

00:20:36.210 --> 00:20:38.460
And then you just indicate
which fields

00:20:38.460 --> 00:20:40.346
that you want to snippet.

00:20:47.320 --> 00:20:53.740
So some of the other features
are paging and cursors.

00:20:53.740 --> 00:20:58.310
So for paging, it's typical
where you'd give an index of

00:20:58.310 --> 00:21:00.240
the results on the
different pages.

00:21:00.240 --> 00:21:04.400
And people randomly access
those results.

00:21:04.400 --> 00:21:09.960
So if I click on page five, for
example, then I have to

00:21:09.960 --> 00:21:10.685
give an offset.

00:21:10.685 --> 00:21:15.150
So if there's 20 results per
page, then I'll want to start

00:21:15.150 --> 00:21:20.180
at result offset 100.

00:21:20.180 --> 00:21:22.880
And the limit will be 20.

00:21:22.880 --> 00:21:25.490
So there's a bit of a
performance hit with this

00:21:25.490 --> 00:21:29.300
because it has to compute that
set of results up to the page

00:21:29.300 --> 00:21:30.790
five plus the next page.

00:21:36.450 --> 00:21:38.290
Alternatively, you can
use cursors, which

00:21:38.290 --> 00:21:40.770
is much more efficient.

00:21:40.770 --> 00:21:46.716
Which is the next page or more
mechanism that you see on a

00:21:46.716 --> 00:21:47.966
lot of websites.

00:21:50.320 --> 00:21:56.710
And cursors can be per result or
per search request. So you

00:21:56.710 --> 00:21:58.930
can put links on each result,
or you can put it

00:21:58.930 --> 00:22:00.766
on the whole page.

00:22:00.766 --> 00:22:07.670
So the first time you issue the
search, you'll specify.

00:22:07.670 --> 00:22:10.280
In this case, I'll
want a cursor per

00:22:10.280 --> 00:22:13.630
page, so a single cursor.

00:22:13.630 --> 00:22:18.880
And I'll return 20 results.

00:22:18.880 --> 00:22:22.470
When they click on the next
link or the more button or

00:22:22.470 --> 00:22:30.060
whatever, they will then issue
this request, which says, OK,

00:22:30.060 --> 00:22:32.090
this has the cursor here.

00:22:32.090 --> 00:22:33.790
And I want--

00:22:33.790 --> 00:22:36.625
again, I'll want another cursor
for another next page

00:22:36.625 --> 00:22:38.690
plus 20 results from
that cursor.

00:22:42.200 --> 00:22:43.210
And then it's over to Bo.

00:22:43.210 --> 00:22:44.460
BO MAJEWSKI: All right.

00:22:47.870 --> 00:22:50.150
So once you get all the results
you probably want to

00:22:50.150 --> 00:22:53.320
show in the most relevant
order to the

00:22:53.320 --> 00:22:56.100
people who are searching.

00:22:56.100 --> 00:23:00.070
As Ged mentioned, by default
we are sorting by order ID.

00:23:00.070 --> 00:23:03.030
These are either default sort,
which comes pretty much for

00:23:03.030 --> 00:23:06.410
free because we store
them in that order.

00:23:06.410 --> 00:23:10.250
Or it is the sort that is being
used even if you specify

00:23:10.250 --> 00:23:13.630
alternative sorting orders.

00:23:13.630 --> 00:23:19.290
So what you see here is the
documents ordered by time.

00:23:19.290 --> 00:23:21.770
And I can change it.

00:23:21.770 --> 00:23:24.700
At the moment, this is a very
simple application, so I can

00:23:24.700 --> 00:23:27.280
change it to author.

00:23:27.280 --> 00:23:30.390
If author is descending,
I come on top.

00:23:30.390 --> 00:23:32.660
And then on the subsequent
pages Ged and

00:23:32.660 --> 00:23:34.600
anonymous will appear.

00:23:34.600 --> 00:23:37.710
You've authorized ascending,
then anonymous

00:23:37.710 --> 00:23:38.745
bubbles to the top.

00:23:38.745 --> 00:23:41.470
And anonymous-- we made a lot
of comments as anonymous, so

00:23:41.470 --> 00:23:44.260
probably around page three
Ged will appear.

00:23:44.260 --> 00:23:46.330
OK.

00:23:46.330 --> 00:23:51.890
But you can also do some more
complicated sorting orders.

00:23:51.890 --> 00:23:53.210
The other way of--

00:23:53.210 --> 00:23:55.790
I'm going to talk about
it in a second--

00:23:55.790 --> 00:23:59.260
the other way of ordering
documents is by scoring them.

00:24:02.670 --> 00:24:06.170
Typically, when you search on
a website, you get documents

00:24:06.170 --> 00:24:07.350
that are most relevant.

00:24:07.350 --> 00:24:10.415
So entertained.

00:24:10.415 --> 00:24:12.500
Let's search for entertained.

00:24:12.500 --> 00:24:16.240
So this is ordered by relevance,
but we can--

00:24:16.240 --> 00:24:18.090
by relevance and time.

00:24:18.090 --> 00:24:22.720
We can also have a simpler
scorer, which is a hit count,

00:24:22.720 --> 00:24:26.220
which essentially will count
only the number of hits.

00:24:26.220 --> 00:24:29.210
And in this case, they are
inverted because simply the

00:24:29.210 --> 00:24:32.200
second phrase had more
occurrences of "are you

00:24:32.200 --> 00:24:34.280
entertained" than
the first one.

00:24:34.280 --> 00:24:36.840
So let me give you some
more details on that.

00:24:41.470 --> 00:24:44.220
As I mentioned, the default
order is order ID.

00:24:44.220 --> 00:24:48.270
If you don't assign anything to
it, the number of seconds

00:24:48.270 --> 00:24:49.840
is assigned, so consequently--

00:24:49.840 --> 00:24:54.420
because we return documents in
descending order by default of

00:24:54.420 --> 00:24:56.870
order ID-- you get the freshest
documents first, the

00:24:56.870 --> 00:24:58.530
oldest last.

00:24:58.530 --> 00:25:02.180
You can actually override this
document if you know how to

00:25:02.180 --> 00:25:06.860
create an order from some sort
of field to a magical integer.

00:25:06.860 --> 00:25:07.870
You are free to do that.

00:25:07.870 --> 00:25:11.170
And this will provide high
performance and pretty much 0

00:25:11.170 --> 00:25:12.930
cost for your application.

00:25:12.930 --> 00:25:16.440
Alternatively you can, in a
search query, search request.

00:25:16.440 --> 00:25:18.890
You can say, well, I
would like to order

00:25:18.890 --> 00:25:20.590
some different order.

00:25:20.590 --> 00:25:22.350
And you just provide sorting
specification.

00:25:22.350 --> 00:25:23.630
You can sort on multiple
fields.

00:25:23.630 --> 00:25:28.270
In this case, we are sorting
by author, and the sort is

00:25:28.270 --> 00:25:28.875
descending.

00:25:28.875 --> 00:25:30.910
We also provide the
default value.

00:25:30.910 --> 00:25:33.860
That means if we don't have
the author in a given

00:25:33.860 --> 00:25:37.240
document, use this value, which
causes the document

00:25:37.240 --> 00:25:40.200
either to bubble to the
top or to the bottom.

00:25:40.200 --> 00:25:42.560
Once we sort them
by authors, the

00:25:42.560 --> 00:25:43.930
secondary field is comment.

00:25:43.930 --> 00:25:48.780
So all documents with the same
author of course will go into

00:25:48.780 --> 00:25:49.600
the same batch.

00:25:49.600 --> 00:25:51.700
And then the secondary
sort is applied.

00:25:55.180 --> 00:25:58.380
You can use some of the more
complicated expressions.

00:25:58.380 --> 00:26:01.380
So we just don't limit you
to the individual field.

00:26:01.380 --> 00:26:05.810
You can use regular operators
of course depending on what

00:26:05.810 --> 00:26:10.290
sort of fields you have. On
numeric fields, you can use

00:26:10.290 --> 00:26:11.700
multiplication, addition.

00:26:11.700 --> 00:26:14.200
You can use conditional
operators.

00:26:14.200 --> 00:26:17.880
If something happened, then
assign this sort of score.

00:26:17.880 --> 00:26:19.370
Otherwise assign this.

00:26:19.370 --> 00:26:21.490
And you can use a bunch of
functions like maximum,

00:26:21.490 --> 00:26:23.800
minimum, logarithm, et cetera.

00:26:23.800 --> 00:26:25.390
Some examples here.

00:26:25.390 --> 00:26:29.090
If you want to sort by price
plus tax plus shipping to give

00:26:29.090 --> 00:26:32.290
people the total cost
of purchasing the

00:26:32.290 --> 00:26:33.900
item, you can do that.

00:26:33.900 --> 00:26:36.910
So you would include in a
sorting specification

00:26:36.910 --> 00:26:41.440
expression, which is price
plus tax plus shipping at

00:26:41.440 --> 00:26:43.930
distance from a location.

00:26:43.930 --> 00:26:45.910
You can also construct
artificial fields.

00:26:45.910 --> 00:26:48.640
This is probably not for
sorting, but you can actually

00:26:48.640 --> 00:26:52.440
create artificial fields
by concatenating a

00:26:52.440 --> 00:26:56.350
bunch of other fields.

00:26:56.350 --> 00:26:58.420
Along with the sorting,
you also have

00:26:58.420 --> 00:27:00.920
access to custom scoring.

00:27:00.920 --> 00:27:02.330
You specify the custom score.

00:27:02.330 --> 00:27:03.680
And in this case, the
expression is

00:27:03.680 --> 00:27:05.720
maximum number of tags.

00:27:05.720 --> 00:27:08.130
Simply count the number of
fields that you have in a

00:27:08.130 --> 00:27:09.850
document with a given name.

00:27:09.850 --> 00:27:13.910
So it counts the number of
fields named tag and limits

00:27:13.910 --> 00:27:15.250
those to five.

00:27:15.250 --> 00:27:17.900
So then, all documents with
five, six and seven tags are

00:27:17.900 --> 00:27:19.220
considered the same.

00:27:19.220 --> 00:27:21.150
Everything else is sorted.

00:27:21.150 --> 00:27:25.620
If there are no tags in a given
document, the default

00:27:25.620 --> 00:27:29.170
value is used, which
is 0 in this case.

00:27:29.170 --> 00:27:32.160
With scoring, however,
there comes a caveat.

00:27:32.160 --> 00:27:35.210
We have to score a
lot of documents.

00:27:35.210 --> 00:27:38.080
If you don't tell
us how many--

00:27:38.080 --> 00:27:41.130
because we want to make sure
that we return you the highest

00:27:41.130 --> 00:27:43.930
scoring document-- so if you
are requesting about 20

00:27:43.930 --> 00:27:46.760
documents, probably limit
to about a 100

00:27:46.760 --> 00:27:47.800
where you want to score.

00:27:47.800 --> 00:27:51.110
So just use caution.

00:27:51.110 --> 00:27:54.060
Don't go crazy on us.

00:27:54.060 --> 00:27:56.730
You can also use the
default scorers.

00:27:56.730 --> 00:27:58.510
So we provide two default
scorers, match

00:27:58.510 --> 00:27:59.350
scorer and hit count.

00:27:59.350 --> 00:28:00.775
Hit count is mostly
for debugging.

00:28:00.775 --> 00:28:02.700
This is very simplistic.

00:28:02.700 --> 00:28:04.850
Match scorer is somewhat
more sophisticated.

00:28:04.850 --> 00:28:09.650
So if it uses the term
frequency, TF, times inverted

00:28:09.650 --> 00:28:11.120
document frequency.

00:28:11.120 --> 00:28:13.120
So essentially, term frequency
counts how many

00:28:13.120 --> 00:28:14.600
times the term occurs.

00:28:14.600 --> 00:28:19.000
And inverted document
frequency counts is

00:28:19.000 --> 00:28:23.000
proportional to how frequent
that term is on documents.

00:28:23.000 --> 00:28:26.240
So you have the word "the",
which is in every document

00:28:26.240 --> 00:28:30.130
that you have in a repository,
the IDF will be very low.

00:28:30.130 --> 00:28:34.310
And consequently it will
be scored low.

00:28:34.310 --> 00:28:37.840
Or if you have some terms that
occur multiple times on only a

00:28:37.840 --> 00:28:39.465
few documents, then that
score will be high.

00:28:39.465 --> 00:28:43.730
So this is a default one and
right out of the box.

00:28:43.730 --> 00:28:45.320
Hit count essentially
is just TF.

00:28:48.280 --> 00:28:50.170
Snippeting, Ged already
mentioned.

00:28:50.170 --> 00:28:53.090
We provide default snippeting,
but you also can control it.

00:28:53.090 --> 00:28:56.420
So use the snippet function,
which rather than getting the

00:28:56.420 --> 00:28:58.940
defaults, you can say, well,
the expression to return

00:28:58.940 --> 00:29:03.190
essentially the default snippet
is also an expression

00:29:03.190 --> 00:29:04.040
that we return.

00:29:04.040 --> 00:29:05.810
But here you control
it with a function.

00:29:05.810 --> 00:29:08.820
And you say, snippet
to return is based

00:29:08.820 --> 00:29:12.180
on field name comment.

00:29:12.180 --> 00:29:13.450
This time match just Sydney.

00:29:13.450 --> 00:29:15.950
Don't match karaoke.

00:29:15.950 --> 00:29:18.040
And limit 240 characters.

00:29:18.040 --> 00:29:21.710
The last parameter one means you
want consecutive snippets.

00:29:21.710 --> 00:29:24.100
So don't take three pieces
of a text here.

00:29:24.100 --> 00:29:25.700
Just take a single
piece of a text.

00:29:25.700 --> 00:29:27.553
So you can take two pieces,
three pieces of a text, et

00:29:27.553 --> 00:29:31.390
cetera, per document.

00:29:31.390 --> 00:29:32.480
OK.

00:29:32.480 --> 00:29:35.550
The original Issue 217 actually

00:29:35.550 --> 00:29:37.200
was filed about Datastore.

00:29:37.200 --> 00:29:39.240
So you might be wondering
what are we doing

00:29:39.240 --> 00:29:40.990
with all these documents?

00:29:40.990 --> 00:29:44.320
And the documents is essentially
something that

00:29:44.320 --> 00:29:45.420
gives you full control.

00:29:45.420 --> 00:29:48.640
If you have data stored
somewhere else in Datastore,

00:29:48.640 --> 00:29:50.110
you probably want to
use documents.

00:29:50.110 --> 00:29:53.910
If you have concerns about
privacy or revealing secret

00:29:53.910 --> 00:29:57.420
information or whatever, use
your documents and create

00:29:57.420 --> 00:30:01.240
something that's searchable and
points back to the actual

00:30:01.240 --> 00:30:05.140
data that you want
the user to find.

00:30:05.140 --> 00:30:07.450
However, if you store in
Datastore, this is

00:30:07.450 --> 00:30:08.700
the section for you.

00:30:10.840 --> 00:30:13.770
So this is the second part
of the architecture.

00:30:13.770 --> 00:30:15.630
Rather than operating
on documents,

00:30:15.630 --> 00:30:17.030
you operate on entities.

00:30:17.030 --> 00:30:21.920
So now, rather than doing index
document calls, you

00:30:21.920 --> 00:30:24.052
simply do entity put.

00:30:24.052 --> 00:30:26.270
And there are two
possible paths.

00:30:26.270 --> 00:30:30.060
One is it goes to the Datastore
and, under the hood,

00:30:30.060 --> 00:30:34.450
generates a document for you,
stores that document, and in

00:30:34.450 --> 00:30:35.850
that document it remembers
which entity it

00:30:35.850 --> 00:30:38.230
was generated from.

00:30:38.230 --> 00:30:41.730
Then it'll have appropriate way
of matching that document

00:30:41.730 --> 00:30:44.150
with the entity when you
execute that search.

00:30:44.150 --> 00:30:48.830
The other path uses Task Queue,
which will allow you to

00:30:48.830 --> 00:30:50.610
actually do some extra
modifications.

00:30:50.610 --> 00:30:56.890
So we also will give you
somewhat the freedom to

00:30:56.890 --> 00:30:59.640
generate these documents
freely, without your

00:30:59.640 --> 00:31:02.030
intervention, but later,
modify them.

00:31:02.030 --> 00:31:05.710
Let me give you a more
detailed description.

00:31:05.710 --> 00:31:10.850
By default, we are not going
to change the behavior of

00:31:10.850 --> 00:31:12.110
Datastore entities.

00:31:12.110 --> 00:31:17.340
So if you have a Datastore
entity, it has no full-text

00:31:17.340 --> 00:31:22.790
search capabilities until you
annotate the properties of

00:31:22.790 --> 00:31:25.730
that entity with search type.

00:31:25.730 --> 00:31:31.570
And in this case, I have the
greeting, which is also this

00:31:31.570 --> 00:31:34.620
guest book application entity.

00:31:34.620 --> 00:31:36.920
And the author is annotated
with a search type Atom.

00:31:36.920 --> 00:31:38.880
Meaning we'll not modify it.

00:31:38.880 --> 00:31:42.280
We'll just take it as is without
further tokenization.

00:31:42.280 --> 00:31:47.180
Comment will take it, but
will treat this as HTML.

00:31:47.180 --> 00:31:52.330
And in this case, date is not
being indexed at all.

00:31:52.330 --> 00:31:55.130
If you wanted the application
like we had, you probably

00:31:55.130 --> 00:31:57.520
would have to create--

00:31:57.520 --> 00:32:01.180
annotate the date as well
with type searchable,

00:32:01.180 --> 00:32:05.130
with a search type.

00:32:05.130 --> 00:32:07.240
And now we have these
two modes.

00:32:07.240 --> 00:32:09.365
One is the what we call
fully automatic mode.

00:32:09.365 --> 00:32:12.790
So essentially now you
execute a put.

00:32:12.790 --> 00:32:14.600
And what happens is, in the

00:32:14.600 --> 00:32:16.500
background, we generate document.

00:32:16.500 --> 00:32:18.880
We store it in Megastore
and remember which

00:32:18.880 --> 00:32:21.330
entity it came from.

00:32:21.330 --> 00:32:25.380
In order to preserve the same
parameters, latency

00:32:25.380 --> 00:32:27.560
parameters, as you had
on Datastore, you can

00:32:27.560 --> 00:32:28.430
do it in two ways.

00:32:28.430 --> 00:32:32.000
You can either tell us just
to put the entity.

00:32:32.000 --> 00:32:37.290
And in that case we'll just
both write the entity and

00:32:37.290 --> 00:32:39.025
write the document on the
same transaction.

00:32:39.025 --> 00:32:42.620
So either both are committed
or nothing is committed.

00:32:42.620 --> 00:32:46.130
Or you can say the search
index mode that is

00:32:46.130 --> 00:32:47.440
asynchronous right.

00:32:47.440 --> 00:32:50.440
What that means is, we will
generate the document, but

00:32:50.440 --> 00:32:53.465
we'll return as soon
as the entity has

00:32:53.465 --> 00:32:55.830
been stored in Datastore.

00:32:55.830 --> 00:32:58.340
In the background, we
are going to start

00:32:58.340 --> 00:32:59.750
processing the document.

00:32:59.750 --> 00:33:01.555
And we'll guarantee the
eventual consistency.

00:33:01.555 --> 00:33:04.030
So eventually that document
will be committed to a

00:33:04.030 --> 00:33:05.620
full-text search index.

00:33:05.620 --> 00:33:09.300
But it does not mean the moment
you put call returned,

00:33:09.300 --> 00:33:12.520
you will be able to search
using full-text search.

00:33:12.520 --> 00:33:15.260
Depending on which one you want,
you either want the same

00:33:15.260 --> 00:33:18.290
performance or immediate
full-text search, you can use

00:33:18.290 --> 00:33:20.310
one or the other.

00:33:20.310 --> 00:33:23.640
There is a semi-automatic
mode, which allows you

00:33:23.640 --> 00:33:25.180
intervention.

00:33:25.180 --> 00:33:28.730
So in a most drastic approach,
you say, generate the

00:33:28.730 --> 00:33:31.870
document, but don't do
anything with it.

00:33:31.870 --> 00:33:33.960
Instead give it back
to my handler.

00:33:33.960 --> 00:33:36.020
So you specify search
index mode, none--

00:33:36.020 --> 00:33:38.910
which means we don't write
it, we just generate it--

00:33:38.910 --> 00:33:43.220
and you specify the handler on
which we'll call you with a

00:33:43.220 --> 00:33:44.650
serialized document.

00:33:44.650 --> 00:33:47.620
What that allows you is further
modify the document.

00:33:47.620 --> 00:33:50.670
The application that Ged was
showing you, for example, was

00:33:50.670 --> 00:33:54.710
analyzing the comment field
and was extracting the

00:33:54.710 --> 00:33:57.220
hashtags and was extracting
shout outs.

00:33:57.220 --> 00:33:59.740
If you want to do that, this is
probably the mode in which

00:33:59.740 --> 00:34:02.970
you would operate.

00:34:02.970 --> 00:34:06.610
There is also a semi-automatic
mode, which is a combination

00:34:06.610 --> 00:34:11.610
of fully automatic and
no-write mode.

00:34:11.610 --> 00:34:15.630
In which case you simply allow
us to write the document, but

00:34:15.630 --> 00:34:16.980
also give us a handler.

00:34:16.980 --> 00:34:18.120
What you do with it?

00:34:18.120 --> 00:34:18.790
It's up to you.

00:34:18.790 --> 00:34:23.545
You can either monitor,
log, whatever.

00:34:23.545 --> 00:34:27.370
The searching is done by
providing one extra method,

00:34:27.370 --> 00:34:30.679
which is matches, which
takes a query.

00:34:30.679 --> 00:34:33.710
And essentially the way it
works is it goes to the

00:34:33.710 --> 00:34:37.429
document index, finds all the
matching documents, and

00:34:37.429 --> 00:34:39.664
performs the intersection with
other parts of the query.

00:34:39.664 --> 00:34:41.909
So it gives you only things
that match the full-text

00:34:41.909 --> 00:34:44.699
search plus other limitations
you gave on the query.

00:34:47.357 --> 00:34:52.260
The final part is
the REST API.

00:34:52.260 --> 00:34:56.820
We pretty much are going to
follow the somewhat standard

00:34:56.820 --> 00:34:59.570
convention of noun, selector,
noun, selector.

00:34:59.570 --> 00:35:01.760
All nouns are plural.

00:35:01.760 --> 00:35:05.150
Selectors are IDs of either
indexes or documents.

00:35:05.150 --> 00:35:09.461
At the moment, we only have used
three methods, get, post,

00:35:09.461 --> 00:35:10.320
and delete.

00:35:10.320 --> 00:35:12.360
Now, I have to give a caveat.

00:35:12.360 --> 00:35:13.230
This may change.

00:35:13.230 --> 00:35:16.470
This is very early stages
of this implementation.

00:35:16.470 --> 00:35:19.880
You've used, say, /indexes, and
you give us a get method.

00:35:19.880 --> 00:35:23.040
We give you method about
all your indexes.

00:35:23.040 --> 00:35:25.450
The first selector is
the index name.

00:35:25.450 --> 00:35:29.860
So on the get, you get the
metadata about that index.

00:35:29.860 --> 00:35:32.570
On post, you create
that index.

00:35:32.570 --> 00:35:36.410
The parameters of the index,
like consistency and version,

00:35:36.410 --> 00:35:38.120
all that sort of stuff, you
would specify after the

00:35:38.120 --> 00:35:39.600
question mark.

00:35:39.600 --> 00:35:42.790
On delete, you delete all
documents from the index and

00:35:42.790 --> 00:35:45.540
delete the index itself.

00:35:45.540 --> 00:35:47.450
Second noun is docs.

00:35:47.450 --> 00:35:53.410
So if you execute a HTTP get
with /index is A/docs.

00:35:53.410 --> 00:35:56.440
You'll get all documents
from index A.

00:35:56.440 --> 00:35:58.260
Post method does nothing.

00:35:58.260 --> 00:36:02.380
And delete deletes all docs,
but it retains your index.

00:36:02.380 --> 00:36:06.580
You can actually limit which
documents you will delete by

00:36:06.580 --> 00:36:08.630
specifying further query after
the question mark.

00:36:08.630 --> 00:36:11.410
So then, in that case, it
means delete from A all

00:36:11.410 --> 00:36:14.380
documents that match
given query.

00:36:14.380 --> 00:36:17.165
And the final selector
is the document ID.

00:36:17.165 --> 00:36:20.770
So again, /index is
/A, /docs is X.

00:36:20.770 --> 00:36:24.580
Select the document
X from get.

00:36:24.580 --> 00:36:27.730
And post, you create the
document, and you specify the

00:36:27.730 --> 00:36:30.910
fields of the question marks
of the parameter.

00:36:30.910 --> 00:36:33.990
And on delete, you delete
that specific document.

00:36:33.990 --> 00:36:37.690
Versions are supported by
prefixing all the URLs with

00:36:37.690 --> 00:36:39.540
appropriate V1, V2, et cetera.

00:36:39.540 --> 00:36:43.740
As you might guess, at the
moment, it's like V.01.

00:36:43.740 --> 00:36:45.500
Well, V1.

00:36:45.500 --> 00:36:49.680
Pagination is supported by
offset limits and format by

00:36:49.680 --> 00:36:53.880
appending the format
name to the noun.

00:36:56.760 --> 00:37:01.100
In terms of a road map, I have
to be very careful, because

00:37:01.100 --> 00:37:03.320
Mick, our Product Manager, is
watching me carefully what I'm

00:37:03.320 --> 00:37:06.090
going to say here.

00:37:06.090 --> 00:37:09.020
At the moment, we are just
telling you what we are

00:37:09.020 --> 00:37:09.490
working on.

00:37:09.490 --> 00:37:13.410
It actually works, despite
Mick's piercing eyes.

00:37:13.410 --> 00:37:15.210
It works.

00:37:15.210 --> 00:37:17.820
But we are going to invite
you to give us feedback.

00:37:17.820 --> 00:37:18.970
I mean, what is missing?

00:37:18.970 --> 00:37:19.730
What would you change?

00:37:19.730 --> 00:37:22.660
What would you like to see?

00:37:22.660 --> 00:37:24.920
A lot of you voted
on Issue 217.

00:37:24.920 --> 00:37:28.960
We hope that a lot of these
people who are interested in

00:37:28.960 --> 00:37:31.900
full-text search can give us
the feedback before we

00:37:31.900 --> 00:37:33.370
completely nail the API.

00:37:33.370 --> 00:37:36.500
At the moment it's fairly
stable, but we still invite

00:37:36.500 --> 00:37:37.910
the feedback.

00:37:37.910 --> 00:37:38.910
The first thing that
we're going to

00:37:38.910 --> 00:37:41.670
release is the core API.

00:37:41.670 --> 00:37:45.795
So this is the part that Ged was
talking about, where you

00:37:45.795 --> 00:37:47.980
will have to generate
your own documents.

00:37:47.980 --> 00:37:50.950
And you will have the freedom
of how you do it, but the

00:37:50.950 --> 00:37:53.270
additional programming expenses
of having to do it.

00:37:55.960 --> 00:37:59.380
Subsequently, the Datastore API
is going to be released,

00:37:59.380 --> 00:38:02.270
in which case you will then have
these fully automatic and

00:38:02.270 --> 00:38:04.720
semi-automatic methods
available.

00:38:04.720 --> 00:38:09.090
And further down the line
is the REST API.

00:38:09.090 --> 00:38:15.660
OK, to sum it up, you were given
an overview of what is

00:38:15.660 --> 00:38:17.090
coming in the full-text
search.

00:38:17.090 --> 00:38:21.740
Stand-alone text search coming
first. Full integration with

00:38:21.740 --> 00:38:25.630
Datastore and the REST
API coming next.

00:38:25.630 --> 00:38:27.500
And I guess we have
20 minutes.

00:38:27.500 --> 00:38:29.530
So if there are any questions,
we'll just open the floor to

00:38:29.530 --> 00:38:30.290
the questions.

00:38:30.290 --> 00:38:32.450
And please use the
mics on the other

00:38:32.450 --> 00:38:33.530
side, so they get recorded.

00:38:33.530 --> 00:38:34.780
[APPLAUSE]

00:38:41.894 --> 00:38:42.890
BO MAJEWSKI: Yes?

00:38:42.890 --> 00:38:43.789
SPEAKER 1: All right.

00:38:43.789 --> 00:38:47.142
So I have an app that has many
different customers in the

00:38:47.142 --> 00:38:49.770
same Datastore.

00:38:49.770 --> 00:38:53.035
All of my entities are keyed
on the customer ID field.

00:38:53.035 --> 00:38:55.857
And I search on that
in all my queries.

00:38:55.857 --> 00:38:58.092
How do I do the same thing
with full-text search?

00:38:58.092 --> 00:39:00.526
Do I use the thing
to make multiple

00:39:00.526 --> 00:39:02.286
indexes, one per customer?

00:39:02.286 --> 00:39:06.667
Do I also add the same kind of
field to all of my full-text

00:39:06.667 --> 00:39:07.365
search variables?

00:39:07.365 --> 00:39:09.970
What's the right way
to go about this?

00:39:09.970 --> 00:39:12.310
Will there be a multi-tenant
space in the name space in the

00:39:12.310 --> 00:39:15.150
API added onto this?

00:39:15.150 --> 00:39:16.770
How does that work?

00:39:16.770 --> 00:39:18.530
BO MAJEWSKI: So the
recommendation would be to

00:39:18.530 --> 00:39:22.130
indeed have index per customer
because you have the freedom.

00:39:22.130 --> 00:39:26.110
I mean, we don't limit how many
indexes you have. At the

00:39:26.110 --> 00:39:29.650
moment there are some
rudimentary limits put in

00:39:29.650 --> 00:39:32.920
place, so you cannot create
millions of them in one day

00:39:32.920 --> 00:39:35.070
because then we think there's
something wrong with the

00:39:35.070 --> 00:39:36.840
application.

00:39:36.840 --> 00:39:42.260
But in order to fully isolate
them, I would recommend using

00:39:42.260 --> 00:39:44.680
customer name or some sort of
thing that identifies the

00:39:44.680 --> 00:39:47.160
customer as the index name.

00:39:47.160 --> 00:39:48.570
The reason for that is--

00:39:48.570 --> 00:39:51.410
and I didn't mention
it in the talk--

00:39:51.410 --> 00:39:57.550
we also plan to allow you, if
the customer says so, make the

00:39:57.550 --> 00:40:01.010
given index accessible to
other applications.

00:40:01.010 --> 00:40:03.200
So you can search it through
other applications.

00:40:03.200 --> 00:40:05.920
And then it would be easier just
to give that permission

00:40:05.920 --> 00:40:09.930
per index rather than having
to juggle all these things.

00:40:09.930 --> 00:40:15.600
So as far as we are concerned,
you can have thousands or tens

00:40:15.600 --> 00:40:17.040
of thousands of indexes.

00:40:17.040 --> 00:40:17.230
SPEAKER 1: OK.

00:40:17.230 --> 00:40:20.821
But that will require using the
lowest level of index to

00:40:20.821 --> 00:40:22.550
the search.

00:40:22.550 --> 00:40:26.020
I can't just go with my data
objects as they are.

00:40:26.020 --> 00:40:27.010
BO MAJEWSKI: No.

00:40:27.010 --> 00:40:27.555
At the moment--

00:40:27.555 --> 00:40:28.660
SPEAKER 1: [UNINTELLIGIBLE]

00:40:28.660 --> 00:40:29.110
OK.

00:40:29.110 --> 00:40:31.510
BO MAJEWSKI: That's
a fair comment.

00:40:31.510 --> 00:40:33.870
And we can think about it,
how we would do it.

00:40:33.870 --> 00:40:35.550
But there are some limits.

00:40:35.550 --> 00:40:36.550
I mean, at the moment, we--

00:40:36.550 --> 00:40:38.860
actually on Datastore
integration, we want to return

00:40:38.860 --> 00:40:42.252
you all entities of a
given type and so.

00:40:42.252 --> 00:40:43.240
SPEAKER 1: No, that's fine.

00:40:43.240 --> 00:40:43.442
It'll take time.

00:40:43.442 --> 00:40:44.452
It's pretty easy
to go that way.

00:40:44.452 --> 00:40:45.260
Thanks.

00:40:45.260 --> 00:40:47.434
BO MAJEWSKI: Sure.

00:40:47.434 --> 00:40:48.420
SPEAKER 2: A couple of things.

00:40:48.420 --> 00:40:52.201
Do you have the ability to mark
fields, certain fields,

00:40:52.201 --> 00:40:55.990
as more important in terms
of the scoring?

00:40:55.990 --> 00:40:57.200
BO MAJEWSKI: Ged?

00:40:57.200 --> 00:40:58.230
GED ELLIS: There is--

00:40:58.230 --> 00:40:58.630
yeah.

00:40:58.630 --> 00:40:59.990
Field match boosts.

00:40:59.990 --> 00:41:00.685
So you can put--

00:41:00.685 --> 00:41:02.695
yeah, yeah, there's boosts
for field matching.

00:41:02.695 --> 00:41:03.664
Yeah.

00:41:03.664 --> 00:41:05.806
SPEAKER 2: And then,
fuzzy matching?

00:41:05.806 --> 00:41:07.710
For misspellings?

00:41:07.710 --> 00:41:07.960
BO MAJEWSKI: OK.

00:41:07.960 --> 00:41:14.420
So we do stemming synonyms
and diacriticals.

00:41:14.420 --> 00:41:15.900
But this is done at
the query time.

00:41:15.900 --> 00:41:20.520
So if you want to match
something--

00:41:20.520 --> 00:41:22.954
prefix matching, or
fuzzy matching?

00:41:22.954 --> 00:41:24.890
SPEAKER 2: Um, yes.

00:41:24.890 --> 00:41:25.150
BO MAJEWSKI: OK.

00:41:25.150 --> 00:41:26.140
Yes.

00:41:26.140 --> 00:41:31.500
So I'll say yes to
the first half.

00:41:31.500 --> 00:41:35.880
Essentially, our approach
to stemming synonyms and

00:41:35.880 --> 00:41:38.000
diacriticals is that it's better
to do it at a query

00:41:38.000 --> 00:41:43.150
time because these
thing change.

00:41:43.150 --> 00:41:45.200
We actually live in Australia.

00:41:45.200 --> 00:41:47.500
And there was like Kevin '07
was the slogan, right?

00:41:47.500 --> 00:41:49.630
And if you have Kevin--

00:41:49.630 --> 00:41:53.990
if you enter two terms, Kevin
'07, then we in 2007 would

00:41:53.990 --> 00:41:56.760
have realized that you're
talking about a particular

00:41:56.760 --> 00:41:59.660
guy, Kevin Rudd.

00:41:59.660 --> 00:42:02.200
Probably in 2004 it
was not relevant.

00:42:02.200 --> 00:42:04.970
So you don't want to recompute
your index based on the year,

00:42:04.970 --> 00:42:05.950
what is popular in a year.

00:42:05.950 --> 00:42:11.580
So the additional processing is
done during the query time.

00:42:11.580 --> 00:42:16.010
However, at this time, we
don't have anything that

00:42:16.010 --> 00:42:18.935
allows you to say, anything
that starts with full.

00:42:18.935 --> 00:42:21.700
And give me all these results.

00:42:21.700 --> 00:42:26.410
That is one of the actually more
requested text search API

00:42:26.410 --> 00:42:32.015
features, but we haven't quite
nailed it at this point.

00:42:32.015 --> 00:42:35.330
SPEAKER 3: So this question is
about the industrial text

00:42:35.330 --> 00:42:37.020
search API.

00:42:37.020 --> 00:42:41.720
So if you have an entity in Java
or even Python, you have

00:42:41.720 --> 00:42:46.373
this-- what appears to be search
by document editor.

00:42:46.373 --> 00:42:49.241
It is an indication of how
we, in Python, use

00:42:49.241 --> 00:42:51.704
the different search.

00:42:51.704 --> 00:42:54.816
How do you search for normal
APIs [? in concrete ?]

00:42:54.816 --> 00:42:55.808
items?

00:42:55.808 --> 00:43:01.270
I mean, expand the models
of data [? stored? ?]

00:43:01.270 --> 00:43:04.760
BO MAJEWSKI: At the moment, we
just allow you to do the

00:43:04.760 --> 00:43:07.180
annotations on fields, right?

00:43:07.180 --> 00:43:10.650
But in what--

00:43:10.650 --> 00:43:12.100
expand the models?

00:43:12.100 --> 00:43:14.300
SPEAKER 3: I know that
web-based, you use cache

00:43:14.300 --> 00:43:15.550
management.

00:43:17.520 --> 00:43:20.350
BO MAJEWSKI: To be honest,
that part has not been

00:43:20.350 --> 00:43:21.330
implemented.

00:43:21.330 --> 00:43:27.570
So if Max is anywhere in the
audience, he can probably

00:43:27.570 --> 00:43:28.930
guess the answer.

00:43:28.930 --> 00:43:30.810
But at the moment--

00:43:30.810 --> 00:43:32.782
SPEAKER 4: So this API,
what's the objective?

00:43:32.782 --> 00:43:34.261
Is it the [UNINTELLIGIBLE]

00:43:34.261 --> 00:43:35.442
going to be exposed to us?

00:43:35.442 --> 00:43:36.597
If you [UNINTELLIGIBLE]

00:43:36.597 --> 00:43:37.670
the browser so that
[UNINTELLIGIBLE]

00:43:37.670 --> 00:43:40.700
only be used within the context
of my application?

00:43:40.700 --> 00:43:44.983
And if so, can I get only the
pointer, which is the ID to

00:43:44.983 --> 00:43:48.238
the entity and then have the
link, which the entity I came

00:43:48.238 --> 00:43:49.612
from led us to?

00:43:49.612 --> 00:43:52.590
What is the response
of the REST API?

00:43:52.590 --> 00:43:54.960
I have two parts.

00:43:54.960 --> 00:43:55.660
The [UNINTELLIGIBLE]

00:43:55.660 --> 00:43:56.158
from the browser.

00:43:56.158 --> 00:44:00.732
And the second part is, do
I get full entity data?

00:44:00.732 --> 00:44:02.510
Or should I have only the point
at which the reader

00:44:02.510 --> 00:44:03.940
[UNINTELLIGIBLE PHRASE]

00:44:03.940 --> 00:44:04.210
BO MAJEWSKI: Yeah.

00:44:04.210 --> 00:44:06.300
I can tell you all these
at the moment.

00:44:06.300 --> 00:44:07.510
So just the document.

00:44:07.510 --> 00:44:08.420
You get the document.

00:44:08.420 --> 00:44:15.520
And the main purpose of REST
API is to allow you to use

00:44:15.520 --> 00:44:18.460
what hopefully is the goodness
of our text search API, even

00:44:18.460 --> 00:44:21.590
if you don't have App
Engine application.

00:44:21.590 --> 00:44:26.200
So how--

00:44:26.200 --> 00:44:32.035
I'm not sure if returning
entities makes sense for

00:44:32.035 --> 00:44:32.450
application.

00:44:32.450 --> 00:44:34.350
Because it's meant for an
application that is not

00:44:34.350 --> 00:44:38.420
necessarily a App Engine
application.

00:44:38.420 --> 00:44:39.450
so

00:44:39.450 --> 00:44:41.730
SPEAKER 4: You mean the
browser or inside the

00:44:41.730 --> 00:44:45.980
applications App Engine
is configured?

00:44:45.980 --> 00:44:47.660
BO MAJEWSKI: No, I mean if you
made the request from a

00:44:47.660 --> 00:44:52.160
browser, and we gave you the
full entity, and you didn't

00:44:52.160 --> 00:44:56.570
have an App Engine
application.

00:44:56.570 --> 00:44:57.920
I know what--

00:44:57.920 --> 00:45:01.050
SPEAKER 4: You will have
authentication problems?

00:45:01.050 --> 00:45:02.130
BO MAJEWSKI: Yeah.

00:45:02.130 --> 00:45:06.610
I mean, authentication is
going follow the same

00:45:06.610 --> 00:45:09.350
principle that Task Queue
was following.

00:45:09.350 --> 00:45:09.805
So, yeah.

00:45:09.805 --> 00:45:10.260
SPEAKER 4: Oh OK.

00:45:10.260 --> 00:45:11.510
That's an administrative API.

00:45:14.749 --> 00:45:18.870
SPEAKER 5: You talked about
pagination and cursors.

00:45:18.870 --> 00:45:23.554
And I'm wondering if I'm using
a per document consistent

00:45:23.554 --> 00:45:28.368
index, and I do a search, are
those-- the cursors and

00:45:28.368 --> 00:45:32.195
pagination-- is that based on
a snapshot of what the index

00:45:32.195 --> 00:45:34.185
looks like when I
did my search?

00:45:34.185 --> 00:45:37.504
Or if things are being added to
that index, is it going to

00:45:37.504 --> 00:45:39.220
bump my search results around?

00:45:39.220 --> 00:45:42.380
GED ELLIS: The pagination
will be recomputed, so--

00:45:42.380 --> 00:45:45.230
sorry, yeah.

00:45:45.230 --> 00:45:46.700
The pagination will
be recomputed.

00:45:46.700 --> 00:45:49.230
But for the cursor, it's a
good question on that.

00:45:49.230 --> 00:45:51.360
I think it's actually-- we'll
take it from where

00:45:51.360 --> 00:45:52.550
it was at that time.

00:45:52.550 --> 00:45:53.420
BO MAJEWSKI: Well, yes.

00:45:53.420 --> 00:45:56.020
I mean, if you change the
document-- if I understand you

00:45:56.020 --> 00:45:56.560
correctly--

00:45:56.560 --> 00:45:58.900
if you change the document, you
will not impact it because

00:45:58.900 --> 00:46:00.760
the document ID stays
the same.

00:46:00.760 --> 00:46:02.892
GED ELLIS: No, but if you
added more results.

00:46:02.892 --> 00:46:03.993
SPEAKER 5: No, if I'm adding
more results, will it--

00:46:03.993 --> 00:46:07.030
GED ELLIS: So for the first
case, when it's using pages,

00:46:07.030 --> 00:46:09.610
it's going to recompute the
whole thing anyway.

00:46:09.610 --> 00:46:13.310
But for the cursor, I'm not sure
what happens actually.

00:46:13.310 --> 00:46:16.874
BO MAJEWSKI: We should
have tried it.

00:46:16.874 --> 00:46:18.300
SPEAKER 5: Can I send you an
email and get back to you?

00:46:18.300 --> 00:46:19.212
BO MAJEWSKI: Yeah, sure.

00:46:19.212 --> 00:46:21.990
GED ELLIS: Sure.

00:46:21.990 --> 00:46:24.590
SPEAKER 6: So I heard about
Python and Java hook-up.

00:46:27.180 --> 00:46:28.246
BO MAJEWSKI: Hm.

00:46:28.246 --> 00:46:29.910
We didn't talk to
the go people.

00:46:29.910 --> 00:46:31.540
GED ELLIS: They sit
next to us, so.

00:46:31.540 --> 00:46:33.432
SPEAKER 6: That's pretty bad.

00:46:33.432 --> 00:46:35.800
[UNINTELLIGIBLE PHRASE]

00:46:35.800 --> 00:46:37.350
GED ELLIS: Yeah.

00:46:37.350 --> 00:46:40.510
BO MAJEWSKI: Well, yes.

00:46:40.510 --> 00:46:44.180
We'll politely ask
them to do that.

00:46:44.180 --> 00:46:47.700
I mean, our back ends
are agnostic.

00:46:47.700 --> 00:46:50.060
We just use our PCs.

00:46:50.060 --> 00:46:53.060
And we just return our
protocol buffers.

00:46:53.060 --> 00:46:55.650
So hopefully they can create
the appropriate

00:46:55.650 --> 00:46:58.300
go object from it.

00:46:58.300 --> 00:47:03.760
Essentially what you see is
there is an RPC and in front

00:47:03.760 --> 00:47:09.480
of it sits a thin layer of Java
API or Python API that

00:47:09.480 --> 00:47:11.730
reconstructs the Python object
or the Java object.

00:47:11.730 --> 00:47:14.890
So I don't anticipate it's going
to be a major hassle to

00:47:14.890 --> 00:47:17.892
get a go going.

00:47:17.892 --> 00:47:20.332
SPEAKER 7: Another question
about data cursor.

00:47:20.332 --> 00:47:21.747
I noticed in your examples,
they were all

00:47:21.747 --> 00:47:23.490
next page, next page.

00:47:23.490 --> 00:47:25.335
Can you go to previous page?

00:47:25.335 --> 00:47:28.460
You know, like using
the data cursor?

00:47:28.460 --> 00:47:30.090
BO MAJEWSKI: You could, but
you would have to store it

00:47:30.090 --> 00:47:30.630
yourself, right?

00:47:30.630 --> 00:47:32.160
So we always give you
the next one.

00:47:32.160 --> 00:47:34.890
If you store it yourself, you
can actually do this.

00:47:34.890 --> 00:47:40.120
So essentially, for us, the
way we store documents in

00:47:40.120 --> 00:47:44.630
Megastore, the cursor tells
us the row from

00:47:44.630 --> 00:47:46.100
which to start scanning.

00:47:46.100 --> 00:47:46.925
That's all it is.

00:47:46.925 --> 00:47:49.610
So if you have it, we
can start scanning

00:47:49.610 --> 00:47:50.780
from earlier row.

00:47:50.780 --> 00:47:55.480
But in HTML applications, it's
kind of difficult because then

00:47:55.480 --> 00:47:56.710
you have to--

00:47:56.710 --> 00:47:59.480
if you're on page five, you have
to maintain cursors from

00:47:59.480 --> 00:48:00.650
the first four pages.

00:48:00.650 --> 00:48:05.550
So this is why we-- actually,
the application uses cursors

00:48:05.550 --> 00:48:10.270
rather than using paging because
we found out that we

00:48:10.270 --> 00:48:13.562
had to maintain them and
all that sort of stuff.

00:48:13.562 --> 00:48:14.920
SPEAKER 7: So is there a general
solution for that?

00:48:14.920 --> 00:48:16.196
Like everyone has to
do it themselves.

00:48:16.196 --> 00:48:18.459
And you're saying you have
to maintain all of it.

00:48:18.459 --> 00:48:19.600
But what if somebody--

00:48:19.600 --> 00:48:20.670
you have a thing that
says, page one,

00:48:20.670 --> 00:48:22.554
page two, page three.

00:48:22.554 --> 00:48:25.346
And they just want to
jump to page six.

00:48:25.346 --> 00:48:27.250
And I haven't gone
there before, so.

00:48:27.250 --> 00:48:28.880
BO MAJEWSKI: Yeah,
so in that case--

00:48:28.880 --> 00:48:30.664
GED ELLIS: In that case, you're
not using cursors.

00:48:30.664 --> 00:48:33.930
You're just using offsets so you
don't need to record that.

00:48:33.930 --> 00:48:37.350
You just give the page
number and the

00:48:37.350 --> 00:48:39.030
actual size of the page.

00:48:39.030 --> 00:48:41.190
You can randomly access
pages that way.

00:48:45.600 --> 00:48:49.071
SPEAKER 8: On the Datastore
API, is there anything

00:48:49.071 --> 00:48:49.470
[UNINTELLIGIBLE]

00:48:49.470 --> 00:48:55.570
including the reference
properties in a document?

00:48:55.570 --> 00:48:57.000
BO MAJEWSKI: Not at the moment,

00:48:57.000 --> 00:49:01.680
but again valid remark.

00:49:01.680 --> 00:49:04.160
We probably could just
do it by keys.

00:49:04.160 --> 00:49:08.430
So you could then extract
the documents by keys.

00:49:08.430 --> 00:49:10.640
At the moment, we didn't
implement it.

00:49:10.640 --> 00:49:13.378
So, no.

00:49:13.378 --> 00:49:13.866
SPEAKER 9: [? Could that be ?]

00:49:13.866 --> 00:49:15.330
used for a document
[INAUDIBLE]

00:49:19.352 --> 00:49:21.732
SPEAKER 8: Like if you have a
user reference property, you

00:49:21.732 --> 00:49:25.540
could-- most people might
want to search by user?

00:49:25.540 --> 00:49:26.940
BO MAJEWSKI: Yes.

00:49:26.940 --> 00:49:29.340
That would be somewhat
complicated.

00:49:29.340 --> 00:49:33.390
We would have to do multiple
traversal of the index.

00:49:33.390 --> 00:49:37.060
But by all means, send
us a feedback.

00:49:37.060 --> 00:49:41.900
And if we find that the raster
magicians can do it, why not?

00:49:45.127 --> 00:49:47.130
SPEAKER 10: I have
two questions.

00:49:47.130 --> 00:49:51.186
The first question is related
to the index space.

00:49:51.186 --> 00:49:54.936
How do you configure it,
and can you monitor it?

00:49:58.280 --> 00:50:00.440
BO MAJEWSKI: You will have in
your admin console the ability

00:50:00.440 --> 00:50:03.760
to look at all indexes that you
have. So there would be a

00:50:03.760 --> 00:50:05.590
list of all indexes your
application has.

00:50:05.590 --> 00:50:10.050
And then once you drill into
an index, you will have the

00:50:10.050 --> 00:50:12.695
metadata and--

00:50:12.695 --> 00:50:14.200
GED ELLIS: Things like
sizing and--

00:50:14.200 --> 00:50:14.290
BO MAJEWSKI: Yeah.

00:50:14.290 --> 00:50:16.360
Size of an index.

00:50:16.360 --> 00:50:18.890
I mean, at the moment, it's
not real-time updated.

00:50:18.890 --> 00:50:23.440
But it's probably going to be
like six hours lagging basic

00:50:23.440 --> 00:50:24.690
statistics about the index.

00:50:24.690 --> 00:50:26.750
Something like this.

00:50:26.750 --> 00:50:29.790
SPEAKER 10: I have one other
question probably related to

00:50:29.790 --> 00:50:31.460
the size question.

00:50:31.460 --> 00:50:32.970
Are there any [UNINTELLIGIBLE]

00:50:32.970 --> 00:50:34.896
on sharding and aggregation?

00:50:40.840 --> 00:50:42.200
BO MAJEWSKI: I'm not sure.

00:50:42.200 --> 00:50:46.370
So we actually shard
it internally.

00:50:46.370 --> 00:50:50.170
I don't think this is part
of an application.

00:50:50.170 --> 00:50:52.090
So once your index
grows large, you

00:50:52.090 --> 00:50:54.190
get spread over multiple--

00:50:54.190 --> 00:50:56.125
what we call them-- tablets.

00:50:56.125 --> 00:51:00.870
So we don't want you to do it
explicitly at the moment.

00:51:00.870 --> 00:51:03.010
It is done under the hood.

00:51:03.010 --> 00:51:05.210
GED ELLIS: And by aggregation,
you mean things like in the

00:51:05.210 --> 00:51:08.720
case of a user index, like an
inbox, you want to be able to

00:51:08.720 --> 00:51:10.625
search all inboxes, over
all inboxes or

00:51:10.625 --> 00:51:10.890
something like that?

00:51:10.890 --> 00:51:12.470
Is that what you mean?

00:51:12.470 --> 00:51:14.962
SPEAKER 10: Inboxes-- like
when you shard, you will

00:51:14.962 --> 00:51:17.170
probably going to search
across the shards and

00:51:17.170 --> 00:51:19.255
aggregate
[UNINTELLIGIBLE PHRASE]

00:51:19.255 --> 00:51:19.665
GED ELLIS: Yeah.

00:51:19.665 --> 00:51:20.450
It's already hemmed.

00:51:20.450 --> 00:51:21.700
Yeah.

00:51:24.630 --> 00:51:29.980
SPEAKER 11: The atom type, is
that just a short word for a

00:51:29.980 --> 00:51:31.370
token of this type?

00:51:31.370 --> 00:51:33.140
BO MAJEWSKI: Yeah.

00:51:33.140 --> 00:51:36.020
I have these weird preferences
of having

00:51:36.020 --> 00:51:37.330
words of the same length.

00:51:37.330 --> 00:51:42.100
So the first three that we did
was text, date, and then atom.

00:51:42.100 --> 00:51:43.770
They all had four characters.

00:51:47.610 --> 00:51:49.655
SPEAKER 12: If you have a field
that can change after

00:51:49.655 --> 00:51:52.465
the document is indexed,
do you have to

00:51:52.465 --> 00:51:54.127
re-index the whole document?

00:51:54.127 --> 00:51:57.015
Say, I left the user tag
in the document.

00:51:57.015 --> 00:51:58.265
GED ELLIS: It just
can't read it.

00:52:01.475 --> 00:52:04.220
SPEAKER 13: I might have just
missed this, but when is it

00:52:04.220 --> 00:52:08.280
available, and when will the
documentation be updated?

00:52:08.280 --> 00:52:09.410
BO MAJEWSKI: Where's
the person who--

00:52:09.410 --> 00:52:09.560
GED ELLIS: Dan.

00:52:09.560 --> 00:52:11.360
He's hiding down
the back there.

00:52:11.360 --> 00:52:13.634
BO MAJEWSKI: If you see like a
red mark on my chest, whatever

00:52:13.634 --> 00:52:17.010
I'm answering, that means I'm
answering wrong because--

00:52:17.010 --> 00:52:18.570
SPEAKER 13: Is that Dan
in the front row?

00:52:18.570 --> 00:52:20.790
BO MAJEWSKI: No, he's actually
in back because he's got a

00:52:20.790 --> 00:52:22.040
really long rifle.

00:52:25.140 --> 00:52:27.690
So apparently we are supposed
to say we are

00:52:27.690 --> 00:52:28.390
working very hard.

00:52:28.390 --> 00:52:29.770
It actually works.

00:52:29.770 --> 00:52:33.300
What you saw was no
smoke and mirrors.

00:52:33.300 --> 00:52:35.200
But there is a few production
issues that we

00:52:35.200 --> 00:52:37.330
need to push through.

00:52:37.330 --> 00:52:40.600
SPEAKER 13: Will you go
pre-release on the local

00:52:40.600 --> 00:52:41.850
before [UNINTELLIGIBLE PHRASE]

00:52:45.490 --> 00:52:46.700
BO MAJEWSKI: Again, I
have to judge his

00:52:46.700 --> 00:52:49.420
eyebrows from a distance.

00:52:49.420 --> 00:52:50.530
It's all going to
be announced.

00:52:50.530 --> 00:52:55.460
And Mickey's going
to kill me if I--

00:52:55.460 --> 00:53:00.390
you know, just one wrong
word, I'm dead.

00:53:00.390 --> 00:53:02.660
Yeah.

00:53:02.660 --> 00:53:02.960
Sorry.

00:53:02.960 --> 00:53:05.840
I know it's not a satisfactory
answer, but this guy is scary.

00:53:10.331 --> 00:53:11.329
SPEAKER 14: I just want
to say thank you.

00:53:11.329 --> 00:53:12.327
I love it.

00:53:12.327 --> 00:53:13.330
Thanks for doing it.

00:53:13.330 --> 00:53:13.770
BO MAJEWSKI: Thank you.

00:53:13.770 --> 00:53:15.020
[APPLAUSE]

00:53:19.770 --> 00:53:22.242
SPEAKER 15: I want to ask
about a shortening

00:53:22.242 --> 00:53:23.420
[UNINTELLIGIBLE PHRASE].

00:53:23.420 --> 00:53:26.001
How about a proximity search?

00:53:26.001 --> 00:53:31.046
For example, I have two
documents, ABC or ACB.

00:53:31.046 --> 00:53:36.510
If I am searching A or B, the
key of ID for both documents

00:53:36.510 --> 00:53:40.760
are the same, but can
I get the ABC first?

00:53:44.310 --> 00:53:44.990
GED ELLIS: That's
a good question.

00:53:44.990 --> 00:53:49.020
I'm not sure if that scorer
does that as well, but is

00:53:49.020 --> 00:53:52.080
proximity in the backend?

00:53:52.080 --> 00:53:54.240
BO MAJEWSKI: I don't know.

00:53:54.240 --> 00:53:58.380
That's my answer.That's a very
lame answer, but kind of

00:53:58.380 --> 00:54:00.150
honest for the moment.

00:54:00.150 --> 00:54:01.870
So yeah.

00:54:01.870 --> 00:54:02.390
Good feedback.

00:54:02.390 --> 00:54:05.680
I mean, if you can either
add it to Issue 217 or

00:54:05.680 --> 00:54:06.240
something like this.

00:54:06.240 --> 00:54:07.900
I mean, we definitely--

00:54:07.900 --> 00:54:10.140
GED ELLIS: We're aware of
proximity search, but whether

00:54:10.140 --> 00:54:12.863
it's actually supported in that
scorer, I'm not sure.

00:54:16.174 --> 00:54:19.490
SPEAKER 16: For a different kind
of proximity description

00:54:19.490 --> 00:54:24.304
for this session, you
mentioned geosearch.

00:54:24.304 --> 00:54:26.140
How does that work?

00:54:26.140 --> 00:54:29.540
BO MAJEWSKI: So you record a
point so you can create a

00:54:29.540 --> 00:54:33.120
field, which you specify that
this is a location.

00:54:33.120 --> 00:54:38.480
And you need to specify the
longitude, latitude for us.

00:54:38.480 --> 00:54:41.395
And then there is a function,
which is a distance.

00:54:41.395 --> 00:54:46.670
And so you can search by
anything that has distance

00:54:46.670 --> 00:54:48.100
less than 10 kilometers.

00:54:48.100 --> 00:54:51.490
And give it a higher boost. So I
don't know how you'd use it,

00:54:51.490 --> 00:54:52.870
but you can use all
these functions.

00:54:52.870 --> 00:54:56.560
Like greater than 10 kilometers,
give it one.

00:54:56.560 --> 00:54:59.150
Otherwise give it miles.

00:54:59.150 --> 00:55:02.560
Give it five.

00:55:02.560 --> 00:55:04.310
Or you can just sort by
a distance from a

00:55:04.310 --> 00:55:05.346
given point as well.

00:55:05.346 --> 00:55:05.740
GED ELLIS: Yeah.

00:55:05.740 --> 00:55:08.030
But you can use it as a restrict
in your search as

00:55:08.030 --> 00:55:10.800
well as sort by the distance.

00:55:10.800 --> 00:55:13.210
SPEAKER 16: To prioritize?

00:55:13.210 --> 00:55:14.120
To sort?

00:55:14.120 --> 00:55:14.420
GED ELLIS: Yeah.

00:55:14.420 --> 00:55:14.720
Exactly.

00:55:14.720 --> 00:55:14.830
BO MAJEWSKI: Yeah.

00:55:14.830 --> 00:55:18.000
But when you search, we use this
stupid thing, which is,

00:55:18.000 --> 00:55:19.890
we assume that you can fly.

00:55:19.890 --> 00:55:20.646
So.

00:55:20.646 --> 00:55:21.984
SPEAKER 16: Yeah.

00:55:21.984 --> 00:55:23.024
All right.

00:55:23.024 --> 00:55:23.770
Thank you.

00:55:23.770 --> 00:55:26.300
GED ELLIS: Thank you.

00:55:26.300 --> 00:55:26.780
BO MAJEWSKI: All right.

00:55:26.780 --> 00:55:28.160
I think that's a wrap.

00:55:28.160 --> 00:55:29.770
Thank you very much.

