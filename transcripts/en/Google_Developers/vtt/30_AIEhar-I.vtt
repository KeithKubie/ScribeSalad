WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.500
JOSHUA MARANTZ: Good morning,
and welcome to

00:00:02.500 --> 00:00:04.350
Make the Web Faster.

00:00:04.350 --> 00:00:08.580
Today we're going to bring you
three new technologies.

00:00:08.580 --> 00:00:10.920
My name is Joshua Marantz and
I'm going to talk about

00:00:10.920 --> 00:00:14.660
mod_pagespeed, which is
an Apache module which

00:00:14.660 --> 00:00:16.650
automatically rewrites
web pages to make

00:00:16.650 --> 00:00:19.290
them display faster.

00:00:19.290 --> 00:00:22.720
Richard Rabbat will talk about
WebP, which is a new image

00:00:22.720 --> 00:00:23.950
format for the web.

00:00:23.950 --> 00:00:30.340
And Hakon Wium Le will talk
about Opera and WebP.

00:00:30.340 --> 00:00:33.190
So, why make your
website fast?

00:00:33.190 --> 00:00:36.360
The benefits are many, among
them are user satisfaction--

00:00:36.360 --> 00:00:38.620
people like to go to
fast website--

00:00:38.620 --> 00:00:41.180
better engagement,
and more revenue.

00:00:41.180 --> 00:00:43.620
But it's hard.

00:00:43.620 --> 00:00:46.270
The techniques for improving
websites are reasonably

00:00:46.270 --> 00:00:48.120
well-known, but they're
cumbersome

00:00:48.120 --> 00:00:49.640
to implement manually.

00:00:49.640 --> 00:00:50.740
There's trade-offs to make.

00:00:50.740 --> 00:00:54.360
There's the trade-off
of maintainability--

00:00:54.360 --> 00:00:57.680
of being able to easily change
your website and maintain it--

00:00:57.680 --> 00:01:00.170
versus keeping minified versions
and sprites of your

00:01:00.170 --> 00:01:02.820
images and your text,
et cetera.

00:01:02.820 --> 00:01:06.630
There's an agility trade-off,
because if you set your cache

00:01:06.630 --> 00:01:09.490
lifetimes for a long time out,
it's very difficult to change

00:01:09.490 --> 00:01:13.140
your JavaScript to fix bugs and
have it push out because

00:01:13.140 --> 00:01:16.340
users' browsers have cached
in it an old version.

00:01:16.340 --> 00:01:17.560
And if you set the
cache lifetime

00:01:17.560 --> 00:01:19.110
short, you get agility.

00:01:19.110 --> 00:01:22.000
But then everybody after they
come back to your site, if

00:01:22.000 --> 00:01:24.040
they come back on a daily basis
they'll get a fresh

00:01:24.040 --> 00:01:26.070
download each time.

00:01:26.070 --> 00:01:30.410
So another aspect is that
browsers are moving forward at

00:01:30.410 --> 00:01:31.590
a rapid pace.

00:01:31.590 --> 00:01:35.270
New browsers have new techniques
that can help web

00:01:35.270 --> 00:01:36.860
developers build faster
websites.

00:01:36.860 --> 00:01:39.330
But the old browsers lack these
techniques, and you

00:01:39.330 --> 00:01:41.530
don't want to leave all the
users who are stuck on old

00:01:41.530 --> 00:01:43.660
browsers for various
reasons behind.

00:01:43.660 --> 00:01:46.070
You want to continue to support
them well letting new

00:01:46.070 --> 00:01:47.340
browsers exploit
the techniques.

00:01:47.340 --> 00:01:50.860
So you kind of have to have some
server-side intelligence.

00:01:50.860 --> 00:01:52.890
And we're discovering new
techniques all the time.

00:01:52.890 --> 00:01:57.080
There's a talk later today about
mobile best practices.

00:01:57.080 --> 00:02:00.295
And as these techniques are
learned and adopted adopted

00:02:00.295 --> 00:02:02.370
and changed, you want to be able
to have a tool that helps

00:02:02.370 --> 00:02:04.580
adopt your website, rather
than employing somebody

00:02:04.580 --> 00:02:07.050
full-time to keep up with these
techniques and adjust

00:02:07.050 --> 00:02:08.490
your website accordingly.

00:02:08.490 --> 00:02:11.760
So the solution is to
use automated tools.

00:02:11.760 --> 00:02:14.670
So this is what mod_pagespeed
is for.

00:02:14.670 --> 00:02:18.340
Optimize your website without
having to change it.

00:02:18.340 --> 00:02:21.330
You don't have to change the way
you generate content, you

00:02:21.330 --> 00:02:24.690
don't have to minify your CSS
and your JavaScript by hand

00:02:24.690 --> 00:02:26.970
and keep two versions
around, spriting

00:02:26.970 --> 00:02:28.490
your images, et cetera.

00:02:28.490 --> 00:02:31.480
You don't have to manually run
ImageMagick over your whole

00:02:31.480 --> 00:02:33.535
library of photos and keep
two versions of those.

00:02:33.535 --> 00:02:35.300
Get a machine to do
that for you.

00:02:35.300 --> 00:02:37.750
That's what machines
are good at.

00:02:37.750 --> 00:02:39.800
So what does mod_pagespeed do?

00:02:39.800 --> 00:02:42.220
It actually does
no black magic.

00:02:42.220 --> 00:02:45.570
the techniques for optimizing
webpages, there's basically

00:02:45.570 --> 00:02:47.970
two bibles written by Steve
Souders: High Performance

00:02:47.970 --> 00:02:50.510
Websites and Even
Faster Websites.

00:02:50.510 --> 00:02:54.610
And they are pretty much the
techniques that we use today

00:02:54.610 --> 00:02:57.570
in mod_pagespeed to make
your website faster.

00:02:57.570 --> 00:03:00.850
Image compression, sizing images
to the right size,

00:03:00.850 --> 00:03:04.130
minifying CSS, JavaScript,
and HTML.

00:03:04.130 --> 00:03:07.640
We take small images that are
below a certain threshold and

00:03:07.640 --> 00:03:08.650
inline them.

00:03:08.650 --> 00:03:10.810
Same with CSS and JavaScript.

00:03:10.810 --> 00:03:13.900
And probably most importantly,
we extend cache lifetimes, and

00:03:13.900 --> 00:03:15.190
we'll talk more about.

00:03:15.190 --> 00:03:16.990
All of these techniques
are listed.

00:03:16.990 --> 00:03:20.410
We have a demo site called
modpagespeed.com, you go to

00:03:20.410 --> 00:03:23.540
that site, it shows you every
optimization that we do,

00:03:23.540 --> 00:03:27.850
documentation before
and after.

00:03:27.850 --> 00:03:32.890
So here's one example we'll dive
into called combining CSS

00:03:32.890 --> 00:03:36.400
files, so if you have four small
CSS files, each one of

00:03:36.400 --> 00:03:39.070
these when it's rendered in a
browser would represent a

00:03:39.070 --> 00:03:42.730
separate HTTP request. For all
kinds of reasons it's better

00:03:42.730 --> 00:03:47.840
to bundle these into one file
and this is not very hard to

00:03:47.840 --> 00:03:50.210
do by hand, but it's kind of
hard to maintain over time and

00:03:50.210 --> 00:03:51.570
it's kind of a conflict.

00:03:51.570 --> 00:03:54.120
So to get a tool to do that
for you, you turn on

00:03:54.120 --> 00:03:58.940
mod_pagespeed and the four lines
of links become one link

00:03:58.940 --> 00:04:01.490
with a concatenated name.

00:04:01.490 --> 00:04:05.610
And one of the most important
things we do is we add to the

00:04:05.610 --> 00:04:10.540
concatenated name a hashtag
which is the md5sum of the

00:04:10.540 --> 00:04:12.580
content of the file.

00:04:12.580 --> 00:04:15.710
And by doing this, that enables
us to serve this

00:04:15.710 --> 00:04:18.320
resource, a combined
CSS file, with a

00:04:18.320 --> 00:04:19.669
very long cache lifetime.

00:04:19.669 --> 00:04:22.760
This means that browsers
will retain

00:04:22.760 --> 00:04:25.400
knowledge about this file--

00:04:25.400 --> 00:04:28.660
we set the cache lifetime
for a year.

00:04:28.660 --> 00:04:31.610
But if you want to go back and
change one of these CSS files

00:04:31.610 --> 00:04:38.220
that it's built out of, then
mod_pagespeed will pick up

00:04:38.220 --> 00:04:42.730
that change, will recompute the
md5 tag, will serve the

00:04:42.730 --> 00:04:47.890
rewritten CSS link with a new
name, and the old stale entry

00:04:47.890 --> 00:04:49.110
in the browser cache
doesn't hurt you.

00:04:49.110 --> 00:04:52.330
So you kind of get the best of
both worlds, which is a long

00:04:52.330 --> 00:04:57.720
cache lifetime but an easily
changeable site.

00:04:57.720 --> 00:05:01.405
So how do you bring
mod_pagespeed into your web

00:05:01.405 --> 00:05:02.700
server flow?

00:05:02.700 --> 00:05:06.560
You have an existing
Apache HTTP server.

00:05:06.560 --> 00:05:10.860
You can download from
co.google.com.

00:05:10.860 --> 00:05:14.020
Our source code and pilot
where we have pre-built

00:05:14.020 --> 00:05:18.960
binaries for CentOS and
DBN and Ubuntu.

00:05:18.960 --> 00:05:21.550
And so you pretty much download
into the Apache

00:05:21.550 --> 00:05:25.280
server, and now you don't have
to change your content, you

00:05:25.280 --> 00:05:28.140
don't have to change your
content generation flow.

00:05:28.140 --> 00:05:31.070
You may want to tweak some of
the settings in pagespeed.com,

00:05:31.070 --> 00:05:32.600
that's optional.

00:05:32.600 --> 00:05:37.780
And you get out of that reduced
latency, improved

00:05:37.780 --> 00:05:39.780
bandwidth, and much longer
cache lifetimes.

00:05:44.360 --> 00:05:48.780
So taking a peek under the hood,
mod_pagespeed is really

00:05:48.780 --> 00:05:50.030
divided into two sections.

00:05:54.600 --> 00:05:58.780
There's a platform-independent
rewriting infrastructure, and

00:05:58.780 --> 00:06:00.600
it has a whole bunch of pieces
in it, but it's all called

00:06:00.600 --> 00:06:02.495
Pagespeed Automatic.

00:06:02.495 --> 00:06:07.090
And this is the engine that
rewrites webpages on the fly.

00:06:07.090 --> 00:06:10.460
On the right we have a bunch of
plug-ins, which are used to

00:06:10.460 --> 00:06:13.700
adapt this architecture to
a specific platform.

00:06:13.700 --> 00:06:17.120
And the first deployment
for this technology

00:06:17.120 --> 00:06:18.310
is an Apache module.

00:06:18.310 --> 00:06:20.730
So we have an Apache module
gasket, and this defines

00:06:20.730 --> 00:06:25.850
mechanisms for caching HTTP
content, caching metadata,

00:06:25.850 --> 00:06:29.650
fetching resources, threading,
and other assorted tasks. it's

00:06:29.650 --> 00:06:31.970
kind of a plug-in architecture
so that this can be applied to

00:06:31.970 --> 00:06:36.060
multiple platforms,
but our deployment

00:06:36.060 --> 00:06:37.830
initially is Apache HTTP.

00:06:40.790 --> 00:06:44.110
How much factor has
this made the web?

00:06:44.110 --> 00:06:49.340
So so far, this has been
launched for about six months.

00:06:49.340 --> 00:06:51.530
We launched in November
of last year.

00:06:51.530 --> 00:06:55.030
A few days after that,
DreamHost, a hosting provider,

00:06:55.030 --> 00:06:57.730
made it a push button on
their control panel.

00:06:57.730 --> 00:07:01.910
So any DreamHost-hosted site
can push a button and

00:07:01.910 --> 00:07:04.520
mod_pagespeed is activated
on their site.

00:07:04.520 --> 00:07:07.190
A couple of months later, we
announced with Go Daddy, the

00:07:07.190 --> 00:07:09.420
dominant hosting provider--

00:07:09.420 --> 00:07:12.300
who has a similar push-button
flow, it's actually a config

00:07:12.300 --> 00:07:16.800
file change-- but any Go Daddy
user can enable mod_pagespeed

00:07:16.800 --> 00:07:18.720
with, basically, a line
in a config file.

00:07:22.750 --> 00:07:26.870
The project is built on a large
base of source code,

00:07:26.870 --> 00:07:29.570
including the pagespeed source
code and a lot of Chromium

00:07:29.570 --> 00:07:32.155
source code, but we have about
60,000 lines of code that we

00:07:32.155 --> 00:07:34.220
wrote ourselves for this.

00:07:34.220 --> 00:07:36.540
It's a significant project.

00:07:36.540 --> 00:07:40.150
About 54,000 sites have
installed and are running

00:07:40.150 --> 00:07:46.020
mod-pagespeed as of today, and
the number is climbing.

00:07:46.020 --> 00:07:48.480
So what does mod_pagespeed
do to the sites?

00:07:48.480 --> 00:07:52.880
Well, let's take a look at 28
sites that we looked at that

00:07:52.880 --> 00:07:54.620
have installed mod_pagespeed.

00:07:54.620 --> 00:07:57.420
To test the site, we used a tool
called webpagetest.org.

00:07:57.420 --> 00:08:03.410
webpagetest.org is a
client-side testing

00:08:03.410 --> 00:08:03.970
technology.

00:08:03.970 --> 00:08:06.360
It's built in with
various browsers.

00:08:06.360 --> 00:08:10.415
In our case, the browser
that we used was IE8.

00:08:10.415 --> 00:08:13.450
So these are all IE8-based
numbers.

00:08:13.450 --> 00:08:19.060
And the blue lines indicate
the first time the page is

00:08:19.060 --> 00:08:19.880
brought up.

00:08:19.880 --> 00:08:22.760
And the red lines indicate the
repeat view, so that's with a

00:08:22.760 --> 00:08:24.090
warm cache.

00:08:24.090 --> 00:08:28.560
And every website
is different.

00:08:28.560 --> 00:08:32.260
We find that a typical
improvement between 20% and

00:08:32.260 --> 00:08:34.169
30% is not surprising.

00:08:34.169 --> 00:08:37.010
We've seen improvements
as much as 50%.

00:08:37.010 --> 00:08:39.440
And this is basically just by
downloading a module and

00:08:39.440 --> 00:08:41.360
turning it on.

00:08:41.360 --> 00:08:44.200
There are websites that have
already been hand tuned to

00:08:44.200 --> 00:08:46.940
follow all the best practices,
basically do the same things

00:08:46.940 --> 00:08:50.240
manually that mod_pagespeed
does automatically.

00:08:50.240 --> 00:08:52.520
And in that case, we don't
offer much improvement.

00:08:52.520 --> 00:08:54.640
In fact, we add some overhead
because we have to go and

00:08:54.640 --> 00:08:59.430
parse the website and say,
nope, this is all done.

00:08:59.430 --> 00:09:02.350
So let's look at this data from
a different perspective.

00:09:02.350 --> 00:09:06.190
Let's look at the images on the
top 1,000 websites on the

00:09:06.190 --> 00:09:09.590
web, the Alexa 1,000.

00:09:09.590 --> 00:09:15.620
On this corpus of images, a
fairly significant number of

00:09:15.620 --> 00:09:17.670
them, mod_pagespeed just looked
at them and said, I can

00:09:17.670 --> 00:09:20.020
get rid of a huge percentage
of the bytes.

00:09:20.020 --> 00:09:22.790
Over 75% of the bytes.

00:09:22.790 --> 00:09:26.020
This would typically happen if
somebody takes a photograph

00:09:26.020 --> 00:09:28.990
from a camera and puts it into
a thumbnail on a webpage.

00:09:28.990 --> 00:09:31.520
Most of those pixels are not
going to be seen by the user,

00:09:31.520 --> 00:09:32.890
so why do you want to
ship them over the

00:09:32.890 --> 00:09:34.040
wire all the time?

00:09:34.040 --> 00:09:35.470
You get a machine to reduce
that for you.

00:09:35.470 --> 00:09:37.650
You don't have to manage that
with compressing it with

00:09:37.650 --> 00:09:41.280
ImageMagick yourself, you just
let mod_pagespeed do it.

00:09:41.280 --> 00:09:45.410
But a really surprisingly high
number of images can be

00:09:45.410 --> 00:09:49.960
improved by a significant
amount, say 20% to 25%.

00:09:49.960 --> 00:09:52.700
And these typically come from
just better compression

00:09:52.700 --> 00:09:58.310
ratios, or re-encoding color
maps to be more optimal, or

00:09:58.310 --> 00:10:01.060
getting rid of all of the
metadata, the f-stop at which

00:10:01.060 --> 00:10:02.680
the photograph was
taken, et cetera.

00:10:05.510 --> 00:10:09.370
So let's dive into one of the
sites that has installed

00:10:09.370 --> 00:10:13.270
mod_pagespeed, called
androidacademy.com.

00:10:13.270 --> 00:10:15.150
First of all, we know that
this has installed

00:10:15.150 --> 00:10:19.420
mod_pagespeed because when we
look at the HTTP response

00:10:19.420 --> 00:10:22.040
headers from that site,
one of them--

00:10:22.040 --> 00:10:24.720
the one where the gray
arrow is pointing--

00:10:24.720 --> 00:10:26.610
it says x-mod-pagespeed.

00:10:26.610 --> 00:10:30.000
So we know that that site was
rewritten by mod_pagespeed.

00:10:30.000 --> 00:10:33.190
So we tested this site
webpagetest.org, which

00:10:33.190 --> 00:10:34.230
produces a lot of data.

00:10:34.230 --> 00:10:35.480
It also produces videos.

00:10:46.930 --> 00:10:48.970
So on the left, mod_pagespeed
is off, on the right,

00:10:48.970 --> 00:10:49.860
mod_pagespeed is on.

00:10:49.860 --> 00:10:51.660
So this a downloaded and go.

00:10:51.660 --> 00:10:57.390
In this case, the site is sped
up noticeably by turning

00:10:57.390 --> 00:10:59.500
mod_pagespeed on.

00:10:59.500 --> 00:11:01.840
But let's go back and
look at the numbers.

00:11:07.520 --> 00:11:10.000
So here's some colored bars.

00:11:10.000 --> 00:11:12.490
The top colored bars represent
the first view.

00:11:12.490 --> 00:11:15.950
The off on the top
and on the below.

00:11:15.950 --> 00:11:18.200
And below that, you see
the repeat views.

00:11:18.200 --> 00:11:21.040
The first bar, the blue
bar, represents the

00:11:21.040 --> 00:11:22.190
time to first byte.

00:11:22.190 --> 00:11:26.010
That's the time between when the
browser sent the request

00:11:26.010 --> 00:11:27.900
for the HTML file and
the first byte of

00:11:27.900 --> 00:11:29.700
HTML that came back.

00:11:29.700 --> 00:11:32.030
And you'll notice that when we
turn mod_pagespeed on, we

00:11:32.030 --> 00:11:34.530
actually make that take
a little bit longer.

00:11:34.530 --> 00:11:38.840
And that's because we've
introduced this server, this

00:11:38.840 --> 00:11:40.510
rewriting pipeline
into the flow.

00:11:40.510 --> 00:11:44.280
So we've actually added
some processing.

00:11:44.280 --> 00:11:48.350
Typically 10 to 30 milliseconds
of delay is added

00:11:48.350 --> 00:11:49.350
to that first byte.

00:11:49.350 --> 00:11:53.380
But we find so much on most
websites to improve that by

00:11:53.380 --> 00:11:56.240
the time you get to the time
to first paint, we've

00:11:56.240 --> 00:11:58.780
benefited the site by
close to a second.

00:11:58.780 --> 00:12:01.450
By the time you get to the page
load time, the onload

00:12:01.450 --> 00:12:04.870
handler, we've benefited the
site by more than two seconds

00:12:04.870 --> 00:12:06.070
on the first view.

00:12:06.070 --> 00:12:08.930
And on repeat views,
the numbers are

00:12:08.930 --> 00:12:10.740
a little bit different.

00:12:10.740 --> 00:12:12.730
And the reasons for the
improvement are also

00:12:12.730 --> 00:12:13.990
different, and we'll
go into those.

00:12:16.680 --> 00:12:20.250
So these are the waterfall
diagrams for this site,

00:12:20.250 --> 00:12:25.990
androidacademy.com, that have
been collected and rendered by

00:12:25.990 --> 00:12:28.150
webpagetest.org.

00:12:28.150 --> 00:12:30.700
On the left mod_pagespeed
is off, on the right

00:12:30.700 --> 00:12:33.490
mod_pagespeed is on.

00:12:33.490 --> 00:12:35.260
The top ones are first
view and the bottom

00:12:35.260 --> 00:12:37.130
ones are repeat view.

00:12:37.130 --> 00:12:39.400
And each of the things, you
don't have to zoom very far

00:12:39.400 --> 00:12:41.550
into these things and look
at all the data to

00:12:41.550 --> 00:12:43.860
understand the story.

00:12:43.860 --> 00:12:46.550
On the first view, you'll notice
that the waterfall

00:12:46.550 --> 00:12:48.410
diagram is significantly
shorter.

00:12:48.410 --> 00:12:51.850
It's probably about 30% shorter
with mod_pagespeed on.

00:12:51.850 --> 00:12:53.980
And that's because
of two things.

00:12:53.980 --> 00:12:57.040
It's because of inlining
small resources so

00:12:57.040 --> 00:12:58.770
there's less HTTP requests.

00:12:58.770 --> 00:13:01.930
And it's because of combining
resources, combining multiple

00:13:01.930 --> 00:13:04.760
CSS files into one, et cetera.

00:13:04.760 --> 00:13:08.800
On the bottom, we have
the repeat view.

00:13:08.800 --> 00:13:11.660
I should say the first view
also benefits because we

00:13:11.660 --> 00:13:12.540
compress images.

00:13:12.540 --> 00:13:16.300
So we make the images smaller,
but it's harder to tell that

00:13:16.300 --> 00:13:19.230
by looking at a zoomed out
view of the webpage.

00:13:19.230 --> 00:13:22.430
You'd have to look at the
waterfall diagram in a lot

00:13:22.430 --> 00:13:23.680
more detail to see that.

00:13:23.680 --> 00:13:27.200
But we'll take a look in more
detail at an example where we

00:13:27.200 --> 00:13:29.690
can show that later.

00:13:29.690 --> 00:13:33.370
So the bottom charts with the
big yellow blobs, those are

00:13:33.370 --> 00:13:34.350
the repeat view.

00:13:34.350 --> 00:13:38.720
And what those yellow bars mean
is that's called a 304.

00:13:38.720 --> 00:13:42.070
That's where the browser has
a copy of the resource--

00:13:42.070 --> 00:13:43.780
an image or a CSS file--

00:13:43.780 --> 00:13:46.130
but it doesn't know because it
doesn't have a long caching

00:13:46.130 --> 00:13:47.950
lifetime or the cache
is expired.

00:13:47.950 --> 00:13:49.050
Is this valid or not?

00:13:49.050 --> 00:13:52.300
So it has to send a request to
the server saying, hey I've

00:13:52.300 --> 00:13:53.050
got this resource.

00:13:53.050 --> 00:13:55.190
It's got this hex tag
called an Etag.

00:13:55.190 --> 00:13:56.610
Is this one good?

00:13:56.610 --> 00:14:01.010
And in this case, during these
tests, it is good.

00:14:01.010 --> 00:14:04.020
So the server sends back,
yes, yes, go with that.

00:14:04.020 --> 00:14:08.680
And that's a very low bandwidth
request, but it

00:14:08.680 --> 00:14:11.450
incurs a complete
roundtrip time.

00:14:11.450 --> 00:14:14.920
So with mod_pagespeed off, you
have to do a lot of round

00:14:14.920 --> 00:14:18.190
trips to the server, even with
a warm cache, just to make

00:14:18.190 --> 00:14:20.560
sure that all these resources
are still valid.

00:14:20.560 --> 00:14:23.360
Because we've done cache
extension and added those

00:14:23.360 --> 00:14:27.010
hashtags, those md5sums
to every URL.

00:14:27.010 --> 00:14:30.020
The browser, if it has the
URL, it's the correct URL

00:14:30.020 --> 00:14:33.200
because the content hash
is in the URL.

00:14:33.200 --> 00:14:37.660
So that's why the repeat view
waterfall diagram with

00:14:37.660 --> 00:14:39.750
mod_pagespeed on looks a
lot more compelling.

00:14:44.720 --> 00:14:47.930
So let's take a look at how
we do our measurement.

00:14:50.430 --> 00:14:56.050
With webpagetest.org, we
did four runs, which is

00:14:56.050 --> 00:14:59.470
mod_pagespeed on and off with
repeat view and first view.

00:14:59.470 --> 00:15:01.320
And then we repeat
that 50 times.

00:15:01.320 --> 00:15:03.890
And the reason that we repeat
that 50 times is that

00:15:03.890 --> 00:15:06.260
measurement on the
web is hard.

00:15:06.260 --> 00:15:12.230
If you were to get a stopwatch
and hit the refresh button in

00:15:12.230 --> 00:15:14.430
your browser a whole bunch of
times and just write down all

00:15:14.430 --> 00:15:16.430
the numbers, you'd see
that there's a

00:15:16.430 --> 00:15:17.310
fair amount of variance.

00:15:17.310 --> 00:15:18.350
It's kind of hard to do this.

00:15:18.350 --> 00:15:20.940
It's a lot easier for machine to
do this, but still there's

00:15:20.940 --> 00:15:25.210
a lot of things in between the
client and the server that can

00:15:25.210 --> 00:15:27.200
cause variance.

00:15:27.200 --> 00:15:28.870
It's a measurement variance.

00:15:28.870 --> 00:15:30.240
One of those things
is the network.

00:15:30.240 --> 00:15:35.470
In this case, Android Academy is
hosted in England, and our

00:15:35.470 --> 00:15:38.230
testing clients were
located in the US.

00:15:38.230 --> 00:15:43.550
So we had an intercontinental
delay, which probably added a

00:15:43.550 --> 00:15:45.510
fair amount of variance to our
test. And I think that's

00:15:45.510 --> 00:15:47.010
probably what accounts for
most of the jitter.

00:15:47.010 --> 00:15:52.580
But we have also seen with many
other sites where the

00:15:52.580 --> 00:15:53.830
servers are overloaded.

00:15:56.440 --> 00:15:58.760
And you'll see the red
and blue dots are

00:15:58.760 --> 00:15:59.510
much more of a jumble.

00:15:59.510 --> 00:16:03.120
And it's hard, if you were to
just one repeat or three

00:16:03.120 --> 00:16:05.420
repeats or something like that,
you could easily draw

00:16:05.420 --> 00:16:06.830
the wrong conclusion.

00:16:06.830 --> 00:16:09.990
And you have to see a lot
of data for us to

00:16:09.990 --> 00:16:10.860
be able to get confident.

00:16:10.860 --> 00:16:15.530
So in this case, while there's
a fair amount of jitter, the

00:16:15.530 --> 00:16:18.310
improvement is pretty clear.

00:16:18.310 --> 00:16:23.520
There's jitter in the
measurement, but the results

00:16:23.520 --> 00:16:25.730
are quite clear that
mod_pagespeed has consistently

00:16:25.730 --> 00:16:26.980
benefited this site.

00:16:30.230 --> 00:16:32.390
So where are we going
with mod_pagespeed

00:16:32.390 --> 00:16:34.120
speed down the road?

00:16:37.190 --> 00:16:40.270
We are installed on around
60,000 servers.

00:16:40.270 --> 00:16:43.390
That's a start, but we'd like to
make the whole web faster,

00:16:43.390 --> 00:16:45.140
and not just 60,000 sites.

00:16:45.140 --> 00:16:48.190
So we're seeking leveraged ways
to do that-- high volume

00:16:48.190 --> 00:16:51.760
partners, hosting
providers, CDNs.

00:16:51.760 --> 00:16:54.130
We'd like to encourage leverage
integrations with

00:16:54.130 --> 00:16:57.010
servers, proxies, and caches
that could put

00:16:57.010 --> 00:16:58.260
this technology inline.

00:16:58.260 --> 00:17:00.980
And we saw in the architecture
slide earlier, it's kind of a

00:17:00.980 --> 00:17:01.860
plug-in architecture.

00:17:01.860 --> 00:17:04.990
So it should be feasible to
integrate this rewriting

00:17:04.990 --> 00:17:11.140
technology into other stacks
other than the Apache stack.

00:17:11.140 --> 00:17:13.619
And we've just been going all
out trying to support every

00:17:13.619 --> 00:17:14.920
user that uses mod_pagespeed.

00:17:14.920 --> 00:17:17.730
You can see us on Twitter, you
can see us on our discussions

00:17:17.730 --> 00:17:20.410
list, et cetera, trying to get
everybody successful that's

00:17:20.410 --> 00:17:22.540
trying to use it.

00:17:22.540 --> 00:17:25.640
We'd also like to make the web
more fast. We've been going to

00:17:25.640 --> 00:17:29.220
the basic optimizations that are
recommended in the Souders

00:17:29.220 --> 00:17:32.020
books that I showed before.

00:17:32.020 --> 00:17:35.270
But we're working on things like
image spreading and WebP

00:17:35.270 --> 00:17:35.760
integration.

00:17:35.760 --> 00:17:37.510
We're going to talk about
WebP in the next

00:17:37.510 --> 00:17:38.760
segment of the talk.

00:17:41.610 --> 00:17:43.990
We'd like to add deferring
JavaScript execution.

00:17:43.990 --> 00:17:47.380
There's a whole suite of things
that we are anxious and

00:17:47.380 --> 00:17:51.030
excited to start working on
to make this speed-up more

00:17:51.030 --> 00:17:53.030
dramatic than what
we have so far.

00:17:53.030 --> 00:17:54.970
It's also important to put
effort into measurement.

00:17:54.970 --> 00:17:56.900
We want to measure better.

00:17:56.900 --> 00:18:00.340
We have dozens of filters now
that help rewrite web pages.

00:18:00.340 --> 00:18:02.270
Which of these have
the most impact?

00:18:02.270 --> 00:18:05.630
We'd like to get some
data behind that.

00:18:05.630 --> 00:18:09.180
And we'd like to help users
evaluate the benefits for

00:18:09.180 --> 00:18:11.010
mod_pagespeed.

00:18:11.010 --> 00:18:14.390
The more you're hitting refresh
with a stopwatch, the

00:18:14.390 --> 00:18:17.200
more hard it's going
to be to draw

00:18:17.200 --> 00:18:19.500
repeatable conclusions from--

00:18:19.500 --> 00:18:23.890
we want to enable users to
effectively gauge the benefit

00:18:23.890 --> 00:18:25.140
they're getting from
mod_pagespeed.

00:18:28.050 --> 00:18:34.420
I want to jump out of the
presentation and show you more

00:18:34.420 --> 00:18:36.280
image stuff.

00:18:36.280 --> 00:18:39.830
So this is an example
you can do yourself.

00:18:39.830 --> 00:18:42.300
This is off of modpagespeed.com.

00:18:42.300 --> 00:18:44.770
This is the site I showed
a snapshot of earlier.

00:18:44.770 --> 00:18:47.390
This shows you all of the
rewrite passes at

00:18:47.390 --> 00:18:49.660
mod_pagespeed supports.

00:18:49.660 --> 00:18:51.670
I went into the rewrite
images example.

00:18:51.670 --> 00:18:56.940
This is the before picture,
where we have three images.

00:18:59.520 --> 00:19:01.450
And this is the source code--

00:19:01.450 --> 00:19:03.500
view source, it's probably
not that visible.

00:19:06.810 --> 00:19:09.320
So there's a couple of
key points here.

00:19:09.320 --> 00:19:14.830
Puzzle.jpg is about
235 kilobytes.

00:19:14.830 --> 00:19:16.640
We don't really need
all those bits.

00:19:16.640 --> 00:19:18.840
We've displayed it
in a small space.

00:19:18.840 --> 00:19:24.660
Why not have the rewritten
puzzle.jpg, which is put into

00:19:24.660 --> 00:19:28.090
a 256 by 192 thumbnail.

00:19:28.090 --> 00:19:31.750
Which we can serve you in 21
kilobytes, and can you tell

00:19:31.750 --> 00:19:33.000
the difference?

00:19:35.970 --> 00:19:40.530
In addition to that, besides
making that JPEG a lot smaller

00:19:40.530 --> 00:19:45.310
than when you pulled it out of
the camera, one of these

00:19:45.310 --> 00:19:47.060
images is sufficiently small.

00:19:47.060 --> 00:19:52.520
I think it's this coffee cup.

00:19:52.520 --> 00:19:55.190
It's sufficiently small that
we've decided that it's better

00:19:55.190 --> 00:19:56.790
to inline it.

00:19:56.790 --> 00:20:03.090
So on the on the after page with
mod_pagespeed on, you see

00:20:03.090 --> 00:20:05.965
one less line in the
waterfall diagram.

00:20:08.510 --> 00:20:12.750
And that's because that coffee
cup has been rendered as a

00:20:12.750 --> 00:20:17.100
data URL so that it can be
displayed without having any

00:20:17.100 --> 00:20:19.210
additional HTTP requests.

00:20:29.560 --> 00:20:31.736
So mod_pagespeed.

00:20:31.736 --> 00:20:34.190
It's an open source
Apache module.

00:20:34.190 --> 00:20:36.930
It uses an Apache license, which
means you can basically

00:20:36.930 --> 00:20:39.200
download the code and do
whatever you like with it.

00:20:39.200 --> 00:20:42.140
So it's an open source Apache
module, which automatically

00:20:42.140 --> 00:20:43.770
makes your websites faster.

00:20:43.770 --> 00:20:45.055
There's two key points here.

00:20:45.055 --> 00:20:47.920
One is that it makes your
websites faster by doing these

00:20:47.920 --> 00:20:51.180
rewrites for fairly well-known
techniques.

00:20:51.180 --> 00:20:52.850
And the other one is that
it's automatic.

00:20:52.850 --> 00:20:55.210
Even if you know these
techniques, you might decide

00:20:55.210 --> 00:20:59.190
that you don't want to keep
doing them yourself manually

00:20:59.190 --> 00:21:02.410
every time you change
your site.

00:21:02.410 --> 00:21:04.360
So there's all kinds
of material on

00:21:04.360 --> 00:21:05.490
the web about this.

00:21:05.490 --> 00:21:07.660
It's easy to search
for it now.

00:21:07.660 --> 00:21:11.300
The first place to go is
modpagespeed.com, which shows

00:21:11.300 --> 00:21:12.600
all of the places--

00:21:12.600 --> 00:21:14.950
all of the rewrites that
we do before and after.

00:21:19.810 --> 00:21:22.340
So next up, we have
Richard Rabbat who

00:21:22.340 --> 00:21:24.780
will talk about WebP.

00:21:24.780 --> 00:21:26.030
RICHARD RABBAT: Thank you.

00:21:31.350 --> 00:21:35.370
So before I start talking about
WebP, I want to mention

00:21:35.370 --> 00:21:37.940
that when Josh and I started
this project, people were

00:21:37.940 --> 00:21:41.020
telling us that we were crazy.

00:21:41.020 --> 00:21:43.790
We had this developer tool,
pagespeed, that we've been

00:21:43.790 --> 00:21:48.620
innovating with, adding lots
of new best practices, and

00:21:48.620 --> 00:21:50.850
trying to understand
how people can

00:21:50.850 --> 00:21:54.100
make their pages faster.

00:21:54.100 --> 00:21:56.550
And then at some point, we
decided this we should make

00:21:56.550 --> 00:21:57.470
this automatic.

00:21:57.470 --> 00:22:01.140
We decided that we could try to
spend a lot of engineering

00:22:01.140 --> 00:22:07.250
time to make the web developer
not spend time themselves

00:22:07.250 --> 00:22:10.210
optimizing their pages, but
instead focusing on their

00:22:10.210 --> 00:22:13.320
content and adding delightful
content for your users.

00:22:17.280 --> 00:22:20.110
At Google it's kind of
nice, because they

00:22:20.110 --> 00:22:23.230
let you try and fail.

00:22:23.230 --> 00:22:25.020
If you fail too many
times, they

00:22:25.020 --> 00:22:28.070
don't let you try anymore.

00:22:28.070 --> 00:22:30.270
But it was just amazing.

00:22:30.270 --> 00:22:33.710
When we launched this,
the uptake was--

00:22:33.710 --> 00:22:38.520
we were actually not expecting
that people really wanted this

00:22:38.520 --> 00:22:40.580
technology in that fashion.

00:22:40.580 --> 00:22:43.540
We were very surprised.

00:22:43.540 --> 00:22:47.320
It just helped the engineering
team put in more effort.

00:22:47.320 --> 00:22:49.630
People put in weekends,
weeknights,

00:22:49.630 --> 00:22:51.330
and things like that.

00:22:51.330 --> 00:22:54.600
One thing that Josh mentioned,
which is we've been doing a

00:22:54.600 --> 00:22:57.570
lot of measurements with things
like webpagetest.org.

00:22:57.570 --> 00:23:01.370
And it's a great tool because
you can see what's happening.

00:23:01.370 --> 00:23:03.350
But last week--

00:23:03.350 --> 00:23:06.700
if you have Google Analytics
on your website, the Google

00:23:06.700 --> 00:23:11.820
Analytics team launched a site
speed measurement tool, which

00:23:11.820 --> 00:23:17.770
allows you to see the exact
latency that your users

00:23:17.770 --> 00:23:18.970
actually experience.

00:23:18.970 --> 00:23:21.990
As opposed to when you're under
a controlled environment

00:23:21.990 --> 00:23:25.750
from a certain server or
close your server.

00:23:25.750 --> 00:23:29.410
So if you use Google Analytics,
you should

00:23:29.410 --> 00:23:33.540
definitely add one line of code
and see what your users

00:23:33.540 --> 00:23:35.850
are experiencing in
terms of latency.

00:23:35.850 --> 00:23:37.760
It may be very eye-opening
for you.

00:23:40.280 --> 00:23:41.870
So talking about WebP.

00:23:41.870 --> 00:23:45.990
WebP is one of these other
examples of crazy ideas that

00:23:45.990 --> 00:23:48.555
we try and we see if
it's going to work.

00:23:55.520 --> 00:24:00.480
And as you all know, most of
the images out there are in

00:24:00.480 --> 00:24:01.390
JPEG format.

00:24:01.390 --> 00:24:06.720
This is one of the Google
logos at some point.

00:24:06.720 --> 00:24:08.256
So a JPEG is a lossy format.

00:24:11.780 --> 00:24:15.280
GIF has been there for
a very long time.

00:24:15.280 --> 00:24:19.420
It has very specific use cases
that people still want to

00:24:19.420 --> 00:24:23.020
have. There's the tracking
pixels, which we don't like

00:24:23.020 --> 00:24:23.560
talk about.

00:24:23.560 --> 00:24:28.620
But there's also things like
transparency and animation.

00:24:28.620 --> 00:24:32.150
Gif is great at allowing
you to do transparency.

00:24:32.150 --> 00:24:38.102
But also people like small
animations, two or three

00:24:38.102 --> 00:24:40.590
images next to each other.

00:24:40.590 --> 00:24:41.990
PNG has been used--

00:24:41.990 --> 00:24:44.750
portable network graphics-- has
been used for very high

00:24:44.750 --> 00:24:49.280
quality icons, texts, graphs,
things like this.

00:24:49.280 --> 00:24:51.430
There's an example
a PNG Google I/O.

00:24:51.430 --> 00:24:53.790
You want to see a developer
conference, you want to be

00:24:53.790 --> 00:24:59.440
able to read the words
"developer conference."

00:24:59.440 --> 00:25:02.850
But if you look at webpages--

00:25:02.850 --> 00:25:06.020
we all know that an image
is worth a 1,000 words--

00:25:06.020 --> 00:25:13.170
and today on the web there's a
lot of bytes that are totally

00:25:13.170 --> 00:25:14.110
image bytes.

00:25:14.110 --> 00:25:17.330
And you can look at--

00:25:17.330 --> 00:25:21.780
this is data from
httparchive.org.

00:25:21.780 --> 00:25:25.800
And the HTML bytes that you're
shipping to users are in the

00:25:25.800 --> 00:25:31.100
10s of kilobytes, and images
are in the 400 kilobytes.

00:25:31.100 --> 00:25:37.560
There's this data from Intel
Corporation that says that

00:25:37.560 --> 00:25:42.930
compression hasn't changed over
the past few years, but

00:25:42.930 --> 00:25:44.830
there's a lot of CPU
power that people

00:25:44.830 --> 00:25:49.620
have on their devices.

00:25:49.620 --> 00:25:54.530
Some of you may have gotten
some tab devices today.

00:25:54.530 --> 00:25:55.630
Great technology.

00:25:55.630 --> 00:26:01.760
The processing technology in
these tablets are way more

00:26:01.760 --> 00:26:03.120
advanced than what
you got in a new

00:26:03.120 --> 00:26:05.070
supercomputer 10 years ago.

00:26:05.070 --> 00:26:06.730
And there's a lot of algorithmic
improvements.

00:26:09.700 --> 00:26:15.710
So we decided to try to figure
out if we can propose an image

00:26:15.710 --> 00:26:19.395
format that can lead to
better compression

00:26:19.395 --> 00:26:21.700
than what JPEG does.

00:26:21.700 --> 00:26:24.930
It is based on the VP8
bitstream, which is what's

00:26:24.930 --> 00:26:28.410
also used for the web
and video format.

00:26:28.410 --> 00:26:33.220
And at first, we did a pretty
large study with

00:26:33.220 --> 00:26:35.310
about 900,000 JPEGs.

00:26:35.310 --> 00:26:40.020
And if we took them and we tried
to compress them again

00:26:40.020 --> 00:26:44.250
for the same signal-to-noise
ratio, we would get about

00:26:44.250 --> 00:26:47.000
39.8% better compression.

00:26:47.000 --> 00:26:50.580
And we thought, oh maybe it's
just because the JPEGs that

00:26:50.580 --> 00:26:54.400
are out there are just
full of extra bytes

00:26:54.400 --> 00:26:55.820
that are not be needed.

00:26:55.820 --> 00:26:59.470
And basically we did something
we called re-JPEG--

00:26:59.470 --> 00:27:00.380
JPEG recompression.

00:27:00.380 --> 00:27:05.520
And we could only get 14%
improvement over that.

00:27:05.520 --> 00:27:08.720
Recently, we started a new study
which is based on SSIM,

00:27:08.720 --> 00:27:14.620
which is considered a better
metric for image quality.

00:27:14.620 --> 00:27:22.090
And we took about 26,000 PNGs
and we did a compression at

00:27:22.090 --> 00:27:25.580
JPEG quality of 75, we
recompressed for the

00:27:25.580 --> 00:27:27.710
equivalent SSIM quality.

00:27:27.710 --> 00:27:31.880
We were getting about
40% smaller.

00:27:31.880 --> 00:27:34.330
Towards the end of this week or
next week, we're going to

00:27:34.330 --> 00:27:39.440
release a much larger study with
some of the images that

00:27:39.440 --> 00:27:42.420
people are used to looking at
when they look at image

00:27:42.420 --> 00:27:44.820
compression.

00:27:44.820 --> 00:27:48.760
Now why is WebP so cool?

00:27:48.760 --> 00:27:51.160
If you look at low bitrate
performance--

00:27:51.160 --> 00:27:55.880
this is an image that one of
our friends from Wikipedia,

00:27:55.880 --> 00:27:57.760
Mathias Schindler tried.

00:27:57.760 --> 00:28:00.760
He took a picture of one of
these German senators and

00:28:00.760 --> 00:28:05.410
tried to compress at a very low
bitrate in WebP and JPEG.

00:28:05.410 --> 00:28:08.680
You can see at low bitrate,
JPEG just

00:28:08.680 --> 00:28:10.030
doesn't quite get it.

00:28:10.030 --> 00:28:15.870
And at high bitrate, WebP
provides something that's just

00:28:15.870 --> 00:28:19.900
as good as a lossless
compression like PNG.

00:28:24.810 --> 00:28:27.710
And why do we do WebP?

00:28:27.710 --> 00:28:30.860
This is data from, again,
webpagetest.org.

00:28:30.860 --> 00:28:34.120
We have this website where we're
comparing a bunch of

00:28:34.120 --> 00:28:38.220
images that we put in JPEG
versus a bunch of images that

00:28:38.220 --> 00:28:39.720
we put in WebP.

00:28:39.720 --> 00:28:43.310
And you can see that some of
the data-- for example, the

00:28:43.310 --> 00:28:45.470
fully loaded data--

00:28:45.470 --> 00:28:50.370
shows that for WebP, you can
save about three seconds in

00:28:50.370 --> 00:28:52.430
time for fully loaded,
because you're

00:28:52.430 --> 00:28:54.320
downloading many less parts.

00:28:54.320 --> 00:28:57.870
In this case, we're downloading
529 kilobytes,

00:28:57.870 --> 00:29:01.830
versus 729 kilobytes.

00:29:01.830 --> 00:29:06.580
And it directly impacts the
speed of your webpage loading.

00:29:09.870 --> 00:29:13.870
So we started with WebP and we
focused on speed, because that

00:29:13.870 --> 00:29:17.850
was going to be the major
feature of the format.

00:29:17.850 --> 00:29:22.360
But we also wanted to delight
a lot of our users.

00:29:22.360 --> 00:29:25.420
So when we first released it,
people gave us some good

00:29:25.420 --> 00:29:28.260
feedback that they wanted
to see a better

00:29:28.260 --> 00:29:30.910
encoding of the image.

00:29:30.910 --> 00:29:36.220
And we spent a few months, we
improved the encoder itself to

00:29:36.220 --> 00:29:39.030
focus specifically
on still images.

00:29:39.030 --> 00:29:44.900
The WebM encoder was very
focused on the transitions,

00:29:44.900 --> 00:29:46.680
the video stuff.

00:29:46.680 --> 00:29:50.865
Instead, with WebP we
focus our encoding

00:29:50.865 --> 00:29:52.490
on the still image.

00:29:52.490 --> 00:29:56.290
And the feedback is
it's now beating

00:29:56.290 --> 00:29:59.740
JPEG much more readily.

00:29:59.740 --> 00:30:01.040
So what are we doing next?

00:30:01.040 --> 00:30:03.580
A bunch of new features.

00:30:03.580 --> 00:30:08.810
We want to support people's need
for metadata, and we're

00:30:08.810 --> 00:30:11.370
adding XMP support.

00:30:11.370 --> 00:30:15.000
XMP is extensible metadata
platform.

00:30:15.000 --> 00:30:20.330
We know some people are used to
XF, but XF has been painful

00:30:20.330 --> 00:30:25.970
for lots of people as well,
because there's no

00:30:25.970 --> 00:30:27.160
standard around it.

00:30:27.160 --> 00:30:30.380
It just creates problems
for the web.

00:30:30.380 --> 00:30:34.670
So because this is a format that
we want to have for many

00:30:34.670 --> 00:30:39.320
years in the future, we're
focusing on better, cleaner

00:30:39.320 --> 00:30:41.470
technology.

00:30:41.470 --> 00:30:44.260
Animation.

00:30:44.260 --> 00:30:47.580
When we first launched WebP,
we had a lot of comments.

00:30:47.580 --> 00:30:48.630
We want animation.

00:30:48.630 --> 00:30:51.250
We said, well just use
the video tag.

00:30:51.250 --> 00:30:52.490
It's great.

00:30:52.490 --> 00:30:54.200
And they're like, no.

00:30:54.200 --> 00:30:57.880
So we tried to figure out
exactly why, and it turns out

00:30:57.880 --> 00:31:00.510
it's mostly a philosophical
issue as opposed to a

00:31:00.510 --> 00:31:01.790
technology issue.

00:31:01.790 --> 00:31:07.000
People that like to do
development of animated images

00:31:07.000 --> 00:31:13.980
really want to use the typical
software that they're used to,

00:31:13.980 --> 00:31:15.480
like their Photoshop,
their ImageMagick.

00:31:15.480 --> 00:31:20.610
They don't want to use FFmpeg
for creating animation.

00:31:20.610 --> 00:31:22.130
So we're adding this.

00:31:22.130 --> 00:31:27.410
And because we're now in a much
newer world, we're adding

00:31:27.410 --> 00:31:30.050
3D stereoscopy.

00:31:30.050 --> 00:31:33.480
Tiling, because you can have
a bunch of images, you can

00:31:33.480 --> 00:31:35.850
create as large of an
image as you'd like.

00:31:35.850 --> 00:31:42.300
And you can start displaying
parts of the image as you can

00:31:42.300 --> 00:31:45.140
download it.

00:31:45.140 --> 00:31:51.200
And there's one cool thing
that we're adding.

00:31:51.200 --> 00:31:54.870
Who knows about CSS
background images?

00:31:54.870 --> 00:31:55.520
OK.

00:31:55.520 --> 00:31:58.640
Who likes how they have
to write them?

00:31:58.640 --> 00:32:01.470
OK, thank you.

00:32:01.470 --> 00:32:05.640
So if you look at the
third column--

00:32:05.640 --> 00:32:08.590
sorry for the colors
a little bit here.

00:32:08.590 --> 00:32:11.930
So we're basically grouping
images together and they're

00:32:11.930 --> 00:32:13.650
going to have a hashtag.

00:32:13.650 --> 00:32:20.550
And image source, for example,
group.webp#john and #jack.

00:32:20.550 --> 00:32:24.520
And then instead of having to
figure out exactly at what

00:32:24.520 --> 00:32:28.270
coordinates you're going to pick
the image from, you can

00:32:28.270 --> 00:32:31.640
actually just refer to
the image within

00:32:31.640 --> 00:32:35.530
that multi-image format.

00:32:35.530 --> 00:32:38.306
And there won't be any
weird CSS to write.

00:32:41.520 --> 00:32:45.740
For 3D-- again, if you look
at the third column--

00:32:45.740 --> 00:32:48.950
if you look at 3D images that
are out there that are in

00:32:48.950 --> 00:32:52.110
JPEG, if you display them on a
2D display, they just don't

00:32:52.110 --> 00:32:53.030
make any sense.

00:32:53.030 --> 00:32:58.400
So with our ability to put
multiple images in the same

00:32:58.400 --> 00:33:04.020
image file, we can actually call
the left image versus the

00:33:04.020 --> 00:33:08.280
right image separately, and
then we can show them.

00:33:08.280 --> 00:33:11.540
It depends on what display
technology one is using, and

00:33:11.540 --> 00:33:17.540
then you can see you can maybe
downgrade to a 2D for some

00:33:17.540 --> 00:33:20.290
people, present 3D for others.

00:33:20.290 --> 00:33:23.080
And also use--

00:33:23.080 --> 00:33:26.180
it depends on the capabilities
of the device.

00:33:26.180 --> 00:33:30.950
But it's definitely an image
format that we're looking at

00:33:30.950 --> 00:33:34.630
to grow in the future, so it's
still young and we're adding

00:33:34.630 --> 00:33:37.030
some more things.

00:33:37.030 --> 00:33:40.750
Last week, one of the engineers
added a JNI

00:33:40.750 --> 00:33:43.740
interface, which we
think is cool.

00:33:43.740 --> 00:33:46.560
And we're adding lossless so
that we can have better

00:33:46.560 --> 00:33:48.530
transparency support.

00:33:48.530 --> 00:33:54.460
On the product side, Picasa web
albums, Gmail, and Google

00:33:54.460 --> 00:33:57.700
App Engine are adding support.

00:33:57.700 --> 00:34:00.470
Picasa web albums already has
it, as well as Gmail.

00:34:00.470 --> 00:34:05.630
Google App Engine is going to
have that support soon.

00:34:05.630 --> 00:34:11.520
And what you get with WebP is
when you have VP8 hardware

00:34:11.520 --> 00:34:14.906
support, you get the WebP
hardware support immediately.

00:34:17.639 --> 00:34:20.770
The next release will also
have a much faster codec.

00:34:20.770 --> 00:34:24.760
Now that's we have a very good
encoder, we're spending some

00:34:24.760 --> 00:34:29.969
time writing assembly code
to make it much faster.

00:34:29.969 --> 00:34:31.219
That's it.

00:34:34.139 --> 00:34:38.860
And at this point, I'd like to
welcome Hakon to talk about

00:34:38.860 --> 00:34:42.050
Opera and WebP.

00:34:42.050 --> 00:34:43.300
Thank you.

00:34:48.635 --> 00:34:50.360
HAKON WIUM LIE: Perfect,
thank you.

00:34:50.360 --> 00:34:52.620
Thank you Richard, thanks
for inviting me here.

00:34:52.620 --> 00:34:57.420
I was at Google I/O last year as
well, when the video format

00:34:57.420 --> 00:34:58.900
WebM was introduced.

00:34:58.900 --> 00:35:00.900
And this is a pleasant follow-up
I think, to be able

00:35:00.900 --> 00:35:02.940
to do a still image format.

00:35:02.940 --> 00:35:04.800
I have to make one comment
though, you talk about the

00:35:04.800 --> 00:35:06.870
weird CSS syntax.

00:35:06.870 --> 00:35:12.220
I'm partially to blame for that,
I proposed CSS in 1994,

00:35:12.220 --> 00:35:14.650
and my baby has kind of
grown since then.

00:35:14.650 --> 00:35:16.680
And I agree with you, that
the background--

00:35:16.680 --> 00:35:19.960
the multiple background images
is kind of weird.

00:35:19.960 --> 00:35:21.980
But it's also stuff that
we don't really

00:35:21.980 --> 00:35:23.290
encourage people to use.

00:35:23.290 --> 00:35:26.040
You shouldn't really have
multiple background images on

00:35:26.040 --> 00:35:26.630
your elements.

00:35:26.630 --> 00:35:29.720
That's only if you want to do
rounded corners or something.

00:35:29.720 --> 00:35:32.190
And we actually have to better
properties for that now.

00:35:32.190 --> 00:35:33.650
Border radius is there.

00:35:33.650 --> 00:35:38.910
So you don't really have to do
the weird CSS thing anyway.

00:35:38.910 --> 00:35:40.450
Also, a word of warning.

00:35:40.450 --> 00:35:43.910
In this session you will be
hearing a lot about automated

00:35:43.910 --> 00:35:45.960
techniques for improving
performance.

00:35:45.960 --> 00:35:47.310
And I think that's helpful.

00:35:47.310 --> 00:35:48.280
That's why we're doing it.

00:35:48.280 --> 00:35:49.790
We're doing it too at Opera.

00:35:49.790 --> 00:35:51.920
But there's limits to how far
you can go with that.

00:35:51.920 --> 00:35:54.450
You still have to take
responsibility for your HTML

00:35:54.450 --> 00:35:58.120
code, for your CSS code,
and for your images.

00:35:58.120 --> 00:36:01.870
We can only get so far with
automated techniques.

00:36:01.870 --> 00:36:06.430
So we still need bright minds
out there to do the coding.

00:36:06.430 --> 00:36:08.970
Given that we do want automated
techniques though,

00:36:08.970 --> 00:36:11.670
I'd like to present Opera's
views on those.

00:36:11.670 --> 00:36:14.220
And we start sort of
on the other end.

00:36:14.220 --> 00:36:17.760
We start not on the server
end, we start with the

00:36:17.760 --> 00:36:19.710
clients, with the users.

00:36:19.710 --> 00:36:24.590
And probably the product
that many of you know--

00:36:24.590 --> 00:36:28.140
we have about 100 million people
using Opera Mini these

00:36:28.140 --> 00:36:30.250
days, active users.

00:36:30.250 --> 00:36:34.520
Opera Mini is a small client
originally written in Java

00:36:34.520 --> 00:36:38.560
that runs in handsets, typically
in mobile phones,

00:36:38.560 --> 00:36:41.680
many of them in the
developing world.

00:36:41.680 --> 00:36:46.440
And they give internet access,
web access, to ordinary

00:36:46.440 --> 00:36:47.730
phones, to ordinary people.

00:36:47.730 --> 00:36:49.760
People who don't have
PCs, perhaps.

00:36:49.760 --> 00:36:54.040
People who don't have even
the power to run a PC.

00:36:54.040 --> 00:36:57.660
And what we do there is that
in the fixed network--

00:36:57.660 --> 00:37:01.420
in the proxy service-- we fetch
the pages and basically

00:37:01.420 --> 00:37:03.250
just get the URL from
the mobile phone.

00:37:03.250 --> 00:37:06.655
We fetch the page, we compress
it to a binary format, that we

00:37:06.655 --> 00:37:11.700
send, then, over the wireless
network to the handset.

00:37:11.700 --> 00:37:18.540
And currently we process
about 60 billion pages

00:37:18.540 --> 00:37:21.790
per month on this.

00:37:21.790 --> 00:37:26.470
We have many people in many
places far away from here,

00:37:26.470 --> 00:37:30.720
like Russia, Indonesia,
India, places where

00:37:30.720 --> 00:37:32.360
the bandwidth costs--

00:37:32.360 --> 00:37:34.170
you pay per kilobyte, perhaps.

00:37:34.170 --> 00:37:36.200
Or there's limited
connectivity.

00:37:36.200 --> 00:37:38.400
Of course, there's never
limited connectivity

00:37:38.400 --> 00:37:39.650
like here is there?

00:37:42.600 --> 00:37:48.150
The other thing we do in this
space is Opera Turbo.

00:37:48.150 --> 00:37:50.230
Opera Turbo is sort
of similar.

00:37:50.230 --> 00:37:54.380
It's also a proxy service that
compresses, but unlike Opera

00:37:54.380 --> 00:37:58.020
Mini, which compresses into a
binary format, Opera Turbo

00:37:58.020 --> 00:38:02.900
just compresses by compressing
the HTML, the CSS, and the

00:38:02.900 --> 00:38:06.800
images, much like you talked
about earlier here.

00:38:06.800 --> 00:38:10.120
Opera Turbo is available from
the normal Opera desktop

00:38:10.120 --> 00:38:10.990
application.

00:38:10.990 --> 00:38:13.520
So if you download Opera
from opera.com,

00:38:13.520 --> 00:38:15.710
you can turn on Turbo.

00:38:15.710 --> 00:38:19.560
If it detects that you're on a
slow network, it will suggest,

00:38:19.560 --> 00:38:21.760
perhaps you should turn me on.

00:38:21.760 --> 00:38:24.910
And currently we have about five
billion page views per

00:38:24.910 --> 00:38:26.470
month for Opera Turbo.

00:38:26.470 --> 00:38:29.740
So it's significantly smaller
than Opera Mini, which has 60,

00:38:29.740 --> 00:38:32.300
but still a lot of people
are using this.

00:38:32.300 --> 00:38:35.280
And about a month ago,
we introduced

00:38:35.280 --> 00:38:38.570
WebP into Opera Turbo.

00:38:38.570 --> 00:38:44.940
We found out, after doing some
research, that WebP was the

00:38:44.940 --> 00:38:50.470
perfect fit to encode the
images for Opera Turbo.

00:38:50.470 --> 00:38:52.350
Here's a typical page.

00:38:52.350 --> 00:38:54.750
You save about 50%
of the bandwidth.

00:38:54.750 --> 00:38:58.080
It'd be interesting to see how
much Opera Turbo can compress

00:38:58.080 --> 00:39:02.350
on top of the page speed module
that we saw there.

00:39:02.350 --> 00:39:05.560
Whether those two will actually
really double the

00:39:05.560 --> 00:39:07.560
performance or whether
they equal.

00:39:07.560 --> 00:39:09.210
We should look into that.

00:39:09.210 --> 00:39:12.580
But these are typical numbers
that we see, that you reduce

00:39:12.580 --> 00:39:15.330
the size by 50% percent
and of course, then

00:39:15.330 --> 00:39:18.180
time also goes down.

00:39:18.180 --> 00:39:20.520
So images is an important
part of this.

00:39:20.520 --> 00:39:24.320
And WebP we found out
was a perfect match.

00:39:24.320 --> 00:39:29.600
If we take just a sample image
found on Flickr, when we do

00:39:29.600 --> 00:39:33.830
the really hard compression
here, when we tried to go

00:39:33.830 --> 00:39:36.100
really, really low,
we see that JPEG

00:39:36.100 --> 00:39:38.060
has significant artifact.

00:39:38.060 --> 00:39:41.260
It may be hard to see in this
projected mode here, but you

00:39:41.260 --> 00:39:45.160
can see in the middle where JPEG
is used, we go down from

00:39:45.160 --> 00:39:49.280
155 k to 8k.

00:39:49.280 --> 00:39:52.310
We see significant artifact
around the head of the turtle,

00:39:52.310 --> 00:39:53.020
for example.

00:39:53.020 --> 00:39:56.040
Whereas in WebP, which
is even lower--

00:39:56.040 --> 00:39:57.980
it's down to only 5kb--

00:39:57.980 --> 00:40:00.030
we don't see those artifacts.

00:40:00.030 --> 00:40:03.430
Now, this may be he's slightly
unfair to JPEG because the

00:40:03.430 --> 00:40:06.280
original comes across
as a JPEG from the

00:40:06.280 --> 00:40:07.950
first place, right?

00:40:07.950 --> 00:40:11.250
So when you do another JPEG, it
seems like you get really

00:40:11.250 --> 00:40:14.630
weird block effects when
these things double up.

00:40:14.630 --> 00:40:18.350
And that may be one reason why
WebP is performing so well.

00:40:18.350 --> 00:40:20.780
But so be it.

00:40:20.780 --> 00:40:23.540
It works well, gives us
better compression.

00:40:23.540 --> 00:40:27.030
And here's another one.

00:40:27.030 --> 00:40:32.620
Again, we see that we have
strong artifact in the middle

00:40:32.620 --> 00:40:36.380
image, whereas WebP gives
us better looking pages.

00:40:39.090 --> 00:40:44.130
Now here's the colleague
of mine, Charles.

00:40:44.130 --> 00:40:47.900
He's chief standards
officer at Opera.

00:40:47.900 --> 00:40:51.380
And also I think the WebP
looks the best here.

00:40:51.380 --> 00:40:53.210
If you look at the one
to the right, you see

00:40:53.210 --> 00:40:54.410
his wrinkles there?

00:40:54.410 --> 00:40:58.410
They they kind of disappeared.

00:40:58.410 --> 00:41:01.900
So if you want to look beautiful
on screen, perhaps

00:41:01.900 --> 00:41:04.840
WebP is the image
format to use.

00:41:04.840 --> 00:41:06.433
Is this something you
put into decoder?

00:41:06.433 --> 00:41:07.683
[LAUGHTER]

00:41:09.680 --> 00:41:11.770
OK.

00:41:11.770 --> 00:41:13.530
Very good.

00:41:13.530 --> 00:41:19.170
Now, the uses of WebP that's
we've seen, both in the Apache

00:41:19.170 --> 00:41:21.750
module and in Opera Turbo,
that's where things are being

00:41:21.750 --> 00:41:23.350
applied automatically.

00:41:23.350 --> 00:41:25.990
I think there's still a time
to go before you can start

00:41:25.990 --> 00:41:29.850
actually putting WebP images
on the web in your pages.

00:41:29.850 --> 00:41:32.320
Because if you do so, it's
going to be disruptive.

00:41:32.320 --> 00:41:35.060
Because most browsers will
not be able to see

00:41:35.060 --> 00:41:37.010
those images yet.

00:41:37.010 --> 00:41:40.470
If you use Opera or if you use
Chrome, you can go to the

00:41:40.470 --> 00:41:42.790
gallery and it shows up.

00:41:42.790 --> 00:41:46.680
But most other browsers will
not be able to show that.

00:41:46.680 --> 00:41:48.480
So there will be a time.

00:41:48.480 --> 00:41:50.770
And we had the same thing happen
when we introduced PNG

00:41:50.770 --> 00:41:52.240
some years ago.

00:41:52.240 --> 00:41:54.320
It takes a while before
browsers catch up.

00:41:54.320 --> 00:41:57.310
I hope the other browsers will
catch up and add support for

00:41:57.310 --> 00:42:01.710
WebP, just like they should
all support WebM as well.

00:42:01.710 --> 00:42:04.770
But until they do, you shouldn't
really exclude users

00:42:04.770 --> 00:42:07.390
by relying on this
being available.

00:42:10.650 --> 00:42:14.220
As a web community, we need to
make sure that our webpages

00:42:14.220 --> 00:42:17.940
work in most browsers
and most devices.

00:42:17.940 --> 00:42:20.980
And I think that's also an
encouragement to Google.

00:42:20.980 --> 00:42:23.470
I have to admit, at Opera we
have some problem with some of

00:42:23.470 --> 00:42:28.570
the more experimentive Google
services that come out.

00:42:28.570 --> 00:42:32.950
You're not always good at
testing in all cases.

00:42:32.950 --> 00:42:35.620
So I encourage testing
to every one of us.

00:42:35.620 --> 00:42:38.320
We need to make this web thing
work, we can't make it work

00:42:38.320 --> 00:42:40.300
for half the people,
half the browsers.

00:42:40.300 --> 00:42:42.110
We need to make it work
for everything.

00:42:42.110 --> 00:42:44.310
That's one of the strengths
of the web, and I

00:42:44.310 --> 00:42:45.890
hope that will continue.

00:42:45.890 --> 00:42:46.793
Thank you.

00:42:46.793 --> 00:42:48.043
[APPLAUSE]

00:42:53.415 --> 00:42:56.390
RICHARD RABBAT: So we have time
for questions, if you

00:42:56.390 --> 00:42:57.640
have any questions.

00:43:03.070 --> 00:43:05.100
OK, go ahead.

00:43:05.100 --> 00:43:06.350
[SIDE CONVERSATION]

00:43:13.110 --> 00:43:16.750
Question for Joshua, actually.

00:43:16.750 --> 00:43:17.180
Two things.

00:43:17.180 --> 00:43:22.090
We're using Rackspace cloud,
and we pay on a

00:43:22.090 --> 00:43:23.680
compute-cycle basis.

00:43:23.680 --> 00:43:29.260
How would using mod_pagespeed
affect compute cycle usage?

00:43:29.260 --> 00:43:33.960
And also, when you're doing
combined requests off of a

00:43:33.960 --> 00:43:39.300
CDN, would that affect-- when
you have multiple CDNs serving

00:43:39.300 --> 00:43:42.650
the same content and you append
them for your CSS

00:43:42.650 --> 00:43:43.880
requests, for instance--

00:43:43.880 --> 00:43:45.840
would there be a performance
gain/loss?

00:43:48.980 --> 00:43:52.590
JOSHUA MARANTZ: So the first
question is about the compute

00:43:52.590 --> 00:43:54.910
costs associated with
mod_pagespeed.

00:43:54.910 --> 00:43:58.810
And I should point that
mod_pagespeed uses a lot of

00:43:58.810 --> 00:43:59.840
caching internally.

00:43:59.840 --> 00:44:02.690
So although we are doing image
compression and image

00:44:02.690 --> 00:44:05.060
resizing, et cetera, that's
really the only

00:44:05.060 --> 00:44:06.480
compute-intensive thing
that we do.

00:44:06.480 --> 00:44:09.610
But we cache the results, and
we only do that once.

00:44:09.610 --> 00:44:16.050
So we think that amortized over
your entire site, it will

00:44:16.050 --> 00:44:16.780
not be measurable.

00:44:16.780 --> 00:44:19.490
But also please take into
account if you pay for

00:44:19.490 --> 00:44:24.390
bandwidth or requests, you'll
be serving a lot less bytes

00:44:24.390 --> 00:44:25.640
and a lot less requests
with mod_pagespeed.

00:44:29.400 --> 00:44:33.010
Your second question is about
buying resources and CDNs.

00:44:33.010 --> 00:44:38.460
And we support CDNs, we
support multi-server

00:44:38.460 --> 00:44:40.870
configurations.

00:44:40.870 --> 00:44:45.970
I'm not sure I entirely
understand your question.

00:44:45.970 --> 00:44:49.260
Mod_pagespeed benefits CDNs
by making more resources

00:44:49.260 --> 00:44:50.900
cacheable at the edge.

00:44:50.900 --> 00:44:52.690
So it's, in general, a win.

00:44:52.690 --> 00:44:58.060
And we enabled this because if
you remember, on the combined

00:44:58.060 --> 00:45:03.920
CSS slide, the link name for the
combined CSS file encodes

00:45:03.920 --> 00:45:06.520
all the information you need
to reproduce the result.

00:45:06.520 --> 00:45:10.330
Which is why multi-server
is not a problem.

00:45:10.330 --> 00:45:11.580
I hope that answers
your question.

00:45:14.670 --> 00:45:15.190
Howdy.

00:45:15.190 --> 00:45:21.190
So one of the big reasons that
PNG was so able to displace

00:45:21.190 --> 00:45:25.810
GIF in many fields is that it
was not patent-encumbered.

00:45:25.810 --> 00:45:31.640
And VP8 has, among other things,
not exactly been

00:45:31.640 --> 00:45:34.410
forthcoming with complete
documentation for the format,

00:45:34.410 --> 00:45:36.860
as is available for
JPEG and PNG.

00:45:36.860 --> 00:45:40.830
And also the guarantee of not
being patent-encumbered is

00:45:40.830 --> 00:45:44.390
still a little bit shaky, to
the point where VP8 simply

00:45:44.390 --> 00:45:47.690
isn't available destroys
the valuable freedom

00:45:47.690 --> 00:45:49.100
for Dora, for example.

00:45:49.100 --> 00:45:54.570
So while I appreciate the
attempt to displace JPEG, now

00:45:54.570 --> 00:45:56.440
that JPEG is actually
patent-free-- the patents

00:45:56.440 --> 00:46:00.260
expired four or five
years ago--

00:46:00.260 --> 00:46:04.230
how is the WebP team planning on
addressing patent concerns.

00:46:04.230 --> 00:46:07.890
RICHARD RABBAT: So I'm not a
lawyer, so I won't be talking

00:46:07.890 --> 00:46:10.450
about a patent.

00:46:10.450 --> 00:46:12.720
But you are welcome to
talk to our lawyers

00:46:12.720 --> 00:46:14.180
about patent issues.

00:46:14.180 --> 00:46:19.320
With respect to documentation,
I'll give you that we also

00:46:19.320 --> 00:46:21.190
really lack on documentation.

00:46:21.190 --> 00:46:23.620
We try our hardest,
but at some point

00:46:23.620 --> 00:46:27.135
we don't have enough--

00:46:27.135 --> 00:46:32.250
it would be great if you can
contribute documentation.

00:46:32.250 --> 00:46:35.770
I don't understand VP8 because
there's no VP8 documentation

00:46:35.770 --> 00:46:37.330
available for me to understand
it from.

00:46:37.330 --> 00:46:40.370
RICHARD RABBAT: So we've been
doing a lot of work on

00:46:40.370 --> 00:46:42.910
documentation, so we have
updated a lot of

00:46:42.910 --> 00:46:45.050
documentation on VP8.

00:46:45.050 --> 00:46:49.460
And I can certainly point to the
people that are working on

00:46:49.460 --> 00:46:50.290
the VP8 documentation.

00:46:50.290 --> 00:46:52.920
If there's any specific
feedback, we can definitely

00:46:52.920 --> 00:46:56.440
make sure that we cover it.

00:46:56.440 --> 00:46:59.980
Are there plans to submit a
formal specification in the

00:46:59.980 --> 00:47:05.865
manner of PNG to relevant
working groups for review?

00:47:05.865 --> 00:47:09.265
RICHARD RABBAT: So I'm not the
product manager for VP8, so I

00:47:09.265 --> 00:47:10.630
don't know exactly.

00:47:10.630 --> 00:47:17.990
I know we have submitted an
informational RFC to document

00:47:17.990 --> 00:47:19.710
what we do.

00:47:19.710 --> 00:47:24.510
I don't know of the other
forward plans.

00:47:24.510 --> 00:47:27.370
Fine, thank you.

00:47:27.370 --> 00:47:30.170
So, does mod_pagespeed concept
change the way we should

00:47:30.170 --> 00:47:31.120
approach design?

00:47:31.120 --> 00:47:35.390
Should I have the designers now
producing all the pages

00:47:35.390 --> 00:47:40.330
and putting the original art in
high quality large size and

00:47:40.330 --> 00:47:45.600
breaking up the JavaScripts,
making no effort to do manual

00:47:45.600 --> 00:47:46.056
optimization?

00:47:46.056 --> 00:47:48.310
Because then the machine
optimizers could do a much

00:47:48.310 --> 00:47:50.421
better job at that?

00:47:50.421 --> 00:47:51.990
RICHARD RABBAT: Please don't.

00:47:51.990 --> 00:47:54.740
I'll start with that.

00:47:54.740 --> 00:47:57.840
We've seen a lot of HTML
files that lie to us.

00:47:57.840 --> 00:48:02.950
And for many reasons, we
can't optimize them.

00:48:02.950 --> 00:48:06.670
When somebody tells us what MIME
type that file is, for

00:48:06.670 --> 00:48:11.040
example, is it's actually the
wrong MIME type, that's one of

00:48:11.040 --> 00:48:12.290
the examples.

00:48:16.450 --> 00:48:21.360
The importance of mod_pagespeed
is that in many

00:48:21.360 --> 00:48:25.610
cases, you don't have the cycles
to actually redo all

00:48:25.610 --> 00:48:26.430
the designs.

00:48:26.430 --> 00:48:30.540
For example, every time you
change your UI layout, you

00:48:30.540 --> 00:48:33.760
want to go and make every
image change.

00:48:33.760 --> 00:48:38.920
And you want to be careful about
the use of your front

00:48:38.920 --> 00:48:40.840
end engineers for that.

00:48:40.840 --> 00:48:43.445
And I'll let Josh
answer as well.

00:48:43.445 --> 00:48:45.760
JOSHUA MARANTZ: Sure.

00:48:45.760 --> 00:48:49.790
I don't think that there's a
need to do a complete 180

00:48:49.790 --> 00:48:54.810
degree turn in how you do your
design of your webpages.

00:48:54.810 --> 00:48:58.200
But it offers you the
opportunity to gradually

00:48:58.200 --> 00:49:03.200
consider maintainability and
efficiency of your design

00:49:03.200 --> 00:49:07.620
process, and let machines take
care of the processes.

00:49:07.620 --> 00:49:11.900
So you could get there, but as
always, I would recommend

00:49:11.900 --> 00:49:15.280
taking it one step at a time.

00:49:15.280 --> 00:49:18.010
This may be a silly question,
it made be enabled already,

00:49:18.010 --> 00:49:21.670
but you're speaking of getting
mod_pagespeed enabled on

00:49:21.670 --> 00:49:24.240
different hosts and different
servers and getting it built

00:49:24.240 --> 00:49:26.020
into different stacks.

00:49:26.020 --> 00:49:28.570
It seems to me that Google is
perfectly poised to do this,

00:49:28.570 --> 00:49:32.600
considering it has its own stack
in Google App Engine.

00:49:32.600 --> 00:49:35.480
Is mod_pagespeed available
for App Engine?

00:49:35.480 --> 00:49:38.660
Is it going to be available
for App Engine?

00:49:38.660 --> 00:49:41.120
Does it even apply
to App Engine?

00:49:41.120 --> 00:49:43.450
RICHARD RABBAT: It is, I think,
the third bug that's

00:49:43.450 --> 00:49:49.030
open on our issues list today.

00:49:49.030 --> 00:49:52.830
For App Engine, it
is currently not

00:49:52.830 --> 00:49:55.620
enabled in App Engine.

00:49:55.620 --> 00:49:58.460
We've talked to the team,
they're very excited.

00:49:58.460 --> 00:50:02.450
We're excited about potentially
providing it, but

00:50:02.450 --> 00:50:08.120
we have not done any immediate
work on this.

00:50:08.120 --> 00:50:12.370
We want to first focus on
stabilizing the technology,

00:50:12.370 --> 00:50:15.130
making sure that we gets
the best out of it.

00:50:15.130 --> 00:50:22.240
And benzes then deployments with
other servers as well.

00:50:22.240 --> 00:50:25.910
One of the big questions, as
well, was how about EngineX?

00:50:25.910 --> 00:50:27.630
How about Apache on Windows?

00:50:27.630 --> 00:50:29.220
How about this?

00:50:29.220 --> 00:50:31.590
Right now we're focused on the
core technology, and we'll

00:50:31.590 --> 00:50:34.520
look at other things
in the future.

00:50:34.520 --> 00:50:36.770
Thank you.

00:50:36.770 --> 00:50:38.870
I think you actually just
answered my question.

00:50:38.870 --> 00:50:44.070
We have seen a lot of success
with EngineX as a front end in

00:50:44.070 --> 00:50:47.370
front of Apache, acting
as a reverse proxy.

00:50:47.370 --> 00:50:49.070
It would be really great to
implement some of these

00:50:49.070 --> 00:50:51.690
techniques on that
level instead.

00:50:51.690 --> 00:50:56.810
So that's something that is on
the roadmap at some point?

00:50:56.810 --> 00:51:00.070
JOSHUA MARANTZ: I stick EngineX
in front of Apache.

00:51:05.260 --> 00:51:10.950
We've seen deployments where
EngineX is a front end and

00:51:10.950 --> 00:51:13.560
Apache with mod_pagespeed
enabled is the back end, and

00:51:13.560 --> 00:51:14.650
that should work great.

00:51:14.650 --> 00:51:15.550
OK.

00:51:15.550 --> 00:51:16.800
Yeah, thank you.

00:51:19.710 --> 00:51:23.078
Can you talk to the
applicability of mod_pagespeed

00:51:23.078 --> 00:51:27.980
and WebP or similar tools to
smartphones and tablets today

00:51:27.980 --> 00:51:29.230
or in the future?

00:51:31.660 --> 00:51:36.050
RICHARD RABBAT: For
mod_pagespeed, every time you

00:51:36.050 --> 00:51:39.310
browse a page, you're going to
see a faster experience.

00:51:39.310 --> 00:51:44.270
One of the really cool things
about mod_pagespeed is that it

00:51:44.270 --> 00:51:46.300
reduces the number of
roundtrips you make.

00:51:46.300 --> 00:51:50.500
And the roundtrip on a mobile
device is a couple of seconds

00:51:50.500 --> 00:51:51.850
at some point.

00:51:51.850 --> 00:51:58.700
So it's a very helpful tool for
a wireless and 3G and 4G

00:51:58.700 --> 00:52:00.180
browsing experience.

00:52:00.180 --> 00:52:05.770
JOSHUA MARANTZ: Yeah, I'll add
that mobile best practice are

00:52:05.770 --> 00:52:09.470
different then desktop best
practices, in terms of

00:52:09.470 --> 00:52:11.600
delivering the best
web experience.

00:52:11.600 --> 00:52:14.900
And one of the things that we
get the opportunity to do in

00:52:14.900 --> 00:52:18.830
mod_pagespeed is deliver an
experience customized to the

00:52:18.830 --> 00:52:26.050
user agent, because we have a
stack that we pay a lot of

00:52:26.050 --> 00:52:28.270
attention to on a daily basis,
that gets to see the user

00:52:28.270 --> 00:52:29.750
agent and then decide
what to do.

00:52:29.750 --> 00:52:33.740
So for example, today we do
image inlining only on

00:52:33.740 --> 00:52:36.230
browsers that we know
to support it.

00:52:36.230 --> 00:52:39.420
And so, the image inlining is
automatic and it works.

00:52:39.420 --> 00:52:41.120
It doesn't leave
anybody behind.

00:52:41.120 --> 00:52:43.450
That's kind of also the vision
with WebP, is that we can

00:52:43.450 --> 00:52:48.250
transcode to WebP for browsers
that don't yet support it.

00:52:48.250 --> 00:52:50.820
But for browsers that do, you
would get WebP automatically

00:52:50.820 --> 00:52:52.210
for free without having to.

00:52:52.210 --> 00:52:57.160
So along those same lines,
being able to have a

00:52:57.160 --> 00:53:00.500
server-side decision about how
to render the webpage is only

00:53:00.500 --> 00:53:01.660
going to benefit mobile.

00:53:01.660 --> 00:53:04.420
Have we gotten everything that
we want out of mobile

00:53:04.420 --> 00:53:05.550
experience, out of mod_pagespeed
yet?

00:53:05.550 --> 00:53:06.926
No, we're still working
on that.

00:53:13.250 --> 00:53:16.410
I work in organization I think
that has a fairly typical

00:53:16.410 --> 00:53:19.570
workflow, in that we have a
centrally hosted content

00:53:19.570 --> 00:53:25.990
management system which writes
out static assets to a CDN.

00:53:25.990 --> 00:53:30.705
So we don't have control over
the buildout of the technology

00:53:30.705 --> 00:53:33.340
at the CDN, but we
would like to--

00:53:33.340 --> 00:53:39.200
for static assets such as CSS
and JS files, we run a manual

00:53:39.200 --> 00:53:41.630
compression script before
pushing out.

00:53:41.630 --> 00:53:47.850
For images however, we don't
have anything in place,

00:53:47.850 --> 00:53:48.170
essentially.

00:53:48.170 --> 00:53:49.950
Are there standalone
components?

00:53:49.950 --> 00:53:52.770
Are there ways of ripping out
the image compression

00:53:52.770 --> 00:53:57.515
components of this and running
that against our asses before

00:53:57.515 --> 00:54:00.270
we push to CDN?

00:54:00.270 --> 00:54:04.150
JOSHUA MARANTZ: So I guess the
point of mod_pagespeed is not

00:54:04.150 --> 00:54:09.050
that we have new or unique image
processing capabilities.

00:54:09.050 --> 00:54:12.060
Under the hood, actually
it's OpenCV.

00:54:12.060 --> 00:54:15.580
ImageMagick is another good
engine that a lot of people

00:54:15.580 --> 00:54:16.790
use when they're doing
this kind of

00:54:16.790 --> 00:54:18.440
manual compression step.

00:54:18.440 --> 00:54:21.110
The point of mod_pagespeed is
to save you the effort of

00:54:21.110 --> 00:54:23.570
having to manage that
flow yourself.

00:54:23.570 --> 00:54:26.170
But given that you have that
flow and you want to keep

00:54:26.170 --> 00:54:29.400
doing it, something like
ImageMagick or other tools

00:54:29.400 --> 00:54:32.400
like that are probably the best
bet for doing standalone

00:54:32.400 --> 00:54:33.585
image compression.

00:54:33.585 --> 00:54:36.280
RICHARD RABBAT: I think he was
talking about further out

00:54:36.280 --> 00:54:40.540
where you have the HTML content
and you want to figure

00:54:40.540 --> 00:54:43.640
out how the image should
be optimized

00:54:43.640 --> 00:54:45.800
for that HTML content.

00:54:45.800 --> 00:54:51.030
Yeah, there's a number
of touch points.

00:54:51.030 --> 00:54:57.120
There's always, especially in
fairly large sites, you can

00:54:57.120 --> 00:54:58.150
optimize at the CDN, you
can optimize before

00:54:58.150 --> 00:54:59.550
you push to the CDN.

00:54:59.550 --> 00:55:02.230
You could do some smart
edge-level page caching.

00:55:04.800 --> 00:55:07.490
We've always taken a very simple
approach of, compress

00:55:07.490 --> 00:55:10.480
everything, pull out all the
white space, pull out all the

00:55:10.480 --> 00:55:13.280
comments, compress the graphics
as much as we can.

00:55:13.280 --> 00:55:18.220
Prior to pushing out to the
CDN, and eliminate steps.

00:55:18.220 --> 00:55:22.560
So I've see things like Yahoo
smush it, where you can upload

00:55:22.560 --> 00:55:24.895
a bunch of images, they come
back looking exactly the same

00:55:24.895 --> 00:55:27.220
but much smaller.

00:55:27.220 --> 00:55:31.840
What I would love is an API that
we upload image, we send

00:55:31.840 --> 00:55:35.810
the image to the API, the API
comes back with an optimized

00:55:35.810 --> 00:55:39.250
lossless version of that
image, and then we

00:55:39.250 --> 00:55:41.100
push it to the CDN.

00:55:41.100 --> 00:55:43.220
If you're into custom
development.

00:55:43.220 --> 00:55:45.600
RICHARD RABBAT: So we actually
have something that's on the

00:55:45.600 --> 00:55:53.070
pagespeed online API part which
allows you to score the

00:55:53.070 --> 00:55:56.750
page against the pagespeed's
rules.

00:55:56.750 --> 00:55:58.900
We currently are going to give
you back results and tell you

00:55:58.900 --> 00:56:01.880
what you could have
done better.

00:56:01.880 --> 00:56:05.010
That's an interesting request
that we'll take into

00:56:05.010 --> 00:56:07.560
consideration.

00:56:07.560 --> 00:56:08.810
Thanks.

00:56:10.670 --> 00:56:13.650
Hi, you mentioned that the
time to first byte on

00:56:13.650 --> 00:56:16.230
mod_pagespeed is slightly
increased because of the

00:56:16.230 --> 00:56:21.180
processing it does and some of
the optimization that applies.

00:56:21.180 --> 00:56:23.790
Could some of that stuff
be done offline in a

00:56:23.790 --> 00:56:24.920
pre-processing step?

00:56:24.920 --> 00:56:27.100
Say, before I deploy
my resources?

00:56:27.100 --> 00:56:28.890
JOSHUA MARANTZ: That's
a great question.

00:56:28.890 --> 00:56:35.180
Of course, all those things
could be done, but they have

00:56:35.180 --> 00:56:37.620
not yet been done.

00:56:37.620 --> 00:56:41.600
But for the majority of
websites, we've taken kind of

00:56:41.600 --> 00:56:44.280
a conservative approach to HTML
and assumed that it's

00:56:44.280 --> 00:56:48.940
fairly dynamic and often
personalized to the user so

00:56:48.940 --> 00:56:52.650
that caching HTML on the server
side is something that

00:56:52.650 --> 00:56:56.120
would not be our default
behavior.

00:56:56.120 --> 00:56:59.550
However, on the resource
optimization side,

00:56:59.550 --> 00:57:00.580
we already do that.

00:57:00.580 --> 00:57:02.470
Because we cache any
rewritten resource.

00:57:02.470 --> 00:57:05.450
So when I talked about that
overhead or that time to first

00:57:05.450 --> 00:57:10.890
byte, that's generally from
running it through the HTML

00:57:10.890 --> 00:57:13.090
filter, because we don't
cache the HTML.

00:57:13.090 --> 00:57:16.820
But we cache all of the
rewritten images and CSS files

00:57:16.820 --> 00:57:19.575
so we don't have to redo
those every time.

00:57:19.575 --> 00:57:21.515
Thank you.

00:57:21.515 --> 00:57:24.310
RICHARD RABBAT: Thank
you all for coming.

00:57:24.310 --> 00:57:27.100
I think a lot of people are
going to break for lunch now,

00:57:27.100 --> 00:57:32.030
so we're keeping you away from
your food, so please go ahead.

