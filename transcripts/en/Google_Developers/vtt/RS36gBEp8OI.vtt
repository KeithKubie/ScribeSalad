WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.402
[MUSIC PLAYING]

00:00:08.750 --> 00:00:10.730
MATT SULLIVAN: Good
morning, and welcome

00:00:10.730 --> 00:00:13.790
to the build reactive
apps with Flutter session.

00:00:13.790 --> 00:00:15.255
My name is Matt Sullivan.

00:00:15.255 --> 00:00:16.880
FILIP HRACEK: And my
name Filip Hracek,

00:00:16.880 --> 00:00:20.970
and we're both developer
advocates on the Flutter team.

00:00:20.970 --> 00:00:24.000
MATT SULLIVAN: So let's kick
off with looking at how to build

00:00:24.000 --> 00:00:26.060
reactive apps on Flutter.

00:00:26.060 --> 00:00:29.504
Flutter lets you
build beautiful apps.

00:00:29.504 --> 00:00:30.920
It gives you the
ability to create

00:00:30.920 --> 00:00:34.430
fluid and customized,
sophisticated UIs There's

00:00:34.430 --> 00:00:36.530
a few examples up
here just to show

00:00:36.530 --> 00:00:39.470
you the different
range and types

00:00:39.470 --> 00:00:42.920
of apps that you can
build with Flutter.

00:00:42.920 --> 00:00:47.230
At the heart of Flutter's UI
is a powerful, reactive model.

00:00:47.230 --> 00:00:49.730
I'm going to give you the 30
second summary of how it works,

00:00:49.730 --> 00:00:51.960
and then we're going to
deep dive into things.

00:00:51.960 --> 00:00:55.820
Firstly, in Flutter, all
UI components are widgets.

00:00:55.820 --> 00:00:59.000
As you can see here, we have
a widget that's a button.

00:00:59.000 --> 00:01:02.960
Secondly, you take these widgets
and you compose them together

00:01:02.960 --> 00:01:04.724
to create complex UIs.

00:01:04.724 --> 00:01:06.140
So we're going to
refer repeatedly

00:01:06.140 --> 00:01:08.750
to what we call the widget
tree, and that's literally how

00:01:08.750 --> 00:01:10.790
we're building these together.

00:01:10.790 --> 00:01:13.070
Thirdly, and
importantly, Flutter

00:01:13.070 --> 00:01:16.490
manages the relationship
between state and UI,

00:01:16.490 --> 00:01:18.320
and it only rebuilds
those widgets when

00:01:18.320 --> 00:01:20.690
their state changes,
and it relieves you

00:01:20.690 --> 00:01:22.350
of having to do that task.

00:01:22.350 --> 00:01:25.910
So, for example, here, when we
call setState() on the greeting

00:01:25.910 --> 00:01:29.980
widget, it's going to
automatically redraw itself.

00:01:29.980 --> 00:01:33.190
And that's great and wonderful,
but building complex apps

00:01:33.190 --> 00:01:34.390
is never easy.

00:01:34.390 --> 00:01:36.970
Apps typically have
thousands of UI components,

00:01:36.970 --> 00:01:39.580
but more importantly, they
have very complicated,

00:01:39.580 --> 00:01:41.710
and potentially
sophisticated state

00:01:41.710 --> 00:01:44.350
that's reacting with those
UI components asynchronously

00:01:44.350 --> 00:01:48.190
at different times in your app.

00:01:48.190 --> 00:01:51.350
The good news is that
Flutter provides you

00:01:51.350 --> 00:01:55.580
with all the tools necessary,
not only to build UI,

00:01:55.580 --> 00:01:59.240
but also to handle complex
data flow and state

00:01:59.240 --> 00:02:01.970
in your app that
fits in elegantly

00:02:01.970 --> 00:02:05.390
well with Flutter's reactive
model for building UIs.

00:02:05.390 --> 00:02:07.850
Now, Flutter's UI
patterns are well-known

00:02:07.850 --> 00:02:10.550
and well-documented-- you can
check them out on flutter.io--

00:02:10.550 --> 00:02:13.490
but Flutter's reactive
strategies for handling state

00:02:13.490 --> 00:02:14.900
are not so well-known.

00:02:14.900 --> 00:02:19.160
So we're going to focus
the talk on how to do that.

00:02:19.160 --> 00:02:21.099
We're going to take
you on a journey.

00:02:21.099 --> 00:02:23.515
Firstly, we're going to look
at the foundations of Flutter

00:02:23.515 --> 00:02:27.410
and state to show you the
basis of how things work.

00:02:27.410 --> 00:02:28.910
What we're going
to do then is we're

00:02:28.910 --> 00:02:31.820
going to explore how
state and the widget tree

00:02:31.820 --> 00:02:33.530
can be married together.

00:02:33.530 --> 00:02:35.450
And thirdly, we're
going to look at how

00:02:35.450 --> 00:02:38.810
you can use Flutter
streams to elegantly manage

00:02:38.810 --> 00:02:40.672
state in your app.

00:02:40.672 --> 00:02:43.130
Now, at each of these, we're
going to do some live coding--

00:02:43.130 --> 00:02:45.200
and clearly, nothing
is not going to run.

00:02:45.200 --> 00:02:47.420
But we're going to
do some live coding,

00:02:47.420 --> 00:02:50.600
and these examples will
be relatively simple.

00:02:50.600 --> 00:02:52.610
But we want you to
keep in mind how

00:02:52.610 --> 00:02:56.210
these can be scaled out to more
complex state, and larger apps.

00:02:56.210 --> 00:02:58.700
And importantly, the
examples you'll see here

00:02:58.700 --> 00:03:01.190
have been derived from
production apps built

00:03:01.190 --> 00:03:05.880
with Flutter, both by
Google and by other parties.

00:03:05.880 --> 00:03:11.037
So let's dive in and look at
managing state in the simplest

00:03:11.037 --> 00:03:13.370
app we can think of, which
is the incrementor app, which

00:03:13.370 --> 00:03:17.460
is what you get out of the box
when you do Flutter create.

00:03:17.460 --> 00:03:20.090
Flutter's reactive model
is straightforward for UI

00:03:20.090 --> 00:03:22.190
and state, but it's
a little different

00:03:22.190 --> 00:03:25.340
to how things are handled
with Android and iOS.

00:03:25.340 --> 00:03:28.700
So we're going to dive in
by looking at this app,

00:03:28.700 --> 00:03:32.450
and we're going to look at a
common pitfall that typically

00:03:32.450 --> 00:03:34.340
catches people out
when they initially

00:03:34.340 --> 00:03:37.490
start thinking about
reactive systems in general.

00:03:37.490 --> 00:03:38.490
Filip.

00:03:38.490 --> 00:03:39.490
FILIP HRACEK: All right.

00:03:39.490 --> 00:03:41.830
So this is a very
exciting moment for me,

00:03:41.830 --> 00:03:44.545
because I'm going to
break an app on stage

00:03:44.545 --> 00:03:47.570
at IO, which, if
you think about it,

00:03:47.570 --> 00:03:49.630
that's exactly the opposite
of what you normally

00:03:49.630 --> 00:03:51.060
want to do on stage.

00:03:51.060 --> 00:03:53.890
Well, this is in the name
of learning and science,

00:03:53.890 --> 00:03:56.830
so it's OK.

00:03:56.830 --> 00:03:59.410
So if you're not
familiar with this app,

00:03:59.410 --> 00:04:02.080
this app is very exciting.

00:04:02.080 --> 00:04:07.420
It shows you a number, and it
lets you increment that number.

00:04:07.420 --> 00:04:12.970
The important parts are there
is the counter variable,

00:04:12.970 --> 00:04:17.430
there's the build method
that creates the UI.

00:04:17.430 --> 00:04:21.519
Here is the widget which
actually shows that number--

00:04:21.519 --> 00:04:23.090
number four, right now.

00:04:23.090 --> 00:04:24.920
And here's the
floating action button,

00:04:24.920 --> 00:04:27.490
which is this guy
over here, which

00:04:27.490 --> 00:04:30.380
lets you change that variable.

00:04:30.380 --> 00:04:33.760
Now, imagine that this
was a much bigger app,

00:04:33.760 --> 00:04:38.170
and we wanted to put a
little more structure to it.

00:04:38.170 --> 00:04:41.530
We would do that,
often, by extracting

00:04:41.530 --> 00:04:45.640
parts of the build method
into its own widget.

00:04:45.640 --> 00:04:48.610
So I'm going to do just that.

00:04:48.610 --> 00:04:55.840
I'm going to take this out,
create a new widget called

00:04:55.840 --> 00:05:03.340
incrementor, and I'm just going
to paste the code over here.

00:05:03.340 --> 00:05:04.540
We're not done.

00:05:04.540 --> 00:05:08.300
As you can see, there's red
squiggly lines over there,

00:05:08.300 --> 00:05:10.220
which means we have a problem.

00:05:10.220 --> 00:05:13.060
And the problem is that
we cannot actually access

00:05:13.060 --> 00:05:17.260
the counter variable from here,
because we're in this class,

00:05:17.260 --> 00:05:21.700
while the counter
variable is in this class.

00:05:21.700 --> 00:05:25.130
There are many ways
to solve this problem,

00:05:25.130 --> 00:05:27.730
but I have something
very special in mind.

00:05:27.730 --> 00:05:34.300
I'm just going to make the
viable global, because I can.

00:05:34.300 --> 00:05:36.050
MATT SULLIVAN: So there
you have it folks.

00:05:36.050 --> 00:05:39.470
To handle state in Flutter,
you make everything global,

00:05:39.470 --> 00:05:40.460
and your app is good.

00:05:40.460 --> 00:05:41.480
Yeah-- is that what
we're telling people?

00:05:41.480 --> 00:05:41.985
[CHUCKLES]

00:05:41.985 --> 00:05:42.986
FILIP HRACEK: No.

00:05:42.986 --> 00:05:46.700
Actually, we're trying
to make the point here--

00:05:46.700 --> 00:05:49.670
we're trying to break
this app, so please don't

00:05:49.670 --> 00:05:51.910
make your variables global.

00:05:51.910 --> 00:05:58.890
And we're going to fix this in
two minutes, so stay with us.

00:05:58.890 --> 00:06:03.170
We fixed the squiggly lines, so
let's see if this app actually

00:06:03.170 --> 00:06:04.730
works, now.

00:06:04.730 --> 00:06:05.720
It doesn't.

00:06:05.720 --> 00:06:08.900
Now, why is that?

00:06:08.900 --> 00:06:14.720
We can add a thing here to see
if the counter variable has

00:06:14.720 --> 00:06:16.430
actually changed.

00:06:16.430 --> 00:06:19.430
And we see that it
has-- it is now at 12.

00:06:19.430 --> 00:06:22.370
But the user doesn't see it.

00:06:22.370 --> 00:06:23.700
Why is that?

00:06:23.700 --> 00:06:27.560
Well, the reason is that we're
calling setState() in the wrong

00:06:27.560 --> 00:06:28.430
widget.

00:06:28.430 --> 00:06:33.050
We're breaking the contract
of set state, which

00:06:33.050 --> 00:06:35.840
is that you call set state
when you are changing

00:06:35.840 --> 00:06:37.550
the state of the widget.

00:06:37.550 --> 00:06:40.640
We're not changing the state
of the floating action button

00:06:40.640 --> 00:06:45.260
here, we're changing the
state of the widget above it.

00:06:45.260 --> 00:06:48.280
And that way, Flutter
doesn't know--

00:06:48.280 --> 00:06:50.900
Flutter tries to rebuild
that floating action button,

00:06:50.900 --> 00:06:54.170
but that doesn't do anything
with our text over here.

00:06:54.170 --> 00:06:55.540
So I'm going to fix it now.

00:06:58.135 --> 00:06:59.510
MATT SULLIVAN:
What we need to do

00:06:59.510 --> 00:07:02.150
is we need to move set state
into the appropriate widget

00:07:02.150 --> 00:07:04.999
where we want to show the
change, or the mutation,

00:07:04.999 --> 00:07:05.540
of the state.

00:07:05.540 --> 00:07:11.600
So Filip is going to move it
back into the home page widget.

00:07:11.600 --> 00:07:14.270
And thankfully, we no longer
have any more global state.

00:07:14.270 --> 00:07:16.179
Wonderful.

00:07:16.179 --> 00:07:17.720
What we're going to
do then is-- what

00:07:17.720 --> 00:07:19.520
we need to do is we need
to be able to pass down

00:07:19.520 --> 00:07:22.250
a reference to that function so
it can be called by its child

00:07:22.250 --> 00:07:23.120
widget.

00:07:23.120 --> 00:07:25.730
So we're basically going to
update the incrementor widget,

00:07:25.730 --> 00:07:28.940
we're going to pass
through the function

00:07:28.940 --> 00:07:30.165
through the constructor.

00:07:30.165 --> 00:07:31.790
And then, what this
is basically giving

00:07:31.790 --> 00:07:33.800
is the classic callback
method of being

00:07:33.800 --> 00:07:37.310
able to call the function
in the parent widget.

00:07:37.310 --> 00:07:40.296
And that should
probably just work.

00:07:40.296 --> 00:07:41.420
FILIP HRACEK: And it works.

00:07:41.420 --> 00:07:43.100
Awesome.

00:07:43.100 --> 00:07:43.600
All right.

00:07:43.600 --> 00:07:44.730
Back to slides, please.

00:07:47.870 --> 00:07:51.560
So that was great, and it
was pretty easy to fix.

00:07:51.560 --> 00:07:53.320
But you can imagine
that if you have

00:07:53.320 --> 00:07:57.550
a much larger app with
a lot more widgets,

00:07:57.550 --> 00:07:59.060
this could be a problem.

00:07:59.060 --> 00:08:03.010
Let's imagine that you
need state over here,

00:08:03.010 --> 00:08:06.580
and you have state
somewhere over here.

00:08:06.580 --> 00:08:10.720
And now, what you need to do
is, if you follow that pattern

00:08:10.720 --> 00:08:13.960
that I just showed you, you
need to pass down the state

00:08:13.960 --> 00:08:15.460
down the widget tree.

00:08:15.460 --> 00:08:19.300
And that means that all the
widgets that are in that path

00:08:19.300 --> 00:08:21.820
need to know about the state,
even though they don't really

00:08:21.820 --> 00:08:23.190
care.

00:08:23.190 --> 00:08:27.800
And that breaks reuse, it
breaks separation of concerns,

00:08:27.800 --> 00:08:30.160
and it also, potentially,
makes the app

00:08:30.160 --> 00:08:33.710
rebuild a much larger
portion of the state--

00:08:33.710 --> 00:08:35.799
of the UI than you would want.

00:08:35.799 --> 00:08:39.919
You only want the leaf
nodes to be rebuilt.

00:08:39.919 --> 00:08:45.880
So I've hopefully highlighted
two problems here, or two

00:08:45.880 --> 00:08:47.050
challenges.

00:08:47.050 --> 00:08:51.250
First, how do I access state
that doesn't necessarily

00:08:51.250 --> 00:08:55.150
live in the widget where
I need it, and second,

00:08:55.150 --> 00:08:59.260
how do I notify other widgets
that they should rebuild?

00:09:02.350 --> 00:09:06.430
Again, I'm going to
score this pattern

00:09:06.430 --> 00:09:10.420
that I just showed you with
thumbs down on both accounts,

00:09:10.420 --> 00:09:14.710
because while it is easy in
a simple app, in a big app,

00:09:14.710 --> 00:09:17.390
it gets more complicated.

00:09:17.390 --> 00:09:21.670
And I think we have
a better option here.

00:09:21.670 --> 00:09:25.829
MATT SULLIVAN: So let's look
at how we can handle state,

00:09:25.829 --> 00:09:28.120
and the concept of passing
state up and down the widget

00:09:28.120 --> 00:09:31.420
tree without having to expose
it to all the widgets in between

00:09:31.420 --> 00:09:33.730
that don't need to use it.

00:09:33.730 --> 00:09:37.270
Flutter has, out
of the box, what

00:09:37.270 --> 00:09:39.010
is called an InheritedWidget.

00:09:39.010 --> 00:09:43.640
And what an inherited widget
does is it holds state,

00:09:43.640 --> 00:09:47.690
and it allows you to propagate
that state efficiently

00:09:47.690 --> 00:09:51.380
down the widget tree, and
it will rebuild that widget

00:09:51.380 --> 00:09:56.610
tree when that state is
mutated, or that state changes.

00:09:56.610 --> 00:09:58.985
So that sounds promising--
that might help us solve this.

00:09:58.985 --> 00:10:00.318
What is this going to look like?

00:10:00.318 --> 00:10:02.240
Well, basically you have
an InheritedWidget--

00:10:02.240 --> 00:10:03.115
we've put it in here.

00:10:03.115 --> 00:10:05.720
And as opposed to having to
pass down references to it,

00:10:05.720 --> 00:10:08.360
we can use the
build context in any

00:10:08.360 --> 00:10:11.930
of the build methods to get an
access to the instance of that

00:10:11.930 --> 00:10:16.710
state and use it directly
within our widgets themselves.

00:10:16.710 --> 00:10:19.100
So what does that
look like in code?

00:10:19.100 --> 00:10:23.210
Here, I have my really cleverly
named MyInheritedWidget,

00:10:23.210 --> 00:10:25.790
which extends InheritedWidget,
and in here, you

00:10:25.790 --> 00:10:28.430
can see that I have
placed some state.

00:10:28.430 --> 00:10:29.330
Perfect.

00:10:29.330 --> 00:10:30.590
How do I access that?

00:10:30.590 --> 00:10:33.290
Well, I can access
it by, firstly,

00:10:33.290 --> 00:10:38.510
placing my InheritedWidget into
my tree, giving it some state,

00:10:38.510 --> 00:10:42.150
and then building the
widget tree beneath it.

00:10:42.150 --> 00:10:43.970
And then, after
that, I can access it

00:10:43.970 --> 00:10:46.220
by simply using
the build context

00:10:46.220 --> 00:10:48.290
to get a reference
to that widget,

00:10:48.290 --> 00:10:49.790
and then I can access the state.

00:10:49.790 --> 00:10:51.830
So that sounds promising.

00:10:51.830 --> 00:10:55.460
Well, sure-- now I can access
state anywhere in the tree,

00:10:55.460 --> 00:10:57.860
and keep the rest
of my code dry.

00:10:57.860 --> 00:10:59.720
My tree, at a
coarse grain level,

00:10:59.720 --> 00:11:02.340
does rebuild my state
changes, so that's OK.

00:11:02.340 --> 00:11:05.300
But, as you noticed,
my state was final.

00:11:05.300 --> 00:11:08.390
That's not very
helpful if you actually

00:11:08.390 --> 00:11:09.800
want to mutate your state.

00:11:09.800 --> 00:11:14.087
Now, it's not hard to layer in
mutation with InheritedWidget--

00:11:14.087 --> 00:11:15.170
it's a bit of boilerplate.

00:11:15.170 --> 00:11:16.711
What we're going to
do is we're going

00:11:16.711 --> 00:11:18.980
to look at a library
called ScopedModel.

00:11:18.980 --> 00:11:21.020
And ScopedModel is
an external package.

00:11:21.020 --> 00:11:23.180
It's built on top
of InheritedWidget,

00:11:23.180 --> 00:11:25.850
and importantly, it
gives us the access,

00:11:25.850 --> 00:11:27.680
it gives us a more
fine-grained way

00:11:27.680 --> 00:11:30.770
of rebuilding parts of
our tree, and it allows

00:11:30.770 --> 00:11:33.750
us to mutate state, as well.

00:11:33.750 --> 00:11:36.200
So looking at code
real quick, ScopedModel

00:11:36.200 --> 00:11:38.420
equates to my InheritedWidget.

00:11:38.420 --> 00:11:41.060
And we have what's called
a descendent, which

00:11:41.060 --> 00:11:43.820
gives us access to the state.

00:11:43.820 --> 00:11:45.470
I'm showing all this
stuff on slides--

00:11:45.470 --> 00:11:49.440
I want to show it in real
code to show you it working.

00:11:49.440 --> 00:11:52.100
But I don't want to show it
to you in the incrementor app

00:11:52.100 --> 00:11:53.780
because that's pretty simple.

00:11:53.780 --> 00:11:57.110
So Filip and I knocked up
a shopping cart example.

00:11:57.110 --> 00:12:00.050
And what that has is it
has three areas where

00:12:00.050 --> 00:12:01.950
you need to handle your state.

00:12:01.950 --> 00:12:04.310
We've got a cart page which
shows the list of items,

00:12:04.310 --> 00:12:06.590
we have a cart button which
shows the number of items

00:12:06.590 --> 00:12:09.140
in the cart, and we
have a grid of products,

00:12:09.140 --> 00:12:12.350
where each product is tappable,
and should add something

00:12:12.350 --> 00:12:13.970
to the cart.

00:12:13.970 --> 00:12:27.330
So let's jump over to my
laptop, and take a look at this.

00:12:27.330 --> 00:12:30.600
Here, we have the app,
which is already running.

00:12:30.600 --> 00:12:32.350
You can see I have
a grid of products.

00:12:32.350 --> 00:12:34.349
And at the moment, it's
just showing a snack bar

00:12:34.349 --> 00:12:35.280
at the bottom.

00:12:35.280 --> 00:12:39.060
We have my cart button, which
is hard-coded to show zero,

00:12:39.060 --> 00:12:41.739
and we have a cart page, which
currently is showing empty.

00:12:41.739 --> 00:12:43.780
There is no state anywhere
in here at the moment.

00:12:43.780 --> 00:12:45.180
These are all
stateless widgets--

00:12:45.180 --> 00:12:47.520
this does nothing
except look pretty--

00:12:47.520 --> 00:12:49.310
if you consider
this to be pretty.

00:12:49.310 --> 00:12:52.850
We're not designers,
but there you go.

00:12:52.850 --> 00:12:53.770
What do we need to do?

00:12:53.770 --> 00:12:57.070
First, we need to
define our model.

00:12:57.070 --> 00:12:59.310
So I have created cart model.

00:12:59.310 --> 00:13:00.870
It extends model,
and what it does

00:13:00.870 --> 00:13:04.440
is it simply has a cart object
which is holding our state.

00:13:04.440 --> 00:13:07.060
We have three different ways
of interacting with this.

00:13:07.060 --> 00:13:09.870
We've got a getter to pull
down the list of cart items,

00:13:09.870 --> 00:13:12.557
we have item count
which gives us

00:13:12.557 --> 00:13:13.890
the number of items in the cart.

00:13:13.890 --> 00:13:17.560
And, strangely enough, we have
an add method, or function,

00:13:17.560 --> 00:13:19.860
which allows us to place
a product in the cart.

00:13:19.860 --> 00:13:23.340
Now, notice here, when I
mutate or change my state,

00:13:23.340 --> 00:13:25.680
I'm explicitly calling
notify listeners.

00:13:25.680 --> 00:13:27.900
And the way ScopedModel
works is that whenever

00:13:27.900 --> 00:13:32.070
you have a descendent widget,
they are observing your state--

00:13:32.070 --> 00:13:33.990
they are listening for changes.

00:13:33.990 --> 00:13:37.200
And, when our state changes, we
simply call notify listeners,

00:13:37.200 --> 00:13:39.090
and all of those
descendent widgets

00:13:39.090 --> 00:13:43.410
will be notified that state has
changed, and they will rebuild.

00:13:43.410 --> 00:13:45.630
So the whole tree is
not being rebuilt,

00:13:45.630 --> 00:13:47.910
only those widgets that
are listening to it,

00:13:47.910 --> 00:13:50.700
and the things below them
will be rebuilt. Perfect.

00:13:50.700 --> 00:13:53.070
So let's see how I
can use that model

00:13:53.070 --> 00:13:56.034
to inject some state to my app.

00:13:56.034 --> 00:13:57.450
What I'm going to
do is I'm simply

00:13:57.450 --> 00:14:00.330
going to place my state at
the topmost level of my app

00:14:00.330 --> 00:14:01.300
for ease to begin with.

00:14:01.300 --> 00:14:03.090
What I'm going to
do is I am going

00:14:03.090 --> 00:14:05.820
to wrap this in a
new widget, and it

00:14:05.820 --> 00:14:08.410
is going to be a ScopedModel.

00:14:08.410 --> 00:14:09.930
And, as we can see
here, ScopedModel

00:14:09.930 --> 00:14:12.240
takes a model and a child.

00:14:12.240 --> 00:14:16.350
So we can keep the subtree as a
child, and I can place a model.

00:14:16.350 --> 00:14:19.410
And I'm going to create a
new instance of cart model.

00:14:22.160 --> 00:14:24.960
So now I have state existing
at the top of my tree.

00:14:24.960 --> 00:14:25.460
Great.

00:14:25.460 --> 00:14:27.800
I need to access that
state, so how do I do it?

00:14:27.800 --> 00:14:29.732
Let's go down and take
a look at our button.

00:14:29.732 --> 00:14:31.940
And here's our button, and
you can see at the moment,

00:14:31.940 --> 00:14:33.984
it's hard-coded to show zero.

00:14:33.984 --> 00:14:35.900
So what I'm going to do
is I'm going to follow

00:14:35.900 --> 00:14:36.983
the same type of pattern--

00:14:36.983 --> 00:14:38.690
I'm going to wrap
this in a new widget.

00:14:38.690 --> 00:14:43.850
And, this time, I'm going
to use a descendant widget.

00:14:43.850 --> 00:14:47.660
I'm going to type it so it knows
what type of model to look for.

00:14:47.660 --> 00:14:49.190
And this doesn't
take a child, it

00:14:49.190 --> 00:14:52.520
takes a builder, which will
provide me with the model.

00:14:52.520 --> 00:14:54.800
So I'm going to change
my child to builder--

00:14:54.800 --> 00:14:57.480
and this is a function.

00:14:57.480 --> 00:15:05.580
I need the build context because
that's how InheritedWidget

00:15:05.580 --> 00:15:06.810
gets a reference to it.

00:15:06.810 --> 00:15:09.060
We have an optional child
widget I'm not going to use,

00:15:09.060 --> 00:15:10.735
and we're going to have a model.

00:15:10.735 --> 00:15:11.610
So what can I do now?

00:15:11.610 --> 00:15:16.590
I should be able to simply
do model dot item count.

00:15:16.590 --> 00:15:17.090
Perfect.

00:15:17.090 --> 00:15:19.131
We got to do one more
thing to get this to work--

00:15:19.131 --> 00:15:20.730
we've got to add some products.

00:15:20.730 --> 00:15:22.360
I'm going to do
this super quick.

00:15:22.360 --> 00:15:25.920
Here, we have our grid, here,
we have our individual products.

00:15:25.920 --> 00:15:28.080
And, again, I'm going to
follow the same pattern--

00:15:28.080 --> 00:15:33.020
I'm going to wrap this
in a descendant widget.

00:15:33.020 --> 00:15:34.360
I'm going to type it--

00:15:34.360 --> 00:15:36.040
and I'm going to
do that properly.

00:15:36.040 --> 00:15:39.380
And then, again, I'm going
to change this to a builder,

00:15:39.380 --> 00:15:47.310
make this a function, take
my context and my model.

00:15:47.310 --> 00:15:49.350
And so, now, what
we can do in here

00:15:49.350 --> 00:15:51.570
is-- we've got all
of this snack bar

00:15:51.570 --> 00:15:53.140
code, which I can get rid of.

00:15:53.140 --> 00:15:55.950
And I should be able
to do model dot add--

00:15:55.950 --> 00:15:59.670
and we have a product.

00:16:04.100 --> 00:16:05.290
This is all hot reloaded--

00:16:05.290 --> 00:16:06.415
I've placed state in there.

00:16:06.415 --> 00:16:08.690
I don't have to restart
my app, fingers crossed.

00:16:08.690 --> 00:16:12.170
And we'll see if this works.

00:16:12.170 --> 00:16:12.720
There we go.

00:16:12.720 --> 00:16:14.780
So we've gone from
stateless to stateful.

00:16:14.780 --> 00:16:17.060
I haven't changed the
structure of my app.

00:16:17.060 --> 00:16:19.820
All I've done is I've layered
in a few extra widgets.

00:16:19.820 --> 00:16:22.340
And with the way that
this app is built,

00:16:22.340 --> 00:16:23.960
this has worked really nicely.

00:16:23.960 --> 00:16:26.870
FILIP HRACEK: This is
nice Matt, but didn't you

00:16:26.870 --> 00:16:29.750
say that whenever you
call notify listeners,

00:16:29.750 --> 00:16:33.990
you will rebuild the things
below the descendants?

00:16:33.990 --> 00:16:37.060
Which means that we are
now rebuilding the product

00:16:37.060 --> 00:16:39.107
squares every time you click.

00:16:39.107 --> 00:16:40.940
MATT SULLIVAN: So, as
we pointed out before,

00:16:40.940 --> 00:16:42.860
notify listeners notifies
all the descendants.

00:16:42.860 --> 00:16:45.530
So we're rebuilding this
button, but we're also

00:16:45.530 --> 00:16:48.310
rebuilding all of these
products, which is bad.

00:16:48.310 --> 00:16:49.970
So why don't we fix
that real quick.

00:16:49.970 --> 00:16:54.050
Because ScopedModel descendant
has a rebuild unchanged flag--

00:16:54.050 --> 00:16:57.710
and I can set that to false.

00:16:57.710 --> 00:16:59.660
And so you shouldn't
see any difference here.

00:16:59.660 --> 00:17:04.900
What's happening now
is these products

00:17:04.900 --> 00:17:07.280
squares are not being rebuilt.

00:17:07.280 --> 00:17:10.910
I already implemented a
descendant for the cart page,

00:17:10.910 --> 00:17:13.920
because you don't need to see
me type this a third time,

00:17:13.920 --> 00:17:16.819
but it's exactly the
same model there.

00:17:16.819 --> 00:17:19.650
So let's jump back
to the slides.

00:17:19.650 --> 00:17:20.150
Thank you.

00:17:23.280 --> 00:17:24.329
So what does that get us?

00:17:24.329 --> 00:17:27.569
Accessing state-- we can access
state arbitrarily down the tree

00:17:27.569 --> 00:17:31.590
without having to mess with
our intermediate widgets.

00:17:31.590 --> 00:17:33.660
We have a reasonably
elegant means

00:17:33.660 --> 00:17:36.240
of notifying our widgets now
by our descendants observing

00:17:36.240 --> 00:17:39.630
for state change,
and then rebuilding

00:17:39.630 --> 00:17:41.029
when that state changes.

00:17:41.029 --> 00:17:43.320
Now, minimal rebuild-- I'm
going to give a thumbs down,

00:17:43.320 --> 00:17:47.587
and that's because I had
to, a, be reminded by Filip,

00:17:47.587 --> 00:17:49.920
because I constantly forgot
every time we rehearsed this

00:17:49.920 --> 00:17:51.030
to do this--

00:17:51.030 --> 00:17:54.030
that we had to not
rebuild that part.

00:17:54.030 --> 00:17:56.610
There's a cognitive load at
that point for the developers.

00:17:56.610 --> 00:17:58.740
You need to work out
should this rebuild,

00:17:58.740 --> 00:18:01.170
shouldn't this rebuild,
what's going to happen?

00:18:01.170 --> 00:18:03.300
And, when you
evolve your app, you

00:18:03.300 --> 00:18:06.379
have this additional level of
needing to worry about this.

00:18:06.379 --> 00:18:07.920
So I don't think
this is great, and I

00:18:07.920 --> 00:18:09.480
think we probably
need to come up

00:18:09.480 --> 00:18:11.850
with a better solution to that.

00:18:11.850 --> 00:18:15.420
Funnily enough, we're now going
to look at Flutter support

00:18:15.420 --> 00:18:16.440
for streams.

00:18:16.440 --> 00:18:19.230
How streams can be built to fit
in with Flutter's UI reactive

00:18:19.230 --> 00:18:22.290
model, and how they can
solve this very problem.

00:18:26.290 --> 00:18:27.310
FILIP HRACEK: Thank you.

00:18:27.310 --> 00:18:29.110
So let's talk about streams.

00:18:29.110 --> 00:18:32.920
If you are more familiar
with the term Observables,

00:18:32.920 --> 00:18:35.690
they are very closely related.

00:18:35.690 --> 00:18:38.140
And, for the
purposes of our talk,

00:18:38.140 --> 00:18:40.310
they are basically
interchangeable.

00:18:40.310 --> 00:18:43.300
So if you think about
application development,

00:18:43.300 --> 00:18:45.130
streams are everywhere.

00:18:45.130 --> 00:18:49.690
Every user input is a stream
of asynchronous events.

00:18:49.690 --> 00:18:52.840
Every interaction with
the underlying system

00:18:52.840 --> 00:18:55.870
is a stream of
asynchronous events.

00:18:55.870 --> 00:18:58.795
Every interaction-- obviously,
with the outside world through

00:18:58.795 --> 00:18:59.980
the network--

00:18:59.980 --> 00:19:02.170
is a stream of
asynchronous events.

00:19:02.170 --> 00:19:04.420
And crucially, if
you think about it,

00:19:04.420 --> 00:19:08.750
all your updates to the UI is a
stream of asynchronous events.

00:19:08.750 --> 00:19:12.130
So people who are
familiar with ReactiveX

00:19:12.130 --> 00:19:15.010
and reactive programming,
in general, probably

00:19:15.010 --> 00:19:16.510
know where I'm going with this.

00:19:16.510 --> 00:19:18.610
But suffice to
say, it makes sense

00:19:18.610 --> 00:19:21.370
to think about UI
programming as managing

00:19:21.370 --> 00:19:24.340
stream of asynchronous events.

00:19:24.340 --> 00:19:28.330
The good news is Dart has really
good support for streams--

00:19:28.330 --> 00:19:31.510
it has had that for a long time.

00:19:31.510 --> 00:19:35.050
Dart Streams have all the
usual bells and whistles

00:19:35.050 --> 00:19:40.420
that you would expect, like
stream transforming, mapping,

00:19:40.420 --> 00:19:42.440
folding, and so on.

00:19:42.440 --> 00:19:45.760
And Dart even has language
level support for streams,

00:19:45.760 --> 00:19:52.240
like asynchronous generators,
the yield keyword, or wait for.

00:19:52.240 --> 00:19:56.110
So we have this concept
of streams in Dart,

00:19:56.110 --> 00:20:00.070
and it is used throughout
the Dart ecosystem.

00:20:00.070 --> 00:20:05.110
And then we have this concept
of reactive extensions

00:20:05.110 --> 00:20:06.610
and reactive programming.

00:20:06.610 --> 00:20:08.500
On top of that,
there is a package

00:20:08.500 --> 00:20:13.990
called our rxdart, which builds
the reactive extensions on top

00:20:13.990 --> 00:20:19.390
of the inherent streams in Dart.

00:20:19.390 --> 00:20:21.880
So that's really great.

00:20:21.880 --> 00:20:24.880
How does that fit into Flutter?

00:20:24.880 --> 00:20:27.970
Well, Flutter has
this widget called

00:20:27.970 --> 00:20:32.110
StreamBuilder, which is exactly
what you would think it is.

00:20:32.110 --> 00:20:36.120
It is a widget that takes
a stream as an input,

00:20:36.120 --> 00:20:39.700
and a builder method that
will rebuild every time there

00:20:39.700 --> 00:20:42.990
is a new value in the stream.

00:20:42.990 --> 00:20:44.920
Any time you have
a stream, like when

00:20:44.920 --> 00:20:47.480
you're subscribing to
a FirebaseDatabase,

00:20:47.480 --> 00:20:51.500
you can just use StreamBuilder
to rebuild your UI.

00:20:51.500 --> 00:20:53.710
So that is already pretty cool.

00:20:53.710 --> 00:20:56.770
But wouldn't it be
even more awesome

00:20:56.770 --> 00:20:59.710
if we had some kind of
architectural pattern

00:20:59.710 --> 00:21:02.300
to build our apps?

00:21:02.300 --> 00:21:04.960
So imagine that
you have a big app,

00:21:04.960 --> 00:21:08.000
and it has some widgets
that take user input,

00:21:08.000 --> 00:21:11.650
so they have streams of
asynchronous events coming

00:21:11.650 --> 00:21:13.010
from the user.

00:21:13.010 --> 00:21:14.920
And then you have
other widgets that

00:21:14.920 --> 00:21:17.330
can be anywhere
else in the widget

00:21:17.330 --> 00:21:22.060
tree that try to update whenever
there is a state change.

00:21:22.060 --> 00:21:26.570
Now, you cannot just simply
link those two together--

00:21:26.570 --> 00:21:30.340
you need something in between,
and we'll call that business

00:21:30.340 --> 00:21:33.400
logic, for now.

00:21:33.400 --> 00:21:37.360
You need to stream the
events from the widgets that

00:21:37.360 --> 00:21:40.690
have buttons and inputs
to the business logic.

00:21:40.690 --> 00:21:44.650
Then, their magic happens,
and the business logic

00:21:44.650 --> 00:21:47.650
publishes streams
of data changes

00:21:47.650 --> 00:21:50.680
to widgets that are
interested in it.

00:21:50.680 --> 00:21:53.590
And this can then rebuild.

00:21:53.590 --> 00:21:56.860
Crucially, you're
publishing separate streams,

00:21:56.860 --> 00:22:00.130
so the other widget could be
interested in a completely

00:22:00.130 --> 00:22:02.920
different aspect of your
data, and it will just

00:22:02.920 --> 00:22:05.770
subscribe to that stream.

00:22:05.770 --> 00:22:08.530
It won't rebuild
any time there's

00:22:08.530 --> 00:22:10.580
any change to your model--

00:22:10.580 --> 00:22:12.250
it will only rebuild
when there is

00:22:12.250 --> 00:22:16.480
a change to that specific
aspect of the model.

00:22:16.480 --> 00:22:17.530
Let's have a closer look.

00:22:17.530 --> 00:22:20.380
We have streams as inputs,
and streams as outputs.

00:22:20.380 --> 00:22:22.810
How would that look in Dart?

00:22:22.810 --> 00:22:24.910
Well, we would
have an object that

00:22:24.910 --> 00:22:28.480
has Sinks of events as inputs.

00:22:28.480 --> 00:22:34.210
Sinks is the input of a
stream-- you put things into it,

00:22:34.210 --> 00:22:36.910
and then you can listen
to it on the other hand.

00:22:36.910 --> 00:22:40.720
And then there is a
stream of data as output.

00:22:40.720 --> 00:22:44.110
Pretty simple.

00:22:44.110 --> 00:22:47.560
Now, in our example
with a shopping app,

00:22:47.560 --> 00:22:51.710
the simplest possible
cart would be

00:22:51.710 --> 00:22:55.600
to have a single product called
addition, to which you would

00:22:55.600 --> 00:22:58.300
just shove your products into.

00:22:58.300 --> 00:23:00.890
And then it would have
a stream of integers,

00:23:00.890 --> 00:23:03.460
called itemCount, which
would update every time

00:23:03.460 --> 00:23:04.645
the item count changes.

00:23:09.550 --> 00:23:11.950
Internally at Google, we
call these business logic

00:23:11.950 --> 00:23:17.170
components, so that
is bloc for short.

00:23:17.170 --> 00:23:18.500
Let's switch to the computer.

00:23:18.500 --> 00:23:22.420
And I'm going to
implement it real quick.

00:23:22.420 --> 00:23:24.880
So this would be my computer.

00:23:24.880 --> 00:23:27.390
Yes, I have the same app--

00:23:27.390 --> 00:23:31.180
it doesn't change-- it
doesn't currently work.

00:23:31.180 --> 00:23:35.980
And we'll need to
implement this pattern.

00:23:35.980 --> 00:23:38.140
So I already have
a cart provider

00:23:38.140 --> 00:23:43.270
that uses InheritedWidget
so that I can access cart--

00:23:43.270 --> 00:23:48.030
this object from
anywhere in my tree.

00:23:48.030 --> 00:23:51.640
And, as you can see, I'm
creating this object here,

00:23:51.640 --> 00:23:55.940
and then I'm accessing it in
different parts of my app.

00:23:55.940 --> 00:23:58.480
But I'm not doing
anything with it, yet.

00:23:58.480 --> 00:24:03.010
Also, if you look at the
object now, or the component,

00:24:03.010 --> 00:24:07.600
it is pretty empty-- it only
has the underlying model.

00:24:07.600 --> 00:24:11.530
So what I'm going to do is
I'm going to first implement

00:24:11.530 --> 00:24:14.170
the Sink of products--

00:24:14.170 --> 00:24:15.640
the streaming input.

00:24:15.640 --> 00:24:17.500
I'm going to very
quickly code it up,

00:24:17.500 --> 00:24:21.110
and then I'm going to
tell you what it does.

00:24:21.110 --> 00:24:26.350
So it's going to be a Sink
of products called addition.

00:24:26.350 --> 00:24:33.610
This is that input stream that
you can access externally.

00:24:33.610 --> 00:24:37.120
And then this is backed
by a stream controller

00:24:37.120 --> 00:24:40.090
called additionController.

00:24:40.090 --> 00:24:45.210
StreamController is just a basic
class in the stream library

00:24:45.210 --> 00:24:48.230
in Dart-- the core library.

00:24:48.230 --> 00:24:51.940
And that helps us listen
to the stream of things

00:24:51.940 --> 00:24:53.950
that are coming from outside.

00:24:53.950 --> 00:24:56.080
Now, how would you
use it in your app?

00:24:56.080 --> 00:24:59.920
You would just go to
the product squares,

00:24:59.920 --> 00:25:05.230
and wherever you are trying
to add the streams of events,

00:25:05.230 --> 00:25:08.770
you would just say cart bloc--

00:25:08.770 --> 00:25:09.940
the Sink.

00:25:09.940 --> 00:25:12.250
And then we want to
add to the Sink--

00:25:12.250 --> 00:25:16.300
in this case, we want
to add the products.

00:25:16.300 --> 00:25:20.380
Coming back, we want to
also code the output, which

00:25:20.380 --> 00:25:23.570
is a stream of itemCount.

00:25:23.570 --> 00:25:28.660
Let me just quickly do that--
itemCount is a stream of int.

00:25:28.660 --> 00:25:32.200
And it is backed by
something that you

00:25:32.200 --> 00:25:34.740
might know, BehaviorSubject.

00:25:34.740 --> 00:25:38.680
BehaviorSubject is
coming from ReactiveX,

00:25:38.680 --> 00:25:43.810
and it is a different
kind of stream controller

00:25:43.810 --> 00:25:46.040
that has memory of
its latest value.

00:25:46.040 --> 00:25:48.490
So, whenever you listen
to it, it will immediately

00:25:48.490 --> 00:25:50.200
give you that latest value.

00:25:50.200 --> 00:25:52.690
This is in contrast to
normal stream controllers,

00:25:52.690 --> 00:25:55.220
or streams, where,
when you listen to it,

00:25:55.220 --> 00:25:58.930
you will have to wait
until the value changes.

00:25:58.930 --> 00:26:02.210
That could be sometime
in the future.

00:26:02.210 --> 00:26:05.620
In our case, we want to
always have the latest value--

00:26:05.620 --> 00:26:09.400
the moment that we
listen to a stream.

00:26:09.400 --> 00:26:11.410
Now, how would we use that?

00:26:11.410 --> 00:26:15.166
Well, now we get to use
the StreamBuilder class.

00:26:15.166 --> 00:26:16.540
So we have the
cart button here--

00:26:16.540 --> 00:26:21.400
we want it to listen to
changes to the itemCount.

00:26:21.400 --> 00:26:26.440
I'm going to wrap it with a
StreamBuilder of integers.

00:26:26.440 --> 00:26:30.880
It's going to listen to
the itemCount stream.

00:26:30.880 --> 00:26:33.550
The initial data is
going to be zero.

00:26:33.550 --> 00:26:38.260
And then, in here, I can
just access the snapshot

00:26:38.260 --> 00:26:41.260
of the data, which will
always be the latest

00:26:41.260 --> 00:26:44.350
value of the itemCount.

00:26:44.350 --> 00:26:46.930
So we have this.

00:26:46.930 --> 00:26:52.010
Now, all we need to do is to
merge the streams together,

00:26:52.010 --> 00:26:53.794
so that's what I'm
going to do just now.

00:26:53.794 --> 00:26:55.210
MATT SULLIVAN:
This is where Filip

00:26:55.210 --> 00:26:57.084
will make the magic
happen behind the scenes,

00:26:57.084 --> 00:27:00.250
because we've got a bunch
of products coming inbound.

00:27:00.250 --> 00:27:01.840
And what we need
to do is we need

00:27:01.840 --> 00:27:04.507
to listen for changes on that,
because we're not capturing it

00:27:04.507 --> 00:27:05.090
at the moment.

00:27:05.090 --> 00:27:10.790
We need to add those
products to the cart itself.

00:27:10.790 --> 00:27:12.310
So what Filip is
doing now-- he's

00:27:12.310 --> 00:27:15.100
getting access to the
stream, he's listening to it.

00:27:15.100 --> 00:27:17.260
And then, the product will
be the event coming in,

00:27:17.260 --> 00:27:18.760
and all we need to
do at this point,

00:27:18.760 --> 00:27:20.420
then, is add that
product to the cart.

00:27:20.420 --> 00:27:20.920
Great.

00:27:20.920 --> 00:27:23.520
So now we have state managed.

00:27:23.520 --> 00:27:25.270
The other thing we
need to do is make sure

00:27:25.270 --> 00:27:29.020
that itemCount is always
updated when products are added.

00:27:29.020 --> 00:27:31.300
And all we need to do
there is do what we did,

00:27:31.300 --> 00:27:33.220
but in the opposite direction--

00:27:33.220 --> 00:27:36.700
is to add the itemCount
to the itemCount stream.

00:27:36.700 --> 00:27:39.630
And we're done?

00:27:39.630 --> 00:27:41.089
FILIP HRACEK: Yep, we're done.

00:27:41.089 --> 00:27:42.380
Back to you the slides, please.

00:27:46.110 --> 00:27:51.140
So, as you could see, we were
able to implement this business

00:27:51.140 --> 00:27:53.160
logic component pretty quickly.

00:27:53.160 --> 00:27:55.310
It is a little more
complicated, but it gives you

00:27:55.310 --> 00:27:56.720
a lot of cool stuff.

00:27:59.390 --> 00:28:03.620
First of all, it is really
just steams in, streams out.

00:28:03.620 --> 00:28:05.990
Whatever happens
in the component,

00:28:05.990 --> 00:28:08.900
you don't care about--

00:28:08.900 --> 00:28:11.120
as a Flutter UI.

00:28:11.120 --> 00:28:14.600
Then, we could add more
things to this bloc.

00:28:14.600 --> 00:28:18.770
So we could add a
stream of total cost.

00:28:18.770 --> 00:28:23.210
Whenever the cost
of the cart changes,

00:28:23.210 --> 00:28:27.410
you probably want to update
your user to give it that.

00:28:27.410 --> 00:28:31.910
And then, you have a stream
of lists of cart items, which

00:28:31.910 --> 00:28:33.920
is the items that you
want to always update

00:28:33.920 --> 00:28:37.700
whenever you add something to
the cart, or remove from it.

00:28:37.700 --> 00:28:38.920
So that is cool.

00:28:38.920 --> 00:28:41.630
And, again, these are
different aspects of our model

00:28:41.630 --> 00:28:44.670
that we want to show.

00:28:44.670 --> 00:28:47.780
Now, I have a problem
with one part of this,

00:28:47.780 --> 00:28:48.870
and that is this part.

00:28:48.870 --> 00:28:54.260
We're streaming the total cost
as integers, which makes sense

00:28:54.260 --> 00:28:56.360
internally in the component--

00:28:56.360 --> 00:28:59.990
it is a numerical
value, after all.

00:28:59.990 --> 00:29:05.630
But what it leads to is code
in your views like this.

00:29:05.630 --> 00:29:09.890
You have to somehow convert,
or format, the numerical value

00:29:09.890 --> 00:29:11.930
to some kind of string.

00:29:11.930 --> 00:29:15.080
Which is, if you think
about it, business logic--

00:29:15.080 --> 00:29:17.810
this shouldn't be in views.

00:29:17.810 --> 00:29:20.330
So you can go back
to your CartBloc,

00:29:20.330 --> 00:29:23.690
and you can just change
this to a stream of string

00:29:23.690 --> 00:29:25.340
that is already formatted.

00:29:25.340 --> 00:29:28.820
So whenever you want to
show your total cost,

00:29:28.820 --> 00:29:31.160
you just stream
the formatted one.

00:29:31.160 --> 00:29:34.640
And so you just reuse that
same business logic that

00:29:34.640 --> 00:29:37.100
is inside the component now.

00:29:37.100 --> 00:29:39.470
That gives you another
very cool thing,

00:29:39.470 --> 00:29:42.950
and that is that if
you add a new thing,

00:29:42.950 --> 00:29:45.410
or new input to the model--

00:29:45.410 --> 00:29:47.600
sorry, to the component--

00:29:47.600 --> 00:29:49.970
for example, Sink of Locale.

00:29:49.970 --> 00:29:53.480
So users, now, can change
anywhere in your app

00:29:53.480 --> 00:29:57.230
from a US shop to an EU shop.

00:29:57.230 --> 00:30:03.840
Now, you can pipe this change
as a stream to the total cost.

00:30:03.840 --> 00:30:06.530
And so, internally,
in the bloc, you

00:30:06.530 --> 00:30:10.250
will update the
total costs string,

00:30:10.250 --> 00:30:14.420
even though maybe the numerical
value is still the same.

00:30:14.420 --> 00:30:16.800
And that means that
anywhere in the app

00:30:16.800 --> 00:30:18.570
that the user changes
this, you don't

00:30:18.570 --> 00:30:21.110
need to think about
it as a developer.

00:30:21.110 --> 00:30:23.780
It will always update
anywhere else--

00:30:23.780 --> 00:30:25.010
the total cost.

00:30:25.010 --> 00:30:30.340
This would be a real pain
to implement any other way.

00:30:30.340 --> 00:30:35.160
So we have this nice
flow of data and events.

00:30:35.160 --> 00:30:37.920
We have widgets that
are only listening

00:30:37.920 --> 00:30:40.020
to what they need to know.

00:30:40.020 --> 00:30:42.780
And we're using good
old StreamBuilders

00:30:42.780 --> 00:30:43.740
to make that work.

00:30:46.480 --> 00:30:49.020
MATT SULLIVAN: So let's take
a look at what we have now.

00:30:49.020 --> 00:30:51.810
Accessing state
in Fillips example

00:30:51.810 --> 00:30:54.180
was solved by using
the InheritedWidget

00:30:54.180 --> 00:30:58.090
pattern to pass access to
the bloc down the tree.

00:30:58.090 --> 00:31:00.990
We now have very fine
updating on change,

00:31:00.990 --> 00:31:02.550
because we have
different aspects

00:31:02.550 --> 00:31:05.100
of our data being represented
by different streams.

00:31:05.100 --> 00:31:08.940
And those widgets
subscribing to those screams

00:31:08.940 --> 00:31:12.060
will only rebuild when those
aspects of data changes.

00:31:12.060 --> 00:31:14.010
And, finally, we now
have the converse--

00:31:14.010 --> 00:31:17.210
we have mutating state
by pumping data--

00:31:17.210 --> 00:31:19.710
or requests to mutate state--

00:31:19.710 --> 00:31:21.720
into our business
logic, where we're

00:31:21.720 --> 00:31:24.960
observing for change, and
then we can update it there.

00:31:24.960 --> 00:31:27.600
There's this nice pattern of
pushing data in via streams,

00:31:27.600 --> 00:31:32.010
and then updating via streams,
which we think is very elegant.

00:31:32.010 --> 00:31:34.800
This is great, but
you all have options.

00:31:34.800 --> 00:31:38.040
SetState() works fine if you
have a very shallow tree,

00:31:38.040 --> 00:31:39.870
and your app is fairly simple.

00:31:39.870 --> 00:31:42.960
ScopedModel is a fantastic
way for a model, which

00:31:42.960 --> 00:31:46.230
is relatively straightforward,
to be passed up and down,

00:31:46.230 --> 00:31:49.890
and change on a tree
of arbitrary depth.

00:31:49.890 --> 00:31:52.230
For those of you who
like the redux pattern,

00:31:52.230 --> 00:31:54.600
there is an excellent
redux implementation built

00:31:54.600 --> 00:31:57.000
by the community-- the
redux package for Dart,

00:31:57.000 --> 00:32:01.320
and Flutter Redux
for Flutter, which

00:32:01.320 --> 00:32:03.810
will give you that pattern,
and you can use that as well.

00:32:03.810 --> 00:32:05.820
But if there's one
thing that we'd

00:32:05.820 --> 00:32:08.130
like you to take
away from this, it's

00:32:08.130 --> 00:32:13.720
that Flutter's widgets, in
combination with streams,

00:32:13.720 --> 00:32:17.830
gives you a very reactive way
to not only handle your UI,

00:32:17.830 --> 00:32:20.230
but handle the flow of
data through your app,

00:32:20.230 --> 00:32:24.400
and handle the updating of
your UI when that data changes.

00:32:24.400 --> 00:32:26.830
So we highly recommend
you go and check

00:32:26.830 --> 00:32:34.150
out Dart Streams, and the rxdart
as an option for building state

00:32:34.150 --> 00:32:35.500
in your apps.

00:32:35.500 --> 00:32:36.980
We'd love to hear from you.

00:32:36.980 --> 00:32:40.396
Please go to the site,
and give us some feedback.

00:32:40.396 --> 00:32:41.770
All of the code
you've seen today

00:32:41.770 --> 00:32:43.841
is in Fillips GitHub account.

00:32:43.841 --> 00:32:45.340
I did some pull
requests-- honestly,

00:32:45.340 --> 00:32:46.810
he didn't write everything.

00:32:46.810 --> 00:32:48.880
And not only do we show
you the code we showed,

00:32:48.880 --> 00:32:50.364
but we have a redux
implementation

00:32:50.364 --> 00:32:52.780
and a couple of others there
as well for you to check out.

00:32:52.780 --> 00:32:54.529
I want to give a shout
out to the cookbook

00:32:54.529 --> 00:32:57.040
that us and the community
have been working on.

00:32:57.040 --> 00:32:59.110
There's some wonderful
patterns in there--

00:32:59.110 --> 00:33:02.440
everything from widget
creation, to network, to JSON.

00:33:02.440 --> 00:33:03.820
It's a great place to go.

00:33:03.820 --> 00:33:05.410
And there were two
other talks that

00:33:05.410 --> 00:33:06.577
have happened prior to this.

00:33:06.577 --> 00:33:08.701
Fortunately, we have a time
machine called YouTube,

00:33:08.701 --> 00:33:09.880
so you can go back in time.

00:33:09.880 --> 00:33:12.370
And if you want to learn
about building beautiful UIs,

00:33:12.370 --> 00:33:15.130
or building apps end-to-end, I
would recommend you check those

00:33:15.130 --> 00:33:16.660
out-- those are good talks.

00:33:16.660 --> 00:33:19.200
And I would like to say
thank you for your time.

00:33:19.200 --> 00:33:20.200
FILIP HRACEK: Thank you.

00:33:20.200 --> 00:33:23.679
[APPLAUSE]

00:33:23.679 --> 00:33:28.408
[MUSIC PLAYING]

