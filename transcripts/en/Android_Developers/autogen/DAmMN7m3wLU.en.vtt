WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.348
 Oh, good morning everyone. 

00:00:01.348 --> 00:00:03.770
 Welcome to the Advanced Data Binding Lecture 

00:00:03.770 --> 00:00:05.600
 I am Yigit Boyar. 

00:00:05.600 --> 00:00:07.110
 I am George Mount. 

00:00:07.110 --> 00:00:09.440
 We are from the Android UI Toolkit team 

00:00:09.440 --> 00:00:11.780
 Part of the Android Architecture team 

00:00:11.780 --> 00:00:14.608
 Today, let's talk about data binding. 

00:00:17.660 --> 00:00:19.310
 Ok 

00:00:19.310 --> 00:00:22.220
 How many of you have used data binding in the past? 

00:00:22.220 --> 00:00:22.990
 Ok 

00:00:22.990 --> 00:00:25.329
 How many people think that it is still in the testing stage? 

00:00:25.329 --> 00:00:25.995
 it is good 

00:00:25.995 --> 00:00:27.439
 Well, this is the problem. 

00:00:27.439 --> 00:00:29.230
 We didn't make a big announcement last fall. 

00:00:29.230 --> 00:00:32.140
 When we release it with Android Studio 

00:00:32.140 --> 00:00:34.330
 Now available 

00:00:34.330 --> 00:00:36.031
 Welcome everyone to use it 

00:00:36.031 --> 00:00:37.030
 It is very high quality 

00:00:37.030 --> 00:00:40.200
 It performed very well in the public beta 

00:00:40.200 --> 00:00:42.940
 So if you haven't seen it yet, I have a link here. 

00:00:42.940 --> 00:00:45.260
 This link is about before in the Android Developer Summit 

00:00:45.260 --> 00:00:48.280
 Video about Android data binding 

00:00:48.280 --> 00:00:49.664
 You just have to click here 

00:00:49.664 --> 00:00:51.080
 If you watch at home, 

00:00:51.080 --> 00:00:52.700
 You can click on it now 

00:00:52.700 --> 00:00:56.250
 Pause the video, check out this link 

00:00:56.250 --> 00:00:58.385
 Because we are about to show you a lite version of about four minutes. 

00:00:58.385 --> 00:01:01.962
 This includes everything from just 40 minutes. 

00:01:01.962 --> 00:01:02.920
 It is very good 

00:01:02.920 --> 00:01:03.920
 Ok 

00:01:03.920 --> 00:01:06.320
 So what is data binding? 

00:01:06.320 --> 00:01:08.970
 When we have such a layout 

00:01:08.970 --> 00:01:10.790
 This is my store 

00:01:10.790 --> 00:01:13.060
 And what I want to do is -- because 

00:01:13.060 --> 00:01:15.810
 I certainly want to load data in the layout. 

00:01:15.810 --> 00:01:19.150
 Of course, I have to find 

00:01:19.150 --> 00:01:20.220
 View in my layout 

00:01:20.220 --> 00:01:22.980
 Then set all the data, right? 

00:01:22.980 --> 00:01:25.590
 This is terrible, right? 

00:01:25.590 --> 00:01:27.420
 I hate doing these 

00:01:28.140 --> 00:01:30.715
 So we use Android data binding 

00:01:31.965 --> 00:01:33.740
 Let's take a look at that layout again. 

00:01:33.740 --> 00:01:36.810
 Ok, we have to get rid of all the setting logic 

00:01:36.810 --> 00:01:37.830
 These settings are very troublesome 

00:01:37.830 --> 00:01:40.314
 FindViewByID is really bad. 

00:01:40.314 --> 00:01:42.230
 But we have to do some different settings 

00:01:42.230 --> 00:01:43.020
 In onCreate 

00:01:43.020 --> 00:01:46.260
 We don't call setContentView 

00:01:46.260 --> 00:01:49.890
 We must have a different setContentView 

00:01:49.890 --> 00:01:53.050
 This will create a data binding 

00:01:53.050 --> 00:01:57.275
 Then we have to set the data target on that binding. 

00:01:57.815 --> 00:01:59.065
 But we can't just do these 

00:01:59.065 --> 00:02:01.500
 We have to adjust a little bit of our layout. 

00:02:01.500 --> 00:02:04.910
 First, add a layout label 

00:02:04.910 --> 00:02:06.010
 Outside of this 

00:02:06.010 --> 00:02:09.230
 Of course, we have to move the namespace to the position of the layout label. 

00:02:09.230 --> 00:02:10.520
 Because that's the right thing 

00:02:10.870 --> 00:02:12.919
 We still have a data tag 

00:02:12.919 --> 00:02:14.960
 That tag has all the variables we want to use. 

00:02:14.960 --> 00:02:18.822
 Here, for the production of our products 

00:02:18.822 --> 00:02:22.920
 It helps us import and load variables 

00:02:22.920 --> 00:02:24.822
 So that we can use it in the layout 

00:02:24.822 --> 00:02:26.530
 We also need to quote them 

00:02:26.530 --> 00:02:31.130
 So we add the value directly to our reference source 

00:02:31.130 --> 00:02:33.670
 Or other elements already in our layout 

00:02:33.670 --> 00:02:36.580
 Now you can see that we can use any expression 

00:02:36.580 --> 00:02:42.489
 We can use @{ to mark this as a data binding tag. 

00:02:42.489 --> 00:02:43.447
 Let's take a look at how it works. 

00:02:45.610 --> 00:02:47.735
 Data integration is really amazing 

00:02:47.735 --> 00:02:50.175
 And you need a brief explanation 

00:02:50.175 --> 00:02:51.565
 It can be even more amazing 

00:02:51.565 --> 00:02:53.220
 For example, there are standardized steps to tell us 

00:02:53.220 --> 00:02:55.460
 How to prepare, it is important to know this 

00:02:55.460 --> 00:02:58.460
 So you can know what happened behind the scenes 

00:02:58.460 --> 00:03:00.500
 If you are having trouble 

00:03:00.500 --> 00:03:03.000
 You will have a clue where is the problem? 

00:03:03.000 --> 00:03:06.667
 When you click "Run" in Android Studio 

00:03:06.667 --> 00:03:08.875
 Android Studio will start assembling your app 

00:03:08.875 --> 00:03:10.980
 And merge your resources 

00:03:10.980 --> 00:03:14.016
 When layout files are merged 

00:03:14.016 --> 00:03:17.360
 We can choose those layout files 

00:03:17.360 --> 00:03:19.432
 Then delete all the information about the data binding 

00:03:19.432 --> 00:03:22.116
 So all the data you entered about data binding will be deleted. 

00:03:22.615 --> 00:03:25.290
 If you add data binding information to the layout 

00:03:25.290 --> 00:03:27.160
 You will lose it 

00:03:27.980 --> 00:03:30.300
 Next, we parse these expressions 

00:03:30.300 --> 00:03:32.230
 So their grammar is correct 

00:03:32.230 --> 00:03:34.400
 But we don't know if the information you entered makes sense 

00:03:34.400 --> 00:03:37.130
 But they must be grammatically correct 

00:03:37.130 --> 00:03:39.630
 So when we parse, we know 

00:03:39.630 --> 00:03:41.150
 Here are some identifiers here 

00:03:41.150 --> 00:03:42.730
 Enter your field 

00:03:42.730 --> 00:03:44.209
 We donâ€™t know what this is at this stage. 

00:03:44.209 --> 00:03:45.250
 When we know it is correct 

00:03:45.250 --> 00:03:49.130
 If not correct, there will be an error report 

00:03:49.130 --> 00:03:52.570
 Next, your application code will be compiled 

00:03:52.570 --> 00:03:54.520
 The java code you write will be compiled 

00:03:54.520 --> 00:03:56.600
 When it is compiled 

00:03:56.600 --> 00:03:58.240
 We use handlers 

00:03:58.240 --> 00:04:02.820
 Get the output we parse from the layout file 

00:04:02.820 --> 00:04:04.600
 To understand its meaning 

00:04:04.600 --> 00:04:07.320
 For example, you have a user.admin 

00:04:07.320 --> 00:04:09.066
 Now you can specify your variables 

00:04:09.066 --> 00:04:10.690
 We know there are some user costs here. 

00:04:10.690 --> 00:04:12.090
 We find these costs 

00:04:12.090 --> 00:04:14.594
 Then we have to find out what is the meaning of isAdmin 

00:04:14.594 --> 00:04:15.760
 Is it a method call? 

00:04:15.760 --> 00:04:17.019
 Still a field? 

00:04:17.019 --> 00:04:19.006
 We found this answer 

00:04:19.006 --> 00:04:22.630
 We finally liked this management method. 

00:04:22.630 --> 00:04:24.650
 Or you can type user.admin 

00:04:24.650 --> 00:04:27.440
 We still know that this is a 

00:04:27.440 --> 00:04:28.720
 Is.admin Boolean method 

00:04:28.720 --> 00:04:31.560
 Then we can understand that this grammar was expressed before 

00:04:31.560 --> 00:04:33.830
 Can be parsed into a Boolean value 

00:04:33.830 --> 00:04:36.620
 Now let's look at its properties 

00:04:36.620 --> 00:04:40.050
 I have to know what regulator to call. 

00:04:40.050 --> 00:04:44.770
 Is this an integer that can be seen, or is it enabled, can we solve this problem? 

00:04:44.770 --> 00:04:47.060
 It all happened in 

00:04:47.060 --> 00:04:48.520
 When the application is compiled 

00:04:48.520 --> 00:04:51.920
 When we decide what we want to do, we use the code 

00:04:51.920 --> 00:04:54.010
 Write data binding to update the user interface 

00:04:54.010 --> 00:04:56.050
 Then you can benefit 

00:04:57.090 --> 00:05:02.600
 In a nutshell, this is a data binding layout file. 

00:05:02.600 --> 00:05:06.020
 We did this at compile time. 

00:05:06.020 --> 00:05:07.150
 Delete all information 

00:05:07.150 --> 00:05:09.660
 We try to get the file and code 

00:05:09.660 --> 00:05:11.499
 Match each other as much as possible 

00:05:11.499 --> 00:05:13.040
 If you view your files 

00:05:13.040 --> 00:05:15.520
 You will find this file with deleted information. 

00:05:15.520 --> 00:05:17.276
 So we delete the layout label 

00:05:17.276 --> 00:05:19.520
 We remove all data binding settings 

00:05:19.520 --> 00:05:21.900
 Because APT doesn't know them 

00:05:21.900 --> 00:05:22.930
 We clean them up 

00:05:22.930 --> 00:05:27.690
 Then we click on some tags so -- next, well -- 

00:05:27.690 --> 00:05:31.180
 When you zoom in on the layout you will know 

00:05:31.180 --> 00:05:33.860
 That's why even if you didn't put the ID here 

00:05:33.860 --> 00:05:36.290
 We can also find the reason for it 

00:05:37.380 --> 00:05:39.307
 Here, George has some gifts for everyone. 

00:05:40.560 --> 00:05:44.080
 So this is what we released in the fall. 

00:05:44.080 --> 00:05:46.670
 Let's see what new features are available. 

00:05:46.670 --> 00:05:47.600
 Two-way data binding 

00:05:47.600 --> 00:05:50.500
 I know that I heard a lot of people say 

00:05:50.500 --> 00:05:52.840
 This is really great. 

00:05:52.840 --> 00:05:55.340
 Single if there is no two-way data binding 

00:05:55.340 --> 00:05:56.962
 Data binding is not useful, right? 

00:05:56.962 --> 00:05:58.170
 I really can't believe to hear these 

00:05:58.170 --> 00:06:01.780
 Because I think one-way data binding is also very useful 

00:06:02.520 --> 00:06:03.530
 I saw some people 

00:06:03.530 --> 00:06:06.014
 Want to do some of their own things with two-way data binding 

00:06:06.014 --> 00:06:07.470
 They did something like this 

00:06:07.470 --> 00:06:12.680
 That is, they use the original data binding field for one-way data binding. 

00:06:12.680 --> 00:06:14.460
 Then add another processor 

00:06:14.460 --> 00:06:16.002
 To change the text 

00:06:17.062 --> 00:06:18.770
 Of course, they have to check 

00:06:18.770 --> 00:06:21.019
 Is there a change, otherwise 

00:06:21.019 --> 00:06:26.092
 Text changes will cycle continuously 

00:06:26.092 --> 00:06:27.550
 Then it will go back to the field area 

00:06:27.550 --> 00:06:30.240
 And send a text change message 

00:06:30.240 --> 00:06:31.650
 Thatâ€™s a mess. 

00:06:31.650 --> 00:06:34.710
 You will get in your layout 

00:06:34.710 --> 00:06:39.780
 This change handler gives each different binding view 

00:06:39.780 --> 00:06:41.810
 This is really bad 

00:06:41.810 --> 00:06:45.140
 So we want a better solution 

00:06:45.610 --> 00:06:47.760
 Get rid of all the methods you are used to 

00:06:47.760 --> 00:06:50.550
 We can do it on our own 

00:06:50.550 --> 00:06:53.300
 By using @= instead of @{, right? 

00:06:53.300 --> 00:06:57.060
 @= is a very fast, easy to see indicator 

00:06:57.060 --> 00:06:59.700
 This indicates that this is a two-way data binding field 

00:06:59.700 --> 00:07:01.850
 Now we can use a very simple method 

00:07:01.850 --> 00:07:05.630
 Bind Android text fields 

00:07:06.340 --> 00:07:08.930
 Now, you might wonder how this notification is implemented. 

00:07:08.930 --> 00:07:11.329
 What is the operation behind it? 

00:07:11.329 --> 00:07:12.870
 This is very important 

00:07:12.870 --> 00:07:14.729
 If you want to write your own data binding fields 

00:07:14.729 --> 00:07:17.020
 First of all, we have to know 

00:07:17.020 --> 00:07:17.945
 Which monitor to add 

00:07:17.945 --> 00:07:19.980
 We won't want to use TextWatcher 

00:07:19.980 --> 00:07:22.701
 Because this is only valid for text viewing and editing 

00:07:23.860 --> 00:07:27.469
 We don't want to use -- I don't know, what? 

00:07:27.469 --> 00:07:28.510
 Time change 

00:07:28.510 --> 00:07:29.060
 Time change 

00:07:29.060 --> 00:07:30.800
 Yes, date changes, etc. 

00:07:30.800 --> 00:07:31.480
 That is bad 

00:07:31.480 --> 00:07:32.730
 So we have some general purpose monitors 

00:07:32.730 --> 00:07:34.438
 Reverse binding listener 

00:07:34.438 --> 00:07:36.340
 It will tell you 

00:07:36.340 --> 00:07:39.510
 Changed in your view 

00:07:39.510 --> 00:07:42.490
 Your binding will be for you 

00:07:42.490 --> 00:07:44.550
 Install this listener 

00:07:44.550 --> 00:07:48.173
 These codes are generated directly by the generated code program. 

00:07:48.500 --> 00:07:50.560
 You can see what happened here 

00:07:50.560 --> 00:07:53.227
 Is it gets the text from the view 

00:07:53.719 --> 00:07:55.510
 Then it did an empty test 

00:07:55.510 --> 00:07:57.690
 You must make sure that you do all the empty detection. 

00:07:57.690 --> 00:07:59.280
 Everyone here has to look at your variables over and over again. 

00:07:59.280 --> 00:07:59.745
 right? 

00:07:59.745 --> 00:08:00.200
 Ok? 

00:08:00.200 --> 00:08:00.840
 everyone? 

00:08:00.840 --> 00:08:01.270
 Yes 

00:08:01.270 --> 00:08:01.580
 I know 

00:08:01.580 --> 00:08:02.910
 You are not using data binding 

00:08:03.596 --> 00:08:04.721
 You don't need an empty test 

00:08:04.721 --> 00:08:05.827
 Yes 

00:08:05.827 --> 00:08:06.785
 It is 2016 

00:08:06.785 --> 00:08:08.830
 Yes, right 

00:08:08.830 --> 00:08:10.080
 Who has not had an abnormal pointer? 

00:08:10.080 --> 00:08:10.490
 I do not know 

00:08:10.490 --> 00:08:10.930
 nobody 

00:08:10.930 --> 00:08:12.110
 what language? 

00:08:12.110 --> 00:08:13.410
 Finally it sets the field 

00:08:13.410 --> 00:08:15.660
 You can see that the field is set to 

00:08:15.660 --> 00:08:17.897
 Observable field 

00:08:17.897 --> 00:08:19.730
 In fact, you may be interested to see 

00:08:19.730 --> 00:08:25.265
 Because this comment is in the generated code 

00:08:25.265 --> 00:08:27.390
 So if you want to see the generated code, 

00:08:27.390 --> 00:08:28.889
 You will see this comment 

00:08:28.889 --> 00:08:30.669
 And see the inverse of this expression 

00:08:30.669 --> 00:08:32.960
 To help you debug if you have problems 

00:08:36.039 --> 00:08:38.950
 So let's see how you get the field value 

00:08:38.950 --> 00:08:41.080
 We just saw -- get the field value 

00:08:41.080 --> 00:08:43.960
 One thing we need to do to annotate the fastest comment 

00:08:43.960 --> 00:08:50.882
 This can give your view an absorber 

00:08:52.040 --> 00:08:54.000
 Here we have a text view type 

00:08:54.000 --> 00:08:58.880
 We want to know what is the absorber for android:text. 

00:08:59.130 --> 00:09:00.500
 Now we have this method 

00:09:00.500 --> 00:09:01.425
 We can declare it 

00:09:01.425 --> 00:09:02.560
 It's called getText 

00:09:02.560 --> 00:09:06.980
 But if you don't set it it is a default setting 

00:09:06.980 --> 00:09:08.790
 It only uses attribute names 

00:09:08.790 --> 00:09:11.350
 Even if we don't set any properties it will use getTest 

00:09:11.350 --> 00:09:15.210
 Because the property is android:text 

00:09:15.210 --> 00:09:17.760
 Itâ€™s very wise to do this 

00:09:17.760 --> 00:09:20.770
 And we have this comprehensive attribute 

00:09:20.770 --> 00:09:22.730
 This is for this event 

00:09:22.730 --> 00:09:24.760
 This event push notification 

00:09:24.760 --> 00:09:27.480
 Tell us what has changed in the view 

00:09:27.600 --> 00:09:29.832
 Once again, there are default settings there. 

00:09:29.832 --> 00:09:31.540
 If we have not set 

00:09:31.540 --> 00:09:34.212
 It will be android:textAttrChanged 

00:09:34.470 --> 00:09:36.740
 Most of the time, you won't be making any settings here. 

00:09:38.190 --> 00:09:41.260
 Now, I want to talk more about this aspect. 

00:09:41.260 --> 00:09:44.380
 Of course, we have to go from the text view 

00:09:44.380 --> 00:09:46.120
 Get notified 

00:09:46.490 --> 00:09:48.900
 This is what you usually do with the text view. 

00:09:48.900 --> 00:09:50.480
 You will set a TextWatcher 

00:09:50.480 --> 00:09:53.330
 We have the properties of this event 

00:09:53.330 --> 00:09:55.790
 In the binding debugger 

00:09:55.790 --> 00:09:59.570
 So we just added another attribute 

00:09:59.570 --> 00:10:00.600
 Comprehensive attribute 

00:10:00.600 --> 00:10:02.060
 Now, this comprehensive attribute - you 

00:10:02.060 --> 00:10:03.740
 Can't be used in your layout 

00:10:03.740 --> 00:10:05.050
 We will check it 

00:10:05.050 --> 00:10:06.380
 If you try to do this 

00:10:06.380 --> 00:10:12.720
 It will give you an exception or error message 

00:10:12.720 --> 00:10:16.054
 Anyway, you can now set this in your binding adapter. 

00:10:16.054 --> 00:10:17.720
 Of course, all are set for you. 

00:10:17.720 --> 00:10:19.727
 All fields that can run 

00:10:19.727 --> 00:10:21.310
 Of course, what do you need to do? 

00:10:21.310 --> 00:10:22.970
 You need to remove the previous adapter 

00:10:22.970 --> 00:10:25.200
 Then add a new one 

00:10:25.200 --> 00:10:28.140
 You just need to inform them if they are not null, right? 

00:10:28.140 --> 00:10:29.640
 We don't want to notify the empty value of things 

00:10:29.640 --> 00:10:32.722
 Because we want to do null detection 

00:10:33.232 --> 00:10:35.440
 Then we also need to notify our onChange 

00:10:35.440 --> 00:10:38.490
 So now, we know that when the text view changes 

00:10:38.490 --> 00:10:42.060
 It will call the generated onChange 

00:10:42.060 --> 00:10:44.920
 If you have a more complicated absorber -- but 

00:10:44.920 --> 00:10:47.810
 This is not very complicated, just a little more complicated. 

00:10:47.810 --> 00:10:51.494
 This text view does not return a string, what does it return? 

00:10:53.014 --> 00:10:53.804
 Yes 

00:10:53.804 --> 00:10:54.990
 Character sequence, right? 

00:10:54.990 --> 00:10:57.135
 Who uses the character sequence here? 

00:10:57.135 --> 00:10:58.390
 Oh, no one uses character sequences 

00:10:58.390 --> 00:11:00.485
 If you want to set the character sequence to a string? 

00:11:00.485 --> 00:11:01.620
 Type conversion error 

00:11:01.620 --> 00:11:03.550
 So this will be convenient 

00:11:03.550 --> 00:11:06.130
 You have a getTextString 

00:11:06.130 --> 00:11:10.937
 It will automatically convert your character sequence to a string 

00:11:10.937 --> 00:11:13.020
 This can help you 

00:11:13.020 --> 00:11:14.860
 Again, we have this property 

00:11:14.860 --> 00:11:17.750
 Other character fields are also there - that event 

00:11:17.750 --> 00:11:19.462
 Are default settings 

00:11:19.462 --> 00:11:21.170
 We mentioned these loops before. 

00:11:21.170 --> 00:11:25.664
 That is if you have a text view, or edit the text 

00:11:25.664 --> 00:11:27.080
 It will make changes, of course -- 

00:11:27.080 --> 00:11:29.320
 It will change your data field 

00:11:29.320 --> 00:11:31.300
 If your data field has changed 

00:11:31.300 --> 00:11:33.264
 Will change your [inaudible] 

00:11:33.264 --> 00:11:35.180
 This is really bad. Because what happened? 

00:11:35.180 --> 00:11:38.970
 The user enters A, but it displays the text again on it. 

00:11:38.970 --> 00:11:40.347
 And you lost your cursor 

00:11:40.347 --> 00:11:41.316
 Oh! 

00:11:41.316 --> 00:11:42.690
 Yes, you will realize this 

00:11:42.690 --> 00:11:46.020
 If you set the text in the text view it will become the same text 

00:11:46.020 --> 00:11:47.910
 It is still called a change listener 

00:11:47.910 --> 00:11:50.430
 It will have the same layout 

00:11:50.430 --> 00:11:53.032
 Because in the internal [inaudible] is actually a 

00:11:53.032 --> 00:11:53.990
 [inaudible] string 

00:11:53.990 --> 00:11:56.650
 It has some other formats so we have to do this 

00:11:56.650 --> 00:11:57.600
 Yes 

00:11:57.600 --> 00:11:59.350
 So we have already talked about data binding 

00:11:59.350 --> 00:12:00.140
 What do you think? 

00:12:00.140 --> 00:12:01.206
 Actually 

00:12:01.206 --> 00:12:02.694
 It can do more 

00:12:02.694 --> 00:12:05.580
 Because it just realized that there is another change 

00:12:05.580 --> 00:12:07.530
 Of course, it will send another text change 

00:12:07.530 --> 00:12:09.290
 Will continue to last 

00:12:09.290 --> 00:12:10.360
 This is really bad 

00:12:10.360 --> 00:12:13.750
 No one likes an infinite data binding loop 

00:12:13.750 --> 00:12:14.910
 Let us solve this problem 

00:12:14.910 --> 00:12:17.440
 We will solve this problem completely, right? 

00:12:17.930 --> 00:12:19.902
 Unfortunately, can't 

00:12:21.180 --> 00:12:23.260
 But you can solve this problem 

00:12:23.260 --> 00:12:25.834
 We solve this problem for all the settings already applied. 

00:12:26.230 --> 00:12:28.704
 You only need to check the binding adapter 

00:12:28.704 --> 00:12:31.445
 When we set a text field we look at the previous value 

00:12:31.445 --> 00:12:33.480
 Make sure it has not been changed 

00:12:33.480 --> 00:12:35.490
 If it is changed then we need to set it up 

00:12:35.490 --> 00:12:37.490
 If it hasn't been changed, we don't have to set it up. 

00:12:37.490 --> 00:12:39.669
 This can be obtained in our 

00:12:39.669 --> 00:12:41.650
 Break the loop before the infinite loop 

00:12:43.417 --> 00:12:45.000
 This is what we are in data binding 

00:12:45.000 --> 00:12:46.280
 Solution used 

00:12:46.280 --> 00:12:48.920
 Changing the architecture is an option 

00:12:48.920 --> 00:12:50.950
 But only valid for new devices 

00:12:50.950 --> 00:12:55.010
 By doing these workarounds, can we support data binding API 7? 

00:12:55.010 --> 00:12:57.620
 API 7, yes. 

00:12:57.620 --> 00:12:59.630
 Are all the properties valid? 

00:12:59.830 --> 00:13:00.530
 no 

00:13:00.530 --> 00:13:01.370
 of course not 

00:13:01.370 --> 00:13:02.772
 Because we need events 

00:13:02.772 --> 00:13:04.980
 We need events to know if the field has been changed 

00:13:04.980 --> 00:13:06.460
 Whether the attribute has been changed 

00:13:06.460 --> 00:13:07.694
 So we only do 

00:13:07.694 --> 00:13:11.610
 There are change events such as TextWatcher 

00:13:11.610 --> 00:13:13.802
 Like CheckedChanged 

00:13:13.802 --> 00:13:15.010
 These are external events 

00:13:15.010 --> 00:13:18.030
 These are not in any change event 

00:13:18.030 --> 00:13:21.090
 Fortunately 

00:13:21.090 --> 00:13:24.635
 Basically, all the events you care about have changed notices. 

00:13:24.635 --> 00:13:26.760
 These are the things that users will click, right? 

00:13:26.760 --> 00:13:29.000
 They type in the edit field 

00:13:29.000 --> 00:13:29.770
 So this is very good 

00:13:29.770 --> 00:13:31.561
 We have already notified these events 

00:13:31.561 --> 00:13:33.750
 This time for almost all the attributes you care about 

00:13:33.750 --> 00:13:35.158
 Both are effective 

00:13:35.580 --> 00:13:37.640
 But if you have your own fusion 

00:13:37.640 --> 00:13:40.670
 You need to do this to set up an external event 

00:13:40.670 --> 00:13:42.080
 For monitoring 

00:13:44.030 --> 00:13:44.820
 Ok 

00:13:44.820 --> 00:13:47.620
 Let's talk about link expressions 

00:13:47.620 --> 00:13:51.920
 Here, I have a layout with three views 

00:13:51.920 --> 00:13:55.434
 They all have the same expression 

00:13:55.434 --> 00:13:57.922
 These codes are ugly 

00:13:57.922 --> 00:14:01.340
 For example, all UI code is a bit ugly. 

00:14:01.340 --> 00:14:03.630
 I really don't want to do this. 

00:14:03.630 --> 00:14:06.290
 I want to write the code once and then it can be reused elsewhere. 

00:14:06.290 --> 00:14:11.530
 I can create an ID 

00:14:11.530 --> 00:14:15.060
 So I can use it in other expressions 

00:14:15.060 --> 00:14:17.850
 Now I can bind to another field 

00:14:17.850 --> 00:14:18.679
 really not bad 

00:14:18.679 --> 00:14:21.094
 After the back, what it does is of course, just that I am talking 

00:14:21.094 --> 00:14:22.716
 Oh, I realize this. 

00:14:22.716 --> 00:14:24.090
 We have a lot of expressions there 

00:14:24.090 --> 00:14:25.340
 I will replace it 

00:14:28.872 --> 00:14:30.330
 We also have implied event updates 

00:14:30.330 --> 00:14:33.290
 For example, you combine a check field in another view. 

00:14:33.290 --> 00:14:36.690
 Because the check is a two-way data binding field 

00:14:36.690 --> 00:14:39.570
 So we can say oh, look, the field there is 

00:14:39.570 --> 00:14:42.220
 -- the user clicked on it 

00:14:42.220 --> 00:14:43.840
 We will receive updates soon 

00:14:43.840 --> 00:14:45.270
 We know what happened 

00:14:45.270 --> 00:14:47.982
 Let's talk about lambda expressions 

00:14:47.982 --> 00:14:49.700
 So two-way data binding 

00:14:49.700 --> 00:14:51.250
 Is from the layout 

00:14:51.250 --> 00:14:54.860
 A way to use data in your data model 

00:14:54.860 --> 00:14:56.400
 Another method is callback 

00:14:56.400 --> 00:14:58.700
 Callback is to get a view 

00:14:58.700 --> 00:15:00.630
 You set a click list 

00:15:00.630 --> 00:15:02.780
 We want to do this better. 

00:15:02.780 --> 00:15:06.180
 Two days before we introduced this feature 

00:15:06.180 --> 00:15:08.590
 For data binding 

00:15:08.790 --> 00:15:11.460
 You will give the event an ID 

00:15:11.460 --> 00:15:13.240
 In your Java code 

00:15:13.240 --> 00:15:15.690
 You will get an ID from the binding 

00:15:15.690 --> 00:15:17.840
 We have created a view for you 

00:15:17.840 --> 00:15:20.280
 Then you will set up a ClickListener 

00:15:20.280 --> 00:15:22.460
 We want to make everything intuitive 

00:15:24.590 --> 00:15:25.860
 We got rid of it 

00:15:25.860 --> 00:15:29.840
 We applied the method reference so you can say 

00:15:29.840 --> 00:15:33.281
 Hey, we know that OnClick is an event. 

00:15:34.060 --> 00:15:35.760
 So where does this Presenter come from? 

00:15:35.760 --> 00:15:37.718
 [inaudible] and other variables you quoted 

00:15:37.718 --> 00:15:39.050
 So there is still no magic here. 

00:15:39.050 --> 00:15:41.580
 This is not like your activity in the architecture. 

00:15:41.580 --> 00:15:44.146
 OnClick event used 

00:15:45.140 --> 00:15:46.780
 In the Presenter, what you have to do is 

00:15:46.780 --> 00:15:49.289
 Call this method 

00:15:49.289 --> 00:15:51.080
 We will receive the view because onClick 

00:15:51.080 --> 00:15:53.890
 As long as it receives the view, you can get the binding 

00:15:53.890 --> 00:15:55.560
 This is a cool way 

00:15:55.560 --> 00:15:58.580
 Just like data binding, it has a findBinding method 

00:15:58.580 --> 00:16:00.040
 In any view 

00:16:00.040 --> 00:16:01.933
 You can get the event there 

00:16:01.933 --> 00:16:04.700
 Then do whatever you want 

00:16:04.700 --> 00:16:07.230
 But this is still a lot of unnecessary code 

00:16:07.230 --> 00:16:09.840
 So we want to simplify it 

00:16:09.840 --> 00:16:13.520
 We introduced lambda expressions 

00:16:13.520 --> 00:16:15.050
 Come get rid of it 

00:16:15.050 --> 00:16:18.870
 You can set this when onClick happens 

00:16:18.870 --> 00:16:21.390
 Call the presenter.save of the project 

00:16:21.390 --> 00:16:23.240
 Where does the project come from? 

00:16:23.240 --> 00:16:25.650
 This is the project you announced there. 

00:16:25.650 --> 00:16:28.070
 So use the same method in the presenter 

00:16:28.070 --> 00:16:31.120
 You can do whatever you want because you have that project 

00:16:31.120 --> 00:16:32.600
 This is very cool -- in fact 

00:16:32.600 --> 00:16:36.160
 Why do we want to promote it -- so we added this to the time bar 

00:16:36.160 --> 00:16:37.960
 We promoted this feature earlier 

00:16:37.960 --> 00:16:39.770
 Because the test team 

00:16:39.770 --> 00:16:43.000
 These framework demos were released via Google 

00:16:43.453 --> 00:16:46.600
 They want similar features 

00:16:46.600 --> 00:16:51.100
 When you do this, presenter doesn't have any Android code. 

00:16:51.100 --> 00:16:54.030
 So your layout file handles all events for Android 

00:16:54.030 --> 00:16:56.485
 You can test your presenter the way you want. 

00:16:56.485 --> 00:16:58.410
 This is a beautiful separation 

00:16:58.410 --> 00:17:00.730
 It is very useful and very refreshing 

00:17:00.730 --> 00:17:04.369
 Another cool thing is in today's Android Studio. 

00:17:04.369 --> 00:17:09.920
 You can slide to the same function and click on it 

00:17:09.920 --> 00:17:11.770
 Then open the Presenter 

00:17:11.770 --> 00:17:15.619
 This makes it easier for us to find code during development. 

00:17:15.619 --> 00:17:18.300
 So to see [? list?] get more details 

00:17:18.300 --> 00:17:20.569
 This is a lambda expression 

00:17:20.569 --> 00:17:21.980
 You can also write it 

00:17:21.980 --> 00:17:24.180
 onClick can receive a view 

00:17:24.180 --> 00:17:26.355
 If you look at the course description of the onClick callback function 

00:17:26.355 --> 00:17:29.216
 It looks like this 

00:17:29.216 --> 00:17:30.840
 You can reference this view in a lambda expression 

00:17:30.840 --> 00:17:33.440
 If you want to use it 

00:17:36.030 --> 00:17:38.790
 Then the view inside the expression will reference 

00:17:38.790 --> 00:17:41.005
 That you declared in the parameters section 

00:17:41.005 --> 00:17:44.502
 So, just like Java, eight lambda functions 

00:17:45.630 --> 00:17:47.470
 At least you have -- actually you can 

00:17:47.470 --> 00:17:48.760
 Feel free to name 

00:17:48.760 --> 00:17:53.021
 So I call it v. The name doesn't need anything more to match 

00:17:53.210 --> 00:17:56.217
 Let's look at another example, FocusChange 

00:17:56.217 --> 00:17:58.050
 So you want to know when FocusChange happens 

00:17:58.050 --> 00:18:03.560
 You want to call your presenter based on the latest focus 

00:18:03.560 --> 00:18:05.030
 Unfortunately, you can't do this 

00:18:05.030 --> 00:18:07.290
 Because if you look at FocusChange 

00:18:07.290 --> 00:18:10.540
 Or FocusChange syntax, this method accepts the view 

00:18:10.540 --> 00:18:12.240
 And the state of focus 

00:18:12.240 --> 00:18:16.010
 So even if you don't want to use view syntax, 

00:18:16.010 --> 00:18:18.020
 You still need to define the v parameter 

00:18:18.020 --> 00:18:22.820
 So the rule is either you declare all the parameters that the method will receive. 

00:18:22.820 --> 00:18:25.640
 Or nothing defined 

00:18:25.640 --> 00:18:28.510
 We found nothing defined [inaudible] 

00:18:28.510 --> 00:18:29.520
 Is very common 

00:18:29.520 --> 00:18:32.400
 For example, in ClickListener you almost never want to [inaudible] 

00:18:32.400 --> 00:18:33.520
 [inaudible] 

00:18:33.520 --> 00:18:38.320
 So we want to provide you with no-parameter shortcuts. 

00:18:38.320 --> 00:18:40.380
 Another example is onLongClick 

00:18:40.380 --> 00:18:42.140
 The difference between onLongClick is 

00:18:42.140 --> 00:18:46.050
 It expects the result to be a Boolean value 

00:18:46.050 --> 00:18:49.030
 So we know if we want to fill it 

00:18:49.030 --> 00:18:52.640
 To make this workable 

00:18:52.640 --> 00:18:56.030
 Presenter has a lot of methods -- you also need to return a Boolean value 

00:18:56.030 --> 00:18:59.720
 So we won't -- if you enter some lambda expressions there 

00:18:59.720 --> 00:19:03.050
 It won't give back the value that the callback function wants 

00:19:03.050 --> 00:19:04.360
 It won't compile. 

00:19:04.360 --> 00:19:07.580
 We don't want, you know, oh, this, by default, will give back the wrong value. 

00:19:07.580 --> 00:19:09.060
 If something breaks in the future? ? ? 

00:19:09.060 --> 00:19:09.768
 You won't know 

00:19:09.768 --> 00:19:12.860
 If you can't match, we won't try anything. 

00:19:12.860 --> 00:19:14.770
 We failed 

00:19:14.770 --> 00:19:17.070
 There are two ways to achieve the same effect 

00:19:17.070 --> 00:19:19.920
 That is, lambda expressions and method references 

00:19:19.920 --> 00:19:21.430
 They are very useful 

00:19:21.430 --> 00:19:24.790
 I want to talk about how they differ. 

00:19:24.790 --> 00:19:27.100
 Because they have different effects 

00:19:27.100 --> 00:19:29.920
 The main difference between the two methods is that 

00:19:29.920 --> 00:19:32.450
 Lambda expressions will be evaluated 

00:19:32.450 --> 00:19:33.490
 When the event occurs 

00:19:33.490 --> 00:19:36.540
 So no matter what expression you enter here 

00:19:36.540 --> 00:19:39.080
 We will evaluate it when the user clicks on the button, 

00:19:39.080 --> 00:19:40.970
 Or when the text changes, or other 

00:19:40.970 --> 00:19:42.770
 Method reference 

00:19:42.770 --> 00:19:44.790
 Is evaluated when the UI is refreshed 

00:19:44.790 --> 00:19:47.605
 When it is evaluated when we refresh the UI 

00:19:47.605 --> 00:19:49.710
 We evaluate expressions 

00:19:49.710 --> 00:19:51.740
 We find the method that needs to be called 

00:19:51.740 --> 00:19:54.760
 And set the ClickListener that can directly refer to [inaudible] 

00:19:54.760 --> 00:19:56.415
 Let's look at an example 

00:19:56.415 --> 00:19:58.010
 Make everything clearer 

00:19:58.010 --> 00:20:00.690
 In the previous example we have a presenter 

00:20:00.690 --> 00:20:03.700
 I set it to null 

00:20:03.700 --> 00:20:05.220
 And the presenter-- 

00:20:05.220 --> 00:20:08.750
 Link the same method to the same button 

00:20:08.750 --> 00:20:11.350
 If we take a look at saveButton.getClickListener 

00:20:11.350 --> 00:20:13.940
 In this example, when the presenter is null 

00:20:13.940 --> 00:20:16.640
 Is the same button a ClickListener? 

00:20:16.640 --> 00:20:19.990
 If you use a lambda expression, it won't 

00:20:19.990 --> 00:20:22.100
 It actually still has the same button 

00:20:22.100 --> 00:20:23.680
 But not null 

00:20:23.680 --> 00:20:25.150
 Even if you don't have a presenter 

00:20:25.150 --> 00:20:27.960
 There is a callback in this view 

00:20:27.960 --> 00:20:30.460
 But if you use the method reference, it will be null 

00:20:30.460 --> 00:20:32.070
 We don't need to set it 

00:20:32.070 --> 00:20:34.580
 Sometimes setting a clickable view has side effects 

00:20:34.580 --> 00:20:35.840
 This is very important to you. 

00:20:35.840 --> 00:20:38.241
 You need to use the method reference 

00:20:40.000 --> 00:20:41.690
 But we will deal with [inaudible] 

00:20:41.690 --> 00:20:43.910
 So even if there is a callback you wonâ€™t crash 

00:20:43.910 --> 00:20:45.210
 When the callback [inaudible] 

00:20:45.210 --> 00:20:46.983
 We will find no presenter 

00:20:46.983 --> 00:20:48.764
 It will deprecate it 

00:20:49.604 --> 00:20:52.970
 So its way of doing it is when you zoom in on the layout -- 

00:20:52.970 --> 00:20:55.640
 If you don't use a lambda expression we will zoom in on the layout 

00:20:55.640 --> 00:20:56.970
 We set the ClickListener 

00:20:56.970 --> 00:20:58.822
 It belongs to us 

00:20:58.822 --> 00:21:01.280
 When the user clicks we evaluate the presenter 

00:21:01.280 --> 00:21:04.303
 We evaluate the parameters and then run it 

00:21:05.510 --> 00:21:07.860
 If you use method reference 

00:21:07.860 --> 00:21:10.010
 When we will perform the binding this is what we generated 

00:21:10.010 --> 00:21:11.935
 And how to update the UI 

00:21:11.935 --> 00:21:15.320
 When we run that method we will find the presenter 

00:21:15.320 --> 00:21:17.420
 If there is a presenter 

00:21:17.420 --> 00:21:21.840
 We will bind it to the listener, which is the related method. 

00:21:21.840 --> 00:21:24.421
 If there is no presenter, we will set the callback to null. 

00:21:25.472 --> 00:21:26.930
 The listener syntax we generated 

00:21:26.930 --> 00:21:28.960
 It looks so simple 

00:21:28.960 --> 00:21:30.550
 It accepts presenter 

00:21:30.550 --> 00:21:32.360
 So we compare it to the reference 

00:21:32.360 --> 00:21:33.642
 Then we can call it back 

00:21:33.642 --> 00:21:36.450
 The presenter comes from our evaluation presenter 

00:21:38.570 --> 00:21:40.595
 Another difference is that you can use expressions 

00:21:40.595 --> 00:21:43.000
 This is the information we get from lambda expressions 

00:21:43.000 --> 00:21:45.730
 You can use any expression in the lambda 

00:21:45.730 --> 00:21:48.680
 And you can't do this in a method expression 

00:21:48.680 --> 00:21:52.030
 So you can type presenter.save(user.friend) 

00:21:52.030 --> 00:21:53.940
 Then we will evaluate it 

00:21:54.270 --> 00:21:56.470
 Or you can type data.presenter 

00:21:56.470 --> 00:21:59.190
 Any valid expression in data binding can be used here 

00:21:59.190 --> 00:22:00.876
 We will evaluate it 

00:22:01.700 --> 00:22:05.440
 You can't do this in a method expression. 

00:22:05.440 --> 00:22:08.820
 Method must match the event 

00:22:08.820 --> 00:22:12.500
 You can enter data.presenter in the same way. 

00:22:12.500 --> 00:22:14.940
 You can use an expression in one open 

00:22:14.940 --> 00:22:17.030
 But you can't change the call parameters 

00:22:20.270 --> 00:22:22.310
 That callback parameter -- in both methods 

00:22:22.310 --> 00:22:23.580
 We can all use it 

00:22:23.580 --> 00:22:25.080
 If you use a presenter 

00:22:25.080 --> 00:22:26.621
 You have to set the parameters yourself 

00:22:26.621 --> 00:22:28.060
 Like I want to use the view 

00:22:28.060 --> 00:22:30.500
 You need to set the parameters 

00:22:30.500 --> 00:22:31.350
 I am sorry 

00:22:31.350 --> 00:22:32.780
 Wrong button 

00:22:32.780 --> 00:22:35.680
 If you use the reference method it is already feasible 

00:22:35.680 --> 00:22:37.804
 It must match the event 

00:22:38.224 --> 00:22:40.390
 Now in a lambda expression 

00:22:40.390 --> 00:22:43.890
 You can use an extra few variables that you couldn't use before. 

00:22:43.890 --> 00:22:46.170
 One of them is view IDs 

00:22:46.170 --> 00:22:46.720
 Ok? 

00:22:46.720 --> 00:22:49.680
 You can refer to your view in the expression. 

00:22:49.680 --> 00:22:52.210
 This is your view ID, it has been referenced 

00:22:52.210 --> 00:22:54.380
 It is called the camel-casified version. 

00:22:54.380 --> 00:22:59.680
 This is the same field you used in the binding 

00:22:59.680 --> 00:23:02.640
 So we bind it as before. 

00:23:03.736 --> 00:23:05.110
 You can also use the context 

00:23:05.110 --> 00:23:08.020
 I know that many of you want it. 

00:23:08.020 --> 00:23:11.270
 You can see the context without seeing a specific view 

00:23:11.270 --> 00:23:13.340
 So we only give you the context of the root 

00:23:13.340 --> 00:23:16.580
 You can think of it as a generated, synthetic variable 

00:23:16.580 --> 00:23:19.292
 And can be used directly in your layout 

00:23:19.292 --> 00:23:22.130
 But if you create a context 

00:23:22.130 --> 00:23:23.535
 We won't do this 

00:23:23.535 --> 00:23:24.977
 Yes, don't do that 

00:23:24.977 --> 00:23:26.560
 Please don't do that 

00:23:27.780 --> 00:23:29.779
 It will cover our context 

00:23:29.779 --> 00:23:32.120
 If you do that then 

00:23:32.120 --> 00:23:33.940
 Ok, let's talk about animation. 

00:23:33.940 --> 00:23:35.018
 Animation 

00:23:35.018 --> 00:23:37.226
 Everyone wants to use animation in their user interface 

00:23:37.226 --> 00:23:38.098
 How many people, please raise your hand 

00:23:38.098 --> 00:23:38.534
 Yay! 

00:23:38.534 --> 00:23:39.960
 This is right, this is right [inaudible] 

00:23:39.960 --> 00:23:40.430
 action 

00:23:40.430 --> 00:23:42.440
 Let your user interface move 

00:23:42.440 --> 00:23:45.700
 For data binding, you will find 

00:23:45.700 --> 00:23:48.720
 It does not require special operations 

00:23:48.720 --> 00:23:50.920
 You will get this strange result 

00:23:50.920 --> 00:23:54.440
 When you click on some button it will snap to its position 

00:23:54.440 --> 00:23:58.370
 This is really unfortunate. 

00:23:58.370 --> 00:24:02.450
 But we can use some simple operations to get better animations. 

00:24:02.450 --> 00:24:03.820
 That is overuse 

00:24:03.820 --> 00:24:05.640
 How many of you have used excessively before 

00:24:05.640 --> 00:24:07.960
 Transition function was introduced in KitKat 

00:24:07.960 --> 00:24:09.320
 Very useful 

00:24:09.320 --> 00:24:11.970
 You can use it to get automatic animation 

00:24:11.970 --> 00:24:16.846
 You can add onRebindCallback 

00:24:20.840 --> 00:24:24.341
 One of the functions is onPreBind 

00:24:24.341 --> 00:24:26.090
 This is what we really care about. 

00:24:26.090 --> 00:24:29.730
 This will be evaluated before binding 

00:24:29.730 --> 00:24:31.640
 Before the binding is evaluated 

00:24:31.640 --> 00:24:32.820
 We don't know what will happen 

00:24:32.820 --> 00:24:33.760
 We only know 

00:24:33.760 --> 00:24:36.970
 Something happens when it is called 

00:24:36.970 --> 00:24:38.692
 What we have to do is we bring the sceneRoo 

00:24:38.692 --> 00:24:40.900
 Call beginDelayedTransition 

00:24:40.900 --> 00:24:44.720
 Then you can get a very good effect 

00:24:44.720 --> 00:24:45.400
 very good 

00:24:45.400 --> 00:24:46.350
 Very convenient 

00:24:46.350 --> 00:24:47.270
 very simple 

00:24:47.270 --> 00:24:49.726
 Maybe we should make it an API 

00:24:49.726 --> 00:24:50.970
 Enable animation 

00:24:50.970 --> 00:24:52.345
 this is a good idea 

00:24:52.345 --> 00:24:53.970
 Yes, we should do this 

00:24:53.970 --> 00:24:56.020
 But this is not effective under any circumstances 

00:24:56.020 --> 00:24:57.940
 Let me see this ad here. 

00:24:58.370 --> 00:25:01.020
 When we change the fields here 

00:25:01.020 --> 00:25:04.560
 Change the userâ€™s age ad will still jump in and out 

00:25:04.560 --> 00:25:06.730
 Ok, our transition system 

00:25:06.730 --> 00:25:08.440
 Can't handle all the transitions you want 

00:25:08.440 --> 00:25:11.550
 It can handle most common situations -- shallow and shallow 

00:25:11.550 --> 00:25:14.940
 Or change the position of the view, and so on. 

00:25:14.940 --> 00:25:16.606
 You can also use your own transition 

00:25:16.606 --> 00:25:18.480
 Sometimes you want personalized settings 

00:25:18.480 --> 00:25:21.110
 You just want to make an animation for it. 

00:25:21.110 --> 00:25:22.700
 What should you do? 

00:25:22.700 --> 00:25:25.620
 In this case, we can use the settings 

00:25:25.620 --> 00:25:28.140
 When the value is set in the field 

00:25:28.140 --> 00:25:32.850
 We can get the state in the relevant field and turn it into an animation. 

00:25:32.850 --> 00:25:35.500
 So we created the BindingAdapter 

00:25:35.500 --> 00:25:38.570
 We can get old and new values 

00:25:38.570 --> 00:25:40.861
 You can not use the old value if you don't want it. 

00:25:40.861 --> 00:25:42.520
 In this example, we want to use the old value. 

00:25:42.520 --> 00:25:45.320
 Of course, if nothing has changed, we must use the old value. 

00:25:45.320 --> 00:25:47.240
 Of course, don't do anything 

00:25:47.240 --> 00:25:49.590
 We don't want to do anything if nothing has changed 

00:25:49.590 --> 00:25:52.279
 Then, we can make the animation in that place, that place 

00:25:52.279 --> 00:25:54.070
 You can do any animation you want 

00:25:54.070 --> 00:25:56.430
 I don't know, what do you want to do with the text field? 

00:25:56.430 --> 00:25:57.725
 But you can do anything here 

00:25:57.725 --> 00:25:58.433
 Such as cross-fade 

00:25:58.433 --> 00:25:59.230
 I do not know 

00:25:59.230 --> 00:26:00.453
 Dependency injection 

00:26:00.453 --> 00:26:01.005
 Ok 

00:26:01.005 --> 00:26:01.880
 Everyone raises their hands 

00:26:01.880 --> 00:26:04.530
 How many people like dependency injection? 

00:26:04.530 --> 00:26:05.030
 Ok 

00:26:05.030 --> 00:26:05.290
 Good 

00:26:05.290 --> 00:26:05.580
 it is good 

00:26:05.580 --> 00:26:06.320
 This is what you want 

00:26:06.320 --> 00:26:07.432
 This is for you. 

00:26:07.432 --> 00:26:09.640
 When you write the test, of course, what do you do? 

00:26:09.640 --> 00:26:15.250
 When you are binding the adapter you have a if statement 

00:26:15.250 --> 00:26:18.850
 If it is a test setup or you are not testing the setup 

00:26:18.850 --> 00:26:20.720
 You can do this or another 

00:26:20.720 --> 00:26:23.519
 But we are fans of dependency injection 

00:26:23.519 --> 00:26:24.560
 We don't want to 

00:26:24.560 --> 00:26:25.910
 This is very bad 

00:26:25.910 --> 00:26:30.000
 So what we have to do is create an adapter 

00:26:30.000 --> 00:26:33.055
 This is no longer static. 

00:26:33.375 --> 00:26:35.150
 So we have an abstract binding adapter 

00:26:35.150 --> 00:26:36.583
 Of course, this could be an interface 

00:26:36.583 --> 00:26:38.940
 It does not need to be an abstract base class 

00:26:39.130 --> 00:26:43.410
 We use your test version or product version 

00:26:43.410 --> 00:26:46.297
 Implant this interface 

00:26:47.780 --> 00:26:50.720
 But we don't know which interface to call. 

00:26:50.720 --> 00:26:51.600
 We are doing data binding 

00:26:51.600 --> 00:26:53.600
 We don't know if you want 

00:26:53.600 --> 00:26:55.090
 Called in your beta or product version 

00:26:55.090 --> 00:26:57.677
 So we need to know what you will do 

00:26:58.030 --> 00:27:00.190
 So we created this data binding component 

00:27:00.190 --> 00:27:02.200
 Whenever we see an instance method like this 

00:27:02.200 --> 00:27:05.015
 I know you will give us an instance. 

00:27:06.580 --> 00:27:09.710
 So you implant this component 

00:27:09.710 --> 00:27:11.980
 This is a generated data binding component 

00:27:11.980 --> 00:27:14.440
 Generated a getter in it 

00:27:14.900 --> 00:27:16.800
 And you implanted it 

00:27:16.800 --> 00:27:21.299
 You will do everything possible to get your components 

00:27:22.080 --> 00:27:23.580
 However, you still need to set it up 

00:27:23.580 --> 00:27:24.950
 This is the default setting 

00:27:24.950 --> 00:27:27.890
 You can also use it in every inflated call. 

00:27:27.890 --> 00:27:31.570
 But maybe you just want to use one of them 

00:27:31.570 --> 00:27:35.946
 You can use it every time you inflate a view, or bind a view 

00:27:37.000 --> 00:27:39.900
 When you are statically binding an adapter 

00:27:39.900 --> 00:27:40.830
 You can also use it 

00:27:40.830 --> 00:27:42.900
 You don't have to do it 

00:27:42.900 --> 00:27:44.074
 Do this when the instance binds the adapter 

00:27:44.074 --> 00:27:46.240
 Now, I want to give you a useful example of it. 

00:27:46.240 --> 00:27:49.200
 We have this system for loading a picture 

00:27:49.200 --> 00:27:51.860
 We want to use the image loader to load the image 

00:27:51.860 --> 00:27:53.790
 We already have a cache 

00:27:53.790 --> 00:27:55.270
 We certainly get the ImageLoader instance 

00:27:56.390 --> 00:27:58.950
 Of course, got the component 

00:27:58.950 --> 00:28:00.769
 So where does the component come from? 

00:28:00.769 --> 00:28:02.560
 We can take the context 

00:28:02.560 --> 00:28:04.090
 Then we can try to find it in the context 

00:28:04.090 --> 00:28:05.900
 By casting it, and [inaudible] 

00:28:05.900 --> 00:28:06.650
 This is a bit of pain 

00:28:06.650 --> 00:28:09.560
 So what we can do is 

00:28:09.560 --> 00:28:10.902
 Introducing data binding components 

00:28:10.902 --> 00:28:12.590
 Of course, this is in our application 

00:28:12.590 --> 00:28:14.970
 Some examples 

00:28:14.970 --> 00:28:19.650
 We can introduce it in the BindingAdapter 

00:28:19.650 --> 00:28:22.031
 Then we can use it 

00:28:22.690 --> 00:28:26.130
 If you use Dagger 2 you need to create a module 

00:28:26.130 --> 00:28:28.126
 And provide a method 

00:28:28.126 --> 00:28:30.500
 Then you can create a component 

00:28:30.500 --> 00:28:32.190
 Then set your default component like this 

00:28:34.450 --> 00:28:35.820
 Ok 

00:28:35.820 --> 00:28:38.290
 Also, if you use data binding 

00:28:38.290 --> 00:28:40.974
 But never set up binding adapters and use them 

00:28:40.974 --> 00:28:41.640
 This is really great 

00:28:41.640 --> 00:28:43.145
 You can set your own properties 

00:28:43.145 --> 00:28:46.020
 I saw a lot - like, we have to create them 

00:28:46.020 --> 00:28:48.000
 So we can use data binding 

00:28:48.000 --> 00:28:50.850
 But in fact, the data binding function is the most widely abused. 

00:28:50.850 --> 00:28:53.726
 This is a good thing, the characteristics of data binding 

00:28:53.940 --> 00:28:56.160
 The main problem we got was 

00:28:56.160 --> 00:28:57.940
 How do we get started with data binding? 

00:28:57.940 --> 00:29:00.177
 Because you already have an app 

00:29:00.177 --> 00:29:02.260
 When you start from scratch, yes, itâ€™s easy 

00:29:02.260 --> 00:29:03.890
 If you already have an app 

00:29:03.890 --> 00:29:06.599
 It's illogical to rewrite your layout 

00:29:06.599 --> 00:29:07.640
 This is unnecessary work 

00:29:07.640 --> 00:29:09.320
 Keep it if possible 

00:29:09.320 --> 00:29:13.040
 But in the new layout, you can start using data binding. 

00:29:13.040 --> 00:29:15.859
 We want to talk about these levels in detail. 

00:29:16.190 --> 00:29:19.610
 So to start using data binding you just need to enable it in Gradle 

00:29:19.610 --> 00:29:20.330
 very simple 

00:29:20.330 --> 00:29:21.914
 Three lines of code 

00:29:22.480 --> 00:29:26.850
 One thing you can do today is in any layout. 

00:29:26.850 --> 00:29:29.360
 You can build [inaudible] 

00:29:29.360 --> 00:29:31.540
 There are 25, or 30 databases 

00:29:31.540 --> 00:29:33.325
 I have to find a way to get [inaudible] 

00:29:33.325 --> 00:29:34.960
 There are now 31 

00:29:34.960 --> 00:29:35.720
 Yes 

00:29:35.720 --> 00:29:37.400
 31 is the last one 

00:29:37.400 --> 00:29:40.060
 After we release the data binding 

00:29:40.060 --> 00:29:41.414
 I didn't see people who created it. 

00:29:41.414 --> 00:29:43.840
 This is the function we should release seven years ago. 

00:29:43.840 --> 00:29:45.690
 Even eight years ago 

00:29:45.690 --> 00:29:47.690
 When we released Android 

00:29:47.690 --> 00:29:52.450
 So you add layout tags to your layout. 

00:29:52.450 --> 00:29:53.400
 This is fine 

00:29:53.400 --> 00:29:54.740
 You don't need to do anything else 

00:29:54.740 --> 00:29:57.190
 Now, with your code you have these findViewById 

00:29:57.190 --> 00:29:59.980
 Or have these comments you added to the view 

00:29:59.980 --> 00:30:01.460
 You can get rid of all this now 

00:30:01.460 --> 00:30:04.370
 You can get this binding category in this layout. 

00:30:04.370 --> 00:30:09.330
 It already has all the views that view has an ID to use as the field 

00:30:09.330 --> 00:30:11.530
 This is what the public knows, the last field 

00:30:11.530 --> 00:30:12.850
 They are security type fields 

00:30:12.850 --> 00:30:14.470
 You don't need casting 

00:30:14.470 --> 00:30:17.330
 If you make a mistake -- there is a very common mistake that will happen -- 

00:30:17.330 --> 00:30:19.670
 Are you using the same ID 

00:30:19.670 --> 00:30:21.050
 In different places, in different layouts 

00:30:21.050 --> 00:30:23.260
 If someone changes the ID in one place 

00:30:23.260 --> 00:30:24.650
 Your code won't crash, 

00:30:24.650 --> 00:30:26.847
 Because the same ID is still used in another place 

00:30:26.847 --> 00:30:29.180
 But it will crash at runtime 

00:30:29.180 --> 00:30:30.160
 Because you can't find the view. 

00:30:30.160 --> 00:30:31.940
 This does not happen through data binding 

00:30:31.940 --> 00:30:33.780
 Because we create bindings for each layout 

00:30:33.780 --> 00:30:36.057
 If someone accidentally changed the ID 

00:30:36.057 --> 00:30:37.420
 It won't compile 

00:30:40.570 --> 00:30:42.560
 The second part is the binding user interface. 

00:30:42.560 --> 00:30:45.270
 This is a very simple way you can start using data binding 

00:30:45.270 --> 00:30:47.270
 In fact, you should do this 

00:30:47.270 --> 00:30:50.660
 In my opinion, this is very clumsy. Of course, I am biased. 

00:30:50.660 --> 00:30:52.560
 You have this in every user interface -- 

00:30:52.560 --> 00:30:54.750
 Like your presenter 

00:30:54.750 --> 00:30:58.110
 When you enter data you view your data 

00:30:58.110 --> 00:31:00.980
 View your views and make settings for each of them 

00:31:00.980 --> 00:31:02.490
 You need to handle null values 

00:31:02.490 --> 00:31:03.940
 No, you need to capture them 

00:31:03.940 --> 00:31:04.440
 nonsense 

00:31:04.440 --> 00:31:06.440
 This is what you need to write 

00:31:06.440 --> 00:31:08.230
 Unnecessary code 

00:31:08.230 --> 00:31:09.650
 You don't need to write it 

00:31:09.650 --> 00:31:13.110
 So just delete these IDs 

00:31:13.110 --> 00:31:15.780
 Set your variables in the layout 

00:31:15.780 --> 00:31:20.740
 This is a layout showing detailed information 

00:31:20.740 --> 00:31:22.520
 Just use intuition 

00:31:22.520 --> 00:31:24.770
 Set the amount of input in the layout 

00:31:24.770 --> 00:31:27.270
 You can say that the user is displayed in this layout. 

00:31:27.270 --> 00:31:30.610
 You set it up and use it inside 

00:31:30.610 --> 00:31:32.640
 So when someone inflates your layout 

00:31:32.640 --> 00:31:35.140
 And want [inaudible] they have used the binding syntax 

00:31:35.140 --> 00:31:36.431
 They can see all the processors 

00:31:36.431 --> 00:31:39.298
 They know what the input of the layout is. 

00:31:40.570 --> 00:31:43.900
 [inaudible] update the user interface method to get rid of everything 

00:31:43.900 --> 00:31:46.190
 What you need to do is just set it in the binding 

00:31:46.190 --> 00:31:47.510
 Then apply it 

00:31:47.510 --> 00:31:50.314
 All of this will not affect performance 

00:31:50.960 --> 00:31:52.890
 The third point is the callback 

00:31:52.890 --> 00:31:56.600
 Sometimes, you use to bind and get the settings 

00:31:56.600 --> 00:31:58.540
 Then set the ClickListener 

00:31:58.540 --> 00:32:00.800
 This is also unnecessary 

00:32:00.800 --> 00:32:02.930
 Just set presenters 

00:32:02.930 --> 00:32:06.110
 Call this method when the button is clicked 

00:32:06.110 --> 00:32:08.806
 The best thing about this feature is 

00:32:08.806 --> 00:32:11.180
 When you are in Android Studio -- it always happens 

00:32:11.180 --> 00:32:12.330
 You enter the layout 

00:32:12.330 --> 00:32:14.670
 Ok, if the user clicks 

00:32:14.670 --> 00:32:18.545
 Your attempt to search for a view ID 

00:32:18.545 --> 00:32:20.270
 Then find where the ClickListener is 

00:32:20.270 --> 00:32:21.832
 There are several steps 

00:32:21.832 --> 00:32:23.790
 Here you can click and use this method 

00:32:23.790 --> 00:32:25.435
 Then find the implementation 

00:32:28.340 --> 00:32:31.380
 If you start using a new app 

00:32:31.380 --> 00:32:34.960
 Observability may be very, very useful 

00:32:34.960 --> 00:32:37.800
 So used to replace this simple user syntax 

00:32:37.800 --> 00:32:40.380
 You can extend BaseObservable 

00:32:40.380 --> 00:32:43.150
 If you don't want to expand, there is an interface 

00:32:43.150 --> 00:32:45.710
 Can let you do the binding 

00:32:45.710 --> 00:32:47.570
 Whenever the value is changed 

00:32:47.570 --> 00:32:49.240
 You want to find these changes 

00:32:49.240 --> 00:32:51.914
 We will update the user interface 

00:32:53.210 --> 00:32:56.662
 There is a new, highly recommended feature 

00:32:56.662 --> 00:32:58.340
 Bidirectional data binding 

00:32:58.340 --> 00:33:01.340
 Now two-way data binding when you have a complex model 

00:33:01.340 --> 00:33:03.190
 Not very easy to use 

00:33:03.190 --> 00:33:05.500
 But just like all of us have a login form -- 

00:33:05.500 --> 00:33:08.230
 All these people need to fill in 

00:33:08.230 --> 00:33:09.952
 Simple form layout 

00:33:09.952 --> 00:33:13.056
 There is a lot of logic here. 

00:33:13.056 --> 00:33:14.430
 Here you don't need to write code 

00:33:14.430 --> 00:33:17.980
 You can have two-way data binding handle it 

00:33:17.980 --> 00:33:19.480
 Return your things 

00:33:19.480 --> 00:33:23.270
 A layout like this, you only need [inaudible] 

00:33:23.270 --> 00:33:25.610
 Create a team 

00:33:25.610 --> 00:33:26.490
 Set them all to observable fields 

00:33:26.490 --> 00:33:28.900
 There is only one instance of this syntax 

00:33:28.900 --> 00:33:30.850
 How expensive it is not important 

00:33:30.850 --> 00:33:33.462
 Set everything as an observable field 

00:33:34.070 --> 00:33:37.410
 When we do this, our layout looks like this 

00:33:37.410 --> 00:33:39.430
 We have real data 

00:33:39.430 --> 00:33:42.270
 To enable or deprecate this button or any logic 

00:33:42.270 --> 00:33:44.356
 You have this form model 

00:33:44.356 --> 00:33:49.140
 You can use them for every input field 

00:33:49.140 --> 00:33:50.920
 You can say this is a name 

00:33:50.920 --> 00:33:53.390
 Note that this is a two-way data binding 

00:33:53.390 --> 00:33:54.460
 Or you have a button 

00:33:54.460 --> 00:34:00.151
 You will say that if my real data model enables it, then let it be started 

00:34:00.480 --> 00:34:00.980
 You can do this 

00:34:00.980 --> 00:34:03.217
 You can't do this in every layout 

00:34:03.217 --> 00:34:04.300
 So you need to be careful 

00:34:04.300 --> 00:34:08.929
 But there is one thing you can compress - it's all about the form 

00:34:08.929 --> 00:34:11.031
 Or [inaudible] you want to get data --- 

00:34:11.031 --> 00:34:13.159
 This is more convenient and simple 

00:34:13.159 --> 00:34:15.154
 I can save time 

00:34:15.940 --> 00:34:17.420
 So just do it 

00:34:17.420 --> 00:34:19.575
 Now you have a binding layout 

00:34:19.575 --> 00:34:21.710
 Let you get a data object 

00:34:21.710 --> 00:34:24.900
 Then you do whatever you want with that data. 

00:34:25.840 --> 00:34:28.739
 Let me introduce some best practices to you. 

00:34:28.739 --> 00:34:31.520
 Because data binding is very powerful 

00:34:31.520 --> 00:34:34.699
 But just because you can use data binding to do these things. 

00:34:34.699 --> 00:34:37.787
 Doesn't mean you should use data binding to solve all problems 

00:34:38.110 --> 00:34:41.810
 When you are using data binding 

00:34:41.810 --> 00:34:44.960
 Should pay attention to the expression you enter 

00:34:44.960 --> 00:34:47.070
 If you type in an expression like this 

00:34:47.070 --> 00:34:49.687
 Then the user clicks on this button and pays, 

00:34:50.000 --> 00:34:51.760
 You should not do this 

00:34:51.760 --> 00:34:53.660
 Because this is wrong 

00:34:53.660 --> 00:34:56.580
 Because the payment is completely related to your application. 

00:34:56.580 --> 00:34:58.260
 Itâ€™s like your business logic 

00:34:58.260 --> 00:35:00.520
 Has nothing to do with your user interface 

00:35:00.520 --> 00:35:03.110
 You just care about 

00:35:03.110 --> 00:35:04.840
 The user clicked on that button 

00:35:04.840 --> 00:35:07.532
 The responsibility for data binding is over here. 

00:35:08.330 --> 00:35:09.580
 So please get rid of it 

00:35:09.580 --> 00:35:10.580
 Don't do that 

00:35:10.580 --> 00:35:13.780
 You should enter presenter::onSendClick 

00:35:13.780 --> 00:35:16.872
 So the presenter syntax can be self-tested 

00:35:16.872 --> 00:35:20.169
 You can have a reliable application 

00:35:21.030 --> 00:35:23.280
 The boundaries of use are not very clear 

00:35:23.280 --> 00:35:26.890
 Where should I use data binding? 

00:35:26.890 --> 00:35:28.550
 What should I use Java code? 

00:35:28.550 --> 00:35:30.260
 Please use your intuition 

00:35:30.260 --> 00:35:32.144
 Use the best method for you 

00:35:32.144 --> 00:35:33.490
 So you are saying 

00:35:33.490 --> 00:35:35.660
 To change the name of our function, right? 

00:35:35.660 --> 00:35:36.550
 Yes, that is the goal 

00:35:36.550 --> 00:35:37.070
 Yes, yes, good 

00:35:37.070 --> 00:35:38.903
 Do not call the [inaudible] function 

00:35:38.903 --> 00:35:39.720
 Use [inaudible] 

00:35:39.720 --> 00:35:40.981
 This can solve it 

00:35:41.636 --> 00:35:43.730
 Regardless, data binding can be used with the program 

00:35:43.730 --> 00:35:47.240
 Because we did everything at the time of compiling [? Settings?] details 

00:35:47.240 --> 00:35:50.540
 Another point is if it is related to the user interface 

00:35:50.540 --> 00:35:51.950
 Just put it there 

00:35:51.950 --> 00:35:53.654
 You don't need, oh my day 

00:35:53.654 --> 00:35:55.040
 I should not put any logic in my [inaudible] 

00:35:55.040 --> 00:35:57.170
 This doesn't make any sense 

00:35:57.170 --> 00:36:00.260
 No matter what the layout looks like if it is simple 

00:36:00.260 --> 00:36:02.280
 Just stay there because the important thing is 

00:36:02.280 --> 00:36:04.150
 When you are three months later 

00:36:04.150 --> 00:36:06.470
 In Android Studio, when looking at that layout file 

00:36:06.470 --> 00:36:08.994
 Can you know what the role of this layout is? 

00:36:08.994 --> 00:36:09.910
 This is the point 

00:36:09.910 --> 00:36:12.420
 It should be illustrative 

00:36:12.420 --> 00:36:14.695
 Should be able to explain themselves 

00:36:15.460 --> 00:36:19.190
 But if you are here, put such an expression 

00:36:19.190 --> 00:36:22.310
 You can't read it and understand what it means 

00:36:22.310 --> 00:36:23.380
 This is very confusing 

00:36:23.380 --> 00:36:24.910
 Do not do this 

00:36:24.910 --> 00:36:26.960
 Simple expression should be used 

00:36:26.960 --> 00:36:28.680
 So please get rid of it 

00:36:28.680 --> 00:36:32.970
 Create a method to give a short name 

00:36:32.970 --> 00:36:34.640
 And use that method 

00:36:34.640 --> 00:36:36.657
 If the expression cannot be read 

00:36:36.657 --> 00:36:38.430
 If you find that the expression is too long 

00:36:38.430 --> 00:36:40.130
 Then you may have done something wrong 

00:36:40.130 --> 00:36:41.320
 This is a method we created 

00:36:41.320 --> 00:36:43.611
 We can also mention that 

00:36:43.611 --> 00:36:47.060
 We can also use string functions here. 

00:36:47.060 --> 00:36:49.210
 If you want to replace with a string 

00:36:49.210 --> 00:36:51.756
 You can be in your expression 

00:36:51.756 --> 00:36:53.504
 Use string formatting 

00:36:53.504 --> 00:36:55.420
 Another feature is RecyclerView 

00:36:55.420 --> 00:36:57.000
 Also, two days ago 

00:36:57.000 --> 00:37:01.610
 We just released a sample application using Data Binding and RecyclerView on GitHub 

00:37:01.610 --> 00:37:03.290
 RecyclerView application samples on GitHub 

00:37:03.290 --> 00:37:06.332
 I sent it to the Spaces link where you can find it 

00:37:07.070 --> 00:37:09.140
 What you need to pay attention to is 

00:37:09.140 --> 00:37:12.010
 If you use RecyclerView with data binding 

00:37:12.010 --> 00:37:14.756
 You should do this because it generates an [inaudible] for you. 

00:37:14.756 --> 00:37:17.140
 When you bind a view 

00:37:17.140 --> 00:37:19.090
 You should call executePendingBindings every time. 

00:37:19.090 --> 00:37:21.660
 If you don't do this, it will postpone it to the next layout. 

00:37:21.660 --> 00:37:24.510
 And RecyclerView does not work very well. 

00:37:24.510 --> 00:37:27.580
 Because the view doesn't tell us the height 

00:37:27.580 --> 00:37:28.830
 Still a few points 

00:37:28.830 --> 00:37:30.660
 Here are some small examples 

00:37:30.660 --> 00:37:33.540
 About how people use binding adapters most of the time 

00:37:33.540 --> 00:37:35.760
 I want to mention them 

00:37:35.760 --> 00:37:36.810
 you can do it 

00:37:36.810 --> 00:37:37.980
 It's like HTML 

00:37:37.980 --> 00:37:41.135
 We have a text view which is an image URL 

00:37:41.135 --> 00:37:43.730
 This could be an imageView 

00:37:43.730 --> 00:37:45.624
 But this is a text URL 

00:37:45.624 --> 00:37:47.456
 This is ok 

00:37:47.456 --> 00:37:48.790
 You have a binding adapter 

00:37:48.790 --> 00:37:49.894
 You stick it here 

00:37:49.894 --> 00:37:51.560
 Everything works well [inaudible] 

00:37:51.560 --> 00:37:54.786
 Do you know what the image shows? 

00:37:54.786 --> 00:37:56.160
 You do not need an ID 

00:37:56.160 --> 00:37:58.212
 To make it self-explanatory 

00:37:58.930 --> 00:38:00.438
 This is invisible 

00:38:01.180 --> 00:38:03.571
 Oh, there is an image URL here. 

00:38:03.571 --> 00:38:05.590
 You can have multiple parameters 

00:38:05.590 --> 00:38:08.040
 Binding adapter can receive multiple parameters 

00:38:08.040 --> 00:38:10.630
 You can say, well, this is a placeholder 

00:38:10.630 --> 00:38:11.800
 This is an image URL 

00:38:11.800 --> 00:38:14.532
 You have a binding adapter to receive two properties 

00:38:14.532 --> 00:38:17.130
 You call it with these two values 

00:38:17.130 --> 00:38:19.770
 We call it paintable, it is really paintable. 

00:38:19.770 --> 00:38:21.520
 You donâ€™t need to 

00:38:21.520 --> 00:38:23.610
 You can use your logic 

00:38:23.610 --> 00:38:28.020
 It tests very well because at the time of testing 

00:38:28.020 --> 00:38:30.590
 You just provide a virtual adapter that doesn't do anything. 

00:38:30.590 --> 00:38:32.690
 So now your test runs faster 

00:38:32.690 --> 00:38:35.460
 No need to do a work request 

00:38:35.460 --> 00:38:36.650
 Another point - font 

00:38:36.650 --> 00:38:40.300
 This has been asked for many years in the text view 

00:38:40.300 --> 00:38:43.480
 We haven't [inaudible] until the data is bound 

00:38:43.480 --> 00:38:47.570
 Now you can create your own properties 

00:38:47.570 --> 00:38:50.080
 Call app:font and you can run it. 

00:38:50.080 --> 00:38:51.840
 There is a project on GitHub 

00:38:51.840 --> 00:38:54.152
 Can do this from [inaudible] 

00:38:54.152 --> 00:38:55.120
 Very cool 

00:38:55.120 --> 00:38:57.000
 Very convenient 

00:38:57.932 --> 00:39:00.200
 You can use the paintable vector 

00:39:00.200 --> 00:39:02.650
 You can't use a paintable vector in XML right now. 

00:39:02.650 --> 00:39:03.150
 right? 

00:39:03.150 --> 00:39:03.810
 Do not 

00:39:03.810 --> 00:39:06.435
 If you use data binding you can actually use vector images 

00:39:06.435 --> 00:39:09.740
 You just create a binding adapter for that and do it. 

00:39:09.740 --> 00:39:11.779
 The other one here is 

00:39:12.070 --> 00:39:13.715
 Very common in applications [inaudible] 

00:39:13.715 --> 00:39:15.630
 Dimension picture margin 

00:39:15.630 --> 00:39:20.540
 Then you have something like the size of the dimension image 

00:39:20.540 --> 00:39:22.990
 Dimensional image size and margins 

00:39:22.990 --> 00:39:24.570
 You can align the view 

00:39:24.570 --> 00:39:26.190
 You created all of these dimensions 

00:39:26.190 --> 00:39:27.760
 You don't need much 

00:39:27.760 --> 00:39:30.110
 You only need to use data binding 

00:39:30.110 --> 00:39:32.180
 This thing is a picture plus a picture margin 

00:39:32.180 --> 00:39:33.372
 That's it 

00:39:33.372 --> 00:39:35.330
 This should already be there. 

00:39:35.330 --> 00:39:36.470
 but 

00:39:36.470 --> 00:39:36.970
 Ok 

00:39:36.970 --> 00:39:39.657
 When you start experimenting 

00:39:40.240 --> 00:39:42.750
 These are things we haven't considered yet. 

00:39:42.750 --> 00:39:43.910
 Remember the image super URL 

00:39:43.910 --> 00:39:46.410
 We think of one thing...that is it 

00:39:46.410 --> 00:39:49.714
 Someone invented this font and margins 

00:39:50.080 --> 00:39:53.090
 This is just a new thing you can do with data binding. 

00:39:53.090 --> 00:39:55.020
 Please continue to explore it 

00:39:55.020 --> 00:39:55.650
 thank you all 

00:39:55.650 --> 00:39:56.650
 Thank you 

