WEBVTT
Kind: captions
Language: en

00:00:00.772 --> 00:00:04.460
MALE SPEAKER 1: ListView has
been around since Android 1.0.

00:00:04.460 --> 00:00:07.390
And it's meant to handle
repeated structure

00:00:07.390 --> 00:00:09.310
in consistent content.

00:00:09.310 --> 00:00:11.220
And more specifically,
it was made

00:00:11.220 --> 00:00:13.840
to handle this sort of
repeated structure in some very

00:00:13.840 --> 00:00:15.170
simple settings.

00:00:15.170 --> 00:00:18.020
So as you can see here, we've
got our old settings screen

00:00:18.020 --> 00:00:19.420
from Gingerbread.

00:00:19.420 --> 00:00:22.930
And this was already kind
of after a lot of extensions

00:00:22.930 --> 00:00:25.910
to what ListView
was meant to do.

00:00:25.910 --> 00:00:28.145
And sometimes, the content
isn't so consistent,

00:00:28.145 --> 00:00:30.270
so you've got different
view types floating around,

00:00:30.270 --> 00:00:32.119
so on and so forth.

00:00:32.119 --> 00:00:35.070
And we just kind of
kept adding features.

00:00:35.070 --> 00:00:37.740
But the core problem that
ListView meant to solve

00:00:37.740 --> 00:00:39.680
is, how do you make
it fast when there's

00:00:39.680 --> 00:00:43.580
a ton of items-- hundreds,
thousands, possibly more.

00:00:43.580 --> 00:00:46.810
Creating views themselves can
be really expensive, especially

00:00:46.810 --> 00:00:49.540
on old devices back in
Android's early days,

00:00:49.540 --> 00:00:51.170
and memory is limited.

00:00:51.170 --> 00:00:54.090
So you can't just necessarily
create tens of thousands

00:00:54.090 --> 00:00:57.986
of views and deal with
that all at one time.

00:00:57.986 --> 00:00:59.110
And the answer is we cheat.

00:01:01.630 --> 00:01:06.880
So with ListView, we do a trick
with some smoke and mirrors.

00:01:06.880 --> 00:01:10.120
And really, anyone who
works on UI development

00:01:10.120 --> 00:01:12.960
has a lot in common
with stage magicians.

00:01:12.960 --> 00:01:17.810
Stage magicians use
misdirection and other sorts

00:01:17.810 --> 00:01:20.210
of tricks on stage
to make you think

00:01:20.210 --> 00:01:23.900
that you're seeing something
that you're really not.

00:01:23.900 --> 00:01:25.980
And if it looks
right, it is right.

00:01:25.980 --> 00:01:29.610
So I mean, what they're
seeing is the UI in terms

00:01:29.610 --> 00:01:32.340
of what the user believes.

00:01:32.340 --> 00:01:35.185
So the trick that we use is
that we only create and lay

00:01:35.185 --> 00:01:37.390
out the views that the
user can see right now.

00:01:40.060 --> 00:01:42.916
And as the user scrolls, we
continue to lay out more items.

00:01:42.916 --> 00:01:44.540
The image you should
have in your heads

00:01:44.540 --> 00:01:47.170
right now is that bit
from "Wallace and Gromit"

00:01:47.170 --> 00:01:48.850
where you're quickly
laying the track

00:01:48.850 --> 00:01:51.090
in front of the moving train.

00:01:51.090 --> 00:01:53.310
So that's basically
how ListView works.

00:01:53.310 --> 00:01:54.930
And in order to
enable this, ListView

00:01:54.930 --> 00:01:57.200
uses adapter components.

00:01:57.200 --> 00:01:59.110
Now, this is a component
that's provided

00:01:59.110 --> 00:02:01.270
by the application itself.

00:02:01.270 --> 00:02:03.180
And it's used to
create and populate

00:02:03.180 --> 00:02:04.630
the item views on demand.

00:02:04.630 --> 00:02:07.400
You've got this getView
method in the adapter that

00:02:07.400 --> 00:02:10.060
is used to query the adapter
for a particular view

00:02:10.060 --> 00:02:12.000
to show a data item
that corresponds

00:02:12.000 --> 00:02:15.650
to a particular
position in the list.

00:02:15.650 --> 00:02:17.500
And the extra trick
that we do there is we

00:02:17.500 --> 00:02:20.220
also pass in a special
convert view that's

00:02:20.220 --> 00:02:22.590
guaranteed to be of
the same item type

00:02:22.590 --> 00:02:24.430
that the adapter believes
that new position

00:02:24.430 --> 00:02:26.990
to be so that you can
reuse the same view,

00:02:26.990 --> 00:02:30.950
and you don't have to pay
the cost of inflation again.

00:02:30.950 --> 00:02:33.770
And over time, we continued
adding more and more features

00:02:33.770 --> 00:02:35.270
to ListView because
they were things

00:02:35.270 --> 00:02:38.260
that people needed
in their apps.

00:02:38.260 --> 00:02:40.810
And this question
kind of came up a lot.

00:02:40.810 --> 00:02:44.350
So, ListView grew feature
after feature after feature.

00:02:44.350 --> 00:02:47.730
And you can go back and
watch this talk from I/O 2010

00:02:47.730 --> 00:02:50.327
if you want to
see a few of them.

00:02:50.327 --> 00:02:51.660
MALE SPEAKER 2: Watch that talk.

00:02:51.660 --> 00:02:52.700
It's really nice.

00:02:52.700 --> 00:02:53.610
You should watch it.

00:02:53.610 --> 00:02:54.415
I enjoyed it.

00:02:54.415 --> 00:02:55.790
MALE SPEAKER 1:
Yeah, if you want

00:02:55.790 --> 00:03:00.220
to see some of our classic UIs
in some of that talk, as well,

00:03:00.220 --> 00:03:00.720
yeah.

00:03:00.720 --> 00:03:02.101
MALE SPEAKER 2: It's nice.

00:03:02.101 --> 00:03:04.350
MALE SPEAKER 1: But really,
as we kept adding features

00:03:04.350 --> 00:03:07.410
to ListView, we kind of hit
this complexity overdraft point.

00:03:07.410 --> 00:03:09.780
We had so many features
that kinda sorta

00:03:09.780 --> 00:03:12.430
interacted with each
other but not really, all

00:03:12.430 --> 00:03:14.720
of them a little bit one-off.

00:03:14.720 --> 00:03:17.600
And it was just all
these long tail features

00:03:17.600 --> 00:03:21.000
that led to a lot of very
strange interactions.

00:03:21.000 --> 00:03:23.280
And what that meant
in practice is

00:03:23.280 --> 00:03:24.780
that everybody wrote
their apps such

00:03:24.780 --> 00:03:26.530
that things worked
how they wanted it to,

00:03:26.530 --> 00:03:28.520
but a lot of times
those things were really

00:03:28.520 --> 00:03:30.450
just kind of the result
of undefined behavior

00:03:30.450 --> 00:03:33.090
in ListView's
implementation itself.

00:03:33.090 --> 00:03:35.790
And once enough apps
start doing that,

00:03:35.790 --> 00:03:38.520
then that's de facto API
that we have to support.

00:03:38.520 --> 00:03:40.900
Any small change that we make
to ListView's behavior that

00:03:40.900 --> 00:03:43.670
might improve it for some
of these core use cases

00:03:43.670 --> 00:03:46.900
ends up breaking some app's
really hero use case that they

00:03:46.900 --> 00:03:49.429
want to use someplace else.

00:03:49.429 --> 00:03:52.200
We also had a lot of
duplicated functionality

00:03:52.200 --> 00:03:56.990
in ListView, like ListView
selections or View focus, which

00:03:56.990 --> 00:03:57.890
ones do we use?

00:03:57.890 --> 00:03:59.340
I mean, the view
hierarchy already

00:03:59.340 --> 00:04:01.390
knows how to handle
things like keyboard focus

00:04:01.390 --> 00:04:03.740
as you navigate
around, but ListView

00:04:03.740 --> 00:04:05.450
had its own completely
separate idea

00:04:05.450 --> 00:04:08.280
of this in terms of the
current selection, a selector

00:04:08.280 --> 00:04:11.310
drawable that's drawn either
behind or over the views,

00:04:11.310 --> 00:04:14.220
depending on what
configurations that you set up.

00:04:14.220 --> 00:04:16.890
And this led to
a lot of overlap.

00:04:16.890 --> 00:04:20.277
And not only that,
but it meant that,

00:04:20.277 --> 00:04:22.610
when you start using more
complex views in your ListView

00:04:22.610 --> 00:04:24.890
items, you kind of
have to switch over

00:04:24.890 --> 00:04:29.830
to this setItemsCanFocus
option that disables ListView's

00:04:29.830 --> 00:04:31.530
internal selection
handling and lets

00:04:31.530 --> 00:04:36.120
you use the View hierarchy's
focus handling instead.

00:04:36.120 --> 00:04:39.550
Similarly, we had the same issue
around item click listeners

00:04:39.550 --> 00:04:42.740
versus View click listeners and
other sorts of general touch

00:04:42.740 --> 00:04:43.730
handling.

00:04:43.730 --> 00:04:46.970
So ListView provided this
very nice convenience

00:04:46.970 --> 00:04:49.400
where you could set an item
click listener on the ListView

00:04:49.400 --> 00:04:51.400
itself and get clicks
for anything that

00:04:51.400 --> 00:04:52.571
happens in that list.

00:04:52.571 --> 00:04:54.070
Now, this makes a
whole lot of sense

00:04:54.070 --> 00:04:56.080
for lists that are
really uniform,

00:04:56.080 --> 00:04:58.550
where you have a list
of items and you just

00:04:58.550 --> 00:05:01.110
want to pick something from it,
kind of like the pop-up menus

00:05:01.110 --> 00:05:02.740
that we have from
the overflow menu

00:05:02.740 --> 00:05:06.030
up in the upper corner
of your apps today.

00:05:06.030 --> 00:05:08.572
But alternatively,
you can also just

00:05:08.572 --> 00:05:10.030
go ahead and attach
click listeners

00:05:10.030 --> 00:05:11.760
to these views themselves.

00:05:11.760 --> 00:05:15.050
And which one was going
to handle the events

00:05:15.050 --> 00:05:18.030
was sometimes not always
clear or intuitive.

00:05:18.030 --> 00:05:19.655
So people would ask
us a lot of times,

00:05:19.655 --> 00:05:21.630
you know, which one do I use.

00:05:21.630 --> 00:05:24.110
And the answer always
ended up being, it depends.

00:05:24.110 --> 00:05:26.430
It was like, OK, well, how
complex are your list items,

00:05:26.430 --> 00:05:27.370
so on and so forth.

00:05:27.370 --> 00:05:28.828
And anytime that
you have to answer

00:05:28.828 --> 00:05:31.360
a lot of those types of
clarifying questions about,

00:05:31.360 --> 00:05:33.780
like, OK, well, what
are you trying to do?

00:05:33.780 --> 00:05:35.970
Then that really kind of
complicates the developer

00:05:35.970 --> 00:05:38.340
story.

00:05:38.340 --> 00:05:41.290
But really the big
thing that kind of

00:05:41.290 --> 00:05:43.700
kicked off the whole
RecyclerView effort

00:05:43.700 --> 00:05:48.530
was that ListView animations
are really, really difficult.

00:05:48.530 --> 00:05:50.730
And the core problem is
that adapters don't tell

00:05:50.730 --> 00:05:52.630
us enough to do them smart.

00:05:52.630 --> 00:05:59.080
So when you change an adapter,
you say notifyDataSetChange,

00:05:59.080 --> 00:06:02.190
and the assumption is
anything could have changed.

00:06:02.190 --> 00:06:04.059
We're not entirely sure
what, and we're just

00:06:04.059 --> 00:06:06.600
going to go ahead and rebind
all the items that are currently

00:06:06.600 --> 00:06:09.740
visible and go from there.

00:06:09.740 --> 00:06:12.880
And over time, we had a few
prototypes-- some of them

00:06:12.880 --> 00:06:15.465
were done by members of
the team, some of them

00:06:15.465 --> 00:06:17.090
were done by members
of the community--

00:06:17.090 --> 00:06:19.980
all to try to show
items animating

00:06:19.980 --> 00:06:23.040
in and out as the data
set changes, and do so

00:06:23.040 --> 00:06:24.820
in a way that's
kind of intuitive.

00:06:24.820 --> 00:06:27.440
But all of these had some
really major limitations.

00:06:27.440 --> 00:06:29.440
Most of these had
to do with, again,

00:06:29.440 --> 00:06:32.120
the internal implementation
details of ListView

00:06:32.120 --> 00:06:33.750
that apps had really
come to rely on.

00:06:33.750 --> 00:06:35.400
So we couldn't fix
these things to make

00:06:35.400 --> 00:06:38.640
these animations possible.

00:06:38.640 --> 00:06:41.860
So eventually, you just end up
making this face at ListView.

00:06:41.860 --> 00:06:43.570
MALE SPEAKER 2: Yeah,
look at his-- look

00:06:43.570 --> 00:06:46.600
at the regret in his face, like
I'm doing this [INAUDIBLE],

00:06:46.600 --> 00:06:48.860
but I'm not really sure
if I should do this.

00:06:48.860 --> 00:06:50.620
Like, I'm gonna regret this.

00:06:50.620 --> 00:06:51.650
I have to do.

00:06:51.650 --> 00:06:55.560
MALE SPEAKER 1: Yeah, Chet
wears this face a lot.

00:06:55.560 --> 00:06:57.520
MALE SPEAKER 2: It comes
with the framework.

00:06:57.520 --> 00:06:58.785
MALE SPEAKER 1: Right.

00:06:58.785 --> 00:07:00.470
And again, another
one of these problems

00:07:00.470 --> 00:07:01.630
that we had with
ListView was just

00:07:01.630 --> 00:07:02.795
this duplicated functionality--

00:07:02.795 --> 00:07:03.330
MALE SPEAKER 2: [INAUDIBLE]--

00:07:03.330 --> 00:07:04.580
MALE SPEAKER 1: Like what is--

00:07:04.580 --> 00:07:06.805
MALE SPEAKER 2:
[? --slides. ?] [INAUDIBLE].

00:07:06.805 --> 00:07:08.804
MALE SPEAKER 1: Yeah, I
guess we did, didn't we.

00:07:08.804 --> 00:07:10.220
OK.

00:07:10.220 --> 00:07:12.680
So as we moved
on, people started

00:07:12.680 --> 00:07:15.430
using much, much more complex
layouts in their ListView

00:07:15.430 --> 00:07:16.020
items.

00:07:16.020 --> 00:07:18.710
We went from something like
that very simple settings screen

00:07:18.710 --> 00:07:20.840
in Gingerbread to
suddenly, people

00:07:20.840 --> 00:07:23.480
are showing items from a
full social stream, items

00:07:23.480 --> 00:07:25.620
with many different
components to them,

00:07:25.620 --> 00:07:28.970
with many different
points of interaction.

00:07:28.970 --> 00:07:31.819
So these simple grids and lists
that we provided with ListView

00:07:31.819 --> 00:07:33.360
and GridView and
the framework really

00:07:33.360 --> 00:07:36.440
weren't enough to handle
these use cases appropriately.

00:07:36.440 --> 00:07:40.190
People started wanting to create
these sorts of staggered grids,

00:07:40.190 --> 00:07:43.200
responsive layouts,
so on and so forth.

00:07:43.200 --> 00:07:46.450
And really, if you wanted to
change these types of layouts,

00:07:46.450 --> 00:07:49.430
you were rewriting a
whole lot of core code

00:07:49.430 --> 00:07:54.520
that ListView used to do
this adapter-based recycling.

00:07:54.520 --> 00:07:57.840
So if we had a do-over,
what would we change?

00:07:57.840 --> 00:07:59.880
Well, one of the things
that we wanted to do

00:07:59.880 --> 00:08:01.940
was to elevate
the best practices

00:08:01.940 --> 00:08:05.520
of working with ListView
to first-class API.

00:08:05.520 --> 00:08:08.480
We had this ViewHolder pattern
that Roman and I went over

00:08:08.480 --> 00:08:10.730
in the "World of
ListView" talk linked

00:08:10.730 --> 00:08:13.622
earlier in the talk here.

00:08:13.622 --> 00:08:15.580
And the nice thing about
the ViewHolder pattern

00:08:15.580 --> 00:08:19.460
as it existed for
ListView is it gave one

00:08:19.460 --> 00:08:22.452
point where you could sort of
collect a bunch of attributes

00:08:22.452 --> 00:08:23.910
about a recycled
view that you were

00:08:23.910 --> 00:08:26.790
going to work with and have
that single point of access.

00:08:26.790 --> 00:08:29.630
You could kind of cache a lot
of these findViewbyID calls

00:08:29.630 --> 00:08:32.780
that you would make to an
inflated View sub-hierarchy.

00:08:32.780 --> 00:08:34.824
And especially on
older devices, that

00:08:34.824 --> 00:08:36.240
made a big difference,
because you

00:08:36.240 --> 00:08:38.059
were doing fewer traversals.

00:08:38.059 --> 00:08:42.090
And as you were creating more
and more complex item layouts,

00:08:42.090 --> 00:08:44.090
it mattered even more.

00:08:44.090 --> 00:08:45.850
So we thought, OK,
well, let's go ahead

00:08:45.850 --> 00:08:47.570
and just make that
part of the core API.

00:08:47.570 --> 00:08:49.829
Like, let's go ahead and,
instead of having this just

00:08:49.829 --> 00:08:52.120
be a best practice that
everybody has to read some blog

00:08:52.120 --> 00:08:54.440
posts to figure out about,
let's go ahead and make sure

00:08:54.440 --> 00:08:55.650
that this is
something that you see

00:08:55.650 --> 00:08:57.691
as soon as you read the
documentation for working

00:08:57.691 --> 00:09:00.470
with RecyclerView.

00:09:00.470 --> 00:09:02.800
We want to separate view
creation and binding.

00:09:02.800 --> 00:09:06.250
Now, this was something that
happened in the cursor adapters

00:09:06.250 --> 00:09:08.770
that many of you have probably
used if you worked with SQL

00:09:08.770 --> 00:09:11.460
Lite databases or
content providers

00:09:11.460 --> 00:09:15.550
as your backing data source
for your ListView adapters.

00:09:15.550 --> 00:09:19.270
We separated out an onCreate
versus onBind step in those.

00:09:19.270 --> 00:09:22.230
But if you were just writing a
raw ListView adapter yourself,

00:09:22.230 --> 00:09:24.410
then this was
essentially a question

00:09:24.410 --> 00:09:27.700
of the very first couple lines
of code in your getView method

00:09:27.700 --> 00:09:31.070
where if convertView equals
null, create a new thing.

00:09:31.070 --> 00:09:33.512
And then sort of follow through
and do the binding there.

00:09:33.512 --> 00:09:35.220
And this was one of
those things that was

00:09:35.220 --> 00:09:37.010
fairly easy to forget to do.

00:09:37.010 --> 00:09:39.070
And if you forget
to do it, then that

00:09:39.070 --> 00:09:42.350
means that you entirely lose
out on this recycling mechanic

00:09:42.350 --> 00:09:46.060
that ListView gave you to really
kind of boost your performance.

00:09:46.060 --> 00:09:47.724
Sometimes, it
wasn't really clear

00:09:47.724 --> 00:09:49.390
why this was happening
from the outside.

00:09:52.030 --> 00:09:53.910
And next, we really
kind of wanted

00:09:53.910 --> 00:09:57.380
to throw out a bunch of
this selection handling

00:09:57.380 --> 00:10:01.140
that really only made sense
for these very simplified lists

00:10:01.140 --> 00:10:05.010
and just rely on the framework's
normal focus and input

00:10:05.010 --> 00:10:09.230
handling, because this
was-- this, again,

00:10:09.230 --> 00:10:10.772
just kind of comes
down to simplicity

00:10:10.772 --> 00:10:12.521
of working with the
rest of the framework,

00:10:12.521 --> 00:10:14.680
and kind of reinforcing
the consistency of working

00:10:14.680 --> 00:10:17.940
with the rest of
the View hierarchy.

00:10:17.940 --> 00:10:20.640
And then selfishly, we also
wanted a little bit more

00:10:20.640 --> 00:10:22.872
easier maintenance on
our end, because-- I

00:10:22.872 --> 00:10:25.330
don't know if any of you have
taken a look at the internals

00:10:25.330 --> 00:10:28.460
of ListView in AOSP.

00:10:28.460 --> 00:10:33.030
I'm pretty sure that it could
be used to scare small children.

00:10:33.030 --> 00:10:34.960
So we wanted to keep
the core universal.

00:10:34.960 --> 00:10:37.140
So all of those things
that were a total pain

00:10:37.140 --> 00:10:40.220
to rewrite yourself if you tried
to write your own recycling

00:10:40.220 --> 00:10:42.390
container, we
wanted to have a way

00:10:42.390 --> 00:10:44.600
to give that to
developers more or less

00:10:44.600 --> 00:10:46.760
for free in a canned form
so that they didn't have

00:10:46.760 --> 00:10:48.500
to sort of rediscover
all the things

00:10:48.500 --> 00:10:51.152
that we had to do the hard way.

00:10:51.152 --> 00:10:53.110
And we wanted to make
sure that you could still

00:10:53.110 --> 00:10:55.270
implement all of these
other long tail features

00:10:55.270 --> 00:10:58.440
that ListView just kind of
provided as API on ListView

00:10:58.440 --> 00:11:02.130
itself as other plug-ins that
we could sort of share and mix

00:11:02.130 --> 00:11:06.390
and match to get the
experience that you wanted.

00:11:06.390 --> 00:11:08.700
We needed smarter adapters, too.

00:11:08.700 --> 00:11:10.960
Again, the problem
with ListView adapters

00:11:10.960 --> 00:11:13.510
is that you could say,
notifyDataSetChanged.

00:11:13.510 --> 00:11:14.520
OK, what changed?

00:11:14.520 --> 00:11:15.950
Uh.

00:11:15.950 --> 00:11:17.770
And that was about all you knew.

00:11:17.770 --> 00:11:20.190
And this makes animations
really difficult.

00:11:20.190 --> 00:11:23.960
We'll get to that a little
bit further on down the line.

00:11:23.960 --> 00:11:27.290
So RecyclerView adapters
tell us what changed,

00:11:27.290 --> 00:11:29.170
not just that something changed.

00:11:29.170 --> 00:11:31.740
Now, if you're working
with a data source that

00:11:31.740 --> 00:11:34.220
doesn't provide that sort
of fine-grained messaging,

00:11:34.220 --> 00:11:36.790
then you can still use
the old ListView style,

00:11:36.790 --> 00:11:39.480
hey, something changed,
go figure it out.

00:11:39.480 --> 00:11:41.860
We'll make some best-effort
attempts at dealing with it.

00:11:41.860 --> 00:11:44.190
But really, if you
have any knowledge

00:11:44.190 --> 00:11:47.420
of what the specific changes
in your data set are,

00:11:47.420 --> 00:11:50.870
you can get a lot
better results.

00:11:50.870 --> 00:11:54.850
So this also means that we can
do more efficient recycling,

00:11:54.850 --> 00:11:56.620
not just animations.

00:11:56.620 --> 00:11:59.230
If we know that only a
particular item in the adapter

00:11:59.230 --> 00:12:02.000
changed, then we don't
have to rebind everything

00:12:02.000 --> 00:12:04.650
that's on the screen, we only
have to rebind that one view.

00:12:04.650 --> 00:12:07.260
And this can save a lot of time
in the measurement and layout

00:12:07.260 --> 00:12:11.940
phases of applying
those updates.

00:12:11.940 --> 00:12:13.400
MALE SPEAKER 2: All right.

00:12:13.400 --> 00:12:15.640
So that was born RecyclerView.

00:12:15.640 --> 00:12:18.950
So make mistakes we
learned from ListView, Now

00:12:18.950 --> 00:12:21.560
like, OK, how do we
write RecyclerView not

00:12:21.560 --> 00:12:23.760
to repeat the same mistakes.

00:12:23.760 --> 00:12:26.849
And the major thing in
RecyclerView is we try to make

00:12:26.849 --> 00:12:28.515
the [? complement-based ?]
architecture.

00:12:28.515 --> 00:12:30.530
This is the architecture
of RecyclerView.

00:12:30.530 --> 00:12:33.230
And we will go through
the details of it.

00:12:33.230 --> 00:12:34.440
I think it's very important.

00:12:34.440 --> 00:12:36.250
I believe most of
you already use it.

00:12:36.250 --> 00:12:39.520
It's good to know who does what,
and which one you should use,

00:12:39.520 --> 00:12:41.120
or which one you
should customize,

00:12:41.120 --> 00:12:43.210
depending on use case.

00:12:43.210 --> 00:12:46.090
So with the RecyclerView, that's
the main view, [INAUDIBLE]

00:12:46.090 --> 00:12:48.840
there's major three--
three major components.

00:12:48.840 --> 00:12:52.900
There's the layout manager, an
item animator, and an adapter.

00:12:52.900 --> 00:12:56.320
So adapter is provided
by your layout managers.

00:12:56.320 --> 00:12:58.280
Most of you provide
you can write yourself,

00:12:58.280 --> 00:12:59.620
and item animator is the same.

00:12:59.620 --> 00:13:02.060
There's a good default one
where [? you can ?] [? write ?]

00:13:02.060 --> 00:13:02.980
yourself.

00:13:02.980 --> 00:13:05.630
So layout manager
positions the wheels,

00:13:05.630 --> 00:13:08.340
item animator animates
them, and the adapter

00:13:08.340 --> 00:13:10.060
provides the wheels.

00:13:10.060 --> 00:13:11.620
And the RecyclerView
is the boss.

00:13:11.620 --> 00:13:13.210
So it's the central
location that

00:13:13.210 --> 00:13:15.700
communicates with
all these components

00:13:15.700 --> 00:13:17.610
to make them work together.

00:13:17.610 --> 00:13:20.200
So we need to look at
the layout manager.

00:13:20.200 --> 00:13:23.450
It can be a linear
list, it can be a grid,

00:13:23.450 --> 00:13:24.860
or it can be a [INAUDIBLE] grid.

00:13:24.860 --> 00:13:25.880
It can be anything.

00:13:25.880 --> 00:13:28.050
RecyclerView doesn't
know or doesn't

00:13:28.050 --> 00:13:30.420
care about how the
items are laid out.

00:13:30.420 --> 00:13:32.670
It's the layout
manager's responsibility.

00:13:32.670 --> 00:13:37.360
Or scrolling, RecyclerView
handles the interactions

00:13:37.360 --> 00:13:39.780
with the [? finger ?] but
tells the layout manager

00:13:39.780 --> 00:13:42.090
to scroll because only
the layout manager knows

00:13:42.090 --> 00:13:43.330
where the views are.

00:13:43.330 --> 00:13:44.930
So it stores the content.

00:13:44.930 --> 00:13:47.730
Or if you do focus
traversal, RecyclerView

00:13:47.730 --> 00:13:49.570
handles the basic
focus traversal

00:13:49.570 --> 00:13:52.900
because the-- actually, the
[? V ?] framework handles it.

00:13:52.900 --> 00:13:55.740
But if you are focusing
and you need one more item,

00:13:55.740 --> 00:13:57.350
then it's the
layout manager that

00:13:57.350 --> 00:13:59.180
brings the new item
to the focus area,

00:13:59.180 --> 00:14:02.750
because that did
not exist before.

00:14:02.750 --> 00:14:05.250
Or the accessibility,
[INAUDIBLE]

00:14:05.250 --> 00:14:07.850
provides basic information
about those items,

00:14:07.850 --> 00:14:09.790
but layout manager
[INAUDIBLE] is

00:14:09.790 --> 00:14:12.830
the one that knows, OK,
this is a section title.

00:14:12.830 --> 00:14:16.550
Or, you could attach your
custom delegate that says, hey,

00:14:16.550 --> 00:14:20.340
like do not focus on this,
or additional information

00:14:20.340 --> 00:14:22.490
that only you can provide.

00:14:22.490 --> 00:14:24.810
[INAUDIBLE] RecyclerView
accessible to delegate

00:14:24.810 --> 00:14:27.970
API for this.

00:14:27.970 --> 00:14:29.690
MALE SPEAKER 1: All right.

00:14:29.690 --> 00:14:32.690
So similar to ListView,
RecyclerView still

00:14:32.690 --> 00:14:35.610
relies on adapters.

00:14:35.610 --> 00:14:37.760
Now, a RecyclerView
adapter's responsibilities

00:14:37.760 --> 00:14:39.870
are, again, to create
the View, but also

00:14:39.870 --> 00:14:41.120
to create the ViewHolder.

00:14:41.120 --> 00:14:42.620
And the ViewHolder
is what we really

00:14:42.620 --> 00:14:46.180
use as the tracking
element for recycling.

00:14:46.180 --> 00:14:47.839
So when you're
binding an item, you

00:14:47.839 --> 00:14:49.630
don't just bind it to
the View, you bind it

00:14:49.630 --> 00:14:50.640
to the whole ViewHolder.

00:14:50.640 --> 00:14:52.056
And this is something
that you can

00:14:52.056 --> 00:14:56.900
use as a place to stash
other information, as well.

00:14:56.900 --> 00:14:58.900
And of course, it's the
adapter's responsibility

00:14:58.900 --> 00:15:00.775
to notify the
RecyclerView about changes

00:15:00.775 --> 00:15:04.405
that happen to the data set,
or if the data is out of sync.

00:15:08.400 --> 00:15:10.720
So in contrast to
ListView, where

00:15:10.720 --> 00:15:13.980
you could use this item
click listener type of model

00:15:13.980 --> 00:15:17.230
for things, the adapter is now
responsible for configuring

00:15:17.230 --> 00:15:19.050
the item interaction handling.

00:15:19.050 --> 00:15:21.600
So these are all your click
listeners, touch listeners,

00:15:21.600 --> 00:15:22.480
so on and so forth.

00:15:25.230 --> 00:15:28.560
Adapters also deal with
your multiple View types,

00:15:28.560 --> 00:15:32.810
sort of being able to keep track
of the different ViewHolders

00:15:32.810 --> 00:15:35.406
that you may be tracking.

00:15:35.406 --> 00:15:38.400
MALE SPEAKER 2: And I-- one tip
about the [? weave ?] types.

00:15:38.400 --> 00:15:40.150
In the ListView world,
you need to give us

00:15:40.150 --> 00:15:43.230
how many [? weave ?] types you
have, versus in Recycle View,

00:15:43.230 --> 00:15:44.590
they're unlimited.

00:15:44.590 --> 00:15:47.320
So I suggest just use
[? r dot ?] layouts

00:15:47.320 --> 00:15:49.110
[? whatever ?] as
the [INAUDIBLE] type,

00:15:49.110 --> 00:15:50.320
and you're done.

00:15:50.320 --> 00:15:51.350
MALE SPEAKER 1: Right.

00:15:51.350 --> 00:15:53.580
So your View type
IDs is no longer

00:15:53.580 --> 00:15:56.400
needed to be contiguous the way
that they did with ListView.

00:15:56.400 --> 00:15:59.330
So as long as you have any
sort of unique identifier

00:15:59.330 --> 00:16:02.780
you can use to identify a View
type, then go ahead and use it,

00:16:02.780 --> 00:16:04.570
and RecyclerView
isn't going to care.

00:16:04.570 --> 00:16:07.380
So that means that you can
use this handy trick of using

00:16:07.380 --> 00:16:09.400
the layout resource ID itself.

00:16:09.400 --> 00:16:12.680
And since AEPT
already guarantees

00:16:12.680 --> 00:16:14.880
that that ID is
going to be unique,

00:16:14.880 --> 00:16:20.010
it makes a pretty good
stand-in for that identifier.

00:16:20.010 --> 00:16:22.720
Oh, whoops, went
a little too fast.

00:16:22.720 --> 00:16:25.650
So the adapter also deals with
things like recycler recovery.

00:16:25.650 --> 00:16:29.400
So we have this
onFailedToRecycleView concept.

00:16:29.400 --> 00:16:32.240
So why could something
fail to recycle a view?

00:16:32.240 --> 00:16:35.450
Well, again, we're
trying to keep in mind

00:16:35.450 --> 00:16:37.320
that people are doing
more and more complex

00:16:37.320 --> 00:16:38.710
things with their UIs.

00:16:38.710 --> 00:16:40.320
And in those cases,
you might start

00:16:40.320 --> 00:16:43.170
making a lot of
changes to your views

00:16:43.170 --> 00:16:45.280
that are very
difficult to reverse.

00:16:45.280 --> 00:16:48.170
So in those cases where we
know that a View has been left

00:16:48.170 --> 00:16:51.130
in kind of an
inconsistent state, then

00:16:51.130 --> 00:16:53.440
we can communicate that back
and forth to the adapter

00:16:53.440 --> 00:16:56.670
so that the adapter is able
to sort of recover from a case

00:16:56.670 --> 00:17:00.210
where a View has
been messed with kind

00:17:00.210 --> 00:17:03.360
of beyond the normal
bounds of expectation.

00:17:03.360 --> 00:17:05.750
And again, we have the
granular data change events,

00:17:05.750 --> 00:17:10.683
as added, to sort of
handle efficiency and--

00:17:10.683 --> 00:17:11.849
MALE SPEAKER 2: Performance.

00:17:11.849 --> 00:17:12.470
MALE SPEAKER 1:
I'm totally blank.

00:17:12.470 --> 00:17:13.160
Performance.

00:17:13.160 --> 00:17:13.430
That's efficiency.

00:17:13.430 --> 00:17:14.099
MALE SPEAKER 2: Animations.

00:17:14.099 --> 00:17:15.223
MALE SPEAKER 1: Animations.

00:17:15.223 --> 00:17:16.849
Yes, that one.

00:17:16.849 --> 00:17:17.349
All right.

00:17:17.349 --> 00:17:17.960
MALE SPEAKER 2: All right.

00:17:17.960 --> 00:17:19.810
So let's deep dive
into the ViewHolder,

00:17:19.810 --> 00:17:23.680
because most of-- everybody
needs to write their ViewHolder

00:17:23.680 --> 00:17:27.770
to use RecyclerView, and you
spend most of your time there.

00:17:27.770 --> 00:17:31.120
It's important to know the
life cycle of a ViewHolder.

00:17:31.120 --> 00:17:32.470
So we'll go through it.

00:17:32.470 --> 00:17:37.020
What happens when we create
it, what are the stages.

00:17:37.020 --> 00:17:40.340
So while the Layout Manager
is calculating the layout,

00:17:40.340 --> 00:17:42.840
it tells the
RecyclerView, OK, give me

00:17:42.840 --> 00:17:45.240
the View for position five.

00:17:45.240 --> 00:17:47.670
So it wants to get the
View for that position.

00:17:47.670 --> 00:17:50.560
RecyclerView checks the cache,
because we cache the views.

00:17:50.560 --> 00:17:52.290
Now if you already
have it in the cache,

00:17:52.290 --> 00:17:55.470
we will return it to
the Layout Manager.

00:17:55.470 --> 00:17:59.600
If not, so we have it,
[? need to return it. ?]

00:17:59.600 --> 00:18:02.730
If we didn't have
it, the case said no,

00:18:02.730 --> 00:18:05.100
RecyclerView will tell
the-- ask the adapter, OK,

00:18:05.100 --> 00:18:07.290
what's the type of this view?

00:18:07.290 --> 00:18:08.290
Adapter returns it.

00:18:08.290 --> 00:18:10.000
Then we go check the pool.

00:18:10.000 --> 00:18:11.490
This might be a
shared pool, this

00:18:11.490 --> 00:18:14.520
might be the-- like the only
pool used by the RecyclerView.

00:18:14.520 --> 00:18:17.670
Do we have a ViewHolder
for this [? View ?] type.

00:18:17.670 --> 00:18:21.460
If it says no, we tell
the adapter to create one.

00:18:21.460 --> 00:18:25.700
So this is when we actually
create a ViewHolder.

00:18:25.700 --> 00:18:29.410
Or maybe the pool returned
an item that already exists.

00:18:29.410 --> 00:18:34.140
Then we tell the adapter,
OK, bind this position

00:18:34.140 --> 00:18:35.570
to this ViewHolder.

00:18:35.570 --> 00:18:39.310
It returns it, and we give it
back to the Layout Manager.

00:18:39.310 --> 00:18:42.530
Eventually, Layout Manager will
add it back to the RecyclerView

00:18:42.530 --> 00:18:45.720
as [? a ?] [? real ?] child, and
then we will tell the adapter,

00:18:45.720 --> 00:18:48.080
hey, this [? View ?] has
been added to the layout.

00:18:48.080 --> 00:18:51.460
This is a very good
hint for your adapter

00:18:51.460 --> 00:18:56.020
to know that, OK, user is
about to see this view.

00:18:56.020 --> 00:18:58.080
This other case where
Layout Manager might say,

00:18:58.080 --> 00:19:01.510
OK, I'm done with this
view, remove and recycle it.

00:19:01.510 --> 00:19:03.440
RecyclerView will tell
the adapter, OK, I

00:19:03.440 --> 00:19:05.145
removed this view,
let you know so

00:19:05.145 --> 00:19:07.010
that if you have an
[? expensive ?] things

00:19:07.010 --> 00:19:09.790
inside that view,
you can uncache them.

00:19:09.790 --> 00:19:13.280
You can remove them from memory.

00:19:13.280 --> 00:19:15.990
And then we will
check, OK, is this view

00:19:15.990 --> 00:19:18.450
valid for this position.

00:19:18.450 --> 00:19:21.010
If it is valid for this
position, we will cache it.

00:19:21.010 --> 00:19:24.110
The idea is that if the
Layout Manager asks back

00:19:24.110 --> 00:19:26.460
for that position
again, we can give it

00:19:26.460 --> 00:19:28.080
without talking to the adapter.

00:19:28.080 --> 00:19:30.700
This is, again, for
performance reasons.

00:19:30.700 --> 00:19:33.195
And then the cache will
evict the oldest one.

00:19:33.195 --> 00:19:36.440
And I will tell the adapter,
hey, we got rid of this view.

00:19:36.440 --> 00:19:40.050
Now you know that it will not
be reused for that position,

00:19:40.050 --> 00:19:43.324
so you can do even
further memory clean-up.

00:19:43.324 --> 00:19:44.240
MALE SPEAKER 1: Right.

00:19:44.240 --> 00:19:47.040
This is kind of an important
step that was a lesson learned

00:19:47.040 --> 00:19:51.430
from ListView, where ListView
eventually added this Recycled

00:19:51.430 --> 00:19:55.000
View listener that you could use
to track when a view was really

00:19:55.000 --> 00:19:56.440
no longer in use.

00:19:56.440 --> 00:19:59.930
And again, because people create
much, much more complex UIs

00:19:59.930 --> 00:20:01.600
in these sorts of
recycling containers

00:20:01.600 --> 00:20:03.760
these days, this allows
you to take a step

00:20:03.760 --> 00:20:05.820
and say, OK, well,
instead of leaving

00:20:05.820 --> 00:20:08.840
these giant, expensive bitmaps
attached to these views that

00:20:08.840 --> 00:20:11.210
are just being held in a cache
offscreen, let's go ahead

00:20:11.210 --> 00:20:12.710
and clean those
things up, but still

00:20:12.710 --> 00:20:15.225
retain the core view structure
that we had before so

00:20:15.225 --> 00:20:17.446
that we can rebind it later.

00:20:17.446 --> 00:20:19.970
MALE SPEAKER 2: So if
the view is not valid--

00:20:19.970 --> 00:20:22.890
let's says it might be-- maybe
the item has been removed

00:20:22.890 --> 00:20:26.890
because the adapter told
us, or the item was changed

00:20:26.890 --> 00:20:29.099
and the contents of the
view does not represent

00:20:29.099 --> 00:20:30.015
that position anymore.

00:20:30.015 --> 00:20:33.850
If [INAUDIBLE] valid anymore,
we just send it to the pool

00:20:33.850 --> 00:20:35.940
and we tell the
adapter about it.

00:20:35.940 --> 00:20:39.850
There is another use case where
Layout Manager recalculates

00:20:39.850 --> 00:20:43.290
the layout after
some adapter changes,

00:20:43.290 --> 00:20:46.630
and that doesn't use
some of the Views.

00:20:46.630 --> 00:20:49.740
So [? it ?] [? had ?] all the
Views from 1 to 5, let's say,

00:20:49.740 --> 00:20:52.440
and then makes one, it
only use eight of them,

00:20:52.440 --> 00:20:54.870
and the other two are missing.

00:20:54.870 --> 00:20:56.530
So what RecyclerView
does is, OK, we

00:20:56.530 --> 00:20:58.360
understand that the
Layout Manager doesn't

00:20:58.360 --> 00:21:02.805
want these Views anymore,
so but ItemAnimator

00:21:02.805 --> 00:21:03.680
may want them, right.

00:21:03.680 --> 00:21:06.490
You may want to fade them out
instead of disappearing them

00:21:06.490 --> 00:21:07.470
instantly.

00:21:07.470 --> 00:21:11.530
So what RecyclerView will do is,
for each disappearing children,

00:21:11.530 --> 00:21:15.760
it's going to make them children
again and then hide them

00:21:15.760 --> 00:21:16.760
from the Layout Manager.

00:21:16.760 --> 00:21:18.710
We will go into
details of this later,

00:21:18.710 --> 00:21:22.090
but basically the list of
children from the Layout

00:21:22.090 --> 00:21:26.320
Manager's perspective are not
the same that as the children

00:21:26.320 --> 00:21:27.932
of the View group.

00:21:27.932 --> 00:21:32.230
When the ItemAnimator says,
OK, we'll tell ItemAnimator,

00:21:32.230 --> 00:21:33.205
animate these children.

00:21:33.205 --> 00:21:37.920
And when the ItemAnimator says,
OK, I'm done with these Views,

00:21:37.920 --> 00:21:39.320
you can do whatever
we want, then

00:21:39.320 --> 00:21:41.440
RecyclerView will remove them.

00:21:41.440 --> 00:21:44.110
It will tell the adapter
they are going away,

00:21:44.110 --> 00:21:47.280
and then we will recycle it.

00:21:47.280 --> 00:21:49.410
So how do we lose a ViewHolder?

00:21:49.410 --> 00:21:52.220
This is very important because,
if you're losing a ViewHolder,

00:21:52.220 --> 00:21:55.407
you will hit
performance problems.

00:21:55.407 --> 00:21:57.740
[INAUDIBLE] same thing happened,
Recycler Layout Manager

00:21:57.740 --> 00:21:59.890
said, OK, I want to
get rid of this view.

00:21:59.890 --> 00:22:02.750
RecyclerView will check
is this view valid.

00:22:02.750 --> 00:22:05.809
[INAUDIBLE] no, OK, we want
to put this into the pool.

00:22:05.809 --> 00:22:08.100
And the pool [INAUDIBLE]
[? that ?] [? this view ?] has

00:22:08.100 --> 00:22:10.690
[? transisted ?] this is
what Adam mentioned earlier.

00:22:10.690 --> 00:22:14.010
A view having [? transisted ?]
means [? is like ?] [? is ?]

00:22:14.010 --> 00:22:15.770
animating the
contents or, you know,

00:22:15.770 --> 00:22:19.110
we have a button that's
doing some animation.

00:22:19.110 --> 00:22:21.530
That means if
[? a view ?] is animating,

00:22:21.530 --> 00:22:24.000
we cannot reuse it
for other ViewHolder.

00:22:24.000 --> 00:22:26.570
Because imagine that it
was fading out and then

00:22:26.570 --> 00:22:29.270
we bind it to something
else, and it comes to the UI

00:22:29.270 --> 00:22:29.930
as faded out.

00:22:29.930 --> 00:22:31.560
It's like, that's
not what you want.

00:22:31.560 --> 00:22:32.600
You want fresh views.

00:22:32.600 --> 00:22:33.910
MALE SPEAKER 1: There
are a few other cases

00:22:33.910 --> 00:22:36.460
that can cause views to have
a transient state, as well.

00:22:36.460 --> 00:22:38.418
This is a concept that's
part of the framework,

00:22:38.418 --> 00:22:39.980
not just the
RecyclerView itself.

00:22:39.980 --> 00:22:42.730
So for example, if you
have an editText widget

00:22:42.730 --> 00:22:45.504
with a piece of text that
the user has entered,

00:22:45.504 --> 00:22:46.920
and they've gone
ahead and created

00:22:46.920 --> 00:22:50.107
a selection across several
words but maybe not others,

00:22:50.107 --> 00:22:51.940
then that's kind of
this complex interaction

00:22:51.940 --> 00:22:54.370
that the user has
created that we really

00:22:54.370 --> 00:22:56.840
didn't want to make it the
developer's responsibility

00:22:56.840 --> 00:23:00.160
to sort of track and restore
that if that particular item is

00:23:00.160 --> 00:23:03.090
rebound across other contexts.

00:23:03.090 --> 00:23:05.800
MALE SPEAKER 2: So what will
happen is that now we cannot

00:23:05.800 --> 00:23:08.427
reuse this view, and we are
removing from the RecyclerView

00:23:08.427 --> 00:23:10.760
[? like ?] [? the last ?]
reference we have to that view

00:23:10.760 --> 00:23:13.880
is going away, so we give
adapter one last chance.

00:23:13.880 --> 00:23:16.790
Hey, I could not
recycle this view.

00:23:16.790 --> 00:23:17.610
Can I recycle?

00:23:17.610 --> 00:23:19.776
Because most of the time,
it's because of animations

00:23:19.776 --> 00:23:21.410
[? on selection. ?]
You can actually

00:23:21.410 --> 00:23:23.070
recover from that state.

00:23:23.070 --> 00:23:25.680
The only problem is that
we cannot do it ultimately,

00:23:25.680 --> 00:23:27.690
because we don't
know what's going on.

00:23:27.690 --> 00:23:30.675
So adapter can say either
[INAUDIBLE] failed to recycle,

00:23:30.675 --> 00:23:35.370
you can end those animations or
clear the [? selected ?] state,

00:23:35.370 --> 00:23:37.110
or you can even say do nothing.

00:23:37.110 --> 00:23:39.500
Like, I know I fixed this
when [INAUDIBLE] [? this ?]

00:23:39.500 --> 00:23:42.540
[? code. ?] Like, recycle
it, I will use it.

00:23:42.540 --> 00:23:46.420
But if the adapter does
not implement this method,

00:23:46.420 --> 00:23:48.930
by default, it returns false.

00:23:48.930 --> 00:23:53.480
So we will have to
destroy the ViewHolder.

00:23:53.480 --> 00:23:54.967
So it goes to the dead pool.

00:23:54.967 --> 00:23:55.800
You don't want this.

00:23:58.820 --> 00:24:01.330
The moral of the story is,
if you're animating items,

00:24:01.330 --> 00:24:05.100
don't go ahead and create
animations [INAUDIBLE].

00:24:05.100 --> 00:24:08.540
We have the ItemAnimator API
to do these things properly.

00:24:08.540 --> 00:24:10.970
So use the ItemAnimator
if you want to animate.

00:24:10.970 --> 00:24:14.470
And the ItemAnimator receives
the correct life cycle events

00:24:14.470 --> 00:24:16.730
so that we can
recycle-- we can take

00:24:16.730 --> 00:24:19.284
care of recycling those views
when they are done animating.

00:24:19.284 --> 00:24:20.200
MALE SPEAKER 1: Right.

00:24:20.200 --> 00:24:21.970
Essentially, you can
forget about everything

00:24:21.970 --> 00:24:23.860
that just happened on
that slide before you,

00:24:23.860 --> 00:24:25.925
as long as you implement
the ItemAnimator interface.

00:24:25.925 --> 00:24:26.710
MALE SPEAKER 2:
Yeah, [INAUDIBLE].

00:24:26.710 --> 00:24:27.980
MALE SPEAKER 1: If
you're doing it yourself,

00:24:27.980 --> 00:24:28.950
you're on your own,
and you're going

00:24:28.950 --> 00:24:30.730
to have to handle all of
these problems yourself.

00:24:30.730 --> 00:24:31.604
MALE SPEAKER 2: Yeah.

00:24:31.604 --> 00:24:33.540
And [INAUDIBLE]
like the major thing

00:24:33.540 --> 00:24:35.540
when you start using
[? Recycle, ?] you really

00:24:35.540 --> 00:24:38.435
need to forget everything
you learned in ListView.

00:24:38.435 --> 00:24:41.080
Most of them are
valid, but [INAUDIBLE]

00:24:41.080 --> 00:24:45.086
some bits that are not valid
will actually hurt you here.

00:24:45.086 --> 00:24:46.460
So there's another
use case where

00:24:46.460 --> 00:24:49.440
we will lose views is
RecyclerView is like, OK,

00:24:49.440 --> 00:24:51.720
I am done with this view.

00:24:51.720 --> 00:24:53.450
We tried to put
it into the pool,

00:24:53.450 --> 00:24:57.860
but pool is limited
per size per item type.

00:24:57.860 --> 00:25:01.215
So if you have way too many of
those view types in the pool

00:25:01.215 --> 00:25:05.475
already, We're like, you know
what, we have no space for it.

00:25:05.475 --> 00:25:07.670
Throw it out.

00:25:07.670 --> 00:25:08.760
So why would this happen?

00:25:08.760 --> 00:25:11.550
Why would we create
views that we already

00:25:11.550 --> 00:25:14.910
had [INAUDIBLE] them stuff
that are unused in the pool?

00:25:14.910 --> 00:25:21.070
Well, this usually
happens if-- go ahead.

00:25:21.070 --> 00:25:23.695
So if you have too many
ViewHolder types, and why would

00:25:23.695 --> 00:25:26.690
it happen is mostly
because of animations.

00:25:26.690 --> 00:25:32.010
Like you told us, [INAUDIBLE]
to make it animate,

00:25:32.010 --> 00:25:35.090
instead of calling
[INAUDIBLE], call [INAUDIBLE]

00:25:35.090 --> 00:25:37.840
change from zero to all of them.

00:25:37.840 --> 00:25:39.366
So if you say
something like this,

00:25:39.366 --> 00:25:40.990
RecyclerView is
[? like, ?] [INAUDIBLE]

00:25:40.990 --> 00:25:44.670
for every single visible
child, by the default behavior,

00:25:44.670 --> 00:25:46.910
I have to create another
ViewHolder to represent

00:25:46.910 --> 00:25:49.170
the child so I can
cross-fade them,

00:25:49.170 --> 00:25:51.310
because the default
behavior is cross-fade.

00:25:51.310 --> 00:25:54.830
That means you duplicate
the number of ViewHolders.

00:25:54.830 --> 00:25:57.270
Of course, when those
animations are finished,

00:25:57.270 --> 00:25:59.350
we try to put all of
them back to the pool.

00:25:59.350 --> 00:26:01.510
And pool is like, eh, I
don't need this many items.

00:26:01.510 --> 00:26:03.420
You know, just throw them out.

00:26:03.420 --> 00:26:04.420
So don't do that.

00:26:04.420 --> 00:26:08.460
When an item has changed,
tell us what actually changed

00:26:08.460 --> 00:26:10.740
is really, really important.

00:26:10.740 --> 00:26:12.590
[INAUDIBLE] the
correct animation,

00:26:12.590 --> 00:26:15.710
or if you have some other cases
where you notice the views

00:26:15.710 --> 00:26:20.110
are being lost, you
can change the type--

00:26:20.110 --> 00:26:22.650
the size per type in the pool.

00:26:22.650 --> 00:26:24.920
MALE SPEAKER 1: So this
comes up when you have cases

00:26:24.920 --> 00:26:28.220
where, again, social streams are
a really big use case for this,

00:26:28.220 --> 00:26:28.910
as well.

00:26:28.910 --> 00:26:31.170
You might have some posts
that are very long that

00:26:31.170 --> 00:26:33.200
fill an entire screen
all by themselves,

00:26:33.200 --> 00:26:35.980
or you might have several posts
that are very, very short.

00:26:35.980 --> 00:26:38.800
And if you have items that are
of drastically different sizes

00:26:38.800 --> 00:26:40.890
like that, then
the number of items

00:26:40.890 --> 00:26:42.390
that can be attached
at one time is

00:26:42.390 --> 00:26:43.599
going to vary pretty greatly.

00:26:43.599 --> 00:26:45.056
So those are cases
where you really

00:26:45.056 --> 00:26:47.490
want to sort of measure what
your app's own behavior is

00:26:47.490 --> 00:26:49.350
under some of these
use cases, and tune

00:26:49.350 --> 00:26:54.181
the size of the RecycledView
pool accordingly.

00:26:54.181 --> 00:26:54.680
All right.

00:26:54.680 --> 00:26:56.421
MALE SPEAKER 2: ItemAnimator.

00:26:56.421 --> 00:26:59.480
MALE SPEAKER 1:
So, ItemAnimators.

00:26:59.480 --> 00:27:01.530
Items come and
items go over time.

00:27:01.530 --> 00:27:05.170
And again, we want to use a
smarter way of figuring out

00:27:05.170 --> 00:27:07.900
exactly what it
was that changed.

00:27:07.900 --> 00:27:09.900
So let's say that we add
a new item in between H

00:27:09.900 --> 00:27:13.360
and I in this diagram here.

00:27:13.360 --> 00:27:16.580
So now we have P in the
middle, so no longer sorted.

00:27:16.580 --> 00:27:19.620
Ignore that.

00:27:19.620 --> 00:27:22.580
What happens if
something disappears?

00:27:22.580 --> 00:27:25.070
Well, now we have
another image of a list.

00:27:25.070 --> 00:27:27.850
Now, the interesting
thing here-- oh, and then

00:27:27.850 --> 00:27:30.290
of course we have the case
where an item simply changes,

00:27:30.290 --> 00:27:34.010
and its contents
change in place.

00:27:34.010 --> 00:27:36.100
So the interesting
thing in these cases

00:27:36.100 --> 00:27:38.100
is that there's always
kind of some side effects

00:27:38.100 --> 00:27:40.420
when you add and remove views.

00:27:40.420 --> 00:27:44.230
So we added view P here.

00:27:44.230 --> 00:27:47.295
I and J got moved down,
and K is completely gone.

00:27:50.530 --> 00:27:54.360
When we remove, something
really similar happens.

00:27:54.360 --> 00:28:01.980
So we remove item H. I, J, K
move, but L is new on screen.

00:28:01.980 --> 00:28:05.450
We had to get a new view in
order to show it, in that case.

00:28:05.450 --> 00:28:11.020
So without extra information--
oh, sorry, change first.

00:28:11.020 --> 00:28:12.950
And of course, this is
one of the easy cases.

00:28:12.950 --> 00:28:15.033
We can just go ahead and
cross-fade between these.

00:28:17.560 --> 00:28:20.649
So if we're handling things
this way, if an item's removed,

00:28:20.649 --> 00:28:21.440
we can fade it out.

00:28:21.440 --> 00:28:25.560
If an item's added,
we fade it in.

00:28:25.560 --> 00:28:27.880
And if an item is just sort
of moving around on screen,

00:28:27.880 --> 00:28:29.060
we can translate it.

00:28:29.060 --> 00:28:31.480
And our default items
animation handlers

00:28:31.480 --> 00:28:34.040
can handle this, no problem.

00:28:34.040 --> 00:28:37.120
Changing, we just do a
simple cross-fade in place.

00:28:37.120 --> 00:28:38.570
And as long as we
don't have cases

00:28:38.570 --> 00:28:40.480
where that item
has changed size,

00:28:40.480 --> 00:28:41.650
we're in a super easy case.

00:28:41.650 --> 00:28:43.330
But otherwise, it just
means other items around it

00:28:43.330 --> 00:28:45.660
are moving, and we get into
exactly the same cases as

00:28:45.660 --> 00:28:47.590
before.

00:28:47.590 --> 00:28:49.410
But can we do better than this?

00:28:49.410 --> 00:28:52.150
There's kind of a key
problem in these cases, which

00:28:52.150 --> 00:28:55.930
is that, if all we know
is that something changed

00:28:55.930 --> 00:28:59.370
in the adapter and here's the
new state, like with ListView,

00:28:59.370 --> 00:29:02.900
then how do we really tell the
difference between an item that

00:29:02.900 --> 00:29:07.080
was removed from the adapter
after this versus an item that

00:29:07.080 --> 00:29:10.541
just was knocked off screen
and is no longer there.

00:29:10.541 --> 00:29:12.790
When we're putting together
these sorts of animations,

00:29:12.790 --> 00:29:14.710
this is suddenly
really important.

00:29:14.710 --> 00:29:17.680
Similarly, how do we know
something came on screen

00:29:17.680 --> 00:29:20.010
because other things
moved around it,

00:29:20.010 --> 00:29:22.970
or if it's actually a new
item in the adapter itself.

00:29:22.970 --> 00:29:24.910
Again, without there
being a representation

00:29:24.910 --> 00:29:29.030
of those views attached to
the parents from the outset,

00:29:29.030 --> 00:29:31.490
we don't necessarily know.

00:29:31.490 --> 00:29:35.780
So we can do better,
because now we know this.

00:29:35.780 --> 00:29:37.730
We know that
conceptually-- again,

00:29:37.730 --> 00:29:39.670
coming back to this
smoke and mirrors analogy

00:29:39.670 --> 00:29:43.560
from before, even though we only
have a certain number of items

00:29:43.560 --> 00:29:45.800
attached to the view
group at a time,

00:29:45.800 --> 00:29:49.310
conceptually we have a lot
of items that come before

00:29:49.310 --> 00:29:52.830
and after what's
being shown on screen.

00:29:52.830 --> 00:29:55.210
So we can get a little
bit predictive about this

00:29:55.210 --> 00:29:56.670
if we're willing
to ask the adapter

00:29:56.670 --> 00:29:59.630
some additional questions, and
specifically in conjunction

00:29:59.630 --> 00:30:02.380
with the Layout Manager.

00:30:02.380 --> 00:30:05.030
So as we add this
item here and we

00:30:05.030 --> 00:30:08.240
have to delete K,
in this case, we

00:30:08.240 --> 00:30:11.220
know that K is still present
if the adapter hasn't told us

00:30:11.220 --> 00:30:12.500
that it's now gone.

00:30:12.500 --> 00:30:14.890
So we know that it's just
sliding offscreen instead.

00:30:17.570 --> 00:30:20.680
Similarly, with removal,
we can use the same trick.

00:30:20.680 --> 00:30:22.850
We can ask the
Layout Manager, hey,

00:30:22.850 --> 00:30:25.390
show some stuff
around what I'm doing

00:30:25.390 --> 00:30:27.220
so that I have the
added context to be

00:30:27.220 --> 00:30:29.799
able to take the diff of
the before and after states

00:30:29.799 --> 00:30:30.840
and animate it correctly.

00:30:35.558 --> 00:30:37.835
MALE SPEAKER 2: OK. [INAUDIBLE]
speed up a little bit.

00:30:37.835 --> 00:30:38.710
MALE SPEAKER 1: Yeah.

00:30:38.710 --> 00:30:44.250
MALE SPEAKER 2: So the way this
works about the ItemAnimator

00:30:44.250 --> 00:30:46.830
is the predictive animations
is that RecyclerView

00:30:46.830 --> 00:30:51.780
can show a view of the
adapter in the past.

00:30:51.780 --> 00:30:53.480
So how we can do
is like, you know,

00:30:53.480 --> 00:30:56.220
if you have added new
items to the adapter,

00:30:56.220 --> 00:30:58.920
we don't tell about them
to the Layout Manager,

00:30:58.920 --> 00:31:01.960
because it's like it
always sits in between.

00:31:01.960 --> 00:31:05.540
What we do is we show
a different view.

00:31:05.540 --> 00:31:07.710
For example, before
we implemented that,

00:31:07.710 --> 00:31:10.460
there was a Layout
Manager in ItemAnimator.

00:31:10.460 --> 00:31:11.330
And there's a view.

00:31:11.330 --> 00:31:12.340
And they will always fight.

00:31:12.340 --> 00:31:13.210
No, this view is mine.

00:31:13.210 --> 00:31:14.340
No, no, no, this view is mine.

00:31:14.340 --> 00:31:15.464
Like, I want to animate it.

00:31:15.464 --> 00:31:17.680
But wait, wait, I want
to remove and recycle it.

00:31:17.680 --> 00:31:21.780
So it always gets into
this conflicting cases.

00:31:21.780 --> 00:31:25.226
The way we solved this
was the ChildHelper.

00:31:25.226 --> 00:31:28.210
So when Layout Manager
says hey, like, I

00:31:28.210 --> 00:31:29.860
want to get the
child at the position

00:31:29.860 --> 00:31:31.960
or remove it or do
whatever I want,

00:31:31.960 --> 00:31:34.150
RecyclerView doesn't
call the View group.

00:31:34.150 --> 00:31:36.550
Like, we don't change
the children instantly.

00:31:36.550 --> 00:31:38.420
We instead [INAUDIBLE]
ChildHelper,

00:31:38.420 --> 00:31:41.650
which is the component that
is responsible to create this

00:31:41.650 --> 00:31:45.230
[INAUDIBLE] about the contents.

00:31:45.230 --> 00:31:47.790
And then the
ChildHelper decides,

00:31:47.790 --> 00:31:50.130
OK, Layout Manager
told me to remove it,

00:31:50.130 --> 00:31:52.500
but ItemAnimator told
me to animate it,

00:31:52.500 --> 00:31:55.250
so I'll keep it until
the ItemAnimator is done.

00:31:55.250 --> 00:31:58.050
But we don't want Layout
Managers to get more complex

00:31:58.050 --> 00:32:00.400
trying to understand
about animations,

00:32:00.400 --> 00:32:04.100
so for the Layout Manager they
look like they disappeared,

00:32:04.100 --> 00:32:06.730
but they're actually real
children in the View group.

00:32:09.460 --> 00:32:12.810
So ChildHelper is responsible
to provide a virtual list

00:32:12.810 --> 00:32:14.490
to the Layout Manager.

00:32:14.490 --> 00:32:17.170
So for example, let's
assume this view has

00:32:17.170 --> 00:32:19.890
been swiped-- has been removed.

00:32:19.890 --> 00:32:22.860
So while you're on the
Remove Animations at that 200

00:32:22.860 --> 00:32:25.900
milliseconds, if that
Layout Manager tries

00:32:25.900 --> 00:32:28.160
to get the child at
the third position,

00:32:28.160 --> 00:32:30.830
it's going to return Barcelona.

00:32:30.830 --> 00:32:33.880
And if the RecyclerView is-- if
you try to get the RecyclerView

00:32:33.880 --> 00:32:35.740
[INAUDIBLE] child, [INAUDIBLE].

00:32:35.740 --> 00:32:37.780
So the [INAUDIBLE]
between these components

00:32:37.780 --> 00:32:40.820
helps us do these kind
of tricks without making

00:32:40.820 --> 00:32:43.932
these components complex.

00:32:43.932 --> 00:32:45.635
And when the
animation is complete,

00:32:45.635 --> 00:32:48.880
they will start
returning the same value.

00:32:48.880 --> 00:32:53.290
AdapterHelper is the same thing,
but doing the same abstraction

00:32:53.290 --> 00:32:55.000
towards the adapter.

00:32:55.000 --> 00:32:57.640
So when you're like, have
the adapter [INAUDIBLE]

00:32:57.640 --> 00:33:00.450
send all these [INAUDIBLE]
a bunch of things

00:33:00.450 --> 00:33:01.580
happening in the list.

00:33:01.580 --> 00:33:04.200
And Recycler is like,
what's going on.

00:33:04.200 --> 00:33:06.480
I have no idea what's
happening there.

00:33:06.480 --> 00:33:08.990
It's very hard for Layout
Manager to track these things,

00:33:08.990 --> 00:33:13.100
because it's already
busy tracking the UI.

00:33:13.100 --> 00:33:15.640
So AdapterHelper
is to the rescue.

00:33:15.640 --> 00:33:17.940
So when you say
notifyItemInserted

00:33:17.940 --> 00:33:21.255
in the adapter, we record
it and we request a layout.

00:33:21.255 --> 00:33:22.380
We know something happened.

00:33:22.380 --> 00:33:23.320
We need to redraw.

00:33:23.320 --> 00:33:24.400
That's it.

00:33:24.400 --> 00:33:27.560
The only thing we do is we
keep the information about it.

00:33:27.560 --> 00:33:30.070
And now, as you add
more [INAUDIBLE],

00:33:30.070 --> 00:33:33.200
we just keep them in a list.

00:33:33.200 --> 00:33:36.640
Let's say, during this
moment, before we recalculate

00:33:36.640 --> 00:33:39.810
the layout but we know the
adapter contents have changed,

00:33:39.810 --> 00:33:41.150
user clicked on a button.

00:33:44.320 --> 00:33:46.270
And you wanted to get an item.

00:33:46.270 --> 00:33:49.040
You called getAdapterPosition
for the item

00:33:49.040 --> 00:33:51.860
at 59, which was clicked.

00:33:51.860 --> 00:33:55.490
But we know there's a new
item, added at index 55,

00:33:55.490 --> 00:33:57.790
so we know that in
the adapter, there's

00:33:57.790 --> 00:33:59.370
actually at position 60.

00:33:59.370 --> 00:34:00.450
So we return you 60.

00:34:00.450 --> 00:34:03.470
So [INAUDIBLE] not
recalculated, if you

00:34:03.470 --> 00:34:06.730
need the adapter positioned to
go access your adapter items,

00:34:06.730 --> 00:34:08.345
we can provide you
the right position.

00:34:11.239 --> 00:34:14.130
So this simply
happens by checking

00:34:14.130 --> 00:34:17.469
what you told us before.

00:34:17.469 --> 00:34:21.300
And let's say you
send more updates.

00:34:21.300 --> 00:34:23.330
And then we will
go through them.

00:34:23.330 --> 00:34:26.469
The RequestLayout will
be honored by the system.

00:34:26.469 --> 00:34:29.670
We will start preparing
the new layout.

00:34:29.670 --> 00:34:31.830
And at this time,
the adapter is going

00:34:31.830 --> 00:34:36.050
to provide the Layout Manager
the [INAUDIBLE] positions.

00:34:36.050 --> 00:34:37.300
So how does it work?

00:34:37.300 --> 00:34:39.370
What we do is, when
I talk about, like,

00:34:39.370 --> 00:34:45.320
faking the adapter contents, is
we reorder your updates first.

00:34:45.320 --> 00:34:46.989
So the idea is
that everything we

00:34:46.989 --> 00:34:49.050
have to tell to the
Layout Manager first,

00:34:49.050 --> 00:34:50.380
we tell about them.

00:34:50.380 --> 00:34:51.889
We let it do the
predictive layout.

00:34:51.889 --> 00:34:55.929
And then everything else
we tell about them later.

00:34:55.929 --> 00:34:59.550
So if you look at you
removed two items from 61,

00:34:59.550 --> 00:35:03.330
we know that was
61 we reordered.

00:35:03.330 --> 00:35:05.720
[? When ?] we look at
this, OK, I actually

00:35:05.720 --> 00:35:07.160
have the item for 60.

00:35:07.160 --> 00:35:10.390
So even though it is removed,
when the Layout Manager is

00:35:10.390 --> 00:35:12.700
recalculating the
previous state, which

00:35:12.700 --> 00:35:14.680
is part of predictive
animations,

00:35:14.680 --> 00:35:17.750
if it asks for item
60, I can provide it.

00:35:17.750 --> 00:35:19.290
So I don't need
to tell the Layout

00:35:19.290 --> 00:35:23.630
Manager that that item has
been deleted from the adapter.

00:35:23.630 --> 00:35:25.954
But item 61, I don't have it.

00:35:25.954 --> 00:35:28.370
So what I do is I divide that
[? remove ?] [? operation ?]

00:35:28.370 --> 00:35:29.290
into two.

00:35:29.290 --> 00:35:30.890
I tell the Layout
Manager, hey, like,

00:35:30.890 --> 00:35:34.410
before you calculate the
layout, the item 61 is gone,

00:35:34.410 --> 00:35:36.090
just to let you know.

00:35:36.090 --> 00:35:38.950
It does the pre-layout, goes
to the post-layout phase.

00:35:38.950 --> 00:35:42.200
Then we tell about these things,
like this fine-grained adapter

00:35:42.200 --> 00:35:46.740
updates tells, like, enables
us to fake the adapter content

00:35:46.740 --> 00:35:49.510
source layout manager
so that all it has to do

00:35:49.510 --> 00:35:52.020
is we ask it to lay
out twice, and then we

00:35:52.020 --> 00:35:54.350
predict all the rest
of the animations.

00:35:54.350 --> 00:35:56.380
So Layout Manager
almost doesn't need

00:35:56.380 --> 00:35:57.920
to know anything about that.

00:36:00.120 --> 00:36:00.620
OK.

00:36:00.620 --> 00:36:01.786
MALE SPEAKER 1: All right.

00:36:01.786 --> 00:36:03.660
We'll try and move some
of the-- through some

00:36:03.660 --> 00:36:05.868
of the other features here
a little bit more quickly.

00:36:05.868 --> 00:36:07.660
So, ItemDecorations.

00:36:07.660 --> 00:36:10.680
ListView has the ability, like
many other one-off features

00:36:10.680 --> 00:36:13.139
in ListView, to draw
dividers between items.

00:36:13.139 --> 00:36:15.680
And so we needed to make sure
that this sort of functionality

00:36:15.680 --> 00:36:16.960
was still preserved.

00:36:16.960 --> 00:36:19.110
So ItemDecorations
allow you to do

00:36:19.110 --> 00:36:21.555
custom drawing on the
RecyclerView's canvas itself.

00:36:21.555 --> 00:36:23.930
So this is in the context of
the RecyclerView, the parent

00:36:23.930 --> 00:36:26.210
of all your child items,
not necessarily just

00:36:26.210 --> 00:36:28.440
individual items within it.

00:36:28.440 --> 00:36:30.730
We could also go ahead and
add offsets to view bounds.

00:36:30.730 --> 00:36:32.772
Again, using the simple
test case of the divider,

00:36:32.772 --> 00:36:34.729
you need to make sure
that you have that couple

00:36:34.729 --> 00:36:36.810
pixels of space that the
divider consumes itself,

00:36:36.810 --> 00:36:41.310
rather than drawing necessarily
over or under the items views.

00:36:41.310 --> 00:36:43.390
And you can also have
multiple ItemDecorations.

00:36:43.390 --> 00:36:44.370
They stack.

00:36:44.370 --> 00:36:48.410
So these ItemDecorations
can affect views, again,

00:36:48.410 --> 00:36:51.310
in sort of a stack-like manner.

00:36:51.310 --> 00:36:52.320
ItemDecorations.

00:36:52.320 --> 00:36:58.980
So we can draw items
over our list items here.

00:36:58.980 --> 00:37:00.185
[INAUDIBLE] come on.

00:37:05.140 --> 00:37:05.780
All right.

00:37:05.780 --> 00:37:07.620
So another kind
of important thing

00:37:07.620 --> 00:37:09.140
here is the getItemOffsets.

00:37:09.140 --> 00:37:12.370
This is really what lets us add
space around particular items.

00:37:12.370 --> 00:37:15.000
So this can be nice if you're
doing some sort of card

00:37:15.000 --> 00:37:17.260
background around
several items at once,

00:37:17.260 --> 00:37:19.560
so like a grouping of some sort.

00:37:19.560 --> 00:37:22.830
But you can also do it
just on single items, too.

00:37:22.830 --> 00:37:25.270
So we can expand the space
around a particular item,

00:37:25.270 --> 00:37:27.645
because maybe that's an area
that we're going to draw in.

00:37:34.780 --> 00:37:38.422
So we get onDraw, which we'll
draw underneath the item views

00:37:38.422 --> 00:37:40.505
before we actually draw
the item views themselves.

00:37:44.140 --> 00:37:47.470
Which is then followed
by the items themselves.

00:37:47.470 --> 00:37:49.310
And then we get
onDrawOver, which

00:37:49.310 --> 00:37:52.960
allows us a chance to draw
on top of the item views,

00:37:52.960 --> 00:37:56.087
in case that becomes relevant
in your particular situation.

00:37:56.087 --> 00:37:58.670
So in this case, we're doing--
we're just otherwise decorating

00:37:58.670 --> 00:38:00.490
these things.

00:38:00.490 --> 00:38:03.260
So you need to be kind of
careful about ItemDecorations,

00:38:03.260 --> 00:38:06.717
though, because this
drawing phase here

00:38:06.717 --> 00:38:08.800
might be in the middle of
several other operations

00:38:08.800 --> 00:38:10.133
that RecyclerView view is doing.

00:38:10.133 --> 00:38:11.650
And as [INAUDIBLE]
just detailed,

00:38:11.650 --> 00:38:13.660
there are a lot of
things that RecyclerView

00:38:13.660 --> 00:38:16.880
does to sort of try and present
a consistent view of the world

00:38:16.880 --> 00:38:18.940
to adapters versus
the Layout Managers

00:38:18.940 --> 00:38:21.400
who are doing animations
and so on and so forth.

00:38:21.400 --> 00:38:23.280
So the adapter's
view of the world

00:38:23.280 --> 00:38:25.506
may not be what you're
seeing on screen right then.

00:38:25.506 --> 00:38:26.880
So you want to
make sure that you

00:38:26.880 --> 00:38:30.200
don't use the ItemDecorations
to access the adapter.

00:38:30.200 --> 00:38:32.120
Keep the necessary
information about things

00:38:32.120 --> 00:38:34.670
you need to draw in
the ViewHolder itself.

00:38:34.670 --> 00:38:37.250
The ItemDecoration can
access the ViewHolder at will

00:38:37.250 --> 00:38:40.430
because the ViewHolder is data
about what's being displayed

00:38:40.430 --> 00:38:43.020
on screen right now.

00:38:43.020 --> 00:38:46.280
And again, the general
rules around drawing apply.

00:38:46.280 --> 00:38:47.610
This is a pretty hot code path.

00:38:47.610 --> 00:38:49.970
Ideally, this is being
called 60 frames per second,

00:38:49.970 --> 00:38:51.520
if everything's going right.

00:38:51.520 --> 00:38:54.750
So try not to allocate memory,
do anything too expensive,

00:38:54.750 --> 00:38:56.232
so on and so forth.

00:38:56.232 --> 00:38:57.690
You can always go
ahead and use the

00:38:57.690 --> 00:38:59.960
recyclerView.getChildViewHolder
method

00:38:59.960 --> 00:39:02.710
to get the ViewHolder for a
particular ChildView that's

00:39:02.710 --> 00:39:06.170
attached to the
RecyclerView at the time.

00:39:06.170 --> 00:39:08.030
So the RecycledViewPool
is another component

00:39:08.030 --> 00:39:09.740
that's kind of
important to know about,

00:39:09.740 --> 00:39:12.680
if only because it allows you
to pull some pretty neat tricks,

00:39:12.680 --> 00:39:15.350
depending on the type of
UI that you're creating.

00:39:15.350 --> 00:39:17.300
So the Recycled View
Pool would normally just

00:39:17.300 --> 00:39:18.929
be an internal
implementation detail

00:39:18.929 --> 00:39:20.470
where we're holding
extra ViewHolders

00:39:20.470 --> 00:39:22.880
of the different types
like we mentioned earlier.

00:39:22.880 --> 00:39:25.290
But the cool thing about
the RecycledViewPool

00:39:25.290 --> 00:39:27.759
is that you can share it
between multiple RecyclerViews,

00:39:27.759 --> 00:39:29.300
or even just other
custom view groups

00:39:29.300 --> 00:39:31.966
that you've written that need to
do some similar operations that

00:39:31.966 --> 00:39:34.160
need uniform views of this type.

00:39:36.760 --> 00:39:39.520
Again, always make sure
that you keep these scopes

00:39:39.520 --> 00:39:40.629
to a single activity.

00:39:40.629 --> 00:39:41.920
These things are holding views.

00:39:41.920 --> 00:39:43.270
Views hold onto a context.

00:39:43.270 --> 00:39:45.530
Contexts were inflated
with your activity,

00:39:45.530 --> 00:39:47.380
and you can get
yourself into trouble

00:39:47.380 --> 00:39:50.760
if you end up leaking those
activity contexts by accident.

00:39:50.760 --> 00:39:52.180
So make sure that
these are scoped

00:39:52.180 --> 00:39:54.250
to a single activity, at most.

00:39:54.250 --> 00:39:57.510
But you see UIs like this in
terms of the Android Leanback

00:39:57.510 --> 00:39:59.390
Library for Android TV.

00:39:59.390 --> 00:40:03.100
You have multiple rows that
are actually RecyclerViews

00:40:03.100 --> 00:40:04.880
held within RecyclerViews.

00:40:04.880 --> 00:40:08.350
But the innermost child items
are all of a uniform type.

00:40:08.350 --> 00:40:10.830
So what we do there is we can
share the RecycledViewPool

00:40:10.830 --> 00:40:13.500
across all of these
individual rows.

00:40:13.500 --> 00:40:15.370
And this allows us
to be much, much

00:40:15.370 --> 00:40:17.372
more efficient in terms
of how we allocate those

00:40:17.372 --> 00:40:18.330
and manage those pools.

00:40:22.695 --> 00:40:24.570
MALE SPEAKER 2: OK.

00:40:24.570 --> 00:40:27.505
So as we start
adding more functions

00:40:27.505 --> 00:40:29.970
to RecyclerView, what we
tried to implement them

00:40:29.970 --> 00:40:31.654
as components.

00:40:31.654 --> 00:40:33.820
So [INAUDIBLE] Drag &amp; Drop,
if you look at ListView,

00:40:33.820 --> 00:40:36.070
there is like a
bunch of libraries.

00:40:36.070 --> 00:40:37.450
You need to look
at the examples.

00:40:37.450 --> 00:40:39.610
And only some of them
work for your use case.

00:40:39.610 --> 00:40:42.640
So we wanted to learn
over from our mistakes.

00:40:42.640 --> 00:40:44.290
When we designed
ItemTouchHelper,

00:40:44.290 --> 00:40:47.690
we wanted it to be
independent of the layout.

00:40:47.690 --> 00:40:50.550
So want to use ItemTouchHelper,
it can do Drag &amp; Drop,

00:40:50.550 --> 00:40:53.010
it can do Swipe to Dismiss.

00:40:53.010 --> 00:40:57.210
And all you do is you
provide this callback class.

00:40:57.210 --> 00:41:01.530
In the callback class,
[INAUDIBLE] getMovementFlags.

00:41:01.530 --> 00:41:02.280
This is the idea.

00:41:02.280 --> 00:41:03.680
I have a ViewHolder.

00:41:03.680 --> 00:41:06.390
How can I move this
View Holder [INAUDIBLE]

00:41:06.390 --> 00:41:09.760
up and down or left and right.

00:41:09.760 --> 00:41:14.280
And you could say as what should
I do when the item is moved.

00:41:14.280 --> 00:41:18.150
So let's say the user
moved it to somewhere else,

00:41:18.150 --> 00:41:20.760
and then now you need
to change the adapter.

00:41:20.760 --> 00:41:21.650
Similar swipe.

00:41:21.650 --> 00:41:23.270
The user is swiping
to the right.

00:41:23.270 --> 00:41:25.280
When it is done, we
will let you know.

00:41:25.280 --> 00:41:29.770
So all you have to do is tell us
how a ViewHolder can be moved.

00:41:29.770 --> 00:41:33.200
Tell-- actually do what you
need to change in your adapter

00:41:33.200 --> 00:41:35.032
when it is moved or swiped.

00:41:38.970 --> 00:41:43.340
So you can actually run Drag &amp;
Drop and Swipe at the same time

00:41:43.340 --> 00:41:44.490
in the same Layout Manager.

00:41:44.490 --> 00:41:45.270
It just works.

00:41:49.310 --> 00:41:50.950
So this is a getMovementFlags.

00:41:50.950 --> 00:41:52.500
We provide [INAUDIBLE] Flags.

00:41:52.500 --> 00:41:54.870
So in this example,
I say, each item

00:41:54.870 --> 00:41:57.530
can be moved--
dragged up and down,

00:41:57.530 --> 00:41:59.350
and you can swipe
it towards then end.

00:41:59.350 --> 00:42:00.565
So it also supports RTF.

00:42:03.255 --> 00:42:05.820
[INAUDIBLE] if you say
[? and, ?] your callbacks will

00:42:05.820 --> 00:42:08.781
receive the same things, like an
RTL parameters if you use left

00:42:08.781 --> 00:42:11.280
and [? right, ?] your callbacks
will receive left and right.

00:42:14.550 --> 00:42:17.630
So you can also customize
how it is drawn. [INAUDIBLE]

00:42:17.630 --> 00:42:20.440
[? demos, ?] we have the sample
like you can make it fade away

00:42:20.440 --> 00:42:21.670
as you swipe.

00:42:21.670 --> 00:42:25.360
You just [? override ?]
[INAUDIBLE] in the callback.

00:42:25.360 --> 00:42:28.860
And you can also start the
Drag &amp; Drop or Swipe yourself.

00:42:28.860 --> 00:42:30.460
Maybe you have a
custom button there.

00:42:30.460 --> 00:42:33.960
Try to go a little bit faster.

00:42:33.960 --> 00:42:34.820
OK.

00:42:34.820 --> 00:42:36.475
We'll go through
some tips and tricks.

00:42:36.475 --> 00:42:37.350
MALE SPEAKER 1: Yeah.

00:42:37.350 --> 00:42:38.830
Really quick here.

00:42:38.830 --> 00:42:40.825
So again, as we
talked about before,

00:42:40.825 --> 00:42:43.200
we wanted to be more efficient
with RecyclerView adapters

00:42:43.200 --> 00:42:44.830
than we were with
ListView adapters.

00:42:44.830 --> 00:42:46.809
So if you don't update
a particular item,

00:42:46.809 --> 00:42:48.600
you don't get onBind
for that item anymore.

00:42:48.600 --> 00:42:50.433
We're able to just reuse
that view in place.

00:42:54.130 --> 00:42:56.324
So even move
operations, we don't

00:42:56.324 --> 00:42:58.740
have to go back to the adapter
to ask for that data again,

00:42:58.740 --> 00:43:00.270
because, hey, it hasn't changed.

00:43:00.270 --> 00:43:02.990
Why should we do the extra work?

00:43:02.990 --> 00:43:04.990
So we don't get an
invalidate on that view.

00:43:04.990 --> 00:43:07.320
We make sure that cache works.

00:43:07.320 --> 00:43:09.900
We have happy kittens.

00:43:09.900 --> 00:43:12.210
And then what that
means, though,

00:43:12.210 --> 00:43:15.400
as a side effect is that, since
items can be added or removed

00:43:15.400 --> 00:43:18.629
around it and items can move,
when you bind your views,

00:43:18.629 --> 00:43:20.670
don't make assumptions
that the position that you

00:43:20.670 --> 00:43:22.730
were initially
bound for is always

00:43:22.730 --> 00:43:24.950
going to be the position
corresponding to that data

00:43:24.950 --> 00:43:27.340
item.

00:43:27.340 --> 00:43:31.860
Again, this is a perfect example
of what can end up going wrong.

00:43:31.860 --> 00:43:35.520
You want to make sure that
you access the position live

00:43:35.520 --> 00:43:37.520
from the ViewHolder itself.

00:43:37.520 --> 00:43:40.990
The ViewHolder knows
what's going on there.

00:43:40.990 --> 00:43:43.830
In this case, yeah, there we go.

00:43:43.830 --> 00:43:46.380
The ViewHolder knows what the
adapter position is right now.

00:43:46.380 --> 00:43:48.270
So we make sure and keep
that updated for you

00:43:48.270 --> 00:43:49.740
so that you don't have
to track it yourself.

00:43:49.740 --> 00:43:51.448
But make sure that
you don't accidentally

00:43:51.448 --> 00:43:55.672
close over the value of the
adapter position by accident.

00:43:55.672 --> 00:43:57.450
MALE SPEAKER 2: By the
way, Android Studio

00:43:57.450 --> 00:44:00.443
has [INAUDIBLE] now, so it
will not let you do that.

00:44:00.443 --> 00:44:04.550
But so use
itemChangeWithPayload.

00:44:04.550 --> 00:44:07.390
So when an item changes, like
the time change or a user

00:44:07.390 --> 00:44:09.600
liked it, use it
with the payload.

00:44:09.600 --> 00:44:11.870
It will make your onBind
a lot more efficient.

00:44:11.870 --> 00:44:14.557
You can run better animations.

00:44:14.557 --> 00:44:17.140
So in the onBind method, you can
just check if you [INAUDIBLE]

00:44:17.140 --> 00:44:19.290
payloads.

00:44:19.290 --> 00:44:22.220
So if there's no payloads,
[INAUDIBLE] ViewHolder.

00:44:22.220 --> 00:44:25.320
If there's payloads, we
guarantee that the ViewHolder

00:44:25.320 --> 00:44:27.560
is being reused
for that position

00:44:27.560 --> 00:44:29.400
so you don't have
to set everything.

00:44:29.400 --> 00:44:32.670
You only set what has changed,
and you know that information

00:44:32.670 --> 00:44:33.720
from the payload.

00:44:33.720 --> 00:44:34.710
It's very efficient.

00:44:34.710 --> 00:44:36.879
It's great for animations.

00:44:36.879 --> 00:44:39.420
Another mistake we see commonly,
like you have a header view.

00:44:39.420 --> 00:44:42.550
When we ask for the header
view, you return the same one.

00:44:42.550 --> 00:44:43.760
Don't do it.

00:44:43.760 --> 00:44:47.080
If you called onCreate, that
means create a new ViewHolder.

00:44:47.080 --> 00:44:49.830
Don't try to return us the
same [INAUDIBLE] you have,

00:44:49.830 --> 00:44:51.895
because you will have bugs.

00:44:51.895 --> 00:44:55.420
[? We ?] wouldn't call that
method if we didn't need it.

00:44:55.420 --> 00:44:58.320
[INAUDIBLE] something like this.

00:44:58.320 --> 00:45:02.920
If it asks for you to
create, create a new one.

00:45:02.920 --> 00:45:05.100
Adapter versus layout
positions is something

00:45:05.100 --> 00:45:06.950
we previously mentioned.

00:45:06.950 --> 00:45:10.910
But [? a ?] [? view-- ?]
let's say you moved an item.

00:45:10.910 --> 00:45:14.890
At this point, you can
see the adapter positions

00:45:14.890 --> 00:45:16.640
and layout positions
of some items

00:45:16.640 --> 00:45:18.940
are different until
the next layout is

00:45:18.940 --> 00:45:22.380
calculated, because they are
also calculated asynchronously.

00:45:22.380 --> 00:45:24.750
So once the [? View ?]
[? system ?] tells us, OK,

00:45:24.750 --> 00:45:27.675
you can refresh [INAUDIBLE]
[? refresh ?] [? it, ?] now all

00:45:27.675 --> 00:45:30.610
of the items have the same
layout position and adapter

00:45:30.610 --> 00:45:31.360
position.

00:45:31.360 --> 00:45:33.480
So adapter's position
is very good if you

00:45:33.480 --> 00:45:36.700
need to access your data, layout
position is very good if you

00:45:36.700 --> 00:45:39.106
want to know what is above
and below at the point

00:45:39.106 --> 00:45:40.480
[? when ?] user
clicks something.

00:45:40.480 --> 00:45:42.620
MALE SPEAKER 1: All right.

00:45:42.620 --> 00:45:44.107
And I think that's it.

00:45:44.107 --> 00:45:45.190
MALE SPEAKER 2: Thank you.

00:45:45.190 --> 00:45:45.790
Yes.

00:45:45.790 --> 00:45:48.190
[APPLAUSE]

00:45:54.190 --> 00:45:57.840
[MUSIC PLAYING]

