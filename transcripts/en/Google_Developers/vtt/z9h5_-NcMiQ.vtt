WEBVTT
Kind: captions
Language: en

00:00:10.370 --> 00:00:12.230
PETER LUBBERS: Welcome to
"Google Developers Live" here

00:00:12.230 --> 00:00:13.740
on the Chrome channel.

00:00:13.740 --> 00:00:16.270
And today we have a really
exciting episode of a new

00:00:16.270 --> 00:00:23.430
series, "Ask the Author," where
new book authors explain

00:00:23.430 --> 00:00:25.740
about their book and the new,
exciting technologies they're

00:00:25.740 --> 00:00:26.410
talking about.

00:00:26.410 --> 00:00:31.550
So with me I have talking about
"The Definitive Guide to

00:00:31.550 --> 00:00:35.000
HTML5 WebSocket," I have the
three authors that wrote it,

00:00:35.000 --> 00:00:37.160
starting with the first one,
Vanessa, Vanessa Wang.

00:00:37.160 --> 00:00:38.190
Welcome.

00:00:38.190 --> 00:00:38.860
VANESSA WANG: Thanks, Peter.

00:00:38.860 --> 00:00:39.900
I'm Vanessa Wang.

00:00:39.900 --> 00:00:41.540
I'm one of the authors
of the book.

00:00:41.540 --> 00:00:44.605
I'm currently manager of
technical publications at

00:00:44.605 --> 00:00:47.730
Kaazing, which is a start-up
in Mountain View, where I

00:00:47.730 --> 00:00:51.260
write documentation for our
WebSocket platform.

00:00:51.260 --> 00:00:51.590
PETER LUBBERS: Great.

00:00:51.590 --> 00:00:52.920
And Peter Moskovits.

00:00:52.920 --> 00:00:54.660
PETER MOSKOVITS:
Hi, I am Peter.

00:00:54.660 --> 00:00:58.070
And I head up real-time
solutions at Kaazing.

00:00:58.070 --> 00:01:00.240
And I work very closely
with the developer

00:01:00.240 --> 00:01:01.400
community out there.

00:01:01.400 --> 00:01:01.780
PETER LUBBERS: Great.

00:01:01.780 --> 00:01:03.140
And Frank, Frank Salim.

00:01:03.140 --> 00:01:03.970
FRANK SALIM: I'm Frank.

00:01:03.970 --> 00:01:06.390
I am a software engineer
at Google and I

00:01:06.390 --> 00:01:07.650
used to work at Kaazing.

00:01:07.650 --> 00:01:09.130
PETER LUBBERS: Full disclosure,
I also used to

00:01:09.130 --> 00:01:10.660
work at Kaazing, so it feels
like a little bit

00:01:10.660 --> 00:01:12.990
of a reunion here.

00:01:12.990 --> 00:01:18.650
So tell us a little about
the book in general.

00:01:18.650 --> 00:01:21.610
What can we expect to find
in the book, Vanessa?

00:01:21.610 --> 00:01:23.440
VANESSA WANG: We started off the
book with a little history

00:01:23.440 --> 00:01:25.630
of why WebSocket.

00:01:25.630 --> 00:01:27.960
And then we go into the
API and protocol.

00:01:27.960 --> 00:01:30.760
So the standard is comprised of
the WebSocket protocol, the

00:01:30.760 --> 00:01:33.350
communication protocol,
and the API that

00:01:33.350 --> 00:01:34.750
interfaces with it.

00:01:34.750 --> 00:01:37.590
And then we deep dive into three
hands-on examples of how

00:01:37.590 --> 00:01:41.640
to use WebSocket with higher
level protocols, such as XMPP,

00:01:41.640 --> 00:01:47.060
which is a chat application, and
STOMP for pub/sub and VNC,

00:01:47.060 --> 00:01:49.130
which is a binary protocol.

00:01:49.130 --> 00:01:51.000
We also go into some of the
security and deployment

00:01:51.000 --> 00:01:52.000
considerations at the end.

00:01:52.000 --> 00:01:53.540
PETER LUBBERS: Great.

00:01:53.540 --> 00:01:53.720
Yeah.

00:01:53.720 --> 00:01:56.530
I saw a great appendix as
well on how to debug it.

00:01:56.530 --> 00:01:58.300
And we'll get back
to that as well.

00:01:58.300 --> 00:02:01.210
So why did you think--

00:02:01.210 --> 00:02:04.260
when you started writing the
book, Peter, what prompted you

00:02:04.260 --> 00:02:06.040
to do that?

00:02:06.040 --> 00:02:08.889
Why was it a good time
to [INAUDIBLE]?

00:02:08.889 --> 00:02:12.610
PETER MOSKOVITS: It was a long
time until WebSocket became a

00:02:12.610 --> 00:02:14.670
ratified standard.

00:02:14.670 --> 00:02:18.260
In December, 2011,
it was accepted.

00:02:18.260 --> 00:02:20.370
RFC is out there.

00:02:20.370 --> 00:02:25.820
And we felt that there's a need
to share the experience

00:02:25.820 --> 00:02:28.240
that we have gathered
at Kaazing.

00:02:28.240 --> 00:02:32.760
We started it over 4, 4 and
1/2 years ago there.

00:02:32.760 --> 00:02:36.050
And we wanted to share so
that people can get

00:02:36.050 --> 00:02:38.316
started and use it.

00:02:38.316 --> 00:02:38.730
PETER LUBBERS: Great.

00:02:38.730 --> 00:02:38.960
All right.

00:02:38.960 --> 00:02:42.460
So maybe just for everyone
that's watching and has

00:02:42.460 --> 00:02:47.680
questions about WebSocket, by
the way, on the YouTube

00:02:47.680 --> 00:02:51.710
channel we have a link to the
questions, the moderator.

00:02:51.710 --> 00:02:53.030
So we have a moderator
where you can

00:02:53.030 --> 00:02:56.320
vote and ask questions.

00:02:56.320 --> 00:02:57.040
Definitely use that.

00:02:57.040 --> 00:02:58.830
We're going to get back to those
questions at the end of

00:02:58.830 --> 00:02:59.680
this program.

00:02:59.680 --> 00:03:02.320
And for now we'll talk a little
bit more about this.

00:03:02.320 --> 00:03:08.980
So what are some of the core
concepts, before we dive too

00:03:08.980 --> 00:03:10.150
deep into it.

00:03:10.150 --> 00:03:11.806
What is WebSocket?

00:03:11.806 --> 00:03:14.590
Maybe for those of you
that don't know.

00:03:14.590 --> 00:03:15.400
PETER MOSKOVITS: Maybe
I will take that.

00:03:15.400 --> 00:03:17.690
And then others can chime in.

00:03:17.690 --> 00:03:21.870
WebSocket allows you to have
a full duplex always-on

00:03:21.870 --> 00:03:23.810
connection between your browser

00:03:23.810 --> 00:03:25.430
and a WebSocket server.

00:03:25.430 --> 00:03:29.640
And it allows you to build
applications that we've been

00:03:29.640 --> 00:03:32.040
trying to build for
a long time.

00:03:32.040 --> 00:03:35.340
When we first moved to the web,
initially it was around

00:03:35.340 --> 00:03:38.220
static and then later on dynamic
documents, getting

00:03:38.220 --> 00:03:39.325
these documents into
the browser.

00:03:39.325 --> 00:03:42.590
And the browser was used
in a pretty dumb way.

00:03:42.590 --> 00:03:45.580
And then as a browsers evolved
and JavaScript engines became

00:03:45.580 --> 00:03:49.460
more powerful, clearly we could
start moving some of the

00:03:49.460 --> 00:03:51.560
business logic that was running
on the application

00:03:51.560 --> 00:03:54.570
servers and the middlewares
over to the browser.

00:03:54.570 --> 00:03:58.960
And around the same time, it
was clear that we needed a

00:03:58.960 --> 00:04:01.760
better way to connect these
applications that are running

00:04:01.760 --> 00:04:02.600
in the browser.

00:04:02.600 --> 00:04:05.610
And WebSocket addresses that.

00:04:05.610 --> 00:04:09.280
And not only does it have
this very low latency

00:04:09.280 --> 00:04:13.440
communication, it's also
designed to be web-friendly.

00:04:13.440 --> 00:04:16.360
I mean, we can talk about this
a little bit later on.

00:04:16.360 --> 00:04:21.310
But the whole idea that with
HTML5 basically applications

00:04:21.310 --> 00:04:23.750
running natively in the browser
without the need of

00:04:23.750 --> 00:04:26.340
extra plug-ins and extra
extensions, it

00:04:26.340 --> 00:04:28.640
can become very powerful.

00:04:28.640 --> 00:04:28.920
PETER LUBBERS: Right.

00:04:28.920 --> 00:04:30.700
For example, Flash has
a socket, right?

00:04:30.700 --> 00:04:32.570
I think there was a question
about that on the moderator

00:04:32.570 --> 00:04:33.550
we'll get back to later.

00:04:33.550 --> 00:04:34.010
PETER MOSKOVITS: Exactly.

00:04:34.010 --> 00:04:34.970
Flash has socket.

00:04:34.970 --> 00:04:36.200
Java has socket.

00:04:36.200 --> 00:04:39.690
And doing this whole socket
connection in a

00:04:39.690 --> 00:04:42.100
standards-based way, where
everybody does it the same

00:04:42.100 --> 00:04:45.000
way, and you can assume that it
works across the board and

00:04:45.000 --> 00:04:46.870
how well it works-- again,
I guess we can talk

00:04:46.870 --> 00:04:48.010
about that later on--

00:04:48.010 --> 00:04:52.010
is what makes it really
nice and powerful.

00:04:52.010 --> 00:04:53.020
PETER LUBBERS: Very good.

00:04:53.020 --> 00:04:53.170
Yeah.

00:04:53.170 --> 00:04:55.040
It's very exciting
to see a complete

00:04:55.040 --> 00:04:57.740
book devoted to WebSocket.

00:04:57.740 --> 00:05:01.710
One of the things I liked about
your book was the demo

00:05:01.710 --> 00:05:03.090
VM that you shipped.

00:05:03.090 --> 00:05:06.490
So most books, of course, have
a GitHub repository.

00:05:06.490 --> 00:05:07.410
I believe you have that too.

00:05:07.410 --> 00:05:11.070
But to get started with
WebSocket, of course it

00:05:11.070 --> 00:05:14.360
requires a client, but
also a server.

00:05:14.360 --> 00:05:17.930
And that's maybe different from
other parts of HTML5,

00:05:17.930 --> 00:05:20.340
which is usually sort of
like a client-side API

00:05:20.340 --> 00:05:22.210
and you can use that.

00:05:22.210 --> 00:05:25.590
But for WebSocket, you do need
that other endpoint.

00:05:25.590 --> 00:05:28.750
So tell us a little bit, or
maybe you can demo it.

00:05:28.750 --> 00:05:28.920
PETER MOSKOVITS: Sure.

00:05:28.920 --> 00:05:33.950
Maybe I can give you a quick
idea here on my machine.

00:05:33.950 --> 00:05:36.960
So the first thing that you
mentioned was GitHub.

00:05:36.960 --> 00:05:41.300
If you go to GitHub and you
search for WebSocket book, the

00:05:41.300 --> 00:05:46.860
source code is easily
accessible, grouped by

00:05:46.860 --> 00:05:48.150
chapters here.

00:05:48.150 --> 00:05:53.140
In addition to this, you can
also download a VM along with

00:05:53.140 --> 00:05:55.490
the source code from the
publisher's website.

00:05:55.490 --> 00:05:59.090
So all you need to do is again,
search for WebSocket on

00:05:59.090 --> 00:06:00.340
the Apress site.

00:06:00.340 --> 00:06:02.130
And here you see the book.

00:06:02.130 --> 00:06:06.710
And on the bottom of this page,
there is a Source Code

00:06:06.710 --> 00:06:07.880
and Downloads.

00:06:07.880 --> 00:06:10.700
And this is where you
can download the VM.

00:06:10.700 --> 00:06:11.500
The VM is very

00:06:11.500 --> 00:06:14.175
straightforward, relatively small.

00:06:14.175 --> 00:06:16.180
Its starts up in no time.

00:06:16.180 --> 00:06:20.670
It's a virtual box VM and
has Ubuntu on it.

00:06:20.670 --> 00:06:22.830
PETER LUBBERS: And you just
need a VirtualBox player.

00:06:22.830 --> 00:06:23.430
PETER MOSKOVITS: Yes.

00:06:23.430 --> 00:06:24.690
That's all you need.

00:06:24.690 --> 00:06:28.390
You get VirtualBox and you
can open up the VM.

00:06:28.390 --> 00:06:30.920
PETER LUBBERS: Perfect.

00:06:30.920 --> 00:06:32.060
Cool.

00:06:32.060 --> 00:06:35.470
So can you give a quick
demo of how you would

00:06:35.470 --> 00:06:37.490
start it and use it?

00:06:37.490 --> 00:06:37.660
PETER MOSKOVITS: Sure.

00:06:37.660 --> 00:06:41.020
So actually I have already
started up the VM.

00:06:41.020 --> 00:06:44.470
When you take a look at it here,
you see the chapters out

00:06:44.470 --> 00:06:46.000
there on the desktop.

00:06:46.000 --> 00:06:49.930
There is a readme file that
comes with every chapter.

00:06:49.930 --> 00:06:54.310
So when you open it up, you see
the readme file that gives

00:06:54.310 --> 00:06:58.500
you the steps that are related
to the actual chapter.

00:06:58.500 --> 00:06:59.560
All the source code
is obviously

00:06:59.560 --> 00:07:01.060
included here as well.

00:07:01.060 --> 00:07:05.620
And in addition, we also have
a video that is in every

00:07:05.620 --> 00:07:06.330
folder here.

00:07:06.330 --> 00:07:09.650
So this is a set of screencasts
that walk you

00:07:09.650 --> 00:07:13.910
through the steps of doing
these hands-on kind of

00:07:13.910 --> 00:07:16.310
exercises in this environment,
step by step.

00:07:16.310 --> 00:07:19.030
So it's really easy and really
straightforward.

00:07:19.030 --> 00:07:22.110
Maybe I can quickly start one.

00:07:22.110 --> 00:07:26.640
And just basically this
is the experience.

00:07:26.640 --> 00:07:28.700
VANESSA WANG: One of the
purposes of the VM was really

00:07:28.700 --> 00:07:31.620
just to give different access
points to the code.

00:07:31.620 --> 00:07:34.580
So you can walk through the code
in GitHub, but also if

00:07:34.580 --> 00:07:37.710
you don't really learn that way,
you can just start it up

00:07:37.710 --> 00:07:40.160
on the VM and then walk
backwards following the

00:07:40.160 --> 00:07:43.180
examples in the book, and then
figure out how it was built

00:07:43.180 --> 00:07:44.850
just by looking at the VM.

00:07:44.850 --> 00:07:45.100
PETER LUBBERS: Yeah.

00:07:45.100 --> 00:07:47.680
I like that, because that's
often the problem.

00:07:47.680 --> 00:07:49.540
Sometimes you don't have time
to see the whole thing.

00:07:49.540 --> 00:07:51.770
You can see the finished
solution and

00:07:51.770 --> 00:07:54.260
quickly get to the--

00:07:54.260 --> 00:07:55.550
FRANK SALIM: Without having
to bootstrap a lot of

00:07:55.550 --> 00:07:56.480
environments.

00:07:56.480 --> 00:07:59.150
Each of these chapters might
have a different server that

00:07:59.150 --> 00:08:01.070
comes with it that's
pre-configured in the VM.

00:08:01.070 --> 00:08:02.540
There's a chat server and
a messaging server.

00:08:02.540 --> 00:08:04.220
And they're all in there.

00:08:04.220 --> 00:08:06.160
PETER LUBBERS: It's like
pre-seated servers.

00:08:06.160 --> 00:08:06.970
FRANK SALIM: Right.

00:08:06.970 --> 00:08:08.112
PETER LUBBERS: Awesome.

00:08:08.112 --> 00:08:08.550
Great.

00:08:08.550 --> 00:08:12.510
So we talked a little bit
about what WebSocket is.

00:08:12.510 --> 00:08:16.640
But what are some of the
practical applications today

00:08:16.640 --> 00:08:20.560
that you can accomplish
by using the standard?

00:08:20.560 --> 00:08:22.530
PETER MOSKOVITS: So maybe
I can show a couple.

00:08:22.530 --> 00:08:26.350
And then we can take the
discussion from there.

00:08:26.350 --> 00:08:32.570
The first one is going to be a
demo that we like to call the

00:08:32.570 --> 00:08:33.900
portfolio demo.

00:08:33.900 --> 00:08:37.520
One of the typical use cases for
WebSocket is that you have

00:08:37.520 --> 00:08:40.559
a large amount of data available
on the server.

00:08:40.559 --> 00:08:44.360
And you want to get this data
to a number of clients, to

00:08:44.360 --> 00:08:48.070
typically a large number of
clients, very quickly and then

00:08:48.070 --> 00:08:49.470
basically at real-time.

00:08:49.470 --> 00:08:54.630
And this is one of the demos
that showcases this.

00:08:54.630 --> 00:08:58.650
So what you see here
is imaginary data.

00:08:58.650 --> 00:09:00.305
It's not real market
data, obviously--

00:09:00.305 --> 00:09:02.250
[INTERPOSING VOICES]

00:09:02.250 --> 00:09:04.540
that we are showing here.

00:09:04.540 --> 00:09:09.650
And depending on your network
connection, I saw a bit of a

00:09:09.650 --> 00:09:12.480
stop there, you see
the data come in.

00:09:12.480 --> 00:09:16.660
So one of the things that you
can do is you can open a new

00:09:16.660 --> 00:09:17.760
browser window.

00:09:17.760 --> 00:09:19.970
And this demo is available on
the public internet, so you

00:09:19.970 --> 00:09:22.370
can go to the URL that
you see here.

00:09:22.370 --> 00:09:26.240
And you can run this
demo yourself.

00:09:26.240 --> 00:09:28.010
You can execute--

00:09:28.010 --> 00:09:30.630
basically the data is coming
from the server to the client.

00:09:30.630 --> 00:09:32.670
This is something that's not
very easy to do when you're

00:09:32.670 --> 00:09:34.020
using HTTP.

00:09:34.020 --> 00:09:37.290
But it also shows the
bi-directional nature of

00:09:37.290 --> 00:09:40.090
WebSocket, where not only do you
see the data coming in but

00:09:40.090 --> 00:09:42.460
you can also initiate trading.

00:09:42.460 --> 00:09:43.620
PETER LUBBERS: So to
buy a stock, you

00:09:43.620 --> 00:09:45.100
would send a message.

00:09:45.100 --> 00:09:46.180
And they receive messages.

00:09:46.180 --> 00:09:46.510
Right.

00:09:46.510 --> 00:09:47.070
Exactly.

00:09:47.070 --> 00:09:47.285
Yeah.

00:09:47.285 --> 00:09:51.140
I think that demo really
highlights a lot of the cool

00:09:51.140 --> 00:09:56.740
parts about WebSocket as opposed
to what are typically

00:09:56.740 --> 00:10:02.520
called Comet implementations
that are basically HTTP

00:10:02.520 --> 00:10:05.560
requests that are either polling
or long polling.

00:10:05.560 --> 00:10:10.820
So what's the typical reduction
of overhead in

00:10:10.820 --> 00:10:13.360
something like this that
you would find?

00:10:13.360 --> 00:10:16.390
PETER MOSKOVITS: So when you
speak HTTP, along with the

00:10:16.390 --> 00:10:18.910
request and the response there
is a number of headers that

00:10:18.910 --> 00:10:19.980
are sent over.

00:10:19.980 --> 00:10:24.110
And these headers can range from
800 to 1,500, sometimes

00:10:24.110 --> 00:10:25.820
even 2,000 bytes.

00:10:25.820 --> 00:10:29.410
And when it comes to sending and
receiving small amounts of

00:10:29.410 --> 00:10:32.090
data at a high frequency,
then it all adds

00:10:32.090 --> 00:10:33.370
up very, very quickly.

00:10:33.370 --> 00:10:38.310
With WebSocket, the header and
the overhead is in the number

00:10:38.310 --> 00:10:41.040
of bytes, four, six,
eight, bytes.

00:10:41.040 --> 00:10:44.370
So when you're sending over a
character or a small number or

00:10:44.370 --> 00:10:47.100
something really small, then
it can be 100- or even

00:10:47.100 --> 00:10:49.700
1,00-fold, the speed improvement
that you can

00:10:49.700 --> 00:10:52.260
achieve, which is impressive,
especially when you have

00:10:52.260 --> 00:10:57.120
hundreds of thousands or
millions of users out there.

00:10:57.120 --> 00:10:58.010
PETER LUBBERS: Cool.

00:10:58.010 --> 00:11:02.130
So in the book, you
said here JMS.

00:11:02.130 --> 00:11:06.330
So in the book I noticed you
talk a lot about of course

00:11:06.330 --> 00:11:09.690
there's the core WebSocket,
that is

00:11:09.690 --> 00:11:12.160
the API and the protocol.

00:11:12.160 --> 00:11:14.720
But then you also talked
about XMPP.

00:11:14.720 --> 00:11:20.250
You mentioned STOMP or remote
frame buffers, the VNC

00:11:20.250 --> 00:11:23.210
protocol, I guess,
if you will.

00:11:23.210 --> 00:11:27.120
Tell us a little bit about
what the architecture for

00:11:27.120 --> 00:11:28.790
something like that
would look like.

00:11:28.790 --> 00:11:29.050
FRANK SALIM: Yeah.

00:11:29.050 --> 00:11:32.140
So WebSocket really lends
itself to a layered

00:11:32.140 --> 00:11:34.770
architecture where if
you treat it like a

00:11:34.770 --> 00:11:38.280
transport-level protocol, like
an analog-to-TCP, and speak

00:11:38.280 --> 00:11:41.570
application-level protocols
on top of that, that's an

00:11:41.570 --> 00:11:44.330
approach that we think works
really nicely and we describe

00:11:44.330 --> 00:11:46.460
at length in the book.

00:11:46.460 --> 00:11:50.400
PETER LUBBERS: Is it also
part of the standard?

00:11:50.400 --> 00:11:50.770
FRANK SALIM: Yeah.

00:11:50.770 --> 00:11:54.200
So the standard contains
support for

00:11:54.200 --> 00:11:54.860
higher-level protocols.

00:11:54.860 --> 00:11:58.080
They're called sub-protocols,
which maybe isn't the most

00:11:58.080 --> 00:11:59.600
straightforward term.

00:11:59.600 --> 00:12:03.360
But with the standard you can
create a connection that

00:12:03.360 --> 00:12:07.350
negotiates a protocol with
a name, a named protocol.

00:12:07.350 --> 00:12:11.320
And the contents of the
WebSocket conversation will

00:12:11.320 --> 00:12:13.340
adhere to that other protocol.

00:12:13.340 --> 00:12:15.860
PETER LUBBERS: But have any
browsers shipped with any

00:12:15.860 --> 00:12:20.170
sub-protocol support
today, or not yet?

00:12:20.170 --> 00:12:21.640
FRANK SALIM: Support for
the sub-protocol

00:12:21.640 --> 00:12:23.740
feature is baked in.

00:12:23.740 --> 00:12:26.950
And it's more up to the
application to bring along

00:12:26.950 --> 00:12:30.624
sub-protocol support as part
of a JavaScript library.

00:12:30.624 --> 00:12:30.897
PETER LUBBERS: OK.

00:12:30.897 --> 00:12:31.540
I see.

00:12:31.540 --> 00:12:34.710
PETER MOSKOVITS: So here on my
screen I quickly brought up a

00:12:34.710 --> 00:12:38.960
diagram that kind of talks to
this point, where you have

00:12:38.960 --> 00:12:40.920
your clients on the
left-hand side.

00:12:40.920 --> 00:12:44.150
You have the WebSocket
connection going all the way

00:12:44.150 --> 00:12:45.880
to your WebSocket server.

00:12:45.880 --> 00:12:49.040
And then you have a TCP
connection all the

00:12:49.040 --> 00:12:50.020
way to the back end.

00:12:50.020 --> 00:12:52.800
And typically, the TCP
connection that you have on

00:12:52.800 --> 00:12:57.265
the back end can be really any
rich business protocol.

00:12:57.265 --> 00:13:01.790
But when you have a traditional
web application,

00:13:01.790 --> 00:13:05.600
you basically break that
bidirectional connection as

00:13:05.600 --> 00:13:07.590
you go out to your
web clients.

00:13:07.590 --> 00:13:10.310
And this is what WebSocket
is addressing.

00:13:10.310 --> 00:13:13.370
And not only do you have the
full duplex connectivity

00:13:13.370 --> 00:13:17.740
between your clients and your
WebSocket server that can then

00:13:17.740 --> 00:13:22.140
be basically connected all the
way to the back end, but very

00:13:22.140 --> 00:13:25.510
much like on TCP, you can build
these higher level,

00:13:25.510 --> 00:13:26.660
richer protocols.

00:13:26.660 --> 00:13:30.460
So interestingly from a server's
perspective, you

00:13:30.460 --> 00:13:33.780
don't necessarily or don't even
know whether the client

00:13:33.780 --> 00:13:36.200
that is connecting is connecting
over TCP or over

00:13:36.200 --> 00:13:41.950
WebSocket, as long as it speaks
that specific protocol.

00:13:41.950 --> 00:13:43.000
XMPP is a good example.

00:13:43.000 --> 00:13:46.320
And we have an example
for that in the book.

00:13:46.320 --> 00:13:47.530
PETER LUBBERS: Great.

00:13:47.530 --> 00:13:50.630
Well, before we dive into any
further examples, what's the

00:13:50.630 --> 00:13:52.100
level of support
like right now?

00:13:52.100 --> 00:13:54.590
Like what browsers and
especially the mobile

00:13:54.590 --> 00:13:57.470
browsers, what's the
support landscape?

00:13:57.470 --> 00:14:00.770
And Where can I find out?

00:14:00.770 --> 00:14:04.070
PETER MOSKOVITS: So maybe here
I can show caniuse.com.

00:14:06.570 --> 00:14:10.420
So if you filter this for
WebSocket, you see where we

00:14:10.420 --> 00:14:11.080
stand today.

00:14:11.080 --> 00:14:15.380
It shows that the currently-used
browsers, 58%,

00:14:15.380 --> 00:14:19.780
59% of them do support WebSocket
natively, which is

00:14:19.780 --> 00:14:21.510
good on one hand.

00:14:21.510 --> 00:14:23.820
It's pretty bad if you consider
that you may be

00:14:23.820 --> 00:14:28.120
losing 30%, 33% percent of
your users who are going

00:14:28.120 --> 00:14:30.280
against the WebSocket-enabled
application.

00:14:30.280 --> 00:14:31.900
So that is a challenge.

00:14:31.900 --> 00:14:34.150
This is something that we see
out there that people are

00:14:34.150 --> 00:14:34.740
struggling with.

00:14:34.740 --> 00:14:39.490
So it's very important that you
make sure that whatever

00:14:39.490 --> 00:14:42.810
server you're using, you have
the right level of emulation

00:14:42.810 --> 00:14:46.260
or fallback to support all those
browsers that do not

00:14:46.260 --> 00:14:47.720
have native support.

00:14:47.720 --> 00:14:52.100
PETER LUBBERS: Yeah, like
polyfill libraries and so on.

00:14:52.100 --> 00:14:53.610
FRANK SALIM: It's worth
mentioning that the latest

00:14:53.610 --> 00:14:55.240
version of all the
major desktop

00:14:55.240 --> 00:14:56.820
browsers support WebSocket.

00:14:56.820 --> 00:14:56.980
PETER LUBBERS: Yeah.

00:14:56.980 --> 00:14:58.040
That's a big deal, right?

00:14:58.040 --> 00:14:59.950
So IE10 joined.

00:14:59.950 --> 00:15:02.850
FRANK SALIM: The future
looks good.

00:15:02.850 --> 00:15:05.520
PETER LUBBERS: Yeah, that's
actually pretty good, the

00:15:05.520 --> 00:15:07.170
percentage there, because you're
always going to have

00:15:07.170 --> 00:15:09.760
sort of the old ID that's
not going to support it.

00:15:09.760 --> 00:15:14.530
I mean, it's more like what's
happening in the future

00:15:14.530 --> 00:15:17.600
browsers that's important.

00:15:17.600 --> 00:15:19.440
PETER MOSKOVITS: I was thinking
I have another demo

00:15:19.440 --> 00:15:20.470
that maybe we can show.

00:15:20.470 --> 00:15:21.260
PETER LUBBERS: Perfect.

00:15:21.260 --> 00:15:22.190
Yeah.

00:15:22.190 --> 00:15:27.960
PETER MOSKOVITS: So we saw the
use case where we have a lot

00:15:27.960 --> 00:15:30.850
of data coming in from the
server and we want to share

00:15:30.850 --> 00:15:33.420
this with a number of clients.

00:15:33.420 --> 00:15:35.940
Another interesting use case
that was really hard to

00:15:35.940 --> 00:15:39.870
achieve before the world of
WebSocket is this peer-to-peer

00:15:39.870 --> 00:15:42.730
or pseudo-peer-to-peer
kind of connection.

00:15:42.730 --> 00:15:47.260
So one of the first kind of
quick demos that I built when

00:15:47.260 --> 00:15:54.040
I started looking into WebSocket
is a demo called the

00:15:54.040 --> 00:15:57.550
Bouncy Ball Demo.

00:15:57.550 --> 00:16:03.130
And I'm going to bring up a
simulator here and open the

00:16:03.130 --> 00:16:05.180
same page here in
the simulator.

00:16:05.180 --> 00:16:07.780
And just to play safe, I'll
reload this page.

00:16:07.780 --> 00:16:11.980
And what we see here is that
the two are side by side.

00:16:11.980 --> 00:16:14.930
And maybe I can resize this
Chrome window here a little

00:16:14.930 --> 00:16:19.800
bit so they can be truly
side by side.

00:16:19.800 --> 00:16:23.170
And what we can do is with a
simple tap gesture on the

00:16:23.170 --> 00:16:25.590
phone, we can connect
these two screens.

00:16:25.590 --> 00:16:28.820
You see there are basically two
HTML pages with canvases

00:16:28.820 --> 00:16:29.850
rendered in there.

00:16:29.850 --> 00:16:33.310
And when I tap and--

00:16:33.310 --> 00:16:35.700
demo is not behaving.

00:16:35.700 --> 00:16:36.950
Let's try again.

00:16:46.172 --> 00:16:47.422
Let's try that again.

00:16:53.100 --> 00:16:55.330
They would basically
share the screen.

00:16:55.330 --> 00:16:56.830
Here we go.

00:16:56.830 --> 00:16:59.355
And when we actually--

00:16:59.355 --> 00:16:59.730
ah.

00:16:59.730 --> 00:17:00.900
I may need to.

00:17:00.900 --> 00:17:01.660
Here we go.

00:17:01.660 --> 00:17:07.150
So what happens is the two
screens are connected, so

00:17:07.150 --> 00:17:09.040
basically they negotiate
who is on the left and

00:17:09.040 --> 00:17:09.920
who is on the right.

00:17:09.920 --> 00:17:13.609
And when the ball comes to a
shared wall, then a message is

00:17:13.609 --> 00:17:18.210
sent from one browser to the
other through the WebSocket

00:17:18.210 --> 00:17:20.220
server indicating that the
ball is coming at this

00:17:20.220 --> 00:17:23.849
position, this is the speed,
this is the direction where

00:17:23.849 --> 00:17:26.290
it's heading, you take over
the rendering now.

00:17:26.290 --> 00:17:28.990
And then the other browser
can render.

00:17:28.990 --> 00:17:31.060
It's important to mention
that this is not a true

00:17:31.060 --> 00:17:32.130
peer-to-peer connection.

00:17:32.130 --> 00:17:33.890
It goes through the server.

00:17:33.890 --> 00:17:37.170
But you can achieve the--

00:17:37.170 --> 00:17:37.340
PETER LUBBERS: Yeah.

00:17:37.340 --> 00:17:40.080
There have actually been a few
moderator questions we'll get

00:17:40.080 --> 00:17:43.660
to later talking about the
connection with WebRTC.

00:17:43.660 --> 00:17:45.180
So let's come back to that.

00:17:45.180 --> 00:17:48.620
So that's just basically a
canvas implementation on both

00:17:48.620 --> 00:17:49.140
clients, right?

00:17:49.140 --> 00:17:49.943
PETER MOSKOVITS: Right.

00:17:49.943 --> 00:17:50.810
PETER LUBBERS: OK.

00:17:50.810 --> 00:17:53.610
PETER MOSKOVITS: Actually, I
happen to have another one if

00:17:53.610 --> 00:17:55.180
this is a good time.

00:17:55.180 --> 00:18:02.550
This one is a video that shows
a WebGL car on a screen.

00:18:02.550 --> 00:18:05.590
This is a pretty cool
car by itself.

00:18:05.590 --> 00:18:07.020
And in the bottom right
corner, what

00:18:07.020 --> 00:18:09.170
you see is my phone.

00:18:09.170 --> 00:18:13.990
And as I am tilting the phone,
I am time driving the car.

00:18:13.990 --> 00:18:16.630
And the way it happens is I have
a browser run on my phone

00:18:16.630 --> 00:18:19.870
as well detect the
tilt status.

00:18:19.870 --> 00:18:23.810
And as quickly as I can, I'm
sending messages to the

00:18:23.810 --> 00:18:25.740
connected WebSocket server.

00:18:25.740 --> 00:18:29.890
And since they share a server,
it can be bounced back using

00:18:29.890 --> 00:18:32.370
this reflector model.

00:18:32.370 --> 00:18:35.355
And it can be done very quickly
and very easily if you

00:18:35.355 --> 00:18:42.300
are using concepts like pub/sub
on top of WebSocket.

00:18:42.300 --> 00:18:44.140
PETER LUBBERS: High speed
messaging, basically.

00:18:44.140 --> 00:18:44.440
PETER MOSKOVITS: Yeah.

00:18:44.440 --> 00:18:44.940
Exactly.

00:18:44.940 --> 00:18:45.890
PETER LUBBERS: That's
excellent.

00:18:45.890 --> 00:18:46.340
Yeah.

00:18:46.340 --> 00:18:47.250
I like that demo a lot.

00:18:47.250 --> 00:18:49.090
That's really cool.

00:18:49.090 --> 00:18:51.350
So what do you see--

00:18:51.350 --> 00:18:53.600
what other sort of applications
are being built

00:18:53.600 --> 00:18:55.310
today with WebSocket?

00:18:55.310 --> 00:18:59.160
What's happening
in that world?

00:18:59.160 --> 00:19:01.280
VANESSA WANG: So in addition to
some of the examples Peter

00:19:01.280 --> 00:19:05.330
outlined, which is large amounts
of small bits of data

00:19:05.330 --> 00:19:08.410
being sent out to multiple
clients at the same time,

00:19:08.410 --> 00:19:12.350
we're also seeing a lot of
gaming being developed.

00:19:12.350 --> 00:19:14.710
Browser-based games are using
WebSocket, especially like

00:19:14.710 --> 00:19:16.570
MMO-type games.

00:19:16.570 --> 00:19:18.580
I think Mozilla did a
BrowserQuest game a little

00:19:18.580 --> 00:19:23.230
while ago, so did Rob Hawkes
with twitterrocks.com.

00:19:23.230 --> 00:19:23.580
Sorry.

00:19:23.580 --> 00:19:25.810
It was called Rawkets,
I think.

00:19:25.810 --> 00:19:26.660
PETER LUBBERS: Oh
yeah, Rawkets.

00:19:26.660 --> 00:19:27.240
VANESSA WANG: Yeah.

00:19:27.240 --> 00:19:30.920
But we also see some other
ways that people might be

00:19:30.920 --> 00:19:33.990
using this for like
crowdsourcing-type apps, like

00:19:33.990 --> 00:19:38.170
Waze, something like a GPS for
traffic conditions, where a

00:19:38.170 --> 00:19:39.890
lot of people need to
send lots of data

00:19:39.890 --> 00:19:41.880
over the web in real-time.

00:19:41.880 --> 00:19:42.160
PETER MOSKOVITS: Yeah.

00:19:42.160 --> 00:19:43.170
Waze is really cool.

00:19:43.170 --> 00:19:45.580
One of their recent
features is that--

00:19:45.580 --> 00:19:46.270
PETER LUBBERS: The GPS app.

00:19:46.270 --> 00:19:47.740
PETER MOSKOVITS: The
GPS app, yeah.

00:19:47.740 --> 00:19:49.450
You enter an address.

00:19:49.450 --> 00:19:50.670
You navigate somewhere.

00:19:50.670 --> 00:19:53.900
And then you can share your
trip with somebody else.

00:19:53.900 --> 00:19:56.830
So in their browser, they can
basically follow how you're

00:19:56.830 --> 00:19:58.180
getting to a given point.

00:19:58.180 --> 00:20:00.500
So you go and pick up somebody,
and they can see

00:20:00.500 --> 00:20:02.110
where you are stuck in traffic
and how it goes.

00:20:02.110 --> 00:20:04.100
Now, I don't believe
they use WebSocket.

00:20:04.100 --> 00:20:06.560
And I actually I think their
refresh rate is somewhere in

00:20:06.560 --> 00:20:09.190
the 30 second or maybe
1 minute rate.

00:20:09.190 --> 00:20:13.630
But if they would be using
WebSocket, then they would be

00:20:13.630 --> 00:20:17.460
able to see true
real-time data.

00:20:17.460 --> 00:20:18.710
PETER LUBBERS: That's cool.

00:20:20.420 --> 00:20:21.130
That's great.

00:20:21.130 --> 00:20:23.510
Where do you see--

00:20:23.510 --> 00:20:26.840
IE only added the support, what,
like last year, right,

00:20:26.840 --> 00:20:28.170
when IE10 came out.

00:20:28.170 --> 00:20:33.070
So fast forward two to three
years, even five years.

00:20:33.070 --> 00:20:37.630
Where do you see like with
ubiquitous, fast connections

00:20:37.630 --> 00:20:41.670
and everything on mobile, what
sort of applications do you

00:20:41.670 --> 00:20:45.320
envision for WebSocket?

00:20:45.320 --> 00:20:50.680
PETER MOSKOVITS: We already
see a lot of interest in

00:20:50.680 --> 00:20:52.770
machine-to-machine
communication, [INAUDIBLE]

00:20:52.770 --> 00:20:54.370
of things.

00:20:54.370 --> 00:20:58.070
There's an interesting company
that I talked to not too long

00:20:58.070 --> 00:21:00.700
ago where they have the ability
to produce these

00:21:00.700 --> 00:21:04.840
little devices in a very cheap
and very efficient manner

00:21:04.840 --> 00:21:10.850
where they can basically put
out and monitor things like

00:21:10.850 --> 00:21:14.570
parking spots that are available
in cities, or attach

00:21:14.570 --> 00:21:18.030
them to fire extinguishers.

00:21:18.030 --> 00:21:21.910
So when basically the amount of
data that you want to send

00:21:21.910 --> 00:21:25.350
over is typically very small,
most of the time the data that

00:21:25.350 --> 00:21:30.300
you want to send over doesn't
have the real-time

00:21:30.300 --> 00:21:33.190
requirement, but potentially
there is a very large number

00:21:33.190 --> 00:21:37.110
of these devices that are out
there, so basically the

00:21:37.110 --> 00:21:39.980
communication can be
done really well.

00:21:39.980 --> 00:21:43.070
The monitoring aspect, when you
are building dashboards

00:21:43.070 --> 00:21:47.570
that can be an interesting
use case.

00:21:47.570 --> 00:21:48.020
PETER LUBBERS: That's great.

00:21:48.020 --> 00:21:49.540
Any other--

00:21:49.540 --> 00:21:52.330
VANESSA WANG: Similarly, we're
seeing some use cases in

00:21:52.330 --> 00:21:57.160
transportation, also like
tracking cars, where cars are

00:21:57.160 --> 00:21:59.750
going and being able to
report back, trains,

00:21:59.750 --> 00:22:02.660
planes, you name it.

00:22:02.660 --> 00:22:05.040
PETER MOSKOVITS: Another tricky
one is second-screen

00:22:05.040 --> 00:22:08.460
kinds of applications, where
you're watching a show or you

00:22:08.460 --> 00:22:13.170
are watching a sports event, and
then you can interact with

00:22:13.170 --> 00:22:15.070
kind of the system and
you can interact with

00:22:15.070 --> 00:22:17.480
other viewers as well.

00:22:17.480 --> 00:22:22.330
We helped a film festival
last year.

00:22:22.330 --> 00:22:25.450
And they were doing a quiz and
trivia game before the movies.

00:22:25.450 --> 00:22:29.650
And they had real-time voting
after the movies.

00:22:29.650 --> 00:22:32.760
It's a nice alternative to
basically marking up or

00:22:32.760 --> 00:22:38.040
writing your vote for an
audience award movie when you

00:22:38.040 --> 00:22:39.140
can use your phone.

00:22:39.140 --> 00:22:40.460
PETER LUBBERS: Yeah.

00:22:40.460 --> 00:22:42.840
One of the chapters in your book
that I really liked was

00:22:42.840 --> 00:22:46.530
the RFB protocol, the
remote desktop.

00:22:46.530 --> 00:22:51.070
I think that's another very
powerful way to use it.

00:22:51.070 --> 00:22:56.082
So in your VM, you actually
have a VNC server set up?

00:22:56.082 --> 00:22:57.410
FRANK SALIM: Yeah.

00:22:57.410 --> 00:23:00.060
PETER LUBBERS: That's cool.

00:23:00.060 --> 00:23:03.400
FRANK SALIM: You get the kind of
hall of mirrors effect with

00:23:03.400 --> 00:23:07.140
the default configuration,
because the VNC server is the

00:23:07.140 --> 00:23:10.050
same VM where you have
the browser.

00:23:10.050 --> 00:23:13.900
You get the infinite
recursive window.

00:23:13.900 --> 00:23:15.670
PETER LUBBERS: But
still, very cool.

00:23:15.670 --> 00:23:16.190
FRANK SALIM: That's there.

00:23:16.190 --> 00:23:18.060
You can easily reconfigure
to point to a

00:23:18.060 --> 00:23:19.330
different VNC server.

00:23:19.330 --> 00:23:19.680
PETER LUBBERS: Right.

00:23:19.680 --> 00:23:23.490
Is that using sort of the
binary message types of

00:23:23.490 --> 00:23:24.620
WebSocket or just--

00:23:24.620 --> 00:23:25.110
FRANK SALIM: Yeah.

00:23:25.110 --> 00:23:26.600
That's sending binary
data over WebSocket.

00:23:26.600 --> 00:23:30.110
And there's a JavaScript library
that implements the

00:23:30.110 --> 00:23:31.360
Remote Frame Buffer protocol.

00:23:34.730 --> 00:23:36.930
PETER LUBBERS: There's so many
great things out there.

00:23:36.930 --> 00:23:39.780
So one of the things I want to
talk about a little bit is the

00:23:39.780 --> 00:23:41.700
debugging of these
connections.

00:23:41.700 --> 00:23:46.030
So we have for example, in
Chrome Dev Tools, good ways to

00:23:46.030 --> 00:23:48.730
look under the hood and let
us see what's happening.

00:23:48.730 --> 00:23:52.020
What is your debugging workflow
for a WebSocket

00:23:52.020 --> 00:23:53.690
application?

00:23:53.690 --> 00:23:56.670
PETER MOSKOVITS: So let
me get started with

00:23:56.670 --> 00:23:59.260
that here on my machine.

00:23:59.260 --> 00:24:01.640
Let's bring up Chrome
Dev Tools.

00:24:04.690 --> 00:24:09.830
And connect to websocket.org.

00:24:09.830 --> 00:24:12.550
websocket.org is an
awesome website.

00:24:12.550 --> 00:24:14.460
It has a lot of nice resources,

00:24:14.460 --> 00:24:16.930
examples, good articles.

00:24:16.930 --> 00:24:20.680
So it's a good place
to get started.

00:24:20.680 --> 00:24:24.520
The echo test is a very nice
service where basically you

00:24:24.520 --> 00:24:27.780
can create a WebSocket
connection, send some data to

00:24:27.780 --> 00:24:28.500
the server.

00:24:28.500 --> 00:24:31.460
And all the server does is
it echoes it back to you.

00:24:31.460 --> 00:24:36.000
So it's pretty much the first
test that people use if they

00:24:36.000 --> 00:24:40.510
want to basically test
what they have.

00:24:40.510 --> 00:24:43.310
So I'm going to create
a connection.

00:24:43.310 --> 00:24:46.820
And when you switch over to
the Network tab and we can

00:24:46.820 --> 00:24:50.640
filter by WebSocket, what we
see here is the actual

00:24:50.640 --> 00:24:52.390
WebSocket connection.

00:24:52.390 --> 00:24:55.090
And then we talked about
WebSocket beating

00:24:55.090 --> 00:24:59.830
web-friendly, which means that
actually it starts its life as

00:24:59.830 --> 00:25:01.700
an HTTP connection.

00:25:01.700 --> 00:25:05.600
So interestingly, WebSocket
connection is symmetric.

00:25:05.600 --> 00:25:07.870
So the server can send
data asynchronously.

00:25:07.870 --> 00:25:10.730
And the client can send
data asynchronously.

00:25:10.730 --> 00:25:11.730
So it's bi-directional.

00:25:11.730 --> 00:25:16.340
But the way it gets created,
that is asymmetric in the

00:25:16.340 --> 00:25:19.140
sense that it's always the
client that has to initiate

00:25:19.140 --> 00:25:19.700
the connection.

00:25:19.700 --> 00:25:22.100
So basically the browser says
or the client, the WebSocket

00:25:22.100 --> 00:25:26.130
client, says that, hey, I want
to create a connection and

00:25:26.130 --> 00:25:26.970
then, do you speak WebSocket?

00:25:26.970 --> 00:25:30.250
And the server responds, yes,
I do speak WebSocket.

00:25:30.250 --> 00:25:34.660
And that's when the HTTP
connection breaks down and the

00:25:34.660 --> 00:25:38.120
new connection, the WebSocket
connection, takes over.

00:25:38.120 --> 00:25:39.930
FRANK SALIM: And we can see
the handshake here, the

00:25:39.930 --> 00:25:43.400
request and response, with
all of the headers.

00:25:43.400 --> 00:25:43.970
PETER MOSKOVITS: Right.

00:25:43.970 --> 00:25:45.330
FRANK SALIM: Might want to make
it a little bit bigger.

00:25:49.810 --> 00:25:52.480
PETER MOSKOVITS: Here we go.

00:25:52.480 --> 00:25:56.590
So here is the upgrade
header that is sent.

00:25:56.590 --> 00:26:00.690
And here in the response is
the upgrade header too.

00:26:00.690 --> 00:26:01.130
PETER LUBBERS: Cool.

00:26:01.130 --> 00:26:01.610
PETER MOSKOVITS: OK.

00:26:01.610 --> 00:26:05.510
And so once we have the
connection established--

00:26:05.510 --> 00:26:05.680
PETER LUBBERS: Yeah.

00:26:05.680 --> 00:26:07.790
Then you have the messaging
that goes back and forth.

00:26:07.790 --> 00:26:08.300
PETER MOSKOVITS: Exactly.

00:26:08.300 --> 00:26:11.100
So what you can do here
on websocket.org is

00:26:11.100 --> 00:26:13.500
you can send a message.

00:26:13.500 --> 00:26:15.690
And we see the message
was sent.

00:26:15.690 --> 00:26:16.830
And the response was sent back,

00:26:16.830 --> 00:26:18.330
which is the same message.

00:26:18.330 --> 00:26:20.260
So let's click on the
connection again.

00:26:20.260 --> 00:26:22.400
And here we can inspect
the frames.

00:26:22.400 --> 00:26:25.110
Here the background color
indicates whether it was an

00:26:25.110 --> 00:26:27.100
upstream or a downstream.

00:26:27.100 --> 00:26:29.480
You can see the length
of the message.

00:26:29.480 --> 00:26:31.200
And you can see the
time as well.

00:26:35.600 --> 00:26:37.670
So if you are sending a new
message, you would need to

00:26:37.670 --> 00:26:42.010
click on the connection
again to refresh the

00:26:42.010 --> 00:26:43.910
actual frames in here.

00:26:43.910 --> 00:26:48.340
So another thing that we
could do here is--

00:26:48.340 --> 00:26:50.410
let me bring up the console.

00:26:50.410 --> 00:26:53.830
And from the console itself,
we do have a WebSocket

00:26:53.830 --> 00:26:56.690
connection variable here.

00:26:56.690 --> 00:27:01.190
So here you can see the actual
connected WebSockets.

00:27:01.190 --> 00:27:03.130
You see the endpoint here.

00:27:03.130 --> 00:27:06.650
And we can do websocket.send.

00:27:06.650 --> 00:27:12.290
And here we can say something
like, "Hi there." And when you

00:27:12.290 --> 00:27:15.570
do this, what happens is the
message is sent from the

00:27:15.570 --> 00:27:17.610
console, not from
the application.

00:27:17.610 --> 00:27:21.270
So actually, I did say
"hi there" again.

00:27:21.270 --> 00:27:22.100
I should have said
something else.

00:27:22.100 --> 00:27:26.050
But basically--

00:27:26.050 --> 00:27:29.140
thank you.

00:27:29.140 --> 00:27:31.940
FRANK SALIM: Excuse me.

00:27:31.940 --> 00:27:32.570
PETER MOSKOVITS: Here we go.

00:27:32.570 --> 00:27:36.600
So from the application
we don't log

00:27:36.600 --> 00:27:37.620
the outgoing message.

00:27:37.620 --> 00:27:40.450
We only get back the incoming
message, simply because the

00:27:40.450 --> 00:27:41.925
message was not sent
from the app.

00:27:41.925 --> 00:27:43.060
It was sent from the console.

00:27:43.060 --> 00:27:46.990
So it kind of gives you an idea
of how you can use Chrome

00:27:46.990 --> 00:27:49.450
to kind of visualize WebSocket,
which by the way is

00:27:49.450 --> 00:27:51.500
quite a challenge, because
it's all kind

00:27:51.500 --> 00:27:52.900
of under the covers.

00:27:52.900 --> 00:27:53.940
And it's very handy.

00:27:53.940 --> 00:27:54.970
And it's there.

00:27:54.970 --> 00:27:56.595
You don't have to install
or get anything.

00:27:56.595 --> 00:27:59.100
It's just there at your
fingertips right away.

00:27:59.100 --> 00:28:00.550
PETER LUBBERS: What are some of
the other tools you might

00:28:00.550 --> 00:28:03.850
be using for the analysis?

00:28:03.850 --> 00:28:04.738
FRANK SALIM: Do we
want to look at

00:28:04.738 --> 00:28:07.890
Netinternals maybe first?

00:28:07.890 --> 00:28:09.140
PETER MOSKOVITS: Sure.

00:28:15.605 --> 00:28:16.600
PETER LUBBERS: So where
are you going?

00:28:16.600 --> 00:28:18.710
Chrome.

00:28:18.710 --> 00:28:19.820
Right.

00:28:19.820 --> 00:28:20.810
Yeah.

00:28:20.810 --> 00:28:22.176
FRANK SALIM: Even more
under the hood.

00:28:25.270 --> 00:28:29.230
Tools for inspecting
the network stack.

00:28:29.230 --> 00:28:33.160
So even if a WebSocket doesn't
connect and maybe you have a

00:28:33.160 --> 00:28:36.420
DNS stall out or some other
connection issue before you

00:28:36.420 --> 00:28:38.765
get that far, you can look
in Netinternals.

00:28:41.530 --> 00:28:44.280
But I think where you're going
is, what if that's not enough?

00:28:44.280 --> 00:28:46.670
PETER LUBBERS: Right.

00:28:46.670 --> 00:28:48.600
FRANK SALIM: In the case where
you have a WebSocket client,

00:28:48.600 --> 00:28:50.560
your browser and a WebSocket
server that speaks the

00:28:50.560 --> 00:28:54.170
protocol, and everything is
working fine, this is almost

00:28:54.170 --> 00:28:55.210
always enough information.

00:28:55.210 --> 00:28:55.870
You can see your handshake.

00:28:55.870 --> 00:28:58.320
You can see the payload
of WebSocket messages

00:28:58.320 --> 00:28:59.830
flying back and forth.

00:28:59.830 --> 00:29:01.760
If you're writing a new
WebSocket server and you need

00:29:01.760 --> 00:29:05.110
to make sure that the syntax of
the WebSocket messages is

00:29:05.110 --> 00:29:09.830
correct, you might go for
network-level tracing, where

00:29:09.830 --> 00:29:12.885
Wireshark is an incredibly
powerful tool.

00:29:12.885 --> 00:29:13.150
PETER LUBBERS: OK.

00:29:13.150 --> 00:29:14.062
Show us that.

00:29:14.062 --> 00:29:14.980
FRANK SALIM: Let's take
a look at that.

00:29:14.980 --> 00:29:15.650
PETER LUBBERS: The power.

00:29:15.650 --> 00:29:20.010
FRANK SALIM: I'll just refresh
websocket.org again and bring

00:29:20.010 --> 00:29:21.260
up Wireshark.

00:29:29.510 --> 00:29:30.590
PETER LUBBERS: So Wireshark,
you can just

00:29:30.590 --> 00:29:31.695
download that for free?

00:29:31.695 --> 00:29:31.893
FRANK SALIM: Yes.

00:29:31.893 --> 00:29:33.210
Open source application.

00:29:33.210 --> 00:29:38.300
We'll start a capture on the
wireless device here, and

00:29:38.300 --> 00:29:44.053
filter for port 80, where web
traffic will be found.

00:29:47.140 --> 00:29:48.960
All right.

00:29:48.960 --> 00:29:54.340
And we'll start this WebSocket
connection

00:29:54.340 --> 00:29:57.080
and send a few messages.

00:29:57.080 --> 00:30:07.790
And over here, we should see
the complete bytes of both

00:30:07.790 --> 00:30:13.820
sides of the network session,
including framing and masking,

00:30:13.820 --> 00:30:17.750
which are below the level
of where the JavaScript

00:30:17.750 --> 00:30:20.940
application would have
visibility or care about.

00:30:20.940 --> 00:30:21.240
PETER LUBBERS: Yes.

00:30:21.240 --> 00:30:23.830
So you could never get from
within the [INAUDIBLE].

00:30:23.830 --> 00:30:25.220
FRANK SALIM: Right.

00:30:25.220 --> 00:30:29.590
And it looks like with later
versions of Wireshark, it will

00:30:29.590 --> 00:30:34.150
actually dissect the WebSocket
message and show you the

00:30:34.150 --> 00:30:36.863
fields in the WebSocket
message header.

00:30:36.863 --> 00:30:37.690
PETER LUBBERS: OK.

00:30:37.690 --> 00:30:38.220
Well, that's great.

00:30:38.220 --> 00:30:41.040
So basically for
anything that--

00:30:41.040 --> 00:30:43.960
like your regular JavaScript
applications that are let's

00:30:43.960 --> 00:30:47.570
say working, you can get it
from Chrome Dev Tools.

00:30:47.570 --> 00:30:51.490
If you're building things more
advanced, like a server, then

00:30:51.490 --> 00:30:54.550
you might go to the
Wireshark layer.

00:30:54.550 --> 00:30:54.740
FRANK SALIM: Yeah.

00:30:54.740 --> 00:30:56.837
If you're doing a new
implementation of the

00:30:56.837 --> 00:30:59.140
protocol, Wireshark
can be very handy.

00:30:59.140 --> 00:31:00.100
PETER LUBBERS: Right.

00:31:00.100 --> 00:31:00.580
VANESSA WANG: Yeah.

00:31:00.580 --> 00:31:04.480
We walk through using Chrome Dev
Tools, Netinternals, and

00:31:04.480 --> 00:31:05.840
Wireshark in the book as well.

00:31:05.840 --> 00:31:07.660
PETER LUBBERS: In the final
appendix, right, or one of the

00:31:07.660 --> 00:31:08.100
appendices.

00:31:08.100 --> 00:31:10.830
FRANK SALIM: We do write a
WebSocket server in Chapter 3,

00:31:10.830 --> 00:31:13.840
so there is an occasion where
you might want to do this kind

00:31:13.840 --> 00:31:14.740
of debugging.

00:31:14.740 --> 00:31:15.150
VANESSA WANG: Exactly.

00:31:15.150 --> 00:31:16.600
PETER LUBBERS: That's great.

00:31:16.600 --> 00:31:17.960
All right.

00:31:17.960 --> 00:31:23.460
So before we jump into the
questions on the moderator,

00:31:23.460 --> 00:31:27.210
Vanessa, you're a doc manager.

00:31:27.210 --> 00:31:28.620
You've written tons
of documentation.

00:31:28.620 --> 00:31:33.270
How did you find this writing an
actual book different from

00:31:33.270 --> 00:31:34.690
writing docs?

00:31:34.690 --> 00:31:37.510
VANESSA WANG: Well, first it
was we're bringing about a

00:31:37.510 --> 00:31:40.180
technology, a standard,
rather than a product.

00:31:40.180 --> 00:31:44.750
And that was definitely a shift
in just the process.

00:31:44.750 --> 00:31:49.670
And then thinking about the best
way to explain something

00:31:49.670 --> 00:31:52.290
that people will be approaching
in a number of

00:31:52.290 --> 00:31:54.690
different ways, and not
having any sort of

00:31:54.690 --> 00:31:56.420
predictability there.

00:31:56.420 --> 00:31:58.450
So it was a really
good process.

00:31:58.450 --> 00:32:00.668
It was a really intense
process.

00:32:03.600 --> 00:32:07.120
PETER LUBBERS: Having written
a book on the side, I'm sure

00:32:07.120 --> 00:32:09.104
you're happy that it's done.

00:32:09.104 --> 00:32:09.960
Great.

00:32:09.960 --> 00:32:11.310
Well, let's take a look
at a couple of

00:32:11.310 --> 00:32:14.550
questions on the moderator.

00:32:14.550 --> 00:32:18.280
So if you have any questions,
on the YouTube live stream

00:32:18.280 --> 00:32:23.890
there are links to ask and
vote for more questions.

00:32:23.890 --> 00:32:29.740
So let's go to the presentation
view here.

00:32:29.740 --> 00:32:30.230
All right.

00:32:30.230 --> 00:32:36.130
So what considerations in terms
of scalability should

00:32:36.130 --> 00:32:38.680
you take when deploying a
WebSocket-based service.

00:32:38.680 --> 00:32:42.220
In particular, what limits do
you hit easier due to having

00:32:42.220 --> 00:32:44.020
to keep many connections open?

00:32:44.020 --> 00:32:47.430
So that's I guess a commonly
asked question, right?

00:32:47.430 --> 00:32:53.050
Because with HTTP requests,
it's sort of the request,

00:32:53.050 --> 00:32:55.560
response, and it's done.

00:32:55.560 --> 00:32:59.870
Here you now have a whole new
paradigm of potentially

00:32:59.870 --> 00:33:04.280
thousands or millions of
concurrent connections.

00:33:04.280 --> 00:33:08.660
So how do you deal with the
scalability of that?

00:33:08.660 --> 00:33:11.810
This is from Vlad from London.

00:33:11.810 --> 00:33:12.890
PETER MOSKOVITS: Sure.

00:33:12.890 --> 00:33:15.070
Maybe I'll start and then
others can chime in.

00:33:15.070 --> 00:33:18.250
So one of the challenges that
we've been facing in the

00:33:18.250 --> 00:33:24.580
pre-WebSocket world is that
as we moved to the web, we

00:33:24.580 --> 00:33:29.020
started using the web in a way
that we expected kind of the

00:33:29.020 --> 00:33:30.970
client-server world to work.

00:33:30.970 --> 00:33:33.460
So just because we moved to the
web and just because the

00:33:33.460 --> 00:33:38.000
web was not designed for the
richness and the interactivity

00:33:38.000 --> 00:33:40.600
that we had in the client-server
world, that

00:33:40.600 --> 00:33:45.060
doesn't mean that customers and
people basically gave up

00:33:45.060 --> 00:33:46.940
on that need or on
that demand.

00:33:46.940 --> 00:33:51.000
So we came up with a number of
these very creative ways of

00:33:51.000 --> 00:33:52.300
introducing interactivity.

00:33:52.300 --> 00:33:56.990
And we were using HTTP, a very
scalable and stateless

00:33:56.990 --> 00:34:00.550
protocol for something that
it was not designed for.

00:34:00.550 --> 00:34:04.820
And by using something that was
specifically designed for

00:34:04.820 --> 00:34:08.840
this use case, I think we can
write our applications in a

00:34:08.840 --> 00:34:10.469
way more efficient manner.

00:34:10.469 --> 00:34:14.540
Very often I get the question
whether HTTP gets replaced by

00:34:14.540 --> 00:34:18.179
WebSocket, or what this whole
coexistence story is.

00:34:18.179 --> 00:34:23.540
And basically HTTP is there for
all the document-oriented

00:34:23.540 --> 00:34:27.790
resources, things like images
and HTML5 files and CSS and

00:34:27.790 --> 00:34:28.719
JavaScript.

00:34:28.719 --> 00:34:33.969
And WebSocket can be used for
where it's really good, where

00:34:33.969 --> 00:34:39.500
you need to have this permanent
connection for the

00:34:39.500 --> 00:34:40.900
bidirectional communication.

00:34:40.900 --> 00:34:46.270
On the scalability side, yes, it
can be a challenge, simply

00:34:46.270 --> 00:34:51.750
because when you get started
with WebSocket, basically you

00:34:51.750 --> 00:34:53.199
can build amazing things.

00:34:53.199 --> 00:34:56.310
And as you start rolling it out
to the web, you can face

00:34:56.310 --> 00:34:57.780
thousands, tens of thousands,
hundreds of

00:34:57.780 --> 00:34:58.880
thousands of users.

00:34:58.880 --> 00:35:01.510
And suddenly things
can break down.

00:35:01.510 --> 00:35:05.330
How you do clustering, how you
do failover, how you do

00:35:05.330 --> 00:35:08.900
disaster recovery, all these
kinds of questions come up.

00:35:08.900 --> 00:35:12.910
We did a benchmark
not too long ago.

00:35:12.910 --> 00:35:17.690
And in that benchmark, we had a
million concurrent connected

00:35:17.690 --> 00:35:23.430
users served by one server.

00:35:23.430 --> 00:35:24.670
VANESSA WANG: A server
rack, right?

00:35:24.670 --> 00:35:25.340
PETER MOSKOVITS: It was a rack.

00:35:25.340 --> 00:35:26.820
Exactly.

00:35:26.820 --> 00:35:30.650
We had 10 messages sent
per second to

00:35:30.650 --> 00:35:32.790
these 1 million users.

00:35:32.790 --> 00:35:35.720
The message size
was 512 bytes.

00:35:35.720 --> 00:35:39.370
The protocol overhead was
another 100 or 200 bytes.

00:35:39.370 --> 00:35:43.360
And we did not have a single
dropped connection.

00:35:43.360 --> 00:35:46.920
And the overhead that we added
on top of the actual physical

00:35:46.920 --> 00:35:50.380
network overhead, that the
WebSocket stack added on top

00:35:50.380 --> 00:35:54.060
of that the average was I think
3 and 1/2 milliseconds.

00:35:54.060 --> 00:35:56.340
So it can scale.

00:35:56.340 --> 00:35:59.510
But if you want to scale to a
very large number of users,

00:35:59.510 --> 00:36:03.060
then you have to have those
capabilities in the server

00:36:03.060 --> 00:36:05.012
that you are using.

00:36:05.012 --> 00:36:05.990
PETER LUBBERS: Sure.

00:36:05.990 --> 00:36:08.470
Makes sense.

00:36:08.470 --> 00:36:08.950
VANESSA WANG: Actually,
that brings up

00:36:08.950 --> 00:36:10.080
an interesting point.

00:36:10.080 --> 00:36:13.510
One of the things that we talk
about in the book is enabling

00:36:13.510 --> 00:36:15.500
your server to speak
WebSocket.

00:36:15.500 --> 00:36:18.710
So that would be your browser
or your client talking to

00:36:18.710 --> 00:36:22.880
WebSocket, to a WebSocket
server, versus using a server

00:36:22.880 --> 00:36:26.045
in between that translates
WebSocket traffic into TCP

00:36:26.045 --> 00:36:27.520
through the back end.

00:36:27.520 --> 00:36:29.640
And those are two different
options that we go

00:36:29.640 --> 00:36:30.620
through in the book.

00:36:30.620 --> 00:36:31.870
PETER LUBBERS: Cool.

00:36:33.630 --> 00:36:36.180
PETER MOSKOVITS: So speaking of
the book, and I don't know

00:36:36.180 --> 00:36:38.190
whether that would fit into
any of the questions.

00:36:38.190 --> 00:36:39.130
Maybe it would.

00:36:39.130 --> 00:36:41.770
PETER LUBBERS: Buy it.

00:36:41.770 --> 00:36:43.020
Buy the book.

00:36:45.650 --> 00:36:47.720
PETER MOSKOVITS: There are a
couple of very, very neat

00:36:47.720 --> 00:36:50.830
examples that I think we
built for the book.

00:36:50.830 --> 00:36:52.390
So maybe we can show
some of them.

00:36:52.390 --> 00:36:54.830
We have some here in the VM.

00:36:54.830 --> 00:36:58.320
And maybe we can walk through
what whole experience is just

00:36:58.320 --> 00:37:04.810
to basically show how easy
it is to get started.

00:37:04.810 --> 00:37:08.460
So the first one is Chapter 3.

00:37:08.460 --> 00:37:08.750
FRANK SALIM: Right.

00:37:08.750 --> 00:37:12.390
So in Chapter 3, we go through
building a WebSocket server

00:37:12.390 --> 00:37:15.710
from scratch, using nojs
on the server side.

00:37:15.710 --> 00:37:18.200
And that's really nice that we
get to keep the same language

00:37:18.200 --> 00:37:21.700
for these examples on the client
and on the server.

00:37:21.700 --> 00:37:22.760
So we write the server.

00:37:22.760 --> 00:37:26.550
And we have a couple of fun
little things you can do with

00:37:26.550 --> 00:37:29.400
it, the basic just echoing
messages back and forth, and

00:37:29.400 --> 00:37:31.790
also a WebSocket REPL.

00:37:31.790 --> 00:37:34.350
So we have a read-eval-print
loop that you run on the

00:37:34.350 --> 00:37:38.510
server side that executes
JavaScript remotely on all the

00:37:38.510 --> 00:37:40.270
connected clients.

00:37:40.270 --> 00:37:44.070
So I'll just start
that up here.

00:37:44.070 --> 00:37:53.450
I'll go to the Chapter 3
directory and run start REPL

00:37:53.450 --> 00:37:57.250
server dot sh, which is just
executing node and this

00:37:57.250 --> 00:38:02.910
WebSocket REPL JavaScript
application.

00:38:02.910 --> 00:38:24.690
I'll open a couple of browser
windows, I hope, and just open

00:38:24.690 --> 00:38:27.190
the client in each window.

00:38:27.190 --> 00:38:29.040
And we'll see here on the
server a couple of

00:38:29.040 --> 00:38:30.490
connections came in.

00:38:30.490 --> 00:38:33.410
And so whatever we type here in
the console is going to be

00:38:33.410 --> 00:38:35.680
executed by each of
the browsers.

00:38:35.680 --> 00:38:37.610
And the results going to be
returned over WebSocket.

00:38:37.610 --> 00:38:39.770
And it's going to print out
here again on the console.

00:38:39.770 --> 00:38:42.280
So just 1 plus 1, each browser
ran the JavaScript

00:38:42.280 --> 00:38:44.800
expression 1 plus 1.

00:38:44.800 --> 00:38:46.050
That was delivered to it
over the WebSocket.

00:38:46.050 --> 00:38:47.900
It comes back it's 2.

00:38:47.900 --> 00:38:49.760
So each session printed out 2.

00:38:49.760 --> 00:38:51.740
So we can do some pretty
fun things with that.

00:38:51.740 --> 00:39:01.210
For instance, we can manipulate
the actual pages

00:39:01.210 --> 00:39:02.460
run in each of these browsers.

00:39:07.480 --> 00:39:09.458
PETER LUBBERS: Oh wow.

00:39:09.458 --> 00:39:10.708
That's great.

00:39:15.910 --> 00:39:19.610
PETER MOSKOVITS: So you're
basically writing JavaScript

00:39:19.610 --> 00:39:23.370
commands that are sent over,
executed on each of these

00:39:23.370 --> 00:39:27.790
browsers, and you are

00:39:27.790 --> 00:39:28.960
controlling the browser remotely.

00:39:28.960 --> 00:39:29.190
FRANK SALIM: Yeah.

00:39:29.190 --> 00:39:32.220
It's a remote control
application, driven by a

00:39:32.220 --> 00:39:33.380
WebSocket server.

00:39:33.380 --> 00:39:34.810
PETER MOSKOVITS: It's pretty
impressive, especially when

00:39:34.810 --> 00:39:37.490
you have a browser on the other
side of the planet and

00:39:37.490 --> 00:39:38.740
you are remotely
controlling it.

00:39:38.740 --> 00:39:41.585
It can have a pretty
interesting effect.

00:39:41.585 --> 00:39:42.690
PETER LUBBERS: It brings
up the question

00:39:42.690 --> 00:39:45.610
of security, Frank.

00:39:45.610 --> 00:39:46.860
FRANK SALIM: Security's
very important.

00:39:49.440 --> 00:39:52.020
PETER LUBBERS: Let's take
another quick question from

00:39:52.020 --> 00:39:52.600
the moderator.

00:39:52.600 --> 00:39:54.930
So from Frank G. in New York.

00:39:54.930 --> 00:39:58.160
We have, what is the
relationship between WebRTC

00:39:58.160 --> 00:39:59.140
and WebSocket.

00:39:59.140 --> 00:40:02.340
And we talked about this
briefly before.

00:40:02.340 --> 00:40:02.760
FRANK SALIM: Yeah.

00:40:02.760 --> 00:40:05.840
This comes up a lot, because the
one-sentence description

00:40:05.840 --> 00:40:07.320
of WebRTC is this real-time

00:40:07.320 --> 00:40:08.750
communication feature for browsers.

00:40:08.750 --> 00:40:11.130
And the one-sentence description
of WebSocket is a

00:40:11.130 --> 00:40:13.550
real-time communication
feature for browsers.

00:40:13.550 --> 00:40:16.200
So the headline is
very similar.

00:40:16.200 --> 00:40:19.050
But WebSocket has a
client-server model.

00:40:19.050 --> 00:40:21.150
It's a very data-centric
use case.

00:40:21.150 --> 00:40:25.450
And WebRTC is peer-to-peer with
a really heavy focus on

00:40:25.450 --> 00:40:26.520
real-time media.

00:40:26.520 --> 00:40:27.950
That's what it's really
designed for.

00:40:27.950 --> 00:40:28.230
PETER LUBBERS: Right.

00:40:28.230 --> 00:40:28.610
Video, audio.

00:40:28.610 --> 00:40:30.720
FRANK SALIM: And it supports
peer-to-peer data with

00:40:30.720 --> 00:40:32.910
optional reliability.

00:40:32.910 --> 00:40:34.810
And so there are some
overlapping use cases.

00:40:34.810 --> 00:40:37.120
But they're really on the
margins of what they're

00:40:37.120 --> 00:40:38.640
designed for.

00:40:38.640 --> 00:40:39.100
PETER LUBBERS: Right.

00:40:39.100 --> 00:40:40.870
Cool.

00:40:40.870 --> 00:40:43.090
Actually, speaking of security,
what type of

00:40:43.090 --> 00:40:45.820
security should big companies
consider when offering a

00:40:45.820 --> 00:40:48.800
persistent connection to their
back end services?

00:40:48.800 --> 00:40:50.050
Also from Frank in New York.

00:40:52.770 --> 00:40:55.640
FRANK SALIM: Well, should big
companies offer connections

00:40:55.640 --> 00:40:57.230
directly to their back
end services?

00:40:57.230 --> 00:40:59.670
PETER LUBBERS: That's
a good question.

00:40:59.670 --> 00:41:01.480
FRANK SALIM: Well, first of
all, should they offer

00:41:01.480 --> 00:41:02.540
connections directly to
the back end services?

00:41:02.540 --> 00:41:03.200
PETER LUBBERS: Let's
take a step back.

00:41:03.200 --> 00:41:07.710
So what are some of the
WebSocket security

00:41:07.710 --> 00:41:10.950
considerations like you talked
about in the book?

00:41:10.950 --> 00:41:13.120
What does it boil down to?

00:41:13.120 --> 00:41:15.180
FRANK SALIM: So it has
transport-level security, much

00:41:15.180 --> 00:41:18.350
like HTTPS with WebSocket
Secure, the

00:41:18.350 --> 00:41:21.110
WSS scheme over TLS.

00:41:21.110 --> 00:41:23.480
And it starts with an HTTP
connection, so you have

00:41:23.480 --> 00:41:25.250
headers there that you can
use for authentication.

00:41:25.250 --> 00:41:27.560
You can use cookies.

00:41:27.560 --> 00:41:30.690
And then if you use it as a
transport-layer protocol,

00:41:30.690 --> 00:41:32.240
that's basically what you get.

00:41:32.240 --> 00:41:35.260
You can have application-level
security on top, basically

00:41:35.260 --> 00:41:36.160
bring your own.

00:41:36.160 --> 00:41:40.860
Otherwise, it's a pipe which
can be encrypted.

00:41:40.860 --> 00:41:42.350
PETER LUBBERS: Anything
to add?

00:41:42.350 --> 00:41:44.040
PETER MOSKOVITS: And then
there are a number of

00:41:44.040 --> 00:41:47.840
additional security-related
capabilities that

00:41:47.840 --> 00:41:50.270
some servers offer.

00:41:50.270 --> 00:41:52.680
So when it comes to kind of
real-life deployments, then

00:41:52.680 --> 00:41:56.910
you may be interested in SSO
integration, Kerberos

00:41:56.910 --> 00:41:57.305
integration.

00:41:57.305 --> 00:42:04.280
You may be interested in
protecting your environment.

00:42:04.280 --> 00:42:08.120
There are some ways of
establishing a WebSocket

00:42:08.120 --> 00:42:10.540
connection without opening
up any inbound

00:42:10.540 --> 00:42:12.890
ports on your firewall.

00:42:12.890 --> 00:42:18.000
So there's a large number of
things that you can deploy and

00:42:18.000 --> 00:42:22.520
you can consider using when you
want to basically offer

00:42:22.520 --> 00:42:25.190
these services to the web.

00:42:25.190 --> 00:42:29.870
PETER LUBBERS: So once you get
into this enterprise scenario,

00:42:29.870 --> 00:42:33.760
does WebSocket offer anything
specifically to go through

00:42:33.760 --> 00:42:36.890
load balancers, firewalls,
by itself?

00:42:36.890 --> 00:42:40.280
Or how should you
consider that?

00:42:40.280 --> 00:42:42.380
That's pretty common in an
enterprise scenario, right?

00:42:42.380 --> 00:42:42.840
PETER MOSKOVITS: Right.

00:42:42.840 --> 00:42:47.500
So this is a major challenge,
because the plain WebSocket

00:42:47.500 --> 00:42:52.310
connection very often gets cut
off by these proxies and

00:42:52.310 --> 00:42:54.200
routers and firewalls.

00:42:54.200 --> 00:42:58.580
So one typical thing that
improves the penetration is

00:42:58.580 --> 00:43:01.300
when you use WebSocket Secure,
when you tunnel your WebSocket

00:43:01.300 --> 00:43:05.210
connection over TLS then
it gets a lot better.

00:43:05.210 --> 00:43:09.210
But even that doesn't get
you beyond 90% or 95%.

00:43:09.210 --> 00:43:12.410
So at that point the question
is whether you can afford to

00:43:12.410 --> 00:43:16.300
lose 5% or 10% of your potential
users or customers

00:43:16.300 --> 00:43:19.900
or whether you want to have
complete coverage.

00:43:19.900 --> 00:43:21.900
And again, this is
something where

00:43:21.900 --> 00:43:23.440
implementations can differ.

00:43:23.440 --> 00:43:25.290
So there are various
solutions.

00:43:25.290 --> 00:43:28.510
You can fall back
to emulation.

00:43:28.510 --> 00:43:32.690
And if you do that, then there
are ways you can penetrate

00:43:32.690 --> 00:43:34.090
these intermediaries.

00:43:34.090 --> 00:43:34.700
PETER LUBBERS: OK.

00:43:34.700 --> 00:43:35.950
Cool.

00:43:37.450 --> 00:43:38.210
We'll take another question.

00:43:38.210 --> 00:43:43.070
So that's basically the question
I just answered.

00:43:43.070 --> 00:43:43.980
I didn't see that before.

00:43:43.980 --> 00:43:45.940
So network entities, firewalls,
and proxies are not

00:43:45.940 --> 00:43:46.860
very friendly to WebSocket.

00:43:46.860 --> 00:43:49.070
What's the best way to use
WebSocket for connections that

00:43:49.070 --> 00:43:51.010
traverse those entities?

00:43:51.010 --> 00:43:54.550
So I guess the answer use WSS,
the WebSocket Secure.

00:43:54.550 --> 00:43:56.640
PETER MOSKOVITS: That's a good
starting point, yes.

00:43:56.640 --> 00:43:57.730
FRANK SALIM: That's a great
starting point.

00:43:57.730 --> 00:43:58.890
PETER MOSKOVITS: Yes.

00:43:58.890 --> 00:44:00.070
FRANK SALIM: Much better
[INAUDIBLE] with an encrypted

00:44:00.070 --> 00:44:02.090
connection.

00:44:02.090 --> 00:44:04.730
PETER MOSKOVITS: Basically,
very much like SPDY, you

00:44:04.730 --> 00:44:09.060
probably would not want to have
a WebSocket connection,

00:44:09.060 --> 00:44:11.615
just plain WebSocket connection,
unless you are in

00:44:11.615 --> 00:44:13.975
a development or testing
environment.

00:44:13.975 --> 00:44:16.350
In a production environment,
you do want to have TLS.

00:44:16.350 --> 00:44:18.580
FRANK SALIM: Some otherwise
controlled network.

00:44:18.580 --> 00:44:20.290
PETER MOSKOVITS: Exactly.

00:44:20.290 --> 00:44:21.220
PETER LUBBERS: Cool.

00:44:21.220 --> 00:44:24.230
So there's a question from
Shafir in Israel.

00:44:24.230 --> 00:44:26.940
What about better tooling
to debug problems in the

00:44:26.940 --> 00:44:30.430
WebSocket protocol, such as
bad Unicode encoding.

00:44:30.430 --> 00:44:32.790
If the server generates a
WebSocket message the browser

00:44:32.790 --> 00:44:35.110
doesn't like, it's almost
impossible to find where the

00:44:35.110 --> 00:44:35.560
problem is.

00:44:35.560 --> 00:44:39.260
Have you run into that?

00:44:39.260 --> 00:44:42.880
FRANK SALIM: I have
not run into that.

00:44:42.880 --> 00:44:43.960
I can imagine the problem.

00:44:43.960 --> 00:44:47.830
So WebSocket text messages are
required to be UTF-8 encoded.

00:44:47.830 --> 00:44:51.420
So if there's some
other encoding--

00:44:51.420 --> 00:44:55.540
and ASCII will fly by, because
ASCII is a valid subset.

00:44:55.540 --> 00:44:59.060
So most the time during
development you might be not

00:44:59.060 --> 00:45:01.910
encoding and get away with
it on your server.

00:45:01.910 --> 00:45:05.780
But if you have a UTF-16
encoded string in your

00:45:05.780 --> 00:45:08.730
WebSocket payload, the browser
will reject that message.

00:45:08.730 --> 00:45:10.660
PETER LUBBERS: But wouldn't
that be like a server

00:45:10.660 --> 00:45:13.580
configuration issue in
general, or is that

00:45:13.580 --> 00:45:14.100
something--

00:45:14.100 --> 00:45:16.860
because your client is going
to speak-- your browser is

00:45:16.860 --> 00:45:18.160
going to do the right
thing, right?

00:45:18.160 --> 00:45:18.660
FRANK SALIM: Yes.

00:45:18.660 --> 00:45:19.690
That's a server bug.

00:45:19.690 --> 00:45:24.260
But it seems like it could be
a reasonably easy mistake to

00:45:24.260 --> 00:45:25.160
make on the server.

00:45:25.160 --> 00:45:26.080
PETER LUBBERS: I see.

00:45:26.080 --> 00:45:26.720
Right.

00:45:26.720 --> 00:45:28.400
Is there currently
something in, for

00:45:28.400 --> 00:45:29.300
example, Chrome Dev Tools?

00:45:29.300 --> 00:45:33.640
What would happen if you got
a message like that?

00:45:33.640 --> 00:45:35.110
FRANK SALIM: It might just close
the connection silently

00:45:35.110 --> 00:45:37.430
or it might surface
some error.

00:45:37.430 --> 00:45:41.890
So I guess the question is,
can the browsers complain

00:45:41.890 --> 00:45:45.080
about that more coherently?

00:45:45.080 --> 00:45:48.590
PETER LUBBERS: Would Wireshark
be an answer here?

00:45:48.590 --> 00:45:51.280
What do you think?

00:45:51.280 --> 00:45:51.520
Maybe?

00:45:51.520 --> 00:45:52.550
FRANK SALIM: I'm not sure.

00:45:52.550 --> 00:45:52.810
Maybe.

00:45:52.810 --> 00:45:53.550
PETER LUBBERS: OK.

00:45:53.550 --> 00:45:54.650
Cool.

00:45:54.650 --> 00:45:55.710
All right.

00:45:55.710 --> 00:45:58.940
Another question from Shafir
again in Israel.

00:45:58.940 --> 00:46:02.210
When will we have built-in
compression for WebSocket?

00:46:02.210 --> 00:46:05.330
So I think that was a proposal,
right, for something

00:46:05.330 --> 00:46:10.390
to be added on top of the--

00:46:10.390 --> 00:46:10.800
FRANK SALIM: Yeah.

00:46:10.800 --> 00:46:14.600
There's a draft for compression
on WebSockets.

00:46:14.600 --> 00:46:17.600
I don't know the status
or direction of that.

00:46:17.600 --> 00:46:20.120
But it's under discussion.

00:46:20.120 --> 00:46:22.120
PETER LUBBERS: Is there any
implementation that you're

00:46:22.120 --> 00:46:27.490
aware of that has done
anything with that?

00:46:27.490 --> 00:46:28.730
FRANK SALIM: I wouldn't know.

00:46:28.730 --> 00:46:28.946
PETER LUBBERS: Right.

00:46:28.946 --> 00:46:30.100
OK.

00:46:30.100 --> 00:46:31.350
All right.

00:46:32.900 --> 00:46:37.130
Lena in LA asked, is there a
good way to gracefully degrade

00:46:37.130 --> 00:46:39.980
the use of WebSocket on browsers
that are capable of

00:46:39.980 --> 00:46:41.180
versus those that are not?

00:46:41.180 --> 00:46:46.150
So this is where it comes into
like polyfills for WebSocket.

00:46:46.150 --> 00:46:49.680
So, Vanessa, do you have a--

00:46:49.680 --> 00:46:52.330
VANESSA WANG: Well, we do talk
about that a little bit in our

00:46:52.330 --> 00:46:53.240
deployment chapter.

00:46:53.240 --> 00:46:55.650
We talk an emulation.

00:46:55.650 --> 00:46:58.590
The company we work, Kaazing,
actually does provide some

00:46:58.590 --> 00:47:01.560
libraries out of the box
to help with that.

00:47:01.560 --> 00:47:03.960
And it's designed for any
platform that you're using,

00:47:03.960 --> 00:47:06.630
like JavaScript, .NET, Flash.

00:47:06.630 --> 00:47:09.757
There's also other ways to
do it that Peter can

00:47:09.757 --> 00:47:11.110
probably speak to.

00:47:11.110 --> 00:47:13.655
PETER LUBBERS: Do you have any
libraries out there, like I

00:47:13.655 --> 00:47:17.680
think nojs comes
with Socket.IO.

00:47:17.680 --> 00:47:17.960
PETER MOSKOVITS: Right.

00:47:17.960 --> 00:47:18.140
Right.

00:47:18.140 --> 00:47:24.310
So there's a wide variety
of WebSocket servers and

00:47:24.310 --> 00:47:25.130
libraries out there.

00:47:25.130 --> 00:47:28.860
Actually in the book, we do have
an appendix where we list

00:47:28.860 --> 00:47:31.410
those that were available
when we had to submit

00:47:31.410 --> 00:47:32.960
the book for print.

00:47:32.960 --> 00:47:35.600
And many of them do
have better or

00:47:35.600 --> 00:47:38.870
worse fallback or emulation.

00:47:38.870 --> 00:47:43.020
Again, it boils down to how
important it is for you,

00:47:43.020 --> 00:47:45.600
whether you're OK with a certain
percentage of your

00:47:45.600 --> 00:47:51.320
users or not and where that
threshold is for you.

00:47:51.320 --> 00:47:52.460
PETER LUBBERS: So another
question from

00:47:52.460 --> 00:47:54.980
Shafir, maybe for Frank.

00:47:54.980 --> 00:47:58.760
What is the default binary type
for a WebSocket blob when

00:47:58.760 --> 00:48:00.990
that blob has no MIME type?

00:48:00.990 --> 00:48:02.490
Does it make it useless?

00:48:02.490 --> 00:48:05.406
Doesn't that make it useless?

00:48:05.406 --> 00:48:07.490
FRANK SALIM: That's an
interesting question.

00:48:07.490 --> 00:48:13.170
So WebSocket messages don't
have MIME types.

00:48:13.170 --> 00:48:17.170
But your higher-level protocol
can contain that information.

00:48:17.170 --> 00:48:19.960
So you could have some
description of the content

00:48:19.960 --> 00:48:23.310
type in a previous message or
in some framing around that

00:48:23.310 --> 00:48:28.980
blob or some headers that you
send along before reading the

00:48:28.980 --> 00:48:32.290
blob in that can tell the
application what to do with

00:48:32.290 --> 00:48:34.440
that blob, whether to
put into a video

00:48:34.440 --> 00:48:37.290
or an image or texture.

00:48:37.290 --> 00:48:41.650
PETER LUBBERS: Is that how you
would typically code that up?

00:48:41.650 --> 00:48:42.040
FRANK SALIM: Yeah.

00:48:42.040 --> 00:48:44.770
I think it would be atypical to
just blast blobs from the

00:48:44.770 --> 00:48:46.820
server and expect the client to
know what to do with them.

00:48:46.820 --> 00:48:49.990
Although I guess that's
possible, because the server

00:48:49.990 --> 00:48:53.270
and the client might both
be under the same--

00:48:53.270 --> 00:48:54.400
control the same application.

00:48:54.400 --> 00:48:57.208
The client could know what to
expect the encoding of the

00:48:57.208 --> 00:48:58.160
blob to be.

00:48:58.160 --> 00:48:58.510
PETER LUBBERS: Right.

00:48:58.510 --> 00:49:01.760
So let's take a step
back here.

00:49:01.760 --> 00:49:03.770
The default binary
type is blob.

00:49:03.770 --> 00:49:06.060
So what other types
can you use?

00:49:06.060 --> 00:49:09.030
And how hard is it
to set that?

00:49:09.030 --> 00:49:10.380
FRANK SALIM: Setting
is pretty easy.

00:49:10.380 --> 00:49:13.360
There's a property on the
WebSocket object you set to

00:49:13.360 --> 00:49:14.390
the name of the type you want.

00:49:14.390 --> 00:49:17.786
The other option is you can
have a typed array.

00:49:17.786 --> 00:49:18.137
PETER LUBBERS: Right.

00:49:18.137 --> 00:49:19.658
OK.

00:49:19.658 --> 00:49:20.710
All right.

00:49:20.710 --> 00:49:23.950
So a question from Stephen
Kagel in San Francisco.

00:49:23.950 --> 00:49:26.250
Are content delivery networks
able to cache

00:49:26.250 --> 00:49:28.690
WebSockets at all?

00:49:28.690 --> 00:49:31.230
For instance, if I send a
request to retrieve some data

00:49:31.230 --> 00:49:34.480
through the socket, will a CDN
be able to cache that response

00:49:34.480 --> 00:49:34.930
if appropriate?

00:49:34.930 --> 00:49:36.445
So I think that's a really
good question.

00:49:39.220 --> 00:49:40.450
Answers?

00:49:40.450 --> 00:49:41.210
PETER MOSKOVITS: I don't
have an answer.

00:49:41.210 --> 00:49:44.260
I think we'll have to get
back to him on that.

00:49:44.260 --> 00:49:44.740
PETER LUBBERS: Yeah.

00:49:44.740 --> 00:49:47.190
But I mean typically
this would be like

00:49:47.190 --> 00:49:49.690
real-time data, right?

00:49:49.690 --> 00:49:55.920
But I guess it sounds like a
pretty interesting use case

00:49:55.920 --> 00:49:59.100
for public messages something
could be cached.

00:49:59.100 --> 00:50:01.670
OK.

00:50:01.670 --> 00:50:03.840
So we'll get back
to you on that.

00:50:03.840 --> 00:50:08.680
WebSocket plus UDP-based
functionality, asked Oswald in

00:50:08.680 --> 00:50:10.570
San Francisco.

00:50:10.570 --> 00:50:12.880
What are your thoughts?

00:50:12.880 --> 00:50:15.590
FRANK SALIM: Well, there's data
channels in WebRTC, which

00:50:15.590 --> 00:50:21.350
is a WebSocket-like API with
a UDP-based protocol.

00:50:21.350 --> 00:50:23.955
PETER LUBBERS: That's
part of WebRTC.

00:50:23.955 --> 00:50:24.350
Yeah.

00:50:24.350 --> 00:50:25.320
Exactly.

00:50:25.320 --> 00:50:27.980
OK.

00:50:27.980 --> 00:50:31.940
PETER MOSKOVITS: But WebSocket
doesn't support UDP.

00:50:31.940 --> 00:50:33.440
FRANK SALIM: No.

00:50:33.440 --> 00:50:36.110
WebSocket is on top of TCP.

00:50:36.110 --> 00:50:38.440
Once it's no longer on TCP, it
wouldn't be a WebSocket.

00:50:38.440 --> 00:50:39.040
PETER LUBBERS: Right.

00:50:39.040 --> 00:50:41.510
So that's pretty fundamental.

00:50:41.510 --> 00:50:41.670
Yeah.

00:50:41.670 --> 00:50:45.150
I guess the next step would
then be to look to explore

00:50:45.150 --> 00:50:47.860
WebRTC and the data
channels, right?

00:50:47.860 --> 00:50:49.220
So there's another question.

00:50:49.220 --> 00:50:52.760
How do WebSockets work
with proxies?

00:50:52.760 --> 00:50:53.900
Brandon Zachary.

00:50:53.900 --> 00:50:56.420
So we've just discussed
that a little bit.

00:50:56.420 --> 00:50:59.870
I guess the main thing is that
proxy servers typically tend

00:50:59.870 --> 00:51:03.110
to strip some of the
headers off.

00:51:03.110 --> 00:51:08.600
And there's a pretty extensive
diagram in the book that shows

00:51:08.600 --> 00:51:10.490
the sort of possible scenarios
through that.

00:51:10.490 --> 00:51:14.670
So definitely check
that out, Brandon.

00:51:14.670 --> 00:51:19.850
Steven, again, does holding a
WebSocket connection open

00:51:19.850 --> 00:51:23.490
involve holding a phone
radio connection open?

00:51:23.490 --> 00:51:28.020
If so, does this have much of
an effect on battery life?

00:51:28.020 --> 00:51:30.910
That's also a pretty
good question.

00:51:30.910 --> 00:51:31.200
PETER MOSKOVITS: Yes.

00:51:31.200 --> 00:51:34.000
So actually we haven't
specifically talked about

00:51:34.000 --> 00:51:35.000
mobile devices.

00:51:35.000 --> 00:51:39.210
But clearly slowly we are
getting to a point where the

00:51:39.210 --> 00:51:41.970
web is accessed through more
mobile devices than desktop

00:51:41.970 --> 00:51:45.300
devices and how it affects
this whole WebSocket and

00:51:45.300 --> 00:51:46.540
always-on world.

00:51:46.540 --> 00:51:49.910
So there are a number of
challenges with mobile.

00:51:49.910 --> 00:51:52.710
I mean, the classic ones in
the HTML5 world would be

00:51:52.710 --> 00:51:53.640
screen real estate.

00:51:53.640 --> 00:51:56.250
But when it comes to
communication, one is the

00:51:56.250 --> 00:52:00.020
level of connectivity that you
have, whether you can stay

00:52:00.020 --> 00:52:01.170
connected all the time.

00:52:01.170 --> 00:52:03.410
And very often when you are
driving through a tunnel or

00:52:03.410 --> 00:52:07.300
you are flying, you do
get disconnected.

00:52:07.300 --> 00:52:10.670
So that is one challenge, what
can you do about that?

00:52:10.670 --> 00:52:16.020
And briefly the answer to that
challenge is that the

00:52:16.020 --> 00:52:19.800
WebSocket layer does not
provide any reconnect

00:52:19.800 --> 00:52:20.380
capabilities.

00:52:20.380 --> 00:52:22.240
So it's a higher level that
would have to provide that

00:52:22.240 --> 00:52:25.210
functionality, either a higher
level protocol, or you have to

00:52:25.210 --> 00:52:27.320
do that on the application
level.

00:52:27.320 --> 00:52:32.420
And to answer the question
specifically on battery life,

00:52:32.420 --> 00:52:35.430
if you have a connection
open, that does affect

00:52:35.430 --> 00:52:36.920
your battery life.

00:52:36.920 --> 00:52:39.860
The amount of data that you are
transferring does affect

00:52:39.860 --> 00:52:41.080
your battery life.

00:52:41.080 --> 00:52:46.620
So in an ideal world you should
be aware on the server

00:52:46.620 --> 00:52:49.010
side what kind of device you
are talking to, what

00:52:49.010 --> 00:52:55.010
capabilities it has, and talk
to that device accordingly.

00:52:55.010 --> 00:52:58.870
Let's say you have some
streaming kind of application.

00:52:58.870 --> 00:53:01.750
You don't necessarily want to
send 100 or 200 messages per

00:53:01.750 --> 00:53:06.240
second to a mobile device or
you can have a kind of a

00:53:06.240 --> 00:53:09.110
slowdown, slowing down of the
messages as time goes by.

00:53:09.110 --> 00:53:11.020
So there are a number of
strategies that you can use.

00:53:11.020 --> 00:53:15.200
But it's definitely something
that you need to have in mind

00:53:15.200 --> 00:53:17.256
and design your apps for.

00:53:17.256 --> 00:53:19.200
PETER LUBBERS: Perfect.

00:53:19.200 --> 00:53:21.680
So here's an interesting
question.

00:53:21.680 --> 00:53:25.530
Fabito asks, what are the
main advantages of

00:53:25.530 --> 00:53:28.000
WebSockets over Bayeux?

00:53:28.000 --> 00:53:29.600
Remember Bayeux, Frank?

00:53:29.600 --> 00:53:31.190
FRANK SALIM: I very vaguely
remember Bayeux from the

00:53:31.190 --> 00:53:32.170
distant past.

00:53:32.170 --> 00:53:35.270
PETER LUBBERS: I think as I
recall Bayeux was sort of

00:53:35.270 --> 00:53:36.930
pub/sub-based?

00:53:36.930 --> 00:53:38.630
FRANK SALIM: Pub/sub,
Comet stack?

00:53:38.630 --> 00:53:40.490
PETER LUBBERS: Right.

00:53:40.490 --> 00:53:41.590
It's been a while.

00:53:41.590 --> 00:53:44.710
FRANK SALIM: Well, WebSocket is
in browsers, standardized.

00:53:44.710 --> 00:53:47.530
I'm sure it has a number of
technical advantages, but

00:53:47.530 --> 00:53:49.750
without remembering the details
of Bayeux, that's

00:53:49.750 --> 00:53:51.320
going to be hard to
come up with.

00:53:51.320 --> 00:53:53.060
PETER LUBBERS: Well, I think
you hit on it pretty well,

00:53:53.060 --> 00:53:57.780
like WebSocket is the standard
and is implemented everywhere.

00:53:57.780 --> 00:54:01.030
And it's not hard, as you've
shown in the book, to really

00:54:01.030 --> 00:54:07.130
build some great applications
very quickly using some of

00:54:07.130 --> 00:54:09.440
these other pub/sub protocols
on top of that stack.

00:54:09.440 --> 00:54:11.920
PETER MOSKOVITS: Yeah. pub/sub
makes a giant difference.

00:54:11.920 --> 00:54:15.350
And one point I wanted to make
earlier, actually, is that the

00:54:15.350 --> 00:54:18.100
WebSocket API is very easy
to use and it's very

00:54:18.100 --> 00:54:19.150
straightforward.

00:54:19.150 --> 00:54:21.310
At the same time, it's very
low level as well.

00:54:21.310 --> 00:54:25.890
And using something like pub/sub
or something that is

00:54:25.890 --> 00:54:30.530
the right tool for the job
is highly recommended.

00:54:30.530 --> 00:54:33.580
You can get your very
first, very easy

00:54:33.580 --> 00:54:34.610
chat app up and running.

00:54:34.610 --> 00:54:37.540
But when it comes to doing
something for real, you do

00:54:37.540 --> 00:54:40.920
want to use some more
targeted tools.

00:54:40.920 --> 00:54:42.210
And pub/sub is a great way.

00:54:42.210 --> 00:54:45.130
Actually, most of the demos
that we showed in the

00:54:45.130 --> 00:54:47.990
beginning use some pub/sub.

00:54:47.990 --> 00:54:50.900
And in the book, we are
talking about STOMP

00:54:50.900 --> 00:54:52.630
specifically.

00:54:52.630 --> 00:54:55.880
And we use ActiveMQ as
a message broker.

00:54:55.880 --> 00:54:57.820
PETER LUBBERS: What does
STOMP stand for?

00:54:57.820 --> 00:55:00.100
PETER MOSKOVITS: Simple or
Streaming Text-Oriented

00:55:00.100 --> 00:55:05.800
Message Protocol, which is a
very simple protocol, despite

00:55:05.800 --> 00:55:09.370
the fact that it has the word
simple in its name.

00:55:09.370 --> 00:55:11.280
So it is a simple protocol.

00:55:11.280 --> 00:55:12.180
And you can learn.

00:55:12.180 --> 00:55:15.680
And the demo that we give,
actually it's a game that's in

00:55:15.680 --> 00:55:19.540
the VM that is a
rock-paper-scissors game.

00:55:19.540 --> 00:55:22.580
So the idea is similar to what
we described earlier on.

00:55:22.580 --> 00:55:27.060
So there are two players in
two separate browsers.

00:55:27.060 --> 00:55:32.260
And they connect to each other
through a WebSocket server.

00:55:32.260 --> 00:55:34.990
And they're publishing and
subscribing to these messages.

00:55:34.990 --> 00:55:38.510
And that's how they
communicate.

00:55:38.510 --> 00:55:39.810
PETER LUBBERS: So another
question from

00:55:39.810 --> 00:55:41.320
Frank in New York.

00:55:41.320 --> 00:55:44.660
Is WebSocket a replacement
for REST?

00:55:44.660 --> 00:55:45.680
Any thoughts on that?

00:55:45.680 --> 00:55:48.050
FRANK SALIM: So I
would say no.

00:55:48.050 --> 00:55:48.930
And why?

00:55:48.930 --> 00:55:51.090
Because they're pretty much
apples and oranges.

00:55:51.090 --> 00:55:53.880
REST is an architectural
style and WebSocket

00:55:53.880 --> 00:55:55.320
is a network protocol.

00:55:55.320 --> 00:55:58.550
And you can build applications
in a RESTful style on top of

00:55:58.550 --> 00:56:00.810
WebSockets.

00:56:00.810 --> 00:56:03.060
PETER LUBBERS: Are there
examples of that out there

00:56:03.060 --> 00:56:05.920
that you know of?

00:56:05.920 --> 00:56:06.780
FRANK SALIM: I would
imagine there are

00:56:06.780 --> 00:56:08.030
examples of that out there.

00:56:10.640 --> 00:56:14.130
PETER LUBBERS: Efram from the
Canary Islands in Spain, what

00:56:14.130 --> 00:56:17.570
is the best way to send binary
data through a WebSocket

00:56:17.570 --> 00:56:19.800
connection?

00:56:19.800 --> 00:56:23.350
That should be pretty
straightforward, right?

00:56:23.350 --> 00:56:23.610
FRANK SALIM: Yeah.

00:56:23.610 --> 00:56:26.250
You have your JavaScript object
representing the binary

00:56:26.250 --> 00:56:28.500
data and you call
websocket.send.

00:56:28.500 --> 00:56:29.770
You do have a choice of types.

00:56:29.770 --> 00:56:33.660
But really it's the same on the
network, so whatever type

00:56:33.660 --> 00:56:35.307
makes the most sense in
your application on

00:56:35.307 --> 00:56:37.490
the JavaScript side.

00:56:37.490 --> 00:56:37.940
PETER LUBBERS: Yeah.

00:56:37.940 --> 00:56:40.070
But I think a lot of the
examples that are out there

00:56:40.070 --> 00:56:42.090
are still very much
text-based.

00:56:42.090 --> 00:56:43.590
PETER MOSKOVITS: Actually, we do
have an example in the book

00:56:43.590 --> 00:56:45.560
that exercises this.

00:56:45.560 --> 00:56:48.420
When you drop the image in the
browser and it's sent and it's

00:56:48.420 --> 00:56:49.950
sent back again.

00:56:49.950 --> 00:56:50.025
FRANK SALIM: Yeah.

00:56:50.025 --> 00:56:53.576
We have examples in the
book of using--

00:56:53.576 --> 00:56:59.720
I think that was using a blob,
maybe the file reader API, to

00:56:59.720 --> 00:57:00.910
get the contents of the image.

00:57:00.910 --> 00:57:04.900
And once you have the binary
data available, just call on

00:57:04.900 --> 00:57:09.380
websocket.send on a built-in,
browser-supported WebSocket.

00:57:09.380 --> 00:57:09.660
PETER LUBBERS: Yeah.

00:57:09.660 --> 00:57:13.370
I think mainly because in the
early days of WebSocket it was

00:57:13.370 --> 00:57:14.840
a text-based protocol.

00:57:14.840 --> 00:57:16.190
So I think--

00:57:16.190 --> 00:57:16.600
FRANK SALIM: Right.

00:57:16.600 --> 00:57:18.340
And I think some of the
libraries, some of the

00:57:18.340 --> 00:57:21.630
polyfills don't support binary
or don't support binary in all

00:57:21.630 --> 00:57:22.290
situations.

00:57:22.290 --> 00:57:25.080
And if you can only send
text-based data, then you have

00:57:25.080 --> 00:57:26.160
to encode it in some way.

00:57:26.160 --> 00:57:28.460
But if you're using standard
WebSockets, you don't have to

00:57:28.460 --> 00:57:29.170
really compromise there.

00:57:29.170 --> 00:57:31.070
You can just send a
binary message.

00:57:31.070 --> 00:57:33.180
PETER LUBBERS: Like a data URI
or something you would have to

00:57:33.180 --> 00:57:33.770
use instead.

00:57:33.770 --> 00:57:34.370
FRANK SALIM: Yeah.

00:57:34.370 --> 00:57:35.240
Base 64.

00:57:35.240 --> 00:57:35.840
PETER MOSKOVITS:
Base 64, yeah.

00:57:35.840 --> 00:57:37.830
PETER LUBBERS: OK.

00:57:37.830 --> 00:57:41.090
So Vlad from London asked, what
are the most important

00:57:41.090 --> 00:57:43.520
differences between WebSocket
and Flash sockets?

00:57:43.520 --> 00:57:45.760
So we mentioned earlier that
were all these other

00:57:45.760 --> 00:57:47.300
alternatives.

00:57:47.300 --> 00:57:49.230
I guess you don't have
to install a plug-in.

00:57:49.230 --> 00:57:53.020
FRANK SALIM: Flash has support
for opening TCP connections

00:57:53.020 --> 00:57:55.780
with the flash net socket API.

00:57:55.780 --> 00:57:58.890
And it's not really anything
like a WebSocket.

00:57:58.890 --> 00:58:01.530
It doesn't have an HTTP
connection up front.

00:58:01.530 --> 00:58:05.390
It doesn't have any kind
of framing of the data.

00:58:05.390 --> 00:58:09.510
But it does have a separate
out-of-band request to enforce

00:58:09.510 --> 00:58:13.530
the security policy in sort of
a strange, nonstandard way.

00:58:17.965 --> 00:58:18.410
PETER MOSKOVITS: Yeah.

00:58:18.410 --> 00:58:23.850
So in a nutshell, if you have
socket connections from Flash

00:58:23.850 --> 00:58:26.870
or Java, you should seriously
take a look at WebSocket,

00:58:26.870 --> 00:58:29.640
because that is the
way you want to

00:58:29.640 --> 00:58:31.365
move your apps forward.

00:58:34.820 --> 00:58:38.880
I think one more thing on the
Flash socket one is that in

00:58:38.880 --> 00:58:41.670
order for it to work if you are
behind firewalls, you have

00:58:41.670 --> 00:58:44.470
to open a port on those.

00:58:44.470 --> 00:58:48.290
With WebSocket, by default
WebSocket being on port 80 and

00:58:48.290 --> 00:58:51.980
port 443, you don't
need to do that.

00:58:51.980 --> 00:58:53.440
So that's an extra level of the

00:58:53.440 --> 00:58:55.240
web-friendliness of WebSocket.

00:58:55.240 --> 00:58:57.030
PETER LUBBERS: Pretty big.

00:58:57.030 --> 00:58:59.570
PETER MOSKOVITS: That's
a big one.

00:58:59.570 --> 00:58:59.960
PETER LUBBERS: Right.

00:58:59.960 --> 00:59:00.230
OK.

00:59:00.230 --> 00:59:04.600
So Don from San Diego is asking
is WebSocket path to

00:59:04.600 --> 00:59:09.830
using Bonjour zeroconf
using HTML5?

00:59:09.830 --> 00:59:11.120
PETER MOSKOVITS: I'm not sure.

00:59:11.120 --> 00:59:12.737
PETER LUBBERS: Any
thoughts on that?

00:59:12.737 --> 00:59:15.420
I'm not too familiar
with that.

00:59:15.420 --> 00:59:18.120
FRANK SALIM: Yeah.

00:59:18.120 --> 00:59:20.060
That's a protocol
for configuring

00:59:20.060 --> 00:59:21.310
devices on a local network.

00:59:24.190 --> 00:59:26.505
PETER MOSKOVITS: That's what
Apple uses, right?

00:59:26.505 --> 00:59:26.853
FRANK SALIM: Yeah.

00:59:26.853 --> 00:59:28.190
I think that--

00:59:28.190 --> 00:59:29.440
yeah.

00:59:32.970 --> 00:59:36.440
Personally I don't know if
that would be a path to

00:59:36.440 --> 00:59:39.410
letting web applications
participate with local network

00:59:39.410 --> 00:59:43.370
devices or if that would even be
desirable generally from a

00:59:43.370 --> 00:59:45.010
security standpoint.

00:59:45.010 --> 00:59:45.390
PETER LUBBERS: OK.

00:59:45.390 --> 00:59:49.040
Well, we can come
back to that.

00:59:49.040 --> 00:59:54.570
From Bangalore, NTRK, what is
the significance of the URL in

00:59:54.570 --> 00:59:55.220
WebSockets?

00:59:55.220 --> 00:59:58.781
And are they similar
to HTTP URLs?

00:59:58.781 --> 00:59:59.190
FRANK SALIM: Yeah.

00:59:59.190 --> 01:00:01.970
So since a WebSocket connection
starts with an HTTP

01:00:01.970 --> 01:00:05.140
request and response, that
is the URL to which

01:00:05.140 --> 01:00:07.130
the request is made.

01:00:07.130 --> 01:00:10.340
And yeah, it's an HTTP URL.

01:00:10.340 --> 01:00:11.280
PETER LUBBERS: Cool.

01:00:11.280 --> 01:00:13.330
So we've got a couple of other
questions and then

01:00:13.330 --> 01:00:15.230
we'll wrap it up.

01:00:15.230 --> 01:00:18.420
Maybe remind me to have the
coupon for the book.

01:00:18.420 --> 01:00:22.890
So are there any hardware
implementations that use

01:00:22.890 --> 01:00:29.050
WebSockets, from Fabito, any
hardware-based WebSockets?

01:00:29.050 --> 01:00:31.140
Interesting.

01:00:31.140 --> 01:00:32.170
PETER MOSKOVITS: I'm
sure there are.

01:00:32.170 --> 01:00:36.430
So there are all these little
devices out there Arduinos and

01:00:36.430 --> 01:00:39.050
the Pi, Raspberry Pi.

01:00:39.050 --> 01:00:39.530
Yeah.

01:00:39.530 --> 01:00:43.940
So we have played around
with those.

01:00:43.940 --> 01:00:48.190
There's nothing that would
stop these devices from

01:00:48.190 --> 01:00:50.060
speaking WebSocket.

01:00:50.060 --> 01:00:54.010
I can't think off the
top of my head.

01:00:54.010 --> 01:00:55.110
PETER LUBBERS: So we have
two more questions.

01:00:55.110 --> 01:00:56.890
Let's just quickly
run through them.

01:00:56.890 --> 01:00:58.890
John from San Diego.

01:00:58.890 --> 01:01:02.290
Why not use Socket.IO, which
provides the same functions

01:01:02.290 --> 01:01:04.903
and also falls back
to Flash and Ajax.

01:01:08.000 --> 01:01:11.250
I think, again, it comes back to
the standard, right, having

01:01:11.250 --> 01:01:12.800
the WebSocket standard

01:01:12.800 --> 01:01:15.280
implemented in all the browsers.

01:01:15.280 --> 01:01:16.820
Anything to add there?

01:01:16.820 --> 01:01:18.420
PETER MOSKOVITS: Why
not use Socket.IO?

01:01:18.420 --> 01:01:18.730
PETER LUBBERS: Yeah.

01:01:18.730 --> 01:01:20.140
Why not use Socket.IO?

01:01:20.140 --> 01:01:22.060
PETER MOSKOVITS: I think there's
a lot of people who

01:01:22.060 --> 01:01:26.980
use Socket.IO and it
suits their needs.

01:01:26.980 --> 01:01:32.660
So it's an excellent choice
in some cases.

01:01:32.660 --> 01:01:35.750
It's an open source,
free solution.

01:01:35.750 --> 01:01:41.270
So many people find that
as the right tool.

01:01:41.270 --> 01:01:46.050
What we found, what we saw was
we had a couple of customers

01:01:46.050 --> 01:01:49.920
and prospects who came to us--
we have a commercial product

01:01:49.920 --> 01:01:52.560
that scales to larger
enterprises and financial

01:01:52.560 --> 01:01:54.110
services at Kaazing.

01:01:54.110 --> 01:01:57.270
And what we found was that
there were certain corner

01:01:57.270 --> 01:02:00.430
cases that did not quite
work with Socket.IO.

01:02:00.430 --> 01:02:04.170
So they came to us and
asked for some help.

01:02:04.170 --> 01:02:10.520
But Socket.IO is the right tool
for many people and many

01:02:10.520 --> 01:02:12.570
companies out there.

01:02:12.570 --> 01:02:18.400
And basically Socket.IO has a
big role that it contributed

01:02:18.400 --> 01:02:20.870
to the success of
the technology.

01:02:20.870 --> 01:02:23.390
So there's a lot to
be said about it.

01:02:23.390 --> 01:02:24.410
FRANK SALIM: And Socket.IO
uses WebSocket.

01:02:24.410 --> 01:02:26.440
It's not exactly an either/or.

01:02:26.440 --> 01:02:28.460
It's one of the polyfill
libraries for communications

01:02:28.460 --> 01:02:30.690
that uses WebSocket as a
connection strategy.

01:02:30.690 --> 01:02:33.350
PETER MOSKOVITS: That's the
primary one, yeah, I think.

01:02:33.350 --> 01:02:33.630
PETER LUBBERS: All right.

01:02:33.630 --> 01:02:37.190
So if there's any other
questions, we'll

01:02:37.190 --> 01:02:38.840
take a look at them.

01:02:38.840 --> 01:02:41.770
And we'll put in some comments
after the show.

01:02:41.770 --> 01:02:43.460
We have to wrap it up.

01:02:43.460 --> 01:02:44.660
Two quick questions.

01:02:44.660 --> 01:02:48.110
What about any upcoming events
where I can learn more?

01:02:48.110 --> 01:02:52.470
I mean, of course, people can
buy the book but, where can we

01:02:52.470 --> 01:02:53.180
find you guys?

01:02:53.180 --> 01:02:55.030
And how can we get
more information?

01:02:55.030 --> 01:02:57.225
VANESSA WANG: We're doing a live
appearance on Thursday in

01:02:57.225 --> 01:03:00.570
San Francisco, for the San
Francisco HTML5 User Group.

01:03:00.570 --> 01:03:03.140
Ilya Grigorik, who wrote the
forward to our book, is going

01:03:03.140 --> 01:03:04.860
to be doing a talk and
performance, which will be a

01:03:04.860 --> 01:03:05.620
really great talk.

01:03:05.620 --> 01:03:07.990
And the three of us will be
presenting about the book and

01:03:07.990 --> 01:03:08.975
doing a book signing.

01:03:08.975 --> 01:03:09.270
PETER LUBBERS: Perfect.

01:03:09.270 --> 01:03:11.080
VANESSA WANG: So we'll be there
to answer questions and

01:03:11.080 --> 01:03:12.316
talk more about it.

01:03:12.316 --> 01:03:12.700
PETER LUBBERS: OK.

01:03:12.700 --> 01:03:13.930
And if people--

01:03:13.930 --> 01:03:14.620
PETER MOSKOVITS:
HTML5 Dev Con.

01:03:14.620 --> 01:03:15.330
VANESSA WANG: Yes.

01:03:15.330 --> 01:03:15.910
PETER LUBBERS: That's right.

01:03:15.910 --> 01:03:16.420
All right.

01:03:16.420 --> 01:03:17.550
You're going to be there.

01:03:17.550 --> 01:03:17.790
VANESSA WANG: Yeah.

01:03:17.790 --> 01:03:21.210
We'll also be hosting a booth
at the HTML5 Dev Conf.

01:03:21.210 --> 01:03:23.320
I think that's April
1 through 3.

01:03:23.320 --> 01:03:23.460
PETER LUBBERS: Yeah.

01:03:23.460 --> 01:03:25.040
VANESSA WANG: And that's going
to be in San Francisco also.

01:03:25.040 --> 01:03:27.980
And our colleague will be doing
a panel discussion about

01:03:27.980 --> 01:03:29.120
WebSocket there.

01:03:29.120 --> 01:03:29.900
PETER LUBBERS: OK.

01:03:29.900 --> 01:03:35.750
And finally the book, you
have a coupon available.

01:03:35.750 --> 01:03:37.440
Can you tell us about
the coupon?

01:03:37.440 --> 01:03:38.300
40% off?

01:03:38.300 --> 01:03:38.670
VANESSA WANG: Sure.

01:03:38.670 --> 01:03:38.760
Yeah.

01:03:38.760 --> 01:03:41.265
We have a 40% off the
ebook, I think.

01:03:41.265 --> 01:03:41.630
PETER LUBBERS: OK.

01:03:41.630 --> 01:03:44.890
So we can post it in the
moderator afterwards.

01:03:44.890 --> 01:03:45.810
Great.

01:03:45.810 --> 01:03:46.120
OK.

01:03:46.120 --> 01:03:49.540
So with that, I would like to
thank you, Vanessa, Peter,

01:03:49.540 --> 01:03:54.540
Frank for joining us in studio
answering all of everyone's

01:03:54.540 --> 01:03:55.870
WebSocket questions.

01:03:55.870 --> 01:03:58.430
And congratulations on
finishing the book.

01:03:58.430 --> 01:03:59.770
That's a huge accomplishment.

01:03:59.770 --> 01:04:00.730
FRANK SALIM: Thank you.

01:04:00.730 --> 01:04:00.810
VANESSA WANG: Thanks, Peter.

01:04:00.810 --> 01:04:01.160
PETER LUBBERS: Congrats.

01:04:01.160 --> 01:04:05.110
And for those of you online,
thanks for hanging out here.

01:04:05.110 --> 01:04:06.850
And I hope to see you soon.

01:04:06.850 --> 01:04:08.100
Thank you.

