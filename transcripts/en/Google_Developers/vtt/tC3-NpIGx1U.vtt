WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:11.818
IAN FETTE: Alright.

00:00:11.918 --> 00:00:13.758
Thank you everyone
so much for coming.

00:00:13.758 --> 00:00:14.960
Welcome to Google I/O 2010.

00:00:17.620 --> 00:00:20.860
It's a real honor to be here at
the last session of the day.

00:00:20.860 --> 00:00:21.558
I hope you guys did
enjoyed yourselves.

00:00:21.558 --> 00:00:23.040
So you guys enjoyed
the session so far?

00:00:23.040 --> 00:00:25.786
[APPLAUSE].

00:00:27.532 --> 00:00:29.280
Alright.

00:00:29.280 --> 00:00:33.800
So, on the day one keynote, the
opening of Google I/O 2010, we

00:00:33.800 --> 00:00:37.540
showed you where the
HTML5 platform was.

00:00:37.540 --> 00:00:41.860
We showed you a bunch of great
capabilities that we were

00:00:41.860 --> 00:00:42.900
adding to the platform.

00:00:42.900 --> 00:00:45.060
We showed you some awesome
partner applications, like

00:00:45.060 --> 00:00:47.140
MugTug Darkroom, Clicker.

00:00:47.140 --> 00:00:50.438
We showed you an amazing
demo by Sports Illustrated.

00:00:50.438 --> 00:00:53.298
I hope that these serve to
get you excited about what

00:00:53.298 --> 00:00:54.838
you can do with HTML5.

00:00:56.340 --> 00:00:57.860
But, the exciting thing is
that we're not done yet.

00:00:57.860 --> 00:01:01.320
We've still got a ways to go.

00:01:01.320 --> 00:01:04.100
So, in the keynote, we talked
about three main areas.

00:01:04.100 --> 00:01:07.660
We talked about
platform capabilities.

00:01:07.660 --> 00:01:11.480
About letting you make your
web applications as rich,

00:01:11.480 --> 00:01:14.940
contentful, and peachyful
as desktop applications.

00:01:14.940 --> 00:01:18.140
And, we also talked about
solving the problems of

00:01:18.140 --> 00:01:19.060
discovery and monetization.

00:01:20.040 --> 00:01:23.900
In today's talk I'm going
to focus on the platform.

00:01:23.900 --> 00:01:27.540
I want to share with you some
examples of the work that we've

00:01:27.540 --> 00:01:32.740
done in Google Chrome in terms
of lessons learned, some

00:01:32.740 --> 00:01:34.520
examples of UI decisions
that we had to make.

00:01:34.520 --> 00:01:37.560
Sort of give you an
insight into how all

00:01:37.560 --> 00:01:38.480
this development works.

00:01:38.480 --> 00:01:41.600
So, my name is Ian Fette, I'm a
Product Manager on the Google

00:01:41.600 --> 00:01:45.000
Chrome Team, and standing
besides me is Jeff Chang, also

00:01:45.000 --> 00:01:47.360
a Product Manager on the
Google Chrome Team.

00:01:47.360 --> 00:01:50.280
And, together I hope we are
going to provide you with a

00:01:50.280 --> 00:01:54.120
good hour of entertainment.

00:01:54.120 --> 00:01:55.380
So, what are we talking about.

00:01:55.380 --> 00:01:59.310
I first want to go over
what is actually in HTML5.

00:01:59.080 --> 00:02:01.280
There's a lot of
confusion there.

00:02:01.540 --> 00:02:04.120
I want to give an update
on what has happened

00:02:04.120 --> 00:02:04.720
since last year.

00:02:04.720 --> 00:02:06.380
Who all was here at
Google I/O 2009?

00:02:06.840 --> 00:02:09.760
Alright, I see a
lot of hands here.

00:02:09.880 --> 00:02:11.158
We had a talk last
year on HTML5.

00:02:12.118 --> 00:02:14.438
There was a lot of progress
made between last

00:02:14.438 --> 00:02:14.458
year and this year.

00:02:14.458 --> 00:02:17.418
So, I want to talk about some
of that, some lessons learned,

00:02:17.418 --> 00:02:20.158
some new APIs we've added since
then, and I also want to tell

00:02:20.158 --> 00:02:22.458
you about what's
coming up next.

00:02:22.458 --> 00:02:25.720
Like all the others sessions
here at Google I/O 2010,

00:02:25.720 --> 00:02:26.380
we're live waving.

00:02:26.380 --> 00:02:28.020
The link is down
there on the bottom.

00:02:28.020 --> 00:02:31.900
So, if you want to follow
along, if you want to ask any

00:02:31.900 --> 00:02:34.260
questions, feel free, of
course, if you have questions

00:02:34.260 --> 00:02:37.120
at the end, you're welcome
to come up to the mic and

00:02:37.120 --> 00:02:41.258
ask the question there.

00:02:41.258 --> 00:02:42.978
So, what the heck is an HTML5.

00:02:44.118 --> 00:02:49.920
Even as of last year, at Google
I/O 2009, HTML5 had already

00:02:49.920 --> 00:02:51.258
become a buzz word.

00:02:51.258 --> 00:02:56.900
A lot of people used HTML5
to sort of mean the new

00:02:56.900 --> 00:02:58.038
capabilities that have
been added since roughly

00:02:58.038 --> 00:03:01.678
2008, give or take.

00:03:01.678 --> 00:03:02.018
Is it technically correct?

00:03:02.018 --> 00:03:05.398
No, there is a specification
called HTML5.

00:03:06.860 --> 00:03:09.340
But, a lot of things have come
in to this specification, and

00:03:09.340 --> 00:03:13.270
gone out of this specification
as time moves on.

00:03:13.304 --> 00:03:17.188
So, when I say HTML5,
I'm going to use it in

00:03:17.188 --> 00:03:17.278
the buzz word sense.

00:03:17.278 --> 00:03:19.918
I'm going to use it to
mean the new capabilities
71
00:03:19,918 --&gt; 00:03:19,658
that we're adding.

00:03:23.058 --> 00:03:25.378
So, what are some of these
examples of changes that have

00:03:25.378 --> 00:03:26.698
happened in the HTML5 spec.

00:03:27.900 --> 00:03:30.400
HTML5 has actually shed
a lot of features.

00:03:30.400 --> 00:03:33.378
When HTML5 started, it
was a spec being written

00:03:33.378 --> 00:03:34.518
in what working group.

00:03:34.518 --> 00:03:38.158
This was a consortium of
browsers and other interested

00:03:38.158 --> 00:03:40.638
people online, trying to
come together to form a

00:03:40.638 --> 00:03:45.498
specification for what would
become the next HTML standard.

00:03:45.498 --> 00:03:48.298
And, it was one big
giant monolithic spec.

00:03:48.298 --> 00:03:52.558
When a lot of its work moved
over to W3C, some things were

00:03:52.558 --> 00:03:56.020
split out of the specification
into different specifications.

00:03:56.020 --> 00:03:57.460
Into different
working groups even.

00:03:57.460 --> 00:03:58.364
So, a lot of

00:03:58.364 --> 00:04:01.098
the storage APIs, things like
the Web SQL Database, Web

00:04:01.098 --> 00:04:06.998
Indexed Database, now called
Indexed Database API, is in

00:04:06.998 --> 00:04:07.360
a different working group.

00:04:07.360 --> 00:04:10.058
Geolocation, different
working group.

00:04:10.058 --> 00:04:11.678
File API, different
working group.

00:04:11.678 --> 00:04:13.278
Does this actually matter?

00:04:13.278 --> 00:04:14.898
No, it doesn't.

00:04:15.898 --> 00:04:17.240
A lot of this was done
for convenience.

00:04:17.240 --> 00:04:20.380
A lot of it was, you know, when
you have one mailing list, one

00:04:20.380 --> 00:04:23.758
giant working group, it's
really easy for things to get

00:04:23.758 --> 00:04:24.622
lossed in the stream, it's
hard to follow what

00:04:24.622 --> 00:04:25.160
you're interested.

00:04:25.320 --> 00:04:29.200
So, a lot of this was split out
merely for convenience, not

00:04:29.200 --> 00:04:31.880
because it's less important or
because we're not as

00:04:31.880 --> 00:04:32.618
committed to it.

00:04:32.518 --> 00:04:35.780
It's merely for the convenience
of those contributing to

00:04:35.780 --> 00:04:36.980
and implementing the specs.

00:04:36.980 --> 00:04:41.780
So, the fact that your favorite
API may not be in the HTML5

00:04:41.780 --> 00:04:43.780
proper, and it's in a different
spec and a different working

00:04:43.780 --> 00:04:45.498
group, it's not something that
you need to worry about.

00:04:45.498 --> 00:04:47.518
Don't worry about it, we
still love it, we're

00:04:47.518 --> 00:04:50.958
still implementing it.

00:04:50.958 --> 00:04:55.938
But, given that there's so much
in HTML5, what are we actually

00:04:55.938 --> 00:04:57.118
excited by, what are we
spending our time on, what are

00:04:57.118 --> 00:05:02.300
we committing resources to
developing specifications

00:05:02.300 --> 00:05:02.920
and implementing.

00:05:04.958 --> 00:05:06.160
There's a few big areas that
we spent a lot of time on

00:05:06.160 --> 00:05:07.398
over the past year even.

00:05:07.398 --> 00:05:09.518
You can see some of
them on the screen.

00:05:09.518 --> 00:05:10.138
One of them is offline.

00:05:11.058 --> 00:05:14.818
We have been working on
offline, actually for more

00:05:14.818 --> 00:05:15.378
years than I care to admit.

00:05:16.058 --> 00:05:19.380
We started at Google with
Google Gears, which was our

00:05:19.380 --> 00:05:21.000
attempt to give offline
capabilities to

00:05:21.000 --> 00:05:22.898
web applications.

00:05:22.898 --> 00:05:26.860
Google Gears gave web
applications the ability to run

00:05:26.860 --> 00:05:30.278
offline, as well as the ability
to sort data on the

00:05:30.278 --> 00:05:31.338
user's computer.

00:05:31.338 --> 00:05:36.560
I'm very, very happy to see
that there's now a standard, an

00:05:36.560 --> 00:05:40.940
actual W3C standard, around how
to do offline web applications,

00:05:40.940 --> 00:05:42.398
and how to store data offline.

00:05:42.398 --> 00:05:45.138
So, we spent a lot of time over
the past year implementing

00:05:45.138 --> 00:05:48.800
those standards, and making
sure that people can use

00:05:48.800 --> 00:05:51.898
offline web applications in
Google Chrome using
130
00:05:51,898 --&gt; 00:05:51,66
web standards.

00:05:51.940 --> 00:05:53.100
This is very important to us.

00:05:53.100 --> 00:05:56.040
We didn't just say, you know,
oh, we have Gears, we have

00:05:56.040 --> 00:05:58.658
offline capabilities, we're
done, we said there's a

00:05:58.658 --> 00:05:59.678
standard, we're going to
support that we're going

00:05:59.678 --> 00:06:01.980
to implement that.

00:06:01.980 --> 00:06:02.518
We spent a lot time on media.

00:06:02.518 --> 00:06:05.878
For those of you who were here
yesterday, and saw the keynote,

00:06:05.878 --> 00:06:08.540
we announced we're
open sourcing VPA.

00:06:08.540 --> 00:06:09.338
Why are we doing this.

00:06:09.338 --> 00:06:13.180
Well, we believe that video is
an important part of the web,

00:06:13.180 --> 00:06:18.978
and that there needs to be free
and open quota for video.

00:06:18.978 --> 00:06:22.680
So, we have invested not to
just the making video supported

00:06:22.680 --> 00:06:25.858
in Google Chrome, but making
sure there is a viable

00:06:25.858 --> 00:06:29.438
option for an open video
standard on the web.

00:06:29.438 --> 00:06:32.058
Networking, there's an API
called Web Sockets, that makes

00:06:32.058 --> 00:06:35.560
it possible for you to have
bi-directional communication

00:06:35.560 --> 00:06:38.778
from your client application,
your web application,

00:06:38.778 --> 00:06:39.500
back up to a service.

00:06:39.500 --> 00:06:41.320
So, I see some people out there
saying, you know, what's he

00:06:41.320 --> 00:06:43.820
talking about, I can do this
already, it's called
151
00:06:43,82 --&gt; 00:06:43,48
XmlHttpRequest.

00:06:45.740 --> 00:06:49.098
And, yes, you do XHR, and you
can do hanging GETs, you have

00:06:49.098 --> 00:06:52.318
communication back and forth
between your web application

00:06:52.318 --> 00:06:53.718
and your server.

00:06:53.718 --> 00:06:56.798
But, this has some
overhead, some downsides.

00:06:56.798 --> 00:06:59.420
Let's say that you have a
chatty application that each

00:06:59.420 --> 00:07:04.378
time a user presses a key, it
sends a message to the server,

00:07:04.378 --> 00:07:07.158
Google Wave for instance, when
you send, when you're typing in

00:07:07.158 --> 00:07:09.420
waves, all those
characteristics get sent to

00:07:09.420 --> 00:07:11.420
server then sent down
to everyone else

00:07:11.420 --> 00:07:12.420
following the wave.

00:07:12.420 --> 00:07:15.338
If you think about how this
actually works, each time you

00:07:15.338 --> 00:07:18.260
send a new request to the
server, you're not just sending

00:07:18.260 --> 00:07:22.578
that letter, you're sending all
the cookies, all the headers.

00:07:22.578 --> 00:07:24.898
So, we're very excited about a
new specification called Web

00:07:24.898 --> 00:07:27.618
Sockets that lets you keep a
persistent connection opened

00:07:27.618 --> 00:07:30.978
between the server and
the web application.

00:07:30.978 --> 00:07:34.380
It's bi-directional, so either
the server or the client can

00:07:34.380 --> 00:07:37.918
send data back and forth
with much less overhead.

00:07:37.918 --> 00:07:40.138
We spent a lot of time on
that over the past year.

00:07:40.138 --> 00:07:42.160
We're actually contributing
to that specification.

00:07:43.638 --> 00:07:48.458
Things like CSS3, Paged Media,
giving you more control over

00:07:48.458 --> 00:07:49.600
how your content is displayed.

00:07:50.878 --> 00:07:54.998
Both on the screen and
on the printed page.

00:07:54.998 --> 00:07:58.220
So, CSS3 gives you more
primitives for doing layout

00:07:58.220 --> 00:08:01.498
that have been very difficult
in the past, and Paged Media

00:08:01.498 --> 00:08:03.778
gives you primitives for how
you do that layout on

00:08:03.778 --> 00:08:04.700
the printed page.

00:08:04.700 --> 00:08:08.058
Things like controlling page
margins, headers, footers, all

00:08:08.058 --> 00:08:10.458
sorts of -- there's like 16
margin boxes that you

00:08:10.458 --> 00:08:13.058
can configure and put
random stuff in there.

00:08:13.458 --> 00:08:16.500
You can also specify, you know,
what's supposed to happen if I

00:08:16.500 --> 00:08:20.698
design my page for, my printed
page for A4, and the user

00:08:20.698 --> 00:08:22.378
has letter or vice versa.

00:08:22.378 --> 00:08:25.118
So again, this is something
we think is important.

00:08:25.118 --> 00:08:26.638
If you look at Google
Documents, Google

00:08:26.638 --> 00:08:27.998
Documents lets you print.

00:08:27.998 --> 00:08:29.518
Right now, it generates a PDF.

00:08:29.718 --> 00:08:31.678
You know, it works.

00:08:31.678 --> 00:08:32.332
Is it optimal?

00:08:32.606 --> 00:08:32.880
No.

00:08:32.880 --> 00:08:35.460
So, this is an area that
we're spending time on.

00:08:35.460 --> 00:08:36.780
And, platform integration.

00:08:36.780 --> 00:08:38.560
You saw some of this in the
keynote, we'll talk a bit

00:08:38.560 --> 00:08:40.360
more about this today.

00:08:40.360 --> 00:08:44.700
We believe it's very important
that as desktop applications

00:08:44.700 --> 00:08:46.800
can integrate with the
platform, we believe it's

00:08:46.800 --> 00:08:49.748
important that web applications
can also integrate with the

00:08:49.748 --> 00:08:52.740
host platform on which
they're running.

00:08:52.740 --> 00:08:53.660
So, again, why are
we doing this.

00:08:53.660 --> 00:08:56.320
We're doing this because we
want to provide a rich

00:08:56.320 --> 00:08:57.800
experience for web
applications.

00:08:57.800 --> 00:09:02.898
We want you to be able to give
your users the same sort of

00:09:02.898 --> 00:09:06.678
features and experiences that
they can get from a desktop

00:09:06.678 --> 00:09:12.760
application designed to
achieve a similar goal.

00:09:12.760 --> 00:09:14.680
So, you know, we spent a lot of
time this year working on these

00:09:14.680 --> 00:09:17.180
APIs, a lot of man hours
have gone into this.

00:09:17.180 --> 00:09:19.020
We've learned a few lessons.

00:09:19.020 --> 00:09:22.260
I want to share some of those
lessons with you, and give you

00:09:22.260 --> 00:09:25.400
an insight into what it's like
building a browser,

00:09:25.400 --> 00:09:30.020
building web standards,
building a new API.

00:09:30.020 --> 00:09:32.740
One of the first lessons that
we learned, I said that we've

00:09:32.740 --> 00:09:34.940
been working on offline
apps for years.

00:09:34.940 --> 00:09:37.080
Believe me, we've learned a lot
of lessons with offline apps.

00:09:37.080 --> 00:09:39.578
It's still not perfect,
we've got a ways to go,

00:09:39.578 --> 00:09:41.560
but we're learning.

00:09:41.560 --> 00:09:43.060
One of the key lessons that
we learned was around

00:09:43.060 --> 00:09:46.640
discovery and rediscovery.

00:09:46.640 --> 00:09:49.560
I don't know if any of you
used the offline version

00:09:49.560 --> 00:09:52.320
of Gmail with Gears.

00:09:52.320 --> 00:09:54.020
I see a few nods.

00:09:54.020 --> 00:09:58.340
One of the problems is that
it's very hard for a user

00:09:58.340 --> 00:10:00.540
to remember that they need
to type in a URL to reach

00:10:00.540 --> 00:10:03.180
your offline application.

00:10:03.180 --> 00:10:05.480
You know, when you're offline,
when you're in a plane, when

00:10:05.480 --> 00:10:09.060
you board that flight back home
tonight, and you say gee, I

00:10:09.060 --> 00:10:14.820
want to access my email, but I
don't have Wi-Fi, what do I do.

00:10:14.820 --> 00:10:17.180
You know, you guys in the
audience are pretty tech savvy,

00:10:17.180 --> 00:10:19.320
a number of you might figure
out that you can actually open

00:10:19.320 --> 00:10:24.720
the browser and type in
https://mail.google.com, and oh

00:10:24.720 --> 00:10:26.540
by the way, the origin
actually has to match.

00:10:26.540 --> 00:10:28.140
So, if you just type
in gmail.com or

00:10:28.140 --> 00:10:33.240
http://gmail.rule.com
it might not work.

00:10:33.240 --> 00:10:33.380
Woops.

00:10:33.380 --> 00:10:34.700
That's a problem.

00:10:34.700 --> 00:10:36.340
And, that's something you
even remember you need

00:10:36.340 --> 00:10:36.400
to type in a URL.

00:10:37.560 --> 00:10:41.186
So, with Gears, we put a
shortcut on the desktop, and

00:10:41.186 --> 00:10:43.120
that was a step forward.

00:10:43.120 --> 00:10:46.580
But, it still didn't
solve the problem fully.

00:10:46.580 --> 00:10:50.120
So, what we announced yesterday
was the Chrome Web Store.

00:10:50.120 --> 00:10:54.840
Part of the Chrome Web Store is
about making your applications

00:10:54.840 --> 00:10:58.840
discoverable, helping users
find that application you've

00:10:58.840 --> 00:11:01.360
spent the time to write.

00:11:01.360 --> 00:11:04.180
But, the problem is not just
finding the application the

00:11:04.180 --> 00:11:07.500
first time, the problem is
finding the application the

00:11:07.500 --> 00:11:11.020
second time, and the third
time, the rediscovery problem.

00:11:11.020 --> 00:11:13.160
Knowing, how you get back to
that application, knowing how

00:11:13.160 --> 00:11:17.258
you launch that application,
and actually feeling that that

00:11:17.258 --> 00:11:20.260
application is available
to you, even when offline.

00:11:20.260 --> 00:11:23.458
So, with the Web Store,
we're changing the new

00:11:23.458 --> 00:11:24.520
tab page of Chrome.

00:11:24.520 --> 00:11:28.620
To give web applications a
presence, not just in the form

00:11:28.620 --> 00:11:32.600
of bookmarks, or an icon on the
tab -- like one of the

00:11:32.600 --> 00:11:33.760
most visited pages.

00:11:34.540 --> 00:11:39.260
But, an actual first class
treatment, as an installed

00:11:39.260 --> 00:11:41.000
application in Google Chrome.

00:11:41.000 --> 00:11:44.460
We're doing this, in part, so
users can rediscover that

00:11:44.460 --> 00:11:46.900
application, and know
how to get back to it.

00:11:46.900 --> 00:11:49.758
So, that when you are offline,
and you say gee, how do I

00:11:49.758 --> 00:11:52.218
get to my email was
http://mail.google.com,

00:11:52.218 --> 00:11:54.838
https:/mail.google.com,
gmail.com, gmail.de,

00:11:54.838 --> 00:11:55.700
no that doesn't fit.

00:11:57.520 --> 00:12:02.440
You can just click on the
icon, and it's there.

00:12:02.440 --> 00:12:06.898
So, this has been one thing
that we've learned from

00:12:06.898 --> 00:12:08.920
offline applications.

00:12:08.920 --> 00:12:10.280
Another thing that we've
learned with the offline

00:12:10.280 --> 00:12:12.340
applications, it usually
uses more APIs than

00:12:12.340 --> 00:12:14.840
normal web pages.

00:12:14.840 --> 00:12:17.140
It turns out if you're an
offline application, you

00:12:17.140 --> 00:12:20.560
probably want to have some
offline data, but how much

00:12:20.560 --> 00:12:22.500
offline data do you have.

00:12:22.500 --> 00:12:26.820
If it's an e-mail app, 10
years ago maybe 5 megabytes

00:12:26.820 --> 00:12:27.860
would have done it.

00:12:27.860 --> 00:12:29.600
That's our current
default quota for

00:12:29.600 --> 00:12:30.420
offline data.

00:12:30.420 --> 00:12:32.520
Today, I bet most of you in
this room have more than

00:12:32.520 --> 00:12:33.200
5 megabytes of e-mail.

00:12:35.360 --> 00:12:38.500
When we designed a lot of
storage APIs, we sort of

00:12:38.500 --> 00:12:40.800
scratched our head and
said gee, you know,

00:12:40.800 --> 00:12:42.240
what we do for quota.

00:12:42.240 --> 00:12:45.540
Well, we don't want any random
web application to be able to

00:12:45.540 --> 00:12:48.080
fill up the disk,
that sounds bad.

00:12:48.080 --> 00:12:49.020
So, let's put a limit on it.

00:12:49.020 --> 00:12:50.140
Let's say 5 megabytes.

00:12:50.140 --> 00:12:53.480
That seems sort of safe, like,
you know, I'm going to give you

00:12:53.480 --> 00:12:56.600
5 megabytes, you can already
store cookies and cache,

00:12:56.600 --> 00:12:57.740
so what the heck, 5 megs.

00:12:57.740 --> 00:13:00.280
But, what do you do when you
want to have more than that.

00:13:00.280 --> 00:13:04.140
We can prompt the user and say,
you know, Gmail.com wants to

00:13:04.140 --> 00:13:07.600
use another 5 megabytes or
another 100 megabytes, do you

00:13:07.600 --> 00:13:09.320
want to allow this, yes or no.

00:13:09.320 --> 00:13:11.080
But, when do you prompt it.

00:13:11.080 --> 00:13:14.920
If you think about it in terms
of how the spec is written

00:13:14.920 --> 00:13:19.780
today, the logical answer would
be when you get somewhere

00:13:19.780 --> 00:13:21.820
near to filling up the quota.

00:13:21.820 --> 00:13:24.178
Lots of hand waving, you know,
the user agent should do

00:13:24.178 --> 00:13:25.540
something intelligent.

00:13:26.080 --> 00:13:29.380
Which, most people
interpret as prompting.

00:13:29.380 --> 00:13:30.180
But, when are you going
to hit 5 megabytes.

00:13:30.180 --> 00:13:33.240
You know, if you say, I want
to install Gmail offline,

00:13:33.240 --> 00:13:34.360
and I want to use Gmail.

00:13:35.620 --> 00:13:37.920
It would make sense to prompt
right then, but you're

00:13:37.920 --> 00:13:39.680
not going to hit that 5
mega quota right then.

00:13:39.680 --> 00:13:41.120
We're going to start
synchronizing some data, and

00:13:41.120 --> 00:13:43.080
then maybe a minute later
you hit 5 megabytes.

00:13:43.080 --> 00:13:46.180
So, you say, yes install Gmail,
yes let it work offline.

00:13:46.180 --> 00:13:48.740
Then, a minute later you get
another info bar, yes let it

00:13:48.740 --> 00:13:50.960
use more storage, and
then maybe it wants

00:13:50.960 --> 00:13:51.940
to use notifications.

00:13:51.940 --> 00:13:54.278
And, you say yes, let
it use notifications.

00:13:54.278 --> 00:13:56.498
And, you end up answering
like 50 info bars.

00:13:56.498 --> 00:13:58.318
It's like geez, I just wanted
to use this app, you know, when

00:13:58.318 --> 00:14:01.538
I installed an app on my
Android phone, I didn't have to

00:14:01.538 --> 00:14:05.460
like click yes on 50 different
info bars, why is this so hard.

00:14:05.460 --> 00:14:09.740
So, another thing that the
Chrome Web Store is solving is

00:14:09.740 --> 00:14:11.740
this problem of permission.

00:14:11.740 --> 00:14:14.860
With the Chrome Web Store, when
you upload your application to

00:14:14.860 --> 00:14:18.240
the Chrome Web Store, we let
you specify a set of

00:14:18.240 --> 00:14:20.820
permissions that you want your
application to have.

00:14:21.680 --> 00:14:24.260
So, now when a user goes to the
Chrome Web Store and says,

00:14:24.260 --> 00:14:27.720
yes, I want to install this
application, we can handle all

00:14:27.720 --> 00:14:29.540
those permissions up front.

00:14:29.540 --> 00:14:32.820
And, we can say, yes, this app
should be allowed to access the

00:14:32.820 --> 00:14:35.640
location, and access more than
5 megabytes of local storage,

00:14:35.640 --> 00:14:37.060
and access notifications.

00:14:37.060 --> 00:14:40.880
So, this has been a huge
lesson learned for months.

00:14:40.880 --> 00:14:41.960
Is it standard yet.

00:14:42.480 --> 00:14:44.300
Are all browsers
going to do this.

00:14:44.300 --> 00:14:45.880
No, it's not standard yet.

00:14:45.880 --> 00:14:48.500
We are trying to
see what works.

00:14:48.500 --> 00:14:52.080
We're hopeful that we can find
a solution that works well.

00:14:52.080 --> 00:14:54.580
And, assuming that we find a
solution that works well,

00:14:54.580 --> 00:14:57.160
we're hopefully we can then
contribute that back in some

00:14:57.160 --> 00:14:58.700
sort of a standard
friendly manner.

00:14:58.700 --> 00:14:59.440
That's how we do things.

00:14:59.440 --> 00:15:02.980
We don't try to specify
everything up front.

00:15:02.980 --> 00:15:03.240
We try to innovate.

00:15:03.800 --> 00:15:07.720
We try to make sure that we can
produce a good user experience,

00:15:07.720 --> 00:15:11.460
and then contribute
that to a standard.

00:15:11.460 --> 00:15:13.260
So, another lesson learned.

00:15:13.260 --> 00:15:16.020
How many of you have
used Web SQL Database.

00:15:16.020 --> 00:15:21.420
The local storage -- well
Web SQL Database now.

00:15:21.420 --> 00:15:23.520
But, it basically gives you a
SQL database in the browser.

00:15:23.520 --> 00:15:24.820
Anyone's used it?

00:15:24.820 --> 00:15:26.540
Alright, I see a
number of hands.

00:15:26.540 --> 00:15:29.960
One of the problems that this
spec faces, I personally love

00:15:29.960 --> 00:15:32.418
it, I think it's a
very good idea.

00:15:32.418 --> 00:15:34.958
A lot of people are familiar
with SQL, they like SQL.

00:15:35.038 --> 00:15:39.840
But, one of the problems it
faces is that it's sort of

00:15:39.840 --> 00:15:42.260
hard to specify how
this should work.

00:15:42.260 --> 00:15:43.700
Is their a SQL standard.

00:15:43.700 --> 00:15:47.140
Yes, there actually is,
something called SQL.

00:15:47.140 --> 00:15:48.878
And, it has a
standard around it.

00:15:48.878 --> 00:15:52.378
But, no implementation
just implement SQL.

00:15:52.378 --> 00:15:55.178
Everyone implements SQL
plus, you know, whatever

00:15:55.178 --> 00:15:55.938
else, you know.

00:15:55.938 --> 00:15:59.300
How many of you used MySQL
on the server side?

00:15:59.300 --> 00:16:00.760
I see a lot of MySQL people.

00:16:00.760 --> 00:16:01.820
How many of you
used PostgreSQL?

00:16:02.560 --> 00:16:03.800
I see some PostgreSQL people.

00:16:03.800 --> 00:16:05.240
How many of you used SQLite?

00:16:05.240 --> 00:16:06.000
I see some SQLite people.

00:16:06.000 --> 00:16:07.520
How many of you used
MS SQL Server?

00:16:09.560 --> 00:16:09.740
Some people.

00:16:09.740 --> 00:16:11.760
How many of you used Oracle?

00:16:11.760 --> 00:16:12.540
More hands.

00:16:12.540 --> 00:16:16.980
So, it turns out if you try to
write a web application, you

00:16:16.980 --> 00:16:18.058
have to care about that.

00:16:18.058 --> 00:16:21.800
You have to care, am I running
a SQLite, am I running a MySQL,

00:16:21.800 --> 00:16:23.120
am I running a PostgreSQL.

00:16:23.120 --> 00:16:26.500
And, how many of you have ever
upgraded MySQL, and have your

00:16:26.500 --> 00:16:28.080
application stopped working?

00:16:28.080 --> 00:16:29.680
I see some hands there.

00:16:29.680 --> 00:16:32.600
So, when we're designing a
specification, it turns out

00:16:32.600 --> 00:16:35.760
it's not really sufficient to
just say, you know, issue a SQL

00:16:35.760 --> 00:16:37.920
query and return a result.

00:16:37.920 --> 00:16:42.120
We have to say what that means
in some sort of way that's

00:16:42.120 --> 00:16:45.960
going to withstand
the test of time.

00:16:45.960 --> 00:16:48.160
So, 10 years from now, maybe we
don't want to use SQLite 3

00:16:48.160 --> 00:16:49.040
maybe we want to use SQLite 4.

00:16:50.900 --> 00:16:53.120
And, maybe that has
a different syntax.

00:16:53.120 --> 00:16:55.638
Maybe we don't want to
use SQLite at all.

00:16:55.638 --> 00:16:57.580
Maybe we want to use
something else.

00:16:57.140 --> 00:17:01.900
Maybe another browser, which
today once we implement this

00:17:01.900 --> 00:17:04.658
specification doesn't want to
use SQLite, and wants to use an

00:17:04.658 --> 00:17:05.280
alternative implementation.

00:17:06.560 --> 00:17:08.540
What should they match.

00:17:08.540 --> 00:17:12.440
Is there an actual standard
that specifies what the output

00:17:12.440 --> 00:17:14.260
is with a given set of input.

00:17:14.260 --> 00:17:16.840
Today, there's not.

00:17:16.840 --> 00:17:18.300
So, we're looking
at alternatives.

00:17:18.300 --> 00:17:21.598
One alternative that's being
proposed is to specify that

00:17:21.598 --> 00:17:25.240
dialect of SQL that's
appropriate for this API.

00:17:25.240 --> 00:17:28.060
I'm personally hopeful that'll
happen, because I do think that

00:17:28.060 --> 00:17:30.600
there are a number of
developers who are comfortable

00:17:30.600 --> 00:17:35.400
with the SQL model, and want to
use SQL on the client side just

00:17:35.400 --> 00:17:39.280
as they use it on
the service side.

00:17:39.280 --> 00:17:42.340
But, not everyone likes SQL,
and there are some concerns

00:17:42.340 --> 00:17:45.300
about whether we can actually
specify the style up.

00:17:45.300 --> 00:17:46.040
So, there's another
approach that we're

00:17:46.040 --> 00:17:47.800
taking at the same time.

00:17:47.800 --> 00:17:50.340
And, this is called the
index database API.

00:17:50.340 --> 00:17:54.640
How many of you out there
are familiar with ISAM?

00:17:54.640 --> 00:17:55.920
I see some hands.

00:17:55.580 --> 00:17:56.340
OK, good.

00:17:56.340 --> 00:17:59.520
We have some computer
science majors in the room.

00:17:59.520 --> 00:18:04.580
What ISAM is, what this API
basically tries to achieve, is

00:18:04.580 --> 00:18:08.640
to provide a table that is
indexed on a single field.

00:18:08.640 --> 00:18:14.060
And, so you have an index that
is either a DOMString or a

00:18:14.060 --> 00:18:16.060
long, so something that
we can easily index.

00:18:16.060 --> 00:18:19.560
Then, you have an
associate value.

00:18:19.560 --> 00:18:22.040
And, this value can be pretty
much anything, you know, it

00:18:22.040 --> 00:18:24.080
can be an object, it can
be an array, whatever.

00:18:24.440 --> 00:18:28.980
So, you then do lookups on
this table based on the key.

00:18:28.980 --> 00:18:31.420
So, this key can be an author
name, it could be a book

00:18:31.420 --> 00:18:33.760
ID, whatever you want.

00:18:33.760 --> 00:18:35.940
And, then you pull up its
value, and that's it.

00:18:35.940 --> 00:18:38.998
It's just matching on
the index, you have no

00:18:38.998 --> 00:18:39.460
complex query language.

00:18:39.460 --> 00:18:41.278
You can't do joins,
anything like that.

00:18:41.278 --> 00:18:44.040
If you want to do any query
refinement to say, you know,

00:18:44.040 --> 00:18:48.180
author is this, and is
hardcover, something like that.

00:18:48.180 --> 00:18:49.140
You do that in JavaScript.

00:18:49.140 --> 00:18:52.880
If you wanted to do any joins,
taking a table, joining the two

00:18:52.880 --> 00:18:54.620
together, again you do
this in JavaScript.

00:18:54.620 --> 00:18:58.370
This gives us a powerful
database, but also one that

00:18:58.370 --> 00:19:00.500
is very easy to specify.

00:19:00.500 --> 00:19:02.180
So, we're in the middle
of implementing this.

00:19:02.180 --> 00:19:04.580
No browser actually has
an implementation yet,

00:19:04.580 --> 00:19:05.800
we're working on it.

00:19:06.680 --> 00:19:12.140
Hopeful that this turns into a
standard cross browser API

00:19:12.140 --> 00:19:16.818
that's available everywhere,
its future proof.

00:19:16.818 --> 00:19:19.400
Don't know if people actually
write on top of it directly.

00:19:19.400 --> 00:19:22.980
My personal guess is that we
will see a lot of abstraction

00:19:22.980 --> 00:19:26.640
layers written on top of this
API to make it easier to use.

00:19:26.640 --> 00:19:28.900
So, any of you database
geeks out there feel

00:19:28.900 --> 00:19:32.780
free to start writing.

00:19:32.780 --> 00:19:33.660
What else have we learned.

00:19:33.660 --> 00:19:34.300
Storage.

00:19:34.300 --> 00:19:36.320
You know, databases are
great, but some people

00:19:36.320 --> 00:19:37.040
want to store files.

00:19:37.040 --> 00:19:40.140
If you think about an e-mail
application, you want a

00:19:40.140 --> 00:19:40.798
way to store attachments.

00:19:40.798 --> 00:19:44.838
If you think about an image
program, MugTug Darkroom that

00:19:44.838 --> 00:19:47.060
you saw on the keynote, you
want a way to store images.

00:19:47.060 --> 00:19:49.360
And, any of you database guys
out there know that if you try

00:19:49.360 --> 00:19:52.160
to shove a large amount of
binary data in your database

00:19:52.160 --> 00:19:55.960
and it's not designed for
that, bad things happen.

00:19:56.060 --> 00:19:58.220
Turns out a lot of people try
to implement file systems

00:19:58.220 --> 00:19:59.080
on top of databases.

00:19:59.080 --> 00:20:01.140
So, we figured, well
what the heck.

00:20:01.140 --> 00:20:05.980
People want file systems,
let's get them a file system.

00:20:05.980 --> 00:20:09.340
So, now we're working on a file
system API, that gives you, the

00:20:09.340 --> 00:20:13.640
web author, the ability to have
a sandbox per origin

00:20:13.640 --> 00:20:14.960
file system.

00:20:14.960 --> 00:20:18.300
So, what you get is
essentially, and this isn't

00:20:18.300 --> 00:20:22.100
specified this way but in most
implementations I've seen, what

00:20:22.100 --> 00:20:25.780
you get is a folder somewhere
buried deep in the users

00:20:25.780 --> 00:20:28.520
profile directory, into
which you can create new

00:20:28.520 --> 00:20:30.300
files and read files.

00:20:30.300 --> 00:20:33.420
So, this is basically like
chrooted file system, that

00:20:33.420 --> 00:20:35.940
you can do whatever the
heck you want with.

00:20:35.940 --> 00:20:37.620
So, if you want to store
e-mail attachments,

00:20:37.620 --> 00:20:38.760
great you can do it.

00:20:38.760 --> 00:20:40.078
You want to store images,
great you can do it.

00:20:40.078 --> 00:20:43.880
You want to store all your
e-mail on something like a

00:20:43.880 --> 00:20:46.240
Maildir format, you
can do that to.

00:20:46.240 --> 00:20:50.460
And, the cool thing is that
we have exposed APIs for

00:20:50.460 --> 00:20:52.240
FileReader and FileWriter,
that what you read and

00:20:52.240 --> 00:20:55.140
write these files.

00:20:55.140 --> 00:20:58.440
And, we're letting you create
blobs, that you can insert

00:20:58.440 --> 00:21:01.440
anywhere that you would
normally insert an URL.

00:21:01.440 --> 00:21:04.380
So, if you want to say image
source equals some file,

00:21:04.380 --> 00:21:05.200
we're gonna make that work.

00:21:05.200 --> 00:21:14.640
If you want to say href equals
some file, so that the user can

00:21:14.640 --> 00:21:18.720
click on it, and download it or
open it, and whatever other

00:21:18.720 --> 00:21:20.480
program they would use to open
that type of file, we're

00:21:20.480 --> 00:21:21.140
going to make that work.

00:21:21.140 --> 00:21:26.940
We're going to make it possible
for you to get a URN from these

00:21:26.940 --> 00:21:28.020
files, that you can use
anywhere you would

00:21:28.020 --> 00:21:29.620
use a web URL.

00:21:29.620 --> 00:21:32.120
So, we're trying to make
a very flexible API.

00:21:32.120 --> 00:21:33.960
This is also work in progress.

00:21:33.960 --> 00:21:36.238
We're implementing it in
WebKit, so it should be

00:21:36.238 --> 00:21:42.318
available in Chrome and Safari
hopefully this summer.

00:21:42.318 --> 00:21:43.520
And, my personal
favorite, Geolocation.

00:21:44.600 --> 00:21:46.940
You saw Geolocation in
Android quite a while ago.

00:21:46.940 --> 00:21:52.080
You saw Geolocation in
Gears a while ago.

00:21:52.080 --> 00:21:54.480
And, it sounded sort of simple
from a security perspective.

00:21:54.480 --> 00:21:57.180
You say, you know, OK
here's a website.

00:21:57.420 --> 00:22:00.320
The website wants to access
to user's location.

00:22:00.320 --> 00:22:04.920
I'll ask the user, and say, you
know, should maps.google.com be

00:22:04.920 --> 00:22:08.380
allowed to access your
location, yes or no.

00:22:08.380 --> 00:22:10.340
It turns out, that when we
actually implemented this in

00:22:10.340 --> 00:22:13.278
Chrome, and we sat down, and we
had a bunch of really privacy

00:22:13.278 --> 00:22:15.212
minded people from our
Germany office as

00:22:15.212 --> 00:22:20.100
well as some people here in the
Bay area, we started thinking

00:22:20.100 --> 00:22:24.540
about some used cases where it
wasn't quite as clear cut.

00:22:24.540 --> 00:22:27.040
You know, if I'm on
maps.google.com, and I say,

00:22:27.040 --> 00:22:29.480
yes allow my location.

00:22:29.480 --> 00:22:30.140
I understand that.

00:22:30.140 --> 00:22:30.860
I [UNINTELLIGIBLE].

00:22:31.020 --> 00:22:34.060
I'm saying OK, Google can
get my location for Google

00:22:34.060 --> 00:22:36.760
maps, got it, great, next.

00:22:36.760 --> 00:22:39.720
What happens now when I go to
another website, like Yelp.com

00:22:39.720 --> 00:22:42.140
that has an embedded
Google maps gadget.

00:22:44.460 --> 00:22:46.360
Should my location show up.

00:22:46.360 --> 00:22:48.940
I don't know.

00:22:48.980 --> 00:22:51.740
You know, I said yes,
let maps.google.com

00:22:51.740 --> 00:22:52.620
access my location.

00:22:52.620 --> 00:22:55.358
And, technically there's
JavaScript from maps.google.com

00:22:55.358 --> 00:22:58.680
that's trying to
access my location.

00:22:58.680 --> 00:23:01.460
So, you could argue that sure,
let's give the location

00:23:01.460 --> 00:23:02.260
up, that sounds great.

00:23:02.260 --> 00:23:05.520
But, from a users perspective,
what's actually happening.

00:23:05.520 --> 00:23:08.080
I'm not on maps.google.com,
I'm at yelp.com, or some

00:23:08.080 --> 00:23:10.234
other site, and someone
wants my location.

00:23:11.130 --> 00:23:14.480
It's not really what I expect,
that I see my location

00:23:14.480 --> 00:23:15.200
being given out.

00:23:15.200 --> 00:23:17.240
So, what we did is
something different.

00:23:17.240 --> 00:23:22.880
And, I'll show you.

00:23:22.880 --> 00:23:26.420
So, here I am in Google Chrome,
this is actually Chromium a

00:23:26.420 --> 00:23:28.940
nightly build, and I go
to maps.google.com.

00:23:30.040 --> 00:23:33.120
I click to show my
location button.

00:23:33.120 --> 00:23:35.260
And, I see this little info
bar saying, you know,

00:23:35.260 --> 00:23:36.540
maps.google.com wants to
track your location.

00:23:36.540 --> 00:23:37.720
I say allow.

00:23:38.640 --> 00:23:40.670
And, now I see here I am,
I'm a up in San Francisco

00:23:40.670 --> 00:23:41.420
at Moscone West.
531
00:23:41,56 --&gt; 00:23:41
Great.

00:23:42.400 --> 00:23:45.140
I see this little indicator
up here saying this page

00:23:45.140 --> 00:23:46.680
is tracking your location.

00:23:46.680 --> 00:23:47.760
I understand what's going on.

00:23:47.760 --> 00:23:49.400
I'm comfortable with this.

00:23:49.400 --> 00:23:51.080
It's something I understand.

00:23:51.080 --> 00:23:54.260
Now, let's say that I go to
another webpage, which maybe

00:23:54.260 --> 00:23:56.000
it's not quite as reputable.

00:23:56.000 --> 00:23:57.720
You know, its this
IanFette.com site.

00:23:57.720 --> 00:24:00.260
Who knows what that
guy is doing.

00:24:00.260 --> 00:24:01.020
He's iFraming Google maps.

00:24:01.020 --> 00:24:02.600
Oh my God.

00:24:02.600 --> 00:24:06.820
Is my location going to show
up if I click this button.

00:24:06.820 --> 00:24:07.940
And, the answer
right now is no.

00:24:07.940 --> 00:24:10.420
It's not going to show up,
because what we did is we tied

00:24:10.420 --> 00:24:14.020
the permission not just to the
origin of the script requesting

00:24:14.020 --> 00:24:17.700
the location, but also the
origin of the top

00:24:17.700 --> 00:24:18.760
level document.

00:24:18.760 --> 00:24:23.380
So, here I am on IanFette.com,
I'm not getting access.

00:24:23.380 --> 00:24:25.920
It's telling me that my
location is being requested.

00:24:25.920 --> 00:24:29.040
So, I actually trust Ian
Fette, it's me, so I'm

00:24:29.040 --> 00:24:29.850
going to allow it.

00:24:29.934 --> 00:24:31.980
And, here I am at Moscone West.

00:24:31.980 --> 00:24:34.420
So, what actually gets
saved from that.

00:24:34.420 --> 00:24:37.400
If I click this little
indicator in the Omnibox,

00:24:37.400 --> 00:24:39.660
I see that, you know,
that maps.google.com is

00:24:39.660 --> 00:24:40.360
tracking my location.

00:24:40.360 --> 00:24:44.900
If I hit manage location
settings, I can see, you know,

00:24:44.900 --> 00:24:47.678
I'm always asked whether a site
should be able to

00:24:47.678 --> 00:24:49.140
see my location.

00:24:49.140 --> 00:24:50.840
If I click exceptions,
I can see the rules

00:24:50.840 --> 00:24:51.300
that I've specified.

00:24:52.880 --> 00:24:55.700
Here you see that
maps.google.com can get my

00:24:55.700 --> 00:24:59.640
location, and maps.google.com,
when embedded on Ianfette.com,

00:24:59.640 --> 00:25:01.298
can get my location.

00:25:01.298 --> 00:25:05.060
But, maps.google.com on
Ianfette.org, for instance,

00:25:05.060 --> 00:25:07.300
would not be able to
access my location.

00:25:07.300 --> 00:25:10.280
So, this was an example of
an API that, you know, we

00:25:10.280 --> 00:25:12.500
have implemented twice.

00:25:12.320 --> 00:25:16.980
We thought was pretty simple,
but turned out to actually have

00:25:16.980 --> 00:25:19.800
some pretty tricky UI problems.

00:25:19.800 --> 00:25:23.360
So, when people say, you know,
it's easy to add another API,

00:25:23.360 --> 00:25:25.758
it's easy to provide this
functionality, just

00:25:25.758 --> 00:25:26.498
ask the user.

00:25:26.498 --> 00:25:34.500
It turns out that asking the
user is not always easy to do.

00:25:34.500 --> 00:25:38.180
So, when we were here at I/O
2009 last year, we were talking

00:25:38.180 --> 00:25:39.240
about a lot of these APIs.

00:25:39.240 --> 00:25:41.860
We were talking about
storage, about geolocation.

00:25:41.920 --> 00:25:44.180
What have we actually done over
the past year, what are the

00:25:44.180 --> 00:25:48.540
new work areas that we
started on this year.

00:25:48.540 --> 00:25:50.118
One of the really cool ones,
and actually it might not sound

00:25:50.118 --> 00:25:53.180
that cool, but it is, I promise
you, is shared state

00:25:53.180 --> 00:25:54.540
between pages.

00:25:54.540 --> 00:25:57.300
I talked earlier about
the file system API.

00:25:57.300 --> 00:26:00.660
If any of you have written
native code, you know that when

00:26:00.660 --> 00:26:03.380
dealing with files, you have to
worry about race conditions.

00:26:03.380 --> 00:26:07.900
You have to worry about 2
threads accessing the same file

00:26:07.900 --> 00:26:10.890
at once, and both trying to
make modifications

00:26:10.890 --> 00:26:11.320
to that file.

00:26:11.320 --> 00:26:14.786
Bad things can happen if you
don't worry about concurrency.

00:26:14.832 --> 00:26:18.140
It turns out that with the File
API, the FileSystem API that

00:26:18.140 --> 00:26:20.940
we're writing, same
thing can happen.

00:26:20.940 --> 00:26:22.160
You can have race conditions.

00:26:22.160 --> 00:26:24.318
You can have
concurrency issues.

00:26:24.318 --> 00:26:28.500
And, HTML and JavaScript don't
really provide you with great

00:26:28.500 --> 00:26:30.700
mechanisms for handling
things like locking.

00:26:30.700 --> 00:26:31.440
So, what do you do.

00:26:31.440 --> 00:26:35.620
There's an API called
SharedWorkers that lets you

00:26:35.620 --> 00:26:39.300
effectively have multiple
pages, multiple tabs, multiple

00:26:39.300 --> 00:26:42.920
frames, whatever, in the same
origin communicating with

00:26:42.920 --> 00:26:45.260
each other via a post
message interface.

00:26:46.560 --> 00:26:49.298
And, one of the cool
applications of this is that

00:26:49.298 --> 00:26:51.938
you can use a SharedWorker
to serialize your

00:26:51.938 --> 00:26:52.920
FileSystem access.

00:26:52.920 --> 00:26:55.220
So, you could have a
SharedWorker do all the access

00:26:55.220 --> 00:26:58.320
to the FileSystem, and you
could have all your other

00:26:58.320 --> 00:27:01.618
worker threads in the main
thread just send requests to

00:27:01.618 --> 00:27:03.326
the SharedWorker saying, you
know, please edit this file

00:27:03.326 --> 00:27:04.780
in the following way.

00:27:04.780 --> 00:27:08.020
And, the SharedWorker can take
care of ensuring all of those

00:27:08.020 --> 00:27:10.840
are done in a safe manner.

00:27:10.840 --> 00:27:12.080
So, SharedWorkers are great.

00:27:12.080 --> 00:27:13.280
We love them.

00:27:13.880 --> 00:27:15.300
But, they do have
some downsides.

00:27:15.300 --> 00:27:18.040
One of the downsides is
that there's no single

00:27:18.040 --> 00:27:19.340
scripting context.

00:27:19.340 --> 00:27:22.058
So, you can't just take a huge
part of the dom, and hand it

00:27:22.058 --> 00:27:24.500
off to a SharedWorker, and
hand that off to another

00:27:24.500 --> 00:27:26.400
worker or another window.

00:27:26.400 --> 00:27:27.118
It doesn't work.

00:27:27.118 --> 00:27:29.940
It's the only things that
you can serialize, passed

00:27:29.940 --> 00:27:32.480
in via post-message.

00:27:32.480 --> 00:27:33.040
So, what do we do.

00:27:33.040 --> 00:27:35.940
It turns out that this is
actually a useful thing to do.

00:27:35.940 --> 00:27:38.440
One of things we're working on
in Gmail is making it possible

00:27:38.440 --> 00:27:42.160
for you to open up a chat
window, or a composed window or

00:27:42.160 --> 00:27:45.220
any other tear off window,
and have that be fast.

00:27:45.220 --> 00:27:48.358
But, also have that window
survive if you close

00:27:48.358 --> 00:27:49.680
the main window.

00:27:49.680 --> 00:27:52.100
So, we want to have a
shared scripting context.

00:27:52.100 --> 00:27:55.180
So, we're working on something
that we call Share iFrame, that

00:27:55.180 --> 00:27:58.758
gives us a shared scripting
context with which we can pass

00:27:58.758 --> 00:28:00.760
around in a part of the dom.

00:28:00.760 --> 00:28:02.560
So, that we can build up
that composed window

00:28:02.560 --> 00:28:03.680
even before you open it.

00:28:03.680 --> 00:28:04.740
And, then just
hand off the dom.

00:28:05.640 --> 00:28:08.440
We can make that window survive
even after the main window is

00:28:08.440 --> 00:28:10.220
closed, by keeping all the
state in what we call

00:28:10.220 --> 00:28:10.760
the magic iFrame.

00:28:11.600 --> 00:28:12.340
This is a new approach.

00:28:12.340 --> 00:28:14.400
It's not yet standard.

00:28:14.400 --> 00:28:16.800
Again, it's just us trying to
think how do we innovate, how

00:28:16.800 --> 00:28:19.520
do we do something new that
addresses real use cases.

00:28:19.520 --> 00:28:22.326
And, if it turns out that
developers like it, we

00:28:22.326 --> 00:28:26.000
will work on making sure
that it's available in all

00:28:26.000 --> 00:28:28.700
browsers and standards.

00:28:28.700 --> 00:28:30.880
At this point, I want
to turn over to my

00:28:30.880 --> 00:28:31.760
colleague Jeff Chang.

00:28:31.760 --> 00:28:32.900
He's going to talk to you a
little bit about some work

00:28:32.900 --> 00:28:38.660
we've done around files,
dragging files and even more.

00:28:38.660 --> 00:28:40.400
JEFF CHANG: Thanks Ian.

00:28:40.400 --> 00:28:43.960
So, hopefully by now, you all
recognize that we want to make

00:28:43.960 --> 00:28:46.600
web applications as powerful
as, if not more powerful

00:28:46.600 --> 00:28:48.780
than, desktop applications.

00:28:48.780 --> 00:28:50.920
And, one of the areas in
which we're doing that is

00:28:50.920 --> 00:28:51.940
dragging and dropping.

00:28:51.940 --> 00:28:55.220
Dragging and dropping not only
files from the desktop or the

00:28:55.220 --> 00:28:57.740
files that's gone into the
browser, but vice versa.

00:28:57.740 --> 00:29:01.298
And, obviously it's a very
simple and intuitive way to

00:29:01.298 --> 00:29:03.480
kind of interact with files,
so that's why it's important.

00:29:04.240 --> 00:29:05.880
There are a few different
examples here.

00:29:05.880 --> 00:29:08.160
So, let me just walk
through each of them.

00:29:08.160 --> 00:29:10.780
So, one of them is drag-in,
dragging in from the desktop

00:29:10.780 --> 00:29:13.520
or any folder in the file
system into the browser.

00:29:13.520 --> 00:29:16.200
One thing you can do here is
you can listen to the drop

00:29:16.200 --> 00:29:16.560
event, obtain the file object.

00:29:17.080 --> 00:29:20.900
and send it via XML HTTP
request to the server.

00:29:20.900 --> 00:29:22.678
This makes sense if you have
a feature where you want to

00:29:22.678 --> 00:29:24.060
upload a file to the server.

00:29:24.060 --> 00:29:27.458
And, as you saw during the
keynote, and there's a screen

00:29:27.458 --> 00:29:29.220
shot there, but I'll go
ahead and show you now.

00:29:29.220 --> 00:29:33.820
This can be used in Gmail
to upload files in emails.

00:29:33.820 --> 00:29:41.118
So, say I have an email here,
and I have a file on the

00:29:41.118 --> 00:29:43.618
desktop that I want to attach.

00:29:43.618 --> 00:29:46.020
So, let me go ahead
and put the message.

00:29:46.020 --> 00:29:47.000
And, if I have the

00:29:47.000 --> 00:29:49.356
file here, all I have to
do you is take it, drag

00:29:49.356 --> 00:29:50.140
it over to message.

00:29:50.140 --> 00:29:50.250
It tells me I

00:29:50.250 --> 00:29:52.800
can drop the file here
as an attachment.

00:29:52.800 --> 00:29:55.220
Let go, and the file gets
uploaded to the server.

00:29:55.220 --> 00:29:57.560
Very intuitive, very
simple it just works.

00:29:57.700 --> 00:29:59.560
Let me show you
another thing too.

00:29:59.560 --> 00:30:02.240
This is also another feature we
recently launched in Gmail.

00:30:02.240 --> 00:30:04.558
You can actually drag the
image into, such as inline

00:30:04.558 --> 00:30:07.520
attachment, directly within
the message text itself.

00:30:07.520 --> 00:30:10.510
So as long as my cursors are
there and I drag it and drop it

00:30:10.510 --> 00:30:14.960
in this section instead, and
boom I get the nice little

00:30:14.960 --> 00:30:17.180
kitten inside the
message itself.

00:30:17.180 --> 00:30:18.820
That's very cool.

00:30:18.820 --> 00:30:21.578
It just works.

00:30:21.578 --> 00:30:23.938
So, there's other instances too
when you want to drag a file

00:30:23.938 --> 00:30:26.280
in, but you might not
necessarily want to send

00:30:26.280 --> 00:30:26.920
it up to the server.

00:30:26.920 --> 00:30:28.840
Maybe the point of it is
that you want to just drag

00:30:28.840 --> 00:30:31.040
the file in and start
interacting with it.

00:30:31.040 --> 00:30:33.280
If you saw the keynote, there
was the application we showed

00:30:33.280 --> 00:30:37.600
off MugThug Darkroom that
Travis Prichard showed.

00:30:37.600 --> 00:30:39.980
And, in this case it's a
photo editing application.

00:30:39.980 --> 00:30:43.800
Well, let's say I have the
skin, and I actually want to

00:30:43.800 --> 00:30:46.460
do some photo effects on the
kitten, I can simply drag it

00:30:46.460 --> 00:30:48.000
over here and using the file
reader interface,

00:30:48.000 --> 00:30:49.460
in the file API.

00:30:49.460 --> 00:30:52.160
I can now start interacting
with the file directly

00:30:52.160 --> 00:30:53.960
on my local machine.

00:30:53.960 --> 00:30:55.300
And, so I can apply the
filters, and change the

00:30:55.300 --> 00:30:57.020
colors and what not.

00:30:57.020 --> 00:30:59.560
And, in this whole time,
the file has stayed

00:30:59.560 --> 00:31:00.180
on my local machine.

00:31:00.180 --> 00:31:02.292
So, it doesn't need to be
sent up to the server.

00:31:02.486 --> 00:31:05.578
And, in fact, this
works offline as well.

00:31:05.578 --> 00:31:08.480
So, that's dragging in.

00:31:08.480 --> 00:31:09.860
There's also dragging out.

00:31:09.860 --> 00:31:12.860
That's from the browser.

00:31:20.160 --> 00:31:22.300
So dragging out involves
dragging from the

00:31:22.300 --> 00:31:23.818
browser to the desktop.

00:31:24.000 --> 00:31:27.598
And, in this case, you actually
use the download URL format in

00:31:27.598 --> 00:31:31.178
data transfer object, which
contains file type, the name of

00:31:31.178 --> 00:31:33.780
the file, and the URL from
which to download the file.

00:31:33.780 --> 00:31:37.220
So, let me show you a sneak
peak of a feature that we

00:31:37.220 --> 00:31:40.420
are building in Gmail that
takes advantage of this.

00:31:40.420 --> 00:31:43.320
This feature is basically you
have an email, and you have

00:31:43.320 --> 00:31:45.300
a file attachment here.

00:31:45.300 --> 00:31:47.298
And, you want to save it
somewhere in your computer.

00:31:47.298 --> 00:31:49.118
I could have just click the
download link here, and I know

00:31:49.118 --> 00:31:52.460
that's going to put it into the
default directory that Chrome

00:31:52.460 --> 00:31:53.640
downloads to, whatever
that's set to.

00:31:53.640 --> 00:31:56.438
But, this isn't my computer,
I don't actually know where

00:31:56.438 --> 00:31:57.738
exactly that would download to.

00:31:57.738 --> 00:31:58.738
I don't want to hunt
around for the file.

00:31:58.738 --> 00:32:01.278
I just know I want to save the
file right here on the desktop.

00:32:01.178 --> 00:32:03.678
So, what I'll do
is hover over it.

00:32:03.678 --> 00:32:06.940
It prompts me click
or view to save.

00:32:06.940 --> 00:32:08.900
Drag, drop right here.

00:32:08.900 --> 00:32:11.300
And, bam, it downloads
it to my desktop.

00:32:11.300 --> 00:32:13.640
So, again, very simple, very
intuitive, and a great way

00:32:13.640 --> 00:32:19.560
to interact with files.

00:32:19.560 --> 00:32:21.480
Another cool feature
is Notifications.

00:32:21.500 --> 00:32:23.798
Hopefully you saw this
during the keynote as well.

00:32:23.798 --> 00:32:25.380
I think the use case
here is pretty clear.

00:32:25.380 --> 00:32:29.020
You want to let the application
notify the user in an

00:32:29.020 --> 00:32:30.000
unobtrusive manner.

00:32:30.260 --> 00:32:32.980
And, this can be a
variety of situations.

00:32:32.980 --> 00:32:35.780
This could be, let's say you
have a calendar event that's

00:32:35.780 --> 00:32:36.820
coming up that's really
important, you don't

00:32:36.820 --> 00:32:37.800
want to miss that.

00:32:38.900 --> 00:32:40.198
Let's say you have an email
that's coming into your

00:32:40.198 --> 00:32:41.960
inbox, you want to be
notified about that.

00:32:41.960 --> 00:32:44.338
You have Tweet coming in,
you want to see those.

00:32:44.558 --> 00:32:46.620
Or, in this case, let's
say somebody sends

00:32:46.620 --> 00:32:48.526
you a Google Chat.

00:32:48.526 --> 00:32:49.220
Then bam.

00:32:49.220 --> 00:32:52.240
You get a notification.

00:32:52.240 --> 00:32:56.040
So, in terms of the actual way
this is implemented, the

00:32:56.040 --> 00:33:00.238
developer, the app developer,
can provide the content

00:33:00.238 --> 00:33:01.480
as HTML or plain text.

00:33:02.340 --> 00:33:04.000
This feature does
have to be opt in.

00:33:04.440 --> 00:33:07.000
The user does have to
permission it, it does have

00:33:07.000 --> 00:33:10.440
to be assigned on an origin
basis for notifications.

00:33:10.440 --> 00:33:13.780
And, in Chrome we do that in a
similar way to, what Ian showed

00:33:13.780 --> 00:33:16.760
with geolocation, you get a
little info bar that says,

00:33:16.760 --> 00:33:19.880
would you like to let this
domain show you notifications.

00:33:19.880 --> 00:33:21.840
So, there's currently
two specs in progress.

00:33:21.840 --> 00:33:26.560
Ones on the W3C website, and
ones on Chromium.org website.

00:33:27.340 --> 00:33:30.980
But, the plan is to deprecate
the Chromium specific

00:33:30.980 --> 00:33:32.080
one in favor of the
standards track one.

00:33:32.080 --> 00:33:37.600
And, I believe the W3C one is
currently in editor's draft.

00:33:37.600 --> 00:33:38.660
So, that's notifications.

00:33:38.660 --> 00:33:40.820
So, I'm going to go ahead
and pass it back to Ian

00:33:40.820 --> 00:33:41.020
now, who's going to

00:33:41.020 --> 00:33:51.500
talk about some more
stuff on the Horizon.
773
00:33:51,5 --&gt; 00:33:51,44
IAN FETTE: Thanks Jeff.

00:33:51.440 --> 00:33:52.340
So, what's over the Horizon.

00:33:52.340 --> 00:33:54.820
We've showed you
what we've done.

00:33:54.820 --> 00:33:56.880
We've showed you some things
that we've been working

00:33:56.880 --> 00:33:57.720
on over the past year.

00:33:57.720 --> 00:33:59.200
What's coming next.

00:33:59.200 --> 00:34:01.920
It turns out there's a lot
of new capabilities coming.

00:34:01.920 --> 00:34:05.120
If you look at a lot of the
demos from Android this

00:34:05.120 --> 00:34:07.180
morning, you'll see that
people used voice.

00:34:08.580 --> 00:34:12.638
Voice turns out to be a very
natural interaction mechanism.

00:34:12.638 --> 00:34:15.978
People want to speak
their input for certain

00:34:15.978 --> 00:34:16.398
types of queries.

00:34:16.918 --> 00:34:19.978
If you think about it, I drove
here in a Toyota Prius, I

00:34:19.978 --> 00:34:23.720
could hit a button and say,
you know, Moscone West.

00:34:23.720 --> 00:34:25.880
I could drive up here, I have
that, you know, pre-programmed,

00:34:25.880 --> 00:34:26.998
it gets recognized.

00:34:26.998 --> 00:34:29.560
I can control my
car with my voice.

00:34:29.560 --> 00:34:32.518
And, my car can
speak back to me.

00:34:32.518 --> 00:34:36.638
There's voice recognition,
and there's text speech.

00:34:36.638 --> 00:34:39.680
So, we figured, why not build
that into the browser.

00:34:39.680 --> 00:34:40.658
So, we're going to do it.

00:34:40.658 --> 00:34:41.178
How do we do it though.

00:34:41.178 --> 00:34:44.938
We don't want to just give you
a giant wave file and say,

00:34:44.938 --> 00:34:46.198
here you go figure out
what the user said.

00:34:46.198 --> 00:34:48.458
That wound't actually
be that useful.

00:34:48.458 --> 00:34:51.198
So, what we're doing is we're
adding a new input tag.

00:34:51.198 --> 00:34:53.898
We're calling it input
type equals speech.

00:34:53.898 --> 00:34:56.678
And, our vision for this is
that it will like input

00:34:56.678 --> 00:34:58.058
type equals text.

00:34:58.058 --> 00:35:00.000
It probably will produce
a little text area.

00:35:00.000 --> 00:35:03.720
But, also have a little
microphone button, that the

00:35:03.720 --> 00:35:06.100
user can click on to say, yes,
I actually want to speak now,

00:35:06.100 --> 00:35:08.998
and I want you to recognize
what I'm speaking.

00:35:08.998 --> 00:35:12.218
And, when the user does
this, we will recognize

00:35:12.218 --> 00:35:13.540
the users speech.

00:35:13.540 --> 00:35:17.360
We'll take that audio send it
up to a server for processing,

00:35:17.360 --> 00:35:20.428
although it could also be
done locally depending on

00:35:20.428 --> 00:35:22.900
implementation, and make that
available to the website.

00:35:23.320 --> 00:35:26.060
So, whatever the user speaks
will be transcribed, and put

00:35:26.060 --> 00:35:28.198
into the value of the tag.

00:35:28.198 --> 00:35:30.658
We'll also give you even
more control though.

00:35:30.658 --> 00:35:32.158
Because, it turns out that's
not quite sufficient.

00:35:32.158 --> 00:35:34.188
For any of you who have dealt
with speech processing in

00:35:34.188 --> 00:35:37.998
the past, you know that in
specialized areas, you might

00:35:37.998 --> 00:35:39.498
want to restrict the grammar.

00:35:39.498 --> 00:35:42.078
So, if you're calling up Delta
and they're asking you is this

00:35:42.078 --> 00:35:44.238
a domestic flight or an
international flight.

00:35:44.238 --> 00:35:46.338
Turns out, they only want
to know if it's domestic

00:35:46.338 --> 00:35:46.458
or international.

00:35:46.458 --> 00:35:48.718
They don't want to know
if you want pizza.

00:35:48.718 --> 00:35:53.098
So, if you provide a grammar,
you can make it possible to

00:35:53.098 --> 00:35:55.418
have even better accuracy
and recognition.

00:35:55.418 --> 00:35:58.118
So, we're going to support
providing a grammar

00:35:58.118 --> 00:36:00.578
for that input tag.

00:36:00.578 --> 00:36:03.200
We'll also give you events,
like change events and stock

00:36:03.200 --> 00:36:07.498
events, so that you can process
the data sequentially.

00:36:07.498 --> 00:36:11.320
So, as the user is speaking and
we recognize another word,

00:36:11.320 --> 00:36:14.858
we'll give you an event, so
that you can act on that.

00:36:14.858 --> 00:36:16.058
Or, if you only care about it
at the end, we'll give you

00:36:16.058 --> 00:36:18.198
an event for that too.

00:36:18.198 --> 00:36:21.758
So, that's how you can
get data in from voice.

00:36:21.758 --> 00:36:22.908
How do you get data out.

00:36:22.908 --> 00:36:23.118
How do you speak results back.

00:36:23.118 --> 00:36:26.418
How do you say, you know,
turn left in 300 meters.

00:36:26.418 --> 00:36:30.198
Oops you went too far, make a
legal u-turn when possible.

00:36:30.198 --> 00:36:33.258
We're going to provide an
API called text to speech.

00:36:33.258 --> 00:36:34.718
You know, it makes sense, TTS.

00:36:35.038 --> 00:36:38.458
This will be another tag where
you provide a value, and that

00:36:38.458 --> 00:36:42.018
value is whatever gets
spoken to the user.

00:36:42.018 --> 00:36:45.278
But, we're going to make it
just like audio tag, so it will

00:36:45.278 --> 00:36:46.158
inherit from the audio tags.

00:36:46.158 --> 00:36:48.818
So, that you'll have all same
controls, that you would

00:36:48.818 --> 00:36:48.978
have from the audio tag.

00:36:48.978 --> 00:36:49.998
You can play.

00:36:49.998 --> 00:36:50.760
You can pause.

00:36:50.760 --> 00:36:52.020
You can stop.

00:36:52.020 --> 00:36:55.200
You can script it in JavaScript
in the exact same way that you

00:36:55.200 --> 00:36:57.866
would script an audio
tag or a video tag.

00:36:58.912 --> 00:37:03.260
So, we're hopeful that these
two APIs together will enable a

00:37:03.260 --> 00:37:07.460
whole new class of application
on both mobile browsers as

00:37:07.460 --> 00:37:08.598
well as desktop browsers.

00:37:08.598 --> 00:37:10.158
Because, if you look at a
lot of netbooks being

00:37:10.158 --> 00:37:13.738
sold today, they all have
microphones in them.

00:37:13.738 --> 00:37:17.978
So, why not let the
websites access them.

00:37:17.978 --> 00:37:23.040
It turns out that many cameras,
netbooks, and even laptops

00:37:23.040 --> 00:37:27.678
have another device.

00:37:27.578 --> 00:37:30.138
So, we're not just going
to give you access

00:37:30.138 --> 00:37:31.638
to speech input.

00:37:31.638 --> 00:37:33.560
We're not just going
to do transcription.

00:37:33.560 --> 00:37:35.380
We also realize that if you
really want to access that

00:37:35.380 --> 00:37:37.560
microphone, and do everything
you can with it, you might

00:37:37.560 --> 00:37:40.020
want to record the sound.

00:37:40.020 --> 00:37:43.238
You might want to record
yourself singing a

00:37:43.238 --> 00:37:44.480
new Lady Gaga song.

00:37:44.480 --> 00:37:45.440
So, you can put that
up on YouTube.

00:37:46.978 --> 00:37:50.978
Or, you might just want to,
for whatever reason, take

00:37:50.978 --> 00:37:51.548
that, process it as

00:37:51.548 --> 00:37:53.360
a wave, and do your
own processing.

00:37:53.360 --> 00:37:57.098
So, we're going to give you
access to the microphone in

00:37:57.098 --> 00:38:02.018
terms of just being able
to get a single blob up.

00:38:02.018 --> 00:38:05.618
The other API that we want to
expose is access to the webcam.

00:38:05.858 --> 00:38:10.320
It turns out that that's the
other device that many laptops,

00:38:10.320 --> 00:38:13.280
netbooks, and cameras,
excuse me cell phones, are

00:38:13.280 --> 00:38:15.740
shipping with is a camera.

00:38:15.740 --> 00:38:17.420
So, how do we give
you access to that.

00:38:17.420 --> 00:38:20.698
Similar to the microphone, we
want to provide two methods.

00:38:20.698 --> 00:38:24.280
We want to provide a way for
you to get a Blob, a still

00:38:24.280 --> 00:38:27.478
picture that you can use
locally, upload to the

00:38:27.478 --> 00:38:29.198
server, whatever you want.

00:38:29.198 --> 00:38:32.378
And, we also want to be
able to give you a stream.

00:38:32.378 --> 00:38:37.900
So, if you want to have a video
chat application, for instance,

00:38:37.900 --> 00:38:38.724
we want to enable that.

00:38:38.792 --> 00:38:42.158
So, we want to give you access
to a stream of video as well.

00:38:42.158 --> 00:38:44.632
This is not something that
we have working yet.

00:38:44.986 --> 00:38:46.878
It's something
that's in progress.

00:38:46.658 --> 00:38:49.580
You saw a preview of this in
the keynote, but there's a lot

00:38:49.580 --> 00:38:54.898
more to come in this area.

00:38:54.898 --> 00:38:55.798
So, audio is cool.

00:38:55.798 --> 00:38:57.738
I love cars talking to me.

00:38:57.798 --> 00:39:00.558
I love hearing a recorded
sound played back to me.

00:39:00.558 --> 00:39:04.318
But, how many gamers
do I have out here?

00:39:04.318 --> 00:39:04.598
Okay, good.

00:39:04.598 --> 00:39:05.298
I see some hands.

00:39:05.298 --> 00:39:06.278
I love games.

00:39:06.278 --> 00:39:08.358
It turns out, that if you're
playing a first-person shooter,

00:39:08.358 --> 00:39:12.378
and you've got a 5.1 sound
system, you want to know who's

00:39:12.378 --> 00:39:14.418
shooting at you and from where.

00:39:14.418 --> 00:39:16.238
You want positional audio.

00:39:16.238 --> 00:39:20.300
You want that sound to be able
to come not just from the right

00:39:20.300 --> 00:39:23.978
or from the left, but from in
front of you, from behind

00:39:23.978 --> 00:39:25.958
you, from at an angle.

00:39:25.958 --> 00:39:27.198
You want things like reverb.

00:39:27.398 --> 00:39:32.498
So, we are going to give you
access to a fully featured

00:39:32.498 --> 00:39:35.638
positional audio API that will
give you all these controls.

00:39:35.638 --> 00:39:38.060
It will give you things like
control over directionality.

00:39:38.060 --> 00:39:41.020
It will give you volume, send
configuration, gain,

00:39:41.020 --> 00:39:44.000
inner/outer cone, distance
attenuation, pitch, occlusion,

00:39:44.000 --> 00:39:45.238
obstruction, reverb.

00:39:45.238 --> 00:39:47.118
All of these things
will be supported.

00:39:47.118 --> 00:39:49.078
And, it'll be supported in a
way that's simple for you, so

00:39:49.078 --> 00:39:51.158
you don't have to implement
a full physics engine in

00:39:51.158 --> 00:39:54.978
JavaScript just to try to do
positional audio on your own.

00:39:54.978 --> 00:39:58.378
So, this will also make it
possible to develop richer

00:39:58.378 --> 00:40:00.860
games in the browser.

00:40:00.860 --> 00:40:03.678
But, richer games need more
than just great audio It turns

00:40:03.678 --> 00:40:04.958
out they need great video.

00:40:04.958 --> 00:40:08.538
And, Canvas and the video
tag alone are not enough.

00:40:08.538 --> 00:40:12.898
So, we're working on
supporting 3D in the browser.

00:40:12.898 --> 00:40:16.200
There's a new specification
being developed called WebGL

00:40:16.200 --> 00:40:19.340
that exposes OpenGL via
JavaScript findings.

00:40:19.340 --> 00:40:23.038
And, with this, you can
create immersive 3D scenes.

00:40:23.038 --> 00:40:27.498
So, you can access the full
power of the GPU that's on that

00:40:27.498 --> 00:40:29.618
desktop computer, that's on
that laptop computer, that may

00:40:29.618 --> 00:40:33.798
even be on that mobile phone.

00:40:33.798 --> 00:40:37.898
So, this 3D video, together
with positional audio, will

00:40:37.898 --> 00:40:41.458
also enable a new class
of applications.

00:40:41.458 --> 00:40:46.378
WebGL was actually pioneered
a while ago by Firefox, and

00:40:46.378 --> 00:40:50.958
Google also did work in this
area with up with O3D.

00:40:50.958 --> 00:40:53.158
There's some differences
between WebGL and the O3D

00:40:53.158 --> 00:40:55.038
work that we did earlier.

00:40:55.038 --> 00:40:58.538
Namely, with O3D, you
build up a scene.

00:40:58.538 --> 00:41:01.920
And, that scene is retained, so
it's called retained mode API.

00:41:01.920 --> 00:41:03.720
And, you can make
changes to the scene.

00:41:03.720 --> 00:41:05.180
You can say, you know, take
the torch and make it

00:41:05.180 --> 00:41:06.960
lean left, lean right.

00:41:06.960 --> 00:41:08.578
But, you don't redraw
the scene each time.

00:41:09.578 --> 00:41:12.780
With WebGL, it's a director
and media mode API.

00:41:12.780 --> 00:41:16.780
So, each time you issue queries
saying draw this vertex here,

00:41:16.780 --> 00:41:17.060
this vertex there, you know.

00:41:17.060 --> 00:41:20.940
You basically draw
it each time.

00:41:20.940 --> 00:41:23.460
So, there is a difference, but
we're doing work for those

00:41:23.460 --> 00:41:26.878
of you who invested an O3D.

00:41:27.098 --> 00:41:29.438
We're doing work to provide
a compatibility layer

00:41:29.438 --> 00:41:31.898
for O3D on top of WebGL.

00:41:31.898 --> 00:41:32.998
So, we're excited by WebGL.

00:41:33.978 --> 00:41:36.198
I want to show you a quick
demo of what you can do.

00:41:36.198 --> 00:41:38.858
I was hoping to be able to
show you the beach demo,

00:41:38.858 --> 00:41:40.938
I can't show you that.

00:41:40.938 --> 00:41:47.778
But, one of the cool things
that you can do, if you look at

00:41:47.778 --> 00:41:50.980
the source code for this, which
I'm not going to do, but this

00:41:50.980 --> 00:41:56.798
is actually very, very small
in terms of source code.

00:41:56.798 --> 00:41:57.298
It's a pretty simple
application.

00:41:57.298 --> 00:41:59.058
But, I can do all sorts of
things like, you know, create

00:41:59.058 --> 00:42:02.558
3D effects, little puffs,
little trails of fire

00:42:02.558 --> 00:42:04.698
going around in a circle.

00:42:04.698 --> 00:42:06.158
And, it's all very possible.

00:42:06.158 --> 00:42:07.118
It works very well.

00:42:07.118 --> 00:42:11.398
And, this actually works both
in Google Chrome with a

00:42:11.398 --> 00:42:13.058
command line flag, as well
as with Mozilla Firefox.

00:42:13.438 --> 00:42:16.990
So, this is already getting
great reception, great

00:42:16.990 --> 00:42:19.540
adoption, and I really do
believe that this is going

00:42:19.540 --> 00:42:21.280
to enable a new class
of applications.

00:42:21.280 --> 00:42:22.960
A new set of games.

00:42:23.420 --> 00:42:26.360
Really help people understand
that the browser is a great

00:42:26.360 --> 00:42:28.140
place to develop that
application that you

00:42:28.140 --> 00:42:30.038
want to develop.

00:42:30.038 --> 00:42:32.900
So, with that, I want to
turn it over for Q&amp;A.

00:42:32.900 --> 00:42:36.738
I hope that I have given you a
bit of insight into how browser

00:42:36.738 --> 00:42:39.020
development works, how the
development of standards works,

00:42:39.020 --> 00:42:43.000
and inspired you in
terms of HTML5.

00:42:43.980 --> 00:42:44.598
That's my hope.

00:42:45.118 --> 00:42:45.478
Please feel free.

00:42:45.478 --> 00:42:48.278
There are microphones here in
the aisles, if you have any

00:42:48.278 --> 00:42:49.924
questions, come on up, I'm
happy to answer them.

00:42:49.026 --> 00:43:02.058
Thanks [APPLAUSE].

00:43:02.058 --> 00:43:03.300
AUDIENCE: Thank
you for the talk.

00:43:03.300 --> 00:43:10.258
Can you explain the
behavior, how the grammar
980
00:43:10,258 --&gt; 00:43:10,078
attribute will work?

00:43:10.078 --> 00:43:13.818
Is there going to be a limit
on the length, or how that

00:43:13.818 --> 00:43:15.018
attribute would work?

00:43:15.018 --> 00:43:17.138
IAN FETTE: So, there's an
existing specification that

00:43:17.138 --> 00:43:20.578
I believe actually is
being worked in W3C for

00:43:20.578 --> 00:43:24.598
grammars of languages.

00:43:24.858 --> 00:43:26.278
We're hoping to leverage that
existing specification.

00:43:26.218 --> 00:43:29.038
I have to apologize, I don't
actually remember the name

00:43:29.038 --> 00:43:31.738
off the top of my head.

00:43:31.738 --> 00:43:33.638
AUDIENCE: What is it again?

00:43:33.638 --> 00:43:33.998
IAN FETTE: SSML.

00:43:33.998 --> 00:43:37.198
So, if you the search for that,
you should be able to find

00:43:37.198 --> 00:43:39.398
more details in voice XML.

00:43:40.138 --> 00:43:44.988
Sorry, I don't actually
remember off the top of my

00:43:44.988 --> 00:43:46.578
head, you'll have to search on
that, but we're hoping to make

00:43:46.578 --> 00:43:48.218
it as full featured
as possible.

00:43:49.778 --> 00:43:50.338
Yes?

00:43:50.458 --> 00:43:51.598
AUDIENCE: Hi.

00:43:51.598 --> 00:43:57.178
I'm very excited about
exposing tensors on mobile

00:43:57.178 --> 00:43:58.338
devices through HTML5.

00:43:58.338 --> 00:44:00.438
Do you have plans to expose
more, like the Accelerometer

00:44:00.438 --> 00:44:02.658
and other things like that?

00:44:02.658 --> 00:44:05.758
IAN FETTE: Yes, so the Android
Web Browser Team is very

00:44:05.758 --> 00:44:08.388
interested in figuring out how
we expose all capabilities of

00:44:08.388 --> 00:44:10.498
the platform, not just the
microphone and the camera, but

00:44:10.498 --> 00:44:15.300
things like the accelerometer,
the magnetometer for direction.

00:44:15.580 --> 00:44:17.060
So, we're working on
exposing all those.

00:44:17.060 --> 00:44:21.340
Of course, as we do that, we'll
also work with standards bodies

00:44:21.340 --> 00:44:23.832
to make sure that there is a
standard around this, and it

00:44:23.832 --> 00:44:26.720
works not just on Android
devices, but on any mobile

00:44:26.720 --> 00:44:28.740
device that chooses to
implement the standard.

00:44:29.840 --> 00:44:31.860
We want to make that
work everywhere.

00:44:31.860 --> 00:44:36.718
JEFF CHANG: I believe they
demonstrated the, at least the

00:44:36.718 --> 00:44:39.110
compass in Android and in the
browser during the keynote.

00:44:39.110 --> 00:44:40.618
They were showing it,
turning it around.

00:44:40.618 --> 00:44:41.400
IAN FETTE: Yes.

00:44:41.400 --> 00:44:43.458
So, we're definitely
working on it.

00:44:43.458 --> 00:44:43.550
JEFF CHANG: Thank you.

00:44:43.550 --> 00:44:44.098
AUDIENCE: Thanks.

00:44:44.098 --> 00:44:47.478
AUDIENCE: Speaking of new input
devices, what about pressure

00:44:47.478 --> 00:44:50.238
sensitivity and sub-pixel
positioning for graphics?

00:44:51.118 --> 00:44:54.998
IAN FETTE: Pressure sensitivity
and sub-pixel positioning.

00:44:55.798 --> 00:44:59.100
I can't say it's honestly at
the top my priority list.

00:44:59.100 --> 00:45:01.660
I'm happy to add it onto
the list, and try figure

00:45:01.660 --> 00:45:02.760
out how to do it.

00:45:02.760 --> 00:45:04.718
But, right now, I think
we're at the point where

00:45:04.718 --> 00:45:06.298
we have so much going on.

00:45:06.298 --> 00:45:09.818
We're still working on a lot of
the primitives, like the how

00:45:09.818 --> 00:45:12.698
you store data, how you make an
offline application accessible,

00:45:12.698 --> 00:45:15.638
how you draw basic data
with Canvas and WebGL.

00:45:15.880 --> 00:45:19.460
So, yes I agree that, you
know, it is a valid use case

00:45:19.460 --> 00:45:21.178
and something we should
figure out how to do.

00:45:21.178 --> 00:45:23.998
But, it's not something we're
actively working on just yet.

00:45:23.998 --> 00:45:24.738
I apologize.

00:45:27.318 --> 00:45:29.780
Although someone at the
W3C is, Doug tells me.

00:45:29.780 --> 00:45:30.458
Yes?

00:45:30.458 --> 00:45:33.338
AUDIENCE: At the risk of
sounding greedy will you

00:45:33.338 --> 00:45:37.038
localize translate input
speech and text to speech?

00:45:37.038 --> 00:45:39.798
IAN FETTE: So, will we localize
-- you're basically asking

00:45:39.798 --> 00:45:42.738
would we do translation of the
text to speech in voice input.

00:45:45.118 --> 00:45:47.978
Sounds like fun challenge.

00:45:47.978 --> 00:45:49.118
I'm sure someone at Google
would love to do it.

00:45:49.118 --> 00:45:51.818
I can't tell you that we're
actually doing it yet,

00:45:51.818 --> 00:45:53.498
but it sounds fun.

00:45:53.498 --> 00:45:58.158
So, we'll consider it.

00:45:58.158 --> 00:45:58.558
Yes?

00:45:58.558 --> 00:46:00.740
AUDIENCE: One thing I've
noticed is that when the

00:46:00.740 --> 00:46:03.640
browser requires a permission
dialog, usually it seems to be

00:46:03.640 --> 00:46:07.398
at the point that JavaScript
requests for something.

00:46:07.398 --> 00:46:11.198
So, is there like a way maybe
through a meta tag or something

00:46:11.198 --> 00:46:17.518
that you can say this site is
going to ask for location for

00:46:17.518 --> 00:46:21.038
disk space, etc. etc. before it
gets to that point in the code?

00:46:21.038 --> 00:46:23.578
IAN FETTE: So, right now
there's not a declarative

00:46:23.578 --> 00:46:25.958
model to ask for a lot of
permissions in advance.

00:46:25.958 --> 00:46:27.858
It's one of the things that
we're trying to figure out

00:46:27.858 --> 00:46:29.578
with the Web Store, is
how do I provide a

00:46:29.788 --> 00:46:31.300
good declarative model.

00:46:31.300 --> 00:46:34.800
And, our hope is that if we get
that right, and developers

00:46:34.800 --> 00:46:37.518
respond positively saying, you
know, yes, this is a good

00:46:37.518 --> 00:46:39.718
model, this is the capability
that we actually want

00:46:39.718 --> 00:46:40.978
that works for us.

00:46:40.978 --> 00:46:43.198
That, we can turn it into a
standard that's usable not just

00:46:43.198 --> 00:46:47.238
for applications packaged up in
the Web Store, but on any

00:46:47.238 --> 00:46:49.358
application regardless of
whether it's in the Web Store

00:46:49.358 --> 00:46:51.886
or whether it's a URL
I just browsed to.

00:46:51.962 --> 00:46:59.238
So, we want to make it possible
for all web pages to declare

00:46:59.238 --> 00:47:01.318
the permissions that
they intend to use.

00:47:01.318 --> 00:47:02.498
So, it's something
we want to do.

00:47:02.498 --> 00:47:04.158
We're not there yet, but
we're working on it.

00:47:04.158 --> 00:47:06.738
JEFF CHANG: And, one thing to
add to that which Eric Kay

00:47:06.738 --> 00:47:10.238
showed at the Web Store session
earlier today was, we

00:47:10.238 --> 00:47:11.960
definitely want to kind
of simplify that user

00:47:11.960 --> 00:47:12.600
experience for people.

00:47:12.600 --> 00:47:15.158
Because, let's say you have a
crazy off the map that uses the

00:47:15.158 --> 00:47:17.780
camera and the microphone, the
notification, the geolocation,

00:47:17.780 --> 00:47:18.560
and all this stuff.

00:47:18.560 --> 00:47:20.770
You know, we don't want to just
show the user info bar, info

00:47:20.770 --> 00:47:22.360
bar, info bar and
like 5, 6 things.
1080
00:47:22,36 --&gt; 00:47:22,34
Do you want to do this.

00:47:22.340 --> 00:47:23.760
Do you want to let it do this.

00:47:23.760 --> 00:47:26.438
And, they'll be like, yeah, I
guess, I guess, I guess, maybe.

00:47:26.438 --> 00:47:29.588
And, so the idea behind the Web
Store, which Eric was showing

00:47:29.588 --> 00:47:32.918
was at the time of installation
of the application, when you're

00:47:32.918 --> 00:47:35.078
actually creating that shortcut
on your new tab page, then you

00:47:35.078 --> 00:47:38.038
can see this application is
using all these things.

00:47:38.038 --> 00:47:40.980
And, that itself is hard coded
into the manifest that the

00:47:40.980 --> 00:47:41.598
application developer
has provided.

00:47:41.598 --> 00:47:43.960
And, so at that point it has
been cleared, and you never

00:47:43.960 --> 00:47:46.198
have t kind of inundate the
user with a bunch of info bars.

00:47:46.198 --> 00:47:49.458
AUDIENCE: OK.

00:47:49.458 --> 00:47:54.860
I had a couple of
other questions.

00:47:54.860 --> 00:47:56.820
Most voice systems are actually
optimized to understand

00:47:56.820 --> 00:47:58.038
natural speech.

00:47:58.038 --> 00:47:59.558
So, the way I'm speaking now.

00:47:59.558 --> 00:48:02.058
But I believe a lot of people
when they speak to -- a

00:48:02.058 --> 00:48:05.218
computer speaks to them, hello
how are you, and then they want

00:48:05.218 --> 00:48:09.260
to speak back clear enunciated
and then the system messes up.

00:48:09.260 --> 00:48:14.858
So, how do you handle that?

00:48:14.858 --> 00:48:16.138
Have you considered that all?

00:48:16.138 --> 00:48:17.698
IAN FETTE: So, yes and no.

00:48:17.378 --> 00:48:19.658
Yes, you definitely do need to
take that into account when

00:48:19.658 --> 00:48:21.358
designing the voice
recognition.

00:48:21.358 --> 00:48:24.398
It's sort of orthogonal to
the actual standard that

00:48:24.398 --> 00:48:25.040
goes in the browser.

00:48:25.040 --> 00:48:28.060
But, Yes, it's something we're
of that certain people do tend

00:48:28.060 --> 00:48:31.740
to speak differently when
speaking to a voice

00:48:31.740 --> 00:48:32.158
recognition systems.

00:48:32.158 --> 00:48:36.058
However, there are a number
of people who do not speak

00:48:36.058 --> 00:48:38.198
clearly, and enunciate clearly
when speaking to a computer.

00:48:38.198 --> 00:48:40.038
So, you do have to handle both.

00:48:40.038 --> 00:48:43.938
It is something that our team
is, the Voice Team at Google

00:48:43.938 --> 00:48:47.458
is definitely aware of.

00:48:47.458 --> 00:48:47.594
AUDIENCE: OK.

00:48:47.664 --> 00:48:47.918
Then one other thing was --

00:48:47.918 --> 00:48:48.062
IAN FETTE: Last question.

00:48:48.214 --> 00:48:49.158
Sorry.

00:48:49.158 --> 00:48:52.138
AUDIENCE: Yeah, yeah, please

00:48:52.138 --> 00:48:52.358
IAN FETTE: OK.

00:48:52.358 --> 00:48:55.418
AUDIENCE: So, there's a lot
of stuff going on with the

00:48:55.418 --> 00:49:01.278
browser, but in terms of HTML
itself is, well kind of ugly.

00:49:01.278 --> 00:49:08.938
And, what about having
some sort of system that

00:49:08.938 --> 00:49:11.598
could searches through
JSON or something.

00:49:11.598 --> 00:49:13.238
I mean as we're moving
a web applications.

00:49:13.238 --> 00:49:17.798
Being able to somehow
understand content when

00:49:17.798 --> 00:49:18.178
it's not just HTML.

00:49:18.178 --> 00:49:21.898
IAN FETTE: You know something,
there's a number of proposals

00:49:21.898 --> 00:49:24.538
for markup for meta data.

00:49:27.858 --> 00:49:30.738
You know, it's a lot of people
for a lot of years have said,

00:49:30.738 --> 00:49:33.658
you know, if we have all this
meta data about data, we can do

00:49:33.658 --> 00:49:35.058
a better job of searching it.

00:49:35.058 --> 00:49:37.718
To some extent that's true, but
to another extent if you look

00:49:37.718 --> 00:49:42.440
at Google as search engine, it
actually does a remarkable just

00:49:42.440 --> 00:49:44.400
inferring from untagged data.

00:49:44.238 --> 00:49:48.198
So, if I'm ready to throw in
the towel on HTML just yet.

00:49:48.198 --> 00:49:55.618
AUDIENCE: Thanks.

00:49:55.618 --> 00:49:55.978
IAN FETTE: Yes?

00:49:55.978 --> 00:49:59.898
AUDIENCE: If you track a folder
or multiple files, how's that

00:49:59.898 --> 00:50:02.598
handled, and follow
up questions is --

00:50:02.598 --> 00:50:03.280
IAN FETTE: Yeah.

00:50:03.280 --> 00:50:06.238
So, you get a file list that
you can then enumerate it and

00:50:06.238 --> 00:50:09.540
get individual files
from the file list.

00:50:09.540 --> 00:50:11.500
AUDIENCE: So, folders you
can have, and you can get

00:50:11.500 --> 00:50:13.440
everything, recursive
folders, everything in --

00:50:13.440 --> 00:50:16.980
JEFF CHANG: So, there is a
directory upload proposal

00:50:16.980 --> 00:50:21.358
that's being worked on by John
Gregg, and I believe it's

00:50:21.358 --> 00:50:23.078
making the rounds on the Web
WG mailing list right now.

00:50:23.078 --> 00:50:25.538
In order to be able to have an
input type equals directory or

00:50:25.538 --> 00:50:27.458
whatever, and actually have the
recursive things of

00:50:27.458 --> 00:50:28.498
a hold directory.

00:50:28.498 --> 00:50:30.880
So, it's not in the specs
yet, but something already

00:50:30.880 --> 00:50:31.580
being actively discussed.

00:50:31.580 --> 00:50:32.698
IAN FETTE: Multiple files, yes.

00:50:32.698 --> 00:50:36.240
Directory with multiple
files in the works.

00:50:36.240 --> 00:50:36.880
AUDIENCE: OK.

00:50:36.880 --> 00:50:39.100
And a follow up if you have a
large file like a gigabyte

00:50:39.100 --> 00:50:42.000
video, is there any resume
upload or anything like that?

00:50:42.000 --> 00:50:42.496
IAN FETTE: Is

00:50:42.496 --> 00:50:42.924
there any what?
1161
00:50:43,076 --&gt; 00:50:42,94
Sorry.

00:50:42.940 --> 00:50:43.886
AUDIENCE:

00:50:43.886 --> 00:50:44.758
Resume upload.

00:50:44.758 --> 00:50:46.158
JEFF CHANG: Sorry, I think
blob.slice does that, right?

00:50:46.158 --> 00:50:50.238
IAN FETTE: So, with the File
API, you can get access

00:50:50.238 --> 00:50:51.258
to the file locally.

00:50:51.020 --> 00:50:54.460
And, you can slice it to
get access to parts of the

00:50:54.460 --> 00:50:55.438
file and send those up.

00:50:55.918 --> 00:50:58.938
We are working on ways to
make it more convenient

00:50:58.938 --> 00:51:01.098
to do resumption.

00:51:01.098 --> 00:51:03.878
I'm not entirely clear right
now how that would look.

00:51:04.018 --> 00:51:07.380
But, it is technically
possible, right now

00:51:07.380 --> 00:51:12.078
if not convenient.

00:51:12.078 --> 00:51:14.438
Yes?

00:51:14.438 --> 00:51:15.958
AUDIENCE: With the Chrome App
Store, when you download the

00:51:15.958 --> 00:51:18.438
information to one computer, is
their any intent or something

00:51:18.438 --> 00:51:21.638
built in already for being able
to use that application on a

00:51:21.638 --> 00:51:23.320
different computer, with a
different installation

00:51:23.320 --> 00:51:24.978
of Chrome?

00:51:24.978 --> 00:51:28.618
JEFF CHANG: So, I mean, I think
in general with Chrome, we've

00:51:28.618 --> 00:51:33.358
worked that point trying to
make the web experience sync

00:51:33.358 --> 00:51:34.698
across all of your
installations.

00:51:34.698 --> 00:51:36.738
And, so that you can take your
web experience with you as you

00:51:36.738 --> 00:51:38.918
travel, different computers,
and different installations.

00:51:38.918 --> 00:51:40.198
As you know, we already have
things like bookmarks, and

00:51:40.198 --> 00:51:41.318
themes and preferences.

00:51:41.318 --> 00:51:44.678
And, so we certainly would
envision the Web Store in your

00:51:44.678 --> 00:51:45.978
installed applications to

00:51:45.978 --> 00:51:48.878
fit into that picture.

00:51:48.878 --> 00:51:51.518
AUDIENCE: So, from what I've
seen, your voice recognition

00:51:51.518 --> 00:51:54.078
software is pretty
much awesome.

00:51:54.078 --> 00:51:58.998
But, what's the expected
quality for text to speech.

00:51:58.998 --> 00:52:00.212
Is it going to sound

00:52:00.212 --> 00:52:00.978
really blocky all the time?

00:52:00.978 --> 00:52:03.178
And, what have you guys looking
into to kind of make that

00:52:03.178 --> 00:52:10.138
more fluid so it sounds less
like a robot and more like

00:52:10.138 --> 00:52:11.078
something's talking to me.

00:52:11.078 --> 00:52:14.558
IAN FETTE: So, text to speech
has actually come quite a ways

00:52:14.558 --> 00:52:17.578
since, I think the first time I
used it was Microsoft Agent

00:52:17.578 --> 00:52:19.918
back when I was in
middle school.

00:52:20.318 --> 00:52:21.038
It's come long ways.

00:52:22.418 --> 00:52:26.998
I can't into any details about
what we're specifically

00:52:26.998 --> 00:52:27.378
doing to make it better.

00:52:27.378 --> 00:52:31.200
And, other implementations,
other browsers might have

00:52:31.200 --> 00:52:32.940
different ideas for how they
implement it, be that

00:52:32.940 --> 00:52:34.858
locally in the client,
around the server.

00:52:34.858 --> 00:52:38.978
I think our main focus
is on making the

00:52:38.978 --> 00:52:39.318
interaction possible.

00:52:39.318 --> 00:52:42.240
And, once we have that base
level, we'll see what needs are

00:52:42.240 --> 00:52:44.620
not met, you know, someone
really wants to specify.

00:52:44.620 --> 00:52:47.920
You know, make this sound like
Governor Schwarzenegger and

00:52:47.920 --> 00:52:49.458
here's some data that
describes his voice.

00:52:49.458 --> 00:52:51.678
You know, we'll try to figure
out how to make that possible.

00:52:51.678 --> 00:52:53.978
But, I think in v1, we're
really just hoping to found the

00:52:53.978 --> 00:52:58.858
basic use cases of how to take
this text and convert it --

00:52:58.858 --> 00:53:01.658
AUDIENCE: So, in the basic use
case then, is it going to sound

00:53:01.658 --> 00:53:03.538
really blocky in the first run?

00:53:03.538 --> 00:53:07.098
IAN FETTE: I don't think it's
going to sound really blocky.

00:53:07.098 --> 00:53:09.700
I mean I don't think it's going
to sound like a 1990s robot.

00:53:09.700 --> 00:53:12.118
It might not as
configurable as you like.

00:53:12.118 --> 00:53:14.978
But, I'm pretty sure
that we'll be able to

00:53:14.978 --> 00:53:15.998
deliver a high quality.

00:53:15.158 --> 00:53:16.598
JEFF CHANG: It will sound
like a 2010 robot.

00:53:16.598 --> 00:53:17.630
IAN FETTE: Yeah.

00:53:17.630 --> 00:53:17.974
AUDIENCE

00:53:17.974 --> 00:53:18.726
AUDIENCE: All right, thanks.

00:53:18.726 --> 00:53:21.440
IAN FETTE: I think we saw
some of that last night.

00:53:22.120 --> 00:53:23.998
Yes, next question.

00:53:23.998 --> 00:53:24.418
AUDIENCE: Hi.

00:53:24.418 --> 00:53:29.918
Regarding web sockets, is there
any kind of support in Android?

00:53:29.918 --> 00:53:31.298
IAN FETTE: Is there any web
socket support in Android?

00:53:33.280 --> 00:53:35.438
So, a lot of the work that
we did for web sockets

00:53:35.438 --> 00:53:38.478
is contributing
upstream in WebKit.

00:53:40.200 --> 00:53:41.200
Android pulls WebKit.

00:53:41.440 --> 00:53:43.340
I don't actually remember what
revision they're pulling

00:53:43.340 --> 00:53:44.300
in [UNINTELLIGIBLE]

00:53:44.300 --> 00:53:46.900
or whether that includes web
socket supports that they've

00:53:46.900 --> 00:53:48.778
done all the necessary
plumbing for that.

00:53:49.758 --> 00:53:52.658
So, the honest answer is
I'm not entirely sure.

00:53:53.618 --> 00:53:58.338
I would love to see them
support it, but I can't

00:53:58.338 --> 00:53:59.278
speak for that team.

00:53:59.278 --> 00:53:59.582
I'm sorry.

00:53:59.734 --> 00:54:02.498
Doug?

00:54:02.498 --> 00:54:04.838
DOUG: Hey, so I just wanted
to -- there were a lot of

00:54:04.838 --> 00:54:06.798
questions -- you did some stuff
on audio and there were a lot

00:54:06.798 --> 00:54:06.858
of questions about audio.

00:54:07.378 --> 00:54:10.378
I just want to mention that
W3C has a new sort of

00:54:10.378 --> 00:54:11.478
community audio group.

00:54:11.478 --> 00:54:14.340
So, we're collecting used case
in requirements for everything

00:54:14.340 --> 00:54:18.380
from audio synthesis, audio
reading and writing the audio

00:54:18.380 --> 00:54:23.078
stream to text the speech,
to -- the whole range.

00:54:24.098 --> 00:54:27.898
It's a community thing, so
everybody wants to get involved

00:54:27.898 --> 00:54:29.718
in discussions about that.

00:54:29.718 --> 00:54:31.478
Sorry to abuse the mic.

00:54:31.478 --> 00:54:31.538
IAN FETTE: Oh, it's fine.

00:54:31.538 --> 00:54:33.098
And, I should actually say
something really quick.

00:54:33.098 --> 00:54:37.238
You know, in terms of standards
development, there's a lot

00:54:37.238 --> 00:54:38.860
going on, there's a
lot of standards.

00:54:38.860 --> 00:54:41.400
And, we don't always know
what you want, or whether

00:54:41.400 --> 00:54:44.178
these standards actually
match what you want.

00:54:44.178 --> 00:54:47.478
So, I encourage all of you
to actually get involved.

00:54:47.478 --> 00:54:47.958
Go to whatwg.org.
1263
00:54:49,038 --&gt; 00:54:49,018
Go to w3.org.

00:54:51.478 --> 00:54:53.078
Find these mailing lists,
they're easy to find.

00:54:53.078 --> 00:54:55.498
There's Public Web Ask
at w3.org, there's

00:54:55.498 --> 00:54:56.298
What WG at whatwg.org.

00:54:58.100 --> 00:54:59.118
Get involve, follow them.

00:55:00.078 --> 00:55:02.908
If there is an API that you
actually care about, or whether

00:55:02.908 --> 00:55:05.080
it's address a use case you
care about, make sure that we

00:55:05.080 --> 00:55:08.360
hear your feedback, make sure
we know whether this API

00:55:08.360 --> 00:55:09.600
actually works for you or not.

00:55:09.600 --> 00:55:12.060
Because, if you don't give us
this feedback now, it's so

00:55:12.060 --> 00:55:14.460
much harder to go back
and change it later.

00:55:14.460 --> 00:55:17.178
Which is not to say we can't do
it, but getting that feedback

00:55:17.178 --> 00:55:18.100
now is super valuable.

00:55:18.800 --> 00:55:21.380
So, please do get involved
in things like the W3C.

00:55:21.380 --> 00:55:26.660
DOUG: I think if you Google
for W3C audio incubator,

00:55:26.660 --> 00:55:31.198
that will find you.
1279
00:55:31,198 --&gt; 00:55:31,038
IAN FETTE: Thanks Doug.

00:55:31.038 --> 00:55:32.478
I just heard Google.

00:55:32.478 --> 00:55:35.458
Next.

00:55:35.458 --> 00:55:38.780
AUDIENCE: Speaking of APIs if
you want, how would you go

00:55:38.780 --> 00:55:43.118
about -- something I really
want is to have access within

00:55:43.118 --> 00:55:46.878
the browser to the certificate
store, to encryption and

00:55:46.878 --> 00:55:47.780
decryption and signing.

00:55:47.780 --> 00:55:50.638
The stuff that every browser
does for SSL, but I want to

00:55:50.638 --> 00:55:52.438
give it to my application.

00:55:52.438 --> 00:55:56.418
And, where would I even start
the plant the seed for that.

00:55:56.418 --> 00:56:00.118
IAN FETTE: So, where you start
is by going to -- assuming

00:56:00.118 --> 00:56:00.518
that there is no

00:56:00.518 --> 00:56:02.878
spec that already handles it or
even if there it is, go to

00:56:02.878 --> 00:56:06.138
bugs.chromium.org and file a
feature request and say this is

00:56:06.138 --> 00:56:08.378
the kind of application
that I want to build.

00:56:08.378 --> 00:56:11.818
This is the kind of use
case I want to support.

00:56:11.818 --> 00:56:13.238
How are you going
to do it for me.

00:56:13.238 --> 00:56:15.818
And, believe it or not, even
though we do have tens of

00:56:15.818 --> 00:56:18.098
thousands of blogs open on that
site, we do read them and

00:56:18.098 --> 00:56:20.658
we will actually take that.

00:56:20.658 --> 00:56:22.598
Because, that's how we know
that people this capability.

00:56:23.238 --> 00:56:25.600
And, that's how we know
the need to look at it.

00:56:25.600 --> 00:56:27.540
It turns out that encryption
is something we're actually
1302
00:56:27,54 --&gt; 00:56:27,42
looking at already.

00:56:28.438 --> 00:56:31.178
If you look at a lot of banks
in East Asia, particularly

00:56:31.178 --> 00:56:34.238
China and South Korea, all of
them are using active x

00:56:34.238 --> 00:56:37.018
controls to do signatures
on transactions.

00:56:37.018 --> 00:56:37.878
AUDIENCE: Us too.

00:56:37.878 --> 00:56:39.160
IAN FETTE: So, it's a very
legitimate use case.

00:56:39.160 --> 00:56:41.760
There are a lot of
existing uses of that.

00:56:41.760 --> 00:56:43.860
We nee to figure out a
way to support that

00:56:43.860 --> 00:56:44.278
with web standards.

00:56:45.258 --> 00:56:47.638
So, it's something that
I'm very keen to do.

00:56:47.638 --> 00:56:53.280
Unfortunately, I don't have
a date for you on that.

00:56:53.280 --> 00:56:53.684
AUDIENCE: OK.

00:56:53.684 --> 00:56:53.820
Thanks.

00:56:53.820 --> 00:56:56.718
AUDIENCE: Is Google thinking
about standardizing like parts

00:56:56.718 --> 00:57:00.538
of the Web Store experience,
like app launching, you

00:57:00.538 --> 00:57:04.318
know, the app cache or
saving you web apps?

00:57:04.678 --> 00:57:07.338
IAN FETTE: So, I think we want
to figure out what makes sense

00:57:07.338 --> 00:57:09.958
to standardized, and
standardized that.

00:57:09.958 --> 00:57:12.178
One of the examples is like
the declared or permissions.

00:57:12.178 --> 00:57:14.758
We want to figure out how
to standarized that.

00:57:14.758 --> 00:57:17.098
I don't think we'll
standardize the entire thing.

00:57:17.098 --> 00:57:18.920
I mean some of it is
from proprietary.

00:57:18.920 --> 00:57:21.780
But, the parts that makes
sense with our cross browser.

00:57:21.780 --> 00:57:23.260
Yes, obviously we're opened
to standardizing that.

00:57:23.260 --> 00:57:26.898
Yes?

00:57:26.898 --> 00:57:30.358
AUDIENCE: For Chrome extensions
it's easy to do cross

00:57:30.358 --> 00:57:32.398
domain requests.

00:57:32.398 --> 00:57:35.498
I'm just wondering if there's a
way that Google's looking at

00:57:35.498 --> 00:57:37.958
making that kind of like a
permission that could be added,

00:57:37.958 --> 00:57:41.538
so that somebody can do that in
non-extensions, rather than

00:57:41.538 --> 00:57:43.658
using like JSONP or something?

00:57:43.658 --> 00:57:48.598
IAN FETTE: So, you can use
things like cores and UMP to

00:57:48.598 --> 00:57:55.558
specify what -- Geez, I'm
blanking on the actual API.

00:57:55.558 --> 00:57:56.878
It should be possible.

00:57:57.878 --> 00:58:00.058
You're not ever going to be
able for a web page, you

00:58:00.058 --> 00:58:02.218
know, randomly script
another web page.

00:58:02.218 --> 00:58:07.878
But, if that other web page ops
in, it is possible to do that.

00:58:07.878 --> 00:58:13.238
I believe there's cross origin
XHR already shipping in Chrome.

00:58:16.738 --> 00:58:20.178
Come up to me after,
and I will answer your

00:58:20.178 --> 00:58:20.278
question more fully.

00:58:20.278 --> 00:58:21.778
I apologize.

00:58:21.778 --> 00:58:22.638
You caught me on top
of my head here.

00:58:22.638 --> 00:58:23.278
AUDIENCE: No problem.

00:58:23.278 --> 00:58:23.778
Thanks.

00:58:24.758 --> 00:58:26.198
IAN FETTE: So, I see that
my clock in the back is

00:58:26.198 --> 00:58:27.358
actually flashing red.

00:58:27.358 --> 00:58:29.438
So, I think that means
I'm out of time.

00:58:29.438 --> 00:58:31.198
Thank you all so
much for coming.

00:58:31.198 --> 00:58:33.298
I really appreciate it Jeff and
I will hang out for a few

00:58:33.298 --> 00:58:38.298
minutes if you have
more questions.

