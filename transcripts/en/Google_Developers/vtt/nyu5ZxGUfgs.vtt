WEBVTT
Kind: captions
Language: en

00:00:13.570 --> 00:00:16.730
&gt;&gt;Zach Maier: Alright. Hi, everybody. Welcome
to this session. I can't believe it's standing

00:00:16.730 --> 00:00:23.730
room only. This is pretty exciting [laughs]
I wasn't expecting that. So my name is Zach

00:00:25.000 --> 00:00:28.500
Maier and I'm the product manager for our
API Infrastructure team. Joining me on stage

00:00:28.500 --> 00:00:31.019
later will be Mark Stahl, the tech lead for
the API Infrastructure team, and Yaniv Inbar

00:00:31.019 --> 00:00:35.559
and Joey Schorr, two of the engineers on the
API Infrastructure team. So, just like every

00:00:35.559 --> 00:00:41.730
other session we've had so far during IO,
you can follow along with live notes and leave

00:00:41.730 --> 00:00:45.960
comments and questions for the end at bit.ly/apiwave
and if for some reason you really, really

00:00:45.960 --> 00:00:52.120
want to live tweet what I'm saying right now,
you can do it with the #googleapi8 so people

00:00:52.120 --> 00:00:56.370
can follow along. Alright, so this session
is a little bit different from the other session

00:00:56.370 --> 00:01:01.629
we have at Google IO. It's kind of a sneak
peak at how Google's been building APIs in

00:01:01.629 --> 00:01:06.020
the past and what we've noticed and how we're
going to build APIs in the future so you're

00:01:06.020 --> 00:01:10.000
going to get to see like the foundation of
our APIs for the past five years and then

00:01:10.000 --> 00:01:14.030
some upcoming technology that we're really,
really excited about. So, what we're going

00:01:14.030 --> 00:01:18.909
to talk about - this is a 200 level session
so we're talking about a few advanced technologies

00:01:18.909 --> 00:01:23.450
and some terms that not everybody might know
like off the top of their head so I'm going

00:01:23.450 --> 00:01:28.509
to give you a quick refresher as to Google's
API 101, the underlying technology that all

00:01:28.509 --> 00:01:32.820
Google APIs are built on. We'll then go into
 - Mark will come up and talk about how we're

00:01:32.820 --> 00:01:36.829
making future APIs awesome, things we've noticed
in the past, and how we're going to be fixing

00:01:36.829 --> 00:01:40.530
those. Some things that have already been
fixed and some things will be fixed in the

00:01:40.530 --> 00:01:46.030
future so you can be on the lookout there
for some power features that you can use as

00:01:46.030 --> 00:01:49.899
your programming Google APIs, and then what
you're really probably all here waiting to

00:01:49.899 --> 00:01:54.649
see, Joey's going to come up and show a really
awesome demo of the internal tools we use

00:01:54.649 --> 00:01:57.360
to build our own APIs. Kind of a behind the
scenes. Nobody has ever seen this before outside

00:01:57.360 --> 00:02:03.420
of Google so it's really exciting stuff and
then of course, questions and comments. If

00:02:03.420 --> 00:02:09.429
you have any questions or comments, again,
bit.ly/apiwave. Alright, so Google's API 101.

00:02:09.429 --> 00:02:14.310
What are the underlying technologies that
all Google APIs work on? Well, first off,

00:02:14.310 --> 00:02:19.570
since we're a web based company all Google
APIs use REST. REST is short for Representational

00:02:19.570 --> 00:02:26.239
State Transfer and very simply speaking, its
clients and servers exchanging resource representation

00:02:26.239 --> 00:02:32.040
somehow. It's good for cached and layered
systems which is basically the Internet, right?

00:02:32.040 --> 00:02:37.530
So cached and layered systems; Representational
State Transfer. In HTTP, every time you make

00:02:37.530 --> 00:02:40.049
a get request to a resource, you are using
a REST based system so in this case

00:02:40.049 --> 00:02:45.570
if you're using the G data YouTube API, you
get the resource and it will return like a

00:02:45.570 --> 00:02:50.530
list of videos or something like that. The
resource representations that we use in Google

00:02:50.530 --> 00:02:57.419
APIs - right now we use AtomPub which means
they're modeled as feeds of entries and more

00:02:57.419 --> 00:03:02.549
generally it's useful to think of these as
collections of resources and you'll see why

00:03:02.549 --> 00:03:09.549
later. So think of - anytime you get a representation,
it's a collection of a bunch of different

00:03:11.630 --> 00:03:16.609
resources and just to make sure we're all
on the same page with what collection of resource

00:03:16.609 --> 00:03:23.609
means; this is sitting on a server right now.
I have a collection and I have a bunch of

00:03:26.510 --> 00:03:33.510
resources in there. Now, depending on which
API I'm using, this collection can be a collection

00:04:04.769 --> 00:04:10.919
of contacts if it's a contacts API, a collection
of videos if it's a YouTube API, a collection

00:04:10.919 --> 00:04:16.970
of documents, or anything else living in a
cloud if it's like the documents list API.

00:04:16.970 --> 00:04:23.970
Each resource is a document or a contact or
a video in that case. So, what can I do with

00:04:29.199 --> 00:04:36.199
this information that site on the server?
Well, first off, I can get that information

00:04:39.100 --> 00:04:46.100
and bring it to my local client, HTTP Verb
Get, everybody should know what that means.

00:04:49.290 --> 00:04:56.290
So once this is on my client, this resource
is on my client, I can of course modify the

00:04:59.930 --> 00:05:06.930
resource. Once I modify the resource, I can
use PUT Verb and put that resource right back

00:05:11.740 --> 00:05:18.740
into the collection, essentially updating
that resource with any of the changes I made

00:05:20.620 --> 00:05:27.620
on the client. So, what else can I do to these
resources? Of course, I can delete a resource

00:05:30.010 --> 00:05:37.010
which if I delete a resource, guess what happens?
It gets deleted. I can also post a new resource

00:05:43.780 --> 00:05:50.780
into the collection. Now this is inherently
different then every other operation we have

00:05:51.290 --> 00:05:58.290
up here so far. This post actually operates
on the collection, not the resource because

00:05:58.990 --> 00:06:05.160
since there's no resource living on the server
so far, you have to post into the collection

00:06:05.160 --> 00:06:12.160
and then once you post into the collection,
new stuff appears in the collection. One other

00:06:13.139 --> 00:06:20.139
thing you can do on the collection level is
you can also get everything in a collection

00:06:20.670 --> 00:06:27.670
which in essence lists all of the different
resources so you can pull all of the resources

00:06:32.290 --> 00:06:39.290
by calling a GET on the collection. Alright,
so that's a basic REST recollections resources;

00:06:51.060 --> 00:06:57.330
the underlying fundamental technologies of
how all our APIs work up to date. So, a quick

00:06:57.330 --> 00:07:04.190
question for everybody. Who's seen this logo
before? Anybody? Anybody? A few people have,

00:07:04.190 --> 00:07:10.840
which props to you guys, because you've been
around for a long time then because this is

00:07:10.840 --> 00:07:17.840
the very, very first Google Data APIs logo
and it's kind of obvious what it looks like,

00:07:19.880 --> 00:07:26.880
right? It looks like an atom and as time has
progressed, we've dropped the little electron

00:07:30.169 --> 00:07:37.169
arrows flying around and we have the Google
data cube that we use to represent APIs nowadays.

00:07:41.630 --> 00:07:48.630
So what I'm trying to get at with this awesome
history of the logo over the past five years

00:07:53.419 --> 00:07:56.480
is that right now Google data is basically
equivalent to Atom. You must understand Atom

00:07:56.480 --> 00:08:02.810
to use the APIs. This piece of core of our
APIs is built around the Atom Syndication

00:08:02.810 --> 00:08:09.810
Format and the Atom Publishing Protocol and
then over time we've extended those core features

00:08:11.250 --> 00:08:18.250
with features like query, batch, and concurrency.
So far, like this approach that we've taken,

00:08:19.020 --> 00:08:26.020
this Atom based approach, has been very, very
successful. We have more then 25 APIs at Google,

00:08:29.480 --> 00:08:36.480
as I'm sure you're all well aware, and across
all those APIs we get about 2

00:08:39.039 --> 00:08:46.039
billion hits per day which is a pretty impressive
traffic number. If you divided that out, you

00:08:48.490 --> 00:08:55.490
can figure out what QPS that is. So, a lot
of you have used most of these APIs before;

00:08:59.170 --> 00:09:05.760
Blogger, YouTube, calendar, spreadsheets 
- all these APIs run on the foundation so

00:09:05.760 --> 00:09:11.650
we have this awesome foundation built up but
we

00:09:11.650 --> 00:09:18.650
want to keep it going, right? We don't want
to stop with what we have. We want to make

00:09:24.070 --> 00:09:31.070
it better, we want to get more APIs out there,
and we want these APIs that we launch to be

00:09:33.440 --> 00:09:40.440
higher quality. So, inside of Google, and
this is the look behind the scenes that I've

00:09:41.750 --> 00:09:48.750
guaranteed everybody. We are moving to a brand
new API Infrastructure and the cool thing

00:09:53.700 --> 00:10:00.700
about this is we've done it transparently
so if you're using any of these new APIs that

00:10:02.640 --> 00:10:09.640
have been new in the past few weeks; the Google
Moderator API, the Google Buzz API, or the

00:10:13.730 --> 00:10:20.730
Google Latitude API; you are using this brand
new infrastructure. Alright, so I've given

00:10:22.740 --> 00:10:28.149
you the foundation, laid the foundation here,
told you that we're moving to a brand new

00:10:28.149 --> 00:10:35.149
infrastructure but I'm just a product manager
so I can talk about all these cool things

00:10:42.020 --> 00:10:49.020
but to actually tell you how it's really done
here is the tech lead, Mark Stahl. [applause]

00:10:50.460 --> 00:10:57.460
&gt;&gt;Mark Stahl: Hello. My name is Mark Stahl
and I'm the tech lead for Google APIs. I have

00:11:02.480 --> 00:11:09.480
been building APIs for Google for about five
years or we've been building infrastructure

00:11:10.800 --> 00:11:17.800
that have allowed teams to build APIs for
about five years. In the part of the talk,

00:11:20.540 --> 00:11:27.540
I'm going to explain a little bit about some
of the things we've learned over those five

00:11:33.920 --> 00:11:40.920
years; we've been trying to listen; and some
of the rough edges we've noticed and the ways

00:11:46.990 --> 00:11:53.990
we're trying to improve APIs going forward
and the new features and stuff that we're

00:12:01.760 --> 00:12:08.760
trying to build into our new stack. So, one
of the - I'm going to talk about some of the

00:12:15.350 --> 00:12:22.350
rough edges in a couple of areas. First is
just that we're dealing with resource representations

00:12:26.040 --> 00:12:33.040
on the wire and so the formats on the wire
are very important. This is what you guys

00:12:42.630 --> 00:12:49.630
are actually - these are the resources you're
manipulating. I'll deal a little bit with

00:12:51.959 --> 00:12:58.620
REST itself and some of the difficulties that
it provides when trying to do certain types

00:12:58.620 --> 00:13:01.380
of operations and we also maintain a set of
libraries that we try to make available to

00:13:01.380 --> 00:13:08.380
help you use our APIs and I'll discuss some
of the difficulties we've had and the changes,

00:13:11.870 --> 00:13:15.000
again, that we're making going forward to
make these things better. So, first, in the

00:13:15.000 --> 00:13:21.890
output formats, one of the things about REST
you'll know is that it's based on transferring

00:13:21.890 --> 00:13:28.890
a resource or as the technical way, it's a
representation of a resource; that is some

00:13:29.790 --> 00:13:34.230
wire document that says this is the state
of everything in that resource. Now, in order

00:13:34.230 --> 00:13:39.770
to modify, you saw that you have to transfer
that resource representation twice. You have

00:13:39.770 --> 00:13:42.080
to pull down a full copy of the state of the
resource, you modify what you like, and you

00:13:42.080 --> 00:13:49.080
put back a full copy; and this means that
just to do as much as changing a single flag

00:13:51.750 --> 00:13:58.750
requires you actually changing, transferring
the whole resource representation twice, and

00:14:00.190 --> 00:14:07.190
a resource can be pretty much anything. It
cane be, you know, five lines of configuration

00:14:07.660 --> 00:14:14.660
or it can be 400 pieces of meta data and sometimes
that can get a little bit verbose. Also, we

00:14:17.580 --> 00:14:24.580
built on AtomPub right from the beginning
which means we're using Atom Syndication Format

00:14:24.620 --> 00:14:31.620
and XML as the core document and we also 
- maybe some of you have realized that - 

00:14:33.180 --> 00:14:39.360
resources on the wire can be a little bit
verbose. We get this problem a lot of times.

00:14:39.360 --> 00:14:44.810
So, we've been looking at this problem for
a while and we have been looking for RESTful

00:14:44.810 --> 00:14:51.810
ways to solve this problem and we have introduced
now, in the last couple of months, you may

00:14:57.170 --> 00:15:04.170
have seen come out, we allow for the possibility
of partial operations. Realistically speaking,

00:15:09.370 --> 00:15:16.370
you are only operating on part of a resource
90% of the time or the only part that you

00:15:19.640 --> 00:15:26.640
want so partial operations come in two basic
flavors. There is the partial response which

00:15:30.040 --> 00:15:37.040
is when you return this resource to me, only
give me the part of the resource that I really

00:15:50.829 --> 00:15:57.829
want, and I'll just give you a quick example.
Here's an example from YouTube and I'm just

00:16:04.620 --> 00:16:11.620
going to click through and show you. This
is the full XML resource. This is a search

00:16:16.290 --> 00:16:23.290
of YouTube for the number one Google IO video
and this is a lot of feed metadata coming

00:16:38.170 --> 00:16:45.170
up here at the top. You can see the actual
entry, this is the beginning of the actual

00:16:49.680 --> 00:16:56.680
result. Lots and lots of metadata, lots and
lots of metadata; somewhere in here is the

00:16:56.810 --> 00:17:03.810
content that I want. Can anyone see it? I
think it's up here. No, I can't find it. I

00:17:13.240 --> 00:17:20.240
know it's in here because this is actually
live and you can see that this is an awful

00:17:28.789 --> 00:17:35.789
lot of data to transfer for one resource so
assuming that what you want to do is only

00:17:42.999 --> 00:17:49.999
say - you say display just the title and of
course once you have the content field, you

00:17:50.460 --> 00:17:57.460
only want to actually display the content
itself which is a link at the moment to Flash.

00:18:00.999 --> 00:18:07.999
All you really want is these two fields. So,
partial GET, every operation now supports

00:18:12.559 --> 00:18:19.559
this concept of a field's parameter and from
the field's parameter, you specify a mask

00:18:23.419 --> 00:18:30.419
and a mask just says give me what exactly
matches this mask and just to make life a

00:18:37.100 --> 00:18:44.100
little bit easier, somebody show me a live
result. Resolving proxy, that's not good,

00:18:56.919 --> 00:19:03.919
is it? Ah, there it is! So this is actually
a live result and you'll see this is - if

00:19:11.700 --> 00:19:18.700
you're say working in a mobile environment
and you're trying to get just a few things,

00:19:25.179 --> 00:19:32.179
this is a big deal. This is something that
people have really been wanting for a long

00:19:32.389 --> 00:19:39.389
time. It's still RESTful and it works just
the way you need it to and you'll see here

00:19:46.619 --> 00:19:53.619
this is actually a full document in terms
of its structure. It actually has a feed tag,

00:19:57.299 --> 00:20:04.299
it has an entry tag, and it has a content
tag so it still parses the same way except

00:20:04.809 --> 00:20:11.809
it's only a subset of what Atom Syndication
Format requires. So, going back - we also

00:20:13.869 --> 00:20:20.869
have defined another part of partial which
we call the partial update. In this case,

00:20:25.059 --> 00:20:32.059
you use the exact same masking syntax and
you say I'm going to send back a same partial

00:20:34.979 --> 00:20:41.519
representation and only update some fraction
of that resource. Now I'm not going to go

00:20:41.519 --> 00:20:48.519
into this in detail. This was actually launched
and this was discussed actually at last Google

00:20:49.830 --> 00:20:56.830
IO and we launched it like about three months
ago so it's available now on about four APIs

00:21:00.070 --> 00:21:07.070
and you can actually go and read all the details.
If you are working in a bandwidth constrained

00:21:18.409 --> 00:21:25.409
environment or you really need to save space
on a device, this is the type of feature you're

00:21:30.820 --> 00:21:37.820
going to want to exploit so this is something
that's currently available and we'll be rolling

00:21:41.830 --> 00:21:48.830
out to all APIs, databased APIs, in the future.
Another issue that some of you may have dealt

00:21:58.379 --> 00:22:05.379
with; how many people are programming in JavaScript?
Anybody? Not me actually. I'm programming

00:22:09.159 --> 00:22:16.159
in Java but perhaps you've [laughs] you're
trying to use XML results on JavaScript so

00:22:20.070 --> 00:22:27.070
we realized that we need to be able to offer
alternate formats. XML works great in languages

00:22:36.429 --> 00:22:43.429
that have a lot of XML support but JavaScript
is actually another format that a lot of people

00:22:50.970 --> 00:22:57.970
want and in fact formats need to be flexible.
Resources are - it doesn't necessarily mean

00:23:01.759 --> 00:23:08.759
AtomPub. A resource can actually be represented
any number of ways and so we're supporting

00:23:14.359 --> 00:23:21.359
multiple formats, and by multiple formats
I mean these are native to the architecture.

00:23:21.840 --> 00:23:28.840
They are both readable and writeable. Now,
this required us to actually deal with some

00:23:30.659 --> 00:23:37.659
architectural issues. When we stated building
APIs five years ago, AtomPub was all the hotness

00:23:41.029 --> 00:23:48.029
and we built our services actually exported
directly into the Atom Syndication Format

00:23:49.710 --> 00:23:56.710
so all our services were tired to Atom. When
JSON developers came to us and said, "We want

00:24:05.700 --> 00:24:12.700
JSON." Well, we built JSON; however, has anybody
here worked with our old format JSON? Yeah,

00:24:20.159 --> 00:24:27.159
there's a reason and the reason is the JSON
is actually XML coded as JSON and it's not

00:24:37.389 --> 00:24:44.389
the most pretty thing. JSON developers, of
course, is not a natural structure to have

00:24:48.889 --> 00:24:55.539
to put namespaces in your JSON objects. It's
not a pretty sight. Another feature of this

00:24:55.539 --> 00:25:02.539
particular hack that we implemented is that
it's only a one way. This is a read only API

00:25:03.739 --> 00:25:10.739
so if you used the JavaScript client libraries,
you actually could write back but what you

00:25:13.609 --> 00:25:20.609
didn't see was under the hood we transcoded
it back to XML and then sent it back to the

00:25:21.200 --> 00:25:28.200
server, and that was because our servers were
built around the concept of reading and writing

00:25:33.210 --> 00:25:40.210
and parsing Atom's Publishing Protocol and
Atom Syndication Format. So, what we've done

00:25:42.379 --> 00:25:49.379
is we've re-architected our how we build APIs
from the ground up and we've built and introduced

00:25:58.869 --> 00:26:05.869
a generic data concept which you'll see here.
We're using, of course, Google's favorite

00:26:08.379 --> 00:26:15.379
structure which is Protocol Buffers, and you'll
see a little bit later exactly how we do this

00:26:22.149 --> 00:26:29.149
but what we've also introduced then is just
what everybody else is familiar with is templating

00:26:36.599 --> 00:26:43.599
languages but these aren't just simple templating
languages, these are bidirectional templating

00:26:47.269 --> 00:26:54.269
languages. So by writing a template, you actually
get both a read and a write format so we've

00:27:13.659 --> 00:27:20.659
solved some difficult problems in order to
make it possible for people to really build

00:27:29.309 --> 00:27:36.309
APIs and new languages so just to give you
a quick, brief idea of how this really impacts

00:27:44.710 --> 00:27:51.710
APIs, this is our new Buzz API. You may have
all seen this here. So, this is the Atom that

00:27:58.039 --> 00:28:05.039
comes out of Buzz and it's an awful lot of
Atom here. Buzz is built on the activity streams

00:28:11.369 --> 00:28:18.369
specification which means they have an awful
lot of metadata but you can see there's an

00:28:22.590 --> 00:28:29.590
awful lot of metadata in order to get one
piece of content here and somewhere in here

00:28:36.759 --> 00:28:41.299
 - here he is, there it is. This was my content,
I made a Buzz. I'm excited to be speaking

00:28:41.299 --> 00:28:48.299
at Google IO. Now, if you look at the same
thing, all you have to do now is specify all

00:28:58.509 --> 00:29:05.509
JSON and what you're going to get back is
this somewhat ugly blob but it actually gets

00:29:17.499 --> 00:29:24.499
near - if I can find the right key combination
 - ah. So, this is a much neater structure.

00:29:40.929 --> 00:29:47.249
This is actually native JSON, it's not XMLized
JSON and you'll see somewhere in here, a lot

00:29:47.249 --> 00:29:54.249
easier to read, is my actual content labeled
as actual content so APIs going forward will

00:29:58.219 --> 00:30:05.219
now support their own native JSON read write
format. We are not longer constrained by the

00:30:06.469 --> 00:30:13.469
syntax requirements of Atom, we can actually
build a format that's natural for you to work

00:30:14.960 --> 00:30:20.639
with, and one of the other nice features of
this particular change is that the way we

00:30:20.639 --> 00:30:26.679
re-architected our system, this templating
model, doesn't restrict us to just these formats.

00:30:26.679 --> 00:30:33.679
We can actually start introducing other formats
just as easily and in fact we hope to introduce

00:30:36.210 --> 00:30:43.210
new formats in the future. Whatever the new
hotness is, we're ready to be able to introduce

00:30:45.869 --> 00:30:52.869
it into our systems so our APIs will grow
as the Web changes and our APIs will be able

00:30:58.299 --> 00:31:05.299
to adapt to how they actually change. So,
I'd like to switch to our second topic, things

00:31:05.749 --> 00:31:11.609
we've noticed in APIs. REST is very much a
popular approach, an architectural style and

00:31:11.609 --> 00:31:18.609
there's a good reason REST is a popular architectural
style. It's built - REST is based on transferring

00:31:19.609 --> 00:31:26.609
these resource documents. It's exactly what
all your HTTPL and all your web browsing does,

00:31:30.919 --> 00:31:37.919
transfer documents. It's really great for
cacheability. It's really simple for people

00:31:45.379 --> 00:31:52.379
to use these type of APIs but the way it works
actually means it can be awkward for certain

00:31:54.989 --> 00:32:01.849
type of operations so I built up a small example
here. This example starts with the idea of

00:32:01.849 --> 00:32:08.849
a Picasa web. Say you want to rotate a photo
and we're going to rotate this photo in binary

00:32:12.759 --> 00:32:19.759
and we're going to do this a very traditional
REST. First, transfer your resource representation

00:32:20.070 --> 00:32:27.070
over the wire and get your JPEG. Rotate your
photo and write your photo back. So you see

00:32:32.879 --> 00:32:38.080
here, depending on how big this resource representation
here, I've actually transferred a photo twice

00:32:38.080 --> 00:32:45.080
over the wire to do what's a fairly simple
operation. Now, how would we solve this in

00:32:51.700 --> 00:32:58.700
other ways? Typically you think, "Oh, I should
just be able to send the server a command

00:33:13.059 --> 00:33:18.669
saying rotate this photo." Well, there is
no such command in REST. You can do things

00:33:18.669 --> 00:33:25.669
like oh maybe I expose metadata that says
let's give the photo a rotate metadata. This

00:33:29.080 --> 00:33:36.080
is a certain hack that we've done. This actually
is how Picasa did it because we were constrained

00:33:57.219 --> 00:34:04.219
by REST. Of course now, of course, you have
to transfer this rotate state to set it back.

00:34:16.520 --> 00:34:22.560
There is no way to send an imperative command
and there are certain types of imperative

00:34:22.560 --> 00:34:27.270
commands that are even more common. Say, send
email to all attendees of a conference event

00:34:27.270 --> 00:34:33.990
or reset this machine. This type of imperative
statements are inherently difficult to do

00:34:33.990 --> 00:34:40.990
in REST. You can always hack it. Everything
can be done, everything can be faked but it's

00:34:41.659 --> 00:34:48.659
not a natural approach. A natural approach
would be RPC but to switch to RPC, you're

00:34:49.330 --> 00:34:56.330
giving up on REST and you are now in a world
where you don't have the benefits so what

00:34:57.880 --> 00:35:04.880
we've decided to do at Google is we've decided
that we're going to be introducing a very

00:35:05.060 --> 00:35:09.990
lightweight form of RPC, a RESTful approach,
the idea that resources can have extra options

00:35:09.990 --> 00:35:15.220
on them instead of the basic three or four
verbs that REST gives, we are actually introducing

00:35:15.220 --> 00:35:22.220
a form of RPC we call Custom Verbs and this
says that I can have a resource, can export

00:35:24.530 --> 00:35:31.530
something that says when REST is a difficult
way to approach it, here's a custom verb that

00:35:32.140 --> 00:35:39.140
let's me do that resource exactly what I want.
So, in the Picasa web case, this simplifies

00:35:44.580 --> 00:35:51.580
our world greatly. All I do is I send along
a command saying identify my resource, here's

00:35:52.250 --> 00:35:57.300
the operation I wish to perform on it, here's
the parameters, and away I go. Now you'll

00:35:57.300 --> 00:36:04.210
see that we've really reduced the amount of
information on the wire and we've made it

00:36:04.210 --> 00:36:08.230
possible. Within the construct, we still have
a RESTful API as our base but we've given

00:36:08.230 --> 00:36:15.230
ourselves a way to stop the struggle between
RPC and REST and solve some of the tricky

00:36:15.440 --> 00:36:19.030
problems by allowing more capability to write
APIs when it's appropriate. So, I'll just

00:36:19.030 --> 00:36:24.290
show another example real quickly. You probably
all have dealt with - has everybody used our

00:36:24.290 --> 00:36:31.290
task list API? That's because we don't have
a task list API but if we did this is how

00:36:32.230 --> 00:36:39.230
you would say set a task done. You take a
task, you go to its resource, get it, modify

00:36:42.280 --> 00:36:47.680
the done bit, and then you're done and basically
put it back. A custom verb approach then is

00:36:47.680 --> 00:36:54.680
just to have a method, mark done, and using
the same resource identifier you can now perform

00:36:56.760 --> 00:37:03.760
operations on resources so this is a feature
that we're planning on rolling out on APIs

00:37:04.330 --> 00:37:10.950
as necessary in order to make them more powerful.
Another tension that we've noticed in API

00:37:10.950 --> 00:37:17.450
communities is that not everybody is buying
into the RESTful approach. There are other

00:37:17.450 --> 00:37:24.450
approaches out there. How many people have
dealt with, say open social APIs? If you've

00:37:25.240 --> 00:37:32.240
done with open social, you know that open
social community decided on JSON RPC as the

00:37:34.160 --> 00:37:38.830
standard approach to APIs. However, if you
look at what the open social JSON RPC API

00:37:38.830 --> 00:37:45.290
is, a large portion of those are actually
the same RESTful commands that we operate

00:37:45.290 --> 00:37:47.670
in the RESTful world and so what we've decided
to do is, you know, there's no reason that

00:37:47.670 --> 00:37:52.610
we have to sit here and say, "We're only offering
the REST, we're only offering the JSON RPC."

00:37:52.610 --> 00:37:59.610
We can actually offer these in parallel and
we can let them be good where each one is

00:38:01.710 --> 00:38:07.130
best so APIs going forward, again, here's
your simple RESTful model but there's not

00:38:07.130 --> 00:38:13.310
reason that these all can't be mirrored as
JSON RPC models. When you introduce a custom

00:38:13.310 --> 00:38:19.110
verb, of course, they actually fit into this
framework fairly easily so they work quite

00:38:19.110 --> 00:38:25.040
well. Now, you say why are we offering RPC.
REST, of course, I said benefits really well

00:38:25.040 --> 00:38:29.080
because it's the way the Web works. You benefit
from caching, you benefit from the simplicity.

00:38:29.080 --> 00:38:32.360
JSON RPC, well what's it's benefits? Probably
the number one benefit is going to be the

00:38:32.360 --> 00:38:38.440
batching mechanisms and we'll actually support
batching that spans multiple services. You

00:38:38.440 --> 00:38:43.310
can actually start creating more complex systems
through a common API infrastructure. How many

00:38:43.310 --> 00:38:50.310
think this is going to be a really nice ability
to use what's best at the time you use it?

00:38:53.980 --> 00:39:00.980
So, and finally, I'd like to talk a little
bit more about the third issue that we've

00:39:02.170 --> 00:39:07.910
noticed in building our APIs is our client
library strategy. One of the biggest problems

00:39:07.910 --> 00:39:13.130
we've had in client libraries is keeping them
up to date with all the APIs. Google engineers

00:39:13.130 --> 00:39:18.460
are very innovative. They keep introducing
new APIs and new features and the core problem

00:39:18.460 --> 00:39:23.010
we've had is the way we architect our client
libraries, all of that libraries actually

00:39:23.010 --> 00:39:28.340
have - what do we have? We have classes literally
for every XML element in the output streams

00:39:28.340 --> 00:39:33.120
of all these libraries so anytime a service
makes a single change to their API, we have

00:39:33.120 --> 00:39:39.150
to do another release and what we find is
that some of these libraries get a lot of

00:39:39.150 --> 00:39:45.410
love. Java's gets a lot of love because everybody
in Google, Java is one of our top programming

00:39:45.410 --> 00:39:51.100
languages; dot net - some, some love but some
other languages; Python - well, we're not

00:39:51.100 --> 00:39:58.100
sure how much love - you know, it depends
on how much love we get, how much time we

00:39:58.410 --> 00:40:04.890
have and it becomes very difficult to keep
libraries on the cutting edge so we realized

00:40:04.890 --> 00:40:10.610
that this was an architectural issue. How
we had designed our libraries and how we had

00:40:10.610 --> 00:40:16.310
designed our client library strategy put us
in a bind. You weren't able to get libraries

00:40:16.310 --> 00:40:23.310
that worked with our APIs or they lagged behind
because we had built them in a way that made

00:40:27.310 --> 00:40:34.310
it difficult for us to keep up so we started
to rethink client libraries from the ground

00:40:38.210 --> 00:40:45.210
up, and the very first thing we decided to
do is we're going to introduce the concept,

00:40:45.870 --> 00:40:52.770
we're going to introduce the idea of discovery
into APIs at Google. So, this discovery, what

00:40:52.770 --> 00:40:59.770
we're basically - every API now will support
a discovery document. It's just JSON but it's

00:41:00.710 --> 00:41:05.090
simple to read and you use it to describe
these resources. You can describe the URL's,

00:41:05.090 --> 00:41:10.030
parameters, whatever so now there is a way
for a library to be built that actually leverages

00:41:10.030 --> 00:41:16.790
this information and this is built deep into
the infrastructure of how we build APIs. It

00:41:16.790 --> 00:41:23.790
actually means that these - once you publish
an API at Google, the discovery document is

00:41:25.690 --> 00:41:32.690
always up to date so I'll give you another
quick example. The discovery is just another

00:41:34.410 --> 00:41:41.410
API. Buzz being one of the first APIs built
actually has a discovery document and here's

00:41:45.340 --> 00:41:52.340
a - you'll notice here, this is a URL. This
little number here, V zero point one is just

00:41:57.070 --> 00:42:04.070
to let you know that discovery is an experimental
API. We're not officially releasing it today

00:42:10.140 --> 00:42:17.140
but we're innovating in the open, this is
Google IO and you are welcome to go look at

00:42:22.270 --> 00:42:29.270
this API and see it and give us feedback on
it. So, here I'll show you a quick example.

00:42:30.080 --> 00:42:37.080
This is the Buzz document and yes, it looks
terrible. Now it looks a lot better and you

00:42:46.190 --> 00:42:50.130
can see it's pretty straightforward. From
the top, we have the name of the service,

00:42:50.130 --> 00:42:55.730
it's version. We have a URL and then we start
describing what resources exist in this API.

00:42:55.730 --> 00:43:02.730
Here's a set of photos that exist in the API
and here is a URL template that you can use

00:43:05.520 --> 00:43:09.240
to construct access to those photos. I've
already mentioned RPC and here's the RPC mechanism

00:43:09.240 --> 00:43:16.240
and this is a set of methods that you'll see
here. The insert method is a method for adding

00:43:19.650 --> 00:43:25.090
photos to a system. Now you've got both of
these methods and you can now see how to construct

00:43:25.090 --> 00:43:32.090
a RESTful request and how to construct an
RPC request without ever having - so the library

00:43:33.720 --> 00:43:40.720
is going to be built around this concept.
So based on this concept, we are re-architecting

00:43:47.550 --> 00:43:54.550
our client libraries. I call them generic
client libraries. I hate the name generic

00:43:55.490 --> 00:44:00.160
[laughs] Does anybody have a better name?
Because I hate the name generic but it really

00:44:00.160 --> 00:44:07.160
means is client libraries that are built to
be useable with any API built at Google and

00:44:07.910 --> 00:44:14.910
that's really the concept. Several features
that go into this generic concept - one is

00:44:16.240 --> 00:44:23.240
the libraries themselves will be able to leverage
this discovery so you no longer have to start

00:44:31.360 --> 00:44:38.360
scraping URL's out of documents. You can actually
use the names of resources that are a little

00:44:48.420 --> 00:44:55.420
more intelligent to get things out of it.
Another concept is I told you the data model

00:44:57.630 --> 00:45:04.300
classes that was a big problem. We were modeling
XML but it's actually, there's actually a

00:45:04.300 --> 00:45:11.300
lot of better ways to go about it and so for
JavaScript, you use JSON. For Java, we've

00:45:12.260 --> 00:45:19.260
actually come up with a mechanism to map plain
old Java objects directly to JSON and we'll

00:45:26.740 --> 00:45:33.740
show you that in a few minutes and you can
basically create the Java data model classes

00:45:42.620 --> 00:45:49.620
yourselves in a few minutes. We're also rethinking
how we expose some of the advanced features,

00:46:14.540 --> 00:46:21.540
making them much easier to use and finally
the client libraries have to work on all our

00:46:33.810 --> 00:46:40.810
platforms. It's been a long time since we've
had a Java library for G data that worked

00:46:41.660 --> 00:46:48.660
on Android and that's one of the things we're
gonna have. The thing that I most like, and

00:46:53.160 --> 00:47:00.160
hopefully you'll like, is that once this library
is realized it will work with any API. So,

00:47:08.090 --> 00:47:15.090
I've talked about this as a generic concept.
We've actually been building this. Again,

00:47:20.850 --> 00:47:27.850
we're innovating it in the open and we have
a sample to show you and I'm going to invite

00:47:35.590 --> 00:47:42.590
 - I'm just a tech lead which means I have
to invite one of the software engineers up

00:48:01.440 --> 00:48:08.440
to show actual code so I'm inviting Yaniv
Inbar to come up and show an example of the

00:48:15.890 --> 00:48:18.720
client library [applause]

00:48:18.720 --> 00:48:25.720
&gt;&gt;Yaniv: Thank you, Mark. So as Mark has been
talking about, we're all about innovating

00:48:33.060 --> 00:48:38.580
in the open and today we've made available
a Java client library for

00:48:38.580 --> 00:48:41.810
all Google APIs. It's technology we're still
working on, we're experimenting with, but

00:48:41.810 --> 00:48:48.810
we wanted to give it out to developers like
you so you can try it out

00:48:53.630 --> 00:49:00.630
and give us feedback. As Mark said, I'm going
to be demoing an Android application for the

00:49:05.770 --> 00:49:12.540
recently announced Buzz API so let's take
a look at how it works.

00:49:12.540 --> 00:49:19.540
So, the first thing I did is when I set up
my clips project here, is I checked out the

00:49:20.930 --> 00:49:27.170
project from the open source repository where
this sample is hosted.

00:49:27.170 --> 00:49:34.170
The second thing I did is that I started the
emulator and you see this is a G1 device from

00:49:34.380 --> 00:49:41.380
2008 and the point I'm making here is that
if you're a developer

00:49:41.490 --> 00:49:48.490
that's making an Android application, you
want to reach the maximum number of users

00:49:49.160 --> 00:49:56.160
and the best way to do that is to target the
1.5 SDK which represents

00:49:58.970 --> 00:50:04.740
virtually all of the Android market. If you
are only targeting, say a device like the

00:50:04.740 --> 00:50:09.310
Evo that many of you got today, you are only
going to get say less then

00:50:09.310 --> 00:50:16.310
a third of the Android market so you have
to make that trade off between a better SDK

00:50:22.500 --> 00:50:29.500
and greater reach for your application and
in this application the

00:50:32.090 --> 00:50:35.660
first thing the application does is using
intent, it starts the web browser and it shows

00:50:35.660 --> 00:50:40.890
an OAuth authentication page. The end user
then looks at the set of

00:50:40.890 --> 00:50:42.550
permissions that they are granting the application
to do, they have to approve that and then

00:50:42.550 --> 00:50:43.610
they have to grant our application access
to the Buzz API. When

00:50:43.610 --> 00:50:44.440
they click "Grant Access", what happens is
Android defines, our application is defining

00:50:44.440 --> 00:50:47.880
custom URI scheme called Buzz demo that this
demo defined and if the

00:50:47.880 --> 00:50:52.890
wireless is working we'll redirect back to
the application. It looks like we're having

00:50:52.890 --> 00:50:56.110
some technical difficulties here so I'll retry
that. Alright, let me

00:50:56.110 --> 00:51:01.240
just show you the code. So, let me show you
a preview how JSON data is modeled into our

00:51:01.240 --> 00:51:02.670
plain old Java objects. The key here - [talking
in background] The

00:51:02.670 --> 00:51:09.190
key here is that there's a content key and
that's mapped to a JSON train. The JSON data

00:51:09.190 --> 00:51:15.880
model and the Java data class, there's a field
called content and

00:51:15.880 --> 00:51:22.880
we're using an at key annotation to tell it,
"Okay, take that field and map it into the

00:51:28.360 --> 00:51:35.070
JSON key." The type here is trade, previous
trade forward. If you're

00:51:35.070 --> 00:51:42.070
used to JPA on web applications, this is a
very familiar concept where they are using

00:51:46.660 --> 00:51:50.870
that for persistence. So let's take a look
at the Buzz activity class.

00:51:50.870 --> 00:51:54.590
I hope you can see that. Now, the Buzz activity
is just a container for the Buzz object. It

00:51:54.590 --> 00:51:57.000
has an ID field which is represented by a
Java field and it has

00:51:57.000 --> 00:52:04.000
a Buzz object field called object. Again,
I'm mapping from Java fields to JSON keys

00:52:04.750 --> 00:52:10.180
and you'll notice that a Buzz activity actually
has a lot more fields as

00:52:10.180 --> 00:52:13.890
Mark showed you earlier but we're only starting
the ones we care about. This is critical on

00:52:13.890 --> 00:52:18.610
mobile devices where you really want to keep
a low memory profile

00:52:18.610 --> 00:52:23.220
for your application. So, let's take a look
at what discovery looks like in a concrete

00:52:23.220 --> 00:52:28.700
Java application. Here's an example of the
post method. Say I want to

00:52:28.700 --> 00:52:35.700
knit a canoe Buzz post. I defined a method
called activity set insert and I give it a

00:52:38.510 --> 00:52:40.260
set of parameters. In this case, the user
id is at me and that's really

00:52:40.260 --> 00:52:43.290
all the library needs to know in order to
make an HTTP request. You execute the request

00:52:43.290 --> 00:52:46.920
using the Buzz activity data class to serialize
into JSON and we provide a serialization for

00:52:46.920 --> 00:52:50.340
XML and in the future we'll provide it for
other formats. Here's another method, the

00:52:50.340 --> 00:52:52.940
delete method. Straightforward, they all look
the same. You define the name of the method

00:52:52.940 --> 00:52:59.930
I'm running, activities dot delete, and a
set of parameters so let's look at the Buzz

00:52:59.930 --> 00:53:05.620
activity feed. Again, this is just a container
for Buzz activities and I'm using a list of

00:53:05.620 --> 00:53:11.210
Buzz activity as the Java type of the field
and at the at connotation, I'm overriding

00:53:11.210 --> 00:53:18.210
the field name and I'm using items as a JSON
key. There's also a list method here. I won't

00:53:18.710 --> 00:53:25.710
go into any details, any more details and
finally I'll show you the Buzz Parameters

00:53:25.800 --> 00:53:31.500
class. The user id, the scope, and the post
id - those were used in the discovery to construct

00:53:31.500 --> 00:53:35.070
the URL path. The alt and prettyprint are
query parameters so you might be saying to

00:53:35.070 --> 00:53:38.960
yourself, "Wait a second, this isn't JSON."
No, this is for representing a URL but I'm

00:53:38.960 --> 00:53:39.890
using the same at key annotation approach
so let's take a look at the - if I can get

00:53:39.890 --> 00:53:40.920
the emulator working again - if this doesn't
work, I'll go back to Mark. Hopefully it's

00:53:40.920 --> 00:53:43.780
directing back to the application using the
custom URI scheme that we defined. Alright,

00:53:43.780 --> 00:53:45.510
well, it's not working. Oh, it's working.
Great [laughs] and if this works, yes, it

00:53:45.510 --> 00:53:47.590
will show up over here and let's test it and
make sure that we're not just faking this

00:53:47.590 --> 00:53:52.070
demo. Here's the profile page. Ah. Let's go
back to emulator and let's make another post

00:53:52.070 --> 00:53:52.910
[applause] Yes. Ah, let's just delete that
one. Okay, so that's it. I encourage you to

00:53:52.910 --> 00:53:54.470
download the sample, play with it. Try the
application on your own application. Try it

00:53:54.470 --> 00:53:55.590
in Android, try it and install a desktop application
or a web application so I'll let you Mark

00:53:55.590 --> 00:53:55.840
tell you where you can download and where
you can give us feedback [applause]

00:53:55.650 --> 00:54:02.650
&gt;&gt;Mark: Thank you. It's good we have software
engineers for these things so I'd just like

00:54:05.230 --> 00:54:10.830
to, just a quick summary what we think is
better about this

00:54:10.830 --> 00:54:12.590
approach. You've seen that there was some
leverage of the discovery which made the API

00:54:12.590 --> 00:54:13.140
very easy. The amount of code in that sample,
even though we're using

00:54:13.140 --> 00:54:13.950
the Buzz API, there was very little Buzz specific
code that you had to write and there was no

00:54:13.950 --> 00:54:14.380
Buzz specific code included in the library
itself and finally,

00:54:14.380 --> 00:54:15.590
of course, this Java client library runs on
Android as well as APP engine and desktops.

00:54:15.590 --> 00:54:16.820
You are welcome to go check it out. This sample
has been archived for

00:54:16.820 --> 00:54:17.210
your pleasure. You can go read it and see
it. The library itself is still in alpha.

00:54:17.210 --> 00:54:17.460
We have a pre-released version of it available
in our public depository.

00:54:17.240 --> 00:54:17.980
Please go try it, give us feedback, and tell
us what it needs and what you think of it.

00:54:17.980 --> 00:54:20.460
So, that was quick summary of the things that
we're doing on the

00:54:20.460 --> 00:54:20.710
future of APIs and I've mentioned several
of the things that we've tried to fix around

00:54:20.510 --> 00:54:20.760
partial data, formats, and so on. Lots of
things that we're trying to

00:54:20.560 --> 00:54:21.120
make changes in how we build APIs going forward.
So, now I'll try and get to what you've probably

00:54:21.120 --> 00:54:21.370
really come for. How Google really builds
APIs. So, in

00:54:21.230 --> 00:54:21.860
order to make all these changes, we've had
to change how we build APIs from the ground

00:54:21.860 --> 00:54:23.760
up and here to show you some of that architecture
and some of those tools that we built, I'm

00:54:23.760 --> 00:54:25.270
inviting up Joey Schorr who's another software
engineer and he's going to show you exactly

00:54:25.270 --> 00:54:25.670
how Google builds APIs.

00:54:25.670 --> 00:54:26.260
&gt;&gt;Joey Schorr: Thanks, Mark. I don't need
that actually [applause] So imagine that I'm

00:54:26.260 --> 00:54:26.690
an engineer on a team and I have to build
an API. Traditionally

00:54:26.690 --> 00:54:27.540
speaking, I would have to hard code my API
into my front end in whatever format was necessary

00:54:27.540 --> 00:54:27.790
as we see in mostly Atom. I would then have
to manage all the

00:54:27.770 --> 00:54:28.300
necessary common functionality such as authentication,
logging, and other production concerns. As

00:54:28.300 --> 00:54:28.820
we've seen, this can be problematic and as
a result we've

00:54:28.820 --> 00:54:32.480
built a new powerful API stack that allows
Google engineers to create an API in just

00:54:32.480 --> 00:54:33.950
a few short steps. To begin, they start by
implementing their internal

00:54:33.950 --> 00:54:35.400
service. To do so, they define a set of abstract
resources using protocol buffers, our internal

00:54:35.400 --> 00:54:35.650
serialization and deserialization format,
which is also now

00:54:35.430 --> 00:54:35.680
an open source project. Then, once the engineer
has defined his or her internal resources,

00:54:35.580 --> 00:54:35.830
their next step so to define the set of collections
and those

00:54:35.700 --> 00:54:37.870
operations or verbs that can be performed
on the collections by protocol buffer RPC.

00:54:37.870 --> 00:54:39.430
Once the internal service has been launched
and other engineers and

00:54:39.430 --> 00:54:42.510
Google Apps can use it, the next step is to
configure our new API stack. The configuration

00:54:42.510 --> 00:54:47.500
is a simple JSON data file which maps the
REST paths, RPC methods,

00:54:47.500 --> 00:54:54.190
and query parameters to the internal collections,
resources, and verbs that are necessary for

00:54:54.190 --> 00:54:57.400
the API. The API stack also adds all the common
functionality

00:54:57.400 --> 00:55:03.510
that is needed - authentication, caching,
logging - thereby removing the burden from

00:55:03.510 --> 00:55:06.360
the Google engineer and putting it on the
stack itself. Finally, the

00:55:06.360 --> 00:55:06.610
engineer will write the output templates and
these represent the bidirectional transformations

00:55:06.600 --> 00:55:06.850
between the internal format, protocol buffers,
and the

00:55:06.600 --> 00:55:06.850
external format, JSON, Atom, XML, etc. Now
I'm going to show right here during this demo

00:55:06.600 --> 00:55:06.850
how we can implement a very simple API. In
this case, a task list

00:55:06.720 --> 00:55:06.970
API. So to begin, I start by defining all
the resources I need in protocol buffer format.

00:55:06.869 --> 00:55:07.119
To do so, I'll define a task message because
I want tasks in my

00:55:07.000 --> 00:55:07.250
tasks list. I'll define the fields necessary
for my resource. In this case, the ID field.

00:55:07.140 --> 00:55:08.160
Notice that I have to give the internal protocol
buffer identifier

00:55:08.160 --> 00:55:09.600
for the field. I'll probably want a description
of my task and I might want to specify whether

00:55:09.600 --> 00:55:09.850
my task has been completed. Now, once I've
defined all the

00:55:09.790 --> 00:55:10.140
resources that I need in my API, in this case
just a simple task, my next step is to define

00:55:10.140 --> 00:55:10.390
the collections necessary. In this case, I'll
define the tasks

00:55:10.310 --> 00:55:10.590
collection. I'll specify that the resource
id is of type string because I used a string

00:55:10.590 --> 00:55:10.869
here. I will then specify that the resource
itself is the task, of

00:55:10.869 --> 00:55:11.990
course, which I just defined right here above
and then I need to list all the operations

00:55:11.990 --> 00:55:12.560
or verbs that I want to make available as
part of my internal

00:55:12.560 --> 00:55:13.480
service. To begin, I'm going to work the common
REST ones; GET to get a task, LIST to list

00:55:13.480 --> 00:55:14.200
all the tasks, and INSERT to add a new task.
I might also want a

00:55:14.200 --> 00:55:15.060
custom verb. In this case, one to mark a task
as being completed, mark as done. It will

00:55:15.060 --> 00:55:19.119
take in, excuse me, the task id of the tasks
that I want to mark as

00:55:19.119 --> 00:55:21.500
done, and might want to return the actual
task itself. Now, once I've defined all my

00:55:21.500 --> 00:55:22.070
resources and all my collections, my next
step is to run an internal

00:55:22.070 --> 00:55:22.410
code generator which spits out an interface
which I can then implement in order to get

00:55:22.410 --> 00:55:22.690
this working as an internal service. I've
already done so, so my next

00:55:22.690 --> 00:55:23.760
step is to actually config the API stack itself.
Now, as I mentioned earlier, our configuration

00:55:23.760 --> 00:55:24.010
is just a simple JSON data file. However,
we wanted to make

00:55:23.880 --> 00:55:24.130
it even easier for Google engineers to create
an API in just a few steps. To that end, we've

00:55:24.070 --> 00:55:24.320
written a web based tool which I'm going to
show to you

00:55:24.190 --> 00:55:24.440
externally for the very first time today,
which allows Google engineers to create an

00:55:24.330 --> 00:55:24.580
API in under 10 minutes. To begin, I click
"Create New API". I give the

00:55:24.480 --> 00:55:24.850
name of the API, in this case, task list.
I give a descriptive title, "My Task List

00:55:24.850 --> 00:55:25.119
API". I then have to specify the address of
my internal service. In this

00:55:25.119 --> 00:55:25.470
case, running a local host 2500. Once it has
found my service, my next step is to specify

00:55:25.470 --> 00:55:25.720
the mappings of the internal verbs or operations
that I just

00:55:25.680 --> 00:55:25.970
defined to those operations or methods that
will be exposed to the external world. To

00:55:25.970 --> 00:55:26.260
begin, I hit "Add Method". I give the RPC
name of my method, "Task List

00:55:26.260 --> 00:55:26.590
dot tasks dot list". I also give a REST path.
This is ensuring that it's accessible both

00:55:26.590 --> 00:55:26.880
as REST and RPC so this will be "Tasks slash
list". I have to choose

00:55:26.880 --> 00:55:27.130
the internal operation that will be called
and you can see the system is introspected

00:55:27.070 --> 00:55:27.320
upon those operations I just defined, and
then I can add additional

00:55:27.230 --> 00:55:27.720
methods. In this case, I'm going to add one
to Mark, a task is done. I'll give it "Tasks

00:55:27.720 --> 00:55:28.480
slash the task id" and done, and I will choose
Mark as done. Now, as

00:55:28.480 --> 00:55:29.340
we saw, my custom operation required a parameter.
In this case, the task ID. Again, you can

00:55:29.340 --> 00:55:29.890
see the system has introspected on the fields
I've defined and

00:55:29.890 --> 00:55:30.430
given them to me here. Now, once I hit "Save",
my new API has been created. However, I'm

00:55:30.430 --> 00:55:30.740
not quite done yet. In order to truly use
this API externally, I

00:55:30.740 --> 00:55:31.080
have to define the template that maps the
internal resource representation to the external

00:55:31.080 --> 00:55:31.330
world. So you can see here I have my new API
into the list. I

00:55:31.300 --> 00:55:31.580
choose "Templates" and I'm going to want to
map my list method to JSON so I choose JSON

00:55:31.580 --> 00:55:31.830
and now you can see here the template that
represents the

00:55:31.770 --> 00:55:32.020
bidirectional mapping between the methods
internal source representation and it's external

00:55:31.850 --> 00:55:32.100
JSON representation. To begin, I'm going to
want to list the tasks

00:55:31.950 --> 00:55:32.200
defined in the list. A loop over, excuse me,
a loop over all the resources defined in the

00:55:32.090 --> 00:55:33.270
entity and then for each of the tasks I'm
going to want to list a

00:55:33.270 --> 00:55:34.890
JSON object that represents the tasks information
itself. In this case, the ID, the description,

00:55:34.890 --> 00:55:35.140
and whether it's been done. Now, once I hit
"Save", I now

00:55:34.910 --> 00:55:35.160
have a fully functioning bidirectional JSON
API representing my simple task list and to

00:55:34.930 --> 00:55:35.180
that end, I'll actually demonstrate it for
you here. Hold on one moment. I'll just do

00:55:34.960 --> 00:55:35.210
it over here. To begin, I'm going to want
to list all the tasks defined in my service

00:55:34.990 --> 00:55:35.240
and I'm probably going to want to prettyprint
it to see what it actually looks like. As

00:55:35.020 --> 00:55:35.270
you can see, I have a very simple two tasks
that I've prepopulated into my service. You

00:55:35.050 --> 00:55:35.300
can see the tasks JSON representation here
that I've already defined and the ID and some

00:55:35.080 --> 00:55:35.330
of the other fields. You can also, again,
call this via JSON RPC and I'm also again

00:55:35.110 --> 00:55:35.360
going to prettyprint it and you can see here
it's the exact same representation with the

00:55:35.130 --> 00:55:35.380
exception of the lack of the data envelope.
Now, I might want to mark a task as done so

00:55:35.170 --> 00:55:35.420
I will do "Mark Done". I'll give it the task
id, in this case, "My Task", as defined right

00:55:35.200 --> 00:55:35.450
here and of course I'll want to prettyprint
it again and you can see now the task has

00:55:35.230 --> 00:55:35.480
been returned with the done field set to true
and if I go back and list the tasks, refresh,

00:55:35.260 --> 00:55:35.510
you can see now the done field has been marked
to true so you've seen how we can implement

00:55:35.300 --> 00:55:35.550
a very simple yet powerful API in under five
minutes during an IO presentation and this

00:55:35.320 --> 00:55:35.570
demonstrates the true power of our stack [applause]
Zach?

00:55:35.340 --> 00:55:35.590
&gt;&gt;Zach: Alright, thanks Joey. So, as Joey
just said, three steps and Google engineers

00:55:35.360 --> 00:55:35.610
can build an API so I just want to make sure
everybody realized what just happened because

00:55:35.390 --> 00:55:35.640
it's so cool that every time I think about
it, uh, I don't know [laughs] So he took what

00:55:35.420 --> 00:55:35.670
we had as an internal service, wrote a few
config files, connected it to the new API

00:55:35.450 --> 00:55:35.700
stack, and then launched a new API and it
was done in literally five minutes as you

00:55:35.480 --> 00:55:35.730
guys watched. So, alright, so that being said,
we are going to conclude our presentation

00:55:35.510 --> 00:55:35.760
on that note. Questions and comments, check
out bit.ly/apiwave.

00:55:35.520 --> 00:55:35.770
&gt;&gt; I'll pop over there now.

00:55:35.530 --> 00:55:35.780
&gt;&gt;Zach: Alright, I'll invite Mark and Yaniv
back up so I can have them answer the hard

00:55:35.560 --> 00:55:35.810
questions for me. Alright, and there's mics
throughout the audience if anybody has any

00:55:35.580 --> 00:55:35.830
questions as well. Alright. So, want to know
how Google decides what features to offer

00:55:35.610 --> 00:55:35.860
when building a new API? Okay, there's two
things that Google - well, the sessions started.

00:55:35.640 --> 00:55:35.890
Awesome. There's two things that Google wants
to do when we launch a new API. One is Google

00:55:35.670 --> 00:55:35.920
really believes that any data that belongs
to you, belongs to you. Whether it's on our

00:55:35.690 --> 00:55:35.940
system or on your system so when we build
API's, we build them so they expose all the

00:55:35.720 --> 00:55:35.970
data, that way if you want to leave Google,
we don't lock you into Google services and

00:55:35.750 --> 00:55:36.000
you can get all your data out. Now, that said,
you know, exposing all of the data in a simple

00:55:35.790 --> 00:55:36.040
API isn't really the best way. We saw a bunch
of examples of mobile clients. You don't want

00:55:35.820 --> 00:55:36.070
to get all your data every time you want to
simply update something so when our engineers

00:55:35.850 --> 00:55:36.100
build new APIs, they think about what the
use cases for the APIs are and then give you

00:55:35.880 --> 00:55:36.130
methods and field that will work the best
for your API. You guys have anything to add?

00:55:35.910 --> 00:55:36.160
You've built more APIs then I have so [laughs]

00:55:35.920 --> 00:55:36.170
&gt;&gt;Joey: I was just going to mention that we
add APIs where we can add value. We've added

00:55:35.950 --> 00:55:36.200
a lot of APIs to again, a lot of services
that make APIs possible. A lot of our apps

00:55:35.990 --> 00:55:36.240
APIs are designed to make it possible for
say enterprise customers in order to leverage

00:55:36.010 --> 00:55:36.260
the app suite and basically teams are looking
for ways to add APIs in different ways that

00:55:36.040 --> 00:55:36.290
add value and that's just an example of how
we choose APIs. So each product, of course,

00:55:36.070 --> 00:55:36.320
comes with a slightly different story to a
large extent.

00:55:36.090 --> 00:55:36.340
&gt;&gt;Zach: Alright. Well, that was all the moderator
questions so audience, do you have questions?

00:55:36.110 --> 00:55:36.360
&gt;&gt; Yeah. How about a tasks API?

00:55:36.119 --> 00:55:36.369
&gt;&gt;Zach: So, yes. There will be a tasks API
coming soon. I can say that so I think that

00:55:36.150 --> 00:55:36.400
answers your question.

00:55:36.160 --> 00:55:36.410
&gt;&gt; We have to take Joey. Joey can probably
do one in ten minutes.

00:55:36.180 --> 00:55:36.430
&gt;&gt; So, would this discover API, would it be
directly possible to have just one client

00:55:36.210 --> 00:55:36.460
library that would like auto generate libraries
for each and every Google API that supports

00:55:36.230 --> 00:55:36.480
discover?

00:55:36.240 --> 00:55:36.490
&gt;&gt;Zach: Yeah. So, I mean, as you can see from
Yaniv's demo, there's very little Buzz specific

00:55:36.260 --> 00:55:36.510
code in there and so with that client library,
it could be taken and used with any API that

00:55:36.300 --> 00:55:36.550
uses discovery without any updates to the
client library itself which is the awesome

00:55:36.320 --> 00:55:36.570
part of this. So any API that supports discovery
going forward will work with, actually the

00:55:36.350 --> 00:55:36.600
client library that you need is already written.
It's not in it's final form yet but it will

00:55:36.380 --> 00:55:36.630
work. Does that answer your question? Cool.

00:55:36.390 --> 00:55:36.640
&gt;&gt; I think it's worth mentioning though that
this is still technology we're still developing

00:55:36.410 --> 00:55:36.660
so there's no guarantee that the way discovery
worked right now in our demo is the final

00:55:36.440 --> 00:55:36.690
form for it. We are all talking about innovation
in the opening and we wanted to give you a

00:55:36.480 --> 00:55:36.730
chance to give us feedback so that's why we
released it.

00:55:36.490 --> 00:55:36.740
&gt;&gt; And if you have feedback, come grab Yaniv
afterwards since he'll be building all this

00:55:36.520 --> 00:55:36.770
stuff later [laughs]

00:55:36.530 --> 00:55:36.780
&gt;&gt; Why don't we take a live question while
we wait?

00:55:36.540 --> 00:55:36.790
&gt;&gt;Zach: Yeah. So, go ahead.

00:55:36.550 --> 00:55:36.800
&gt;&gt; I'm a big fan of protocol buffers and I
noticed that you've got that sort of exposed

00:55:36.580 --> 00:55:36.830
internally but you're only exposing tech space
external formats. Are there any plans to expose

00:55:36.610 --> 00:55:36.860
 -

00:55:36.610 --> 00:55:36.860
&gt;&gt;Zach: For now, for now.

00:55:36.610 --> 00:55:36.860
&gt;&gt; Expose a binary one?

00:55:36.619 --> 00:55:36.869
&gt;&gt;Zach: So, the benefit of the new stack is
that we can adapt any format very quickly

00:55:36.650 --> 00:55:36.900
so be on the lookout for your favorite format
coming soon.

00:55:36.670 --> 00:55:36.920
&gt;&gt;Yaniv: And make your voice heard. If you
need a format, let us know.

00:55:36.690 --> 00:55:36.940
&gt;&gt;Zach: Alright. So, some more questions here.
What new Google APIs are coming out in the

00:55:36.720 --> 00:55:36.970
new future? Now, if I told you guys when new
APIs were coming out in the near future, that

00:55:36.750 --> 00:55:37.000
would ruin the surprise when they actually
launched [laughs] but the second question;

00:55:36.780 --> 00:55:37.030
when will Google release a tasks API? I kind
of said soon already so there might be a tasks

00:55:36.810 --> 00:55:37.060
API coming out in the near future. Maybe.
I can't make any promises. Alright, the idea

00:55:36.840 --> 00:55:37.090
of a discovery document sound similar to wizdl.
Mark, what are the distinctions between ours

00:55:36.860 --> 00:55:37.110
and wizdl's?

00:55:36.860 --> 00:55:37.110
&gt;&gt;Mark: Well, we are much more similar to
 - I don't know if you are familiar with it

00:55:36.890 --> 00:55:37.140
 - but there's an alternative to wizdl called
waddle. Are you familiar with that? Which,

00:55:36.920 --> 00:55:37.170
if you look at the discovery document format
that we're using right now, is actually almost

00:55:36.940 --> 00:55:37.190
a JSON-ified version of waddle. The difference
between wizdl and waddle is mainly wizdl is

00:55:36.970 --> 00:55:37.220
an RPC focused document and it also comes
along with it the SOAP protocol. Waddle, which

00:55:37.000 --> 00:55:37.250
is a proposed standard, is an XML document
that describes RESTful APIs. Ours actually

00:55:37.020 --> 00:55:37.270
support REST APIs and JSON RPC so it's a slightly
different subset of what we're describing

00:55:37.050 --> 00:55:37.300
and we will probably be more compatible with
waddle, and in fact, we may offer a waddle

00:55:37.080 --> 00:55:37.330
document at some point. It's one of the things
that we're actually considering as a feature

00:55:37.110 --> 00:55:37.360
so I hope that answers your question.

00:55:37.119 --> 00:55:37.369
&gt;&gt;Zach: So on that same line, I just want
to reiterate what Mark said and reinforce

00:55:37.140 --> 00:55:37.390
that with the fact that Google is really committed
to open standards.

00:55:37.160 --> 00:55:37.410
You've seen that throughout all of the presentations
so far in the past two days. Obviously, we

00:55:37.190 --> 00:55:37.440
are working with JSON RPC and Atom so as we
do discovery, as it progresses further, you

00:55:37.220 --> 00:55:37.470
can expect us to make sure that it's as compatible
with as many different discovery formats as

00:55:37.250 --> 00:55:37.500
possible. Alright, so - another audience question.

00:55:37.260 --> 00:55:37.510
&gt;&gt; How do you deal with convergence issues
like throttling?

00:55:37.280 --> 00:55:37.530
&gt;&gt;Zach: So throttling and that type of the
stuff is all taken care of by the API stack

00:55:37.310 --> 00:55:37.560
so none of the teams that actually build an
API at Google - it's one of those common features

00:55:37.340 --> 00:55:37.590
that we take care of. I don't - do you guys
want to talk about that?

00:55:37.360 --> 00:55:37.610
&gt;&gt;Joey: Well, traditionally speaking, that
was actually not the case and one of the benefits

00:55:37.390 --> 00:55:37.640
of the new stack is that teams are no longer
responsible, in a visual team basis, for implementing

00:55:37.420 --> 00:55:37.670
throttling and logging and other production
concerns is now part of new stack and they

00:55:37.450 --> 00:55:37.700
get all those benefits merely by being part
of this stack as we showed.

00:55:37.470 --> 00:55:37.720
&gt;&gt; So do you have like a central operations
team for the production side that deals with

00:55:37.500 --> 00:55:37.750
those issues?

00:55:37.500 --> 00:55:37.750
&gt;&gt;Joey: Yeah. They're sitting in the front
row, right here. [laughs] and shrinking down

00:55:37.530 --> 00:55:37.780
into their seats as I saw that. Believe that,
we've been pretty busy the past few days.

00:55:37.550 --> 00:55:37.800
&gt;&gt;Zach: What book would I have people read?
Wow. [laughs] So I can honestly say that I

00:55:37.580 --> 00:55:37.830
haven't read any books in the past two months
because we've been getting ready for Google

00:55:37.610 --> 00:55:37.860
IO. Do you guys have any books you'd like
to recommend to the audience?

00:55:37.630 --> 00:55:37.880
&gt;&gt; The number one thing I read a while ago
was just Roy Fielding's thesis just to understand

00:55:37.660 --> 00:55:37.910
the concept behind REST and then trying to
figure out where that really - you know, the

00:55:37.690 --> 00:55:37.940
concepts behind are abstract and a little
bit deep in terms of thinking about APIs.

00:55:37.720 --> 00:55:37.970
Other then that, I would actually suggest
you go read APIs. Go look at Twitter, go look

00:55:37.750 --> 00:55:38.000
at New York Times, go look at Facebook, go
look at Flickr. This is where - these are

00:55:37.770 --> 00:55:38.020
the people who are building the new RESTful
APIs that are out there. This is where you

00:55:37.800 --> 00:55:38.050
learn more. The books aren't there yet, or
at least not that I found so that would be

00:55:37.830 --> 00:55:38.080
my recommendation.

00:55:37.840 --> 00:55:38.090
&gt;&gt; And of course, take a look at all the developer
guides for all the new APIs that have launched

00:55:37.869 --> 00:55:38.119
in IO. They are very good resources.

00:55:37.880 --> 00:55:38.130
&gt;&gt;Zach: And if you're looking for a fiction
book, "Day Watch" and "Night Watch" are awesome

00:55:37.910 --> 00:55:38.160
books so you can check those out. Alright,
so another question from the audience.

00:55:37.930 --> 00:55:38.180
&gt;&gt; Question about the at me. How would you
decide the API that uses authentication or

00:55:37.960 --> 00:55:38.210
authorization? And the at me, how do you pass
that in a message?

00:55:37.980 --> 00:55:38.230
&gt;&gt;Zach: I'm sorry. Can you repeat the question?

00:55:38.000 --> 00:55:38.250
&gt;&gt; How do you pass the at me in the message?
Like when you are defining the message and

00:55:38.030 --> 00:55:38.280
how do you decide that it uses authentication?

00:55:38.040 --> 00:55:38.290
&gt;&gt;Zach: So at me is just a shortcut for the
currently authenticated users so we are not

00:55:38.070 --> 00:55:38.320
exposing your users personal email addresses
and URIs that are being sent around the Web.

00:55:38.090 --> 00:55:38.340
&gt;&gt; But do you define the message as using
at me like when you're defining a message,

00:55:38.119 --> 00:55:38.369
how do you say that it has to use at me as
a parameter let's say?

00:55:38.150 --> 00:55:38.400
&gt;&gt;Mark: Let me see if I can answer your question.
Typically, we are addressing a resource. There's

00:55:38.180 --> 00:55:38.430
a URL template. One of those parameters that
are very common is the user ID and that user

00:55:38.210 --> 00:55:38.460
ID can be an email address or some form of
encoded ID or an at me token is a special

00:55:38.240 --> 00:55:38.490
token saying insert user ID that is provided
by authentication. It's implicit in the URL

00:55:38.270 --> 00:55:38.520
template. Does that answer your question?

00:55:38.280 --> 00:55:38.530
&gt;&gt; And that comes in from the stack?

00:55:38.290 --> 00:55:38.540
&gt;&gt;Mark: So when you are configuring the stack,
one of the fields you give in the tool, which

00:55:38.320 --> 00:55:38.570
we didn't demo, is you can actually specify
that certain methods can only be called with

00:55:38.350 --> 00:55:38.600
certain credentials and as a result those
credentials are passed on and in the case

00:55:38.369 --> 00:55:38.619
of a user ID, will be filled in by the stack.

00:55:38.390 --> 00:55:38.640
&gt;&gt; Okay. Got it.

00:55:38.400 --> 00:55:38.650
&gt;&gt;Zach: So I think we have time for one more
question before we're up so we'll go live.

00:55:38.430 --> 00:55:38.680
&gt;&gt; The question I've had is just from designing
different API's. It's always as you're building

00:55:38.460 --> 00:55:38.710
them trying to document it and I saw you kind
of fill out the API and I didn't know if while

00:55:38.490 --> 00:55:38.740
you were building it you had somebody also
in line describing kind of what happens or

00:55:38.520 --> 00:55:38.770
 - I mean, I've always had the problem like
now I have this API and then I have to go

00:55:38.550 --> 00:55:38.800
back and document it and this whole process.
It be much better to merge so I didn't know

00:55:38.580 --> 00:55:38.830
how you guys solved that.

00:55:38.590 --> 00:55:38.840
&gt;&gt;Zach: So actually one of things that we
did not show about this new tool is that it

00:55:38.619 --> 00:55:38.869
auto generates documentation for the API.
Well, if you go out and look at the Latitude

00:55:38.650 --> 00:55:38.900
API docs, there's a reference guide there
and that entire reference guide was auto generated

00:55:38.670 --> 00:55:38.920
with no work by the engineers other then what
you would annotate the fields with as they

00:55:38.700 --> 00:55:38.950
are making the API. Obviously, something more
like a developers guide where you have to

00:55:38.730 --> 00:55:38.980
understand the basics concept that would be
really awesome to auto generate that but the

00:55:38.750 --> 00:55:39.000
stacks not self-aware yet so it's not going
to be able to [laughs]

00:55:38.780 --> 00:55:39.030
&gt;&gt;Mark: Just to expand a little bit on that.
If you notice while I was writing the template,

00:55:38.810 --> 00:55:39.060
it was a variation of JSON. We support JS
doc like comments in there and if you annotate

00:55:38.840 --> 00:55:39.090
fields with the script of information, when
you then go to generate the reference guide

00:55:38.860 --> 00:55:39.110
for example, it will automatically pull that
information from the template and also from

00:55:38.890 --> 00:55:39.140
the configuration information as part of the
same tool I demoed.

00:55:38.910 --> 00:55:39.160
&gt;&gt;Zach: Alright. So I think that's the end
of our session. We've run to the max extent

00:55:38.940 --> 00:55:39.190
allowed so thank you everybody for coming.
We're glad to have a full room here. Grab

00:55:38.960 --> 00:55:39.210
us afterwards if you have any questions [applause]

