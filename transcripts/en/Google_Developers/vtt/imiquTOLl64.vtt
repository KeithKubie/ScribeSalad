WEBVTT
Kind: captions
Language: en

00:00:03.290 --> 00:00:05.240
DAVID CHANDLER: Good morning.

00:00:05.240 --> 00:00:06.570
What a crowd.

00:00:06.570 --> 00:00:11.040
We speculated when Google I/O
sold out in 59 minutes.

00:00:11.040 --> 00:00:14.790
By the way, congratulations to
all of you who set places in

00:00:14.790 --> 00:00:17.730
your calendars that you were
going to get an I/O ticket

00:00:17.730 --> 00:00:19.920
this year no matter what.

00:00:19.920 --> 00:00:22.640
It's a great testimony to the
excitement about Google

00:00:22.640 --> 00:00:24.950
Technologies and APIs that
you're all here.

00:00:24.950 --> 00:00:26.970
And we're very glad for that.

00:00:26.970 --> 00:00:29.100
But when we sold out so
quickly there was some

00:00:29.100 --> 00:00:32.280
speculation, is this because
people just want the free

00:00:32.280 --> 00:00:33.670
phones or devices?

00:00:33.670 --> 00:00:36.600
And the fact that we have over
200 people here in this room,

00:00:36.600 --> 00:00:39.690
standing room only, to hear talk
about GWT says to me, no,

00:00:39.690 --> 00:00:40.940
you came for the code.

00:00:47.212 --> 00:00:48.450
So thank you very much.

00:00:48.450 --> 00:00:49.450
My name is David Chandler.

00:00:49.450 --> 00:00:52.300
I work with the Google Web
Tool Kit team in Atlanta.

00:00:52.300 --> 00:00:54.730
And we're going to talk this
morning about some third-party

00:00:54.730 --> 00:00:58.580
tools that you can use for
productive GWT development.

00:00:58.580 --> 00:01:00.930
And with that, we'll go
ahead and get started.

00:01:04.000 --> 00:01:05.710
So first, we're going
to talk about

00:01:05.710 --> 00:01:07.050
third-party tools in general.

00:01:07.050 --> 00:01:10.100
And then we're going to speak
about Objectify-Appengine,

00:01:10.100 --> 00:01:12.750
which is useful on
the server side.

00:01:12.750 --> 00:01:15.480
Then I'm going to cover the new
RequestFactory features in

00:01:15.480 --> 00:01:18.780
GWT 2.1 and then Philippe
Beaudoin will talk about the

00:01:18.780 --> 00:01:20.865
gwt-platform framework
for MVP development.

00:01:23.400 --> 00:01:25.520
So we want to mention
some third-party

00:01:25.520 --> 00:01:26.740
tools that are useful.

00:01:26.740 --> 00:01:28.210
Google can write a line
of code, but we don't

00:01:28.210 --> 00:01:29.570
write all the code.

00:01:29.570 --> 00:01:32.270
We rely on third-party
open source projects

00:01:32.270 --> 00:01:33.360
to do an awful lot.

00:01:33.360 --> 00:01:34.670
And of course, we contribute
to get those

00:01:34.670 --> 00:01:36.430
things started as well.

00:01:36.430 --> 00:01:38.650
But one tool that you can use
for GWT and App Engine

00:01:38.650 --> 00:01:40.610
development is Maven.

00:01:40.610 --> 00:01:43.570
And I just want to highlight
because there were some issues

00:01:43.570 --> 00:01:46.540
using Maven with Google Plugin
for Eclipse in the past. We've

00:01:46.540 --> 00:01:49.530
made a big effort to make those
work better together.

00:01:49.530 --> 00:01:52.750
And you can now import an
existing Maven project in

00:01:52.750 --> 00:01:55.820
Eclipse and your Google Plugin
in for Eclipse stuff will be

00:01:55.820 --> 00:01:56.560
all configured.

00:01:56.560 --> 00:01:59.770
With your App Engine STKs will
come from the Maven POM as

00:01:59.770 --> 00:02:01.470
well as your GWT STKs.

00:02:01.470 --> 00:02:04.840
And it works much better than
it has in the past.

00:02:04.840 --> 00:02:05.680
So this is a great--

00:02:05.680 --> 00:02:07.050
[APPLAUSE].

00:02:07.050 --> 00:02:08.280
Thank you.

00:02:08.280 --> 00:02:11.640
So let me ask, how many
people use Maven?

00:02:11.640 --> 00:02:12.040
OK.

00:02:12.040 --> 00:02:13.020
Lots.

00:02:13.020 --> 00:02:16.040
How many people love Maven?

00:02:16.040 --> 00:02:16.940
OK.

00:02:16.940 --> 00:02:19.230
How many people hate Maven?

00:02:19.230 --> 00:02:21.820
Some of the same hands.

00:02:21.820 --> 00:02:22.510
All right.

00:02:22.510 --> 00:02:23.800
We understand.

00:02:23.800 --> 00:02:25.400
But it's a useful tool.

00:02:25.400 --> 00:02:28.400
So we want to try and support
it as best we can.

00:02:28.400 --> 00:02:31.440
And two third-party projects
that are very important to

00:02:31.440 --> 00:02:34.240
that are the Maven GAE Plugin
and the GWT Maven Plugin.

00:02:34.240 --> 00:02:37.770
And we're really glad that they
took this on because they

00:02:37.770 --> 00:02:40.450
did those plugins before we
supported it and Google Plugin

00:02:40.450 --> 00:02:41.430
for Eclipse.

00:02:41.430 --> 00:02:43.550
And we rely on the community
for this so

00:02:43.550 --> 00:02:45.410
that's great stuff.

00:02:45.410 --> 00:02:47.720
Now on the App Engine datastore
side there have

00:02:47.720 --> 00:02:50.350
been, besides the JDO and JPA
interface that Google

00:02:50.350 --> 00:02:54.770
produces, there is Twig, Sim3,
Symbol DS, Objectify.

00:02:54.770 --> 00:02:56.220
There's lots of different
frameworks that have been

00:02:56.220 --> 00:02:58.470
developed to help people
with persistence.

00:02:58.470 --> 00:03:02.130
And then on the front
end side, lots of

00:03:02.130 --> 00:03:04.060
model-view-presenter
frameworks.

00:03:04.060 --> 00:03:07.850
Mvp4g, gwt-presenter and
dispatch, and gwt-platform are

00:03:07.850 --> 00:03:10.780
frameworks you've probably
all heard of.

00:03:10.780 --> 00:03:13.440
So these are just some tools
if you're getting started

00:03:13.440 --> 00:03:15.170
researching these topics.

00:03:15.170 --> 00:03:18.340
Good places to go and look.

00:03:18.340 --> 00:03:20.380
So what we're going to do this
morning is kind of work from

00:03:20.380 --> 00:03:21.390
back to front.

00:03:21.390 --> 00:03:24.480
We're going to start on the
server side and talk about the

00:03:24.480 --> 00:03:26.890
App Engine datastore in
Objectify, a framework that

00:03:26.890 --> 00:03:28.040
can help you there.

00:03:28.040 --> 00:03:31.400
Then move up to RequestFactory
which is GWT's new RPC layer.

00:03:31.400 --> 00:03:35.170
And then at the top we'll have
gwt-platform and how you can

00:03:35.170 --> 00:03:39.320
use it to build
model-view-presenter UIs.

00:03:39.320 --> 00:03:41.830
So with that, I'm very pleased
this morning to have with us

00:03:41.830 --> 00:03:45.260
the creator of Appengine
Objectify Jeff Schnitzer.

00:03:45.260 --> 00:03:46.510
Jeff, please come on up.

00:03:52.120 --> 00:03:52.940
JEFF SCHNITZER: Hello.

00:03:52.940 --> 00:03:54.510
It worked.

00:03:54.510 --> 00:03:57.618
Oh where's the clicker?

00:03:57.618 --> 00:03:58.850
All right.

00:03:58.850 --> 00:04:03.060
I'm going to give you a very,
very brief introduction to

00:04:03.060 --> 00:04:06.770
what I'm calling the simplest,
convenient interface to the

00:04:06.770 --> 00:04:08.750
App Engine datastore.

00:04:08.750 --> 00:04:10.760
But first, I have a little
confession to make, and that's

00:04:10.760 --> 00:04:13.200
that I hate writing tools.

00:04:13.200 --> 00:04:17.120
I'm an entrepreneur, and every
day that I spend writing tools

00:04:17.120 --> 00:04:20.800
is a day that I'm not adding a
feature to an application that

00:04:20.800 --> 00:04:25.390
might someday make me
rich and successful.

00:04:25.390 --> 00:04:28.853
But I use a lot of tools, and
it's very important to me to

00:04:28.853 --> 00:04:29.590
use good tools.

00:04:29.590 --> 00:04:34.640
If you ever walk into the back
of the workspace of an

00:04:34.640 --> 00:04:38.500
automotive or motorcycle
mechanic, you'll find well,

00:04:38.500 --> 00:04:42.040
first, a number of posters
of half-naked women.

00:04:42.040 --> 00:04:46.430
But second, you'll find a big
box of Snap-On Tools.

00:04:46.430 --> 00:04:48.340
Snap-On Tools are
very expensive.

00:04:48.340 --> 00:04:52.590
A wrench that will cost maybe
$10 at Sears will set you back

00:04:52.590 --> 00:04:54.370
about $50 from Snap-On.

00:04:54.370 --> 00:04:56.100
There's nothing wrong with
the Craftsman tool.

00:04:56.100 --> 00:04:58.910
I've got a garage full of them,
and let me tell you they

00:04:58.910 --> 00:05:01.380
turn bolts just fine.

00:05:01.380 --> 00:05:05.480
But if you hold the Snap-On tool
in your hand, the polish

00:05:05.480 --> 00:05:06.630
is a little bit better.

00:05:06.630 --> 00:05:08.990
The weighting is a little
bit better.

00:05:08.990 --> 00:05:11.470
It's just slightly nicer
ergonomically.

00:05:11.470 --> 00:05:17.010
And if you spend every day of
your life working with tools,

00:05:17.010 --> 00:05:21.080
when you have slightly nicer
tools, it actually improves

00:05:21.080 --> 00:05:22.950
your quality of life.

00:05:22.950 --> 00:05:26.990
So when I started working on App
Engine a year and a half

00:05:26.990 --> 00:05:31.030
ago, I started out with
JDA and JPO--

00:05:31.030 --> 00:05:32.290
excuse me.

00:05:32.290 --> 00:05:33.540
JPO and JDA.

00:05:36.260 --> 00:05:40.140
Well, my quality of
life was not good.

00:05:40.140 --> 00:05:42.890
This kind of surprised me,
because I'm actually a really

00:05:42.890 --> 00:05:44.410
big fan of JPA.

00:05:44.410 --> 00:05:47.830
I've been doing Java EE
development professionally for

00:05:47.830 --> 00:05:48.670
about a decade.

00:05:48.670 --> 00:05:51.930
I've been using Hibernate
version 1.0 and I've got Gavin

00:05:51.930 --> 00:05:53.390
King on speed dial.

00:05:53.390 --> 00:05:56.682
But still, it was a struggle.

00:05:56.682 --> 00:05:59.380
And I tried to figure out why.

00:05:59.380 --> 00:06:02.790
I realized that there's two
basic problems. One, there's a

00:06:02.790 --> 00:06:09.020
lot of stuff in JDO and JPA that
just don't really apply

00:06:09.020 --> 00:06:10.462
to App Engine.

00:06:10.462 --> 00:06:14.030
And second of all, there's a
lot of stuff in App Engine

00:06:14.030 --> 00:06:16.550
that just was never accounted
for when they

00:06:16.550 --> 00:06:18.330
designed JPA and JDO.

00:06:18.330 --> 00:06:20.570
You can't develop an application
on App Engine

00:06:20.570 --> 00:06:23.770
without understanding at some
level how keys work, how

00:06:23.770 --> 00:06:27.430
entity groups work, and the
particular quirks of indexes

00:06:27.430 --> 00:06:29.330
on App Engine.

00:06:29.330 --> 00:06:33.260
And because of this there's four
learning curves that I

00:06:33.260 --> 00:06:34.390
had to climb.

00:06:34.390 --> 00:06:38.830
First, how do you represent your
Java data structures with

00:06:38.830 --> 00:06:41.030
JPA or JDO?

00:06:41.030 --> 00:06:47.340
How do you manage the giant
DataNucleus software package

00:06:47.340 --> 00:06:49.270
which implements that?

00:06:49.270 --> 00:06:52.460
There's actually the DataNucleus
plugin that Google

00:06:52.460 --> 00:06:55.880
writes that maps from the
whatever they put out on the

00:06:55.880 --> 00:06:58.800
back end to the low
level data store.

00:06:58.800 --> 00:07:03.290
And then there's how should my
data actually be represented

00:07:03.290 --> 00:07:06.580
natively in the datastore
itself?

00:07:06.580 --> 00:07:09.910
To make this especially fun, the
documentation for all of

00:07:09.910 --> 00:07:11.570
these learning curves
is spread out

00:07:11.570 --> 00:07:13.750
all over the internet.

00:07:13.750 --> 00:07:18.100
And so I was running to and
fro different websites.

00:07:18.100 --> 00:07:22.950
When I took a step back and
said, OK this is crazy.

00:07:22.950 --> 00:07:25.100
I realized the only one of these
learning curves that

00:07:25.100 --> 00:07:32.590
really matters is, how should my
data look in the datastore?

00:07:32.590 --> 00:07:34.700
Because this is what
controls what is my

00:07:34.700 --> 00:07:36.330
application going to cost?

00:07:36.330 --> 00:07:39.410
How long is it going to take
my queries to return?

00:07:39.410 --> 00:07:42.280
Will I be able to get
the answers to my

00:07:42.280 --> 00:07:44.520
queries that I want?

00:07:44.520 --> 00:07:46.740
So of course, I went straight to
the low-level API, which at

00:07:46.740 --> 00:07:48.820
the time was documented
only in Java Docs.

00:07:51.460 --> 00:07:53.260
And I realized something.

00:07:53.260 --> 00:07:57.310
I realized that the App Engine
datastore is actually really

00:07:57.310 --> 00:08:00.230
simple and really elegant.

00:08:00.230 --> 00:08:02.490
There's really only
four operations.

00:08:02.490 --> 00:08:04.350
You can get data out
of the datastore.

00:08:04.350 --> 00:08:05.780
You can put data in
the datastore.

00:08:05.780 --> 00:08:06.710
You can delete it.

00:08:06.710 --> 00:08:10.220
And then you can query for it.

00:08:10.220 --> 00:08:13.740
And the low-level API is not
really all that bad.

00:08:13.740 --> 00:08:17.690
You've got these simple entity
data structures.

00:08:17.690 --> 00:08:19.450
It's basically a HashMap.

00:08:19.450 --> 00:08:21.860
You can key it by string.

00:08:21.860 --> 00:08:24.770
You can put some data in, you
can take some data out.

00:08:24.770 --> 00:08:27.900
But it's a little bit too simple
for all the reasons

00:08:27.900 --> 00:08:30.530
that we invented compilers
and type checkers.

00:08:30.530 --> 00:08:32.789
It's really not very pleasant
working with HashMaps.

00:08:32.789 --> 00:08:36.400
And the datastore itself
has a few funny quirks.

00:08:36.400 --> 00:08:39.539
If you put numbers into an
entity, it'll always

00:08:39.539 --> 00:08:41.679
come back as a long.

00:08:41.679 --> 00:08:45.770
If you put a set of data into
the entity, it'll come back as

00:08:45.770 --> 00:08:47.370
a list.

00:08:47.370 --> 00:08:51.770
So what I really wanted
was just objects.

00:08:51.770 --> 00:08:56.140
We're used to working with
objects, nice tight

00:08:56.140 --> 00:08:57.550
structures.

00:08:57.550 --> 00:09:02.960
So I decided that I'm going to
write a thin layer that works

00:09:02.960 --> 00:09:07.460
just like the low-level API
does, but that lets me work

00:09:07.460 --> 00:09:08.130
with objects.

00:09:08.130 --> 00:09:13.370
It simply objectifies
the low-level API.

00:09:13.370 --> 00:09:19.180
And so here is an example
of an Objectify entity.

00:09:19.180 --> 00:09:21.180
There's only one required
annotation.

00:09:21.180 --> 00:09:23.720
You have to define an ID.

00:09:23.720 --> 00:09:26.850
And it uses the ID annotation.

00:09:26.850 --> 00:09:29.380
Other than that you can use
enums You can have almost any

00:09:29.380 --> 00:09:32.530
type involved you want.

00:09:32.530 --> 00:09:36.030
Getting an entity out of the
datastore is very simple.

00:09:36.030 --> 00:09:39.310
You pass in the class and
an ID, and you can

00:09:39.310 --> 00:09:40.900
get back the entity.

00:09:40.900 --> 00:09:45.150
There's also a batch operation
for doing this.

00:09:45.150 --> 00:09:47.560
Putting data into
the datastore.

00:09:47.560 --> 00:09:50.370
Create an object, put
it in the datastore.

00:09:50.370 --> 00:09:54.160
There's a batch operation
as well.

00:09:54.160 --> 00:09:56.190
Deleting entities.

00:09:56.190 --> 00:09:58.660
Simple, straightforward.

00:09:58.660 --> 00:10:01.360
There's also as you can
guess there's a

00:10:01.360 --> 00:10:03.440
batch delete operation.

00:10:03.440 --> 00:10:07.630
And for any of you that use
the Python version of App

00:10:07.630 --> 00:10:10.010
Engine, the querying API should

00:10:10.010 --> 00:10:11.680
actually seem very simple.

00:10:11.680 --> 00:10:14.780
Should seem very familiar.

00:10:14.780 --> 00:10:18.660
So that's the briefest
introduction to it.

00:10:18.660 --> 00:10:21.650
A year and a half later, there's
been quite a lot of

00:10:21.650 --> 00:10:22.890
new features added.

00:10:22.890 --> 00:10:26.120
I'm not the only one committing
code anymore.

00:10:26.120 --> 00:10:28.500
We've added asynchronous
operations,

00:10:28.500 --> 00:10:29.600
true polymorphic queries.

00:10:29.600 --> 00:10:33.350
So you can ask for all the
mammals, and get back the cats

00:10:33.350 --> 00:10:35.540
and the dogs, but
not the lizards.

00:10:35.540 --> 00:10:36.710
Partial indexes.

00:10:36.710 --> 00:10:38.190
Parallel transactions.

00:10:38.190 --> 00:10:40.470
Embedded objects and
collections.

00:10:40.470 --> 00:10:41.650
Serialized object graphs.

00:10:41.650 --> 00:10:43.770
And then two things that
really I use a lot.

00:10:43.770 --> 00:10:46.190
A lot.

00:10:46.190 --> 00:10:47.270
Automatic memcaching.

00:10:47.270 --> 00:10:49.880
So if you just put a little
annotation, @cached, on your

00:10:49.880 --> 00:10:51.810
entities, they'll automatically
be pulled

00:10:51.810 --> 00:10:54.440
efficiently in and out
of the memchache.

00:10:54.440 --> 00:10:59.300
And a set of tools which we've
sort of worked out over time

00:10:59.300 --> 00:11:03.250
are necessary to make fairly
radical schema changes.

00:11:03.250 --> 00:11:06.730
They allow you to make fairly
radical schema changes without

00:11:06.730 --> 00:11:10.370
experiencing any downtime
whatsoever.

00:11:10.370 --> 00:11:14.250
And with that, I will hand off
to the next presenter.

00:11:23.580 --> 00:11:25.760
DAVID CHANDLER: Thanks
very much, Jeff.

00:11:25.760 --> 00:11:27.750
So let's talk about the
middle layer now.

00:11:27.750 --> 00:11:33.290
In 2.1, GWT put out a new RPC
layer called RequestFactory.

00:11:33.290 --> 00:11:36.120
And I want to use this time to
introduce RequestFactory to

00:11:36.120 --> 00:11:38.750
you, and then also show you
how it can be used with

00:11:38.750 --> 00:11:42.960
Objectify in a GWT
application.

00:11:42.960 --> 00:11:46.700
So there are four ways
of doing RPC in GWT.

00:11:46.700 --> 00:11:49.610
We've had for a long time the
RequestBuilder with either the

00:11:49.610 --> 00:11:51.950
XMLParser or the JSONParser.

00:11:51.950 --> 00:11:56.240
So you can connect to any XML
or JSON feed via XML HTTP

00:11:56.240 --> 00:12:00.320
request. There's GWT RPC which
allows you to send and receive

00:12:00.320 --> 00:12:03.370
POJOs on the wire and
automatically handles the

00:12:03.370 --> 00:12:05.620
serialization and
deserialization.

00:12:05.620 --> 00:12:08.260
And most recently, we've
introduced RequestFactory.

00:12:08.260 --> 00:12:10.900
And you might ask, well why
did we need another RPC

00:12:10.900 --> 00:12:12.450
framework in GWT?

00:12:12.450 --> 00:12:16.100
A lot of people are using
GWT RPC very happily.

00:12:16.100 --> 00:12:19.470
And the answer is there's a few
limitations or problems,

00:12:19.470 --> 00:12:20.820
especially when you
get the larger

00:12:20.820 --> 00:12:23.470
applications using GWT RPC.

00:12:23.470 --> 00:12:27.630
One of them is that GWT RPC
creates a custom serializer

00:12:27.630 --> 00:12:30.370
and deserializer
for each class.

00:12:30.370 --> 00:12:30.680
Sorry.

00:12:30.680 --> 00:12:31.330
Not custom.

00:12:31.330 --> 00:12:32.940
It automatically generates it.

00:12:32.940 --> 00:12:34.600
But there's one per class.

00:12:34.600 --> 00:12:36.920
So if you have a lot of classes
that you're sending

00:12:36.920 --> 00:12:40.080
and receiving over the wire,
you're going to get a lot of

00:12:40.080 --> 00:12:42.080
extra Java script
to do all that.

00:12:42.080 --> 00:12:43.830
Serialize, deserialize.

00:12:43.830 --> 00:12:46.030
And this can also lead to what
we call accidental type

00:12:46.030 --> 00:12:49.830
explosions, where because it
supports polymorphism, if you

00:12:49.830 --> 00:12:53.930
use an interface type like List,
and send that over the

00:12:53.930 --> 00:12:58.570
wire, GWT RPC has to create a
serializer and deserializer

00:12:58.570 --> 00:13:01.580
for array lists, linked
lists and all the

00:13:01.580 --> 00:13:04.090
concrete types of lists.

00:13:04.090 --> 00:13:06.720
So that adds to compile time as
well as to the size of your

00:13:06.720 --> 00:13:08.450
resulting Java script.

00:13:08.450 --> 00:13:10.950
And finally, we've been talking
in recent years about

00:13:10.950 --> 00:13:13.880
the command pattern and
recommending the use of that

00:13:13.880 --> 00:13:15.270
in GWT applications.

00:13:15.270 --> 00:13:17.190
And GWT RPC doesn't support
it directly.

00:13:17.190 --> 00:13:19.910
Now there are excellent
frameworks like gwt-dispatch

00:13:19.910 --> 00:13:23.150
that do implement the command
pattern in GWT RPC.

00:13:23.150 --> 00:13:27.060
But it's a little heavy
class-wise, as we'll see here.

00:13:27.060 --> 00:13:30.070
And it's not built in.

00:13:30.070 --> 00:13:34.410
So RequestFactory neither uses
nor replaces GWT RPC.

00:13:34.410 --> 00:13:37.280
It is it's own thing entirely.

00:13:37.280 --> 00:13:39.790
It's actually based on JSON
under the covers.

00:13:39.790 --> 00:13:43.680
But we have our own protocol
that we add on top of that.

00:13:43.680 --> 00:13:46.150
It's designed for data-oriented
services.

00:13:46.150 --> 00:13:47.960
So it's especially
well-suited for

00:13:47.960 --> 00:13:50.770
persistence layer type services.

00:13:50.770 --> 00:13:56.030
It doesn't have to be, but it
has that concept in mind.

00:13:56.030 --> 00:13:57.900
It acknowledges the
DTO problem.

00:13:57.900 --> 00:14:02.400
So one of the things that
faces developers--

00:14:02.400 --> 00:14:05.200
when you try to send your
objects from server to client,

00:14:05.200 --> 00:14:07.160
there's a lot of your
server-side energies whether

00:14:07.160 --> 00:14:10.670
they be JPA, JPO or Objectify
or something else, they're

00:14:10.670 --> 00:14:14.300
going to have annotations in
them that have meaning for the

00:14:14.300 --> 00:14:15.920
server-side framework.

00:14:15.920 --> 00:14:19.910
But GWT is a Java to Java
script compiler.

00:14:19.910 --> 00:14:23.010
So in order to do that Java
script compilation, we have to

00:14:23.010 --> 00:14:26.630
have the Java source for
every bit of Java code.

00:14:26.630 --> 00:14:30.180
Well, the GWT compiler doesn't
know about the Java source for

00:14:30.180 --> 00:14:34.260
JPA, JDO and Objectify,
for example.

00:14:34.260 --> 00:14:37.490
So you wouldn't be able to
serialize those objects

00:14:37.490 --> 00:14:39.970
properly and send it
back and forth.

00:14:39.970 --> 00:14:41.500
So there's several
ways around this.

00:14:41.500 --> 00:14:44.510
One is to use GWT's supersource
capability.

00:14:44.510 --> 00:14:48.220
And Objectify actually
supports that.

00:14:48.220 --> 00:14:52.130
There's other frameworks like
Gilead or Hibernate that will

00:14:52.130 --> 00:14:55.470
make GWT aware of the source
even though it's not the

00:14:55.470 --> 00:14:57.020
actual server source.

00:14:57.020 --> 00:15:00.470
It'll make GWT think it has the
source for an annotation,

00:15:00.470 --> 00:15:02.560
say, so that it can be
used on the client.

00:15:02.560 --> 00:15:03.660
And that's nice.

00:15:03.660 --> 00:15:05.760
It's very convenient,
because then you can

00:15:05.760 --> 00:15:07.390
send the same object.

00:15:07.390 --> 00:15:09.940
Just have one representation
of your entity, and send it

00:15:09.940 --> 00:15:11.580
back and forth.

00:15:11.580 --> 00:15:12.650
But there are some difficulties

00:15:12.650 --> 00:15:14.210
with that as well.

00:15:14.210 --> 00:15:16.740
There have been recent changes
to the App Engine datastore

00:15:16.740 --> 00:15:19.070
key structure which make
that more difficult.

00:15:19.070 --> 00:15:24.280
And also you can get--

00:15:24.280 --> 00:15:26.220
sorry, I lost my train
of thought there.

00:15:26.220 --> 00:15:28.720
There's some kinds of
server-side activities which

00:15:28.720 --> 00:15:32.030
you just may not ever be able
to represent in GWT.

00:15:32.030 --> 00:15:35.840
And so at some point, you
may have to use DTOs.

00:15:35.840 --> 00:15:37.440
So what's the problem
with DTOs?

00:15:37.440 --> 00:15:41.090
The problem is that now you have
two representations of

00:15:41.090 --> 00:15:42.810
your entity, which is a pain.

00:15:42.810 --> 00:15:46.340
And also, you have to manually
copy on the server side.

00:15:46.340 --> 00:15:50.880
When a request comes in, you
have to copy from the DTO to

00:15:50.880 --> 00:15:51.840
the real server entity.

00:15:51.840 --> 00:15:53.680
And then, when it goes back
out, you have to copy the

00:15:53.680 --> 00:15:55.760
properties from the real server
entity back to the DTO.

00:15:55.760 --> 00:15:58.880
There's a lot of boilerplate
type stuff

00:15:58.880 --> 00:16:00.390
required to do that.

00:16:00.390 --> 00:16:03.970
So RequestFactory acknowledges
this problem.

00:16:03.970 --> 00:16:07.850
And it uses a DTO pattern, but
in a very light-weight way.

00:16:07.850 --> 00:16:10.290
What we do is allow you to
find an interface on the

00:16:10.290 --> 00:16:13.400
client side that represents
your entity.

00:16:13.400 --> 00:16:16.590
And so you only have to worry
about the signature, if you

00:16:16.590 --> 00:16:17.400
will, of the entity.

00:16:17.400 --> 00:16:19.040
Just the getters and setters.

00:16:19.040 --> 00:16:21.180
And then the RequestFactory
code takes care of

00:16:21.180 --> 00:16:24.640
automatically instantiating that
interface and populating

00:16:24.640 --> 00:16:27.080
all the getters and setters
for you so that you're not

00:16:27.080 --> 00:16:31.650
having to do that tedious
type of copy code.

00:16:31.650 --> 00:16:33.810
So that's one benefit.

00:16:33.810 --> 00:16:36.380
Another one is that
RequestFactory is at a higher

00:16:36.380 --> 00:16:37.600
level of abstraction.

00:16:37.600 --> 00:16:39.420
So you can use the
command pattern.

00:16:39.420 --> 00:16:41.460
It's built in with the
request object.

00:16:41.460 --> 00:16:43.110
It already provides batching.

00:16:43.110 --> 00:16:46.720
In 2.3, you can batch requests
within services.

00:16:46.720 --> 00:16:48.740
And in 2.4, you'll actually
be able to batch

00:16:48.740 --> 00:16:50.940
across services as well.

00:16:50.940 --> 00:16:55.510
We enabled the RPC persistence
layers to be created with

00:16:55.510 --> 00:16:58.310
minimal boilerplate as you'll
see here this morning.

00:16:58.310 --> 00:17:00.900
And then RequestFactory also
tracks changes to your

00:17:00.900 --> 00:17:03.570
entities on the client
side, and it sends

00:17:03.570 --> 00:17:06.270
only difs to the server.

00:17:06.270 --> 00:17:09.839
So some payload shrinkage
becomes

00:17:09.839 --> 00:17:12.670
possible because of that.

00:17:12.670 --> 00:17:15.220
Also now, we're happy to
announce that RequestFactory

00:17:15.220 --> 00:17:16.420
has gone mobile.

00:17:16.420 --> 00:17:18.849
And you can write one
RequestFactory service

00:17:18.849 --> 00:17:22.810
implementation, post it on App
Engine or some other platform,

00:17:22.810 --> 00:17:26.119
and consume that service from
both a GWT client as well as a

00:17:26.119 --> 00:17:27.900
native Android client.

00:17:27.900 --> 00:17:30.590
And to facilitate that, we've
moved RequestFactory out from

00:17:30.590 --> 00:17:32.870
underneath the GWT package
structure into

00:17:32.870 --> 00:17:36.140
com.google.web.binary so
it can be shared by

00:17:36.140 --> 00:17:37.710
Android code as well.

00:17:37.710 --> 00:17:39.520
And we think that's going to
be attractive for a lot of

00:17:39.520 --> 00:17:43.280
people in the near term who
still need a richer user

00:17:43.280 --> 00:17:46.310
experience than you can get
with a GWT app on mobile.

00:17:46.310 --> 00:17:49.010
Although we're improving
that as fast as we can.

00:17:49.010 --> 00:17:51.140
But if you have a native
app this makes it easy.

00:17:51.140 --> 00:17:55.195
At least you only have write
your service side once.

00:17:55.195 --> 00:17:57.840
So let's take a look at what it
takes to get started with

00:17:57.840 --> 00:17:59.340
RequestFactory here.

00:17:59.340 --> 00:18:02.330
First of all, in your gwt.xml,
you need an inherits to bring

00:18:02.330 --> 00:18:03.550
in the module.

00:18:03.550 --> 00:18:04.940
You have to map the
RequestFactory

00:18:04.940 --> 00:18:07.920
servlet in your web.xml.

00:18:07.920 --> 00:18:10.540
And then, what you're going to
do is create DTO interfaces

00:18:10.540 --> 00:18:13.370
representing all your entities
and value types.

00:18:13.370 --> 00:18:15.120
We'll talk about that
in a second.

00:18:15.120 --> 00:18:17.370
You'll have your service stubs
just like in GWT RPC.

00:18:17.370 --> 00:18:19.170
It's just an interface.

00:18:19.170 --> 00:18:22.660
You have RequestFactory class
which extends the GWT

00:18:22.660 --> 00:18:25.360
RequestFactory interface, and
that's what ties it together

00:18:25.360 --> 00:18:27.440
and tells about all
your services.

00:18:27.440 --> 00:18:31.550
And then finally to make it all
happen you just GWT.create

00:18:31.550 --> 00:18:34.860
your RequestFactory class.

00:18:34.860 --> 00:18:38.125
So let's talk about some
concepts, terminology, define

00:18:38.125 --> 00:18:38.850
some terms here.

00:18:38.850 --> 00:18:42.150
An entity is something that
has ID inversion.

00:18:42.150 --> 00:18:44.570
So it's probably like
a car in a fleet

00:18:44.570 --> 00:18:46.360
represented in a database.

00:18:46.360 --> 00:18:50.390
And it's likely represented
by a row in a table.

00:18:50.390 --> 00:18:53.330
A value type would be more like
a column in the table.

00:18:53.330 --> 00:18:56.610
It's something that doesn't have
ID inversion, maybe the

00:18:56.610 --> 00:18:58.830
color of the car.

00:18:58.830 --> 00:19:02.550
A proxy type is a RequestFactory
term for the

00:19:02.550 --> 00:19:05.900
interface that you create on the
client side to represent

00:19:05.900 --> 00:19:09.640
one of these server side
entities or value types.

00:19:09.640 --> 00:19:12.790
And the proxy types are shared
between the client and server.

00:19:12.790 --> 00:19:15.810
And as we'll see in a moment,
they're in a shared package.

00:19:15.810 --> 00:19:20.560
The RequestFactory code in GWT
automatically creates and

00:19:20.560 --> 00:19:23.780
tracks instances of your
interfaces using the new

00:19:23.780 --> 00:19:25.190
AutoBeans framework.

00:19:25.190 --> 00:19:27.750
And this is available to
use for other purposes

00:19:27.750 --> 00:19:29.660
if you want in GWT.

00:19:29.660 --> 00:19:31.940
But it happens to be
the plumbing behind

00:19:31.940 --> 00:19:33.570
RequestFactory.

00:19:33.570 --> 00:19:36.900
A little bit about what this
means is that RequestFactory

00:19:36.900 --> 00:19:39.890
will actually create an instance
of an interface.

00:19:39.890 --> 00:19:40.650
OK, wait.

00:19:40.650 --> 00:19:42.150
How can you do that?

00:19:42.150 --> 00:19:44.190
And you could do it using an
anonymous interclass or

00:19:44.190 --> 00:19:45.880
something, but that's not
what I'm talking about.

00:19:45.880 --> 00:19:48.310
You'll see in a minute, you can
just call Service.create,

00:19:48.310 --> 00:19:49.510
and give it your
interface type.

00:19:49.510 --> 00:19:52.570
And you'll get back an instance
of that interface.

00:19:52.570 --> 00:19:56.400
Because RequestFactory actually
creates the instance,

00:19:56.400 --> 00:19:58.925
it can register visitors.

00:19:58.925 --> 00:20:02.520
It supports the visitor pattern
on your instance.

00:20:02.520 --> 00:20:04.900
And so it knows whenever
a setter has been

00:20:04.900 --> 00:20:07.440
called on your entity.

00:20:07.440 --> 00:20:10.090
And because it is able to know
when the setters have been

00:20:10.090 --> 00:20:12.110
called, it can determine
when there's changes.

00:20:12.110 --> 00:20:14.560
And this in fact is what allows
RequestFactory to keep

00:20:14.560 --> 00:20:18.260
track of changes, and send only
changes the the client.

00:20:18.260 --> 00:20:20.910
So by giving RequestFactory
control of creating your

00:20:20.910 --> 00:20:26.120
instances, you're allowing it
to do smart things for you.

00:20:26.120 --> 00:20:29.420
Then finally, a service stub is
just our service interface

00:20:29.420 --> 00:20:33.240
analogous to our remote service
class and GWT RPC.

00:20:33.240 --> 00:20:36.100
In RequestFactory, it's called
RequestContext--

00:20:36.100 --> 00:20:39.610
is the class that
you'll extend.

00:20:39.610 --> 00:20:41.000
So on the server side--

00:20:41.000 --> 00:20:42.610
and I'm trying a little
color coding

00:20:42.610 --> 00:20:44.080
experiment here this morning.

00:20:44.080 --> 00:20:46.870
I apologize if you're red/green
color blind.

00:20:46.870 --> 00:20:49.930
But we'll try to use position
to indicate it as well.

00:20:49.930 --> 00:20:53.070
But you can remember RGB,
server, shared, client.

00:20:53.070 --> 00:20:54.350
RGB going across.

00:20:54.350 --> 00:20:56.260
So on the server
things are red.

00:20:56.260 --> 00:20:58.930
This is where we're going to
have our entities and our

00:20:58.930 --> 00:21:00.460
service implementations.

00:21:00.460 --> 00:21:02.470
We'll also have something called
locators, which we'll

00:21:02.470 --> 00:21:04.380
talk about a little bit later.

00:21:04.380 --> 00:21:06.680
In the middle, we have
the shared package.

00:21:06.680 --> 00:21:09.080
And this is all just
interfaces.

00:21:09.080 --> 00:21:11.750
And then our actual client code
that calls RequestFactory

00:21:11.750 --> 00:21:16.720
services is in blue
on the right.

00:21:16.720 --> 00:21:20.980
So let's look at an example of
an entity and entity proxy.

00:21:20.980 --> 00:21:25.100
On the left, we have a named
list. This is an entity that

00:21:25.100 --> 00:21:27.100
uses Objectify annotations.

00:21:27.100 --> 00:21:31.060
So we have the @entity
and @ID in it.

00:21:31.060 --> 00:21:33.160
It lives on the server
side of things.

00:21:33.160 --> 00:21:36.340
And it has some code in it which
is not understandable by

00:21:36.340 --> 00:21:37.940
GWT on the client.

00:21:37.940 --> 00:21:42.720
Namely, that key type there,
which wouldn't be transferable

00:21:42.720 --> 00:21:45.950
across the wire.

00:21:45.950 --> 00:21:48.780
Notice that the proxy now
lives on the right side.

00:21:48.780 --> 00:21:51.250
NamedListProxy is just
an interface.

00:21:51.250 --> 00:21:54.410
Interface NamedListProxy
extends EntityProxy.

00:21:54.410 --> 00:21:57.990
And it basically just defines
the public signature of our

00:21:57.990 --> 00:21:59.640
entity on the client side.

00:21:59.640 --> 00:22:01.860
So just the getters
and setters.

00:22:01.860 --> 00:22:06.930
And you can notice also that
the proxy has to refer to

00:22:06.930 --> 00:22:08.750
other proxy types.

00:22:08.750 --> 00:22:12.240
So instead of referring to an
app user, which would be a

00:22:12.240 --> 00:22:15.850
server-side entity, it has
to refer to AppUserProxy.

00:22:15.850 --> 00:22:17.680
Instead of referring to
ListItem it refers to

00:22:17.680 --> 00:22:19.120
ListItemProxy.

00:22:19.120 --> 00:22:21.750
So everything on the client
side you're going to add

00:22:21.750 --> 00:22:24.290
proxy, generally, when creating
your interfaces.

00:22:24.290 --> 00:22:26.930
RequestFactory automatically
takes care of converting

00:22:26.930 --> 00:22:29.140
between the proxy types
and the real types

00:22:29.140 --> 00:22:31.220
on the server side.

00:22:31.220 --> 00:22:36.680
Notice that our entity proxy on
the right side also has a

00:22:36.680 --> 00:22:38.480
ProxyFor annotation.

00:22:38.480 --> 00:22:41.980
This is how you tell it which
server-side class it

00:22:41.980 --> 00:22:43.120
represents.

00:22:43.120 --> 00:22:46.330
In this case it's NamedList and
it also has a locator here

00:22:46.330 --> 00:22:48.990
which we'll talk about
in a second.

00:22:48.990 --> 00:22:52.760
So all of your built-in value
types, basically String and

00:22:52.760 --> 00:22:56.380
your primitive wrapper types in
Java like String, Integer,

00:22:56.380 --> 00:22:58.450
Ebullient, et cetera,
are automatically

00:22:58.450 --> 00:22:59.980
handled by GWT RPC.

00:22:59.980 --> 00:23:02.100
You don't have to write
anything special.

00:23:02.100 --> 00:23:03.860
Enums are also supported.

00:23:03.860 --> 00:23:06.340
So in our proxy interface here
we've defined an enum

00:23:06.340 --> 00:23:09.080
ListType, NOTES and TODO.

00:23:09.080 --> 00:23:11.330
And we don't have to do anything
special to serialize

00:23:11.330 --> 00:23:12.910
that across the wire.

00:23:12.910 --> 00:23:15.700
It does not have to be located
in the proxy type.

00:23:15.700 --> 00:23:20.650
It can be located anywhere
in a shared package.

00:23:20.650 --> 00:23:25.490
And on the server-side,
RequestFactory just ignores

00:23:25.490 --> 00:23:26.540
the annotations.

00:23:26.540 --> 00:23:28.900
RequestFactory itself isn't
concerned with that.

00:23:28.900 --> 00:23:33.390
Those are purely there for
Objectify in this case.

00:23:33.390 --> 00:23:37.220
And then finally, notice that
we can send an embedded list

00:23:37.220 --> 00:23:41.620
of items. So we're using the
embedded annotation to send a

00:23:41.620 --> 00:23:45.020
list of items. And what that
will do is store the items in

00:23:45.020 --> 00:23:48.160
our list along with the
list in the datastore.

00:23:48.160 --> 00:23:50.530
This is the Objectify
annotation.

00:23:50.530 --> 00:23:53.170
It's a powerful feature to be
able to store things together

00:23:53.170 --> 00:23:56.680
as a package in datastore.

00:23:56.680 --> 00:23:59.820
So that is an entity proxy.

00:23:59.820 --> 00:24:01.180
Fairly simple.

00:24:01.180 --> 00:24:03.110
Just an interface.

00:24:03.110 --> 00:24:06.490
ValueProxy is even simpler
because value types don't have

00:24:06.490 --> 00:24:08.000
ID inversion.

00:24:08.000 --> 00:24:12.410
So here, a list item, which
is being included in the

00:24:12.410 --> 00:24:16.170
collection of items in our
entity, just has a ProxyFor

00:24:16.170 --> 00:24:20.060
annotation that identifies
the server-side class.

00:24:20.060 --> 00:24:23.170
And note also that we can
use @ProxyFor for name.

00:24:23.170 --> 00:24:25.850
So if you do @ProxyFor it's
actually looking for the Java

00:24:25.850 --> 00:24:28.050
type, which means that
Java type has to be

00:24:28.050 --> 00:24:29.090
on your class path.

00:24:29.090 --> 00:24:31.470
But a lot of projects,
especially larger ones, will

00:24:31.470 --> 00:24:34.090
split their GWT projects into
two separate projects, one

00:24:34.090 --> 00:24:35.585
containing the client side
and one containing

00:24:35.585 --> 00:24:37.200
the server-side code.

00:24:37.200 --> 00:24:40.630
So you may not have the
server-side types on your

00:24:40.630 --> 00:24:42.220
class path in the client.

00:24:42.220 --> 00:24:44.990
And if that's the case, you can
use ProxyForName, give it

00:24:44.990 --> 00:24:48.650
a fully qualified class path
as a string and then

00:24:48.650 --> 00:24:51.590
RequestFactory will be able to
find it still at run time.

00:24:55.900 --> 00:24:56.070
OK.

00:24:56.070 --> 00:24:58.540
Let's look at our service
definitions now.

00:24:58.540 --> 00:25:00.970
The service stub you see at the
bottom we're defining a

00:25:00.970 --> 00:25:02.585
NamedListService.

00:25:02.585 --> 00:25:07.650
And this is just a basic CRUD
service for our list object.

00:25:07.650 --> 00:25:10.580
It references the service IMPL,
which in this case is

00:25:10.580 --> 00:25:13.340
called NamedListDAO, because
it happens to be

00:25:13.340 --> 00:25:15.130
a data access object.

00:25:15.130 --> 00:25:18.590
And we have a locator
we'll talk about.

00:25:18.590 --> 00:25:21.270
It just extends the
RequestContext interface.

00:25:21.270 --> 00:25:24.970
And then all of the types
return, all of the methods,

00:25:24.970 --> 00:25:27.640
return request objects.

00:25:27.640 --> 00:25:29.550
This is what supports the
command pattern in

00:25:29.550 --> 00:25:30.980
RequestFactory.

00:25:30.980 --> 00:25:33.740
And then the request object is
parameterized with the real

00:25:33.740 --> 00:25:35.120
return type.

00:25:35.120 --> 00:25:38.750
So on the server your
implementation of this service

00:25:38.750 --> 00:25:42.030
is going to return a list
of named lists.

00:25:42.030 --> 00:25:45.820
But the client interface has to
say Request parameterized

00:25:45.820 --> 00:25:48.176
with List of NamedListProxy.

00:25:48.176 --> 00:25:50.830
So there's a little mapping
going on there.

00:25:50.830 --> 00:25:52.970
And we're going to be bringing
out tooling in Google Plugin

00:25:52.970 --> 00:25:57.530
for Eclipse that will give you
warnings when your server

00:25:57.530 --> 00:26:00.370
interfaces, or your IMPLs,
don't match your

00:26:00.370 --> 00:26:00.870
interfaces, et cetera.

00:26:00.870 --> 00:26:03.550
Right now, that's a weakness
of this is that you have to

00:26:03.550 --> 00:26:05.290
manually keep those
things in sync.

00:26:05.290 --> 00:26:07.470
You'll get run time exceptions
if they don't match.

00:26:13.570 --> 00:26:15.310
Oh sorry.

00:26:15.310 --> 00:26:17.300
So at the top, we see
the RequestFactory.

00:26:17.300 --> 00:26:18.990
This is what ties
it all together.

00:26:18.990 --> 00:26:21.560
If we define multiple services,
then we would have

00:26:21.560 --> 00:26:23.850
an accessor method for
each one in our

00:26:23.850 --> 00:26:25.690
RequestFactory interface.

00:26:25.690 --> 00:26:28.550
Here, for compactness,
we only have one.

00:26:28.550 --> 00:26:31.090
And this is just a marker
interface that let's

00:26:31.090 --> 00:26:33.820
RequestFactory know it has
to write some code

00:26:33.820 --> 00:26:35.360
for all these services.

00:26:37.880 --> 00:26:39.790
So how do we use it?

00:26:39.790 --> 00:26:41.890
Well, once we've defined our
interfaces and our proxy

00:26:41.890 --> 00:26:45.600
types, we do a GWT.create
on the RequestFactory.

00:26:45.600 --> 00:26:49.340
This causes GWT to run a bunch
of generators which generate

00:26:49.340 --> 00:26:51.600
the actual code that's
going to make the

00:26:51.600 --> 00:26:54.130
service calls, et cetera.

00:26:54.130 --> 00:26:58.070
We create our entity using the
Service.create method that's

00:26:58.070 --> 00:27:00.420
on the RequestContext
interface.

00:27:00.420 --> 00:27:05.450
We give it our proxy type, and
we'll get back an instance of

00:27:05.450 --> 00:27:05.970
that object.

00:27:05.970 --> 00:27:09.810
So in this case a taskProxy.

00:27:09.810 --> 00:27:11.680
We can then call its setters.

00:27:11.680 --> 00:27:15.010
And then call our method
to persist the task.

00:27:15.010 --> 00:27:16.310
That would be a method
that we defined

00:27:16.310 --> 00:27:17.990
in our service interface.

00:27:17.990 --> 00:27:19.520
And then finally, fire it.

00:27:19.520 --> 00:27:24.270
And fire it is equivalent to
your async call in GWT RPC.

00:27:24.270 --> 00:27:26.800
This is what actually makes
the call to the server.

00:27:26.800 --> 00:27:29.390
And just like GWT RPC
you had to pass an

00:27:29.390 --> 00:27:30.800
async callback object.

00:27:30.800 --> 00:27:32.580
Here we pass a receiver.

00:27:32.580 --> 00:27:36.550
That's RequestFactory's
terminology for your callback.

00:27:36.550 --> 00:27:39.590
And it has onSuccess, onFailure
and onViolation

00:27:39.590 --> 00:27:43.600
methods similar to GWT RPC.

00:27:43.600 --> 00:27:46.220
Finally, note that when you've
made a call to the server and

00:27:46.220 --> 00:27:49.820
you get data back, then there
are entity proxy change events

00:27:49.820 --> 00:27:53.730
that get fired if RequestFactory
determines that

00:27:53.730 --> 00:27:55.520
something has changed
on the server.

00:27:55.520 --> 00:28:01.020
And this is why entities have
the concept of ID and version

00:28:01.020 --> 00:28:02.600
in RequestFactory.

00:28:02.600 --> 00:28:04.330
So you can update the version.

00:28:04.330 --> 00:28:05.750
You're responsible to
update the version

00:28:05.750 --> 00:28:07.360
on the server side.

00:28:07.360 --> 00:28:10.980
And when RequestFactory is
returning a response and it

00:28:10.980 --> 00:28:13.390
detects that the version has
changed, say from three to

00:28:13.390 --> 00:28:16.640
four, then it will trigger this
entity proxy change event

00:28:16.640 --> 00:28:17.780
on the client.

00:28:17.780 --> 00:28:20.635
So you can listen for that in
your presenters or widgets or

00:28:20.635 --> 00:28:23.230
other classes to make
updates to the UI.

00:28:27.402 --> 00:28:27.890
OK.

00:28:27.890 --> 00:28:30.010
So let's look at some code,
how it all works together.

00:28:30.010 --> 00:28:33.960
This is a method that will
create a new list object and

00:28:33.960 --> 00:28:35.860
persist it on the server.

00:28:35.860 --> 00:28:39.770
So we do reqCtx.create give it
our interface type, call the

00:28:39.770 --> 00:28:42.400
setters, and then save
and return is our

00:28:42.400 --> 00:28:43.990
method on the service.

00:28:43.990 --> 00:28:45.070
We fire it.

00:28:45.070 --> 00:28:46.470
We pass it a receiver.

00:28:46.470 --> 00:28:49.620
And we implement the onSuccess
method that will do something.

00:28:49.620 --> 00:28:52.570
In this case we're updating a
data table with our new cell

00:28:52.570 --> 00:28:53.820
table structure.

00:28:56.530 --> 00:28:58.540
Notice that we only
have to implement

00:28:58.540 --> 00:29:00.090
the onSuccess method.

00:29:00.090 --> 00:29:02.660
With GWT RPC, you also
had to do onFailure.

00:29:02.660 --> 00:29:07.830
There's DefaultHandler for
failure in RequestFactory.

00:29:07.830 --> 00:29:09.410
So we don't have to do that.

00:29:09.410 --> 00:29:13.100
But you can always of course
wrap the receiver object.

00:29:13.100 --> 00:29:16.480
You can extend it and provide
a default implementation of

00:29:16.480 --> 00:29:22.950
your own for onFailure
or any other method.

00:29:22.950 --> 00:29:23.240
OK.

00:29:23.240 --> 00:29:24.410
Here's an update.

00:29:24.410 --> 00:29:25.620
Now, this is important.

00:29:25.620 --> 00:29:28.740
When something comes back from
the server with RequestFactory

00:29:28.740 --> 00:29:30.320
it is immutable.

00:29:30.320 --> 00:29:31.620
It cannot be changed.

00:29:31.620 --> 00:29:34.680
And in order to tell
RequestFactory that you want

00:29:34.680 --> 00:29:37.170
to make changes to it, because
remember we want to track

00:29:37.170 --> 00:29:39.390
those changes, you have
to call the method

00:29:39.390 --> 00:29:40.980
explicitly to do that.

00:29:40.980 --> 00:29:45.280
So you're going to call
reqCtx.edit and pass it the

00:29:45.280 --> 00:29:48.030
object that you got
from the server.

00:29:48.030 --> 00:29:49.150
And that makes it editable.

00:29:49.150 --> 00:29:50.910
You can then call
the setters and

00:29:50.910 --> 00:29:59.290
fire a request. OK.

00:29:59.290 --> 00:30:00.490
Let's look at a query.

00:30:00.490 --> 00:30:03.890
This one is going to receive
back the list of objects from

00:30:03.890 --> 00:30:04.860
the server.

00:30:04.860 --> 00:30:07.750
And it calls the listAll method
and then you'll notice

00:30:07.750 --> 00:30:09.770
there's this dot with.

00:30:09.770 --> 00:30:12.810
So one of the issues with GWT
RPC was that it would

00:30:12.810 --> 00:30:16.780
automatically bring back
a whole object graph.

00:30:16.780 --> 00:30:19.710
And as your object graphs become
large, this can be

00:30:19.710 --> 00:30:20.260
problematic.

00:30:20.260 --> 00:30:21.710
Especially in Internet
Explorer.

00:30:21.710 --> 00:30:25.070
There's various bugs and issues
you can find on that.

00:30:25.070 --> 00:30:29.170
So with RequestFactory, we
wanted to give you control

00:30:29.170 --> 00:30:32.730
over exactly which properties
in the object graph you want

00:30:32.730 --> 00:30:33.800
to bring back.

00:30:33.800 --> 00:30:35.890
So to do that you use
the dot with.

00:30:35.890 --> 00:30:39.170
And you just specify the names
of the properties that you

00:30:39.170 --> 00:30:40.150
want to retrieve.

00:30:40.150 --> 00:30:43.360
So you can specify a comma
separated list, and you can

00:30:43.360 --> 00:30:46.270
also use dot notation to drill
down more deeply into your

00:30:46.270 --> 00:30:47.290
object graph.

00:30:47.290 --> 00:30:50.290
And it'll walk that and bring
back only those items.

00:30:50.290 --> 00:30:54.350
So this is required to bring
back any proxy types.

00:30:54.350 --> 00:30:56.760
Any entity-related
DTO property.

00:30:56.760 --> 00:31:00.220
So entityProxy or valueProxy,
you have to use dot with.

00:31:00.220 --> 00:31:03.680
If you don't all you're going
to get back is the built-in

00:31:03.680 --> 00:31:07.120
value types like the String
and Integer properties for

00:31:07.120 --> 00:31:08.370
your entities.

00:31:11.590 --> 00:31:14.380
So a little bit more
RequestFactory goodness here.

00:31:14.380 --> 00:31:16.700
Validation is supported now
on the server side.

00:31:16.700 --> 00:31:20.350
You can annotate your entities
with the JSR303 Bean

00:31:20.350 --> 00:31:23.920
validation annotations like
@NotNull and Length.

00:31:23.920 --> 00:31:27.890
And prior to invoking a service
method RequestFactory

00:31:27.890 --> 00:31:31.440
will call the validation API,
will validate all the

00:31:31.440 --> 00:31:38.270
entities, and will return any
validation violation to the

00:31:38.270 --> 00:31:40.350
client, and then you can
handle them in your

00:31:40.350 --> 00:31:41.910
onViolation method.

00:31:41.910 --> 00:31:44.480
That would give you a set of
constraint violations that you

00:31:44.480 --> 00:31:45.820
can handle.

00:31:45.820 --> 00:31:48.350
So this happens before
any action is taken.

00:31:48.350 --> 00:31:50.280
If there are violation
constraints then

00:31:50.280 --> 00:31:53.180
RequestFactory will just abort
the action and won't actually

00:31:53.180 --> 00:31:57.530
invoke the method on
the server side.

00:31:57.530 --> 00:31:59.650
Some more goodies here are the
new editor framework, which

00:31:59.650 --> 00:32:01.330
unfortunately we don't
have time to go into

00:32:01.330 --> 00:32:02.390
this morning in depth.

00:32:02.390 --> 00:32:05.220
But with editors you can
do data binding.

00:32:05.220 --> 00:32:07.970
So this automates the process
of getting information from

00:32:07.970 --> 00:32:10.900
the view to your model
and vice versa.

00:32:10.900 --> 00:32:13.940
The boilerplate type of code
that's usually required there.

00:32:13.940 --> 00:32:17.450
There's a good sample app for
this in the DynaTableRF.

00:32:17.450 --> 00:32:21.760
And basically, the editor will
take away a little bit more of

00:32:21.760 --> 00:32:26.220
the boilerplate code common for
updating persistence UIs.

00:32:26.220 --> 00:32:29.200
It will also automatically give
you the property list for

00:32:29.200 --> 00:32:31.060
your dot with clause.

00:32:31.060 --> 00:32:32.880
So you don't have to manually
specify that.

00:32:32.880 --> 00:32:35.090
It will infer that from the
things have been changed in

00:32:35.090 --> 00:32:39.360
the UI, and then sends dot with
with all those properties

00:32:39.360 --> 00:32:41.040
listed to the server.

00:32:44.150 --> 00:32:45.190
So putting it together now.

00:32:45.190 --> 00:32:48.120
Let's look at how you can use
RequestFactory with Objectify

00:32:48.120 --> 00:32:52.510
to build a pretty light-weight
persistence layer in GWT.

00:32:52.510 --> 00:32:56.120
You can annotate your entities
with Objectify.

00:32:56.120 --> 00:32:59.970
Define your entity proxy
interfaces on the client.

00:32:59.970 --> 00:33:04.130
And then, the cool part is we
can expose our DAOs directly

00:33:04.130 --> 00:33:07.310
as RequestFactory services.

00:33:07.310 --> 00:33:09.420
So if you think about what
you've done with the command

00:33:09.420 --> 00:33:12.790
pattern, maybe using
gwt-dispatch or something, the

00:33:12.790 --> 00:33:15.600
command pattern can be
kind of verbose.

00:33:15.600 --> 00:33:19.080
So you have action and a result
for each command which

00:33:19.080 --> 00:33:21.780
corresponds to one method
on a service.

00:33:21.780 --> 00:33:25.160
Then you also have an action
handler on the server side.

00:33:25.160 --> 00:33:26.490
And then your DAO and entity.

00:33:26.490 --> 00:33:28.980
So to define a basic CRUD
service with four methods in

00:33:28.980 --> 00:33:30.200
the command pattern,
you would actually

00:33:30.200 --> 00:33:32.460
end up with 14 classes.

00:33:32.460 --> 00:33:34.620
To do that same thing in
RequestFactory by just

00:33:34.620 --> 00:33:38.140
exposing a DAO directly as a
service, all you need is your

00:33:38.140 --> 00:33:40.900
entity proxy and your
service interface.

00:33:40.900 --> 00:33:44.130
And so you end up with two
classes and two interfaces.

00:33:44.130 --> 00:33:46.290
So let's look at an
example of that.

00:33:46.290 --> 00:33:49.640
On the server side here we
have our NamedListDao.

00:33:49.640 --> 00:33:50.650
This is our service IMPL.

00:33:50.650 --> 00:33:54.130
We're actually exposing it as
a service to the client.

00:33:54.130 --> 00:33:56.400
I've just shown one of the
methods here, the save method

00:33:56.400 --> 00:33:58.910
to persist it to
the datastore.

00:33:58.910 --> 00:34:03.190
And then on the client side,
we represent that as our

00:34:03.190 --> 00:34:06.560
NamedList service that extends
RequestContext.

00:34:06.560 --> 00:34:10.350
It just defines the method with
the signature using a

00:34:10.350 --> 00:34:12.540
request for the return type.

00:34:12.540 --> 00:34:14.230
And that's it.

00:34:14.230 --> 00:34:15.215
You define your DAO.

00:34:15.215 --> 00:34:18.310
You define your interface
on the client.

00:34:18.310 --> 00:34:18.969
And that's it.

00:34:18.969 --> 00:34:21.239
That's all the wrapper code you
have to write to actually

00:34:21.239 --> 00:34:23.440
expose the DAO as a service.

00:34:23.440 --> 00:34:27.560
So for persistence-oriented
services this is really ideal

00:34:27.560 --> 00:34:31.880
because it gives you a very
quick way with little code to

00:34:31.880 --> 00:34:35.980
implement CRUD services
and the like.

00:34:35.980 --> 00:34:38.360
So the plumbing that's required
to make this work are

00:34:38.360 --> 00:34:41.840
the locators which I've been
deferring until this point.

00:34:41.840 --> 00:34:45.250
So RequestFactory, in order to
infer things like version

00:34:45.250 --> 00:34:49.730
changes on the server, has
to be able to locate

00:34:49.730 --> 00:34:51.710
or find your entities.

00:34:51.710 --> 00:34:55.280
So in the original 2.1
implementation of

00:34:55.280 --> 00:34:57.820
RequestFactory, you had to
provide static finder methods

00:34:57.820 --> 00:34:59.580
on your entities themselves.

00:34:59.580 --> 00:35:01.035
But that wasn't a very
flexible pattern.

00:35:01.035 --> 00:35:03.450
It made it difficult to work
with dependency injection on

00:35:03.450 --> 00:35:05.090
the server side.

00:35:05.090 --> 00:35:06.690
And it's not a common pattern.

00:35:06.690 --> 00:35:11.320
So in 2.1.1, I think it was, we
made it possible to define

00:35:11.320 --> 00:35:13.490
a locator for an entity.

00:35:13.490 --> 00:35:16.180
And the locator, its whole
job is just to find it.

00:35:16.180 --> 00:35:18.850
So it makes the call, the query,
to the datastore and

00:35:18.850 --> 00:35:20.640
brings back the entity.

00:35:20.640 --> 00:35:26.840
Well, because Objectify uses
generics well in the DAOs, you

00:35:26.840 --> 00:35:29.390
can actually write one Objectify
locator that will

00:35:29.390 --> 00:35:32.390
work with all your Objectify
entities.

00:35:32.390 --> 00:35:35.520
So only one class to make
all this come alive.

00:35:35.520 --> 00:35:39.210
And similarly for the services,
RequestFactory

00:35:39.210 --> 00:35:43.360
originally would actually call
static methods and those would

00:35:43.360 --> 00:35:44.690
be your services.

00:35:44.690 --> 00:35:46.960
But that doesn't work with
dependency injection at all,

00:35:46.960 --> 00:35:48.900
because you need instances
of things.

00:35:48.900 --> 00:35:51.750
So in 2.1.1 we made it to where
you could specify a

00:35:51.750 --> 00:35:54.010
service locator, and that
would give you back an

00:35:54.010 --> 00:35:55.650
instance of a service.

00:35:55.650 --> 00:35:59.590
So now you can do service
inheritance as well.

00:35:59.590 --> 00:36:03.670
And in the previous slide, you
noticed that the NamedListDao

00:36:03.670 --> 00:36:05.872
extends ObjectifyDao.

00:36:05.872 --> 00:36:09.400
So the only code I have to put
in my NamedListDao is code

00:36:09.400 --> 00:36:11.790
that's specific to
that entity.

00:36:11.790 --> 00:36:13.640
In this case I'm getting
the user and

00:36:13.640 --> 00:36:15.270
setting an owner property.

00:36:15.270 --> 00:36:18.020
But if I were just persisting
the entity I wouldn't have to

00:36:18.020 --> 00:36:20.170
even have a method here because
it would just be

00:36:20.170 --> 00:36:22.410
inherited from the
ObjectifyDao.

00:36:22.410 --> 00:36:25.930
So you can make a really
lightweight CRUD persistence

00:36:25.930 --> 00:36:28.070
layer using this.

00:36:28.070 --> 00:36:30.970
So service locators enable you
to configure your services

00:36:30.970 --> 00:36:33.720
through dependency injection.

00:36:33.720 --> 00:36:37.130
And again, you can use one
generic service locator for

00:36:37.130 --> 00:36:38.390
all services.

00:36:38.390 --> 00:36:40.680
Basically, all you need on the
service is you implement the

00:36:40.680 --> 00:36:44.740
service locator interface and
you return class.newinstance.

00:36:44.740 --> 00:36:46.970
And it'll look at the service
class that it was requested

00:36:46.970 --> 00:36:49.120
and just return a new
instance of it.

00:36:49.120 --> 00:36:52.540
Or if you want to hook it into
Spring or Guice, then you call

00:36:52.540 --> 00:36:54.800
the web application
context and get it

00:36:54.800 --> 00:36:58.460
from your DI container.

00:36:58.460 --> 00:37:01.060
So this is what an Objectify
entity locator looks like.

00:37:01.060 --> 00:37:02.910
You can see it's very simple.

00:37:02.910 --> 00:37:06.210
To create methods just call
class.newInstance to create an

00:37:06.210 --> 00:37:08.170
instance of the requested
entity.

00:37:08.170 --> 00:37:13.440
And then define method makes the
Objectify call to find it.

00:37:13.440 --> 00:37:16.370
This one, I'm using a
datastoreObject as a

00:37:16.370 --> 00:37:17.650
convenience.

00:37:17.650 --> 00:37:21.060
By extending that base class,
having my entities extend

00:37:21.060 --> 00:37:24.710
that, I can know that the ID
property is of type Long,

00:37:24.710 --> 00:37:27.860
which makes my other methods
in this locator

00:37:27.860 --> 00:37:29.080
a little bit simpler.

00:37:29.080 --> 00:37:31.810
But you can also do it using
Reflection, because it's on

00:37:31.810 --> 00:37:34.680
the server side, and avoid
even that little bit.

00:37:34.680 --> 00:37:36.520
So your entities can just
be playing POJOs.

00:37:36.520 --> 00:37:39.720
Don't have to extend
any class.

00:37:39.720 --> 00:37:42.460
So to sum it all up, to make
a service layer with

00:37:42.460 --> 00:37:44.980
RequestFactory and Objectify,
you have one entity locator,

00:37:44.980 --> 00:37:47.790
one service locator, one
RequestFactory class.

00:37:47.790 --> 00:37:49.760
Those are for your whole app.

00:37:49.760 --> 00:37:51.200
And they're already written
for you, by the way.

00:37:51.200 --> 00:37:52.360
If you look at the
sample projects

00:37:52.360 --> 00:37:53.730
we'll put up in a minute.

00:37:53.730 --> 00:37:56.650
And then your entity.

00:37:56.650 --> 00:37:59.650
Each one has to have two
representations, but one of

00:37:59.650 --> 00:38:02.080
them is just an interface
on the client.

00:38:02.080 --> 00:38:05.300
Your service has an IMPL and
a service interface.

00:38:05.300 --> 00:38:07.990
And that's about as lightweight
as you can make a

00:38:07.990 --> 00:38:10.510
service layer actually in GWT.

00:38:10.510 --> 00:38:13.020
But even for this we do have
some tooling coming out.

00:38:13.020 --> 00:38:15.430
There'll be a presentation
sometime.

00:38:15.430 --> 00:38:18.810
It's either today or tomorrow,
I can't remember, on using

00:38:18.810 --> 00:38:21.190
Android for App Engine
development.

00:38:21.190 --> 00:38:22.190
App Engine for Android?

00:38:22.190 --> 00:38:23.832
Well, anyway.

00:38:23.832 --> 00:38:26.800
And that presentation will be
showing some tooling in

00:38:26.800 --> 00:38:30.380
GooglePlugin for Eclipse where
you can actually right click

00:38:30.380 --> 00:38:32.640
and say, new service layer or
something like that and it

00:38:32.640 --> 00:38:36.800
will create a lot of these
interfaces and code for you.

00:38:36.800 --> 00:38:38.510
So watch this space
for tooling to

00:38:38.510 --> 00:38:41.190
make this even user.

00:38:41.190 --> 00:38:41.480
OK.

00:38:41.480 --> 00:38:45.240
With that, I'd like to move to
the front end now to the UI.

00:38:45.240 --> 00:38:45.920
You've heard about the

00:38:45.920 --> 00:38:47.810
model-view-presenter framework.

00:38:47.810 --> 00:38:51.820
And several frameworks emerged,
Mvp4g, gwt-dispatch,

00:38:51.820 --> 00:38:55.950
gwt-presenter, and one of the
most recent frameworks has

00:38:55.950 --> 00:38:59.120
been run by Philippe Beaudoin
who created it.

00:38:59.120 --> 00:39:02.210
And today, we have, I'm pleased
to announce, Philippe

00:39:02.210 --> 00:39:03.430
himself to talk about
the framework.

00:39:03.430 --> 00:39:04.680
So welcome, Philippe.

00:39:12.880 --> 00:39:13.050
PHILIPPE BEAUDOIN: OK.

00:39:13.050 --> 00:39:14.950
So thanks, David.

00:39:14.950 --> 00:39:17.170
So the rest of this talk is
going to be about the

00:39:17.170 --> 00:39:21.480
gwt-platform, which we also call
GWTP so we can have the

00:39:21.480 --> 00:39:24.050
cute little tepee as our logo.

00:39:24.050 --> 00:39:24.290
OK.

00:39:24.290 --> 00:39:28.480
So the goal of gwt-platform is
to actually make it possible

00:39:28.480 --> 00:39:32.020
for you, the developers, to
build a large scale GWT

00:39:32.020 --> 00:39:36.040
application while sticking to
the industry best practices.

00:39:36.040 --> 00:39:39.460
So in there, you'll get a
presenter-centric model view

00:39:39.460 --> 00:39:42.010
presenter framework.

00:39:42.010 --> 00:39:45.530
There's also a common pattern
that's included in GWTP and a

00:39:45.530 --> 00:39:46.450
couple of other goodies.

00:39:46.450 --> 00:39:50.090
For example, there are
mechanisms to help you play

00:39:50.090 --> 00:39:52.510
with your internationalization
strings.

00:39:52.510 --> 00:39:57.440
Or just recently, in version
0.6 coming very soon, we'll

00:39:57.440 --> 00:40:00.950
actually add some mechanisms
to let you make it possible

00:40:00.950 --> 00:40:04.570
for your AJAX stage to be
indexed by a crawler.

00:40:04.570 --> 00:40:06.800
So I call this a
presenter-centric

00:40:06.800 --> 00:40:08.530
model-view-presenter
framework.

00:40:08.530 --> 00:40:11.890
And the reason is that because
all the information is

00:40:11.890 --> 00:40:13.970
actually located right
into the presenter.

00:40:13.970 --> 00:40:15.590
You don't have to write
multiple classes.

00:40:15.590 --> 00:40:19.320
It's all in the same place.

00:40:19.320 --> 00:40:19.690
OK.

00:40:19.690 --> 00:40:22.495
So a quick overview
of GWTP's MVP.

00:40:22.495 --> 00:40:28.210
The first thing to know is that
GWTP's MVP predates GWT's

00:40:28.210 --> 00:40:29.830
Activity and Places.

00:40:29.830 --> 00:40:32.300
So it's not based on them.

00:40:32.300 --> 00:40:35.340
However, we're working really
hard to bridge that gap now so

00:40:35.340 --> 00:40:39.440
you can benefit both from
Activity and Places, and

00:40:39.440 --> 00:40:42.820
GWTP's super simple
MVP syntax.

00:40:42.820 --> 00:40:45.830
It's also an annotation-based
API, which means that most of

00:40:45.830 --> 00:40:48.520
the time you can do in a single
line of code what would

00:40:48.520 --> 00:40:51.470
otherwise take you a
couple of classes.

00:40:51.470 --> 00:40:53.720
There's also support for nested
presenter, a little

00:40:53.720 --> 00:40:56.610
feature we'll come back
into detail soon.

00:40:56.610 --> 00:40:59.180
And there's also built-in
support for GIN, so you get

00:40:59.180 --> 00:41:02.420
dependence injection on the
client, and much more which

00:41:02.420 --> 00:41:04.430
we'll list at the end.

00:41:04.430 --> 00:41:04.660
OK.

00:41:04.660 --> 00:41:06.530
So in order to understand
GWTP let's start

00:41:06.530 --> 00:41:08.350
with a quick example.

00:41:08.350 --> 00:41:11.220
Let's say you want to build in
your web app some page that

00:41:11.220 --> 00:41:13.840
welcomes the user to your app.

00:41:13.840 --> 00:41:17.570
So in MVP world, it means you
have to write at least a

00:41:17.570 --> 00:41:19.490
presenter and a view.

00:41:19.490 --> 00:41:23.620
So this is how the view
would look into GWTP.

00:41:23.620 --> 00:41:25.860
But the first thing you'll
notice is that we're extending

00:41:25.860 --> 00:41:26.510
some class.

00:41:26.510 --> 00:41:28.250
They're called ViewIMPL.

00:41:28.250 --> 00:41:31.230
It's important to know that
ViewIMPL is an empty class

00:41:31.230 --> 00:41:33.580
basically just providing default
implementation for

00:41:33.580 --> 00:41:34.560
three methods.

00:41:34.560 --> 00:41:37.710
So you don't have to actually
extend that class.

00:41:37.710 --> 00:41:39.500
You can extend whatever
class you want.

00:41:39.500 --> 00:41:41.820
For example Composite.

00:41:41.820 --> 00:41:44.110
There is also it's implementing
some interface,

00:41:44.110 --> 00:41:47.620
and we'll come back
to that soon.

00:41:47.620 --> 00:41:50.360
But really the only important
thing in that class here is

00:41:50.360 --> 00:41:53.310
the asWidget method you see
at the bottom there.

00:41:53.310 --> 00:41:56.090
Basically, it says that your
view has to be able to be

00:41:56.090 --> 00:41:57.600
represented as a widget.

00:41:57.600 --> 00:42:00.180
You can create that widget
in any way you want.

00:42:00.180 --> 00:42:03.450
In that particular case, we're
using UIBinder to create it.

00:42:03.450 --> 00:42:07.960
But if you prefer to use
GWT Designer, or if you

00:42:07.960 --> 00:42:09.220
instantiate the widgets
manually,

00:42:09.220 --> 00:42:12.180
you're free to do that.

00:42:12.180 --> 00:42:15.180
But the fun part is actually
the presenter itself.

00:42:15.180 --> 00:42:17.100
So let's take a look at it.

00:42:17.100 --> 00:42:19.975
Here, the first thing you'll
see is that we are defining

00:42:19.975 --> 00:42:22.870
the interface we introduced
in the previous slide.

00:42:22.870 --> 00:42:24.910
So we have my view here.

00:42:24.910 --> 00:42:27.190
Right now, it's an empty
interface, but we'll fill it

00:42:27.190 --> 00:42:28.830
with methods that the
presenter can use to

00:42:28.830 --> 00:42:31.470
communicate with it's view.

00:42:31.470 --> 00:42:34.830
We also have a second interface
here called MyProxy.

00:42:34.830 --> 00:42:38.180
The proxy is actually the
fun part of GWTP.

00:42:38.180 --> 00:42:42.230
It's using GWT code generation
tools in order to provide some

00:42:42.230 --> 00:42:43.865
kind of shadow class
for the presenter.

00:42:46.950 --> 00:42:48.930
The goal of this shadow class
is to actually make it

00:42:48.930 --> 00:42:52.560
possible for your presenter to
be lazily loaded or to use

00:42:52.560 --> 00:42:53.720
GWT's cold splitting.

00:42:53.720 --> 00:42:56.710
So it's really easy to do cold
splitting with GWTP.

00:42:56.710 --> 00:42:59.670
You'll only need that line,
your proxy code split, and

00:42:59.670 --> 00:43:01.780
your presenter will
only be loaded the

00:43:01.780 --> 00:43:04.400
first time it's requested.

00:43:04.400 --> 00:43:06.860
And the last thing there is
just a constructor that

00:43:06.860 --> 00:43:10.200
forwards all the resources
needed by a presenter to the

00:43:10.200 --> 00:43:12.350
parent class who is going
to deal with it.

00:43:12.350 --> 00:43:13.730
But you're free to
use any of these

00:43:13.730 --> 00:43:17.100
resources if you need them.

00:43:17.100 --> 00:43:17.340
OK.

00:43:17.340 --> 00:43:20.180
So once you have a presenter,
something you really often

00:43:20.180 --> 00:43:23.270
want to do is attach a URL
to that presenter.

00:43:23.270 --> 00:43:28.600
So say, the user visits my web
page hash welcome, you should

00:43:28.600 --> 00:43:31.150
get into that welcome
presenter page.

00:43:31.150 --> 00:43:33.130
So in GWTP again, that's
easy to do.

00:43:33.130 --> 00:43:36.140
Single line nameToken there,
and you indicate the name

00:43:36.140 --> 00:43:38.980
token you'd like to attach
to your presenter.

00:43:38.980 --> 00:43:42.100
And bang as soon as the
user visits that page

00:43:42.100 --> 00:43:44.560
you get that presenter.

00:43:44.560 --> 00:43:46.920
Now you often want to
attach a bit more

00:43:46.920 --> 00:43:48.900
information to the URL.

00:43:48.900 --> 00:43:55.020
For example let's say that here
we wanted a parameter on

00:43:55.020 --> 00:43:59.280
the URL that says the user
name is Philippe.

00:43:59.280 --> 00:44:00.900
So you can do that
again in GWTP.

00:44:00.900 --> 00:44:05.760
And it's easy because the URL
is going to be parsed

00:44:05.760 --> 00:44:07.950
automatically by
the framework.

00:44:07.950 --> 00:44:10.490
And once it's parsed, the
framework is going to call a

00:44:10.490 --> 00:44:13.840
method called prepareFromRequest
which you

00:44:13.840 --> 00:44:15.280
see at the bottom here.

00:44:15.280 --> 00:44:18.170
You get a place request. You
can grab any component you

00:44:18.170 --> 00:44:19.810
want from the place request
and do whatever

00:44:19.810 --> 00:44:20.880
you want with it.

00:44:20.880 --> 00:44:22.330
So you have the parameters
there.

00:44:22.330 --> 00:44:25.910
In that case we're calling the
method in the view in order to

00:44:25.910 --> 00:44:28.290
set the user name right
in the view.

00:44:28.290 --> 00:44:32.090
So you can see we've added a
method to the view interface

00:44:32.090 --> 00:44:33.800
at the top, and we're
calling it from the

00:44:33.800 --> 00:44:36.530
prepareFromRequest.

00:44:36.530 --> 00:44:36.660
OK.

00:44:36.660 --> 00:44:38.740
Now let's talk a little
bit about GWTP's

00:44:38.740 --> 00:44:40.840
nested presenter feature.

00:44:40.840 --> 00:44:44.450
The idea of the nested presenter
is that it leverages

00:44:44.450 --> 00:44:48.660
the well-known principle of
hierarchy of widgets that you

00:44:48.660 --> 00:44:50.570
all know and that you all use.

00:44:50.570 --> 00:44:53.600
And it tries to bring that all
the way into the presenters

00:44:53.600 --> 00:44:53.930
themselves.

00:44:53.930 --> 00:44:57.530
So you can actually organize
your presenters hierarchically

00:44:57.530 --> 00:44:59.480
without having to instantiate
the widgets that

00:44:59.480 --> 00:45:01.260
are attached to them.

00:45:01.260 --> 00:45:05.400
So you're free to test your
presenter hierarchy without

00:45:05.400 --> 00:45:10.190
having to instantiate widgets,
or without the GWT test case.

00:45:10.190 --> 00:45:11.900
It also brings a couple
of life cycle

00:45:11.900 --> 00:45:12.860
events to the presenter.

00:45:12.860 --> 00:45:16.850
You will now have things like
onReset, onReveal and onHide,

00:45:16.850 --> 00:45:19.910
which will be called whenever
these events occurs, your

00:45:19.910 --> 00:45:24.170
presenters, and all the way
down your hierarchy.

00:45:24.170 --> 00:45:28.560
So let's say that you want a
top-level presenter in your

00:45:28.560 --> 00:45:29.810
new presenter hierarchy.

00:45:33.880 --> 00:45:36.560
So this top level presenter
would actually add children

00:45:36.560 --> 00:45:37.960
presenters.

00:45:37.960 --> 00:45:41.170
In that case, the view has to
be able to attach these

00:45:41.170 --> 00:45:43.520
children presenters to
the parent presenter.

00:45:43.520 --> 00:45:47.030
And this is done in the method
called setInSlot in the view.

00:45:47.030 --> 00:45:49.570
Basically, it only looks at the
slot into which you want

00:45:49.570 --> 00:45:52.670
to add the children presenter
and it adds the corresponding

00:45:52.670 --> 00:45:53.790
widget there.

00:45:53.790 --> 00:45:55.520
Three simple methods.

00:45:55.520 --> 00:45:58.330
And this is only true if your
presenter can have children.

00:45:58.330 --> 00:46:00.310
Otherwise, the view doesn't
need anything more.

00:46:02.850 --> 00:46:05.560
Now on the presenter side, since
the presenter can have

00:46:05.560 --> 00:46:09.530
children, it has to define a
couple of constants that will

00:46:09.530 --> 00:46:11.540
be used to refer to
these children.

00:46:11.540 --> 00:46:13.990
So here you can see two
of these constants.

00:46:13.990 --> 00:46:16.940
The first one is called TOP_SLOT
and CENTER_SLOT.

00:46:16.940 --> 00:46:18.800
They have been added
to the presenter.

00:46:18.800 --> 00:46:21.340
And these can basically
be any kind of object.

00:46:21.340 --> 00:46:23.810
So the first one is the
generate Java object.

00:46:23.810 --> 00:46:25.910
The second one is slightly
more complex.

00:46:25.910 --> 00:46:29.810
It's a GWT type platform.

00:46:29.810 --> 00:46:32.640
The reason the second one is
more complex is because it's

00:46:32.640 --> 00:46:36.740
going to allow us to use the
EventBus to decouple even the

00:46:36.740 --> 00:46:38.560
parent presenter from
its children.

00:46:41.710 --> 00:46:45.990
So the top-level presenter has
to reveal itself and say, I'm

00:46:45.990 --> 00:46:49.040
going to occupy the full
page of the web app.

00:46:49.040 --> 00:46:51.670
So to do that there's a
revealInParent method which we

00:46:51.670 --> 00:46:52.860
left off earlier.

00:46:52.860 --> 00:46:55.390
But every presenter needs
to have that.

00:46:55.390 --> 00:46:57.870
And in the case of the top level
presenter, it actually

00:46:57.870 --> 00:47:01.600
fires an event called
RevealRootContentEvent.

00:47:01.600 --> 00:47:05.000
And that event is called by
GWTP and says, OK, now the

00:47:05.000 --> 00:47:07.430
presenter is going to occupy
the entire page.

00:47:07.430 --> 00:47:09.850
If you'd rather use GWT's
Layout Panel, there's a

00:47:09.850 --> 00:47:11.800
slightly different event
that you can fire in

00:47:11.800 --> 00:47:15.170
exactly the same way.

00:47:15.170 --> 00:47:18.430
Now if you want to reveal a
children presenter that's

00:47:18.430 --> 00:47:21.410
loosely coupled to its parent,
they can't talk

00:47:21.410 --> 00:47:22.930
to one another directly.

00:47:22.930 --> 00:47:25.700
What happens there is that the
children will actually fire an

00:47:25.700 --> 00:47:30.400
event again that says, please
reveal me inside that slot.

00:47:30.400 --> 00:47:31.580
The slot is just a constant.

00:47:31.580 --> 00:47:33.710
It's not a reference to
the parent itself.

00:47:33.710 --> 00:47:39.500
The parent will catch the event
and reveal the children.

00:47:39.500 --> 00:47:41.670
The last little thing I'm going
to talk about is called

00:47:41.670 --> 00:47:43.020
PresenterWidgets.

00:47:43.020 --> 00:47:45.870
So sometimes you don't really
need to have that decoupling

00:47:45.870 --> 00:47:48.220
between the parent presenter
and the children.

00:47:48.220 --> 00:47:51.650
You just want some lightweight
mechanism to create reusable

00:47:51.650 --> 00:47:52.690
components.

00:47:52.690 --> 00:47:54.880
This is where PresenterWidgets
come in.

00:47:54.880 --> 00:47:59.660
So PresenterWidgets are also
very useful if you have

00:47:59.660 --> 00:48:02.930
tightly related presenters and
you don't want to go to the

00:48:02.930 --> 00:48:06.520
trouble of decoupling
via the EventBus.

00:48:06.520 --> 00:48:09.070
So an example in which I
personally tend to use

00:48:09.070 --> 00:48:11.930
PresenterWidget, there's a
little login bar at the top of

00:48:11.930 --> 00:48:14.280
your web app that
says, OK, well

00:48:14.280 --> 00:48:15.510
you're logged in Philippe.

00:48:15.510 --> 00:48:17.510
Log in, log out, stuff
like that.

00:48:17.510 --> 00:48:19.000
So in that case, it's called
the loginPresenter.

00:48:21.670 --> 00:48:22.790
You see there.

00:48:22.790 --> 00:48:25.330
And for PresenterWidget what
we do is that we actually

00:48:25.330 --> 00:48:27.950
inject them in the
parent presenter.

00:48:27.950 --> 00:48:30.190
So you can see the injection
called here on the

00:48:30.190 --> 00:48:31.390
constructor.

00:48:31.390 --> 00:48:34.450
And then later at any point in
time, you are free to call the

00:48:34.450 --> 00:48:37.070
method called setInSlot
and say, I want this

00:48:37.070 --> 00:48:40.440
PresenterWidget to actually
occupy that top

00:48:40.440 --> 00:48:41.990
slot in that case.

00:48:41.990 --> 00:48:44.850
So in this example here, we're
doing that in onReveal.

00:48:44.850 --> 00:48:48.390
So the first time this main
presenter is revealed, it's

00:48:48.390 --> 00:48:51.200
going to install the login
presenter in the top slot.

00:48:51.200 --> 00:48:53.560
But you are free to replace
it later or to

00:48:53.560 --> 00:48:56.750
do that at any time.

00:48:56.750 --> 00:48:59.810
So the last little thing is
that we're using GIN.

00:48:59.810 --> 00:49:03.460
And all these nice little
components are interfaces that

00:49:03.460 --> 00:49:05.810
we have to connect to
implementations and that we

00:49:05.810 --> 00:49:07.340
have to connect to
one another.

00:49:07.340 --> 00:49:09.630
This is done in the
GIN module.

00:49:09.630 --> 00:49:12.820
There are couple of methods in
GWTP to help you do a lot of

00:49:12.820 --> 00:49:14.580
bindings in one call.

00:49:14.580 --> 00:49:17.260
So it's again few
lines of code.

00:49:17.260 --> 00:49:20.650
And if you're interested to know
how to do that you can

00:49:20.650 --> 00:49:22.420
look at the wiki.

00:49:22.420 --> 00:49:24.240
There's also a custom
place manager

00:49:24.240 --> 00:49:25.870
that you have to write.

00:49:25.870 --> 00:49:29.080
This is basically just telling
your app, oh, if the user logs

00:49:29.080 --> 00:49:33.460
in without a hash tag there
go to that default page.

00:49:33.460 --> 00:49:38.570
Or if it's an error page, you
can define it in there.

00:49:38.570 --> 00:49:40.900
So it's all defined in
the wiki, like I say.

00:49:40.900 --> 00:49:44.580
But if you're using Eclipse,
you'll be happy to know that

00:49:44.580 --> 00:49:48.970
with version 0.6 there will be
a new Eclipse plugin coming

00:49:48.970 --> 00:49:52.000
out with GWTP that will let
you create all these

00:49:52.000 --> 00:49:55.240
presenters and views and
connections between them with

00:49:55.240 --> 00:49:56.660
a simple click of the mouse.

00:49:56.660 --> 00:49:58.020
But I'd like to thank Michael
[? Renault ?]

00:49:58.020 --> 00:50:03.006
and Imagine who actually
contributed that plugin.

00:50:03.006 --> 00:50:04.256
[APPLAUSE.]

00:50:06.150 --> 00:50:07.920
OK.

00:50:07.920 --> 00:50:12.210
So quickly in summary, what
GWTP offers you is that

00:50:12.210 --> 00:50:14.980
basically you can do MVP with
two classes, a presenter and a

00:50:14.980 --> 00:50:19.120
view, which is the strict
minimum you need for MVP.

00:50:19.120 --> 00:50:21.940
There is also super simple
history management through the

00:50:21.940 --> 00:50:24.440
@token annotation.

00:50:24.440 --> 00:50:27.620
You have nesting, so
nested presenters.

00:50:27.620 --> 00:50:30.590
And there's also a lot more
inquiry due to Explorer.

00:50:30.590 --> 00:50:33.020
So you can actually have tabbed
presenters with little

00:50:33.020 --> 00:50:36.120
tabs at the top or dialogue
box presenters.

00:50:36.120 --> 00:50:38.840
There are gatekeepers, which
allow you to do client-side

00:50:38.840 --> 00:50:42.800
security so some pages are not
visible to some users.

00:50:42.800 --> 00:50:45.620
ProxyEvent is a little
annotation that makes it super

00:50:45.620 --> 00:50:48.710
easy to bind EventHandler
to events.

00:50:48.710 --> 00:50:50.450
There are breadcrumbs
support if your

00:50:50.450 --> 00:50:51.980
application needs that.

00:50:51.980 --> 00:50:56.340
Annotation processors that
easily, automatically generate

00:50:56.340 --> 00:50:58.110
events actions and DTOs.

00:50:58.110 --> 00:51:00.930
And there's also the GWTP's
command patterns that is

00:51:00.930 --> 00:51:03.790
packed full of features
like what we've seen.

00:51:03.790 --> 00:51:07.150
There's also quick features I
want to bring your attention

00:51:07.150 --> 00:51:08.970
on that's coming out
really soon too.

00:51:08.970 --> 00:51:12.620
It's what we call GWTP's
Crawler Service.

00:51:12.620 --> 00:51:15.440
And basically, it's a service
you can instantiate.

00:51:15.440 --> 00:51:17.450
Right now, it's meant to
run in App Engine.

00:51:17.450 --> 00:51:20.950
But it will make it easy for
your AJAX page to be crawlable

00:51:20.950 --> 00:51:21.840
by search engines.

00:51:21.840 --> 00:51:24.090
It's a feature that has been
requested for awhile.

00:51:24.090 --> 00:51:26.520
I think it's going to be
really useful to you.

00:51:26.520 --> 00:51:30.550
So in conclusion, I'd like to
thank Arcbees Consulting

00:51:30.550 --> 00:51:32.060
who've been funding
the project.

00:51:32.060 --> 00:51:35.590
Also BookDen.net who have
been using it a lot.

00:51:35.590 --> 00:51:36.840
They've really helped.

00:51:36.840 --> 00:51:39.010
But this project is an
open source project.

00:51:39.010 --> 00:51:42.230
Lots of contributors on it, and
it would never be where it

00:51:42.230 --> 00:51:43.940
is today without their help.

00:51:43.940 --> 00:51:47.040
So I'd like to acknowledge
them.

00:51:47.040 --> 00:51:49.506
So with that I'll hand
it over to David.

00:51:49.506 --> 00:51:50.756
[APPLAUSE]

00:51:57.410 --> 00:51:58.780
DAVID CHANDLER: Thank you.

00:51:58.780 --> 00:52:00.030
Thanks very much.

00:52:03.940 --> 00:52:06.160
There's a couple of sample apps
that I want to point your

00:52:06.160 --> 00:52:08.780
attention to for using
some of these things.

00:52:08.780 --> 00:52:10.640
We have a project we created.

00:52:10.640 --> 00:52:12.570
Philippe did most
of it actually.

00:52:12.570 --> 00:52:15.910
The GWT GAE 2011 project shows
you how to use RequestFactory,

00:52:15.910 --> 00:52:19.310
Objectify and gwt-presenter
all together.

00:52:19.310 --> 00:52:21.230
gwt-platform, sorry.

00:52:21.230 --> 00:52:22.680
ListWidget is something I did.

00:52:22.680 --> 00:52:24.100
The user interface
is terrible.

00:52:24.100 --> 00:52:25.470
I apologize.

00:52:25.470 --> 00:52:29.090
The server-side code is fine.

00:52:29.090 --> 00:52:31.660
Maven, Objectify,
RequestFactory.

00:52:31.660 --> 00:52:34.540
And then, Turbomanage
is my personal blog.

00:52:34.540 --> 00:52:36.490
Arcbees is Philippe's blog.

00:52:36.490 --> 00:52:43.545
Googledevtools is our Twitter
account for the GWT team.

00:52:43.545 --> 00:52:45.360
Let's see.

00:52:45.360 --> 00:52:46.950
Sorry I didn't get your
blog up there, Jeff.

00:52:46.950 --> 00:52:50.850
The best place to find Jeff
is actually on the

00:52:50.850 --> 00:52:54.480
Objectify-Appengine mailing
list. Based on the frequency

00:52:54.480 --> 00:52:58.040
and timing of posts that I've
seen, I'm pretty sure that

00:52:58.040 --> 00:53:01.830
Jeff responds to the mailing
list while he's riding his

00:53:01.830 --> 00:53:06.880
motorcycle to and from Central
America as he talked about in

00:53:06.880 --> 00:53:08.850
the abstract.

00:53:08.850 --> 00:53:11.320
So very responsive.

00:53:11.320 --> 00:53:12.920
I want to give a huge
thank you to

00:53:12.920 --> 00:53:14.760
the open source community.

00:53:14.760 --> 00:53:16.110
We haven't mentioned them this
morning, but I want to

00:53:16.110 --> 00:53:18.780
especially thank David Peterson
who created the

00:53:18.780 --> 00:53:21.780
gwt-presenter and gwt-dispatch
frameworks based on Ray Ryan's

00:53:21.780 --> 00:53:23.390
talk two years ago.

00:53:23.390 --> 00:53:26.400
That framework was very
important in building this

00:53:26.400 --> 00:53:30.960
whole community of MVP
architecture and GWT.

00:53:30.960 --> 00:53:33.610
And gwt-platform actually uses
a lot of that code and is

00:53:33.610 --> 00:53:35.150
built further on it.

00:53:35.150 --> 00:53:38.340
So you all are the secret
to the success of these

00:53:38.340 --> 00:53:41.470
platforms. I encourage you to
get involved in the open

00:53:41.470 --> 00:53:44.850
source projects around
GWT and App Engine.

00:53:44.850 --> 00:53:46.940
And let's see.

00:53:46.940 --> 00:53:49.720
I just wanted to point out one
historic thing that's happened

00:53:49.720 --> 00:53:52.360
here this morning.

00:53:52.360 --> 00:53:56.750
We don't usually let people
talk at Google I/O until

00:53:56.750 --> 00:54:00.140
they're Googlers or sometimes
external guys like Jeff.

00:54:00.140 --> 00:54:01.970
But Philippe has done something
unusual in that he's

00:54:01.970 --> 00:54:05.360
actually done his first
presentation at Google I/O

00:54:05.360 --> 00:54:06.820
before he actually
joined Google.

00:54:06.820 --> 00:54:10.930
He has been hired by Google,
I'm happy to say.

00:54:10.930 --> 00:54:13.360
His Noogler training isn't
for a couple of weeks.

00:54:13.360 --> 00:54:14.620
I'm a Noogler myself.

00:54:14.620 --> 00:54:16.920
I joined last June so it was
before the last I/O.

00:54:16.920 --> 00:54:19.933
So I just want to say, Philippe,
my hat's off to you.

00:54:19.933 --> 00:54:21.183
[APPLAUSE].

00:54:29.870 --> 00:54:32.950
Now I want to point out
one presentation.

00:54:32.950 --> 00:54:35.430
We're going to mention that
RequestFactory tooling and the

00:54:35.430 --> 00:54:38.215
Android App Engine
today at 3:45.

00:54:38.215 --> 00:54:40.960
I also encourage you to stop by
the GWT office hours from

00:54:40.960 --> 00:54:42.870
12:00 to 3:00 both days.

00:54:42.870 --> 00:54:45.090
That's where you can get people
personally answering

00:54:45.090 --> 00:54:47.260
your questions about GWT.

00:54:47.260 --> 00:54:49.220
And finally, I encourage you
to visit the GWT Developer

00:54:49.220 --> 00:54:52.420
Sandbox area out on the
second floor here.

00:54:52.420 --> 00:54:55.410
We have 16 companies who are
using GWT in creative and

00:54:55.410 --> 00:54:56.670
innovative ways.

00:54:56.670 --> 00:54:58.980
And that's a great place
to talk geek.

00:54:58.980 --> 00:55:00.910
There's also some of them, I
think there's a special offer

00:55:00.910 --> 00:55:03.610
on a book there, and some other
things that you might be

00:55:03.610 --> 00:55:04.860
interested in.

00:55:04.860 --> 00:55:07.010
It's GWT developers.

00:55:07.010 --> 00:55:09.270
We have about five
minutes left.

00:55:09.270 --> 00:55:11.450
If you would like to ask a
question, can I ask that you

00:55:11.450 --> 00:55:13.080
make your way to one of
the mikes so that it

00:55:13.080 --> 00:55:14.660
can be on the video.

00:55:14.660 --> 00:55:17.910
And maybe that's not such
a good idea with the

00:55:17.910 --> 00:55:19.320
crowd we have here.

00:55:19.320 --> 00:55:21.286
But if you can give it a shot.

00:55:21.286 --> 00:55:23.120
We'll wait for you to
get to a mic there.

00:55:25.940 --> 00:55:26.200
AUDIENCE: Yes.

00:55:26.200 --> 00:55:27.090
Hello.

00:55:27.090 --> 00:55:28.360
I'm [UNINTELLIGIBLE]

00:55:28.360 --> 00:55:30.280
I have a question for Jeff.

00:55:30.280 --> 00:55:35.310
So do you think that Objectify
could be the next Hibernate?

00:55:35.310 --> 00:55:37.560
I mean [UNINTELLIGIBLE]

00:55:37.560 --> 00:55:38.600
SQL [UNINTELLIGIBLE]

00:55:38.600 --> 00:55:42.486
SQL that the best
[UNINTELLIGIBLE].

00:55:42.486 --> 00:55:43.900
JEFF SCHNITZER: I don't know how
to answer that question.

00:55:43.900 --> 00:55:46.170
I hope not.

00:55:46.170 --> 00:55:48.935
Hibernate is a very, very
complicated piece of software.

00:55:48.935 --> 00:55:51.620
I hope Objectify never
gets to that point.

00:55:55.610 --> 00:55:56.080
DAVID CHANDLER: OK.

00:55:56.080 --> 00:55:57.760
Anyone else?

00:55:57.760 --> 00:55:58.035
Yes?

00:55:58.035 --> 00:56:00.910
AUDIENCE: Say I have variable
schemas on the server side.

00:56:00.910 --> 00:56:04.260
Is there any way to apply the
RequestFactory details if I

00:56:04.260 --> 00:56:07.800
don't know the schema of
the object in advance?

00:56:07.800 --> 00:56:08.700
DAVID CHANDLER: No.

00:56:08.700 --> 00:56:09.770
AUDIENCE: OK.

00:56:09.770 --> 00:56:11.100
DAVID CHANDLER: Not offhand.

00:56:11.100 --> 00:56:12.510
AUDIENCE: OK.

00:56:12.510 --> 00:56:13.160
Thanks.

00:56:13.160 --> 00:56:15.670
DAVID CHANDLER: You can write a
generic schema, but then at

00:56:15.670 --> 00:56:17.965
that point it just becomes
basically a HashMap or a

00:56:17.965 --> 00:56:19.210
properties bag or something
that you're

00:56:19.210 --> 00:56:21.190
going back and forth.

00:56:21.190 --> 00:56:24.110
And actually that will work, and
it will actually work with

00:56:24.110 --> 00:56:26.310
App Engine because the
datastore doesn't

00:56:26.310 --> 00:56:27.375
have to have types.

00:56:27.375 --> 00:56:30.560
As Jeff showed at first, you
just have an entity which is

00:56:30.560 --> 00:56:32.610
basically just a
properties bag.

00:56:32.610 --> 00:56:38.040
So you can do it but not with
POJOs that you're redefining

00:56:38.040 --> 00:56:38.785
on the fly.

00:56:38.785 --> 00:56:39.260
AUDIENCE: OK.

00:56:39.260 --> 00:56:40.600
Thank you.

00:56:40.600 --> 00:56:42.040
DAVID CHANDLER: Question.

00:56:42.040 --> 00:56:44.160
AUDIENCE: This question
is for Philippe.

00:56:44.160 --> 00:56:48.690
Since Ray Ryan's talk, I really
got into the MVP thing.

00:56:48.690 --> 00:56:51.630
And then with the activities
in Places, I kind of had

00:56:51.630 --> 00:56:55.510
trouble mentally mapping between
that in view of MVP in

00:56:55.510 --> 00:56:56.990
the Activity Places.

00:56:56.990 --> 00:57:00.340
Do you any insights as
to how gwt-platform

00:57:00.340 --> 00:57:03.350
going to tackle that?

00:57:03.350 --> 00:57:04.460
PHILIPPE BEAUDOIN: Yes.

00:57:04.460 --> 00:57:07.230
To be honest I haven't looked at
Activities and Places that

00:57:07.230 --> 00:57:09.860
much myself.

00:57:09.860 --> 00:57:13.590
From what I understand there,
it goes some way towards

00:57:13.590 --> 00:57:18.560
helping you do the MVP
architecture, but you have to

00:57:18.560 --> 00:57:19.810
do the rest of it yourself.

00:57:23.670 --> 00:57:25.060
I'm not entirely sure.

00:57:25.060 --> 00:57:28.530
I think that what GWTP will do
for is that it will actually

00:57:28.530 --> 00:57:33.050
reduce the number classes you
have to write just because it

00:57:33.050 --> 00:57:36.600
tends to use annotations instead
of asking you to write

00:57:36.600 --> 00:57:37.850
multiple classes.

00:57:40.470 --> 00:57:44.390
Beside that, I'm not
entirely sure the

00:57:44.390 --> 00:57:46.630
difference between both.

00:57:46.630 --> 00:57:47.820
DAVID CHANDLER: We're going to
talk about Activities and

00:57:47.820 --> 00:57:51.690
Places tomorrow afternoon in the
high-performance GWT talk.

00:57:51.690 --> 00:57:53.000
And you might get some
ideas there.

00:57:53.000 --> 00:57:54.700
I think you could
create some--

00:57:54.700 --> 00:58:00.390
or Philippe could create some
annotations for presenters for

00:58:00.390 --> 00:58:02.420
example that would
also allow that

00:58:02.420 --> 00:58:03.230
presenter to be an activity.

00:58:03.230 --> 00:58:07.730
And you could co-generate some
of the code you need for that.

00:58:07.730 --> 00:58:09.200
We should talk.

00:58:09.200 --> 00:58:10.070
There's potential there.

00:58:10.070 --> 00:58:12.190
PHILIPPE BEAUDOIN: I will
be attending this one.

00:58:12.190 --> 00:58:12.690
DAVID CHANDLER: Yes.

00:58:12.690 --> 00:58:13.010
AUDIENCE: Hi.

00:58:13.010 --> 00:58:14.280
I am Marcello.

00:58:14.280 --> 00:58:17.500
Last year, I remember you showed
us integration with the

00:58:17.500 --> 00:58:18.820
Spring Roo.

00:58:18.820 --> 00:58:20.650
Are the teams still
working together?

00:58:20.650 --> 00:58:22.530
Are you going to add
these to Spring?

00:58:22.530 --> 00:58:24.560
DAVID CHANDLER: We haven't
done a lot of development

00:58:24.560 --> 00:58:26.350
building further
on Spring Roo.

00:58:26.350 --> 00:58:29.400
My understanding is that Spring
has hired someone that

00:58:29.400 --> 00:58:32.240
is working on the GWT
stuff full-time.

00:58:32.240 --> 00:58:35.640
But I'm not real plugged into
that right now so I'm not sure

00:58:35.640 --> 00:58:36.890
how much is really going on.

00:58:40.690 --> 00:58:41.240
AUDIENCE: Thanks.

00:58:41.240 --> 00:58:44.260
DAVID CHANDLER: That's
the best I can say.

00:58:44.260 --> 00:58:47.670
And just for curiosity how many
people are using Roo or

00:58:47.670 --> 00:58:49.490
trying to use Roo?

00:58:49.490 --> 00:58:50.500
A few people.

00:58:50.500 --> 00:58:52.290
OK.

00:58:52.290 --> 00:58:54.150
I'd be glad to get
your thoughts.

00:58:54.150 --> 00:58:56.470
I'll be hanging around the
Developer Sandbox area later

00:58:56.470 --> 00:58:58.140
today if you want to talk
about that more.

00:59:03.480 --> 00:59:03.900
Yes.

00:59:03.900 --> 00:59:04.050
AUDIENCE: Yeah.

00:59:04.050 --> 00:59:05.300
One quick question.

00:59:05.300 --> 00:59:08.610
What about Objective-C client
for RequestFactory?

00:59:08.610 --> 00:59:11.590
I realize this is Google and
we have Android as a client

00:59:11.590 --> 00:59:16.840
and GWT, but it's obviously a
big platform, big market that

00:59:16.840 --> 00:59:19.050
we'd like to be able to deploy
to multiple clients.

00:59:19.050 --> 00:59:21.440
DAVID CHANDLER: I'm sure if
the open source community

00:59:21.440 --> 00:59:23.770
wanted to contribute an
Objective-C client for

00:59:23.770 --> 00:59:26.990
RequestFactory, we probably
wouldn't turn it down.

00:59:26.990 --> 00:59:29.160
But I don't think that's
something that we would be

00:59:29.160 --> 00:59:30.410
working on.

00:59:33.660 --> 00:59:33.900
OK.

00:59:33.900 --> 00:59:35.210
I don't see anyone else
lined up at the mic so

00:59:35.210 --> 00:59:36.870
thank you very much.

