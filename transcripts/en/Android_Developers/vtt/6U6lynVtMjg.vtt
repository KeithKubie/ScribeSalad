WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.772
[MUSIC PLAYING]

00:00:03.550 --> 00:00:04.780
RAPH LEVIEN: I'm Raph Levien.

00:00:04.780 --> 00:00:06.364
I'm on the Android
UI Toolkit team,

00:00:06.364 --> 00:00:07.780
and I'm going to
talk to you today

00:00:07.780 --> 00:00:09.900
about Android textual layout.

00:00:09.900 --> 00:00:12.890
And I hope you'll find
this an interesting talk,

00:00:12.890 --> 00:00:15.360
and I hope you brought
lots of questions as well.

00:00:15.360 --> 00:00:18.590
And I'm happy to address
those after the session

00:00:18.590 --> 00:00:21.260
and also at office
hours this afternoon.

00:00:23.960 --> 00:00:26.620
So I'm going to talk
about-- it's kind of a grab

00:00:26.620 --> 00:00:29.180
bag of a bunch of different
topics around text

00:00:29.180 --> 00:00:31.344
and typography on Android.

00:00:31.344 --> 00:00:33.260
I'm going to talk about
some of the challenges

00:00:33.260 --> 00:00:34.990
and opportunities.

00:00:34.990 --> 00:00:37.910
Just a little bit of an
introduction to material

00:00:37.910 --> 00:00:41.420
design, which I'm sure everybody
here is quite familiar with.

00:00:41.420 --> 00:00:45.550
Then I'm going to go into some
of the details about the Roboto

00:00:45.550 --> 00:00:48.400
2 and Noto fonts, and
especially the kind of more

00:00:48.400 --> 00:00:51.200
recent changes around
these to better support

00:00:51.200 --> 00:00:52.560
international typography.

00:00:52.560 --> 00:00:56.190
A huge amount of the work that
we do on the Android UI Toolkit

00:00:56.190 --> 00:00:59.290
team is supporting all of
the languages of the world,

00:00:59.290 --> 00:01:01.301
or most of them.

00:01:01.301 --> 00:01:03.550
Then I'm going to go into
some of the really, I think,

00:01:03.550 --> 00:01:07.620
exciting newer features
around OpenType

00:01:07.620 --> 00:01:11.600
typography control and high
quality paragraph layout,

00:01:11.600 --> 00:01:15.530
which rolled out in
Lollipop and Marshmallow.

00:01:15.530 --> 00:01:18.290
So what are some of the
challenges and opportunities?

00:01:18.290 --> 00:01:21.340
I mean, I come from
a print background.

00:01:21.340 --> 00:01:25.160
And doing typography
on mobile is

00:01:25.160 --> 00:01:28.164
extremely different than
doing typography on print.

00:01:28.164 --> 00:01:30.580
There are some things in common,
but there are some things

00:01:30.580 --> 00:01:32.450
that are really different.

00:01:32.450 --> 00:01:39.260
You have to be very focused
on the performance of the text

00:01:39.260 --> 00:01:41.880
stack because you've got
only so much battery and only

00:01:41.880 --> 00:01:42.890
so much RAM.

00:01:42.890 --> 00:01:45.490
But you really do have very
powerful compute resources.

00:01:45.490 --> 00:01:48.300
You've got multi-core,
multi-gigahertz processes

00:01:48.300 --> 00:01:49.130
in there.

00:01:49.130 --> 00:01:51.430
So if you want to do
sophisticated, advanced

00:01:51.430 --> 00:01:55.300
typography, you do have the
compute power to do that.

00:01:55.300 --> 00:01:58.810
60 frames a second is
absolutely a requirement.

00:01:58.810 --> 00:02:01.840
And this is, again, both a
challenge and an opportunity

00:02:01.840 --> 00:02:04.570
that you can do these
really rich animations

00:02:04.570 --> 00:02:07.820
and transitions, and do this
kind of interactive motion

00:02:07.820 --> 00:02:10.669
typography that
really is completely

00:02:10.669 --> 00:02:12.590
impossible in a
print background.

00:02:12.590 --> 00:02:14.360
But you have to
make everything fit

00:02:14.360 --> 00:02:17.440
in that 16 millisecond budget.

00:02:17.440 --> 00:02:19.080
You've got a very small screen.

00:02:19.080 --> 00:02:21.420
And this has some
interesting challenges

00:02:21.420 --> 00:02:23.030
in how you create
your layouts, how

00:02:23.030 --> 00:02:26.380
you do the paragraph layout.

00:02:26.380 --> 00:02:29.130
But a flipside, again, is
that on modern devices,

00:02:29.130 --> 00:02:31.740
you have this very
high resolution.

00:02:31.740 --> 00:02:34.240
Then, as I mentioned,
we have this requirement

00:02:34.240 --> 00:02:37.374
to support all of the
languages of the world, all

00:02:37.374 --> 00:02:38.540
of the scripts of the world.

00:02:38.540 --> 00:02:40.960
But we have a lot of
really good resources

00:02:40.960 --> 00:02:45.220
both in fonts and typography
control of how you do that.

00:02:45.220 --> 00:02:47.534
And then I'm going
to talk about some

00:02:47.534 --> 00:02:48.950
of the line breaking
improvements,

00:02:48.950 --> 00:02:51.324
some of the paragraph layout
improvements in Marshmallow.

00:02:51.324 --> 00:02:53.400
And those were really
motivated by a need

00:02:53.400 --> 00:02:55.580
to get this working
in very small screens,

00:02:55.580 --> 00:02:58.270
like watch faces.

00:02:58.270 --> 00:03:02.480
So I'm going to just introduce
this concept of the advance

00:03:02.480 --> 00:03:03.440
of display technology.

00:03:03.440 --> 00:03:05.150
This was the first
mobile device I ever

00:03:05.150 --> 00:03:07.130
had when I was 12 years old.

00:03:07.130 --> 00:03:10.570
And as you can see, it's
got a lot of the elements

00:03:10.570 --> 00:03:12.635
of a modern mobile device.

00:03:12.635 --> 00:03:17.800
It even has a really
nice, big keyboard.

00:03:17.800 --> 00:03:22.260
But the display technology in
this generation of technology

00:03:22.260 --> 00:03:24.260
is kind of the bare
minimum that you need

00:03:24.260 --> 00:03:26.160
to get text displayed at all.

00:03:26.160 --> 00:03:29.750
And I think that that
evolution kind of carried

00:03:29.750 --> 00:03:31.740
that there was a very
primitive approach

00:03:31.740 --> 00:03:35.520
to just get the letters
drawn on the screen

00:03:35.520 --> 00:03:38.020
and not really think
about typography.

00:03:38.020 --> 00:03:39.700
Another good thing
about this screenshot

00:03:39.700 --> 00:03:42.500
is you get some sense of the
difference in computing power

00:03:42.500 --> 00:03:46.550
available today as back then.

00:03:46.550 --> 00:03:50.760
So before I worked
on Android, I was

00:03:50.760 --> 00:03:54.030
working on Google web
fonts, Google Fonts.

00:03:54.030 --> 00:03:58.050
And the upper left corner is
kind of your classic laptop

00:03:58.050 --> 00:03:58.920
or desktop screen.

00:03:58.920 --> 00:04:01.000
And this really
ruled what we did,

00:04:01.000 --> 00:04:03.620
that you have a very
small number of pixels

00:04:03.620 --> 00:04:05.580
to represent the text.

00:04:05.580 --> 00:04:07.220
And you have a
lot of constraints

00:04:07.220 --> 00:04:10.990
in how the letterforms
map into those pixels.

00:04:10.990 --> 00:04:13.060
And that also
includes the spacing.

00:04:13.060 --> 00:04:16.691
You see very poor-- like the a
and p are crunched up together,

00:04:16.691 --> 00:04:18.649
and the p and o are
separated, because you only

00:04:18.649 --> 00:04:21.390
have so many pixels
and so much precision.

00:04:21.390 --> 00:04:25.220
But as you go into more
modern display technology,

00:04:25.220 --> 00:04:27.570
you have so many more pixels.

00:04:27.570 --> 00:04:30.700
And so on the upper right,
you have a 4k monitor, which

00:04:30.700 --> 00:04:33.870
is starting to replace laptops.

00:04:33.870 --> 00:04:35.710
And on the lower
left, this isn't even

00:04:35.710 --> 00:04:37.030
the most recent device.

00:04:37.030 --> 00:04:41.150
This is a two-year-old
device and it has 468 ppi.

00:04:41.150 --> 00:04:44.180
And you probably can't
even see the pixels here.

00:04:44.180 --> 00:04:47.610
And then comparing that to,
for example, an inkjet printer,

00:04:47.610 --> 00:04:49.830
you actually have, on
these mobile devices,

00:04:49.830 --> 00:04:53.440
you have a much higher
precision, higher quality

00:04:53.440 --> 00:04:56.980
representation of the
shapes of the letter forms

00:04:56.980 --> 00:04:58.250
and the spaces between them.

00:04:58.250 --> 00:05:00.510
So it really enables typography.

00:05:00.510 --> 00:05:05.260
And all four of these
screen shots or captures

00:05:05.260 --> 00:05:09.260
are of the same 12
point Times Roman.

00:05:09.260 --> 00:05:11.300
And so this is what we
have to work with today.

00:05:11.300 --> 00:05:13.650
This is our lead
device, the Nexus 6P.

00:05:13.650 --> 00:05:15.600
It's an amazing device.

00:05:15.600 --> 00:05:19.720
And it has an amazing screen
to match the overall device.

00:05:19.720 --> 00:05:21.990
It's at 515 ppi.

00:05:21.990 --> 00:05:25.100
One of the ways I think
about screen resolution

00:05:25.100 --> 00:05:29.430
is when Star Trek-- when they
were doing the Star Trek TV

00:05:29.430 --> 00:05:32.390
show, they had a book that
had all of the specifications

00:05:32.390 --> 00:05:34.540
for all of the technology,
like how many terajoules

00:05:34.540 --> 00:05:36.080
were in a phasor pulse.

00:05:36.080 --> 00:05:38.200
And one of the
specifications is what

00:05:38.200 --> 00:05:41.430
is the resolution of
these little devices

00:05:41.430 --> 00:05:43.030
that people are carrying around?

00:05:43.030 --> 00:05:44.960
And the answer is 400 dpi.

00:05:44.960 --> 00:05:50.580
So we've blown way
past Star Trek.

00:05:50.580 --> 00:05:54.270
So as I say, everybody here
knows about material design.

00:05:54.270 --> 00:05:57.280
This will just touch
on it that the UX team,

00:05:57.280 --> 00:05:58.930
it started really
about two years ago

00:05:58.930 --> 00:06:02.500
that they were looking at these
more powerful devices, higher

00:06:02.500 --> 00:06:03.790
quality display technologies.

00:06:03.790 --> 00:06:07.680
And they were really thinking,
if we were redesigning this

00:06:07.680 --> 00:06:12.260
from scratch, if we really could
do anything, what would we do?

00:06:12.260 --> 00:06:15.300
And the result of
that exploration

00:06:15.300 --> 00:06:18.690
really synthesized into
a set of guidelines,

00:06:18.690 --> 00:06:22.530
into a coherent design
language that incorporates

00:06:22.530 --> 00:06:23.890
many different elements.

00:06:23.890 --> 00:06:28.040
It incorporates
colors, it incorporates

00:06:28.040 --> 00:06:30.740
the material
metaphors with paper,

00:06:30.740 --> 00:06:34.090
and kind of a three
dimensional effect.

00:06:34.090 --> 00:06:37.210
And it also
incorporates typography.

00:06:37.210 --> 00:06:42.020
And so one of the sections
in the material design

00:06:42.020 --> 00:06:48.810
spec I really recommend, it
has a lot of good information

00:06:48.810 --> 00:06:51.800
and a lot of good guidance
about how to do typography

00:06:51.800 --> 00:06:53.560
within material design.

00:06:53.560 --> 00:06:55.420
And of course,
another part of that

00:06:55.420 --> 00:07:00.460
is a much greater expanded
palette of different weights

00:07:00.460 --> 00:07:04.880
and of different sizes, and how
you use the weight and size.

00:07:04.880 --> 00:07:07.280
Instead of having just one
size of text, one weight,

00:07:07.280 --> 00:07:10.010
you use this to
indicate the structure

00:07:10.010 --> 00:07:14.100
of your app, the structure of
the information in your app.

00:07:14.100 --> 00:07:18.760
So the cornerstone of
typography in material design

00:07:18.760 --> 00:07:20.560
is the Roboto 2 typeface.

00:07:20.560 --> 00:07:23.690
And so this was an update
that happened in Lollipop.

00:07:23.690 --> 00:07:25.820
And it was pretty subtle.

00:07:25.820 --> 00:07:28.400
A lot of people probably
didn't even notice it.

00:07:28.400 --> 00:07:31.650
But there was actually a
lot going on in this update.

00:07:31.650 --> 00:07:34.380
So one of the things is the
expanded Unicode coverage.

00:07:34.380 --> 00:07:37.500
It actually increased
by a factor of three.

00:07:37.500 --> 00:07:40.770
And we have full
support for Unicode 8

00:07:40.770 --> 00:07:44.040
for Latin, Greek,
and Cyrillic scripts.

00:07:44.040 --> 00:07:49.130
And that covers a lot of the
languages in the world that

00:07:49.130 --> 00:07:52.420
are maybe less familiar to us,
like the African languages use

00:07:52.420 --> 00:07:55.970
a lot of unusual
Latin characters.

00:07:55.970 --> 00:07:58.070
We also expanded the
weights and styles

00:07:58.070 --> 00:07:59.260
that we ship on the device.

00:07:59.260 --> 00:08:02.170
So we're doing thin, light,
regular, medium, bold,

00:08:02.170 --> 00:08:02.780
and black.

00:08:02.780 --> 00:08:06.592
So there's a tremendous
palette of the visual effects

00:08:06.592 --> 00:08:07.300
that you can get.

00:08:07.300 --> 00:08:09.630
And all of those
include true italics.

00:08:09.630 --> 00:08:11.630
And we also have a
family of condensed,

00:08:11.630 --> 00:08:15.050
which is better for better
information density,

00:08:15.050 --> 00:08:17.340
and also can give
you some contrast.

00:08:17.340 --> 00:08:23.090
Two different styles that you
can work with in your app.

00:08:23.090 --> 00:08:27.060
In addition, the Roboto 2 font
is completely open source.

00:08:27.060 --> 00:08:30.990
And that includes not just the
final true type font files,

00:08:30.990 --> 00:08:32.210
but the entire build chain.

00:08:32.210 --> 00:08:35.890
So you can go in there and
customize it and play with it

00:08:35.890 --> 00:08:37.070
and send us pull requests.

00:08:37.070 --> 00:08:40.150
And we really treat
almost everything

00:08:40.150 --> 00:08:46.110
we do in a very
open source manner.

00:08:46.110 --> 00:08:48.630
So the design updated as well.

00:08:48.630 --> 00:08:51.260
And this is just a little
bit of a before and after.

00:08:51.260 --> 00:08:53.500
And you can see it's
a little subtle,

00:08:53.500 --> 00:08:56.800
but there's kind of
a stiff sides to some

00:08:56.800 --> 00:08:59.150
of the characters,
like a capital O.

00:08:59.150 --> 00:09:02.620
And that has become a more
refined, gentle curve.

00:09:02.620 --> 00:09:05.030
Some of the shapes were
maybe a little bit unusual,

00:09:05.030 --> 00:09:07.790
like the K's and the
capital R. And those

00:09:07.790 --> 00:09:10.890
have become more simplified
and more streamlined.

00:09:10.890 --> 00:09:14.210
And we also went from
a square dot on the i's

00:09:14.210 --> 00:09:16.070
and j's to a round dot.

00:09:16.070 --> 00:09:17.570
So it's an evolution.

00:09:17.570 --> 00:09:24.050
It's a more refined form
of the original design.

00:09:24.050 --> 00:09:28.420
It's very central to Android
and very central, of course,

00:09:28.420 --> 00:09:30.860
to material design.

00:09:30.860 --> 00:09:33.500
So I talked about the
global reach of Android.

00:09:33.500 --> 00:09:36.630
And we talk a lot about
the next billion users.

00:09:36.630 --> 00:09:43.540
And they're-- like we heard
in the previous talk, about,

00:09:43.540 --> 00:09:46.510
how do you reach them through
the Play Store console?

00:09:46.510 --> 00:09:48.280
But there's also a
lot that you have

00:09:48.280 --> 00:09:51.300
to do with the presentation
of text and language

00:09:51.300 --> 00:09:52.720
in these devices.

00:09:52.720 --> 00:09:57.020
So again, Roboto 2 dramatically
increases the Unicode coverage.

00:09:57.020 --> 00:09:58.780
And you can see, this
is just a sample.

00:09:58.780 --> 00:10:03.460
This is just one of the pages
of additional extended Latin

00:10:03.460 --> 00:10:03.960
characters.

00:10:03.960 --> 00:10:07.950
And another thing I'll point
out, just for this slide,

00:10:07.950 --> 00:10:11.342
like if you look kind
of near the middle

00:10:11.342 --> 00:10:12.800
towards the left-hand
side, you see

00:10:12.800 --> 00:10:17.730
some O's with some
doubly stacked accents.

00:10:17.730 --> 00:10:21.030
And that's a very common
pattern in a lot of languages,

00:10:21.030 --> 00:10:23.580
but not European languages
that we're used to.

00:10:23.580 --> 00:10:26.630
So you see it in Vietnamese and
some of these other languages.

00:10:26.630 --> 00:10:29.560
So you really-- when
you're designing your apps,

00:10:29.560 --> 00:10:31.340
when you're testing
your apps, you really

00:10:31.340 --> 00:10:34.040
need to be careful
to test them in some

00:10:34.040 --> 00:10:36.220
of these other languages
to make sure that you've

00:10:36.220 --> 00:10:37.800
got enough vertical space.

00:10:37.800 --> 00:10:42.130
This is one of the
real key takeaways

00:10:42.130 --> 00:10:43.589
that if you just
design in English,

00:10:43.589 --> 00:10:46.046
you've got these letters, they
don't have anything going on

00:10:46.046 --> 00:10:48.260
above, they don't have
anything going on below.

00:10:48.260 --> 00:10:53.470
But that is not the
experience of millions,

00:10:53.470 --> 00:10:56.720
hundreds of millions of
people around the world.

00:10:56.720 --> 00:10:59.280
So in addition to Latin,
Greek, and Cyrillic,

00:10:59.280 --> 00:11:01.820
there's this huge diversity
of other languages.

00:11:01.820 --> 00:11:04.700
And in fact, this is the list
of scripts, not even languages.

00:11:04.700 --> 00:11:07.990
There's many scripts that
support multiple languages.

00:11:07.990 --> 00:11:10.540
These are the Noto
scripts that we're

00:11:10.540 --> 00:11:11.910
supporting in Marshmallow.

00:11:11.910 --> 00:11:16.730
So it really is a huge expansion
compared with previous versions

00:11:16.730 --> 00:11:17.730
of Android.

00:11:17.730 --> 00:11:21.850
And it really covers a very
large fraction of the languages

00:11:21.850 --> 00:11:23.780
that are spoken in the world.

00:11:23.780 --> 00:11:26.590
And so here are three scripts
that I just kind of picked out

00:11:26.590 --> 00:11:29.490
as representative.

00:11:29.490 --> 00:11:31.430
I find these just
really beautiful.

00:11:31.430 --> 00:11:35.580
And you can see attention
between classical forms,

00:11:35.580 --> 00:11:38.910
but also trying to make them
consistent with the kind

00:11:38.910 --> 00:11:43.210
of clean Roboto design.

00:11:43.210 --> 00:11:45.680
And so I think these
three are either

00:11:45.680 --> 00:11:48.715
new in either
Marshmallow or Lollipop.

00:11:51.370 --> 00:11:56.450
So then, in addition to
this large set of scripts,

00:11:56.450 --> 00:11:58.980
CJK, Chinese,
Japanese, and Korean,

00:11:58.980 --> 00:12:05.070
represent a very large fraction
of the users of Android.

00:12:05.070 --> 00:12:07.180
A lot of the users in the world.

00:12:07.180 --> 00:12:11.570
And so in Lollipop, we
launched Noto CJK, which

00:12:11.570 --> 00:12:13.980
is a joint project with Adobe.

00:12:13.980 --> 00:12:16.690
So it's also out
there-- they released it

00:12:16.690 --> 00:12:18.286
as source Hans Sans.

00:12:18.286 --> 00:12:19.910
And that's also an
open source project.

00:12:19.910 --> 00:12:20.700
And it has a tracker.

00:12:20.700 --> 00:12:21.470
It's very active.

00:12:21.470 --> 00:12:27.910
People find issues and
it's being revised.

00:12:27.910 --> 00:12:31.900
And in addition,
to just the fonts,

00:12:31.900 --> 00:12:34.420
that project also
brought with it

00:12:34.420 --> 00:12:36.610
a high quality
renderer for something

00:12:36.610 --> 00:12:39.290
called CFF, Compact Font Format.

00:12:39.290 --> 00:12:42.140
And this is based
on the Adobe code,

00:12:42.140 --> 00:12:44.870
but it's now been open
sourced as part of free type.

00:12:44.870 --> 00:12:49.490
So you can go look at the code,
use that in your own projects

00:12:49.490 --> 00:12:50.740
as well.

00:12:50.740 --> 00:12:53.910
So Noto CJK is a very
ambitious project

00:12:53.910 --> 00:12:57.610
that really is designed to
be a comprehensive support

00:12:57.610 --> 00:13:01.130
font to support all of CJK.

00:13:01.130 --> 00:13:07.170
And that includes the
different local forms.

00:13:07.170 --> 00:13:10.040
So there's a difference between
simplified and traditional

00:13:10.040 --> 00:13:10.930
Chinese.

00:13:10.930 --> 00:13:12.590
Those are different
from Japanese.

00:13:12.590 --> 00:13:14.350
And then there are
some glyphs that

00:13:14.350 --> 00:13:15.540
appear different in Korean.

00:13:15.540 --> 00:13:17.750
And it's very important
to these users

00:13:17.750 --> 00:13:20.130
to see the correct
form in their language.

00:13:20.130 --> 00:13:25.130
If you see it wrong, it
really is a polish problem.

00:13:25.130 --> 00:13:27.490
So notice CJK has
a unified design.

00:13:27.490 --> 00:13:30.070
There's like a consistent--
like there's some releases

00:13:30.070 --> 00:13:32.650
that we've done where the
Chinese and Japanese really

00:13:32.650 --> 00:13:36.070
don't look like they're part
of the same family of fonts.

00:13:36.070 --> 00:13:39.640
And in Noto CJK, we really
have a unified design,

00:13:39.640 --> 00:13:41.610
but we have the
different variants

00:13:41.610 --> 00:13:44.810
in the different regions.

00:13:44.810 --> 00:13:47.880
So no discussion of
text is complete today

00:13:47.880 --> 00:13:50.380
without talking about emoji.

00:13:50.380 --> 00:13:54.710
And we really treat
emoji as a type of text.

00:13:54.710 --> 00:13:57.430
So an app doesn't have
to do anything special.

00:13:57.430 --> 00:14:02.100
An app doesn't have to say, oh,
show me some color images here

00:14:02.100 --> 00:14:03.270
or something like that.

00:14:03.270 --> 00:14:06.460
You just represent text and you
ask for the text to be drawn,

00:14:06.460 --> 00:14:08.600
or in a text view, or edited.

00:14:08.600 --> 00:14:12.370
And it just automatically
shows up using this color font

00:14:12.370 --> 00:14:16.780
technology which is now
standardized in OpenType 1.7.

00:14:16.780 --> 00:14:18.400
And there are
actually many tools,

00:14:18.400 --> 00:14:22.920
many font editors
actually will create fonts

00:14:22.920 --> 00:14:24.510
in this emoji form.

00:14:24.510 --> 00:14:29.410
So if you want to-- or I should
say, in a color font form.

00:14:29.410 --> 00:14:34.280
Whether it's used for emoji
or not is really up to you.

00:14:34.280 --> 00:14:38.350
And you can incorporate these
custom fonts in your app

00:14:38.350 --> 00:14:43.020
and get color representation
of either emoji or text

00:14:43.020 --> 00:14:45.600
just by dropping in the font.

00:14:45.600 --> 00:14:48.400
This also supports
flags and keycaps.

00:14:48.400 --> 00:14:52.480
It's a more expanded
set of emoji.

00:14:52.480 --> 00:14:55.140
And one of the new API's--
I should say this is

00:14:55.140 --> 00:14:57.440
a Marshmallow API.

00:14:57.440 --> 00:15:01.109
In a lot of apps, you want to
know what emoji are present,

00:15:01.109 --> 00:15:03.400
because you want to make a
decision do you present this

00:15:03.400 --> 00:15:06.920
as a palette for
users to choose.

00:15:06.920 --> 00:15:08.660
And this has always
been a problem

00:15:08.660 --> 00:15:11.560
because different phones will
have different emoji sets.

00:15:11.560 --> 00:15:14.910
And as we're upgrading,
it's hard to know,

00:15:14.910 --> 00:15:16.660
is this emoji present
or not, or does

00:15:16.660 --> 00:15:20.309
this flag exist, in the
case of the flag emoji.

00:15:20.309 --> 00:15:22.350
And so we've got this new
API that will tell you.

00:15:22.350 --> 00:15:25.380
It's very fast and we
really recommend-- we really

00:15:25.380 --> 00:15:27.290
want you to be using
hasGlyph so you

00:15:27.290 --> 00:15:33.160
know what emoji are on your
device, what you can use.

00:15:33.160 --> 00:15:34.950
So then I want to
talk about some

00:15:34.950 --> 00:15:36.620
of the typography features.

00:15:36.620 --> 00:15:38.130
We've really been
expanding this.

00:15:38.130 --> 00:15:41.730
The goal-- my goal
certainly-- is to make Android

00:15:41.730 --> 00:15:45.710
typography match what
you can do on the web

00:15:45.710 --> 00:15:48.450
and match what you can do not
just in print, but like really

00:15:48.450 --> 00:15:49.300
high quality print.

00:15:49.300 --> 00:15:51.258
And so I'll walk you
through some of the things

00:15:51.258 --> 00:15:53.606
that we do here.

00:15:53.606 --> 00:15:55.230
I'll just go through
this list and then

00:15:55.230 --> 00:15:57.479
I'll show some
examples that we have.

00:15:57.479 --> 00:15:59.020
Kerning and ligatures,
we've actually

00:15:59.020 --> 00:16:03.160
had those since, I
think, Jelly Bean MR2.

00:16:03.160 --> 00:16:04.444
But now there's more control.

00:16:04.444 --> 00:16:06.110
So if you want to
turn those on and off,

00:16:06.110 --> 00:16:08.330
there's fine grain
control to do that.

00:16:08.330 --> 00:16:14.200
We have this font feature
settings attribute

00:16:14.200 --> 00:16:17.990
where you really can go in and
control the OpenType features.

00:16:17.990 --> 00:16:20.360
I'll give you several
examples of that.

00:16:20.360 --> 00:16:22.470
And that's using a
CSS-compatible syntax.

00:16:22.470 --> 00:16:26.520
So we want to make this stuff
so if your designers are used

00:16:26.520 --> 00:16:29.420
to controlling
typography on the web,

00:16:29.420 --> 00:16:33.450
we want to make impedance
mismatch as smooth as possible.

00:16:33.450 --> 00:16:36.980
So you can just
take that knowledge

00:16:36.980 --> 00:16:38.225
and apply it to Android apps.

00:16:38.225 --> 00:16:40.350
And then this is a little
bit more technical thing,

00:16:40.350 --> 00:16:44.690
but we use OpenType integrally
to give you these localized

00:16:44.690 --> 00:16:47.640
forms that-- there are many
languages, certainly not

00:16:47.640 --> 00:16:50.360
just the Chinese, Japanese,
and Korean, where there's going

00:16:50.360 --> 00:16:52.610
to be some subtle differences.

00:16:52.610 --> 00:16:54.890
The same basic script,
but differences in the way

00:16:54.890 --> 00:16:55.910
it's presented.

00:16:55.910 --> 00:16:58.030
And we use OpenType
to control that.

00:16:58.030 --> 00:17:01.510
And I'll talk a little
bit also about what

00:17:01.510 --> 00:17:05.099
you want to do in your app
to make that work perfectly.

00:17:05.099 --> 00:17:06.250
So kerning and ligature.

00:17:06.250 --> 00:17:10.310
So the fi ligature is a little
controversial in Roboto.

00:17:10.310 --> 00:17:12.510
Not everybody loves this.

00:17:12.510 --> 00:17:18.760
But it is definitely a sign of
more sophisticated typography

00:17:18.760 --> 00:17:21.619
that you don't just put the
letters that, in some cases,

00:17:21.619 --> 00:17:23.230
you have these combinations.

00:17:23.230 --> 00:17:24.990
And you have a
specifically drawing glyph

00:17:24.990 --> 00:17:27.240
that represents more
than one letter.

00:17:27.240 --> 00:17:31.230
And this is certainly--
this exists in Roboto.

00:17:31.230 --> 00:17:35.460
And it's a very important part,
like especially in serif fonts.

00:17:35.460 --> 00:17:37.530
You really need those
ligatures for the font

00:17:37.530 --> 00:17:38.580
to display correctly.

00:17:38.580 --> 00:17:42.590
So if, again, as you're using
custom fonts in your app,

00:17:42.590 --> 00:17:44.130
you want those ligatures.

00:17:44.130 --> 00:17:45.880
And the same is
true for kerning.

00:17:45.880 --> 00:17:47.630
You almost never want
to turn this off.

00:17:47.630 --> 00:17:49.421
The only time you might
want to turn it off

00:17:49.421 --> 00:17:51.590
is if you've got some kind
of technical alignment

00:17:51.590 --> 00:17:55.080
where things need to have the
consistent with no matter what

00:17:55.080 --> 00:17:57.230
the characters are.

00:17:57.230 --> 00:18:00.620
But in any case, as of
M, with the font feature

00:18:00.620 --> 00:18:04.090
setting attribute,
you can control these.

00:18:04.090 --> 00:18:06.490
These are actually implemented
as OpenType features.

00:18:06.490 --> 00:18:09.180
And as with any
OpenType feature,

00:18:09.180 --> 00:18:11.940
you can turn it on or off
with fontFeatureSettings.

00:18:11.940 --> 00:18:16.990
And that's actually
a Lollipop Plus API.

00:18:16.990 --> 00:18:21.640
So another great hidden feature
is the user proportional

00:18:21.640 --> 00:18:23.330
and old style numbers.

00:18:23.330 --> 00:18:26.610
And these are really
important for a more refined,

00:18:26.610 --> 00:18:28.600
sophisticated typography.

00:18:28.600 --> 00:18:31.150
That the default
numbers are basically

00:18:31.150 --> 00:18:34.420
the same size as capitals, and
they're all the same width.

00:18:34.420 --> 00:18:36.890
And being the same width
is really important

00:18:36.890 --> 00:18:39.600
if you've got some kind
of animated display.

00:18:39.600 --> 00:18:41.680
You don't want it to be
juddering back and forth.

00:18:41.680 --> 00:18:44.170
Or if you've got a tabular
presentation of numbers

00:18:44.170 --> 00:18:45.180
like a spreadsheet.

00:18:45.180 --> 00:18:47.610
But it's not always
the prettiest display.

00:18:47.610 --> 00:18:49.320
And if you're
doing running text,

00:18:49.320 --> 00:18:52.070
if you're doing
paragraphs of text,

00:18:52.070 --> 00:18:55.500
then proportional may
be a more subtle change

00:18:55.500 --> 00:18:58.840
where you just give the
one a little bit narrower

00:18:58.840 --> 00:19:00.844
so you don't have all
this space around it.

00:19:00.844 --> 00:19:03.510
And then if you're really trying
to do something that looks more

00:19:03.510 --> 00:19:05.900
like a book, something
that looks more

00:19:05.900 --> 00:19:08.020
like traditional
typography, then you've

00:19:08.020 --> 00:19:10.460
got these old style figures.

00:19:10.460 --> 00:19:12.500
And those are in Roboto 2.

00:19:12.500 --> 00:19:13.800
Those are present in the font.

00:19:13.800 --> 00:19:16.000
And you use the Android
fontFeatureSettings

00:19:16.000 --> 00:19:20.580
to select pnum, proportional
numbers, or onum, old style

00:19:20.580 --> 00:19:21.440
figures.

00:19:21.440 --> 00:19:25.530
And again, highly recommended
if you're bringing custom fonts

00:19:25.530 --> 00:19:30.820
into your app that you have
the complete access to all

00:19:30.820 --> 00:19:34.790
of the OpenType
features in those fonts.

00:19:34.790 --> 00:19:38.280
And this is, again,
an L Plus feature.

00:19:38.280 --> 00:19:42.310
Another feature that
I think is really

00:19:42.310 --> 00:19:47.140
a powerful tool for bringing
more sophisticated design

00:19:47.140 --> 00:19:50.270
to apps is control
over letter spacing.

00:19:50.270 --> 00:19:51.890
So there's the default
letter spacing.

00:19:51.890 --> 00:19:56.230
It's really tuned
for legibility.

00:19:56.230 --> 00:19:58.990
People are getting
information on their phone.

00:19:58.990 --> 00:20:01.670
They need to be able
to read it quickly.

00:20:01.670 --> 00:20:04.354
And that's what the default
letter spacing is tuned for.

00:20:04.354 --> 00:20:05.770
But if you've got
something that's

00:20:05.770 --> 00:20:08.370
kind of larger,
more of a branding

00:20:08.370 --> 00:20:12.380
and less of a
functional element,

00:20:12.380 --> 00:20:17.150
then spacing it a little tighter
might kind of highlight that.

00:20:17.150 --> 00:20:19.770
And then you can
also use wide spacing

00:20:19.770 --> 00:20:23.580
as maybe a form of emphasis
or just bringing a little bit

00:20:23.580 --> 00:20:25.980
more breath to your design.

00:20:25.980 --> 00:20:29.210
So you have-- you're
no longer stuck

00:20:29.210 --> 00:20:33.290
with just the default spacing
that's set in your font.

00:20:33.290 --> 00:20:36.630
And again, that's
an L Plus feature.

00:20:36.630 --> 00:20:40.090
So in Marshmallow, this is
really one of the things

00:20:40.090 --> 00:20:45.150
I'm most excited about,
that we really stepped up

00:20:45.150 --> 00:20:47.390
the paragraph layout.

00:20:47.390 --> 00:20:51.945
And the old algorithm
used-- you fill up a line,

00:20:51.945 --> 00:20:53.570
and then when once
you get to the point

00:20:53.570 --> 00:20:57.250
where the line is full, then you
just break at the word boundary

00:20:57.250 --> 00:20:58.220
and you keep going.

00:20:58.220 --> 00:21:02.580
But in Marshmallow, we have this
high quality paragraph layout

00:21:02.580 --> 00:21:03.650
mode.

00:21:03.650 --> 00:21:06.630
And it incorporates a couple
of different elements.

00:21:06.630 --> 00:21:09.690
It incorporates
automatic hyphenation.

00:21:09.690 --> 00:21:12.360
And it also incorporates this
concept of whole paragraph

00:21:12.360 --> 00:21:13.160
optimization.

00:21:13.160 --> 00:21:15.540
So it kind of
moves pieces around

00:21:15.540 --> 00:21:18.180
to get like a best score.

00:21:18.180 --> 00:21:21.860
There's kind of a
score that tells you,

00:21:21.860 --> 00:21:23.325
what is the quality
of this layout?

00:21:23.325 --> 00:21:24.950
And it's really trying
to optimize that

00:21:24.950 --> 00:21:26.790
across the entire paragraph.

00:21:26.790 --> 00:21:28.710
Both of these
algorithms are based

00:21:28.710 --> 00:21:32.820
on TeX, which is a print
typography package.

00:21:32.820 --> 00:21:34.400
It has a very long history.

00:21:34.400 --> 00:21:41.620
And high end print publishing
tools use this same approach.

00:21:41.620 --> 00:21:44.520
But the parameters-- like
when do you use hyphens?

00:21:44.520 --> 00:21:46.030
Hyphens are a little bit weird.

00:21:46.030 --> 00:21:49.460
People are not used to seeing
them on a mobile device.

00:21:49.460 --> 00:21:52.850
There's some contexts where
they make a lot of sense,

00:21:52.850 --> 00:21:55.219
like if you're displaying
an e-book, for example.

00:21:55.219 --> 00:21:56.760
And there's some
where maybe it makes

00:21:56.760 --> 00:21:59.800
a little less sense, like UI
strings or maybe chat messages.

00:21:59.800 --> 00:22:02.330
People are not used to
seeing hyphens there.

00:22:02.330 --> 00:22:06.660
So we tuned the
parameters-- its heuristics.

00:22:06.660 --> 00:22:13.710
And we kind of chose these
so that a couple of things

00:22:13.710 --> 00:22:14.830
that people were noticing.

00:22:14.830 --> 00:22:18.290
That if you hyphenate and
you break a partial word

00:22:18.290 --> 00:22:22.330
onto the last line,
that is really weird.

00:22:22.330 --> 00:22:25.700
That's something that people
have a negative reaction to.

00:22:25.700 --> 00:22:29.440
So there's a parameter in
the tuning that kind of

00:22:29.440 --> 00:22:31.270
doesn't do that very often.

00:22:31.270 --> 00:22:33.940
But on the other hand,
one of the reasons

00:22:33.940 --> 00:22:35.609
why you want to do
this hyphenation

00:22:35.609 --> 00:22:37.650
and want to do this high
quality paragraph layout

00:22:37.650 --> 00:22:40.370
is you want better
information density.

00:22:40.370 --> 00:22:42.160
This is especially
important when

00:22:42.160 --> 00:22:45.260
you have very narrow settings,
and especially true on very

00:22:45.260 --> 00:22:47.500
small screens like watch faces.

00:22:47.500 --> 00:22:51.120
That if you break a word,
and you leave a huge amount

00:22:51.120 --> 00:22:53.480
of empty space, that's waste.

00:22:53.480 --> 00:22:56.140
That's an opportunity that
you could have used that space

00:22:56.140 --> 00:22:57.920
to present information.

00:22:57.920 --> 00:23:02.680
So we really look at this
question of would hyphenation

00:23:02.680 --> 00:23:07.180
bring you end lines
down to n minus 1

00:23:07.180 --> 00:23:08.290
by doing the hyphenation?

00:23:08.290 --> 00:23:10.960
And in that case, we say, yes.

00:23:10.960 --> 00:23:11.930
You do want that.

00:23:11.930 --> 00:23:13.810
You don't want to
waste that space.

00:23:13.810 --> 00:23:16.040
You want more
information density.

00:23:16.040 --> 00:23:17.870
And that increases
the chance that you'll

00:23:17.870 --> 00:23:19.470
get a hyphen on there.

00:23:19.470 --> 00:23:23.650
So this is kind of
a different tuning

00:23:23.650 --> 00:23:25.190
than you would
expect for something

00:23:25.190 --> 00:23:28.110
like print typography, which is
where there's kind of the most

00:23:28.110 --> 00:23:31.950
tradition of doing hyphenation.

00:23:31.950 --> 00:23:34.680
So one of the other
things we looked at

00:23:34.680 --> 00:23:36.690
is this question,
do we want to have

00:23:36.690 --> 00:23:41.300
an opt-in where your app says,
yes, I want high quality mode.

00:23:41.300 --> 00:23:44.130
But maybe it's
considered expensive.

00:23:44.130 --> 00:23:47.270
You know, it's too
slow to run or we

00:23:47.270 --> 00:23:48.770
don't want to always have it.

00:23:48.770 --> 00:23:51.486
But we tried turning it on
across the entire system

00:23:51.486 --> 00:23:53.360
as a default and we
really liked what we saw.

00:23:53.360 --> 00:23:56.990
I mean, you want a higher
quality presentation

00:23:56.990 --> 00:23:59.150
of paragraphs.

00:23:59.150 --> 00:24:02.050
Of course, if it is
not right for your app,

00:24:02.050 --> 00:24:06.859
then please turn it off or
control the tuning parameters.

00:24:06.859 --> 00:24:09.150
But we also had to do a lot
of work on the performance.

00:24:09.150 --> 00:24:12.110
So it's doing a lot more work.

00:24:12.110 --> 00:24:13.950
There's a lot more
sophistication

00:24:13.950 --> 00:24:15.740
that's going on in there.

00:24:15.740 --> 00:24:19.700
But overall, the amount of time
that it spends drawing text

00:24:19.700 --> 00:24:21.010
is about the same as Lollipop.

00:24:21.010 --> 00:24:23.120
There's some use
cases that are faster

00:24:23.120 --> 00:24:26.480
and there's some where it's like
maybe some of the benchmarks

00:24:26.480 --> 00:24:28.040
where we've gone backwards.

00:24:28.040 --> 00:24:33.620
But we've really tried to make
that usable for everybody.

00:24:33.620 --> 00:24:38.110
And so here's a demo of the
kind of profound difference.

00:24:38.110 --> 00:24:40.710
You can see that you really see
on the left-hand side, which

00:24:40.710 --> 00:24:44.410
is the pre-M paragraph layout.

00:24:44.410 --> 00:24:48.320
And you can still get to this by
setting breakStrategy="simple"

00:24:48.320 --> 00:24:50.080
in your XML.

00:24:50.080 --> 00:24:53.790
But you see these huge
gaps where, like the word

00:24:53.790 --> 00:24:55.140
conversation, it doesn't fit.

00:24:55.140 --> 00:24:57.630
So OK, it just goes
to the next line.

00:24:57.630 --> 00:25:00.600
And with the high
quality layout,

00:25:00.600 --> 00:25:02.440
it says, OK, we
can hyphenate that.

00:25:02.440 --> 00:25:04.190
And we can actually
get this block of text

00:25:04.190 --> 00:25:06.682
that's very clean.

00:25:09.460 --> 00:25:11.920
It really looks much
more like a book

00:25:11.920 --> 00:25:15.532
and less like
computer text display.

00:25:15.532 --> 00:25:16.990
And on the right-hand
side, you can

00:25:16.990 --> 00:25:19.650
see it's actually pretty
eager to use hyphens.

00:25:19.650 --> 00:25:20.970
And that's a control.

00:25:20.970 --> 00:25:25.670
There's a default, which
is a little less eager.

00:25:25.670 --> 00:25:29.550
It uses hyphens when they really
improve the density, when you

00:25:29.550 --> 00:25:31.950
really improve those huge gaps.

00:25:31.950 --> 00:25:34.590
And then there's
this setting of full,

00:25:34.590 --> 00:25:37.570
hyphenationFrequency="full",
which is really appropriate

00:25:37.570 --> 00:25:39.600
if you are displaying
paragraphs of text.

00:25:39.600 --> 00:25:41.730
If you've got an app
like an e-book reader

00:25:41.730 --> 00:25:44.530
where you're really
displaying paragraphs.

00:25:44.530 --> 00:25:48.140
Then we recommend using
full instead of the default.

00:25:48.140 --> 00:25:50.310
And if you want to
turn hyphenation off,

00:25:50.310 --> 00:25:52.150
you can actually--
you can mix and match.

00:25:52.150 --> 00:25:54.520
You can have a high
quality strategy

00:25:54.520 --> 00:25:57.390
in terms of the optimization
of where the line breaks go,

00:25:57.390 --> 00:25:58.430
but just no hyphens.

00:25:58.430 --> 00:25:59.530
And that's another option.

00:26:02.310 --> 00:26:05.880
In the same kind of
increased control

00:26:05.880 --> 00:26:09.270
and has control
over line breaking,

00:26:09.270 --> 00:26:12.810
we were looking at this
particular problem, a very

00:26:12.810 --> 00:26:15.640
common pattern for UI strings.

00:26:15.640 --> 00:26:17.890
You've got a string
that just doesn't quite

00:26:17.890 --> 00:26:21.500
fit into the space, into
the width of the set.

00:26:21.500 --> 00:26:23.670
And then you get
this word-- you know,

00:26:23.670 --> 00:26:25.290
UI strings are often very short.

00:26:25.290 --> 00:26:28.090
So this happens quite a lot
where you just have one line,

00:26:28.090 --> 00:26:30.070
but you have like one
or maybe two words

00:26:30.070 --> 00:26:31.290
that go to the second line.

00:26:31.290 --> 00:26:32.560
And it just doesn't look nice.

00:26:32.560 --> 00:26:37.420
It's not a very pleasing visual
presentation of this text.

00:26:37.420 --> 00:26:41.130
So you can select
breakStrategy="balanced".

00:26:41.130 --> 00:26:44.270
And that tries to line it
up so that all of the lines

00:26:44.270 --> 00:26:48.371
are roughly the same length.

00:26:48.371 --> 00:26:50.870
In a traditional paragraph, you
try and get all of the lines

00:26:50.870 --> 00:26:52.880
except for the last
the same length,

00:26:52.880 --> 00:26:55.380
but balanced really just
tweaks that one thing

00:26:55.380 --> 00:26:57.530
and says, just make this
whole thing line up.

00:26:57.530 --> 00:26:59.510
This is based,
again-- for designers

00:26:59.510 --> 00:27:01.090
who are familiar
with web technology,

00:27:01.090 --> 00:27:03.680
this is based on
Adobe's proposal

00:27:03.680 --> 00:27:05.040
for text wrap balanced.

00:27:05.040 --> 00:27:06.760
That hasn't become a standard.

00:27:06.760 --> 00:27:08.690
I don't think it's
widely shipping yet.

00:27:08.690 --> 00:27:13.270
But again, we're trying to
make the design of typography

00:27:13.270 --> 00:27:19.050
on Android similar to the design
of typography for the web.

00:27:19.050 --> 00:27:21.770
So I wanted to
also-- I mentioned

00:27:21.770 --> 00:27:24.700
when I was talking about
the different languages

00:27:24.700 --> 00:27:29.290
and the different things that
we do to change the way we

00:27:29.290 --> 00:27:32.750
present text, that
this is really

00:27:32.750 --> 00:27:35.020
one of the most important
things that apps can do

00:27:35.020 --> 00:27:39.670
is to get the locale of the
text that the app is displaying

00:27:39.670 --> 00:27:40.660
correct.

00:27:40.660 --> 00:27:44.900
Because if it's wrong,
you'll still get the text

00:27:44.900 --> 00:27:46.970
displayed, but things
will be degraded.

00:27:46.970 --> 00:27:48.520
They won't be as nice.

00:27:48.520 --> 00:27:53.460
They won't be as polished as if
you set that locale correctly.

00:27:53.460 --> 00:27:55.760
So there's three
different ways that locale

00:27:55.760 --> 00:28:00.470
flows into text in Android,
in Android framework text.

00:28:00.470 --> 00:28:04.170
There's the settings,
which are system-wide,

00:28:04.170 --> 00:28:06.960
which control a default locale.

00:28:06.960 --> 00:28:09.170
And of course, this
is their fault.

00:28:09.170 --> 00:28:11.460
This is what happens if
you don't do anything.

00:28:11.460 --> 00:28:14.870
And you hope it's right,
but unfortunately, there

00:28:14.870 --> 00:28:17.150
are a bunch of
cases, mostly when

00:28:17.150 --> 00:28:21.020
you have multilingual users--
in America, there aren't any.

00:28:21.020 --> 00:28:22.890
But in the rest of
the world, there's

00:28:22.890 --> 00:28:26.880
a lot of people that speak
more than one language.

00:28:26.880 --> 00:28:30.047
So the language that
they're viewing the app in,

00:28:30.047 --> 00:28:31.630
the language that
they're interacting,

00:28:31.630 --> 00:28:36.790
that they're maybe looking at
user content, might not be,

00:28:36.790 --> 00:28:39.780
might not match the
system setting app.

00:28:39.780 --> 00:28:43.470
So we have a
setTextLocale API, which

00:28:43.470 --> 00:28:45.570
you can use on a text view.

00:28:45.570 --> 00:28:50.025
And if you have metadata, if
your server knows the language

00:28:50.025 --> 00:28:52.640
that that text is,
then we strongly

00:28:52.640 --> 00:28:54.740
recommend that you
set text locale

00:28:54.740 --> 00:28:58.450
on the text key that displays
that text so that the locale is

00:28:58.450 --> 00:28:59.940
correctly identified.

00:28:59.940 --> 00:29:03.360
And then this may be a
little bit more specialized,

00:29:03.360 --> 00:29:05.360
like for something like
a translate app where

00:29:05.360 --> 00:29:07.040
you may have a
single string that

00:29:07.040 --> 00:29:08.530
contains multiple languages.

00:29:08.530 --> 00:29:10.850
It might say the
translation of this word

00:29:10.850 --> 00:29:13.490
into this other language
is some other word.

00:29:13.490 --> 00:29:17.180
And you might have a
language that's just a span.

00:29:17.180 --> 00:29:19.480
And for that we've
got a LocaleSpan.

00:29:19.480 --> 00:29:23.330
And you can set that on
just the text in your app

00:29:23.330 --> 00:29:25.725
that represents that span.

00:29:25.725 --> 00:29:26.850
So what does the locale do?

00:29:26.850 --> 00:29:28.891
I mean, like I've said,
it's important to set it,

00:29:28.891 --> 00:29:29.790
but what happens?

00:29:29.790 --> 00:29:33.240
How does that actually control
the way text is displayed?

00:29:33.240 --> 00:29:36.680
And before Jelly Bean, there
was no difference at all.

00:29:36.680 --> 00:29:38.420
Text just displayed.

00:29:38.420 --> 00:29:40.980
But in Marshmallow,
there's four different ways

00:29:40.980 --> 00:29:43.680
that locale affects the
presentation of text.

00:29:43.680 --> 00:29:46.390
It changes the
font that's chosen.

00:29:46.390 --> 00:29:48.820
And that's especially
important for distinguishing

00:29:48.820 --> 00:29:52.260
between traditional
and simplified Chinese,

00:29:52.260 --> 00:29:54.790
as well as Japanese and Korean.

00:29:54.790 --> 00:29:57.470
Those are different
fonts that are unified.

00:29:57.470 --> 00:30:01.750
It affects this local OpenType
feature lookup so that,

00:30:01.750 --> 00:30:05.480
like there are differences in
devanagari script between Hindi

00:30:05.480 --> 00:30:07.180
and Marathi.

00:30:07.180 --> 00:30:10.460
And it makes sure that
you get the correct forms

00:30:10.460 --> 00:30:14.540
of those letters, things like
Persian numerals and so on.

00:30:14.540 --> 00:30:18.020
Or not-- well, Persian
numerals are complicated,

00:30:18.020 --> 00:30:22.280
but the point is that if
you know the language,

00:30:22.280 --> 00:30:25.720
then setting it will get the
correct lookups to happen

00:30:25.720 --> 00:30:27.980
on the font.

00:30:27.980 --> 00:30:30.370
The locale also
affects line breaking.

00:30:30.370 --> 00:30:32.350
There's some languages
where deciding

00:30:32.350 --> 00:30:34.240
where the boundaries
are between words, where

00:30:34.240 --> 00:30:35.700
you can break the
line, is actually

00:30:35.700 --> 00:30:37.540
kind of a complex question.

00:30:37.540 --> 00:30:39.930
Thai is the most
common, certainly,

00:30:39.930 --> 00:30:42.260
that you'll see where
there's no spaces.

00:30:42.260 --> 00:30:45.120
And so you really, in the case
of Thai, you need a dictionary.

00:30:45.120 --> 00:30:47.390
You need to say,
this is the word,

00:30:47.390 --> 00:30:49.910
so that I know where the
boundaries of the words are.

00:30:49.910 --> 00:30:52.635
And that is completely
reliant on knowing

00:30:52.635 --> 00:30:53.510
what the language is.

00:30:53.510 --> 00:30:56.980
If you just put Thai text
through, but don't identify

00:30:56.980 --> 00:30:59.720
that the language is Thai,
then it gets confused

00:30:59.720 --> 00:31:03.500
and you get in line breaks in
potentially very bad places

00:31:03.500 --> 00:31:05.980
that don't line up
with words at all.

00:31:05.980 --> 00:31:08.560
And then, of course,
lastly, now that we

00:31:08.560 --> 00:31:11.470
have automatic
hyphenation, that knowing

00:31:11.470 --> 00:31:17.540
which dictionary of patterns
to use depends on the language.

00:31:17.540 --> 00:31:19.340
And this is-- like
most of the things

00:31:19.340 --> 00:31:21.860
that I just talked
about are kind

00:31:21.860 --> 00:31:24.410
of more exotic languages
to this audience,

00:31:24.410 --> 00:31:27.180
but automatic hyphenation
is important between,

00:31:27.180 --> 00:31:29.890
for example,
Norwegian and English.

00:31:29.890 --> 00:31:32.174
They're both in the same script.

00:31:32.174 --> 00:31:33.590
But if you use the
wrong patterns,

00:31:33.590 --> 00:31:35.800
you'll get you'll
get weird hyphens.

00:31:35.800 --> 00:31:40.630
And then there's-- like how do
you know what the language is?

00:31:40.630 --> 00:31:43.490
And fortunately, there is
an open source library.

00:31:43.490 --> 00:31:46.920
I mean, this is actually
mostly developed by Google,

00:31:46.920 --> 00:31:47.840
but it's out there.

00:31:47.840 --> 00:31:50.690
The Compact Language
Detector library,

00:31:50.690 --> 00:31:53.504
which is now in
its second version.

00:31:53.504 --> 00:31:54.920
It's open source
and it's designed

00:31:54.920 --> 00:31:56.490
to be very
performant, very fast.

00:31:56.490 --> 00:31:58.800
It's not a huge
dependency to take on.

00:31:58.800 --> 00:32:02.560
So if you've got an app where
you're displaying messages

00:32:02.560 --> 00:32:04.390
and you really don't
have the metadata,

00:32:04.390 --> 00:32:07.680
you don't know where it came
from, what that language is,

00:32:07.680 --> 00:32:10.930
but you want to ensure that
it's displayed with the highest

00:32:10.930 --> 00:32:12.870
quality-- and of
course, that metadata

00:32:12.870 --> 00:32:15.370
can be really useful for
lots of other things--

00:32:15.370 --> 00:32:20.890
then we really do recommend
this Compact Language Detector.

00:32:20.890 --> 00:32:25.410
You pipe the output of
that into setTextLocale,

00:32:25.410 --> 00:32:29.790
and that really improves
the quality of your display.

00:32:29.790 --> 00:32:33.660
So that's kind of all of the
prepared topics that I had.

00:32:33.660 --> 00:32:36.440
I want to open it
up to questions.

00:32:36.440 --> 00:32:38.630
I'm happy to answer
any questions you have.

00:32:38.630 --> 00:32:40.450
And please wait for
the mic to come to you.

00:32:54.450 --> 00:32:55.440
AUDIENCE: Hello.

00:32:55.440 --> 00:32:58.110
On the topic of
custom fonts, so you

00:32:58.110 --> 00:33:01.480
can achieve custom fonts
via-- like on simple views

00:33:01.480 --> 00:33:03.460
such as text view, but
it's pretty difficult

00:33:03.460 --> 00:33:07.840
to do for framework UI classes,
such as like navigation view

00:33:07.840 --> 00:33:09.130
or toolbar.

00:33:09.130 --> 00:33:11.130
Is there a recommended
way by the frameworks

00:33:11.130 --> 00:33:15.050
team to achieve custom fonts
globally within your app?

00:33:15.050 --> 00:33:17.900
RAPH LEVIEN: Yeah,
that's a good question.

00:33:17.900 --> 00:33:24.390
I don't think we have a
mechanism for applying

00:33:24.390 --> 00:33:26.979
a font globally across the app.

00:33:26.979 --> 00:33:28.770
So unfortunately, I
think that is something

00:33:28.770 --> 00:33:32.750
that you have to do with code.

00:33:32.750 --> 00:33:36.370
But that's something that
we're interested in looking

00:33:36.370 --> 00:33:37.420
at, making easier.

00:33:40.569 --> 00:33:41.110
AUDIENCE: Hi.

00:33:41.110 --> 00:33:44.100
I get a lot of requests
from design forum situations

00:33:44.100 --> 00:33:48.877
where they want the text
to be exactly this size,

00:33:48.877 --> 00:33:50.710
possibly because it's
aligning with an image

00:33:50.710 --> 00:33:53.669
or something like that.

00:33:53.669 --> 00:33:55.710
What is your recommendation
for-- what I'd really

00:33:55.710 --> 00:33:57.880
like to do is have
the text shrink down

00:33:57.880 --> 00:34:01.310
if it's in, say, a language
that it has more text there.

00:34:01.310 --> 00:34:03.500
What is your
recommendation for that?

00:34:03.500 --> 00:34:05.770
RAPH LEVIEN: That's a
very common request.

00:34:05.770 --> 00:34:09.429
And we do not have support in
the framework for that yet.

00:34:09.429 --> 00:34:12.360
It is something that we
are really looking at.

00:34:12.360 --> 00:34:14.560
There are a number of
open source libraries.

00:34:14.560 --> 00:34:17.870
One of the reasons that we
haven't implemented something

00:34:17.870 --> 00:34:21.389
like that-- I looked at
it and one of the problems

00:34:21.389 --> 00:34:23.832
that you get into is
that you get kind of,

00:34:23.832 --> 00:34:26.096
how do you specify what
that behavior should be?

00:34:26.096 --> 00:34:28.679
So you just specify kind of one
point in there, where you want

00:34:28.679 --> 00:34:30.679
it to be exactly that size.

00:34:30.679 --> 00:34:32.679
But there's a lot
of other use cases

00:34:32.679 --> 00:34:35.050
where people are trying
to-- because you're

00:34:35.050 --> 00:34:38.020
trying to line it up, basically,
with other graphic elements.

00:34:38.020 --> 00:34:40.409
There's a lot of other cases
where people are just mostly

00:34:40.409 --> 00:34:41.520
concerned about making it fit.

00:34:41.520 --> 00:34:43.150
So they want kind
of different logic.

00:34:43.150 --> 00:34:45.870
They want something that
says make it a standard size.

00:34:45.870 --> 00:34:48.380
Make it 14 sp, unless
it doesn't fit,

00:34:48.380 --> 00:34:53.080
and then we want to have it
shrink down to some other size.

00:34:53.080 --> 00:34:56.170
But we don't want to have it
shrink down to below like 8,

00:34:56.170 --> 00:34:58.230
because then it
becomes illegible.

00:34:58.230 --> 00:35:00.750
So you get these
cases where specifying

00:35:00.750 --> 00:35:04.640
how you want that behavior to
scale is kind of complicated.

00:35:04.640 --> 00:35:09.219
And if and when we do
implement something

00:35:09.219 --> 00:35:10.760
like that in the
framework, we really

00:35:10.760 --> 00:35:15.060
need to make sure that we
cover the range of behavior

00:35:15.060 --> 00:35:16.720
in a way that makes sense.

00:35:16.720 --> 00:35:20.510
Until then, I'm not
going to recommend

00:35:20.510 --> 00:35:22.410
any specific open
source library,

00:35:22.410 --> 00:35:24.620
but there's a bunch
of them out there.

00:35:24.620 --> 00:35:26.870
And it's likely that
there's something

00:35:26.870 --> 00:35:31.282
that just subclasses text view
and overlays that behavior.

00:35:31.282 --> 00:35:32.740
It's likely that
there is something

00:35:32.740 --> 00:35:34.151
that will fit what you need.

00:35:37.380 --> 00:35:38.890
AUDIENCE: Early
on, I saw a mention

00:35:38.890 --> 00:35:41.670
for CSS styles being
applied to text.

00:35:41.670 --> 00:35:43.400
Is that something is
done through styles

00:35:43.400 --> 00:35:46.064
or is it through the
use of HTML text?

00:35:46.064 --> 00:35:46.730
RAPH LEVIEN: OK.

00:35:46.730 --> 00:35:49.790
So I'm sorry if
that was misleading.

00:35:49.790 --> 00:35:54.320
It's not CSS styles in general
that we're applying to text.

00:35:54.320 --> 00:35:59.060
There are specific attributes,
there are specific parameters

00:35:59.060 --> 00:36:01.490
that we're-- and in
that particular slide,

00:36:01.490 --> 00:36:03.670
I was talking about
font feature settings.

00:36:03.670 --> 00:36:05.010
And it's like the syntax.

00:36:05.010 --> 00:36:07.350
Because specifying
all these OpenType

00:36:07.350 --> 00:36:09.080
features is kind
of a complex thing.

00:36:09.080 --> 00:36:11.930
It's not just like a number
or something like that.

00:36:11.930 --> 00:36:15.090
And so we adapted
the syntax from CSS.

00:36:15.090 --> 00:36:16.700
It is compatible with CSS.

00:36:16.700 --> 00:36:20.080
So if you have that particular
feature, other features

00:36:20.080 --> 00:36:22.080
that we've got,
like letter spacing,

00:36:22.080 --> 00:36:24.880
the name of the feature,
the meaning of the feature,

00:36:24.880 --> 00:36:27.310
we're trying to make
it consistent with CSS.

00:36:27.310 --> 00:36:32.110
But we haven't implemented a
web browser in Android framework

00:36:32.110 --> 00:36:32.820
text.

00:36:32.820 --> 00:36:36.690
You can use web view, but
that's-- there is not like

00:36:36.690 --> 00:36:39.200
a generic CSS translator.

00:36:39.200 --> 00:36:40.820
It's just these
specific features

00:36:40.820 --> 00:36:45.915
that are low impedance,
or compatible with CSS.

00:36:50.210 --> 00:36:51.990
AUDIENCE: What is
the performance cost

00:36:51.990 --> 00:36:55.854
of the high quality text layout
strategy with hyphenation?

00:36:55.854 --> 00:36:58.020
For example, if you want
to actually change the text

00:36:58.020 --> 00:36:58.790
view contents.

00:36:58.790 --> 00:37:01.600
So what is that going to
cost you at layout time?

00:37:01.600 --> 00:37:04.870
RAPH LEVIEN: Well,
measuring text performance

00:37:04.870 --> 00:37:05.890
is really complex.

00:37:05.890 --> 00:37:11.250
I mean, the order
of magnitude is

00:37:11.250 --> 00:37:15.690
that it's about the same
as simple text in Lollipop.

00:37:15.690 --> 00:37:20.950
So it's doing more work, but
we actually took a wrench to it

00:37:20.950 --> 00:37:24.140
and did a lot of optimizations
to make it go faster.

00:37:24.140 --> 00:37:26.140
There's going to be some
specific cases that are

00:37:26.140 --> 00:37:27.570
going to be a little slower.

00:37:27.570 --> 00:37:29.150
There's other cases,
like if you're

00:37:29.150 --> 00:37:31.170
editing a very large
buffer, that it's

00:37:31.170 --> 00:37:32.560
going to be a lot faster.

00:37:32.560 --> 00:37:35.880
Because we really did a lot
of performance improvement

00:37:35.880 --> 00:37:37.730
in that area.

00:37:37.730 --> 00:37:40.590
So ultimately, if you're really
concerned about performance,

00:37:40.590 --> 00:37:43.710
like if you've profiled your
app and you've said, oh, my god.

00:37:43.710 --> 00:37:46.376
I'm spending all of this
time doing the layout,

00:37:46.376 --> 00:37:47.500
of the high quality layout.

00:37:47.500 --> 00:37:51.360
And if you've decided that
the visual improvement of that

00:37:51.360 --> 00:37:54.510
is not worth it in your app,
then by all means, set simple.

00:37:54.510 --> 00:37:59.120
We have not come across-- I
can't really think of any apps

00:37:59.120 --> 00:38:00.700
that I know of,
either first party

00:38:00.700 --> 00:38:03.160
or third party, where people
have felt a need to do that.

00:38:03.160 --> 00:38:05.290
But it's certainly an option.

00:38:05.290 --> 00:38:09.280
And we will continue to
improve the performance.

00:38:09.280 --> 00:38:11.300
This is a very
important area for us.

00:38:11.300 --> 00:38:13.520
It's got to not jank.

00:38:13.520 --> 00:38:16.714
AUDIENCE: Also, will there be
a support library for this?

00:38:16.714 --> 00:38:17.380
RAPH LEVIEN: No.

00:38:17.380 --> 00:38:18.850
Unfortunately, a
lot of the stuff

00:38:18.850 --> 00:38:21.420
that happens in framework
text is at such a low level

00:38:21.420 --> 00:38:24.455
that you can't really fill
it in with a support library.

00:38:35.200 --> 00:38:35.850
AUDIENCE: Hi.

00:38:35.850 --> 00:38:37.120
I know better than
to ask you what

00:38:37.120 --> 00:38:38.745
are you guys going
to do in the future,

00:38:38.745 --> 00:38:43.360
but I wanted to ask a
little about static layout

00:38:43.360 --> 00:38:48.510
and the new method that lets
you set custom margins per line.

00:38:48.510 --> 00:38:49.540
RAPH LEVIEN: Yes.

00:38:49.540 --> 00:38:51.790
AUDIENCE: So I know it's not
ready to do full wrapping

00:38:51.790 --> 00:38:54.030
around a path, which is
what I imagined when I first

00:38:54.030 --> 00:38:54.655
heard about it.

00:38:54.655 --> 00:38:56.720
But I am wondering,
what were you guys

00:38:56.720 --> 00:38:58.460
imagining when you added it?

00:38:58.460 --> 00:39:00.160
Is it just the
circular watch face,

00:39:00.160 --> 00:39:02.980
or is there something else cool
I could, but I don't know yet.

00:39:02.980 --> 00:39:03.510
RAPH LEVIEN: Oh, great.

00:39:03.510 --> 00:39:04.010
No.

00:39:04.010 --> 00:39:07.290
And that's a slide that
almost happened in this talk.

00:39:07.290 --> 00:39:09.060
And I wanted to keep
it simple because I

00:39:09.060 --> 00:39:15.550
wanted to talk about things that
would be for most developers.

00:39:15.550 --> 00:39:17.220
So certainly, the
circular watch face.

00:39:17.220 --> 00:39:21.350
So maybe I should just
explain that there's

00:39:21.350 --> 00:39:25.630
layers of the text stack, where
text view is the one that most

00:39:25.630 --> 00:39:27.200
of you interact with.

00:39:27.200 --> 00:39:30.620
But underneath text
view is static layout.

00:39:30.620 --> 00:39:33.080
And static layout does
a lot of the things

00:39:33.080 --> 00:39:35.640
around line breaking
and paragraph layout.

00:39:35.640 --> 00:39:37.840
And then below that is
like draw text and the kind

00:39:37.840 --> 00:39:39.550
of very low level APIs.

00:39:39.550 --> 00:39:41.750
And in static layout,
we have a new method

00:39:41.750 --> 00:39:44.720
that lets you adjust
the shape by controlling

00:39:44.720 --> 00:39:46.750
indents on the paragraph.

00:39:46.750 --> 00:39:47.650
And so, yes.

00:39:47.650 --> 00:39:51.020
The watch face was absolutely
a motivation for that.

00:39:51.020 --> 00:39:52.520
We are seeing
other applications.

00:39:52.520 --> 00:39:54.640
People are adopting
it in cases where

00:39:54.640 --> 00:39:58.320
people are doing custom
views, rather than

00:39:58.320 --> 00:39:59.740
just relying on text view.

00:39:59.740 --> 00:40:01.680
One of the really nice
ones is when you just

00:40:01.680 --> 00:40:03.805
get to flow around an image,
where you're basically

00:40:03.805 --> 00:40:08.920
doing something like
a web style float.

00:40:08.920 --> 00:40:13.640
And it is possible to do your
own-- to kind of roll your own,

00:40:13.640 --> 00:40:16.560
if you've got a
path, to figure out,

00:40:16.560 --> 00:40:18.710
based on the knowledge
of the line heights

00:40:18.710 --> 00:40:21.500
and stuff like that, to figure
out what the indents are.

00:40:21.500 --> 00:40:25.930
I think you'll see this
continue to evolve.

00:40:25.930 --> 00:40:30.490
Clearly, it makes sense
to do a higher level

00:40:30.490 --> 00:40:34.810
feature that is easier to
use, is not so low level.

00:40:34.810 --> 00:40:37.178
But unfortunately,
it is not there yet.

00:40:42.190 --> 00:40:44.510
Any other questions?

00:40:44.510 --> 00:40:45.010
All right.

00:40:45.010 --> 00:40:46.696
Well, thank you so
much for coming.

00:40:46.696 --> 00:40:47.960
[APPLAUSE]

00:40:47.960 --> 00:40:50.710
[MUSIC PLAYING]

