WEBVTT
Kind: captions
Language: en

00:00:03.199 --> 00:00:04.199
Hi!

00:00:04.199 --> 00:00:08.029
My name is Brad and I am one of the Tech Leads
for Native Client.

00:00:08.029 --> 00:00:14.050
In this video, I am going to dive into the
technology that makes Native Client apps possible.

00:00:14.050 --> 00:00:19.739
A key concept in Native Client is the sandbox,
an isolation technique that prevents downloaded

00:00:19.739 --> 00:00:23.320
code from doing things it’s not supposed
to.

00:00:23.320 --> 00:00:28.800
The Native Client sandbox prevents application
code from interacting directly with the native

00:00:28.800 --> 00:00:29.820
operating system.

00:00:29.820 --> 00:00:32.860
This is crucial for portability.

00:00:32.860 --> 00:00:37.710
If an app invoked the native OS directly,
it couldn’t run on other operating systems.

00:00:37.710 --> 00:00:43.180
It’s also essential for security, because
the native operating system provides access

00:00:43.180 --> 00:00:47.860
to resources like your files that need to
be protected.

00:00:47.860 --> 00:00:53.310
The Native Client sandbox is implemented using
a technique called Software Fault Isolation.

00:00:53.310 --> 00:00:55.770
This technique was first introduced in the
early 90’s.

00:00:55.770 --> 00:01:02.010
It’s based on the use of assembly-language
idioms that are easy to recognize and that,

00:01:02.010 --> 00:01:07.110
when used, make it possible to prove certain
things about the program’s behavior.

00:01:07.110 --> 00:01:13.469
For example, if you insure that all data addresses
used by a program are greater than a particular

00:01:13.469 --> 00:01:19.120
address, then you know that no memory references
can happen below that address.

00:01:19.120 --> 00:01:24.310
Using software fault isolation we implement
what we call reliable disassembly.

00:01:24.310 --> 00:01:29.859
This means that we know every instruction
a program can execute, and won’t run it

00:01:29.859 --> 00:01:33.749
unless we can prove that each instruction
is safe.

00:01:33.749 --> 00:01:37.880
Defense in depth is another key concept for
Native Client.

00:01:37.880 --> 00:01:40.159
Suppose you had a brick of gold.

00:01:40.159 --> 00:01:44.249
You might put it in a safe, but you wouldn’t
leave that safe sitting out in your front

00:01:44.249 --> 00:01:45.429
yard.

00:01:45.429 --> 00:01:50.170
Maybe you’d put it inside your house, maybe
even in a locked room, and you would probably

00:01:50.170 --> 00:01:52.460
lock your house too.

00:01:52.460 --> 00:01:58.179
In the same way, Native Client uses multiple
layers of protection that make it much harder

00:01:58.179 --> 00:02:00.320
to attack the system.

00:02:00.320 --> 00:02:05.729
We also apply best practices such as strict
coding standards and multiple internal and

00:02:05.729 --> 00:02:11.460
external security reviews to insure that our
system is really safe.

00:02:11.460 --> 00:02:15.099
Openness is another key principle we’ve
applied in this system.

00:02:15.099 --> 00:02:22.530
We’ve built the system around established
open standards like HTML5, C, C++, POSIX and

00:02:22.530 --> 00:02:27.480
ELF, to make it easily accessible to a large
community of developers.

00:02:27.480 --> 00:02:33.300
We’ve open-sourced our system, because we’ve
seen that scrutiny and input from the developer

00:02:33.300 --> 00:02:35.349
community makes our system better.

00:02:35.349 --> 00:02:40.569
I hope you’ve enjoyed this quick overview
of some of the principles behind Native Client

00:02:40.569 --> 00:02:41.659
technology.

00:02:41.659 --> 00:02:44.469
To learn more visit our site at gonacl.com.

