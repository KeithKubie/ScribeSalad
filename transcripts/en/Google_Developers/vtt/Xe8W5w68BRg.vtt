WEBVTT
Kind: captions
Language: en

00:00:01.768 --> 00:00:03.100
RUSSELL KETCHUM: All right.

00:00:03.100 --> 00:00:06.570
Well, I want to start by
thanking everyone for coming

00:00:06.570 --> 00:00:09.480
out and listening to us talk
today about creating highly

00:00:09.480 --> 00:00:12.300
dynamic apps using Google
Tag Manager.

00:00:12.300 --> 00:00:13.550
I am Russ Ketchum.

00:00:13.550 --> 00:00:16.740
I'm the lead product manager for
Google Analytics for Apps,

00:00:16.740 --> 00:00:18.800
and also Google Tag Manager.

00:00:18.800 --> 00:00:20.770
NEIL RHODES: And my name's
Neil Rhodes, and I'm the

00:00:20.770 --> 00:00:22.170
engineering lead for
the Google Tag

00:00:22.170 --> 00:00:25.610
Manager for Mobile Apps.

00:00:25.610 --> 00:00:28.350
RUSSELL KETCHUM: So I want to
describe a problem to that you

00:00:28.350 --> 00:00:30.760
as developers all know
pretty well.

00:00:30.760 --> 00:00:32.689
Now here, just kind of a
quick show of hands.

00:00:32.689 --> 00:00:35.995
Who in here actually as is app
developer, iOS, Android?

00:00:35.995 --> 00:00:37.360
All right, so the vast
majority of you.

00:00:37.360 --> 00:00:38.390
Awesome.

00:00:38.390 --> 00:00:41.430
So this is a problem you all
know really well, and that is

00:00:41.430 --> 00:00:45.810
once you ship your app,
it's frozen, right?

00:00:45.810 --> 00:00:47.430
I mean, it's locked in.

00:00:47.430 --> 00:00:51.270
It's stuck, and it's effectively
cast in stone.

00:00:51.270 --> 00:00:54.270
And so what that means is if
you want to make even the

00:00:54.270 --> 00:00:58.410
tiniest change to your app,
you're now stuck with this

00:00:58.410 --> 00:01:01.940
multi-step, kind of
indeterminate amount of time,

00:01:01.940 --> 00:01:04.099
how long it's going to take
to get from point A

00:01:04.099 --> 00:01:05.280
to point D on here.

00:01:05.280 --> 00:01:08.560
Who knows how many other sub
steps there are in between.

00:01:08.560 --> 00:01:12.120
And it's really complicated, so
first you start by needing

00:01:12.120 --> 00:01:14.480
to secure approvals, whether
or not these are internal

00:01:14.480 --> 00:01:16.760
approvals, or if you're going
through an app store that

00:01:16.760 --> 00:01:19.320
requires approvals, then you
actually have to physically

00:01:19.320 --> 00:01:20.510
ship your new version.

00:01:20.510 --> 00:01:23.270
You have to wait for an upgrade
cycle to happen, and

00:01:23.270 --> 00:01:25.980
then even at the end of that,
you're left with this version

00:01:25.980 --> 00:01:28.170
uncertainty, where some of
your users have upgraded,

00:01:28.170 --> 00:01:29.080
others haven't.

00:01:29.080 --> 00:01:32.020
You're using tools like Google
Analytics to figure out who's

00:01:32.020 --> 00:01:32.990
using what version.

00:01:32.990 --> 00:01:36.220
And so it's very difficult for
you as a developer to ensure

00:01:36.220 --> 00:01:38.930
that all of your users are
having kind of the consistent

00:01:38.930 --> 00:01:41.460
experience, or even the targeted
experience that you

00:01:41.460 --> 00:01:43.000
intend for them to have.

00:01:43.000 --> 00:01:47.160
And so today we're here to
propose an alternative, and

00:01:47.160 --> 00:01:48.600
that is pretty simple.

00:01:48.600 --> 00:01:51.830
It's make your app highly
configurable, and then use the

00:01:51.830 --> 00:01:53.840
Google Tag Manager SDK.

00:01:53.840 --> 00:01:56.940
And so when you do that, you
actually take this process,

00:01:56.940 --> 00:01:59.990
again, however many steps it is,
and you collapse it to a

00:01:59.990 --> 00:02:03.290
model where you're in charge of
communicating your changes

00:02:03.290 --> 00:02:04.720
directly with your users.

00:02:04.720 --> 00:02:07.120
And you can be confident that
that's going to happen within

00:02:07.120 --> 00:02:08.479
roughly 12 hours.

00:02:08.479 --> 00:02:10.330
So I want to introduce Neil,
and he's going to actually

00:02:10.330 --> 00:02:12.630
explain to you how it works.

00:02:12.630 --> 00:02:14.380
So as Russ described, what
you're going to do is make

00:02:14.380 --> 00:02:17.060
your application highly
configurable.

00:02:17.060 --> 00:02:17.620
What does that mean?

00:02:17.620 --> 00:02:20.220
That really means you're going
to take all of the static

00:02:20.220 --> 00:02:22.910
configuration that you normally
do in an application

00:02:22.910 --> 00:02:26.680
via constants, and instead
make key value pairs and

00:02:26.680 --> 00:02:28.520
respond those keys.

00:02:28.520 --> 00:02:31.200
What sorts of things might
you want to configure?

00:02:31.200 --> 00:02:33.930
Well if you're using AdMob, for
example, you might want to

00:02:33.930 --> 00:02:37.960
configure how often ads occur,
or how long they're there, or

00:02:37.960 --> 00:02:40.160
where they occur
on the screen.

00:02:40.160 --> 00:02:44.010
If you're communicating with a
back end server, what is the

00:02:44.010 --> 00:02:45.790
host name that you're
connecting to?

00:02:45.790 --> 00:02:49.150
What is the path you're using,
if you're using HTTP?

00:02:49.150 --> 00:02:51.565
And that's something that might
change over time that

00:02:51.565 --> 00:02:53.160
you want to be able
to configure.

00:02:53.160 --> 00:02:54.792
Gameplay, if you've
got a game.

00:02:54.792 --> 00:02:59.930
How much are particular things
worth in terms of play?

00:02:59.930 --> 00:03:02.842
How many lives do you get
if you kill the bad guy?

00:03:02.842 --> 00:03:07.380
If you have any URLs in your
application that refer to help

00:03:07.380 --> 00:03:11.110
or upgrades, or things like
that, what are those URLs?

00:03:11.110 --> 00:03:12.200
UI settings.

00:03:12.200 --> 00:03:13.060
What colors do you use?

00:03:13.060 --> 00:03:14.380
You've got to buy a button.

00:03:14.380 --> 00:03:15.920
What color is going
to work best?

00:03:15.920 --> 00:03:17.490
Is a red best?

00:03:17.490 --> 00:03:18.530
Is a blue best?

00:03:18.530 --> 00:03:20.310
And what if you change
your mind later on?

00:03:20.310 --> 00:03:22.520
What's the text of
that button?

00:03:22.520 --> 00:03:25.995
What features might you have
that you want to only deploy

00:03:25.995 --> 00:03:27.730
at some later time?

00:03:27.730 --> 00:03:28.590
Miscellaneous.

00:03:28.590 --> 00:03:30.080
Some message of the day
that you want to

00:03:30.080 --> 00:03:31.700
display to the user.

00:03:31.700 --> 00:03:33.750
So here's the basic idea.

00:03:33.750 --> 00:03:35.330
In a nutshell, it's like this.

00:03:35.330 --> 00:03:38.100
Take the constants in your
application and replace them

00:03:38.100 --> 00:03:41.780
with calls to Google
Tag Manager.

00:03:41.780 --> 00:03:46.260
As an example here, we have a
timeout of 1,500 milliseconds.

00:03:46.260 --> 00:03:48.250
Is that really the
right number?

00:03:48.250 --> 00:03:50.600
You were sitting there coding,
and at the time that seemed

00:03:50.600 --> 00:03:52.140
like the right number.

00:03:52.140 --> 00:03:54.340
But what if it turns out
that should really

00:03:54.340 --> 00:03:58.150
be 1,800, or 1,200?

00:03:58.150 --> 00:04:01.900
By making a call to the
container which contains our

00:04:01.900 --> 00:04:06.720
values, we can get the timeout
in milliseconds, and that will

00:04:06.720 --> 00:04:10.280
give us the current setting
for that key.

00:04:10.280 --> 00:04:13.080
And similarly, we can have a
whole host of keys in our

00:04:13.080 --> 00:04:17.010
application and get those
values, and know that we're

00:04:17.010 --> 00:04:20.209
going to get the latest
values for those.

00:04:20.209 --> 00:04:21.574
Here's an example.

00:04:21.574 --> 00:04:24.862
You're using AdMob to monetize
your application.

00:04:24.862 --> 00:04:30.050
AdMob has one of the parameters
that you use is the

00:04:30.050 --> 00:04:32.850
banner size, and they're
a set of constants.

00:04:32.850 --> 00:04:35.550
One constant is banner,
which is, I

00:04:35.550 --> 00:04:37.660
believe, a 320x50 banner.

00:04:37.660 --> 00:04:40.970
Another is Smart Banner, which
configures it based on the

00:04:40.970 --> 00:04:42.060
size of the screen.

00:04:42.060 --> 00:04:44.030
Which one do you want to use?

00:04:44.030 --> 00:04:46.890
Well, Smart, because
it's smart, right?

00:04:46.890 --> 00:04:48.210
It must be better.

00:04:48.210 --> 00:04:50.760
But maybe there are
circumstances where better is

00:04:50.760 --> 00:04:55.190
better, and why not hedge your
bets and actually just make a

00:04:55.190 --> 00:04:59.830
value for a key that says
the banner size to use?

00:04:59.830 --> 00:05:02.480
Get that string value, and
then convert it to the

00:05:02.480 --> 00:05:03.840
appropriate enumeration.

00:05:03.840 --> 00:05:05.690
And then it gives you the
flexibility later on of

00:05:05.690 --> 00:05:07.080
changing your mind.

00:05:07.080 --> 00:05:09.460
Similarly, do you want the ad
at the top of the screen or

00:05:09.460 --> 00:05:10.885
the bottom of the screen?

00:05:10.885 --> 00:05:12.070
Well, I don't know.

00:05:12.070 --> 00:05:14.690
I looked, and my product manager
looked, and we decided

00:05:14.690 --> 00:05:16.210
the top was better.

00:05:16.210 --> 00:05:18.390
But maybe it'll turn out that
the bottom might be

00:05:18.390 --> 00:05:19.300
better later on.

00:05:19.300 --> 00:05:21.060
That might monetize better.

00:05:21.060 --> 00:05:26.480
So again, hedge my bet by
having a Boolean that

00:05:26.480 --> 00:05:29.780
specifies what I want, and then
when I create my ad view,

00:05:29.780 --> 00:05:31.790
depending on the value of that
Boolean, either at the

00:05:31.790 --> 00:05:33.590
beginning of my layout
view, or at the end

00:05:33.590 --> 00:05:34.290
of my layout view.

00:05:34.290 --> 00:05:37.760
So a small amount of
code for that.

00:05:37.760 --> 00:05:38.970
Here's an example for content.

00:05:38.970 --> 00:05:42.270
So what we're doing here is just
creating a JSON with keys

00:05:42.270 --> 00:05:44.400
and values.

00:05:44.400 --> 00:05:46.460
And this is for content,
what our URLs are.

00:05:46.460 --> 00:05:49.670
As you know, URLs are
not always constant.

00:05:49.670 --> 00:05:51.270
We sometimes do want
to change them.

00:05:51.270 --> 00:05:55.250
This gives us the opportunity
to do that.

00:05:55.250 --> 00:05:59.260
You might have a much larger
group of key value pairs, and

00:05:59.260 --> 00:06:01.960
so can actually use a hierarchy,
as in here, where

00:06:01.960 --> 00:06:05.430
our top level hierarchy
is physics, or target.

00:06:05.430 --> 00:06:08.270
So this is an example we're
going to see in a moment of a

00:06:08.270 --> 00:06:12.180
gain, which has a physics engine
for basically landing a

00:06:12.180 --> 00:06:13.360
lunar lander.

00:06:13.360 --> 00:06:16.590
So we have constants for the
gravity, the down acceleration

00:06:16.590 --> 00:06:19.610
per second, the fire, so that
is when we turn on our

00:06:19.610 --> 00:06:21.950
thrusters, how much acceleration
is there.

00:06:21.950 --> 00:06:22.375
Fuel.

00:06:22.375 --> 00:06:25.370
All those sorts of things which
normally you would just

00:06:25.370 --> 00:06:27.930
create as constants, but really
do affect the game

00:06:27.930 --> 00:06:30.960
play, and might make sense
to have configurable.

00:06:30.960 --> 00:06:32.690
So how does this
actually work?

00:06:35.750 --> 00:06:37.085
You create a container.

00:06:37.085 --> 00:06:39.080
We're going to look at the
initialization that contains

00:06:39.080 --> 00:06:40.640
your SDK in a little bit.

00:06:40.640 --> 00:06:43.440
But you create it, and then
you go via web browser to

00:06:43.440 --> 00:06:48.410
Google Tag Manager and
edit the settings for

00:06:48.410 --> 00:06:49.490
your various keys.

00:06:49.490 --> 00:06:52.970
So change the values you want.

00:06:52.970 --> 00:06:53.930
And then what happens?

00:06:53.930 --> 00:06:59.930
Your application, which has been
written and uses the SDK,

00:06:59.930 --> 00:07:05.610
the SDK will actually go up and
periodically poll for new

00:07:05.610 --> 00:07:08.930
container values, where
the periodic is

00:07:08.930 --> 00:07:11.000
once every 12 hours.

00:07:11.000 --> 00:07:13.190
So it'll go, grab that
new container, and

00:07:13.190 --> 00:07:16.350
then save it locally.

00:07:16.350 --> 00:07:20.370
As you're making calls to get
values for your keys, it's not

00:07:20.370 --> 00:07:22.110
going to the network
at that point.

00:07:22.110 --> 00:07:25.460
Instead, is using the saved
container, and just going and

00:07:25.460 --> 00:07:26.710
grabbing those values.

00:07:29.660 --> 00:07:32.680
So let's look at a demo.

00:07:32.680 --> 00:07:40.270
I've got a lunar lander.

00:07:40.270 --> 00:07:42.380
So this is the lunar lander,
basically, that you may have

00:07:42.380 --> 00:07:46.830
all seen from one of the
Android sample apps.

00:07:46.830 --> 00:07:52.090
I've modified it slightly to
use the Google Tag Manager.

00:07:52.090 --> 00:07:54.090
So what we have is a Lander.

00:07:54.090 --> 00:07:57.960
I'm trying to land in
the landing pad

00:07:57.960 --> 00:07:59.400
on the bottom right.

00:07:59.400 --> 00:08:02.810
And I'm really not very
good at this.

00:08:02.810 --> 00:08:04.780
And so I always crash.

00:08:04.780 --> 00:08:05.870
There are a number of reasons.

00:08:05.870 --> 00:08:08.660
I always go too fast, but
also, that pad is very

00:08:08.660 --> 00:08:11.620
hard to land on.

00:08:11.620 --> 00:08:14.650
We ship this to the users, and
we find that they try playing

00:08:14.650 --> 00:08:17.370
it three or four times like
me and can't win, and

00:08:17.370 --> 00:08:19.150
give up and go on.

00:08:19.150 --> 00:08:21.440
And so it doesn't monetize
very well,

00:08:21.440 --> 00:08:23.240
and we get bad reviews.

00:08:23.240 --> 00:08:25.940
So it turns out we'd like
to make that pad bigger.

00:08:25.940 --> 00:08:27.190
How can we do that?

00:08:29.480 --> 00:08:34.090
So I've got here Google
Tag Manager.

00:08:34.090 --> 00:08:37.330
We have the different versions,
so I have over time

00:08:37.330 --> 00:08:41.559
published several versions of
these container values.

00:08:41.559 --> 00:08:44.220
Let's look at the version we
have right now, and let's look

00:08:44.220 --> 00:08:45.960
at this collection of values.

00:08:45.960 --> 00:08:49.460
So what I see here is various
values, again, for the

00:08:49.460 --> 00:08:53.370
physics, and then also this
target controls that target at

00:08:53.370 --> 00:08:54.620
the bottom.

00:08:56.450 --> 00:08:57.770
And I can change the width.

00:08:57.770 --> 00:09:00.450
Let's say I change
it from 1.6 to 3.

00:09:00.450 --> 00:09:02.083
I don't really know what the
units are, but I know this

00:09:02.083 --> 00:09:04.010
will be about twice
as wide, right?

00:09:04.010 --> 00:09:06.820
Which sounds good.

00:09:06.820 --> 00:09:09.360
Save this.

00:09:09.360 --> 00:09:11.680
And now that doesn't change
it immediately.

00:09:11.680 --> 00:09:12.940
There are many things
I might want to

00:09:12.940 --> 00:09:15.040
change in my container.

00:09:15.040 --> 00:09:16.290
Various values.

00:09:18.510 --> 00:09:20.780
Once you create a version, that
will actually create a

00:09:20.780 --> 00:09:24.970
numbered version, and then
you can publish it.

00:09:24.970 --> 00:09:26.740
And now that's live.

00:09:26.740 --> 00:09:32.340
So what that means is as lunar
lander applications check back

00:09:32.340 --> 00:09:37.060
into the Google Tag Manager on
the web, they'll get this new

00:09:37.060 --> 00:09:39.060
version, the container.

00:09:39.060 --> 00:09:43.260
But the changes, we've changed
the value of 1.6 to 3.

00:09:43.260 --> 00:09:44.120
So what does that mean?

00:09:44.120 --> 00:09:47.070
That means if I wait 12 hours
here, are maybe on average,

00:09:47.070 --> 00:09:49.860
six hours, I'll get
this new value.

00:09:49.860 --> 00:09:51.200
So--

00:09:51.200 --> 00:09:53.290
well, no, let's not wait.

00:09:53.290 --> 00:09:56.960
So this particular version of
the application is a debug

00:09:56.960 --> 00:09:58.700
version that is checking
back a lot more

00:09:58.700 --> 00:09:59.950
often for demo purposes.

00:10:08.200 --> 00:10:11.120
And as you see here now, it has
a much wider landing pad.

00:10:11.120 --> 00:10:17.980
And so now I have a chance of
actually landing successfully.

00:10:17.980 --> 00:10:21.230
And I think I've done it
once out of 20 times.

00:10:21.230 --> 00:10:24.160
So I used to actually pay
quarters to play this as a

00:10:24.160 --> 00:10:25.990
kid, but as I remember,
I was better at it.

00:10:29.260 --> 00:10:31.580
OK, so that's just a quick
example of this server side

00:10:31.580 --> 00:10:32.420
configuration.

00:10:32.420 --> 00:10:36.090
You just want to change a value
and have it reflected.

00:10:36.090 --> 00:10:38.370
What's the code you have
to write for this?

00:10:38.370 --> 00:10:41.100
Well first, you need a small
amount of initialization.

00:10:41.100 --> 00:10:43.400
The first thing you actually
do is go to Google Tag

00:10:43.400 --> 00:10:45.530
Manager, create an account,
and create

00:10:45.530 --> 00:10:46.780
what we call a container.

00:10:46.780 --> 00:10:48.680
And you get from that
a container ID.

00:10:48.680 --> 00:10:52.660
So this distinguishes that
collection of values.

00:10:52.660 --> 00:10:56.990
We initialize the Tag Manager,
and then create a container.

00:10:56.990 --> 00:11:00.840
Or open the container, rather,
with Open Saved, passing that

00:11:00.840 --> 00:11:03.060
same container ID.

00:11:03.060 --> 00:11:04.810
What will that do?

00:11:04.810 --> 00:11:08.610
Well, it'll spawn a separate
thread to go and try and read

00:11:08.610 --> 00:11:11.490
that saved container
from disk.

00:11:11.490 --> 00:11:14.070
Remember that it caches that
saved container on disk, and

00:11:14.070 --> 00:11:17.780
if that container's not there,
or if it's older than 12

00:11:17.780 --> 00:11:20.420
hours, it'll go out to the
network to try and read the

00:11:20.420 --> 00:11:22.080
freshest version.

00:11:22.080 --> 00:11:25.170
In any case, what'll happen,
while it's doing that, you go

00:11:25.170 --> 00:11:27.750
along doing your other
initialization, and then you

00:11:27.750 --> 00:11:30.420
call container future dot get,
which will return back your

00:11:30.420 --> 00:11:33.020
initialized container.

00:11:33.020 --> 00:11:36.360
Once you have that container,
you have four very simple

00:11:36.360 --> 00:11:40.360
calls. getLong, getString,
getDouble, and getBoolean.

00:11:40.360 --> 00:11:42.340
You give a key, it gives
you back the current

00:11:42.340 --> 00:11:44.360
value for that key.

00:11:44.360 --> 00:11:47.800
And it's really that simple.

00:11:47.800 --> 00:11:50.930
One thing to keep in mind, if
there is no value defined for

00:11:50.930 --> 00:11:52.360
the key, it's not going
to throw an

00:11:52.360 --> 00:11:53.560
exception or anything else.

00:11:53.560 --> 00:11:56.420
It'll return a default
value of zero,

00:11:56.420 --> 00:11:59.930
false, an empty string.

00:11:59.930 --> 00:12:03.012
There's one slight wrinkle.

00:12:03.012 --> 00:12:08.330
You ship your application,
someone downloads it, and then

00:12:08.330 --> 00:12:12.970
they go to run it without
a network connection.

00:12:12.970 --> 00:12:15.200
Well, by what I just said,
there's no container yet.

00:12:15.200 --> 00:12:17.380
We haven't actually downloaded
one from the network, and we

00:12:17.380 --> 00:12:19.080
can't because there's
no network.

00:12:19.080 --> 00:12:22.630
Do you really want to get
zeroes, and empty strings, and

00:12:22.630 --> 00:12:25.820
falses for all of your
values, right?

00:12:25.820 --> 00:12:28.390
No gravity makes the
game easier.

00:12:28.390 --> 00:12:32.890
On the other hand, a width of
zero makes it hard, so that

00:12:32.890 --> 00:12:33.840
wouldn't be good.

00:12:33.840 --> 00:12:38.960
So as well, you embed and ship
within your application

00:12:38.960 --> 00:12:43.200
default values, in the
form of a JSON file.

00:12:43.200 --> 00:12:44.100
Or later on, we'll
see you could

00:12:44.100 --> 00:12:46.510
actually put in a container.

00:12:46.510 --> 00:12:49.220
So you put all the default
values you want, and then

00:12:49.220 --> 00:12:52.520
these will be used only until
the very first time it

00:12:52.520 --> 00:12:55.820
successfully connects and gets
the latest container.

00:12:55.820 --> 00:12:59.720
And from then, the users will
always have the last published

00:12:59.720 --> 00:13:01.960
container version.

00:13:01.960 --> 00:13:03.840
RUSSELL KETCHUM: So up until
this point, we've been talking

00:13:03.840 --> 00:13:06.910
about making configuration
changes that would affect all

00:13:06.910 --> 00:13:07.850
of your users.

00:13:07.850 --> 00:13:09.920
And I think I'd argue, actually,
that in and of

00:13:09.920 --> 00:13:11.760
itself is really powerful.

00:13:11.760 --> 00:13:16.030
But at its core, Google Tag
Manager has a very robust

00:13:16.030 --> 00:13:20.010
rules engine, and when you use
it in concert with these

00:13:20.010 --> 00:13:23.140
server side configuration
macros, you're actually able

00:13:23.140 --> 00:13:27.110
to segment your user base
and get at very targeted

00:13:27.110 --> 00:13:29.680
experiences for different
sets of your users.

00:13:29.680 --> 00:13:32.450
So you can actually serve up
different configurations based

00:13:32.450 --> 00:13:35.940
on what types of users you have,
where they are, who they

00:13:35.940 --> 00:13:37.540
are, those type of elements.

00:13:37.540 --> 00:13:40.380
And Neil's going to show
you a little bit more.

00:13:40.380 --> 00:13:42.810
NEIL RHODES: So let's say, for
instance, we ship your

00:13:42.810 --> 00:13:49.600
application and you find out
via bug reports from users,

00:13:49.600 --> 00:13:53.110
and also, let's say via your
analytics crash exceptions,

00:13:53.110 --> 00:13:56.460
that you have a problem on a
particular version of our own

00:13:56.460 --> 00:13:57.540
operating system.

00:13:57.540 --> 00:13:57.770
OK?

00:13:57.770 --> 00:14:00.780
Android 2.2, you've got a
particular problem, and a

00:14:00.780 --> 00:14:03.820
timeout value you're
using is too short.

00:14:03.820 --> 00:14:07.620
You normally use 3,000
milliseconds, and it turns out

00:14:07.620 --> 00:14:10.060
on this particular OS, you
really need to be using 5,000

00:14:10.060 --> 00:14:11.320
milliseconds.

00:14:11.320 --> 00:14:13.480
So you'd like to make a change
such that on that version of

00:14:13.480 --> 00:14:16.290
the OS you get 5,000, any other
versions you get 3,000.

00:14:16.290 --> 00:14:17.550
What do you do?

00:14:17.550 --> 00:14:19.220
First thing you do
is create a rule.

00:14:19.220 --> 00:14:21.940
A rule that says I'm trying
to target Android 2.2.

00:14:24.680 --> 00:14:27.770
So as you can see here, what we
set up is that the platform

00:14:27.770 --> 00:14:29.200
is equal Android.

00:14:29.200 --> 00:14:31.040
Why do we have to
specify that?

00:14:31.040 --> 00:14:32.645
What's the other possibility
for the platform?

00:14:37.320 --> 00:14:38.800
Guesses?

00:14:38.800 --> 00:14:39.470
iOS, yeah.

00:14:39.470 --> 00:14:42.810
So we have both an iOS
and an Android SDK.

00:14:42.810 --> 00:14:46.910
And then we look at the version
starting with 2.2, so

00:14:46.910 --> 00:14:49.580
we can handle any sub
ones as well.

00:14:49.580 --> 00:14:54.850
Then we set up a value for
our time out to be 5,000.

00:14:54.850 --> 00:14:57.370
And then the critical part is
we put the two together.

00:14:57.370 --> 00:15:02.850
So we say this particular
macro is only enabled on

00:15:02.850 --> 00:15:05.511
Android 2.2.

00:15:05.511 --> 00:15:09.450
So that will ensure that on
those devices, we'll have a

00:15:09.450 --> 00:15:10.980
value of 5,000.

00:15:10.980 --> 00:15:14.800
We still need to make sure the
others have a 3,000, and only

00:15:14.800 --> 00:15:15.760
the others.

00:15:15.760 --> 00:15:19.000
We need to partition all of our
users, because we don't

00:15:19.000 --> 00:15:23.610
want to be specifying more
than one value, right?

00:15:23.610 --> 00:15:27.350
We're 3,000, but we're also
5,000 if it's Android 2.2, and

00:15:27.350 --> 00:15:28.850
then it's a question of
which one to use.

00:15:28.850 --> 00:15:34.240
So we go back and we say, OK,
our timeout of 3,000 is going

00:15:34.240 --> 00:15:38.690
to be enabled always, but we
also have disabling rules.

00:15:38.690 --> 00:15:44.690
So we can actually say if it's
the Android 2.2, then we will

00:15:44.690 --> 00:15:46.860
disable the 3,000 timeout.

00:15:46.860 --> 00:15:51.710
So your choice is either it's
enabled for 2.2 and you have a

00:15:51.710 --> 00:15:55.420
value of 5,000, or if I
have 3,000, which is

00:15:55.420 --> 00:15:57.130
disabled for 2.2.

00:15:57.130 --> 00:15:59.510
And it's one possibility
of what you can do.

00:15:59.510 --> 00:16:01.620
Another thing you could do,
change a value on a

00:16:01.620 --> 00:16:03.880
given date and time.

00:16:03.880 --> 00:16:07.570
As an example, let's say you
have a feature that you want

00:16:07.570 --> 00:16:10.580
to launch on a particular
day and date.

00:16:10.580 --> 00:16:13.830
One way to do that is have a
version of your application

00:16:13.830 --> 00:16:17.210
that you deploy at that time,
but that feature is not really

00:16:17.210 --> 00:16:20.530
going to go live until users
actually go through and do

00:16:20.530 --> 00:16:21.980
their updates.

00:16:21.980 --> 00:16:24.900
Instead, what you might do is
go ahead and write that

00:16:24.900 --> 00:16:29.360
feature behind some flag, some
check for a Boolean.

00:16:29.360 --> 00:16:32.240
And then as soon as that Boolean
switches, that feature

00:16:32.240 --> 00:16:33.480
is suddenly active.

00:16:33.480 --> 00:16:36.010
So in this case we have a
particular enable whiz bang

00:16:36.010 --> 00:16:41.060
feature is true, and then we
have a schedule for when

00:16:41.060 --> 00:16:42.460
that's going to be true.

00:16:42.460 --> 00:16:45.200
So it'll have its default value
other than during this

00:16:45.200 --> 00:16:47.280
time period.

00:16:47.280 --> 00:16:50.810
So it allows you to do all sorts
of things, including

00:16:50.810 --> 00:16:54.830
turn on a particular feature
at a particular time.

00:16:54.830 --> 00:16:57.730
So we've looked at checking
things like the platform, the

00:16:57.730 --> 00:17:01.000
version, and directly
the time.

00:17:01.000 --> 00:17:04.319
What if it's something distinct
to your application,

00:17:04.319 --> 00:17:06.280
or unique to your application?

00:17:06.280 --> 00:17:08.170
We've got that covered
as well.

00:17:08.170 --> 00:17:12.010
So what you can actually do is
have your application publish

00:17:12.010 --> 00:17:16.790
values, which you can then
write rules against.

00:17:16.790 --> 00:17:21.670
Let's say, for example, in our
game here, if we fail to land

00:17:21.670 --> 00:17:24.550
three times or more, then
we want to put up some

00:17:24.550 --> 00:17:25.930
hints to the user.

00:17:25.930 --> 00:17:28.230
Now, that's easy
to code, right?

00:17:28.230 --> 00:17:31.970
But what if that business
logic changes?

00:17:31.970 --> 00:17:34.100
What if you decide that number
shouldn't be three, but

00:17:34.100 --> 00:17:35.210
instead should be four?

00:17:35.210 --> 00:17:36.900
Or you don't want to put
up a hint at all?

00:17:36.900 --> 00:17:39.150
Or you want to do
something else?

00:17:39.150 --> 00:17:42.570
So what we've done here
is we say we have an

00:17:42.570 --> 00:17:44.760
enable hint is true.

00:17:44.760 --> 00:17:47.245
So your code is looking, saying
is enable hint true?

00:17:47.245 --> 00:17:48.540
If so, I'll show a hint.

00:17:48.540 --> 00:17:50.090
If not, I won't.

00:17:50.090 --> 00:17:52.910
And then we have a rule
associated with that, which is

00:17:52.910 --> 00:17:55.170
that the number of failed
attempts is greater than or

00:17:55.170 --> 00:17:56.420
equal to three.

00:17:56.420 --> 00:17:58.910
Where's that num failed
attempts coming from?

00:17:58.910 --> 00:18:02.010
It's coming from your code.

00:18:02.010 --> 00:18:03.840
And this is the code
you write.

00:18:03.840 --> 00:18:08.690
You register a handler that it's
given, basically the name

00:18:08.690 --> 00:18:11.490
of the thing we're interested
in, along with any arguments

00:18:11.490 --> 00:18:12.830
you want to pass.

00:18:12.830 --> 00:18:15.390
Your code then runs and
executes, and delivers back

00:18:15.390 --> 00:18:16.260
the results.

00:18:16.260 --> 00:18:18.250
In this case, of course, it's
very simple and we don't care

00:18:18.250 --> 00:18:19.500
about any arguments.

00:18:22.230 --> 00:18:24.310
What other sorts of macros are
there that are available to

00:18:24.310 --> 00:18:25.920
you out of the box?

00:18:25.920 --> 00:18:30.210
You got the screen size, the
language the user is using,

00:18:30.210 --> 00:18:33.360
app version platform,
OS version.

00:18:33.360 --> 00:18:36.060
And then as well, this backdoor
function call, where

00:18:36.060 --> 00:18:38.250
you can really do anything
you want.

00:18:38.250 --> 00:18:43.070
And then operators will string
numeric operators to deal with

00:18:43.070 --> 00:18:45.930
those values.

00:18:45.930 --> 00:18:47.180
Let's look at a demonstration.

00:18:52.770 --> 00:18:57.260
So let's imagine we ship this
application, and we find

00:18:57.260 --> 00:18:58.760
something odd.

00:18:58.760 --> 00:19:02.630
What we find is, and this is
somewhat contrived, I'll

00:19:02.630 --> 00:19:07.930
admit, we find that the users,
we made this landing pad

00:19:07.930 --> 00:19:09.030
wider, right?

00:19:09.030 --> 00:19:14.060
And we find that users who are
not using English like it.

00:19:14.060 --> 00:19:15.200
How do we know that?

00:19:15.200 --> 00:19:19.860
We both look at their reviews,
and we also use Google

00:19:19.860 --> 00:19:24.070
Analytics and find that if
they're using a lot of

00:19:24.070 --> 00:19:27.180
languages, they interact with
the app audit, and we have

00:19:27.180 --> 00:19:28.320
good modernization.

00:19:28.320 --> 00:19:30.490
But for some reason if they're
using English,

00:19:30.490 --> 00:19:31.490
they don't like it.

00:19:31.490 --> 00:19:33.930
And if we look at the reviews,
they say it's too easy.

00:19:33.930 --> 00:19:36.380
So I guess it's everyone
but me who can

00:19:36.380 --> 00:19:38.680
actually do well at that.

00:19:38.680 --> 00:19:42.530
So we want to go ahead, and with
our application already

00:19:42.530 --> 00:19:47.190
deployed in the field, change
it so that it's harder for

00:19:47.190 --> 00:19:49.910
users when you're running
in English than not.

00:19:49.910 --> 00:19:51.160
Let's look at how we do that.

00:19:55.070 --> 00:19:59.210
So what I'm going to do is take
some of these values.

00:19:59.210 --> 00:20:01.460
I prefer to copy and paste
rather than type, because it's

00:20:01.460 --> 00:20:02.710
so easy to get it wrong.

00:20:08.510 --> 00:20:10.130
And I'm going to create
a new macro.

00:20:10.130 --> 00:20:12.760
This new macro is going
to be [? pard, ?]

00:20:12.760 --> 00:20:14.640
let's say.

00:20:14.640 --> 00:20:20.210
And we are going to make
different values for two of

00:20:20.210 --> 00:20:21.330
these things.

00:20:21.330 --> 00:20:23.130
We're going to make different
values for the width.

00:20:23.130 --> 00:20:25.000
So instead of being three,
we're going to

00:20:25.000 --> 00:20:26.850
take it back to--

00:20:26.850 --> 00:20:28.350
we'll make it 1.7.

00:20:28.350 --> 00:20:29.780
And this is the gravity.

00:20:29.780 --> 00:20:32.340
And we also want to make it
somewhat more difficult for

00:20:32.340 --> 00:20:35.550
them, so I'll make the
gravity be higher.

00:20:35.550 --> 00:20:37.180
We don't want this for
everyone, though.

00:20:37.180 --> 00:20:40.740
We need a rule that says it's
only true for English users.

00:20:40.740 --> 00:20:42.500
Right now we don't have
any good rules, so

00:20:42.500 --> 00:20:44.730
let's create a rule.

00:20:44.730 --> 00:20:48.760
And this rule is going to be,
we're going to call it, I

00:20:48.760 --> 00:20:51.720
don't know, is English,
let's say, or English.

00:20:51.720 --> 00:20:54.570
And if the language
is equal to EN.

00:20:54.570 --> 00:20:59.700
So these are the two character
language codes.

00:20:59.700 --> 00:21:04.160
So this basically says if we're
in English, it's going

00:21:04.160 --> 00:21:06.670
to make the gravity be
55, and the width of

00:21:06.670 --> 00:21:07.920
the landing pad 1.7.

00:21:10.260 --> 00:21:12.410
Remember, I told you we also
have to make sure to deal with

00:21:12.410 --> 00:21:13.870
sort of the non-English case.

00:21:13.870 --> 00:21:15.860
So let's go ahead and make
a macro for that.

00:21:23.990 --> 00:21:26.740
And my copy and paste doesn't
work quite so well because I

00:21:26.740 --> 00:21:27.550
didn't have the right
things in there.

00:21:27.550 --> 00:21:38.280
So I'm going to try and remember
what that was.

00:21:38.280 --> 00:21:39.675
I'm going to call it for
a moment, gravity.

00:21:44.960 --> 00:21:55.225
And then the other was the
target, and the width of 3.0.

00:22:02.000 --> 00:22:05.940
The key part here, though, is
I need-- so every rule needs

00:22:05.940 --> 00:22:07.260
an enabling rule.

00:22:07.260 --> 00:22:08.820
When should this fire?

00:22:08.820 --> 00:22:11.000
Well, we want it
to fire always.

00:22:11.000 --> 00:22:13.360
The disabling rule
says except.

00:22:13.360 --> 00:22:15.670
So except for if it's
in English.

00:22:20.270 --> 00:22:22.020
And I'll need to go back
and change gravity

00:22:22.020 --> 00:22:25.130
to the right name.

00:22:25.130 --> 00:22:27.520
And then the final thing I
need to do is actually go

00:22:27.520 --> 00:22:29.080
change these values
here, right?

00:22:29.080 --> 00:22:31.970
These are values, again, they're
always true, and I

00:22:31.970 --> 00:22:39.540
need to remove both the
width and the gravity.

00:22:39.540 --> 00:22:42.020
Again, because I need to have
this specified only really in

00:22:42.020 --> 00:22:43.820
one place for a given
configuration.

00:22:48.180 --> 00:22:51.450
At this point I can go create
a version and publish.

00:22:51.450 --> 00:22:53.330
What I'm going to do instead,
especially since I didn't

00:22:53.330 --> 00:22:55.910
write that gravity right, is
go ahead and just publish a

00:22:55.910 --> 00:22:58.690
previous version that had these
settings already done,

00:22:58.690 --> 00:23:00.450
and where I typed it right.

00:23:00.450 --> 00:23:03.430
So I publish that, and
that's published.

00:23:03.430 --> 00:23:07.025
So we now have got a rule for
English versus non-English.

00:23:17.960 --> 00:23:18.200
All right.

00:23:18.200 --> 00:23:21.690
So I'm in English, and in fact
what happened, that looks like

00:23:21.690 --> 00:23:24.402
about a 1.7 width, doesn't it?

00:23:24.402 --> 00:23:26.380
At fairly high gravity.

00:23:26.380 --> 00:23:29.620
If I went to a device that had
a non-English language, it'd

00:23:29.620 --> 00:23:30.630
be different.

00:23:30.630 --> 00:23:32.870
Well, let's just go ahead and
change the language here.

00:23:39.640 --> 00:23:42.200
So we'll try Catalan.

00:23:42.200 --> 00:23:44.330
Not that I particularly
understand it.

00:23:58.120 --> 00:24:02.310
And we come back in and
start our game.

00:24:02.310 --> 00:24:06.180
And now we've got the game
that we want for the

00:24:06.180 --> 00:24:07.620
non-English friends.

00:24:07.620 --> 00:24:10.680
So this is just an example
of how the rules work.

00:24:10.680 --> 00:24:13.440
You can make these rules based,
again, on any of the

00:24:13.440 --> 00:24:15.980
predefined macros that we have,
or any settings that you

00:24:15.980 --> 00:24:17.350
want to have from your
application.

00:24:24.310 --> 00:24:26.130
Preview.

00:24:26.130 --> 00:24:29.200
So you make changes to your
container, and you want to

00:24:29.200 --> 00:24:33.090
actually try them out before
you ship them off to your

00:24:33.090 --> 00:24:34.780
thousands, or hundreds
of thousands,

00:24:34.780 --> 00:24:36.970
or millions of customers.

00:24:36.970 --> 00:24:38.390
Kind of makes sense.

00:24:38.390 --> 00:24:39.750
How do you do that?

00:24:39.750 --> 00:24:42.460
Well, in GTM, you choose
Preview and

00:24:42.460 --> 00:24:44.310
it gives you a URL.

00:24:44.310 --> 00:24:48.320
That URL, you then to email
or SMS to your device.

00:24:48.320 --> 00:24:51.120
And from your device,
you open that URL.

00:24:51.120 --> 00:24:54.140
Basically what we do is register
a scheme for you, and

00:24:54.140 --> 00:24:56.010
it opens your application.

00:24:56.010 --> 00:25:00.710
But instead of using either the
saved container or using

00:25:00.710 --> 00:25:03.300
the latest published container,
it will use the

00:25:03.300 --> 00:25:05.520
preview container you
just previewed.

00:25:05.520 --> 00:25:08.660
And you'll then be able to
exercise your application, see

00:25:08.660 --> 00:25:11.700
this working correctly, make any
modifications you want to

00:25:11.700 --> 00:25:14.940
in the container, re-preview
until you're happy, completely

00:25:14.940 --> 00:25:18.080
satisfied, then you hit publish,
and then your users

00:25:18.080 --> 00:25:20.880
also start getting it.

00:25:20.880 --> 00:25:21.830
Best practices.

00:25:21.830 --> 00:25:23.910
One, go ahead and
do that preview.

00:25:23.910 --> 00:25:26.630
Test it before you publish
to your wide world.

00:25:26.630 --> 00:25:28.890
A second one, read your
container values

00:25:28.890 --> 00:25:31.840
at the right time.

00:25:31.840 --> 00:25:34.350
Depending on what values you're
looking at, you may

00:25:34.350 --> 00:25:38.170
want to read the values when you
start your application, or

00:25:38.170 --> 00:25:40.530
in a case here, we went
ahead and read as we

00:25:40.530 --> 00:25:43.430
started a new game.

00:25:43.430 --> 00:25:46.920
What we would not have wanted
done is read as we're doing

00:25:46.920 --> 00:25:49.830
our physics simulation quality
while the user's going.

00:25:49.830 --> 00:25:51.220
For two reasons.

00:25:51.220 --> 00:25:53.370
You want sort of your inner
loop to be as quick as

00:25:53.370 --> 00:25:56.080
possible, and we are doing
some computation.

00:25:56.080 --> 00:25:59.750
And second, imagine the user's
experience if they're playing

00:25:59.750 --> 00:26:01.300
the game, right?

00:26:01.300 --> 00:26:04.400
They're carefully landing.

00:26:04.400 --> 00:26:07.340
We get a new container at the
same time, and suddenly update

00:26:07.340 --> 00:26:09.050
the gravity, and they
slam to the ground.

00:26:09.050 --> 00:26:10.340
Not so fun.

00:26:10.340 --> 00:26:13.520
So it's up to you to determine
when makes sense.

00:26:13.520 --> 00:26:16.830
Actually call these
container values.

00:26:16.830 --> 00:26:19.560
And then finally, set the
appropriate defaults.

00:26:19.560 --> 00:26:21.970
I talked about creating
JSON default.

00:26:21.970 --> 00:26:24.260
So you can actually just
create a JSON file that

00:26:24.260 --> 00:26:27.390
contains all your keys
and the their values.

00:26:27.390 --> 00:26:30.480
As well, though, you can
actually download from Tag

00:26:30.480 --> 00:26:32.970
Manager a version of
the container.

00:26:32.970 --> 00:26:36.720
The binary file, it includes
those same keys and values,

00:26:36.720 --> 00:26:40.150
but more importantly, it
also includes rules.

00:26:40.150 --> 00:26:43.850
So you can have your default
container include rules and

00:26:43.850 --> 00:26:47.270
act differentially on different
macros and different

00:26:47.270 --> 00:26:52.890
devices as part of your
initial container.

00:26:52.890 --> 00:26:55.370
Of course, then it'll still
always use the latest version

00:26:55.370 --> 00:26:56.720
that it gets from the server.

00:27:00.080 --> 00:27:02.010
RUSSELL KETCHUM: So with that, I
hope you could tell Neil and

00:27:02.010 --> 00:27:05.290
I are pretty fired up about GTM
for mobile apps, and it's

00:27:05.290 --> 00:27:07.100
something that we're
announcing today.

00:27:07.100 --> 00:27:09.500
It's not been generally
available up until this point,

00:27:09.500 --> 00:27:12.590
and we'd like to invite all of
you to join the white list.

00:27:12.590 --> 00:27:15.830
You can go to this short URL,
fill out a quick form, and

00:27:15.830 --> 00:27:18.320
that will sign you up for the
process, and we'll be adding

00:27:18.320 --> 00:27:20.130
you in the next few weeks.

00:27:20.130 --> 00:27:22.990
Also, on your way in or at the
back of the room, we had one

00:27:22.990 --> 00:27:26.230
sheeters that should give you
the exact same information

00:27:26.230 --> 00:27:28.040
this links on there, so you
don't need to snap a picture

00:27:28.040 --> 00:27:30.770
of the screen if you
don't want to.

00:27:30.770 --> 00:27:32.950
And yeah, then you can just go
ahead and get at it, and

00:27:32.950 --> 00:27:35.420
hopefully start using
GTM in your apps.

00:27:35.420 --> 00:27:37.890
And with that, I'd like
to open it up for some

00:27:37.890 --> 00:27:39.140
questions thank you.

00:27:43.930 --> 00:27:45.750
I think there's mics in the
middle, if you guys want to

00:27:45.750 --> 00:27:47.310
head to those.

00:27:47.310 --> 00:27:52.000
MALE SPEAKER: So concerning the
rules and like the time

00:27:52.000 --> 00:27:55.070
rule, where it says something
should be applied for a

00:27:55.070 --> 00:27:59.960
certain number of days, is
that controlling when--

00:28:02.630 --> 00:28:05.690
is that being evaluated on the
device, or is that being

00:28:05.690 --> 00:28:06.850
evaluated as to when it

00:28:06.850 --> 00:28:08.690
delivers the updated container?

00:28:08.690 --> 00:28:11.110
NEIL RHODES: So that's
a good question.

00:28:11.110 --> 00:28:15.580
Most of the rules, virtually all
the rules except the one

00:28:15.580 --> 00:28:18.980
exception you're having there
are evaluated on the device.

00:28:18.980 --> 00:28:21.590
So there's nothing that's
happening on the server.

00:28:21.590 --> 00:28:25.220
That particular one is done on
the server, so it actually

00:28:25.220 --> 00:28:28.150
controls what's coming down
in the container.

00:28:28.150 --> 00:28:31.720
We are looking to try and add a
time based one that can also

00:28:31.720 --> 00:28:32.940
run on the device.

00:28:32.940 --> 00:28:34.490
MALE SPEAKER: Right, because it
would control how sharply

00:28:34.490 --> 00:28:35.730
you could start a future.

00:28:35.730 --> 00:28:36.200
MALE SPEAKER: Exactly.

00:28:36.200 --> 00:28:39.020
Because the question is, right,
do you have to wait

00:28:39.020 --> 00:28:41.260
sort of the 12 hours for it to
trickle down, or does it

00:28:41.260 --> 00:28:44.980
happen hour and minute?

00:28:44.980 --> 00:28:46.580
RUSSELL KETCHUM: That is an
important point Neil touches

00:28:46.580 --> 00:28:49.440
on, though, because a lot of
those rules obviously could

00:28:49.440 --> 00:28:52.200
raise privacy concerns, and so
it's critically important from

00:28:52.200 --> 00:28:55.240
our standpoint that that data
never comes up over the wire.

00:28:55.240 --> 00:28:57.730
So all those different
parameters that we're making

00:28:57.730 --> 00:28:59.980
decisions about for those
rules, that's all being

00:28:59.980 --> 00:29:02.415
evaluated client side.

00:29:02.415 --> 00:29:03.190
NEIL RHODES: Except
that one case.

00:29:03.190 --> 00:29:05.840
MALE SPEAKER: OK, thanks.

00:29:05.840 --> 00:29:07.090
MALE SPEAKER: Can you
define a rule based

00:29:07.090 --> 00:29:08.760
on the device model?

00:29:08.760 --> 00:29:09.330
NEIL RHODES: You can.

00:29:09.330 --> 00:29:11.625
So what we have right now is--

00:29:17.600 --> 00:29:19.370
I don't remember, to
tell you the truth.

00:29:19.370 --> 00:29:22.490
If not, we should add it.

00:29:22.490 --> 00:29:23.310
MALE SPEAKER: It would
be very useful.

00:29:23.310 --> 00:29:26.870
Sometimes there are bugs on not
Android version specific,

00:29:26.870 --> 00:29:28.455
but device specific.

00:29:28.455 --> 00:29:30.290
NEIL RHODES: That makes tons
of sense, and I just don't

00:29:30.290 --> 00:29:31.160
remember off the
top of my head.

00:29:31.160 --> 00:29:32.530
But if not, we should have it.

00:29:32.530 --> 00:29:34.140
RUSSELL KETCHUM: It may not
in the initial set,

00:29:34.140 --> 00:29:35.370
but it'll be there.

00:29:35.370 --> 00:29:35.780
MALE SPEAKER: Yeah.

00:29:35.780 --> 00:29:36.830
Thank you.

00:29:36.830 --> 00:29:37.600
MALE SPEAKER: Hi.

00:29:37.600 --> 00:29:40.240
I was wondering, how does this
affect testability of the app?

00:29:40.240 --> 00:29:43.620
Is there any way I can swap out
configuration when I run

00:29:43.620 --> 00:29:45.670
uni-tests and stuff?

00:29:45.670 --> 00:29:47.160
RUSSELL KETCHUM: So that's
a great question.

00:29:47.160 --> 00:29:51.010
There are two issues for this.

00:29:51.010 --> 00:29:56.200
So let me see what the best--

00:29:56.200 --> 00:29:58.070
the uni-testing is a good
question, and I don't have an

00:29:58.070 --> 00:30:00.386
answer to you this minute.

00:30:00.386 --> 00:30:04.240
The other question, though, is
let's say you have a product

00:30:04.240 --> 00:30:07.380
manager who, you write some new
version, and they want to

00:30:07.380 --> 00:30:08.870
see, what's it going
to look like?

00:30:08.870 --> 00:30:09.330
Right?

00:30:09.330 --> 00:30:13.120
But it's not enabled
in your container.

00:30:13.120 --> 00:30:15.740
You don't want to go publish a
new container that will send

00:30:15.740 --> 00:30:16.520
out to the rest of the world.

00:30:16.520 --> 00:30:20.110
So we actually have the idea of
a preview mode, where you

00:30:20.110 --> 00:30:24.720
can actually set values to
override what would normally

00:30:24.720 --> 00:30:25.910
be in the container.

00:30:25.910 --> 00:30:27.695
MALE SPEAKER: OK, so that would
be something I can use

00:30:27.695 --> 00:30:30.170
in tests as well?

00:30:30.170 --> 00:30:31.615
NEIL RHODES: So what that
actually will do is launch

00:30:31.615 --> 00:30:33.140
your application in
this version.

00:30:33.140 --> 00:30:34.500
It's also a URL.

00:30:34.500 --> 00:30:36.220
I don't how appropriate that
would be for testing.

00:30:38.980 --> 00:30:40.230
MALE SPEAKER: OK, thanks.

00:30:42.530 --> 00:30:44.650
MALE SPEAKER: So right now it
looks like you primarily

00:30:44.650 --> 00:30:47.840
support basic data types
for your containers.

00:30:47.840 --> 00:30:50.770
What would be the plan for
expanding that to, like,

00:30:50.770 --> 00:30:54.295
custom data types, or other
types of customized ability?

00:30:54.295 --> 00:30:57.280
NEIL RHODES: What sorts of
things are you interested in?

00:30:57.280 --> 00:30:58.920
MALE SPEAKER: I didn't really
have anything specific, but I

00:30:58.920 --> 00:31:00.600
guess just in general, if you
were to create your own

00:31:00.600 --> 00:31:07.540
classes, or if there were some
non-standard, or non-primitive

00:31:07.540 --> 00:31:14.130
types that you wanted configure
somehow through GTM.

00:31:14.130 --> 00:31:14.300
NEIL RHODES: Sure.

00:31:14.300 --> 00:31:17.690
Our answer right now
is, and we may

00:31:17.690 --> 00:31:18.890
expand this in the future.

00:31:18.890 --> 00:31:21.180
But right now the answer
is if you want.

00:31:21.180 --> 00:31:24.020
So we have strings.

00:31:24.020 --> 00:31:25.830
If you have strings, you can
do whatever you want.

00:31:25.830 --> 00:31:28.400
You could, for instance, put
JSON in a string, and you

00:31:28.400 --> 00:31:30.810
could compile that if you want
in some structured data.

00:31:30.810 --> 00:31:33.650
MALE SPEAKER: Or figure out a
way to serialize something

00:31:33.650 --> 00:31:37.770
that you could, I don't know,
abstract into GTM, and then

00:31:37.770 --> 00:31:39.660
re-parcel it, or something.

00:31:39.660 --> 00:31:40.410
NEIL RHODES: You
could do that.

00:31:40.410 --> 00:31:44.260
We don't have any current plans
for making that easier

00:31:44.260 --> 00:31:46.410
than serializing, de-serializing
yourself.

00:31:46.410 --> 00:31:49.150
MALE SPEAKER: Thanks.

00:31:49.150 --> 00:31:51.550
MALE SPEAKER: Is there a way to
create a rule to target a

00:31:51.550 --> 00:31:53.810
certain percentage of devices
so that I could do A/B

00:31:53.810 --> 00:31:55.720
testing, or 5% of--

00:31:55.720 --> 00:31:57.470
NEIL RHODES: So let me
tell you something.

00:31:57.470 --> 00:32:01.480
So prior to December, I was
lead of the content

00:32:01.480 --> 00:32:05.000
experiments team, where we did
experimentation for the web.

00:32:05.000 --> 00:32:08.190
And the way I got into this,
so this is not a product

00:32:08.190 --> 00:32:10.780
announcement, but the way I got
into this was I wanted to

00:32:10.780 --> 00:32:14.150
be able to do experimentation
for mobile apps, and came up

00:32:14.150 --> 00:32:16.410
with the concept of doing the
keys and values, because it

00:32:16.410 --> 00:32:18.910
made tons of sense to do
that as a way to do

00:32:18.910 --> 00:32:20.160
experimentation.

00:32:20.160 --> 00:32:23.760
So you could, for instance, say
30 percent of my users, I

00:32:23.760 --> 00:32:26.760
want to do some A/B testing,
change this value or that

00:32:26.760 --> 00:32:29.620
value, or these set of values
and that set of values.

00:32:29.620 --> 00:32:34.760
That's how I got into this, and
it continues to be a key

00:32:34.760 --> 00:32:36.590
interest, but we don't have any
announcements right now.

00:32:36.590 --> 00:32:39.570
MALE SPEAKER: OK, thanks.

00:32:39.570 --> 00:32:42.860
NEIL RHODES: But it does
make perfect sense.

00:32:42.860 --> 00:32:43.680
MALE SPEAKER: Hi.

00:32:43.680 --> 00:32:46.480
you mentioned that most
of the rules are

00:32:46.480 --> 00:32:48.450
evaluated client side.

00:32:48.450 --> 00:32:51.710
So if I have a lot of rules,
does this mean every time they

00:32:51.710 --> 00:32:54.300
are all sent to the device?

00:32:54.300 --> 00:32:55.440
NEIL RHODES: So this
doesn't mean every

00:32:55.440 --> 00:32:56.820
time they're all sent.

00:32:56.820 --> 00:33:00.400
We do have the opportunity,
we're not doing it right now,

00:33:00.400 --> 00:33:02.960
but we have the opportunity
for sending down

00:33:02.960 --> 00:33:04.510
differential updates.

00:33:04.510 --> 00:33:07.400
So if you've got version 10 of
the container and version 11

00:33:07.400 --> 00:33:10.005
of the container comes down, we
can send the difs instead

00:33:10.005 --> 00:33:11.770
of sending the entire
container.

00:33:11.770 --> 00:33:15.150
But right now, yes, that
is what's happening.

00:33:15.150 --> 00:33:19.140
Eventually, the entire container
has to make it down.

00:33:19.140 --> 00:33:21.690
Having said that, we do have
the opportunity for some

00:33:21.690 --> 00:33:26.080
server side up optimizations,
like there's no reason to send

00:33:26.080 --> 00:33:31.770
down rules for iOS if it's
an Android device.

00:33:31.770 --> 00:33:34.660
We're not doing that server
side partial evaluation at

00:33:34.660 --> 00:33:36.390
this point, though.

00:33:36.390 --> 00:33:36.830
MALE SPEAKER: Thank you.

00:33:36.830 --> 00:33:38.140
RUSSELL KETCHUM: So we're
just about over time.

00:33:38.140 --> 00:33:39.896
Maybe we can squeeze in just
one last question, then I

00:33:39.896 --> 00:33:41.180
think we'll have
to wrap it up.

00:33:41.180 --> 00:33:43.010
MALE SPEAKER: So you said
you have an iOS SDK.

00:33:43.010 --> 00:33:46.350
Do you have this in the wild and
in the apps yet, for iOS'

00:33:46.350 --> 00:33:49.210
that have been through the
app store approval yet?

00:33:49.210 --> 00:33:50.840
RUSSELL KETCHUM: So actually,
there's a piece of

00:33:50.840 --> 00:33:54.130
functionality we didn't talk
about here, which it actually

00:33:54.130 --> 00:33:55.820
is called public preview.

00:33:55.820 --> 00:33:58.960
And so you have the opportunity
with kind of the

00:33:58.960 --> 00:34:00.790
Apple review process when
you're going through the

00:34:00.790 --> 00:34:04.790
iTunes Connect, you can actually
provide URLs that

00:34:04.790 --> 00:34:07.960
anybody with that URL can use
to see the experience.

00:34:07.960 --> 00:34:11.550
Because we're hypersensitive to
the issue of not wanting to

00:34:11.550 --> 00:34:15.489
empower developers to ship
hidden features, and so that's

00:34:15.489 --> 00:34:17.510
what these public preview
URLs are intended to do.

00:34:17.510 --> 00:34:21.000
So the premise is effectively,
build the app the

00:34:21.000 --> 00:34:22.050
way you want it.

00:34:22.050 --> 00:34:24.210
And then you as the developer,
the onus is on you to kind of

00:34:24.210 --> 00:34:27.020
communicate everything that
your app does to Apple.

00:34:27.020 --> 00:34:29.620
And you can use these public
preview URLs so that their

00:34:29.620 --> 00:34:32.480
reviewers can actually see
exactly the experiences that

00:34:32.480 --> 00:34:33.699
you're intending to release.

00:34:33.699 --> 00:34:34.179
MALE SPEAKER: OK.

00:34:34.179 --> 00:34:36.030
But you don't know of any apps
that have gone through

00:34:36.030 --> 00:34:37.150
approval yet with this?

00:34:37.150 --> 00:34:37.642
RUSSELL KETCHUM: No.

00:34:37.642 --> 00:34:39.610
MALE SPEAKER: OK.

00:34:39.610 --> 00:34:40.600
RUSSELL KETCHUM: All right.

00:34:40.600 --> 00:34:41.280
So I think that's it.

00:34:41.280 --> 00:34:42.080
Thanks again.

00:34:42.080 --> 00:34:44.800
One last thing, on your way out,
if you want to hit those

00:34:44.800 --> 00:34:46.949
QR codes at the back to
rate the session.

00:34:46.949 --> 00:34:49.320
NEIL RHODES: And one last last
thing is we're available at

00:34:49.320 --> 00:34:51.770
the sandbox, at the analytic
sandbox if you have any

00:34:51.770 --> 00:34:53.820
further questions or want to
talk to us individually.

00:34:53.820 --> 00:34:54.409
Thanks very much.

00:34:54.409 --> 00:34:55.659
RUSSELL KETCHUM: Thanks,
everyone.

