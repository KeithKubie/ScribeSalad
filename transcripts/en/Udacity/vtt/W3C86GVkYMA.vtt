WEBVTT
Kind: captions
Language: en

00:00:00.270 --> 00:00:02.210
Alright, we're back, what's the answer Michael?

00:00:02.210 --> 00:00:04.880
&gt;&gt; So, you want me to work it through?

00:00:04.880 --> 00:00:05.570
&gt;&gt; Sure.

00:00:05.570 --> 00:00:09.980
&gt;&gt; So what I did first is I made it to, I extended the table that you had.

00:00:09.980 --> 00:00:10.770
&gt;&gt; Okay.

00:00:10.770 --> 00:00:12.970
&gt;&gt; To include each of these, the output for each of

00:00:12.970 --> 00:00:15.220
these three functions. What I'm basically, what I like to do is

00:00:15.220 --> 00:00:19.180
compute the squared error for each of these three functions on that

00:00:19.180 --> 00:00:22.460
data and then choose the one that has the lowest squared error.

00:00:22.460 --> 00:00:23.870
&gt;&gt; Make total sense to me. Sounds good

00:00:23.870 --> 00:00:25.310
enough to be an algorithm. So you want me

00:00:25.310 --> 00:00:25.940
to write out the table?

00:00:25.940 --> 00:00:28.720
&gt;&gt; Well, I mean, I started to do that, and then there

00:00:28.720 --> 00:00:30.870
was like one too many steps, and I just threw out my

00:00:30.870 --> 00:00:33.980
hand and just wrote a program. Okay, so, we'll just say"

00:00:33.980 --> 00:00:37.790
Insert code here", because that's what you did, that was the step.

00:00:37.790 --> 00:00:38.780
&gt;&gt; And, what did your code tell you?

00:00:38.780 --> 00:00:40.900
&gt;&gt; Well, let me start with the constant function, because that's the

00:00:40.900 --> 00:00:44.630
easiest piece of code. So, I'm saying what's the difference between each

00:00:44.630 --> 00:00:47.340
of the D values and two. Squaring it all and summing it

00:00:47.340 --> 00:00:52.050
up and I get 19. And I can do the same thing,

00:00:54.200 --> 00:00:59.170
instead of using two I use x over three take the difference of that

00:00:59.170 --> 00:01:03.680
to the D values and square that and I get 19 point four, four, four,

00:01:03.680 --> 00:01:08.510
four, four, four. Then I can do, right, so now at this point I'm

00:01:08.510 --> 00:01:12.790
rock and rolling. I can actually just substitute in my nine, and I get 12?

00:01:12.790 --> 00:01:15.280
&gt;&gt; Not, not something-odd 12?

00:01:15.280 --> 00:01:19.430
&gt;&gt; No, just 12, so the error's 12. So that has the smallest error.

00:01:19.430 --> 00:01:22.120
So even though that's sort of a crazy, like, stripy function

00:01:22.120 --> 00:01:24.990
right. Like, it increases linearly and then it resets at 9.

00:01:24.990 --> 00:01:25.180
&gt;&gt; Mmhmm.

00:01:25.180 --> 00:01:27.650
&gt;&gt; It actually fits the state of the best.

00:01:27.650 --> 00:01:33.710
&gt;&gt; That is correct. Your code is correct, Michael. Well done. Well actually,

00:01:33.710 --> 00:01:36.410
looking at this data that sort of makes sense to me, right. Because

00:01:36.410 --> 00:01:40.420
if you look at the first three examples. Of the data, the outputs

00:01:40.420 --> 00:01:45.140
are very close. But the outputs of the next three are much bigger, and

00:01:45.140 --> 00:01:47.930
by doing a mod nine, what you effectively do is

00:01:47.930 --> 00:01:52.150
say, this is the identity function above this line. And then

00:01:52.150 --> 00:01:54.760
below the line, it's as if I'm sort of subtracting

00:01:54.760 --> 00:01:56.680
nine from all of them, and that makes them closer together.

00:01:56.680 --> 00:01:57.380
&gt;&gt; Hm.

00:01:57.380 --> 00:01:58.610
&gt;&gt; And so it just happens to work out

00:01:58.610 --> 00:02:00.910
here. But surely that's just because we came up

00:02:00.910 --> 00:02:03.290
with a bad constant function and a bad linear

00:02:03.290 --> 00:02:05.170
function. Do you think there's a better linear function?

00:02:05.170 --> 00:02:08.220
&gt;&gt; So I mean because it's the squared

00:02:08.220 --> 00:02:10.560
error, we're really just talking about linear regression.

00:02:10.560 --> 00:02:10.660
&gt;&gt; Right.

00:02:10.660 --> 00:02:13.160
&gt;&gt; So I can just run linear regression. So I get

00:02:13.160 --> 00:02:18.885
an intercept of 0.9588 And a, and a slope of 0.1647.

00:02:18.885 --> 00:02:19.270
&gt;&gt; Okay

00:02:19.270 --> 00:02:22.070
&gt;&gt; So that's, so that's my linear function of choice.

00:02:22.070 --> 00:02:24.474
&gt;&gt; Okay, so that's, what was, what was that again?

00:02:24.474 --> 00:02:31.816
&gt;&gt; So x times, you know, it's like a six, I guess, like 0.165 probably.

00:02:31.816 --> 00:02:32.973
&gt;&gt; 0.165x

00:02:32.973 --> 00:02:33.395
&gt;&gt; Plus

00:02:33.395 --> 00:02:33.819
&gt;&gt; Mm hm.

00:02:33.819 --> 00:02:36.940
&gt;&gt; Plus 0.959. So that's

00:02:36.940 --> 00:02:38.540
our function, that's our best linear function,

00:02:38.540 --> 00:02:40.490
the function that minimizes greater. So it better

00:02:40.490 --> 00:02:44.640
end up being, it better end up being less than 19.4, or I'm a liar.

00:02:44.640 --> 00:02:45.211
&gt;&gt; Mm-hm.

00:02:45.211 --> 00:02:47.680
&gt;&gt; And now I need to take the difference

00:02:47.680 --> 00:02:52.935
between that and D square it, and sum. 15.7.

00:02:52.935 --> 00:02:59.350
&gt;&gt; Hm. So that gives you 15, I'm going to say 15.8. So that is better.

00:02:59.350 --> 00:03:02.050
&gt;&gt; Yeah, so it's better than the X over three,

00:03:02.050 --> 00:03:03.870
but it's also worse than the mod nie.

00:03:03.870 --> 00:03:04.110
&gt;&gt; Hm.

00:03:04.110 --> 00:03:08.750
&gt;&gt; and the best constant function, has to be worse, because the linear

00:03:08.750 --> 00:03:13.110
functions include the constant functions as a subset, so this is, that 15.8 is.

00:03:13.110 --> 00:03:16.100
Is better than the best constant function too. Oh its easy to do

00:03:16.100 --> 00:03:19.280
though right? Because the best constant function is just the mean of the data.

00:03:19.280 --> 00:03:22.110
&gt;&gt; What is the mean of the data?

00:03:22.110 --> 00:03:22.410
&gt;&gt; 2.17.

00:03:22.410 --> 00:03:23.740
&gt;&gt; huh two is pretty close.

00:03:23.740 --> 00:03:25.360
&gt;&gt; Yeah that's interesting.

00:03:25.360 --> 00:03:26.020
&gt;&gt; Well that's

00:03:26.020 --> 00:03:27.120
&gt;&gt; Kind of in the middle of the pack

00:03:27.120 --> 00:03:27.480
I guess.

00:03:27.480 --> 00:03:29.560
&gt;&gt; That sort of works right because two the error

00:03:29.560 --> 00:03:32.010
for two was actually lower than the error for x divided

00:03:32.010 --> 00:03:34.055
by three. And for what it's worth the error for

00:03:34.055 --> 00:03:40.143
2.17 as constant function to 2.2 is 8.8, 18.8, 18.8 sorry.

00:03:40.143 --> 00:03:42.149
&gt;&gt; Yeah, you're not the [INAUDIBLE].

00:03:42.149 --> 00:03:43.770
&gt;&gt; Yeah, eight would have been less than everything.

00:03:43.770 --> 00:03:46.880
&gt;&gt; Okay. So, what have we learned here?

00:03:46.880 --> 00:03:48.710
&gt;&gt; That sometimes you want to use mod.

00:03:48.710 --> 00:03:49.470
&gt;&gt; Yeah.

00:03:49.470 --> 00:03:51.478
&gt;&gt; If your data is weird. [LAUGH]

00:03:51.478 --> 00:03:52.440
&gt;&gt; You have you

00:03:52.440 --> 00:03:54.800
have definitely modified my box.

00:03:54.800 --> 00:03:59.462
&gt;&gt; Well I'm glad you found it mod. Hmm. [LAUGH]

00:03:59.462 --> 00:04:02.100
PUNS. Okay, good, so I think that was

00:04:02.100 --> 00:04:03.810
a good, that was, that was a good exercise.

00:04:03.810 --> 00:04:06.090
So I'm going to give you one more example

00:04:06.090 --> 00:04:08.450
of deriving something and then we're going to move on.

00:04:08.450 --> 00:04:09.150
&gt;&gt; Cool.

00:04:09.150 --> 00:04:09.690
&gt;&gt; Okay.

