WEBVTT
Kind: captions
Language: en

00:00:01.167 --> 00:00:03.067
Fisher: Gonna talk to you
about Chrome internals.

00:00:03.067 --> 00:00:05.200
So I'm Darin Fisher.

00:00:05.200 --> 00:00:06.701
I'm a member
of the Chrome team.

00:00:06.701 --> 00:00:08.534
I've actually been with
the project since inception,

00:00:08.534 --> 00:00:10.734
back in 2006.

00:00:10.734 --> 00:00:12.601
And today is just
an opportunity to go through

00:00:12.601 --> 00:00:16.334
all of the stuff that's
underneath the hood.

00:00:16.334 --> 00:00:18.467
And so there'll be things
that you may

00:00:18.467 --> 00:00:20.434
have heard about before
if you've read the comic.

00:00:20.434 --> 00:00:22.100
But, you know,
I just wanted to cover

00:00:22.100 --> 00:00:23.400
as much ground as I could

00:00:23.400 --> 00:00:25.334
and discuss
all the different things

00:00:25.334 --> 00:00:29.000
that go into
Chrome's architecture.

00:00:29.000 --> 00:00:32.067
So this was our guiding
principle from day one.

00:00:32.067 --> 00:00:33.701
We really wanted
to make sure

00:00:33.701 --> 00:00:36.701
that we were stressing a very
simple interface to Chrome.

00:00:36.701 --> 00:00:40.067
And, you know,
that would allow people

00:00:40.067 --> 00:00:41.767
to very easily and naturally

00:00:41.767 --> 00:00:44.267
get to a very fast browser,
a very powerful browser,

00:00:44.267 --> 00:00:46.334
leveraging this, you know,
powerful architecture,

00:00:46.334 --> 00:00:48.000
but they don't see
or be burdened

00:00:48.000 --> 00:00:50.234
by the architecture.

00:00:50.234 --> 00:00:53.133
This sort of reminded us

00:00:53.133 --> 00:00:56.234
of the way Google.com's
search experience was,

00:00:56.234 --> 00:00:59.100
and so here's just
a little image of Chrome,

00:00:59.100 --> 00:01:00.934
very simple Chrome
that you've all seen

00:01:00.934 --> 00:01:02.267
in a little photo of--

00:01:02.267 --> 00:01:03.934
taken off of
one of the design docs of--

00:01:03.934 --> 00:01:07.067
for Chrome's architecture.

00:01:07.067 --> 00:01:09.234
Just a little aside,

00:01:09.234 --> 00:01:12.467
this is actually rendered
using HTML.

00:01:12.467 --> 00:01:14.501
Actually thought I would
just quickly show this,

00:01:14.501 --> 00:01:16.133
because it's interesting.

00:01:16.133 --> 00:01:18.167
It's using
a WebKit gradient effect

00:01:18.167 --> 00:01:20.200
on a straight-off image.

00:01:20.200 --> 00:01:23.300
So it's kind of neat

00:01:23.300 --> 00:01:26.334
that you can do all this
kinds of stuff in WebKit,

00:01:26.334 --> 00:01:30.434
which Chrome is based on.

00:01:30.434 --> 00:01:32.934
Okay, so here's
a little quote

00:01:32.934 --> 00:01:34.901
that I'm not really sure
who to attribute it to,

00:01:34.901 --> 00:01:37.100
but back in 2006
it was something

00:01:37.100 --> 00:01:38.868
that we were all thinking
about it at the time.

00:01:38.868 --> 00:01:40.567
"Modern browsers
really resemble

00:01:40.567 --> 00:01:43.300
co-operatively multi-tasked
operating systems of the past."

00:01:43.300 --> 00:01:44.701
So what do I mean?

00:01:44.701 --> 00:01:47.934
You can think back to
older versions of Windows,

00:01:47.934 --> 00:01:51.234
older versions of Mac OS,
where if any process,

00:01:51.234 --> 00:01:53.734
any application
on your system

00:01:53.734 --> 00:01:56.901
decided to go into
an infinite loop or crashed,

00:01:56.901 --> 00:01:58.667
it could bring down your
whole entire operating system,

00:01:58.667 --> 00:02:00.501
and you'd lose
all your applications.

00:02:00.501 --> 00:02:04.367
And this was what the state
of browsers were back then.

00:02:04.367 --> 00:02:06.300
And it seemed
very unfortunate,

00:02:06.300 --> 00:02:08.334
especially as web applications
were getting larger

00:02:08.334 --> 00:02:09.667
and more complicated.

00:02:09.667 --> 00:02:11.501
I mean, oftentimes
you'd have the experience

00:02:11.501 --> 00:02:15.501
of going--composing an e-mail
and suddenly deciding,

00:02:15.501 --> 00:02:16.734
you know, I want
to go do a search,

00:02:16.734 --> 00:02:18.200
I want to go do something else,

00:02:18.200 --> 00:02:20.567
and branching off
to go get some information

00:02:20.567 --> 00:02:22.968
and venturing to a website
that maybe somehow

00:02:22.968 --> 00:02:24.968
unfortunately triggers
a browser bug,

00:02:24.968 --> 00:02:27.267
and then you completely lose
what you were working on

00:02:27.267 --> 00:02:28.701
in that other tab.

00:02:28.701 --> 00:02:30.701
This just seemed like a very
unfortunate situation to us,

00:02:30.701 --> 00:02:32.167
and we were just thinking,
you know,

00:02:32.167 --> 00:02:33.667
modern operating systems
solved this

00:02:33.667 --> 00:02:36.968
by separation of applications
into different processes.

00:02:36.968 --> 00:02:40.200
So couldn't we exploit that?

00:02:40.200 --> 00:02:42.300
And the goals of--

00:02:42.300 --> 00:02:44.934
Speaking more about goals
for Chrome back in the day,

00:02:44.934 --> 00:02:47.501
beyond just a simple interface,
we really wanted to see

00:02:47.501 --> 00:02:49.100
what we could do
to really move the bar

00:02:49.100 --> 00:02:51.267
in terms of speed,
stability, and security.

00:02:51.267 --> 00:02:54.000
We felt like, as applications
were getting more complicated,

00:02:54.000 --> 00:02:56.133
you know,
speed was very important.

00:02:56.133 --> 00:02:57.901
As applications
were getting more complicated,

00:02:57.901 --> 00:03:00.367
it was more likely that you
could have instability issues

00:03:00.367 --> 00:03:01.701
causing problems,

00:03:01.701 --> 00:03:03.167
and so how could we solve
all these problems?

00:03:03.167 --> 00:03:05.634
Again, multi-process
architecture.

00:03:05.634 --> 00:03:07.534
If we could divide
the application

00:03:07.534 --> 00:03:09.100
over multiple processes,
you know,

00:03:09.100 --> 00:03:11.067
it'd be great
if you could have web apps

00:03:11.067 --> 00:03:12.701
each having their own thread,
and you get this

00:03:12.701 --> 00:03:14.334
if each web app
has its own process.

00:03:14.334 --> 00:03:15.868
Separate address spaces.

00:03:15.868 --> 00:03:18.434
If each web application
has its own address space,

00:03:18.434 --> 00:03:20.801
its own process,
then there's some insulation

00:03:20.801 --> 00:03:23.667
in case one of the applications
happens to trigger a bug

00:03:23.667 --> 00:03:25.100
and cause a crash.

00:03:25.100 --> 00:03:28.234
Similarly, if your applications
are consuming a lot of memory

00:03:28.234 --> 00:03:31.367
and they're all sharing
one giant heap together,

00:03:31.367 --> 00:03:33.167
you can have
performance problems.

00:03:33.167 --> 00:03:35.767
But with separate app processes
and separate address spaces,

00:03:35.767 --> 00:03:37.467
each one having
its own memory pools,

00:03:37.467 --> 00:03:38.868
you have a lot
of smaller memory pools,

00:03:38.868 --> 00:03:40.701
and better performance ensues.

00:03:40.701 --> 00:03:42.067
Security.

00:03:42.067 --> 00:03:44.767
So given that we were
actually leveraging

00:03:44.767 --> 00:03:46.234
operating system processes,

00:03:46.234 --> 00:03:48.567
and operating systems
already have the idea

00:03:48.567 --> 00:03:52.300
that a process might have
certain capabilities

00:03:52.300 --> 00:03:55.634
based on the use
associated with that process.

00:03:55.634 --> 00:03:59.701
Seems like we could leverage
the operating system's support

00:03:59.701 --> 00:04:02.067
for taking away privileges
from a process

00:04:02.067 --> 00:04:04.067
or limiting the privileges
of a process,

00:04:04.067 --> 00:04:07.834
and thereby achieve a sandbox
to run web applications.

00:04:07.834 --> 00:04:10.767
And this would be great
because, well,

00:04:10.767 --> 00:04:13.501
we know that software
is just enormously complicated.

00:04:13.501 --> 00:04:15.334
And if there's
any kind of bug,

00:04:15.334 --> 00:04:17.968
and that bug
allows an attacker

00:04:17.968 --> 00:04:21.367
to get code running with
the privileges of the user,

00:04:21.367 --> 00:04:22.968
then they can do things

00:04:22.968 --> 00:04:24.467
that would potentially
harm the user,

00:04:24.467 --> 00:04:25.968
'cause they have
the power of the user.

00:04:25.968 --> 00:04:27.300
And so we really
liked the idea

00:04:27.300 --> 00:04:29.200
of there being
this belt and suspenders,

00:04:29.200 --> 00:04:32.067
this secondary level
of protection, the sandbox.

00:04:32.067 --> 00:04:34.000
And we get all this,
it's all possible

00:04:34.000 --> 00:04:36.734
because we can divide
the application, the browser

00:04:36.734 --> 00:04:38.901
into multiple processes.

00:04:38.901 --> 00:04:40.834
Okay, but I mentioned before
speed.

00:04:40.834 --> 00:04:42.300
Speed is very important.

00:04:42.300 --> 00:04:44.667
And so in the early days
we were thinking

00:04:44.667 --> 00:04:46.968
it's one thing
to divide the browser

00:04:46.968 --> 00:04:48.434
into multiple processes,

00:04:48.434 --> 00:04:49.968
and that allows
the applications

00:04:49.968 --> 00:04:51.200
to not stomp on one another

00:04:51.200 --> 00:04:52.534
and to achieve
good performance there,

00:04:52.534 --> 00:04:54.100
good scaling
across multiple cores.

00:04:54.100 --> 00:04:56.100
But we just want
the rendering engine

00:04:56.100 --> 00:04:57.934
to be very fast as well.

00:04:57.934 --> 00:05:00.000
So that informed our choice
of rendering engine,

00:05:00.000 --> 00:05:03.467
and we went with WebKit
because it was, well--

00:05:03.467 --> 00:05:04.734
We really wanted to--

00:05:04.734 --> 00:05:06.467
We knew that Chrome
was going to be open source,

00:05:06.467 --> 00:05:08.267
and we chose upon--

00:05:08.267 --> 00:05:10.834
took a look at all
the open source options

00:05:10.834 --> 00:05:12.901
and WebKit was just
really fast,

00:05:12.901 --> 00:05:14.567
and it has
a very small footprint.

00:05:14.567 --> 00:05:16.400
Back in '06,
you could see that WebKit

00:05:16.400 --> 00:05:18.033
was starting to become
the popular choice

00:05:18.033 --> 00:05:19.634
amongst mobile browsers.

00:05:19.634 --> 00:05:21.100
And this all had to do
with, you know,

00:05:21.100 --> 00:05:22.367
just how good WebKit is.

00:05:22.367 --> 00:05:23.834
But there was one thing
that we saw

00:05:23.834 --> 00:05:25.033
as a big opportunity,

00:05:25.033 --> 00:05:26.834
and that was
JavaScript performance.

00:05:26.834 --> 00:05:29.000
Back in '06, the JavaScript
engine in WebKit

00:05:29.000 --> 00:05:32.167
was a very straightforward,
simple interpreted

00:05:32.167 --> 00:05:33.801
JavaScript engine.

00:05:33.801 --> 00:05:37.133
And we had a team at Google
who recognized

00:05:37.133 --> 00:05:38.634
that there was
this great opportunity

00:05:38.634 --> 00:05:40.234
to apply some of
the more modern approaches

00:05:40.234 --> 00:05:44.000
to BM technology, BMs,
to build a JavaScript engine

00:05:44.000 --> 00:05:45.968
that was GIT-based

00:05:45.968 --> 00:05:48.534
and leveraged a lot
of other techniques

00:05:48.534 --> 00:05:50.467
to make
dynamic programs like--

00:05:50.467 --> 00:05:52.534
Dynamic programming languages,
like JavaScript,

00:05:52.534 --> 00:05:54.367
run so much faster.

00:05:54.367 --> 00:05:57.367
And the V8 team was very
successful, in my opinion.

00:05:57.367 --> 00:05:58.934
I mean, compared to where
we were in '06,

00:05:58.934 --> 00:06:00.601
they've come
order of magnitude,

00:06:00.601 --> 00:06:02.467
or one or two
orders of magnitude

00:06:02.467 --> 00:06:05.367
depending on what kinds of tests
you're talking about.

00:06:05.367 --> 00:06:08.467
And that's just outstanding.

00:06:08.467 --> 00:06:12.200
Don't you just love
silent auto-update?

00:06:12.200 --> 00:06:15.467
I do.

00:06:15.467 --> 00:06:19.100
Okay, so under the hood.

00:06:19.100 --> 00:06:21.534
The major components
of Chrome.

00:06:21.534 --> 00:06:25.067
So this is sort of--

00:06:25.067 --> 00:06:28.334
gives you a big picture
of some of the major modules.

00:06:28.334 --> 00:06:30.167
And Chromium
is the source base

00:06:30.167 --> 00:06:32.067
from which Chrome is derived,

00:06:32.067 --> 00:06:33.767
Chrome being the application.

00:06:33.767 --> 00:06:36.067
And Chromium depends
on WebKit.

00:06:36.067 --> 00:06:38.734
I've mentioned
WebKit already and V8.

00:06:38.734 --> 00:06:40.534
And Skia,
Skia's our graphics engine.

00:06:40.534 --> 00:06:42.167
This actually comes
from the android project.

00:06:42.167 --> 00:06:43.701
It's a 2-D graphics engine

00:06:43.701 --> 00:06:45.801
that's highly optimized
for mobile environments.

00:06:45.801 --> 00:06:49.367
And so it really runs well
on a desktop system.

00:06:49.367 --> 00:06:52.300
And so
in the Chromium world,

00:06:52.300 --> 00:06:54.334
how these
are all glued together,

00:06:54.334 --> 00:06:55.601
Chromium embeds WebKit.

00:06:55.601 --> 00:06:57.367
WebKit renders to Skia.

00:06:57.367 --> 00:07:00.133
Chromium also renders
its own UI to Skia.

00:07:00.133 --> 00:07:03.667
And WebKit talks to V8
to run JavaScript.

00:07:03.667 --> 00:07:05.434
But Chromium also talks
directly to V8

00:07:05.434 --> 00:07:07.334
for things
like proxy auto-config

00:07:07.334 --> 00:07:09.667
and other usages
of JavaScript in a browser

00:07:09.667 --> 00:07:12.667
besides just that
related to web content.

00:07:12.667 --> 00:07:14.534
So Chromium itself,
the code base,

00:07:14.534 --> 00:07:16.367
includes all the other stuff
that's not WebKit

00:07:16.367 --> 00:07:18.067
that's not V8, not Skia,

00:07:18.067 --> 00:07:20.067
and other libraries
that we incorporate.

00:07:20.067 --> 00:07:23.067
But it includes
things like the UI,

00:07:23.067 --> 00:07:24.434
the tab strip,
and the Omnibox--

00:07:24.434 --> 00:07:26.834
these are all
native UI elements.

00:07:26.834 --> 00:07:29.701
We chose to go
with a native UI for Chrome

00:07:29.701 --> 00:07:31.467
because we really wanted
to make sure

00:07:31.467 --> 00:07:35.267
that we could get all of
the look and feel just right.

00:07:35.267 --> 00:07:37.734
We wanted to have a very
lightweight, fast browser.

00:07:37.734 --> 00:07:40.334
We wanted to have a browser
that was highly tuned

00:07:40.334 --> 00:07:42.200
for Windows
and then again for Mac

00:07:42.200 --> 00:07:44.067
and then again for Linux.

00:07:44.067 --> 00:07:47.334
And so for Windows,
we went about--

00:07:47.334 --> 00:07:49.200
we went about building
this native tab strip,

00:07:49.200 --> 00:07:50.534
this native Omnibox.

00:07:50.534 --> 00:07:54.434
And, however, not all
of our UI is native.

00:07:54.434 --> 00:07:56.367
The new tab page,
the downloads page,

00:07:56.367 --> 00:07:58.067
the history panel,

00:07:58.067 --> 00:08:00.634
these appear
in the tab contents area.

00:08:00.634 --> 00:08:04.267
And so they are naturally
HTML-based

00:08:04.267 --> 00:08:06.167
so that you get
the same look and feel

00:08:06.167 --> 00:08:07.734
that you would
for a web app.

00:08:07.734 --> 00:08:10.767
And this turned out
to work very well for us.

00:08:10.767 --> 00:08:12.868
So basically,
the amount of native code

00:08:12.868 --> 00:08:14.601
is minimized to just that

00:08:14.601 --> 00:08:17.467
of the frame
or the window manager.

00:08:17.467 --> 00:08:19.067
So that's pretty much
all I'm gonna talk about

00:08:19.067 --> 00:08:21.200
as far as UI is concerned.

00:08:21.200 --> 00:08:23.100
The other main components
in Chromium though

00:08:23.100 --> 00:08:24.634
are multi-process
architecture.

00:08:24.634 --> 00:08:27.634
That's sort of the thing that--
the goop that binds

00:08:27.634 --> 00:08:31.000
this whole collection
of processes together.

00:08:31.000 --> 00:08:33.667
And they history system
is fairly complicated,

00:08:33.667 --> 00:08:35.033
based around Sequel Light,

00:08:35.033 --> 00:08:37.300
and there's
a full text index there.

00:08:37.300 --> 00:08:39.734
The network stack
runs in the main process.

00:08:39.734 --> 00:08:42.434
I'll actually talk more
about processes in detail later.

00:08:42.434 --> 00:08:45.701
And then there's a sandbox
piece of module

00:08:45.701 --> 00:08:48.033
within
the Chromium source base.

00:08:48.033 --> 00:08:49.868
So moving on.

00:08:49.868 --> 00:08:52.000
Multi-process architecture.

00:08:52.000 --> 00:08:53.767
Just getting into this
a little bit more.

00:08:53.767 --> 00:08:55.367
So I've been talking
about processes.

00:08:55.367 --> 00:08:56.868
So this is what I mean.

00:08:56.868 --> 00:08:58.100
This picture here shows

00:08:58.100 --> 00:09:00.167
that this main coordinating
browser process

00:09:00.167 --> 00:09:03.434
that all of the child processes
talk to.

00:09:03.434 --> 00:09:06.334
And we have a sequence--
a set of different renderers.

00:09:06.334 --> 00:09:08.100
Each of the rendering processes

00:09:08.100 --> 00:09:09.701
are the processes
that embed WebKit

00:09:09.701 --> 00:09:11.634
to render web pages,

00:09:11.634 --> 00:09:12.901
and they talk back
to the browser

00:09:12.901 --> 00:09:14.567
for things like IO.

00:09:14.567 --> 00:09:15.801
So because of the sandbox,

00:09:15.801 --> 00:09:17.467
the renderers
actually don't have access

00:09:17.467 --> 00:09:19.367
to direct--direct access
to the system,

00:09:19.367 --> 00:09:21.033
and they must proxy through
the browser for everything.

00:09:21.033 --> 00:09:23.334
So this is sort of
a hub and spoke design.

00:09:23.334 --> 00:09:25.100
I've shown some other
processes here--

00:09:25.100 --> 00:09:27.801
worker processes,
plug-in processes.

00:09:27.801 --> 00:09:31.634
So worker processes are
the new web workers coming of--

00:09:31.634 --> 00:09:34.534
that you start to see
various browsers implementing.

00:09:34.534 --> 00:09:38.200
These allow for a web page
to have a background thread

00:09:38.200 --> 00:09:40.534
or a background set of threads
that do work.

00:09:40.534 --> 00:09:43.334
And there's
a very asynchronous way

00:09:43.334 --> 00:09:45.067
of communicating to those
background threads,

00:09:45.067 --> 00:09:47.067
which lends itself
very naturally

00:09:47.067 --> 00:09:51.267
to having those workers
be out of process.

00:09:51.267 --> 00:09:53.267
And there can be
many of them.

00:09:53.267 --> 00:09:55.634
Plug-ins--Plug-ins actually
run outside the sandbox

00:09:55.634 --> 00:09:57.200
in their own process.

00:09:57.200 --> 00:09:59.400
So when I say plug-ins here,
I don't mean, like,

00:09:59.400 --> 00:10:01.200
Firefox extensions
or things like that.

00:10:01.200 --> 00:10:02.634
I mean the traditional
browser plug-ins

00:10:02.634 --> 00:10:05.234
like Flash, Java,
Silverlight, and so on

00:10:05.234 --> 00:10:07.701
that use things like NPAPI
or ActiveX.

00:10:07.701 --> 00:10:10.734
And so for these--
for each of these plug-ins,

00:10:10.734 --> 00:10:12.901
we load them
in their own process,

00:10:12.901 --> 00:10:17.467
so there's a Flash process
and a Java process and so on.

00:10:17.467 --> 00:10:19.133
Now I've made
some mention here

00:10:19.133 --> 00:10:20.801
of trust, untrusted,
and so on.

00:10:20.801 --> 00:10:23.067
So it's important to note

00:10:23.067 --> 00:10:27.033
that we really would like
to have sandboxed plug-ins.

00:10:27.033 --> 00:10:28.834
We would liked to have
included them in the sandbox,

00:10:28.834 --> 00:10:32.434
but because they are
basically already software

00:10:32.434 --> 00:10:35.334
that's on the system,
they have dependencies

00:10:35.334 --> 00:10:37.801
on being able to actually
access the system directly.

00:10:37.801 --> 00:10:40.067
They just can't be
included in the sandbox.

00:10:40.067 --> 00:10:41.901
A good example is Flash.

00:10:41.901 --> 00:10:44.000
It actually needs to be able
to auto-update itself.

00:10:44.000 --> 00:10:46.567
Well, if we denied its ability
to access your system,

00:10:46.567 --> 00:10:49.501
it wouldn't be able
to update itself.

00:10:49.501 --> 00:10:52.000
So it has to run
outside of the sandbox.

00:10:52.000 --> 00:10:53.901
But it still runs
in its own process

00:10:53.901 --> 00:10:56.067
so that we get some insulation
from, you know,

00:10:56.067 --> 00:11:01.534
page faults and so on.

00:11:01.534 --> 00:11:03.200
So inter-process
communication,

00:11:03.200 --> 00:11:06.200
just a few words
about that.

00:11:06.200 --> 00:11:08.934
We decided early on
that we really--

00:11:08.934 --> 00:11:10.634
You know, there were
many applications

00:11:10.634 --> 00:11:14.567
that you could point to that
were multi-process already,

00:11:14.567 --> 00:11:16.601
on your Windows desktop
or wherever.

00:11:16.601 --> 00:11:19.567
And a lot of times,
performance can--

00:11:19.567 --> 00:11:21.400
It's very easy to build
a multi-process application

00:11:21.400 --> 00:11:23.067
that doesn't perform well.

00:11:23.067 --> 00:11:24.901
And one of the key things
we really went for

00:11:24.901 --> 00:11:26.534
was this so-called
a permanent model,

00:11:26.534 --> 00:11:28.868
where we want to make sure
that individual processes

00:11:28.868 --> 00:11:30.133
or really individual threads

00:11:30.133 --> 00:11:31.767
really can run
as independently as possible

00:11:31.767 --> 00:11:35.400
and rely on more of
an asynchronous communication,

00:11:35.400 --> 00:11:36.934
locking between
the processes,

00:11:36.934 --> 00:11:40.033
locking between the threads
as minimally as possible.

00:11:40.033 --> 00:11:42.667
So we went for an asynchronous
communication system.

00:11:42.667 --> 00:11:46.667
Early on, we tried using
existing systems on Windows,

00:11:46.667 --> 00:11:48.501
like Windows messages that--

00:11:48.501 --> 00:11:50.601
You can so asynchronous
Windows messages.

00:11:50.601 --> 00:11:52.501
We looked at using comm.

00:11:52.501 --> 00:11:54.934
All these systems
were fairly complicated,

00:11:54.934 --> 00:11:56.901
and in order to achieve--

00:11:56.901 --> 00:11:58.834
In order to get the kind
of control we wanted

00:11:58.834 --> 00:12:00.601
over the IPC,
we went with named pipes.

00:12:00.601 --> 00:12:02.667
Plus named pipes
are much more portable.

00:12:02.667 --> 00:12:05.100
And we knew we would
eventually be bringing this

00:12:05.100 --> 00:12:06.567
to Mac and Linux,
and so it made sense

00:12:06.567 --> 00:12:08.300
to go with named pipes.

00:12:08.300 --> 00:12:10.234
We do have some support
for limited blocking calls,

00:12:10.234 --> 00:12:12.734
because that's required
for some of the--

00:12:12.734 --> 00:12:14.467
to support some of
the web interfaces

00:12:14.467 --> 00:12:16.334
that we need to support.

00:12:16.334 --> 00:12:18.501
And I can talk
about that more later.

00:12:18.501 --> 00:12:20.000
There's some use
of shared memory,

00:12:20.000 --> 00:12:21.868
but we basically
don't use shared memory

00:12:21.868 --> 00:12:23.534
unless it really
gives a big benefit,

00:12:23.534 --> 00:12:26.701
because it just adds
complexity to the system.

00:12:26.701 --> 00:12:29.000
So basically you can imagine,
if you will,

00:12:29.000 --> 00:12:31.267
these different processes

00:12:31.267 --> 00:12:34.868
that are basically having
a stream of events

00:12:34.868 --> 00:12:37.701
asynchronously flowing
to one process or the other.

00:12:37.701 --> 00:12:42.567
And it's sort of like
a big interconnected network

00:12:42.567 --> 00:12:45.667
of data being passed around.

00:12:45.667 --> 00:12:47.100
And we're trying
to keep this thing

00:12:47.100 --> 00:12:49.434
running as smoothly as possible
and avoiding hiccups.

00:12:49.434 --> 00:12:51.834
That's basically the goal

00:12:51.834 --> 00:12:54.067
of the inter-process
communication.

00:12:54.067 --> 00:12:55.934
This diagram here just shows

00:12:55.934 --> 00:12:57.734
that in order to keep things
running smoothly,

00:12:57.734 --> 00:12:59.567
we dedicate a thread
in each process

00:12:59.567 --> 00:13:01.801
to run and service the IPC.

00:13:01.801 --> 00:13:05.567
That way, if the UI thread,
T(UI), in the browser,

00:13:05.567 --> 00:13:09.067
were to go off
and produce a whole bunch

00:13:09.067 --> 00:13:11.067
of IPCs that he wants
to send to the renderer

00:13:11.067 --> 00:13:14.300
but then not yield control
to the system

00:13:14.300 --> 00:13:16.167
that actually sends
the IPCs,

00:13:16.167 --> 00:13:17.667
that could be bad.

00:13:17.667 --> 00:13:19.133
So instead,
there's a background thread

00:13:19.133 --> 00:13:20.801
who picks up that queue
of outbound requests

00:13:20.801 --> 00:13:22.167
and sends them along.

00:13:22.167 --> 00:13:23.667
Meanwhile, the browser's
doing other things,

00:13:23.667 --> 00:13:26.234
possibly expensive things,
but the IPC is flowing.

00:13:26.234 --> 00:13:27.734
And then the renderer,
the same deal.

00:13:27.734 --> 00:13:31.868
JavaScript application could be
consuming T(WebKit),

00:13:31.868 --> 00:13:33.634
but we still have
an IO thread

00:13:33.634 --> 00:13:35.100
that's pumping events
and doing things

00:13:35.100 --> 00:13:36.701
and keeping things
running smoothly.

00:13:36.701 --> 00:13:39.100
That's just sort of
a bird's-eye view

00:13:39.100 --> 00:13:42.234
of what the inter-process
communication looks like.

00:13:42.234 --> 00:13:46.133
Process assignments.

00:13:46.133 --> 00:13:48.367
What do I mean by this?

00:13:48.367 --> 00:13:51.467
Given that Chrome
has many rendering processes

00:13:51.467 --> 00:13:53.834
and we really would love,
ideally,

00:13:53.834 --> 00:13:55.901
to be able to assign
a single web application

00:13:55.901 --> 00:13:58.033
to a single process,
thereby giving

00:13:58.033 --> 00:14:00.467
the best separation
between web applications.

00:14:00.467 --> 00:14:02.200
There's some realities
to the web

00:14:02.200 --> 00:14:07.200
that force us to group
some applications or some--

00:14:07.200 --> 00:14:08.767
What do I mean by applications?
Web pages.

00:14:08.767 --> 00:14:13.033
Some web pages have to be
grouped together in processes.

00:14:13.033 --> 00:14:15.100
And then there's
opportunities to decide

00:14:15.100 --> 00:14:17.801
when we should actually
create a new process.

00:14:17.801 --> 00:14:19.367
And coming up with
a good formula here

00:14:19.367 --> 00:14:20.734
is a little tricky,

00:14:20.734 --> 00:14:22.634
'cause there's
some realistic limitations.

00:14:22.634 --> 00:14:24.601
Like we don't want to have
too many processes.

00:14:24.601 --> 00:14:26.400
At some point,
you start to pay a cost

00:14:26.400 --> 00:14:28.234
by having many processes.

00:14:28.234 --> 00:14:29.701
So we have a process limit.

00:14:29.701 --> 00:14:32.267
If that limit's reached,
we'll start reusing processes.

00:14:32.267 --> 00:14:34.300
If there's a potential
script connection

00:14:34.300 --> 00:14:35.567
between two web pages,

00:14:35.567 --> 00:14:37.300
well, they need to be
in the same process.

00:14:37.300 --> 00:14:39.601
We could have built
the system

00:14:39.601 --> 00:14:44.033
so that there was
a complex way of--

00:14:44.033 --> 00:14:46.200
a bridge or so
between the script

00:14:46.200 --> 00:14:48.167
running in one page
and the script in another page,

00:14:48.167 --> 00:14:49.801
but that seemed like it would
be overly complicated

00:14:49.801 --> 00:14:52.100
and potentially lead to a lot
of performance problems.

00:14:52.100 --> 00:14:54.667
So instead we thought,
well, a web application--

00:14:54.667 --> 00:14:56.534
Well, if we think
of a web application

00:14:56.534 --> 00:14:58.801
that might have many pages

00:14:58.801 --> 00:15:01.067
as probably sharing
script connections,

00:15:01.067 --> 00:15:03.801
then it kind of makes sense
for those many pages

00:15:03.801 --> 00:15:05.467
to all be grouped
in the same process.

00:15:05.467 --> 00:15:09.434
And so this idea of just
looking at any page

00:15:09.434 --> 00:15:13.868
that's open from WebKit
as potentially being a page

00:15:13.868 --> 00:15:16.367
that should be
in the same process,

00:15:16.367 --> 00:15:17.767
that seemed to make sense.

00:15:17.767 --> 00:15:20.801
And it works out pretty well
for a lot of applications.

00:15:20.801 --> 00:15:22.467
You'd think,
interestingly enough,

00:15:22.467 --> 00:15:24.067
Target blank--
I put this up here

00:15:24.067 --> 00:15:26.467
'cause you'd think that when
a user clicks on target blank,

00:15:26.467 --> 00:15:28.167
and that means
open a new window,

00:15:28.167 --> 00:15:29.834
that there should be
no script connection

00:15:29.834 --> 00:15:32.801
between that and the page
that you opened

00:15:32.801 --> 00:15:34.234
that the link was clicked on.

00:15:34.234 --> 00:15:35.467
Well, it turns out

00:15:35.467 --> 00:15:37.601
that there is
a very real script connection.

00:15:37.601 --> 00:15:39.467
When that new page
is opened,

00:15:39.467 --> 00:15:42.200
it's actually got
a dot opener property,

00:15:42.200 --> 00:15:44.701
and the dot opener property
allows it to see the guy--

00:15:44.701 --> 00:15:48.601
the page from which
he was opened.

00:15:48.601 --> 00:15:51.701
Now that's okay.

00:15:51.701 --> 00:15:53.467
So okay, well,
then in that case,

00:15:53.467 --> 00:15:55.200
if it's the same origin,
you know,

00:15:55.200 --> 00:15:57.367
'cause JavaScript allows
scripting

00:15:57.367 --> 00:16:00.100
provided origin A
and origin B are the same,

00:16:00.100 --> 00:16:02.734
then they--
they then, you know--

00:16:02.734 --> 00:16:06.267
Okay, we would only group them
in the same process if--

00:16:06.267 --> 00:16:10.067
if the new page
is of the same origin.

00:16:10.067 --> 00:16:11.834
And that's actually
not good enough,

00:16:11.834 --> 00:16:14.567
because it might be that
you are clicking a link from--

00:16:14.567 --> 00:16:17.868
opening a new window
from origin A to origin B,

00:16:17.868 --> 00:16:20.200
but origin B
might have a sub frame

00:16:20.200 --> 00:16:21.901
that's also on origin A.

00:16:21.901 --> 00:16:23.634
And origin--
the page over here

00:16:23.634 --> 00:16:26.100
can actually find
that frame by name.

00:16:26.100 --> 00:16:29.367
And so sort of after the fact,
after a window's created,

00:16:29.367 --> 00:16:30.734
there might be
a script connection

00:16:30.734 --> 00:16:32.133
that become established.

00:16:32.133 --> 00:16:34.000
So we need to keep those
in the same process.

00:16:34.000 --> 00:16:36.534
Okay, but then there's
some heuristics

00:16:36.534 --> 00:16:40.400
to try to get out of
these sort of situations.

00:16:40.400 --> 00:16:42.501
Turns out that a lot
of web applications

00:16:42.501 --> 00:16:46.767
use window.open
to navigate

00:16:46.767 --> 00:16:50.701
from the application
to a new page.

00:16:50.701 --> 00:16:52.601
For example, Gmail,
when you click a link,

00:16:52.601 --> 00:16:56.067
it wants to take you
to a new page for that link.

00:16:56.067 --> 00:16:58.968
And the thing though
is that Gmail

00:16:58.968 --> 00:17:01.334
really has no interest in there
being a script connection

00:17:01.334 --> 00:17:04.200
between Gmail
and that new page.

00:17:04.200 --> 00:17:08.100
It even goes so far
to set the opener property

00:17:08.100 --> 00:17:10.067
of that new page
to null

00:17:10.067 --> 00:17:12.601
before navigating
that new page

00:17:12.601 --> 00:17:14.234
to the URL
that you clicked on.

00:17:14.234 --> 00:17:15.901
Those kinds
of tricks are done

00:17:15.901 --> 00:17:17.501
to sort of sever
the script connection,

00:17:17.501 --> 00:17:20.534
at least as far as
that rendering process

00:17:20.534 --> 00:17:21.934
would be concerned.

00:17:21.934 --> 00:17:24.400
Well, we sort of use that
as a clue, as a heuristic

00:17:24.400 --> 00:17:26.534
to determine that--
Oh, I see.

00:17:26.534 --> 00:17:28.868
There's no script connection
because it's been removed.

00:17:28.868 --> 00:17:31.734
We can just fork that off
into another process.

00:17:31.734 --> 00:17:34.133
And so that's the kind
of heuristic that we've applied

00:17:34.133 --> 00:17:36.901
to get sort of a good
distribution of processes

00:17:36.901 --> 00:17:40.300
when, say, Gmail is the source
of all your new tabs,

00:17:40.300 --> 00:17:42.334
because you're
clicking links there,

00:17:42.334 --> 00:17:44.434
or other applications
like Gmail.

00:17:44.434 --> 00:17:47.400
All right, another topic
about process assignments.

00:17:47.400 --> 00:17:51.667
When you are just typing
a URL in the location bar,

00:17:51.667 --> 00:17:55.267
you're saying,
"Replace the current tab

00:17:55.267 --> 00:17:57.901
with new contents
from this new location."

00:17:57.901 --> 00:18:00.601
And we recognize
that if what you're typing

00:18:00.601 --> 00:18:04.033
is a URL with a new domain,

00:18:04.033 --> 00:18:07.701
effectively it's
an opportunity for us to say,

00:18:07.701 --> 00:18:11.434
"It's like closing the tab
and opening a new tab."

00:18:11.434 --> 00:18:14.901
And so what you achieve there
is an opportunity

00:18:14.901 --> 00:18:17.567
to switch processes
out from under the system

00:18:17.567 --> 00:18:19.200
without the user
really being aware

00:18:19.200 --> 00:18:20.567
that there was
a process switch.

00:18:20.567 --> 00:18:22.267
And this becomes a really
natural and nice point

00:18:22.267 --> 00:18:24.968
for garbage collection.

00:18:24.968 --> 00:18:27.067
So frequently in Chrome,

00:18:27.067 --> 00:18:28.734
you're just typing
in the location bar,

00:18:28.734 --> 00:18:31.501
you go to a--
enter a new URL up there,

00:18:31.501 --> 00:18:33.434
and unbeknownst to you,

00:18:33.434 --> 00:18:37.767
we're actually swapping
processes underneath.

00:18:37.767 --> 00:18:40.267
Oh, yes,
process per domain.

00:18:40.267 --> 00:18:42.167
So some people
might have heard

00:18:42.167 --> 00:18:45.133
about the research project,
the Gisele browser,

00:18:45.133 --> 00:18:48.400
which basically
implemented this idea

00:18:48.400 --> 00:18:51.033
of actually having a separate
rendering process per domain,

00:18:51.033 --> 00:18:53.234
rather than a separate
rendering process per tab.

00:18:53.234 --> 00:18:56.534
This was something that
we looked at very hard as well,

00:18:56.534 --> 00:18:58.534
because it seems
very attractive.

00:18:58.534 --> 00:19:00.968
And our conclusions
were very similar to theirs--

00:19:00.968 --> 00:19:02.634
that you suffer some--

00:19:02.634 --> 00:19:05.133
It turns out, you suffer
some web compatibility hit

00:19:05.133 --> 00:19:07.200
for trying to make
this kind of change.

00:19:07.200 --> 00:19:09.033
But it still seems
so attractive.

00:19:09.033 --> 00:19:10.801
Wouldn't it be nice
if you could have

00:19:10.801 --> 00:19:13.367
one rendering engine
dedicated for one domain?

00:19:13.367 --> 00:19:14.767
And then you could
start to apply

00:19:14.767 --> 00:19:17.667
some of these
multi-process benefits

00:19:17.667 --> 00:19:19.501
to actual domains.

00:19:19.501 --> 00:19:23.100
You could say, "All the data
associated to Food.com

00:19:23.100 --> 00:19:26.000
would only be available
to that rendering process."

00:19:26.000 --> 00:19:28.801
And you wouldn't be able
to ever see data for Bar.com.

00:19:28.801 --> 00:19:31.234
That's sort of the holy grail
of multi-process architecture.

00:19:31.234 --> 00:19:33.567
But there's some real
web compat challenges

00:19:33.567 --> 00:19:36.334
that we face with that.

00:19:36.334 --> 00:19:38.501
For example,
third-party cookies

00:19:38.501 --> 00:19:39.734
are a big problem.

00:19:39.734 --> 00:19:44.868
It turns out the web page
can dabble with cookies

00:19:44.868 --> 00:19:50.601
that are not its own.

00:19:50.601 --> 00:19:51.934
All right, so sandbox.

00:19:51.934 --> 00:19:53.834
So I've been talking
about the sandbox,

00:19:53.834 --> 00:19:56.901
but here's a little more
detail about it.

00:19:56.901 --> 00:19:58.534
Primary goal of the sandbox

00:19:58.534 --> 00:20:02.234
was really all about protecting
the user against malware.

00:20:02.234 --> 00:20:04.567
There's so many things
that you might wish to sandbox.

00:20:04.567 --> 00:20:06.300
Like you might wish to,
as I was just saying,

00:20:06.300 --> 00:20:10.033
you might wish to protect
one origin from another origin--

00:20:10.033 --> 00:20:11.667
Food.com from Bar.com.

00:20:11.667 --> 00:20:14.968
But that wasn't something
we strove to achieve initially.

00:20:14.968 --> 00:20:16.534
The first goal of the sandbox

00:20:16.534 --> 00:20:19.200
was really just
as a catchall

00:20:19.200 --> 00:20:22.033
to protect the user
against malware.

00:20:22.033 --> 00:20:23.734
If somehow there was a bug

00:20:23.734 --> 00:20:25.868
exploited
in the renderering engine,

00:20:25.868 --> 00:20:28.267
it should not turn itself
into a vehicle

00:20:28.267 --> 00:20:31.100
to allow people
to distribute malware.

00:20:31.100 --> 00:20:32.634
So Chrome
has several features,

00:20:32.634 --> 00:20:34.200
several anti-malware features.

00:20:34.200 --> 00:20:35.801
It has the sandbox,
of course,

00:20:35.801 --> 00:20:38.100
but it also has
the safe browsing feature,

00:20:38.100 --> 00:20:41.100
much like what you find
in other browsers,

00:20:41.100 --> 00:20:43.901
where once you venture
onto a URL or a page

00:20:43.901 --> 00:20:47.801
that contains content
known to be bad,

00:20:47.801 --> 00:20:49.767
we'll show an interstitial,
an error,

00:20:49.767 --> 00:20:51.667
allowing the user
to go through or not.

00:20:51.667 --> 00:20:53.601
That's sort of a first cut.

00:20:53.601 --> 00:20:55.234
You know, obviously
if we don't know--

00:20:55.234 --> 00:20:57.067
If the service
that you're using

00:20:57.067 --> 00:20:59.100
to supply that data
doesn't know about the bad URL,

00:20:59.100 --> 00:21:00.434
it's not gonna work.

00:21:00.434 --> 00:21:02.634
So you need some kind
of extra protection.

00:21:02.634 --> 00:21:05.067
It was very interesting--
a very interesting story.

00:21:05.067 --> 00:21:07.033
One of our engineers
was tracking down a crash

00:21:07.033 --> 00:21:08.934
that he saw in Chrome
in the renderer,

00:21:08.934 --> 00:21:12.067
and he was like,
"Oh, it's hard to reproduce--"

00:21:12.067 --> 00:21:14.434
It's hard to debug
when he has the sandbox engaged.

00:21:14.434 --> 00:21:17.067
So he thought, "I'll just
take off the sandbox,

00:21:17.067 --> 00:21:19.868
"and then I'll load this page up
in my debugger,

00:21:19.868 --> 00:21:21.501
and go to town
trying to figure it out."

00:21:21.501 --> 00:21:23.634
Well, it turns out that
that was actually

00:21:23.634 --> 00:21:25.934
a site serving malware
that exploited his system

00:21:25.934 --> 00:21:28.667
and corrupted his XP.

00:21:28.667 --> 00:21:30.834
And he was like, "Oh, crap,
now I have to re-image,"

00:21:30.834 --> 00:21:32.767
just 'cause he was trying
to debug this problem.

00:21:32.767 --> 00:21:35.834
So sandbox
is a really nice tool.

00:21:35.834 --> 00:21:38.367
What are we trying
to restrict?

00:21:38.367 --> 00:21:40.567
Well, trying to restrict

00:21:40.567 --> 00:21:43.067
the processes' access
to the file system and network

00:21:43.067 --> 00:21:45.067
and other kinds of devices
on the system.

00:21:45.067 --> 00:21:46.968
We're also trying
to restrict his access

00:21:46.968 --> 00:21:48.434
to the windowing system.

00:21:48.434 --> 00:21:49.968
So he shouldn't be able to mess
around with your desktop,

00:21:49.968 --> 00:21:51.400
shouldn't be able
to mess around

00:21:51.400 --> 00:21:54.000
with any of the hardware,
your keyboard or your mouse

00:21:54.000 --> 00:21:55.567
and so on.

00:21:55.567 --> 00:21:57.167
The mechanisms
to achieve this--

00:21:57.167 --> 00:22:01.267
Well, as I said, every process
has some associated user,

00:22:01.267 --> 00:22:03.133
and the user has
a certain set of capabilities.

00:22:03.133 --> 00:22:06.000
Under Windows, this is
represented by a user token.

00:22:06.000 --> 00:22:08.534
And we can strip
all of the rights

00:22:08.534 --> 00:22:10.667
off of that user token,
thereby denying things

00:22:10.667 --> 00:22:13.734
like system access
and file system access.

00:22:13.734 --> 00:22:15.901
And there's other techniques
in Windows,

00:22:15.901 --> 00:22:17.567
including job objects
that can be used

00:22:17.567 --> 00:22:19.801
to further restrict
the capabilities of a process.

00:22:19.801 --> 00:22:21.868
And even just running it
on a separate virtual desktop,

00:22:21.868 --> 00:22:24.200
this is a great way
to sort of limit

00:22:24.200 --> 00:22:26.400
the processes' ability
to get access

00:22:26.400 --> 00:22:31.267
to some of the input devices.

00:22:31.267 --> 00:22:34.200
Okay, but sandbox
doesn't actually--

00:22:34.200 --> 00:22:36.534
A browser actually needs
to be able to load file URLs.

00:22:36.534 --> 00:22:38.200
So how do we achieve that
given that sandbox

00:22:38.200 --> 00:22:40.667
doesn't allow you
to access file URLs?

00:22:40.667 --> 00:22:42.601
Well, two big examples
of this

00:22:42.601 --> 00:22:44.534
are A,
loading file colon URLs,

00:22:44.534 --> 00:22:47.367
and the other one is actually
being able to upload a file

00:22:47.367 --> 00:22:49.934
that is specified
in a web form.

00:22:49.934 --> 00:22:53.100
So to deal with file uploads,
what we do

00:22:53.100 --> 00:22:58.367
is when the WebKit
wants to show a file picker,

00:22:58.367 --> 00:23:00.968
it actually just asks
the browser,

00:23:00.968 --> 00:23:02.501
"Please show a file picker."

00:23:02.501 --> 00:23:04.200
Or a rendering process
asks the browser,

00:23:04.200 --> 00:23:05.434
"Please show a file picker."

00:23:05.434 --> 00:23:06.534
The browser
shows a file picker.

00:23:06.534 --> 00:23:08.000
The user makes their selection.

00:23:08.000 --> 00:23:10.501
And then what we do
before we return that result

00:23:10.501 --> 00:23:12.767
to the rendering engine
is we put it on a whitelist

00:23:12.767 --> 00:23:14.200
associated
with that rendering engine.

00:23:14.200 --> 00:23:16.234
And now that rendering engine
is allowed to say

00:23:16.234 --> 00:23:18.100
that he wants
to upload that file.

00:23:18.100 --> 00:23:20.534
It's pretty simple.

00:23:20.534 --> 00:23:22.467
File colon URLs, well,
what is this?

00:23:22.467 --> 00:23:25.033
This is, you know,
the rendering engine

00:23:25.033 --> 00:23:26.767
being able to load
any file URL,

00:23:26.767 --> 00:23:30.167
because if you go to some
Food.HTML on your hard drive,

00:23:30.167 --> 00:23:33.434
it can load images from
anywhere else on the hard drive.

00:23:33.434 --> 00:23:35.968
To make that work,
what we do is we actually

00:23:35.968 --> 00:23:38.667
just dedicate a separate
process for file colon URLs.

00:23:38.667 --> 00:23:42.634
So we're never mixing
web content and file colon URLs

00:23:42.634 --> 00:23:45.267
in the same process.

00:23:45.267 --> 00:23:47.801
For example, if you go
into the location bar

00:23:47.801 --> 00:23:49.167
and you type file colon,

00:23:49.167 --> 00:23:51.067
and you're sitting
on a web page somewhere,

00:23:51.067 --> 00:23:53.167
what we'll actually do
is leverage that technique

00:23:53.167 --> 00:23:55.667
I mentioned before of swapping
the rendering engine out

00:23:55.667 --> 00:23:56.934
underneath the hood,

00:23:56.934 --> 00:23:58.300
so that really
what we're doing

00:23:58.300 --> 00:24:01.167
is loading it
in a fresh rendering engine

00:24:01.167 --> 00:24:05.868
that is now just dedicated
to local files.

00:24:05.868 --> 00:24:07.901
Okay, so what isn't protected?

00:24:07.901 --> 00:24:10.067
I talked a little bit before
about, like,

00:24:10.067 --> 00:24:11.901
we're not separating origins.

00:24:11.901 --> 00:24:14.234
So what that means
is that cookies--

00:24:14.234 --> 00:24:15.634
A rendering engine can read

00:24:15.634 --> 00:24:17.133
all of your cookies
from anywhere.

00:24:17.133 --> 00:24:19.634
So if somehow there was
a bug in the rendering engine,

00:24:19.634 --> 00:24:21.334
that guy could then
go and ask for cookies

00:24:21.334 --> 00:24:22.801
from any domain.

00:24:22.801 --> 00:24:26.100
And this is just--this is
something we have to support

00:24:26.100 --> 00:24:27.801
because of document.cookie.

00:24:27.801 --> 00:24:29.968
There's a JavaScript API
to allow the web page

00:24:29.968 --> 00:24:31.734
to read your cookies.

00:24:31.734 --> 00:24:34.467
The one exception here
is the HTTP-only cookies.

00:24:34.467 --> 00:24:37.234
We actually don't have to allow
the renderer to see those.

00:24:37.234 --> 00:24:39.000
He can make HTTP requests,

00:24:39.000 --> 00:24:40.667
and then the network stack
running in the browser

00:24:40.667 --> 00:24:44.400
will add those
HTTP-only cookies.

00:24:44.400 --> 00:24:45.601
Passwords.

00:24:45.601 --> 00:24:46.934
Passwords,
much like cookies,

00:24:46.934 --> 00:24:48.868
it turns out that the web page
can read the passwords.

00:24:48.868 --> 00:24:50.801
So if you have an input type,
people's password,

00:24:50.801 --> 00:24:53.234
and the user enters
a value there,

00:24:53.234 --> 00:24:54.834
it's actually supported
by the web

00:24:54.834 --> 00:24:56.334
that the web page
should be able

00:24:56.334 --> 00:24:58.300
to actually read that value out
and do something with it.

00:24:58.300 --> 00:25:00.000
It's just the way

00:25:00.000 --> 00:25:01.567
the input type,
people's password,

00:25:01.567 --> 00:25:04.067
it's just a mechanism
for having some sort of secret

00:25:04.067 --> 00:25:05.901
that's entered into
the web page.

00:25:05.901 --> 00:25:08.100
And so this generic mechanism
allows web pages

00:25:08.100 --> 00:25:11.801
to do things like
do client-side authentication.

00:25:11.801 --> 00:25:13.767
So it's not
necessarily the case

00:25:13.767 --> 00:25:16.767
that this password field
corresponds to data

00:25:16.767 --> 00:25:18.701
that will be in a forum post.

00:25:18.701 --> 00:25:20.100
The reason why
that's interesting,

00:25:20.100 --> 00:25:21.434
'cause you might
imagine a system

00:25:21.434 --> 00:25:24.300
where the browser returns
a dummy password

00:25:24.300 --> 00:25:25.801
to the web page.

00:25:25.801 --> 00:25:27.400
And then
when the dummy password

00:25:27.400 --> 00:25:28.901
appears in the form post,

00:25:28.901 --> 00:25:31.000
the browser transparently
replaces it

00:25:31.000 --> 00:25:32.667
with the real password.

00:25:32.667 --> 00:25:35.200
That's a very clever way
to avoid exposing

00:25:35.200 --> 00:25:36.767
the real password
to the web page.

00:25:36.767 --> 00:25:38.234
But again,
because the web page

00:25:38.234 --> 00:25:40.067
has the power
to read that value

00:25:40.067 --> 00:25:42.234
and so some computation on it,

00:25:42.234 --> 00:25:44.267
it's--there's a potential--

00:25:44.267 --> 00:25:46.767
there's a huge web
compatibility problem there.

00:25:46.767 --> 00:25:48.968
So we end up
exposing the passwords

00:25:48.968 --> 00:25:51.167
to the rendering engine.

00:25:51.167 --> 00:25:52.968
Other things like
HTML 5 database,

00:25:52.968 --> 00:25:54.567
local store, session store,
they're much like cookies--

00:25:54.567 --> 00:25:55.667
same kind of deal.

00:25:55.667 --> 00:25:56.934
They're origin-based,

00:25:56.934 --> 00:25:58.400
and the renderer
gets access to them.

00:25:58.400 --> 00:26:00.434
Cross-site attacks,
user data in the cloud,

00:26:00.434 --> 00:26:02.100
that kind of stuff
is not what the sandbox

00:26:02.100 --> 00:26:03.734
is trying to protect against.

00:26:03.734 --> 00:26:05.367
You could imagine
a better sandbox

00:26:05.367 --> 00:26:09.400
that did do that kind
of stuff.

00:26:09.400 --> 00:26:11.968
Okay, so moving on
to rendering in a sandbox.

00:26:11.968 --> 00:26:13.968
So given that we have, like,
almost no access to the system,

00:26:13.968 --> 00:26:15.767
how do we render?

00:26:15.767 --> 00:26:17.501
Normally,
a web rendering engine

00:26:17.501 --> 00:26:19.367
is designed to render
to a native widget,

00:26:19.367 --> 00:26:21.667
like an hWnd
or an NSView

00:26:21.667 --> 00:26:24.133
or an X Window.

00:26:24.133 --> 00:26:25.901
And that kind of thing
doesn't work

00:26:25.901 --> 00:26:28.067
in a sandbox renderer
because we literally

00:26:28.067 --> 00:26:29.934
are trying to deny
access to hWnds.

00:26:29.934 --> 00:26:31.734
HWnds are in
the Windows desktop.

00:26:31.734 --> 00:26:33.200
We're trying to deny that.

00:26:33.200 --> 00:26:35.334
So instead, very simply,
render to a bitmap.

00:26:35.334 --> 00:26:37.267
Send the bitmap
to the browser process.

00:26:37.267 --> 00:26:39.501
The browser puts that bitmap
on the screen.

00:26:39.501 --> 00:26:42.734
So it's like
a glorified image viewer.

00:26:42.734 --> 00:26:44.133
Complexities.

00:26:44.133 --> 00:26:47.200
Well, the rendering engine

00:26:47.200 --> 00:26:50.701
can't get away without
using some system calls.

00:26:50.701 --> 00:26:53.367
For example, we need a way
to render fonts.

00:26:53.367 --> 00:26:55.634
And on Windows, to get
the best sort of fidelity

00:26:55.634 --> 00:26:58.033
and the best sort of
native look and feel,

00:26:58.033 --> 00:27:00.767
you really need to use
the Windows GDI APIs

00:27:00.767 --> 00:27:02.801
to render fonts.

00:27:02.801 --> 00:27:04.434
Well,
an interesting story here.

00:27:04.434 --> 00:27:06.300
This turned out to be
really challenging,

00:27:06.300 --> 00:27:09.534
'cause once you take away
the rendering engine's ability

00:27:09.534 --> 00:27:12.000
to access the file system,

00:27:12.000 --> 00:27:15.767
well, what this actually means
is that you can't load fonts.

00:27:15.767 --> 00:27:18.234
And all the font APIs,
transparently under the hood,

00:27:18.234 --> 00:27:19.901
will load fonts.

00:27:19.901 --> 00:27:22.767
Interestingly enough,
they don't do it in user land.

00:27:22.767 --> 00:27:24.334
They do it in kernel mode.

00:27:24.334 --> 00:27:25.801
But they use the token

00:27:25.801 --> 00:27:27.467
of the process
that was calling them

00:27:27.467 --> 00:27:29.868
to actually decide
whether or not

00:27:29.868 --> 00:27:32.434
the kernel should load
that font.

00:27:32.434 --> 00:27:36.234
Well, our token doesn't have
those privileges.

00:27:36.234 --> 00:27:39.300
So it turns out that Chrome
implements a glorious hack

00:27:39.300 --> 00:27:42.567
of when we encounter
a font API call that fails,

00:27:42.567 --> 00:27:44.934
we pause and let the browser
repeat the API

00:27:44.934 --> 00:27:46.267
and load the font,

00:27:46.267 --> 00:27:48.834
thereby populating the kernel's
cache of all fonts,

00:27:48.834 --> 00:27:51.734
and then we repeat the exercise
of calling that API

00:27:51.734 --> 00:27:53.234
in the renderer

00:27:53.234 --> 00:27:54.901
and this time
hope it succeeds

00:27:54.901 --> 00:27:56.834
because it hits some cache

00:27:56.834 --> 00:27:59.033
that the kernel maintains.

00:27:59.033 --> 00:28:01.501
So fascinating complexities
just trying to deal

00:28:01.501 --> 00:28:03.767
with some OS APIs.

00:28:03.767 --> 00:28:05.167
Other things
that we really wanted

00:28:05.167 --> 00:28:06.734
to try to achieve
with this--

00:28:06.734 --> 00:28:08.801
We really wanted to make sure
that there's no way

00:28:08.801 --> 00:28:10.868
that a hung renderer
can screw up the browser.

00:28:10.868 --> 00:28:13.367
This really impacts
the rendering model,

00:28:13.367 --> 00:28:15.467
which I'll talk about
a little more in detail later.

00:28:15.467 --> 00:28:17.467
But fundamentally, you don't
want to be in a situation

00:28:17.467 --> 00:28:19.133
where the renderer
is acquiring a lock

00:28:19.133 --> 00:28:21.234
that the browser
then has to also acquire,

00:28:21.234 --> 00:28:23.634
because the renderer
might never release it.

00:28:23.634 --> 00:28:26.200
And that--
As an end result, you know,

00:28:26.200 --> 00:28:28.601
a bad renderer might
bring down the whole browser,

00:28:28.601 --> 00:28:30.501
and we just really don't want
to be in that situation.

00:28:30.501 --> 00:28:33.334
And of course
it needs to be really fast.

00:28:33.334 --> 00:28:35.000
So speed is very important

00:28:35.000 --> 00:28:37.834
and somehow there should not
be any situations

00:28:37.834 --> 00:28:42.367
where the renderer
can lock up the browser.

00:28:42.367 --> 00:28:44.267
So painting and scrolling,

00:28:44.267 --> 00:28:45.901
lock free
painting and scrolling.

00:28:45.901 --> 00:28:47.834
This is a system
that we implement

00:28:47.834 --> 00:28:50.601
of maintaining
a backingstore in the browser.

00:28:50.601 --> 00:28:54.367
A recent Pixmap
of what the tab looks like.

00:28:54.367 --> 00:28:55.901
Very simple idea.

00:28:55.901 --> 00:28:57.200
And then the renderer,

00:28:57.200 --> 00:28:59.033
whenever he needs
to update a region,

00:28:59.033 --> 00:29:01.100
he sends a bitmap
over shared memory

00:29:01.100 --> 00:29:02.868
to the browser
and he blits that in

00:29:02.868 --> 00:29:04.100
to his backingstore

00:29:04.100 --> 00:29:08.100
and then blits that result
onto the screen.

00:29:08.100 --> 00:29:09.400
Very straightforward.

00:29:09.400 --> 00:29:10.868
And then when the browser

00:29:10.868 --> 00:29:12.267
is finished
putting pixels on the screen,

00:29:12.267 --> 00:29:13.534
he acknowledges
to the renderer,

00:29:13.534 --> 00:29:14.968
"Hey, look, and now
it's a good time

00:29:14.968 --> 00:29:16.801
to produce another bitmap."

00:29:16.801 --> 00:29:19.367
So this turns out to work
fairly well,

00:29:19.367 --> 00:29:22.601
except that, you know,
we recognize

00:29:22.601 --> 00:29:25.033
that you end up
in this sort of staggering

00:29:25.033 --> 00:29:26.834
kind of situation

00:29:26.834 --> 00:29:28.868
where the renderer paints,
then the browser paints,

00:29:28.868 --> 00:29:30.801
then the renderer paints,
browser paints.

00:29:30.801 --> 00:29:32.701
And in order to get
better performance,

00:29:32.701 --> 00:29:34.767
we allow the renderer
to sort of prefetch

00:29:34.767 --> 00:29:37.934
or do one additional render
ahead of the next--

00:29:37.934 --> 00:29:40.133
in parallel
to the browser painting.

00:29:40.133 --> 00:29:41.701
So if you're on
a multi-core system,

00:29:41.701 --> 00:29:43.667
you would be able
to light up both CPUs,

00:29:43.667 --> 00:29:45.167
one of them is the renderer

00:29:45.167 --> 00:29:46.868
producing the next
rendered output,

00:29:46.868 --> 00:29:48.133
and the other one
is the browser

00:29:48.133 --> 00:29:49.834
putting the pixels
from the previous rendering

00:29:49.834 --> 00:29:51.501
on the screen.

00:29:51.501 --> 00:29:53.501
Scrolling works
very similarly.

00:29:53.501 --> 00:29:55.734
In order to achieve
very good scrolling performance,

00:29:55.734 --> 00:29:58.200
you don't want to just
repaint the whole thing.

00:29:58.200 --> 00:30:00.334
You want to tell
the windowing system,

00:30:00.334 --> 00:30:01.968
"Hey, look,
move your pixels down

00:30:01.968 --> 00:30:03.868
and backfill
this exposed region."

00:30:03.868 --> 00:30:06.567
So we send commands
from the renderer

00:30:06.567 --> 00:30:09.767
to scroll the backingstore
and fill the exposed region,

00:30:09.767 --> 00:30:11.868
the then the browser
repeats the exercise

00:30:11.868 --> 00:30:13.334
of commanding
the windowing system

00:30:13.334 --> 00:30:15.601
to scroll the pixels and then
backfill the exposed region.

00:30:15.601 --> 00:30:21.367
And again, it acknowledges
once that's been done.

00:30:21.367 --> 00:30:24.167
Actually one more comment
about painting.

00:30:24.167 --> 00:30:27.234
So whenever you need
to resize the browser window,

00:30:27.234 --> 00:30:31.400
because we have a backingstore
of the old rendering,

00:30:31.400 --> 00:30:33.901
we don't necessarily have--
that backingstore

00:30:33.901 --> 00:30:35.834
is not the right size
when you resize.

00:30:35.834 --> 00:30:37.634
And so it turns out
to be necessary

00:30:37.634 --> 00:30:40.968
to play some games to try
to get good performance there,

00:30:40.968 --> 00:30:43.367
because we're in a situation
where a resize happened

00:30:43.367 --> 00:30:46.634
and we want to update
the backingstore,

00:30:46.634 --> 00:30:49.033
and we obviously
don't have it yet.

00:30:49.033 --> 00:30:51.434
But we have asked the renderer
to produce the data,

00:30:51.434 --> 00:30:53.167
and we're just waiting
for the renderer

00:30:53.167 --> 00:30:55.167
to produce the data,
but Windows has asked us

00:30:55.167 --> 00:30:57.567
to paint right now,
because it just resized.

00:30:57.567 --> 00:31:00.267
So we do implement
a little bit of a pause

00:31:00.267 --> 00:31:02.767
to allow the renderer
to produce pixels.

00:31:02.767 --> 00:31:04.701
If it can produce them
fast enough,

00:31:04.701 --> 00:31:06.934
then on resize we will
paint the correct pixels

00:31:06.934 --> 00:31:09.400
and not the old pixels.

00:31:09.400 --> 00:31:11.501
But it's fairly common
in Chrome when you use it,

00:31:11.501 --> 00:31:14.167
if you resize very quickly,
you will see a little gutter,

00:31:14.167 --> 00:31:18.434
and that's
what's going on there.

00:31:18.434 --> 00:31:19.968
Resource loading.

00:31:19.968 --> 00:31:21.367
So as I mentioned before,

00:31:21.367 --> 00:31:23.434
the browser's this proxy
for all the IO.

00:31:23.434 --> 00:31:27.400
He takes great care
to restrict the types of URLs

00:31:27.400 --> 00:31:29.534
that can be loaded
based on protocols.

00:31:29.534 --> 00:31:33.467
So if a rendering process
was not asked by the browser

00:31:33.467 --> 00:31:36.133
to load a file URL,
then the rendering process

00:31:36.133 --> 00:31:38.801
shall not request file URLs.

00:31:38.801 --> 00:31:40.667
And if he does,
they're denied.

00:31:40.667 --> 00:31:42.934
Chrome colon URLs
are like file colon URLs

00:31:42.934 --> 00:31:44.634
in that they're trusted.

00:31:44.634 --> 00:31:46.901
Chrome colon URLs
are used to load things

00:31:46.901 --> 00:31:49.234
like the new tab page,
the downloads panel,

00:31:49.234 --> 00:31:53.934
and other web content
that part of Chrome's UI.

00:31:53.934 --> 00:31:58.968
This browser network code
will actually perform

00:31:58.968 --> 00:32:01.067
all the safe browsing checks
I talked about.

00:32:01.067 --> 00:32:03.367
He'll do all kinds of things
like vending the cookies

00:32:03.367 --> 00:32:04.567
to the renderers
and managing all the data

00:32:04.567 --> 00:32:07.467
associated
with resource loading.

00:32:07.467 --> 00:32:09.934
Finally, before WebKit
sees any data,

00:32:09.934 --> 00:32:12.133
the browser's actually performed
a lot of different things.

00:32:12.133 --> 00:32:14.167
He's handled
HTTP authentication

00:32:14.167 --> 00:32:15.734
if prompting was necessary.

00:32:15.734 --> 00:32:18.000
He's done all
the SSL verification

00:32:18.000 --> 00:32:20.667
and potentially put up UI

00:32:20.667 --> 00:32:22.868
to ask users if they're--

00:32:22.868 --> 00:32:24.934
You know, put a warning dialog
that's like,

00:32:24.934 --> 00:32:26.434
"This, you know--

00:32:26.434 --> 00:32:28.634
This certificate
is not necessarily valid."

00:32:28.634 --> 00:32:29.968
He's done all these things

00:32:29.968 --> 00:32:31.934
by the time
WebKit sees any data.

00:32:31.934 --> 00:32:34.200
He's also potentially
handled downloads,

00:32:34.200 --> 00:32:36.067
so content sniffing
happens in the browser.

00:32:36.067 --> 00:32:41.000
MIME detection happens there
if necessary and so on.

00:32:41.000 --> 00:32:42.868
Some of the things that's
interesting about downloads

00:32:42.868 --> 00:32:45.901
is that if you imagine
a scenario

00:32:45.901 --> 00:32:48.567
where you were
returning data to WebKit

00:32:48.567 --> 00:32:49.901
or to the rendering process,

00:32:49.901 --> 00:32:51.434
and that process
was to determine

00:32:51.434 --> 00:32:53.734
whether or not the data
should be treated as a download,

00:32:53.734 --> 00:32:56.434
well, you would be
in an unfortunate situation

00:32:56.434 --> 00:32:58.100
of having to echo that data
back to the browser

00:32:58.100 --> 00:33:00.000
so that he could
save it to disk.

00:33:00.000 --> 00:33:01.934
And so moving the detection
into the browser

00:33:01.934 --> 00:33:03.467
allows for better performance.

00:33:03.467 --> 00:33:05.167
All the decisions
happen there,

00:33:05.167 --> 00:33:06.567
and it can either go--

00:33:06.567 --> 00:33:08.267
it could either decide
at that time

00:33:08.267 --> 00:33:13.033
to T it to disk
instead of to the renderer.

00:33:13.033 --> 00:33:14.968
The history system.

00:33:14.968 --> 00:33:20.200
So...much like painting,

00:33:20.200 --> 00:33:22.701
it was important to us
that we could achieve

00:33:22.701 --> 00:33:26.367
a good way to manage
visited links

00:33:26.367 --> 00:33:28.267
without locking.

00:33:28.267 --> 00:33:31.901
We wanted to make sure that--

00:33:31.901 --> 00:33:35.834
so that the renderer
could very quickly check

00:33:35.834 --> 00:33:37.400
whether or not
a link was visited

00:33:37.400 --> 00:33:39.300
so it could color it
as visited or not,

00:33:39.300 --> 00:33:40.901
and do so in a way
that didn't require

00:33:40.901 --> 00:33:42.634
acquiring any kind of lock.

00:33:42.634 --> 00:33:44.834
So there's sort of simple idea
of shared memory

00:33:44.834 --> 00:33:46.767
containing a bitmap

00:33:46.767 --> 00:33:48.801
that's treated like
a hash table.

00:33:48.801 --> 00:33:50.834
We apply a crypto hash
to the URL,

00:33:50.834 --> 00:33:53.734
take 64 bits of that,
index this bitmap,

00:33:53.734 --> 00:33:58.234
and then see if
the link's visited or not.

00:33:58.234 --> 00:33:59.767
And then the browser,

00:33:59.767 --> 00:34:01.334
whenever he needs
to update this thing,

00:34:01.334 --> 00:34:02.801
he's either setting the bits,

00:34:02.801 --> 00:34:04.334
or if he finds that
he needs to grow the table,

00:34:04.334 --> 00:34:05.767
he creates a whole new table,

00:34:05.767 --> 00:34:07.267
sends the new table
down to the renderer.

00:34:07.267 --> 00:34:08.734
The renderers
drop the old table

00:34:08.734 --> 00:34:10.067
and then pick up
the new one.

00:34:10.067 --> 00:34:12.267
Works great
with the minor exception

00:34:12.267 --> 00:34:15.067
that it causes us to fail
one of the Acid3 tests.

00:34:15.067 --> 00:34:18.534
This is why Chrome gets
that link test error in Acid3,

00:34:18.534 --> 00:34:21.267
because it turns out that this
is a very asynchronous model,

00:34:21.267 --> 00:34:22.767
of the browser's the only one

00:34:22.767 --> 00:34:24.300
who writes
to the visited link table.

00:34:24.300 --> 00:34:25.801
The renderer's
the one who reads,

00:34:25.801 --> 00:34:28.534
but this Acid3 test
actually requires the renderer

00:34:28.534 --> 00:34:32.234
to have visited
and be able to check right away

00:34:32.234 --> 00:34:35.734
that this link
is actually visited.

00:34:35.734 --> 00:34:37.767
But we're working
on a fix.

00:34:37.767 --> 00:34:39.501
So after a page loads,

00:34:39.501 --> 00:34:41.634
data is actually extracted
from the page

00:34:41.634 --> 00:34:43.267
so that it can be sent
into the full text index,

00:34:43.267 --> 00:34:45.868
and that's what drives
things like the Omnibox

00:34:45.868 --> 00:34:48.601
and the whole history search
mechanism in Chrome.

00:34:48.601 --> 00:34:50.701
And new tab is populated
with thumbnails.

00:34:50.701 --> 00:34:54.501
Those thumbnails are captured
at this time and so on.

00:34:54.501 --> 00:34:56.667
And this data is collected,
sent up to the browser.

00:34:56.667 --> 00:35:00.767
All this history management
happens up there.

00:35:00.767 --> 00:35:03.033
Plug-ins.

00:35:03.033 --> 00:35:04.968
This is probably--Plug-ins--

00:35:04.968 --> 00:35:07.467
Support Netscape
style plug-ins

00:35:07.467 --> 00:35:11.267
and even ActiveX controls
through a shim.

00:35:11.267 --> 00:35:12.734
Talk a little bit more
about that.

00:35:12.734 --> 00:35:14.167
Supporting plug-ins
turns out to be

00:35:14.167 --> 00:35:15.934
probably one of the hardest
things about doing Chrome,

00:35:15.934 --> 00:35:18.734
because we knew
they could not run

00:35:18.734 --> 00:35:20.100
in the sandbox renderer

00:35:20.100 --> 00:35:21.567
because they required
a lot of privileges,

00:35:21.567 --> 00:35:23.367
and we knew that we wanted
to have a sandbox

00:35:23.367 --> 00:35:25.100
that was very aggressive.

00:35:25.100 --> 00:35:26.968
And so that meant
pushing the plug-in

00:35:26.968 --> 00:35:28.634
outside of
the rendering engine,

00:35:28.634 --> 00:35:32.234
which meant taking an API
that was synchronous

00:35:32.234 --> 00:35:34.834
and designed to run
inside of a rendering engine

00:35:34.834 --> 00:35:37.300
and forcing it out of process.

00:35:37.300 --> 00:35:40.200
This turned out to be
very complicated.

00:35:40.200 --> 00:35:41.834
But what we tried to do here

00:35:41.834 --> 00:35:44.767
by allocating a single
plug-in process per plug-in

00:35:44.767 --> 00:35:48.334
was to give plug-ins sort of
this environment to run in

00:35:48.334 --> 00:35:52.033
that looked to them much like
an ordinary browser environment.

00:35:52.033 --> 00:35:54.334
So unbeknownst to them,
hopefully,

00:35:54.334 --> 00:35:56.000
they don't realize
that they're actually

00:35:56.000 --> 00:35:57.701
in a separate process.

00:35:57.701 --> 00:35:59.634
And this works--

00:35:59.634 --> 00:36:03.000
Through a lot of
sweat, tears, and toil,

00:36:03.000 --> 00:36:05.167
we've gotten this to work.

00:36:05.167 --> 00:36:08.234
So there's two types
of plug-ins,

00:36:08.234 --> 00:36:09.968
two modes of rendering
for plug-ins.

00:36:09.968 --> 00:36:12.467
One is called windowless
and one is windowed.

00:36:12.467 --> 00:36:14.200
Windowed means that
you actually get--

00:36:14.200 --> 00:36:16.200
the plug-in actually
has its own native widget,

00:36:16.200 --> 00:36:17.634
like its own hWnd.

00:36:17.634 --> 00:36:20.000
And then once it has
its own hWnd,

00:36:20.000 --> 00:36:24.467
it has its own
render loop basically.

00:36:24.467 --> 00:36:27.200
And it has a lot of control
and access to the system.

00:36:27.200 --> 00:36:29.133
But we're running
that hWnd out of process,

00:36:29.133 --> 00:36:31.334
and so we are managing
a windowing hierarchy

00:36:31.334 --> 00:36:32.868
that spans processes,

00:36:32.868 --> 00:36:34.934
and windows
outside of our control

00:36:34.934 --> 00:36:38.400
will be doing IPCs
between those windows,

00:36:38.400 --> 00:36:41.968
and that leads to a lot
of complexity.

00:36:41.968 --> 00:36:43.868
So we do
some interesting tricks

00:36:43.868 --> 00:36:46.701
to try to minimize
the synchronous communication

00:36:46.701 --> 00:36:48.167
that Windows does
underneath the hood

00:36:48.167 --> 00:36:49.834
so that scrolling a page
with plug-ins

00:36:49.834 --> 00:36:51.801
will actually perform okay.

00:36:51.801 --> 00:36:54.200
I think we still have
room to improve here,

00:36:54.200 --> 00:36:56.000
but it's gotten
a lot better

00:36:56.000 --> 00:36:57.734
since the Chrome 1 days.

00:36:57.734 --> 00:37:00.467
Or I should say
since our initial launch.

00:37:00.467 --> 00:37:02.634
Caching the rendering
of windowless plug-ins.

00:37:02.634 --> 00:37:04.534
What we do when there's
a windowless plug-in--

00:37:04.534 --> 00:37:05.868
This is a plug-in type

00:37:05.868 --> 00:37:08.100
that has no hWnd
associated with it, no window.

00:37:08.100 --> 00:37:10.100
Instead the rendering engine
just asks it,

00:37:10.100 --> 00:37:12.000
"Please paint
into this buffer."

00:37:12.000 --> 00:37:14.167
And it turns out
that windowless plug-ins

00:37:14.167 --> 00:37:15.801
do something interesting.

00:37:15.801 --> 00:37:17.734
They actually
do the compositing

00:37:17.734 --> 00:37:19.367
inside the plug-in.

00:37:19.367 --> 00:37:20.701
What this means is--

00:37:20.701 --> 00:37:23.067
And they can be
in the Z-order of CSS.

00:37:23.067 --> 00:37:26.367
And so what this means
is that as WebKit is painting

00:37:26.367 --> 00:37:28.067
and it encounters a plug-in,

00:37:28.067 --> 00:37:29.634
it sort of stops,
asks the plug-in,

00:37:29.634 --> 00:37:30.934
"Now please draw your pixels,"

00:37:30.934 --> 00:37:32.701
and then WebKit
continues painting on top.

00:37:32.701 --> 00:37:34.400
So you get
this interesting stack.

00:37:34.400 --> 00:37:36.000
And so if we were
trying to achieve,

00:37:36.000 --> 00:37:39.467
as I mentioned earlier on,
good asynchronous communication

00:37:39.467 --> 00:37:42.000
between our processes
and asynchronous separation,

00:37:42.000 --> 00:37:43.734
here, rendering
windowless plug-ins,

00:37:43.734 --> 00:37:45.734
is a case
where we don't have that.

00:37:45.734 --> 00:37:47.501
So our solution
was to keep a cache

00:37:47.501 --> 00:37:50.467
or what the windowless
plug-in rendered last time

00:37:50.467 --> 00:37:51.934
in the rendering process,

00:37:51.934 --> 00:37:53.868
so that when we're painting
in WebKit,

00:37:53.868 --> 00:37:56.334
he can quickly just paint
from that cached representation

00:37:56.334 --> 00:37:57.968
of the plug-in.

00:37:57.968 --> 00:38:00.133
And once we implemented this,
we got a much better performance

00:38:00.133 --> 00:38:01.701
for windowless plug-ins.

00:38:01.701 --> 00:38:03.634
Of course you suffer
a frame rate hit

00:38:03.634 --> 00:38:05.267
for windowless animations,

00:38:05.267 --> 00:38:08.667
but overall the results
are much better.

00:38:08.667 --> 00:38:11.501
Another big challenge
with all of this is porting,

00:38:11.501 --> 00:38:14.934
because NPAPI is not
a platform-independent API.

00:38:14.934 --> 00:38:17.701
It's really just glue,
bridging glue,

00:38:17.701 --> 00:38:21.767
binding the browser
to other native APIs

00:38:21.767 --> 00:38:23.467
for rendering.

00:38:23.467 --> 00:38:27.400
And so the work required
to support Mac and Linux

00:38:27.400 --> 00:38:29.367
is similar magnitude
to the work

00:38:29.367 --> 00:38:30.701
that was required
to support Windows,

00:38:30.701 --> 00:38:33.234
and it's very challenging.

00:38:33.234 --> 00:38:34.467
But it's coming along.

00:38:34.467 --> 00:38:36.300
The current Chromium
Max and Linux builds

00:38:36.300 --> 00:38:38.667
do not yet have plug-ins
enabled for this reason,

00:38:38.667 --> 00:38:40.868
but they're in development

00:38:40.868 --> 00:38:44.167
and can be enabled
through a switch, I believe.

00:38:44.167 --> 00:38:49.200
So I want to talk
a little bit about WebKit,

00:38:49.200 --> 00:38:51.467
just briefly about WebKit.

00:38:51.467 --> 00:38:53.367
So WebKit,
for those who don't know,

00:38:53.367 --> 00:38:55.601
is comprised of,
what I'd say,

00:38:55.601 --> 00:38:57.400
is about three major modules.

00:38:57.400 --> 00:38:58.701
There's JavaScriptCore,

00:38:58.701 --> 00:39:00.167
the WebKit's
JavaScript engine.

00:39:00.167 --> 00:39:02.033
This is obviously
what Chrome doesn't use.

00:39:02.033 --> 00:39:03.801
We use V8 instead.

00:39:03.801 --> 00:39:06.267
WebCore represents
all of the code

00:39:06.267 --> 00:39:09.033
to do the HTML, CSS,
and DOM rendering.

00:39:09.033 --> 00:39:12.167
SVG is at this layer
and other features.

00:39:12.167 --> 00:39:16.000
A lot of the new
API's database and so on

00:39:16.000 --> 00:39:18.501
are at this layer.

00:39:18.501 --> 00:39:20.400
And then there's
the WebKit layer to WebKit,

00:39:20.400 --> 00:39:22.334
which is the API layer.

00:39:22.334 --> 00:39:25.634
And we don't use this because
the layers that exist here

00:39:25.634 --> 00:39:27.267
in the WebKit repository

00:39:27.267 --> 00:39:30.033
are things like
a COM API to WebKit,

00:39:30.033 --> 00:39:32.267
an objective CAPI
to WebKit,

00:39:32.267 --> 00:39:34.200
a GDK API to WebKit,

00:39:34.200 --> 00:39:35.234
a QT API to WebKit,

00:39:35.234 --> 00:39:37.767
wxWidgets API to WebKit.

00:39:37.767 --> 00:39:39.467
None of those
are really appropriate

00:39:39.467 --> 00:39:41.267
for our use case

00:39:41.267 --> 00:39:43.200
where we need it
to run the renderer

00:39:43.200 --> 00:39:45.467
in this insulated world
in the sandbox

00:39:45.467 --> 00:39:47.334
where it really doesn't
have access to the system.

00:39:47.334 --> 00:39:49.534
And so there's any native
toolkit you can imagine,

00:39:49.534 --> 00:39:51.334
or any even
cross-platform toolkit,

00:39:51.334 --> 00:39:53.534
that, under the hood,
really deals in native widgets

00:39:53.534 --> 00:39:55.033
just wouldn't work.

00:39:55.033 --> 00:39:56.701
So, for us,
we were not able to use

00:39:56.701 --> 00:39:58.100
the existing embedding APIs,

00:39:58.100 --> 00:39:59.601
but we had to have our own.

00:39:59.601 --> 00:40:01.167
And so we're
building out own

00:40:01.167 --> 00:40:03.067
that we will be putting into
the WebKit repository

00:40:03.067 --> 00:40:06.801
in good time.

00:40:06.801 --> 00:40:09.067
So if you were to look
into the WebCore reposit--

00:40:09.067 --> 00:40:11.100
WebCore directory today,

00:40:11.100 --> 00:40:13.434
you would see some
interesting pound defines.

00:40:13.434 --> 00:40:15.734
Things for, like,
PLATFORM(CHROMIUM)

00:40:15.734 --> 00:40:20.701
which represents changes
that we made to WebKit

00:40:20.701 --> 00:40:23.133
to support
Chromium-specific things.

00:40:23.133 --> 00:40:24.400
PLATFORM(SKIA),

00:40:24.400 --> 00:40:26.601
again for Skia-specific
things.

00:40:26.601 --> 00:40:30.133
Basically WebCore
has a graphics layer

00:40:30.133 --> 00:40:32.667
where you are to implement
a graphics context.

00:40:32.667 --> 00:40:34.200
And so we have
a Skia implementation

00:40:34.200 --> 00:40:35.634
to graphics contexts.

00:40:35.634 --> 00:40:38.234
USE(V8) is the pound defined
to select V8.

00:40:38.234 --> 00:40:42.567
The V8 bindings
all live inside of WebCore.

00:40:42.567 --> 00:40:44.234
Mostly.

00:40:44.234 --> 00:40:46.167
WebKit versions.

00:40:46.167 --> 00:40:50.100
So for when we shipped
Chrome 1,

00:40:50.100 --> 00:40:51.901
when we did
our initial launch,

00:40:51.901 --> 00:40:53.901
we were very nervous
about our selection

00:40:53.901 --> 00:40:55.801
of the version of WebKit.

00:40:55.801 --> 00:40:58.801
We wanted to make sure
that we didn't inadvertently

00:40:58.801 --> 00:41:01.400
introduce web compatibility
issues.

00:41:01.400 --> 00:41:04.667
So Safari 3 had shipped
earlier in the year,

00:41:04.667 --> 00:41:07.534
and we chose to continue
shipping WebKit

00:41:07.534 --> 00:41:10.300
based on the version of WebKit
that Safari 3 shipped,

00:41:10.300 --> 00:41:12.300
mostly just to achieve
compatibility.

00:41:12.300 --> 00:41:15.300
We didn't want to worry about
being on a different WebKit

00:41:15.300 --> 00:41:17.467
that had changed.

00:41:17.467 --> 00:41:18.834
Again for Chrome 2,

00:41:18.834 --> 00:41:20.901
we're pretty lined up
with Safari 4's WebKit.

00:41:20.901 --> 00:41:22.934
I think we've taken
a slightly older--

00:41:22.934 --> 00:41:25.868
a slightly newer version
of WebKit than they shipped.

00:41:25.868 --> 00:41:31.100
And one of the big hurdles
for Chrome 2

00:41:31.100 --> 00:41:34.067
was actually moving
from this older WebKit

00:41:34.067 --> 00:41:35.901
to the newer WebKit.

00:41:35.901 --> 00:41:37.667
And so that has a lot to do

00:41:37.667 --> 00:41:40.634
with what I want
to talk about next.

00:41:40.634 --> 00:41:42.601
It's WebKit development.

00:41:42.601 --> 00:41:44.534
So members
of the Chromium team

00:41:44.534 --> 00:41:48.400
are very active
in the WebKit community now.

00:41:48.400 --> 00:41:51.234
We have a number of reviewers,
a number of contributors,

00:41:51.234 --> 00:41:55.501
and we're just trying
to increase our presence

00:41:55.501 --> 00:41:58.133
and increase our contribution
to the WebKit project.

00:41:58.133 --> 00:42:02.200
So we believe strongly
in WebKit being--

00:42:02.200 --> 00:42:04.834
We're very happy
to have used WebKit.

00:42:04.834 --> 00:42:08.934
We're just very much enjoying
all the things it does for us,

00:42:08.934 --> 00:42:11.701
and we want to continue
to contribute to it.

00:42:11.701 --> 00:42:13.400
I say status: unforked.

00:42:13.400 --> 00:42:15.868
So when we initially launched,

00:42:15.868 --> 00:42:19.067
because we were on
an older version of WebKit

00:42:19.067 --> 00:42:21.601
and we needed
to fix problems,

00:42:21.601 --> 00:42:25.701
we accumulated a large number
of forks to WebKit.

00:42:25.701 --> 00:42:28.467
And indeed to even
support V8 in WebKit,

00:42:28.467 --> 00:42:31.400
we needed to make
modifications.

00:42:31.400 --> 00:42:34.200
So in order to get
to a point where we could

00:42:34.200 --> 00:42:35.767
actually work
directly on WebKit

00:42:35.767 --> 00:42:38.300
and be a first-class citizen
in the WebKit world,

00:42:38.300 --> 00:42:39.834
we needed to unfork.

00:42:39.834 --> 00:42:42.734
And so we went through
this massive,

00:42:42.734 --> 00:42:44.434
I call massive, undertaking

00:42:44.434 --> 00:42:46.567
to sort of push all
of our changes into WebKit

00:42:46.567 --> 00:42:49.767
and refactor things so that
our changes could live there

00:42:49.767 --> 00:42:52.968
and finally end up in a world
where we're able to work

00:42:52.968 --> 00:42:54.667
with Chrome,
develop Chrome,

00:42:54.667 --> 00:42:56.734
on the tip of tree
of WebKit

00:42:56.734 --> 00:42:58.601
alongside of other developers

00:42:58.601 --> 00:43:00.234
who are developing
tip of tree WebKit

00:43:00.234 --> 00:43:02.934
using Safari.

00:43:02.934 --> 00:43:05.067
So our focus of WebKit
development going forward

00:43:05.067 --> 00:43:06.367
is, as I mentioned before,

00:43:06.367 --> 00:43:09.300
we want to establish
a WebKit API for Chromium.

00:43:09.300 --> 00:43:12.000
Our goals here
are very simple

00:43:12.000 --> 00:43:15.701
We want to build a very simple
C++ API to WebKit

00:43:15.701 --> 00:43:19.734
that is not dependent
on any other toolkit

00:43:19.734 --> 00:43:21.267
other than WebCore,
all right?

00:43:21.267 --> 00:43:25.167
That's basically just about
a very thin layer to WebKit

00:43:25.167 --> 00:43:27.467
so that if anybody else
wants to embed WebKit,

00:43:27.467 --> 00:43:29.000
they have
an easy path forward.

00:43:29.000 --> 00:43:32.033
It's not a matter of picking
a certain flavor of toolkit

00:43:32.033 --> 00:43:33.834
that is compatible
with your world,

00:43:33.834 --> 00:43:35.501
but here,
suppose you just want

00:43:35.501 --> 00:43:40.767
a simple API
that's not particular,

00:43:40.767 --> 00:43:42.901
you could use this as well.

00:43:42.901 --> 00:43:45.400
We have a lot of folks
working on open web platform,

00:43:45.400 --> 00:43:46.667
HTML 5, et cetera.

00:43:46.667 --> 00:43:48.000
Web workers
is included in that

00:43:48.000 --> 00:43:49.367
and a number of other things,

00:43:49.367 --> 00:43:51.667
like the video feature
that was just recently launched

00:43:51.667 --> 00:43:54.300
in the Chrome developer
channel.

00:43:54.300 --> 00:43:56.801
And of course
we're very interested

00:43:56.801 --> 00:43:58.300
in improving web compat.

00:43:58.300 --> 00:44:00.667
I think web compat is probably
one of the number one challenges

00:44:00.667 --> 00:44:03.167
for any fledging browser,

00:44:03.167 --> 00:44:05.033
certainly for
any rendering engine

00:44:05.033 --> 00:44:06.601
that doesn't have
the kind of market share

00:44:06.601 --> 00:44:09.701
that MSHTML has
or Gekko has.

00:44:09.701 --> 00:44:11.567
And so the things
that we can do here

00:44:11.567 --> 00:44:13.968
to make a difference
I think would go a long way.

00:44:13.968 --> 00:44:16.400
I think WebKit is fortunately
getting to the point now

00:44:16.400 --> 00:44:17.834
where it's--

00:44:17.834 --> 00:44:20.200
you know, it's approaching
10% market share

00:44:20.200 --> 00:44:22.601
if you add up all the browser,
mobile included,

00:44:22.601 --> 00:44:24.100
that embed WebKit.

00:44:24.100 --> 00:44:27.567
And so once--
my experience with Firefox

00:44:27.567 --> 00:44:30.234
tells me that, you know,
once you get to that 10% point,

00:44:30.234 --> 00:44:33.334
that's when people
don't have a choice but to care.

00:44:33.334 --> 00:44:36.968
Because if one out of ten
users to their website

00:44:36.968 --> 00:44:38.734
can't view their website

00:44:38.734 --> 00:44:41.033
or can't purchase something
off of their site,

00:44:41.033 --> 00:44:43.400
well, then they'll feel that

00:44:43.400 --> 00:44:45.067
in a financial manner
at least.

00:44:45.067 --> 00:44:48.267
And so the hope is that
once you reach that threshold,

00:44:48.267 --> 00:44:49.834
suddenly it'll be
a snowball effect

00:44:49.834 --> 00:44:51.701
and people will care
and people will--

00:44:51.701 --> 00:44:56.133
and compatibility problems
will disappear faster.

00:44:56.133 --> 00:44:58.601
And of course we continue
to be very interested

00:44:58.601 --> 00:45:00.534
in how we can
improve performance.

00:45:00.534 --> 00:45:02.000
Performance is--

00:45:02.000 --> 00:45:03.501
Speed is important

00:45:03.501 --> 00:45:07.133
to the whole essence
of Chrome.

00:45:07.133 --> 00:45:08.334
Open web platform.

00:45:08.334 --> 00:45:09.701
Just a few
more notes about that,

00:45:09.701 --> 00:45:11.701
some of the things
that are in progress.

00:45:11.701 --> 00:45:14.701
Audio/video, well,
you saw the recent release.

00:45:14.701 --> 00:45:17.701
And we're very excited
about that.

00:45:17.701 --> 00:45:19.000
There's lots more
that can be done

00:45:19.000 --> 00:45:22.300
to improve HTML 5
video support in Chrome.

00:45:22.300 --> 00:45:23.601
So we'll be working on that.

00:45:23.601 --> 00:45:25.267
Application cache,
database,

00:45:25.267 --> 00:45:26.734
local storage,
session storage.

00:45:26.734 --> 00:45:29.801
These are all features about
enabling offline applications.

00:45:29.801 --> 00:45:32.834
So very excited to adopt
the same APIs

00:45:32.834 --> 00:45:35.133
as all the other
major browsers.

00:45:35.133 --> 00:45:36.634
Some of these things are
already enabled in WebKit.

00:45:36.634 --> 00:45:38.000
So you might say,

00:45:38.000 --> 00:45:39.834
"Well, how come Chrome
doesn't have them already?

00:45:39.834 --> 00:45:41.501
Safari 4 has it."

00:45:41.501 --> 00:45:43.100
And, you know,
it turns out

00:45:43.100 --> 00:45:45.467
that when you throw a sandbox
around a rendering engine

00:45:45.467 --> 00:45:47.534
and you divide it up
into multiple processes,

00:45:47.534 --> 00:45:50.133
that some of these things
become much more complicated

00:45:50.133 --> 00:45:52.234
to support.

00:45:52.234 --> 00:45:53.934
What do these have in common?

00:45:53.934 --> 00:45:56.100
Well, application cache,
database, local storage,

00:45:56.100 --> 00:45:57.934
they're all touching
the disk.

00:45:57.934 --> 00:45:59.467
So there's file system access.

00:45:59.467 --> 00:46:01.367
File system access
that needs to be proxied

00:46:01.367 --> 00:46:03.033
or managed in some way

00:46:03.033 --> 00:46:05.100
so that these
rendering processes

00:46:05.100 --> 00:46:08.934
can securely access
these APIs.

00:46:08.934 --> 00:46:11.033
So these are all
in development.

00:46:11.033 --> 00:46:14.200
And the way we tend to develop
new features in Chrome

00:46:14.200 --> 00:46:17.400
is that we put them
into the main line

00:46:17.400 --> 00:46:19.200
but behind a command line flag

00:46:19.200 --> 00:46:21.567
so that they're not
actually enabled by default

00:46:21.567 --> 00:46:23.000
until they're ready.

00:46:23.000 --> 00:46:24.467
But by having them
in the main line,

00:46:24.467 --> 00:46:26.968
it means that as Dev Channel
releases go out,

00:46:26.968 --> 00:46:28.868
Beta channel releases go out,

00:46:28.868 --> 00:46:31.367
or stable pushes even happen,
these features are there,

00:46:31.367 --> 00:46:33.200
and people who are interested

00:46:33.200 --> 00:46:35.200
can set
the command line option

00:46:35.200 --> 00:46:37.000
to turn it on to try it out
to give us feedback.

00:46:37.000 --> 00:46:38.834
So we don't have
to require people

00:46:38.834 --> 00:46:41.234
to do custom builds in order
to try out new features

00:46:41.234 --> 00:46:42.400
and give us feedback.

00:46:42.400 --> 00:46:44.534
They can just take
the standard build,

00:46:44.534 --> 00:46:45.868
try it out,
give us feedback.

00:46:45.868 --> 00:46:50.968
And this is huge for supporting
a community of testers.

00:46:50.968 --> 00:46:52.734
Notifications
is a new thing

00:46:52.734 --> 00:46:54.634
that has a lot of interest.

00:46:54.634 --> 00:46:57.434
It's all about trying
to make it possible

00:46:57.434 --> 00:47:00.968
for web applications
to do better notifications

00:47:00.968 --> 00:47:04.634
to the user,
better than window.alert.

00:47:04.634 --> 00:47:06.200
Window.alert
is very, you know,

00:47:06.200 --> 00:47:08.434
a very unfortunate API.

00:47:08.434 --> 00:47:10.434
It sure would be nice
if Calendar could have

00:47:10.434 --> 00:47:12.701
a less annoying,
a less obtrusive way

00:47:12.701 --> 00:47:15.434
of notifying the user that
there is a meeting coming up,

00:47:15.434 --> 00:47:17.534
but a notification
that is still effective

00:47:17.534 --> 00:47:20.934
at getting your attention.

00:47:20.934 --> 00:47:23.501
So that's the kind of stuff
that we're working on.

00:47:23.501 --> 00:47:25.767
And of course web workers
I talked about before.

00:47:25.767 --> 00:47:27.334
There's this idea
of shared workers,

00:47:27.334 --> 00:47:29.701
which is really interesting
that's still being worked out,

00:47:29.701 --> 00:47:32.200
details are being worked out,
but sure would be--

00:47:32.200 --> 00:47:35.467
It would be very powerful
if you could have a worker

00:47:35.467 --> 00:47:38.734
that lives on beyond--

00:47:38.734 --> 00:47:40.501
Well, I should back up
and make sure everybody's

00:47:40.501 --> 00:47:41.767
familiar with workers.

00:47:41.767 --> 00:47:43.801
This is the idea
of background threads

00:47:43.801 --> 00:47:45.667
where you can run
JavaScript on.

00:47:45.667 --> 00:47:48.167
A dedicated worker
is one that a web page

00:47:48.167 --> 00:47:49.467
just creates for itself.

00:47:49.467 --> 00:47:50.634
So it wants
a background thread,

00:47:50.634 --> 00:47:52.000
he can create
a dedicated worker.

00:47:52.000 --> 00:47:54.200
When the page goes away,
the dedicated worker goes away.

00:47:54.200 --> 00:47:55.634
Persistent workers.

00:47:55.634 --> 00:47:58.400
Well, there the worker
can live on a little longer.

00:47:58.400 --> 00:48:01.634
But shared workers are kind of
like persistent workers,

00:48:01.634 --> 00:48:04.267
but different
in that they have a name.

00:48:04.267 --> 00:48:06.367
And you can find them lazily.

00:48:06.367 --> 00:48:08.067
You can find them
and connect to them.

00:48:08.067 --> 00:48:10.200
And so it could give
web applications

00:48:10.200 --> 00:48:12.434
a very powerful way
to have a context,

00:48:12.434 --> 00:48:13.968
a JavaScript context

00:48:13.968 --> 00:48:15.968
that's hidden
and off to the side

00:48:15.968 --> 00:48:17.467
that they can
later connect to.

00:48:17.467 --> 00:48:19.100
So you can imagine
a web application

00:48:19.100 --> 00:48:22.634
might run a portion
of its back end there

00:48:22.634 --> 00:48:24.234
in a shared worker

00:48:24.234 --> 00:48:27.100
and let the actual web pages
just be front ends

00:48:27.100 --> 00:48:30.767
that render the data that
that shared worker manages.

00:48:30.767 --> 00:48:34.033
There's a lot of really
interesting ideas in HTML 5

00:48:34.033 --> 00:48:35.434
and an open web platform

00:48:35.434 --> 00:48:40.234
that we're very excited
to be implementing.

00:48:40.234 --> 00:48:42.734
So I just want to briefly
talk about the network stack

00:48:42.734 --> 00:48:44.300
since I mentioned before

00:48:44.300 --> 00:48:46.200
that that's
a very important element

00:48:46.200 --> 00:48:48.033
of browser architecture.

00:48:48.033 --> 00:48:50.234
Making a better wheel.

00:48:50.234 --> 00:48:52.734
So one wonders,

00:48:52.734 --> 00:48:55.567
why go and invent
another networking stack?

00:48:55.567 --> 00:48:57.000
There's so many out there.

00:48:57.000 --> 00:48:59.033
Indeed, when we first
started the project,

00:48:59.033 --> 00:49:00.901
we thought, well,
let's not do this--

00:49:00.901 --> 00:49:03.701
let's not write this code
if we don't have to.

00:49:03.701 --> 00:49:06.734
In fact, can't we just use
the networking stacks

00:49:06.734 --> 00:49:08.400
that ship with
the various operating systems

00:49:08.400 --> 00:49:10.000
that we wish to target?

00:49:10.000 --> 00:49:11.467
So on Windows,
the natural choice

00:49:11.467 --> 00:49:12.567
was probably Wininet.

00:49:12.567 --> 00:49:14.033
That's the networking stack

00:49:14.033 --> 00:49:15.868
under the hood
of Internet Explorer.

00:49:15.868 --> 00:49:18.534
And there's an API to that
that's well established,

00:49:18.534 --> 00:49:20.767
and, well, let's use that.

00:49:20.767 --> 00:49:22.400
And we started
down that path.

00:49:22.400 --> 00:49:25.501
And interestingly enough,
we learned that

00:49:25.501 --> 00:49:27.267
we really needed
to have control

00:49:27.267 --> 00:49:30.200
over our own web cache
and our own cookie store.

00:49:30.200 --> 00:49:31.934
Okay, so Wininet,
you tell it,

00:49:31.934 --> 00:49:34.534
"Don't use your cookies.
We'll supply our own."

00:49:34.534 --> 00:49:36.100
Turning off the cache though

00:49:36.100 --> 00:49:37.901
turned out to be
kind of difficult.

00:49:37.901 --> 00:49:40.400
Well, we wanted to be able
to turn off the cache

00:49:40.400 --> 00:49:42.834
because we needed to be able
to support incognito mode.

00:49:42.834 --> 00:49:44.400
We didn't want it to be able
to turn off the cache

00:49:44.400 --> 00:49:47.033
because if the cache
contained data

00:49:47.033 --> 00:49:49.100
that was fetched
by Internet Explorer,

00:49:49.100 --> 00:49:51.467
then it might be data
specific to Internet Explorer's

00:49:51.467 --> 00:49:53.667
user agent string.

00:49:53.667 --> 00:49:55.167
And so that
could be a problem.

00:49:55.167 --> 00:49:57.133
So we really are in
a situation

00:49:57.133 --> 00:50:00.133
where we have to manage
our own cache.

00:50:00.133 --> 00:50:01.734
And it turns out
that there was no way

00:50:01.734 --> 00:50:03.734
to tell Wininet,
"Hey, look,

00:50:03.734 --> 00:50:07.434
I don't want you to supply
data from your cache."

00:50:07.434 --> 00:50:09.734
And so we then switched
to Winhttp,

00:50:09.734 --> 00:50:11.767
which is another library
that Microsoft ships

00:50:11.767 --> 00:50:14.167
that just provides
the HTTP layer.

00:50:14.167 --> 00:50:15.934
You bring your own cache.
You bring your own cookies.

00:50:15.934 --> 00:50:18.300
Okay, that sounds great.

00:50:18.300 --> 00:50:21.734
And that's actually what
we shipped with in Chrome 1.

00:50:21.734 --> 00:50:24.300
But, you know,
we recognized that there's--

00:50:24.300 --> 00:50:26.534
we were missing opportunities
to improve performance,

00:50:26.534 --> 00:50:31.934
missing opportunities
to improve this layer

00:50:31.934 --> 00:50:34.400
and even to fix
certain bugs.

00:50:34.400 --> 00:50:37.133
And so we set about
developing our own library,

00:50:37.133 --> 00:50:39.601
and that now lives
in src/net/http/

00:50:39.601 --> 00:50:42.200
in the Chromium code base.

00:50:42.200 --> 00:50:45.267
And that's what shipped
in Chrome 2.

00:50:45.267 --> 00:50:47.968
So DNS prefetching is something
we shipped in Chrome 1,

00:50:47.968 --> 00:50:51.801
you've probably heard about,
which is all about predicting

00:50:51.801 --> 00:50:54.033
which host names
you might visit

00:50:54.033 --> 00:50:56.868
so that we can get
the DNS results started earlier.

00:50:56.868 --> 00:51:00.701
This has a very measurable
impact on performance.

00:51:00.701 --> 00:51:03.901
And we've been spending
a lot of energy--

00:51:03.901 --> 00:51:05.701
You know, whenever anybody
checks the little thing,

00:51:05.701 --> 00:51:07.934
helps supply anonymous
usage data to Google

00:51:07.934 --> 00:51:10.501
to make Google Chrome better,

00:51:10.501 --> 00:51:14.200
that anonymous data
is used to help support

00:51:14.200 --> 00:51:16.167
tailoring these kinds
of algorithms,

00:51:16.167 --> 00:51:17.767
understanding
when this is working,

00:51:17.767 --> 00:51:19.734
when it's not working,

00:51:19.734 --> 00:51:22.267
and various other aspects
of Chrome as well.

00:51:22.267 --> 00:51:24.400
So in development,
there's lots of things

00:51:24.400 --> 00:51:25.767
still to be done
for the new network stack--

00:51:25.767 --> 00:51:27.100
feature parity.

00:51:27.100 --> 00:51:28.601
And there's things missing
like sock support,

00:51:28.601 --> 00:51:30.434
IPv6 literals.

00:51:30.434 --> 00:51:32.367
Regular IPv6,
if a host name results,

00:51:32.367 --> 00:51:33.901
IPv6 would work fine,

00:51:33.901 --> 00:51:35.868
but if you actually use
an IPv6 literal,

00:51:35.868 --> 00:51:37.467
there's some little,
subtle bugs.

00:51:37.467 --> 00:51:38.801
We're working out
all those kinks

00:51:38.801 --> 00:51:42.567
or things that are happening
for future releases.

00:51:42.567 --> 00:51:44.834
Other cool new features
that might help--

00:51:44.834 --> 00:51:46.400
that will have a big impact
on performance.

00:51:46.400 --> 00:51:47.801
Sparse caching.

00:51:47.801 --> 00:51:50.167
So video support
really demands the idea

00:51:50.167 --> 00:51:52.167
that you should be able
to advance the movie

00:51:52.167 --> 00:51:53.734
to a certain location

00:51:53.734 --> 00:51:55.067
and start downloading
from there

00:51:55.067 --> 00:51:56.567
and cache all that data.

00:51:56.567 --> 00:51:58.200
Well, we want to still
be able to jump back

00:51:58.200 --> 00:52:00.901
to the old location
and hit the cache again.

00:52:00.901 --> 00:52:04.000
Sparse caching is gonna help
with this a lot.

00:52:04.000 --> 00:52:06.467
This will also improve the way
Acrobat Reader runs

00:52:06.467 --> 00:52:08.467
inside of Chrome,
because Acrobat Reader,

00:52:08.467 --> 00:52:11.934
when you advance to a page,
like the 27th page,

00:52:11.934 --> 00:52:13.534
Acrobat Reader
will ask the browser,

00:52:13.534 --> 00:52:15.901
"Please fetch me the data
at this range."

00:52:15.901 --> 00:52:17.834
And so we want to be able
to cache that.

00:52:17.834 --> 00:52:20.334
Other browsers don't cache
the ranges like that

00:52:20.334 --> 00:52:21.968
because managing
a sparse cache

00:52:21.968 --> 00:52:24.100
is actually
pretty complicated.

00:52:24.100 --> 00:52:26.400
There's a bunch of other ideas
we have that we're brewing

00:52:26.400 --> 00:52:29.100
and trying to actually
test out.

00:52:29.100 --> 00:52:30.767
Looking at ways
that we can actually employ

00:52:30.767 --> 00:52:32.968
HTTP pipelining
in a manner that's safe.

00:52:32.968 --> 00:52:34.567
Looking at ways
that we can improve

00:52:34.567 --> 00:52:36.234
the establishment
of TCP connections,

00:52:36.234 --> 00:52:37.868
'cause these are--

00:52:37.868 --> 00:52:40.601
TCP connection establishment
is a point at which

00:52:40.601 --> 00:52:42.267
you can really lose
a lot of time.

00:52:42.267 --> 00:52:45.434
And if anything you can do
to kinda like hide that time

00:52:45.434 --> 00:52:48.734
or avoid paying that cost,
you know, when the user

00:52:48.734 --> 00:52:50.968
actually tries to go somewhere
would be beneficial.

00:52:50.968 --> 00:52:52.501
But of course
we have to be very careful

00:52:52.501 --> 00:52:55.000
not to put too much burden
on servers and things like that.

00:52:55.000 --> 00:52:59.601
So parallel proxy auto-config.

00:52:59.601 --> 00:53:02.167
Well, if you're ever using
proxy auto-config,

00:53:02.167 --> 00:53:04.200
you know that performance
can be a real problem with it.

00:53:04.200 --> 00:53:07.300
And so all of us at Google
use a proxy auto-config,

00:53:07.300 --> 00:53:09.100
and so we feel this pain
every day,

00:53:09.100 --> 00:53:10.567
and so we really want
to do something about it.

00:53:10.567 --> 00:53:14.000
And hopefully it benefits
other people as well.

00:53:14.000 --> 00:53:15.434
And that's it.

00:53:15.434 --> 00:53:18.601
I want to open
the floor to questions.

00:53:18.601 --> 00:53:23.734
And let me know
what you're interested in.

00:53:23.734 --> 00:53:25.467
man: Hi.

00:53:25.467 --> 00:53:28.634
As a script developer
in JavaScript,

00:53:28.634 --> 00:53:31.400
I'm not that familiar
with the Chrome yet.

00:53:31.400 --> 00:53:34.133
When I write
an XML HTTP request,

00:53:34.133 --> 00:53:36.400
I can do it synchronous
or asynchronous.

00:53:36.400 --> 00:53:38.501
And the synchronous
is usually blocking

00:53:38.501 --> 00:53:40.834
based on IE.

00:53:40.834 --> 00:53:44.634
The new Firefox, I realized,
it's non-blocking.

00:53:44.634 --> 00:53:46.434
Is it the same with Chrome?

00:53:46.434 --> 00:53:47.734
Fisher:
So it turns out that

00:53:47.734 --> 00:53:49.634
that's a very interesting
thing you mentioned.

00:53:49.634 --> 00:53:51.467
I'm actually the developer
who implemented

00:53:51.467 --> 00:53:53.267
Firefox's behavior.

00:53:53.267 --> 00:53:56.501
And I kind of regret it,
and I'll explain why.

00:53:56.501 --> 00:53:59.033
Because JavaScript
has the assumption

00:53:59.033 --> 00:54:01.968
of run to completion,
being single-threaded.

00:54:01.968 --> 00:54:03.200
But if you--

00:54:03.200 --> 00:54:06.634
If JavaScript blocks on
XML HTTP requests

00:54:06.634 --> 00:54:09.000
to do a synchronous network IO,

00:54:09.000 --> 00:54:11.868
it still looks like
a function call to JavaScript.

00:54:11.868 --> 00:54:13.968
And if you interrupt
that function call

00:54:13.968 --> 00:54:16.567
with, like, running
another JavaScript--

00:54:16.567 --> 00:54:18.701
some other thread
of JavaScript somewhere--

00:54:18.701 --> 00:54:20.267
I mean, it's all
on the same real thread,

00:54:20.267 --> 00:54:22.601
but to the programmer it looks
like somehow JavaScript,

00:54:22.601 --> 00:54:24.501
in another context,
was running

00:54:24.501 --> 00:54:26.467
in the middle
of this function call.

00:54:26.467 --> 00:54:28.634
And so it breaks
the run to completion behavior

00:54:28.634 --> 00:54:30.734
that you come to expect.

00:54:30.734 --> 00:54:35.501
And so really I worry that
the Firefox implementation--

00:54:35.501 --> 00:54:38.300
You know, I was a fan of it
at the time,

00:54:38.300 --> 00:54:42.434
because it frees the UI
from being locked up.

00:54:42.434 --> 00:54:44.234
But I worry
that it would result

00:54:44.234 --> 00:54:47.467
in some very strange bugs
for web developers,

00:54:47.467 --> 00:54:49.968
because when
they expect their program

00:54:49.968 --> 00:54:51.467
to just run
like a sequential program,

00:54:51.467 --> 00:54:53.067
it's suddenly not.

00:54:53.067 --> 00:54:56.400
And so it is
a very big concern to me.

00:54:56.400 --> 00:54:58.100
In Chrome,
we took the approach of,

00:54:58.100 --> 00:55:01.434
well, the rendering engine
is a child process,

00:55:01.434 --> 00:55:02.734
and we have a bitmap

00:55:02.734 --> 00:55:04.701
of the recent
representation of it.

00:55:04.701 --> 00:55:06.667
So when the web page says

00:55:06.667 --> 00:55:09.734
XML HTTP request send,
in a synchronous manner,

00:55:09.734 --> 00:55:12.234
we just let that process
suspend itself.

00:55:12.234 --> 00:55:13.834
And during that IO time,

00:55:13.834 --> 00:55:16.634
we show the old representation
of the page.

00:55:16.634 --> 00:55:19.801
Of course the page is not
interactive at this time.

00:55:19.801 --> 00:55:22.033
But I feel like that's
probably the right way

00:55:22.033 --> 00:55:23.434
for it to behave.

00:55:23.434 --> 00:55:27.067
And basically my belief
is that synchronous XHR

00:55:27.067 --> 00:55:29.234
is really a pretty evil API.

00:55:29.234 --> 00:55:31.067
It's not one that works well
with the web.

00:55:31.067 --> 00:55:32.167
The web is asynchronous.

00:55:32.167 --> 00:55:34.467
Asynchronous APIs
work much more naturally

00:55:34.467 --> 00:55:37.267
in a browser environment.

00:55:37.267 --> 00:55:39.100
So--So that's--

00:55:39.100 --> 00:55:41.300
I can imagine Chrome
doing smarter things though

00:55:41.300 --> 00:55:42.501
in the future.

00:55:42.501 --> 00:55:44.467
Like, for example,
giving the user some UI

00:55:44.467 --> 00:55:46.834
so that they could interrupt
a synchronous XHR

00:55:46.834 --> 00:55:48.434
that's taking too long.

00:55:48.434 --> 00:55:50.067
Today, the only way
to interrupt

00:55:50.067 --> 00:55:51.934
a synchronous XHR in Chrome
that's taking too long

00:55:51.934 --> 00:55:53.334
is to close the tab.

00:55:53.334 --> 00:55:55.400
Close the tab,
you kill the process.

00:55:55.400 --> 00:55:56.734
But if you could interrupt it

00:55:56.734 --> 00:55:58.834
and return control
to a JavaScript with an error,

00:55:58.834 --> 00:56:02.300
that seems like it'd be better.

00:56:02.300 --> 00:56:05.267
Any other questions?

00:56:05.267 --> 00:56:06.868
man: You know,
I almost want to encourage you

00:56:06.868 --> 00:56:09.901
to do some alternative
to NPAPI.

00:56:09.901 --> 00:56:12.267
I've struggled
with trying to port across

00:56:12.267 --> 00:56:15.367
the different browsers
on PGP.

00:56:15.367 --> 00:56:17.634
And we've been trying
to do something

00:56:17.634 --> 00:56:22.000
to look at secure text,
encrypted text, encrypted--

00:56:22.000 --> 00:56:24.033
you know, like an embedded
encrypted content

00:56:24.033 --> 00:56:26.033
and display it.

00:56:26.033 --> 00:56:28.100
And it's just--
it's really difficult

00:56:28.100 --> 00:56:30.000
to go across
the different browsers.

00:56:30.000 --> 00:56:31.400
There's a lot
of little fallbacks.

00:56:31.400 --> 00:56:33.267
NPAPI--Well, put it this way.

00:56:33.267 --> 00:56:34.968
If you're gonna do it,
could you, like, at least

00:56:34.968 --> 00:56:37.133
put out some sample code,
one that compiles

00:56:37.133 --> 00:56:38.868
and actually works
in the different browsers

00:56:38.868 --> 00:56:40.100
and does something--

00:56:40.100 --> 00:56:41.367
Fisher: I agree with you.

00:56:41.367 --> 00:56:42.934
NPAPI is really the bane

00:56:42.934 --> 00:56:45.667
of developers
who have to deal with it.

00:56:45.667 --> 00:56:47.701
I wish there was
something better as well.

00:56:47.701 --> 00:56:49.601
man: Well, I mean,
even the Safari--

00:56:49.601 --> 00:56:53.000
The Safari, you know,
WebKit plug-in thing is way--

00:56:53.000 --> 00:56:55.334
at least that works
on Safari.

00:56:55.334 --> 00:56:56.767
Maybe leverage some of that.

00:56:56.767 --> 00:56:58.801
Fisher: Yeah,
I'm very interested

00:56:58.801 --> 00:57:00.334
in a better solution

00:57:00.334 --> 00:57:02.567
and one that is well documented
and full of samples

00:57:02.567 --> 00:57:04.667
that actually make sense.

00:57:04.667 --> 00:57:06.167
Next question.

00:57:06.167 --> 00:57:07.901
man: I have a question
about your strategy

00:57:07.901 --> 00:57:10.167
for increasing compatibility,

00:57:10.167 --> 00:57:11.667
like, with the rendering
in Safari.

00:57:11.667 --> 00:57:13.434
It seems like, in Safari,

00:57:13.434 --> 00:57:14.901
when they're about
to make a release,

00:57:14.901 --> 00:57:16.367
they do, like,
a WebKit tag,

00:57:16.367 --> 00:57:18.334
and then maybe they commit
into that tag.

00:57:18.334 --> 00:57:21.968
What do you do to, like,
ensure that your--

00:57:21.968 --> 00:57:23.934
whatever you do for a release

00:57:23.934 --> 00:57:27.834
is compatible
with their rendering?

00:57:27.834 --> 00:57:29.467
Fisher: If I understood
the question right,

00:57:29.467 --> 00:57:30.801
you're saying what happens
if, like,

00:57:30.801 --> 00:57:33.300
a new tag is introduced
that's sort of half-baked?

00:57:33.300 --> 00:57:35.234
man:
Or what do you do, like--

00:57:35.234 --> 00:57:37.567
I guess what's your strategy
before--

00:57:37.567 --> 00:57:40.400
When you're deciding on,
you know, where to--

00:57:40.400 --> 00:57:42.300
what revision to go off of.

00:57:42.300 --> 00:57:43.634
Fisher: Yes.

00:57:43.634 --> 00:57:45.501
Okay, yeah, so it's
a very tough question.

00:57:45.501 --> 00:57:48.634
Like, because we are trying
to release early release often

00:57:48.634 --> 00:57:51.000
and not just be beholden

00:57:51.000 --> 00:57:53.100
to when Apple decides
to launch WebKit,

00:57:53.100 --> 00:57:55.033
it does mean
that we potentially pick up

00:57:55.033 --> 00:57:57.267
half-baked APIs,
half-baked things.

00:57:57.267 --> 00:57:59.167
But fortunately the way
WebKit community tends to work

00:57:59.167 --> 00:58:01.234
is that they hide those things
behind a pound define.

00:58:01.234 --> 00:58:03.868
And so it's up to us
to decide when to add

00:58:03.868 --> 00:58:06.801
that pound define
so that it's compiled in.

00:58:06.801 --> 00:58:09.534
And that's basically
been our approach.

00:58:09.534 --> 00:58:14.033
So we don't expose them
until we're ready.

00:58:14.033 --> 00:58:15.934
man: I was curious
a little bit more

00:58:15.934 --> 00:58:17.234
about the sandboxing.

00:58:17.234 --> 00:58:18.534
You were saying in Windows

00:58:18.534 --> 00:58:20.501
it kind of strips
the credentials away from it,

00:58:20.501 --> 00:58:22.067
and I was curious
about other operating systems,

00:58:22.067 --> 00:58:24.367
if you're like--
if it would be more of, like,

00:58:24.367 --> 00:58:26.801
a memory bounds checking
at the code level

00:58:26.801 --> 00:58:28.801
or if you're familiar
with, like, Valgrind,

00:58:28.801 --> 00:58:30.734
which is, like, object code.

00:58:30.734 --> 00:58:32.834
Like, how would you
be implementing that?

00:58:32.834 --> 00:58:34.167
Fisher:
There's a lot of--

00:58:34.167 --> 00:58:36.801
a lot of crazy ideas,
you know, afoot

00:58:36.801 --> 00:58:38.601
for how to sandbox
on Linux.

00:58:38.601 --> 00:58:40.200
You have a lot
of traditional tools

00:58:40.200 --> 00:58:42.634
like chroot,
different user--

00:58:42.634 --> 00:58:43.901
totally different user.

00:58:43.901 --> 00:58:45.234
You know, there's a lot
of things.

00:58:45.234 --> 00:58:47.200
But all of those tools
seem to require

00:58:47.200 --> 00:58:49.701
some change or some support
from the host system,

00:58:49.701 --> 00:58:53.167
so something that's installed
by admin or whatnot.

00:58:53.167 --> 00:58:54.901
I would encourage you
to get up on Chromium Dev

00:58:54.901 --> 00:58:56.200
and chat with the engineers

00:58:56.200 --> 00:58:57.634
who are actually looking
into this problem,

00:58:57.634 --> 00:58:59.200
'cause there's just so many
different approaches

00:58:59.200 --> 00:59:00.701
you could take
with sandboxing.

00:59:00.701 --> 00:59:02.801
man: Are you guys interested
in any sort of, like,

00:59:02.801 --> 00:59:05.367
it's not really portable,
but it's, like, an object type--

00:59:05.367 --> 00:59:06.934
like, how Valgrind does it,

00:59:06.934 --> 00:59:08.334
where it just
reads object code

00:59:08.334 --> 00:59:10.200
and just runs that inside
of, like, an emulator,

00:59:10.200 --> 00:59:11.734
like a user space emulation?

00:59:11.734 --> 00:59:13.367
Fisher: Big concern
is performance really

00:59:13.367 --> 00:59:14.968
with anything we do.

00:59:14.968 --> 00:59:16.567
man: Okay, thank you.

00:59:16.567 --> 00:59:18.868
another man:
One more thing about plug-ins.

00:59:18.868 --> 00:59:20.501
You know,
it would also help if maybe

00:59:20.501 --> 00:59:23.634
you streamlined the installation
process a little bit.

00:59:23.634 --> 00:59:27.567
I understand the security
implications of having plug-ins.

00:59:27.567 --> 00:59:29.467
It'd be nice,
from a user's point of view,

00:59:29.467 --> 00:59:31.901
if they could click somewhere
and actually get a plug-in

00:59:31.901 --> 00:59:35.100
without having
to reboot the browser and--

00:59:35.100 --> 00:59:37.100
Fisher: Well, one of the things
we're trying to solve

00:59:37.100 --> 00:59:39.334
with Chrome extension system
is to actually make it easy

00:59:39.334 --> 00:59:42.801
for extensions to deliver
all manner of things

00:59:42.801 --> 00:59:44.434
that extend the browser.

00:59:44.434 --> 00:59:47.601
And so just like an XPI
can be used on Mozilla

00:59:47.601 --> 00:59:49.534
to deliver an NPAPI plug-in,

00:59:49.534 --> 00:59:52.033
a Chrome extension bundle
should be able to do the same

00:59:52.033 --> 00:59:54.300
and give the user
very good control

00:59:54.300 --> 00:59:55.868
over managing
that plug-in.

00:59:55.868 --> 00:59:57.801
man: Yeah,
we'll talk offline.

00:59:57.801 --> 00:59:59.167
Fisher: So anyways,
that's it.

00:59:59.167 --> 01:00:00.734
I'm afraid we're
all out of time for questions,

01:00:00.734 --> 01:00:02.868
but I'm happy to talk
to folks afterwards.

01:00:02.868 --> 01:00:04.367
Thank you so much
for coming,

01:00:04.367 --> 01:00:09.434
and I'm to remind you

01:00:09.434 --> 01:00:10.934
of this.

01:00:10.934 --> 01:00:12.701
Haveasec.com/IO.

01:00:12.701 --> 01:00:14.634
Please leave your comments.

