WEBVTT
Kind: captions
Language: en

00:00:01.167 --> 00:00:03.467
Kokkevis:
...an engineer at Google.

00:00:03.467 --> 00:00:07.100
I'm also the tech lead
of the O3D team

00:00:07.100 --> 00:00:09.334
and I'm going to be giving
this presentation today

00:00:09.334 --> 00:00:11.133
with Gregg Tavares,

00:00:11.133 --> 00:00:15.033
who's a lead engineer
on the project as well

00:00:15.033 --> 00:00:17.033
on API Google.

00:00:17.033 --> 00:00:19.534
But I was wondering,
before we start,

00:00:19.534 --> 00:00:21.167
if I could get
with a show of hands--

00:00:21.167 --> 00:00:24.033
how many of you have
actually downloaded

00:00:24.033 --> 00:00:27.133
and sort of
looked around O3D?

00:00:27.133 --> 00:00:30.000
Okay.
There's a few people.

00:00:30.000 --> 00:00:31.300
Can I ask you
how many of you

00:00:31.300 --> 00:00:33.200
have actually done
any graphics programming

00:00:33.200 --> 00:00:36.501
with stuff like D3D
or OpenGL?

00:00:36.501 --> 00:00:37.901
All right, a lot more.
Excellent.

00:00:37.901 --> 00:00:38.968
All right.
Cool.

00:00:38.968 --> 00:00:40.968
So we kind of figured
that it would be

00:00:40.968 --> 00:00:42.767
a pretty diverse audience.

00:00:42.767 --> 00:00:45.033
So what we did is we--
we split the presentation

00:00:45.033 --> 00:00:46.601
in two parts, really.

00:00:46.601 --> 00:00:50.634
So I'm going to start
with an overview of O3D.

00:00:50.634 --> 00:00:52.300
I'm going to give you
sort of a high-level view

00:00:52.300 --> 00:00:54.434
of what the API is,

00:00:54.434 --> 00:00:56.968
and what the goals were
in designing that API,

00:00:56.968 --> 00:01:00.067
and focus on a few
different sort of areas

00:01:00.067 --> 00:01:02.901
that we think were
sort of unique about O3D.

00:01:02.901 --> 00:01:04.901
And in the second part,
Gregg will take over

00:01:04.901 --> 00:01:07.567
and we'll actually show you how,
in about 20 minutes,

00:01:07.567 --> 00:01:09.868
you can make
a little game application.

00:01:09.868 --> 00:01:11.267
So that--that should be fun.

00:01:11.267 --> 00:01:14.100
And...

00:01:14.100 --> 00:01:16.434
hopefully it will be good
for you guys too.

00:01:16.434 --> 00:01:19.601
So...O3D.

00:01:19.601 --> 00:01:21.701
O3D, as you probably know,

00:01:21.701 --> 00:01:25.634
is a JavaScript API for
doing GPU accelerated graphics

00:01:25.634 --> 00:01:28.601
inside--
inside a web page.

00:01:28.601 --> 00:01:32.234
Right now,
O3D is a plugin for--

00:01:32.234 --> 00:01:36.000
oh, was I talking
without slides? Okay.

00:01:36.000 --> 00:01:37.434
[chuckles]

00:01:37.434 --> 00:01:40.467
O3D is a plugin
for all major browsers,

00:01:40.467 --> 00:01:44.167
including IE, by the way,

00:01:44.167 --> 00:01:47.434
so...and runs in all
major operating systems.

00:01:47.434 --> 00:01:49.033
Right now, like I said,
it's a plugin,

00:01:49.033 --> 00:01:51.534
but we're hoping
that it will be integrated

00:01:51.534 --> 00:01:55.434
more closely inside the browser
starting with Chrome in first.

00:01:55.434 --> 00:01:57.868
What kind of applications
you can run with O3D--

00:01:57.868 --> 00:02:00.200
it's really entirely
up to you guys.

00:02:00.200 --> 00:02:01.834
If you go
to our website,

00:02:01.834 --> 00:02:03.734
you're gonna see a few samples
of applications--

00:02:03.734 --> 00:02:07.567
things that we thought were
sort of interesting to do in 3D.

00:02:07.567 --> 00:02:09.601
You know,
the obvious ones are games.

00:02:09.601 --> 00:02:12.033
Data visualization
is another type.

00:02:12.033 --> 00:02:13.467
You know, the--
sort of the type of,

00:02:13.467 --> 00:02:15.601
you know, Google Earth,
displaying data on a map,

00:02:15.601 --> 00:02:17.200
stuff like that.

00:02:17.200 --> 00:02:20.767
Other sort of 3D scenes
and modeling sort of tools

00:02:20.767 --> 00:02:23.834
and tools that allow you to
sort of spin around 3D models--

00:02:23.834 --> 00:02:26.267
you know,
these are obvious examples.

00:02:26.267 --> 00:02:28.067
But--but in reality,
you know,

00:02:28.067 --> 00:02:31.868
any application that you
can currently do natively

00:02:31.868 --> 00:02:33.267
with 3D graphics

00:02:33.267 --> 00:02:36.968
you can probably do with O3D
and run it inside your browser.

00:02:36.968 --> 00:02:39.601
Before we go into details
with the API,

00:02:39.601 --> 00:02:41.434
I think it would be a good idea
to sort of tell you

00:02:41.434 --> 00:02:43.033
a little bit about
the goals that we had

00:02:43.033 --> 00:02:45.267
when we were designing
the API.

00:02:45.267 --> 00:02:47.133
The first goal is
we wanted something

00:02:47.133 --> 00:02:48.834
that's--that's
really expressive,

00:02:48.834 --> 00:02:52.501
so we were really sort of--
we wanted...

00:02:52.501 --> 00:02:55.334
the idea behind O3D
was it needed to be an API

00:02:55.334 --> 00:02:57.968
that would be capable of doing
sort of complex rendering.

00:02:57.968 --> 00:03:00.734
And if you think of complex
rendering, 3D rendering,

00:03:00.734 --> 00:03:02.634
your mind typically goes
into video games.

00:03:02.634 --> 00:03:04.067
So video games
are sort of--

00:03:04.067 --> 00:03:06.567
probably the most complex
3D apps that you find today.

00:03:06.567 --> 00:03:08.033
So we wanted
to design an API

00:03:08.033 --> 00:03:10.801
that's capable of handling
that level of complexity.

00:03:10.801 --> 00:03:12.267
We wanted something
that you can create

00:03:12.267 --> 00:03:15.634
really sort of complex
rendering worlds,

00:03:15.634 --> 00:03:17.300
multi-pass effects,
you know,

00:03:17.300 --> 00:03:19.167
doing reflections,

00:03:19.167 --> 00:03:21.434
nice shaders
in your objects,

00:03:21.434 --> 00:03:23.033
stuff like that.

00:03:23.033 --> 00:03:24.767
We know that we're running
inside a browser

00:03:24.767 --> 00:03:27.400
so performance
is a major concern--

00:03:27.400 --> 00:03:28.534
was a major concern for us.

00:03:28.534 --> 00:03:30.267
So we made--
we took several steps

00:03:30.267 --> 00:03:33.400
to make sure that our API is
really performing

00:03:33.400 --> 00:03:35.501
for cases where you have
really large scenes

00:03:35.501 --> 00:03:36.968
with a lot of objects--
which are, you know,

00:03:36.968 --> 00:03:38.934
typically hard to do

00:03:38.934 --> 00:03:40.367
in an environment
like the browser.

00:03:40.367 --> 00:03:43.267
The second goal
that we had

00:03:43.267 --> 00:03:45.868
was--was we wanted to make
an API that's really flexible.

00:03:45.868 --> 00:03:47.534
We really didn't want
to make any assumptions

00:03:47.534 --> 00:03:50.033
that we're making an API
specifically for making games

00:03:50.033 --> 00:03:52.334
or for making other types
of applications.

00:03:52.334 --> 00:03:54.334
We really wanted
a fairly low-level API

00:03:54.334 --> 00:03:56.033
that would allow you to do
pretty much anything

00:03:56.033 --> 00:03:59.234
you wanted to do with
3D graphics in the browser.

00:03:59.234 --> 00:04:02.634
And finally, we're really
big believers

00:04:02.634 --> 00:04:04.334
in the--
in the "one web" idea.

00:04:04.334 --> 00:04:07.334
We wanted, really,
the applications that you write

00:04:07.334 --> 00:04:09.667
to be able to run
exactly the same way,

00:04:09.667 --> 00:04:11.868
if possible,
on all browsers

00:04:11.868 --> 00:04:14.000
or operating systems.

00:04:14.000 --> 00:04:16.767
This is both for the benefit
of the developers--

00:04:16.767 --> 00:04:20.033
so you as a developer can
just sit down on your machine

00:04:20.033 --> 00:04:22.467
and write--
write an application

00:04:22.467 --> 00:04:24.167
and sort of be sure
that it's going to run

00:04:24.167 --> 00:04:25.467
on everybody else's machine

00:04:25.467 --> 00:04:26.767
and they're going to have
the same experience

00:04:26.767 --> 00:04:28.267
as you're having
when you're looking at it.

00:04:28.267 --> 00:04:29.968
But also from
the user's perspective--

00:04:29.968 --> 00:04:31.534
in that, you know,
when you go to a website

00:04:31.534 --> 00:04:32.701
that has O3D content

00:04:32.701 --> 00:04:34.200
you want to be sure
that it actually works.

00:04:34.200 --> 00:04:36.801
The way we did that is we--
we sort of decided

00:04:36.801 --> 00:04:39.267
early on in a spec
of graphics hardware

00:04:39.267 --> 00:04:41.033
that we decided to support--

00:04:41.033 --> 00:04:43.634
and we said whatever--
whatever is capable of running

00:04:43.634 --> 00:04:45.300
on that hardware is good

00:04:45.300 --> 00:04:46.667
and it's going to run
GPU accelerated.

00:04:46.667 --> 00:04:49.734
Everything below that,
we have a fallback plan

00:04:49.734 --> 00:04:53.667
which is going to be
running itself to render.

00:04:53.667 --> 00:04:55.434
But regardless of the case,

00:04:55.434 --> 00:04:57.434
you're actually going to see
the same images

00:04:57.434 --> 00:05:00.000
rendering in your browser.

00:05:00.000 --> 00:05:02.133
Having said that,

00:05:02.133 --> 00:05:04.200
it's--this is a list

00:05:04.200 --> 00:05:06.200
of a few of the
sort of feature highlights.

00:05:06.200 --> 00:05:08.367
Obviously the API
is fairly big,

00:05:08.367 --> 00:05:10.467
and there's a lot of features.

00:05:10.467 --> 00:05:13.734
But these are features that
are important to remember.

00:05:13.734 --> 00:05:15.033
First of all,
like I said,

00:05:15.033 --> 00:05:16.734
we wanted to provide
a very flexible API.

00:05:16.734 --> 00:05:18.167
So we really give you

00:05:18.167 --> 00:05:20.501
very--fairly low-level access
to the graphics hardware.

00:05:20.501 --> 00:05:23.834
So we allow you to write
your own shader programs

00:05:23.834 --> 00:05:27.767
using HLSL and Cg
as the shading language,

00:05:27.767 --> 00:05:29.434
which gives you,
really, full access

00:05:29.434 --> 00:05:31.367
to modern graphics hardware.

00:05:31.367 --> 00:05:33.968
We also have the API
in such a way

00:05:33.968 --> 00:05:36.667
that you can--you can do
modern rendering effects

00:05:36.667 --> 00:05:37.901
like multi-pass rendering.

00:05:37.901 --> 00:05:39.934
For example,
you can render an entire scene

00:05:39.934 --> 00:05:41.534
in--into an offscreen buffer,

00:05:41.534 --> 00:05:43.968
and then take that buffer
and use it for something else.

00:05:43.968 --> 00:05:46.033
And this allows you to do
more complex effects,

00:05:46.033 --> 00:05:48.701
like if you wanted
to do motion blurs,

00:05:48.701 --> 00:05:50.968
depth of field effects,
stuff like that.

00:05:50.968 --> 00:05:53.434
So this is all possible
with the API.

00:05:53.434 --> 00:05:55.534
We give you full control
over the render states

00:05:55.534 --> 00:05:57.534
so you have, you know,
very fine-grain control

00:05:57.534 --> 00:05:59.567
over how you do blending,

00:05:59.567 --> 00:06:00.868
things like that.

00:06:00.868 --> 00:06:03.434
We also expose image loaders

00:06:03.434 --> 00:06:05.567
beyond what the browser
actually supports.

00:06:05.567 --> 00:06:09.000
So we load a few
compressed formats

00:06:09.000 --> 00:06:10.701
that support levels
of detail as well.

00:06:10.701 --> 00:06:14.067
You can load them
directly in O3D.

00:06:14.067 --> 00:06:16.667
And I think that we've
implemented within O3D--

00:06:16.667 --> 00:06:18.234
which is sort of--
escapes a little bit

00:06:18.234 --> 00:06:20.000
from the--from
the typical rendering

00:06:20.000 --> 00:06:21.234
side of things--

00:06:21.234 --> 00:06:23.400
is we added
a fairly low-level animation

00:06:23.400 --> 00:06:24.734
and skinning system

00:06:24.734 --> 00:06:27.334
which would allow you
to do animated characters

00:06:27.334 --> 00:06:29.634
within your application
fairly easily.

00:06:29.634 --> 00:06:31.067
You can author them
somewhere else

00:06:31.067 --> 00:06:32.934
and have them exported
and have them running

00:06:32.934 --> 00:06:35.367
in O3D
with very little effort.

00:06:35.367 --> 00:06:37.234
And this is something
that we wanted to do

00:06:37.234 --> 00:06:39.801
natively inside
the actual plugin

00:06:39.801 --> 00:06:41.801
because we thought and--
well, we still believe

00:06:41.801 --> 00:06:44.567
that JavaScript is probably
still not fast enough

00:06:44.567 --> 00:06:46.400
to do some of these things
that are necessary,

00:06:46.400 --> 00:06:49.901
some of the calculations
that are necessary for that.

00:06:49.901 --> 00:06:52.000
We know that
different browsers

00:06:52.000 --> 00:06:54.734
have different performance
in terms of JavaScript.

00:06:54.734 --> 00:06:56.701
So while JavaScript

00:06:56.701 --> 00:06:58.901
is generally getting faster
in old browsers,

00:06:58.901 --> 00:07:00.367
there's still a big disconnect

00:07:00.367 --> 00:07:02.667
between various
browser implementations.

00:07:02.667 --> 00:07:05.367
So--and we realized that
fairly early on.

00:07:05.367 --> 00:07:06.701
So what we ended up doing

00:07:06.701 --> 00:07:09.100
is we--we actually embedded
Chrome's V8 engine,

00:07:09.100 --> 00:07:12.367
which is one of the fastest
JavaScript engines around,

00:07:12.367 --> 00:07:13.701
within the O3D plugin--

00:07:13.701 --> 00:07:15.234
which means that
you can select

00:07:15.234 --> 00:07:16.634
whether you want to run
your code

00:07:16.634 --> 00:07:19.367
inside
the embedded V8 engine--

00:07:19.367 --> 00:07:20.934
so you're going to get
the same performance

00:07:20.934 --> 00:07:23.133
on the same PC regardless
of the browser you're running--

00:07:23.133 --> 00:07:24.567
or whether
you want to run it

00:07:24.567 --> 00:07:26.667
inside the browser's
JavaScript engine.

00:07:26.667 --> 00:07:28.033
So you have this option to do.

00:07:28.033 --> 00:07:32.100
And finally...
we also opened an API

00:07:32.100 --> 00:07:35.133
that allows you to--
to import assets,

00:07:35.133 --> 00:07:37.367
3D assets,
in the browser.

00:07:37.367 --> 00:07:38.567
That's based on JSON.

00:07:38.567 --> 00:07:41.033
I'm going to say
a little bit more about that

00:07:41.033 --> 00:07:42.300
pretty soon.

00:07:42.300 --> 00:07:45.067
So...really quickly,

00:07:45.067 --> 00:07:47.200
just to give you
an idea about APIs,

00:07:47.200 --> 00:07:49.934
typically graphics APIs fall
into one of two categories:

00:07:49.934 --> 00:07:51.400
there's
immediate mode APIs,

00:07:51.400 --> 00:07:53.901
in which graphics commands
are executed sort of immediately

00:07:53.901 --> 00:07:55.701
as you--
as you enter them,

00:07:55.701 --> 00:07:57.901
and--and...

00:07:57.901 --> 00:07:59.901
the side effect
of immediate mode APIs

00:07:59.901 --> 00:08:01.334
is that if you have a frame

00:08:01.334 --> 00:08:03.467
and you want to sort of change
something inside the frame,

00:08:03.467 --> 00:08:04.934
you really need to redraw
the entire frame.

00:08:04.934 --> 00:08:06.100
So you're going
to need to draw

00:08:06.100 --> 00:08:07.567
everything
that's in the frame.

00:08:07.567 --> 00:08:09.667
Typical examples
of immediate mode APIs

00:08:09.667 --> 00:08:11.434
are, you know,
Direct3D and OpenGL,

00:08:11.434 --> 00:08:12.734
which are the low-level APIs

00:08:12.734 --> 00:08:15.167
that are used
for rendering natively.

00:08:15.167 --> 00:08:17.434
But also if you think
in the HTML world,

00:08:17.434 --> 00:08:19.167
the Canvas--
the Canvas 2D surface

00:08:19.167 --> 00:08:20.501
is an immediate mode API.

00:08:20.501 --> 00:08:21.767
On the other side
of the spectrum,

00:08:21.767 --> 00:08:23.634
you have retained mode APIs,

00:08:23.634 --> 00:08:25.534
where instead of actually
issuing the draw commands

00:08:25.534 --> 00:08:26.934
one after the other,

00:08:26.934 --> 00:08:28.133
you actually describe,
first,

00:08:28.133 --> 00:08:30.400
the objects that
you want to render.

00:08:30.400 --> 00:08:32.067
There's typically some sort
of a scene graph structure

00:08:32.067 --> 00:08:34.267
that's associated there.

00:08:34.267 --> 00:08:35.634
And there,
the high-level information

00:08:35.634 --> 00:08:37.067
is retained between frames,

00:08:37.067 --> 00:08:40.234
which means that the actual
system can redraw your frames

00:08:40.234 --> 00:08:42.334
without you having
to execute code--

00:08:42.334 --> 00:08:43.734
adding on the code
that you need

00:08:43.734 --> 00:08:45.667
in order to sort of
make whatever changes

00:08:45.667 --> 00:08:47.901
you need to make
from one frame to the next.

00:08:47.901 --> 00:08:49.634
And typical examples
of that are, you know,

00:08:49.634 --> 00:08:53.100
most game engines fall in
the retained mode API category.

00:08:53.100 --> 00:08:57.033
In the HTML world,
SVG is a retained mode API.

00:08:57.033 --> 00:08:59.133
And, you know, the entire
sort of HTML DOM--

00:08:59.133 --> 00:09:00.734
you can think of it
as a retained mode API

00:09:00.734 --> 00:09:03.000
where you describe
the page contents first

00:09:03.000 --> 00:09:05.701
and the browser knows how
to render the entire page.

00:09:05.701 --> 00:09:07.267
And to make this
a little bit more concrete,

00:09:07.267 --> 00:09:09.167
imagine you have this example
where you, you know,

00:09:09.167 --> 00:09:10.467
you have
the very simple scene.

00:09:10.467 --> 00:09:12.300
You have, you know, red sphere
that you wanted to move

00:09:12.300 --> 00:09:13.868
to the right
over time

00:09:13.868 --> 00:09:16.133
and a green square
that stays constant.

00:09:16.133 --> 00:09:18.367
If you were to use
immediate mode,

00:09:18.367 --> 00:09:20.133
what you would
have to do mostly is,

00:09:20.133 --> 00:09:22.234
in every frame, you would have
to execute commands

00:09:22.234 --> 00:09:24.100
to draw everything--the
contents of the entire scene.

00:09:24.100 --> 00:09:25.534
So you have to clear it,

00:09:25.534 --> 00:09:26.968
move your cursor
to position,

00:09:26.968 --> 00:09:28.934
set your color,
draw the circle,

00:09:28.934 --> 00:09:30.300
then move to
a different position,

00:09:30.300 --> 00:09:32.234
set the new color to green,

00:09:32.234 --> 00:09:35.100
draw a square,
and repeat that process

00:09:35.100 --> 00:09:36.767
for every frame.

00:09:36.767 --> 00:09:38.567
Now, if you look at
the retained mode API,

00:09:38.567 --> 00:09:39.834
the process
is a little simpler.

00:09:39.834 --> 00:09:41.334
So a lot of the code
actually moves

00:09:41.334 --> 00:09:43.300
to the initialization step

00:09:43.300 --> 00:09:45.367
in which you create
some higher-level constructs

00:09:45.367 --> 00:09:47.367
where you say,
"I have a circle that's red

00:09:47.367 --> 00:09:48.801
"then a square that's green.

00:09:48.801 --> 00:09:51.100
"I know that the square
is not going to move anywhere

00:09:51.100 --> 00:09:53.033
so I'm going to set it
in a specific position."

00:09:53.033 --> 00:09:55.100
And then all you have to do
each frame

00:09:55.100 --> 00:09:57.834
is actually move the circle,

00:09:57.834 --> 00:09:59.067
set the new position
of the circle,

00:09:59.067 --> 00:10:00.868
and--and repeat that.

00:10:00.868 --> 00:10:04.601
And the actual system
will be able to redraw itself.

00:10:04.601 --> 00:10:05.934
Why this is important--

00:10:05.934 --> 00:10:07.634
the difference between
these two approaches--

00:10:07.634 --> 00:10:10.367
is that the stuff that
you see in the green box

00:10:10.367 --> 00:10:13.267
is actually stuff that would
be running in JavaScript.

00:10:13.267 --> 00:10:15.934
So if you were running
at a really fast frame rate--

00:10:15.934 --> 00:10:17.267
say 60 frames a second,

00:10:17.267 --> 00:10:19.467
which is sort of
a common frame rate

00:10:19.467 --> 00:10:20.834
for an interactive
application--

00:10:20.834 --> 00:10:22.067
you have 16 milliseconds

00:10:22.067 --> 00:10:24.133
to issue all these--
all these draw calls.

00:10:24.133 --> 00:10:25.434
Imagine a scene
that has, you know,

00:10:25.434 --> 00:10:26.834
hundreds and hundreds
of objects.

00:10:26.834 --> 00:10:29.334
It's going to be hard to
actually execute all that code

00:10:29.334 --> 00:10:31.701
and still have time
to do your application logic.

00:10:31.701 --> 00:10:33.734
So in some cases
retained mode API

00:10:33.734 --> 00:10:36.167
is advantageous
in terms of performance.

00:10:36.167 --> 00:10:38.000
So--so where does
O3D fall in?

00:10:38.000 --> 00:10:40.834
It's--O3D is really
a low-level retained mode API.

00:10:40.834 --> 00:10:42.767
That's the way
we want to think of it.

00:10:42.767 --> 00:10:44.501
It has a lot
of the flexibility

00:10:44.501 --> 00:10:46.334
of immediate mode API,

00:10:46.334 --> 00:10:48.868
but a lot of the performance
critical aspects of rendering,

00:10:48.868 --> 00:10:51.734
like z-sort
and forgetting transparency--

00:10:51.734 --> 00:10:53.334
so the transparency
correcting,

00:10:53.334 --> 00:10:54.901
doing culling, animation,
all that--

00:10:54.901 --> 00:10:56.567
are executed
in native code.

00:10:56.567 --> 00:10:59.000
And if you look
at the spectrum of APIs,

00:10:59.000 --> 00:11:00.334
if you look at the far left,

00:11:00.334 --> 00:11:01.801
there's OpenGL and D3D,

00:11:01.801 --> 00:11:03.968
which is definitely sort of
the lowest level API

00:11:03.968 --> 00:11:05.234
that you see.

00:11:05.234 --> 00:11:07.234
O3D really falls
very close to that

00:11:07.234 --> 00:11:09.067
as opposed to the other end
of the spectrum

00:11:09.067 --> 00:11:11.367
where you have the game engines
that are super high-level.

00:11:11.367 --> 00:11:13.033
And sort of
somewhere in the middle

00:11:13.033 --> 00:11:14.467
but more towards
the right side

00:11:14.467 --> 00:11:17.701
is the full-fledged
scene graphs like...

00:11:17.701 --> 00:11:20.734
stuff that you see, like,
say the Ogre API,

00:11:20.734 --> 00:11:22.133
stuff like that...

00:11:22.133 --> 00:11:23.767
that definitely
have a lot more

00:11:23.767 --> 00:11:25.300
sort of higher-level
features that--

00:11:25.300 --> 00:11:27.434
collision detection,
potentially physics,

00:11:27.434 --> 00:11:28.767
stuff like that.

00:11:28.767 --> 00:11:31.834
O3D is definitely
a lot more low-level.

00:11:31.834 --> 00:11:34.634
Stuff that you see in O3D,
like I mentioned before,

00:11:34.634 --> 00:11:37.801
typically a retained mode API
has some sort of hierarchy.

00:11:37.801 --> 00:11:40.334
You're going to see in O3D
two types of graphs:

00:11:40.334 --> 00:11:41.667
You're going to see
the transform graph,

00:11:41.667 --> 00:11:42.934
which is sort of
a typical graph

00:11:42.934 --> 00:11:44.200
that you see
in scene graphs,

00:11:44.200 --> 00:11:45.567
where you have
a bunch of, you know,

00:11:45.567 --> 00:11:46.901
transforms
that describe the--

00:11:46.901 --> 00:11:48.901
where the--where your objects
get rendered

00:11:48.901 --> 00:11:50.601
and also the--the shapes

00:11:50.601 --> 00:11:52.267
which are the actual mashups
that get rendered.

00:11:52.267 --> 00:11:53.934
The shapes in our world,

00:11:53.934 --> 00:11:55.467
because we are
fully shader based,

00:11:55.467 --> 00:11:58.067
they get associated
with materials and effects

00:11:58.067 --> 00:11:59.467
that contain
the shader code.

00:11:59.467 --> 00:12:02.601
But--but this is a pretty,
you know, common structure

00:12:02.601 --> 00:12:04.400
that you see
in scene graph APIs.

00:12:04.400 --> 00:12:06.300
What is a bit novel
about O3D

00:12:06.300 --> 00:12:07.934
is a different type
of graph that we have

00:12:07.934 --> 00:12:09.968
which is called a rendergraph.

00:12:09.968 --> 00:12:11.701
And the rendergraph
is really the recipe

00:12:11.701 --> 00:12:14.033
for drawing 3D objects.

00:12:14.033 --> 00:12:15.267
Like I said before,

00:12:15.267 --> 00:12:17.667
we wanted to allow
a more complicated effect,

00:12:17.667 --> 00:12:19.934
like doing multi-pass rendering,
stuff like that.

00:12:19.934 --> 00:12:22.701
That--in order to describe
that kind of rendering,

00:12:22.701 --> 00:12:24.400
we needed a different
data structure

00:12:24.400 --> 00:12:26.400
from the data structure that
actually holds the objects.

00:12:26.400 --> 00:12:28.567
And if you look at this,
this is just an example

00:12:28.567 --> 00:12:30.267
of a typical rendergraph

00:12:30.267 --> 00:12:33.934
that has both trans--
transparent and opaque pass.

00:12:33.934 --> 00:12:36.300
But typically
what O3D will do

00:12:36.300 --> 00:12:38.567
is it will parse this--
will traverse this graph

00:12:38.567 --> 00:12:41.000
from sort of top to bottom,
left to right,

00:12:41.000 --> 00:12:43.534
and will issue
rendering commands,

00:12:43.534 --> 00:12:44.801
you know,
based on the node.

00:12:44.801 --> 00:12:46.000
I'm not going
to go into detail

00:12:46.000 --> 00:12:47.367
about what
really happens in there,

00:12:47.367 --> 00:12:48.534
but I thought
that will give you an idea

00:12:48.534 --> 00:12:51.234
of what you'll find
in a rendergraph

00:12:51.234 --> 00:12:53.767
because Gregg is going
to mention rendergraphs

00:12:53.767 --> 00:12:55.968
a little bit later on
in his part.

00:12:55.968 --> 00:13:00.234
So as far as the experience
with programming with O3D,

00:13:00.234 --> 00:13:03.501
the actual API is a fairly
low-level 3D graphics API.

00:13:03.501 --> 00:13:06.634
So you'll definitely do a lot
better programming with O3D

00:13:06.634 --> 00:13:09.834
if you have some experience
with 3D graphics APIs

00:13:09.834 --> 00:13:11.701
like OpenGL and Direct3D.

00:13:11.701 --> 00:13:13.767
In order to make things
a little simpler

00:13:13.767 --> 00:13:15.033
for those of you

00:13:15.033 --> 00:13:16.767
who don't necessarily
have that experience,

00:13:16.767 --> 00:13:18.934
we've provided
a fairly comprehensive set

00:13:18.934 --> 00:13:20.834
of JavaScript
utility libraries

00:13:20.834 --> 00:13:22.701
that do certain things
a lot easier.

00:13:22.701 --> 00:13:24.000
So with a one--single call,

00:13:24.000 --> 00:13:26.400
you can create common perimeters
like cubes, figures,

00:13:26.400 --> 00:13:27.901
you know, cylinders,
like that.

00:13:27.901 --> 00:13:30.100
You can create
simple particle effects.

00:13:30.100 --> 00:13:32.133
You can create shaders.

00:13:32.133 --> 00:13:35.300
You can load--
you can stream in files

00:13:35.300 --> 00:13:37.300
with assets,
things like that.

00:13:37.300 --> 00:13:39.868
The utilities are not really
part of the API

00:13:39.868 --> 00:13:42.901
but are there
to make your job easier.

00:13:42.901 --> 00:13:44.934
And also,
they serve as very--

00:13:44.934 --> 00:13:46.767
very good sort of sample code.

00:13:46.767 --> 00:13:48.834
So you can use them,
you can change them

00:13:48.834 --> 00:13:51.834
to fit your needs
if they don't fit your needs.

00:13:51.834 --> 00:13:53.701
Finally, we expect that,
over time,

00:13:53.701 --> 00:13:55.234
there's going to be
higher-level libraries

00:13:55.234 --> 00:13:58.367
that will be developed
on top of all that

00:13:58.367 --> 00:14:01.167
that will make the task
of writing O3D applications

00:14:01.167 --> 00:14:05.334
a lot easier for
more developers, actually.

00:14:05.334 --> 00:14:07.033
So having said all that,

00:14:07.033 --> 00:14:09.467
you know, an O3D application
typically breaks down

00:14:09.467 --> 00:14:10.934
into two things:
There's the code,

00:14:10.934 --> 00:14:13.067
which is sort of--
sets up all the rendering.

00:14:13.067 --> 00:14:15.067
It contains sort of
the application logic

00:14:15.067 --> 00:14:16.634
and you see a lot of code

00:14:16.634 --> 00:14:18.267
in the second part
of this presentation.

00:14:18.267 --> 00:14:20.000
And then there's
the asset part,

00:14:20.000 --> 00:14:21.834
which is really
all the 3D assets that you need

00:14:21.834 --> 00:14:25.267
in order to render texture,
shaders, animation,

00:14:25.267 --> 00:14:26.367
stuff like that.

00:14:26.367 --> 00:14:27.734
And while
we're on this topic,

00:14:27.734 --> 00:14:30.367
I thought I'd say
something about assets.

00:14:30.367 --> 00:14:32.133
So--so with O3D,

00:14:32.133 --> 00:14:36.033
we decided to not invent
yet another file format.

00:14:36.033 --> 00:14:37.968
There's tons of file formats
for 3D stuff.

00:14:37.968 --> 00:14:40.701
Unfortunately,
none of them really...

00:14:40.701 --> 00:14:43.868
we thought, was a particularly
good fit for O3D.

00:14:43.868 --> 00:14:47.434
So what we did is we decided not
to create yet another format,

00:14:47.434 --> 00:14:48.701
'cause at this point,
like I said,

00:14:48.701 --> 00:14:51.467
we wanted to--this format
to be very flexible

00:14:51.467 --> 00:14:52.701
in the sense that
we don't really know

00:14:52.701 --> 00:14:54.234
what kind of application
you're creating.

00:14:54.234 --> 00:14:56.133
So we don't want
to create a file format

00:14:56.133 --> 00:14:57.934
that sort of
describes something

00:14:57.934 --> 00:14:59.567
that we don't know about.

00:14:59.567 --> 00:15:01.601
But what we did is
we created an API

00:15:01.601 --> 00:15:04.133
that allows you
to load in the browser

00:15:04.133 --> 00:15:05.634
these zipped archive files.

00:15:05.634 --> 00:15:07.234
And these
zipped archive files

00:15:07.234 --> 00:15:10.167
can contain, you know,
generally three different types

00:15:10.167 --> 00:15:11.334
of files.

00:15:11.334 --> 00:15:12.567
They can contain text files.

00:15:12.567 --> 00:15:14.767
They can contain
image files

00:15:14.767 --> 00:15:18.567
and binary objects,
binary buffer files.

00:15:18.567 --> 00:15:22.234
Yeah, a typical application--
for example,

00:15:22.234 --> 00:15:25.033
if you have sort of a general
sort of rendering task

00:15:25.033 --> 00:15:27.234
that you wanted to bring
in a whole scene,

00:15:27.234 --> 00:15:30.501
you would probably describe
the contents of the scene

00:15:30.501 --> 00:15:32.834
in JSON format and
store that in a text file.

00:15:32.834 --> 00:15:35.133
You would put all your textures
in image files

00:15:35.133 --> 00:15:37.567
inside the same--
the same archive.

00:15:37.567 --> 00:15:39.334
And finally,
all the heavy data,

00:15:39.334 --> 00:15:42.801
like, for example...
vertex buffers, index buffers,

00:15:42.801 --> 00:15:46.234
animation, all that
would go into binary buffers.

00:15:46.234 --> 00:15:47.834
So once you zip all that--

00:15:47.834 --> 00:15:49.501
and that's a process
that you do offline--

00:15:49.501 --> 00:15:52.133
the application requests
that file from the server,

00:15:52.133 --> 00:15:54.534
the server sends it,
and streams it, actually,

00:15:54.534 --> 00:15:57.000
and then the application
can extract the data

00:15:57.000 --> 00:15:58.300
from the file
and can then

00:15:58.300 --> 00:16:03.267
start calling
the regular O3D--O3D calls

00:16:03.267 --> 00:16:04.734
in order to actually
create the objects.

00:16:04.734 --> 00:16:06.000
And this is a fairly--

00:16:06.000 --> 00:16:07.567
we found that this is
a fairly flexible approach

00:16:07.567 --> 00:16:11.167
to--to transferring
any kind of data you want.

00:16:11.167 --> 00:16:12.467
But, you know,
having said that,

00:16:12.467 --> 00:16:13.634
this is a bit abstract.

00:16:13.634 --> 00:16:15.701
In reality, a lot of
the 3D applications

00:16:15.701 --> 00:16:17.434
really, you know,
require, you know,

00:16:17.434 --> 00:16:19.501
general models with
textures and all that.

00:16:19.501 --> 00:16:21.033
And in order
to give you a leg up

00:16:21.033 --> 00:16:22.267
in that process,

00:16:22.267 --> 00:16:25.434
we decided to write...

00:16:25.434 --> 00:16:28.434
really a sample,
which is a converter

00:16:28.434 --> 00:16:29.868
that takes a Collada file,

00:16:29.868 --> 00:16:32.133
which is an XML representation
of a 3D world.

00:16:32.133 --> 00:16:34.634
Collada files
can be exported

00:16:34.634 --> 00:16:37.267
from most of
the DCC tools today,

00:16:37.267 --> 00:16:40.400
like, Maya, Max...
Google SketchUp.

00:16:40.400 --> 00:16:43.133
So you use the exporter
from the DCC tool

00:16:43.133 --> 00:16:45.167
in order to create
a Collada file.

00:16:45.167 --> 00:16:47.601
Then you use
the O3D converter--

00:16:47.601 --> 00:16:52.534
[microphone cuts out]

00:16:59.067 --> 00:17:05.400
Okay?
Cool.

00:17:05.400 --> 00:17:07.133
[audience chuckles]

00:17:14.701 --> 00:17:17.534
Hello?
Okay. Cool.

00:17:17.534 --> 00:17:21.100
So we have we have a tool
that shapes with the O3D SDK

00:17:21.100 --> 00:17:22.634
that really is a converter.

00:17:22.634 --> 00:17:24.567
It takes a Collada file
and zips, you know,

00:17:24.567 --> 00:17:26.868
converts all the contents
to this zip archived format

00:17:26.868 --> 00:17:28.801
that I talked about
right before.

00:17:28.801 --> 00:17:30.801
And then, at the same time,
we have a sample library,

00:17:30.801 --> 00:17:32.367
a JavaScript library,

00:17:32.367 --> 00:17:33.634
that is able to load this file

00:17:33.634 --> 00:17:36.901
and create the O3D content
that you have.

00:17:36.901 --> 00:17:41.033
So if you look into
the O3D SDK,

00:17:41.033 --> 00:17:43.033
you're gonna find--
you're gonna find this tool.

00:17:43.033 --> 00:17:44.601
And actually,
in Gregg's part--

00:17:44.601 --> 00:17:46.400
which is about
to start right now--

00:17:46.400 --> 00:17:48.634
he's going to be
making use of this...

00:17:48.634 --> 00:17:50.834
to load content
in the application.

00:17:54.934 --> 00:18:03.167
Tavares:
[inaudible]

00:18:03.167 --> 00:18:07.934
Switch...

00:18:07.934 --> 00:18:12.534
[indistinct chatter]

00:18:12.534 --> 00:18:15.934
There?

00:18:15.934 --> 00:18:20.467
Up higher?

00:18:20.467 --> 00:18:23.200
Hello?
Testing. Okay.

00:18:23.200 --> 00:18:26.100
So we're going to go over
making an O3D application.

00:18:26.100 --> 00:18:28.934
This is just kind of
a small, sample start of a game.

00:18:28.934 --> 00:18:30.534
It's not, like,
a really cool game.

00:18:30.534 --> 00:18:31.934
But we'll go over
all the steps,

00:18:31.934 --> 00:18:34.501
and hopefully a few days
after the show

00:18:34.501 --> 00:18:36.033
we'll be able
to put them online.

00:18:36.033 --> 00:18:38.968
A few things we'll probably
have to fix, but...

00:18:38.968 --> 00:18:42.234
they are here live.

00:18:42.234 --> 00:18:43.667
So the first thing
you have to do

00:18:43.667 --> 00:18:45.734
is, like they said, the O3D
runs in a web page.

00:18:45.734 --> 00:18:47.234
So you need to set up
a web page.

00:18:47.234 --> 00:18:50.100
So normally you would
have a few script tags.

00:18:50.100 --> 00:18:53.467
In our case,
we have our sample library.

00:18:53.467 --> 00:18:55.400
We include this script
called base.js

00:18:55.400 --> 00:18:57.667
and that kind of gives us
an include facility

00:18:57.667 --> 00:18:59.234
for including
other modules.

00:18:59.234 --> 00:19:01.234
And you can see here
where we're requiring

00:19:01.234 --> 00:19:04.701
the module util
and the module math.

00:19:04.701 --> 00:19:06.167
Then you have your body.

00:19:06.167 --> 00:19:09.801
And you see we have the onload
set to call an init function.

00:19:09.801 --> 00:19:11.901
And then,
because it's a plugin,

00:19:11.901 --> 00:19:13.734
normally it would run
as an object tag.

00:19:13.734 --> 00:19:17.934
But object tags
are kind of iffy in the sense

00:19:17.934 --> 00:19:19.634
that different browsers
implement them different ways.

00:19:19.634 --> 00:19:21.634
So you can still do that
if you want,

00:19:21.634 --> 00:19:23.300
but our utility library

00:19:23.300 --> 00:19:25.501
instead looks for divs
that have an I.D.

00:19:25.501 --> 00:19:26.767
that starts with O3D,

00:19:26.767 --> 00:19:30.200
and it will insert
inside that div an object tag.

00:19:30.200 --> 00:19:33.000
And it will, you know,
scale to the size of that div--

00:19:33.000 --> 00:19:34.367
happens to be.

00:19:34.367 --> 00:19:36.167
So if you look at the next code,
here's the init function

00:19:36.167 --> 00:19:38.701
that that onload
was going to call.

00:19:38.701 --> 00:19:40.501
And it's going to call
this utility function

00:19:40.501 --> 00:19:42.100
called makeClients.

00:19:42.100 --> 00:19:43.534
It's an asynchronous function
that, again,

00:19:43.534 --> 00:19:45.334
has to do with
being cross-browser.

00:19:45.334 --> 00:19:46.834
Certain browsers
don't necessarily

00:19:46.834 --> 00:19:48.067
create the objects
the moment you ask for them.

00:19:48.067 --> 00:19:49.200
You have to keep pulling
until they

00:19:49.200 --> 00:19:51.734
actually have created them.

00:19:51.734 --> 00:19:52.934
So when
it's finally figured out

00:19:52.934 --> 00:19:54.434
that it's created
those objects,

00:19:54.434 --> 00:19:56.501
then it will call the function
that you've passed there--

00:19:56.501 --> 00:19:58.367
in this case, initstep2.

00:19:58.367 --> 00:20:00.734
initstep2 gets passed through
the list of all the el--

00:20:00.734 --> 00:20:02.267
the objects
that got created.

00:20:02.267 --> 00:20:03.734
In this case,
we only created one,

00:20:03.734 --> 00:20:05.267
so we know we're just gonna
pull that out of that array.

00:20:05.267 --> 00:20:07.834
And then we pull out
some globals here.

00:20:07.834 --> 00:20:09.400
The math is
our math library.

00:20:09.400 --> 00:20:11.868
That's just to make
our typing shorter.

00:20:11.868 --> 00:20:13.634
The client
is the based object,

00:20:13.634 --> 00:20:17.133
the object that
all the APIs start from.

00:20:17.133 --> 00:20:18.801
Then we create
this thing called a pack.

00:20:18.801 --> 00:20:20.934
A pack is something
that manages

00:20:20.934 --> 00:20:22.701
the lifetime of objects.

00:20:22.701 --> 00:20:23.968
And it's kind of hard
to go into the details

00:20:23.968 --> 00:20:26.334
but the basic way
to describe it

00:20:26.334 --> 00:20:28.267
is that all objects
are reference counted

00:20:28.267 --> 00:20:29.901
and the pack holds one count.

00:20:29.901 --> 00:20:32.033
So if you remove
something in pack,

00:20:32.033 --> 00:20:33.834
it loses that count of--
nothing else is referencing it

00:20:33.834 --> 00:20:35.434
and it'll finally
get deleted.

00:20:35.434 --> 00:20:37.033
The next thing we're gonna do
is we're gonna create

00:20:37.033 --> 00:20:38.701
a transform
for the transform graph

00:20:38.701 --> 00:20:40.167
and this is--we're--
gonna be our root transform.

00:20:40.167 --> 00:20:43.601
So everything from that and
below is gonna get rendered.

00:20:43.601 --> 00:20:46.133
And then we're gonna call
this utility function

00:20:46.133 --> 00:20:47.534
that will set up
a rendergraph--

00:20:47.534 --> 00:20:49.267
basically, the rendergraph
you saw in the slide

00:20:49.267 --> 00:20:50.467
a few moments ago.

00:20:50.467 --> 00:20:51.868
Of course you could
create it by hand,

00:20:51.868 --> 00:20:53.601
but it turns out
that for the--

00:20:53.601 --> 00:20:54.734
most of the cases
we have come up,

00:20:54.734 --> 00:20:57.667
this one routine
will create a rendergraph

00:20:57.667 --> 00:20:59.200
that handles
most of our cases.

00:20:59.200 --> 00:21:00.701
It passes back
this object called a--

00:21:00.701 --> 00:21:02.968
that we store
in this function called--

00:21:02.968 --> 00:21:04.300
or this variable
called g_viewInfo

00:21:04.300 --> 00:21:05.667
that we'll reference later.

00:21:05.667 --> 00:21:08.467
And you can see
we're passing in g_root,

00:21:08.467 --> 00:21:10.267
which says this is
the part that we want to render.

00:21:10.267 --> 00:21:12.067
And the bottom where it says

00:21:12.067 --> 00:21:13.701
g_client_renderGraphRoot

00:21:13.701 --> 00:21:16.067
is just attaching it
to the client's root

00:21:16.067 --> 00:21:17.334
so that it will actually

00:21:17.334 --> 00:21:19.601
traverse this rendergraph
for us.

00:21:19.601 --> 00:21:22.067
Then we need to make a--
set up a camera.

00:21:22.067 --> 00:21:23.901
We don't really have
something called a camera

00:21:23.901 --> 00:21:25.601
but we have view
and projection matrices

00:21:25.601 --> 00:21:28.501
for those who are familiar
with GL or D3D.

00:21:28.501 --> 00:21:30.167
So here
you can see the first--

00:21:30.167 --> 00:21:32.400
there's--we have a function
called updateProjection.

00:21:32.400 --> 00:21:35.434
And it's using
that viewInfo object,

00:21:35.434 --> 00:21:37.367
looking in this thing
called a drawContext,

00:21:37.367 --> 00:21:38.834
which is part
of the rendergraph,

00:21:38.834 --> 00:21:41.033
and setting the projection
matrix of that

00:21:41.033 --> 00:21:42.868
by calling
our math utility library

00:21:42.868 --> 00:21:44.300
that has a function
that will build

00:21:44.300 --> 00:21:46.634
a prospective matrix for you.

00:21:46.634 --> 00:21:48.934
And then there's
an updateCamera function

00:21:48.934 --> 00:21:52.901
that is using the look at
function from the math library

00:21:52.901 --> 00:21:55.868
to take an eye target
and an up vector

00:21:55.868 --> 00:21:59.434
and build a viewMatrix and
then set that into that context.

00:21:59.434 --> 00:22:02.734
So if we step over
to the sample--

00:22:02.734 --> 00:22:04.300
well, nothing's
going to come up yet

00:22:04.300 --> 00:22:05.734
'cause we haven't had any--
made any content,

00:22:05.734 --> 00:22:07.501
but this gray area
is the area

00:22:07.501 --> 00:22:11.267
that has been created
so far.

00:22:11.267 --> 00:22:12.901
So now we've got to put
something on the screen.

00:22:12.901 --> 00:22:15.601
So the first step: you need
to make some materials.

00:22:15.601 --> 00:22:17.567
Again, we're going to call
and do a utility function.

00:22:17.567 --> 00:22:19.701
The first one--it's going to
create just a basic material

00:22:19.701 --> 00:22:21.834
and we're going to set it
to a green color.

00:22:21.834 --> 00:22:24.534
And we're putting that
in this variable red material.

00:22:24.534 --> 00:22:26.100
Then we're also going to create
a checkered material.

00:22:26.100 --> 00:22:27.834
The checkered material
is actually going to load

00:22:27.834 --> 00:22:29.400
a shader from a file.

00:22:29.400 --> 00:22:31.667
The first function,
createBasicMaterial,

00:22:31.667 --> 00:22:33.400
actually generated a shader
in JavaScript.

00:22:33.400 --> 00:22:36.334
This one's gonna load one
from a file.

00:22:36.334 --> 00:22:38.133
And both of those
got created in this pack

00:22:38.133 --> 00:22:40.100
and so we're gonna--
the third part of this thing

00:22:40.100 --> 00:22:41.334
is we're gonna
call this function

00:22:41.334 --> 00:22:43.767
createAndBindStandardParams,

00:22:43.767 --> 00:22:45.300
which--since we
created the shaders,

00:22:45.300 --> 00:22:46.534
we know what parameters
they need.

00:22:46.534 --> 00:22:47.934
If you're familiar
with shaders, they--

00:22:47.934 --> 00:22:49.434
you specify
all of these parameters

00:22:49.434 --> 00:22:50.534
that they need
for rendering.

00:22:50.534 --> 00:22:53.100
Since we know which ones
got created,

00:22:53.100 --> 00:22:55.767
we're gonna--we have this
function that will give you

00:22:55.767 --> 00:22:56.934
a JavaScript object

00:22:56.934 --> 00:22:59.234
that has ways to access
all those parameters

00:22:59.234 --> 00:23:00.801
in a global way.

00:23:00.801 --> 00:23:03.767
And so this way we can set
the light and the light color

00:23:03.767 --> 00:23:05.501
for both of those materials

00:23:05.501 --> 00:23:07.934
with one setting here.

00:23:07.934 --> 00:23:10.501
Then we're going to create
a plane, a ground plane.

00:23:10.501 --> 00:23:11.901
That's the first line.

00:23:11.901 --> 00:23:14.200
We'll create a transform
to position that in the world.

00:23:14.200 --> 00:23:17.567
We're gonna transparent
that transform to our root,

00:23:17.567 --> 00:23:19.467
and then we're gonna
add that plane

00:23:19.467 --> 00:23:20.868
to that transform.

00:23:20.868 --> 00:23:23.701
We create a cylinder.
We create another transform.

00:23:23.701 --> 00:23:25.834
This time we're gonna store it
in a global player transform

00:23:25.834 --> 00:23:28.601
so that we can manipulate it
easier later.

00:23:28.601 --> 00:23:30.000
We're gonna parent that
to the world,

00:23:30.000 --> 00:23:31.734
and we're going
to add that shape

00:23:31.734 --> 00:23:33.167
to that transform.

00:23:33.167 --> 00:23:38.534
And so I go over
into step two...

00:23:38.534 --> 00:23:39.834
there we go.

00:23:39.834 --> 00:23:42.200
We have a plane.
We have a cylinder.

00:23:42.200 --> 00:23:44.834
Okay, so now we gotta make it
do something more interesting.

00:23:44.834 --> 00:23:47.400
So let's let the user
move it.

00:23:47.400 --> 00:23:49.334
So in this case, we need to
track the state of the keyboard.

00:23:49.334 --> 00:23:53.133
And I think,
unlike most JavaScript...

00:23:53.133 --> 00:23:54.968
programs, you're usually
going to have to--

00:23:54.968 --> 00:23:56.400
if you're writing a game,
you want to know

00:23:56.400 --> 00:23:57.868
when the key is held down
and when it's released.

00:23:57.868 --> 00:23:59.267
Not just when it's pressed.

00:23:59.267 --> 00:24:02.901
So in this case we're
going to assign some functions

00:24:02.901 --> 00:24:04.434
to key up and key down.

00:24:04.434 --> 00:24:05.834
And you'll see that
we actually

00:24:05.834 --> 00:24:07.434
call into our JavaScript
labor to do that

00:24:07.434 --> 00:24:08.868
versus kind of like
the DOM way,

00:24:08.868 --> 00:24:11.133
which--we'd put them
on the window or on a div.

00:24:11.133 --> 00:24:12.601
And that's mostly
because we're a plugin.

00:24:12.601 --> 00:24:14.567
We had to do it that way.

00:24:14.567 --> 00:24:16.234
If we ever
are not a plugin,

00:24:16.234 --> 00:24:18.300
we'll be able to, you know,
make it the DOM way.

00:24:18.300 --> 00:24:19.834
And then you can see
the two functions down here:

00:24:19.834 --> 00:24:23.300
On keyDown we're just going
to use this global array

00:24:23.300 --> 00:24:25.100
and set,
for a particular key,

00:24:25.100 --> 00:24:26.701
whether that key
is up or down.

00:24:26.701 --> 00:24:28.033
If the key is let up,
we'll set it--

00:24:28.033 --> 00:24:31.100
we'll record
that it's been released.

00:24:31.100 --> 00:24:32.701
Then we're going to add
some stuff in our--

00:24:32.701 --> 00:24:36.467
back in our inner function
to add a render callback.

00:24:36.467 --> 00:24:37.968
And that--that's
a JavaScript function

00:24:37.968 --> 00:24:39.868
that will get called
every single frame,

00:24:39.868 --> 00:24:41.868
and potentially
up to 60 hertz

00:24:41.868 --> 00:24:43.834
or whatever your refresh rate
on your monitor is.

00:24:43.834 --> 00:24:46.167
Most LCD monitors
are 60 hertz.

00:24:46.167 --> 00:24:47.834
And down here, you can see
the actual function.

00:24:47.834 --> 00:24:50.167
It gets passed to this object,
which is a renderEvent.

00:24:50.167 --> 00:24:52.167
Out of that we're going
to pull the elapsedTime,

00:24:52.167 --> 00:24:53.834
and the elapsedTime
is how much time

00:24:53.834 --> 00:24:55.834
since the last renderEvent
in seconds.

00:24:55.834 --> 00:24:58.767
So that's useful,
and I'll show why.

00:24:58.767 --> 00:25:00.200
And then we're going
to call this function

00:25:00.200 --> 00:25:02.300
handleMoveKeys.

00:25:02.300 --> 00:25:03.834
And so here's
handleMoveKeys.

00:25:03.834 --> 00:25:06.634
And so you can see we have
a directionX and directionZ.

00:25:06.634 --> 00:25:08.968
That's the direction
across our ground plane.

00:25:08.968 --> 00:25:11.467
And these keys,
it's checking--

00:25:11.467 --> 00:25:13.067
the first column,
it's checking the cursor keys

00:25:13.067 --> 00:25:15.801
and the second column,
it's checking ASWD,

00:25:15.801 --> 00:25:17.901
which are pretty common
for a lot of games.

00:25:17.901 --> 00:25:19.868
And we're setting our direction
variables over here.

00:25:19.868 --> 00:25:22.467
And then we're just gonna add
those to the player's position.

00:25:22.467 --> 00:25:23.968
And then before,
in the setup,

00:25:23.968 --> 00:25:25.400
we had the player's transform.

00:25:25.400 --> 00:25:29.501
We're gonna set
his translation to...

00:25:29.501 --> 00:25:30.901
where it needs to be
to move around.

00:25:30.901 --> 00:25:34.234
So if I go over
to this step,

00:25:34.234 --> 00:25:37.400
we should now be able
to move him around.

00:25:37.400 --> 00:25:40.000
He's moving kind of fast.

00:25:40.000 --> 00:25:41.367
So the next step:

00:25:41.367 --> 00:25:44.601
We're just gonna make
that frame rate independent.

00:25:44.601 --> 00:25:46.167
So here
we're going to set up

00:25:46.167 --> 00:25:48.434
a...a variable
for MOVE_VELOCITY

00:25:48.434 --> 00:25:49.868
just to make it
easy to tweak.

00:25:49.868 --> 00:25:54.133
And we're gonna say it moves
25 units per second.

00:25:54.133 --> 00:25:56.434
And then we're gonna go into
that handleMoveKeys function

00:25:56.434 --> 00:25:58.167
and we're gonna change that
math that we were doing

00:25:58.167 --> 00:26:00.467
to add to the position
to use that MOVE_VELOCITY.

00:26:00.467 --> 00:26:02.467
And before we were just
adding the direction.

00:26:02.467 --> 00:26:04.467
And then we're gonna multiply it
by the elapsedTime.

00:26:04.467 --> 00:26:07.200
So it'll only move
whatever percentage of a second

00:26:07.200 --> 00:26:08.868
this frame actually handled.

00:26:08.868 --> 00:26:10.934
And then the rest of the code
stayed the same.

00:26:10.934 --> 00:26:16.968
And so if I go
and run step four...

00:26:16.968 --> 00:26:19.267
it should now run
nice and smooth.

00:26:19.267 --> 00:26:22.100
And...regardless
of what frame rate

00:26:22.100 --> 00:26:24.968
or how the power of the machine
that the user has,

00:26:24.968 --> 00:26:29.934
it should move at the same rate
across the field.

00:26:29.934 --> 00:26:32.133
So the next step is we want to
move it relative to the camera.

00:26:32.133 --> 00:26:33.501
If I go back to the demo,

00:26:33.501 --> 00:26:34.701
you can see that
as I move it across

00:26:34.701 --> 00:26:36.100
it's going down the grid.

00:26:36.100 --> 00:26:38.067
But the grid is kind of
at an angle to the camera

00:26:38.067 --> 00:26:39.868
and that's not really
good for a game.

00:26:39.868 --> 00:26:42.167
So there's
some little math here.

00:26:42.167 --> 00:26:43.601
I'm not really going to go
into the math,

00:26:43.601 --> 00:26:46.434
but there's this function
computeMoveMatrixFromViewMatrix.

00:26:46.434 --> 00:26:48.400
So before we were
computing a view matrix

00:26:48.400 --> 00:26:50.133
in our updateCamera function,

00:26:50.133 --> 00:26:51.934
and if we passed that matrix
to this function

00:26:51.934 --> 00:26:53.734
it'll return a matrix
that we can use

00:26:53.734 --> 00:26:55.601
to adjust our movement.

00:26:55.601 --> 00:26:57.534
And so I went
into the updateCamera,

00:26:57.534 --> 00:26:58.934
and anytime the camera's
been updated,

00:26:58.934 --> 00:27:01.200
I'm gonna update
this MoveMatrix just to--

00:27:01.200 --> 00:27:03.167
so I don't have
to worry about it anymore.

00:27:03.167 --> 00:27:04.534
And then I go back
into the place

00:27:04.534 --> 00:27:05.834
that was moving the character.

00:27:05.834 --> 00:27:07.934
And instead
of moving him directly,

00:27:07.934 --> 00:27:09.567
with our direction
times our velocity

00:27:09.567 --> 00:27:11.100
times our elapsed time,

00:27:11.100 --> 00:27:13.534
I'm gonna take that value and
multiply it by that MoveMatrix

00:27:13.534 --> 00:27:15.567
and it's gonna give me
two values I can instead use

00:27:15.567 --> 00:27:17.334
to move the player.

00:27:17.334 --> 00:27:19.334
So now if I go back and--
and...

00:27:19.334 --> 00:27:22.501
show you that example,

00:27:22.501 --> 00:27:26.267
you'll see that the player
is now moving

00:27:26.267 --> 00:27:27.901
perpendicular
to the camera field.

00:27:27.901 --> 00:27:29.200
And if I move it in and out,

00:27:29.200 --> 00:27:30.767
it's moving in and out
of the screen.

00:27:30.767 --> 00:27:33.667
And that's kind of
more game-like.

00:27:33.667 --> 00:27:36.601
So the next step is: Let's make
the camera follow the player.

00:27:36.601 --> 00:27:37.801
So that's pretty simple.

00:27:37.801 --> 00:27:39.200
Just take
the player's position,

00:27:39.200 --> 00:27:40.968
stick it in the target,
and call updateCamera.

00:27:40.968 --> 00:27:42.834
And then we'll put that
in a function

00:27:42.834 --> 00:27:44.601
and we're gonna call it
every frame as well

00:27:44.601 --> 00:27:45.934
in our onRender.

00:27:45.934 --> 00:27:50.901
So if I go
over to that step...

00:27:50.901 --> 00:27:54.167
now the camera's
following the player.

00:27:54.167 --> 00:27:56.033
But you can see
it's kind of stiff.

00:27:56.033 --> 00:27:57.667
It's not really
a good feeling.

00:27:57.667 --> 00:28:00.200
So let's make the camera
a little more smooth.

00:28:00.200 --> 00:28:01.601
So we'll smooth out
the camera,

00:28:01.601 --> 00:28:02.834
and this is a trick

00:28:02.834 --> 00:28:04.601
that a lot of video game
programmers use.

00:28:04.601 --> 00:28:05.834
It's not quite
frame rate independent,

00:28:05.834 --> 00:28:07.067
but it's close enough.

00:28:07.067 --> 00:28:08.467
Basically
what we're gonna do

00:28:08.467 --> 00:28:09.868
is instead of using
the new place

00:28:09.868 --> 00:28:11.300
we wanted the camera
to be directly,

00:28:11.300 --> 00:28:13.634
we're gonna store it in
a variable called newTarget

00:28:13.634 --> 00:28:16.234
and then we're just gonna take--
call this function lerp.

00:28:16.234 --> 00:28:19.701
And this says, "Move from
the target to the new target."

00:28:19.701 --> 00:28:22.968
And we're only gonna take
3% of that difference.

00:28:22.968 --> 00:28:24.267
And make that
the new target.

00:28:24.267 --> 00:28:28.667
And so if I
go run this sample...

00:28:28.667 --> 00:28:30.234
now the camera
will lag behind.

00:28:30.234 --> 00:28:31.734
So I move over here,
and the camera will catch up.

00:28:31.734 --> 00:28:34.701
Move over here,
the camera will catch up.

00:28:34.701 --> 00:28:36.501
And that's just
a much better feeling

00:28:36.501 --> 00:28:40.033
than before.

00:28:40.033 --> 00:28:41.534
So let's add
a little bit of action.

00:28:41.534 --> 00:28:43.000
Let's make the charac--

00:28:43.000 --> 00:28:45.267
little bit more code, and
it's a little bit complicated

00:28:45.267 --> 00:28:46.734
to explain, but...

00:28:46.734 --> 00:28:48.467
in the first part,
there's a little variable

00:28:48.467 --> 00:28:49.667
where we're checking
if the layout--

00:28:49.667 --> 00:28:50.834
a user is allowed to jump.

00:28:50.834 --> 00:28:52.234
And I'll go over that
in a moment.

00:28:52.234 --> 00:28:53.501
But here we're checking--
that's the space bar.

00:28:53.501 --> 00:28:55.467
32 happens to be
the key code for the space.

00:28:55.467 --> 00:28:57.267
If we press the space,

00:28:57.267 --> 00:28:58.534
set this flag
that we're jumping,

00:28:58.534 --> 00:29:00.000
and set that
we can't jump again.

00:29:00.000 --> 00:29:02.133
That's so we can't keep jumping
while we're in the air.

00:29:02.133 --> 00:29:05.133
And then just set the player's
velocity to some value,

00:29:05.133 --> 00:29:08.067
which we define
other--elsewhere.

00:29:08.067 --> 00:29:10.033
And then--otherwise
when I come through here

00:29:10.033 --> 00:29:11.701
we'll already be jumping.

00:29:11.701 --> 00:29:14.067
And so we're gonna
take that velocity

00:29:14.067 --> 00:29:15.501
and we're gonna
add in gravity

00:29:15.501 --> 00:29:18.167
and you can see we're
multiplying by the elapsed time

00:29:18.167 --> 00:29:19.601
to make it
frame rate independent.

00:29:19.601 --> 00:29:21.300
And we're gonna
use that velocity

00:29:21.300 --> 00:29:23.000
and add it
to its position

00:29:23.000 --> 00:29:25.033
also by the--multiply it
by the elapsed time

00:29:25.033 --> 00:29:26.334
to make that
frame rate independent.

00:29:26.334 --> 00:29:28.267
And then we're checking
whether he hit the ground

00:29:28.267 --> 00:29:29.667
just by checking
whether he hit 0.

00:29:29.667 --> 00:29:32.667
And if he hit 0,
then we're gonna just...

00:29:32.667 --> 00:29:36.334
force it to 0 and
tell him to stop jumping.

00:29:36.334 --> 00:29:37.434
And then at the bottom
you can see

00:29:37.434 --> 00:29:39.534
the reason we have
this canJump

00:29:39.534 --> 00:29:40.734
is that we basically
don't want it

00:29:40.734 --> 00:29:41.868
if you hold the space bar,

00:29:41.868 --> 00:29:43.033
that the player
will just keep bouncing.

00:29:43.033 --> 00:29:44.234
We want to make it
that you actually

00:29:44.234 --> 00:29:45.634
have to press the space bar
to jump again.

00:29:45.634 --> 00:29:47.200
And so that's why,
when he's finished jumping,

00:29:47.200 --> 00:29:48.634
we don't let him jump again

00:29:48.634 --> 00:29:50.367
until he's released
the space bar.

00:29:50.367 --> 00:29:52.167
And then finally,
in the translate,

00:29:52.167 --> 00:29:53.901
where we were
positioning the player,

00:29:53.901 --> 00:29:57.067
we add it to set
the "Y" position back in.

00:29:57.067 --> 00:30:01.567
So if I go
and do this sample...

00:30:01.567 --> 00:30:04.834
he should now move around
and he should jump.

00:30:04.834 --> 00:30:06.200
[chuckles]

00:30:06.200 --> 00:30:08.067
So let's take him
to the next step.

00:30:08.067 --> 00:30:09.934
Let's add a little bit
of effect.

00:30:09.934 --> 00:30:12.133
Here we're gonna create
a particle emitter.

00:30:12.133 --> 00:30:14.133
So we have, again,
our utility libraries

00:30:14.133 --> 00:30:15.667
and we're gonna create
a particle system,

00:30:15.667 --> 00:30:18.467
and from that system we're gonna
create a particle emitter.

00:30:18.467 --> 00:30:20.968
We're gonna set its state
so it's an additive particle.

00:30:20.968 --> 00:30:22.300
That means the colors add up.

00:30:22.300 --> 00:30:24.067
We're gonna set a little
ColorRamp here.

00:30:24.067 --> 00:30:27.434
This ColorRamp says
start at 30% opaque white

00:30:27.434 --> 00:30:30.567
and go to 0% opaque white
or 100% transparent.

00:30:30.567 --> 00:30:31.801
And then we have
all these parameters

00:30:31.801 --> 00:30:33.167
that set up some particles.

00:30:33.167 --> 00:30:34.834
So we want
to emit 30 particles.

00:30:34.834 --> 00:30:37.868
We want them to take--
to last a 1/2 a second,

00:30:37.868 --> 00:30:41.567
to start at size 5, and scale
to size 10 over that time.

00:30:41.567 --> 00:30:43.167
And then there's
some funky math

00:30:43.167 --> 00:30:44.467
down here at the bottom,

00:30:44.467 --> 00:30:46.834
where--if we wanted to set
the parameters directly,

00:30:46.834 --> 00:30:48.501
we could have done just like
we did those last parameters.

00:30:48.501 --> 00:30:50.400
But this--we want
to actually set the--

00:30:50.400 --> 00:30:53.033
the velocity of the...

00:30:53.033 --> 00:30:54.434
of the particles
per particle.

00:30:54.434 --> 00:30:55.934
So I'm doing
a little math here,

00:30:55.934 --> 00:30:59.033
which is just taking
a velocity along the ground

00:30:59.033 --> 00:31:01.734
and rotating it randomly
at 360 degrees

00:31:01.734 --> 00:31:03.767
so they'll come out
at some random place

00:31:03.767 --> 00:31:05.400
around his feet.

00:31:05.400 --> 00:31:07.367
And then I actually add
a little acceleration

00:31:07.367 --> 00:31:09.767
so they'll slow
as they come away.

00:31:09.767 --> 00:31:12.067
And then we create
an emitter for that,

00:31:12.067 --> 00:31:13.868
or a one-shot emitter.

00:31:13.868 --> 00:31:15.734
And then to use it,
we just go

00:31:15.734 --> 00:31:17.033
back into the code
there where he's jumping.

00:31:17.033 --> 00:31:19.968
When he lands on the ground,
we trigger that effect.

00:31:19.968 --> 00:31:23.767
So if I go and show you
this sample...

00:31:23.767 --> 00:31:26.634
now when he jumps
there's a poof.

00:31:26.634 --> 00:31:28.868
[chuckle]

00:31:28.868 --> 00:31:31.467
Okay, so having, you know,
like, a checkered plane

00:31:31.467 --> 00:31:34.267
and a--and a cylinder,
okay, programmer art.

00:31:34.267 --> 00:31:37.133
But you've gotta add
some real art at some point.

00:31:37.133 --> 00:31:41.100
So the next step is:
We're gonna load a character.

00:31:41.100 --> 00:31:43.667
And so here,
back in our initStep,

00:31:43.667 --> 00:31:45.100
we're--instead
of making the cylinder,

00:31:45.100 --> 00:31:46.467
we deleted that code.

00:31:46.467 --> 00:31:48.167
We're still gonna create
a transform for the player,

00:31:48.167 --> 00:31:50.067
but this time
we're gonna create a pack

00:31:50.067 --> 00:31:52.467
and this is mostly
for management reasons.

00:31:52.467 --> 00:31:53.734
We don't really
have to do this,

00:31:53.734 --> 00:31:55.734
but it make--
keeps things separated.

00:31:55.734 --> 00:31:57.467
And then we're gonna call
this function loadScene.

00:31:57.467 --> 00:31:58.868
And we pass in that pack

00:31:58.868 --> 00:32:01.033
to say everything we load
to get--create from that pack,

00:32:01.033 --> 00:32:03.367
and we're gonna pass in
that player transform

00:32:03.367 --> 00:32:05.267
to say everything
that gets loaded,

00:32:05.267 --> 00:32:06.968
build under that transform.

00:32:06.968 --> 00:32:09.033
And here you can see
we passed it in a path.

00:32:09.033 --> 00:32:12.467
And then because
this is a web API,

00:32:12.467 --> 00:32:13.667
the whole thing
has to be asynchronous

00:32:13.667 --> 00:32:14.868
'cause you don't know how long

00:32:14.868 --> 00:32:16.334
it's gonna take
to download that.

00:32:16.334 --> 00:32:18.033
And so when it's finished
we want to tell it to continue

00:32:18.033 --> 00:32:19.167
with initStep3.

00:32:19.167 --> 00:32:20.801
And initStep3 is
all the code we used to have

00:32:20.801 --> 00:32:24.567
below the point
of creating the--the cylinder

00:32:24.567 --> 00:32:25.834
plus a few extra lines,

00:32:25.834 --> 00:32:27.067
and these few extra lines
are listed here

00:32:27.067 --> 00:32:28.601
which is to prepare the pack.

00:32:28.601 --> 00:32:31.734
That goes through the pack
and creates the standard shaders

00:32:31.734 --> 00:32:33.467
that our utility library
will create for you.

00:32:33.467 --> 00:32:34.834
If you're doing
something custom,

00:32:34.834 --> 00:32:37.133
you might stop there and
actually create custom shaders

00:32:37.133 --> 00:32:38.634
to do something
really fancy.

00:32:38.634 --> 00:32:40.868
And we're gonna bind
the parameters again

00:32:40.868 --> 00:32:42.300
from the ones
we bound before,

00:32:42.300 --> 00:32:44.100
so that all of the shaders
that just were created

