WEBVTT
Kind: captions
Language: en

00:00:36.370 --> 00:00:39.200
PROFESSOR: All right,
let's get started.

00:00:39.200 --> 00:00:43.120
So today we're continuing
the theme of locked linkages.

00:00:43.120 --> 00:00:45.970
Last time we talked about the
Carpenter's Rule Theorem, which

00:00:45.970 --> 00:00:48.420
brought together all of the
rigidity theory and tensegrity

00:00:48.420 --> 00:00:50.620
theory we had
built, essentially,

00:00:50.620 --> 00:00:55.090
and showed that there
were no locked 2D

00:00:55.090 --> 00:00:59.040
chains, paths or
cycles, as graphs.

00:00:59.040 --> 00:01:07.130
And in general you can think
in 2D, you can think in 3D,

00:01:07.130 --> 00:01:10.210
and you can think
in 4D and higher.

00:01:10.210 --> 00:01:14.560
I drew this table way at
the beginning of class.

00:01:14.560 --> 00:01:18.560
And you can think
about chains, which

00:01:18.560 --> 00:01:24.470
are-- these are so-called open
chains, like robotic arms.

00:01:24.470 --> 00:01:26.690
Paths is a graph.

00:01:26.690 --> 00:01:32.630
And polygons are closed chains.

00:01:32.630 --> 00:01:34.960
And then another case it's
interesting to think about,

00:01:34.960 --> 00:01:37.820
and there's been a lot of
work on, are trees where

00:01:37.820 --> 00:01:40.190
you don't have any
cycles in your graph,

00:01:40.190 --> 00:01:44.890
but you could have branching
points with degree more than 2.

00:01:44.890 --> 00:01:47.670
You may recall Carpenter's
Rule Theorem worked whenever

00:01:47.670 --> 00:01:51.050
you had a graph of
maximum degree 2.

00:01:51.050 --> 00:01:53.940
So it allowed even
multiple chains

00:01:53.940 --> 00:01:56.980
in one graph that
could be disconnected.

00:01:56.980 --> 00:02:02.020
But it forbade any kind
of tree branching stuff.

00:02:02.020 --> 00:02:03.920
So Carpenter's Rule
Theorem is that there's

00:02:03.920 --> 00:02:07.990
no locked chains in 2D.

00:02:07.990 --> 00:02:11.640
So we did that.

00:02:11.640 --> 00:02:16.020
But trees, there are
locked trees in 2D.

00:02:16.020 --> 00:02:20.140
3D there are locked chains.

00:02:20.140 --> 00:02:21.720
And these are two
results that we

00:02:21.720 --> 00:02:26.380
will talk about in
today's lecture.

00:02:26.380 --> 00:02:31.190
And that implies that there are
locked trees, sort of obvious.

00:02:31.190 --> 00:02:34.620
Trees are more general
than open chains.

00:02:34.620 --> 00:02:36.700
And because there's a
locked open chain in 3D,

00:02:36.700 --> 00:02:39.260
there's also a locked tree.

00:02:39.260 --> 00:02:42.450
In 4D, though, it switches.

00:02:42.450 --> 00:02:44.700
So none of these
things are locked.

00:02:44.700 --> 00:02:48.000
Of course, there are
locked graphs in general.

00:02:48.000 --> 00:02:51.070
But if you look at trees, or
paths, or cycles, none of them

00:02:51.070 --> 00:02:51.760
can lock.

00:02:51.760 --> 00:02:54.057
We won't have time to talk
about that today, maybe

00:02:54.057 --> 00:02:54.640
another class.

00:02:57.166 --> 00:02:58.540
Essentially we're
always thinking

00:02:58.540 --> 00:03:00.890
about an intrinsically
one dimensional structure.

00:03:00.890 --> 00:03:04.260
These edges, bars, are
always one dimensional.

00:03:04.260 --> 00:03:07.980
In 2D, where the
space are living in,

00:03:07.980 --> 00:03:10.720
the ambient dimension is just
one more than the dimension

00:03:10.720 --> 00:03:12.700
of your edges, it's
really interesting.

00:03:12.700 --> 00:03:15.070
And that's what
we saw for chains

00:03:15.070 --> 00:03:17.370
and what we'll see for trees.

00:03:17.370 --> 00:03:19.740
In 3D it gets tricky.

00:03:19.740 --> 00:03:22.480
This mismatch of
two in dimension

00:03:22.480 --> 00:03:25.340
allows you to lock things,
kind of like knots.

00:03:25.340 --> 00:03:28.480
And in 4D there's such--
there's so much freedom

00:03:28.480 --> 00:03:30.540
in the way you move,
somehow, nothing

00:03:30.540 --> 00:03:33.125
can lock, in the same way
that there are no knots in 4D.

00:03:35.840 --> 00:03:37.340
Cool.

00:03:37.340 --> 00:03:40.310
So that's the reminder
summary about locked linkages,

00:03:40.310 --> 00:03:43.920
what they are, and
what's known about them.

00:03:43.920 --> 00:03:46.690
Now we've seen that
chains aren't locked.

00:03:46.690 --> 00:03:49.360
But before I get trees I
want to talk about algorithms

00:03:49.360 --> 00:03:50.415
for actually doing this.

00:03:50.415 --> 00:03:53.430
This is, after all,
geometric folding algorithms.

00:03:53.430 --> 00:03:55.866
We've seen a proof
that they exist,

00:03:55.866 --> 00:03:57.490
that in fact if we
had a chain, there's

00:03:57.490 --> 00:04:00.490
an expansive motion
increases all the distances

00:04:00.490 --> 00:04:04.300
and therefore doesn't
collide with itself,

00:04:04.300 --> 00:04:08.550
and eventually straightens
all the outermost open chains

00:04:08.550 --> 00:04:12.260
and convexifies all the closed
chains that are outermost,

00:04:12.260 --> 00:04:15.780
not containing anything.

00:04:15.780 --> 00:04:19.570
But how do we actually
find such a motion?

00:04:19.570 --> 00:04:21.430
And this has been the
subject of some study.

00:04:21.430 --> 00:04:23.096
There are three
algorithms for doing it.

00:04:28.590 --> 00:04:35.940
So we'll call this
unfolding 2D chains,

00:04:35.940 --> 00:04:42.040
unfolding being the goal of
straightening or convexifying.

00:04:42.040 --> 00:04:45.830
And the first algorithm is just
to mimic the proof that we saw.

00:04:59.700 --> 00:05:03.060
I call that proof CDR, because
it's Connelly-Demain-Rote.

00:05:03.060 --> 00:05:07.100
And if you think
about what we proved,

00:05:07.100 --> 00:05:09.650
we just looked at the sort
of infinitesimal case.

00:05:09.650 --> 00:05:12.890
We said, if we're at some
position then at least,

00:05:12.890 --> 00:05:14.914
for an infinitesimal
amount of time,

00:05:14.914 --> 00:05:16.330
we can increase
all the distances.

00:05:16.330 --> 00:05:18.320
All the struts can
increase in length,

00:05:18.320 --> 00:05:21.000
and the bars stay
the same length.

00:05:21.000 --> 00:05:23.550
That's really only specifying
the first derivative

00:05:23.550 --> 00:05:24.410
of a motion.

00:05:24.410 --> 00:05:27.170
So if you think of motion
as being, I don't know,

00:05:27.170 --> 00:05:30.430
some configuration C
that's a function of time,

00:05:30.430 --> 00:05:34.010
and you take the derivative
with respect to t,

00:05:34.010 --> 00:05:36.107
then we computed what
that derivative should be.

00:05:36.107 --> 00:05:37.440
That was the first order motion.

00:05:37.440 --> 00:05:42.270
I think we called it d,
which is a little confusing.

00:05:42.270 --> 00:05:45.380
This is the d that we computed.

00:05:45.380 --> 00:05:49.710
And we said, well that's
an infinitesimal motion

00:05:49.710 --> 00:05:51.155
of some tensegrity.

00:05:51.155 --> 00:05:52.780
We can find it with
linear programming.

00:05:52.780 --> 00:05:55.050
So at any moment in
time we can figure out

00:05:55.050 --> 00:05:58.210
what our derivative should be.

00:05:58.210 --> 00:06:00.720
This is what's called an
ordinary differential equation,

00:06:00.720 --> 00:06:03.650
for those who have
taking 1803 or whatever.

00:06:03.650 --> 00:06:05.474
You just solve it.

00:06:05.474 --> 00:06:06.890
And a very easy
way to solve it is

00:06:06.890 --> 00:06:10.610
if you imagine configuration
space, you start somewhere,

00:06:10.610 --> 00:06:12.349
you compute which
way to go, you move

00:06:12.349 --> 00:06:13.640
a little bit in that direction.

00:06:13.640 --> 00:06:15.931
You're only supposed to go
for an infinitesimal amount.

00:06:15.931 --> 00:06:18.070
But it goes some
positive epsilon.

00:06:18.070 --> 00:06:20.020
Then recompute
your new direction,

00:06:20.020 --> 00:06:22.170
follow that, recompute
your new direction,

00:06:22.170 --> 00:06:24.500
follow that for a little
bit, and keep going.

00:06:24.500 --> 00:06:26.960
And you're almost tracking
the intended curve.

00:06:26.960 --> 00:06:28.510
It's not quite perfect.

00:06:28.510 --> 00:06:31.440
But as your step
size, this epsilon,

00:06:31.440 --> 00:06:35.970
goes to 0 you approximate
the intended path.

00:06:35.970 --> 00:06:38.514
And that's, I mean how
close you approximate

00:06:38.514 --> 00:06:39.680
is computed in the textbook.

00:06:39.680 --> 00:06:41.380
You can see that for details.

00:06:41.380 --> 00:06:43.350
This is a method
called forward Euler.

00:06:43.350 --> 00:06:46.810
It's like the simplest way to
solve an ordinary differential

00:06:46.810 --> 00:06:47.310
equation.

00:06:47.310 --> 00:06:48.850
There are much better ways.

00:06:48.850 --> 00:06:51.810
But it's easiest to think
about, and reason about.

00:06:51.810 --> 00:06:54.835
And so it gives you some
approximate solution.

00:06:57.670 --> 00:06:58.760
Let me show it to you.

00:07:03.130 --> 00:07:04.750
I'm going to show
you three methods.

00:07:04.750 --> 00:07:06.800
The top one is the
one I'm talking about.

00:07:06.800 --> 00:07:08.425
So we're starting
with the same polygon

00:07:08.425 --> 00:07:11.637
on the left, simple
little v shape.

00:07:11.637 --> 00:07:13.595
A second method is called
pseudo-triangulation.

00:07:13.595 --> 00:07:14.840
We'll talk about that next.

00:07:14.840 --> 00:07:16.310
The third method's
called energy.

00:07:16.310 --> 00:07:17.970
That one's one you've seen.

00:07:17.970 --> 00:07:19.810
Let's start with
the first method,

00:07:19.810 --> 00:07:25.080
where we take some example
like this teeth example,

00:07:25.080 --> 00:07:28.850
and we, at each
step, compute what

00:07:28.850 --> 00:07:31.960
is the, in some
sense, the biggest

00:07:31.960 --> 00:07:33.359
expanse of motion you could do.

00:07:33.359 --> 00:07:34.900
We go a little bit
in that direction.

00:07:34.900 --> 00:07:36.560
So in these animations,
the edge links

00:07:36.560 --> 00:07:37.957
are changing a little bit.

00:07:37.957 --> 00:07:40.290
And I've chosen the step size
so the edge lengths change

00:07:40.290 --> 00:07:42.840
by, at most, 10%,
something like that.

00:07:42.840 --> 00:07:44.390
And here, this one,
left side we're

00:07:44.390 --> 00:07:47.120
zooming, right side
we're not zooming.

00:07:47.120 --> 00:07:48.620
These are somewhat
older animations.

00:07:48.620 --> 00:07:51.580
So apologies for the frame rate.

00:07:51.580 --> 00:07:53.010
What else do I want to say?

00:07:53.010 --> 00:07:54.930
This is an example--
well, notice

00:07:54.930 --> 00:07:57.650
it's pulling the teeth
off sort of from the end.

00:07:57.650 --> 00:08:00.260
If you want to be expensive you
cannot pull the teeth apart.

00:08:00.260 --> 00:08:02.702
We're going to see other ways
to do the teeth in a moment.

00:08:02.702 --> 00:08:03.660
Here's another example.

00:08:03.660 --> 00:08:05.730
Both of these
examples at some point

00:08:05.730 --> 00:08:08.430
we're conjectured to be locked.

00:08:08.430 --> 00:08:10.420
Before the Carpenter's
Rule Theorem was proved,

00:08:10.420 --> 00:08:13.862
a lot of people were trying
to find counter examples.

00:08:13.862 --> 00:08:14.570
There aren't any.

00:08:18.080 --> 00:08:18.775
So this is nice.

00:08:18.775 --> 00:08:22.560
It preserve five-fold
rotational symmetry.

00:08:22.560 --> 00:08:26.570
And you can do it for
multiple shapes as well.

00:08:26.570 --> 00:08:29.890
So here we have one polygon
in the center, four arcs,

00:08:29.890 --> 00:08:33.940
four paths on the outside.

00:08:33.940 --> 00:08:36.380
In this case, the simulation
stopped when one of them

00:08:36.380 --> 00:08:41.064
convexified because I didn't
implement all of the algorithm.

00:08:41.064 --> 00:08:43.230
At that point you just have
to rigidify that polygon

00:08:43.230 --> 00:08:46.600
and expand the rest.

00:08:46.600 --> 00:08:49.140
So that gives you an
idea sort of visually

00:08:49.140 --> 00:08:51.200
what this looks like.

00:08:51.200 --> 00:08:53.780
Qualitatively, we can say
a bunch of cool things

00:08:53.780 --> 00:08:55.070
about this method.

00:08:55.070 --> 00:08:58.680
One is that's it's the
only method that's strictly

00:08:58.680 --> 00:09:06.100
expansive, strictly meaning not
only do the struts not decrease

00:09:06.100 --> 00:09:07.990
in length, but they
also don't stay the same

00:09:07.990 --> 00:09:09.530
whenever that's possible.

00:09:09.530 --> 00:09:11.150
They strictly increase.

00:09:11.150 --> 00:09:12.510
Now, there are some exceptions.

00:09:12.510 --> 00:09:16.750
If I have a bar, obviously,
if I add a strut here

00:09:16.750 --> 00:09:18.680
it's not going to strictly
increase in length.

00:09:18.680 --> 00:09:22.020
Also, if I have a bunch
of bars that are collinear

00:09:22.020 --> 00:09:24.156
and I add a strut
from here to here,

00:09:24.156 --> 00:09:25.780
that's not going to
increase in length.

00:09:25.780 --> 00:09:27.090
It's not possible.

00:09:27.090 --> 00:09:30.317
But all other struts will
strictly increase in length.

00:09:30.317 --> 00:09:30.900
You can check.

00:09:30.900 --> 00:09:35.150
That's what we proved here.

00:09:35.150 --> 00:09:38.190
So that's nice.

00:09:38.190 --> 00:09:42.860
Another fun fact, I
didn't write it here,

00:09:42.860 --> 00:09:47.740
but it preserves symmetry
if you do it right.

00:09:51.350 --> 00:09:53.485
You may notice in
this example actually,

00:09:53.485 --> 00:09:55.610
it was originally four-fold
rotationally symmetric.

00:09:55.610 --> 00:09:58.360
It does rotate a little bit.

00:09:58.360 --> 00:10:00.220
That's from computational error.

00:10:00.220 --> 00:10:01.660
And you could correct for that.

00:10:01.660 --> 00:10:05.050
I didn't correct for it.

00:10:05.050 --> 00:10:11.700
It should, in theory, preserve
the four-fold symmetry there.

00:10:11.700 --> 00:10:12.660
Good.

00:10:12.660 --> 00:10:14.640
We can compute one step.

00:10:14.640 --> 00:10:18.310
So how fast can you
compute this thing?

00:10:18.310 --> 00:10:20.250
We can compute one step
in polynomial time.

00:10:20.250 --> 00:10:23.262
That's finding an infinitesimal
motion of a tensegrity.

00:10:23.262 --> 00:10:24.345
That's linear programming.

00:10:27.970 --> 00:10:31.820
But how many steps does it make?

00:10:31.820 --> 00:10:32.850
We don't really know.

00:10:32.850 --> 00:10:35.180
There is a bound
in the textbook.

00:10:35.180 --> 00:10:38.390
It's not very small.

00:10:38.390 --> 00:10:44.960
It's also-- with forward Euler
you lose a bit of accuracy.

00:10:44.960 --> 00:10:47.100
Now you could
correct for accuracy,

00:10:47.100 --> 00:10:48.850
force all the edge
lengths to be the same,

00:10:48.850 --> 00:10:50.080
then you won't
preserve the symmetry.

00:10:50.080 --> 00:10:51.720
There's a bit of trade off here.

00:10:51.720 --> 00:10:53.469
I don't want to spend
too much time on it.

00:10:53.469 --> 00:10:55.080
This is the first algorithm.

00:10:55.080 --> 00:10:58.280
Although it's the only one
that's strictly expensive,

00:10:58.280 --> 00:10:59.550
to me it's not the nicest.

00:10:59.550 --> 00:11:06.976
So I'm going to move on
to the next method which

00:11:06.976 --> 00:11:08.350
is pointed
pseudo-triangulations.

00:11:13.970 --> 00:11:16.360
This is a method
by Ileana Streinu,

00:11:16.360 --> 00:11:20.350
basically at the same
time as the original

00:11:20.350 --> 00:11:22.830
Carpenter's Rule Theorem.

00:11:22.830 --> 00:11:24.280
And these are
examples of what are

00:11:24.280 --> 00:11:26.970
called pointed
pseudo-triangulations

00:11:26.970 --> 00:11:28.830
for a given set of points.

00:11:28.830 --> 00:11:34.040
So in general, a
pseudo-triangle is a polygon

00:11:34.040 --> 00:11:36.980
that has three convex vertices.

00:11:36.980 --> 00:11:40.020
So a triangle has three
convex vertices and that's it.

00:11:40.020 --> 00:11:44.670
A pseudo-triangle, I allow
a bunch of reflex vertices

00:11:44.670 --> 00:11:47.260
in between those guys.

00:11:47.260 --> 00:11:48.550
So this should be a polygon.

00:11:48.550 --> 00:11:51.200
I've drawn it curved.

00:11:51.200 --> 00:11:55.430
And if you check in this
figure, all of the faces

00:11:55.430 --> 00:11:56.460
are pseudo-triangles.

00:11:56.460 --> 00:11:59.180
Most of them here are
actually quadrilaterals.

00:11:59.180 --> 00:12:01.090
But in particular,
that's a pseudo-triangle.

00:12:01.090 --> 00:12:04.610
Sometimes there's
actual triangles.

00:12:04.610 --> 00:12:07.130
Here they're all
quads or triangles.

00:12:07.130 --> 00:12:10.040
And a pointed
pseudo-triangulation

00:12:10.040 --> 00:12:14.630
has the property
that at every vertex

00:12:14.630 --> 00:12:19.410
all of the edges incident
to it lie in a half plane.

00:12:19.410 --> 00:12:21.340
They all lie on that side.

00:12:21.340 --> 00:12:26.315
In other words, there's an angle
that's bigger than 180 degrees.

00:12:26.315 --> 00:12:32.150
So this was a pseudo-triangle,
and this is pointed.

00:12:34.870 --> 00:12:38.330
And if you check this
example, every vertex

00:12:38.330 --> 00:12:40.275
has an angle that's
bigger than 180 degrees.

00:12:44.510 --> 00:12:46.850
Obviously the ones on
the outside have to.

00:12:46.850 --> 00:12:49.290
They're always convex.

00:12:49.290 --> 00:12:51.240
And pointed
pseudo-triangulations

00:12:51.240 --> 00:12:55.850
are-- they're not only supposed
to have these two properties,

00:12:55.850 --> 00:12:58.346
but you're also supposed to
have as many edges as possible,

00:12:58.346 --> 00:12:59.970
subject to having
these two properties.

00:12:59.970 --> 00:13:03.900
If you tried to add any edge
to either of these examples,

00:13:03.900 --> 00:13:06.980
you would violate
the pointed property.

00:13:06.980 --> 00:13:11.630
If I added this edge, then I'd
destroy this 180 degree angle.

00:13:11.630 --> 00:13:13.080
Any edge you
consider, either you

00:13:13.080 --> 00:13:14.990
get a crossing--
which is not allowed--

00:13:14.990 --> 00:13:21.250
or one of the vertices
loses a 180 degree angle.

00:13:21.250 --> 00:13:23.480
So this is actually a
really powerful concept.

00:13:23.480 --> 00:13:27.470
And it was introduced by this
paper by Streinu in 2000.

00:13:27.470 --> 00:13:30.164
It has lots of theory
built around it by now.

00:13:30.164 --> 00:13:31.830
I'm not going to talk
about that theory.

00:13:31.830 --> 00:13:34.466
I want to talk about how it
applies to Carpenter's Rule

00:13:34.466 --> 00:13:34.965
problem.

00:13:39.546 --> 00:13:40.920
I guess the first
thing to say is

00:13:40.920 --> 00:13:48.590
that if you have,
say, a polygon-- maybe

00:13:48.590 --> 00:13:51.290
I should do a real example,
so I'll make it not so giant.

00:13:56.230 --> 00:13:58.330
OK, you take a polygon.

00:13:58.330 --> 00:13:59.950
So far it's pointed, right?

00:13:59.950 --> 00:14:01.980
Every vertex-- one
of the two sides

00:14:01.980 --> 00:14:05.090
has an angle bigger than 180.

00:14:05.090 --> 00:14:10.485
So just add as many edges as you
can while still being pointed.

00:14:10.485 --> 00:14:12.200
Do, do, do.

00:14:12.200 --> 00:14:15.570
This one, that looks OK.

00:14:19.480 --> 00:14:20.590
I think that's it.

00:14:20.590 --> 00:14:22.534
I think this is a
pseudo-triangulation.

00:14:22.534 --> 00:14:24.950
I've added as many edges as I
can while still being point.

00:14:24.950 --> 00:14:27.060
It turns out if you start
with something that's pointed,

00:14:27.060 --> 00:14:29.270
you'll be able to keep adding
edges, keep it pointed.

00:14:29.270 --> 00:14:32.930
And in the end all of the
faces will be pseudo-triangles.

00:14:32.930 --> 00:14:34.347
So mission accomplished.

00:14:34.347 --> 00:14:35.930
This is a pointed
pseudo-triangulation

00:14:35.930 --> 00:14:40.160
that contains, as a subgraph,
my original polygon.

00:14:43.190 --> 00:14:46.120
So these are the edge
lengths I want to preserve.

00:14:46.120 --> 00:14:47.720
Those should stay rigid.

00:14:47.720 --> 00:14:50.340
I'm going to be kind of
crazy and also preserve

00:14:50.340 --> 00:14:53.070
the lengths of all
of these edges.

00:14:53.070 --> 00:14:55.910
Now if you did that, this
thing would be rigid,

00:14:55.910 --> 00:14:57.290
which is not so exciting.

00:14:57.290 --> 00:15:01.300
All you need to do to fix that
is remove one of these added

00:15:01.300 --> 00:15:05.530
edges that's on the convex hull
on the outer boundary here.

00:15:05.530 --> 00:15:08.069
Then it will have one
degree of freedom.

00:15:08.069 --> 00:15:09.610
So there will be
two ways to move it.

00:15:09.610 --> 00:15:12.690
One is to expand this distance,
the other is to contract it.

00:15:12.690 --> 00:15:15.250
And the one that
expands that distance

00:15:15.250 --> 00:15:17.770
will expand all distances.

00:15:17.770 --> 00:15:22.730
So if you look at some
other pair, like this guy,

00:15:22.730 --> 00:15:27.790
every other pair of distances
will expand or stay the same.

00:15:27.790 --> 00:15:30.690
So this thing is expansive.

00:15:33.930 --> 00:15:35.670
But not strictly
expensive, because we're

00:15:35.670 --> 00:15:37.250
preserving these lengths.

00:15:37.250 --> 00:15:39.720
These ones will stay the same.

00:15:39.720 --> 00:15:43.990
So let me show you some of
the things that can happen.

00:15:43.990 --> 00:15:46.742
So this is sort of at the
heart of the algorithm.

00:15:46.742 --> 00:15:48.450
I'm not going to go
into all the details.

00:15:48.450 --> 00:15:52.230
This can happen like n
cubed times, where you say,

00:15:52.230 --> 00:15:53.862
OK I've added in
all these edges.

00:15:53.862 --> 00:15:55.320
Here's a nice
pseudo-triangle here.

00:15:55.320 --> 00:15:57.470
It happens to be a triangle with
some stuff on the bottom, stuff

00:15:57.470 --> 00:15:58.230
on the top.

00:15:58.230 --> 00:16:00.325
As I flex this to
expand the distances

00:16:00.325 --> 00:16:01.866
this is going to move like that.

00:16:01.866 --> 00:16:03.240
At some point,
those three points

00:16:03.240 --> 00:16:06.720
will become collinear,
got to deal with that.

00:16:06.720 --> 00:16:10.230
And the way you deal with it
is as you continue moving,

00:16:10.230 --> 00:16:13.480
it's no longer the case
that those two blue edges

00:16:13.480 --> 00:16:15.530
are the edges in the
pseudo-triangulation.

00:16:15.530 --> 00:16:17.574
Now it's this one red edge.

00:16:17.574 --> 00:16:18.490
This is called a flip.

00:16:18.490 --> 00:16:20.323
And you see, we used
to have a quadrilateral

00:16:20.323 --> 00:16:22.180
up here an a triangle down here.

00:16:22.180 --> 00:16:26.030
Now we have a triangle up here
and a quadrilateral over here.

00:16:26.030 --> 00:16:27.655
That's pretty intuitive.

00:16:27.655 --> 00:16:29.530
You preserve that it's
a pseudo-triangulation

00:16:29.530 --> 00:16:32.610
as you move this.

00:16:32.610 --> 00:16:35.660
If you tried to go
too far here you

00:16:35.660 --> 00:16:38.130
would actually get a
convex quadrilateral.

00:16:38.130 --> 00:16:40.897
If this kept going
then this would

00:16:40.897 --> 00:16:41.980
be a convex quadrilateral.

00:16:41.980 --> 00:16:43.396
That's not a
pseudo-triangulation,

00:16:43.396 --> 00:16:44.265
that's bad.

00:16:44.265 --> 00:16:45.640
But you can always
do these flips

00:16:45.640 --> 00:16:46.724
to fix it as you go along.

00:16:46.724 --> 00:16:48.306
And it turns out
this will only happen

00:16:48.306 --> 00:16:49.520
a polynomial number of times.

00:16:49.520 --> 00:16:51.830
AUDIENCE: [INAUDIBLE].

00:16:51.830 --> 00:16:54.051
PROFESSOR: Like shown,
is how I flipped it.

00:16:54.051 --> 00:16:56.410
AUDIENCE: Is it
[INAUDIBLE] to a red?

00:16:56.410 --> 00:17:02.310
PROFESSOR: Yeah, the red edge
now goes from here to there.

00:17:02.310 --> 00:17:04.280
Whereas before there
were two segments that

00:17:04.280 --> 00:17:05.863
went from here to
there, now I'm going

00:17:05.863 --> 00:17:08.060
to go straight from
there to there.

00:17:08.060 --> 00:17:11.230
That's the difference.

00:17:11.230 --> 00:17:14.480
This is the general picture,
you have to believe me,

00:17:14.480 --> 00:17:17.310
because I want to talk
about other things.

00:17:17.310 --> 00:17:18.619
And, cool.

00:17:18.619 --> 00:17:21.890
So here's an example
of it actually running.

00:17:21.890 --> 00:17:25.510
So we have some polygon
in the top left.

00:17:25.510 --> 00:17:28.750
We've deleted the
edge that's cyan.

00:17:28.750 --> 00:17:31.930
So that one's going to expand.

00:17:31.930 --> 00:17:34.940
And we move a little bit.

00:17:34.940 --> 00:17:36.810
This is moving a little bit.

00:17:36.810 --> 00:17:38.770
This is moving a
little bit more.

00:17:38.770 --> 00:17:40.770
At this point, these three
points are collinear.

00:17:40.770 --> 00:17:43.061
Actually, the way it's drawn
it looks like a little bit

00:17:43.061 --> 00:17:44.010
too far.

00:17:44.010 --> 00:17:45.326
But they should be collinear.

00:17:45.326 --> 00:17:46.950
That would be a
violation, because this

00:17:46.950 --> 00:17:48.510
would be-- if we go
any farther-- that

00:17:48.510 --> 00:17:50.100
would be a violation because
this would be a convex

00:17:50.100 --> 00:17:51.180
quadrilateral.

00:17:51.180 --> 00:17:55.357
So we do a flip here, and we
end up with that edge instead.

00:17:55.357 --> 00:17:56.940
So now everything's
a pseudo-triangle,

00:17:56.940 --> 00:17:59.700
everything's pointed,
everything's happy.

00:17:59.700 --> 00:18:02.970
You keep going, then these
three points become collinear.

00:18:02.970 --> 00:18:04.960
So you end up getting that edge.

00:18:04.960 --> 00:18:06.800
And you keep going.

00:18:06.800 --> 00:18:11.040
And all throughout this
motion all pairwise distances

00:18:11.040 --> 00:18:12.250
are not decreasing.

00:18:12.250 --> 00:18:14.800
Everything's expanding
or staying the same.

00:18:14.800 --> 00:18:17.530
And then the wrap
up looks like this.

00:18:17.530 --> 00:18:19.714
In the end, you get
a convex polygon.

00:18:19.714 --> 00:18:21.130
Then you're stuck,
because there's

00:18:21.130 --> 00:18:23.817
no edge to remove
on the outside.

00:18:23.817 --> 00:18:25.400
You've got to keep
all of those edges.

00:18:27.970 --> 00:18:30.750
So that is the
pseudo-triangulation method

00:18:30.750 --> 00:18:31.670
in a nutshell.

00:18:31.670 --> 00:18:34.400
And it's expansive.

00:18:34.400 --> 00:18:41.150
It has a polynomial
in n number of moves.

00:18:48.640 --> 00:18:52.920
It's not clear how quickly
you can compute the moves.

00:18:57.750 --> 00:18:59.420
I know an exponential
time algorithm.

00:18:59.420 --> 00:19:01.070
There might be faster one.

00:19:01.070 --> 00:19:02.620
I don't think this
has been resolved.

00:19:02.620 --> 00:19:05.930
Let me just check my notes here.

00:19:05.930 --> 00:19:08.290
It says best algorithm
is exponential to compute

00:19:08.290 --> 00:19:08.790
one move.

00:19:08.790 --> 00:19:10.340
In these examples,
where they're all

00:19:10.340 --> 00:19:12.590
quadrilaterals or
triangles, it's

00:19:12.590 --> 00:19:14.190
really easy to compute them.

00:19:14.190 --> 00:19:16.950
In general, if you get
complicated things,

00:19:16.950 --> 00:19:17.494
it's unclear.

00:19:17.494 --> 00:19:19.910
Pseudo-triangulations though
have a lot of nice structure.

00:19:19.910 --> 00:19:24.660
So maybe it's easier than
general linkage folding.

00:19:24.660 --> 00:19:27.050
This, I have here,
implementing this algorithm

00:19:27.050 --> 00:19:30.430
would be a cool project.

00:19:30.430 --> 00:19:33.210
Oh, another open problem
is how many steps

00:19:33.210 --> 00:19:34.990
does this algorithm really need?

00:19:34.990 --> 00:19:37.045
Can you prove a
pseudo-polynomial bound?

00:19:37.045 --> 00:19:38.880
I'm not sure.

00:19:38.880 --> 00:19:43.150
But let me tell you about my
personal favorite algorithm,

00:19:43.150 --> 00:19:46.340
the energy method.

00:19:46.340 --> 00:19:52.980
This is also the
most recent, in 2004.

00:19:52.980 --> 00:19:54.480
The weird thing
about this algorithm

00:19:54.480 --> 00:19:55.745
is that it is not expansive.

00:20:01.586 --> 00:20:03.835
It's really easy to compute
one step of the algorithm.

00:20:06.420 --> 00:20:10.700
I can do it in quadratic
time, even exactly.

00:20:14.880 --> 00:20:17.690
This one you have to specify
some error tolerance epsilon.

00:20:17.690 --> 00:20:20.160
This one you have to specify
some error tolerance epsilon.

00:20:20.160 --> 00:20:24.480
Here you can do it perfectly
if you have exact square roots.

00:20:24.480 --> 00:20:27.800
And the number of
steps is also small.

00:20:38.570 --> 00:20:41.250
It has a pseudo-polynomial
number of steps.

00:20:41.250 --> 00:20:44.070
Have I talked about
pseudo-polynomial yet?

00:20:44.070 --> 00:20:45.510
Maybe, briefly at some point.

00:20:45.510 --> 00:20:49.890
Let me tell you what I mean.

00:20:49.890 --> 00:20:52.290
I want to be polynomial
in the number vertices

00:20:52.290 --> 00:20:55.672
n and another parameter r.

00:20:55.672 --> 00:20:59.370
r is going to be, basically,
the maximum distance

00:20:59.370 --> 00:21:01.780
in your initial
configuration divided

00:21:01.780 --> 00:21:04.050
by the minimum distance.

00:21:04.050 --> 00:21:07.040
Exactly how you define
distance, don't worry about it.

00:21:07.040 --> 00:21:08.600
Not a big deal.

00:21:08.600 --> 00:21:10.810
So this is a geometric
feature of the input.

00:21:10.810 --> 00:21:12.116
It has nothing to do with n.

00:21:12.116 --> 00:21:13.740
n could stay fixed
and you could change

00:21:13.740 --> 00:21:15.780
this to whatever
you want by making

00:21:15.780 --> 00:21:17.620
nastier and nastier examples.

00:21:17.620 --> 00:21:21.900
Nastiness is measured here by
how big your linkages versus

00:21:21.900 --> 00:21:24.130
how tight things get.

00:21:24.130 --> 00:21:25.890
So as long as that's
reasonable, this

00:21:25.890 --> 00:21:28.090
is going to be a
polynomial number of moves.

00:21:28.090 --> 00:21:29.110
So this is a good bound.

00:21:29.110 --> 00:21:32.940
It's better than all the others
that's been proved anyway.

00:21:32.940 --> 00:21:35.980
It might hold for some
of the other methods.

00:21:35.980 --> 00:21:38.370
Here, of course, we have a
better bound on the number

00:21:38.370 --> 00:21:38.870
moves.

00:21:38.870 --> 00:21:40.470
But each move is
kind of complicated.

00:21:40.470 --> 00:21:43.090
It's pseudo-triangulation.

00:21:43.090 --> 00:21:44.840
So there is a trade
off between complexity

00:21:44.840 --> 00:21:46.737
of move and number of moves.

00:21:46.737 --> 00:21:48.570
But this gets a decent
bound for everything.

00:21:52.201 --> 00:21:53.200
You've seen this method.

00:21:53.200 --> 00:21:55.690
I showed it in lecture one.

00:21:55.690 --> 00:22:01.450
But it's interesting to contrast
it with the CDR method, which

00:22:01.450 --> 00:22:04.130
sort of unrolled the
teeth from the end.

00:22:04.130 --> 00:22:08.490
Here, this method basically
pulls the teeth right apart.

00:22:08.490 --> 00:22:12.940
And that's possible because it's
not required to be expansive.

00:22:12.940 --> 00:22:16.850
And we have the double tree.

00:22:19.529 --> 00:22:21.070
This one looks more
or less the same.

00:22:21.070 --> 00:22:23.572
It's a little smoother, I would
say, than the other method.

00:22:23.572 --> 00:22:24.780
I don't have it side by side.

00:22:24.780 --> 00:22:27.674
So it's a little hard to guess.

00:22:27.674 --> 00:22:29.840
And what's really exciting
about this method, to me,

00:22:29.840 --> 00:22:33.230
is that you can run it
for really large examples

00:22:33.230 --> 00:22:34.910
in like a minute or so.

00:22:34.910 --> 00:22:37.620
500 vertices, no big deal.

00:22:37.620 --> 00:22:39.820
Whereas, because each
step is pretty easy

00:22:39.820 --> 00:22:42.420
to compute in quadratic
time, with this method

00:22:42.420 --> 00:22:46.470
you need it to solve
a convex program.

00:22:46.470 --> 00:22:49.655
And that's a little
costly for large examples.

00:22:53.200 --> 00:22:54.370
Cool.

00:22:54.370 --> 00:22:55.930
So that's the energy method.

00:22:55.930 --> 00:22:57.930
Now I'm going to actually
tell you how it works.

00:23:01.934 --> 00:23:03.475
Big difference is
it's not expansive.

00:23:09.510 --> 00:23:12.240
And the idea is,
well, being expansive

00:23:12.240 --> 00:23:14.710
on every edge,
that's kind of hard.

00:23:14.710 --> 00:23:15.780
How do I figure that out?

00:23:15.780 --> 00:23:17.100
Oh, it makes my brain hurt.

00:23:17.100 --> 00:23:18.930
I've got to solve
this tensegrity.

00:23:18.930 --> 00:23:22.800
But if I was just
expansive on average,

00:23:22.800 --> 00:23:24.570
maybe that would be good enough.

00:23:24.570 --> 00:23:27.150
That's the crazy idea.

00:23:27.150 --> 00:23:38.610
So we define this energy
function that does just that.

00:23:38.610 --> 00:23:40.156
It's a function
on configurations.

00:23:47.290 --> 00:23:54.230
So I'm going to write E of
C. No M in this equation.

00:23:54.230 --> 00:24:00.390
We're going to sum over all
edges Ew, and then sum over all

00:24:00.390 --> 00:24:06.300
vertices U different
from V and W.

00:24:06.300 --> 00:24:11.600
And we're going to take 1
over the distance from U

00:24:11.600 --> 00:24:13.990
to the edge.

00:24:13.990 --> 00:24:17.610
This is just saying sum over
all non-incident vertices

00:24:17.610 --> 00:24:20.784
and edges, take their
distance-- there's

00:24:20.784 --> 00:24:23.200
many ways you could define
that, like the minimum distance

00:24:23.200 --> 00:24:25.970
between them would be
fine-- take the reciprocal,

00:24:25.970 --> 00:24:27.450
add them all up.

00:24:27.450 --> 00:24:29.900
This is my energy function.

00:24:29.900 --> 00:24:30.920
Kind of weird.

00:24:30.920 --> 00:24:34.560
But it's averaging
not of distances,

00:24:34.560 --> 00:24:36.640
but 1 over distances.

00:24:36.640 --> 00:24:38.150
So why is that so interesting?

00:24:38.150 --> 00:24:41.110
Because distances
are always positive.

00:24:41.110 --> 00:24:42.790
So I only have to go over here.

00:24:42.790 --> 00:24:45.590
If I write distance
in the x-axis,

00:24:45.590 --> 00:24:49.940
and 1 over the
distance in the y-axis,

00:24:49.940 --> 00:24:52.550
the plot of that
function looks like this.

00:24:52.550 --> 00:24:56.190
It has this vertical
asymptote at 0.

00:24:56.190 --> 00:24:59.740
So if the distance were to
go to 0, which is bad for me

00:24:59.740 --> 00:25:02.620
because that's one thing start
crossing-- they will start

00:25:02.620 --> 00:25:05.760
touching at d equals 0, and
after that they might cross--

00:25:05.760 --> 00:25:09.360
the energy shoots to
positive infinity.

00:25:09.360 --> 00:25:12.630
So if I take the sum over all
these, if any of the distances

00:25:12.630 --> 00:25:17.890
decrease to 0 then the energy
will shoot to infinity.

00:25:17.890 --> 00:25:20.960
What if my distances increase?

00:25:20.960 --> 00:25:24.717
Because I know
expansive motions exist.

00:25:24.717 --> 00:25:26.050
That's what we proved last time.

00:25:28.560 --> 00:25:30.390
I'm not going to compute them.

00:25:30.390 --> 00:25:33.240
But I know they're
out there somewhere.

00:25:33.240 --> 00:25:36.080
If I had an expansive motion,
all of these distances

00:25:36.080 --> 00:25:38.210
increase.

00:25:38.210 --> 00:25:41.810
So that means this
reciprocal decreases.

00:25:41.810 --> 00:25:43.320
So I have-- it's
hard to imagine--

00:25:43.320 --> 00:25:46.150
I have this giant dimensional
configuration space.

00:25:46.150 --> 00:25:48.295
It has d times n
dimensions, whatever.

00:25:48.295 --> 00:25:49.140
A lot of stuff.

00:25:51.660 --> 00:25:53.910
I'm somewhere.

00:25:53.910 --> 00:25:57.280
But if I now plotted--
imagine that's

00:25:57.280 --> 00:26:00.190
in two dimensions,
in the plane here,

00:26:00.190 --> 00:26:02.580
so that's there-- and then
in the third dimension I

00:26:02.580 --> 00:26:04.430
plot what is this
energy landscape.

00:26:04.430 --> 00:26:06.840
For each of these configurations
I compute some height.

00:26:06.840 --> 00:26:08.080
What is my energy?

00:26:08.080 --> 00:26:10.690
I get some 3D surface here.

00:26:10.690 --> 00:26:15.050
In general, it's going to be
d times n plus 1 dimensions.

00:26:15.050 --> 00:26:16.350
Here's the configuration space.

00:26:16.350 --> 00:26:18.540
We plot over that.

00:26:18.540 --> 00:26:21.880
What I'm saying is, because
expansive motions exist,

00:26:21.880 --> 00:26:24.030
there has to be a motion
for every point that

00:26:24.030 --> 00:26:25.966
decreases energy.

00:26:25.966 --> 00:26:27.590
Because if you decrease
every distance,

00:26:27.590 --> 00:26:31.310
you also decrease them
on average in this sense.

00:26:31.310 --> 00:26:34.740
If every term decreases,
then of course, the sum will.

00:26:34.740 --> 00:26:45.230
So this means energy
decreasing motions exist.

00:26:49.616 --> 00:26:51.950
Now energy decreasing
feels like a good thing.

00:26:51.950 --> 00:26:57.480
Because I start somewhere, it
has some energy, not infinity.

00:26:57.480 --> 00:26:59.990
If I decrease the energy,
it's really hard for my energy

00:26:59.990 --> 00:27:01.912
to go to plus infinity.

00:27:01.912 --> 00:27:03.880
It can't happen.

00:27:03.880 --> 00:27:12.890
So all I need to do is follow
any energy decreasing motion.

00:27:18.830 --> 00:27:21.790
It might be an expansive
one, but probably not.

00:27:21.790 --> 00:27:23.790
We know that there are
energy decreasing motions

00:27:23.790 --> 00:27:25.732
because there are
expansive motions.

00:27:25.732 --> 00:27:27.440
But let's just take
any energy decreasing

00:27:27.440 --> 00:27:30.960
motion, sort of
expansive on average.

00:27:30.960 --> 00:27:38.262
Then it won't self-intersect
because if energy decreases

00:27:38.262 --> 00:27:39.720
it will never get
to plus infinity.

00:27:39.720 --> 00:27:41.761
And therefore none of the
distances will go to 0.

00:27:44.500 --> 00:27:48.820
So what this algorithm does
is follow the gradient.

00:27:57.500 --> 00:28:00.500
So I should say something
about what this notation is.

00:28:00.500 --> 00:28:02.860
This is whatever,
higher order calculus.

00:28:06.340 --> 00:28:09.120
You live in some space.

00:28:09.120 --> 00:28:10.940
You're on like some
hill, or whatever.

00:28:10.940 --> 00:28:13.380
You're on some surface.

00:28:13.380 --> 00:28:16.322
And you say well I'd really
like to go downhill from here.

00:28:16.322 --> 00:28:18.030
And there might be
many downhill options.

00:28:18.030 --> 00:28:19.488
There might be many
uphill options.

00:28:19.488 --> 00:28:21.960
This is some crazy high
dimensional choice.

00:28:21.960 --> 00:28:24.790
Just take the option
that decreases energy

00:28:24.790 --> 00:28:27.210
the fastest, the most downhill.

00:28:27.210 --> 00:28:32.260
That is negative gradient of
E. Believe me that it exists.

00:28:32.260 --> 00:28:34.990
It exists because this
energy function is smooth,

00:28:34.990 --> 00:28:35.790
in some sense.

00:28:38.180 --> 00:28:39.930
You're basically taking
first derivatives.

00:28:39.930 --> 00:28:41.910
That gives you the
highest chain--

00:28:41.910 --> 00:28:44.390
or you take the place that has
the highest change and boom.

00:28:44.390 --> 00:28:45.264
That gives it to you.

00:28:45.264 --> 00:28:47.510
It's very easy to compute
because this function has

00:28:47.510 --> 00:28:48.690
quadratically many terms.

00:28:48.690 --> 00:28:51.930
It takes about n
squared time to find it.

00:28:51.930 --> 00:28:56.550
And that gives you some
energy decrease in motion.

00:28:56.550 --> 00:28:57.990
It's just an easy one to find.

00:28:57.990 --> 00:29:00.480
And that's what we're
animating all the time.

00:29:00.480 --> 00:29:02.570
So we just find energy
decreasing motion,

00:29:02.570 --> 00:29:04.230
move a little bit
in that direction.

00:29:04.230 --> 00:29:06.040
Not too much,
because if you go--

00:29:06.040 --> 00:29:07.960
it's again a first derivative.

00:29:07.960 --> 00:29:09.710
This is only an
infinitesimal motion.

00:29:09.710 --> 00:29:12.330
But we're actually going
to move in that direction

00:29:12.330 --> 00:29:13.740
for a positive amount of time.

00:29:13.740 --> 00:29:16.010
As long as we don't go too
far, and we can find how

00:29:16.010 --> 00:29:19.370
far by binary search,
we won't self-intersect.

00:29:19.370 --> 00:29:21.350
Because we know locally
it's decreasing energy.

00:29:21.350 --> 00:29:25.140
If we go small enough step it
really will decrease energy,

00:29:25.140 --> 00:29:26.660
and then life is good.

00:29:26.660 --> 00:29:30.600
So it's really easy to do this.

00:29:30.600 --> 00:29:33.170
Super simple algorithm.

00:29:33.170 --> 00:29:35.150
Good.

00:29:35.150 --> 00:29:37.460
It's non-expansive
because we're only

00:29:37.460 --> 00:29:41.932
decreasing the average,
not each of the terms.

00:29:41.932 --> 00:29:44.730
Do, do, do, do, do.

00:29:44.730 --> 00:29:47.470
You can prove the
number of steps--

00:29:47.470 --> 00:29:53.130
this is the part I'm most proud
of here-- is pseudo-polynomial,

00:29:53.130 --> 00:29:58.220
polynomial in n and r.

00:29:58.220 --> 00:30:00.420
What is the polynomial?

00:30:00.420 --> 00:30:06.010
n to the 123 times r to the 81.

00:30:06.010 --> 00:30:07.880
This is the largest
polynomial bound

00:30:07.880 --> 00:30:11.960
I know of that's not
dependent on dimension.

00:30:11.960 --> 00:30:12.710
So I'm very proud.

00:30:12.710 --> 00:30:15.270
In practice, the number of
steps is much, much smaller

00:30:15.270 --> 00:30:15.770
than this.

00:30:15.770 --> 00:30:17.870
This is what we could
prove in an easy way.

00:30:17.870 --> 00:30:20.000
If you want a project,
it's a little tedious,

00:30:20.000 --> 00:30:21.700
but it would be easy,
I'm pretty sure.

00:30:21.700 --> 00:30:24.070
You could decrease
this to, I don't know,

00:30:24.070 --> 00:30:26.670
at least n to the
20 or something

00:30:26.670 --> 00:30:28.720
by being a little more
careful on the analysis.

00:30:28.720 --> 00:30:30.886
But once we got something
that was pseudo-polynomial

00:30:30.886 --> 00:30:32.010
we were happy.

00:30:32.010 --> 00:30:34.822
So we could leave others to
figure out the right bound.

00:30:34.822 --> 00:30:37.280
It's a little tricky with these
gradient descent algorithms

00:30:37.280 --> 00:30:38.734
to get good bounds.

00:30:38.734 --> 00:30:40.150
In practice they
work really well,

00:30:40.150 --> 00:30:41.830
because the gradient
is not as nasty

00:30:41.830 --> 00:30:44.640
as you might imagine it
to be in the worst case.

00:30:44.640 --> 00:30:47.670
But the worst case bound,
hey, it's pseudo-polynomial.

00:30:47.670 --> 00:30:49.290
It's a nice
theoretical guarantee.

00:30:49.290 --> 00:30:51.350
And in practice it
also happens to work.

00:30:51.350 --> 00:30:53.230
Like these examples
only take, I don't know,

00:30:53.230 --> 00:30:55.950
a few hundred steps,
1,000 steps, whatever.

00:30:55.950 --> 00:30:58.510
AUDIENCE: Where do
those numbers come from?

00:30:58.510 --> 00:31:00.370
PROFESSOR: Where
does 123 come from?

00:31:00.370 --> 00:31:02.140
We really wanted
it to be 1, 2, 3.

00:31:02.140 --> 00:31:03.796
81 is my birth year.

00:31:03.796 --> 00:31:05.404
[LAUGHTER]

00:31:05.404 --> 00:31:07.445
PROFESSOR: That's why I
like this number so much.

00:31:07.445 --> 00:31:09.760
Oh, actually here
I have 41 written.

00:31:09.760 --> 00:31:11.080
I'm pretty sure it's 81 though.

00:31:11.080 --> 00:31:15.362
I should correct the notes,
double check, something.

00:31:15.362 --> 00:31:18.730
It's really you're just adding
up twos and threes a lot,

00:31:18.730 --> 00:31:21.310
and fours, and things like
that a whole bunch of times.

00:31:21.310 --> 00:31:24.090
And then just luckily it
came out to a nice number.

00:31:24.090 --> 00:31:26.894
As far as I know,
not intentional.

00:31:26.894 --> 00:31:28.810
There are few authors
though, so I don't know.

00:31:28.810 --> 00:31:31.870
Maybe one of them increased
a bound to make it a little

00:31:31.870 --> 00:31:35.480
cooler number in the end.

00:31:35.480 --> 00:31:37.767
Good.

00:31:37.767 --> 00:31:39.600
So that's pseudo-polynomial
number of steps.

00:31:39.600 --> 00:31:41.000
It's interesting,
each of the steps

00:31:41.000 --> 00:31:42.291
is actually a very nice motion.

00:31:42.291 --> 00:31:44.080
It just moves along
a straight line

00:31:44.080 --> 00:31:45.580
in the configuration space.

00:31:45.580 --> 00:31:47.580
I would be nice to know
whether you can actually

00:31:47.580 --> 00:31:50.800
achieve a polynomial number
of steps independent of r.

00:31:50.800 --> 00:31:52.220
I think the answer
is no, it's not

00:31:52.220 --> 00:31:55.629
possible for some linkages
that are really tight.

00:31:55.629 --> 00:31:57.920
I think you need a dependence,
a polynomial dependence,

00:31:57.920 --> 00:32:00.075
on r-- at least a
linear dependence on r.

00:32:00.075 --> 00:32:01.550
But I don't know
how to prove that.

00:32:01.550 --> 00:32:03.830
It's a nice open problem.

00:32:03.830 --> 00:32:07.210
Another fun problem, these
examples with polygons

00:32:07.210 --> 00:32:12.210
end up with a particular
convex shape in the end.

00:32:12.210 --> 00:32:13.650
Is that shape unique?

00:32:13.650 --> 00:32:15.650
If I gave you the sequence
of edge lengths here,

00:32:15.650 --> 00:32:18.190
they're all 1, or
they're almost 1.

00:32:18.190 --> 00:32:19.196
Not quite the same.

00:32:19.196 --> 00:32:21.320
No, sorry, they get tinier
as you go to the center.

00:32:21.320 --> 00:32:22.903
But for that sequence
of edge lengths,

00:32:22.903 --> 00:32:25.390
is there a unique minimum
energy configuration?

00:32:25.390 --> 00:32:26.430
I think so.

00:32:26.430 --> 00:32:29.390
But I don't know.

00:32:29.390 --> 00:32:31.640
We know that this method
will get to convex,

00:32:31.640 --> 00:32:33.930
because only at the
convex configuration

00:32:33.930 --> 00:32:35.640
do you no longer have
an expansive motion

00:32:35.640 --> 00:32:40.320
and no longer have a decreasing
energy motion, maybe.

00:32:40.320 --> 00:32:40.820
Cool.

00:32:40.820 --> 00:32:42.150
Those are the three algorithms.

00:32:42.150 --> 00:32:43.300
Any questions about them?

00:32:49.230 --> 00:32:52.715
Before we go to trees, again,
tell you a cool application

00:32:52.715 --> 00:33:02.905
to origami, which
is to rigid origami.

00:33:07.040 --> 00:33:10.900
Remember, rigid origami, we're
not allowed to add any creases.

00:33:10.900 --> 00:33:15.370
And all of the faces between
creases have to stay flat.

00:33:15.370 --> 00:33:17.130
They're like made
of-- imagine you

00:33:17.130 --> 00:33:19.920
have pieces of metal
representing the faces.

00:33:19.920 --> 00:33:22.730
You have piano hinges
making the edges.

00:33:22.730 --> 00:33:24.010
That's rigid origami.

00:33:24.010 --> 00:33:25.270
That's kind of like a linkage.

00:33:25.270 --> 00:33:27.600
In particular, when you
have a single vertex

00:33:27.600 --> 00:33:35.060
origami-- say that's five
foldable, I don't know.

00:33:35.060 --> 00:33:37.020
And if you say each
of these wedges

00:33:37.020 --> 00:33:41.560
is a rigid piece of
metal, well we already

00:33:41.560 --> 00:33:46.380
know this kind of set up can
be modeled by its boundary.

00:33:46.380 --> 00:33:47.980
Ignore the interior.

00:33:47.980 --> 00:33:51.260
Just think of there
being hinges of this one

00:33:51.260 --> 00:33:56.040
dimensional structure like that.

00:33:56.040 --> 00:33:59.110
So that looks a
lot like a linkage.

00:33:59.110 --> 00:34:01.170
These have to stay rigid.

00:34:01.170 --> 00:34:02.400
They're not straight lines.

00:34:02.400 --> 00:34:03.780
It's a little different.

00:34:03.780 --> 00:34:05.400
It's almost the same.

00:34:05.400 --> 00:34:08.227
If you think about how you're
allowed to fold these things--

00:34:08.227 --> 00:34:09.810
really you should
think about it here,

00:34:09.810 --> 00:34:14.310
I guess-- what happens, by
a continuous motion what

00:34:14.310 --> 00:34:17.600
happens is that you're
living on a sphere.

00:34:17.600 --> 00:34:22.290
So you start out on the
equator of the sphere.

00:34:22.290 --> 00:34:24.040
This thing, just plop
it down the equator.

00:34:24.040 --> 00:34:26.139
The boundary lies on the
boundary of the sphere.

00:34:26.139 --> 00:34:28.659
The interior of the paper
is inside the sphere,

00:34:28.659 --> 00:34:31.659
right along the flat part there.

00:34:31.659 --> 00:34:35.909
As you fold, these points
will stay on the sphere.

00:34:35.909 --> 00:34:38.590
And these edge links
will be preserved,

00:34:38.590 --> 00:34:39.940
their arcs on the spheres.

00:34:39.940 --> 00:34:42.580
There will be great
circular arcs at all times.

00:34:42.580 --> 00:34:44.710
So folding this
thing in three space

00:34:44.710 --> 00:34:50.150
is really equivalent to folding
this linkage on the sphere.

00:34:50.150 --> 00:34:52.650
And that looks an awful lot
like a polygon on a sphere.

00:34:52.650 --> 00:34:55.659
What we really want is a
spherical Carpenter's Rule

00:34:55.659 --> 00:34:56.159
Theorem.

00:35:02.980 --> 00:35:05.430
And there is.

00:35:05.430 --> 00:35:07.190
This is by Streinu and Whiteley.

00:35:10.940 --> 00:35:22.370
So if you have a closed chain,
a polygon, of total length

00:35:22.370 --> 00:35:32.290
at most 2 pi on a
unit sphere then you

00:35:32.290 --> 00:35:35.195
have a connected
configuration space.

00:35:41.320 --> 00:35:44.421
So in the plane,
closed chain always

00:35:44.421 --> 00:35:45.920
had a connected
configuration space.

00:35:45.920 --> 00:35:50.002
On the sphere you need that
the chain is not too long,

00:35:50.002 --> 00:35:52.210
because there's only sort
of a bounded amount of room

00:35:52.210 --> 00:35:53.310
on the sphere.

00:35:53.310 --> 00:36:03.720
The equator has total length 2
pi, perimeter of the equator.

00:36:03.720 --> 00:36:06.230
For unit sphere it's 2 pi.

00:36:06.230 --> 00:36:08.540
So we're just canonically
making it a unit sphere.

00:36:08.540 --> 00:36:10.940
And 2 pi really corresponds
to this situation,

00:36:10.940 --> 00:36:12.520
which is 360 degrees.

00:36:12.520 --> 00:36:14.190
That's how much
total length we have.

00:36:14.190 --> 00:36:16.629
So it just fits in the
equator, life is good.

00:36:16.629 --> 00:36:18.170
The reason you want
it to have length

00:36:18.170 --> 00:36:20.700
at most 2 pi is because
then you actually do

00:36:20.700 --> 00:36:22.880
have a convex configuration.

00:36:22.880 --> 00:36:25.040
In the case of 2 pi, it
lies along the equator.

00:36:25.040 --> 00:36:28.980
If it's smaller than 2 pi it'll
be like some smaller portion.

00:36:28.980 --> 00:36:32.100
This would be less than
2 pi on the sphere.

00:36:35.600 --> 00:36:38.917
If it's greater than 2 pi,
you can't draw it convexly

00:36:38.917 --> 00:36:39.500
on the sphere.

00:36:39.500 --> 00:36:40.480
You can draw something.

00:36:40.480 --> 00:36:42.410
Like I could draw
something like this,

00:36:42.410 --> 00:36:46.090
that'll have really long
length on the sphere.

00:36:46.090 --> 00:36:48.160
But there will be no
way to convexify it.

00:36:48.160 --> 00:36:50.480
You get stuck at some point.

00:36:50.480 --> 00:36:52.670
And as long as you don't
have that situation,

00:36:52.670 --> 00:36:55.210
you can take this--
what this actually

00:36:55.210 --> 00:36:57.300
implies is that your
polygon at all times

00:36:57.300 --> 00:36:58.940
will lie in a hemisphere.

00:36:58.940 --> 00:37:01.400
You take that hemisphere
and you sort of unroll it,

00:37:01.400 --> 00:37:04.010
you splay it out, you
project it to the plane.

00:37:04.010 --> 00:37:06.630
You apply the planar
Carpenter's Rule Theorem.

00:37:06.630 --> 00:37:09.770
You apply the fact that
unrolling operation,

00:37:09.770 --> 00:37:11.970
or that projection
if you will-- I

00:37:11.970 --> 00:37:17.200
think it's like
projection from some point

00:37:17.200 --> 00:37:21.730
here out to the plane--
that projection preserves

00:37:21.730 --> 00:37:26.520
infinitesimal flexibility
of tensegrities.

00:37:26.520 --> 00:37:29.630
So it'll still have the
expensive motion in the plane.

00:37:29.630 --> 00:37:33.590
And then you could turn in to an
expansive motion on the sphere.

00:37:33.590 --> 00:37:36.620
And eventually you'll
get a convex polygon.

00:37:36.620 --> 00:37:38.850
So that's sort of
how this is proved.

00:37:38.850 --> 00:37:41.020
Then you can apply
it to rigid origami,

00:37:41.020 --> 00:37:42.870
and say for single
vertex origami,

00:37:42.870 --> 00:37:44.920
it's always rigidly foldable.

00:37:44.920 --> 00:37:46.950
Any state you want
to reach can be

00:37:46.950 --> 00:37:50.332
reached by continuous
motion, without bending

00:37:50.332 --> 00:37:51.040
any of the faces.

00:37:53.890 --> 00:37:55.190
So a fun little application.

00:38:01.320 --> 00:38:04.250
And one of the few things
we know about rigid origami,

00:38:04.250 --> 00:38:08.170
for multiple vertices
it gets a lot harder.

00:38:08.170 --> 00:38:11.527
Not always possible,
and we don't

00:38:11.527 --> 00:38:12.735
have a nice characterization.

00:38:24.480 --> 00:38:29.900
So finally, let's move onto
locked trees in the plane.

00:38:34.910 --> 00:38:38.100
So these are sort of
the classic examples.

00:38:38.100 --> 00:38:41.520
The top two were
in a 1998 paper.

00:38:41.520 --> 00:38:46.010
This was when I started
working on folding stuff, very

00:38:46.010 --> 00:38:47.366
beginning.

00:38:47.366 --> 00:38:52.120
A whole bunch of people
from a big workshop.

00:38:52.120 --> 00:38:53.970
First example is this one.

00:38:53.970 --> 00:39:00.080
And it's a bunch of sort of
arms tucked into their armpits,

00:39:00.080 --> 00:39:02.550
and in a cyclic way.

00:39:02.550 --> 00:39:06.680
And the dotted circles
mean objects in this mirror

00:39:06.680 --> 00:39:08.530
are closer than they appear.

00:39:08.530 --> 00:39:13.270
So imagine that
all of these points

00:39:13.270 --> 00:39:17.050
are actually really, really
close and tight in here.

00:39:17.050 --> 00:39:19.140
And this guy's actually
really close and tight

00:39:19.140 --> 00:39:21.212
against this edge.

00:39:21.212 --> 00:39:22.670
So I've drawn it
with lots of slack

00:39:22.670 --> 00:39:24.461
so you can see the
combinatorial structure.

00:39:24.461 --> 00:39:27.070
But geometrically
it's much tighter.

00:39:27.070 --> 00:39:29.730
Then the intuition is that you
can't get any of these arms

00:39:29.730 --> 00:39:35.430
open unless you could somehow
expand one of these wedges.

00:39:35.430 --> 00:39:38.160
It's like, if you could
expand this angle then

00:39:38.160 --> 00:39:40.159
this guy would have
room to come out.

00:39:40.159 --> 00:39:41.450
But how do I expand that angle?

00:39:41.450 --> 00:39:43.533
Well I'd have to compress
the other angles because

00:39:43.533 --> 00:39:44.470
of the cyclic picture.

00:39:44.470 --> 00:39:47.450
And I can't, if I look at some
other angle like this one,

00:39:47.450 --> 00:39:50.830
I can't compress it because
the arm is in the way.

00:39:50.830 --> 00:39:54.962
So I can't open an arm until
I've closed some other arm.

00:39:54.962 --> 00:39:56.920
And I can't close an arm
before I've opened it.

00:39:56.920 --> 00:39:58.090
And so nothing can happen.

00:39:58.090 --> 00:40:00.390
That's the intuition
behind the proof.

00:40:00.390 --> 00:40:02.050
The details are very
messy, because you

00:40:02.050 --> 00:40:05.210
have to define open
and closed, and what

00:40:05.210 --> 00:40:08.140
things must happen
before what things.

00:40:08.140 --> 00:40:09.550
This example should
look familiar

00:40:09.550 --> 00:40:12.410
because if you double it, if
you replace every edge with two

00:40:12.410 --> 00:40:14.300
edges, we get one
of the examples that

00:40:14.300 --> 00:40:19.260
was expanding with the
five-fold symmetry.

00:40:19.260 --> 00:40:22.770
So people have sort
of known for a while,

00:40:22.770 --> 00:40:26.550
and then we finally proved,
that this is locked.

00:40:26.550 --> 00:40:29.250
If you double it, people thought
well maybe it's still locked.

00:40:29.250 --> 00:40:34.730
Turns out no, because the center
vertex can expand in a polygon,

00:40:34.730 --> 00:40:36.600
but with a tree it can't.

00:40:36.600 --> 00:40:38.900
OK, big deal.

00:40:38.900 --> 00:40:42.910
These examples, this is just
yet another way to do that.

00:40:42.910 --> 00:40:47.060
But what's interesting is if
you double some of the edges

00:40:47.060 --> 00:40:48.700
you get this tree.

00:40:48.700 --> 00:40:51.610
So you have 1 degree 3
vertex in the center.

00:40:51.610 --> 00:40:54.160
And you go around,
you visit this arm.

00:40:54.160 --> 00:40:56.040
You go back, you visit this arm.

00:40:56.040 --> 00:40:58.860
Turns out this really
does simulate this tree,

00:40:58.860 --> 00:41:01.720
because we haven't touched
the central degree 3 vertex.

00:41:01.720 --> 00:41:05.300
And this is nice because
it has one degree 3 vertex.

00:41:05.300 --> 00:41:07.890
Everything else
is degree 2 or 1.

00:41:07.890 --> 00:41:09.420
So in the Carpenter's
Rule theorem

00:41:09.420 --> 00:41:12.330
where we said maximum
degree 2, it's really tight.

00:41:12.330 --> 00:41:14.810
And as soon as you add
one vertex of degree 3

00:41:14.810 --> 00:41:16.800
you can be locked.

00:41:16.800 --> 00:41:20.000
That was the point
of this example.

00:41:20.000 --> 00:41:22.010
What other fun things
can you do with trees?

00:41:22.010 --> 00:41:24.610
Well, three years
ago in this class

00:41:24.610 --> 00:41:27.360
we started thinking
about other locked trees.

00:41:27.360 --> 00:41:29.510
How low could you go?

00:41:29.510 --> 00:41:31.980
How many edges do
need to get locked?

00:41:31.980 --> 00:41:36.579
This example-- no I guess
this example would be minimum.

00:41:36.579 --> 00:41:38.120
Here I've drawn it
with eight petals.

00:41:38.120 --> 00:41:40.770
You can get away
with five petals,

00:41:40.770 --> 00:41:43.200
or are five arms,
each of length 3.

00:41:43.200 --> 00:41:44.500
So that's 15 edges.

00:41:44.500 --> 00:41:46.170
That was the state of the art.

00:41:46.170 --> 00:41:50.650
And then we had this crazy
idea in a problem session

00:41:50.650 --> 00:41:55.010
of this locked
chain, locked tree.

00:41:55.010 --> 00:41:57.530
It has two degree 3 vertices.

00:41:57.530 --> 00:41:59.360
And it kind of just
winds in there.

00:41:59.360 --> 00:42:01.360
We're going to see why
these things are locked.

00:42:01.360 --> 00:42:02.170
But OK, that's kind of neat.

00:42:02.170 --> 00:42:03.740
11, that's much better than 15.

00:42:03.740 --> 00:42:04.820
Can we do better?

00:42:04.820 --> 00:42:08.890
And every week we improved
it, for a few weeks.

00:42:08.890 --> 00:42:13.140
This one looks messier,
but it has one fewer edge.

00:42:13.140 --> 00:42:16.930
And then this one came
along, and we're like whoa.

00:42:16.930 --> 00:42:20.860
So symmetric, so beautiful.

00:42:20.860 --> 00:42:25.580
What's interesting is it doesn't
have the cyclic structure.

00:42:25.580 --> 00:42:27.422
It's almost flat, in fact.

00:42:27.422 --> 00:42:29.630
You could think of all these
guys being in one point.

00:42:29.630 --> 00:42:31.030
All these guys
being in one point.

00:42:31.030 --> 00:42:32.446
All those guys
being in one point.

00:42:32.446 --> 00:42:34.460
It's like they're,
all three, collinear.

00:42:34.460 --> 00:42:36.360
So it's a very different
kind of example.

00:42:36.360 --> 00:42:38.670
Before we thought
locked trees required

00:42:38.670 --> 00:42:40.425
this kind of cyclic condition.

00:42:43.170 --> 00:42:46.950
And so, for example,
we conjectured--

00:42:46.950 --> 00:42:48.810
or I guess Poon,
one of the authors

00:42:48.810 --> 00:42:51.516
here-- conjectured that
there would be no way

00:42:51.516 --> 00:42:53.140
to lock something if
all the edges were

00:42:53.140 --> 00:42:54.750
horizontal and vertical.

00:42:54.750 --> 00:42:57.770
Because if you have
that you couldn't

00:42:57.770 --> 00:42:59.770
have five things in a circle.

00:42:59.770 --> 00:43:02.030
Now suddenly we think,
oh, this is interesting.

00:43:02.030 --> 00:43:05.970
Because it has two
degree 3 vertices.

00:43:05.970 --> 00:43:07.140
It's so symmetric.

00:43:07.140 --> 00:43:09.220
Surely this is the
fewest possible edges

00:43:09.220 --> 00:43:11.840
we could get away with.

00:43:11.840 --> 00:43:16.550
But no, then we found
the eight edge example.

00:43:16.550 --> 00:43:18.580
And this is kind of funny.

00:43:18.580 --> 00:43:22.940
It's like instead of
being nice and symmetric,

00:43:22.940 --> 00:43:25.110
essentially, what we're
doing is removing this edge.

00:43:25.110 --> 00:43:27.229
And we want to instead
attach it in here.

00:43:27.229 --> 00:43:29.270
But then we have to futz
around with the vertices

00:43:29.270 --> 00:43:31.070
to make it work
out and be a tree.

00:43:31.070 --> 00:43:35.020
And now has only
one degree 3 vertex.

00:43:35.020 --> 00:43:36.751
So it also has
that nice property.

00:43:36.751 --> 00:43:37.750
It only has eight edges.

00:43:37.750 --> 00:43:39.124
And this, we
believe, is optimal.

00:43:43.140 --> 00:43:47.120
And we can actually prove
something along those lines.

00:43:47.120 --> 00:43:59.870
So a linear tree is one where
all the vertices lie nearly

00:43:59.870 --> 00:44:00.370
on the line.

00:44:04.930 --> 00:44:07.360
So this is a linear locked tree.

00:44:07.360 --> 00:44:09.640
And we can prove that among
all linear locked trees,

00:44:09.640 --> 00:44:11.820
they must have at
least eight edges.

00:44:15.952 --> 00:44:24.130
Locked linear tree has
at least eight edges.

00:44:24.130 --> 00:44:28.390
So at least among linear locked
trees that example is optimal.

00:44:28.390 --> 00:44:32.490
But maybe you could use
the second dimension

00:44:32.490 --> 00:44:35.400
to do something better
than eight edges.

00:44:35.400 --> 00:44:36.840
But I don't think so.

00:44:36.840 --> 00:44:39.230
That's an open problem.

00:44:39.230 --> 00:44:41.110
What other good
things can we do?

00:44:41.110 --> 00:44:43.110
You can make it orthogonal.

00:44:43.110 --> 00:44:45.570
You can mimic exactly
this structure

00:44:45.570 --> 00:44:47.440
with an orthogonal
structure, all the edges

00:44:47.440 --> 00:44:48.840
horizontal and vertical.

00:44:48.840 --> 00:44:52.170
Just expand each of these
vertices into very tiny,

00:44:52.170 --> 00:44:54.120
and if this is drawn
really squished,

00:44:54.120 --> 00:44:55.450
these are super short edges.

00:44:55.450 --> 00:44:58.550
So they really don't change
the motion space hardly at all.

00:44:58.550 --> 00:44:59.910
You can actually prove that.

00:44:59.910 --> 00:45:01.222
And this is also locked.

00:45:01.222 --> 00:45:03.430
That's one of the nice things
you do once you get out

00:45:03.430 --> 00:45:04.810
of the cyclic kind of structure.

00:45:07.540 --> 00:45:10.110
I think I have
something else, no.

00:45:10.110 --> 00:45:11.300
OK, stay there.

00:45:15.180 --> 00:45:17.130
Yeah, actually maybe
I do want to go there.

00:45:21.870 --> 00:45:24.980
This is an example, it has
a cyclic structure again.

00:45:24.980 --> 00:45:30.020
Same paper, last year.

00:45:30.020 --> 00:45:31.414
This is a newer example.

00:45:31.414 --> 00:45:33.580
And it has the property
that all of the edge lengths

00:45:33.580 --> 00:45:38.960
are the same, and
nothing touches.

00:45:38.960 --> 00:45:43.160
Now you'll appreciate this in
a little while, how crazy this

00:45:43.160 --> 00:45:43.730
is.

00:45:43.730 --> 00:45:47.190
Because all of the
previous examples

00:45:47.190 --> 00:45:49.560
required things to be
very close and tight.

00:45:49.560 --> 00:45:54.230
And we crucially use
very tight proximity

00:45:54.230 --> 00:45:57.150
in order to prove
things are locked.

00:45:57.150 --> 00:46:05.370
And if you take the example
that looks like this, with six

00:46:05.370 --> 00:46:14.250
arms-- I didn't
draw it very well.

00:46:14.250 --> 00:46:15.700
But if you draw
it with six arms,

00:46:15.700 --> 00:46:17.790
these are like
equilateral triangles,

00:46:17.790 --> 00:46:19.902
the edge lengths will
be almost all the same.

00:46:19.902 --> 00:46:21.360
In fact, if you
allow them to touch

00:46:21.360 --> 00:46:23.247
they will be exactly the same.

00:46:23.247 --> 00:46:24.830
So there was this
open question, well,

00:46:24.830 --> 00:46:27.740
if I want them to be exactly
the same but not touch,

00:46:27.740 --> 00:46:29.180
can you still lock?

00:46:29.180 --> 00:46:31.940
We thought no, but in
fact you can do it.

00:46:31.940 --> 00:46:33.710
And this is very
tricky to prove locked

00:46:33.710 --> 00:46:36.645
because we can't make
these arbitrarily tight.

00:46:36.645 --> 00:46:39.020
It really has to look like
this, because the edge lengths

00:46:39.020 --> 00:46:40.350
are all the same.

00:46:40.350 --> 00:46:43.275
Now this has
seven-fold symmetry.

00:46:46.030 --> 00:46:48.181
Because sixfold they
would all touch.

00:46:48.181 --> 00:46:48.680
It's tricky.

00:46:52.170 --> 00:46:52.670
Cool.

00:46:55.870 --> 00:46:57.370
A big open question
here, of course,

00:46:57.370 --> 00:46:59.300
is to characterize locked trees.

00:46:59.300 --> 00:47:02.149
I think that's quite hard,
because in particular,

00:47:02.149 --> 00:47:03.940
if you're given a tree
and you want to know

00:47:03.940 --> 00:47:05.440
does that go from
this configuration

00:47:05.440 --> 00:47:07.770
to this configuration,
that's known to be p space

00:47:07.770 --> 00:47:10.400
complete, which is
really, really hard.

00:47:10.400 --> 00:47:12.180
But all of those
examples are locked.

00:47:12.180 --> 00:47:15.520
So maybe unlocked trees
have some special structure

00:47:15.520 --> 00:47:17.020
that's easy to find.

00:47:17.020 --> 00:47:18.090
I guess not.

00:47:18.090 --> 00:47:20.200
But who knows?

00:47:20.200 --> 00:47:21.700
What I do think has
a nice structure

00:47:21.700 --> 00:47:23.884
are these linear locked trees.

00:47:23.884 --> 00:47:24.800
They're pretty simple.

00:47:24.800 --> 00:47:26.230
They're basically
one dimensional.

00:47:26.230 --> 00:47:28.790
And I think we could
characterize linear lock trees

00:47:28.790 --> 00:47:30.170
in polynomial time.

00:47:30.170 --> 00:47:33.430
Maybe we'll work on
that this afternoon.

00:47:33.430 --> 00:47:36.590
But that is open.

00:47:36.590 --> 00:47:38.460
All right, next thing
I want to talk about

00:47:38.460 --> 00:47:41.364
is how the heck do you prove
that these things are locked?

00:47:41.364 --> 00:47:43.780
Now historically there have
been lots of different proofs.

00:47:43.780 --> 00:47:46.860
And this tree still does
not have a nice proof

00:47:46.860 --> 00:47:48.000
that it's locked.

00:47:48.000 --> 00:47:50.420
But all the other trees I
can give you very succinct

00:47:50.420 --> 00:47:52.182
proofs that they're locked.

00:47:52.182 --> 00:47:53.890
And so I want to tell
you how we do that.

00:48:03.230 --> 00:48:06.980
Because it uses tensegrity
theory, our good friend.

00:48:14.120 --> 00:48:18.365
This is the idea of
infinitesimally locked

00:48:18.365 --> 00:48:18.865
linkages.

00:48:38.199 --> 00:48:39.990
So ignore this part of
the picture for now.

00:48:39.990 --> 00:48:43.240
If we take some tree,
most of the examples

00:48:43.240 --> 00:48:45.370
I drew these little
scion circles to say,

00:48:45.370 --> 00:48:47.700
well, these guys
are really tight.

00:48:47.700 --> 00:48:49.350
And the intuition
is the tighter you

00:48:49.350 --> 00:48:52.506
make it, the less that
configuration can move.

00:48:52.506 --> 00:48:54.380
If you look, we're
claiming the configuration

00:48:54.380 --> 00:48:55.460
space is disconnected.

00:48:55.460 --> 00:48:57.335
But not only that, we
have this configuration

00:48:57.335 --> 00:49:00.265
and we say there's a
small ball of motions

00:49:00.265 --> 00:49:01.390
that you could possibly do.

00:49:01.390 --> 00:49:03.667
It does wiggle a little bit.

00:49:03.667 --> 00:49:05.250
And then there's
other stuff over here

00:49:05.250 --> 00:49:07.790
that you can never reach because
this can't move very much.

00:49:12.270 --> 00:49:18.060
Well in fact, if you make these
circles tighter and tighter,

00:49:18.060 --> 00:49:21.830
the claim is that this,
in the space of motions,

00:49:21.830 --> 00:49:24.750
you get less and less freedom.

00:49:24.750 --> 00:49:26.950
How could we formalize that?

00:49:26.950 --> 00:49:30.040
As you draw the thing tighter
you get less and less motion.

00:49:32.730 --> 00:49:35.540
Well, let's go to the limit.

00:49:35.540 --> 00:49:37.540
Suppose we went all
the way to the point

00:49:37.540 --> 00:49:40.890
that these things are touching.

00:49:40.890 --> 00:49:43.670
Now this is going to be a
little tricky mathematically,

00:49:43.670 --> 00:49:46.770
because we have to remember that
this vertex is in this wedge,

00:49:46.770 --> 00:49:49.330
even though it's actually
right on top of this point.

00:49:49.330 --> 00:49:53.190
So we have to remember, sort
of, how things look locally.

00:49:53.190 --> 00:50:04.390
But geometrically the picture
is going to look like that.

00:50:04.390 --> 00:50:06.740
If you look from
afar, you won't be

00:50:06.740 --> 00:50:09.290
able to tell that there's
three edges along here,

00:50:09.290 --> 00:50:11.630
because they're right
on top of each other.

00:50:11.630 --> 00:50:14.860
But if you, sort of, imagine
zooming in infinitesimally

00:50:14.860 --> 00:50:16.420
in each of these
vertices, it's going

00:50:16.420 --> 00:50:18.720
to be whatever the heck it is.

00:50:24.504 --> 00:50:26.420
So you remember the fact
that right here there

00:50:26.420 --> 00:50:27.440
are four vertices.

00:50:27.440 --> 00:50:29.606
And this is how they're
connected to incident edges.

00:50:29.606 --> 00:50:32.750
There's actually three edges
here, and two edges here,

00:50:32.750 --> 00:50:33.250
and so on.

00:50:36.080 --> 00:50:38.140
So that's how you
describe one of these,

00:50:38.140 --> 00:50:44.890
we call them,
self-touching linkages.

00:50:44.890 --> 00:50:47.822
Because the edges are
touching each other.

00:50:47.822 --> 00:50:51.170
They're right on
top of each other.

00:50:51.170 --> 00:50:56.330
Now normally, if you wanted to
capture this notion of wiggling

00:50:56.330 --> 00:50:59.100
a little bit, we
could define the idea

00:50:59.100 --> 00:51:01.640
of being locked within epsilon.

00:51:05.880 --> 00:51:10.520
So a configuration is
locked within epsilon

00:51:10.520 --> 00:51:23.440
if it's impossible
to get farther

00:51:23.440 --> 00:51:27.610
than epsilon in
configuration space.

00:51:33.290 --> 00:51:36.910
So that's this little ball,
thinking about radius epsilon

00:51:36.910 --> 00:51:38.076
here.

00:51:38.076 --> 00:51:39.700
And if you can't get
outside that ball,

00:51:39.700 --> 00:51:41.440
you have some weird
space you can get to.

00:51:41.440 --> 00:51:44.480
But if it's bounded by
a ball of radius epsilon

00:51:44.480 --> 00:51:47.432
then I say you're
locked within epsilon.

00:51:47.432 --> 00:51:48.890
And if epsilon is
small that really

00:51:48.890 --> 00:51:51.650
means there are other
things you can't get to.

00:51:51.650 --> 00:51:53.710
Well as soon as I
get to self-touching

00:51:53.710 --> 00:51:57.090
I can actually think about
being locked within epsilon

00:51:57.090 --> 00:52:05.250
for epsilon equals 0,
also known as being rigid.

00:52:07.839 --> 00:52:09.880
We've already talked about
being locked within 0.

00:52:09.880 --> 00:52:12.560
If you can't move it
all, that's rigid.

00:52:12.560 --> 00:52:14.630
So this thing could
actually be rigid.

00:52:14.630 --> 00:52:16.314
Whereas all the
locked trees, they

00:52:16.314 --> 00:52:17.730
can never be rigid
because I don't

00:52:17.730 --> 00:52:18.910
want them to really touch.

00:52:18.910 --> 00:52:19.970
This is an analysis tool.

00:52:19.970 --> 00:52:21.720
I don't like trees
that are self-touching.

00:52:21.720 --> 00:52:23.760
It's kind of ugly and cheating.

00:52:26.750 --> 00:52:29.370
And so real trees,
non-self-touching touching

00:52:29.370 --> 00:52:32.400
trees could only be locked
within some positive epsilon.

00:52:32.400 --> 00:52:34.360
But if we consider
for the moment

00:52:34.360 --> 00:52:36.850
the extreme when
they're touching then

00:52:36.850 --> 00:52:38.110
we could hope for rigidity.

00:52:38.110 --> 00:52:40.734
Rigidity is good because we know
how to prove things are rigid.

00:52:40.734 --> 00:52:43.070
We know how to test things
are rigid in two dimensions.

00:52:43.070 --> 00:52:44.590
It's pretty easy.

00:52:44.590 --> 00:52:46.620
We could test is it
infinitesimally rigid?

00:52:46.620 --> 00:52:50.770
If it's infinitesimally
rigid we know it's rigid.

00:52:50.770 --> 00:52:55.280
It's a little bit
trickier because we

00:52:55.280 --> 00:52:58.100
have to represent the
non-crossing constraints.

00:52:58.100 --> 00:53:00.650
And that's what these
purple edges do.

00:53:00.650 --> 00:53:04.830
So the idea is,
well I definitely

00:53:04.830 --> 00:53:06.780
want to preserve the
lengths of these edges.

00:53:06.780 --> 00:53:08.490
I'm not interested
in expansive motions,

00:53:08.490 --> 00:53:10.770
because that's a subset
of possible motions.

00:53:10.770 --> 00:53:14.860
But I do know that this
vertex should move away

00:53:14.860 --> 00:53:16.530
from this edge, or
stay on the edge.

00:53:16.530 --> 00:53:19.610
It's not allowed to go to
the other side of the edge.

00:53:19.610 --> 00:53:21.850
So I imagine there's a
little tiny strut here.

00:53:21.850 --> 00:53:23.840
It's of infinitesimal
length right now.

00:53:23.840 --> 00:53:26.890
It can get longer, but it has
to get longer in that direction.

00:53:26.890 --> 00:53:28.590
You have to move
away-- you have to stay

00:53:28.590 --> 00:53:30.425
on the right side of this edge.

00:53:30.425 --> 00:53:32.550
And you have to stay on
the left side of this edge.

00:53:32.550 --> 00:53:36.170
It turns out you really can
represent that by a strut.

00:53:36.170 --> 00:53:38.150
It's now a strut between
a vertex and an edge,

00:53:38.150 --> 00:53:41.730
because this guy can slide along
the edge, or move away from it.

00:53:41.730 --> 00:53:43.680
But it's a strut.

00:53:43.680 --> 00:53:45.840
And you can think of
this as a tensegrity,

00:53:45.840 --> 00:53:48.170
all the usual tensegrity
theory applies.

00:53:48.170 --> 00:53:52.690
You can define equilibrium
stresses, polyhedral liftings,

00:53:52.690 --> 00:53:54.590
infinitesimal rigidity.

00:53:54.590 --> 00:53:58.926
And so what's
actually drawn here--

00:53:58.926 --> 00:54:00.800
you should look at the
book for more details.

00:54:00.800 --> 00:54:02.466
I don't want to go
into details on this.

00:54:02.466 --> 00:54:05.470
But originally the state of
the art for proving something

00:54:05.470 --> 00:54:08.090
like this is locked
is you basically

00:54:08.090 --> 00:54:11.130
give-- you show an
equilibrium stress that

00:54:11.130 --> 00:54:13.714
is positive on all the struts.

00:54:13.714 --> 00:54:15.380
We know that if you
find a stress that's

00:54:15.380 --> 00:54:17.640
positive on all struts
than all the struts in fact

00:54:17.640 --> 00:54:19.670
must act as bars.

00:54:19.670 --> 00:54:24.350
What that means is that this
length, which is currently 0,

00:54:24.350 --> 00:54:26.370
must stay 0.

00:54:26.370 --> 00:54:27.890
Therefore this
vertex is actually

00:54:27.890 --> 00:54:31.060
pinned because it has
to both be on this edge

00:54:31.060 --> 00:54:32.020
and be on this edge.

00:54:32.020 --> 00:54:34.959
That's what a 0 length bar
here and here would mean.

00:54:34.959 --> 00:54:36.250
It really has to be right here.

00:54:36.250 --> 00:54:37.580
It can't move it all.

00:54:37.580 --> 00:54:40.790
And therefore this whole thing
is rigid, and nothing moves.

00:54:47.480 --> 00:54:48.730
Clear?

00:54:48.730 --> 00:54:50.810
So we can use all
the tensegrity stuff

00:54:50.810 --> 00:54:53.420
to prove that when this thing
is actually self-touching,

00:54:53.420 --> 00:54:57.020
and all these distances
are 0, it is rigid.

00:54:57.020 --> 00:54:58.510
But so what?

00:54:58.510 --> 00:55:00.560
Who cares about the
self-touching thing

00:55:00.560 --> 00:55:01.890
being rigid?

00:55:01.890 --> 00:55:03.790
It's nice, but what
I really care about

00:55:03.790 --> 00:55:06.150
is the non-self-touching
configurations

00:55:06.150 --> 00:55:09.540
are locked within epsilon,
for some tiny epsilon.

00:55:09.540 --> 00:55:10.285
Well good news.

00:55:15.800 --> 00:55:21.120
Rigidity of the
self-touching configuration

00:55:21.120 --> 00:55:28.620
implies what's called
strongly locked,

00:55:28.620 --> 00:55:32.690
yet another term which
I need to define.

00:55:32.690 --> 00:55:45.240
Strongly locked means
that sufficiently small,

00:55:45.240 --> 00:56:01.755
sufficiently small
perturbations of the linkage,

00:56:01.755 --> 00:56:15.140
or I should say of the
linkage configuration,

00:56:15.140 --> 00:56:21.980
are locked within
epsilon for any epsilon.

00:56:26.170 --> 00:56:30.420
This is exactly the property
I wanted to formalize,

00:56:30.420 --> 00:56:34.710
saying that if you draw
the example tighter

00:56:34.710 --> 00:56:36.660
it can move less.

00:56:36.660 --> 00:56:39.390
For any epsilon, we
want to say you can only

00:56:39.390 --> 00:56:43.150
move within epsilon,
there's some notion

00:56:43.150 --> 00:56:47.640
of sufficiently small such
that if I take this example

00:56:47.640 --> 00:56:49.570
and imagine currently
all the vertices are

00:56:49.570 --> 00:56:50.854
on top of each other.

00:56:50.854 --> 00:56:52.270
But now I perturb
it a little bit,

00:56:52.270 --> 00:56:54.720
which involves changing not
only the vertex coordinates,

00:56:54.720 --> 00:56:58.730
but also the edge lengths--
but a tiny amount, some delta

00:56:58.730 --> 00:57:01.740
that's a function of epsilon.

00:57:01.740 --> 00:57:03.360
Whatever epsilon
you choose, there's

00:57:03.360 --> 00:57:05.870
a very small disk I
can draw like this,

00:57:05.870 --> 00:57:09.600
such that as long as all the
vertices stay within that disk

00:57:09.600 --> 00:57:13.150
your example will be
locked within epsilon.

00:57:13.150 --> 00:57:15.870
This is great because it lets
us analyze rigidity, which

00:57:15.870 --> 00:57:18.940
is easy for self-touching
configurations, which are not

00:57:18.940 --> 00:57:20.940
interesting in some sense.

00:57:20.940 --> 00:57:24.470
But we get to conclude something
about the perturbations which

00:57:24.470 --> 00:57:26.607
are not self-touching
and therefore nice.

00:57:26.607 --> 00:57:28.440
And we get the property
we want, that you're

00:57:28.440 --> 00:57:30.720
locked within epsilon
for any epsilon you want.

00:57:30.720 --> 00:57:32.747
You just draw it
tighter you'll be

00:57:32.747 --> 00:57:34.080
locked within a smaller epsilon.

00:57:37.540 --> 00:57:39.400
So this is pretty cool.

00:57:39.400 --> 00:57:41.900
And I didn't defined
perturbation.

00:57:41.900 --> 00:57:54.691
But I just mean every vertex
stays within a radius delta

00:57:54.691 --> 00:57:55.190
disk.

00:57:59.520 --> 00:58:03.369
And sufficiently
small here is delta,

00:58:03.369 --> 00:58:04.660
which is a function of epsilon.

00:58:09.890 --> 00:58:12.130
So this is pretty cool.

00:58:12.130 --> 00:58:14.970
And it turns out also--
this is proved much later--

00:58:14.970 --> 00:58:16.570
these results are like 2002.

00:58:16.570 --> 00:58:21.320
And then 2006 proved
that if you take

00:58:21.320 --> 00:58:23.900
any self-touching configuration,
which is like this,

00:58:23.900 --> 00:58:26.410
you specify the geometry
where things are all

00:58:26.410 --> 00:58:27.580
on top of each other.

00:58:27.580 --> 00:58:31.130
And then you'd say what you
want every vertex to look like.

00:58:31.130 --> 00:58:35.980
It turns out there really
is a valid perturbation that

00:58:35.980 --> 00:58:38.040
preserves that
combinatorial structure

00:58:38.040 --> 00:58:39.821
and is arbitrarily small.

00:58:39.821 --> 00:58:41.820
So here, of course, I've
drawn it so it's clear.

00:58:41.820 --> 00:58:43.457
You can perturb things.

00:58:43.457 --> 00:58:45.290
And I changed the edge
lengths a little bit.

00:58:45.290 --> 00:58:49.570
But I can actually realize
this combinatorial structure.

00:58:49.570 --> 00:58:52.360
It turns out that's
always possible.

00:58:52.360 --> 00:58:54.110
So you can take any
self-touching linkage,

00:58:54.110 --> 00:58:56.040
you can perturb it so
it's not self-touching,

00:58:56.040 --> 00:58:58.950
and it is arbitrarily
locked within epsilon.

00:59:02.680 --> 00:59:06.300
And the way you
prove it, or one way

00:59:06.300 --> 00:59:08.240
to prove that
something is rigid,

00:59:08.240 --> 00:59:10.320
is to say well this
proof is infinitesimally

00:59:10.320 --> 00:59:13.120
rigid by constructing an
equilibrium stress that's

00:59:13.120 --> 00:59:15.345
positive on all these
0 length struts.

00:59:15.345 --> 00:59:17.270
As long as it's positive
all those 0 length

00:59:17.270 --> 00:59:21.860
struts you know that
they're effectively bars.

00:59:21.860 --> 00:59:24.310
Usually once they're
bars it's really obvious

00:59:24.310 --> 00:59:28.140
that the thing is rigid because
it pins vertices into corners.

00:59:28.140 --> 00:59:30.640
Then you know that the whole
thing is infinitesimally rigid,

00:59:30.640 --> 00:59:33.850
therefore it's rigid,
therefore it's strongly locked.

00:59:33.850 --> 00:59:36.339
And you could see some examples
of doing that in the book.

00:59:36.339 --> 00:59:38.130
But this is no longer
the state of the art.

00:59:38.130 --> 00:59:39.546
There are now
easier ways to prove

00:59:39.546 --> 00:59:41.005
that trees are
locked-- some trees.

00:59:41.005 --> 00:59:41.962
It doesn't always work.

00:59:41.962 --> 00:59:44.060
Of course, it might be
infinitesimally flexible.

00:59:44.060 --> 00:59:46.360
Lots of things could fail.

00:59:46.360 --> 00:59:48.964
But if it succeeds in
proving something is rigid,

00:59:48.964 --> 00:59:51.130
then you know it's strongly
locked and you're happy.

00:59:54.350 --> 00:59:56.300
So it's a conservative
test, you might say.

00:59:56.300 --> 00:59:57.710
It would be a cool
thing to implement.

00:59:57.710 --> 00:59:59.668
This is not hard, it's
just linear programming.

01:00:02.150 --> 01:00:07.110
But there's a cooler way
that's even more-- like one

01:00:07.110 --> 01:00:08.980
where I can really
draw the pictures here,

01:00:08.980 --> 01:00:11.100
you know we had to
draw all these diagrams

01:00:11.100 --> 01:00:13.530
and figure out that stress
positive numbers worked on all

01:00:13.530 --> 01:00:17.035
these edges, and
eh, it's tedious.

01:00:21.080 --> 01:00:22.230
There's a much slicker way.

01:00:33.270 --> 01:00:38.780
And for whatever reason, they
have become known as the rules.

01:00:38.780 --> 01:00:40.160
There are two of them.

01:00:40.160 --> 01:00:44.480
Although we've tried to come
up with various rule threes,

01:00:44.480 --> 01:00:46.870
the ones that have been
tried and tested and used

01:00:46.870 --> 01:00:49.360
all over the place are
rule one and rule two.

01:00:53.420 --> 01:00:56.712
So rule one.

01:00:56.712 --> 01:00:58.670
You'll see why this is
interesting in a moment.

01:01:01.420 --> 01:01:04.810
I have some linkage,
self-touching linkage.

01:01:04.810 --> 01:01:06.500
We're in the same framework.

01:01:06.500 --> 01:01:10.690
Suppose these two edges
have the same length.

01:01:10.690 --> 01:01:12.800
I'm drawing this
one slightly smaller

01:01:12.800 --> 01:01:16.207
just so I can show you,
which is on which side.

01:01:16.207 --> 01:01:17.790
But suppose they
have the same length.

01:01:17.790 --> 01:01:21.570
And suppose that
both of these angles

01:01:21.570 --> 01:01:25.490
are acute, strictly,
less than 90.

01:01:28.180 --> 01:01:29.930
What do you think
happens in this picture?

01:01:29.930 --> 01:01:31.450
I have this bar floating around.

01:01:31.450 --> 01:01:33.700
And I have these three bars.

01:01:33.700 --> 01:01:36.404
What happens to this bar?

01:01:36.404 --> 01:01:38.570
AUDIENCE: It's confined to
be against the other bar.

01:01:38.570 --> 01:01:40.861
PROFESSOR: It's confined to
be right against this edge.

01:01:40.861 --> 01:01:46.220
It can't move at all until
this angle-- both of these,

01:01:46.220 --> 01:01:48.730
and I guess at least one of
them would have to get to 90,

01:01:48.730 --> 01:01:50.820
then you could try
to slide it out.

01:01:50.820 --> 01:01:54.720
Like if this one goes beyond
90 then you can slide out.

01:01:54.720 --> 01:02:01.670
As long as they're both less
than 90 it's pinned there.

01:02:01.670 --> 01:02:08.460
So what I'm going to do
is redraw this diagram as

01:02:08.460 --> 01:02:13.292
with two edges there, which
I mean, you can just ignore.

01:02:13.292 --> 01:02:15.250
The point is if there's
something attached here

01:02:15.250 --> 01:02:19.390
and here-- maybe many things,
it's a tree, who knows?--

01:02:19.390 --> 01:02:22.770
you can just attach
them right there.

01:02:22.770 --> 01:02:24.440
This is a simplification
to the linkage.

01:02:24.440 --> 01:02:26.190
It does not behave the same.

01:02:26.190 --> 01:02:29.260
But it has the same rigidity.

01:02:29.260 --> 01:02:31.640
Because if all I care
about is rigidity,

01:02:31.640 --> 01:02:34.290
I care about can I move at all?

01:02:34.290 --> 01:02:36.780
So in order for this
guy to move and all,

01:02:36.780 --> 01:02:38.870
these guys would
first have to move

01:02:38.870 --> 01:02:41.710
for quite a while, a
positive amount of time.

01:02:41.710 --> 01:02:44.640
I just want to know can
I move 0 or more than 0?

01:02:44.640 --> 01:02:47.830
If I can move more than 0 I
could move this guy more than 0

01:02:47.830 --> 01:02:49.760
without this guy moving at all.

01:02:49.760 --> 01:02:51.760
So really I don't care
about how this guy moves.

01:02:51.760 --> 01:02:55.240
He's effectively pinned for at
least a small amount of time.

01:02:55.240 --> 01:02:57.480
I really care about can
the rest move it all?

01:02:57.480 --> 01:02:59.760
So you can simplify
your linkage like this,

01:02:59.760 --> 01:03:02.180
and the rigidity
will be preserved.

01:03:02.180 --> 01:03:05.784
This is awesome because it's
easy to see when this applies.

01:03:05.784 --> 01:03:07.200
And you just
simplify your linkage

01:03:07.200 --> 01:03:10.520
until you can just tell
whether it's rigid.

01:03:10.520 --> 01:03:14.310
All right rule two is
sort of a special case.

01:03:14.310 --> 01:03:16.760
It looks like this.

01:03:16.760 --> 01:03:21.280
So here, this bar and this bar
actually share an endpoint.

01:03:21.280 --> 01:03:23.980
And again, I need that
this angle is acute.

01:03:23.980 --> 01:03:26.990
And I need that these
two have the same length.

01:03:31.060 --> 01:03:38.040
And I can simplify
to that, where

01:03:38.040 --> 01:03:41.030
if anything was attached here
it just gets attached there.

01:03:43.590 --> 01:03:44.390
Let's try it out.

01:03:50.145 --> 01:03:51.770
Actually, I could
use some more boards.

01:04:12.950 --> 01:04:19.380
So I'm just going to copy the
example we had from before.

01:04:19.380 --> 01:04:21.380
And this will work on
basically all the examples

01:04:21.380 --> 01:04:23.130
I've shown you except
the equilateral one.

01:04:39.000 --> 01:04:43.496
This is the one, two, three,
four, five, six, seven,

01:04:43.496 --> 01:04:44.700
eight bar example.

01:04:44.700 --> 01:04:48.022
This is conjectured minimum.

01:04:48.022 --> 01:04:49.230
Let's prove that it's locked.

01:04:52.160 --> 01:04:53.640
See any rule one's
we could apply?

01:04:57.300 --> 01:05:00.040
Do you see any edges
that are effectively

01:05:00.040 --> 01:05:01.810
wedged against another edge?

01:05:01.810 --> 01:05:05.250
Remember, all of these
vertices are actually

01:05:05.250 --> 01:05:08.147
on top of each
other, we're thinking

01:05:08.147 --> 01:05:09.480
about the self-touching version.

01:05:09.480 --> 01:05:11.280
These guys are
actually touching,

01:05:11.280 --> 01:05:13.562
and these guys are
actually touching.

01:05:13.562 --> 01:05:16.510
AUDIENCE: This rule
one [INAUDIBLE].

01:05:16.510 --> 01:05:19.477
PROFESSOR: There's a rule one--

01:05:19.477 --> 01:05:20.560
AUDIENCE: That one, there.

01:05:20.560 --> 01:05:21.450
PROFESSOR: --here?

01:05:21.450 --> 01:05:22.600
Yeah, good.

01:05:22.600 --> 01:05:25.960
This edge is pinned
against this edge.

01:05:25.960 --> 01:05:30.100
Because look, we have acute
angles here, namely 0.

01:05:30.100 --> 01:05:32.660
There's an acute
angle here, that's 0.

01:05:32.660 --> 01:05:34.910
And this edge, if these guys
are on top of each other,

01:05:34.910 --> 01:05:35.910
and these guys aer
on top of each other,

01:05:35.910 --> 01:05:37.720
these two edges have
the same length.

01:05:37.720 --> 01:05:41.760
Therefore these are
pinned together.

01:05:41.760 --> 01:05:45.940
So let me redraw it when
they're pinned together.

01:05:58.472 --> 01:06:00.930
I'm drawing things with curves
just so it's easier to draw,

01:06:00.930 --> 01:06:04.620
but you understand this
is also basically flat.

01:06:04.620 --> 01:06:08.380
Again these guys are all
on top of each other,

01:06:08.380 --> 01:06:12.730
these are on top of each other,
these are on top of each other.

01:06:12.730 --> 01:06:14.200
Did I do that right?

01:06:14.200 --> 01:06:15.680
I think so, yep.

01:06:15.680 --> 01:06:16.994
Anymore?

01:06:16.994 --> 01:06:17.910
AUDIENCE: [INAUDIBLE].

01:06:17.910 --> 01:06:19.700
PROFESSOR: Yes,
on the right side.

01:06:19.700 --> 01:06:21.890
It's another rule one.

01:06:21.890 --> 01:06:25.290
Here it's actually
pretty symmetric.

01:06:25.290 --> 01:06:26.060
Is this locked?

01:06:26.060 --> 01:06:26.770
Is this rigid?

01:06:26.770 --> 01:06:27.811
It's kind of hard to say.

01:06:27.811 --> 01:06:30.410
But now it's going
to be pretty obvious.

01:06:30.410 --> 01:06:32.440
Because when these
guys join together

01:06:32.440 --> 01:06:33.940
that means these
two vertices really

01:06:33.940 --> 01:06:35.731
are on top of each
other for positive time.

01:06:35.731 --> 01:06:37.000
Same for these.

01:06:37.000 --> 01:06:41.230
So a new example looks
like two triangles

01:06:41.230 --> 01:06:43.827
with an edge floating there.

01:06:43.827 --> 01:06:45.410
Now it's pretty
obvious this is rigid.

01:06:45.410 --> 01:06:47.580
But if you really want
to make it obvious

01:06:47.580 --> 01:06:53.080
you can apply rule
two to this guy.

01:06:53.080 --> 01:06:55.770
And then these guys
are pinned together.

01:06:55.770 --> 01:07:02.560
And then you have two triangles.

01:07:02.560 --> 01:07:05.640
Two triangles are rigid.

01:07:05.640 --> 01:07:06.954
I think that's pretty obvious.

01:07:06.954 --> 01:07:09.370
You could check it, whether
they're infinitesimally rigid,

01:07:09.370 --> 01:07:10.580
whatever you feel like.

01:07:10.580 --> 01:07:13.845
But because that's rigid,
this is rigid, this is rigid,

01:07:13.845 --> 01:07:14.470
this is ridged.

01:07:14.470 --> 01:07:16.120
Because these operations
preserve rigidity.

01:07:16.120 --> 01:07:17.744
They don't preserve
locked or whatever,

01:07:17.744 --> 01:07:19.101
but they preserve rigidity.

01:07:19.101 --> 01:07:20.600
Once you know that
this is rigid you

01:07:20.600 --> 01:07:21.860
know that it's strongly locked.

01:07:21.860 --> 01:07:23.693
So when you perturb it
so these guys are not

01:07:23.693 --> 01:07:26.285
on top of each other, but
they're slightly spread out,

01:07:26.285 --> 01:07:27.660
it will be locked
within epsilon,

01:07:27.660 --> 01:07:29.960
for any epsilon you want.

01:07:29.960 --> 01:07:31.216
Now this is super easy.

01:07:31.216 --> 01:07:32.840
And this is how we
were able to iterate

01:07:32.840 --> 01:07:35.650
through all those locked
trees, and say, oh yeah,

01:07:35.650 --> 01:07:38.950
this is still rigid, so
it's still strongly locked.

01:07:38.950 --> 01:07:41.220
Now this doesn't always work.

01:07:41.220 --> 01:07:42.604
But it seems pretty good.

01:07:42.604 --> 01:07:44.270
And one of the
conjectures on the tables

01:07:44.270 --> 01:07:47.870
is that for linear
trees rules one and two

01:07:47.870 --> 01:07:49.530
are kind of almost enough.

01:07:49.530 --> 01:07:51.020
It's not literally true.

01:07:51.020 --> 01:07:52.822
But it's hopefully mostly true.

01:07:52.822 --> 01:07:55.190
AUDIENCE: It seems that
that argument would

01:07:55.190 --> 01:08:00.720
mean you wouldn't need
one of the n's on--

01:08:00.720 --> 01:08:03.260
PROFESSOR: Right, so we could
think about this example.

01:08:03.260 --> 01:08:06.790
And you're asking do you need--
does this need to be that long

01:08:06.790 --> 01:08:10.010
or could we throw
away the last bar?

01:08:10.010 --> 01:08:11.670
Right, it looks
like that's good.

01:08:11.670 --> 01:08:14.020
If you throw away this
bar it's still the case

01:08:14.020 --> 01:08:18.720
that this edge you
can apply rule one,

01:08:18.720 --> 01:08:21.580
and say that it's pinned
against this edge.

01:08:21.580 --> 01:08:24.060
And once those are there,
this thing basically

01:08:24.060 --> 01:08:26.979
acts as a single triangle,
and life is good.

01:08:26.979 --> 01:08:29.580
Yeah, so you can
remove this one edge.

01:08:29.580 --> 01:08:34.090
You could not remove both of
the edges, at least for rule one

01:08:34.090 --> 01:08:36.819
to apply, because then this
guy's not wedged into anything.

01:08:36.819 --> 01:08:40.020
He's wedged on this side but
he's not wedged on that side.

01:08:40.020 --> 01:08:41.610
But you can remove this edge.

01:08:41.610 --> 01:08:43.110
And that's a super
easy way to prove

01:08:43.110 --> 01:08:43.960
that this thing is locked.

01:08:43.960 --> 01:08:45.918
We didn't know this when
we wrote the textbook,

01:08:45.918 --> 01:08:47.740
otherwise we would
have given that proof.

01:08:47.740 --> 01:08:50.740
There's one based on
stresses in the textbook.

01:08:50.740 --> 01:08:53.700
But here, yeah, you can make
very easy judgments like that.

01:08:53.700 --> 01:08:55.830
Now it doesn't
mean that it's not

01:08:55.830 --> 01:08:57.529
locked when you remove
two of the edges.

01:09:00.609 --> 01:09:03.090
I'm not sure, no I
think it's not locked.

01:09:03.090 --> 01:09:04.960
But just because the
rules don't apply

01:09:04.960 --> 01:09:06.729
doesn't tell you
that's not locked.

01:09:06.729 --> 01:09:09.184
But it at least makes
it hard to prove.

01:09:09.184 --> 01:09:10.600
And it's a good
sort of guideline.

01:09:14.970 --> 01:09:16.234
Questions?

01:09:16.234 --> 01:09:17.202
Yeah.

01:09:17.202 --> 01:09:20.533
AUDIENCE: Did the perturbations
that are positive and finite

01:09:20.533 --> 01:09:21.074
have numbers?

01:09:21.074 --> 01:09:24.125
Like, what's-- it's sort of
disturbing that they get very,

01:09:24.125 --> 01:09:26.819
very small-- what are they?

01:09:26.819 --> 01:09:30.160
PROFESSOR: So you want
to know how big is delta?

01:09:30.160 --> 01:09:31.149
How big is epsilon?

01:09:31.149 --> 01:09:37.010
Well it depends, of course, how
much motion you want to allow,

01:09:37.010 --> 01:09:39.310
how small the
perturbations have to be.

01:09:39.310 --> 01:09:40.760
And I don't have a great answer.

01:09:40.760 --> 01:09:44.710
I do recall that we computed
a bound, probably in terms

01:09:44.710 --> 01:09:48.640
of something like r, the
maximum distance divided

01:09:48.640 --> 01:09:51.600
by the smallest non 0 distance.

01:09:51.600 --> 01:09:55.959
So it depends how close to
tight you are in other places.

01:09:55.959 --> 01:09:57.250
And it depends on your epsilon.

01:09:57.250 --> 01:09:58.917
There is an explicit bound.

01:09:58.917 --> 01:10:00.750
I think it's polynomial
on those two things.

01:10:00.750 --> 01:10:02.970
But I don't quite remember.

01:10:02.970 --> 01:10:05.110
So you can actually compute
how much perturbation

01:10:05.110 --> 01:10:08.060
will give you locked
within epsilon.

01:10:08.060 --> 01:10:10.870
But it's certainly not clean.

01:10:10.870 --> 01:10:13.850
It's actually not too hard
to prove this statement

01:10:13.850 --> 01:10:14.700
just using topology.

01:10:21.140 --> 01:10:22.900
Should I try to remember
how to prove it?

01:10:27.730 --> 01:10:34.610
Basically, yeah, so
there's this fun fact.

01:10:34.610 --> 01:10:37.280
Suppose you have
some tensegrity.

01:10:37.280 --> 01:10:39.370
So tensegrities
are kind of hard.

01:10:39.370 --> 01:10:44.057
They say, look, a bar has
this length, ain't changing.

01:10:44.057 --> 01:10:45.390
Let's be a little more flexible.

01:10:45.390 --> 01:10:48.444
What if you said, oh, this
bar can change within epsilon?

01:10:48.444 --> 01:10:50.610
Because in reality you could
probably pull the metal

01:10:50.610 --> 01:10:53.970
a little bit, just
not very much.

01:10:53.970 --> 01:10:56.330
Struts, it's not
supposed to get smaller.

01:10:56.330 --> 01:11:00.050
Let's say it can get epsilon
smaller than it's supposed to.

01:11:00.050 --> 01:11:02.900
It turns out if you take
some tensegrity that's rigid,

01:11:02.900 --> 01:11:04.920
and then you add this
little bit of flexibility

01:11:04.920 --> 01:11:08.210
so the edges can change
in length a tiny amount,

01:11:08.210 --> 01:11:13.387
then before you made this change
your configuration was a point,

01:11:13.387 --> 01:11:14.970
and there might have
been other stuff.

01:11:14.970 --> 01:11:17.070
But locally you
couldn't move at all.

01:11:17.070 --> 01:11:21.090
If you add this
flexibility, the new picture

01:11:21.090 --> 01:11:24.500
is a point with a
tiny ball around it.

01:11:24.500 --> 01:11:28.067
And whatever, I mean this
might change a little bit also.

01:11:28.067 --> 01:11:30.400
But the point is this point
doesn't get much bigger when

01:11:30.400 --> 01:11:32.170
you add just a little
bit of flexibility.

01:11:32.170 --> 01:11:34.780
This is a fact that was
known in rigidity theory.

01:11:34.780 --> 01:11:36.920
It's called sloppy rigidity.

01:11:36.920 --> 01:11:39.170
And it's essentially what's
going on here-- that we're

01:11:39.170 --> 01:11:40.670
adding a little bit
of perturbation.

01:11:40.670 --> 01:11:42.030
Before you couldn't move at all.

01:11:42.030 --> 01:11:42.960
Now you can move a little bit.

01:11:42.960 --> 01:11:45.001
We just had to generalize
from regular tensegrity

01:11:45.001 --> 01:11:49.620
so these weird tensegrities
with sliding struts.

01:11:49.620 --> 01:11:52.160
And this is kind of intuitive.

01:11:52.160 --> 01:11:54.520
To really check it
you just need to check

01:11:54.520 --> 01:11:57.650
that the constraints on edges
and struts are closed sets,

01:11:57.650 --> 01:11:59.840
and then the have
to behave this way.

01:11:59.840 --> 01:12:03.000
But you can actually compute
how quickly they change.

01:12:03.000 --> 01:12:05.470
It's just messy.

01:12:05.470 --> 01:12:07.090
So I'll leave it at that.

01:12:07.090 --> 01:12:09.795
Hey, there's a little
proof addition,

01:12:09.795 --> 01:12:12.084
glad I still remember it.

01:12:12.084 --> 01:12:12.750
Other questions?

01:12:12.750 --> 01:12:14.970
This is the end of 2D trees.

01:12:14.970 --> 01:12:19.920
And now I want to talk
briefly about 3D chains.

01:12:19.920 --> 01:12:23.438
So we did this one, now
I want to do this one.

01:12:40.230 --> 01:12:43.860
Actually this is one of the
oldest results, from 1998.

01:12:43.860 --> 01:12:46.110
So right around the same
time as the locked trees.

01:13:04.190 --> 01:13:07.040
I may have shown this example
last time, or in lecture one.

01:13:07.040 --> 01:13:09.040
But here it is again.

01:13:09.040 --> 01:13:11.770
Three bars in the
center, and two

01:13:11.770 --> 01:13:13.210
really long bars in the ends.

01:13:13.210 --> 01:13:26.430
We call this knitting needles,
because it's like two knitting

01:13:26.430 --> 01:13:28.620
needles with a short
string connecting them,

01:13:28.620 --> 01:13:30.400
tied in a knot, sort of.

01:13:30.400 --> 01:13:31.980
Topologically this
is not knotted.

01:13:31.980 --> 01:13:34.410
If you could add
extra creases here

01:13:34.410 --> 01:13:36.640
you could pull that
through, no problem.

01:13:36.640 --> 01:13:40.090
But if this is rigid,
like a linkage,

01:13:40.090 --> 01:13:51.060
then this thing
is locked provided

01:13:51.060 --> 01:14:02.550
each end bar has
length strictly greater

01:14:02.550 --> 01:14:04.820
than the sum of the middle bars.

01:14:11.730 --> 01:14:15.230
So there's three middle bars
here, add up their lengths,

01:14:15.230 --> 01:14:16.680
it should be shorter
than this one

01:14:16.680 --> 01:14:19.050
and it should be
shorter than this one.

01:14:19.050 --> 01:14:20.570
That's the cutoff.

01:14:20.570 --> 01:14:23.430
And I believe once it's
the other way around,

01:14:23.430 --> 01:14:24.290
this is not locked.

01:14:36.370 --> 01:14:39.900
Sadly, rules one and do not
prove this thing is locked.

01:14:39.900 --> 01:14:41.920
They only work in
two dimensions.

01:14:41.920 --> 01:14:45.340
But for this one example--
and to tell you the truth,

01:14:45.340 --> 01:14:48.540
this is pretty much the only
example of a locked open chain

01:14:48.540 --> 01:14:54.180
that we have-- there's a
really simple, nice proof.

01:14:54.180 --> 01:14:55.996
Let me draw the picture again.

01:14:55.996 --> 01:14:59.191
AUDIENCE: Do you
need the bottom one?

01:14:59.191 --> 01:15:01.690
PROFESSOR: You're asking do I
need three bars in the center,

01:15:01.690 --> 01:15:04.010
or could I get away with two?

01:15:04.010 --> 01:15:07.780
In fact, to draw this in
3D you need three bars.

01:15:07.780 --> 01:15:08.940
That's maybe not obvious.

01:15:13.370 --> 01:15:16.990
But if you tried to draw
it would just four bars,

01:15:16.990 --> 01:15:22.780
like this, it's
not really possible

01:15:22.780 --> 01:15:25.290
because these three
points are coplanar,

01:15:25.290 --> 01:15:29.672
as all three points
are, and then yeah.

01:15:29.672 --> 01:15:31.199
You can't get this
weaving pattern.

01:15:31.199 --> 01:15:33.490
This guy's going to be either
above or below the plane.

01:15:33.490 --> 01:15:35.656
And this guy's going to be
above or below the plane.

01:15:35.656 --> 01:15:39.030
And in all cases, you
don't get this weaving.

01:15:39.030 --> 01:15:41.407
So you really need the five.

01:15:41.407 --> 01:15:42.240
This is the minimum.

01:15:42.240 --> 01:15:46.370
You can prove all four
bar 3D chains to not lock.

01:15:46.370 --> 01:15:47.760
But with five you can do it.

01:15:50.320 --> 01:15:52.264
Good question.

01:15:52.264 --> 01:15:53.680
So here's how we're
going to prove

01:15:53.680 --> 01:15:54.763
that this thing is locked.

01:15:58.634 --> 01:16:01.050
So there are these three edges,
they have various lengths,

01:16:01.050 --> 01:16:01.980
who knows?

01:16:01.980 --> 01:16:06.130
But add up the lengths, divide
by 2, and measure out that far.

01:16:06.130 --> 01:16:08.515
So I'm going to call that
the midpoint of those three

01:16:08.515 --> 01:16:09.015
segments.

01:16:12.390 --> 01:16:15.750
I want to center a ball here.

01:16:15.750 --> 01:16:22.780
It's going to look
something like that.

01:16:22.780 --> 01:16:25.900
It's a 3D ball centered there.

01:16:25.900 --> 01:16:38.010
So it's a ball, diameter equal
to the sum of the middle bars.

01:16:42.190 --> 01:16:43.640
So radius is half that.

01:16:43.640 --> 01:16:55.215
And the center is the midpoint
of the sum of the middle bars,

01:16:55.215 --> 01:16:55.715
whatever.

01:16:59.970 --> 01:17:02.420
So the radius is half the
sum of the middle bars.

01:17:02.420 --> 01:17:05.050
And this is at half the
sum of the middle bars.

01:17:05.050 --> 01:17:11.290
Therefore these middle
bars stay inside the ball.

01:17:11.290 --> 01:17:13.280
Maybe they touch the boundary.

01:17:13.280 --> 01:17:16.570
But they're inside or on
the boundary of the ball.

01:17:16.570 --> 01:17:22.555
So that means the middle
bars are in the ball.

01:17:26.640 --> 01:17:30.340
Maybe just barely, but no
matter how you move this thing--

01:17:30.340 --> 01:17:33.870
I mean if you move this point
then the ball moves with it.

01:17:33.870 --> 01:17:35.640
So no matter how
this thing folds,

01:17:35.640 --> 01:17:37.390
those three bar stay
inside the ball.

01:17:37.390 --> 01:17:38.470
What about these bars?

01:17:38.470 --> 01:17:40.937
Or what about the endpoints?

01:17:40.937 --> 01:17:42.770
Well if this point is
inside the ball, which

01:17:42.770 --> 01:17:45.500
it is, and this point is
inside the ball, which it is,

01:17:45.500 --> 01:17:50.530
then this thing is longer
than the diameter of the ball.

01:17:50.530 --> 01:17:52.880
This thing is greater than
the sum of the middle bars.

01:17:52.880 --> 01:17:55.171
The diameter of the ball is
the sum of the middle bars.

01:17:55.171 --> 01:17:56.820
So if I take any
point inside the ball

01:17:56.820 --> 01:18:02.170
and move straight from there
by the radius of the-- more

01:18:02.170 --> 01:18:06.500
than the diameter of the ball,
I must go outside the ball.

01:18:06.500 --> 01:18:13.115
So the endpoints are
outside the ball.

01:18:16.494 --> 01:18:18.410
How the heck are you
going untie that not when

01:18:18.410 --> 01:18:21.120
all of the interior vertices
stay inside of the ball,

01:18:21.120 --> 01:18:22.920
and these guys stay
outside the ball?

01:18:22.920 --> 01:18:28.325
To formalize how the
heck, you can say well

01:18:28.325 --> 01:18:30.870
if you ignore what's inside the
ball-- something's happening

01:18:30.870 --> 01:18:31.960
there, who knows?

01:18:31.960 --> 01:18:33.600
But outside it's
like there's a ball

01:18:33.600 --> 01:18:36.250
and there's two sticks
coming out of it.

01:18:36.250 --> 01:18:39.310
So you can just
imagine, for example,

01:18:39.310 --> 01:18:43.640
tying a string
between the two ends.

01:18:43.640 --> 01:18:46.160
And something happens
in the inside.

01:18:46.160 --> 01:18:48.600
But if you think of just
from the outside perspective,

01:18:48.600 --> 01:18:49.850
these sticks just move around.

01:18:49.850 --> 01:18:53.580
It's really easy to
not tangle this cord

01:18:53.580 --> 01:18:56.120
when these sticks move around.

01:18:56.120 --> 01:18:59.260
So now, in order for
this thing to become

01:18:59.260 --> 01:19:02.690
unlocked, to straighten
out for example,

01:19:02.690 --> 01:19:06.050
somehow inside you
have to do some magic

01:19:06.050 --> 01:19:08.120
to get rid of this topology.

01:19:08.120 --> 01:19:09.190
Well what do I mean?

01:19:09.190 --> 01:19:14.120
Well if you could do it inside,
you could do that motion even

01:19:14.120 --> 01:19:16.210
when there's a
string tied out here.

01:19:16.210 --> 01:19:18.330
But when I tie the string
out here, it is a knot.

01:19:18.330 --> 01:19:19.830
It's a trefoil know.

01:19:19.830 --> 01:19:23.070
There's no way to untie a
trefoil know without crossing.

01:19:23.070 --> 01:19:24.932
So either there's
crossing in here--

01:19:24.932 --> 01:19:26.890
which better be-- or
there's crossing out here.

01:19:26.890 --> 01:19:28.265
There can't be
crossing out here.

01:19:28.265 --> 01:19:30.052
It's just two
sticks and a string.

01:19:30.052 --> 01:19:32.010
You can easily arrange
the motion of the string

01:19:32.010 --> 01:19:35.130
to not cross the two sticks.

01:19:35.130 --> 01:19:38.820
Therefore this thing
in fact cannot untie.

01:19:38.820 --> 01:19:43.880
Therefore this thing is
locked, cannot straighten out.

01:19:43.880 --> 01:19:47.060
So that's locked 3D chains.

01:19:47.060 --> 01:19:49.490
Let me tell you a bunch
of cool open problems.

01:19:49.490 --> 01:19:52.120
This is really the only good
example of a locked 3D chain

01:19:52.120 --> 01:19:53.150
we have.

01:19:53.150 --> 01:19:56.040
And it has length ratios,
the best you could do

01:19:56.040 --> 01:19:59.040
is like 1 to 3 plus epsilon.

01:19:59.040 --> 01:20:00.800
If each of these
is length 1, these

01:20:00.800 --> 01:20:02.580
have to be 3 plus epsilon.

01:20:02.580 --> 01:20:04.330
Is that the best?

01:20:04.330 --> 01:20:07.400
Or could it be, for
example, that all the edges

01:20:07.400 --> 01:20:10.590
or between length 1 and 2,
and the chain is locked?

01:20:10.590 --> 01:20:11.920
We don't know.

01:20:11.920 --> 01:20:14.830
In the extreme case, what if all
the edge lengths of the same,

01:20:14.830 --> 01:20:16.550
all length 1?

01:20:16.550 --> 01:20:18.120
Is there a locked 3D chain?

01:20:18.120 --> 01:20:21.260
We now know there's
a locked 2D tree,

01:20:21.260 --> 01:20:23.600
but for chains it's tricky.

01:20:23.600 --> 01:20:26.170
It's even open if
you add thickness.

01:20:26.170 --> 01:20:30.970
You say, hey, let's
think about a 3D chain,

01:20:30.970 --> 01:20:32.630
all the edge lengths
are the same,

01:20:32.630 --> 01:20:36.187
and you get to specify
some radius of the bars.

01:20:36.187 --> 01:20:38.020
For a while I thought
maybe this was locked.

01:20:38.020 --> 01:20:40.990
I don't think it is.

01:20:40.990 --> 01:20:42.920
We can unfold.

01:20:42.920 --> 01:20:46.130
All of these questions are
open, and pretty fascinating.

01:20:46.130 --> 01:20:50.300
Especially because proteins
are a lot like equilateral--

01:20:50.300 --> 01:20:53.840
like all the edge lengths
the same-- 3D chains.

01:20:53.840 --> 01:20:57.580
It's even open for
equilateral 3D trees.

01:20:57.580 --> 01:20:59.590
So we know 2D equilateral
trees can lock.

01:20:59.590 --> 01:21:03.140
But 3D, it's open.

01:21:03.140 --> 01:21:04.640
I think that's
enough open problems.

01:21:04.640 --> 01:21:06.456
Lots of cool questions here.

01:21:06.456 --> 01:21:07.580
All right, I have one more.

01:21:07.580 --> 01:21:08.800
It's just fun.

01:21:08.800 --> 01:21:15.890
Even if you have a 3D chain
where all the edges are

01:21:15.890 --> 01:21:17.790
on top of each other
on a line segment--

01:21:17.790 --> 01:21:19.370
it's like a linear
tree but now it's

01:21:19.370 --> 01:21:24.880
a linear 3D chain-- it's
like a bundle of segments.

01:21:24.880 --> 01:21:26.780
Is that locked?

01:21:26.780 --> 01:21:27.580
I don't think so.

01:21:27.580 --> 01:21:30.080
But even that is tricky
to come up with algorithm.

01:21:30.080 --> 01:21:32.940
Maybe we'll work on some of
these in the problem session.

01:21:32.940 --> 01:21:35.000
That's it.

