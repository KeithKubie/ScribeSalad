WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:00.842
JULIA FERRAIOLI:
Hey, everybody.

00:00:00.842 --> 00:00:04.620
Welcome to this session on
distributed databases.

00:00:04.620 --> 00:00:07.240
This panel is really designed
to give you an overview of

00:00:07.240 --> 00:00:10.920
some various approaches, some
best practices, and give you

00:00:10.920 --> 00:00:12.840
the opportunity to ask questions
to these industry

00:00:12.840 --> 00:00:16.770
experts that we've gathered
here on stage today.

00:00:16.770 --> 00:00:18.980
So let's get started.

00:00:18.980 --> 00:00:22.030
My name is Julia Ferraioli, and
I am a developer advocate

00:00:22.030 --> 00:00:24.320
working on Google
Compute Engine.

00:00:24.320 --> 00:00:25.560
BRIAN DORSEY: And I
am Brian Dorsey.

00:00:25.560 --> 00:00:27.940
And I'm a developer programs
engineer working on Compute

00:00:27.940 --> 00:00:29.280
Engine and cloud storage.

00:00:29.280 --> 00:00:30.955
And we will be your
hosts today.

00:00:30.955 --> 00:00:31.450
JULIA FERRAIOLI: Excellent.

00:00:31.450 --> 00:00:36.260
But why should you care about
distributed databases?

00:00:36.260 --> 00:00:38.500
BRIAN DORSEY: We think this is
an incredibly exciting time in

00:00:38.500 --> 00:00:40.010
the world of databases
in general.

00:00:40.010 --> 00:00:42.950
And the NoSQL world in
particular has been exploring

00:00:42.950 --> 00:00:47.680
a wide variety of ways to
distribute your data.

00:00:47.680 --> 00:00:51.310
And the different databases
have very individual

00:00:51.310 --> 00:00:53.850
approaches to how they approach
high availability,

00:00:53.850 --> 00:00:56.920
reliability, and scalability.

00:00:56.920 --> 00:00:59.445
JULIA FERRAIOLI: And with vast
computing resources available

00:00:59.445 --> 00:01:02.430
to us on demand, we're able to
gather more and more data,

00:01:02.430 --> 00:01:04.360
turning it into actionable
information.

00:01:04.360 --> 00:01:06.600
This information is
how we grow, how

00:01:06.600 --> 00:01:08.130
we develop and improve.

00:01:08.130 --> 00:01:10.580
It's far too important to
be lost to a crash.

00:01:10.580 --> 00:01:12.250
BRIAN DORSEY: Or some kind
of natural disaster.

00:01:12.250 --> 00:01:14.145
JULIA FERRAIOLI: Or a klutz
tripping over the wrong cable.

00:01:17.650 --> 00:01:19.920
BRIAN DORSEY: And as an
industry, we've usually dealt

00:01:19.920 --> 00:01:22.860
with this sort of thing by
implementing failover or some

00:01:22.860 --> 00:01:24.290
kind of backups.

00:01:24.290 --> 00:01:27.360
And we really believe that the
way forward is to distribute

00:01:27.360 --> 00:01:29.520
your data onto a large
number of machines.

00:01:29.520 --> 00:01:31.620
And you're going to want a
database that's designed for

00:01:31.620 --> 00:01:32.700
that world.

00:01:32.700 --> 00:01:36.410
You want a database that, as you
add more machines, you get

00:01:36.410 --> 00:01:38.330
more reliability.

00:01:38.330 --> 00:01:41.350
JULIA FERRAIOLI: So the last
reason is actually rather

00:01:41.350 --> 00:01:43.350
self-serving.

00:01:43.350 --> 00:01:46.130
We all like to relax
once in a while.

00:01:46.130 --> 00:01:48.700
So with a well-chosen,
well-configured database

00:01:48.700 --> 00:01:51.890
solution, you can ditch that
dreaded on call pager and

00:01:51.890 --> 00:01:54.660
finally get a good
night's sleep.

00:01:54.660 --> 00:01:57.380
So let's introduce
our panelists.

00:01:57.380 --> 00:02:01.090
First off, we're going to hear
from Tyler Hannan from Basho,

00:02:01.090 --> 00:02:03.940
then Mike Miller, representing
Cloudant.

00:02:03.940 --> 00:02:06.430
BRIAN DORSEY: Then we'll have
Chris Ramsdale from the Google

00:02:06.430 --> 00:02:10.389
Cloud Datastore and Will
Shulman from MongoLab.

00:02:10.389 --> 00:02:14.520
JULIA FERRAIOLI: OK,
Tyler, you are up.

00:02:14.520 --> 00:02:14.950
TYLER HANNAN: Beauty.

00:02:14.950 --> 00:02:16.600
Thank you, Julia and Brian.

00:02:16.600 --> 00:02:18.850
So as they said, my name is
Tyler Hannan, and I'm with

00:02:18.850 --> 00:02:19.900
Basho Technologies.

00:02:19.900 --> 00:02:21.390
A little bit about Basho--

00:02:21.390 --> 00:02:23.400
we were founded in
January of 2008.

00:02:23.400 --> 00:02:25.600
There's about 140 of us now.

00:02:25.600 --> 00:02:28.670
We have offices sort of strewn
about the world.

00:02:28.670 --> 00:02:31.490
But as a company building
distributed systems, we're

00:02:31.490 --> 00:02:33.480
kind of neurotic about the term
distributed, and we're a

00:02:33.480 --> 00:02:35.070
distributed team as well.

00:02:35.070 --> 00:02:37.460
So about 80% of us
work from home.

00:02:37.460 --> 00:02:40.750
So when thinking our product,
Riak, our database, it's good

00:02:40.750 --> 00:02:43.320
to start by considering
the benefits of

00:02:43.320 --> 00:02:44.580
a distributed database.

00:02:44.580 --> 00:02:47.290
We believe that Riak is a very
operationally friendly

00:02:47.290 --> 00:02:49.960
database that is
fault-tolerant.

00:02:49.960 --> 00:02:51.660
It can survive a node failure.

00:02:51.660 --> 00:02:53.410
It's highly available.

00:02:53.410 --> 00:02:55.300
It can survive network
partition events.

00:02:55.300 --> 00:02:56.650
It's scalable.

00:02:56.650 --> 00:03:00.880
You can grow to meet demand
simply by adding hardware or

00:03:00.880 --> 00:03:04.260
compute instance, and
it's self-healing.

00:03:04.260 --> 00:03:06.490
Self-healing is an interesting
one, because in any of the

00:03:06.490 --> 00:03:10.250
events above, be they good,
bad, or indifferent,

00:03:10.250 --> 00:03:12.250
your data is safe.

00:03:12.250 --> 00:03:15.140
So if those are the benefits,
what are the properties of

00:03:15.140 --> 00:03:18.040
Riak that those benefits
are derived from?

00:03:18.040 --> 00:03:20.360
Riak is a key/value
value store.

00:03:20.360 --> 00:03:21.400
It's open source.

00:03:21.400 --> 00:03:22.610
It's distributed.

00:03:22.610 --> 00:03:23.890
It's masterless.

00:03:23.890 --> 00:03:25.540
It's eventually consistent.

00:03:25.540 --> 00:03:28.610
Each of these could be a talk
in their own right.

00:03:28.610 --> 00:03:31.190
So I'm just going to touch on
a few very, very briefly.

00:03:31.190 --> 00:03:33.760
Riak is a key/value store, which
means you have very,

00:03:33.760 --> 00:03:35.470
very simple operations--

00:03:35.470 --> 00:03:37.250
gets, puts, deletes.

00:03:37.250 --> 00:03:39.490
And the value is
mostly opaque.

00:03:39.490 --> 00:03:41.590
It's stored on disk as binary.

00:03:41.590 --> 00:03:44.020
I append a key to that
value, either

00:03:44.020 --> 00:03:45.840
programmatically or manually.

00:03:45.840 --> 00:03:48.340
And those key value pairs are
stored in a higher level name

00:03:48.340 --> 00:03:49.970
space called a bucket.

00:03:49.970 --> 00:03:53.210
I interact with these key value
pairs via either an HTTP

00:03:53.210 --> 00:03:54.970
or protocol buffers API.

00:03:54.970 --> 00:03:57.610
And there's a slew of client
libraries for it, some of

00:03:57.610 --> 00:03:59.490
which we've built, some which
others have built.

00:03:59.490 --> 00:04:01.480
Pick a language, there's
a library.

00:04:01.480 --> 00:04:03.480
And then we've layered some
extras on top of that-- some

00:04:03.480 --> 00:04:06.250
lightweight JavaScript and
Erlang MapReduce, full text

00:04:06.250 --> 00:04:09.210
search, secondary indices, pre-
and post-commit hooks.

00:04:09.210 --> 00:04:12.560
Importantly, though,
Riak is masterless.

00:04:12.560 --> 00:04:14.640
If you're new to the world of
distributed systems and

00:04:14.640 --> 00:04:17.120
distributed databases in
general, I encourage you to

00:04:17.120 --> 00:04:18.820
read the Dynamo specification.

00:04:18.820 --> 00:04:21.380
It's a white paper
that's seminal

00:04:21.380 --> 00:04:22.890
to describe an approach.

00:04:22.890 --> 00:04:25.310
And it's the approach that
Riak has adopted.

00:04:25.310 --> 00:04:28.810
A masterless deployment means
that any node can serve any

00:04:28.810 --> 00:04:32.940
request, that data and load
are spread evenly.

00:04:32.940 --> 00:04:35.500
This is achieved through
a combination of gossip

00:04:35.500 --> 00:04:39.540
protocol, which is mesh
network-like, hinted hand off.

00:04:39.540 --> 00:04:42.230
But the point is that you can
achieve near linear scale by

00:04:42.230 --> 00:04:45.460
simply adding hardware
or compute instance.

00:04:45.460 --> 00:04:46.450
And what does that look like?

00:04:46.450 --> 00:04:49.710
It's really three commands--
riak-admin cluster join,

00:04:49.710 --> 00:04:52.030
cluster plan-- here's what's
going to happen to your datas

00:04:52.030 --> 00:04:54.520
and the replica thereof, and
cluster commit, and you're off

00:04:54.520 --> 00:04:55.230
and running.

00:04:55.230 --> 00:04:57.740
In the context of what we're
talking about with Google,

00:04:57.740 --> 00:05:02.220
that's as simple as firing up
gcutil or the Python APIs,

00:05:02.220 --> 00:05:05.050
giving it a project, choosing
a machine type--

00:05:05.050 --> 00:05:08.780
n1-standard-4, because we all
like memory as databases--

00:05:08.780 --> 00:05:12.470
SSHing in and setting it up,
and you're off and running.

00:05:12.470 --> 00:05:15.100
So when would Risk make
sense for you?

00:05:15.100 --> 00:05:17.910
If you want an operationally
friendly database, and you

00:05:17.910 --> 00:05:21.940
want to combine that with an
operationally scalable compute

00:05:21.940 --> 00:05:24.020
platform like Google Compute.

00:05:24.020 --> 00:05:27.320
And you're in gaming, social,
mobile, retail,

00:05:27.320 --> 00:05:29.010
advertising, whatever.

00:05:29.010 --> 00:05:31.290
Forget about the term
"big data." Think

00:05:31.290 --> 00:05:33.340
about critical data.

00:05:33.340 --> 00:05:37.710
When your data is critical, when
it must be served with

00:05:37.710 --> 00:05:41.200
high availability and low
latency, then you want to look

00:05:41.200 --> 00:05:42.370
into a distributed system.

00:05:42.370 --> 00:05:43.750
And Riak may be a good one.

00:05:43.750 --> 00:05:45.084
Thank you.

00:05:45.084 --> 00:05:50.010
[APPLAUSE]

00:05:50.010 --> 00:05:51.260
MIKE MILLER: Can everybody
hear me OK in the back?

00:05:53.830 --> 00:05:54.810
Well, my name's Mike Miller.

00:05:54.810 --> 00:05:56.980
I'm one of the co-founders
from Cloudant.

00:05:56.980 --> 00:05:59.510
And I'm going to give you
three quick slides, just

00:05:59.510 --> 00:06:00.760
pictures actually.

00:06:00.760 --> 00:06:03.040
And while I'm a technical
founder, I'm going to try to

00:06:03.040 --> 00:06:04.400
keep this high level
and get to the

00:06:04.400 --> 00:06:05.890
question and answer session.

00:06:05.890 --> 00:06:09.770
So how many of you are mobile
developers or have that is a

00:06:09.770 --> 00:06:12.570
big part of your work?

00:06:12.570 --> 00:06:15.470
How many of you have databases
that are so big that you can't

00:06:15.470 --> 00:06:16.720
fit them on a single machine?

00:06:19.000 --> 00:06:21.220
Everybody that is writing a
mobile app, if you app is

00:06:21.220 --> 00:06:23.480
successful, you'll eventually
hit that point.

00:06:23.480 --> 00:06:27.180
And so really, that's one of the
two main reasons that we

00:06:27.180 --> 00:06:27.750
founded Cloudant.

00:06:27.750 --> 00:06:30.100
So my background is in big
scale systems from Large

00:06:30.100 --> 00:06:31.620
Hadron Collider.

00:06:31.620 --> 00:06:33.740
And when we were trying to
build that and serve a

00:06:33.740 --> 00:06:36.860
globally distributed populace
on 200 datacenters, we

00:06:36.860 --> 00:06:39.120
realized that two things broke
our model of computing.

00:06:39.120 --> 00:06:41.430
One was big data, and the
other was the fact that

00:06:41.430 --> 00:06:43.290
everybody was in a
different place.

00:06:43.290 --> 00:06:45.700
That last one has been
rebranded as mobile.

00:06:45.700 --> 00:06:49.420
And the fact that scale is
important and masterless and

00:06:49.420 --> 00:06:51.290
distributed and all the things
we're going to talk about, you

00:06:51.290 --> 00:06:52.690
should just take for granted.

00:06:52.690 --> 00:06:54.330
I'm not going to go
in those details.

00:06:54.330 --> 00:06:56.170
You should have a service that,
when it needs to grow,

00:06:56.170 --> 00:06:57.500
you put nodes in it.

00:06:57.500 --> 00:06:58.730
And that service
gets bigger and

00:06:58.730 --> 00:07:00.480
faster in a linear fashion.

00:07:00.480 --> 00:07:01.000
That's all great.

00:07:01.000 --> 00:07:04.040
But the other thing is to attack
the latency problem.

00:07:04.040 --> 00:07:06.360
What we realized when we're
solving that at the LHC was

00:07:06.360 --> 00:07:09.340
really that what we wanted was
to take a database and take a

00:07:09.340 --> 00:07:11.740
content distribution network,
like Akamai, and merge them

00:07:11.740 --> 00:07:14.080
together so that I could
have my device, and

00:07:14.080 --> 00:07:15.250
I could write locally.

00:07:15.250 --> 00:07:17.690
And then it would synchronize
when it could in the lowest

00:07:17.690 --> 00:07:18.810
latency fashion possible.

00:07:18.810 --> 00:07:21.450
So you've got 200 precious
milliseconds for every user

00:07:21.450 --> 00:07:22.290
interaction.

00:07:22.290 --> 00:07:24.790
And that means that if you're
going around the globe, you

00:07:24.790 --> 00:07:26.880
spend 50 milliseconds getting
off your phone.

00:07:26.880 --> 00:07:28.310
So with Cloudant, we've
built a distributed

00:07:28.310 --> 00:07:29.210
database as a service.

00:07:29.210 --> 00:07:31.210
We run it so that you
don't have to.

00:07:31.210 --> 00:07:33.100
You can focus on your
core competency.

00:07:33.100 --> 00:07:35.860
And we're, I think, rolled out
on something like 18 to 20

00:07:35.860 --> 00:07:37.320
datacenters around
the globe now.

00:07:37.320 --> 00:07:39.750
So our big thing is footprint
and giving you a low latency

00:07:39.750 --> 00:07:41.360
connection wherever you
are so that you write

00:07:41.360 --> 00:07:43.170
local and think later.

00:07:43.170 --> 00:07:45.810
And so it's one database
that I think a strong

00:07:45.810 --> 00:07:46.530
recommendation I have.

00:07:46.530 --> 00:07:48.320
As you choose new technologies,
choose something

00:07:48.320 --> 00:07:50.330
that has a mobile strategy
baked in.

00:07:50.330 --> 00:07:52.640
So we heard what it's like
to install Riak--

00:07:52.640 --> 00:07:53.120
awesome.

00:07:53.120 --> 00:07:54.440
This is what it's like
to install Cloudant.

00:07:54.440 --> 00:07:55.130
You sign up.

00:07:55.130 --> 00:07:57.670
You get a
username.cloudant.com-- done.

00:07:57.670 --> 00:08:00.230
And then you get access
and resources

00:08:00.230 --> 00:08:01.700
automatically around the globe.

00:08:01.700 --> 00:08:03.820
So you write local, and your
data is beating you around on

00:08:03.820 --> 00:08:05.860
the globe as your users move.

00:08:05.860 --> 00:08:07.300
And the way this works
is pretty simple.

00:08:07.300 --> 00:08:09.810
You can actually use
this cloud API.

00:08:09.810 --> 00:08:12.260
So we speak the Apache
CouchDB API.

00:08:12.260 --> 00:08:14.120
Beneath that, we've [INAUDIBLE]
the same concepts

00:08:14.120 --> 00:08:16.930
from Amazon's Dynamo
paper around

00:08:16.930 --> 00:08:18.360
distribution and quorum.

00:08:18.360 --> 00:08:20.390
So that can handle megabytes
to petabytes.

00:08:20.390 --> 00:08:23.630
But you can also run a local
instance of an open source

00:08:23.630 --> 00:08:25.630
project on your desktop
machine.

00:08:25.630 --> 00:08:26.470
Or you could actually
run it in the

00:08:26.470 --> 00:08:28.070
browser, store state locally--

00:08:28.070 --> 00:08:29.760
so the local store HTML5.

00:08:29.760 --> 00:08:31.650
And you can even run this
on iOS and Touch.

00:08:31.650 --> 00:08:33.624
And the cool thing there is you
can always write locally

00:08:33.624 --> 00:08:36.659
and preserve that full
offline experience.

00:08:36.659 --> 00:08:40.490
So in terms of what I think you
should have in your head

00:08:40.490 --> 00:08:43.570
as you think about choosing your
database technologies,

00:08:43.570 --> 00:08:46.260
think about what things you're
forced to do with your

00:08:46.260 --> 00:08:48.310
database that you'd
love to get away.

00:08:48.310 --> 00:08:50.680
And so we're trying to give you
a chance to say hey, do I

00:08:50.680 --> 00:08:52.640
really need global
write master?

00:08:52.640 --> 00:08:55.660
Or can I just put data someplace
locally and have

00:08:55.660 --> 00:08:58.020
that distribution happen
automatically?

00:08:58.020 --> 00:08:59.510
So with that, I'll
pass on the mic.

00:08:59.510 --> 00:09:00.237
Thank you.

00:09:00.237 --> 00:09:03.150
[APPLAUSE]

00:09:03.150 --> 00:09:07.250
CHRIS RAMSDALE: Thanks, Mike,
and thanks, Julia and Brian.

00:09:07.250 --> 00:09:08.290
I'm Chris Ramsdale.

00:09:08.290 --> 00:09:10.240
I'm a product manager for the
Google Cloud Platform.

00:09:10.240 --> 00:09:14.010
And I'm focused on App Engine
and distributed storage within

00:09:14.010 --> 00:09:15.710
the platform itself.

00:09:15.710 --> 00:09:19.280
The Cloud Platform storage
family is comprised of Google

00:09:19.280 --> 00:09:21.920
Cloud Storage for serving blob
data, Cloud SQL for relational

00:09:21.920 --> 00:09:24.660
data, and the newly released
Cloud Datastore for

00:09:24.660 --> 00:09:25.960
non-relational data.

00:09:25.960 --> 00:09:27.700
And for the sake of today, we're
going to focus on the

00:09:27.700 --> 00:09:28.970
Cloud Datastore.

00:09:28.970 --> 00:09:31.350
And I've got a few slides, and
we'll get going, and then

00:09:31.350 --> 00:09:33.150
we'll drop it into
Q&amp;A as well.

00:09:33.150 --> 00:09:37.400
So announced yesterday, the
Google Cloud Datastore was our

00:09:37.400 --> 00:09:39.780
efforts to extract out the
higher application datastore

00:09:39.780 --> 00:09:42.660
that was part of App Engine and
make it available to any

00:09:42.660 --> 00:09:45.570
compute container, be it
EC2 or Compute Engine

00:09:45.570 --> 00:09:47.260
or things like that.

00:09:47.260 --> 00:09:51.520
Launched in 2011, the high
replication datastore turned

00:09:51.520 --> 00:09:53.020
out to be a really great project
and a really good

00:09:53.020 --> 00:09:54.080
service for our users.

00:09:54.080 --> 00:09:55.230
We've gone for two years.

00:09:55.230 --> 00:09:57.670
We're at about 4.5 trillion
transactions per month right

00:09:57.670 --> 00:10:00.730
now storing petabytes of data.

00:10:00.730 --> 00:10:03.540
Jokingly, App Engine has really
been referred to as the

00:10:03.540 --> 00:10:04.780
SDK for BigTable.

00:10:04.780 --> 00:10:08.180
So what we did was we said,
that's great, but it's

00:10:08.180 --> 00:10:11.280
packaged up in the App Engine
SDK, so you can't get to it

00:10:11.280 --> 00:10:12.220
from anywhere else.

00:10:12.220 --> 00:10:13.490
And so we pulled that out.

00:10:13.490 --> 00:10:15.190
We put an HTTP interface
on top of it.

00:10:15.190 --> 00:10:17.130
I'm not really doing justice
for what we did to the API,

00:10:17.130 --> 00:10:19.450
but you should go
read the docs.

00:10:19.450 --> 00:10:21.620
And now we're announcing it as
the Google Cloud Datastore

00:10:21.620 --> 00:10:24.480
and, again, making it available
from anywhere.

00:10:24.480 --> 00:10:26.260
And by doing that, not only
do we get the hardened

00:10:26.260 --> 00:10:29.760
productivity or the
productization of HRD and now

00:10:29.760 --> 00:10:31.870
inside of Cloud Datastore, we
also get the features and

00:10:31.870 --> 00:10:35.760
functionality, for example,
asset transactions, eventual

00:10:35.760 --> 00:10:38.940
strong consistency, a built-in
query engine that lets you do

00:10:38.940 --> 00:10:40.680
fixed cost queries and
things like that.

00:10:40.680 --> 00:10:43.190
Those are all available
as well.

00:10:43.190 --> 00:10:44.500
So that's what the product is.

00:10:44.500 --> 00:10:46.220
And real quickly, we're going to
talk about how that aligns

00:10:46.220 --> 00:10:49.480
with what our philosophies are
and what we're trying to do

00:10:49.480 --> 00:10:51.940
within the Google Cloud
Platform all up.

00:10:51.940 --> 00:10:55.000
So at it's core, we're trying to
bring Google infrastructure

00:10:55.000 --> 00:10:56.660
to developers, to our customers,
to you that are in

00:10:56.660 --> 00:10:59.270
this room today and joining us
for Google I/O. Specifically,

00:10:59.270 --> 00:11:02.210
the same infrastructure that's
running things like Geo and

00:11:02.210 --> 00:11:07.230
Mail and Google Maps and Search
and things like that.

00:11:07.230 --> 00:11:10.160
And what that is specifically
in the case of storage, is

00:11:10.160 --> 00:11:11.590
these components that you see
here on the left hand side

00:11:11.590 --> 00:11:13.850
that Urs had talked about
yesterday in the Cloud keynote

00:11:13.850 --> 00:11:15.240
if you happened to see it--

00:11:15.240 --> 00:11:17.400
everything from our datacenters
and our machines

00:11:17.400 --> 00:11:20.090
to our networking to the crazy
services that we've built over

00:11:20.090 --> 00:11:20.850
the past few years--

00:11:20.850 --> 00:11:22.830
Colossus, BigTable,
and Megastore.

00:11:22.830 --> 00:11:24.650
And by doing that, what we allow
you to do is we bring

00:11:24.650 --> 00:11:26.190
you high availability.

00:11:26.190 --> 00:11:27.690
By building on top of Megastore,
we actually give

00:11:27.690 --> 00:11:30.540
you the replication across
multiple geos.

00:11:30.540 --> 00:11:31.780
We give you high scalability.

00:11:31.780 --> 00:11:34.820
So Colossus for actually giving
you the stores, the

00:11:34.820 --> 00:11:36.200
underlying mechanism
for storing.

00:11:36.200 --> 00:11:38.780
It gives you a huge capacity and
high durability, and then

00:11:38.780 --> 00:11:40.680
BigTable for horizontal
scaling out.

00:11:40.680 --> 00:11:42.190
So we do that automatically
for you.

00:11:42.190 --> 00:11:44.970
You don't have to actually add a
node to the Cloud Datastore.

00:11:44.970 --> 00:11:46.670
We just shard appropriately
and things happen.

00:11:46.670 --> 00:11:49.510
And finally, an API frontend
that's actually built on top

00:11:49.510 --> 00:11:52.180
of App Engine that we'll
just scale out.

00:11:52.180 --> 00:11:53.650
We're looking for access
from anywhere.

00:11:53.650 --> 00:11:55.460
We think that data it should
not be siloed.

00:11:55.460 --> 00:11:56.600
It should follow you
wherever you go.

00:11:56.600 --> 00:11:59.480
And as our platform expands
out and as customers use

00:11:59.480 --> 00:12:02.670
hybrid approaches like Compute
Engine in EC2, they want their

00:12:02.670 --> 00:12:04.790
data to follow them wherever
they need to go.

00:12:04.790 --> 00:12:05.850
And then finally, what's
near and dear to my

00:12:05.850 --> 00:12:06.820
heart is Fully Managed.

00:12:06.820 --> 00:12:08.870
I think that we're all going to
talk about management and

00:12:08.870 --> 00:12:12.080
how we do it as we get into the
Q&amp;A. And what that means

00:12:12.080 --> 00:12:14.880
for us at Google is that
you get this guy.

00:12:14.880 --> 00:12:15.720
This is Michael Handler.

00:12:15.720 --> 00:12:17.360
He's one of our Site Reliability
Engineers.

00:12:17.360 --> 00:12:19.280
We call them SREs.

00:12:19.280 --> 00:12:21.390
And they help keep the service
up and running.

00:12:21.390 --> 00:12:24.330
They help us do planning,
architecture, failovers,

00:12:24.330 --> 00:12:25.250
things like that.

00:12:25.250 --> 00:12:27.650
But because you're building on
the same infrastructure as all

00:12:27.650 --> 00:12:30.660
those other products I alluded
to, you not only get him.

00:12:30.660 --> 00:12:32.800
You get him cloned
like 1,000 times.

00:12:32.800 --> 00:12:34.770
So you've got all these teams
that are monitoring all these

00:12:34.770 --> 00:12:37.300
services that do automatically
scale out for you.

00:12:37.300 --> 00:12:38.920
But sometimes things happen.

00:12:38.920 --> 00:12:42.270
And we've got the cell phone,
AKA the pager to take care of

00:12:42.270 --> 00:12:44.340
it and make sure you don't have
to worry about it so you

00:12:44.340 --> 00:12:46.410
get more sleep.

00:12:46.410 --> 00:12:48.083
I'll turn it over to WIll.

00:12:48.083 --> 00:12:54.080
[APPLAUSE]

00:12:54.080 --> 00:12:54.610
WILL SHULMAN: Hello everyone.

00:12:54.610 --> 00:12:56.210
My name is Will Shulman.

00:12:56.210 --> 00:12:58.490
I'm the CEO and co-founder
of MongoLab.

00:12:58.490 --> 00:13:01.250
I'm going to give you an
introduction to MongoDB and

00:13:01.250 --> 00:13:04.120
our MongoLab Lab
cloud service.

00:13:04.120 --> 00:13:05.370
It's upside down.

00:13:09.030 --> 00:13:10.580
So real quick, what
is MongoDB?

00:13:10.580 --> 00:13:13.970
MongoDB is an open source,
high-performance, distributed,

00:13:13.970 --> 00:13:15.610
and document-oriented
database.

00:13:15.610 --> 00:13:17.830
And I'll go through what that
means really quickly.

00:13:17.830 --> 00:13:21.070
First and foremost, MongoDB
is a document database.

00:13:21.070 --> 00:13:23.230
It doesn't mean, for those of
you who are not familiar with

00:13:23.230 --> 00:13:25.200
that terminology, it doesn't
mean it stores PDF files.

00:13:25.200 --> 00:13:28.150
It means it stores these
rich JSON documents.

00:13:28.150 --> 00:13:31.730
MongoDB stores these in a binary
representation of JSON

00:13:31.730 --> 00:13:33.510
called BSON.

00:13:33.510 --> 00:13:35.980
And this is a really important
part of MongoDB that really

00:13:35.980 --> 00:13:38.170
differentiates it from other
NoSQL databases.

00:13:38.170 --> 00:13:39.930
It's not just a key
value store.

00:13:39.930 --> 00:13:42.420
It gives you these rich
data structures.

00:13:42.420 --> 00:13:43.560
It's got nested objects.

00:13:43.560 --> 00:13:45.290
It's got arrays.

00:13:45.290 --> 00:13:49.100
You can represent geolocations
natively.

00:13:49.100 --> 00:13:53.890
And also, unlike a lot of
key/value stores, MongoDB has

00:13:53.890 --> 00:13:55.420
a rich query language.

00:13:55.420 --> 00:13:57.280
It's a real database.

00:13:57.280 --> 00:14:01.090
It allows you to do searching
and sorting by not just the

00:14:01.090 --> 00:14:02.970
keys, but any nested value.

00:14:02.970 --> 00:14:08.260
So here we have all sorts of
examples of doing queries and

00:14:08.260 --> 00:14:10.170
geolocation, if you
look down at this

00:14:10.170 --> 00:14:11.490
example towards the bottom.

00:14:11.490 --> 00:14:12.510
It's built in.

00:14:12.510 --> 00:14:15.240
It's got aggregation, so you
can do binning and grouping

00:14:15.240 --> 00:14:17.630
like you would with a
relational database.

00:14:17.630 --> 00:14:20.180
And also like a relational
database, although you can

00:14:20.180 --> 00:14:23.800
search and sort by anything,
you can create indexes on

00:14:23.800 --> 00:14:24.810
almost anything.

00:14:24.810 --> 00:14:27.710
So if your queries are slow,
you can index on any field

00:14:27.710 --> 00:14:31.180
value, nested key values
deep inside the object.

00:14:31.180 --> 00:14:33.170
You can index on array values.

00:14:33.170 --> 00:14:35.770
Makes it really great, not just
for a large data sets,

00:14:35.770 --> 00:14:37.660
which I'll talk about in a
minute, but really as a

00:14:37.660 --> 00:14:41.400
replacement for MySQL or any
relational database you use.

00:14:41.400 --> 00:14:43.670
If you spent an inordinate
amount of time in your life

00:14:43.670 --> 00:14:45.410
mapping from your
object-oriented programming

00:14:45.410 --> 00:14:47.540
language to a relational
datastore and doing

00:14:47.540 --> 00:14:51.470
object-relational mapping, you
don't have to do that anymore.

00:14:51.470 --> 00:14:54.360
Second, MongoDB is a distributed
database.

00:14:54.360 --> 00:14:56.580
There are two clustering
technologies with MongoDB.

00:14:56.580 --> 00:14:57.890
The first clustering
technology is

00:14:57.890 --> 00:14:59.310
called Replica Sets.

00:14:59.310 --> 00:15:00.940
This is what allows
you to have high

00:15:00.940 --> 00:15:02.570
availability in MongoDB.

00:15:02.570 --> 00:15:04.430
It's single master.

00:15:04.430 --> 00:15:05.960
So you can read and write.

00:15:05.960 --> 00:15:09.280
It supports both strong
consistency and eventual

00:15:09.280 --> 00:15:10.320
consistency.

00:15:10.320 --> 00:15:12.180
So if you need strong
consistency for your

00:15:12.180 --> 00:15:13.550
application, you can have it.

00:15:13.550 --> 00:15:16.730
If eventual consistency
is acceptable for your

00:15:16.730 --> 00:15:19.490
application, you can also read
from these secondaries.

00:15:19.490 --> 00:15:24.250
And its consistency model is
very, very configurable.

00:15:24.250 --> 00:15:26.530
The second clustering
technology is

00:15:26.530 --> 00:15:28.320
called Shard Clusters.

00:15:28.320 --> 00:15:30.500
This is basically a cluster
of clusters.

00:15:30.500 --> 00:15:32.590
So it's a cluster
of Replica Sets.

00:15:32.590 --> 00:15:34.930
And with Sharding Clusters, this
is how you get horizontal

00:15:34.930 --> 00:15:36.690
scalability with MongoDB.

00:15:36.690 --> 00:15:39.270
Like many have mentioned, as you
add nodes to the system,

00:15:39.270 --> 00:15:41.750
your rights get distributed
amongst them, and it just

00:15:41.750 --> 00:15:45.390
scales linearly in a very
horizontal manner.

00:15:45.390 --> 00:15:46.580
What is MongoLab?

00:15:46.580 --> 00:15:49.050
So MongoLab is MongoDB
as a service.

00:15:49.050 --> 00:15:50.980
And that's what we do.

00:15:50.980 --> 00:15:54.260
MongoLab really is about
automating all of the

00:15:54.260 --> 00:15:56.150
operational aspects of
our running database.

00:15:56.150 --> 00:15:59.730
We try to build an expert system
out of the DBA so that

00:15:59.730 --> 00:16:01.050
you don't have the DBA.

00:16:01.050 --> 00:16:02.320
You don't have to have
the ops guys.

00:16:02.320 --> 00:16:04.620
And you can focus, like a lot
of folks have mentioned, on

00:16:04.620 --> 00:16:05.250
building your app.

00:16:05.250 --> 00:16:07.750
We handle provisioning
and scaling,

00:16:07.750 --> 00:16:09.390
replication and backups.

00:16:09.390 --> 00:16:11.300
We've got rich Web UI.

00:16:11.300 --> 00:16:14.180
We handle all the monitoring,
all the alerting.

00:16:14.180 --> 00:16:17.210
And of course, all with the
service comes expert support.

00:16:17.210 --> 00:16:20.730
Our product offering offers
shared and dedicated VM plans.

00:16:20.730 --> 00:16:24.560
We have SSD backed plans, single
and multi-node plans.

00:16:24.560 --> 00:16:27.920
So whether you're doing
analytics and you just need a

00:16:27.920 --> 00:16:31.180
single node database, or you
need lots of nodes, we're

00:16:31.180 --> 00:16:34.340
going to have full sharding
support in 2014.

00:16:34.340 --> 00:16:37.240
And we run on all sorts of cloud
providers, and we're

00:16:37.240 --> 00:16:40.660
here today and this week to
announce our support for the

00:16:40.660 --> 00:16:42.310
Google Cloud Platform,
which we're really,

00:16:42.310 --> 00:16:43.450
really excited about.

00:16:43.450 --> 00:16:46.900
So thank you very much.

00:16:46.900 --> 00:16:48.550
We've got a sandbox.

00:16:48.550 --> 00:16:49.540
I guess I lost my last slide.

00:16:49.540 --> 00:16:53.190
I just wanted to say we've got
a sandbox outside tomorrow at

00:16:53.190 --> 00:16:56.380
Google I/O, where you can come
and get a demo of our service.

00:16:56.380 --> 00:16:58.150
So we encourage you
guys to stop by.

00:16:58.150 --> 00:16:59.470
Thanks.

00:16:59.470 --> 00:17:04.220
[APPLAUSE]

00:17:04.220 --> 00:17:05.170
JULIA FERRAIOLI: Thanks, guys.

00:17:05.170 --> 00:17:06.660
That was a great overview.

00:17:06.660 --> 00:17:09.490
And this is the fun part
where we jump into

00:17:09.490 --> 00:17:11.270
some Q&amp;A by the audience.

00:17:11.270 --> 00:17:14.180
I encourage you if you have
questions, start lining up at

00:17:14.180 --> 00:17:16.480
the mics now.

00:17:16.480 --> 00:17:20.569
To jump start it, we'll
just seed a question.

00:17:20.569 --> 00:17:23.020
We're at Google I/O.
Most of us were

00:17:23.020 --> 00:17:25.260
at Urs's talk yesterday.

00:17:25.260 --> 00:17:27.920
So we heard a lot about the
improvements and the type of

00:17:27.920 --> 00:17:29.790
infrastructure that
we have at Google.

00:17:29.790 --> 00:17:33.700
So my first question, and this
can be answered by everybody,

00:17:33.700 --> 00:17:36.800
is, what makes Google's
infrastructure a great place

00:17:36.800 --> 00:17:39.070
to run distributed databases?

00:17:39.070 --> 00:17:40.610
We'll start with Will.

00:17:40.610 --> 00:17:43.840
WILL SHULMAN: So we've actually
been using GCE for a

00:17:43.840 --> 00:17:44.470
little while.

00:17:44.470 --> 00:17:47.060
And first thing actually
is the network.

00:17:47.060 --> 00:17:50.110
The network is a, it's blazing
fast, really, really

00:17:50.110 --> 00:17:50.950
impressive.

00:17:50.950 --> 00:17:53.070
The other thing that's great
about the Google Cloud

00:17:53.070 --> 00:17:56.840
Platform is it has a private
distributed backbone between

00:17:56.840 --> 00:17:57.770
all the datacenters.

00:17:57.770 --> 00:18:00.620
So we're really excited about
that functionality.

00:18:00.620 --> 00:18:04.930
We're really excited to offer
globally multi-region clusters

00:18:04.930 --> 00:18:06.330
where you can have nodes--

00:18:06.330 --> 00:18:07.470
different parts of the globe.

00:18:07.470 --> 00:18:08.870
But you're not talking over
the open internet.

00:18:08.870 --> 00:18:13.580
You're actually talking over
Google's private backbone.

00:18:13.580 --> 00:18:14.570
CHRIS RAMSDALE: So it's slightly
different for us,

00:18:14.570 --> 00:18:17.170
because we're not actually
building on top of Compute

00:18:17.170 --> 00:18:18.510
Engine VMs, at least today.

00:18:18.510 --> 00:18:22.140
But I think there's an analogy
that I'll get to real quickly,

00:18:22.140 --> 00:18:25.390
which is that for the same
reasons that it's good to

00:18:25.390 --> 00:18:28.300
build on Compute Engine for all
the services they provide

00:18:28.300 --> 00:18:29.830
and the fast networking and the
things that Google takes

00:18:29.830 --> 00:18:32.200
care of, it's the same reason
we chose to build on top of

00:18:32.200 --> 00:18:35.110
things like Megastore and
Colossus and BigTable and

00:18:35.110 --> 00:18:37.470
whatnot and are looking at
things like Spanner as well,

00:18:37.470 --> 00:18:39.630
because those are the lower
level pieces that are handled

00:18:39.630 --> 00:18:42.540
by Google, much like the lower
level VMs are inside of

00:18:42.540 --> 00:18:43.950
infrastructure.

00:18:43.950 --> 00:18:47.700
And then also at the same time,
while you can access the

00:18:47.700 --> 00:18:49.700
Cloud Datastore from
things like EC2 or

00:18:49.700 --> 00:18:51.200
Rackspace or whatnot--

00:18:51.200 --> 00:18:52.350
although I think the
latency might be

00:18:52.350 --> 00:18:53.710
a little bit awkward--

00:18:53.710 --> 00:18:55.980
we really built this for Compute
Engine users, because

00:18:55.980 --> 00:18:57.990
we do think it's one of the
great platforms that we're

00:18:57.990 --> 00:19:00.950
offering and bringing into the
larger cloud platform.

00:19:00.950 --> 00:19:04.850
And so we wanted to give those
users a fully managed

00:19:04.850 --> 00:19:06.570
non-relational schemaless
datastore to

00:19:06.570 --> 00:19:07.820
truly grow their apps.

00:19:10.020 --> 00:19:10.840
MIKE MILLER: Boy, there
are a lot of ways I

00:19:10.840 --> 00:19:11.690
want to answer this.

00:19:11.690 --> 00:19:13.720
Number one maybe being that it's
not Amazon, which is kind

00:19:13.720 --> 00:19:16.630
of nice as a change.

00:19:16.630 --> 00:19:20.510
The reality is we built a
database as a service.

00:19:20.510 --> 00:19:21.770
And we've got to bring that
to the place where

00:19:21.770 --> 00:19:22.390
the developers are.

00:19:22.390 --> 00:19:23.980
There's a large and rapidly
growing number of

00:19:23.980 --> 00:19:24.920
developers on Google.

00:19:24.920 --> 00:19:27.550
So for us, there are all kinds
of technical reasons about why

00:19:27.550 --> 00:19:28.850
it's a great platform.

00:19:28.850 --> 00:19:31.820
If you're building a CDN,
you want to know the

00:19:31.820 --> 00:19:33.210
network very well.

00:19:33.210 --> 00:19:35.270
And reliable latencies
are huge as well--

00:19:35.270 --> 00:19:36.020
so private backbone.

00:19:36.020 --> 00:19:38.280
But really, the number one thing
for us is footprint,

00:19:38.280 --> 00:19:41.070
like I need to get as close
to the edge as possible.

00:19:41.070 --> 00:19:44.820
And so Google has one of the
biggest, if not the biggest

00:19:44.820 --> 00:19:45.630
deployments globally.

00:19:45.630 --> 00:19:48.920
So for us, that's massive.

00:19:48.920 --> 00:19:50.540
TYLER HANNAN: So Will mentioned
this, and I'm going

00:19:50.540 --> 00:19:51.630
to repeat it.

00:19:51.630 --> 00:19:54.980
The private backbone between
datacenters matters.

00:19:54.980 --> 00:19:58.130
Data locality is an important
concern when you're

00:19:58.130 --> 00:20:00.220
distributing a global
database.

00:20:00.220 --> 00:20:04.980
But also, when scalability is a
problem, it's a problem now.

00:20:04.980 --> 00:20:07.290
And it's a business
problem now.

00:20:07.290 --> 00:20:11.260
And so the ability to simply
scale by using the tools that

00:20:11.260 --> 00:20:14.250
are provided to developers
regardless of which database

00:20:14.250 --> 00:20:17.080
solution you choose is an
important and, I think, unique

00:20:17.080 --> 00:20:21.210
component of Compute Engine and
something that if I could

00:20:21.210 --> 00:20:24.360
surmise, will be a
continued area of

00:20:24.360 --> 00:20:27.050
improvement in the future.

00:20:27.050 --> 00:20:30.420
JULIA FERRAIOLI: So it looks
like we have some questions.

00:20:30.420 --> 00:20:31.310
AUDIENCE: My name's Drew
[? Broadly. ?]

00:20:31.310 --> 00:20:32.800
I'm from New Zealand.

00:20:32.800 --> 00:20:34.740
One of the questions I have--

00:20:34.740 --> 00:20:37.170
because the people from
Cassandra aren't up here, and

00:20:37.170 --> 00:20:38.370
I thought I'd take
the opportunity--

00:20:38.370 --> 00:20:41.090
and what are your opinions on
distributed counters, and

00:20:41.090 --> 00:20:43.840
what's your approach?

00:20:43.840 --> 00:20:47.260
TYLER HANNAN: So distributed
counters was the question.

00:20:47.260 --> 00:20:50.490
Sorry, I'm repeating that,
because I'm hard of hearing.

00:20:50.490 --> 00:20:55.950
We've been working hard on, in
concert with INRIA Research in

00:20:55.950 --> 00:21:00.240
France, on CRDTs and looking at
building counters that can

00:21:00.240 --> 00:21:03.090
survive in eventually
consistent world.

00:21:03.090 --> 00:21:06.110
We've also been working on
adding some strong consistency

00:21:06.110 --> 00:21:08.300
capabilities into Riak.

00:21:08.300 --> 00:21:09.200
I think they're there.

00:21:09.200 --> 00:21:11.280
I think they're coming soon.

00:21:11.280 --> 00:21:13.380
I think they're a lot
of scary math.

00:21:13.380 --> 00:21:16.230
So it'll be interesting to see
how the market adopts.

00:21:16.230 --> 00:21:18.270
But I think we're on the
cusp of distributed

00:21:18.270 --> 00:21:20.780
counters being a reality.

00:21:20.780 --> 00:21:22.650
MIKE MILLER: Yeah, CRDTs are
definitely a hot area of

00:21:22.650 --> 00:21:23.930
implementation.

00:21:23.930 --> 00:21:25.790
I don't know about how hot there
are research-wise, but

00:21:25.790 --> 00:21:27.700
we're certainly seeing users who
have implemented a large

00:21:27.700 --> 00:21:29.990
number of those things
in reality.

00:21:29.990 --> 00:21:33.590
But overall, I think a little
bit of a shift in mindset when

00:21:33.590 --> 00:21:34.250
you're writing something.

00:21:34.250 --> 00:21:37.040
A lot of people who come to
NoSQL will get there after

00:21:37.040 --> 00:21:39.440
going to the fully denormalized
state.

00:21:39.440 --> 00:21:41.396
So you start with start schemas,
and you work up all

00:21:41.396 --> 00:21:41.615
the way to full.

00:21:41.615 --> 00:21:42.670
You normalize.

00:21:42.670 --> 00:21:48.460
And that mindset is something
that we have to help show

00:21:48.460 --> 00:21:50.080
people the best ways
to solve problems.

00:21:50.080 --> 00:21:52.050
I think one of the things that
we also see that's available

00:21:52.050 --> 00:21:54.360
now in the majority of these
systems is going to an

00:21:54.360 --> 00:21:57.020
immutable data model where if
you're modeling a state

00:21:57.020 --> 00:21:59.070
machine, every transition
is modified--

00:21:59.070 --> 00:22:01.380
modeled as, say, a new document
in our system, a new

00:22:01.380 --> 00:22:02.220
JSON document.

00:22:02.220 --> 00:22:04.180
And the aggregate state
is summed up

00:22:04.180 --> 00:22:05.210
in a secondary index.

00:22:05.210 --> 00:22:07.800
So that's a really powerful
way already without even

00:22:07.800 --> 00:22:10.110
appealing to something as
complicated as CRDTs to deal

00:22:10.110 --> 00:22:12.710
with rapidly changing things
that have to be summed.

00:22:12.710 --> 00:22:14.270
So concrete examples--

00:22:14.270 --> 00:22:17.650
leader boards, amounts of money
in accounts, virtual

00:22:17.650 --> 00:22:20.170
currencies, which maps a very
real large amount of dollars.

00:22:25.160 --> 00:22:26.990
CHRIS RAMSDALE: I think they
summed it up well.

00:22:26.990 --> 00:22:31.040
AUDIENCE: Are you two able to
give an input on it or not?

00:22:31.040 --> 00:22:33.390
WILL SHULMAN: I'll be honest
with you, I've given almost no

00:22:33.390 --> 00:22:35.390
thought to distributed
counters.

00:22:35.390 --> 00:22:36.540
So sorry about that.

00:22:36.540 --> 00:22:38.370
AUDIENCE: Thank you.

00:22:38.370 --> 00:22:39.620
JULIA FERRAIOLI: More time
for more questions.

00:22:43.000 --> 00:22:46.360
AUDIENCE: So many of my
friends who initially

00:22:46.360 --> 00:22:49.320
recommended MongoDB to me,
later, I noticed they grew

00:22:49.320 --> 00:22:52.840
disillusioned with
document-oriented databases.

00:22:52.840 --> 00:22:56.440
I'm wondering how have you
noticed organizations dealing

00:22:56.440 --> 00:22:59.200
with the engineering scaling
issues of actually engineering

00:22:59.200 --> 00:23:00.410
applications with

00:23:00.410 --> 00:23:03.530
document-oriented databases versus--

00:23:03.530 --> 00:23:07.110
I'm not talking about the whole
technical scaling, but

00:23:07.110 --> 00:23:09.050
building their applications.

00:23:09.050 --> 00:23:11.600
WILL SHULMAN: So for
document-oriented databases is

00:23:11.600 --> 00:23:15.060
specifically your question?

00:23:15.060 --> 00:23:16.834
AUDIENCE: Right.

00:23:16.834 --> 00:23:19.770
JULIA FERRAIOLI: Sounds like
a great question for Will.

00:23:19.770 --> 00:23:21.880
WILL SHULMAN: I think if you're
not just talking about

00:23:21.880 --> 00:23:25.430
the technical aspects, which
obviously involve sharding and

00:23:25.430 --> 00:23:27.130
using the horizontal scalability
aspects of

00:23:27.130 --> 00:23:32.290
MongoDB, from an organizational
standpoint, we

00:23:32.290 --> 00:23:34.820
find the customers are just
loving MongoDB even actually

00:23:34.820 --> 00:23:36.490
if it's not a large
data problem.

00:23:36.490 --> 00:23:40.870
So the ability to not-- and like
I mentioned in my talk,

00:23:40.870 --> 00:23:43.050
almost every programming
language now is an

00:23:43.050 --> 00:23:44.530
object-oriented programming
language.

00:23:44.530 --> 00:23:48.310
So having a rich object data
structure in your database is

00:23:48.310 --> 00:23:51.500
really just unbelievable for
developer productivity.

00:23:51.500 --> 00:23:54.040
If you're using something like
server side JavaScript or

00:23:54.040 --> 00:23:58.430
Python or Ruby, and you have
this object in memory, you

00:23:58.430 --> 00:24:00.210
could just throw it into
the Datastore.

00:24:00.210 --> 00:24:03.890
We're finding that people are
really finding the schemaless

00:24:03.890 --> 00:24:05.980
nature of Mongo, the ability
that you could just add

00:24:05.980 --> 00:24:09.400
fields, the ability to just
insert things and take them

00:24:09.400 --> 00:24:12.300
out without having to do a lot
of transformations, is really

00:24:12.300 --> 00:24:14.400
helping from an organizational
standpoint, which is what I

00:24:14.400 --> 00:24:17.370
think you were getting at,
really scale development,

00:24:17.370 --> 00:24:18.620
really scale productivity.

00:24:21.900 --> 00:24:23.310
MIKE MILLER: Sorry, I didn't
mean to steal the mic.

00:24:23.310 --> 00:24:25.140
I think it's a good question
if I interpret it

00:24:25.140 --> 00:24:26.110
a little bit myself.

00:24:26.110 --> 00:24:28.040
I think one of the questions
is something

00:24:28.040 --> 00:24:29.680
like a document database.

00:24:29.680 --> 00:24:30.200
You're [? trading ?]

00:24:30.200 --> 00:24:31.740
JSON on the wire over HTTP.

00:24:31.740 --> 00:24:33.840
There's a lot of ways
to model your data.

00:24:33.840 --> 00:24:36.820
And that flexibility, again,
like education in terms of

00:24:36.820 --> 00:24:39.880
what is the best way for a
particular system to solve

00:24:39.880 --> 00:24:40.700
this problem.

00:24:40.700 --> 00:24:43.360
In our system, there are at
least four different ways to

00:24:43.360 --> 00:24:45.720
store one to many, many,
many relationships.

00:24:45.720 --> 00:24:49.010
And so a lot of that has to do
with just getting out best

00:24:49.010 --> 00:24:51.340
practices and understanding,
oh, my problem

00:24:51.340 --> 00:24:52.470
falls in this bucket.

00:24:52.470 --> 00:24:54.160
And that's something that I
think the communities in

00:24:54.160 --> 00:24:59.560
general are rapidly starting to
try to get down on paper.

00:24:59.560 --> 00:25:00.070
CHRIS RAMSDALE: I'll
add to it.

00:25:00.070 --> 00:25:02.850
To touch on the point of
everybody that's doing mobile

00:25:02.850 --> 00:25:04.980
as well today, I think there's
other things you want to

00:25:04.980 --> 00:25:07.940
consider as well in terms of
going after that approach and

00:25:07.940 --> 00:25:09.570
going after doing
document stores.

00:25:09.570 --> 00:25:11.875
While they're schemaless and
they're great and it makes it

00:25:11.875 --> 00:25:15.150
very easy to scale, you do lack
the things that you get

00:25:15.150 --> 00:25:18.460
from, say, doing row-column,
where you want to do, I want a

00:25:18.460 --> 00:25:20.630
subset of my property, because
you're trying to minimize the

00:25:20.630 --> 00:25:22.410
payload that's going back over
the wire to your mobile

00:25:22.410 --> 00:25:25.630
clients, especially when you're
doing a back end as a

00:25:25.630 --> 00:25:27.730
service type of solution when
there's no server side code to

00:25:27.730 --> 00:25:28.860
filter out.

00:25:28.860 --> 00:25:31.280
You're literally going from
the mobile device-- iOS,

00:25:31.280 --> 00:25:32.180
Android-- back to
the Datastore.

00:25:32.180 --> 00:25:34.550
You're like, no, no, no, I don't
need 100 properties.

00:25:34.550 --> 00:25:35.960
I only need the first five,
because that's actually what

00:25:35.960 --> 00:25:40.200
I'm showing in my limited
real estate view there.

00:25:40.200 --> 00:25:41.860
TYLER HANNAN: And I think this
is an important question, so

00:25:41.860 --> 00:25:44.210
I'm actually going to answer it
slightly differently, which

00:25:44.210 --> 00:25:49.520
is in the world of relational
databases, we started modeling

00:25:49.520 --> 00:25:52.410
our data by saying what
answers do I have.

00:25:52.410 --> 00:25:55.980
In the world of NoSQL,
non-relational databases, we

00:25:55.980 --> 00:25:58.550
start modeling our data
by saying what

00:25:58.550 --> 00:26:00.070
questions do I have.

00:26:00.070 --> 00:26:02.450
So you could think of it as a
top down approach rather than

00:26:02.450 --> 00:26:03.550
a bottom up.

00:26:03.550 --> 00:26:05.450
And it's not an either/or.

00:26:05.450 --> 00:26:08.260
There are situations where
you may want a relational

00:26:08.260 --> 00:26:13.010
datastore alongside a
non-relational with something

00:26:13.010 --> 00:26:14.990
specific for geospatial
indexing.

00:26:14.990 --> 00:26:18.240
That polyglot deployment is
important, and it's something

00:26:18.240 --> 00:26:21.010
that, as developers, I think we
can be excited about that

00:26:21.010 --> 00:26:23.090
we're not limited to
a set of tools.

00:26:23.090 --> 00:26:26.100
We have a broad range of tools
to draw from based upon

00:26:26.100 --> 00:26:27.170
application need.

00:26:27.170 --> 00:26:29.250
It's not a one to one
application to

00:26:29.250 --> 00:26:30.440
database model anymore.

00:26:30.440 --> 00:26:32.690
It's a one to many, depending on
what's living inside of the

00:26:32.690 --> 00:26:33.940
application.

00:26:38.930 --> 00:26:40.370
AUDIENCE: You mentioned
Spanner.

00:26:40.370 --> 00:26:42.980
Could you speak about how it
differs from BigTable, and are

00:26:42.980 --> 00:26:44.895
there any plans to expose
it via an API?

00:26:48.630 --> 00:26:49.340
CHRIS RAMSDALE: To repeat the
question, I think question

00:26:49.340 --> 00:26:53.380
was, I had mentioned Spanner,
and was there--

00:26:53.380 --> 00:26:55.350
AUDIENCE: How does it differ
from BigTable, and are there

00:26:55.350 --> 00:26:58.080
any plans to expose
it via an API?

00:26:58.080 --> 00:26:59.740
CHRIS RAMSDALE: So it doesn't
differ BigTable.

00:26:59.740 --> 00:27:01.660
It differs from Megastore and
how they're doing the

00:27:01.660 --> 00:27:02.910
replication.

00:27:04.750 --> 00:27:07.540
Spanner is, in many ways, the
next evolution of Megastore in

00:27:07.540 --> 00:27:09.800
the fact that it does
georeplication in a more

00:27:09.800 --> 00:27:12.760
efficient manner and actually
can do time stamping across

00:27:12.760 --> 00:27:13.520
multiple geos.

00:27:13.520 --> 00:27:17.170
So it really gets us to where
we're trying to go, is the

00:27:17.170 --> 00:27:18.480
global footprint.

00:27:18.480 --> 00:27:20.980
Whereas replication between
datacenters right now via

00:27:20.980 --> 00:27:22.850
Fiber is actually pretty good.

00:27:22.850 --> 00:27:24.580
Think about where do you want to
be in five years from now,

00:27:24.580 --> 00:27:26.030
10 years from now, where you're
like, I don't want to

00:27:26.030 --> 00:27:28.490
actually think about, unless
it's for compliancy reasons,

00:27:28.490 --> 00:27:30.090
where my data is.

00:27:30.090 --> 00:27:31.080
I just have a bunch of users.

00:27:31.080 --> 00:27:32.430
I have a great service
that's taking off.

00:27:32.430 --> 00:27:34.520
I'm the next Tumblr, Pinterest
or whatever.

00:27:34.520 --> 00:27:36.190
And they are all
over the place.

00:27:36.190 --> 00:27:37.380
And my data needs to
be replicated.

00:27:37.380 --> 00:27:39.920
So then I go across the Pacific
or I go across all the

00:27:39.920 --> 00:27:42.030
dark fiber that's in the
Atlantic or whatnot, it just

00:27:42.030 --> 00:27:43.670
happens in microseconds.

00:27:43.670 --> 00:27:45.140
So that's really the
goal of Spanner.

00:27:45.140 --> 00:27:47.060
And that's why I was looping it
back to Megastore, because

00:27:47.060 --> 00:27:48.990
Megastore is the service that
actually does the replication

00:27:48.990 --> 00:27:51.140
for us and for Google.

00:27:51.140 --> 00:27:53.070
There's a question about APIs.

00:27:53.070 --> 00:27:54.990
And yes, there's many
conversations underway about

00:27:54.990 --> 00:27:58.270
should we surface an API
on top of Spanner.

00:27:58.270 --> 00:28:00.020
I have my personal beliefs that
I think that what we're

00:28:00.020 --> 00:28:02.830
doing inside of HRD, inside of
the Cloud Datastore is the

00:28:02.830 --> 00:28:05.610
right way to go, because we're
actually pulling in--

00:28:05.610 --> 00:28:07.480
if you flip the bit on all of
Google's infrastructure right

00:28:07.480 --> 00:28:08.560
now and made it public, I think

00:28:08.560 --> 00:28:09.930
everybody would freak out.

00:28:09.930 --> 00:28:12.730
It's not the way I think that
everybody wants to program.

00:28:12.730 --> 00:28:14.630
So what I like what we're doing
inside of the cloud

00:28:14.630 --> 00:28:17.080
platform is we're putting that
layer on top of it that makes

00:28:17.080 --> 00:28:19.220
it really palatable for
developers to come along and

00:28:19.220 --> 00:28:21.390
use some pretty mind-blowing
infrastructure.

00:28:21.390 --> 00:28:23.200
AUDIENCE: So is that a no?

00:28:23.200 --> 00:28:23.380
CHRIS RAMSDALE: Say what?

00:28:23.380 --> 00:28:25.810
AUDIENCE: Is that a no?

00:28:25.810 --> 00:28:27.350
CHRIS RAMSDALE: No, no,
no, that's a not yet.

00:28:27.350 --> 00:28:28.000
It might.

00:28:28.000 --> 00:28:30.900
It's actually been debated
inside of Google right now.

00:28:35.000 --> 00:28:35.440
AUDIENCE: Hi, [? Stephan ?]

00:28:35.440 --> 00:28:37.450
[INAUDIBLE] from Rovio
Entertainment in Finland.

00:28:37.450 --> 00:28:40.830
I was wondering if you have some
advice, ideas, or tools

00:28:40.830 --> 00:28:44.620
to deal with backup and restore
strategy in reasonable

00:28:44.620 --> 00:28:47.140
time, because usually you deal
with huge amounts of data and

00:28:47.140 --> 00:28:48.320
distributed databases.

00:28:48.320 --> 00:28:52.300
And while most of them address
disaster scenarios already in

00:28:52.300 --> 00:28:55.986
this redundancy setup, there's
still a possibility that

00:28:55.986 --> 00:28:59.170
you'll cause data corruption by
bugs in the application--

00:28:59.170 --> 00:29:01.500
not that that would
ever happen.

00:29:01.500 --> 00:29:03.350
CHRIS RAMSDALE: Yeah, in
actuality, it's the

00:29:03.350 --> 00:29:05.830
application bugs that get you
all the time, not that Rovio

00:29:05.830 --> 00:29:08.020
would write any bugs.

00:29:08.020 --> 00:29:10.470
Like the pigs wouldn't go off
into space somewhere else and

00:29:10.470 --> 00:29:11.720
attack a planet.

00:29:14.960 --> 00:29:17.440
We have a backup and restore
functionality right now that's

00:29:17.440 --> 00:29:19.720
in its very much alpha
phase, I would say.

00:29:22.680 --> 00:29:23.830
That's user-initiated.

00:29:23.830 --> 00:29:25.520
We're in the process of
moving that into a

00:29:25.520 --> 00:29:27.190
fully managed service.

00:29:27.190 --> 00:29:30.020
It goes with the whole theme
of what we're trying to do.

00:29:30.020 --> 00:29:31.400
And that just gets us to
where we want to be.

00:29:31.400 --> 00:29:32.540
That's the baseline
functionality.

00:29:32.540 --> 00:29:34.393
That's an epic backup
is what I call it.

00:29:34.393 --> 00:29:36.290
So if you have 10 terabytes a
day, you're doing that backup

00:29:36.290 --> 00:29:36.760
all the time.

00:29:36.760 --> 00:29:38.950
And one could do the math in
their head and say, that's not

00:29:38.950 --> 00:29:41.160
necessarily the way I want
to be doing things.

00:29:41.160 --> 00:29:43.500
So then what we're going to do
is take it from there and go

00:29:43.500 --> 00:29:45.900
into doing incremental backups
with snapshots as well.

00:29:45.900 --> 00:29:47.550
So what you get is,
you get full

00:29:47.550 --> 00:29:49.570
backups that are reliable.

00:29:49.570 --> 00:29:51.540
Then you get backups for
cheap-- incremental.

00:29:51.540 --> 00:29:53.260
And then you get backups with
snapshotting, which gives you

00:29:53.260 --> 00:29:56.880
the consistency that you
can do them at anytime.

00:29:56.880 --> 00:29:59.340
WILL SHULMAN: So we run a cloud
service around MongoDB.

00:29:59.340 --> 00:30:01.890
There's lots of interesting
techniques that you can use

00:30:01.890 --> 00:30:03.440
with Mongo to deal with
this problem.

00:30:03.440 --> 00:30:04.300
And you're right.

00:30:04.300 --> 00:30:08.430
Almost always we deal with node
failure via replication.

00:30:08.430 --> 00:30:11.430
But human error is always when
people come calling us and

00:30:11.430 --> 00:30:14.570
say, hey, can you restore
backup for us?

00:30:14.570 --> 00:30:18.010
So we have a backup system that
does snapshotting and

00:30:18.010 --> 00:30:21.170
does the typical type of backup
you might expect.

00:30:21.170 --> 00:30:23.660
But there's other technologies,
both core to

00:30:23.660 --> 00:30:26.350
MongoDB and stuff that we're
building that's going to help

00:30:26.350 --> 00:30:26.880
even further.

00:30:26.880 --> 00:30:30.940
So one is a MongoDB technology
called Delayed Slaves, or

00:30:30.940 --> 00:30:31.730
Delayed Replication.

00:30:31.730 --> 00:30:34.650
So you can actually set up a
node that lags behind the

00:30:34.650 --> 00:30:37.200
master by an hour,
a day, a week.

00:30:37.200 --> 00:30:39.960
And that's one technique some
customers used to say OK, I

00:30:39.960 --> 00:30:42.050
fat fingered the database.

00:30:42.050 --> 00:30:44.050
I'm going to go to this Delayed
Slave that's maybe an

00:30:44.050 --> 00:30:45.080
hour behind.

00:30:45.080 --> 00:30:48.750
And I'll have a set of data that
is not corrupted by the

00:30:48.750 --> 00:30:51.410
bug or whatever caused
the problem.

00:30:51.410 --> 00:30:54.310
The other nice thing about
MongoDB is it has an op log of

00:30:54.310 --> 00:30:55.090
every operation.

00:30:55.090 --> 00:30:56.850
This is what replication
is driven off of.

00:30:56.850 --> 00:31:00.480
So you can actually restore
to a snapshot.

00:31:00.480 --> 00:31:03.420
Let's say you restore to a
snapshot from a day ago.

00:31:03.420 --> 00:31:07.400
Then you could replay the op log
to bring the data state to

00:31:07.400 --> 00:31:10.280
the operation right before the
operation that started to make

00:31:10.280 --> 00:31:12.450
things go wrong or started
to corrupt the database.

00:31:12.450 --> 00:31:14.570
So you could actually
do point in time.

00:31:14.570 --> 00:31:15.710
And that's also something
we're looking to

00:31:15.710 --> 00:31:18.370
productize as well.

00:31:18.370 --> 00:31:20.170
MIKE MILLER: Maybe I'll
just add an anecdote.

00:31:20.170 --> 00:31:23.650
I'm sure everybody here has
backup solutions and a story

00:31:23.650 --> 00:31:25.320
there available on
the product page.

00:31:25.320 --> 00:31:29.150
One interesting piece of data,
though-- and this is not fully

00:31:29.150 --> 00:31:29.580
quantitative.

00:31:29.580 --> 00:31:31.290
I'm just trying to this
in my mind right now.

00:31:31.290 --> 00:31:35.170
But I would estimate about 80%
of the user-initiated errors

00:31:35.170 --> 00:31:37.750
we've had are simply database
deletes by mistake.

00:31:37.750 --> 00:31:40.170
You have a REST API that
looks really clean.

00:31:40.170 --> 00:31:42.190
And it's like, you've
got a verb.

00:31:42.190 --> 00:31:43.990
You've got a base URL.

00:31:43.990 --> 00:31:45.390
You've got a collection
or a database.

00:31:45.390 --> 00:31:47.520
And then you've got a document,
maybe other things

00:31:47.520 --> 00:31:48.070
behind that.

00:31:48.070 --> 00:31:49.360
And you have a script
that somehow has an

00:31:49.360 --> 00:31:50.330
empty string in there.

00:31:50.330 --> 00:31:52.640
You just dropped the whole
database by mistake.

00:31:52.640 --> 00:31:56.230
And so actually about 80% of the
things that we have to do

00:31:56.230 --> 00:31:57.800
for users are restoring
databases

00:31:57.800 --> 00:31:58.880
that they just deleted.

00:31:58.880 --> 00:32:01.070
And so number one thing you
can do is rename files in

00:32:01.070 --> 00:32:01.890
garbage collects.

00:32:01.890 --> 00:32:04.730
There are basic operational
policies you can take that

00:32:04.730 --> 00:32:06.690
allow to, like, oh, that
email came in.

00:32:06.690 --> 00:32:08.210
Yeah, we just restored
it right away.

00:32:08.210 --> 00:32:09.710
Flip the bit.

00:32:09.710 --> 00:32:11.290
So it's interesting
to see actually.

00:32:11.290 --> 00:32:13.510
One of the things we should do
is talk about as you run the

00:32:13.510 --> 00:32:16.600
service, what are the things you
learn about the users that

00:32:16.600 --> 00:32:18.430
really drive how you go
back and feed that

00:32:18.430 --> 00:32:19.890
back into the product?

00:32:19.890 --> 00:32:22.960
JULIA FERRAIOLI: Don't make
delete calls too easy.

00:32:22.960 --> 00:32:23.780
CHRIS RAMSDALE: Just
do what we do.

00:32:23.780 --> 00:32:26.410
We make the writes, the delete
actually really expensive.

00:32:26.410 --> 00:32:28.300
And the storage is really cheap,
so you just keep the

00:32:28.300 --> 00:32:29.550
data around.

00:32:31.310 --> 00:32:32.560
I've got to poke
fun at myself.

00:32:35.490 --> 00:32:37.080
TYLER HANNAN: A whole
slew of options and

00:32:37.080 --> 00:32:38.810
opportunities with Riak.

00:32:38.810 --> 00:32:42.820
I'll just reiterate what the
gentleman said, which is

00:32:42.820 --> 00:32:46.320
backups are, again, a business
challenge in addition to a

00:32:46.320 --> 00:32:47.980
technology challenge,
particularly when you're

00:32:47.980 --> 00:32:49.250
considering latency.

00:32:49.250 --> 00:32:51.970
So whether you adopt a backup
strategy that's a fully

00:32:51.970 --> 00:32:54.960
replicated cluster that mirrors
production or whether

00:32:54.960 --> 00:32:58.200
you use some cool syincing
technology or whether you do

00:32:58.200 --> 00:33:01.080
more of a traditional sort of
replication, whatever you

00:33:01.080 --> 00:33:03.800
choose, plan for failure.

00:33:03.800 --> 00:33:06.030
That's my key message about
distributed systems.

00:33:06.030 --> 00:33:07.220
Plan for failure.

00:33:07.220 --> 00:33:08.470
And test it.

00:33:10.960 --> 00:33:13.570
JULIA FERRAIOLI: So we have a
little under six minutes left

00:33:13.570 --> 00:33:16.050
for questions.

00:33:16.050 --> 00:33:17.690
AUDIENCE: So my question is
very much related to the

00:33:17.690 --> 00:33:19.320
previous one.

00:33:19.320 --> 00:33:22.390
In human error events, if you
have an append-only database,

00:33:22.390 --> 00:33:24.890
where instead of deleting or
updating, then you can stop

00:33:24.890 --> 00:33:26.180
those errors as well.

00:33:26.180 --> 00:33:30.340
Do you guys have any plans to
support an append-only style

00:33:30.340 --> 00:33:34.740
database as a first class
kind of product?

00:33:34.740 --> 00:33:36.050
MIKE MILLER: I can tell you.

00:33:36.050 --> 00:33:38.280
Sorry, sometimes it sounds
like it cuts out.

00:33:38.280 --> 00:33:40.980
So we use modified portions
of the Apache

00:33:40.980 --> 00:33:42.810
CouchDB storage engine.

00:33:42.810 --> 00:33:45.870
So it's an append-only
copy and write b-tree

00:33:45.870 --> 00:33:47.710
So we're never overriding
our data.

00:33:47.710 --> 00:33:50.260
We compact it away in the
background after so much time

00:33:50.260 --> 00:33:51.680
or so many revisions.

00:33:51.680 --> 00:33:55.010
But we haven't fully leveraged
that yet to productize very

00:33:55.010 --> 00:33:58.550
clever incremental slash point
in time backup service.

00:33:58.550 --> 00:34:00.010
So there are great things you
can do that, depending on the

00:34:00.010 --> 00:34:02.820
storage model you choose for
primary and secondary indexes.

00:34:05.610 --> 00:34:08.320
CHRIS RAMSDALE: So HRD and the
Cloud Datastores, since we're

00:34:08.320 --> 00:34:10.260
built on top of BigTable,
we're already doing the

00:34:10.260 --> 00:34:10.980
append-only.

00:34:10.980 --> 00:34:12.915
This is why it's actually much
easier just to leave your data

00:34:12.915 --> 00:34:16.290
around, rather than it is to go
and do writes to delete it.

00:34:16.290 --> 00:34:19.120
And then to dovetail back into
what I was talking about to

00:34:19.120 --> 00:34:22.040
the guy from Rovio is that,
given that we have the

00:34:22.040 --> 00:34:24.670
foundation laid to allow us to
do incremental and snapshot

00:34:24.670 --> 00:34:26.969
backups at time based on the way
we're doing the appending.

00:34:32.010 --> 00:34:34.800
AUDIENCE: So there's a lot of
cool technologies being

00:34:34.800 --> 00:34:37.110
introduced and rolled
out to developers.

00:34:37.110 --> 00:34:40.270
But with the database, I always
wonder why are we still

00:34:40.270 --> 00:34:42.590
using HTTP to interface
with the data?

00:34:42.590 --> 00:34:45.070
Why are we using a stateless
connection?

00:34:45.070 --> 00:34:48.949
And my personal challenge is
using high concurrency at

00:34:48.949 --> 00:34:53.489
Python, you start accumulating
large file descriptors for all

00:34:53.489 --> 00:34:56.330
of the HTTP connections that
have come and gone and not

00:34:56.330 --> 00:34:57.200
been collected in time.

00:34:57.200 --> 00:34:59.900
And so it's a real challenge
managing that versus when I'm

00:34:59.900 --> 00:35:02.520
using Postgres or something
with traditional binary

00:35:02.520 --> 00:35:04.110
stateful connection,
I don't seem to

00:35:04.110 --> 00:35:05.060
run into those problems.

00:35:05.060 --> 00:35:08.160
So is there a plan to maybe
standardize a binary protocol

00:35:08.160 --> 00:35:10.120
or a stateful protocol
for these types of

00:35:10.120 --> 00:35:11.820
services coming out?

00:35:11.820 --> 00:35:14.440
WILL SHULMAN: So MongoDB
actually has

00:35:14.440 --> 00:35:15.810
a binary wire protocol.

00:35:15.810 --> 00:35:17.740
It actually isn't an
HTTP interface.

00:35:17.740 --> 00:35:21.620
MongoLab actually does offer
an HTTP interface on top of

00:35:21.620 --> 00:35:23.480
the Mongo protocol, and you can
use it if you'd like to.

00:35:23.480 --> 00:35:26.260
But I'd say 90% of our customers
use one of the

00:35:26.260 --> 00:35:29.440
standard MongoDB drivers
supported by 10 Gen.

00:35:29.440 --> 00:35:31.390
So almost every programming
language you might want to

00:35:31.390 --> 00:35:34.610
talk to MongoDB from, there's
a driver, and it's a tight

00:35:34.610 --> 00:35:36.720
wire protocol.

00:35:36.720 --> 00:35:41.760
It's based on the BSON spec,
which is at bsonspec.org.

00:35:41.760 --> 00:35:44.760
And yes, so very well
understood.

00:35:44.760 --> 00:35:46.650
And all the drivers have
connection pooling and things

00:35:46.650 --> 00:35:49.720
like that from a traditional
relational database, what

00:35:49.720 --> 00:35:52.240
you're probably used to.

00:35:52.240 --> 00:35:52.830
CHRIS RAMSDALE: But
I'll add to that.

00:35:52.830 --> 00:35:55.870
I think that the way we think
about is, with the stateful

00:35:55.870 --> 00:35:57.975
connections, whether you're
doing socket or whatnot, it

00:35:57.975 --> 00:35:59.800
ends up being a bottleneck in
your system when you're trying

00:35:59.800 --> 00:36:01.140
to scale out horizontally.

00:36:01.140 --> 00:36:02.240
So that's one.

00:36:02.240 --> 00:36:03.900
And so we try to avoid those
wherever we can.

00:36:03.900 --> 00:36:05.610
So HTTP just happens to
be the mechanism.

00:36:05.610 --> 00:36:07.010
Maybe that's going to
change over time.

00:36:07.010 --> 00:36:07.630
Hopefully it does.

00:36:07.630 --> 00:36:09.580
There's a fair amount of
overhead to bring those

00:36:09.580 --> 00:36:10.370
connections up.

00:36:10.370 --> 00:36:12.810
And then two, what I'll add is,
think about it in terms of

00:36:12.810 --> 00:36:15.640
when the server goes away, when
it really is just a bunch

00:36:15.640 --> 00:36:18.180
of mobile clients, when they're
actually doing, when

00:36:18.180 --> 00:36:19.870
we've got all the auth figured
out and things like that.

00:36:19.870 --> 00:36:22.230
So you're making a connection
back from the client.

00:36:22.230 --> 00:36:23.740
The last thing you'd want
to have is a persistent

00:36:23.740 --> 00:36:26.960
connection over extremely
flaky carrier

00:36:26.960 --> 00:36:28.850
connection like 3G or 4G.

00:36:28.850 --> 00:36:31.230
So I think we've got to start
thinking in terms of the

00:36:31.230 --> 00:36:32.050
paradigm shift has already

00:36:32.050 --> 00:36:34.870
happened to going to stateless.

00:36:34.870 --> 00:36:36.390
MIKE MILLER: Yeah, I'll
completely second that.

00:36:36.390 --> 00:36:39.360
We actually only support HTTP
connection because we're firm

00:36:39.360 --> 00:36:40.180
believers--

00:36:40.180 --> 00:36:43.120
well, if we look at our user
base, it's over half

00:36:43.120 --> 00:36:43.615
JavaScript.

00:36:43.615 --> 00:36:45.960
A lot of that is directly
from the clients.

00:36:45.960 --> 00:36:49.400
And so we think a decade from
now, a, nobody will run their

00:36:49.400 --> 00:36:50.780
own databases.

00:36:50.780 --> 00:36:54.950
And b, we'll be, if not
completely in a two-tier

00:36:54.950 --> 00:36:57.470
stack, then something that looks
like a very, very thin

00:36:57.470 --> 00:36:58.780
middle tier, which is
just for session

00:36:58.780 --> 00:37:00.320
management and sign-ups.

00:37:00.320 --> 00:37:01.600
And it's going to be
direct connection

00:37:01.600 --> 00:37:02.350
from your mobile device.

00:37:02.350 --> 00:37:05.410
So for that, now HTTP, maybe
in the future, web sockets,

00:37:05.410 --> 00:37:06.970
things that are a little
bit faster and

00:37:06.970 --> 00:37:08.110
lighter weight protocols.

00:37:08.110 --> 00:37:10.025
But I think that's
the direction the

00:37:10.025 --> 00:37:11.275
world's moving in.

00:37:14.224 --> 00:37:15.150
JULIA FERRAIOLI:
Next question?

00:37:15.150 --> 00:37:18.200
AUDIENCE: Do you have any advice
if the data is actually

00:37:18.200 --> 00:37:21.040
graph-like, where it doesn't
fit into a document.

00:37:21.040 --> 00:37:23.470
For example, the data is big
but you need to traverse.

00:37:23.470 --> 00:37:27.000
Think about Knowledge Graph,
but the data is huge.

00:37:27.000 --> 00:37:28.480
How do you distribute it?

00:37:28.480 --> 00:37:30.890
Any advice?

00:37:30.890 --> 00:37:33.690
TYLER HANNAN: So the question
was, advice regarding modeling

00:37:33.690 --> 00:37:36.860
graph style data.

00:37:36.860 --> 00:37:39.020
I'm going to say something
that maybe people at my

00:37:39.020 --> 00:37:41.010
company wouldn't like, which
is you should look into a

00:37:41.010 --> 00:37:42.720
graph database.

00:37:42.720 --> 00:37:43.586
They're there.

00:37:43.586 --> 00:37:46.770
They're really freaking amazing,
and they do their job

00:37:46.770 --> 00:37:47.780
really well.

00:37:47.780 --> 00:37:51.580
So if that's the model that you
need, I would encourage

00:37:51.580 --> 00:37:54.370
you to look into the people
who are building a data

00:37:54.370 --> 00:37:57.790
storage for that model.

00:37:57.790 --> 00:37:59.850
MIKE MILLER: I'll answer that.

00:37:59.850 --> 00:38:03.450
If your data fits in memory,
Neo4j is your database, that's

00:38:03.450 --> 00:38:03.870
pretty spectacular.

00:38:03.870 --> 00:38:04.890
It's got a REST API.

00:38:04.890 --> 00:38:05.870
It's awesome.

00:38:05.870 --> 00:38:09.160
And it's an incredible team
with a great community.

00:38:09.160 --> 00:38:12.910
If it doesn't fit there, certain
type of graph problems

00:38:12.910 --> 00:38:15.880
are amenable to MapReduce
processing, not all.

00:38:15.880 --> 00:38:17.840
There's some great talks from
Twitter about how they're

00:38:17.840 --> 00:38:19.460
swinging their Hadoop hammer,
because it's the only hammer

00:38:19.460 --> 00:38:22.780
they have, but how they get into
some really funny spots,

00:38:22.780 --> 00:38:26.160
where they have to get very
clever with approximate sets

00:38:26.160 --> 00:38:28.030
and hash tables and
things like that.

00:38:28.030 --> 00:38:30.470
But some problems are
well-suited to MapReduce.

00:38:30.470 --> 00:38:31.980
So that opens up a lot
of doors for you.

00:38:31.980 --> 00:38:33.900
It's about data modeling,
again.

00:38:33.900 --> 00:38:36.630
But if that doesn't work for
you, you're probably not going

00:38:36.630 --> 00:38:38.340
to solve the distributed
graph problem yourself.

00:38:38.340 --> 00:38:41.030
The community has been working
on that for a very long time.

00:38:41.030 --> 00:38:43.460
So we should probably start to
lean on these guys over here

00:38:43.460 --> 00:38:48.340
about maybe open sourcing
something around Pregel.

00:38:48.340 --> 00:38:48.470
CHRIS RAMSDALE: Noted.

00:38:48.470 --> 00:38:51.800
[LAUGHTER]

00:38:51.800 --> 00:38:53.700
JULIA FERRAIOLI: So we're
just about out of time.

00:38:53.700 --> 00:38:56.220
I would encourage you to
come up and talk to

00:38:56.220 --> 00:38:57.620
us after the session.

00:38:57.620 --> 00:39:00.120
We'll probably move a little
bit outside, so we can

00:39:00.120 --> 00:39:04.220
actually let the next
folks set up.

00:39:04.220 --> 00:39:05.540
But I just wanted to
say thank you.

00:39:05.540 --> 00:39:06.470
Thank you to all of you.

00:39:06.470 --> 00:39:08.770
Thank you to our panelists for
coming out here today.

00:39:08.770 --> 00:39:12.370
[APPLAUSE]

