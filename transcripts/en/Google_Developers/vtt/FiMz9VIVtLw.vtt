WEBVTT
Kind: captions
Language: en

00:07:59.749 --> 00:08:02.840
 &gt;&gt; JACOB WENGER:  I am a huge 
soccer man fan, have been my 

00:08:02.841 --> 00:08:05.971
entire life.  I have found 
memories of playing the game 

00:08:05.972 --> 00:08:10.000
grow willing up excluding the 
time Is I got kicked in the face

00:08:15.836 --> 00:08:18.472
it's a game I'm playing in or 
not.  Over the years you could 

00:08:18.473 --> 00:08:22.689
say I have learned the p
rimitives of the game, pass, 

00:08:22.690 --> 00:08:26.314
shooting, dribbling, defending, 
doing skill moves.  Each concept

00:08:31.657 --> 00:08:37.704
have a player skill set.  In a 
similar withdraw, security for 

00:08:42.458 --> 00:08:45.566
gut when you compose them 
together you can form powerful 

00:08:45.567 --> 00:08:49.205
rules and protect data even for 
complex applications.  And today

00:08:51.106 --> 00:08:53.106
to speak and I will train you on

00:08:53.121 --> 00:08:56.454
these  concepts. 
 If you haven't ghessed it, I 

00:08:56.455 --> 00:09:00.174
will be using the help of the 
swoart R sport oi love.  I sl 

00:09:00.175 --> 00:09:05.720
been on the Firebase team over 
two years now.  So you could say

00:09:07.633 --> 00:09:11.264
on the real time database.  I'm 
hoping to share the knowledge 

00:09:11.265 --> 00:09:13.479
with you today.  I know it's 
early and I'm talking about 

00:09:13.887 --> 00:09:15.887
security, a traditionally boring

00:09:16.016 --> 00:09:18.925
subject, so I thought I would 
spice it up a bit and instead of

00:09:21.151 --> 00:09:23.969
Firebase security, we will talk 
about the key to Firebase 

00:09:24.189 --> 00:09:28.910
security as told with  emogi.  
So 

00:09:29.108 --> 00:09:31.120
you will be seeing that over the

00:09:31.419 --> 00:09:35.156
next  half hour.  You heard how 
Firebase is more than just a 

00:09:35.157 --> 00:09:38.393
real time database.  It is a 
suite of integrated products to 

00:09:38.394 --> 00:09:42.830
help you develop your app, grow 
your user base, and earn money. 

00:09:44.439 --> 00:09:47.663
gap a little Brit between the 
old and new world and talk to 

00:09:47.664 --> 00:09:50.672
you about security in your 
Firebase apps across two 

00:09:50.778 --> 00:09:55.518
different products. 
 The first is the Firebase real 

00:09:55.519 --> 00:09:59.544
time database.  This is the old 
reliable battle tested real time

00:10:04.486 --> 00:10:08.917
arbitrary Jayson data such as 
team schedule.  The second 

00:10:09.015 --> 00:10:13.354
product is the brand shiny new 
Firebase storage.  You will use 

00:10:13.355 --> 00:10:16.875
this to store files like video 
might lights from last night's 

00:10:16.876 --> 00:10:21.512
match or an audio clip of a 
Spanish announcer screaming g

00:10:21.513 --> 00:10:27.158
oal!.  I do not know how they 
hold that for so long.  Thank 

00:10:27.159 --> 00:10:29.159
you, thank 

00:10:31.398 --> 00:10:35.000
you. 
 In order to explain Firebase 

00:10:35.001 --> 00:10:37.921
security, I first need  need to 
tell 

00:10:38.121 --> 00:10:40.839
you what exactly do I mean by 
security.  The way I see it is 

00:10:40.840 --> 00:10:44.267
that there are two sides to the 
security coin.  On one side you 

00:10:44.268 --> 00:10:46.995
have authentication and on the 
other side you have 

00:10:48.105 --> 00:10:50.622
authorization.  What exactly do 
these terms mean?  

00:10:51.138 --> 00:10:53.138
Authentication is the process of

00:10:53.245 --> 00:10:55.965
verifying users are who they 
actually say they are.  So this 

00:10:55.966 --> 00:11:00.190
user is Sarah, and this user is 
Billy.  Authorization on the 

00:11:00.191 --> 00:11:03.527
other hand is the process of 
determining who has access to 

00:11:03.528 --> 00:11:06.953
what data.  So maybe Sarah has a

00:11:06.954 --> 00:11:08.259
ticket to the match and is going

00:11:08.260 --> 00:11:12.794
to be ail to get in whereas 
Billy is empty handed and w

00:11:12.795 --> 00:11:16.027
illing stuck watching the game 
from the pub. 

00:11:16.028 --> 00:11:18.028
 Traditionally implementing both

00:11:18.244 --> 00:11:20.972
sides of security took a lot of 
work.  You had to manage your 

00:11:20.973 --> 00:11:24.907
own servers, you had to set up 
your own databases, and you will

00:11:27.640 --> 00:11:30.859
serverside code to protect your 
users.  Thankfully Firebase 

00:11:31.159 --> 00:11:33.391
makes this simple because we 
have products that do this out 

00:11:33.392 --> 00:11:36.810
of the box. 
 On the authenticationside, we 

00:11:36.811 --> 00:11:40.548
have a product calls Firebase 
authentication.  Very original, 

00:11:40.549 --> 00:11:42.867
I know.  Firebase authentication

00:11:43.062 --> 00:11:46.595
allows you to verify users in a 
bunch of different ways.  Behave

00:11:49.598 --> 00:11:53.641
allows you to sign a unique 
identifier to every user.  We 

00:11:53.642 --> 00:11:56.854
have email password age next 
indication which allows you to 

00:11:56.855 --> 00:12:01.998
verify user using a combination 
of email and  password then 

00:12:02.612 --> 00:12:06.623
there 
is O off that uses third party 

00:12:06.624 --> 00:12:10.562
like face bike or Google to 
authorize on your behalf. 

00:12:10.563 --> 00:12:13.172
 Finally, there is custom 
authentication.  When you need 

00:12:13.173 --> 00:12:18.115
something extra, or custom, and 
or you need integrate request 

00:12:18.116 --> 00:12:22.949
wantisting off solution.  I 
won't be focusing very much on 

00:12:22.950 --> 00:12:25.966
Firebase authentication during 
this talk but if you are 

00:12:26.267 --> 00:12:28.477
interested in it, tomorrow at 
1: 

00:12:28.478 --> 00:12:32.621
1:00 p.m. on this stage, best 
practices for a great sign in 

00:12:32.622 --> 00:12:36.154
experience.  So if you want to 
learn more, check that out. 

00:12:36.155 --> 00:12:39.372
 What I will be focusing on 
today is authorization.  The way

00:12:41.683 --> 00:12:46.032
is we use what we call Firebase 
rules for both the real time 

00:12:46.033 --> 00:12:51.754
database and for Firebase 
storage.  I think the best way 

00:12:51.755 --> 00:12:54.484
to learn this stuff is to 
actually go through a ton of 

00:12:54.485 --> 00:12:57.312
different examples and we are 
going to start with learning the

00:12:59.627 --> 00:13:03.341
time database rules language.  
Before we can actually protect 

00:13:03.342 --> 00:13:08.089
data, we need to know what data 
we are going to  pro protect.  

00:13:08.090 --> 00:13:09.907
Kicking things off we will start

00:13:09.908 --> 00:13:14.140
with example data. 
 The real time database stores J

00:13:14.141 --> 00:13:18.377
SON data.  Sear we have an 
empty JSON object we can say 

00:13:18.378 --> 00:13:21.199
let's put a top level games n
ode.  This is where we will 

00:13:21.290 --> 00:13:23.212
store all of the game 
information including the 

00:13:23.213 --> 00:13:26.238
schedule for the current team.  
Within the games node we are 

00:13:26.239 --> 00:13:30.584
going to have a bunch of random 
IDs which we call push IDs in 

00:13:30.585 --> 00:13:33.186
the real time database and these

00:13:33.387 --> 00:13:37.010
will uniquely identify every 
game in our list. 

00:13:37.011 --> 00:13:39.025
 So within each game we will 
have a bunch of different 

00:13:39.424 --> 00:13:42.362
content about that game.  We 
will have the date of the game, 

00:13:42.363 --> 00:13:46.295
who the opponent is and whether 
or not the game is open to the 

00:13:46.296 --> 00:13:50.125
public.  There will also be a 
game content node.  This is data

00:13:53.441 --> 00:13:54.746
ticketed 
customers only so people who 

00:13:54.747 --> 00:13:59.377
have bought  ticket to the game 
should be able to see stuff in 

00:13:59.378 --> 00:14:02.106
game content.  Lastly we will 
have a tickets node and this 

00:14:02.107 --> 00:14:04.640
will be a list of users who have

00:14:04.853 --> 00:14:07.158
tickets to the game.  The best 
place to start with security is 

00:14:07.159 --> 00:14:11.091
with what the defaults are. 
 Additionally our default rules 

00:14:11.092 --> 00:14:13.092
looked like this.  Just like the

00:14:13.107 --> 00:14:15.032
data you store in your real time

00:14:15.033 --> 00:14:19.362
database, you're rules are also 
a JSON object.  It has a top 

00:14:19.363 --> 00:14:24.800
level rules node, and then 
within that by default we have 

00:14:24.801 --> 00:14:28.032
read true write true.  This is 
the first primitive we will 

00:14:30.137 --> 00:14:33.361
learn,.read and.write, it 
determines who has read access 

00:14:33.362 --> 00:14:35.987
and who has write access.  So as

00:14:36.180 --> 00:14:38.905
I'm sure you can tell, this m
eans everyone and anyone has 

00:14:38.906 --> 00:14:41.642
access to all of your date sta 
both to read it and write it.  

00:14:41.643 --> 00:14:43.643
This is pretty great for getting

00:14:43.750 --> 00:14:45.359
started because you can go ahead

00:14:45.360 --> 00:14:47.573
and create new Firebase database

00:14:47.983 --> 00:14:51.502
and start writing and reading 
from it right away,  but it also

00:14:53.535 --> 00:14:56.248
malicious attacker, to steal 
your data. 

00:14:56.249 --> 00:15:01.587
 How would they do that?  They 
can easily circumvent them by 

00:15:01.588 --> 00:15:06.229
writing a few lines of code.  
This is using the Firebase 3.0

00:15:06.230 --> 00:15:08.237
SDK.  What we are going to d
o, with those of you familiar 

00:15:08.238 --> 00:15:10.238
with the real time database, you

00:15:10.466 --> 00:15:12.786
used to do new Firebase and pass

00:15:13.795 --> 00:15:20.125
your database URL now, you will 
all  Firebase.initialize app.  

00:15:20.126 --> 00:15:24.858
And the database oral which is 
where you are going to store 

00:15:24.859 --> 00:15:26.668
data.  Once you have an instance

00:15:26.669 --> 00:15:31.002
of an app, you can get a 
database instance and then c

00:15:31.003 --> 00:15:33.527
all.ref on that.  That will 
give you a reference, a pointing

00:15:37.951 --> 00:15:39.172
Firebase real time database.  We

00:15:39.173 --> 00:15:43.204
won't pull data yet but we can 
do that by doing a once value.  

00:15:43.205 --> 00:15:45.519
This will do a get on our data. 

00:15:45.810 --> 00:15:48.233
This will return a promise 
fulfilled with the snapshot of 

00:15:48.234 --> 00:15:53.283
the data.  This is an immutable 
snapshot and we can extract data

00:15:59.527 --> 00:16:02.358
 This is not great.  So as of 
yesterday we have updated 

00:16:02.559 --> 00:16:05.471
default rules when you create a 
Firebase real time database.  So

00:16:07.699 --> 00:16:09.907
instead of read true write true.

00:16:09.908 --> 00:16:11.937
We are going to see off does not

00:16:12.136 --> 00:16:14.965
equal null for both of those.  
This is the next concept, this 

00:16:14.966 --> 00:16:19.111
off variable.  This is a top 
level variable populated by the 

00:16:19.112 --> 00:16:22.933
rules language itself and it 
represents the authentication 

00:16:22.934 --> 00:16:25.342
state of the client making the 
request. 

00:16:25.343 --> 00:16:26.856
 So if I'm making a request from

00:16:26.857 --> 00:16:29.893
a laptop that is not 
authenticated with Firebase, 

00:16:29.894 --> 00:16:33.828
this auth variable will be null 
and I won't be able to read or 

00:16:33.829 --> 00:16:38.355
write data.  If I'm making it 
from a phone authenticated with 

00:16:38.356 --> 00:16:40.356
Facebook, the auth variable will

00:16:40.760 --> 00:16:44.515
not be null and it will contain 
UID which is a unique identifier

00:16:45.902 --> 00:16:49.143
specific user signs in via 
Facebook, they will be given the

00:16:51.748 --> 00:16:54.573
authenticated I will be able to 
read.  So this is better because

00:16:57.409 --> 00:17:01.230
providers are enabled for your 
Firebase database when you 

00:17:01.329 --> 00:17:06.566
create it.  By default no one 
did read or write data and you 

00:17:06.567 --> 00:17:09.892
need to add authentication.  
Let's say you want to add 

00:17:10.517 --> 00:17:13.409
anonymous oak thent case which 
is common use case for many 

00:17:13.815 --> 00:17:18.357
aches.  Now, a guy who can see 
the rules says I can work with 

00:17:18.358 --> 00:17:22.278
this because they are still a 
bit too open.  Let's look at 

00:17:22.279 --> 00:17:25.404
code.  We will initialize the 
app in the same way.  Now we 

00:17:25.405 --> 00:17:30.847
will call auth.sign in a
nonymously.  We will be 

00:17:31.345 --> 00:17:32.351
authenticated and any request we

00:17:32.352 --> 00:17:36.890
make from this client will have 
a non-null auth variable in the 

00:17:36.891 --> 00:17:40.425
rules.  We go ahead and after 
that promise is fulfilled we 

00:17:40.426 --> 00:17:42.426
will get I reference to our root

00:17:42.632 --> 00:17:46.468
of our database, we will this 
time remove the data and then we

00:17:48.482 --> 00:17:52.718
removed.  So this is kind of 
terrifying. 

00:17:53.626 --> 00:17:55.843
terrifying.  And not what we 
want by the time we release our 

00:17:55.844 --> 00:17:58.362
application to production. 
 So I know exactly what you are 

00:17:58.363 --> 00:18:00.363
thinking, you are saying this  
saying this is 

00:18:01.376 --> 00:18:04.295
really easy Jacob, all you need 
to do is lock this thing down.  

00:18:04.296 --> 00:18:08.533
So we can do that.  We can say 
let's go ahead and say no one 

00:18:08.534 --> 00:18:15.001
can read and  no one can write 
anything at all.  100 points, my

00:18:16.404 --> 00:18:20.340
touching my data.  This is very 
true, but it also kind of r

00:18:20.341 --> 00:18:24.370
enders your app pointless. 
 Kind of like the face massage 

00:18:24.371 --> 00:18:29.808
emogi which I legitimately have 
never had a chance to use before

00:18:31.525 --> 00:18:36.057
beyond this obviously pointless 
rules set I want to introduce an

00:18:39.391 --> 00:18:42.808
read and write false is 
equivalent to not putting those 

00:18:42.809 --> 00:18:46.345
rules at all and the default 
value is false. 

00:18:46.346 --> 00:18:48.247
 So this is a contrived example,

00:18:48.248 --> 00:18:50.978
but these two rule sets are the 
same.  This will come into place

00:18:56.015 --> 00:18:58.845
allow anyone to read or write.  
So let's say we will grant 

00:18:59.230 --> 00:19:02.461
public access to all of the 
games node.  How can we do that?

00:19:04.279 --> 00:19:08.010
 We will go ahead and create a 
games node within our rules and 

00:19:08.011 --> 00:19:11.340
say read true.  So everyone can 
read all of the different games 

00:19:11.341 --> 00:19:15.464
and see the entire schedule.  
This is not exactly what we want

00:19:17.079 --> 00:19:20.713
want to have only ticketed 
customers or only people who are

00:19:22.437 --> 00:19:26.168
games we allow them to be p
ublic.  So we can go ahead and 

00:19:26.169 --> 00:19:31.812
make a semi public schedule by 
instead of doing read true, 

00:19:32.406 --> 00:19:35.138
actually specifying the game ID 
for every game and for the top 

00:19:35.139 --> 00:19:37.453
game, we know the public flag is

00:19:37.657 --> 00:19:40.891
it set to true so we will put 
read true, and for the other 

00:19:40.892 --> 00:19:44.517
game, we know that it's not 
public, so we need to be 

00:19:45.135 --> 00:19:48.138
authenticated. 
 So this works, although it has 

00:19:48.139 --> 00:19:51.967
a couple of issues.  The first 
is that this read true rule is 

00:19:51.968 --> 00:19:54.390
hard coded.  And the only reason

00:19:54.682 --> 00:19:58.312
we put read true is we know the 
data we started with the is 

00:19:58.510 --> 00:20:01.432
public field was set to true.  
But what we want to look at is 

00:20:01.433 --> 00:20:03.562
we want to look at the is public

00:20:03.760 --> 00:20:08.596
field itself and use that 
existing data to 2KER78 our -- 

00:20:08.597 --> 00:20:12.426
determine our rule.  We can go 
ahead and do this by changing 

00:20:12.427 --> 00:20:15.541
both of these rules to the same 
rule.  And the rule is going to 

00:20:15.542 --> 00:20:21.793
say, am I authenticated?  Or is 
public field set to true? 

00:20:21.794 --> 00:20:26.328
 So we start with our auth does 
not equal null and then we say, 

00:20:26.329 --> 00:20:29.763
we use the data variable.  This 
is a top level variable like 

00:20:29.764 --> 00:20:33.072
auth which represents the 
existing data in your Firebase 

00:20:33.073 --> 00:20:36.813
real time database.  So we say 
at the current location, which 

00:20:36.814 --> 00:20:43.955
is games/that long UID, is 
public child stet and is its 

00:20:43.956 --> 00:20:46.690
value true?  If so, allow anyone

00:20:46.871 --> 00:20:50.314
to read this note. 
 So this is getting us closer, 

00:20:50.315 --> 00:20:54.733
but we still have another 
problem.  These game IZs are 

00:20:54.734 --> 00:20:59.174
randomly generated push IDs..  
We won't know what they are 

00:20:59.376 --> 00:21:01.796
before our app is sent to 
production so we can't hard code

00:21:03.606 --> 00:21:05.515
to have to specify the same rule

00:21:05.516 --> 00:21:08.744
over and over for all of the 
games.  So we can go ahead and 

00:21:08.745 --> 00:21:10.859
get rid of that and replace them

00:21:10.962 --> 00:21:13.088
with what we call wildcard 
locations. 

00:21:13.089 --> 00:21:16.314
 That's what this dollar 
represents.  So dollar game ID 

00:21:16.315 --> 00:21:20.436
is a wildcard character kind of 
like a variable that will match 

00:21:20.437 --> 00:21:24.774
all strings.  So it will match 
all of those game IDs that we 

00:21:24.775 --> 00:21:26.775
previously saw.  Now, instead of

00:21:26.893 --> 00:21:29.403
specifying this rule that we saw

00:21:29.712 --> 00:21:33.948
earlier for every game, we only 
need to specify one time.  So 

00:21:33.949 --> 00:21:37.468
this is good except for the fact

00:21:37.672 --> 00:21:40.993
that the data we store in the 
games node is actually, we want 

00:21:40.994 --> 00:21:43.920
different access levels for 
different pieces of data.  For 

00:21:43.921 --> 00:21:48.560
this top field, the date, the 
opponent and the is public f

00:21:48.561 --> 00:21:51.385
lags, that should always be 
publicly readable by everybody. 

00:21:52.588 --> 00:21:56.518
shouldn't be ail to look at the 
date, opponent and is public 

00:21:56.519 --> 00:21:59.340
flag. 
 Whereas the game content we 

00:21:59.341 --> 00:22:03.080
only want ticketed customers to 
see this or see it if it is 

00:22:03.276 --> 00:22:06.501
public and then the tickets n
ode, we will want to lock down 

00:22:06.502 --> 00:22:10.933
on a per-user basis where I can 
go ahead and buy a ticket myself

00:22:14.455 --> 00:22:19.205
dome person can't -- random 
person can't write to  my ticket

00:22:20.614 --> 00:22:24.343
this, let's put a read rule on 
our game and then underneath 

00:22:24.344 --> 00:22:27.875
that we will say, you can only 
read the game content given that

00:22:30.094 --> 00:22:33.841
 And then for tickets, we do 
want to do it on a per-user 

00:22:34.428 --> 00:22:37.339
basis, but for now we will say 
do you have a ticket, if so, you

00:22:38.964 --> 00:22:41.987
eems like it would work except 
it actually won't.  That's 

00:22:42.185 --> 00:22:46.231
because of what we call the 
rules  cascade.  Which is a core

00:22:48.433 --> 00:22:50.433
 The rules cascade.  Essentially

00:22:50.563 --> 00:22:55.391
says in order to read data at A
/B/C, you just need a read rule 

00:22:55.392 --> 00:22:59.840
that evaluates to true at any 
level in that parent hierarchy. 

00:23:00.023 --> 00:23:03.156
 So in order to read the data at

00:23:04.361 --> 00:23:06.986
games, game ID, game content, we

00:23:07.394 --> 00:23:10.204
actually would start at the top 
and look at the games node and 

00:23:10.205 --> 00:23:12.435
say do we have a read rule here.

00:23:12.620 --> 00:23:16.453
We don't, but we know that that 
just implies that we have a read

00:23:18.783 --> 00:23:21.997
read won't be allowed at that 
level because we don't, we don't

00:23:25.218 --> 00:23:28.441
move to the  next level and go 
to 

00:23:28.747 --> 00:23:32.480
game ID.  Game ID does have a 
read rule which evaluates to 

00:23:32.481 --> 00:23:34.700
read true.  The read will be 
allowed. 

00:23:34.701 --> 00:23:37.830
 And so we actually will 
completely ignore this game 

00:23:38.624 --> 00:23:40.751
content read rule.  That's 
because if we are allowing 

00:23:41.048 --> 00:23:45.983
people to read games/game ID, 
then they certainly are going to

00:23:48.924 --> 00:23:52.138
game content.  In addition this 
tickets room won't be included 

00:23:52.139 --> 00:23:55.056
either.  So we need to work 
around this a little bit. 

00:23:55.057 --> 00:23:58.907
 The way we can do that, one 
option is copying these two 

00:23:59.293 --> 00:24:01.293
rules we had previously and then

00:24:01.420 --> 00:24:04.148
specifying read true for every 
field we want to be publicly 

00:24:04.149 --> 00:24:07.876
readable.  This definitely w
orks, but it involves a bunch 

00:24:07.877 --> 00:24:10.792
of different read rules and now 
every time we want to add 

00:24:11.293 --> 00:24:14.215
another public field, we are 
going to have to add to our 

00:24:14.517 --> 00:24:18.046
rules.  So if we want to add a 
time to let people know when the

00:24:19.463 --> 00:24:22.790
add a rule which is time read 
true. 

00:24:22.791 --> 00:24:27.435
 So we can actually get around 
this by restructuring our data a

00:24:29.940 --> 00:24:33.371
opponent and is public at the 
top level of the game, we can 

00:24:33.372 --> 00:24:36.595
get rid of it, add a metadata 
node and throw those things in 

00:24:36.596 --> 00:24:41.343
the metadata node.  We can 
refactor our rules in a similar 

00:24:41.344 --> 00:24:44.261
way, get rid of the three rules,

00:24:44.462 --> 00:24:49.622
replace them with a single 
metadata rule  which is read t

00:24:49.623 --> 00:24:51.214
rue. 
 Our rules are simpler, we have 

00:24:51.215 --> 00:24:55.766
fewer of them and if  we want to

00:24:55.947 --> 00:24:57.779
add the time node, we don't have

00:24:57.780 --> 00:25:00.904
to add anything to the rules.  
We can add it to metadata and it

00:25:04.531 --> 00:25:07.152
 The next thing we want to talk 
about is this rule here.  

00:25:07.464 --> 00:25:09.171
Currently we are  allowing 
people 

00:25:09.172 --> 00:25:10.778
to read the game content node if

00:25:10.779 --> 00:25:13.903
they are authenticated at all.  
In our soccer example, this 

00:25:14.107 --> 00:25:17.141
essentially would be I have a 
ticket but I have a ticket to 

00:25:17.142 --> 00:25:19.964
some game, not I have a ticket 
to this game. 

00:25:19.965 --> 00:25:22.591
 So we actually want to lock it 
down to only people who have 

00:25:22.592 --> 00:25:26.627
tickets to this game not a 
ticket in general.  So in order 

00:25:26.628 --> 00:25:28.623
to do that, let's take a look at

00:25:28.624 --> 00:25:31.463
what our tickets node look  
looks l

00:25:31.464 --> 00:25:35.181
ike.  Wore going to have it k
eyed by unique identify e

00:25:35.182 --> 00:25:38.521
veries.  These are UIDs I was 
talking about earlier.  So it's 

00:25:38.522 --> 00:25:41.540
a long, you can assume it's a 
random string and we are going 

00:25:41.541 --> 00:25:47.594
to create a hash map of those, 
of those UIDs.  And so we can go

00:25:49.408 --> 00:25:54.153
and say our tickets node is 
going to be keyed by UID.  So we

00:26:00.789 --> 00:26:05.623
read and write if off.UID equals

00:26:06.335 --> 00:26:09.361
dollar UID. 
 We know the auth variable has 

00:26:09.362 --> 00:26:12.481
user identification state so 
currently logged in user and if 

00:26:12.482 --> 00:26:16.608
their UID is the same as the 
location we are writing to, 

00:26:16.808 --> 00:26:18.937
which is the dollar UID, we will

00:26:19.135 --> 00:26:21.969
allow them to write to the node 
and read from it.  This is what 

00:26:21.970 --> 00:26:23.970
we call user based security.  So

00:26:24.187 --> 00:26:26.910
we have locked down the  tickets

00:26:27.410 --> 00:26:29.627
node.  The next thing is lock 
down the game content need.  

00:26:29.628 --> 00:26:32.858
What we want to say is if the 
tickets node has the currently 

00:26:32.859 --> 00:26:37.806
logged in use are's UID as a k
ey, then allow the read. 

00:26:37.807 --> 00:26:40.828
 We can do that by using a 
parent reference.  So we take 

00:26:40.829 --> 00:26:44.042
data, which, again, is the 
current data at that location.  

00:26:44.043 --> 00:26:47.783
We call it parent.  Then we go 
to the tickets node.  We see if 

00:26:47.784 --> 00:26:52.305
it has the currently logged in 
user as a child.  So the last 

00:26:52.306 --> 00:26:57.245
thing in this example I want to 
talk through is being able to 

00:26:57.246 --> 00:27:01.489
edit the schedule itself.  Here 
we can add an admin's node at 

00:27:01.490 --> 00:27:02.797
the same level as our games node

00:27:02.798 --> 00:27:06.524
in our data structure and we 
will key it again by UID of all 

00:27:06.525 --> 00:27:10.251
of the admins of the app.  You 
can throw a bunch of profile 

00:27:10.252 --> 00:27:12.374
information.  For here I will 
put the name. 

00:27:12.375 --> 00:27:16.109
 So we want to lock down that 
metadata node which determines 

00:27:16.110 --> 00:27:18.137
the schedule so that only admins

00:27:18.313 --> 00:27:20.226
can write to it.  The way we can

00:27:20.227 --> 00:27:23.357
do that is by using this root 
reference.  So we say root, 

00:27:23.563 --> 00:27:25.078
which is going to take us to the

00:27:25.079 --> 00:27:29.604
root of our Firebase.  We go to 
the admins child, and we see if 

00:27:29.605 --> 00:27:34.135
the currently logged in user is 
in that note.  So that works, we

00:27:37.264 --> 00:27:40.591
able to read it read it and the 
people who should able to write 

00:27:40.592 --> 00:27:43.314
it can write it.  We need to 
validate that the write is 

00:27:43.824 --> 00:27:47.038
actually correct because you 
could write wrong data, you k

00:27:47.039 --> 00:27:49.670
now, write a date that is not a 
date at all, but that's not 

00:27:50.166 --> 00:27:51.984
really what we want.  So we copy

00:27:51.985 --> 00:27:55.922
our rules from the previous 
slide.  And then we say let's 

00:27:55.923 --> 00:28:00.748
add rules to date and opponent 
which say the new data must be a

00:28:02.571 --> 00:28:04.886
ere?  We are referencing the 
new data that questioner about 

00:28:04.887 --> 00:28:10.034
to be written.  Whereas data 
talks about data that's 

00:28:10.329 --> 00:28:13.653
currently stored before the 
write, new data will be the data

00:28:16.978 --> 00:28:18.978
opponent, it must be a 

00:28:22.822 --> 00:28:24.637
string.  
This seems like it should work 

00:28:24.638 --> 00:28:28.574
but we run into problems with 
the rules cascade. 

00:28:28.575 --> 00:28:32.993
 So in this example, let's say 
we try and write a number to 

00:28:32.994 --> 00:28:37.635
metadata/date as an 
authenticated admin.  We would 

00:28:37.636 --> 00:28:40.967
first touch the top rule, which 
says are you an admin and it 

00:28:40.968 --> 00:28:44.595
would say yes, I am and at that 
point the date rule would be 

00:28:44.596 --> 00:28:47.715
completely ignored. 
 This is not what we 

00:28:51.437 --> 00:28:53.437
want.  So 
we can look at it the other 

00:28:53.451 --> 00:28:54.657
direction.  Let's say we want to

00:28:54.658 --> 00:28:56.677
write a string but we are not in

00:28:57.681 --> 00:28:59.000
admin.  We first would go to the

00:28:59.001 --> 00:29:04.438
top right rule, go are you an 
admin, no, not an admin thoan we

00:29:05.843 --> 00:29:10.297
says are you writing a strike?  
Yes, I am writing a string and 

00:29:10.298 --> 00:29:13.606
we would allow that to happen 
completely ignoring the admin 

00:29:13.607 --> 00:29:16.640
rule which is not what we want 
because we want to lock down 

00:29:16.641 --> 00:29:19.560
writes to admins.  How can we 
solve this? 

00:29:19.561 --> 00:29:21.374
 All we need to do is change the

00:29:21.375 --> 00:29:24.823
write rules to what we call 
validate rules.  Validate rules 

00:29:24.824 --> 00:29:27.634
are different than read and 
write rules and the way I like 

00:29:27.635 --> 00:29:32.368
to think about it is in order 
for a write to succeed, all you 

00:29:32.369 --> 00:29:36.795
need is one write rule in that 
hierarchy to be true.  So all of

00:29:40.423 --> 00:29:45.060
together if any one is true.  
Whereas with validate rule you 

00:29:45.061 --> 00:29:49.484
need all validate rules to be 
true.  So validate rules are a

00:29:49.485 --> 00:29:53.639
nded together.  So with 
validation you do complex stuff.

00:29:58.858 --> 00:30:03.593
data we are about to write must 
have a date and opponent.  We 

00:30:03.594 --> 00:30:05.594
can also say more complex things

00:30:05.610 --> 00:30:08.939
than just is it a string?  We 
can use regular expressions to 

00:30:08.940 --> 00:30:12.169
verify the date has the proper 
format.  We can use contains 

00:30:12.170 --> 00:30:15.794
queries, which is this is kind 
of an arbitrary example, but we 

00:30:15.795 --> 00:30:19.641
can say the opponent must 
contain an S in their name.  We 

00:30:19.642 --> 00:30:21.341
can say more things like is this

00:30:21.342 --> 00:30:26.077
a bullion or is this a number? 
 One tricky really like is this 

00:30:26.078 --> 00:30:28.391
dollar other field.  This is 
kind 

00:30:32.724 --> 00:30:36.138
of a trick that says dent 
allow other nodes to be written 

00:30:36.139 --> 00:30:39.462
to the feel.  So dollar other 
will match other strings that 

00:30:39.463 --> 00:30:45.806
aren't date opponent and are 
public. 

00:30:45.807 --> 00:30:48.924
 So these are really just a few 
examples of what you can do with

00:30:51.144 --> 00:30:52.870
actually combine them in a bunch

00:30:52.871 --> 00:30:56.699
of ways and do complex schema 
validation including i

00:30:56.700 --> 00:30:59.312
mplementing things like c
ounters, time expiring data and 

00:30:59.313 --> 00:31:03.843
even user rate limiting.  So we 
have seen a bunch of different 

00:31:03.844 --> 00:31:09.799
examples of how to actually do 
security rules, but I'm going to

00:31:11.614 --> 00:31:15.936
one thing to actually key code 
on slide and another to actually

00:31:17.951 --> 00:31:22.391
over here.  And this is the 
brand new Firebase dashboard.  

00:31:22.392 --> 00:31:23.995
How many have played around with

00:31:23.996 --> 00:31:25.996
this 

00:31:27.417 --> 00:31:30.643
thing?  A little over half 
the group.  So it looks more 

00:31:30.644 --> 00:31:32.753
beautiful than the old d
ashboard.  On the left you can 

00:31:32.754 --> 00:31:34.784
see the products that are a part

00:31:34.981 --> 00:31:39.100
of Firebase.  We will be playing

00:31:39.810 --> 00:31:40.919
with database and that's what we

00:31:40.920 --> 00:31:43.345
see right away.  We see the data

00:31:44.145 --> 00:31:46.362
currently stored in our Firebase

00:31:46.768 --> 00:31:50.091
database.  I have already 
prepared some example data, and 

00:31:50.092 --> 00:31:53.712
I will go ahead and load that. 
 It will have the same format as

00:31:55.636 --> 00:31:59.669
placing w so we have a bunch of 
different  admins keyed by UID 

00:31:59.670 --> 00:32:02.296
and include the name of the 
admin and then we have a bunch 

00:32:02.297 --> 00:32:06.626
of games that include game 
content which we lock down to 

00:32:06.627 --> 00:32:10.955
ticketed customers.  We have 
metadata which includes is 

00:32:11.262 --> 00:32:13.779
public field and tickets keyed 
by UID. 

00:32:13.780 --> 00:32:15.780
 So we can actually play with 

00:32:18.923 --> 00:32:21.249
these rules by going to the 
rules simulator.  The first 

00:32:21.435 --> 00:32:24.081
thing we will do is click this 
button here and that's actually 

00:32:24.082 --> 00:32:26.306
going to open up our simulator. 

00:32:26.682 --> 00:32:31.325
So by default, again, our rules 
are you need to be authenticated

00:32:35.969 --> 00:32:40.096
ay, hey, I will read from/games 
even though I'm not 

00:32:40.313 --> 00:32:42.811
authenticated. 
 We will see that the simulated 

00:32:42.812 --> 00:32:46.345
read is denied.  The cool thing 
is you can come in and see which

00:32:51.892 --> 00:32:56.236
So we can go ahead and we can 
work around this.  We can say 

00:32:56.237 --> 00:32:58.752
let's put games.read is going to

00:33:02.259 --> 00:33:08.021
be true.  And we run this again 
and we can see the rules cascade

00:33:09.444 --> 00:33:13.380
allowed but then we will head 
down to the rule on line 6 and 

00:33:13.381 --> 00:33:15.381
see that the read is going to be

00:33:15.663 --> 00:33:18.834
allowed and because read rules 
are orged together, the right 

00:33:18.835 --> 00:33:22.334
overall will be allowed. 
 And then if we look at just 

00:33:22.335 --> 00:33:25.286
reading from the root again, we 
will see that, again, we are not

00:33:27.944 --> 00:33:31.115
So we can go ahead and see this 
a little bit more if we swap the

00:33:34.085 --> 00:33:38.350
put our read rule at the top, 
move this read rule down here 

00:33:38.351 --> 00:33:43.038
within games, and then try and 
read from/games again.  We will 

00:33:43.039 --> 00:33:46.335
see the rules cascade where we 
hit the read rule at the top and

00:33:47.977 --> 00:33:49.069
second read rule because it will

00:33:49.070 --> 00:33:51.149
be allowed and similarly when we

00:33:51.352 --> 00:33:53.117
just read at root, it's going to

00:33:53.118 --> 00:33:56.289
be allowed. 
 So let's go ahead and add the 

00:33:56.290 --> 00:34:01.102
rules that we came up with 
during our slides and copy them 

00:34:01.103 --> 00:34:04.039
here.  This is exactly the full 
set that we talked through, and 

00:34:04.040 --> 00:34:07.541
we have our rules for the 
metadata node, for the game 

00:34:07.978 --> 00:34:10.712
content node and for the ticket 
node.  So we will go ahead and 

00:34:10.713 --> 00:34:13.119
publish these rules which will 
actually upload those to 

00:34:13.666 --> 00:34:16.290
Firebase servers and put them 
live in your app. 

00:34:16.291 --> 00:34:19.681
 And then we are going to try d
oing some writes.  The first 

00:34:19.682 --> 00:34:22.525
thing we will do is we will 
write to games, and then we are 

00:34:22.526 --> 00:34:24.526
going to want to grab one of our

00:34:24.605 --> 00:34:28.760
game IDs and so we will head 
over here and grab the first 

00:34:28.761 --> 00:34:33.246
game ID.  And head back to wry. 

00:34:35.777 --> 00:34:39.918
Games/that game ID/metadata.  We

00:34:40.153 --> 00:34:44.418
will right with just FU.  So we 
click run and we see we are not 

00:34:44.419 --> 00:34:47.466
going to pass because we are not

00:34:47.700 --> 00:34:51.199
authenticated so the auth 
variable is not set.  So let's 

00:34:51.200 --> 00:34:54.028
authenticate.  Here you can see 
the authenticated section where 

00:34:54.029 --> 00:34:58.731
we R we can choose providers we 
can pretend to authenticate w

00:34:58.732 --> 00:35:02.028
ith.  And we can override the U
ID we use in the a

00:35:02.029 --> 00:35:04.763
uthentication.  For now we will 
use the randomly assigned UID 

00:35:04.764 --> 00:35:06.764
and click run and see that, man,

00:35:07.155 --> 00:35:11.889
we still failed the same rule, 
even though we have an auth.UID 

00:35:11.890 --> 00:35:15.359
now, but we are not actually an 
add  

00:35:16.124 --> 00:35:21.061
admin.  We head to the admin 
section, we grab the admin UID 

00:35:21.062 --> 00:35:24.124
and throw it in here and now we 
run and, all right, so we pass 

00:35:24.125 --> 00:35:28.390
the rule on line 8, but now we 
are failing one of our validate 

00:35:28.391 --> 00:35:30.671
rules. 
 It says new data must have date

00:35:33.204 --> 00:35:38.111
that.  We will change this to 
have a date, which will be 

00:35:38.548 --> 00:35:41.610
tomorrow, and we are going to 
intentionally have a mistake in 

00:35:41.611 --> 00:35:44.235
there where we put three 
characters for the year and then

00:35:45.783 --> 00:35:47.751
ahead and say we are going to be

00:35:47.752 --> 00:35:51.580
playing arsenal tomorrow. 
 If we run that, we will see we 

00:35:51.581 --> 00:35:54.425
now pass the first validate r
ule, but that still doesn't 

00:35:54.628 --> 00:35:57.815
allow the write to happen.  We 
failed this regular expression. 

00:36:00.207 --> 00:36:02.832
that 2016, click run, and now we

00:36:03.066 --> 00:36:06.660
see all of the different rules 
succeed and our overall 

00:36:07.098 --> 00:36:10.067
simulated write was allowed.  
You can go to this details 

00:36:10.176 --> 00:36:13.989
section to get a ton more d
etails about why the write 

00:36:14.442 --> 00:36:16.629
allowed.  You can see the type, 
where it was written to, what 

00:36:16.630 --> 00:36:19.676
data, what authentication state 
was, whether or not you were an 

00:36:19.677 --> 00:36:22.537
admin and a bunch of different 
data for each line that was 

00:36:23.615 --> 00:36:25.615
executed in the write.  So if we

00:36:25.709 --> 00:36:28.881
head beaks  back to the  slides 
you have 

00:36:29.959 --> 00:36:34.896
gotten a rolling tour so far of 
both 9 rooms language -- the -- 

00:36:34.897 --> 00:36:38.506
the rules language itself and 
the actual simulator.  If we 

00:36:38.507 --> 00:36:43.757
head back to the slides., h
opefully you guys are not 

00:36:44.289 --> 00:36:48.350
feeling too over Elmed at this 
point and -- overwhelmed and 

00:36:48.351 --> 00:36:50.866
realizing the breadth of 
security, the options you have 

00:36:50.867 --> 00:36:53.695
available to you. 
 I realize that a lot of you I 

00:36:53.696 --> 00:36:56.320
have gone through a bunch of 
stuff already and you may be 

00:36:56.321 --> 00:36:59.383
feeling a bit stressed or you 
may be feeling more scared or 

00:36:59.384 --> 00:37:02.337
you may even possibly be feeling

00:37:02.571 --> 00:37:04.102
like this and be completely lost

00:37:04.103 --> 00:37:08.681
and we realize that.  Security 
is not easy.  There is no 

00:37:08.916 --> 00:37:11.650
getting around that.  Firebase 
has also taken a different 

00:37:11.869 --> 00:37:15.790
approach to security than many 
of you are familiar with.  So in

00:37:17.979 --> 00:37:21.166
rules work consistently -- were 
one of the hardest thicks for 

00:37:21.167 --> 00:37:24.119
new  Firebase developers to 
figure out. 

00:37:24.120 --> 00:37:26.635
 We heard that feedback and we 
are actually playing around with

00:37:28.605 --> 00:37:31.762
creating what we called rules 
compilers.  So first game a 

00:37:32.527 --> 00:37:37.245
compiler calls blaze.  Which 
introduced stuff like types, and

00:37:40.184 --> 00:37:45.669
then came Bolt which built on 
the work of when blaze and 

00:37:46.747 --> 00:37:49.700
included generic types.  It 
included a cleaner syntax to 

00:37:49.701 --> 00:37:54.420
write less code and it also 
included match pads to make 

00:37:54.529 --> 00:37:58.013
rules easier to read and write. 
 But there was still a problem. 

00:37:59.670 --> 00:38:04.248
rules, languages and compilers 
were all database specific.  Now

00:38:06.124 --> 00:38:08.124
real time database.  It's now an

00:38:08.640 --> 00:38:11.702
integrated suite f products.  
That's kind of where the next 

00:38:11.703 --> 00:38:15.625
product comes in.  Firebase 
storage.  We needed a rules 

00:38:15.969 --> 00:38:19.031
language for Firebase storage 
and we felt the existing rules 

00:38:19.032 --> 00:38:21.642
language left too much to be 
desired  

00:38:21.892 --> 00:38:25.376
desired so we went back to the 
drawing board and built a new 

00:38:25.377 --> 00:38:28.658
rules language from the ground 
up, one that borrowed heavily 

00:38:28.659 --> 00:38:31.705
from the real time database 
rules the things we liked and is

00:38:36.081 --> 00:38:39.596
different learnings we got from 
our Blaise and bolt compilers. 

00:38:39.597 --> 00:38:42.315
 &gt;&gt; .  So it's early days for 
the Firebase storage.  There is 

00:38:42.316 --> 00:38:45.394
lots of stuff we still have 
planned and that is still going 

00:38:45.395 --> 00:38:47.800
to be coming out but I quantity 
to give you a walk through of 

00:38:47.801 --> 00:38:50.958
the existing features and show 
you how you can use it to 

00:38:52.161 --> 00:38:55.551
protect your files in Firebase 
storage.  Before we actually 

00:38:55.552 --> 00:39:00.802
look at data, before we look at 
rules, we need to look at data 

00:39:00.803 --> 00:39:04.099
we are protecting.  The real 
time database stores data like 

00:39:04.100 --> 00:39:09.225
this.  We have a users node, we 
have it cued by UID and we have 

00:39:09.226 --> 00:39:12.506
profile information.  This is J
SON data.  Firebase storage on 

00:39:12.507 --> 00:39:15.475
the other hand is going to be 
protecting data like this.  This

00:39:16.773 --> 00:39:20.054
you would have on your local 
file system.  Instead of a u

00:39:20.055 --> 00:39:23.446
ser's node, you  you would have 
a 

00:39:24.446 --> 00:39:26.851
user's directory and you would 
have a directory for each user 

00:39:26.852 --> 00:39:28.852
and for each user you would have

00:39:29.571 --> 00:39:31.571
a bunch of different immannings,

00:39:32.540 --> 00:39:35.930
audio, movies and text files.  
This is the stuff we will want 

00:39:35.931 --> 00:39:38.977
to protect.  So what do the 
rules actually look like.  The 

00:39:38.978 --> 00:39:41.384
syntax will be different from 
the real time database rules, 

00:39:41.385 --> 00:39:47.837
but the concepts are very much 
the same.  So we start with the 

00:39:47.838 --> 00:39:52.541
default storage rules, and the 
default rules say we first are 

00:39:52.542 --> 00:39:57.135
going to specify which service 
we are using to write rules so 

00:39:57.136 --> 00:39:58.885
we are going to say we are using

00:39:58.886 --> 00:40:02.292
the storage, the F
irebase.storage service. 

00:40:02.293 --> 00:40:06.652
 Within that we need to specify 
what bucket.  This is our Google

00:40:08.090 --> 00:40:12.340
reading and writing files to.  
Then we will use match 35Ds.  

00:40:12.341 --> 00:40:18.466
The way to interpret the syntax 
is the curly braces are 

00:40:18.826 --> 00:40:21.872
equivalent to the dollar 
wildcard locations in the real 

00:40:21.873 --> 00:40:23.622
time database rules.  So what we

00:40:23.623 --> 00:40:26.905
are saying here is it we are 
going to match all pads, a 

00:40:27.655 --> 00:40:32.030
wildcard all  strings and the 
equals dollar dollar says allow 

00:40:32.031 --> 00:40:36.421
it to be many levels deep.  If 
you all had all paths with all 

00:40:36.422 --> 00:40:42.421
equals with no dollar dollar it 
will be only one level deep.  

00:40:42.422 --> 00:40:45.812
And   
Within that we will say allow 

00:40:45.813 --> 00:40:49.531
read and write.  We have a more 
compact syntax because we are 

00:40:49.532 --> 00:40:51.626
able to do read and write on the

00:40:51.735 --> 00:40:56.094
same line.  If request.age is 
not null, allow read and write 

00:40:56.095 --> 00:41:00.486
to happen so the rooms are 
equivalent to the real time 

00:41:00.596 --> 00:41:04.190
rules for the dbts there are 
differences in the actual 

00:41:04.424 --> 00:41:09.236
conditional to auth has moved 
from a top level variable into a

00:41:10.550 --> 00:41:12.736
will contain the information 
about the request be willing 

00:41:12.737 --> 00:41:16.784
made, the read or write. 
 So let's look at a few more 

00:41:16.785 --> 00:41:21.159
examples.  Maybe we don't want 
to actually do read, write, only

00:41:22.785 --> 00:41:26.503
if you want to make the stuff 
public.  We can do that by a

00:41:26.504 --> 00:41:29.458
llowing read write with no 
conditional.  More compact 

00:41:29.567 --> 00:41:31.567
syntax than the database rules. 

00:41:31.661 --> 00:41:33.082
Similarly, to do private, we can

00:41:33.083 --> 00:41:35.801
go ahead and just add in 
conditional which says if false 

00:41:35.802 --> 00:41:38.989
which will always allow, which 
will always evaluate to false.  

00:41:38.990 --> 00:41:43.130
So this would not allow anyone 
to read anything.  Finally we 

00:41:43.131 --> 00:41:47.287
can do user-based security.  So 
instead of doing the all paths 

00:41:47.288 --> 00:41:50.599
match, we are going to do a 
match path which looks like t

00:41:50.600 --> 00:41:52.975
his. 
 We are going to say go to the 

00:41:52.976 --> 00:41:56.491
users' directory and then do 
match any string which will be 

00:41:56.492 --> 00:41:59.882
our UID, the unique identifier 
for the stewser and then match 

00:41:59.883 --> 00:42:02.398
all files.  This time we are not

00:42:03.367 --> 00:42:07.429
using equal star star so we are 
not  doing multi-level match 

00:42:07.430 --> 00:42:11.367
paddeds and we will say you are 
allowed to read and write if you

00:42:13.321 --> 00:42:18.916
user.  So we say request.auth.U
ID equals UID.  

00:42:19.572 --> 00:42:23.509
That second UID comes from the 
match pad itself.  So let's head

00:42:25.901 --> 00:42:29.291
talk about storing game 
highlights.  Like we had in the 

00:42:29.292 --> 00:42:31.166
real time database, we will have

00:42:31.167 --> 00:42:34.979
a top level games directory 
instead of a games node.  We 

00:42:34.980 --> 00:42:37.074
will again key that directory by

00:42:37.277 --> 00:42:39.026
the game ID, so the data between

00:42:39.027 --> 00:42:42.870
the two is actually looking 
similar, the structure. 

00:42:42.871 --> 00:42:45.933
 And then within each game, we 
will have a highlight reel, we 

00:42:45.934 --> 00:42:50.183
will have a recording of the 
audio.  And we will have a bunch

00:42:53.247 --> 00:42:57.637
fan images will be keyed by the 
unique identifier of those fans,

00:42:59.154 --> 00:43:02.450
bunch of different images.  So 
we want to go ahead and write 

00:43:02.451 --> 00:43:04.529
rules to protect this data.  The

00:43:04.733 --> 00:43:08.138
first thing we will do is write 
a top level match path which 

00:43:08.139 --> 00:43:13.154
says/games slash game ID.  So 
this is the kind of thing we did

00:43:14.374 --> 00:43:18.952
are doing it much more c
ompactly.  We will nest match 

00:43:18.953 --> 00:43:22.233
pads like we were able to nest 
rules in the database rules and 

00:43:22.234 --> 00:43:26.609
we will say if in game/game ID 
we have a highlighted movie, 

00:43:26.610 --> 00:43:31.437
let's allow everyone to read it 
and let's allow you to write to 

00:43:31.438 --> 00:43:35.906
it if you are authenticated as 
an admin.  Here we are using a 

00:43:35.907 --> 00:43:39.423
new concept, this is using our 
custom authentication.  That 

00:43:39.424 --> 00:43:42.813
auth variable that specifies UID

00:43:42.814 --> 00:43:48.173
in the rules language, you can 
make any variable with net auth 

00:43:48.174 --> 00:43:54.284
variable.  You can say auth.is 
mad min.   

00:43:55.941 --> 00:43:59.549
admin.  And then we store a 
bunch of custom attributes that 

00:43:59.550 --> 00:44:03.034
we want to write.  In this case 
we will store whether or not the

00:44:04.910 --> 00:44:08.738
 Next we need to do rules for 
the recording, audio file, and 

00:44:08.739 --> 00:44:12.676
those rules are going to be 
identical to the  highlights r

00:44:12.677 --> 00:44:16.833
eel.  Finally, we need to 
protect our user's data to 

00:44:17.162 --> 00:44:19.162
within fan images UID file name,

00:44:19.240 --> 00:44:21.240
we will allow all of those to be

00:44:21.631 --> 00:44:25.036
read.  It's a public view, but 
we will only allow you to write 

00:44:25.037 --> 00:44:28.646
it if you are that logged in 
user.  So we can go ahead and 

00:44:28.647 --> 00:44:31.490
clean up some of the rules and 
make these more compact.  The 

00:44:31.491 --> 00:44:33.006
first thing we will do is notice

00:44:33.007 --> 00:44:36.070
that the rules for highlight 

00:44:36.179 --> 00:44:38.147
reel and the recording are 
identical. 

00:44:38.148 --> 00:44:43.616
 Let's get rid of one, slightly 
change our match pad to say just

00:44:45.711 --> 00:44:47.445
update our write rule from which

00:44:47.446 --> 00:44:50.961
currently just checks if we are 
admin to also check that the 

00:44:50.962 --> 00:44:55.774
file name itself is either 
highlights.move or recording.M

00:44:55.775 --> 00:44:58.508
P3.  So we have 
gotten rid of a bunch of lines. 

00:45:01.791 --> 00:45:04.306
extract this read rule from 
these two rules because we know 

00:45:04.307 --> 00:45:07.040
that everything is publicly r
eadable.  So if we pull that 

00:45:07.041 --> 00:45:13.041
out, we go ahead and squish 
those two down and we create a 

00:45:13.042 --> 00:45:15.042
match path for all paths as many

00:45:15.136 --> 00:45:19.933
levels deep as we want and just 
put in allow read.  We have now 

00:45:19.934 --> 00:45:22.792
taken what was initially six 
rules and made it down to three 

00:45:22.793 --> 00:45:24.793
which is much easier to read and

00:45:24.966 --> 00:45:27.294
easier to understand, less to 
keep in your head.

00:45:31.873 --> 00:45:34.716
do with files is validate that 
they are of the correct type and

00:45:35.920 --> 00:45:38.108
that.  So the validation for the

00:45:38.530 --> 00:45:41.373
storage language is quite 
different from what we have in 

00:45:41.374 --> 00:45:43.374
the 

00:45:44.890 --> 00:45:47.186
rules language.  We start 
with our rule which says you 

00:45:47.187 --> 00:45:50.358
need to be logged in user, and 
then we will add a rule which 

00:45:50.359 --> 00:45:52.359
says the size of the resource we

00:45:52.548 --> 00:45:56.799
are about to write has to be 
less than 5 mega bytes.  We can 

00:45:56.800 --> 00:46:01.066
do things like check content 
type and  verify the content 

00:46:01.300 --> 00:46:02.268
type 
of the resource we are writing 

00:46:02.269 --> 00:46:06.315
is an image.  Even more so we 
can actually determine which 

00:46:06.316 --> 00:46:11.034
kind of rights we are  going to 
allow.  We can disable deletes 

00:46:11.035 --> 00:46:13.661
by doing a request resource does

00:46:14.208 --> 00:46:17.160
not equal null.  If you think 
about this.  This is saying if I

00:46:19.114 --> 00:46:22.192
election that is null which m
eans I'm obliterating which is 

00:46:22.193 --> 00:46:24.193
there, then I won't able to 

00:46:37.178 --> 00:46:38.584
do 
that.  One thing I'm excited 

00:46:38.585 --> 00:46:42.428
about is functions.  This is 
something that people love from 

00:46:42.429 --> 00:46:46.350
the Blaise and bolt compilers.  
Let's go ahead and take a subset

00:46:47.679 --> 00:46:50.194
slide and turn them into 
functions.  First we will start 

00:46:50.195 --> 00:46:54.773
with is this the current user.  
We will create a function called

00:46:56.524 --> 00:47:00.789
and we will just return that 
same rule set verifying that the

00:47:02.228 --> 00:47:06.696
the UID the function takes.  If 
that is true, we can go ahead 

00:47:06.697 --> 00:47:09.883
and replace this rule here with 
a much shorter rule which is 

00:47:09.884 --> 00:47:11.884
just is current user and pass 
the 

00:47:21.042 --> 00:47:24.322
UID.  Pass is the size of 
the number of mega bytes we want

00:47:25.964 --> 00:47:30.213
the rule down here with a call 
to less than N mega bytes 5.  

00:47:30.214 --> 00:47:32.620
Finally we can take the rule 
that checks whether or not the 

00:47:32.621 --> 00:47:36.245
file is an image, create a 
function called is image which 

00:47:36.246 --> 00:47:40.386
returns the same exact rule and 
replace the call down here with 

00:47:40.387 --> 00:47:42.684
is image.  So we have taken what

00:47:43.231 --> 00:47:48.481
was a pretty long and hard to 
read write rule and turned into 

00:47:48.482 --> 00:47:50.668
something clear and easy to 
understand even if you don't 

00:47:50.669 --> 00:47:54.075
write the rules yourself, you 
could read and understand who is

00:47:56.373 --> 00:47:58.997
type of files will be written.  
It's short enough you can fit it

00:48:01.077 --> 00:48:02.826
 This is a huge improvement over

00:48:02.827 --> 00:48:04.467
the existing rules language, and

00:48:04.468 --> 00:48:07.404
I think you guys will find that 
it will clean up a lot of your 

00:48:10.702 --> 00:48:13.203
code.  That is the knew Firebase

00:48:14.296 --> 00:48:17.249
store rules language.  It's 
composed with a dozen or so  

00:48:17.250 --> 00:48:19.781
primitived which you can compose

00:48:20.109 --> 00:48:24.046
together to form clesm file 
access rules and validation.  It

00:48:25.891 --> 00:48:28.953
the database rules language i
tself, but also all of the new 

00:48:28.954 --> 00:48:32.891
improvements that we got from 
things like Blaise and bolt.  

00:48:32.892 --> 00:48:36.736
And it is better situated for 
the new multiproduct world that 

00:48:36.737 --> 00:48:40.894
Firebase now occupies. 
 At this point, I think 

00:48:41.316 --> 00:48:44.174
congratulations are in order.  
You just made it through my 

00:48:44.175 --> 00:48:46.018
9:00 a.m. talk on security.  You

00:48:46.019 --> 00:48:49.518
now know the tools you have at 
your exposal to protect your 

00:48:49.519 --> 00:48:55.972
Firebase data in both the real 
time database and in in storage.

00:48:57.833 --> 00:49:00.473
primitives and put them into an 
existing app or if you are new 

00:49:00.474 --> 00:49:04.067
to Firebase a brand new app and 
make sure you are protecting 

00:49:04.068 --> 00:49:06.583
your data.  If you are 
interested in learning more, you

00:49:08.990 --> 00:49:12.286
documentation, head on over to 
Firebase.Google.com. 

00:49:12.287 --> 00:49:15.239
 We have documentation from all 
of the Inc. did products.  You 

00:49:15.240 --> 00:49:18.083
also can find out about all of 
the other parts of Firebase, all

00:49:19.710 --> 00:49:22.787
announced yesterday by heading 
to our features page and lastly,

00:49:25.085 --> 00:49:28.788
has made Firebase successful so 
far and it's something we 

00:49:29.132 --> 00:49:32.194
continue to try and strive and 
do our best at and that's not g

00:49:32.195 --> 00:49:35.694
oing to be exchanging any time 
soon.  So please head over to 

00:49:35.695 --> 00:49:39.195
surf port page, join our 
community, join our Google 

00:49:39.852 --> 00:49:42.461
groups, join our stack overflow 
community and be a part of the 

00:49:42.462 --> 00:49:45.320
conversation.  Let us know what 
features you want, whether it's 

00:49:45.321 --> 00:49:47.289
with the rules language, whether

00:49:47.290 --> 00:49:49.914
it's with the actual database 
rules or storage or any other 

00:49:49.915 --> 00:49:53.524
product.  We definitely value 
your feedback and a lot of what 

00:49:53.525 --> 00:49:56.243
we released yesterday is based 
on feedback from customers like 

00:49:56.244 --> 00:50:00.962
you.  Also brand new You Tube 
channel with a bunch of really 

00:50:00.963 --> 00:50:03.135
cool intro videos for all of the

00:50:03.370 --> 00:50:04.900
new features and you can find us

00:50:04.901 --> 00:50:08.932
on Firebase on Twitter for all 
of the up-to-date news.  There 

00:50:08.933 --> 00:50:13.322
is still a lot of cool stuff 
happening at IO.  We have two 

00:50:13.323 --> 00:50:16.479
full days left.  Half of the 
office hours are over but you 

00:50:16.480 --> 00:50:20.979
should check out the one that's 
at 5:00 p.m. std or one of the 

00:50:20.980 --> 00:50:23.481
ones tomorrow.  If you are 

00:50:24.043 --> 00:50:27.418
interested in seeing Firebase 
sessions there are double digit 

00:50:27.419 --> 00:50:31.574
talks left about Firebase.  Two 
that you may be interested in, 

00:50:31.575 --> 00:50:35.200
one would be zero to app develop

00:50:35.404 --> 00:50:38.576
with Firebase tomorrow at 
10:00 a.m. on the main 

00:50:38.920 --> 00:50:42.309
amphitheater.  This is a really 
cool talk where they will be 

00:50:42.310 --> 00:50:47.122
building an Android and iOS and 
a web app all from scratch that 

00:50:47.123 --> 00:50:49.123
includes storage, database rules

00:50:49.843 --> 00:50:52.357
and authentication, all in 45 
minutes.  So it's going to be 

00:50:52.358 --> 00:50:56.295
exciting.  Whether or not they 
are able to do it, so you should

00:50:58.812 --> 00:51:01.234
 The other talk is the one I 
mentioned about Firebase 

00:51:01.672 --> 00:51:04.718
authentication.  That one is on 
this stage tomorrow at 1:00 p.m.

00:51:07.892 --> 00:51:11.500
come join us right at the sand 
box right next door, and we can 

00:51:11.501 --> 00:51:14.783
take a look at one of your 
existing apps, talk through 

00:51:14.892 --> 00:51:18.188
rules in your app or talk about 
the new features. 

00:51:18.189 --> 00:51:21.454
 Thank you, everybody, for 
coming this morning and learning

00:51:23.987 --> 00:51:30.753
security.  My name is  Jacob 
Wenger you it find more at 

00:51:31.190 --> 00:51:34.815
underscore J Wenger.  Thank you 
very much, peace out!  Do not 

00:51:34.816 --> 00:51:39.956
forgot to protect your Firebase 
data! 

00:51:39.957 --> 00:51:41.957
 (Applause).

00:57:45.912 --> 00:57:45.918
 Services Provided By: 
 Caption First, Inc. 

00:57:45.919 --> 00:57:45.926
 P.O. Box 3066 
 Monument, CO 80132 

00:57:45.927 --> 00:57:45.930
 800-825-5234 
 www.captionfirst.com 

00:57:45.934 --> 00:57:45.943
 This text is being provided in 
a rough draft format. 

00:57:45.944 --> 00:57:45.949
 Communication Access Realtime 
Translation (CART) is provided 

00:57:45.950 --> 00:57:45.952
 in order to facilitate 
communication accessibility and 

00:57:45.953 --> 00:57:45.963
may 
 not be a totally verbatim 

00:57:45.964 --> 00:57:47.964
record of the proceedings. 
             * * * 

01:08:06.179 --> 01:08:07.142
 Coming.  I'm Todd.  I work on 
fire bass cloud message ing.  I 

01:08:07.143 --> 01:08:09.584
focus on performance, specifical
ly reducing battery consumption,

01:08:10.029 --> 01:08:12.298
 improving liability and 
reducing lanty.  With me on 

01:08:12.299 --> 01:08:17.892
stage is Ciaran
&gt;&gt; Today we're here to discuss 

01:08:17.893 --> 01:08:21.069
some of the details of cloud 
message ing performance, clulg 

01:08:21.510 --> 01:08:25.142
      including how we measure 
it, some typical latency numbers

01:08:25.289 --> 01:08:28.011
 we see, some of the factors 
that can affect that performance

01:08:28.312 --> 01:08:31.048
 and finally a few of the cool 
projects we've been working on 

01:08:31.049 --> 01:08:34.838
lately to help make the service 
even more      more robust 

01:08:34.839 --> 01:08:37.237
especially in the face of 
unreliable networks.

01:08:37.310 --> 01:08:39.490
We've had kind of a busy morning
.  I haven't had a chance to 

01:08:39.491 --> 01:08:43.560
talk to you.  I saw yesterday 
that firebase ed cloud 

01:08:43.561 --> 01:08:44.470
message ing is the new Google 
Cloud message        messaging. 

01:08:44.471 --> 01:08:46.871
 Does that mean this whole 
presentation is out of date?

01:08:46.947 --> 01:08:50.674
&gt;&gt; No.  I'm glad you asked.  So 
as you all heard yesterday, we 

01:08:50.675 --> 01:08:56.253
launched a combined suite of 
services called firebase.  

01:08:56.254 --> 01:08:59.293
Firebase cloud message ing is 
the Google Cloud message ing 

01:08:59.294 --> 01:09:03.662
under that suite.  The data that
 we're going to talk about today

01:09:03.971 --> 01:09:10.004
 applies to both services.
Before we get started, I'd like 

01:09:10.005 --> 01:09:13.162
to review a couple basics real 
quick so we're on the same page.

01:09:13.310 --> 01:09:16.804
So first let's look at how adown
 stream message flows from your 

01:09:16.805 --> 01:09:20.715
serve ers to the devices.
So when it flows from your serve

01:09:20.856 --> 01:09:24.190
 ers, the first hop is the    
thefire base ed cloud message 

01:09:24.335 --> 01:09:28.881
ing front end.  From there it's 
time stamped and persisted to 

01:09:28.882 --> 01:09:31.443
storage        storage.  If the 
device is connected, it's sent 

01:09:31.444 --> 01:09:34.311
immediately to the back end 
server where it is then forward

01:09:34.471 --> 01:09:37.644
ed to the device.
So let's take

01:09:41.056 --> 01:09:47.863
 another closer look from back 
end to the device.  It's not a 

01:09:47.864 --> 01:09:51.948
simple arrow      arrow.  The 
first hop is that it leaves the 

01:09:51.949 --> 01:09:54.516
firebase ed cloud message ing 
back end and goes through the 

01:09:54.517 --> 01:09:57.703
Internet towards your wireless 
network or your carrier's 

01:09:57.704 --> 01:10:00.995
infrastructure.  Within that 
point there's going to be a 

01:10:00.996 --> 01:10:07.360
network address trans      
translation device, NAT for 

01:10:07.361 --> 01:10:09.452
short.  That allows us to deal 
with the shortness of IPV4 

01:10:09.453 --> 01:10:12.178
space      space.  This is a 
carrier provide feature or 

01:10:12.179 --> 01:10:15.485
wireless network router provided
 feature.

01:10:15.576 --> 01:10:23.522
And from there -- oh, okay.
From there it travels to the 

01:10:23.523 --> 01:10:25.488
device.
One of the key aspects of this 

01:10:25.489 --> 01:10:28.337
network address translation 
device that keeps track of 

01:10:28.338 --> 01:10:32.570
connections, and let's look more
 closely at how that works.

01:10:32.699 --> 01:10:35.138
So the connection list is a list
 of connections and the external

01:10:36.071 --> 01:10:40.286
 IPN ports along with a timeout.
  When the timeout expires for 

01:10:40.287 --> 01:10:43.313
the connection being inactive, 
the connection's removed and no 

01:10:43.314 --> 01:10:45.571
more communication can happen 
over in that connection.  So the

01:10:46.052 --> 01:10:49.034
 devices must reestablish the 
connection.

01:10:49.112 --> 01:10:52.364
If that NAT device is really 
busy, we can run out of space 

01:10:52.365 --> 01:10:56.464
and we have to evict the least 
recently used enter       entry 

01:10:56.465 --> 01:11:00.667
before it times out.
Most NAT devices are well 

01:11:00.668 --> 01:11:04.750
behaved in that they'll send a T
  TCP reset when they remove an 

01:11:04.751 --> 01:11:08.838
entry from the table and that 
will let devices know to 

01:11:08.839 --> 01:11:12.894
reconnect.  Some devices don't 
send a TCP reset.  That leaves 

01:11:12.895 --> 01:11:16.090
the connection closed but the 
devices are unaware.  We call 

01:11:16.091 --> 01:11:18.091
that a silent

01:11:19.697 --> 01:11:21.985
 close.  In this scenario the 
device must figure a way to 

01:11:21.986 --> 01:11:23.633
figure out it's broken and 
reestablish it

01:11:23.634 --> 01:11:26.136
one solution for this is to send
 heart beats from the connection

01:11:26.735 --> 01:11:29.018
 from the device to our serve 
ers.  We do this to keep the 

01:11:29.019 --> 01:11:33.383
connections active so they don't
 time out and detect more ready 

01:11:33.841 --> 01:11:37.626
ily when the connections fail.
Another an I wanted to review 

01:11:37.627 --> 01:11:43.520
real quick was lanty pert tiles.
  As you all know 50 percentile 

01:11:43.521 --> 01:11:46.048
lanty

01:11:49.842 --> 01:11:53.313
 and 50 percent of users 
experience more latency than 

01:11:53.314 --> 01:11:55.314
this metric.

01:11:58.270 --> 01:12:02.842
There's also the 80 percent 
latency where we have a long 

01:12:02.843 --> 01:12:04.817
tail distribution such as look  
   looking at the performance of

01:12:04.818 --> 01:12:08.572
 carrier wire identify  
             Wifi networks where

01:12:08.720 --> 01:12:11.457
 the performance of individual 
carry      carriers could differ

01:12:11.611 --> 01:12:13.114
 significantly.
In situations where we control 

01:12:13.115 --> 01:12:17.199
more of the infrastructure, such
 as within our own FCMN 

01:12:17.200 --> 01:12:21.242
infrastructure we can look at 95
 percentile latency, which is 19

01:12:21.846 --> 01:12:24.271
 out of 20 users experience ing 
less latency than that.

01:12:24.369 --> 01:12:28.043
So enough review.  Let's start 
with some of the stats.

01:12:28.161 --> 01:12:32.793
We'll start by looking at 
latency first.  This is the same

01:12:32.940 --> 01:12:35.851
 diagram that you've seen before
.  We're going to look at in 

01:12:35.852 --> 01:12:41.221
this next slide latency from the
 FCM path.  So as the message 

01:12:41.222 --> 01:12:45.739
flows through the FCM serve ers 
for both mobile and Wifi.  So 50

01:12:46.196 --> 01:12:50.877
 percentile latency is a small 
64 milliseconds.  Ninety-five 

01:12:50.878 --> 01:12:55.400
percentile latency is 161 
milliseconds.  We chose 95 here 

01:12:55.401 --> 01:12:57.648
because we control the 
infrastructure.  We're able to 

01:12:57.649 --> 01:13:01.742
provide tighter latency bounds.
If we're careful we can estimate

01:13:01.902 --> 01:13:09.585
 the latency.  If we're         
   from the the point the 

01:13:09.586 --> 01:13:12.463
message enters the FCM 
infrastructure to the point 

01:13:12.464 --> 01:13:15.470
delivered to the device.  To do 
this we'll use Google hangouts 

01:13:15.471 --> 01:13:20.868
data and the traveling back from
 the device to estimate the one-

01:13:21.265 --> 01:13:23.265
     one-way latency.

01:13:26.593 --> 01:13:28.525
So 50 percentile latency from 
the front end of FCM to the 

01:13:28.526 --> 01:13:32.024
client is 160 millisecond, which
 is pretty low.  Eighty 

01:13:32.025 --> 01:13:35.945
percentile latency is 348 
milliseconds.  We chose 80 

01:13:35.946 --> 01:13:40.925
percentile here because Wilus 
and mobile networks tend to have

01:13:41.219 --> 01:13:44.723
 a lot of variance and we felt 
80 percentile latency was 

01:13:44.724 --> 01:13:46.203
represent          
representative of well behaved 

01:13:46.204 --> 01:13:50.847
network's performance.
Before I hand off, the data that

01:13:51.149 --> 01:13:53.261
 we've talked about now is for 
connected           connected 

01:13:53.262 --> 01:13:56.134
devices.  Connect        
Connectivity is an important 

01:13:56.135 --> 01:13:58.386
factor and Ciaran is going talk 
about that.

01:13:58.454 --> 01:14:00.976
&gt;&gt; Right.
So to give the audience some 

01:14:00.977 --> 01:14:03.541
context, when the team started 
looking at these numbers        

01:14:03.542 --> 01:14:06.854
numbers, we obviously high fived
 or selves, gave ourselves a pat

01:14:07.097 --> 01:14:08.968
 on the back, et cetera.  These 
are pretty good numbers.  Then 

01:14:08.969 --> 01:14:11.675
we took another look and 
realized like Todd just said 

01:14:11.676 --> 01:14:15.897
that these are only for devices 
that already have an active 

01:14:15.898 --> 01:14:18.477
connection with the FCM serve 
ers.  But there's an entire 

01:14:18.478 --> 01:14:21.826
category of devices that don't 
have an active connection, and 

01:14:21.827 --> 01:14:25.128
so then the next logical 
question we asked ourselves was 

01:14:25.129 --> 01:14:28.440
why?  Why don't these devices 
have an active connection?  And 

01:14:28.441 --> 01:14:31.326
is there anything that we can do
 to make sure that connection 

01:14:31.327 --> 01:14:34.928
stays open longer and is there 
more often?

01:14:35.007 --> 01:14:37.973
So we didn't really know the 
answer to that question.  So we 

01:14:37.974 --> 01:14:40.529
did what we usually do when 
we're face ed with a question we

01:14:40.877 --> 01:14:43.434
 don't know, which is we looked 
at the data.  More specifically 

01:14:43.435 --> 01:14:46.749
we looked at the connection 
close events that we were seeing

01:14:47.026 --> 01:14:50.965
 and we roughly categorize ed 
them into one of two buckets.  

01:14:50.966 --> 01:14:56.699
And the first bucket is user 
initiate ed connection close 

01:14:56.700 --> 01:14:59.854
events.  These are actions that 
the user has taken that has 

01:14:59.855 --> 01:15:03.652
influence ed their connectivity 
in some way.  So some typical 

01:15:03.653 --> 01:15:06.819
examples we see here are if the 
user is worried about their 

01:15:06.820 --> 01:15:09.309
battery or they're not going to 
see a charge er for a while, 

01:15:09.310 --> 01:15:12.471
they might turn off background 
data.  Another example is if the

01:15:12.626 --> 01:15:14.922
 user is going someplace that 
has poor or limited network 

01:15:14.923 --> 01:15:19.918
connectivity.  So that might be 
the park, mountains, my parents'

01:15:20.659 --> 01:15:24.135
 house, hi Dad.  Another example
 that we see is if the user has 

01:15:24.136 --> 01:15:26.720
turned off data by enable ing   
       enabling airplane mode.  

01:15:26.721 --> 01:15:30.190
They can do this for legal 
reasons, like if they're actual

01:15:30.341 --> 01:15:33.221
ly on airplane.  They could also
 do it for financial reasons or 

01:15:33.222 --> 01:15:35.222
just because they want the noise
s to stop.

01:15:35.249 --> 01:15:40.134
That's an entire category of 
user events that can affect 

01:15:40.135 --> 01:15:42.417
somebody's connectivity.  
There's a limit to what we can 

01:15:42.418 --> 01:15:46.246
do about those.  Yonder, there's
 an entire category of external 

01:15:46.247 --> 01:15:48.247
factors that can affect connect
        connectivity.

01:15:48.277 --> 01:15:53.493
Now, the     , you may note this
 category of external factors is

01:15:53.661 --> 01:15:56.530
 technically pretty close to 
infinity, right?  Like there's a

01:15:56.662 --> 01:15:59.848
 whole bunch of things that can 
stop a connection between your 

01:15:59.849 --> 01:16:03.602
client and the FCM serve ers.  
But that's not really a useful 

01:16:03.603 --> 01:16:07.385
paradigm for us.  Instead, we 
decide ed to subdivide it into 

01:16:07.386 --> 01:16:11.626
two sections.  The first is NAT 
device issues.  So as Todd 

01:16:11.627 --> 01:16:16.793
pointed out, NAT means network 
address translation.  That's a 

01:16:16.794 --> 01:16:20.984
device that sits between the FCM
 client, typically an Android 

01:16:20.985 --> 01:16:26.394
device, and a server and doles 
out IPV4 and maintains an 

01:16:26.395 --> 01:16:29.448
internal mapping.  Typically the
 issues we see from that devices

01:16:29.742 --> 01:16:33.471
 are capacity or timeout issues 
there's also another section 

01:16:33.472 --> 01:16:36.332
here which is random failures of
 the.  He's these are evejts 

01:16:36.333 --> 01:16:40.479
that            events that can 
happen anywhere, including power

01:16:40.918 --> 01:16:45.084
 surgeries and               
surgeries.  There are some steps

01:16:45.356 --> 01:16:48.368
 we can take but in general 
we're pretty limited in what we 

01:16:48.369 --> 01:16:52.480
can do here.  We decide ed to 
focus specifically on network 

01:16:52.481 --> 01:16:55.063
address translation issues and 
see what changes we could make 

01:16:55.064 --> 01:16:58.845
to make the experience better 
for more users.

01:16:58.944 --> 01:17:01.427
But first we wanted to see how 
often people were actually 

01:17:01.428 --> 01:17:05.801
affected by NAT issues.  So we 
started to look at the sort of 

01:17:05.802 --> 01:17:08.522
connection close events that 
we're seeing out in the wild for

01:17:08.828 --> 01:17:13.050
 real mobile operators.  One of 
the operators that we looked at 

01:17:13.051 --> 01:17:17.018
had 98.6 percent of their 
connection close events being 

01:17:17.019 --> 01:17:21.197
explicit.  That is, not sile 
lebt           silent.

01:17:21.268 --> 01:17:24.920
Another operator we looked at 
had 99.4 percent of their 

01:17:24.921 --> 01:17:27.645
connection close events being 
explicit.  These are great stats

01:17:27.961 --> 01:17:30.831
 and we're really happy to see 
these because it means that most

01:17:31.574 --> 01:17:34.426
 users, their connections are 
staying open or if they're 

01:17:34.427 --> 01:17:38.207
actually being closed, they're 
being closed explicitly.  So 

01:17:38.208 --> 01:17:40.331
both parties know the connection
 has been closed and they can 

01:17:40.332 --> 01:17:43.859
work to reestablish a new one, 
which means that your connect  

01:17:44.440 --> 01:17:47.778
      connectivity is very high 
and you're very likely to get 

01:17:47.779 --> 01:17:51.107
messages very quickly.
On the other hand, not all 

01:17:51.108 --> 01:17:54.533
operators are performing the  
              performing at the 

01:17:54.534 --> 01:17:56.960
same level.
Here's an example of a small 

01:17:56.961 --> 01:17:59.680
poor performing operator we saw 
that had almost 40 percent of 

01:17:59.681 --> 01:18:02.582
their connection choices being 
silent.  That's a huge 

01:18:02.583 --> 01:18:05.201
difference from the other two 
operators that we saw.  We 

01:18:05.202 --> 01:18:07.768
wanted to kind of dig into what 
was make ing this happen and 

01:18:07.769 --> 01:18:12.110
what we could do about it.  But 
first it may help to go over 

01:18:12.111 --> 01:18:15.787
what exactly a silent connection
 is and why it's so harmful for 

01:18:15.788 --> 01:18:18.306
us.

01:18:21.655 --> 01:18:24.730
So here's an example of an 
explicit close or what we call a

01:18:25.038 --> 01:18:27.786
 polite disconnect.  In this 
scenario the device on the left 

01:18:27.787 --> 01:18:30.467
already has an active connection
 to the FCM serve ers.  When a 

01:18:30.468 --> 01:18:33.809
message is required to be 
delivered to the device, FCM 

01:18:33.810 --> 01:18:37.401
sends the message down, travels 
through the network 

01:18:37.402 --> 01:18:40.205
infrastructure, the NAT device, 
and arrives at the phone in a 

01:18:40.206 --> 01:18:44.377
timely manner.
Then the NAT device decides to 

01:18:44.378 --> 01:18:47.852
close the connection but sends 
out an explicit TCP reset or FIN

01:18:47.991 --> 01:18:50.926
 packet to both parties.  Now 
both parties know that 

01:18:50.927 --> 01:18:54.998
connection has been closed.  
After a short duration, the 

01:18:54.999 --> 01:18:57.725
Android device attempts to 
reestablish that connection.  It

01:18:57.726 --> 01:19:00.251
 does so.  And there's a new 
connection that is used to 

01:19:00.252 --> 01:19:02.800
transfer data between the 
Android device and the FCM serve

01:19:02.946 --> 01:19:08.267
      servers.  Then later, when
 the     serve      servers need

01:19:08.547 --> 01:19:11.560
 to send a new connection, it 
does so on the new connection 

01:19:11.561 --> 01:19:14.411
just like before and the message
 is delivered promptly.

01:19:14.511 --> 01:19:18.970
This is a great scenario because
 again the Android device 

01:19:18.971 --> 01:19:20.971
realizes the

01:19:28.479 --> 01:19:31.296
  Here's an example of one.  
Again, in this scenario the 

01:19:31.297 --> 01:19:35.292
phone already has an active 
connection with the FC   FCM 

01:19:35.293 --> 01:19:38.301
serve ers.  When a message is 
delivered to the device it 

01:19:38.302 --> 01:19:40.413
travels through the network 
infrastructure just like before 

01:19:40.414 --> 01:19:45.487
and arrives at the device.  Then
 when the router or NAT device 

01:19:45.488 --> 01:19:47.974
decides to close the connection,
 it does so silently.  It 

01:19:47.975 --> 01:19:50.947
doesn't send an explicit packet 
to either party.  Now neither 

01:19:50.948 --> 01:19:55.827
party knows that connection has 
been closed.  Later, when FCM 

01:19:55.828 --> 01:19:57.930
wants to send a notification 
down to the phone, it tries to 

01:19:57.931 --> 01:20:01.005
write to that connection, and 
only then does it realize the 

01:20:01.006 --> 01:20:06.087
connection has been closed and 
is unusable.  A short time later

01:20:06.088 --> 01:20:09.996
 the phone will attempt to send 
a heart beat back up to FCM and 

01:20:09.997 --> 01:20:13.894
will attempt to do so on the old
, now dead connection.  When it 

01:20:13.895 --> 01:20:16.364
does that, then it will realize 
that the connection has been 

01:20:16.365 --> 01:20:19.694
closed.  It will reestablish a 
new connection, and FCM will 

01:20:19.695 --> 01:20:24.142
send      send any messages cued
 in the meantime back down to 

01:20:24.143 --> 01:20:26.588
the phone.
The key take away here is that 

01:20:26.589 --> 01:20:31.107
this scenario causes a period of
 dissection that can range  

01:20:35.875 --> 01:20:38.762
 go up to a couple minutes until
 the phone sends a new heart 

01:20:38.763 --> 01:20:41.067
beat     beat.  This isn't a 
great experience for our users 

01:20:41.068 --> 01:20:43.084
because they could be silently 
disconnected with no awareness. 

01:20:43.247 --> 01:20:46.150
 If they receive an urgent 
message, it may not get to them 

01:20:46.151 --> 01:20:48.577
for many minutes.  Obviously 
this isn't a great opportunity

01:20:48.742 --> 01:20:50.437
            opportunity -- or 
this is a great opportunity for 

01:20:50.438 --> 01:20:55.425
us to make some changes and see 
what we can do to fix this.

01:20:55.522 --> 01:20:59.220
So this is kind of a one-     
one-weird trick sort of thing.  

01:20:59.221 --> 01:21:01.423
Here's the same poor performing 
operator.  You've already seen 

01:21:01.424 --> 01:21:05.164
this data.  Before almost 40 
percent of the connection close 

01:21:05.165 --> 01:21:09.872
events were silent.  After make 
ing this small adjustment, 

01:21:09.873 --> 01:21:13.241
almost over 90 percent of the 
connection closed events were 

01:21:13.242 --> 01:21:15.118
explicit.  That's a huge 
reduction in the number of 

01:21:15.119 --> 01:21:18.710
silent closes that we were 
seeing.  So how do we do this?  

01:21:18.711 --> 01:21:22.150
How do we make this happen?  The
 answer is we reduce the heart 

01:21:22.151 --> 01:21:25.119
beat interval to below what we 
thought their NAT timeout 

01:21:25.120 --> 01:21:30.156
interval was.  What that means 
is that when a NAT device 

01:21:30.157 --> 01:21:33.218
typically closes a connection 
due to timeout issues, it's 

01:21:33.219 --> 01:21:35.602
because it think so no data is 
going to be passed on that 

01:21:35.603 --> 01:21:37.953
connection anymore.  An FCM 
connection, on the other hand, 

01:21:37.954 --> 01:21:41.363
is always active.  We're always 
expecting to receive data on 

01:21:41.364 --> 01:21:44.686
that.  That's how you receive 
your messages so quickly.

01:21:44.784 --> 01:21:48.842
So the trick here was to make 
sure we were sending packets 

01:21:48.843 --> 01:21:50.909
frequently enough that the NAT 
device realized that the 

01:21:50.910 --> 01:21:55.015
connection was still open and 
that it shouldn't close it.

01:21:55.096 --> 01:21:58.067
So here's that same data in a 
different form.  As you can see,

01:21:58.243 --> 01:22:03.242
 for the first three-quarters of
 the graph, the silent closes 

01:22:03.243 --> 01:22:06.765
over time harbor pretty steadily
 between 1.5 million and just 

01:22:06.766 --> 01:22:10.056
over 2 million.  On the other 
hand, when we initiate ed the 

01:22:10.057 --> 01:22:12.959
heart beat interval -- or when 
we adjusted the heart beat 

01:22:12.960 --> 01:22:15.850
interval, that blue dotted line 
you see, you see the number of 

01:22:15.851 --> 01:22:20.309
silent closes dropped dramatic 
cally.  In fact, they dropped 88

01:22:20.310 --> 01:22:25.782
 percent down to just around 
250,000.  That's a huge, huge 

01:22:25.783 --> 01:22:29.700
improvement, and we're very 
happy we got to make that.

01:22:29.797 --> 01:22:33.175
Now, this approach of take     
taking the whole team and look  

01:22:33.507 --> 01:22:36.538
   looking at mobile operator 
data and coming up with a plan 

01:22:36.539 --> 01:22:40.277
and implementing that plan is 
great for mobile operators, 

01:22:40.278 --> 01:22:42.950
especially large er ones where 
the amount of impact that we can

01:22:43.206 --> 01:22:47.264
 have is dramatic for just that 
small amount of work.  On the 

01:22:47.265 --> 01:22:50.054
other hand, that approach 
doesn't really scale well with

01:22:53.060 --> 01:22:54.337
 Wifi networks.  It's not like I
 can go in and record each 

01:22:54.338 --> 01:22:56.283
network and whether or not it's 
a good quality one.  So we had 

01:22:56.284 --> 01:22:59.293
to come up with a different 
solution, and Todd, I know you 

01:22:59.294 --> 01:23:02.555
have a lot of practice here.  
Can you give us an example of 

01:23:02.556 --> 01:23:06.241
what we did to make that better?
&gt;&gt; Yeah.

01:23:06.328 --> 01:23:09.932
Wifi adaptive heart beat was a 
really excite ing project for me

01:23:10.091 --> 01:23:12.538
 to work on.  We started out 
with a constant heart beat 

01:23:12.539 --> 01:23:16.336
interval of 15 minutes, and it 
was great for most operators -- 

01:23:16.337 --> 01:23:19.203
or for most Wifi networks.  But 
there were a few that would be 

01:23:19.204 --> 01:23:21.938
disconnected because they had 
shorter NAT timeouts than that 

01:23:21.939 --> 01:23:24.619
or more active devices.  A 
simple solution could be to just

01:23:24.807 --> 01:23:28.040
 reduce the static heart beat to
 four minutes, but we might 

01:23:28.041 --> 01:23:30.479
consume a little bit more 
battery as a result.  What we 

01:23:30.480 --> 01:23:33.619
really wanted was something to 
develop an algorithm that would 

01:23:33.620 --> 01:23:37.449
balance battery consumption with
 connectivity.  We brainstormed 

01:23:37.450 --> 01:23:41.394
for a bit and came up with 
candidates.  We took those 

01:23:41.395 --> 01:23:45.601
candidate algorithms and 
simulate ed them against mottled

01:23:46.046 --> 01:23:49.354
 NAT devices.  Here's an 
example.  The modeled device 

01:23:49.355 --> 01:23:52.453
varies its timeout in the yellow
 line.  The red line shows the 

01:23:52.454 --> 01:23:55.910
heart beats as they adjust in 
interval to match that and as to

01:23:56.332 --> 01:23:58.332
 Wifi adapt  

01:24:08.800 --> 01:24:09.258
    adaptive heart beat.
This simulation here shows the 

01:24:09.259 --> 01:24:09.611
device was connected over 97 
percent of the time.  In 

01:24:09.612 --> 01:24:09.757
comparison if this same 
simulation was run with a static

01:24:09.758 --> 01:24:10.018
 heart beat of 15 memberships, 
the device would only have been 

01:24:10.019 --> 01:24:11.137
connected 66 percent of the 
time     time.  After we refined

01:24:11.138 --> 01:24:13.797
         refined our algorithm 
and came up with what we thought

01:24:13.798 --> 01:24:17.829
 was a good solution, we took it
 to the lab.  There we had four 

01:24:17.830 --> 01:24:20.414
nexus six devices.  We divide ed
 them into two groups, control 

01:24:20.415 --> 01:24:23.312
group and experiment group.  The
 control group kept the 15 

01:24:23.313 --> 01:24:26.047
minute static heart beat and the
 experiment group got our new 

01:24:26.048 --> 01:24:29.465
Wifi adaptive heart beat 
algorithm.  We connected them to

01:24:29.778 --> 01:24:32.187
 monsoon power meter so we could
 measure the current power 

01:24:32.188 --> 01:24:34.451
consumption of all devices and a
 Wifi network that we controlled

01:24:34.643 --> 01:24:37.873
.  This allowed us to emulate 
the various NAT behaviors we had

01:24:37.874 --> 01:24:42.869
 experience ed.
We also took a T sweep to make 

01:24:42.870 --> 01:24:44.345
sure it was operating as 
expected.

01:24:44.346 --> 01:24:47.057
From this lab experiment we came
 up with some interesting 

01:24:47.058 --> 01:24:50.273
numbers.  First we could compare
 the cost of doing a heart beat 

01:24:50.274 --> 01:24:54.017
versus the cost of doing a 
reconnect.  We found that a 

01:24:54.018 --> 01:25:00.507
heart beat saved 36 percent 
better.  Or sorry, a heart beat 

01:25:00.508 --> 01:25:02.160
consumed 36 percent let's 
\lest\Less\let's battery than a 

01:25:02.161 --> 01:25:05.607
reconnect.
Scenario.

01:25:05.707 --> 01:25:08.453
In addition if we look at a ten 
minute NAT timeout device, 

01:25:08.454 --> 01:25:11.389
that's one we've talked about 
before, in the experiment group 

01:25:11.390 --> 01:25:14.510
it would simply have 29-minute 
heart beats.  In the control 

01:25:14.511 --> 01:25:18.411
group it would have a 15 minute 
heart       heart beat followed 

01:25:18.412 --> 01:25:22.819
bay reconnect.  The experiment 
group would achieve the 97 

01:25:22.820 --> 01:25:27.986
percent we   we's sympathy 
lately ied and control group 

01:25:27.987 --> 01:25:33.855
only 67 group.  By increasing 
the heart beat interval in 

01:25:33.856 --> 01:25:37.385
certain situations we're actual
ly able to save battery in 

01:25:37.386 --> 01:25:38.698
addition to improving connect
ivity.

01:25:38.699 --> 01:25:41.497
We started rolling this feature 
out and along the way we collect

01:25:41.681 --> 01:25:43.768
ed data.  I'd love to share with
 you some of the data we got 

01:25:43.769 --> 01:25:49.316
when we got to the 50 percent of
 production users.

01:25:49.477 --> 01:25:57.383
First, we saw 34 percent fewer 
silent closes, and more TT   TTO

01:25:57.384 --> 01:26:02.615
 messages delivered.  If you 
remember the GCM spec, time to 

01:26:02.616 --> 01:26:04.743
live messages are messages that 
are delivered immediately if the

01:26:05.016 --> 01:26:08.092
 device is online.  Otherwise 
they're discarded because they 

01:26:08.093 --> 01:26:10.537
aren't stored to be delivered 
later.  They're time delivered 

01:26:10.538 --> 01:26:12.783
zero.  By delivering more of 
those messages that shows we're 

01:26:12.784 --> 01:26:18.453
connected more of the time.
In addition, we improve battery 

01:26:18.454 --> 01:26:21.936
for 54 percent of users.
&gt;&gt; Whoa, whoa, whoa.  We 

01:26:21.937 --> 01:26:26.174
improved battery for 54 percent 
of users?  That's huge.

01:26:26.234 --> 01:26:28.975
&gt;&gt; Yeah, 54 percent.
[ APPLAUSE ]

01:26:29.052 --> 01:26:35.056
&gt;&gt; Wow.
&gt;&gt; And there's a small caveat to

01:26:37.292 --> 01:26:37.886
 that.  For a very small portion
 of users, users only connected

01:26:37.887 --> 01:26:40.209
           connected 33 percent 
of the time or less, we did 

01:26:40.210 --> 01:26:43.396
spend a little bit of battery.  
.3 percent more battery consumed

01:26:44.149 --> 01:26:53.567
 for an \idle\idol device.  For 
that small subset of users 

01:26:53.568 --> 01:26:56.626
improved three times.  I feel 
like the battery numbers paid 

01:26:56.627 --> 01:27:00.003
out.  We improved connectivity 
for 72 percent of users.

01:27:00.086 --> 01:27:03.072
So as a result this feature is 
live.  Everybody's phone should 

01:27:03.073 --> 01:27:06.452
have it.  And we're continuing 
to think about how to improve it

01:27:06.608 --> 01:27:09.730
 further.
In addition to looking at our 

01:27:09.731 --> 01:27:11.999
own data, we also felt it was 
important to look at data from 

01:27:12.000 --> 01:27:16.079
services that depend on us.  I'd
 like to look at Google hang    

01:27:16.080 --> 01:27:22.018
 hangouts 99 percentile latency 
data.  The blue line represents 

01:27:22.019 --> 01:27:27.386
Wifi and mobile users combined. 
 So it's both sets of users in 

01:27:27.387 --> 01:27:31.835
one line.  And the Wifi line is 
red.  It's just the Wifi users

01:27:37.413 --> 01:27:41.679
.  What we can see here is that 
at the 50 percent rollout point,

01:27:37.413 --> 01:27:39.966
 the niernt percentile latency 
for Wifi users dropped.

01:27:40.160 --> 01:27:43.532
When we got to a hundred percent
 rollout, the users continued to

01:27:43.700 --> 01:27:46.828
 drop but also 99 percentile 
users dropped.  That means we've

01:27:47.564 --> 01:27:51.457
 changed what problem is causing
 the 99 percentile latency for 

01:27:51.458 --> 01:27:58.861
Wifi plus mobile users.  In the 
end, the remaining latency for 

01:27:58.862 --> 01:28:02.730
the blue line was caused by 3G 
mobile networks, when which we 

01:28:02.731 --> 01:28:05.398
focused on later.  That's a talk
 for another time.  If you look 

01:28:05.399 --> 01:28:09.128
just at the Wifi line, we 
reduced the 99 percentile 

01:28:09.129 --> 01:28:13.689
latency for hang     hangouts 55
 percent.

01:28:13.897 --> 01:28:17.480
So we've gone through and looked
 at how GCM performs and some 

01:28:17.481 --> 01:28:19.834
interesting projects we really 
enjoyed working on.  I want to 

01:28:19.835 --> 01:28:22.582
take a brief second to talk 
about what can we learn about 

01:28:22.583 --> 01:28:27.337
the users of GCM from the data 
that we have.  So we're going to

01:28:27.468 --> 01:28:29.553
 look at user influence ed 
\dissection\disconnection 

01:28:29.554 --> 01:28:32.419
events       events.  So events 
where the users decide       

01:28:32.420 --> 01:28:34.960
decided to be disconnected for a
 sustained period of time.  

01:28:34.961 --> 01:28:37.741
We're going to look at events 
where the user's been disconnect

01:28:37.893 --> 01:28:40.272
ed for 30 minutes or more where 
they have made the decision not 

01:28:40.273 --> 01:28:45.021
to be reconnected.
This is a heat map that I'm 

01:28:45.022 --> 01:28:48.363
going to talk about.  One thing 
I wanted to point out before I 

01:28:48.364 --> 01:28:50.955
started that though was most 
messages are delivered in well 

01:28:50.956 --> 01:28:53.123
under 30 minutes.  We're only 
talking about the long tail here

01:28:53.269 --> 01:28:55.547
     here.  We're only talking 
about messages delivered longer 

01:28:55.548 --> 01:28:59.781
than 30 minutes.  Or to devices 
that have been offline for more 

01:28:59.782 --> 01:29:02.804
than 30 minutes.  This heat map 
is color code ed.  Red means a 

01:29:02.805 --> 01:29:05.410
higher percentage of messages 
are delivered to devices that 

01:29:05.411 --> 01:29:08.604
have been offline and green 
represents a lower percentage of

01:29:08.605 --> 01:29:12.156
 messages.  We will post on the 
spaces app the full set of data 

01:29:12.157 --> 01:29:15.466
for this grade so you can check 
it out online.

01:29:15.554 --> 01:29:19.973
So, for example, 4 percent of 
Indian users are seeing their 

01:29:19.974 --> 01:29:23.390
messages delivered to devices 
that have been offline between 

01:29:23.391 --> 01:29:26.954
two and four hours.  In the U.S.
 that's only .8 percent.  As you

01:29:27.132 --> 01:29:30.578
 can see this varies from 
country to country significantly

01:29:31.231 --> 01:29:33.863
.  Let's take another look at 
this data in a slightly 

01:29:33.864 --> 01:29:37.902
different representation.  This 
is a cumulative graph.  You can 

01:29:37.903 --> 01:29:41.416
see 15 percent of users in India
 -- or 15 percent of messages in

01:29:41.554 --> 01:29:45.948
 India are delivered to devices 
that have been offline two hours

01:29:45.949 --> 01:29:48.844
 or more.  That means that if 
you're developing an app for the

01:29:49.151 --> 01:29:52.860
 world, you need to take into 
account the device connectivity 

01:29:52.861 --> 01:29:57.921
may not be a iewbt qus thing.  
You have to make the app work 

01:29:57.922 --> 01:30:02.491
where connectivity may go away.
One other dataset I thought we 

01:30:02.492 --> 01:30:05.210
could pull is to look at day of 
the week.  This is the global 

01:30:05.211 --> 01:30:08.099
data.  It's not any particular 
country, but you can clearly see

01:30:08.258 --> 01:30:10.784
 that Saturday and Sunday are 
days in which the users are less

01:30:10.959 --> 01:30:14.775
 likely to be available on their
 devices.  Maybe they work on 

01:30:14.776 --> 01:30:19.127
the weekdays or maybe they have 
phone free Saturday Sundays.

01:30:19.322 --> 01:30:21.605
Karen, what are some things we 
can do                        

01:30:21.809 --> 01:30:25.153
             Ciaran, what are 
some things we can do where 

01:30:25.154 --> 01:30:27.658
connect        connectivity is 
not prevalent.

01:30:27.719 --> 01:30:29.929
&gt;&gt; I'm glad you asked that 
question and totally surprised 

01:30:29.930 --> 01:30:34.464
by it.  No, I'm joke ing. just 
released a new open source 

01:30:34.465 --> 01:30:37.354
library.  It's called the 
firebase job dispatch          

01:30:37.355 --> 01:30:40.493
dispatcher.  This is a library 
for schedule ing jobs     jobs, 

01:30:40.494 --> 01:30:43.612
discrete units of work on 
Android and coming soon IOS that

01:30:43.946 --> 01:30:47.140
 let you set constraints and 
triggers for these jobs.  You 

01:30:47.141 --> 01:30:50.453
can say something like I'd like 
to do this download but only 

01:30:50.454 --> 01:30:53.748
when the user has an unmetered 
Wifi network.  Or I'd like to 

01:30:53.749 --> 01:30:57.005
run this task every week but 
only while the device is charge 

01:30:57.631 --> 01:31:01.050
      charging.  This helps make
 sure that your app remains a 

01:31:01.051 --> 01:31:04.403
good app citizen on both IOS and
 Android and ultimately it means

01:31:05.062 --> 01:31:07.776
 that you're respecting your 
user by make ing sure you're 

01:31:07.777 --> 01:31:10.239
only using the bandwidth when 
you absolutely need to and 

01:31:10.240 --> 01:31:14.025
you're waiting for the most 
opportune time to initiate 

01:31:14.026 --> 01:31:17.039
download or maintenance tasks 
you need.

01:31:17.129 --> 01:31:19.810
This is available right now and 
you can check out those links 

01:31:19.811 --> 01:31:22.420
there.  The IOS version is 
absolutely coming soon.

01:31:22.508 --> 01:31:26.299
We also have a Codelab for you 
called removing againy ies on 

01:31:26.300 --> 01:31:30.683
background services.  That's 
available at the link there.

01:31:31.132 --> 01:31:34.559
We encourage you to check it out
.  In there we go over a sample 

01:31:34.560 --> 01:31:37.349
app and talk about removing 
dependency ies on background 

01:31:37.350 --> 01:31:41.502
services and converting to this 
new job centric world.

01:31:41.614 --> 01:31:44.792
This is a great way to make sure
 your app is more battery 

01:31:44.793 --> 01:31:47.955
efficient and works even better 
on newer versions of Android and

01:31:48.410 --> 01:31:53.509
 IOS.
So this has been us, we've been 

01:31:53.510 --> 01:31:56.541
talking about GCM performance.  
We'd love to hear your comments 

01:31:56.542 --> 01:31:59.876
and feedback.  Please leave us a
 note in the spaces app and I 

01:31:59.877 --> 01:32:02.273
guess we have some time for Q&amp;A 
right now.

01:32:02.353 --> 01:32:04.887
&gt;&gt; Yeah, we have time for 
questions if you want and then 

01:32:04.888 --> 01:32:08.583
go ahead.  Find a mic, please.
[ APPLAUSE ]

01:32:08.666 --> 01:32:15.542
&gt;&gt; I guess they're allowed to 
clap.

01:32:15.634 --> 01:32:19.211
&gt;&gt; Hi.  I am from Verizon 
Wireless.

01:32:19.278 --> 01:32:22.336
I have a question.  So the 
presentation so far you have 

01:32:22.337 --> 01:32:26.145
shown is mainly the improvement 
on like Wifi network, like the 

01:32:26.146 --> 01:32:33.316
NAT, right?  But on the cellular
 network, your heart beat is to 

01:32:33.317 --> 01:32:35.782
be 28 minutes, right?  So did 
you change that or it still 

01:32:35.783 --> 01:32:38.857
remains the same?
&gt;&gt; So I guess you'd probably be 

01:32:38.858 --> 01:32:42.424
a better --
&gt;&gt; So what we do is we look at 

01:32:42.425 --> 01:32:46.438
the performance of carry iers 
and we try to say well how this 

01:32:46.439 --> 01:32:48.813
carrier doing.  One of the 
things we may do is if that 

01:32:48.814 --> 01:32:52.279
carrier is performing poorly we 
may try a couple heart beats and

01:32:52.280 --> 01:32:54.908
 see how they do and reach out 
to the carrier and contact them.

01:32:55.111 --> 01:32:57.542
  In some cases we can even 
extend the heart beat interval 

01:32:57.543 --> 01:33:00.243
to 60 minutes, which is really 
awesome        awesome.

01:33:00.315 --> 01:33:06.423
&gt;&gt; So you base ically take a 
look on the carrier and it's not

01:33:06.736 --> 01:33:11.870
 fixed number; it's dinely    
    dynamically changed.

01:33:12.099 --> 01:33:14.346
&gt;&gt; The number is based on the 
operator based on the 

01:33:14.347 --> 01:33:15.990
experiences and performances  
            performances we see 

01:33:15.991 --> 01:33:19.470
on that operator.  Operators 
that have short NAT timeouts  

01:33:19.989 --> 01:33:21.756
        timeouts we'll adjust 
that heart beat interval to 

01:33:21.757 --> 01:33:25.833
match that.  If they have a long
 timeout, like Todd was saying 

01:33:25.834 --> 01:33:30.087
some have almost 60 minute time
outs, we'll extend that heart 

01:33:30.088 --> 01:33:32.162
beat as much as possible because
 we know how much the battery 

01:33:32.163 --> 01:33:34.778
savings matter to our users.
&gt;&gt; This is something we try to 

01:33:34.779 --> 01:33:38.260
work with carry iers as well.  
So when we make changes like 

01:33:38.261 --> 01:33:40.214
this we'll reach out to the 
carry iers and coordinate with 

01:33:40.215 --> 01:33:45.727
them as best we can.
&gt;&gt; So is GCM becomes firebase ed

01:33:45.728 --> 01:33:49.307
 something, you guys change the 
name?  What is the new name?

01:33:49.393 --> 01:33:53.599
&gt;&gt; So GCM which was Google Cloud
 message ing is now firebase ed 

01:33:53.600 --> 01:33:56.164
message ing, or FCM.
&gt;&gt; Thank you very much.

01:34:00.255 --> 01:34:06.895
&gt;&gt; Hi.  I notice you guys update
 the end point from -- so the 

01:34:06.896 --> 01:34:13.319
boast GCM, FCM end points are 
available.  In order to take 

01:34:13.320 --> 01:34:16.551
advantage of the work you guys 
are doing, do we need to switch 

01:34:16.552 --> 01:34:22.285
the end point from GCM to FCM?
&gt;&gt; Our infrastructure 

01:34:22.286 --> 01:34:24.963
improvements are going to affect
 both APIs.

01:34:25.051 --> 01:34:27.681
&gt;&gt; You shouldn't have to make 
any changes to your app.  

01:34:27.682 --> 01:34:29.682
Everyone gets this built in.

01:34:31.769 --> 01:34:35.933
&gt;&gt; Okay.  Thank you.
I mean my server by my app.

01:34:36.021 --> 01:34:38.021
&gt;&gt; Yeah.
&gt;&gt; Okay.  Thank you all for your

01:34:38.145 --> 01:34:42.377
 time.  We're going to hang out 
over by the fire bass booth if 

01:34:42.378 --> 01:34:44.052
you have individual questions 
after we get untangled from 

01:34:44.053 --> 01:34:45.620
these speakers.  Have a good day
    day.

01:34:45.621 --> 01:34:48.065
[ APPLAUSE ]

02:11:48.843 --> 02:11:51.551
The Firebase plug-in which I 
guess is more correctly called 

02:11:51.552 --> 02:11:54.544
the play services plug-in for 
Android, you might be curious 

02:11:54.545 --> 02:11:57.265
what happens with that plug-in. 
 Well, I'll tell you a little 

02:11:57.266 --> 02:12:00.293
bit about what happens.  Three 
things.  One, it will read a 

02:12:00.294 --> 02:12:03.613
configuration from your Google 
services.  So Firebase is just 

02:12:03.614 --> 02:12:08.014
like Play services was where you
 go to a console, you get a J 

02:12:08.015 --> 02:12:10.880
sun file, drop it into your app.
  This contains configuration 

02:12:10.881 --> 02:12:15.101
your app will use in order to 
operate correctly p the      .

02:12:15.162 --> 02:12:20.263
It will inject Maven 
dependencies.  This is actually 

02:12:20.264 --> 02:12:24.631
groovy code, not java code.  
You'll notice the lack of a 

02:12:24.632 --> 02:12:27.356
semicolon and single quotes 
around some of the strings.  

02:12:27.357 --> 02:12:29.923
What we're doing here is the 
plug-in will reach into your 

02:12:29.924 --> 02:12:32.801
project, look into its 
dependencies collection and add 

02:12:32.802 --> 02:12:36.114
a compiled dependency on 
Firebase core.  Now, this 

02:12:36.115 --> 02:12:38.377
Firebase core module is kind of 
interesting because it contains 

02:12:38.378 --> 02:12:41.517
no code.  Now, why would we add 
a dependency on something that 

02:12:41.518 --> 02:12:45.129
contains no code, !  That seems 
kind of weird, until you look 

02:12:45.130 --> 02:12:50.291
inside the maven palm file for 
this.  Palm file is just sort of

02:12:50.564 --> 02:12:53.588
 metadata about how a dependency
 looks.

02:12:53.689 --> 02:12:55.578
You'll look in the highlighted 
section here you can see that 

02:12:55.579 --> 02:12:59.071
the Firebase core module depends
 on Firebase analytics.  So when

02:12:59.991 --> 02:13:03.839
 you apply the Google services 
plug-in to your Firebase app, 

02:13:03.840 --> 02:13:06.380
you will get analytics for free.
  It's kind of important to note

02:13:06.657 --> 02:13:09.864
, this is how important we think
 that analytics is for your app.

02:13:10.021 --> 02:13:12.321
  You get it always.  It's a 
crucial part of Firebase 

02:13:12.322 --> 02:13:15.507
applications, and you'll see 
that throughout this conference 

02:13:15.508 --> 02:13:18.776
how Firebase analytics actually 
enhances the cape ability ies of

02:13:19.086 --> 02:13:22.871
 the other components that you 
use in why you are app.

02:13:22.938 --> 02:13:26.532
The third thing that the plug-in
 will do is inject some 

02:13:26.533 --> 02:13:31.193
resources.  You can see in this 
bit of code we're reaching into 

02:13:31.194 --> 02:13:33.624
your project, into the Android 
configuration, and for each of 

02:13:33.625 --> 02:13:36.228
the variance that you're 
building, what we'll do is find 

02:13:36.229 --> 02:13:39.437
a unique location for that 
variant that's your file output 

02:13:39.438 --> 02:13:43.240
directory.  Then we'll create a 
task.  This task, what it does 

02:13:43.241 --> 02:13:46.543
is it will generate resources 
when it's called.  On that 

02:13:46.544 --> 02:13:49.570
variant we can register a 
resource generating task, pass 

02:13:49.571 --> 02:13:53.345
that task that will actually do 
the work and feed it the output 

02:13:53.346 --> 02:13:56.078
directly.
What happens is this is an API 

02:13:56.079 --> 02:14:01.743
within the gradeall plug     
plug-in when it's called you can

02:14:01.744 --> 02:14:04.688
 say if this plug-in wants to 
generate some resources this is 

02:14:04.689 --> 02:14:09.373
an output directory that the 
rest of the build will use to 

02:14:09.374 --> 02:14:14.370
look for those resources.  It 
drops fully formed valid Android

02:14:14.822 --> 02:14:18.153
 resource files, XML files that 
will be merge ed into the build.

02:14:18.446 --> 02:14:22.697
  So what all this task is doing
 is it's reading out of those JS

02:14:23.018 --> 02:14:25.887
ON file all of those values and 
keys and configuration and 

02:14:25.888 --> 02:14:28.295
storing them as resources.  
That's how your app actually 

02:14:28.296 --> 02:14:30.847
gets ahold of all the different 
things it needs to operate 

02:14:30.848 --> 02:14:33.587
properly.
So if you're developing with 

02:14:33.588 --> 02:14:38.577
Firebase, you'll likely come 
across this new task API.  This 

02:14:38.578 --> 02:14:44.933
is how a Play service is doing 
concurrence y within the app.  

02:14:44.934 --> 02:14:47.795
This is like the API pretty much
 all products will be using 

02:14:47.796 --> 02:14:50.211
going forward.
This is created just for 

02:14:50.212 --> 02:14:53.858
Firebase APIs.  However, this 
could be applied to any sort of 

02:14:53.859 --> 02:14:57.009
play services API in the future.
  Now, for Firebase specifically

02:14:57.177 --> 02:15:00.954
 if you're using remote config, 
authentication, or file storage,

02:15:01.083 --> 02:15:04.565
 you will run across this task 
API.  It's an important thing to

02:15:04.727 --> 02:15:10.981
 know.
So the general form of the A 

02:15:10.982 --> 02:15:14.753
sync API, we'll call it Firebase
 ed thing and say you call a 

02:15:14.754 --> 02:15:17.824
method on that do stuff.  This 
do stuff method, if it wants to 

02:15:17.825 --> 02:15:19.919
do things asynchronous          
   asynchronously, it will 

02:15:19.920 --> 02:15:22.952
return immediately and generate 
a task object.  This task object

02:15:23.144 --> 02:15:26.927
 is parameterize ed by some 
result, whatever it wants to 

02:15:26.928 --> 02:15:30.091
generate.  We have a task that 
wants to return some result.  On

02:15:30.092 --> 02:15:33.553
 that task it's a representation
 of background work.  On that 

02:15:33.554 --> 02:15:37.665
task you can register listeners.
  You could have a success 

02:15:37.666 --> 02:15:38.696
listener and then there's a call
 back in there that will receive

02:15:38.697 --> 02:15:41.868
 the result type when it's been 
generate ed.  You can register a

02:15:42.040 --> 02:15:44.496
 failure listener which then 
receives an exception of 

02:15:44.497 --> 02:15:48.490
whatever happened that caused 
the task to fail.  So that right

02:15:48.774 --> 02:15:52.504
 there is all you actually need 
to handle these things correctly

02:15:52.830 --> 02:15:55.261
.
Now, there's a third version 

02:15:55.262 --> 02:15:57.701
where you can register an on 
complete listener.  What this 

02:15:57.702 --> 02:16:01.286
does is bundles both success and
 failure up into a single call 

02:16:01.287 --> 02:16:04.202
back.  If you choose to use a 
noncomplete listener, what you 

02:16:04.203 --> 02:16:07.103
do is you get a task and you can
 ask that task, did you complete

02:16:07.104 --> 02:16:11.864
 successfully?  If you did, give
 me your result.  If you did not

02:16:11.865 --> 02:16:14.710
 complete, then give me the 
exception.  You can choose.  You

02:16:14.711 --> 02:16:17.693
 can register either success or 
failure separate or independent

02:16:17.908 --> 02:16:20.499
ly or do a completion listener 
and handle both in the same 

02:16:20.500 --> 02:16:23.189
callback.
So there's four ways to get task

02:16:23.503 --> 02:16:26.116
 results.  I've showed you the 
general format, but there's four

02:16:26.348 --> 02:16:28.587
 different ways, and you should 
know each one of them.

02:16:28.736 --> 02:16:30.959
First of all, there's a call 
back on the main thread.  This 

02:16:30.960 --> 02:16:33.665
is what I showed you in the 
previous slide.  You can add a 

02:16:33.666 --> 02:16:36.852
success failure completion 
listener, give it a listen      

02:16:36.853 --> 02:16:39.291
 listener, and this listener 
will be invoked on the main 

02:16:39.292 --> 02:16:41.402
thread.
Now, there's a different format 

02:16:41.403 --> 02:16:43.779
and you should know this one.  
This is actually more important 

02:16:43.780 --> 02:16:47.000
than the last one, where you can
 get a callback scoped to an 

02:16:47.001 --> 02:16:50.157
activity.  What it means to be 
scoped to an activity is this 

02:16:50.158 --> 02:16:54.741
listener that you register will 
not get execute ed if the 

02:16:54.742 --> 02:16:59.487
activity goes through its on 
stop.  If an activity is being 

02:16:59.488 --> 02:17:03.580
stopped the listener will not 
execute.  This is important 

02:17:03.581 --> 02:17:05.581
because if you register a listen
er without unregistering it when

02:17:05.743 --> 02:17:08.592
 the activity dies you can have 
an activity leak.  That's 

02:17:08.593 --> 02:17:13.942
terrible.  Long running task 
that exceed or go beyond the 

02:17:13.943 --> 02:17:16.790
life cycle of an activity can 
cause a leak.  This causes out 

02:17:16.791 --> 02:17:19.717
of memory problems and they're 
actually very difficult to 

02:17:19.718 --> 02:17:23.054
diagnose.  If you're calling 
this API within an activity, use

02:17:23.341 --> 02:17:26.079
 the second format, the format 
where it accepts an activity 

02:17:26.080 --> 02:17:29.053
object and you only register or 
only have that listener for that

02:17:29.477 --> 02:17:33.084
 one activity.
If you want to receive your 

02:17:33.085 --> 02:17:36.656
result on another thread, not on
 the main thread, if you want to

02:17:36.802 --> 02:17:38.914
 handle in the background and 
say you wanted to do more block

02:17:39.525 --> 02:17:44.351
ing work in that, now, if you've
 never dealt with an executor 

02:17:44.352 --> 02:17:51.048
before, it's base ically a JAVA 
or    identify's thread

02:17:54.211 --> 02:17:57.944
.  Make an executive decision 
how do you deploy this to 

02:17:54.211 --> 02:17:57.395
another thread.  Could be a 
single or pull of threads or a 

02:17:57.396 --> 02:18:01.171
growing and shrinking pull of 
threads.  This API doesn't care.

02:18:01.472 --> 02:18:06.070
  The executor cares where the 
thread goes.  You just hand it 

02:18:06.071 --> 02:18:08.936
an executor that makes that 
decision.

02:18:09.059 --> 02:18:12.212
&gt;&gt; The last way is you can block
 the current thread if you want 

02:18:12.213 --> 02:18:15.069
to wait for the result end line.
  I say right away don't do this

02:18:15.196 --> 02:18:17.293
 on the main thread.  Don't 
block the main thread.  We can't

02:18:17.574 --> 02:18:20.197
 say that enough.  Don't do that
 in your Android applications.  

02:18:20.198 --> 02:18:22.791
It can lead to a fairly bad user
 experience.  But if you do want

02:18:23.106 --> 02:18:27.243
 to block some other thread, 
there's a utility method on task

02:18:27.534 --> 02:18:30.906
s called await.  You can give it
 the tasks that you want to wait

02:18:31.222 --> 02:18:33.479
 for.  It will block and then 
the result will come out of that

02:18:33.760 --> 02:18:36.268
.  Now, if you're not willing to
 wait indefinitely, you can feed

02:18:36.401 --> 02:18:39.321
 it a timeout.  That timeout 
will sort of time box the amount

02:18:39.482 --> 02:18:46.400
 of time you're willing to wait 
and return with an ex execution.

02:18:46.539 --> 02:18:50.641
  Now, you will have to capture 
both an execution or an 

02:18:50.642 --> 02:18:53.097
interrupted             
interrupted, so you'll have to 

02:18:53.098 --> 02:18:57.349
handle that case here.
So let's say how do you do a 

02:18:57.350 --> 02:19:01.863
sequence of work?  This can be 
common in some Android apps 

02:19:01.864 --> 02:19:04.911
where you have task one which 
leads to task two, so on, so 

02:19:04.912 --> 02:19:06.956
forth.  You have to do them in 
order.  There's a special way to

02:19:07.268 --> 02:19:12.475
 express this in the task API 
using continue with or using 

02:19:12.476 --> 02:19:15.646
continue with task.  There's a 
subtle difference between the 

02:19:15.647 --> 02:19:17.949
two.  So if you're using 
continue with, you will have to 

02:19:17.950 --> 02:19:21.439
create a continuation object.  
What a continuation object does 

02:19:21.440 --> 02:19:25.026
is it says I know how to -- 
there's some result type for 

02:19:25.027 --> 02:19:29.197
input and some result type for 
output.  And within my method 

02:19:29.198 --> 02:19:34.493
when it's called then     then, 
it receives the task that's 

02:19:34.494 --> 02:19:38.991
generating the impact type     
type.  You can see inside the 

02:19:38.992 --> 02:19:41.789
method.  We're calling task get 
result.  That returns the input 

02:19:41.790 --> 02:19:44.096
type.  We can do some 
transformation, do whatever we 

02:19:44.097 --> 02:19:47.022
need to do and generate an 
output type in response.  To 

02:19:47.023 --> 02:19:51.114
make use of that you just call 
on the origin task, call it task

02:19:51.421 --> 02:19:53.380
 continue it, feed it the 
continuation and that feeds you 

02:19:53.381 --> 02:19:57.326
yet another task, which is 
parametertize ed by the output 

02:19:57.327 --> 02:20:00.084
type.
If using continuous task, it's 

02:20:00.085 --> 02:20:01.878
very similar but slight       
slightly different in that 

02:20:01.879 --> 02:20:05.175
continue with task generalates a
 task.  It doesn't generate the 

02:20:05.176 --> 02:20:09.394
result type directly.  It 
generalates a task that is 

02:20:09.395 --> 02:20:12.232
responsible for generating the 
output type.  The form of the 

02:20:12.233 --> 02:20:15.404
execution is the same task dot 
continue with task

02:20:18.445 --> 02:20:20.419
.  You can then wait on to get 
these results.

02:20:20.420 --> 02:20:24.676
Now, it begs the question -- I'm
 on the wrong slide.  Okay.

02:20:24.677 --> 02:20:27.851
So the up-shot of all this task 
chaining business is you have a 

02:20:27.852 --> 02:20:32.953
sort of sin tactic sugar for 
execute ing a series of tasks.  

02:20:32.954 --> 02:20:35.614
If you're like me with and 
worked with data promising 

02:20:35.615 --> 02:20:39.340
frameworks like spark, you know 
you have a series of steps you 

02:20:39.341 --> 02:20:41.564
have to execute.  Say for 
example you have a query and 

02:20:41.565 --> 02:20:44.658
that's going to generate a 
result set, then you want to 

02:20:44.659 --> 02:20:48.306
filter, maybe do some mapping, 
one data point to another, sort 

02:20:48.307 --> 02:20:50.929
those results and group them by 
type, you can express that very 

02:20:50.930 --> 02:20:55.316
suck      succinctly like this. 
 This is how you do serialize 

02:20:55.764 --> 02:21:00.245
ed    ized chain of execution.
So if you want to do parallel 

02:21:00.246 --> 02:21:04.237
task execution, and I would say 
this is actually more common 

02:21:04.238 --> 02:21:07.702
than serial task execution, if 
you want to do it in parallel, 

02:21:07.703 --> 02:21:11.695
and this is very common if you 
say want to kickoff, I don't 

02:21:11.696 --> 02:21:14.610
know, an authentication and a 
query and do a database read and

02:21:14.902 --> 02:21:17.525
 you want those all to happen at
 the same time but you only want

02:21:17.969 --> 02:21:20.630
 to progress to the next step 
when all of those are complete. 

02:21:20.956 --> 02:21:23.713
 So you only want to wait as 
long as the longest one of those

02:21:23.876 --> 02:21:29.988
 tasks.  So to run things in 
parallel, you can use tasks dot 

02:21:29.989 --> 02:21:33.243
win all.  Tasks again is utility
 class.  Win all is utility 

02:21:33.244 --> 02:21:35.688
method that says I'll take each 
one of the tasks that you want 

02:21:35.689 --> 02:21:39.274
to wait on and I'll generate 
from that a final task.  This is

02:21:39.607 --> 02:21:43.806
 asynchronous.  You'll get a 
task in response asynchronously 

02:21:43.807 --> 02:21:48.280
programtize ed.  It doesn't 
generate anything.  But gives 

02:21:48.281 --> 02:21:50.399
you a target to listen to to 
know when the lists are complete

02:21:50.568 --> 02:21:54.170
.  You add a success listener.  
Inside there u you can reach 

02:21:54.171 --> 02:21:56.989
into all the other tests 
inflight and get the results.  

02:21:56.990 --> 02:21:59.953
It's worth note ing that if any 
one of these tasks fail, the 

02:21:59.954 --> 02:22:02.733
entire thing will fail.  So 
you'll need to check for that as

02:22:03.183 --> 02:22:07.328
 well.  Same thing with serial 
task execution.  If any one of 

02:22:07.329 --> 02:22:09.923
your tasks in the serial chain 
fails, the whole thing will fail

02:22:10.202 --> 02:22:13.335
.  In fact, that exception will 
get propagate ed on from task to

02:22:13.644 --> 02:22:16.266
 task until the final result 
will receive the original 

02:22:16.267 --> 02:22:19.267
exception that caused the 
failure.

02:22:19.355 --> 02:22:23.622
So the easy iest way to et crew 
your own                  create

02:22:23.937 --> 02:22:27.198
 your own task is to create a 
callable.  It's a java construct

02:22:27.366 --> 02:22:30.309
.  Very similar to run    
runnable.  Runnable takes 

02:22:30.310 --> 02:22:33.446
nothing as input and generalates
 nothing as output.  Callable 

02:22:33.447 --> 02:22:36.812
takes nothing as input and 
generalates some programmerrize 

02:22:37.264 --> 02:22:42.067
ed as output.  We're create ing 
a callable, programmertize ed 

02:22:42.068 --> 02:22:49.107
and simply puts out that print 
type.  All you do is tasks.call 

02:22:49.108 --> 02:22:51.277
and feed it that call.  
Immediately you'll get a task 

02:22:51.278 --> 02:22:53.779
object that you can wait on to 
get that result.

02:22:53.853 --> 02:22:57.681
Now, it's important to know that
 tasks.call will schedule your 

02:22:57.682 --> 02:23:00.963
work to run on the main thread. 
 If you're doing some blocking 

02:23:00.964 --> 02:23:03.719
work in your callable you 
probably don't want that.  

02:23:03.720 --> 02:23:05.661
Probably want to schedule it on 
another thread.  There's a 

02:23:05.662 --> 02:23:08.282
format that takes an executor.  
Create an executor         

02:23:08.283 --> 02:23:11.079
executor, schedule your work on 
that, your task on that, and 

02:23:11.080 --> 02:23:15.825
then you can use that task in 
serial or parallel tasks along 

02:23:15.826 --> 02:23:19.838
with the Firebase ed tasks.
Now, if you have your own thread

02:23:19.986 --> 02:23:22.156
ing           threading 
framework, I know there's a 

02:23:22.157 --> 02:23:24.707
bunch and everyone has their own
 favorite asynchronous framework

02:23:25.924 --> 02:23:28.746
, you don't have to abandon that
 to use tasks and you don't have

02:23:29.060 --> 02:23:33.735
 to wedge tasks into that other 
format.  There is a way to do 

02:23:33.736 --> 02:23:36.169
some interoperability.  A bunch 
of code on this and I'll try to 

02:23:36.170 --> 02:23:39.363
unpack it
the intermethod here the class 

02:23:39.364 --> 02:23:42.184
here is called task completion 
source.  What a task completion 

02:23:42.185 --> 02:23:47.072
source does is provides kind of 
an empty task for other threads 

02:23:47.073 --> 02:23:51.127
to feed their results into.  So 
when you have a task completion 

02:23:51.128 --> 02:23:54.076
source, you can get a task out 
of it and register a success 

02:23:54.077 --> 02:23:58.343
listener.  That success listener
 would again be programmer    

02:23:58.667 --> 02:24:00.667
       programmertize ed by the 
type you're expecting

02:24:00.794 --> 02:24:04.921
In this example I'm going tofire
 up           to fire up a new 

02:24:04.922 --> 02:24:06.984
thread.  This is just for 
illustration.  What you can do 

02:24:06.985 --> 02:24:09.796
is in that other thread, 
whatever it's doing, if it's 

02:24:09.797 --> 02:24:11.820
going to generate some result 
and you need to feed that result

02:24:11.970 --> 02:24:17.053
 into a task, you can just call 
source.set result.  What that 

02:24:17.054 --> 02:24:19.530
does is the task that's in that 
result will be fully complete ed

02:24:19.531 --> 02:24:24.422
 or resolved.  That's how you 
can have things in your other 

02:24:24.423 --> 02:24:29.179
asynchronous framework work with
 the task framework.

02:24:29.180 --> 02:24:32.990
So that's all great.  Now I'd 
like to move onto some specific 

02:24:32.991 --> 02:24:35.912
product details.  I'll tell you 
a little bit about Firebase 

02:24:35.913 --> 02:24:38.218
crash reporting.  Crash report
ing is special to me because I 

02:24:38.219 --> 02:24:41.411
worked on this.  I'm actually 
the developer advocate for crash

02:24:41.412 --> 02:24:45.596
 reporting and test lab.  So I 
have sort of a special place for

02:24:46.505 --> 02:24:49.590
 me with crash reporting.  You 
might ask the question how do 

02:24:49.591 --> 02:24:52.082
you actually detect a crash?  
That seems like a strange thing.

02:24:52.083 --> 02:24:55.911
  How do you do it?  So I'm sure
 you all know this dialogue.  If

02:24:55.912 --> 02:24:58.793
 you're an Android developer you
 have seen this dialogue.  If 

02:24:58.794 --> 02:25:01.628
you haven't, I'm willing to bet 
you've never written a line of 

02:25:01.629 --> 02:25:04.645
Android code or you're a really 
darn good developer.  And actual

02:25:04.952 --> 02:25:08.676
ly I think this dialogue is 
actually kind of funny.  It's 

02:25:08.677 --> 02:25:10.946
saying something rather 
unfortunate happened and I'm 

02:25:10.947 --> 02:25:13.121
asked to be okay with it   it.  
I don't think this is okay.  

02:25:13.122 --> 02:25:16.687
This is not okay.  So the button
 should actually say not okay.  

02:25:16.688 --> 02:25:19.616
I really think it should say not
 okay.  But in this case I'm 

02:25:19.617 --> 02:25:23.334
being asked to say it's okay.  
When you push okay then the 

02:25:23.335 --> 02:25:28.494
process finally dies.
The way to handle this case is 

02:25:28.495 --> 02:25:31.506
using something called an 
unC.O.D. exception handler.

02:25:34.723 --> 02:25:35.541
  This is a regular java 
construct.  There this is 

02:25:35.542 --> 02:25:38.315
interface under java laying 
thread       thread.  You can 

02:25:38.316 --> 02:25:41.383
register one of these.  This 
will get notified if there's an 

02:25:41.384 --> 02:25:46.280
exception that pops off the call
 -- runtime a no pointer 

02:25:46.281 --> 02:25:51.027
exception that made its way back
 to the top of the call stack.  

02:25:51.028 --> 02:25:54.055
If you want to know if that 
happened use an on call handler.

02:25:54.188 --> 02:25:57.582
  The interface for that is 
pretty simpler.  Here I'm 

02:25:57.583 --> 02:25:59.032
create ing an anonymous 
exception handler.  I'm going to

02:25:59.033 --> 02:26:02.101
 receive the thread that actual
ly generate ed that and the 

02:26:02.102 --> 02:26:04.102
throwable that made it outside 
the call stack.

02:26:04.379 --> 02:26:07.223
And then what I can do is to 
register this for all threads 

02:26:07.224 --> 02:26:12.784
within my JVM or art or whatever
 you want to call it   it, you 

02:26:12.785 --> 02:26:16.671
can call it exception handler, a
 great verbose java name, pass 

02:26:16.672 --> 02:26:20.249
it that handler.  What happens 
is any time for any thread if 

02:26:20.250 --> 02:26:25.479
it's going to crash with an 
exception, you'll get called 

02:26:25.480 --> 02:26:29.971
before the process finally dies.
Now, actually, I advanced a 

02:26:29.972 --> 02:26:34.483
little too soon.  So if you read
 your exception happened letter 

02:26:34.484 --> 02:26:37.394
that does nothing.  Like in the 
previous side there was no 

02:26:37.395 --> 02:26:39.671
implementation there.  If you 
register that it will actually 

02:26:39.672 --> 02:26:41.682
keep your app from crash      
crashing.  It will continue to 

02:26:41.683 --> 02:26:44.302
run.  This which is probably not
 what you want, because if a 

02:26:44.303 --> 02:26:47.359
runtime exception gets thrown, 
that will actually -- that's a 

02:26:47.360 --> 02:26:49.838
bad thing for your app.  It 
really should die.  Things could

02:26:50.041 --> 02:26:52.518
 be in a bad state.  You don't 
want to continue.  What you 

02:26:52.519 --> 02:26:55.588
really want to do is call 
through to the prior exception 

02:26:55.589 --> 02:26:58.750
handler.  So this is the best 
practice.  This is kind of the 

02:26:58.751 --> 02:27:00.928
understood practice for 
exception handlers.  The first 

02:27:00.929 --> 02:27:04.585
thing you do, you get the prior 
default exception handler.  Then

02:27:04.586 --> 02:27:07.322
 you create your own and call 
through to the prior one when 

02:27:07.323 --> 02:27:11.986
you're done.  This let's bunch 
of components all create a 

02:27:11.987 --> 02:27:14.415
different sort of like chain of 
-- not chain of responsibilities

02:27:15.276 --> 02:27:17.672
, but a chain of reaction so you
 can register a bunch of default

02:27:18.423 --> 02:27:21.650
 exception handlers          
handers.  Each one will run in 

02:27:21.651 --> 02:27:25.608
turn until the original default 
Android handler which is 

02:27:25.609 --> 02:27:28.012
responsible for putting up the 
crash dialogue will finally run.

02:27:30.701 --> 02:27:35.559
So you've probably seen this as 
well.  This is an A and R or 

02:27:35.560 --> 02:27:38.522
application not responding.  
This happens when you run 

02:27:38.523 --> 02:27:41.309
something on the main thread 
that takes more than five skdz. 

02:27:41.522 --> 02:27:44.637
 More often than that, some 
network access or file access 

02:27:44.638 --> 02:27:48.515
that took too long.  Or some 
sort of algorithm that got out 

02:27:48.516 --> 02:27:51.697
of control.  This is a bad user 
experience.  It's asking me to 

02:27:51.698 --> 02:27:53.991
be okay with that.  I'm not 
really okay with it and I 

02:27:53.992 --> 02:27:58.368
probably don't want to wait, but
 this is not generate ed from an

02:27:59.930 --> 02:28:02.364
 uncaught exception handler, 
this is Android kicking in and 

02:28:02.365 --> 02:28:05.650
saying look, your main thread is
 out of order.  The user needs 

02:28:05.651 --> 02:28:08.187
to be able to decide do I want 
to keep waiting for this.

02:28:08.326 --> 02:28:13.569
Now, it's worth note ing that 
inside your default uncaught 

02:28:13.570 --> 02:28:16.558
exception handler, if you block 
too long, and Android, you can 

02:28:16.559 --> 02:28:20.135
still ANR the app.  Your 
uncaught exception handler still

02:28:20.288 --> 02:28:22.831
 have to follow the general 
rules of Android development 

02:28:22.832 --> 02:28:25.768
where you don't block it.  It's 
kind of a bad idea.  If you do 

02:28:25.769 --> 02:28:28.863
block for more than five seconds
 and the user chooses to term 

02:28:28.864 --> 02:28:34.006
Nate the app by saying, okay, 
you'll lose that crash.  The 

02:28:34.007 --> 02:28:38.410
Android will kill your app.  In 
your uncaught exception handler,

02:28:38.411 --> 02:28:43.556
 you need to be quick, let get 
that crash and let the user move

02:28:43.761 --> 02:28:46.340
 on.
So all that aside, now, hold 

02:28:46.341 --> 02:28:49.035
that all in your mind for a 
moment and say now let's talk 

02:28:49.036 --> 02:28:52.576
about how crash reporting actual
ly works.  At some point we need

02:28:52.849 --> 02:28:56.088
 to register this uncaught 
exception hand      handler. 

02:28:59.296 --> 02:29:03.362
 Crash reporting needs to do 
this.  We use a content provider

02:28:59.296 --> 02:29:01.459
 for this.  That seems weird 
     weird.  Why would you use a

02:29:01.619 --> 02:29:03.988
 content provider to register 
crash reporting?  Isn't a 

02:29:03.989 --> 02:29:06.167
content provider supposed to 
provide content?  You would say 

02:29:06.168 --> 02:29:10.519
yeah, of course, but there's 
some interesting properties 

02:29:10.520 --> 02:29:15.831
about content providers that 
make this interesting.  It's 

02:29:15.832 --> 02:29:18.318
worthwhile to look at how an 
Android process actually starts 

02:29:18.319 --> 02:29:21.572
up.  There's procedure that 
every Android app goes through. 

02:29:22.283 --> 02:29:24.237
 The first thing that happens 
when an Android process starts 

02:29:24.238 --> 02:29:27.700
up is every content provide that
 you declare in your manifest 

02:29:27.701 --> 02:29:33.119
goes to its on create in order 
of priority.  If there's a 

02:29:33.120 --> 02:29:33.574
priority definition there it 
will go in that order.  Now, 

02:29:33.575 --> 02:29:36.516
it's also worth note ing that 
this happens in your main 

02:29:36.517 --> 02:29:39.802
process only.  If you have a 
multi process app, and most of 

02:29:39.803 --> 02:29:44.194
you probably do not, but if you 
have a multi process app, , the 

02:29:44.195 --> 02:29:47.263
contour providers will not be 
created off the main process.

02:29:47.348 --> 02:29:50.075
The second thing that happens is
 your application sub class will

02:29:50.633 --> 02:29:53.456
 be created.  If you've defined 
an application sub class which I

02:29:53.774 --> 02:29:56.745
 think something like a third of
 all Android apps do this, that 

02:29:56.746 --> 02:29:59.154
will be initialize ed, go 
through its on create after all 

02:29:59.155 --> 02:30:03.330
the content providers.
Then once that happened, the 

02:30:03.331 --> 02:30:05.302
third thing that happens is 
whatever component that needs to

02:30:05.303 --> 02:30:09.067
 be invoked will be invoked.  
Usually it's an app launch.  So 

02:30:09.068 --> 02:30:11.752
an activity will come into play.
  Or a service could have been 

02:30:11.753 --> 02:30:15.323
started.  Or a broadcast receive
         receiver.  Whatever the

02:30:15.641 --> 02:30:18.646
 invoke component it will not be
 create ed and run until content

02:30:18.819 --> 02:30:22.172
 providers and applications all 
in it.

02:30:22.173 --> 02:30:24.785
It's worth note ing here content
 provider is the early iest hook

02:30:24.941 --> 02:30:28.704
 into the Android process.  So 
that's why we initialize crash 

02:30:28.705 --> 02:30:31.210
reporting there.  If we initial
ize crash reporting in a content

02:30:31.528 --> 02:30:34.752
 provider, that means we will 
happen before application and 

02:30:34.753 --> 02:30:36.910
before everything else.  So 
that's one benefit.

02:30:36.991 --> 02:30:39.871
The other benefit to using a 
content provider is content 

02:30:39.872 --> 02:30:43.974
providers participate in Android
 manifest merger.  An Android, 

02:30:43.975 --> 02:30:46.485
you know that if you have 
library projects and all of 

02:30:46.486 --> 02:30:49.642
those things from all of those 
manifests all get combined into 

02:30:49.643 --> 02:30:53.676
a single manifest for your app, 
so if we define in our crash 

02:30:53.677 --> 02:30:56.852
reporting library, a content 
provider that automatically gets

02:30:57.143 --> 02:30:59.478
 pulled into your app and that 
automatically causes 

02:30:59.479 --> 02:31:01.892
initialization.  This is great 
because you don't have to write 

02:31:01.893 --> 02:31:04.616
a line of code to initialize.  
All you do is depend on the 

02:31:04.617 --> 02:31:07.402
library and manifest merger will
 bring our content provider in, 

02:31:07.403 --> 02:31:14.694
do the initialsation and it's 
super easy for you.  Now, the 

02:31:14.695 --> 02:31:17.634
reason -- you could use 
application, but applications  

02:31:17.783 --> 02:31:19.783
            applications don't 
participate in Android manifest

02:31:21.564 --> 02:31:23.123
 merger.  The only way you can 
define an application object is 

02:31:23.124 --> 02:31:27.208
you and your manifest.  Library 
projects cannot contribute to 

02:31:27.209 --> 02:31:30.998
applications, they can't hook 
into on create, that's why we're

02:31:31.577 --> 02:31:34.780
 using content provider.
Now, the Firebase uncaught 

02:31:34.781 --> 02:31:38.339
exception handler does a number 
of things.  The first thing is 

02:31:38.340 --> 02:31:41.045
it collects a lot of information
 about the device.  This is one 

02:31:41.046 --> 02:31:43.540
when we go off and find the 
device type and measure memory 

02:31:43.541 --> 02:31:46.892
and serialize the exception and 
what we're going to do is dump 

02:31:46.893 --> 02:31:50.875
that all into a proto buff and 
send that to a crash service.  

02:31:50.876 --> 02:31:55.479
Now, crash service is an Android
 service.  The way we built it, 

02:31:55.480 --> 02:31:57.732
at least for this launch, is to 
run in another process.  So the 

02:31:57.733 --> 02:32:00.940
crash services that do 
persistence of the crash will 

02:32:00.941 --> 02:32:03.737
write it to disk and do the 
transmission all happens in 

02:32:03.738 --> 02:32:07.214
another process.  Now, this is a
 clever idea, right?  If you 

02:32:07.215 --> 02:32:12.455
remember back before you can say
, you know, the idea of causing 

02:32:12.456 --> 02:32:15.927
an ANR within your crash handler
 is a bad idea.  What we wanted 

02:32:15.928 --> 02:32:18.946
to do is get all that data as 
fast as possible and ship it off

02:32:19.123 --> 02:32:22.653
 to another process.  Let that 
do the blocking, the writing to 

02:32:22.654 --> 02:32:26.278
disk, let that do the write ing 
to network and let the main app 

02:32:26.279 --> 02:32:30.764
process crash gracefully and let
 the user move on and do what 

02:32:30.765 --> 02:32:33.699
they want.  This also let's us 
do persistent retry.  This other

02:32:34.009 --> 02:32:37.018
 process can keep retrialing and
 sending that crash so we can 

02:32:37.019 --> 02:32:41.393
get it as fast as possible.
Now, there's a little problem 

02:32:41.394 --> 02:32:46.498
with this scheme.  I don't know 
if you can see it right 

02:32:46.499 --> 02:32:50.604
awireless network.  We didn't 
see it until late in the 

02:32:50.605 --> 02:32:53.488
development cycle.  I'll say a 
little bit more about that, but 

02:32:53.489 --> 02:32:55.652
here's a situation we have     
have.  We have a main app 

02:32:55.653 --> 02:32:59.269
process.  It goes through its 
content provider, application, 

02:32:59.270 --> 02:33:02.351
and invoke components.  Now we 
have this background process 

02:33:02.352 --> 02:33:06.217
that's handling the crash.  It 
goes through its application and

02:33:07.285 --> 02:33:10.502
 the crash service gets invoked.
  The problem here is that if 

02:33:10.503 --> 02:33:13.448
your application object is 
writing to some shared resource 

02:33:13.449 --> 02:33:18.112
to a database or a file, there's
 a potential for erase conflict 

02:33:18.113 --> 02:33:21.919
here.  So most app developers 
don't actually depend -- or 

02:33:21.920 --> 02:33:25.322
expect that their application 
object would be run twice.  The 

02:33:25.323 --> 02:33:29.989
normal expectation is that it's 
run once in a single process.  

02:33:29.990 --> 02:33:32.054
Because we're running crash 
reporting in another process, 

02:33:32.055 --> 02:33:34.367
that means we have a second 
application object, just like 

02:33:34.368 --> 02:33:37.335
the first and it's doing the 
same thing as the first.  If 

02:33:37.336 --> 02:33:39.401
your application object is 
writing to a database you could 

02:33:39.402 --> 02:33:43.456
actually run into a locking 
problem.  We actually didn't 

02:33:43.457 --> 02:33:46.960
detect this.  The people who 
detected this were our early 

02:33:46.961 --> 02:33:49.976
access partners.  We had a 
couple partners who had some 

02:33:49.977 --> 02:33:52.843
strange errors and it turned out
 this was the problem.  This is 

02:33:52.844 --> 02:33:54.797
one of the reasons why we're 
launching crash reporting for 

02:33:54.798 --> 02:34:01.312
Android as beta because of this.
  Now, it should be told that 

02:34:01.313 --> 02:34:04.280
crash reporting is -- it's 
production ready.  We want you 

02:34:04.281 --> 02:34:06.904
to use it.  We really hope you 
use T. we think it's a great 

02:34:06.905 --> 02:34:10.491
tool.  But you should know if 
your application object is doing

02:34:10.637 --> 02:34:13.344
 any of this writing to a 
database or a file, crash report

02:34:13.510 --> 02:34:17.220
ing may cause problems four.  
This is something we're hoping 

02:34:17.221 --> 02:34:21.791
to resolve.
There's another problem with 

02:34:21.792 --> 02:34:24.736
this plan of using a background 
task is there's a movement 

02:34:24.737 --> 02:34:27.425
within Google to encourage apps 
to eliminate background 

02:34:27.426 --> 02:34:31.326
invisible word.  Define what 
invisible work is.  Invisible 

02:34:31.327 --> 02:34:35.714
work is something your app is 
doing without a UA displaying.  

02:34:35.715 --> 02:34:39.498
If you have no activity that's 
started in the foreground.  That

02:34:39.499 --> 02:34:42.553
 would be visible work.  If you 
have a service that has a 

02:34:42.554 --> 02:34:45.409
notification in the curtain, 
that's visible work.  So if you 

02:34:45.410 --> 02:34:48.497
don't have either one of those 
situations, that's invisible 

02:34:48.498 --> 02:34:52.647
work.  And at Google we're 
trying to encourage developers 

02:34:52.648 --> 02:34:56.258
to cut back on the amount of 
invisible work because that can 

02:34:56.259 --> 02:35:00.935
cause battery drain or 81 known 
like data usage.  For crash 

02:35:00.936 --> 02:35:04.874
report       reporting this 
actually is -- we're doing 

02:35:04.875 --> 02:35:07.572
invisible work so we need to cut
 down on that.

02:35:07.573 --> 02:35:10.366
I was expecting to have a URL to
 a blog post where we talked a 

02:35:10.367 --> 02:35:11.882
little bit about that.  
Unfortunately it's not available

02:35:11.883 --> 02:35:14.988
.  I'll have that on Monday.  I 
think the plan is to publish 

02:35:14.989 --> 02:35:17.917
this on Monday.  If you join the
 spaces for this talk, I can get

02:35:18.023 --> 02:35:21.354
 you that URL.  I think it will 
be posted on our medium blog.  

02:35:21.355 --> 02:35:24.760
So if you want to read more 
about that, follow up with that.

02:35:26.390 --> 02:35:29.177
So in the next version of crash 
reporting, we will actually not 

02:35:29.178 --> 02:35:34.031
have a background process.  
We're working on eliminate ing 

02:35:34.032 --> 02:35:37.403
that.  The up-sides of course 
we'll work more widely so we 

02:35:37.404 --> 02:35:40.204
don't have to worry about apps 
with application objects that 

02:35:40.205 --> 02:35:42.788
aren't compatible.  It will be 
more compliant to development 

02:35:42.789 --> 02:35:47.184
where we'll be cut     cutting 
back on this invisible work.  

02:35:47.185 --> 02:35:51.765
The downside is there is an 
increased chance of latency.  

02:35:51.766 --> 02:35:55.309
With the old we could get that 
passage sent vary vie quickly.  

02:35:55.310 --> 02:35:57.986
If we're competing with the idea
 that the app may die before we 

02:35:57.987 --> 02:36:02.062
can get the crash out of the -- 
into our serve ers and into the 

02:36:02.063 --> 02:36:06.538
app, it's just a risk that we 
just can't get at immediately.  

02:36:06.539 --> 02:36:09.769
Also this gives us a sort of 
constraint of being able to 

02:36:09.770 --> 02:36:13.075
retry less frequently.  So that 
said, there's trade-offs.  We're

02:36:13.076 --> 02:36:16.852
 going for the no background 
process version.

02:36:16.939 --> 02:36:22.036
Okay.  So that's crash reporting
.  I'll say a little bit about 

02:36:22.037 --> 02:36:27.935
how things work on -- oh, didn't
 advance.  Firebase analytics, 

02:36:27.936 --> 02:36:31.283
okay.  Another interesting thing
, you might be wondering how 

02:36:31.284 --> 02:36:35.242
does Firebase analytics track 
user behavior?  Now, if you 

02:36:35.243 --> 02:36:38.619
recall earlier, we put analytics
 in every Firebase app.  This is

02:36:38.767 --> 02:36:41.786
 a very important component.  
What it does, one of the things 

02:36:41.787 --> 02:36:45.111
it does, is it tracks the usage 
for your app.  This is great.  

02:36:45.112 --> 02:36:47.947
You do nothing.  You write zero 
lines of code and you get track

02:36:48.094 --> 02:36:51.169
ing.  You might be wondering, 
how does analytics do that if 

02:36:51.170 --> 02:36:53.170
you're not write ing code?  How 
does it

02:36:56.296 --> 02:36:57.083
 reach into my app and know how 
the user is using it?  So the 

02:36:57.084 --> 02:37:00.529
question that we're trying to 
ask is how do we determine when 

02:37:00.530 --> 02:37:02.880
the app is in the foreground and
 when the app is in the 

02:37:02.881 --> 02:37:07.262
background?  How do you track 
the time spent in the app and 

02:37:07.263 --> 02:37:11.446
how do they navigate activities?
  This is user      iewferl for 

02:37:11.447 --> 02:37:14.980
determine ing how long a session
 is or how frequently a user is 

02:37:14.981 --> 02:37:18.404
using your app.
The way we do that is using 

02:37:18.405 --> 02:37:21.968
something called activity life 
cycle callbacks.  It's an API in

02:37:22.123 --> 02:37:25.872
 Android.  Available since ice 
cream sandwich and beyond.  API 

02:37:25.873 --> 02:37:29.214
level 14.  If you create one of 
these and register it with your 

02:37:29.215 --> 02:37:31.729
app, you can receive call backed
 for every activity in your app.

02:37:32.022 --> 02:37:35.648
  A universal listener for all 
activity.  All activities 

02:37:35.649 --> 02:37:39.536
clearly have to go through their
 create, start, resume, and so 

02:37:39.537 --> 02:37:41.998
either to.  You can listen to 
every single one of those.  This

02:37:41.999 --> 02:37:45.154
 is how Firebase analytics 
determines how users are using 

02:37:45.155 --> 02:37:47.155
your app.

02:37:48.866 --> 02:37:53.655
So for this interface we have 
created pause ed stop, resume.  

02:37:53.656 --> 02:37:58.335
You can listen to all these but 
there's two in particular that 

02:37:58.336 --> 02:38:01.890
are determined in how a user is 
using your app.  That is on 

02:38:01.891 --> 02:38:05.452
start and on stop.  Here's a bit
 of code.  It's kind of a little

02:38:05.453 --> 02:38:10.104
 bit pseudo Cody, but this is 
something you could do in your 

02:38:10.105 --> 02:38:11.920
own app if you want to track 
something similar.  I'll walk 

02:38:11.921 --> 02:38:14.656
you through these lines.  The 
first thing we want to do is 

02:38:14.657 --> 02:38:17.835
count the number of activities 
that have been started.  We also

02:38:18.001 --> 02:38:21.440
 want to count the moment at 
which the user first enters the 

02:38:21.441 --> 02:38:25.421
app.  That's userrented time    
 time.  Now, when we listen to 

02:38:25.422 --> 02:38:28.374
on activity started, what we can
 say is if there are no 

02:38:28.375 --> 02:38:30.375
activities started, none started
 equals

02:38:33.262 --> 02:38:37.528
 zero, we can record the current
 time.  That's the time that the

02:38:33.262 --> 02:38:35.368
 user launched the app or first 
entered it from say the task 

02:38:35.369 --> 02:38:38.841
switcher.  Then what we do is 
increment the number of started

02:38:40.782 --> 02:38:42.782
         started activities.  
Then as an activity is sphopped

02:38:46.381 --> 02:38:50.181
          stopped, we'll 
turnaround, decrement the number

02:38:46.381 --> 02:38:47.859
 of started activities and say 
if the number of started 

02:38:47.860 --> 02:38:51.356
activities is zero, meaning 
there's no activities visible 

02:38:51.357 --> 02:38:55.016
right now, record the time that 
they left the app, do a little 

02:38:55.017 --> 02:38:57.636
math and say this is how long 
the user was in the app.  Now, 

02:38:57.637 --> 02:39:01.026
this is pretty handy, right?  
This is a fairly bulletproof way

02:39:01.202 --> 02:39:03.592
 of knowing when the user was 
looking at your app and when 

02:39:03.593 --> 02:39:06.312
they were not, because as long 
as you have an activity started 

02:39:06.313 --> 02:39:08.752
you can be certain that you were
 on the screen.  When your 

02:39:08.903 --> 02:39:10.911
activity is stopped you can be 
certain that you were invisible.

02:39:11.022 --> 02:39:16.139
  This is how we track that.
So what's next after here?  I've

02:39:16.140 --> 02:39:20.855
 given a bulge of information. 
                      bunch of 

02:39:20.856 --> 02:39:23.684
information.  If you're an IOS 
developer there's another talk 

02:39:23.685 --> 02:39:27.232
in this room from an IOS 
perspective.  If you want to 

02:39:27.233 --> 02:39:29.237
know anything about Firebase 
there's links here.  If you want

02:39:29.238 --> 02:39:32.208
 to join the spa I say and ask 
questions and interact with each

02:39:32.377 --> 02:39:34.653
 other, and I had that link to 
the blog post, that will be here

02:39:34.774 --> 02:39:37.798
 as well.  It looks like we have
 some amount of time left.  I'll

02:39:37.799 --> 02:39:42.209
 take some questions if anyone 
would like it and thank you for 

02:39:42.210 --> 02:39:45.753
being here.
[ APPLAUSE ]

02:40:15.524 --> 02:40:17.451
     &gt;&gt; I don't think I quite 
understood what the relationship

02:40:17.452 --> 02:40:21.607
 between the task API and 
Firebase is.  Like can I use the

02:40:21.916 --> 02:40:24.677
 new task API and not use 
Firebase or is it something 

02:40:24.678 --> 02:40:26.983
that's --
&gt;&gt; Yeah.  So the question is can

02:40:27.470 --> 02:40:30.363
 you use this new task API 
without using Firebase, and the 

02:40:30.364 --> 02:40:33.382
answer to that is yes.  Task API
 is just a lightweight 

02:40:33.383 --> 02:40:36.918
collection of classes.  If you 
pull in Firebase as a dependency

02:40:37.294 --> 02:40:41.289
, you will get the task API for 
free and you're not obligate ed 

02:40:41.290 --> 02:40:45.203
to use anything in Firebase.  So
 yeah.

02:40:45.293 --> 02:40:52.592
&gt;&gt; So what's the relation 
between task API and Igerra API.

02:40:52.712 --> 02:40:54.427
  It's also observe able 
           observable type, 

02:40:54.428 --> 02:40:57.670
right?  So why having both now?
&gt;&gt; Right.  So the question is 

02:40:57.671 --> 02:41:02.061
what is the relationship between
 the task API and Agera.  For 

02:41:02.062 --> 02:41:05.271
those of you who don't know, 
it's a library Google released 

02:41:05.272 --> 02:41:07.561
that is similar to frameworks 
like RX java

04:01:38.454 --> 04:01:39.454
&gt;
&gt;&gt;

04:01:38.454 --> 04:01:38.724
&gt;&gt;
&gt;&gt;

04:01:38.725 --> 04:01:39.725
&gt;&gt;
&gt;&gt;

04:01:38.725 --> 04:01:40.725
&gt;&gt; Test test

04:02:08.051 --> 04:02:10.364
 test test test test test test

04:03:24.074 --> 04:03:26.074
 test.

04:03:27.613 --> 04:03:28.613
&gt;&gt;
&gt;&gt;

04:03:27.613 --> 04:03:28.613
&gt;&gt;
&gt;&gt;

04:03:27.613 --> 04:03:28.613
&gt;&gt;
&gt;&gt;

04:03:27.613 --> 04:03:28.613
&gt;&gt;
&gt;&gt;

04:03:27.613 --> 04:03:30.245
&gt;&gt; May 19,

04:03:43.192 --> 04:03:44.340
 2016
FB19. 

04:03:44.341 --> 04:03:48.137
Google Libraries for iOS 
Developers

04:07:29.606 --> 04:07:30.322
&gt;&gt;
&gt;&gt;

04:07:30.323 --> 04:07:31.323
&gt;&gt;
&gt;&gt;

04:07:30.323 --> 04:07:31.323
&gt;&gt;
&gt;&gt;

04:07:30.323 --> 04:07:33.433
&gt;&gt; May 19, 2016. 

04:07:40.185 --> 04:07:43.503
FB19. 
Firebase for iOS Developers

04:08:07.383 --> 04:08:10.598
&gt;&gt; Well, I guess the music 
stopped, so that's my cue to 

04:08:10.599 --> 04:08:15.450
start.  Hi, everybody!  I hope 
the line wasn't too long.  This 

04:08:15.451 --> 04:08:18.647
is Firebase for iOS developers, 
I have an awful lot of content 

04:08:18.648 --> 04:08:21.677
to go through and not a lot of 
time so I will get started and 

04:08:21.678 --> 04:08:26.118
talk really fast.  Sort of like 
micro machines guy if you 

04:08:26.119 --> 04:08:29.242
remember him.  So as you may 
have heard, Firebase is a suite 

04:08:29.243 --> 04:08:33.588
of integrated products divined 
to help you develop your app, 

04:08:33.589 --> 04:08:38.126
grow user base and earn money 
and more specifically.  We are 

04:08:38.127 --> 04:08:43.742
there to help you on iOS.  I 
know we are at Google I/O and I 

04:08:43.743 --> 04:08:46.772
know you will hear about instant
 apps and all of that stuff 

04:08:46.773 --> 04:08:50.696
which does sound cool, but when 
it comes to  developer tools, 

04:08:50.697 --> 04:08:54.638
particularly mobile developer 
tools and particularly Firebase 

04:08:54.639 --> 04:08:57.633
we take cross platform s 
eriously.  We know a mobile 

04:08:57.634 --> 04:09:01.167
library is probably not helpful 
to you unless it's available on 

04:09:01.168 --> 04:09:04.292
all of the platforms you are 
developing for and for most of 

04:09:04.293 --> 04:09:07.892
you, doing development in m 
obile, that generally means 

04:09:08.315 --> 04:09:12.946
Android and iOS.  Imhappy that 
this whole cool new platform is 

04:09:12.947 --> 04:09:16.899
built under the Firebase brand 
because I think people know that

04:09:16.900 --> 04:09:19.699
 Firebase is serious about 
supporting iOS and will continue

04:09:19.997 --> 04:09:21.997
 to in the

04:09:23.709 --> 04:09:25.624
 future.
&gt;&gt; Fun fact, if I give this talk

04:09:25.625 --> 04:09:29.338
 in Spanish it looks like I'm 
excited about the idea of an 

04:09:29.339 --> 04:09:32.760
operating system.  That's my one
 internationalization joke for 

04:09:32.761 --> 04:09:38.107
the event.  Thank you. 
Out of the features we have 

04:09:38.108 --> 04:09:40.640
available on Firebase these are 
the ones available on iOS.  So 

04:09:40.641 --> 04:09:43.756
you will notice the only thing 
we had to dim out was the test 

04:09:43.757 --> 04:09:48.485
lab which is specifically being 
called test lab for Android for 

04:09:48.486 --> 04:09:52.123
that purpose.  It didn't fit 
nicely in the slide.  Everything

04:09:52.309 --> 04:09:56.886
 you can't do in Firebase, you 
can do on Android and iOS. 

04:09:56.887 --> 04:10:00.759
So this is kind of supposed to 
be a technical deep dive which I

04:10:01.074 --> 04:10:05.003
 think is weird given that some 
of the features are brand new to

04:10:05.195 --> 04:10:07.703
 you and you haven't had a 
chance to play with them so this

04:10:07.934 --> 04:10:10.743
 talk will be more about 
interesting quirks that I 

04:10:10.744 --> 04:10:13.475
discovered which I started 
experimenting and p laying 

04:10:13.476 --> 04:10:16.287
around with the Firebase 
platform and building my own app

04:10:16.475 --> 04:10:20.879
 which as fed lal law mandates 
any time you create a new law 

04:10:20.880 --> 04:10:26.395
with a library it has to be a t 
o-do app. 

04:10:26.396 --> 04:10:29.253
I don't know all of the answers 
to everything, this is like this

04:10:29.576 --> 04:10:33.976
 is a neat quirk and I thought I
 would give a presentation on 

04:10:33.977 --> 04:10:37.817
it.  Legits talk about the setup
 process.  Generally Firebase 

04:10:37.818 --> 04:10:43.858
encourages you to use CocoaPods.
  We are we are using CocoaPods 

04:10:43.859 --> 04:10:47.373
as the generally recommended 
withdraw to install stuff.  

04:10:47.374 --> 04:10:51.291
Probably a lot of you know it.  
It's a dependency manager that 

04:10:51.292 --> 04:10:54.729
vastly simplifies the process of
 adding libraries to your app.  

04:10:54.730 --> 04:10:58.905
If you don't know anything about
 CocoaPods, we do have a 

04:10:58.906 --> 04:11:02.367
fantastic video.  I'm having 
trouble with the clicker. 

04:11:02.880 --> 04:11:07.503
That you can check out with an 
incredibly handsome cast.  I'll 

04:11:07.504 --> 04:11:10.648
give you a moment if you want to
 take a picture of the URL, go 

04:11:10.649 --> 04:11:15.767
ahead and if not, I will post it
 in the Google space afterward. 

04:11:16.074 --> 04:11:19.592
 One important note about cocoa 
pods is you should generally 

04:11:19.593 --> 04:11:23.725
only pod install what you need. 
Not everyone knows this, I 

04:11:23.726 --> 04:11:27.244
didn't know this at first, but 
the thing about CocoaPods is a 

04:11:27.245 --> 04:11:31.578
dding a pod actually increases 
the size of the app whether you 

04:11:31.579 --> 04:11:34.797
include that code or not.  So if
 you have the choice between 

04:11:34.798 --> 04:11:39.743
installing a massive Uber pod 
that has 40 features or i 

04:11:39.744 --> 04:11:43.153
nstalling a little sub speck of 
that pod that contains the three

04:11:43.154 --> 04:11:47.999
 features you are interested in,
 go for the sub speck. 

04:11:48.000 --> 04:11:52.417
We have structured our  pods to 
encourage that behavior.  You 

04:11:52.418 --> 04:11:55.062
will notice in the documentation
 for all of the CocoaPods we ask

04:11:55.063 --> 04:11:59.175
 you to install they are the 
individual sub specs that are 

04:11:59.176 --> 04:12:02.197
part of Firebase.  You have 
Firebase core which give yous

04:12:05.813 --> 04:12:09.237
 Analytics.  If you do try and 
pod Firebase in the hopes that 

04:12:09.238 --> 04:12:12.960
you are going to install this 
giant massive everything, that's

04:12:13.264 --> 04:12:17.601
 not going to work.  We just map
 that directly to Firebase/core.

04:12:19.310 --> 04:12:22.420
have to pod install every 
explicit feature that you are 

04:12:22.421 --> 04:12:27.854
interested in adding.  If you 
don't know about podtry, who 

04:12:27.855 --> 04:12:32.693
doesn't know about pod try.  
There is one or two people or 

04:12:32.694 --> 04:12:36.129
maybe everyone is afraid to 
raise their hand.  If you don't 

04:12:36.130 --> 04:12:39.342
know, it's a great way to try 
out any library that CocoaPods 

04:12:39.343 --> 04:12:45.246
has available.  It basically 
goes out and searches the 

04:12:45.247 --> 04:12:47.247
repository for a demo are or 
sample app 

04:12:48.303 --> 04:12:49.989
that it downloads to a temporary
 directory on the computer and 

04:12:49.990 --> 04:12:52.315
runs it. 
You can check out the library in

04:12:52.588 --> 04:12:55.652
 action in Xcode, play around 
with the code, see what happens 

04:12:55.653 --> 04:12:59.590
when you Tweet things without 
having to be like, gee, I wonder

04:12:59.961 --> 04:13:02.557
 what this does and you have to 
find the documentation and 

04:13:02.558 --> 04:13:05.853
sample file and download it and 
do the work manually.  So we 

04:13:05.854 --> 04:13:10.445
have made sure that all of our 
Firebase samples work with pod 

04:13:10.446 --> 04:13:15.277
try so give it a try. 
CocoaPods released version 1.0, 

04:13:15.278 --> 04:13:19.603
congratulations to the team if 
you are watching on  watching 

04:13:19.604 --> 04:13:22.731
online.  From an end user 
perspective not a lot has 

04:13:22.732 --> 04:13:26.953
changed for you with version 1.
0.  Hopefully there are very few

04:13:27.168 --> 04:13:29.457
 break annuals with your pod 
files unless you are d oing 

04:13:30.181 --> 04:13:33.214
something fancy.  The point of 
the release is it's a forward 

04:13:33.215 --> 04:13:35.910
looking release where the team 
is preparing for the future and 

04:13:35.911 --> 04:13:38.889
wants to make sure everything 
can scale and is production 

04:13:39.351 --> 04:13:42.060
ready.  We are excited to be a 
part of that. 

04:13:42.061 --> 04:13:45.589
But, granted, wherever I give 
this presentation there is one 

04:13:45.590 --> 04:13:49.000
developer in every crowd that is
 not happy with the idea of 

04:13:49.001 --> 04:13:54.887
CocoaPods.  There they are.  All
 right!  Don't worry, grumpy c 

04:13:54.888 --> 04:14:02.618
ats,  we love you to.  You can 
download the libraries without 

04:14:02.619 --> 04:14:05.295
CocoaPods.  What you are going 
to do is download this giant zip

04:14:05.296 --> 04:14:08.247
 file that is going to contain 
all of the frameworks available 

04:14:08.248 --> 04:14:13.388
and there is a step by step 
guidena says for every feature 

04:14:13.389 --> 04:14:17.899
if you want Firebase messaging 
you need to install A, B, C, D, 

04:14:17.900 --> 04:14:19.900
and Analytics, 

04:14:23.378 --> 04:14:26.072
, E and F.  So it takes a few 
manual steps but you can still 

04:14:26.073 --> 04:14:30.701
do it.  So don't w orry, cocoa 
pod haters, we still like you. 

04:14:30.702 --> 04:14:35.253
Show of hands if anyone was 
secretly hoping we would support

04:14:37.058 --> 04:14:41.569
 carthage instead?  Good to 
know.  Just gaging the interest 

04:14:41.570 --> 04:14:45.191
in the room.  I'm not making 
promises about future anything. 

04:14:45.192 --> 04:14:48.227
 We are almost all on modules 
now which is generally nicer 

04:14:48.228 --> 04:14:52.546
when you are importing things 
and importing is simple.  You 

04:14:52.547 --> 04:14:55.788
can import Firebase and this 
will import the headers for any 

04:14:55.789 --> 04:14:59.903
of the pods you have installed. 
 There is a lot of has include 

04:14:59.904 --> 04:15:04.244
magic going on underneath the 
hood that makes sure this works 

04:15:04.245 --> 04:15:08.267
which I know kind of sounds like
 the opposite of my hey only pod

04:15:08.352 --> 04:15:11.773
 install what you need advice 
that I gave you three slides a 

04:15:11.774 --> 04:15:13.389
go. 
Here you are not going to 

04:15:13.390 --> 04:15:17.520
increase the size of your app if
 you import  import Firebase and

04:15:18.622 --> 04:15:21.548
 import all of the Firebase 
features you have installed.  

04:15:21.549 --> 04:15:24.172
Maybe there will be a slight 
increase in compilation time but

04:15:24.382 --> 04:15:27.388
 I think it should be 
negligible.  And it makes 

04:15:27.389 --> 04:15:31.133
development very easy.  You sort
 of have import Firebase and any

04:15:31.311 --> 04:15:35.138
 feature you want to try should 
work without Xcode giving you an

04:15:35.480 --> 04:15:40.401
 error.  We have Bitcode support
 now.  So you can used Firebase 

04:15:40.402 --> 04:15:43.615
for your watching TV apps.  I'm 
sorry this took so long.  We 

04:15:43.910 --> 04:15:47.631
have a style guide n ow, an API 
review for all of our developer 

04:15:47.632 --> 04:15:50.856
libraries that are published as 
part of the Firebase platform so

04:15:51.038 --> 04:15:55.570
 you should start to see 
consistent class names across 

04:15:55.571 --> 04:15:58.209
Firebase which is good.  Not all
 of them are there yet.  You 

04:15:58.210 --> 04:16:02.034
know who you are.  But most of 
our features look consistent.  

04:16:02.035 --> 04:16:05.567
So almost all of our classes 
begin with FIR and for anything 

04:16:05.568 --> 04:16:08.397
that uses a single continue you 
will call it in the same way.  

04:16:08.398 --> 04:16:11.990
So the idea is once you got used
 to using a couple of features 

04:16:11.991 --> 04:16:15.028
in Firebase you should be able 
to guess how you would be using 

04:16:15.029 --> 04:16:17.148
some of the other features as 
well. 

04:16:17.149 --> 04:16:21.068
So let's talk briefly about what
 does happen when you create a 

04:16:21.069 --> 04:16:23.690
project in Firebase because you 
are going to go to the Firebase 

04:16:23.691 --> 04:16:27.323
console and you are going to say
 create a project and you will 

04:16:27.324 --> 04:16:31.661
wait a while and it will do 
magic for you.  Then you a 

04:16:31.938 --> 04:16:35.374
attach your iOS app and it will 
give you a key list file you 

04:16:35.375 --> 04:16:37.979
will download and drag into the 
Xcode project. 

04:16:37.980 --> 04:16:41.820
After you have done that, you 
are then going to call this one 

04:16:41.821 --> 04:16:46.158
magic call for app.configure 
which will set up everything 

04:16:46.159 --> 04:16:49.055
within Firebase for you no 
matter what feature you have for

04:16:49.682 --> 04:16:55.909
 you.  This configs it for you. 
 So what's going on?  When you 

04:16:55.910 --> 04:17:02.901
pre yate a fryer base in a 
console it will create auth 

04:17:02.902 --> 04:17:07.761
clients and pin up an interest 
of Firebase database to use and 

04:17:07.976 --> 04:17:10.005
Firebase storage bucket.  
Whether you plan on using them 

04:17:10.006 --> 04:17:13.494
or not, they are available on 
the back end to use and for each

04:17:13.836 --> 04:17:18.035
 thing it sets up, there is a 
constant available.  It will be 

04:17:18.036 --> 04:17:22.891
the address of the database or 
your auth client ID or Cloud 

04:17:23.502 --> 04:17:28.526
messenger, sender ID all gets 
put in the P list file so when 

04:17:28.527 --> 04:17:32.881
you drag it into your app and 
call for app.configure, it will 

04:17:32.882 --> 04:17:35.879
configure client libraries it 
sees installed in your app and 

04:17:35.880 --> 04:17:40.009
it will do that by dragging in 
all of the  constants that you 

04:17:40.010 --> 04:17:43.943
have put into the P list file.  
There is no more copying pasting

04:17:44.628 --> 04:17:48.763
 various IDs from the corn sole 
into combrur app..  You 

04:17:48.764 --> 04:17:51.306
shouldn't have to do any of that
 which is nice.  Let's talk 

04:17:51.307 --> 04:17:54.931
about this individual feature.  
I will start with Firebase 

04:17:54.932 --> 04:17:58.240
remote config.  This is a way 
for you to change the look and 

04:17:58.241 --> 04:18:00.055
feel of your app from the Cloud.

04:18:00.056 --> 04:18:04.078
When you release your app and 
you realize, oh, no, I have text

04:18:04.181 --> 04:18:08.613
 that's wrong or level 51 too 
hard or animation is taking way 

04:18:08.614 --> 04:18:13.847
too long if you have fired value
 to use remote config you can 

04:18:13.848 --> 04:18:16.672
update from the Cloud.  So you 
within the Cloud you will say 

04:18:16.673 --> 04:18:20.693
this is actually the value I 
want for my button text and your

04:18:21.397 --> 04:18:24.883
 Apple download the new values 
and it should be available in a 

04:18:24.884 --> 04:18:28.552
matter of minutes instead of 
having to go through let's 

04:18:28.553 --> 04:18:32.030
release new build and get it 
approved and published and have 

04:18:32.374 --> 04:18:34.883
everybody download the new 
version.  This happens not quite

04:18:35.721 --> 04:18:37.721
 instantaneously but pretty darn
 quick. 

04:18:38.116 --> 04:18:43.445
Generally speaking how remote 
config works on iOS you will set

04:18:44.052 --> 04:18:52.035
 up default values.  And then 
you are going to you will fetch 

04:18:52.036 --> 04:18:56.752
values from Firebase remote 
config.  These get  down loaded 

04:18:56.753 --> 04:19:01.270
and they get place in cached 
holding pattern on the device.  

04:19:01.271 --> 04:19:06.902
They don't get used until you 
call activate fetch.  When you 

04:19:06.903 --> 04:19:10.241
call activate fetch these values
 get installed on top of d 

04:19:10.242 --> 04:19:14.754
efaults.  So when you want to  
retrieve the value for the 

04:19:14.755 --> 04:19:18.062
individual settings you have got
 remote config will give you the

04:19:18.892 --> 04:19:21.382
 version downloaded or the 
default values you have s 

04:19:21.383 --> 04:19:24.333
upplied.  And I think the 
important thing to take away 

04:19:24.334 --> 04:19:27.896
from this is you don't have to 
supply new values for e 

04:19:27.897 --> 04:19:29.944
verything. 
What we would encourage you to 

04:19:29.945 --> 04:19:33.661
do is basically use remote 
config for any value that you 

04:19:33.662 --> 04:19:37.712
have in your app, any kind of 
magic number, any constant, any 

04:19:37.713 --> 04:19:40.823
text string, all of that stuff, 
everything you have got and all 

04:19:40.824 --> 04:19:46.067
of that, app contents.Swift file
 we have around.  This should be

04:19:46.565 --> 04:19:50.377
 set up to use remote config.  
Then when you want to change one

04:19:50.585 --> 04:19:54.302
 or two you are only supplying 
the deltas, only the stuff 

04:19:54.303 --> 04:20:00.053
that's changed  from remote 
config.  And you have f 

04:20:00.054 --> 04:20:02.867
lexibility to change values in 
the future without having to 

04:20:02.868 --> 04:20:04.868
supplies thousands of values 
every time

04:20:07.465 --> 04:20:07.833
 you want to fetch stuff remote 
config. 

04:20:07.834 --> 04:20:10.150
That's generally the way we 
recommend you use it.  In case 

04:20:10.151 --> 04:20:14.152
you are wondering what's up with
 that activate fetch call, why 

04:20:14.153 --> 04:20:17.085
not apply these values right 
away, generally speaking is 

04:20:17.086 --> 04:20:20.311
maybe you don't want your app 
changing mid run.  If you are 

04:20:20.312 --> 04:20:23.250
using remote config and using 
values to change the layout of 

04:20:23.251 --> 04:20:27.554
your buttons or change the text 
of your buttons it can be 

04:20:27.555 --> 04:20:31.003
awkward if that happens right 
when the user is in the middle 

04:20:31.004 --> 04:20:33.716
of using the app.  You don't 
know when the fetch call will be

04:20:33.914 --> 04:20:36.530
 complete and so we give that 
power to you as the developer.  

04:20:36.531 --> 04:20:39.755
There are a couple of strategies
 for how you can make use of t 

04:20:39.756 --> 04:20:42.759
his.  One is go ahead and 
activate the values as soon as 

04:20:42.760 --> 04:20:45.595
they are downloaded.  Maybe you 
don't care if the val so changed

04:20:45.596 --> 04:20:49.106
 in the middle of your app.  
Another option is put up a l 

04:20:49.107 --> 04:20:53.143
oading screen, block until l 
oad.  You will call fetch with 

04:20:53.144 --> 04:20:55.549
completion handler in your l 
oading screen.  Once the fetch 

04:20:55.550 --> 04:20:59.674
is complete, you will call 
activate fetch and compel the 

04:20:59.675 --> 04:21:04.325
loading screen to go away and 
put up your view controller and 

04:21:04.326 --> 04:21:07.957
start your app.  Maybe you add a
 time out in case things go w 

04:21:07.958 --> 04:21:11.378
rong.  So this has the advantage
 of you are going to get the 

04:21:11.379 --> 04:21:14.784
latest fresh values any time 
your user starts your app but 

04:21:14.785 --> 04:21:18.405
has the disadvantage of you now 
have a loading screen that you 

04:21:18.406 --> 04:21:21.044
have to look at. 
Maybe that's okay if you have 

04:21:21.045 --> 04:21:23.856
set up work happening in 
parallel, but maybe you want 

04:21:23.857 --> 04:21:28.806
your app to start faster.  So 
that's why I like this other 

04:21:28.807 --> 04:21:32.922
method which seems 
counterintuitive at first but is

04:21:33.328 --> 04:21:38.650
 neat, you call activate fetch 
as soon as your app starts up or

04:21:39.047 --> 04:21:45.020
 whatever enters the foreground.
  This will take previously 

04:21:45.021 --> 04:21:48.118
downloaded values and apply them
 on top of defaults.  Then you 

04:21:48.119 --> 04:21:51.664
will call fetch with completion 
handler and you will not 

04:21:51.665 --> 04:21:54.267
actually care about what happens
 234 the completion handler. 

04:21:54.470 --> 04:21:59.286
What you have done is you have 
values downloaded from the Cloud

04:21:59.599 --> 04:22:02.516
 sitting on your device ready to
 be applied the next time the 

04:22:02.517 --> 04:22:06.658
user starts the app.  Obviously 
this has advantage of being able

04:22:07.052 --> 04:22:10.262
 to start right away, but it 
does have the disadvantage of 

04:22:10.263 --> 04:22:15.400
you might be supplying slighting
 older values.  You could try a 

04:22:15.401 --> 04:22:18.727
hybrid approach where you are 
allowed to see when this last 

04:22:18.728 --> 04:22:22.958
remote config batch of data was 
downloaded and you can see is it

04:22:23.175 --> 04:22:26.393
 older than three days.  Maybe 
that's too old for my app so I 

04:22:26.394 --> 04:22:30.406
will put up a loading screen and
 fetch the new values, but if 

04:22:30.407 --> 04:22:33.846
it's more recent than three d 
ays, that's fine.  Side 

04:22:33.847 --> 04:22:37.501
discussion about localized text,
 every time I talk to people can

04:22:37.502 --> 04:22:42.710
 you use remote config for text,
 people are like, yes, that  

04:22:42.913 --> 04:22:46.629
sounds great, but I know I'm not
 supposed to we have all of 

04:22:46.630 --> 04:22:51.681
these best practices on the 
device for using the R.thing on 

04:22:51.682 --> 04:22:54.889
Android.  You want me to throw 
out the best praik is and use 

04:22:54.890 --> 04:22:58.001
remote config.  The actioner is 
you can't have the -- answer is 

04:22:58.002 --> 04:23:01.942
you can't have the best of both 
words..  NS localized striping 

04:23:01.943 --> 04:23:06.459
will provide the proper striping
 for the device the user is u 

04:23:06.460 --> 04:23:10.282
sing.  It will fall back to a 
default language if you don't 

04:23:10.283 --> 04:23:13.189
have the language available.  
You can take the localized 

04:23:13.190 --> 04:23:16.620
string value and pass into 
remote config as defaults.  What

04:23:17.034 --> 04:23:21.662
 ends up happening is for 
English  users you will have 

04:23:21.663 --> 04:23:24.982
English text and for French 
users you will have defaults 

04:23:24.983 --> 04:23:27.815
that contain French text.  When 
you realize that one of the 

04:23:27.816 --> 04:23:32.024
translations is not quite right 
and it's off, you can fix it in 

04:23:32.025 --> 04:23:35.041
remote config. 
You have the ability to create 

04:23:35.042 --> 04:23:39.878
conditions, and these basically 
are your way of telling remote 

04:23:39.879 --> 04:23:42.696
config please supply values to 
people who meet this condition. 

04:23:43.102 --> 04:23:45.594
 Sometimes it's a random subset 
of the audience, but often it 

04:23:45.821 --> 04:23:50.141
could be things like people 
whose device language happens to

04:23:50.345 --> 04:23:53.763
 be French.  You might create a 
condition for French speakers 

04:23:53.764 --> 04:23:58.108
and within remote config you 
would supply a new value for 

04:23:58.109 --> 04:24:02.226
that condition.  You would say 
my French speaker, this is the 

04:24:02.227 --> 04:24:06.145
value I will download.  For all 
other users the default value is

04:24:06.455 --> 04:24:10.493
 no value.  This tells remote 
configure go ahead and use 

04:24:10.494 --> 04:24:16.939
whatever default is supplied on 
the device.  So I don't need to 

04:24:16.940 --> 04:24:19.770
supply text for all of the other
 12 languages that maybe I'm 

04:24:19.771 --> 04:24:24.382
supporting in my app.  So this 
will end up just changing the 

04:24:24.383 --> 04:24:27.412
stored text only on devices 
where language is French. 

04:24:27.413 --> 04:24:31.630
So I'm still using NS localized 
string and following these best

04:24:34.656 --> 04:24:37.486
 practices.  So that's pretty 
good.  At least I think so.  In 

04:24:37.487 --> 04:24:40.693
summary, you can use remote 
config to adjust localized text.

04:24:40.694 --> 04:24:44.530
  Don't use it to dynamically 
localize all of your text in the

04:24:45.130 --> 04:24:48.594
 Cloud.  In theory you could do 
that and maybe it's a fun hack 

04:24:48.754 --> 04:24:53.173
but don't do it because you are 
downloading an entire language 

04:24:53.174 --> 04:24:57.327
pack from the Cloud every time 
and that's not cool.  You get a 

04:24:57.328 --> 04:25:00.550
disappointed looking emoji for 
that. 

04:25:00.551 --> 04:25:07.788
And you can use emogis in your 
remote config  strings.  I can't

04:25:08.606 --> 04:25:13.607
 guarantee its bullet proof. 
Let's move to Analytics.  I 

04:25:13.608 --> 04:25:16.532
might need to talk faster.  This
 is the backbone of what a lot 

04:25:16.533 --> 04:25:20.155
of Firebase is about.  There is 
not a lot to say on the client 

04:25:20.156 --> 04:25:24.004
side here.  You are basically, 
the A PI surface is small.  You 

04:25:24.005 --> 04:25:27.534
are logging events possibly with
 parameters and setting user 

04:25:27.535 --> 04:25:30.552
properties and that's about it. 
 So probably the most 

04:25:30.553 --> 04:25:33.566
interesting thing to note is 
that if you want to turn on 

04:25:33.567 --> 04:25:36.895
debug mode for Firebase 
Analytics, it's actually an 

04:25:36.896 --> 04:25:39.711
argument you pass i n.  So you 
have to go in and edit your 

04:25:39.712 --> 04:25:42.221
schemes and put this in.  I 
don't know why, but that's what 

04:25:42.222 --> 04:25:45.945
you have to do. 
And an important note about 

04:25:45.946 --> 04:25:49.075
testing.  Analytics data is not 
being sent all of the time.  

04:25:49.076 --> 04:25:52.886
Sort of as the way to keep, be 
respectful of your user's 

04:25:52.887 --> 04:25:56.707
battery life and that, we are 
not constantly streaming down 

04:25:56.708 --> 04:26:00.165
Analytics data.  That wouldn't 
be cool.  So instead we send 

04:26:00.549 --> 04:26:04.586
down Analytics data either if 
it's in an hour or when your app

04:26:04.682 --> 04:26:07.612
 goes into the background.  When
 you are testing this in Xcode, 

04:26:07.613 --> 04:26:11.445
you will try firing off 
Analytics events and then you 

04:26:11.446 --> 04:26:14.922
will hit stop and you will say 
how come none of my Analytics 

04:26:14.923 --> 04:26:17.902
data is making it.  Is something
 wrong?  The issue is if you hit

04:26:17.903 --> 04:26:23.718
 stop, your app quits before you
  it has a chance to send 

04:26:23.719 --> 04:26:29.053
Analytics data.  So if you test 
Analytics do command shift H and

04:26:29.347 --> 04:26:32.813
 hit the home screen on the 
device and that will give 

04:26:33.975 --> 04:26:35.599
Analytics time to send down to 
the servers. 

04:26:35.600 --> 04:26:41.829
I will talk about audiences.  
These are basically  groups that

04:26:42.035 --> 04:26:46.188
 you can define out of things 
you are recording in Firebase 

04:26:46.189 --> 04:26:49.380
Analytics.  This is people who 
have reached level 30 in my game

04:26:49.580 --> 04:26:56.113
 or women in Canada between the 
ages of 35 and 45 who have 

04:26:56.114 --> 04:26:58.673
visited my store but have not 
purchased anything yet.  They 

04:26:58.674 --> 04:27:04.600
can be as broad or narrow as you
 like.  As people use the app 

04:27:04.601 --> 04:27:08.323
Firebase Analytics will 
subscribe them to these a 

04:27:08.324 --> 04:27:11.735
udiences.  One other condition 
you can add for remote config is

04:27:12.009 --> 04:27:14.547
 does somebody belong in this 
audience?  You can change the 

04:27:14.548 --> 04:27:17.589
look and feel of the app for 
people who have reached level 30

04:27:17.924 --> 04:27:20.599
 in your game and sort of do all
 of that without having to touch

04:27:20.796 --> 04:27:23.945
 the code on your client which 
is kind of neat. 

04:27:23.946 --> 04:27:26.244
It's used for notifications and 
I will talk about that

04:27:30.182 --> 04:27:34.479
 later.  One important note 
about audiences is they are  not

04:27:34.978 --> 04:27:37.423
 retroactive.  People will 
create audiences and go and look

04:27:37.709 --> 04:27:44.050
 in Firebase Analytics ant the 
first question is why are they 

04:27:44.051 --> 04:27:46.363
empty?  You didn't do anything 
wrong.  The reason this is 

04:27:46.364 --> 04:27:49.390
happening is in order for us to 
give you  Analytics service that

04:27:49.502 --> 04:27:53.336
 is free and scales to thousands
 of apps, we have to distribute 

04:27:53.337 --> 04:27:56.440
some of the work onto the 
clients themselves.  So it's 

04:27:56.441 --> 04:27:59.441
actually the client that is 
going to be determining whether 

04:27:59.442 --> 04:28:01.360
it belongs to a particular 
audience or not. 

04:28:01.361 --> 04:28:07.408
So as people use your app, they 
will get subscribed to these 

04:28:07.409 --> 04:28:09.938
audiences by the client as they 
are using them.  If you think 

04:28:09.939 --> 04:28:12.842
you are going to be using the 
audience for something a few d 

04:28:12.843 --> 04:28:17.597
ays or weeks ahead of time, 
create audiences so they have a 

04:28:17.598 --> 04:28:22.442
chance to fill up and propagate 
as you go.  Let's move onto 

04:28:22.443 --> 04:28:24.443
Firebase crash reporting which I
 believe is

04:28:26.977 --> 04:28:30.670
 still in beta.  Not a lot to 
say here, you add in the 

04:28:30.671 --> 04:28:35.208
library, and then crashes get 
reported to Firebase. 

04:28:35.209 --> 04:28:38.832
Probably most interesting part 
here is you are going to add 

04:28:38.833 --> 04:28:41.772
this script into the build 
phases which uploads the  

04:28:41.959 --> 04:28:45.285
symbols file.  I think this is 
standard if you have used other 

04:28:45.286 --> 04:28:51.729
crash reporting tools but this 
deon fuse  indicate indicates 

04:28:51.730 --> 04:28:55.020
your stack trace.  So instead of
 something that looks like this,

04:28:55.345 --> 04:29:00.882
 where you are like maybe the 
problem is with method 474,525, 

04:29:00.883 --> 04:29:03.580
I should figure out what that i 
s, you get something that looks 

04:29:03.581 --> 04:29:06.708
like this where you can say oh, 
I guess the problem is with that

04:29:06.914 --> 04:29:11.147
 crash button was pressed 
method.  Why do I have this  

04:29:13.365 --> 04:29:16.489
method?  Make I should get rid 
of it.  So that's what happens 

04:29:16.490 --> 04:29:18.191
when you upload the symbols 
file. 

04:29:18.192 --> 04:29:20.192
When you want to test 

04:29:22.499 --> 04:29:23.643
crash reporting, it's a little 
tricky just that if your app 

04:29:23.644 --> 04:29:26.897
crashes and you are running in 
Xcode, Xcode will go in and 

04:29:26.898 --> 04:29:29.378
capture that in the debugger 
which is what you want.  If your

04:29:29.379 --> 04:29:31.804
 app is crashing while you are 
in the middle of development, 

04:29:31.805 --> 04:29:37.829
you want to be able to analyze 
what's going on right there 234 

04:29:37.830 --> 04:29:42.653
 in the debugger.  If you want 
to test that crash report is 

04:29:42.654 --> 04:29:45.990
working by running a crash on 
the app, run the app in Xcode, 

04:29:45.991 --> 04:29:50.295
make sure the latest version is 
on the device or simulator.  

04:29:50.296 --> 04:29:53.450
Then hit stop in Xcode, and then
 run again from the simulator of

04:29:53.636 --> 04:29:57.056
 the device and then generate a 
crash and you can run it one 

04:29:57.057 --> 04:30:01.080
more time and it's on the last 
run that Firebase crash 

04:30:01.081 --> 04:30:04.923
reporting will notice that your 
app crashed the previous time.  

04:30:04.924 --> 04:30:08.539
The last time you can run it in 
Xcode and you will see a console

04:30:08.849 --> 04:30:12.967
 message that says crash report 
finished uploading which is 

04:30:12.968 --> 04:30:17.492
nice.  A quick note on logging. 
So Firebase crash reporting also

04:30:17.784 --> 04:30:20.908
 allows you to record logs, 
report those directly to the 

04:30:20.909 --> 04:30:24.856
crash reporting tool so that in 
addition to getting a stack 

04:30:24.857 --> 04:30:27.469
trace for any crash you can see 
what your user was using right 

04:30:27.470 --> 04:30:30.983
up to the point where the app 
crashed so that you don't have 

04:30:30.984 --> 04:30:35.112
to, so you can analyze this and 
be like, wow, my user is using 

04:30:35.113 --> 04:30:40.359
my app in ways I did not expect.
  You can do this by explicitly 

04:30:40.360 --> 04:30:45.809
logging events to Firebase crash
 reporting eecialg with FIR 

04:30:45.810 --> 04:30:50.308
crash log, the first one reports
 to Firebase crass reporting.  

04:30:50.309 --> 04:30:53.117
The second spits out stuff to 
the console.  Maybe for some of 

04:30:53.118 --> 04:30:56.757
you doing more sophisticated 
logging like you have written 

04:30:56.758 --> 04:30:59.977
your own logging method you 
could be like that's great I can

04:31:00.592 --> 04:31:03.108
 report my log messages to crash
 reporting with a couple of 

04:31:03.109 --> 04:31:08.739
lines of code and voila, all are
 being reported to my crash 

04:31:08.740 --> 04:31:10.635
reporting.
&gt;&gt; Or if you are using cocoa 

04:31:10.636 --> 04:31:13.765
lumber jack you can say that's 
great, I can add in a logger 

04:31:13.766 --> 04:31:16.798
that will report to my crash 
reporting tool and everything I 

04:31:16.799 --> 04:31:21.035
log will get logged to Firebase 
crash reporting or whatever 

04:31:21.036 --> 04:31:24.027
crash tool I happen to be using.
  This is great but I want to 

04:31:24.028 --> 04:31:29.361
point out one cautionary tail 
that Doug and another def guy 

04:31:29.362 --> 04:31:32.790
pointed out is that you might be
 logging things that you are not

04:31:33.110 --> 04:31:36.906
 expecting to get reported to a 
crash reporting tool.  I print 

04:31:37.235 --> 04:31:41.471
out all sorts of debug info. 
I print out a lot of information

04:31:41.652 --> 04:31:45.790
 all of the time because I'm 
like, oh, I will see that while 

04:31:45.791 --> 04:31:49.013
debugging or it will stay local 
on the user's device.  If you 

04:31:49.014 --> 04:31:51.930
are suddenly magically with a 
couple of lines of code 

04:31:51.931 --> 04:31:53.830
reporting all of that 
information to the crash 

04:31:53.831 --> 04:31:56.061
reporting law where perhaps 
other people in your company can

04:31:56.253 --> 04:31:59.869
 see that because they have 
access to that panel, just make 

04:31:59.870 --> 04:32:02.100
sure you are not leaking 
information that you didn't 

04:32:02.101 --> 04:32:04.010
intend to. 
If you are currently using 

04:32:04.011 --> 04:32:07.140
another crash reporting tool and
 you have done this technique, 

04:32:07.141 --> 04:32:11.364
maybe go home and double check 
you are not doing this.  Just a 

04:32:11.365 --> 04:32:13.972
recommendation.  I will talk 
about dynamic links because I 

04:32:13.973 --> 04:32:17.016
think they are also kind of c 
ool.  These are basically links 

04:32:17.017 --> 04:32:20.915
that work the way you want them 
to on mobile devices.  So the 

04:32:20.916 --> 04:32:26.108
same link can take users to an 
Android app if they have it 

04:32:26.109 --> 04:32:28.099
installed or a iOS app.  If they
 don't have the app installed 

04:32:28.100 --> 04:32:30.406
they can take them to the 
appropriate place in the app 

04:32:30.407 --> 04:32:35.135
store or the play store and if 
you prefer you can take them to 

04:32:35.136 --> 04:32:40.086
a website instead if they don't 
have your app installed. 

04:32:40.087 --> 04:32:42.288
One of the big advantages of 
dynamic links is if you have to 

04:32:42.289 --> 04:32:45.494
take users to the app store 
first, all of that link 

04:32:45.495 --> 04:32:49.263
information doesn't get lost.  
You are basically Firebase 

04:32:49.450 --> 04:32:52.052
dynamic links can read in 
whatever link brought your users

04:32:52.266 --> 04:32:54.972
 to your app in the first place.
  That's generally good 

04:32:54.973 --> 04:32:57.991
information for you.  It's 
probably a really important 

04:32:57.992 --> 04:33:00.635
signal for like what did the 
user click on that made the them

04:33:01.117 --> 04:33:03.652
 so, you know, interested in 
your app that they had to 

04:33:03.653 --> 04:33:06.266
install it because you can then 
take the information and make 

04:33:06.267 --> 04:33:09.489
sure you are presenting relevant
 information to your user right 

04:33:09.490 --> 04:33:13.822
away instead of just a generic 
home screen.  So this is a 

04:33:13.823 --> 04:33:17.051
really good way to increase 
retention, I encourage you to 

04:33:17.052 --> 04:33:19.763
kind of look into these if you 
have email campaign or any other

04:33:20.081 --> 04:33:21.447
 way you are sharing your app 
through a link. 

04:33:21.448 --> 04:33:25.714
So one question I sometimes get 
is, okay, are dynamic links the 

04:33:21.448 --> 04:33:23.448
same as universal links and the 
answer is mostly

04:33:29.840 --> 04:33:33.760
 no but kind of yes a little 
bit.  You probably know about 

04:33:33.761 --> 04:33:37.091
universal links it's your way of
 telling IOS instead of opening 

04:33:37.092 --> 04:33:40.920
this link in Safari, if my app 
is installed open my app and 

04:33:40.921 --> 04:33:47.053
pass the link into it.  My Apple
  app app will read in the link 

04:33:47.054 --> 04:33:50.661
and know what important stuff it
 should be displaying.  And you 

04:33:50.662 --> 04:33:58.021
do this by  placing a little app
 site association on your 

04:33:58.022 --> 04:34:01.350
website it works great.  This is
 assuming you have a website 

04:34:01.351 --> 04:34:05.677
with content that mirrors what's
 in your app. 

04:34:05.678 --> 04:34:10.121
You could use dynamic links the 
same way, if the user clicks on 

04:34:10.122 --> 04:34:12.916
this link take them to my app 
and some other website, but 

04:34:12.917 --> 04:34:16.458
generally speaking most use them
 when they want to be more 

04:34:16.459 --> 04:34:21.013
aggressive about driving i 
nstalls.  If you are creating  

04:34:21.398 --> 04:34:24.919
an exquisite pay installer app. 
 It will take your user to the 

04:34:24.920 --> 04:34:27.726
app store, make sure they 
install your app and when they 

04:34:27.727 --> 04:34:31.265
open it for the first time it 
says you installed the app 

04:34:31.266 --> 04:34:34.896
because you are interest in cat 
facts here are cat facts right 

04:34:34.897 --> 04:34:40.186
away instead of  showing a 
generic sign-in screen.  Games 

04:34:40.187 --> 04:34:43.029
are other good example. 
There are a lot of games out 

04:34:43.030 --> 04:34:46.544
there that don't have c 
orresponding content on the 

04:34:46.545 --> 04:34:49.777
website.  If this is you and 
your website has a list of our 

04:34:49.778 --> 04:34:53.103
games and a jobs page, this is 
another option where dynamic 

04:34:53.104 --> 04:34:55.936
links could be helpful if you 
want to link to a particular 

04:34:55.937 --> 04:34:59.746
replay or a particular level or 
something like that within your 

04:34:59.747 --> 04:35:03.482
game.  So how do they talk to 
your app?  Basically two ways.  

04:35:03.483 --> 04:35:09.813
One way is custom URL schemes so
 you will add your bundle ID as 

04:35:09.814 --> 04:35:13.440
your custom URL scheme if you 
have done Google sign-in you 

04:35:13.441 --> 04:35:16.168
have done it before or if you 
saw my last presentation, this 

04:35:16.169 --> 04:35:18.896
is familiar to you. 
You will handle it in an open 

04:35:18.897 --> 04:35:23.826
URL call.  Within this open URL 
call, the full URL which is the 

04:35:23.827 --> 04:35:26.853
full dynamic link will pass into
 the dynamic links library and 

04:35:26.854 --> 04:35:31.272
you will say can you turn it 
into a dynamic link object?  And

04:35:31.466 --> 04:35:35.011
 you will get back the object 
which you can parse, analyze and

04:35:35.206 --> 04:35:39.335
 do whatever you need to respond
 to that link or you will get 

04:35:39.336 --> 04:35:45.680
back null in which case maybe as
 a Google  sign in URL or 

04:35:45.681 --> 04:35:47.681
Facebook sign in URL O

04:35:50.100 --> 04:35:50.300
 something like that.  And to 
get this working you will need 

04:35:50.301 --> 04:35:54.043
to turn on the associated 
domains capability and you will 

04:35:54.044 --> 04:36:02.177
need to make sure you add in 
this sub domain.app.G L@domain 

04:36:02.178 --> 04:36:04.763
basically as a domain your app 
can accept. 

04:36:04.764 --> 04:36:09.427
And this ABCDE will obviously be
 a code that is specific to your

04:36:09.624 --> 04:36:12.923
 project when you create it in 
the Firebase console.  Then you 

04:36:13.258 --> 04:36:16.896
will handle it the same way 
except that you will handle it 

04:36:16.897 --> 04:36:19.897
through the continual user 
activity method insteel of open 

04:36:19.898 --> 04:36:24.342
URL.  So you are saying I 
thought you told me dynamic 

04:36:24.343 --> 04:36:28.961
links aren't the same as 
universal links, what's the deal

04:36:29.167 --> 04:36:31.598
 1234?  We basically use 
universal links to send 

04:36:31.788 --> 04:36:34.803
information to your site when 
they click the dynamic link. 

04:36:34.804 --> 04:36:40.263
We create our own tiny website 
with sub domain.app got GL and 

04:36:40.658 --> 04:36:42.758
we host our own

04:36:46.060 --> 04:36:48.377
 app association site.  So it's 
completely up to you whether you

04:36:48.675 --> 04:36:52.216
 want to support yiewb versal 
dlirchgs on your own side.  

04:36:52.217 --> 04:36:55.833
Maybe you do, and that's fine.  
And maybe you don't and that's 

04:36:55.834 --> 04:36:58.666
also fine and maybe you don't 
have a website and that's okay 

04:36:58.667 --> 04:37:03.790
too.  It doesn't matter. 
So don't freak out about 

04:37:03.791 --> 04:37:06.604
universal links if you are like 
we haven't gotten around to 

04:37:06.605 --> 04:37:10.052
setting that up.  You don't need
 to.  You only need to make sure

04:37:10.329 --> 04:37:12.632
 your client is capable of 
receiving them which means t 

04:37:12.633 --> 04:37:17.392
urning on that one switch in the
 capabilities tab of Xcode.  One

04:37:17.590 --> 04:37:23.003
 last note on testing dynamic 
links.  You can't cut and paste 

04:37:23.004 --> 04:37:31.671
them into Safari.  Safari will 
act like your app is not 

04:37:31.672 --> 04:37:34.373
installed.  Instead what you 
want to do is paste them 

04:37:34.374 --> 04:37:38.611
directly into an app like notes 
and then you have the option of 

04:37:38.612 --> 04:37:41.925
editing these URLs if you want 
to try different things an see 

04:37:41.926 --> 04:37:45.264
what happens and if you long 
press on them you have the 

04:37:45.265 --> 04:37:47.683
option of whether you want to 
open them in the app or see what

04:37:47.892 --> 04:37:50.204
 happens if the link goes to 
Safari. 

04:37:50.205 --> 04:37:54.019
So you want to test the links, 
put them in notes and let iOS do

04:37:54.426 --> 04:38:02.680
 its magic.  I will move onto --
 15 anyone its.   15 minutes.  

04:38:02.681 --> 04:38:06.701
Firebase age let's you sign in 
or letting your user add in the 

04:38:06.702 --> 04:38:09.731
user name and password that 
Firebase manages for you so you 

04:38:09.732 --> 04:38:13.066
don't have to store pass words 
on your server.  Generally 

04:38:13.067 --> 04:38:18.198
speaking when you sign in, you 
will use something like Google, 

04:38:18.199 --> 04:38:22.133
Facebook, Twitter, and you will 
get back I think this is user 

04:38:22.134 --> 04:38:25.324
Google 1, 2, 3, and here is 
information you use to verify 

04:38:25.325 --> 04:38:28.350
it.  So you will send that 
information down to Firebase and

04:38:28.460 --> 04:38:33.906
 say this is Google user 1, 2, 
3, and Firebase will verify on 

04:38:33.907 --> 04:38:37.528
its end that this appears to be 
the user that you say, and then 

04:38:37.529 --> 04:38:40.673
basically once that's done, you 
will get back a Firebase user I 

04:38:40.674 --> 04:38:42.840
D. 
And you will be able to sort of 

04:38:42.841 --> 04:38:47.279
access this user as a Firebase 
user in the client.  And this 

04:38:47.280 --> 04:38:50.702
Firebase user looks the same for
 all users no matter how they 

04:38:50.703 --> 04:38:53.432
signed into your app.  You can 
treat this object basically the 

04:38:53.433 --> 04:38:57.544
same way and this user ID will 
be unique across all of the 

04:38:57.545 --> 04:39:02.921
different ciber  sign in 
providers.  You get a giant 

04:39:02.922 --> 04:39:06.708
random string that gets paired 
with the user I D so you can 

04:39:06.709 --> 04:39:11.159
verify on future visits and this
 is cached locally and all of 

04:39:11.160 --> 04:39:13.661
that done transparent to you, 
you don't have to care about 

04:39:13.662 --> 04:39:17.495
that, but this is nice because 
when the user comes back to the 

04:39:17.496 --> 04:39:21.203
device you don't need to sign 
them into Facebook, Google, 

04:39:21.204 --> 04:39:24.291
Twitter, et cetera.  You have 
the information on your device 

04:39:24.438 --> 04:39:29.518
locally to keep ciberring   
signing them in. 

04:39:29.519 --> 04:39:32.487
If you want to post things on 
Facebook or  You Tube you will 

04:39:32.488 --> 04:39:34.488
have to sign in to these other

04:39:38.431 --> 04:39:42.560
 services.  Firebase also s 
upports the idea of anonymous 

04:39:42.561 --> 04:39:46.295
auth which is basically pretty 
cool.  It allows you to sign in 

04:39:46.572 --> 04:39:52.508
the user anonymously.  You can 
tell Firebase I have  anonymous 

04:39:52.509 --> 04:39:55.642
user and it will give you back a
 Firebase user object and you 

04:39:55.643 --> 04:39:59.976
can let your user communicate 
with Firebase the they way 

04:39:59.977 --> 04:40:01.870
normally do.
&gt;&gt; At a future point if the user

04:40:01.871 --> 04:40:06.404
 says I will sign in with 
Facebook, you can tell Firebase 

04:40:06.405 --> 04:40:12.057
this anonymous user is also this
 fab  Facebook user, and 

04:40:12.058 --> 04:40:15.081
Firebase will link the accounts 
so if this the same user signs 

04:40:15.082 --> 04:40:17.496
in with Facebook on another 
device, they will get all of 

04:40:17.497 --> 04:40:20.505
this i nformation.  And we do 
the right thing where if this 

04:40:20.506 --> 04:40:23.438
user also happened to have 
created another anonymous 

04:40:23.439 --> 04:40:27.153
account on that other device and
 they say oh, yes, I'm also this

04:40:27.456 --> 04:40:32.887
 same Pheifer  Firebase will say
 it looks like you have two 

04:40:32.888 --> 04:40:35.794
accounts you want to associate 
with this account.  Let's give 

04:40:35.795 --> 04:40:42.261
you the information.  And the 
nice thing about the flow is it 

04:40:42.262 --> 04:40:46.173
lets you, it basically gives you
 the power to have your user use

04:40:46.359 --> 04:40:49.405
 the app and all of its features
 without forcing them in through

04:40:49.406 --> 04:40:53.425
 a s ign-in flow.  It's great 
for your users.  They often 

04:40:53.426 --> 04:40:56.650
don't want to sign in just to 
try the app.  They are sort of 

04:40:56.651 --> 04:40:59.573
much more vested in the process 
if they have tried it a bit and 

04:40:59.574 --> 04:41:02.999
they say I actually like this 
app now I'm willing to sign in. 

04:41:03.194 --> 04:41:07.517
 It's sort of, for you it makes 
the process easier to handle 

04:41:07.518 --> 04:41:11.338
that and Apple generally likes 
this approach as well.  They are

04:41:12.260 --> 04:41:16.468
 encouraging you to  can you 
have the user try out the app 

04:41:16.469 --> 04:41:21.014
without signing them into a sign
 in flow right away.  Try out 

04:41:21.015 --> 04:41:23.128
anonymous auth if you haven't.  
It's neat. 

04:41:23.129 --> 04:41:25.129
I will move

04:41:33.777 --> 04:41:37.099
 on.  Firebase app indexing 
which allows your app to show up

04:41:37.516 --> 04:41:41.741
 in Google searches.  So this is
 like universal links, and my 

04:41:41.742 --> 04:41:47.166
answer is, no, but also yes a 
bit.  So app indexing on iOS is 

04:41:47.167 --> 04:41:50.600
useful if you have universal 
links set up where those links 

04:41:50.601 --> 04:41:53.500
point to your app.  We have the 
website, you know, we have got 

04:41:53.501 --> 04:41:58.142
the website and the app and our 
Apple site association file that

04:41:58.940 --> 04:42:02.882
 sells iOS instead of opening 
links in Safari, open it up 

04:42:02.883 --> 04:42:06.189
directly in the app if it's 
installed.  And so what you can 

04:42:06.190 --> 04:42:10.735
do is basically through one call
 through app indexing, you can 

04:42:10.736 --> 04:42:14.670
let Google know that your app is
 using universal links.  This 

04:42:14.671 --> 04:42:23.241
parameter  that you are passing 
in is your app will iTunes.  ID.

04:42:26.336 --> 04:42:30.924
store ID is incase we need to 
grab information like your app 

04:42:30.925 --> 04:42:36.294
icon.  It let's Google know you 
are using universal links 

04:42:36.295 --> 04:42:38.922
installed on your site and you 
are okay with it reading that 

04:42:38.923 --> 04:42:40.920
file.
What happens is when your site 

04:42:40.921 --> 04:42:43.733
shows up in the search results, 
Google will look at the link and

04:42:43.734 --> 04:42:48.287
 say, wait, I know that link 
uses universal links.  And I 

04:42:48.288 --> 04:42:51.315
know the app is available on 
this device, so I know that this

04:42:51.509 --> 04:42:54.628
 link is not actually going to 
grow to a website.  It's going 

04:42:54.629 --> 04:42:59.769
to open in the app ininstead.  
It will change the look to look 

04:42:59.770 --> 04:43:04.395
a little more appy.  And then 
based on the assumption that you

04:43:04.592 --> 04:43:07.514
 have gone or your user has gone
 through the trouble of i 

04:43:07.515 --> 04:43:10.430
nstalling the app in the first 
place, that probably means they 

04:43:10.431 --> 04:43:12.431
are interested in the content of
 your app. 

04:43:12.961 --> 04:43:15.279
And, therefore, this search 
result might be a little bit 

04:43:15.280 --> 04:43:19.000
more relevant.  So you will 
often not always, no guarantees,

04:43:19.230 --> 04:43:23.345
 get a ranking boost because 
basically we now know that 

04:43:23.346 --> 04:43:28.374
things   this is going to an app
 that the user installed and is 

04:43:28.375 --> 04:43:31.483
interested in.  The other 
question is is this like core 

04:43:31.484 --> 04:43:35.401
spotlight and here the answer is
 no.  App indexing is more for 

04:43:35.402 --> 04:43:38.656
Web content that you might be 
searching for on Google and 

04:43:38.657 --> 04:43:41.951
letting Google know that those 
links will show up in your app 

04:43:41.952 --> 04:43:45.579
at well.  Core spotlight is 
letting spot light know you have

04:43:46.702 --> 04:43:49.818
 content available on the app in
 the device and people can use 

04:43:49.819 --> 04:43:53.230
it using spotlight. 
You can very clearly use both of

04:43:53.339 --> 04:43:55.767
 these if you feel they are 
appropriate for your app and you

04:43:56.281 --> 04:43:59.481
 probably should because you 
want your app to be 

04:43:59.482 --> 04:44:01.914
discoverable.  So let's talk 
about Firebase Cloud messaging 

04:44:01.915 --> 04:44:06.527
which is our one stop messaging 
solution for messaging on all 

04:44:06.528 --> 04:44:10.673
platforms.  The idea is you can 
use Firebase Cloud m essaging to

04:44:12.578 --> 04:44:13.782
 communicate with Android as 
well as route notifications 

04:44:13.783 --> 04:44:18.763
through APNS to stalk to iOS 
devices.  How does it work?  

04:44:18.764 --> 04:44:24.456
Here is the 90-second summary. 
Why would you want to do this?  

04:44:24.457 --> 04:44:27.088
Maybe that's a better question. 
 So basically part of the reason

04:44:27.280 --> 04:44:31.604
 is that you only have to write 
one code path.  You only have to

04:44:31.717 --> 04:44:34.320
 talk to one service.  So that 
gives you less code

04:44:37.654 --> 04:44:38.060
 to write.  There is less code 
in general.  I guess that's not 

04:44:38.061 --> 04:44:43.192
true because we have to write 
the code but you don't have to. 

04:44:43.581 --> 04:44:46.717
 There is other reasons, you can
 take advantage of services like

04:44:47.315 --> 04:44:50.435
 t opics, your clients can 
subscribe to various 

04:44:50.436 --> 04:44:52.768
notification topics about 
various subjects.  Your client 

04:44:52.769 --> 04:44:56.180
can say I'm interested in events
 happening in Texas and then if 

04:44:56.181 --> 04:44:59.901
you want to send a notification 
to everybody, you know, who is 

04:44:59.902 --> 04:45:03.238
interested in Texas events, you 
can do that without having to 

04:45:03.239 --> 04:45:07.250
write server side code.  You 
simply tell Firebase Cloud m 

04:45:07.251 --> 04:45:10.573
essaging, send this to people 
who subscribe to the Texas topic

04:45:10.778 --> 04:45:17.613
 and it will do that. 
It also lets you use Firebase 

04:45:17.614 --> 04:45:19.723
notifications panel which does 
make this whole process easier 

04:45:19.724 --> 04:45:23.145
and I will talk about in a 
minute because it is pretty c 

04:45:23.146 --> 04:45:26.360
ool.  All right.  Now, here is 
the 90 second summary of how 

04:45:26.361 --> 04:45:29.779
this works.  Generally speaking 
you will set up APNS and you 

04:45:29.780 --> 04:45:37.166
will have an APNS certificate 
you will use to talk to the 

04:45:37.167 --> 04:45:42.009
server.  You are going to upload
 APNS certificate to Firebase 

04:45:42.010 --> 04:45:46.433
cloud messaging.  It will 
associate it with the same app 

04:45:46.434 --> 04:45:52.040
associated with the API key.  
Assuming that your user has s 

04:45:52.041 --> 04:45:57.606
aid, yes, I would like to 
receive notifications, will send

04:46:03.844 --> 04:46:10.074
SAPNS .  So you will get back a 
Firebase Cloud messaging token 

04:46:10.075 --> 04:46:13.793
and it will hold onto a copy of 
the token and make sure it's 

04:46:13.794 --> 04:46:17.009
associated with the Firebase 
Cloud messaging token.  When you

04:46:17.296 --> 04:46:19.420
 then ask to send a 
notification, you will send it 

04:46:19.421 --> 04:46:23.962
with an API key and Firebase 
will confirm that, yes, it 

04:46:23.963 --> 04:46:29.684
matches your app. 
It will notice, hey, this 

04:46:29.685 --> 04:46:32.924
Firebase messaging device token 
is associated with an

04:46:35.937 --> 04:46:40.554
 APNS t oken.  I I'll take that 
APNS to talk to APNS and I will 

04:46:40.555 --> 04:46:44.182
take the token to identify the 
object I want to talk to and put

04:46:44.388 --> 04:46:49.545
 that in a new notification I 
will send to APNS and APNS ends 

04:46:51.437 --> 04:46:52.999
notice to your device.  Here is 
how you do that work on the 

04:46:53.000 --> 04:46:59.488
client side.  You do this.  So I
 am being a little fess E.   

04:47:00.000 --> 04:47:04.274
facetious.  You need to enable 
notifications in your t ab.  But

04:47:04.275 --> 04:47:07.547
 basically this call does all of
 the work needed on the client 

04:47:07.741 --> 04:47:12.909
to do that whole, h ey, let's 
request a token from APNS and 

04:47:12.986 --> 04:47:17.506
give it to Firebase Cloud 
messaging.  There are very 

04:47:17.507 --> 04:47:21.519
clever methods going on behind 
the scene that's hides these 

04:47:21.520 --> 04:47:25.659
details from you. 
At this point on your end 

04:47:25.660 --> 04:47:30.085
handling incoming messages are 
like handling incoming 

04:47:30.086 --> 04:47:32.301
notifications.  There is very 
little custom code you have to 

04:47:32.302 --> 04:47:35.430
write to get the app to work 
with Firebase code messaging.  

04:47:35.431 --> 04:47:40.762
Now that I have told you that, 
you will look at documentation. 

04:47:40.949 --> 04:47:44.591
I'll hold that thought.  I want 
to point out the first thing we 

04:47:44.592 --> 04:47:48.904
are asking you for or that we 
ask for is a silent n 

04:47:48.905 --> 04:47:51.039
otification.  That's important 
because as a developer, you want

04:47:51.323 --> 04:47:54.152
 to decide when you are going to
 ask for those more visible 

04:47:54.153 --> 04:47:57.778
notifications with the badges 
and sounds and what knot.  I 

04:47:57.779 --> 04:48:02.123
think apps used to ask for these
 on start up but users are like 

04:48:02.124 --> 04:48:07.232
why do you want to send me 
notifications and they will 

04:48:07.233 --> 04:48:10.467
decline in large numbers.  The 
best practice is for apps to say

04:48:10.668 --> 04:48:13.074
 we would like to send you 
notifications for these reasons,

04:48:13.288 --> 04:48:17.925
 doesn't that sound great?  And 
the user says that sounds 

04:48:17.926 --> 04:48:22.060
fantastic and you write the code
 to bring up the system 

04:48:22.061 --> 04:48:25.388
dialogue.  So don't worry, you 
can still do that using Firebase

04:48:25.686 --> 04:48:29.930
 Cloud m essaging. 
So you don't have to write 

04:48:29.931 --> 04:48:32.734
custom code to get Firebase 
Cloud messaging to work and then

04:48:35.655 --> 04:48:36.655
 you look at our documentation 
and you will see the custom code

04:48:36.656 --> 04:48:39.917
 to connect Firebase Cloud m 
essaging and you will say I 

04:48:39.918 --> 04:48:42.386
thought you said I didn't have 
to do any of this.  The answer 

04:48:42.387 --> 04:48:46.122
is you can also send messages 
through Firebase Cloud messaging

04:48:46.529 --> 04:48:49.728
 to your app if it is in the 
foreground without having to go 

04:48:49.729 --> 04:48:52.672
through APNS or in addition to 
going through APNS.  So why 

04:48:52.673 --> 04:48:58.099
would you want to do this?  
Mostly for redundancy. 

04:48:58.100 --> 04:49:04.254
It also turns out that Firebase 
cloud messaging tends to be more

04:49:04.739 --> 04:49:08.474
 aggressive about delivering 
medium priority messages, but 

04:49:08.475 --> 04:49:11.490
it's about redundancy.  What 
will happen within your app when

04:49:11.800 --> 04:49:16.221
 it goes into the foreground, a 
little trouble clicking here.  

04:49:16.222 --> 04:49:20.056
When your app goes into the 
foreground you will explicitly 

04:49:20.057 --> 04:49:23.681
connect to  to Firebase Cloud m 
essaging.  When your app goes 

04:49:23.682 --> 04:49:27.108
into the background you will 
explicitly disconnect.  That's 

04:49:27.604 --> 04:49:30.617
how Firebase Cloud messaging 
knows whether or not to use the 

04:49:30.618 --> 04:49:34.642
channel to communicate to your 
app.  The nice thing is  is 

04:49:34.643 --> 04:49:38.188
Firebase Cloud messaging does go
 through the process of deduping

04:49:38.779 --> 04:49:44.919
 messages for you so from your 
perspective p ks like you only 

04:49:44.920 --> 04:49:47.918
got un. 
The other thing we have 

04:49:47.919 --> 04:49:50.274
announced around notifications 
is the Firebase notifications 

04:49:50.275 --> 04:49:53.901
panel.  This makes it easier for
 non-technical members of your 

04:49:53.902 --> 04:49:57.211
team to send notifications.  
There will be times you will 

04:49:57.212 --> 04:50:00.731
need to write custom protocols 
and server logic and that stuff 

04:50:00.732 --> 04:50:04.083
but this does cover a lot.  
There are two things I want to 

04:50:04.084 --> 04:50:07.795
point out, the first is we can 
target audiences to receive 

04:50:07.796 --> 04:50:11.804
notifications so I can send a 
notification to people who have 

04:50:11.805 --> 04:50:14.539
bought stickers from my app 
store in the past and tell them 

04:50:14.540 --> 04:50:18.371
we have new categories of 
stickers, check them out.  And 

04:50:18.372 --> 04:50:21.793
we define conversion events so 
we can see how effective a 

04:50:21.794 --> 04:50:24.714
notification was.  Basically 
within Firebase Analytics if 

04:50:24.715 --> 04:50:28.122
there are important events you 
want to track like the user 

04:50:28.123 --> 04:50:31.921
making a purchase or subscribing
 to your newsletter or signing 

04:50:31.922 --> 04:50:35.575
up for a premium service or that
 sort of thing you would 

04:50:35.576 --> 04:50:38.600
identify those as conversion 
events and you can tell Firebase

04:50:39.106 --> 04:50:41.406
 notifications, hey, I would 
like to identify this conversion

04:50:41.620 --> 04:50:44.946
 event as this successful 
conclusion of this notification.

04:50:44.947 --> 04:50:47.806
  So for every notification you 
send you can see the number of 

04:50:47.947 --> 04:50:51.074
people it got sent to, the 
number of people who opened up 

04:50:51.075 --> 04:50:53.702
that notification or the number 
of devices because the person 

04:50:53.703 --> 04:50:56.834
could have multiple devices and 
then the number of times that 

04:50:56.835 --> 04:50:59.846
notification led to a conversion
 event.  That's really useful in

04:51:00.360 --> 04:51:03.184
 case you are wondering if 
notifications are being helpful 

04:51:03.185 --> 04:51:06.397
or not. 
Are they  being spammy or h 

04:51:06.398 --> 04:51:09.200
elpful to the users you are 
targeting.  You can look and see

04:51:09.201 --> 04:51:12.355
 how many are being opened, how 
many are being acted upon and it

04:51:12.356 --> 04:51:16.056
 can help you realize either I 
need to target my messaging more

04:51:16.543 --> 04:51:20.197
 or I am doing a good job.  So 
that was a lot of stuff to cover

04:51:20.482 --> 04:51:26.277
 and  I haven't covered a bunch 
of other  features yet like 

04:51:26.278 --> 04:51:31.951
Firebase storage and ad mob and 
normally at this point I would 

04:51:31.952 --> 04:51:35.702
be p roducing pli rout 85 which 
is my show on the You Tube 

04:51:35.703 --> 04:51:39.307
channel.  We started a brand new
 You Tube channel for Firebase 

04:51:39.308 --> 04:51:45.138
so it's called Firebase, but you
 can find it at You Tube.com/

04:51:45.367 --> 04:51:49.078
firebase where we will be 
hosting a bunch of screen casts 

04:51:49.079 --> 04:51:51.500
on how to get started with some 
of these features both on iOS 

04:51:51.501 --> 04:51:54.437
and A ndroid.  As we start 
building out libraries and 

04:51:54.438 --> 04:51:57.948
adding cool features and adding 
new stuff they might get added 

04:51:57.949 --> 04:52:02.164
pretty f ast, but that's okay, 
it keeps me in a job. 

04:52:02.381 --> 04:52:04.992
So if you want to find out m 
ore, this is where you find 

04:52:04.993 --> 04:52:07.654
Firebase.  This is where you get
 some nice help and support.  We

04:52:07.655 --> 04:52:11.333
 have got our You Tube channel, 
our Twitter feed and with one 

04:52:11.334 --> 04:52:14.278
minute remaining I will say 
thank you very much.  I will 

04:52:14.279 --> 04:52:18.306
take questions down here.  
Thanks!

04:52:18.705 --> 04:52:20.705
(Applause).

05:03:31.059 --> 05:03:33.059
Engagement.
May 19, 2016. 2PM PT.

05:09:29.099 --> 05:09:32.712
 (Applause). 
&gt;&gt; FABIAN SCHLUP: Hello, 

05:09:32.836 --> 05:09:36.493
everybody, thank you so much for
 come ing today to the session. 

05:09:36.494 --> 05:09:40.280
My name is Timo, I'm a product 
manager on Google Search. And 

05:09:40.281 --> 05:09:44.816
here with me, every       I have
 Fabian who is a software 

05:09:44.817 --> 05:09:49.524
engineer who works on app 
indexing. We're excited to talk 

05:09:49.525 --> 05:09:51.525
to all of you about app

05:09:54.406 --> 05:09:58.339
 indexing today. I'll start out 
of        out with a quick 

05:09:54.406 --> 05:09:56.473
overview of what app indexing is
 all about. How you can use 

05:09:56.474 --> 05:10:00.579
Google Search to get more active
 users and keep those users 

05:10:00.910 --> 05:10:04.127
engaged. Then Fabian's going to 
talk a little bit about how you 

05:10:04.128 --> 05:10:07.480
can get started with app index
ing.     

05:10:07.481 --> 05:10:11.181
We'll conclude with a very 
excite ing outlook of what we 

05:10:11.182 --> 05:10:14.967
are going to do later this year 
around personal content with a 

05:10:14.968 --> 05:10:20.708
couple of very excite ing demos.
 Every day, users come to Google

05:10:21.269 --> 05:10:24.879
 billions of times with 
information. And that happens in

05:10:24.880 --> 05:10:29.991
 many countries more often on 
mobile than on desktop. Now, 

05:10:29.992 --> 05:10:33.414
your app can be relevant to 
these billions of information 

05:10:33.415 --> 05:10:38.457
needs. Your app constantly can 
help all of these users suck 

05:10:38.458 --> 05:10:41.659
come to us            cumb to us
 with various needs they have. 

05:10:41.660 --> 05:10:44.464
Now, the question is, how can 
you actually connect your app 

05:10:44.632 --> 05:10:49.105
with all of those users and 
their needs? That's what we're 

05:10:49.106 --> 05:10:51.106
going to talk about today.

05:10:58.650 --> 05:11:03.265
indexing. You can get your app 
and its content into Google 

05:11:03.266 --> 05:11:06.106
Search. Acquire new users, yo uh
 can experience               

05:11:06.233 --> 05:11:09.064
       you can experience 
organic growth and keep the 

05:11:09.065 --> 05:11:11.709
users engaged. Now, one of the 
changes we've announced this 

05:11:11.710 --> 05:11:15.943
week is that app indexing is now
 part of Firebase. Firebase is a

05:11:17.053 --> 05:11:20.085
 suite of IPD     integrated 
products designed to help you 

05:11:20.086 --> 05:11:25.549
develop your app, grow user base
 and earn money.   

05:11:25.550 --> 05:11:30.352
App indexing is one of 15APIs 
that help you, the developers, 

05:11:30.353 --> 05:11:32.353
build amazing apps.

05:11:34.815 --> 05:11:39.133
 When      It can lead to more 
active users. Together, with 

05:11:39.398 --> 05:11:44.962
your app content and Google 
Search, we can delight all of 

05:11:44.963 --> 05:11:50.841
those users to come to Google 
for various needs. Who here is 

05:11:50.842 --> 05:11:53.742
familiar with app indexing? 
Awesome. It's a good number.   

05:11:53.743 --> 05:11:56.805
For those of you familiar with 
it, you'll find that Fabian has 

05:11:56.806 --> 05:12:00.537
a couple of interesting changes 
to announce. Now, for those of 

05:12:00.538 --> 05:12:04.032
you not familiar with it, don't 
worry about it . With Firebase, 

05:12:04.033 --> 05:12:06.485
you have all of the tools you 
need to get started at your 

05:12:06.486 --> 05:12:08.486
fingertips.

05:12:10.492 --> 05:12:12.815
 Next, let's talk about some of 
the products we've built to help

05:12:13.013 --> 05:12:16.978
 you grow your app and keep your
 users engaged. Let's start with

05:12:16.979 --> 05:12:21.811
 growth and installs through 
Google Search. Now, here as you 

05:12:21.812 --> 05:12:25.665
can see on the search results 
page, we can help you get your 

05:12:25.666 --> 05:12:30.113
app discovered. For very, you 
know, specific search intents 

05:12:30.114 --> 05:12:35.054
such as IO2016, we can show you 
results from apps such that you 

05:12:35.055 --> 05:12:38.935
can install that app. All I want
ed to do was install the app, 

05:12:39.102 --> 05:12:42.300
step on the green button, goes 
to the play store, you can 

05:12:42.516 --> 05:12:47.377
download and install the app.   
If I have more generic 

05:12:47.378 --> 05:12:54.159
information needs such as Google
 Apps or race ing games, . Now 

05:12:54.160 --> 05:12:59.598
you     we can also help rank 
these types of results better. 

05:12:59.599 --> 05:13:01.747
Now, having to install an app, 
though, creates a lot of 

05:13:01.748 --> 05:13:05.262
friction between users and their
 needs as well as, you know, 

05:13:05.263 --> 05:13:12.047
your app content. Now, yesterday
, a something was announced  

05:13:12.048 --> 05:13:14.593
ed   d excite ing, on the       
 it's an amazing new experience 

05:13:14.710 --> 05:13:16.710
that keeps

05:13:19.278 --> 05:13:23.659
 user -- now instead of having 
to download a   an app first, go

05:13:23.868 --> 05:13:25.976
 right into the app where you 
can find all of the information 

05:13:25.977 --> 05:13:29.089
that they need.   
Now, this will ultimately reduce

05:13:29.283 --> 05:13:33.704
 this barrier that stands 
between the user and your app 

05:13:33.705 --> 05:13:35.705
content.

05:13:37.928 --> 05:13:41.346
 Next, let's talk a little bit 
about ENL     engagement and how

05:13:41.347 --> 05:13:44.383
 Google Search can help you with
 that. Once an app is installed,

05:13:44.384 --> 05:13:50.849
 we can organically open in your
 app. A search for IO schedule, 

05:13:50.850 --> 05:13:53.477
you can see it as a result from 
the app, all I have to do now is

05:13:53.855 --> 05:13:57.191
 tap on it and goes right into 
the app where I find all of the 

05:13:57.192 --> 05:14:01.585
information that I need. For app
 indexing, again, you can -- we 

05:14:01.586 --> 05:14:03.754
can help you rank those results 
better on the

05:14:07.836 --> 05:14:11.187
 search results page.   
With the Google App, we've put 

05:14:11.188 --> 05:14:15.281
the power at the user's 
fingertips with the search box 

05:14:15.282 --> 05:14:17.282
on many

05:14:18.560 --> 05:14:20.238
 android phones on the home 
screen. Tap on the search box, 

05:14:20.239 --> 05:14:27.718
type it in and they're good to 
go. Earlier today, I looked up 

05:14:27.719 --> 05:14:31.893
various sessions in the IO app. 
My own session included. If I 

05:14:31.894 --> 05:14:34.591
want to get back to that session
, all I have to do is type in 

05:14:34.592 --> 05:14:37.922
rules, which is the title of the
 talk. And I see the results 

05:14:37.923 --> 05:14:42.646
appear here while I type in the 
Google App. When I type into 

05:14:42.647 --> 05:14:47.235
this, it goes back into the app 
where it can find all of the 

05:14:47.236 --> 05:14:49.236
information such as

05:14:50.510 --> 05:14:52.705
        .   
Now, the Google App helps re

05:14:52.912 --> 05:14:56.197
engage users with the app 
content for those       

05:14:56.198 --> 05:14:59.876
thousands of apps. And it's easy
 for users to get back in. 

05:14:59.877 --> 05:15:03.422
Because all they have to do is 
tap on the search box and tell 

05:15:03.423 --> 05:15:07.575
us what they're looking for. 
Now, besides the search results 

05:15:08.896 --> 05:15:13.023
page and the Google App, Google 
brings your app con at the 

05:15:13.024 --> 05:15:18.139
present time to users'          
                         content

05:15:18.140 --> 05:15:22.184
 to the user's fingerprints. A 
new movie "Captain county       

05:15:22.185 --> 05:15:25.001
 America" that I should check 
out. Now all I have to do is 

05:15:25.002 --> 05:15:29.042
press the home button and get 
more information through Google 

05:15:29.043 --> 05:15:36.182
Now. Here, I get "Captain 
America," and a couple of app 

05:15:36.183 --> 05:15:41.223
results, as well. These apps are
 use ing App indexing. If I tap 

05:15:41.224 --> 05:15:43.224
on

05:15:47.411 --> 05:15:51.277
 the result, it goes into the 
app where I find all of the 

05:15:47.411 --> 05:15:49.719
information that I need. It's an
 amazing feature because it puts

05:15:49.720 --> 05:15:52.804
 your app content    tent 
anywhere where they are on 

05:15:52.805 --> 05:15:54.805
android.

05:16:01.166 --> 05:16:04.383
little bit. More than 10,000 
apps are use ing app indexing to

05:16:04.647 --> 05:16:08.725
 grow their app and keep the 
users engaged. But it includes 

05:16:08.726 --> 05:16:12.384
most of the top apps that users 
use every single day all over 

05:16:12.385 --> 05:16:21.023
the world. It translates to more
 than 200 billion app results 

05:16:21.024 --> 05:16:26.046
and a truly amazing number. 
Let's look at some of the 

05:16:26.181 --> 05:16:31.684
success stories of partners that
 are use ing app indexing. 

05:16:31.685 --> 05:16:33.685
Increase on CTR by almost 5% for

05:16:37.074 --> 05:16:43.349
 app results, access on increase
 in daily ad traffic almost 12%.

05:16:43.350 --> 05:16:49.669
 And increased transaction value
 by 200%.    are some truly 

05:16:49.670 --> 05:16:54.482
amazing numbers that tell you 
how important app indexing is 

05:16:54.483 --> 05:16:57.841
for these partners and that any 
app should use this technology 

05:16:57.842 --> 05:17:02.849
to grow the user base and keep 
the users engaged. Now, with 

05:17:03.304 --> 05:17:07.761
that, I'm handing it over to 
Fabian to tell you how you need 

05:17:07.762 --> 05:17:10.077
to get started. 
&gt;&gt; FABIAN SCHLUP: Thank you, 

05:17:10.078 --> 05:17:14.062
Timo. So let's talk about what 
you need to do and how you can 

05:17:14.063 --> 05:17:17.245
get started enable ing the the
     great features that we saw 

05:17:17.246 --> 05:17:21.865
working for Europe. And as Timo 
outlined, the key is really to 

05:17:21.866 --> 05:17:25.873
get your app into the google 
search index. Once it's in 

05:17:26.138 --> 05:17:29.436
there, we can then surface 
results for your app in great 

05:17:29.437 --> 05:17:34.036
places, like, Google Search, now
 on tap, the autocomplete 

05:17:34.037 --> 05:17:36.844
feature. And we can bring YURS  
    users right into the 

05:17:36.845 --> 05:17:40.966
relevant screen in your app.   
Over the last year, it's 

05:17:40.967 --> 05:17:44.344
actually gotten quite a bit 
easier to index apps. That's 

05:17:44.345 --> 05:17:46.759
something we're really excited 
about it. And you'll see that in

05:17:46.882 --> 05:17:51.274
 a moment when I step through. 
There's three basic rules that 

05:17:51.275 --> 05:17:53.275
you want to follow if you want 
to get

05:17:56.087 --> 05:17:59.173
 this engagement and growth for 
your app. First, your app needs 

05:17:59.174 --> 05:18:01.174
to

05:18:02.235 --> 05:18:04.226
 support URLs so you can link 
right into the right place. 

05:18:04.227 --> 05:18:08.100
Second, you need to call our API
 so we can better understand the

05:18:08.310 --> 05:18:12.818
 content in your app. And three,
 you want to make sure you can 

05:18:13.096 --> 05:18:15.892
keep an eye on, you know, the im
pact you're getting from 

05:18:15.893 --> 05:18:19.476
following the first two rules, 
right? How many more active 

05:18:19.477 --> 05:18:22.157
users you're        you're gett
ing and if there's still room 

05:18:22.158 --> 05:18:25.750
for improvement optimization in 
your app to get even more out of

05:18:25.751 --> 05:18:31.366
 it. We'll step through this one
 by one in a second starting 

05:18:31.367 --> 05:18:35.778
with supporting URLs. Let's do a
 quick show of hands, who here 

05:18:35.779 --> 05:18:41.282
has an app or worked on an app 
that supports URLs? Oh, great, 

05:18:41.283 --> 05:18:44.589
about half. And how many of you 
have worked on app indexing 

05:18:44.590 --> 05:18:47.062
specifically? So getting your 
app into the index?

05:18:51.121 --> 05:18:56.770
 All right. Cool. Excellent. So 
let's talk about URLs first. UR

05:18:57.033 --> 05:19:01.792
Ls were invented for the web, 
right? So websites support URLs 

05:19:01.793 --> 05:19:06.064
naturally. You have different 
web pages. Each one comes with 

05:19:06.065 --> 05:19:10.370
their own URL. And that's what 
you see in the address bar at 

05:19:10.371 --> 05:19:13.105
the top of the browser. But for 
apps, it's a little less natural

05:19:13.534 --> 05:19:18.533
 to support URLs. And we really 
have to think about and write 

05:19:18.534 --> 05:19:22.060
specific codes to actually 
handle URLs in the apps and make

05:19:22.213 --> 05:19:25.580
 sure the right screen comes up 
when your app is started with a 

05:19:25.581 --> 05:19:30.340
URL.    important           
important to do that, right? 

05:19:30.341 --> 05:19:33.188
Because when we want to find 
relevant content for our users, 

05:19:33.189 --> 05:19:37.259
we don't want to just send them 
to your app, launch the app, but

05:19:37.456 --> 05:19:40.362
 take them straight to the right
 place. So this is really one of

05:19:41.110 --> 05:19:43.110
 the building blocks of app 
indexing.

05:19:46.212 --> 05:19:49.977
 Next, you know, there's a 
question of if you have a URL 

05:19:49.978 --> 05:19:53.017
like the one on screen here, how
 do you actually know there's an

05:19:53.018 --> 05:19:56.775
 app that can handle this type 
of URL? How do you know this 

05:19:56.776 --> 05:19:59.492
might potentially link into an 
app? And how do you find out 

05:19:59.493 --> 05:20:01.493
what that app might be?

05:20:06.473 --> 05:20:10.118
the website with the app or with
 a set of apps that can also 

05:20:10.366 --> 05:20:15.984
show that content. And it turns 
out in the web, we have a very

05:20:16.400 --> 05:20:19.590
      very similar challenge 
where a web browser needs to 

05:20:19.591 --> 05:20:21.591
find out

05:20:24.014 --> 05:20:27.180
 what web server to get the web 
page you want to look at. When 

05:20:27.694 --> 05:20:30.582
you type a URL into a browser, 
the browser uses something 

05:20:30.695 --> 05:20:35.325
called the domain name system or
 DNS to result the domain name 

05:20:35.326 --> 05:20:41.015
into an IP address which tells 
it what server to talk to. 

05:20:41.016 --> 05:20:43.824
That's worked really well for 
the web. And over the last year,

05:20:44.000 --> 05:20:46.022
 we've seen a similar system 
being established for 

05:20:46.244 --> 05:20:50.898
resolve ing a domain name into a
 mobile app. And actually, it's 

05:20:50.899 --> 05:20:57.269
two systems. One for android and
 one for I   iOS. They work 

05:20:57.270 --> 05:21:01.181
similarly. Almost identically. 
And I'll step through exactly ho

05:21:01.704 --> 05:21:03.647
      ly   ly it works in a 
moment.   

05:21:03.648 --> 05:21:09.425
What they do the systems is they
 allow you to create a 

05:21:09.426 --> 05:21:11.781
connection, linking from your 
website to the app and basically

05:21:12.400 --> 05:21:15.286
 declare ing, hey, this is the 
app or set of apps that can 

05:21:15.581 --> 05:21:20.412
handle my URLs. And also, the 
other way around, have the app 

05:21:20.591 --> 05:21:25.216
declare what are the kinds of UR
Ls I can handle. And with this 

05:21:25.418 --> 05:21:30.695
two-way connection, that's what 
helps us understand the space. 

05:21:30.696 --> 05:21:33.690
So let's look at how the     
this specifically works on 

05:21:33.691 --> 05:21:39.372
androids and then I'll go into i
OS second. And I'll continue to 

05:21:39.546 --> 05:21:43.869
use the IO app. Because many of 
you might have that installed on

05:21:44.065 --> 05:21:46.317
 your phone today and you can 
check out some of these things 

05:21:46.318 --> 05:21:49.478
right after the session 
yourself. And then, also, we'll 

05:21:49.479 --> 05:21:54.464
be publishing the source code 
for the IO app for     after the

05:21:54.465 --> 05:21:57.399
 conference so you can see the 
implementation behind all of 

05:21:57.400 --> 05:22:01.670
this.   
So every Ann destroyed      

05:22:01.800 --> 05:22:06.056
         android app has 
something, here's an example of 

05:22:06.057 --> 05:22:10.215
the I   man any fest,  
       NI        manifest, and 

05:22:10.216 --> 05:22:13.439
that's where it declares that it
 can handle any URL in the 

05:22:13.440 --> 05:22:18.391
domain, events Google to come, 
and that starts with the path I

05:22:18.985 --> 05:22:25.159
O2016/schedule/anything. And 
then, there's the little 

05:22:25.160 --> 05:22:29.712
attribute that you can see auto 
verify equals true. That's a new

05:22:30.380 --> 05:22:35.772
 attribute from level 23 that 
tells us that we have this two-

05:22:36.038 --> 05:22:38.768
way connection set up. Meaning 
that the system can go talk to 

05:22:38.769 --> 05:22:42.257
the website and the website will
 very      verify and confirm 

05:22:42.258 --> 05:22:47.403
that, in fact, this is the app 
that               S   that it 

05:22:47.404 --> 05:22:52.278
wants its URLs to link into. And
 also, if you have this 

05:22:52.279 --> 05:22:56.652
attribute. What you'll actually 
get starting from android 6.0 

05:22:56.653 --> 05:22:59.734
marshmallow, your app will be 
set as the default handler for 

05:22:59.735 --> 05:23:03.168
these types of URLs right when 
it's installed.  

05:23:03.169 --> 05:23:07.428
That means that even the first 
time a user taps on the URL 

05:23:07.429 --> 05:23:10.700
anywhere on the phone, the 
message ing app or web or 

05:23:11.014 --> 05:23:13.130
anywhere, they'll be taken 
straight to your app, and they 

05:23:13.131 --> 05:23:17.247
won't get the dialogue that you 
might know that will ask you if 

05:23:17.248 --> 05:23:20.633
you want to open this in the 
browser or in this app. So 

05:23:20.634 --> 05:23:23.085
that's another great benefit you
 get

05:23:26.939 --> 05:23:29.739
 there.   
But for any of this to work, the

05:23:26.939 --> 05:23:29.194
 service side has to also check 
out, right? The other connection

05:23:29.363 --> 05:23:34.483
. The other side of the 
connection. So how this works is

05:23:34.916 --> 05:23:36.916
 you host 

05:23:38.659 --> 05:23:42.227
a small predefined path on your 
website that defers back to

05:23:46.720 --> 05:23:50.653
 the app by package name and 
certificate fingerprints. And 

05:23:46.720 --> 05:23:48.846
that part is really important, 
right? The google,       GOOG

05:23:49.276 --> 05:23:53.160
      Google to understand that 
it's okay to link results from 

05:23:53.161 --> 05:23:56.976
search for these types of URLs 
directly into this app. That's 

05:23:56.977 --> 05:24:01.377
something we don't want to do 
unless we know the website owner

05:24:01.378 --> 05:24:04.432
 actually wants this traffic to 
go into this particular app, 

05:24:04.762 --> 05:24:08.327
right? Instead of the website. 
On

05:24:11.768 --> 05:24:17.662
 the IOS side, we have something
 called entitlements. As part of

05:24:18.114 --> 05:24:22.572
 the app itself. And, again, 
that's where you would refer to 

05:24:22.573 --> 05:24:26.133
the domain for which the app can
 handle URLs. And on the service

05:24:26.281 --> 05:24:30.171
 side, again, a small chase on 
file. Different one, but similar

05:24:30.435 --> 05:24:36.947
 in spirit where you point back 
to the IOS app by iTUNZ    TUNZ

05:24:37.456 --> 05:24:44.353
       I-TUNZ        iTunes ID. 
I do no    know an interesting 

05:24:44.354 --> 05:24:50.368
difference between the Io    io 
OS and android system, the path 

05:24:50.369 --> 05:24:53.704
prefix that defines the set of U
RLs the app can handle is define

05:24:53.918 --> 05:24:58.892
d with the server side 
configuration file on iOS. While

05:24:59.237 --> 05:25:02.406
 on androids, this is part of 
the app i   itself in the SBEPT

05:25:03.199 --> 05:25:06.479
       intent filter.   
Now you've got this two-way 

05:25:06.480 --> 05:25:08.612
connection set up and of course,
 you have to write the codes to 

05:25:08.613 --> 05:25:11.103
actually bring up the right 
screen and so forth in your app.

05:25:11.104 --> 05:25:14.745
 And I'm not going to into      
go into details about that right

05:25:14.896 --> 05:25:17.471
 here. But at least now we have 
a clear system for finding the 

05:25:17.658 --> 05:25:21.482
right app to link into just give
      given the URL. But until 

05:25:21.803 --> 05:25:24.899
recently, actually, many of us 
have still been use ing custom U

05:25:25.071 --> 05:25:29.475
RLs. And let me give you an 
example of what I mean. By 

05:25:29.476 --> 05:25:37.145
custom URLs, custom keep      
scheme. Not HD  DRKS     DDP.

05:25:40.334 --> 05:25:41.493
 These are broken in several 
ways. I want to take a moment to

05:25:41.494 --> 05:25:43.938
 try to discourage you from use
 ing these as much as possible, 

05:25:43.939 --> 05:25:49.444
if you can at all help it. One 
of the issues here is that we do

05:25:49.643 --> 05:25:52.423
 not have the system here, 
right? Where we can somehow re

05:25:52.728 --> 05:25:56.103
liablely resolve any        
       ly    y resolve any part 

05:25:56.104 --> 05:25:58.835
of this to an app. It's not 
clear which app this should link

05:25:58.836 --> 05:26:02.632
 into. And then also, it really 
doesn't work across platforms. 

05:26:02.633 --> 05:26:06.315
So if you want to share this URL
 with a friend, send them a 

05:26:06.316 --> 05:26:10.797
message or post this in social 
media. You can't really, right? 

05:26:10.798 --> 05:26:14.372
Because if your friend opens 
this on the mobile computer, on 

05:26:14.373 --> 05:26:17.506
desk top computer, rather, then 
that's not going to do anything 

05:26:17.507 --> 05:26:21.581
on a desktop computer. And so in
 these cases, you still have to 

05:26:21.582 --> 05:26:25.094
send a web URL which works 
anywhere because it opens the 

05:26:25.095 --> 05:26:29.585
web page. But then, if your 
friend does receive it on a 

05:26:29.586 --> 05:26:32.152
mobile device, then now that's 
not going to go into the app, 

05:26:32.153 --> 05:26:35.592
right? Even if they have the app
 installed. Now you would have 

05:26:35.593 --> 05:26:39.943
to translate from the web URL to
 the custom URL and now you'd 

05:26:39.944 --> 05:26:44.612
have to have some sort of map
ping table or translation rule. 

05:26:44.613 --> 05:26:52.295
So long story short, by use ing 
web URLs, HDDPURLs s, you can 

05:26:52.296 --> 05:26:54.586
sidestep a lot of the headaches.
 And that's what I would 

05:26:54.587 --> 05:27:02.510
recommend.    your app does 
support HDP URLs. Now you're 

05:27:02.511 --> 05:27:07.061
ready to test. And if you want 
to test your app many ice LAX

05:27:07.412 --> 05:27:11.976
      solation, maybe UCHT      
you haven't gotten the service 

05:27:11.977 --> 05:27:15.867
side launched yet. You can 
launch your app with a view 

05:27:15.868 --> 05:27:20.021
intent and passing the URL you 
want to test out. And that 

05:27:20.022 --> 05:27:22.245
should launch your app and get 
you straight to the right screen

05:27:22.519 --> 05:27:26.787
 if if    you've done everything
 right. And once you've got the 

05:27:27.043 --> 05:27:29.116
connection in both ways 
established, if you have the

05:27:32.425 --> 05:27:37.859
 little file for android or iO, 
S or both deployed on the 

05:27:38.203 --> 05:27:41.210
website . The easiest way is 
probably to send yourself a 

05:27:41.211 --> 05:27:44.710
bunch of URLs in an email or 
something and tap on them on 

05:27:44.711 --> 05:27:46.711
your device

05:27:48.383 --> 05:27:50.383
. And then that should go 
straight into the right screen.

05:27:54.913 --> 05:27:58.138
you know, that is required for 
your results to start showing up

05:27:58.328 --> 05:28:02.761
 on Google. It might still take 
a day TWOR      or two for us to

05:28:02.762 --> 05:28:05.217
 pick it up and start showing 
the results to users. In the 

05:28:05.218 --> 05:28:07.218
meantime, what you can do,

05:28:09.554 --> 05:28:13.820
 check out the brand new preview
 tool. You can find this as part

05:28:09.554 --> 05:28:12.403
 of the documentation. We 
LAUMPLGed it      ed            

05:28:12.404 --> 05:28:15.481
launched it earlier this week. 
You can enter any of your URLs 

05:28:15.482 --> 05:28:19.287
and we'll instantly show you a 
preview of how your results are 

05:28:19.288 --> 05:28:22.512
going to look like on mobile for
 your users. That's kind of cool

05:28:22.729 --> 05:28:30.218
.   
So with that, let's go on to the

05:28:30.618 --> 05:28:38.797
 next slide and talk about the 
second rule. Calling the API. As

05:28:39.026 --> 05:28:41.272
 a user uses your app and 
browses the con at the present 

05:28:41.273 --> 05:28:44.039
time in                       t
ent in your app, you can call 

05:28:44.196 --> 05:28:47.376
the API with the URL and the 
title of the current screen. And

05:28:47.811 --> 05:28:50.621
 that helps us better        
better understand how your app 

05:28:50.622 --> 05:28:54.489
works and what content is 
important to users. And that can

05:28:54.490 --> 05:28:57.511
 actually also be an interesting
 signal for us to help rank 

05:28:57.512 --> 05:29:03.054
these results on Google Search. 
And another place where this is 

05:29:03.055 --> 05:29:09.001
really important is the auto-
complete feature that Timo 

05:29:09.002 --> 05:29:10.815
showed you earlier. Here we have
 limited real estate on the 

05:29:10.816 --> 05:29:16.782
screen. We can fit a max of five
 or six results max. So we want 

05:29:16.783 --> 05:29:20.301
to show only the most relevant 
results. And so, in this case 

05:29:20.302 --> 05:29:23.779
here, just knowing that I've 
looked at my own SKEGS       

05:29:24.750 --> 05:29:26.750
session before in the I

05:29:29.281 --> 05:29:29.768
O app, that's a strong signal 
for us that there's, you know, a

05:29:29.769 --> 05:29:32.733
 lot of high likelihood I want 
to get back there, right? That's

05:29:33.049 --> 05:29:37.126
 important content for me. And 
that's what we would show in 

05:29:37.436 --> 05:29:39.436
auto-

05:29:40.571 --> 05:29:40.880
E KPLOO       complete. And with
 one tap, I'll be right back in 

05:29:40.881 --> 05:29:45.205
the app.   
And in terms of the code we ask 

05:29:45.206 --> 05:29:47.590
you to add for this, it should 
be fairly minimal.

05:29:51.978 --> 05:29:54.995
 It can basically be three lines
 per activity or per time of 

05:29:54.996 --> 05:30:00.123
screen you have. The first one 
is constructing the URL for the 

05:30:00.124 --> 05:30:02.124
current session. Again, this is 
the example from

05:30:05.271 --> 05:30:07.774
 the IO app. Second, putting 
together the action object with 

05:30:07.775 --> 05:30:11.898
a title and the URL that 
describes what is happening. And

05:30:12.276 --> 05:30:15.546
 you see that we use the view 
action here. We also support 

05:30:15.832 --> 05:30:20.393
other action types such as 
listen or purchase or bookmark 

05:30:20.579 --> 05:30:23.766
depending on what it is the user
 does. But viewing will be one 

05:30:23.929 --> 05:30:31.230
of the more common ones.   
And then third, you call the 

05:30:31.231 --> 05:30:33.745
start method to indicate that 
the action is now starting. And 

05:30:33.746 --> 05:30:38.124
there's a corresponding end 
method, as well, that would be 

05:30:38.125 --> 05:30:40.895
called by the IO app as you 
navigate away from the session 

05:30:40.896 --> 05:30:43.792
detail screen, again. And if you
 have instantaneous actions in 

05:30:43.793 --> 05:30:46.315
your app, like, you know, 
bookmarking something or 

05:30:46.316 --> 05:30:50.328
purchase ing something, then you
 can just call the end method 

05:30:50.329 --> 05:30:53.934
straight away and be done with 
it.   

05:30:53.935 --> 05:30:58.974
And to make it, you know, as 
simple as possible to do this, 

05:30:58.975 --> 05:31:04.048
we've added to the studio one of
 the things the studio will do. 

05:31:04.049 --> 05:31:07.035
It'll tell you if there's any 
issues with, both your 

05:31:07.036 --> 05:31:09.036
implementation 

05:31:15.951 --> 05:31:19.951
of URL support in general or 
your implementation of calling 

05:31:15.951 --> 05:31:18.702
the API. It'll also help you 
generate the codes, and also 

05:31:18.703 --> 05:31:23.645
most of the intent filters. And 
then you can also test right 

05:31:23.646 --> 05:31:28.429
from within Android Studio. We 
have a feature where we can 

05:31:28.430 --> 05:31:30.430
simulate

05:31:32.119 --> 05:31:37.004
 with a given URL and Android 
Studio will show you which 

05:31:37.005 --> 05:31:41.846
parameters and     for API and a
 little preview of that page in 

05:31:41.847 --> 05:31:49.173
your app. On the iOS side, the A
PI is simpler and more limited 

05:31:49.174 --> 05:31:52.735
currently. We ask that you add a
 single call when the app starts

05:31:53.805 --> 05:31:55.839
 up to register the app

05:32:01.839 --> 05:32:03.839
 on the device.   
And so now you already essential

05:32:03.952 --> 05:32:08.424
ly know everything there is to 
get your app into the index. And

05:32:08.732 --> 05:32:11.454
 now, you really want to make 
sure it actually worked, right? 

05:32:11.455 --> 05:32:14.295
And you're actually getting more
 active users and you want to 

05:32:14.296 --> 05:32:17.969
see if there's any issues or 
maybe what you can optimize to 

05:32:17.970 --> 05:32:21.652
get even more out of this. One 
thing you definitely want to do 

05:32:21.653 --> 05:32:23.734
is track refer traffic.

05:32:29.573 --> 05:32:31.573
 Through google      GOOG  

05:32:33.685 --> 05:32:34.786
 How many users use through 
Google. And a way to make this 

05:32:34.787 --> 05:32:42.603
simpler or to make it simpler 
for you, we've added this method

05:32:42.935 --> 05:32:47.407
. A little over a year ago with 
level 22. And you can think of 

05:32:47.408 --> 05:32:53.887
it SLAer to the              
similar to the HDP header. It 

05:32:53.888 --> 05:32:58.145
tells you where the user is come
 ing from in terms of URL. If a 

05:32:58.327 --> 05:33:00.327
user's come 

05:33:01.805 --> 05:33:04.634
ing from Google.com in a web 
browser, then the refer will be 

05:33:05.312 --> 05:33:08.985
Google.com. And if the user's 
come ing in through the Google 

05:33:09.657 --> 05:33:13.141
app, which could be any 
autocompletions or now on tap 

05:33:13.142 --> 05:33:20.219
all of these things, then the UR
L would be the second URL. The 

05:33:20.220 --> 05:33:25.261
Android dash app notation is a 
way we use to put both a package

05:33:25.262 --> 05:33:29.926
 name and the URL inside the app
 into one URL.

05:33:33.265 --> 05:33:38.665
 So if your traffic is not come
 ing from any of these to 

05:33:38.937 --> 05:33:41.938
reverse, you know the user came 
in through Google, and you can 

05:33:42.088 --> 05:33:45.474
log it through your analytic 
solution. If you don't have an 

05:33:45.475 --> 05:33:48.368
analytics solution yet, by the 
way, you might have heard about 

05:33:48.369 --> 05:33:54.558
this new offering launched 
yesterday, Firebase analytics 

05:33:54.559 --> 05:33:58.131
which offers unlimited reporting
 for free your app, that might 

05:33:58.132 --> 05:34:02.489
be a strong candidate to 
consider here. ' And then from 

05:34:02.490 --> 05:34:05.726
our                       
And from our side, we offer 

05:34:05.727 --> 05:34:09.627
analytics. We have a tool called
 search console, and you can 

05:34:09.628 --> 05:34:12.846
verify that you own a given app.
 And then we'll show you metrics

05:34:13.543 --> 05:34:17.609
 on, you know, how many results 
are we showing for your app? How

05:34:17.610 --> 05:34:20.830
 many clicks are these results 
getting? And also, how many 

05:34:20.831 --> 05:34:22.908
installs are happening          
 happening as a result of people

05:34:23.372 --> 05:34:30.196
 that are discovering your app 
on Google Search? And that's 

05:34:30.197 --> 05:34:35.662
basically it.   
Make sure to support URLs, and 

05:34:35.663 --> 05:34:40.405
many of you already do. Second, 
call the app indexing API so we 

05:34:40.406 --> 05:34:42.785
can better understand the 
content and we can better rank 

05:34:42.786 --> 05:34:48.362
your results. And if you already
 support URLs in your apps, this

05:34:48.363 --> 05:34:50.388
 is really the only rule you 
have to follow in addition, 

05:34:50.389 --> 05:34:56.203
basically. And then three, make 
sure to log into the search 

05:34:56.204 --> 05:34:59.291
console to see if you have any I
 guess         issues and to see

05:34:59.497 --> 05:35:02.636
 the benefits that you're 
getting and what you might 

05:35:02.637 --> 05:35:06.755
potentially be able to optimize.

05:35:06.756 --> 05:35:08.756
You can find all of 

05:35:11.490 --> 05:35:13.621
this and more. But before you do
 that, I'm going to give it back

05:35:13.940 --> 05:35:18.013
 to Timo for the excite ing last
 part. 

05:35:18.014 --> 05:35:21.100
&gt;&gt; TIMO MERTENS: Thank you so 
much, Fabian. I hope everything 

05:35:21.214 --> 05:35:24.204
           everybody knows a 
little more now what it takes to

05:35:24.205 --> 05:35:28.320
 get your app and its content to
 Google Search. Now, we'd like 

05:35:28.321 --> 05:35:29.890
to talk about something very 
special that's going to come 

05:35:29.891 --> 05:35:34.574
later this year that resolves 
around personal content         

05:35:34.709 --> 05:35:37.252
                     volves 
around personal content. So far,

05:35:37.405 --> 05:35:40.647
 we've talked about how to get 
your public app content to 

05:35:40.648 --> 05:35:43.923
Google Search to grow your user 
base and keep your users engaged

05:35:44.074 --> 05:35:47.477
. But every day, users all over 
the world interact with or 

05:35:47.478 --> 05:35:49.822
KREAKT        create a lot of 
personal information whether 

05:35:49.823 --> 05:35:55.152
that's messages that you send or
 receive, documents you create, 

05:35:55.153 --> 05:35:58.302
play lists you listen to or 
photos that you take. Now, all 

05:35:58.530 --> 05:36:01.485
of that data is really important
 for many, many different user 

05:36:01.486 --> 05:36:06.888
needs. For example, wouldn't it 
be amazing if you could find 

05:36:06.889 --> 05:36:10.782
that message from a best friend 
who talked about an awesome 

05:36:10.783 --> 05:36:14.622
sushi place. Wouldn't it be 
great to find a shopping list 

05:36:14.623 --> 05:36:18.597
when I'm at the grocery store? 
Wouldn't it be awesome if I 

05:36:18.598 --> 05:36:21.841
could just get back to that play
list before my Sunday morning 

05:36:21.842 --> 05:36:25.239
run?   
No, your app content can help 

05:36:25.240 --> 05:36:29.019
with many of these different 
user needs. And that's why we're

05:36:29.198 --> 05:36:32.212
 excited to announce today that 
later this year we're going to 

05:36:32.213 --> 05:36:36.485
let your index personal content 
on android. We're going to ex

05:36:37.645 --> 05:36:40.981
tend app indexing to let users 
find anything in their apps 

05:36:40.982 --> 05:36:46.685
through the Google App.   
Now, when we design this 

05:36:46.686 --> 05:36:51.389
addition to app indention    
   dexing, we follow three core 

05:36:51.390 --> 05:36:54.767
principles. Which are privacy 
control and simplicity. First of

05:36:54.892 --> 05:36:57.828
 all, personal app content stays
 on the device and doesn't leave

05:36:58.140 --> 05:37:03.038
 the phone. It means, we will 
search the data on the phone. 

05:37:04.427 --> 05:37:07.576
Next, you as the developer will 
be in crop of the life cycle of 

05:37:07.577 --> 05:37:12.212
that data. You determine when it
 gets indexed, updated or remove

05:37:12.384 --> 05:37:14.384
d.

05:37:17.946 --> 05:37:22.365
 Finally in regards             
 ly   ly, advance once more. 

05:37:22.366 --> 05:37:25.669
There you go. Fabian explained 
how easy it is right now to get 

05:37:25.670 --> 05:37:28.162
the con at the present time to 
google      GOOG      Google 

05:37:28.163 --> 05:37:31.952
Search, a few lines of code and 
keep it as simple as that. Just 

05:37:32.153 --> 05:37:34.539
a few lines of code and your 
personal content will be indexed

05:37:34.724 --> 05:37:38.193
 on the phone.   
Now, let's look at some of the 

05:37:38.194 --> 05:37:41.496
cool experiences that we could 
actually enable with that 

05:37:41.497 --> 05:37:43.497
addition.

05:37:46.009 --> 05:37:48.009
 Some very special partners.

05:37:56.110 --> 05:38:03.085
 All right. Fair enough. So my 
friend Henry sent me a message 

05:38:03.086 --> 05:38:05.923
before telling me about a great 
session I should check out on 

05:38:05.924 --> 05:38:10.124
Friday. Totally forgot the title
 for it. Let's see if we can go 

05:38:10.292 --> 05:38:15.181
back to that. All we have to do 
is tap on the search box here. 

05:38:15.182 --> 05:38:20.632
Tap on the search box. And all 
we have to do is type the name.

05:38:24.071 --> 05:38:30.789
 I don't know if we can adjust 
the -- we're good with time. 

05:38:30.790 --> 05:38:32.790
We've got a few minutes.

05:38:51.589 --> 05:38:54.417
use the device itself. 
&gt;&gt; TIMO MERTENS: Excellent. 

05:38:54.418 --> 05:38:56.776
&gt;&gt; FABIAN SCHLUP: Better? 
&gt;&gt; TIMO MERTENS: Is that better?

05:39:04.166 --> 05:39:06.166
 No? Maybe? A little bit?

05:39:16.825 --> 05:39:18.825
 A little darker still.

05:39:25.923 --> 05:39:31.001
 How many developers does it 
take to fix it?

05:39:34.300 --> 05:39:38.413
 We need more people on stage, 
apparently, to fix this. 

05:39:38.414 --> 05:39:39.752
&gt;&gt; FABIAN SCHLUP: Maybe you 
could talk through what happened

05:39:39.753 --> 05:39:40.312
. 
&gt;&gt; TIMO MERTENS: All right. 

05:39:40.313 --> 05:39:42.034
&gt;&gt;      
&gt;&gt; FABIAN SCHLUP: People have 

05:39:42.035 --> 05:39:45.467
seen the auto-complete feature. 
Just close your eyes and -- 

05:39:45.468 --> 05:39:48.354
&gt;&gt; TIMO MERTENS: Imagine. That's
 right. What I wanted to do was 

05:39:48.558 --> 05:39:51.324
find a message from my Henry was
 talking about this session I 

05:39:51.325 --> 05:39:56.296
should check out. All we have to
 do is demonstrate, type the 

05:39:56.297 --> 05:39:58.297
name in the search box. And 
normally you

05:40:02.315 --> 05:40:06.448
 see completions for that. And 
instead what we will show is a 

05:40:02.315 --> 05:40:05.819
contact card for the contact as 
well as a message from that app.

05:40:05.971 --> 05:40:11.673
 In this case, Henry sent the 
message. And all we would have 

05:40:11.674 --> 05:40:15.225
to do is tap on the result and 
goes right into the app. And can

05:40:15.226 --> 05:40:19.546
 then read the message in that 
conversation. And now that seems

05:40:19.813 --> 05:40:21.840
 to be better.

05:40:28.021 --> 05:40:30.390
&gt;&gt; TIMO MERTENS: We just go for 
it and you have          you 

05:40:30.391 --> 05:40:34.153
have to imagine you see the 
things on ZBREEN        screen. 

05:40:34.154 --> 05:40:35.801
&gt;&gt; FABIAN SCHLUP: We'll do it 
like this. Thank you. 

05:40:35.802 --> 05:40:38.215
&gt;&gt; TIMO MERTENS: Once more. 
Let's try this one more time. 

05:40:39.372 --> 05:40:45.466
Henry and --   
(Laughter). 

05:40:45.467 --> 05:40:48.222
&gt;&gt; TIMO MERTENS: You see an icon
 over there, that's a good start

05:40:48.452 --> 05:40:50.943
. Just tap on the results and we
 go right into the app.

05:40:58.947 --> 05:41:02.192
 And a little purple, that's 
good. But anyway, Henry's tell

05:41:02.309 --> 05:41:06.967
ing me to check out Google's 
vision tomorrow morning at 9:00 

05:41:07.275 --> 05:41:11.864
a.m.. Sounds like a great talk 
you should totally check out.   

05:41:11.977 --> 05:41:15.920
Now, this is going to be really 
tricky. But -- all right. We 

05:41:16.049 --> 05:41:19.921
need to go down a little bit to 
see what else. There you too    

05:41:19.922 --> 05:41:25.238
 see the vision. Going into the 
next one. If we got back to the 

05:41:25.544 --> 05:41:30.095
home screen, now -- by the way, 
who went to the concert last 

05:41:30.096 --> 05:41:35.439
night? Awesome. It was amazing, 
wasn't it? Now, we happen to go,

05:41:35.610 --> 05:41:38.569
 as well. And Fabian sent me a 
message, actually, with a video 

05:41:38.570 --> 05:41:42.208
he took. Now, all we have to do 
is search for Fabian and see 

05:41:42.209 --> 05:41:49.636
there's a message in glide      
 Glyde, LETSZ see if        

05:41:49.761 --> 05:41:54.635
      , let's see if we can play
 that back. Looks like a lot of 

05:41:54.636 --> 05:42:00.621
fun. Awesome.   
Now, going back to the previous 

05:42:00.622 --> 05:42:05.043
message, tomorrow morning, 9:00 
     9:00 a.m., I remember I had

05:42:05.044 --> 05:42:08.219
 breakfast planned with Adam. 
Let's try to find the message, 

05:42:08.220 --> 05:42:12.468
I've totally forgot the time. 
Then we tap on it, search for 

05:42:12.629 --> 05:42:17.158
Adam. 
&gt;&gt; FABIAN SCHLUP: Adam. 

05:42:17.159 --> 05:42:19.915
&gt;&gt; TIMO MERTENS: There it is. 
The message in linkedin. Tap on 

05:42:20.398 --> 05:42:23.168
it, jump right into it. And 
there       there we go. 8:00 

05:42:23.169 --> 05:42:25.169
a.m. on Friday. Thank you.

05:42:29.724 --> 05:42:32.778
 Now 8:00 a.m., I guess I have 
to get up earlier tomorrow. Fair

05:42:32.779 --> 05:42:37.617
 enough. I love eating yogurt 
for breakfast. The other day I 

05:42:37.618 --> 05:42:41.736
started reading an article call
ed how yogurt affects the brain 

05:42:41.737 --> 05:42:45.675
that I never finished reading, 
but I did save that one and     

05:42:45.676 --> 05:42:48.876
in pockets. Now if I want to go 
back to it, all I have to do is 

05:42:48.877 --> 05:42:54.606
type in part of the title and we
 can tap on it and goes      it 

05:42:54.607 --> 05:42:56.297
goes right into the app where I 
can go ahead and read it on my 

05:42:56.298 --> 05:43:01.001
way home tonight. Thank you, 
Fabian. Sorry for the technical 

05:43:01.002 --> 05:43:03.861
difficulty ies.   
Now, these examples really show 

05:43:03.862 --> 05:43:12.378
the power of that data and user 
needs. Through the Google App, 

05:43:12.569 --> 05:43:15.750
we can let users find everything
 in their apps with their 

05:43:15.751 --> 05:43:17.457
personal life with their 
personal data or through the 

05:43:17.458 --> 05:43:20.885
Google App by tapping on the 
search box, type ing in a few 

05:43:20.886 --> 05:43:23.971
characters and they see your app
 content right there. And all of

05:43:23.972 --> 05:43:28.166
 this will be powered through 
App Indexing later this year.   

05:43:28.298 --> 05:43:32.798
Now, here are the partners we've
 worked with in the early access

05:43:33.048 --> 05:43:35.137
 program. They've done an 
amazing job in and able ing the 

05:43:35.138 --> 05:43:39.139
experiences and         
              e ing             

05:43:39.140 --> 05:43:41.358
 enable ing these services. If 
you're interested in this, have 

05:43:41.359 --> 05:43:44.021
a look at this link here and 
share your interest with us 

05:43:44.022 --> 05:43:47.811
later this year. We will follow 
up with more information or 

05:43:47.812 --> 05:43:52.247
availability of this extension 
of app indexing. Now, quick 

05:43:52.248 --> 05:43:57.226
summary, we showed that with App
 Indexing, you can get more app 

05:43:57.227 --> 05:44:01.885
users, grow your app, drive 
reengagement all through these 

05:44:03.079 --> 05:44:06.537
various search features, such as
 the search results page or 

05:44:06.538 --> 05:44:09.408
instant apps. Fabian explain LD 
three              PLAN 

05:44:10.125 --> 05:44:12.911
   plained three simple rules 
that's all it takes and later 

05:44:12.912 --> 05:44:16.439
this year, you'll see some 
really cool features around 

05:44:16.440 --> 05:44:20.523
personal con at the present time
                    tent.   

05:44:20.524 --> 05:44:24.333
Now, here's more information 
about both app indexing as well 

05:44:24.334 --> 05:44:29.925
as Firebase, come check with us.
 We're happy to talk more with 

05:44:29.926 --> 05:44:33.070
all of you. And with that, thank
 you all so much for come ing. 

05:44:33.513 --> 05:44:36.629
We hope you're as excited about 
getting your app into search as 

05:44:36.630 --> 05:44:40.357
we are. Thank you.   
(Applause) 

05:44:45.003 --> 05:44:48.698
   time for questions if anybody
 has some. 

05:44:48.699 --> 05:44:51.310
&gt;&gt; FABIAN SCHLUP: Yeah. 
&gt;&gt; TIMO MERTENS:    

05:44:53.180 --> 05:44:55.597
&gt;&gt; TIMO MERTENS: Go ahead. 
&gt;&gt; I love it, it's great. I've 

05:44:55.598 --> 05:44:58.652
been implementing it in all of 
my apps. Through the 

05:44:58.792 --> 05:45:01.133
personalization, looks like you 
can add more content besides the

05:45:01.134 --> 05:45:04.768
 title. That's like one of the 
largest features that's missing 

05:45:04.769 --> 05:45:08.598
compared to core spotlight 
search. And it seems like you 

05:45:08.737 --> 05:45:11.961
guys are addressing that for 
personal. Seems like since the 

05:45:12.465 --> 05:45:16.349
Google App could just update and
 you can update the SDK, are we 

05:45:16.350 --> 05:45:18.508
going to see that for 
nonpersonal? Rile      Right 

05:45:18.998 --> 05:45:22.042
now, just icon, icon, icon. It'd
 be lovely to see your beautiful

05:45:22.386 --> 05:45:26.413
 faces when I look for App 
indexing and then a tiny icon, 

05:45:26.414 --> 05:45:30.567
per se, so they know what app it
 is. Is that stuff in the works 

05:45:30.714 --> 05:45:33.479
or all in the personal stuff? 
&gt;&gt;      

05:45:33.480 --> 05:45:35.971
&gt;&gt; TIMO MERTENS: Overall, we are
 expanding on the features that 

05:45:35.972 --> 05:45:40.447
will highlight con at the 
present time. You just saw an 

05:45:40.448 --> 05:45:42.853
early stage integration, but 
there's much more to come later 

05:45:42.962 --> 05:45:46.563
this year. 
&gt;&gt; Okay. That was very vague. 

05:45:46.564 --> 05:45:48.636
&gt;&gt; TIMO MERTENS: Talk later. 
&gt;&gt; FABIAN SCHLUP: Maybe I can 

05:45:48.637 --> 05:45:52.294
and     add that, yes, showing 
more interesting, engage ing, 

05:45:52.544 --> 05:45:55.105
richer results is something we 
think about. For personal 

05:45:55.263 --> 05:45:57.519
content, that's -- we're going 
to have to, you know, we're 

05:45:57.520 --> 05:46:00.200
going to need your help for you 
to actually provide us some of 

05:46:00.201 --> 05:46:03.878
that data through the API and 
for, you know, for the more 

05:46:03.879 --> 05:46:07.667
public content that we have 
today. We actually don't want 

05:46:07.668 --> 05:46:11.372
you to make us pass more 
information or we don't want you

05:46:11.373 --> 05:46:15.656
 to have to do more work. We 
have more information of more 

05:46:15.657 --> 05:46:17.657
rich results we could show.

05:46:32.716 --> 05:46:38.489
&gt;&gt; Hi, so I had a question about
 turning on and off app 

05:46:38.490 --> 05:46:42.315
indention       dexing. You can 
do that for personal content. 

05:46:42.316 --> 05:46:47.183
But can you do that for web 
content for the classic search 

05:46:47.184 --> 05:46:51.817
indexing? 
&gt;&gt; FABIAN SCHLUP: Your question 

05:46:51.818 --> 05:46:55.418
is as an app owner, can you turn
 on or off

06:08:13.986 --> 06:08:14.056
ommunication accessibility and 
may not be a totally verbatim 

06:08:14.057 --> 06:08:16.323
record of the proceedings.
********

06:08:14.282 --> 06:08:17.465
   &gt;&gt; There we go.

06:08:23.413 --> 06:08:26.649
  Good afternoon.  Welcome to 
Firebase notifications.

06:08:31.555 --> 06:08:36.698
     (laughter) In this session,
 I'm Francesco, I'm going to 

06:08:37.185 --> 06:08:39.185
introduce why we believe that 
notifications are important.  

06:08:39.622 --> 06:08:44.023
Later on, Tingmui, 
our project manager will come on

06:08:44.024 --> 06:08:48.245
 stage and introduce what we 
have built so that you can use 

06:08:48.246 --> 06:08:50.895
notifications effectively.  And 
finally, 

06:08:50.896 --> 06:08:56.093
Laurence, our lunch and T shirt 
guy and developer   eradicate 

06:08:56.207 --> 06:09:02.721
will show you this product with 
a few demos.  So let's begin.

06:09:02.722 --> 06:09:06.436
     Why notifications?  When we
 embark on the journey of d

06:09:06.839 --> 06:09:10.165
eveloping an application, we all
 dream about its success.  We 

06:09:10.166 --> 06:09:12.681
think about how 
much our use ers will love our 

06:09:12.682 --> 06:09:16.774
applications.  We want them to c
ome to the application and want 

06:09:16.997 --> 06:09:21.450
more and more.  Because user 
engagement play 

06:09:21.451 --> 06:09:23.451
AIs

06:09:25.078 --> 06:09:27.081
 really big role in application 
development.  Applications are 

06:09:27.082 --> 06:09:32.302
those messages that comes in 
front of a use er, grabs their 

06:09:32.303 --> 06:09:34.725
attention, and 
hopefully do something that we 

06:09:34.807 --> 06:09:38.955
want to.  A month ago I bought a
 ticket to a fest I feel    

06:09:40.407 --> 06:09:43.788
         festival and this 
application is reminding me that

06:09:43.789 --> 06:09:46.895
 in three days 
this application begins and 

06:09:47.923 --> 06:09:53.355
maybe I should check the final 
line-up or buy tickets         

06:09:53.356 --> 06:09:57.185
tickets to the shuttle or share 
the notifications with my 

06:09:57.401 --> 06:10:00.012
friends.
     So notifications are really

06:10:00.347 --> 06:10:02.681
 important in fact there are 
study ies         study ies that

06:10:02.682 --> 06:10:06.377
 show that use ers that opt into
 notifications are twice as 

06:10:06.832 --> 06:10:08.832
likely to 
come back as those that don't.  

06:10:08.879 --> 06:10:11.801
But if we send too many 
notifications               

06:10:11.802 --> 06:10:15.730
notifications, we might upset 
the use er, overwhelm them and 

06:10:17.147 --> 06:10:21.090
achieve the opposite 
effect.  Use ers might silence 

06:10:21.830 --> 06:10:26.965
notifications or even worse, 
uninstall or app.  So we need to

06:10:26.966 --> 06:10:29.968
 get a few things right.  We 
need to know, when is 

06:10:29.969 --> 06:10:33.293
the rate time to get        to 
send a notification.  If I get 

06:10:33.406 --> 06:10:36.398
the notification now to come 
back and play a new level, it's 

06:10:36.713 --> 06:10:39.119
probably not effective.  We 
need to understand who we should

06:10:39.120 --> 06:10:43.455
 target.  If we have wet suit 
sales, and we target runners, 

06:10:43.456 --> 06:10:46.387
maybe we are not as effective as
 if we target 

06:10:46.388 --> 06:10:53.805
surfers.  And finally, what is 
the member?  What are we trying 

06:10:54.699 --> 06:10:58.912
to -- message we are trying to 
convey to this use er.  If we 

06:10:59.013 --> 06:11:01.957
write an 
application and slip in a bug, 

06:11:02.272 --> 06:11:05.417
bug zapping, right.  We 
definitely have bugs in our 

06:11:05.634 --> 06:11:09.094
applications.  Not Laurence.  
Obviously not Laurence.

06:11:09.095 --> 06:11:12.014
     Well we want to target just
 the population that was affecte

06:11:12.457 --> 06:11:16.735
d by the bug.  We don't want to 
send an apology to the entire 

06:11:17.214 --> 06:11:19.630
population of 
our use ers.  So, notifications 

06:11:19.822 --> 06:11:22.852
are really important, but to get
 these things right, we need 

06:11:22.853 --> 06:11:25.489
some sort of feedback, and here 
is when analytics 

06:11:25.490 --> 06:11:28.581
comes to help.  Because with g
ood analytics data, now we can 

06:11:29.117 --> 06:11:31.117
improve our engagement statute 
us.  And our

06:11:34.758 --> 06:11:36.072
 marketing and growth people can

06:11:36.073 --> 06:11:40.405
spend time focusing on how to 
increase our use er base and our

06:11:40.623 --> 06:11:45.344
 content editor can send content
 updates as they write the 

06:11:45.345 --> 06:11:49.668
articles.  And our 
product managers like Tingmui 

06:11:50.295 --> 06:11:52.777
here can send announcements to 
use ers that will make the usage

06:11:53.598 --> 06:12:00.013
 of the April even      -- app 
even more compelling.  So we 

06:12:00.082 --> 06:12:03.546
think this is very important and
 here at Firebase, we have a new

06:12:03.547 --> 06:12:07.753
 product that will let you do 
exactly this.  Please welcome T

06:12:07.863 --> 06:12:09.863
ingmui to show 
you Firebase notifications

06:12:10.804 --> 06:12:12.112
               notifications  
             notifications

06:12:12.113 --> 06:12:16.953
     (Applause)you, Francesco.  
So, let's take a look at five 

06:12:16.954 --> 06:12:23.825
base notifications.  It is part 
of the Firebase product.  And 

06:12:25.239 --> 06:12:27.239
Firebase is a

06:12:29.104 --> 06:12:31.947
 integrate ed product that helps
 you to develop your apps, glow 

06:12:32.245 --> 06:12:36.880
a use er base, and earn money.  
Francesco just mentioned that 

06:12:37.252 --> 06:12:40.379
notification is really important
 in helping you to engage use 

06:12:40.690 --> 06:12:44.628
ers.  With the right contacts, 
and the right analytics, it 

06:12:44.914 --> 06:12:46.963
could be even more 
powerful.  But the process has 

06:12:48.410 --> 06:12:52.288
to be simple.  So that people 
can really focus on getting the 

06:12:52.401 --> 06:12:54.913
content of the message.  Send an
 interesting 

06:12:54.914 --> 06:12:57.342
message that's going to bring 
your use er back much more 

06:12:57.746 --> 06:12:59.746
effectively,

06:13:01.762 --> 06:13:04.272
 so let's see how Firebase 
notification is going to help 

06:13:04.273 --> 06:13:06.781
you achieve that    
that.  Many of you are familiar 

06:13:06.782 --> 06:13:11.378
with Firebase Cloud message ing.
  The new version of Google 

06:13:11.379 --> 06:13:15.236
Cloud message ing.  It has been 
reliable y delivering 

06:13:15.237 --> 06:13:20.075
messages to Android, iOS, and 
Chrome use ers.  Firebase 

06:13:20.076 --> 06:13:26.240
notifications is built on top of
 Firebase Cloud Message ing.  It

06:13:26.241 --> 06:13:28.957
 is cross-platform.  It 
is designed so that you can set 

06:13:28.958 --> 06:13:34.516
the right target are the right 
contacts and be able to evaluate

06:13:34.517 --> 06:13:40.731
 effectiveness after.  It's 
simple.  As you 

06:13:40.732 --> 06:13:44.234
can see from this console anyone
 should be able to send a 

06:13:44.362 --> 06:13:46.893
notification on message without 
having to write a single line of

06:13:47.069 --> 06:13:49.108
 server code so 
that you can really focus on 

06:13:49.109 --> 06:13:51.805
getting the content of your 
message right.

06:13:51.806 --> 06:13:55.325
     But, it is not just a forum
 so that you have to fill out 

06:13:55.446 --> 06:14:01.087
all the mandatory fields before 
you can send a message.  It's 

06:14:01.088 --> 06:14:04.007
designed so that 
you can set the right target by 

06:14:04.008 --> 06:14:12.160
using analytic insights, SCM 
topics or even device and app 

06:14:12.161 --> 06:14:14.975
info.  Once you have these lined
 to the right 

06:14:14.976 --> 06:14:18.005
target, it's about engage ing  
        engage ing your use er 

06:14:18.239 --> 06:14:22.395
with the right contacts.  For 
example, use language so that 

06:14:22.396 --> 06:14:27.106
you can localize your message so
 that your 

06:14:27.107 --> 06:14:33.037
Italian use ers will not be 
getting a German message, for 

06:14:33.038 --> 06:14:36.489
example.  Or send your message 
so that it's delivered based off

06:14:36.490 --> 06:14:38.951
 the use er's time zone    
zone.  Don't have to worry about

06:14:38.952 --> 06:14:43.954
 wake ing a use er at 3:00 a.m. 
in the morning, get them mad, 

06:14:44.374 --> 06:14:48.168
turn off notifications and 
potentially say bye to 

06:14:48.169 --> 06:14:53.384
your applications.  Every 
applications has its own 

06:14:54.269 --> 06:14:58.323
customizations and you can do 
that by using the custom data 

06:14:58.324 --> 06:15:02.539
field.  You can pass in the 
dynamic length so you can take 

06:15:02.540 --> 06:15:07.601
use ers to the right content 
hand the right flow of your app 

06:15:08.485 --> 06:15:10.902
or provide a discount so you can
 apply the 

06:15:10.903 --> 06:15:13.732
discount when you tap on pending
 notifications

06:15:18.779 --> 06:15:21.946
.  You've just seen how easy it 
is to send notifications but is 

06:15:22.266 --> 06:15:25.475
it a factor?  Is it bringing 
more use ers 

06:15:25.476 --> 06:15:28.807
back?  Not having much of a 
difference or actually turning 

06:15:29.234 --> 06:15:34.449
use ers away?
     Firebase is integrate ed 

06:15:34.777 --> 06:15:37.566
with analytics and provide you 
with a default analytics so you 

06:15:37.567 --> 06:15:41.259
can understand the effectiveness
 right out of the   When sending

06:15:41.260 --> 06:15:44.825
 a message, a lot of the time 
there is a goal that we want to 

06:15:45.326 --> 06:15:49.819
achieve.  You can set that by 
using conversion events.  We 

06:15:50.740 --> 06:15:54.382
track sent and opened for you by
 default, but obviously, you can

06:15:54.383 --> 06:15:59.869
 provide your own.  So now, 
let's go take a look at the 

06:16:00.410 --> 06:16:04.055
console and see 
where you can find the analysis

06:16:07.957 --> 06:16:10.284
. to the laptop.

06:16:14.773 --> 06:16:19.072
.  So, what you're -- 
(laughter).  So what you're 

06:16:19.073 --> 06:16:24.065
seeing here is the Firebase 
console.  And you can find 

06:16:26.401 --> 06:16:28.620
notifications under growth 
because we believe that it can 

06:16:28.831 --> 06:16:33.742
really help you to reenengage 
your use er to improve the 

06:16:33.852 --> 06:16:36.750
experience.  So this is 
where you have all the campaigns

06:16:36.874 --> 06:16:39.330
 that you're manage ing.  If you
 click on one of the campaigns 

06:16:39.603 --> 06:16:45.554
that has already been completed,
 it's loading.  

06:16:45.555 --> 06:16:51.570
All right.  This is where you're
 going to see the analysis, the 

06:16:52.308 --> 06:16:55.083
notification funnel.  So there's
 some interesting data here.  

06:16:55.403 --> 06:16:57.710
Number sent, 
and how many of your use ers 

06:16:57.917 --> 06:17:02.653
actually haven't opened your 
notifications.  So apparently, 

06:17:02.654 --> 06:17:08.765
this particular promotion is not
 as effective in 

06:17:08.766 --> 06:17:15.385
getting the us auto -- use er to
 open notifications and if you 

06:17:16.080 --> 06:17:19.122
actually put in 95s we will 
track the time your use er a

06:17:19.318 --> 06:17:21.428
ctually clicked the 
actions that will lead to that 

06:17:22.221 --> 06:17:24.567
event.
     So this gives you the basic

06:17:24.568 --> 06:17:27.411
 insight of notification effect
iveness.  If you want do more 

06:17:27.412 --> 06:17:30.131
analysis, this is when you go to
 analytics.  So 

06:17:30.132 --> 06:17:32.132
there's one trick I would like 
to share 

06:17:36.260 --> 06:17:40.967
with you here today.  So if you 
go to analytics, and look for 

06:17:40.968 --> 06:17:43.195
notification opens under the 
events 

06:17:43.196 --> 06:17:49.151
top, this will bring you the 
default analytics event report 

06:17:49.265 --> 06:17:52.714
view.  So you see the total 
count.  The breakdown by 

06:17:52.715 --> 06:17:57.722
messages and topics, as 
well as the breakdown by 

06:17:57.816 --> 06:18:02.042
location and demo graphic if 
those data is available to you. 

06:18:02.043 --> 06:18:05.132
 The trick I want to show you is
 if you actually click 

06:18:05.133 --> 06:18:10.023
on one of the messages up here, 
we'll actually automatically 

06:18:10.253 --> 06:18:13.000
apply filters to all the 
dashboards and all the event 

06:18:13.499 --> 06:18:16.936
reports in analytics.  So 
now you can really do some 

06:18:16.937 --> 06:18:20.751
serious analysis of how this 
particular notification campaign

06:18:21.065 --> 06:18:24.898
 actually impacts your underline
 success metrics and 

06:18:24.899 --> 06:18:32.553
factors.  So now let's go back 
to the presentation, please.ll 

06:18:32.554 --> 06:18:37.852
right.  So you've just seen the 
product walk through.  So now, 

06:18:37.853 --> 06:18:43.636
Laurence, our develop eradicate 
is going                   er 

06:18:43.735 --> 06:18:46.670
advocate is going to show us our
 demo.

06:18:46.671 --> 06:18:50.679
   &gt;&gt; LAURENCE MORONEY: I don't 
know about you guys but I'm a 

06:18:50.680 --> 06:18:52.680
really lazy code er

06:18:55.636 --> 06:18:56.733
.  I like to write as few line 
as possible.  Actually, before 

06:18:56.734 --> 06:19:03.374
my demo -- who?  I see people w
aving.  Oh, short.  So I'm a 

06:19:03.779 --> 06:19:07.506
very lazy programmer in general.
  I like to write as few lines 

06:19:07.622 --> 06:19:10.235
of code as 
possible.  I want things made as

06:19:10.236 --> 06:19:13.639
 easy as they can be and that's 
one of the things that really 

06:19:13.640 --> 06:19:16.514
attracts many he to Firebase 
notifications 

06:19:16.515 --> 06:19:18.874
because it's just so easy's 
developer.  So first of all I 

06:19:19.085 --> 06:19:22.292
want to talk about two scenarios
 for building applications and 

06:19:22.800 --> 06:19:24.394
one is when you're 
receiving notifications in the 

06:19:24.395 --> 06:19:27.941
background and I want to talk 
about just how easy it is for 

06:19:27.942 --> 06:19:31.341
you to build the code doing that
.

06:19:31.342 --> 06:19:33.664
     Here's the code if you want
 to receive background 

06:19:33.665 --> 06:19:37.771
notifications in iOS.  Any other
 lazy developers here?  You 

06:19:37.772 --> 06:19:41.324
know, a single line of 
code, and technically, it's not 

06:19:41.325 --> 06:19:44.633
even a line of code.  It's a 
line of configuration, right?  

06:19:44.634 --> 06:19:47.751
You add a single part to your 
iOS application 

06:19:47.752 --> 06:19:51.276
and use the Firebase message ing
 part -- a lot of people ask, 

06:19:51.277 --> 06:19:55.090
well why message ing?  Why not 
notifications?  And you may be 

06:19:55.091 --> 06:19:59.377
familiar with Google 
Cloud Message ing and now its 

06:19:59.489 --> 06:20:04.869
new evolution of Firebase 
message egg.  So they're so 

06:20:04.870 --> 06:20:08.074
similar, we decided there's no p
oint in using two 

06:20:08.075 --> 06:20:11.354
different things so if you 
incorporate the pod into your 

06:20:11.355 --> 06:20:14.432
Cloud message ing you can also 
grow Firebase message ing as 

06:20:14.433 --> 06:20:20.485
well but all you've got to 
do is put this in your 

06:20:20.486 --> 06:20:23.915
application and you're good to. 
 For Android, it's almost as 

06:20:23.916 --> 06:20:28.696
easy.  Just Firebase message ing
 3.0.0.  And that's it.  

06:20:28.697 --> 06:20:31.695
So if you create an application 
and I'm going to demo in just a 

06:20:31.696 --> 06:20:34.636
moment where I used Android 
studio and I did file name 

06:20:34.725 --> 06:20:36.725
application and if 
you're an

06:20:39.983 --> 06:20:43.983
 Android studio developer you're
 probably familiar with the 

06:20:39.983 --> 06:20:44.930
template which just gives you a 
hello world.  That's all I did 

06:20:44.931 --> 06:20:50.924
then add   
added a line to the build.

06:20:51.677 --> 06:20:56.875
gradele.  So I have an app 
running and Tingmui is going to 

06:20:56.989 --> 06:20:59.627
send a notification to this app.
   &gt;&gt; TINGMUI LI: Can we switch 

06:20:59.628 --> 06:21:01.838
to the laptop?
   &gt;&gt; LAURENCE MORONEY: Yeah, s

06:21:04.345 --> 06:21:06.345
orry.  Switch to the laptop.
   &gt;&gt; TINGMUI LI: All right.  So

06:21:06.662 --> 06:21:12.526
 let's see.  Let's start sending
 a notification.  What shall I 

06:21:12.527 --> 06:21:13.995
send?
   &gt;&gt; LAURENCE MORONEY: What 

06:21:13.996 --> 06:21:17.041
should we say?  What kind of 
notification?  Just so you know 

06:21:17.373 --> 06:21:21.711
it's real.  Any hockey fans 
here?  Who's going to 

06:21:21.712 --> 06:21:23.712
win the Stanley cup

06:21:26.015 --> 06:21:32.767
?  Penguins?  Who said the 
Seattle Thunderbirds?  You're my

06:21:32.768 --> 06:21:38.727
 hero.  They're not even in it. 
 Okay, let's send penguins.

06:21:38.728 --> 06:21:40.728
   &gt;&gt; TINGMUI LI: Penguins.

06:21:43.477 --> 06:21:44.179
  Hey.
   &gt;&gt; LAURENCE MORONEY: Easier 

06:21:44.180 --> 06:21:47.901
this way.  All right.  So can we
 switch back to the phone?  So, 

06:21:48.204 --> 06:21:51.031
now, earlier you saw the phone 
was just 

06:21:51.032 --> 06:21:54.028
sitting on the desktop and the 
notification has just come in.  

06:21:54.313 --> 06:21:57.695
You can see it up in my 
notification tray so if I slide 

06:21:58.139 --> 06:22:00.355
down from that, my 
application was just called 

06:22:00.761 --> 06:22:03.069
Firebase notification one, and 
you can see Tingmui has actually

06:22:03.450 --> 06:22:09.400
 sent the notification Penguins 
and if I touch on 

06:22:09.401 --> 06:22:11.728
that, it's going to launch the 
app.  And this is the familiar 

06:22:12.032 --> 06:22:16.747
app from hello world studio.  I 
wrote no code to goat that.  

06:22:16.748 --> 06:22:19.648
Isn't -- get to 
that.  Isn't that pretty cool, 

06:22:19.649 --> 06:22:23.078
right?
     (applause)

06:22:23.079 --> 06:22:26.110
     I've never had so many 
applause for doing nothing 

06:22:26.417 --> 06:22:27.925
before.  This is great.  
(laughter)

06:22:27.926 --> 06:22:35.742
     Could so can we switch back
 to the slide, please?  So that 

06:22:35.743 --> 06:22:38.796
was background notifications and
 people say, great, but what if 

06:22:38.797 --> 06:22:43.032
I want do it 
in the foreground.  The classic 

06:22:43.440 --> 06:22:48.092
example of this is if you're 
using some kind of IP telephone 

06:22:48.479 --> 06:22:50.812
y app and then you want to 
change your call, in 

06:22:50.813 --> 06:22:54.800
most cases you want to answer, 
some you want to ignore, and 

06:22:55.105 --> 06:22:58.269
that you will kind of UI so 
you're changing the context of 

06:22:58.270 --> 06:22:59.949
the app upon 
receiving notification.  So 

06:22:59.950 --> 06:23:03.666
let's take a look at how to o 
actually do this.  In this case,

06:23:03.667 --> 06:23:06.110
 I'm still a lazy developer so 
it's not a whole 

06:23:06.111 --> 06:23:08.707
lot of work but it's a little 
bit of work and it's a little 

06:23:08.708 --> 06:23:13.687
bit more so in Android, here's 
all have I to do.  Okay I'm 

06:23:13.688 --> 06:23:17.991
going to create a class, because
 I'm a lazy programmer and have 

06:23:18.301 --> 06:23:21.328
no imagine ation on what to call
 the thing and I specify an 

06:23:21.329 --> 06:23:26.250
intent filter on this so 
that will handle different 

06:23:26.251 --> 06:23:29.827
actions so this class will 
handle the action and the action

06:23:29.828 --> 06:23:34.036
 I want it to handle is come 
Google message ing app.  If 

06:23:34.037 --> 06:23:38.362
this application is running on 
the device, whenever an income i

06:23:38.459 --> 06:23:41.777
ng notification comes then this 
Firebase message ing service 

06:23:41.778 --> 06:23:43.987
class is the one 
that's going to handle it.

06:23:43.988 --> 06:23:48.081
     And this class would look a
 little bit like this.  So it's 

06:23:49.089 --> 06:23:53.443
just straight forward Java code 
here.  This is my lazy Java-b

06:23:53.759 --> 06:23:56.175
ased message ing 
service and I'm going to extend 

06:23:56.394 --> 06:24:00.777
the Firebase ed message ing 
service for that.  And whenever 

06:24:00.778 --> 06:24:03.899
I receive the message, I just 
receive this message 

06:24:03.900 --> 06:24:07.457
receive ed and it's going to 
contain a remote message and 

06:24:07.855 --> 06:24:09.891
then there's a bunch of 
attributes of that message that 

06:24:09.892 --> 06:24:13.319
I can do something with.  I 
put together a screen cast of 

06:24:13.320 --> 06:24:16.183
this that went on YouTube last 
night and one question somebody 

06:24:16.184 --> 06:24:21.768
asked me was well, how would I 
generate a 

06:24:21.769 --> 06:24:27.137
custom noise so say, for 
example, Android M, we have the 

06:24:28.116 --> 06:24:31.367
ability do a custom notification
.  Here's how you do that.  

06:24:31.368 --> 06:24:33.696
You're receiving the 
remote message in and then you 

06:24:33.697 --> 06:24:36.513
can generate a new notification 
that      that you would then 

06:24:37.401 --> 06:24:41.938
generate an Android with that 
custom on L. also, if you 

06:24:41.939 --> 06:24:45.370
have Android Wear a watch next 
to it, you can send the 95 

06:24:45.371 --> 06:24:49.184
there.  Lots of great stuff you 
can do and this is really all 

06:24:49.185 --> 06:24:52.086
the code that you 
have to be able to do do that.  

06:24:52.889 --> 06:24:56.594
You create the service.  You c
reate the message ing field.  

06:24:57.006 --> 06:24:58.637
Message received.  Pretty 
straight forward.  

06:24:58.638 --> 06:25:02.538
Pretty easy, right?  And then 
people go, but what about iOS.

06:25:02.823 --> 06:25:06.650
     I say, okay.  IOS.  Forgive
 me, my 

06:25:09.768 --> 06:25:14.621
slides, I tend to use objective 
C.  I haven't become a fan of Ta

06:25:14.726 --> 06:25:19.123
ylor Swift yet.  People are 
laughing 

06:25:19.124 --> 06:25:23.042
at my jokes.  This is great.  
Last time nobody was.  So when 

06:25:23.043 --> 06:25:27.392
you're writing an iOS you just 
have, have a receive line      

06:25:27.474 --> 06:25:32.561
line of code.  If you're an 
objective C programmer you're 

06:25:32.562 --> 06:25:36.486
familiar with this.  It's just a
 set of name value pairs.  So 

06:25:36.685 --> 06:25:39.283
there's going to be a set of 
name value pairs 

06:25:39.284 --> 06:25:42.388
and keys, this is where I r
eadout the keys like maybe the 

06:25:42.389 --> 06:25:45.405
message ID or message body or 
something like that and then I 

06:25:45.406 --> 06:25:47.487
can do something 
interesting with that in iOS.  

06:25:47.488 --> 06:25:51.855
So should we see this in 
actions?  What do you think?

06:25:51.856 --> 06:25:54.087
   &gt;&gt; TINGMUI LI: Why not?
   &gt;&gt; LAURENCE MORONEY: Okay.  

06:25:54.088 --> 06:25:57.490
Can we switch to the laptop, p
lease?  Actually, switch back to

06:25:57.491 --> 06:25:59.688
 the phone first, please.  And I
 have my 

06:25:59.689 --> 06:26:03.236
application running in the 
foreground and it's the same 

06:26:04.614 --> 06:26:06.847
hello world application from 
Android studio except I added a 

06:26:06.848 --> 06:26:10.285
service class to that ll the 
code I showed you on the slide 

06:26:10.753 --> 06:26:15.047
and I'm reasoning it and now can
 we switch to the laptop, now?  

06:26:15.578 --> 06:26:18.155
What should we send?  What do 
you think?  Something other than

06:26:18.770 --> 06:26:22.240
 Penguins.  I don't really like 
the Penguins.

06:26:22.241 --> 06:26:25.029
   &gt;&gt; TINGMUI LI: Turtles 
        turtles?

06:26:25.030 --> 06:26:29.465
   &gt;&gt; LAURENCE MORONEY: There's 
tho hockey team called the 

06:26:29.466 --> 06:26:31.466
turtles, but that's

06:26:33.770 --> 06:26:39.214
 okay.  Name a hockey team.  Is 
he        sharks.  Thank you.  T

06:26:40.612 --> 06:26:43.644
hey're going 
to win tonight, right?  So as 

06:26:43.735 --> 06:26:46.946
Tingmui sends that, can we now 
switch to the phone?  And we 

06:26:47.336 --> 06:26:49.651
should see an income ing 
notification that's going 

06:26:49.652 --> 06:26:58.476
to change my activity.  Drum 
role, everybody.  Thank you for 

06:26:58.477 --> 06:27:01.501
the drumroll.  There it is.  We 
see this activity and this was 

06:27:01.502 --> 06:27:03.789
launched in 
response to the notification so 

06:27:03.790 --> 06:27:07.202
in that slide where I showed you
 earlier on that I received the 

06:27:07.305 --> 06:27:08.953
notification and I received the 
data, I have 

06:27:08.954 --> 06:27:10.954
another activity that 

06:27:15.413 --> 06:27:15.608
I just launched, stuck that 
bundle in the data.  So in this 

06:27:15.609 --> 06:27:19.703
activity I ran the text.  It was
 really, really as simple 

06:27:19.704 --> 06:27:23.198
as that.  We're probably talking
 15 lines of code total to do 

06:27:23.275 --> 06:27:26.960
the whole thing and this is me 
receiving custom notifications 

06:27:26.961 --> 06:27:29.278
and actually 
doing something active with 

06:27:29.699 --> 06:27:34.225
that.  How easy is that?  What 
are we going to do year?  So 

06:27:34.544 --> 06:27:37.159
with that, Tingmui, I'd like to 
pass it back to you 

06:27:37.160 --> 06:27:40.465
and we're going to talk about 
some customers, right?

06:27:40.466 --> 06:27:42.989
   &gt;&gt; TINGMUI LI: Yep.  Can we 
go back to the presentation, 

06:27:43.298 --> 06:27:44.538
please?  And thank you, Laurence
.

06:27:44.539 --> 06:27:46.539
   &gt;&gt; LAURENCE MORONEY: Thank 
you

06:27:49.562 --> 06:27:49.650
.
     (applause)

06:27:53.185 --> 06:27:57.303
got the T shirts.
   &gt;&gt; TINGMUI LI: Yeah I think 

06:27:57.304 --> 06:28:00.632
we have more shirts to send out.
  Okay.  So I hope you guys 

06:28:00.633 --> 06:28:04.986
enjoyed the T shirts as well as 
the demo that we 

06:28:04.987 --> 06:28:08.405
just showed you.  We definitely 
like it.  So we have just shown 

06:28:09.817 --> 06:28:13.875
you how to send this out without
 using the console and how 

06:28:13.876 --> 06:28:15.458
simple it is to 
integrate on the client side.  

06:28:15.459 --> 06:28:20.604
We don't want the developer 
product in a vacuum so we have 

06:28:20.707 --> 06:28:24.304
been gathering a lot of 
developer feedback and 

06:28:24.305 --> 06:28:28.040
there are many developers who 
actually integrate ed to 

06:28:28.423 --> 06:28:31.676
Firebase notifications already. 
 Today, I would like to share 

06:28:31.677 --> 06:28:34.269
the experiences of three 
of them and for the rest please 

06:28:34.594 --> 06:28:38.408
go to other Firebase sessions 
and hear about their experience.

06:28:39.020 --> 06:28:43.486
     So, first, avenue air.  
Someone is taking a picture.  

06:28:43.999 --> 06:28:48.236
So, avenue air helps use ers to 
manage their travel experience 

06:28:48.237 --> 06:28:51.351
after they have 
already booked their experience.

06:28:51.455 --> 06:28:53.669
  So they would get

06:28:58.298 --> 06:29:03.440
 a Firebase Mejia letter   
           message alert.  They 

06:29:03.441 --> 06:29:10.082
were also able to focus on the 
important part      parts of 

06:29:10.083 --> 06:29:13.823
their 
app.

06:29:13.824 --> 06:29:17.095
     Bus buzz.  An application t
hat allows you to book a bus 

06:29:17.096 --> 06:29:20.747
ticket.  They were able to 
integrate very quickly with 

06:29:20.748 --> 06:29:25.221
Firebase while still 
able to customize their use er 

06:29:25.222 --> 06:29:28.604
experience.
     Milan studio is able to use

06:29:28.907 --> 06:29:34.502
 Firebase applications in their 
latest application, true day, an

06:29:34.503 --> 06:29:38.459
 application that helps use ers 
to celebrate 

06:29:38.460 --> 06:29:40.254
anniversary ies.  They have use 
ers around the world and they're

06:29:40.255 --> 06:29:44.586
 able to use a time zone feature
 so they don't have to worry 

06:29:44.587 --> 06:29:46.536
about sending 
notifications               

06:29:46.537 --> 06:29:49.845
notifications after midnight and
 disrupting their use ers so 

06:29:50.030 --> 06:29:53.967
these are some real life 
examples and testimony ies on 

06:29:54.268 --> 06:29:57.395
how flexible, simple, and 
reliable Firebase notification 

06:29:57.396 --> 06:30:01.319
is.  So we have covered a lot 
today.  We've talked about why 

06:30:01.852 --> 06:30:05.608
we think 95 is       
notification is important in 

06:30:05.711 --> 06:30:08.042
engage ing 
use ers, what we built to engage

06:30:08.145 --> 06:30:12.951
 use ers, and also showed you 
some demos and also partner 

06:30:12.952 --> 06:30:17.425
feedback.
     In summary, there are three

06:30:17.426 --> 06:30:21.052
 key takeaways.  We built 
Firebase notification so that 

06:30:21.053 --> 06:30:24.559
anyone can send notification 
without having to write  line of

06:30:24.773 --> 06:30:29.488
 server code and we made the 
client integration super simple 

06:30:29.489 --> 06:30:34.914
as well so that you can focus on
 getting the right user with 

06:30:34.915 --> 06:30:38.144
the right contacts.  And with a 
tight integration with analytics

06:30:38.240 --> 06:30:41.741
, you'll be able to measure the 
effectiveness of your 

06:30:41.954 --> 06:30:45.369
notifications.  We're 
really excited to announce that 

06:30:45.370 --> 06:30:49.024
Firebase notifications is 
available to you today, so for 

06:30:49.025 --> 06:30:51.859
those who are interested to 
learn more, please go 

06:30:51.860 --> 06:30:53.860
to Firebase.

06:30:56.696 --> 06:31:00.125
Google.com, check out our 
documentation and support page. 

06:31:00.126 --> 06:31:02.740
 We really look forward to your 
feedback because we want to 

06:31:02.839 --> 06:31:04.844
develop a 
product that really helps you to

06:31:04.845 --> 06:31:08.563
 better engage your use ers.  So
 thank you so much for coming to

06:31:08.564 --> 06:31:12.090
 this session and now I'm going 
to invite 

06:31:12.091 --> 06:31:14.091
Francesco back on stage and then
 open up the floor for 

06:31:15.209 --> 06:31:16.620
questions.
   &gt;&gt; LAURENCE MORONEY: Before 

06:31:16.621 --> 06:31:19.258
we take questions I have a q
uestion for everybody here and 

06:31:19.259 --> 06:31:22.434
I've got I a couple of prizes of
 some Chrome casts     

06:31:22.435 --> 06:31:25.280
casts, that anybody who's an 
eagle eye developer.  You saw we

06:31:26.690 --> 06:31:32.009
 did our agenda slide, we did a 
little bit of code but there was

06:31:32.010 --> 06:31:37.051
 a bug in that 
code that wouldn't compute.  So 

06:31:37.191 --> 06:31:41.814
if anybody gets it, see me after
 the session and you'll get a 

06:31:43.192 --> 06:31:45.194
Chrome cast for the first two.  
So what 

06:31:45.195 --> 06:31:48.321
questions?  Now they're all 
wondering.  Can we go to the mic

06:31:48.656 --> 06:31:51.489
 in the center.
   &gt;&gt; Greetings.  Yesterday when

06:31:53.353 --> 06:31:57.193
 I heard about Firebase for the 
first time, I understood it was 

06:31:57.194 --> 06:32:00.377
for Android, iOS, and also 
desktop message ing         

06:32:00.378 --> 06:32:02.299
messaging.  Does anything you 
covered today cover that?

06:32:02.300 --> 06:32:05.041
   &gt;&gt; TINGMUI LI: So what we 
have for Firebase notification 

06:32:05.632 --> 06:32:08.843
is iOS and Android today.  We 
are definitely looking into 

06:32:08.844 --> 06:32:10.740
making it available 
for web as well.

06:32:10.741 --> 06:32:13.381
   &gt;&gt; But not today?
   &gt;&gt; TINGMUI LI: Not today.

06:32:13.382 --> 06:32:16.658
   &gt;&gt; Hey there, for the first 
notification demo you did the 

06:32:16.659 --> 06:32:19.666
one that was just kind of 
sending it directly.  I know you

06:32:19.952 --> 06:32:22.797
 said it's just like 
one line of configuration code. 

06:32:22.798 --> 06:32:25.592
 Was there also code for r
eceiving the notification that 

06:32:25.709 --> 06:32:29.355
we didn't see?  Like, how does 
it know, then, which 

06:32:29.356 --> 06:32:33.375
activity to open up to or how to
 send a bundle of data or how 

06:32:33.376 --> 06:32:38.441
that bundle of data gets read?
   &gt;&gt; LAURENCE MORONEY: Yeah, so

06:32:38.637 --> 06:32:42.735
 that app was in the background 
and all I did was launch the app

06:32:42.736 --> 06:32:44.564
 and whatever activity was on, I
 touched the 

06:32:44.565 --> 06:32:47.796
home screen so then the app was 
sitting in the background as a 

06:32:47.915 --> 06:32:51.501
result so then when I receive ed
 the notification I just 

06:32:51.502 --> 06:32:54.944
reactivated the app.  
In this case, it was pretty 

06:32:55.239 --> 06:32:58.245
straight forward but a 
multiactivity one then whatever 

06:32:58.556 --> 06:33:01.186
activity is active at the time I
 put it in the background 

06:33:01.187 --> 06:33:03.619
but no other code.
   &gt;&gt; So that background was in 

06:33:03.880 --> 06:33:07.041
the background, we wanted it 
reactivate it.  If you wanted to

06:33:07.042 --> 06:33:10.244
 send data, that's when you do 
the foreground?

06:33:13.707 --> 06:33:16.507
   &gt;&gt; LAURENCE MORONEY: Correct.
  Exactly.

06:33:13.707 --> 06:33:17.421
   &gt;&gt; Hi.  We saw the 
notifications manually using the

06:33:17.422 --> 06:33:21.747
 console, but is there any way 
to automatically trigger using 

06:33:21.847 --> 06:33:29.930
another app without the console?
  To do notifications., I 

06:33:29.931 --> 06:33:32.151
misunderstood the question.  So 
I want to use a second app to 

06:33:32.658 --> 06:33:36.443
trigger notification in my app?
   &gt;&gt; Yes.  Using for Firebase.

06:33:36.776 --> 06:33:39.201
   &gt;&gt; LAURENCE MORONEY: One 
thing you could do is not 

06:33:39.506 --> 06:33:44.810
Firebase notifications but 
Firebase messages and your s

06:33:45.830 --> 06:33:47.830
econd app to send a 
notification to Firebase message

06:33:47.985 --> 06:33:51.384
 ing and ask that to do that and
 then if your first app was a 

06:33:52.085 --> 06:33:54.995
part of that.
   &gt;&gt; But can we use the 

06:33:55.500 --> 06:33:57.298
audience analytics to send 
notifications to different 

06:33:57.299 --> 06:33:59.252
audience?
   &gt;&gt; LAURENCE MORONEY: Yes you 

06:33:59.253 --> 06:34:03.025
could.  Definitely.
   &gt;&gt; Hi there.  Actually, I ha

06:34:03.341 --> 06:34:06.439
ve my own app that I create ed 
recently and I implemented that 

06:34:07.705 --> 06:34:12.731
goes with Cloud Message ing 
there, and then I 

06:34:13.237 --> 06:34:19.003
rolled a PHP administration 
panel for sending notification 

06:34:19.101 --> 06:34:21.923
to already registered use ers so
 the thing I manage ed to do u

06:34:22.319 --> 06:34:26.556
sing it that way, I was 
also providing for user like an 

06:34:26.557 --> 06:34:30.144
action in the notification, so 
that whenever the notification 

06:34:30.261 --> 06:34:34.275
came, there was like a bottom 
button, for 

06:34:34.276 --> 06:34:39.010
example, refreshing data, 
answering the message, or 

06:34:39.011 --> 06:34:42.234
anything like that.  How do you 
implement that using Firebase?

06:34:42.720 --> 06:34:46.418
   &gt;&gt; LAURENCE MORONEY: Corks 
within the pay load          -- 

06:34:46.531 --> 06:34:49.256
so, within the pay load you had 
some data and you would use that

06:34:49.257 --> 06:34:53.875
 data to trigger an action 
within your application?  So, in

06:34:53.876 --> 06:34:57.306
 the case, for example, the 
second demo I sent there, that 

06:34:57.605 --> 06:35:01.548
data, Tingmui just sent Sharks 
but that data 

06:35:01.549 --> 06:35:04.212
could be anything.  It doesn't 
have to be the simple string 

06:35:04.319 --> 06:35:07.854
like that and whatever the 
concept for that data, I could 

06:35:08.361 --> 06:35:10.993
parse that from the 
client's side and say, if it's 

06:35:11.214 --> 06:35:15.054
sharks, launch this activity.  
If it's ping      penguins, 

06:35:16.200 --> 06:35:17.957
launch that.
   &gt;&gt; Yeah, but this is done 

06:35:17.958 --> 06:35:22.570
automatically.  When we have 
sharks, we are running this 

06:35:22.571 --> 06:35:24.965
activity.  When there is penguin
, this activity.  But 

06:35:25.275 --> 06:35:28.172
I'm asking a possibility of 
performing some act by the user 

06:35:28.173 --> 06:35:30.778
when the notification arrived.  
So we see the notification, can 

06:35:30.779 --> 06:35:32.779
click the 
notification to open the 

06:35:33.118 --> 06:35:39.774
default, actually open the 
activity, but current solution 

06:35:40.053 --> 06:35:44.005
allows us to have a small button
 or small action to 

06:35:44.006 --> 06:35:48.383
perform different action.  Like 
snooze.  Like replay.  Something

06:35:48.384 --> 06:35:51.863
 like that., so that's something
 that we don't have right now.  

06:35:51.864 --> 06:35:55.373
Yeah, but we're definitely 
looking at getting it, Yeah.  

06:35:55.374 --> 06:35:57.374
Because 
a lot of people ask about that.

06:35:57.475 --> 06:35:59.594
   &gt;&gt; All right.  So another s
mall question, could you just 

06:35:59.595 --> 06:36:05.455
confirm that      that we can 
use a solution like fire bird 

06:36:05.456 --> 06:36:07.456
notification

06:36:08.528 --> 06:36:12.982
 for the jell yes    y 
bean, lower than the N?  Is it 

06:36:14.514 --> 06:36:17.414
usable there?
   &gt;&gt; FRANCESCO NERIERI: Yes.  

06:36:17.415 --> 06:36:20.444
As long as you have the latest P
lay services version.

06:36:20.445 --> 06:36:23.493
   &gt;&gt; All right.  That's all.  
Thanks.

06:36:23.494 --> 06:36:25.494
   &gt;&gt; Thank you.
   &gt;&gt; All right.  I have two 

06:36:25.551 --> 06:36:28.479
questions.  The first one is 
that I recently implemented the 

06:36:29.014 --> 06:36:32.871
GCM support for Android.  We're 
talking about 

07:07:04.831 --> 07:07:06.831
.

07:07:08.418 --> 07:07:10.418
       Super

07:07:15.567 --> 07:07:17.567
charge ing Firebase with Google 
Cloud.

07:07:35.884 --> 07:07:41.586
                     Test 

07:07:50.277 --> 07:07:54.496
                 FB28

07:08:06.162 --> 07:08:09.417
.
       May 19, 2016

07:08:25.502 --> 07:08:27.710
.
       &gt;&gt; Hello, everybody.  

07:08:27.711 --> 07:08:31.357
Welcome.  So today my name is 
 Sandeep.  It's always Sandeep. 

07:08:31.551 --> 07:08:36.493
 I'm a developer advocate on 
 the Google Cloud platform.

07:08:36.494 --> 07:08:39.204
        &gt;&gt; BRET McGOWEN:  I'm 
alts a developer at Google for 

07:08:40.416 --> 07:08:42.492
 the Google Cloud Platform.
        &gt;&gt; SANDEEP DINESH:  

07:08:42.493 --> 07:08:44.940
Today we'll talk about 
super     

07:08:44.941 --> 07:08:47.977
 supercharge ing Firebase.have 
had had a chance to 

07:08:47.978 --> 07:08:51.575
 play with fieb previously?  A 
good number.  You know it's a 

07:08:52.072 --> 07:08:55.200
 integrate ed suite of products 
to help you develop your app, 

07:08:55.201 --> 07:08:58.242
 grow your user base and earn 
money.  As a developer my 

07:08:58.243 --> 07:09:01.157
 favorite part is how quickly 
you can build amazing 

07:09:01.158 --> 07:09:05.708
 applications without write ing 
a single line of serve er side 

07:09:06.120 --> 07:09:06.305
 code.
        &gt;&gt; SANDEEP DINESH:  When

07:09:06.306 --> 07:09:11.058
 you do need serve er side 
 code, Google Cloud Platform 

07:09:11.141 --> 07:09:16.602
comes to the rescue.  It's a 
 full Sued of tool, big data, 

07:09:16.603 --> 07:09:18.605
you name it.  It makes 
super     

07:09:18.606 --> 07:09:20.550
 supercharge ing your app really
 easy.

07:09:20.551 --> 07:09:22.551
        &gt;&gt; BRET McGOWEN:  So 
today we're going to talk about 

07:09:25.969 --> 07:09:29.712
 how fieb and Google Cloud 
Platform are best friends.  How 

07:09:30.002 --> 07:09:35.443
 they can work together to help 
you build amazing things in 

07:09:35.444 --> 07:09:36.525
 record time.
        &gt;&gt; SANDEEP DINESH:  So 

07:09:36.526 --> 07:09:39.480
we brainstormed and thought 
 about all the crazy ideas we 

07:09:39.481 --> 07:09:42.214
have.  We started throwing 
 them on the board.  We said 

07:09:42.306 --> 07:09:46.065
we're going to build a app that 
 does all of thoos things?  All 

07:09:46.066 --> 07:09:50.385
of these things?     Okay of the
 we don't have that 

07:09:50.386 --> 07:09:56.370
 much time.  Can we pick a hand 
68.    ful?  Let's not get too 

07:09:57.384 --> 07:09:57.575
crazy     
 crazy.

07:09:57.576 --> 07:09:58.898
        &gt;&gt; BRET McGOWEN:  Well 
let's pick a few things.  

07:09:58.899 --> 07:10:01.318
 We're going to build a app that
 does a few of these crazy 

07:10:01.319 --> 07:10:05.540
 things.  You know, I'm kind of 
tone ed down a little bit.  

07:10:05.541 --> 07:10:09.904
 But what we wanted to do is 
build a realtime, crowd-source 

07:10:10.672 --> 07:10:12.672
ed             
 crowd-sourced, live-streamed 

07:10:12.732 --> 07:10:14.732
game ing        game ing 
platform.

07:10:15.848 --> 07:10:18.455
       (Applause).
                      &gt;&gt; SANDEEP

07:10:18.456 --> 07:10:19.779
 DINESH:  That was a lot of buzz
 word, 

07:10:19.780 --> 07:10:22.513
 what does that mean?  What it 
means is instead of a normal 

07:10:22.608 --> 07:10:25.270
 game setup where each player 
has their own character, 

07:10:25.271 --> 07:10:30.175
 everyone is going to be playing
 the same character at the 

07:10:30.176 --> 07:10:35.905
 same time.  You might have seen
 twitch plays Pokiman 

07:10:35.906 --> 07:10:38.252
 popular a couple years ago.  
Here is how it work, everyone 

07:10:38.342 --> 07:10:41.574
 logged in, tab let, mobile, 
desktop, they're all sending 

07:10:41.672 --> 07:10:45.307
 commands, up down, left, right,
 right, left, and the 

07:10:45.308 --> 07:10:47.435
 character is responding to 
every single one of them.  

07:10:47.436 --> 07:10:53.383
 Sounds a little bit chaotic, 
but a lot of fun.o, of course, 

07:10:54.888 --> 07:11:00.437
the fieb      Firebase real    
 realtime database is perfect 

07:11:00.544 --> 07:11:03.785
for this.  Makes making real    
 realtime crowd-source ed 

07:11:04.082 --> 07:11:05.574
applications very simple simple.

07:11:05.575 --> 07:11:08.421
 Let's take a look.  I built a 
simple chat app every time I 

07:11:08.615 --> 07:11:11.760
 sent the message with my phone,
 you can see the chat 

07:11:11.761 --> 07:11:14.499
 messages showing up in both 
browse ers.  You can also see 

07:11:14.591 --> 07:11:16.591
the 
 chats coming

07:11:18.133 --> 07:11:19.943
 in the Firebase dashboard.  
What is this data?  

07:11:19.944 --> 07:11:24.798
 It's just JSON, makes it really
 easy to intd grate            

07:11:25.602 --> 07:11:27.602
integrate into any 
 application.

07:11:27.828 --> 07:11:28.927
        &gt;&gt; SANDEEP DINESH:  
Let's talk about code.  How do 

07:11:28.928 --> 07:11:30.928
 you connect a Firebase.  When 
you create a Firebase project 

07:11:32.664 --> 07:11:36.904
of information.  A API key, a 
 database URL, he's following 

07:11:37.227 --> 07:11:40.840
along, and a project ID.  You 
 use these three things to 

07:11:41.232 --> 07:11:44.471
connect a Firebase and also use 
 the API key and project ID to 

07:11:44.984 --> 07:11:48.015
connect to Google Cloud 
 Platform, so it makes it super 

07:11:49.229 --> 07:11:51.822
         super seize ee.  You 
take the 

07:11:51.823 --> 07:11:54.256
 configure, pass into Firebase, 
get a reference to the 

07:11:54.257 --> 07:11:56.463
 database.  Then we get a 
reference to the chat note.  

07:11:56.464 --> 07:11:59.015
 Firebase is just basically a 
tree of data.  So we've got a 

07:11:59.370 --> 07:12:02.132
 node called chat.  We're going 
to be inserting chat message 

07:12:03.535 --> 07:12:06.794
each chat message will be a 
 child of the chat node.

07:12:06.795 --> 07:12:10.834
       So how do we get the data
 into Firebase?  Super easy.  

07:12:11.012 --> 07:12:14.676
 Firebase provides a method 
called push.  It automatically 

07:12:14.852 --> 07:12:17.292
 appends your data to the list. 
 It creates a new child and 

07:12:17.293 --> 07:12:20.879
 creates a unique ID for you.  
This is really nice in our 

07:12:20.880 --> 07:12:22.540
 multiplayer environment because
 you're going to have a lot 

07:12:22.541 --> 07:12:24.971
 of messages coming in at the 
same time.  You won't have to 

07:12:25.212 --> 07:12:28.017
 worry about stepping on each 
oh, getting conflicting IDs or 

07:12:28.706 --> 07:12:31.848
 create ing some sort of 
timestamp on your phone, are 

07:12:31.939 --> 07:12:33.864
Firebase 
 does that for you.  You pass in

07:12:33.865 --> 07:12:39.224
 a ID you want.  In this 
 case we do a JSON, and then 

07:12:39.498 --> 07:12:44.873
text Google hello I/O.  Just 
 like that it instantly goes 

07:12:45.101 --> 07:12:47.414
into Firebase.  How do we 
 listen to the events as they 

07:12:47.704 --> 07:12:51.451
come in?  Firebase provides a 
 few event listener, one is 

07:12:51.559 --> 07:12:54.686
called Child added.  If you're 
 listening to the chat node, any

07:12:54.687 --> 07:12:56.512
 time there is a message 
 that comes under that, there is

07:12:56.513 --> 07:12:59.030
 a child node, you get 
 notified, almost 

07:12:59.342 --> 07:13:01.270
instantaneously.  You can do 
whatever you 

07:13:01.271 --> 07:13:04.295
 want s. in this case we're 
going to consult a log and write

07:13:07.905 --> 07:13:10.743
course, the realtime database is
 what we 

07:13:10.744 --> 07:13:13.172
 all know and love.  Firebase 
gives you a ton of features, 

07:13:13.680 --> 07:13:15.680
 stat       
 static testing Cloud based lab,

07:13:16.195 --> 07:13:20.330
 user op, remote config and, 
 of course, realtime database.  

07:13:20.331 --> 07:13:22.574
My favorite          favorite 
part you can 

07:13:22.575 --> 07:13:24.704
 pick and choose what you want. 
 You don't have to use all 

07:13:24.705 --> 07:13:27.320
 of the services.  Of so we're 
going to use static hosting, 

07:13:27.628 --> 07:13:31.148
 user auth and realtime database
 and use them with the 

07:13:31.149 --> 07:13:35.894
 Google Cloud Platform.
       So let's look at our 

07:13:36.203 --> 07:13:37.605
mock.
       &gt;&gt; Yes.  It's pretty 

07:13:37.606 --> 07:13:40.547
clear we're developers and not 
 designer, I think it's b

07:13:41.585 --> 07:13:42.578
eautiful in the way my mother 
think     

07:13:42.579 --> 07:13:46.316
 thinks I'm beautiful.  We just 
knocked this out in this HTM   

07:13:46.317 --> 07:13:49.983
 HTML.  We have a log in button,
 using Firebase you a thent 

07:13:49.984 --> 07:13:55.103
 case, 2016 it log in with 
Twitter, it makes it super 

07:13:55.412 --> 07:13:57.226
easy..
       Right below that he    we

07:13:57.227 --> 07:14:01.872
 can embed a you tube live 
stream, 

07:14:01.873 --> 07:14:04.490
 if you've played a video 
before, you're familiar with the

07:14:04.491 --> 07:14:06.407
 D 
 pad, up, down, left, right, 

07:14:06.408 --> 07:14:09.354
clicking on the buttons will 
 send the commands to Firebase. 

07:14:09.434 --> 07:14:11.954
 Of course, what would a 
 game be without a little trash 

07:14:12.067 --> 07:14:15.016
talk, so we're going to add 
 a chat box at the bottom.  Type

07:14:15.017 --> 07:14:17.346
 your message, hope yfl 
 something nice, and everyone 

07:14:17.640 --> 07:14:19.164
else will send it when you 
 submit.

07:14:19.165 --> 07:14:22.385
       &gt;&gt; So taking a look at 
application a   architecture 

07:14:22.491 --> 07:14:24.220
right 
 now.  It's pretty simple.  We 

07:14:24.221 --> 07:14:26.514
have all cliebt        client 
directly 

07:14:26.515 --> 07:14:31.066
 talking to Firebase.  In in    
     No serve er side mode.  The

07:14:31.067 --> 07:14:32.794
 comants are 
 pushed up to Cloud as well as 

07:14:32.795 --> 07:14:35.666
the chat messages.  Simple is 
 not crazy and you promise ed 

07:14:36.187 --> 07:14:37.798
crazy.
       &gt;&gt; Maybe a little crazy.

07:14:37.799 --> 07:14:40.839
       &gt;&gt; We need crazy.  This 
is not crazy enough for us.

07:14:40.840 --> 07:14:44.764
       &gt;&gt; That was fun.
       &gt;&gt; It was fun.kay.  Not 

07:14:45.101 --> 07:14:46.503
crazy.  Let's do something 
crazy.  

07:14:46.504 --> 07:14:48.783
 Let's run the game in one 
location, right.  So normally in

07:14:50.774 --> 07:14:52.887
 connected to Firebase.  
 It's sending update a, it's 

07:14:53.107 --> 07:14:55.641
receive willing date a, but it's

07:14:55.642 --> 07:14:59.159
 responsible for rendering the 
game on your Android device, 

07:15:00.655 --> 07:15:04.195
 ISO or desktop web, the client 
is responsible for genting 

07:15:04.196 --> 07:15:06.527
 the data and rendering and 
handle ing the game logic.  We 

07:15:06.744 --> 07:15:08.336
 wanted to do something 
different.  We're going to run 

07:15:08.337 --> 07:15:09.867
the 
 game in one location, so all 

07:15:09.868 --> 07:15:11.382
the commands come, it's render 

07:15:11.383 --> 07:15:13.834
 rendered in one place, and you 
can see how everyone is 

07:15:13.835 --> 07:15:16.849
 collaborate ing together. 
important to note that we're 

07:15:17.538 --> 07:15:19.538
also not building a 
 game, like this session is not 

07:15:19.576 --> 07:15:21.576
building a game using 
 Firebase.  The game is just 

07:15:21.691 --> 07:15:24.058
with a we happen to choose 
 because we thought it would be 

07:15:24.316 --> 07:15:26.658
fun and interesting and easy 
 to follow along.  But you can 

07:15:26.659 --> 07:15:28.582
imagine just sort of 
 collaborative environments 

07:15:28.583 --> 07:15:31.708
where people are sending in 
 signals disoontly to do edit 

07:15:31.914 --> 07:15:34.433
data or whatever you have.  It 
 would be applicable to a wide 

07:15:35.037 --> 07:15:37.985
variety of platforms.  We're 
 going to run this in something 

07:15:38.493 --> 07:15:40.575
called Google Compute Engine 

07:15:40.576 --> 07:15:43.218
 Engine.  It's our virtual 
machine offering.  We chose 

07:15:43.415 --> 07:15:46.054
 Windows of our flavor of 
virtual machine.

07:15:46.749 --> 07:15:50.311
       &gt;&gt; The Google Compute E
ngine is pretty cool.  We have 

07:15:50.494 --> 07:15:54.834
 data center        centers 
around the world to run VMs.  

07:15:54.835 --> 07:15:56.862
You have custom 
 machine type, so wiewr not 

07:15:56.972 --> 07:16:00.696
locked into 2, 4, 6, 18, you can

07:16:00.697 --> 07:16:05.147
 pick, 14, 10 CPUs.  Same with 
memory.  We're also very 

07:16:05.148 --> 07:16:09.371
 proud of about       billing.  
We do subhour bill      billing.

07:16:09.877 --> 07:16:12.714
  If you have 25 
 minutes you pay for 25 minute, 

07:16:12.715 --> 07:16:15.535
we don't round to a hour.  
 There is no recertificates 

07:16:15.638 --> 07:16:17.638
instances           instance 

07:16:17.988 --> 07:16:19.406
rereserve ins or anything like 
that, you 

07:16:19.407 --> 07:16:21.836
 Tuesday and get a discount, 
which is nice.  My favorite is 

07:16:22.230 --> 07:16:27.359
 how consistently fast they are.
  You can spin up 1,000 

07:16:27.360 --> 07:16:29.496
 Linux in like 5 minutes.  
Because of the isolation in data

07:16:31.000 --> 07:16:32.127
noise y neighbor problem that 
you 

07:16:32.128 --> 07:16:34.975
 have in a lot of Clouds.
       &gt;&gt; Let's take a look at 

07:16:35.128 --> 07:16:37.778
how you would create a 
 virtual machine on Google 

07:16:38.896 --> 07:16:45.050
Compute Engine.  First you 
 navigate to u. I      uI.  

07:16:45.051 --> 07:16:46.969
Click create instance.  This 
will bring up 

07:16:46.970 --> 07:16:49.803
 a dialogue with information we 
can fill out about the VM.  

07:16:49.804 --> 07:16:53.939
 For example, name, I'll name 
mine, mine Windows VM.  Below 

07:16:54.238 --> 07:16:56.683
 that we have different 
geographic zones and regions.  

07:16:56.684 --> 07:16:58.593
So 
 we've got zones and regions in 

07:16:58.594 --> 07:17:02.124
Europe, Asia, and the United 
 States.  I'll choose U.S.  Two 

07:17:02.326 --> 07:17:06.769
CPUs.  7.5 gigs of RAM and 
 then choose a operating 

07:17:07.172 --> 07:17:10.500
          operating system.  In 
this case Windows serve     

07:17:10.501 --> 07:17:14.053
 server 2012, data center 
edition.  Why not. to the power 

07:17:14.250 --> 07:17:16.661
of sped up video, the machine is

07:17:16.662 --> 07:17:18.800
 almost instantly create ed.  
It's not quite that fast in real

07:17:22.838 --> 07:17:24.544
button, you click it, there is a

07:17:24.545 --> 07:17:28.101
 Chrome browse er that lefts you
 remote desktop into your 

07:17:28.102 --> 07:17:31.111
 machine without installing any 
software or setting up 

07:17:31.112 --> 07:17:33.033
 configuration.  And look at 
that immediately we're in the 

07:17:33.034 --> 07:17:36.655
 virtual machine.  We also have 
a SSH in the browse er 

07:17:36.656 --> 07:17:38.582
 functionality for Linux 
distributions.

07:17:38.583 --> 07:17:41.530
       One other thing to point 
out about the UI, the link 

07:17:41.531 --> 07:17:45.866
 at the bottom says equivalent 
rest.  It's nice to use it to 

07:17:46.051 --> 07:17:49.691
 click around and     and says I
 want this OS and this much RAM 

07:17:50.391 --> 07:17:51.688
and 
 this much CPU.  If you need to 

07:17:51.689 --> 07:17:54.702
do that in a repeatable 
 programmatic manner, if you 

07:17:54.703 --> 07:17:58.260
have a application spinning up 
 or down serve ers or a script, 

07:17:58.643 --> 07:18:02.388
clicking that will give you a 
 HTTP post request that you can 

07:18:02.480 --> 07:18:06.731
send to the Google Cloud 
 platform API and preconfigure 

07:18:07.125 --> 07:18:10.960
ed with the settings you used 
 in the UI and same with the G 

07:18:11.041 --> 07:18:14.085
command line command.
       &gt;&gt; So of course, Google 

07:18:14.398 --> 07:18:16.315
Compute Engine is not the 
 only place invest to run your 

07:18:16.316 --> 07:18:19.016
code.  We have something we 
 like to call the computing 

07:18:19.542 --> 07:18:21.650
continuum.
       &gt;&gt; Continuum.

07:18:21.755 --> 07:18:24.217
       &gt;&gt; So on the far left we 
have, of course, 

07:18:24.218 --> 07:18:26.736
 infrastructure as a service.  
Now this is Compute Engine, 

07:18:26.737 --> 07:18:32.387
 raw Linux and Windows VMs, you 
can SSH in, you get full 

07:18:32.388 --> 07:18:34.465
 access.  You can run anything 
you want.  This is what you 

07:18:34.466 --> 07:18:37.235
 traditionally think about when 
you think VMs.  But as you 

07:18:37.236 --> 07:18:40.562
 move up that spectrum, you get 
container engine.  Now how 

07:18:40.563 --> 07:18:43.085
 many people here are playing 
with docker or docker 

07:18:43.086 --> 07:18:47.226
 containers?  A fair amount.
       So a container engine is 

07:18:47.227 --> 07:18:49.649
how similar mow we run 
 everything at Google, right, 

07:18:49.972 --> 07:18:52.280
con     containers.  Instead of 
SSH 

07:18:52.281 --> 07:18:57.035
 into the machine and manually 
manage it, you get a API for 

07:18:57.322 --> 07:19:00.385
 a cluster and that's a open-
source ed container management 

07:19:00.386 --> 07:19:03.183
 system.  It lets you manage 
docker applications on the 

07:19:03.184 --> 07:19:05.722
 cluster.  You can say how many 
you want, scale them up, it 

07:19:05.723 --> 07:19:08.243
 will keep them up, things like 
that.  You're manage ing 

07:19:08.244 --> 07:19:12.609
 applications in microservices 
instead of actually the raw 

07:19:12.610 --> 07:19:14.610
 infrastructure itself.
       And as we move up that 

07:19:14.907 --> 07:19:18.758
spectrum, we get App Engine.  
 So with App Engine, you just 

07:19:18.942 --> 07:19:21.895
write your code, upload it and 
 boom.  We worry about all 

07:19:22.292 --> 07:19:25.517
that      of that infrastructure
 stuff.  

07:19:25.518 --> 07:19:29.452
 Scale it for you, security 
patch ch   es, make sure it's up

07:19:29.453 --> 07:19:31.061
 and 
 returning.  It lets you focus 

07:19:31.062 --> 07:19:33.094
on application logic and 
 building a great app without 

07:19:33.688 --> 07:19:37.011
worrying about the operation 
 stuff underneath.  Finally we 

07:19:37.012 --> 07:19:39.131
have Cloud functions which 
 are currently in alpha.  So 

07:19:39.447 --> 07:19:42.184
these are with a we like to 
 call event-driven program 

07:19:42.274 --> 07:19:43.583
models.  Something happens in 
the 

07:19:43.584 --> 07:19:46.126
 Cloud and it triggers a 
function to run, against serve 

07:19:46.324 --> 07:19:47.933
erless 
 computing.  Something in 

07:19:47.934 --> 07:19:52.986
Firebase triggers a function or 
 likepubsub, Cloud storage, what

07:19:52.987 --> 07:19:55.408
 have you.  It can trigger 
 little functions to run and do 

07:19:55.513 --> 07:19:57.530
something without you worry     
 worrying about the 

07:19:58.543 --> 07:19:59.957
infrastructure.
       &gt;&gt; So now that we've got 

07:19:59.958 --> 07:20:02.182
the code running on the 
 serve er, how do we connect to 

07:20:02.579 --> 07:20:05.191
Firebase?  You're probably 
 familiar with the Firebase 

07:20:05.404 --> 07:20:09.958
client SDK for Android, IOS and 
 web.  If you use the technology

07:20:09.959 --> 07:20:13.581
 stack as Java or Java 
 script on the serve er you can 

07:20:13.582 --> 07:20:16.915
use the same SDK to connect to 
 Firebase.  If off text stack or

07:20:16.916 --> 07:20:19.847
 language not one of those, 
 we have third party, Python, PH

07:20:20.052 --> 07:20:25.109
P, riewber pearl               
Ru, about y, go, and C 

07:20:25.110 --> 07:20:28.342
 sharp.  They're third party, 
not supported by Google 

07:20:28.343 --> 07:20:33.093
 officially so your mileage may 
vary, but I encourage           

07:20:33.292 --> 07:20:35.413
enencourage you 
 to check it out.  If you have a

07:20:35.414 --> 07:20:39.050
 text stack not represented, 
 Firebase is a rest API.  If you

07:20:39.051 --> 07:20:42.695
 can make a REST request 
 post you can use to access 

07:20:42.967 --> 07:20:44.293
Firebase functionality, which is

07:20:44.294 --> 07:20:45.834
 awesome.
       &gt;&gt; In our case we're 

07:20:45.835 --> 07:20:51.581
going to be using Node.js and 
 iewtioning robot JS it's pretty

07:20:51.582 --> 07:20:54.511
 cool, let's you take 
 Node.js and translate to 

07:20:54.919 --> 07:20:56.719
keyboard commands.  In this case

07:20:56.720 --> 07:20:58.720
 we're going to connect to 
Firebase, use the same 

07:20:58.754 --> 07:21:00.473
connection 
 we used on the client, and go 

07:21:00.474 --> 07:21:03.005
to the command subtree.  
 Every time we get a up, down, 

07:21:03.203 --> 07:21:05.766
left, or right, all we're 
 going to do is send a keyboard 

07:21:05.860 --> 07:21:08.182
command to our game.  Our 
 game can be any game off the 

07:21:08.287 --> 07:21:11.027
shelf.  We're just going to 
 send the keyboard commands.  

07:21:11.028 --> 07:21:12.724
It's already Firebase enable ed.

07:21:12.725 --> 07:21:16.349
 Pretty cool.
       &gt;&gt; And we're going   ing 

07:21:16.350 --> 07:21:19.491
to livestream everything to You

07:21:19.492 --> 07:21:22.699
 Youtube.  It gives us the 
ability to encode the desktop.  

07:21:22.700 --> 07:21:25.346
 The entire desktop whatever is 
happening on it, we can live 

07:21:26.541 --> 07:21:31.537
 stream to You Tube.  As a bonus
 we can embed it in our game    

07:21:31.538 --> 07:21:33.849
 game.  As you play it and see 
the character respond to your 

07:21:34.155 --> 07:21:36.564
 commands, you see it respond to
 everyone elses command, 

07:21:36.565 --> 07:21:43.331
 they're all watching the same 
YouTube stream.  As a bonus 

07:21:43.332 --> 07:21:46.446
 free platform, you don't pay 
for ingress or egress charges 

07:21:46.650 --> 07:21:48.701
 which is really nice.
       &gt;&gt; If we take a look at 

07:21:48.702 --> 07:21:50.899
the architecture, we have the 
 client, again, speaking 

07:21:51.016 --> 07:21:52.618
directly to Firebase, pushing up

07:21:52.619 --> 07:21:55.455
 the chat and the command 
message, and then we have our 

07:21:56.008 --> 07:21:59.500
 Node.js process running on 
Windows VM and it's going to be 

07:21:59.501 --> 07:22:01.727
 taking the commands and relayi
ng it to the game, right.  

07:22:01.728 --> 07:22:03.747
 Then we're going to take the 
whole screen and encode it and 

07:22:03.846 --> 07:22:08.907
 send it up to YouTube live.  
Pretty cool.

07:22:09.207 --> 07:22:11.132
       &gt;&gt; Cool.
       &gt;&gt; But cool is not crazy.

07:22:11.133 --> 07:22:15.429
       &gt;&gt; Pretty crazy, huge 
multiplayer, same tain          

07:22:16.683 --> 07:22:19.681
 simultaneous game.
       &gt;&gt; Not crazy enough.

07:22:19.682 --> 07:22:21.799
       &gt;&gt; Let me think.  You 
know what I always thought, 

07:22:21.800 --> 07:22:24.645
 type ing is boring, what if we 
get rid of keyboard and 

07:22:24.646 --> 07:22:26.888
 buttons.  What if you could 
control this game with the 

07:22:26.889 --> 07:22:29.689
 power of your mind?
       &gt;&gt; Wait.  Wait.  What?

07:22:30.001 --> 07:22:33.738
       &gt;&gt; Just kidding, we don't
 have a mind-reading API.  

07:22:33.739 --> 07:22:39.193
 But we're the next best thing, 
Cloud cap     Speech API.  

07:22:39.194 --> 07:22:40.301
You've 
 probably seen similar 

07:22:40.302 --> 07:22:42.624
technology, as you talk it's 
 transcribe ing your spoken word

07:22:42.625 --> 07:22:45.572
 into text.  We talked a lot 
 yesterday during the key     

07:22:45.573 --> 07:22:47.981
keynote about Google assist.  
This is 

07:22:47.982 --> 07:22:51.017
 the same spech-to-text 
technology that powers all of 

07:22:51.723 --> 07:22:53.131
that 
 at Google using machine 

07:22:53.132 --> 07:22:55.352
learning.  It's just an API 
request 

07:22:55.353 --> 07:22:59.392
 in HTTP post request, so it 
needs technology stack, serve 

07:22:59.584 --> 07:23:01.219
er, 
 client, browse er, what have 

07:23:01.220 --> 07:23:04.144
you, it can take advantage of 
 Cloud speech API.

07:23:04.343 --> 07:23:08.071
       So like Bret said, it's a
 simple post request, in 

07:23:08.072 --> 07:23:12.317
 this case we're going o it 64 
encode the audio and then 

07:23:12.318 --> 07:23:14.731
 send it up.  That's pretty much
 all you have to do.  And 

07:23:14.732 --> 07:23:18.486
 you get back the transcript.  
And in this case how old is 

07:23:18.487 --> 07:23:21.074
 the Brooklyn bridge, 98% 
confident.

07:23:21.075 --> 07:23:22.917
       &gt;&gt; Are you asking me how 
would?

07:23:22.918 --> 07:23:24.622
       &gt;&gt; Am I asking you?  I 
don't know.

07:23:24.623 --> 07:23:28.149
       &gt;&gt; It's 146 years old.
       &gt;&gt; Thank you.  I did not 

07:23:28.150 --> 07:23:30.492
need to know that.
       &gt;&gt; So it's looking a lot 

07:23:30.589 --> 07:23:33.506
better.  We didn't magically 
 become designers but we took 

07:23:33.818 --> 07:23:36.640
advantage of material design 
 to kind of relay out and 

07:23:36.934 --> 07:23:38.675
reorganize our app.  Colors look

07:23:38.676 --> 07:23:40.633
 better, the design looks 
better.  You'll notice there is 

07:23:40.634 --> 07:23:42.398
no 
 D pad at all, there is no way 

07:23:42.399 --> 07:23:45.020
to control this, except by 
 clicking that button and speaki

07:23:45.240 --> 07:23:47.240
ng the command.  So instead 
 of pressing up and down and 

07:23:47.478 --> 07:23:51.423
left and right, you actually 
 say aloud, up, down, left, 

07:23:51.424 --> 07:23:52.753
right, and the game will respond

07:23:52.754 --> 07:23:55.556
 and send those commands up 
through Firebase.

07:23:55.867 --> 07:23:58.802
       So looking at your 
architecture, we again don't use

07:24:00.917 --> 07:24:04.344
speech API, the clients talk 
 directly to the Cloud Speech 

07:24:04.345 --> 07:24:06.466
API, get the transcript, send 
 it up to Firebase, and then 

07:24:06.467 --> 07:24:10.495
again, our Node.js application 
 running on Windows is going to 

07:24:10.818 --> 07:24:12.818
relay the commands to the 
 game and then live stream e

07:24:13.548 --> 07:24:19.680
verything to    to YouTube.
       &gt;&gt; But.  Come on, that's 

07:24:19.792 --> 07:24:22.013
a little bit more craze he 
 ee, like voice.

07:24:22.014 --> 07:24:25.053
       &gt;&gt; You can't be satisfy. 
 So how do we make this even 

07:24:25.246 --> 07:24:28.979
 more crazy ier?  What if, what 
if our game got so popular it 

07:24:28.980 --> 07:24:32.017
 was played around the world?
       &gt;&gt; What.  What do you 

07:24:32.018 --> 07:24:33.708
mean what if?
       &gt;&gt; I'm sorry.  Yes.  When

07:24:33.709 --> 07:24:37.248
 our game gets so popular, 
 it is played around the world. 

07:24:37.503 --> 07:24:40.805
 Well not everyone speaks 
 English.  So let's introduce a 

07:24:40.984 --> 07:24:43.523
multilingual support for our 
 app.  It will be awesome if I 

07:24:43.720 --> 07:24:46.452
could verbally speak in my 
 native tongue and it would 

07:24:46.852 --> 07:24:48.470
instantly be translate ed into 
the 

07:24:48.471 --> 07:24:51.499
 native tongue of everyone else 
who is playing this game in 

07:24:51.500 --> 07:24:54.138
 realtime.  And conversely as 
they spoke in their native 

07:24:54.139 --> 07:24:57.283
 tongue, it would show up on my 
screen in my language.  I 

07:24:57.284 --> 07:25:00.690
 think that's pretty crazy.
       So for that we use the 

07:25:00.894 --> 07:25:03.615
Google translate API.  You 
 probably used the Google 

07:25:04.427 --> 07:25:06.740
translate app or been to 
translate         

07:25:06.741 --> 07:25:10.672
 translate.google on the web you
 can type text and translate 

07:25:10.879 --> 07:25:13.258
 to English and paste in French 
and trans light to Jap        

07:25:13.408 --> 07:25:15.934
            translate to 
Japanese.  

07:25:15.935 --> 07:25:17.246
 Super          
 Super seize ee.  Now it's 

07:25:17.247 --> 07:25:19.871
available on the Google Cloud 
API 

07:25:19.872 --> 07:25:22.683
 to use your same machine 
technology in your application.

07:25:22.993 --> 07:25:26.024
       &gt;&gt; Again a simple HTTP 
request, is he end up the 

07:25:26.025 --> 07:25:31.179
 string and target language, 
which is espanol and we get 

07:25:31.180 --> 07:25:35.195
 back the translate ed text and 
we automatically detect the 

07:25:35.196 --> 07:25:36.943
 source language for you, which 
is really nice.

07:25:36.944 --> 07:25:38.757
       &gt;&gt; Awesome.
       &gt;&gt; So we have a lot more 

07:25:38.758 --> 07:25:42.289
machine-learning APIs.  One 
 I like to talk about is the 

07:25:42.891 --> 07:25:45.318
Cloud Vision API.  You get the 
 same power that Google photos 

07:25:45.528 --> 07:25:48.042
have, you send sup a photo 
 and you get very detailed 

07:25:48.637 --> 07:25:51.078
information like emotion 
 detection, object detection, OC

07:25:51.173 --> 07:25:56.313
R, all these kind of cool 
 stuff, again, with a simple 

07:25:56.527 --> 07:25:59.154
REST API call.  If you're using 
 tense letter flow today, you 

07:25:59.847 --> 07:26:03.503
can use Cloud machine learning 
 on our clusters so get the purr

07:26:03.504 --> 07:26:08.041
 of CPU, GP Us and TP Us 
 that we have in Google Cloud to

07:26:08.042 --> 07:26:10.062
 train your machine learning 
 models.

07:26:10.249 --> 07:26:12.686
       Believe me when I say 
there is more coming soon.

07:26:12.687 --> 07:26:14.918
       &gt;&gt; Sounds excite ing.  
Here is our architecture as it 

07:26:14.993 --> 07:26:18.230
 stands now.  Again, we've got 
client, tab lets, desktop, 

07:26:18.231 --> 07:26:21.577
 mobile, they are transcribe ing
 your spoken word, and then 

07:26:21.578 --> 07:26:24.800
 translate ing it, if necessary,
 using the translate API, sync 

07:26:27.037 --> 07:26:30.061
using Firebase, both to our 
 serve er, which is running 

07:26:30.961 --> 07:26:32.484
Node.js but also potentially 
every 

07:26:32.485 --> 07:26:35.010
 other client logged in using 
Firebase.  It's live streamed 

07:26:35.954 --> 07:26:40.948
 everything to YouTube to people
 around the world can watch.  

07:26:40.949 --> 07:26:44.084
 Why don't we do a little demo 
and show you the game we 

07:26:44.085 --> 07:26:47.018
 built so you can see the APIs 
in action.

07:26:47.226 --> 07:26:50.562
       I'm going to be playing 
on my desktop and Sandeep 

07:26:50.563 --> 07:26:53.264
 will play on his phone.  First 
I'll demonstrate the chat 

07:26:53.265 --> 07:26:58.004
 portion.  So let's see.  Hello 
and welcome to Google I/O.  

07:26:58.005 --> 07:27:00.246
 And look at that, almost 
instantaneously on the screen 

07:27:00.430 --> 07:27:04.063
you 
 can see hello and welcome to 

07:27:04.798 --> 07:27:08.102
Google I/O.  Almost as soon as 
 I finished talking.  Let's see 

07:27:08.400 --> 07:27:10.928
how it syncs through 
 Firebase.  Sandeep if you want 

07:27:11.742 --> 07:27:13.154
to reply.
        &gt;&gt; SANDEEP DINESH:  

07:27:13.155 --> 07:27:16.177
Everyone here is so cool.
        &gt;&gt; BRET McGOWEN:  You're

07:27:16.178 --> 07:27:19.112
 just pandering now.  You 
 see almost instantaneously it 

07:27:19.113 --> 07:27:22.432
showed up on the chat box.  
 Everyone here is so cool.  Now 

07:27:22.522 --> 07:27:24.522
let's try a different 
 language, let me switch from 

07:27:24.668 --> 07:27:31.004
English down to espa in, ol 
 and            nol and 

07:27:31.005 --> 07:27:33.539
 almost instantaneously it 
translates to Spanish and I see 

07:27:33.655 --> 07:27:36.071
 it in the original.  I'm not 
that great at Spanish so let 

07:27:36.164 --> 07:27:38.601
 me switch back to English.
        &gt;&gt; SANDEEP DINESH:  

07:27:38.602 --> 07:27:42.230
Wait.  I took span i        
Spanish in high 

07:27:42.231 --> 07:27:43.031
 school.
        &gt;&gt; BRET McGOWEN:  You're

07:27:43.032 --> 07:27:45.032
 the expert.
        &gt;&gt; SANDEEP DINESH:  Oh, 

07:27:45.540 --> 07:27:47.540
yeah.
        &gt;&gt; BRET McGOWEN:  (the 

07:27:47.697 --> 07:27:50.989
speaking Spanish).
        &gt;&gt; SANDEEP DINESH:  And 

07:27:51.114 --> 07:27:56.847
the classic spannic 10    
        span      Spanish 101 

07:27:57.260 --> 07:28:01.193
 phrase in realtime Bret you 
want to play the game.

07:28:01.194 --> 07:28:03.077
        &gt;&gt; SANDEEP DINESH:  
Let's play.  This is my windows 

07:28:03.078 --> 07:28:05.942
 remote desktop on the left.  
I'll click start and then 

07:28:05.943 --> 07:28:08.054
 explain the game.  The point of
 the game is to get the red 

07:28:08.055 --> 07:28:10.590
 dot in the bottom left corner 
to the finish line, which is 

07:28:11.107 --> 07:28:13.913
 the blue dot in the top right 
corner.  We're going to do 

07:28:13.914 --> 07:28:18.258
 this by verbally issue ing 
commands to the game 

07:28:18.565 --> 07:28:19.354
simultaneous            
 simultaneously to control the 

07:28:19.355 --> 07:28:22.096
character.  We have 5 minutes 
 in which to do that.  So let's 

07:28:22.197 --> 07:28:24.419
give it a whirl.
        &gt;&gt; BRET McGOWEN:  Let's 

07:28:25.125 --> 07:28:26.640
do it.
        &gt;&gt; SANDEEP DINESH:  Up, 

07:28:26.641 --> 07:28:30.875
right. right.  Right.
        &gt;&gt; SANDEEP DINESH:  Up, 

07:28:30.876 --> 07:28:34.198
up Bret up.
        &gt;&gt; SANDEEP DINESH:  Up.

07:28:35.710 --> 07:28:36.818
        &gt;&gt; BRET McGOWEN:  Up.
        &gt;&gt; SANDEEP DINESH:  Up.

07:28:36.819 --> 07:28:39.154
        &gt;&gt; BRET McGOWEN:  Right,
 up, up.

07:28:39.155 --> 07:28:41.575
        &gt;&gt; SANDEEP DINESH:  
There we go.  Up, up,.

07:28:41.576 --> 07:28:44.284
        &gt;&gt; BRET McGOWEN:  Up, 
left, left.

07:28:44.285 --> 07:28:46.212
        &gt;&gt; SANDEEP DINESH:  
Left?  What are you doing?

07:28:46.213 --> 07:28:48.720
        &gt;&gt; BRET McGOWEN:  I 
don't know.  Up.

07:28:48.721 --> 07:28:51.743
        &gt;&gt; SANDEEP DINESH:  
Right, right, right.

07:28:51.744 --> 07:28:55.796
        &gt;&gt; BRET McGOWEN:  Up?  
Oh, my God we suck at this.

07:28:55.797 --> 07:28:57.001
        &gt;&gt; SANDEEP DINESH:  We 
are really not good at this 

07:28:57.002 --> 07:28:58.711
 game.  That's all right.  I 
think that was fun.

07:28:58.712 --> 07:29:00.712
       (Applause).

07:29:04.869 --> 07:29:08.379
                     &gt;&gt; But, you
 know, fun is not crazy.

07:29:08.491 --> 07:29:10.524
       &gt;&gt; Oh, no.
       &gt;&gt; Yeah.

07:29:10.525 --> 07:29:12.744
       &gt;&gt; I don't like where 
this is headed.

07:29:12.745 --> 07:29:15.158
       &gt;&gt; You like it it.  We're
 going to make it crazy.  

07:29:15.159 --> 07:29:18.221
 Ladies and gentlemen, get out 
your phone and play, this 

07:29:18.222 --> 07:29:22.449
 includes you on the livestream.
  It's going to ask for geo   

07:29:22.450 --> 07:29:25.884
 geolocation, hit qle, I'll get 
into why later, of course if 

07:29:26.003 --> 07:29:29.033
 you're not comfortable, hit no.
  Get out your phone, come 

07:29:29.034 --> 07:29:31.657
 on, all get it out, we're going
 to make it loud in here.  

07:29:31.658 --> 07:29:35.713
 This is not going to work, but 
it's going to be fun.

07:29:35.821 --> 07:29:38.649
       &gt;&gt; This is definitely 
going to be crazy.  All right.

07:29:38.747 --> 07:29:41.161
       &gt;&gt; So we're going to 
restart the game and give the 

07:29:41.948 --> 07:29:46.911
 whole world 5 minutes to get 
Mr. red dot to Mrs. blue dot.  

07:29:46.912 --> 07:29:48.936
 5 minutes.
       &gt;&gt; All right.

07:29:48.937 --> 07:29:53.058
       &gt;&gt; All right.  We're 
going to give everyone a few    

07:29:53.059 --> 07:29:53.547
 seconds       
 seconds.

07:29:53.548 --> 07:29:55.789
       &gt;&gt; Raise your hand if 
anyone at all is on.

07:29:56.295 --> 07:29:58.913
       &gt;&gt; You might have notice 
ed the UI looks a little 

07:29:58.914 --> 07:30:01.320
 different.  We have a hold to 
speak button.  You press it 

07:30:01.321 --> 07:30:04.400
 down, you speak, are let it go,
 it will transcribe your 

07:30:04.401 --> 07:30:08.198
 text.  Some devices don't allow
 browse er support for the 

07:30:08.199 --> 07:30:13.349
 microphone.  So we have a Dpad,
 but yeah.  We can't build a 

07:30:13.457 --> 07:30:17.076
 native app in time and push it 
into the app store, I know.  

07:30:17.077 --> 07:30:24.119
 So unfortunately, PR said, no 
live chat.  Blame PR.

07:30:24.120 --> 07:30:26.175
       &gt;&gt; It was because I was 
swearing a lot in rehearsal 

07:30:26.176 --> 07:30:29.505
 and they thought, you know.
       &gt;&gt; They didn't trust us. 

07:30:29.602 --> 07:30:31.822
 All right.  So I think most 
 people are ready to go.  We're 

07:30:32.030 --> 07:30:36.377
going to give everyone 5 
 minutes.  3, 2, 

07:30:39.792 --> 07:30:44.224
1 -- what is this!.
       &gt;&gt; Oh, my God!

07:30:44.548 --> 07:30:48.950
       &gt;&gt; Wow!
       &gt;&gt; This is amazing!

07:30:49.058 --> 07:30:51.058
       &gt;&gt; (Laughing)

07:30:55.995 --> 07:30:57.705
.
       &gt;&gt; No.  Come on you're so

07:30:57.706 --> 07:31:01.055
 close! love it.  There is 
trolls in every crowd 

07:31:01.056 --> 07:31:02.662
 (Laughing).
       &gt;&gt; Who is trolling with 

07:31:02.663 --> 07:31:05.482
left?  Come an!
       &gt;&gt; It's beautiful.

07:31:05.483 --> 07:31:11.136
       &gt;&gt; You saw 4 minutes.  
This is chaos.  All right.  

07:31:11.137 --> 07:31:13.658
 Come on, you can do it!
       &gt;&gt; We're never going to 

07:31:13.659 --> 07:31:20.101
get out of this little -- oh,  

07:31:20.102 --> 07:31:21.931
 oh --
       (audience members 

07:31:21.932 --> 07:31:24.206
shouting).
       &gt;&gt; So many people hitting

07:31:24.207 --> 07:31:26.769
 left, this is amazing!
       &gt;&gt; It is.

07:31:26.770 --> 07:31:32.199
       &gt;&gt; Oh, we got out!.
       &gt;&gt; Remember to hold down 

07:31:32.316 --> 07:31:34.316
and let go.

07:31:36.948 --> 07:31:41.314
audience members shouting).
       &gt;&gt; Oh, so close!

07:31:41.501 --> 07:31:46.347
       &gt;&gt; This is intense.
       &gt;&gt; Oh, my God!  Oh, oh, 

07:31:46.348 --> 07:31:50.587
oh, !
       &gt;&gt; Almost!

07:31:51.406 --> 07:31:55.181
       &gt;&gt; Oh, !  Oh, !
       &gt;&gt; Wait.  It's in the 

07:31:55.182 --> 07:31:58.439
corner!
       &gt;&gt; How did that even 

07:31:58.440 --> 07:32:02.670
happen?
       &gt;&gt; So close!

07:32:02.671 --> 07:32:05.192
       &gt;&gt; Oh, it's right there. 
 It's right there!

07:32:05.394 --> 07:32:10.498
       &gt;&gt; Oh, my God!  Oh, !  
Our VM is overwhelmed, we should

07:32:12.635 --> 07:32:14.783
       &gt;&gt; I know.  Right.  This 
is amazing.

07:32:14.784 --> 07:32:16.790
       &gt;&gt; I don't even know 
what's going on.  I am like 

07:32:17.003 --> 07:32:17.504
lost    
 lost.

07:32:17.505 --> 07:32:20.032
       &gt;&gt; Any tips for them?
       &gt;&gt; Okay.  Everyone stop 

07:32:20.233 --> 07:32:22.959
except one person, how about 
 that (Laughing).

07:32:23.261 --> 07:32:27.186
       &gt;&gt; That will never work. 
 Oh, we're so far down now.

07:32:27.388 --> 07:32:30.315
       &gt;&gt; Oh, my God.  This is 
crazy.  I don't even know 

07:32:30.316 --> 07:32:32.355
 what's going on.
       &gt;&gt; Who else is using the 

07:32:32.550 --> 07:32:36.899
speech API?  Who got it 
 acetowork?  I               to 

07:32:37.183 --> 07:32:39.118
 work?
       &gt;&gt; I think it overwhelmed

07:32:39.119 --> 07:32:45.485
 the WiFi.  So I wrote this 
 game in Adobe Flash.  Let's 

07:32:45.561 --> 07:32:47.289
blank it.  That was ridiculous 

07:32:47.290 --> 07:32:51.634
 ridiculously crazy.  Round of 
aplawses for              a.

07:32:51.635 --> 07:32:57.089
       (Applause) 
                   applause for 

07:32:57.286 --> 07:32:59.286
everyone.  That 
 was crazy.  That was crazy.

07:32:59.530 --> 07:33:01.932
       &gt;&gt; That was amazing.
       &gt;&gt; But, come on, one more

07:33:01.933 --> 07:33:04.371
 thing, just for me, old 
 time sake?

07:33:04.453 --> 07:33:06.453
       &gt;&gt; Just a little bit.
       &gt;&gt; A little bit more 

07:33:06.485 --> 07:33:07.899
crazy?
       &gt;&gt; A little bit.  Okay.  

07:33:07.900 --> 07:33:10.134
So we'll do something a 
 little bit more crazy.  We're 

07:33:10.325 --> 07:33:13.092
going to talk about big data.  
 At Google we love big data, 

07:33:13.093 --> 07:33:16.296
it's in our DNA, we've been 
 doing it since day 1.  We have 

07:33:17.311 --> 07:33:20.629
a ton of tools to let you in 
 had interact with, pro serks 

07:33:21.038 --> 07:33:25.573
and analyze big data.  I'm 
 going to talk about big query. 

07:33:25.882 --> 07:33:29.718
 So big query is our data 
 analytica warehouse tool.  What

07:33:29.719 --> 07:33:34.872
 does that mean?  It means 
 you can upload, gigabyte, tare 

07:33:35.064 --> 07:33:42.004
a bytes into it, and using the 
 same scwel, the same sql you 

07:33:42.123 --> 07:33:44.342
already know.  It's a manage ed 
 service you don't have to worry

07:33:44.343 --> 07:33:46.278
 about scale ing 
 infrastructure or replicate ing

07:33:46.279 --> 07:33:47.903
 the data or worry about 
back    

07:33:47.904 --> 07:33:55.237
 backups or worry about how much
 ram              how much RAM 

07:33:55.342 --> 07:33:58.771
or CPU, you just upload 
 the data and as soon as it is 

07:33:59.694 --> 07:34:01.195
uploaded we can query.  Query 

07:34:01.196 --> 07:34:04.024
 Queries that used to take hours
 and days      days can now be 

07:34:04.144 --> 07:34:05.350
done 
 literally in seconds.

07:34:05.351 --> 07:34:08.561
       &gt;&gt; Pretty cool.  So 
again, thank you, guys, for that

07:34:08.562 --> 07:34:12.389
 meta      metadata, that geo 
location.  We basically 

07:34:12.390 --> 07:34:17.254
 collected from the client.  We 
used Google maps to get some geo

07:34:17.344 --> 07:34:20.275
 coding to get your city and 
state.  And browse er 

07:34:20.276 --> 07:34:23.703
 type and device type.  Simple 
metadata, in your application 

07:34:26.599 --> 07:34:29.469
temperature sensors coming 
 in, or how many people clicked 

07:34:29.856 --> 07:34:32.797
the red button versus green.  
 Things like that.  So thank 

07:34:32.798 --> 07:34:36.234
you, guys, for enable ing that.
ll right.  So here is the code, 

07:34:36.752 --> 07:34:39.891
how we got it 
 into Big inquiry.  It's pretty 

07:34:39.892 --> 07:34:42.698
straightforward.  First we 
 required the G Cloud client 

07:34:43.111 --> 07:34:46.534
library.  It is a client 
 library that wraps a lot of 

07:34:47.061 --> 07:34:49.373
Google Cloud Platform functions 
 in a nice sort of node-friendly

07:34:49.669 --> 07:34:53.884
 style.  We've got these 
 available for Ruby, Python, 

07:34:54.516 --> 07:34:57.548
Java and Go.  Rather than 
 making the HTTP requests 

07:34:57.614 --> 07:34:58.766
yourself you can use the library

07:34:58.767 --> 07:35:03.197
 in a manner familiar to you in 
those languages.e we require G 

07:35:03.297 --> 07:35:05.333
Cloud we're going to reference B
ig 

07:35:05.334 --> 07:35:08.951
 query and then dataset name.  
The dataset name is just the 

07:35:09.475 --> 07:35:13.193
 database name, essentially.  
Then we'll reference the table 

07:35:13.614 --> 07:35:15.734
 specifically.  So we have this 
child added listener, this 

07:35:15.735 --> 07:35:18.843
 is the same child added listen 
       listener we see early 

07:35:19.073 --> 07:35:21.073
ier.  This is 
 the app running on the windows 

07:35:21.173 --> 07:35:24.115
VM.  It's getting node fied 
 through child added.  It's 

07:35:24.326 --> 07:35:27.735
going to rely the keystrokes 
 into the game as you saw 

07:35:28.047 --> 07:35:30.262
and     after that it will be a 
table 

07:35:30.263 --> 07:35:34.406
 insert into Big query.  It's 
going to use snapshot.  This 

07:35:34.601 --> 07:35:37.545
 is the JSON payload.  This is 
the payload that has the 

07:35:37.546 --> 07:35:39.852
 command, and then, for example,
 city and state of where you 

07:35:40.280 --> 07:35:42.280
 executed the command.
       &gt;&gt; We had to 

07:35:42.502 --> 07:35:45.320
transform              
     Didn't have to transform 

07:35:45.527 --> 07:35:48.246
the Firebase data at all.
       &gt;&gt; Useful.  Then after 

07:35:48.654 --> 07:35:51.572
that you you can do post-     
 post-processing you want.

07:35:51.573 --> 07:35:55.272
       &gt;&gt; Once it's in had Big 
query it looks like any 

07:35:55.273 --> 07:35:58.177
 database.  You have columns and
 rows and you can write some 

07:35:58.386 --> 07:36:03.031
 SQL.  We have an API so you can
 programmatically interact 

07:36:03.032 --> 07:36:05.032
 with it as well.
       &gt;&gt; All right.  Speaking 

07:36:05.061 --> 07:36:08.493
of interaking,             
interacting let's take a 

07:36:08.494 --> 07:36:10.820
 look at the data we just 
inserted.  As you were playing 

07:36:10.914 --> 07:36:12.349
we 
 were but the         putting 

07:36:12.350 --> 07:36:14.944
the data into company cap big 
query.  It's 

07:36:14.945 --> 07:36:17.696
 live data.  So I'm going to do 
a select star, I know it's 

07:36:17.697 --> 07:36:20.635
 bad form but less type ing on 
stage, then let's see, let's do 

07:36:21.769 --> 07:36:25.477
 orld       
 order by timestamp descending. 

07:36:25.986 --> 07:36:29.907
 And then let's run that.  
 See what kind of data we get.

07:36:30.215 --> 07:36:33.648
       All right.  So we see -- 
okay.  So we've got a lot in 

07:36:33.967 --> 07:36:37.410
 mountainview, but then also in 
California and Utah.  Good 

07:36:37.411 --> 07:36:40.419
 job Utah playing along.  
Awesome.  And then again, it's 

07:36:40.754 --> 07:36:43.355
 just SQL.  So let's see what 
were the most common commands 

07:36:43.655 --> 07:36:46.192
 that people issue ed?  So I'm 
just going to do a count.

07:36:46.285 --> 07:36:49.240
       &gt;&gt; Okay.  If left wins 
I'm lost faith in humanity 

07:36:49.241 --> 07:36:50.928
 right now.
       &gt;&gt; There is a troll in 

07:36:50.929 --> 07:36:55.335
every crowd.  I'm just going 
 to group by command, run that. 

07:36:55.593 --> 07:37:01.350
 And you can see that, wow,  

07:37:01.351 --> 07:37:04.469
 wow -- (Laughing).
       You see number one was 

07:37:04.670 --> 07:37:06.670
right and number two is up.  
 It makes sense in had the 

07:37:06.896 --> 07:37:07.600
context of the game.  We're 
start     

07:37:07.601 --> 07:37:09.835
 starting in the bottom left 
corner of the game and trying 

07:37:09.951 --> 07:37:12.667
 to get to the top right.  So 
most commands would either be 

07:37:12.990 --> 07:37:16.105
 right or up.
       &gt;&gt; Trolls      Trolls, of

07:37:16.106 --> 07:37:18.819
 course, down and left.  Come 
on, guys.

07:37:18.820 --> 07:37:23.163
       &gt;&gt; Who was on team left, 
come on.  Yeah.  This guy 

07:37:23.164 --> 07:37:25.499
 here (Laughing).  All right.  I
 have a couple of other save    

07:37:25.500 --> 07:37:28.622
 saved query ies so we can take 
a look at that data.  Again, 

07:37:28.827 --> 07:37:31.969
 snags you ingest the data into 
Big query it is immediately 

07:37:31.970 --> 07:37:34.484
 available to query.  Let's see 
what kind of devices were 

07:37:34.485 --> 07:37:37.915
 people using?  Let's see.  Run 
this.  Another query -- oops    

07:37:37.916 --> 07:37:39.852
 oops. we go.
       &gt;&gt; Okay.  Most people 

07:37:39.853 --> 07:37:42.656
were on the phone.  We have 
 about 1, 200 clicks from a 

07:37:42.973 --> 07:37:46.120
desktop and a few people on a 
 tablet.  That's pretty cool. 

07:37:46.410 --> 07:37:49.340
tablets.
       &gt;&gt; Go tablet, team tabl

07:37:49.651 --> 07:37:50.975
et?
       &gt;&gt; I don't have a tab 

07:37:50.976 --> 07:37:52.880
let.
       &gt;&gt; Let's see by city.  

07:37:52.881 --> 07:37:55.404
I'm just going to do -- 
 another group by city and see 

07:37:55.609 --> 07:38:00.754
where we got. -- wow!  Look at 
at the city, let's go through 

07:38:00.962 --> 07:38:03.858
 them.  Hit next.
       &gt;&gt; Yeah.

07:38:04.366 --> 07:38:07.494
       &gt;&gt; Look at at the city 
ies.

07:38:08.813 --> 07:38:10.321
       &gt;&gt; Seattle.
       &gt;&gt; Thanks to everyone on 

07:38:10.322 --> 07:38:12.959
the livestream for playing 
 around, by the way.  That's 

07:38:13.267 --> 07:38:15.590
awesome.  We got a really good 
 international audience.  That's

07:38:15.591 --> 07:38:17.911
 awesome.
       &gt;&gt; You can see that data 

07:38:18.118 --> 07:38:20.729
came in live, right.  We 
 couldn't make this up if we 

07:38:21.126 --> 07:38:23.126
tried.  We probably could 
 though, but we didn't 

07:38:23.261 --> 07:38:25.984
(Laughing).  But yeah.  Wow!  
Shout 

07:38:25.985 --> 07:38:30.141
 out to all the guys on the live
 stream.  Thank you so much.

07:38:30.142 --> 07:38:31.436
       (Applause).
                     And of 

07:38:31.437 --> 07:38:33.961
course, everyone here as well.
       (Applause).

07:38:33.962 --> 07:38:36.280
                     &gt;&gt; So one 
thing I want to point out, you 

07:38:36.383 --> 07:38:37.920
might be 
 look will go at the query and 

07:38:37.921 --> 07:38:41.386
it says 179 seconds elapse ed, 
 you might be thinking for a few

07:38:41.387 --> 07:38:44.258
 hundred or a few thousand 
 rows it's not that fast.  

07:38:44.259 --> 07:38:47.579
You're right.  Big query is not 
 designed to be super performant

07:38:47.894 --> 07:38:51.137
 over small data set, it's 
 designed to be super fast over 

07:38:51.467 --> 07:38:54.101
huge datasets on the giga    
 gigabyte scale.  Don't use it 

07:38:54.317 --> 07:38:57.340
as a SQL date      database but 
if you 

07:38:57.341 --> 07:39:02.085
 want to dump a lot of data into
 it and query it.  Like log, 

07:39:03.497 --> 07:39:07.436
 like web logs, you can query 
massive amounts of data in a 

07:39:07.642 --> 07:39:10.437
 few seconds.  In fact, where it
 product came from at Google 

07:39:10.661 --> 07:39:16.630
 we needed to analyze all of our
 ads data, as you imagine, data 

07:39:16.717 --> 07:39:22.383
and Ads log data is humongous, 
it was taking hours 

07:39:22.384 --> 07:39:27.101
 and houring to run simple 
query.  We developed the 

07:39:27.102 --> 07:39:29.028
 technology that became Big 
query.

07:39:29.029 --> 07:39:32.661
       &gt;&gt; You can query tera 
bytes in seconds.

07:39:32.662 --> 07:39:35.772
       &gt;&gt; Literally in seconds.
       &gt;&gt; Imagine this game, we 

07:39:35.895 --> 07:39:38.795
played for two seconds and 
 generate ed all that data.  If 

07:39:39.010 --> 07:39:42.260
this game was running 24 hours 
 a day, 7 days a week, you can 

07:39:42.452 --> 07:39:44.160
imagine how much data we're 
 going to be generate ing, 

07:39:44.161 --> 07:39:46.324
right.  A normal database is 
going 

07:39:46.325 --> 07:39:50.252
 to be overwhelmed by that 
amount of data.  Big query is 

07:39:50.769 --> 07:39:52.769
 definitely whether         
where you want to store this 

07:39:52.779 --> 07:39:57.826
type of data. course that's not 
the only big data we have at 

07:39:58.514 --> 07:40:03.377
 Google.  We have Cloud -- you 
can get a fully bootstrapped 

07:40:03.378 --> 07:40:07.306
 includes der in 90 seconds.  If
 you're running Spark or HAD   

07:40:07.307 --> 07:40:10.665
 HADUP and want to move to the 
Cloud this is exactly built 

07:40:10.666 --> 07:40:14.406
 for you.  Then we have Cloud 
data flow, this is the next 

07:40:14.407 --> 07:40:18.337
 generation of map, with one API
 you can do batch, streaming 

07:40:18.338 --> 07:40:21.266
 and ETL.  We have open sources 
is as Apache bean and when 

07:40:21.267 --> 07:40:23.995
 you run on the Cloud, we do all
 the operations for you, the 

07:40:24.402 --> 07:40:26.611
 autoscale ing, instance, things
 like that.  Which is really 

07:40:26.837 --> 07:40:28.748
 nice.
       And for all the data a

07:40:28.749 --> 07:40:32.413
nalysts out there, we have 
 Cloud data lab, it lets you do 

07:40:32.708 --> 07:40:36.220
exploration and visual 
 analysis with open-source note

07:40:36.647 --> 07:40:38.872
wook          notebooks and died
 directly into 

07:40:38.873 --> 07:40:40.996
 machine leern                
              direct            

07:40:40.997 --> 07:40:43.004
 tied directly into 
 machine learning and big data 

07:40:43.127 --> 07:40:46.039
tools.
       &gt;&gt; Here is the final..  

07:40:46.040 --> 07:40:50.076
You have browse er, tablet, 
 desktops, mobile, listening to 

07:40:50.287 --> 07:40:53.097
verbal speech, using the 
 Cloud speech API, translate ing

07:40:53.098 --> 07:40:55.430
 back and forth from multiple 
 languages            

07:40:55.431 --> 07:40:57.476
 languages if necessary, syncing
 everything in realtime 

07:40:57.477 --> 07:40:59.776
 through Firebase to every other
 client and to our serve er, 

07:40:59.885 --> 07:41:02.808
 be which is running our game 
and node app.  Live streaming 

07:41:03.421 --> 07:41:08.578
 everything to YouTube and 
inserting into Big query where 

07:41:08.754 --> 07:41:09.373
it 
 is immediately available for 

07:41:09.374 --> 07:41:12.087
you to query and see what your 
 users are up to.

07:41:12.088 --> 07:41:13.424
       &gt;&gt; You know what is 
really crazy?

07:41:13.425 --> 07:41:16.831
       &gt;&gt; What?
       &gt;&gt; You know what?

07:41:17.033 --> 07:41:19.033
       &gt;&gt; The whole thing.
       &gt;&gt; We built the whole 

07:41:19.080 --> 07:41:21.715
thing in a week.  That was 
 really crazy.  Shows         

07:41:21.716 --> 07:41:24.329
Showses the power of Firebase 
and Google 

07:41:24.330 --> 07:41:27.958
 Cloud and how it makes building
 applications a little by 

07:41:27.959 --> 07:41:30.795
 the easy ier.  Check out 
Firebase at new home at 

07:41:31.492 --> 07:41:34.507
Firebase.         
 Firebase.google.com and we also

07:41:34.508 --> 07:41:40.362
 have two really cool You   
 Youtube chants the Google 

07:41:40.739 --> 07:41:44.076
developers channel?  How many 
 have subscribe ed            

07:41:44.077 --> 07:41:46.895
subscribe ed already?  Awesome. 
 And the Google platform 

07:41:46.896 --> 07:41:49.455
 channel, we have a ton of Cloud
 content coming out all the 

07:41:49.456 --> 07:41:51.427
 time.  If you're interested in 
learning more about Cloud, 

07:41:51.428 --> 07:41:54.547
 we have a lot for you to inter
act with here at I/O.  

07:41:54.548 --> 07:41:57.899
 Tomorrow our colleague is doing
 a session on big data, so 

07:41:57.900 --> 07:42:00.618
 he is already over here in the 
corner.  If you are at all 

07:42:00.619 --> 07:42:03.725
 interested in big data, we just
 hit, just the very tip of 

07:42:03.726 --> 07:42:07.284
 the iceberg of big data 
offerings in Google Cloud, check

07:42:07.285 --> 07:42:09.102
 it 
 out.  He's going to talk a lot 

07:42:09.103 --> 07:42:12.026
about the big data offerings 
 over the intellects 2016 

07:42:12.334 --> 07:42:14.039
datasets.
       &gt;&gt; That sounds scary.

07:42:14.040 --> 07:42:16.777
       &gt;&gt; No way I'm touching 
that.  So that is in stage 5 

07:42:17.069 --> 07:42:20.314
 tomorrow at 11:00 be sure to 
check it out.  Please stop by 

07:42:20.516 --> 07:42:23.632
 the code lab, we have a bunch 
of code labs for you to get 

07:42:23.633 --> 07:42:26.461
 your hands on Google Cloud 
Platform, interact, write sample

07:42:28.381 --> 07:42:30.217
being playing.
       &gt;&gt; Are we getting played 

07:42:30.218 --> 07:42:32.947
off the stage?  (Laughing).  
 So if you go to the code lab, 

07:42:33.552 --> 07:42:38.015
any machine you see, hop on, 
 we have the Cloud code lab, a 

07:42:38.407 --> 07:42:42.063
sandbox right out here to the 
 left spx Firebase             .

07:42:42.343 --> 07:42:45.066
       &gt;&gt; Firebase and Google 
Cloud are next to each other.

07:42:45.168 --> 07:42:47.998
       &gt;&gt; We have a emotion 
detector, can you make ee    

07:42:48.300 --> 07:42:49.816
emotions 
 and it colors your photo 

07:42:49.817 --> 07:42:52.960
depending on emotion.  And then 
 finally tomorrow at 9:00 a.m. 

07:42:53.247 --> 07:42:55.437
we have office hours at the 
 office hours tent, so we'd love

07:42:55.576 --> 07:42:58.303
 to hear what your questions 
 are about Cloud, what you're 

07:42:58.516 --> 07:43:00.835
doing with Cloud now, and then 
 any sort of interesting 

07:43:00.935 --> 07:43:02.852
projects you might have for us 
to 

07:43:02.853 --> 07:43:04.853
 talk about and see what we can 
do.

07:43:06.102 --> 07:43:06.685
       (Applause).
                     &gt;&gt; Thank 

07:43:06.686 --> 07:43:09.223
you.
       &gt;&gt; Thank you all so much.

07:43:19.173 --> 07:43:22.002
       &gt;&gt; What's up? question.

07:43:26.208 --> 07:43:28.208
music playing)

09:54:56.610 --> 09:54:58.610
much for coming.  If we could 
ask everyone to take their seats

09:54:58.902 --> 09:55:00.902
.  We are about to 

09:55:03.275 --> 09:55:06.767
get ready.  So have a seat. 

09:55:33.191 --> 09:55:35.731
 Last call.  If everyone would 
please take their seats.  Thank 

09:55:35.732 --> 09:55:39.314
you so much for coming.  We're 
super excited tonight.  We hope 

09:55:39.315 --> 09:55:42.737
you guys are, too.  I think 
congrats, you guys are all 

09:55:42.738 --> 09:55:45.429
nominees, .  This should be   
        should be a really fun 

09:55:45.430 --> 09:55:48.021
show.  Quick heads up, when we 
announce the winners, nobody 

09:55:48.022 --> 09:55:51.781
knows if they've won, so when we
 announce the winners tonight, 

09:55:52.244 --> 09:55:55.939
please approach the stage using 
the stairs over here.  Come on 

09:55:55.940 --> 09:55:57.932
up and receive your award.  I'll
 give you a warning.  It says 

09:55:57.933 --> 09:56:04.934
quite heavy, so get ready.    
You won't have to speak.  Do 

09:56:04.935 --> 09:56:05.906
your thing.  There will be
               There will be a 

09:56:05.907 --> 09:56:09.216
photographer taking pictures.  
Feel free to just exit back on 

09:56:09.217 --> 09:56:12.656
the side of the stage again.  
Once you exit, we'll have a host

09:56:12.946 --> 09:56:16.782
 over here, and she can take 
your award.  Take it to the back

09:56:16.783 --> 09:56:19.327
 and then after the ceremony 
we'll connect with you guys, so 

09:56:19.328 --> 09:56:21.728
if you want to take it with you,
 or if you want us to ship it 

09:56:21.729 --> 09:56:23.729
back to you, we can just connect
 afterwards

09:56:30.284 --> 09:56:32.284
:  Any questions

09:56:42.148 --> 09:56:44.516
?   
&gt;&gt; Anybody using this 

09:56:44.694 --> 09:56:47.444
microphone, if you could keep it
 in this position, and you could

09:56:48.197 --> 09:56:50.433
 project a little bit, because 
we are told there might be quite

09:56:50.629 --> 09:56:53.845
 some extraneous noise outside. 
 It would just help with the 

09:56:53.846 --> 09:56:55.846
volume level.  Thanks very much

09:58:18.694 --> 09:58:20.694
: 

10:02:21.873 --> 10:02:23.873
      Awards

10:08:23.559 --> 10:08:28.397
. 
&gt;&gt;      . 

10:08:28.398 --> 10:08:30.398
&gt;&gt;

10:08:52.736 --> 10:08:56.690
&gt;&gt; 7:00              
 #

10:09:05.462 --> 10:09:07.462
 7:00    

10:09:33.755 --> 10:09:35.755
&gt;&gt; 
&gt;&gt;

10:12:07.210 --> 10:12:10.137
                 Please take 
your seats.  The program will 

10:12:10.138 --> 10:12:12.138
begin shortly. 

10:15:29.583 --> 10:15:31.583
               2016 Google play 
awards

10:15:35.696 --> 10:15:38.671
.    
Please welcome Purnima Kochikar,

10:15:39.355 --> 10:15:47.646
 head of apps and games BD, 
Google play    Play. 

10:15:47.647 --> 10:15:54.022
&gt;&gt; PURNIMA KOCHIKAR:  Good 
evening.  How's everyone doing? 

10:15:54.023 --> 10:15:55.735
(Applause) 
&gt;&gt; PURNIMA KOCHIKAR:  Welcome to

10:15:55.736 --> 10:16:00.530
 the first ever Google play 
awards

10:16:05.758 --> 10:16:08.676
.  Since we announced this 
program about a couple weeks ago

10:16:08.994 --> 10:16:12.148
, there has been incredible 
excitement from the developer 

10:16:12.149 --> 10:16:15.051
community and the press from all
 around the world.  This would 

10:16:15.052 --> 10:16:19.639
not be possible without you and 
your work.  So give yourself a 

10:16:19.640 --> 10:16:21.640
big round of applause.  
(Applause)

10:16:29.865 --> 10:16:35.435
 accomplished together since we 
launched Google play,     

10:16:35.594 --> 10:16:37.458
Play           Google Play, it's
 pretty amazing.  And the 

10:16:37.459 --> 10:16:40.223
momentum isn't       isn't 
letting up.  Your apps and games

10:16:40.579 --> 10:16:45.086
 now reach a billion users every
 month through play app, 

10:16:46.213 --> 10:16:50.942
and               play car    
    Play, and they're driving 50

10:16:50.943 --> 10:16:55.418
 billion downloads in 2016 alone
.  Pretty amazing, isn't       

10:16:55.419 --> 10:16:58.342
isn't it?
(Applause)  

10:16:58.343 --> 10:17:02.685
Each day my team and I have the 
privilege of working with you to

10:17:02.686 --> 10:17:07.570
 help you build successful 
mobile businesses and each day 

10:17:07.571 --> 10:17:13.919
you use the platforms and tools 
we provide to create apps and 

10:17:13.920 --> 10:17:16.969
games that amaze and inspire us.

10:17:16.970 --> 10:17:22.452
Tonight we take the time to 
celebrate you and the great work

10:17:22.726 --> 10:17:30.357
 you have done over the last 
year.  Tonight we honor ten 

10:17:30.358 --> 10:17:32.358
examples of outstanding 
achievement

10:17:39.498 --> 10:17:41.397
. 
(Applause)  

10:17:41.398 --> 10:17:45.327
So let's get the show started, 
shall we?  All right.  

10:17:45.328 --> 10:17:47.328
(Laughter)

10:18:19.774 --> 10:18:24.778
welcome Bob Meese, head of games
 BD, Google Play

10:18:33.734 --> 10:18:35.734
.  
(Applause) Bobs      

10:18:36.232 --> 10:18:36.864
              .  
(Applause) 

10:18:36.865 --> 10:18:40.261
&gt;&gt; Bob Meese        OB MEESE:  
Hi, everyone.  What a great 

10:18:40.262 --> 10:18:44.888
crowd.  This is a lot of fun.  
Indies provide fun, deep, 

10:18:44.889 --> 10:18:50.580
meaningful experiences, spanning
 games of all genre.  They prove

10:18:51.446 --> 10:18:54.762
 that developers of any size can
 succeed on Android.  I judged 

10:18:55.475 --> 10:18:57.475
the first Google Play Ind

10:18:59.964 --> 10:19:03.795
ie festival last month.  We're 
thrilled to support this 

10:19:03.796 --> 10:19:08.698
community and it's so important 
to us.  We have the Indie corner

10:19:08.876 --> 10:19:15.382
, which is a dedicated 
collection of indie games we 

10:19:15.383 --> 10:19:19.885
support.  Look at the nominee. 
&gt;&gt; Stand out indie nominee are 

10:19:19.886 --> 10:19:21.886
Alpha Bear

10:19:28.328 --> 10:19:37.695
, Alto's    to's adventure 
        Adventure, fast    Fast 

10:19:38.608 --> 10:19:40.608
like    Like a fox 

10:19:46.447 --> 10:19:48.447
  Fox, Kink

10:20:00.562 --> 10:20:03.213
o.   
Stand

10:20:14.922 --> 10:20:16.922
 Are you ready? 

10:20:27.759 --> 10:20:28.386
Alpha Bear. 
(Applause) 

10:20:28.387 --> 10:20:30.387
(Applause)

10:20:45.002 --> 10:20:50.872
&gt;&gt; Best use of Google Play game 
services

10:20:55.645 --> 10:20:59.662
.
&gt;&gt;      For the next award, 

10:21:00.185 --> 10:21:02.525
increase competition on Google 
Play that help create a great 

10:21:02.526 --> 10:21:06.129
community of gamers, with 
features like multiplayer and 

10:21:06.130 --> 10:21:09.195
leader boards, they help keep 
gamers engaged and keep them 

10:21:09.196 --> 10:21:13.414
coming back for more.  All the 
nominees in this category 

10:21:13.415 --> 10:21:17.605
integrated multiple Google Play 
game features that enhanced the 

10:21:17.606 --> 10:21:20.826
overall user experience.    
Let's take a look at the 

10:21:21.138 --> 10:21:24.611
nominees.
&gt;&gt; Best use of Google Play games

10:21:24.764 --> 10:21:28.361
 services nominee are sea   Sea 
battle   

10:21:34.080 --> 10:21:36.080
   Battle 2, table     Table 
tennis      Tennis touch

10:21:36.943 --> 10:21:38.943
     Touch

10:21:43.058 --> 10:21:45.058
,

10:21:47.863 --> 10:21:50.704
 cat adventures              Cat
 Adventures              Cat 

10:21:50.705 --> 10:21:55.594
Adventures, power     tower 
matted        madness         

10:21:55.794 --> 10:21:59.707
    Tower Madness             T
ower Madness 2.   

10:21:59.708 --> 10:22:01.708
So 
many                           

10:22:03.276 --> 10:22:05.276
 Tower Madness 2.   

10:22:06.776 --> 10:22:08.776
Zombie Highway 2  .  
Best use of Google Play game 

10:22:08.920 --> 10:22:12.605
services.
&gt;&gt; All right.  For the next one,

10:22:12.606 --> 10:22:16.855
 what are               one, can
 we have an applause for the 

10:22:16.856 --> 10:22:18.904
nominees?  All right.  Cool. 
(Applause)  

10:22:18.905 --> 10:22:23.763
And the winner is:  Table tennis
      Tennis touch 

10:22:27.191 --> 10:22:29.191
    Touch.  
(Applause)

10:23:25.418 --> 10:23:34.970
 Please welcome Larissa Fontaine
, head of apps BD, Google Play. 

10:23:34.971 --> 10:23:36.971
(Applause) 

10:23:38.561 --> 10:23:40.641
&gt;&gt; LARISSA FONTAINE:  So having 
recently finished a home 

10:23:41.236 --> 10:23:44.474
improvement project, I used even
 more new apps than I usually 

10:23:44.475 --> 10:23:48.643
do, which is kind of a lot.  It 
was incredible with the adoption

10:23:49.030 --> 10:23:54.801
 of material design how quickly 
I was able to navigate and find 

10:23:54.802 --> 10:23:59.185
recommendations and ideas in 
well-designed apps.  They were 

10:23:59.186 --> 10:24:03.659
enjoyable, intuitive, and helped
 me find exactly what I was 

10:24:03.660 --> 10:24:08.239
looking for without having to 
hunt and peck.  It's not just 

10:24:08.240 --> 10:24:12.695
home improvement apps.  Over one
 million apps have adopted 

10:24:12.696 --> 10:24:15.760
material design elements in just
 the last two years since we 

10:24:15.761 --> 10:24:21.791
announced them.  This year's  's
 nominees represent first class 

10:24:21.792 --> 10:24:28.675
material design implementations 
across many categories.  And the

10:24:28.676 --> 10:24:33.991
 nominees are. 
&gt;&gt; Best use of material design 

10:24:33.992 --> 10:24:36.682
nominees are

10:24:41.613 --> 10:24:49.065
:  Bring, fab awe us            
, fab you         , fabulous

10:24:50.199 --> 10:24:52.199
        Fabulous, 

10:24:59.809 --> 10:25:01.809
Robinhood,

10:25:03.457 --> 10:25:05.986
 to Do list, Viv    

10:25:13.410 --> 10:25:15.410
 Vivo.  Best use of material 
design

10:25:18.145 --> 10:25:18.865
.  
&gt;&gt; LARISSA FONTAINE:  And the 

10:25:18.866 --> 10:25:20.866
winner is:  Robinhood

10:25:49.668 --> 10:25:50.177
. 
(Applause) 

10:25:50.178 --> 10:25:52.178
&gt;&gt; Standout 

10:25:57.111 --> 10:25:59.111
start-up

10:26:04.552 --> 10:26:06.818
. 
(Laughter)   

10:26:06.819 --> 10:26:12.246
I'm still here.  Similar to our 
focus on indie, this year we are

10:26:12.247 --> 10:26:14.871
 putting start-up developers 
front and center.  As we talked 

10:26:14.872 --> 10:26:17.866
about a couple times over the 
last two days, we have launched 

10:26:17.867 --> 10:26:21.594
an early access program for apps
 that are still in beta to 

10:26:21.809 --> 10:26:24.866
connect developers with a 
community of early adopters to 

10:26:25.181 --> 10:26:28.910
get great feedback early in your
 development.    

10:26:28.911 --> 10:26:33.676
We are consistently amazed with 
the incredible funnel of fresh 

10:26:33.677 --> 10:26:37.474
and unique experiences coming 
from lean teams, and this group 

10:26:37.475 --> 10:26:42.904
of nominees represent incredible
 startups from across the 

10:26:43.899 --> 10:26:45.683
ecosystem.  And the nominees are

10:26:45.684 --> 10:26:51.118
&gt;&gt; Standout start-up, nominees 
are: 

10:26:56.692 --> 10:26:58.692
 DubSmash, Hopper

10:27:05.548 --> 10:27:07.548
, musically         Musically

10:27:12.325 --> 10:27:14.325
 Robinhood

10:27:34.138 --> 10:27:39.621
      , Robinhood, .   
And the winner is:  Hopper. 

10:27:39.622 --> 10:27:41.622
(Applause)

10:28:20.299 --> 10:28:22.299
.   
(Music)

10:28:44.846 --> 10:28:52.357
welcome bench Galbraith       
          Ben gal     Galbraith,

10:28:55.773 --> 10:29:00.264
developer of product group.  
(Applause) 

10:29:00.265 --> 10:29:04.416
&gt;&gt; BEN GALBRAITH:  Last may we 
opened a dedicated

10:29:09.516 --> 10:29:12.229
 category based on age and 
popular characters.  As the 

10:29:12.230 --> 10:29:17.285
father of eight young children, 
all one wife, all one at a time,

10:29:17.629 --> 10:29:21.114
 this section is enormously 
popular in our household.  We 

10:29:21.115 --> 10:29:24.755
love these apps.  Let's take a 
look at the nominees.

10:29:24.756 --> 10:29:33.868
&gt;&gt; Best families app nominee as 
are:  Card wars    Wars, 

10:29:33.869 --> 10:29:41.074
adventure         Adventure time
    Time, Lego Jur     o 

10:29:41.075 --> 10:29:45.478
Jurassic          o Jurassic 
world     World, my  My very 

10:29:45.649 --> 10:29:47.649
   Very hungry      Hungry c  

10:29:51.143 --> 10:29:54.326
 Cater       Caterpillar  ar, 
Thinkrolls

10:30:00.877 --> 10:30:02.877
 2, Tok

10:30:06.008 --> 10:30:11.262
a Natur       a Nature.  Best 
families app.  

10:30:11.263 --> 10:30:13.954
&gt;&gt; BEN GALBRAITH:  And the win
ner is:  Thinkrolls

10:30:43.811 --> 10:30:44.111
 2. 
(Applause) 

10:30:44.112 --> 10:30:46.112
&gt;&gt; Most innovative

10:30:49.250 --> 10:30:51.091
.  Sgloebz         
&gt;&gt; BEN GALBRAITH:  The most 

10:30:51.092 --> 10:30:54.836
innovative category highlights 
the apps and games that bring 

10:30:54.837 --> 10:30:58.256
the wow moments that demonstrate
 something truly new and unique.

10:30:58.257 --> 10:31:01.543
  This can come in the form of 
new controls for a game based on

10:31:01.544 --> 10:31:04.125
 the latest sensors, or it could
 be             it could be deep

10:31:04.429 --> 10:31:07.913
 personalization that gives you 
an intimate, emotional 

10:31:07.914 --> 10:31:11.623
connection to the experience.  
In whatever form it comes, 

10:31:11.624 --> 10:31:17.176
innovation can transform 
something ordinary into 

10:31:17.177 --> 10:31:20.774
something immer       immersiv
          immersive, all in the 

10:31:20.775 --> 10:31:23.782
babel device that 
                         in the 

10:31:23.783 --> 10:31:26.601
mobile device that fits in the 
palm of your hand.

10:31:26.602 --> 10:31:32.665
&gt;&gt; Most innovative nominees are:
  Fabulou  

10:31:37.805 --> 10:31:46.925
ous, Fast space       like   
 Like a fox

10:31:48.143 --> 10:31:54.168
   Fox, New York Times VR, smart
     Smart news 

10:31:58.969 --> 10:32:02.549
   News, this    This war   War 
of mine    Mine

10:32:08.491 --> 10:32:10.672
, .   
Most innovative. 

10:32:10.673 --> 10:32:15.881
&gt;&gt; BEN GALBRAITH:  The winner is
 New York Times VR. 

10:32:15.882 --> 10:32:17.882
(Applause)

10:33:14.777 --> 10:33:19.317
welcome Sameer Samat, VP product
 management

10:33:34.018 --> 10:33:35.835
Google Play. 
(Applause)  realizing now that 

10:33:35.836 --> 10:33:40.245
many of you did not get the memo
 on the appropriate dress code 

10:33:40.246 --> 10:33:46.464
for this evening's  's attire.  
You're forgiven, however. 

10:33:46.465 --> 10:33:49.160
(Laughter)   
Tiptoed look my best        

10:33:51.825 --> 10:33:56.016
honor of some of the great he 
have        est developers in 

10:33:56.017 --> 10:33:57.443
the world. 
(Applause)  

10:33:57.444 --> 10:33:59.794
One of the favorite parts of my 
job is watching developers take 

10:33:59.795 --> 10:34:05.083
a new design or an ancient 
technology and take experiences 

10:34:05.084 --> 10:34:08.288
that are truly changing people's
 lives.  The apps and the games 

10:34:08.289 --> 10:34:13.266
that they create offer a service
, piece of functionality, or an 

10:34:13.267 --> 10:34:18.636
entirely new experience that is 
truly inspiring and amazing.    

10:34:18.637 --> 10:34:21.888
Being an early adopter is really
 hard.  It means challenging the

10:34:22.257 --> 10:34:24.422
 status quo.  It means pushing 
your team in different 

10:34:24.423 --> 10:34:30.018
directions.  These are all 
things that we at Google truly 

10:34:30.019 --> 10:34:32.550
admire in this year's  's 
nominees.  Let's take a look.

10:34:32.551 --> 10:34:36.103
&gt;&gt; Early adopter nominees are:  
Glide

10:34:44.577 --> 10:34:48.253
, mechanic        Mechanic 
estate      Estate

10:34:53.770 --> 10:35:01.726
, Minecr        Minecraft story
     Story mode    Mode, 

10:35:02.200 --> 10:35:05.806
world     World around     
 Around me  Me

10:35:11.991 --> 10:35:13.991
, Thu 

10:35:17.825 --> 10:35:19.825
umper.    
Early adopter

10:35:21.610 --> 10:35:22.713
.  
&gt;&gt; SAMEER SAMAT:  And the winner

10:35:22.714 --> 10:35:27.543
 this year in the early adopter 
category is world     World 

10:35:27.544 --> 10:35:29.544
around      Around me  Me

10:36:03.318 --> 10:36:11.584
                                                                                                                     Zumper.

10:36:03.318 --> 10:36:06.518
Early adopter.  
&gt;&gt; SAMEER SAMAT:  And the winner

10:36:03.318 --> 10:36:07.384
 this year in the early adopter 
category is World Around Me. 

10:36:03.318 --> 10:36:06.534
(Applause) 
&gt;&gt; Go global.  

10:36:06.535 --> 10:36:09.937
&gt;&gt; SAMEER SAMAT:  Given how 
popular Android devices are 

10:36:09.938 --> 10:36:14.545
around the world, we often get 
asked by developers, how do I 

10:36:14.546 --> 10:36:17.821
make a successful entry into a 
new market?  Many people think 

10:36:17.822 --> 10:36:22.243
that localizing an app means 
taking an app from one          

10:36:22.244 --> 10:36:24.043
from one language to another, 
but it's so much more than that.

10:36:24.044 --> 10:36:28.078
  For an app to feel truly 
successful in a different 

10:36:28.079 --> 10:36:32.564
country, users there need to 
believe that it was built for 

10:36:32.565 --> 10:36:37.851
them.  This is all about colors 
and character chases        

10:36:37.852 --> 10:36:39.255
choices and contextual relevance
 as well as language.  It's 

10:36:39.256 --> 10:36:42.544
really hard to do       to do.  
And so this year we wanted to 

10:36:42.545 --> 10:36:46.016
honor a set of developers that 
exemplify what great 

10:36:46.017 --> 10:36:48.863
localization looks like.  The 
nominees are. 

10:36:48.864 --> 10:36:52.447
&gt;&gt; Go global nominees are:  
Dragon

10:36:57.377 --> 10:37:01.511
 Doken battle 

10:37:16.083 --> 10:37:16.429
     Battle             
                                      ,

10:37:16.430 --> 10:37:19.153
Dragon Doken Battle music    
 Music smash

10:37:24.940 --> 10:37:31.676
, Pokemon shuffle       Shuffle 
mobile      Mobile, Fr    

10:37:31.677 --> 10:37:36.818
Freeletic           Freeletics 
body    Body weight, go

10:37:39.845 --> 10:37:41.845
 global. 
&gt;&gt; SAMEER SAMAT:  And the winner

10:37:43.671 --> 10:37:46.656
 in the go global category, 
Pokemon Shuffle mobile

10:37:46.922 --> 10:37:48.922
      Mobile

10:38:06.782 --> 10:38:09.319
.  
(Music) 

10:38:09.320 --> 10:38:11.320
(Applause)

10:38:40.149 --> 10:38:44.227
Jaimie Rosenberg, 

10:38:47.413 --> 10:38:49.213
VP Google Play. 
(Applause) 

10:38:47.413 --> 10:38:53.167
&gt;&gt; JAIMIE ROSENBERG:  Hi, 
everyone.  It's incredibly 

10:38:53.168 --> 10:38:56.043
humbling just looking out at 
this room.  It's incredibly 

10:38:56.044 --> 10:39:00.762
humbling as a reminder to see 
how far our Android developer 

10:39:00.763 --> 10:39:03.563
community has come since we 
first launched the platform back

10:39:05.076 --> 10:39:08.357
 in 2008.  We're now at the 
final two award categories of 

10:39:08.358 --> 10:39:12.869
the night, best app, and best 
game.  The nominees in these 

10:39:12.870 --> 10:39:15.729
categories are true examples of 
the amazing work being done by 

10:39:15.730 --> 10:39:20.964
all of you and our Android 
developers all over the world.  

10:39:23.694 --> 10:39:26.338
 the award for best app.  
Whether you're looking for a 

10:39:26.339 --> 10:39:30.823
recipe, ideas for a home remodel
, or ways to stay informed or 

10:39:30.824 --> 10:39:35.074
entertained, the nominees 
managed         in this category

10:39:35.075 --> 10:39:37.973
 make your day more productive 
and more fun.  They serve their 

10:39:37.974 --> 10:39:41.531
users in different ways, but 
what they all have in common is 

10:39:41.532 --> 10:39:46.444
great design, intuitive user 
experience, and broad appeal.  

10:39:46.445 --> 10:39:50.950
Let's take a look at the 
nominees for best app.

10:39:50.951 --> 10:39:54.625
&gt;&gt; Best app nominees are

10:40:12.952 --> 10:40:14.952
:  Houzz

10:40:16.381 --> 10:40:18.381
, tune    Tune In radio

10:40:21.281 --> 10:40:28.687
     Radio, Buzz      BuzzFeed
          BuzzFeed, Col     

10:40:28.688 --> 10:40:30.688
Color       Colorfy

10:40:48.552 --> 10:40:51.567
. 
&gt;&gt; SAMEER SAMAT:  And the winner

10:40:51.568 --> 10:40:53.812
 for the best app is:  Houzz

10:41:03.623 --> 10:41:06.242
. 
(Applause).  Congrats           

10:41:07.462 --> 10:41:09.285
              . 
(Applause)  

10:41:09.286 --> 10:41:11.286
Congrats, guys.  Well done

10:41:42.891 --> 10:41:45.799
.
&gt;&gt; Best game. 

10:41:45.800 --> 10:41:47.800
(Applause)

10:41:52.593 --> 10:41:56.054
to try that one at home later.  
(Laughter)   

10:41:56.055 --> 10:42:00.300
This year's  's nominees for 
best game gave everyone a reason

10:42:00.861 --> 10:42:04.262
 to be a gamer, from big screen 
characters to small screen heros

10:42:04.605 --> 10:42:09.351
, from puzzles to clans to 
battles, these nominees connect 

10:42:09.352 --> 10:42:13.320
and delight users everywhere.  
They're also a ton of fun.  They

10:42:13.321 --> 10:42:16.569
 also tend to showcase the very 
best of what an droid device can

10:42:17.676 --> 10:42:21.371
 do.  So let's take a look at 
the nominees for bifida game 

10:42:21.372 --> 10:42:24.194
&gt;&gt; Best                    
       for best game 

10:42:24.195 --> 10:42:27.151
&gt;&gt; Best game nominees are:  
Alpha Bear

10:42:32.444 --> 10:42:34.557
, clash     Clash of kings     

10:42:43.359 --> 10:42:45.359
Kings, clash

10:42:47.003 --> 10:42:54.758
       clash       clash    
 Clash Royale, marvel      

10:42:55.605 --> 10:43:01.641
Marvel future      Future fight 
    Fight, Star Wars, galaxy    

10:43:01.964 --> 10:43:07.489
  Galaxy of heros     Heros.  
Best game.  

10:43:07.490 --> 10:43:09.560
&gt;&gt; JAIMIE ROSENBERG:  And the 
winner of the Google Play award 

10:43:09.561 --> 10:43:15.376
for best game is:  Clash

10:43:20.946 --> 10:43:22.946
 Royale

10:43:26.419 --> 10:43:28.419
. 
(Applause)

10:43:44.165 --> 10:43:47.603
stage Purnima Kochikar.

10:43:51.467 --> 10:43:55.796
  One more huge round of 
applause for all the nominees 

10:43:55.797 --> 10:43:58.822
and the winners, please. 
(Applause)  

10:43:58.823 --> 10:44:02.970
Make some noise!

10:44:08.394 --> 10:44:12.578
  With so many amazing apps and 
games, it was an extremely 

10:44:12.579 --> 10:44:15.507
difficult task for the panel to 
pick the nominees and the 

10:44:15.508 --> 10:44:18.378
winners.  Thank you for 
constantly pushing the 

10:44:18.379 --> 10:44:21.723
boundaries to show us what's
        what's possible.  I hope

10:44:21.986 --> 10:44:23.986
 you had a good time tonight

10:44:27.032 --> 10:44:32.542
.  And I hope you're energized 
to go out and use the new tools 

10:44:32.543 --> 10:44:37.121
and features that we announced 
all through I/O to create new 

10:44:37.122 --> 10:44:40.416
apps and games.  
(Applause)

10:44:47.924 --> 10:44:51.807
waiting to see what you will 
create next.  We are constantly 

10:44:51.808 --> 10:44:57.116
amazed and it's what makes our 
jobs fun every day.  But first, 

10:44:57.117 --> 10:45:01.224
it's time to go out and have 
some fun.  Please join us for 

10:45:01.225 --> 10:45:04.409
after hours happening all around
 the venue.  Good night, and 

