WEBVTT
Kind: captions
Language: en

00:00:01.500 --> 00:00:02.440
MALE SPEAKER: OK.

00:00:02.440 --> 00:00:05.700
We'll get started
now with session two.

00:00:05.700 --> 00:00:09.140
We have session two
on layout performance.

00:00:09.140 --> 00:00:13.069
And to moderate this session, we
have Mike Shaver from Facebook.

00:00:13.069 --> 00:00:13.860
Mike, take it away.

00:00:13.860 --> 00:00:16.606
MIKE SHAVER: Thank you.

00:00:16.606 --> 00:00:17.480
Thank you, everybody.

00:00:17.480 --> 00:00:18.459
Excited to be here.

00:00:18.459 --> 00:00:20.750
So I'll tell you a little
bit about the panelists here,

00:00:20.750 --> 00:00:22.500
and then we'll get started.

00:00:22.500 --> 00:00:25.430
Charles works on,
at Flipboard, living

00:00:25.430 --> 00:00:26.930
the adventure of
layout performance

00:00:26.930 --> 00:00:28.820
in many different browsers.

00:00:28.820 --> 00:00:32.530
Wilson, developer in Firefox
OS and author of Library Fast

00:00:32.530 --> 00:00:35.660
DOM, which gets good
performance by avoiding

00:00:35.660 --> 00:00:37.986
the overhead of actually
laying things out.

00:00:37.986 --> 00:00:40.110
Christopher Chedeau, on
the React team at Facebook,

00:00:40.110 --> 00:00:42.360
who-- he provides a library
that gets good performance

00:00:42.360 --> 00:00:44.240
by avoiding touching the DOM.

00:00:44.240 --> 00:00:46.900
David Baron, who works
[INAUDIBLE] at Mozilla,

00:00:46.900 --> 00:00:49.860
trying to give us fewer reasons
to avoid layout and touching

00:00:49.860 --> 00:00:51.030
layout in the DOM.

00:00:51.030 --> 00:00:52.850
And Paul Lewis,
developer advocate

00:00:52.850 --> 00:00:56.232
who tries to help developers
make their applications quick,

00:00:56.232 --> 00:00:58.690
using all the power of the web
and in spite, in some cases,

00:00:58.690 --> 00:00:59.810
of the power of the web.

00:00:59.810 --> 00:01:01.760
And Paul will get us started
with a quick presentation

00:01:01.760 --> 00:01:03.010
here about layout performance.

00:01:03.010 --> 00:01:04.810
PAUL LEWIS: Great.

00:01:04.810 --> 00:01:07.960
So what I'm going to
do is to just start

00:01:07.960 --> 00:01:10.280
talking about what layout
is just so we framed

00:01:10.280 --> 00:01:12.636
the conversation a little bit.

00:01:12.636 --> 00:01:15.680
The layout's the process of
converting the DOM styles

00:01:15.680 --> 00:01:17.774
to a geometric
representation of the page.

00:01:17.774 --> 00:01:19.940
So it's about getting data
concerning width, height,

00:01:19.940 --> 00:01:22.970
location, and visibility
of every element.

00:01:22.970 --> 00:01:25.150
And for the initial
load-- so we sort of think

00:01:25.150 --> 00:01:27.630
of this as the first
frame-- you need

00:01:27.630 --> 00:01:30.410
to know everything about every
element and its geometry.

00:01:30.410 --> 00:01:33.580
So you kind of calculate
the world, right?

00:01:33.580 --> 00:01:35.600
But for subsequent
frames, you might only

00:01:35.600 --> 00:01:37.379
change part of the
page, like, I don't

00:01:37.379 --> 00:01:39.170
know, adding more
information to something,

00:01:39.170 --> 00:01:42.100
expanding something, maybe
even removing something.

00:01:42.100 --> 00:01:44.960
And hopefully, we'd only
calculate the layout

00:01:44.960 --> 00:01:47.480
for that smaller part of the
tree, or you'd think anyway.

00:01:47.480 --> 00:01:49.400
But actually, most
of the time, layout

00:01:49.400 --> 00:01:51.340
is scoped to the
entire document.

00:01:51.340 --> 00:01:53.730
And this is sort
of in large part

00:01:53.730 --> 00:01:56.250
due to the web's layout
model, the document flow

00:01:56.250 --> 00:01:57.710
that we're all used to.

00:01:57.710 --> 00:02:00.230
If you change the width
of body, then most likely,

00:02:00.230 --> 00:02:02.677
everything inside of
that's going to change.

00:02:02.677 --> 00:02:04.760
And if you change something
further down the tree,

00:02:04.760 --> 00:02:07.170
then [INAUDIBLE]
all the way back up

00:02:07.170 --> 00:02:08.410
will at least get checked.

00:02:08.410 --> 00:02:12.770
And if they're effective, then
they may get laid out as well.

00:02:12.770 --> 00:02:15.810
But layout is kind of one
part of this whole pipeline.

00:02:15.810 --> 00:02:19.220
And this being a kind of
simplified version, which

00:02:19.220 --> 00:02:22.320
includes JavaScript, and
includes style calculations,

00:02:22.320 --> 00:02:24.000
painting, and composition.

00:02:24.000 --> 00:02:28.520
And layout itself is sort of
borne of CSS, kind of sadly,

00:02:28.520 --> 00:02:31.740
I think, in some ways, with the
classic box model, flex grid,

00:02:31.740 --> 00:02:35.980
all these things that
we've had over time.

00:02:35.980 --> 00:02:37.490
Other things about layout.

00:02:37.490 --> 00:02:42.082
You can't trigger layout
without also triggering paint,

00:02:42.082 --> 00:02:43.540
because as you
change the geometry,

00:02:43.540 --> 00:02:45.340
you'll need to change pixels.

00:02:45.340 --> 00:02:47.880
So for most cases, today
when you trigger layout

00:02:47.880 --> 00:02:50.370
and therefore paint, you'll
probably miss frames.

00:02:50.370 --> 00:02:53.460
So we basically tell you
to avoid it at all costs.

00:02:53.460 --> 00:02:55.910
Or if you're going to do it,
do it judiciously so the user

00:02:55.910 --> 00:02:57.385
doesn't notice.

00:02:57.385 --> 00:02:59.260
So essentially, we've
ended up with this kind

00:02:59.260 --> 00:03:03.820
of fairly intricate relationship
with the parts about pages.

00:03:03.820 --> 00:03:05.960
And from a layout
point of view at least,

00:03:05.960 --> 00:03:08.270
it's a finely balanced
house of cards.

00:03:08.270 --> 00:03:10.470
We fight with CSS,
we fight with layout,

00:03:10.470 --> 00:03:14.900
both to get good performance
but to avoid brittleness.

00:03:14.900 --> 00:03:16.780
From the outside,
I think layout is

00:03:16.780 --> 00:03:19.570
really difficult
to reason about.

00:03:19.570 --> 00:03:22.300
If I change the height of
this element over here,

00:03:22.300 --> 00:03:24.240
what happens inside
the layout engine?

00:03:24.240 --> 00:03:25.360
I don't know.

00:03:25.360 --> 00:03:27.575
I have no idea, not a clue.

00:03:27.575 --> 00:03:28.450
Try it, and find out.

00:03:28.450 --> 00:03:29.810
It's exciting, right?

00:03:29.810 --> 00:03:32.070
And how long should I expect
that to take on, like,

00:03:32.070 --> 00:03:33.400
a Nexus 5?

00:03:33.400 --> 00:03:34.540
I don't know.

00:03:34.540 --> 00:03:36.379
And what about all the browsers?

00:03:36.379 --> 00:03:38.670
You might get something from
Chrome, but you might not.

00:03:38.670 --> 00:03:41.003
And even then, you've still
got all these other browsers

00:03:41.003 --> 00:03:41.850
to deal with.

00:03:41.850 --> 00:03:43.420
So we don't always
get the insight

00:03:43.420 --> 00:03:46.697
that I think we probably
need to make good decisions.

00:03:46.697 --> 00:03:48.113
So from a developer
point of view,

00:03:48.113 --> 00:03:49.914
I think it's just
difficult to understand

00:03:49.914 --> 00:03:51.580
what's going on in
the pipeline and what

00:03:51.580 --> 00:03:53.657
the impact of your
code is going to be.

00:03:53.657 --> 00:03:56.240
So I think that's why, for me,
this panel is really important.

00:03:56.240 --> 00:03:58.239
Because for anybody who's
serious about building

00:03:58.239 --> 00:04:02.036
for the web, fast loading and
fast-running pages are crucial,

00:04:02.036 --> 00:04:04.160
especially those things
like service worker kick-in

00:04:04.160 --> 00:04:07.150
and loading changes-- then the
differentiator might actually

00:04:07.150 --> 00:04:08.880
be how people feel
about your app

00:04:08.880 --> 00:04:10.670
when they're actually
using the thing.

00:04:10.670 --> 00:04:12.086
Because what we're
trying to avoid

00:04:12.086 --> 00:04:14.639
is that judder of
missed frames or worse,

00:04:14.639 --> 00:04:16.180
a complete halt,
because we know it's

00:04:16.180 --> 00:04:17.596
going to kill the
user experience.

00:04:17.596 --> 00:04:19.610
That's the thing
we want to avoid.

00:04:19.610 --> 00:04:23.090
And for me, I think layout
performance is actually a proxy

00:04:23.090 --> 00:04:24.980
for, I want my
stuff to run well,

00:04:24.980 --> 00:04:27.460
because right now
it probably doesn't.

00:04:27.460 --> 00:04:30.170
Not necessarily layout
itself is that little task

00:04:30.170 --> 00:04:31.920
in the pipeline.

00:04:31.920 --> 00:04:34.344
So broadening our view a little
bit then, we and our users

00:04:34.344 --> 00:04:36.010
want fast-running
experiences, and we're

00:04:36.010 --> 00:04:38.180
sad when we don't get them.

00:04:38.180 --> 00:04:41.370
But I wanna kind of ask,
whose problem is that?

00:04:41.370 --> 00:04:44.260
Allow me to present
two extremes of views

00:04:44.260 --> 00:04:45.670
to that particular question.

00:04:45.670 --> 00:04:48.630
First of all, it's entirely
the browser manufacturer's

00:04:48.630 --> 00:04:49.600
responsibility.

00:04:49.600 --> 00:04:51.190
I should just write
my code, and they

00:04:51.190 --> 00:04:54.290
should make sure
that it runs well.

00:04:54.290 --> 00:04:56.620
For me, that would be like
telling a car manufacturer

00:04:56.620 --> 00:04:58.494
that you expect to be
able to get to 60 miles

00:04:58.494 --> 00:05:01.630
an hour no matter what fuel
you put in, how you drive,

00:05:01.630 --> 00:05:04.730
or what you end up carrying.

00:05:04.730 --> 00:05:08.140
Just seems on the touch
unreasonable side to me, that.

00:05:08.140 --> 00:05:10.130
On the other extreme,
it's entirely

00:05:10.130 --> 00:05:11.770
the developer's responsibility.

00:05:11.770 --> 00:05:13.110
Things can perform well.

00:05:13.110 --> 00:05:17.180
They can go fast as long as they
don't trigger layouts or paint.

00:05:17.180 --> 00:05:19.680
And that, for me, is like the
car manufacturer, in response,

00:05:19.680 --> 00:05:23.130
telling you you can only change
gears at exactly 4,000 RPM.

00:05:23.130 --> 00:05:24.982
And for the love of
all that is decent,

00:05:24.982 --> 00:05:26.690
we know we've given
you a steering wheel,

00:05:26.690 --> 00:05:29.064
but please don't turn left,
because the car will explode.

00:05:31.520 --> 00:05:35.550
So I'm not convinced that that's
actually the right question

00:05:35.550 --> 00:05:37.800
to ask-- who's going
to make this faster?

00:05:37.800 --> 00:05:39.480
I think a better
question to ask is,

00:05:39.480 --> 00:05:41.210
do we even have
the right pipeline,

00:05:41.210 --> 00:05:43.901
and is it optimized
for the right thing?

00:05:43.901 --> 00:05:45.400
So to answer that
one, I think we're

00:05:45.400 --> 00:05:47.470
going to do a little bit
of armchair philosophy,

00:05:47.470 --> 00:05:49.880
a sort of philosophy of web
development, if you like,

00:05:49.880 --> 00:05:51.380
to ask the important
questions like,

00:05:51.380 --> 00:05:53.290
what experiences are
we trying to make,

00:05:53.290 --> 00:05:55.540
what's the difference between
a web app and a website?

00:05:55.540 --> 00:05:58.980
And if text is invented by
minus 999 EMs and nobody's

00:05:58.980 --> 00:06:02.019
about to read it,
is it truly there?

00:06:02.019 --> 00:06:03.560
Let's start with
the big one, the one

00:06:03.560 --> 00:06:05.410
that actually I
think matters today.

00:06:05.410 --> 00:06:07.409
What experiences are we
actually trying to make?

00:06:07.409 --> 00:06:10.432
Or put another way, what's the
primary use case of the web?

00:06:10.432 --> 00:06:12.890
Because that, for me, should
define our path, the questions

00:06:12.890 --> 00:06:15.954
we ask ourselves and crucially,
what we optimize for.

00:06:15.954 --> 00:06:17.620
For context, Android
and, of course, iOS

00:06:17.620 --> 00:06:21.920
as well, both have a very clear,
single use case for me-- apps.

00:06:21.920 --> 00:06:24.820
Everything is in support of
apps and very little else.

00:06:24.820 --> 00:06:26.660
We, on the other
hand, have a platform

00:06:26.660 --> 00:06:29.650
that's grown out of documents,
that's its origins, right?

00:06:29.650 --> 00:06:33.150
Headings, sections, articles,
the document object model.

00:06:33.150 --> 00:06:37.950
And we have sort of fairly funny
layout models in some places.

00:06:37.950 --> 00:06:39.720
But as we try and
make web apps, we've

00:06:39.720 --> 00:06:41.710
realized there's a bit
of a mismatch here.

00:06:41.710 --> 00:06:43.939
We don't have, included
in our platform,

00:06:43.939 --> 00:06:46.230
app-like primitives like
infinite scrolling list views,

00:06:46.230 --> 00:06:47.780
or master detail
views, and navigation

00:06:47.780 --> 00:06:50.321
draws, or pull to refresh, or
all the other things that we've

00:06:50.321 --> 00:06:52.280
heard from that first panel.

00:06:52.280 --> 00:06:54.410
Actually, you can build
something like those,

00:06:54.410 --> 00:06:57.000
but it requires
significant work often

00:06:57.000 --> 00:07:00.380
at the cost of circumventing
the browser's models

00:07:00.380 --> 00:07:05.220
or reimplementing things
like scrolling yourself.

00:07:05.220 --> 00:07:07.800
To my mind, we've
got a few options.

00:07:07.800 --> 00:07:10.750
In ascending order
of extremity, one,

00:07:10.750 --> 00:07:13.930
we can keep improving
the web-- add a rocket

00:07:13.930 --> 00:07:16.224
to the back of the
car in the hope

00:07:16.224 --> 00:07:17.890
that our entire
pipeline will eventually

00:07:17.890 --> 00:07:20.369
become fast enough for us
to do what it is we want.

00:07:20.369 --> 00:07:21.910
And the good news
there is that there

00:07:21.910 --> 00:07:24.680
are significant improvements
happening in all the browsers.

00:07:24.680 --> 00:07:26.340
Streamlining a
style calculations,

00:07:26.340 --> 00:07:29.920
layout itself, GP
rasterization, or fixes

00:07:29.920 --> 00:07:31.460
to touch input latency.

00:07:31.460 --> 00:07:32.770
But is that enough?

00:07:32.770 --> 00:07:34.610
Is that going to get us there?

00:07:34.610 --> 00:07:36.480
Two, we could keep
polishing but add

00:07:36.480 --> 00:07:39.300
in new hooks and new
primitives to better equip

00:07:39.300 --> 00:07:41.400
the pipeline for
web apps, assuming

00:07:41.400 --> 00:07:42.860
that's what we want to do.

00:07:42.860 --> 00:07:44.580
What about hooks into
the layout engine

00:07:44.580 --> 00:07:47.915
that let you decide what
gets laid out when and how.

00:07:47.915 --> 00:07:50.290
Or if you want something, some
kind of progressive layout

00:07:50.290 --> 00:07:51.873
or something like
that, sort of lo-fi,

00:07:51.873 --> 00:07:54.900
hi-fi, what do we do to
the pipeline that gives you

00:07:54.900 --> 00:07:56.160
that power?

00:07:56.160 --> 00:07:58.921
For me, the extensible web
manifesto is a good thing,

00:07:58.921 --> 00:08:00.420
but for some reason,
rendering seemd

00:08:00.420 --> 00:08:02.540
to get a pass in
that conversation.

00:08:02.540 --> 00:08:05.130
And it's not something
that's being extended yet.

00:08:05.130 --> 00:08:09.680
And I think it makes the system
more able to reason about

00:08:09.680 --> 00:08:11.750
if you get those
controls, hopefully.

00:08:11.750 --> 00:08:15.200
And it's just less magic.

00:08:15.200 --> 00:08:17.420
But if we still want
magic, we could always

00:08:17.420 --> 00:08:20.715
fork the web, which
is not necessarily

00:08:20.715 --> 00:08:21.840
what I think we want to do.

00:08:21.840 --> 00:08:23.381
But we could explicitly
create, like,

00:08:23.381 --> 00:08:26.920
a web app-centric fast path and
aggressively deprecate anything

00:08:26.920 --> 00:08:28.560
that just stands in our way.

00:08:28.560 --> 00:08:29.280
Why not?

00:08:29.280 --> 00:08:30.540
It's the future.

00:08:30.540 --> 00:08:32.527
I think that would
be sad for the web.

00:08:32.527 --> 00:08:33.110
I actually do.

00:08:33.110 --> 00:08:35.830
And I think we don't want
to see it bifurcated.

00:08:35.830 --> 00:08:37.330
I'm not convinced
we need it either.

00:08:37.330 --> 00:08:39.840
But in the interests
of completeness,

00:08:39.840 --> 00:08:41.516
there you have the third option.

00:08:41.516 --> 00:08:42.890
Ultimately, though,
I think those

00:08:42.890 --> 00:08:44.300
are technical
considerations, and we

00:08:44.300 --> 00:08:45.883
might do a balance
of all those three.

00:08:48.376 --> 00:08:50.750
For me, they have to subordinate
to the primary question.

00:08:50.750 --> 00:08:51.880
We have a layout pipeline.

00:08:51.880 --> 00:08:56.180
It is phenomenally successful
at laying out documents,

00:08:56.180 --> 00:08:58.544
but we're trying to make
it amazing for web apps.

00:08:58.544 --> 00:09:01.085
And when push comes to shove,
if we can't have an engine that

00:09:01.085 --> 00:09:05.650
is amazing or even good at
both, what do we actually want?

00:09:05.650 --> 00:09:09.350
What do we want our engines
to be default-fast for?

00:09:09.350 --> 00:09:12.832
Lots of questions and
perhaps not many answers.

00:09:12.832 --> 00:09:14.790
But then that's the job
of the panel, isn't it?

00:09:14.790 --> 00:09:16.373
So I guess with that,
I'll say thanks,

00:09:16.373 --> 00:09:17.586
and suggest we get started.

00:09:17.586 --> 00:09:19.212
MIKE SHAVER: Thank you, Paul.

00:09:19.212 --> 00:09:22.068
[APPLAUSE]

00:09:25.880 --> 00:09:29.740
Waiting for my on slide, make
sure I get the right question.

00:09:29.740 --> 00:09:32.530
Pretty sure I know what
the first question is.

00:09:32.530 --> 00:09:34.490
So following on to
that, I mean, one

00:09:34.490 --> 00:09:37.407
of the big gaps we
have in the performance

00:09:37.407 --> 00:09:39.740
landscape for the web is the
lack of a layout benchmark.

00:09:39.740 --> 00:09:41.406
We have them for
scripting, we have them

00:09:41.406 --> 00:09:43.630
for compositing, and
canvas, and various pieces

00:09:43.630 --> 00:09:45.130
of network activity.

00:09:45.130 --> 00:09:46.745
We really don't
have one for layout.

00:09:46.745 --> 00:09:48.370
I think that makes
it under-represented

00:09:48.370 --> 00:09:49.660
in the performance
work that happens.

00:09:49.660 --> 00:09:51.260
So I'd like to ask you,
Charles-- you're in this stuff

00:09:51.260 --> 00:09:51.950
all the time.

00:09:51.950 --> 00:09:54.800
What would you put in the
layout benchmark today?

00:09:54.800 --> 00:09:56.950
CHARLES YING: Oh, boy.

00:09:56.950 --> 00:10:01.371
Well, put all of Flipboard in
there, and then call it a day.

00:10:01.371 --> 00:10:01.870
No.

00:10:01.870 --> 00:10:05.180
I mean, there's so many
different types of apps,

00:10:05.180 --> 00:10:08.070
but you really want
to get representations

00:10:08.070 --> 00:10:09.570
of each of the big apps.

00:10:09.570 --> 00:10:12.780
I would say text
rendering is one of them.

00:10:12.780 --> 00:10:14.870
We do all sorts of text
measurement and things

00:10:14.870 --> 00:10:17.510
like that-- something that
looks like a game, something

00:10:17.510 --> 00:10:20.550
that looks like a lot of data.

00:10:20.550 --> 00:10:24.860
I mean, we could go anywhere
from consumer to scientific.

00:10:24.860 --> 00:10:28.012
It's a broad-- I would say I
don't know the full answer.

00:10:28.012 --> 00:10:29.970
I don't know if you can
actually put everything

00:10:29.970 --> 00:10:31.460
into a layout benchmark.

00:10:31.460 --> 00:10:32.960
MIKE SHAVER: So
actually, and I want

00:10:32.960 --> 00:10:36.400
to add just a quick note for
participants from the audience.

00:10:36.400 --> 00:10:38.820
If you raise your hand, we
can bring a microphone to you

00:10:38.820 --> 00:10:41.510
when you sort of register
yourself to speak there.

00:10:41.510 --> 00:10:43.145
And then you'll
have a microphone.

00:10:43.145 --> 00:10:44.670
You'll be able to speak.

00:10:44.670 --> 00:10:46.645
So I guess actually
while we're waiting

00:10:46.645 --> 00:10:49.020
for that to get settled, I'll
throw it over to Paul here.

00:10:49.020 --> 00:10:50.060
You're an advocate
for developers.

00:10:50.060 --> 00:10:52.143
Benchmarks are a very
effective way for developers

00:10:52.143 --> 00:10:53.270
to advocate for themselves.

00:10:53.270 --> 00:10:54.620
PAUL LEWIS: They can be.

00:10:54.620 --> 00:10:56.078
MIKE SHAVER: Why
don't we have one?

00:10:56.078 --> 00:10:58.440
PAUL LEWIS: I worry about
benchmarks getting gamed,

00:10:58.440 --> 00:10:59.270
generally.

00:10:59.270 --> 00:11:01.802
But that, notwithstanding,
I think, yes.

00:11:01.802 --> 00:11:03.260
One of the hard
things is measuring

00:11:03.260 --> 00:11:05.300
smoothness is really
difficult today

00:11:05.300 --> 00:11:09.190
in a cross browser-- there's no
API that says, is this smooth?

00:11:09.190 --> 00:11:11.720
And a couple of days
ago, a Chrome engineer

00:11:11.720 --> 00:11:14.010
posted to the Web
Performance group, saying,

00:11:14.010 --> 00:11:17.020
we think we could
do with this API.

00:11:17.020 --> 00:11:19.700
And I would love to see how
that conversation turns out.

00:11:19.700 --> 00:11:21.520
Because if you have
that API, then you

00:11:21.520 --> 00:11:23.989
can start making meaningful
benchmarks, hopefully.

00:11:23.989 --> 00:11:25.030
And I think you're right.

00:11:25.030 --> 00:11:26.610
Like, something that
is representative

00:11:26.610 --> 00:11:28.570
of the kind of things that
people are trying to make,

00:11:28.570 --> 00:11:30.040
not necessarily the things
they've made in the past,

00:11:30.040 --> 00:11:32.150
but what are we
trying to make now?

00:11:32.150 --> 00:11:35.240
Like, infinite scrolling
list views or all the stuff

00:11:35.240 --> 00:11:37.150
that you guys are
doing at Flipboard.

00:11:37.150 --> 00:11:39.030
Let's put that in
there, and let's see

00:11:39.030 --> 00:11:42.150
how fast we can get it on
mobile, on desktop, everywhere.

00:11:42.150 --> 00:11:43.256
That would be great.

00:11:43.256 --> 00:11:45.950
MIKE SHAVER: Uh, Jonathan,
do you have a microphone?

00:11:45.950 --> 00:11:47.730
JONATHAN: [INAUDIBLE].

00:11:47.730 --> 00:11:48.566
MIKE SHAVER: Oh, OK.

00:11:48.566 --> 00:11:49.065
[LAUGHTER]

00:11:49.065 --> 00:11:49.815
MIKE SHAVER: Wait.

00:11:49.815 --> 00:11:51.764
I'm going to make you
say something anyway.

00:11:51.764 --> 00:11:53.020
No, it's fine.

00:11:55.381 --> 00:11:55.880
No?

00:11:55.880 --> 00:11:56.422
JONATHAN: No.

00:11:56.422 --> 00:11:57.255
MIKE SHAVER: Oh, OK.

00:11:57.255 --> 00:11:57.890
Next time.

00:11:57.890 --> 00:12:00.210
Next time.

00:12:00.210 --> 00:12:04.330
So it's true we don't have the
smoothness there-- smoothness

00:12:04.330 --> 00:12:04.950
test, rather.

00:12:04.950 --> 00:12:07.560
Is that really a limit?

00:12:07.560 --> 00:12:09.392
David, you work on
layout performance.

00:12:09.392 --> 00:12:10.850
How do you tell if
stuff got better

00:12:10.850 --> 00:12:12.697
if you don't have
a smoothness API?

00:12:12.697 --> 00:12:14.530
Can we not measure
layout in some other way?

00:12:21.037 --> 00:12:22.120
DAVID BARON: I don't know.

00:12:22.120 --> 00:12:25.150
A lot of the measuring we do
is still about absolute time,

00:12:25.150 --> 00:12:25.900
I think.

00:12:25.900 --> 00:12:29.010
When we're actually
looking at layout itself

00:12:29.010 --> 00:12:30.060
as a very narrow thing.

00:12:33.700 --> 00:12:39.320
We are starting to have tools
internally for measuring

00:12:39.320 --> 00:12:41.310
things like frame
rate and so on.

00:12:44.660 --> 00:12:47.250
I think the conversation about
how we expose those to the web

00:12:47.250 --> 00:12:48.874
is a good one, and
we should have that.

00:12:56.164 --> 00:12:58.815
PAUL LEWIS: Certainly, from
Chrome's point of view,

00:12:58.815 --> 00:13:01.525
you can load Chrome
as a bunch of flags.

00:13:01.525 --> 00:13:04.320
And we use then an
extra API that we

00:13:04.320 --> 00:13:07.030
use in telemetry, which
is how we sort of run

00:13:07.030 --> 00:13:09.224
through our benchmarks
and go, was that faster?

00:13:09.224 --> 00:13:09.890
Was that slower?

00:13:09.890 --> 00:13:11.550
And it's all automated.

00:13:11.550 --> 00:13:13.090
I think it is this
question of, how

00:13:13.090 --> 00:13:14.673
then do you make
that something that's

00:13:14.673 --> 00:13:17.920
more broadly available
in a safe way and so on?

00:13:17.920 --> 00:13:19.920
And in the right way,
and make it a primitive

00:13:19.920 --> 00:13:21.280
that people can build on top of.

00:13:21.280 --> 00:13:25.694
Rather than saying we need
necessarily a layout benchmark,

00:13:25.694 --> 00:13:28.360
I think it is the right thing to
give the underlying primitive--

00:13:28.360 --> 00:13:29.890
this is kind of the
extensible web stuff, right?

00:13:29.890 --> 00:13:31.280
And just give them--
and then people

00:13:31.280 --> 00:13:32.960
can build the right
things, because it's

00:13:32.960 --> 00:13:34.730
very difficult from
the outside to go,

00:13:34.730 --> 00:13:38.340
well, we should make a benchmark
that does exactly this one

00:13:38.340 --> 00:13:40.640
thing, or we should
make this one case fast,

00:13:40.640 --> 00:13:44.090
because like I said,
there's such a range.

00:13:44.090 --> 00:13:45.490
And you just end
up making this--

00:13:45.490 --> 00:13:47.350
we did this with
scrolling, didn't we?

00:13:47.350 --> 00:13:50.380
We made scrolling fast, and
then all of a sudden, people

00:13:50.380 --> 00:13:52.001
tried to go off piste.

00:13:52.001 --> 00:13:54.000
And it was like, yeah,
that's not going to work.

00:13:54.000 --> 00:13:55.167
You don't get scroll events.

00:13:55.167 --> 00:13:56.666
That's not going
to play out nicely.

00:13:56.666 --> 00:13:58.452
And I kind of feel
like that with anything

00:13:58.452 --> 00:14:00.160
that would be-- the
smoothness benchmark,

00:14:00.160 --> 00:14:03.435
you've got to just kind of take
a step back and say, what do we

00:14:03.435 --> 00:14:05.810
need to give developers so
that they can start testing it

00:14:05.810 --> 00:14:09.526
themselves in the way that makes
sense for their applications?

00:14:09.526 --> 00:14:12.184
WILSON PAGE: For load time,
we have the page speed score.

00:14:12.184 --> 00:14:13.600
Could we have
something like that,

00:14:13.600 --> 00:14:15.260
like sort of gamifiy
the whole thing,

00:14:15.260 --> 00:14:17.890
and have people go, I've got
a layout time of this much,

00:14:17.890 --> 00:14:19.480
like collapsing that,
having something

00:14:19.480 --> 00:14:20.521
[INAUDIBLE] the same way.

00:14:20.521 --> 00:14:22.300
You collapse the whole
page, open it up,

00:14:22.300 --> 00:14:24.049
and you've got a score,
like, from nothing

00:14:24.049 --> 00:14:27.180
to this much is how much your
page takes to layout, paint,

00:14:27.180 --> 00:14:27.680
everything.

00:14:27.680 --> 00:14:29.046
And you could get,
say, we reckon

00:14:29.046 --> 00:14:31.545
that's a pretty good score, we
reckon that's an awful score.

00:14:31.545 --> 00:14:33.330
Your DOM's too big,
or the kind of things

00:14:33.330 --> 00:14:35.760
you're positioning
it too complex.

00:14:35.760 --> 00:14:38.330
Is that something we can
do, so people can clearly

00:14:38.330 --> 00:14:41.040
identify when their page is
good and when their page is bad?

00:14:41.040 --> 00:14:43.360
PAUL LEWIS: I would love that.

00:14:43.360 --> 00:14:46.610
I think the score is like a
really good first indicator of,

00:14:46.610 --> 00:14:47.890
is it good or is it bad?

00:14:47.890 --> 00:14:50.056
Hopefully, you'd be able
to see that from this thing

00:14:50.056 --> 00:14:51.880
not working nicely.

00:14:51.880 --> 00:14:56.002
But beyond that,
it's like, if you've

00:14:56.002 --> 00:14:57.710
got something that's
not playing nicely--

00:14:57.710 --> 00:14:58.580
we were talking about
this last night.

00:14:58.580 --> 00:14:59.810
If you've got three things
that aren't playing nicely

00:14:59.810 --> 00:15:01.490
and you remove one,
and all of a sudden,

00:15:01.490 --> 00:15:03.114
it looks like it's
playing more nicely,

00:15:03.114 --> 00:15:05.430
you don't necessarily know
what it was that one thing.

00:15:05.430 --> 00:15:06.910
It could have been three things
that weren't playing nicely

00:15:06.910 --> 00:15:10.110
together, and you removed the
one that broke the condition.

00:15:10.110 --> 00:15:12.485
But you want more
information, not just a score,

00:15:12.485 --> 00:15:13.700
not just a number at the end.

00:15:13.700 --> 00:15:17.248
You want to kind of know, how
did you arrive at that answer,

00:15:17.248 --> 00:15:19.373
so that I can make more
intelligent guesses, rather

00:15:19.373 --> 00:15:20.970
than this big, black
box of, hey, you

00:15:20.970 --> 00:15:22.700
put some CSS and some DOM in.

00:15:22.700 --> 00:15:26.500
You get a number out the other
side or a frames per second.

00:15:26.500 --> 00:15:29.222
Like, let people sort of
start to dive into that.

00:15:29.222 --> 00:15:30.930
It's probably a bit
overwhelming, though.

00:15:30.930 --> 00:15:31.620
CHRISTOPHER CHEDEAU: Yeah.

00:15:31.620 --> 00:15:33.220
I think you need some
dev tools, you know,

00:15:33.220 --> 00:15:34.678
to make it easier
for the developer

00:15:34.678 --> 00:15:35.780
to know what's going on.

00:15:35.780 --> 00:15:40.344
So for example, like, if you're
looking at a news feed perf,

00:15:40.344 --> 00:15:42.010
you're going to say,
oh, I changed this,

00:15:42.010 --> 00:15:45.370
so I trigger the
re-flow or layout.

00:15:45.370 --> 00:15:46.900
And now what?

00:15:46.900 --> 00:15:50.310
So you have a timing, but you
have no idea what happened

00:15:50.310 --> 00:15:54.610
and where you should be
organize your code to be faster

00:15:54.610 --> 00:15:58.290
or what happened in layout,
which elements were layout.

00:15:58.290 --> 00:16:00.470
And so we don't have
this information.

00:16:00.470 --> 00:16:03.270
So we have to guess and
try to test something.

00:16:03.270 --> 00:16:07.817
But it's like, yeah, as you
said, a real black box for us.

00:16:07.817 --> 00:16:09.400
CHARLES YING: When
we profile our app,

00:16:09.400 --> 00:16:16.000
we frequently see hot spots
being spent either in painting,

00:16:16.000 --> 00:16:20.340
or in layout, or in [INAUDIBLE]
coding, or in compositing.

00:16:20.340 --> 00:16:23.550
And they trade places
all in the same profile.

00:16:23.550 --> 00:16:25.800
I mean, it would be great
if everything was integrated

00:16:25.800 --> 00:16:28.480
together and you can see,
like, oh, JPEG decoding

00:16:28.480 --> 00:16:31.280
was taking this
long, or the gradient

00:16:31.280 --> 00:16:33.839
draw that I was doing
is taking this long.

00:16:33.839 --> 00:16:35.005
We have that on native side.

00:16:35.005 --> 00:16:36.505
When we profile our
JavaScript apps,

00:16:36.505 --> 00:16:38.900
it says, well, paint
took this long,

00:16:38.900 --> 00:16:42.144
and layout took this long.

00:16:42.144 --> 00:16:43.560
And you're like,
where do I start?

00:16:43.560 --> 00:16:44.780
DAVID BARON: Yeah.

00:16:44.780 --> 00:16:47.030
Some of those conditions are
very complicated, though,

00:16:47.030 --> 00:16:50.440
because you end
up in a situation

00:16:50.440 --> 00:16:53.070
where you've done something
that makes the painting process

00:16:53.070 --> 00:16:55.560
itself slow, you've
done something else

00:16:55.560 --> 00:16:57.690
that makes you paint a lot.

00:16:57.690 --> 00:17:00.590
Fixing either one of those would
fix your performance problem.

00:17:00.590 --> 00:17:03.620
And we need to
somehow figure out

00:17:03.620 --> 00:17:06.099
how to show that information
to you in a useful way.

00:17:06.099 --> 00:17:07.380
And that's kind of hard.

00:17:07.380 --> 00:17:08.619
PAUL LEWIS: Yeah, I agree.

00:17:08.619 --> 00:17:10.993
I was profiling
something this past week.

00:17:10.993 --> 00:17:13.569
And there were, like,
1,000 or so elements.

00:17:13.569 --> 00:17:15.240
And they all had
Overflow Hidden on.

00:17:15.240 --> 00:17:17.067
And layout was
actually really fast.

00:17:17.067 --> 00:17:19.150
Generally speaking, layout's
actually really fast.

00:17:19.150 --> 00:17:20.980
But layer management is not.

00:17:20.980 --> 00:17:23.274
Or it's getting better,
but it wasn't in this case.

00:17:23.274 --> 00:17:25.190
And the thing was I
turned off Overflow Hidden

00:17:25.190 --> 00:17:25.670
as a bit of a guess.

00:17:25.670 --> 00:17:27.640
I was like, I wonder what
happens if I do this.

00:17:27.640 --> 00:17:32.840
And sure enough, layer
management went down,

00:17:32.840 --> 00:17:35.540
but layout went
through the roof.

00:17:35.540 --> 00:17:40.840
It went from 9 milliseconds
up to 77 milliseconds.

00:17:40.840 --> 00:17:43.540
Looking at this, I was
like, I don't know why.

00:17:43.540 --> 00:17:46.110
I have to speak to our
engineers, who very kindly sit

00:17:46.110 --> 00:17:49.110
with me and explain, in simple
terms, why this is true.

00:17:49.110 --> 00:17:51.530
But as a developer, you
look at this, you go,

00:17:51.530 --> 00:17:52.950
I just changed one style.

00:17:52.950 --> 00:17:55.510
Everything went really weird.

00:17:55.510 --> 00:17:56.600
Now what do I do?

00:17:56.600 --> 00:17:59.590
And that's the problem I
desperately want us to solve.

00:17:59.590 --> 00:18:01.460
Like, how do we make
that reasonable again?

00:18:01.460 --> 00:18:03.630
MIKE SHAVER: Absolutely.

00:18:03.630 --> 00:18:05.772
Something here from
Steve [INAUDIBLE].

00:18:05.772 --> 00:18:08.380
STEVE: In the world of
performance metrics,

00:18:08.380 --> 00:18:12.070
we have these kind of two
camps of synthetic and ROM

00:18:12.070 --> 00:18:14.850
where ROM is real user traffic.

00:18:14.850 --> 00:18:19.770
And a lot of the things that I
feel have been talked about so

00:18:19.770 --> 00:18:22.610
far is on the
synthetic side, we're

00:18:22.610 --> 00:18:27.410
collecting profiles on
heavily instrumented browsers

00:18:27.410 --> 00:18:29.980
in the dev world or in a lab.

00:18:29.980 --> 00:18:31.930
And I haven't heard
people talking

00:18:31.930 --> 00:18:36.170
about metrics that could be
gathered on real traffic.

00:18:36.170 --> 00:18:39.000
And there was that great
blog post like a year or so

00:18:39.000 --> 00:18:40.770
ago from Twitter
where they said,

00:18:40.770 --> 00:18:43.960
our performance metric
is time to first tweet.

00:18:43.960 --> 00:18:45.940
But I forget exactly
what they did.

00:18:45.940 --> 00:18:48.780
But whatever they
did really wasn't

00:18:48.780 --> 00:18:51.540
exactly on when the
tweet was rendered,

00:18:51.540 --> 00:18:54.840
because we have no way of
measuring that via JavaScript

00:18:54.840 --> 00:18:55.750
on real pages.

00:18:55.750 --> 00:18:59.370
And so it seems like we
could do a lot of things

00:18:59.370 --> 00:19:01.930
on what kind of
rendering metrics

00:19:01.930 --> 00:19:05.000
we want to gather in the
real world, but like,

00:19:05.000 --> 00:19:06.440
this is a really obvious one.

00:19:06.440 --> 00:19:09.330
I've got a key
container in my page

00:19:09.330 --> 00:19:11.910
that contains the first
tweet or the photo of the day

00:19:11.910 --> 00:19:13.670
or whatever, and I
just want to know

00:19:13.670 --> 00:19:15.470
when it finishes rendering.

00:19:15.470 --> 00:19:17.860
Is there a way that we--
are people working on that?

00:19:17.860 --> 00:19:20.830
Or what kind of
real-world metrics

00:19:20.830 --> 00:19:24.375
can be gathered with
regard to layout?

00:19:24.375 --> 00:19:26.600
CHRISTOPHER CHEDEAU: So
what we do on the iOS app

00:19:26.600 --> 00:19:30.750
is we log for each
news feed cell

00:19:30.750 --> 00:19:32.850
how much time it
takes to run them.

00:19:32.850 --> 00:19:35.950
And so this way, we
know on each device

00:19:35.950 --> 00:19:38.410
all the devices, how
much time [INAUDIBLE],

00:19:38.410 --> 00:19:39.660
so we can improve it.

00:19:39.660 --> 00:19:42.590
And we also have
a smoothness test

00:19:42.590 --> 00:19:46.210
where we log how many FPS
do we get, how many frames

00:19:46.210 --> 00:19:49.220
do we drop, when do we drop
them, what causes a drop.

00:19:49.220 --> 00:19:52.290
And this way, we can
aggregate on the real traffic

00:19:52.290 --> 00:19:55.700
how much layouts is costing
us and how much rendering

00:19:55.700 --> 00:19:56.470
is costing us.

00:19:56.470 --> 00:19:58.370
But unfortunately,
on the web, there's

00:19:58.370 --> 00:20:00.944
no real API for us to do that.

00:20:00.944 --> 00:20:01.610
MIKE SHAVER: OK.

00:20:01.610 --> 00:20:02.110
Great.

00:20:02.110 --> 00:20:04.400
So I think we'll move to
the next question now.

00:20:07.028 --> 00:20:07.920
Excellent.

00:20:07.920 --> 00:20:10.210
We'll move to the
next question now.

00:20:10.210 --> 00:20:13.300
So most of the performance
improvements that we see today

00:20:13.300 --> 00:20:15.810
are really being focused
around GPU optimization,

00:20:15.810 --> 00:20:18.780
especially around rasterization
and compositing it,

00:20:18.780 --> 00:20:21.620
making that asynchronous or
doing it in alternate hardware.

00:20:21.620 --> 00:20:23.080
Once that well was
dry, or to apply

00:20:23.080 --> 00:20:27.380
to other aspects of
layout performance,

00:20:27.380 --> 00:20:31.037
where do we see the next major
performance improvement there?

00:20:31.037 --> 00:20:32.620
And I'll ask, I
guess, David to start.

00:20:32.620 --> 00:20:35.340
What's on the menu?

00:20:35.340 --> 00:20:37.340
DAVID BARON: In some ways,
it's hard to predict.

00:20:37.340 --> 00:20:39.930
One area that could
be big is parallelism

00:20:39.930 --> 00:20:43.930
just because one of the
trends with hardware

00:20:43.930 --> 00:20:46.380
these days is that you're
not getting faster cores,

00:20:46.380 --> 00:20:48.030
you're getting more cores.

00:20:48.030 --> 00:20:52.970
And the web needs to figure
out how to exploit that better.

00:20:52.970 --> 00:20:57.050
Things like script in
the DOM-- like the web

00:20:57.050 --> 00:21:03.120
sort of has the sort of
single-threaded programming

00:21:03.120 --> 00:21:04.010
model of the DOM.

00:21:04.010 --> 00:21:05.580
But there are things
in layout that

00:21:05.580 --> 00:21:08.300
can certainly be
parallelized better.

00:21:08.300 --> 00:21:10.690
That said, we don't
even necessarily

00:21:10.690 --> 00:21:13.640
know what the next
thing is going to be.

00:21:13.640 --> 00:21:16.587
It could end up being other
things that make things faster.

00:21:16.587 --> 00:21:18.420
PAUL LEWIS: When I
tested it this past week,

00:21:18.420 --> 00:21:20.790
and I have spoken with people,
layout itself was fast.

00:21:20.790 --> 00:21:23.730
And parallelizing that
doesn't seem to me

00:21:23.730 --> 00:21:28.760
to bring us any great wins
unless I'm missing something

00:21:28.760 --> 00:21:29.524
from there.

00:21:29.524 --> 00:21:30.190
I agree, though.

00:21:30.190 --> 00:21:32.177
We definitely-- the
thing we optimized

00:21:32.177 --> 00:21:34.010
for is what I was trying
to say at the start

00:21:34.010 --> 00:21:35.760
is we have to optimize
in the direction

00:21:35.760 --> 00:21:39.400
that people want us to go, which
is if you're trying to build

00:21:39.400 --> 00:21:42.550
web apps, we should try
and make web apps fast.

00:21:42.550 --> 00:21:47.290
It's probably a really simple
way to look at the world.

00:21:47.290 --> 00:21:50.050
CHARLES YING: Another
way to improve speed

00:21:50.050 --> 00:21:52.760
is to reduce the amount
of work that's being done.

00:21:52.760 --> 00:21:55.550
I mean, we have
parallel core desktops,

00:21:55.550 --> 00:21:57.250
but when you look
at a mobile phone,

00:21:57.250 --> 00:22:00.740
we're still at quad core,
which still blows my mind.

00:22:00.740 --> 00:22:05.830
But small numbers
of cores on phones.

00:22:05.830 --> 00:22:09.790
So one way to do
that would be to give

00:22:09.790 --> 00:22:14.890
fast paths or different ways
of having web apps interact

00:22:14.890 --> 00:22:16.170
with the browser core.

00:22:16.170 --> 00:22:19.170
For example, the way
React does a virtual DOM,

00:22:19.170 --> 00:22:22.890
and batches commands, and sends
them to the DOM all at once.

00:22:22.890 --> 00:22:26.470
And that is an improved
API if you had some deeper

00:22:26.470 --> 00:22:29.820
integration, so the browser
could understand those things.

00:22:29.820 --> 00:22:31.362
And apps are not
integrating so much.

00:22:31.362 --> 00:22:32.903
PAUL LEWIS: The
thing that worries me

00:22:32.903 --> 00:22:35.850
about that is this idea that
you have to take everything off.

00:22:35.850 --> 00:22:38.580
It's like reimplementing
the browser's everything

00:22:38.580 --> 00:22:40.470
to just do the one thing.

00:22:40.470 --> 00:22:42.781
And that just feels so alien.

00:22:42.781 --> 00:22:45.030
Like you say, if the deeper
integration is these hooks

00:22:45.030 --> 00:22:47.660
in so that you actually
have more direct control

00:22:47.660 --> 00:22:49.310
over the parts of the pipeline
rather than having to go,

00:22:49.310 --> 00:22:50.795
I'll just do it all
myself then, fine,

00:22:50.795 --> 00:22:52.152
if you want a job done properly.

00:22:52.152 --> 00:22:54.110
CHARLES YING: Well, I
think it's more of, like,

00:22:54.110 --> 00:22:54.850
batching up things.

00:22:54.850 --> 00:22:57.090
So for example, the way I said
attributes on a DOM element

00:22:57.090 --> 00:22:59.214
is I have to call-- if I
want to set 10 attributes,

00:22:59.214 --> 00:23:02.600
I have to say, set attribute,
set attribute, set attribute.

00:23:02.600 --> 00:23:07.270
Or I could inject
HTML, which I don't

00:23:07.270 --> 00:23:08.800
know if that's even better.

00:23:08.800 --> 00:23:12.550
But if there was a command that
said, like, send 10 attributes

00:23:12.550 --> 00:23:15.610
and set them all at once
as one call, for example.

00:23:15.610 --> 00:23:19.555
Some kind of improved APIs.

00:23:19.555 --> 00:23:20.930
MALE SPEAKER:
Could we get more--

00:23:20.930 --> 00:23:23.500
MIKE SHAVER: Sorry, I'm going
to take one from the delegates

00:23:23.500 --> 00:23:25.361
there, too.

00:23:25.361 --> 00:23:26.490
Oh, I was going to.

00:23:26.490 --> 00:23:29.241
Was it Jordan?

00:23:29.241 --> 00:23:29.740
No.

00:23:29.740 --> 00:23:30.940
MALE SPEAKER: It's
different [INAUDIBLE].

00:23:30.940 --> 00:23:32.520
MIKE SHAVER: It's different now.

00:23:32.520 --> 00:23:34.136
Ada?

00:23:34.136 --> 00:23:35.260
Does Ada have a microphone?

00:23:35.260 --> 00:23:35.760
Oh.

00:23:35.760 --> 00:23:37.222
Oh, gees.

00:23:37.222 --> 00:23:37.790
Sorry.

00:23:37.790 --> 00:23:39.540
Sorry, I thought we
had somebody up there.

00:23:42.504 --> 00:23:50.300
AUDIENCE: Is it worth having
multiple optimized settings

00:23:50.300 --> 00:23:54.510
that you could say, this
page is more like a web app,

00:23:54.510 --> 00:24:00.820
this page is more like a
document, optimize accordingly?

00:24:00.820 --> 00:24:01.660
MIKE SHAVER: Yeah.

00:24:01.660 --> 00:24:04.247
Well, I think it'd be an
interesting question maybe

00:24:04.247 --> 00:24:06.080
for David is, what could
developers tell you

00:24:06.080 --> 00:24:09.750
about their pages that would let
you lay them out more quickly,

00:24:09.750 --> 00:24:11.810
let you render
them more quickly.

00:24:11.810 --> 00:24:14.640
DAVID BARON: I think
whenever there's a-- no, no,

00:24:14.640 --> 00:24:16.060
that's too strong a statement.

00:24:16.060 --> 00:24:18.460
But there are many cases
where there's things

00:24:18.460 --> 00:24:20.800
that developers could
tell us that we could

00:24:20.800 --> 00:24:24.080
use to optimize in one
direction or another.

00:24:24.080 --> 00:24:26.340
But we could also just do
those things on our own.

00:24:26.340 --> 00:24:28.830
We can detect that you
don't use this feature

00:24:28.830 --> 00:24:30.490
and optimize that way.

00:24:30.490 --> 00:24:39.450
The hard part about
that is the risk

00:24:39.450 --> 00:24:41.500
is we create weird
performance characteristics

00:24:41.500 --> 00:24:42.480
for the platform.

00:24:42.480 --> 00:24:46.800
In other words, if we
have a mechanism where

00:24:46.800 --> 00:24:50.030
if you don't use any floats,
some set of layout things

00:24:50.030 --> 00:24:52.090
are a lot faster.

00:24:52.090 --> 00:24:54.680
And then you pull in some
piece of external content

00:24:54.680 --> 00:24:57.030
that has a float, and
you trigger that bit.

00:24:57.030 --> 00:24:58.406
That's going to
be hard to debug.

00:24:58.406 --> 00:25:00.446
CHRISTOPHER CHEDEAU: But
the storage is the case.

00:25:00.446 --> 00:25:01.215
DAVID BARON: Yeah.

00:25:01.215 --> 00:25:03.920
CHRISTOPHER CHEDEAU: If you
have on-wheel and you use it,

00:25:03.920 --> 00:25:06.390
then you're going to
hit all the [INAUDIBLE]

00:25:06.390 --> 00:25:07.960
performance in WebKit.

00:25:07.960 --> 00:25:08.991
MIKE SHAVER: Yeah.

00:25:08.991 --> 00:25:09.490
OK.

00:25:09.490 --> 00:25:12.389
I want to take-- Larry
was up and then not.

00:25:12.389 --> 00:25:13.180
And now here he is.

00:25:13.180 --> 00:25:14.460
Yes, I want to take a
question from him [INAUDIBLE].

00:25:14.460 --> 00:25:15.835
AUDIENCE: I was
just going to ask

00:25:15.835 --> 00:25:17.660
you to talk about the
relationship of relay

00:25:17.660 --> 00:25:20.310
out performance in the
HTTP2 with server push

00:25:20.310 --> 00:25:22.892
and prioritization,
because I thought

00:25:22.892 --> 00:25:26.350
that would be a major factor of
something new coming that would

00:25:26.350 --> 00:25:28.550
change how layout would perform.

00:25:33.690 --> 00:25:36.100
DAVID BARON: I think there
are a bunch of things

00:25:36.100 --> 00:25:42.480
we can do to get better-- like,
provide feedback from layout

00:25:42.480 --> 00:25:45.440
within the browser to
better prioritize what

00:25:45.440 --> 00:25:47.580
resources we're loading.

00:25:47.580 --> 00:25:49.730
I think hopefully,
some of that will

00:25:49.730 --> 00:25:54.400
be happening within not
too far in the future.

00:25:54.400 --> 00:26:00.290
But that's not something--
I wouldn't expect things

00:26:00.290 --> 00:26:02.780
like orders of magnitude
improvement out of that.

00:26:02.780 --> 00:26:07.800
But I would expect sort
of better responsiveness

00:26:07.800 --> 00:26:11.061
for the first useful
appearance of a page.

00:26:11.061 --> 00:26:12.810
CHRISTOPHER CHEDEAU:
So I have a question.

00:26:12.810 --> 00:26:16.010
So on iOS, what we do is
we render all the stories,

00:26:16.010 --> 00:26:17.640
like, in a different thread.

00:26:17.640 --> 00:26:20.730
And whenever they are rendered,
we push into the main thread.

00:26:20.730 --> 00:26:23.380
And unfortunately, we
cannot do that on the web,

00:26:23.380 --> 00:26:26.910
because in a web [INAUDIBLE]
we cannot have access to CSS.

00:26:26.910 --> 00:26:30.070
And we cannot even-- like, I
tried to re-implement a big

00:26:30.070 --> 00:26:33.230
part of CSS, but I don't have
any text measurement API.

00:26:33.230 --> 00:26:35.450
So I cannot even
re-implement CSS.

00:26:35.450 --> 00:26:37.980
So is there a way
for me as a developer

00:26:37.980 --> 00:26:41.950
to prepare some of the part of
the UI in a different thread,

00:26:41.950 --> 00:26:45.879
and then push them back to the
main thread, so we don't stall?

00:26:45.879 --> 00:26:47.420
MIKE SHAVER: That
actually takes us--

00:26:47.420 --> 00:26:48.622
I think, actually,
this is, I think,

00:26:48.622 --> 00:26:50.872
a good opportunity to move
to the next question, which

00:26:50.872 --> 00:26:51.660
is pretty related.

00:26:51.660 --> 00:26:52.830
Actually, I'll
take Dominic first.

00:26:52.830 --> 00:26:54.400
And then I want to come back
to this topic, because it's

00:26:54.400 --> 00:26:56.035
where we end up with
the next question.

00:26:56.035 --> 00:26:56.890
AUDIENCE: Yeah.

00:26:56.890 --> 00:26:57.765
I guess my question--

00:26:57.765 --> 00:26:58.550
MIKE SHAVER: Can you
please stand up-- sorry--

00:26:58.550 --> 00:26:59.650
so the camera can get you?

00:26:59.650 --> 00:27:01.015
AUDIENCE: Hi, camera.

00:27:01.015 --> 00:27:02.382
Oh, OK.

00:27:02.382 --> 00:27:03.340
MIKE SHAVER: Thank you.

00:27:03.340 --> 00:27:05.850
AUDIENCE: My question
is what can we

00:27:05.850 --> 00:27:09.600
learn from other operating
systems and native app

00:27:09.600 --> 00:27:10.624
frameworks and so on?

00:27:10.624 --> 00:27:13.040
Like, what is the web doing
that's so different that makes

00:27:13.040 --> 00:27:16.720
it so hard, or is it hard
everywhere and everybody's

00:27:16.720 --> 00:27:18.840
just more professional
on iOS and they're

00:27:18.840 --> 00:27:20.881
able to do their job and
get 60 frames per second

00:27:20.881 --> 00:27:21.670
and we're not?

00:27:21.670 --> 00:27:24.550
Like, what is different
in iOS and Windows and all

00:27:24.550 --> 00:27:27.046
these things that
we could learn from?

00:27:27.046 --> 00:27:27.795
MIKE SHAVER: Yeah.

00:27:27.795 --> 00:27:30.830
And we actually have a question
to that that I do wanna

00:27:30.830 --> 00:27:32.840
sort of get to, but
I'd sort of like to-- I

00:27:32.840 --> 00:27:34.840
think that's a bigger
question than we have time

00:27:34.840 --> 00:27:37.315
for in the remaining
time on this topic.

00:27:37.315 --> 00:27:39.440
I want to make sure we have
a bunch of time for it.

00:27:39.440 --> 00:27:41.230
But I do want to
push in here-- there

00:27:41.230 --> 00:27:44.110
was another sort of question.

00:27:44.110 --> 00:27:46.720
So we can move to
the next one here.

00:27:46.720 --> 00:27:48.750
Layout's often poorly
suited, as Christopher

00:27:48.750 --> 00:27:54.120
was saying, to having innovation
in user space, in script space.

00:27:54.120 --> 00:27:58.710
It's hard to poly-fill new
layout types and so forth.

00:27:58.710 --> 00:28:00.280
What do libraries
need from browsers?

00:28:00.280 --> 00:28:01.720
What are the most
important primitives

00:28:01.720 --> 00:28:03.261
to expose there, so
we could see more

00:28:03.261 --> 00:28:05.990
of these things experimented
on at the pace of the script

00:28:05.990 --> 00:28:08.652
library rather than at the
pace of browser implementation?

00:28:08.652 --> 00:28:10.860
WILSON PAGE: Well, I think
I'd be really excited just

00:28:10.860 --> 00:28:12.670
to have more hooks,
like Paul was saying,

00:28:12.670 --> 00:28:15.622
into when the browser
is doing things.

00:28:15.622 --> 00:28:17.080
Like we have
requestanimationframe,

00:28:17.080 --> 00:28:19.496
which is great to do just
before paint, so we can be like,

00:28:19.496 --> 00:28:21.490
yep, get that at the right time.

00:28:21.490 --> 00:28:23.770
But it'd be really
interesting to know even

00:28:23.770 --> 00:28:27.860
when layout has happened or
when layout is about to happen,

00:28:27.860 --> 00:28:30.380
because sometimes parts
of the page might change,

00:28:30.380 --> 00:28:31.860
and you just have no idea.

00:28:31.860 --> 00:28:35.924
There's no way of detecting when
the parts of the page change,

00:28:35.924 --> 00:28:37.840
because if you were doing
stuff in JavaScript,

00:28:37.840 --> 00:28:41.050
some things in layout
that CSS can't do,

00:28:41.050 --> 00:28:44.080
you need to be able to know,
ah, a class in the body

00:28:44.080 --> 00:28:48.840
changed which hid
this thing, and then

00:28:48.840 --> 00:28:50.060
changed the width of this.

00:28:50.060 --> 00:28:51.800
And you just have
no way of knowing--

00:28:51.800 --> 00:28:55.040
mutation observers
don't go that far.

00:28:55.040 --> 00:28:59.920
So that's something
I think would really

00:28:59.920 --> 00:29:02.410
enable libraries to do more.

00:29:02.410 --> 00:29:06.106
MIKE SHAVER: And Alex?

00:29:06.106 --> 00:29:08.335
To Christophers' point--
I wish my colleague,

00:29:08.335 --> 00:29:09.814
Elliott's friend was here.

00:29:09.814 --> 00:29:11.230
He'd do a much
better job of this.

00:29:11.230 --> 00:29:12.666
Oh, is he?

00:29:12.666 --> 00:29:14.040
Well, Elliott,
how about you take

00:29:14.040 --> 00:29:17.971
this about what the
primitives for CSS should be.

00:29:17.971 --> 00:29:20.198
MALE SPEAKER: Here
you go, Elliott.

00:29:20.198 --> 00:29:21.822
MIKE SHAVER: That
was beautifully done.

00:29:21.822 --> 00:29:25.497
ELLIOTT: I got
microphone-sniped.

00:29:25.497 --> 00:29:27.580
I think the biggest thing
that's missing right now

00:29:27.580 --> 00:29:31.190
is text measurement,
as brought up.

00:29:31.190 --> 00:29:33.620
We have no API to measure text.

00:29:33.620 --> 00:29:35.200
And that's usually deficient.

00:29:35.200 --> 00:29:38.660
And Canvas has this really
painful to use text measurement

00:29:38.660 --> 00:29:39.390
API.

00:29:39.390 --> 00:29:41.830
Anyone who's ever used
it understands quite

00:29:41.830 --> 00:29:43.150
how painful it is.

00:29:43.150 --> 00:29:45.850
And I think if I was going to
expand the space right now,

00:29:45.850 --> 00:29:49.170
I would like to expose the way
that we break up line boxes,

00:29:49.170 --> 00:29:52.580
and wrap text, and measure
text, and text justification,

00:29:52.580 --> 00:29:53.687
and glyph sizing.

00:29:53.687 --> 00:29:55.270
And I think that
that goes a long way.

00:29:55.270 --> 00:29:57.030
Canvas already has the
ability to draw a rectangle,

00:29:57.030 --> 00:29:58.321
but it has no way to wrap text.

00:29:58.321 --> 00:30:00.090
And that just seems
like something

00:30:00.090 --> 00:30:03.375
that we should solve for you.

00:30:03.375 --> 00:30:05.610
WILSON PAGE: Yeah, the
case I was talking about

00:30:05.610 --> 00:30:09.130
was actually a component we
made where we had to, like,

00:30:09.130 --> 00:30:11.410
dynamically fit text in a box.

00:30:11.410 --> 00:30:12.870
Like the box is this big.

00:30:12.870 --> 00:30:15.360
OK, let's shrink the text
down, and like, oh-- just

00:30:15.360 --> 00:30:16.552
using the available space.

00:30:16.552 --> 00:30:18.010
And we had to do
some measurements,

00:30:18.010 --> 00:30:19.640
and there might be
pieces either side

00:30:19.640 --> 00:30:22.340
of the text which
change the block size.

00:30:22.340 --> 00:30:23.780
Or those pieces
might get hidden.

00:30:23.780 --> 00:30:25.960
And it's really hard
for us to detect that.

00:30:25.960 --> 00:30:30.192
So sometimes we just have
to manually say, resize now.

00:30:30.192 --> 00:30:30.900
And I don't know.

00:30:30.900 --> 00:30:31.565
It gets messy.

00:30:31.565 --> 00:30:32.440
It gets really messy.

00:30:32.440 --> 00:30:34.606
CHRISTOPHER CHEDEAU: So to
get back on W's question,

00:30:34.606 --> 00:30:40.002
the way the browser layout
works is you put your CSS,

00:30:40.002 --> 00:30:42.460
and the browser is going to do
an entire layout [INAUDIBLE]

00:30:42.460 --> 00:30:43.600
on everything.

00:30:43.600 --> 00:30:45.730
And if you want to
control the [INAUDIBLE]

00:30:45.730 --> 00:30:49.200
for the one element, you want
to inside change what you want,

00:30:49.200 --> 00:30:51.740
like to change the size
of the inner element,

00:30:51.740 --> 00:30:54.420
you've got to do a full
layout pass, measured element,

00:30:54.420 --> 00:30:56.814
update the children, and
do a full layout pass.

00:30:56.814 --> 00:30:58.730
And the way it's working
on iOS and on Android

00:30:58.730 --> 00:31:01.540
is for each element,
you know its size,

00:31:01.540 --> 00:31:05.020
and you have to manually
specify the size of the children

00:31:05.020 --> 00:31:06.200
and the size of yourself.

00:31:06.200 --> 00:31:09.090
So the API is a
lot more painful,

00:31:09.090 --> 00:31:12.094
but it enables you to do, like,
everything you want, basically.

00:31:12.094 --> 00:31:13.760
So on one side on
web, it's pretty easy.

00:31:13.760 --> 00:31:16.500
You declare what you
want, and it gets done.

00:31:16.500 --> 00:31:18.850
But you don't have that
fine-grained control.

00:31:18.850 --> 00:31:19.710
PAUL LEWIS: Right.

00:31:19.710 --> 00:31:21.160
And the web, in that
sense, becomes magical.

00:31:21.160 --> 00:31:23.740
And it's brilliant, because if
you just want to lay out text,

00:31:23.740 --> 00:31:25.380
it will do it for you.

00:31:25.380 --> 00:31:27.900
But if you want to take
control and do that yourself,

00:31:27.900 --> 00:31:29.124
there is no way, right?

00:31:29.124 --> 00:31:31.040
And this is firmly--
I'll be interested to see

00:31:31.040 --> 00:31:32.999
how the extensible web
one goes this afternoon,

00:31:32.999 --> 00:31:35.081
because I think that's
right in that territory of,

00:31:35.081 --> 00:31:36.840
can you expose these
things in such a way

00:31:36.840 --> 00:31:39.485
that if somebody was desperate
to do their own text layout,

00:31:39.485 --> 00:31:41.110
they could do that,
and they could also

00:31:41.110 --> 00:31:43.854
measure how long
that thing took?

00:31:43.854 --> 00:31:45.520
Because that's the
other aspect to this.

00:31:45.520 --> 00:31:47.460
You can go off-road,
do your own thing.

00:31:47.460 --> 00:31:49.370
But you should also
know the impact

00:31:49.370 --> 00:31:51.480
of doing that and what
you're trading off

00:31:51.480 --> 00:31:55.679
when you take the browser's
job from it and do it yourself.

00:31:55.679 --> 00:31:57.970
What does that actually then
mean for you and your app?

00:31:57.970 --> 00:31:59.810
CHARLES YING: At
Flipboard, we actually do

00:31:59.810 --> 00:32:01.830
a lot of our page
layout in JavaScript.

00:32:01.830 --> 00:32:03.690
And that's because
we want things

00:32:03.690 --> 00:32:06.610
like baseline grids, and
column grids, and gutters,

00:32:06.610 --> 00:32:09.060
and things that just
aren't available

00:32:09.060 --> 00:32:13.360
in the browser, something
like CSS columns,

00:32:13.360 --> 00:32:15.630
but with more
things that we want

00:32:15.630 --> 00:32:16.850
specific to our application.

00:32:16.850 --> 00:32:19.540
And we struggle with
things like knowing

00:32:19.540 --> 00:32:22.160
when the font loaded
so we could measure it.

00:32:22.160 --> 00:32:27.070
And we have workarounds
to measure text.

00:32:27.070 --> 00:32:28.940
And we get around
it by saying, let's

00:32:28.940 --> 00:32:31.640
put a DOM element into the
body, and size it this way,

00:32:31.640 --> 00:32:32.920
and then measure it.

00:32:32.920 --> 00:32:34.646
But that's really hacky.

00:32:34.646 --> 00:32:36.520
And we still don't know
when the font loaded.

00:32:36.520 --> 00:32:39.230
So those are the kinds of
things that we deal with.

00:32:39.230 --> 00:32:41.130
And it's top of
the profile for us.

00:32:41.130 --> 00:32:44.320
Everything else, we
can kind of get done.

00:32:44.320 --> 00:32:46.690
But not that.

00:32:46.690 --> 00:32:48.190
DAVID BARON: I think
Elliott's point

00:32:48.190 --> 00:32:51.380
about exposing the stuff
about text measurement,

00:32:51.380 --> 00:32:53.630
and breaking, and
wrapping, and things

00:32:53.630 --> 00:32:58.360
like that, I hadn't actually
heard that feedback before.

00:32:58.360 --> 00:33:00.680
And it's certainly
something useful

00:33:00.680 --> 00:33:06.520
that I think is relatively
doable in terms of something

00:33:06.520 --> 00:33:07.820
we can expose.

00:33:07.820 --> 00:33:11.740
I think it's also somewhat
different from the idea

00:33:11.740 --> 00:33:16.070
of actually exposing
the full layout

00:33:16.070 --> 00:33:20.080
model in the idea behind the
extensible web manifesto, which

00:33:20.080 --> 00:33:23.510
would sort of say that we
want to actually expose

00:33:23.510 --> 00:33:27.860
the concepts you would need to
do something like build Flexbox

00:33:27.860 --> 00:33:31.260
in an implementation that
didn't already have it.

00:33:31.260 --> 00:33:35.790
That said, doing all of
that is really hard because

00:33:35.790 --> 00:33:39.210
of the complexity of
all the existing layout

00:33:39.210 --> 00:33:42.340
concepts that we have,
and how those concepts

00:33:42.340 --> 00:33:47.460
interact with each other in a
whole bunch of different ways.

00:33:47.460 --> 00:33:48.915
CHRISTOPHER CHEDEAU: So yeah.

00:33:48.915 --> 00:33:51.320
To get back on you on the
trying to re-implement Flexbox,

00:33:51.320 --> 00:33:54.720
one of the big missing parts we
have is you cannot [INAUDIBLE]

00:33:54.720 --> 00:33:58.920
it, because if you add a
rule that doesn't exist

00:33:58.920 --> 00:34:02.180
in the browser, the browser--
like, in the dev tools,

00:34:02.180 --> 00:34:03.670
you can see it,
but in JavaScript,

00:34:03.670 --> 00:34:05.310
you have no way to
actually see it.

00:34:05.310 --> 00:34:07.700
So one of the great things
with browser and JavaScript

00:34:07.700 --> 00:34:11.260
is you can poly-fill all
the APIs back to IE6.

00:34:11.260 --> 00:34:12.790
But in the CSS, you cannot.

00:34:12.790 --> 00:34:15.160
And the people that did
poly-fill Flexbox, what

00:34:15.160 --> 00:34:19.120
they did, they implemented
a full CSS parser

00:34:19.120 --> 00:34:21.250
and a full, like,
CSS selector engine.

00:34:21.250 --> 00:34:24.480
And every time something
changes in the DOM,

00:34:24.480 --> 00:34:27.560
they re-implement CSS.

00:34:27.560 --> 00:34:29.269
And just you get
Flexbox, which is crazy.

00:34:29.269 --> 00:34:31.351
DAVID BARON: I think that's
the easy part, though.

00:34:31.351 --> 00:34:32.525
Like, I think we could add--

00:34:32.525 --> 00:34:34.191
MIKE SHAVER: I think
that's very telling

00:34:34.191 --> 00:34:35.469
that that's the easy part.

00:34:35.469 --> 00:34:36.684
[INTERPOSING VOICES]

00:34:36.684 --> 00:34:37.600
DAVID BARON: Well, no.

00:34:37.600 --> 00:34:40.310
I think fixing that is the
easy part in that we could

00:34:40.310 --> 00:34:42.359
add an API for poly-filling
CSS properties.

00:34:42.359 --> 00:34:43.650
CHRISTOPHER CHEDEAU: Please do.

00:34:43.650 --> 00:34:45.233
DAVID BARON: And
that would be an API.

00:34:45.233 --> 00:34:49.420
But that API would be much
easier to add than the API

00:34:49.420 --> 00:34:51.143
for becoming part
of a layout model.

00:34:51.143 --> 00:34:52.226
CHRISTOPHER CHEDEAU: Yeah.

00:34:52.226 --> 00:34:53.392
Well, that's the first step.

00:34:53.392 --> 00:34:54.632
MIKE SHAVER: And Alex?

00:34:54.632 --> 00:34:55.132
Oh.

00:34:55.132 --> 00:34:56.280
Sorry, yeah.

00:34:56.280 --> 00:34:58.420
When you have a comment,
to raise your hand up.

00:34:58.420 --> 00:34:59.770
AUDIENCE: I have a question.

00:34:59.770 --> 00:35:04.080
So my question is, are
we going to a future

00:35:04.080 --> 00:35:07.680
where basically the [INAUDIBLE]
going to be exposed?

00:35:07.680 --> 00:35:09.860
What should be
exposed to content

00:35:09.860 --> 00:35:11.910
alters and what should not?

00:35:11.910 --> 00:35:14.280
Because from my
understanding, most content

00:35:14.280 --> 00:35:17.730
alters, they [INAUDIBLE]
as a black box.

00:35:17.730 --> 00:35:21.684
Like, I write a CSS rule,
and something happens.

00:35:21.684 --> 00:35:22.460
MIKE SHAVER: Yeah.

00:35:22.460 --> 00:35:24.552
This is an interesting
sort of issue

00:35:24.552 --> 00:35:26.760
is how much does it change
the ergonomics of building

00:35:26.760 --> 00:35:29.880
a website that just works
across devices and so forth?

00:35:29.880 --> 00:35:33.714
What do you think we
shouldn't expose, Paul?

00:35:33.714 --> 00:35:36.415
PAUL LEWIS: That's a really--
I don't know what the use case.

00:35:36.415 --> 00:35:39.450
Actually, I don't know
what it is at this point

00:35:39.450 --> 00:35:41.440
that people are trying
to make-- well, we know.

00:35:41.440 --> 00:35:43.762
They're trying to
poly-fill Flexbox.

00:35:43.762 --> 00:35:45.470
And it should be in
support of use cases.

00:35:45.470 --> 00:35:48.357
It should absolutely be we
are trying to do these things.

00:35:48.357 --> 00:35:49.940
What primitives do
we need to do that?

00:35:49.940 --> 00:35:51.460
I don't know what those
are at this stage.

00:35:51.460 --> 00:35:53.626
I think we just need to
have the conversation rather

00:35:53.626 --> 00:35:57.330
than-- getting to this point,
as I said-- rendering today has

00:35:57.330 --> 00:36:00.240
had a pass to not
be part, seemingly,

00:36:00.240 --> 00:36:01.890
of the extensible web manifesto.

00:36:01.890 --> 00:36:04.620
I think that's time that we
took that question, said,

00:36:04.620 --> 00:36:06.259
should this actually be exposed?

00:36:06.259 --> 00:36:07.800
That's the thing,
the first question.

00:36:07.800 --> 00:36:08.810
If the answer's
yes, then I think

00:36:08.810 --> 00:36:11.090
we need to have a very long
and probably interesting

00:36:11.090 --> 00:36:12.220
conversation about
exactly what, but I

00:36:12.220 --> 00:36:13.000
don't know what that is yet.

00:36:13.000 --> 00:36:13.920
MIKE SHAVER: I want to
go to Alex in one sec,

00:36:13.920 --> 00:36:15.836
but I do want to hear
very quickly from David.

00:36:15.836 --> 00:36:17.410
What is the scariest
thing for you

00:36:17.410 --> 00:36:19.220
to expose to content authors?

00:36:19.220 --> 00:36:21.550
What would you want
to fix right away?

00:36:26.171 --> 00:36:27.670
DAVID BARON: It's
hard to even know,

00:36:27.670 --> 00:36:30.050
but there's a lot of things in
layout that are pretty scary.

00:36:30.050 --> 00:36:31.294
MIKE SHAVER: I'll let you get
away with that only because I

00:36:31.294 --> 00:36:32.841
really want to hear from Alex.

00:36:32.841 --> 00:36:33.904
AUDIENCE: Thanks.

00:36:33.904 --> 00:36:35.320
David, I'm really
actually kind of

00:36:35.320 --> 00:36:36.820
shocked to hear you say
that you haven't heard

00:36:36.820 --> 00:36:38.620
that feedback
before, specifically

00:36:38.620 --> 00:36:41.262
because I think the folks
who have been working

00:36:41.262 --> 00:36:43.470
in and around the extensible
web manifesto principles

00:36:43.470 --> 00:36:45.886
for the last couple of years
have been focused on the idea

00:36:45.886 --> 00:36:48.340
that you need to explain
yourself at a platform level

00:36:48.340 --> 00:36:50.490
when you provide capabilities
at the high level.

00:36:50.490 --> 00:36:53.120
And specifically, text
rendering seems like an easy one

00:36:53.120 --> 00:36:55.490
and participating in the
entire area of layout

00:36:55.490 --> 00:36:59.360
seems like the obvious
next set of steps for this.

00:36:59.360 --> 00:37:01.246
And I think to the
earlier question,

00:37:01.246 --> 00:37:02.870
should we expose the
render tree, well,

00:37:02.870 --> 00:37:05.070
if we can get a portable
description of how browsers

00:37:05.070 --> 00:37:08.090
operate, we owe it to users
to express as much of it

00:37:08.090 --> 00:37:09.225
as is safe, right?

00:37:09.225 --> 00:37:10.850
The answer of what
shouldn't you expose

00:37:10.850 --> 00:37:13.410
is maybe cross-origin
imagery back in a case

00:37:13.410 --> 00:37:14.660
where it isn't a core's image.

00:37:14.660 --> 00:37:16.150
Those are the sorts
of areas where

00:37:16.150 --> 00:37:17.816
there are security
implications for some

00:37:17.816 --> 00:37:21.080
of these compositional features
of the web that we can't break.

00:37:21.080 --> 00:37:24.700
But in every other area, I
challenge you differently

00:37:24.700 --> 00:37:27.889
and suggest that we should
be exposing everything

00:37:27.889 --> 00:37:30.180
that the browser can do to
the extent that is possible.

00:37:36.549 --> 00:37:39.080
DAVID BARON: I kind of have two
different responses to that.

00:37:39.080 --> 00:37:43.700
But I think there are
a few ways where layout

00:37:43.700 --> 00:37:49.030
is a little bit different in
that a bunch of the technology

00:37:49.030 --> 00:37:52.010
behind style and layout was
sort of designed with things

00:37:52.010 --> 00:37:54.560
like device
independence, and being

00:37:54.560 --> 00:37:56.640
able to adapt to different
sorts of devices,

00:37:56.640 --> 00:37:59.140
being able to adapt to
different user preferences

00:37:59.140 --> 00:38:01.170
as sort of a fundamental
characteristic

00:38:01.170 --> 00:38:02.960
of those technologies.

00:38:02.960 --> 00:38:08.370
I think if we had had these
capabilities before the iPhone,

00:38:08.370 --> 00:38:10.400
the iPhone people
would have done

00:38:10.400 --> 00:38:14.170
things that would have made
it a lot harder for the iPhone

00:38:14.170 --> 00:38:18.050
to adapt to desktop
web content to mobile.

00:38:18.050 --> 00:38:20.260
So I think I'm not saying
we shouldn't do it,

00:38:20.260 --> 00:38:23.190
but I'm saying I think we need
to be careful and try and do it

00:38:23.190 --> 00:38:26.950
in a way that doesn't break
those aspects of the way

00:38:26.950 --> 00:38:30.354
these technologies are designed.

00:38:30.354 --> 00:38:32.019
MIKE SHAVER: Very quickly.

00:38:32.019 --> 00:38:34.060
AUDIENCE: [INAUDIBLE]
don't accept your argument,

00:38:34.060 --> 00:38:36.180
because the same
is said for DOM.

00:38:36.180 --> 00:38:38.380
So for instance, the
argument is that if we

00:38:38.380 --> 00:38:41.032
had exposed what it means to
participate in the form system

00:38:41.032 --> 00:38:43.490
to the extent that you could
create a custom element, which

00:38:43.490 --> 00:38:46.190
is a true input box, then
iOS couldn't have styled

00:38:46.190 --> 00:38:48.340
the select element
the way it did.

00:38:48.340 --> 00:38:52.174
This is both misdirection
and roughly untrue.

00:38:52.174 --> 00:38:53.840
It is the case today
that people already

00:38:53.840 --> 00:38:55.190
have very large
JavaScript frameworks

00:38:55.190 --> 00:38:57.240
that re-implement large
portions of this stuff.

00:38:57.240 --> 00:38:59.219
And that content,
yes, didn't port.

00:38:59.219 --> 00:39:00.760
But developers have
strong incentives

00:39:00.760 --> 00:39:03.220
to do the things that are
cheap and free in the platform.

00:39:03.220 --> 00:39:05.011
And those are the things
that we can adapt.

00:39:05.011 --> 00:39:07.150
But it's when developers
get stuck that they

00:39:07.150 --> 00:39:08.340
need the flexibility.

00:39:08.340 --> 00:39:10.660
And they're not asking
for it because they

00:39:10.660 --> 00:39:12.549
don't want you to
adapt for them,

00:39:12.549 --> 00:39:14.590
they're asking for it
because you haven't adapted

00:39:14.590 --> 00:39:16.256
well enough for them
for the new context

00:39:16.256 --> 00:39:18.120
that they already
find themselves in.

00:39:18.120 --> 00:39:20.240
It's not about the
backward-looking scenario.

00:39:20.240 --> 00:39:21.864
It's about the
forward-looking scenario

00:39:21.864 --> 00:39:23.220
where you're not already ahead.

00:39:23.220 --> 00:39:26.000
And the argument behind the
extensible web manifesto

00:39:26.000 --> 00:39:28.720
is that you're not
going to be ahead.

00:39:28.720 --> 00:39:30.030
I can't predict the future.

00:39:30.030 --> 00:39:32.410
And I know that you're probably
better than me at this.

00:39:32.410 --> 00:39:34.970
But I also have a
reason to doubt.

00:39:34.970 --> 00:39:37.060
MIKE SHAVER: Thank you.

00:39:37.060 --> 00:39:40.175
We move on to the
next question here

00:39:40.175 --> 00:39:42.551
sort of in the similar vein.

00:39:42.551 --> 00:39:44.300
A lot of the hardest
things to do smoothly

00:39:44.300 --> 00:39:47.310
involve tracking the human input
where that feedback cycle needs

00:39:47.310 --> 00:39:48.770
to be very, very tight.

00:39:48.770 --> 00:39:50.520
And going through our
current abstractions

00:39:50.520 --> 00:39:51.780
can be a big problem.

00:39:51.780 --> 00:39:54.730
What are the missing
declarative or shortcut pieces

00:39:54.730 --> 00:39:56.350
that would get us,
in shorter order,

00:39:56.350 --> 00:39:58.683
to really a responsive and
smooth layout while resolving

00:39:58.683 --> 00:40:01.266
some of these bigger issues?

00:40:01.266 --> 00:40:03.140
Maybe what would you
Charles-- what would you

00:40:03.140 --> 00:40:06.660
like to see as a way to just
say, track this or give me

00:40:06.660 --> 00:40:08.790
fast feedback on this
for the kinds of apps

00:40:08.790 --> 00:40:11.875
you're building at Flipboard?

00:40:11.875 --> 00:40:14.260
CHARLES YING: I'll say
that a lot of what we've

00:40:14.260 --> 00:40:17.340
done in the past to make
performance, even on native,

00:40:17.340 --> 00:40:21.965
track well with good latency has
been to rasterize things, shove

00:40:21.965 --> 00:40:25.541
them in images, and then
show these images as facades,

00:40:25.541 --> 00:40:27.040
and let the user
interact with them.

00:40:27.040 --> 00:40:32.540
Browsers do that by rendering
web content into tiled images,

00:40:32.540 --> 00:40:34.820
and then show the
users the images.

00:40:34.820 --> 00:40:38.130
If we had more control to
be able to render content

00:40:38.130 --> 00:40:41.860
and control how those
[INAUDIBLE] to the user,

00:40:41.860 --> 00:40:46.070
we could give a lot more
smoothness to the user

00:40:46.070 --> 00:40:48.400
without saying to
the browsers, we

00:40:48.400 --> 00:40:53.130
need every little ounce of
performance you can give us.

00:40:53.130 --> 00:40:54.890
We can fake things.

00:40:54.890 --> 00:40:56.570
We have the ability
to fake things.

00:40:56.570 --> 00:40:59.440
We can put Band-aids
around things.

00:40:59.440 --> 00:41:01.672
PAUL LEWIS: I'm just curious.

00:41:01.672 --> 00:41:03.880
How does that differ from,
say, having a canvas where

00:41:03.880 --> 00:41:06.065
you can rasterize and take
control of rasterization

00:41:06.065 --> 00:41:06.565
yourself?

00:41:06.565 --> 00:41:08.260
CHARLES YING: So
on Flipboard, we

00:41:08.260 --> 00:41:11.510
have this page flip animation
where we cut the page in half

00:41:11.510 --> 00:41:13.860
and we flip it down like this.

00:41:13.860 --> 00:41:16.520
So the way we do that is
we render the entire page

00:41:16.520 --> 00:41:20.390
into an image, and then we split
it apart in the scene graph

00:41:20.390 --> 00:41:21.800
on the native side.

00:41:21.800 --> 00:41:25.870
And yes, I could
re-implement CSS in HTML,

00:41:25.870 --> 00:41:27.240
and render everything in it.

00:41:27.240 --> 00:41:29.050
That's been done before.

00:41:29.050 --> 00:41:31.077
But it's not ideal.

00:41:31.077 --> 00:41:32.910
So what we actually do
is we clone the node,

00:41:32.910 --> 00:41:38.890
and we animate the two
halves in two different DOMs.

00:41:38.890 --> 00:41:41.432
That's also really scary, too.

00:41:41.432 --> 00:41:43.140
PAUL LEWIS: I guess
the reason I'm asking

00:41:43.140 --> 00:41:45.650
is because if you
were so inclined,

00:41:45.650 --> 00:41:48.170
you could take WebGL
and 3GS, and and you

00:41:48.170 --> 00:41:50.240
could have a scene
graph, and you

00:41:50.240 --> 00:41:52.030
could check out an
image as a texture,

00:41:52.030 --> 00:41:53.395
and have it do the 3D thing--

00:41:53.395 --> 00:41:54.750
CHRISTOPHER CHEDEAU: But you've
got to reimplement everything

00:41:54.750 --> 00:41:55.340
if you do that.

00:41:55.340 --> 00:41:56.810
CHARLES YING: But we've got
all text rendering and all text

00:41:56.810 --> 00:41:57.540
layout as well.

00:41:57.540 --> 00:41:58.200
CHRISTOPHER CHEDEAU:
[INAUDIBLE].

00:41:58.200 --> 00:41:58.825
PAUL LEWIS: OK.

00:41:58.825 --> 00:42:02.550
So you see one of the goodies
of the ease of doing the web

00:42:02.550 --> 00:42:04.340
thing without having
to reimplement-- OK.

00:42:04.340 --> 00:42:05.120
MIKE SHAVER: Yeah.

00:42:05.120 --> 00:42:05.411
PAUL LEWIS: Right.

00:42:05.411 --> 00:42:05.510
Fine.

00:42:05.510 --> 00:42:07.676
CHRISTOPHER CHEDEAU: And
we had this with front-side

00:42:07.676 --> 00:42:10.700
[INAUDIBLE] where
unfortunately Chrome is not

00:42:10.700 --> 00:42:14.450
guaranteeing that it's
going to be in the layer.

00:42:14.450 --> 00:42:16.999
So we have no guarantee
that everything

00:42:16.999 --> 00:42:18.790
that's going to be
inside of this animation

00:42:18.790 --> 00:42:21.970
is not going to blow up
and re-layout while you're

00:42:21.970 --> 00:42:23.954
doing anything,
which is very scary.

00:42:23.954 --> 00:42:26.120
MIKE SHAVER: We have from
the audience here Dominic.

00:42:31.455 --> 00:42:32.160
AUDIENCE: OK.

00:42:32.160 --> 00:42:34.810
So speaking to this question
in particular about,

00:42:34.810 --> 00:42:37.915
like, touch and easy
shortcuts that we can do,

00:42:37.915 --> 00:42:40.040
I think this is really
interesting, because there's

00:42:40.040 --> 00:42:43.340
competing instincts people
have on the browser side.

00:42:43.340 --> 00:42:45.820
Some of them are like, we
should make touch events really

00:42:45.820 --> 00:42:48.900
low level, and we should
give you, like, hooks

00:42:48.900 --> 00:42:51.109
into before scroll
that are synchronous.

00:42:51.109 --> 00:42:52.900
And then you can-- if
you're really careful

00:42:52.900 --> 00:42:54.275
and you code really
well, you can

00:42:54.275 --> 00:42:55.827
get 60 FPS and complete control.

00:42:55.827 --> 00:42:57.660
Whereas some of the
other ideas that I think

00:42:57.660 --> 00:43:00.530
are really, really interesting,
and I want to see more of

00:43:00.530 --> 00:43:05.422
are what if we made gestures
or scrolling a timing,

00:43:05.422 --> 00:43:07.880
like a timeline that you could
hook up into web animations.

00:43:07.880 --> 00:43:09.505
So you could say, I
want this animation

00:43:09.505 --> 00:43:12.110
to be controlled by how
the user is scrolling

00:43:12.110 --> 00:43:13.790
or how they're gesturing.

00:43:13.790 --> 00:43:15.820
And that to me, when
you think of shortcuts

00:43:15.820 --> 00:43:18.305
that would make these
things easier and also fast,

00:43:18.305 --> 00:43:20.430
that, I think, is one of
the most interesting ideas

00:43:20.430 --> 00:43:21.840
I've seen.

00:43:21.840 --> 00:43:23.700
I'm not really sure
if people are into it.

00:43:23.700 --> 00:43:25.370
But I wanted to put
it out there in case

00:43:25.370 --> 00:43:26.970
people hadn't heard of it.

00:43:26.970 --> 00:43:31.790
DAVID BARON: I think the thing
to connect animation timelines

00:43:31.790 --> 00:43:34.590
to scrolling is a good idea.

00:43:34.590 --> 00:43:37.810
There's proposals for
it for both, I think,

00:43:37.810 --> 00:43:40.390
web animations and
for CSS animations.

00:43:40.390 --> 00:43:42.830
And I think a lot of people
are pretty excited about that.

00:43:42.830 --> 00:43:43.830
MIKE SHAVER: Yeah.

00:43:43.830 --> 00:43:46.140
Looking at some of the
web VR stuff that's

00:43:46.140 --> 00:43:48.330
being mooted right now,
one of the big issues in VR

00:43:48.330 --> 00:43:51.190
is the very low latency between
motion-to-photon to avoid

00:43:51.190 --> 00:43:52.564
sim sickness and so forth.

00:43:52.564 --> 00:43:54.730
If that's something we can
do in a programmatic way,

00:43:54.730 --> 00:43:56.265
that's great.

00:43:56.265 --> 00:43:57.640
Are there going
to be cases where

00:43:57.640 --> 00:43:59.830
we need to punch through
those abstractions for really

00:43:59.830 --> 00:44:00.670
purpose-built stuff?

00:44:00.670 --> 00:44:03.600
PAUL LEWIS: We have a history of
punching through for scrolling.

00:44:03.600 --> 00:44:06.660
And it's great
for that use case.

00:44:06.660 --> 00:44:10.605
But the moment you step off
that path, you're in trouble.

00:44:10.605 --> 00:44:11.730
You're in a lot of problem.

00:44:11.730 --> 00:44:13.920
And there's no way back out.

00:44:13.920 --> 00:44:15.470
When somebody says,
shortcut, it's

00:44:15.470 --> 00:44:17.260
like, for me, the
caveat has to be

00:44:17.260 --> 00:44:20.025
but it's a recreateable
shortcut with underpinning--

00:44:20.025 --> 00:44:21.650
MIKE SHAVER: And with
a smooth gradient

00:44:21.650 --> 00:44:23.660
of performance, ideally,
rather than some discontinuity.

00:44:23.660 --> 00:44:24.183
PAUL LEWIS: Yeah.

00:44:24.183 --> 00:44:25.599
Otherwise, it's
just unreasonable,

00:44:25.599 --> 00:44:27.253
because it's magic again.

00:44:27.253 --> 00:44:28.100
MIKE SHAVER: Right.

00:44:28.100 --> 00:44:31.895
Tobias is-- yeah, if you
have something to add,

00:44:31.895 --> 00:44:34.270
and I hope lots of people do,
if you raise your hand when

00:44:34.270 --> 00:44:35.660
you add yourself
to the list, then

00:44:35.660 --> 00:44:37.840
we can get the microphone
to you early and so forth.

00:44:37.840 --> 00:44:38.960
AUDIENCE: Yeah.

00:44:38.960 --> 00:44:42.820
So sorry, it's not related
to that question now.

00:44:42.820 --> 00:44:45.550
So regarding your fast path
in the browser where you say,

00:44:45.550 --> 00:44:47.990
well, I want to limit
myself to, let's

00:44:47.990 --> 00:44:50.050
say Flexbox or
something, because I know

00:44:50.050 --> 00:44:52.180
the brower's faster
there, how about we

00:44:52.180 --> 00:44:55.340
give the user control
of searching this?

00:44:55.340 --> 00:44:58.835
And whenever you use something
else, it gives you an error.

00:44:58.835 --> 00:45:01.750
Then you couldn't
even use it, and you

00:45:01.750 --> 00:45:03.640
would know if there's
something that

00:45:03.640 --> 00:45:07.380
would trigger the slow path.

00:45:07.380 --> 00:45:10.300
What's the problem with that?

00:45:10.300 --> 00:45:11.550
WILSON PAGE: Could you repeat?

00:45:11.550 --> 00:45:12.950
I didn't really
get the last of--

00:45:12.950 --> 00:45:15.950
MIKE SHAVER: You mean to
provide sort of a strict mode

00:45:15.950 --> 00:45:18.210
that pages can opt into a
smaller surface of the web

00:45:18.210 --> 00:45:18.520
platform--

00:45:18.520 --> 00:45:19.200
AUDIENCE: Yes.

00:45:19.200 --> 00:45:19.865
MIKE SHAVER: And
they just error out

00:45:19.865 --> 00:45:21.156
if they touch the wrong things?

00:45:21.156 --> 00:45:21.772
AUDIENCE: Yes.

00:45:21.772 --> 00:45:21.975
Right.

00:45:21.975 --> 00:45:23.974
WILSON PAGE: That sounds
like a good idea to me,

00:45:23.974 --> 00:45:28.210
but David said, like, vendors
can already kind of predict

00:45:28.210 --> 00:45:31.620
what features you're going to
be using by just seeing what

00:45:31.620 --> 00:45:32.920
properties you're--

00:45:32.920 --> 00:45:34.760
DAVID BARON: It's not
that we can predict.

00:45:34.760 --> 00:45:37.800
But if there's some
great thing we can do,

00:45:37.800 --> 00:45:40.570
we could already just count
whether you're doing it or not,

00:45:40.570 --> 00:45:44.960
and optimize based on that.

00:45:44.960 --> 00:45:46.730
The point he's making
is that he wants

00:45:46.730 --> 00:45:49.315
to ensure that he doesn't
fall off that fast path.

00:45:53.290 --> 00:45:55.320
We could do that sort of thing.

00:45:55.320 --> 00:45:58.090
When you say, error, people
have different interpretations

00:45:58.090 --> 00:45:58.590
of error.

00:45:58.590 --> 00:46:01.302
I think we don't want the
yellow screen of death,

00:46:01.302 --> 00:46:03.510
for those of you who are
familiar with external parse

00:46:03.510 --> 00:46:05.940
errors.

00:46:05.940 --> 00:46:09.315
But we could take a
root where you opt in

00:46:09.315 --> 00:46:13.390
to having a feature not work,
where "not work" means silently

00:46:13.390 --> 00:46:15.272
fail in some way.

00:46:15.272 --> 00:46:17.960
PAUL LEWIS: Wouldn't that
ruin the debug aspects

00:46:17.960 --> 00:46:20.040
where you go, I think
this should work,

00:46:20.040 --> 00:46:22.300
but again, it magically
doesn't work now?

00:46:22.300 --> 00:46:23.940
Or it feels like it--
because maybe you

00:46:23.940 --> 00:46:26.231
include a web component that
had switched something off

00:46:26.231 --> 00:46:27.490
or didn't expect something.

00:46:27.490 --> 00:46:28.980
Like that idea that
you're not always--

00:46:28.980 --> 00:46:29.970
MIKE SHAVER: [INAUDIBLE]
transitive knowledge.

00:46:29.970 --> 00:46:30.120
PAUL LEWIS: Yeah.

00:46:30.120 --> 00:46:32.870
You're not always in control
of every part of the page.

00:46:32.870 --> 00:46:35.270
And if that feels like it
would work in the context

00:46:35.270 --> 00:46:38.550
where you are, that
would be a concern

00:46:38.550 --> 00:46:40.900
that, yes, you don't
have the final say.

00:46:40.900 --> 00:46:42.870
Or if you switch
something on, you say,

00:46:42.870 --> 00:46:44.490
don't ever switch this off.

00:46:44.490 --> 00:46:47.030
And something that you need
to use needs to switch it off,

00:46:47.030 --> 00:46:48.410
we're in a very horrible place.

00:46:48.410 --> 00:46:48.940
WILSON PAGE: Yeah,
that doesn't really

00:46:48.940 --> 00:46:51.560
work when you're using
third-party scripts and stuff.

00:46:51.560 --> 00:46:53.330
You have no idea what
APIs they're using.

00:46:53.330 --> 00:46:55.200
And you might be like, oh,
I don't need an [INAUDIBLE],

00:46:55.200 --> 00:46:55.820
and turn it off.

00:46:55.820 --> 00:46:56.260
And then--

00:46:56.260 --> 00:46:58.140
MIKE SHAVER: Well, it's
a manifest-- no, sorry,

00:46:58.140 --> 00:46:59.450
I don't want to bore that talk.

00:46:59.450 --> 00:47:00.519
Sorry.

00:47:00.519 --> 00:47:02.310
I actually want to skip
a couple questions,

00:47:02.310 --> 00:47:03.690
because we only have time
for one more, I think.

00:47:03.690 --> 00:47:04.810
And I want to go
back to something

00:47:04.810 --> 00:47:07.351
Dominic raised earlier, which
is that native toolkits provide

00:47:07.351 --> 00:47:10.740
a ton of help for doing smooth
layout and smooth interactions.

00:47:10.740 --> 00:47:12.240
What do we need to
borrow from that?

00:47:12.240 --> 00:47:15.022
And where is the web
just-- where can we just

00:47:15.022 --> 00:47:16.980
copy our way to victory
in some of these cases?

00:47:20.029 --> 00:47:22.320
On support side, you deal
with a bunch of native pieces

00:47:22.320 --> 00:47:23.945
and you deal with a
bunch of web stuff.

00:47:23.945 --> 00:47:26.960
What do you miss most in terms
of the performance and layout

00:47:26.960 --> 00:47:29.706
characteristics when you
come back to the web?

00:47:29.706 --> 00:47:32.185
CHARLES YING: I
think for us, most,

00:47:32.185 --> 00:47:39.790
we probably miss improved
text manipulation primitives.

00:47:39.790 --> 00:47:41.180
I mean, more
broadly, I would say

00:47:41.180 --> 00:47:43.850
that things that are
missing are a pure way

00:47:43.850 --> 00:47:48.750
to get to render things into
a texture and show that.

00:47:48.750 --> 00:47:51.680
We know that this has
security implications

00:47:51.680 --> 00:47:54.196
if I were to render the
bank header in the browser

00:47:54.196 --> 00:47:55.070
Chrome on the screen.

00:47:55.070 --> 00:47:57.490
But having that kind
of behavior allows

00:47:57.490 --> 00:48:02.250
us to improve a lot of
paths in the application.

00:48:02.250 --> 00:48:04.310
And just more generally,
at previous companies,

00:48:04.310 --> 00:48:09.350
we've adopted Flash-like scene
graphs with shaders and things

00:48:09.350 --> 00:48:13.800
that run very fast, attached
to the hardware very closely,

00:48:13.800 --> 00:48:16.910
and having something
like core animation,

00:48:16.910 --> 00:48:18.850
or some other type
of scene graph

00:48:18.850 --> 00:48:21.820
would help with a lot
of animation cases

00:48:21.820 --> 00:48:23.450
that we run into.

00:48:26.291 --> 00:48:29.070
MIKE SHAVER: And so I mean,
you, on the Firefox OS

00:48:29.070 --> 00:48:32.650
side, Wilson-- I mean, you're
trying to build stuff that's

00:48:32.650 --> 00:48:36.170
experientially competitive with
those other platforms, right?

00:48:36.170 --> 00:48:38.500
You're really going
head to head with them.

00:48:38.500 --> 00:48:40.140
What us hard for you there?

00:48:40.140 --> 00:48:43.380
What do you go and stand over
David's desk and bang on it

00:48:43.380 --> 00:48:45.217
for?

00:48:45.217 --> 00:48:46.300
WILSON PAGE: I don't know.

00:48:46.300 --> 00:48:48.126
Well, at the moment,
like, tooling.

00:48:48.126 --> 00:48:49.000
We just need tooling.

00:48:49.000 --> 00:48:50.870
We need to know where
we're spending time.

00:48:50.870 --> 00:48:53.040
And there's always
this, like, pressure

00:48:53.040 --> 00:48:54.612
to no regression,
starter time must

00:48:54.612 --> 00:48:56.070
be as fast as
possible, blah, blah.

00:48:56.070 --> 00:48:57.780
But sometimes it's
tricky to know, yeah,

00:48:57.780 --> 00:48:58.960
exactly what's happening.

00:48:58.960 --> 00:49:03.210
Unless you're a gecko
expert, it's very hard

00:49:03.210 --> 00:49:08.450
to know where exactly
I'm spending my time

00:49:08.450 --> 00:49:11.210
and how I should be laying
out the page differently.

00:49:11.210 --> 00:49:13.350
So there's a few
people at Mozilla

00:49:13.350 --> 00:49:16.880
who know rendering
really, really well.

00:49:16.880 --> 00:49:19.260
And they can just look
at the display lists

00:49:19.260 --> 00:49:22.260
and just say, oh,
yeah, clearly, using

00:49:22.260 --> 00:49:24.300
this element looks
a bit strange to me,

00:49:24.300 --> 00:49:26.410
and a list of 1,000 elements.

00:49:26.410 --> 00:49:28.970
And I'd really like
just more tooling

00:49:28.970 --> 00:49:37.004
to surface these faux pas
to make things easier.

00:49:37.004 --> 00:49:38.420
PAUL LEWIS: When
I look at this, I

00:49:38.420 --> 00:49:41.420
think things like
Polymer web components

00:49:41.420 --> 00:49:45.470
hopefully helps there where
accepted good ways to do

00:49:45.470 --> 00:49:49.200
things can start to be
shared with other people.

00:49:49.200 --> 00:49:52.290
So if somebody makes a
phenomenal infinite scrolling

00:49:52.290 --> 00:49:55.105
list, that that could be shared,
that that can be built upon,

00:49:55.105 --> 00:49:57.560
and that that includes,
baked into it,

00:49:57.560 --> 00:49:59.380
the fast path, the
idea of how you

00:49:59.380 --> 00:50:01.300
should do these
kinds of things so

00:50:01.300 --> 00:50:03.609
that if you want to do your
own thing, you still can,

00:50:03.609 --> 00:50:05.150
because that fast
path-- and maybe we

00:50:05.150 --> 00:50:06.650
need to build down
a bit, like we're

00:50:06.650 --> 00:50:08.990
saying with these extra hooks,
to do those really well.

00:50:08.990 --> 00:50:10.480
But you've got it in
both directions now.

00:50:10.480 --> 00:50:13.070
You've got a kind of example
that you can take and hopefully

00:50:13.070 --> 00:50:13.760
configure.

00:50:13.760 --> 00:50:15.640
And you've got also
the underlying ways

00:50:15.640 --> 00:50:17.490
of re-doing that thing
yourself rather than

00:50:17.490 --> 00:50:19.157
kind of hoping that
you can recreate it.

00:50:19.157 --> 00:50:20.323
I think that's what we need.

00:50:20.323 --> 00:50:21.920
And hopefully, that
fast-tracks a lot

00:50:21.920 --> 00:50:24.460
of people who are-- they're
like, I need to make a web app.

00:50:24.460 --> 00:50:27.480
It's gotta have these features.

00:50:27.480 --> 00:50:28.980
Why don't I just
use that thing that

00:50:28.980 --> 00:50:30.470
is already shipped and good?

00:50:30.470 --> 00:50:30.840
WILSON PAGE: Yeah.

00:50:30.840 --> 00:50:32.423
That's the most
exciting thing for me,

00:50:32.423 --> 00:50:34.830
that we can actually start
sharing these pieces.

00:50:34.830 --> 00:50:37.970
And someone who doesn't know
that much about performance

00:50:37.970 --> 00:50:39.920
and all the things
you need to know

00:50:39.920 --> 00:50:43.760
to get a well-performing app can
just take a piece off the shelf

00:50:43.760 --> 00:50:45.650
and just use it, and
then suddenly they've

00:50:45.650 --> 00:50:48.190
got something that's
performing as well as native.

00:50:48.190 --> 00:50:51.052
And that's something the
web's never had before.

00:50:51.052 --> 00:50:53.385
Yeah, you could maybe if you
were using the same library

00:50:53.385 --> 00:50:54.690
as someone else, you
might be able to use

00:50:54.690 --> 00:50:55.984
a component that they built.

00:50:55.984 --> 00:50:58.150
But the fact that we have
it built into the platform

00:50:58.150 --> 00:50:59.275
now is super exciting.

00:50:59.275 --> 00:51:01.650
And I think for
us in Firefox OS,

00:51:01.650 --> 00:51:04.680
we're really going to see--
we're banking on web components

00:51:04.680 --> 00:51:06.609
to really accelerate
the number of apps that

00:51:06.609 --> 00:51:08.150
are going to land
in the marketplace.

00:51:08.150 --> 00:51:10.710
If we can just give
developers a package

00:51:10.710 --> 00:51:14.550
and just say, look, here you go,
you can build an app in a day.

00:51:14.550 --> 00:51:15.420
To get that.

00:51:15.420 --> 00:51:17.860
And that's something that
I think we're going really,

00:51:17.860 --> 00:51:18.930
really start.

00:51:18.930 --> 00:51:21.720
MIKE SHAVER: You
raised the issue, too,

00:51:21.720 --> 00:51:24.937
of not needing to have
a lot of expertise

00:51:24.937 --> 00:51:26.770
in order to make a
high-performance web app.

00:51:26.770 --> 00:51:27.854
But I think you're on iOS.

00:51:27.854 --> 00:51:30.519
You need to work relatively hard
to make something that's janky.

00:51:30.519 --> 00:51:31.940
So it feels like
we're really kind

00:51:31.940 --> 00:51:33.820
of at the wrong
ends of that there.

00:51:33.820 --> 00:51:36.577
We're at the end of our
time as well, unfortunately.

00:51:36.577 --> 00:51:38.660
So I do want to thank the
panel and everybody that

00:51:38.660 --> 00:51:39.290
contributed to this.

00:51:39.290 --> 00:51:40.800
I think layout
performance is an area

00:51:40.800 --> 00:51:42.750
we need to see a lot of
attention to in the future

00:51:42.750 --> 00:51:44.791
if we're going to take
web apps to the next area.

00:51:44.791 --> 00:51:46.690
So thanks all a lot
for your participation.

00:51:46.690 --> 00:51:49.740
[APPLAUSE]

