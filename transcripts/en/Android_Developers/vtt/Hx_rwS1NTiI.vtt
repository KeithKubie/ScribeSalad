WEBVTT
Kind: captions
Language: en

00:00:06.874 --> 00:00:08.347
[APPLAUSE]

00:00:13.270 --> 00:00:15.170
JAMAL EASON: So, good morning.

00:00:15.170 --> 00:00:18.130
Welcome to our session on what's
new in Android development

00:00:18.130 --> 00:00:19.210
tools.

00:00:19.210 --> 00:00:20.290
My name is Jamal Eason.

00:00:20.290 --> 00:00:21.825
I'm here with Xav and Tor.

00:00:21.825 --> 00:00:23.200
And today we're
going to give you

00:00:23.200 --> 00:00:26.470
an insider's tour of all the
new and upcoming features

00:00:26.470 --> 00:00:28.990
for Android development.

00:00:28.990 --> 00:00:32.200
As you know, Android
Studio is the official IDE

00:00:32.200 --> 00:00:35.627
for developing apps for
Android, provided by Google.

00:00:35.627 --> 00:00:37.210
We work hand-in-hand
with the platform

00:00:37.210 --> 00:00:40.180
to ensure that all the latest
APIs and features are tightly

00:00:40.180 --> 00:00:43.450
integrated inside
of Android Studio.

00:00:43.450 --> 00:00:44.940
It's our team's
mission to ensure

00:00:44.940 --> 00:00:47.440
that we provide the latest and
greatest tools to help you be

00:00:47.440 --> 00:00:50.560
efficient and Thank developers.

00:00:50.560 --> 00:00:52.690
I must say, I thank
you for your feedback

00:00:52.690 --> 00:00:54.880
so far in making
Android Studio great.

00:00:57.460 --> 00:00:58.960
So before we jump
into new features,

00:00:58.960 --> 00:01:01.335
I just want to spend a few
moments talking about features

00:01:01.335 --> 00:01:03.940
that we launched since we
last spoke with you last year,

00:01:03.940 --> 00:01:05.550
in case you missed them.

00:01:05.550 --> 00:01:09.490
So last year at IO, we gave
you a preview of Android Studio

00:01:09.490 --> 00:01:13.090
2.2, which included things
like a new layout editor,

00:01:13.090 --> 00:01:15.580
the Espresso Test Recorder,
and CMake support,

00:01:15.580 --> 00:01:18.646
which is great for C++ projects.

00:01:18.646 --> 00:01:20.020
And, around
November, we give you

00:01:20.020 --> 00:01:23.470
a preview of Android Studio
2.3, which included things

00:01:23.470 --> 00:01:26.100
like an update to Instant
Run, the Lint Baseline

00:01:26.100 --> 00:01:28.180
support, and the
ConstraintLayout

00:01:28.180 --> 00:01:30.400
reaching stable status,
which is tightly

00:01:30.400 --> 00:01:33.580
correlated with
the layout editor.

00:01:33.580 --> 00:01:35.600
And just this past
March, we actually

00:01:35.600 --> 00:01:40.330
released a few releases
of Android Studio 2.4.

00:01:40.330 --> 00:01:42.370
But, as you know
from yesterday, we're

00:01:42.370 --> 00:01:44.650
not going to be releasing
Android Studio 2.4.

00:01:44.650 --> 00:01:50.496
Instead, we're releasing
Android Studio 3.0.

00:01:50.496 --> 00:01:51.912
[APPLAUSE]

00:01:55.690 --> 00:01:58.030
So we made the shift
for two reasons--

00:01:58.030 --> 00:02:00.210
number one, as we were
developing features,

00:02:00.210 --> 00:02:03.120
we realized all the work
going inside this release

00:02:03.120 --> 00:02:06.450
didn't seem sort of indicative
of one incremental change.

00:02:06.450 --> 00:02:09.090
Number two, we made the
tough and rare decision

00:02:09.090 --> 00:02:11.547
to make a breaking,
Gradle API change.

00:02:11.547 --> 00:02:12.630
And we'll talk about that.

00:02:12.630 --> 00:02:14.490
But that change allows
us to scale and have

00:02:14.490 --> 00:02:17.559
faster Gradle build speeds.

00:02:17.559 --> 00:02:19.350
So we have features
across the entire range

00:02:19.350 --> 00:02:21.630
of feature sets for
your app development--

00:02:21.630 --> 00:02:25.990
from building, testing, and
optimizing your application.

00:02:25.990 --> 00:02:27.450
So let's dive in.

00:02:27.450 --> 00:02:28.950
Instead of me
talking about it, I'm

00:02:28.950 --> 00:02:30.699
actually going to
invite Tor up to give us

00:02:30.699 --> 00:02:33.877
a demo of all the cool features
inside of Android Studio 3.0.

00:02:33.877 --> 00:02:35.460
And, after that,
I'll have Xav come up

00:02:35.460 --> 00:02:36.870
and talk about the build system.

00:02:36.870 --> 00:02:38.110
So with that--

00:02:38.110 --> 00:02:40.874
Tor-- let's get started.

00:02:40.874 --> 00:02:41.790
TOR NORBYE: All right.

00:02:41.790 --> 00:02:43.839
So this is Android Studio 3.0.

00:02:43.839 --> 00:02:45.755
It's based on the latest
version of IntelliJ--

00:02:45.755 --> 00:02:47.020
the latest stable version--

00:02:47.020 --> 00:02:48.510
2017.1.

00:02:48.510 --> 00:02:50.894
So we picked up tons
of great features

00:02:50.894 --> 00:02:52.560
that I'm not going
to have time to show.

00:02:52.560 --> 00:02:53.550
I'll just highlight a couple.

00:02:53.550 --> 00:02:55.466
There's parameter hints--
which you see here--

00:02:55.466 --> 00:02:58.710
where we show the parameter
name at the call site.

00:02:58.710 --> 00:03:00.890
And there's emojis in comments.

00:03:00.890 --> 00:03:02.670
You know, so
sometimes, when you're

00:03:02.670 --> 00:03:04.470
commenting on some
slow code, you really

00:03:04.470 --> 00:03:07.140
want to use a snail emoticon.

00:03:07.140 --> 00:03:08.040
All right.

00:03:08.040 --> 00:03:11.580
Anyway, the big news for us is
that we are supporting Kotlin,

00:03:11.580 --> 00:03:13.040
so--

00:03:13.040 --> 00:03:13.848
in the new-- yeah--

00:03:13.848 --> 00:03:16.840
[APPLAUSE]

00:03:16.840 --> 00:03:19.180
So in the new project wizard,
there's a checkbox now.

00:03:19.180 --> 00:03:21.820
You can enable Kotlin
right from the get-go.

00:03:21.820 --> 00:03:24.369
Or, in an existing
project, you can start

00:03:24.369 --> 00:03:25.660
creating Kotlin files directly.

00:03:25.660 --> 00:03:27.993
And the IDE will walk you
through upgrading your project

00:03:27.993 --> 00:03:30.640
dependencies.

00:03:30.640 --> 00:03:33.460
Or you can just take
an existing class

00:03:33.460 --> 00:03:34.910
and run it through a converter.

00:03:34.910 --> 00:03:37.030
So the way you do that
is you go to code,

00:03:37.030 --> 00:03:38.830
convert Java file
to Kotlin file.

00:03:38.830 --> 00:03:40.390
It runs it through
this converter.

00:03:40.390 --> 00:03:42.730
And, sometimes, it does a
fantastic job-- like here,

00:03:42.730 --> 00:03:45.280
it's realized, I want
string interpolation.

00:03:45.280 --> 00:03:48.340
And it's used de-structuring
declarations here.

00:03:48.340 --> 00:03:51.850
But, you know, you can see
also sometimes gets warnings.

00:03:51.850 --> 00:03:53.020
It's not always perfect.

00:03:53.020 --> 00:03:55.010
I want to lower
expectations a little bit.

00:03:55.010 --> 00:03:58.849
Here's another example-- here
we have a data class in Java.

00:03:58.849 --> 00:04:01.390
There's a one-line version of
this you could write in Kotlin.

00:04:01.390 --> 00:04:03.130
But if you run it
through the converter,

00:04:03.130 --> 00:04:06.850
you end up with code that
is completely accurate

00:04:06.850 --> 00:04:07.990
but not the most optimal.

00:04:07.990 --> 00:04:10.187
So this does the same
as before in Kotlin.

00:04:10.187 --> 00:04:11.770
So it's really a
great starting point.

00:04:11.770 --> 00:04:15.040
And then, typically, you
massage it a bit more.

00:04:15.040 --> 00:04:20.149
So here's a Kotlin file showing
several language features.

00:04:20.149 --> 00:04:23.544
You have the
four-loop with ranges.

00:04:23.544 --> 00:04:25.210
You have a let
statement, with a lambda,

00:04:25.210 --> 00:04:26.462
and you have a when statement.

00:04:26.462 --> 00:04:28.420
We don't have time to
cover the language today.

00:04:28.420 --> 00:04:30.340
There's going to talks
about that tomorrow

00:04:30.340 --> 00:04:31.507
that you don't want to miss.

00:04:31.507 --> 00:04:32.881
But when you're
starting out, you

00:04:32.881 --> 00:04:35.204
might have some concerns
about performance here.

00:04:35.204 --> 00:04:37.120
You know, like, is this
going to be expensive?

00:04:37.120 --> 00:04:38.370
What about this let statement?

00:04:38.370 --> 00:04:40.630
Is this making a new
inner class in an object?

00:04:40.630 --> 00:04:43.090
There's a really
great way to find out.

00:04:43.090 --> 00:04:47.170
So you can invoke the
show byte code window.

00:04:47.170 --> 00:04:50.800
This is going to show the byte
code for the current statement.

00:04:50.800 --> 00:04:52.580
If you read byte
code, that's great.

00:04:52.580 --> 00:04:55.210
But if you don't, there's this
really great decompile button

00:04:55.210 --> 00:04:57.340
in the top right window here.

00:04:57.340 --> 00:05:00.380
When I click on this, I get
the equivalent Java code.

00:05:00.380 --> 00:05:02.440
So now I can look
at this and go, OK,

00:05:02.440 --> 00:05:04.690
that range loop turns
into a really pure y

00:05:04.690 --> 00:05:05.920
loop with an index check.

00:05:05.920 --> 00:05:10.210
And, similarly, the let
statement is just an if check.

00:05:10.210 --> 00:05:12.207
So don't prematurely
optimize in your head

00:05:12.207 --> 00:05:14.290
based on what you are
afraid Kotlin's going to do.

00:05:14.290 --> 00:05:16.810
Write, you know, the most
beautiful Kotlin code you can.

00:05:16.810 --> 00:05:19.897
And when you're in doubt, you
can check what it's doing.

00:05:19.897 --> 00:05:21.730
The last thing I'm going
to say about Kotlin

00:05:21.730 --> 00:05:26.920
is that all the Android
link checks that ran on Java

00:05:26.920 --> 00:05:28.780
files-- there's
about 80 of those.

00:05:28.780 --> 00:05:30.430
They're all running
on Kotlin as well.

00:05:30.430 --> 00:05:31.390
There's no gap.

00:05:31.390 --> 00:05:32.855
It's the same code base now.

00:05:32.855 --> 00:05:34.310
[APPLAUSE]

00:05:36.991 --> 00:05:37.490
All right.

00:05:37.490 --> 00:05:41.090
Let's talk about
the Layout Editor.

00:05:41.090 --> 00:05:44.150
So we launched the new Layout
Editor last year at IO.

00:05:44.150 --> 00:05:46.485
And we've continued
working on it, obviously.

00:05:46.485 --> 00:05:48.860
So one of the things we have
in the new version is better

00:05:48.860 --> 00:05:51.224
handling of errors--
as you can see here--

00:05:51.224 --> 00:05:52.140
and constraint layout.

00:05:52.140 --> 00:05:53.730
We've enhanced that a lot.

00:05:53.730 --> 00:05:56.570
So, first of all, we
recently added chains.

00:05:56.570 --> 00:05:59.150
So a chain is a
way to distribute

00:05:59.150 --> 00:06:00.766
widgets along an axis.

00:06:00.766 --> 00:06:02.390
So you can select
these three widgets--

00:06:02.390 --> 00:06:05.044
say that I want to create, for
example, a horizontal chain.

00:06:05.044 --> 00:06:06.710
I don't know if you
can see, but there's

00:06:06.710 --> 00:06:09.860
kind of a beautiful
chain graphic here.

00:06:09.860 --> 00:06:12.790
And I can align
this horizontally.

00:06:12.790 --> 00:06:14.660
And now there's this
chain cycle button.

00:06:14.660 --> 00:06:16.820
So I can basically
click on this to explore

00:06:16.820 --> 00:06:18.810
how the chains are behaving.

00:06:18.810 --> 00:06:21.110
Another feature
we're about to launch

00:06:21.110 --> 00:06:23.810
is Constraint Layout 1.1.

00:06:23.810 --> 00:06:26.420
And in 1.1 we have barriers.

00:06:26.420 --> 00:06:28.760
And the easiest way to explain
this is just to show it,

00:06:28.760 --> 00:06:29.787
I think.

00:06:29.787 --> 00:06:31.370
And so, if I were
to move this widget,

00:06:31.370 --> 00:06:33.860
you can see that this
line next to it--

00:06:33.860 --> 00:06:37.190
basically, we make sure that
we don't ever overlap with it.

00:06:37.190 --> 00:06:39.050
So this is a pretty
good way to make

00:06:39.050 --> 00:06:41.155
layouts that respond correctly.

00:06:41.155 --> 00:06:42.530
And that's actually
all I'm going

00:06:42.530 --> 00:06:44.488
to say about constraint
layout, because there's

00:06:44.488 --> 00:06:46.510
a whole talk about it
in a couple of hours

00:06:46.510 --> 00:06:48.560
that you don't want to miss.

00:06:48.560 --> 00:06:50.750
Another feature we've
added in the Layout Editor

00:06:50.750 --> 00:06:53.480
is support for sample data.

00:06:53.480 --> 00:06:56.660
So in your apps you might
have for your recycle view.

00:06:56.660 --> 00:06:57.890
It's pretty common.

00:06:57.890 --> 00:07:00.320
And it looks nothing like the
Layout Editor when you run,

00:07:00.320 --> 00:07:04.100
because you're putting data
into it-- images and, of course,

00:07:04.100 --> 00:07:06.074
application-specific data.

00:07:06.074 --> 00:07:07.490
So a couple of
years ago, we added

00:07:07.490 --> 00:07:09.632
some support to deal with
this with design time

00:07:09.632 --> 00:07:11.340
attributes-- the tools
attributes, right?

00:07:11.340 --> 00:07:13.172
So you could put some
string in and you

00:07:13.172 --> 00:07:15.380
can start approximating what
your app is going to do.

00:07:15.380 --> 00:07:18.030
But that's terrible
in a list view.

00:07:18.030 --> 00:07:20.210
So we've continued
enhancing this.

00:07:20.210 --> 00:07:25.330
So now we have this new
sample resource type.

00:07:25.330 --> 00:07:29.120
So, for example, I can pull
in some lorem ipsum text.

00:07:29.120 --> 00:07:32.050
Or I can pull in, let's
say, date of the week.

00:07:35.572 --> 00:07:37.530
But the real power of
this is when you actually

00:07:37.530 --> 00:07:38.980
define your own data.

00:07:38.980 --> 00:07:42.600
So here is this new
JSON file that I've

00:07:42.600 --> 00:07:43.830
created in my project.

00:07:43.830 --> 00:07:45.346
This is for a fitness app.

00:07:45.346 --> 00:07:47.220
So there's various
activities that, you know,

00:07:47.220 --> 00:07:50.140
this app is modeling--
biking, walking, and so forth.

00:07:50.140 --> 00:07:52.490
And there's some other data
associated, like distances.

00:07:52.490 --> 00:07:54.340
And we even have some icons.

00:07:54.340 --> 00:07:57.570
What I can do now is
go into my item layout

00:07:57.570 --> 00:08:00.690
that I'm using in the list and I
can start binding these things.

00:08:00.690 --> 00:08:03.229
So code completion works
here for the app sample tag.

00:08:03.229 --> 00:08:05.520
It's picking out all the
attributes from the JSON file.

00:08:05.520 --> 00:08:09.030
And I can, for example, hook
up the icon property to this.

00:08:09.030 --> 00:08:10.620
I can hook up the
description property

00:08:10.620 --> 00:08:12.000
to this next text view.

00:08:12.000 --> 00:08:13.810
And so, when I
come back to this,

00:08:13.810 --> 00:08:15.360
you can see I get
a layout that looks

00:08:15.360 --> 00:08:17.250
much more like the real app.

00:08:17.250 --> 00:08:18.735
[APPLAUSE]

00:08:21.705 --> 00:08:22.561
All right.

00:08:22.561 --> 00:08:24.560
The last Layout Editor
feature I'm going to show

00:08:24.560 --> 00:08:30.170
is support for O
downloadable fonts.

00:08:30.170 --> 00:08:32.905
So in O, you can declare
downloadable fonts.

00:08:32.905 --> 00:08:34.030
There's lots of advantages.

00:08:34.030 --> 00:08:36.620
And there's a talk about
that, as well, of course.

00:08:36.620 --> 00:08:39.710
But the way this works is
that I select a text view

00:08:39.710 --> 00:08:42.880
and in the Layout Editor,
in the font family chooser,

00:08:42.880 --> 00:08:45.080
there is a more fonts
item on the bottom.

00:08:45.080 --> 00:08:48.860
When I invoke that, I can browse
the available online fonts

00:08:48.860 --> 00:08:50.180
or search.

00:08:50.180 --> 00:08:51.710
I can pick my favorite--

00:08:51.710 --> 00:08:53.830
Fingerpaint.

00:08:53.830 --> 00:08:58.250
And you can see, I now get this
new font resource in my project

00:08:58.250 --> 00:09:03.110
and it actually works
the way you'd expect.

00:09:03.110 --> 00:09:03.610
All right.

00:09:03.610 --> 00:09:07.580
Another O feature we've added
is support for adaptive icons.

00:09:07.580 --> 00:09:12.710
So in the image asset wizard,
we now help you create these.

00:09:12.710 --> 00:09:15.350
So we help you with
the foreground layer.

00:09:15.350 --> 00:09:19.330
You can modify the
background layer.

00:09:19.330 --> 00:09:21.260
I don't know if you can
tell from the screen,

00:09:21.260 --> 00:09:24.464
but there's also options to show
safe zones, grid, and so forth.

00:09:24.464 --> 00:09:26.630
So this, hopefully, helps
you put all the right bits

00:09:26.630 --> 00:09:29.600
in the right places.

00:09:29.600 --> 00:09:31.400
Another small feature
that's easy to miss

00:09:31.400 --> 00:09:32.733
is the bottom right corner here.

00:09:32.733 --> 00:09:36.020
There's a device
explorer now, finally.

00:09:36.020 --> 00:09:38.030
So here you can go in
and actually explore

00:09:38.030 --> 00:09:39.710
files in your file system.

00:09:39.710 --> 00:09:42.165
You know, you can click on
files to see them locally.

00:09:42.165 --> 00:09:44.540
And you can right-click on
folders to upload and download

00:09:44.540 --> 00:09:46.932
files and that kind of thing.

00:09:46.932 --> 00:09:48.140
All right, let's talk about--

00:09:48.140 --> 00:09:48.623
[APPLAUSE]

00:09:48.623 --> 00:09:49.123
Thank you.

00:09:52.010 --> 00:09:54.095
Let's talk about Instant Apps.

00:09:54.095 --> 00:09:55.970
So we have a lot of
support for Instant Apps.

00:09:55.970 --> 00:09:57.200
We have a bunch
of new lint rules.

00:09:57.200 --> 00:09:59.241
We have support in the
Gradle build system, which

00:09:59.241 --> 00:10:00.590
I think Xav will talk about.

00:10:00.590 --> 00:10:04.130
We have new wizards for
creating feature modules.

00:10:04.130 --> 00:10:06.620
But the hardest part of
creating a Instant App

00:10:06.620 --> 00:10:09.310
is probably going to be to
break up your monolithic app.

00:10:09.310 --> 00:10:11.270
So we're working on
some refactoring tools

00:10:11.270 --> 00:10:12.412
to help with that.

00:10:12.412 --> 00:10:14.370
So I'm going to take this
simple example first.

00:10:14.370 --> 00:10:16.571
So here I have a class.

00:10:16.571 --> 00:10:17.570
I'm going to extract it.

00:10:17.570 --> 00:10:20.330
So I invoke the
modularize for factoring.

00:10:20.330 --> 00:10:23.660
And you can see that it offers
to pull four classes out

00:10:23.660 --> 00:10:25.120
into this new module.

00:10:25.120 --> 00:10:27.620
And that's because this class
depends on three other classes

00:10:27.620 --> 00:10:28.730
recursively.

00:10:28.730 --> 00:10:30.110
And it'll also
pull along with it

00:10:30.110 --> 00:10:32.349
resources and manifest entries.

00:10:32.349 --> 00:10:34.640
This is the ideal case that
I bet you will not actually

00:10:34.640 --> 00:10:36.530
encounter with your own app.

00:10:36.530 --> 00:10:38.390
Here's a more realistic example.

00:10:38.390 --> 00:10:42.800
So I'm going to try to pull this
activity into its own module.

00:10:42.800 --> 00:10:44.990
And here you can see
it's pulling a lot.

00:10:44.990 --> 00:10:48.290
And we have some spaghetti
because my class depends

00:10:48.290 --> 00:10:50.420
on this class which
then, you know,

00:10:50.420 --> 00:10:52.370
utils class, which
is then pointing it

00:10:52.370 --> 00:10:53.270
to some other stuff.

00:10:53.270 --> 00:10:54.290
This is real spaghetti.

00:10:54.290 --> 00:10:56.840
And so what you have to do
now is start deciding where

00:10:56.840 --> 00:10:58.860
to cut the spaghetti, right?

00:10:58.860 --> 00:11:00.010
And so you invoke this.

00:11:00.010 --> 00:11:01.010
It creates the new code.

00:11:01.010 --> 00:11:02.635
And then you would
have to actually fix

00:11:02.635 --> 00:11:03.740
the code afterwards.

00:11:03.740 --> 00:11:05.930
So we have an initial
version of this in Canary 1,

00:11:05.930 --> 00:11:10.140
but this is a feature we're
very much still working on.

00:11:10.140 --> 00:11:15.330
We've also improve
the APK analyzer.

00:11:15.330 --> 00:11:22.550
So what I can do here is load in
a APK that is a release binary.

00:11:22.550 --> 00:11:23.050
Right.

00:11:23.050 --> 00:11:25.200
So last year we launched this
and we had a lot of support

00:11:25.200 --> 00:11:25.890
for resources.

00:11:25.890 --> 00:11:29.310
This year we've added a bunch
of support for code and DEX.

00:11:29.310 --> 00:11:34.770
So first of all I can drill
into the DEX system here.

00:11:34.770 --> 00:11:38.610
Let's see-- so I can
right click on a class.

00:11:38.610 --> 00:11:41.830
And we disassembled
the byte code for you.

00:11:41.830 --> 00:11:45.000
You can also notice that the
package name here is a.a.a.

00:11:45.000 --> 00:11:47.190
And I promise we didn't
write the code that way.

00:11:47.190 --> 00:11:49.950
That's because this is
a ProGuarded APK, right?

00:11:49.950 --> 00:11:52.440
So ProGuard has gone and
shrunk all the symbols

00:11:52.440 --> 00:11:53.700
down to something very short.

00:11:53.700 --> 00:11:56.199
But now we have this button for
loading the ProGuard mapping

00:11:56.199 --> 00:11:57.030
file.

00:11:57.030 --> 00:11:58.130
So when I do that--

00:11:58.130 --> 00:11:59.880
I've got to find my
ProGuard mapping file.

00:12:02.610 --> 00:12:05.436
When I do that, you can see that
we now show the original symbol

00:12:05.436 --> 00:12:07.560
names instead, as you're
drilling around in the Dex

00:12:07.560 --> 00:12:08.927
file, which is pretty handy.

00:12:08.927 --> 00:12:10.875
[APPLAUSE]

00:12:13.584 --> 00:12:15.000
There are some
more features here.

00:12:15.000 --> 00:12:16.500
I can right click
and, for example,

00:12:16.500 --> 00:12:19.260
generate a keep rule, which
is handy when I'm comparing

00:12:19.260 --> 00:12:20.769
debug and release binaries.

00:12:20.769 --> 00:12:23.310
By the way, we have this compare
button up here on the right.

00:12:23.310 --> 00:12:25.268
And I notice that, hey,
I need to actually keep

00:12:25.268 --> 00:12:26.550
this class for the release.

00:12:26.550 --> 00:12:28.410
Or, conversely, I
might be surprised

00:12:28.410 --> 00:12:30.305
that this class is in
the release binary.

00:12:30.305 --> 00:12:31.680
And so I can
right-click and say,

00:12:31.680 --> 00:12:34.260
show me the usages in
the ProGuarded code

00:12:34.260 --> 00:12:38.400
to help me identify what
it is I need to get rid of.

00:12:38.400 --> 00:12:41.430
We have another feature for
APKs and that is APK debugging.

00:12:41.430 --> 00:12:43.980
So the way this works is that
either from the welcome screen

00:12:43.980 --> 00:12:49.530
or from the File menu here,
you can point to a random APK--

00:12:49.530 --> 00:12:52.452
let's see-- I don't
know why it's not

00:12:52.452 --> 00:12:53.410
showing my home folder.

00:12:58.000 --> 00:13:01.720
I think I'm having
network issues.

00:13:01.720 --> 00:13:02.981
Well, this is very sad.

00:13:02.981 --> 00:13:03.480
All right.

00:13:03.480 --> 00:13:04.896
I'm just going to
talk through it.

00:13:04.896 --> 00:13:06.690
So, basically, if you're
not using Studio--

00:13:06.690 --> 00:13:09.360
if you're a game
developer-- we give you

00:13:09.360 --> 00:13:12.660
a way to just point to an APK
and we make a shell project

00:13:12.660 --> 00:13:14.490
for you based on the
APK analyzer, where

00:13:14.490 --> 00:13:17.490
we show you the sources
inside APK on the left.

00:13:17.490 --> 00:13:18.930
And then we let
you map sources--

00:13:18.930 --> 00:13:21.750
the Java source code as well
as the shared libraries.

00:13:21.750 --> 00:13:25.560
We let you drop in a SO
with debuggable symbols

00:13:25.560 --> 00:13:27.660
to stand in place for
the optimized one.

00:13:27.660 --> 00:13:31.050
So I'm really sad
that didn't work.

00:13:31.050 --> 00:13:31.950
All right.

00:13:31.950 --> 00:13:34.599
Next, I should talk
about the profiler.

00:13:34.599 --> 00:13:36.390
This is a really, really
big feature for us

00:13:36.390 --> 00:13:38.680
with lots of people
working on it.

00:13:38.680 --> 00:13:40.770
And here's how it works.

00:13:40.770 --> 00:13:42.450
So I've already
started running my app.

00:13:42.450 --> 00:13:43.714
It's an image app.

00:13:43.714 --> 00:13:45.630
In fact, you probably
saw this in the keynote.

00:13:45.630 --> 00:13:46.470
I started running it.

00:13:46.470 --> 00:13:47.845
And so the way
the profiler works

00:13:47.845 --> 00:13:50.850
is I can now open
up the profiler tab

00:13:50.850 --> 00:13:53.075
and it will attach
to the process--

00:13:57.122 --> 00:13:58.455
all right, no connected devices.

00:14:02.127 --> 00:14:03.210
I'm going to run it again.

00:14:10.250 --> 00:14:11.360
It's very unhappy.

00:14:11.360 --> 00:14:13.485
I'm going to just kill the
emulator and start over.

00:14:23.212 --> 00:14:25.087
This is really exciting
television, isn't it?

00:14:29.860 --> 00:14:31.650
All right.

00:14:31.650 --> 00:14:35.610
We should work on making that
system image boot faster.

00:14:35.610 --> 00:14:37.020
[APPLAUSE]

00:14:41.151 --> 00:14:41.650
All right.

00:14:41.650 --> 00:14:43.090
So here we have it.

00:14:43.090 --> 00:14:44.910
And no connected devices--

00:14:44.910 --> 00:14:45.410
wow.

00:14:48.580 --> 00:14:51.304
You know what, I say we--

00:14:51.304 --> 00:14:51.970
oh, there we go.

00:14:51.970 --> 00:14:52.470
Here we go.

00:14:52.470 --> 00:14:53.695
Whew.

00:14:53.695 --> 00:14:55.595
[APPLAUSE]

00:14:57.980 --> 00:14:58.690
All right.

00:14:58.690 --> 00:14:59.190
OK.

00:14:59.190 --> 00:15:01.850
So the way this works is that
it's attached to this process.

00:15:01.850 --> 00:15:04.730
And it's showing me what's
happening with the CPU, memory,

00:15:04.730 --> 00:15:05.970
and network.

00:15:05.970 --> 00:15:09.260
And so let's go and make some
stuff happen in the app, right?

00:15:09.260 --> 00:15:11.870
So I'll click on an image.

00:15:11.870 --> 00:15:17.700
And-- wow-- network
is very unhappy.

00:15:17.700 --> 00:15:19.400
OK.

00:15:19.400 --> 00:15:20.480
All right.

00:15:20.480 --> 00:15:21.239
Super slow-- OK.

00:15:21.239 --> 00:15:23.780
Anyway, it works, because if we
look in the background here--

00:15:23.780 --> 00:15:26.113
and I accidentally clicked
on the memory profiler-- here

00:15:26.113 --> 00:15:28.290
we have the CPU,
memory, and network.

00:15:28.290 --> 00:15:30.440
You see these little
purple dots up here?

00:15:30.440 --> 00:15:31.700
Those are my touch events.

00:15:31.700 --> 00:15:34.100
You can also see the
activities happening.

00:15:34.100 --> 00:15:36.230
Activity-- things like
stopped and destroyed.

00:15:36.230 --> 00:15:37.240
It's very small.

00:15:37.240 --> 00:15:39.930
But it's basically listing
activity names up here.

00:15:39.930 --> 00:15:41.340
So let's start with the network.

00:15:41.340 --> 00:15:43.522
This is a timeline
I can scroll in.

00:15:43.522 --> 00:15:45.480
So I'm going to click
down in the network area.

00:15:45.480 --> 00:15:48.170
And here I can see the network
traffic and radio traffic that

00:15:48.170 --> 00:15:49.700
happened in this time interval.

00:15:49.700 --> 00:15:52.222
I can zoom in on
something like this

00:15:52.222 --> 00:15:53.680
and it'll show me
the network calls

00:15:53.680 --> 00:15:55.280
that happened during that time.

00:15:55.280 --> 00:15:57.620
And I can click on a
particular network request

00:15:57.620 --> 00:15:59.870
and sort of see it
and the call stack.

00:15:59.870 --> 00:16:02.990
And the way this works is
that we instrument your app at

00:16:02.990 --> 00:16:04.130
build time.

00:16:04.130 --> 00:16:05.790
And so you have
to opt into this.

00:16:05.790 --> 00:16:09.080
So you go to your run config and
there is a profiling tab where

00:16:09.080 --> 00:16:11.280
you enable advance profiling.

00:16:11.280 --> 00:16:14.570
So, basically, we look
for uses of usages

00:16:14.570 --> 00:16:16.700
of HTTP url connection.

00:16:16.700 --> 00:16:18.410
And so if your
app is using that,

00:16:18.410 --> 00:16:20.960
or anything based
on it-- like Volley.

00:16:20.960 --> 00:16:25.262
And we also support OK HTTP
now, as of 3.0 Canary 1.

00:16:25.262 --> 00:16:27.106
[APPLAUSE]

00:16:29.880 --> 00:16:34.090
We've also added
support in Android 0

00:16:34.090 --> 00:16:36.496
for basically doing this
instrumentation on the fly.

00:16:36.496 --> 00:16:39.120
So you don't need to do any kind
of build time instrumentation.

00:16:39.120 --> 00:16:41.460
So that'll be enabled
in an upcoming build

00:16:41.460 --> 00:16:43.150
of Android Studio.

00:16:43.150 --> 00:16:43.650
All right.

00:16:43.650 --> 00:16:44.941
So that's the network profiler.

00:16:44.941 --> 00:16:46.841
Let's look at the CPU profiler.

00:16:46.841 --> 00:16:47.340
All right.

00:16:47.340 --> 00:16:49.440
So I'm going to,
again, click in here.

00:16:49.440 --> 00:16:52.690
And here I can see
the thread activity.

00:16:52.690 --> 00:16:55.342
So I'm going to jump
to be live again.

00:16:55.342 --> 00:16:57.300
And then I'm going to do
some stuff in the app.

00:16:57.300 --> 00:16:59.480
So I'll click on this image.

00:16:59.480 --> 00:17:01.410
Actually, I forgot
that what I want to do

00:17:01.410 --> 00:17:03.420
is start collecting samples.

00:17:03.420 --> 00:17:05.670
So I'm clicking on the
recording and now it's

00:17:05.670 --> 00:17:07.770
gathering more
information and then I'll

00:17:07.770 --> 00:17:13.829
do some stuff in
the app like that.

00:17:13.829 --> 00:17:16.750
And now I'll stop recording.

00:17:16.750 --> 00:17:17.250
OK.

00:17:17.250 --> 00:17:19.380
So now the timeline--
it's showing me

00:17:19.380 --> 00:17:22.619
here that during this interval
we have more information.

00:17:22.619 --> 00:17:23.910
And I can stop.

00:17:23.910 --> 00:17:26.480
I can click on a particular
thread I'm interested in.

00:17:26.480 --> 00:17:28.230
So the thread displays
in the middle here.

00:17:28.230 --> 00:17:31.180
And we can see that AsyncTask
3 looks pretty interesting.

00:17:31.180 --> 00:17:32.320
So I'll click on that.

00:17:32.320 --> 00:17:34.610
You can see a flame
chart on the bottom here.

00:17:34.610 --> 00:17:38.100
And this is actually based
on ranges that I select.

00:17:38.100 --> 00:17:42.150
So I can narrow my focus on what
I'm particularly interested in.

00:17:42.150 --> 00:17:43.674
And we also have a--

00:17:43.674 --> 00:17:45.090
actually, that was
the call chart.

00:17:45.090 --> 00:17:46.089
This is the flame chart.

00:17:46.089 --> 00:17:49.040
And we also have top-down
and bottom-up displays

00:17:49.040 --> 00:17:49.710
of the frames.

00:17:49.710 --> 00:17:53.550
So here I can sort in descending
order of method calls,

00:17:53.550 --> 00:17:54.610
for example.

00:17:54.610 --> 00:17:56.570
So that's the CPU profiler.

00:17:56.570 --> 00:18:00.017
And last, but not least, we
have the network profiler.

00:18:00.017 --> 00:18:01.350
So, again, I'm going to go live.

00:18:01.350 --> 00:18:03.766
So I just want to reiterate
this point about this timeline

00:18:03.766 --> 00:18:04.867
keeping all data.

00:18:04.867 --> 00:18:06.950
I think, I was told, about
five megabytes per hour

00:18:06.950 --> 00:18:09.810
is what this costs.

00:18:09.810 --> 00:18:11.550
So now I'm going to go live.

00:18:11.550 --> 00:18:13.390
And we're going to
start looking at memory.

00:18:13.390 --> 00:18:16.230
So the first thing I'll do is,
I'm going to go inside the app

00:18:16.230 --> 00:18:21.480
and I'm going to ask it to
clear all of its caches.

00:18:21.480 --> 00:18:23.760
And then I'm going to go
into network profiler.

00:18:23.760 --> 00:18:29.610
And I'm going to click on
the garbage collection.

00:18:29.610 --> 00:18:31.470
So now we have sort
of a good baseline.

00:18:31.470 --> 00:18:32.100
All right.

00:18:32.100 --> 00:18:36.130
So this is showing you the
memory of the app right now.

00:18:36.130 --> 00:18:38.910
And let's start collecting
allocation stack traces.

00:18:38.910 --> 00:18:40.740
This means that any
kind of allocation

00:18:40.740 --> 00:18:42.281
that happens in the
app-- we're going

00:18:42.281 --> 00:18:43.584
to record where it was done.

00:18:43.584 --> 00:18:45.750
And the reason for that
will be obvious in a second.

00:18:45.750 --> 00:18:49.140
And now I'm going to do
some more memory-intensive

00:18:49.140 --> 00:18:50.370
activities in the app.

00:18:50.370 --> 00:18:52.161
You can see, in the
background, the metrics

00:18:52.161 --> 00:18:56.310
are scrolling as it's
realizing the heap is larger.

00:18:56.310 --> 00:18:59.670
And now let's go in and grab a
heap dump with this down arrow

00:18:59.670 --> 00:19:00.712
here.

00:19:00.712 --> 00:19:04.520
So now it's fetching
a heap dump.

00:19:04.520 --> 00:19:06.120
And that should be fast.

00:19:06.120 --> 00:19:06.960
Yeah.

00:19:06.960 --> 00:19:09.390
So here we can see,
basically, a summary

00:19:09.390 --> 00:19:11.910
of the objects in the heap.

00:19:11.910 --> 00:19:14.170
If I click on, for
example, the bitmap class,

00:19:14.170 --> 00:19:15.780
there's 76 bitmaps.

00:19:15.780 --> 00:19:18.000
I can see those objects here.

00:19:18.000 --> 00:19:19.890
I can click on a bitmap class.

00:19:19.890 --> 00:19:21.630
And, just like in
the old heap viewer,

00:19:21.630 --> 00:19:24.120
I can now start chasing
down the references

00:19:24.120 --> 00:19:25.540
if I want to look for a leak.

00:19:25.540 --> 00:19:29.250
But it can also see
which bitmap this is.

00:19:29.250 --> 00:19:33.210
Or, if this was allocated during
my allocation tracking run,

00:19:33.210 --> 00:19:35.160
I can see the
allocation stack trace--

00:19:35.160 --> 00:19:37.260
where this object came from.

00:19:37.260 --> 00:19:39.690
And for other classes--
for example, string--

00:19:39.690 --> 00:19:41.640
yes, we show the actual string.

00:19:41.640 --> 00:19:44.400
So that's the new profiler.

00:19:44.400 --> 00:19:46.509
We hope it makes
your apps better.

00:19:46.509 --> 00:19:47.946
[APPLAUSE]

00:19:52.296 --> 00:19:53.670
And now I'm going
to turn it over

00:19:53.670 --> 00:19:56.045
to Xav, who's going to show
you how we're working to make

00:19:56.045 --> 00:19:57.690
your builds perform faster.

00:19:57.690 --> 00:19:59.870
XAVIER DUCROHET: Thank you, Tor.

00:19:59.870 --> 00:20:01.325
[APPLAUSE]

00:20:03.670 --> 00:20:04.170
All right.

00:20:04.170 --> 00:20:06.930
Let's start with the
new Maven repository--

00:20:06.930 --> 00:20:07.620
finally.

00:20:07.620 --> 00:20:09.420
I know a lot of you
have asked for it.

00:20:09.420 --> 00:20:13.920
So the url is maven.google.com
and starting with Gradle 4.0

00:20:13.920 --> 00:20:16.069
milestone 2 that was
released yesterday,

00:20:16.069 --> 00:20:17.610
you can just use
the Google shortcut.

00:20:17.610 --> 00:20:20.660
So it's much easier and you
don't have to remember the url.

00:20:20.660 --> 00:20:23.880
We are publishing all the super
libraries and the Gradle plugin

00:20:23.880 --> 00:20:26.040
now, exclusively,
through the repository.

00:20:26.040 --> 00:20:29.270
And we've uploaded all the
previous versions of the super

00:20:29.270 --> 00:20:31.050
library-- not of the
Gradle plugin yet--

00:20:31.050 --> 00:20:32.310
that will come soon.

00:20:32.310 --> 00:20:34.290
So you can just start
using the repository

00:20:34.290 --> 00:20:36.070
even if you are not
using the new artifact

00:20:36.070 --> 00:20:39.014
that we released yesterday.

00:20:39.014 --> 00:20:40.680
Then let's talk about
build preferments.

00:20:40.680 --> 00:20:43.260
We know it's a big problem
for a lot of developers

00:20:43.260 --> 00:20:46.440
and we spent the last few
quarters really focusing

00:20:46.440 --> 00:20:47.997
on that a lot.

00:20:47.997 --> 00:20:49.830
So the first thing that
I want to talk about

00:20:49.830 --> 00:20:52.800
is making a lot of
task more incremental.

00:20:52.800 --> 00:20:56.910
So we looked at the biggest task
that takes the longest to run.

00:20:56.910 --> 00:21:00.810
And we looked at what we could
do to make them incremental.

00:21:00.810 --> 00:21:03.240
So the Java compilation is
actually part of Gradle itself.

00:21:03.240 --> 00:21:06.000
And, as of Gradle
3.5 it's enabled

00:21:06.000 --> 00:21:09.480
by default and it's stable
incremental compilation.

00:21:09.480 --> 00:21:11.340
It doesn't yet support
annotation processor,

00:21:11.340 --> 00:21:13.756
but it's something that we're
working with the Gradle team

00:21:13.756 --> 00:21:14.550
to fix.

00:21:14.550 --> 00:21:18.350
Dexing in the plug-in
3.0 is incremental

00:21:18.350 --> 00:21:22.270
on a per-class basis and works
with [INAUDIBLE] Dex as well.

00:21:22.270 --> 00:21:24.150
So that will make
a big difference.

00:21:24.150 --> 00:21:27.550
And then, finally,
APK packaging-- in 2.2

00:21:27.550 --> 00:21:30.522
we released that as
an incremental package

00:21:30.522 --> 00:21:31.980
so that we don't
have to recompress

00:21:31.980 --> 00:21:35.210
entries that, you know, didn't
change from the previous build.

00:21:35.210 --> 00:21:37.710
And then we have a couple of
tasks like resource processing.

00:21:37.710 --> 00:21:39.942
We are working on
it using APD 2.

00:21:39.942 --> 00:21:41.150
We've made a lot of progress.

00:21:41.150 --> 00:21:44.160
We are planning to release that
for 3.0-- for the final 3.0.

00:21:44.160 --> 00:21:46.140
And then shrinking--
if you're using

00:21:46.140 --> 00:21:48.900
shrinking in your own
debug build in order

00:21:48.900 --> 00:21:50.730
to get below the
multi-dex limit,

00:21:50.730 --> 00:21:52.612
we have an incremental
shrinker that

00:21:52.612 --> 00:21:55.070
allows pre-dexing and is faster
than just running ProGuard.

00:21:55.070 --> 00:21:57.403
So you can use that just for
de-bug and do a [INAUDIBLE]

00:21:57.403 --> 00:21:59.840
with ProGuard anyways.

00:21:59.840 --> 00:22:02.340
So the second thing I want to
talk about is the build cache.

00:22:02.340 --> 00:22:07.520
So Gradle, in 3.5,
released a build cache

00:22:07.520 --> 00:22:09.390
that works at the task level.

00:22:09.390 --> 00:22:12.660
So Gradle already looks at
the hash of all your inputs

00:22:12.660 --> 00:22:14.820
to see if the task
is up to date on it.

00:22:14.820 --> 00:22:17.386
And now it can use that
hash as a key in the cache.

00:22:17.386 --> 00:22:20.010
And if the task needs to run but
there's an entry in the cache,

00:22:20.010 --> 00:22:21.900
you're just going to
get the output directly

00:22:21.900 --> 00:22:23.890
from the cache, rather
than re-run the task.

00:22:23.890 --> 00:22:25.350
So it will be faster.

00:22:25.350 --> 00:22:27.960
It should be stable
in Gradle 4.2

00:22:27.960 --> 00:22:30.187
and enabled by
default at that point.

00:22:30.187 --> 00:22:31.770
There's three run
version of the task.

00:22:31.770 --> 00:22:33.450
The first one-- of
the cache, sorry.

00:22:33.450 --> 00:22:34.470
The first one is local.

00:22:34.470 --> 00:22:36.636
So it's good when you're
switching between branches.

00:22:36.636 --> 00:22:40.350
And you can enable it today with
Gradle 4.0 using --build-cache

00:22:40.350 --> 00:22:41.110
on the property.

00:22:41.110 --> 00:22:43.460
And then the other one
is the distributed one,

00:22:43.460 --> 00:22:46.870
sharing build cache with your
teammate and your build server.

00:22:46.870 --> 00:22:48.810
For that, you need
a storage backend.

00:22:48.810 --> 00:22:51.270
So they have a
reference implementation

00:22:51.270 --> 00:22:53.229
on top of Hazelcast
that you can use.

00:22:53.229 --> 00:22:55.020
Gradle Enterprise, of
course, we bought it.

00:22:55.020 --> 00:22:57.600
And As a very simple API if
you want to generate your own

00:22:57.600 --> 00:22:58.770
backend.

00:22:58.770 --> 00:23:01.394
So the Gradle plugin
3.0 alpha 1 does not

00:23:01.394 --> 00:23:03.060
have a lot of cache
that are, right now,

00:23:03.060 --> 00:23:05.200
mapped as cacheable--
only a couple of them.

00:23:05.200 --> 00:23:07.620
But we are planning to
roll out more of those

00:23:07.620 --> 00:23:11.020
and most of them by
the time 3.0 is final.

00:23:11.020 --> 00:23:12.651
So that should make
a big improvement.

00:23:12.651 --> 00:23:14.400
Now a lot of developers
are asking us, OK,

00:23:14.400 --> 00:23:16.530
how should I
organize my project?

00:23:16.530 --> 00:23:18.540
You know, how many
component-- how many modules?

00:23:18.540 --> 00:23:20.470
And how does that
affect performance?

00:23:20.470 --> 00:23:23.400
So, generally, more modules mean
you can go around, you know,

00:23:23.400 --> 00:23:26.460
lack of incrementality
in some of the tasks.

00:23:26.460 --> 00:23:28.980
But it's also useful for
other things, like code reuse,

00:23:28.980 --> 00:23:31.890
for example, you know,
if we want to share code

00:23:31.890 --> 00:23:33.390
across different
application, if you

00:23:33.390 --> 00:23:35.730
want to have better control
over API and dependencies--

00:23:35.730 --> 00:23:37.830
like, your business
logic should probably not

00:23:37.830 --> 00:23:40.560
have access to some random UI
from work that you are using.

00:23:40.560 --> 00:23:43.370
But, in terms of performance,
with caching in particular,

00:23:43.370 --> 00:23:45.360
then having more modules
mean more chances

00:23:45.360 --> 00:23:47.310
to have a cache sheet,
and that's better.

00:23:47.310 --> 00:23:49.800
And, also, there's something
called compilation avoidance

00:23:49.800 --> 00:23:53.289
that was introduced in Gradle
3.4, that you're now using.

00:23:53.289 --> 00:23:54.580
I'm not going to talk about it.

00:23:54.580 --> 00:23:57.750
James [INAUDIBLE] will have
a talk today at 5:30 talking

00:23:57.750 --> 00:24:00.020
about building up speed--

00:24:00.020 --> 00:24:02.477
build speed-- and they'll
talk about it at that point.

00:24:02.477 --> 00:24:04.560
Now we know that a lot of
developers have told us,

00:24:04.560 --> 00:24:07.110
well, I'm adding more modules
and now my build is lot slower.

00:24:07.110 --> 00:24:08.670
You know, what gives?

00:24:08.670 --> 00:24:10.940
So this is really what
we focused on a lot

00:24:10.940 --> 00:24:13.446
in 3.0, so I want to
talk about that now.

00:24:13.446 --> 00:24:14.820
The first thing
that we looked at

00:24:14.820 --> 00:24:17.240
was the startup cost
of the build, right?

00:24:17.240 --> 00:24:18.750
That configuration
time that happens

00:24:18.750 --> 00:24:20.874
every time you want to do
a build or every time you

00:24:20.874 --> 00:24:21.450
want to sync.

00:24:21.450 --> 00:24:23.380
So we got a project
from a developer.

00:24:23.380 --> 00:24:26.530
It's about 135 modules,
220 dependencies.

00:24:26.530 --> 00:24:28.950
And in 2.2 it took almost
three minutes to configure.

00:24:28.950 --> 00:24:30.640
And that's pretty terrible.

00:24:30.640 --> 00:24:33.644
So we finally fixed that
down to 10 seconds into 2.3.

00:24:33.644 --> 00:24:35.310
But even then, we are
still doing things

00:24:35.310 --> 00:24:37.310
that we shouldn't be doing,
like preserving dependencies

00:24:37.310 --> 00:24:39.226
for all the variants,
even though you may only

00:24:39.226 --> 00:24:40.950
build one of them.

00:24:40.950 --> 00:24:42.600
And we could not
really fix it properly

00:24:42.600 --> 00:24:43.770
without a lot of new APIs.

00:24:43.770 --> 00:24:47.160
So in 3.0, with Gradle
4.0, we finally fixed that.

00:24:47.160 --> 00:24:48.840
And it's down to two seconds.

00:24:48.840 --> 00:24:50.650
We still have some
room for improvement.

00:24:50.650 --> 00:24:52.774
There's some things that
are not quite parallelized

00:24:52.774 --> 00:24:54.850
but we'll do that later.

00:24:54.850 --> 00:24:57.092
So the other thing that we
looked at was, you know,

00:24:57.092 --> 00:24:58.800
bottleneck when you
have a lot of modules

00:24:58.800 --> 00:24:59.990
and you want to
parallelize the build.

00:24:59.990 --> 00:25:01.650
And, again, it's something
we work very closely

00:25:01.650 --> 00:25:02.760
with a greater team.

00:25:02.760 --> 00:25:04.280
They did a lot of
new APIs for us

00:25:04.280 --> 00:25:05.750
and, finally, we can fix that.

00:25:05.750 --> 00:25:07.749
So let's look at
an example here.

00:25:07.749 --> 00:25:09.290
Here, on the left,
we have some tasks

00:25:09.290 --> 00:25:10.970
that belong to an
app that consumes

00:25:10.970 --> 00:25:13.250
a library and the task,
now, on the right.

00:25:13.250 --> 00:25:15.822
So let's go through what
happened in the build.

00:25:15.822 --> 00:25:17.780
And, you know, we're
going to, basically, build

00:25:17.780 --> 00:25:20.450
all the elements of
the app of the library

00:25:20.450 --> 00:25:22.970
and then package them in
a big zip file-- the AAR.

00:25:22.970 --> 00:25:24.930
And then we're going
to unzip that AAR.

00:25:24.930 --> 00:25:27.350
And we're going to consume
it, you know, on the app.

00:25:27.350 --> 00:25:29.330
So you can see,
zero parallelism--

00:25:29.330 --> 00:25:30.290
that's pretty terrible.

00:25:30.290 --> 00:25:32.164
So, again, with those
new APIs that we have--

00:25:32.164 --> 00:25:35.540
now we can publish all
those elements of the AAR--

00:25:35.540 --> 00:25:37.280
and there's what,
like 14 of them--

00:25:37.280 --> 00:25:39.910
separately, instead of just
having to publish the full AAR.

00:25:39.910 --> 00:25:42.118
And the build, instead, can
look something like that.

00:25:42.118 --> 00:25:44.510
As soon as the manifest
of the library is used--

00:25:44.510 --> 00:25:47.180
is available-- we can
keep building the library,

00:25:47.180 --> 00:25:48.980
but we can start
building the app too.

00:25:48.980 --> 00:25:51.060
And then you have
better parallelism.

00:25:51.060 --> 00:25:53.700
And, notice, also that we don't
build the AAR at all anymore.

00:25:53.700 --> 00:25:56.850
We don't unzip it so the builds
are more efficient that way.

00:25:56.850 --> 00:25:59.330
And then, finally, Gradle
4.0 has some additional APIs

00:25:59.330 --> 00:26:02.519
to do parallelism
inside a single module.

00:26:02.519 --> 00:26:03.810
We're not quite using them yet.

00:26:03.810 --> 00:26:06.390
But we're going to
start using them soon.

00:26:06.390 --> 00:26:06.890
All right.

00:26:06.890 --> 00:26:08.599
Let's talk about some
new build features.

00:26:08.599 --> 00:26:10.306
Oh, and I want to
mention that, you know,

00:26:10.306 --> 00:26:11.356
it's just the first step.

00:26:11.356 --> 00:26:12.730
We're not saying
we're going to--

00:26:12.730 --> 00:26:14.270
3.0 is going to fix
everything, right?

00:26:14.270 --> 00:26:16.519
It's something we're going
to keep investing a lot in.

00:26:16.519 --> 00:26:18.060
And it's just like a first step.

00:26:18.060 --> 00:26:18.560
OK.

00:26:18.560 --> 00:26:19.960
So some new build features.

00:26:19.960 --> 00:26:23.390
First thing I want to talk about
is Java 8 language features.

00:26:23.390 --> 00:26:25.700
So it used to require jack.

00:26:25.700 --> 00:26:28.010
We announced a few weeks ago
that jack is [INAUDIBLE].

00:26:28.010 --> 00:26:30.460
In fact, in 3.0, jack
is completely removed.

00:26:30.460 --> 00:26:33.010
If you try to enable it, it
will tell you don't enable it.

00:26:33.010 --> 00:26:35.557
The DSL is still there so
that we have a proper message.

00:26:35.557 --> 00:26:37.640
All you have to set up is
the source compatibility

00:26:37.640 --> 00:26:39.590
and the target compatibility.

00:26:39.590 --> 00:26:42.500
So the build looks
something like this, right?

00:26:42.500 --> 00:26:44.360
We go from Javac,
which generates

00:26:44.360 --> 00:26:46.990
Java 8 class Bytecode, to a
converter that converts that

00:26:46.990 --> 00:26:50.420
to Java 7 class Bytecode,
transforms, and then dexing.

00:26:50.420 --> 00:26:52.880
The transform is things like
ProGuard, [? InstantRend. ?]

00:26:52.880 --> 00:26:54.630
But also you're on
transforms, potentially

00:26:54.630 --> 00:26:56.060
if you use the transform API.

00:26:56.060 --> 00:26:59.080
So, just as a heads-up,
later-- probably in 3.1,

00:26:59.080 --> 00:27:01.190
we're going to reverse
those two steps

00:27:01.190 --> 00:27:02.720
and do the conversion after.

00:27:02.720 --> 00:27:04.250
So if you have
custom transform, you

00:27:04.250 --> 00:27:06.530
need to update them to
Java 8 class Bytecode

00:27:06.530 --> 00:27:09.080
as soon as possible.

00:27:09.080 --> 00:27:10.790
The second feature
I want to talk about

00:27:10.790 --> 00:27:12.890
is dependency management.

00:27:12.890 --> 00:27:14.876
So there's a lot of
changes here in 3.0.

00:27:14.876 --> 00:27:16.250
You're probably
aware that if you

00:27:16.250 --> 00:27:19.970
have an app and a library
right now, the library--

00:27:19.970 --> 00:27:22.650
the app only consumed the
release version of the library

00:27:22.650 --> 00:27:23.435
always.

00:27:23.435 --> 00:27:25.670
So on the right here, you
have the configuration

00:27:25.670 --> 00:27:26.391
of the library--

00:27:26.391 --> 00:27:27.140
debug and release.

00:27:27.140 --> 00:27:29.180
And then you have the
configuration of the app--

00:27:29.180 --> 00:27:32.150
debug and release, and
then compile and packaging.

00:27:32.150 --> 00:27:33.740
And you could kind
of like go around

00:27:33.740 --> 00:27:36.470
that by manually setting
up, you know, debug compile,

00:27:36.470 --> 00:27:37.590
and then targeting debug.

00:27:37.590 --> 00:27:38.720
And that would work.

00:27:38.720 --> 00:27:41.130
But if you use flavors, it
doesn't quite work very well.

00:27:41.130 --> 00:27:43.430
Now in 3.0, things
are more complicated

00:27:43.430 --> 00:27:46.160
because for
compilation avoidance,

00:27:46.160 --> 00:27:48.320
what we have on the
library side is we publish

00:27:48.320 --> 00:27:50.870
two configuration per variant.

00:27:50.870 --> 00:27:52.750
So now we have debug
API element and debugger

00:27:52.750 --> 00:27:54.310
runtime that are meant to
be used on the other side

00:27:54.310 --> 00:27:56.120
by compile and runtime,
which were renamed

00:27:56.120 --> 00:27:57.860
to match the Gradle ones.

00:27:57.860 --> 00:28:01.180
So the good news is that we
finally fixed that in 3.0,

00:28:01.180 --> 00:28:02.930
thanks to new API in Gradle.

00:28:02.930 --> 00:28:04.580
Now the step goes automatically.

00:28:04.580 --> 00:28:07.380
We don't have to manually
try to make that work.

00:28:07.380 --> 00:28:09.844
So let's look to see how
that works at a high level.

00:28:09.844 --> 00:28:11.510
Basically, we have
the ability to set up

00:28:11.510 --> 00:28:14.032
attributes on this
configuration object

00:28:14.032 --> 00:28:15.740
and Gradle will
automatically match them.

00:28:15.740 --> 00:28:18.050
So we created an attribute
on build type for you

00:28:18.050 --> 00:28:19.000
automatically.

00:28:19.000 --> 00:28:22.820
And then debug matches debug and
then release matches release.

00:28:22.820 --> 00:28:24.470
If you have flavors, same thing.

00:28:24.470 --> 00:28:26.390
We create a new
attribute for the flavor

00:28:26.390 --> 00:28:28.744
and then bluedebug matches
with bluedebug automatically.

00:28:28.744 --> 00:28:30.410
You know, you don't
have anything to do.

00:28:30.410 --> 00:28:32.030
It is done automatically.

00:28:32.030 --> 00:28:34.790
Now, of course, if you don't
have the same number of flavor

00:28:34.790 --> 00:28:36.570
everywhere, it's
going to work too--

00:28:36.570 --> 00:28:38.580
like, if you don't have
them in the library,

00:28:38.580 --> 00:28:41.570
bluedeblug is going to match
with debug automatically.

00:28:41.570 --> 00:28:44.040
The attributes are
actually optional.

00:28:44.040 --> 00:28:46.040
However, if that's the
other way around-- if you

00:28:46.040 --> 00:28:48.020
have a library with
flavors, but you

00:28:48.020 --> 00:28:49.535
don't have flavor
in an application,

00:28:49.535 --> 00:28:50.910
then it's just
not going to work.

00:28:50.910 --> 00:28:53.240
And you're to get a build
error and you have to fix it.

00:28:53.240 --> 00:28:54.330
So we have a new DSL--

00:28:54.330 --> 00:28:56.120
it's called flavor selection.

00:28:56.120 --> 00:28:58.540
It's not variant-aware yet,
but we're going to do that--

00:28:58.540 --> 00:29:00.248
where you basically
tell the build, look,

00:29:00.248 --> 00:29:02.600
I want to pick blue
instead of orange.

00:29:02.600 --> 00:29:05.160
And then it just works.

00:29:05.160 --> 00:29:07.550
Now if you switch to 3.0,
and you have flavors,

00:29:07.550 --> 00:29:10.480
you're very likely to run into
that error saying, you know,

00:29:10.480 --> 00:29:13.070
hey, flavor dimension
name is now required--

00:29:13.070 --> 00:29:15.470
which you may already be
doing with two different ones

00:29:15.470 --> 00:29:18.329
but not if you have
a singular dimension.

00:29:18.329 --> 00:29:20.120
So fixing it is very
easy, right, you know.

00:29:20.120 --> 00:29:21.744
That's your code, roughly.

00:29:21.744 --> 00:29:23.660
And then you fix it with
that and that's done.

00:29:23.660 --> 00:29:24.930
You don't actually
need to put it

00:29:24.930 --> 00:29:26.480
in like flavor one
or flavor two block

00:29:26.480 --> 00:29:27.938
because there's
only one dimension.

00:29:27.938 --> 00:29:30.039
We can just fix that for you.

00:29:30.039 --> 00:29:32.330
So the big question is, why
do we force you to do that?

00:29:32.330 --> 00:29:35.040
Why can't we just pick up
a random default value?

00:29:35.040 --> 00:29:36.950
So let's go through an example.

00:29:36.950 --> 00:29:38.240
Here we have an app.

00:29:38.240 --> 00:29:40.520
And the app requires
debug orange.

00:29:40.520 --> 00:29:43.460
And then we have two libraries,
one of them with two flavors--

00:29:43.460 --> 00:29:46.065
blue and orange-- and the one
with strawberry and orange.

00:29:46.065 --> 00:29:48.440
Now you can already see that's
not quite the same orange,

00:29:48.440 --> 00:29:48.940
right?

00:29:48.940 --> 00:29:50.060
And we just don't know.

00:29:50.060 --> 00:29:51.510
So when the apps
says orange, it's

00:29:51.510 --> 00:29:54.350
like, I don't know
which orange you want.

00:29:54.350 --> 00:29:57.650
So that's why we ask you to
name those flavor dimensions.

00:29:57.650 --> 00:30:00.404
Because we're going to use that
as the name of the attribute.

00:30:00.404 --> 00:30:01.820
And then the name
of the attribute

00:30:01.820 --> 00:30:04.250
is actually color blue,
color orange, and then

00:30:04.250 --> 00:30:05.250
fruit strawberry.

00:30:05.250 --> 00:30:07.040
And then we can make
the right selection.

00:30:07.040 --> 00:30:08.331
And it's the same thing, right.

00:30:08.331 --> 00:30:10.841
Here, to make it work, you
have to set a flavor selection.

00:30:10.841 --> 00:30:13.340
And, in order to do that, you
need to not just give us blue,

00:30:13.340 --> 00:30:15.756
but you need to give us color
blue so that we can properly

00:30:15.756 --> 00:30:19.100
set that new attribute
on the configuration

00:30:19.100 --> 00:30:22.660
and then it just
works out of the box.

00:30:22.660 --> 00:30:23.450
OK.

00:30:23.450 --> 00:30:25.700
Let's talk about instant
app a little bit.

00:30:25.700 --> 00:30:27.050
So let's say you have an app--

00:30:27.050 --> 00:30:29.466
you know, it has a few modules--
an app module, with that,

00:30:29.466 --> 00:30:32.329
the application module;
some library modules.

00:30:32.329 --> 00:30:34.370
And then you want to make
some of those libraries

00:30:34.370 --> 00:30:36.129
as features for
your instant app.

00:30:36.129 --> 00:30:37.670
So the first thing
you're going to do

00:30:37.670 --> 00:30:41.300
is change some of those
plugins to be not library,

00:30:41.300 --> 00:30:42.140
but be feature.

00:30:42.140 --> 00:30:43.598
It's a new plugin
that we released.

00:30:43.598 --> 00:30:44.810
It's part of 3.0.

00:30:44.810 --> 00:30:47.300
And what's nice about
that feature plugin is

00:30:47.300 --> 00:30:48.920
that it uses the
attribute mechanism

00:30:48.920 --> 00:30:53.440
I just talked about so that
it publishes both a AAR--

00:30:53.440 --> 00:30:55.970
or at least the content
of the AAR for an app--

00:30:55.970 --> 00:30:57.500
and a feature APK.

00:30:57.500 --> 00:31:00.060
So when an app says, hey,
you know, I depend on you.

00:31:00.060 --> 00:31:01.640
Give me your artifact.

00:31:01.640 --> 00:31:03.860
It adds to the attribute
saying, I'm an app.

00:31:03.860 --> 00:31:06.276
And then it's going to link
it to the right configuration.

00:31:06.276 --> 00:31:08.600
And it's going to consume
the feature plugin, you know,

00:31:08.600 --> 00:31:09.920
as an AAR.

00:31:09.920 --> 00:31:11.510
And when you have
another module that

00:31:11.510 --> 00:31:15.429
is an instant app-- and the
goal of that instant app module

00:31:15.429 --> 00:31:16.470
is not to build anything.

00:31:16.470 --> 00:31:17.386
It's just to package--

00:31:17.386 --> 00:31:19.416
to grab-- all of
the features APK

00:31:19.416 --> 00:31:21.790
and make it into a bundle that
can be uploaded to a phone

00:31:21.790 --> 00:31:23.139
or to the Play store.

00:31:23.139 --> 00:31:24.680
Then the feature
plugin will actually

00:31:24.680 --> 00:31:26.740
build a feature APK--
something that can actually

00:31:26.740 --> 00:31:29.760
be distributed to your phone as,
you know, instant app feature.

00:31:29.760 --> 00:31:32.960
And that way you can
really share code

00:31:32.960 --> 00:31:34.610
without having to
do some weird stuff.

00:31:34.610 --> 00:31:36.770
It's just the regular
module that you had before--

00:31:36.770 --> 00:31:38.450
just change the
plugin, and that's it.

00:31:38.450 --> 00:31:41.220
If you want more information
about building Android apps,

00:31:41.220 --> 00:31:45.140
there's a talk at 3:30 today
that I encourage you to watch.

00:31:45.140 --> 00:31:47.971
And, with that, back to Jamal.

00:31:47.971 --> 00:31:49.919
[APPLAUSE]

00:31:53.047 --> 00:31:54.380
JAMAL EASON: All right, so test.

00:31:54.380 --> 00:31:56.930
So now you've developed
and built your application.

00:31:56.930 --> 00:32:00.000
Now it's time to test.

00:32:00.000 --> 00:32:01.550
So we offer inside
of Android Studio

00:32:01.550 --> 00:32:04.370
is a new performant Android
emulator, which we actually

00:32:04.370 --> 00:32:05.940
released about a
year and a half ago.

00:32:05.940 --> 00:32:08.481
So if you haven't tried it since
then, I highly encourage it.

00:32:08.481 --> 00:32:09.712
It's fast and exciting.

00:32:09.712 --> 00:32:11.420
But after launching
the Android emulator,

00:32:11.420 --> 00:32:14.270
we found about two pain
points from developers.

00:32:14.270 --> 00:32:17.484
One-- developers want to try
out their end-to-end flow.

00:32:17.484 --> 00:32:19.400
What's the experience
look like, for instance,

00:32:19.400 --> 00:32:22.640
when my app-- when my user
actually downloads my app?

00:32:22.640 --> 00:32:24.064
Or, perhaps, what's
the experience

00:32:24.064 --> 00:32:24.980
of an in-app purchase?

00:32:24.980 --> 00:32:26.780
There was no way to test this.

00:32:26.780 --> 00:32:29.770
The second pain-point was
around Google Play services.

00:32:29.770 --> 00:32:31.330
It seemed, every
release, there was

00:32:31.330 --> 00:32:33.950
some lag between Google Play
services and the Android

00:32:33.950 --> 00:32:34.820
emulator.

00:32:34.820 --> 00:32:40.106
So to that, we added the Google
Play Store to the emulator.

00:32:40.106 --> 00:32:42.002
[APPLAUSE]

00:32:44.380 --> 00:32:46.900
Now this seemingly small step
was actually a lot of work.

00:32:46.900 --> 00:32:49.441
What we did was actually add a
lot of quality and performance

00:32:49.441 --> 00:32:52.000
enhancements to ensure we
had a great experience when

00:32:52.000 --> 00:32:54.070
using the Play Store
with the emulator.

00:32:54.070 --> 00:32:56.050
Along with that, we
also added support

00:32:56.050 --> 00:32:58.630
for OpenGL ES 3.0,
which, hopefully,

00:32:58.630 --> 00:33:01.510
will help you accelerate
your testing as well.

00:33:01.510 --> 00:33:03.739
And, lastly, we
added proxy support.

00:33:03.739 --> 00:33:05.530
I know some of you have
Enterprise networks

00:33:05.530 --> 00:33:06.910
or unique ATT support.

00:33:06.910 --> 00:33:08.860
Now we have a UI system
that manages that.

00:33:11.235 --> 00:33:13.360
So I want to talk about
the impact and implications

00:33:13.360 --> 00:33:14.780
of adding the Play Store.

00:33:14.780 --> 00:33:17.990
So we've always shipped the AOSP
versions, or the Android Open

00:33:17.990 --> 00:33:20.630
Source Project versions
of the system images.

00:33:20.630 --> 00:33:23.120
What this allowed you to do
is have unfettered access

00:33:23.120 --> 00:33:25.080
to both the operating
system and your app

00:33:25.080 --> 00:33:27.620
by having elevated
privileges in root access.

00:33:27.620 --> 00:33:29.482
But by adding the
Google Play Store,

00:33:29.482 --> 00:33:31.190
we actually have a
new variation of this,

00:33:31.190 --> 00:33:33.170
called the Google Play edition.

00:33:33.170 --> 00:33:35.480
What this means is now we
actually digitally sign

00:33:35.480 --> 00:33:36.560
the system images.

00:33:36.560 --> 00:33:38.630
But that prevents you
from having root access.

00:33:38.630 --> 00:33:40.806
So if you want Google
Play and Google APIs,

00:33:40.806 --> 00:33:42.180
just use the Google
Play edition.

00:33:42.180 --> 00:33:44.221
But if you want the deep
analysis and root access

00:33:44.221 --> 00:33:48.444
ability, you still have the AOSP
version that's also available.

00:33:48.444 --> 00:33:50.860
One additional thing I want
to talk about for the emulator

00:33:50.860 --> 00:33:53.020
is actually this app
bug reporting system.

00:33:53.020 --> 00:33:54.340
So we heard from some
of you, like, hey, I

00:33:54.340 --> 00:33:56.756
want to have a quick way to
take a bug report so, perhaps,

00:33:56.756 --> 00:33:59.020
I can share with my
colleague or my QA team.

00:33:59.020 --> 00:34:01.010
So now, with one
or two clicks, you

00:34:01.010 --> 00:34:03.390
can create a bug report for
emulator, take a screenshot,

00:34:03.390 --> 00:34:05.170
have some space
to do a repo step,

00:34:05.170 --> 00:34:06.830
and put that to your QA team.

00:34:06.830 --> 00:34:09.163
So that should make it quicker
for you to do development

00:34:09.163 --> 00:34:12.150
on the emulator.

00:34:12.150 --> 00:34:14.699
Lastly, for those of you who
do Android Wear development.

00:34:14.699 --> 00:34:16.800
As you heard, with
Android Wear 2.0,

00:34:16.800 --> 00:34:18.598
we now support devices
with rotary support.

00:34:18.598 --> 00:34:20.639
So we added a feature
inside the emulator for you

00:34:20.639 --> 00:34:25.560
now to test that all inside
the Android emulator.

00:34:25.560 --> 00:34:28.404
And, lastly, about debugging
is around the Layout Inspector.

00:34:28.404 --> 00:34:29.820
So, as you saw
from Tor's demo, we

00:34:29.820 --> 00:34:31.739
have a rich, new
Layout Editor, which

00:34:31.739 --> 00:34:34.469
allows you to add new constraint
layouts and new themes

00:34:34.469 --> 00:34:35.803
and styles for your application.

00:34:35.803 --> 00:34:38.219
But many times you might have
a problem with your layout--

00:34:38.219 --> 00:34:40.880
something's the wrong color, or
something's invisible, or gone.

00:34:40.880 --> 00:34:43.246
So we actually launched a
Layout inspector last year.

00:34:43.246 --> 00:34:45.120
But with this release
we added new capability

00:34:45.120 --> 00:34:47.370
for better search and better
organizational properties

00:34:47.370 --> 00:34:49.540
to help debug your
layouts for Android app.

00:34:52.480 --> 00:34:55.210
So, lastly, optimize.

00:34:55.210 --> 00:34:57.070
So as you heard
during the keynote,

00:34:57.070 --> 00:34:58.750
we talked about Android vitals.

00:34:58.750 --> 00:35:01.166
And what this really is about
is about the system health--

00:35:01.166 --> 00:35:03.169
about your phone
and the apps on it.

00:35:03.169 --> 00:35:04.960
And the way we think
about this is actually

00:35:04.960 --> 00:35:07.639
sort of a continuum of
information that's available.

00:35:07.639 --> 00:35:09.430
So as you get the system
health information

00:35:09.430 --> 00:35:12.760
now available through the Google
Play console or Firebase--

00:35:12.760 --> 00:35:14.900
now you have a list
of sort of symptoms

00:35:14.900 --> 00:35:16.900
of what might be going
on with your application.

00:35:16.900 --> 00:35:18.819
And now you can pop
into Android Studio

00:35:18.819 --> 00:35:20.860
to have a deeper understanding
of what's going on

00:35:20.860 --> 00:35:22.870
and have a root case analysis.

00:35:22.870 --> 00:35:24.970
And, as Tor showed you,
at the core of this

00:35:24.970 --> 00:35:26.249
is the Android profiler.

00:35:26.249 --> 00:35:28.540
So I hope you take advantage
of all these various tools

00:35:28.540 --> 00:35:30.190
to understand--
ranging from, again,

00:35:30.190 --> 00:35:33.404
the CPU profiler to understand
what is going on with your CPU;

00:35:33.404 --> 00:35:35.320
the memory usage to
understand what's going on

00:35:35.320 --> 00:35:37.420
with your memory profile
of your application;

00:35:37.420 --> 00:35:39.280
and, lastly, the
network profiler,

00:35:39.280 --> 00:35:40.904
to get a deeper
understanding of what's

00:35:40.904 --> 00:35:44.612
going on with your network
traffic of your app.

00:35:44.612 --> 00:35:46.570
The last topic I want to
talk about in optimize

00:35:46.570 --> 00:35:48.820
is around APK size.

00:35:48.820 --> 00:35:50.570
So, as you heard on
the keynote yesterday,

00:35:50.570 --> 00:35:53.180
we announced Android
Go and this initiative

00:35:53.180 --> 00:35:56.510
around making Android
optimal and smaller.

00:35:56.510 --> 00:35:57.970
So, many times
with your APK, you

00:35:57.970 --> 00:36:00.250
might have legacy code or
things going on with it

00:36:00.250 --> 00:36:02.930
you may not sort of remember
putting into the app.

00:36:02.930 --> 00:36:05.260
So with 3.0, as
Tor demonstrated,

00:36:05.260 --> 00:36:07.120
we've now added
additional capability

00:36:07.120 --> 00:36:08.350
into the APK analyzer.

00:36:08.350 --> 00:36:09.910
So, again, I invite
you to use this

00:36:09.910 --> 00:36:12.796
in your typical
optimization flow.

00:36:12.796 --> 00:36:14.170
As demonstrated,
we added support

00:36:14.170 --> 00:36:17.387
for instant apps, better
Bytecode support, ProGuard file

00:36:17.387 --> 00:36:18.400
mapping, and much more.

00:36:21.200 --> 00:36:23.820
And, lastly, I want to call
out a big feature around vector

00:36:23.820 --> 00:36:24.720
assets.

00:36:24.720 --> 00:36:27.120
So I'm a big fan of using
vector assets myself.

00:36:27.120 --> 00:36:29.780
And it's a great way to
optimize your application.

00:36:29.780 --> 00:36:32.190
But if you must use a
bitmap or a raster image,

00:36:32.190 --> 00:36:34.920
we added WebP support
inside of Android Studio.

00:36:34.920 --> 00:36:37.950
And what we found is, if you
convert from PNG to JPEG,

00:36:37.950 --> 00:36:41.130
you can save upwards of 25%
in your file size, which

00:36:41.130 --> 00:36:43.110
would be a huge saving for APK.

00:36:43.110 --> 00:36:45.180
So, again, if you right
click on any PNG instead

00:36:45.180 --> 00:36:46.920
of-- or JPEG inside
of Android Studio,

00:36:46.920 --> 00:36:48.420
we will auto-convert it to WebP.

00:36:48.420 --> 00:36:50.370
And if you want to edit it, you
can actually convert your WebP

00:36:50.370 --> 00:36:51.210
back into PNG.

00:36:54.060 --> 00:36:56.077
And, with that,
that's Android Studio.

00:36:56.077 --> 00:36:57.660
So we talked about
a range of features

00:36:57.660 --> 00:37:00.035
from develop, for adding Kotlin
support, or better Java 8

00:37:00.035 --> 00:37:01.830
language support;
better instant app

00:37:01.830 --> 00:37:04.480
support inside the build system;
adding the Google Play Store

00:37:04.480 --> 00:37:06.180
to the emulator;
and a whole suite

00:37:06.180 --> 00:37:07.710
of optimization tools for you.

00:37:10.650 --> 00:37:12.510
And with that, that's our talk.

00:37:12.510 --> 00:37:14.046
Thank you so much.

00:37:14.046 --> 00:37:15.958
[APPLAUSE]

00:37:17.870 --> 00:37:22.354
[MUSIC PLAYING]

