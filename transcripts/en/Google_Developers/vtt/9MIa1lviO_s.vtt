WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:07.400
[MUSIC PLAYING]

00:00:07.400 --> 00:00:08.764
NATHAN MARTZ: Hello, everyone.

00:00:08.764 --> 00:00:10.180
Thanks so much for
sticking around

00:00:10.180 --> 00:00:13.200
for the very last session
of I/O and the last session

00:00:13.200 --> 00:00:17.300
in our Daydream series of
talks here at I/O 2016.

00:00:17.300 --> 00:00:20.300
It's really fun to be here
to talk about Daydream

00:00:20.300 --> 00:00:22.000
and to talk about it in detail.

00:00:22.000 --> 00:00:24.720
Today we're going to talk
about building high performance

00:00:24.720 --> 00:00:26.300
Daydream apps.

00:00:26.300 --> 00:00:28.470
So as I'm sure you
all know, Daydream

00:00:28.470 --> 00:00:31.980
is Google's new VR platform
for building immersive,

00:00:31.980 --> 00:00:37.380
interactive long form VR
applications and experiences.

00:00:37.380 --> 00:00:41.190
And when we talk about
creating immersive, creating

00:00:41.190 --> 00:00:43.910
a sense of presence,
really what we're doing

00:00:43.910 --> 00:00:48.330
is creating an illusion for
the mind, albeit an extremely

00:00:48.330 --> 00:00:50.170
compelling illusion.

00:00:50.170 --> 00:00:53.150
And today we're going to
get to the API's for how

00:00:53.150 --> 00:00:54.680
we create that illusion.

00:00:54.680 --> 00:00:58.270
But before we get there, we need
to understand why this matters

00:00:58.270 --> 00:01:00.530
from a physiological level.

00:01:00.530 --> 00:01:03.880
So there's two very interrelated
and important systems

00:01:03.880 --> 00:01:06.950
to understand when you
think about presence in VR.

00:01:06.950 --> 00:01:10.720
The first is your inner
ear, your vestibular system.

00:01:10.720 --> 00:01:12.200
This is the part
of your body that

00:01:12.200 --> 00:01:15.250
understands balance,
that is what

00:01:15.250 --> 00:01:18.776
responds to when you tilt your
head, when you move your body.

00:01:18.776 --> 00:01:20.400
The system is a
constant sense of where

00:01:20.400 --> 00:01:22.600
your head is oriented in space.

00:01:22.600 --> 00:01:25.320
The other system is your
ocular system, your eyes,

00:01:25.320 --> 00:01:27.860
which of course are
how you see the world.

00:01:27.860 --> 00:01:30.030
And normally, unless
you've eaten something

00:01:30.030 --> 00:01:32.390
you shouldn't have,
those two systems

00:01:32.390 --> 00:01:35.120
are perfectly in sync
with one another.

00:01:35.120 --> 00:01:37.690
As you move your head, your
eyes adjust and your inner ear

00:01:37.690 --> 00:01:40.020
picks up the change right away.

00:01:40.020 --> 00:01:42.720
The challenge is that
in VR, there's actually

00:01:42.720 --> 00:01:46.270
a lot of things that happen
between your movement, which

00:01:46.270 --> 00:01:49.490
is instantaneously sensed
by your vestibular system,

00:01:49.490 --> 00:01:51.570
and what your eyes see.

00:01:51.570 --> 00:01:53.682
You have things like
when you move your head,

00:01:53.682 --> 00:01:55.140
there are sensors
in the phone that

00:01:55.140 --> 00:01:56.710
have to pick up that movement.

00:01:56.710 --> 00:02:00.350
They send that to the CPU, which
is computation and simulation.

00:02:00.350 --> 00:02:01.020
It renders.

00:02:01.020 --> 00:02:03.210
It sends that to the GPU,
which does rendering.

00:02:03.210 --> 00:02:05.150
And then the display
has to output it.

00:02:05.150 --> 00:02:07.660
And then finally, it
gets to your eyes.

00:02:07.660 --> 00:02:11.692
And the longer the gap
is between the movement

00:02:11.692 --> 00:02:13.650
that you created-- what
your inner ear sensed--

00:02:13.650 --> 00:02:16.550
and what you see on
screen, we call that motion

00:02:16.550 --> 00:02:20.720
to photon latency-- the amount
of time from motion to photon.

00:02:20.720 --> 00:02:25.500
And that's responsible for
how present we feel in VR.

00:02:25.500 --> 00:02:27.895
A lot of lag, we
feel very absent.

00:02:27.895 --> 00:02:30.320
In fact, you can even
feel simulator sickness.

00:02:30.320 --> 00:02:32.620
And so really our
goal-- and what Daydream

00:02:32.620 --> 00:02:36.990
allows-- is for you to get
below 20 milliseconds of motion

00:02:36.990 --> 00:02:38.610
to photon latency.

00:02:38.610 --> 00:02:41.420
And the focus of today's
talk is how you do that

00:02:41.420 --> 00:02:44.319
and how you do it in
a sustained fashion.

00:02:44.319 --> 00:02:46.610
There's another thing that
I think is really important,

00:02:46.610 --> 00:02:48.730
which is at a higher level.

00:02:48.730 --> 00:02:50.580
We're all building experiences.

00:02:50.580 --> 00:02:51.760
We talk about mobile VR.

00:02:51.760 --> 00:02:53.470
These are devices
that run on batteries.

00:02:53.470 --> 00:02:55.220
They're seven watt devices.

00:02:55.220 --> 00:02:58.160
But we're also in a
world full of computers

00:02:58.160 --> 00:03:01.580
that plug into power plants,
the 600 watt devices.

00:03:01.580 --> 00:03:04.185
And of course, we want to create
immersive, compelling, fun,

00:03:04.185 --> 00:03:06.930
and engaging experiences
for mobile VR

00:03:06.930 --> 00:03:08.870
that feel just as
good as the ones you

00:03:08.870 --> 00:03:11.580
can get on high-end desktops.

00:03:11.580 --> 00:03:15.400
So to do that, Daydream
provides a platform for you.

00:03:15.400 --> 00:03:17.720
There's a hardware
component to the platform,

00:03:17.720 --> 00:03:20.870
the phone itself, all the
Daydream certified components

00:03:20.870 --> 00:03:21.920
in it.

00:03:21.920 --> 00:03:24.365
And then there's the OS,
Android N, and it's VR mode,

00:03:24.365 --> 00:03:27.150
a support for low latency
rendering and head tracking

00:03:27.150 --> 00:03:29.380
and all of that good stuff.

00:03:29.380 --> 00:03:31.870
So to tell you how to take
advantage of that hardware

00:03:31.870 --> 00:03:33.440
and software
platform, we're going

00:03:33.440 --> 00:03:35.970
to look at three
really key components.

00:03:35.970 --> 00:03:38.100
We're going to look at
rendering-- how you actually

00:03:38.100 --> 00:03:41.330
set the machine up to get it
to run in a low latency mode--

00:03:41.330 --> 00:03:44.170
general performance and
optimization strategies,

00:03:44.170 --> 00:03:46.800
and lastly, how
you can use audio

00:03:46.800 --> 00:03:51.540
to save yourself a lot of time
and your phone a lot of energy.

00:03:51.540 --> 00:03:53.625
So the first and really
key section is rendering.

00:03:53.625 --> 00:03:56.970
This is where a lot of time
and compute goes in VR.

00:03:56.970 --> 00:04:00.670
So let's say you start
with a Daydream phone.

00:04:00.670 --> 00:04:01.540
Great.

00:04:01.540 --> 00:04:03.456
In a simple version of
rendering, you're like,

00:04:03.456 --> 00:04:04.310
I have a phone.

00:04:04.310 --> 00:04:06.170
And then I render
to the phone screen.

00:04:06.170 --> 00:04:06.882
That's our ideal.

00:04:06.882 --> 00:04:08.340
I have a thing,
and I render to it.

00:04:08.340 --> 00:04:09.536
Done.

00:04:09.536 --> 00:04:10.910
But the reality
is that rendering

00:04:10.910 --> 00:04:11.850
doesn't work that way.

00:04:11.850 --> 00:04:13.290
It's more complicated.

00:04:13.290 --> 00:04:16.660
So traditionally, 3D
apps are double buffered.

00:04:16.660 --> 00:04:19.519
You render to one
image or texture

00:04:19.519 --> 00:04:22.980
while the phone is scanning
out another texture.

00:04:22.980 --> 00:04:25.420
But because there
are two buffers,

00:04:25.420 --> 00:04:27.250
that buffering adds latency.

00:04:27.250 --> 00:04:29.670
It takes certain amount of
time to scan one while you're

00:04:29.670 --> 00:04:30.720
rendering to the other.

00:04:30.720 --> 00:04:33.930
And so already you may have
16 or 30 milliseconds just

00:04:33.930 --> 00:04:35.400
from that one step.

00:04:35.400 --> 00:04:39.100
And in fact on Android by
default, not in VR mode,

00:04:39.100 --> 00:04:40.970
it may add another
frame or maybe even

00:04:40.970 --> 00:04:43.800
two frames of additional
latency as Android tries

00:04:43.800 --> 00:04:45.126
to smooth out the experience.

00:04:45.126 --> 00:04:46.750
So this latency,
which isn't noticeable

00:04:46.750 --> 00:04:52.090
at all on a regular app or
game, is very noticeable in VR.

00:04:52.090 --> 00:04:54.050
And so our goal
is actually in VR

00:04:54.050 --> 00:04:56.530
to get back to that original
idea of basically you

00:04:56.530 --> 00:04:58.050
render a frame
and it's instantly

00:04:58.050 --> 00:04:59.150
available on the screen.

00:04:59.150 --> 00:05:03.010
Ideally, we want zero
motion to photon latency.

00:05:03.010 --> 00:05:06.120
So in the section that
I'm about to go through,

00:05:06.120 --> 00:05:08.560
I have a bunch of
code, all of which

00:05:08.560 --> 00:05:12.174
is extracted from samples
part of our new NDK.

00:05:12.174 --> 00:05:14.840
I'm focusing on C++ here because
I thinks that's what most folks

00:05:14.840 --> 00:05:15.798
here are interested in.

00:05:15.798 --> 00:05:17.270
There are Java examples as well.

00:05:17.270 --> 00:05:20.620
The short link at the bottom
is for the source code

00:05:20.620 --> 00:05:23.550
if you want to follow along and
look at the unexpanded source.

00:05:23.550 --> 00:05:25.250
In this section,
I've kind of cropped

00:05:25.250 --> 00:05:27.370
out the interesting
bits and left

00:05:27.370 --> 00:05:29.410
out some of the boilerplate,
which is important

00:05:29.410 --> 00:05:32.550
but not as material
for this conversation.

00:05:32.550 --> 00:05:35.660
So one of the most
basic things is set up.

00:05:35.660 --> 00:05:38.360
This is in your
MainActivity.java file.

00:05:38.360 --> 00:05:40.460
You have your onCreate
for your activity.

00:05:40.460 --> 00:05:41.876
And the first thing
you want to do

00:05:41.876 --> 00:05:45.010
is create a GVR layout,
which is part of RSDK.

00:05:45.010 --> 00:05:49.040
And the GVR layout includes all
of the scaffolding for core UX

00:05:49.040 --> 00:05:51.967
and UI in Daydream.

00:05:51.967 --> 00:05:53.550
And it also is what's
going to give us

00:05:53.550 --> 00:05:55.680
access to an internal
pointer that we

00:05:55.680 --> 00:05:57.990
use in the native code
in just a little bit.

00:05:57.990 --> 00:06:00.390
You want to create a GL
surface view-- standard way

00:06:00.390 --> 00:06:04.035
of rendering to GL in Android.

00:06:04.035 --> 00:06:05.410
And then after
that, you're going

00:06:05.410 --> 00:06:08.500
to want to actually set a
renderer up, a native renderer,

00:06:08.500 --> 00:06:11.550
for your surface view.

00:06:11.550 --> 00:06:14.630
And when you do that, there's
two really important functions.

00:06:14.630 --> 00:06:16.470
The first is onSurfaceCreated.

00:06:16.470 --> 00:06:18.380
And you're going to
want to use a JNI

00:06:18.380 --> 00:06:24.040
method to get from that Java
function into your native code.

00:06:24.040 --> 00:06:27.190
In this case, I've got a simple
sort of mock C++ function

00:06:27.190 --> 00:06:28.739
called initialized GL.

00:06:28.739 --> 00:06:30.280
And this is what's
going to be called

00:06:30.280 --> 00:06:32.062
from that onSurfaceCreated.

00:06:32.062 --> 00:06:33.520
The first thing
you want to do is--

00:06:33.520 --> 00:06:35.600
using that this
API pointer, which

00:06:35.600 --> 00:06:37.790
you can get out of
your GVR layout--

00:06:37.790 --> 00:06:40.040
is a GVR API initialize GL.

00:06:40.040 --> 00:06:41.550
That kind of tells us, OK.

00:06:41.550 --> 00:06:42.400
Daydream SDK.

00:06:42.400 --> 00:06:44.572
We're about to get started.

00:06:44.572 --> 00:06:46.280
From there, the next
thing you want to do

00:06:46.280 --> 00:06:48.490
is say, hey GVR API
GetRecommendedRenderTargetSize.

00:06:51.020 --> 00:06:53.420
And what's interesting is--
what that's going to do

00:06:53.420 --> 00:06:57.445
is it's going to look at the
phone that the user is using,

00:06:57.445 --> 00:06:59.650
and it's going to look
at the optical properties

00:06:59.650 --> 00:07:03.040
of the viewer that they're using
and compute an optimal texture

00:07:03.040 --> 00:07:06.630
size such that you get
one-to-one pixel precision

00:07:06.630 --> 00:07:08.755
at the center of the lens.

00:07:08.755 --> 00:07:11.005
Then you're going to need
to create a new framebuffer,

00:07:11.005 --> 00:07:14.610
or framebuffer chain really,
by calling our offscreen

00:07:14.610 --> 00:07:18.120
framebuffer handle function,
calling create to it,

00:07:18.120 --> 00:07:20.230
and then passing
in the render size.

00:07:20.230 --> 00:07:23.160
Now, the render size is
actually mutable intentionally.

00:07:23.160 --> 00:07:26.020
The recommended size is not
the only size you have to use.

00:07:26.020 --> 00:07:29.720
You may decide to use higher
resolution or lower resolution

00:07:29.720 --> 00:07:31.310
framebuffers.

00:07:31.310 --> 00:07:33.090
But the important
thing to highlight here

00:07:33.090 --> 00:07:35.410
is that we're creating
an off-screen texture.

00:07:35.410 --> 00:07:37.890
We're not rendering directly
to the front buffer.

00:07:37.890 --> 00:07:39.810
We're rendering to an
off-screen texture.

00:07:39.810 --> 00:07:41.460
And this off-screen
texture is actually

00:07:41.460 --> 00:07:44.610
larger than the physical
display of the phone.

00:07:44.610 --> 00:07:48.600
And we'll talk about why
that is in a few more slides.

00:07:48.600 --> 00:07:50.310
So going back to
our main activity

00:07:50.310 --> 00:07:52.600
on Java-- now that
we've set everything up,

00:07:52.600 --> 00:07:55.680
the next most important
function is onDrawFrame.

00:07:55.680 --> 00:07:57.050
And this is the tick function.

00:07:57.050 --> 00:07:59.480
This is the heartbeat that
is going to pump our renderer

00:07:59.480 --> 00:08:02.970
and keep us drawing
at 60 or 30 hertz.

00:08:02.970 --> 00:08:05.300
So here, now we're back to C++.

00:08:05.300 --> 00:08:08.482
Again, we use a JNI method to
get into C++ for draw frame.

00:08:08.482 --> 00:08:09.940
And at the top of
the function, you

00:08:09.940 --> 00:08:11.439
want to take that
framebuffer handle

00:08:11.439 --> 00:08:14.120
that you've got in your
initialize GL function

00:08:14.120 --> 00:08:15.330
and call SetActive.

00:08:15.330 --> 00:08:17.910
You're telling our
SDK, all right.

00:08:17.910 --> 00:08:18.670
We're ready to go.

00:08:18.670 --> 00:08:21.000
We're about to start
drawing using the resources

00:08:21.000 --> 00:08:24.120
that we've allocated for you.

00:08:24.120 --> 00:08:26.640
Once you do that, you
need to get the head pose.

00:08:26.640 --> 00:08:28.470
And the cool thing is
that you use our API.

00:08:28.470 --> 00:08:31.520
You say, just, hey, get where
the user's head position is.

00:08:31.520 --> 00:08:33.200
And you're
automatically accessing

00:08:33.200 --> 00:08:36.070
all of the low latency sensor
data, all of the sensor

00:08:36.070 --> 00:08:37.659
fusion, head tracking.

00:08:37.659 --> 00:08:38.720
All that's in there.

00:08:38.720 --> 00:08:39.350
You don't have to worry about.

00:08:39.350 --> 00:08:40.266
It's one line of code.

00:08:40.266 --> 00:08:41.650
We do tons of work for you.

00:08:41.650 --> 00:08:45.840
And now you know the
orientation of the user's head.

00:08:45.840 --> 00:08:48.087
The next step is to draw
the left and right eyes.

00:08:48.087 --> 00:08:49.670
I've omitted the
details of that code,

00:08:49.670 --> 00:08:51.780
but basically you're
going to draw the left eye

00:08:51.780 --> 00:08:53.365
to the left side of the
image, the right side eye

00:08:53.365 --> 00:08:54.360
to the right side.

00:08:54.360 --> 00:08:56.210
And now you have--
hey-- stereo rendering.

00:08:56.210 --> 00:08:59.030
Pretty awesome.

00:08:59.030 --> 00:09:00.970
Once you've done
that rendering, you

00:09:00.970 --> 00:09:03.090
need to do a couple
more steps before it's

00:09:03.090 --> 00:09:04.090
really ready for VR.

00:09:04.090 --> 00:09:06.340
The first is just calling
SetDefaultFramebufferActive.

00:09:11.290 --> 00:09:14.900
And that's, again, we're
saying, OK, we bound this thing.

00:09:14.900 --> 00:09:16.060
We render to it.

00:09:16.060 --> 00:09:18.840
Again, SDK, we're about to
push it out to the screen.

00:09:18.840 --> 00:09:20.285
And then you call
DistortOffscreen

00:09:20.285 --> 00:09:22.265
FramebufferToScreen.

00:09:22.265 --> 00:09:23.770
And you say, OK.

00:09:23.770 --> 00:09:25.130
I made an offscreen framebuffer.

00:09:25.130 --> 00:09:26.320
I rendered to it.

00:09:26.320 --> 00:09:29.387
Now distort it, which
means do lens correction.

00:09:29.387 --> 00:09:30.970
If you're not familiar
with that idea,

00:09:30.970 --> 00:09:35.364
it's basically-- when you view
a virtual world through lenses,

00:09:35.364 --> 00:09:37.030
really you're looking
at a screen that's

00:09:37.030 --> 00:09:38.590
just inches from your eyes.

00:09:38.590 --> 00:09:41.510
But you feel like you're looking
out on an entire virtual space.

00:09:41.510 --> 00:09:43.681
The virtual view distance
is different than

00:09:43.681 --> 00:09:44.805
the physical view distance.

00:09:44.805 --> 00:09:47.070
And it's lenses that
make that possible.

00:09:47.070 --> 00:09:50.230
But those same lenses that
let you see the screen

00:09:50.230 --> 00:09:53.690
and feel like you're looking
on a world warp the image.

00:09:53.690 --> 00:09:56.630
And so we actually have to do
a counter distortion, which

00:09:56.630 --> 00:09:58.770
is based on the optical
properties of the lens,

00:09:58.770 --> 00:10:01.020
so that you don't see all
straight lines looking

00:10:01.020 --> 00:10:02.680
curved through the lenses.

00:10:02.680 --> 00:10:04.139
So this
DistortOffscreenFramebuffer

00:10:04.139 --> 00:10:06.013
is going to take care
of that lens distortion

00:10:06.013 --> 00:10:08.150
for us using the undistorted
perspective that we've

00:10:08.150 --> 00:10:09.290
provided.

00:10:09.290 --> 00:10:11.217
So we have our stereo screen.

00:10:11.217 --> 00:10:12.550
That winds up getting distorted.

00:10:12.550 --> 00:10:13.590
And if you actually
look at your screen,

00:10:13.590 --> 00:10:15.423
you'll see it's kind
of vignetted and warped

00:10:15.423 --> 00:10:18.710
as we've done this
barrel distortion on it.

00:10:18.710 --> 00:10:22.080
And then we're going to want
to do one more thing here,

00:10:22.080 --> 00:10:25.060
which is-- there's a
technique that we use called

00:10:25.060 --> 00:10:29.260
async reprojection where if you
think about what's happened--

00:10:29.260 --> 00:10:32.830
where you called GetHeadPose
and you did some rendering

00:10:32.830 --> 00:10:34.980
and then we said, hey,
GPU, go do this thing,

00:10:34.980 --> 00:10:36.410
some time has elapsed.

00:10:36.410 --> 00:10:39.210
It may be only milliseconds
that have elapsed,

00:10:39.210 --> 00:10:42.520
but probably their heads
have moved a little bit more

00:10:42.520 --> 00:10:45.410
just in the time it took you
to render both of those eyes.

00:10:45.410 --> 00:10:48.740
And so what we do as part of
our distortion and presentation

00:10:48.740 --> 00:10:52.375
pass is we take your scene and
we shift it just a little more.

00:10:52.375 --> 00:10:54.840
At the last possible second,
we get the very latest head

00:10:54.840 --> 00:10:57.110
position and warp again.

00:10:57.110 --> 00:11:00.370
And that way it further
reduces the sense of latency

00:11:00.370 --> 00:11:04.070
that users feel as they're
looking around the world.

00:11:04.070 --> 00:11:06.170
And then finally
with that shifted

00:11:06.170 --> 00:11:09.940
and corrected reprojected view,
we push that to the scene.

00:11:09.940 --> 00:11:12.419
And that's what you see
on your phone-- except

00:11:12.419 --> 00:11:13.210
actually not quite.

00:11:13.210 --> 00:11:14.770
We're not quite done yet.

00:11:14.770 --> 00:11:16.980
So the other thing
that's really important

00:11:16.980 --> 00:11:19.820
is that if we just
naively took that view

00:11:19.820 --> 00:11:21.630
and rendered it
to the screen, you

00:11:21.630 --> 00:11:24.690
would get tearing because the
screen is actually refreshing.

00:11:24.690 --> 00:11:27.340
It's being rescanned over
and over and over again.

00:11:27.340 --> 00:11:29.824
If you have a single block of
memory that's being scanned,

00:11:29.824 --> 00:11:31.240
and you just sort
of write blindly

00:11:31.240 --> 00:11:33.100
into that block
of memory, you're

00:11:33.100 --> 00:11:34.800
going to see ripping
on the screen.

00:11:34.800 --> 00:11:37.260
You'll overwrite maybe
part of the screen

00:11:37.260 --> 00:11:38.630
as it's being updated.

00:11:38.630 --> 00:11:41.440
And it's really unsettling,
especially in VR.

00:11:41.440 --> 00:11:44.924
So in order to update
the scene right away

00:11:44.924 --> 00:11:46.340
but do it without
tearing, we have

00:11:46.340 --> 00:11:48.590
to enable a feature
called ScanlineRacing.

00:11:48.590 --> 00:11:50.270
And what ScanlineRacing
does is we

00:11:50.270 --> 00:11:53.810
know exactly where the
scanline is in the display,

00:11:53.810 --> 00:11:56.570
and we make sure that we
update right behind it

00:11:56.570 --> 00:11:58.687
so that it kind of
looks like this.

00:11:58.687 --> 00:12:00.270
But basically, we
make sure that we're

00:12:00.270 --> 00:12:03.610
updating slices of the
display just in time for them

00:12:03.610 --> 00:12:04.690
to be scanned out.

00:12:04.690 --> 00:12:07.110
And when you get all that
timing exactly right,

00:12:07.110 --> 00:12:08.540
you have the
minimum latency that

00:12:08.540 --> 00:12:11.516
allows you to draw it
directly to the front buffer.

00:12:11.516 --> 00:12:12.890
And that's kind
of cool, I think.

00:12:12.890 --> 00:12:14.460
Also, I really like
this animation.

00:12:14.460 --> 00:12:15.480
It's fun.

00:12:15.480 --> 00:12:16.990
It's like so many
programmer hours

00:12:16.990 --> 00:12:19.120
to make that animated
GIF a reality.

00:12:19.120 --> 00:12:20.584
[LAUGHING]

00:12:21.560 --> 00:12:24.450
So there's a couple more
things that you need to do.

00:12:24.450 --> 00:12:26.110
Basically, what we
just talked about,

00:12:26.110 --> 00:12:29.620
that gives you the fundamentals
of low latency rendering

00:12:29.620 --> 00:12:30.580
in Daydream.

00:12:30.580 --> 00:12:31.756
But we're not quite done.

00:12:31.756 --> 00:12:33.130
And if you just
did the previous,

00:12:33.130 --> 00:12:35.727
some things wouldn't quite work.

00:12:35.727 --> 00:12:38.310
Back to Java-- there's another
function that you need to call,

00:12:38.310 --> 00:12:41.740
which is setVRModeEnabled.

00:12:41.740 --> 00:12:45.914
This is basically saying, hey,
Android OS, turn on VR mode.

00:12:45.914 --> 00:12:48.330
And when you do that, some
really important things happen.

00:12:48.330 --> 00:12:51.810
The whole Android N VR
mode stack comes alive.

00:12:51.810 --> 00:12:54.506
A lot of functions turn on
or allow you to turn them

00:12:54.506 --> 00:12:55.630
on because you've said, OK.

00:12:55.630 --> 00:12:56.730
We're in VR mode.

00:12:56.730 --> 00:12:59.300
And it's even a cue for things
like, oh, notifications should

00:12:59.300 --> 00:13:00.635
no longer be rendered in mono.

00:13:00.635 --> 00:13:02.670
They need to be
rendered in stereo

00:13:02.670 --> 00:13:05.740
because we're telling the
machine that the user's now

00:13:05.740 --> 00:13:07.460
in VR.

00:13:07.460 --> 00:13:12.070
Also, the Daydream controller
requires that VR mode flag.

00:13:12.070 --> 00:13:14.070
So if you want input,
you have to be like, hey.

00:13:14.070 --> 00:13:14.625
I'm in VR.

00:13:14.625 --> 00:13:16.750
Otherwise we won't talk to
the controller and waste

00:13:16.750 --> 00:13:18.590
battery on it.

00:13:18.590 --> 00:13:22.100
So the last thing is you want
to enable sustained performance

00:13:22.100 --> 00:13:22.880
mode.

00:13:22.880 --> 00:13:25.810
And really one of the other
challenges of smartphone VR

00:13:25.810 --> 00:13:29.214
is that we're not just trying
to do low latency rendering.

00:13:29.214 --> 00:13:31.630
We're trying to do it in a
sustained fashion in a way that

00:13:31.630 --> 00:13:35.180
works on a phone for
minutes, tens of minutes,

00:13:35.180 --> 00:13:37.180
hours at a time.

00:13:37.180 --> 00:13:39.300
And what sustained
performance mode does

00:13:39.300 --> 00:13:41.464
is it actually
manages the hardware.

00:13:41.464 --> 00:13:43.380
If you're not familiar
with the details of how

00:13:43.380 --> 00:13:45.790
phone hardware is designed,
most phone interactions

00:13:45.790 --> 00:13:46.582
are very bursty.

00:13:46.582 --> 00:13:48.540
The phones in your pocket,
it's not doing much,

00:13:48.540 --> 00:13:49.685
just waiting for a call.

00:13:49.685 --> 00:13:50.560
Then you pull it out.

00:13:50.560 --> 00:13:51.260
You unlock it.

00:13:51.260 --> 00:13:52.436
You check your email.

00:13:52.436 --> 00:13:54.310
You browse the web, and
then you put it away.

00:13:54.310 --> 00:13:56.560
And so the phone wants to
kind of turn on and go burst

00:13:56.560 --> 00:13:59.380
when you launch your web
browser and then back off again.

00:13:59.380 --> 00:14:04.570
Well for VR, we're running
really hot, really hard.

00:14:04.570 --> 00:14:08.440
This is sustained stereo
60 hertz rendering.

00:14:08.440 --> 00:14:11.670
But if the phone was allowed
to run at its peak speed,

00:14:11.670 --> 00:14:13.170
it would actually
generate more heat

00:14:13.170 --> 00:14:14.710
than the phone can dissipate.

00:14:14.710 --> 00:14:17.760
And so sustained performance
mode tells the OS, hey.

00:14:17.760 --> 00:14:20.860
Manage your CPU and GPU
a little bit differently.

00:14:20.860 --> 00:14:23.150
Run at a lower
peak speed in order

00:14:23.150 --> 00:14:27.740
to maintain your throughput
for a longer period of time.

00:14:27.740 --> 00:14:31.490
Last thing you need to do is--
in your AndroidManifest.xml,

00:14:31.490 --> 00:14:32.740
there's two tags.

00:14:32.740 --> 00:14:35.950
The first is the VR
mode tag, and the second

00:14:35.950 --> 00:14:38.250
is the VR high performance tag.

00:14:38.250 --> 00:14:39.410
VR mode is a permission.

00:14:39.410 --> 00:14:41.780
You're saying, hey, I need
to be able to have access

00:14:41.780 --> 00:14:44.120
to VR mode in my app.

00:14:44.120 --> 00:14:47.320
And then the high performance,
it's basically like,

00:14:47.320 --> 00:14:49.320
I am a Daydream app.

00:14:49.320 --> 00:14:51.110
I can take advantage
of the Daydream API.

00:14:55.340 --> 00:14:57.910
You can set this required
flag to either true or false.

00:14:57.910 --> 00:15:01.820
If you set it to false, it
means that maybe I'm actually

00:15:01.820 --> 00:15:04.300
also a traditional
app with a Daydream

00:15:04.300 --> 00:15:06.710
mode in a self-contained
VR environment.

00:15:06.710 --> 00:15:10.470
So I don't require Daydream
for my app to be installed,

00:15:10.470 --> 00:15:12.390
but I'll benefit
from it if it is.

00:15:12.390 --> 00:15:14.000
However, you're saying, no.

00:15:14.000 --> 00:15:15.580
I'm building a
Daydream only app,

00:15:15.580 --> 00:15:17.750
and I only want it to
be available to users

00:15:17.750 --> 00:15:19.247
with Daydream ready phones.

00:15:19.247 --> 00:15:21.330
You want to set that high
performance tag to true.

00:15:21.330 --> 00:15:26.170
You're saying, I require this
to exist for my app to run.

00:15:26.170 --> 00:15:29.520
So a lot of you probably
think oh, that's great.

00:15:29.520 --> 00:15:31.710
All the C++, I'm glad
that I understand it,

00:15:31.710 --> 00:15:32.550
but I don't do that.

00:15:32.550 --> 00:15:34.140
I use game engines.

00:15:34.140 --> 00:15:36.630
And that's why we're
doing native integrations

00:15:36.630 --> 00:15:39.480
with both Unity and Unreal,
the two most popular game

00:15:39.480 --> 00:15:41.760
engines for VR development.

00:15:41.760 --> 00:15:43.830
And what these native
integrations actually

00:15:43.830 --> 00:15:47.042
are using the same NDK
that you have access to

00:15:47.042 --> 00:15:49.250
and actually incorporating
most of the same functions

00:15:49.250 --> 00:15:51.749
I've just shared with you, but
into these large professional

00:15:51.749 --> 00:15:53.660
code bases and
making sure that it's

00:15:53.660 --> 00:15:56.690
bubbled up through the ecosystem
and settings and all of that.

00:15:56.690 --> 00:15:59.462
So if you're a Unity developer,
we have a plugin available

00:15:59.462 --> 00:16:01.420
right now, but it doesn't
take advantage of all

00:16:01.420 --> 00:16:02.610
the Daydream optimizations.

00:16:02.610 --> 00:16:05.372
That won't happen until the
native integration this summer.

00:16:05.372 --> 00:16:06.830
For Unreal, that
native integration

00:16:06.830 --> 00:16:12.150
is available right now in
the 4.12 developer preview.

00:16:12.150 --> 00:16:14.430
So I'm going to talk more
broadly about performance--

00:16:14.430 --> 00:16:16.763
things that you want to be
thinking about whether you're

00:16:16.763 --> 00:16:20.070
writing your own engine or
using a game engine that's

00:16:20.070 --> 00:16:22.220
commercially available.

00:16:22.220 --> 00:16:24.290
So when we talk
about performance,

00:16:24.290 --> 00:16:26.260
there's a tendency
to think mostly

00:16:26.260 --> 00:16:28.150
about polygons and pixels.

00:16:28.150 --> 00:16:32.070
You're like, oh, is my
character too high polygon?

00:16:32.070 --> 00:16:35.000
But the thing you actually need
to think most about when you're

00:16:35.000 --> 00:16:38.700
talking about performance
on smartphones is thermals,

00:16:38.700 --> 00:16:39.690
is heat.

00:16:39.690 --> 00:16:43.240
Like I said, your phone is
capable of producing more heat

00:16:43.240 --> 00:16:47.250
than it can dissipate if it runs
at its absolute maximum speed.

00:16:47.250 --> 00:16:49.660
And phone SOCs are
designed that if they ever

00:16:49.660 --> 00:16:52.361
generate too much heat, they'll
actually throttle themselves

00:16:52.361 --> 00:16:52.860
back.

00:16:52.860 --> 00:16:54.026
They'll slow down.

00:16:54.026 --> 00:16:55.400
In fact, they'll
slow down a lot.

00:16:55.400 --> 00:16:58.210
They'll hit the brakes to cool
down enough that they can then

00:16:58.210 --> 00:16:59.600
speed back up again.

00:16:59.600 --> 00:17:02.034
And if you're in VR, you
don't want that to happen.

00:17:02.034 --> 00:17:03.950
You don't want to be
running at one frame rate

00:17:03.950 --> 00:17:06.052
and then slow way down
and then come back.

00:17:06.052 --> 00:17:08.010
That's like sitting in
a car that's speeding up

00:17:08.010 --> 00:17:08.750
and slowing down.

00:17:08.750 --> 00:17:11.220
We want smooth,
steady frame rate.

00:17:11.220 --> 00:17:15.380
And that's much more a function
of thermals then of raw pixel

00:17:15.380 --> 00:17:18.510
count or polygon count.

00:17:18.510 --> 00:17:20.630
The other thing to think
about is recognizing

00:17:20.630 --> 00:17:23.579
that both the CPU
and the GPU generate

00:17:23.579 --> 00:17:26.619
heat, as is all the
interconnects between them,

00:17:26.619 --> 00:17:28.860
system memory,
all of that stuff.

00:17:28.860 --> 00:17:31.190
And the CPU and the GPU
are on the same diode.

00:17:31.190 --> 00:17:32.830
They're very close
to one another.

00:17:32.830 --> 00:17:36.580
So if you're generating a
lot of heat from the CPU,

00:17:36.580 --> 00:17:39.090
that will affect the thermal
budget available to the GPU.

00:17:39.090 --> 00:17:41.470
Similarly, if you optimize
things on the GPU,

00:17:41.470 --> 00:17:43.394
it'll make the
whole system cooler.

00:17:43.394 --> 00:17:45.060
So remember that
you're thinking through

00:17:45.060 --> 00:17:46.957
a self-contained package.

00:17:46.957 --> 00:17:48.540
And it's a whole
ecosystem that you're

00:17:48.540 --> 00:17:51.270
optimizing for and thinking
about the thermal profile of,

00:17:51.270 --> 00:17:53.616
not this sort of abstract
and interdependent parts,

00:17:53.616 --> 00:17:54.990
though you might
think about them

00:17:54.990 --> 00:17:58.170
on a console or a desktop PC.

00:17:58.170 --> 00:18:00.720
One of the most basic
optimizations on the CPU side

00:18:00.720 --> 00:18:03.550
that should be thinking about
are batch counts or what

00:18:03.550 --> 00:18:05.100
some people call draw calls.

00:18:05.100 --> 00:18:07.590
Every 3D object
in your scene has

00:18:07.590 --> 00:18:11.230
to be processed by the CPU,
handed off to the driver,

00:18:11.230 --> 00:18:13.290
in order for the
GPU to render it.

00:18:13.290 --> 00:18:14.620
And that of course, takes work.

00:18:14.620 --> 00:18:16.820
It takes computing, sometimes
quite a bit of work,

00:18:16.820 --> 00:18:19.040
to prep that geometry
and send it down.

00:18:19.040 --> 00:18:21.910
In fact, when you profile
a lot of your apps,

00:18:21.910 --> 00:18:24.690
one of those common bottlenecks
is that they're CPU-bound,

00:18:24.690 --> 00:18:26.940
simply trying to feed the GPU.

00:18:26.940 --> 00:18:28.840
This is the reason
APIs like Vulcan

00:18:28.840 --> 00:18:31.690
exists, is to lower
that overhead.

00:18:31.690 --> 00:18:34.020
If you're targeting
Daydream, especially

00:18:34.020 --> 00:18:36.720
in sort of this year frame,
our somewhat conservative

00:18:36.720 --> 00:18:38.210
recommendation is
that you target

00:18:38.210 --> 00:18:40.740
100 batches, 100
draw calls, per eye,

00:18:40.740 --> 00:18:42.897
or about 200 batches per scene.

00:18:42.897 --> 00:18:44.980
You may find that for some
games, you can do more,

00:18:44.980 --> 00:18:46.700
or for some apps
you can do less.

00:18:46.700 --> 00:18:48.989
Engines, code bases,
all that stuff varies.

00:18:48.989 --> 00:18:50.655
But to give you a
very basic bottleneck,

00:18:50.655 --> 00:18:53.770
it's something to think about.

00:18:53.770 --> 00:18:56.314
Another way to actually
reduce your batch count

00:18:56.314 --> 00:18:57.730
and run more
efficiently generally

00:18:57.730 --> 00:19:00.032
is to bake everything
that you can.

00:19:00.032 --> 00:19:01.490
Anything that's
static that doesn't

00:19:01.490 --> 00:19:04.870
need to be computed
dynamically, compute statically.

00:19:04.870 --> 00:19:08.210
So one great example is you
want to combine local instances

00:19:08.210 --> 00:19:09.690
of static geometry.

00:19:09.690 --> 00:19:12.220
For example, there's three
rocks on the ground there.

00:19:12.220 --> 00:19:15.100
And they're the same rock model,
just rotate with one another.

00:19:15.100 --> 00:19:17.370
And normally, if you
just place each of them,

00:19:17.370 --> 00:19:20.530
that's three draw calls,
one for each rock.

00:19:20.530 --> 00:19:23.510
But it's often for VR
a good optimization

00:19:23.510 --> 00:19:27.340
to combine them
into a single mesh.

00:19:27.340 --> 00:19:30.040
Of course it's more polys,
but you're saving batch count.

00:19:30.040 --> 00:19:31.880
And you're really not
rendering much more.

00:19:31.880 --> 00:19:33.820
You still have to render all
three rocks from the GPU's

00:19:33.820 --> 00:19:35.736
perspective, but the
fact that you submit them

00:19:35.736 --> 00:19:37.440
once is a lot more efficient.

00:19:37.440 --> 00:19:40.170
And engines like
Unreal and Unity

00:19:40.170 --> 00:19:43.750
have built-in optimizations
called static batching in Unity

00:19:43.750 --> 00:19:46.680
or actor merging in Unreal.

00:19:46.680 --> 00:19:48.860
And those are great ways
to take content, author it

00:19:48.860 --> 00:19:52.780
in a normal way, but then crank
down the number of batches.

00:19:52.780 --> 00:19:55.430
Light mapping looks fantastic.

00:19:55.430 --> 00:19:58.510
It takes some memory, but
memory is relatively cheaper

00:19:58.510 --> 00:20:01.230
in terms of you have a lot of
memory on these modern devices.

00:20:01.230 --> 00:20:05.140
So doing high-fidelity
lighting calculations offline

00:20:05.140 --> 00:20:07.820
and baking them totally helps.

00:20:07.820 --> 00:20:10.310
One other really
clever trick-- if you

00:20:10.310 --> 00:20:13.380
have control of your camera, if
you're in a fixed environment--

00:20:13.380 --> 00:20:17.660
is past a certain distance,
the stereo effect kind of

00:20:17.660 --> 00:20:18.820
goes away.

00:20:18.820 --> 00:20:21.590
And so if you can pre-render
your backgrounds-- render them

00:20:21.590 --> 00:20:26.840
into an ODS, a 360 stereo
pano or mono pano--

00:20:26.840 --> 00:20:29.765
you can just blit that right
to the screen like a sky box.

00:20:29.765 --> 00:20:31.390
To the user, it will
look just as real,

00:20:31.390 --> 00:20:34.582
and you'll save
yourself a ton of time.

00:20:34.582 --> 00:20:36.290
One of the things you
really, really want

00:20:36.290 --> 00:20:41.150
to be thoughtful about
is the bus, basically

00:20:41.150 --> 00:20:44.089
the circuitry that transfers
data around the SOC.

00:20:44.089 --> 00:20:46.630
This is one of these things that
you tend not to think about.

00:20:46.630 --> 00:20:47.520
Like, oh, there's memory.

00:20:47.520 --> 00:20:48.660
And it's accessed randomly.

00:20:48.660 --> 00:20:49.610
And it's fast.

00:20:49.610 --> 00:20:52.290
But actually, one of the
most energy consuming

00:20:52.290 --> 00:20:55.860
operations on the SOC is
just reading and writing

00:20:55.860 --> 00:20:56.912
for main memory.

00:20:56.912 --> 00:20:59.120
And of course, when you're
talking about framebuffers

00:20:59.120 --> 00:21:02.790
that are 1080p 1440p,
that's like a lot of pixels

00:21:02.790 --> 00:21:03.430
to move around.

00:21:03.430 --> 00:21:06.040
Textures that are 4K
by 4K-- all of that

00:21:06.040 --> 00:21:09.090
is data that has to be shuttled
back and forth from main memory

00:21:09.090 --> 00:21:11.190
to the GPU and back again.

00:21:11.190 --> 00:21:15.540
So some ways that you can manage
the amount of traffic you're

00:21:15.540 --> 00:21:17.570
putting on the bus--
the first one is you

00:21:17.570 --> 00:21:20.000
can actually tweak the
offscreen render texture size.

00:21:20.000 --> 00:21:21.958
Remember I said we need
that original function.

00:21:21.958 --> 00:21:24.440
We said, hey, give me the
idealized offscreen target

00:21:24.440 --> 00:21:25.279
size.

00:21:25.279 --> 00:21:26.320
That's just a suggestion.

00:21:26.320 --> 00:21:28.600
You may find that for your
particular application

00:21:28.600 --> 00:21:32.100
you can run much
smaller or much larger.

00:21:32.100 --> 00:21:33.400
So iterate with that.

00:21:33.400 --> 00:21:36.565
See what is the right balance
of performance and fidelity.

00:21:36.565 --> 00:21:38.940
This is one of the biggest
kind of constant optimizations

00:21:38.940 --> 00:21:41.100
you can make to your app.

00:21:41.100 --> 00:21:45.140
You always want to use
compressed textures.

00:21:45.140 --> 00:21:46.810
A lot of mobile
developers are used

00:21:46.810 --> 00:21:48.340
to not compressing
textures because maybe you

00:21:48.340 --> 00:21:50.798
don't have that many of them,
you don't like the artifacts.

00:21:50.798 --> 00:21:52.690
But in 3-D, you want
to compress things.

00:21:52.690 --> 00:21:58.250
And Daydream ready phones have
all the latest ETC2, really,

00:21:58.250 --> 00:21:59.860
really good texture compression.

00:21:59.860 --> 00:22:01.740
So take advantage of it.

00:22:01.740 --> 00:22:04.070
It will save you a
tremendous amount

00:22:04.070 --> 00:22:05.687
of bus bandwidth and energy.

00:22:05.687 --> 00:22:07.270
And then the last
thing you need to do

00:22:07.270 --> 00:22:09.640
is avoid full screen passes.

00:22:09.640 --> 00:22:12.990
A very common pattern on
desktop and on console

00:22:12.990 --> 00:22:14.710
is you render your
scene, and then

00:22:14.710 --> 00:22:17.032
you have another
pass for shadows

00:22:17.032 --> 00:22:19.880
and another pass for bloom
and then depth of field

00:22:19.880 --> 00:22:21.830
and then vignetting.

00:22:21.830 --> 00:22:24.170
On a phone, each of
those full-screen passes

00:22:24.170 --> 00:22:26.530
usually means reading
from the main framebuffer

00:22:26.530 --> 00:22:28.580
and writing back to
the main framebuffer.

00:22:28.580 --> 00:22:32.480
It's like millions of pixels
back and forth across the bus.

00:22:32.480 --> 00:22:36.820
Instead, what you want to do is
be very judicious-- basically

00:22:36.820 --> 00:22:39.830
don't do full screen passes but
build them into your shaders

00:22:39.830 --> 00:22:41.020
to the extent you need
to do them at all.

00:22:41.020 --> 00:22:43.103
So something like tone
mapping, where maybe you're

00:22:43.103 --> 00:22:45.550
going from HDR down to LDR.

00:22:45.550 --> 00:22:48.370
Try to do that actually at
the end of your pixel shader

00:22:48.370 --> 00:22:50.810
so that you only have to read
and write to the framebuffer

00:22:50.810 --> 00:22:53.160
once.

00:22:53.160 --> 00:22:55.890
In general, though, you want
to prefer the vertex shader

00:22:55.890 --> 00:22:57.540
to the pixel shader.

00:22:57.540 --> 00:23:00.060
Modern GPU's are homogeneous.

00:23:00.060 --> 00:23:02.740
Whether they're processing
verts or processing pixels,

00:23:02.740 --> 00:23:04.100
they don't matter too much.

00:23:04.100 --> 00:23:06.570
They will do whatever
you tell them to do.

00:23:06.570 --> 00:23:09.760
But there's often 20x
fewer vertices onscreen

00:23:09.760 --> 00:23:11.610
than there are pixels onscreen.

00:23:11.610 --> 00:23:13.350
And so if you can do
something per vertex

00:23:13.350 --> 00:23:16.350
rather than per pixel, that's
a 20x reduction in the amount

00:23:16.350 --> 00:23:18.440
of compute the GPU has to do.

00:23:18.440 --> 00:23:21.569
And so really, when you look
at your shaders, get involved,

00:23:21.569 --> 00:23:23.360
understand what they're
doing, and anything

00:23:23.360 --> 00:23:26.310
you can move to be per
vertex and interpolated--

00:23:26.310 --> 00:23:28.420
even if it's not
quite as perfect--

00:23:28.420 --> 00:23:32.190
is probably a giant win
in compute and in thermal.

00:23:32.190 --> 00:23:33.820
And in general, you
can target-- again,

00:23:33.820 --> 00:23:36.510
a little bit conservatively--
about 100,000 verts per eye

00:23:36.510 --> 00:23:37.829
or 200,000 verts per frame.

00:23:37.829 --> 00:23:39.870
Now I should mentioned
these budgets are assuming

00:23:39.870 --> 00:23:40.850
you're rendering at 60.

00:23:40.850 --> 00:23:43.391
If you're rendering at 30, which
I'll talk about in a second,

00:23:43.391 --> 00:23:45.260
you've got a little
bit more headroom.

00:23:45.260 --> 00:23:47.170
In fact, this is
the other thing--

00:23:47.170 --> 00:23:50.160
because we have
async reprojection,

00:23:50.160 --> 00:23:52.650
we will actually
update the displays

00:23:52.650 --> 00:23:56.100
at 60 hertz-- even if you're
rendering much slower,

00:23:56.100 --> 00:23:57.540
we will keep
updating the display

00:23:57.540 --> 00:24:00.670
to the best of our ability using
async reprojection to correct

00:24:00.670 --> 00:24:02.270
for the user's head movement.

00:24:02.270 --> 00:24:07.850
So apps will look best when
you also render at 60 hertz,

00:24:07.850 --> 00:24:09.370
but you can render
at lower rates.

00:24:09.370 --> 00:24:10.930
You can render at 30 hertz.

00:24:10.930 --> 00:24:12.890
And what you'll see is
you'll render a frame

00:24:12.890 --> 00:24:14.392
and then we'll
output two frames.

00:24:14.392 --> 00:24:16.100
And depending on the
app you're building,

00:24:16.100 --> 00:24:18.440
that can look totally natural.

00:24:18.440 --> 00:24:21.350
The most key thing, no matter
what frame rate you target,

00:24:21.350 --> 00:24:25.060
is to pick a frame
rate and stick to it.

00:24:25.060 --> 00:24:29.963
If you're going from 20 to 50 to
30 to 40, users can feel that.

00:24:29.963 --> 00:24:32.010
And it will feel unsettling.

00:24:32.010 --> 00:24:34.774
So a stable frame rate no matter
what you do is really key.

00:24:34.774 --> 00:24:36.190
I'd recommend for
most developers,

00:24:36.190 --> 00:24:38.210
especially early on,
try different things.

00:24:38.210 --> 00:24:38.880
Evaluate.

00:24:38.880 --> 00:24:39.830
Experiment.

00:24:39.830 --> 00:24:42.440
Don't lock in early on,
at least not until you've

00:24:42.440 --> 00:24:43.920
done those experiments.

00:24:43.920 --> 00:24:46.780
If you are rendering
at 30 hertz,

00:24:46.780 --> 00:24:48.480
it's really tempting
to then spend

00:24:48.480 --> 00:24:50.830
33 milliseconds on rendering.

00:24:50.830 --> 00:24:53.540
But actually, if you're
running at 30 hertz,

00:24:53.540 --> 00:24:56.960
you want to do that to save
power, to save energy output.

00:24:56.960 --> 00:25:00.710
So actually use less than
33 milliseconds of compute.

00:25:00.710 --> 00:25:02.720
Let the phone cool down a bit.

00:25:02.720 --> 00:25:05.680
So if use 20 milliseconds,
it's still more than the 16

00:25:05.680 --> 00:25:09.040
you get from 60 hertz
rendering, but think

00:25:09.040 --> 00:25:10.520
of that as a
power-saving strategy,

00:25:10.520 --> 00:25:14.150
not just a way to spend
twice as much time rendering.

00:25:14.150 --> 00:25:17.100
And lastly, profile,
profile, profile.

00:25:17.100 --> 00:25:19.410
One of the awesome
things about Daydream

00:25:19.410 --> 00:25:21.660
is that it's on
Android, and you get

00:25:21.660 --> 00:25:23.270
the benefits of
the entire Android

00:25:23.270 --> 00:25:25.460
ecosystem for profiling--
Android Studios,

00:25:25.460 --> 00:25:28.810
GPU profiling into bugging,
Qualcomm's profilers,

00:25:28.810 --> 00:25:30.290
Nvidia's profile-- sorry.

00:25:30.290 --> 00:25:33.200
Qualcomm gets an additional
Daydream hardware.

00:25:33.200 --> 00:25:37.840
And you also get so much
just out of the box.

00:25:37.840 --> 00:25:40.090
You get Unity and
Unreal's profilers.

00:25:40.090 --> 00:25:43.390
If you write your own engines,
all of that sort of stuff

00:25:43.390 --> 00:25:46.800
is really, really
available and powerful.

00:25:46.800 --> 00:25:52.020
The last thing I want to
mention is make it a habit.

00:25:52.020 --> 00:25:55.090
Be thoughtful about this
in your team's workflow.

00:25:55.090 --> 00:26:00.030
It's natural for teams to think
that they're going to just--

00:26:00.030 --> 00:26:02.530
OK, I'm going to do my app.

00:26:02.530 --> 00:26:04.740
And I'll figure out
performance later on.

00:26:04.740 --> 00:26:06.410
But that's brutal.

00:26:06.410 --> 00:26:08.470
Super brutal.

00:26:08.470 --> 00:26:12.030
You're leaving a lot of hard
work to the end of development.

00:26:12.030 --> 00:26:13.940
What you want to do in
VR because performance

00:26:13.940 --> 00:26:16.890
is critical, make it part
of your team culture.

00:26:16.890 --> 00:26:19.470
Make it something you do
every day, twice a day.

00:26:19.470 --> 00:26:21.360
Have a performance
cop every week

00:26:21.360 --> 00:26:23.714
that rotates and is looking
at how things are running.

00:26:23.714 --> 00:26:25.880
Because if you don't stay
on top of your performance

00:26:25.880 --> 00:26:28.890
and your thermal
output, you're going

00:26:28.890 --> 00:26:31.984
to be in trouble
later on in the game.

00:26:31.984 --> 00:26:33.400
Last thing I want
to talk about is

00:26:33.400 --> 00:26:37.140
audio, which I think is kind of
an unappreciated element of VR

00:26:37.140 --> 00:26:40.790
in general and especially
on smartphones.

00:26:40.790 --> 00:26:42.910
There's this a quote I
love from Martin O'Donnell,

00:26:42.910 --> 00:26:46.000
the composer of the
original "Halo" series.

00:26:46.000 --> 00:26:49.780
He said, "Music makes you
feel; sound makes it real".

00:26:49.780 --> 00:26:51.740
And there's no
more true statement

00:26:51.740 --> 00:26:54.000
I've heard about audio
design than that.

00:26:54.000 --> 00:26:56.670
You can create a tremendous
amount of emotion

00:26:56.670 --> 00:27:00.310
and a tremendous amount of
presence just through audio.

00:27:00.310 --> 00:27:04.680
And if you think about
watts per immersion,

00:27:04.680 --> 00:27:06.340
the amount you get
from processing

00:27:06.340 --> 00:27:08.050
audio versus processing
visuals, it's

00:27:08.050 --> 00:27:11.470
dramatically more efficient
what you can do with audio.

00:27:11.470 --> 00:27:14.092
So as an example, think
about rendering a tree

00:27:14.092 --> 00:27:16.050
or the-- you want to say,
well, there's a tree,

00:27:16.050 --> 00:27:18.840
and the wind is blowing through
it and rustling the leaves.

00:27:18.840 --> 00:27:21.650
Well, you can render all
the leaves on the tree

00:27:21.650 --> 00:27:23.400
and animate them as a
way of saying, look.

00:27:23.400 --> 00:27:25.700
The wind is blowing
through the tree.

00:27:25.700 --> 00:27:28.990
Or you can have a sound
effect of wind rustling

00:27:28.990 --> 00:27:31.290
and a much simpler
version of the tree,

00:27:31.290 --> 00:27:33.770
and users are going to find
them both very plausible.

00:27:33.770 --> 00:27:35.700
In fact, they'll
appreciate the sound more

00:27:35.700 --> 00:27:36.920
than just the pure visuals.

00:27:36.920 --> 00:27:39.460
And obviously, it's
dramatically cheaper

00:27:39.460 --> 00:27:42.150
to render a simplified tree--
perhaps not that simple--

00:27:42.150 --> 00:27:45.170
but a simplified tree with
audio than it is to render

00:27:45.170 --> 00:27:46.940
one very complicated object.

00:27:46.940 --> 00:27:48.940
And you can suggest
objects that aren't

00:27:48.940 --> 00:27:51.920
there, things in the distance
that-- oh, I heard a wolf.

00:27:51.920 --> 00:27:54.950
They must be out there-- without
rendering any wolves at all.

00:27:54.950 --> 00:27:57.310
And since our goal really
is to create presence,

00:27:57.310 --> 00:28:00.424
audio lets us do that really
creatively, really efficiently.

00:28:00.424 --> 00:28:02.590
And again, as mobile
developers, we tend to be like,

00:28:02.590 --> 00:28:04.200
oh, audio is the
last thing we do.

00:28:04.200 --> 00:28:06.200
Make it the first thing
you do or the second

00:28:06.200 --> 00:28:09.560
after you integrate the API.

00:28:09.560 --> 00:28:11.560
Two other things to think
about with audio-- one

00:28:11.560 --> 00:28:12.630
is spatial audio.

00:28:12.630 --> 00:28:14.400
Some people like
binaural rendering.

00:28:14.400 --> 00:28:16.900
We have technologies, and we
provide these with the Daydream

00:28:16.900 --> 00:28:20.600
SDK that let you use
headphones but get

00:28:20.600 --> 00:28:23.270
a sense of surround sound--
better than surround sound.

00:28:23.270 --> 00:28:25.840
We can give you a sense
of sound above you

00:28:25.840 --> 00:28:28.820
and below you, all around you.

00:28:28.820 --> 00:28:31.030
It's really, really compelling.

00:28:31.030 --> 00:28:32.990
And it makes you
feel much more--

00:28:32.990 --> 00:28:35.630
it's much more believable than
simple stereo panning, which

00:28:35.630 --> 00:28:38.080
is what you get by default.

00:28:38.080 --> 00:28:41.200
You also want to think about
the way the environment affects

00:28:41.200 --> 00:28:42.180
the audio.

00:28:42.180 --> 00:28:44.930
If you imagine a conversation
between two people,

00:28:44.930 --> 00:28:46.350
well, obviously
that conversation

00:28:46.350 --> 00:28:48.410
would sound very
different in a forest

00:28:48.410 --> 00:28:50.580
than it would sound
in a spaceship.

00:28:50.580 --> 00:28:52.870
And our SDK has tools
that let you actually

00:28:52.870 --> 00:28:55.100
specify the room that
you're in, the size,

00:28:55.100 --> 00:28:56.150
the physical materials.

00:28:56.150 --> 00:28:58.025
And it will process the
audio in a way that's

00:28:58.025 --> 00:29:01.470
believable for that space.

00:29:01.470 --> 00:29:03.810
So we've covered a lot today.

00:29:03.810 --> 00:29:06.382
Really to wrap
up, all of this is

00:29:06.382 --> 00:29:07.840
how you create a
sense of presence,

00:29:07.840 --> 00:29:10.620
how you get below that
20 milliseconds motion

00:29:10.620 --> 00:29:13.197
to photon latency.

00:29:13.197 --> 00:29:14.780
We hope that that
will help you create

00:29:14.780 --> 00:29:17.660
luscious, beautiful,
immersive, compelling VR

00:29:17.660 --> 00:29:20.580
experiences for Daydream.

00:29:20.580 --> 00:29:22.290
Thank you so much
for making the time.

00:29:22.290 --> 00:29:24.290
We have tons of resources
available online.

00:29:24.290 --> 00:29:26.099
There's the Google
Developer site,

00:29:26.099 --> 00:29:28.640
which has a subsection on how
you can build your own Daydream

00:29:28.640 --> 00:29:29.955
developer kit.

00:29:29.955 --> 00:29:32.080
We have the NDK decay where
all the code that we've

00:29:32.080 --> 00:29:34.280
talked about today comes from.

00:29:34.280 --> 00:29:36.450
And lastly, a giant
section on spatial audio.

00:29:36.450 --> 00:29:38.690
I've linked here to
our dev site page,

00:29:38.690 --> 00:29:41.160
but we also had a
full session dedicated

00:29:41.160 --> 00:29:43.850
to spatial audio
creation, technology.

00:29:43.850 --> 00:29:46.150
It was earlier today,
but check it out online.

00:29:46.150 --> 00:29:49.230
It'll be posted to the
main I/O channel later on.

00:29:49.230 --> 00:29:51.570
So thank you all very much.

00:29:51.570 --> 00:29:53.160
Thanks for being a
part of Daydream.

00:29:53.160 --> 00:29:56.030
And maybe you can make apps
about flipping pancakes

00:29:56.030 --> 00:29:56.681
on the beach.

00:29:56.681 --> 00:29:59.140
[APPLAUSE]

00:29:59.140 --> 00:29:59.650
Thank you.

00:30:02.950 --> 00:30:05.700
[MUSIC PLAYING]

