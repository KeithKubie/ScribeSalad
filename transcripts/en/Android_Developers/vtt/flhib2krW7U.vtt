WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.640
[MUSIC PLAYING]

00:00:03.520 --> 00:00:05.340
YAFIT BECHER: Wow.

00:00:05.340 --> 00:00:07.350
It's hard to believe
it's been only a year

00:00:07.350 --> 00:00:10.170
since we launched the
App Bundle here at I/O.

00:00:10.170 --> 00:00:12.890
And what an incredible
year it was.

00:00:12.890 --> 00:00:15.780
I'm Yafit Becher, a product
manager with the Play London

00:00:15.780 --> 00:00:16.292
team.

00:00:16.292 --> 00:00:18.500
MARTIN CHURCHILL: And I'm
Martin, a software engineer

00:00:18.500 --> 00:00:20.283
on Google Play in London.

00:00:20.283 --> 00:00:22.200
So today, we're going
to talk about what's new

00:00:22.200 --> 00:00:26.170
this year in the world
of Android app bundles.

00:00:26.170 --> 00:00:28.410
So many developers have
bought into our vision

00:00:28.410 --> 00:00:31.170
to optimize tailored delivery,
and have already migrated

00:00:31.170 --> 00:00:32.790
to the App Bundle.

00:00:32.790 --> 00:00:34.670
This includes some of
the most popular apps

00:00:34.670 --> 00:00:37.350
on Play seeing incredible
size savings, that

00:00:37.350 --> 00:00:40.680
range from around 10%
to 60% versus delivering

00:00:40.680 --> 00:00:42.620
a universal APK.

00:00:42.620 --> 00:00:44.370
We really couldn't
have hoped for a better

00:00:44.370 --> 00:00:48.720
acceptance of the App Bundle
among the developer community.

00:00:48.720 --> 00:00:50.950
And Google Apps are
migrating, as well.

00:00:50.950 --> 00:00:54.390
So this includes apps such
as Photos, Maps, and YouTube,

00:00:54.390 --> 00:00:56.550
which have dramatically
reduced their app size

00:00:56.550 --> 00:00:59.160
having switched to the Bundle.

00:00:59.160 --> 00:01:00.970
So how is this achieved?

00:01:00.970 --> 00:01:03.240
Let's take a look back,
and remind ourselves

00:01:03.240 --> 00:01:06.000
what the App Bundle is.

00:01:06.000 --> 00:01:08.910
So in essence, the App Bundle
is a new publishing format

00:01:08.910 --> 00:01:12.300
that replaces the
traditional monolithic APK.

00:01:12.300 --> 00:01:15.060
But the App Bundle is
not installed directly.

00:01:15.060 --> 00:01:19.200
Instead, Play generates APKs
optimized for specific devices

00:01:19.200 --> 00:01:21.450
from the single Bundle upload.

00:01:21.450 --> 00:01:24.450
These APKs are much smaller than
if the developer were to deploy

00:01:24.450 --> 00:01:26.430
a single APK for everyone.

00:01:26.430 --> 00:01:29.040
But the single upload provides
a much simpler developer

00:01:29.040 --> 00:01:33.030
experience than
uploading multiple APKs.

00:01:33.030 --> 00:01:34.810
So how does this work?

00:01:34.810 --> 00:01:36.720
So the smaller download
size is achieved

00:01:36.720 --> 00:01:38.910
by delivering only the
resources from the app

00:01:38.910 --> 00:01:41.640
that the specific devices need.

00:01:41.640 --> 00:01:43.530
Deploying a single
APK would result

00:01:43.530 --> 00:01:46.770
in all languages, densities,
and native architectures

00:01:46.770 --> 00:01:49.110
being delivered for
all the devices.

00:01:49.110 --> 00:01:51.300
But as we see here,
with the App Bundle,

00:01:51.300 --> 00:01:53.610
only the relevant
languages, densities,

00:01:53.610 --> 00:01:55.380
and native architectures
are delivered,

00:01:55.380 --> 00:01:58.110
yielding a smaller install
on the device and a faster

00:01:58.110 --> 00:02:00.550
download.

00:02:00.550 --> 00:02:03.720
So on average, the App
Bundle yields a 20% reduction

00:02:03.720 --> 00:02:05.070
in app size.

00:02:05.070 --> 00:02:06.780
This leads to faster
downloads, which

00:02:06.780 --> 00:02:10.380
leads to an 11% increase
in install successes,

00:02:10.380 --> 00:02:13.920
because there are fewer chances
for the download to fail.

00:02:13.920 --> 00:02:16.350
And, since less
disk space is used,

00:02:16.350 --> 00:02:20.220
it also leads to a
reduction in uninstalls.

00:02:20.220 --> 00:02:22.790
So since launch,
more than 80,000 apps

00:02:22.790 --> 00:02:25.130
have moved over
to the App Bundle.

00:02:25.130 --> 00:02:27.320
Those apps are now
publishing a single bundle,

00:02:27.320 --> 00:02:29.930
and relying on Play to
deliver smaller APKs

00:02:29.930 --> 00:02:32.180
to specific devices
tailored for them.

00:02:37.770 --> 00:02:39.670
YAFIT BECHER: But this
is just the beginning.

00:02:39.670 --> 00:02:41.220
The introduction
of the App Bundle

00:02:41.220 --> 00:02:44.640
opens the door for new and
exciting delivery features

00:02:44.640 --> 00:02:48.750
that simply wouldn't have
been possible before.

00:02:48.750 --> 00:02:50.520
With the App
Bundle, we can build

00:02:50.520 --> 00:02:53.070
towards a vision of
tailored delivery

00:02:53.070 --> 00:02:56.940
that optimizes all aspects
of your app serving--

00:02:56.940 --> 00:03:01.110
from which part of the app
to serve, to whom and when.

00:03:03.960 --> 00:03:06.550
In order to take the App
Bundle to the next level,

00:03:06.550 --> 00:03:09.580
we are giving you
greater control.

00:03:09.580 --> 00:03:11.910
And that's why our
main topic, today,

00:03:11.910 --> 00:03:16.260
is customizable delivery, which
puts you in control over how

00:03:16.260 --> 00:03:18.630
your app is being delivered.

00:03:18.630 --> 00:03:20.910
This will allow us
to fully realize

00:03:20.910 --> 00:03:24.030
the potential of the App
Bundle, as it's you who

00:03:24.030 --> 00:03:28.140
knows your app and users best.

00:03:28.140 --> 00:03:30.570
Today, we'll cover
four new product

00:03:30.570 --> 00:03:32.970
offerings that
demonstrate the concept

00:03:32.970 --> 00:03:35.610
of customizable delivery.

00:03:35.610 --> 00:03:39.360
In-app updates, that lets
you target updates directly

00:03:39.360 --> 00:03:41.100
from your app.

00:03:41.100 --> 00:03:43.920
Condition delivery, that
lets you choose which feature

00:03:43.920 --> 00:03:47.610
modules to deliver
to which devices.

00:03:47.610 --> 00:03:50.190
On-demand delivery, that
allows you to call for

00:03:50.190 --> 00:03:53.190
features only when
you need them.

00:03:53.190 --> 00:03:55.350
And asset delivery
for games, that

00:03:55.350 --> 00:03:58.340
expands the App Bundle to
include game content, letting

00:03:58.340 --> 00:04:02.010
you package your game assets
alongside your game binary,

00:04:02.010 --> 00:04:05.430
and publish a single
artifact to Play.

00:04:05.430 --> 00:04:08.190
We'll also talk about
internal app sharing,

00:04:08.190 --> 00:04:10.200
that gives you an
easy way to share

00:04:10.200 --> 00:04:14.230
test builds with your testers.

00:04:14.230 --> 00:04:16.990
Over to Martin, to talk
about in-app updates,

00:04:16.990 --> 00:04:19.500
our first product
offering for today.

00:04:19.500 --> 00:04:21.279
MARTIN CHURCHILL: Thanks, Yafit.

00:04:21.279 --> 00:04:23.860
So auto updates are really
great for seamlessly

00:04:23.860 --> 00:04:27.520
keeping your users up to date,
but not all users receive them.

00:04:27.520 --> 00:04:29.290
Some are never on Wi-Fi.

00:04:29.290 --> 00:04:32.350
Others may simply have
auto updates turned off.

00:04:32.350 --> 00:04:36.440
So some users end up using
old versions of the app.

00:04:36.440 --> 00:04:38.260
Now, this isn't
great for developers.

00:04:38.260 --> 00:04:40.060
For one thing, there
may be a critical bug

00:04:40.060 --> 00:04:43.210
fix that you really need to
get out to all your users,

00:04:43.210 --> 00:04:46.030
a new and strategic
feature you're rolling out,

00:04:46.030 --> 00:04:47.590
a multiplayer game
where you need

00:04:47.590 --> 00:04:50.440
to have all of your players on
the same version of the app,

00:04:50.440 --> 00:04:53.050
or perhaps you're simply looking
to ditch support for very

00:04:53.050 --> 00:04:55.390
old versions of the app.

00:04:55.390 --> 00:04:58.120
Now, in-app updates, which
we're launching today,

00:04:58.120 --> 00:05:00.820
gives you a way to trigger
updates of your app

00:05:00.820 --> 00:05:03.040
directly from your app.

00:05:03.040 --> 00:05:05.860
It gives you control over
the right contextual moment

00:05:05.860 --> 00:05:08.710
to start an update, while
keeping the user in the app

00:05:08.710 --> 00:05:11.790
and not risking
additional friction.

00:05:11.790 --> 00:05:14.200
So in-app updates
come in two flavors--

00:05:14.200 --> 00:05:17.110
an immediate flow that
triggers the update right away,

00:05:17.110 --> 00:05:19.300
requiring minimal integration.

00:05:19.300 --> 00:05:21.520
This is because Play
handles the user experience

00:05:21.520 --> 00:05:23.170
during the update.

00:05:23.170 --> 00:05:25.030
And a flexible
flow that lets you

00:05:25.030 --> 00:05:28.270
customize the user
experience during the update.

00:05:28.270 --> 00:05:30.190
This requires more
thinking and design work,

00:05:30.190 --> 00:05:33.010
but is ultimately much
more customizable.

00:05:33.010 --> 00:05:38.000
So let's take a look at both
of these flavors in action.

00:05:38.000 --> 00:05:40.720
So first, we'll take a look
at the immediate in-app update

00:05:40.720 --> 00:05:44.240
flow, with our sample
recipe finder app.

00:05:44.240 --> 00:05:47.260
So as we can see here, the
app triggers an update,

00:05:47.260 --> 00:05:49.360
and the user is kept
in a managed flow

00:05:49.360 --> 00:05:51.700
until the update finishes.

00:05:51.700 --> 00:05:55.060
So first, the user confirms that
they want to take the update,

00:05:55.060 --> 00:05:58.370
and the download size
is revealed to the user.

00:05:58.370 --> 00:06:00.820
Then the update is
downloaded, during which

00:06:00.820 --> 00:06:04.390
Play manages the user
experience as we see here.

00:06:04.390 --> 00:06:07.090
Once the update is downloaded
and ready for install,

00:06:07.090 --> 00:06:09.100
it is applied and
control is returned

00:06:09.100 --> 00:06:12.490
to the new, up-to-date,
shiny version of the app,

00:06:12.490 --> 00:06:15.790
and the user can continue
their journey inside the app.

00:06:15.790 --> 00:06:17.290
Now here, the
developer doesn't need

00:06:17.290 --> 00:06:19.390
to do anything beyond
the initial trigger

00:06:19.390 --> 00:06:22.090
of the update, which can happen
when the developer chooses.

00:06:24.720 --> 00:06:28.220
Now, some developers will want
more customizability than this.

00:06:28.220 --> 00:06:30.350
So here, we have Swiggy.

00:06:30.350 --> 00:06:32.990
Swiggy is a food delivery
app popular in India,

00:06:32.990 --> 00:06:35.270
with more than 10
million downloads.

00:06:35.270 --> 00:06:37.850
Now, many of their users
aren't regularly on Wi-Fi,

00:06:37.850 --> 00:06:40.280
and so can't benefit
from auto updates.

00:06:40.280 --> 00:06:42.200
But by using in-app
updates, they

00:06:42.200 --> 00:06:44.820
can prompt the user to update
while they're in the app,

00:06:44.820 --> 00:06:47.550
and they have the
user's attention.

00:06:47.550 --> 00:06:51.440
So as we see here, Swiggy have
incorporated a small alert icon

00:06:51.440 --> 00:06:54.950
that notifies the user that
the update is available.

00:06:54.950 --> 00:06:56.510
Then, when the
user investigates,

00:06:56.510 --> 00:06:58.010
they're prompted
with an opportunity

00:06:58.010 --> 00:07:00.440
to do an in-app update.

00:07:00.440 --> 00:07:02.870
Once again, Play
seeks confirmation

00:07:02.870 --> 00:07:04.670
by displaying the download size.

00:07:04.670 --> 00:07:07.190
But for this flow, once
the user has accepted,

00:07:07.190 --> 00:07:09.920
control is returned
immediately back to the app,

00:07:09.920 --> 00:07:12.830
and the user can continue to
use the app while the update is

00:07:12.830 --> 00:07:14.480
being downloaded.

00:07:14.480 --> 00:07:16.510
Finally, when the
update is ready,

00:07:16.510 --> 00:07:18.680
Play will inform the
app again, and the app

00:07:18.680 --> 00:07:20.700
can do something appropriate.

00:07:20.700 --> 00:07:23.510
For example, here,
Swiggy raises a snack bar

00:07:23.510 --> 00:07:25.310
which provides the
opportunity for the user

00:07:25.310 --> 00:07:28.040
to complete the update
by restarting the app--

00:07:28.040 --> 00:07:31.530
again, into the new,
shiny version of the app.

00:07:31.530 --> 00:07:33.290
So the flexible
in-app update flow

00:07:33.290 --> 00:07:35.210
provides the developer
the opportunity

00:07:35.210 --> 00:07:39.540
to customize the experience
during the in-app update.

00:07:39.540 --> 00:07:43.550
So next, let's take a look
how this looks like in code.

00:07:43.550 --> 00:07:47.030
So first, we acquire an
instance of an appUpdateManager

00:07:47.030 --> 00:07:48.470
from the Play Core library.

00:07:48.470 --> 00:07:51.410
This is an object that lets you
interact with the in-app update

00:07:51.410 --> 00:07:53.120
API.

00:07:53.120 --> 00:07:56.600
We make a call to find out
whether an update is available.

00:07:56.600 --> 00:07:59.330
If it is, then we can act
appropriately-- perhaps

00:07:59.330 --> 00:08:01.610
triggering the in-app
update flow immediately,

00:08:01.610 --> 00:08:05.920
or perhaps rendering some button
that will do so once clicked.

00:08:05.920 --> 00:08:09.350
Now, the Java Play Core API for
in-app updates that we see here

00:08:09.350 --> 00:08:14.210
is available for any app to
use today in Play Core 1.5.

00:08:14.210 --> 00:08:16.700
But in the future, we'll be
adding extension libraries

00:08:16.700 --> 00:08:18.740
for integration with
Kotlin and Jetpack,

00:08:18.740 --> 00:08:21.120
leading to even simpler code.

00:08:21.120 --> 00:08:22.820
And if you're interested
in seeing that,

00:08:22.820 --> 00:08:26.060
there was a live demo in
the developer keynote.

00:08:26.060 --> 00:08:27.125
So that's in-app updates.

00:08:30.170 --> 00:08:32.120
YAFIT BECHER: Thank you, Martin.

00:08:32.120 --> 00:08:35.299
Now let's talk about how to
adjust the way your app is

00:08:35.299 --> 00:08:37.730
installed in the first place.

00:08:37.730 --> 00:08:40.750
Traditionally, all your
code and app contents

00:08:40.750 --> 00:08:43.740
are always serve to all users.

00:08:43.740 --> 00:08:46.000
But sometimes, you
have features that

00:08:46.000 --> 00:08:49.490
are simply not applicable
to some of the users

00:08:49.490 --> 00:08:52.330
or some of the devices.

00:08:52.330 --> 00:08:56.230
So by including them, your
users get part of your app

00:08:56.230 --> 00:08:58.030
that they will never use.

00:08:58.030 --> 00:09:00.350
This is obviously not ideal.

00:09:00.350 --> 00:09:04.990
Conditional delivery lets you
control which part of your app

00:09:04.990 --> 00:09:08.440
would be served to which users.

00:09:08.440 --> 00:09:10.480
With conditional
delivery, you can

00:09:10.480 --> 00:09:13.330
set a set of conditions
under which a feature

00:09:13.330 --> 00:09:18.580
module would be delivered, and
otherwise will be left out.

00:09:18.580 --> 00:09:22.000
This lets you exclude a
certain part of your app

00:09:22.000 --> 00:09:24.130
from some of the
devices, and avoid

00:09:24.130 --> 00:09:26.530
loading your app with
irrelevant features

00:09:26.530 --> 00:09:28.480
to the device it
is installed on,

00:09:28.480 --> 00:09:31.420
optimizing download size
and on-device footprint

00:09:31.420 --> 00:09:33.670
of your app.

00:09:33.670 --> 00:09:36.160
We support three
types of conditions

00:09:36.160 --> 00:09:38.320
for conditional delivery.

00:09:38.320 --> 00:09:41.500
First, you can have a
module included only

00:09:41.500 --> 00:09:43.310
for specific countries.

00:09:43.310 --> 00:09:45.740
This is the first time
Play has let you target

00:09:45.740 --> 00:09:47.960
part of your app this way.

00:09:47.960 --> 00:09:52.360
Second, you can restrict a
module by minimum SDK version,

00:09:52.360 --> 00:09:56.300
targeting only devices
above a certain version.

00:09:56.300 --> 00:09:59.170
And third, you can
deliver your module only

00:09:59.170 --> 00:10:02.590
to devices that support
a certain feature--

00:10:02.590 --> 00:10:04.160
such as a VR headset.

00:10:06.770 --> 00:10:10.050
Configuring conditional
delivery is super easy.

00:10:10.050 --> 00:10:12.710
Once you've extracted the
feature into the module,

00:10:12.710 --> 00:10:16.400
the only change needed is
adding installation instructions

00:10:16.400 --> 00:10:19.280
to the Android manifest XML.

00:10:19.280 --> 00:10:22.070
The newly-introduced
install time elements

00:10:22.070 --> 00:10:25.830
allow you to specify
conditions for delivery.

00:10:25.830 --> 00:10:30.140
You can include conditions for
device feature, user country,

00:10:30.140 --> 00:10:31.790
and min SDK.

00:10:31.790 --> 00:10:37.010
We additionally support
minimum openGL ES version.

00:10:37.010 --> 00:10:39.530
If you leave the install
time element empty,

00:10:39.530 --> 00:10:42.740
the module would
always be delivered.

00:10:42.740 --> 00:10:45.530
In this example,
delivery is conditioned

00:10:45.530 --> 00:10:49.760
by device feature and
min SDK, and the module

00:10:49.760 --> 00:10:54.140
will be served only to n-plus
devices that have an AR camera.

00:10:56.750 --> 00:11:01.280
The user country condition lets
you exclude or include a module

00:11:01.280 --> 00:11:02.990
in specific
countries, and you can

00:11:02.990 --> 00:11:05.960
specify more than one country.

00:11:05.960 --> 00:11:08.760
Here, the module
will be deployed only

00:11:08.760 --> 00:11:12.470
to United States and Britain.

00:11:12.470 --> 00:11:14.420
The device country,
in this context,

00:11:14.420 --> 00:11:18.230
is typically determined by the
user billing address attached

00:11:18.230 --> 00:11:19.400
to the Google Play account.

00:11:22.060 --> 00:11:25.060
As we've seen, conditions
may be combined,

00:11:25.060 --> 00:11:29.920
and all conditions must be met
for a module to be delivered.

00:11:29.920 --> 00:11:35.350
At runtime, you can call Play
Core API getInstalledModules

00:11:35.350 --> 00:11:39.400
to find out which
modules are installed.

00:11:39.400 --> 00:11:41.950
This can be used, for
example, to get access

00:11:41.950 --> 00:11:47.370
to a certain activity contained
in a conditional module.

00:11:47.370 --> 00:11:50.000
Once the app is installed,
conditional modules

00:11:50.000 --> 00:11:52.340
can also be requested
through code--

00:11:52.340 --> 00:11:56.780
even if conditions
weren't originally met.

00:11:56.780 --> 00:11:59.090
This is useful,
for example, when

00:11:59.090 --> 00:12:02.030
you want a specific
module to be served only

00:12:02.030 --> 00:12:08.210
to some of the users by default,
while still letting other users

00:12:08.210 --> 00:12:10.680
get it upon request.

00:12:10.680 --> 00:12:13.520
Martin will talk next
on how such features can

00:12:13.520 --> 00:12:16.700
be called for on demand.

00:12:16.700 --> 00:12:18.380
MARTIN CHURCHILL: Thanks.

00:12:18.380 --> 00:12:21.470
So that's modules that are
conditional at install time.

00:12:21.470 --> 00:12:23.480
But sometimes, at
install time, you simply

00:12:23.480 --> 00:12:26.400
do not know whether a module
is relevant for a user.

00:12:26.400 --> 00:12:28.490
Perhaps this depends on
your individual knowledge

00:12:28.490 --> 00:12:32.340
of the user, or their behavior
inside the app after install.

00:12:32.340 --> 00:12:34.800
So what can you do then?

00:12:34.800 --> 00:12:37.910
On-demand feature modules can
be used to install and remove

00:12:37.910 --> 00:12:40.250
modules during the
lifetime of an app,

00:12:40.250 --> 00:12:44.390
based on user behavior inside
the app, triggered via code.

00:12:44.390 --> 00:12:47.600
For example, this might be
useful for user-driven uploads

00:12:47.600 --> 00:12:49.490
in a consumption
app, which might only

00:12:49.490 --> 00:12:53.130
be used by a subset of
the most engaged users.

00:12:53.130 --> 00:12:55.550
Other use cases might
be an onboarding flow

00:12:55.550 --> 00:12:59.540
or a customer support flow that
are rarely used more than once.

00:12:59.540 --> 00:13:01.340
So let's explore a case study--

00:13:01.340 --> 00:13:03.330
Netflix.

00:13:03.330 --> 00:13:05.150
So Netflix's
customer support flow

00:13:05.150 --> 00:13:08.360
is a feature used only by a
small subset of their users,

00:13:08.360 --> 00:13:11.380
and is rarely used more than
once by an individual user.

00:13:11.380 --> 00:13:15.210
But it is a fairly big component
of the app, at a few megabytes.

00:13:15.210 --> 00:13:17.360
So it's a perfect use
case for a feature

00:13:17.360 --> 00:13:20.180
module delivered on demand.

00:13:20.180 --> 00:13:22.820
When the user clicks on the
customer support option,

00:13:22.820 --> 00:13:25.410
the module is downloaded
and installed.

00:13:25.410 --> 00:13:27.500
And once installed,
it seamlessly opens,

00:13:27.500 --> 00:13:30.530
and the user can connect
to customer support.

00:13:30.530 --> 00:13:34.160
This flow is live
in Netflix today.

00:13:34.160 --> 00:13:35.930
Now, in future,
Netflix will also

00:13:35.930 --> 00:13:38.660
configure installed
modules in other ways.

00:13:38.660 --> 00:13:41.540
For example, it can
remove the onboarding flow

00:13:41.540 --> 00:13:43.620
once the onboarding
flow is completed.

00:13:43.620 --> 00:13:46.280
So how might that look?

00:13:46.280 --> 00:13:48.330
So let's take a look
at the code, here.

00:13:48.330 --> 00:13:50.930
So let's consider
how removing a module

00:13:50.930 --> 00:13:53.640
would look in code like this.

00:13:53.640 --> 00:13:55.490
So first, the
module is configured

00:13:55.490 --> 00:13:58.320
as an unconditional
install time module.

00:13:58.320 --> 00:13:59.960
So this is a dynamic
feature that's

00:13:59.960 --> 00:14:02.300
extracted and separate
from the rest of the app,

00:14:02.300 --> 00:14:05.900
but it's installed for everyone
when the app is installed.

00:14:05.900 --> 00:14:08.120
But by keeping it separate,
when the time is right,

00:14:08.120 --> 00:14:11.630
it can be removed in code via
the splitInstall API in Play

00:14:11.630 --> 00:14:12.920
Core.

00:14:12.920 --> 00:14:15.560
The Play Store will then
mark the module for removal,

00:14:15.560 --> 00:14:20.490
and remove it before too long,
saving precious disk space.

00:14:20.490 --> 00:14:22.490
Now, on-demand and
conditional modules

00:14:22.490 --> 00:14:25.010
are in general
availability today,

00:14:25.010 --> 00:14:26.440
and can be used in any app.

00:14:31.660 --> 00:14:34.120
YAFIT BECHER: So we talked
a lot about customizing

00:14:34.120 --> 00:14:36.130
delivery of feature modules.

00:14:36.130 --> 00:14:39.910
But the reality is that many
times, the bulk of the content

00:14:39.910 --> 00:14:43.690
is actually coming from
assets and that code.

00:14:43.690 --> 00:14:46.950
This is especially true for
games, which sometimes require

00:14:46.950 --> 00:14:52.500
massive content download to even
get the user started playing.

00:14:52.500 --> 00:14:56.430
We know that many of you are
using CDN solutions to host

00:14:56.430 --> 00:14:58.880
and deliver your content from.

00:14:58.880 --> 00:15:02.800
But this results in a
suboptimal user experience.

00:15:02.800 --> 00:15:06.870
Users install and open the game,
ready to start playing, just

00:15:06.870 --> 00:15:09.240
to be faced with a long
progress bar waiting

00:15:09.240 --> 00:15:13.020
for additional resources
to be downloaded.

00:15:13.020 --> 00:15:16.650
Furthermore, since the CDN
is blind to the device asking

00:15:16.650 --> 00:15:19.350
for the content, it
cannot optimize delivery

00:15:19.350 --> 00:15:21.250
to the requesting client.

00:15:21.250 --> 00:15:26.080
So you end up serving
all assets to all users,

00:15:26.080 --> 00:15:29.010
regardless if they
will ever use them.

00:15:29.010 --> 00:15:31.710
Another major downside
of using a CDN

00:15:31.710 --> 00:15:35.230
is that you can't rely on
auto updates of assets.

00:15:35.230 --> 00:15:38.610
So again, this results
in additional long waits

00:15:38.610 --> 00:15:44.850
for updating resources after
the game is already installed.

00:15:44.850 --> 00:15:47.220
To make asset delivery
seamless, we'll

00:15:47.220 --> 00:15:51.330
be releasing a new set of
delivery options suited

00:15:51.330 --> 00:15:52.610
for games.

00:15:52.610 --> 00:15:56.130
With that, we are extending
the App Bundle format

00:15:56.130 --> 00:15:58.440
to include game
assets, introducing

00:15:58.440 --> 00:16:00.900
a whole new delivery construct--

00:16:00.900 --> 00:16:03.020
the asset pack.

00:16:03.020 --> 00:16:05.200
Unlike feature
modules, asset packs

00:16:05.200 --> 00:16:09.670
are composed of assets only,
with no executable code,

00:16:09.670 --> 00:16:12.130
and can be very large.

00:16:12.130 --> 00:16:15.190
Asset packs will be
packaged in the App Bundle

00:16:15.190 --> 00:16:17.170
alongside your
game binary, so you

00:16:17.170 --> 00:16:20.080
can publish a single
artifact to Play containing

00:16:20.080 --> 00:16:22.790
everything your game needs.

00:16:22.790 --> 00:16:24.730
You can also rely
on Play to take

00:16:24.730 --> 00:16:27.370
care of keeping your
assets up-to-date,

00:16:27.370 --> 00:16:30.820
just like it currently
does with your game binary.

00:16:30.820 --> 00:16:33.310
And, similarly to
the flexibility

00:16:33.310 --> 00:16:35.310
you have with
feature modules, you

00:16:35.310 --> 00:16:39.400
will be able to customize asset
delivery according to your game

00:16:39.400 --> 00:16:41.690
needs.

00:16:41.690 --> 00:16:45.700
To start, you can use this
to serve your assets upfront,

00:16:45.700 --> 00:16:49.090
as part of the initial
install, instead

00:16:49.090 --> 00:16:51.910
of using APK extension files.

00:16:51.910 --> 00:16:53.870
Asset packs served
this way won't

00:16:53.870 --> 00:16:57.010
require to publish an
additional artifact to Play,

00:16:57.010 --> 00:16:59.260
and unlike extension
files, are not

00:16:59.260 --> 00:17:04.660
prone to accidental deletion
by the user or other apps.

00:17:04.660 --> 00:17:06.819
Your assets can
be easily accessed

00:17:06.819 --> 00:17:10.060
like any assets package
in the base APK,

00:17:10.060 --> 00:17:13.630
using Android Assets Manager.

00:17:13.630 --> 00:17:16.390
You can sign up today
for our early access

00:17:16.390 --> 00:17:19.869
program at this
link, and will soon

00:17:19.869 --> 00:17:23.800
be able to include up to one
gigabyte of your game assets

00:17:23.800 --> 00:17:27.310
in the App Bundle, avoiding
the additional complexity

00:17:27.310 --> 00:17:30.728
of using APK extension files.

00:17:30.728 --> 00:17:33.692
[APPLAUSE]

00:17:35.180 --> 00:17:38.630
But again, this is
just the first step.

00:17:38.630 --> 00:17:41.720
Stay tuned for further
announcements later this year

00:17:41.720 --> 00:17:43.910
about additional
delivery options,

00:17:43.910 --> 00:17:47.750
which will give you even
greater flexibility and control,

00:17:47.750 --> 00:17:52.340
and allow larger
asset packs and enable

00:17:52.340 --> 00:17:56.870
optimized device targeting, so
that for game assets as well,

00:17:56.870 --> 00:17:59.480
your users will
get only the assets

00:17:59.480 --> 00:18:01.310
suitable for their device.

00:18:04.170 --> 00:18:07.820
So let's recap the features
we've discussed so far, today.

00:18:07.820 --> 00:18:10.400
You can trigger updates
directly from your app,

00:18:10.400 --> 00:18:14.360
without having your
users go to the store.

00:18:14.360 --> 00:18:18.250
You can condition the
delivery of feature modules.

00:18:18.250 --> 00:18:21.110
And you can call for
features on demand.

00:18:21.110 --> 00:18:23.690
And soon, you'll be
able to package up

00:18:23.690 --> 00:18:27.430
to one gigabyte of your game
assets in the App Bundle

00:18:27.430 --> 00:18:31.550
and serve it as part of
the game installation.

00:18:31.550 --> 00:18:33.620
But a lot of what
we touched on today

00:18:33.620 --> 00:18:38.660
relies on having your app
broken up into modules.

00:18:38.660 --> 00:18:41.660
So to fully benefit
from all this greatness,

00:18:41.660 --> 00:18:45.160
you should consider
modularizing your app.

00:18:45.160 --> 00:18:48.680
Let's thank Martin, and have
Ben from our developer relations

00:18:48.680 --> 00:18:52.740
team get a little deeper
on app modularization.

00:18:52.740 --> 00:18:54.650
We'll then talk about
our last product

00:18:54.650 --> 00:18:56.140
announcement for today--

00:18:56.140 --> 00:18:59.575
internal app sharing.

00:18:59.575 --> 00:19:02.040
[APPLAUSE]

00:19:02.040 --> 00:19:05.500
BEN WEISS: Thanks, Yafit.

00:19:05.500 --> 00:19:06.400
Wow.

00:19:06.400 --> 00:19:11.560
That's a lot of new ways to
ship your app to your users.

00:19:11.560 --> 00:19:14.590
But like Yafit just said, in
order to make the most of it,

00:19:14.590 --> 00:19:17.230
your app has to be modularized.

00:19:17.230 --> 00:19:20.320
Traditionally, an app was
served to a user's device

00:19:20.320 --> 00:19:22.270
as a single monolithic APK.

00:19:22.270 --> 00:19:24.670
That contained all the
code and resources,

00:19:24.670 --> 00:19:28.330
and all the features
to run all of your app.

00:19:28.330 --> 00:19:31.010
With the Android
App Bundle, that

00:19:31.010 --> 00:19:35.230
uses a split APK functionality
introduced in Android Lollipop,

00:19:35.230 --> 00:19:38.740
makes use of this so we can
make use of all the features

00:19:38.740 --> 00:19:40.750
that we have seen today.

00:19:40.750 --> 00:19:44.110
Instead of packaging everything
into one single monolithic APK,

00:19:44.110 --> 00:19:47.680
multiple configuration
APKs are being built.

00:19:47.680 --> 00:19:50.340
Then, some of them--
suiting the user's devices

00:19:50.340 --> 00:19:52.250
and preferences--
will be installed

00:19:52.250 --> 00:19:53.710
onto the user's device.

00:19:53.710 --> 00:19:57.310
This already saves your
user precious data.

00:19:57.310 --> 00:19:59.860
You can achieve this by
simply building your Android

00:19:59.860 --> 00:20:03.580
app as an App Bundle, and
releasing it on the Play Store.

00:20:03.580 --> 00:20:07.173
So far, no changes to
your code are required,

00:20:07.173 --> 00:20:09.340
but this already will lead
to decreased installation

00:20:09.340 --> 00:20:11.500
size and faster downloads.

00:20:11.500 --> 00:20:14.400
But I'm here to talk
about modularization.

00:20:14.400 --> 00:20:18.760
So let's take a look at
what we did with an app--

00:20:18.760 --> 00:20:23.440
that we made our sample
app for modularized apps.

00:20:23.440 --> 00:20:25.420
We've gone through a
process with Plaid.

00:20:25.420 --> 00:20:28.900
It's an app that we've used
to showcase a lot of features

00:20:28.900 --> 00:20:30.430
throughout the years.

00:20:30.430 --> 00:20:34.510
We used it for material design,
to animations and transitions,

00:20:34.510 --> 00:20:36.680
and most recently dark mode.

00:20:36.680 --> 00:20:38.800
Also, throughout
the past year, we

00:20:38.800 --> 00:20:43.530
added major changes to the
app and modularized it,

00:20:43.530 --> 00:20:47.720
and added dependency
injection using Dagger.

00:20:47.720 --> 00:20:50.890
The app consists of a
home feed that displays

00:20:50.890 --> 00:20:52.270
gathered information.

00:20:52.270 --> 00:20:55.120
It also has a search
functionality, an about screen,

00:20:55.120 --> 00:20:58.090
and several news sources that
can be turned on and off.

00:20:58.090 --> 00:20:59.830
In the end, these
user-facing features

00:20:59.830 --> 00:21:02.350
will be our feature module.

00:21:02.350 --> 00:21:04.060
But before we
started modularizing,

00:21:04.060 --> 00:21:06.010
we switched over to App Bundles.

00:21:06.010 --> 00:21:09.580
This allowed us to save a
staggering 2/3 of the storage

00:21:09.580 --> 00:21:11.830
on some user's devices.

00:21:11.830 --> 00:21:15.555
We ship a native
library, and by only

00:21:15.555 --> 00:21:17.680
having to ship the library
for the CPU architecture

00:21:17.680 --> 00:21:22.510
that it's installed on, we
save a lot of data already.

00:21:22.510 --> 00:21:25.670
From there, we were
able to make changes

00:21:25.670 --> 00:21:28.900
to the structure Plaid has.

00:21:28.900 --> 00:21:31.090
Usually your app consists
of multiple things that

00:21:31.090 --> 00:21:32.500
tie in together--

00:21:32.500 --> 00:21:36.190
of code, resources, extra
dependencies, and drawables.

00:21:36.190 --> 00:21:40.120
After modularizing, the compiler
will enforce clean boundaries

00:21:40.120 --> 00:21:43.210
between your feature modules
through a directed dependency

00:21:43.210 --> 00:21:44.120
graph.

00:21:44.120 --> 00:21:48.148
So let's take a look how
we did that within Plaid.

00:21:48.148 --> 00:21:49.690
No matter how you
structure your code

00:21:49.690 --> 00:21:52.000
overall within the app, no
matter which architecture

00:21:52.000 --> 00:21:55.090
you choose, you break that
down into feature modules

00:21:55.090 --> 00:21:56.980
beforehand.

00:21:56.980 --> 00:21:59.080
Before we actually started
making feature modules,

00:21:59.080 --> 00:22:03.340
we put everything into
packages per feature.

00:22:03.340 --> 00:22:06.160
This allowed for a clean
separation of concerns already.

00:22:06.160 --> 00:22:07.810
During that, we
started untangling

00:22:07.810 --> 00:22:10.150
unwanted dependencies,
and in the end,

00:22:10.150 --> 00:22:12.340
none of the feature
modules should import code

00:22:12.340 --> 00:22:15.730
from another feature
module directly.

00:22:15.730 --> 00:22:18.050
Then we [INAUDIBLE]
looked at our resources.

00:22:18.050 --> 00:22:21.430
We were particularly interested
in structuring them in a way

00:22:21.430 --> 00:22:23.620
that we can move them
to modules later on, as

00:22:23.620 --> 00:22:26.690
well, without problems.

00:22:26.690 --> 00:22:29.590
So for strings, we
initially created files

00:22:29.590 --> 00:22:31.750
with a naming convention
that reflects the feature

00:22:31.750 --> 00:22:33.460
association.

00:22:33.460 --> 00:22:36.220
We chose to add a
module name as a prefix.

00:22:36.220 --> 00:22:41.410
That way, they still show up
grouped together in the IDE.

00:22:41.410 --> 00:22:45.550
We then moved the strings
into these feature resource

00:22:45.550 --> 00:22:49.070
files as we went along.

00:22:49.070 --> 00:22:50.800
We also renamed
layouts, drawables,

00:22:50.800 --> 00:22:53.550
attributes in the same way,
and then moved them along.

00:22:56.080 --> 00:22:58.000
This left us with
shared sources,

00:22:58.000 --> 00:23:01.330
which we moved into shared
dependency called our core

00:23:01.330 --> 00:23:02.118
library.

00:23:02.118 --> 00:23:04.660
The core library is bundled once
within the app space module,

00:23:04.660 --> 00:23:08.530
and can be exposed to
dynamic feature modules.

00:23:08.530 --> 00:23:10.750
This means the
entire application

00:23:10.750 --> 00:23:13.000
is able to access
[INAUDIBLE] dependencies

00:23:13.000 --> 00:23:16.240
without unnecessarily
adding to the app size.

00:23:16.240 --> 00:23:20.290
At this point, everything still
was one monolithic module.

00:23:20.290 --> 00:23:22.880
But since we structured
our app on a feature level,

00:23:22.880 --> 00:23:25.810
we were able to go on and create
our real first dynamic feature

00:23:25.810 --> 00:23:28.600
module.

00:23:28.600 --> 00:23:30.610
We started using the
most lightweight module

00:23:30.610 --> 00:23:32.530
with the least
shared dependencies--

00:23:32.530 --> 00:23:34.900
our About screen.

00:23:34.900 --> 00:23:37.420
The Android Studios
New Module dialog

00:23:37.420 --> 00:23:39.520
takes care of creating
the basic setup.

00:23:39.520 --> 00:23:43.152
All we have to do is enter the
module name and a package name.

00:23:43.152 --> 00:23:45.610
Directories are being created,
and the correct dependencies

00:23:45.610 --> 00:23:48.770
are added in the
app's Gradle file.

00:23:48.770 --> 00:23:50.770
Then we moved all the
previously structured code

00:23:50.770 --> 00:23:52.840
and resources in
the About feature

00:23:52.840 --> 00:23:54.760
into a newly-created module.

00:23:54.760 --> 00:23:56.950
For most cases, it was a
fairly lightweight process,

00:23:56.950 --> 00:23:59.617
but some did take a little bit
more work and thinking about.

00:23:59.617 --> 00:24:00.700
So let's talk about these.

00:24:03.220 --> 00:24:06.210
As we're using resources
from both the About feature

00:24:06.210 --> 00:24:08.100
as well as from
the core library,

00:24:08.100 --> 00:24:10.740
imports came from
different R files.

00:24:10.740 --> 00:24:12.253
They became a bit
tedious to read.

00:24:12.253 --> 00:24:13.920
In a monolithic
application, you usually

00:24:13.920 --> 00:24:18.370
have one single of these
files, so that's not a problem.

00:24:18.370 --> 00:24:22.710
But if you import from
multiple packages,

00:24:22.710 --> 00:24:27.700
you can end up with
imports like this.

00:24:27.700 --> 00:24:30.198
We were able to resolve this
with Kotlin's import aliasing.

00:24:30.198 --> 00:24:31.740
It's a feature that
allows you to map

00:24:31.740 --> 00:24:33.150
an import to another name.

00:24:33.150 --> 00:24:35.400
So instead of having to write
a fully qualified import

00:24:35.400 --> 00:24:39.840
for apps R class, we
simply remapped it to appR.

00:24:39.840 --> 00:24:41.640
This led to more concise
and readable code.

00:24:41.640 --> 00:24:44.560
Differentiation is
still possible and easy,

00:24:44.560 --> 00:24:47.310
but it's way less noisy to read.

00:24:47.310 --> 00:24:48.900
Another thing we
had to change was

00:24:48.900 --> 00:24:50.858
the way activities are
launched within the app.

00:24:50.858 --> 00:24:54.300
In a monolithic app,
it's possible to pass

00:24:54.300 --> 00:24:58.560
a class directly to
the intent explicitly.

00:24:58.560 --> 00:25:00.750
Even activities within
a library dependency

00:25:00.750 --> 00:25:02.575
can be explicitly launched.

00:25:02.575 --> 00:25:04.950
The dependency is directly
accessible from within the app

00:25:04.950 --> 00:25:08.160
space module, but a
dynamic feature module

00:25:08.160 --> 00:25:10.470
depends on the app,
which makes its content

00:25:10.470 --> 00:25:12.390
invisible to the app module.

00:25:12.390 --> 00:25:14.880
This means that classes in
a dynamic feature module

00:25:14.880 --> 00:25:17.980
are inaccessible
to the app module.

00:25:17.980 --> 00:25:19.980
So instead of passing
the class directly,

00:25:19.980 --> 00:25:22.500
we now pass the fully
qualified class name.

00:25:22.500 --> 00:25:24.990
The Android framework is
able to instantiate and start

00:25:24.990 --> 00:25:28.290
the activity as it usually did.

00:25:28.290 --> 00:25:30.930
An app containing fragments
in a dynamic feature module

00:25:30.930 --> 00:25:34.590
can use reflection
for instantiation.

00:25:34.590 --> 00:25:36.510
A key to modularizing
is also having

00:25:36.510 --> 00:25:39.940
a single point of responsibility
for actions your app can take.

00:25:39.940 --> 00:25:42.480
So we didn't want to maintain
these [INAUDIBLE] type calls

00:25:42.480 --> 00:25:44.470
throughout the
entirety of Plaid,

00:25:44.470 --> 00:25:48.480
so we introduced the addressable
activity interface in the app's

00:25:48.480 --> 00:25:50.340
core library.

00:25:50.340 --> 00:25:52.932
Then we implemented it for
each of Plaid's activities.

00:25:52.932 --> 00:25:54.390
When needed, these
objects can also

00:25:54.390 --> 00:25:57.378
hold keys to [INAUDIBLE]
extras in a single place.

00:25:57.378 --> 00:25:58.920
This allows for
centralized code that

00:25:58.920 --> 00:26:02.280
can be invoked from any module.

00:26:02.280 --> 00:26:04.740
Alongside with the
intentTo function,

00:26:04.740 --> 00:26:06.630
this makes launching
the activity

00:26:06.630 --> 00:26:09.442
straightforward and type safe.

00:26:09.442 --> 00:26:10.900
This allows for
decoupled code that

00:26:10.900 --> 00:26:15.880
can be invoked from any module,
as well as easy to read.

00:26:15.880 --> 00:26:18.790
Even before making use
of on-demand delivery,

00:26:18.790 --> 00:26:21.650
we have reaped various benefits.

00:26:21.650 --> 00:26:23.700
Plaid's build time
dropped from three minutes

00:26:23.700 --> 00:26:26.610
down to one minute
for a clean build.

00:26:26.610 --> 00:26:29.340
This was achieved by using
Gradle's parallel build

00:26:29.340 --> 00:26:31.200
feature, which
enables us to build

00:26:31.200 --> 00:26:33.360
multiple independent
features at once.

00:26:33.360 --> 00:26:35.250
Up to a certain
limit, separating out

00:26:35.250 --> 00:26:37.260
more independent
features will further

00:26:37.260 --> 00:26:39.450
decrease the build time.

00:26:39.450 --> 00:26:41.500
Overall, we gained a
more maintainable app.

00:26:41.500 --> 00:26:43.530
This is due to
self-contained modules

00:26:43.530 --> 00:26:46.260
and compile time
enforcement of separation.

00:26:46.260 --> 00:26:49.140
Also, app's footprint has
dramatically decreased.

00:26:49.140 --> 00:26:51.630
This results in
faster app downloads,

00:26:51.630 --> 00:26:55.650
and saves precious
storage on device.

00:26:55.650 --> 00:26:58.500
So looking back at our
tracks that we took so far,

00:26:58.500 --> 00:27:00.570
we first identified
the features of the app

00:27:00.570 --> 00:27:01.960
that we wanted to modularize.

00:27:01.960 --> 00:27:03.960
In our case, those were
the user-facing features

00:27:03.960 --> 00:27:05.550
that the app already had.

00:27:05.550 --> 00:27:07.770
Then we started moving
the code and resources

00:27:07.770 --> 00:27:09.150
to match the structure.

00:27:09.150 --> 00:27:14.022
Afterwards, we created a feature
module and populated that.

00:27:14.022 --> 00:27:16.560
Our modularized
architecture will allow us

00:27:16.560 --> 00:27:18.840
in the future to
dynamically install modules

00:27:18.840 --> 00:27:20.068
as we need them.

00:27:20.068 --> 00:27:22.110
This works by depending
on the Play Core library,

00:27:22.110 --> 00:27:26.580
and making use of
its functionality.

00:27:26.580 --> 00:27:29.090
We can request dynamic feature
modules as they are needed,

00:27:29.090 --> 00:27:30.920
and start installing them.

00:27:30.920 --> 00:27:34.310
Also, if users disable
features for a longer time,

00:27:34.310 --> 00:27:37.502
we can easily uninstall them
if they're no longer needed.

00:27:37.502 --> 00:27:38.960
For more details
on how to do that,

00:27:38.960 --> 00:27:41.450
check out the sample app, as
well as the Play Core library

00:27:41.450 --> 00:27:43.340
documentation.

00:27:43.340 --> 00:27:45.320
You can follow Plaid's
development on GitHub.

00:27:45.320 --> 00:27:46.940
Also, check out an
article containing

00:27:46.940 --> 00:27:50.570
more in-depth information on
the modularization process.

00:27:50.570 --> 00:27:52.040
Thank you very much.

00:27:52.040 --> 00:27:54.002
With that, back to you, Yafit.

00:27:54.002 --> 00:27:54.502
[APPLAUSE]

00:27:54.502 --> 00:27:55.502
YAFIT BECHER: Thank you.

00:28:04.400 --> 00:28:07.300
Now, let's talk
about testing a bit.

00:28:07.300 --> 00:28:09.130
Since we launched
the App Bundle,

00:28:09.130 --> 00:28:12.310
we kept hearing from
developers how great it is.

00:28:12.310 --> 00:28:16.390
But there's one thing we heard
from you loud and clear--

00:28:16.390 --> 00:28:20.180
testing of the App
Bundle is hard.

00:28:20.180 --> 00:28:23.920
This is especially true early
in the development lifecycle,

00:28:23.920 --> 00:28:26.140
where you simply want
to share a test build

00:28:26.140 --> 00:28:28.810
with your internal testers.

00:28:28.810 --> 00:28:32.560
In the APK world, it used
to be very easy to do.

00:28:32.560 --> 00:28:35.470
You simply sent the
APK, and the platform

00:28:35.470 --> 00:28:37.480
knows what to do with it.

00:28:37.480 --> 00:28:40.240
But App Bundles are
not installable.

00:28:40.240 --> 00:28:44.660
And with Play tailoring the
served app to each device,

00:28:44.660 --> 00:28:48.910
you want a guaranteed way to
get exactly the same binary

00:28:48.910 --> 00:28:51.040
as your users would get.

00:28:51.040 --> 00:28:54.710
You have asked, and
we have heard you.

00:28:54.710 --> 00:28:57.920
Internal app sharing,
launched today,

00:28:57.920 --> 00:29:00.800
gives you a quick and easy
way to internally share

00:29:00.800 --> 00:29:03.260
App Bundles for testing.

00:29:03.260 --> 00:29:06.230
All you need to do
is upload a Bundle

00:29:06.230 --> 00:29:09.380
to Play, get a
shareable URL, and have

00:29:09.380 --> 00:29:16.220
your testers use that URL to
download and test the app.

00:29:16.220 --> 00:29:17.870
This is how it looks.

00:29:17.870 --> 00:29:20.030
You simply drag
and drop to upload,

00:29:20.030 --> 00:29:23.840
and share the generated
link with your testers.

00:29:23.840 --> 00:29:26.550
With internal app
sharing, the app installed

00:29:26.550 --> 00:29:30.590
is exactly the same as if it
would've officially published

00:29:30.590 --> 00:29:32.030
to Play.

00:29:32.030 --> 00:29:35.390
It even supports dynamic
delivery features,

00:29:35.390 --> 00:29:39.800
including on-demand and
conditional delivery.

00:29:39.800 --> 00:29:42.340
This way, you have
full confidence

00:29:42.340 --> 00:29:45.410
that what you are testing
is the real thing,

00:29:45.410 --> 00:29:49.880
and you can expect exactly the
same behavior as your users

00:29:49.880 --> 00:29:51.630
out in the wild.

00:29:51.630 --> 00:29:55.250
You are probably curious to
hear more about how it works,

00:29:55.250 --> 00:29:58.740
so let's have Serge, who led
the development of internal app

00:29:58.740 --> 00:30:00.940
sharing, dive into
the details a bit.

00:30:03.886 --> 00:30:06.823
[APPLAUSE]

00:30:07.323 --> 00:30:08.800
SERGE BEAUCHAMP: Thanks, Yafit.

00:30:08.800 --> 00:30:10.270
Hello.

00:30:10.270 --> 00:30:13.850
First, I'd like to clarify
that internal app sharing is

00:30:13.850 --> 00:30:17.780
fundamentally different than
our existing testing programs.

00:30:17.780 --> 00:30:20.690
Simply put, it's
not a release track.

00:30:20.690 --> 00:30:25.670
With internal app sharing, the
test versions uploaded to Play

00:30:25.670 --> 00:30:28.890
are served and hosted
by Play independently.

00:30:28.890 --> 00:30:33.560
They're not part of a release
published in Play Console.

00:30:33.560 --> 00:30:36.110
So let's touch on a
few important features.

00:30:36.110 --> 00:30:47.700
First, uploaders don't need
to be Play Console members.

00:30:47.700 --> 00:30:51.980
So you can authorize users
that don't have access

00:30:51.980 --> 00:30:54.140
to the Play Store.

00:30:54.140 --> 00:30:58.700
Test versions are re-signed by
Play with a test certificate,

00:30:58.700 --> 00:31:04.010
so uploaders don't need access
to the production or upload

00:31:04.010 --> 00:31:05.600
key of your app.

00:31:05.600 --> 00:31:09.350
Play doesn't require
unique version codes,

00:31:09.350 --> 00:31:13.940
so multiple uploaders can use
this feature independently,

00:31:13.940 --> 00:31:16.230
and they don't have
to pick unique version

00:31:16.230 --> 00:31:18.400
codes when they upload.

00:31:18.400 --> 00:31:21.480
Debuggable artifacts
can also be uploaded,

00:31:21.480 --> 00:31:23.900
so you can debug the APKs
once they're installed

00:31:23.900 --> 00:31:26.420
on the testers' devices.

00:31:26.420 --> 00:31:30.470
To authorize testers, you
can go to the Play Console

00:31:30.470 --> 00:31:34.790
and choose to either
allow anyone with the link

00:31:34.790 --> 00:31:41.780
to download and install
APKs, or to allow only users

00:31:41.780 --> 00:31:43.730
in a predefined list.

00:31:43.730 --> 00:31:47.480
In both cases, there's a
user cap enforced by Play.

00:31:47.480 --> 00:31:50.030
So let me show you how
it works in practice.

00:31:53.040 --> 00:31:55.320
Can we switch to
the laptop, please?

00:32:02.680 --> 00:32:03.770
Can we see the lap--

00:32:03.770 --> 00:32:04.270
yes.

00:32:04.270 --> 00:32:05.320
Excellent.

00:32:05.320 --> 00:32:10.960
So I have an App Bundle,
here, on my desktop.

00:32:10.960 --> 00:32:13.600
I just did a fix for a
bug that was reported,

00:32:13.600 --> 00:32:16.840
and I want to quickly
share it with my Q engineer

00:32:16.840 --> 00:32:18.640
for validation.

00:32:18.640 --> 00:32:20.500
Obviously, because
it's an App Bundle,

00:32:20.500 --> 00:32:24.350
my tester cannot simply
install it on the device.

00:32:24.350 --> 00:32:29.290
So what I will do is I will load
the new internal app sharing

00:32:29.290 --> 00:32:36.540
upload page, and I will drag and
drop the bundle onto that page.

00:32:36.540 --> 00:32:38.850
Again, here, I don't have to
worry about version codes,

00:32:38.850 --> 00:32:40.225
because I'm
guaranteed they won't

00:32:40.225 --> 00:32:43.770
conflict with the artifact
published in release tracks.

00:32:43.770 --> 00:32:47.310
It shows a dialogue, and
it shows the version name

00:32:47.310 --> 00:32:50.100
of my App Bundle that is
extracted from the Android

00:32:50.100 --> 00:32:51.690
manifest file.

00:32:51.690 --> 00:32:54.330
I can choose to change
the version name,

00:32:54.330 --> 00:32:57.220
so my tester knows what
this test version is about.

00:33:01.370 --> 00:33:06.530
Here, again, my
uploader account doesn't

00:33:06.530 --> 00:33:09.200
need to have access
to the Play Console.

00:33:09.200 --> 00:33:11.450
It just needs to be
authorized by the Play Console

00:33:11.450 --> 00:33:14.510
admin for that app.

00:33:14.510 --> 00:33:16.970
Now that the upload
has completed,

00:33:16.970 --> 00:33:19.190
it shows a shareable link.

00:33:19.190 --> 00:33:22.840
So I can copy that link, and
I can send it to my tester.

00:33:27.470 --> 00:33:30.110
Can we switch to
the device, please?

00:33:34.240 --> 00:33:35.210
Amazing.

00:33:35.210 --> 00:33:37.810
So I have my testers
device, here.

00:33:37.810 --> 00:33:45.220
And within a few seconds,
I should get the email.

00:33:45.220 --> 00:33:50.520
So my tester opens the
link, and installs the app.

00:33:58.540 --> 00:33:59.670
So there it is.

00:33:59.670 --> 00:34:02.123
Super simple and quick.

00:34:02.123 --> 00:34:05.069
[APPLAUSE]

00:34:07.040 --> 00:34:10.280
This is a version of
Gmail that I built,

00:34:10.280 --> 00:34:13.670
and I changed it so that
there's a dynamic feature module

00:34:13.670 --> 00:34:15.290
for the Compose activity.

00:34:15.290 --> 00:34:18.920
When I tap on the
Plus button, here, it

00:34:18.920 --> 00:34:23.929
loads a feature module,
and it's installed by Play.

00:34:23.929 --> 00:34:27.540
It works right away, because
the app is installed by Play.

00:34:27.540 --> 00:34:32.219
But even better, because
my Bundle is debuggable,

00:34:32.219 --> 00:34:36.609
I can take my device and I can
connect it to Android Studio.

00:34:39.260 --> 00:34:45.469
I can attach the
debugger to that process,

00:34:45.469 --> 00:34:50.940
and I can step through
the dynamic delivery code.

00:34:50.940 --> 00:34:53.197
So that's super useful.

00:34:53.197 --> 00:34:54.030
Can you-- oh, sorry.

00:34:54.030 --> 00:34:55.639
Can we switch to the--

00:34:55.639 --> 00:34:59.670
can we switch to
both devices, please?

00:34:59.670 --> 00:35:00.750
All right.

00:35:00.750 --> 00:35:02.310
Let me do that again.

00:35:02.310 --> 00:35:08.150
I can step through the
dynamic delivery code.

00:35:11.220 --> 00:35:16.050
More than that, we also built
an API endpoint, and a Play

00:35:16.050 --> 00:35:21.240
Publisher API, so you can
automate publishing artifacts

00:35:21.240 --> 00:35:23.010
to internal app sharing.

00:35:23.010 --> 00:35:26.200
And you can integrate it
with third-party tools,

00:35:26.200 --> 00:35:29.160
so you can even, for
instance, invoke it directly

00:35:29.160 --> 00:35:30.750
from Android Studio.

00:35:30.750 --> 00:35:33.420
So this is Play
internal app sharing.

00:35:33.420 --> 00:35:35.016
Thank you very much.

00:35:35.016 --> 00:35:37.974
[APPLAUSE]

00:35:40.940 --> 00:35:42.740
YAFIT BECHER: Thank you, Serge.

00:35:42.740 --> 00:35:45.650
So just in case you've missed
it, using internal app sharing,

00:35:45.650 --> 00:35:49.280
Serge was able to locally
debug dynamic delivery

00:35:49.280 --> 00:35:51.080
of an on-demand feature.

00:35:51.080 --> 00:35:51.800
Isn't that cool?

00:35:54.830 --> 00:35:58.310
We hope that this presentation
demonstrated our commitment

00:35:58.310 --> 00:36:01.310
to the App Bundle, and
that we are doubling down

00:36:01.310 --> 00:36:05.210
on our vision of customized,
dynamic delivery.

00:36:05.210 --> 00:36:09.050
In-app updates, conditional
delivery, dynamic delivery,

00:36:09.050 --> 00:36:11.420
and internal sharing
are all live,

00:36:11.420 --> 00:36:15.800
with documentation available,
at developer.android.com.

00:36:15.800 --> 00:36:20.390
If you are interested in trying
out upfront asset delivery,

00:36:20.390 --> 00:36:24.650
join our early
program at the link.

00:36:24.650 --> 00:36:26.730
We'll have more to
share later this year,

00:36:26.730 --> 00:36:29.570
so come and see us at events
like the Android Developer

00:36:29.570 --> 00:36:31.940
Summit and Google Play Time.

00:36:31.940 --> 00:36:32.780
Thank you.

00:36:32.780 --> 00:36:35.830
[MUSIC PLAYING]

