WEBVTT
Kind: captions
Language: en

00:00:03.530 --> 00:00:12.870
Let's go ahead and
get started, you guys.

00:00:12.870 --> 00:00:15.250
OK, so before we
begin, I just want

00:00:15.250 --> 00:00:17.920
a brief note about the quiz.

00:00:17.920 --> 00:00:21.550
So you should get the quiz
back tomorrow in recitation.

00:00:21.550 --> 00:00:27.440
The mean and median on the
quiz were 69 out of 100,

00:00:27.440 --> 00:00:30.630
so look for it tomorrow.

00:00:30.630 --> 00:00:33.010
And there should be solutions
post it also tomorrow.

00:00:37.194 --> 00:00:39.110
Does anybody or member
with standard deviation

00:00:39.110 --> 00:00:41.610
was on the quiz?

00:00:41.610 --> 00:00:43.800
OK, thanks.

00:00:43.800 --> 00:00:45.580
OK, so the topic
for today, we're

00:00:45.580 --> 00:00:49.060
going to continue
talking about networking.

00:00:49.060 --> 00:00:51.580
And just to recap where
we left off last time,

00:00:51.580 --> 00:00:55.540
I wanted to review a few of the
best effort network properties.

00:00:55.540 --> 00:01:00.070
So you remember at
the end of lecture

00:01:00.070 --> 00:01:08.390
last time we talked about
this notion of a best effort

00:01:08.390 --> 00:01:08.920
network.

00:01:08.920 --> 00:01:10.460
And we said that
these packet switch

00:01:10.460 --> 00:01:15.520
networks like the Internet are
typically best effort, which

00:01:15.520 --> 00:01:17.990
means that there are
certain things in particular

00:01:17.990 --> 00:01:20.530
that they don't guarantee.

00:01:20.530 --> 00:01:25.350
So one property of
best effort networks

00:01:25.350 --> 00:01:29.400
is that they're
subject to delays.

00:01:29.400 --> 00:01:38.350
So these are delays due to
the propagation of messages

00:01:38.350 --> 00:01:40.960
down our wire, the time
it takes for the messages

00:01:40.960 --> 00:01:43.080
to propagate along the pipe.

00:01:43.080 --> 00:01:46.280
Remember we talked about
that analogy last time?

00:01:46.280 --> 00:01:52.690
Time to transmit the
message, so transmission time

00:01:52.690 --> 00:01:54.460
is sort of the amount
of time it takes

00:01:54.460 --> 00:01:56.900
proportional to the
length of the message

00:01:56.900 --> 00:02:00.500
and the bit rate of the link.

00:02:00.500 --> 00:02:04.695
And then, there is
additional delays

00:02:04.695 --> 00:02:06.320
that are introduced
by these properties

00:02:06.320 --> 00:02:08.236
that we talked about at
the end of the lecture

00:02:08.236 --> 00:02:11.460
last time such as queuing.

00:02:11.460 --> 00:02:14.600
So the fact that remember we
said that these networks are

00:02:14.600 --> 00:02:17.180
congested and the load is
somewhat unpredictable.

00:02:17.180 --> 00:02:19.460
And because the load of the
network is unpredictable,

00:02:19.460 --> 00:02:21.080
that necessarily
means that there

00:02:21.080 --> 00:02:23.600
are going to be queues
in between the links

00:02:23.600 --> 00:02:25.520
on our network.

00:02:25.520 --> 00:02:28.200
And then finally,
additional sorts

00:02:28.200 --> 00:02:32.084
of delay that we
talked about, but also

00:02:32.084 --> 00:02:33.750
can be an issue as
the processing delay.

00:02:33.750 --> 00:02:36.180
So this is the delay
incurred by sort

00:02:36.180 --> 00:02:38.830
of the overhead of processing
messages between switches,

00:02:38.830 --> 00:02:42.770
for example, in our network.

00:02:42.770 --> 00:02:45.780
OK, so other interesting
properties of best effort

00:02:45.780 --> 00:02:50.510
networks, they incur some loss.

00:02:50.510 --> 00:02:53.060
OK, so there are
going to be messages

00:02:53.060 --> 00:02:57.431
that are corrupted as they are
transmitted down these links.

00:02:57.431 --> 00:02:59.930
There are going to be losses
that are caused by congestions.

00:02:59.930 --> 00:03:04.550
Remember we talked about how
one of the only responses,

00:03:04.550 --> 00:03:06.620
oftentimes the best
response to congestion

00:03:06.620 --> 00:03:10.517
is simply to drop packets
to reduce overload.

00:03:10.517 --> 00:03:12.350
And there are sometimes
going to be failures

00:03:12.350 --> 00:03:15.270
that are going to be switches
within the network that

00:03:15.270 --> 00:03:17.010
will sometimes simply
cease to function.

00:03:17.010 --> 00:03:18.426
And of course
you're going to lose

00:03:18.426 --> 00:03:20.040
the data when that happens.

00:03:20.040 --> 00:03:23.410
And there can be
reordering of packets.

00:03:27.232 --> 00:03:28.690
So you didn't talk
much about this.

00:03:28.690 --> 00:03:30.630
But it's fairly
sort of obvious idea

00:03:30.630 --> 00:03:33.990
that suppose an application has
two different messages, right?

00:03:33.990 --> 00:03:37.030
Well if you think about the
way that those messages may

00:03:37.030 --> 00:03:39.300
be routed along different
paths through the network.

00:03:39.300 --> 00:03:41.520
And we'll talk about this
more when we talk about how

00:03:41.520 --> 00:03:43.622
routing works next time.

00:03:43.622 --> 00:03:45.830
But because they can be
routed along different paths,

00:03:45.830 --> 00:03:48.580
there's no guarantee that the
messages, because message one

00:03:48.580 --> 00:03:51.560
was sent before message two,
that message one actually

00:03:51.560 --> 00:03:53.600
arrives before message
two at whatever

00:03:53.600 --> 00:03:55.200
endpoint you're sending to.

00:03:55.200 --> 00:03:57.045
And finally, there
can be duplication.

00:04:00.470 --> 00:04:03.399
And duplication is often a
side effect of techniques

00:04:03.399 --> 00:04:05.440
that we'll again talk
about next time for dealing

00:04:05.440 --> 00:04:07.040
with this issue of loss.

00:04:07.040 --> 00:04:09.670
So if you have lost packets,
somewhere in the network

00:04:09.670 --> 00:04:11.792
you may want to try and
retransmit those packets.

00:04:11.792 --> 00:04:13.500
And because you're
retransmitting things,

00:04:13.500 --> 00:04:14.700
you're sending things
multiple times.

00:04:14.700 --> 00:04:15.830
There can be places
in the network

00:04:15.830 --> 00:04:17.899
where you actually see
two copies of a message.

00:04:17.899 --> 00:04:21.000
So these best effort
networks have a number

00:04:21.000 --> 00:04:24.160
of sort of properties that make
using them somewhat complex.

00:04:24.160 --> 00:04:26.900
And what we're going to
talk about over the next two

00:04:26.900 --> 00:04:28.800
or three lectures
basically are ways

00:04:28.800 --> 00:04:33.130
of mitigating the complexity
of these best effort networks,

00:04:33.130 --> 00:04:35.820
of making the interface
that these best effort

00:04:35.820 --> 00:04:39.510
networks provide to
applications a little bit

00:04:39.510 --> 00:04:42.420
more usable in the sense that
we're going to try and find

00:04:42.420 --> 00:04:44.970
ways to reduce the
effects of things

00:04:44.970 --> 00:04:47.470
like loss and reordering are
to make it so that applications

00:04:47.470 --> 00:04:50.730
don't necessarily need to
be aware of those things.

00:04:50.730 --> 00:04:52.520
So in order to start
getting at sort

00:04:52.520 --> 00:04:54.860
of dealing with
complexity, we're

00:04:54.860 --> 00:04:58.930
going to talk today about
this notion of layering.

00:04:58.930 --> 00:05:12.330
So -- So when we talked
generically about systems

00:05:12.330 --> 00:05:14.750
earlier in the class, we
said that a standard way that

00:05:14.750 --> 00:05:16.958
we're going to deal with
complexity is by introducing

00:05:16.958 --> 00:05:18.940
modularity.

00:05:18.940 --> 00:05:22.250
And the specific
kind of modularity

00:05:22.250 --> 00:05:26.334
that is widely used within
networks is layering.

00:05:26.334 --> 00:05:28.750
And that's what we're going
to talk about most of the time

00:05:28.750 --> 00:05:31.540
today.

00:05:31.540 --> 00:05:33.660
The other way that we
typically deal with,

00:05:33.660 --> 00:05:35.870
another common way of
dealing with complexity

00:05:35.870 --> 00:05:38.850
with the networks is
by using protocols.

00:05:44.620 --> 00:05:46.440
And a protocol is
really just a set

00:05:46.440 --> 00:05:52.450
of rules for how two
machines on the network

00:05:52.450 --> 00:05:53.750
do communicate with each other.

00:05:53.750 --> 00:05:55.890
So, for example,
a protocol might

00:05:55.890 --> 00:05:58.640
say that if I want
to tell you about,

00:05:58.640 --> 00:06:02.079
if I want to send a message
to you that I will put

00:06:02.079 --> 00:06:04.370
this certain bit of information
at the beginning of it,

00:06:04.370 --> 00:06:06.453
I'll put some address
information at the beginning

00:06:06.453 --> 00:06:08.220
of that message.

00:06:08.220 --> 00:06:12.340
And the message will be no more
than a certain number of bytes

00:06:12.340 --> 00:06:13.090
long.

00:06:13.090 --> 00:06:15.489
And I'll put that
message on the wire,

00:06:15.489 --> 00:06:17.030
and then part of
the protocol is also

00:06:17.030 --> 00:06:18.400
that you will send an
acknowledgment back

00:06:18.400 --> 00:06:20.660
to me that tells me that
you in fact got the message.

00:06:20.660 --> 00:06:22.880
So these protocols
are very well defined

00:06:22.880 --> 00:06:25.350
sets of rules about
how communication

00:06:25.350 --> 00:06:26.267
is supposed to happen.

00:06:26.267 --> 00:06:27.641
These protocols
are going to help

00:06:27.641 --> 00:06:29.350
us to deal with
complexity because they

00:06:29.350 --> 00:06:31.170
are going to tell us
what we expect to have

00:06:31.170 --> 00:06:32.130
happen within the network.

00:06:32.130 --> 00:06:33.900
And when things don't
follow the protocols,

00:06:33.900 --> 00:06:35.441
then that's going
to be an indication

00:06:35.441 --> 00:06:38.650
that something went wrong,
and that we should therefore

00:06:38.650 --> 00:06:39.740
try and recover from it.

00:06:39.740 --> 00:06:41.740
So, for example, if
we lose a packet,

00:06:41.740 --> 00:06:43.370
the protocol is
going to allow us

00:06:43.370 --> 00:06:45.240
to detect that a packet
was lost and request

00:06:45.240 --> 00:06:46.530
that that be retransmitted.

00:06:46.530 --> 00:06:49.390
We'll talk much more
about protocols next time,

00:06:49.390 --> 00:06:51.500
but it's sort of
worth bearing in mind

00:06:51.500 --> 00:06:53.339
that almost at any
time, two things

00:06:53.339 --> 00:06:55.130
are communicating within
a network that are

00:06:55.130 --> 00:06:56.450
using one of these protocols.

00:06:56.450 --> 00:06:59.190
And a protocol is
just a set of rules.

00:06:59.190 --> 00:07:05.810
OK so I want to just
quickly give you

00:07:05.810 --> 00:07:07.100
this list of five questions.

00:07:07.100 --> 00:07:09.391
We're going to come back to
this list of five questions

00:07:09.391 --> 00:07:10.950
a little bit later.

00:07:10.950 --> 00:07:13.394
But these are sort
of five key questions

00:07:13.394 --> 00:07:14.810
that we need to
sort of figure out

00:07:14.810 --> 00:07:17.490
how we're going to actually
resolve in networks.

00:07:17.490 --> 00:07:20.970
And the first question is, how
do we multiplex conversations

00:07:20.970 --> 00:07:21.720
on a network?

00:07:21.720 --> 00:07:23.220
When we talked about
this last time,

00:07:23.220 --> 00:07:25.580
we have these two different
alternatives, time division

00:07:25.580 --> 00:07:29.231
multiplexing, which we said
was used in telephone networks.

00:07:29.231 --> 00:07:30.730
And we talked about
packet switching

00:07:30.730 --> 00:07:32.938
as a way in which we can
have multiple people sharing

00:07:32.938 --> 00:07:33.865
a network.

00:07:33.865 --> 00:07:35.490
But there is a bunch
of other questions

00:07:35.490 --> 00:07:36.630
that we haven't
really answered yet.

00:07:36.630 --> 00:07:37.500
And this is what
we're going to get

00:07:37.500 --> 00:07:39.300
at over the next few lectures.

00:07:39.300 --> 00:07:41.350
So how do we transmit
bits on a link?

00:07:41.350 --> 00:07:44.950
How do we actually,
given a wire,

00:07:44.950 --> 00:07:47.420
how do we actually modulate
that wire in the right way

00:07:47.420 --> 00:07:50.470
to transmit the message that
we want to transmit down it?

00:07:50.470 --> 00:07:52.490
How do we forward
packets via switches?

00:07:52.490 --> 00:07:54.810
So we sort of said that
there are these switches,

00:07:54.810 --> 00:07:57.150
and that along any
communication path,

00:07:57.150 --> 00:08:00.310
there may be sort of
multiple communication hops

00:08:00.310 --> 00:08:02.310
that have to be taken
through multiple switches.

00:08:02.310 --> 00:08:05.310
But we haven't yet talked
about what is actually

00:08:05.310 --> 00:08:06.910
going on inside those switches.

00:08:06.910 --> 00:08:08.370
So we are going to look
in particular at what's

00:08:08.370 --> 00:08:10.120
going on inside
switches in the Internet

00:08:10.120 --> 00:08:13.095
and see how that works.

00:08:13.095 --> 00:08:14.470
Then there's this
question about,

00:08:14.470 --> 00:08:16.210
how do we actually make
communication reliable?

00:08:16.210 --> 00:08:18.501
So we said that one of the
limitations of a best effort

00:08:18.501 --> 00:08:20.580
networks is that, well,
it introduces loss,

00:08:20.580 --> 00:08:22.690
and it can reorder packets.

00:08:22.690 --> 00:08:24.870
Applications
oftentimes don't want

00:08:24.870 --> 00:08:27.250
to have their packets
reordered or dropped, right,

00:08:27.250 --> 00:08:30.114
because they're trying to
actually exchange information

00:08:30.114 --> 00:08:30.780
with each other.

00:08:30.780 --> 00:08:33.314
So we'd like to understand
what kinds of techniques

00:08:33.314 --> 00:08:34.730
we can use that
can systematically

00:08:34.730 --> 00:08:38.862
allow us to avoid, or to
make communication reliable.

00:08:38.862 --> 00:08:40.820
And then, finally, how
do we manage congestion?

00:08:40.820 --> 00:08:43.265
So we said that one of
the fundamental problems

00:08:43.265 --> 00:08:44.640
with these packet
switch networks

00:08:44.640 --> 00:08:46.590
is that the amount
of load may be

00:08:46.590 --> 00:08:47.980
unpredictable in the network.

00:08:47.980 --> 00:08:52.590
So the question that we
need to ask, then, is, OK,

00:08:52.590 --> 00:08:54.394
how are we going to
manage this congestion?

00:08:54.394 --> 00:08:56.810
What are we going to do in
response to congestion in order

00:08:56.810 --> 00:08:59.010
to sort of minimize
the effect that it has

00:08:59.010 --> 00:09:01.931
on the applications that are
trying to run on the network.

00:09:01.931 --> 00:09:04.180
OK, so we'll come back to
these questions in a minute,

00:09:04.180 --> 00:09:07.270
and as we talk about what the
layers of the network stack

00:09:07.270 --> 00:09:09.950
are, we'll sort of see how
these different questions

00:09:09.950 --> 00:09:13.240
fit in to these different
parts of the network stack.

00:09:13.240 --> 00:09:14.800
But what I want to
do now is really

00:09:14.800 --> 00:09:16.860
turn to this issue of layering.

00:09:16.860 --> 00:09:23.480
OK, so in order to understand
a little bit about why there

00:09:23.480 --> 00:09:25.310
might be wires within
a network, or a

00:09:25.310 --> 00:09:28.130
why there might be layers
within a network, excuse me,

00:09:28.130 --> 00:09:33.310
let's look at a very
simple kind of a network.

00:09:33.310 --> 00:09:38.190
So suppose we have some
client, a client, C, OK,

00:09:38.190 --> 00:09:41.310
who has a number of
different connections

00:09:41.310 --> 00:09:46.110
to the outside world
available to it.

00:09:46.110 --> 00:09:48.860
And, it can connect each
of those connections

00:09:48.860 --> 00:09:51.170
go, say, for example,
to some switch which

00:09:51.170 --> 00:09:55.050
may in turn connect to
another switch which may in

00:09:55.050 --> 00:10:00.720
turn connect to some N host S,
server S, that the client is

00:10:00.720 --> 00:10:02.390
trying to communicate with, OK?

00:10:02.390 --> 00:10:05.650
So, suppose C is trying
to send a message to S.

00:10:05.650 --> 00:10:08.480
Let's think a little bit about
how this might actually work.

00:10:08.480 --> 00:10:15.360
So we have the application,
which is perhaps running on C.

00:10:15.360 --> 00:10:18.480
And, it might try
and send a message

00:10:18.480 --> 00:10:25.260
by calling some
routine send S message.

00:10:25.260 --> 00:10:30.480
OK, so it says send to endpoint
S this message that I have.

00:10:30.480 --> 00:10:33.120
So let's think about
how we might actually

00:10:33.120 --> 00:10:35.220
go about implementing this.

00:10:35.220 --> 00:10:39.310
So one way that you might
have the application send

00:10:39.310 --> 00:10:41.590
a message to S is
that you might have

00:10:41.590 --> 00:10:44.707
this sort of the application
might understand everything

00:10:44.707 --> 00:10:47.040
about what the whole network
topology looks like, right?

00:10:47.040 --> 00:10:49.590
So, it might understand, know
about all the different links

00:10:49.590 --> 00:10:51.381
that are available to
it, and with each one

00:10:51.381 --> 00:10:57.000
of these different links, it
may understand what the topology

00:10:57.000 --> 00:10:58.250
of devices that are out there.

00:10:58.250 --> 00:11:00.208
So if I have a connection
to the Internet, that

00:11:00.208 --> 00:11:03.230
would mean that I have to
understand all of the machines

00:11:03.230 --> 00:11:05.150
that are connected to
me via the Internet,

00:11:05.150 --> 00:11:08.190
right, so I have this
list of a million hosts,

00:11:08.190 --> 00:11:11.510
and [UNINTELLIGIBLE] every
client, and I sort of just

00:11:11.510 --> 00:11:14.040
scan down this list
of a million machines

00:11:14.040 --> 00:11:15.600
that I can connect
to until I find S.

00:11:15.600 --> 00:11:18.177
And then I send a message
out over the next link

00:11:18.177 --> 00:11:19.010
or something, right?

00:11:19.010 --> 00:11:20.950
So this sounds very
complicated because it

00:11:20.950 --> 00:11:23.020
forces the application
to understand

00:11:23.020 --> 00:11:26.889
the sort of entire functionality
of the network underneath it,

00:11:26.889 --> 00:11:28.430
how the network is
connected, and how

00:11:28.430 --> 00:11:29.638
the nodes talk to each other.

00:11:29.638 --> 00:11:31.520
So that doesn't seem
like a very good idea.

00:11:31.520 --> 00:11:33.436
Right, instead we'd like
to application simply

00:11:33.436 --> 00:11:36.350
to be able to just
send its message out.

00:11:36.350 --> 00:11:38.680
And we would like some
lower layer service

00:11:38.680 --> 00:11:40.700
to take care of the
details of figuring out

00:11:40.700 --> 00:11:42.740
where to send the message next.

00:11:42.740 --> 00:11:48.710
So, in networks, we talk
about that sort of service

00:11:48.710 --> 00:11:51.190
that runs underneath
the application, that's

00:11:51.190 --> 00:11:56.000
in charge of figuring out what
the next sort of connection,

00:11:56.000 --> 00:11:59.260
the next top to use
within the network,

00:11:59.260 --> 00:12:02.290
we call that the
network layer, OK?

00:12:02.290 --> 00:12:05.320
So, I'm going to
abbreviate as NET.

00:12:05.320 --> 00:12:07.770
And so, what the network
layer, for example, suppose

00:12:07.770 --> 00:12:10.610
this client had three
connections available to it.

00:12:10.610 --> 00:12:12.990
It has a modem connection.

00:12:12.990 --> 00:12:15.100
It has a WiFi connection.

00:12:15.100 --> 00:12:18.059
And maybe it has an
Ethernet connection.

00:12:18.059 --> 00:12:19.600
What the network
layer is going to do

00:12:19.600 --> 00:12:21.310
is it's going to
look at this name, S,

00:12:21.310 --> 00:12:23.480
that the client has specified.

00:12:23.480 --> 00:12:26.200
And it's going to try and
decide which one of these links

00:12:26.200 --> 00:12:30.222
is the next link to use in order
to forward the message on to S.

00:12:30.222 --> 00:12:31.930
OK, so it's just going
to make a decision

00:12:31.930 --> 00:12:35.470
from amongst the
available connections.

00:12:35.470 --> 00:12:42.380
So, it's going to basically
pick the next link, OK?

00:12:42.380 --> 00:12:43.990
And if this is the
Internet, you're

00:12:43.990 --> 00:12:46.487
going to have these switches
or these routers that

00:12:46.487 --> 00:12:48.320
may have links to a
bunch of other networks.

00:12:48.320 --> 00:12:52.030
And so in the Internet,
the network layer

00:12:52.030 --> 00:12:55.880
runs actually on all of the
routers within the Internet,

00:12:55.880 --> 00:12:57.860
and is making these
decisions about how

00:12:57.860 --> 00:12:59.160
to forward packet after packet.

00:12:59.160 --> 00:13:02.960
So we'll see again in the
next lecture and in recitation

00:13:02.960 --> 00:13:06.690
how the Internet actually
does packet forwarding.

00:13:06.690 --> 00:13:09.700
But so we said there
is this network layer.

00:13:09.700 --> 00:13:13.020
But we have this thing that's
picking the next link to send

00:13:13.020 --> 00:13:14.640
the message out over, right?

00:13:14.640 --> 00:13:16.910
But we don't necessarily
want that thing

00:13:16.910 --> 00:13:19.950
to have to understand the
details of how you actually

00:13:19.950 --> 00:13:22.680
communicate over each of the
available physical connections,

00:13:22.680 --> 00:13:23.230
right?

00:13:23.230 --> 00:13:27.260
So suppose that the
only thing that was here

00:13:27.260 --> 00:13:30.246
was this network layer.

00:13:30.246 --> 00:13:31.870
And the network layer
had to understand

00:13:31.870 --> 00:13:34.374
how to communicate over
Ethernet and WiFi and the modem.

00:13:34.374 --> 00:13:35.790
Right, well then
the network layer

00:13:35.790 --> 00:13:38.248
is going to be very complicated
because, of course, sending

00:13:38.248 --> 00:13:39.850
messages out over
a wireless radio

00:13:39.850 --> 00:13:43.520
is very different than sending
messages out over an Ethernet.

00:13:43.520 --> 00:13:45.180
So what we have
is one layer that

00:13:45.180 --> 00:13:47.570
sits underneath the network
layer, which we typically

00:13:47.570 --> 00:13:51.250
call the link layer.

00:13:51.250 --> 00:13:56.930
And the link layer is
responsible for managing

00:13:56.930 --> 00:14:01.360
the physical connection for
the transmission of data

00:14:01.360 --> 00:14:03.250
from a long just
one of these wires.

00:14:03.250 --> 00:14:05.440
It's the thing that
actually moves bits

00:14:05.440 --> 00:14:10.420
from C to whatever the next
top within the network is, OK?

00:14:13.530 --> 00:14:16.390
So, these are these two layers.

00:14:16.390 --> 00:14:18.430
You notice now, I've
left this hole here.

00:14:18.430 --> 00:14:21.650
You might be wondering
what goes into that hole.

00:14:21.650 --> 00:14:24.329
So what we said is
so the network layer

00:14:24.329 --> 00:14:25.870
is responsible for
picking the links.

00:14:25.870 --> 00:14:29.600
But remember that what we
talked about so far in this best

00:14:29.600 --> 00:14:31.800
effort network abstraction
is sort of affairs

00:14:31.800 --> 00:14:34.810
all these problems, decent sort
of with delays, reordering,

00:14:34.810 --> 00:14:36.640
duplication, and so on.

00:14:36.640 --> 00:14:40.070
And it might be that
neither of these layers

00:14:40.070 --> 00:14:42.340
really is responsible for
dealing with those problems.

00:14:42.340 --> 00:14:44.432
What we said is,
what we want, to be

00:14:44.432 --> 00:14:46.390
able to provide an
abstraction for applications

00:14:46.390 --> 00:14:49.134
where some of these problems
with the best effort networks

00:14:49.134 --> 00:14:50.300
are hidden from the network.

00:14:50.300 --> 00:14:53.970
OK, so typically
networks introduce

00:14:53.970 --> 00:14:56.410
a third layer,
which in this class

00:14:56.410 --> 00:14:58.190
we call the end-to-end
layer that's

00:14:58.190 --> 00:15:01.990
in charge of addressing
these kinds of issues.

00:15:01.990 --> 00:15:05.950
The end-to-end layer may seem
a little bit fuzzy, the details

00:15:05.950 --> 00:15:08.300
of it when we talk about it
because the end-to-end layer

00:15:08.300 --> 00:15:11.010
can do lots of different things
for different applications.

00:15:11.010 --> 00:15:13.980
OK, so some applications
may be concerned about,

00:15:13.980 --> 00:15:19.190
for example, the possibility
of messages being lost, right,

00:15:19.190 --> 00:15:21.411
whereas other
applications may not

00:15:21.411 --> 00:15:23.160
be as concerned about
messages being lost,

00:15:23.160 --> 00:15:25.360
but may be very
concerned about delay.

00:15:25.360 --> 00:15:27.190
And we'll see as we
talk to the class

00:15:27.190 --> 00:15:29.601
that delay and loss trade
off with each other which

00:15:29.601 --> 00:15:30.100
makes sense.

00:15:30.100 --> 00:15:32.150
If I lose a message and
I have to retransmit it,

00:15:32.150 --> 00:15:35.100
that's going to increase
the delay on the network.

00:15:35.100 --> 00:15:38.556
But, so it's possible to sort
of trade these things off

00:15:38.556 --> 00:15:39.180
for each other.

00:15:39.180 --> 00:15:40.680
So the end-to-end
layer is the thing

00:15:40.680 --> 00:15:44.000
that's responsible for trying
to make application environment

00:15:44.000 --> 00:15:45.950
sort of more pleasant
for the application.

00:15:45.950 --> 00:15:49.730
And that can mean dealing
with trying to eliminate loss

00:15:49.730 --> 00:15:51.492
or trying to minimize
delay, for example.

00:15:51.492 --> 00:15:53.700
We'll talk about different
kinds of end-to-end layers

00:15:53.700 --> 00:15:56.770
in just a few lectures.

00:15:56.770 --> 00:15:58.490
OK, so these are
kind of the three.

00:15:58.490 --> 00:16:01.360
So we're going to decompose
our network into these three

00:16:01.360 --> 00:16:02.540
layers.

00:16:02.540 --> 00:16:06.160
And in order to sort illustrate
this to you a little better,

00:16:06.160 --> 00:16:07.720
what I want to do
is just walk you

00:16:07.720 --> 00:16:10.200
through a simple example
of how the letters might

00:16:10.200 --> 00:16:17.540
look in the Internet with
a simple web application.

00:16:17.540 --> 00:16:19.710
And I'm going to use
some of that terminology

00:16:19.710 --> 00:16:21.089
from the Internet
here, and we're

00:16:21.089 --> 00:16:23.380
going to return to some of
this terminology, introduced

00:16:23.380 --> 00:16:25.530
its older more
carefully in recitation.

00:16:25.530 --> 00:16:28.440
But I'll try and explain
it as much as we go.

00:16:28.440 --> 00:16:36.370
So suppose we have a
laptop, say my laptop here,

00:16:36.370 --> 00:16:39.920
that wants to connect to
a Web server, MIT.edu.

00:16:39.920 --> 00:16:42.320
And, the way that
the Web works is it

00:16:42.320 --> 00:16:45.360
uses a protocol
called HTTP, which

00:16:45.360 --> 00:16:50.750
is used for making requests
for specific webpages,

00:16:50.750 --> 00:16:53.710
and for returning the
results of those webpages.

00:16:53.710 --> 00:16:56.230
So these are typically
called requests and responses

00:16:56.230 --> 00:17:00.300
in the HTTP specification.

00:17:00.300 --> 00:17:03.570
Now, if you look at, so this
is sort of from the user's

00:17:03.570 --> 00:17:06.050
perspective; the
application is a browser

00:17:06.050 --> 00:17:08.400
that knows about
the http protocol,

00:17:08.400 --> 00:17:10.839
or a Web server that knows
about the HTTP protocol.

00:17:10.839 --> 00:17:13.250
And it's running on these
two remote machines.

00:17:13.250 --> 00:17:15.660
Underneath each of
these things, of course,

00:17:15.660 --> 00:17:19.349
there is a set of layers.

00:17:19.349 --> 00:17:23.410
And each of these things
has layers underneath it.

00:17:23.410 --> 00:17:25.578
And these layers correspond
to these three things

00:17:25.578 --> 00:17:27.869
we just talked about, the
end-to-end layer, the network

00:17:27.869 --> 00:17:31.030
layer, and the link layer.

00:17:31.030 --> 00:17:33.040
So one thing you
may notice here is

00:17:33.040 --> 00:17:36.180
that the link layer is different
between these two things.

00:17:36.180 --> 00:17:39.900
So the laptop is perhaps
communicating over WiFi,

00:17:39.900 --> 00:17:42.350
and the Web server
is communicating

00:17:42.350 --> 00:17:44.670
over the Ethernet.

00:17:44.670 --> 00:17:47.030
But otherwise these two
things have the same;

00:17:47.030 --> 00:17:51.230
their Ethernet layer and their
network layer are TCP and IP.

00:17:51.230 --> 00:17:54.360
So, TCP is going to be in
charge of basically providing

00:17:54.360 --> 00:17:56.054
this reliable
abstraction for us.

00:17:56.054 --> 00:17:57.720
We're not going to
talk about it anymore

00:17:57.720 --> 00:17:59.700
today, except to
say that, that it

00:17:59.700 --> 00:18:01.670
makes communication reliable.

00:18:01.670 --> 00:18:03.760
We'll see how it
does that later.

00:18:03.760 --> 00:18:08.150
What IP is responsible for is
choosing the sort of next top

00:18:08.150 --> 00:18:10.917
to make along each connection
of the way, each connection

00:18:10.917 --> 00:18:11.750
within the Internet.

00:18:11.750 --> 00:18:13.960
So, IP is the protocol
that runs the Internet.

00:18:13.960 --> 00:18:16.690
And, you may have
seen IP addresses.

00:18:16.690 --> 00:18:18.710
So, IP addresses are
the sort of names

00:18:18.710 --> 00:18:20.380
for the endpoints
in the Internet,

00:18:20.380 --> 00:18:23.010
and takes an IP
address and basically

00:18:23.010 --> 00:18:24.510
gives you this
next link that you

00:18:24.510 --> 00:18:27.460
should use in order to
transmit a message out over it.

00:18:27.460 --> 00:18:32.090
OK, so suppose that
the browser generates

00:18:32.090 --> 00:18:34.579
a request for some page.

00:18:34.579 --> 00:18:36.370
What it's going to do
is it's going to call

00:18:36.370 --> 00:18:38.480
send on the end-to-end layer.

00:18:38.480 --> 00:18:41.110
OK, so I've just written this
as E to E send to make it clear

00:18:41.110 --> 00:18:44.160
that this is a send
request to the ETE layer.

00:18:44.160 --> 00:18:47.082
And it's going to
pass some message.

00:18:47.082 --> 00:18:48.540
In this case, the
message is simply

00:18:48.540 --> 00:18:51.460
going to be the contents
of this request.

00:18:51.460 --> 00:18:53.220
And it's going to
specify the underlying

00:18:53.220 --> 00:18:56.250
protocol that it should use
as well as the destination

00:18:56.250 --> 00:18:56.750
address.

00:18:56.750 --> 00:19:00.600
So this address is one of
these Internet addresses and IP

00:19:00.600 --> 00:19:02.620
address followed
by this colon 80.

00:19:02.620 --> 00:19:04.950
So, what colon 80
does is it identifies

00:19:04.950 --> 00:19:06.730
what's called a port number.

00:19:06.730 --> 00:19:08.250
And it identifies
the application

00:19:08.250 --> 00:19:10.075
we're running on
the remote server

00:19:10.075 --> 00:19:11.450
that we want to
communicate with.

00:19:11.450 --> 00:19:13.650
So, typically Web
servers run on port.

00:19:13.650 --> 00:19:15.650
Now, you say they run
on port number 80.

00:19:15.650 --> 00:19:19.510
That just means that the
TCP layer on the other side

00:19:19.510 --> 00:19:24.520
knows how to communicate,
knows that the Web

00:19:24.520 --> 00:19:26.860
server on the other end is
connected on this port number

00:19:26.860 --> 00:19:27.360
80.

00:19:27.360 --> 00:19:29.100
So it gives us a
way to communicate,

00:19:29.100 --> 00:19:31.940
to identify applications that
are running on the remote host.

00:19:34.500 --> 00:19:39.390
So now what happens is this
request is going to be,

00:19:39.390 --> 00:19:42.224
the TCP layer is going to
take this request, which

00:19:42.224 --> 00:19:43.640
I've shown in blue,
and it's going

00:19:43.640 --> 00:19:46.679
to attach what are called
headers and trailers to it.

00:19:46.679 --> 00:19:48.720
So these headers and
trailers are the information

00:19:48.720 --> 00:19:53.500
that TCP needs, the TCP
layer on the other side

00:19:53.500 --> 00:19:55.830
is going to need in order
to deliver this message

00:19:55.830 --> 00:19:57.250
to the application.

00:19:57.250 --> 00:20:00.380
So in particular,
this thing is going

00:20:00.380 --> 00:20:02.630
to contain this port number
that we already mentioned.

00:20:02.630 --> 00:20:04.838
So this is going to be used
on the other end in order

00:20:04.838 --> 00:20:06.940
to send the message
to the Web server.

00:20:06.940 --> 00:20:09.150
It's also going to have
a sequence number, which

00:20:09.150 --> 00:20:10.525
as we will see
later, we're going

00:20:10.525 --> 00:20:15.100
to use in order to, for
example, reporter in order

00:20:15.100 --> 00:20:20.294
to detect reordered messages
or detect lost messages.

00:20:20.294 --> 00:20:22.960
OK, so the TCP layer now is just
going to repeat the same thing.

00:20:22.960 --> 00:20:25.180
It's just going to
take this packet,

00:20:25.180 --> 00:20:28.570
and it's going to call
some request, say,

00:20:28.570 --> 00:20:32.360
NetSend [SP?] on the IP layer
that sits underneath it.

00:20:32.360 --> 00:20:37.587
And again, it's going to
specify the set of data

00:20:37.587 --> 00:20:39.420
that it built up, which
we called a segment.

00:20:39.420 --> 00:20:43.500
So that's what SEG is, which was
the purple and the blue blocks.

00:20:43.500 --> 00:20:45.550
And it's going to pass
that on to the IP header

00:20:45.550 --> 00:20:48.520
using this NetSend
message to the IP layer.

00:20:48.520 --> 00:20:51.070
And it's going to tell the
IP layer what IP address it

00:20:51.070 --> 00:20:52.390
wants to send this message to.

00:20:52.390 --> 00:20:54.390
Now, the IP layer is going
to take this message,

00:20:54.390 --> 00:20:56.015
and it's going to
put the header on it.

00:20:56.015 --> 00:20:58.880
So IP doesn't use a
trailer, although it could,

00:20:58.880 --> 00:21:02.690
in principle, use a trailer.

00:21:02.690 --> 00:21:05.380
And this IP header is
going to sort of just

00:21:05.380 --> 00:21:07.510
contain the IP address
of the next hop,

00:21:07.510 --> 00:21:09.730
or of the destination.

00:21:09.730 --> 00:21:13.380
OK, now the IP layer is going
to do exactly what we said.

00:21:13.380 --> 00:21:15.200
The IP layer is
our network layer

00:21:15.200 --> 00:21:17.010
so it's going to do exactly
what we said it does before.

00:21:17.010 --> 00:21:17.100
It's going to look at
all the available links

00:21:17.100 --> 00:21:19.700
that it has to it, and it's
going to send this message out

00:21:19.700 --> 00:21:23.200
over one of those
links that it believes

00:21:23.200 --> 00:21:26.260
is the correct next
top in forwarding.

00:21:26.260 --> 00:21:28.140
So it's going to call link send.

00:21:28.140 --> 00:21:29.704
It's going to pass
this packet on,

00:21:29.704 --> 00:21:31.620
and it's going to specify
the name of the link

00:21:31.620 --> 00:21:33.000
that it wants to use.

00:21:33.000 --> 00:21:35.200
And it may have to specify
some address information,

00:21:35.200 --> 00:21:37.610
for example, what I've shown
here is just [cool?] in one

00:21:37.610 --> 00:21:41.240
just to say whatever machine
is one the wireless network

00:21:41.240 --> 00:21:43.730
at wireless address number one.

00:21:43.730 --> 00:21:47.050
So you guys saw sort of a
similar addressing scheme being

00:21:47.050 --> 00:21:48.290
used in Ethernet last time.

00:21:48.290 --> 00:21:51.180
You can sort of think
of that the same here.

00:21:51.180 --> 00:21:54.290
So what happens now is of
course the same process.

00:21:54.290 --> 00:21:57.880
The link layer attaches
its header and trailer.

00:21:57.880 --> 00:22:02.250
So, I've called WH and WT for
WiFi header and WiFi trailer.

00:22:02.250 --> 00:22:04.990
And now at this point we
called this thing a frame.

00:22:04.990 --> 00:22:07.790
And this frame is now
ready to be delivered out

00:22:07.790 --> 00:22:10.280
sort of along the next
top of the network.

00:22:10.280 --> 00:22:14.160
So suppose that the
network layer identified

00:22:14.160 --> 00:22:16.890
one particular switch
as the next destination

00:22:16.890 --> 00:22:20.150
of this packet.

00:22:20.150 --> 00:22:25.080
It's going to send this out
over the network to the WiFi

00:22:25.080 --> 00:22:27.137
interface of this switch.

00:22:27.137 --> 00:22:28.970
The switch is going to
receive this message.

00:22:28.970 --> 00:22:33.280
What it's going to
do is it's going

00:22:33.280 --> 00:22:36.260
to take the WiFi header
and the WiFi trailer,

00:22:36.260 --> 00:22:38.490
and it's going to peel
them off of the message,

00:22:38.490 --> 00:22:42.050
and it's going to pass the
message with just the network

00:22:42.050 --> 00:22:45.040
header, no more WiFi header
on it up to the IP layer.

00:22:45.040 --> 00:22:48.940
Now the IP layer now
has an exact copy

00:22:48.940 --> 00:22:54.780
of the sort of message including
the IP header from the laptop.

00:22:54.780 --> 00:22:57.230
And, so what the IP
header layer will do

00:22:57.230 --> 00:23:02.220
is look at its IP
header labeled NH here,

00:23:02.220 --> 00:23:04.990
and it'll decide what the next
appropriate hop to use, to send

00:23:04.990 --> 00:23:07.260
this message out, it is.

00:23:07.260 --> 00:23:10.187
So it's going to then
pick the next link

00:23:10.187 --> 00:23:12.270
to send a message out over
and, say, in this case,

00:23:12.270 --> 00:23:15.197
it decides to send the message
over an Ethernet connection.

00:23:15.197 --> 00:23:17.530
The Ethernet connection is
going to receive the message.

00:23:17.530 --> 00:23:20.220
It's going to attach its
header and its trailer to it.

00:23:20.220 --> 00:23:22.710
And then it's going to send
it out to the next link, OK?

00:23:22.710 --> 00:23:26.020
So this process just repeats.

00:23:26.020 --> 00:23:28.880
The message gets sent
to the Ethernet link

00:23:28.880 --> 00:23:29.830
on the other side.

00:23:29.830 --> 00:23:32.640
The Ethernet link forwards
the message onto the IP layer.

00:23:32.640 --> 00:23:34.610
The IP layer
decodes the message,

00:23:34.610 --> 00:23:36.820
decides what the
next link to use is.

00:23:36.820 --> 00:23:39.780
In this case, it decides
again to use an Ethernet link.

00:23:39.780 --> 00:23:42.110
And it sends the message
out over the Ethernet.

00:23:42.110 --> 00:23:44.120
Finally we get to MIT.edu.

00:23:44.120 --> 00:23:46.820
And once we get to
MIT.edu, we just

00:23:46.820 --> 00:23:48.887
start forwarding this
message up the layers, OK?

00:23:48.887 --> 00:23:51.220
So, we do what are called
up-calls from the lower layers

00:23:51.220 --> 00:23:53.120
to the higher layers,
notifying them

00:23:53.120 --> 00:23:54.510
that a message has arrived.

00:23:54.510 --> 00:23:57.360
So, the Ethernet layer peels
its headers off, sends them up

00:23:57.360 --> 00:23:58.170
to the IP layer.

00:23:58.170 --> 00:24:00.230
The IP layer peels
its headers off,

00:24:00.230 --> 00:24:03.640
sends them up to the TCP layer.

00:24:03.640 --> 00:24:05.250
Then remember, we
said the TCP layer,

00:24:05.250 --> 00:24:08.799
so the TCP layer has
a port number that's

00:24:08.799 --> 00:24:09.590
associated with it.

00:24:09.590 --> 00:24:12.770
The port number is used to
identify the application that

00:24:12.770 --> 00:24:14.210
should receive this message.

00:24:14.210 --> 00:24:16.240
So, the TCP layer
pulls out the port

00:24:16.240 --> 00:24:18.630
and sends it up to the
web server, which finally

00:24:18.630 --> 00:24:20.710
receives our request, OK?

00:24:20.710 --> 00:24:22.420
Now the Web server
does whatever it does.

00:24:22.420 --> 00:24:24.240
It chews on this
request for a while,

00:24:24.240 --> 00:24:26.240
and say, for example,
generates a webpage,

00:24:26.240 --> 00:24:27.896
generates some HTML
that it's going

00:24:27.896 --> 00:24:29.020
to send back to the client.

00:24:29.020 --> 00:24:31.620
And now this process just
repeats all over again.

00:24:31.620 --> 00:24:35.210
The MIT.edu sends
a message back down

00:24:35.210 --> 00:24:37.420
to TCP identifying the
client as the endpoint

00:24:37.420 --> 00:24:39.140
that it wants the
message to reach, OK?

00:24:43.800 --> 00:24:48.000
So this is sort of the basic
way in which we use layering.

00:24:48.000 --> 00:24:50.780
What I want to do is now kind
of step back and look at,

00:24:50.780 --> 00:24:53.360
I sort of presented this
as a very quick example.

00:24:53.360 --> 00:24:55.940
But what I want
to do is step back

00:24:55.940 --> 00:24:58.690
and look at some of
the sort of rules

00:24:58.690 --> 00:25:02.240
that we are following
as we use these layers,

00:25:02.240 --> 00:25:04.630
and to sort of talk
about why we have

00:25:04.630 --> 00:25:06.550
sort of constructivist
thing in the exact way

00:25:06.550 --> 00:25:08.340
that we have constructed it.

00:25:08.340 --> 00:25:11.370
So the first rule that
we are following here

00:25:11.370 --> 00:25:15.740
is called encapsulation.

00:25:27.030 --> 00:25:28.730
So what encapsulation
is, is it's simply

00:25:28.730 --> 00:25:31.850
this way in which you notice
that when we send messages out,

00:25:31.850 --> 00:25:33.730
each layer associated
its own header

00:25:33.730 --> 00:25:36.800
and trailer with those
messages that were sent out.

00:25:36.800 --> 00:25:39.840
And it didn't modify
anything about any

00:25:39.840 --> 00:25:42.760
of this sort of data that wasn't
associated with the header

00:25:42.760 --> 00:25:44.830
and trailer for that layer, OK?

00:25:44.830 --> 00:25:49.470
So, encapsulation
says that each layer

00:25:49.470 --> 00:25:55.270
may add or remove
depending on whether we're

00:25:55.270 --> 00:25:58.170
sending a message down
or sending a message up.

00:25:58.170 --> 00:26:02.485
Its own headers are trailers.

00:26:06.990 --> 00:26:15.950
OK, but that layer doesn't
touch, doesn't look at or use

00:26:15.950 --> 00:26:19.750
the payload from higher layers.

00:26:19.750 --> 00:26:32.982
OK, so the link layer
doesn't look at anything

00:26:32.982 --> 00:26:34.440
that the end to
end layer sends it.

00:26:34.440 --> 00:26:36.280
It simply treats this
as a block of data

00:26:36.280 --> 00:26:39.197
that it has to transmit, and
it doesn't understand anything

00:26:39.197 --> 00:26:41.280
about what the contents
of that block of data are.

00:26:41.280 --> 00:26:42.930
It doesn't assume anything
about the contents

00:26:42.930 --> 00:26:44.020
of that block of data.

00:26:44.020 --> 00:26:46.840
Similarly, the network layer
doesn't assume anything

00:26:46.840 --> 00:26:48.630
about the contents
of the data that's

00:26:48.630 --> 00:26:50.420
received from end to end layer.

00:26:50.420 --> 00:26:52.750
And similarly, the
end to end layer

00:26:52.750 --> 00:26:55.260
doesn't assume anything about
the format or the layout

00:26:55.260 --> 00:26:58.390
of the data that's received
from the application layer, OK,

00:26:58.390 --> 00:26:59.730
or from the application.

00:26:59.730 --> 00:27:04.860
So what this layering
abstraction buys

00:27:04.860 --> 00:27:10.450
us is that it allows
these things to sort

00:27:10.450 --> 00:27:14.957
of coexist without any
understanding of what

00:27:14.957 --> 00:27:15.790
the other layers do.

00:27:15.790 --> 00:27:19.730
So in particular, it means that
we can, for example, change

00:27:19.730 --> 00:27:21.750
something about the
format of the data

00:27:21.750 --> 00:27:23.890
that the network layer sends.

00:27:23.890 --> 00:27:26.120
And we continue to use
the same link layer.

00:27:26.120 --> 00:27:32.340
OK, so I can send it out
over an Ethernet that's

00:27:32.340 --> 00:27:35.250
not data that's been sort
of packaged up by IP, right?

00:27:35.250 --> 00:27:37.600
It doesn't necessarily
have to be an IP packet

00:27:37.600 --> 00:27:40.480
to send it out over Ethernet.

00:27:40.480 --> 00:27:46.650
And so, this sort of
separation between the layers

00:27:46.650 --> 00:27:48.530
is going to be really
critical for allowing

00:27:48.530 --> 00:27:50.760
us to sort of
maintain and develop

00:27:50.760 --> 00:27:52.770
new networking code over time.

00:27:52.770 --> 00:27:54.590
And it also means
that the people

00:27:54.590 --> 00:27:58.230
who provide the sort of
companies that build and sell

00:27:58.230 --> 00:28:00.809
software and hardware that
works at these different layers

00:28:00.809 --> 00:28:02.350
don't really have
to assume very much

00:28:02.350 --> 00:28:08.480
about what the other layers
are going to provide, right?

00:28:08.480 --> 00:28:10.430
So if I'm making
an Ethernet card,

00:28:10.430 --> 00:28:13.790
I don't have to understand
anything about exactly what,

00:28:13.790 --> 00:28:15.740
I hopefully won't have
to understand anything

00:28:15.740 --> 00:28:19.000
about exactly what's sort
of going on up at the higher

00:28:19.000 --> 00:28:20.290
levels of the network stack.

00:28:20.290 --> 00:28:22.123
You have to be a little
bit careful, though,

00:28:22.123 --> 00:28:23.850
because of course
the individual layers

00:28:23.850 --> 00:28:27.820
do have some protocol that
there is some sort of API

00:28:27.820 --> 00:28:30.980
that they're using to
interface with each other.

00:28:30.980 --> 00:28:33.460
So, API is an application
programming interface.

00:28:33.460 --> 00:28:36.610
You have some set of routines
that they call on each other.

00:28:36.610 --> 00:28:39.490
So for example, I
showed in this example

00:28:39.490 --> 00:28:41.780
up here that the
networking layer

00:28:41.780 --> 00:28:45.416
is calling this
link send message

00:28:45.416 --> 00:28:46.540
on the link layer below it.

00:28:46.540 --> 00:28:49.406
So the link layer has to provide
this link send interface.

00:28:49.406 --> 00:28:51.280
And similarly, there's
a comparable interface

00:28:51.280 --> 00:28:54.050
when the link layer receives
a message that uses to send up

00:28:54.050 --> 00:28:55.470
to the network layer.

00:28:55.470 --> 00:28:57.930
OK, but basically
what this means

00:28:57.930 --> 00:29:01.580
is that we can develop
the software that

00:29:01.580 --> 00:29:03.900
runs at the different
layers in isolation

00:29:03.900 --> 00:29:05.990
without having to worry
too much about what's

00:29:05.990 --> 00:29:08.980
going on at the layers
above or below us.

00:29:08.980 --> 00:29:10.463
OK, so --

00:29:20.820 --> 00:29:23.310
Let's return back to
our set of questions

00:29:23.310 --> 00:29:27.160
now and talk a little bit
about how these questions map

00:29:27.160 --> 00:29:31.020
onto our three layers.

00:29:31.020 --> 00:29:34.612
OK, so our first
question is, so we

00:29:34.612 --> 00:29:37.070
said question one is, we've
sort of already addressed that.

00:29:37.070 --> 00:29:40.750
But question two is, well, how
do we transmit bits on a link?

00:29:40.750 --> 00:29:45.470
OK, so clearly that's going
to be handled by layer two,

00:29:45.470 --> 00:29:48.270
OK, or by the link layer, sorry.

00:29:48.270 --> 00:29:54.110
And, so the link
layer is the thing

00:29:54.110 --> 00:29:56.162
that's going to be in
charge of actually pushing

00:29:56.162 --> 00:29:57.120
the bits onto the link.

00:29:57.120 --> 00:29:59.460
And none of the other layers
need to know about this.

00:29:59.460 --> 00:30:02.980
Question three, OK, how do we
forward packets via switches?

00:30:02.980 --> 00:30:06.210
Well, it seems that it's
pretty clearly what's

00:30:06.210 --> 00:30:07.530
happening at the network layer.

00:30:07.530 --> 00:30:09.071
OK, so the network
layer is the thing

00:30:09.071 --> 00:30:13.130
that's deciding sort
of which packet,

00:30:13.130 --> 00:30:17.970
what the next link that we
should use is within a switch.

00:30:17.970 --> 00:30:19.760
OK, and now questions
four and five

00:30:19.760 --> 00:30:24.220
are these questions about
this kind of our best network

00:30:24.220 --> 00:30:24.720
properties.

00:30:24.720 --> 00:30:26.428
How do we achieve
reliable communication?

00:30:26.428 --> 00:30:27.740
How we manage congestion?

00:30:27.740 --> 00:30:29.400
These are things that were
going to worry about at the end

00:30:29.400 --> 00:30:30.010
to end layer.

00:30:34.390 --> 00:30:40.890
OK, so just to sort of
illustrate a little bit more

00:30:40.890 --> 00:30:44.276
about sort of how the
commercial, and how

00:30:44.276 --> 00:30:46.650
these things are separated in
sort of a commercial world,

00:30:46.650 --> 00:30:49.310
I thought I'd just show you the
slide that sort of illustrates

00:30:49.310 --> 00:30:52.539
that there are lots of
different vendors, both hardware

00:30:52.539 --> 00:30:55.080
and software, that run at each
one of these different layers.

00:30:55.080 --> 00:30:58.260
So, for example, at
the end to end layer,

00:30:58.260 --> 00:31:00.880
first there are clearly
a bunch of applications

00:31:00.880 --> 00:31:01.950
that run up there.

00:31:01.950 --> 00:31:03.890
And each of those
applications perhaps

00:31:03.890 --> 00:31:06.550
has some different sort
of set of requirements

00:31:06.550 --> 00:31:08.810
about how data is delivered.

00:31:08.810 --> 00:31:11.380
And those
applications, typically

00:31:11.380 --> 00:31:14.340
the sort of things
like the TCP protocol

00:31:14.340 --> 00:31:16.900
are provided by, say, the
operating system vendor.

00:31:16.900 --> 00:31:23.620
So Microsoft Windows provides
an implementation of TCP;

00:31:23.620 --> 00:31:27.010
similarly Mac OS and
Linux also provide this.

00:31:27.010 --> 00:31:28.959
At the network layer
now we have sort

00:31:28.959 --> 00:31:31.500
of this huge variety of people
who are building these network

00:31:31.500 --> 00:31:31.970
switches.

00:31:31.970 --> 00:31:33.330
And these network
switches are the things

00:31:33.330 --> 00:31:34.850
that have sort of
coded into them

00:31:34.850 --> 00:31:37.630
the rules for how you should
forward messages around

00:31:37.630 --> 00:31:38.820
on the Internet.

00:31:38.820 --> 00:31:41.460
And so these are these companies
like Cisco and Alcatel,

00:31:41.460 --> 00:31:44.440
in sort of these big companies
that hear mentioned in the news

00:31:44.440 --> 00:31:45.570
all the time.

00:31:45.570 --> 00:31:47.450
And then finally at the
sort of lowest layer,

00:31:47.450 --> 00:31:49.407
there are these sorts
of link layer things.

00:31:49.407 --> 00:31:51.740
And again, there are a number
of link layer technologies

00:31:51.740 --> 00:31:54.270
like WiFi and Ethernet.

00:31:54.270 --> 00:31:55.970
And those link
layer technologies

00:31:55.970 --> 00:32:00.300
are different than
the technologies that

00:32:00.300 --> 00:32:03.150
are used to actually
decide which

00:32:03.150 --> 00:32:06.070
hop we should next use in
order to transmit data around

00:32:06.070 --> 00:32:07.510
in the Internet.

00:32:07.510 --> 00:32:10.901
OK, so if there's a big
diversity of applications.

00:32:10.901 --> 00:32:12.650
And part of this
diversity of applications

00:32:12.650 --> 00:32:15.290
is enabled by this
separation of the layers

00:32:15.290 --> 00:32:19.887
because Microsoft
Windows doesn't really

00:32:19.887 --> 00:32:22.220
have to know anything about
how the network layer works.

00:32:22.220 --> 00:32:24.860
It simply passes
sort of messages

00:32:24.860 --> 00:32:28.690
on for the network to transmit.

00:32:28.690 --> 00:32:33.670
OK, so and the point
is that the vendors

00:32:33.670 --> 00:32:37.390
are generally different at
each of these different layers.

00:32:37.390 --> 00:32:41.375
OK, so given this sort
of high-level overview

00:32:41.375 --> 00:32:42.750
of layering, what
we're now going

00:32:42.750 --> 00:32:44.440
to do throughout the
next few lectures

00:32:44.440 --> 00:32:47.000
is to pay some attention to how
each of the different layers

00:32:47.000 --> 00:32:47.740
works.

00:32:47.740 --> 00:32:49.250
So we're going to
start off talking

00:32:49.250 --> 00:32:52.700
about this class
about the link layer.

00:32:52.700 --> 00:32:57.070
And then we'll move
on to the network

00:32:57.070 --> 00:32:58.990
and ends to end layers
in later lectures.

00:33:06.990 --> 00:33:09.627
OK, so we've sort of seen
some of the things that

00:33:09.627 --> 00:33:11.460
touched on some of the
things the link layer

00:33:11.460 --> 00:33:13.440
needs to provide
at a high level.

00:33:13.440 --> 00:33:16.720
But let's make a list and talk
about what these things are.

00:33:16.720 --> 00:33:20.770
So the first thing clearly
that the link layer does

00:33:20.770 --> 00:33:23.720
is manage the sort of
transmission of bits

00:33:23.720 --> 00:33:25.170
along this physical wire.

00:33:25.170 --> 00:33:30.940
OK, so there's going to
be some digital to analog

00:33:30.940 --> 00:33:35.910
to digital conversion
that happens

00:33:35.910 --> 00:33:39.339
in sort of as a part of using
any one of these links, OK?

00:33:39.339 --> 00:33:41.880
And this is going to be one of
the main functions of the link

00:33:41.880 --> 00:33:44.130
layer is it's
going to decide how

00:33:44.130 --> 00:33:46.400
this sort of digital to
analog to digital conversion

00:33:46.400 --> 00:33:48.700
is done, OK?

00:33:48.700 --> 00:33:51.200
Another thing to link
layer does is framing.

00:33:51.200 --> 00:33:52.890
And so, framing,
well you remember

00:33:52.890 --> 00:33:54.310
we talked about
at the link layer,

00:33:54.310 --> 00:33:57.070
we sometimes call for messages
that are transmitted around,

00:33:57.070 --> 00:33:58.520
we call these things frames.

00:33:58.520 --> 00:34:01.860
Framing is simply
separating the frames,

00:34:01.860 --> 00:34:04.890
is deciding how we should
separate the frames that

00:34:04.890 --> 00:34:07.530
are on the wire.

00:34:07.530 --> 00:34:11.000
So it says, how
does the software

00:34:11.000 --> 00:34:16.550
that's running at the link layer
decide that one frame has ended

00:34:16.550 --> 00:34:17.750
and another frame has begun?

00:34:17.750 --> 00:34:19.429
That's what framing is about.

00:34:19.429 --> 00:34:22.789
And we'll talk about these
two issues briefly today.

00:34:22.789 --> 00:34:24.830
The other kinds of things
that happen at the link

00:34:24.830 --> 00:34:28.020
layer we're not going to talk
about as much about today.

00:34:28.020 --> 00:34:30.630
One of them is channel access.

00:34:30.630 --> 00:34:37.760
And so this is how
somebody who wants

00:34:37.760 --> 00:34:42.800
to send a message actually
is able to physically use

00:34:42.800 --> 00:34:45.889
the wire or the air that
it's transmitting out

00:34:45.889 --> 00:34:48.412
of without interfering or
something on top of something

00:34:48.412 --> 00:34:50.120
else who's transmitting
at the same time.

00:34:50.120 --> 00:34:52.090
So you guys have read
the Ethernet paper,

00:34:52.090 --> 00:34:53.960
and you saw one way
in which that's done

00:34:53.960 --> 00:34:58.040
and Ethernet, which is basically
by listening for a carrier,

00:34:58.040 --> 00:35:01.150
right, which is
called carrier sense,

00:35:01.150 --> 00:35:04.274
and only when the
channel is not used,

00:35:04.274 --> 00:35:05.690
there's not a
carrier on the wire,

00:35:05.690 --> 00:35:07.320
does somebody try and send.

00:35:07.320 --> 00:35:10.540
And then you use this notion
of collision detection

00:35:10.540 --> 00:35:17.024
and Ethernet in order to
actually sort of detect

00:35:17.024 --> 00:35:19.190
whether or not you are able
to successfully transmit

00:35:19.190 --> 00:35:19.750
your message.

00:35:19.750 --> 00:35:21.750
So these are the kinds
of things you worry about

00:35:21.750 --> 00:35:23.120
in channel access.

00:35:23.120 --> 00:35:24.600
Last time with
the phone network,

00:35:24.600 --> 00:35:26.750
we talked about time
division multiplexing

00:35:26.750 --> 00:35:29.849
as another way in which you
can sort of share access

00:35:29.849 --> 00:35:30.640
to a physical wire.

00:35:30.640 --> 00:35:33.120
You can carve it up into a
bunch of little units of time

00:35:33.120 --> 00:35:37.480
and assign each sender
one unit of time.

00:35:37.480 --> 00:35:41.640
OK, so now the last
link layer issue

00:35:41.640 --> 00:35:45.760
which sometimes is
done in the link layer

00:35:45.760 --> 00:35:49.725
is error detection
and correction.

00:35:53.340 --> 00:35:55.854
And I don't want to
talk at all about really

00:35:55.854 --> 00:35:57.770
how error detection or
correction works except

00:35:57.770 --> 00:36:01.140
to say that some link layer is
included in some link layers

00:36:01.140 --> 00:36:02.920
don't include it.

00:36:02.920 --> 00:36:06.160
The idea here is suppose we
are transmitting a message out

00:36:06.160 --> 00:36:07.782
over a wire.

00:36:07.782 --> 00:36:09.240
Of course, there's
some probability

00:36:09.240 --> 00:36:10.864
that that message
will become corrupted

00:36:10.864 --> 00:36:13.329
or garbled it is being
transmitted, either because it

00:36:13.329 --> 00:36:15.370
interferes with somebody
else who is transmitting

00:36:15.370 --> 00:36:18.690
at the same time, or as
the message propagates,

00:36:18.690 --> 00:36:21.380
it decays somewhat and we
can't decode it anymore.

00:36:21.380 --> 00:36:23.970
So sometimes link layers
include a facility

00:36:23.970 --> 00:36:26.830
for doing this error
detection and correction.

00:36:26.830 --> 00:36:28.450
And error detection
and correction

00:36:28.450 --> 00:36:30.158
is one of these things
that can sometimes

00:36:30.158 --> 00:36:33.360
be included at the link layer,
and is very often included

00:36:33.360 --> 00:36:34.740
at the end to end layer.

00:36:34.740 --> 00:36:37.816
And so, as you read, the
reason I mention this

00:36:37.816 --> 00:36:39.190
as being a part
of the link layer

00:36:39.190 --> 00:36:42.582
is that as you read the end
arguments paper for recitation

00:36:42.582 --> 00:36:44.040
next time, you
should sort of think

00:36:44.040 --> 00:36:47.861
about how the end-to-end
argument relates

00:36:47.861 --> 00:36:49.860
to whether error detection
and correction should

00:36:49.860 --> 00:36:51.276
be within the link
layer or should

00:36:51.276 --> 00:36:54.930
be within the end to end layer.

00:36:54.930 --> 00:36:58.360
OK, so let's talk about
these sort of two issues

00:36:58.360 --> 00:37:00.826
that I said we'll
address briefly here.

00:37:00.826 --> 00:37:02.450
So the first issue
I want to talk about

00:37:02.450 --> 00:37:06.560
is how the conversion
from digital

00:37:06.560 --> 00:37:09.840
to analog to conversion works.

00:37:09.840 --> 00:37:22.250
So -- So the way to think
about, suppose that we have some

00:37:22.250 --> 00:37:26.590
sender which has some sequence
of bits, say, one, zero, one,

00:37:26.590 --> 00:37:29.950
zero that they want to send
out over the radio channel.

00:37:29.950 --> 00:37:31.660
So if you think
about what this is

00:37:31.660 --> 00:37:33.814
going to look like in
terms of an analog signal,

00:37:33.814 --> 00:37:35.730
they are of course are
many different ways you

00:37:35.730 --> 00:37:36.540
could represent it.

00:37:36.540 --> 00:37:38.123
But a simple way to
represent it might

00:37:38.123 --> 00:37:41.920
be to say that this
is a digital line,

00:37:41.920 --> 00:37:44.420
and we'll make the line high
when we are transmitting a one,

00:37:44.420 --> 00:37:47.530
and we'll make the line low when
we're transmitting a zero, OK?

00:37:47.530 --> 00:37:49.250
So we would send
this message out

00:37:49.250 --> 00:37:54.610
as high followed by low followed
by high followed by low.

00:37:54.610 --> 00:38:03.272
So this would be
one, zero, one, zero.

00:38:03.272 --> 00:38:04.730
OK, you might ask
the question, OK,

00:38:04.730 --> 00:38:08.200
how do we decide when to
sort of push the next bit out

00:38:08.200 --> 00:38:08.832
on to the wire?

00:38:08.832 --> 00:38:10.290
Well, typically
the way we do it is

00:38:10.290 --> 00:38:12.380
we have some clock
signal that tells us

00:38:12.380 --> 00:38:14.100
when the next bit
should be, we should

00:38:14.100 --> 00:38:16.270
start sending the
next bit on the wire.

00:38:16.270 --> 00:38:19.940
So we might have some protocol
that says something like,

00:38:19.940 --> 00:38:23.367
every time there is a rising
edge in the clock signal,

00:38:23.367 --> 00:38:24.950
we'll start transmitting
the next bit.

00:38:24.950 --> 00:38:27.760
So, what does that mean?

00:38:27.760 --> 00:38:29.975
So a rising edge --

00:38:39.190 --> 00:38:42.950
OK, so suppose this is our
clock and this is our data.

00:38:42.950 --> 00:38:45.590
And what I've just shown here is
that every time a clock signal

00:38:45.590 --> 00:38:47.749
goes high, we start
sending in new bit.

00:38:47.749 --> 00:38:50.290
OK, so every time we go from
low to high in the clock signal,

00:38:50.290 --> 00:38:52.800
we start putting a
new bit on the wire.

00:38:52.800 --> 00:38:55.930
So, now it's going to
happen is oftentimes

00:38:55.930 --> 00:38:58.520
the way the network
connections are

00:38:58.520 --> 00:39:02.800
connected is what's a
so-called serial connection.

00:39:02.800 --> 00:39:05.016
So we have one wire that's
transmitting the data.

00:39:05.016 --> 00:39:06.390
And we don't have
a separate wire

00:39:06.390 --> 00:39:08.160
that includes the clock signal.

00:39:08.160 --> 00:39:11.540
We just sort of transmit
the data out over the wire.

00:39:11.540 --> 00:39:13.740
So if you were to
look at this data

00:39:13.740 --> 00:39:15.760
as it comes down the
serial connection,

00:39:15.760 --> 00:39:23.550
at the receiver, what it would
look like is something that

00:39:23.550 --> 00:39:25.346
was sort of, it's not
going to look exactly

00:39:25.346 --> 00:39:27.470
like these nice square
pulse was that we have here.

00:39:27.470 --> 00:39:29.110
It's going to have
decayed somewhat.

00:39:29.110 --> 00:39:35.370
So it might look
something like is

00:39:35.370 --> 00:39:38.550
each of these nice square
waves might have sort of become

00:39:38.550 --> 00:39:43.010
a somewhat decayed version
of their former selves, OK?

00:39:43.010 --> 00:39:45.900
And now the question
we have is, OK,

00:39:45.900 --> 00:39:47.590
how are we going to
decode this, right?

00:39:47.590 --> 00:39:49.600
So we don't have access
to the original clock

00:39:49.600 --> 00:39:50.850
signal that was used.

00:39:50.850 --> 00:39:53.750
But we may know what
frequency, would

00:39:53.750 --> 00:39:55.080
rate this data was encoded at.

00:39:55.080 --> 00:39:57.840
So we may be able to generate
a comparable clock signal.

00:39:57.840 --> 00:40:04.920
So suppose we generate
a clock signal that's

00:40:04.920 --> 00:40:09.230
about the same frequency,
and then try and use

00:40:09.230 --> 00:40:11.480
that to decode the message,
say, by looking again

00:40:11.480 --> 00:40:13.266
at the rising edges.

00:40:13.266 --> 00:40:14.640
If we're not
careful, we're going

00:40:14.640 --> 00:40:15.890
to get something that's wrong.

00:40:15.890 --> 00:40:18.550
So in this case, I transmitted
one, zero, one, zero,

00:40:18.550 --> 00:40:20.700
but now I'm decoding
something that's

00:40:20.700 --> 00:40:21.920
shifted from that somewhat.

00:40:21.920 --> 00:40:24.610
So I'm decoding
zero, one, zero, one.

00:40:24.610 --> 00:40:28.792
So, I've sort of become
offset because the two clock

00:40:28.792 --> 00:40:30.500
signals aren't actually
identical, right?

00:40:30.500 --> 00:40:32.070
Even though they're
at the same frequency,

00:40:32.070 --> 00:40:34.670
they are not specifically lined
up with each other in time.

00:40:34.670 --> 00:40:36.970
So we say that those
signals are out of phase.

00:40:36.970 --> 00:40:43.340
So one signal is
essentially a time shifted

00:40:43.340 --> 00:40:46.550
version of the other signal.

00:40:46.550 --> 00:40:49.170
OK, and this time shifting
leads to these kinds of problems

00:40:49.170 --> 00:40:52.980
where we don't properly decode
the message because we're not

00:40:52.980 --> 00:40:55.150
sampling the channel at
the right point in time.

00:40:55.150 --> 00:40:56.490
We're not looking at
the channel to see

00:40:56.490 --> 00:40:57.531
whether it's high or low.

00:41:01.400 --> 00:41:03.890
OK, so how are we
going to fix this?

00:41:03.890 --> 00:41:06.740
It turns out that there's sort
of a simple and elegant way

00:41:06.740 --> 00:41:08.370
that's often used to fix this.

00:41:08.370 --> 00:41:10.735
And it's what's called a
phase lock loop or a PLL.

00:41:13.530 --> 00:41:16.700
So a phase lock loop,
a very simple way

00:41:16.700 --> 00:41:19.679
that you can implement a
phase lock loop is as follows.

00:41:19.679 --> 00:41:21.220
So the idea here is
that what we want

00:41:21.220 --> 00:41:23.460
to do is we want to figure
out, we want and make it

00:41:23.460 --> 00:41:28.150
so that the receiver has
essentially a lined up version

00:41:28.150 --> 00:41:29.234
of the transmitters clock.

00:41:29.234 --> 00:41:30.733
So we need to figure
out how much we

00:41:30.733 --> 00:41:32.770
need to shift the
receiver's clock in order

00:41:32.770 --> 00:41:34.770
to make it line up with
the transmitter's clock.

00:41:34.770 --> 00:41:37.070
And once we do that, then
hopefully we will properly

00:41:37.070 --> 00:41:38.861
decode the message
instead of being shifted

00:41:38.861 --> 00:41:40.325
when we decode the message.

00:41:40.325 --> 00:41:42.700
So the idea with a phase lock
loop is kind of as follows.

00:41:42.700 --> 00:41:45.290
Suppose we have our
signal like this.

00:41:48.029 --> 00:41:49.820
A simple way to implement
a phase lock loop

00:41:49.820 --> 00:41:54.720
is to take this signal
and to sample it

00:41:54.720 --> 00:41:59.260
not once per clock, but some
multiple number of times

00:41:59.260 --> 00:42:01.050
per clock period, OK?

00:42:01.050 --> 00:42:03.580
We call this oversampling.

00:42:03.580 --> 00:42:06.020
We might, say for
example, do eight times

00:42:06.020 --> 00:42:07.500
oversampling on this.

00:42:10.500 --> 00:42:14.060
OK, so what that means is if
we were perfectly lined up

00:42:14.060 --> 00:42:16.380
in time on this
oversampled signal,

00:42:16.380 --> 00:42:21.524
and we were encoding a one as
a high, and a zero as a low,

00:42:21.524 --> 00:42:23.690
then what we would see if
we were perfectly lined up

00:42:23.690 --> 00:42:27.440
is alternating sequences of
eight zeroes and eight ones,

00:42:27.440 --> 00:42:28.930
right?

00:42:28.930 --> 00:42:30.550
So, if instead we
start decoding this

00:42:30.550 --> 00:42:32.341
and we see something
that's not quite that,

00:42:32.341 --> 00:42:35.630
suppose we see three
ones followed by eight

00:42:35.630 --> 00:42:40.170
zeroes followed by five ones.

00:42:40.170 --> 00:42:43.680
OK, so we decode two bits worth
of information off the wire,

00:42:43.680 --> 00:42:46.660
and we see that it's sort
of shifted in this way.

00:42:46.660 --> 00:42:50.400
OK, that suggests that I
need to shift the signal

00:42:50.400 --> 00:42:51.530
to the left some amount.

00:42:51.530 --> 00:42:54.110
OK, and so this is exactly
what the phase lock loop does

00:42:54.110 --> 00:42:56.096
is it observed the
signal as it's coming in,

00:42:56.096 --> 00:42:57.470
and it computes
an amount that we

00:42:57.470 --> 00:43:00.520
need to shift the signal in
one direction or the other.

00:43:00.520 --> 00:43:04.160
OK, so if you wanted to make
a sort of schematic for how

00:43:04.160 --> 00:43:08.390
a phase lock loop works, we have
our sender and the receiver.

00:43:08.390 --> 00:43:09.640
The idea is simply as follows.

00:43:09.640 --> 00:43:12.250
You have some data
at the sender,

00:43:12.250 --> 00:43:14.890
and a clock at the sender.

00:43:14.890 --> 00:43:20.560
Those go into some encoder box.

00:43:20.560 --> 00:43:22.530
They are transmitted
out over a line

00:43:22.530 --> 00:43:27.340
to the receiver, which
has a decoder box.

00:43:27.340 --> 00:43:30.200
OK, but the decoder box
needs a clock signal

00:43:30.200 --> 00:43:33.040
that's been lined up with the
sender's clock signal, OK?

00:43:33.040 --> 00:43:36.040
So we're going to do is use
our phase lock loop to do that.

00:43:36.040 --> 00:43:38.510
So the phase lock
loop is going to take

00:43:38.510 --> 00:43:46.180
in the incoming signal as
well as the unaligned clock

00:43:46.180 --> 00:43:48.980
from the local machine.

00:43:48.980 --> 00:43:53.350
And it's going to input into
the decoder an aligned clock

00:43:53.350 --> 00:43:54.290
signal.

00:43:54.290 --> 00:43:56.500
OK, so basically
what's going to happen

00:43:56.500 --> 00:43:58.910
is this PLL is going to be
able to reconstruct the clock

00:43:58.910 --> 00:44:00.390
signal from the sender.

00:44:00.390 --> 00:44:02.770
Of course, it takes a little
bit of time for the PLL

00:44:02.770 --> 00:44:04.221
to reconstruct the clock signal.

00:44:04.221 --> 00:44:06.720
So usually what we do is every
message that we transmit over

00:44:06.720 --> 00:44:09.700
the link, we have some sort
of set of synchronization bits

00:44:09.700 --> 00:44:12.370
at the beginning of it
that we use in order

00:44:12.370 --> 00:44:15.170
to allow the phase
lock loop to lock in

00:44:15.170 --> 00:44:18.000
to the phase of the
signals being transmitted.

00:44:18.000 --> 00:44:20.430
And that preamble doesn't
carry any data bytes.

00:44:20.430 --> 00:44:22.080
It's simply sort
of overhead that's

00:44:22.080 --> 00:44:24.800
on every packet to guarantee
that the sender and receiver's

00:44:24.800 --> 00:44:28.150
clock synchronize
with each other.

00:44:28.150 --> 00:44:32.510
So there is one
last little detail

00:44:32.510 --> 00:44:36.660
associated with phase lock loops
that you guys may have noticed.

00:44:36.660 --> 00:44:38.440
So the issue is that
the signal that I've

00:44:38.440 --> 00:44:41.520
shown being transmitted here
is a one, zero, one, zero, one,

00:44:41.520 --> 00:44:42.675
zero signal, right?

00:44:42.675 --> 00:44:44.800
But if you think about the
way that this phase lock

00:44:44.800 --> 00:44:47.800
loop works, what the
phase lock loop does

00:44:47.800 --> 00:44:50.920
is it looks for these transition
points in the signal, right?

00:44:50.920 --> 00:44:53.130
So it looks for points
where the signal changes

00:44:53.130 --> 00:44:55.047
from a one to a zero, right?

00:44:55.047 --> 00:44:57.130
So suppose that instead
of transmitting one, zero,

00:44:57.130 --> 00:45:00.250
I transmitted zero, zero, zero,
zero, zero, zero, zero, right?

00:45:00.250 --> 00:45:01.960
Then the problem I'm
going to have is I'm

00:45:01.960 --> 00:45:04.001
just going to have a very
long sequence of zeroes

00:45:04.001 --> 00:45:06.099
even if I do this eight
times over sampling.

00:45:06.099 --> 00:45:08.390
I'm still just going to have
a long sequence of zeroes,

00:45:08.390 --> 00:45:10.726
and I'm not going to
know how much I need

00:45:10.726 --> 00:45:11.850
to shift the signal, right?

00:45:11.850 --> 00:45:13.391
I'm going to have
no way of computing

00:45:13.391 --> 00:45:14.970
how much I need to
shift the signal.

00:45:14.970 --> 00:45:17.920
So it turns out there's a very
simple and kind of elegant

00:45:17.920 --> 00:45:20.440
solution to this called
Manchester encoding.

00:45:27.100 --> 00:45:30.540
And the idea with Manchester
encoding is as follows.

00:45:30.540 --> 00:45:33.380
It says will transmit
a zero as a transition

00:45:33.380 --> 00:45:35.850
from a low to high, and
we'll transmit a one

00:45:35.850 --> 00:45:39.050
as a transition from
a high to a low.

00:45:39.050 --> 00:45:42.190
OK, so now if I transmit
a signal like one,

00:45:42.190 --> 00:45:45.950
zero, one, if I transmit the
signal: zero, zero, zero,

00:45:45.950 --> 00:45:49.030
it simply looks like this.

00:45:49.030 --> 00:45:52.210
So, zero is a transition
from a low to high

00:45:52.210 --> 00:45:55.460
followed by another transition
from a low to a high.

00:45:55.460 --> 00:45:58.170
OK, so now this is zero,
zero, zero, zero, right?

00:45:58.170 --> 00:46:01.840
And if I transmit the
signal, zero, one, zero,

00:46:01.840 --> 00:46:04.570
this is a transition from
a low to a high followed

00:46:04.570 --> 00:46:06.820
by a transition from a
high to a low followed

00:46:06.820 --> 00:46:09.930
by a transition from
a low to a high, OK?

00:46:09.930 --> 00:46:13.570
So now we have a way that we can
guarantee that every bit as it

00:46:13.570 --> 00:46:14.700
least one transition in it.

00:46:14.700 --> 00:46:16.130
And that's going to
allow our phase lock

00:46:16.130 --> 00:46:18.270
loop to look into the
face of the signal that's

00:46:18.270 --> 00:46:20.090
being transmitted.

00:46:20.090 --> 00:46:24.934
Of course, the cost of
this is that we've now

00:46:24.934 --> 00:46:26.350
doubled the number,
sort of, we've

00:46:26.350 --> 00:46:28.402
doubled, every bit as a
transition in it, right?

00:46:28.402 --> 00:46:30.860
So we sort of have the number
of bits that we can send over

00:46:30.860 --> 00:46:32.940
the channel because
instead of a one

00:46:32.940 --> 00:46:36.940
being simply a low, or a one
simply being a high and a zero

00:46:36.940 --> 00:46:39.510
being a low, now everything
is both a high and a low.

00:46:39.510 --> 00:46:41.450
So we have the amount
of data that we

00:46:41.450 --> 00:46:42.730
can send on the channel.

00:46:42.730 --> 00:46:45.450
But we've sort of
gotten this wind

00:46:45.450 --> 00:46:48.070
that now we can have the
phase lock loop actually work.

00:46:48.070 --> 00:46:50.070
And so turns out Manchester
encoding is actually

00:46:50.070 --> 00:46:50.872
commonly used.

00:46:50.872 --> 00:46:52.580
There are other encoding
schemes that you

00:46:52.580 --> 00:46:55.430
can use that are sort of less
wasteful of channel bandwidth,

00:46:55.430 --> 00:46:57.600
but operate on the
same principle,

00:46:57.600 --> 00:47:02.030
trying to introduce extra
transitions when possible.

00:47:02.030 --> 00:47:07.522
So this basically wraps up our
discussion of the link layer.

00:47:07.522 --> 00:47:09.230
What we're going to
talk about next time,

00:47:09.230 --> 00:47:11.460
are going to start talking about
how the network layer works.

00:47:11.460 --> 00:47:13.210
And we're going to
basically talk about

00:47:13.210 --> 00:47:16.940
how Internet routing
actually functions,

00:47:16.940 --> 00:47:21.327
and how these routers
actually decide which

00:47:21.327 --> 00:47:23.660
link they should use to
transmit the next message around

00:47:23.660 --> 00:47:24.310
in the network.

00:47:24.310 --> 00:47:28.700
So, that's it for this time,
and we'll see you on Wednesday.

