WEBVTT
Kind: captions
Language: en

00:00:06.230 --> 00:00:07.570
TONY CHAN: Hi, everyone.

00:00:07.570 --> 00:00:12.630
Sorry again for the technical
difficulty earlier.

00:00:12.630 --> 00:00:19.570
So I hope now everyone can see
everything OK and no echo.

00:00:19.570 --> 00:00:22.030
So let's jump straight
to the news.

00:00:24.810 --> 00:00:32.590
So the news of this week,
so we have new devices.

00:00:32.590 --> 00:00:38.430
So we just announced this
week, the Nexus 4.

00:00:38.430 --> 00:00:44.320
It's a Quad core Snapdragon S4
with a Snapdragon processor

00:00:44.320 --> 00:00:48.030
with the largest 4.7
inch screen.

00:00:48.030 --> 00:00:50.930
And it has NFC, actually, which
is what we are going to

00:00:50.930 --> 00:00:53.780
talk about today.

00:00:53.780 --> 00:00:55.960
We have also another
new device.

00:00:55.960 --> 00:00:57.735
It's a 10 inch device.

00:00:57.735 --> 00:01:00.350
It has a super high
resolution--

00:01:00.350 --> 00:01:02.350
it's 2560.

00:01:02.350 --> 00:01:08.530
And so I'm sure you guys can
read more about these two

00:01:08.530 --> 00:01:11.480
devices on the internet.

00:01:11.480 --> 00:01:16.280
And of course, the new version
of Android 4.2, we just

00:01:16.280 --> 00:01:17.490
announced it.

00:01:17.490 --> 00:01:23.270
And along with that, we have
also pretty good guidelines of

00:01:23.270 --> 00:01:28.730
how to build high quality tablet
applications, and also

00:01:28.730 --> 00:01:30.960
in general high quality
applications.

00:01:30.960 --> 00:01:35.420
So we added some more
documentation guidelines to

00:01:35.420 --> 00:01:38.606
help developers to build high
quality applications.

00:01:42.070 --> 00:01:45.470
Another major news we
have, we now have

00:01:45.470 --> 00:01:48.440
seller support in India.

00:01:48.440 --> 00:01:53.320
You can read more about that
in the blog post, but just

00:01:53.320 --> 00:01:57.700
want to clarify something.

00:01:57.700 --> 00:02:02.260
The seller support also includes
in-app billing.

00:02:02.260 --> 00:02:04.645
And subscriptions are
also included.

00:02:08.940 --> 00:02:14.090
The Google+ experiment
we announced earlier.

00:02:14.090 --> 00:02:18.550
So we still need to gather
all the submissions.

00:02:18.550 --> 00:02:22.120
And we will follow up with
you guys next week.

00:02:22.120 --> 00:02:23.550
So stay tuned.

00:02:27.360 --> 00:02:31.420
So now back to our
presentation this

00:02:31.420 --> 00:02:34.250
week, which is NFC.

00:02:34.250 --> 00:02:39.280
So let's take a look
at what NFC is.

00:02:39.280 --> 00:02:43.410
Just before we dive into the
implementation details, so

00:02:43.410 --> 00:02:48.440
let's take a high-level overview
of what NFC is.

00:02:48.440 --> 00:02:52.940
So NFC stands for Near
Field Communication.

00:02:52.940 --> 00:02:57.110
It's really based on the
RFID technology.

00:02:57.110 --> 00:03:01.530
It's a short-range technology.

00:03:01.530 --> 00:03:12.670
So usually when the device to
the NFC tech card is between 4

00:03:12.670 --> 00:03:14.780
centimeters or less,

00:03:14.780 --> 00:03:19.230
communication will start happening.

00:03:19.230 --> 00:03:24.470
You can also share a small
payload, usually in kilobytes,

00:03:24.470 --> 00:03:31.020
between NFC tags and an Android
device, or between

00:03:31.020 --> 00:03:32.270
Android devices.

00:03:34.310 --> 00:03:42.450
So the most common data format
people use for NFC is NDEF.

00:03:42.450 --> 00:03:44.580
Also, we will talk a little
bit more about

00:03:44.580 --> 00:03:48.610
that in future slides.

00:03:48.610 --> 00:03:52.360
So what is NFC for?

00:03:52.360 --> 00:03:55.570
Actually, you can use NFC
for a couple of things.

00:03:55.570 --> 00:03:58.310
The first one is social.

00:03:58.310 --> 00:04:02.940
I mean, you can share contact
information using NFC, which

00:04:02.940 --> 00:04:06.110
is one of the most
common use cases.

00:04:06.110 --> 00:04:11.800
And also, you can use NFC to do
bootstrapping for Bluetooth

00:04:11.800 --> 00:04:13.440
and Wi-Fi connections.

00:04:13.440 --> 00:04:18.170
So Anirudh will talk a little
bit more about that, and also

00:04:18.170 --> 00:04:20.589
the Android technology,
Android Beam.

00:04:20.589 --> 00:04:25.190
So Anirudh will cover
that later on.

00:04:25.190 --> 00:04:30.370
And the third use case of
NFC is in commerce--

00:04:30.370 --> 00:04:35.680
so for example, contact-less
payment like Google Wallet.

00:04:35.680 --> 00:04:42.210
But that is a little bit outside
of our topic today

00:04:42.210 --> 00:04:45.510
because Google Wallet
requires the access

00:04:45.510 --> 00:04:46.760
to the secure element.

00:04:46.760 --> 00:04:51.570
And if you are interested in
becoming a partner of Google

00:04:51.570 --> 00:04:58.870
Wallet, you can go to the link
below here to send us

00:04:58.870 --> 00:05:00.780
information.

00:05:00.780 --> 00:05:03.620
But that's not something
we're going to cover

00:05:03.620 --> 00:05:05.410
today, Google Wallet.

00:05:05.410 --> 00:05:09.870
We're going to focus on
the technology today.

00:05:09.870 --> 00:05:15.750
So for NFC, there are a few
communication protocols.

00:05:15.750 --> 00:05:19.040
So these are the protocols.

00:05:19.040 --> 00:05:22.600
So I'm not going to spell
out all of these

00:05:22.600 --> 00:05:25.100
ISO standards here.

00:05:25.100 --> 00:05:33.280
But the key thing here is we
have Android classes to talk

00:05:33.280 --> 00:05:35.380
to these protocols.

00:05:35.380 --> 00:05:40.550
and so I kind of highlight that
with the bullets here.

00:05:43.220 --> 00:05:47.730
And besides the protocol,
we have different

00:05:47.730 --> 00:05:51.910
types of NFC tags.

00:05:51.910 --> 00:06:01.710
So the standard ones defined
in the NFC forum, there are

00:06:01.710 --> 00:06:02.970
four major types.

00:06:02.970 --> 00:06:07.010
And there are products,
actually, implementing these

00:06:07.010 --> 00:06:09.380
different types.

00:06:09.380 --> 00:06:15.400
So some of the more common ones,
probably that you guys

00:06:15.400 --> 00:06:22.280
see most, are the MIFARE ones
and the Sony FeliCa one.

00:06:22.280 --> 00:06:26.530
But there are four major
types of tags in NFC.

00:06:30.000 --> 00:06:35.110
I have actually a very nice
table to summarize all these,

00:06:35.110 --> 00:06:36.930
to put things together.

00:06:36.930 --> 00:06:38.970
So stay tuned.

00:06:38.970 --> 00:06:43.160
And besides the NFC forum
standards, there are also

00:06:43.160 --> 00:06:45.710
other types of tags.

00:06:45.710 --> 00:06:49.660
So the MIFARE Classic
one is one of them.

00:06:49.660 --> 00:06:54.640
And it's also very popular--

00:06:54.640 --> 00:07:00.040
NXP is using this type of tag.

00:07:00.040 --> 00:07:03.590
And there's additional operation
you can do with

00:07:03.590 --> 00:07:04.670
these tags.

00:07:04.670 --> 00:07:07.750
And we have a special class,
actually, for these also,

00:07:07.750 --> 00:07:09.000
called MifareClassic.

00:07:11.980 --> 00:07:16.630
So what is NDEF?

00:07:16.630 --> 00:07:26.080
So we talked about formats of
data we use in NFC, and I

00:07:26.080 --> 00:07:30.390
mentioned NDEF is the most
common standard.

00:07:30.390 --> 00:07:35.900
So NDEF actually stands for
NFC Data Exchange Format.

00:07:35.900 --> 00:07:41.210
It's really a lightweight
binary message format.

00:07:41.210 --> 00:07:47.620
And one thing about NDEF is an
NDEF message can have many

00:07:47.620 --> 00:07:49.710
NDEF records.

00:07:49.710 --> 00:07:55.840
And for data with an
application-defined payload

00:07:55.840 --> 00:08:00.640
can be actually encapsulated in
one or more NDEF records.

00:08:04.530 --> 00:08:09.170
So let's take a look at the NDEF
record, talk a bit more

00:08:09.170 --> 00:08:10.880
about that in detail.

00:08:10.880 --> 00:08:14.600
So an NDEF record is composed
of a header and a payload.

00:08:14.600 --> 00:08:21.240
So in the header, it has a
3-bit Type Name Format.

00:08:21.240 --> 00:08:24.420
And it also has the
type itself--

00:08:24.420 --> 00:08:26.370
it's in variable length.

00:08:26.370 --> 00:08:30.180
It's from 0 to 255 bytes.

00:08:30.180 --> 00:08:32.429
And the same thing for the ID.

00:08:32.429 --> 00:08:36.980
It's optional and not
very often used.

00:08:36.980 --> 00:08:38.510
And then the payload.

00:08:38.510 --> 00:08:43.990
The payload can actually have
data up to 2 to the power of

00:08:43.990 --> 00:08:47.260
32 minus 1 byte.

00:08:47.260 --> 00:08:49.380
So that's the structure
of the NDEF record.

00:08:52.240 --> 00:08:56.110
So here's the big picture side,
a summary of all the

00:08:56.110 --> 00:09:01.100
relationship between
all the classes.

00:09:01.100 --> 00:09:06.270
So if you look at the NFC stack,
so you have the analog

00:09:06.270 --> 00:09:07.530
things at the bottom.

00:09:07.530 --> 00:09:09.620
And then you have the different

00:09:09.620 --> 00:09:13.160
communication protocols.

00:09:13.160 --> 00:09:15.900
And there are two
major types of

00:09:15.900 --> 00:09:19.200
applications people can build.

00:09:19.200 --> 00:09:25.970
So one is using the standard
NDEF message format.

00:09:25.970 --> 00:09:32.610
And within that, you have the
NFC forum standard Type 1 to

00:09:32.610 --> 00:09:39.720
Type 4 tag and also have
the MIFARE Classic tag.

00:09:39.720 --> 00:09:45.590
And the stuff in blue is
actually the Android classes

00:09:45.590 --> 00:09:50.620
we have to the implementation
for those

00:09:50.620 --> 00:09:55.120
particular types of tags.

00:09:55.120 --> 00:10:01.260
And for non-NDEF format
applications, we also have the

00:10:01.260 --> 00:10:11.160
corresponding classes to allow
a developer to talk directly

00:10:11.160 --> 00:10:12.220
through the protocol.

00:10:12.220 --> 00:10:18.900
So we have all these NFCA class,
which corresponds to

00:10:18.900 --> 00:10:25.300
the ISO 14443-3A protocol,
and et cetera.

00:10:25.300 --> 00:10:31.470
So it's mapping these route
protocols if the application

00:10:31.470 --> 00:10:35.830
is not using the NDEF
data format.

00:10:35.830 --> 00:10:41.460
So that's a nice summary of
all these things together.

00:10:44.280 --> 00:10:53.510
So now let's start to talk about
how Android actually

00:10:53.510 --> 00:10:59.260
reads these tags and then how to
dispatch these tags to your

00:10:59.260 --> 00:11:00.980
applications.

00:11:00.980 --> 00:11:09.460
So again, the two major
categories, one is the tag

00:11:09.460 --> 00:11:14.310
using the NDEF format, and the
other one is using the

00:11:14.310 --> 00:11:15.830
non-NDEF format.

00:11:15.830 --> 00:11:25.600
So we have different action
types, essentially

00:11:25.600 --> 00:11:27.850
following the order.

00:11:27.850 --> 00:11:32.670
We first try to see whether
something matched the NDEF

00:11:32.670 --> 00:11:33.770
data format first.

00:11:33.770 --> 00:11:37.290
So we have an action called
NDEF discover.

00:11:37.290 --> 00:11:44.010
So if there is an activity that
matched that action, we

00:11:44.010 --> 00:11:49.810
will route the intent
to that application.

00:11:49.810 --> 00:11:53.610
So we will see some example
of how to set up these

00:11:53.610 --> 00:11:54.980
[INAUDIBLE]

00:11:54.980 --> 00:11:56.410
in your application later.

00:11:58.920 --> 00:12:04.660
So back to the picture, if the
NDEF discover action, we don't

00:12:04.660 --> 00:12:11.110
see any NDEF-format tag, we
will fall back to the tag

00:12:11.110 --> 00:12:17.240
discover actions and then to
the tag discover actions.

00:12:17.240 --> 00:12:26.400
So this is how the Android
decision tree to decide how to

00:12:26.400 --> 00:12:36.290
dispatch all the NFC tag
it reads from the fail.

00:12:36.290 --> 00:12:42.680
So now, how to request NFC
access in the application?

00:12:42.680 --> 00:12:49.390
So as you guys probably can
imagine, this definitely has

00:12:49.390 --> 00:12:51.450
something to do with
the manifest.

00:12:51.450 --> 00:12:55.280
So the first thing you need
to do is to add a special

00:12:55.280 --> 00:12:56.520
permission.

00:12:56.520 --> 00:12:59.920
It's android.permission.nfc.

00:12:59.920 --> 00:13:05.170
And for filtering application
in Google Play, you want to

00:13:05.170 --> 00:13:12.570
use the feature use_feature tag
specifying the hardware.

00:13:12.570 --> 00:13:16.260
So if NFC is really an optional
feature in your

00:13:16.260 --> 00:13:22.390
application, you can consider
setting the required

00:13:22.390 --> 00:13:24.340
attribute to false.

00:13:24.340 --> 00:13:30.930
And you can also check NFC
runtime availability by using

00:13:30.930 --> 00:13:32.900
the getDefaultAdapter()
method.

00:13:32.900 --> 00:13:37.930
If it equals null, that means
NFC is not available in that

00:13:37.930 --> 00:13:39.180
particular device.

00:13:42.610 --> 00:13:49.150
So another thing is you have to
set the minimum SDK version

00:13:49.150 --> 00:13:50.170
in your application.

00:13:50.170 --> 00:13:56.460
So the minimum SDK version that
will have NFC support is

00:13:56.460 --> 00:13:58.340
API level nine.

00:13:58.340 --> 00:14:01.450
So in this level, we
will support the

00:14:01.450 --> 00:14:11.400
ACTION_TAG_DISCOVERED action,
but we recommend developers to

00:14:11.400 --> 00:14:15.140
at least specify level 10,
because it has a much more

00:14:15.140 --> 00:14:18.620
comprehensive read/write
support in level 10.

00:14:18.620 --> 00:14:24.010
And also you can do foreground
NDEF pushing.

00:14:24.010 --> 00:14:30.050
In API level 14, we added
Android Beam support and also

00:14:30.050 --> 00:14:36.600
some extra convenience methods
to create NDEF records.

00:14:36.600 --> 00:14:43.440
So at least use API level 10.

00:14:43.440 --> 00:14:44.715
That's our recommendation.

00:14:47.520 --> 00:14:49.200
So filtering--

00:14:49.200 --> 00:14:54.130
let's take a look at how you
set up your activity to

00:14:54.130 --> 00:14:56.235
capture these NFC intents.

00:15:00.130 --> 00:15:02.960
So one of the actions you
can filter by is the

00:15:02.960 --> 00:15:06.920
NDEF_DISCOVERED action.

00:15:06.920 --> 00:15:10.250
In this example here, you
can filter by MIME type.

00:15:10.250 --> 00:15:18.930
So you can specify if the MIME
type is plain text, you have a

00:15:18.930 --> 00:15:24.730
data tag and specify the MIME
type, that's how you filter

00:15:24.730 --> 00:15:26.010
NFC message--

00:15:26.010 --> 00:15:27.740
by MIME type.

00:15:27.740 --> 00:15:31.920
And if you want to do
filtering by URI,

00:15:31.920 --> 00:15:33.840
you can also do that.

00:15:33.840 --> 00:15:41.360
So it has a different data tag,
specifying the host or

00:15:41.360 --> 00:15:42.985
prefix of your URI.

00:15:47.840 --> 00:15:49.396
And the next actions--

00:15:53.370 --> 00:16:01.250
after the dispatch system
couldn't find a match on the

00:16:01.250 --> 00:16:05.200
NDEF_DISCOVERED action, we'll
fall back to this

00:16:05.200 --> 00:16:07.020
TECH_DISCOVERED action.

00:16:07.020 --> 00:16:11.110
And in order for this to work,
your application has to

00:16:11.110 --> 00:16:16.270
specify an XML resource file
to specify the list of

00:16:16.270 --> 00:16:20.370
technology the NFC tag
you're reading--

00:16:20.370 --> 00:16:23.530
your application--

00:16:23.530 --> 00:16:29.060
the list of NFC technology has
to support before your

00:16:29.060 --> 00:16:35.260
application can process the
NFC tag information.

00:16:35.260 --> 00:16:39.900
So in this case here, what you
are trying to say here is your

00:16:39.900 --> 00:16:47.075
application will only take NFC
tag that can support the

00:16:47.075 --> 00:16:51.190
entire list of NFC technology.

00:16:51.190 --> 00:16:55.120
So it's a pretty long
list of things.

00:16:55.120 --> 00:16:59.810
I think in reality, you only
want to specify a field,

00:16:59.810 --> 00:17:03.310
because this is really
end cases.

00:17:03.310 --> 00:17:08.460
So you're trying to find
something that supports all of

00:17:08.460 --> 00:17:09.694
these technologies--

00:17:09.694 --> 00:17:11.660
it's not all.

00:17:11.660 --> 00:17:17.319
So how to do an all
in the tag lists--

00:17:17.319 --> 00:17:22.369
so if you specify multiple
resources, like this example

00:17:22.369 --> 00:17:29.000
here, so you're trying
to filter something.

00:17:29.000 --> 00:17:36.340
If the NFC tag is supporting
NFCA and NDEF and all is

00:17:36.340 --> 00:17:43.100
supporting NFCB or NDEF, both
of them will match, and your

00:17:43.100 --> 00:17:48.350
applications can serve both
of these NFC cards.

00:17:48.350 --> 00:17:53.200
So if you need to use the all
semantics, this is the way how

00:17:53.200 --> 00:17:55.840
you define the tech list.

00:18:00.230 --> 00:18:10.540
So another fallback is using
the TECH_DISCOVERED in your

00:18:10.540 --> 00:18:16.000
activity, you pretty much just
filter by the TECH_DISCOVERED

00:18:16.000 --> 00:18:18.130
tech actions.

00:18:18.130 --> 00:18:26.060
And then you add the metadata
tag, pointing to the

00:18:26.060 --> 00:18:27.740
resource XML file.

00:18:27.740 --> 00:18:32.473
So this is how you include the
filter in your manifest.

00:18:41.720 --> 00:18:48.260
So did I miss--

00:18:48.260 --> 00:18:49.510
OK.

00:18:51.180 --> 00:18:54.770
So how to obtain information
from the intent.

00:18:54.770 --> 00:18:57.380
So it's pretty straightforward.

00:18:57.380 --> 00:18:59.150
There are two ways
you can do it.

00:19:01.870 --> 00:19:07.590
If you want to have the NFC
tag, you can always do the

00:19:07.590 --> 00:19:14.800
getParcelable data extra,
calling the EXTRA_TAG.

00:19:14.800 --> 00:19:19.190
And it will return you a tag,
and you can just look through

00:19:19.190 --> 00:19:22.520
and get them to find out
the list of technology.

00:19:22.520 --> 00:19:25.200
But there's also a very
convenient way.

00:19:25.200 --> 00:19:31.350
If you know you are only
processing NFC tech using the

00:19:31.350 --> 00:19:41.236
NDEF data format, you can use
the NDEF_MESSAGES extra to get

00:19:41.236 --> 00:19:46.590
a list of NDEF messages.

00:19:46.590 --> 00:19:48.000
So the [INAUDIBLE]

00:19:48.000 --> 00:19:53.470
here is really an example of how
you get the NDEF messages.

00:19:53.470 --> 00:20:02.010
So you pretty much get a list
of parcelable, and then you

00:20:02.010 --> 00:20:08.480
[? cast ?] these raw messages
to the NDEF message to just

00:20:08.480 --> 00:20:09.730
look through it.

00:20:13.980 --> 00:20:18.430
So the next session, Anirudh
is going to talk

00:20:18.430 --> 00:20:19.670
about Android Beam.

00:20:19.670 --> 00:20:21.680
So I pass it to Anirudh.

00:20:25.408 --> 00:20:25.880
ANIRUDH DEWANI: All right.

00:20:25.880 --> 00:20:27.630
Thanks, Tony.

00:20:27.630 --> 00:20:29.700
So to begin with, what's
Android Beam?

00:20:29.700 --> 00:20:32.570
It's something that's based on
something called NFC NDEF

00:20:32.570 --> 00:20:33.210
Message Push.

00:20:33.210 --> 00:20:36.780
So this is about pushing
messages from an app that's

00:20:36.780 --> 00:20:39.190
running on the foreground, an
activity that's running on the

00:20:39.190 --> 00:20:43.070
foreground to another activity
running on another phone.

00:20:43.070 --> 00:20:46.760
So that's the push
part aspect--

00:20:46.760 --> 00:20:50.480
TONY CHAN: By the way, can you
guys see the slide when

00:20:50.480 --> 00:20:52.346
Anirudh talks?

00:20:52.346 --> 00:20:53.220
MALE SPEAKER 3: I can, Tony.

00:20:53.220 --> 00:20:56.465
TONY CHAN: Andrew, you can?

00:20:56.465 --> 00:20:57.260
How about Andrew?

00:20:57.260 --> 00:20:59.970
Andrew, can you see the slide
when Anirudh talks?

00:21:05.380 --> 00:21:08.030
Andrew, can you see the slide?

00:21:12.820 --> 00:21:14.060
ANIRUDH DEWANI: He
has a [INAUDIBLE]

00:21:14.060 --> 00:21:18.180
message, but he can highlight
it to see.

00:21:18.180 --> 00:21:20.500
So it's probably not
getting recorded.

00:21:20.500 --> 00:21:22.070
Tony, let me do something.

00:21:22.070 --> 00:21:28.950
I will share my desktop
instead.

00:21:28.950 --> 00:21:30.200
TONY CHAN: OK.

00:21:58.000 --> 00:21:59.710
ANIRUDH DEWANI: All right, I
think we've got my slides on

00:21:59.710 --> 00:22:01.780
the screen now.

00:22:01.780 --> 00:22:05.000
So as I was mentioning,
NFC is based on NDEF

00:22:05.000 --> 00:22:06.960
message push format.

00:22:06.960 --> 00:22:12.360
And it's basically NDEF message,
like Tony explained,

00:22:12.360 --> 00:22:16.220
it's something that contains
zero or more NDEF records, the

00:22:16.220 --> 00:22:21.170
first record being something
that contains the URI or the

00:22:21.170 --> 00:22:24.060
MIME type of the content that
your NDEF message contains.

00:22:24.060 --> 00:22:26.850
For example, if it's an image,
you would have something with

00:22:26.850 --> 00:22:27.850
the image MIME type.

00:22:27.850 --> 00:22:31.620
Or if you have text, you would
set ASCII as the MIME type.

00:22:31.620 --> 00:22:34.060
So that's your zero
position NDEF

00:22:34.060 --> 00:22:35.880
record in the NDEF message.

00:22:35.880 --> 00:22:39.210
Now, this message with these
records is pushed from one

00:22:39.210 --> 00:22:41.450
device when in close
proximity.

00:22:41.450 --> 00:22:43.890
And that's the basic
concept of NFC.

00:22:43.890 --> 00:22:48.136
When you bring devices in close
proximity and when your

00:22:48.136 --> 00:22:51.680
app is running in foreground,
that's when NFC beam is

00:22:51.680 --> 00:22:54.580
activated, and it tries to
push the message from one

00:22:54.580 --> 00:22:55.830
device onto the other one.

00:22:58.700 --> 00:23:02.190
So as a programmer, how do you
enable your app or make your

00:23:02.190 --> 00:23:05.090
app Android Beam capable?

00:23:05.090 --> 00:23:06.470
It's quite simple.

00:23:06.470 --> 00:23:09.360
There are two options of
how you can do that.

00:23:09.360 --> 00:23:12.390
The first one is, you basically
invoke the method

00:23:12.390 --> 00:23:15.050
setNdefMessagePush().

00:23:15.050 --> 00:23:17.210
So when your app is running,
your activity is in the

00:23:17.210 --> 00:23:20.280
foreground, you call this
method, and this method is

00:23:20.280 --> 00:23:25.320
usually used if you have a
static data to be pushed.

00:23:25.320 --> 00:23:26.830
For example, you may want
to push the link

00:23:26.830 --> 00:23:28.980
of your app to download.

00:23:28.980 --> 00:23:31.800
And this is something static,
and this is the method you

00:23:31.800 --> 00:23:34.330
would use when you have to
push that kind of data.

00:23:34.330 --> 00:23:37.390
The other option is that you
can have your activity

00:23:37.390 --> 00:23:41.280
implement something called
CreateNdefMessageCallback.

00:23:41.280 --> 00:23:43.980
And so as soon as your activity
then comes into

00:23:43.980 --> 00:23:48.710
foreground, the system invokes
this method, calls your

00:23:48.710 --> 00:23:50.760
activity back using
this interface.

00:23:50.760 --> 00:23:53.490
And the only method that you
have to implement from this

00:23:53.490 --> 00:23:58.050
interface is the
createNdefMessage method.

00:23:58.050 --> 00:24:00.250
So this method is where you
have to provide the

00:24:00.250 --> 00:24:04.960
implementation of how you create
the message and return

00:24:04.960 --> 00:24:06.370
a message from the method.

00:24:06.370 --> 00:24:09.020
So the framework would invoke
the callback, and

00:24:09.020 --> 00:24:09.860
this method is called.

00:24:09.860 --> 00:24:11.700
And at this point, you
should return the

00:24:11.700 --> 00:24:13.590
created NDEF message.

00:24:13.590 --> 00:24:16.760
So this is more useful when you
want to add some context

00:24:16.760 --> 00:24:18.900
to your NDEF message.

00:24:18.900 --> 00:24:23.480
So depending on what state your
activity is, or maybe,

00:24:23.480 --> 00:24:26.220
for example, if you're on
YouTube and you have some URL

00:24:26.220 --> 00:24:29.240
that you're watching right now
which you want to push to the

00:24:29.240 --> 00:24:31.730
other guy so there is
some context here.

00:24:31.730 --> 00:24:34.630
So you would use this
implementation of using a

00:24:34.630 --> 00:24:38.280
callback and create the NDEF
message appropriately by using

00:24:38.280 --> 00:24:41.290
the context from your activity
and embedding that data onto

00:24:41.290 --> 00:24:45.760
the message and parcelling
that message through.

00:24:45.760 --> 00:24:49.520
And when this is done, what you
get is a callback called

00:24:49.520 --> 00:24:50.770
setNdefPushCompleteCallback.

00:24:52.710 --> 00:24:55.500
This is the callback that's
invoked when the system is

00:24:55.500 --> 00:25:01.090
able to reliably beam the
message to the other device.

00:25:01.090 --> 00:25:04.700
So what we've discussed here,
there's a short snippet of

00:25:04.700 --> 00:25:08.155
code on how it's implemented--

00:25:08.155 --> 00:25:09.590
very simple code.

00:25:09.590 --> 00:25:15.430
OnCreate we set the NDEF
message push callback.

00:25:15.430 --> 00:25:18.040
And this is the other
implementation, which is the

00:25:18.040 --> 00:25:20.900
implementation of implementing
an interface callback.

00:25:20.900 --> 00:25:23.880
So we have a method implemented
here called

00:25:23.880 --> 00:25:26.570
createNdefMessage, which
comes from the create

00:25:26.570 --> 00:25:29.320
NDEF message callback.

00:25:29.320 --> 00:25:34.710
At this point, what we do is we
construct an NDEF message.

00:25:34.710 --> 00:25:40.680
So like we said, NDEF message is
basically an array of zero

00:25:40.680 --> 00:25:42.160
or more NDEF records.

00:25:42.160 --> 00:25:45.600
So in this case, what we do is,
we have this method called

00:25:45.600 --> 00:25:48.310
createMimeRecord, and this
is a custom method.

00:25:48.310 --> 00:25:53.830
So what createMimeRecord does is
basically creates the first

00:25:53.830 --> 00:25:57.250
NDEF record as the MIME
type of the data.

00:25:57.250 --> 00:26:00.800
In this case, ASCII is the
MIME type because we are

00:26:00.800 --> 00:26:03.780
sending some text across.

00:26:03.780 --> 00:26:09.710
So what it does is puts the MIME
type as the first NDEF

00:26:09.710 --> 00:26:13.170
record and then uses the
rest of the message--

00:26:13.170 --> 00:26:16.640
in this case, it's just a text
that says "beam me up." And it

00:26:16.640 --> 00:26:21.460
uses this to add to the payload
of the NDEF message,

00:26:21.460 --> 00:26:24.600
which is the records falling
from index one, two, three,

00:26:24.600 --> 00:26:27.200
and as long as your data is.

00:26:27.200 --> 00:26:29.418
But the first record is
always the MIME type.

00:26:32.110 --> 00:26:34.760
And how do you receive
this Beam message?

00:26:34.760 --> 00:26:37.720
So what we've done
till now is we've

00:26:37.720 --> 00:26:39.275
created the NDEF message.

00:26:39.275 --> 00:26:42.090
And when our activity's in
foreground, the system will

00:26:42.090 --> 00:26:43.420
try to beam this message.

00:26:43.420 --> 00:26:48.240
So on the other device, which
is in close proximity, you

00:26:48.240 --> 00:26:52.910
have to filter your NFC intent
ACTION_NDEF_DISCOVERED.

00:26:52.910 --> 00:26:56.680
This will make sure that the
system knows that you have a

00:26:56.680 --> 00:26:59.210
component or you have an
activity that's interested in

00:26:59.210 --> 00:27:00.350
this intent.

00:27:00.350 --> 00:27:04.580
And when you declare this
intent, you declare it with a

00:27:04.580 --> 00:27:08.540
URL or MIME type of interest
to you, which means--

00:27:08.540 --> 00:27:13.300
so for example, a code that we
just saw in the last slide was

00:27:13.300 --> 00:27:15.800
trying to send you
some ASCII text.

00:27:15.800 --> 00:27:20.140
So when you declare this in
your manifest, you may say

00:27:20.140 --> 00:27:22.730
that I am only interested
in text.

00:27:22.730 --> 00:27:25.570
If there's an NFC intent with
a message that's carrying

00:27:25.570 --> 00:27:26.700
text, I'm interested.

00:27:26.700 --> 00:27:31.380
Or if there's an NFC message
carrying some image data, I am

00:27:31.380 --> 00:27:32.030
interested.

00:27:32.030 --> 00:27:36.970
So you declare also your
MIME type of interest.

00:27:36.970 --> 00:27:40.270
So again, like we said, it
should be the same as the

00:27:40.270 --> 00:27:42.900
first NDEF record of the
incoming message.

00:27:42.900 --> 00:27:48.260
Because that's where we kept the
MIME type of the message.

00:27:48.260 --> 00:27:52.850
So once you do that, and let's
look at some simple code--

00:27:58.540 --> 00:27:59.210
here it is.

00:27:59.210 --> 00:28:02.910
This is the method that's
invoked on new intent, which

00:28:02.910 --> 00:28:04.666
is what we'll get
called when--

00:28:04.666 --> 00:28:05.916
[INAUDIBLE].

00:28:10.500 --> 00:28:13.860
So this method is what we're
invoking on new intent.

00:28:13.860 --> 00:28:17.480
And so that means there is an
incoming message now that we

00:28:17.480 --> 00:28:19.150
are ready to process.

00:28:19.150 --> 00:28:24.730
So what we do now is using the
GET_EXTRAS of the intent, we

00:28:24.730 --> 00:28:28.330
try to obtain the raw message,
which is the NDEF message.

00:28:28.330 --> 00:28:31.930
And the NDEF message is the 0th
or the beginning element

00:28:31.930 --> 00:28:33.350
of the raw message array.

00:28:33.350 --> 00:28:35.770
And this is the only
element right now.

00:28:35.770 --> 00:28:37.530
So once we get the NDEF
message, what

00:28:37.530 --> 00:28:40.820
we want to do is--

00:28:40.820 --> 00:28:44.670
the actual message, because the
0th element is the MIME

00:28:44.670 --> 00:28:47.480
type or the URL type, what we
want to do is get the payload

00:28:47.480 --> 00:28:49.100
starting from the 0th message.

00:28:49.100 --> 00:28:52.510
So we say,
ndefMessage.getRecords.

00:28:52.510 --> 00:28:56.020
And we use the method
getPayload, which will give us

00:28:56.020 --> 00:28:59.330
the following records from the
MIME type, following the MIME

00:28:59.330 --> 00:29:00.530
type record.

00:29:00.530 --> 00:29:03.690
And this is basically the text
message that we had, which

00:29:03.690 --> 00:29:06.940
said "beam me up." And this is
how you obtain the message.

00:29:06.940 --> 00:29:10.290
So as you can see, it's just 10
lines of code on both sides

00:29:10.290 --> 00:29:11.420
on both devices.

00:29:11.420 --> 00:29:14.740
And sending the intent as well
as receiving the intent, and

00:29:14.740 --> 00:29:17.460
your app is now NFC
Beam capable.

00:29:17.460 --> 00:29:21.210
You have some more use cases
like Tony discussed-- how to

00:29:21.210 --> 00:29:23.720
set up a handshake for
Bluetooth with NFC.

00:29:23.720 --> 00:29:25.620
And then in this case, you might
want to exchange some

00:29:25.620 --> 00:29:28.560
more data of different MIME
types between the two devices

00:29:28.560 --> 00:29:30.470
if you want to initiate a
Bluetooth connection or if you

00:29:30.470 --> 00:29:34.410
want to send across images
or some other text data.

00:29:34.410 --> 00:29:37.675
But in general, this
is how NFC works.

00:29:37.675 --> 00:29:40.970
Move the MIME type under the
first record, create the other

00:29:40.970 --> 00:29:43.950
records with the payload, and
push the payload across.

00:29:43.950 --> 00:29:48.990
Declare the intent
NFC discovered.

00:29:48.990 --> 00:29:53.880
And then once you have the
intent in your activity on new

00:29:53.880 --> 00:29:56.700
intent, you try to process this
message by obtaining the

00:29:56.700 --> 00:30:00.590
raw record and then getting the
payload from the record.

00:30:00.590 --> 00:30:02.080
And all this happens
on foreground.

00:30:02.080 --> 00:30:03.270
And that's how NFC Beam works.

00:30:03.270 --> 00:30:05.820
Your app has to be
on foreground.

00:30:05.820 --> 00:30:09.340
So just a use case here.

00:30:09.340 --> 00:30:14.620
What may happen sometimes is
that there may be multiple

00:30:14.620 --> 00:30:17.500
applications on the device
that may be interested in

00:30:17.500 --> 00:30:21.620
listening to NFC incoming
messages of a

00:30:21.620 --> 00:30:22.570
certain MIME type.

00:30:22.570 --> 00:30:25.570
This could be very common for
something like a contact or

00:30:25.570 --> 00:30:28.400
image or text-- there will
be multiple applications.

00:30:28.400 --> 00:30:34.550
So if your application is
beaming that message and you

00:30:34.550 --> 00:30:38.090
want to guarantee the delivery
of the message back to your

00:30:38.090 --> 00:30:41.020
app on the other phone, what
you can do is use something

00:30:41.020 --> 00:30:43.310
called Application Record,
and this is

00:30:43.310 --> 00:30:44.610
Android Application Record--

00:30:44.610 --> 00:30:46.880
AAR.

00:30:46.880 --> 00:30:48.330
This is very simple
implementation.

00:30:48.330 --> 00:30:51.770
What it does is just puts the
package name of your app in

00:30:51.770 --> 00:30:54.080
the NDEF message.

00:30:54.080 --> 00:30:58.430
Which basically means inside the
NDEF message, everything

00:30:58.430 --> 00:30:59.620
is an NDEF record.

00:30:59.620 --> 00:31:03.520
So this basically means that we
are creating an NDEF record

00:31:03.520 --> 00:31:06.000
which contains the package
name of our app.

00:31:06.000 --> 00:31:09.140
So this is to specifically
target your app at the

00:31:09.140 --> 00:31:10.480
receiving end of the message.

00:31:10.480 --> 00:31:13.620
This increases the probability
that your app will be the

00:31:13.620 --> 00:31:15.850
first app to pick
up the message.

00:31:15.850 --> 00:31:20.820
Or your app is the intended
receiver of the message.

00:31:20.820 --> 00:31:26.160
So just to summarize what we
saw in terms of a graphical

00:31:26.160 --> 00:31:32.050
illustration, on the top you see
a device that has the Beam

00:31:32.050 --> 00:31:34.970
foreground UI activated, which
means the device is ready to

00:31:34.970 --> 00:31:36.140
beam a message.

00:31:36.140 --> 00:31:40.880
At this point, we use the
createNdefMessage method from

00:31:40.880 --> 00:31:44.840
the createNdefMessage callback
interface to create our

00:31:44.840 --> 00:31:47.030
message and send it
to the system

00:31:47.030 --> 00:31:49.030
adapter, the NFC adapter.

00:31:49.030 --> 00:31:52.680
So once you create the message,
this message is

00:31:52.680 --> 00:31:55.070
beamed to the other device
using NFC technology.

00:31:55.070 --> 00:31:59.600
And if you have the intent
ACTION_NDEF_DISCOVERED on your

00:31:59.600 --> 00:32:02.560
app, this message will be
delivered to your app.

00:32:02.560 --> 00:32:05.910
And the format of the NDEF
message would indicate what is

00:32:05.910 --> 00:32:09.930
the MIME type or the nature of
the data in your message.

00:32:09.930 --> 00:32:13.710
And based on this, you will have
your intent [? filter ?]

00:32:13.710 --> 00:32:16.010
declaring those MIME types.

00:32:16.010 --> 00:32:20.290
And once you receive the data,
you're able to pass it getting

00:32:20.290 --> 00:32:22.720
the raw record and then
looking to the

00:32:22.720 --> 00:32:24.990
record for the payload.

00:32:24.990 --> 00:32:30.320
So this pretty much summarizes
what we have to offer for

00:32:30.320 --> 00:32:31.570
Android Beam right now.

00:32:33.720 --> 00:32:38.260
Yeah, that wraps up our live
presentation for today.

00:32:38.260 --> 00:32:41.280
So Tony, we can move to Q&amp;A?

00:32:41.280 --> 00:32:42.530
TONY CHAN: Yeah, sure.

00:32:44.480 --> 00:32:49.370
So Let's take a look at the

00:32:49.370 --> 00:32:59.780
questions we have on moderator.

00:32:59.780 --> 00:33:10.950
So the first one I see is from
Anatole from Ukraine.

00:33:10.950 --> 00:33:15.090
So I need to authorize users,
but I don't want them to fill

00:33:15.090 --> 00:33:16.450
in some data manually.

00:33:16.450 --> 00:33:20.150
So after receiving a
confirmation email, I want

00:33:20.150 --> 00:33:22.750
Excel in my app to be started.

00:33:22.750 --> 00:33:25.620
Can you use URI like this?

00:33:25.620 --> 00:33:31.530
My app colon-slash-slash some
data in Gmail client because

00:33:31.530 --> 00:33:33.320
it knows the URI.

00:33:38.670 --> 00:33:41.910
So we talked about
intent filter.

00:33:41.910 --> 00:33:46.200
And I believe in the Gmail
client, actually, the standard

00:33:46.200 --> 00:33:52.430
HTTP URI is actually working.

00:33:52.430 --> 00:33:57.190
And so in your applications, one
suggestion I can think of

00:33:57.190 --> 00:34:01.880
is you can have an intent filter
actually filter by some

00:34:01.880 --> 00:34:03.640
specific URL.

00:34:03.640 --> 00:34:10.330
So if you have some URL only
your application can

00:34:10.330 --> 00:34:15.670
understand, so you can use
that to filter by that.

00:34:15.670 --> 00:34:19.540
So you don't need to use a
different kind of scheme.

00:34:19.540 --> 00:34:21.880
So that would be
my suggestion.

00:34:21.880 --> 00:34:25.460
Anirudh, do you have anything
to add on top of that?

00:34:25.460 --> 00:34:26.790
ANIRUDH DEWANI: Yeah, I think
that's the easiest way-- to go

00:34:26.790 --> 00:34:29.210
through something that the
framework already understands.

00:34:29.210 --> 00:34:32.290
And what the Gmail understands
is the HTTP URI.

00:34:32.290 --> 00:34:36.310
The other thing I could think of
is maybe your confirmation

00:34:36.310 --> 00:34:40.080
could come as a file which is
off your application type.

00:34:40.080 --> 00:34:43.389
And once the user downloads the
file, maybe a patch, an

00:34:43.389 --> 00:34:44.949
unlock patch or something.

00:34:44.949 --> 00:34:47.460
When the user downloads that
file, your app is registered

00:34:47.460 --> 00:34:49.020
to open the file of that type.

00:34:49.020 --> 00:34:53.320
That may be another way
of handling this.

00:34:53.320 --> 00:34:55.340
TONY CHAN: Cool.

00:34:55.340 --> 00:35:00.770
So the second question we have
here is, anything new about

00:35:00.770 --> 00:35:10.250
NFC in 4.2 API level 17 that you
are allowed to talk about?

00:35:10.250 --> 00:35:15.890
So I haven't seen actually
anything I am aware of that's

00:35:15.890 --> 00:35:18.240
super-new on 4.2.

00:35:18.240 --> 00:35:21.730
So I need to double
check that.

00:35:21.730 --> 00:35:25.220
And if we have something that
we can talk about, maybe we

00:35:25.220 --> 00:35:30.090
can talk about that in
future [INAUDIBLE]

00:35:30.090 --> 00:35:32.270
class.

00:35:32.270 --> 00:35:35.050
So yeah.

00:35:35.050 --> 00:35:41.070
So why don't you take
the next question?

00:35:44.180 --> 00:35:46.490
ANIRUDH DEWANI: So the question
is from Flight

00:35:46.490 --> 00:35:48.980
Engineer, Austin, Texas.

00:35:48.980 --> 00:35:51.720
And the question is, I would
like to replace the incoming

00:35:51.720 --> 00:35:54.080
call screen with a
small overlay.

00:35:54.080 --> 00:35:57.530
But it appears that there is no
way to disable the default

00:35:57.530 --> 00:36:00.350
incoming call screen
in [INAUDIBLE]

00:36:00.350 --> 00:36:01.000
app.

00:36:01.000 --> 00:36:05.840
Any creative ways of achieving
the desired result?

00:36:05.840 --> 00:36:08.300
Requiring root is
a possibility.

00:36:08.300 --> 00:36:12.260
So I would not comment on what
you can achieve by rooting

00:36:12.260 --> 00:36:14.110
because I'm not really
familiar.

00:36:14.110 --> 00:36:18.680
And it's not something we
recommend anyway to our users.

00:36:18.680 --> 00:36:21.260
So yes, you are right.

00:36:21.260 --> 00:36:23.450
The phone application is the
standard application.

00:36:23.450 --> 00:36:27.560
And you can't put textual
or graphical canvas

00:36:27.560 --> 00:36:28.870
overlays over top of it.

00:36:31.510 --> 00:36:33.046
TONY CHAN: This is really
for security reasons.

00:36:33.046 --> 00:36:34.750
ANIRUDH DEWANI: Yeah,
pretty much.

00:36:34.750 --> 00:36:38.030
TONY CHAN: Yeah, the fourth
question is coming from

00:36:38.030 --> 00:36:43.240
Russia, from [INAUDIBLE].

00:36:43.240 --> 00:36:46.330
So I have a positive experience
on Android platform

00:36:46.330 --> 00:36:50.550
for porting application built
on frameworks like Spring,

00:36:50.550 --> 00:36:54.210
Hibernate, AOP, et cetera.

00:36:54.210 --> 00:36:57.430
I would like help to continue
development in cooperation in

00:36:57.430 --> 00:36:59.020
this field with you.

00:36:59.020 --> 00:37:02.600
So that doesn't really
seem like a question.

00:37:02.600 --> 00:37:07.950
But we are glad, actually, that
you have good experience

00:37:07.950 --> 00:37:09.980
with porting applications.

00:37:09.980 --> 00:37:13.730
Feel free to leave us some more
comments or some specific

00:37:13.730 --> 00:37:21.220
questions in G+ in the future
if you have anything.

00:37:21.220 --> 00:37:21.940
ANIRUDH DEWANI: Yeah.

00:37:21.940 --> 00:37:23.510
Just add something to it.

00:37:23.510 --> 00:37:27.350
I think there are some open
source projects that are

00:37:27.350 --> 00:37:30.020
catering to these frameworks
or applications of these

00:37:30.020 --> 00:37:31.050
frameworks on Android.

00:37:31.050 --> 00:37:32.390
I surely know there
is something

00:37:32.390 --> 00:37:33.690
called Spring Android.

00:37:33.690 --> 00:37:38.140
And definitely [INAUDIBLE].

00:37:38.140 --> 00:37:40.550
So there is [INAUDIBLE]

00:37:40.550 --> 00:37:42.200
or something like that available
for Android.

00:37:42.200 --> 00:37:43.330
And these are open source.

00:37:43.330 --> 00:37:46.300
So I think a good avenue for
you would be to work with

00:37:46.300 --> 00:37:46.740
these guys.

00:37:46.740 --> 00:37:48.975
Spring Android is a project
where you can go and

00:37:48.975 --> 00:37:50.560
contribute.

00:37:50.560 --> 00:37:53.860
And yeah, so this is how
you can work with

00:37:53.860 --> 00:37:55.110
community that's one idea.

00:37:59.130 --> 00:38:02.380
TONY CHAN: Anirudh, want
to take the next one?

00:38:02.380 --> 00:38:02.780
ANIRUDH DEWANI: Yes.

00:38:02.780 --> 00:38:06.410
So the next question is from
Shoshanka, Hyderabad, India.

00:38:06.410 --> 00:38:10.735
The question is, I need the
process of changing the bite

00:38:10.735 --> 00:38:15.220
rate of an audio file which
should be used on Android SDK.

00:38:15.220 --> 00:38:17.850
So the question is not
really clear to me.

00:38:17.850 --> 00:38:21.145
So I get the first part, the
process of changing the bit

00:38:21.145 --> 00:38:22.100
rate of an audio file.

00:38:22.100 --> 00:38:25.755
So we have media codecs where
you can have an input buffer

00:38:25.755 --> 00:38:27.000
and an output buffer.

00:38:27.000 --> 00:38:33.470
And you can specify the media
properties there.

00:38:33.470 --> 00:38:36.790
But I don't get the part where
you say which should be used

00:38:36.790 --> 00:38:38.040
on Android SDK.

00:38:40.510 --> 00:38:43.380
Do you mean what should work
on the Android OS?

00:38:46.320 --> 00:38:47.630
See, I'm not really clear.

00:38:47.630 --> 00:38:50.530
Maybe if you can drop us a
comment on what you want to

00:38:50.530 --> 00:38:54.300
say with the second part of
your question [INAUDIBLE].

00:38:54.300 --> 00:38:59.670
But just in case, for handling
the audio and video pipelines,

00:38:59.670 --> 00:39:04.660
you can use a media codec,
which is available on the

00:39:04.660 --> 00:39:05.910
Android SDK.

00:39:09.140 --> 00:39:10.860
TONY CHAN: So the next
question is from

00:39:10.860 --> 00:39:15.250
Sweden, from Mac 10.

00:39:15.250 --> 00:39:19.950
So random users of my apps,
maybe one user a day out of

00:39:19.950 --> 00:39:23.800
200,000, get a Java
I/O [INAUDIBLE]

00:39:23.800 --> 00:39:27.595
exception permission denied
when calling contacts open

00:39:27.595 --> 00:39:29.720
file input.

00:39:29.720 --> 00:39:34.310
A few seconds later, the
file reading works.

00:39:34.310 --> 00:39:40.190
So Mac and I actually took a
look at the links you have.

00:39:40.190 --> 00:39:45.160
And if doesn't actually give
us too much information.

00:39:45.160 --> 00:39:48.710
Maybe we really need to look
at some code before we can

00:39:48.710 --> 00:39:49.700
fully answer this.

00:39:49.700 --> 00:39:55.440
But one idea I can think of may
be, is it possible to have

00:39:55.440 --> 00:39:57.360
some sort of raising
conditions?

00:39:57.360 --> 00:40:02.290
Like, the file it's actually
reading doesn't exist in

00:40:02.290 --> 00:40:04.120
certain cases?

00:40:04.120 --> 00:40:07.356
So that's my guess.

00:40:07.356 --> 00:40:09.830
How about you, Anirudh?

00:40:09.830 --> 00:40:13.560
Anything you can think of?

00:40:13.560 --> 00:40:13.840
ANIRUDH DEWANI: Not really.

00:40:13.840 --> 00:40:17.680
I saw the [? stack list ?]
there.

00:40:17.680 --> 00:40:21.790
Maybe if you can obtain a
buttress from the device which

00:40:21.790 --> 00:40:23.545
will capture more information
on what's happening there.

00:40:23.545 --> 00:40:26.510
I can see there is a permission
denied by the Unix

00:40:26.510 --> 00:40:27.310
APIs there.

00:40:27.310 --> 00:40:31.735
But yeah, a buttress would
probably help narrow in on

00:40:31.735 --> 00:40:35.866
what's happening, if you can
grab one from your users.

00:40:40.330 --> 00:40:43.770
Maybe even random failure of
flash drive or storage.

00:40:46.400 --> 00:40:49.220
TONY CHAN: So how about
the last question?

00:40:49.220 --> 00:40:50.856
Anirudh, do you want
to take that?

00:40:50.856 --> 00:40:51.670
ANIRUDH DEWANI: All right.

00:40:51.670 --> 00:40:55.730
So the question is, what are the
various best approaches to

00:40:55.730 --> 00:40:56.950
develop static pages?

00:40:56.950 --> 00:40:58.590
Each page contains text--

00:40:58.590 --> 00:41:00.880
TONY CHAN: Oh, I think
you skipped one.

00:41:00.880 --> 00:41:04.630
ANIRUDH DEWANI: So that's
the second to last.

00:41:04.630 --> 00:41:06.940
Is card emulation supported?

00:41:06.940 --> 00:41:10.950
If yes, then how do we do card
emulation of Android devices?

00:41:10.950 --> 00:41:12.650
Google Wallet is able to do.

00:41:12.650 --> 00:41:13.900
Why not others?

00:41:16.920 --> 00:41:20.480
I don't know the answer
to this one.

00:41:20.480 --> 00:41:22.550
So Google Wallet--

00:41:22.550 --> 00:41:23.090
I don't know.

00:41:23.090 --> 00:41:28.900
Tony, do you have any insights
on how NFC is working?

00:41:28.900 --> 00:41:30.020
TONY CHAN: I believe, actually,

00:41:30.020 --> 00:41:31.780
emulation is supported.

00:41:31.780 --> 00:41:34.840
Because I heard developer
has done that before.

00:41:34.840 --> 00:41:44.670
And also, when one Android
device is talking to another

00:41:44.670 --> 00:41:47.930
Android device, it's really
some sort of emulations.

00:41:47.930 --> 00:41:52.925
But I'm not 100% sure, is it
really the true emulation?

00:42:01.510 --> 00:42:04.870
I don't have a direct answer.

00:42:04.870 --> 00:42:09.400
So maybe we can take a
look at that and get

00:42:09.400 --> 00:42:11.470
back to you next week?

00:42:11.470 --> 00:42:13.590
Follow up with you?

00:42:13.590 --> 00:42:15.400
ANIRUDH DEWANI: Also, I believe
Google Wallet is

00:42:15.400 --> 00:42:20.230
probably not using stable
interfaces right now to work

00:42:20.230 --> 00:42:23.920
against NFC, in the sense which
can be published as part

00:42:23.920 --> 00:42:24.790
of SDK [? enabled ?].

00:42:24.790 --> 00:42:26.500
Everyone's sort of experimented

00:42:26.500 --> 00:42:27.640
in what it's doing.

00:42:27.640 --> 00:42:29.850
And once we have some kind of
stable interface, that may

00:42:29.850 --> 00:42:33.300
become a public SDK
[? facing the API. ?]

00:42:33.300 --> 00:42:34.550
AUDIENCE: [INAUDIBLE]

00:42:40.364 --> 00:42:43.760
The APIs that we are talking
about, I'm referring to seek

00:42:43.760 --> 00:42:46.780
interface, which has been
provided already, has been

00:42:46.780 --> 00:42:49.960
implemented in many of the
devices, such as the Samsung

00:42:49.960 --> 00:42:51.415
and Sony devices--

00:42:51.415 --> 00:42:53.621
The seek interface.

00:42:53.621 --> 00:42:58.780
What we find is that it is not
getting implemented in the OS.

00:42:58.780 --> 00:43:01.140
That's why it's not a standard
[INAUDIBLE].

00:43:01.140 --> 00:43:04.470
Just hoping to get some kind of
info if it is going to be

00:43:04.470 --> 00:43:06.380
standardized in the
future anywhere.

00:43:06.380 --> 00:43:08.750
Is it there in the roadmap or
not-- something like that?

00:43:08.750 --> 00:43:11.950
Because people want
to do something

00:43:11.950 --> 00:43:13.695
with the seek interface.

00:43:13.695 --> 00:43:17.590
They want to access the SIM
card for certain reasons--

00:43:17.590 --> 00:43:20.040
because a secure element
has the [INAUDIBLE].

00:43:20.040 --> 00:43:22.050
They want to access the
secure element.

00:43:22.050 --> 00:43:26.120
And being not able to do it is
a limitation for many of the

00:43:26.120 --> 00:43:27.790
applications.

00:43:27.790 --> 00:43:32.196
So looking forward, is there
any plan like that that you

00:43:32.196 --> 00:43:33.670
guys are having?

00:43:33.670 --> 00:43:34.170
ANIRUDH DEWANI: Yeah.

00:43:34.170 --> 00:43:37.120
I mean, definitely there's
work in progress--

00:43:37.120 --> 00:43:38.410
even [INAUDIBLE]

00:43:38.410 --> 00:43:38.980
when it was launched.

00:43:38.980 --> 00:43:41.670
And even now, it was under
specific devices.

00:43:41.670 --> 00:43:44.540
Because like you said,
it's not a stable

00:43:44.540 --> 00:43:46.310
interface right now.

00:43:46.310 --> 00:43:47.030
There are different

00:43:47.030 --> 00:43:48.510
implementations that cross renders.

00:43:48.510 --> 00:43:51.370
And so this is something that
is being worked at.

00:43:51.370 --> 00:43:54.760
And I don't know the timelines
on when we'll have something

00:43:54.760 --> 00:43:57.650
stable to be exposed
as a backward

00:43:57.650 --> 00:43:58.870
compatibility for our time.

00:43:58.870 --> 00:44:02.850
But there's work in progress,
and I can try to find out more

00:44:02.850 --> 00:44:06.200
from the teams and update
you on what progress is

00:44:06.200 --> 00:44:07.390
[INAUDIBLE].

00:44:07.390 --> 00:44:10.136
AUDIENCE: Also a
small question.

00:44:10.136 --> 00:44:12.990
Google Nexus S used to have

00:44:12.990 --> 00:44:15.370
compatibility with the [? SWP ?]

00:44:15.370 --> 00:44:18.010
chip, so it was able to have
a communication over there.

00:44:23.220 --> 00:44:26.270
The previous one, the Nexus 3,
which [INAUDIBLE], there is a

00:44:26.270 --> 00:44:27.060
[INAUDIBLE]

00:44:27.060 --> 00:44:27.695
having it.

00:44:27.695 --> 00:44:32.300
Are we expecting this to
be there in Nexus 4?

00:44:32.300 --> 00:44:34.000
ANIRUDH DEWANI: Sorry, can you
repeat the first part?

00:44:34.000 --> 00:44:37.838
I didn't really catch with
the audio breaking.

00:44:37.838 --> 00:44:42.390
AUDIENCE: I'm saying Galaxy
Nexus was not having it, yet

00:44:42.390 --> 00:44:47.520
Nexus S, the previous one was
having the seek interface.

00:44:47.520 --> 00:44:50.470
It was having the SWP chip, by
which the SIM can communicate

00:44:50.470 --> 00:44:53.510
on the NFC level.

00:44:53.510 --> 00:44:56.680
Is there any possibility that
Nexus 4 will be having it?

00:44:56.680 --> 00:44:58.780
Is there any chance--

00:44:58.780 --> 00:45:00.860
do you have it on the roadmap?

00:45:00.860 --> 00:45:01.930
ANIRUDH DEWANI: I
can find out.

00:45:01.930 --> 00:45:03.130
I can find out.

00:45:03.130 --> 00:45:05.540
I don't know the answer.

00:45:05.540 --> 00:45:08.030
AUDIENCE: Thank you.

00:45:08.030 --> 00:45:09.410
ANIRUDH DEWANI: So maybe
you can join us next

00:45:09.410 --> 00:45:11.640
week for the answers.

00:45:11.640 --> 00:45:16.080
Or we'll try to post it to
G+ on the [INAUDIBLE].

00:45:16.080 --> 00:45:23.940
TONY CHAN: Yeah, try to post
the question in G+ to us so

00:45:23.940 --> 00:45:24.830
that we have a record.

00:45:24.830 --> 00:45:27.900
And we can follow up easier.

00:45:27.900 --> 00:45:30.350
So thanks.

00:45:30.350 --> 00:45:31.720
ANIRUDH DEWANI: My ID
is Anirudh Dewani.

00:45:31.720 --> 00:45:32.490
And that's Tony Chan.

00:45:32.490 --> 00:45:33.920
So you can find us on G+.

00:45:33.920 --> 00:45:38.090
And maybe you can just tag us to
post a question, and we'll

00:45:38.090 --> 00:45:39.340
[INAUDIBLE].

00:45:41.710 --> 00:45:44.180
TONY CHAN: So let's take a look
at the last question.

00:45:44.180 --> 00:45:49.300
So what is the best approach
to develop static pages?

00:45:49.300 --> 00:45:53.250
Each page contained text
and optional images.

00:45:53.250 --> 00:45:57.020
I'm thinking to use one activity
ViewPager use as your

00:45:57.020 --> 00:45:57.710
[INAUDIBLE]

00:45:57.710 --> 00:46:01.660
pages of a real book while the
user flips left and right

00:46:01.660 --> 00:46:03.020
through pages of data.

00:46:07.820 --> 00:46:12.930
ANIRUDH DEWANI: So depending on
the size of the book that

00:46:12.930 --> 00:46:16.715
you're talking about, 200 pages,
maybe, you don't want

00:46:16.715 --> 00:46:19.970
200 fragments sitting
in a ViewPager with

00:46:19.970 --> 00:46:20.870
data flipping across.

00:46:20.870 --> 00:46:24.060
So what you probably want to
do is instantiate something

00:46:24.060 --> 00:46:27.770
with five fragments and try to
buffer or cycle through your

00:46:27.770 --> 00:46:30.685
content of the book so keeping
some pages in the buffer so

00:46:30.685 --> 00:46:32.150
user can go up and back.

00:46:32.150 --> 00:46:36.940
And then maybe use just
animations on a given fragment

00:46:36.940 --> 00:46:41.860
or a view to have the content
of the fragment being

00:46:41.860 --> 00:46:46.080
replaced, the text and the image
being replaced from your

00:46:46.080 --> 00:46:48.430
data source again.

00:46:48.430 --> 00:46:54.090
I mean, the strategy of using an
activity of a fragment and

00:46:54.090 --> 00:46:57.110
some animations would be good.

00:46:57.110 --> 00:47:01.490
So Google Books itself was
written within the script.

00:47:01.490 --> 00:47:05.070
And the script is a low-level
graphics and mathematical

00:47:05.070 --> 00:47:07.970
computation library that
we introduced.

00:47:07.970 --> 00:47:11.180
So I'm not sure what the kind
of development you see on it

00:47:11.180 --> 00:47:11.920
going ahead.

00:47:11.920 --> 00:47:13.620
But that's what Google
Books was using at

00:47:13.620 --> 00:47:14.560
that point of time.

00:47:14.560 --> 00:47:18.440
But again, you have the options
using Java, OpenGL 3-D

00:47:18.440 --> 00:47:21.000
interfaces and to give those
effects and animations.

00:47:21.000 --> 00:47:25.630
And even the framework object
animated properties can give

00:47:25.630 --> 00:47:29.310
you animation to give
the effect.

00:47:29.310 --> 00:47:34.440
But yeah, I would look at
a fragment with a view

00:47:34.440 --> 00:47:41.456
containing text and images and
some animations there.

00:47:41.456 --> 00:47:44.090
TONY CHAN: Well, I guess
that's all we

00:47:44.090 --> 00:47:46.150
have in terms of questions.

00:47:46.150 --> 00:47:51.120
And so thank you very
much for watching.

00:47:51.120 --> 00:47:57.460
And I hope you learned something
about NFC today.

00:47:57.460 --> 00:48:01.030
So we will be back next week.

00:48:01.030 --> 00:48:03.920
Hopefully Ankur will
be back too.

00:48:03.920 --> 00:48:08.890
Anyway, anything else you
want to add before we--

00:48:08.890 --> 00:48:12.800
ANIRUDH DEWANI: Just a reminder
that we are running

00:48:12.800 --> 00:48:14.620
the Android experiments.

00:48:14.620 --> 00:48:17.730
And the first one was about
connectivity API.

00:48:17.730 --> 00:48:19.280
So if you have some last minute

00:48:19.280 --> 00:48:20.400
submissions, please go on.

00:48:20.400 --> 00:48:24.750
And if you want to showcase your
call of have us review it

00:48:24.750 --> 00:48:27.445
or showcase what you've done,
please submit it to the

00:48:27.445 --> 00:48:29.280
Android Experiments page.

00:48:29.280 --> 00:48:30.646
We're looking forward to it.

00:48:30.646 --> 00:48:32.520
TONY CHAN: Cool.

00:48:32.520 --> 00:48:33.450
All right.

00:48:33.450 --> 00:48:34.610
I think that's it.

00:48:34.610 --> 00:48:36.420
Thank you very much
for watching.

00:48:36.420 --> 00:48:39.910
And we'll see you next week.

00:48:39.910 --> 00:48:40.810
All right.

00:48:40.810 --> 00:48:42.060
Bye.

