WEBVTT
Kind: captions
Language: en

00:00:00.470 --> 00:00:02.000
Max Ross: Good afternoon, everybody. Thanks
for coming.

00:00:02.000 --> 00:00:08.630
Let's go ahead and get started.
My name is Max Ross, and today we're going

00:00:08.630 --> 00:00:13.500
to be talking about testing techniques for
Google App Engine.

00:00:13.500 --> 00:00:17.859
Quick reminder -- you can follow along with
some live notes that are being taken on this

00:00:17.859 --> 00:00:25.949
wave here.
Give you all a second to type that in. [pause]

00:00:25.949 --> 00:00:29.119
We have a moderator module there.
So you can ask questions at the end.

00:00:29.119 --> 00:00:33.820
Okay. So, a little bit about me.
I'm a software engineer at Google. I work

00:00:33.820 --> 00:00:38.020
on the App Engine team.
I do things related to persistence -- I work

00:00:38.020 --> 00:00:41.511
on the data store.
I work on the JPA and JDO implementations

00:00:41.511 --> 00:00:46.550
that ship with the Java SDK.
I do various things related to the Java runtime.

00:00:46.550 --> 00:00:50.010
The most important thing that you need to
know about me with respect to this talk, though,

00:00:50.010 --> 00:00:55.230
is that -- I take testing very, very, very
seriously.

00:00:55.230 --> 00:00:59.170
I love writing tests. Tests make me feel good.
They let me sleep well at night.

00:00:59.170 --> 00:01:02.581
And I hope that makes you feel good knowing
that a storage guy on the App Engine team

00:01:02.581 --> 00:01:08.850
feels this way.
Brief overview of what we're going to cover

00:01:08.850 --> 00:01:13.470
 -- I want to spend a few minutes talking
to you about developer testing in general.

00:01:13.470 --> 00:01:19.000
And then, we're going to talk about some techniques
for testing your App Engine apps locally using

00:01:19.000 --> 00:01:21.541
the App Engine SDK.
And then, we're going to get a little bit

00:01:21.541 --> 00:01:26.710
more adventurous, and we're going to talk
about techniques for running your tests in

00:01:26.710 --> 00:01:29.760
the Cloud.
And I've got some really, really cool demos

00:01:29.760 --> 00:01:32.960
planned that I think you're going to like.
Then, we'll wrap things up, and then I'll

00:01:32.960 --> 00:01:40.990
take any questions that you might have.
So let's start with developer testing.

00:01:40.990 --> 00:01:44.140
I want to define a couple of terms that I'm
going to use over and over.

00:01:44.140 --> 00:01:48.130
There's a lot of language around testing.
There's disagreements about the definitions

00:01:48.130 --> 00:01:50.670
of these terms.
I want to give you my definitions so that,

00:01:50.670 --> 00:01:54.729
when I talk about an integration test or a
unit test, you know what I'm talking about.

00:01:54.729 --> 00:01:59.650
I apologize if you disagree with these.
A "unit test" -- we're testing something very

00:01:59.650 --> 00:02:04.470
small, something very precise -- no external
dependencies.

00:02:04.470 --> 00:02:06.850
Or, if there are external dependencies, we're
in complete control of them.

00:02:06.850 --> 00:02:13.480
A classic example might be a string parsing
routine where all of the logic is included

00:02:13.480 --> 00:02:15.959
in just that single function.
You want to make sure it does what you expect

00:02:15.959 --> 00:02:18.550
it to do.
We can expand the scope a little bit to an

00:02:18.550 --> 00:02:22.910
integration test, where we're testing the
interaction between components or maybe even

00:02:22.910 --> 00:02:26.810
systems.
Classic example here -- writing tests that

00:02:26.810 --> 00:02:30.260
talk to a database or a data store if you're
working on App Engine.

00:02:30.260 --> 00:02:35.681
You want to issue a query -- or, really -- put
some data in the database, issue a query,

00:02:35.681 --> 00:02:39.489
make sure you get back what you expect.
And I'm going to show you some live demos

00:02:39.489 --> 00:02:42.120
of that in action.
And then, expanding the scope all the way

00:02:42.120 --> 00:02:46.600
out, we have end-to-end testing where you're
driving your application through the public

00:02:46.600 --> 00:02:50.150
API.
For App Engine, this means http.

00:02:50.150 --> 00:02:56.380
Classic example here might be verifying the
authorization flow of your application where

00:02:56.380 --> 00:03:01.590
you go to a particular URL.
You don't have permission to look at it.

00:03:01.590 --> 00:03:04.440
An admin logs in. They give you permission
to look at it.

00:03:04.440 --> 00:03:06.380
You visit it again. You see that the page
renders.

00:03:06.380 --> 00:03:12.790
So, I need to get up on my soap box just for
a few minutes here and let you know why I

00:03:12.790 --> 00:03:19.770
am so passionate about developer testing.
The obvious benefit here is, you write some

00:03:19.770 --> 00:03:23.670
code, you've added some functionality.
Now, you want to make that sure it does what

00:03:23.670 --> 00:03:26.831
it does.
You want to make sure it does what you expect

00:03:26.831 --> 00:03:29.019
it to do.
You write a test. You test that code.

00:03:29.019 --> 00:03:33.650
You check that code in along with the test.
It gives you a good feeling about the code

00:03:33.650 --> 00:03:38.700
you've just written.
And that's important. And that's valuable.

00:03:38.700 --> 00:03:43.709
But, for me, that's not even the most important
thing that developer testing gets you.

00:03:43.709 --> 00:03:48.080
When you're just starting out on a project,
checking code in is not particularly risky,

00:03:48.080 --> 00:03:51.410
because you're not at risk of breaking anything.
You haven't even built anything yet.

00:03:51.410 --> 00:03:54.690
So that first check in?
You wrote a test to make sure that that first

00:03:54.690 --> 00:03:58.390
check in does what you wanted it to do, and
you feel good about and you check it in.

00:03:58.390 --> 00:04:02.849
But that second check in is a little bit riskier,
because there's existing code.

00:04:02.849 --> 00:04:05.880
There's existing features.
There's users who have expectations of this

00:04:05.880 --> 00:04:09.019
code now.
So that second check in, you're not only in

00:04:09.019 --> 00:04:13.870
danger of getting the initial thing wrong,
you're in danger of breaking the first thing.

00:04:13.870 --> 00:04:16.699
And the third check in is riskier, and the
fourth check in is riskier.

00:04:16.699 --> 00:04:21.160
And now, we fast forward three years into
your project, and you've had 50 developers.

00:04:21.160 --> 00:04:25.760
How can you actually feel safe about the changes
you're making when there's so much at stake

00:04:25.760 --> 00:04:29.960
with every single check in.
It's actually terrifying, right?

00:04:29.960 --> 00:04:33.000
But if you're writing tests along the way,
you're mitigating that risk.

00:04:33.000 --> 00:04:37.610
Each check in is not riskier, because every
time you check in, you're adding some code

00:04:37.610 --> 00:04:40.680
to your code base.
It's part of your code base that verifies

00:04:40.680 --> 00:04:43.590
that what you just checked in does what you
wanted it to do.

00:04:43.590 --> 00:04:47.060
And as long as you're running those tests
every step of the way, you never have to lose

00:04:47.060 --> 00:04:51.060
that confidence.
So this makes me feel really good about my

00:04:51.060 --> 00:04:54.551
code.
So the advice that I want to give to everybody

00:04:54.551 --> 00:04:59.430
in the audience today -- if you're not already
doing testing, please, try it out.

00:04:59.430 --> 00:05:02.170
See if it works for you. The benefits are
real.

00:05:02.170 --> 00:05:06.540
This is a short-term investment in the success
of your project, but it's also -- more importantly

00:05:06.540 --> 00:05:10.280
 -- a long-term investment in the success
of your project.

00:05:10.280 --> 00:05:14.850
Treat your code as first-class citizens in
your code base, right alongside the production

00:05:14.850 --> 00:05:20.350
code. They deserve it.
I'm not the only one at Google who feels this

00:05:20.350 --> 00:05:27.500
way.
Testing at Google has a long and proud history.

00:05:27.500 --> 00:05:31.139
We take testing very, very seriously.
I've listed up here a couple of frameworks

00:05:31.139 --> 00:05:34.780
that have come out of Google engineering that
are related to testing.

00:05:34.780 --> 00:05:39.060
There's a number of C++ frameworks, which
are basically the C++ testing frameworks that

00:05:39.060 --> 00:05:42.380
we use internally.
There's a couple of Java frameworks, one really

00:05:42.380 --> 00:05:46.759
interesting one which is useful for concurrency
testing.

00:05:46.759 --> 00:05:52.260
This is an example of how seriously we take
it that the tools we develop inside, we've

00:05:52.260 --> 00:05:55.600
released an open source whenever we can.
We want everybody to have these same tools

00:05:55.600 --> 00:06:02.699
at their disposal.
So, how does this relate to App Engine?

00:06:02.699 --> 00:06:07.080
When we talk about App Engine and where our
code runs, we're typically talking about two

00:06:07.080 --> 00:06:10.000
different execution environments.
There's the Cloud where our code actually

00:06:10.000 --> 00:06:14.510
lives, serving requests on the Internet.
And then there's the dev app server, which

00:06:14.510 --> 00:06:18.130
is running locally, which gives us the same
functionality that we have in the Cloud, but

00:06:18.130 --> 00:06:22.240
not the same scale.
There's actually a third environment that

00:06:22.240 --> 00:06:25.700
we pretty much never talk about, but we should
 -- and that's what we're talking about here

00:06:25.700 --> 00:06:28.430
today.
It's the test execution environment.

00:06:28.430 --> 00:06:33.920
The test execution environment can exist locally,
and it can exist in the Cloud.

00:06:33.920 --> 00:06:38.010
It can be serving http requests, but -- more
interestingly for the purposes of this talk

00:06:38.010 --> 00:06:45.100
 -- it can also involve a test harness issuing
requests to very precise pieces of your code.

00:06:45.100 --> 00:06:48.570
So the question is, do we need App Engine
specific testing strategies?

00:06:48.570 --> 00:06:55.840
And the answer is, "Yes, we do need some."
And that's what we're going to go over.

00:06:55.840 --> 00:07:01.020
So, let's start with "locally," because this
is a little bit more familiar.

00:07:01.020 --> 00:07:04.540
How many people here have written an App Engine
application and written some tests that run

00:07:04.540 --> 00:07:10.259
locally?
Okay. I'm very happy to see all those hands.

00:07:10.259 --> 00:07:13.280
Good.
Hopefully those of you who raised your hands

00:07:13.280 --> 00:07:17.180
will agree with me that a lot of it is the
same.

00:07:17.180 --> 00:07:22.520
Your frameworks apply -- JUnit, PyUnit -- you
want to write Selenium tests.

00:07:22.520 --> 00:07:25.050
These things work. There's not a whole lot
that's different.

00:07:25.050 --> 00:07:29.639
The best practices make sense as well -- in
terms of isolation, in terms of how you're

00:07:29.639 --> 00:07:32.350
going to design your application so that it
can be tested, in terms of how you're going

00:07:32.350 --> 00:07:37.229
to write your tests so that they're effective
and isolated and not flaky.

00:07:37.229 --> 00:07:44.131
This is all really good news.
What's different? Not a lot, but there are

00:07:44.131 --> 00:07:48.319
some interesting technical details that I
want to get into.

00:07:48.319 --> 00:07:55.910
The main one is that the RPC layer that's
part of App Engine that dispatches all of

00:07:55.910 --> 00:08:01.080
your calls to back end services has assumptions
about the environment that it executes in.

00:08:01.080 --> 00:08:06.230
So I've got an example up here that I've taken
from the implementation of the data store

00:08:06.230 --> 00:08:09.312
API.
And you can see this call API proxy dot get

00:08:09.312 --> 00:08:13.310
current environment -- if it's not there,
it throws a null pointer exception.

00:08:13.310 --> 00:08:20.270
The data store API assumes that either the
dev app server or the application server that's

00:08:20.270 --> 00:08:22.889
running in production is setting up a current
environment for it.

00:08:22.889 --> 00:08:25.699
And if it's not there, it's going to throw
an exception.

00:08:25.699 --> 00:08:29.840
But so, what happens when you're running a
unit test or an integration test and there's

00:08:29.840 --> 00:08:34.399
no dev app server to set this environment
up -- you're going to get this exception -- the

00:08:34.399 --> 00:08:36.829
null pointer exception.
So what are you going to do?

00:08:36.829 --> 00:08:39.779
Well, if you've been writing unit tests on
App Engine for a while, you probably remember

00:08:39.779 --> 00:08:42.769
originally you had to jump through a bunch
of hoops to make this work.

00:08:42.769 --> 00:08:46.850
You had to implement a bunch of interfaces
that sort of seemed like they were part of

00:08:46.850 --> 00:08:49.709
the implementation, and it was just dirty
and messy.

00:08:49.709 --> 00:08:55.220
And then, a couple releases ago, we released
the App Engine testing APIs, which make this

00:08:55.220 --> 00:09:02.760
much, much, much nicer.
So I want to show you a quick demo of using

00:09:02.760 --> 00:09:08.170
the App Engine testing APIs locally.
And we're going to go back to our favorite

00:09:08.170 --> 00:09:13.420
little App Engine demo app -- the Guestbook.
And we're going to write an integration test

00:09:13.420 --> 00:09:24.489
for Guestbook.
Oops. Not ready for that yet.

00:09:24.489 --> 00:09:29.100
Okay. So this is not your typical guestbook
application.

00:09:29.100 --> 00:09:35.809
It looks the same. You've got your shout-outs.
But the interesting thing about it -- actually,

00:09:35.809 --> 00:09:41.739
let me show you that application real quick.
[pause]

00:09:41.739 --> 00:09:45.570
While that comes up -- The interesting thing
about this version of the Guestbook application

00:09:45.570 --> 00:09:53.429
is that it supports higher availability rights.
So when you give it a new message, it will

00:09:53.429 --> 00:10:00.019
try to write it to the data store.
And if that "put into the data store" succeeds,

00:10:00.019 --> 00:10:05.290
then everything is good.
But if it fails, it's going to queue it up

00:10:05.290 --> 00:10:10.290
in a task queue task to execute later.
So we got eventual consistency with our data

00:10:10.290 --> 00:10:13.119
store rights.
Now, I want to write an integration test that

00:10:13.119 --> 00:10:20.529
verifies that this works the way that I expect.
So I'm going to write two tests here using

00:10:20.529 --> 00:10:23.769
the local testing APIs.
The first one is going to test that synchronous

00:10:23.769 --> 00:10:27.529
rights behave the way I expect.
The second one is going to verify that asynchronous

00:10:27.529 --> 00:10:36.319
rights work the way I expect.
Let's get a little screen real estate here.

00:10:36.319 --> 00:10:42.769
So I'm a little bit old-school. I use Junit3.
So I'm going to extend test case.

00:10:42.769 --> 00:10:47.470
And the very first thing I'm going to do is
make sure that I've got the App Engine testing

00:10:47.470 --> 00:10:55.540
APIs configured properly.
So I'm going to get a local service test helper.

00:10:55.540 --> 00:11:01.190
I'm going to instantiate that, and since this
test uses the local data store service and

00:11:01.190 --> 00:11:05.889
the local task queue service, I'm going to
instantiate some configs for both of those

00:11:05.889 --> 00:11:14.799
to tell the test helper that I want to use
both of those local services.

00:11:14.799 --> 00:11:23.040
That's the one for the data store.
Okay. So I've got that allocated.

00:11:23.040 --> 00:11:27.330
And now, I need to override my set up and
tear down methods to make sure that the helper

00:11:27.330 --> 00:11:38.360
gets set up and tear down as well. [pause]
There's the set up. Tear it down. Symmetry

00:11:38.360 --> 00:11:44.579
is good.
Okay. I'm ready to write some tests.

00:11:44.579 --> 00:11:46.960
There's a couple of helper objects that I
think I'm going to need.

00:11:46.960 --> 00:11:50.410
I'm testing a Guestbook DAO -- Data Access
Object.

00:11:50.410 --> 00:12:01.480
So let's get a hold of one of those.
And we'll get a hold of a data store service

00:12:01.480 --> 00:12:05.699
as well because I'm going to use the low-level
data store API for some of my assertions.

00:12:05.699 --> 00:12:20.399
[pause] Okay. I'm ready to go.
Got my object set up.

00:12:20.399 --> 00:12:23.829
So the first test is going to be testing synchronous
rights.

00:12:23.829 --> 00:12:32.549
Signature of this method is "DAO save."
I need a greeting object.

00:12:32.549 --> 00:12:45.589
So I'm going to rely on the helper method
that I have sitting around. [pause]

00:12:45.589 --> 00:12:49.629
And we'll save that.
And if we look at the implementation of this

00:12:49.629 --> 00:12:52.489
method, you can see that one of the things
that I'm doing here is setting the key back

00:12:52.489 --> 00:12:57.350
on the greeting once I've saved it.
This is the indication to the presentation

00:12:57.350 --> 00:13:02.859
layer that this was a synchronous right.
Because I got a key back. I got a unique ID

00:13:02.859 --> 00:13:08.639
back.
So let's verify that I got a key. [Pause]

00:13:08.639 --> 00:13:16.019
"AssertNotNull" And let's also make some assertions
that the data actually found its way into

00:13:16.019 --> 00:13:19.959
the data store.
So I'm going to use the low-level API to look

00:13:19.959 --> 00:13:27.129
this thing back up.
Data store service dot get greeting. Look

00:13:27.129 --> 00:13:31.029
it up by its key.
Now, this will throw an exception if it's

00:13:31.029 --> 00:13:35.029
not found -- "entity not found" exception.
That's fine. I want this test to fail if it's

00:13:35.029 --> 00:13:37.380
not found.
So I'm not going to bother catching this exception.

00:13:37.380 --> 00:13:42.470
I'm just going to let it propagate out.
And then, finally, I'll assert that the content

00:13:42.470 --> 00:13:53.149
is what I expect.
Okay. This looks like a reasonable test to

00:13:53.149 --> 00:13:54.549
me.
I think I could sleep at night.

00:13:54.549 --> 00:13:57.699
There's probably a couple extra things that
I would do if I wasn't typing it live in front

00:13:57.699 --> 00:14:02.929
of all of you, but let's see if it's green.
Okay, it's green. I'm happy about that.

00:14:02.929 --> 00:14:07.199
But let's try the more interesting example
 -- the asynchronous rights.

00:14:07.199 --> 00:14:10.721
In order to test that asynchronous rights
are working, I need to force the data store

00:14:10.721 --> 00:14:14.041
to fail.
The way I'm going to force the data store

00:14:14.041 --> 00:14:17.319
to fail is, I'm going to create a custom delegate
object.

00:14:17.319 --> 00:14:22.859
A "delegate object" is an object that all
of your RPCs pass through en route to the

00:14:22.859 --> 00:14:27.100
back end services -- whether you're running
in production or whether you're running locally.

00:14:27.100 --> 00:14:33.259
So, in this case, I'm going to create a custom
delegate object that will throw an exception

00:14:33.259 --> 00:14:38.949
on every data store RPC.
So I'm going to call this an "explosive delegate,"

00:14:38.949 --> 00:14:45.739
and it's going to extend "base delegate,"
which is a helper class that I've defined.

00:14:45.739 --> 00:14:50.689
There's not a lot going on in here.
It's really just delegating for all of the

00:14:50.689 --> 00:14:54.509
methods.
Just trying to save some typing.

00:14:54.509 --> 00:14:57.959
The one method I want to override is make
synchronous call, because I am making an asynchronous

00:14:57.959 --> 00:15:00.239
call to the data store, and I want to intercept
that.

00:15:00.239 --> 00:15:07.439
I want to see that -- if the package is data
store v3 -- this is a constant that is defined.

00:15:07.439 --> 00:15:11.499
So it's not -- it's sort of a magic value,
but it's a publicly accessible magic value

00:15:11.499 --> 00:15:16.420
 -- it's accessible to everyone here.
If it's a data store call, I'm going to throw

00:15:16.420 --> 00:15:27.300
an API proxy exception with a specific error
code, which I want to import.

00:15:27.300 --> 00:15:34.149
Internal error. Okay.
That line's a little bit long. We can split

00:15:34.149 --> 00:15:37.290
that up.
So any data store call that comes through

00:15:37.290 --> 00:15:42.069
here is going to generate an exception.
The next thing I want to do is intercept all

00:15:42.069 --> 00:15:47.209
the calls to the task queue.
The reason I want to do this is because I'm

00:15:47.209 --> 00:15:50.560
going to capture the message that I'm sending
to the task queue so I can make some assertions

00:15:50.560 --> 00:15:54.019
about it.
So I need to declare a member so I have a

00:15:54.019 --> 00:16:08.479
place to put it when I actually catch it.
And so, this is a bulk add request.

00:16:08.479 --> 00:16:12.549
And when it's a task queue message, I'm going
to merge that -- I'm going to populate that

00:16:12.549 --> 00:16:13.809
value.
These are protocol buffers.

00:16:13.809 --> 00:16:17.889
So, I'm just going to take the raw bytes and
fold them in.

00:16:17.889 --> 00:16:24.149
And then, I'm going to let the call flow through.
So I've got a custom delegate here, which

00:16:24.149 --> 00:16:30.339
I can use to assert that, when the data store
throws an exception, I then get a task queue

00:16:30.339 --> 00:16:32.790
message.
And I'm going to capture that task queue message.

00:16:32.790 --> 00:16:34.239
And then, I'm going to make some assertions
on it.

00:16:34.239 --> 00:16:36.779
So let's write the actual test that installs
this delegate.

00:16:36.779 --> 00:16:46.779
The first thing I need is an instance of this
delegate.

00:16:46.779 --> 00:16:51.540
And then, I'm going to install it.
This install method is something that's in

00:16:51.540 --> 00:16:56.439
that base class that I didn't want to type
out in front of everybody, but it's two lines

00:16:56.439 --> 00:16:59.519
of code.
It's just setting a global variable holding

00:16:59.519 --> 00:17:03.540
on to the original value.
And I know I'm going to want to un-set it

00:17:03.540 --> 00:17:07.209
later so that my test doesn't leave a weird
state around.

00:17:07.209 --> 00:17:13.779
So I'm going to do all of this in a "finally"
block. [pause] Uninstall.

00:17:13.779 --> 00:17:19.470
And then, we're going to do something very
similar to the original test. [pause]

00:17:19.470 --> 00:17:31.669
Except, instead of asserting that the key
is not null, I'm going to assert that the

00:17:31.669 --> 00:17:36.550
key is null.
Because this is the indication to the presentation

00:17:36.550 --> 00:17:39.539
layer that this was an asynchronous right.
So that it can display something appropriate

00:17:39.539 --> 00:17:44.080
like, "We got your message.
It'll be there shortly."

00:17:44.080 --> 00:17:49.179
And then, finally, I want to make assertions
about the greeting that is actually encoded

00:17:49.179 --> 00:17:52.399
in the task queue message.
And I have a helper function for that that's

00:17:52.399 --> 00:17:55.269
going to help me with that.
I've got my greeting.

00:17:55.269 --> 00:17:59.610
And I can say, "Demo Helper, please extract
the greeting from this task queue message."

00:17:59.610 --> 00:18:22.630
Okay. Yes? No? [pause]
Oh, I forgot to make it a member. There we

00:18:22.630 --> 00:18:29.559
go.
Okay. So, now I have something that's checking

00:18:29.559 --> 00:18:36.000
that there is no key at the conclusion of
the right and also checking that the greeting

00:18:36.000 --> 00:18:41.750
gets properly encoded in the task.
And again, I've got to test the passes.

00:18:41.750 --> 00:18:45.259
And I feel reasonably good about this.
This is pretty decent test coverage for this.

00:18:45.259 --> 00:18:49.391
Ordinarily, I'd probably want to verify the
individual attributes of the greeting to make

00:18:49.391 --> 00:18:52.809
sure that they got translated properly, but
for live demo purposes, I'm satisfied with

00:18:52.809 --> 00:18:56.169
this.
So let's move on.

00:18:56.169 --> 00:18:59.399
That was the local testing API.
What I hope you notice was that I did a little

00:18:59.399 --> 00:19:03.320
bit of set up at the beginning to install
the test helper.

00:19:03.320 --> 00:19:08.250
And then, everything else was pretty standard
unit testing integration type stuff with a

00:19:08.250 --> 00:19:12.809
little bit of extra knowledge of how the RPC
layers work.

00:19:12.809 --> 00:19:20.470
So let's move on to the fancier stuff.
Do you want to run your tests in the Cloud?

00:19:20.470 --> 00:19:25.549
I want to run my tests in the Cloud.
I want to run my tests in an environment that

00:19:25.549 --> 00:19:30.279
is as realistic as possible.
And we've done a really good job making sure

00:19:30.279 --> 00:19:37.570
that the dev app server has equivalent functionality,
but there is no substitute for the real thing

00:19:37.570 --> 00:19:40.700
functionality-wise -- also performance-wise,
right?

00:19:40.700 --> 00:19:43.630
The local data store service stores everything
in memory.

00:19:43.630 --> 00:19:50.130
You're not going to get accurate latencies
for writes and reads unless you're running

00:19:50.130 --> 00:19:55.750
things in production.
So, fidelity is really an important reason

00:19:55.750 --> 00:19:59.429
to run your tests in the Cloud.
The other reason, though, is efficiency.

00:19:59.429 --> 00:20:05.559
If you've got a really large test suite, Google
App Engine has all of these computing resources

00:20:05.559 --> 00:20:09.390
that are at your disposal.
So rather than sitting there waiting for your

00:20:09.390 --> 00:20:13.610
test suite to run for 30 minutes or an hour,
or however long it's going to take -- or,

00:20:13.610 --> 00:20:17.000
biting the bullet and deciding to set up your
own test grid which you are then going to

00:20:17.000 --> 00:20:21.221
need to maintain -- upload your test to App
Engine. Run them there.

00:20:21.221 --> 00:20:30.870
We will manage your test grid for you.
So what are the similarities between the types

00:20:30.870 --> 00:20:35.120
of testing that you're used to doing and Cloud
testing? Again, your frameworks work.

00:20:35.120 --> 00:20:38.140
Your best practices work.
End to end testing -- in this case, we're

00:20:38.140 --> 00:20:40.720
just driving things through the front end
of your application.

00:20:40.720 --> 00:20:44.299
The front end of your application is available
on App Engine the same way the front end of

00:20:44.299 --> 00:20:47.120
your application is available when you're
running locally.

00:20:47.120 --> 00:20:51.559
So that's the same.
Again, this is really good news.

00:20:51.559 --> 00:20:54.769
What's different? There are more differences
here.

00:20:54.769 --> 00:21:00.210
First and foremost, your tests are now subject
to the requirements we have for App Engine

00:21:00.210 --> 00:21:05.409
requests -- which means, they need to finish
in 30 seconds, they have to obey the sandbox

00:21:05.409 --> 00:21:10.279
restrictions.
So, if you have tests that like to communicate

00:21:10.279 --> 00:21:15.519
directly with the network or spin up threads
or do any of the other things that we don't

00:21:15.519 --> 00:21:21.570
let you do in the Cloud, that's going to pose
a problem.

00:21:21.570 --> 00:21:25.700
Now, I don't have any good solutions for those
two issues.

00:21:25.700 --> 00:21:29.429
Your tests still need to finish in 30 seconds,
and they still need to obey the sandbox restrictions.

00:21:29.429 --> 00:21:35.759
But this third one here -- that you have to
invoke your tests over http -- I do have a

00:21:35.759 --> 00:21:44.299
good solution for you here. [pause]
I have a framework called GAE Cloud Cover,

00:21:44.299 --> 00:21:49.430
and it just went 1.00 final last night.
And now, it's at 1.01 final, because I found

00:21:49.430 --> 00:21:54.840
a bug this morning, but I'm releasing it.
And its sole purpose is to help with this

00:21:54.840 --> 00:22:00.510
issue -- How are you going to run your unit
tests and your integration tests over http?

00:22:00.510 --> 00:22:04.580
Test harnesses typically assume that they
can communicate with your code in process,

00:22:04.580 --> 00:22:07.440
but when they get to the Cloud, that's no
longer possible.

00:22:07.440 --> 00:22:11.840
But Cloud Cover is going to help with this.
We're going to push your tests into the Cloud.

00:22:11.840 --> 00:22:13.820
We're going to install Cloud Cover along with
it.

00:22:13.820 --> 00:22:16.001
And through the Cloud Cover UI, we're going
to drive your tests.

00:22:16.001 --> 00:22:23.870
So let me give you a demo that's going to
illustrate how easy it is to take the test

00:22:23.870 --> 00:22:28.659
suite that we just built and deploy it to
the Cloud.

00:22:28.659 --> 00:22:32.139
The primary design goal of Cloud Cover is
to run existing test suites.

00:22:32.139 --> 00:22:35.940
I don't want you to have to retrofit everything
that you've already done to run in this specific

00:22:35.940 --> 00:22:38.750
environment.
I want your tests to run locally just as well

00:22:38.750 --> 00:22:43.701
as they run in the Cloud and vice versa.
So if you want to get your tests running in

00:22:43.701 --> 00:22:46.740
the Cloud, I've listed the steps here: You're
going to install a JAR.

00:22:46.740 --> 00:22:49.830
I'm not going to show you how to do that.
You're going to configure a Servlet.

00:22:49.830 --> 00:22:52.480
It's fairly boilerplate. The documentation
describes it nicely.

00:22:52.480 --> 00:22:57.080
You are going to replace the local service
test helper with Cloud Cover's own implementation

00:22:57.080 --> 00:23:01.470
of the local service test helper.
And the reason for that is that the local

00:23:01.470 --> 00:23:05.740
service test helper that I showed you when
I was writing those tests assumes that you're

00:23:05.740 --> 00:23:10.360
running locally with local services available.
But when you're running in the Cloud, those

00:23:10.360 --> 00:23:14.650
local services aren't available.
So we want to install Cloud Cover's version

00:23:14.650 --> 00:23:20.520
of this, which is really going to turn those
initialization steps into no ops.

00:23:20.520 --> 00:23:23.580
Because everything that you already need in
production is there.

00:23:23.580 --> 00:23:28.649
You don't need to set up that current environment.
You don't need to mess with the data store.

00:23:28.649 --> 00:23:32.799
Then, we're going to write one small class,
which is going to tell Cloud Cover about the

00:23:32.799 --> 00:23:35.011
test suite that it's going to run.
We're going to deploy, we're going to run,

00:23:35.011 --> 00:23:39.770
and we're going to feel good.
Oops. Before we get to that, let me show you

00:23:39.770 --> 00:23:46.600
the demo.
So, what do you think, Alon? Live or offline?

00:23:46.600 --> 00:23:53.740
Go for it? Let's see what happens.
So, I have this very simple demo queued up

00:23:53.740 --> 00:23:55.149
here.
This is the Cloud Cover UI.

00:23:55.149 --> 00:24:00.879
I'm going to click "start new run" and looking
good.

00:24:00.879 --> 00:24:04.909
Okay. So it ran extremely fast.
There are only three tests here, and it shows

00:24:04.909 --> 00:24:09.090
a failure.
Ooh, and I got a little XMPP message saying,

00:24:09.090 --> 00:24:12.710
"Hey, your test run is done" -- which is not
that useful when it takes five seconds, but

00:24:12.710 --> 00:24:20.249
if it takes an hour, that's nice.
And, this happened to fail because I included

00:24:20.249 --> 00:24:24.249
 -- intentionally -- a failure message, just
to show you what a failure looks like.

00:24:24.249 --> 00:24:30.379
But, these are the tests that we just wrote.
And I uploaded them before I came up here.

00:24:30.379 --> 00:24:33.620
So Test Async write succeeded. Test Sync Write
succeeded.

00:24:33.620 --> 00:24:40.220
And this is sort of a poor man's version of
what a testing UI looks like in your IDE or

00:24:40.220 --> 00:24:42.950
something like that.
But it's on the web.

00:24:42.950 --> 00:24:49.240
Now, there's something interesting going on
here, though.

00:24:49.240 --> 00:24:56.970
I've seen at least two other web test runners,
which appear to do something similar.

00:24:56.970 --> 00:25:01.260
And some of them are really gorgeous.
They have these unbelievably pretty UIs.

00:25:01.260 --> 00:25:06.929
One of them is called Kotori JUnit Web Runner.
And I just found out about it this week, and

00:25:06.929 --> 00:25:11.039
I need to talk to that developer to see if
we can collaborate, because their UI is absolutely

00:25:11.039 --> 00:25:12.620
gorgeous.
There's a link to it that should be in the

00:25:12.620 --> 00:25:17.360
live wave when we're finished.
But Cloud Cover's doing something a little

00:25:17.360 --> 00:25:20.720
bit different.
We're running your tests in parallel using

00:25:20.720 --> 00:25:25.159
the task queue.
We're creating one task queue task per test.

00:25:25.159 --> 00:25:27.539
And then, we're letting the workers run through
them.

00:25:27.539 --> 00:25:31.090
So, here's an example of what's going on.
When I click that "create new run" button,

00:25:31.090 --> 00:25:37.809
the tests are loading up in the suite.
The tests are being fed into the task queue.

00:25:37.809 --> 00:25:42.570
And then, once they're all fed in, the workers
start chewing on them.

00:25:42.570 --> 00:25:47.480
And this is all asynchronous, which means
we can do things in parallel.

00:25:47.480 --> 00:25:51.120
And when we're done, we get that nice little
XMPP notification or e-mail or however you

00:25:51.120 --> 00:25:59.980
want to get your notification -- you can configure
it, and you get the results of your test suite.

00:25:59.980 --> 00:26:06.549
[pause]
There are some additional things we need to

00:26:06.549 --> 00:26:11.190
think about when we want to run our tests
in the Cloud. Isolation.

00:26:11.190 --> 00:26:22.799
How many people have ever run an existing
unit test suite where the tests run in parallel?

00:26:22.799 --> 00:26:25.720
Googlers, right?
Because we have a framework that does it for

00:26:25.720 --> 00:26:28.019
us.
Okay. Not a Googler?

00:26:28.019 --> 00:26:32.320
Good. Okay. Great.
So, it gets more complicated, right?

00:26:32.320 --> 00:26:35.559
Your tests are now interacting with one another
in ways that you didn't expect.

00:26:35.559 --> 00:26:39.970
So this first example up here -- let's say
we have two tests -- one which deals with

00:26:39.970 --> 00:26:45.009
a "read through cache," which, when you ask
it for a value, if the value isn't there,

00:26:45.009 --> 00:26:48.890
it then turns around and asks the data store
for it.

00:26:48.890 --> 00:26:52.100
And then, you have some other tests, which
is just a simple query, right?

00:26:52.100 --> 00:26:55.769
Feed some data into the data store, issue
a query, make sure what you got back is what

00:26:55.769 --> 00:27:00.220
you expect.
You wouldn't expect there to be any interesting

00:27:00.220 --> 00:27:04.649
interactions, but if we wrote that explosive
delegate that I showed you in the earlier

00:27:04.649 --> 00:27:11.320
example, and we installed that, that explosive
delegate is global, which means that, if these

00:27:11.320 --> 00:27:18.629
two tests happen to hit these two same points
at the same time, the test that's just verifying

00:27:18.629 --> 00:27:22.289
the simple query is going to blow up, because
it's going to try to do something that talks

00:27:22.289 --> 00:27:25.350
to the data store, and that explosive delegate
is sitting there.

00:27:25.350 --> 00:27:28.379
And it's going to throw an exception, and
you're going to scratch your head thinking,

00:27:28.379 --> 00:27:30.899
"What went wrong? This didn't happen last
time."

00:27:30.899 --> 00:27:36.279
And now, you've got flaky tests.
Another example that we need to think about

00:27:36.279 --> 00:27:43.830
here is that your test data needs to be "thread
safe" -- and I put that in quotes.

00:27:43.830 --> 00:27:47.710
And these examples here -- we might have one
test that creates a user, another test that

00:27:47.710 --> 00:27:51.340
deletes a user.
And if they get to these two points at the

00:27:51.340 --> 00:27:56.830
same time where the creation test is asserting
that something exists after the deletion test

00:27:56.830 --> 00:28:01.659
has gone ahead and done its deletion.
Again, we're going to get a test failure in

00:28:01.659 --> 00:28:06.000
a way that we didn't expect, right?
We're looking at test create user, and it

00:28:06.000 --> 00:28:09.299
failed -- and we said -- "Well, we created
it. And then, we tried to read it back, and

00:28:09.299 --> 00:28:13.440
it's telling me it's not here -- what happened?"
Well, this other test deleted the data out

00:28:13.440 --> 00:28:17.159
from under you.
So non-thread safety gives you flakiness,

00:28:17.159 --> 00:28:20.730
and flakiness can be really frustrating because
it's difficult to reproduce.

00:28:20.730 --> 00:28:24.639
And even if you do reproduce it, you might
not reproduce it in the exact same way.

00:28:24.639 --> 00:28:29.419
So we need solutions to these problems.
Here are the solutions to these problems.

00:28:29.419 --> 00:28:36.039
These are both part of Cloud Cover.
For the delegates, we have an alternate delegate

00:28:36.039 --> 00:28:40.629
implementation that you will need to retrofit
your tests with.

00:28:40.629 --> 00:28:44.089
It's a thread-safe delegate.
So the example that I showed you at the beginning

00:28:44.089 --> 00:28:49.940
 -- instead of installing that delegate globally,
we will use a thread safe delegate so that

00:28:49.940 --> 00:28:55.070
that change will only be visible to the thread
that needs it.

00:28:55.070 --> 00:28:58.999
That's going to take care of it there.
We do have to make that change to our code,

00:28:58.999 --> 00:29:05.649
but it's a pretty minor change.
The other solution is very cool.

00:29:05.649 --> 00:29:10.960
We have a feature coming out shortly -- if
not in the next SDK, then probably the one

00:29:10.960 --> 00:29:16.259
after -- called "Name Spaces."
And this is a way to stripe your data.

00:29:16.259 --> 00:29:20.290
This is a way to scope your data.
So that you can perform some work within a

00:29:20.290 --> 00:29:23.059
certain name space.
And the work that you're doing with, say,

00:29:23.059 --> 00:29:29.159
the data store or mem cache -- all of that
persistent state is associated with that name

00:29:29.159 --> 00:29:32.440
space.
So we can isolate the data of different tests

00:29:32.440 --> 00:29:34.789
from one another.
And this is exactly what Cloud Cover does

00:29:34.789 --> 00:29:38.670
 -- every single test that's running has its
own name space.

00:29:38.670 --> 00:29:44.730
So in the example that I showed you before
 -- when we say that we are creating a user

00:29:44.730 --> 00:29:48.619
and then deleting a user, and some other test
is creating a user and then verifying that

00:29:48.619 --> 00:29:51.899
it exists.
Even if, from the application's point of view,

00:29:51.899 --> 00:29:56.919
those entities are identical, they're not
going to overlap.

00:29:56.919 --> 00:30:01.890
So, we've got our data isolation, and Cloud
Cover is going to take care of this for you.

00:30:01.890 --> 00:30:05.830
Thank you.
So, let me show you an example of this actually

00:30:05.830 --> 00:30:08.369
working.
The demo that I showed you before -- that

00:30:08.369 --> 00:30:11.519
was a talk demo.
It was very small.

00:30:11.519 --> 00:30:14.950
But I want to show you something real.
And I figured, "What better way to show you

00:30:14.950 --> 00:30:21.320
that this is real than to run a real test
suite in the Cloud using Cloud Cover?" So

00:30:21.320 --> 00:30:28.320
I've taken the test suite for the JDO/JPA
Implementation that ships as part of the Java

00:30:28.320 --> 00:30:32.360
SDK.
It's about 1300 unit and integration tests.

00:30:32.360 --> 00:30:39.299
And it does all of the hairy stuff you might
ever imagine a test suite could do with the

00:30:39.299 --> 00:30:44.070
local data store.
Every type of query you can think of -- installing

00:30:44.070 --> 00:30:47.970
custom delegates left and right -- this test
suite does it.

00:30:47.970 --> 00:30:55.769
And so, that's what I'm going to run here.
I will select it from my drop down.

00:30:55.769 --> 00:30:59.120
This test suite is called "data nucleus,"
because the test suite is built on the data

00:30:59.120 --> 00:31:04.350
nucleus access platform.
And I will start this running.

00:31:04.350 --> 00:31:08.470
This will not run as fast as the test that
I just showed you.

00:31:08.470 --> 00:31:12.249
I'm running half the test suite, because I
do want this to finish while I'm still up

00:31:12.249 --> 00:31:14.539
here.
It does take some time.

00:31:14.539 --> 00:31:20.330
This is an example of testing in the Cloud
for fidelity as opposed to efficiency.

00:31:20.330 --> 00:31:23.970
Almost all of these tests are doing lots and
lots and lots of data store interaction.

00:31:23.970 --> 00:31:28.470
Locally, it will run faster, because the local
data store is completely in memory.

00:31:28.470 --> 00:31:31.200
It will run slower here, because it's using
the real data store.

00:31:31.200 --> 00:31:34.269
It's actually communicating with the back
end data store.

00:31:34.269 --> 00:31:39.389
But, I do get the true experience of running
this code in the Cloud.

00:31:39.389 --> 00:31:46.159
So this is the test suite that we run before
we release a new implementation of the JDO

00:31:46.159 --> 00:31:49.020
and the JPA.
And, as we can see here, it's going along

00:31:49.020 --> 00:31:50.659
pretty well, actually.
It's at 34 percent.

00:31:50.659 --> 00:31:54.739
You'll notice that there's this item here
 -- "too slow."

00:31:54.739 --> 00:31:58.639
There's 148 tests that are too slow.
These are the tests that aren't finishing

00:31:58.639 --> 00:32:03.629
in 30 seconds.
At some point, I need to decide whether I

00:32:03.629 --> 00:32:06.739
want to break these tests up just so that
they pass on Cloud Cover.

00:32:06.739 --> 00:32:10.549
I might do it, because I really, really would
like to run this in Cloud Cover and see all

00:32:10.549 --> 00:32:11.889
green.
I haven't seen it yet.

00:32:11.889 --> 00:32:14.700
There are still a few interactions that I
haven't sorted out.

00:32:14.700 --> 00:32:17.320
But, by and large, this is working. You can
see it clicking away.

00:32:17.320 --> 00:32:21.480
We've got 68 tests that are running in parallel
right now.

00:32:21.480 --> 00:32:29.289
Let me show you in the admin console -- maybe
 -- what's going on behind the scenes.

00:32:29.289 --> 00:32:31.630
C'mon.
Yes! All right.

00:32:31.630 --> 00:32:34.929
So we can see our traffic spiked up a little
bit.

00:32:34.929 --> 00:32:38.809
But all of the real work is happening in the
task queues.

00:32:38.809 --> 00:32:43.200
You can see we've got 32 tasks in the queue.
We've run 1200 tasks in the last minute.

00:32:43.200 --> 00:32:51.190
And I can look in here, and you can see that
there is one task for every high-level test

00:32:51.190 --> 00:32:56.210
case that I'm executing.
And so, the workers are just clicking their

00:32:56.210 --> 00:33:00.460
way through.
I configured my default queue to have the

00:33:00.460 --> 00:33:03.049
maximum rate, because I want to get through
these as quickly as possible.

00:33:03.049 --> 00:33:07.549
The maximum rate is 50 tasks per second.
These tests aren't that fast.

00:33:07.549 --> 00:33:12.549
So I'm not actually scratching that limit.
But, I'm going to show you something in a

00:33:12.549 --> 00:33:19.509
little bit that definitely makes use of that.
So, let's go back -- let's see how we're doing

00:33:19.509 --> 00:33:22.539
here.
We're 93 percent done. We're just about finished.

00:33:22.539 --> 00:33:34.419
Yep, there it is. Okay, cool. [pause]
So, that was the fancy demo.

00:33:34.419 --> 00:33:37.190
And that should convince you that this is
real.

00:33:37.190 --> 00:33:41.710
That really is the real test suite doing all
sorts of hairy unit and integration testing

00:33:41.710 --> 00:33:46.470
stuff with App Engine running in the Cloud.
And it ran still pretty quickly even though

00:33:46.470 --> 00:33:51.799
it was using the real data store.
But let's take this a little bit further.

00:33:51.799 --> 00:33:59.169
Everything I've shown you so far has involved
running App Engine test suites in the Cloud.

00:33:59.169 --> 00:34:03.600
But why limit ourselves?
The Cloud Cover framework is agnostic.

00:34:03.600 --> 00:34:08.399
It doesn't care whether or not your code under
test uses App Engine.

00:34:08.399 --> 00:34:13.169
It doesn't care whether you're using JUnit
or TestNG or which version of J Unit.

00:34:13.169 --> 00:34:16.889
It's a little bit of work you have to do to
plug in a different test harness, but the

00:34:16.889 --> 00:34:22.490
framework itself is agnostic.
So if you have a large test suite -- even

00:34:22.490 --> 00:34:26.990
if it's a test suite for something that is
not App Engine, why not upload it and let

00:34:26.990 --> 00:34:31.690
App Engine be your grid?
So, let's do an arbitrary demo -- arbitrary

00:34:31.690 --> 00:34:36.629
code -- the Google Collections Framework.
If you're a Java developer and you're not

00:34:36.629 --> 00:34:39.549
familiar with the Google Collections Framework,
check it out.

00:34:39.549 --> 00:34:42.690
It's really, really useful. That's the end
of the plug.

00:34:42.690 --> 00:34:46.020
This is data structures, okay? It has nothing
to do with web apps.

00:34:46.020 --> 00:34:51.049
It doesn't know anything about the data store.
It was built long before App Engine ever existed.

00:34:51.049 --> 00:34:55.810
These guys have 44,000 tests.
I'm not going to run 44,000 tests.

00:34:55.810 --> 00:34:59.010
I can't get 44,000 tasks into the task queue
in 30 seconds.

00:34:59.010 --> 00:35:03.981
If I could, I would go for it.
But I am going to run a bunch of these tests.

00:35:03.981 --> 00:35:08.049
These tests have absolutely nothing to do
with App Engine.

00:35:08.049 --> 00:35:18.140
So I have uploaded that test suite.
This is the Google Collections test suite.

00:35:18.140 --> 00:35:28.300
And I'm going to start the run.
Now, this initial request is slow.

00:35:28.300 --> 00:35:33.200
This library does a lot of dynamic test generation.
It's working really hard.

00:35:33.200 --> 00:35:35.530
These folks didn't actually write 44,000 tests
by hand.

00:35:35.530 --> 00:35:40.190
They have a number of template tests, which
they're using for different map implementations

00:35:40.190 --> 00:35:46.040
and different list implementations.
And they have ways of generating tests for

00:35:46.040 --> 00:35:49.849
the different implementations of map and list
that they're providing over and over again.

00:35:49.849 --> 00:35:55.359
So they kind of exploded out.
But I'm running -- I think -- 2400 tests here?

00:35:55.359 --> 00:35:59.369
And this is humming along very nicely. I've
already finished 1500.

00:35:59.369 --> 00:36:04.369
This thing's going to be done very quickly.
I've got a failure -- the supplier's test.

00:36:04.369 --> 00:36:06.170
Let's see what's going on there.
Oh, it's already done.

00:36:06.170 --> 00:36:12.020
Okay. That was fast.
I look at this failure, and look what's failing

00:36:12.020 --> 00:36:16.340
 -- "Test Thread Safe."
Well, that shouldn't be too much of a surprise,

00:36:16.340 --> 00:36:17.820
right?
I told you up front that, if you're going

00:36:17.820 --> 00:36:21.420
to run your tests in the Cloud, your tests
in the code under tests have to abide by the

00:36:21.420 --> 00:36:25.180
restrictions of App Engine.
Here's a thread safety test.

00:36:25.180 --> 00:36:36.640
They're spinning up threads.
I can't run this test on Cloud Cover. [pause]

00:36:36.640 --> 00:36:40.619
But, this work will get done -- we will take
care of it on the Python side.

00:36:40.619 --> 00:36:46.250
We need to hone in on what the exact expectations
of Python developers are.

00:36:46.250 --> 00:36:51.790
Running tests inside the local sandbox -- this
is kind of a big one.

00:36:51.790 --> 00:36:56.460
Those tests that I showed you -- those integration
tests that I was running locally -- weren't

00:36:56.460 --> 00:37:00.099
running with any of the security restrictions
enabled.

00:37:00.099 --> 00:37:06.960
I could have written -- I'm sorry -- if the
code that I was testing did something that

00:37:06.960 --> 00:37:11.910
wouldn't run in App Engine like spin up a
thread, those tests still would have passed.

00:37:11.910 --> 00:37:16.270
It wasn't running in the secure JVM; it was
running in a raw JVM.

00:37:16.270 --> 00:37:21.569
So we need to figure out how to do this.
We want as much fidelity as possible, whether

00:37:21.569 --> 00:37:29.400
you're running in the Cloud or locally.
And part of making it a proper emulation is

00:37:29.400 --> 00:37:33.740
enforcing the security constraints when you're
running your application in the dev app server.

00:37:33.740 --> 00:37:36.540
We've got that working.
But when you're testing -- we don't have that

00:37:36.540 --> 00:37:41.160
working yet.
I tried to do it in time for this demo -- couldn't

00:37:41.160 --> 00:37:43.660
do it.
It's hard. We need to figure some stuff out.

00:37:43.660 --> 00:37:46.349
So we'll get to that.
And then, there are certain types of tests

00:37:46.349 --> 00:37:50.910
where you want to launch the actual dev app
server and throw some traffic at it.

00:37:50.910 --> 00:37:55.230
Or, in the case of the integration test that
I showed you when we were trying to figure

00:37:55.230 --> 00:38:00.320
out what happened with the task queue, and
we were extracting that greeting object from

00:38:00.320 --> 00:38:01.880
the task queue.
You might have been looking at that and thinking,

00:38:01.880 --> 00:38:06.980
"Well, rather than asserting on this sort
of -- these low-level bytes that are passing

00:38:06.980 --> 00:38:12.490
through the RPC layer, why don't you just
pause for a bit and wait for the task to execute?

00:38:12.490 --> 00:38:16.319
The reason is we're not in a good position
to actually write that test yet.

00:38:16.319 --> 00:38:21.710
The local task queue implementation uses the
URL fetch service, right?

00:38:21.710 --> 00:38:25.839
That's how tasks work in App Engine is you
give it a URL to hit.

00:38:25.839 --> 00:38:31.670
But in order to hit a URL, you need to have
an http server running, and we don't have

00:38:31.670 --> 00:38:34.099
that yet.
So we need to find a way to make that much

00:38:34.099 --> 00:38:38.160
easier to do so that you can write those types
of tests in the most natural way.

00:38:38.160 --> 00:38:42.420
For Cloud Cover, there's lots of really interesting
work to be done here, and I think we're just

00:38:42.420 --> 00:38:44.790
getting started.
And the cool thing is that it's completely

00:38:44.790 --> 00:38:47.720
open source.
There should be a link on the live wave -- if

00:38:47.720 --> 00:38:50.970
not now, then shortly -- that shows you where
you can download it.

00:38:50.970 --> 00:38:54.730
And if anybody wants to help out with this,
I've already got a bunch of feature requests

00:38:54.730 --> 00:38:56.599
filed.
If you've got your own ideas for what it should

00:38:56.599 --> 00:39:00.640
look like -- that would be cool.
If you want to make the UI look as beautiful

00:39:00.640 --> 00:39:05.059
as that other one that I referenced before,
that would be cool.

00:39:05.059 --> 00:39:11.589
Jump in. [pause]
So, the conclusions that I want to take -- that

00:39:11.589 --> 00:39:16.250
I hope -- that I want you to take away.
First and foremost -- developer testing is

00:39:16.250 --> 00:39:19.040
important.
If you didn't believe that coming in here,

00:39:19.040 --> 00:39:25.180
I hope I've convinced you to at least take
a good look at it.

00:39:25.180 --> 00:39:30.290
Mitigating that risk as your project grows
can really, really make a big difference in

00:39:30.290 --> 00:39:33.230
the long run.
The other thing I hope you see is that everything

00:39:33.230 --> 00:39:36.660
that you already know about testing transfers
to App Engine.

00:39:36.660 --> 00:39:39.910
This isn't the case where you need to unlearn
things and learn a totally different skill

00:39:39.910 --> 00:39:44.250
set.
If you know how to write testable apps already,

00:39:44.250 --> 00:39:46.660
you know how to write testable apps on App
Engine.

00:39:46.660 --> 00:39:53.300
If you know how to write effective tests already,
you know how to write effective apps on App

00:39:53.300 --> 00:39:55.510
Engine.
You just need to become familiar with a couple

00:39:55.510 --> 00:39:58.869
of the technical details that are specific
to App Engine.

00:39:58.869 --> 00:40:01.460
When it comes to local testing, use the App
Engine testing API.

00:40:01.460 --> 00:40:05.950
It's going to make your life much easier.
And when it's time to run your tests in the

00:40:05.950 --> 00:40:14.140
Cloud, use Cloud Cover, push your tests inside
the Cloud, and let Cloud Cover drive it.

00:40:14.140 --> 00:40:19.990
Finally, remember that -- even if you're not
a web application developer, you can still

00:40:19.990 --> 00:40:22.859
use App Engine.
App Engine is good at fan out.

00:40:22.859 --> 00:40:27.630
It's not a general-purpose computing platform,
but it's really good at web applications,

00:40:27.630 --> 00:40:30.490
and it's really good at fan out.
And if there is a fan out element to what

00:40:30.490 --> 00:40:33.350
you're doing, like with testing -- there's
a test suite.

00:40:33.350 --> 00:40:36.109
It's made up of individual tests.
They don't know anything about one another.

00:40:36.109 --> 00:40:41.039
They're not related to one another.
That type of problem can be very effectively

00:40:41.039 --> 00:40:46.940
solved by App Engine.
So keep your minds open. And now, let's do

00:40:46.940 --> 00:41:00.320
some questions.
Okay. And feel free to ask live questions

00:41:00.320 --> 00:41:07.840
as well. [chuckling]
So, the number one question on moderator -- I'll

00:41:07.840 --> 00:41:11.099
get to you in just one second - the number
one question on moderator was, "Is this talk

00:41:11.099 --> 00:41:17.020
Java specific?
I hope not." Conceptually, this all applies,

00:41:17.020 --> 00:41:19.420
right?
If you want to write Cloud Cover for Python,

00:41:19.420 --> 00:41:25.030
you could do it today -- except for the aspect
of the name spaces not being available yet.

00:41:25.030 --> 00:41:28.480
But you can write all of the code.
It just won't necessarily run if you're using

00:41:28.480 --> 00:41:33.440
the data store or mem cache.
So apologies to anyone in here who felt misled.

00:41:33.440 --> 00:41:35.730
Let's take a live question here.

00:41:35.730 --> 00:41:37.819
Q [first male audience member] Challenges
with data-driven testing -- one challenge

00:41:37.819 --> 00:41:39.920
is isolation.
The second challenge is the data set up proof.

00:41:39.920 --> 00:41:48.680
You have proofs like DB what's -- how do you
do that in App Engine?

00:41:48.680 --> 00:41:59.500
Max Ross: You were asking the hard questions
at the fireside chat yesterday too, right?

00:41:59.500 --> 00:42:06.020
Okay. [pause]
My personal approach is -- for unit and integration

00:42:06.020 --> 00:42:10.119
tests, I try to operate on a fairly limited
data set that I can set up easily within the

00:42:10.119 --> 00:42:13.450
30-second limit.
I'm not uploading megabytes and megabytes

00:42:13.450 --> 00:42:21.180
of data that I then assume the existence of
across multiple tests.

00:42:21.180 --> 00:42:27.470
I've been on projects where we did that before.
We ultimately moved away from it, because

00:42:27.470 --> 00:42:31.220
you will find yourself in the position where
you need to restore that data to its original

00:42:31.220 --> 00:42:33.630
state.
Or you find yourself in the position of pretending

00:42:33.630 --> 00:42:37.329
to commit transactions and then rolling them
back, but things sometimes fail when you commit

00:42:37.329 --> 00:42:39.470
 -- you miss out on opportunities to see those
errors.

00:42:39.470 --> 00:42:45.510
So, my approach is, try to write tests that
operate on limited data sets.

00:42:45.510 --> 00:42:50.319
I know that's not always practical.
If you find yourself in a position where you

00:42:50.319 --> 00:42:56.510
do need a large data set, testing that in
the Cloud -- right now that's going to be

00:42:56.510 --> 00:42:58.859
a challenge.
But, very good question. Yes.

00:42:58.859 --> 00:43:07.540
Q [second male audience member] I notice you
didn't use Dependency Injection. What's your

00:43:07.540 --> 00:43:08.540
take on Dependency Injection?

00:43:08.540 --> 00:43:14.349
Max Ross: I love Dependency Injection.
If -- I've used Guice a lot. I've used Spring

00:43:14.349 --> 00:43:18.410
a little bit.
We don't do it as part of the SDK, because

00:43:18.410 --> 00:43:23.950
we don't want to force any frameworks on you.
We want you to bring your own frameworks.

00:43:23.950 --> 00:43:31.609
So, in that particular data access object,
perhaps you caught that I was initializing

00:43:31.609 --> 00:43:37.250
private final members in line.
And that would be a smell in my own code.

00:43:37.250 --> 00:43:41.540
But in terms of keeping things short for a
demo, that's the way I initialized it.

00:43:41.540 --> 00:43:47.359
But, in general -- I should back up and say
 -- I don't think Dependency Injection is

00:43:47.359 --> 00:43:50.000
necessarily important.
I think inversion of control is important.

00:43:50.000 --> 00:43:55.300
And Dependency Injection, I think, is a very
effective way to get inversion of control.

00:43:55.300 --> 00:43:57.119
Didn't want to introduce any additional frameworks
here.

00:43:57.119 --> 00:44:01.210
And just, as a team, our general approach
is, we want to let you choose the frameworks

00:44:01.210 --> 00:44:06.210
that you want to use.
So that's why you don't see Guice as part

00:44:06.210 --> 00:44:11.180
of the SDK or Spring as part of the SDK.
That's your choice. We don't want to force

00:44:11.180 --> 00:44:16.079
that on you.
Okay. Let's see what else we have on moderator.

00:44:16.079 --> 00:44:19.410
Q [Max Ross reads question from moderator]
Any integrations with C?

00:44:19.410 --> 00:44:22.440
Continuous integrations with servers like
Hudson for testing monitoring?

00:44:22.440 --> 00:44:29.190
Max Ross: So, this is -- so no. But, all of
this can totally happen.

00:44:29.190 --> 00:44:34.530
This -- Cloud Cover is -- it's not nearly
as full-featured.

00:44:34.530 --> 00:44:38.609
But the idea is very similar to something
that we have running internally at Google

00:44:38.609 --> 00:44:43.950
that we use to run our tests.
And, in addition to running all of our tests,

00:44:43.950 --> 00:44:49.130
we have data repositories that keep track
of the history of our test runs.

00:44:49.130 --> 00:44:54.809
We've got all sorts of good analytical data.
So, all of this could happen with Cloud Cover.

00:44:54.809 --> 00:44:59.480
I can't think of any reason why Cloud Cover
can't be the external version of this thing

00:44:59.480 --> 00:45:03.799
that we have running internally, which is
incredibly useful in terms of integration

00:45:03.799 --> 00:45:09.869
with IDEs -- integration with other servers,
reporting metrics -- all of these things.

00:45:09.869 --> 00:45:16.130
You could even imagine going so far as to
have an online performance regression framework,

00:45:16.130 --> 00:45:19.800
which would be incredibly useful.
That sort of thing is so difficult to set

00:45:19.800 --> 00:45:25.391
up, but so valuable once you have it.
So. The answer to the specific question, "No,

00:45:25.391 --> 00:45:27.960
that integration doesn't exist."
But I think all of these things are possible,

00:45:27.960 --> 00:45:34.440
and I would love to talk with anybody who's
interested in pushing it in that direction.

00:45:34.440 --> 00:45:35.440
Live question.

00:45:35.440 --> 00:45:40.430
Q [third male audience member] Hi. Is the
App Engine testing API also Java-specific?

00:45:40.430 --> 00:45:44.410
Max Ross: The App Engine testing API is currently
Java only.

00:45:44.410 --> 00:45:46.930
And that is the thing that I want to rectify.

00:45:46.930 --> 00:45:52.890
Q [third male audience member] Because we'd
love to have Python --

00:45:52.890 --> 00:45:54.839
Max Ross: Yeah, I mean you can -- don't get
me wrong -- you can write tests for Python.

00:45:54.839 --> 00:46:00.520
It's just these libraries wrap up sort of
some of the messiness. Yes.

00:46:00.520 --> 00:46:13.600
Q [fourth male audience member] Hi. If I have
to execute a heavy multiple sweat test -- stress

00:46:13.600 --> 00:46:22.310
test.
So, should I let Google know beforehand?

00:46:22.310 --> 00:46:31.780
Max Ross: So if your test is similar.
If your test is a load test, then -- we have

00:46:31.780 --> 00:46:35.980
 -- in fact there was an IO talk two years
ago -- which should still be online -- by

00:46:35.980 --> 00:46:42.079
a fellow named Ken Ashcraft who talks about
load testing strategies for Google App Engine.

00:46:42.079 --> 00:46:47.640
So, the general piece of advice is, ramp up
slowly.

00:46:47.640 --> 00:46:50.430
Don't turn your traffic on like a brick wall,
right?

00:46:50.430 --> 00:46:55.369
If you look at your admin console, it should
ramp up as opposed to just being a giant step.

00:46:55.369 --> 00:46:58.250
And beyond that, I would recommend looking
at that talk.

00:46:58.250 --> 00:46:59.980
There's very useful strategies there.

00:46:59.980 --> 00:47:03.930
Q [fourth male audience member] So is there
any cap or?

00:47:03.930 --> 00:47:08.950
Max Ross: Well, it's just traffic to us, right?
It's just traffic to us.

00:47:08.950 --> 00:47:12.950
So we don't -- we can't distinguish between
a load test and traffic.

00:47:12.950 --> 00:47:18.770
It's just -- if your app's getting traffic,
we don't know what you're doing.

00:47:18.770 --> 00:47:20.520
Enable billing -- that will help.
Yeah, thank you. Yes.

00:47:20.520 --> 00:47:21.520
Q [fifth male audience member] Thanks for
your talk.

00:47:21.520 --> 00:47:22.520
So I've been running tests in parallel, in
sort of a cloudlike environment, for about

00:47:22.520 --> 00:47:32.040
eight years, so it's good to see other folks
doing that in App Engine now.

00:47:32.040 --> 00:47:33.040
Max Ross: Excellent.

00:47:33.040 --> 00:47:34.040
Q [fifth male audience member] You said you
wanted to take tests that run fine locally

00:47:34.040 --> 00:47:35.040
and then parellelize them. It seems like you
have to make a bunch of changes to them. There's

00:47:35.040 --> 00:47:41.319
this delegate thing and this Junit3 config
thing so does that mean once you've done that

00:47:41.319 --> 00:47:52.289
they no longer run locally or - 'cause you
really want both modes.

00:47:52.289 --> 00:48:00.119
Max Ross: Right. So, the changes that you
have to make and -- let me just show you,

00:48:00.119 --> 00:48:03.710
because I skipped over this part of my demo,
because I was working on time.

00:48:03.710 --> 00:48:07.029
So, to answer your question, "Once you make
these changes, do they still run locally?"

00:48:07.029 --> 00:48:11.590
"Yes, they absolutely run locally."
These Cloud Cover implementations of these

00:48:11.590 --> 00:48:16.710
classes that you're swapping things out for
can distinguish between a local run and a

00:48:16.710 --> 00:48:19.630
Cloud run.
So if you're running locally, they do the

00:48:19.630 --> 00:48:24.310
thing that they normally do.
And then, if they're running in the Cloud,

00:48:24.310 --> 00:48:29.170
then they do this slightly different behavior.
So, for this test that I wrote here, which

00:48:29.170 --> 00:48:36.520
was the Guestbook DAO test,
there are two changes. Here's the first one.

00:48:36.520 --> 00:48:43.900
[pause]
Okay. That's the first one.

00:48:43.900 --> 00:48:50.170
Which, and, you know, if this were in the
 -- for example in the JDO/JPA test suite,

00:48:50.170 --> 00:48:54.089
this helper set up is in one base class that
everything extends.

00:48:54.089 --> 00:48:58.450
So I didn't have to go through and change
it in 300 different places.

00:48:58.450 --> 00:49:06.619
The other thing that you have to do is, change
the delegate.

00:49:06.619 --> 00:49:12.369
And that's in this base class down here.
Where's "install?"

00:49:12.369 --> 00:49:24.849
Okay. And in this case -- I didn't rehearse
this part so I have to find my way through

00:49:24.849 --> 00:49:28.890
it.
But, it is the Cloud Cover local service test

00:49:28.890 --> 00:49:35.300
helper.
Set delegate. Actually, so the first thing

00:49:35.300 --> 00:49:43.470
we do here is, we're gonna replace that.
We're going to replace that. And that's it.

00:49:43.470 --> 00:49:47.789
That's really it.
So, it's still pretty compatible.

00:49:47.789 --> 00:49:53.910
It is true that your test suite is going to
have a dependency on Cloud Cover.

00:49:53.910 --> 00:49:59.040
It's a really small JAR.
I don't think it's really going to get in

00:49:59.040 --> 00:50:01.650
your way.
Does that answer your question? Yes.

00:50:01.650 --> 00:50:07.660
Q [sixth male audience member] Are there any
Selenium style test suites coming for Visualization?

00:50:07.660 --> 00:50:11.299
Max Ross: For Visualization -- I don't think
I understand.

00:50:11.299 --> 00:50:13.329
I'm sorry. I know Selenium.

00:50:13.329 --> 00:50:17.890
Q [sixth male audience member] I'm sorry,
for UI testing. It's a related question.

00:50:17.890 --> 00:50:22.770
Max Ross: Okay, okay, okay.
I think it ties into the thing we want to

00:50:22.770 --> 00:50:26.849
make better where we want to simplify the
process of running tests that fire up the

00:50:26.849 --> 00:50:32.670
dev app server.
That will make that sort of testing easier.

00:50:32.670 --> 00:50:39.950
When it comes to running these tests in production,
Selenium just wants to know what URL to hit,

00:50:39.950 --> 00:50:40.950
right?

00:50:40.950 --> 00:50:43.349
Q [sixth male audience member] You can actually
test click through scenarios with Selenium.

00:50:43.349 --> 00:50:53.000
I was wondering if Google was going to release
anything that's App Engine specific, so that

00:50:53.000 --> 00:50:58.069
we could test UI in Visualization on App Engine.

00:50:58.069 --> 00:51:04.559
Max Ross: We don't have any concrete plans,
but let's talk for a minute afterwards, because

00:51:04.559 --> 00:51:07.000
I have a feeling that I'm not fully grasping.

00:51:07.000 --> 00:51:09.920
Q [seventh male audience member] I have a
very similar question.

00:51:09.920 --> 00:51:10.920
Max Ross: Sure.

00:51:10.920 --> 00:51:12.349
Q [seventh male audience member] Is there
any plans to -- is anybody building a load

00:51:12.349 --> 00:51:18.130
testing kind of application on App Engine
which can do fan out?

00:51:18.130 --> 00:51:21.140
Like bus computing and --

00:51:21.140 --> 00:51:24.380
Max Ross: Where the load is generated by App
Engine?

00:51:24.380 --> 00:51:26.309
Q [seventh male audience member] App Engine
and perhaps just something.

00:51:26.309 --> 00:51:30.390
I mean, I'm sure that you have a lot of applications
which run on Webscape.

00:51:30.390 --> 00:51:35.160
Max Ross: I'm not aware of anybody building
that.

00:51:35.160 --> 00:51:40.751
Could be interesting.
I could take another question from moderator.

00:51:40.751 --> 00:51:47.779
Q [Max Ross reads question from moderator]
Will testing.API be available for a modern

00:51:47.779 --> 00:51:48.779
language?

00:51:48.779 --> 00:51:55.400
Max Ross: Ouch. If you consider Python a modern
language -- and I do -- I don't want to start

00:51:55.400 --> 00:51:59.030
any fights -- then, yes, it will be available.
It still hurts, though.

00:51:59.030 --> 00:52:00.030
[audience laughs]

00:52:00.030 --> 00:52:04.500
Q [eighth male audience member] Does local
memory data store persist collections using

00:52:04.500 --> 00:52:11.089
helper, using JDO/JUnit? All my tests are
failing.

00:52:11.089 --> 00:52:15.089
Max Ross: Sorry? All your tests are failing?

00:52:15.089 --> 00:52:17.990
Q [eight male audience member] My collections
never come back.

00:52:17.990 --> 00:52:24.339
Max Ross: Your collections never come back
when you're using JDO in your testing?

00:52:24.339 --> 00:52:29.640
I'm sure I could help you diagnose it.
There is a blogpost that I'm planning for

00:52:29.640 --> 00:52:35.059
my blog, which deals largely with recipes
for JDO and JPA.

00:52:35.059 --> 00:52:39.099
And there is a testing entry long overdue.
So when that entry comes out, I'm going to

00:52:39.099 --> 00:52:42.839
show you exactly how I do it.
The other thing you can do, though, is -- all

00:52:42.839 --> 00:52:47.730
this test suite for JDO and JPA that I ran
using Cloud Cover is also completely open

00:52:47.730 --> 00:52:51.050
source.
And you can download it, and you can type

00:52:51.050 --> 00:52:57.390
"ant test," and it will run.
And so, you can see 1300 examples of testing

00:52:57.390 --> 00:53:00.609
with JDO and JPA and there's lots and lots
of collections tests.

00:53:00.609 --> 00:53:03.630
It's hard to get right. Yeah.

00:53:03.630 --> 00:53:09.790
Q [ninth male audience member] Is the name
space feature you mentioned apply to the mem

00:53:09.790 --> 00:53:12.040
cache service as well?

00:53:12.040 --> 00:53:16.420
Max Ross: Yes. Data store and mem cache are
both name space aware.

00:53:16.420 --> 00:53:21.170
I have not tested Cloud Cover with mem cache
tests yet.

00:53:21.170 --> 00:53:25.170
I would not be shocked to find that I'm doing
something wrong.

00:53:25.170 --> 00:53:29.260
But I will test it before this name space
feature becomes generally available to make

00:53:29.260 --> 00:53:40.760
sure that, when you can use all of these features
in App Engine, you can also use all of these

00:53:40.760 --> 00:53:41.760
features in Cloud Cover.

00:53:41.760 --> 00:53:42.760
Max Ross: I think -- oh, there's one last
question here.

00:53:42.760 --> 00:53:44.140
Q [Max Ross reads question from moderator]
Can you do isolated end to end testing on

00:53:44.140 --> 00:53:46.430
the local GAE server?"

00:53:46.430 --> 00:53:57.490
Max Ross: I'm not sure I know what is meant
by "isolated."

00:53:57.490 --> 00:54:00.741
Is that referring to data set up and tear
down?

00:54:00.741 --> 00:54:07.720
I don't know. Okay.
So thank you all for coming.

00:54:07.720 --> 00:54:08.720
I really appreciate it.

00:54:08.720 --> 00:54:11.020
&gt;&gt; [Applause]

00:54:11.020 --> 00:54:20.140
Max Ross: And stay tuned for the next talk.
Alfred's going to be talking about next gen

00:54:20.140 --> 00:54:21.869
queries, and it's really cool stuff.

