WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.490
[MUSIC PLAYING]

00:00:08.615 --> 00:00:10.630
SHAILEN TULI: Hi, everyone.

00:00:10.630 --> 00:00:12.060
My name is Shailen Tuli.

00:00:12.060 --> 00:00:14.400
I am a developer
programs engineer

00:00:14.400 --> 00:00:16.620
working on Android at Google.

00:00:16.620 --> 00:00:19.980
And I'm here to talk
to you about building

00:00:19.980 --> 00:00:24.525
great apps for
Android O. Android

00:00:24.525 --> 00:00:26.010
O was kind of a big topic.

00:00:26.010 --> 00:00:29.141
There are lots of
cool things in O.

00:00:29.141 --> 00:00:31.140
And there's a talk later
in the afternoon that's

00:00:31.140 --> 00:00:34.590
going to cover many of them.

00:00:34.590 --> 00:00:41.780
My talk is going to focus on
a couple of topics, basically,

00:00:41.780 --> 00:00:46.520
what you can and cannot do
with regard to background work

00:00:46.520 --> 00:00:50.180
in your O apps and what you
can and cannot do with regard

00:00:50.180 --> 00:00:54.740
to location gathering when
your app is in the background.

00:00:54.740 --> 00:00:56.702
This is going to be a
fairly technical talk.

00:00:56.702 --> 00:00:58.535
I'm going to focus on
just those two issues.

00:01:01.130 --> 00:01:02.700
And I have a lot of material.

00:01:02.700 --> 00:01:04.420
So I'm going to
go a little fast.

00:01:04.420 --> 00:01:06.800
So you've been warned.

00:01:06.800 --> 00:01:10.700
OK, so why focus on
background so much?

00:01:10.700 --> 00:01:12.980
Why focus on background
limits that are coming

00:01:12.980 --> 00:01:16.550
in O and other location limits?

00:01:16.550 --> 00:01:19.550
Because first, I believe
these are some of the biggest

00:01:19.550 --> 00:01:22.310
changes in the platform.

00:01:22.310 --> 00:01:24.380
And these are changes
that have really, really

00:01:24.380 --> 00:01:27.590
great consequences for
you, app developers.

00:01:27.590 --> 00:01:29.330
Because I believe
these changes make

00:01:29.330 --> 00:01:33.030
Android an even better
platform for writing apps.

00:01:33.030 --> 00:01:34.880
So that's what I'm
going to be focusing on.

00:01:34.880 --> 00:01:37.940
I'll talk, of course,
about what the changes are,

00:01:37.940 --> 00:01:40.767
what strategies you can
use to deal with them.

00:01:40.767 --> 00:01:42.350
I'll talk also a
little bit about sort

00:01:42.350 --> 00:01:45.020
of historically how we have
come to this point where we have

00:01:45.020 --> 00:01:48.260
to limit what kind
of background work

00:01:48.260 --> 00:01:52.590
goes on generally and
specifically with regard

00:01:52.590 --> 00:01:57.060
to location, so sort of a little
historical overview of things.

00:01:57.060 --> 00:02:01.220
OK, so pretty much everything
I'm going to cover in this talk

00:02:01.220 --> 00:02:03.560
relates either to
system health--

00:02:03.560 --> 00:02:06.820
basically good ram
management-- or to battery,

00:02:06.820 --> 00:02:10.759
to how to get more
battery performant

00:02:10.759 --> 00:02:12.877
stuff happening in your apps.

00:02:12.877 --> 00:02:14.960
What I'll do is I'll start
with a little overview,

00:02:14.960 --> 00:02:17.240
just talk about a few
things that sort of just

00:02:17.240 --> 00:02:19.460
give you a sense of what's
really happening in O.

00:02:19.460 --> 00:02:22.160
And then we'll do we'll
do a deep dive into each

00:02:22.160 --> 00:02:25.110
of these topics afterwards.

00:02:25.110 --> 00:02:27.110
So the first thing with
regards to system health

00:02:27.110 --> 00:02:30.860
is there is a
limitation now in O

00:02:30.860 --> 00:02:33.770
that there will be no started
services in the background.

00:02:33.770 --> 00:02:36.000
This is kind of a big deal.

00:02:36.000 --> 00:02:38.510
But it really only applies
to started services

00:02:38.510 --> 00:02:39.380
in the background.

00:02:39.380 --> 00:02:40.880
When you're in the
foreground, there

00:02:40.880 --> 00:02:42.440
is no limitation to
started services.

00:02:42.440 --> 00:02:45.680
You can keep doing
what you're doing now.

00:02:45.680 --> 00:02:48.050
The other system health
issue is that there

00:02:48.050 --> 00:02:53.640
will be fairly substantial
limits on implicit broadcasts.

00:02:53.640 --> 00:02:56.780
So you can still have
explicit broadcasts.

00:02:56.780 --> 00:02:59.690
You can dynamically
register for broadcasts.

00:02:59.690 --> 00:03:02.160
But broadcast that
go into a manifest,

00:03:02.160 --> 00:03:05.540
there's going to be quite a
lot of limits placed on those.

00:03:05.540 --> 00:03:07.700
Again, we'll explore these.

00:03:07.700 --> 00:03:10.880
So the question is, when
do all these things happen?

00:03:10.880 --> 00:03:13.940
When do you have to start
worrying about these things?

00:03:13.940 --> 00:03:18.040
And the answer is, when you
increment your target SDK

00:03:18.040 --> 00:03:21.140
version to target
O. Now that may

00:03:21.140 --> 00:03:23.930
seem like distant
to some people,

00:03:23.930 --> 00:03:26.100
maybe not so distant to others.

00:03:26.100 --> 00:03:28.910
But I would urge everyone
to start thinking about this

00:03:28.910 --> 00:03:30.680
and thinking about it now.

00:03:30.680 --> 00:03:34.880
Because even today,
users of your apps

00:03:34.880 --> 00:03:38.420
can go into their
settings of their phones,

00:03:38.420 --> 00:03:41.060
figure out how much work
you're doing in the background,

00:03:41.060 --> 00:03:44.510
decide if that work is too
much, and essentially curtail

00:03:44.510 --> 00:03:45.680
that work.

00:03:45.680 --> 00:03:48.920
So like it or not, the
limits on background

00:03:48.920 --> 00:03:52.880
work that you can do,
those are here already.

00:03:52.880 --> 00:03:54.950
So it's something that
you as app developers

00:03:54.950 --> 00:03:56.450
kind of have to deal with.

00:03:56.450 --> 00:03:58.430
You'll deal with them
much more substantially

00:03:58.430 --> 00:04:00.530
when you upgrade
to O. But you have

00:04:00.530 --> 00:04:03.000
to deal with them now as well.

00:04:03.000 --> 00:04:04.580
So that's all system health.

00:04:04.580 --> 00:04:06.134
So let's talk about battery now.

00:04:06.134 --> 00:04:08.300
And that's pretty much the
focus of the changes that

00:04:08.300 --> 00:04:12.890
are coming in O have come in O.
So basically, what's happening

00:04:12.890 --> 00:04:19.418
is that, for battery reasons,
what kind of location gathering

00:04:19.418 --> 00:04:20.959
you can do in the
background is going

00:04:20.959 --> 00:04:23.930
to be substantially throttled.

00:04:23.930 --> 00:04:27.230
So if you have gotten
used to the idea of having

00:04:27.230 --> 00:04:30.620
very frequent updates, for
instance, in the foreground

00:04:30.620 --> 00:04:33.050
and in the background,
the foreground stuff

00:04:33.050 --> 00:04:34.340
is going to remain the same.

00:04:34.340 --> 00:04:37.440
The background stuff
will be quite different.

00:04:37.440 --> 00:04:39.590
And so the question is,
when does this kick in?

00:04:39.590 --> 00:04:41.900
When do these limits kick in?

00:04:41.900 --> 00:04:44.930
And the answer here
is, they kick in now.

00:04:44.930 --> 00:04:47.970
For any app that is
running on an O device,

00:04:47.970 --> 00:04:50.930
regardless of SDK version,
these background limits

00:04:50.930 --> 00:04:53.360
with regard to
location are here.

00:04:53.360 --> 00:04:55.880
So this means that, if you
have an app that does something

00:04:55.880 --> 00:05:00.800
with location and your
target SDK is N or M or L,

00:05:00.800 --> 00:05:05.360
that app may actually behave
quite differently without you

00:05:05.360 --> 00:05:07.040
having to change a line of code.

00:05:07.040 --> 00:05:08.860
That app, when it's
run on an O device,

00:05:08.860 --> 00:05:10.526
is going to start
behaving differently--

00:05:10.526 --> 00:05:12.030
could behave differently.

00:05:12.030 --> 00:05:15.030
So this is a fairly
significant change as well.

00:05:15.030 --> 00:05:18.710
And it's something that,
if you have a location

00:05:18.710 --> 00:05:23.730
component to your apps, you're
going to have to deal with.

00:05:23.730 --> 00:05:25.670
So these are big
changes, like no

00:05:25.670 --> 00:05:29.090
started services, limits on
what you can do with broadcasts,

00:05:29.090 --> 00:05:31.070
limits to what you can
do with background.

00:05:31.070 --> 00:05:34.410
So the question is,
why are we doing this?

00:05:34.410 --> 00:05:35.670
How did we get here?

00:05:35.670 --> 00:05:37.050
What's really going on?

00:05:37.050 --> 00:05:39.610
So the first thing is,
we're not doing this

00:05:39.610 --> 00:05:41.360
because we like being
difficult or we just

00:05:41.360 --> 00:05:43.730
like making people's
lives difficult. We're

00:05:43.730 --> 00:05:46.550
doing this because this
is, essentially, better

00:05:46.550 --> 00:05:47.540
for the platform.

00:05:47.540 --> 00:05:48.770
It's better for the users.

00:05:48.770 --> 00:05:54.650
The users want you to build
apps that are really, really

00:05:54.650 --> 00:05:58.160
performant, that do
really great things

00:05:58.160 --> 00:05:59.720
with brand management,
that do really

00:05:59.720 --> 00:06:02.540
great things with battery.

00:06:02.540 --> 00:06:04.400
The changes that
we've introduced in O

00:06:04.400 --> 00:06:06.110
have been a long
time in the coming.

00:06:06.110 --> 00:06:10.010
So we'll get to all the
details in a minute or two.

00:06:10.010 --> 00:06:11.660
But I'm going to
take a little while

00:06:11.660 --> 00:06:15.800
and just talk about how we got
here starting in Marshmallow.

00:06:15.800 --> 00:06:17.780
So go back to Marshmallow.

00:06:17.780 --> 00:06:20.810
And you remember that's
when we introduce Doze.

00:06:20.810 --> 00:06:22.280
So what's Doze?

00:06:22.280 --> 00:06:24.680
Just a recap that,
when your device

00:06:24.680 --> 00:06:27.380
is stationary, when
it's not charging,

00:06:27.380 --> 00:06:29.240
when the screen is
off, essentially,

00:06:29.240 --> 00:06:31.760
when it's not being
used, we said,

00:06:31.760 --> 00:06:33.500
you can't just go
crazy and do all sorts

00:06:33.500 --> 00:06:34.850
of things in the background.

00:06:34.850 --> 00:06:36.770
You've got to channel
all your background work

00:06:36.770 --> 00:06:39.380
into a very narrowly-defined,
well-defined maintenance

00:06:39.380 --> 00:06:40.400
windows.

00:06:40.400 --> 00:06:43.070
Because frankly, when a device
is just sort of sitting there,

00:06:43.070 --> 00:06:45.170
it should not be doing
really crazy things.

00:06:45.170 --> 00:06:48.800
It should be a very
well-behaved, quiet machine.

00:06:48.800 --> 00:06:51.830
So that's where Doze came in.

00:06:51.830 --> 00:06:53.927
Android M also gave
us app stand by.

00:06:53.927 --> 00:06:56.510
And the idea of there was that,
if you have background network

00:06:56.510 --> 00:07:00.980
activity, how that
activity was done

00:07:00.980 --> 00:07:02.720
was actually
dependent on how much

00:07:02.720 --> 00:07:06.110
or how little the user was
interacting with your app.

00:07:06.110 --> 00:07:08.570
Again, the idea is, if there's
background work being done,

00:07:08.570 --> 00:07:10.700
let's just do this
very carefully.

00:07:10.700 --> 00:07:13.670
And in Android N, we
give you Doze Light ,

00:07:13.670 --> 00:07:15.050
which is basically like Doze.

00:07:15.050 --> 00:07:17.750
But the difference is that
the device is not stationary.

00:07:17.750 --> 00:07:20.630
So think of, I have
my phone right here.

00:07:20.630 --> 00:07:21.740
It's not on.

00:07:21.740 --> 00:07:23.720
Obviously, it's not charging.

00:07:23.720 --> 00:07:25.900
But it's moving,
because I'm moving.

00:07:25.900 --> 00:07:29.990
And again, the idea was, even
then, you do background work

00:07:29.990 --> 00:07:31.550
pretty carefully.

00:07:31.550 --> 00:07:34.940
So all of this started off
a couple of releases ago.

00:07:34.940 --> 00:07:37.640
And what you're seeing
in O is pretty much

00:07:37.640 --> 00:07:44.600
a very natural progression of
what we introduced in M in N.

00:07:44.600 --> 00:07:48.470
So the other stuff that's very
significant is, starting in N,

00:07:48.470 --> 00:07:50.930
we started paying attention
to some broadcasts

00:07:50.930 --> 00:07:54.290
that we felt were excessively
noisy, they were causing system

00:07:54.290 --> 00:07:58.280
health problems, thrashing,
very visible jank for users.

00:07:58.280 --> 00:08:00.500
And we decided to
curtail what you

00:08:00.500 --> 00:08:02.490
could do with those broadcasts.

00:08:02.490 --> 00:08:07.490
So in Android N, we said, for
instance, the connection action

00:08:07.490 --> 00:08:09.710
broadcast, you could
not anymore listen

00:08:09.710 --> 00:08:11.420
for this in the register.

00:08:11.420 --> 00:08:15.860
And you could no longer register
for this in your manifests.

00:08:15.860 --> 00:08:18.470
And the reason was that it was
an extremely noisy broadcast.

00:08:18.470 --> 00:08:20.510
We didn't want to
be waking up apps

00:08:20.510 --> 00:08:23.510
to inform about
connectivity changes.

00:08:23.510 --> 00:08:25.316
It was too expensive.

00:08:25.316 --> 00:08:27.065
Similarly, there were
two other broadcasts

00:08:27.065 --> 00:08:30.350
that were targeted in N, and
that's Action New Picture,

00:08:30.350 --> 00:08:31.200
Action New Video.

00:08:31.200 --> 00:08:34.190
These are fired when
a user takes a picture

00:08:34.190 --> 00:08:36.830
or creates a little video.

00:08:36.830 --> 00:08:41.450
And so Action New Picture
is actually a great example

00:08:41.450 --> 00:08:44.420
to consider when you think
about what the system health

00:08:44.420 --> 00:08:48.450
implications are of allowing a
broadcast like that to happen.

00:08:48.450 --> 00:08:50.720
So imagine a user
takes out their phone,

00:08:50.720 --> 00:08:52.190
takes a photograph.

00:08:52.190 --> 00:08:56.840
At that point, there
are, let's say, 20 apps

00:08:56.840 --> 00:09:01.010
on the user's device which have
registered for this broadcast.

00:09:01.010 --> 00:09:02.960
The system says,
all right, let's go.

00:09:02.960 --> 00:09:03.950
Let's wake you up.

00:09:03.950 --> 00:09:07.160
Off we go, 1, 2, 3, 4, 5.

00:09:07.160 --> 00:09:09.680
And each of those apps now
wants to do some really great,

00:09:09.680 --> 00:09:10.430
impressive things.

00:09:10.430 --> 00:09:13.026
Because who doesn't want
to impress the user, right?

00:09:13.026 --> 00:09:14.150
And so they start Services.

00:09:14.150 --> 00:09:16.160
They start expensive stuff.

00:09:16.160 --> 00:09:18.440
And before you know,
the system is saying,

00:09:18.440 --> 00:09:20.900
hey, apps 6, 7,
8, I can't really

00:09:20.900 --> 00:09:24.080
launch you before I
kill off 1, 2 and 3,

00:09:24.080 --> 00:09:25.180
and so on, and so forth.

00:09:25.180 --> 00:09:29.120
And so the system is, in
this point, in turbulence.

00:09:29.120 --> 00:09:30.470
It's launching stuff.

00:09:30.470 --> 00:09:31.330
It's creating stuff.

00:09:31.330 --> 00:09:35.060
It's killing stuff,
doing whatever it can.

00:09:35.060 --> 00:09:38.135
Heaven forbid the user takes
a second or a third picture,

00:09:38.135 --> 00:09:40.250
it goes even more crazy.

00:09:40.250 --> 00:09:43.760
So in Android N, we said, this
is no way for an operating

00:09:43.760 --> 00:09:44.900
system to be behaving.

00:09:44.900 --> 00:09:47.531
You cannot register for
these things in a manifest.

00:09:47.531 --> 00:09:49.280
We're not going to be
waking up your apps.

00:09:49.280 --> 00:09:51.620
We're not going to go crazy
every time somebody takes

00:09:51.620 --> 00:09:55.010
a picture or makes a video.

00:09:55.010 --> 00:09:57.626
So that's the
background to that.

00:09:57.626 --> 00:09:59.000
Now the location
stuff that we're

00:09:59.000 --> 00:10:02.650
going to talk about is largely
driven by battery concerns.

00:10:02.650 --> 00:10:05.390
And battery has been a huge
issue for us year, after year,

00:10:05.390 --> 00:10:08.090
after year, after year.

00:10:08.090 --> 00:10:13.430
In our surveys,
one in three users

00:10:13.430 --> 00:10:15.560
say that battery
is the number one

00:10:15.560 --> 00:10:17.300
concern for them about Android.

00:10:19.880 --> 00:10:23.810
And what happens is
users, rightly or wrongly,

00:10:23.810 --> 00:10:26.840
associate location
with battery drain.

00:10:26.840 --> 00:10:29.690
And because they do that,
they go and disable location

00:10:29.690 --> 00:10:32.270
all together, which
makes all the nice apps

00:10:32.270 --> 00:10:35.150
that you guys have written
either not work at all

00:10:35.150 --> 00:10:37.216
or they work in a
degraded manner.

00:10:37.216 --> 00:10:38.840
This is not good for
the app developer.

00:10:38.840 --> 00:10:40.060
It's not good for the user.

00:10:40.060 --> 00:10:42.770
It's not good for
Android as a platform.

00:10:42.770 --> 00:10:49.510
So this time in O, Google has
taken a very serious approach

00:10:49.510 --> 00:10:54.370
to battery management and
targeted background usage

00:10:54.370 --> 00:10:57.520
of location as a
primary culprit, which

00:10:57.520 --> 00:10:59.540
needs to be sort of
carefully managed

00:10:59.540 --> 00:11:01.620
for battery to work well.

00:11:01.620 --> 00:11:04.660
All right, so that's
the historical stuff.

00:11:04.660 --> 00:11:08.276
One more little segue before
we dive into O elements, which

00:11:08.276 --> 00:11:10.900
is that, all through this time,
we're going to be talking about

00:11:10.900 --> 00:11:14.050
started services,
implicit broadcasts,

00:11:14.050 --> 00:11:15.277
background location.

00:11:15.277 --> 00:11:17.110
And it's a good thing
to take maybe a minute

00:11:17.110 --> 00:11:20.110
and say, what exactly
is foreground?

00:11:20.110 --> 00:11:21.280
What exactly is background?

00:11:21.280 --> 00:11:24.340
It's sort of obvious at one
level and maybe not so obvious

00:11:24.340 --> 00:11:26.770
at another.

00:11:26.770 --> 00:11:30.820
So the obvious stuff, when you
have a visible app component,

00:11:30.820 --> 00:11:32.830
when the user can
see your app, when

00:11:32.830 --> 00:11:35.569
your activity is
started or resumed,

00:11:35.569 --> 00:11:36.610
you're in the foreground.

00:11:36.610 --> 00:11:39.070
When you have a widget,
you're in the foreground--

00:11:39.070 --> 00:11:41.590
fairly obvious.

00:11:41.590 --> 00:11:43.630
When you have a
foreground service,

00:11:43.630 --> 00:11:46.250
you are considered in the
foreground-- kind of obvious.

00:11:46.250 --> 00:11:47.580
It's a foreground service.

00:11:47.580 --> 00:11:49.760
Don't let the service
part fool you.

00:11:49.760 --> 00:11:51.430
Stay with the word foreground.

00:11:51.430 --> 00:11:54.520
You are in the foreground
with a foreground service.

00:11:54.520 --> 00:11:56.790
When you have a bound
service and there

00:11:56.790 --> 00:11:59.860
is a client in the foreground
binding to that service,

00:11:59.860 --> 00:12:03.160
you are then also
in the foreground.

00:12:03.160 --> 00:12:05.440
When you have a content
provider and there

00:12:05.440 --> 00:12:08.440
is something that is in
the foreground accessing

00:12:08.440 --> 00:12:12.940
that content provider, you are
then also in the foreground.

00:12:12.940 --> 00:12:15.730
And then there's a slew of
sort of very specialized

00:12:15.730 --> 00:12:17.680
cases, which, if you
read about these,

00:12:17.680 --> 00:12:20.800
you will understand, yeah, these
kind of have to be foreground.

00:12:20.800 --> 00:12:23.094
And accessibility
service, for instance,

00:12:23.094 --> 00:12:25.510
has to perform all sorts of
actions on behalf of the user.

00:12:25.510 --> 00:12:27.850
It has to be
considered foreground.

00:12:27.850 --> 00:12:31.070
Notification listener
service, app start account

00:12:31.070 --> 00:12:33.070
authenticator,
wallpaper service--

00:12:33.070 --> 00:12:37.240
you can find documentation
on developmer.android.com

00:12:37.240 --> 00:12:41.020
explaining all of
this pretty carefully.

00:12:41.020 --> 00:12:43.150
The good news is, in
all of these cases

00:12:43.150 --> 00:12:46.300
that I mentioned,
nothing that relates

00:12:46.300 --> 00:12:49.670
to background limits in Android
O applies, none of that.

00:12:49.670 --> 00:12:51.670
If you're in the foreground,
you can pretty much

00:12:51.670 --> 00:12:55.300
do whatever you could do
in any release up till now.

00:12:55.300 --> 00:12:57.760
Nothing really changes for you.

00:12:57.760 --> 00:13:00.969
But when are you now
not in the foreground?

00:13:00.969 --> 00:13:02.260
When are you in the background?

00:13:02.260 --> 00:13:04.570
So you're no visible
app component,

00:13:04.570 --> 00:13:06.820
so your activity has stopped.

00:13:06.820 --> 00:13:09.700
There's no widget.

00:13:09.700 --> 00:13:11.350
You are in a
started service that

00:13:11.350 --> 00:13:13.490
is not a foreground service.

00:13:13.490 --> 00:13:16.150
So that would put you
in the background.

00:13:16.150 --> 00:13:18.790
You are in a JobService.

00:13:18.790 --> 00:13:22.605
We'll be talking a lot about
JobScheduler and jobs later on.

00:13:22.605 --> 00:13:24.550
But when you're in
that part of the code,

00:13:24.550 --> 00:13:28.210
you are, again, going
to be in the background.

00:13:28.210 --> 00:13:31.990
And when you're dealing with the
broadcast inside your broadcast

00:13:31.990 --> 00:13:37.150
receiver, you also, in this
time, are in the background.

00:13:37.150 --> 00:13:39.090
And all of these
cases, the background

00:13:39.090 --> 00:13:43.010
limits that have been introduced
in O, they will apply.

00:13:43.010 --> 00:13:44.410
So it's kind of a big deal.

00:13:44.410 --> 00:13:48.130
Trivial apps can do without
dealing with broadcasts,

00:13:48.130 --> 00:13:49.979
and services, et cetera.

00:13:49.979 --> 00:13:51.520
Most people don't
write trivial apps.

00:13:51.520 --> 00:13:53.200
They write mature apps.

00:13:53.200 --> 00:13:56.420
Those apps will be
affected by these changes.

00:13:56.420 --> 00:13:58.960
So I'm going to
dive into Services

00:13:58.960 --> 00:14:02.170
and what's changing with
Services in Android O, lots

00:14:02.170 --> 00:14:03.649
of fun stuff.

00:14:03.649 --> 00:14:05.440
As I said, this is a
pretty technical talk,

00:14:05.440 --> 00:14:08.380
so we'll go deep into this.

00:14:08.380 --> 00:14:11.470
From now on, applications
can no longer freely

00:14:11.470 --> 00:14:13.570
execute background Services.

00:14:13.570 --> 00:14:16.990
So the idea is, we want you to
stop thinking about services

00:14:16.990 --> 00:14:18.280
and start thinking about jobs.

00:14:18.280 --> 00:14:21.266
Move to JobScheduler or
Firebase JobDispatcher

00:14:21.266 --> 00:14:23.140
for the kind of work
that you would currently

00:14:23.140 --> 00:14:25.550
give to Services.

00:14:25.550 --> 00:14:29.080
Apps that are doing ongoing
work with regard to broadcasts

00:14:29.080 --> 00:14:31.450
should also start
thinking about jobs.

00:14:31.450 --> 00:14:35.530
Because starting a
service, for instance,

00:14:35.530 --> 00:14:37.886
to do something in
response to a broadcast

00:14:37.886 --> 00:14:39.010
will no longer be possible.

00:14:42.050 --> 00:14:44.380
The idea behind these
changes is fundamentally

00:14:44.380 --> 00:14:47.410
that, if expensive work or
potentially expensive work

00:14:47.410 --> 00:14:50.750
is being done on
behalf of the user,

00:14:50.750 --> 00:14:52.300
the user should
be aware of that.

00:14:52.300 --> 00:14:54.340
It should be
visible to the user.

00:14:54.340 --> 00:14:58.630
If you are doing things that
cost the user data, battery,

00:14:58.630 --> 00:15:02.269
ram, whatever, the user
should sort of say, hey,

00:15:02.269 --> 00:15:03.310
I know you're doing this.

00:15:03.310 --> 00:15:03.830
I approve.

00:15:03.830 --> 00:15:06.470
This is making my app
experience really quite good.

00:15:06.470 --> 00:15:07.720
Keep doing it.

00:15:07.720 --> 00:15:09.400
We don't want
expensive work sort

00:15:09.400 --> 00:15:12.400
of happening quietly
in a clandestine manner

00:15:12.400 --> 00:15:14.240
without the user's approval.

00:15:14.240 --> 00:15:18.560
So that's the guiding principle
behind a lot of these changes.

00:15:18.560 --> 00:15:21.946
So now what happens if
you do call start service

00:15:21.946 --> 00:15:23.320
and you're not in
the foreground?

00:15:23.320 --> 00:15:25.660
You get an illegal
state exception.

00:15:25.660 --> 00:15:28.099
If appending intent
is involved, then you

00:15:28.099 --> 00:15:29.140
won't get this exception.

00:15:29.140 --> 00:15:30.140
But it still won't work.

00:15:30.140 --> 00:15:32.470
You'll get a log warning.

00:15:32.470 --> 00:15:35.380
Basically, there isn't a way,
when you're in the background,

00:15:35.380 --> 00:15:39.020
to start a service anymore.

00:15:39.020 --> 00:15:43.840
So this is kind of a big deal.

00:15:43.840 --> 00:15:45.590
I don't know if you
think it's a big deal.

00:15:45.590 --> 00:15:47.131
But when I first
found out about this

00:15:47.131 --> 00:15:50.350
I was like, whoa,
that's a big deal.

00:15:50.350 --> 00:15:53.370
But there are, actually,
some very practical ways

00:15:53.370 --> 00:15:56.220
in which this is softened up.

00:15:56.220 --> 00:15:59.460
So one of them is that
there is a grace period.

00:15:59.460 --> 00:16:02.340
So Services continue
to run on for a while

00:16:02.340 --> 00:16:04.190
once you lose your
foreground status.

00:16:04.190 --> 00:16:07.410
So take an example
of, you have an app.

00:16:07.410 --> 00:16:09.480
The app does some.

00:16:09.480 --> 00:16:11.220
The user is using the app.

00:16:11.220 --> 00:16:12.225
It launches a service.

00:16:12.225 --> 00:16:14.370
The service is doing fine.

00:16:14.370 --> 00:16:16.320
And then the user
swipes away your app.

00:16:16.320 --> 00:16:17.100
It's gone now.

00:16:17.100 --> 00:16:18.957
It's no longer in
the foreground.

00:16:18.957 --> 00:16:20.790
The service won't be
killed off immediately.

00:16:20.790 --> 00:16:24.390
There will be a few
minutes of grace period

00:16:24.390 --> 00:16:27.280
where the service will continue
to run, at which point,

00:16:27.280 --> 00:16:29.820
the system will step in and
say, OK, enough of that.

00:16:29.820 --> 00:16:31.350
And it will kill
of that service.

00:16:31.350 --> 00:16:32.820
But it won't be immediate.

00:16:32.820 --> 00:16:34.200
And effectively,
what will happen

00:16:34.200 --> 00:16:38.310
in a few minutes is the
service's on destroy method

00:16:38.310 --> 00:16:39.030
will be called.

00:16:39.030 --> 00:16:42.900
And it will be as if the
service had called stop self.

00:16:42.900 --> 00:16:46.170
The system will just
do that for you.

00:16:46.170 --> 00:16:48.900
But it's nice that
it's not abrupt.

00:16:48.900 --> 00:16:50.710
There is a grace period.

00:16:50.710 --> 00:16:53.700
The second is, I think, the
realization that, sometimes

00:16:53.700 --> 00:16:56.040
when you are in the
background, your app

00:16:56.040 --> 00:16:59.190
is going to want to
respond to certain events.

00:16:59.190 --> 00:17:01.070
They may be very
user-visible events.

00:17:01.070 --> 00:17:02.880
They may be other
kind of events.

00:17:02.880 --> 00:17:07.380
And for that, there is a process
to temporarily whitelist apps,

00:17:07.380 --> 00:17:10.710
to temporarily treat apps as
if they were in the foreground

00:17:10.710 --> 00:17:12.690
for doing very specific things.

00:17:12.690 --> 00:17:15.910
This is probably best
explained with some examples.

00:17:15.910 --> 00:17:18.300
So let's say you have
a high-priority cloud

00:17:18.300 --> 00:17:21.180
message coming down
to your device that

00:17:21.180 --> 00:17:24.180
pierces those restrictions.

00:17:24.180 --> 00:17:26.280
And your app now wants
to do something with it.

00:17:26.280 --> 00:17:28.800
So we give you a period
of a few seconds--

00:17:28.800 --> 00:17:30.210
less than a minute--

00:17:30.210 --> 00:17:33.570
whereby you can be
considered foreground and you

00:17:33.570 --> 00:17:35.620
can launch Services.

00:17:35.620 --> 00:17:39.210
Similarly, if you have an
SMS or an NMS delivery,

00:17:39.210 --> 00:17:41.020
you may want to respond to that.

00:17:41.020 --> 00:17:44.160
So again, that is a short
window where you are given

00:17:44.160 --> 00:17:46.230
temporary foreground status.

00:17:46.230 --> 00:17:48.740
And you can respond to that.

00:17:48.740 --> 00:17:53.450
And in Android O, notifications
are kind of a big deal.

00:17:53.450 --> 00:17:57.720
When you are responding to a
notification action of any kind

00:17:57.720 --> 00:18:01.500
and there's a pending intent
involved, at that point,

00:18:01.500 --> 00:18:04.900
you are treated as if you
are in the foreground.

00:18:04.900 --> 00:18:07.064
So this is sort of a
very pragmatic approach

00:18:07.064 --> 00:18:08.480
that the framework
team has taken.

00:18:08.480 --> 00:18:11.310
They've said, by
and large, we don't

00:18:11.310 --> 00:18:13.540
want you doing expensive
work in the background.

00:18:13.540 --> 00:18:15.870
But we do understand that
there are some cases where

00:18:15.870 --> 00:18:16.860
you need to do it.

00:18:16.860 --> 00:18:18.900
And here's how you do them.

00:18:18.900 --> 00:18:24.450
So this whitelisting
process should, in fact,

00:18:24.450 --> 00:18:27.030
help most developers
target what they

00:18:27.030 --> 00:18:29.064
need to do pretty effectively.

00:18:29.064 --> 00:18:29.730
That's our hope.

00:18:32.970 --> 00:18:36.030
Foreground services are not
affected by any of this.

00:18:36.030 --> 00:18:39.240
So you can have a
foreground service,

00:18:39.240 --> 00:18:41.520
have a persistent notification.

00:18:41.520 --> 00:18:42.500
The user sees that.

00:18:42.500 --> 00:18:44.370
And life is good.

00:18:44.370 --> 00:18:48.420
The only problem is
that foreground services

00:18:48.420 --> 00:18:50.370
have typically been
done in two steps.

00:18:50.370 --> 00:18:52.240
You start a service
in the background.

00:18:52.240 --> 00:18:53.970
And then you promote
it to foreground.

00:18:53.970 --> 00:18:55.803
The first part is not
going to work anymore.

00:18:55.803 --> 00:18:57.750
You can't start Services
in the background.

00:18:57.750 --> 00:19:00.870
So there is a new API for
starting foreground services.

00:19:00.870 --> 00:19:02.700
Essentially, it does
that two-step thing

00:19:02.700 --> 00:19:03.866
and it just does it for you.

00:19:07.150 --> 00:19:10.080
We'll talk more about
foreground services

00:19:10.080 --> 00:19:13.150
and the appropriateness of
foreground services in a bit.

00:19:13.150 --> 00:19:16.950
So a question I was asked when
I did this presentation in India

00:19:16.950 --> 00:19:20.730
by a developer, he said, do
you expose any kind of API

00:19:20.730 --> 00:19:24.270
where I can tell if it's
safe to start service or not?

00:19:24.270 --> 00:19:25.590
No, we do not.

00:19:25.590 --> 00:19:28.780
It's for the app developer
to figure out when it is safe

00:19:28.780 --> 00:19:31.560
and when it is not safe
to start a service.

00:19:31.560 --> 00:19:33.999
Essentially you have to
sort of do your homework

00:19:33.999 --> 00:19:36.540
and figure out when you're in
the foreground, when you're not

00:19:36.540 --> 00:19:40.610
in the foreground,
and go with that.

00:19:40.610 --> 00:19:43.700
So that's the gist
of the Services part.

00:19:43.700 --> 00:19:47.000
A couple of other points
to tidy up, bound services

00:19:47.000 --> 00:19:49.010
are unchanged.

00:19:49.010 --> 00:19:51.530
Because we're thinking
much more about foreground

00:19:51.530 --> 00:19:54.290
and background, there are
some sort of semantics

00:19:54.290 --> 00:19:56.430
of this that are interesting.

00:19:56.430 --> 00:20:00.650
So for instance, if
I'm in the foreground

00:20:00.650 --> 00:20:03.890
and I'm binding to one of my own
services, that's no big deal.

00:20:03.890 --> 00:20:06.800
If I'm in the foreground and
I'm binding to somebody else's

00:20:06.800 --> 00:20:08.810
service and they're
in the background,

00:20:08.810 --> 00:20:11.600
then they too will be
considered foreground.

00:20:11.600 --> 00:20:14.900
Because a foreground client
elevates their status

00:20:14.900 --> 00:20:16.224
to foreground as well.

00:20:16.224 --> 00:20:18.140
So these are sort of
things that, as you start

00:20:18.140 --> 00:20:23.030
thinking in sort O semantics,
in O terms much more,

00:20:23.030 --> 00:20:24.837
will be very obvious.

00:20:24.837 --> 00:20:26.420
It's not something
that I taught a lot

00:20:26.420 --> 00:20:28.850
about when I was writing code.

00:20:28.850 --> 00:20:31.760
So this is going to be a
little bit of an adjustment

00:20:31.760 --> 00:20:37.940
as we go into O. All
right, here we go.

00:20:37.940 --> 00:20:41.320
A question that's asked me,
what about IntentServices?

00:20:41.320 --> 00:20:43.160
You've talked about
started services.

00:20:43.160 --> 00:20:44.290
What about IntentServices?

00:20:44.290 --> 00:20:46.100
IntentServices
are just services.

00:20:46.100 --> 00:20:47.744
They are started services.

00:20:47.744 --> 00:20:49.160
Everything I've
said about started

00:20:49.160 --> 00:20:51.820
services applies to them

00:20:51.820 --> 00:20:55.170
And in fact, this is
kind of a big deal.

00:20:55.170 --> 00:20:57.680
So the support library
now has support

00:20:57.680 --> 00:21:00.500
for the JobIntentService class.

00:21:00.500 --> 00:21:02.490
And that's supposed
to be a replacement.

00:21:02.490 --> 00:21:04.790
It could be considered a
replacement for IntentService.

00:21:04.790 --> 00:21:09.040
We'll talk more
about this in a bit.

00:21:09.040 --> 00:21:11.500
Fundamentally, we
would like to start

00:21:11.500 --> 00:21:15.460
thinking that jobs are the
way you want to go about this.

00:21:15.460 --> 00:21:19.750
Services, expensive
broadcasts are really

00:21:19.750 --> 00:21:21.100
have served us well--

00:21:21.100 --> 00:21:25.510
somewhat well-- up till O,
which from now on, JobScheduler,

00:21:25.510 --> 00:21:30.130
Firebase, JobDispatcher and jobs
are your real Swiss Army Knife

00:21:30.130 --> 00:21:33.954
as you go forward
building your apps.

00:21:33.954 --> 00:21:34.745
So that's services.

00:21:34.745 --> 00:21:40.280
A lot of stuff are
taken, a lot of changes.

00:21:40.280 --> 00:21:42.790
So I'm going to throw more stuff
at you now about background

00:21:42.790 --> 00:21:46.010
limits and broadcasts.

00:21:46.010 --> 00:21:50.200
So the limitation is
on implicit broadcasts.

00:21:50.200 --> 00:21:52.810
And the gist of
it is that limits

00:21:52.810 --> 00:21:55.750
to implicit broadcasts
delivered to manifest

00:21:55.750 --> 00:21:58.600
defined receivers are not going
to be honored for the most

00:21:58.600 --> 00:21:59.870
part.

00:21:59.870 --> 00:22:04.770
So at this point,
the question comes,

00:22:04.770 --> 00:22:06.360
what is an explicit broadcast?

00:22:06.360 --> 00:22:07.740
What is an implicit broadcast?

00:22:07.740 --> 00:22:09.198
If you go to Stack
Overflow, you'll

00:22:09.198 --> 00:22:11.820
see lots of confusing
answers about that.

00:22:11.820 --> 00:22:15.270
And the answer here simply is,
if a broadcast is explicitly

00:22:15.270 --> 00:22:17.790
targeted at something, at
someone, at some package,

00:22:17.790 --> 00:22:21.120
at some app, then it's
an explicit broadcast.

00:22:21.120 --> 00:22:22.920
And you can put
it your manifest.

00:22:22.920 --> 00:22:24.870
If it is not, if it's
a general broadcast

00:22:24.870 --> 00:22:26.940
that is sort of sent
out into the wild,

00:22:26.940 --> 00:22:28.500
it's an implicit broadcast.

00:22:28.500 --> 00:22:30.760
And you should not put
it in your manifest.

00:22:30.760 --> 00:22:34.530
So take, for example,
action package replaced.

00:22:34.530 --> 00:22:39.900
Action packaged replaced, if you
register for this before O in N

00:22:39.900 --> 00:22:42.810
and lower, you will have
this broadcast go off

00:22:42.810 --> 00:22:45.820
every time any packages
is placed on your device.

00:22:45.820 --> 00:22:47.340
That's pretty noisy, right?

00:22:50.260 --> 00:22:52.840
Contrast that with action
my package replaced.

00:22:52.840 --> 00:22:56.050
In this case, a broadcast
is sent only to me,

00:22:56.050 --> 00:22:58.420
because my package
has been replaced.

00:22:58.420 --> 00:23:00.790
So this is kind of
a big distinction.

00:23:00.790 --> 00:23:02.890
It's not always
incredibly intuitive.

00:23:02.890 --> 00:23:04.840
But I think this is
something that developers

00:23:04.840 --> 00:23:06.580
will have to think about.

00:23:06.580 --> 00:23:08.570
Explicit broadcasts
can still be put

00:23:08.570 --> 00:23:10.150
in the manifest, no problem.

00:23:12.700 --> 00:23:15.460
Now there are some
implicit broadcasts

00:23:15.460 --> 00:23:20.410
that the framework team has
understood need to be allowed.

00:23:20.410 --> 00:23:23.830
And if you follow these,
there's a pretty good reason

00:23:23.830 --> 00:23:27.700
why each one of these is
permitted to still be put

00:23:27.700 --> 00:23:30.260
in O world in your manifest.

00:23:30.260 --> 00:23:33.310
So action boot completed,
OK, this fires once.

00:23:33.310 --> 00:23:36.150
It's required by apps to set
up jobs, alarms, et cetera,

00:23:36.150 --> 00:23:37.060
et cetera.

00:23:37.060 --> 00:23:38.930
It's not hugely disruptive.

00:23:38.930 --> 00:23:40.270
It's OK.

00:23:40.270 --> 00:23:43.660
Action locale changed,
well, your locale presumably

00:23:43.660 --> 00:23:45.760
doesn't change a whole lot.

00:23:45.760 --> 00:23:48.040
And when it does, it's
not totally unreasonable

00:23:48.040 --> 00:23:50.980
that apps will want
to respond to that.

00:23:50.980 --> 00:23:54.400
Action headset plug,
now this is, the user

00:23:54.400 --> 00:23:55.780
plugs in their headset.

00:23:55.780 --> 00:23:59.890
So at that point, there's
a user action involved.

00:23:59.890 --> 00:24:02.526
It's not entirely unreasonable
that some app is going

00:24:02.526 --> 00:24:03.650
to want to respond to that.

00:24:03.650 --> 00:24:06.730
Again, this is not
hugely disruptive.

00:24:06.730 --> 00:24:09.250
When you have received an
SMS, you'll want to respond.

00:24:09.250 --> 00:24:10.750
This is a very partial list.

00:24:10.750 --> 00:24:15.940
The whole documentation is
there our androiddeveloper.com.

00:24:15.940 --> 00:24:19.390
And it will explain to you
why all these broadcasts,

00:24:19.390 --> 00:24:22.750
while they're implicit, are
still actually completely OK.

00:24:25.360 --> 00:24:30.340
The dynamic registration of
for broadcast is completely OK.

00:24:30.340 --> 00:24:32.210
Nothing of this has changed.

00:24:32.210 --> 00:24:35.820
So you can always use
context or registerReceiver.

00:24:35.820 --> 00:24:37.900
And as long as that
context is valid,

00:24:37.900 --> 00:24:40.561
you will get whatever
broadcast you registered here.

00:24:40.561 --> 00:24:41.560
So that's completely OK.

00:24:41.560 --> 00:24:42.670
It's not changed.

00:24:42.670 --> 00:24:44.625
The idea is, if your
app is being used,

00:24:44.625 --> 00:24:46.660
if there's an active
context, and you

00:24:46.660 --> 00:24:48.280
register for a
broadcast, it's not

00:24:48.280 --> 00:24:51.220
hugely disruptive for the system
to give you that broadcast.

00:24:51.220 --> 00:24:55.130
But if your app is asleep,
that's a different thing.

00:24:55.130 --> 00:24:58.990
So that's the way to think
about these limitations that

00:24:58.990 --> 00:25:01.960
are being introduced in O.

00:25:01.960 --> 00:25:03.700
So at this point,
you're thinking, well,

00:25:03.700 --> 00:25:07.570
this is fantastic
for users, right?

00:25:07.570 --> 00:25:08.879
Your battery is preserved.

00:25:08.879 --> 00:25:10.420
Your system health
is so much better,

00:25:10.420 --> 00:25:12.640
no long-running services.

00:25:12.640 --> 00:25:15.400
All the noise that was generated
by these broadcasts, that's

00:25:15.400 --> 00:25:17.190
pretty much quieted down.

00:25:17.190 --> 00:25:18.530
What about me, the developer?

00:25:18.530 --> 00:25:21.190
I had all these great ideas,
all these great plans.

00:25:21.190 --> 00:25:24.610
What am I supposed to do?

00:25:24.610 --> 00:25:28.300
So let's talk a
little bit about that.

00:25:28.300 --> 00:25:30.780
What you can do is a
bunch of strategies.

00:25:30.780 --> 00:25:34.630
So first, instead of having
long-running services,

00:25:34.630 --> 00:25:38.484
if there is some external
stimulus that changes something

00:25:38.484 --> 00:25:40.900
in your app or that wants to
change something in your app,

00:25:40.900 --> 00:25:42.660
use Cloud Messaging.

00:25:42.660 --> 00:25:43.360
It's fantastic.

00:25:43.360 --> 00:25:45.490
You can use Cloud Messaging.

00:25:45.490 --> 00:25:48.130
If you use high priority,
it'll peer through those.

00:25:48.130 --> 00:25:50.380
It'll give you temporary
foreground status.

00:25:50.380 --> 00:25:52.490
And you're good to go.

00:25:52.490 --> 00:25:55.390
If you use normal priority,
that's still very good.

00:25:55.390 --> 00:25:58.330
Because now the operating
system can very judiciously,

00:25:58.330 --> 00:26:03.280
carefully, efficiently schedule
the work that you want to do.

00:26:03.280 --> 00:26:05.680
Normal priority should
be your default.

00:26:05.680 --> 00:26:07.822
You don't want to abuse this.

00:26:07.822 --> 00:26:09.280
And you want to
preserve the system

00:26:09.280 --> 00:26:12.030
health that comes from that.

00:26:12.030 --> 00:26:14.120
Another thing is you can
use JobIntentService.

00:26:14.120 --> 00:26:16.510
I'd mentioned that
a few slides ago.

00:26:16.510 --> 00:26:20.710
JobIntentService is part
of the support library.

00:26:20.710 --> 00:26:22.580
It's very new.

00:26:22.580 --> 00:26:25.060
It should be considered a
replacement for IntentService.

00:26:25.060 --> 00:26:26.770
And basically, what
it will do, it's

00:26:26.770 --> 00:26:28.477
aware of background limits.

00:26:28.477 --> 00:26:30.310
And it will just sort
of do the right thing.

00:26:30.310 --> 00:26:35.800
In pre-O apps, it will
run context start service.

00:26:35.800 --> 00:26:38.320
And in O and beyond
O apps, it will

00:26:38.320 --> 00:26:42.490
run JobScheduler.nq for work.

00:26:42.490 --> 00:26:44.590
So this is a pretty
good way to sort of

00:26:44.590 --> 00:26:46.810
have all that abstracted away.

00:26:46.810 --> 00:26:50.260
And you don't have
to think about it.

00:26:50.260 --> 00:26:53.470
WakefulBroadcastReceiver
is now deprecated.

00:26:53.470 --> 00:26:55.540
The whole point of
WakefulBroadcastReceiver

00:26:55.540 --> 00:26:57.520
was that you were
handling a broadcast.

00:26:57.520 --> 00:27:01.880
And you kick off a service
or something like that.

00:27:01.880 --> 00:27:03.050
You can't do that anymore.

00:27:03.050 --> 00:27:05.425
So there's really no reason
to have this sticking around.

00:27:07.686 --> 00:27:10.060
And finally-- and this is kind
of an important conceptual

00:27:10.060 --> 00:27:10.960
point--

00:27:10.960 --> 00:27:13.709
you want the operating
system to be your friend.

00:27:13.709 --> 00:27:15.250
All right, so go
back to that example

00:27:15.250 --> 00:27:18.850
I gave of somebody taking
a picture, which spins off

00:27:18.850 --> 00:27:22.300
the starting off of 10,
15, 20 apps, all of which

00:27:22.300 --> 00:27:24.280
are now starting services.

00:27:24.280 --> 00:27:25.750
At that point, the
operating system

00:27:25.750 --> 00:27:27.200
can do one of two things.

00:27:27.200 --> 00:27:29.230
It can either run your app.

00:27:29.230 --> 00:27:30.610
Or it can kill your app.

00:27:30.610 --> 00:27:32.690
It cannot do anything else.

00:27:32.690 --> 00:27:33.940
It will try to run everything.

00:27:33.940 --> 00:27:37.240
But when it loses the
ability to run everything,

00:27:37.240 --> 00:27:38.860
it will start killing things.

00:27:38.860 --> 00:27:40.360
You don't want your
operating system

00:27:40.360 --> 00:27:42.190
to be turned into a killer.

00:27:42.190 --> 00:27:46.060
You want your work to be
scheduled intelligently

00:27:46.060 --> 00:27:47.440
by the operating system.

00:27:47.440 --> 00:27:51.430
So for that reason, it's
much better to use jobs.

00:27:51.430 --> 00:27:53.710
When you use jobs,
the operating system

00:27:53.710 --> 00:27:56.910
can say, all right, 1,
2, 3, I run you now.

00:27:56.910 --> 00:27:57.940
4 or 5 are run new.

00:27:57.940 --> 00:27:59.140
I run 1 again.

00:27:59.140 --> 00:28:01.060
It can schedule
that intelligently.

00:28:01.060 --> 00:28:02.950
So you want to go for that.

00:28:02.950 --> 00:28:05.860
We encourage you
to use JobScheduler

00:28:05.860 --> 00:28:08.080
as much as you can.

00:28:08.080 --> 00:28:14.410
And the big topic, you can
use foreground services

00:28:14.410 --> 00:28:16.720
for doing all sorts
of great work.

00:28:16.720 --> 00:28:18.410
And there are no limits.

00:28:18.410 --> 00:28:21.670
So a very big temptation
would be to say, oh, my god,

00:28:21.670 --> 00:28:24.310
so much is changing in
O. I'm going to just slap

00:28:24.310 --> 00:28:25.920
on in foreground service.

00:28:25.920 --> 00:28:28.090
And I don't have to
think about this.

00:28:28.090 --> 00:28:30.580
The problem with that is,
the foreground service

00:28:30.580 --> 00:28:33.250
has a certain meaning, right?

00:28:33.250 --> 00:28:37.210
When I'm listening to music,
when I'm in a fitness app, when

00:28:37.210 --> 00:28:39.430
I'm using Maps
and navigation, it

00:28:39.430 --> 00:28:42.610
makes sense that there is
a notification to the top

00:28:42.610 --> 00:28:45.400
and that it's doing work for
me, even when I'm not actively

00:28:45.400 --> 00:28:47.230
engaging with the app.

00:28:47.230 --> 00:28:48.949
If that is the case
in your apps, great.

00:28:48.949 --> 00:28:49.990
Use a foreground service.

00:28:49.990 --> 00:28:51.680
It's a fantastic idea.

00:28:51.680 --> 00:28:53.410
But if it isn't,
the users are going

00:28:53.410 --> 00:28:55.060
to start wondering,
why the hell there

00:28:55.060 --> 00:28:58.360
is this persistent notifications
at the top telling them

00:28:58.360 --> 00:29:01.030
that you're doing extensive
work that they don't understand?

00:29:01.030 --> 00:29:03.400
They'll probably
either stop it work,

00:29:03.400 --> 00:29:05.990
or worse still,
uninstall your app.

00:29:05.990 --> 00:29:07.630
You don't want that to happen.

00:29:07.630 --> 00:29:10.010
Use foreground services
if it makes sense.

00:29:10.010 --> 00:29:13.180
If it doesn't make sense, think
of all the other strategies

00:29:13.180 --> 00:29:15.520
that we've outlined
and go with those.

00:29:18.470 --> 00:29:21.760
And finally, since O is pretty
much putting you in a position

00:29:21.760 --> 00:29:24.594
where you have to
think about background

00:29:24.594 --> 00:29:26.260
and what you're doing
in the background,

00:29:26.260 --> 00:29:27.790
I think it's a good
time to ask, do

00:29:27.790 --> 00:29:30.430
you really need to do
all this background work?

00:29:30.430 --> 00:29:33.700
I think there has been a sense
for many, many, many years

00:29:33.700 --> 00:29:38.940
now in Android that it's cool to
just spin up something and have

00:29:38.940 --> 00:29:40.690
it run forever and
ever in the background.

00:29:40.690 --> 00:29:43.322
And the system will
somehow handle it.

00:29:43.322 --> 00:29:45.280
Well, now the system is
telling you, no, no, we

00:29:45.280 --> 00:29:46.279
don't want to handle it.

00:29:46.279 --> 00:29:48.110
We don't want this to happen.

00:29:48.110 --> 00:29:50.440
So if we are really
at the point where

00:29:50.440 --> 00:29:53.320
we are questioning all this,
it's a good time to ask,

00:29:53.320 --> 00:29:55.750
hey, I started doing
all this background work

00:29:55.750 --> 00:29:57.910
three years, four
years ago in my app.

00:29:57.910 --> 00:30:00.230
Do I really still
need to do this?

00:30:00.230 --> 00:30:02.410
The answer sometimes you
will find will be, no.

00:30:02.410 --> 00:30:06.080
I don't really need to do this,
in which case, you shouldn't.

00:30:06.080 --> 00:30:10.170
All right, fast
segue to location.

00:30:10.170 --> 00:30:12.900
So first of all, location
is kind of a huge topic.

00:30:12.900 --> 00:30:15.300
It's used in a ton of apps.

00:30:15.300 --> 00:30:16.950
In fact, when I
started looking at logs

00:30:16.950 --> 00:30:18.930
to see who was using
location, I was surprised,

00:30:18.930 --> 00:30:22.140
like, oh, I didn't think all
these apps were using location.

00:30:22.140 --> 00:30:23.810
But they are.

00:30:23.810 --> 00:30:27.840
And in Android O, all the
limitations on location

00:30:27.840 --> 00:30:30.030
are actually very significant.

00:30:30.030 --> 00:30:33.340
So let's talk about those.

00:30:33.340 --> 00:30:35.640
So again, as I mentioned,
people treat location

00:30:35.640 --> 00:30:37.580
as they associate that
with battery drain.

00:30:37.580 --> 00:30:40.290
They turn off location.

00:30:40.290 --> 00:30:42.370
And your apps don't
work properly.

00:30:42.370 --> 00:30:45.390
So we believe this
doesn't help anyone.

00:30:45.390 --> 00:30:48.070
We believe that location
should be used wisely.

00:30:48.070 --> 00:30:49.320
It should be used efficiently.

00:30:49.320 --> 00:30:52.920
It should not be
conflated automatically

00:30:52.920 --> 00:30:55.660
with battery drain.

00:30:55.660 --> 00:30:58.950
We want people to love
their location apps, right?

00:30:58.950 --> 00:31:04.539
So this is where kind of big
changes have happened in O.

00:31:04.539 --> 00:31:06.080
And you will see,
while this may seem

00:31:06.080 --> 00:31:07.730
a little dramatic
at first, you can

00:31:07.730 --> 00:31:09.550
see how much better
an experience

00:31:09.550 --> 00:31:13.350
this will be going forward
for app developers.

00:31:13.350 --> 00:31:18.410
So the location limits
are that background apps

00:31:18.410 --> 00:31:21.265
will receive location
in a very throttled way.

00:31:21.265 --> 00:31:22.640
So when you're in
the foreground,

00:31:22.640 --> 00:31:24.230
you can pretty much
request location--

00:31:24.230 --> 00:31:25.730
I don't know-- as
often as you want.

00:31:25.730 --> 00:31:27.290
Let's say you want updates.

00:31:27.290 --> 00:31:31.370
You can have location
updates 30 seconds, whatever.

00:31:31.370 --> 00:31:32.900
Once you go in
the background, we

00:31:32.900 --> 00:31:37.710
will give you location
updates a few times an hour.

00:31:37.710 --> 00:31:39.370
That's it.

00:31:39.370 --> 00:31:42.610
So this is kind of a big deal.

00:31:45.850 --> 00:31:50.000
And this will happen, regardless
of the target STK version.

00:31:50.000 --> 00:31:53.290
So on your N apps, your
M apps, your L apps,

00:31:53.290 --> 00:31:55.510
and whatever, this will
start happening now,

00:31:55.510 --> 00:31:57.930
the moment O devices start
appearing on the market.

00:32:01.470 --> 00:32:03.730
You can use batching.

00:32:03.730 --> 00:32:06.070
And what that does is it
collects location ever

00:32:06.070 --> 00:32:08.530
so many times and then
delivers all those location

00:32:08.530 --> 00:32:12.460
data to you in a batched way.

00:32:12.460 --> 00:32:16.620
And that's the way that you
can get more data points.

00:32:16.620 --> 00:32:19.319
And you trade latency
for more data.

00:32:19.319 --> 00:32:20.860
But your data will
still be delivered

00:32:20.860 --> 00:32:22.510
only a few times an hour.

00:32:25.570 --> 00:32:28.570
There's changes in
O to Wi-Fi scanning.

00:32:28.570 --> 00:32:31.990
So we could have an
entire talk about,

00:32:31.990 --> 00:32:34.330
what makes location expensive?

00:32:34.330 --> 00:32:36.310
What doesn't make it expensive?

00:32:36.310 --> 00:32:38.650
But GPS is very
expensive-- super accurate,

00:32:38.650 --> 00:32:39.880
but very expensive.

00:32:39.880 --> 00:32:42.220
Wi-Fi isn't actually that cheap.

00:32:42.220 --> 00:32:46.000
So now the deal is that
no location computation

00:32:46.000 --> 00:32:48.580
will be performed when
the device stays connected

00:32:48.580 --> 00:32:50.470
to same static access point.

00:32:50.470 --> 00:32:51.790
There's no need for it.

00:32:51.790 --> 00:32:53.290
Your location isn't changing.

00:32:53.290 --> 00:32:55.390
We're going to sort of be
very judicious in making

00:32:55.390 --> 00:32:59.530
Wi-Fi scans, because
they're expensive.

00:32:59.530 --> 00:33:03.190
And this is good
for a lot of people.

00:33:03.190 --> 00:33:04.720
For me, I spend--

00:33:04.720 --> 00:33:09.100
I don't know-- at a time,
8, 10, 12, 15 hours at home.

00:33:09.100 --> 00:33:10.630
I'm connected to the same Wi-Fi.

00:33:10.630 --> 00:33:12.130
Why the hell does
location services

00:33:12.130 --> 00:33:14.260
have to compute my
location over and over?

00:33:14.260 --> 00:33:16.150
It's not changing.

00:33:16.150 --> 00:33:23.440
Similarly, when I'm at work and
I spend 8, 10, hopefully not

00:33:23.440 --> 00:33:28.260
15 hours at work, again, I'm
connected to the same Wi-Fi.

00:33:28.260 --> 00:33:29.710
Nothing is changing.

00:33:29.710 --> 00:33:34.540
Why does location service
have to expend energies

00:33:34.540 --> 00:33:35.980
trying to compute my location?

00:33:35.980 --> 00:33:39.147
Most people spend a lot of
time at home or at work.

00:33:39.147 --> 00:33:41.230
So there's a lot of changes
to Wi-Fi scanning that

00:33:41.230 --> 00:33:42.700
actually make O much better.

00:33:45.880 --> 00:33:49.220
There's also changes in O
to how Geofencing works.

00:33:49.220 --> 00:33:54.730
So it was quite normal up
till O to scan for Geofencing

00:33:54.730 --> 00:33:55.510
every few seconds.

00:33:58.370 --> 00:34:01.570
And we have now made that
not every few seconds,

00:34:01.570 --> 00:34:04.100
but around a two minute latency.

00:34:04.100 --> 00:34:05.710
This is sort of vague.

00:34:05.710 --> 00:34:08.170
But what we noticed
that, even going from,

00:34:08.170 --> 00:34:11.949
let's say, tens of seconds
to two minutes for Geofencing

00:34:11.949 --> 00:34:15.560
latency, gave us dramatic
battery performance.

00:34:15.560 --> 00:34:17.320
In some devices, it was 10x.

00:34:17.320 --> 00:34:18.949
It's a little bit
device-dependent,

00:34:18.949 --> 00:34:21.070
so it's not always
going to be 10x.

00:34:21.070 --> 00:34:23.189
But we found it to be
really quite dramatic.

00:34:23.189 --> 00:34:24.730
So that's another
change that's come.

00:34:27.820 --> 00:34:30.040
So this is all, up
to now, everything

00:34:30.040 --> 00:34:31.659
I've said about
location is about what

00:34:31.659 --> 00:34:35.449
happens when you run
your N app, your M app,

00:34:35.449 --> 00:34:38.760
your L app on an old device.

00:34:38.760 --> 00:34:41.320
What happens when you
actually start targeting O?

00:34:41.320 --> 00:34:43.840
What happens to location?

00:34:43.840 --> 00:34:45.670
So the first thing
is, we've always

00:34:45.670 --> 00:34:48.940
told you, when you
request locations,

00:34:48.940 --> 00:34:51.610
use a PendingIntent.getService.

00:34:51.610 --> 00:34:53.110
That's one of the
arguments that you

00:34:53.110 --> 00:34:56.860
pass to your location request.

00:34:56.860 --> 00:34:59.680
You can't do that
anymore, because it's

00:34:59.680 --> 00:35:03.120
O. There is no getService.

00:35:03.120 --> 00:35:04.852
Background services
can't be started.

00:35:04.852 --> 00:35:07.060
So you're going to have to
have a different strategy.

00:35:07.060 --> 00:35:11.620
And that strategy is you use
PendingIntent or getBroadcast.

00:35:11.620 --> 00:35:14.740
And then you go and register
an explicit broadcast

00:35:14.740 --> 00:35:15.840
in your manifest.

00:35:15.840 --> 00:35:18.230
And that will work.

00:35:18.230 --> 00:35:22.430
So the targeting of
O is not hugely hard.

00:35:22.430 --> 00:35:27.020
I think it should be
fairly painless to do it.

00:35:27.020 --> 00:35:29.240
Getting adjusted to
the idea that you

00:35:29.240 --> 00:35:32.892
are running on O when
you hadn't planned to

00:35:32.892 --> 00:35:34.100
is going to be an adjustment.

00:35:34.100 --> 00:35:37.790
And I would urge all of you to
start thinking about this fast.

00:35:37.790 --> 00:35:40.160
So what are good
location strategies?

00:35:40.160 --> 00:35:42.260
Like, what can you
do as developers now?

00:35:42.260 --> 00:35:44.300
Because frankly, with
the location stuff,

00:35:44.300 --> 00:35:46.130
these changes are here now.

00:35:46.130 --> 00:35:48.694
Sooner or later, O devices
are going to start showing up.

00:35:48.694 --> 00:35:51.110
And people are going to start
running your apps on those O

00:35:51.110 --> 00:35:52.290
devices.

00:35:52.290 --> 00:35:55.080
And then they will notice that
location works differently.

00:35:55.080 --> 00:35:58.250
So a very good strategy,
instead of having

00:35:58.250 --> 00:36:02.090
long-running services or
expensive and very fast

00:36:02.090 --> 00:36:03.860
location updates
in the background,

00:36:03.860 --> 00:36:06.500
is to start using
Geofencing much more.

00:36:06.500 --> 00:36:11.270
We have generally found that
people use Geofencing less

00:36:11.270 --> 00:36:13.310
than we would like them to.

00:36:13.310 --> 00:36:17.150
Geofencing is very, very,
very supremely optimized for

00:36:17.150 --> 00:36:18.360
performance.

00:36:18.360 --> 00:36:20.940
So for instance, if I have
a geofence around the Krakow

00:36:20.940 --> 00:36:23.930
airport, and I have a
geofence around the airport

00:36:23.930 --> 00:36:25.820
that I will be flying
to in a couple of days

00:36:25.820 --> 00:36:28.610
in San Francisco,
location services

00:36:28.610 --> 00:36:32.120
knows that there is no
chance that-- there's

00:36:32.120 --> 00:36:36.350
no reason for it to
expend any cycles trying

00:36:36.350 --> 00:36:38.640
to track the geofence
that's in San Francisco.

00:36:38.640 --> 00:36:40.157
I'm not there.

00:36:40.157 --> 00:36:41.990
But it also knows, I'm
actually not that far

00:36:41.990 --> 00:36:43.280
from the Krakow airport.

00:36:43.280 --> 00:36:46.910
So it will very
carefully and judiciously

00:36:46.910 --> 00:36:48.430
monitor that geofence.

00:36:48.430 --> 00:36:51.470
So a lot of the use cases
for location updates

00:36:51.470 --> 00:36:54.660
involve updates around an area.

00:36:54.660 --> 00:36:56.030
When am I near home?

00:36:56.030 --> 00:36:57.770
When am I near a restaurant?

00:36:57.770 --> 00:37:00.920
When am I leaving a place,
et cetera, et cetera.

00:37:00.920 --> 00:37:03.440
And Geofencing can be
a huge, huge asset.

00:37:03.440 --> 00:37:06.770
So please use it
as much as you can.

00:37:06.770 --> 00:37:07.910
Use batching.

00:37:07.910 --> 00:37:09.920
So I promised I'd talk
more about batching,

00:37:09.920 --> 00:37:11.180
so I'll do that now.

00:37:11.180 --> 00:37:12.650
Essentially what
you're doing is,

00:37:12.650 --> 00:37:14.390
when you're in the
background, you're

00:37:14.390 --> 00:37:17.540
only going to get updates
a few times an hour.

00:37:17.540 --> 00:37:20.390
But you can get more
data points, as long

00:37:20.390 --> 00:37:22.460
as you're prepared to give up--

00:37:22.460 --> 00:37:24.980
the trade off is with latency.

00:37:24.980 --> 00:37:27.260
So here, you look
at this code map.

00:37:27.260 --> 00:37:30.740
So you create a
location request.

00:37:30.740 --> 00:37:32.570
You set its interval
to be 10 minutes.

00:37:32.570 --> 00:37:36.080
So you say, give me location
updates every 10 minutes.

00:37:36.080 --> 00:37:40.610
And then you say, but deliver
them no later than 30 minutes.

00:37:40.610 --> 00:37:43.970
So in a normal situation,
what will happen is,

00:37:43.970 --> 00:37:47.810
you will get three location
data points every 30 minutes

00:37:47.810 --> 00:37:49.280
in this kind of a case.

00:37:49.280 --> 00:37:52.700
If you didn't set
the max wait time,

00:37:52.700 --> 00:37:54.140
you would not get batching.

00:37:54.140 --> 00:37:58.180
And therefore, you would
miss out on data points.

00:37:58.180 --> 00:38:00.970
Another very, very
important location strategy

00:38:00.970 --> 00:38:05.300
in the age of O is to get
your location passively.

00:38:05.300 --> 00:38:07.750
So what are we
talking about here?

00:38:07.750 --> 00:38:10.840
Basically, location is
computed on a device basis,

00:38:10.840 --> 00:38:13.340
not just on an app basis.

00:38:13.340 --> 00:38:16.360
So when your app is
in the background,

00:38:16.360 --> 00:38:20.960
and therefore getting fairly
infrequent location updates,

00:38:20.960 --> 00:38:23.140
another app may be
in the foreground.

00:38:23.140 --> 00:38:24.490
It may be a mapping app.

00:38:24.490 --> 00:38:27.310
It may be some other app that
gets location updates quite

00:38:27.310 --> 00:38:29.530
a lot.

00:38:29.530 --> 00:38:31.750
Location services,
free of charge,

00:38:31.750 --> 00:38:33.820
will make that stuff
available to you,

00:38:33.820 --> 00:38:37.090
the data points available to
you and to any other app that's

00:38:37.090 --> 00:38:39.190
in the background
and wants that data.

00:38:39.190 --> 00:38:43.300
So this kind of opportunistic
location gathering I think

00:38:43.300 --> 00:38:45.520
is extremely good.

00:38:45.520 --> 00:38:47.210
We believe it's under-utilized.

00:38:47.210 --> 00:38:49.630
And we would like developers
to use it much more.

00:38:49.630 --> 00:38:51.680
So here's an example
how you can do that.

00:38:51.680 --> 00:38:54.730
Again, you create
a location request.

00:38:54.730 --> 00:38:57.640
You set the interval
to 10 minutes.

00:38:57.640 --> 00:39:02.030
You set the max wait time
for batching to 30 minutes.

00:39:02.030 --> 00:39:04.690
But then you set the
fastest interval to,

00:39:04.690 --> 00:39:09.300
let's say, two minutes, meaning,
if I'm in the background

00:39:09.300 --> 00:39:11.350
and anybody else is
consuming location

00:39:11.350 --> 00:39:15.100
data, every couple of minutes,
let me know about that data.

00:39:15.100 --> 00:39:19.112
And given the sheer number
of apps that use location,

00:39:19.112 --> 00:39:20.695
there's a pretty
good chance that when

00:39:20.695 --> 00:39:23.410
the user is using their
phone for something else,

00:39:23.410 --> 00:39:25.120
they will be gathering
location data.

00:39:25.120 --> 00:39:26.536
And then you can
have it for free.

00:39:29.170 --> 00:39:31.464
So that's a very
important strategy.

00:39:31.464 --> 00:39:32.880
I would urge all
of you to use it.

00:39:35.710 --> 00:39:40.777
While you're doing all this,
because of these changes in O,

00:39:40.777 --> 00:39:42.610
we're putting developers
in a position where

00:39:42.610 --> 00:39:44.401
they kind of have to
rethink their location

00:39:44.401 --> 00:39:46.199
strategies from scratch, right?

00:39:46.199 --> 00:39:47.740
If you're going to
do that, you might

00:39:47.740 --> 00:39:51.670
as we'll rethink them
for pre-O apps also.

00:39:51.670 --> 00:39:55.090
If you're running an N app,
or an M app, or an L app,

00:39:55.090 --> 00:39:58.030
that too could use from
the same principles

00:39:58.030 --> 00:40:00.310
that we are putting
forward in O and become

00:40:00.310 --> 00:40:01.750
more battery-efficient.

00:40:01.750 --> 00:40:03.490
So why wait?

00:40:03.490 --> 00:40:05.980
You can start making
things better now.

00:40:05.980 --> 00:40:12.010
So fundamentally, location is
expensive in one of three ways,

00:40:12.010 --> 00:40:15.940
related to frequency,
latency or accuracy.

00:40:15.940 --> 00:40:20.810
So O is saying to us,
on the frequency axis

00:40:20.810 --> 00:40:23.170
it's saying that, when
you're in the background,

00:40:23.170 --> 00:40:24.790
you need to not be so frequent.

00:40:24.790 --> 00:40:29.170
You can implement that now for
your N apps, for your M apps.

00:40:29.170 --> 00:40:35.350
Again, latency, sometimes you
want the real-time experience.

00:40:35.350 --> 00:40:38.680
But sometimes it's actually
OK to wait a few seconds

00:40:38.680 --> 00:40:41.890
before you get the location data
that has been computed for you.

00:40:41.890 --> 00:40:44.000
So use batching, like
we just talked about.

00:40:44.000 --> 00:40:46.290
You can do that now.

00:40:46.290 --> 00:40:49.030
And if you're using
a geofence, you

00:40:49.030 --> 00:40:51.320
can use a responsiveness time.

00:40:51.320 --> 00:40:54.020
And the more you give it, the
better your battery performance

00:40:54.020 --> 00:40:54.520
will be.

00:40:54.520 --> 00:40:58.660
You can do all these
things now for your apps.

00:40:58.660 --> 00:41:01.090
And when you're at it,
I mean, O isn't really

00:41:01.090 --> 00:41:03.976
dealing with accuracy that much.

00:41:03.976 --> 00:41:06.350
If you're rethinking everything
with regards to location,

00:41:06.350 --> 00:41:10.030
you might as well also say,
do I really need high accuracy

00:41:10.030 --> 00:41:12.040
all the time?

00:41:12.040 --> 00:41:16.046
Maybe I can use a balance
power accuracy, maybe no power.

00:41:16.046 --> 00:41:17.170
There are a lot of options.

00:41:17.170 --> 00:41:19.180
You can read our
documentation on this.

00:41:19.180 --> 00:41:22.000
Do I need the best,
greatest, most expensive

00:41:22.000 --> 00:41:24.220
location updates all the time?

00:41:24.220 --> 00:41:24.970
Probably not.

00:41:28.000 --> 00:41:31.040
And finally,
foreground services.

00:41:31.040 --> 00:41:34.940
You can go right ahead
and just completely

00:41:34.940 --> 00:41:38.030
bypass all these
location limits in O

00:41:38.030 --> 00:41:40.060
by running a foreground service.

00:41:40.060 --> 00:41:42.200
But you just have to make
sure the user will really

00:41:42.200 --> 00:41:43.820
approve of that service.

00:41:43.820 --> 00:41:45.950
Otherwise, they will get
annoyed with your app.

00:41:45.950 --> 00:41:48.050
And they will
probably uninstall it.

00:41:48.050 --> 00:41:50.480
Don't want that.

00:41:50.480 --> 00:41:54.480
That's basically
it-- a lot of stuff.

00:41:54.480 --> 00:41:55.340
I'm around.

00:41:55.340 --> 00:41:58.910
If you have apps that you think
are going to be now struggling

00:41:58.910 --> 00:42:01.470
with some of these O limits,
please come and talk to me.

00:42:01.470 --> 00:42:04.690
I'd love to hear your story.

00:42:04.690 --> 00:42:07.900
And happy coding.

00:42:07.900 --> 00:42:10.000
Thank you.

00:42:10.000 --> 00:42:12.750
[MUSIC PLAYING]

