WEBVTT
Kind: captions
Language: en

00:00:08.850 --> 00:00:10.360
RAY CROMWELL: Good afternoon.

00:00:10.360 --> 00:00:12.990
How you guys doing?

00:00:12.990 --> 00:00:15.070
I'm looking around the room and
I'm seeing a lot of people

00:00:15.070 --> 00:00:18.490
who I think are either
passionate about GWT or Dart,

00:00:18.490 --> 00:00:21.480
because you could have been
downstairs getting your Nexus

00:00:21.480 --> 00:00:24.260
7, your Galaxy Nexus, and
your Nexus Q, but

00:00:24.260 --> 00:00:25.760
you're here in my session.

00:00:25.760 --> 00:00:28.570
So thanks for coming.

00:00:28.570 --> 00:00:31.110
This session is titled
"Migrating Code from GWT to

00:00:31.110 --> 00:00:34.700
Dart." And if you
might notice--

00:00:34.700 --> 00:00:36.010
I'm tech lead for GWT.

00:00:36.010 --> 00:00:37.710
My name is Ray Cromwell.

00:00:37.710 --> 00:00:39.670
So the first thing you might be
asking-- and I get this a

00:00:39.670 --> 00:00:42.240
lot-- before the session even
starts, is why Dart?

00:00:42.240 --> 00:00:44.360
Why am I even giving a Dart
session in the first place?

00:00:44.360 --> 00:00:46.290
I'm tech lead on GWT.

00:00:46.290 --> 00:00:48.720
Well first of all, actually,
I think Dart's

00:00:48.720 --> 00:00:49.770
a really cool language.

00:00:49.770 --> 00:00:53.030
And I'm a compiler geek so I
tend to like languages and

00:00:53.030 --> 00:00:54.240
language-oriented stuff.

00:00:54.240 --> 00:00:58.100
So I volunteered to give this
session, because to me,

00:00:58.100 --> 00:01:00.710
learning programming languages
is not about discussing which

00:01:00.710 --> 00:01:05.239
language is best, whether Dart
is better than JavaScript or

00:01:05.239 --> 00:01:06.850
better than Java and so on.

00:01:06.850 --> 00:01:10.580
Because every language that you
encounter has things that

00:01:10.580 --> 00:01:12.680
are good about them and
things that people

00:01:12.680 --> 00:01:14.190
will complain about.

00:01:14.190 --> 00:01:17.230
And so for each type of
application, there's always

00:01:17.230 --> 00:01:21.760
sort of a sweet spot, and Dart
is no exception to that.

00:01:21.760 --> 00:01:24.660
But it is a very cool language,
and it takes some of

00:01:24.660 --> 00:01:28.740
the best features from
JavaScript and Java and

00:01:28.740 --> 00:01:29.680
combines them into one.

00:01:29.680 --> 00:01:31.480
And I'll get to that later.

00:01:31.480 --> 00:01:33.050
I also think learning
new languages is

00:01:33.050 --> 00:01:33.750
good for your brain.

00:01:33.750 --> 00:01:36.580
Just like bilingualism and
spoken languages, if you learn

00:01:36.580 --> 00:01:37.990
multiple programming languages,
it's going to be

00:01:37.990 --> 00:01:39.070
good for your career.

00:01:39.070 --> 00:01:40.930
It's going to make you think
in different ways.

00:01:40.930 --> 00:01:43.080
And hopefully exposure to Dart
will make you think about

00:01:43.080 --> 00:01:45.860
designing web applications in
different ways, perhaps ways

00:01:45.860 --> 00:01:52.140
that are more structured, if
you're not a Java programmer.

00:01:52.140 --> 00:01:54.650
And finally, I don't really
think that you can evaluate a

00:01:54.650 --> 00:01:57.200
language unless you've
developed using it.

00:01:57.200 --> 00:02:00.740
A lot of times, you're online
and you'll see people having

00:02:00.740 --> 00:02:02.080
wars over programming
languages.

00:02:02.080 --> 00:02:04.310
My language is better
than yours.

00:02:04.310 --> 00:02:06.780
They'll microcriticize various
parts of the spec.

00:02:06.780 --> 00:02:10.360
But really, you'll never know
what's cool about a language

00:02:10.360 --> 00:02:13.250
or what sucks about it unless
you actually develop with it.

00:02:13.250 --> 00:02:17.950
And so this presentation is
designed to help you utilize

00:02:17.950 --> 00:02:22.390
what you already know, which is
hopefully Java and GWT, and

00:02:22.390 --> 00:02:26.670
get you up to speed on Dart as
fast as possible so you can

00:02:26.670 --> 00:02:28.730
try that experiment
out for yourself.

00:02:28.730 --> 00:02:31.100
And then you can make the
decision whether or not you

00:02:31.100 --> 00:02:33.760
think Dart is a good language
for you or GWT is a good

00:02:33.760 --> 00:02:35.615
language for you, or hand-coded
JavaScript's a good

00:02:35.615 --> 00:02:37.210
language for you.

00:02:37.210 --> 00:02:40.860
And so I want to try to map
concepts that you already know

00:02:40.860 --> 00:02:44.690
from Java and GWT into Dart so
that you'll understand things

00:02:44.690 --> 00:02:45.920
faster and quicker.

00:02:45.920 --> 00:02:49.170
I want to try to teach you some
Dart idioms and to get

00:02:49.170 --> 00:02:52.590
your feet wet in terms of
porting some existing GWT

00:02:52.590 --> 00:02:56.250
application constructs
into Dart.

00:02:56.250 --> 00:02:58.320
So what is Dart?

00:02:58.320 --> 00:03:01.260
We say it's a structured
language for web applications.

00:03:01.260 --> 00:03:04.510
But it's more than that, because
on the surface, it has

00:03:04.510 --> 00:03:06.380
the appearance of
being Java-like.

00:03:06.380 --> 00:03:09.860
But underneath it's a
dynamically typed language.

00:03:09.860 --> 00:03:10.820
So what does that mean?

00:03:10.820 --> 00:03:12.900
If you think of JavaScript--

00:03:12.900 --> 00:03:16.470
it means that you can refer to
things on an object, fields or

00:03:16.470 --> 00:03:18.720
invoke methods and so on,
regardless of what the

00:03:18.720 --> 00:03:19.900
declared type is.

00:03:19.900 --> 00:03:23.200
You might say it's a customer
object, but at run time you

00:03:23.200 --> 00:03:25.960
can still refer to that object
as if it was a totally

00:03:25.960 --> 00:03:26.490
different type.

00:03:26.490 --> 00:03:29.800
The type doesn't restrict
you from shooting

00:03:29.800 --> 00:03:31.860
yourself in the foot.

00:03:31.860 --> 00:03:35.620
But Dart goes a little bit
further, because although you

00:03:35.620 --> 00:03:39.860
can do that, you can also run,
optionally, your application

00:03:39.860 --> 00:03:40.680
in checked mode.

00:03:40.680 --> 00:03:43.260
And in checked mode, the
types do have meaning.

00:03:43.260 --> 00:03:45.250
And you will get runtime errors
if you, for example,

00:03:45.250 --> 00:03:48.580
try to access something on an
object or a class that wasn't

00:03:48.580 --> 00:03:50.030
there in that type.

00:03:50.030 --> 00:03:52.330
But in general, when you're
programing in Dart, unlike in

00:03:52.330 --> 00:03:55.740
Java, you should treat the
types like annotation or

00:03:55.740 --> 00:03:59.190
documentation for both people
reading the code and for

00:03:59.190 --> 00:04:01.890
machines that are processing
it, like tools.

00:04:01.890 --> 00:04:03.450
Dart's also a class-based

00:04:03.450 --> 00:04:04.790
object-oriented programming language.

00:04:04.790 --> 00:04:06.520
It's not a prototype-based
language.

00:04:06.520 --> 00:04:07.820
It's not functional language.

00:04:07.820 --> 00:04:11.320
It's class-based
object-oriented.

00:04:11.320 --> 00:04:14.860
But because it has a type
system and it's

00:04:14.860 --> 00:04:16.850
OO, it's very toolable.

00:04:16.850 --> 00:04:18.550
So one of the things you'll be
able to do is you'll be able

00:04:18.550 --> 00:04:21.190
to go out and get things like
the Dart Editor, which is

00:04:21.190 --> 00:04:24.670
based on the Eclipse framework,
or the latest

00:04:24.670 --> 00:04:27.730
IntelliJ plugin, and you'll
actually be able to get all of

00:04:27.730 --> 00:04:30.620
this nice stuff that you
like in Java in Dart.

00:04:30.620 --> 00:04:34.140
Command method completion, field
completion, refactoring,

00:04:34.140 --> 00:04:35.070
go to declaration--

00:04:35.070 --> 00:04:35.810
all those things are there.

00:04:35.810 --> 00:04:38.950
Things that are actually
typically hard to do in

00:04:38.950 --> 00:04:43.010
dynamic languages with
IDEs, you can do

00:04:43.010 --> 00:04:44.980
quite easily with Dart.

00:04:44.980 --> 00:04:47.560
And Dart has the option of
running either natively in the

00:04:47.560 --> 00:04:51.520
Dart VM or in any other browser
by using a Dart-to-JS

00:04:51.520 --> 00:04:55.590
compiler, which compiles
the JS just like GWT.

00:04:55.590 --> 00:04:57.520
So let's dive right in.

00:04:57.520 --> 00:04:59.740
Rather than teaching the
language spec, if you haven't

00:04:59.740 --> 00:05:02.170
seen any of the other sessions,
I'm just going to

00:05:02.170 --> 00:05:06.930
start off with Java and try to
transmorgify it into Dart.

00:05:06.930 --> 00:05:08.690
Let's see how that works out.

00:05:08.690 --> 00:05:11.350
So the first thing that's
different between Dart and

00:05:11.350 --> 00:05:15.250
Java is basically, there's no
access modifier keywords.

00:05:15.250 --> 00:05:18.580
So you can basically just remove
the private and public

00:05:18.580 --> 00:05:21.640
declarations and the code
will continue to work.

00:05:21.640 --> 00:05:23.550
The next thing is that
types are optional.

00:05:23.550 --> 00:05:27.490
So it's not-- we don't always
recommend removing types.

00:05:27.490 --> 00:05:30.180
I think well-written library
code should have the types

00:05:30.180 --> 00:05:31.860
there so when other people are
reading your code, they'll

00:05:31.860 --> 00:05:33.470
actually kind of know
the intent.

00:05:33.470 --> 00:05:35.640
But just to show you, we
can remove that string

00:05:35.640 --> 00:05:39.220
declaration, that Boolean field
declaration, and we end

00:05:39.220 --> 00:05:41.830
up with that.

00:05:41.830 --> 00:05:43.700
The other thing is that--

00:05:43.700 --> 00:05:44.880
and I actually like
this feature.

00:05:44.880 --> 00:05:47.400
This is one of my favorite
features of Dart.

00:05:47.400 --> 00:05:50.710
In Java, you write the same code
over and over and over

00:05:50.710 --> 00:05:52.540
again for initializing
constructors.

00:05:52.540 --> 00:05:53.800
You have a constructor.

00:05:53.800 --> 00:05:55.220
It takes three parameters.

00:05:55.220 --> 00:05:56.610
What is the first thing you
do in the body of the

00:05:56.610 --> 00:05:57.260
constructor?

00:05:57.260 --> 00:06:00.940
This dot x equals y, this dot a
equals b, and so on, right?

00:06:00.940 --> 00:06:02.470
The same thing--

00:06:02.470 --> 00:06:05.640
and a lot of languages have
this problem too, but Dart

00:06:05.640 --> 00:06:08.460
actually has a little bit of
syntactic sugar for this.

00:06:08.460 --> 00:06:12.490
So if you want to auto-assign
a parameter to a field, then

00:06:12.490 --> 00:06:15.660
you refer to the field in the
constructor parameter

00:06:15.660 --> 00:06:18.160
declaration with a
this qualifier.

00:06:18.160 --> 00:06:22.310
So here I'm saying this.name
and that's it, in the

00:06:22.310 --> 00:06:23.630
constructor parameter list.

00:06:23.630 --> 00:06:28.310
And basically the Dart VM or the
Dart compiler knows that

00:06:28.310 --> 00:06:32.470
that refers to the field name,
which has a string type, and

00:06:32.470 --> 00:06:35.820
it's going to autogenerate
this.name equals name for you.

00:06:40.060 --> 00:06:46.290
In Java, if you have a block of
code in an if statement or

00:06:46.290 --> 00:06:48.690
a for statement that only has
one line, you now that you can

00:06:48.690 --> 00:06:51.360
eliminate the curly braces
and just put a semicolon.

00:06:51.360 --> 00:06:54.810
In Dart, even for method
declarations, you can

00:06:54.810 --> 00:06:56.630
eliminate the curly braces.

00:06:56.630 --> 00:07:01.360
So here is a method that only
has one line of code in it.

00:07:01.360 --> 00:07:04.540
And so the cat constructor just
equals greater-than and

00:07:04.540 --> 00:07:06.050
then an expression to
the right of it.

00:07:09.410 --> 00:07:11.030
So Dart doesn't have packages.

00:07:11.030 --> 00:07:14.450
It has something that's not
exactly like a package.

00:07:14.450 --> 00:07:15.430
It's called a library.

00:07:15.430 --> 00:07:18.080
And so here we just delete
package com.foo and we just

00:07:18.080 --> 00:07:21.110
use #library('foo'), which is
basically saying the code

00:07:21.110 --> 00:07:22.370
below it is part of
that library.

00:07:25.560 --> 00:07:29.420
Now I said that Dart doesn't
have access qualifiers, like

00:07:29.420 --> 00:07:30.560
public and private.

00:07:30.560 --> 00:07:34.860
But you can hide things
within a library.

00:07:34.860 --> 00:07:37.350
So you can make it so that no
one outside of the library foo

00:07:37.350 --> 00:07:38.600
can see a particular variable.

00:07:38.600 --> 00:07:42.400
And the way you do that is by
putting a leading underscore

00:07:42.400 --> 00:07:43.260
on the field name.

00:07:43.260 --> 00:07:48.390
So in this example, _name and
_iCanHazMeme are only visible

00:07:48.390 --> 00:07:53.740
to classes within
the library foo.

00:07:53.740 --> 00:07:55.750
So Dart doesn't have an import
statement like Java, but it

00:07:55.750 --> 00:07:57.050
does have #import.

00:07:57.050 --> 00:08:00.730
And with #import, basically,
you import libraries.

00:08:00.730 --> 00:08:02.940
And this is the syntax for it.

00:08:02.940 --> 00:08:04.030
So we're getting there.

00:08:04.030 --> 00:08:06.250
We're almost fully converted.

00:08:06.250 --> 00:08:10.040
So Dart has final fields,
but they're initialized

00:08:10.040 --> 00:08:11.210
differently than Java.

00:08:11.210 --> 00:08:13.960
They're using the C++-style
initializer list.

00:08:13.960 --> 00:08:16.520
So if you have some final
fields, they have to be

00:08:16.520 --> 00:08:18.560
assigned during construction.

00:08:18.560 --> 00:08:20.440
And so the way you do it is
you put a colon after the

00:08:20.440 --> 00:08:23.250
constructor and then a
comma-separated list of

00:08:23.250 --> 00:08:24.500
assignments.

00:08:27.730 --> 00:08:29.230
Dart also has static fields.

00:08:29.230 --> 00:08:31.680
So you can see in this example,
UBER_CAT, we want it

00:08:31.680 --> 00:08:35.380
be a static, final, immutable
Cat, right,

00:08:35.380 --> 00:08:36.630
that everyone sees.

00:08:39.640 --> 00:08:43.210
And you can initialize them to
be immutable or singleton--

00:08:43.210 --> 00:08:45.100
think of string interning
in Java--

00:08:45.100 --> 00:08:50.660
by using something Dart has
called a const constructor.

00:08:50.660 --> 00:08:53.310
So if you put the const keyword
in front of the Cat

00:08:53.310 --> 00:08:56.220
constructor, essentially what
this is saying is that there's

00:08:56.220 --> 00:09:02.510
only ever one instance of that
Cat with that parameter name.

00:09:02.510 --> 00:09:09.070
So if you construct a Cat and
the name is Mr. Tibbles, then

00:09:09.070 --> 00:09:10.840
there's only one instance
of Mr. Tibbles.

00:09:10.840 --> 00:09:13.340
And the next time you try to
allocate one, you'll still get

00:09:13.340 --> 00:09:14.300
the same instance.

00:09:14.300 --> 00:09:16.120
That means you can
use a reference

00:09:16.120 --> 00:09:19.690
comparison, for example.

00:09:19.690 --> 00:09:22.090
Another biggie, and this'll
probably be the biggest shock

00:09:22.090 --> 00:09:24.930
if you're coming from Java or
GWT, is that there's no

00:09:24.930 --> 00:09:27.340
function overloading in Dart.

00:09:27.340 --> 00:09:30.220
And so here's a typical
example of Java--

00:09:30.220 --> 00:09:34.320
the Money class, where it's
storing things as a

00:09:34.320 --> 00:09:35.810
fixed-point integer.

00:09:35.810 --> 00:09:38.560
Let's say multiplied by 100,
so it's in pennies.

00:09:38.560 --> 00:09:40.410
And so someone might have
three constructors.

00:09:40.410 --> 00:09:42.930
One that takes an int, one that
takes a string, and one

00:09:42.930 --> 00:09:44.390
that takes a double.

00:09:44.390 --> 00:09:45.900
And they might have some
overloaded methods.

00:09:45.900 --> 00:09:48.170
So down at the bottom we
have two add methods.

00:09:48.170 --> 00:09:51.870
One takes another Money class,
and one takes another Money

00:09:51.870 --> 00:09:57.910
class but optionally charges tax
before it adds the money.

00:09:57.910 --> 00:10:01.390
So Dart works around this
problem by introducing named

00:10:01.390 --> 00:10:02.440
constructors.

00:10:02.440 --> 00:10:05.120
So in Dart, your constructor
does not always have to have

00:10:05.120 --> 00:10:07.360
the same name as your
class itself.

00:10:07.360 --> 00:10:09.460
In Java, your constructor
for the Cat class is

00:10:09.460 --> 00:10:10.830
always called Cat.

00:10:10.830 --> 00:10:13.250
In Dart, you have a
constructor called

00:10:13.250 --> 00:10:16.030
Money.fromDouble and
Money.fromString.

00:10:16.030 --> 00:10:20.540
So the actual qualified
constructor name is itself an

00:10:20.540 --> 00:10:21.170
constructor.

00:10:21.170 --> 00:10:24.120
So someone, if they wanted to
create Money from a double,

00:10:24.120 --> 00:10:26.180
they'd say new Money.fromDouble

00:10:26.180 --> 00:10:27.430
and then the value.

00:10:29.680 --> 00:10:33.390
Likewise, for the overloaded
method case, what we can do is

00:10:33.390 --> 00:10:35.950
we can collapse those two
methods into a single method

00:10:35.950 --> 00:10:38.090
because Dart has optional
parameters.

00:10:38.090 --> 00:10:40.430
So all you do to make a
parameter optional is you

00:10:40.430 --> 00:10:42.040
enclose it in square brackets.

00:10:42.040 --> 00:10:46.720
So now the original Money
class, which had two

00:10:46.720 --> 00:10:49.820
parameters, and then another
specialized version, which had

00:10:49.820 --> 00:10:52.090
the emitted parameter is
collapsed into a single method

00:10:52.090 --> 00:10:53.340
which has the optional
parameter.

00:10:56.870 --> 00:10:59.470
And you could specify default
values for the parameters.

00:10:59.470 --> 00:11:02.180
So typically in Java, if you
have this case where you have

00:11:02.180 --> 00:11:04.672
two overloads, and one of them
is just an overload because

00:11:04.672 --> 00:11:07.550
you want to allow the person to
emit an optional parameter,

00:11:07.550 --> 00:11:11.130
you'd typically have one method
call the other and pass

00:11:11.130 --> 00:11:12.930
in the default value.

00:11:12.930 --> 00:11:14.790
Here you can just specify
the value.

00:11:14.790 --> 00:11:16.670
So I say in the default,
if you don't specify

00:11:16.670 --> 00:11:19.132
chargeTax is true.

00:11:19.132 --> 00:11:22.580
The government's gonna
love that.

00:11:22.580 --> 00:11:25.310
As a bonus, all optional
parameters are named

00:11:25.310 --> 00:11:25.870
parameters.

00:11:25.870 --> 00:11:28.190
So if you have a list of like
five optional parameters, and

00:11:28.190 --> 00:11:31.640
maybe you don't memorize the API
but you happen to know the

00:11:31.640 --> 00:11:34.860
names of the parameters, you
can specify the optional

00:11:34.860 --> 00:11:37.770
parameter by putting a colon
in front of its name.

00:11:37.770 --> 00:11:39.780
So I'm passing the chargeTax
parameter by

00:11:39.780 --> 00:11:41.030
saying chargeTax: false.

00:11:45.420 --> 00:11:47.490
Here's an interesting thing.

00:11:47.490 --> 00:11:50.790
A lot of people complain about
Java, of people creating tons

00:11:50.790 --> 00:11:53.590
of factory service locator,
factory factory classes, and

00:11:53.590 --> 00:11:54.600
things like that.

00:11:54.600 --> 00:11:57.410
And factories and dependency
injection are very, very

00:11:57.410 --> 00:11:58.960
common in Java.

00:11:58.960 --> 00:12:01.300
And I think Dart recognized
this and said, we should

00:12:01.300 --> 00:12:04.530
provide a solution for
this that doesn't

00:12:04.530 --> 00:12:05.690
add a lot of bloat.

00:12:05.690 --> 00:12:08.380
And so what you can do is you
can designate a constructor as

00:12:08.380 --> 00:12:10.070
a factory constructor.

00:12:10.070 --> 00:12:13.640
So here we're saying the Money
constructor that takes an

00:12:13.640 --> 00:12:16.690
amount is a factory
constructor.

00:12:16.690 --> 00:12:19.430
And what it does is it says,
if the amount is equal to

00:12:19.430 --> 00:12:22.990
zero, then return this static
final interned instance of

00:12:22.990 --> 00:12:25.930
zero, else return a new
Money object that's

00:12:25.930 --> 00:12:27.490
constructed on the fly.

00:12:27.490 --> 00:12:29.650
And typically you might do this
if you want to use zero

00:12:29.650 --> 00:12:33.100
as a special value to use
reference equality.

00:12:33.100 --> 00:12:36.060
There's only ever one Money
object representing zero

00:12:36.060 --> 00:12:40.220
money, but other ones actually
have differing values.

00:12:40.220 --> 00:12:42.720
And so what happens is, when
you new the Money object it

00:12:42.720 --> 00:12:45.660
actually calls this method, and
the method actually can

00:12:45.660 --> 00:12:48.120
return a different object,
unlike a typical Java

00:12:48.120 --> 00:12:48.470
constructor.

00:12:48.470 --> 00:12:51.130
You can't return something from
the constructor that's

00:12:51.130 --> 00:12:52.460
different than the
object itself.

00:12:55.530 --> 00:12:57.760
And Dart also has operator
overloading.

00:12:57.760 --> 00:13:00.380
So we can make that Money class
a little easier to use

00:13:00.380 --> 00:13:03.200
by overwriting operator+
on it.

00:13:03.200 --> 00:13:06.260
And now you can just say
money+money instead of

00:13:06.260 --> 00:13:07.510
money.add(money).

00:13:11.950 --> 00:13:15.350
And finally, Dart has
getters and setters.

00:13:15.350 --> 00:13:18.170
So this is a typical
POJO, Plain Old Job

00:13:18.170 --> 00:13:20.650
Object bean, in Java.

00:13:20.650 --> 00:13:23.120
And so we have a field called
Amount, so naturally we have

00:13:23.120 --> 00:13:25.690
to write an int get amount that
returns _amount, and a

00:13:25.690 --> 00:13:27.600
setter for it.

00:13:27.600 --> 00:13:30.010
And then on the bottom, you
see method calls from it.

00:13:30.010 --> 00:13:35.360
Whereas in Dart, what you can
do is you can put a get

00:13:35.360 --> 00:13:38.030
keyword in front of the function
name and a set

00:13:38.030 --> 00:13:39.770
keyword in front
of the setter.

00:13:39.770 --> 00:13:42.440
And then what happens is you can
reference the object as if

00:13:42.440 --> 00:13:45.070
those were field references,
not method calls.

00:13:45.070 --> 00:13:48.380
And Dart will actually invoke
the getter methods for you.

00:13:48.380 --> 00:13:51.450
So this is kind of a less
boilerplate-y way of setting

00:13:51.450 --> 00:13:57.360
up fields with getters and
setters or properties.

00:13:57.360 --> 00:14:03.520
Let's talk about the type
system differences.

00:14:03.520 --> 00:14:05.620
So there's really only five
built-in types you need to

00:14:05.620 --> 00:14:06.660
worry about.

00:14:06.660 --> 00:14:08.270
There are two numeric types.

00:14:08.270 --> 00:14:10.320
There's int and double.

00:14:10.320 --> 00:14:11.830
And yes, you're reading
that right.

00:14:11.830 --> 00:14:14.710
The integer is infinite
precision, so you never have

00:14:14.710 --> 00:14:18.120
to worry about overflow
in your code.

00:14:18.120 --> 00:14:20.406
If you want to compute--

00:14:20.406 --> 00:14:23.430
boy, don't try to compute
Google because

00:14:23.430 --> 00:14:24.050
you'll run out of memory.

00:14:24.050 --> 00:14:27.080
But if you want to compute a
very large number, you can use

00:14:27.080 --> 00:14:29.090
integers to do it.

00:14:29.090 --> 00:14:32.760
Doubles are 64-bit IEEE-754
goodness.

00:14:32.760 --> 00:14:36.260
Typically you might have a
game or a lot of math or

00:14:36.260 --> 00:14:38.530
physics code, and they're
great to use for that.

00:14:38.530 --> 00:14:39.500
Dart does have a String.

00:14:39.500 --> 00:14:41.200
Class It has a bool type--

00:14:41.200 --> 00:14:42.830
not Boolean, but bool.

00:14:42.830 --> 00:14:46.200
And it has two fundamental
collection types that

00:14:46.200 --> 00:14:49.210
everybody uses, hopefully,
which is List and Map.

00:14:49.210 --> 00:14:52.960
And like every other language
except for Java, they have

00:14:52.960 --> 00:14:54.000
first-class support.

00:14:54.000 --> 00:14:59.060
So there are literals
for maps and lists

00:14:59.060 --> 00:15:00.050
built into the language.

00:15:00.050 --> 00:15:02.500
So you define a List literal
with square brackets, and you

00:15:02.500 --> 00:15:06.160
define a map with curly braces,
much like JSON and

00:15:06.160 --> 00:15:08.540
JavaScript.

00:15:08.540 --> 00:15:10.490
There's some big differences
with strings

00:15:10.490 --> 00:15:12.250
between Java and Dart.

00:15:12.250 --> 00:15:17.580
String support interpolation
in Dart-- so you can put a

00:15:17.580 --> 00:15:21.470
dollar sign and then a variable
name inside of any

00:15:21.470 --> 00:15:25.580
string, and Dart will substitute
that with the

00:15:25.580 --> 00:15:29.210
variable of the same name that's
in the same scope.

00:15:29.210 --> 00:15:30.590
But you can go a little
bit further, too.

00:15:30.590 --> 00:15:31.900
You could put a curly brace.

00:15:31.900 --> 00:15:36.320
And for example, you can invoke
a method call on that.

00:15:36.320 --> 00:15:38.640
If this looks familiar to you,
it looks very much like the

00:15:38.640 --> 00:15:41.160
expression language that's often
in many Java frameworks,

00:15:41.160 --> 00:15:45.810
like JSP and JSS and things
like that, or like Apache

00:15:45.810 --> 00:15:48.210
property substitution.

00:15:48.210 --> 00:15:52.130
One of the features I love most,
actually, is heredocs,

00:15:52.130 --> 00:15:54.850
and Dart was very good
to add that.

00:15:54.850 --> 00:15:57.700
And it's basically multi-line
strings that you can include

00:15:57.700 --> 00:16:00.260
verbatim in the code.

00:16:00.260 --> 00:16:02.430
And that's really, really useful
if you want to bake in

00:16:02.430 --> 00:16:05.730
some HTML or some CSS into your
app, and you don't have

00:16:05.730 --> 00:16:09.040
to worry about going in and
escaping every new line and

00:16:09.040 --> 00:16:09.860
all the other kind of stuff.

00:16:09.860 --> 00:16:13.810
You can kind of structure
DSL-specific syntaxes right

00:16:13.810 --> 00:16:15.350
into your Dart source code,
just by putting

00:16:15.350 --> 00:16:17.370
in a multiline string.

00:16:17.370 --> 00:16:20.170
And if you don't want
interpolation, because maybe

00:16:20.170 --> 00:16:22.430
you want literal dollar signs,
just put an @ in front of the

00:16:22.430 --> 00:16:24.050
string, and it turns it
off for that string.

00:16:26.610 --> 00:16:29.110
I don't want to say a
lot about generics.

00:16:29.110 --> 00:16:32.730
Dart does have generics, but
they are radically simplified

00:16:32.730 --> 00:16:34.590
generics, which is
a good thing.

00:16:34.590 --> 00:16:37.240
Because Java generics--

00:16:37.240 --> 00:16:39.900
I mean, if anybody's played
around in Scala, this sounds

00:16:39.900 --> 00:16:41.900
like somebody whining, but Java
generics are actually

00:16:41.900 --> 00:16:43.940
kind of complicated, and a lot
of people don't understand the

00:16:43.940 --> 00:16:47.120
difference between covariants,
invariants, contravariants,

00:16:47.120 --> 00:16:49.140
wild cards, and things
like that.

00:16:49.140 --> 00:16:51.420
And as a result, most people
don't even use those features.

00:16:51.420 --> 00:16:53.670
I mean, if you're Joshua Bloch,
you use them in the

00:16:53.670 --> 00:16:56.900
Java collections classes, but if
you go look at most regular

00:16:56.900 --> 00:16:59.040
Java programmers, they
hardly ever use most

00:16:59.040 --> 00:17:00.740
of these extra features.

00:17:00.740 --> 00:17:03.780
And so Dart basically said,
why add all this extra

00:17:03.780 --> 00:17:04.530
complexity?

00:17:04.530 --> 00:17:07.829
Most people would just use
Foo if T So Dart only has

00:17:07.829 --> 00:17:11.430
covariants for generics.

00:17:11.430 --> 00:17:13.819
But Dart does not use erasure.

00:17:13.819 --> 00:17:17.660
So generics in Dart are
actual reified.

00:17:17.660 --> 00:17:19.190
You can check the
runtime types.

00:17:19.190 --> 00:17:23.510
So a Foo or a list of int--
you can actually check

00:17:23.510 --> 00:17:25.250
it to see what it is.

00:17:25.250 --> 00:17:27.079
And if you try to say,
is this a foo of

00:17:27.079 --> 00:17:28.960
string, it will say false.

00:17:28.960 --> 00:17:31.920
That's not the case in Java,
where if you have a list of T,

00:17:31.920 --> 00:17:34.850
a list of anything, basically
it's only really a list, and

00:17:34.850 --> 00:17:38.020
you actually cannot check
what it is at runtime.

00:17:38.020 --> 00:17:39.530
But in general, I would
say, don't worry

00:17:39.530 --> 00:17:40.890
too much about this.

00:17:40.890 --> 00:17:44.700
Things just kind of work, and
you don't have to worry too

00:17:44.700 --> 00:17:46.090
much about it.

00:17:46.090 --> 00:17:48.710
Generics in Dart are simple and
they work out of the box.

00:17:48.710 --> 00:17:53.310
And don't get yourself worried
about what's being left out.

00:17:56.810 --> 00:17:58.920
The other-- and I want to say
the third favorite feature of

00:17:58.920 --> 00:18:03.080
mine is finally lexically
scoped closures.

00:18:03.080 --> 00:18:04.440
I wish Java had them.

00:18:04.440 --> 00:18:06.020
I wish Java 8 will have them.

00:18:06.020 --> 00:18:06.690
Hopefully they will.

00:18:06.690 --> 00:18:09.340
But yes.

00:18:09.340 --> 00:18:11.810
Bye-bye, anonymous classes,
and hello function types.

00:18:11.810 --> 00:18:14.630
So here is an example of
an apply function.

00:18:14.630 --> 00:18:16.760
It takes a list of integers and
applies the function to

00:18:16.760 --> 00:18:18.620
each thing in the list and
returns a new list.

00:18:18.620 --> 00:18:21.670
And so at the bottom I just
show a simple example.

00:18:21.670 --> 00:18:26.780
Apply an inline literal list of
1, 2, 3, 4, 5, a function

00:18:26.780 --> 00:18:29.280
which basically doubles
its input.

00:18:29.280 --> 00:18:35.840
So what you do to declare a
closure is you basically put

00:18:35.840 --> 00:18:39.135
the parameters in parentheses
with optional types, and then

00:18:39.135 --> 00:18:42.590
you put =&gt;, and then the
expression to be evaluated,

00:18:42.590 --> 00:18:43.270
the function body.

00:18:43.270 --> 00:18:45.280
You can use curly braces
there too if you want.

00:18:50.020 --> 00:18:51.990
And you can make things a
little bit more readable

00:18:51.990 --> 00:18:53.270
because Dart has typedefs.

00:18:53.270 --> 00:18:56.220
So often, these function
declarations, if they're

00:18:56.220 --> 00:18:58.440
really complicated and take a
lot of parameters-- maybe have

00:18:58.440 --> 00:19:00.550
a function which takes functions
to functions, and

00:19:00.550 --> 00:19:02.250
things like that--

00:19:02.250 --> 00:19:04.060
you want to break them down
into separate steps.

00:19:04.060 --> 00:19:05.700
And with typedefs,
you can do that.

00:19:05.700 --> 00:19:11.070
So here I'm basically saying
that there is a function that

00:19:11.070 --> 00:19:14.705
takes an int and returns an int,
and I'm going to give it

00:19:14.705 --> 00:19:16.660
the name Transformer.

00:19:16.660 --> 00:19:19.860
And then my apply function
now, rather than saying--

00:19:19.860 --> 00:19:24.850
if you look at the previous
slide, it's int f(int arg))

00:19:24.850 --> 00:19:26.630
Now this says Transformer bay.

00:19:29.370 --> 00:19:31.820
Maybe some of you get the
reference to that.

00:19:31.820 --> 00:19:33.750
And so then at the bottom, I
have another one where I say

00:19:33.750 --> 00:19:35.000
Transformer prime
= (x) =&gt; 2 * x.

00:19:38.140 --> 00:19:40.750
And so it looks a little
more readable.

00:19:40.750 --> 00:19:44.220
You can document the typedef
and things like that.

00:19:44.220 --> 00:19:49.025
OK so that kind of covers the
language syntax case.

00:19:49.025 --> 00:19:51.940
Now I'm going to cover just some
of the API differences.

00:19:51.940 --> 00:19:55.140
So Dart has two collection
classes, as I mentioned

00:19:55.140 --> 00:19:57.620
before, and they
are generified.

00:19:57.620 --> 00:19:59.930
That's List and Map.

00:19:59.930 --> 00:20:02.670
And so in Dart, you can create
them in two ways.

00:20:02.670 --> 00:20:06.670
You can new them, with the new
operator, or you can construct

00:20:06.670 --> 00:20:09.840
them inline with literals,
which a lot of people do.

00:20:09.840 --> 00:20:13.810
That's a very common
thing to do.

00:20:13.810 --> 00:20:15.970
And you don't actually have to
worry about the underlying

00:20:15.970 --> 00:20:16.900
concrete types.

00:20:16.900 --> 00:20:19.470
So Map and List will be abstract
classes and there

00:20:19.470 --> 00:20:21.370
might be multiple
implementations of Map and

00:20:21.370 --> 00:20:22.960
List, but Dart will
pick a default

00:20:22.960 --> 00:20:23.770
implementation for you.

00:20:23.770 --> 00:20:26.170
In Java, you have to think,
am I going to use HashMap?

00:20:26.170 --> 00:20:27.940
Am I going to use
LinkedHashMap?

00:20:27.940 --> 00:20:30.260
And things like that.

00:20:30.260 --> 00:20:31.110
And then iteration--

00:20:31.110 --> 00:20:32.410
you have multiple
choices, right?

00:20:32.410 --> 00:20:35.170
So you can use what's called
external iteration, where you

00:20:35.170 --> 00:20:37.900
basically have your own for
loop, you ask for the length

00:20:37.900 --> 00:20:40.530
of the list, and you iterate
over it and you index into it

00:20:40.530 --> 00:20:42.670
like an array, like List[i].

00:20:42.670 --> 00:20:45.470
No operator overloading to
access list members.

00:20:45.470 --> 00:20:48.760
You don't have to
say List.get(i).

00:20:48.760 --> 00:20:51.930
Or you could use the
For In operators.

00:20:51.930 --> 00:20:53.180
You could say for (value
in list) {doSomething}.

00:20:55.350 --> 00:20:59.900
Or you can use an internal
iterator, which is basically,

00:20:59.900 --> 00:21:02.970
you pass a closure to the
forEach method, and it will

00:21:02.970 --> 00:21:05.410
loop over the collection
internally and call your

00:21:05.410 --> 00:21:07.640
function for each member
of the list.

00:21:07.640 --> 00:21:10.580
And then there's equivalent
methods for Map.

00:21:10.580 --> 00:21:13.750
It's just that they take two
parameters for the forEach

00:21:13.750 --> 00:21:16.550
method, key and value, or you
have to get the set of keys

00:21:16.550 --> 00:21:20.110
and the set of values
to iterate over.

00:21:20.110 --> 00:21:20.320
All right.

00:21:20.320 --> 00:21:23.275
So now let's actually move on
to converting the actual GWT

00:21:23.275 --> 00:21:25.240
code over to Dart.

00:21:25.240 --> 00:21:28.690
And so let's first convert
a really simple example.

00:21:28.690 --> 00:21:30.600
Here's a "Hello World" in GWT.

00:21:30.600 --> 00:21:32.740
You have the onModuleLoad
function, and I'm going to

00:21:32.740 --> 00:21:35.000
call window.alert("Hello
World").

00:21:35.000 --> 00:21:38.430
What would this look
like in Dart?

00:21:38.430 --> 00:21:39.790
Really, really compact.

00:21:39.790 --> 00:21:43.140
So first thing is we import the
Dart HTML library so we

00:21:43.140 --> 00:21:46.700
can get the window function,
the alert function.

00:21:46.700 --> 00:21:50.410
Secondly, Dart's EntryPoint,
is the main function.

00:21:50.410 --> 00:21:51.580
So--

00:21:51.580 --> 00:21:53.280
whoops--

00:21:53.280 --> 00:21:53.910
what?

00:21:53.910 --> 00:21:56.230
There we go.

00:21:56.230 --> 00:21:58.860
Let me restart.

00:21:58.860 --> 00:22:02.590
I don't know why
that happened.

00:22:02.590 --> 00:22:03.840
Let's go back.

00:22:12.090 --> 00:22:13.580
I have a lot of slides.

00:22:13.580 --> 00:22:16.020
OK.

00:22:16.020 --> 00:22:17.610
There we go.

00:22:17.610 --> 00:22:18.400
This one.

00:22:18.400 --> 00:22:21.230
And so if you look at this, you
have to declare a class.

00:22:21.230 --> 00:22:22.100
You have to implement
EntryPoint.

00:22:22.100 --> 00:22:24.070
You have to have an onModuleLoad
function with

00:22:24.070 --> 00:22:25.490
access qualifiers.

00:22:25.490 --> 00:22:27.400
And then you call
window.alert.

00:22:27.400 --> 00:22:29.510
Here you just declare a main
function and that basically

00:22:29.510 --> 00:22:32.270
runs whatever code
is specified.

00:22:32.270 --> 00:22:35.490
But a lot of times people are
going to structure a little

00:22:35.490 --> 00:22:37.590
more, because you don't want
everything running in main.

00:22:37.590 --> 00:22:40.620
So people might decide
to declare a class.

00:22:40.620 --> 00:22:43.480
So here I have a class called
Hello, and my equivalent of

00:22:43.480 --> 00:22:45.745
onModuleLoad is the
go function.

00:22:45.745 --> 00:22:48.290
And from main, I just
create that Hello

00:22:48.290 --> 00:22:49.558
instance and invoke go.

00:22:52.630 --> 00:22:56.360
So this is a really important
point right now.

00:22:56.360 --> 00:22:59.300
So you know, Dart is
bleeding edge.

00:22:59.300 --> 00:23:02.130
And we're working hard on
it, and we're working

00:23:02.130 --> 00:23:02.980
as fast as we can.

00:23:02.980 --> 00:23:06.440
But we don't yet have a widget
library in the SDK that you

00:23:06.440 --> 00:23:07.360
can download today.

00:23:07.360 --> 00:23:08.810
One will be available soon.

00:23:08.810 --> 00:23:11.140
If you've seen some of the other
demos, like the Swarm

00:23:11.140 --> 00:23:12.890
app, there's some really
slick stuff going on.

00:23:12.890 --> 00:23:16.240
And that knowledge will
translate into an awesome

00:23:16.240 --> 00:23:17.340
widget library.

00:23:17.340 --> 00:23:19.780
But for now, we just have
DOM programming.

00:23:19.780 --> 00:23:24.360
And so I'm going to compare GWT
DOM program versus Dart

00:23:24.360 --> 00:23:24.800
DOM programming.

00:23:24.800 --> 00:23:28.200
So here is an example.

00:23:28.200 --> 00:23:31.490
I might have a div tag with
ID "button" in the HTML.

00:23:31.490 --> 00:23:34.100
So I'm going to add an
EventListener, a click

00:23:34.100 --> 00:23:36.910
EventListener, to
that div tag.

00:23:36.910 --> 00:23:38.990
And so here's the GWT
code that you have

00:23:38.990 --> 00:23:40.020
to write to do that.

00:23:40.020 --> 00:23:42.850
So you have to look it up by
going Document.get, which gets

00:23:42.850 --> 00:23:43.480
the document element.

00:23:43.480 --> 00:23:45.470
Then getElementByID
and the button.

00:23:45.470 --> 00:23:47.790
Then you have to sink the event
type event you want to

00:23:47.790 --> 00:23:50.790
listen to, so you use
DOM.sinkEvents.

00:23:50.790 --> 00:23:53.050
Then you have to set the
EventListener callback,

00:23:53.050 --> 00:23:56.610
DOM.setEventListener, and have
an anonymous inner class

00:23:56.610 --> 00:24:00.150
callback with a function
declared in it, which then has

00:24:00.150 --> 00:24:02.210
window.alert.

00:24:02.210 --> 00:24:05.320
So what would that look
like in Dart?

00:24:05.320 --> 00:24:10.040
You just say Query
("#ID").on.click.add and then

00:24:10.040 --> 00:24:11.655
a closure for the
EventHandler.

00:24:11.655 --> 00:24:12.770
Now there's a couple
of interesting

00:24:12.770 --> 00:24:13.870
things going on here.

00:24:13.870 --> 00:24:18.080
First of all, Dart has global
functions, and so not every

00:24:18.080 --> 00:24:19.830
method has to be part
of a class.

00:24:19.830 --> 00:24:24.105
So there's a global top-level
query function, and basically

00:24:24.105 --> 00:24:26.360
it kind of acts like the
dollar-sign function in

00:24:26.360 --> 00:24:27.720
jQuery, if you want to think
of it like that.

00:24:27.720 --> 00:24:31.530
So I'm looking up the button
with ID "button." And I'm

00:24:31.530 --> 00:24:32.870
going to get back an element.

00:24:32.870 --> 00:24:36.310
Now the element going to have a
magic field in it called on.

00:24:36.310 --> 00:24:39.410
And on is going to have a bunch
of setter properties--

00:24:39.410 --> 00:24:41.310
like I showed you setters
earlier--

00:24:41.310 --> 00:24:42.310
for each type of event.

00:24:42.310 --> 00:24:45.100
So here we've got one
called click--

00:24:45.100 --> 00:24:45.580
a setter.

00:24:45.580 --> 00:24:48.510
We've got one called mouseOver
and things like that.

00:24:48.510 --> 00:24:51.040
And each one of those is going
to have an add method on it.

00:24:51.040 --> 00:24:54.030
And so now, I'm just saying--

00:24:54.030 --> 00:24:58.790
for the element that I got back,
on click, give me back

00:24:58.790 --> 00:25:02.710
this click thing, which can then
allow me to add a closure

00:25:02.710 --> 00:25:04.600
to it, which will be called.

00:25:04.600 --> 00:25:07.090
And so that's basically how you
would write the same code.

00:25:07.090 --> 00:25:08.375
You look at it again--

00:25:11.530 --> 00:25:12.780
it looks a lot more readable.

00:25:16.570 --> 00:25:19.970
So that's basically converting
a Hello World and some simple

00:25:19.970 --> 00:25:21.160
DOM programming.

00:25:21.160 --> 00:25:23.980
This is kind of where
Dart is today.

00:25:23.980 --> 00:25:26.270
As I said, there's high-level
libraries that are on the way

00:25:26.270 --> 00:25:28.040
real soon now.

00:25:28.040 --> 00:25:30.510
But for now, it's really an
HTML5 experience, which is not

00:25:30.510 --> 00:25:31.980
always the worst thing.

00:25:31.980 --> 00:25:36.400
But here's the sort of
high-level mapping of what API

00:25:36.400 --> 00:25:38.200
in GWT corresponds to what
you have to do in Dart.

00:25:38.200 --> 00:25:40.790
So if you're using
com.google.gwt.dom, you're

00:25:40.790 --> 00:25:43.320
going to import the
dart:html library.

00:25:43.320 --> 00:25:46.790
If you're using UIBinder and
SafeHTMLTemplates and

00:25:46.790 --> 00:25:49.880
[INAUDIBLE] messages from GWT,
you're probably just going to

00:25:49.880 --> 00:25:53.080
use Dart string interpolation
to do the same thing.

00:25:53.080 --> 00:25:56.295
If you're doing server
communication, like GWT RPC or

00:25:56.295 --> 00:25:58.810
Request Factory, in Dart, right
now, today, you're going

00:25:58.810 --> 00:26:01.130
to use XMLHttpRequest.

00:26:01.130 --> 00:26:03.970
For widgets, of course,
GWT has widgets.

00:26:03.970 --> 00:26:05.530
For Dart, real soon now
there's going to

00:26:05.530 --> 00:26:06.910
be some cool stuff.

00:26:06.910 --> 00:26:13.300
And in multi-process, for using
WebWorkers, GWT has some

00:26:13.300 --> 00:26:16.450
third-party hacks that add
WebWorker support to GWT.

00:26:16.450 --> 00:26:20.670
Dart actually has WebWorkers
built in to the language as a

00:26:20.670 --> 00:26:23.890
first-class construct.

00:26:23.890 --> 00:26:25.470
They're called isolates.

00:26:25.470 --> 00:26:29.710
And so doing multi-process stuff
within Dart really has

00:26:29.710 --> 00:26:30.240
no equal anywhere.

00:26:30.240 --> 00:26:34.130
They make it really
easy to use.

00:26:34.130 --> 00:26:36.480
So let's try to get a little
more deeper and port something

00:26:36.480 --> 00:26:37.040
more complex.

00:26:37.040 --> 00:26:38.360
Let's try to port a widget.

00:26:41.252 --> 00:26:43.905
Now widgets are written in many
different ways in GWT.

00:26:43.905 --> 00:26:46.726
I'm just going to focus on the
modern way people do widgets

00:26:46.726 --> 00:26:49.280
with GWT, which is
with UIBinder.

00:26:49.280 --> 00:26:52.810
And so the idea here is just
how can I take a GWT widget

00:26:52.810 --> 00:26:56.320
that I've written that uses
UIBinder to define its HTML

00:26:56.320 --> 00:26:59.825
structure and port that
over to Dart?

00:26:59.825 --> 00:27:02.450
And the general idea here is
just to take the UIBinder

00:27:02.450 --> 00:27:06.440
template and enclose it in
a multi-line string.

00:27:06.440 --> 00:27:11.090
Convert any of the ui:field
attributes to just be ID

00:27:11.090 --> 00:27:12.770
attributes on the elements.

00:27:12.770 --> 00:27:16.030
Then build a Dart class to
represent normally what GWT

00:27:16.030 --> 00:27:18.940
would generate to bind that
template, which is basically

00:27:18.940 --> 00:27:21.605
looking up the IDs and assigning
them to fields in

00:27:21.605 --> 00:27:23.070
your object.

00:27:23.070 --> 00:27:25.410
And then you'll have to
basically move the raw HTML

00:27:25.410 --> 00:27:30.330
resources, like CssResource, to
be external CSS by using a

00:27:30.330 --> 00:27:33.040
link tag to include the CSS.

00:27:33.040 --> 00:27:37.330
It's not a perfect solution, but
it's not horribly bad to

00:27:37.330 --> 00:27:38.440
port code like this.

00:27:38.440 --> 00:27:41.810
So here's an example.

00:27:41.810 --> 00:27:43.170
This is how it looks in Java.

00:27:43.170 --> 00:27:45.455
I have a UIBinder template
with a div tag.

00:27:45.455 --> 00:27:49.580
It says, Hello, &lt;span ui:
field = 'nameSpan' /&gt; .

00:27:49.580 --> 00:27:53.710
And then here I have a little
bit of code which basically

00:27:53.710 --> 00:27:57.930
calls setElement(UIBin
der.CreateandBindUi(this)).

00:27:57.930 --> 00:27:59.230
Now if you're GWT programmer,
you know

00:27:59.230 --> 00:28:00.920
this works some magic.

00:28:00.920 --> 00:28:04.690
And what happens is, is it
basically generates some code

00:28:04.690 --> 00:28:09.600
behind the scenes that will take
that UIBinder template,

00:28:09.600 --> 00:28:13.820
create a div tag, and inject
that HTML source, as an inner

00:28:13.820 --> 00:28:15.240
HTML, into it.

00:28:15.240 --> 00:28:16.840
And put it into the document.

00:28:16.840 --> 00:28:19.190
And then the next thing it will
do is it will go through

00:28:19.190 --> 00:28:21.060
and it will look up
that field, that

00:28:21.060 --> 00:28:23.730
UI field, the nameSpan.

00:28:23.730 --> 00:28:25.980
And when it finds that element,
it will store it in

00:28:25.980 --> 00:28:27.020
the field on your class.

00:28:27.020 --> 00:28:30.970
You can see here, this
nameSpan attribute.

00:28:30.970 --> 00:28:33.420
So this element will be looked
up in the DOM with

00:28:33.420 --> 00:28:36.940
getElementById and then
put there for you.

00:28:36.940 --> 00:28:38.810
So kind of like a dependency
injection.

00:28:38.810 --> 00:28:40.490
So we want to get
that into Dart.

00:28:40.490 --> 00:28:42.240
So how can we emulate that?

00:28:42.240 --> 00:28:45.340
So the first thing is, we remove
the top and bottom XML

00:28:45.340 --> 00:28:46.410
tags and replace them
with triple-quote.

00:28:46.410 --> 00:28:50.890
And so now we've just put it
into a multi-line string.

00:28:50.890 --> 00:28:56.530
And we replace the ui:field
with just id='nameSpan'.

00:28:56.530 --> 00:29:01.100
And then secondly, the next step
that we'd do is we would

00:29:01.100 --> 00:29:02.430
write a function--

00:29:02.430 --> 00:29:04.620
that you can see right here--

00:29:04.620 --> 00:29:11.440
which will first create a new
HTML element with the

00:29:11.440 --> 00:29:13.810
template, which we
defined up here.

00:29:13.810 --> 00:29:18.100
And what this new Element.html
does is it actually kind of

00:29:18.100 --> 00:29:21.570
creates a div and injects the
string as the innerHTML of it.

00:29:21.570 --> 00:29:24.390
So what you get back, basically,
is essentially what

00:29:24.390 --> 00:29:27.170
UIBinder was doing as a div
element with the HTML in it.

00:29:27.170 --> 00:29:32.250
And then once we get that, we
input it into the DOM, the

00:29:32.250 --> 00:29:35.620
next thing we're going to do is
run element.query on it and

00:29:35.620 --> 00:29:39.440
look up id nameSpan and then
assign it to the field

00:29:39.440 --> 00:29:40.620
nameSpan here.

00:29:40.620 --> 00:29:44.290
So GWT kind of automates that
part of it, which is

00:29:44.290 --> 00:29:46.310
automatically looking up the
element for you and then

00:29:46.310 --> 00:29:46.970
signing it.

00:29:46.970 --> 00:29:49.950
So you actually have to write
that code yourself here, but

00:29:49.950 --> 00:29:51.950
it's not too bad.

00:29:51.950 --> 00:29:54.720
But you could make it
expandable, extensible.

00:29:54.720 --> 00:29:59.170
So here I have one where we have
two nameSpan tags in my

00:29:59.170 --> 00:30:03.245
template and I would have
two fields, like a

00:30:03.245 --> 00:30:04.590
nameSpan1 and a nameSpan2.

00:30:04.590 --> 00:30:08.150
Instead of having fields on my
object, I use a map, a map

00:30:08.150 --> 00:30:11.950
from the id to the element.

00:30:11.950 --> 00:30:15.370
And then what I do is I extend
my setElementByTemplate

00:30:15.370 --> 00:30:18.690
function to take the template,
which was from up here, and

00:30:18.690 --> 00:30:23.610
take a list of ids to look
up, which were up here.

00:30:23.610 --> 00:30:25.340
And then what this is going to
do is it's going to inject

00:30:25.340 --> 00:30:29.080
this and then document.query
look up each one of those and

00:30:29.080 --> 00:30:30.480
inject them into
the map for me.

00:30:30.480 --> 00:30:33.330
And that's what this basically
does here.

00:30:33.330 --> 00:30:38.490
It loops over for each ID and
then it injects into the map,

00:30:38.490 --> 00:30:41.760
calling element.query
with the id.

00:30:41.760 --> 00:30:44.735
And so that's a way to sort
of make it extensible.

00:30:44.735 --> 00:30:47.700
So you could have an arbitrary
number of elements that are

00:30:47.700 --> 00:30:51.390
looked up and automatically
injected for you, so you can

00:30:51.390 --> 00:30:55.170
cache them and look
them up later.

00:30:55.170 --> 00:30:57.050
What about instantiated widgets,
though, right?

00:30:57.050 --> 00:30:59.790
So I just showed you
HTML tags that

00:30:59.790 --> 00:31:01.030
are in UIBinder templates.

00:31:01.030 --> 00:31:02.340
But you know that GWT
does a lot more.

00:31:02.340 --> 00:31:06.290
So for example, you might use
HTMLPanel, or Menu item, or

00:31:06.290 --> 00:31:08.090
Tree item, and things
like that.

00:31:08.090 --> 00:31:12.460
Well, if it's a basic leaf
widget in GWT, like an input,

00:31:12.460 --> 00:31:16.280
or a checkbox, or a text area,
or something, you can just

00:31:16.280 --> 00:31:19.030
replace those with the
HTML5 equivalents.

00:31:19.030 --> 00:31:21.710
In fact for GWT, even, we
recommend actually not using

00:31:21.710 --> 00:31:25.650
heavyweight widgets for stuff
that's just basic HTML5.

00:31:25.650 --> 00:31:28.270
It's just too much overhead.

00:31:28.270 --> 00:31:31.030
But if you have something like a
composite type that's really

00:31:31.030 --> 00:31:35.170
complex, like a menu
or a tree--

00:31:35.170 --> 00:31:37.430
yes, right now, you're going
to actually need to code

00:31:37.430 --> 00:31:38.470
replacements.

00:31:38.470 --> 00:31:40.090
The good news is you're only
going to do it once, but yeah,

00:31:40.090 --> 00:31:41.630
you're going to have to write
your own tree for now.

00:31:41.630 --> 00:31:45.430
And I expect that as Dart gets a
larger and larger community,

00:31:45.430 --> 00:31:49.590
even if Dart provides its own
widget library, probably other

00:31:49.590 --> 00:31:50.490
people are going to
write their own

00:31:50.490 --> 00:31:51.340
widget libraries too.

00:31:51.340 --> 00:31:55.360
Someone will have a fancy tree
or a fancy carousel widget or

00:31:55.360 --> 00:31:57.740
something that is not included
in the library.

00:31:57.740 --> 00:32:04.500
So for now, it's an HTML
experience, but things will

00:32:04.500 --> 00:32:05.100
get better.

00:32:05.100 --> 00:32:09.410
But if you think it's too hard
to port widgets, then there's

00:32:09.410 --> 00:32:12.960
an alternate pattern that
you can use to get your

00:32:12.960 --> 00:32:13.730
feet wet with Dart.

00:32:13.730 --> 00:32:19.710
Let's say you have an existing
GWT application and you want

00:32:19.710 --> 00:32:20.830
to kind of try out Dart.

00:32:20.830 --> 00:32:21.980
Maybe you want to write
a new page.

00:32:21.980 --> 00:32:24.780
You want to add a new page to
your application, like a

00:32:24.780 --> 00:32:28.610
settings screen or like a
feedback page or something.

00:32:28.610 --> 00:32:31.240
And you want to write that part
in Dart, but the entire

00:32:31.240 --> 00:32:32.550
rest of the part, you
want to keep in GWT.

00:32:32.550 --> 00:32:34.210
So you want to keep your
application running at all

00:32:34.210 --> 00:32:38.070
times and not throw everything
away and start from scratch.

00:32:38.070 --> 00:32:40.630
The good news is that if you use
the Activities and Places

00:32:40.630 --> 00:32:43.550
model that's been in GWT for a
while, or if you've always

00:32:43.550 --> 00:32:48.060
been using history tag routing,
then you could do

00:32:48.060 --> 00:32:49.240
this quite easily.

00:32:49.240 --> 00:32:51.220
And the way you could
do it is this.

00:32:51.220 --> 00:32:55.150
You have your GWT application
look for history state changes

00:32:55.150 --> 00:32:56.380
in the hashtag.

00:32:56.380 --> 00:32:59.370
And if the history change is
one of the things that your

00:32:59.370 --> 00:33:03.440
app understands, then route the
event to the existing GWT

00:33:03.440 --> 00:33:05.510
code that's going to
put up that page.

00:33:05.510 --> 00:33:08.300
But if it's something you don't
understand, then send a

00:33:08.300 --> 00:33:12.390
message or let it fall through
to a Dart application that's

00:33:12.390 --> 00:33:13.540
running in the same page.

00:33:13.540 --> 00:33:15.770
So you've source-scripted in the
GWT module and you've also

00:33:15.770 --> 00:33:17.810
source-scripted in your Dart
app, and they're both looking

00:33:17.810 --> 00:33:19.060
at the history.

00:33:19.060 --> 00:33:21.800
And if they agree not to step
on each other's toes, this

00:33:21.800 --> 00:33:22.580
could work very well.

00:33:22.580 --> 00:33:24.540
The Dart code could look at
it and go, well, I don't

00:33:24.540 --> 00:33:28.100
understand that history tag, so
GWT can probably take care

00:33:28.100 --> 00:33:28.700
of that one.

00:33:28.700 --> 00:33:31.060
But I see one that's destined
for me, like the feedback

00:33:31.060 --> 00:33:35.110
page, the new feedback page, so
I'm basically going to take

00:33:35.110 --> 00:33:38.650
over the main content
area of the page and

00:33:38.650 --> 00:33:40.810
replace it with my UI.

00:33:40.810 --> 00:33:41.580
Right?

00:33:41.580 --> 00:33:48.210
And so that gives you kind of a
very high-level integration

00:33:48.210 --> 00:33:51.100
point for putting Dart pages
into your existing GWT apps.

00:33:53.800 --> 00:33:56.200
You could migrate page
at a time that way.

00:33:56.200 --> 00:33:58.720
Here's a picture, like you
might have a banking

00:33:58.720 --> 00:34:00.510
application.

00:34:00.510 --> 00:34:03.090
And so maybe you have an
existing bill payment service,

00:34:03.090 --> 00:34:06.180
and #billpay on the URL will
send you to the bill pay

00:34:06.180 --> 00:34:08.355
activity in the GWT app.

00:34:08.355 --> 00:34:11.010
But you're adding a new page,
which is banking, like maybe

00:34:11.010 --> 00:34:12.199
bank transfers.

00:34:12.199 --> 00:34:14.080
And so you've written
that one in Dart.

00:34:14.080 --> 00:34:17.970
So what you do is you just have
the Dart part of the app

00:34:17.970 --> 00:34:20.900
that's sitting in the page look
for #banking in the URL.

00:34:20.900 --> 00:34:24.199
And that's the signal for it
to actually take over the

00:34:24.199 --> 00:34:28.750
content area and install
its view.

00:34:28.750 --> 00:34:30.800
But if you do this, the very
next thing you're going to run

00:34:30.800 --> 00:34:33.040
into is, how do you share
application state?

00:34:33.040 --> 00:34:36.570
I mean, maybe the GWT app just
did something and now the Dart

00:34:36.570 --> 00:34:39.139
app actually has to get
what was changed.

00:34:39.139 --> 00:34:42.650
And so there are a number
of options for this.

00:34:42.650 --> 00:34:45.460
One option is, use
browser storage.

00:34:45.460 --> 00:34:50.060
So you could use IndexDB,
SessionStorage, or cookies and

00:34:50.060 --> 00:34:54.639
have GWT commit transient
session-oriented data, let's

00:34:54.639 --> 00:34:58.360
say the current account or
profile representing the user.

00:34:58.360 --> 00:35:01.260
Have it committed to IndexDB
storage in the browser.

00:35:01.260 --> 00:35:03.740
And then when Dart goes to kick
off its view, like you

00:35:03.740 --> 00:35:08.950
navigate to the banking page,
then it's going to read from

00:35:08.950 --> 00:35:11.980
the database and get things
related to the user, like his

00:35:11.980 --> 00:35:14.720
name, his current account,
authentication tokens to let

00:35:14.720 --> 00:35:17.090
him make transfers, and
things like that.

00:35:17.090 --> 00:35:19.610
The other option is, you could
put serialized data objects

00:35:19.610 --> 00:35:20.790
into the DOM.

00:35:20.790 --> 00:35:25.720
So if you want Dart to pick up
something that GWT has to send

00:35:25.720 --> 00:35:27.950
to it, one option is just create
an element, like a div

00:35:27.950 --> 00:35:31.240
element, use display none, and
put some data in there.

00:35:31.240 --> 00:35:34.660
And then give it an
id, like an id =

00:35:34.660 --> 00:35:35.780
data object or something.

00:35:35.780 --> 00:35:37.810
And then just have Dart
look it up and parse

00:35:37.810 --> 00:35:38.890
the JSON out of it.

00:35:38.890 --> 00:35:40.950
That's another option.

00:35:40.950 --> 00:35:43.150
Probably the cleanest mechanism

00:35:43.150 --> 00:35:44.370
is just to use messaging.

00:35:44.370 --> 00:35:47.480
So in the new HTML5 browsers.
you have window.postMessage().

00:35:47.480 --> 00:35:49.070
So you can use this
for communication

00:35:49.070 --> 00:35:50.170
between GWT and Dart.

00:35:50.170 --> 00:35:52.630
Have Dart listen on window
object for messages and just

00:35:52.630 --> 00:35:55.580
have GWT post messages, so you
can transfer data back and

00:35:55.580 --> 00:36:01.130
forth between the two running
apps that way.

00:36:01.130 --> 00:36:05.230
So one thing, as a GWT
programmer, you're probably

00:36:05.230 --> 00:36:08.820
wondering about is something
like JSNI.

00:36:08.820 --> 00:36:11.190
And we got a lot of mileage
out of that with GWT.

00:36:11.190 --> 00:36:14.880
Early on in GWT's adoption,
there were a lot of JavaScript

00:36:14.880 --> 00:36:15.690
libraries out there.

00:36:15.690 --> 00:36:17.690
We didn't have really
killer widgets.

00:36:17.690 --> 00:36:19.780
GWT widgets really looked
terrible out of the box.

00:36:19.780 --> 00:36:22.540
And so people we're going and
picking up jQuery or picking

00:36:22.540 --> 00:36:24.080
up Ext JS and things like
that and they were

00:36:24.080 --> 00:36:25.630
wrapping them with GWT.

00:36:25.630 --> 00:36:28.150
And that really held people over
until we could actually

00:36:28.150 --> 00:36:29.960
deliver better widgets
in later versions.

00:36:29.960 --> 00:36:32.450
And so you might be thinking,
well I'll do that for Dart.

00:36:32.450 --> 00:36:36.110
I'll use Dart and I'll wrap some
cool widgets until the

00:36:36.110 --> 00:36:38.270
Dart team delivers the
better widget set.

00:36:38.270 --> 00:36:41.910
Unfortunately, Dart does
not have JSNI.

00:36:41.910 --> 00:36:43.900
And there's a very good
reason for that.

00:36:43.900 --> 00:36:46.880
And so you might think of
Dart as it is today as

00:36:46.880 --> 00:36:48.800
a Dart-to-JS compiler.

00:36:48.800 --> 00:36:52.760
But Dart as it's envisioned is
actually a virtual machine

00:36:52.760 --> 00:36:56.720
that runs just like V8 does,
but it runs Dart code.

00:36:56.720 --> 00:36:58.810
And so because it's another
virtual machine in the

00:36:58.810 --> 00:37:00.320
browser, it's separate
from V8.

00:37:00.320 --> 00:37:01.500
It has a separate heap.

00:37:01.500 --> 00:37:03.920
So you can't just pass an object
reference from one to

00:37:03.920 --> 00:37:06.160
the other, because they live
in different memory spaces.

00:37:06.160 --> 00:37:08.030
Probably even different
process sandboxes.

00:37:08.030 --> 00:37:12.000
So that wouldn't be very
efficient, even if you could

00:37:12.000 --> 00:37:14.530
pull it off.

00:37:14.530 --> 00:37:19.870
But there still is a need for
you to make calls from Dart to

00:37:19.870 --> 00:37:20.970
JavaScript and vice versa.

00:37:20.970 --> 00:37:22.360
There's no question
about that.

00:37:22.360 --> 00:37:23.420
There is a need to do that.

00:37:23.420 --> 00:37:25.700
Like, you might want to interact
with the Maps API

00:37:25.700 --> 00:37:29.120
from Google, and there's
no Dart Maps API yet.

00:37:29.120 --> 00:37:31.720
And so there has to be
a way to do this.

00:37:31.720 --> 00:37:34.870
And fortunately, there
is a way to do it.

00:37:34.870 --> 00:37:37.150
There's an unofficial way--

00:37:37.150 --> 00:37:39.390
quite a few, actually, which
I'm going to show you.

00:37:39.390 --> 00:37:41.910
And I'm going to make you a
promise that we're actually

00:37:41.910 --> 00:37:44.840
working on it, and actually, a
real nice solution will be

00:37:44.840 --> 00:37:46.460
coming later down the pipe.

00:37:46.460 --> 00:37:49.910
So what are the ways
we can do this?

00:37:49.910 --> 00:37:51.875
Well one way is this
postMessage() communication,

00:37:51.875 --> 00:37:53.480
like I just discussed.

00:37:53.480 --> 00:37:57.410
So what you could do is you
could have JavaScript listen

00:37:57.410 --> 00:38:01.250
for window.onmessage, and
anything that basically comes

00:38:01.250 --> 00:38:04.090
in through a message, you
just run eval on it.

00:38:04.090 --> 00:38:07.310
And then likewise, in
the Dart world--

00:38:07.310 --> 00:38:09.290
this is Dart code here--

00:38:09.290 --> 00:38:11.970
you do postMessage, and in
there you put JavaScript.

00:38:11.970 --> 00:38:14.920
And then so the JavaScript event
handler gets triggered

00:38:14.920 --> 00:38:15.920
and it just runs eval.

00:38:15.920 --> 00:38:20.120
So I've made a call from Dart
to JavaScript in that way.

00:38:20.120 --> 00:38:22.080
It's not pretty, but it works.

00:38:22.080 --> 00:38:26.130
Another solution that people do,
because you have a little

00:38:26.130 --> 00:38:28.680
bit more control, is script
tag injections.

00:38:28.680 --> 00:38:32.310
So in Dart code, you could just
create a script tag, set

00:38:32.310 --> 00:38:36.330
its text attribute to be the
JavaScript text, and insert it

00:38:36.330 --> 00:38:39.080
into the body of the browser
document, and it

00:38:39.080 --> 00:38:41.820
will just be evaluated.

00:38:41.820 --> 00:38:45.040
But that's only uni-directional
communication,

00:38:45.040 --> 00:38:50.170
and you can't build an API if
you can't get any values back

00:38:50.170 --> 00:38:53.310
after you evaluate the code.

00:38:53.310 --> 00:38:55.850
You could have bi-directional
messaging.

00:38:55.850 --> 00:38:57.940
So I could send the message to
JavaScript, and it'll say,

00:38:57.940 --> 00:39:00.090
call this method on Google
Maps for me.

00:39:00.090 --> 00:39:03.560
Google Maps dot
setCurrentLongitude = 10.

00:39:03.560 --> 00:39:07.180
But the problem is, I can't get
any return value from that

00:39:07.180 --> 00:39:08.280
function back.

00:39:08.280 --> 00:39:10.930
You could make the JavaScript
then post the message back to

00:39:10.930 --> 00:39:13.420
Dart and have Dart listen for a
message, which then has the

00:39:13.420 --> 00:39:14.570
return value in it.

00:39:14.570 --> 00:39:16.680
And in that case, it would
look very much like

00:39:16.680 --> 00:39:22.120
asynchronous JSON-RPC back and
forth between the server.

00:39:22.120 --> 00:39:26.160
But the API that could be built
around that would look

00:39:26.160 --> 00:39:26.860
pretty nasty.

00:39:26.860 --> 00:39:29.400
For example, every getter and
setter would have to take a

00:39:29.400 --> 00:39:33.400
closure that would be called
back into with the return

00:39:33.400 --> 00:39:35.310
value when it was ready.

00:39:35.310 --> 00:39:37.160
You have got to remember,
the browser isn't always

00:39:37.160 --> 00:39:37.700
synchronous.

00:39:37.700 --> 00:39:40.120
So if you ask the browser to do
something, it could do it

00:39:40.120 --> 00:39:42.500
immediately, or actually,
it could do it

00:39:42.500 --> 00:39:44.480
at next event loop.

00:39:44.480 --> 00:39:48.190
And so you have to basically
pass it a callback because it

00:39:48.190 --> 00:39:50.450
could be executed
at a later time.

00:39:50.450 --> 00:39:55.830
And so this would lead to a
really poor API experience.

00:39:55.830 --> 00:39:59.400
But it turns out, there's
actually an API in a browser.

00:39:59.400 --> 00:40:02.790
It's one of the very few
synchronous XHRs or another

00:40:02.790 --> 00:40:07.950
that actually is synchronous,
meaning it actually blocks

00:40:07.950 --> 00:40:10.270
until it finishes executing.

00:40:10.270 --> 00:40:12.580
And it's called dispatchEvent().

00:40:12.580 --> 00:40:15.440
And what it allows you to do is
to fire off an event, like

00:40:15.440 --> 00:40:18.680
onClick or something like that,
and it will be handled

00:40:18.680 --> 00:40:19.320
immediately.

00:40:19.320 --> 00:40:23.000
Not the next time the browser
goes to the event loop, or

00:40:23.000 --> 00:40:26.020
after all the set timeouts
run, but right now.

00:40:26.020 --> 00:40:30.870
And so that gives us a hack or
sort of a doorway to get true

00:40:30.870 --> 00:40:33.220
synchronous bi-directional
messaging between Dart and

00:40:33.220 --> 00:40:34.140
JavaScript.

00:40:34.140 --> 00:40:37.980
And the essential way you'll
do it is this.

00:40:37.980 --> 00:40:43.120
You're going to invent a
new custom event name.

00:40:43.120 --> 00:40:44.250
And you can do that
in JavaScript.

00:40:44.250 --> 00:40:45.180
You can make your own events.

00:40:45.180 --> 00:40:47.720
You don't have to just use
onClick or mouseover.

00:40:47.720 --> 00:40:52.440
And I'll call it 'dartjsni',
just for GWT'S sake.

00:40:52.440 --> 00:40:54.050
And then what you're going to do
is you're going to register

00:40:54.050 --> 00:40:57.950
an event listener in Dart via
window.addEventListener and

00:40:57.950 --> 00:41:03.190
look for this 'dartjsni' event
to happen, and do something

00:41:03.190 --> 00:41:04.260
when it does happen.

00:41:04.260 --> 00:41:06.360
And then you're going to
construct a serialization

00:41:06.360 --> 00:41:07.740
format for RPC calls.

00:41:07.740 --> 00:41:09.830
Maybe you just take the method
name and all the arguments

00:41:09.830 --> 00:41:11.530
that you want to call and you
serialize them in a JSON

00:41:11.530 --> 00:41:13.300
object or something.

00:41:13.300 --> 00:41:16.680
And you have the callback
that's looking for that

00:41:16.680 --> 00:41:20.240
'dartjsni' event deserialize
it and evaluate it.

00:41:20.240 --> 00:41:22.540
Then you're going to invent
another event name-- let's

00:41:22.540 --> 00:41:24.260
call it 'returnjsni'--

00:41:24.260 --> 00:41:26.520
and it's going to take the
return value, serialize it,

00:41:26.520 --> 00:41:28.960
and then fire via
window.dispatchEvent this

00:41:28.960 --> 00:41:32.060
'returnjsni' event.

00:41:32.060 --> 00:41:34.980
And then in the Dart code,
you're going to be looking for

00:41:34.980 --> 00:41:40.110
window.OnDartjsni event handler,
and that's going to

00:41:40.110 --> 00:41:42.430
be the return value.

00:41:42.430 --> 00:41:44.730
And what makes this all work
is that when both sides use

00:41:44.730 --> 00:41:48.330
dispatchEvent(), there
is no asynchronicity.

00:41:48.330 --> 00:41:50.350
You fire the event and it
immediately evokes the

00:41:50.350 --> 00:41:51.660
callback on the JavaScript
side.

00:41:51.660 --> 00:41:54.100
The JavaScript side does the
evaluation and invokes

00:41:54.100 --> 00:41:56.550
dispatchEvent for 'returnjsni'
and it immediately runs the

00:41:56.550 --> 00:42:02.040
Dart event handler, all in
one synchronous loop.

00:42:02.040 --> 00:42:03.190
This is just a picture of it.

00:42:03.190 --> 00:42:05.240
It's probably not very
useful for you.

00:42:05.240 --> 00:42:06.985
But I tried to draw
how it would work.

00:42:10.270 --> 00:42:12.320
I'm just going to skip
that picture for now.

00:42:12.320 --> 00:42:16.640
So you could make the
JSNI mappings even

00:42:16.640 --> 00:42:17.720
more natural, right?

00:42:17.720 --> 00:42:21.200
Like what if you just wanted
to have a Dart object, and

00:42:21.200 --> 00:42:24.580
when you refer on that Dart
object to any field or any

00:42:24.580 --> 00:42:27.830
method, it actually is kind of
a mirror or a proxy directly

00:42:27.830 --> 00:42:28.250
into JavaScript.

00:42:28.250 --> 00:42:30.600
It kind of represents a
JavaScript object on the other

00:42:30.600 --> 00:42:32.300
side of the fence.

00:42:32.300 --> 00:42:35.870
And so Dart has two features
that actually almost make this

00:42:35.870 --> 00:42:39.130
look completely natural and
almost like the JavaScript's

00:42:39.130 --> 00:42:39.820
not even involved.

00:42:39.820 --> 00:42:42.000
The first is operator
overloading.

00:42:42.000 --> 00:42:45.610
So you can implement
the operator[]--

00:42:45.610 --> 00:42:47.960
and here I have a class
called JsProxy--

00:42:47.960 --> 00:42:49.840
and it takes a field name.

00:42:49.840 --> 00:42:52.480
And then what you do is you
make that synchronous call

00:42:52.480 --> 00:42:54.720
over using that Dart
JSNI method I just

00:42:54.720 --> 00:42:56.140
described how you'd do.

00:42:56.140 --> 00:43:00.420
And you index the field name on
the object reference that

00:43:00.420 --> 00:43:04.690
you're holding on to, that this
proxy object represents.

00:43:04.690 --> 00:43:06.960
Dart has another feature I
haven't described yet.

00:43:06.960 --> 00:43:10.170
Because it's a dynamic language,
what I said earlier

00:43:10.170 --> 00:43:14.020
was is that you can try to
access or invoke anything on

00:43:14.020 --> 00:43:16.260
an object, even though it's the
wrong type, and it will

00:43:16.260 --> 00:43:17.850
still try it.

00:43:17.850 --> 00:43:20.240
And if it fails, it doesn't
fail completely.

00:43:20.240 --> 00:43:22.630
What it does is it invokes
noSuchMethod.

00:43:22.630 --> 00:43:24.700
So it's a magical method.

00:43:24.700 --> 00:43:27.070
You could put it on a Dart class
to override it, and it

00:43:27.070 --> 00:43:29.470
will be called for any method
that it can't find, that

00:43:29.470 --> 00:43:30.970
someone tried to invoke.

00:43:30.970 --> 00:43:35.040
And so in this way, you could
make a JsProxy class that can

00:43:35.040 --> 00:43:40.640
invoke any JavaScript method
that exists in the JSVM by

00:43:40.640 --> 00:43:42.190
defining a noSuchMethod.

00:43:42.190 --> 00:43:43.960
It takes the name of the method
someone's trying to

00:43:43.960 --> 00:43:45.660
invoke and a list of the
arguments, and then you just

00:43:45.660 --> 00:43:48.660
make a synchronous call using
what I just described in the

00:43:48.660 --> 00:43:49.670
previous slide.

00:43:49.670 --> 00:43:53.972
And it will return the value as
if that method existed on

00:43:53.972 --> 00:43:57.220
the JsProxy object by going to
JavaScript and asking it to

00:43:57.220 --> 00:43:59.130
evaluate it.

00:43:59.130 --> 00:44:01.450
So that's another interesting
idiom or

00:44:01.450 --> 00:44:04.900
example you could use.

00:44:04.900 --> 00:44:08.330
And if you wanted to invoke GWT
code directly from Dart or

00:44:08.330 --> 00:44:11.810
vice versa, I would advocate
using a library I wrote called

00:44:11.810 --> 00:44:12.990
GWT Exporter.

00:44:12.990 --> 00:44:16.150
And what that allows you to do
is to put @Export annotations

00:44:16.150 --> 00:44:18.190
on your classes and
Java methods.

00:44:18.190 --> 00:44:23.510
And what it does is it manually
declares JavaScript

00:44:23.510 --> 00:44:27.360
exports in the top-level window
object of the page.

00:44:27.360 --> 00:44:29.700
And then once you've got those
things exposed to JavaScript,

00:44:29.700 --> 00:44:32.760
then you can use the Dart JSNI
method technique I showed you

00:44:32.760 --> 00:44:35.810
to just call directly
into GWT.

00:44:35.810 --> 00:44:38.560
Likewise, if you wanted to do
it the other way around, you

00:44:38.560 --> 00:44:42.930
could export Dart functions into
JavaScript by writing a

00:44:42.930 --> 00:44:46.895
JavaScript function which, when
invoked, uses the Dart

00:44:46.895 --> 00:44:49.690
JSNI mechanism to send a message
over to Dart and say,

00:44:49.690 --> 00:44:52.770
I'm invoking this method
on this Dart class.

00:44:52.770 --> 00:44:57.610
However what I've just shown
you, it's really complicated

00:44:57.610 --> 00:44:58.580
and it's kind of a hack.

00:44:58.580 --> 00:45:01.070
And I would not advocate using
it, except for specialized

00:45:01.070 --> 00:45:04.850
scenarios like trying to create
a really nice mapping

00:45:04.850 --> 00:45:06.610
for, like, the Google Maps
library or some other

00:45:06.610 --> 00:45:09.400
JavaScript library, where it
would be painful to have an

00:45:09.400 --> 00:45:11.580
asynchronous approach.

00:45:11.580 --> 00:45:13.680
Otherwise, I would suggest,
just use postMessage.

00:45:13.680 --> 00:45:17.710
It's the easiest thing and
the least likely to fail.

00:45:17.710 --> 00:45:20.410
And for the record, we actually
don't know how much

00:45:20.410 --> 00:45:21.730
longer dispatch will
be around.

00:45:21.730 --> 00:45:24.470
It could very well be that the
HTML5 committee could say

00:45:24.470 --> 00:45:26.030
tomorrow, we're removing that.

00:45:28.610 --> 00:45:33.310
So in summary I just wanted to
say that Dart is a cool new

00:45:33.310 --> 00:45:35.040
dynamic language.

00:45:35.040 --> 00:45:37.770
It takes some of the best things
from JavaScript, which

00:45:37.770 --> 00:45:40.820
is the ability to start up
quickly without a compile

00:45:40.820 --> 00:45:44.440
pass, to have the program
run even though

00:45:44.440 --> 00:45:45.310
the types are wrong.

00:45:45.310 --> 00:45:47.270
So you can iterate on
something, even

00:45:47.270 --> 00:45:49.360
if you've got errors.

00:45:49.360 --> 00:45:53.620
But also to allow the language
to be tooled and tested with

00:45:53.620 --> 00:45:56.550
compile-time static
tool chains.

00:45:56.550 --> 00:46:00.060
It offers a lightweight DOM
programming library for now,

00:46:00.060 --> 00:46:02.650
but later on, it will have
a very rich library.

00:46:02.650 --> 00:46:04.150
That's the whole point of
having a structured

00:46:04.150 --> 00:46:05.120
programming language.

00:46:05.120 --> 00:46:08.120
They invented all of this new
syntax for a type system.

00:46:08.120 --> 00:46:09.610
They're going to build
a really rich

00:46:09.610 --> 00:46:11.220
library to support it.

00:46:11.220 --> 00:46:15.690
It's not going to be very raw
and basic like JavaScript.

00:46:15.690 --> 00:46:17.590
Try converting some simple
GWT libraries.

00:46:17.590 --> 00:46:18.230
Get your feet wet.

00:46:18.230 --> 00:46:20.680
Pick the simplest thing in your
project and say, what

00:46:20.680 --> 00:46:21.570
would this look like in Dart?

00:46:21.570 --> 00:46:22.270
Just play around with it.

00:46:22.270 --> 00:46:23.310
Have some fun.

00:46:23.310 --> 00:46:24.570
Or integrate--

00:46:24.570 --> 00:46:27.370
try to add a new page your app
by basically writing it in

00:46:27.370 --> 00:46:30.950
Dart and using the hashtag
history routing to integrate

00:46:30.950 --> 00:46:33.140
it into the page.

00:46:33.140 --> 00:46:35.710
I would advocate, even if you're
not going to use Dart,

00:46:35.710 --> 00:46:38.070
to look at the GWT Activities
and Places model if you're not

00:46:38.070 --> 00:46:38.780
using it already.

00:46:38.780 --> 00:46:41.310
Because it will help
you in the future.

00:46:41.310 --> 00:46:45.800
And finally, if you're really
adventurous, try hacking a

00:46:45.800 --> 00:46:48.730
Dart JSNI library.

00:46:48.730 --> 00:46:51.590
You could probably release it,
and if you do it quick enough,

00:46:51.590 --> 00:46:54.390
everyone might use it.

00:46:54.390 --> 00:46:56.230
So that's my presentation.

00:46:56.230 --> 00:46:58.340
Hope you guys got something
out of it.

00:46:58.340 --> 00:47:00.660
And I'm open to taking
some questions.

00:47:00.660 --> 00:47:08.830
[APPLAUSE]

00:47:08.830 --> 00:47:09.050
AUDIENCE: Yeah.

00:47:09.050 --> 00:47:12.480
You mentioned
internationalization and

00:47:12.480 --> 00:47:13.760
string interpolation.

00:47:13.760 --> 00:47:15.650
RAY CROMWELL: Yes.

00:47:15.650 --> 00:47:19.293
AUDIENCE: I wonder, do you have
an example of that, like

00:47:19.293 --> 00:47:21.170
how it works in Dart?

00:47:21.170 --> 00:47:23.980
I'm using it in GWT, but to
migrate some stuff, I'm going

00:47:23.980 --> 00:47:25.360
to need to move it do Dart.

00:47:25.360 --> 00:47:27.260
RAY CROMWELL: Yeah, that's
a good question for me.

00:47:27.260 --> 00:47:30.530
[INAUDIBLE], do you happen
to know the idiom for

00:47:30.530 --> 00:47:31.878
doing that in Dart?

00:47:31.878 --> 00:47:34.120
AUDIENCE: [INAUDIBLE]

00:47:34.120 --> 00:47:35.660
RAY CROMWELL: What I was
thinking of, when I wrote

00:47:35.660 --> 00:47:39.010
that, was basically using the
string interpolation to define

00:47:39.010 --> 00:47:43.710
the templates like you would do
it in a Messages class in

00:47:43.710 --> 00:47:48.420
GWT and basically create the
equivalent of a Dart

00:47:48.420 --> 00:47:51.200
ResourceBundle but using
JSON structures.

00:47:51.200 --> 00:47:54.000
And then write in a little
utility library to basically

00:47:54.000 --> 00:47:56.710
perform the equivalent of what
gets code generated in GWT,

00:47:56.710 --> 00:48:00.540
which is to take the template
and basically apply the JSON

00:48:00.540 --> 00:48:02.596
to it to fill out
the template.

00:48:02.596 --> 00:48:03.610
Yeah, sorry.

00:48:03.610 --> 00:48:05.645
I probably should have fleshed
that out more.

00:48:05.645 --> 00:48:08.260
I probably ran out of time,
doing my slides.

00:48:08.260 --> 00:48:09.195
AUDIENCE: That's fine.

00:48:09.195 --> 00:48:13.060
And I'm looking for something a
little bit more formal with

00:48:13.060 --> 00:48:14.800
the Places and Activities.

00:48:14.800 --> 00:48:16.720
Is there something like
that planned for Dart?

00:48:16.720 --> 00:48:21.170
Or is it just like window.on
listening

00:48:21.170 --> 00:48:22.630
for that native event?

00:48:22.630 --> 00:48:24.690
RAY CROMWELL: Yeah I don't
know the answer to that.

00:48:24.690 --> 00:48:28.440
But I believe the Dart team is
working on rich object models.

00:48:28.440 --> 00:48:30.730
And they're probably looking
at MBC or MBP.

00:48:30.730 --> 00:48:32.334
Do you happen to know, Vijay?

00:48:32.334 --> 00:48:53.110
VIJAY:MENON: [INAUDIBLE]

00:48:53.110 --> 00:48:55.220
RAY CROMWELL: So just in case no
one heard that, they built

00:48:55.220 --> 00:48:57.670
a really nice application
called Swarm.

00:48:57.670 --> 00:48:59.510
And what they're doing is
they're taking the lessons

00:48:59.510 --> 00:49:02.470
learned from building that rich
UI and the way they've

00:49:02.470 --> 00:49:05.840
organized it and basically
trying to extract the

00:49:05.840 --> 00:49:08.320
libraries and the patterns out
of it that they're going to

00:49:08.320 --> 00:49:09.010
use for Dart.

00:49:09.010 --> 00:49:11.730
And so I don't think that
they have anything

00:49:11.730 --> 00:49:12.920
today that's concrete.

00:49:12.920 --> 00:49:18.730
But I do believe that-- because
Seth Ladd is heavily

00:49:18.730 --> 00:49:23.830
involved in interacting with
the community who's

00:49:23.830 --> 00:49:24.710
dealing with Dart.

00:49:24.710 --> 00:49:28.040
And Seth is a really big fan
of MBC and MBP stuff.

00:49:28.040 --> 00:49:31.050
So there probably will be
something that great.

00:49:31.050 --> 00:49:33.190
But sorry, I don't
know the answer.

00:49:33.190 --> 00:49:33.880
AUDIENCE: That's OK.

00:49:33.880 --> 00:49:35.480
Last question, I promise.

00:49:35.480 --> 00:49:38.930
When I last looked at Dart,
it said "Alpha" on it.

00:49:38.930 --> 00:49:42.110
Do we know when it's going
to be promoted?

00:49:42.110 --> 00:49:44.570
RAY CROMWELL: Is Lars
or Vijay here?

00:49:44.570 --> 00:49:46.120
Vijay, do you want
to take that?

00:49:46.120 --> 00:49:47.370
VIJAY MENON: [INAUDIBLE]

00:49:49.440 --> 00:49:50.000
RAY CROMWELL: I'll
just repeat you.

00:49:50.000 --> 00:49:53.395
VIJAY MENON: You can get an
official answer from Lars.

00:49:53.395 --> 00:49:54.645
[INAUDIBLE]

00:49:56.790 --> 00:49:57.760
RAY CROMWELL: Ah.

00:49:57.760 --> 00:50:00.090
VIJAY MENON: My understanding
is that later this year,

00:50:00.090 --> 00:50:03.357
there'll be more of an official
release, but I'm not

00:50:03.357 --> 00:50:05.340
exactly sure we've said
what the date is

00:50:05.340 --> 00:50:06.150
going to be on that.

00:50:06.150 --> 00:50:07.700
AUDIENCE: OK.

00:50:07.700 --> 00:50:08.600
RAY CROMWELL: So later this
year, there will be an

00:50:08.600 --> 00:50:09.160
official answer.

00:50:09.160 --> 00:50:11.400
But if you go talk to Lars,
just track him down--

00:50:11.400 --> 00:50:14.290
he's kind of a very tall
guy with glasses--

00:50:14.290 --> 00:50:16.000
he could probably give you
a more concrete answer.

00:50:16.000 --> 00:50:17.730
But I do believe, at least
from my own personal

00:50:17.730 --> 00:50:20.720
experience, the language spec
seems to be settling down very

00:50:20.720 --> 00:50:21.215
nicely now.

00:50:21.215 --> 00:50:23.170
And so it's probably
going to exit the

00:50:23.170 --> 00:50:25.450
Alpha phase very soon.

00:50:25.450 --> 00:50:25.710
AUDIENCE: Great.

00:50:25.710 --> 00:50:25.940
Thank you.

00:50:25.940 --> 00:50:27.130
RAY CROMWELL: But that shouldn't
dissuade you from

00:50:27.130 --> 00:50:28.200
trying it, right?

00:50:28.200 --> 00:50:30.180
Have some fun with it.

00:50:30.180 --> 00:50:30.860
VIJAY MENON: OK.

00:50:30.860 --> 00:50:31.360
Sorry.

00:50:31.360 --> 00:50:33.890
Just to add in-- we do have
teams in Google who are

00:50:33.890 --> 00:50:34.800
starting to use Dart.

00:50:34.800 --> 00:50:37.910
So even though we're still
working on it, it's pretty

00:50:37.910 --> 00:50:39.380
usable today.

00:50:39.380 --> 00:50:40.740
They wouldn't be using
it if it wasn't.

00:50:43.480 --> 00:50:43.965
AUDIENCE: Hi there.

00:50:43.965 --> 00:50:46.630
Are there any legs to the rumor
that GWT is looking for

00:50:46.630 --> 00:50:48.910
new intermediate language, and
that intermediate language

00:50:48.910 --> 00:50:52.850
might be Dart?

00:50:52.850 --> 00:50:53.810
RAY CROMWELL: Yeah, there's
nothing official.

00:50:53.810 --> 00:50:55.120
There's been some
talk about that.

00:50:55.120 --> 00:50:57.550
I know I've thought about it
personally, of building a Dart

00:50:57.550 --> 00:50:58.530
back end for GWT.

00:50:58.530 --> 00:51:04.440
So if and when Chrome actually
has the Dart VM built into it,

00:51:04.440 --> 00:51:06.430
it might be the case that
either one of two

00:51:06.430 --> 00:51:07.190
things might happen.

00:51:07.190 --> 00:51:10.300
Either someone might build a
back-end for GWT that emits

00:51:10.300 --> 00:51:12.890
Dart code, compiles the Dart,
just to take advantage of the

00:51:12.890 --> 00:51:15.490
speed and start-up time
improvements that the Dart VM

00:51:15.490 --> 00:51:16.810
will have over V8.

00:51:16.810 --> 00:51:18.680
The other option, actually, and
I think this is probably

00:51:18.680 --> 00:51:21.080
more likely, is that someone
will build a tool that

00:51:21.080 --> 00:51:25.500
actually will help migrate Java
code to Dart in case you

00:51:25.500 --> 00:51:28.430
want to basically port
some code over.

00:51:28.430 --> 00:51:30.750
There are some difficulties in
compiling GWT code to Dart

00:51:30.750 --> 00:51:32.080
because of JavaScript.

00:51:32.080 --> 00:51:36.320
So you can imagine, any large
GWT application at sort of the

00:51:36.320 --> 00:51:39.360
leaves of the program, deepest
down, is going to have JSNI

00:51:39.360 --> 00:51:40.910
method calls to deal
with the browser.

00:51:40.910 --> 00:51:44.210
And so those would have to be
replaced with the Dart library

00:51:44.210 --> 00:51:44.880
equivalents.

00:51:44.880 --> 00:51:48.740
So if someone's calling, like,
dom.getElementById, rather

00:51:48.740 --> 00:51:52.350
than making a JSNI call there,
which would have to use this

00:51:52.350 --> 00:51:54.640
hack, it would have to replace
it with the equivalent

00:51:54.640 --> 00:51:58.260
dart:html library and call
the actual Dart method.

00:51:58.260 --> 00:52:00.330
And it's certainly possible to
do that, but it would actually

00:52:00.330 --> 00:52:03.280
be a lot of mapping work.

00:52:03.280 --> 00:52:04.020
But yeah.

00:52:04.020 --> 00:52:05.080
We've talked about it.

00:52:05.080 --> 00:52:07.210
If I have nothing
official to say.

00:52:07.210 --> 00:52:09.820
AUDIENCE: Thank you.

00:52:09.820 --> 00:52:11.450
AUDIENCE: Do you think
there's going to--

00:52:11.450 --> 00:52:13.020
when they finally get
to release, will

00:52:13.020 --> 00:52:14.250
they have the widgets?

00:52:14.250 --> 00:52:18.960
And will they be similar to
what GWT has already?

00:52:18.960 --> 00:52:19.970
RAY CROMWELL: They
probably will be.

00:52:19.970 --> 00:52:21.900
So I don't know, actually, the
timeline on the widgets.

00:52:21.900 --> 00:52:24.840
But I know what their philosophy
and intention is.

00:52:24.840 --> 00:52:26.680
And so their philosophy and
intention is actually to

00:52:26.680 --> 00:52:29.260
deliver widgets that probably
go far beyond what GWT has.

00:52:29.260 --> 00:52:33.500
So GWT, when it started,
basically they wanted it to be

00:52:33.500 --> 00:52:34.460
more like JavaScript.

00:52:34.460 --> 00:52:36.115
We didn't want to be very
opinionated about what the

00:52:36.115 --> 00:52:38.740
widgets looked like, so the
first GWT widgets were very

00:52:38.740 --> 00:52:40.100
ugly out of the box.

00:52:40.100 --> 00:52:41.820
They didn't provide very
much styling at all.

00:52:41.820 --> 00:52:43.830
Later, we got some sense
knocked into us, and we

00:52:43.830 --> 00:52:45.720
realized most programmers
can't take the time to

00:52:45.720 --> 00:52:46.930
actually style all
their widgets.

00:52:46.930 --> 00:52:48.930
We should provide some default
that actually looks

00:52:48.930 --> 00:52:49.720
reasonable.

00:52:49.720 --> 00:52:50.620
And we did that.

00:52:50.620 --> 00:52:52.910
But still, it's nothing compared
to what Sencha has,

00:52:52.910 --> 00:52:53.480
for example.

00:52:53.480 --> 00:52:54.210
Right?

00:52:54.210 --> 00:52:56.340
And so that was probably
a mistake

00:52:56.340 --> 00:52:58.920
early in the GWT design.

00:52:58.920 --> 00:53:02.060
The Dart team, I think, is
eyeing the fact that people

00:53:02.060 --> 00:53:04.690
want to design apps and they
want to design them to be

00:53:04.690 --> 00:53:06.810
productive, and they want
to wow their consumers.

00:53:06.810 --> 00:53:08.600
And so you need not just
a widget library.

00:53:08.600 --> 00:53:10.890
You need a very sexy widget
library out of the box.

00:53:10.890 --> 00:53:14.450
And so they're actually aiming
to make something that's very

00:53:14.450 --> 00:53:15.660
lickable, something that
you're going to

00:53:15.660 --> 00:53:16.780
love out of the box.

00:53:16.780 --> 00:53:18.050
And it's going to be
very opinionated.

00:53:18.050 --> 00:53:20.970
So the slider widget is going
to look the way the Dart

00:53:20.970 --> 00:53:23.450
user-interface designer
wants it to look.

00:53:23.450 --> 00:53:25.290
And it might not look the way
you want it to look, but it's

00:53:25.290 --> 00:53:26.920
probably going to look
really sweet.

00:53:26.920 --> 00:53:29.210
And so that's basically what
they're looking at.

00:53:29.210 --> 00:53:32.384
Am I summarizing correctly,
Vijay?

00:53:32.384 --> 00:53:33.350
OK.

00:53:33.350 --> 00:53:35.210
I'm actually not part of the
Dart team, so I don't want to

00:53:35.210 --> 00:53:35.956
speak too much about it.

00:53:35.956 --> 00:53:38.050
But I overheard some
conversations.

00:53:38.050 --> 00:53:38.315
OK?

00:53:38.315 --> 00:53:39.140
You have another?

00:53:39.140 --> 00:53:42.990
AUDIENCE: Also, I've got a lot
of applications on App Engine.

00:53:42.990 --> 00:53:48.850
And is there a pattern or
something that I can use to

00:53:48.850 --> 00:53:50.492
migrate it to that?

00:53:50.492 --> 00:53:51.710
RAY CROMWELL: You're talking
about App Engine?

00:53:51.710 --> 00:53:54.410
AUDIENCE: App Engine using
RequestFactory.

00:53:54.410 --> 00:53:55.850
RAY CROMWELL: Oh, yeah.

00:53:55.850 --> 00:53:58.380
I actually was going to
discuss this in the

00:53:58.380 --> 00:54:00.690
presentation, but I realized
later I had too many slides

00:54:00.690 --> 00:54:01.540
and I ran out of time.

00:54:01.540 --> 00:54:05.110
But if you're using
RequestFactory, actually--

00:54:05.110 --> 00:54:05.870
I should take this offline.

00:54:05.870 --> 00:54:06.780
There's an extra bonus.

00:54:06.780 --> 00:54:09.580
Because RequestFactory's
JSON-based, it's very possible

00:54:09.580 --> 00:54:13.270
to make Dart client code work
with JSON RequestFactory stuff

00:54:13.270 --> 00:54:14.260
on the server.

00:54:14.260 --> 00:54:15.640
It's not true for GWT-RPC.

00:54:15.640 --> 00:54:18.680
GWT-RPC is very tightly tied
in to the Java type system.

00:54:18.680 --> 00:54:19.860
RequestFactory isn't.

00:54:19.860 --> 00:54:22.790
So actually, it's possible
to make a Dart code call

00:54:22.790 --> 00:54:25.170
server-side Java RequestFactory
code.

00:54:25.170 --> 00:54:29.090
And so maybe I can catch you
offline and discuss that.

00:54:29.090 --> 00:54:31.815
AUDIENCE: Thank you.

00:54:31.815 --> 00:54:32.250
AUDIENCE: OK.

00:54:32.250 --> 00:54:35.870
So my question would be about
GWT-RPC, so you already

00:54:35.870 --> 00:54:36.740
answered it.

00:54:36.740 --> 00:54:43.060
So there's some way to
invoke GWT-RPC calls?

00:54:43.060 --> 00:54:44.170
RAY CROMWELL: Yes.

00:54:44.170 --> 00:54:47.070
That would be kind of difficult
to pull off.

00:54:47.070 --> 00:54:49.810
I could see you constructing
something that would invoke

00:54:49.810 --> 00:54:53.460
it, but I would see it being
hard to actually deal with the

00:54:53.460 --> 00:54:54.620
return value.

00:54:54.620 --> 00:55:00.690
So there are Android clients
that actually invoke GWT-RPC

00:55:00.690 --> 00:55:03.680
because Android also is Java, so
they can deal with the fact

00:55:03.680 --> 00:55:05.740
that when the return value comes
back and it says, like,

00:55:05.740 --> 00:55:09.480
it's an array list of doubles or
something, the classes for

00:55:09.480 --> 00:55:11.800
decoding an array list of
doubles are already present in

00:55:11.800 --> 00:55:13.630
the runtime of Dalvik, right?

00:55:13.630 --> 00:55:16.720
With Dart, if you invoke some
server-side call and you get

00:55:16.720 --> 00:55:20.600
back an array of things that are
Java types, right, there's

00:55:20.600 --> 00:55:22.900
not necessarily something to
map to decode those and

00:55:22.900 --> 00:55:25.130
demarshal them into
on the Dart side.

00:55:25.130 --> 00:55:26.210
So it's a little
more difficult.

00:55:26.210 --> 00:55:28.740
But invoking I could see.

00:55:28.740 --> 00:55:31.180
As long as your API actually
uses mostly primitive things,

00:55:31.180 --> 00:55:34.160
like longs, and integers, and
strings, and so on, or maybe

00:55:34.160 --> 00:55:36.840
POJOs, I think you could
pull it off.

00:55:36.840 --> 00:55:39.085
But if you catch me outside, I
might have some suggestions.

00:55:39.085 --> 00:55:39.400
AUDIENCE: OK.

00:55:39.400 --> 00:55:39.851
Cool.

00:55:39.851 --> 00:55:42.110
Thanks.

00:55:42.110 --> 00:55:43.154
RAY CROMWELL: OK.

00:55:43.154 --> 00:55:44.810
AUDIENCE: Hello?

00:55:44.810 --> 00:55:45.560
At [INAUDIBLE]

00:55:45.560 --> 00:55:46.630
Google our [INAUDIBLE]

00:55:46.630 --> 00:55:49.900
we have many talks about Google
Web Toolkit and we have

00:55:49.900 --> 00:55:53.870
a separate section in
developers' handbooks about

00:55:53.870 --> 00:55:55.210
Google Web Toolkit.

00:55:55.210 --> 00:55:58.580
And now it seems [INAUDIBLE]

00:55:58.580 --> 00:56:02.280
session, which mentioned
Google Web Toolkit.

00:56:02.280 --> 00:56:06.795
So I want to ask,
is GWT is dead?

00:56:06.795 --> 00:56:08.130
RAY CROMWELL: No.

00:56:08.130 --> 00:56:09.960
I been asked this
question a lot.

00:56:09.960 --> 00:56:15.700
And if you look at Google, for
example, a lot of Google's top

00:56:15.700 --> 00:56:17.280
properties, actually,
like AdWords--

00:56:17.280 --> 00:56:21.240
97% of their revenue comes
from the AdWords team.

00:56:21.240 --> 00:56:24.050
And AdWords uses GWT for their
campaign management tool.

00:56:24.050 --> 00:56:26.820
And so it's impractical for us
to say that GWT was dead,

00:56:26.820 --> 00:56:28.010
first of all.

00:56:28.010 --> 00:56:31.010
Second of all, Google
is about choice.

00:56:31.010 --> 00:56:32.070
The company's about choice.

00:56:32.070 --> 00:56:32.960
You know, App Engine,
for example.

00:56:32.960 --> 00:56:34.630
We offer Java.

00:56:34.630 --> 00:56:36.830
We offer Go.

00:56:36.830 --> 00:56:37.860
We offer Python.

00:56:37.860 --> 00:56:39.920
Well, we released Go
recently, right?

00:56:39.920 --> 00:56:42.010
Does that mean that Guido van
Rossum is out of a job and

00:56:42.010 --> 00:56:42.810
Python is dead?

00:56:42.810 --> 00:56:43.370
No.

00:56:43.370 --> 00:56:45.530
It just means that there's
another option for developers.

00:56:45.530 --> 00:56:48.350
And so what I would say for GWT
is that we're not going to

00:56:48.350 --> 00:56:49.730
take GWT away from you.

00:56:49.730 --> 00:56:52.140
And we're still going to support
JavaScript development

00:56:52.140 --> 00:56:56.480
for V8, and we're still going
to support GWT development.

00:56:56.480 --> 00:56:59.220
But we're also offering this new
option that might entice

00:56:59.220 --> 00:57:01.550
some people, maybe some people
who don't like JavaScript.

00:57:01.550 --> 00:57:03.650
Or maybe they're people who like
JavaScript, but they want

00:57:03.650 --> 00:57:04.810
better tools for JavaScript.

00:57:04.810 --> 00:57:07.170
They want a really nice
IDE for something

00:57:07.170 --> 00:57:08.010
that's a dynamic language.

00:57:08.010 --> 00:57:09.170
There's Dart for you.

00:57:09.170 --> 00:57:12.540
Or maybe they like Java, but
maybe they're getting tired of

00:57:12.540 --> 00:57:13.590
doing enterprise apps.

00:57:13.590 --> 00:57:17.450
So nothing's changing
with GWT.

00:57:17.450 --> 00:57:20.590
In fact, if you attend my
session on Friday, there is

00:57:20.590 --> 00:57:23.360
actually some nice news that's
going to be announced with

00:57:23.360 --> 00:57:26.406
respect to GWT's future.

00:57:26.406 --> 00:57:28.760
AUDIENCE: OK.

00:57:28.760 --> 00:57:31.410
RAY CROMWELL: Anything else?

00:57:31.410 --> 00:57:31.740
OK.

00:57:31.740 --> 00:57:33.230
Thanks for coming, and--

00:57:33.230 --> 00:57:37.110
[APPLAUSE]

00:57:37.110 --> 00:57:38.080
RAY CROMWELL: You're welcome.

00:57:38.080 --> 00:57:41.000
Be safe on your way down rushing
to get your devices.

00:57:41.000 --> 00:57:42.250
Don't trip and fall.

