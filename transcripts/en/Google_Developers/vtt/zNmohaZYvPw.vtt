WEBVTT
Kind: captions
Language: en

00:00:14.240 --> 00:00:15.240
Google I/O
19 May 2010

00:00:15.240 --> 00:00:16.240
Android
Casting a Wide Net: How to Target All Android

00:00:16.240 --> 00:00:17.240
Devices

00:00:17.240 --> 00:00:19.200
&gt;&gt;Justin Mattson: So good afternoon, everyone.
Thanks, everyone, for coming.

00:00:19.200 --> 00:00:24.650
My name is Justin Mattson. I'm a developer
advocate, working at Google, where I have

00:00:24.650 --> 00:00:29.060
been for the last about four years. And for
the last two years of that, I have been working

00:00:29.060 --> 00:00:36.120
on the Android project, which is hopefully
what all you are here to hear me speak about.

00:00:36.120 --> 00:00:42.210
And so the last two years on Android has been
really exciting, really crazy.

00:00:42.210 --> 00:00:49.360
I expect it to get crazier and more exciting
as time goes on because that's all that happened.

00:00:49.360 --> 00:00:54.740
And part of that excitement and craziness
has been the fact that if we go back two years

00:00:54.740 --> 00:01:01.369
ago, Android was a software development kit
and an emulator.

00:01:01.369 --> 00:01:06.500
Fast forward two years to today, and you can
go out on the show floor and see around 50

00:01:06.500 --> 00:01:13.990
devices from a variety of manufacturers, running
on a variety of carriers around the world.

00:01:13.990 --> 00:01:19.719
What that means is we have had an explosion
in the number of form factors and screens

00:01:19.719 --> 00:01:25.650
and configurations that are out there, which
is really awesome, because Android has become

00:01:25.650 --> 00:01:32.200
the optimal device for millions and millions
of users across the world.

00:01:32.200 --> 00:01:37.259
Millions and millions of users that you can
now reach as developers for Android.

00:01:37.259 --> 00:01:42.869
The other side of that, of course, is a challenge.
These devices are different. They run different

00:01:42.869 --> 00:01:50.179
versions of Android. They have different screens.
So how can you, as developers, meet this challenge?

00:01:50.179 --> 00:01:57.149
And that's what we're here to talk about today.
So a little housekeeping before we really

00:01:57.149 --> 00:02:02.939
get into the main goal. As with the other
sessions, we're using Wave to both take notes

00:02:02.939 --> 00:02:07.939
as well as discuss the presentation as it's
going on. If you would like to participate

00:02:07.939 --> 00:02:14.560
in the Wave in any of these capacities, please
go to tinyurl.com/iocasting or scan the QR

00:02:14.560 --> 00:02:21.350
code but be quick about it because I have
to keep moving.

00:02:21.350 --> 00:02:27.770
So as I was saying, there's a huge opportunity
out there to reach a very large number of

00:02:27.770 --> 00:02:35.440
users. And in order to realize that opportunity,
you have to meet a challenge which is running

00:02:35.440 --> 00:02:39.860
across all of these devices.
The good news I am here to tell you today

00:02:39.860 --> 00:02:44.850
is that meeting that challenge is not that
hard.

00:02:44.850 --> 00:02:50.200
So I want to go over a set of considerations,
as you are building your Android applications,

00:02:50.200 --> 00:02:55.810
that will give you a strong foundation for
running well across all devices in the Android

00:02:55.810 --> 00:03:00.390
universe today.
And when I think about this task, I think

00:03:00.390 --> 00:03:07.910
about it in two vectors. The first vector
is screen or UI compatibility, so we will

00:03:07.910 --> 00:03:14.330
talk about that first, and mainly that has
to deal with the way you are creating layouts

00:03:14.330 --> 00:03:19.670
and drawables for your project. And underlying
the layouts and drawables that you will use

00:03:19.670 --> 00:03:24.420
for your project is the resource system which
is the foundation to build on and what I'll

00:03:24.420 --> 00:03:28.710
talk about first.
The second vector of compatibility that I

00:03:28.710 --> 00:03:35.300
think about is API-level compatibility. So
this means what APIs are available to you

00:03:35.300 --> 00:03:42.310
as a developer from the Android system.
So I'm not going to talk about specific APIs

00:03:42.310 --> 00:03:49.260
that are or are not available, but I will
talk to you about how to figure out what you

00:03:49.260 --> 00:03:54.010
have available and then how to adapt your
program behavior based on that.

00:03:54.010 --> 00:03:59.870
And finally, a word about testing because
I am talking about running on many, many devices,

00:03:59.870 --> 00:04:05.820
and testing is going to be essential.
But I am also do a little preview in saying

00:04:05.820 --> 00:04:14.711
you don't have to have all of those devices.
In this first vector of screen or UI compatibility

00:04:14.711 --> 00:04:19.631
that I am talking about I first need to talk
about the resource system.

00:04:19.631 --> 00:04:26.680
Now, the resource system might be something
that many of you are familiar with but I really

00:04:26.680 --> 00:04:31.509
want to cover this because it's essential
as the basis for building a compatible Android

00:04:31.509 --> 00:04:35.460
application.
So the resource loading system is there to

00:04:35.460 --> 00:04:38.830
help you out.
It is there to load the resources that are

00:04:38.830 --> 00:04:45.020
most appropriate for the current device configuration
that your application is running on.

00:04:45.020 --> 00:04:50.219
So the question is, how does it pick those
resources? It picks those resources based

00:04:50.219 --> 00:04:56.290
on a number of qualifiers. And these qualifiers
you use to label your bundles of resources

00:04:56.290 --> 00:05:02.680
so the system can find them.
So I will refer to these resources as bundles

00:05:02.680 --> 00:05:08.110
of resources or directories that live within
the resource directory of your project interchangeably.

00:05:08.110 --> 00:05:15.340
So the other thing to realize is that the
configuration of your device can change while

00:05:15.340 --> 00:05:21.210
your application is running. And if so, the
system is going to restart your process in

00:05:21.210 --> 00:05:26.980
order so that the resource system can provide
all the new graphics and strings and everything

00:05:26.980 --> 00:05:30.710
that you need.
A resource configuration change might come

00:05:30.710 --> 00:05:33.800
in a number of forms, and I will mention one
of those a little bit later.

00:05:33.800 --> 00:05:43.129
So I mentioned resources are specified by
some qualifiers that correspond to attributes

00:05:43.129 --> 00:05:48.810
of the configuration of your system. And what
I want to do is go through a few of these

00:05:48.810 --> 00:05:57.560
that are really important for this first vector
of screen or UI compatibility.

00:05:57.560 --> 00:06:02.800
The first qualifier is screen size. And what
do I mean when I say screen size? By screen

00:06:02.800 --> 00:06:07.830
size, I mean actual physical dimension of
the screen that your application is running

00:06:07.830 --> 00:06:15.409
on, not something like, say, screen resolution.
And types of resources that are most concerned

00:06:15.409 --> 00:06:21.620
with screen size are typically things like
layouts, because if you have more physical

00:06:21.620 --> 00:06:27.509
space on your screen, you may choose to include
different UI elements or arrange them in a

00:06:27.509 --> 00:06:32.120
different way.
Now, for Android devices out there, there

00:06:32.120 --> 00:06:38.229
are actually many, many different screen sizes.
Some differ only by a tenth of an inch, and

00:06:38.229 --> 00:06:43.710
these small differences aren't all that consequential
most of the time. So Android asks you not

00:06:43.710 --> 00:06:49.979
to consider every individual screen size but,
rather, different buckets. And by focusing

00:06:49.979 --> 00:06:55.569
on this much smaller set of different buckets,
you will greatly simplify the task of pick

00:06:55.569 --> 00:07:01.629
being layouts that make sense for these different
screens.

00:07:01.629 --> 00:07:06.650
The second qualifier to talk about is screen
orientation. You might also think of it as

00:07:06.650 --> 00:07:12.240
aspect ratio.
So this is, is your screen wider or taller?

00:07:12.240 --> 00:07:16.479
And pretty obviously, you know, the types
of resources that are concerned with this

00:07:16.479 --> 00:07:21.979
are layouts. Sometimes drawable resources
like images that you will include, but more

00:07:21.979 --> 00:07:27.650
often than not, layouts.
And I mentioned before that the configuration

00:07:27.650 --> 00:07:33.919
of a system can change while your application
is running. Orientation is one of those configuration

00:07:33.919 --> 00:07:41.089
parameters that is actually pretty likely
to change. And who has tried to stop the system

00:07:41.089 --> 00:07:47.330
from killing their application when the orientation
changes?

00:07:47.330 --> 00:07:52.800
Okay. I think more of you have probably tried
to do this, but don't do this. The system

00:07:52.800 --> 00:07:58.139
is doing this for your own good. Because otherwise,
you have to figure out what are all the different

00:07:58.139 --> 00:08:05.740
resources that you should load.
And so a change in screen orientation might

00:08:05.740 --> 00:08:10.610
be triggered by a hardware change, like a
user flips out a keyboard on the G1 or the

00:08:10.610 --> 00:08:18.130
Droid, or it might be the result of an accelerometer
event. You know, the sensors detect that the

00:08:18.130 --> 00:08:23.330
screen orientation has changed.
And then when your app restarts, it gets this

00:08:23.330 --> 00:08:29.419
opportunity to load the optimized layout for
the new configuration. So don't disable it.

00:08:29.419 --> 00:08:36.409
Work with it, not against the system. The
system is probably going to win.

00:08:36.409 --> 00:08:42.120
And the third qualifier I want to talk about
is screen density, which is the other attribute

00:08:42.120 --> 00:08:49.061
of a screen that we are interested in. And
quite simply, density is the number of pixels

00:08:49.061 --> 00:08:55.900
per whatever unit of measure you want to use.
Now, notably, the density qualifier works

00:08:55.900 --> 00:09:01.660
differently than the previous two qualifiers
that I mentioned. Instead of being an exact-match

00:09:01.660 --> 00:09:07.190
system, the density qualifier system works
on inexact matches. The system attempts to

00:09:07.190 --> 00:09:15.620
find a best fit for the existing configuration.
And for best fit, the Android system asks

00:09:15.620 --> 00:09:20.930
to you construct three sets of resources at
this point, resources for low density, medium

00:09:20.930 --> 00:09:26.300
density, and high density screens. And the
types of resources you are most apt to create

00:09:26.300 --> 00:09:32.490
customized versions with are the drawable
resources, the images that are going to be

00:09:32.490 --> 00:09:38.050
rendered to the screen.
And so what does "best fit" in this case mean?

00:09:38.050 --> 00:09:46.250
Well, best fit was designed to mean the density
qualifier that is closest to the actual screen

00:09:46.250 --> 00:09:52.690
density that the app is being run on, and
the one that the system thinks will look best.

00:09:52.690 --> 00:10:00.550
When talking about this qualifier, it's important
to note a critical bug in Android 1.5 with

00:10:00.550 --> 00:10:08.860
respect to this qualifier, and that is the
fact that Android 1.5, unlike the design says,

00:10:08.860 --> 00:10:15.569
selects the first match for the density qualifier
instead of the best match.

00:10:15.569 --> 00:10:20.400
So if you are running on a medium density
screen, this might be the bundle of drawables

00:10:20.400 --> 00:10:24.540
that is selected by the system to be displayed,
and then the system is going to scale all

00:10:24.540 --> 00:10:30.360
of these. And if they are high density resources,
it will have to down sample.

00:10:30.360 --> 00:10:35.589
So this is quite simply a bug, but then you
would ask, well, what is the order of resources

00:10:35.589 --> 00:10:41.259
in the bundle? And this is determined by the
way the packaging tool packaged up the actual

00:10:41.259 --> 00:10:47.850
application binary. And what the packaging
tool puts in the binary first is going to

00:10:47.850 --> 00:10:54.470
be determined by the order in which the host
operating system of the packaging tool listed

00:10:54.470 --> 00:11:01.050
the resources directory to it.
Now, unfortunately, different operating systems

00:11:01.050 --> 00:11:06.820
list things differently. And it's not actually
even guaranteed that two runs on the same

00:11:06.820 --> 00:11:13.450
operating system will produce the same results.
So the take-away here is that if you provide

00:11:13.450 --> 00:11:20.750
these customized resources and support Android
1.5, the way that the density qualifier works

00:11:20.750 --> 00:11:27.200
is completely indeterminate.
There is a way out of this problem which is

00:11:27.200 --> 00:11:33.790
going to bring us to the version qualifier.
So before we go over how you can use the version

00:11:33.790 --> 00:11:40.440
qualifier to fix the previous issue, let me
describe how it works.

00:11:40.440 --> 00:11:44.550
And why you might care about it.
So independently of the great things it can

00:11:44.550 --> 00:11:51.300
do to work around this other bug, the version
qualifier is most useful if you are trying

00:11:51.300 --> 00:11:57.000
to adapt to different styles presented by
different versions of the operating system.

00:11:57.000 --> 00:12:04.339
So between Android 1.6 and 2.0, for example,
the default look of icons on the home screen

00:12:04.339 --> 00:12:12.990
changed from being sort of three dimensional,
as you can see on the right, as opposed -- and

00:12:12.990 --> 00:12:20.930
went to being more flatter, more one dimensional
in 2.0, as you can see on the left.

00:12:20.930 --> 00:12:24.930
And also, over time, you might imagine that
some sort of layout conventions change as

00:12:24.930 --> 00:12:30.790
well, so you might decide to include custom
layouts and custom drawables for later or

00:12:30.790 --> 00:12:37.540
earlier versions of the system.
Now, similar to the way the density qualifier

00:12:37.540 --> 00:12:46.720
works, the version qualifier uses a best match
approach that is basically an inequality.

00:12:46.720 --> 00:12:53.480
And the inequality says the best match will
be the version qualifier that is closest to

00:12:53.480 --> 00:13:01.769
my own without exceeding it. So if you are
running on Android 2.0, which is version 5

00:13:01.769 --> 00:13:09.420
of the operating system, and it sees a version
3 directory and nothing higher between three

00:13:09.420 --> 00:13:14.440
and five, it will consider that a match. But
if there's a version 6 directory, that will

00:13:14.440 --> 00:13:19.399
not be a match since it exceeds the current
SDK version of the system it is running on.

00:13:19.399 --> 00:13:27.850
Now, two more small items before we talk about
how you can use this to work around the density

00:13:27.850 --> 00:13:36.430
qualifier problems, is that the version qualifier
has bugs of its own.

00:13:36.430 --> 00:13:44.910
So on Android 1.5 through 2.0, the version
qualifier does exact matching instead of inexact

00:13:44.910 --> 00:13:52.560
matching. So Android 1.6, which is version
4 of the operating system, will not consider

00:13:52.560 --> 00:14:01.160
the V3 directory a match. It will look only
for V4 or, of course, an unqualified resource

00:14:01.160 --> 00:14:04.220
directory.
The second thing to be aware of is Android

00:14:04.220 --> 00:14:10.279
2.0 thinks -- The resource system in Android
2.0 thinks that it's version 6.

00:14:10.279 --> 00:14:17.600
So 2.0.1 which actually is version 6 also
thinks it's version 6. So for the resource

00:14:17.600 --> 00:14:25.080
system, essentially version 5 never happened.
Now, happily, 2.0.1 and above, these bugs

00:14:25.080 --> 00:14:30.329
are fixed. Everything works great.
So with these caveats in mind, how can we

00:14:30.329 --> 00:14:37.320
get to our goal of having the right assets
selected for Android 1.5 and the medium density

00:14:37.320 --> 00:14:42.920
screens that it runs on?
So we can do this. Or this is the beginning

00:14:42.920 --> 00:14:49.300
of the solution, anyway. We have our medium
density resources and we know Android 1.5

00:14:49.300 --> 00:14:55.920
is only ever going to run on a medium density
screen. We will have our medium density resources

00:14:55.920 --> 00:15:00.790
and suffix them with V3.
So we know for sure this directory is going

00:15:00.790 --> 00:15:05.899
to be picked by Android 1.5 now.
And actually, were it not for these two bugs

00:15:05.899 --> 00:15:14.279
that I was just talking about, we'd be done.
But now there's an issue because version 4

00:15:14.279 --> 00:15:19.319
and version 5 of the platform are not going
to select this directory, and with the structure

00:15:19.319 --> 00:15:24.889
that I have listed here, they actually will
then use the low density or the high density

00:15:24.889 --> 00:15:32.279
resources. In order to get around this, we
need to make a copy of the medium density

00:15:32.279 --> 00:15:35.310
resources.
And as long as our medium density resources

00:15:35.310 --> 00:15:41.000
are actually the same across all of the versus
of the platform, we're done. If you want to

00:15:41.000 --> 00:15:46.290
include more customized resources for different
versions, it gets a little more complicated.

00:15:46.290 --> 00:15:50.759
I am not going to go over that, but applying
the rules and caveats that I have described

00:15:50.759 --> 00:15:57.620
here makes it pretty straightforward.
So unfortunately, to support optimized drawables

00:15:57.620 --> 00:16:03.140
across all versions of the platform, you need
some resource duplication that's going to

00:16:03.140 --> 00:16:13.430
inflate the size of your application package.
But that should give you a pretty complete

00:16:13.430 --> 00:16:18.680
overview of the parts of the resource system
that you need to consider for this first vector

00:16:18.680 --> 00:16:23.569
of UI or screen compatibility that I have
been talking about.

00:16:23.569 --> 00:16:28.790
And now that we understand that, I want to
move on and build on that and talk about how

00:16:28.790 --> 00:16:34.629
some specific types of resources are handled.
The specific type that I want to cover is

00:16:34.629 --> 00:16:46.730
image resources, because a large part of many
people's applications out there involve images.

00:16:46.730 --> 00:16:52.379
So it's important first to understand what
Android is trying to do with image resources,

00:16:52.379 --> 00:16:55.199
and what the resource system is trying to
accomplish.

00:16:55.199 --> 00:17:02.350
And that goal is that images -- bitmaps that
you include should be displayed as the same

00:17:02.350 --> 00:17:10.230
physical size across all devices out there,
regardless of the screen configuration.

00:17:10.230 --> 00:17:15.860
And this is great, because that means if you
define your image view to take a certain number

00:17:15.860 --> 00:17:20.280
of density independent pixels, the system
is going to take care of all this math and

00:17:20.280 --> 00:17:25.490
everything for you to figure out how many
actual pixels on the screen that view to take

00:17:25.490 --> 00:17:32.640
up.
Now, a secondary consideration is whether

00:17:32.640 --> 00:17:39.100
or not you want to include optimized resources
for every density bucket that's out there.

00:17:39.100 --> 00:17:43.659
And for some types of images, this may not
actually be necessary.

00:17:43.659 --> 00:17:48.770
If you have low-complexity things, like a
square or a circle or something like that

00:17:48.770 --> 00:17:53.380
that's going to scale pretty well, it might
not be worth the extra application package

00:17:53.380 --> 00:17:57.320
size.
But for other images that have a greater deal

00:17:57.320 --> 00:18:04.230
of complexity or convey information based
on one or two pixels, it's really going to

00:18:04.230 --> 00:18:10.059
be worth it to you to include optimized versions
and take that extra time in the prebuild process.

00:18:10.059 --> 00:18:16.320
And to illustrate that, I want to walk through
how the system might handle scaling in this

00:18:16.320 --> 00:18:25.280
case.
So let's say I've included this nice image

00:18:25.280 --> 00:18:30.450
resource, very sophisticated and pretty, along
with my application package.

00:18:30.450 --> 00:18:37.190
So I've got a smiley face, and I've rendered
him here on my representative medium-density

00:18:37.190 --> 00:18:41.659
pixel grid.
Let's say this is the only resource that I've

00:18:41.659 --> 00:18:47.200
include- -- the only version of this resource
that I've included with my application.

00:18:47.200 --> 00:18:52.710
But what happens if then the application is
actually run on a low-density screen?

00:18:52.710 --> 00:18:55.159
So in the middle here, I have a low-density
pixel grid.

00:18:55.159 --> 00:18:59.840
And what I've done is overlaid the medium-density
pixels on it, and then tried to make some

00:18:59.840 --> 00:19:03.880
guesses about the pixels that would be chosen
to be colored in.

00:19:03.880 --> 00:19:06.809
This is essentially your sampling algorithm;
right?

00:19:06.809 --> 00:19:13.100
So you can see the choices that I've made
here with my pretty simplistic sampling algorithm.

00:19:13.100 --> 00:19:18.160
While they still convey the overall character
of the image, there's a significant loss of

00:19:18.160 --> 00:19:23.190
fidelity.
And the other thing I want to do is select

00:19:23.190 --> 00:19:28.320
a slightly different sampling algorithm.
And you can see that the fidelity lost here

00:19:28.320 --> 00:19:32.360
is actually much greater.
Now, neither of these really represent what

00:19:32.360 --> 00:19:36.360
the system does.
But the point that I want to get across is

00:19:36.360 --> 00:19:42.890
that what sort of fidelity is retained is
highly dependent on the sophistication of

00:19:42.890 --> 00:19:47.820
the sampling algorithm, and also that even
with the best of intentions, there's only

00:19:47.820 --> 00:19:53.309
so much that the system can do with a limited
number of pixels.

00:19:53.309 --> 00:19:58.900
And, finally, the other part of this is that
you can see that parts of this image, like

00:19:58.900 --> 00:20:03.429
the curves of the face or the nose that are
dependent on just a couple of pixels are the

00:20:03.429 --> 00:20:08.450
ones that have been impacted most greatly.
Whereas the sides of the face and, you know,

00:20:08.450 --> 00:20:12.660
the ears have more or less retained their
character across, you know, all decisions

00:20:12.660 --> 00:20:22.409
here, 'cause they're dependent on a greater
number of pixels to convey information.

00:20:22.409 --> 00:20:27.470
So that's what will happen if you don't, you
know, interfere with the system and the way

00:20:27.470 --> 00:20:32.059
it loads images in any way.
It will, you know, rescale these things for

00:20:32.059 --> 00:20:36.200
you.
But let's say you want to manipulate what

00:20:36.200 --> 00:20:39.620
the system does by default.
Well, are you really sure that you want to

00:20:39.620 --> 00:20:41.910
do this?
You probably shouldn't do this.

00:20:41.910 --> 00:20:47.950
You know, please, unless you're really, really
sure, just let the system do what was it was

00:20:47.950 --> 00:20:54.039
designed to do and help you out.
But if you must, let's talk about breaking

00:20:54.039 --> 00:20:59.399
the rules.
So the first thing to understand of how to

00:20:59.399 --> 00:21:06.770
break the rules is what the rules are by default.
So by default, when resources are being loaded,

00:21:06.770 --> 00:21:12.460
you -- and you grab a BitmapFactory object,
for example, and say, create a bitmap out

00:21:12.460 --> 00:21:19.649
of this resource or this URI or something,
and provide no BitmapFactory options object,

00:21:19.649 --> 00:21:25.559
the BitmapFactory options will be set to their
defaults, which are something like this.

00:21:25.559 --> 00:21:31.201
And we're concerned with two of the options.
The input density and the input target density.

00:21:31.201 --> 00:21:39.000
So the input density is the density that the
system believes the resource was designed

00:21:39.000 --> 00:21:43.110
for.
So if it plucks a resource out of the medium-density

00:21:43.110 --> 00:21:47.559
drawable folder, it's going to assume that
this was intended for medium density.

00:21:47.559 --> 00:21:54.520
And then the end target density is the density
of the screen that this input is targeted

00:21:54.520 --> 00:21:59.519
to be displayed on.
So, typically, the screen on the phone.

00:21:59.519 --> 00:22:03.380
And then whether or not the system is going
to scale this when it's rendered on the screen

00:22:03.380 --> 00:22:08.649
is dependent on the ratio between these two
values.

00:22:08.649 --> 00:22:14.279
So, obviously, if you want to get around this,
what you can do is provide your own -- your

00:22:14.279 --> 00:22:23.559
own bitmap options object and set the in density
equal to the in target density equal to the

00:22:23.559 --> 00:22:25.990
density of the screen that you're running
on.

00:22:25.990 --> 00:22:31.020
And, basically, this will help you in those
couple of situations -- and there really aren't

00:22:31.020 --> 00:22:37.169
very many -- where you want to override the
system's default behavior and, you know, really

00:22:37.169 --> 00:22:42.120
render your image pixel for pixel.
And the result in my previous example here

00:22:42.120 --> 00:22:48.649
was that I wouldn't have gotten any of these
scaling effects, but it's going to take up

00:22:48.649 --> 00:22:54.899
a larger portion of the screen because I'm
taking up the same number of larger pixels,

00:22:54.899 --> 00:22:58.530
which, as I said, generally isn't what you
want to do.

00:22:58.530 --> 00:23:04.410
So Nine-Patches.
Who's used Nine-Patches?

00:23:04.410 --> 00:23:11.549
Who wants to use Nine-Patches and doesn't
understand them?

00:23:11.549 --> 00:23:13.190
Okay.
A few people.

00:23:13.190 --> 00:23:19.919
And so Nine-Patches are a really powerful
type of image resource.

00:23:19.919 --> 00:23:25.630
And, basically, what they do is take your
base image resource and layer some information

00:23:25.630 --> 00:23:29.130
on top of it.
And the purpose of these things is so you

00:23:29.130 --> 00:23:36.410
can include fewer drawables in your package.
Because the bit of information that you're

00:23:36.410 --> 00:23:42.670
layering on top instructs the system how to
scale and manipulate this image so that it

00:23:42.670 --> 00:23:48.190
can fit larger or smaller sizes than it's
currently designed for.

00:23:48.190 --> 00:23:52.850
So I'd really like to go over these.
Unfortunately, my desire to do this is not

00:23:52.850 --> 00:23:57.059
sufficient to allow me to do so, because I
don't have time.

00:23:57.059 --> 00:24:07.010
So we're going to go through it really quick.
Pay attention.

00:24:07.010 --> 00:24:09.330
Nine-Patches.
So that's how they work.

00:24:09.330 --> 00:24:11.980
They're really great.
You should look into them.

00:24:11.980 --> 00:24:18.279
And I'm -- will try to get these slides that
I didn't talk about at all up as soon as possible

00:24:18.279 --> 00:24:23.179
with greater descriptions so they will be
useful.

00:24:23.179 --> 00:24:29.470
Okay.
So I -- really, I spent a lot of time on these

00:24:29.470 --> 00:24:35.740
graphics, because I'm not a graphic designer.
And I had to cut them out.

00:24:35.740 --> 00:24:40.059
So I've been talking about images and bitmaps
and things like that.

00:24:40.059 --> 00:24:45.720
And so now I want to step back a bit and talk
about drawables in general.

00:24:45.720 --> 00:24:51.840
So the bitmap resources that you include with
your package are one of the things that's

00:24:51.840 --> 00:24:55.610
drawn to the screen.
But drawables are a broader class and are,

00:24:55.610 --> 00:25:02.000
quite simply, anything that knows how to render
itself to the screen.

00:25:02.000 --> 00:25:07.460
So in talking about drawables, I want to bring
forward some classes that can help you out

00:25:07.460 --> 00:25:13.620
when you're writing your application, can
help you draw a user interface that is better

00:25:13.620 --> 00:25:18.840
optimized to the screen that you're running
on, allows you to have a smaller application

00:25:18.840 --> 00:25:24.980
package size, reduce the amount of work that
you'll need to do when creating your package,

00:25:24.980 --> 00:25:32.980
and generally make everyone happy.
So this is, you know, sort of a tips and tricks

00:25:32.980 --> 00:25:35.140
section.
And the first type of drawable that I want

00:25:35.140 --> 00:25:39.649
to talk about is shapes.
Maybe some of you are thinking, shapes.

00:25:39.649 --> 00:25:40.971
My God.
They're so basic.

00:25:40.971 --> 00:25:48.899
Why do we want to talk about shapes?
Well, shapes are great, because they're classes

00:25:48.899 --> 00:25:56.269
that know how to draw simple graphics primitives
to the screen, like a circle or a rectangle

00:25:56.269 --> 00:26:02.000
or the special rectangle, a square.
And what's great about these is that you can

00:26:02.000 --> 00:26:06.690
use them in a couple of ways.
First of all, I've unzipped developers' applications

00:26:06.690 --> 00:26:13.260
before to find that they've included a number
of drawables which are merely colored circles

00:26:13.260 --> 00:26:18.019
or colored squares, things like this, and
for no reason, they made their application

00:26:18.019 --> 00:26:23.260
larger, when they should have just used shape
drawable.

00:26:23.260 --> 00:26:28.809
And the second thing is that it's pretty common
to want to form a composite type of drawable

00:26:28.809 --> 00:26:34.669
where you're using some basic shape and then
actually some custom drawable, maybe like

00:26:34.669 --> 00:26:39.149
a company logo that you want to include on
some different colored fields or something

00:26:39.149 --> 00:26:42.720
like this.
So instead of having to go through the work

00:26:42.720 --> 00:26:47.190
at the beginning to create these, you can
use shapes at run time to draw great-looking

00:26:47.190 --> 00:26:53.429
versions on the screen.
And this is really facilitated by the shape

00:26:53.429 --> 00:26:59.150
classes, because they have this handy draw
method to help you in building a custom view.

00:26:59.150 --> 00:27:05.950
And if you were going to build a custom view,
like, one that rendered my little Google I/O

00:27:05.950 --> 00:27:10.340
logo there on a green rectangle, you might
do it something like this.

00:27:10.340 --> 00:27:19.559
So the first thing that this view class is
doing is creating a new rectangle shape.

00:27:19.559 --> 00:27:26.840
And then in the constructor, I'm grabbing
this logo from my applications resources.

00:27:26.840 --> 00:27:32.340
And then when it comes time to actually draw
my view, render it to screen, I'm first telling

00:27:32.340 --> 00:27:38.260
the shape what size it needs to be.
And then handing it the Canvas that my view

00:27:38.260 --> 00:27:42.230
was handed by the drawing system.
And then I'll simply draw my logo on top of

00:27:42.230 --> 00:27:47.270
that one it's finished.
And the result is that I didn't need to include

00:27:47.270 --> 00:27:53.280
my logo on a green background and a red background
and a blue background and, you know, textured

00:27:53.280 --> 00:27:57.539
and everything like that.
I was able to include just the unique bit

00:27:57.539 --> 00:28:09.590
and then handle these generic operations in
code at run time.

00:28:09.590 --> 00:28:15.590
Another drawable type that can be really useful
on this vector of screen compatibility is

00:28:15.590 --> 00:28:19.549
the scale drawable.
And the scale drawable's a wrapper around

00:28:19.549 --> 00:28:25.570
another drawable that allows you more customized
control of the way that drawable grows and

00:28:25.570 --> 00:28:29.110
changes as the screen grows or the aspect
ratio changes.

00:28:29.110 --> 00:28:37.080
This can be particularly useful in places
where one dimension of the underlying drawable

00:28:37.080 --> 00:28:43.059
is much more important than the other dimension.
So for this, think things like a horizontal

00:28:43.059 --> 00:28:47.470
progress bar, the horizontal is actually much
more important, and you'd like to grow that

00:28:47.470 --> 00:28:51.860
out as the screen gets wider, but you don't
necessarily want to make it a whole bunch

00:28:51.860 --> 00:28:56.470
taller.
Rather, you'd like to take that vertical screen

00:28:56.470 --> 00:28:59.679
space and do something more interesting with
it.

00:28:59.679 --> 00:29:05.840
Similarly, dividers of vertical or horizontal
varieties have a dimension that is certainly

00:29:05.840 --> 00:29:11.289
more important than the other.
So, basically, you know, anyplace where one

00:29:11.289 --> 00:29:16.580
dimension is more important than the other
is one where a scale drawable can help you

00:29:16.580 --> 00:29:21.770
out in making the UI look better as well as
reducing the number of actual drawable resources

00:29:21.770 --> 00:29:29.670
that you need to include.
The next one I want to talk about is the level

00:29:29.670 --> 00:29:34.649
list drawable, which I think is a rather clever
little beast.

00:29:34.649 --> 00:29:40.929
And so the level list drawable is a composite
of other drawables that you include in your

00:29:40.929 --> 00:29:46.730
package.
And what it does is logically groups these

00:29:46.730 --> 00:29:56.409
resources or other drawables into one element.
And part of what this is doing is separating

00:29:56.409 --> 00:30:03.309
out your presentation from your implementation.
So your implementation can be concerned with

00:30:03.309 --> 00:30:08.250
figuring out what state your drawable should
be in, and then the level list will figure

00:30:08.250 --> 00:30:11.520
out, based on that state, what the exact presentation
should be.

00:30:11.520 --> 00:30:20.350
An example that, you know, is really straightforward
of using these is a status meter of some variety.

00:30:20.350 --> 00:30:26.380
So imagine you have a battery meter and you
have drawables for different charge levels,

00:30:26.380 --> 00:30:30.870
but you don't have one for every charge level
from 0 to 100%.

00:30:30.870 --> 00:30:37.870
And the drawable itself should just figure
out which of -- which of the drawables that

00:30:37.870 --> 00:30:40.111
are its children it should pick to draw to
the screen.

00:30:40.111 --> 00:30:45.370
And your code should just be concerned with
setting the status of that drawable so it

00:30:45.370 --> 00:30:51.440
can figure out how to draw itself.
There are some other kind of less-conventional

00:30:51.440 --> 00:30:55.059
uses for this.
You might use it for weather conditions or

00:30:55.059 --> 00:31:00.350
perhaps if you're trying to pick what a drawable
should look like on different UI themes, because

00:31:00.350 --> 00:31:08.669
there are a couple different UI themes out
there for Android devices.

00:31:08.669 --> 00:31:14.299
And if you're using some of these less-natural
scenarios for level lists, you can define

00:31:14.299 --> 00:31:21.120
constants in your code that are going to make
the code much more readable and logical in

00:31:21.120 --> 00:31:27.190
terms of setting what the level means and
what it stands for.

00:31:27.190 --> 00:31:33.480
So the goal of this drawable is really to
make your code easier and more readable and

00:31:33.480 --> 00:31:38.130
logically separate the concerns of presentation
from the actual code implementation.

00:31:38.130 --> 00:31:43.230
And I want to walk through a quick example
of using this, because I really do like level

00:31:43.230 --> 00:31:50.040
list and think it's, you know, rather clever.
So let's say that I have an application where

00:31:50.040 --> 00:31:56.300
I want to provide details of -- you know,
details for a sports game that's going to

00:31:56.300 --> 00:31:59.290
happen.
And one thing that I'm worried about is what

00:31:59.290 --> 00:32:02.809
the weather is going to be like.
And I want to render this attribute on the

00:32:02.809 --> 00:32:08.059
screen.
Now, logically, this part of the screen is

00:32:08.059 --> 00:32:10.490
always just weather condition, what it's going
to be like.

00:32:10.490 --> 00:32:15.110
My code just wants to think about weather
condition, set the condition, let the UI figure

00:32:15.110 --> 00:32:18.470
out the rest.
So I've got my level list here defined in

00:32:18.470 --> 00:32:23.460
XML which has a number of items.
So the items have two attributes.

00:32:23.460 --> 00:32:29.370
They refer to a drawable resource.
In this case, it was just bitmaps.

00:32:29.370 --> 00:32:36.720
And then they also have this max level parameter.
And this is the maximum value that the level

00:32:36.720 --> 00:32:42.029
list is set to for which this drawable is
appropriate.

00:32:42.029 --> 00:32:46.960
For example, here, I'm basically saying if
the chance of rain is between zero and 10%,

00:32:46.960 --> 00:32:52.789
I want to put the chance slight up there.
If the chance is between 10 and 40, okay,

00:32:52.789 --> 00:33:01.110
I'll say -- you know, I'll say the chance
is sort of good.

00:33:01.110 --> 00:33:04.130
So then if I want to use this in my code,
it looks something like this.

00:33:04.130 --> 00:33:10.200
And it looks really simple, which is awesome.
I've exported some of the switch statement

00:33:10.200 --> 00:33:15.200
complexity that I might otherwise have to
this nice markup language that I don't have

00:33:15.200 --> 00:33:19.450
to clutter my code with.
And I can even let my designers reconfigure

00:33:19.450 --> 00:33:23.539
this for me, and I don't have to worry about
it.

00:33:23.539 --> 00:33:27.389
So I'm just finding the view that corresponds
to my weather condition here.

00:33:27.389 --> 00:33:33.330
And then I'm setting the image level.
And maybe I'll get the image level, which

00:33:33.330 --> 00:33:37.750
is the probability of rain, from some Web
service out there.

00:33:37.750 --> 00:33:43.019
And if you'd like -- if you'd like suggestions
on how to do this best, make sure to attend

00:33:43.019 --> 00:33:47.440
the first Android session tomorrow, which
I saw a preview of and is actually really

00:33:47.440 --> 00:33:51.340
awesome.
But, anyway, so I'll call out to my Web service

00:33:51.340 --> 00:33:55.529
and, you know, get the probability back, and
then the UI element will figure out how to

00:33:55.529 --> 00:33:58.559
display itself.
So if there's a good chance of rain, it might

00:33:58.559 --> 00:34:02.190
look something like this.
You know, if the chance of rain is pretty

00:34:02.190 --> 00:34:08.800
low, it might look as such.
And then -- but I could also use this for

00:34:08.800 --> 00:34:12.429
something less conventional.
I could use it for the sports teams here,

00:34:12.429 --> 00:34:16.200
to control what icons.
And for this, I would do something just like

00:34:16.200 --> 00:34:21.470
defining logical constants that correspond
to the sports teams and then setting those

00:34:21.470 --> 00:34:26.260
to be -- correspond to max level in my level
list attributes.

00:34:26.260 --> 00:34:34.659
Oh, and a special thanks to the -- the open
clip art project, which has some great public

00:34:34.659 --> 00:34:41.740
domain images that saved me probably a day
of work trying to create a cloud with a sun

00:34:41.740 --> 00:34:45.700
behind it.
I'm not a graphic artist.

00:34:45.700 --> 00:34:54.450
So talking about resources, talking about
images and drawables, these are the main components

00:34:54.450 --> 00:34:59.119
of what you'll need to think about when you're
thinking about cross-screen compatibility

00:34:59.119 --> 00:35:01.991
or this UI compatibility factor that I've
been talking about.

00:35:01.991 --> 00:35:07.760
So there are a number of things in the system
to help you out, you know, the resource system,

00:35:07.760 --> 00:35:12.680
and also a simplification of the universe,
collapsing the different screens and different

00:35:12.680 --> 00:35:17.890
 -- collapsing the different screen configurations
into a handful instead of the myriad that

00:35:17.890 --> 00:35:25.300
are actually on the 50 devices out there.
But of course your application isn't just

00:35:25.300 --> 00:35:28.900
UI.
There's probably some code that drives that

00:35:28.900 --> 00:35:32.520
UI.
And the code that drives that UI is going

00:35:32.520 --> 00:35:36.790
to run on different versions of the Android
operating system.

00:35:36.790 --> 00:35:43.760
Today, we have three major versions out there.
We have Android 1.5, 1.6, and 2.1.

00:35:43.760 --> 00:35:48.160
And I'm here to tell you that multiple versions
are the norm, not the exception.

00:35:48.160 --> 00:35:55.339
Sorry.
So I think that we'll probably always have

00:35:55.339 --> 00:36:01.010
at least two major versions of the Android
other there.

00:36:01.010 --> 00:36:07.579
But this isn't such a terrible thing.
And it's actually not that hard to deal with.

00:36:07.579 --> 00:36:13.839
So let's go over how we deal with this diversity,
with this API diversity.

00:36:13.839 --> 00:36:18.150
And so basically what I'm going to talk about
here is detection.

00:36:18.150 --> 00:36:23.290
And after the condition of the environment
has been detected, you have any number of

00:36:23.290 --> 00:36:25.849
different ways that you can deal with that
change.

00:36:25.849 --> 00:36:30.350
Or not that change, but deal with that situation.
Don't worry.

00:36:30.350 --> 00:36:36.030
The API level isn't one of those things that
will change while your application is running.

00:36:36.030 --> 00:36:42.760
That would be really bad.
So the basics -- So there are two types of

00:36:42.760 --> 00:36:50.800
API changes that we're going to consider.
One is when whole new classes enter or leave

00:36:50.800 --> 00:36:59.230
the API, and the other is when individual
methods get appended or removed or changed.

00:36:59.230 --> 00:37:04.680
But the basic strategy for dealing with both
of these situations is the same, which is

00:37:04.680 --> 00:37:12.369
to insert yourself into the class loading
and verification chain of command so that

00:37:12.369 --> 00:37:17.550
you can intercept any errors, realize what
the error means, and then deal with it in

00:37:17.550 --> 00:37:23.820
your code appropriately.
And so for dealing with class-level changes,

00:37:23.820 --> 00:37:29.089
what we're going to walk through is using
some static methods and members which are

00:37:29.089 --> 00:37:33.310
basically going to poke the class loading
system and say, "Tell me if something" -- you

00:37:33.310 --> 00:37:39.560
know, "Tell me if this item isn't available."
Then we'll catch any error that that system

00:37:39.560 --> 00:37:48.220
throws to us, and adapt the behavior appropriately.
And so by using the -- a secondary class with

00:37:48.220 --> 00:37:53.880
some static methods, we'll avoid this kind
of messy probing where we call class forename

00:37:53.880 --> 00:37:59.390
and type out the whole name, which we might
mistype and get a false positive on and all

00:37:59.390 --> 00:38:03.570
sorts of messy things.
The downside of this, of course, is that we

00:38:03.570 --> 00:38:11.220
need more classes of either top-level classes
or inner classes to help us out.

00:38:11.220 --> 00:38:15.150
And to deal with this, you might have just
a host of inner classes in sort of whatever

00:38:15.150 --> 00:38:20.330
class host your detection code, or you might
sequester them all in one package where they're

00:38:20.330 --> 00:38:24.710
kind of out of the way of the rest of your
project.

00:38:24.710 --> 00:38:27.380
And one of these detector classes might look
something like this.

00:38:27.380 --> 00:38:33.540
So I've got my class here called canary.
For anyone not familiar, canaries used to

00:38:33.540 --> 00:38:37.099
be used in coal mining to detect if dangerous
gases were building up.

00:38:37.099 --> 00:38:41.200
So unfortunately for the canary, it would
typically die, but the miners would come out

00:38:41.200 --> 00:38:49.579
alive.
So my digital canary is going to have a private

00:38:49.579 --> 00:38:57.250
static member that is of type whatever I'm
looking for, whatever the new class is.

00:38:57.250 --> 00:39:01.220
And then I've got the static method try new
class that tries to create a new instance

00:39:01.220 --> 00:39:05.920
of this class.
Now, there are a couple of different ways

00:39:05.920 --> 00:39:09.360
that I can do this.
I wouldn't necessarily have to create a new

00:39:09.360 --> 00:39:11.290
instance.
There are some different ways to skin this

00:39:11.290 --> 00:39:13.430
cat.
But this is the one that I'm, you know -- the

00:39:13.430 --> 00:39:17.869
one that I'm fond of and going to choose for
this case.

00:39:17.869 --> 00:39:20.369
So how does canary integrate with the rest
of my code?

00:39:20.369 --> 00:39:26.240
So if I've got my activity here, what I'm
going to do is have this Boolean that tells

00:39:26.240 --> 00:39:29.800
me whether the canary is available.
After I made these slides, I realized I probably

00:39:29.800 --> 00:39:34.589
should have said canary alive or not, and
that sort of goes with the rest of the metaphor.

00:39:34.589 --> 00:39:37.120
If canary is available and alive, I'll do
one thing.

00:39:37.120 --> 00:39:42.589
And if it's not, I'll do another.
So the first thing that I'm going to do is

00:39:42.589 --> 00:39:49.170
have my check APIs method here, which is going
to call this static method in my canary class.

00:39:49.170 --> 00:39:53.680
And when it does this, the class loader for
Android is for the first time going to pull

00:39:53.680 --> 00:40:00.359
canary into memory, look at it, and go, "Do
you work on this system?"

00:40:00.359 --> 00:40:04.180
And if it does, you know, my code's going
to proceed, and I'll say the canary's available

00:40:04.180 --> 00:40:06.670
and alive.
But if the class loader looks at it and says,

00:40:06.670 --> 00:40:10.671
"Wait a second, we don't have that.
It's going to freak out and throw an error

00:40:10.671 --> 00:40:15.500
and say we can't load this class."
I'm going to catch that error and note that

00:40:15.500 --> 00:40:21.170
the canary is not available and also put in
the log that the canary's not available, which

00:40:21.170 --> 00:40:27.859
will hopefully help with debugging later on
if I find some odd application behavior and

00:40:27.859 --> 00:40:35.099
I see this in the log, I'll know that the
compatibility mode code had been invoked.

00:40:35.099 --> 00:40:41.220
So this will help me deal with when whole
new classes come in or go out of the API.

00:40:41.220 --> 00:40:46.190
But sometimes the API-level changes are a
bit more subtle than that.

00:40:46.190 --> 00:40:51.990
Sometimes they're just new methods or maybe
even just changed method signatures.

00:40:51.990 --> 00:40:54.589
And I think this case is a little bit trickier
to deal with.

00:40:54.589 --> 00:41:01.830
But the same basic, you know, two-phased strategy
of detect and deal with is still being used.

00:41:01.830 --> 00:41:08.339
So in the detection phase, I have the choice
of using reflection to see if a given class

00:41:08.339 --> 00:41:14.440
has a method available.
Or I can take the step to make my code version-aware,

00:41:14.440 --> 00:41:20.190
which means I'll have some bit of code that
has, you know, the lookup table that says,

00:41:20.190 --> 00:41:24.961
in this version of the OS, I have these -- you
know, I have these APIs available.

00:41:24.961 --> 00:41:27.611
In this version, I have these APIs available,
et cetera, et cetera.

00:41:27.611 --> 00:41:32.530
And then that code can just look at the build
version number.

00:41:32.530 --> 00:41:36.420
The downside of this, of course, is that this
is pretty brittle.

00:41:36.420 --> 00:41:40.130
It's open to human error.
And it means when new versions come out, you're

00:41:40.130 --> 00:41:44.859
going to have to scramble and update this
code.

00:41:44.859 --> 00:41:50.230
So once we've detected whether or not something
is available, you know, how are we going to

00:41:50.230 --> 00:41:56.670
create a class that works in this environment?
Well, one way is that we can call a questionable

00:41:56.670 --> 00:42:01.230
method through using reflection.
And this is going to result in fewer classes,

00:42:01.230 --> 00:42:08.619
because then my detection code can also operate
on these underlying classes and I won't throw

00:42:08.619 --> 00:42:13.230
any verification errors.
The other option is to use some sort of factory

00:42:13.230 --> 00:42:19.720
pattern which will, you know, figure out availability
and then based on that, load the appropriate

00:42:19.720 --> 00:42:25.270
class that implements an interface that only
touches methods that are available on this

00:42:25.270 --> 00:42:31.130
version of the platform.
So reflection is going to give me fewer classes.

00:42:31.130 --> 00:42:35.330
The factory method will give me more classes
but is somewhat cleaner in the implementation

00:42:35.330 --> 00:42:42.359
because I'm only calling through to actual
class methods as opposed to using reflection

00:42:42.359 --> 00:42:48.700
to make the calls, which, again, messier dependent
on typing, dependent on typing on the keyboard

00:42:48.700 --> 00:42:52.740
correctly.
And so what I'm going to walk through here

00:42:52.740 --> 00:42:58.712
is doing this just solely with reflection.
It's the method I'd recommend and the method

00:42:58.712 --> 00:43:04.190
that I prefer.
So this time, all the action is going to focus

00:43:04.190 --> 00:43:08.089
on my canary class.
So I've got my canary.

00:43:08.089 --> 00:43:12.800
And as I said before, there are a couple different
ways to do the detection phase.

00:43:12.800 --> 00:43:18.069
And I'm using a different one here.
So I have my private member, which is now

00:43:18.069 --> 00:43:27.260
a method, the actual method type in Java.
And then I'm using a static initializer block.

00:43:27.260 --> 00:43:31.410
So the static initializing block is going
to run when the class is first loaded into

00:43:31.410 --> 00:43:35.140
memory.
And in this case, what I'm doing is calling

00:43:35.140 --> 00:43:42.030
getdensity.
Or, well, so my getdensity member is going

00:43:42.030 --> 00:43:47.650
to be assigned the getdensity method of the
Canvas class if it's available.

00:43:47.650 --> 00:43:53.530
And, incidentally, this method is only available
on Android 1.6 and above, because that, there

00:43:53.530 --> 00:44:00.020
was only one density in the world, medium
density, on the G1.

00:44:00.020 --> 00:44:06.450
But if not, the class loading system is going
to throw an error, which, again, I'll log

00:44:06.450 --> 00:44:15.849
and implicitly detect by leaving getdensity
null.

00:44:15.849 --> 00:44:20.300
So, then, to actually use this in code, like
I said, all the action is on canary this time.

00:44:20.300 --> 00:44:26.050
And canary is going to expose this interface
that my other classes are going to call through

00:44:26.050 --> 00:44:31.370
to.
And so I realize in this slide I left this

00:44:31.370 --> 00:44:36.920
extraneous "hasDensity" member.
So please just ignore that.

00:44:36.920 --> 00:44:42.930
So in my getdensity method that canary has,
I'll first see, all right, did I find that

00:44:42.930 --> 00:44:48.800
getdensity the method of Canvas was available?
And if so, I'll just return the result from

00:44:48.800 --> 00:44:52.309
that.
But I'll invoke that method using Reflection,

00:44:52.309 --> 00:44:56.930
which means regardless of the system that
I'm actually running on, canary can be loaded,

00:44:56.930 --> 00:45:04.200
because I'm never calling Canvas.getdensity.
If I called Canvas.getdensity directly, when

00:45:04.200 --> 00:45:08.280
canary was loaded on Android 1.5, there would
be an error thrown.

00:45:08.280 --> 00:45:15.589
So I've met my goal of fewer classes but somewhat
messier calling syntax here.

00:45:15.589 --> 00:45:20.020
But if canary isn't available, I'll perform
some default behavior.

00:45:20.020 --> 00:45:25.260
In this case, default behavior is pretty easy
to figure out, because it is just to say that

00:45:25.260 --> 00:45:31.339
I'm on a medium-density device, because Android
1.5, only medium density.

00:45:31.339 --> 00:45:38.500
What you may choose to do with your applications
instead is to either disable -- disable whole

00:45:38.500 --> 00:45:43.710
sections of functionality or to try to run
in some degraded mode when you don't have

00:45:43.710 --> 00:45:52.440
access to APIs that you would like.
And so by using these, you know, somewhat

00:45:52.440 --> 00:45:57.421
clever, somewhat not clever tricks with Reflection,
you'll be able to detect the environment that

00:45:57.421 --> 00:46:04.130
you're running in and then at run time, adapt
your behavior accordingly and meet this goal

00:46:04.130 --> 00:46:14.410
of having -- you know, the second vector of
compatibility, this version-level API compatibility.

00:46:14.410 --> 00:46:20.260
So now having talked about the two vectors,
I just want to say a couple words on testing.

00:46:20.260 --> 00:46:23.480
Testing is always important for any code that
you write.

00:46:23.480 --> 00:46:29.240
But certainly if you're writing tricky code
that uses Reflection or providing different

00:46:29.240 --> 00:46:33.599
resources, you want to verify that all of
this works properly.

00:46:33.599 --> 00:46:38.530
And there's really nothing better than actually
testing your application.

00:46:38.530 --> 00:46:43.970
It allows you to verify that the UI that you've
designed for different screen resolutions

00:46:43.970 --> 00:46:49.319
and different screen sizes and densities is
working properly, and also check that the

00:46:49.319 --> 00:46:53.500
API compatibility code that we just went through
is working as expected.

00:46:53.500 --> 00:46:59.930
And the great thing is that you can do pretty
much all of this checking on the Android emulator

00:46:59.930 --> 00:47:04.869
itself.
So for some of you, you will be writing applications

00:47:04.869 --> 00:47:09.910
that access bits of hardware that the emulator
doesn't, well, emulate.

00:47:09.910 --> 00:47:14.460
Maybe it's the Bluetooth stack or -- or using
Wi-Fi or something like that.

00:47:14.460 --> 00:47:18.010
In which case, you probably will need a bit
of hardware to actually do your testing.

00:47:18.010 --> 00:47:25.240
Oh, my God, he admitted you might need hardware
for testing.

00:47:25.240 --> 00:47:32.960
So -- But the happy news there is that you
don't need every piece of hardware in the

00:47:32.960 --> 00:47:37.700
world.
So as I've said before, the Android system

00:47:37.700 --> 00:47:42.670
tries to simplify the view of the device universe,
particularly with respect to screens, into

00:47:42.670 --> 00:47:49.500
some different buckets. So at most what you
need is hardware from each of these different

00:47:49.500 --> 00:47:54.819
buckets. And there really aren't that many
buckets out there. So no need to run out and

00:47:54.819 --> 00:47:59.530
buy all 50 phones that you see on the show
floor, although I I'm sure the OEMs would

00:47:59.530 --> 00:48:09.920
love it if you did. So support our OEMs.
So I hope in this presentation you have seen

00:48:09.920 --> 00:48:14.819
that supporting all these different device
models that will reach millions and millions

00:48:14.819 --> 00:48:21.660
of users is not a Herculean task but one that
is imminently within your reach.

00:48:21.660 --> 00:48:26.410
There are these cluster of considerations
to think about while you are building your

00:48:26.410 --> 00:48:32.500
application, and if you take these to mind
as you are writing your code and designing

00:48:32.500 --> 00:48:37.450
your resources, you are going to end up with
an application that looks great across all

00:48:37.450 --> 00:48:42.770
those devices in the hands of millions of
users.

00:48:42.770 --> 00:48:49.569
So with that, I'll turn it over to questions.
Again, here is the URL for the live Wave,

00:48:49.569 --> 00:48:57.390
and the QR code which I will leave up for
just slightly longer this time.

00:48:57.390 --> 00:49:02.250
Okay.
And I'm going to try to switch over to Wave

00:49:02.250 --> 00:49:13.910
here,
and see what we have in terms of questions.

00:49:13.910 --> 00:49:19.530
If there are live questions, please go to
the microphones and we'll try to multiplex

00:49:19.530 --> 00:49:28.609
in some efficient way.
How to target devices like aPad?

00:49:28.609 --> 00:49:32.740
Android Pad. I haven't heard of the Android
Pad. I don't think it exists. So -- Sorry?

00:49:32.740 --> 00:49:41.530
&gt;&gt;&gt; (Speaking off mic)
&gt;&gt;Justin Mattson: So someone is talking about

00:49:41.530 --> 00:49:45.280
the lobby of Building 43, and I believe you
are referring to what we call the Mega Phone,

00:49:45.280 --> 00:49:52.920
which is, if you haven't seen pictures, of
the life size, kind of, Nexus Ones.

00:49:52.920 --> 00:50:00.680
The answer is there is no aPad but I can actually
answer this question for you which is to say

00:50:00.680 --> 00:50:04.609
use all the things which we have been talking
about here.

00:50:04.609 --> 00:50:10.630
If you think about this, anything that is
sort of a tablet-sized device just has a different

00:50:10.630 --> 00:50:16.040
screen configuration. And we have the resources
in the system for you to be able to deal with

00:50:16.040 --> 00:50:22.790
this.
So I am going to go to a live question over

00:50:22.790 --> 00:50:26.740
there.
&gt;&gt;&gt; Yeah, one of the things that I ran into

00:50:26.740 --> 00:50:34.829
in trying handle the rotation, for example,
was I have an application that solves puzzles,

00:50:34.829 --> 00:50:40.610
and it takes a while to do that and it does
it in a thread in the background and is constantly

00:50:40.610 --> 00:50:52.369
showing "updating the screen." So the -- when
the -- if you do the normal let the application

00:50:52.369 --> 00:50:59.630
 -- or let the system kill the activity and
restart it, you lose your UI context that

00:50:59.630 --> 00:51:03.981
the background thread is trying to access
through the handler. How do you deal with

00:51:03.981 --> 00:51:08.430
that?
&gt;&gt;Justin Mattson: So -- But you are still

00:51:08.430 --> 00:51:10.930
preserving your thread running in the background,
I assume.

00:51:10.930 --> 00:51:12.750
&gt;&gt;&gt; That's correct.
&gt;&gt;Justin Mattson: Okay; great.

00:51:12.750 --> 00:51:17.119
So you are doing that, and before I answer
your question I want to talk about how you

00:51:17.119 --> 00:51:22.420
are probably doing that, which many, many
devs I have talked to aren't aware of. And

00:51:22.420 --> 00:51:32.170
so that's this great call-back called onRetainNonConfigurationInstance
So if you are handling a configuration change

00:51:32.170 --> 00:51:37.309
and you have got long-running stuff, solving
a puzzle in the background, you can shove

00:51:37.309 --> 00:51:45.040
that running thread into the object that is
passed along to onRetainNonConfigurationInstance,

00:51:45.040 --> 00:51:49.520
and that thread will keep running and keep
spinning away while the orientation or something

00:51:49.520 --> 00:51:55.040
else is changing and allow you to not do all
these nasty tricks, like storing things in

00:51:55.040 --> 00:51:59.810
static members.
So to answer your question, how do you deal

00:51:59.810 --> 00:52:05.750
with a lost UI context, and I don't think
there is any magic answer here. You basically

00:52:05.750 --> 00:52:15.020
need some bit on that thread that you can
set on that thread to say UI unavailable.

00:52:15.020 --> 00:52:22.280
And then when the UI comes back, what you
want to perhaps have is -- so one way perhaps

00:52:22.280 --> 00:52:26.690
that you want to structure your puzzle solver
thread is to actually have a looper of its

00:52:26.690 --> 00:52:35.870
own, and have that looper be able to receive
the message from the main UI thread when it

00:52:35.870 --> 00:52:40.470
comes back.
So have something in "on create" that will

00:52:40.470 --> 00:52:46.089
be able to get to that handler and send it
a message. And that handler is something that

00:52:46.089 --> 00:52:54.900
you might want to store in that nonconfiguration
instance object. So then the thread will get

00:52:54.900 --> 00:53:00.099
the signal, okay, this is available again,
and I can go ahead and update the UI.

00:53:00.099 --> 00:53:05.410
&gt;&gt;&gt; Okay. Thank you.
&gt;&gt;Justin Mattson: So let's go over here, on

00:53:05.410 --> 00:53:09.450
the other side for a question.
&gt;&gt;&gt; So I have a question. If you are targeting

00:53:09.450 --> 00:53:14.420
the other way, if you actually don't want
to support all devices, are there any targeting

00:53:14.420 --> 00:53:20.299
options, for example, in the manifest other
than the version, the Android version?

00:53:20.299 --> 00:53:25.119
&gt;&gt;Justin Mattson: So I actually had to forget
that I don't have to repeat the question.

00:53:25.119 --> 00:53:31.710
You are on a mic.
So the answer there is a little bit that you

00:53:31.710 --> 00:53:39.570
can do. One is that you can say what screen
sizes you support. So you can, for example,

00:53:39.570 --> 00:53:45.100
opt out of small screen sizes.
Now, if you do something like opt out of large

00:53:45.100 --> 00:53:51.680
screen sizes, you don't actually opt out of
them because what the system can do is say,

00:53:51.680 --> 00:53:55.660
okay, were you designed for a normal size
screen. Well, I will just letterbox you because

00:53:55.660 --> 00:54:01.920
I run you in the context of this larger size
screen and you are going to perform like you

00:54:01.920 --> 00:54:06.430
are expected to.
You know, conversely, with small screens we

00:54:06.430 --> 00:54:09.609
can't take a large interface and cram it into
a small screen nearly as well.

00:54:09.609 --> 00:54:17.150
So there are a limited number of options here,
and I guess I would really hope that the focus

00:54:17.150 --> 00:54:22.030
is on bringing Android applications to all
the users out there. I certainly understand

00:54:22.030 --> 00:54:29.579
that sometimes not all devices can be supported
from the beginning. And you may be left in

00:54:29.579 --> 00:54:33.350
a situation where you will just have to do
run time detection and say I'm sorry, I don't

00:54:33.350 --> 00:54:38.079
support your configuration.
And the other thing to be aware of with this

00:54:38.079 --> 00:54:51.680
is that this ability to filter and target
is actually at the Android market level. So

00:54:51.680 --> 00:54:55.410
the screen's attribute that I was talking
about, for example, is completely ignored

00:54:55.410 --> 00:55:02.470
by the package system. So it won't refuse
to install something that doesn't say that

00:55:02.470 --> 00:55:06.490
it supports the screen. It will install it
and then try to run it and see what happens.

00:55:06.490 --> 00:55:12.300
So it's just something to be aware of, that
if you are delivering an app through your

00:55:12.300 --> 00:55:18.089
own Web site or something like that, you may
not have that same sort of protection that

00:55:18.089 --> 00:55:20.830
market affords you.
&gt;&gt;&gt; Thanks.

00:55:20.830 --> 00:55:26.040
&gt;&gt;Justin Mattson: Sure.
So I want to go back to a question on the

00:55:26.040 --> 00:55:29.829
Wave.
How will future versions of Android address

00:55:29.829 --> 00:55:38.780
fragmentation?
Well, so first of all, let's define fragmentation.

00:55:38.780 --> 00:55:46.549
And so fragmentation is when the same version
of Android runs differently across different

00:55:46.549 --> 00:55:55.559
hardware. And so to date, I haven't really
seen that many instances of fragmentation.

00:55:55.559 --> 00:56:02.610
I suspect the asker of this question was saying
 -- was asking how will we address the fact

00:56:02.610 --> 00:56:08.430
that Android runs on devices that aren't the
same?

00:56:08.430 --> 00:56:13.170
So the answer is we are not going to stop
Android from running on different devices.

00:56:13.170 --> 00:56:19.000
Running on different devices is great. It
allows people to put different phones, all

00:56:19.000 --> 00:56:25.380
sorts of things out there that meet the end
users' needs. The end users want different

00:56:25.380 --> 00:56:30.180
types of devices. They want different configurations
because they meet their needs better.

00:56:30.180 --> 00:56:36.200
So what Android already does and will continue
to do for us and try to do better and better

00:56:36.200 --> 00:56:41.680
as time goes on is allow you to understand
the environment in which you are operating

00:56:41.680 --> 00:56:46.210
and adapt to it appropriately, and provide
tools where it can.

00:56:46.210 --> 00:56:52.930
For example, where I was talking about imagery
source scaling before. This is something provided

00:56:52.930 --> 00:56:58.609
by the system so that it's easier to run on
different screen densities out there. And

00:56:58.609 --> 00:57:09.170
where we can provide these things that will
help developers out, we will implement them.

00:57:09.170 --> 00:57:12.099
So --
&gt;&gt;&gt; (speaking off mic).

00:57:12.099 --> 00:57:20.460
&gt;&gt;Justin Mattson: Mine is not being refreshed.
So I don't know if that answered the questioner's

00:57:20.460 --> 00:57:24.039
question. If they are here, raise your hand.
And if it didn't, we'll....

00:57:24.039 --> 00:57:32.550
Okay.
Okay. Let's do another live question over

00:57:32.550 --> 00:57:36.030
here.
&gt;&gt;&gt; I just want to point out that there's

00:57:36.030 --> 00:57:44.250
a better way to handle the case -- or detect
the case where a method has been added on

00:57:44.250 --> 00:57:47.920
a newer version of Android.
&gt;&gt;Justin Mattson: I'm sorry, to detect where

00:57:47.920 --> 00:57:50.339
what has been added?
&gt;&gt;&gt; The case where a method has been added

00:57:50.339 --> 00:57:53.420
on the new version.
&gt;&gt;Justin Mattson: Sure.

00:57:53.420 --> 00:57:58.450
&gt;&gt;&gt; You can actually use the same way that
you detected a new class has been added. You

00:57:58.450 --> 00:58:02.820
can just catch the verifier --
&gt;&gt;Justin Mattson: Mm-hmm.

00:58:02.820 --> 00:58:11.220
&gt;&gt;&gt; I use that in Hello Android third edition
when I went to support multi-touch and also

00:58:11.220 --> 00:58:13.759
not multi-touch.
&gt;&gt;Justin Mattson: Mm-hmm.

00:58:13.759 --> 00:58:21.190
&gt;&gt;&gt; So I just had a class which extended move
events. And if you were on an old Android,

00:58:21.190 --> 00:58:28.539
it got a verify error which you could catch.
&gt;&gt;Justin Mattson: Sure. And yes, that's another

00:58:28.539 --> 00:58:33.240
way that you can do it, and certainly I was
hoping to bring out a number of different

00:58:33.240 --> 00:58:40.650
ways to skin this cat that if different people
have different exact use cases and situations,

00:58:40.650 --> 00:58:44.289
they can choose from the one that makes the
most sense for them.

00:58:44.289 --> 00:58:49.859
But, yeah, that's a good point. You can use
very much the same method as for the whole

00:58:49.859 --> 00:58:59.430
new class to do a method.
Okay. So last question. So raise your hand

00:58:59.430 --> 00:59:07.720
if you -- So raise your hand if you want me
to answer the first question up here or take

00:59:07.720 --> 00:59:11.430
another audience question.
So question up here, raise your hand.

00:59:11.430 --> 00:59:16.690
Audience question.
Audience wins.

00:59:16.690 --> 00:59:18.460
You, sir.
&gt;&gt;&gt; Me.

00:59:18.460 --> 00:59:23.360
&gt;&gt;Justin Mattson: Yes.
&gt;&gt;&gt; So mostly from listening you to talk,

00:59:23.360 --> 00:59:26.670
it seems like you were addressing graphical
objects.

00:59:26.670 --> 00:59:32.289
&gt;&gt;Justin Mattson: Mm-hmm.
&gt;&gt;&gt; You know, icons, drawables, images, Nine-Patches,

00:59:32.289 --> 00:59:36.869
things like that.
I have an issue where an app that I wrote

00:59:36.869 --> 00:59:43.109
for the G1 -- I actually didn't write it for
the G1. It runs properly on the G1, displays

00:59:43.109 --> 00:59:48.440
an edit text view properly on the G1, but
on the Android it actually, it collapses it

00:59:48.440 --> 00:59:52.049
and it cuts it off, and things just aren't
lining up.

00:59:52.049 --> 00:59:59.369
So I was wondering if you have any advice
or hints for not graphical objects but regular

00:59:59.369 --> 01:00:03.660
UI objects.
&gt;&gt;Justin Mattson: Sure. So the edit text is

01:00:03.660 --> 01:00:09.559
in some sense just a drawable object itself.
Now, this actually is also sort of the first

01:00:09.559 --> 01:00:15.380
question up here, what if things behave differently
on different devices. And so if things behave

01:00:15.380 --> 01:00:22.030
differently on different devices, it's a bug.
Report that bug.

01:00:22.030 --> 01:00:23.660
Report it loudly, if you need to.
&gt;&gt;&gt; Okay.

01:00:23.660 --> 01:00:26.069
&gt;&gt;Justin Mattson: But report it.
&gt;&gt;&gt; I am reporting it.

01:00:26.069 --> 01:00:31.660
&gt;&gt;Justin Mattson: Now, in your specific case,
are you perhaps defining the size of the text

01:00:31.660 --> 01:00:36.350
that goes into the edit text in number of
pixels, PX?

01:00:36.350 --> 01:00:41.099
&gt;&gt;&gt; I would have to go back and look at my
XML file. I think I am defining it in terms

01:00:41.099 --> 01:00:47.480
of DIP.
I recently went through my XML files and kind

01:00:47.480 --> 01:00:53.531
of did a purge on PXs and replaced everything
with DIP. There may be a straggler out there

01:00:53.531 --> 01:00:57.349
but I think it's all working off of DIP.
&gt;&gt;Justin Mattson: Then the answer is I am

01:00:57.349 --> 01:01:02.480
not aware of that bug, and so report it on
the forums and wherever and we will pick it

01:01:02.480 --> 01:01:04.960
apart.
So the specific issue, though, I am talking

01:01:04.960 --> 01:01:11.119
about is if you define things on PX, there
was a bug in at least one version of Android

01:01:11.119 --> 01:01:18.059
that ran on Droid where the number of pixels
that correspond to a PX was incorrect. And

01:01:18.059 --> 01:01:23.100
so any text that you defined in terms of PX
would render incorrectly, but I think it's

01:01:23.100 --> 01:01:28.880
only fair because we tell you not to use PX,
and use DIP, DP or SP.

01:01:28.880 --> 01:01:34.210
&gt;&gt;&gt; And just to clarify one of the very first
questions. There actually is a device out

01:01:34.210 --> 01:01:40.430
there called the aPad. This came out on some
of the gadget sites about a week or two ago

01:01:40.430 --> 01:01:46.400
 -- about a week ago. If you Google for Android
and aPad, there is a Chinese knock-off company

01:01:46.400 --> 01:01:50.440
out there who is selling a generic tablet
device running Android 1.5.

01:01:50.440 --> 01:01:53.880
&gt;&gt;Justin Mattson: Does it look cool?
&gt;&gt;&gt;It looks pretty freaking cool.

01:01:53.880 --> 01:01:55.500
&gt;&gt;Justin Mattson: Okay. I'll have to look
it up.

01:01:55.500 --> 01:01:59.910
So we are over time, and they are going to
shoot me pretty soon, but thank you all for

01:01:59.910 --> 01:02:05.290
coming and enjoy targeting all those devices
and the users that come along with them.

01:02:05.290 --> 01:02:06.029
[ Applause ]

