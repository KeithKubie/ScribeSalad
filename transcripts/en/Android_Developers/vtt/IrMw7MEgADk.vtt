WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.862
[MUSIC PLAYING]

00:00:08.119 --> 00:00:09.680
CHET HAASE: Hello.

00:00:09.680 --> 00:00:11.060
Welcome to another talk.

00:00:13.517 --> 00:00:15.100
Welcome to Modern
Android Development.

00:00:15.100 --> 00:00:16.600
I should point out,
before we start,

00:00:16.600 --> 00:00:18.937
that this sun is a lot
brighter than I am,

00:00:18.937 --> 00:00:20.020
so we may have to do this.

00:00:20.020 --> 00:00:21.978
ROMAIN GUY: So we can
either put on the glasses

00:00:21.978 --> 00:00:24.190
and not see the slides, or
don't put on the glasses

00:00:24.190 --> 00:00:26.080
and not see anything.

00:00:26.080 --> 00:00:27.370
So that's going to be fun.

00:00:27.370 --> 00:00:29.720
CHET HAASE: We'll see
how this goes today.

00:00:29.720 --> 00:00:31.500
Welcome to Modern
Android Development.

00:00:31.500 --> 00:00:33.375
I'm Chet Haase from the
Android toolkit team.

00:00:33.375 --> 00:00:35.958
ROMAIN GUY: And I'm Romain Guy
from the Android framework team

00:00:35.958 --> 00:00:36.625
slash something.

00:00:36.625 --> 00:00:39.041
CHET HAASE: And we're going
to talk about a bunch of stuff

00:00:39.041 --> 00:00:41.290
that you probably already
know, but it occurred to us

00:00:41.290 --> 00:00:44.650
that we have given you advice
and information about how

00:00:44.650 --> 00:00:47.240
to develop good apps for
Android over the years.

00:00:47.240 --> 00:00:50.530
And that information has
changed over the years

00:00:50.530 --> 00:00:53.050
as we've introduced new
capabilities, new APIs,

00:00:53.050 --> 00:00:56.439
new performance on the
platform, all kinds of things.

00:00:56.439 --> 00:00:57.730
And so it's a little confusing.

00:00:57.730 --> 00:00:59.188
You could go search
for information

00:00:59.188 --> 00:01:01.450
even on some of our
docs site, and maybe

00:01:01.450 --> 00:01:04.180
get information
that doesn't really

00:01:04.180 --> 00:01:06.310
apply to a lot of
situations currently.

00:01:06.310 --> 00:01:07.810
So we wanted to
wrap it all together

00:01:07.810 --> 00:01:11.507
and say, here's our current 2018
view of the important things

00:01:11.507 --> 00:01:12.590
to think about in Android.

00:01:12.590 --> 00:01:14.890
ROMAIN GUY: Android is
10 years old this year,

00:01:14.890 --> 00:01:17.320
and yeah, like Chet said, a
lot of outdated information.

00:01:17.320 --> 00:01:19.450
Sometimes, I see blogs
on stack overflow,

00:01:19.450 --> 00:01:21.610
someone being really
mad about something

00:01:21.610 --> 00:01:23.140
that we said 10 years ago.

00:01:23.140 --> 00:01:23.781
Don't be mad.

00:01:23.781 --> 00:01:24.280
It's OK.

00:01:24.280 --> 00:01:25.030
Things change.

00:01:25.030 --> 00:01:26.822
Things evolve.

00:01:26.822 --> 00:01:28.030
It's not because we hate you.

00:01:28.030 --> 00:01:29.590
It's not because we were wrong.

00:01:29.590 --> 00:01:31.881
It's because it was a different
time-- different needs,

00:01:31.881 --> 00:01:32.840
different devices.

00:01:32.840 --> 00:01:34.682
So we're going to talk
about some of that.

00:01:34.682 --> 00:01:36.640
Just to make sure you
understand the difference

00:01:36.640 --> 00:01:38.380
between the modern
way of doing things

00:01:38.380 --> 00:01:40.330
and the old way of
doing things, we

00:01:40.330 --> 00:01:43.000
have a slight hint
on the slides.

00:01:43.000 --> 00:01:47.120
So some of the slides are
going to look like this.

00:01:47.120 --> 00:01:49.360
CHET HAASE: So let us begin.

00:01:49.360 --> 00:01:51.230
So let's take a
look at a timeline.

00:01:51.230 --> 00:01:54.670
This is sort of all the
history of Android over time.

00:01:54.670 --> 00:01:58.750
So 1.0 came out
in 2008, and then

00:01:58.750 --> 00:02:00.880
apparently, we didn't do
much for several years.

00:02:00.880 --> 00:02:01.739
[LAUGHTER]

00:02:01.739 --> 00:02:03.280
I don't know what
was going on there.

00:02:03.280 --> 00:02:05.590
I just couldn't think of
the things to put in there.

00:02:05.590 --> 00:02:08.556
Optimize, optimize, optimize.

00:02:08.556 --> 00:02:09.930
And then Android
Studio came out.

00:02:09.930 --> 00:02:10.199
What's that?

00:02:10.199 --> 00:02:11.009
ROMAIN GUY:
According to the web,

00:02:11.009 --> 00:02:12.480
we were busy building bad APIs.

00:02:12.480 --> 00:02:13.864
[LAUGHTER]

00:02:13.864 --> 00:02:16.280
CHET HAASE: Apparently, those
weren't the ones you wanted,

00:02:16.280 --> 00:02:18.370
so we've worked better
at that over the years.

00:02:18.370 --> 00:02:20.854
So Android Studio came out,
so we changed from Eclipse

00:02:20.854 --> 00:02:22.270
into Android Studio,
where now, we

00:02:22.270 --> 00:02:24.250
were building in
richer capabilities

00:02:24.250 --> 00:02:25.910
than we could at the time.

00:02:25.910 --> 00:02:26.770
Art came out.

00:02:26.770 --> 00:02:32.050
It was off by default
in KitKat, and it was

00:02:32.050 --> 00:02:33.970
the only runtime in Lollipop.

00:02:33.970 --> 00:02:36.580
This is huge, as you'll see
in some of our recommendations

00:02:36.580 --> 00:02:38.440
there, because it
really has changed,

00:02:38.440 --> 00:02:40.480
over time, the way we
look at the way you

00:02:40.480 --> 00:02:42.550
should write your code.

00:02:42.550 --> 00:02:45.250
Prior Dalvik information
does not necessarily

00:02:45.250 --> 00:02:46.900
apply in an Art world.

00:02:46.900 --> 00:02:48.280
Recycler view was released.

00:02:48.280 --> 00:02:51.056
Important because it was
a better version of List

00:02:51.056 --> 00:02:52.180
View with more flexibility.

00:02:52.180 --> 00:02:54.520
But also, we started
releasing components

00:02:54.520 --> 00:02:56.020
in the support
library disconnected

00:02:56.020 --> 00:02:57.940
from platform
releases, which means

00:02:57.940 --> 00:02:59.890
you could use these
new capabilities

00:02:59.890 --> 00:03:02.050
in your applications
across all the releases

00:03:02.050 --> 00:03:03.420
that you cared about.

00:03:03.420 --> 00:03:05.490
A little while later,
we had Constraint Layout

00:03:05.490 --> 00:03:07.210
built into Android Studio--

00:03:07.210 --> 00:03:09.970
a richer way of actually
designing your APIs, as opposed

00:03:09.970 --> 00:03:13.360
to the rich way of
typing XML directly.

00:03:13.360 --> 00:03:16.239
Kotlin-- I think that
came out last year.

00:03:16.239 --> 00:03:16.780
I don't know.

00:03:16.780 --> 00:03:19.390
Some IO conference or something.

00:03:19.390 --> 00:03:21.820
Architecture Components--
these were announced last year.

00:03:21.820 --> 00:03:23.290
1.0 in the fall.

00:03:23.290 --> 00:03:25.000
New way of doing
things, where we

00:03:25.000 --> 00:03:26.830
are trying to solve,
or at least help

00:03:26.830 --> 00:03:29.110
with, a lot of complex
problems with Android,

00:03:29.110 --> 00:03:31.300
and taking feedback
from the community

00:03:31.300 --> 00:03:33.880
and iterating on that to
create developer APIs that

00:03:33.880 --> 00:03:35.380
make things easier for you.

00:03:35.380 --> 00:03:36.670
That is the whole goal.

00:03:36.670 --> 00:03:39.024
Studio Profilers,
a much richer way

00:03:39.024 --> 00:03:41.440
for actually figuring out what
the performance metrics are

00:03:41.440 --> 00:03:42.670
for your application.

00:03:42.670 --> 00:03:45.010
KTx, the extension
library that came out

00:03:45.010 --> 00:03:46.880
a couple of months
ago for Kotlin.

00:03:46.880 --> 00:03:48.870
And recently, the
Paging Library came out

00:03:48.870 --> 00:03:50.860
and went 1.0 just this week.

00:03:50.860 --> 00:03:53.020
So this is sort of a scope
of some of the things

00:03:53.020 --> 00:03:54.310
that have happened over time.

00:03:54.310 --> 00:03:58.030
I'm pretty sure there was more
going on between 2008 and 2013.

00:03:58.030 --> 00:03:59.447
I just can't
remember what it was.

00:03:59.447 --> 00:04:00.363
ROMAIN GUY: All right.

00:04:00.363 --> 00:04:01.780
We're going to start with tools.

00:04:01.780 --> 00:04:03.670
Here's a tool that you may know.

00:04:03.670 --> 00:04:06.250
How many of you have used
this tool, Hierarchy Viewer?

00:04:06.250 --> 00:04:07.540
Oh, that's pretty good.

00:04:07.540 --> 00:04:08.486
Not everyone.

00:04:08.486 --> 00:04:10.360
So that was our tool
called Hierarchy Viewer.

00:04:10.360 --> 00:04:11.590
It was part of the SDK.

00:04:11.590 --> 00:04:13.840
It was a stand
alone application.

00:04:13.840 --> 00:04:16.149
There was actually another
version before that one.

00:04:16.149 --> 00:04:18.730
That was the one that I
originally wrote in a weekend

00:04:18.730 --> 00:04:21.970
because I needed a debugging
tool to optimize the platform.

00:04:21.970 --> 00:04:24.760
And for some reason, we
started shipping it in the SDK.

00:04:24.760 --> 00:04:26.110
It wasn't the fastest tool.

00:04:26.110 --> 00:04:28.300
It wasn't the prettiest tool.

00:04:28.300 --> 00:04:31.000
Actually, this one was built
by someone who, funnily enough,

00:04:31.000 --> 00:04:33.310
was spending a lot of
time actually sleeping

00:04:33.310 --> 00:04:34.240
at their desk.

00:04:34.240 --> 00:04:35.340
That was very interesting.

00:04:35.340 --> 00:04:36.860
I never used that
technique before.

00:04:36.860 --> 00:04:38.800
It didn't quite work.

00:04:38.800 --> 00:04:41.210
So now, we replaced it
with something much better,

00:04:41.210 --> 00:04:42.210
called Layout Inspector.

00:04:42.210 --> 00:04:44.425
It's part of Android Studio.

00:04:44.425 --> 00:04:46.300
One of the nice benefits
is that you can open

00:04:46.300 --> 00:04:48.850
multiple inspections at once.

00:04:48.850 --> 00:04:50.720
It's a lot, lot faster.

00:04:50.720 --> 00:04:53.170
So if you haven't used
that tool, go use it.

00:04:53.170 --> 00:04:56.320
It's a very easy way to
analyze your hierarchy

00:04:56.320 --> 00:04:58.990
and debug various things
like embedding and margining,

00:04:58.990 --> 00:05:02.350
and even performance sometimes,
if you have too many views that

00:05:02.350 --> 00:05:03.962
overlap each other.

00:05:03.962 --> 00:05:07.200
Here's another one that's the
old way of profiling the code.

00:05:07.200 --> 00:05:08.617
That was called Trace View.

00:05:08.617 --> 00:05:10.450
So Trace View is a tool
that already existed

00:05:10.450 --> 00:05:13.900
when I joined the Android team
in 2007, so it's been around

00:05:13.900 --> 00:05:14.650
for quite a while.

00:05:14.650 --> 00:05:17.160
Here, we see it in
action inside of Eclipse.

00:05:17.160 --> 00:05:18.840
It used to be its
own stand alone tool.

00:05:18.840 --> 00:05:20.840
So one of the issues that
we had with Trace View

00:05:20.840 --> 00:05:24.000
is the original version was
an instrumented profiler,

00:05:24.000 --> 00:05:25.300
so there was a lot of overhead.

00:05:25.300 --> 00:05:27.810
It was running on every
method that was invoked.

00:05:27.810 --> 00:05:29.486
It was running in
interpreting mode.

00:05:29.486 --> 00:05:31.360
And so you couldn't
really trust the numbers.

00:05:31.360 --> 00:05:34.470
So when it said, this method
took three milliseconds,

00:05:34.470 --> 00:05:35.620
that wasn't true.

00:05:35.620 --> 00:05:38.190
The method actually was
a lot faster than that,

00:05:38.190 --> 00:05:41.040
and the only thing you could
do is compare the relative time

00:05:41.040 --> 00:05:42.600
between different methods.

00:05:42.600 --> 00:05:44.940
And even that was difficult
because if a method was

00:05:44.940 --> 00:05:47.560
invoking native code, the
native code was not affected.

00:05:47.560 --> 00:05:49.620
So any method
invoking native code

00:05:49.620 --> 00:05:53.130
was skewed because numbers
were just all so wrong.

00:05:53.130 --> 00:05:54.540
Over the years,
we added sampling

00:05:54.540 --> 00:05:56.750
profiling to this tool.

00:05:56.750 --> 00:05:59.100
But still, it was
very difficult to use.

00:05:59.100 --> 00:06:01.290
Only a few of us even
were using it internally

00:06:01.290 --> 00:06:04.140
because it wasn't that great.

00:06:04.140 --> 00:06:06.550
A few years later, thankfully,
we introduced Systrace.

00:06:06.550 --> 00:06:08.466
So the big benefit of
Systrace over Trace View

00:06:08.466 --> 00:06:10.380
is that it gives you
a comprehensive view

00:06:10.380 --> 00:06:11.274
of the entire system.

00:06:11.274 --> 00:06:12.690
Trace View tells
you how much time

00:06:12.690 --> 00:06:16.140
you're spending on every line
of code inside your application,

00:06:16.140 --> 00:06:16.920
basically.

00:06:16.920 --> 00:06:18.390
But sometimes,
performance issues

00:06:18.390 --> 00:06:19.800
come from somewhere
else in the system.

00:06:19.800 --> 00:06:21.240
Maybe you're
blocked on something

00:06:21.240 --> 00:06:23.030
that's in a different process.

00:06:23.030 --> 00:06:25.710
So Systrace gives you
that view that you needed.

00:06:25.710 --> 00:06:28.920
Before that, we were
completely in the blind.

00:06:28.920 --> 00:06:31.260
And now, we have
new profilers that

00:06:31.260 --> 00:06:33.120
have been introduced
in Android Studio.

00:06:33.120 --> 00:06:35.400
I think they're
part of 3.2 or 3.1.

00:06:35.400 --> 00:06:36.880
I don't really remember.

00:06:36.880 --> 00:06:39.141
But if you go to
the Profiler tab,

00:06:39.141 --> 00:06:41.140
you're going to see a
real time graph of the CPU

00:06:41.140 --> 00:06:43.080
usage of your application
and the memories [INAUDIBLE]

00:06:43.080 --> 00:06:44.220
of your application.

00:06:44.220 --> 00:06:46.235
And if you double-click
on the CPU graph,

00:06:46.235 --> 00:06:47.610
you're going to
get to that view.

00:06:47.610 --> 00:06:50.220
It looks very similar
to Trace View.

00:06:50.220 --> 00:06:52.350
Again, it's a lot
faster, and it lets

00:06:52.350 --> 00:06:55.320
you do native code profiling,
instrumented profiling,

00:06:55.320 --> 00:06:58.590
sampling profiling,
and even Systrace.

00:06:58.590 --> 00:07:01.660
So this is the tool that you
should be using from now on,

00:07:01.660 --> 00:07:04.470
and this is what these
graphs look like.

00:07:04.470 --> 00:07:07.650
So we have, now, I
believe, four graphs.

00:07:07.650 --> 00:07:10.639
We have the CPU one, the
memory one, the network one,

00:07:10.639 --> 00:07:11.430
and the energy one.

00:07:11.430 --> 00:07:13.388
I've never used the
network one because I'm not

00:07:13.388 --> 00:07:15.390
sure what servers
are for, but I'm

00:07:15.390 --> 00:07:17.280
sure you guys
understand that and you

00:07:17.280 --> 00:07:19.914
will make good use of it.

00:07:19.914 --> 00:07:21.330
And that's what
it looks like when

00:07:21.330 --> 00:07:22.980
you enter the CPU profiler.

00:07:22.980 --> 00:07:24.022
So you get a flame graph.

00:07:24.022 --> 00:07:25.938
You have different ways
of analyzing the data.

00:07:25.938 --> 00:07:27.360
The one I like is
the flame graph.

00:07:27.360 --> 00:07:29.550
It's going to colorize
all the function

00:07:29.550 --> 00:07:31.286
calls with different
colors, depending

00:07:31.286 --> 00:07:32.410
on how much time they take.

00:07:32.410 --> 00:07:35.277
So anything that shows in
red shades or dark orange

00:07:35.277 --> 00:07:37.110
are the bottlenecks
inside your application.

00:07:37.110 --> 00:07:40.140
So a very easy way to drill
down inside your application

00:07:40.140 --> 00:07:42.420
and identify the bottlenecks.

00:07:42.420 --> 00:07:45.450
This is the native profiler.

00:07:45.450 --> 00:07:48.130
It's available starting
on Android 8.0,

00:07:48.130 --> 00:07:51.890
so you need Oreo or higher
to be able to run it.

00:07:51.890 --> 00:07:53.930
And I mentioned briefly
the new memory profiler,

00:07:53.930 --> 00:07:56.160
so to do memory
tracking, we used

00:07:56.160 --> 00:07:57.690
to use this tool called DDMS.

00:07:57.690 --> 00:07:59.700
Again, it was a
stand alone tool.

00:07:59.700 --> 00:08:01.430
It was built on the
eclipse platform.

00:08:01.430 --> 00:08:04.080
It was really difficult
to use because it was not

00:08:04.080 --> 00:08:04.860
part of the ID.

00:08:04.860 --> 00:08:07.060
At some point, we added
it back in the ID.

00:08:07.060 --> 00:08:09.120
And that was pretty
much the only good way

00:08:09.120 --> 00:08:11.070
you could see whether
or not you are locating

00:08:11.070 --> 00:08:12.740
memory in the wrong places.

00:08:12.740 --> 00:08:14.490
For instance, whether
you're doing drawing

00:08:14.490 --> 00:08:17.220
or whether you're doing
layout or touch handling.

00:08:17.220 --> 00:08:19.410
And now, it's part
of, again, Studio.

00:08:19.410 --> 00:08:21.750
So when you see this
graph that shows you,

00:08:21.750 --> 00:08:24.000
in real time, the
memory usage, you

00:08:24.000 --> 00:08:25.750
can even see the
different buckets.

00:08:25.750 --> 00:08:26.850
So it's going to tell you
how much memory you're

00:08:26.850 --> 00:08:29.130
using on your Java heap,
or how much native memory

00:08:29.130 --> 00:08:31.570
you're using, how much
graphics memory you're using.

00:08:31.570 --> 00:08:34.260
So you can pinpoint where
the problem is coming from.

00:08:34.260 --> 00:08:36.560
You can also create a
slice, as you see on screen.

00:08:36.560 --> 00:08:39.059
It's going to show you all the
allocations during that time.

00:08:39.059 --> 00:08:41.789
You can see the stack traces,
you can fold the references.

00:08:41.789 --> 00:08:46.650
You don't have to dump the
edge profile, converted

00:08:46.650 --> 00:08:47.850
to using edge [INAUDIBLE].

00:08:47.850 --> 00:08:50.880
You don't have to run jhat and
see these horrible-looking web

00:08:50.880 --> 00:08:52.622
UI that you used to have to use.

00:08:52.622 --> 00:08:54.830
It doesn't do everything
yet, so sometimes, you still

00:08:54.830 --> 00:08:56.820
have to go to jhat, but
it's a very good way

00:08:56.820 --> 00:08:58.220
to get started if
you have memory

00:08:58.220 --> 00:09:00.640
issues inside your application.

00:09:00.640 --> 00:09:03.380
Layout Design used
to be like this.

00:09:03.380 --> 00:09:04.505
It's Article Design.

00:09:04.505 --> 00:09:06.630
And it's interesting because
when Android came out,

00:09:06.630 --> 00:09:09.180
it was very hard to convince
everyone to move to XML.

00:09:09.180 --> 00:09:10.690
Remember, a lot of
angry developers

00:09:10.690 --> 00:09:13.970
really wanted to write
Java code to build the UI.

00:09:13.970 --> 00:09:15.442
And now, we've given you this.

00:09:15.442 --> 00:09:17.400
So this is the constraint
layout visual editor,

00:09:17.400 --> 00:09:19.108
and now we have a lot
of angry developers

00:09:19.108 --> 00:09:22.230
who would love to use only
XML, and not the visual tool.

00:09:22.230 --> 00:09:24.840
So I guess we have to
invent something new just

00:09:24.840 --> 00:09:26.779
as a decoy to make you
start using this one.

00:09:26.779 --> 00:09:28.320
CHET HAASE: I think
the only constant

00:09:28.320 --> 00:09:31.170
is that engineers will
be unhappy with whatever

00:09:31.170 --> 00:09:32.370
new option you give them.

00:09:32.370 --> 00:09:34.920
ROMAIN GUY: Especially
if they're French.

00:09:34.920 --> 00:09:38.190
And if you went to the
What's New in Tools talk,

00:09:38.190 --> 00:09:40.700
you've seen a sneak peek of
a new tool for motion layout

00:09:40.700 --> 00:09:43.060
to create animations
using constraint layout.

00:09:43.060 --> 00:09:45.690
Nicola and John are going
to show that again, I

00:09:45.690 --> 00:09:47.850
think, tomorrow or Thursday.

00:09:47.850 --> 00:09:49.140
So go find that talk.

00:09:49.140 --> 00:09:52.519
And so we want to make it clear
that this visual designer is

00:09:52.519 --> 00:09:53.310
only the beginning.

00:09:53.310 --> 00:09:54.601
There's so much more we can do.

00:09:54.601 --> 00:09:56.580
We haven't had time to
build everything yet.

00:09:56.580 --> 00:10:00.390
But this new motion layout
editor is the next step.

00:10:00.390 --> 00:10:04.290
And building animations with
visual feedback-- real time

00:10:04.290 --> 00:10:08.880
visual feedback-- is a
lot nicer than using XML.

00:10:08.880 --> 00:10:12.020
Runtime and language, Chet.

00:10:12.020 --> 00:10:12.820
CHET HAASE: Sure.

00:10:12.820 --> 00:10:13.890
So Dalvik--

00:10:16.830 --> 00:10:18.384
ROMAIN GUY: Don't be so sad.

00:10:18.384 --> 00:10:20.050
CHET HAASE: Dalvik
was awesome for doing

00:10:20.050 --> 00:10:21.425
what it was designed
to do, which

00:10:21.425 --> 00:10:23.920
was it was optimized for space.

00:10:23.920 --> 00:10:28.570
When the G1 came out, it
had 192 megs, 48 of which--

00:10:28.570 --> 00:10:29.500
ROMAIN GUY: Well, 64--

00:10:29.500 --> 00:10:30.970
a small portion was accessible
for the applications.

00:10:30.970 --> 00:10:32.678
CHET HAASE: A very
small amount of memory

00:10:32.678 --> 00:10:35.230
was actually available
for applications to use,

00:10:35.230 --> 00:10:37.420
so Dalvik could
not, as a runtime,

00:10:37.420 --> 00:10:40.331
take up a bunch of memory
for itself or all the heap

00:10:40.331 --> 00:10:41.830
and where it needed
to store things.

00:10:41.830 --> 00:10:45.460
So that meant that as
devices got better,

00:10:45.460 --> 00:10:47.980
as memory got larger,
it didn't necessarily

00:10:47.980 --> 00:10:51.220
have the capabilities to
optimize in the wholesale way

00:10:51.220 --> 00:10:52.030
that we needed to.

00:10:52.030 --> 00:10:54.070
At some point, they
basically started

00:10:54.070 --> 00:10:57.340
from scratch on the Art
runtime that, as we said,

00:10:57.340 --> 00:11:00.920
came out in KitKat and
was default in Lollipop.

00:11:00.920 --> 00:11:03.520
But back in the Dalvik
days, we basically

00:11:03.520 --> 00:11:05.260
had recommendations
that came from that

00:11:05.260 --> 00:11:07.540
because of things
like allocations

00:11:07.540 --> 00:11:08.680
being really expensive.

00:11:08.680 --> 00:11:11.530
It had to walk the heap and
find a place to put this thing,

00:11:11.530 --> 00:11:13.700
and the heap got
fragmented over time,

00:11:13.700 --> 00:11:16.320
which meant that even if it
had a bunch of space there,

00:11:16.320 --> 00:11:18.970
it didn't necessarily have a
lot of contiguous space in which

00:11:18.970 --> 00:11:21.670
to find a place to
put that object.

00:11:21.670 --> 00:11:24.100
And then collections were
also really expensive.

00:11:24.100 --> 00:11:26.320
You ended up-- you would
allocate things over time,

00:11:26.320 --> 00:11:28.610
and then eventually, it is
going to run out of memory.

00:11:28.610 --> 00:11:29.740
And when it does that--

00:11:29.740 --> 00:11:31.060
when you're in the
middle of an animation,

00:11:31.060 --> 00:11:32.601
you're on the UI
thread, and it says,

00:11:32.601 --> 00:11:34.480
I need to allocate
space for a bitmap--

00:11:34.480 --> 00:11:36.910
can't find the space,
better run a GC.

00:11:36.910 --> 00:11:39.400
You're probably going to
lose two or three frames just

00:11:39.400 --> 00:11:42.250
because Dalvik needed to
actually collect all the items

00:11:42.250 --> 00:11:45.550
without references anymore.

00:11:45.550 --> 00:11:48.190
So some of the recommendations
that we had were basically

00:11:48.190 --> 00:11:50.830
avoid allocating things
whenever you can.

00:11:50.830 --> 00:11:53.770
That's certainly the way that we
live life inside the framework

00:11:53.770 --> 00:11:55.720
because we are your
inner loop, but we also

00:11:55.720 --> 00:11:58.450
recommended that application
developers do that.

00:11:58.450 --> 00:12:00.370
One of the recommendations
that I believe

00:12:00.370 --> 00:12:02.170
the community has
seen batted around

00:12:02.170 --> 00:12:04.600
was don't use enums, right?

00:12:04.600 --> 00:12:07.870
Because it turns out
an enum structure--

00:12:07.870 --> 00:12:12.080
the class structure-- is a whole
lot bigger than an int object,

00:12:12.080 --> 00:12:12.580
right?

00:12:12.580 --> 00:12:14.020
And we use ints
all over the place

00:12:14.020 --> 00:12:15.970
because we try to minimize
the amount of memory we're

00:12:15.970 --> 00:12:18.460
taking up, and we also try to
minimize the amount of time

00:12:18.460 --> 00:12:20.530
we're creating a new
object, as opposed

00:12:20.530 --> 00:12:22.900
to passing primitive
types around.

00:12:22.900 --> 00:12:25.300
We also said that
primitive types are cool.

00:12:25.300 --> 00:12:27.030
Ints are cool, floats are cool.

00:12:27.030 --> 00:12:29.050
Capital I integer, not so cool.

00:12:29.050 --> 00:12:31.270
Also, what's not
cool is autoboxing.

00:12:31.270 --> 00:12:34.540
So when you're using
standard collection classes,

00:12:34.540 --> 00:12:36.970
if you have a bunch of
information stored in these

00:12:36.970 --> 00:12:39.550
primitive types and they're
being autoboxed in and out,

00:12:39.550 --> 00:12:41.800
or if you're using other
patterns and approaches that

00:12:41.800 --> 00:12:44.652
cause these things to
get created into objects,

00:12:44.652 --> 00:12:46.360
you would see, in the
tools that we had--

00:12:46.360 --> 00:12:48.180
like allocation
tracker, at the time--

00:12:48.180 --> 00:12:49.990
that you'd be
autoboxing and causing

00:12:49.990 --> 00:12:51.700
allocations along the fly.

00:12:51.700 --> 00:12:53.710
And then eventually,
GC kicks in,

00:12:53.710 --> 00:12:56.500
and you hate yourself
just a little bit more.

00:12:56.500 --> 00:12:59.290
So modern world,
we now have Art.

00:12:59.290 --> 00:13:01.120
It is optimized for performance.

00:13:01.120 --> 00:13:04.430
It was created from the ground
up not to optimize for memory,

00:13:04.430 --> 00:13:05.960
but to optimize for performance.

00:13:05.960 --> 00:13:08.590
And this is performance in
terms of method call stuff,

00:13:08.590 --> 00:13:12.820
but it's also optimized for
allocations and collections.

00:13:12.820 --> 00:13:14.770
Way faster allocations
and collections

00:13:14.770 --> 00:13:15.980
for a few different reasons.

00:13:15.980 --> 00:13:19.060
One of those is it has it
set aside for large objects.

00:13:19.060 --> 00:13:21.340
So instead of putting
everything in the same heap,

00:13:21.340 --> 00:13:24.010
and then having to find
space for large objects

00:13:24.010 --> 00:13:26.710
amidst all the tiny ones,
it puts all the bitmaps

00:13:26.710 --> 00:13:29.200
in a separate heap, all
the large objects, overall.

00:13:29.200 --> 00:13:33.190
It's way easier to find space
for those large objects,

00:13:33.190 --> 00:13:35.530
and then the small objects
go in the separate heap.

00:13:35.530 --> 00:13:38.950
Also, really cool,
it can defragment.

00:13:38.950 --> 00:13:41.930
Dalvik could not defragment,
so it would allocate over time,

00:13:41.930 --> 00:13:43.837
and eventually, there
wasn't enough space

00:13:43.837 --> 00:13:44.920
for that thing you needed.

00:13:44.920 --> 00:13:47.197
So you would get these
obscure error messages

00:13:47.197 --> 00:13:49.780
where it said that it couldn't
find a megabyte because there's

00:13:49.780 --> 00:13:53.050
only 48 megabytes free.

00:13:53.050 --> 00:13:55.120
Doesn't make a lot of
sense until you realize,

00:13:55.120 --> 00:13:57.280
well, it's probably that
the heap is fragmented

00:13:57.280 --> 00:13:58.930
and we can't really
do much about that.

00:13:58.930 --> 00:13:59.980
Now we can.

00:13:59.980 --> 00:14:01.630
In Art, it defragments the heap.

00:14:01.630 --> 00:14:04.750
In an earlier release, it would
defragment when the application

00:14:04.750 --> 00:14:05.914
was in the background.

00:14:05.914 --> 00:14:08.080
Now, it can actually
defragment when the application

00:14:08.080 --> 00:14:10.450
is in the foreground, as well.

00:14:10.450 --> 00:14:11.690
So way better.

00:14:11.690 --> 00:14:14.290
So the recommendations
that we have now are

00:14:14.290 --> 00:14:16.330
go ahead and allocate
when necessary.

00:14:16.330 --> 00:14:17.050
It's OK.

00:14:17.050 --> 00:14:21.760
In fact, if you use
enums, I don't care.

00:14:21.760 --> 00:14:23.232
Go ahead.

00:14:23.232 --> 00:14:25.156
[CHEERING]

00:14:27.080 --> 00:14:30.110
Apparently, you do care,
so I hope you enjoy them.

00:14:30.110 --> 00:14:32.720
We still, as a rule,
tend to not use them

00:14:32.720 --> 00:14:34.282
in a lot of framework
code and APIs.

00:14:34.282 --> 00:14:35.240
ROMAIN GUY: I use them.

00:14:35.240 --> 00:14:37.740
CHET HAASE: They are there
sometimes, but as I said,

00:14:37.740 --> 00:14:39.000
we are still the inner loop.

00:14:39.000 --> 00:14:41.210
So we tend to be way
more conservative

00:14:41.210 --> 00:14:45.110
than you necessarily need to
be in your application code.

00:14:45.110 --> 00:14:47.330
Use appropriate types.

00:14:47.330 --> 00:14:49.320
I still think primitive
types are really cool,

00:14:49.320 --> 00:14:50.069
but you know what?

00:14:50.069 --> 00:14:52.820
If you need to use a collection
with an object type, that's OK.

00:14:52.820 --> 00:14:57.410
But be aware that these phones
are still constrained devices.

00:14:57.410 --> 00:15:01.430
Memory may not be 48
or 64 megs available,

00:15:01.430 --> 00:15:04.610
but it is still being shared
with everything else being

00:15:04.610 --> 00:15:06.800
used, being run on that system.

00:15:06.800 --> 00:15:08.804
Also, batteries are
really important.

00:15:08.804 --> 00:15:10.220
It's important to
let that battery

00:15:10.220 --> 00:15:11.790
last as long as possible.

00:15:11.790 --> 00:15:14.390
So if you're constantly
doing things all the time--

00:15:14.390 --> 00:15:17.000
if you're constantly generating
garbage and collecting it,

00:15:17.000 --> 00:15:18.860
sure, Art is a lot
faster at that.

00:15:18.860 --> 00:15:21.260
But Art still has to
do the work of actually

00:15:21.260 --> 00:15:24.200
allocating and collecting, and
all of that stuff uses power.

00:15:24.200 --> 00:15:28.010
So it's still good to remember
that the battery uses power

00:15:28.010 --> 00:15:30.140
and that maybe you should
be conservative on what

00:15:30.140 --> 00:15:31.370
you're trying to do.

00:15:31.370 --> 00:15:34.880
And also, like the framework,
be aware of the inner loop

00:15:34.880 --> 00:15:36.230
bottlenecks.

00:15:36.230 --> 00:15:37.760
Don't do things in
a tight loop that

00:15:37.760 --> 00:15:39.124
may cause performance problems.

00:15:39.124 --> 00:15:40.790
ROMAIN GUY: So when
Android was started,

00:15:40.790 --> 00:15:43.370
the team decided to go with
the Java programming language

00:15:43.370 --> 00:15:44.896
to create
applications, and there

00:15:44.896 --> 00:15:46.020
were many reasons for that.

00:15:46.020 --> 00:15:48.380
The main one was it was an
extremely popular language.

00:15:48.380 --> 00:15:49.550
There were millions
of developers who

00:15:49.550 --> 00:15:51.020
knew how to use this language.

00:15:51.020 --> 00:15:53.690
There were many
excellent and free tools.

00:15:53.690 --> 00:15:56.330
So it was really helpful
for the quick adoption

00:15:56.330 --> 00:15:58.130
of the Android platform.

00:15:58.130 --> 00:15:59.960
Over time, we have
been, sometimes,

00:15:59.960 --> 00:16:03.080
a little bit slow at adopting
new versions of the language.

00:16:03.080 --> 00:16:06.230
We recently started supporting
the Java programming language

00:16:06.230 --> 00:16:07.790
version 1.8.

00:16:07.790 --> 00:16:11.810
I think they are reaching 1.10.

00:16:11.810 --> 00:16:13.520
But it served us for many years.

00:16:13.520 --> 00:16:15.841
Last year, thankfully,
we announced full support

00:16:15.841 --> 00:16:17.340
for the Kotlin
programming language.

00:16:17.340 --> 00:16:19.201
How many of you are
using it right now?

00:16:19.201 --> 00:16:19.700
[CHEERING]

00:16:19.700 --> 00:16:20.600
All right.

00:16:20.600 --> 00:16:21.641
CHET HAASE: Keep them up.

00:16:21.641 --> 00:16:22.994
One, two, three, four.

00:16:22.994 --> 00:16:24.160
ROMAIN GUY: Almost everyone.

00:16:24.160 --> 00:16:25.850
CHET HAASE: It was
definitely more than five.

00:16:25.850 --> 00:16:27.350
ROMAIN GUY: We'll
keep a few slides.

00:16:27.350 --> 00:16:29.150
So we announced it
last year in 2017.

00:16:29.150 --> 00:16:31.340
We're working in close
collaboration with JetBrains.

00:16:31.340 --> 00:16:34.840
We're making sure that our
tools work well with Kotlin,

00:16:34.840 --> 00:16:37.910
and then make sure that we have
access to the features we need.

00:16:37.910 --> 00:16:39.500
Overall, we like
it because it makes

00:16:39.500 --> 00:16:41.467
code more enjoyable
to read and to write,

00:16:41.467 --> 00:16:43.550
and we spend so much time
reading and writing code

00:16:43.550 --> 00:16:44.940
that it does matter.

00:16:44.940 --> 00:16:46.600
So I have a few examples here.

00:16:46.600 --> 00:16:47.490
They're going to
be hard to read,

00:16:47.490 --> 00:16:49.740
but it's OK, because you all
know how to write Kotlin.

00:16:49.740 --> 00:16:52.430
Those examples are taken
from the Kotlin extensions,

00:16:52.430 --> 00:16:54.520
so I'm going to go over
them really quickly.

00:16:54.520 --> 00:16:55.641
I like named parameters.

00:16:55.641 --> 00:16:57.890
You don't have to create
multiple overloads of methods

00:16:57.890 --> 00:16:59.390
or builders all the time.

00:16:59.390 --> 00:17:01.400
You can inline functions,
which is really useful

00:17:01.400 --> 00:17:04.400
when you create extensions, or
even when you create graphics

00:17:04.400 --> 00:17:06.500
code, for instance.

00:17:06.500 --> 00:17:09.020
We saw that.

00:17:09.020 --> 00:17:09.980
Operators.

00:17:09.980 --> 00:17:11.390
You can overload operators.

00:17:11.390 --> 00:17:13.440
You should be careful with that.

00:17:13.440 --> 00:17:16.819
You can abuse this quite a
bit, and I've done this myself.

00:17:16.819 --> 00:17:19.069
Once, I created an in
fix operator called X,

00:17:19.069 --> 00:17:21.740
because it looks like the
cross-product for vectors.

00:17:21.740 --> 00:17:22.609
Don't do that.

00:17:22.609 --> 00:17:24.650
It's a terrible idea.

00:17:24.650 --> 00:17:27.980
I put it on GitHub because
it's a terrible idea.

00:17:27.980 --> 00:17:31.460
You can do destructuring
assignment.

00:17:31.460 --> 00:17:33.440
So when you have
a POJO, we create

00:17:33.440 --> 00:17:36.260
methods called component
one, two, three, et cetera.

00:17:36.260 --> 00:17:38.167
Then you can do
multiple assignments

00:17:38.167 --> 00:17:39.000
in one line of code.

00:17:39.000 --> 00:17:42.500
So this is an example,
again, from Android KTx where

00:17:42.500 --> 00:17:44.297
we destructure an integer.

00:17:44.297 --> 00:17:46.130
So you don't have to
do shifting and masking

00:17:46.130 --> 00:17:48.980
of bytes and integers.

00:17:48.980 --> 00:17:51.300
We have data classes.

00:17:51.300 --> 00:17:53.720
Very easy way to create all
those getters and two string

00:17:53.720 --> 00:17:54.780
and equals and hashcode.

00:17:54.780 --> 00:17:56.446
So you don't have to,
and you don't even

00:17:56.446 --> 00:17:59.070
have to type the shortcut to
tell IntelliJ to do it for you.

00:17:59.070 --> 00:18:00.380
That's the level
of laziness that we

00:18:00.380 --> 00:18:01.421
have reached with Kotlin.

00:18:01.421 --> 00:18:04.070
So that's fantastic.

00:18:04.070 --> 00:18:05.650
And finally, yes.

00:18:05.650 --> 00:18:08.960
I just wanted to call out some
of the things that, to me, make

00:18:08.960 --> 00:18:11.090
Kotlin so appealing,
is very smart

00:18:11.090 --> 00:18:13.290
design decisions they've
made in language.

00:18:13.290 --> 00:18:15.200
And one of them,
for instance, is

00:18:15.200 --> 00:18:18.672
when a lambda is the last
parameter of a function,

00:18:18.672 --> 00:18:20.630
they have this special
syntax that you can use.

00:18:20.630 --> 00:18:21.890
You don't have to
pass the lambda

00:18:21.890 --> 00:18:23.230
as a parameter to the function.

00:18:23.230 --> 00:18:24.380
You can just open
the curly braces

00:18:24.380 --> 00:18:25.670
and put your code right there.

00:18:25.670 --> 00:18:27.629
It looks and feels
a lot more natural.

00:18:27.629 --> 00:18:30.170
So one of the things we're doing
now when we're designing new

00:18:30.170 --> 00:18:32.960
APIs in the platform--
starting with Android P--

00:18:32.960 --> 00:18:36.410
we make sure that our Java APIs
are full of these conventions.

00:18:36.410 --> 00:18:38.600
When we have a single
abstract method interface,

00:18:38.600 --> 00:18:40.972
we make sure that the parameter
that uses the interface

00:18:40.972 --> 00:18:42.680
goes at the end of
the list of parameters

00:18:42.680 --> 00:18:46.480
so that Kotlin
developers can benefit

00:18:46.480 --> 00:18:48.450
from this particular
feature in the language.

00:18:48.450 --> 00:18:49.908
And we're going to
do more and more

00:18:49.908 --> 00:18:54.500
of that in the support library
and all of our future APIs.

00:18:54.500 --> 00:18:56.680
So for those of you who
are not using Kotlin yet,

00:18:56.680 --> 00:18:58.790
a project can contain
both Kotlin and Java.

00:18:58.790 --> 00:19:01.275
You don't have to convert all
your application to Kotlin.

00:19:01.275 --> 00:19:03.650
The next class you add to your
application can be Kotlin,

00:19:03.650 --> 00:19:05.630
or you can convert
an existing class.

00:19:05.630 --> 00:19:07.020
We have a ton of lint checks.

00:19:07.020 --> 00:19:09.230
If there are things that
are missing, go tell Tor.

00:19:09.230 --> 00:19:11.330
It's going to write it
pretty much in front of you

00:19:11.330 --> 00:19:13.220
and commit it right away.

00:19:13.220 --> 00:19:16.705
It's kind of a machine when it
comes to writing lint checks.

00:19:16.705 --> 00:19:18.080
Check out the
Android extensions.

00:19:18.080 --> 00:19:20.130
Again, there's a
talk by Jake Wharton,

00:19:20.130 --> 00:19:21.902
I think, on Thursday
morning about it.

00:19:21.902 --> 00:19:24.110
It's going to talk about a
lot of interesting things.

00:19:24.110 --> 00:19:26.020
We also created the style guide.

00:19:26.020 --> 00:19:28.674
So those of you who are
still using our Java guide--

00:19:28.674 --> 00:19:30.090
I mean, we didn't
really have one,

00:19:30.090 --> 00:19:31.800
but if you're following
our source code,

00:19:31.800 --> 00:19:33.924
you're probably prefixing
your fields with M.

00:19:33.924 --> 00:19:36.340
You're going to be happy to
know that we're not doing that

00:19:36.340 --> 00:19:38.170
anymore with Kotlin.

00:19:38.170 --> 00:19:40.080
First, because we
don't really like it,

00:19:40.080 --> 00:19:41.455
and also because
you can't really

00:19:41.455 --> 00:19:44.020
do it because of the property
syntax in Kotlin, anyway.

00:19:44.020 --> 00:19:46.230
We also have an
interoperability guide.

00:19:46.230 --> 00:19:47.980
So if you're going
to be writing code

00:19:47.980 --> 00:19:50.770
that is meant to be consumed
by both Java developers

00:19:50.770 --> 00:19:52.510
and Kotlin developers,
[INAUDIBLE]

00:19:52.510 --> 00:19:54.460
that you're writing Java
code or Kotlin code,

00:19:54.460 --> 00:19:56.350
we have guides for
you that explain

00:19:56.350 --> 00:19:57.980
how you should be
writing your APIs

00:19:57.980 --> 00:20:01.717
so they can be used in a natural
manner in both languages.

00:20:01.717 --> 00:20:04.050
And those are the guides that
we are following ourselves

00:20:04.050 --> 00:20:07.150
for our new APIs in the platform
and the support libraries.

00:20:07.150 --> 00:20:09.070
CHET HAASE: Let's
talk about APIs.

00:20:09.070 --> 00:20:11.831
First of all,
layouts in Android,

00:20:11.831 --> 00:20:13.330
there are a bunch
of them, but these

00:20:13.330 --> 00:20:15.850
are kind of the major ones that
people dealt with over time.

00:20:15.850 --> 00:20:18.430
First of all, there
was AbsoluteLayout.

00:20:18.430 --> 00:20:20.839
And it's so easy to
use, why wouldn't you?

00:20:20.839 --> 00:20:22.630
Then you'd just tell
the view exactly where

00:20:22.630 --> 00:20:24.050
you want it to be, right?

00:20:24.050 --> 00:20:25.960
LinearLayout, you can
just nest those things

00:20:25.960 --> 00:20:28.630
as deeply as you want to
and get exactly the UI

00:20:28.630 --> 00:20:29.650
you're looking for.

00:20:29.650 --> 00:20:32.725
FrameLayout, it's fine.

00:20:32.725 --> 00:20:35.100
If you squint at it, it's kind
of like an AbsoluteLayout.

00:20:35.100 --> 00:20:37.350
ROMAIN GUY: That's the best
thing we can say about it.

00:20:37.350 --> 00:20:39.166
It's fine.

00:20:39.166 --> 00:20:40.540
CHET HAASE:
GridLayout, turns out

00:20:40.540 --> 00:20:42.470
it's a little bit
complicated to use,

00:20:42.470 --> 00:20:45.110
but we can figure that out,
and it has a lot of flexibility

00:20:45.110 --> 00:20:45.610
there.

00:20:45.610 --> 00:20:48.427
And RelativeLayout, we've
heard that it's expensive.

00:20:48.427 --> 00:20:50.260
Is this something we
should be using or not?

00:20:50.260 --> 00:20:53.360
So the modern world.

00:20:53.360 --> 00:20:55.170
Here's how we think
about AbsoluteLayout.

00:20:58.420 --> 00:21:00.568
ROMAIN GUY: We just
want to make it clear.

00:21:00.568 --> 00:21:04.061
[LAUGHTER AND APPLAUSE]

00:21:07.159 --> 00:21:09.450
CHET HAASE: The only reason
that this is not deprecated

00:21:09.450 --> 00:21:12.394
is because there is
one important class

00:21:12.394 --> 00:21:13.310
the subclass is from--

00:21:13.310 --> 00:21:14.390
ROMAIN GUY: No,
it is deprecated.

00:21:14.390 --> 00:21:15.390
It is deprecated.

00:21:15.390 --> 00:21:15.660
CHET HAASE: It is deprecated.

00:21:15.660 --> 00:21:15.930
OK.

00:21:15.930 --> 00:21:17.888
Well, we deprecated it,
and that's about as far

00:21:17.888 --> 00:21:20.400
as we can take it because web
view is in AbsoluteLayout.

00:21:20.400 --> 00:21:21.990
Sorry, don't use that.

00:21:21.990 --> 00:21:23.130
Hopefully, you're not.

00:21:23.130 --> 00:21:26.010
LinearLayout, it's actually
fine to still use, especially

00:21:26.010 --> 00:21:26.820
for simple cases.

00:21:26.820 --> 00:21:28.445
If you're deeply,
deeply nesting,

00:21:28.445 --> 00:21:29.820
then you're deeply,
deeply wrong,

00:21:29.820 --> 00:21:30.750
and there's a better solution.

00:21:30.750 --> 00:21:32.820
We'll get to it at the
bottom of the slide.

00:21:32.820 --> 00:21:35.550
FrameLayout, it's also
OK for simple use cases.

00:21:35.550 --> 00:21:37.200
You need to put that
one thing in there

00:21:37.200 --> 00:21:39.300
with appropriate
padding and margins.

00:21:39.300 --> 00:21:39.870
That's kind of what
it's there for.

00:21:39.870 --> 00:21:41.280
ROMAIN GUY: And the dirty
secret of FrameLayout

00:21:41.280 --> 00:21:43.200
is that it's an
AbsoluteLayout in this case.

00:21:43.200 --> 00:21:45.471
If you use margins
correctly, you basically

00:21:45.471 --> 00:21:47.220
have an AbsoluteLayout,
but don't do that.

00:21:47.220 --> 00:21:48.540
CHET HAASE: Don't do that.

00:21:48.540 --> 00:21:49.810
Don't do that.

00:21:49.810 --> 00:21:53.250
GridLayout-- it turns
out that it's really

00:21:53.250 --> 00:21:56.550
intended to be used with tools,
except the problem was we never

00:21:56.550 --> 00:21:59.080
actually wrote the tools.

00:21:59.080 --> 00:22:00.330
ROMAIN GUY: I think we forgot.

00:22:00.330 --> 00:22:01.996
CHET HAASE: Probably
not the best layout

00:22:01.996 --> 00:22:04.050
to use for your situation,
unless you already

00:22:04.050 --> 00:22:05.750
wrapped your head around it.

00:22:05.750 --> 00:22:06.674
OK.

00:22:06.674 --> 00:22:08.340
There may be better
solutions out there.

00:22:08.340 --> 00:22:11.140
RelativeLayout-- we believe
that ConstraintLayout is,

00:22:11.140 --> 00:22:12.390
in general, a better solution.

00:22:12.390 --> 00:22:14.515
I would think of it as a
subset of the capabilities

00:22:14.515 --> 00:22:15.439
of RelativeLayout.

00:22:15.439 --> 00:22:16.980
It has a lot of the
same capabilities

00:22:16.980 --> 00:22:19.200
of relative positioning
of children,

00:22:19.200 --> 00:22:20.890
with respect to each other.

00:22:20.890 --> 00:22:23.040
But it has way more
relative positioning

00:22:23.040 --> 00:22:25.860
to guidelines and some of the
new capabilities they've been

00:22:25.860 --> 00:22:26.670
working on in ConstraintLayout.

00:22:26.670 --> 00:22:29.211
ROMAIN GUY: The way I like to
describe it is ConstraintLayout

00:22:29.211 --> 00:22:30.916
is a RelativeLayout that works.

00:22:30.916 --> 00:22:32.790
CHET HAASE: And also,
the best thing about it

00:22:32.790 --> 00:22:34.760
is it's tightly
integrated with the tool.

00:22:34.760 --> 00:22:37.350
It was written in tandem
by the same people

00:22:37.350 --> 00:22:40.500
with the tool, which means
the design tool works really

00:22:40.500 --> 00:22:42.892
well with that layout,
as opposed to, well, they

00:22:42.892 --> 00:22:45.450
created the APIs, and the
tools sort of never caught up.

00:22:45.450 --> 00:22:47.280
That is not the case there.

00:22:47.280 --> 00:22:48.540
We mentioned 2.0.

00:22:48.540 --> 00:22:49.740
It's not 2.0 yet.

00:22:49.740 --> 00:22:52.900
I would say it's 2.0 soon.

00:22:52.900 --> 00:22:56.010
So keep an eye out for
what's coming up in 2.0.

00:22:56.010 --> 00:22:57.720
The talk by John
and Nicola this week

00:22:57.720 --> 00:23:00.690
will go over some of
that stuff, probably.

00:23:00.690 --> 00:23:03.180
Final thought on AbsoluteLayout.

00:23:03.180 --> 00:23:05.760
ROMAIN GUY: Just
to make it clear.

00:23:05.760 --> 00:23:08.720
So we have a class in
the UI toolkit called

00:23:08.720 --> 00:23:11.340
AdapterView, which is the base
class for a number of widgets.

00:23:11.340 --> 00:23:14.400
So ListView,
GridView, and Gallery.

00:23:14.400 --> 00:23:18.090
And they served us fine
for many, many years.

00:23:18.090 --> 00:23:19.230
They had a few issues.

00:23:19.230 --> 00:23:21.670
They were difficult to maintain.

00:23:21.670 --> 00:23:24.240
GridView, I think,
has not been used

00:23:24.240 --> 00:23:26.470
by pretty much any
app for quite a while,

00:23:26.470 --> 00:23:27.900
maybe for applications.

00:23:27.900 --> 00:23:30.025
Gallery is kind of like
a horizontal ListView,

00:23:30.025 --> 00:23:32.400
and I'm pretty sure it's been
deprecated for a long time.

00:23:32.400 --> 00:23:35.040
And we haven't certainly been
looking at it for a while.

00:23:35.040 --> 00:23:37.110
So I wouldn't use it
if I were you, anyway.

00:23:37.110 --> 00:23:38.250
Probably doesn't work.

00:23:38.250 --> 00:23:39.580
So here are some of the issues.

00:23:39.580 --> 00:23:41.310
So an AdapterView
has an adapter,

00:23:41.310 --> 00:23:43.440
and the adapter is interfaced
between your data set

00:23:43.440 --> 00:23:44.830
and the view itself.

00:23:44.830 --> 00:23:46.860
So one of the things you
can do in the adapter

00:23:46.860 --> 00:23:49.541
is notify the view of any
changes in the data set.

00:23:49.541 --> 00:23:51.290
The problem is that
you can only notify it

00:23:51.290 --> 00:23:52.890
of coarse-grained changes.

00:23:52.890 --> 00:23:55.660
All you can say is, hey,
something has changed.

00:23:55.660 --> 00:23:58.835
So absurdly enough,
in ListView, we

00:23:58.835 --> 00:24:01.622
have a lot of code that's trying
to figure out what has changed.

00:24:01.622 --> 00:24:03.330
Wouldn't it be nice
if you could tell us,

00:24:03.330 --> 00:24:04.970
because you probably know?

00:24:04.970 --> 00:24:07.750
Well, we built an API
where you cannot tell us.

00:24:07.750 --> 00:24:09.030
So that's kind of dumb.

00:24:09.030 --> 00:24:11.981
We also used to tell you to
follow this pattern, the View

00:24:11.981 --> 00:24:12.480
Holder.

00:24:12.480 --> 00:24:14.160
So the View Holder--
and it's one

00:24:14.160 --> 00:24:15.490
of those things where
I've seen a lot of people

00:24:15.490 --> 00:24:17.610
mad online about the View Holder
because it's a lot of product

00:24:17.610 --> 00:24:18.760
plates you have to write.

00:24:18.760 --> 00:24:20.260
It was actually
extremely important.

00:24:20.260 --> 00:24:22.680
I went back and I looked
at one of our old talks,

00:24:22.680 --> 00:24:24.870
and using View Holder
pattern would give you

00:24:24.870 --> 00:24:26.364
an extra 10 frames
per second when

00:24:26.364 --> 00:24:28.530
you were scrolling your
ListView on the T-Mobile G1.

00:24:28.530 --> 00:24:30.780
So it did matter a
lot way back then.

00:24:30.780 --> 00:24:32.587
It's not as necessary anymore.

00:24:32.587 --> 00:24:34.670
But because of RecyclerView,
it's part of the API,

00:24:34.670 --> 00:24:37.146
so you can now get
it for free, anyway.

00:24:37.146 --> 00:24:38.390
And finally, animations.

00:24:38.390 --> 00:24:40.397
Animations are possible
with AdapterView.

00:24:40.397 --> 00:24:42.230
So for instance, let's
say you have ListView

00:24:42.230 --> 00:24:44.250
and an item disappeared
from the data set.

00:24:44.250 --> 00:24:45.890
And you'd like the
item to fade away,

00:24:45.890 --> 00:24:48.330
and the rest of the item to
collapse and close the gap.

00:24:48.330 --> 00:24:50.130
You can do this with ListView.

00:24:50.130 --> 00:24:52.960
All you need to do is write
this little bit of code.

00:24:52.960 --> 00:24:56.712
Chet wrote a blog post about
it, I think, a few years ago.

00:24:56.712 --> 00:24:58.170
[LAUGHTER]

00:24:58.170 --> 00:25:00.540
CHET HAASE: That was one
of the ListView animations.

00:25:00.540 --> 00:25:02.310
We had a series of
videos showing you

00:25:02.310 --> 00:25:03.850
how to do different ones.

00:25:03.850 --> 00:25:05.452
ROMAIN GUY: This is
part of the code.

00:25:05.452 --> 00:25:07.410
You only need to understand
the future observer

00:25:07.410 --> 00:25:10.610
and transient state and measures
and notes and animations.

00:25:10.610 --> 00:25:12.270
It was rather difficult.

00:25:12.270 --> 00:25:16.860
So instead, now, we have the
RecyclerView, thankfully.

00:25:16.860 --> 00:25:18.362
So this is just a
dumb application.

00:25:18.362 --> 00:25:20.320
The first time I actually
used the RecyclerView

00:25:20.320 --> 00:25:22.720
was a couple of months ago.

00:25:22.720 --> 00:25:24.150
It was so much easier.

00:25:24.150 --> 00:25:25.840
That was really nice.

00:25:25.840 --> 00:25:28.500
I was able to create a different
version of the RecyclerView.

00:25:28.500 --> 00:25:29.875
The nice thing
about RecyclerView

00:25:29.875 --> 00:25:32.310
is that instead of having
multiple widgets that

00:25:32.310 --> 00:25:34.560
are effectively different
layouts for your data set,

00:25:34.560 --> 00:25:38.695
you can specify a layout
for a single RecyclerView.

00:25:38.695 --> 00:25:41.070
So this is the same exact code
with just different layout

00:25:41.070 --> 00:25:42.080
managers for the RecyclerView.

00:25:42.080 --> 00:25:43.830
CHET HAASE: I should point
out, too, that all of those

00:25:43.830 --> 00:25:45.789
were vertical, but
you could actually

00:25:45.789 --> 00:25:46.830
have a horizontal layout.

00:25:46.830 --> 00:25:50.157
For years, people asked us
how to do a horizontal--

00:25:50.157 --> 00:25:51.240
ROMAIN GUY: Oh, it's easy.

00:25:51.240 --> 00:25:51.730
CHET HAASE: Horizontal ListView.

00:25:51.730 --> 00:25:53.820
ROMAIN GUY: You just set a
rotation on the ListView,

00:25:53.820 --> 00:25:55.944
and then you have to
intercept all the touch events

00:25:55.944 --> 00:25:56.760
and rotate them.

00:25:56.760 --> 00:25:59.070
And then there's a few
more APIs that you probably

00:25:59.070 --> 00:26:00.565
need to override because--

00:26:00.565 --> 00:26:01.180
anyway.

00:26:01.180 --> 00:26:01.764
That was easy.

00:26:01.764 --> 00:26:02.888
CHET HAASE: Secret, though.

00:26:02.888 --> 00:26:05.010
The easiest way is to
simply rotate your phone

00:26:05.010 --> 00:26:08.240
90 degrees, which has gotten
easier with some of the system

00:26:08.240 --> 00:26:10.792
UI improvements in
the latest release.

00:26:10.792 --> 00:26:13.250
ROMAIN GUY: And one of the nice
things about RecyclerView--

00:26:13.250 --> 00:26:15.680
it does so many things
in much better ways.

00:26:15.680 --> 00:26:17.570
We have paging and
we have prefetching.

00:26:17.570 --> 00:26:18.702
The API is nicer.

00:26:18.702 --> 00:26:20.160
You can change
layout managers, you

00:26:20.160 --> 00:26:22.040
can write your own
layout manager.

00:26:22.040 --> 00:26:24.000
But also, animations,
they come for free.

00:26:24.000 --> 00:26:27.037
So the equivalent of the
code we just saw is this.

00:26:27.037 --> 00:26:29.120
And in particular, with
RecyclerView, what you get

00:26:29.120 --> 00:26:30.980
is fine-grained changes.

00:26:30.980 --> 00:26:33.470
So you can tell
us, if an item was

00:26:33.470 --> 00:26:34.880
removed, what item was removed.

00:26:34.880 --> 00:26:36.740
When an item was added,
what item was added.

00:26:36.740 --> 00:26:38.930
You can tell us about ranges
of items that have changed,

00:26:38.930 --> 00:26:40.888
or you can tell us that
everything has changed.

00:26:40.888 --> 00:26:44.494
This is much better
for you and for us.

00:26:44.494 --> 00:26:45.410
CHET HAASE: All right.

00:26:45.410 --> 00:26:47.000
Fragments.

00:26:47.000 --> 00:26:49.640
In the old days, we
heard that fragments

00:26:49.640 --> 00:26:51.380
were really complicated.

00:26:51.380 --> 00:26:53.577
And also, we would
fix this thing.

00:26:53.577 --> 00:26:55.910
So we didn't necessarily have
everything correct or have

00:26:55.910 --> 00:26:58.010
all the APIs that people
needed, so we would

00:26:58.010 --> 00:26:59.760
put in improvements,
and we would put that

00:26:59.760 --> 00:27:00.980
into the platform release.

00:27:00.980 --> 00:27:03.740
And then applications
could only use that

00:27:03.740 --> 00:27:06.770
with devices on that
platform release.

00:27:06.770 --> 00:27:10.310
And so the modern advice is
don't use the platform version.

00:27:10.310 --> 00:27:12.140
We have since ported
all of that code

00:27:12.140 --> 00:27:14.750
to make all of the fixes
in the support library,

00:27:14.750 --> 00:27:16.684
and we have now
deprecated fragments

00:27:16.684 --> 00:27:17.600
in the core platforms.

00:27:17.600 --> 00:27:18.710
So don't use them there.

00:27:18.710 --> 00:27:22.280
Use the support library, or now,
Jetpack version of fragments.

00:27:22.280 --> 00:27:24.290
We are putting more
goodness there.

00:27:24.290 --> 00:27:28.165
So use those, and
also, we are continuing

00:27:28.165 --> 00:27:29.040
to make improvements.

00:27:29.040 --> 00:27:30.665
There's a talk on
fragments this week--

00:27:30.665 --> 00:27:31.873
ROMAIN GUY: Tomorrow morning.

00:27:31.873 --> 00:27:33.680
CHET HAASE: --by Adam
and Ian tomorrow.

00:27:33.680 --> 00:27:36.710
So please check that out to hear
more information about things

00:27:36.710 --> 00:27:38.510
that we are doing,
as well as ways

00:27:38.510 --> 00:27:40.760
to use fragments, which
should be a little bit easier.

00:27:40.760 --> 00:27:43.740
A major one of those is the
new navigation controller.

00:27:43.740 --> 00:27:44.960
So check that out.

00:27:44.960 --> 00:27:46.390
It sort of builds on fragments.

00:27:46.390 --> 00:27:47.510
It doesn't depend on them.

00:27:47.510 --> 00:27:49.280
There is no
dependency, but it does

00:27:49.280 --> 00:27:52.340
build on those capabilities
for creating and navigating

00:27:52.340 --> 00:27:55.130
between the screens
of your application.

00:27:55.130 --> 00:27:58.340
Activities are very closely
related to fragments.

00:27:58.340 --> 00:28:00.890
In the old days, basically,
Android applications

00:28:00.890 --> 00:28:02.660
consisted of
multiple activities.

00:28:02.660 --> 00:28:06.860
That was the application flow
for all Android applications.

00:28:06.860 --> 00:28:10.280
We expected developers to do
this, and developers did this.

00:28:10.280 --> 00:28:12.980
When you want to go from
one screen of your app

00:28:12.980 --> 00:28:16.580
to another one, you launch an
intent, you get a new window.

00:28:16.580 --> 00:28:19.880
There, you have some window
animation to get you there,

00:28:19.880 --> 00:28:21.710
and there you are.

00:28:21.710 --> 00:28:25.160
The new approach is use single
activities when you can.

00:28:25.160 --> 00:28:28.790
It turns out that's a much
richer experience for the user.

00:28:28.790 --> 00:28:31.579
Those window animations--
well, they're animating,

00:28:31.579 --> 00:28:33.370
but they're not doing
anything interesting.

00:28:33.370 --> 00:28:35.300
They're not doing anything
that helps the user

00:28:35.300 --> 00:28:37.760
transition from one state of
the application to another.

00:28:37.760 --> 00:28:40.430
Instead, it's basically
completely separate windows

00:28:40.430 --> 00:28:43.550
that are coming into view
when you could actually

00:28:43.550 --> 00:28:49.460
use single activity approaches
to retain the same Chrome

00:28:49.460 --> 00:28:50.480
around the application.

00:28:50.480 --> 00:28:51.920
Might as well have
the same action

00:28:51.920 --> 00:28:54.830
bar with the content switching
out from underneath it,

00:28:54.830 --> 00:28:56.990
or use richer
animations, which are

00:28:56.990 --> 00:29:02.690
possible with either the core
platform animations or fragment

00:29:02.690 --> 00:29:03.720
animations.

00:29:03.720 --> 00:29:09.020
So go ahead and use an activity.

00:29:09.020 --> 00:29:11.097
You may have situations
in your application

00:29:11.097 --> 00:29:13.430
where you have different entry
points, especially if you

00:29:13.430 --> 00:29:16.013
have a deep length that someone
may come into your application

00:29:16.013 --> 00:29:16.640
with.

00:29:16.640 --> 00:29:18.765
Then, it's appropriate to
have separate activities.

00:29:18.765 --> 00:29:21.170
That is the way to
expose that information.

00:29:21.170 --> 00:29:24.650
But otherwise, try to
use a single activity.

00:29:24.650 --> 00:29:28.310
Fragments are not necessary for
single activity applications,

00:29:28.310 --> 00:29:30.290
but they can help with
this a lot, especially

00:29:30.290 --> 00:29:32.400
with some of the recent
improvements there

00:29:32.400 --> 00:29:34.830
and the navigation
controller stuff, too.

00:29:34.830 --> 00:29:35.540
Architecture.

00:29:35.540 --> 00:29:36.980
So here was the old advice.

00:29:36.980 --> 00:29:39.050
A few years ago--

00:29:39.050 --> 00:29:40.760
OK, only 2016.

00:29:40.760 --> 00:29:43.580
So basically two years ago,
Dianne Hackborn posted this

00:29:43.580 --> 00:29:44.750
on G+.

00:29:44.750 --> 00:29:48.650
We usually get this question
from application developers,

00:29:48.650 --> 00:29:51.440
where they will ask us what
application architecture

00:29:51.440 --> 00:29:53.780
they should use in
their application.

00:29:53.780 --> 00:29:56.940
And our answer is
always, we don't care.

00:29:56.940 --> 00:29:57.872
We are not you.

00:29:57.872 --> 00:29:59.580
We don't know how your
application works.

00:29:59.580 --> 00:30:01.038
We don't know the
best architecture

00:30:01.038 --> 00:30:04.140
for your application, so
please make your own decision.

00:30:04.140 --> 00:30:07.160
And then there is usually a
follow-up question of, yeah,

00:30:07.160 --> 00:30:07.910
I get that.

00:30:07.910 --> 00:30:11.250
But which architecture
should I use?

00:30:11.250 --> 00:30:13.624
So Dianne posted
this to basically say

00:30:13.624 --> 00:30:14.540
this once and for all.

00:30:14.540 --> 00:30:15.740
We do not care.

00:30:15.740 --> 00:30:17.500
The components that
we have in there--

00:30:17.500 --> 00:30:21.110
the content providers, the
activities, the services--

00:30:21.110 --> 00:30:22.820
these are system-level
components.

00:30:22.820 --> 00:30:24.890
They're not an
architecture around which

00:30:24.890 --> 00:30:26.130
you build your application.

00:30:26.130 --> 00:30:28.550
So please build the
one that's appropriate

00:30:28.550 --> 00:30:30.740
for your application.

00:30:30.740 --> 00:30:32.390
The new advice is,
actually, we're

00:30:32.390 --> 00:30:34.670
happy to provide you some
recommended architecture.

00:30:34.670 --> 00:30:36.836
Because it turns out that
people would at least like

00:30:36.836 --> 00:30:39.039
some common advice
that makes sense,

00:30:39.039 --> 00:30:40.580
and we believe that
we have that now.

00:30:40.580 --> 00:30:42.597
Specifically, with the
architecture components,

00:30:42.597 --> 00:30:44.180
we think that we
have an approach that

00:30:44.180 --> 00:30:45.210
makes a lot of sense.

00:30:45.210 --> 00:30:46.640
We have APIs that
are easy to use

00:30:46.640 --> 00:30:48.110
and you can build around those.

00:30:48.110 --> 00:30:50.240
We are not demanding
that you use this.

00:30:50.240 --> 00:30:52.904
Please use the architecture
that makes sense to you.

00:30:52.904 --> 00:30:54.320
But we do have a
core architecture

00:30:54.320 --> 00:30:55.779
that we believe should work.

00:30:55.779 --> 00:30:57.320
If you're starting
a new application,

00:30:57.320 --> 00:31:01.495
if you have new developers
on your team, it makes sense.

00:31:01.495 --> 00:31:02.870
One of the reasons
that we worked

00:31:02.870 --> 00:31:05.090
with Android
architecture components

00:31:05.090 --> 00:31:06.380
was to solve hard problems.

00:31:06.380 --> 00:31:09.440
One of the hardest problems
was Android lifecycle.

00:31:09.440 --> 00:31:11.690
And our answer was,
all you need to do

00:31:11.690 --> 00:31:14.600
is understand this
diagram and memorize it.

00:31:14.600 --> 00:31:18.020
And someone, externally,
did their own version

00:31:18.020 --> 00:31:20.510
of that diagram, which looks
like this, which is actually

00:31:20.510 --> 00:31:23.967
a lot easier to understand
if you look at it like this.

00:31:23.967 --> 00:31:26.300
So that's basically everything
you need to know and keep

00:31:26.300 --> 00:31:28.350
in your head at all times.

00:31:28.350 --> 00:31:30.440
So the problem would
be, you would basically

00:31:30.440 --> 00:31:32.210
create a bunch of
methods in your activity

00:31:32.210 --> 00:31:34.300
so that you could track
and manage lifecycle.

00:31:34.300 --> 00:31:36.440
You're handling creation
and starting and stopping

00:31:36.440 --> 00:31:38.814
and resuming and pausing, and
you're probably doing stuff

00:31:38.814 --> 00:31:40.160
in destroy, as well.

00:31:40.160 --> 00:31:42.530
You're probably doing
too much on Create.

00:31:42.530 --> 00:31:44.900
You're probably having
race conditions, as well as

00:31:44.900 --> 00:31:46.317
leaks in your start
and your stop,

00:31:46.317 --> 00:31:48.608
and you're probably doing
that in the pause and resume,

00:31:48.608 --> 00:31:49.170
as well.

00:31:49.170 --> 00:31:51.842
And you're not exactly sure why
you're overriding on destroy,

00:31:51.842 --> 00:31:53.550
but someone told you
you probably should.

00:31:53.550 --> 00:31:55.110
So we'll do that, as well.

00:31:55.110 --> 00:31:59.360
So in the meantime, you actually
only know the lifecycle state

00:31:59.360 --> 00:32:00.770
if you override those methods.

00:32:00.770 --> 00:32:02.450
We didn't give you
a way to query that.

00:32:02.450 --> 00:32:04.040
We know what it is, internally.

00:32:04.040 --> 00:32:06.380
We're just not letting
you in on the secret.

00:32:06.380 --> 00:32:08.220
So there is no API
for you to query,

00:32:08.220 --> 00:32:09.970
so you need to override
all those methods,

00:32:09.970 --> 00:32:12.140
and then you end up chucking
too much code in there.

00:32:12.140 --> 00:32:14.660
So too much logic basically
happening everywhere.

00:32:14.660 --> 00:32:17.300
The new approach is we have
an object called the Lifecycle

00:32:17.300 --> 00:32:17.870
Owner.

00:32:17.870 --> 00:32:19.906
You can ask for a
lifecycle object,

00:32:19.906 --> 00:32:21.530
and then you can
either query the state

00:32:21.530 --> 00:32:23.930
if you want to know what
state of lifecycle you're in,

00:32:23.930 --> 00:32:25.970
or you can set an
observer on it,

00:32:25.970 --> 00:32:28.104
and then you can get
callbacks into those methods.

00:32:28.104 --> 00:32:30.270
This allows you to abstract
it into a separate place

00:32:30.270 --> 00:32:33.020
so you're not basically bogging
down activity code with all

00:32:33.020 --> 00:32:33.741
this information.

00:32:33.741 --> 00:32:35.240
But you're putting
it where it makes

00:32:35.240 --> 00:32:36.710
sense in your application.

00:32:36.710 --> 00:32:40.490
Fortunately, we override--
we subclass lifecycle owner

00:32:40.490 --> 00:32:43.330
or implement that in both
fragment and AppCompat

00:32:43.330 --> 00:32:43.940
activities.

00:32:43.940 --> 00:32:46.260
So in the support
library, please use these.

00:32:46.260 --> 00:32:47.840
Those are lifecycle owners.

00:32:47.840 --> 00:32:50.270
So basically, you can query
them to get the lifecycle,

00:32:50.270 --> 00:32:51.692
and then go from there.

00:32:51.692 --> 00:32:53.900
So we went from a model
where you would have activity

00:32:53.900 --> 00:32:57.207
with basically all of this
lifecycle-dependent logic in it

00:32:57.207 --> 00:32:59.290
to a model where the
activity can be much smaller,

00:32:59.290 --> 00:33:02.210
take that logic out, abstract
it into this other thing

00:33:02.210 --> 00:33:04.400
over there, set a
lifecycle observer on it,

00:33:04.400 --> 00:33:05.840
and get the callbacks you want.

00:33:05.840 --> 00:33:08.314
We have a similar problem
going on with views and data.

00:33:08.314 --> 00:33:10.730
We have an activity, and then
we have all this information

00:33:10.730 --> 00:33:11.960
about the views in there.

00:33:11.960 --> 00:33:13.671
And then we have the
data for the views,

00:33:13.671 --> 00:33:15.420
and we need to know
when the data changes,

00:33:15.420 --> 00:33:17.100
and we need to also
track the lifecycle

00:33:17.100 --> 00:33:20.070
so that we don't leak things or
call things at the wrong time.

00:33:20.070 --> 00:33:22.220
So we just end up having
too much stuff there.

00:33:22.220 --> 00:33:24.950
Well now, you had this
concept of a LiveData

00:33:24.950 --> 00:33:26.360
and a ViewModel
where you can put

00:33:26.360 --> 00:33:30.024
that stuff-- you can abstract
it out of the activity.

00:33:30.024 --> 00:33:31.940
So you can put all that
information out there,

00:33:31.940 --> 00:33:32.831
observe that stuff.

00:33:32.831 --> 00:33:34.580
So now, in the activity,
you should really

00:33:34.580 --> 00:33:37.340
have only information
about views and a reference

00:33:37.340 --> 00:33:38.311
to the ViewModel.

00:33:38.311 --> 00:33:40.310
And then put all of that
logic in the ViewModel.

00:33:40.310 --> 00:33:41.600
It's using LiveData objects.

00:33:41.600 --> 00:33:45.380
It's handling lifecycle on its
own, and you can observe it.

00:33:45.380 --> 00:33:46.010
Way better.

00:33:46.010 --> 00:33:47.450
Way less buggy.

00:33:47.450 --> 00:33:50.050
For data, our approach--

00:33:50.050 --> 00:33:57.777
our argument to you
was you're on your own.

00:33:57.777 --> 00:33:58.860
We don't manage your data.

00:33:58.860 --> 00:34:00.000
Do whatever you want.

00:34:00.000 --> 00:34:02.125
And there are lots of
database solutions out there.

00:34:02.125 --> 00:34:03.450
We have SQLite in the platform.

00:34:03.450 --> 00:34:04.283
Go ahead and use it.

00:34:04.283 --> 00:34:05.660
Knock yourself out.

00:34:05.660 --> 00:34:06.700
Whatever.

00:34:06.700 --> 00:34:08.719
We don't want to get
into that business.

00:34:08.719 --> 00:34:11.239
The new approach is we actually
do offer something for data.

00:34:11.239 --> 00:34:13.790
It builds on top of
SQLite, but it actually

00:34:13.790 --> 00:34:17.750
offers build time verification,
so you're not just

00:34:17.750 --> 00:34:20.699
sending these queries down and
then getting errors at runtime.

00:34:20.699 --> 00:34:23.510
But you can see this problem
at build time and integration

00:34:23.510 --> 00:34:26.810
with the LiveData stuff
that we saw earlier,

00:34:26.810 --> 00:34:29.810
or you can be on your
own if you want to.

00:34:29.810 --> 00:34:32.270
We're not trying to take
over your database solution.

00:34:32.270 --> 00:34:35.449
We're simply offering a
better local persistent story

00:34:35.449 --> 00:34:37.850
than we had previously,
to make it easier for you.

00:34:37.850 --> 00:34:39.570
The overall diagram
looks like this.

00:34:39.570 --> 00:34:42.560
The only new element here
is this idea of repository.

00:34:42.560 --> 00:34:44.719
It's a pattern for
basically abstracting

00:34:44.719 --> 00:34:46.679
for where the data comes from.

00:34:46.679 --> 00:34:48.906
So if it comes
from local or web,

00:34:48.906 --> 00:34:50.989
it shouldn't matter to the
rest of the people that

00:34:50.989 --> 00:34:51.655
are querying it.

00:34:51.655 --> 00:34:54.530
So it's kind of nice to
have an abstraction there.

00:34:54.530 --> 00:34:56.750
Data paging.

00:34:56.750 --> 00:34:59.582
So we had this thing
called CursorAdapter.

00:34:59.582 --> 00:35:01.040
It had some good
elements about it.

00:35:01.040 --> 00:35:02.930
It did have support
for a database cursor.

00:35:02.930 --> 00:35:04.220
That's nice.

00:35:04.220 --> 00:35:07.700
But it was specific
to ListView, and it

00:35:07.700 --> 00:35:11.210
had, basically, other
problems with inefficiencies--

00:35:11.210 --> 00:35:13.100
paging sizes, stuff like that.

00:35:13.100 --> 00:35:15.990
We had AsyncListUtil,
which was more useful,

00:35:15.990 --> 00:35:18.110
but also was really
inefficient for doing things

00:35:18.110 --> 00:35:20.510
like web transactions.

00:35:20.510 --> 00:35:22.760
So we have a new model
in modern Android.

00:35:22.760 --> 00:35:24.170
We have data paging.

00:35:24.170 --> 00:35:27.180
The Paging Library
when 1.0 this week,

00:35:27.180 --> 00:35:29.480
and there are good
things about it.

00:35:29.480 --> 00:35:31.490
So it works with RecyclerView.

00:35:31.490 --> 00:35:34.130
It handles fine-grained
data changes.

00:35:34.130 --> 00:35:37.880
It's much more efficient, uses
background threads very easily.

00:35:37.880 --> 00:35:40.370
You can observe changes, so
it's integrated with LiveData.

00:35:40.370 --> 00:35:42.710
But again, we're not forcing
this architecture on you.

00:35:42.710 --> 00:35:45.020
If you're using RxJava2,
you can integrate with that

00:35:45.020 --> 00:35:46.400
very easily, as well.

00:35:46.400 --> 00:35:48.260
And flexible data
fetching options,

00:35:48.260 --> 00:35:50.810
so you can specify
the window size

00:35:50.810 --> 00:35:52.430
and when you want
to get these things.

00:35:52.430 --> 00:35:55.220
There are, of course,
always trade-offs.

00:35:55.220 --> 00:35:57.380
I find that the bad
thing about data paging

00:35:57.380 --> 00:36:01.135
is that the name
is rather boring.

00:36:01.135 --> 00:36:02.010
ROMAIN GUY: Graphics.

00:36:02.010 --> 00:36:05.210
So when we started Android,
we only had OpenGL ES 1.0.

00:36:05.210 --> 00:36:07.400
We didn't even have shaders.

00:36:07.400 --> 00:36:09.831
We were doing everything
with software rendering.

00:36:09.831 --> 00:36:11.330
That was an issue
for several years.

00:36:11.330 --> 00:36:13.970
It was fast enough
for the early devices.

00:36:13.970 --> 00:36:16.700
It's only when we hit the
tablet form factor that it

00:36:16.700 --> 00:36:18.140
started to become an issue.

00:36:18.140 --> 00:36:19.820
We used to do a lot
of nine patches,

00:36:19.820 --> 00:36:21.620
and I'm sure some
of you have suffered

00:36:21.620 --> 00:36:23.328
through the creation
of the nine patches,

00:36:23.328 --> 00:36:25.520
or even worse, trying to
explain to your UX designer

00:36:25.520 --> 00:36:27.170
how to create them.

00:36:27.170 --> 00:36:28.550
Where do you put the black dots?

00:36:28.550 --> 00:36:30.320
Which side do they go?

00:36:30.320 --> 00:36:32.474
I still don't know, to this day.

00:36:32.474 --> 00:36:33.890
TextureView versus
SurfaceView, we

00:36:33.890 --> 00:36:36.334
touched on that in
our preview talk.

00:36:36.334 --> 00:36:38.000
Basically, there was
always this problem

00:36:38.000 --> 00:36:41.204
of do you use the less efficient
TextureView that can integrate

00:36:41.204 --> 00:36:43.620
better with the other views,
like ListView and animations,

00:36:43.620 --> 00:36:45.100
or do you use SurfaceView?

00:36:45.100 --> 00:36:48.316
And managing bitmaps was hard.

00:36:48.316 --> 00:36:50.690
A lot of you built applications,
and you were getting out

00:36:50.690 --> 00:36:53.210
of memory errors because you
were trying to create bitmaps

00:36:53.210 --> 00:36:55.850
and you have to do caching,
and this is difficult.

00:36:55.850 --> 00:37:01.130
And our answer was
basically, eh, c'est la vie.

00:37:01.130 --> 00:37:02.450
So now this.

00:37:02.450 --> 00:37:04.044
We have OpenGL 3.1 and 3.2.

00:37:04.044 --> 00:37:05.460
You have content
shaders, you have

00:37:05.460 --> 00:37:08.480
Vulcan if you want to do
low-level graphics rendering.

00:37:08.480 --> 00:37:11.750
We do hardware
acceleration everywhere.

00:37:11.750 --> 00:37:16.170
VectorDrawables have basically
replaced most of our drawables

00:37:16.170 --> 00:37:17.346
and bitmaps in applications.

00:37:17.346 --> 00:37:18.470
We have small applications.

00:37:18.470 --> 00:37:19.595
You don't have to support--

00:37:19.595 --> 00:37:21.800
supporting multiple
densities is a lot easier.

00:37:21.800 --> 00:37:24.070
You don't need as many
batches as before.

00:37:24.070 --> 00:37:26.330
And something that
we're now doing

00:37:26.330 --> 00:37:29.300
is we're working with
you-- very often,

00:37:29.300 --> 00:37:32.006
application developers
turn to us for solutions.

00:37:32.006 --> 00:37:33.380
But when the
community-- that is,

00:37:33.380 --> 00:37:36.020
you-- have been building
amazing libraries that we think

00:37:36.020 --> 00:37:38.850
are the right answer, that's
the ones you should be using.

00:37:38.850 --> 00:37:41.780
So for instance, Glide
or Picasso or Lottie

00:37:41.780 --> 00:37:43.211
are excellent at what they do.

00:37:43.211 --> 00:37:44.836
If you want to manage
bitmaps or if you

00:37:44.836 --> 00:37:47.270
want to create crazy, complex
animation with Lottie,

00:37:47.270 --> 00:37:48.260
you should use those.

00:37:48.260 --> 00:37:50.680
We're not going to spend time
recreating something that

00:37:50.680 --> 00:37:52.430
already exists out
there and that we think

00:37:52.430 --> 00:37:55.170
is very good at what it does.

00:37:55.170 --> 00:37:57.370
So please go use
those libraries.

00:37:57.370 --> 00:37:58.241
Again, know this.

00:37:58.241 --> 00:37:59.740
You should probably
use SurfaceView,

00:37:59.740 --> 00:38:00.906
and not TextureView anymore.

00:38:00.906 --> 00:38:02.730
It has outlived its time.

00:38:02.730 --> 00:38:06.620
And finally, we used to tell
you to profile your code.

00:38:06.620 --> 00:38:08.960
We used to tell you to
avoid work whenever possible

00:38:08.960 --> 00:38:11.150
and to minimize
memory consumption.

00:38:11.150 --> 00:38:12.590
But now, we have better devices.

00:38:12.590 --> 00:38:13.940
We have lot of cores,
we have a lot of RAM.

00:38:13.940 --> 00:38:15.023
We have a better language.

00:38:15.023 --> 00:38:16.130
It's a better runtime.

00:38:16.130 --> 00:38:18.980
So instead, what you should be
doing is profiling your code

00:38:18.980 --> 00:38:21.380
and avoiding work whenever
possible, and also minimizing

00:38:21.380 --> 00:38:23.810
memory consumption.

00:38:23.810 --> 00:38:25.700
CHET HAASE: Because it
turns out that devices

00:38:25.700 --> 00:38:26.690
are still constrained.

00:38:26.690 --> 00:38:27.940
You need to keep that in mind.

00:38:27.940 --> 00:38:31.370
Battery life is critical
and bandwidth is precious,

00:38:31.370 --> 00:38:33.460
and all of these contribute
to user experience.

00:38:33.460 --> 00:38:35.930
So your user will thank
you if you are actually

00:38:35.930 --> 00:38:37.940
still being conservative
about these things

00:38:37.940 --> 00:38:40.190
and getting the best
performance for your application

00:38:40.190 --> 00:38:41.840
that's appropriate.

00:38:41.840 --> 00:38:45.620
We would like to thank you,
and there is a different way

00:38:45.620 --> 00:38:48.740
to say this.

00:38:48.740 --> 00:38:51.470
And I think we're done.

00:38:51.470 --> 00:38:52.215
Thank you.

00:38:52.215 --> 00:38:55.125
[APPLAUSE]

00:38:55.125 --> 00:38:58.601
[MUSIC PLAYING]

