WEBVTT
Kind: captions
Language: en

00:00:00.560 --> 00:00:01.740
KASPER LUND: So I'm Kasper.

00:00:01.740 --> 00:00:04.250
I'm here to give
you some insights

00:00:04.250 --> 00:00:08.220
into what we're doing
with Dart for mobile

00:00:08.220 --> 00:00:12.120
and how we feel like we
can actually change mobile

00:00:12.120 --> 00:00:13.180
for the better.

00:00:13.180 --> 00:00:16.940
So when we talk about mobile,
it's probably no surprise

00:00:16.940 --> 00:00:19.120
that it's the two
devices on the left there

00:00:19.120 --> 00:00:21.700
that has our attention.

00:00:21.700 --> 00:00:23.720
You already now have
ways of running Dart code

00:00:23.720 --> 00:00:24.910
in that context.

00:00:24.910 --> 00:00:27.040
What we're looking
at here is a way

00:00:27.040 --> 00:00:29.010
of giving you the
flexibility to run

00:00:29.010 --> 00:00:31.050
Dart in a more
native-like setting

00:00:31.050 --> 00:00:34.540
and still provide a lot of
the nice values and features

00:00:34.540 --> 00:00:36.790
that you know from Dart.

00:00:36.790 --> 00:00:39.970
So why is it that people
want to use Dart on mobile?

00:00:39.970 --> 00:00:42.450
Well, Dart is a modern and
light technology stack,

00:00:42.450 --> 00:00:44.440
and our focus on
developer productivity

00:00:44.440 --> 00:00:47.617
seems to fit really well
in the mobile space.

00:00:47.617 --> 00:00:49.700
The one thing that I also
mentioned in the keynote

00:00:49.700 --> 00:00:52.560
is that code sharing across
multiple client apps,

00:00:52.560 --> 00:00:55.770
or perhaps different
variants of the same app,

00:00:55.770 --> 00:00:58.510
seems to be something that's
really compelling, especially

00:00:58.510 --> 00:01:00.620
for large teams
that struggle when

00:01:00.620 --> 00:01:02.560
they have to deliver
three different variants

00:01:02.560 --> 00:01:04.170
of the same app.

00:01:04.170 --> 00:01:08.570
So imagine you have a very
complicated application,

00:01:08.570 --> 00:01:10.490
like a to-do sample
here, and you

00:01:10.490 --> 00:01:12.980
want to deliver
three versions of it,

00:01:12.980 --> 00:01:17.180
three different UIs all
running the same core model.

00:01:17.180 --> 00:01:20.390
It's a little bit painful to
have to write that core model

00:01:20.390 --> 00:01:24.290
in Java, in Objective C,
and maybe some C++ code

00:01:24.290 --> 00:01:25.020
in the middle.

00:01:25.020 --> 00:01:26.710
So it'd be nice to
be able to just take

00:01:26.710 --> 00:01:29.420
that part of your business
logic, dump it into Dart,

00:01:29.420 --> 00:01:32.940
and just skin it for the
different kind of UIs.

00:01:32.940 --> 00:01:35.030
What you see on the left
is the Android version.

00:01:35.030 --> 00:01:36.905
What you see on the
right is the iOS version.

00:01:36.905 --> 00:01:38.650
And in both cases--
this is actually

00:01:38.650 --> 00:01:42.140
a running sample I can show
you too, if you want to see it.

00:01:42.140 --> 00:01:44.960
But in both cases, they're
using native widgets,

00:01:44.960 --> 00:01:47.730
so it feels like
it's a native app.

00:01:47.730 --> 00:01:50.110
It's just that all of the
content that we show here,

00:01:50.110 --> 00:01:52.600
it just comes from
a Dart application.

00:01:52.600 --> 00:01:54.380
So it's a fairly simple setup.

00:01:54.380 --> 00:01:57.610
So you have a UI for iOS
and a UI for Android.

00:01:57.610 --> 00:01:59.150
Let's just focus on those two.

00:01:59.150 --> 00:02:01.470
The client, or the
command line version,

00:02:01.470 --> 00:02:03.080
is not that interesting
in this case.

00:02:03.080 --> 00:02:05.820
And underneath that, you
have your application model

00:02:05.820 --> 00:02:07.845
written in Dart.

00:02:07.845 --> 00:02:09.470
And in this case,
the application model

00:02:09.470 --> 00:02:10.740
is fairly simple,
but there are lots

00:02:10.740 --> 00:02:12.750
of cases where it's
really, really complicated,

00:02:12.750 --> 00:02:15.310
and it's really core
parts of your offering

00:02:15.310 --> 00:02:16.690
that will fit in there.

00:02:16.690 --> 00:02:18.920
To actually make this
application model fly

00:02:18.920 --> 00:02:21.010
on these devices,
we have to talk

00:02:21.010 --> 00:02:24.000
about what it means to
have a Dart runtime there.

00:02:24.000 --> 00:02:26.550
So the Dart runtime is the
part of the stack that actually

00:02:26.550 --> 00:02:28.560
runs your Dart applications.

00:02:28.560 --> 00:02:32.030
And already now we have
a really great offering

00:02:32.030 --> 00:02:35.170
for Android, but
for iOS, because

00:02:35.170 --> 00:02:37.070
of some of the restrictions
on that platform,

00:02:37.070 --> 00:02:38.861
we've had to do a little
bit of engineering

00:02:38.861 --> 00:02:41.320
to try to come up with a
new solution in that space.

00:02:41.320 --> 00:02:43.460
So let's look a little
bit at that runtime system

00:02:43.460 --> 00:02:48.590
and then dive into what Fletch
is and what it will become.

00:02:48.590 --> 00:02:50.920
So Fletch is a Dart
runtime for mobile.

00:02:50.920 --> 00:02:53.520
It's targeting the iOS
space where we have

00:02:53.520 --> 00:02:55.120
sort of a hole in our offering.

00:02:55.120 --> 00:02:57.920
There's no great way of
running Dart code on iOS today,

00:02:57.920 --> 00:03:00.790
and that's what we're trying
to plot with this thing.

00:03:00.790 --> 00:03:03.720
It's a new thing, so
it's not a product yet.

00:03:03.720 --> 00:03:08.340
It's not something you can pick
down from GitHub today and use

00:03:08.340 --> 00:03:09.660
for building real things.

00:03:09.660 --> 00:03:12.140
But it's something
we're productizing

00:03:12.140 --> 00:03:15.050
over the next quarters.

00:03:15.050 --> 00:03:16.080
So what is it really?

00:03:16.080 --> 00:03:19.720
It's a small and
elegant runtime system.

00:03:19.720 --> 00:03:21.500
It supports on-the-fly
program changes

00:03:21.500 --> 00:03:24.880
to keep the right level of
productivity for you guys.

00:03:24.880 --> 00:03:26.554
So that means that
we'll allow you

00:03:26.554 --> 00:03:28.720
to basically change the
program while it's executing

00:03:28.720 --> 00:03:33.120
on a mobile device, so to
make that hole edit, compile,

00:03:33.120 --> 00:03:36.564
refresh cycle really,
really smooth.

00:03:36.564 --> 00:03:38.730
It actually also runs an
iOS through interpretation.

00:03:38.730 --> 00:03:41.070
And the key selling
point here is

00:03:41.070 --> 00:03:44.440
that this is a way for you guys
to write Dart code that runs

00:03:44.440 --> 00:03:48.420
on iOS in a mobile setting.

00:03:48.420 --> 00:03:50.520
So some of the sort
of key characteristics

00:03:50.520 --> 00:03:52.990
are kind of interesting here.

00:03:52.990 --> 00:03:56.230
It's designed to be very
light, interactive in a sense,

00:03:56.230 --> 00:03:58.010
and also very concurrent.

00:03:58.010 --> 00:04:00.750
So the lightness
is-- I mean, it's

00:04:00.750 --> 00:04:02.594
hard to measure that
with just one metric.

00:04:02.594 --> 00:04:05.010
I'll throw out some numbers
here to give you an indication

00:04:05.010 --> 00:04:06.337
of where we're going with this.

00:04:06.337 --> 00:04:08.170
First of all, we made
it so that it start up

00:04:08.170 --> 00:04:11.260
really, really quickly, even
on these mobile devices,

00:04:11.260 --> 00:04:15.030
so that adding Dart support
to your mobile application

00:04:15.030 --> 00:04:17.620
doesn't really cost you on
the startup of your app.

00:04:17.620 --> 00:04:19.529
So we're looking at
around 2 milliseconds

00:04:19.529 --> 00:04:22.940
for starting and shutting down
a small Dart, like a Hello World

00:04:22.940 --> 00:04:23.880
thing.

00:04:23.880 --> 00:04:25.770
But that's really sort
of probably as low

00:04:25.770 --> 00:04:26.670
as we can almost get.

00:04:26.670 --> 00:04:28.780
We might be able to
make it twice as fast.

00:04:28.780 --> 00:04:33.260
But the way we've done this
is to really double down

00:04:33.260 --> 00:04:35.370
on the implementations
of the snapshots

00:04:35.370 --> 00:04:39.530
and use the fact that the
snapshots that the Fletch

00:04:39.530 --> 00:04:43.290
system runs have byte
codes in there that

00:04:43.290 --> 00:04:45.800
are ready to be interpreted
from the first millisecond.

00:04:45.800 --> 00:04:48.090
So there's no parsing
or scanning overhead.

00:04:48.090 --> 00:04:51.720
So it's a very simple
thing that way.

00:04:51.720 --> 00:04:54.550
It also has a low
memory overhead.

00:04:54.550 --> 00:04:56.610
Right now it's around
200K in binary size.

00:04:56.610 --> 00:04:58.794
That means that it doesn't
add a lot of dead weight

00:04:58.794 --> 00:05:01.210
to your application to just
throw it in there, even if you

00:05:01.210 --> 00:05:04.632
only want to add a few methods
of Dart code to your system.

00:05:04.632 --> 00:05:06.340
We feel like it's
really important for us

00:05:06.340 --> 00:05:09.560
to stay in that space
so that we can work out

00:05:09.560 --> 00:05:12.490
as an add-on to an existing app.

00:05:12.490 --> 00:05:15.110
So even if we're not
providing a ton of value yet,

00:05:15.110 --> 00:05:18.130
the cost of including it
is not sort of prohibitive.

00:05:18.130 --> 00:05:20.640
So we're focusing on something
very small, very lightweight,

00:05:20.640 --> 00:05:23.280
and very simple.

00:05:23.280 --> 00:05:26.550
The interactive part
is kind of interesting.

00:05:26.550 --> 00:05:28.830
We heard a question
during the panel

00:05:28.830 --> 00:05:31.350
today that the one
missing thing in Dart

00:05:31.350 --> 00:05:34.930
is the ability to update
code and work with it

00:05:34.930 --> 00:05:38.840
in a sort of more
interactive and live way.

00:05:38.840 --> 00:05:43.290
We've built Fletch to have a
wire protocol for doing program

00:05:43.290 --> 00:05:44.879
changes in an atomic way.

00:05:44.879 --> 00:05:46.920
So that means that you
can change multiple things

00:05:46.920 --> 00:05:49.260
in your app and then
apply them in one go.

00:05:49.260 --> 00:05:51.159
Sometimes you're
changing some things

00:05:51.159 --> 00:05:52.950
in one method that
depends on other changes

00:05:52.950 --> 00:05:55.900
to be live at the same time, so
you can bundle them up and then

00:05:55.900 --> 00:05:59.830
apply them in an atomic
way over a wire protocol.

00:05:59.830 --> 00:06:01.920
And this extends to
basically all the things

00:06:01.920 --> 00:06:03.420
you might change in a program.

00:06:03.420 --> 00:06:05.440
You can change the
superclass hierarchy,

00:06:05.440 --> 00:06:08.626
add new fields to classes,
add new methods, of course,

00:06:08.626 --> 00:06:10.000
and mess with the
implementations

00:06:10.000 --> 00:06:10.720
of these things.

00:06:10.720 --> 00:06:13.110
It just gives you
a very fluid way,

00:06:13.110 --> 00:06:15.025
and one way of thinking
of this is it's

00:06:15.025 --> 00:06:17.390
a very, very powerful debugger.

00:06:17.390 --> 00:06:21.072
It's really a compelling
thing to have.

00:06:21.072 --> 00:06:23.530
This is a known thing from
other languages and the systems,

00:06:23.530 --> 00:06:25.446
and we're just trying
to bring that technology

00:06:25.446 --> 00:06:27.970
to Dart as well, even in a
setting where you're running

00:06:27.970 --> 00:06:31.760
your development environment
on one machine and your system

00:06:31.760 --> 00:06:32.840
on a mobile phone.

00:06:35.770 --> 00:06:37.352
The third thing
that we're doing,

00:06:37.352 --> 00:06:39.060
which is a bit more
sort of experimental,

00:06:39.060 --> 00:06:42.750
is the work on isolates that
makes us sort of even more

00:06:42.750 --> 00:06:45.290
concurrent than we are today.

00:06:45.290 --> 00:06:47.294
We're experimenting with
making it a lot cheaper

00:06:47.294 --> 00:06:49.585
to do blocking operations,
because they're conceptually

00:06:49.585 --> 00:06:53.859
a lot simpler than
the async limitations.

00:06:53.859 --> 00:06:55.400
But it has to be
really, really cheap

00:06:55.400 --> 00:06:58.670
so you don't get scalability
issues out of that.

00:06:58.670 --> 00:07:00.500
Another thing that
we've made work

00:07:00.500 --> 00:07:05.710
here is that it actually scales
to 100,000 concurrent isolates.

00:07:05.710 --> 00:07:08.590
And we've done this by being
really, really aggressive

00:07:08.590 --> 00:07:11.566
in how much we can share
between these isolates

00:07:11.566 --> 00:07:13.440
and have them start out
really, really small.

00:07:13.440 --> 00:07:15.640
So if you're doing like
just a few computations,

00:07:15.640 --> 00:07:19.725
like one example here was let's
block on some database query,

00:07:19.725 --> 00:07:21.600
then basically you're
not doing a lot of work

00:07:21.600 --> 00:07:24.810
on that isolate so the
overhead can be really small.

00:07:24.810 --> 00:07:28.120
An isolate starts out
being around 4K of memory,

00:07:28.120 --> 00:07:30.610
and that includes the optic
heap and a small stack

00:07:30.610 --> 00:07:33.260
for the execution, and
then it grows from there.

00:07:33.260 --> 00:07:36.472
And the trick is, of course,
to share all the program

00:07:36.472 --> 00:07:38.930
structures, all the classes,
all the byte codes between all

00:07:38.930 --> 00:07:41.450
the isolates that run the
same sort of code base,

00:07:41.450 --> 00:07:43.915
you could say, and just only
pay for the differences.

00:07:46.570 --> 00:07:47.820
So how does it all fit in?

00:07:47.820 --> 00:07:50.330
Let's focus on the iOS case.

00:07:50.330 --> 00:07:52.590
On iOS, you might have
a lot of native code

00:07:52.590 --> 00:07:54.576
that uses native
widgets, and you

00:07:54.576 --> 00:07:56.450
might have some Dart
code in the mix as well.

00:07:56.450 --> 00:07:57.866
Underneath that
thing there, there

00:07:57.866 --> 00:07:59.910
is this Fletch
runtime that runs it,

00:07:59.910 --> 00:08:01.520
and on your development
machine that

00:08:01.520 --> 00:08:04.230
might be a little bit weird
to use a Linux machine up

00:08:04.230 --> 00:08:08.190
against an iOS device, but
let's assume that works well.

00:08:08.190 --> 00:08:12.400
You have your SDK that allows
you to debug, inspect, modify

00:08:12.400 --> 00:08:13.640
code as it's running.

00:08:13.640 --> 00:08:15.440
And the sort of thing
I point out here

00:08:15.440 --> 00:08:17.580
is the sort of the
wire protocol allows

00:08:17.580 --> 00:08:20.420
us to interact with the runtime,
change things, and inspect

00:08:20.420 --> 00:08:22.320
the state and work
with the code, sort

00:08:22.320 --> 00:08:26.460
of a really powerful debugging
interface, you could say.

00:08:26.460 --> 00:08:29.690
So if we dive into what
this SDK might turn into,

00:08:29.690 --> 00:08:32.927
this is a little bit sort of
up in the air in the sense

00:08:32.927 --> 00:08:35.510
that this is a preview of what
we might actually put in there.

00:08:35.510 --> 00:08:37.134
So it's a little bit
of a vision thing.

00:08:37.134 --> 00:08:39.460
But I just want to give you
a feel for how this thing

00:08:39.460 --> 00:08:42.250
actually might play out.

00:08:42.250 --> 00:08:43.950
At the core of it,
we want to make sure

00:08:43.950 --> 00:08:46.460
that we have great command line
tools for working with Dart

00:08:46.460 --> 00:08:48.800
code, and we feel like
focusing on command line

00:08:48.800 --> 00:08:51.066
first is a nice place to start.

00:08:51.066 --> 00:08:52.440
It allows us to
sort of formulate

00:08:52.440 --> 00:08:54.470
the concepts and the
things you work with,

00:08:54.470 --> 00:08:55.887
and then sort of
build from there.

00:08:55.887 --> 00:08:57.803
So this is probably going
to look a little bit

00:08:57.803 --> 00:08:59.650
like an interactive
debug in many ways.

00:08:59.650 --> 00:09:02.630
So we imagine that
having a way of running

00:09:02.630 --> 00:09:05.100
Dart code through a tool
like this, starting it

00:09:05.100 --> 00:09:08.700
up maybe on the device or
maybe on a local setting,

00:09:08.700 --> 00:09:11.374
would feel pretty
natural to most people.

00:09:11.374 --> 00:09:12.790
Of course, you can
set breakpoints

00:09:12.790 --> 00:09:15.287
in your code and interact
with it through that.

00:09:15.287 --> 00:09:17.620
Imagine you set a breakpoint
in an updateDisplay method,

00:09:17.620 --> 00:09:20.740
and you hit that breakpoint,
an isolate pauses,

00:09:20.740 --> 00:09:24.270
and you can see in the command
line here in this output

00:09:24.270 --> 00:09:28.460
that you're paused at a
specific expression in there.

00:09:28.460 --> 00:09:30.667
This is just like a
debugger, you could say.

00:09:30.667 --> 00:09:32.750
So what happens if you
realize that there actually

00:09:32.750 --> 00:09:35.125
is a small bug here or something
you'd like to play with?

00:09:35.125 --> 00:09:39.256
And maybe this code is not
exactly what it should be.

00:09:39.256 --> 00:09:40.630
You can step
through and actually

00:09:40.630 --> 00:09:43.844
sort of understand why it's not
doing what you expect it to do.

00:09:43.844 --> 00:09:46.260
For instance, if you debug and
step to the next statement,

00:09:46.260 --> 00:09:47.801
you might see that
the state changes.

00:09:47.801 --> 00:09:51.960
Like the x plus position
variable here changes its value

00:09:51.960 --> 00:09:53.612
from null to 20 in this case.

00:09:53.612 --> 00:09:55.320
Maybe that's not what
you were expecting.

00:09:55.320 --> 00:09:57.490
Maybe it should've
been something else.

00:09:57.490 --> 00:10:00.280
So if you wanted to fix
a number in here and say,

00:10:00.280 --> 00:10:01.810
that number's not
entirely correct.

00:10:01.810 --> 00:10:04.140
I want to update
that to 100 instead,

00:10:04.140 --> 00:10:06.820
for instance, you
would just go edit

00:10:06.820 --> 00:10:09.310
that in your favorite
editor, and the system

00:10:09.310 --> 00:10:11.000
would realize that
you'd done a change

00:10:11.000 --> 00:10:13.420
and tell you about that when
you start applying them.

00:10:13.420 --> 00:10:15.330
So it might look
something like this.

00:10:15.330 --> 00:10:19.400
Like we can tell that you've
updated this 10 to 100.

00:10:19.400 --> 00:10:21.580
We can apply all these
changes to the running system

00:10:21.580 --> 00:10:24.020
in an atomic operation,
and we can actually

00:10:24.020 --> 00:10:26.820
tell you exactly what we're
doing to which methods and just

00:10:26.820 --> 00:10:28.380
apply it and make it happen.

00:10:28.380 --> 00:10:30.100
Once you've changed
code over there,

00:10:30.100 --> 00:10:31.530
you may want to
restart the method

00:10:31.530 --> 00:10:34.000
and start over and do
the computations again,

00:10:34.000 --> 00:10:35.004
if that's safe.

00:10:35.004 --> 00:10:36.670
And let's assume that
it is, so you just

00:10:36.670 --> 00:10:38.930
rewind the method and
start stepping through it.

00:10:38.930 --> 00:10:41.441
Now it's a plus 100 instead,
so it behaves a little bit

00:10:41.441 --> 00:10:41.940
differently.

00:10:41.940 --> 00:10:45.380
So you get 110 out
instead of the 20.

00:10:45.380 --> 00:10:47.110
And assuming that
was what you wanted,

00:10:47.110 --> 00:10:50.820
you've updated your code,
and you learned something

00:10:50.820 --> 00:10:52.120
about how it works in practice.

00:10:52.120 --> 00:10:54.420
And updating is actually
an interesting part,

00:10:54.420 --> 00:10:57.640
but also this notion of working
with the code in a live setting

00:10:57.640 --> 00:10:58.530
is really powerful.

00:10:58.530 --> 00:11:01.460
It gives you better insight
into how it's actually behaving.

00:11:01.460 --> 00:11:04.310
And just feeling comfortable,
just trying things out,

00:11:04.310 --> 00:11:05.160
is really powerful.

00:11:08.560 --> 00:11:10.500
You can, of course,
debug even more,

00:11:10.500 --> 00:11:14.110
delete breakpoints, and
resume, and off you go.

00:11:14.110 --> 00:11:17.950
So this is just to illustrate
how this atomic application

00:11:17.950 --> 00:11:19.835
of changes could work out.

00:11:19.835 --> 00:11:21.460
We will keep track
of what you changed,

00:11:21.460 --> 00:11:22.959
and we will allow
you to update them

00:11:22.959 --> 00:11:24.430
in one go over a wire protocol.

00:11:27.770 --> 00:11:32.030
So Fletch as a
runtime system for iOS

00:11:32.030 --> 00:11:33.780
is something we really
want you to get out

00:11:33.780 --> 00:11:35.790
to you so you can start
building things that

00:11:35.790 --> 00:11:37.550
run on iOS in a nice way.

00:11:37.550 --> 00:11:42.960
So we're working very hard on
getting an early version of it

00:11:42.960 --> 00:11:48.420
ready in Q3 so that it's ready
for proper feedback from you

00:11:48.420 --> 00:11:49.130
guys.

00:11:49.130 --> 00:11:52.000
And then we want a productize
it and make it into a real thing

00:11:52.000 --> 00:11:55.220
that you can depend
on later this year.

00:11:55.220 --> 00:11:58.220
It's only part of the
story, because having

00:11:58.220 --> 00:11:59.830
a way of running
Dart code on mobile

00:11:59.830 --> 00:12:01.860
is exciting-- at
least to some of us--

00:12:01.860 --> 00:12:04.720
but we also need to figure out
what do you then build on top

00:12:04.720 --> 00:12:06.450
and how do we make
all that fit together.

00:12:06.450 --> 00:12:08.510
So there's something
missing here.

00:12:08.510 --> 00:12:10.250
Just after we have
the runtime system,

00:12:10.250 --> 00:12:12.600
we need to start building
real applications.

00:12:12.600 --> 00:12:15.540
I'm going to dive into
how we see that happening.

00:12:15.540 --> 00:12:18.060
We call that Dart for mobile.

00:12:18.060 --> 00:12:20.190
In the iOS case, we
considered building this

00:12:20.190 --> 00:12:23.145
on top of the runtime.

00:12:23.145 --> 00:12:25.810
And we have some guiding
principles in this space.

00:12:25.810 --> 00:12:28.685
We want to have a nice
layered approach where

00:12:28.685 --> 00:12:31.320
we make use of existing
native functionality.

00:12:31.320 --> 00:12:35.260
We want to keep it
low-level, fast, and simple.

00:12:35.260 --> 00:12:37.450
And we want to try
to avoid enforcing

00:12:37.450 --> 00:12:38.890
too many abstractions.

00:12:38.890 --> 00:12:41.930
So we want to make sure that
if the abstractions that we

00:12:41.930 --> 00:12:45.060
provide are not entirely
correct for what you're doing,

00:12:45.060 --> 00:12:47.150
there's a lower level
you can go to and build

00:12:47.150 --> 00:12:49.040
your own frameworks
on top instead.

00:12:49.040 --> 00:12:54.400
So it's an attempt to make
sort of a layer of offerings

00:12:54.400 --> 00:12:59.130
here where if the highest level
of abstraction that we offer

00:12:59.130 --> 00:13:02.575
is slightly wrong for you, there
is a layer below you can go to.

00:13:02.575 --> 00:13:04.950
I'm going to give you examples
of what these layers might

00:13:04.950 --> 00:13:07.360
look like, and maybe that makes
it a little bit more concrete.

00:13:07.360 --> 00:13:09.651
But this is the guiding
principles of what we're doing.

00:13:12.240 --> 00:13:17.630
So the way we interact or
interoperate with native code

00:13:17.630 --> 00:13:20.070
is through a sort of
cross-language support

00:13:20.070 --> 00:13:22.880
based on a structured
messaging mechanism.

00:13:22.880 --> 00:13:25.500
So imagine you have UI code
for Android written in Java,

00:13:25.500 --> 00:13:28.140
and you have some UI code for
iOS written in Objective C,

00:13:28.140 --> 00:13:30.580
and you have, hopefully,
lots and lots of Dart code

00:13:30.580 --> 00:13:34.410
that are exposing a number
of services to this UI code,

00:13:34.410 --> 00:13:36.190
we're building
support for allowing

00:13:36.190 --> 00:13:41.430
you to access all these services
in a low-level, but fairly sane

00:13:41.430 --> 00:13:43.000
way.

00:13:43.000 --> 00:13:44.500
So the way it looks
is that you have

00:13:44.500 --> 00:13:48.290
a description of a service, and
it's in sort of a low-level IDL

00:13:48.290 --> 00:13:49.430
format.

00:13:49.430 --> 00:13:51.070
In this case, there
is an echo service

00:13:51.070 --> 00:13:52.680
that has a simple echo method.

00:13:52.680 --> 00:13:54.727
You can see that it's
actually describing

00:13:54.727 --> 00:13:56.310
how many bits these
integers are going

00:13:56.310 --> 00:13:59.610
to take up in the protocol.

00:13:59.610 --> 00:14:01.690
So it's designed to
be fairly low-level

00:14:01.690 --> 00:14:06.320
so you can tweak it and
make things very compact.

00:14:06.320 --> 00:14:08.914
On the Dart side, if you want
to implement this service,

00:14:08.914 --> 00:14:10.080
it's fairly straightforward.

00:14:10.080 --> 00:14:12.660
You just go ahead and
implement the echo method,

00:14:12.660 --> 00:14:15.240
and in this case just
return the integer.

00:14:15.240 --> 00:14:18.040
The interesting part is
really on the client side.

00:14:18.040 --> 00:14:20.530
We're generating code to
make all this fit together,

00:14:20.530 --> 00:14:22.440
and we're generating
steps for C++--

00:14:22.440 --> 00:14:25.910
it works well in the
Objective C case, too--

00:14:25.910 --> 00:14:29.912
that allows you to call these
methods as static methods.

00:14:29.912 --> 00:14:31.730
And you can choose if
you want to call them

00:14:31.730 --> 00:14:34.290
in a synchronous way or
you wait for the result.

00:14:34.290 --> 00:14:36.124
In a lot cases, that's
the simplest version.

00:14:36.124 --> 00:14:37.998
But there are also cases
if you're doing work

00:14:37.998 --> 00:14:39.930
from a UI thread,
that it really doesn't

00:14:39.930 --> 00:14:41.632
work for you to block and wait.

00:14:41.632 --> 00:14:43.840
So we allow you to call
these things in an async way,

00:14:43.840 --> 00:14:46.830
too, and get a callback
when the things are done.

00:14:46.830 --> 00:14:50.410
In C++ there is no built-in
support for futures or promises

00:14:50.410 --> 00:14:54.370
or even async in a way, so here
it's back to somewhat annoying

00:14:54.370 --> 00:14:55.200
callbacks.

00:14:55.200 --> 00:14:57.630
It's low-level, and we do
imagine the people will

00:14:57.630 --> 00:15:00.090
build something on top.

00:15:00.090 --> 00:15:01.640
It's really fast,
though, and I think

00:15:01.640 --> 00:15:03.740
that's the core point here.

00:15:03.740 --> 00:15:08.370
It's low-level and fast, and
it's fairly simple to extend.

00:15:08.370 --> 00:15:11.560
Like, the Java version
is somewhat similar.

00:15:11.560 --> 00:15:14.060
The biggest difference is in
the async case where you're not

00:15:14.060 --> 00:15:16.880
passing a function
reference but some sort

00:15:16.880 --> 00:15:20.864
of an instance of an interface.

00:15:20.864 --> 00:15:22.780
So that's sort of how
we, at the lowest level,

00:15:22.780 --> 00:15:24.237
imagine binding things together.

00:15:24.237 --> 00:15:26.070
Clearly just passing
integers back and forth

00:15:26.070 --> 00:15:27.600
is not that interesting.

00:15:27.600 --> 00:15:30.210
You can do things with that,
but it's a little bit limiting,

00:15:30.210 --> 00:15:32.970
so we do allow you to have
more structured messages.

00:15:32.970 --> 00:15:36.864
So there a format for
describing these structures,

00:15:36.864 --> 00:15:38.280
and they can have
fields, and they

00:15:38.280 --> 00:15:40.450
can have basically entire
trees of structures

00:15:40.450 --> 00:15:41.640
that you can build.

00:15:41.640 --> 00:15:44.420
And you can serialize
them into a binary form,

00:15:44.420 --> 00:15:46.550
and that's the one
we send across.

00:15:46.550 --> 00:15:48.350
And the reason why
we're doing this,

00:15:48.350 --> 00:15:52.070
even though it feels maybe
annoying to have to write this

00:15:52.070 --> 00:15:53.970
and a bit cumbersome
to use, is that we

00:15:53.970 --> 00:15:56.814
want these languages to have
a shared understanding of what

00:15:56.814 --> 00:15:58.980
they're interacting over
and what kind of data types

00:15:58.980 --> 00:16:01.280
flow between them.

00:16:01.280 --> 00:16:03.280
So in this case,
you can see that you

00:16:03.280 --> 00:16:06.440
can build an entire tree of
persons, like a hierarchy,

00:16:06.440 --> 00:16:08.500
here with the children list.

00:16:08.500 --> 00:16:10.800
And then you might
actually send a reference

00:16:10.800 --> 00:16:14.330
to sort of a structure of
these things across the wire

00:16:14.330 --> 00:16:18.050
and get a count of all the
people or persons in a tree

00:16:18.050 --> 00:16:18.550
bank.

00:16:21.182 --> 00:16:22.640
Everything runs in
the same process

00:16:22.640 --> 00:16:25.610
in this model, which makes a
lot of things a lot simpler.

00:16:25.610 --> 00:16:28.070
So the messages that
we send are actually

00:16:28.070 --> 00:16:30.350
encoded as binary data.

00:16:30.350 --> 00:16:33.470
We don't do any sort of
expensive encoding or decoding.

00:16:33.470 --> 00:16:36.140
We're not producing a
tree of Dart objects

00:16:36.140 --> 00:16:38.130
that you walk
through afterwards.

00:16:38.130 --> 00:16:40.750
We're actually basically
just deconstructing

00:16:40.750 --> 00:16:43.530
this binary thing as you
work with the structure.

00:16:43.530 --> 00:16:46.300
So if there are areas you never
touch in that binary message,

00:16:46.300 --> 00:16:47.720
it costs nothing.

00:16:47.720 --> 00:16:49.172
And this is in
contrast with JSON

00:16:49.172 --> 00:16:50.630
or even protobufs
where you usually

00:16:50.630 --> 00:16:53.550
build up a Dart representation
of the entire message

00:16:53.550 --> 00:16:55.100
and then start looking into it.

00:16:55.100 --> 00:16:57.520
So really the binary
data that you send across

00:16:57.520 --> 00:16:58.890
is the primary thing.

00:16:58.890 --> 00:17:00.690
Again, low-level,
but very efficient.

00:17:02.659 --> 00:17:04.950
The reason why everything
runs through the same process

00:17:04.950 --> 00:17:06.710
is that we allow the
native application

00:17:06.710 --> 00:17:08.579
to be in control
of this process.

00:17:08.579 --> 00:17:10.700
It's the one invoking
all the Dart services.

00:17:10.700 --> 00:17:13.380
We just link it into the
same application and the Dart

00:17:13.380 --> 00:17:14.220
runtime.

00:17:14.220 --> 00:17:16.925
In many ways, it
doesn't really--

00:17:16.925 --> 00:17:19.300
it's just an implementation
detail, like your native app,

00:17:19.300 --> 00:17:21.966
that you've decided to include a
runtime that runs on Dart code,

00:17:21.966 --> 00:17:22.585
too.

00:17:22.585 --> 00:17:24.390
It's very simple.

00:17:24.390 --> 00:17:26.680
So I'd like to try to
show you a demo of what

00:17:26.680 --> 00:17:28.719
we can do with this
thing on an iPad, so let

00:17:28.719 --> 00:17:29.760
me try to switch to that.

00:17:33.610 --> 00:17:36.320
So we've built a
small sample here.

00:17:36.320 --> 00:17:38.640
It runs on Dart on top
of a Fletch runtime,

00:17:38.640 --> 00:17:41.100
and it talks to
some GitHub APIs,

00:17:41.100 --> 00:17:44.420
and it shows you a list of
GitHub commits for the Fletch

00:17:44.420 --> 00:17:46.115
project.

00:17:46.115 --> 00:17:47.470
Let me fire it up.

00:17:47.470 --> 00:17:49.720
So one of the hardest
things you do in this space

00:17:49.720 --> 00:17:52.410
is these infinite
scrolling lists of whatnot.

00:17:52.410 --> 00:17:57.680
So you have basically a lot
of data inside the Dart model,

00:17:57.680 --> 00:18:01.530
and you want to show a
part of it, a view of it,

00:18:01.530 --> 00:18:04.470
and you want to update that view
as you scroll through the thing

00:18:04.470 --> 00:18:05.240
here.

00:18:05.240 --> 00:18:09.160
So all the data you have
in here are actually

00:18:09.160 --> 00:18:11.830
stored in the Dart
side of the world,

00:18:11.830 --> 00:18:17.690
and it's super smooth and sort
of a real native widget thing.

00:18:17.690 --> 00:18:21.150
There is even sort of
a pagination going on

00:18:21.150 --> 00:18:23.400
that we will fetch
things in the background

00:18:23.400 --> 00:18:25.590
when we feel like we're
getting close to the limit

00:18:25.590 --> 00:18:26.970
and fill in more data.

00:18:26.970 --> 00:18:29.040
All that stuff happens
on the Dart side.

00:18:29.040 --> 00:18:31.760
And the only thing that
we then communicate

00:18:31.760 --> 00:18:35.570
from the Dart part of the
world to the native part--

00:18:35.570 --> 00:18:38.630
in this case, the iOS
version-- is the thing

00:18:38.630 --> 00:18:40.090
you can see on the screen.

00:18:40.090 --> 00:18:42.230
So we can scroll back and forth,
and you can come play with it

00:18:42.230 --> 00:18:42.730
afterwards.

00:18:42.730 --> 00:18:45.340
It's a fairly simple
thing, but it just

00:18:45.340 --> 00:18:47.320
shows that you
can take something

00:18:47.320 --> 00:18:50.230
that involves talking to
a server written in Dart

00:18:50.230 --> 00:18:53.480
and expose it to native code
in a fairly efficient way.

00:18:53.480 --> 00:18:55.330
Like Fletch is not
the fastest system

00:18:55.330 --> 00:18:57.871
in the world in the sense that
it's doing pure interpretation

00:18:57.871 --> 00:18:58.980
on this device.

00:18:58.980 --> 00:19:00.710
But, I mean, in a
lot of cases, it's

00:19:00.710 --> 00:19:03.800
certainly fast enough to
build these real things.

00:19:03.800 --> 00:19:06.810
So it looks pretty
promising to that extent.

00:19:06.810 --> 00:19:08.500
And we can continue
scrolling here,

00:19:08.500 --> 00:19:10.250
and it will just fill
in more information.

00:19:10.250 --> 00:19:12.125
It builds up fairly
large structures quickly,

00:19:12.125 --> 00:19:14.220
but it looks pretty good.

00:19:14.220 --> 00:19:17.140
Does that makes sense?

00:19:17.140 --> 00:19:20.100
Let's talk a little bit about
how that's actually built.

00:19:20.100 --> 00:19:25.730
So it's sort of an infinite
GitHub commit list.

00:19:25.730 --> 00:19:27.460
We showed them with
native widgets.

00:19:27.460 --> 00:19:29.380
And the way we plug all
these things together

00:19:29.380 --> 00:19:34.000
is using, at the lowest level,
this service description

00:19:34.000 --> 00:19:36.630
that we then build
things on top of.

00:19:36.630 --> 00:19:40.340
So in this case, we've
decided to build a layer

00:19:40.340 --> 00:19:44.280
on top of the services that
have sort of a reactant spider

00:19:44.280 --> 00:19:47.200
or a sort of
unidrectional flow model

00:19:47.200 --> 00:19:52.150
for showing parts of a
Dart model in a native UI.

00:19:52.150 --> 00:19:54.060
The way it actually
works is fairly simple,

00:19:54.060 --> 00:19:55.460
at least in the abstract.

00:19:55.460 --> 00:19:59.510
You have a Dart model that
defines a presentation graph,

00:19:59.510 --> 00:20:01.250
and in this case, the
presentation graph

00:20:01.250 --> 00:20:04.390
is what's actually
shown on the device.

00:20:04.390 --> 00:20:05.480
So it's not everything.

00:20:05.480 --> 00:20:07.542
It's the subset
that you can see.

00:20:07.542 --> 00:20:09.500
That is a presentation
that then is interpreted

00:20:09.500 --> 00:20:13.380
by the native UI, turned into
native widgets, you can say,

00:20:13.380 --> 00:20:17.410
and if the native UI determines
that you are doing something

00:20:17.410 --> 00:20:19.870
to some of these elements,
it will delegate it then back

00:20:19.870 --> 00:20:22.722
to the presentation, and these
events will then potentially

00:20:22.722 --> 00:20:24.930
update state inside the
model like telling the system

00:20:24.930 --> 00:20:26.340
that you've scrolled.

00:20:26.340 --> 00:20:28.861
So it feels like a
fairly nice model for it,

00:20:28.861 --> 00:20:31.110
because it decouples the
Dart model from the native UI

00:20:31.110 --> 00:20:33.480
in a very clean and sane way.

00:20:33.480 --> 00:20:36.310
All they sort of interact with
is this presentation stuff,

00:20:36.310 --> 00:20:38.200
and they do it in a
very orderly manner

00:20:38.200 --> 00:20:41.150
by letting sort
of everything flow

00:20:41.150 --> 00:20:42.660
in a sort of unidirectional way.

00:20:45.415 --> 00:20:47.290
I'm not expecting you
can actually read this.

00:20:47.290 --> 00:20:49.080
I'll go into detail so
you can see it later.

00:20:49.080 --> 00:20:51.079
Don't worry too much about
it, but basically you

00:20:51.079 --> 00:20:53.267
have a Dart model on
the side with Dart code.

00:20:53.267 --> 00:20:54.850
You have a presentation
in the middle,

00:20:54.850 --> 00:20:59.140
which is a small language for
defining this presentation

00:20:59.140 --> 00:21:00.300
graph.

00:21:00.300 --> 00:21:05.300
And then there is native
iOS code on the right side

00:21:05.300 --> 00:21:10.430
here for constructing real
table views and cells for those

00:21:10.430 --> 00:21:12.730
and delegating events back.

00:21:12.730 --> 00:21:17.940
So if we start at the
presentation level here,

00:21:17.940 --> 00:21:22.620
let's talk about what that thing
is and how we can define it.

00:21:22.620 --> 00:21:26.134
As I said, it is defined on
top of the service description

00:21:26.134 --> 00:21:28.300
that we've built, but we've
found that it's actually

00:21:28.300 --> 00:21:32.980
kind of nice to be able to
introduce this notion of nodes

00:21:32.980 --> 00:21:34.190
in this presentation graph.

00:21:34.190 --> 00:21:37.900
These are application-specific
data type, you could say,

00:21:37.900 --> 00:21:41.490
and in this case, it corresponds
to a list of commits.

00:21:41.490 --> 00:21:44.160
That is, like the visible
stuff, and as some

00:21:44.160 --> 00:21:47.510
of these commit nodes with
an author and a message

00:21:47.510 --> 00:21:50.602
and a way of sending back,
delegating events back

00:21:50.602 --> 00:21:52.810
into the system, in this
case, by clicking something,

00:21:52.810 --> 00:21:54.260
for instance.

00:21:54.260 --> 00:21:56.940
So you can write this
for your application,

00:21:56.940 --> 00:21:59.440
write the data type that
makes sense for you,

00:21:59.440 --> 00:22:03.740
and you can create this
from the Dart side then.

00:22:03.740 --> 00:22:06.390
And let's take a look
at how that might look.

00:22:06.390 --> 00:22:09.730
The Dart model
will actually find

00:22:09.730 --> 00:22:11.910
some way of fetching
information from the network

00:22:11.910 --> 00:22:13.680
or building that
up, build a model,

00:22:13.680 --> 00:22:17.340
and then basically have a method
called, in this case, percent,

00:22:17.340 --> 00:22:19.920
that will return a node from
this presentation graph,

00:22:19.920 --> 00:22:23.090
construct it like
flux and react.

00:22:23.090 --> 00:22:24.820
On demand you create
this list node

00:22:24.820 --> 00:22:26.520
with some commits
in there, and then

00:22:26.520 --> 00:22:29.990
the system actually will
look at the last presentation

00:22:29.990 --> 00:22:32.330
graph you sent across
to the other side,

00:22:32.330 --> 00:22:35.240
do a diff of those two
things, and only send

00:22:35.240 --> 00:22:38.120
a patch set across the wire.

00:22:38.120 --> 00:22:40.590
And we do this for
you by if you use

00:22:40.590 --> 00:22:42.964
this kind of way of defining
a presentation graph,

00:22:42.964 --> 00:22:44.380
we give you the
diffing algorithms

00:22:44.380 --> 00:22:46.180
and all that for free.

00:22:46.180 --> 00:22:48.310
So all you have to do is
basically think about,

00:22:48.310 --> 00:22:51.160
in the abstract
terms, what things

00:22:51.160 --> 00:22:52.492
constitute my presentation.

00:22:52.492 --> 00:22:54.700
And then, of course, you
have to write the code, too.

00:22:54.700 --> 00:22:57.890
But actually it takes
the presentation

00:22:57.890 --> 00:23:00.950
and turns it into real
native UI widgets.

00:23:00.950 --> 00:23:04.370
You could imagine building
like a more generic set

00:23:04.370 --> 00:23:07.220
of presentation graph
nodes and then sharing

00:23:07.220 --> 00:23:09.650
some of the native code
across multiple applications

00:23:09.650 --> 00:23:11.160
if that make sense to you.

00:23:11.160 --> 00:23:13.360
But it's kind of nice
to think of this model

00:23:13.360 --> 00:23:16.190
as it allows you to have
application-specific

00:23:16.190 --> 00:23:19.850
presentations that you then
write a bit of, in this case,

00:23:19.850 --> 00:23:24.492
Objective C code for mapping
to the native widgets.

00:23:24.492 --> 00:23:26.700
And the nice thing is that
we'll give you a patch set

00:23:26.700 --> 00:23:30.140
and tell you what's changed,
what's been updated so you only

00:23:30.140 --> 00:23:31.670
modify those things.

00:23:31.670 --> 00:23:33.550
So basically you just
run through whatever

00:23:33.550 --> 00:23:36.240
we tell you has
changed, not everything.

00:23:36.240 --> 00:23:38.650
And that's the reason why it
actually works so smoothly

00:23:38.650 --> 00:23:40.110
and it works so well.

00:23:40.110 --> 00:23:42.470
And if you have questions
about this thing,

00:23:42.470 --> 00:23:43.950
Ian is in the
audience, and he'll

00:23:43.950 --> 00:23:47.006
be happy to-- he's
raising his hand here.

00:23:47.006 --> 00:23:49.130
At least the people in the
room have an opportunity

00:23:49.130 --> 00:23:53.270
to hunt him down afterwards
and learn more about this set

00:23:53.270 --> 00:23:55.090
up we're building.

00:23:55.090 --> 00:23:57.870
It is layered, so you
will find that anything

00:23:57.870 --> 00:24:00.235
you describe in the
presentation graph description,

00:24:00.235 --> 00:24:03.150
if we go back to that
in here, is actually

00:24:03.150 --> 00:24:06.640
compiled into a set
of services that you

00:24:06.640 --> 00:24:07.730
access across the wire.

00:24:07.730 --> 00:24:11.130
And the definition for
the structured messages

00:24:11.130 --> 00:24:14.560
that are involved in sending
these binary patches across

00:24:14.560 --> 00:24:17.049
are these patch sets.

00:24:17.049 --> 00:24:18.590
And that's a reason
why we think it's

00:24:18.590 --> 00:24:20.150
nice to have a layered approach.

00:24:20.150 --> 00:24:22.860
If something below this
level makes more sense,

00:24:22.860 --> 00:24:24.850
then you can certainly
skip this and just

00:24:24.850 --> 00:24:29.120
interact with the runtime
in that way instead.

00:24:29.120 --> 00:24:30.762
So here's the model again.

00:24:30.762 --> 00:24:32.470
You see one thing I
didn't really mention

00:24:32.470 --> 00:24:34.670
is there's some hookup
here that tells you what

00:24:34.670 --> 00:24:36.420
to do when this is selected.

00:24:36.420 --> 00:24:39.567
It's basically just like
pulling in a Dart method here.

00:24:39.567 --> 00:24:41.900
But you're never calling the
select method from in here.

00:24:41.900 --> 00:24:44.780
That gets called through a
delegate event delegation

00:24:44.780 --> 00:24:47.390
mechanism.

00:24:47.390 --> 00:24:49.630
So the roadmap is
relatively simple.

00:24:49.630 --> 00:24:53.220
I told you that we are
going to ship Fletch first,

00:24:53.220 --> 00:24:55.120
and then we are going
to ship Dart for mobile

00:24:55.120 --> 00:24:56.360
at the end of the year.

00:24:56.360 --> 00:24:59.660
And Dart for mobile is
sort of the combination

00:24:59.660 --> 00:25:02.030
of the runtime support for
actually making this run

00:25:02.030 --> 00:25:03.630
on a device like you saw.

00:25:03.630 --> 00:25:07.381
It's a service description layer
that is, this low-level thing.

00:25:07.381 --> 00:25:09.380
And then there's a slightly
more opinionated way

00:25:09.380 --> 00:25:11.760
of expressing
presentation graphs

00:25:11.760 --> 00:25:14.611
and working with them
from the two sides.

00:25:14.611 --> 00:25:16.360
Hopefully this sort
of makes sense to you.

00:25:16.360 --> 00:25:17.651
It's a very practical approach.

00:25:17.651 --> 00:25:19.810
It's a very low-level
approach, but it's

00:25:19.810 --> 00:25:23.540
something that fits really
well into existing apps

00:25:23.540 --> 00:25:27.610
and works well in order for
us to have a native story that

00:25:27.610 --> 00:25:30.910
gives you real native
applications mostly,

00:25:30.910 --> 00:25:34.600
or partly, written in Dart.

00:25:34.600 --> 00:25:35.205
That's it.

00:25:43.910 --> 00:25:49.210
KEVIN: We have time for maybe
one question that's short.

00:25:49.210 --> 00:25:50.750
I scared them.

00:25:50.750 --> 00:25:52.690
I have a question.

00:25:52.690 --> 00:25:53.190
Anyone?

00:25:56.587 --> 00:25:57.670
KASPER LUND: Shoot, Kevin.

00:25:57.670 --> 00:25:59.253
KEVIN: How does your
definition format

00:25:59.253 --> 00:26:02.185
relate to things like
protobuf or other things?

00:26:02.185 --> 00:26:02.810
Like just the--

00:26:02.810 --> 00:26:03.000
KASPER LUND: IDL.

00:26:03.000 --> 00:26:04.040
KEVIN: --IDL format?

00:26:04.040 --> 00:26:06.415
KASPER LUND: So if you're
talking about the lowest level,

00:26:06.415 --> 00:26:08.060
like the service
description level,

00:26:08.060 --> 00:26:11.370
it's in many ways inspired
by protobufs and systems

00:26:11.370 --> 00:26:12.625
like Cap'n Proto.

00:26:12.625 --> 00:26:14.000
We've simplified
it a little bit,

00:26:14.000 --> 00:26:15.360
because we're running
in the same process

00:26:15.360 --> 00:26:17.640
so we're not worried about
version skews at all.

00:26:17.640 --> 00:26:20.942
So carrying around the weight
of having a protocol that

00:26:20.942 --> 00:26:22.900
guarantees forwards and
backwards compatibility

00:26:22.900 --> 00:26:24.340
is not necessary in our case.

00:26:24.340 --> 00:26:26.173
So it's, you could say,
a simplified version

00:26:26.173 --> 00:26:27.830
of mostly Cap'n Proto.

00:26:27.830 --> 00:26:29.710
KEVIN: So it's not
designed for persistence

00:26:29.710 --> 00:26:30.860
or over to the network?

00:26:30.860 --> 00:26:33.235
KASPER LUND: It's designed
for really fast communications

00:26:33.235 --> 00:26:36.480
between these two things
that are versioned together.

00:26:36.480 --> 00:26:37.517
Thank you.

00:26:37.517 --> 00:26:40.100
MALE SPEAKER: As usual, if you
have more questions for Kasper,

00:26:40.100 --> 00:26:40.910
he'll be around.

00:26:40.910 --> 00:26:42.920
Bug him later.

00:26:42.920 --> 00:26:44.440
I totally killed
the applause there

00:26:44.440 --> 00:26:46.320
by talking right when
everyone was about to start.

00:26:46.320 --> 00:26:46.920
KEVIN: For Kasper?

00:26:46.920 --> 00:26:48.336
MALE SPEAKER: A
round of applause.

00:26:48.336 --> 00:26:49.070
[APPLAUSE]

