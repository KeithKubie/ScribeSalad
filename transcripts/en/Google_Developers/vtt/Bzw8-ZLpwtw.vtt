WEBVTT
Kind: captions
Language: en

00:00:00.160 --> 00:00:01.900
MONA VAJOLAHI: I'm
Mona Vajolahi.

00:00:01.900 --> 00:00:04.560
I'm a product manager
at Google.

00:00:04.560 --> 00:00:08.630
I work on making the web fast,
and more specifically, I work

00:00:08.630 --> 00:00:10.750
on [INAUDIBLE] products.

00:00:10.750 --> 00:00:11.910
DOANTAM PHAN: My name's
Doantam Phan.

00:00:11.910 --> 00:00:13.690
I'm also a product manager
working on

00:00:13.690 --> 00:00:16.230
making the web fast.

00:00:16.230 --> 00:00:17.310
BRYAN MCQUADE: And I'm
Bryan McQuade.

00:00:17.310 --> 00:00:20.920
I'm the technical lead of
PageSpeed Insights.

00:00:20.920 --> 00:00:21.370
MONA VAJOLAHI: All right.

00:00:21.370 --> 00:00:26.310
So I want to start by showing
you a video that would capture

00:00:26.310 --> 00:00:28.140
the impact of the
recommendations that we are

00:00:28.140 --> 00:00:30.160
going to talk to you
about today.

00:00:30.160 --> 00:00:32.195
So here's a sample
Wikipedia page.

00:00:32.195 --> 00:00:36.470
We are going to load it on a
mobile device at 3G network.

00:00:36.470 --> 00:00:39.590
And on the left hand side,
you'll see the Wikipedia

00:00:39.590 --> 00:00:40.650
page-- the original version.

00:00:40.650 --> 00:00:43.160
Then the right hand side, the
optimized vision is after the

00:00:43.160 --> 00:00:45.960
implemented best practices
that we are going

00:00:45.960 --> 00:00:46.480
to share with you.

00:00:46.480 --> 00:00:47.730
So let me play the video.

00:00:51.430 --> 00:00:55.270
So as you can see, the original
one takes some time

00:00:55.270 --> 00:00:58.500
to show something on the page,
and overall the original

00:00:58.500 --> 00:01:01.050
finishes in five seconds,
whereas the optimized version

00:01:01.050 --> 00:01:02.450
finishes in two seconds.

00:01:02.450 --> 00:01:07.790
Now, let's have a closer look
at what's happening here.

00:01:07.790 --> 00:01:10.940
So even more interesting is
that the optimized version

00:01:10.940 --> 00:01:13.860
actually shows something on the
page around the one second

00:01:13.860 --> 00:01:17.920
mark, whereas in the original
version, we are staring at a

00:01:17.920 --> 00:01:20.860
blank screen for almost
three seconds.

00:01:20.860 --> 00:01:22.810
And here's what we are
going to do today.

00:01:22.810 --> 00:01:26.110
We are going to try to get
some content on the page

00:01:26.110 --> 00:01:27.750
around that one second mark.

00:01:27.750 --> 00:01:31.760
Let's see just a quick
agenda on the top.

00:01:31.760 --> 00:01:34.476
So we're talking about why speed
matters, and then we're

00:01:34.476 --> 00:01:36.470
going to share the
recommendations for creating

00:01:36.470 --> 00:01:37.950
an instant mobile performance.

00:01:37.950 --> 00:01:41.460
And also, in the end, Bryan is
going to do a deep dive in one

00:01:41.460 --> 00:01:45.250
example, and show you in action
how we can do that.

00:01:45.250 --> 00:01:50.530
So we all know that connection
speed on mobile, 3G or 4G, is

00:01:50.530 --> 00:01:54.190
slower than your average
connection speed on desktop.

00:01:54.190 --> 00:01:58.200
However, users on a mobile
device actually expect the

00:01:58.200 --> 00:02:02.370
sites to load as fast or even
faster as what they have on

00:02:02.370 --> 00:02:03.420
the desktop.

00:02:03.420 --> 00:02:04.580
So there's a problem.

00:02:04.580 --> 00:02:10.340
More than that, users of mobile
sites actually learn to

00:02:10.340 --> 00:02:11.510
avoid slow sites.

00:02:11.510 --> 00:02:13.946
And that first interaction that
they have with a site--

00:02:13.946 --> 00:02:16.330
the first experience they have--
is actually really,

00:02:16.330 --> 00:02:17.570
really important.

00:02:17.570 --> 00:02:22.020
In an experiment of adding one
second additional latency to a

00:02:22.020 --> 00:02:26.320
shopping site, it actually saw
that page views will decrease

00:02:26.320 --> 00:02:29.000
if you have additional latency,
conversion rates are

00:02:29.000 --> 00:02:31.940
going to drop, and bounce rates
are going to go up.

00:02:31.940 --> 00:02:35.940
More importantly, what happens
is that that experience sticks

00:02:35.940 --> 00:02:38.600
with the user, so they are less
likely to come back to

00:02:38.600 --> 00:02:44.710
the site, and less likely
to go back to the site.

00:02:44.710 --> 00:02:47.170
So here's what we want
to do today.

00:02:47.170 --> 00:02:50.270
We want to make that first
experience really fast and

00:02:50.270 --> 00:02:55.120
snappy, so that we actually get
the users to come back and

00:02:55.120 --> 00:02:56.370
visit the site more often.

00:03:00.660 --> 00:03:06.950
So the topic of today's talk--
we're going to show how we can

00:03:06.950 --> 00:03:11.910
get the most important content
of the site to the user under

00:03:11.910 --> 00:03:12.970
one second.

00:03:12.970 --> 00:03:15.950
So that most important content
usually is what you see above

00:03:15.950 --> 00:03:17.380
the fold of the page.

00:03:17.380 --> 00:03:18.720
And why did we pick
one second?

00:03:18.720 --> 00:03:22.290
Because user studies show that
that is the limit that people

00:03:22.290 --> 00:03:24.190
are going to pay attention
to your site.

00:03:24.190 --> 00:03:26.870
So after that one second of
staring at a blank screen,

00:03:26.870 --> 00:03:30.300
users are more likely to just
step away and basically never

00:03:30.300 --> 00:03:31.980
come back to your site.

00:03:31.980 --> 00:03:35.440
And today, the average page load
time on mobile is seven

00:03:35.440 --> 00:03:38.860
seconds, which is a huge gap
from where we want to be

00:03:38.860 --> 00:03:42.930
compared to where
we are today.

00:03:42.930 --> 00:03:48.260
Now, we all know 4G bandwidth
is much higher than 3G, so

00:03:48.260 --> 00:03:51.400
that should solve all our
problems, and basically

00:03:51.400 --> 00:03:54.680
experience on mobile would
be very fast on 4G.

00:03:54.680 --> 00:03:56.500
Well, not quite.

00:03:56.500 --> 00:04:00.140
Let's look at the difference
between bandwidth and latency.

00:04:00.140 --> 00:04:02.750
Bandwidth is the amount of
data transferred over the

00:04:02.750 --> 00:04:04.530
network per unit of time.

00:04:04.530 --> 00:04:08.020
So for example, a network can
have five megabit per second

00:04:08.020 --> 00:04:09.330
of bandwidth.

00:04:09.330 --> 00:04:12.720
However, latency is the delay
in transferring the packet

00:04:12.720 --> 00:04:15.340
from the source to
a destination.

00:04:15.340 --> 00:04:19.610
So for specifying latency, we
usually use round trip times.

00:04:19.610 --> 00:04:22.385
Now, if I have huge amounts of
data that I want to transfer

00:04:22.385 --> 00:04:25.110
on a network-- like, if I'm
loading a video, obviously,

00:04:25.110 --> 00:04:26.480
bandwidth matters a lot.

00:04:26.480 --> 00:04:30.210
But when I'm loading a page,
there's a lot of small

00:04:30.210 --> 00:04:33.660
requests going back and forth,
and in that case, bandwidth is

00:04:33.660 --> 00:04:35.490
not helping me a lot.

00:04:35.490 --> 00:04:38.080
So what happens is that latency
in loading your page

00:04:38.080 --> 00:04:39.990
is dominated by round
trip times.

00:04:39.990 --> 00:04:42.030
And now round trip times
on mobile networks

00:04:42.030 --> 00:04:44.760
are especially high.

00:04:44.760 --> 00:04:48.030
And on an average 3G network,
for example, you have a round

00:04:48.030 --> 00:04:51.910
trip between 100 milliseconds
to 450 milliseconds.

00:04:51.910 --> 00:04:54.225
On a 4G network, you
have between 60

00:04:54.225 --> 00:04:55.990
milliseconds and 180.

00:04:55.990 --> 00:04:58.340
And as you can see, the
difference between 3G and 4G

00:04:58.340 --> 00:05:00.250
is not huge here.

00:05:00.250 --> 00:05:04.040
So in order to get that snappy
user experience, we have to

00:05:04.040 --> 00:05:06.620
design for this high latency
environment.

00:05:06.620 --> 00:05:10.070
And we have to try to reduce the
number of round trips as

00:05:10.070 --> 00:05:11.410
much as possible.

00:05:11.410 --> 00:05:14.290
And that brings us to the rules
that we are going to

00:05:14.290 --> 00:05:15.660
share with you today.

00:05:15.660 --> 00:05:19.500
These are about how to create
a fast user experience in a

00:05:19.500 --> 00:05:21.070
high latency environment.

00:05:21.070 --> 00:05:24.920
It could be when I'm using my
mobile phone to load a page.

00:05:24.920 --> 00:05:27.840
It could be when I'm using my
laptop and connecting to a 3G

00:05:27.840 --> 00:05:30.520
network to load a page.

00:05:30.520 --> 00:05:34.550
So the four rules are, one,
avoid landing page redirects.

00:05:34.550 --> 00:05:37.120
Two, minimize server
response time.

00:05:37.120 --> 00:05:39.840
Three, eliminate render
blocking resources.

00:05:39.840 --> 00:05:42.490
And four, prioritize
visible content.

00:05:42.490 --> 00:05:44.220
Now, what we are going to do
is that we're going through

00:05:44.220 --> 00:05:47.100
each one of these rules, and
tell you why we picked those,

00:05:47.100 --> 00:05:50.110
and why they're useful.

00:05:50.110 --> 00:05:53.550
So let's just start by let's see
what happens when a user

00:05:53.550 --> 00:05:54.870
visits a site.

00:05:54.870 --> 00:05:57.450
So I'll go to my mobile device--
mobile browser.

00:05:57.450 --> 00:06:01.050
I enter www.example.com
in the browser.

00:06:01.050 --> 00:06:03.702
What happens is that there's
going to be a DNS lookup to

00:06:03.702 --> 00:06:04.990
fetch the IP.

00:06:04.990 --> 00:06:08.120
Then there's going to be a TCP
connection established.

00:06:08.120 --> 00:06:10.180
Then the request is sent
to the server.

00:06:10.180 --> 00:06:13.100
Server takes the request,
processes the response,

00:06:13.100 --> 00:06:15.840
generates the response, and
sends it back to the user.

00:06:15.840 --> 00:06:18.960
So we already have three
round trips, plus

00:06:18.960 --> 00:06:20.350
server processing time.

00:06:20.350 --> 00:06:23.470
Now, if I say, on an average
network, the round trip time

00:06:23.470 --> 00:06:27.310
is 200 milliseconds, that brings
us to 600 millisecond

00:06:27.310 --> 00:06:30.500
plus server response time.

00:06:30.500 --> 00:06:35.120
Now, let's say www.example.com
actually has a redirect to

00:06:35.120 --> 00:06:37.210
m.example.com.

00:06:37.210 --> 00:06:38.450
What happens then?

00:06:38.450 --> 00:06:42.800
In that case, there is another
DNS lookup, another TCP

00:06:42.800 --> 00:06:46.910
connection, another sender
response, which basically

00:06:46.910 --> 00:06:48.110
doubles our latency.

00:06:48.110 --> 00:06:49.950
So there is three additional
round trips.

00:06:49.950 --> 00:06:53.820
If we are over SSL, it's
actually four, and brings us

00:06:53.820 --> 00:06:56.270
to 1.2 second total latency.

00:06:56.270 --> 00:06:59.170
And this is all before
any of your HTML

00:06:59.170 --> 00:07:01.760
content gets to the browser.

00:07:01.760 --> 00:07:03.660
Now, if you look at this, there
are parts of this that

00:07:03.660 --> 00:07:06.000
I, as a developer, have
no control over.

00:07:06.000 --> 00:07:09.310
I cannot do anything about DNS
lookup, TCP connection, send

00:07:09.310 --> 00:07:09.540
and receive.

00:07:09.540 --> 00:07:13.460
But what I do have control
over is the redirect and

00:07:13.460 --> 00:07:15.060
server response time.

00:07:15.060 --> 00:07:22.250
And that brings us to the first
two rules that says,

00:07:22.250 --> 00:07:25.550
avoid any landing page redirects
and minimize server

00:07:25.550 --> 00:07:28.320
processing time as much as
possible to reduce that

00:07:28.320 --> 00:07:30.650
latency and to minimize
the RTT time.

00:07:30.650 --> 00:07:33.120
Now, Doantam is going to tell
you more about these next two

00:07:33.120 --> 00:07:35.966
rules, and why they are
really important.

00:07:35.966 --> 00:07:37.480
DOANTAM PHAN: Thanks, Mona.

00:07:37.480 --> 00:07:42.340
So we've seen that there are
various things that you can do

00:07:42.340 --> 00:07:45.050
to your network by adding extra
redirects, by having a

00:07:45.050 --> 00:07:48.160
high server response time, that
really slow down the user

00:07:48.160 --> 00:07:51.430
perceived latency
of your site.

00:07:51.430 --> 00:07:55.030
What I'm going to talk about now
is actually the way that

00:07:55.030 --> 00:07:56.530
the structure of your page--

00:07:56.530 --> 00:07:59.080
the HTML that you use and how
you organize it-- can actually

00:07:59.080 --> 00:08:02.640
also lead to a huge increase
in user perceived latency.

00:08:02.640 --> 00:08:04.060
And the way that we're going to
do this is we're going to

00:08:04.060 --> 00:08:07.000
look a little bit into the
browser rendering pipeline.

00:08:07.000 --> 00:08:11.180
So what I have here is a
simplified diagram, and you

00:08:11.180 --> 00:08:14.490
can see that to paint anything
to the screen, we both need a

00:08:14.490 --> 00:08:17.250
document object model to be
ready, and the CSS object

00:08:17.250 --> 00:08:18.620
model to be ready.

00:08:18.620 --> 00:08:21.230
And it turns out that both of
these things are going to

00:08:21.230 --> 00:08:24.470
depend heavily on having the
presence of external scripts

00:08:24.470 --> 00:08:26.500
and stylesheets.

00:08:26.500 --> 00:08:29.310
To see how this actually
affects user perceived

00:08:29.310 --> 00:08:33.090
latency, we'll go through
this brief example.

00:08:33.090 --> 00:08:35.830
So here I have a very simple
HTML web page.

00:08:35.830 --> 00:08:38.100
I've grayed out all the text,
because I want to indicate

00:08:38.100 --> 00:08:39.419
that the parser hasn't actually

00:08:39.419 --> 00:08:43.020
gotten to the HTML yet.

00:08:43.020 --> 00:08:45.140
On the right hand side, I have
a representation of what the

00:08:45.140 --> 00:08:46.430
user sees--

00:08:46.430 --> 00:08:47.420
a smartphone--

00:08:47.420 --> 00:08:50.260
and at the bottom of the page,
I have some representation of

00:08:50.260 --> 00:08:52.180
the internal state of
the browser, right?

00:08:52.180 --> 00:08:56.030
So I have the pipeline, and I
also have the various external

00:08:56.030 --> 00:09:00.020
files that the HTML
references.

00:09:00.020 --> 00:09:02.650
So from our perspective, the
first interesting event is

00:09:02.650 --> 00:09:04.880
when we discover example.css.

00:09:04.880 --> 00:09:06.920
So at that point, you can see
the progress bars on the

00:09:06.920 --> 00:09:09.900
bottom are indicating that I've
started parsing the HTML,

00:09:09.900 --> 00:09:12.750
I've started constructing the
DOM, and I've initiated a

00:09:12.750 --> 00:09:14.000
fetch for the CSS.

00:09:16.240 --> 00:09:18.695
The next interesting event from
the perspective of user

00:09:18.695 --> 00:09:20.540
latency is when I encounter
this div--

00:09:20.540 --> 00:09:23.750
this div that presents some
text to the user.

00:09:23.750 --> 00:09:26.800
Now, ideally, at this point in
our rendering pipeline, we'd

00:09:26.800 --> 00:09:28.930
want to show this text to the
user immediately, right?

00:09:28.930 --> 00:09:31.540
Because the user has clicked
on our site, and they're

00:09:31.540 --> 00:09:34.110
waiting, staring at a blank
page and a progress bar.

00:09:34.110 --> 00:09:37.760
But due to the way that this
div depends on the styling

00:09:37.760 --> 00:09:41.100
information inside external.css,
that's going to

00:09:41.100 --> 00:09:43.390
cause the browser to not
know what to do.

00:09:43.390 --> 00:09:45.470
And so it's just going to
continue parsing the file.

00:09:45.470 --> 00:09:47.830
And so this is where you can see
that the latency is going

00:09:47.830 --> 00:09:50.320
to creep in.

00:09:50.320 --> 00:09:55.030
So similarly, as I encounter the
image, as I encounter the

00:09:55.030 --> 00:09:57.430
JavaScript file, I'm also going
to have to initiate

00:09:57.430 --> 00:09:58.030
fetches for them.

00:09:58.030 --> 00:10:00.240
But I still can't show anything,
because the CSS file

00:10:00.240 --> 00:10:02.860
hasn't yet loaded.

00:10:02.860 --> 00:10:06.240
And so it's only finally when
the CSS file is loaded off the

00:10:06.240 --> 00:10:08.490
network and memory that I can
actually pop something up on

00:10:08.490 --> 00:10:09.600
the screen to the user.

00:10:09.600 --> 00:10:11.780
At that point, the user
is finally engaged.

00:10:11.780 --> 00:10:15.690
Up to that point, they're just
staring at a blank screen.

00:10:15.690 --> 00:10:18.140
And so an important thing to
note here is that the DOM can

00:10:18.140 --> 00:10:20.520
be constructed iteratively
as you're

00:10:20.520 --> 00:10:21.850
parsing through the file.

00:10:21.850 --> 00:10:24.480
But the CSS object model is only
constructed once all the

00:10:24.480 --> 00:10:26.390
CSS is in place.

00:10:26.390 --> 00:10:29.510
And this is really the reason
why a lot of webpages feel

00:10:29.510 --> 00:10:32.490
slow on a mobile device, or
really, on any device.

00:10:32.490 --> 00:10:36.060
It's just not as noticeable on a
desktop, due to the way that

00:10:36.060 --> 00:10:37.310
latency works.

00:10:40.660 --> 00:10:42.980
And so as we continue parsing
through the file, we're going

00:10:42.980 --> 00:10:44.630
to finish loading
the JavaScript.

00:10:44.630 --> 00:10:45.740
We're going to finish
loading the image.

00:10:45.740 --> 00:10:49.240
And at that point, the page
is ready, and sort of

00:10:49.240 --> 00:10:50.990
consumed by the user.

00:10:50.990 --> 00:10:52.760
But at that point, they've been
waiting quite some time

00:10:52.760 --> 00:10:55.990
to get this information.

00:10:55.990 --> 00:11:00.690
So to summarize, the issue is
that these external scripts

00:11:00.690 --> 00:11:02.750
and stylesheets are going to
block the painting of content

00:11:02.750 --> 00:11:04.000
in the body, right?

00:11:04.000 --> 00:11:06.670
And we're not saying that
external resources are bad.

00:11:06.670 --> 00:11:09.360
In fact, it's generally a very
reasonable practice on desktop

00:11:09.360 --> 00:11:12.950
to have these resources for
cacheability, and for easy

00:11:12.950 --> 00:11:14.450
composition of HTML.

00:11:14.450 --> 00:11:17.470
But on a mobile device, if you
assume 200 millisecond

00:11:17.470 --> 00:11:20.490
latency, maybe 300 millisecond,
these extra round

00:11:20.490 --> 00:11:22.610
trips to fetch every additional
resource is going

00:11:22.610 --> 00:11:24.020
to be very costly.

00:11:24.020 --> 00:11:26.920
And so what you really want to
do is be able to avoid these

00:11:26.920 --> 00:11:28.940
blocking external scripts
and stylesheets.

00:11:31.690 --> 00:11:34.750
So generally speaking, when you
do this, the way that you

00:11:34.750 --> 00:11:37.730
can get around this is you can
be smart about the CSS.

00:11:37.730 --> 00:11:41.390
You can inline parts of the CSS
that are responsible for

00:11:41.390 --> 00:11:44.890
the above the fold content in
the header of your HTML file.

00:11:44.890 --> 00:11:48.240
And so, then when the browser
is parsing through the file,

00:11:48.240 --> 00:11:50.830
at the point that it encounters
that div, it knows

00:11:50.830 --> 00:11:52.650
how to style it and paint
it to the screen.

00:11:55.320 --> 00:11:57.210
And that's really where this
third rule comes from-- this

00:11:57.210 --> 00:12:00.800
notion of eliminating render
blocking resources.

00:12:00.800 --> 00:12:02.530
Understanding that there's
certain things in the

00:12:02.530 --> 00:12:05.080
rendering pipeline that will
block, because they don't have

00:12:05.080 --> 00:12:07.030
the right information, and
making that information

00:12:07.030 --> 00:12:11.340
available to the browser
at the right moment.

00:12:11.340 --> 00:12:14.080
So let's say that I attended
this talk, and I saw these

00:12:14.080 --> 00:12:16.750
three rules, and I think to
myself, hey, I'm done.

00:12:16.750 --> 00:12:20.100
I can just inline everything,
and everything will be great.

00:12:20.100 --> 00:12:22.050
And I just want to add an
additional caveat, which is

00:12:22.050 --> 00:12:24.840
where this fourth rule comes
into play, which is this

00:12:24.840 --> 00:12:28.580
notion of the additional latency
that comes due to the

00:12:28.580 --> 00:12:30.130
slow start of TCP.

00:12:30.130 --> 00:12:33.880
So in this example, I've
actually inlined all the CSS

00:12:33.880 --> 00:12:34.360
that I have.

00:12:34.360 --> 00:12:36.410
I've put all the styling
information there.

00:12:36.410 --> 00:12:39.320
In fact, I've gone the extra
step where I've added in the

00:12:39.320 --> 00:12:43.980
icons as data image URLs in
the header of the CSS.

00:12:43.980 --> 00:12:47.840
Now, the problem is going
to come up that--

00:12:47.840 --> 00:12:49.200
keep in mind that we want
to reduce these

00:12:49.200 --> 00:12:50.090
round trips, right?

00:12:50.090 --> 00:12:53.370
And so if the initial above the
fold content of your page

00:12:53.370 --> 00:12:57.660
is over 14K over that initial
TCP congestion window, that's

00:12:57.660 --> 00:12:59.990
actually going to incur an
additional round trip.

00:12:59.990 --> 00:13:02.430
And so, you need to be
really careful about

00:13:02.430 --> 00:13:03.540
how you inline something.

00:13:03.540 --> 00:13:06.710
You can't just blindly inline a
file, unless, of course, the

00:13:06.710 --> 00:13:08.320
file is below that cutoff.

00:13:08.320 --> 00:13:11.560
But if a file's above that
cutoff, you're going to need

00:13:11.560 --> 00:13:14.340
to figure out what are the
critical parts of CSS, and

00:13:14.340 --> 00:13:16.710
what are the noncritical
parts of CSS?

00:13:16.710 --> 00:13:19.550
And then you should use delay
loading and asynchronous stuff

00:13:19.550 --> 00:13:21.740
for the parts that are not
necessary for that initial

00:13:21.740 --> 00:13:24.420
user experience to really get
to something in one second.

00:13:28.770 --> 00:13:31.830
And I want to emphasize that
we're not saying that you

00:13:31.830 --> 00:13:35.890
should only make your whole page
fit in 14 kilobytes or 15

00:13:35.890 --> 00:13:38.410
kilobytes, because that is kind
of really stringent, and

00:13:38.410 --> 00:13:40.300
actually fairly difficult
to do.

00:13:40.300 --> 00:13:42.240
You only need to make sure
that the above the fold

00:13:42.240 --> 00:13:43.920
portion of your page fits.

00:13:43.920 --> 00:13:46.590
And actually keep in mind that
with compression, that's

00:13:46.590 --> 00:13:49.110
actually going to cause us
to get a lot more space.

00:13:49.110 --> 00:13:54.470
Maybe up to 45K of text.

00:13:54.470 --> 00:13:56.620
And so that's where this is
final rule comes from-- this

00:13:56.620 --> 00:13:59.200
notion of prioritizing
the visible content.

00:13:59.200 --> 00:14:03.220
So be smart about what you're
inlining, and make sure that

00:14:03.220 --> 00:14:05.780
it fits within this congestion
window so that the user can

00:14:05.780 --> 00:14:07.820
get that content right away.

00:14:07.820 --> 00:14:11.160
So now Brian is going to go into
an example about how you

00:14:11.160 --> 00:14:12.410
apply these rules
to a real site.

00:14:15.210 --> 00:14:16.970
BRYAN MCQUADE: Thanks,
Doantam.

00:14:16.970 --> 00:14:17.780
So I'm Bryan McQuaid.

00:14:17.780 --> 00:14:19.680
I'm the tech lead of
PageSpeed Insights.

00:14:19.680 --> 00:14:22.440
And I'm going to take what we
just learned from Mona and

00:14:22.440 --> 00:14:26.790
Doantam and apply that to an
actual website that we created

00:14:26.790 --> 00:14:29.000
to work through and see how much
faster we can make that

00:14:29.000 --> 00:14:30.970
website load on mobile.

00:14:30.970 --> 00:14:32.700
So we have this demo website,

00:14:32.700 --> 00:14:34.450
demo.modspdy.com, that we put together.

00:14:34.450 --> 00:14:36.205
It's a simple mobile page.

00:14:36.205 --> 00:14:39.810
It sort of has characteristics
of standard mobile websites.

00:14:39.810 --> 00:14:42.650
It redirects to an m.site, it
has a little bit of server

00:14:42.650 --> 00:14:45.310
processing time, it's reasonably
small, and it has

00:14:45.310 --> 00:14:48.590
just one stylesheet in the
head with some data URIs.

00:14:48.590 --> 00:14:50.580
The page looks like
this on the right.

00:14:50.580 --> 00:14:52.050
And it's a simple page, right?

00:14:52.050 --> 00:14:54.240
We would expect a page like
this to load quickly.

00:14:54.240 --> 00:14:56.610
We would hope, anyway, right?

00:14:56.610 --> 00:14:59.610
It turns out--

00:14:59.610 --> 00:15:02.040
and I suppose I should
clarify.

00:15:02.040 --> 00:15:03.650
Modspdy.com was a domain we had

00:15:03.650 --> 00:15:05.060
available to create a demo.

00:15:05.060 --> 00:15:06.430
It has nothing to
do with SPDY.

00:15:06.430 --> 00:15:09.082
It just happened to
be on that domain.

00:15:12.440 --> 00:15:14.710
So now we'll sort of dive in,
and we'll look at this page,

00:15:14.710 --> 00:15:17.520
figure out where the performance
bottlenecks are,

00:15:17.520 --> 00:15:20.500
apply these optimizations one
at a time, and then observe

00:15:20.500 --> 00:15:22.720
the improvement in load time
that we get as result of

00:15:22.720 --> 00:15:23.660
applying those.

00:15:23.660 --> 00:15:26.400
So to start, we have this
unoptimized page here which

00:15:26.400 --> 00:15:27.840
literally just has
three resources.

00:15:27.840 --> 00:15:31.060
We've got demo.modspdy.com,
which redirects to

00:15:31.060 --> 00:15:33.930
m.modspdy.com, which
then loads a

00:15:33.930 --> 00:15:36.410
single static CSS resource.

00:15:36.410 --> 00:15:42.410
And what we see is that
unfortunately, the load of

00:15:42.410 --> 00:15:46.380
these resources is completely
serialized, and we essentially

00:15:46.380 --> 00:15:48.790
incur-- because it's on HTTPS
as well, we've got a fourth

00:15:48.790 --> 00:15:50.491
round trip in there--

00:15:50.491 --> 00:15:53.630
and the end result is that we're
looking at about 6.6

00:15:53.630 --> 00:15:55.710
seconds of latency before we
see anything on the screen,

00:15:55.710 --> 00:15:58.460
even for a simple
page like this.

00:15:58.460 --> 00:16:02.305
So let's go ahead and look
a little further.

00:16:05.380 --> 00:16:08.180
So to start, we've got this
redirect, demo.modspdy.com,

00:16:08.180 --> 00:16:10.970
which redirects to
m.modspdy.com.

00:16:10.970 --> 00:16:12.060
And we know that's costly.

00:16:12.060 --> 00:16:13.360
Mona has showed us.

00:16:13.360 --> 00:16:15.670
In fact, in this particular
environment, we're using web

00:16:15.670 --> 00:16:18.800
page tests' 3G modeling.

00:16:18.800 --> 00:16:20.560
Round trips are actually
300 milliseconds.

00:16:20.560 --> 00:16:23.370
So we've talked about 200 being
a good general target to

00:16:23.370 --> 00:16:26.450
be in between 3G and 4G.

00:16:26.450 --> 00:16:28.130
But for 200 milliseconds,
that is.

00:16:28.130 --> 00:16:30.930
For this particular demo, we're
using a 300 millisecond

00:16:30.930 --> 00:16:32.150
round trip time.

00:16:32.150 --> 00:16:34.720
And on top of that, because it's
on HTTPS, we're looking

00:16:34.720 --> 00:16:36.520
at four round trips.

00:16:36.520 --> 00:16:39.540
So that redirect ends up costing
us, by itself, 4 times

00:16:39.540 --> 00:16:42.470
300, 1.2 seconds.

00:16:42.470 --> 00:16:43.950
So the question becomes,
how do we avoid that?

00:16:43.950 --> 00:16:45.760
How do we avoid that cost?

00:16:45.760 --> 00:16:47.790
There are really two good
ways to approach this.

00:16:47.790 --> 00:16:50.200
At a high level, we have to make
sure that we serve the

00:16:50.200 --> 00:16:53.530
user content at the URL they
request initially, right?

00:16:53.530 --> 00:16:57.050
If we redirect them from
demo.modspdy.com to

00:16:57.050 --> 00:17:01.660
m.modspdy.com, we saw we're
inherently going to experience

00:17:01.660 --> 00:17:03.580
that additional latency.

00:17:03.580 --> 00:17:05.180
So what we have to do is
instead serve the right

00:17:05.180 --> 00:17:08.470
content to the right users
at the URL they request.

00:17:08.470 --> 00:17:09.730
So what that means is
one of two things.

00:17:09.730 --> 00:17:12.500
Either user responsive design,
which allows you to serve the

00:17:12.500 --> 00:17:15.200
same HTML to all your users,
be it mobile users, desktop

00:17:15.200 --> 00:17:18.400
users, and the page will render
differently depending

00:17:18.400 --> 00:17:20.780
on the device characteristics.

00:17:20.780 --> 00:17:22.990
And I should say, that's a
great approach if you're

00:17:22.990 --> 00:17:24.109
building a site from scratch.

00:17:24.109 --> 00:17:25.710
I think that's the
right way to go.

00:17:25.710 --> 00:17:28.730
But if you've got an existing
mobile website and desktop

00:17:28.730 --> 00:17:31.280
website, and you're just trying
to figure out, well,

00:17:31.280 --> 00:17:35.620
how do I move from having this
redirect to not, then what you

00:17:35.620 --> 00:17:39.500
want to do is make sure that you
vary the HTML content that

00:17:39.500 --> 00:17:42.820
you serve to your users based on
the user agent coming in at

00:17:42.820 --> 00:17:43.870
the web server.

00:17:43.870 --> 00:17:46.420
And so if you're getting a
request from a mobile user

00:17:46.420 --> 00:17:50.530
agent, you serve the mobile HTML
directly, and if you get

00:17:50.530 --> 00:17:54.660
a request from a desktop user,
you serve the desktop HTML for

00:17:54.660 --> 00:17:55.910
them as well.

00:17:58.040 --> 00:18:00.000
So it's easy enough to
sort of say, just go

00:18:00.000 --> 00:18:00.990
ahead and do that.

00:18:00.990 --> 00:18:03.690
Let's go ahead and do
a quick example.

00:18:03.690 --> 00:18:06.750
I'm actually on the web server
for modspdy.com now.

00:18:06.750 --> 00:18:11.720
And we can take a look in
the demo directory.

00:18:11.720 --> 00:18:13.330
We've got a couple files.

00:18:13.330 --> 00:18:15.210
This is an Apache web server.

00:18:15.210 --> 00:18:17.530
So I'm going to go ahead and
actually bring up the

00:18:17.530 --> 00:18:21.290
.htaccess file for
demo.modspdy.com,

00:18:21.290 --> 00:18:22.300
and we'll see that--

00:18:22.300 --> 00:18:25.260
so .htaccess file is an Apache
file that lets you specify

00:18:25.260 --> 00:18:29.390
additional information about how
content should be served.

00:18:29.390 --> 00:18:33.980
And what we've done here is we
have this rewrite rule that

00:18:33.980 --> 00:18:37.900
basically says, conditionally
apply the following rule if

00:18:37.900 --> 00:18:40.400
the HTTP user agent matches
either iPhone or Android.

00:18:40.400 --> 00:18:43.210
So basically, a very simple
mobile user agent matcher.

00:18:43.210 --> 00:18:44.920
You could expand on this.

00:18:44.920 --> 00:18:47.660
And then if that matched,
go ahead and

00:18:47.660 --> 00:18:49.600
rewrite the empty URL--

00:18:49.600 --> 00:18:53.150
so that is the URL with just a
slash, essentially-- no URL,

00:18:53.150 --> 00:18:54.240
just the host name--

00:18:54.240 --> 00:18:56.950
to HTTPS://m.modspdy.com.

00:18:56.950 --> 00:18:59.480
So that's the costly one that
we just looked at that

00:18:59.480 --> 00:19:01.770
incurred that 1.2 seconds
of latency.

00:19:01.770 --> 00:19:08.630
So if, instead, we tell Apache
to rewrite that URL to a local

00:19:08.630 --> 00:19:13.730
file, then what we'll get--

00:19:13.730 --> 00:19:15.930
so let me do this, actually.

00:19:15.930 --> 00:19:23.490
Let me go ahead and put
demo.modspdy.com on there, and

00:19:23.490 --> 00:19:26.420
we can see it redirect.

00:19:26.420 --> 00:19:27.815
So that was before.

00:19:27.815 --> 00:19:29.450
And if we just switch those--

00:19:32.450 --> 00:19:33.700
so now I'll go ahead
and do that again.

00:19:38.590 --> 00:19:41.110
And now we can see that the
content that we had been re

00:19:41.110 --> 00:19:44.780
directing users to on m dot is
now served directly from

00:19:44.780 --> 00:19:46.020
demo.modspdy.com.

00:19:46.020 --> 00:19:48.090
And just to sort
of close that--

00:19:48.090 --> 00:19:50.240
so it's a pretty simple thing
to configure, right?

00:19:50.240 --> 00:19:52.430
This is the Apache variant, but
if you use a different web

00:19:52.430 --> 00:19:55.630
server, they all support
this in different ways.

00:19:55.630 --> 00:19:56.840
And then just to look--

00:19:56.840 --> 00:20:01.846
so we're saying, basically,
serve up mobile.php instead.

00:20:01.846 --> 00:20:03.970
Why don't we look at what
that file looks like?

00:20:11.270 --> 00:20:16.420
So that's just a sim link over
to the m.modspdy.com index

00:20:16.420 --> 00:20:16.830
file, right?

00:20:16.830 --> 00:20:17.680
Which is exactly what we were

00:20:17.680 --> 00:20:19.660
redirecting the user to before.

00:20:19.660 --> 00:20:22.670
And so now we're able to
avoid that redirect.

00:20:22.670 --> 00:20:27.690
And let's see the effect
of doing that on

00:20:27.690 --> 00:20:30.770
the page load time.

00:20:30.770 --> 00:20:34.890
So if we think about what we
expect to happen here, we're

00:20:34.890 --> 00:20:37.080
removing, as we talked about,
four round trips--

00:20:37.080 --> 00:20:41.620
DNS, TCP, SSL, and request and
response, each of which cost

00:20:41.620 --> 00:20:44.240
300 millis from the
time to display.

00:20:44.240 --> 00:20:49.440
We were at 6.6 seconds before,
and as a result of removing

00:20:49.440 --> 00:20:52.080
that redirect, indeed, we see
the load time of the page drop

00:20:52.080 --> 00:20:54.460
to 5.4 seconds, which is
exactly what we expect.

00:20:54.460 --> 00:20:58.550
So we've sort of confirmed
through our test environment

00:20:58.550 --> 00:21:03.740
here the result that we
would expect to see.

00:21:03.740 --> 00:21:05.040
And by the way, did
I mention--

00:21:05.040 --> 00:21:06.460
so I don't know, how many
people are familiar

00:21:06.460 --> 00:21:08.950
with Web Page Test?

00:21:08.950 --> 00:21:10.200
OK, so not most.

00:21:10.200 --> 00:21:13.530
So we've used Web Page Test to
both produce these videos and

00:21:13.530 --> 00:21:16.100
the waterfall underneath, which
shows the resources that

00:21:16.100 --> 00:21:18.240
are loaded and the time that
each one is loaded at.

00:21:18.240 --> 00:21:21.110
It's a really great resource,
webpagetest.org.

00:21:21.110 --> 00:21:24.170
You can tell it, show me what
my page looks like over a 3G

00:21:24.170 --> 00:21:27.020
connection from various
locations around the world

00:21:27.020 --> 00:21:30.080
using different kinds of
devices, get these videos,

00:21:30.080 --> 00:21:31.640
look at still frames.

00:21:31.640 --> 00:21:35.080
It's a really rich tool to
understand what the experience

00:21:35.080 --> 00:21:37.660
your users are seeing is.

00:21:37.660 --> 00:21:39.620
And so we've use that to
create these here.

00:21:42.530 --> 00:21:44.420
OK, so let's go ahead and
dive into the next.

00:21:44.420 --> 00:21:45.460
So we've improved
the page, right?

00:21:45.460 --> 00:21:49.390
We've gone from 6.6 seconds to
5.4 seconds, but it's still by

00:21:49.390 --> 00:21:50.350
no means fast.

00:21:50.350 --> 00:21:52.230
So let's go ahead and dive
in and talk about server

00:21:52.230 --> 00:21:53.480
processing time.

00:21:58.520 --> 00:22:00.850
So there's sort of two things
you want to think about when

00:22:00.850 --> 00:22:02.190
you think about server
processing time.

00:22:02.190 --> 00:22:04.160
One is, what is your server
processing time?

00:22:04.160 --> 00:22:04.900
How do you measure that?

00:22:04.900 --> 00:22:08.340
And two, if it's high, why is
it high, and what can you do

00:22:08.340 --> 00:22:09.920
to reduce that?

00:22:09.920 --> 00:22:12.700
And so we can go ahead and take
a look at that actual

00:22:12.700 --> 00:22:14.720
page we have.

00:22:14.720 --> 00:22:18.730
I'll bring up Chrome Dev Tools,
bring up the network

00:22:18.730 --> 00:22:21.550
tab, and then I'm going to
go ahead and reload.

00:22:27.870 --> 00:22:30.640
And so we can see here that
the waiting time, when we

00:22:30.640 --> 00:22:33.050
click on the resource for
demo.modspdy.com and the

00:22:33.050 --> 00:22:34.590
timing, the waiting time--

00:22:34.590 --> 00:22:36.100
I don't know if you can read
that, it's pretty small--

00:22:36.100 --> 00:22:37.420
is 1.6 seconds.

00:22:37.420 --> 00:22:40.860
So we've got 1.6 seconds of time
between the time we sent

00:22:40.860 --> 00:22:42.580
the request and the time
the first bytes of the

00:22:42.580 --> 00:22:43.250
response came back.

00:22:43.250 --> 00:22:44.390
So it's quite high.

00:22:44.390 --> 00:22:46.685
We'd expect to see maybe one
network round trip there, but

00:22:46.685 --> 00:22:48.410
1.6 seconds is way above
that, right?

00:22:48.410 --> 00:22:50.020
And so then the question
becomes, well, why?

00:22:50.020 --> 00:22:50.790
What's going on there?

00:22:50.790 --> 00:22:52.740
Why is it so high?

00:22:52.740 --> 00:22:55.460
And so it's a little bit outside
the scope of the talk

00:22:55.460 --> 00:22:58.830
to sort of figure out and
understand server processing

00:22:58.830 --> 00:23:01.750
time deeply, but at a high
level, what you need to do is

00:23:01.750 --> 00:23:03.240
essentially measure
this server side.

00:23:03.240 --> 00:23:04.630
So what are those times?

00:23:04.630 --> 00:23:07.100
And then, ideally, have some
monitoring infrastructure in

00:23:07.100 --> 00:23:09.730
place that helps you understand
if it's high, where

00:23:09.730 --> 00:23:10.880
that time is going.

00:23:10.880 --> 00:23:13.480
And so one of the tools
we like for this

00:23:13.480 --> 00:23:14.650
is called New Relic.

00:23:14.650 --> 00:23:19.200
They have a free offering that
you can use, and it lets you

00:23:19.200 --> 00:23:21.360
see at a high level where time
is going within your

00:23:21.360 --> 00:23:21.640
application.

00:23:21.640 --> 00:23:23.910
So I'll go ahead and just bring
up the New Relic view

00:23:23.910 --> 00:23:27.930
for this webpage.

00:23:27.930 --> 00:23:29.960
And so this graph in the middle
here is showing us over

00:23:29.960 --> 00:23:33.250
time how long the server took to
generate various responses

00:23:33.250 --> 00:23:35.860
that were requested for
the particular URL

00:23:35.860 --> 00:23:36.810
we're looking at.

00:23:36.810 --> 00:23:40.050
And so we've got a breakdown by
database time and PHP time,

00:23:40.050 --> 00:23:45.010
and so we can see that, by and
large, recently, anyway--

00:23:45.010 --> 00:23:47.510
and so I should say these pits
are just places where there

00:23:47.510 --> 00:23:49.280
were no requests.

00:23:49.280 --> 00:23:50.560
It's a demo page, so
there's not a whole

00:23:50.560 --> 00:23:52.790
lot of activity here.

00:23:52.790 --> 00:23:56.010
But by and large, we're seeing
pretty substantial time spent

00:23:56.010 --> 00:24:00.340
in the database querying, and
a little bit of time in that

00:24:00.340 --> 00:24:03.200
blue, though nonzero
time, right?

00:24:03.200 --> 00:24:07.220
A couple hundred mills in the
PHP execution environment.

00:24:07.220 --> 00:24:08.460
And so then the question
becomes why?

00:24:08.460 --> 00:24:10.480
What are we doing?

00:24:10.480 --> 00:24:13.570
And what can we do to sort
of address those?

00:24:13.570 --> 00:24:19.090
So I'll just look really
quickly at our page.

00:24:19.090 --> 00:24:20.940
And this is just
a simple demo.

00:24:20.940 --> 00:24:23.380
But sure enough, we've
got two things.

00:24:23.380 --> 00:24:26.180
Get data from database, and then
render the HTML with that

00:24:26.180 --> 00:24:28.060
data, right?

00:24:28.060 --> 00:24:31.280
And I've sort of created the
queries in such a way that

00:24:31.280 --> 00:24:33.950
they're intentionally slow for
the purpose of this demo, but

00:24:33.950 --> 00:24:37.890
this is something we see pretty
often is that pages

00:24:37.890 --> 00:24:41.350
will have multiple second for
spike times as a result of

00:24:41.350 --> 00:24:43.890
spending a lot of time either
in the database or executing

00:24:43.890 --> 00:24:46.560
PHP, or possibly some
other reason.

00:24:46.560 --> 00:24:48.570
But in any case, now that we
know that, the question

00:24:48.570 --> 00:24:55.760
becomes what can we do
to reduce this time?

00:24:55.760 --> 00:25:00.330
And our options are really
remove, defer, or optimize.

00:25:00.330 --> 00:25:06.660
And in this case, I observe
the page is generated

00:25:06.660 --> 00:25:09.670
dynamically, but it's really
static content, right?

00:25:09.670 --> 00:25:11.220
And this is a common pattern
you see, too, right?

00:25:11.220 --> 00:25:13.800
You've got a page that's mostly
static or it might

00:25:13.800 --> 00:25:16.260
change periodically, but
fundamentally, it doesn't

00:25:16.260 --> 00:25:18.620
change on every request, but
it's still generated

00:25:18.620 --> 00:25:21.090
dynamically from the database
on every request, and that

00:25:21.090 --> 00:25:24.550
ends up, in some cases, adding
a good bit of latency.

00:25:24.550 --> 00:25:28.120
So in this case, because it's
mostly static, we can simply

00:25:28.120 --> 00:25:30.630
just whenever we update the
database to have a new product

00:25:30.630 --> 00:25:33.230
or whatever it may be, just
render that to HTML, right?

00:25:33.230 --> 00:25:36.020
Dump that to a static HTML file
on the web server, and

00:25:36.020 --> 00:25:37.410
then just serve that instead.

00:25:37.410 --> 00:25:38.660
And so I've done that.

00:25:41.270 --> 00:25:43.820
Or I thought I did that.

00:25:43.820 --> 00:25:45.840
I did do that.

00:25:45.840 --> 00:25:47.330
It's over here.

00:25:47.330 --> 00:25:51.050
And we can see now, we'll
go ahead and reload

00:25:51.050 --> 00:25:54.300
it and take a look--

00:25:54.300 --> 00:25:57.070
that our waiting time has gone
from that 1.6 seconds down to

00:25:57.070 --> 00:26:00.380
84 milliseconds, because we're
not invoking the database and

00:26:00.380 --> 00:26:02.330
running the PHP engine
on every request now.

00:26:02.330 --> 00:26:03.860
We just rendered this to static
content, and we're

00:26:03.860 --> 00:26:05.170
serving that instead.

00:26:05.170 --> 00:26:07.985
And so, in general, as much as
you can precompute ideally all

00:26:07.985 --> 00:26:10.660
of the content, if your pages
doesn't have any dynamic

00:26:10.660 --> 00:26:12.960
pieces-- many pages do have a
little bit that's dynamic, but

00:26:12.960 --> 00:26:15.630
if you can precompute the
majority of it to minimize the

00:26:15.630 --> 00:26:18.960
work in the request path of
the user, you'll create a

00:26:18.960 --> 00:26:21.420
better experience
for your users.

00:26:21.420 --> 00:26:26.550
So that's server processing
time.

00:26:26.550 --> 00:26:28.313
And so now we can see--
that was about 1.5,

00:26:28.313 --> 00:26:29.610
1.6 seconds we saw.

00:26:29.610 --> 00:26:34.070
And indeed, again, we were
at-- what was it?

00:26:34.070 --> 00:26:35.210
5.4 seconds?

00:26:35.210 --> 00:26:36.600
And now we're down
to 3.8 seconds.

00:26:36.600 --> 00:26:40.300
So we've reduced render time,
again, by another 1.6 seconds.

00:26:40.300 --> 00:26:49.620
And you can see that if we go
backwards a little bit, this

00:26:49.620 --> 00:26:52.220
sort of green region right here
in the old version was

00:26:52.220 --> 00:26:52.800
quite long.

00:26:52.800 --> 00:26:54.820
That was that server
processing time.

00:26:54.820 --> 00:27:00.290
And we can see now that that
green region is much shorter.

00:27:00.290 --> 00:27:02.620
And that's where we've pulled
in time, and that's resulted

00:27:02.620 --> 00:27:04.760
in a faster render
on the screen.

00:27:04.760 --> 00:27:06.000
So let's keep going.

00:27:06.000 --> 00:27:08.150
We're doing well, but
we're not to our one

00:27:08.150 --> 00:27:09.050
second target yet.

00:27:09.050 --> 00:27:09.490
And I should--

00:27:09.490 --> 00:27:10.690
I guess a spoiler alert.

00:27:10.690 --> 00:27:12.550
It's physically impossible to
get to one second in this

00:27:12.550 --> 00:27:13.290
configuration.

00:27:13.290 --> 00:27:15.170
So we're not going to get there,
but we're going to get

00:27:15.170 --> 00:27:16.380
as close as we can get.

00:27:16.380 --> 00:27:17.920
We're going to get
quite close.

00:27:17.920 --> 00:27:20.320
So let's see how close
we can get.

00:27:20.320 --> 00:27:24.720
So as Doantam talked about, the
load of our external CSS

00:27:24.720 --> 00:27:27.510
resource blocks rendering
of page content.

00:27:27.510 --> 00:27:30.060
So that actually ends up
incurring seven round trips on

00:27:30.060 --> 00:27:32.520
the network, and at 300
milliseconds, that's a very

00:27:32.520 --> 00:27:34.250
substantial cost.

00:27:34.250 --> 00:27:36.450
So that's the first thing we can
do-- a very simple, very

00:27:36.450 --> 00:27:38.720
easy thing-- is just simply
experiment with inlining all

00:27:38.720 --> 00:27:39.640
that content.

00:27:39.640 --> 00:27:40.810
And people do this
a lot on mobile.

00:27:40.810 --> 00:27:42.150
It's a pretty common
technique, right?

00:27:42.150 --> 00:27:43.740
Just inline, inline, inline.

00:27:43.740 --> 00:27:46.150
As Doantam talked about, there
are some drawbacks to that.

00:27:46.150 --> 00:27:47.460
So we'll start with that.

00:27:47.460 --> 00:27:52.660
We'll start with inlining, and
then we'll iterate from there.

00:27:52.660 --> 00:27:57.906
So if this is our first page,
with the external stylesheet,

00:27:57.906 --> 00:28:03.150
then we can simply, as Doantam
showed, inline all the styles

00:28:03.150 --> 00:28:04.800
and serve it up.

00:28:04.800 --> 00:28:06.790
And so what does this actually
do in terms of load time

00:28:06.790 --> 00:28:08.040
performance?

00:28:10.160 --> 00:28:12.130
And so what we see is we're down
from, I believe it was

00:28:12.130 --> 00:28:15.360
3.6 seconds before, now
down to 2.4 seconds.

00:28:15.360 --> 00:28:18.520
So we've removed 1.2 seconds,
which, interestingly, is the

00:28:18.520 --> 00:28:23.680
four round trips from the DNS,
TCP, SSL and request response

00:28:23.680 --> 00:28:24.970
of that external stylesheet.

00:28:24.970 --> 00:28:26.700
We've essentially eliminated
those.

00:28:26.700 --> 00:28:29.340
We still have the round trips
for fetching the stylesheet,

00:28:29.340 --> 00:28:30.270
though, right?

00:28:30.270 --> 00:28:32.930
They've just moved
to be inline.

00:28:32.930 --> 00:28:34.410
And we're still paying
that cost.

00:28:34.410 --> 00:28:38.890
And worse than that, we've
moved those assets from a

00:28:38.890 --> 00:28:41.670
cacheable resource--
a CSS file--

00:28:41.670 --> 00:28:44.640
into sort of a non-cacheable
HTML payload.

00:28:44.640 --> 00:28:46.800
So repeat visitors to our
site are going to end up

00:28:46.800 --> 00:28:49.350
downloading that content on
every visit, which is pretty

00:28:49.350 --> 00:28:50.930
undesirable, right?

00:28:50.930 --> 00:28:55.090
And so let's see as a final sort
of optimization if we can

00:28:55.090 --> 00:28:56.270
go ahead and address
that issue and

00:28:56.270 --> 00:28:58.390
make the page faster.

00:28:58.390 --> 00:29:01.740
So the only issue we're faced
with now is that we've got

00:29:01.740 --> 00:29:04.900
this large blob of CSS in the
head, and as Doantam talked

00:29:04.900 --> 00:29:08.760
about, that ends up delaying
render of the page due to the

00:29:08.760 --> 00:29:11.750
TCP congestion window growth.

00:29:11.750 --> 00:29:14.820
And so what we want to do is
essentially identify the

00:29:14.820 --> 00:29:15.980
critical CSS--

00:29:15.980 --> 00:29:18.240
that CSS that's needed
to style and position

00:29:18.240 --> 00:29:19.970
content on the page--

00:29:19.970 --> 00:29:22.340
and load that inline
in the head.

00:29:22.340 --> 00:29:24.200
And ideally, that's small.

00:29:24.200 --> 00:29:27.500
And then defer the
non-critical CSS.

00:29:27.500 --> 00:29:30.900
So let's see what that
might look like.

00:29:30.900 --> 00:29:35.980
So if we take note of the fact
that the CSS is largely data

00:29:35.980 --> 00:29:37.260
URIs, right?

00:29:37.260 --> 00:29:38.310
And those data URIs are big.

00:29:38.310 --> 00:29:42.300
They also don't compress very
well, so they end up taking a

00:29:42.300 --> 00:29:46.160
lot of time on the network.

00:29:46.160 --> 00:29:49.020
If we say, well, we'll reserve
this space for those

00:29:49.020 --> 00:29:50.420
images in the HTML--

00:29:50.420 --> 00:29:53.150
we'll carve out that 100 by
100 pixel block, and we'll

00:29:53.150 --> 00:29:55.190
make sure to put that style in
early so things don't move

00:29:55.190 --> 00:29:58.210
around when the stylesheet
loads, but then we'll load the

00:29:58.210 --> 00:30:00.540
remaining content in a deferred
stylesheet in a way

00:30:00.540 --> 00:30:03.390
that doesn't block render,
then we can make the page

00:30:03.390 --> 00:30:06.540
faster and recover a lot of
the caching benefits of

00:30:06.540 --> 00:30:08.460
externalizing that content
in the CSS resource.

00:30:11.880 --> 00:30:17.270
So let's go ahead and take a
look at the effect of that.

00:30:17.270 --> 00:30:21.820
And so here we've achieved an
even more dramatic speedup of

00:30:21.820 --> 00:30:22.700
the first paint time.

00:30:22.700 --> 00:30:24.940
Now we're at 1.5 seconds
to display

00:30:24.940 --> 00:30:26.440
almost all the content.

00:30:26.440 --> 00:30:29.850
You can see that the Chrome
icon comes in a bit later.

00:30:29.850 --> 00:30:32.270
And so it's interesting to
look at the waterfall.

00:30:32.270 --> 00:30:34.910
For the first time, we've
actually moved the paint line

00:30:34.910 --> 00:30:38.320
from the end in, and then we can
see the first paint line

00:30:38.320 --> 00:30:39.880
here-- this green line--

00:30:39.880 --> 00:30:44.420
actually happens, essentially,
before the deferred stylesheet

00:30:44.420 --> 00:30:45.270
has to load.

00:30:45.270 --> 00:30:49.050
So we've basically achieved a
render very shortly after the

00:30:49.050 --> 00:30:51.400
four round trips we incur for
the network cost, which is

00:30:51.400 --> 00:30:53.530
about as good as we can
do on this page.

00:30:53.530 --> 00:30:56.540
And then the remaining deferred
styles come in later,

00:30:56.540 --> 00:30:58.760
and they automatically kind of--
we'll watch it again just

00:30:58.760 --> 00:30:59.330
to see it, right?

00:30:59.330 --> 00:31:00.820
The Chrome icon comes
in a slightly

00:31:00.820 --> 00:31:02.260
later time at the end.

00:31:05.380 --> 00:31:07.250
So one other thing I did just
as a kind of advanced

00:31:07.250 --> 00:31:08.990
optimization--

00:31:08.990 --> 00:31:11.250
if some of the icons on your
page are really high priority,

00:31:11.250 --> 00:31:13.800
you can inline low resolution
previews of those, and that's

00:31:13.800 --> 00:31:15.520
what I've done with the
PageSpeed icon.

00:31:15.520 --> 00:31:17.860
And that causes that content to
show up a little sooner so

00:31:17.860 --> 00:31:21.390
the user can see it, but doesn't
have the cost of

00:31:21.390 --> 00:31:24.010
downloading the full
image asset inline

00:31:24.010 --> 00:31:25.350
in a blocking manner.

00:31:25.350 --> 00:31:29.440
So just real quickly to close,
let's go ahead and look at

00:31:29.440 --> 00:31:30.850
where we were and where
we ended up.

00:31:36.050 --> 00:31:39.180
So we went from a the first ping
time of 6.6 seconds to

00:31:39.180 --> 00:31:42.790
about 1.5 seconds, which is just
about as low as we can

00:31:42.790 --> 00:31:43.080
get, right?

00:31:43.080 --> 00:31:45.583
That's the sort of absolute
minimum is the four round trip

00:31:45.583 --> 00:31:46.620
times of 1.2.

00:31:46.620 --> 00:31:48.410
So we've got a little bit of
browser processing time in

00:31:48.410 --> 00:31:50.120
there, and we've basically
streamlined

00:31:50.120 --> 00:31:51.370
this as much as possible.

00:31:57.050 --> 00:31:58.080
So that's it.

00:31:58.080 --> 00:32:00.580
So at a high level, designing
for high latency means

00:32:00.580 --> 00:32:02.090
following these four
best practices.

00:32:02.090 --> 00:32:04.530
Avoiding landing page redirects,
minimizing server

00:32:04.530 --> 00:32:07.550
processing time, eliminating
render blocking round trips,

00:32:07.550 --> 00:32:10.850
and prioritizing visible
content.

00:32:10.850 --> 00:32:12.100
Any questions?

00:32:21.720 --> 00:32:27.150
AUDIENCE: So, several of the
tricks that you proposed here

00:32:27.150 --> 00:32:33.030
would cause the same URL to
serve both mobile and

00:32:33.030 --> 00:32:35.690
non-mobile content.

00:32:35.690 --> 00:32:37.760
I think that's still
considered a

00:32:37.760 --> 00:32:39.870
no-no by search engines.

00:32:39.870 --> 00:32:41.110
Is that--

00:32:41.110 --> 00:32:42.390
BRYAN MCQUADE: No.

00:32:42.390 --> 00:32:44.690
So I'm not a search expert,
but there's a good bit of

00:32:44.690 --> 00:32:49.030
content on the webmaster site
for Google specifically that

00:32:49.030 --> 00:32:51.760
talks about the different ways
you can address this issue.

00:32:51.760 --> 00:32:55.150
One of them is to have separate
URLs, but we actually

00:32:55.150 --> 00:32:57.370
show how you can support
both responsive design

00:32:57.370 --> 00:32:58.870
and varying the HTML.

00:32:58.870 --> 00:33:03.160
So both those techniques are
supported, at least by Google,

00:33:03.160 --> 00:33:04.440
and really should be by
all search engines.

00:33:04.440 --> 00:33:08.010
If they're not, then--

00:33:08.010 --> 00:33:09.350
Does that--

00:33:09.350 --> 00:33:09.580
AUDIENCE: Yeah.

00:33:09.580 --> 00:33:13.220
I mean, in this specific
example, the site was very

00:33:13.220 --> 00:33:14.610
clearly mobile.

00:33:14.610 --> 00:33:16.710
Like, I wouldn't want to
see that on a browser.

00:33:16.710 --> 00:33:17.270
BRYAN MCQUADE: Oh, I see.

00:33:17.270 --> 00:33:19.300
So what I didn't actually
do there--

00:33:19.300 --> 00:33:21.140
there was a line in my .htaccess
that actually

00:33:21.140 --> 00:33:24.190
allowed it to conditionally
execute that redirect to the

00:33:24.190 --> 00:33:26.110
mobile thing, depending
on the user agent.

00:33:26.110 --> 00:33:27.360
So we would still send--

00:33:27.360 --> 00:33:34.240
I can actually really quickly
just-- right.

00:33:34.240 --> 00:33:35.260
So if I actually enable this--

00:33:35.260 --> 00:33:38.230
I didn't, because it made it
hard to actually use the demo

00:33:38.230 --> 00:33:38.860
on a desktop.

00:33:38.860 --> 00:33:42.390
But now if I re-enable that
rewrite [INAUDIBLE], if you

00:33:42.390 --> 00:33:46.800
now go to demo.modspdy.com,
well--

00:33:49.530 --> 00:33:51.030
I don't have an index.html
now.

00:33:51.030 --> 00:33:51.860
AUDIENCE: Yeah.

00:33:51.860 --> 00:33:54.490
Because it's a back end
redirect, though, if you go to

00:33:54.490 --> 00:33:58.680
that same URL on a mobile
site, you might

00:33:58.680 --> 00:34:00.430
get something different.

00:34:00.430 --> 00:34:03.870
So that's why I kind of--

00:34:03.870 --> 00:34:06.200
I assume that this was not
intended to change the

00:34:06.200 --> 00:34:08.020
recommendation from Google.

00:34:08.020 --> 00:34:10.380
This was just an example.

00:34:10.380 --> 00:34:10.810
BRYAN MCQUADE: So yeah.

00:34:10.810 --> 00:34:12.750
So at a high level,
you should-- and I

00:34:12.750 --> 00:34:13.360
apologize for this.

00:34:13.360 --> 00:34:14.610
I'm not actually sure
what's going on.

00:34:14.610 --> 00:34:16.020
I can debug it in a moment.

00:34:16.020 --> 00:34:19.380
At a high level, it's totally
fine to vary the HTML you send

00:34:19.380 --> 00:34:20.960
as a function of user agent.

00:34:20.960 --> 00:34:22.989
We say you should include the
vary user agent header in the

00:34:22.989 --> 00:34:25.970
response as well to give us a
heads up that it does vary as

00:34:25.970 --> 00:34:29.020
a function of user agent.

00:34:29.020 --> 00:34:29.329
AUDIENCE: Thanks.

00:34:29.329 --> 00:34:30.106
BRYAN MCQUADE: Yep.

00:34:30.106 --> 00:34:31.480
AUDIENCE: I have a question.

00:34:31.480 --> 00:34:33.000
This is kind of a throwback.

00:34:33.000 --> 00:34:37.199
Have you played around with
using progressive images?

00:34:37.199 --> 00:34:39.790
BRYAN MCQUADE: I think that's
another talk in itself.

00:34:39.790 --> 00:34:42.409
So we're looking at that now,
and we're thinking about what

00:34:42.409 --> 00:34:46.005
is optimal there, but it's
definitely a big challenge, I

00:34:46.005 --> 00:34:49.340
think, to do optimally
and efficiently.

00:34:49.340 --> 00:34:51.080
I'd be happy to-- maybe we
can chat afterwards.

00:34:51.080 --> 00:34:53.730
AUDIENCE: OK.

00:34:53.730 --> 00:34:54.800
AUDIENCE: Hi.

00:34:54.800 --> 00:34:57.575
I'm a user of page speed
services, and I

00:34:57.575 --> 00:34:58.920
find this very cool.

00:34:58.920 --> 00:35:03.260
And I have a question about
how to reduce the latency

00:35:03.260 --> 00:35:08.670
about subs request, since we
know that in order for page

00:35:08.670 --> 00:35:13.980
speed service to optimize a
page, it will fetch the page

00:35:13.980 --> 00:35:18.175
first, and then make several
sample requests.

00:35:18.175 --> 00:35:23.310
Could you share a bit about
your consideration about

00:35:23.310 --> 00:35:29.140
deploying processing centers
for page speed services in

00:35:29.140 --> 00:35:32.235
order to make a great
global product?

00:35:32.235 --> 00:35:35.570
BRYAN MCQUADE: So I think Elia,
another person on our

00:35:35.570 --> 00:35:37.510
team, will be giving a talk
about PageSpeed products later

00:35:37.510 --> 00:35:39.900
today, and that might
be a better question

00:35:39.900 --> 00:35:42.010
just to ask to him.

00:35:42.010 --> 00:35:44.030
Or we could maybe
chat afterwards.

00:35:44.030 --> 00:35:44.340
AUDIENCE: OK.

00:35:44.340 --> 00:35:47.140
Thank you.

00:35:47.140 --> 00:35:48.390
BRYAN MCQUADE: Any
other questions?

00:35:50.440 --> 00:35:51.340
OK.

00:35:51.340 --> 00:35:51.940
Thank you.

00:35:51.940 --> 00:35:54.220
Oh, we'll do one more.

00:35:54.220 --> 00:35:55.710
AUDIENCE: OK, so I noticed you
used some JavaScript magic

00:35:55.710 --> 00:35:59.260
there to make the CSS load
in a deferred matter.

00:35:59.260 --> 00:36:02.290
Is there any techniques that are
maybe coming to tell the

00:36:02.290 --> 00:36:06.040
browser in the style tag to
say, defer this later?

00:36:06.040 --> 00:36:07.140
I don't need to do that.

00:36:07.140 --> 00:36:08.430
BRYAN MCQUADE: I wish that
existed, and that's something

00:36:08.430 --> 00:36:09.960
that, I think, is talked
about a little bit.

00:36:09.960 --> 00:36:11.070
I think it's needed.

00:36:11.070 --> 00:36:13.930
Anytime you have to use a little
JavaScript snippet, it

00:36:13.930 --> 00:36:15.980
feels a little wrong, right?

00:36:15.980 --> 00:36:17.940
AUDIENCE: Well, it's really
verbose, and you can't really

00:36:17.940 --> 00:36:19.630
know what's going
on unless you--

00:36:19.630 --> 00:36:20.100
BRYAN MCQUADE: Right, right.

00:36:20.100 --> 00:36:20.430
Yeah.

00:36:20.430 --> 00:36:21.720
So I think that's where
we want to be.

00:36:21.720 --> 00:36:24.730
There's no mechanism to express,
basically, I want to

00:36:24.730 --> 00:36:26.410
load this stylesheet, but don't
have [? a ?] block the

00:36:26.410 --> 00:36:28.420
render today, and so you
have to do it in

00:36:28.420 --> 00:36:29.520
that mechanism currently.

00:36:29.520 --> 00:36:30.976
But I think that's where
we should be moving.

00:36:30.976 --> 00:36:31.670
AUDIENCE: Thank you.

00:36:31.670 --> 00:36:32.920
BRYAN MCQUADE: Yep.

00:36:34.790 --> 00:36:37.290
AUDIENCE: So I had a question
about putting an upstream

00:36:37.290 --> 00:36:40.200
cache in front of these
web servers.

00:36:40.200 --> 00:36:43.770
And your recommendation is to
vary on the user agent, which

00:36:43.770 --> 00:36:45.220
means the cache is basically
made ineffective.

00:36:48.610 --> 00:36:49.530
BRYAN MCQUADE: So that's a
good question, actually.

00:36:49.530 --> 00:36:55.450
I don't know if there was a
video from the webmaster team

00:36:55.450 --> 00:36:58.250
recently about this.

00:36:58.250 --> 00:37:03.410
So we talked to some
of the big CDNs--

00:37:03.410 --> 00:37:04.860
someone at Akamai, for
instance-- and they actually

00:37:04.860 --> 00:37:07.030
walked us through basically how
you would enable this use

00:37:07.030 --> 00:37:08.160
case using their system
specifically.

00:37:08.160 --> 00:37:10.290
I can point you at that if
that would be helpful.

00:37:10.290 --> 00:37:12.530
Basically, it is a solvable
problem that requires a little

00:37:12.530 --> 00:37:15.268
bit of additional configuration
on the CDN side.

00:37:18.450 --> 00:37:19.420
OK.

00:37:19.420 --> 00:37:20.670
Thank you.

