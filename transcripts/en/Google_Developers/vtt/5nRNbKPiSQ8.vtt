WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.910
JEZ FLETCHER: Good afternoon
everyone.

00:00:02.910 --> 00:00:05.150
Welcome to this talk,
which we've entitled

00:00:05.150 --> 00:00:07.230
Maps API Best Practices.

00:00:07.230 --> 00:00:09.110
SUZANNA RUUB: Or How
To Be Awesome.

00:00:09.110 --> 00:00:10.100
JEZ FLETCHER: My name's
Jez Fletcher.

00:00:10.100 --> 00:00:12.090
I'm a software engineer
on the Google Maps

00:00:12.090 --> 00:00:13.540
API based in Sydney.

00:00:13.540 --> 00:00:16.239
SUZANNA RUUB: And I'm Suzanna
Ruub, also a software engineer

00:00:16.239 --> 00:00:19.540
on the Maps API team
in Sydney.

00:00:19.540 --> 00:00:20.480
JEZ FLETCHER: So I want
to give you a brief

00:00:20.480 --> 00:00:21.510
overview of our talk.

00:00:21.510 --> 00:00:24.150
We've broken it up into
three sections.

00:00:24.150 --> 00:00:26.810
The first section we've
entitled Be Smart.

00:00:26.810 --> 00:00:29.620
And this is some general
development tips, some good

00:00:29.620 --> 00:00:33.140
tools that you can use to make
your programming really robust

00:00:33.140 --> 00:00:34.750
with the Maps API.

00:00:34.750 --> 00:00:36.220
SUZANNA RUUB: And the next part,
we're going to talk to

00:00:36.220 --> 00:00:38.950
you about how to be savvy, how
to use some interesting

00:00:38.950 --> 00:00:42.680
features to solve problems
in your application.

00:00:42.680 --> 00:00:44.330
JEZ FLETCHER: And the last
section-- and this is the

00:00:44.330 --> 00:00:46.290
section I'm personally
really excited about.

00:00:46.290 --> 00:00:47.740
Are you excited about
it too, Suzanna?

00:00:47.740 --> 00:00:48.880
SUZANNA RUUB: I'm
very excited.

00:00:48.880 --> 00:00:49.540
JEZ FLETCHER: This
is the section

00:00:49.540 --> 00:00:51.390
we've entitled Be Awesome.

00:00:51.390 --> 00:00:52.910
And this is where we're going
to take you through some

00:00:52.910 --> 00:00:56.830
advanced features of the API
and using some different

00:00:56.830 --> 00:00:59.300
services in concert to create
some really powerful

00:00:59.300 --> 00:01:00.550
applications.

00:01:02.360 --> 00:01:05.530
All right, so let's get
started with Be Smart.

00:01:05.530 --> 00:01:09.300
And we're going to start this
in kind of an odd place

00:01:09.300 --> 00:01:11.880
because we're going to tell
you first when maybe you

00:01:11.880 --> 00:01:13.910
shouldn't be using
the Maps API.

00:01:13.910 --> 00:01:16.670
And that's an odd thing to start
off with in a talk about

00:01:16.670 --> 00:01:18.900
the Maps API.

00:01:18.900 --> 00:01:21.940
So here what I want to do is I
want to add a marker to the

00:01:21.940 --> 00:01:25.780
map showing where my favorite
beer store in Australia is.

00:01:25.780 --> 00:01:27.720
And to do this, I've loaded
up the entire

00:01:27.720 --> 00:01:30.100
JavaScript of the Maps API.

00:01:30.100 --> 00:01:31.410
We've got a pannable map.

00:01:31.410 --> 00:01:32.790
It's got Street View.

00:01:32.790 --> 00:01:36.270
It's a big download, and all I
really wanted to do was to put

00:01:36.270 --> 00:01:38.450
a marker on the map.

00:01:38.450 --> 00:01:40.970
And maybe this is overkill.

00:01:40.970 --> 00:01:43.220
This might be a situation where
the right tool for the

00:01:43.220 --> 00:01:46.360
job is actually the
Static Maps API.

00:01:46.360 --> 00:01:49.510
And you can see here in this
example, we've got just a

00:01:49.510 --> 00:01:52.770
static image of Bridge Road in
Richmond, which is where Slow

00:01:52.770 --> 00:01:55.410
Beer, my favorite
beer store, is.

00:01:55.410 --> 00:01:56.940
And it's just got a
marker on the map.

00:01:56.940 --> 00:02:02.120
And this is really simple
to do in Static Maps.

00:02:02.120 --> 00:02:05.770
And this is just a single URL
that you embed in your web

00:02:05.770 --> 00:02:07.420
page and it returns an image.

00:02:09.949 --> 00:02:11.890
But you might say to me,
well, I'm not just

00:02:11.890 --> 00:02:12.720
going to Slow Beer.

00:02:12.720 --> 00:02:14.120
I want to go on a bit
of a beer crawl.

00:02:14.120 --> 00:02:16.430
I want to go to my favorite
pub that's near there.

00:02:16.430 --> 00:02:19.300
I want to go to the Mountain
Goat Brewery which is nearby.

00:02:19.300 --> 00:02:21.930
And I want to be able to show
my friends the path that you

00:02:21.930 --> 00:02:25.290
can take to walk between
the three.

00:02:25.290 --> 00:02:27.400
And the good news is
the Static Maps API

00:02:27.400 --> 00:02:28.390
allows for this too.

00:02:28.390 --> 00:02:30.460
It actually has a lot of visual
elements that you can

00:02:30.460 --> 00:02:31.520
add to the map.

00:02:31.520 --> 00:02:33.160
So in this case, you can see
that we've got different

00:02:33.160 --> 00:02:36.400
colored markers with different
labels on them.

00:02:36.400 --> 00:02:39.670
And we've got a polyline showing
the path that you can

00:02:39.670 --> 00:02:41.580
take to go to all three
of these great

00:02:41.580 --> 00:02:45.430
beer places in Melbourne.

00:02:45.430 --> 00:02:47.340
So to do this, it's
really simple.

00:02:47.340 --> 00:02:49.910
The key parts here, we've got
the three different markers

00:02:49.910 --> 00:02:52.520
with the different colors and
the different labels.

00:02:52.520 --> 00:02:55.180
And we've got the path,
which sets the route

00:02:55.180 --> 00:02:57.680
we're going to take.

00:02:57.680 --> 00:02:59.560
SUZANNA RUUB: Now Jez and his
friends are wandering around

00:02:59.560 --> 00:03:01.780
Melbourne all carrying
their smart phones.

00:03:01.780 --> 00:03:04.530
And as smart phones are getting
smarter, they also are

00:03:04.530 --> 00:03:06.940
having higher resolution
displays.

00:03:06.940 --> 00:03:10.480
And with this, when an image is
displayed, they upscale it

00:03:10.480 --> 00:03:12.770
in order to fill the device.

00:03:12.770 --> 00:03:17.150
And so the Static Maps API
supports high resolution

00:03:17.150 --> 00:03:18.430
imagery as well.

00:03:18.430 --> 00:03:21.250
You can supply a scale parameter
to get this image,

00:03:21.250 --> 00:03:24.600
which is the same as the one we
saw before, but in higher

00:03:24.600 --> 00:03:25.330
resolution.

00:03:25.330 --> 00:03:28.180
Which means that when the images
are upscaled, we don't

00:03:28.180 --> 00:03:29.950
lose the pixel quality.

00:03:29.950 --> 00:03:31.210
We don't get blurry images.

00:03:31.210 --> 00:03:35.050
They will still be
crisp and clear.

00:03:35.050 --> 00:03:35.340
JEZ FLETCHER: OK.

00:03:35.340 --> 00:03:37.960
But let's say I want Street
View imagery.

00:03:37.960 --> 00:03:40.580
The door of the Mountain Goat
Brewery is in a sort of

00:03:40.580 --> 00:03:43.300
industrial area, and it's just
a roller door, and it doesn't

00:03:43.300 --> 00:03:44.890
really look like a place
you can actually

00:03:44.890 --> 00:03:46.360
go and get a beer.

00:03:46.360 --> 00:03:48.640
So I want to be able to show my
friends well, this is what

00:03:48.640 --> 00:03:49.510
it actually looks like.

00:03:49.510 --> 00:03:51.370
And this is where you want to
go after you've visited the

00:03:51.370 --> 00:03:53.140
Royston Hotel.

00:03:53.140 --> 00:03:56.720
So we have a solution
for this as well.

00:03:56.720 --> 00:03:58.640
And this the Static
Street View, the

00:03:58.640 --> 00:03:59.660
Street View Image API.

00:03:59.660 --> 00:04:03.600
And this gives direct access to
the image data from Street

00:04:03.600 --> 00:04:05.560
View panoramas.

00:04:05.560 --> 00:04:06.760
This is really easy to use.

00:04:06.760 --> 00:04:09.710
It's done in a very similar way
to Static Maps, the key

00:04:09.710 --> 00:04:11.983
differences being that you
request from Street View

00:04:11.983 --> 00:04:13.760
rather than Static Map.

00:04:13.760 --> 00:04:15.550
And you also have to set
the orientation.

00:04:15.550 --> 00:04:18.180
So you can set a location just
like you do for Static Map.

00:04:18.180 --> 00:04:20.089
But you also have the heading,
the pitch, and

00:04:20.089 --> 00:04:21.339
the field of view.

00:04:23.700 --> 00:04:27.970
Now let's say I have some data
on my server about all of the

00:04:27.970 --> 00:04:29.480
breweries in Australia.

00:04:29.480 --> 00:04:31.930
And I want to be able to
dynamically load information

00:04:31.930 --> 00:04:35.770
about a user's top 10 breweries
and plot them on the

00:04:35.770 --> 00:04:37.180
map and do some extra
information.

00:04:37.180 --> 00:04:38.700
So there are my top 10 favorite

00:04:38.700 --> 00:04:41.050
breweries from Australia.

00:04:41.050 --> 00:04:43.470
The naive way of getting this
data dynamically from my

00:04:43.470 --> 00:04:49.280
server is to make a bunch of
individual HTTP requests, one

00:04:49.280 --> 00:04:53.170
for each of the documents
that I want.

00:04:53.170 --> 00:04:55.780
Now this can be something of
a performance hit because

00:04:55.780 --> 00:04:59.900
there's overhead involved in
making each HTTP request.

00:04:59.900 --> 00:05:04.560
And we can see that if we do a
net trace on one that loads a

00:05:04.560 --> 00:05:06.960
whole bunch of small documents,
then we get a net

00:05:06.960 --> 00:05:11.100
race like this, and we can
actually harm our performance.

00:05:11.100 --> 00:05:13.860
So a better way is to have a
handle that can actually

00:05:13.860 --> 00:05:15.170
bundle responses.

00:05:15.170 --> 00:05:16.630
And this is something we're
going to hearken back to a

00:05:16.630 --> 00:05:21.090
number of times in this talk,
how you can make fewer HTTP

00:05:21.090 --> 00:05:23.330
requests to a server.

00:05:23.330 --> 00:05:26.030
So in this case, we've got a
handler on our server which

00:05:26.030 --> 00:05:28.890
can cope with lists of IDs.

00:05:28.890 --> 00:05:31.400
And instead of making one
request, we just concatenate

00:05:31.400 --> 00:05:33.140
all of the IDs that we want.

00:05:33.140 --> 00:05:36.120
The server will bundle those
documents that we want and

00:05:36.120 --> 00:05:38.270
send them back to the client.

00:05:38.270 --> 00:05:41.430
This can have significant
improvement in our

00:05:41.430 --> 00:05:44.460
performance, but there are some
caveats to doing this.

00:05:47.440 --> 00:05:50.960
There are built-in limits to
how long a URL can be.

00:05:50.960 --> 00:05:56.050
So if we just naively start
concatenating IDs onto a long

00:05:56.050 --> 00:05:59.160
request, then we could come
up against this limit.

00:05:59.160 --> 00:06:01.380
We should also keep in mind that
we're going to be getting

00:06:01.380 --> 00:06:03.460
much larger responses back
from the server.

00:06:03.460 --> 00:06:05.980
And so there's going to be some
processing time required

00:06:05.980 --> 00:06:07.920
on the client to
unbundle these.

00:06:07.920 --> 00:06:10.000
And of course, there's the
processing time on the server

00:06:10.000 --> 00:06:12.240
to bundle these up,
rather than just

00:06:12.240 --> 00:06:14.250
blindly serving a file.

00:06:14.250 --> 00:06:16.620
So as for everything, this is
something of a trade off.

00:06:16.620 --> 00:06:20.330
But you generally find that
having fewer HTTP requests is

00:06:20.330 --> 00:06:22.400
a net gain for your
application.

00:06:22.400 --> 00:06:23.670
That's a good rule of thumb.

00:06:23.670 --> 00:06:25.870
SUZANNA RUUB: Another way to
reduce the number of HTTP

00:06:25.870 --> 00:06:29.640
requests that you're making is
with your JavaScript, and to

00:06:29.640 --> 00:06:32.170
take many JavaScript files in
which you're developing your

00:06:32.170 --> 00:06:35.060
different objects and classes
and compile them together

00:06:35.060 --> 00:06:38.470
using the JavaScript
Closure Compiler.

00:06:38.470 --> 00:06:41.290
The Closure Compiler
takes a set of

00:06:41.290 --> 00:06:43.110
JavaScript files as input.

00:06:43.110 --> 00:06:47.610
It then checks them for validity
and outputs more

00:06:47.610 --> 00:06:52.070
JavaScript that is a condensed
form of what the input was.

00:06:52.070 --> 00:06:55.880
It strips white space, comments,
and unused code.

00:06:55.880 --> 00:06:59.200
It can also do semantic and
syntactic error checking

00:06:59.200 --> 00:07:01.610
before your code hits the
browser, where the errors that

00:07:01.610 --> 00:07:05.170
you get may be fairly
hard to decipher.

00:07:05.170 --> 00:07:08.260
It can also provide types
through JS stock type

00:07:08.260 --> 00:07:11.760
annotations to provide for
type checking in what is

00:07:11.760 --> 00:07:15.920
otherwise a dynamically typed
language and can be difficult

00:07:15.920 --> 00:07:20.010
in JavaScript that it's
so dynamic and loose.

00:07:20.010 --> 00:07:23.440
It also optionally obfuscates
or minifies your code by

00:07:23.440 --> 00:07:27.160
turning long variable names
into short ones.

00:07:27.160 --> 00:07:29.690
So let's look at some of the
errors that closure compiler

00:07:29.690 --> 00:07:32.150
can help you with before you hit
the browser and what might

00:07:32.150 --> 00:07:33.510
have happened if you were
in the browser.

00:07:33.510 --> 00:07:33.920
JEZ FLETCHER: Right.

00:07:33.920 --> 00:07:36.280
So I've written this
small application.

00:07:36.280 --> 00:07:37.500
And I ran it in the browser.

00:07:37.500 --> 00:07:38.580
And my app isn't working.

00:07:38.580 --> 00:07:41.170
And I got a really obtuse error

00:07:41.170 --> 00:07:42.690
message from the browser.

00:07:42.690 --> 00:07:46.110
SUZANNA RUUB: So Internet
Explorer has a non-standard

00:07:46.110 --> 00:07:47.860
interpretation of
trailing commas.

00:07:47.860 --> 00:07:50.710
And if you load something, an
object with a trailing comma

00:07:50.710 --> 00:07:55.120
in Internet Explorer, you will
get some random line number

00:07:55.120 --> 00:07:57.650
and some unknown error--

00:07:57.650 --> 00:07:59.910
very hard to solve
this problem.

00:07:59.910 --> 00:08:02.260
But the Closure Compiler will
warn you of this and explain

00:08:02.260 --> 00:08:04.790
to you nicely what's going on
and why it should be avoided.

00:08:04.790 --> 00:08:05.480
JEZ FLETCHER: OK, great.

00:08:05.480 --> 00:08:07.000
So I fixed up my
trailing comma.

00:08:07.000 --> 00:08:08.770
But I'm still getting a whole
bunch of errors, Suzanna.

00:08:08.770 --> 00:08:09.740
Can't you help me?

00:08:09.740 --> 00:08:11.350
SUZANNA RUUB: So the compiler
can also warn

00:08:11.350 --> 00:08:13.300
about undefined variables.

00:08:13.300 --> 00:08:16.290
So here the parameter two
was spelled t-w-o.

00:08:16.290 --> 00:08:18.450
I then used it as t-o-o.

00:08:18.450 --> 00:08:20.150
T-o-o is not defined.

00:08:20.150 --> 00:08:23.200
Closure Compiler warns me of
that, instead of later getting

00:08:23.200 --> 00:08:26.230
just an undefined value
somewhere else down the line,

00:08:26.230 --> 00:08:27.360
which would have happened
if I'd been

00:08:27.360 --> 00:08:29.190
running this in the browser.

00:08:29.190 --> 00:08:33.679
And it warns me that I am using
the this keyword in a

00:08:33.679 --> 00:08:36.299
function that has not been
declared a constructor or is

00:08:36.299 --> 00:08:39.000
not a prototype method.

00:08:39.000 --> 00:08:41.960
So if we fix these up--

00:08:41.960 --> 00:08:42.830
JEZ FLETCHER: So I
fixed these up.

00:08:42.830 --> 00:08:44.670
I've added the constructor
tag.

00:08:44.670 --> 00:08:46.970
I've added some param tags.

00:08:46.970 --> 00:08:48.470
But I'm still getting
errors, Suzanna.

00:08:48.470 --> 00:08:52.010
SUZANNA RUUB: So now it provides
the very helpful

00:08:52.010 --> 00:08:56.030
error that the new keyword is
missing when you call my app.

00:08:56.030 --> 00:08:58.900
You cannot instantiate
an object

00:08:58.900 --> 00:08:59.920
without the new keyword.

00:08:59.920 --> 00:09:02.530
But this is a very common
error that we make.

00:09:02.530 --> 00:09:05.810
And often your app will not
throw any errors at all.

00:09:05.810 --> 00:09:07.440
It just won't work.

00:09:07.440 --> 00:09:09.780
So by running it through the
compiler and being warned that

00:09:09.780 --> 00:09:13.040
we haven't called new my app,
we've just called my app, we

00:09:13.040 --> 00:09:15.090
saved ourselves a lot of time.

00:09:15.090 --> 00:09:18.790
Also, we've declared the
function to have two parameter

00:09:18.790 --> 00:09:21.090
types and only passed in one.

00:09:21.090 --> 00:09:21.260
JEZ FLETCHER: OK.

00:09:21.260 --> 00:09:22.850
So I forgot a parameter.

00:09:22.850 --> 00:09:24.450
That's a mistake that
anyone could do.

00:09:24.450 --> 00:09:25.680
So I'll add the parameter.

00:09:25.680 --> 00:09:27.140
And now we're ready
to go, right?

00:09:27.140 --> 00:09:28.260
JEZ FLETCHER: It's still
the wrong type.

00:09:28.260 --> 00:09:29.510
It was declared as a number.

00:09:29.510 --> 00:09:32.130
So this is how Closure Compiler

00:09:32.130 --> 00:09:33.950
enforces type checking.

00:09:33.950 --> 00:09:35.150
We said it should be a number.

00:09:35.150 --> 00:09:36.650
We passed in a string.

00:09:36.650 --> 00:09:37.230
That's bad.

00:09:37.230 --> 00:09:37.930
It's warned us.

00:09:37.930 --> 00:09:40.110
And again, if this were running
in the browser, we

00:09:40.110 --> 00:09:46.930
would see some sort of b does
not support whatever operation

00:09:46.930 --> 00:09:49.110
we're trying to perform on it,
instead of just letting us

00:09:49.110 --> 00:09:51.800
know where it was exactly that
we passed in the wrong object.

00:09:51.800 --> 00:09:52.180
JEZ FLETCHER: OK.

00:09:52.180 --> 00:09:53.000
So I fixed this up.

00:09:53.000 --> 00:09:55.020
And now finally are
we ready to go?

00:09:55.020 --> 00:09:55.560
SUZANNA RUUB: We are.

00:09:55.560 --> 00:09:58.480
No more errors and it outputs
a minified version of this

00:09:58.480 --> 00:10:03.540
code, stripping all unused
variables and functions.

00:10:03.540 --> 00:10:03.790
JEZ FLETCHER: Great.

00:10:03.790 --> 00:10:05.080
But I want to use
the Maps API.

00:10:05.080 --> 00:10:06.580
That's why I'm here, right?

00:10:06.580 --> 00:10:10.960
So why is this code giving
me so many errors?

00:10:10.960 --> 00:10:12.130
SUZANNA RUUB: So many errors.

00:10:12.130 --> 00:10:13.530
A slew of errors.

00:10:13.530 --> 00:10:14.400
JEZ FLETCHER: A slew
of errors.

00:10:14.400 --> 00:10:17.460
This is really a
slew of errors.

00:10:17.460 --> 00:10:19.760
In fact, next time I'm thinking
of a canonical

00:10:19.760 --> 00:10:21.850
example for a slew of errors,
I'm just going to think of

00:10:21.850 --> 00:10:22.640
this slide right here.

00:10:22.640 --> 00:10:23.850
SUZANNA RUUB: This is
a slew of errors.

00:10:23.850 --> 00:10:28.190
So these errors are all saying
that google.maps objects are

00:10:28.190 --> 00:10:29.530
not defined.

00:10:29.530 --> 00:10:31.800
So you probably can't read
these from where you're

00:10:31.800 --> 00:10:34.720
sitting, that's to make
a point that there

00:10:34.720 --> 00:10:35.310
are a lot of errors.

00:10:35.310 --> 00:10:37.580
JEZ FLETCHER: But believe us
that it's a slew of errors.

00:10:37.580 --> 00:10:40.170
SUZANNA RUUB: So it's all
warnings that the objects of

00:10:40.170 --> 00:10:43.270
the Maps API are not defined.

00:10:43.270 --> 00:10:44.880
So the Closure Compiler
supports

00:10:44.880 --> 00:10:46.320
something called externs.

00:10:46.320 --> 00:10:50.650
And externs is a file containing
symbol definitions

00:10:50.650 --> 00:10:54.810
of things that exist at run
time but you don't have at

00:10:54.810 --> 00:10:56.510
compile time in your own code.

00:10:56.510 --> 00:10:58.720
Things that exist in third
party libraries.

00:10:58.720 --> 00:11:02.120
So the Maps API has an externs
file as do many other

00:11:02.120 --> 00:11:04.410
prominent third party
libraries.

00:11:04.410 --> 00:11:08.220
So when we download the externs
file from the Closure

00:11:08.220 --> 00:11:13.520
Compiler site on Google code and
compile again using those

00:11:13.520 --> 00:11:15.990
externs, we get no errors.

00:11:15.990 --> 00:11:19.450
And we do get this minified
version of our function.

00:11:19.450 --> 00:11:23.940
And you'll note that none of the
Google Maps API properties

00:11:23.940 --> 00:11:24.900
have been obfuscated.

00:11:24.900 --> 00:11:29.810
Those need to be used in their
full symbols in order to be

00:11:29.810 --> 00:11:33.000
recognized by the API.

00:11:33.000 --> 00:11:35.430
You can learn more about
the Closure Compile on

00:11:35.430 --> 00:11:37.350
developers.google.com.

00:11:37.350 --> 00:11:42.080
And there is a web service that
allows you to run your

00:11:42.080 --> 00:11:44.220
code through the compiler right
there in the web page.

00:11:44.220 --> 00:11:46.720
You won't get all of this neat
error checking that I showed,

00:11:46.720 --> 00:11:49.740
so I do recommend downloading
the compiler.jar file and

00:11:49.740 --> 00:11:52.860
running it on your desktop.

00:11:52.860 --> 00:11:53.130
JEZ FLETCHER: OK.

00:11:53.130 --> 00:11:56.000
We're going to talk a little
bit now about testing.

00:11:56.000 --> 00:11:58.960
And this is an important part
of any sort of application

00:11:58.960 --> 00:11:59.840
development.

00:11:59.840 --> 00:12:02.100
But it's something that's often
overlooked in JavaScript

00:12:02.100 --> 00:12:04.140
development for the web.

00:12:04.140 --> 00:12:06.260
And there's no reason this
should be the case because

00:12:06.260 --> 00:12:08.930
there are some great tools out
there for doing testing of

00:12:08.930 --> 00:12:10.350
JavaScript.

00:12:10.350 --> 00:12:13.190
The two main types of testing
that we do in testing our

00:12:13.190 --> 00:12:16.660
JavaScript application, which
is the Maps API, is unit

00:12:16.660 --> 00:12:19.790
testing and automated
integration testing.

00:12:19.790 --> 00:12:23.050
Now unit testing takes a single
component and tests it

00:12:23.050 --> 00:12:24.520
in isolation.

00:12:24.520 --> 00:12:26.020
These tests are usually small.

00:12:26.020 --> 00:12:27.500
They're very focused.

00:12:27.500 --> 00:12:29.680
And they run very quickly.

00:12:29.680 --> 00:12:32.690
The advantage of unit tests
is that they allow you to

00:12:32.690 --> 00:12:36.630
identify really easily what
part of your code is not

00:12:36.630 --> 00:12:38.960
working the way it's
intended to.

00:12:38.960 --> 00:12:41.450
The other good thing about unit
tests is that when you're

00:12:41.450 --> 00:12:45.040
running a unit test alongside
writing the component itself,

00:12:45.040 --> 00:12:47.690
then you're actually the first
user of that component.

00:12:47.690 --> 00:12:50.490
And so it gives you a really
good insight into how this

00:12:50.490 --> 00:12:52.870
component works, how it's going
to interact with other

00:12:52.870 --> 00:12:57.800
things, and the interface that
it actually exposes.

00:12:57.800 --> 00:13:00.970
The other side of this is
integration testing.

00:13:00.970 --> 00:13:03.160
And this is where you test your
entire application from

00:13:03.160 --> 00:13:06.470
end to end in the way that a
user would actually interact

00:13:06.470 --> 00:13:09.350
with your application.

00:13:09.350 --> 00:13:11.300
And this tests the entire
application.

00:13:11.300 --> 00:13:14.250
These tend to be larger tests.

00:13:14.250 --> 00:13:17.510
And they often run directly in
a browser, in this case, for

00:13:17.510 --> 00:13:20.050
JavaScript.

00:13:20.050 --> 00:13:22.220
The other great thing that
integration testing is good

00:13:22.220 --> 00:13:25.810
for is checking for
regression bugs.

00:13:25.810 --> 00:13:30.290
So one of the first things we do
if we get a bug reported in

00:13:30.290 --> 00:13:34.080
the Maps API, the first thing we
do is write an integration

00:13:34.080 --> 00:13:35.650
test for that bug.

00:13:35.650 --> 00:13:38.960
And then we go in, and we fix
the bug itself, and then

00:13:38.960 --> 00:13:40.440
integration test passes.

00:13:40.440 --> 00:13:43.160
And now that we've got the
integration test as part of

00:13:43.160 --> 00:13:46.830
our test suite, it means that we
shouldn't see that bug come

00:13:46.830 --> 00:13:53.600
up again in the same form that
we saw it in that case.

00:13:53.600 --> 00:13:56.270
So the two tools, these are
actually the two tools that we

00:13:56.270 --> 00:14:00.420
use in the Maps API
to test our code.

00:14:00.420 --> 00:14:03.100
And they're both available
as open source libraries.

00:14:03.100 --> 00:14:06.020
The first is Google JS Test, and
that's what we use for all

00:14:06.020 --> 00:14:07.410
of our unit testing.

00:14:07.410 --> 00:14:09.650
And for our integration testing
we use a library

00:14:09.650 --> 00:14:11.860
called Puppeteer.

00:14:11.860 --> 00:14:14.950
And Puppeteer is really good
because it actually runs your

00:14:14.950 --> 00:14:16.240
application in the browser.

00:14:16.240 --> 00:14:19.230
And you can actually watch it
as it's running through the

00:14:19.230 --> 00:14:22.170
interactions it does with
your application.

00:14:22.170 --> 00:14:27.360
And you can also then have a
look at the DOM and interact

00:14:27.360 --> 00:14:28.010
with the page.

00:14:28.010 --> 00:14:30.020
If there's an error, for
example, you can see exactly

00:14:30.020 --> 00:14:33.990
the state that the page was in
when the error occurred.

00:14:33.990 --> 00:14:38.620
And they're both available to
download from code.google.com.

00:14:38.620 --> 00:14:41.520
SUZANNA RUUB: So this brings us
to some features that you

00:14:41.520 --> 00:14:45.620
can use in solving your problems
using the Maps API.

00:14:45.620 --> 00:14:47.840
We're going to take these good
maps you have, and we're going

00:14:47.840 --> 00:14:50.890
to make them great.

00:14:50.890 --> 00:14:55.520
So when Jez drags this marker,
you'll notice that the circle

00:14:55.520 --> 00:14:57.940
follows along with it.

00:14:57.940 --> 00:15:01.250
And just to point out for a
moment, I want to show our

00:15:01.250 --> 00:15:04.760
circle object in the API that is
drawn in geographic space,

00:15:04.760 --> 00:15:06.920
which is why gets bigger as
it goes towards the pole.

00:15:06.920 --> 00:15:08.400
Just kind of a neat
little feature.

00:15:08.400 --> 00:15:12.080
JEZ FLETCHER: Hooray for the
Mercator projection, eh?

00:15:12.080 --> 00:15:15.320
SUZANNA RUUB: So that is
an example of key-value

00:15:15.320 --> 00:15:16.590
observation.

00:15:16.590 --> 00:15:21.260
Key-value observation is when
one object is monitoring a

00:15:21.260 --> 00:15:24.170
property of another object and
updating its own state to

00:15:24.170 --> 00:15:26.140
reflect that.

00:15:26.140 --> 00:15:29.560
So we can implement this marker
and circle following

00:15:29.560 --> 00:15:33.220
each other using an event
listener on the marker, adding

00:15:33.220 --> 00:15:35.900
a listener to listen to changes
to the marker's

00:15:35.900 --> 00:15:39.220
position, and then updating
the circle center to match

00:15:39.220 --> 00:15:41.460
that of the marker.

00:15:41.460 --> 00:15:42.790
This is a one-way binding.

00:15:42.790 --> 00:15:45.890
If the circle changes its
position for whatever reason,

00:15:45.890 --> 00:15:48.440
the marker will not
move with it.

00:15:48.440 --> 00:15:51.620
So we have in the API something
called MVCObject,

00:15:51.620 --> 00:15:54.020
where MVC stands for Model
View Controller.

00:15:54.020 --> 00:15:56.910
But it is more generally an
object to help with key-value

00:15:56.910 --> 00:15:58.180
observation.

00:15:58.180 --> 00:16:02.250
And the MVCObject lets you set
up two-way bindings between

00:16:02.250 --> 00:16:04.310
objects with one call.

00:16:04.310 --> 00:16:08.280
So here, the circle is binding
its center property to the

00:16:08.280 --> 00:16:10.220
marker's position property.

00:16:10.220 --> 00:16:13.590
Any time the marker's position
changes, the circle's center

00:16:13.590 --> 00:16:16.090
will be that value
and vice versa.

00:16:16.090 --> 00:16:18.570
So both the marker and the
circle can be changed, and the

00:16:18.570 --> 00:16:19.890
other will update.

00:16:19.890 --> 00:16:21.610
This is a fairly
simple example.

00:16:21.610 --> 00:16:23.510
But here's something
more complicated.

00:16:23.510 --> 00:16:28.100
Here I built a custom map type
control where the custom

00:16:28.100 --> 00:16:31.080
control actually shows what the
map is going to look like.

00:16:31.080 --> 00:16:34.840
And I've used the Styled
Maps API to do this.

00:16:34.840 --> 00:16:39.710
So when a button is clicked,
it updates the map type ID,

00:16:39.710 --> 00:16:41.340
which is bound to the map.

00:16:41.340 --> 00:16:45.490
So the map and each of the
buttons which are MVCObjects,

00:16:45.490 --> 00:16:48.480
share the property
of map type ID.

00:16:48.480 --> 00:16:50.750
They know nothing about each
other, but they just share

00:16:50.750 --> 00:16:52.390
this one property.

00:16:52.390 --> 00:16:55.620
So when the map's map type ID
changes, each button is

00:16:55.620 --> 00:17:00.810
notified of that and can
update its style to be

00:17:00.810 --> 00:17:03.670
selected or unselected.

00:17:03.670 --> 00:17:07.190
And when a button is clicked, it
can update the map type ID,

00:17:07.190 --> 00:17:10.490
which is then reflected on the
map and in every other button.

00:17:10.490 --> 00:17:12.109
None of the buttons know
about the map.

00:17:12.109 --> 00:17:13.940
And the map doesn't know
about the buttons.

00:17:13.940 --> 00:17:17.250
It just has one bit of wiring
code that hooks up those

00:17:17.250 --> 00:17:20.869
bindings, just like we saw in
the previous example, where

00:17:20.869 --> 00:17:24.472
each button is bound to
the map's map type ID.

00:17:24.472 --> 00:17:29.260
Now one great advantage of this
is that it's much simpler

00:17:29.260 --> 00:17:31.650
to implement than adding a whole
bunch of event listeners

00:17:31.650 --> 00:17:34.020
and passing the map around to
all the buttons and having all

00:17:34.020 --> 00:17:36.280
these complicated class
interactions.

00:17:36.280 --> 00:17:38.760
The other advantage goes back
to the testing that Jez was

00:17:38.760 --> 00:17:40.060
talking about.

00:17:40.060 --> 00:17:43.040
Using key value observation
in this way, and using the

00:17:43.040 --> 00:17:46.540
MVCObject, makes for easier
unit testing since you can

00:17:46.540 --> 00:17:48.760
test the map in isolation,
and you can test

00:17:48.760 --> 00:17:50.410
the button in isolation.

00:17:50.410 --> 00:17:52.990
And the button doesn't need to
know anything about the much

00:17:52.990 --> 00:17:54.790
more complicated map object.

00:17:54.790 --> 00:17:57.560
It only needs to check that when
it's clicked, it sets the

00:17:57.560 --> 00:17:58.620
map type ID.

00:17:58.620 --> 00:18:00.780
And that when the map
type ID changes, its

00:18:00.780 --> 00:18:03.980
styles reflect that.

00:18:03.980 --> 00:18:04.310
JEZ FLETCHER: OK.

00:18:04.310 --> 00:18:06.780
So if you've been to any of the
Maps API talks in the last

00:18:06.780 --> 00:18:08.170
couple of days, you've
probably seen

00:18:08.170 --> 00:18:09.180
this example before.

00:18:09.180 --> 00:18:11.410
But that's because this is
something that we really want

00:18:11.410 --> 00:18:13.290
to drive home hard.

00:18:13.290 --> 00:18:16.220
I put the rhetorical question up
on the slide, who's seen an

00:18:16.220 --> 00:18:17.780
address entry form like this?

00:18:17.780 --> 00:18:20.960
And the answer, of course, is
everybody because every form

00:18:20.960 --> 00:18:23.400
on the web looks like this.

00:18:23.400 --> 00:18:25.310
And we don't think this is a
particularly good way of

00:18:25.310 --> 00:18:28.130
implementing an address
entry form.

00:18:28.130 --> 00:18:32.280
We think this is a lot better,
where we have the autocomplete

00:18:32.280 --> 00:18:36.430
widget which allows us to
dynamically predict what

00:18:36.430 --> 00:18:38.420
address is being entered
and then get structured

00:18:38.420 --> 00:18:40.130
information about this.

00:18:40.130 --> 00:18:43.270
So I'm going to type in the
address of the office of

00:18:43.270 --> 00:18:45.840
Google Australia in Sydney.

00:18:45.840 --> 00:18:47.890
And when we select that,
we get a whole bunch of

00:18:47.890 --> 00:18:50.440
information that we can use
to pre-populate this form.

00:18:50.440 --> 00:18:53.210
So we've got the street number
and the street name.

00:18:53.210 --> 00:18:56.540
We've got all of the information
about the address.

00:18:56.540 --> 00:18:59.850
But we also get for free extra
geographical information, such

00:18:59.850 --> 00:19:02.210
as the latitude and longitude.

00:19:02.210 --> 00:19:05.830
And this is really easy
to implement.

00:19:05.830 --> 00:19:07.920
All that needs to be done is
that you need to include the

00:19:07.920 --> 00:19:11.480
places library when you
load the Maps API.

00:19:11.480 --> 00:19:15.410
And then you can just
instantiate the Google Maps

00:19:15.410 --> 00:19:19.710
places autocomplete and pass it
the input element that you

00:19:19.710 --> 00:19:21.920
want to turn into an
autocomplete widget.

00:19:21.920 --> 00:19:24.380
And then you just listen
to the place change

00:19:24.380 --> 00:19:26.270
event on that widget.

00:19:26.270 --> 00:19:29.610
And then when a user selects a
particular place, you can get

00:19:29.610 --> 00:19:32.520
the structured information
out.

00:19:32.520 --> 00:19:34.620
SUZANNA RUUB: So here we see the
autocomplete widget being

00:19:34.620 --> 00:19:36.370
used in conjunction
with a map.

00:19:36.370 --> 00:19:39.100
Since it gives us that location
data, that lat/long

00:19:39.100 --> 00:19:42.880
for the address entered, we can
enter addresses and then

00:19:42.880 --> 00:19:45.010
easily plot them on the
map with a marker.

00:19:48.230 --> 00:19:52.530
So Jez is going to put in a few
beaches here in Australia.

00:19:52.530 --> 00:19:55.800
And I'd like to take this time
to point out that if Jez

00:19:55.800 --> 00:19:59.100
always wants to show these same
beaches in Australia, or

00:19:59.100 --> 00:20:01.620
he wants to show all the beaches
in Australia, and he's

00:20:01.620 --> 00:20:04.300
not looking for user input, then
the autocomplete widget

00:20:04.300 --> 00:20:05.440
is not the way to go.

00:20:05.440 --> 00:20:07.290
And the Geocoder is
not the way to go,

00:20:07.290 --> 00:20:09.020
the client side Geocoder.

00:20:09.020 --> 00:20:11.940
In the case that you're showing
the same results over

00:20:11.940 --> 00:20:14.880
and over again, you need to
geocode the same objects and

00:20:14.880 --> 00:20:17.740
you have a static set of them,
you should use the geocoding

00:20:17.740 --> 00:20:21.280
web service, where you make a
request that looks like this.

00:20:21.280 --> 00:20:24.260
There are three requests here,
one for each of the beaches.

00:20:24.260 --> 00:20:26.740
And it will output JSON.

00:20:26.740 --> 00:20:29.850
And you should then take the
lat/long that is returned in

00:20:29.850 --> 00:20:36.030
the JSON and cache that in
a spatial data store.

00:20:36.030 --> 00:20:39.840
So switching gears away from
geocoding back to our beaches.

00:20:39.840 --> 00:20:42.620
You can see these are the same
beaches shown on the map, but

00:20:42.620 --> 00:20:44.520
with a slightly more
interesting marker.

00:20:44.520 --> 00:20:47.690
This is the iconic surf life
saving flag in Australia that

00:20:47.690 --> 00:20:50.470
denotes any beach.

00:20:50.470 --> 00:20:56.070
To use these custom images,
we used the custom

00:20:56.070 --> 00:20:57.370
marker image class.

00:20:57.370 --> 00:21:01.110
And the custom marker image
class allows you to sprite

00:21:01.110 --> 00:21:02.070
your images.

00:21:02.070 --> 00:21:05.080
Spriting is taking multiple
images and combining it into

00:21:05.080 --> 00:21:08.040
one file to, again, reduce
the number of HTTP

00:21:08.040 --> 00:21:09.430
requests that we make.

00:21:09.430 --> 00:21:12.520
Any time you're going to load
multiple images to be used in

00:21:12.520 --> 00:21:15.770
conjunction, they should be
loaded as a sprite, as a

00:21:15.770 --> 00:21:16.960
single image.

00:21:16.960 --> 00:21:20.170
So here, I've made a sprite
of the beach flag

00:21:20.170 --> 00:21:22.720
icon and its shadow.

00:21:22.720 --> 00:21:26.700
And to use both parts of this
in the marker, I create two

00:21:26.700 --> 00:21:28.960
marker image objects.

00:21:28.960 --> 00:21:31.090
The first argument to the marker
image object is just

00:21:31.090 --> 00:21:33.180
the URL of this marker.

00:21:33.180 --> 00:21:35.550
For spriting, the key arguments
are the second and

00:21:35.550 --> 00:21:37.270
third parameters.

00:21:37.270 --> 00:21:40.610
The second one is the display
size that you want to show.

00:21:40.610 --> 00:21:44.690
So the flag is 20 by 32 pixels,
and its shadow is 35

00:21:44.690 --> 00:21:46.100
by 32 pixels.

00:21:46.100 --> 00:21:47.660
That's the second parameter.

00:21:47.660 --> 00:21:50.870
The third parameter is the
offset of that part of the

00:21:50.870 --> 00:21:53.640
image within the greater
image sprite.

00:21:53.640 --> 00:21:56.990
So for the flag, it's
up at 0, 0.

00:21:56.990 --> 00:22:02.450
And the shadow is at 39 pixels
to the right of that.

00:22:02.450 --> 00:22:05.930
So those are specified in the
second and third parameters.

00:22:05.930 --> 00:22:08.370
The fourth parameter has nothing
to do with spriting

00:22:08.370 --> 00:22:11.240
but tells the marker where
the image should be

00:22:11.240 --> 00:22:13.510
positioned to have--

00:22:13.510 --> 00:22:15.920
at which point should be
the marker's lat/long.

00:22:15.920 --> 00:22:20.770
So here, you want the bottom
left of the flag to be at the

00:22:20.770 --> 00:22:21.880
marker's lat/long.

00:22:21.880 --> 00:22:25.960
So you specify the zero and then
the left hand corner of

00:22:25.960 --> 00:22:29.010
that, which is 32 pixels
for the anchor.

00:22:29.010 --> 00:22:30.670
That's the fourth parameter.

00:22:30.670 --> 00:22:33.180
Now the marker image
class also allows

00:22:33.180 --> 00:22:34.880
for scaling of this.

00:22:34.880 --> 00:22:38.440
So we can show this same icon
at three different sizes

00:22:38.440 --> 00:22:42.010
without loading extra images.

00:22:42.010 --> 00:22:45.790
To scale the icons, we add
a fifth parameter.

00:22:45.790 --> 00:22:50.050
And the fifth parameter is the
entire size of the image, so

00:22:50.050 --> 00:22:52.990
if it's a sprite, not just the
part you want to show, but the

00:22:52.990 --> 00:22:56.350
entire size, after scaling.

00:22:56.350 --> 00:23:00.520
So if the image was originally
57 by 34 pixels, we multiply

00:23:00.520 --> 00:23:01.470
that by two.

00:23:01.470 --> 00:23:04.150
And we need to specify
that in the fifth

00:23:04.150 --> 00:23:05.710
parameter to marker image.

00:23:05.710 --> 00:23:08.850
You also have to multiply the
display size, the offset, and

00:23:08.850 --> 00:23:09.860
the anchor by two.

00:23:09.860 --> 00:23:13.140
But the key part is adding
that scaled size.

00:23:13.140 --> 00:23:14.970
And the scaled size is not
required if you're

00:23:14.970 --> 00:23:17.830
not scaling the image.

00:23:17.830 --> 00:23:20.320
JEZ FLETCHER: Another new cool
feature for doing custom

00:23:20.320 --> 00:23:22.080
markers that was only
launched at I/O

00:23:22.080 --> 00:23:24.460
yesterday is Marker Symbols.

00:23:24.460 --> 00:23:28.420
And this allows you to draw
markers dynamically using any

00:23:28.420 --> 00:23:32.430
SVG path and have them be more
interactive and more

00:23:32.430 --> 00:23:36.390
responsive that you can with
a standard marker image.

00:23:36.390 --> 00:23:38.440
There was a great talk yesterday
on this called

00:23:38.440 --> 00:23:43.050
Advanced Maps Visualization, and
I encourage you to check

00:23:43.050 --> 00:23:45.110
it out on YouTube.

00:23:45.110 --> 00:23:48.030
SUZANNA RUUB: So when one image
or one symbol is not

00:23:48.030 --> 00:23:51.270
sufficient for showing your
markers, you need to use a

00:23:51.270 --> 00:23:52.015
custom overlay.

00:23:52.015 --> 00:23:55.100
And a custom overlay lets you
create the DOM structure

00:23:55.100 --> 00:23:56.750
yourself and combine elements.

00:23:56.750 --> 00:23:58.940
So here I've created some
markers for countries that

00:23:58.940 --> 00:24:04.040
combine a flag image and a
label, as well as some shadows

00:24:04.040 --> 00:24:06.670
and some pretty CSS.

00:24:06.670 --> 00:24:11.190
So to do this, I inherit from
the OverlayView class.

00:24:11.190 --> 00:24:13.450
And then I implement
three methods.

00:24:13.450 --> 00:24:16.510
I need to implement onadd, which
creates DOM elements and

00:24:16.510 --> 00:24:19.230
adds them to the Maps panes.

00:24:19.230 --> 00:24:23.450
I then implement the
draw method to

00:24:23.450 --> 00:24:26.510
position that overlay.

00:24:26.510 --> 00:24:30.070
So I convert the lat/long into
map pixel coordinates using

00:24:30.070 --> 00:24:31.630
helper functions provided.

00:24:31.630 --> 00:24:34.900
And this function will be
recalled every time we need to

00:24:34.900 --> 00:24:37.010
reposition the overlay.

00:24:37.010 --> 00:24:39.400
And then the third is just
onremove, where you clean up

00:24:39.400 --> 00:24:42.980
everything you did in onadd.

00:24:42.980 --> 00:24:43.190
JEZ FLETCHER: OK.

00:24:43.190 --> 00:24:45.810
The next thing I wanted to do
is I wanted to show you some

00:24:45.810 --> 00:24:48.590
of the beautiful sights of
my hometown of Sydney.

00:24:48.590 --> 00:24:50.950
And I thought, well, the best
way of doing this, obviously,

00:24:50.950 --> 00:24:53.040
is to use a Street
View panorama.

00:24:53.040 --> 00:24:55.760
And so I picked a location in
Sydney that has one of the

00:24:55.760 --> 00:24:58.410
best views of Sydney that
I think we have.

00:24:58.410 --> 00:25:01.390
And here it is.

00:25:01.390 --> 00:25:03.120
Except, that's not it, is it?

00:25:03.120 --> 00:25:05.390
That's the side of the
street somewhere.

00:25:05.390 --> 00:25:08.110
And probably what I actually
wanted to show you was around

00:25:08.110 --> 00:25:11.860
in this direction where we
have the beautiful Sydney

00:25:11.860 --> 00:25:13.890
Harbour Bridge, the Sydney
Opera House, and looking

00:25:13.890 --> 00:25:17.550
towards the central business
district across the harbor.

00:25:17.550 --> 00:25:19.540
Now the problem with what we've
done here is we've just

00:25:19.540 --> 00:25:21.540
naively set the location,
but we haven't set the

00:25:21.540 --> 00:25:25.720
orientation, the heading of
this street view panorama.

00:25:25.720 --> 00:25:27.970
So you can see, when you create
a panorama object, you

00:25:27.970 --> 00:25:29.630
pass in panoramaOptions.

00:25:29.630 --> 00:25:32.110
So we set the position to be
Sydney Harbour, but we haven't

00:25:32.110 --> 00:25:35.130
set the orientation.

00:25:35.130 --> 00:25:38.920
So we can improve this by
hard-coding an orientation.

00:25:38.920 --> 00:25:41.130
So in this case, we've said, OK,
we want to be looking at

00:25:41.130 --> 00:25:44.690
190 degrees because that's the
direction of the CBD from

00:25:44.690 --> 00:25:49.710
Kirribilli, where this
panorama is located.

00:25:49.710 --> 00:25:52.510
So you can see we've added our
point of view object to our

00:25:52.510 --> 00:25:55.290
panorama options, and it takes
our heading that we've

00:25:55.290 --> 00:25:57.350
hard-coded.

00:25:57.350 --> 00:26:00.030
Now this still isn't a really
great solution because it's

00:26:00.030 --> 00:26:01.090
not very dynamic.

00:26:01.090 --> 00:26:04.090
And if you need to do this for a
large number of things, then

00:26:04.090 --> 00:26:06.850
you're going to have to manually
hard-code each of the

00:26:06.850 --> 00:26:08.680
headings that you want.

00:26:08.680 --> 00:26:11.010
A better way to do this is
to calculate the heading

00:26:11.010 --> 00:26:11.990
automatically.

00:26:11.990 --> 00:26:15.590
And so you can see here we've
got two boxes where you can

00:26:15.590 --> 00:26:17.650
set your location and what
you want to look at.

00:26:17.650 --> 00:26:19.670
And of course these are
autocomplete widgets because

00:26:19.670 --> 00:26:22.120
we're entering an address on
the web, and any time we're

00:26:22.120 --> 00:26:23.730
entering an address on the web,
we should be using an

00:26:23.730 --> 00:26:25.240
autocomplete widget.

00:26:25.240 --> 00:26:27.560
So we set the origin to be the
corner of these two streets in

00:26:27.560 --> 00:26:28.860
Kirribilli, and we want
to be looking

00:26:28.860 --> 00:26:31.560
towards Sydney, the city.

00:26:31.560 --> 00:26:34.430
But the advantage of this is
that it's now dynamic.

00:26:34.430 --> 00:26:38.220
So if instead we want to look at
Old Mason Street, which is

00:26:38.220 --> 00:26:42.740
on the edge of the bay here in
San Francisco, and we want to

00:26:42.740 --> 00:26:45.310
be looking at another beautiful
bridge, the Golden

00:26:45.310 --> 00:26:47.700
Gate Bridge, then
we can do that.

00:26:47.700 --> 00:26:49.230
And we've not had to
calculate anything.

00:26:49.230 --> 00:26:52.100
This is all done automatically
for us.

00:26:52.100 --> 00:26:54.970
And the way we've done that
is by using the spherical

00:26:54.970 --> 00:27:00.430
geometry library, which you can
get with the Maps API by

00:27:00.430 --> 00:27:02.660
passing a parameter at load
time, just like you can for

00:27:02.660 --> 00:27:05.180
the Places API.

00:27:05.180 --> 00:27:10.220
And it has a compute heading
option, which we use here

00:27:10.220 --> 00:27:12.700
giving it the origin and
the destination.

00:27:12.700 --> 00:27:16.080
And we pass that into our
point of view object.

00:27:16.080 --> 00:27:20.370
Now let's say that instead of
looking at something specific,

00:27:20.370 --> 00:27:22.550
we just want to be looking
down a road.

00:27:22.550 --> 00:27:25.620
And we don't care particularly
what we're looking at, but we

00:27:25.620 --> 00:27:26.920
want to be looking down
the road that

00:27:26.920 --> 00:27:28.570
we're traveling down.

00:27:28.570 --> 00:27:31.030
Now the good thing about the
panorama is that it has a lot

00:27:31.030 --> 00:27:33.800
of information about the
panorama surrounding it.

00:27:33.800 --> 00:27:38.830
So each panorama object has a
list of links that links to

00:27:38.830 --> 00:27:41.950
other panoramas from the
current panorama.

00:27:41.950 --> 00:27:44.270
And so we've set our location
here to be Times

00:27:44.270 --> 00:27:45.600
Square in New York.

00:27:45.600 --> 00:27:47.040
And we've said that we
want to be looking

00:27:47.040 --> 00:27:48.940
approximately 180 degrees.

00:27:48.940 --> 00:27:51.230
And what this demo is doing is
looking through all the links

00:27:51.230 --> 00:27:54.540
from the panorama and finding
the heading which is closest

00:27:54.540 --> 00:27:57.120
to our target.

00:27:57.120 --> 00:28:01.570
So if we wanted to be looking
north instead, it says, well

00:28:01.570 --> 00:28:03.560
the closest heading
is 28 degrees.

00:28:03.560 --> 00:28:04.590
And there's a link
off that way.

00:28:04.590 --> 00:28:08.530
So we know that we're looking
down the street.

00:28:08.530 --> 00:28:13.430
So this is also really simple
to do but quite powerful.

00:28:13.430 --> 00:28:15.790
You just have to listen to
the links changed event.

00:28:15.790 --> 00:28:19.360
And this will get called any
time a new panorama is loaded.

00:28:19.360 --> 00:28:21.920
And once that's loaded, we can
get information about the

00:28:21.920 --> 00:28:25.060
links, look through each of
those links for the one that's

00:28:25.060 --> 00:28:26.960
closest to our target,
and set the

00:28:26.960 --> 00:28:28.510
panorama to be that heading.

00:28:32.330 --> 00:28:34.300
SUZANNA RUUB: And now it's time
to show you how to put a

00:28:34.300 --> 00:28:38.160
number of these features all
together, or to be awesome.

00:28:38.160 --> 00:28:39.400
JEZ FLETCHER: I'm excited
about this section.

00:28:39.400 --> 00:28:40.290
Are you excited?

00:28:40.290 --> 00:28:42.130
SUZANNA RUUB: I am.

00:28:42.130 --> 00:28:45.700
So we've got some help from a
few of our teammates today to

00:28:45.700 --> 00:28:49.392
help explain the situations that
we needed to solve and to

00:28:49.392 --> 00:28:49.500
build these apps.

00:28:49.500 --> 00:28:51.300
JEZ FLETCHER: They've got some
problems, and we thought we

00:28:51.300 --> 00:28:53.160
could put the Maps
API into action

00:28:53.160 --> 00:28:55.180
to solve these problems.

00:28:55.180 --> 00:28:57.010
SUZANNA RUUB: So first we have
our co-worker James.

00:28:57.010 --> 00:29:00.230
And he's been kind enough
to join us today.

00:29:00.230 --> 00:29:03.140
He has an unusual fear of aliens
and always wears a

00:29:03.140 --> 00:29:05.720
tin-foil hat, as you can see.

00:29:05.720 --> 00:29:08.570
But sometimes I'm feeling mean,
and I walk around the

00:29:08.570 --> 00:29:10.590
office, and I take off
his tin foil hat.

00:29:10.590 --> 00:29:12.490
And he gets pretty upset.

00:29:12.490 --> 00:29:13.050
JEZ FLETCHER: It's
really cruel.

00:29:13.050 --> 00:29:14.720
We've tried to put a stop
to it, but Suzanna,

00:29:14.720 --> 00:29:16.970
she can't be helped.

00:29:16.970 --> 00:29:18.000
SUZANNA RUUB: Can't help it.

00:29:18.000 --> 00:29:23.200
So he thought, well, since I'm
always taking off his hat,

00:29:23.200 --> 00:29:26.470
he's going to cover the
roof in tin foil.

00:29:26.470 --> 00:29:28.410
And he thought there's probably
other people who have

00:29:28.410 --> 00:29:31.180
the same problem where they need
to cover their roofs in

00:29:31.180 --> 00:29:31.630
tin foil too.

00:29:31.630 --> 00:29:34.120
So he's starting a little
side business for it.

00:29:34.120 --> 00:29:35.200
And I felt bad about the hat.

00:29:35.200 --> 00:29:37.380
So I built him this application
to help him

00:29:37.380 --> 00:29:41.400
estimate the amount of materials
he will need to

00:29:41.400 --> 00:29:44.030
cover his customer's roofs.

00:29:44.030 --> 00:29:47.060
So I started by giving
him an input field to

00:29:47.060 --> 00:29:48.550
put the address in.

00:29:48.550 --> 00:29:52.220
And I'm using the autocomplete
widget to do that.

00:29:52.220 --> 00:29:54.810
And then we go to
that location.

00:29:54.810 --> 00:29:57.120
And you'll note there is no zoom
control on the map, and

00:29:57.120 --> 00:30:00.370
that Jez did not need to zoom
in or out to get to this

00:30:00.370 --> 00:30:04.110
beautiful picture of our roof
in the Sydney office.

00:30:04.110 --> 00:30:09.160
I used the Map Zoom Service to
find the best zoom level, or

00:30:09.160 --> 00:30:11.230
the zoom level with
the best satellite

00:30:11.230 --> 00:30:13.330
imagery at that location.

00:30:13.330 --> 00:30:17.590
So I zoom directly to that spot
and then put the drawing

00:30:17.590 --> 00:30:21.900
control from the drawing library
on the map, allowing

00:30:21.900 --> 00:30:26.280
Jez, or James later, to outline
the roof and draw a

00:30:26.280 --> 00:30:29.100
polygon over that roof.

00:30:29.100 --> 00:30:31.690
Then with the path of that
polygon, I can use the

00:30:31.690 --> 00:30:35.110
geometry library to compute
the area and compute the

00:30:35.110 --> 00:30:37.530
perimeter because he's also
going to do some gutters while

00:30:37.530 --> 00:30:40.290
he's up there doing roof work.

00:30:40.290 --> 00:30:43.840
So with the places.Autocomplete,
I gave

00:30:43.840 --> 00:30:47.400
James a tool to find an
address, then used the

00:30:47.400 --> 00:30:53.400
MapZoomService to zoom the map
to the most appropriate level

00:30:53.400 --> 00:30:58.970
to show the best imagery, then
added the DrawingManager to

00:30:58.970 --> 00:31:01.990
allow him to draw polygons
on the map, and used the

00:31:01.990 --> 00:31:04.600
geometric library's computearea
and computelength

00:31:04.600 --> 00:31:07.830
functions to measure the
area and length.

00:31:07.830 --> 00:31:09.050
I had to do no math.

00:31:09.050 --> 00:31:11.430
I had to set up no
click handlers.

00:31:11.430 --> 00:31:13.860
It was a very simple application
to write using the

00:31:13.860 --> 00:31:16.106
tools of the Maps API.

00:31:16.106 --> 00:31:16.560
JEZ FLETCHER: OK.

00:31:16.560 --> 00:31:20.000
So the next co-worker that
needs some help is Chris.

00:31:20.000 --> 00:31:21.550
And Chris is a bit
of a hipster.

00:31:21.550 --> 00:31:24.140
Actually he's a lot of a
hipster, isn't he Suzanna?

00:31:24.140 --> 00:31:25.120
He's a lot of a hipster.

00:31:25.120 --> 00:31:27.960
And he's just bought a brand
new fixie, only it doesn't

00:31:27.960 --> 00:31:29.390
have any breaks yet.

00:31:29.390 --> 00:31:32.690
And the problem is that he wants
to know if on his daily

00:31:32.690 --> 00:31:35.570
commute there's going to be any
really steep hills that

00:31:35.570 --> 00:31:37.460
are going to cause
him problems.

00:31:37.460 --> 00:31:40.270
Because he doesn't have brakes,
he's likely to careen

00:31:40.270 --> 00:31:42.620
off the road and break
his Ray-Bans or

00:31:42.620 --> 00:31:45.640
something like that.

00:31:45.640 --> 00:31:48.300
So we built him this app here.

00:31:48.300 --> 00:31:51.460
This allows him to enter
the two places that

00:31:51.460 --> 00:31:53.790
he wants to go between.

00:31:53.790 --> 00:31:57.340
Of course, they use the
autocomplete widget.

00:31:57.340 --> 00:31:59.770
And then give him directions
along that path.

00:31:59.770 --> 00:32:01.890
And once we've got the path that
the directions are going

00:32:01.890 --> 00:32:05.970
to take, we can then use the
elevation service to get the

00:32:05.970 --> 00:32:08.500
elevation data for that route.

00:32:08.500 --> 00:32:09.550
And we've plotted this here.

00:32:09.550 --> 00:32:12.620
So we can see that he goes up
a hill for awhile, but then

00:32:12.620 --> 00:32:16.780
it's a pretty gentle trip all
the way down the hill for the

00:32:16.780 --> 00:32:18.260
hipster in his hipster
glasses.

00:32:21.450 --> 00:32:24.530
So this also leveraged
a number of services

00:32:24.530 --> 00:32:25.750
through the Maps API.

00:32:25.750 --> 00:32:28.510
So it uses the autocomplete
widget, of course.

00:32:28.510 --> 00:32:31.190
It uses the DirectionsService to
get the route and then the

00:32:31.190 --> 00:32:33.960
DirectionsRenderer to show
that route on the map.

00:32:33.960 --> 00:32:36.310
It also uses the
ElevationService to get the

00:32:36.310 --> 00:32:38.650
elevation along the path
we get back from the

00:32:38.650 --> 00:32:40.720
DirectionService.

00:32:40.720 --> 00:32:43.520
And of course we also use a
custom image to show the

00:32:43.520 --> 00:32:44.810
glasses so you can
tell that it's a

00:32:44.810 --> 00:32:47.350
hipster who's doing this.

00:32:47.350 --> 00:32:49.020
SUZANNA RUUB: And then our
last co-worker who had a

00:32:49.020 --> 00:32:52.240
problem, Dave needed to do
some home improvements.

00:32:52.240 --> 00:32:53.030
JEZ FLETCHER: He really did.

00:32:53.030 --> 00:32:55.300
I've been to his house recently,
and boy, does it

00:32:55.300 --> 00:32:56.840
need some home improvement.

00:32:56.840 --> 00:32:59.490
SUZANNA RUUB: So he thought on
the way home from work one day

00:32:59.490 --> 00:33:01.030
he would stop by Bunnings.

00:33:01.030 --> 00:33:05.020
Bunnings is Australia's home
improvement warehouse store.

00:33:05.020 --> 00:33:08.190
The thing is, in Sydney, there
are a bunch of Bunnings, and

00:33:08.190 --> 00:33:10.790
Dave didn't know which
one to visit.

00:33:10.790 --> 00:33:14.890
So we whipped up this
app for him.

00:33:14.890 --> 00:33:20.370
Let's see work and his home
out in Balcombe Hills.

00:33:20.370 --> 00:33:25.100
And then I use the Place service
to search for all of

00:33:25.100 --> 00:33:27.850
the Bunnings that are
in this view port.

00:33:27.850 --> 00:33:28.980
So these are all the Bunnings.

00:33:28.980 --> 00:33:30.820
And you can see there are a
lot to choose from and a

00:33:30.820 --> 00:33:32.340
number of them that look
like they might

00:33:32.340 --> 00:33:34.310
be reasonable options.

00:33:34.310 --> 00:33:38.030
Now to find the best path, I
could have made a separate

00:33:38.030 --> 00:33:41.910
directions service request for
every single Bunnings to find

00:33:41.910 --> 00:33:44.800
the distance and duration
it would take

00:33:44.800 --> 00:33:47.170
to travel that route.

00:33:47.170 --> 00:33:48.790
That's very expensive.

00:33:48.790 --> 00:33:51.060
It's bad for the user.

00:33:51.060 --> 00:33:51.980
It would take too long.

00:33:51.980 --> 00:33:52.880
It's too much data.

00:33:52.880 --> 00:33:56.305
Each directions result
is quite large.

00:33:56.305 --> 00:33:58.800
It's not an efficient way
to solve this problem.

00:33:58.800 --> 00:34:01.120
But there is the distance
matrix service.

00:34:01.120 --> 00:34:05.130
And the distance matrix service
takes a set of origins

00:34:05.130 --> 00:34:08.610
and a set of destinations and
computes the distance and

00:34:08.610 --> 00:34:12.250
duration between each origin
and each destination.

00:34:12.250 --> 00:34:17.500
So I set the work and home as
the origins and each of the

00:34:17.500 --> 00:34:19.980
Bunnings as the destinations.

00:34:19.980 --> 00:34:23.739
Then I computed, using the
result of that, which of these

00:34:23.739 --> 00:34:26.940
Bunnings resulted in the
shortest trip between work and

00:34:26.940 --> 00:34:29.500
Bunnings and that Bunnings
and home.

00:34:29.500 --> 00:34:33.270
Then I fired off that
single request to

00:34:33.270 --> 00:34:34.850
the directions service.

00:34:34.850 --> 00:34:38.090
And I got back the full driving
directions to plot on

00:34:38.090 --> 00:34:40.840
the map and in the panel.

00:34:40.840 --> 00:34:43.409
Now both the directions service
and the distance

00:34:43.409 --> 00:34:47.250
matrix service provide a number
of options for routing.

00:34:47.250 --> 00:34:52.330
So the initial result told
us that the Bunnings near

00:34:52.330 --> 00:34:54.160
Chatswood is probably
the best--

00:34:54.160 --> 00:34:56.725
or Crows Nest, Chatswood.

00:34:56.725 --> 00:34:58.110
JEZ FLETCHER: It's actually
in Artarmon.

00:34:58.110 --> 00:34:58.960
I looked it up.

00:34:58.960 --> 00:35:00.230
SUZANNA RUUB: It's
in Artarmon.

00:35:00.230 --> 00:35:01.480
I can't even say that.

00:35:03.910 --> 00:35:08.530
So that's the best route given
that he just wants to drive.

00:35:08.530 --> 00:35:11.340
But if you know anything about
Sydney, this route has a bunch

00:35:11.340 --> 00:35:13.900
of toll roads on it, and it
would be a very expensive trip

00:35:13.900 --> 00:35:15.540
for Dave to get home.

00:35:15.540 --> 00:35:19.820
So we can send to both the
distance matrix and directions

00:35:19.820 --> 00:35:24.170
service the request
to avoid tolls.

00:35:24.170 --> 00:35:27.600
So avoiding tolls takes him
to a North Rocks Bunnings.

00:35:27.600 --> 00:35:31.290
And if for whatever reason he
wants to avoid all highways,

00:35:31.290 --> 00:35:34.040
it'll send them down this other
road through Parramatta,

00:35:34.040 --> 00:35:35.480
going to the Auburn Bunnings.

00:35:35.480 --> 00:35:37.540
And here, you can see that he
probably actually has a few

00:35:37.540 --> 00:35:40.770
options for the Bunnings
to visit.

00:35:40.770 --> 00:35:44.250
But the distance matrix
said this one is best.

00:35:44.250 --> 00:35:46.600
And if he's feeling particularly
environmentally

00:35:46.600 --> 00:35:48.610
conscious, he might
want to walk.

00:35:48.610 --> 00:35:51.440
Even though you'll see the route
takes I think about six

00:35:51.440 --> 00:35:54.720
hours, and that doesn't include
the stop at Bunnings.

00:35:54.720 --> 00:35:56.790
JEZ FLETCHER: And if you know
Dave, he likes to spend a good

00:35:56.790 --> 00:35:58.380
couple of hours at Bunnings.

00:35:58.380 --> 00:36:00.250
SUZANNA RUUB: So that might
be a long trip if he

00:36:00.250 --> 00:36:03.550
were to walk home.

00:36:03.550 --> 00:36:07.320
So to implement this, I used the
PlacesService to get all

00:36:07.320 --> 00:36:09.480
the Bunnings in the view port.

00:36:09.480 --> 00:36:13.390
I then used the DistanceMatrix
service to get the shortest

00:36:13.390 --> 00:36:16.880
route in using only one request,
despite the fact that

00:36:16.880 --> 00:36:18.530
there are many Bunnings.

00:36:18.530 --> 00:36:20.660
Then I used the
DirectionsService to get the

00:36:20.660 --> 00:36:23.910
full details of that routing.

00:36:23.910 --> 00:36:27.050
And I used the
DirectionsRenderer to draw

00:36:27.050 --> 00:36:30.260
that on the map and
in the panel.

00:36:30.260 --> 00:36:30.450
JEZ FLETCHER: OK.

00:36:30.450 --> 00:36:31.840
So that's the last
of our demos.

00:36:31.840 --> 00:36:34.820
And we just wanted to give you
three key takeaways from this

00:36:34.820 --> 00:36:39.385
talk to sort of summarize what
we were talking about.

00:36:39.385 --> 00:36:42.510
And the first takeaway we'd
like you to think about is

00:36:42.510 --> 00:36:45.220
that you should be following
good programming practices

00:36:45.220 --> 00:36:47.780
even when you're in JavaScript
and even when you're just

00:36:47.780 --> 00:36:49.830
working with the Maps API.

00:36:49.830 --> 00:36:53.980
And we've shown you some cool
tools with the testing open

00:36:53.980 --> 00:36:56.190
source libraries that we showed
you and the Closure

00:36:56.190 --> 00:36:59.190
Compiler that can help
you do this.

00:36:59.190 --> 00:37:00.580
SUZANNA RUUB: And then we want
to encourage you to really

00:37:00.580 --> 00:37:02.520
pull in all of your resources.

00:37:02.520 --> 00:37:06.010
Use as many features as you can
to enrich your data, to

00:37:06.010 --> 00:37:09.820
add context to it, and to create
something that would

00:37:09.820 --> 00:37:13.825
have been smart and
make it awesome.

00:37:13.825 --> 00:37:14.850
JEZ FLETCHER: Exactly.

00:37:14.850 --> 00:37:16.790
When you use features together,
you really get

00:37:16.790 --> 00:37:18.810
powerful stuff, don't
you Suzanna?

00:37:18.810 --> 00:37:21.280
And the last thing, and you've
probably seen this before, we

00:37:21.280 --> 00:37:23.450
want to drive home that every
address field on the web

00:37:23.450 --> 00:37:25.220
should use autocomplete.

00:37:25.220 --> 00:37:26.760
And you've seen that all the
way through our demos.

00:37:26.760 --> 00:37:29.720
Every time we had to enter an
address, we used the auto

00:37:29.720 --> 00:37:30.400
complete widget.

00:37:30.400 --> 00:37:32.570
And we think this is something
that's not just going to make

00:37:32.570 --> 00:37:35.100
your Maps applications better,
we think it's going to make

00:37:35.100 --> 00:37:37.570
the web better as a whole.

00:37:37.570 --> 00:37:41.360
SUZANNA RUUB: So you can visit
developers.google.com/maps for

00:37:41.360 --> 00:37:44.700
more information about all of
the APIs and features that

00:37:44.700 --> 00:37:47.220
we've talked about today.

00:37:47.220 --> 00:37:48.060
JEZ FLETCHER: And
we'd now like to

00:37:48.060 --> 00:37:50.090
throw it open to questions.

00:37:50.090 --> 00:37:51.537
So thank you very much.

00:37:51.537 --> 00:37:59.180
[APPLAUSE]

00:37:59.180 --> 00:38:01.010
SUZANNA RUUB: And if you have
any questions, please come to

00:38:01.010 --> 00:38:02.260
one of the mikes.

00:38:34.098 --> 00:38:35.938
AUDIENCE: I've been using the
autocomplete widget for a

00:38:35.938 --> 00:38:36.480
couple of projects now.

00:38:36.480 --> 00:38:39.940
And one thing that bothers me is
I can't hit enter to select

00:38:39.940 --> 00:38:41.830
the first entry in the list.

00:38:41.830 --> 00:38:46.160
Is this a feature
that will come?

00:38:46.160 --> 00:38:49.140
SUZANNA RUUB: So the issue
tracker is a great place to

00:38:49.140 --> 00:38:50.420
file requests like these.

00:38:50.420 --> 00:38:52.810
We really do respond to them.

00:38:52.810 --> 00:38:55.430
So, yes.

00:38:55.430 --> 00:38:57.070
File that in the
issue tracker.

00:38:57.070 --> 00:38:58.350
We will take a look at it.

00:38:58.350 --> 00:39:00.480
That's a great request.

00:39:00.480 --> 00:39:01.730
Thanks.

00:39:06.580 --> 00:39:08.353
AUDIENCE: I guess it doesn't
matter if I walk

00:39:08.353 --> 00:39:09.603
up to the mike now.

00:39:12.280 --> 00:39:17.340
We have an application that puts
maps on people's websites

00:39:17.340 --> 00:39:19.990
for their business.

00:39:19.990 --> 00:39:20.870
And they enter an address.

00:39:20.870 --> 00:39:25.960
And we geocode it in the back
end, put the geocoded address

00:39:25.960 --> 00:39:30.960
directly into the map code on
the website, and that prevents

00:39:30.960 --> 00:39:35.645
us from having to geocode every
page load without doing

00:39:35.645 --> 00:39:40.510
any kind of crazy memcache
stuff on the page.

00:39:40.510 --> 00:39:49.390
But when we had adopted that
practice, it was expressed to

00:39:49.390 --> 00:39:52.480
us that that wasn't necessarily
a good practice

00:39:52.480 --> 00:39:55.380
for the reason that the
geocoding gets updated from

00:39:55.380 --> 00:39:56.500
time to time.

00:39:56.500 --> 00:39:59.540
And we should be most of the
time be using the on page

00:39:59.540 --> 00:40:04.910
geocoding, rewriting the
JavaScript of the page.

00:40:04.910 --> 00:40:08.350
We chose to go the route that
we went because we have

00:40:08.350 --> 00:40:11.780
another UI that users
can then go in and

00:40:11.780 --> 00:40:14.070
change their map location.

00:40:14.070 --> 00:40:16.650
And since it's already
hard-coded on the page, it's

00:40:16.650 --> 00:40:21.400
pretty trivial to hard-code
it to a different address.

00:40:21.400 --> 00:40:24.540
Is that still considered
not the best

00:40:24.540 --> 00:40:29.690
practice, or has that changed?

00:40:29.690 --> 00:40:34.040
SUZANNA RUUB: So the question
is around when is it best

00:40:34.040 --> 00:40:37.540
practice to geocode on the page
versus ahead of time and

00:40:37.540 --> 00:40:41.700
then hard-code that because
geocodes update.

00:40:41.700 --> 00:40:45.740
I would say, so if you have a
bunch of static addresses that

00:40:45.740 --> 00:40:48.860
need geocoding, they should be
done ahead of time using the

00:40:48.860 --> 00:40:50.360
web service, as you are.

00:40:50.360 --> 00:40:54.110
But yes, your cache should be
cleared from time to time to

00:40:54.110 --> 00:40:55.370
allow for updates.

00:40:55.370 --> 00:40:58.600
So I don't have a recommendation
for what that

00:40:58.600 --> 00:41:01.540
timing should be.

00:41:01.540 --> 00:41:04.780
If you notice that you're not
getting the address you think

00:41:04.780 --> 00:41:09.780
you should, then decrease
your cache time.

00:41:09.780 --> 00:41:12.860
JEZ FLETCHER: But this can be
batched, remember, so--

00:41:12.860 --> 00:41:16.800
AUDIENCE: This is something that
the page gets generated,

00:41:16.800 --> 00:41:24.150
and then unless the user does
something to trigger the page

00:41:24.150 --> 00:41:29.025
being regenerated, the map would
not get updated in our

00:41:29.025 --> 00:41:30.965
current location.

00:41:30.965 --> 00:41:35.815
We do have a mechanism we can
regenerate all the pages

00:41:35.815 --> 00:41:37.065
[INAUDIBLE]

00:41:40.200 --> 00:41:42.720
SUZANNA RUUB: I would probably
advise regenerating them from

00:41:42.720 --> 00:41:45.335
time to time so that you get
updates to the geocodes.

00:41:50.450 --> 00:41:52.350
Any other questions?

00:41:52.350 --> 00:41:54.000
I think the mikes
are working now.

00:41:54.000 --> 00:41:56.620
So you can come up
and use those.

00:42:01.390 --> 00:42:05.490
AUDIENCE: I think you kind
of covered this with

00:42:05.490 --> 00:42:06.850
the batching API.

00:42:06.850 --> 00:42:13.570
But my developers have talked
about the rate limits, and

00:42:13.570 --> 00:42:14.210
it's a challenge.

00:42:14.210 --> 00:42:17.080
So what's your advice for
dealing with rate limits?

00:42:17.080 --> 00:42:18.740
SUZANNA RUUB: So for a
particular service--

00:42:18.740 --> 00:42:21.230
I guess it goes for all
services perhaps.

00:42:21.230 --> 00:42:23.590
But I can tell you a little more
about what I did in the

00:42:23.590 --> 00:42:27.440
Bunnings example around
rate limits.

00:42:27.440 --> 00:42:29.310
So you'll notice that
I was toggling

00:42:29.310 --> 00:42:31.120
between a bunch of options.

00:42:31.120 --> 00:42:34.210
And one thing that I did was
just in the client, after I

00:42:34.210 --> 00:42:38.400
made a request, I cached the
request that I made and then

00:42:38.400 --> 00:42:39.960
the end directions result.

00:42:39.960 --> 00:42:43.540
Because otherwise, it's
rate-limited, and so I can't

00:42:43.540 --> 00:42:46.110
make all those requests if you
want to toggle back and forth

00:42:46.110 --> 00:42:49.420
across all the options.

00:42:49.420 --> 00:42:51.310
So any time you're doing
repeated things, you should

00:42:51.310 --> 00:42:54.800
cache in that instance so that
you don't make the same

00:42:54.800 --> 00:42:58.270
request again and again.

00:42:58.270 --> 00:43:03.010
If it's not a matter of repeated
action and just that

00:43:03.010 --> 00:43:06.310
you have more work to do, if
you can front-load some of

00:43:06.310 --> 00:43:11.660
that offline and store it in
your own cache, that would be

00:43:11.660 --> 00:43:13.620
appropriate for say, geocodes.

00:43:13.620 --> 00:43:16.200
Otherwise, wait.

00:43:20.530 --> 00:43:22.200
AUDIENCE: I have a
similar problem.

00:43:22.200 --> 00:43:26.130
I have about 11,000 static
locations in the United States

00:43:26.130 --> 00:43:29.780
and every day about 1,000
dynamic locations.

00:43:29.780 --> 00:43:33.990
I'm trying to find the closest
of my static locations for

00:43:33.990 --> 00:43:35.580
each dynamic.

00:43:35.580 --> 00:43:38.000
Can I use the distance matrix?

00:43:38.000 --> 00:43:39.390
SUZANNA RUUB: Distance
matrix has a limit, I

00:43:39.390 --> 00:43:41.970
believe, of 10 origins.

00:43:41.970 --> 00:43:45.730
It's not quite 10 origins
and 10 destinations--

00:43:45.730 --> 00:43:48.380
do you have the exact number?

00:43:48.380 --> 00:43:49.030
Yeah, you.

00:43:49.030 --> 00:43:50.749
MALE SPEAKER: [INAUDIBLE]

00:43:50.749 --> 00:43:52.020
maximum of 100 elements.

00:43:52.020 --> 00:43:52.200
SUZANNA RUUB: OK.

00:43:52.200 --> 00:43:56.160
So maximum of 100 elements,
whether that's 10 by 10-- oh,

00:43:56.160 --> 00:43:57.250
new answer.

00:43:57.250 --> 00:43:57.693
MALE SPEAKER: [INAUDIBLE]

00:43:57.693 --> 00:44:00.800
Maps for Business customers
can do 25 by 25.

00:44:00.800 --> 00:44:03.760
SUZANNA RUUB: So Maps for
Business customers can do 25

00:44:03.760 --> 00:44:06.560
by 25 or whatever that
multiplies out to be.

00:44:06.560 --> 00:44:10.830
And not Maps for Business
customers can get 10 by 10 or

00:44:10.830 --> 00:44:14.790
some other configuration
that multiplies to 100.

00:44:14.790 --> 00:44:19.100
So is that the answer you
were looking for?

00:44:19.100 --> 00:44:21.550
AUDIENCE: Yeah, so really for
a large number, like in my

00:44:21.550 --> 00:44:23.970
case, you don't really
have a solution then?

00:44:23.970 --> 00:44:26.860
SUZANNA RUUB: I would say for
a large company and a large

00:44:26.860 --> 00:44:30.540
data set, you should talk
to our sales reps.

00:44:30.540 --> 00:44:31.790
AUDIENCE: Thank you.

00:44:34.530 --> 00:44:37.640
AUDIENCE: More questions around
unit testing with the

00:44:37.640 --> 00:44:40.060
JavaScript API.

00:44:40.060 --> 00:44:43.410
I mean there's some DOM
manipulation at first, versus

00:44:43.410 --> 00:44:48.300
stuff that you don't have to,
versus maybe unit testing with

00:44:48.300 --> 00:44:50.690
events that you could
trigger off a map.

00:44:50.690 --> 00:44:54.450
Any more thoughts on is it
possible to do that?

00:44:54.450 --> 00:44:58.440
What's the capabilities in depth
more with JavaScript?

00:44:58.440 --> 00:45:00.640
SUZANNA RUUB: Let's see.

00:45:00.640 --> 00:45:02.970
You may need to ask follow-up
questions if I don't get all

00:45:02.970 --> 00:45:04.540
parts of this.

00:45:04.540 --> 00:45:08.120
If you use Google JS Test, for
example, it runs not in a

00:45:08.120 --> 00:45:09.840
browser at all.

00:45:09.840 --> 00:45:11.960
It runs just the JavaScript.

00:45:11.960 --> 00:45:16.960
So that's a good tool to use for
testing the functionality

00:45:16.960 --> 00:45:18.210
of your class.

00:45:20.350 --> 00:45:24.670
You can easily trigger events
with it and listen to events

00:45:24.670 --> 00:45:26.200
and test your event handling.

00:45:26.200 --> 00:45:30.200
If you want to check things
in the DOM, then Puppeteer

00:45:30.200 --> 00:45:31.370
is the way to go.

00:45:31.370 --> 00:45:33.590
And you can actually inspect
individual elements

00:45:33.590 --> 00:45:34.880
and click on them.

00:45:34.880 --> 00:45:38.800
And so you can actually load it
up running the Maps API and

00:45:38.800 --> 00:45:43.370
check that the map has loaded
and that you have done the

00:45:43.370 --> 00:45:45.620
things to it that
you want to do.

00:45:45.620 --> 00:45:48.940
JEZ FLETCHER: I guess another
key thing to say is that if

00:45:48.940 --> 00:45:51.040
you follow this sort of testing
structure, then it

00:45:51.040 --> 00:45:54.130
actually guides your way to
actually structure your

00:45:54.130 --> 00:45:55.830
individual classes as well.

00:45:55.830 --> 00:45:58.270
So if you can pull out all of
the functionality that doesn't

00:45:58.270 --> 00:46:00.860
have to do with DOM manipulation
into one class,

00:46:00.860 --> 00:46:03.090
then you can test that really
easily and really quickly

00:46:03.090 --> 00:46:05.410
using Google JS test.

00:46:05.410 --> 00:46:07.710
And then if you have the DOM
manipulation in a separate

00:46:07.710 --> 00:46:10.170
thing, then you can test that
when you're doing your overall

00:46:10.170 --> 00:46:13.300
integration tests in the
browser with Puppeteer.

00:46:13.300 --> 00:46:16.500
SUZANNA RUUB: And with that,
keep in mind that you can mock

00:46:16.500 --> 00:46:20.260
things in Google JS Test,
meaning you can mock out all

00:46:20.260 --> 00:46:24.220
of our classes and just expect
that a map works the way you

00:46:24.220 --> 00:46:25.990
think it should, and a
marker works the way

00:46:25.990 --> 00:46:26.720
you think it should.

00:46:26.720 --> 00:46:28.820
And trust us to have
tested those parts.

00:46:28.820 --> 00:46:30.060
And mock those out.

00:46:30.060 --> 00:46:33.320
And just check that you're
correctly calling set position

00:46:33.320 --> 00:46:36.370
or fit bounds or whatever
it is that you are

00:46:36.370 --> 00:46:37.600
calling on the map.

00:46:37.600 --> 00:46:40.300
AUDIENCE: Any ways to get help
on mocking the data?

00:46:43.880 --> 00:46:46.410
SUZANNA RUUB: So I think the
resources for Google JS Test

00:46:46.410 --> 00:46:49.260
will explain how to
create mocks.

00:46:49.260 --> 00:46:53.650
And it's actually as simple in
JavaScript as saying, create

00:46:53.650 --> 00:46:55.460
mock instance or create
mock function.

00:46:55.460 --> 00:46:56.790
And you just pass it the name.

00:46:56.790 --> 00:47:00.320
So with externs, using the
externs in combination with

00:47:00.320 --> 00:47:04.860
Google JS Test, you should be
able to mock the Maps API

00:47:04.860 --> 00:47:06.110
functionality.

00:47:09.060 --> 00:47:11.480
AUDIENCE: Hi, at the Federal
Aviation Administration, my

00:47:11.480 --> 00:47:14.430
users are either searching for
an airport code or an address.

00:47:14.430 --> 00:47:17.430
Could I use the autocomplete
widget to first check if it's

00:47:17.430 --> 00:47:20.430
a three-digit airport code,
like SFO, and try and

00:47:20.430 --> 00:47:23.340
autocomplete airports that start
with S, and then, if

00:47:23.340 --> 00:47:26.120
not, go to the address
suggestions?

00:47:26.120 --> 00:47:27.370
SUZANNA RUUB: In the back,
do we have airport

00:47:27.370 --> 00:47:29.530
codes in auto complete?

00:47:29.530 --> 00:47:31.230
AUDIENCE: It usually works
for airport codes.

00:47:31.230 --> 00:47:34.570
But we have really minor
airports that it

00:47:34.570 --> 00:47:35.810
doesn't work for.

00:47:35.810 --> 00:47:37.060
MALE SPEAKER: [INAUDIBLE]

00:48:08.000 --> 00:48:09.950
SUZANNA RUUB: I think the short
answer here is that

00:48:09.950 --> 00:48:14.230
though airports are in
autocomplete, we don't quite

00:48:14.230 --> 00:48:16.610
have a way to say restrict
just to airports.

00:48:16.610 --> 00:48:18.480
AUDIENCE: I have an internal
list of my airport codes.

00:48:18.480 --> 00:48:21.760
Could I point it at my internal
list first, or does

00:48:21.760 --> 00:48:23.850
it not allow for that
kind of local data?

00:48:23.850 --> 00:48:23.978
SUZANNA RUUB: It doesn't.

00:48:23.978 --> 00:48:28.140
You cannot insert things
into the autocomplete.

00:48:28.140 --> 00:48:33.030
But go ahead and file feature
requests on the issue tracker.

00:48:33.030 --> 00:48:34.280
And talk to Marcello.

00:48:36.710 --> 00:48:37.960
Any more questions?

00:48:40.970 --> 00:48:42.140
All right, thank
you very much.

00:48:42.140 --> 00:48:46.900
And there is a fireside chat
this afternoon at 5:15 if you

00:48:46.900 --> 00:48:49.210
have any more questions for
a broader range of people.

