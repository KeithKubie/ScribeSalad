WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:37.696
[MUSIC PLAYING]

00:00:56.048 --> 00:00:58.180
RAUL FURNICA: OK, the screen
size is really small, so it's

00:00:58.180 --> 00:00:58.760
kind of weird.

00:00:58.760 --> 00:01:02.690
But this is a live
API [INAUDIBLE]

00:01:02.690 --> 00:01:04.110
from this URL, so you
just click on it.

00:01:04.110 --> 00:01:30.359
[MUSIC PLAYING]

00:01:39.536 --> 00:01:43.850
RAUL FURNICA: --I can explain
what happens.

00:01:43.850 --> 00:01:47.820
But most of the time, it's just
explaining, oh, that's

00:01:47.820 --> 00:01:50.250
behind this.

00:01:50.250 --> 00:01:55.590
So we've done a request to
retrieve [INAUDIBLE] metadata.

00:01:55.590 --> 00:01:57.790
That way, you can figure
from the URL.

00:01:57.790 --> 00:02:02.600
And then we have a web interface
where you can try

00:02:02.600 --> 00:02:06.220
any API call directly without
actually [INAUDIBLE]

00:02:06.220 --> 00:02:07.994
tool or using a [INAUDIBLE].

00:02:07.994 --> 00:02:10.799
So you just [INAUDIBLE]
web interface.

00:02:10.799 --> 00:02:14.840
You have links to this
interface later on--

00:02:14.840 --> 00:02:17.710
actually, on the last slide
on the resources.

00:02:17.710 --> 00:02:23.500
And it's a really cool interface
that allows you to

00:02:23.500 --> 00:02:24.350
specify the parameters.

00:02:24.350 --> 00:02:27.140
But if a parameter is like a
[INAUDIBLE] parameter, you can

00:02:27.140 --> 00:02:29.745
actually choose from the values
allowed and so on.

00:02:29.745 --> 00:02:35.080
So it's a way to discover the
API and get into YouTube APIs

00:02:35.080 --> 00:02:37.260
and YouTube, in particular.

00:02:37.260 --> 00:02:40.690
On the response, you just get
metadata about video.

00:02:43.322 --> 00:02:46.370
So kind of looks like this.

00:02:46.370 --> 00:02:48.640
This is the first view
I'm giving you.

00:02:48.640 --> 00:02:50.790
I'm going to go back to
it and show you more.

00:03:17.250 --> 00:03:20.510
So in the first slide at the
top, I'm going to walk you

00:03:20.510 --> 00:03:25.053
through the API structure
and terminology.

00:03:25.053 --> 00:03:28.820
And the way I'm going to do that
is I'm going to slowly

00:03:28.820 --> 00:03:32.340
start taking the base URL and
complete it until we get to a

00:03:32.340 --> 00:03:34.370
full request that we can
fire against the API.

00:03:34.370 --> 00:03:36.720
I'm going to explain every
single path and term that we

00:03:36.720 --> 00:03:39.490
have on the way.

00:03:39.490 --> 00:03:43.580
So first thing to note is that
the YouTube API is now hosted

00:03:43.580 --> 00:03:45.600
at googleapis.com.

00:03:45.600 --> 00:03:48.530
It only works on HTTPS.

00:03:48.530 --> 00:03:53.380
And very first part of
the path is YouTube.

00:03:53.380 --> 00:03:55.590
At googleapis.com,
you can find any

00:03:55.590 --> 00:03:56.640
API that Google creates.

00:03:56.640 --> 00:03:59.630
So you can find,
like, G+ APIs.

00:03:59.630 --> 00:04:02.760
You can find contacts--

00:04:02.760 --> 00:04:03.630
sorry.

00:04:03.630 --> 00:04:08.340
Well, contacts works, too, but
Gmail, Calendar, all APIs are

00:04:08.340 --> 00:04:10.670
under their own name.

00:04:10.670 --> 00:04:14.090
And then the very first thing
you'll see that is particular

00:04:14.090 --> 00:04:16.440
to YouTube is the
version of API.

00:04:16.440 --> 00:04:19.630
The version of the API is,
as you might know,

00:04:19.630 --> 00:04:20.579
a versioning API.

00:04:20.579 --> 00:04:25.690
It's just naming of a particular
schema of the API.

00:04:25.690 --> 00:04:30.630
Minor versions are usually
backwards-compatible, and they

00:04:30.630 --> 00:04:32.650
add to the API schema.

00:04:32.650 --> 00:04:34.770
Major versions are
backwards-incompatible, and

00:04:34.770 --> 00:04:39.580
they change the schema in a
non-reusable way from an

00:04:39.580 --> 00:04:40.380
[? app-forward ?]

00:04:40.380 --> 00:04:42.488
perspective.

00:04:42.488 --> 00:04:46.680
The naming, in particular,
is v major dot minor.

00:04:46.680 --> 00:04:50.010
It's normal, so what
you would expect.

00:04:50.010 --> 00:04:52.720
And it's part of the URL, so
that makes it really clear

00:04:52.720 --> 00:04:56.105
which version you're using to
contact the YouTube API.

00:05:00.506 --> 00:05:04.190
YouTube APIs are all RESTful.

00:05:04.190 --> 00:05:09.350
And does everybody understand
what RESTful as an API means?

00:05:09.350 --> 00:05:10.150
AUDIENCE: Yes.

00:05:10.150 --> 00:05:12.170
RAUL FURNICA: Cool, awesome.

00:05:12.170 --> 00:05:16.850
So in that sense, we
have data models.

00:05:16.850 --> 00:05:18.800
We have a layer of this logic.

00:05:18.800 --> 00:05:21.840
So I'm going to talk about both,
and then I'm going to

00:05:21.840 --> 00:05:24.552
describe them, what do they
mean, the YouTube API.

00:05:24.552 --> 00:05:27.290
And first thing in the
terminology that I want to

00:05:27.290 --> 00:05:30.430
introduce is collections.

00:05:30.430 --> 00:05:36.210
Collections, you can take it
as the sum of all resources

00:05:36.210 --> 00:05:37.910
that are of the same type.

00:05:37.910 --> 00:05:41.510
So collections would be anything
that, on the product

00:05:41.510 --> 00:05:43.430
side, we would call nouns.

00:05:43.430 --> 00:05:45.410
So anything that YouTube--

00:05:45.410 --> 00:05:48.440
or the users of YouTube--
define as a noun, like

00:05:48.440 --> 00:05:51.740
playlists or a video, it,
in the end, forms the

00:05:51.740 --> 00:05:52.190
collections.

00:05:52.190 --> 00:05:58.100
So this next part of the URL, it
identifies which collection

00:05:58.100 --> 00:05:59.350
you want to work on.

00:06:02.136 --> 00:06:06.310
I've listed here all the
collections we support right

00:06:06.310 --> 00:06:06.974
now in the API.

00:06:06.974 --> 00:06:09.150
And we're going to add on them,
and we're going to get

00:06:09.150 --> 00:06:11.910
to the point-- like in v3 right
now, we have less than

00:06:11.910 --> 00:06:12.920
we had in v2.

00:06:12.920 --> 00:06:15.300
But we're going to get into
the point that we have

00:06:15.300 --> 00:06:16.556
everything that we had
in v2, and we're

00:06:16.556 --> 00:06:18.775
going to add some more.

00:06:18.775 --> 00:06:22.405
The main parts are, as I already
mentioned, videos,

00:06:22.405 --> 00:06:24.150
playlists, and channels.

00:06:24.150 --> 00:06:27.786
That's the main defining nouns
of the YouTube product.

00:06:27.786 --> 00:06:30.440
On top of that, there is
activities, search, and

00:06:30.440 --> 00:06:31.830
subscription.

00:06:31.830 --> 00:06:34.410
Those are a bit more special.

00:06:34.410 --> 00:06:37.710
Activities are more about the
social side of YouTube, so you

00:06:37.710 --> 00:06:39.310
follow other people's
activity.

00:06:39.310 --> 00:06:41.630
You subscribe to other
people's activity.

00:06:41.630 --> 00:06:43.155
You see what they're
doing on YouTube.

00:06:43.155 --> 00:06:47.315
You get to discover new
content via them.

00:06:47.315 --> 00:06:49.230
And in a sort of
weird way, even

00:06:49.230 --> 00:06:50.470
recommendations in playlist.

00:06:50.470 --> 00:06:53.330
And when YouTube thinks you
should be watching this video,

00:06:53.330 --> 00:06:56.510
that comes up as an activity,
as a recommendation.

00:06:56.510 --> 00:07:00.050
YouTube tells you or thinks
this is good for you.

00:07:00.050 --> 00:07:04.240
Search is another collection,
but I'm going to detail that

00:07:04.240 --> 00:07:06.160
probably later, because
we actually

00:07:06.160 --> 00:07:08.361
reworked search in v3.

00:07:08.361 --> 00:07:13.685
And subscriptions is just
videos, so you can get to, and

00:07:13.685 --> 00:07:15.530
the channels, you subscribe
to them.

00:07:18.670 --> 00:07:20.975
By introducing collections,
I already talked

00:07:20.975 --> 00:07:22.190
about resources a bit.

00:07:22.190 --> 00:07:24.060
So resources is very
hard to define.

00:07:24.060 --> 00:07:26.760
I mean, it's pretty clear what
it is, but if I were to define

00:07:26.760 --> 00:07:29.780
it, I would say it's just like
an identifiable unit

00:07:29.780 --> 00:07:32.890
of data in an API.

00:07:32.890 --> 00:07:34.790
Identifiable is the
important part.

00:07:34.790 --> 00:07:38.150
So every resource has
a resource ID.

00:07:38.150 --> 00:07:41.710
The resource ID is unique and
can point to that particular

00:07:41.710 --> 00:07:43.420
resource only.

00:07:43.420 --> 00:07:46.720
The resource IDs are, however,
not unique amongst different

00:07:46.720 --> 00:07:48.260
collections.

00:07:48.260 --> 00:07:50.890
So a video ID may collide
with a playlist ID.

00:07:50.890 --> 00:07:54.604
We don't necessarily care about
keeping resource IDs

00:07:54.604 --> 00:07:58.270
unique the entire way, which
is something that we

00:07:58.270 --> 00:07:59.970
used to do in v2.

00:07:59.970 --> 00:08:03.030
But we just found out that that
was really hard to use,

00:08:03.030 --> 00:08:06.890
and people got confused because
they always had to

00:08:06.890 --> 00:08:11.150
take the YouTube ID that you
would know from a website URL

00:08:11.150 --> 00:08:16.250
and pre-plan something to make
it look like an API resource.

00:08:16.250 --> 00:08:21.660
So in v3, we're reusing the
same resource IDs as the

00:08:21.660 --> 00:08:22.610
website does.

00:08:22.610 --> 00:08:25.490
So if you take the video IDs
from the website URL, you can

00:08:25.490 --> 00:08:30.620
just type it in to the API
and use the same thing.

00:08:30.620 --> 00:08:33.579
That, as I said, may cause
collision in some different

00:08:33.579 --> 00:08:36.340
resources, but you just need to
be aware that this is the

00:08:36.340 --> 00:08:38.291
video that I'm talking about,
[? where it still ?] plays.

00:08:38.291 --> 00:08:40.191
And the chance is pretty
low as well.

00:08:44.294 --> 00:08:47.438
Again, they're the same as the
YouTube nouns-- so it's video,

00:08:47.438 --> 00:08:49.910
playlist, and channel.

00:08:49.910 --> 00:08:54.080
And the resource ID, like right
here, you can see the

00:08:54.080 --> 00:08:55.980
collection is videos.

00:08:55.980 --> 00:08:58.210
And then after, we're already
moving into the parameters

00:08:58.210 --> 00:09:01.230
that we're setting
on this API call.

00:09:01.230 --> 00:09:04.580
That's id= and then the value.

00:09:04.580 --> 00:09:07.895
And then there are some
extras to the request.

00:09:07.895 --> 00:09:09.460
And I'm going to explain
a bit later.

00:09:09.460 --> 00:09:12.740
But if you take this request as
it is, and you [INAUDIBLE]

00:09:12.740 --> 00:09:14.470
API server, you would
get a response.

00:09:14.470 --> 00:09:17.460
So that's already a fully
built request.

00:09:17.460 --> 00:09:19.560
So we get some [INAUDIBLE]

00:09:19.560 --> 00:09:25.500
simple version, collection,
or resource ID.

00:09:25.500 --> 00:09:27.650
How does a video resource
look like?

00:09:27.650 --> 00:09:30.180
So YouTube is about videos.

00:09:30.180 --> 00:09:32.350
I don't know if I should
mention that.

00:09:32.350 --> 00:09:40.430
But since videos are the main
resource of YouTube, so we--

00:09:40.430 --> 00:09:41.680
oops.

00:09:43.670 --> 00:09:45.870
That is true to the
API as well.

00:09:45.870 --> 00:09:48.420
Video resource is the most
complicated resource we have

00:09:48.420 --> 00:09:52.020
in the YouTube API, as well,
in terms of schema and the

00:09:52.020 --> 00:09:56.090
number of things you can
retrieve from it.

00:09:56.090 --> 00:10:00.720
And I just took here
the main important

00:10:00.720 --> 00:10:04.340
fields for YouTube resource.

00:10:04.340 --> 00:10:07.465
And it's exactly what
you would expect.

00:10:07.465 --> 00:10:11.680
It's the time the video has
uploaded to YouTube.

00:10:11.680 --> 00:10:14.766
It's the channel the video
is uploaded into.

00:10:14.766 --> 00:10:18.820
It's the title, the description,
the thumbnails,

00:10:18.820 --> 00:10:21.430
and a categoryId and tags.

00:10:21.430 --> 00:10:26.570
This allows you to render the
visual snippet of a video, and

00:10:26.570 --> 00:10:29.990
even start playback on an
embedded player I didn't

00:10:29.990 --> 00:10:32.950
include that here, but
that's there as well.

00:10:32.950 --> 00:10:37.620
There is a lot of information
extra that you can request

00:10:37.620 --> 00:10:40.150
with specific requests.

00:10:40.150 --> 00:10:40.635
Sure.

00:10:40.635 --> 00:10:41.885
AUDIENCE: [INAUDIBLE].

00:10:45.140 --> 00:10:45.770
RAUL FURNICA: Key properties.

00:10:45.770 --> 00:10:48.600
So that's a very
good question.

00:10:48.600 --> 00:10:51.320
So in v2, if you noticed--

00:10:51.320 --> 00:10:52.931
AUDIENCE: [INAUDIBLE].

00:10:52.931 --> 00:10:53.800
RAUL FURNICA: Oh, OK.

00:10:53.800 --> 00:10:54.000
Sorry.

00:10:54.000 --> 00:10:58.550
To repeat the question,
thumbnails has the key.

00:10:58.550 --> 00:11:00.881
And the question is, what
is the key for, and

00:11:00.881 --> 00:11:03.152
what does it mean?

00:11:03.152 --> 00:11:08.080
Thumbnails is basically
a map, in JSON terms.

00:11:08.080 --> 00:11:10.620
And the reason it is a map is
that we found out in version

00:11:10.620 --> 00:11:15.640
2, when it was released, people
started depending on

00:11:15.640 --> 00:11:17.700
the order of the thumbnails'
returned--

00:11:17.700 --> 00:11:19.190
particular order.

00:11:19.190 --> 00:11:25.890
So people would expect that
thumbnail, too, is of size 144

00:11:25.890 --> 00:11:28.460
by [? 102 ?] pixels.

00:11:28.460 --> 00:11:30.700
And when we needed to introduce
new thumbnails, we

00:11:30.700 --> 00:11:33.580
always had the issue that we
can't insert it in the first

00:11:33.580 --> 00:11:36.290
or second place, because
that matters.

00:11:36.290 --> 00:11:39.090
But even in the last place,
[INAUDIBLE] other people,

00:11:39.090 --> 00:11:41.060
because they make assumptions
about the number

00:11:41.060 --> 00:11:43.970
of thumbnails available.

00:11:43.970 --> 00:11:46.950
So to solve all this, we
turned it into a map.

00:11:46.950 --> 00:11:49.640
And they key's actually the
name of the thumbnail.

00:11:49.640 --> 00:11:52.340
So it's going to be
named default.

00:11:52.340 --> 00:11:54.410
If you don't care, use
the default one.

00:11:54.410 --> 00:11:57.721
If you want the HD thumbnail,
you're going to use the name

00:11:57.721 --> 00:11:59.030
HD thumbnail is all.

00:12:02.410 --> 00:12:05.702
And that means it's not
particularly ordered.

00:12:05.702 --> 00:12:09.490
You identify by name what
thumbnail you want to use.

00:12:12.590 --> 00:12:15.080
There is another thing that
I've highlighted here, and

00:12:15.080 --> 00:12:16.390
that's kind.

00:12:16.390 --> 00:12:18.830
Kind is a field that every
single resource in

00:12:18.830 --> 00:12:23.270
a YouTube API has.

00:12:23.270 --> 00:12:26.680
And it defines the type of that
resource, if you want.

00:12:26.680 --> 00:12:30.130
So they're all going to be
youtube# and then the name of

00:12:30.130 --> 00:12:33.630
the resource, so video,
in this case.

00:12:33.630 --> 00:12:37.090
This is there because in any
JSON response, looking at just

00:12:37.090 --> 00:12:39.183
the resource, you cannot
tell what type it is.

00:12:39.183 --> 00:12:43.700
So if you want to know, for
some reason, then that

00:12:43.700 --> 00:12:47.840
basically gives you
that information.

00:12:47.840 --> 00:12:52.880
And if you're wondering, this is
the schema that the API is

00:12:52.880 --> 00:12:55.710
defining completely.

00:12:55.710 --> 00:12:58.840
And it's based on JSON
schema, if you note.

00:12:58.840 --> 00:13:02.650
And you can retrieve this
information at runtime from

00:13:02.650 --> 00:13:05.580
our servers at any
time you want.

00:13:05.580 --> 00:13:07.620
So the schema is public
and discoverable.

00:13:10.770 --> 00:13:13.390
Now we're getting into something
that is specific to

00:13:13.390 --> 00:13:17.300
the YouTube API, and it's
new for version 3.

00:13:17.300 --> 00:13:18.410
And that's parts.

00:13:18.410 --> 00:13:23.650
So we discovered that our
resources are very

00:13:23.650 --> 00:13:24.305
[INAUDIBLE].

00:13:24.305 --> 00:13:29.700
And in order to retrieve a
particular resource, you might

00:13:29.700 --> 00:13:35.580
get a 100-kilobytes response,
even, for a video in version

00:13:35.580 --> 00:13:37.990
2, for instance, which is really
a lot for bandwidth

00:13:37.990 --> 00:13:39.260
consumption.

00:13:39.260 --> 00:13:41.490
So people need better control
in what they're retrieving

00:13:41.490 --> 00:13:43.490
about that resource.

00:13:43.490 --> 00:13:46.840
And also, we need a more
marginal response and marginal

00:13:46.840 --> 00:13:48.370
resources, in particular.

00:13:48.370 --> 00:13:52.070
However, a video is still a
video, and it means many

00:13:52.070 --> 00:13:53.130
things to YouTube.

00:13:53.130 --> 00:13:57.210
So if you're asking an uploader
what a video means,

00:13:57.210 --> 00:14:00.125
it might be just the bytes he
uploaded and then the type of

00:14:00.125 --> 00:14:03.250
description of the video
from upload metadata.

00:14:03.250 --> 00:14:05.410
But if you're asking
an advertiser--

00:14:05.410 --> 00:14:08.160
and advertisers are
users, too--

00:14:08.160 --> 00:14:11.440
then you're basically finding
out that they have very

00:14:11.440 --> 00:14:13.110
different needs related
to video.

00:14:13.110 --> 00:14:17.650
They don't care that much about
the title maybe, but

00:14:17.650 --> 00:14:20.090
they care a lot more about the
stats-- how many times was

00:14:20.090 --> 00:14:24.085
this video watched, how many
times was this video embedded

00:14:24.085 --> 00:14:26.435
on a particular site, or
which sites was it

00:14:26.435 --> 00:14:28.190
embedded on and so on.

00:14:28.190 --> 00:14:33.010
So analytics, in that sense, is
much more important there.

00:14:33.010 --> 00:14:38.430
So in order to not have
different APIs for all this,

00:14:38.430 --> 00:14:40.160
we still call that resource.

00:14:40.160 --> 00:14:43.075
So video, we came
out with parts.

00:14:43.075 --> 00:14:47.560
Parts are a grouping of fields
that makes sense to be both

00:14:47.560 --> 00:14:50.760
managed and retrieved
at the same time.

00:14:50.760 --> 00:14:54.290
And every single resource we
make against the YouTube API

00:14:54.290 --> 00:14:58.145
version 3 requires that you
specify the parts you want to

00:14:58.145 --> 00:14:59.950
fetch on that resource.

00:14:59.950 --> 00:15:06.770
If it's a write operation, then
it basically means that

00:15:06.770 --> 00:15:09.110
you're just operating
that part alone.

00:15:09.110 --> 00:15:15.550
And every single part can be
read or written all by itself,

00:15:15.550 --> 00:15:16.810
so [? independently. ?]

00:15:16.810 --> 00:15:19.930
Or you can do that on multiple
parts at the same time.

00:15:19.930 --> 00:15:23.770
There's no way to say, give me
all the parts today, which is

00:15:23.770 --> 00:15:28.330
good for us because it allows
us to add new parts without

00:15:28.330 --> 00:15:29.750
changing backwards-compatibility
or

00:15:29.750 --> 00:15:33.050
without having to break
apps already there.

00:15:33.050 --> 00:15:38.970
Because if apps would start
depending on certain parts

00:15:38.970 --> 00:15:41.034
being there or not being
there, that would be a

00:15:41.034 --> 00:15:42.850
backwards-incompatible change.

00:15:42.850 --> 00:15:43.970
So this is good for us.

00:15:43.970 --> 00:15:46.980
This is good for our clients.

00:15:46.980 --> 00:15:50.580
And it really gives a lot of
control over the bandwidth for

00:15:50.580 --> 00:15:51.232
every client app.

00:15:51.232 --> 00:15:52.588
And the bandwidth is
really important,

00:15:52.588 --> 00:15:53.838
particularly in YouTube.

00:15:56.240 --> 00:16:00.490
So I'm going to give
examples later on.

00:16:00.490 --> 00:16:04.310
But to start with, let's look
at two particular parts of

00:16:04.310 --> 00:16:05.070
video difference.

00:16:05.070 --> 00:16:08.510
One is statistics, one I talked
about a bit in the

00:16:08.510 --> 00:16:09.968
analytics use case.

00:16:09.968 --> 00:16:13.110
And another one is the status.

00:16:13.110 --> 00:16:15.890
So statistics, for instance, is
much more interesting for

00:16:15.890 --> 00:16:18.796
people that are looking into how
is this video doing, how

00:16:18.796 --> 00:16:23.861
is it shared, how many people
like it or dislike it or

00:16:23.861 --> 00:16:25.520
comment on it?

00:16:25.520 --> 00:16:29.230
And this second status part is
much more about controlling

00:16:29.230 --> 00:16:32.782
privacy of the video, and it's
much more important for an

00:16:32.782 --> 00:16:34.370
uploader perspective,
for instance.

00:16:34.370 --> 00:16:37.505
Or it's much more important from
a playback perspective.

00:16:37.505 --> 00:16:40.788
If the video is private, you
can only do a playback for

00:16:40.788 --> 00:16:41.870
that video, right?

00:16:41.870 --> 00:16:43.699
So you can't see.

00:16:43.699 --> 00:16:47.580
So the two are relatively
different, but you do get a

00:16:47.580 --> 00:16:52.351
choice to say, I want both of
them, or I want one of them,

00:16:52.351 --> 00:16:53.794
or I want none of
them, basically.

00:16:58.560 --> 00:17:03.190
There are two parts that are
generic enough that show up on

00:17:03.190 --> 00:17:05.470
every single resource.

00:17:05.470 --> 00:17:09.230
One of them is the id part.

00:17:09.230 --> 00:17:11.560
It doesn't make sense to return
a resource without

00:17:11.560 --> 00:17:16.589
returning its ID, so there is
no need to call out the id

00:17:16.589 --> 00:17:17.589
part in the part parameter.

00:17:17.589 --> 00:17:21.800
You can just assume it's always
going to be returned.

00:17:21.800 --> 00:17:25.230
And the second is a snippet,
which kind of goes with the

00:17:25.230 --> 00:17:27.829
philosophy that if you say
YouTube resource, it should

00:17:27.829 --> 00:17:30.794
have a visual presentation
or a thumbnail.

00:17:30.794 --> 00:17:33.660
It's kind of something we're
trying to introduce in every

00:17:33.660 --> 00:17:38.140
single operation that the
YouTube API supports.

00:17:38.140 --> 00:17:40.960
We didn't have that in version
2, and people had a lot of

00:17:40.960 --> 00:17:45.920
problems trying to retrieve
thumbnails that are about to

00:17:45.920 --> 00:17:48.580
resource, but not necessarily
the resource, not necessarily

00:17:48.580 --> 00:17:50.466
having a thumbnail directly.

00:17:50.466 --> 00:17:55.256
Like, for instance,
subscription, it's a channel

00:17:55.256 --> 00:17:56.050
you subscribe to.

00:17:56.050 --> 00:17:58.620
But in order to get a thumbnail
for that in version

00:17:58.620 --> 00:18:01.460
2, you have to actually take
your channel ID from the

00:18:01.460 --> 00:18:04.930
subscription and then fire
another request against the

00:18:04.930 --> 00:18:07.545
channel's feed, and then
get the thumbnail.

00:18:07.545 --> 00:18:11.890
In this case, we're just saying
we want to make it easy

00:18:11.890 --> 00:18:16.450
for people to visualize any
YouTube resource and put it on

00:18:16.450 --> 00:18:18.730
a web page.

00:18:18.730 --> 00:18:21.540
So that's all the fields
you need to

00:18:21.540 --> 00:18:23.000
build this small snippet.

00:18:23.000 --> 00:18:26.530
If you need a lot more, then you
have other options to get

00:18:26.530 --> 00:18:27.830
more detail.

00:18:27.830 --> 00:18:30.500
But we're kind of inlining
a bit of data to

00:18:30.500 --> 00:18:34.050
help you out there.

00:18:34.050 --> 00:18:36.920
Now we're moving to the business
logic [INAUDIBLE], so

00:18:36.920 --> 00:18:39.235
basically on the operations
side.

00:18:39.235 --> 00:18:42.880
So I've been talking about the
resources in particular-- so

00:18:42.880 --> 00:18:48.380
collections, resources, or
data model, collection as

00:18:48.380 --> 00:18:50.970
resources, IDs, and parts.

00:18:50.970 --> 00:18:53.701
And now let's see what
kind of calls we can

00:18:53.701 --> 00:18:55.625
make against the API.

00:18:55.625 --> 00:19:04.260
So in terms of business
logic, we can define

00:19:04.260 --> 00:19:07.160
the concepts as services.

00:19:07.160 --> 00:19:09.800
Services are pretty much
related to collections.

00:19:09.800 --> 00:19:13.050
So every single service
operates on a single

00:19:13.050 --> 00:19:15.340
collection and only
one collection.

00:19:15.340 --> 00:19:18.580
And it allows management of that
collection, so you can do

00:19:18.580 --> 00:19:20.760
both reads and writes on that
particular collection.

00:19:23.810 --> 00:19:25.705
In that sense, they're
all linked to

00:19:25.705 --> 00:19:26.892
the collections name.

00:19:26.892 --> 00:19:29.250
So there is a ChannelService,
there is a VideoService, there

00:19:29.250 --> 00:19:34.640
is a PlayerService and a
PlaylistService and a

00:19:34.640 --> 00:19:38.250
SearchService, and so on.

00:19:38.250 --> 00:19:41.127
Services, in particular, handle
all the logic around

00:19:41.127 --> 00:19:45.380
the authentication, around
privacy, ACLs for accessing

00:19:45.380 --> 00:19:47.882
the data, and so on.

00:19:47.882 --> 00:19:52.510
For authentication, we use OAuth
2.0 in version 3, and

00:19:52.510 --> 00:19:53.760
only OAuth 2.0.

00:19:58.960 --> 00:20:02.270
And [INAUDIBLE] to describe the
service methods, this is

00:20:02.270 --> 00:20:03.040
just by the book.

00:20:03.040 --> 00:20:05.100
It's not particular to
the YouTube API.

00:20:05.100 --> 00:20:08.120
Any RESTful API would
do the same.

00:20:08.120 --> 00:20:11.935
We only support list, insert,
update, and delete.

00:20:11.935 --> 00:20:13.435
First one is a read.

00:20:13.435 --> 00:20:17.230
The last one is a write.

00:20:17.230 --> 00:20:22.600
And the syntax is dictated by
HTTP in the RESTful APIs.

00:20:22.600 --> 00:20:26.030
So in order to do a list, you
have to do a HTTP GET call.

00:20:26.030 --> 00:20:29.940
In order to do an insert, you
have to do an HTTP POST call,

00:20:29.940 --> 00:20:32.550
HTTP PUT for update,
and HTTP DELETE

00:20:32.550 --> 00:20:37.680
for deleting a resource.

00:20:37.680 --> 00:20:42.560
So in the RESTful APIs, the verb
of the HTTP request gives

00:20:42.560 --> 00:20:45.340
you the method that is
going to be invoked

00:20:45.340 --> 00:20:47.674
on the server side.

00:20:47.674 --> 00:20:53.070
The URL is going to give you the
rest of the signature of

00:20:53.070 --> 00:20:54.690
the method that is
being invoked--

00:20:54.690 --> 00:20:57.250
that is being called.

00:20:57.250 --> 00:21:01.640
In the case of inserts and
updates, so POST and PUT,

00:21:01.640 --> 00:21:06.210
there has to be a request body
that contains the resource

00:21:06.210 --> 00:21:09.110
that is being affected
by the write.

00:21:09.110 --> 00:21:11.580
So in the case of insert, it's
going to contain a resource

00:21:11.580 --> 00:21:15.620
that is being created, or the
metadata on the video that is

00:21:15.620 --> 00:21:17.490
being uploaded, for instance.

00:21:17.490 --> 00:21:21.670
In the case of update, it's
the resource that is being

00:21:21.670 --> 00:21:25.260
altered, so the new title that
you want to set on a video,

00:21:25.260 --> 00:21:25.847
for instance.

00:21:25.847 --> 00:21:27.715
AUDIENCE: Is that [INAUDIBLE]

00:21:27.715 --> 00:21:29.590
ID in the update?

00:21:29.590 --> 00:21:31.170
RAUL FURNICA: Good question.

00:21:31.170 --> 00:21:37.170
So we noticed in version
2 that the [INAUDIBLE]

00:21:37.170 --> 00:21:42.220
between the specification in URL
and the data coming in a

00:21:42.220 --> 00:21:44.280
request body.

00:21:44.280 --> 00:21:48.710
So in version 2, we had this
issue where, in inserts, the

00:21:48.710 --> 00:21:51.620
ID was in the request method
as well as in the

00:21:51.620 --> 00:21:53.740
URL and in the body.

00:21:53.740 --> 00:21:56.070
And what do we do when in
conflict, like when you're

00:21:56.070 --> 00:22:00.142
telling us in the body that you
want to update video ID x,

00:22:00.142 --> 00:22:03.850
but in a request parameter,
you say you y?

00:22:03.850 --> 00:22:06.010
So in that case, we've have
to reject the request.

00:22:06.010 --> 00:22:08.330
So we just want to make it
simple and reduce that

00:22:08.330 --> 00:22:09.730
duplication.

00:22:09.730 --> 00:22:13.900
So the POST actually has always
been clear, because you

00:22:13.900 --> 00:22:18.550
don't have the ID part to
create, but the edit is really

00:22:18.550 --> 00:22:19.900
where the question is.

00:22:19.900 --> 00:22:23.020
The PUT would contain the
resource ID in the resource

00:22:23.020 --> 00:22:24.280
you're editing.

00:22:24.280 --> 00:22:26.490
And actually, that
[INAUDIBLE].

00:22:26.490 --> 00:22:30.600
And that allows us to even go
further and edit multiple

00:22:30.600 --> 00:22:31.850
resources at the same time.

00:22:36.130 --> 00:22:38.813
The DELETE, however, because
it's a simple call, and

00:22:38.813 --> 00:22:41.775
because the request is in the
body, and we actually, as much

00:22:41.775 --> 00:22:44.140
as we want to leave that out.

00:22:44.140 --> 00:22:47.800
So it's hard to put a body in
the request, [INAUDIBLE].

00:22:47.800 --> 00:22:51.212
So for the DELETE, we're taking
the ID and the URL.

00:22:56.030 --> 00:22:59.150
And another particular thing
that the YouTube API did that

00:22:59.150 --> 00:23:02.310
is not necessarily specific to
all RESTful APIs-- yeah?

00:23:02.310 --> 00:23:03.774
AUDIENCE: Do you [INAUDIBLE]?

00:23:17.460 --> 00:23:19.295
RAUL FURNICA: The question
was, is there a symmetry

00:23:19.295 --> 00:23:22.040
between the five types
of methods and--

00:23:22.040 --> 00:23:24.750
AUDIENCE: No, the symmetry
between-- so [INAUDIBLE].

00:23:30.930 --> 00:23:34.490
RAUL FURNICA: So the GET URL
looks very similar to what--

00:23:34.490 --> 00:23:35.740
AUDIENCE: The parameter
[INAUDIBLE].

00:23:44.355 --> 00:23:47.039
RAUL FURNICA: Ah, I
see what you mean.

00:23:47.039 --> 00:23:51.210
So we don't support
the exact same

00:23:51.210 --> 00:23:54.400
parameters on list and delete.

00:23:54.400 --> 00:23:57.510
But we try to for as
much as we can.

00:23:57.510 --> 00:24:02.230
So by the bulk deletes, which
would be if you delete

00:24:02.230 --> 00:24:05.030
something by author, you would
delete everything, it's

00:24:05.030 --> 00:24:06.490
something we're looking into.

00:24:06.490 --> 00:24:08.240
We don't have it
yet right now.

00:24:08.240 --> 00:24:12.030
But it's a big question if we
want it, because it's super

00:24:12.030 --> 00:24:15.040
powerful, but in the same time,
it's super damaging if

00:24:15.040 --> 00:24:16.900
you do it by mistake.

00:24:16.900 --> 00:24:21.480
So it's a balance there that
we haven't yet drilled on

00:24:21.480 --> 00:24:22.730
where we want to support.

00:24:28.470 --> 00:24:33.940
So filters-- it's a new concept
in the YouTube API.

00:24:33.940 --> 00:24:36.170
They're applied to lists,
in particular.

00:24:36.170 --> 00:24:41.150
And what we're trying to say is
that every single list, if

00:24:41.150 --> 00:24:45.280
it's unfiltered, it's supposed
to return the entire index

00:24:45.280 --> 00:24:45.730
YouTube has.

00:24:45.730 --> 00:24:51.220
So if you're doing list videos,
supposedly we're being

00:24:51.220 --> 00:24:54.485
asked to return the entire
index of all videos ever

00:24:54.485 --> 00:24:59.120
YouTube had in one request,
in one response,

00:24:59.120 --> 00:25:01.310
which is not feasible.

00:25:01.310 --> 00:25:07.540
So in order to cope with that
and to basically give people a

00:25:07.540 --> 00:25:11.313
clear notion of what it can do
to filter, to narrow down the

00:25:11.313 --> 00:25:16.590
number of results a particular
API method will affect, we

00:25:16.590 --> 00:25:19.210
added a particular process
called Filter.

00:25:19.210 --> 00:25:23.910
So every single YouTube API list
request has to specify at

00:25:23.910 --> 00:25:27.150
least one filter, and actually
at most one filter, too.

00:25:27.150 --> 00:25:29.350
So you cannot combine filters.

00:25:29.350 --> 00:25:33.420
But there can be extra
parameters that define how the

00:25:33.420 --> 00:25:36.455
filter works.

00:25:36.455 --> 00:25:40.580
A couple of filters that I want
to talk about, one of

00:25:40.580 --> 00:25:44.140
them-- the most important
one-- is the ID filter.

00:25:44.140 --> 00:25:46.845
And we took it a bit further
in just allowing you to

00:25:46.845 --> 00:25:48.400
retrieve a single
resource by ID.

00:25:48.400 --> 00:25:50.790
We allow you to retrieve any
number of resources you want

00:25:50.790 --> 00:25:51.750
by [INAUDIBLE]

00:25:51.750 --> 00:25:52.130
number.

00:25:52.130 --> 00:25:55.640
We actually have a high limit
of 50 that we support.

00:25:55.640 --> 00:26:00.430
But it's a comma-separated list
of IDs that you can put

00:26:00.430 --> 00:26:02.880
in the ID parameter.

00:26:02.880 --> 00:26:05.650
And that matches, from the
entire collection, only those

00:26:05.650 --> 00:26:09.050
resources that have that
ID, for instance.

00:26:09.050 --> 00:26:12.571
Another filter that maybe is a
lot more interesting to see

00:26:12.571 --> 00:26:13.650
are the playlistitems.

00:26:13.650 --> 00:26:19.070
Playlistitems is the collection
of all entries in a

00:26:19.070 --> 00:26:20.290
playlist, if you want.

00:26:20.290 --> 00:26:22.880
So not all playlists.

00:26:22.880 --> 00:26:25.230
So there are playlists, and then
there are entries inside

00:26:25.230 --> 00:26:27.346
a playlist, videos inside
a playlist.

00:26:27.346 --> 00:26:32.100
So that's playlistitems,
if that makes sense.

00:26:32.100 --> 00:26:32.300
OK?

00:26:32.300 --> 00:26:34.480
All right.

00:26:34.480 --> 00:26:37.480
So that was you can filter by
a particular playlist ID.

00:26:37.480 --> 00:26:41.410
So the code there is exactly,
give me all the

00:26:41.410 --> 00:26:42.540
videos in this playlist.

00:26:42.540 --> 00:26:45.130
And that's the filter
playlist ID.

00:26:45.130 --> 00:26:50.960
And for search, of course, you
have filter by textual

00:26:50.960 --> 00:26:54.841
keywords that you want to
match when you return.

00:26:54.841 --> 00:26:59.220
And there is a particular one,
the mine filter, that just

00:26:59.220 --> 00:27:01.850
returns data that belongs to
the [? character of the ?]

00:27:01.850 --> 00:27:03.320
user.

00:27:03.320 --> 00:27:05.800
So whatever you uploaded,
whatever you

00:27:05.800 --> 00:27:08.060
created is in a playlist.

00:27:12.360 --> 00:27:18.300
And on changing the behavior of
a particular filter, I have

00:27:18.300 --> 00:27:22.276
here an example where you search
for a particular term,

00:27:22.276 --> 00:27:25.870
like APIs, and you want to
change the order in which the

00:27:25.870 --> 00:27:26.780
results are returned.

00:27:26.780 --> 00:27:28.780
So then there is an extra
parameter, which is not a

00:27:28.780 --> 00:27:32.140
filter, but it's just a normal
parameter that affects how the

00:27:32.140 --> 00:27:33.310
response actually looks like.

00:27:33.310 --> 00:27:35.670
And that's the order
it was rated.

00:27:35.670 --> 00:27:39.508
So you want to sort
them by rating.

00:27:39.508 --> 00:27:40.430
AUDIENCE: What--

00:27:40.430 --> 00:27:40.810
RAUL FURNICA: Yeah?

00:27:40.810 --> 00:27:42.410
AUDIENCE: --about page number?

00:27:42.410 --> 00:27:43.160
RAUL FURNICA: How about?

00:27:43.160 --> 00:27:44.920
AUDIENCE: Page number.

00:27:44.920 --> 00:27:45.980
Page.

00:27:45.980 --> 00:27:46.600
RAUL FURNICA: Page number?

00:27:46.600 --> 00:27:49.033
AUDIENCE: Yeah, if I only
want a certain--

00:27:49.033 --> 00:27:53.180
RAUL FURNICA: I'm going to talk
about that in two slides,

00:27:53.180 --> 00:27:54.530
If I Remember right.

00:27:58.000 --> 00:28:03.360
So all services in YouTube API
define to particular filters--

00:28:03.360 --> 00:28:06.190
the ID filter, which allows
us to return one or more

00:28:06.190 --> 00:28:08.140
resources by ID, and
the mine filter.

00:28:08.140 --> 00:28:11.500
The mine filter is an
interesting one, because it

00:28:11.500 --> 00:28:14.875
actually requires you to fire
an authenticator request.

00:28:14.875 --> 00:28:17.480
So if you're trying to use the
mine filter, but you're not

00:28:17.480 --> 00:28:21.140
authenticated as a user, then it
doesn't really make sense.

00:28:21.140 --> 00:28:27.250
So you don't really have
anything as a public API call.

00:28:27.250 --> 00:28:32.550
And also, it allows you to build
an app that manages the

00:28:32.550 --> 00:28:37.541
user's account if you want, or
just adding those features to

00:28:37.541 --> 00:28:39.228
an app that already exists.

00:28:42.120 --> 00:28:44.040
And let's talk about paging.

00:28:44.040 --> 00:28:46.130
As I said, in two slides.

00:28:46.130 --> 00:28:50.930
So paging is the other option
you have to reduce the number

00:28:50.930 --> 00:28:53.211
of resources that will
be returned on

00:28:53.211 --> 00:28:55.996
a particular request.

00:28:55.996 --> 00:28:59.216
And in v3, we have
changed paging.

00:28:59.216 --> 00:29:02.320
And this is a big change
versus v2.

00:29:02.320 --> 00:29:04.710
In v2, the paging was indexed.

00:29:04.710 --> 00:29:10.314
So you would only say, start
index 25, num results five.

00:29:10.314 --> 00:29:12.030
You have a question?

00:29:12.030 --> 00:29:13.880
OK.

00:29:13.880 --> 00:29:19.610
So that meant for us that we had
to return, from the 25th

00:29:19.610 --> 00:29:23.400
resource that matched,
five resources.

00:29:23.400 --> 00:29:27.690
And in v3, we're using
token-based paging.

00:29:27.690 --> 00:29:31.220
The reason for that is that we
get more flexibility to both

00:29:31.220 --> 00:29:34.900
give you consistent paging-- so
if the collection changed

00:29:34.900 --> 00:29:39.280
since you first requested the
previous page, you would

00:29:39.280 --> 00:29:41.906
actually either see duplicates,
like resources

00:29:41.906 --> 00:29:44.960
that you saw in the previous
page [INAUDIBLE], because you

00:29:44.960 --> 00:29:48.080
can actually tell when you
actually did that request.

00:29:48.080 --> 00:29:51.770
Tokens allow us to do a much
better job at that.

00:29:51.770 --> 00:29:55.030
That doesn't mean we're doing
it on all requests yet, but

00:29:55.030 --> 00:29:58.020
that's where we want to be.

00:29:58.020 --> 00:30:01.100
And the way it works is that
on every response,

00:30:01.100 --> 00:30:03.880
you have a page info.

00:30:03.880 --> 00:30:06.320
So it tells you what are the
total number of resources that

00:30:06.320 --> 00:30:08.500
matched your filter.

00:30:08.500 --> 00:30:12.246
And it tells you how many
results per page we have

00:30:12.246 --> 00:30:15.960
returned, which is always
identical to the parameter you

00:30:15.960 --> 00:30:19.470
sent over that says
maxResults=10 or whatever.

00:30:19.470 --> 00:30:22.430
The default is five right
now [INAUDIBLE].

00:30:25.250 --> 00:30:27.840
And we also give you the next
page token and the previous

00:30:27.840 --> 00:30:32.022
page token, so for navigating
back and forth.

00:30:32.022 --> 00:30:34.480
That's the token you would
use in the page

00:30:34.480 --> 00:30:36.700
token for your parameter.

00:30:36.700 --> 00:30:43.160
And that would retrieve this
particular page now.

00:30:43.160 --> 00:30:45.460
So in that sense, the API
interface simplifies

00:30:45.460 --> 00:30:48.510
a lot, if you want.

00:30:48.510 --> 00:30:52.517
It's not as powerful as index
paging, in the sense that it

00:30:52.517 --> 00:30:54.795
doesn't allow you to skip pages
and go to the particular

00:30:54.795 --> 00:30:56.455
page that you want directly.

00:30:56.455 --> 00:30:59.250
This only allows you
to go page by page.

00:30:59.250 --> 00:31:01.000
AUDIENCE: So the PageToken,
I need to get

00:31:01.000 --> 00:31:02.350
that from the response.

00:31:02.350 --> 00:31:03.350
RAUL FURNICA: Yeah.

00:31:03.350 --> 00:31:05.744
So you can't just
skip 10 pages.

00:31:05.744 --> 00:31:06.640
AUDIENCE: Oh, bummer.

00:31:06.640 --> 00:31:09.160
RAUL FURNICA: Yeah, that's the
difference between the index

00:31:09.160 --> 00:31:10.580
paging and the token paging.

00:31:10.580 --> 00:31:13.654
AUDIENCE: Are you going
to [INAUDIBLE]?

00:31:13.654 --> 00:31:19.360
RAUL FURNICA: If there is a big
use case, if it's a big

00:31:19.360 --> 00:31:21.140
feature request to have that,
we will look into it.

00:31:21.140 --> 00:31:26.616
But right now, we're just
happy with it so far.

00:31:26.616 --> 00:31:28.548
AUDIENCE: Right on.

00:31:28.548 --> 00:31:30.480
AUDIENCE: Could you
repeat questions?

00:31:30.480 --> 00:31:31.010
RAUL FURNICA: OK.

00:31:31.010 --> 00:31:35.080
So the question is, in fact, are
we going to add a way to

00:31:35.080 --> 00:31:36.500
skip pages?

00:31:36.500 --> 00:31:39.470
And the answer so far is that
we don't have that.

00:31:39.470 --> 00:31:43.400
But if it turns to be a very
important use case to support,

00:31:43.400 --> 00:31:46.736
then we would add it.

00:31:46.736 --> 00:31:49.070
But basically, your feedback.

00:31:49.070 --> 00:31:51.345
AUDIENCE: I would say,
just use numbers.

00:31:51.345 --> 00:31:53.810
[INAUDIBLE].

00:31:53.810 --> 00:31:56.095
RAUL FURNICA: That would be back
to index paging, which is

00:31:56.095 --> 00:31:59.882
the one we actually think it's
inferior in design to

00:31:59.882 --> 00:32:01.750
this one right now.

00:32:01.750 --> 00:32:05.460
But because of the problems
I mentioned, you get

00:32:05.460 --> 00:32:09.755
duplication, because the
collection changes in the time

00:32:09.755 --> 00:32:11.210
you're browsing it.

00:32:11.210 --> 00:32:14.070
And we can do much better with
this, because the token

00:32:14.070 --> 00:32:17.330
actually catches the
type of time--

00:32:17.330 --> 00:32:17.970
AUDIENCE: It changes.

00:32:17.970 --> 00:32:18.785
RAUL FURNICA: Yeah.

00:32:18.785 --> 00:32:19.230
AUDIENCE: [INAUDIBLE].

00:32:19.230 --> 00:32:21.460
RAUL FURNICA: Yeah.

00:32:21.460 --> 00:32:24.985
So it can give you consistent
browsing with tokens.

00:32:24.985 --> 00:32:27.182
AUDIENCE: So [INAUDIBLE].

00:32:36.490 --> 00:32:39.550
RAUL FURNICA: Yeah, we token--
so the question is, if the

00:32:39.550 --> 00:32:43.700
data behind changes while you're
browsing a collection,

00:32:43.700 --> 00:32:46.056
what's the intended behavior?

00:32:46.056 --> 00:32:48.660
So the intended behavior is
really that you're not

00:32:48.660 --> 00:32:50.140
affected by that.

00:32:50.140 --> 00:32:53.600
And your review of the
collection stays consistent,

00:32:53.600 --> 00:32:55.616
even though the data
behind it changes.

00:32:59.020 --> 00:33:01.658
AUDIENCE: Are there special
values for the tokens when

00:33:01.658 --> 00:33:05.650
you're-- begin and
end of the list?

00:33:05.650 --> 00:33:09.852
RAUL FURNICA: Are there special
values for the token

00:33:09.852 --> 00:33:11.402
at the beginning of the list
or at the end of the list?

00:33:14.050 --> 00:33:16.040
Beginning of the list
is marked by an

00:33:16.040 --> 00:33:17.370
[? absence of the ?] token.

00:33:17.370 --> 00:33:20.510
So that's 0.

00:33:20.510 --> 00:33:26.425
End of the list is not something
we're super strong

00:33:26.425 --> 00:33:30.160
on, because the more
it grows, the less

00:33:30.160 --> 00:33:32.540
we think it's relevant.

00:33:32.540 --> 00:33:35.280
Like in search, for instance,
it's not relevant to go to the

00:33:35.280 --> 00:33:38.410
millionth response.

00:33:38.410 --> 00:33:42.290
But to tell-- if it's a finite
collection, like the items in

00:33:42.290 --> 00:33:47.490
a playlist, then you know you
reached t end because you'll

00:33:47.490 --> 00:33:50.320
never have a next-page token.

00:33:50.320 --> 00:33:52.560
And you also know by the
total results how

00:33:52.560 --> 00:33:55.222
many are in that place.

00:33:55.222 --> 00:33:58.827
So you don't have a number
directly from

00:33:58.827 --> 00:34:00.842
the very first request.

00:34:00.842 --> 00:34:03.728
AUDIENCE: What happens if
a video is deleted?

00:34:03.728 --> 00:34:05.652
[INAUDIBLE].

00:34:05.652 --> 00:34:11.659
RAUL FURNICA: If a video is
deleted, you're going to see

00:34:11.659 --> 00:34:13.760
some metadata about
that video.

00:34:13.760 --> 00:34:16.710
But of course, you cannot play
back the video anymore.

00:34:16.710 --> 00:34:22.320
So it's like with any web
reference, if you want.

00:34:22.320 --> 00:34:25.520
You still have the link on a
page about another page that

00:34:25.520 --> 00:34:26.200
was deleted.

00:34:26.200 --> 00:34:29.230
But once you try to access it,
you can't get anything.

00:34:29.230 --> 00:34:30.330
So it's the same thing.

00:34:30.330 --> 00:34:32.280
You get the reference
to the video.

00:34:32.280 --> 00:34:34.480
You still get the ID.

00:34:34.480 --> 00:34:36.460
You might still get
some metadata.

00:34:36.460 --> 00:34:40.270
But you will not be able
to view the video.

00:34:40.270 --> 00:34:42.620
AUDIENCE: There wouldn't be
any metadata in that, say,

00:34:42.620 --> 00:34:45.449
[INAUDIBLE]?

00:34:45.449 --> 00:34:47.400
RAUL FURNICA: There is some
metadata that is being

00:34:47.400 --> 00:34:47.789
referenced.

00:34:47.789 --> 00:34:50.860
So for instance, that's true for
the YouTube website, too.

00:34:50.860 --> 00:34:54.179
So if you have a video on your
playlist that you don't own,

00:34:54.179 --> 00:34:58.470
somebody else owns, and that
particular person deletes it,

00:34:58.470 --> 00:35:01.390
you still see some metadata
about that video.

00:35:01.390 --> 00:35:05.430
And the reason for that is
because we need to allow

00:35:05.430 --> 00:35:07.540
people to manage their
playlists.

00:35:07.540 --> 00:35:10.440
So they need to see that that
video is not available anymore

00:35:10.440 --> 00:35:13.382
and then delete the playlist
item and create something or

00:35:13.382 --> 00:35:16.890
replace it with something
else.

00:35:16.890 --> 00:35:22.210
And also, we don't want to get
into the behavior that we

00:35:22.210 --> 00:35:25.150
randomly remove stuff from
people's playlists, and then

00:35:25.150 --> 00:35:26.400
they don't know what's
happening.

00:35:37.020 --> 00:35:41.710
I've already talked a bit about
the response format,

00:35:41.710 --> 00:35:43.860
mainly the default
format is JSON.

00:35:43.860 --> 00:35:46.800
And almost everybody is familiar
with JSON by now,

00:35:46.800 --> 00:35:50.550
which is one of the big reasons
why we incremented the

00:35:50.550 --> 00:35:56.020
major version of YouTube API, to
switch Atom/XML to JSON and

00:35:56.020 --> 00:35:58.753
more modern standards and
response formats.

00:35:58.753 --> 00:35:59.620
It's lightweight.

00:35:59.620 --> 00:36:00.370
It's easy.

00:36:00.370 --> 00:36:01.665
It's a textual format.

00:36:01.665 --> 00:36:03.130
It's easy to debug.

00:36:03.130 --> 00:36:04.470
Everybody understands it.

00:36:04.470 --> 00:36:06.892
It's human-readable, it's
machine-readable.

00:36:06.892 --> 00:36:11.036
It's a lot more compact
than XML and Atom.

00:36:11.036 --> 00:36:13.500
And it is a different
format, as I said.

00:36:13.500 --> 00:36:18.580
But we're actually thinking
that if people care about

00:36:18.580 --> 00:36:20.920
bandwidth, we can do even
better than that.

00:36:20.920 --> 00:36:25.710
So we're working on extended
protocol buffers, which means

00:36:25.710 --> 00:36:29.500
we're allowing people to get
binary serialization from us,

00:36:29.500 --> 00:36:31.402
which are much more effective
in terms of

00:36:31.402 --> 00:36:33.760
bandwidth, even in JSON.

00:36:33.760 --> 00:36:38.100
And it is the most efficient
version, but it's also a power

00:36:38.100 --> 00:36:38.550
user feature.

00:36:38.550 --> 00:36:42.370
So not everybody's going to
use it, I'm pretty sure.

00:36:42.370 --> 00:36:46.054
But if bandwidth is really
important, then people are

00:36:46.054 --> 00:36:49.100
going to use it, I think.

00:36:49.100 --> 00:36:50.220
AUDIENCE: Just curious,
are you still

00:36:50.220 --> 00:36:52.210
going to support XML?

00:36:52.210 --> 00:36:53.580
RAUL FURNICA: No.

00:36:53.580 --> 00:36:55.580
The question was, are we still
going to support XML?

00:36:55.580 --> 00:36:57.430
The answer is no.

00:37:01.100 --> 00:37:06.030
With the new version comes a
fresh set of client libraries,

00:37:06.030 --> 00:37:07.280
which actually are
really awesome.

00:37:07.280 --> 00:37:09.750
And you can try them all.

00:37:09.750 --> 00:37:12.614
And I have the link, as well,
on the last slide, and I'm

00:37:12.614 --> 00:37:15.580
going to leave the last
slide up for a while.

00:37:15.580 --> 00:37:18.950
I'm going to send the slides
around, as well.

00:37:18.950 --> 00:37:23.864
But we just support a lot of
languages now, compared to v2.

00:37:23.864 --> 00:37:26.395
The advantage is that, since
we're building on the same

00:37:26.395 --> 00:37:29.960
technology stack as every other
Google API, we get to

00:37:29.960 --> 00:37:32.930
the client library support
almost for free.

00:37:32.930 --> 00:37:34.110
That's good for us.

00:37:34.110 --> 00:37:35.420
It's good for you, as well.

00:37:35.420 --> 00:37:39.900
So we're having .NET, Dart,
even a Google Web Toolkit

00:37:39.900 --> 00:37:44.280
extension, Java, JavaScript,
Objective-C, PHP, Python, and

00:37:44.280 --> 00:37:46.920
Ruby at this point.

00:37:46.920 --> 00:37:52.140
And anything that, depends on
how many people are going to

00:37:52.140 --> 00:37:54.270
use it, we're going to
add to this list.

00:38:00.380 --> 00:38:03.940
So this slide, I don't know if
I've introduced [INAUDIBLE]

00:38:03.940 --> 00:38:04.260
before.

00:38:04.260 --> 00:38:05.170
Or maybe you know.

00:38:05.170 --> 00:38:06.520
Everybody knows [INAUDIBLE].

00:38:06.520 --> 00:38:10.790
So he's been an awesome
dev advocate.

00:38:10.790 --> 00:38:14.780
And he was complaining when I
was building the slides that

00:38:14.780 --> 00:38:17.170
they're kind of dry and we need
some personal information

00:38:17.170 --> 00:38:18.270
about you and all that.

00:38:18.270 --> 00:38:21.280
So I already told you I'm from
Switzerland and all that.

00:38:21.280 --> 00:38:22.145
So this is about me.

00:38:22.145 --> 00:38:24.826
We need a break from all the
technical stuff, so let's

00:38:24.826 --> 00:38:26.076
check it out.

00:38:28.290 --> 00:38:31.760
So that's it.

00:38:31.760 --> 00:38:37.116
So that was my first snowboard
jump ever, last year, and the

00:38:37.116 --> 00:38:38.410
last one I did.

00:38:38.410 --> 00:38:41.460
But basically, the final thing
I want to say is that I like

00:38:41.460 --> 00:38:45.180
my extreme programming as I like
my extreme sports, which

00:38:45.180 --> 00:38:46.870
means cowardly safe.

00:38:46.870 --> 00:38:49.335
Which is good for you, I
think, because I'm not

00:38:49.335 --> 00:38:52.490
breaking the API every
month or every week.

00:38:52.490 --> 00:38:57.900
But it's kind of like my
philosophy in a sense, or what

00:38:57.900 --> 00:39:02.390
I've come to learn in a very
painful way, I might say, with

00:39:02.390 --> 00:39:05.720
the recent app that we broke,
or we took back.

00:39:05.720 --> 00:39:08.080
And it's like, work on
the API team can be

00:39:08.080 --> 00:39:09.680
very back and forth.

00:39:09.680 --> 00:39:13.310
So you want to evolve the API,
and you want to do cool stuff,

00:39:13.310 --> 00:39:14.480
but then you launch it,
and stuff breaks.

00:39:14.480 --> 00:39:17.090
And then you have to take it
back, and you have to figure

00:39:17.090 --> 00:39:19.980
out a way to put it out there
in a way that people can use

00:39:19.980 --> 00:39:22.220
the new cool stuff but
doesn't break the app

00:39:22.220 --> 00:39:23.200
that's already existing.

00:39:23.200 --> 00:39:27.590
And fortunately for everybody,
actually, YouTube API is used

00:39:27.590 --> 00:39:30.570
by our internal apps,
as well, a lot.

00:39:30.570 --> 00:39:35.030
And the Android that we're
having on the Android phone,

00:39:35.030 --> 00:39:37.150
for instance, it's using
the YouTube API.

00:39:37.150 --> 00:39:40.435
So in that sense, it's the same
API we're using, that

00:39:40.435 --> 00:39:41.750
you're using.

00:39:41.750 --> 00:39:45.600
And that's good for everybody,
because first, it catches

00:39:45.600 --> 00:39:47.640
issues very fast for us.

00:39:47.640 --> 00:39:54.650
And second, if you feel like
it's easier for us to ignore

00:39:54.650 --> 00:39:56.695
third-party developers, it's
really hard to ignore

00:39:56.695 --> 00:39:59.666
first-party developers that
come to the desk, and it's

00:39:59.666 --> 00:40:01.481
like, you broke my app.

00:40:01.481 --> 00:40:03.770
So you have to fix it.

00:40:03.770 --> 00:40:07.810
And that's where the cowardly
safe comes from, because we

00:40:07.810 --> 00:40:10.340
did that a couple of times,
and then it's like, OK, we

00:40:10.340 --> 00:40:13.290
need to stop doing this, and I
need to stop waking up at 3:00

00:40:13.290 --> 00:40:17.610
AM for pushes that broke apps.

00:40:17.610 --> 00:40:21.390
And we need to do better.

00:40:21.390 --> 00:40:23.540
And I think we actually have
a very good track.

00:40:23.540 --> 00:40:27.160
Like, v2 has been around
for five years.

00:40:27.160 --> 00:40:30.930
V1 has been around for six years
and is still working.

00:40:30.930 --> 00:40:34.110
So I think we're
kind of there.

00:40:34.110 --> 00:40:37.138
We're doing it.

00:40:37.138 --> 00:40:40.590
So in the next part, which is
the second part of my talk,

00:40:40.590 --> 00:40:43.790
I'm going to talk about design
principles and how we've built

00:40:43.790 --> 00:40:46.780
and thoughts we were thinking
around building v3.

00:40:50.070 --> 00:40:52.670
It may not be very interesting
from a client perspective, but

00:40:52.670 --> 00:40:56.280
it may give you more light on
how APIs are being built and

00:40:56.280 --> 00:40:58.116
what we consider when
we think about it.

00:41:00.900 --> 00:41:03.460
This slide, in particular,
it's not anything

00:41:03.460 --> 00:41:04.910
that I came up with.

00:41:04.910 --> 00:41:14.100
I just went to Wikipedia, and I
took the generic principles

00:41:14.100 --> 00:41:14.930
from there.

00:41:14.930 --> 00:41:19.920
So YouTube API is a
service-oriented architecture.

00:41:19.920 --> 00:41:21.610
And any RESTful API is that.

00:41:21.610 --> 00:41:24.865
So you have services, as I
talked about, and you have

00:41:24.865 --> 00:41:28.790
resources that those
services work on.

00:41:28.790 --> 00:41:33.570
That means that in itself,
it comes with a couple of

00:41:33.570 --> 00:41:36.015
principles, that I list here.

00:41:36.015 --> 00:41:40.266
So you have a particular
contract for each service.

00:41:40.266 --> 00:41:43.243
People that have to know what
that service does in order to

00:41:43.243 --> 00:41:45.280
be able to use it.

00:41:45.280 --> 00:41:46.990
You have loose coupling.

00:41:46.990 --> 00:41:52.030
So the two different services
shouldn't do the same thing.

00:41:52.030 --> 00:41:59.897
The more things you have that
are similar or do kind of like

00:41:59.897 --> 00:42:02.030
the same thing, the more
confusing it is in an API.

00:42:02.030 --> 00:42:05.650
So you want to keep
that to a minimum.

00:42:05.650 --> 00:42:08.240
The service is an abstraction,
so it doesn't tell you about

00:42:08.240 --> 00:42:10.190
the back ends or the logic
that's behind it.

00:42:10.190 --> 00:42:11.900
It just tells you, this
is what I do.

00:42:11.900 --> 00:42:14.426
I don't need to understand
what's behind it.

00:42:14.426 --> 00:42:19.590
And that makes it easy
to use the API.

00:42:19.590 --> 00:42:21.640
The service is also usable.

00:42:21.640 --> 00:42:26.300
So instead of coming up with new
things all the time, you

00:42:26.300 --> 00:42:30.500
should find out ways to reuse
existing services.

00:42:30.500 --> 00:42:34.140
So we always have the choice of
writing new services, but

00:42:34.140 --> 00:42:37.330
the first question has to be,
do we have already a service

00:42:37.330 --> 00:42:40.510
that does this?

00:42:40.510 --> 00:42:42.520
Services are autonomous,
so they work

00:42:42.520 --> 00:42:44.170
independent of each other.

00:42:44.170 --> 00:42:46.416
They are stateless.

00:42:46.416 --> 00:42:50.390
That's almost all
web services.

00:42:50.390 --> 00:42:57.475
They have a schema that can be
read at runtime, so there is

00:42:57.475 --> 00:43:00.670
discoverability And they're
composable, in the sense that

00:43:00.670 --> 00:43:04.060
one service can work with
the other, and so on.

00:43:04.060 --> 00:43:10.150
And in particular for RESTful,
we care about scalability and

00:43:10.150 --> 00:43:11.210
interfaces.

00:43:11.210 --> 00:43:18.040
But to go a bit into depth with
this concept, so what

00:43:18.040 --> 00:43:21.770
have we done in particular for
the YouTube API v3, related to

00:43:21.770 --> 00:43:23.840
those principles?

00:43:23.840 --> 00:43:29.220
So the contract of the service
and the discoverability, it's

00:43:29.220 --> 00:43:36.190
done via the discovery service
that all Google has.

00:43:36.190 --> 00:43:39.130
So any single Google API right
now that is served on

00:43:39.130 --> 00:43:43.315
googleapis.com, you can go
to the Discovery Service.

00:43:43.315 --> 00:43:44.580
It's that link over there,
developers.googl

00:43:44.580 --> 00:43:49.770
e.com/discovery, and then you
can download the schema of

00:43:49.770 --> 00:43:52.700
that service and find out what
are the parameters that every

00:43:52.700 --> 00:43:57.028
method takes, what are all the
methods [INAUDIBLE] and so on.

00:43:57.028 --> 00:44:01.590
Our own client libraries are
using this document to build

00:44:01.590 --> 00:44:03.410
their data model.

00:44:03.410 --> 00:44:08.740
And also, it's something you
can analyze to do any API

00:44:08.740 --> 00:44:11.086
reflection that you
might need.

00:44:11.086 --> 00:44:16.660
Or if you're building tools,
like ID extensions for

00:44:16.660 --> 00:44:19.490
particular products or
APIs, then you can

00:44:19.490 --> 00:44:21.352
integrate with that.

00:44:21.352 --> 00:44:24.830
That also contains documentation
and so on for

00:44:24.830 --> 00:44:26.392
particular features.

00:44:26.392 --> 00:44:28.010
This is a big new thing.

00:44:28.010 --> 00:44:29.855
We didn't have anything
like this in v2.

00:44:35.220 --> 00:44:35.701
AUDIENCE: Question.

00:44:35.701 --> 00:44:36.182
RAUL FURNICA: Yes?

00:44:36.182 --> 00:44:37.625
AUDIENCE: So if you have
discovery, are we going to

00:44:37.625 --> 00:44:42.250
have something like the
interface definition language?

00:44:42.250 --> 00:44:47.220
Like in XML, [INAUDIBLE],
there is a way still to

00:44:47.220 --> 00:44:51.000
describe what the service is.

00:44:51.000 --> 00:44:54.850
RAUL FURNICA: So we're using
the JSON schema for that.

00:44:54.850 --> 00:44:58.336
The question is, if we have
discovery, are we going to

00:44:58.336 --> 00:45:03.100
have an idea, or an XML
description language that the

00:45:03.100 --> 00:45:05.430
discovery document
is written in?

00:45:05.430 --> 00:45:09.020
And the answer is that,
basically, we use JSON schema.

00:45:09.020 --> 00:45:12.570
We checked out at
json-schema.org, I think.

00:45:12.570 --> 00:45:15.530
And I just pulled it up here so
you can see what a document

00:45:15.530 --> 00:45:17.050
looks like.

00:45:17.050 --> 00:45:25.240
And it's pure JSON that tells
you the name of the inquiry.

00:45:25.240 --> 00:45:29.370
You can see right now, what's
the revision, what is the

00:45:29.370 --> 00:45:31.780
description, what are the
items for [? the API? ?]

00:45:31.780 --> 00:45:36.350
And then if we go into the
actual definition, you're

00:45:36.350 --> 00:45:39.520
going to get authentication
information, [INAUDIBLE]

00:45:39.520 --> 00:45:40.990
authentication [INAUDIBLE]

00:45:40.990 --> 00:45:43.860
API supports.

00:45:43.860 --> 00:45:47.810
And then we get to the schemas,
which tells us every

00:45:47.810 --> 00:45:50.215
single resource, what's the
name of the resource.

00:45:50.215 --> 00:45:53.850
So you have an activity
resource, and then what are

00:45:53.850 --> 00:45:55.020
the fields on that resource.

00:45:55.020 --> 00:46:00.000
So we have an ID, type, a
description, and so on.

00:46:00.000 --> 00:46:07.490
Every single field
is described with

00:46:07.490 --> 00:46:09.260
documentation there.

00:46:09.260 --> 00:46:12.120
So the description you see
there is basically the

00:46:12.120 --> 00:46:15.010
documentation of that field.

00:46:15.010 --> 00:46:18.520
And you can read it right here,
or you can add it to a

00:46:18.520 --> 00:46:22.140
client library, or you can use
it to generate a documentation

00:46:22.140 --> 00:46:23.418
document or anything
like that.

00:46:27.270 --> 00:46:29.356
And later on, down in the
documents, you're going to

00:46:29.356 --> 00:46:35.162
find rest of all the methods and
everything else about how

00:46:35.162 --> 00:46:37.625
the API can be used, and then
what are the parameters for

00:46:37.625 --> 00:46:39.914
each method, and so on.

00:46:39.914 --> 00:46:43.558
AUDIENCE: So is this going to be
a standard JSON schema, or

00:46:43.558 --> 00:46:45.878
is this Google-specific?

00:46:45.878 --> 00:46:47.820
RAUL FURNICA: It's a standard
JSON schema.

00:46:47.820 --> 00:46:50.011
We don't do anything
specific here.

00:46:50.011 --> 00:46:55.500
The question was if this is a
web standard, or we're just

00:46:55.500 --> 00:46:56.880
using some Google-specific
tools.

00:47:07.070 --> 00:47:11.963
On to the reusability part, a
good example that I can show

00:47:11.963 --> 00:47:15.800
you right now is the
reused playlists.

00:47:15.800 --> 00:47:22.160
So there are many ways or many
lists of videos that you can

00:47:22.160 --> 00:47:23.750
find on a particular account.

00:47:26.760 --> 00:47:29.060
The first request that
I'm showing here,

00:47:29.060 --> 00:47:31.145
it's fetching my channel.

00:47:31.145 --> 00:47:35.868
So as I'm authenticating as a
particular user, I'm fetching

00:47:35.868 --> 00:47:36.420
my channel.

00:47:36.420 --> 00:47:41.290
And I'm asking for the content
of that channel.

00:47:41.290 --> 00:47:44.416
And in the content of that
channel, there is a field

00:47:44.416 --> 00:47:46.810
called Related Playlists.

00:47:46.810 --> 00:47:49.700
If you look at the field,
it's a map.

00:47:49.700 --> 00:47:52.960
And the names are likes,
favorites, uploads, watch

00:47:52.960 --> 00:47:55.110
history, and watch later.

00:47:55.110 --> 00:47:57.290
They're all features of
YouTube, but in that

00:47:57.290 --> 00:48:01.402
particular playlist
in that sense.

00:48:01.402 --> 00:48:04.510
However, they're all playlist
IDs, and they all can be

00:48:04.510 --> 00:48:09.850
fetched via the playlist
collection or service.

00:48:09.850 --> 00:48:14.470
So in the playlist service, I
can take, into the ID filter,

00:48:14.470 --> 00:48:18.140
all those different IDs, put
them in, and I'm going to get

00:48:18.140 --> 00:48:22.840
playlists and all the content of
the watch history and watch

00:48:22.840 --> 00:48:24.650
later and so on.

00:48:24.650 --> 00:48:28.400
So in that sense, if you have
written on the client tab a

00:48:28.400 --> 00:48:32.550
playlist player, let's say, you
do not need to deal with

00:48:32.550 --> 00:48:36.030
different APIs for the watch
history or the watch later.

00:48:36.030 --> 00:48:41.393
You can just feed the same data
to that playlist player,

00:48:41.393 --> 00:48:45.260
and it's going to be able to
play back through that.

00:48:45.260 --> 00:48:49.682
So any video list is, in
that sense, a playlist.

00:48:49.682 --> 00:48:52.180
We could have went the way that
we had different services

00:48:52.180 --> 00:48:56.690
and different collections for
it, but reusability, it's a

00:48:56.690 --> 00:49:03.210
big principle that we
care about in v3.

00:49:03.210 --> 00:49:06.846
Autonomy is the other big one,
which kind of has a good side

00:49:06.846 --> 00:49:10.500
of the coin and a bad
side of the coin.

00:49:10.500 --> 00:49:11.750
It's no perfect [INAUDIBLE].

00:49:14.220 --> 00:49:17.870
And it's also different from
v2, in that from v2, we

00:49:17.870 --> 00:49:21.050
approached this differently.

00:49:21.050 --> 00:49:24.820
So in v3, every single service
operates on one collection

00:49:24.820 --> 00:49:27.570
only, and none more.

00:49:27.570 --> 00:49:34.450
So in v2, every single service
could operate on the same

00:49:34.450 --> 00:49:36.410
resource as [INAUDIBLE]
services.

00:49:36.410 --> 00:49:41.935
So we had playlist service,
which contained videos, and we

00:49:41.935 --> 00:49:44.345
had a video service, or an
upload service, that contained

00:49:44.345 --> 00:49:45.770
videos as well.

00:49:45.770 --> 00:49:49.585
In v3, there is only one
playlist where videos are

00:49:49.585 --> 00:49:53.400
being retrieved from, and that's
the video service.

00:49:53.400 --> 00:49:54.960
The playlist service
would never

00:49:54.960 --> 00:49:57.091
inline a video in itself.

00:49:57.091 --> 00:50:01.600
Like, you would have metadata
about the video, but it would

00:50:01.600 --> 00:50:06.920
not be a video in that
sense, if you want.

00:50:06.920 --> 00:50:09.540
It also ties into inheritance
versus composition.

00:50:13.630 --> 00:50:16.905
So resource inlining
is not supported.

00:50:16.905 --> 00:50:22.050
The way to make that better
and not say that we cannot

00:50:22.050 --> 00:50:26.070
retrieve anything about the
link to resource-- for

00:50:26.070 --> 00:50:28.080
instance, in a playlist, you
have various items that are

00:50:28.080 --> 00:50:29.280
about video, right?

00:50:29.280 --> 00:50:33.130
It's that, as I told earlier,
we have a snippet for every

00:50:33.130 --> 00:50:37.430
single resource returning you
get where you can get

00:50:37.430 --> 00:50:41.530
information about that
referenced resource.

00:50:41.530 --> 00:50:43.145
It's not a lot of information.

00:50:43.145 --> 00:50:46.720
And if you need extra
information that only the

00:50:46.720 --> 00:50:49.660
video resource has, you need to
fetch the video in the end.

00:50:49.660 --> 00:50:51.960
But it gives a starting point.

00:50:51.960 --> 00:50:56.000
To give an example of this on
search, which is now actually

00:50:56.000 --> 00:51:01.562
on the slides, but on search,
you can find videos, too.

00:51:01.562 --> 00:51:06.340
However, in search, it's really
important that we

00:51:06.340 --> 00:51:08.840
conserve the bandwidth
and we actually--

00:51:08.840 --> 00:51:11.453
it's not so important that we
have a full video description,

00:51:11.453 --> 00:51:12.812
for instance.

00:51:12.812 --> 00:51:19.340
So the search snippet, it has
also a description field.

00:51:19.340 --> 00:51:22.160
But it's not going to inline the
entire video description

00:51:22.160 --> 00:51:25.100
but just a snippet of the video
description, which makes

00:51:25.100 --> 00:51:27.970
sense, because in search, you
want snippets about the stuff

00:51:27.970 --> 00:51:30.410
you matched.

00:51:30.410 --> 00:51:31.490
So that's the difference,
if you want.

00:51:31.490 --> 00:51:33.250
Search doesn't return videos.

00:51:33.250 --> 00:51:35.550
It returns search results.

00:51:35.550 --> 00:51:37.982
But those talk about videos.

00:51:42.802 --> 00:51:44.750
One other thing to note.

00:51:44.750 --> 00:51:47.240
This is that the ID of a search
result is actually a

00:51:47.240 --> 00:51:48.023
composed ID.

00:51:48.023 --> 00:51:51.490
So it has a kind, which
is the same as the

00:51:51.490 --> 00:51:53.280
type of the API response.

00:51:53.280 --> 00:51:55.680
So that kind could be
video or playlist.

00:51:55.680 --> 00:51:58.810
So you might have matched
the video and playlist.

00:51:58.810 --> 00:52:05.152
And then it has the relevant
field of the video or the

00:52:05.152 --> 00:52:07.460
channel or the playlist that
the field [INAUDIBLE]

00:52:07.460 --> 00:52:09.615
information that you need.

00:52:09.615 --> 00:52:14.110
So it's really both autonomous,
like search can

00:52:14.110 --> 00:52:18.300
function without the video
field, or the video

00:52:18.300 --> 00:52:22.500
collection, and there is
composition there, too.

00:52:22.500 --> 00:52:24.600
So search refers to it.

00:52:27.760 --> 00:52:30.226
And that's the slide here.

00:52:30.226 --> 00:52:33.680
Because I was saying, that's
the reverse of the coin, so

00:52:33.680 --> 00:52:34.885
that's the good part.

00:52:34.885 --> 00:52:37.470
The bad part is that we don't
get the information about a

00:52:37.470 --> 00:52:40.510
video inlined in the
search response.

00:52:40.510 --> 00:52:42.650
And in order to get that, we
need to follow up with a

00:52:42.650 --> 00:52:44.260
second request.

00:52:44.260 --> 00:52:47.445
Now, I talked about
the ID filter.

00:52:47.445 --> 00:52:49.000
The ID filter is what
I would like to call

00:52:49.000 --> 00:52:51.040
the poor man's batch.

00:52:51.040 --> 00:52:52.670
So you can do a batch.

00:52:52.670 --> 00:52:56.245
Literally, you can take a number
of up to 15 video IDs

00:52:56.245 --> 00:52:59.540
and put them in the ID filter
and return them all at once.

00:52:59.540 --> 00:53:04.970
So that means if you're writing
an application, that,

00:53:04.970 --> 00:53:09.440
say, you use to display these
items, and you do a request,

00:53:09.440 --> 00:53:13.430
like one of those two here, that
returns particular items

00:53:13.430 --> 00:53:14.930
in a place.

00:53:14.930 --> 00:53:17.680
And those are videos that you
want to have more data fetched

00:53:17.680 --> 00:53:19.800
about those videos.

00:53:19.800 --> 00:53:21.350
You don't need to follow up.

00:53:21.350 --> 00:53:25.090
Say you retrieve 25 playlist
items, you don't need to

00:53:25.090 --> 00:53:26.735
follow up with 25 requests.

00:53:26.735 --> 00:53:28.970
But you follow up with a see-all
request, where you put

00:53:28.970 --> 00:53:31.105
all 25 videos you
want to return.

00:53:33.680 --> 00:53:38.990
So it's composed, and it's
different [INAUDIBLE]

00:53:38.990 --> 00:53:42.190
services, but we give you tools
to make that easy so you

00:53:42.190 --> 00:53:46.265
don't have to query too much and
batch as much as you can.

00:53:50.340 --> 00:53:56.160
And that would be a bit about
design principles and how we

00:53:56.160 --> 00:53:58.880
applied them to v3.

00:53:58.880 --> 00:54:02.715
Next, I'm going to talk about
migration guide and

00:54:02.715 --> 00:54:05.040
deprecation of v2.

00:54:05.040 --> 00:54:07.360
Is there any particular
question about design

00:54:07.360 --> 00:54:09.190
principles in particular?

00:54:11.748 --> 00:54:13.230
AUDIENCE: It's pretty good.

00:54:13.230 --> 00:54:14.480
RAUL FURNICA: Thank you.

00:54:17.760 --> 00:54:19.260
OK, let's talk about v2.

00:54:19.260 --> 00:54:20.910
I didn't want to talk
much about v2.

00:54:20.910 --> 00:54:26.136
It's like v2 is the past.
v3 is the future.

00:54:26.136 --> 00:54:28.270
We're much more excited
about v3.

00:54:28.270 --> 00:54:30.180
But that doesn't mean that--

00:54:30.180 --> 00:54:36.120
I mean, as I said, we have a
long track of stability in the

00:54:36.120 --> 00:54:39.616
YouTube API, and we don't want
to ruin any of that.

00:54:39.616 --> 00:54:44.575
So don't worry about v2
going away too soon.

00:54:44.575 --> 00:54:47.482
It's going to go away,
but not anytime soon.

00:54:47.482 --> 00:54:52.710
It will be supported at least
until April 2015.

00:54:52.710 --> 00:54:56.790
We will announce you when it's
officially deprecated.

00:54:56.790 --> 00:55:00.370
We didn't deprecate v2 right
now, because we want to add a

00:55:00.370 --> 00:55:03.370
bit more features to v3
before we do that.

00:55:03.370 --> 00:55:06.950
And v3, we're still
working on it.

00:55:06.950 --> 00:55:11.050
And we're adding a lot of
features to help you migrate

00:55:11.050 --> 00:55:14.260
existing apps from v2 to v3.

00:55:14.260 --> 00:55:19.705
Amongst those, we have
user authentication.

00:55:19.705 --> 00:55:24.240
So if you're using OAuth 2.0 in
v2, it's going to work in

00:55:24.240 --> 00:55:27.390
v3, too, kind of like
the same way.

00:55:27.390 --> 00:55:31.510
The scopes in v2 are accepted
in v3 as well.

00:55:31.510 --> 00:55:34.220
The scopes in v3 have
[INAUDIBLE]

00:55:34.220 --> 00:55:34.780
in v2.

00:55:34.780 --> 00:55:39.365
So once you switch fully to
v3, you're just going to

00:55:39.365 --> 00:55:43.410
[INAUDIBLE] there, and you
don't need to fire back

00:55:43.410 --> 00:55:47.320
requests with v2, hopefully.

00:55:47.320 --> 00:55:49.764
Authenticated, in that sense.

00:55:49.764 --> 00:55:51.270
The developer registr--

00:55:51.270 --> 00:55:51.420
sorry.

00:55:51.420 --> 00:55:51.760
Yeah?

00:55:51.760 --> 00:55:52.245
AUDIENCE: Yeah.

00:55:52.245 --> 00:55:55.990
How do you cases where your
developer keys aren't secured

00:55:55.990 --> 00:55:57.240
by [INAUDIBLE]?

00:56:00.220 --> 00:56:04.100
RAUL FURNICA: The question is,
how do we handle cases where

00:56:04.100 --> 00:56:06.120
the developer key can
be [INAUDIBLE]

00:56:06.120 --> 00:56:07.690
from the code, like
in JavaScript?

00:56:10.200 --> 00:56:12.190
There's not a good answer
for it right now.

00:56:12.190 --> 00:56:15.960
So you can put the developer key
in a header, but if it's

00:56:15.960 --> 00:56:17.170
JavaScript, you can always
look at the code

00:56:17.170 --> 00:56:18.870
and see what happens.

00:56:21.842 --> 00:56:24.520
Developer keys aren't sniffable,
in that sense.

00:56:24.520 --> 00:56:27.100
We can't really super-secure
them all the

00:56:27.100 --> 00:56:28.030
time for all cases.

00:56:28.030 --> 00:56:31.385
AUDIENCE: Is there a way to
specify that there's an

00:56:31.385 --> 00:56:34.700
anonymous developer or
something like that?

00:56:34.700 --> 00:56:35.940
RAUL FURNICA: That's another
good question.

00:56:35.940 --> 00:56:39.190
So is there a way to specify
that it's anonymous developer?

00:56:39.190 --> 00:56:43.175
The version 3 doesn't allow
unregistered traffic.

00:56:43.175 --> 00:56:46.050
So in version 3, every single
call you make, you have to

00:56:46.050 --> 00:56:48.800
have a developer key for it.

00:56:48.800 --> 00:56:51.940
So in that sense, there is no
way to do anonymous calls.

00:56:56.545 --> 00:56:59.130
So yeah, there is no good answer
for JavaScript, in

00:56:59.130 --> 00:57:01.030
particular, for [INAUDIBLE]

00:57:01.030 --> 00:57:03.265
or clients.

00:57:03.265 --> 00:57:06.270
There is a way to hide it if you
have a server application,

00:57:06.270 --> 00:57:07.900
and then you put it on
the server and not

00:57:07.900 --> 00:57:09.060
on the client side.

00:57:09.060 --> 00:57:13.130
But that can be harder to
do than it is to stay.

00:57:13.130 --> 00:57:15.900
So we're aware of it,
and we're kind of

00:57:15.900 --> 00:57:16.390
fine with it so far.

00:57:16.390 --> 00:57:18.795
If we find there is a lot of
abuse happening because of

00:57:18.795 --> 00:57:21.686
that, then we're going
to look into it.

00:57:21.686 --> 00:57:24.840
But it's a good question that I
don't have a good answer to.

00:57:28.800 --> 00:57:31.760
And because we're talking about
developer registration

00:57:31.760 --> 00:57:36.980
in particular, if you register
with v3 today, you're going to

00:57:36.980 --> 00:57:40.602
be able to use the same
developer key in

00:57:40.602 --> 00:57:42.780
v3 and v2 as well.

00:57:42.780 --> 00:57:48.380
So the only thing you need to do
if you want to keep firing

00:57:48.380 --> 00:57:52.120
requests against both v2 and v3
for a while, and they have

00:57:52.120 --> 00:57:56.540
a migration in steps, and that
switch on the site is starting

00:57:56.540 --> 00:57:58.590
using v3 developer keys.

00:58:01.320 --> 00:58:03.610
And resource IDs are
interchangeable between the

00:58:03.610 --> 00:58:06.114
two versions of the
API as well.

00:58:11.040 --> 00:58:15.952
Any particular questions
about migration?

00:58:15.952 --> 00:58:16.428
Yeah?

00:58:16.428 --> 00:58:17.678
AUDIENCE: [INAUDIBLE]?

00:58:21.664 --> 00:58:23.928
RAUL FURNICA: I can't
really hear you.

00:58:23.928 --> 00:58:25.178
AUDIENCE: [INAUDIBLE]?

00:58:30.974 --> 00:58:31.650
RAUL FURNICA: [INAUDIBLE].

00:58:31.650 --> 00:58:32.900
AUDIENCE: [INAUDIBLE]?

00:58:38.290 --> 00:58:39.888
RAUL FURNICA: Do you
mean video tags?

00:58:39.888 --> 00:58:40.347
AUDIENCE: Yeah.

00:58:40.347 --> 00:58:41.597
[INAUDIBLE]?

00:58:44.020 --> 00:58:45.090
RAUL FURNICA: It's
a good question.

00:58:45.090 --> 00:58:52.085
So I think back here somewhere,
I was showing the

00:58:52.085 --> 00:58:53.740
video schema.

00:58:53.740 --> 00:58:54.740
Yeah.

00:58:54.740 --> 00:58:58.330
And you actually do have
tags on the schema.

00:58:58.330 --> 00:59:04.850
But recently, YouTube has
removed video tags from read.

00:59:04.850 --> 00:59:06.770
So they're not publicly
accessible.

00:59:06.770 --> 00:59:08.460
However, tags are still
there, and they're

00:59:08.460 --> 00:59:09.710
accessible to the uploader.

00:59:12.110 --> 00:59:15.180
That's a product decision
on the YouTube side.

00:59:15.180 --> 00:59:17.871
On the API side, we don't have
much to say about it, or we

00:59:17.871 --> 00:59:20.950
don't have any particular
reasoning.

00:59:20.950 --> 00:59:23.590
And I think a PM would
be much better

00:59:23.590 --> 00:59:24.060
to answer that question.

00:59:24.060 --> 00:59:26.680
Or maybe do you have
more details?

00:59:26.680 --> 00:59:27.150
PRESENTER: Yeah.

00:59:27.150 --> 00:59:30.850
The answer is, [INAUDIBLE]

00:59:30.850 --> 00:59:33.350
so if you were using
[INAUDIBLE]

00:59:33.350 --> 00:59:38.960
to be talking about a specific
set of [INAUDIBLE], API that

00:59:38.960 --> 00:59:40.701
allows you to do [INAUDIBLE]

00:59:40.701 --> 00:59:47.162
IDs, and then without
the [INAUDIBLE].

00:59:47.162 --> 00:59:47.660
RAUL FURNICA: Yeah.

00:59:47.660 --> 00:59:50.680
So I'm going to talk about
topics a bit later, and I'm

00:59:50.680 --> 00:59:52.456
going to introduce
it for that.

00:59:52.456 --> 00:59:57.350
But this key, [INAUDIBLE]'s
answer was that topics and

00:59:57.350 --> 00:59:58.600
[INAUDIBLE].

01:00:10.430 --> 01:00:14.340
So let's go into the new
features that we had in v3

01:00:14.340 --> 01:00:17.420
that we didn't have in
previous versions.

01:00:17.420 --> 01:00:19.905
I'm going to highlight
two in particular.

01:00:19.905 --> 01:00:22.750
I did more than that,
but I'm not going to

01:00:22.750 --> 01:00:26.110
take too much time.

01:00:26.110 --> 01:00:28.150
So universal search
is one of them.

01:00:28.150 --> 01:00:30.710
So as I said, we reworked
search.

01:00:30.710 --> 01:00:34.370
In version 2, you could search
only on particular indexes.

01:00:34.370 --> 01:00:37.570
So you could only search
videos or playlists or

01:00:37.570 --> 01:00:39.420
channels, but not
a combination of

01:00:39.420 --> 01:00:40.592
those in the same time.

01:00:40.592 --> 01:00:43.730
In version 3, we're adding
universal search, which

01:00:43.730 --> 01:00:47.940
basically allows you to search
anything at the same time.

01:00:47.940 --> 01:00:51.310
Or it still gives you the option
to restrict a search to

01:00:51.310 --> 01:00:54.490
a particular resource type,
like just videos or just

01:00:54.490 --> 01:00:57.450
channels or just playlists.

01:00:57.450 --> 01:01:00.160
I talked a bit about how that
looks like, as a search

01:01:00.160 --> 01:01:03.090
result, as a search resource.

01:01:03.090 --> 01:01:09.823
But the benefit is that we
get to do the ranking and

01:01:09.823 --> 01:01:11.710
relevance on the server side.

01:01:11.710 --> 01:01:14.900
So we might not, given different
terms-- like,

01:01:14.900 --> 01:01:18.440
channel is the best fit for
a first result versus a

01:01:18.440 --> 01:01:19.690
video and so on.

01:01:26.090 --> 01:01:32.320
I'm not going to show you
[INAUDIBLE], but the way it

01:01:32.320 --> 01:01:36.222
works is that in the search
response, you get the snippet

01:01:36.222 --> 01:01:39.916
about the resource matched,
and then the ID of the

01:01:39.916 --> 01:01:41.460
resource, if you have
fetched a full

01:01:41.460 --> 01:01:43.106
resource that was found.

01:01:43.106 --> 01:01:47.580
So the use case we normally
think about is that you show a

01:01:47.580 --> 01:01:50.440
list of search results, and then
it's the same thing that

01:01:50.440 --> 01:01:52.346
a user clicks on a particular
search result, and it comes to

01:01:52.346 --> 01:01:54.690
the details of that resource.

01:01:54.690 --> 01:01:59.450
It's kind of like the same API
operations support in that.

01:02:02.150 --> 01:02:05.970
And I'm going to show you a
video about Freebase topics

01:02:05.970 --> 01:02:09.650
that I'm introducing into the
YouTube API, which is another

01:02:09.650 --> 01:02:13.336
very big feature that
we're adding.

01:02:13.336 --> 01:02:13.790
[VIDEO PLAYBACK]

01:02:13.790 --> 01:02:16.320
-Wouldn't it be amazing if
Google could understand that

01:02:16.320 --> 01:02:18.820
the words that you use when
you're doing a search, well,

01:02:18.820 --> 01:02:20.110
they aren't just words.

01:02:20.110 --> 01:02:22.540
They refer to real things
in the world.

01:02:22.540 --> 01:02:26.550
That a building is a building,
and an animal is an animal,

01:02:26.550 --> 01:02:29.540
and that they're not just random
strings of characters.

01:02:29.540 --> 01:02:33.120
If we could understand that
those words are talking about

01:02:33.120 --> 01:02:35.880
those real-world things, then
we could do a better job of

01:02:35.880 --> 01:02:38.470
getting you just the content
that you want off the web.

01:02:42.230 --> 01:02:44.690
-The way Google is trying to
build information about

01:02:44.690 --> 01:02:47.440
real-world connections is by
building a knowledge graph.

01:02:47.440 --> 01:02:51.090
The Knowledge Graph is about
collecting information, about

01:02:51.090 --> 01:02:52.660
objects in the real world.

01:02:52.660 --> 01:02:56.120
The object could be a person,
could be a book, could be a

01:02:56.120 --> 01:02:58.400
movie, and many other
types of things.

01:02:58.400 --> 01:03:01.550
For example, for a famous
person, we collect relevant

01:03:01.550 --> 01:03:04.493
data about them, such as
their date of birth, or

01:03:04.493 --> 01:03:06.120
how tall they are.

01:03:06.120 --> 01:03:09.170
We can also connect that person
to closely related

01:03:09.170 --> 01:03:11.800
objects in the Knowledge
Graph.

01:03:11.800 --> 01:03:15.690
-Let's say you're interested
in Renaissance painters, or

01:03:15.690 --> 01:03:19.020
how about how many women have
won the Nobel Prize.

01:03:19.020 --> 01:03:21.280
By understanding the
relationships between things,

01:03:21.280 --> 01:03:24.740
be it between painters in the
Renaissance or women and the

01:03:24.740 --> 01:03:28.000
Nobel Prize, Google can do a
better job of understanding

01:03:28.000 --> 01:03:30.880
what it is exactly you're
searching for.

01:03:30.880 --> 01:03:33.550
-One of the first features we
are going to introduce, which

01:03:33.550 --> 01:03:36.660
applies the Knowledge
Graph, is a panel

01:03:36.660 --> 01:03:38.730
next to the web results.

01:03:38.730 --> 01:03:41.010
-When you have a question to
answer, others may have come

01:03:41.010 --> 01:03:43.780
to Google already to search
for the same thing.

01:03:43.780 --> 01:03:46.240
Google can jump-start your
research process by combining

01:03:46.240 --> 01:03:48.520
the information that others
found useful with the

01:03:48.520 --> 01:03:50.280
information in the
Knowledge Graph.

01:03:50.280 --> 01:03:53.430
-All of the collective human
wisdom that comes through our

01:03:53.430 --> 01:03:56.670
search engine, what people are
searching for, tells us what

01:03:56.670 --> 01:03:59.270
are the interesting things
to put in our database.

01:03:59.270 --> 01:04:00.860
-Take Leonardo da Vinci.

01:04:00.860 --> 01:04:03.670
Let's say you wanted to learn
about the most important

01:04:03.670 --> 01:04:05.330
Renaissance painters.

01:04:05.330 --> 01:04:08.680
You might search for Leonardo da
Vinci because he's the only

01:04:08.680 --> 01:04:11.010
Renaissance painter
you know about.

01:04:11.010 --> 01:04:14.140
Now you see information right
in the search results that

01:04:14.140 --> 01:04:17.420
helps you explore the broader
topic of Renaissance painters.

01:04:17.420 --> 01:04:19.680
You'll see some of the most
famous paintings from that

01:04:19.680 --> 01:04:22.810
era, like the Mona Lisa, and
discover other painters of

01:04:22.810 --> 01:04:26.770
that time, like Michelangelo
and Raphael.

01:04:26.770 --> 01:04:29.280
-We're in the early phases
of moving from being an

01:04:29.280 --> 01:04:32.660
information engine to becoming
a knowledge engine.

01:04:32.660 --> 01:04:35.590
And these enhancements are one
step in that direction.

01:04:35.590 --> 01:04:38.250
-As we grow the Knowledge Graph
and make it larger and

01:04:38.250 --> 01:04:42.450
richer, we're really excited at
the opportunity we have to

01:04:42.450 --> 01:04:45.590
understand more of the users'
queries, to understand more

01:04:45.590 --> 01:04:48.710
about the information that's
out there on the web, and

01:04:48.710 --> 01:04:51.165
intelligently connect the
two to each other.

01:04:51.165 --> 01:04:52.590
[END VIDEO PLAYBACK]

01:04:56.390 --> 01:05:05.680
RAUL FURNICA: So this is about
an effort that is Google-wide.

01:05:05.680 --> 01:05:11.210
And there is a lot of it
going into YouTube.

01:05:11.210 --> 01:05:15.320
So YouTube is figuring out
particular topics to

01:05:15.320 --> 01:05:20.010
associate, or particular
Freebase topics that have been

01:05:20.010 --> 01:05:24.470
talked about in the Knowledge
Graph, basically, that are

01:05:24.470 --> 01:05:26.750
associated with a particular
video or a playlist or a

01:05:26.750 --> 01:05:29.490
channel, and that are
relevant for that

01:05:29.490 --> 01:05:31.500
playlist or video or channel.

01:05:31.500 --> 01:05:34.860
And in the API, we're servicing
those topic IDs,

01:05:34.860 --> 01:05:37.410
which are not YouTube
API-specific.

01:05:37.410 --> 01:05:41.590
It's actually a fine example of
integrating the YouTube API

01:05:41.590 --> 01:05:46.700
with other APIs that are
not YouTube-specific.

01:05:46.700 --> 01:05:54.620
And we give you a way to both
discover content by searching

01:05:54.620 --> 01:05:57.770
by particular topics, YouTube
content that matches the

01:05:57.770 --> 01:06:02.395
topic, and gathering around,
giving a video of what are the

01:06:02.395 --> 01:06:06.455
topics that this video
is related to.

01:06:06.455 --> 01:06:10.850
The way that looks into the API
response is that we have a

01:06:10.850 --> 01:06:13.370
part that is particular
for topics--

01:06:13.370 --> 01:06:15.200
called Topic Details--

01:06:15.200 --> 01:06:19.520
that lists all the topic IDs
that we think this YouTube

01:06:19.520 --> 01:06:22.830
content is associated with.

01:06:22.830 --> 01:06:26.850
From there, you can either take
a topic ID and resolve it

01:06:26.850 --> 01:06:31.040
against the Freebase API, and
understand what that topic is

01:06:31.040 --> 01:06:34.320
about and what is the other
information in the Knowledge

01:06:34.320 --> 01:06:38.170
Graph we have about that topic,
or you can search for

01:06:38.170 --> 01:06:42.010
more content related
to that topic.

01:06:42.010 --> 01:06:46.160
That's a YouTube API call that
you can make to search for

01:06:46.160 --> 01:06:47.730
more YouTube content matching
that topic.

01:06:50.550 --> 01:06:54.520
To read more about the Freebase
API in particular,

01:06:54.520 --> 01:06:57.195
you can use the link
on the side.

01:06:57.195 --> 01:07:01.584
Basically, it's a wiki
on freebase.com.

01:07:01.584 --> 01:07:05.245
And it explains what topics are
in particular, and how do

01:07:05.245 --> 01:07:08.660
you identify it, and how do you
retrieve metadata about

01:07:08.660 --> 01:07:12.670
topics, and how do you find all
kind of things about them.

01:07:18.930 --> 01:07:22.150
Talking about YouTube API
in particular, this

01:07:22.150 --> 01:07:23.570
is one of the examples.

01:07:23.570 --> 01:07:29.620
So if I was looking at the video
ID there-- and by the

01:07:29.620 --> 01:07:33.690
way, all the video IDs that are
used here are kind of like

01:07:33.690 --> 01:07:35.640
talks that are interesting,
that you might

01:07:35.640 --> 01:07:36.900
want to check out.

01:07:36.900 --> 01:07:39.680
So I didn't choose
random video IDs.

01:07:39.680 --> 01:07:44.525
I just chose something that
might send you on a path to

01:07:44.525 --> 01:07:47.970
find even more about
either YouTube or

01:07:47.970 --> 01:07:51.870
Freebase or YouTube API.

01:07:51.870 --> 01:07:56.610
And I'm asking for the topic
details of that video ID.

01:07:56.610 --> 01:08:00.220
And I'm getting back a Freebase
topic ID that looks

01:08:00.220 --> 01:08:02.817
like that, so slash [INAUDIBLE]
and then slash and

01:08:02.817 --> 01:08:05.294
then the ID.

01:08:05.294 --> 01:08:09.540
In order to load information
about that topic, by just

01:08:09.540 --> 01:08:12.080
seeing the YouTube API response,
I don't really know

01:08:12.080 --> 01:08:13.090
what a topic is.

01:08:13.090 --> 01:08:16.729
I just have this ID, so I don't
really know the name of

01:08:16.729 --> 01:08:19.416
the title of the topic,
what is it about.

01:08:19.416 --> 01:08:23.569
In order to resolve that, we're
going to use right now,

01:08:23.569 --> 01:08:31.779
actually, the Freebase API,
which is also a JSON API that

01:08:31.779 --> 01:08:35.950
you can use from this
[INAUDIBLE]

01:08:35.950 --> 01:08:38.050
Freebase as well.

01:08:38.050 --> 01:08:40.940
And I just paste in the
topic ID I got.

01:08:40.940 --> 01:08:46.615
And the filter on this
particular API restricts the

01:08:46.615 --> 01:08:50.649
data you return about
that topic.

01:08:50.649 --> 01:08:56.130
So the topic the video is
associated with is API.

01:08:56.130 --> 01:09:00.990
And it was created by that
particular user at that time.

01:09:00.990 --> 01:09:03.899
And it was that title
in English.

01:09:03.899 --> 01:09:08.335
And there is a lot more if I
were to either include more in

01:09:08.335 --> 01:09:10.689
the filter or just take
the filter out.

01:09:10.689 --> 01:09:15.510
Actually, I can just try it out
and show you that it's a

01:09:15.510 --> 01:09:19.529
lot of rich information in the
response of the Freebase API.

01:09:22.680 --> 01:09:28.500
So you get alias topics.

01:09:28.500 --> 01:09:33.229
You get articles you read
on Wikipedia APIs.

01:09:33.229 --> 01:09:38.060
You also are going to see some
thumbnails, pictures, video

01:09:38.060 --> 01:09:40.256
talks about APIs, and so on.

01:09:40.256 --> 01:09:44.158
It's all embedded in the
Knowledge Graph, if you want.

01:09:51.649 --> 01:09:55.210
So you can take any YouTube
resource, find the topics

01:09:55.210 --> 01:09:58.420
associated, go to the Freebase
API, find what the topic is

01:09:58.420 --> 01:10:00.992
about, and find content that is
not even YouTube-related--

01:10:00.992 --> 01:10:03.900
it's not on Wikipedia
or anything else--

01:10:03.900 --> 01:10:06.340
and pull all that
data and show it

01:10:06.340 --> 01:10:09.210
in your app, basically.

01:10:09.210 --> 01:10:11.542
Which should be better
[INAUDIBLE].

01:10:18.660 --> 01:10:23.725
And then, assuming we had
resolved that, or we figured

01:10:23.725 --> 01:10:26.706
out what the topic is about, and
maybe other content that

01:10:26.706 --> 01:10:30.260
is not YouTube-specific about
that topic, we might want to

01:10:30.260 --> 01:10:34.565
search more videos or more
channels that have that topic

01:10:34.565 --> 01:10:36.450
as well, or share that topic.

01:10:36.450 --> 01:10:40.060
The way to do that is, in the
search API, just pass on the

01:10:40.060 --> 01:10:41.995
topic ID as a parameter.

01:10:41.995 --> 01:10:47.910
And you can specify extra
search keywords, or not.

01:10:47.910 --> 01:10:51.630
And that's going to return you
even more YouTube content that

01:10:51.630 --> 01:10:54.580
is associated with that topic.

01:10:54.580 --> 01:10:57.400
And we have a cool sample client
application that I can

01:10:57.400 --> 01:11:00.520
show you right now.

01:11:00.520 --> 01:11:03.510
And this is using the search.

01:11:03.510 --> 01:11:04.950
It's a very simple UI.

01:11:04.950 --> 01:11:07.720
We didn't want to do too much.

01:11:07.720 --> 01:11:09.444
But we just want to show you
the API call and how

01:11:09.444 --> 01:11:10.610
it would look like.

01:11:10.610 --> 01:11:13.086
So for instance, I'm going to
search for the API topic that

01:11:13.086 --> 01:11:15.310
we just had before.

01:11:15.310 --> 01:11:19.230
This is textual search in
topics, so it's going to just

01:11:19.230 --> 01:11:21.890
match topics right now
related to API.

01:11:21.890 --> 01:11:24.610
It has a very good suggestion
and a very strong suggestion--

01:11:24.610 --> 01:11:27.400
API, Application Programming
Interface.

01:11:27.400 --> 01:11:28.780
That's the one I
actually meant.

01:11:28.780 --> 01:11:30.670
But there are actually
other topics that

01:11:30.670 --> 01:11:31.655
are related to APIs.

01:11:31.655 --> 01:11:33.860
And they are showing here.

01:11:33.860 --> 01:11:36.840
I can pick that one, which just
means picking the ID that

01:11:36.840 --> 01:11:38.860
you saw before.

01:11:38.860 --> 01:11:43.570
And as a result of that, firing
a search with the

01:11:43.570 --> 01:11:49.300
YouTube API, I get channels
about the API, about APIs.

01:11:49.300 --> 01:11:52.560
I get playlists about APIs.

01:11:52.560 --> 01:11:56.050
So there is an AdWords place,
there is an About

01:11:56.050 --> 01:11:57.670
Apigee, and so on.

01:11:57.670 --> 01:12:01.530
And I get videos about APIs that
I can all search through

01:12:01.530 --> 01:12:02.780
universal search.

01:12:05.235 --> 01:12:07.527
How to design a good
API, and so on.

01:12:07.527 --> 01:12:11.826
AUDIENCE: So is that prioritized
through relevancy?

01:12:11.826 --> 01:12:14.300
RAUL FURNICA: The client
application here is actually

01:12:14.300 --> 01:12:15.790
doing the [? splitting. ?]

01:12:15.790 --> 01:12:17.680
It shows the type of
channels versus

01:12:17.680 --> 01:12:20.470
playlists versus videos.

01:12:20.470 --> 01:12:23.810
But normally, if you just typed
a response for the API

01:12:23.810 --> 01:12:27.126
server, it's going to be
relevancy, and they're going

01:12:27.126 --> 01:12:28.376
to all intermingle.

01:12:30.600 --> 01:12:33.692
Or you can restrict to just
videos, or just channels, or

01:12:33.692 --> 01:12:34.846
just playlists.

01:12:34.846 --> 01:12:41.190
AUDIENCE: So in this client
[? support ?] area, the filter

01:12:41.190 --> 01:12:42.890
is the same [? text box ?]

01:12:42.890 --> 01:12:44.140
API--

01:12:46.350 --> 01:12:48.704
Google--

01:12:48.704 --> 01:12:49.700
RAUL FURNICA: Yeah, I can.

01:12:49.700 --> 01:12:53.700
AUDIENCE: Is that the order of
relevancy, the APIs that are

01:12:53.700 --> 01:12:55.714
the most relevant?

01:12:55.714 --> 01:12:57.420
Google is probably
[? secondary-- ?]

01:12:57.420 --> 01:12:59.440
RAUL FURNICA: Oh, you mean--

01:12:59.440 --> 01:13:01.780
so the question is if API
is more relevant.

01:13:01.780 --> 01:13:03.040
You mean amongst topics?

01:13:03.040 --> 01:13:04.264
AUDIENCE: Yeah, if I say API--

01:13:04.264 --> 01:13:05.080
RAUL FURNICA: Like here.

01:13:05.080 --> 01:13:08.040
AUDIENCE: space,
Google space--

01:13:11.220 --> 01:13:13.530
RAUL FURNICA: So I'm not sure
if API google is going to

01:13:13.530 --> 01:13:16.610
match a particular
API Google topic.

01:13:16.610 --> 01:13:20.500
But it actually matches topics
that has [INAUDIBLE].

01:13:20.500 --> 01:13:21.750
AUDIENCE: Oh, I see.

01:13:28.640 --> 01:13:31.450
RAUL FURNICA: And you can try
this out, and you can see the

01:13:31.450 --> 01:13:33.390
source code of the
app as well.

01:13:33.390 --> 01:13:35.290
It's also linked
[? on the site. ?]

01:13:48.900 --> 01:13:54.580
So this is my last slide, so
thanks for bearing and being

01:13:54.580 --> 01:13:55.920
with me still.

01:13:55.920 --> 01:14:02.720
So you have a bunch of links
here that you can follow and

01:14:02.720 --> 01:14:07.120
read more about version 3,
try it out, register as a

01:14:07.120 --> 01:14:13.170
developer, and try the sample
client application.

01:14:13.170 --> 01:14:14.760
So you have the documentation.

01:14:14.760 --> 01:14:22.085
The documentation has a tool
that lets you try different

01:14:22.085 --> 01:14:24.580
API calls directly from the
documentation page.

01:14:24.580 --> 01:14:28.650
So you can both read what is
called as and what are all the

01:14:28.650 --> 01:14:31.410
parameters it takes and what
each parameter means, and also

01:14:31.410 --> 01:14:34.292
try it in the same time
on the web interface.

01:14:34.292 --> 01:14:38.660
The client libraries are linked
there, and we have

01:14:38.660 --> 01:14:42.480
nine, ten client libraries
that we support.

01:14:42.480 --> 01:14:47.500
The API Explorer lets you fire
API requests on the web

01:14:47.500 --> 01:14:51.450
interface as well without having
to go through developer

01:14:51.450 --> 01:14:52.590
registration.

01:14:52.590 --> 01:14:55.740
You can just try it out on the
web interface directly.

01:14:55.740 --> 01:14:59.100
The Developer Registration and
Console is a great tool to

01:14:59.100 --> 01:15:05.950
monitor your particular client
application API traffic and to

01:15:05.950 --> 01:15:11.885
register for either just YouTube
API or other APIs that

01:15:11.885 --> 01:15:13.925
you are using in your
application--

01:15:13.925 --> 01:15:16.960
Google APIs, I should say.

01:15:16.960 --> 01:15:24.070
The resources [INAUDIBLE], and
we have a team of DevRel and

01:15:24.070 --> 01:15:26.430
people that, even us apps
engineers sometimes come on

01:15:26.430 --> 01:15:30.930
the pones and answer questions
that third-party

01:15:30.930 --> 01:15:32.283
developers ask us.

01:15:32.283 --> 01:15:34.730
And that's on Stack Overflow.

01:15:34.730 --> 01:15:38.080
And there is a YouTube API
tag for it you can use.

01:15:41.280 --> 01:15:43.980
The API itself, it's
[? served ?] from

01:15:43.980 --> 01:15:49.350
googleapis.com/youtube/v3.

01:15:49.350 --> 01:15:52.290
The discovery document that I
talked to you about, where you

01:15:52.290 --> 01:15:55.660
can read the schema, both
human-readable and

01:15:55.660 --> 01:15:59.488
machine-readable, and the
client applications.

01:15:59.488 --> 01:16:01.364
PRESENTER: [INAUDIBLE].

01:16:01.364 --> 01:16:03.709
Going once.

01:16:03.709 --> 01:16:04.525
Sold.

01:16:04.525 --> 01:16:05.470
OK.

01:16:05.470 --> 01:16:06.670
RAUL FURNICA: Thank
you very much.

01:16:06.670 --> 01:16:08.170
[APPLAUSE]

01:16:18.070 --> 01:16:33.333
[MUSIC PLAYING]

