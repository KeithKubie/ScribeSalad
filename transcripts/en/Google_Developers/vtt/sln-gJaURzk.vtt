WEBVTT
Kind: captions
Language: en

00:00:07.888 --> 00:00:08.381
ANDREW GERRAND: Hi everyone.

00:00:08.381 --> 00:00:10.353
My name is [INAUDIBLE].

00:00:10.353 --> 00:00:16.269
[INAUDIBLE], I'm here with the
Go Team, and for those of you

00:00:16.269 --> 00:00:17.519
that don't know, [INAUDIBLE]

00:00:21.199 --> 00:00:24.157
at Google, and I'm joined
by [INAUDIBLE]

00:00:28.101 --> 00:00:32.538
2009 [INAUDIBLE]

00:00:32.538 --> 00:00:34.750
version 1.0, which is a version
that will be supported

00:00:34.750 --> 00:00:36.870
for years to come.

00:00:36.870 --> 00:00:38.990
And I'll just get everyone to
introduce themselves, starting

00:00:38.990 --> 00:00:41.220
from the left, and a bit
about what they do.

00:00:41.220 --> 00:00:42.690
BRAD FITZPATRICK: I'm
Brad Fitzpatrick.

00:00:42.690 --> 00:00:45.850
I work on the standard library
and libraries within Google,

00:00:45.850 --> 00:00:47.860
and miscellaneous bugs
and whatever.

00:00:52.170 --> 00:00:52.430
KEN THOMPSON: Hi.

00:00:52.430 --> 00:00:53.390
I'm Ken Thompson, and--

00:00:53.390 --> 00:01:00.430
[APPLAUSE]

00:01:00.430 --> 00:01:02.530
--and I'm semi-retired.

00:01:02.530 --> 00:01:06.116
I worked on Go until the public
release in November and

00:01:06.116 --> 00:01:11.220
a little after that, and
now I'm having fun.

00:01:11.220 --> 00:01:11.850
ROB PIKE: I'm Rob Pike.

00:01:11.850 --> 00:01:15.696
I work mostly on the libraries
and help with documentation

00:01:15.696 --> 00:01:17.000
and basically make trouble.

00:01:19.620 --> 00:01:20.850
ROBERT GRIESEMER: I'm
Robert Griesemer.

00:01:20.850 --> 00:01:26.290
I wrote part of Go Doc and Go
[INAUDIBLE], and worked a

00:01:26.290 --> 00:01:27.540
little bit on the spec.

00:01:29.700 --> 00:01:32.560
ANDREW GERRAND: He
wrote the spec.

00:01:32.560 --> 00:01:34.270
DAVID SIMONS: I'm
David Simons.

00:01:34.270 --> 00:01:36.805
I worked on the Go runtime for
App Engine, and a bunch of

00:01:36.805 --> 00:01:40.580
other things in the standard
library and inside Google.

00:01:40.580 --> 00:01:42.130
ANDREW GERRAND: And I'm
Andrew Gerrand, and

00:01:42.130 --> 00:01:44.160
I'm a developer advocate.

00:01:44.160 --> 00:01:47.350
I'm sort of public interface
to the Go Team at Google.

00:01:47.350 --> 00:01:50.170
And so without further ado,
I'll just invite people to

00:01:50.170 --> 00:01:52.010
come up to the mics.

00:01:52.010 --> 00:01:55.620
Nigel, my glamorous assistant,
it's also a member of the Go

00:01:55.620 --> 00:01:58.590
Team, and he's going to read
some of the questions from

00:01:58.590 --> 00:02:00.030
[INAUDIBLE].

00:02:00.030 --> 00:02:00.480
Oh, yeah.

00:02:00.480 --> 00:02:03.520
I should mention the other
important members of our team

00:02:03.520 --> 00:02:05.130
like Russ Cox and Ian Taylor--

00:02:05.130 --> 00:02:06.580
Ian Lance Taylor--

00:02:06.580 --> 00:02:10.995
who couldn't be here today, just
do really great stuff and

00:02:10.995 --> 00:02:12.245
I wish they were here with us.

00:02:17.150 --> 00:02:18.620
NIGEL: Let's do a couple
questions from the

00:02:18.620 --> 00:02:21.560
[INAUDIBLE].

00:02:21.560 --> 00:02:24.850
So the first one is, what is the
core Go Team spending most

00:02:24.850 --> 00:02:26.090
of its time on--

00:02:26.090 --> 00:02:27.400
I'll start again.

00:02:27.400 --> 00:02:30.220
What is the core Go Team
spending most of its time on

00:02:30.220 --> 00:02:31.210
since the Go 1 release.

00:02:31.210 --> 00:02:33.930
What sort of things can we
expect in the medium term, say

00:02:33.930 --> 00:02:35.180
six months?

00:02:37.940 --> 00:02:42.690
ROB PIKE: Mostly the Go 1
release formed a boundary for

00:02:42.690 --> 00:02:46.040
stable language that we knew
we could sort of depend on.

00:02:46.040 --> 00:02:49.390
And so now we're focusing more
than we were before, although

00:02:49.390 --> 00:02:52.250
certainly not exclusively, on
more internal development,

00:02:52.250 --> 00:02:55.330
trying to get some Go
development inside Google,

00:02:55.330 --> 00:02:58.380
because we made the language
to help make Google more

00:02:58.380 --> 00:03:00.010
productive and helpful
internally.

00:03:00.010 --> 00:03:01.770
So there's been a
shift of focus.

00:03:01.770 --> 00:03:03.930
I wouldn't say it's a majority
time, but a lot of us are

00:03:03.930 --> 00:03:07.470
working more exclusively
on internal stuff.

00:03:07.470 --> 00:03:11.400
The longer term, there's a
bunch of stuff coming.

00:03:11.400 --> 00:03:14.630
We'll probably do a Go
1.1 release maybe

00:03:14.630 --> 00:03:16.350
sort of end of year-ish.

00:03:16.350 --> 00:03:17.250
Do you want to talk
about that?

00:03:17.250 --> 00:03:19.350
ANDREW GERRAND: Yeah, by the end
of the year we would say.

00:03:19.350 --> 00:03:21.260
ROB PIKE: And that'll include
a bunch of performance

00:03:21.260 --> 00:03:22.680
improvements.

00:03:22.680 --> 00:03:25.750
We've got some pretty amazing
compiler changes that have

00:03:25.750 --> 00:03:29.400
given remarkable speed-ups
to some programs.

00:03:29.400 --> 00:03:32.520
The libraries probably won't
change all that much for Go

00:03:32.520 --> 00:03:36.540
1.1, we might add a couple
of minor things.

00:03:36.540 --> 00:03:39.130
The thing is once you commit to
a library, you've got to be

00:03:39.130 --> 00:03:41.220
sure it's right, and we really,
really care about

00:03:41.220 --> 00:03:44.230
getting the APIs right, so I
suspect there won't be a lot

00:03:44.230 --> 00:03:47.020
of API changes until we're
absolutely convinced that

00:03:47.020 --> 00:03:48.230
that's the right model.

00:03:48.230 --> 00:03:51.190
That's sort of a bigger thing
than a point release.

00:03:51.190 --> 00:03:53.240
There's some garbage collector
changes that will make it

00:03:53.240 --> 00:03:58.490
significantly more efficient on
parallel execution, and a

00:03:58.490 --> 00:04:01.510
precise collector is in the
works that will make 32-bit

00:04:01.510 --> 00:04:05.110
collection much more effective
and therefore eliminate that

00:04:05.110 --> 00:04:06.660
one sort of sore spot.

00:04:06.660 --> 00:04:08.915
ANDREW GERRAND: We're also
hoping to promote some of the

00:04:08.915 --> 00:04:11.860
other operating system ports,
like the OpenBSD, NetBSD

00:04:11.860 --> 00:04:17.060
ports, and then there may be
another one, to that fully

00:04:17.060 --> 00:04:17.899
supported status.

00:04:17.899 --> 00:04:19.935
Currently there's only FreeBSD,
Windows, Linux, and

00:04:19.935 --> 00:04:23.700
[INAUDIBLE], and so they should
be in 1.1 as well,

00:04:23.700 --> 00:04:25.550
depending on the [INAUDIBLE].

00:04:25.550 --> 00:04:28.085
Oh, and there may be some
scheduler changes as well, but

00:04:28.085 --> 00:04:29.160
we're not sure how
they're going.

00:04:29.160 --> 00:04:34.030
But the long and short of it
is 1.1 is really about

00:04:34.030 --> 00:04:36.680
tightening the screws and making
things faster and more

00:04:36.680 --> 00:04:38.740
efficient and more reliable.

00:04:38.740 --> 00:04:42.270
We're not looking at any
language changes at all until

00:04:42.270 --> 00:04:45.070
Go Version 2, and we're not
sure when that will be.

00:04:45.070 --> 00:04:47.290
So we don't have a long-term
roadmap for the

00:04:47.290 --> 00:04:47.880
project at the moment.

00:04:47.880 --> 00:04:49.930
We're really happy to be a
position where we have

00:04:49.930 --> 00:04:52.630
something that we think is
really great, really solid,

00:04:52.630 --> 00:04:56.650
and a great platform for which
you guys can use to build

00:04:56.650 --> 00:04:57.900
reliable software.

00:05:01.030 --> 00:05:02.770
You can get up and ask
questions as well.

00:05:02.770 --> 00:05:04.670
Let's take another
one from Nige.

00:05:04.670 --> 00:05:06.630
NIGEL: I know it's been asked
before, and probably again

00:05:06.630 --> 00:05:08.380
recently, but do you
have any news or

00:05:08.380 --> 00:05:09.660
plans about Go on Android?

00:05:12.938 --> 00:05:15.900
ANDREW GERRAND: No.

00:05:15.900 --> 00:05:18.300
ROB PIKE: Clap?

00:05:18.300 --> 00:05:20.890
NIGEL: What feature or design
decision on Go had the most

00:05:20.890 --> 00:05:22.930
surprising impact, or
changed the way code

00:05:22.930 --> 00:05:24.200
was written the most?

00:05:24.200 --> 00:05:25.980
Defer, interfaces, reflection?

00:05:35.180 --> 00:05:38.280
KEN THOMPSON: In just volume of
code, I think it's slices.

00:05:38.280 --> 00:05:40.970
I think they turned out
to be very nice.

00:05:40.970 --> 00:05:43.480
ROB PIKE: Ken designed the
slices, by the way.

00:05:43.480 --> 00:05:47.800
I should mention that Robert
and Ken and I, who were the

00:05:47.800 --> 00:05:52.650
original instigators of all
this spent probably a year

00:05:52.650 --> 00:05:55.240
trying to figure out how arrays
would work, because we

00:05:55.240 --> 00:05:57.580
knew we wanted some sort of
variable-sized array, but we

00:05:57.580 --> 00:06:00.280
also knew we wanted fixed-size
arrays that were statically

00:06:00.280 --> 00:06:03.490
checked, and we had these things
called open arrays, I

00:06:03.490 --> 00:06:05.030
don't remember how
they worked.

00:06:05.030 --> 00:06:06.950
But it was a real struggle, we
spent a long time, and then

00:06:06.950 --> 00:06:10.550
Ken walked in one day with this
slice idea, and it wasn't

00:06:10.550 --> 00:06:12.480
clear it was the right answer,
but as soon as we started

00:06:12.480 --> 00:06:14.510
using it, it was obvious.

00:06:14.510 --> 00:06:17.380
I would add, I think that
there's sort of

00:06:17.380 --> 00:06:18.410
two parts that question.

00:06:18.410 --> 00:06:21.950
One is, what made existing Go
programs change, and I think

00:06:21.950 --> 00:06:24.290
slices are definitely
the answer there.

00:06:24.290 --> 00:06:27.910
As far as how I think about
programming is different, for

00:06:27.910 --> 00:06:30.350
a lot of people, it's the
concurrency stuff, but I've

00:06:30.350 --> 00:06:32.670
been using concurrency longer
than some of you and so it

00:06:32.670 --> 00:06:35.380
wasn't as big a deal, although
I love having it.

00:06:35.380 --> 00:06:40.030
For me, the whole idea of
interfaces profoundly changed

00:06:40.030 --> 00:06:42.480
how I think about software
development.

00:06:42.480 --> 00:06:46.200
The idea that a program is
composed of these things that

00:06:46.200 --> 00:06:49.420
stick together feels so
easy to work with.

00:06:49.420 --> 00:06:52.050
It just changes the way software
gets constructed, it

00:06:52.050 --> 00:06:55.443
changes the way libraries get
built, and for the sort of day

00:06:55.443 --> 00:06:58.070
to day programming I do, I
think they're the biggest

00:06:58.070 --> 00:07:00.474
single thing.

00:07:00.474 --> 00:07:00.940
MALE SPEAKER: Anybody else?

00:07:00.940 --> 00:07:01.560
ROBERT GRIESEMER: Yeah.

00:07:01.560 --> 00:07:07.250
Maybe the fact that a package
file can just be a single file

00:07:07.250 --> 00:07:11.160
as opposed to two files where
one is specifying what you

00:07:11.160 --> 00:07:16.540
export, as is still the case
for the standard systems

00:07:16.540 --> 00:07:17.500
programming languages.

00:07:17.500 --> 00:07:20.300
I think that reduces your number
of files there by a

00:07:20.300 --> 00:07:22.860
factor of two, and also makes
it much easier to

00:07:22.860 --> 00:07:24.210
maintain your code.

00:07:24.210 --> 00:07:26.970
ROB PIKE: I also remember that
when we changed it so that all

00:07:26.970 --> 00:07:29.780
of the globals in your package
could be declared in whatever

00:07:29.780 --> 00:07:33.900
order you wanted, you didn't
have to predeclare, Ken came

00:07:33.900 --> 00:07:35.400
in one day and he said,
this is the best

00:07:35.400 --> 00:07:38.300
decision we ever made.

00:07:38.300 --> 00:07:41.270
ANDREW GERRAND: Yeah, I would
go further and say that the

00:07:41.270 --> 00:07:44.590
entire way packages are
arranged, where you can have

00:07:44.590 --> 00:07:46.630
packages that consist of
multiple files and it's all

00:07:46.630 --> 00:07:51.320
kind of fairly loose, has really
made the process of

00:07:51.320 --> 00:07:53.670
building software from the
ground up much more

00:07:53.670 --> 00:07:56.350
straightforward and fluid, and
I feel like refactoring and

00:07:56.350 --> 00:07:59.930
everything becomes really a very
minor deal, whereas it

00:07:59.930 --> 00:08:04.266
can be very difficult
in other languages.

00:08:04.266 --> 00:08:05.130
Hey Bob.

00:08:05.130 --> 00:08:07.110
BOB: Hey Andrew.

00:08:07.110 --> 00:08:09.670
You talked about improving the
scheduling of Go routines.

00:08:09.670 --> 00:08:12.220
I'm wondering if you can discuss
it, what type of

00:08:12.220 --> 00:08:14.680
internal discussions you have of
how to improve that type of

00:08:14.680 --> 00:08:17.300
schedule without writing a
operating system on top of an

00:08:17.300 --> 00:08:18.910
operating system.

00:08:18.910 --> 00:08:20.610
ANDREW GERRAND: It's actually
been an external discussion on

00:08:20.610 --> 00:08:23.630
the Go lang dev mailing list.

00:08:23.630 --> 00:08:26.920
One of our prolific
contributors, Dmitry Vyukov,

00:08:26.920 --> 00:08:28.960
who we should thank profusely
for his great work on

00:08:28.960 --> 00:08:35.789
improving the efficiency of
the runtime, he actually

00:08:35.789 --> 00:08:38.789
posted a proposal for a revised
scheduler and that's

00:08:38.789 --> 00:08:39.600
what's been under discussion.

00:08:39.600 --> 00:08:41.740
So there's kind of tentative
plans there, but I won't go

00:08:41.740 --> 00:08:44.190
into it now, but if
you're curious,

00:08:44.190 --> 00:08:45.780
it's all there online.

00:08:45.780 --> 00:08:46.730
BOB: Thanks.

00:08:46.730 --> 00:08:49.110
ROB PIKE: I would like to just
add that you kind of do have

00:08:49.110 --> 00:08:50.660
to implement an operating
system above

00:08:50.660 --> 00:08:51.750
an operating system.

00:08:51.750 --> 00:08:54.380
That's really what the runtime
is, and what it's doing is

00:08:54.380 --> 00:08:57.990
it's changing the primitives
you have that the operating

00:08:57.990 --> 00:08:59.830
system doesn't give you.

00:08:59.830 --> 00:09:03.170
The main thing that Dimitri is
doing, he's trying to speed up

00:09:03.170 --> 00:09:05.970
by structuring it differently
and thinking about scheduling

00:09:05.970 --> 00:09:08.220
things in a different way, and
I think it's a big deal.

00:09:08.220 --> 00:09:11.760
The thing he's not doing, which
I think needs to be done

00:09:11.760 --> 00:09:16.230
at some point, but it's very,
very difficult to do well, is

00:09:16.230 --> 00:09:23.100
some kind of preemptive
scheduler.

00:09:23.100 --> 00:09:27.880
The current scheduler will
schedule a particular thread,

00:09:27.880 --> 00:09:31.960
or therefore, Go routine only
at communication points,

00:09:31.960 --> 00:09:34.710
locks, system calls,
things like that.

00:09:34.710 --> 00:09:36.380
So if you have an infinite
loop, it will

00:09:36.380 --> 00:09:38.200
never yield the processor.

00:09:38.200 --> 00:09:40.850
If you're running on multiple
processors, if your program is

00:09:40.850 --> 00:09:44.010
truly parallel, then you
can get them to execute

00:09:44.010 --> 00:09:46.800
independently, but the load
balancing doesn't work right

00:09:46.800 --> 00:09:48.360
unless there's some sort
of preemption.

00:09:48.360 --> 00:09:50.460
So I think preemption has to
happen, but it's a very

00:09:50.460 --> 00:09:53.510
difficult subject and we haven't
done it yet because

00:09:53.510 --> 00:09:54.690
we've been worrying about
other things.

00:09:54.690 --> 00:09:57.610
It doesn't have a huge effect
on things like correctness,

00:09:57.610 --> 00:09:59.580
but it does mean you can
do a much better

00:09:59.580 --> 00:10:01.190
job of managing resources.

00:10:01.190 --> 00:10:05.180
But we don't have it yet.

00:10:05.180 --> 00:10:06.690
AUDIENCE: So I know this was
covered a little bit in the

00:10:06.690 --> 00:10:08.360
previous session, the
concurrency and

00:10:08.360 --> 00:10:12.500
synchronization features of Go
channels, but it seems to me

00:10:12.500 --> 00:10:16.520
that it supports really one
paradigm or one pattern of

00:10:16.520 --> 00:10:18.980
concurrency, which is really
produce a consumer framework,

00:10:18.980 --> 00:10:22.670
and I guess you could also add
semaphores if you look at the

00:10:22.670 --> 00:10:26.030
queue length as a
synchronization feature.

00:10:26.030 --> 00:10:29.180
I'm just wondering if anyone has
done a survey of a number

00:10:29.180 --> 00:10:32.320
of design patterns in
concurrency, such as the ones

00:10:32.320 --> 00:10:35.340
in Java.Lang.Concurrent or some
other large library where

00:10:35.340 --> 00:10:37.830
there are a lot of different
design patterns for

00:10:37.830 --> 00:10:41.270
concurrency, to see if any of
those should be implemented as

00:10:41.270 --> 00:10:44.400
higher order features on top of
the mutexes and semaphores

00:10:44.400 --> 00:10:47.540
that are provided
in Go libraries.

00:10:47.540 --> 00:10:50.770
So basically the short form of
the question is, is it true

00:10:50.770 --> 00:10:52.500
that really, we're just
looking at produce and

00:10:52.500 --> 00:10:54.180
consumer relationships
with Go channels?

00:10:54.180 --> 00:10:57.710
And the next question then is,
should there be some higher

00:10:57.710 --> 00:11:00.420
order features built on top of
the semaphores and f that are

00:11:00.420 --> 00:11:03.100
the low level synchronization
features that are provided in

00:11:03.100 --> 00:11:04.350
the libraries?

00:11:06.085 --> 00:11:07.370
BRAD FITZPATRICK: Well, there's
some things already

00:11:07.370 --> 00:11:09.760
there, there's like Sync Week
group, which is like

00:11:09.760 --> 00:11:12.730
CountDownLatch in Java or
whatever, and it's also pretty

00:11:12.730 --> 00:11:15.490
easy to build your own
primitives on top of those.

00:11:15.490 --> 00:11:18.270
We have a library that I use in
a lot of my servers called

00:11:18.270 --> 00:11:22.390
Single Flight where if you have,
let's say, a web server,

00:11:22.390 --> 00:11:24.870
and three people come in roughly
at the same time and

00:11:24.870 --> 00:11:27.330
they all want something
expensive, I have just a

00:11:27.330 --> 00:11:30.650
little function that latches
onto existing requests that

00:11:30.650 --> 00:11:32.230
are in flight, and then
multiplexes the

00:11:32.230 --> 00:11:33.370
answer out to everyone.

00:11:33.370 --> 00:11:36.060
It's a tiny amount of code, but
that's a primitive you can

00:11:36.060 --> 00:11:38.050
build using existing
Go routines and

00:11:38.050 --> 00:11:40.020
channels and stuff.

00:11:40.020 --> 00:11:42.910
There could probably be a
package like SyncUtil that

00:11:42.910 --> 00:11:46.550
puts a lot of these patterns
into a library, but outside of

00:11:46.550 --> 00:11:51.250
like Wait Group, there's not
too many of them right now.

00:11:51.250 --> 00:11:55.380
ANDREW GERRAND: I think also
part of the issue is that

00:11:55.380 --> 00:11:58.500
because these primitives are so
easy to write, we've sort

00:11:58.500 --> 00:12:00.943
of shied away from including
too many of these tricks in

00:12:00.943 --> 00:12:03.400
the standard library because
everybody's need is subtly

00:12:03.400 --> 00:12:05.790
different, and if you just write
the code yourself, you

00:12:05.790 --> 00:12:08.905
have total control over
the intricacies of

00:12:08.905 --> 00:12:11.300
the particular piece.

00:12:11.300 --> 00:12:13.200
AUDIENCE: Although most people
shouldn't be writing that

00:12:13.200 --> 00:12:15.370
code, right?

00:12:15.370 --> 00:12:17.070
Most people shouldn't
be writing low level

00:12:17.070 --> 00:12:20.110
synchronization primitives
if they want

00:12:20.110 --> 00:12:21.620
their code to be safe.

00:12:21.620 --> 00:12:24.130
I don't trust most programmers
to write that sort of code.

00:12:24.130 --> 00:12:25.550
ROB PIKE: I actually take
objection to that.

00:12:25.550 --> 00:12:29.240
I think in the last talk,
I showed a lot of really

00:12:29.240 --> 00:12:32.250
interesting examples that
didn't have low level

00:12:32.250 --> 00:12:33.850
synchronization of any kind.

00:12:33.850 --> 00:12:37.130
And part of the whole point of
the design of Go's concurrency

00:12:37.130 --> 00:12:38.770
is that it's not low level.

00:12:38.770 --> 00:12:41.635
And I don't object to having
low level synchronization

00:12:41.635 --> 00:12:44.990
primitives where they're
necessary, but Go takes a

00:12:44.990 --> 00:12:48.040
pretty firm stand that you can
think about large scale

00:12:48.040 --> 00:12:50.480
concurrent programming with much
higher level, easier to

00:12:50.480 --> 00:12:52.160
reason about, primitives.

00:12:52.160 --> 00:12:56.260
And I think you're being a
little contentious on how

00:12:56.260 --> 00:12:57.270
you're describing that.

00:12:57.270 --> 00:13:00.300
I'd also like to say that
saying that the channels

00:13:00.300 --> 00:13:04.410
promote a producer consumer
model is OK, but you can do

00:13:04.410 --> 00:13:05.280
other things with it, too.

00:13:05.280 --> 00:13:08.360
I mean, the whole idea of a
channel on a channel doesn't

00:13:08.360 --> 00:13:09.190
map into the idea of a

00:13:09.190 --> 00:13:11.300
producer-consumer kind of thing.

00:13:11.300 --> 00:13:14.040
There are really rich models
that you can build with these

00:13:14.040 --> 00:13:17.990
that don't have the flavors of
these words you're using.

00:13:17.990 --> 00:13:21.400
That said, I completely agree it
would be fantastic to have

00:13:21.400 --> 00:13:24.770
libraries for some of these
larger level things, but I

00:13:24.770 --> 00:13:27.790
would make the libraries not be
things like semaphores but

00:13:27.790 --> 00:13:31.910
things like multiplexers, and
load balancers, and that kind

00:13:31.910 --> 00:13:36.170
of thing, much higher level
rather than just one level up

00:13:36.170 --> 00:13:38.180
from the locks and
things like that.

00:13:38.180 --> 00:13:39.650
AUDIENCE: Right, thank you.

00:13:39.650 --> 00:13:42.710
DAVID SIMONS: I'll just add to
that that it's also sometimes

00:13:42.710 --> 00:13:45.440
a trap that new Go programmers
fall into where they try to

00:13:45.440 --> 00:13:48.330
map concepts from other
languages too directly when

00:13:48.330 --> 00:13:50.180
they start to write Go.

00:13:50.180 --> 00:13:52.270
So that can be very easy, if
you're familiar with, say,

00:13:52.270 --> 00:13:55.380
writing concurrent coding in
Java, to come over to Go and

00:13:55.380 --> 00:13:57.500
immediately look for
all the things from

00:13:57.500 --> 00:14:01.620
java.util.concurrent in Go to
pretty much write exactly the

00:14:01.620 --> 00:14:04.610
same code, just with
Go syntax.

00:14:04.610 --> 00:14:07.210
Part of the appeal of Go is that
you can structure your

00:14:07.210 --> 00:14:12.300
program in a very different way,
something that could be a

00:14:12.300 --> 00:14:15.800
lot more natural or decomposing
to Go routines,

00:14:15.800 --> 00:14:19.350
because Go routines
are efficient.

00:14:19.350 --> 00:14:22.990
The more mappings that you
provide, the easier it is for

00:14:22.990 --> 00:14:26.190
people to not take a sit back
and rethink how they've

00:14:26.190 --> 00:14:29.710
structured their code.

00:14:29.710 --> 00:14:32.820
AUDIENCE: In broad strokes, can
you tell us a bit about

00:14:32.820 --> 00:14:36.060
the problems that led you to
create Go in the first place,

00:14:36.060 --> 00:14:40.430
and then how your goals have
changed for Go as it's got

00:14:40.430 --> 00:14:43.570
more real world adoption
and gotten out there.

00:14:43.570 --> 00:14:46.860
Are they still the same, or
has it evolved a lot?

00:14:46.860 --> 00:14:48.950
ROB PIKE: I actually give a
talk just last week on--

00:14:48.950 --> 00:14:49.470
ANDREW GERRAND: Do
you have it here?

00:14:49.470 --> 00:14:50.890
You could just--

00:14:50.890 --> 00:14:52.890
ROB PIKE: Give the talk, yeah.

00:14:52.890 --> 00:14:56.000
I mean, it's kind of a cartoon
answer but it's fairly

00:14:56.000 --> 00:15:02.650
accurate that we were doing a
lot of C++ development, and

00:15:02.650 --> 00:15:04.600
the joke, but there's a grain
of truth in it, is we got

00:15:04.600 --> 00:15:06.920
tired of waiting for
the compilations.

00:15:06.920 --> 00:15:10.120
We were building these massive
binaries on massive compute

00:15:10.120 --> 00:15:12.120
clusters and it was
taking over an

00:15:12.120 --> 00:15:13.780
hour to build a binary.

00:15:13.780 --> 00:15:17.070
And we thought, why is this the
case when a video game can

00:15:17.070 --> 00:15:19.260
generate 100 frames a second?

00:15:19.260 --> 00:15:21.440
What's wrong with our world?

00:15:21.440 --> 00:15:24.480
And we thought about the kind
of software that we build,

00:15:24.480 --> 00:15:27.840
which is basically web servers
and back ends,

00:15:27.840 --> 00:15:29.540
and that's one branch.

00:15:29.540 --> 00:15:32.620
But then we also thought about
why these things take so long.

00:15:32.620 --> 00:15:35.820
It's mostly because of the
dependency hierarchy.

00:15:35.820 --> 00:15:40.610
And in C++, to a much greater
extent than Java, say, the

00:15:40.610 --> 00:15:42.860
dependency hierarchy is
very uncontrolled.

00:15:42.860 --> 00:15:46.610
You include a Header file, but
you don't know whether you

00:15:46.610 --> 00:15:48.360
need it or not, unless you
take it out and find it

00:15:48.360 --> 00:15:49.370
doesn't compile anymore.

00:15:49.370 --> 00:15:52.610
With all the ifdef guards and
nonsense like that, it's

00:15:52.610 --> 00:15:57.400
possible to have complete
uncontrolled dependency stuff,

00:15:57.400 --> 00:15:59.930
which causes things to be
built many, many times.

00:15:59.930 --> 00:16:02.880
Mike Burrows, who built the
Chubby server, was waiting for

00:16:02.880 --> 00:16:04.470
a build one day-- we
spent a lot of time

00:16:04.470 --> 00:16:06.780
waiting for C++ builds--

00:16:06.780 --> 00:16:09.500
and he noticed a file went by
that he didn't understand the

00:16:09.500 --> 00:16:13.060
need for in his binary, and so
he looked into it, and it was

00:16:13.060 --> 00:16:16.350
a file he'd never heard of
in a package heap that no

00:16:16.350 --> 00:16:19.000
business being linked in, and
the header files being

00:16:19.000 --> 00:16:22.210
compiled 37,000 times to
build [INAUDIBLE].

00:16:22.210 --> 00:16:25.950
And you laugh, but that's what
happens when the model is, you

00:16:25.950 --> 00:16:28.460
use ifdef guards to protect
your dependencies, and you

00:16:28.460 --> 00:16:31.110
just include everything and let
it build, and it becomes

00:16:31.110 --> 00:16:34.700
this incredibly dense nest
of too much work.

00:16:34.700 --> 00:16:40.000
So a key driver behind Go was
making that not possible,

00:16:40.000 --> 00:16:43.660
fixing through the language the
dependency problem, having

00:16:43.660 --> 00:16:47.330
totally clear dependencies,
rejecting unused imports,

00:16:47.330 --> 00:16:51.560
making the dependency problem
solved by the compiler.

00:16:51.560 --> 00:16:54.080
And there's a key point there,
which we've talked about in

00:16:54.080 --> 00:16:56.770
talks before, which is you have
a Package A that depends

00:16:56.770 --> 00:17:00.660
on a Package B that depends on
a Package C, but A does not

00:17:00.660 --> 00:17:02.760
itself depend on C directly--

00:17:02.760 --> 00:17:06.430
so A depends on B and B depends
on C. To compile A,

00:17:06.430 --> 00:17:09.970
you should not have to compile
C along with B. So once you

00:17:09.970 --> 00:17:13.990
compile B, it pulls up all of
the information about C that

00:17:13.990 --> 00:17:17.930
it needs into its object code
so that when A runs, it says

00:17:17.930 --> 00:17:21.980
import B, all it has to read is
B. And for the three steps,

00:17:21.980 --> 00:17:24.160
that's obviously a trivial
thing, but when you have

00:17:24.160 --> 00:17:26.839
thousands and thousands of
files, that can save

00:17:26.839 --> 00:17:30.490
exponentially in the number of
dependencies you have look at,

00:17:30.490 --> 00:17:32.070
and I mean exponentially.

00:17:32.070 --> 00:17:34.700
And so Go builds take a fraction
of a second, partly

00:17:34.700 --> 00:17:37.350
because the compiler's fairly
quick, but mostly because the

00:17:37.350 --> 00:17:40.020
dependency problem just doesn't
exist in the language,

00:17:40.020 --> 00:17:42.236
and that was a really, really
key part of it.

00:17:42.236 --> 00:17:44.480
AUDIENCE: And is that still
what you see as the most

00:17:44.480 --> 00:17:47.430
important problem today
that Go solves?

00:17:47.430 --> 00:17:52.010
KEN THOMPSON: For me, the reason
I was enthusiastic

00:17:52.010 --> 00:17:55.140
about Go is because just about
the same time we were starting

00:17:55.140 --> 00:18:03.930
on Go, I read or tried to read
the C++ 0x proposed standard,

00:18:03.930 --> 00:18:05.830
and that was the convincer
for me.

00:18:11.420 --> 00:18:12.660
BRAD FITZPATRICK: The thing
I like about it is you can

00:18:12.660 --> 00:18:13.840
actually find the code.

00:18:13.840 --> 00:18:18.190
I read C++ code, even code I
used to write, that I wrote,

00:18:18.190 --> 00:18:21.530
and I just try to trace through
it, and it's bouncing

00:18:21.530 --> 00:18:25.970
around dozens of files, dozens
of callbacks, and I like being

00:18:25.970 --> 00:18:27.420
able to read code that
reads top down.

00:18:27.420 --> 00:18:30.470
I've been porting a lot of C++
code at Google to Go, and it

00:18:30.470 --> 00:18:34.340
gets substantially shorter and
readable, and we can see the

00:18:34.340 --> 00:18:37.110
logic finally, whereas it used
to be spread over so many

00:18:37.110 --> 00:18:38.590
files that you couldn't actually
get the high level

00:18:38.590 --> 00:18:41.190
picture of what your
server was doing.

00:18:41.190 --> 00:18:42.650
ANDREW GERRAND: And as somebody
coming from a

00:18:42.650 --> 00:18:43.555
different angle who--

00:18:43.555 --> 00:18:47.540
I don't have a C++ background at
all, but I worked mostly in

00:18:47.540 --> 00:18:51.160
more dynamic languages like
JavaScript and Python, and

00:18:51.160 --> 00:18:55.940
what I love about Go is that I
can write the software that I

00:18:55.940 --> 00:18:59.620
want to write with high
performance which is not

00:18:59.620 --> 00:19:00.830
really verbose code.

00:19:00.830 --> 00:19:03.240
It's very simple to understand,
and the code that

00:19:03.240 --> 00:19:07.320
I read on the page is the
code that is executed.

00:19:07.320 --> 00:19:10.530
When I iterate over a slice,
there's not some chance that

00:19:10.530 --> 00:19:12.620
there's an iterative
implementation that fetches a

00:19:12.620 --> 00:19:15.520
file from a web server in
Romania and serves me some

00:19:15.520 --> 00:19:16.590
JSON or something.

00:19:16.590 --> 00:19:21.780
Instead, the language is very
deliberately simple and

00:19:21.780 --> 00:19:25.120
contained so that it's very easy
to reason about code that

00:19:25.120 --> 00:19:27.770
you're reading.

00:19:27.770 --> 00:19:30.450
And as programmers, we tend to
spend way more time reading

00:19:30.450 --> 00:19:32.430
other people's code than writing
code, and I think that

00:19:32.430 --> 00:19:35.000
speaks to what Brad is saying is
that if you dive into a Go

00:19:35.000 --> 00:19:37.160
project like the Go standard
libraries, it's very, very

00:19:37.160 --> 00:19:39.910
accessible, and more accessible
than any other

00:19:39.910 --> 00:19:41.286
language that I've worked in.

00:19:41.286 --> 00:19:42.520
BRAD FITZPATRICK: It's
also nice to be able

00:19:42.520 --> 00:19:43.940
to block for a change.

00:19:43.940 --> 00:19:45.880
When you come from writing
servers where it's all

00:19:45.880 --> 00:19:48.800
callbacks and callbacks and
callbacks with no JS code or

00:19:48.800 --> 00:19:51.150
whatever, where every line of
your code is indented a little

00:19:51.150 --> 00:19:54.220
bit more, another anonymous
function, another, it's nice

00:19:54.220 --> 00:19:56.290
to be able to be like, oh, I
can write to the network

00:19:56.290 --> 00:19:59.410
there, and I can wait however
long it takes, however slow

00:19:59.410 --> 00:20:02.120
that client is, and then I go
to the next line of code.

00:20:02.120 --> 00:20:03.740
I don't have to name that,
I don't have to name that

00:20:03.740 --> 00:20:05.150
lambda, I don't have to
name that callback,

00:20:05.150 --> 00:20:07.560
I just write code.

00:20:07.560 --> 00:20:09.675
ROBERT GRIESEMER: I have written
a lot of C++ code in

00:20:09.675 --> 00:20:13.510
my previous life, and I think
you can actually write quite

00:20:13.510 --> 00:20:16.740
nice code in C++, but you have
to be incredibly disciplined.

00:20:16.740 --> 00:20:20.780
And almost every company that I
know, they have an internal

00:20:20.780 --> 00:20:25.400
style where they just use
a subset of C++, because

00:20:25.400 --> 00:20:27.770
otherwise, they just can't
control their code.

00:20:27.770 --> 00:20:31.960
And so even if you're very
disciplined, if you make an

00:20:31.960 --> 00:20:33.620
error, it's incredibly difficult
to find them.

00:20:33.620 --> 00:20:40.610
Now in Go, it would be really
nice, I thought, if we had a

00:20:40.610 --> 00:20:42.820
language where these things
are simply not possible.

00:20:42.820 --> 00:20:45.710
And the fact is that all or many
of the ideas that we have

00:20:45.710 --> 00:20:49.410
now in Go actually existed
a very long time ago.

00:20:49.410 --> 00:20:53.700
Rob Pike pointed out many of
the concurrency ideas, they

00:20:53.700 --> 00:21:04.280
were invented 20 years
ago, 30 years ago.

00:21:04.280 --> 00:21:08.340
The ideas about how you organize
packages, they go

00:21:08.340 --> 00:21:11.040
back all the way to [INAUDIBLE]
and the

00:21:11.040 --> 00:21:13.730
[INAUDIBLE].

00:21:13.730 --> 00:21:17.140
There's a lot of ideas in Go
that have been around forever

00:21:17.140 --> 00:21:20.170
in different languages, which
all for some reason or not,

00:21:20.170 --> 00:21:23.710
really made it to
a mainstream.

00:21:23.710 --> 00:21:24.960
I thought it would be
nice if we had them.

00:21:24.960 --> 00:21:26.210
I want them.

00:21:29.470 --> 00:21:30.710
AUDIENCE: Is anyone doing a--

00:21:30.710 --> 00:21:32.850
ROB PIKE: One more point
before you go, sorry.

00:21:32.850 --> 00:21:35.160
Is this on?

00:21:35.160 --> 00:21:37.790
Robert mentioned this thing that
everybody subsets C++ so

00:21:37.790 --> 00:21:42.080
they write in their own subset
in their company.

00:21:42.080 --> 00:21:47.400
Last week Russ Cox, who's not
here joked that maybe the C++

00:21:47.400 --> 00:21:49.520
style guide has all that in
it, but the Go style guide

00:21:49.520 --> 00:21:51.660
should start by saying, you can
use the whole language.

00:21:55.476 --> 00:21:59.630
AUDIENCE: Is anyone writing
a kernel in Go?

00:21:59.630 --> 00:22:01.820
I've always wanted to have this
idea where I could just

00:22:01.820 --> 00:22:04.520
push services out of the kernel
into user [INAUDIBLE]

00:22:04.520 --> 00:22:07.290
like a micro-kernel, and then
rewrite them in Go one at a

00:22:07.290 --> 00:22:10.576
time, and then keep going until
the whole thing was Go.

00:22:10.576 --> 00:22:14.770
ROBERT GRIESEMER: I believe
Ross actually prototyped a

00:22:14.770 --> 00:22:17.860
completely standalone
mini-kernel that was just

00:22:17.860 --> 00:22:20.090
written in Go and ran
on bare hardware.

00:22:20.090 --> 00:22:22.580
BRAD FITZPATRICK: And somebody
else ported something like

00:22:22.580 --> 00:22:25.670
BusyBox that ran as a [? nit, ?]
and so the whole

00:22:25.670 --> 00:22:27.890
userland, at least, was
Go, including the

00:22:27.890 --> 00:22:30.080
shell and all the tools.

00:22:30.080 --> 00:22:31.660
At least it was a proof
of concept.

00:22:35.270 --> 00:22:38.990
AUDIENCE: Another question just
on Amazon Web Services.

00:22:38.990 --> 00:22:41.180
Any experience, tips, tools?

00:22:43.920 --> 00:22:45.370
ANDREW GERRAND: Relating to
go on Amazon Web Services?

00:22:45.370 --> 00:22:46.910
AUDIENCE: Yes, sorry,
obviously.

00:22:46.910 --> 00:22:50.640
ANDREW GERRAND: Well, use
Gustavo's Go AMZ package for

00:22:50.640 --> 00:22:52.300
talking to Amazon.

00:22:52.300 --> 00:22:54.344
It works.

00:22:54.344 --> 00:22:55.290
AUDIENCE: Or not.

00:22:55.290 --> 00:22:55.690
ANDREW GERRAND: Or not.

00:22:55.690 --> 00:22:56.940
That may be the case.

00:22:59.550 --> 00:23:01.720
BRAD FITZPATRICK: I don't do
anything fancy on Amazon, but

00:23:01.720 --> 00:23:05.460
I run a lot of Go code on
Amazon, just on random single

00:23:05.460 --> 00:23:10.170
machines, and it runs fine,
like anything else.

00:23:10.170 --> 00:23:14.790
ANDREW GERRAND: We support
x86 hardware.

00:23:14.790 --> 00:23:18.470
AUDIENCE: So it has been said
that inside C++, there is a

00:23:18.470 --> 00:23:21.670
very small and beautiful
language trying hard to get

00:23:21.670 --> 00:23:28.220
out, and it appears that finally
it is getting out.

00:23:28.220 --> 00:23:32.120
So my question is, how would
you compare Go effort to

00:23:32.120 --> 00:23:35.240
effort by Digital
Mars and Andre

00:23:35.240 --> 00:23:37.000
Alexandrescu with [? D? ?]

00:23:43.200 --> 00:23:44.160
ROBERT GRIESEMER: I don't know
what I should say here.

00:23:44.160 --> 00:23:49.110
I attended a D talk a couple of
months ago, and one of the

00:23:49.110 --> 00:23:54.780
questions that was asked about
D is, what happens if a new

00:23:54.780 --> 00:23:56.180
paradigm comes along?

00:23:56.180 --> 00:24:00.650
Is D going to incorporate it,
and the answer was yes.

00:24:04.480 --> 00:24:07.370
I cannot speak for the D
developers and inventors, of

00:24:07.370 --> 00:24:12.020
course, but my impression from
this presentation was that D

00:24:12.020 --> 00:24:16.930
is going to grow very, very
much the same as C++ has

00:24:16.930 --> 00:24:21.580
grown, and I think in Go, we're
tried to do a completely

00:24:21.580 --> 00:24:22.390
different approach.

00:24:22.390 --> 00:24:25.950
We're trying to take things
out as much as we can, to

00:24:25.950 --> 00:24:30.760
reduce them to the bare bones,
the absolute minimum that you

00:24:30.760 --> 00:24:32.530
need to build everything up.

00:24:32.530 --> 00:24:36.880
And if those little pieces are
orthogonal and work well

00:24:36.880 --> 00:24:38.850
together, you actually get
something that is more

00:24:38.850 --> 00:24:42.300
powerful than when you have a
lot of features that kind of

00:24:42.300 --> 00:24:45.140
all scratch each other a little
bit and then have very

00:24:45.140 --> 00:24:48.626
weird side effects that are
difficult to understand.

00:24:48.626 --> 00:24:49.310
AUDIENCE: Thank you.

00:24:49.310 --> 00:24:51.230
ANDREW GERRAND: Maybe you guys
can speak briefly about the

00:24:51.230 --> 00:24:56.490
design process of the language
as well, if you want to.

00:24:56.490 --> 00:24:58.910
ROB PIKE: It was interesting,
for this talk last week, I did

00:24:58.910 --> 00:25:02.730
some archaeology, and I found a
Mail message from the first

00:25:02.730 --> 00:25:05.670
week, actually a thread
with the three of us

00:25:05.670 --> 00:25:06.890
talking about it.

00:25:06.890 --> 00:25:09.920
And it was remarkable to me how
much of the flavor of the

00:25:09.920 --> 00:25:12.300
language emerged in those
first conversations.

00:25:12.300 --> 00:25:16.180
We knew what we wanted, and
fairly quickly converged on a

00:25:16.180 --> 00:25:18.390
rough approach to what
was going on.

00:25:18.390 --> 00:25:21.280
I think one of the most
important things about Go in

00:25:21.280 --> 00:25:25.530
its design is that Robert
comes from a very

00:25:25.530 --> 00:25:30.340
object-oriented, Smalltalk,
Oberon kind of background, Ken

00:25:30.340 --> 00:25:34.270
is Unix and worked on C stuff
and things like that, and I

00:25:34.270 --> 00:25:38.280
have this concurrent point
of view about everything.

00:25:38.280 --> 00:25:40.230
And so we have three completely
different

00:25:40.230 --> 00:25:44.075
worldviews, and to design a
language with three completely

00:25:44.075 --> 00:25:46.040
different worldviews, one thing
you do is just put all

00:25:46.040 --> 00:25:48.470
the ideas in, and whoo,
and you get something.

00:25:48.470 --> 00:25:51.670
But instead, what we did was
make sure that every single

00:25:51.670 --> 00:25:54.570
feature that went into the
language went in only when the

00:25:54.570 --> 00:25:57.230
three of us agreed that it was
the right feature and the

00:25:57.230 --> 00:26:00.560
right design for that feature,
and I think that's a really

00:26:00.560 --> 00:26:06.220
important part of why Go works
so well despite being a fairly

00:26:06.220 --> 00:26:08.196
simple language, at least
in broad strokes.

00:26:08.196 --> 00:26:10.130
Do you agree with that?

00:26:10.130 --> 00:26:11.600
ROBERT GRIESEMER: Yeah, I
would agree with that.

00:26:11.600 --> 00:26:12.690
I want to say one thing.

00:26:12.690 --> 00:26:17.770
I think it was an incredibly
hard process.

00:26:17.770 --> 00:26:22.270
I think there were several times
where I probably yelled

00:26:22.270 --> 00:26:25.920
at Ken Thompson, and then I
would go back in my room and

00:26:25.920 --> 00:26:27.885
said, hey, you don't yell
at Ken Thomson.

00:26:31.954 --> 00:26:33.910
ROB PIKE: Did you yell back?

00:26:33.910 --> 00:26:35.030
KEN THOMPSON: No, no.

00:26:35.030 --> 00:26:42.100
I remember one instance, and
basically, it was almost the

00:26:42.100 --> 00:26:44.980
first day when we wrote a big
list of things on the

00:26:44.980 --> 00:26:49.220
blackboard, and there was one
question that we spent maybe

00:26:49.220 --> 00:26:52.340
10 seconds on.

00:26:52.340 --> 00:26:56.750
Should the declarations be
C-like, like inside out, or

00:26:56.750 --> 00:27:02.170
should they be Pascal-like,
left to right?

00:27:02.170 --> 00:27:04.670
And we said Pascal-like,
and that was it.

00:27:04.670 --> 00:27:07.780
And from then on, decorations
were in, and--

00:27:07.780 --> 00:27:10.110
MALE SPEAKER: Best
decision ever.

00:27:10.110 --> 00:27:12.400
KEN THOMPSON: But one that early
on got a lot of flack.

00:27:12.400 --> 00:27:13.988
AUDIENCE: I think it was
definitely the right decision.

00:27:18.290 --> 00:27:23.320
NIGEL: The next question from
the moderator, what has the

00:27:23.320 --> 00:27:26.245
biggest mistake in Go's design
turned out to be, and how have

00:27:26.245 --> 00:27:27.270
you worked around it?

00:27:27.270 --> 00:27:29.468
Is there a billion dollar
mistake in Go?

00:27:33.460 --> 00:27:35.170
ANDREW GERRAND: So the billion
dollar mistake I guess refers

00:27:35.170 --> 00:27:38.010
to [? null point ?], and yes, Go
has [? null pointers ?], so

00:27:38.010 --> 00:27:40.790
we have the billion dollar
mistake in Go.

00:27:40.790 --> 00:27:43.590
ROB PIKE: And some people don't
like it because of that.

00:27:43.590 --> 00:27:45.162
I don't think it's a billion
dollar mistake,

00:27:45.162 --> 00:27:47.420
but what do I know?

00:27:47.420 --> 00:27:47.830
Mistakes.

00:27:47.830 --> 00:27:52.710
I wish that some of the syntax,
it was a little

00:27:52.710 --> 00:27:53.810
simpler in a few places.

00:27:53.810 --> 00:27:56.620
I think there are too many ways
to declare a variable,

00:27:56.620 --> 00:27:58.710
and there's this whole shadowing
nonsense and

00:27:58.710 --> 00:28:00.750
so on and so on.

00:28:00.750 --> 00:28:04.450
But I don't think there's
a huge single thing

00:28:04.450 --> 00:28:05.660
that I feel is wrong.

00:28:05.660 --> 00:28:09.210
Part of the Go 1 process was
actually going through all of

00:28:09.210 --> 00:28:12.010
the things that were bugging
us and fixing them.

00:28:12.010 --> 00:28:13.950
And so a year ago, the
language looked quite

00:28:13.950 --> 00:28:16.300
different from it does today,
but we fixed a lot of it, and

00:28:16.300 --> 00:28:18.950
a lot of stuff got cleaned up,
and that's precisely what the

00:28:18.950 --> 00:28:21.530
Go 1 release process
was all about.

00:28:21.530 --> 00:28:23.140
So we fixed the things
that were bugging us.

00:28:23.140 --> 00:28:26.956
But for biggest mistake in the
language, I don't know.

00:28:26.956 --> 00:28:27.920
[INAUDIBLE].

00:28:27.920 --> 00:28:30.970
MALE SPEAKER: There's the
scoping of loop variables is

00:28:30.970 --> 00:28:32.050
kind of confusing to
a lot of people.

00:28:32.050 --> 00:28:32.590
ROB PIKE: Scoping for
loop variables.

00:28:32.590 --> 00:28:34.280
That confuses people.

00:28:34.280 --> 00:28:37.210
I think it's fine, but I can see
why a different decision

00:28:37.210 --> 00:28:39.030
would also be fine.

00:28:39.030 --> 00:28:40.980
But this is the kind of thing
you can't just change.

00:28:40.980 --> 00:28:43.760
Once you've decided people using
your language, you can

00:28:43.760 --> 00:28:47.060
change the semantics of a for
loop, that's kind of scary.

00:28:47.060 --> 00:28:48.880
ANDREW GERRAND: That's the one
that I regret, but the reason

00:28:48.880 --> 00:28:50.620
why we decided not to change
it is because it would have

00:28:50.620 --> 00:28:53.697
been incredibly subtle to detect
when people were using

00:28:53.697 --> 00:28:55.880
it [INAUDIBLE].

00:28:55.880 --> 00:28:59.210
AUDIENCE: So what led to your
design decision, in the

00:28:59.210 --> 00:29:01.650
formatting of Go code, the
conical formatting, to use

00:29:01.650 --> 00:29:02.900
tabs instead of spaces?

00:29:05.590 --> 00:29:06.840
ROBERT GRIESEMER: Good taste.

00:29:17.430 --> 00:29:21.860
KEN THOMPSON: If you read the
ASCII spec, it says a tab is

00:29:21.860 --> 00:29:27.410
some number of spaces that set
the tab stops, and so it just

00:29:27.410 --> 00:29:29.670
appears that that's the
definition of what you want

00:29:29.670 --> 00:29:32.810
there, instead of saying
five tabs or

00:29:32.810 --> 00:29:34.380
eight tabs or two tabs--

00:29:34.380 --> 00:29:36.362
spaces, excuse me--

00:29:36.362 --> 00:29:38.680
the answer is a tab.

00:29:38.680 --> 00:29:39.155
It's the definition.

00:29:39.155 --> 00:29:41.300
ANDREW GERRAND: [INAUDIBLE] your
editor render it how you

00:29:41.300 --> 00:29:42.700
want it to look.

00:29:42.700 --> 00:29:45.500
ROBERT GRIESEMER: I wrote Go
[INAUDIBLE], and the reason

00:29:45.500 --> 00:29:48.720
for writing it was unrelated to
this, it was just everyone

00:29:48.720 --> 00:29:51.680
wanted to get rid of some silly
discussions about how

00:29:51.680 --> 00:29:54.020
you format code that
just consumed time.

00:29:54.020 --> 00:29:56.560
But then when it comes to
indentation, I thought,

00:29:56.560 --> 00:30:00.340
everybody has a different style,
and ideally, it would

00:30:00.340 --> 00:30:02.770
be great if everybody could just
look at the code the way

00:30:02.770 --> 00:30:05.310
they want to look at
it in their editor.

00:30:05.310 --> 00:30:08.250
And with indentation, it's
a very contentious thing.

00:30:08.250 --> 00:30:11.440
Some people really want a lot of
indentation, some are happy

00:30:11.440 --> 00:30:15.850
with two spaces or
even one space.

00:30:15.850 --> 00:30:18.220
And the fact of the matter is
you get used to everything.

00:30:18.220 --> 00:30:22.150
But with tabs, you at least have
the chance to actually

00:30:22.150 --> 00:30:26.650
change it in most environments
to be a different size.

00:30:26.650 --> 00:30:30.930
And the idea was that by doing
that, you have a chance to

00:30:30.930 --> 00:30:33.110
actually adjust it to
your personal needs.

00:30:33.110 --> 00:30:34.170
Now it turns out,
I think that's

00:30:34.170 --> 00:30:35.540
probably not true in reality.

00:30:35.540 --> 00:30:40.390
People don't really
change that.

00:30:40.390 --> 00:30:40.810
ROB PIKE: That's not true.

00:30:40.810 --> 00:30:42.000
I know Ken uses eight-space
tabs and I

00:30:42.000 --> 00:30:42.960
use four-space tabs.

00:30:42.960 --> 00:30:45.910
ROBERT GRIESEMER: OK,
there you go.

00:30:45.910 --> 00:30:48.520
Even within the Go Team,
everyone I think uses a

00:30:48.520 --> 00:30:50.980
different editor and everyone
has different preferences on

00:30:50.980 --> 00:30:53.310
syntax highlighting or
fixed-width fonts versus

00:30:53.310 --> 00:30:56.450
variable-width fonts, so I mean,
it's not like we're very

00:30:56.450 --> 00:30:57.970
religious one way or another,
we just use

00:30:57.970 --> 00:30:58.840
what we want to use.

00:30:58.840 --> 00:31:01.260
ROB PIKE: The most important
thing about Go [INAUDIBLE]

00:31:01.260 --> 00:31:04.140
is not the choices it makes
but that it makes them.

00:31:04.140 --> 00:31:05.780
The fact that there's a program

00:31:05.780 --> 00:31:07.500
that formats the code--

00:31:07.500 --> 00:31:09.370
I actually would publicly like
to thank Robert, because I

00:31:09.370 --> 00:31:11.550
think he did an amazing
job on Go [INAUDIBLE].

00:31:11.550 --> 00:31:13.440
It is an incredible tool.

00:31:13.440 --> 00:31:15.570
But it also enables
things that we

00:31:15.570 --> 00:31:18.280
didn't realize upfront.

00:31:18.280 --> 00:31:20.950
Because what [INAUDIBLE] does,
it reads your entire program,

00:31:20.950 --> 00:31:23.590
parses it into a full Go
syntax tree, and then

00:31:23.590 --> 00:31:25.790
reformats in, or maybe
just leaves it

00:31:25.790 --> 00:31:27.580
alone, but it depends.

00:31:27.580 --> 00:31:31.910
But because of that ability to
pick up a tree, a syntax tree

00:31:31.910 --> 00:31:34.830
of a Go program, and generate
human, readable, commented,

00:31:34.830 --> 00:31:38.880
neatly laid-out code, we can
write tools that do things to

00:31:38.880 --> 00:31:41.500
your Go program that would
be very difficult to do

00:31:41.500 --> 00:31:44.070
automatically, like the Go Fix
tool that will go in and

00:31:44.070 --> 00:31:47.760
rewrite your program to bring
it up to date to go on spec.

00:31:47.760 --> 00:31:49.830
That would be almost
inconceivable if we didn't

00:31:49.830 --> 00:31:52.010
have an automatic
code formatter.

00:31:52.010 --> 00:31:54.120
And it's such a powerful idea
that we're starting to think

00:31:54.120 --> 00:31:55.370
about doing it for some
of the other things.

00:31:55.370 --> 00:31:57.740
You can imagine a Make File
version of Go [INAUDIBLE] that

00:31:57.740 --> 00:32:01.370
would let you edit your Make
Files automatically, or

00:32:01.370 --> 00:32:04.270
conceivably, other languages,
Java would probably benefit

00:32:04.270 --> 00:32:05.135
from that kind of thing.

00:32:05.135 --> 00:32:07.440
Being able to rewrite your
program and generate human,

00:32:07.440 --> 00:32:10.390
readable output wasn't the goal
of Go [INAUDIBLE], but it

00:32:10.390 --> 00:32:11.500
turned out to be one of
the most important

00:32:11.500 --> 00:32:12.690
properties about it.

00:32:12.690 --> 00:32:15.790
And if you get tabs instead of
spaces, I think that's a small

00:32:15.790 --> 00:32:17.040
price to pay.

00:32:20.640 --> 00:32:25.190
KEN THOMPSON: For me, before
Go [INAUDIBLE], there was

00:32:25.190 --> 00:32:28.180
continual wars about whether
curly braces were at the end

00:32:28.180 --> 00:32:32.240
or the beginning, or all
sorts of things.

00:32:32.240 --> 00:32:37.080
And while at the time that Go
[INAUDIBLE] was written, I

00:32:37.080 --> 00:32:39.950
didn't agree on all the
decisions, but now, there's no

00:32:39.950 --> 00:32:44.710
wars, there's no arguments, it's
just the way it is, and

00:32:44.710 --> 00:32:47.240
that probably saves half of the
discussions that go on at

00:32:47.240 --> 00:32:49.490
Google over C and C++.

00:32:53.930 --> 00:32:55.960
NIGEL: The next question is
about what's happening with

00:32:55.960 --> 00:32:58.690
garbage collection over the next
six months or so, but I

00:32:58.690 --> 00:33:00.640
think we covered that earlier
with the roadmap.

00:33:00.640 --> 00:33:03.600
So the next question after that,
are there any plans to

00:33:03.600 --> 00:33:06.760
distribute Go Lang threads to
work across similar machines

00:33:06.760 --> 00:33:08.580
to create truly distributed
systems?

00:33:08.580 --> 00:33:11.370
If something like this should
be implemented for Go Lang,

00:33:11.370 --> 00:33:13.230
what do you see as the
challenges that should be

00:33:13.230 --> 00:33:14.220
considered?

00:33:14.220 --> 00:33:17.870
ROB PIKE: That's something
I really love to see.

00:33:17.870 --> 00:33:20.420
I think there's two
ways to do it.

00:33:20.420 --> 00:33:23.670
The way the question
was phrased was to

00:33:23.670 --> 00:33:25.430
distribute the threads.

00:33:25.430 --> 00:33:28.200
That sort of implies some kind
of process migration aspect,

00:33:28.200 --> 00:33:30.640
which is not the way that
I would approach it.

00:33:30.640 --> 00:33:32.690
A long time ago, I wrote a
little toy package called

00:33:32.690 --> 00:33:36.810
netchan, which lets you turn
a channel into a network

00:33:36.810 --> 00:33:39.920
connection so that you can have
two machines sharing a

00:33:39.920 --> 00:33:43.220
network but using the channel
primitives on either end to

00:33:43.220 --> 00:33:44.930
manage their communication.

00:33:44.930 --> 00:33:47.240
And I think that's a really good
idea but I didn't get the

00:33:47.240 --> 00:33:50.530
API right, so we pulled it out
of Go 1, and we've been

00:33:50.530 --> 00:33:52.360
talking again about what
the design for that

00:33:52.360 --> 00:33:53.370
really should be.

00:33:53.370 --> 00:33:55.730
And I think it's a really,
really powerful idea.

00:33:55.730 --> 00:33:58.840
But one of the things we want to
make sure happens when you

00:33:58.840 --> 00:34:01.460
do that is that all of those
patterns I showed you in the

00:34:01.460 --> 00:34:03.060
previous talk still work.

00:34:03.060 --> 00:34:05.630
So you should be able to send
a channel over a netchan and

00:34:05.630 --> 00:34:06.540
stuff like that.

00:34:06.540 --> 00:34:08.800
And getting that done is
actually quite subtle and

00:34:08.800 --> 00:34:11.389
difficult, but we definitely
want to see it.

00:34:11.389 --> 00:34:14.429
I can't promise any date for
it, because it is a hard

00:34:14.429 --> 00:34:18.139
problem, but it's definitely
from the beginning an idea

00:34:18.139 --> 00:34:18.820
that we had.

00:34:18.820 --> 00:34:21.739
I remember Ken and I had a
conversation sometime in the

00:34:21.739 --> 00:34:24.570
first year, we probably had five
conversations about how

00:34:24.570 --> 00:34:26.850
we were going to get channels
and networks together, and we

00:34:26.850 --> 00:34:29.429
never quite figured it out, but
we still really want to

00:34:29.429 --> 00:34:31.415
see it happen.

00:34:31.415 --> 00:34:33.739
I should mention Erlang, by the
way, gets this done, but

00:34:33.739 --> 00:34:36.370
it has a very different model.

00:34:36.370 --> 00:34:38.800
AUDIENCE: So I love Go
concurrency, but I know some

00:34:38.800 --> 00:34:42.460
problems are better solved using
GPU parallelism, and I

00:34:42.460 --> 00:34:46.870
wonder if anyone's using
GPU parallelism in Go.

00:34:50.670 --> 00:34:53.290
ROB PIKE: Not that we know of.

00:34:53.290 --> 00:34:55.040
ANDREW GERRAND: Only in the same
way that they used them

00:34:55.040 --> 00:34:58.130
from C or other languages.

00:34:58.130 --> 00:35:01.560
It's a sweet idea, the idea of
launching a Go routine that

00:35:01.560 --> 00:35:06.530
runs on an auxiliary processor
in some heterogeneous system,

00:35:06.530 --> 00:35:08.985
but it's not something that
exists now, and it's certainly

00:35:08.985 --> 00:35:09.760
a difficult problem.

00:35:09.760 --> 00:35:12.090
ROBERT GRIESEMER: So my
understanding is also that all

00:35:12.090 --> 00:35:15.490
these systems which employ
that parallelism use

00:35:15.490 --> 00:35:19.390
specialized languages for those
GPUs because the GPUs

00:35:19.390 --> 00:35:21.560
pretty much change from year
to year, or even half

00:35:21.560 --> 00:35:22.950
year to half year.

00:35:22.950 --> 00:35:28.090
So I'm not an expert, but I
suspect that if you use it,

00:35:28.090 --> 00:35:32.520
let's say from C, that you're
just invoking or sending those

00:35:32.520 --> 00:35:34.575
snippets of that
other language.

00:35:38.020 --> 00:35:39.520
ROB PIKE: My understanding is
it's actually a compiler that

00:35:39.520 --> 00:35:43.170
runs on the video card, and we
haven't yet managed to port Go

00:35:43.170 --> 00:35:45.650
to a video card, but it would
be cool if we could.

00:35:45.650 --> 00:35:46.900
MALE SPEAKER: If Russ has
a free weekend, maybe.

00:35:51.800 --> 00:35:54.510
NIGEL: The next moderator
question is about Go 1.1

00:35:54.510 --> 00:35:56.400
roadmap, I think we covered
that already.

00:35:56.400 --> 00:35:58.870
The next one, any plans
to port Go to MIPS?

00:35:58.870 --> 00:36:01.340
A lot of embedded hardware
with network support runs

00:36:01.340 --> 00:36:03.820
MIPS, and writing network
software in Go is so much

00:36:03.820 --> 00:36:05.130
easier than in C, C++.

00:36:08.010 --> 00:36:10.520
ANDREW GERRAND: GCC Go should
be able to output code that

00:36:10.520 --> 00:36:11.750
runs on MIPS.

00:36:11.750 --> 00:36:13.480
ROB PIKE: It's already done.

00:36:13.480 --> 00:36:16.040
ANDREW GERRAND: We'd would love
to more users, so anybody

00:36:16.040 --> 00:36:17.440
who's hearing this and
has the hardware--

00:36:17.440 --> 00:36:18.510
BRAD FITZPATRICK: [INAUDIBLE].

00:36:18.510 --> 00:36:18.980
ANDREW GERRAND: Yeah, OK.

00:36:18.980 --> 00:36:21.320
So for those of you who don't
know, we have two compilers

00:36:21.320 --> 00:36:24.830
that the Go Team work on
actively, and there's the GC,

00:36:24.830 --> 00:36:28.330
which is the one that was
based on Ken's Plan 9 C

00:36:28.330 --> 00:36:31.660
compiler design, and that's the
one that you get with the

00:36:31.660 --> 00:36:32.780
standard Go distribution.

00:36:32.780 --> 00:36:39.140
And then in GCC 471, GCC Go will
be included, which is a

00:36:39.140 --> 00:36:42.460
front end for the new
compiler collection.

00:36:42.460 --> 00:36:46.960
And so you can compile Go for
all of the platforms that GCC

00:36:46.960 --> 00:36:50.600
can target within some
constraints, I believe.

00:36:50.600 --> 00:36:52.430
We're publishing a blog
post about this

00:36:52.430 --> 00:36:54.770
within the next week.

00:36:54.770 --> 00:37:00.010
But with GCC Go, I know people
have run stuff on SPOC systems

00:37:00.010 --> 00:37:05.190
and MIPS, Alpha, IRIX, which is
Alpha, and other operating

00:37:05.190 --> 00:37:06.410
systems we don't support,
and so there's a

00:37:06.410 --> 00:37:08.300
lot of scope there.

00:37:08.300 --> 00:37:10.890
But it's not that it's not
supported, it's that it's not

00:37:10.890 --> 00:37:13.080
been well tested, so if you have
these kinds of systems,

00:37:13.080 --> 00:37:16.970
we'd love for you to get GCC Go
and try it out, and let us

00:37:16.970 --> 00:37:20.280
know how it goes.

00:37:20.280 --> 00:37:22.080
ROB PIKE: Both the compiler
suites were written to the

00:37:22.080 --> 00:37:23.990
specs, so as far as
we know, they

00:37:23.990 --> 00:37:25.260
implement the same language.

00:37:25.260 --> 00:37:28.010
Of course, there's probably bugs
and variations, but as

00:37:28.010 --> 00:37:31.410
far as we know, you have no
problem compiling programs on

00:37:31.410 --> 00:37:32.700
either suite and have it work.

00:37:35.920 --> 00:37:40.580
AUDIENCE: So is there a plan to
add versioning to imports

00:37:40.580 --> 00:37:44.170
or external packages?

00:37:44.170 --> 00:37:45.760
ANDREW GERRAND: No,
not at this stage.

00:37:45.760 --> 00:37:50.190
AUDIENCE: Because it's kind of
hard if an external package or

00:37:50.190 --> 00:37:54.030
some library that you're using
changes API and you want to

00:37:54.030 --> 00:37:57.410
use Go Get to get that library,
and it's in a

00:37:57.410 --> 00:37:59.820
different version, you
have to jump in and

00:37:59.820 --> 00:38:03.062
get check out another.

00:38:03.062 --> 00:38:05.150
ANDREW GERRAND: Yeah, I
understand the problem, and

00:38:05.150 --> 00:38:07.590
I'm sure the other Go developers
do as well.

00:38:07.590 --> 00:38:11.480
What we're trying to encourage
Go package authors to do is

00:38:11.480 --> 00:38:13.870
maintain a consistent interface,
and if you go in

00:38:13.870 --> 00:38:16.610
and change the interface, it's
probably wise to change the

00:38:16.610 --> 00:38:19.890
import path as well, and have
a V2 of your library that

00:38:19.890 --> 00:38:22.910
supports a different
kind of interface.

00:38:22.910 --> 00:38:25.100
And that's just part of release
engineering, and I

00:38:25.100 --> 00:38:28.240
think it's something that some
parts of the open source

00:38:28.240 --> 00:38:30.555
community do well, and other
parts that are more ad hoc

00:38:30.555 --> 00:38:33.800
don't really address
very well.

00:38:33.800 --> 00:38:37.850
Brad has more experience
with this domain--

00:38:37.850 --> 00:38:38.760
BRAD FITZPATRICK: I was just
going to point out, you

00:38:38.760 --> 00:38:39.860
shouldn't rely on
that, though.

00:38:39.860 --> 00:38:43.090
I mean, the responsible thing to
deploy code to prod is not

00:38:43.090 --> 00:38:46.320
to have a script that runs
Go Get, which could

00:38:46.320 --> 00:38:47.200
be malicious code.

00:38:47.200 --> 00:38:49.080
Maybe that GetHub author's
account got

00:38:49.080 --> 00:38:50.120
taken over or something.

00:38:50.120 --> 00:38:53.410
So use Go Get during
development, and then once

00:38:53.410 --> 00:38:54.870
you're going to ship something,
put it in your own

00:38:54.870 --> 00:38:57.240
version control system,
snapshot it, whatever.

00:39:00.050 --> 00:39:01.670
ANDREW GERRAND: Also, you don't
have to update all of

00:39:01.670 --> 00:39:03.270
your dependencies every time.

00:39:03.270 --> 00:39:05.890
The default behavior of Go Get
is only to fetch, not to

00:39:05.890 --> 00:39:10.150
update, so get it to a working
state, and then only Dash U

00:39:10.150 --> 00:39:11.880
with Go Get with care.

00:39:14.690 --> 00:39:18.290
AUDIENCE: Are there already
any backwards incompatible

00:39:18.290 --> 00:39:22.150
changes being thought of for
the fabled Go 2 release?

00:39:22.150 --> 00:39:23.070
ROB PIKE: No.

00:39:23.070 --> 00:39:25.600
But that's not to say there
won't be, we just haven't

00:39:25.600 --> 00:39:26.260
thought about it.

00:39:26.260 --> 00:39:28.780
Really, Go 2 is in the
indefinite future.

00:39:28.780 --> 00:39:30.660
It's years away.

00:39:30.660 --> 00:39:32.580
There's been a couple of ideas
that have been mentioned that

00:39:32.580 --> 00:39:35.460
might be Go 2 things, but we're
not thinking about Go 2.

00:39:35.460 --> 00:39:36.610
We're just not.

00:39:36.610 --> 00:39:39.270
We're thinking about taking what
we've built so far and

00:39:39.270 --> 00:39:42.930
using it, because the ideas in
Go 2 will be ideas that we

00:39:42.930 --> 00:39:45.340
develop using Go 1 and
finding out what we

00:39:45.340 --> 00:39:48.020
need to make better.

00:39:48.020 --> 00:39:49.420
ANDREW GERRAND: I think to
answer the question literally,

00:39:49.420 --> 00:39:51.740
I think by necessity, Go 2
would include backwards

00:39:51.740 --> 00:39:52.750
incompatible changes.

00:39:52.750 --> 00:39:54.000
Otherwise, it would just
be Go 1.something.

00:39:57.360 --> 00:39:59.360
AUDIENCE: Are there any plans
to bring a self-hosted

00:39:59.360 --> 00:40:00.610
compiler to Go?

00:40:04.580 --> 00:40:06.780
BRAD FITZPATRICK: I mean, we're
not doing it, but other

00:40:06.780 --> 00:40:08.050
people have discussed it.

00:40:08.050 --> 00:40:11.505
There's a project called LL
Go, which is a Go compiler

00:40:11.505 --> 00:40:16.140
that uses the Go AST and Go
parser and all that, and then

00:40:16.140 --> 00:40:18.050
they're fleshing out the type
checking and then they're

00:40:18.050 --> 00:40:21.820
emitting all the bit
code and whatnot.

00:40:21.820 --> 00:40:23.890
AUDIENCE: What's the reason
behind that decision?

00:40:23.890 --> 00:40:25.330
BRAD FITZPATRICK: Some guy's
having fun with it.

00:40:25.330 --> 00:40:27.050
AUDIENCE: No, I mean what's
the reason behind you guys

00:40:27.050 --> 00:40:29.560
sticking with writing everything
in C instead of

00:40:29.560 --> 00:40:31.515
moving to self-hosted.

00:40:31.515 --> 00:40:33.045
BRAD FITZPATRICK: I mean, the
pragmatic answer is there was

00:40:33.045 --> 00:40:35.370
no Go to write Go in
initially, right?

00:40:35.370 --> 00:40:36.950
I mean, look at Rust.

00:40:36.950 --> 00:40:40.030
They took a long time writing
their compiler in Rust because

00:40:40.030 --> 00:40:41.380
Rust didn't exist.

00:40:41.380 --> 00:40:44.620
It's a route, but it's just a
very slow, painful route.

00:40:44.620 --> 00:40:44.860
AUDIENCE: All right.

00:40:44.860 --> 00:40:45.450
Thank you.

00:40:45.450 --> 00:40:48.820
ROB PIKE: It's much easier to
bootstrap, both locally and to

00:40:48.820 --> 00:40:51.730
other people, if the compiler is
written in a language that

00:40:51.730 --> 00:40:53.830
everybody has.

00:40:53.830 --> 00:40:55.800
ANDREW GERRAND: Russ made a
really good point in the

00:40:55.800 --> 00:41:00.370
recent Q&amp;A session that he did
is that if you're changing a

00:41:00.370 --> 00:41:02.650
language, or if you find a bug
in your language and your

00:41:02.650 --> 00:41:05.400
compiler is written in that
language, it can be a very,

00:41:05.400 --> 00:41:08.370
very difficult process to
correct the bug in your

00:41:08.370 --> 00:41:11.110
language and in the compiler
at the same time.

00:41:11.110 --> 00:41:14.020
You have to sort of bootstrap
the change and propagate it

00:41:14.020 --> 00:41:16.220
through the chain, and there are
people on this stage know

00:41:16.220 --> 00:41:21.460
way more about that than I
do, but it's very hard.

00:41:21.460 --> 00:41:24.460
ROBERT GRIESEMER: But also,
there is actually a

00:41:24.460 --> 00:41:28.000
significant part of a front end
in the library, and as we

00:41:28.000 --> 00:41:31.980
speak, some people in the
community are thinking about

00:41:31.980 --> 00:41:35.040
completing that part so there
would actually be a front end,

00:41:35.040 --> 00:41:38.496
at least for a compiler, where
somebody could hook up a back

00:41:38.496 --> 00:41:39.746
end if they wanted to.

00:41:41.970 --> 00:41:43.010
ROB PIKE: Go is a fine
language for writing

00:41:43.010 --> 00:41:45.650
compilers, it's just we haven't
taken it on yet.

00:41:45.650 --> 00:41:47.790
And I think maturity will
probably lead to one at some

00:41:47.790 --> 00:41:50.250
point, but we have no
plans at the moment.

00:41:50.250 --> 00:41:52.090
We're working on using
it rather than

00:41:52.090 --> 00:41:53.340
rewriting the compiler.

00:41:56.800 --> 00:41:59.590
AUDIENCE: Are there any plans
to add anything like DL Open

00:41:59.590 --> 00:42:01.795
or DY Sim to Go for dynamically

00:42:01.795 --> 00:42:03.100
loading code at runtime?

00:42:09.600 --> 00:42:11.280
ANDREW GERRAND: No.

00:42:11.280 --> 00:42:12.220
ROB PIKE: There are no plans.

00:42:12.220 --> 00:42:15.180
I will admit that although Go
is statically linked, and in

00:42:15.180 --> 00:42:17.840
the first session today,
everyone on the panel, I

00:42:17.840 --> 00:42:21.100
think, said how important that
was to their deployment.

00:42:21.100 --> 00:42:23.960
So having a statically-linked
binary is a really important

00:42:23.960 --> 00:42:26.880
part of what makes Go nice
to use and deploy.

00:42:26.880 --> 00:42:29.050
I do think there's a real merit
in having a dynamic

00:42:29.050 --> 00:42:33.050
loadable module, which is a
slightly different point, and

00:42:33.050 --> 00:42:34.590
I actually would kind of like
to see that happen.

00:42:34.590 --> 00:42:37.490
I don't think it's terribly
difficult, but there are no

00:42:37.490 --> 00:42:38.660
plans to do so.

00:42:38.660 --> 00:42:39.790
I do understand the
distinction,

00:42:39.790 --> 00:42:41.040
and it might be cool.

00:42:44.455 --> 00:42:45.940
MALE SPEAKER: [INAUDIBLE].

00:42:45.940 --> 00:42:46.360
ROB PIKE: Does what?

00:42:46.360 --> 00:42:47.860
Where would you see Go?

00:42:47.860 --> 00:42:49.800
MALE SPEAKER: Using DL Open?

00:42:49.800 --> 00:42:51.188
ROB PIKE: I haven't tried
it, I don't know.

00:42:51.188 --> 00:42:52.438
MALE SPEAKER: [INAUDIBLE].

00:42:54.540 --> 00:42:57.010
AUDIENCE: How large is the
largest known Go project, and

00:42:57.010 --> 00:42:58.440
the longest one running
in production?

00:43:06.030 --> 00:43:07.390
ANDREW GERRAND: YouTube's
[? vtest ?]

00:43:07.390 --> 00:43:12.550
project, which is [INAUDIBLE],
I think is in the realm of

00:43:12.550 --> 00:43:14.760
approaching 100K.

00:43:14.760 --> 00:43:20.220
That sounds a bit
high, above 50.

00:43:20.220 --> 00:43:23.152
It's hard to say because I, like
the guys that we had on

00:43:23.152 --> 00:43:25.350
the stage today, I don't know
how big their code bases are,

00:43:25.350 --> 00:43:26.570
probably sizable.

00:43:26.570 --> 00:43:30.370
But just on the weekend I met
somebody from a fairly large

00:43:30.370 --> 00:43:33.460
company who said, when he met me
and learned what I did, he

00:43:33.460 --> 00:43:34.920
said, thank you so
much for Go.

00:43:34.920 --> 00:43:36.780
We use it everywhere
in our company.

00:43:36.780 --> 00:43:38.830
And so I had no idea
they were using it,

00:43:38.830 --> 00:43:39.620
they didn't tell anybody.

00:43:39.620 --> 00:43:43.020
And so I think there are a lot
of people that use Go that

00:43:43.020 --> 00:43:45.200
don't go out and just send us
an email about it, hey, I'm

00:43:45.200 --> 00:43:46.415
using your product.

00:43:46.415 --> 00:43:49.250
There's a lot of stuff that
exists that is not out there.

00:43:49.250 --> 00:43:52.340
But certainly, we're using
it inside Google.

00:43:52.340 --> 00:43:56.410
Unfortunately, we can't go into
great detail about that.

00:43:56.410 --> 00:43:58.480
ROBERT GRIESEMER: You should
also remember that a 50K Go

00:43:58.480 --> 00:44:02.860
program is really a
100K C program.

00:44:02.860 --> 00:44:05.470
ROB PIKE: Go Doc is also quite
big and it runs in production,

00:44:05.470 --> 00:44:06.660
and it's been running
for quite awhile,

00:44:06.660 --> 00:44:07.900
several years now.

00:44:07.900 --> 00:44:10.755
The YouTube project has been
running in production for at

00:44:10.755 --> 00:44:14.030
least a year or more, long
before they open sourced it.

00:44:14.030 --> 00:44:19.640
So there's serious examples of
large programs running for a

00:44:19.640 --> 00:44:21.760
long time in production,
but I don't know what

00:44:21.760 --> 00:44:23.970
the specifics are.

00:44:23.970 --> 00:44:25.090
AUDIENCE: I'd be very surprised
if this hasn't been

00:44:25.090 --> 00:44:28.840
asked before, but given that
Ken is famous for paper

00:44:28.840 --> 00:44:31.880
reflections on trusting trust,
where you can build a compiler

00:44:31.880 --> 00:44:33.600
that builds a back door into
itself each time you compile

00:44:33.600 --> 00:44:38.160
it with itself, how do we know
that we can trust Go?

00:44:38.160 --> 00:44:40.380
KEN THOMPSON: Well, if you read
the paper, you can't.

00:44:44.030 --> 00:44:49.340
Somebody said, I think in a
[? Turing ?] lecture, not me,

00:44:49.340 --> 00:44:55.440
that the popularity of a
language is guaranteed when

00:44:55.440 --> 00:44:58.060
you get your first virus
in that language.

00:44:58.060 --> 00:45:04.620
And I've heard that the first
virus in Go has come around.

00:45:04.620 --> 00:45:05.870
ROB PIKE: We're on the
world stage now.

00:45:09.790 --> 00:45:11.950
AUDIENCE: Are there any plans
or desires to revise some of

00:45:11.950 --> 00:45:16.650
the old abandoned Go ports, Tiny
Go, Native Client, which

00:45:16.650 --> 00:45:18.890
were proofs of concept and which
were really meant to be

00:45:18.890 --> 00:45:20.140
fully developed?

00:45:23.300 --> 00:45:24.620
ANDREW GERRAND: I was going
to say, tiny was really an

00:45:24.620 --> 00:45:27.400
experiment and I don't think
Russ ever intended to take

00:45:27.400 --> 00:45:30.050
that further as something
bigger.

00:45:30.050 --> 00:45:33.700
The Native Client port of Go
was something that we were

00:45:33.700 --> 00:45:36.450
serious about at the time, but
the Native Client platform has

00:45:36.450 --> 00:45:40.050
kind of changed direction a bit,
and now they are focusing

00:45:40.050 --> 00:45:45.170
on people exporting [INAUDIBLE]
code, it's called

00:45:45.170 --> 00:45:48.800
[? Pinochle ?], and it uses an
LLVM back end to dynamically

00:45:48.800 --> 00:45:51.870
generate machine code on
various platforms.

00:45:51.870 --> 00:45:56.630
And so that would necessitate
a way of producing Go code

00:45:56.630 --> 00:45:59.830
that's in LLVM's intermediate
language, and that's something

00:45:59.830 --> 00:46:01.940
that we would love to do and
would love to see happen, but

00:46:01.940 --> 00:46:04.409
it's not something that we're
actively looking for, no.

00:46:08.850 --> 00:46:11.180
AUDIENCE: How much do I need to
pay to keep generics out of

00:46:11.180 --> 00:46:13.590
the language?

00:46:13.590 --> 00:46:14.840
ANDREW GERRAND: How
much have you got?

00:46:18.530 --> 00:46:21.310
AUDIENCE: Next question, how
close does GCC go to running

00:46:21.310 --> 00:46:25.282
in front of non-GCC back
ends like Clang?

00:46:25.282 --> 00:46:26.970
ROB PIKE: I don't know
if anyone's actually

00:46:26.970 --> 00:46:28.520
actively doing it.

00:46:28.520 --> 00:46:31.360
Certainly, one of the most
remarkable achievements about

00:46:31.360 --> 00:46:35.110
GCC Go is that it's released as
part of the GCC package but

00:46:35.110 --> 00:46:37.280
it's not under GPL.

00:46:37.280 --> 00:46:39.700
And the reason for that is that
Ian really wants to see

00:46:39.700 --> 00:46:42.850
someone build an LLVM back end,
or at least he wants the

00:46:42.850 --> 00:46:45.170
freedom for someone to
be able to do that.

00:46:45.170 --> 00:46:49.730
And we're just waiting for
someone who wants Go thinks of

00:46:49.730 --> 00:46:51.190
it as a challenge
to make it work.

00:46:51.190 --> 00:46:56.630
As far as I know, nothing active
is underway, but it

00:46:56.630 --> 00:47:00.030
would be whatever amount of work
that is, and should be

00:47:00.030 --> 00:47:02.520
fairly straightforward unless
I misunderstand something.

00:47:06.380 --> 00:47:08.530
AUDIENCE: Any plans to create
an official third party

00:47:08.530 --> 00:47:12.280
software repository like
Python, Pipel,

00:47:12.280 --> 00:47:14.890
PERL CPAN, Ruby Gems?

00:47:14.890 --> 00:47:15.930
ANDREW GERRAND: Absolutely.

00:47:15.930 --> 00:47:19.470
So there's a fantastic site at
the moment called Go Package

00:47:19.470 --> 00:47:22.580
Doc that was developed by a
guy named Gary [? Bird, ?]

00:47:22.580 --> 00:47:25.745
and it's a system that allows
you to view the documentation

00:47:25.745 --> 00:47:29.630
of any Go Package that's
publicly accessible in a web

00:47:29.630 --> 00:47:31.990
browser, and that's a real
asset to the community.

00:47:31.990 --> 00:47:35.430
And we've been talking about
taking this further and

00:47:35.430 --> 00:47:39.690
turning it into a package index
and a search engine, and

00:47:39.690 --> 00:47:41.990
we've got some really exciting
plans, it's just a matter

00:47:41.990 --> 00:47:43.880
doing it now.

00:47:43.880 --> 00:47:47.010
But I think the one notable
difference between the

00:47:47.010 --> 00:47:51.810
approach we're looking at and
the approach of things like

00:47:51.810 --> 00:47:56.860
CPAN or some of the other
repositories is that it's not

00:47:56.860 --> 00:48:00.830
going to be human curated but
rather machine curated, and we

00:48:00.830 --> 00:48:06.440
feel like that might yield some
advantages in some ways.

00:48:06.440 --> 00:48:08.160
BRAD FITZPATRICK: The other
important difference is that

00:48:08.160 --> 00:48:11.850
Go's name space is DNS,
you use a URL to

00:48:11.850 --> 00:48:12.700
describe your package.

00:48:12.700 --> 00:48:15.920
So it's not like PERL CPAN where
you upload it and you

00:48:15.920 --> 00:48:18.270
have some central group of
people that say, you're

00:48:18.270 --> 00:48:20.560
allowed to use that name.

00:48:20.560 --> 00:48:22.850
So we don't have a central
naming authority, which is

00:48:22.850 --> 00:48:24.660
kind of implicit with
a central model.

00:48:24.660 --> 00:48:29.070
So you can be GetHub.com slash
whatever, code.Google.com or

00:48:29.070 --> 00:48:31.478
whatever, and that's
your import path.

00:48:35.150 --> 00:48:37.070
ROB PIKE: And that was a very
deliberate decision for just

00:48:37.070 --> 00:48:38.350
this reason.

00:48:38.350 --> 00:48:41.560
We'd like to make it be
automated, and it's an ongoing

00:48:41.560 --> 00:48:43.680
challenge to figure out how
best to do that, but it's

00:48:43.680 --> 00:48:44.930
really what we want to see.

00:48:47.080 --> 00:48:48.810
AUDIENCE: Are there any plans
on adding the ability to

00:48:48.810 --> 00:48:50.090
call Go from C?

00:48:50.090 --> 00:48:53.180
In order for me to really use
it as a systems language, I

00:48:53.180 --> 00:48:55.520
need to be able to bind to
it from another language.

00:48:55.520 --> 00:48:58.170
Most languages have the ability
to call a C interface.

00:49:01.894 --> 00:49:04.690
ROB PIKE: You can call
one direction.

00:49:04.690 --> 00:49:06.570
BRAD FITZPATRICK: You can't
embed Go in C currently.

00:49:06.570 --> 00:49:09.940
Go needs to be main to set
things up, but it keeps coming

00:49:09.940 --> 00:49:11.940
up, and people inside
Google want it to.

00:49:11.940 --> 00:49:14.250
So I think Ian has said he wants
to make it work, and

00:49:14.250 --> 00:49:17.030
Russ has said he wants to make
it work, so it's definitely on

00:49:17.030 --> 00:49:17.420
some roadmap.

00:49:17.420 --> 00:49:18.570
I don't know.

00:49:18.570 --> 00:49:20.540
ROB PIKE: The issue here, for
those who don't know, is

00:49:20.540 --> 00:49:23.590
there's a thing called C Go,
which lets you call a C

00:49:23.590 --> 00:49:27.730
program from Go, and that
works reasonably well.

00:49:27.730 --> 00:49:29.710
A lot of people use it for
various things and some

00:49:29.710 --> 00:49:32.195
critical parts of the library
use it to do things like DNS

00:49:32.195 --> 00:49:34.080
look-ups and stuff.

00:49:34.080 --> 00:49:36.780
The problem is that the Go
runtime owns memory, owns the

00:49:36.780 --> 00:49:40.340
stack, and there's a calling
convention issue across that

00:49:40.340 --> 00:49:43.830
boundary, which means that at
the moment, you can only use

00:49:43.830 --> 00:49:44.830
it to go one way.

00:49:44.830 --> 00:49:48.480
So Go has to be running main.

00:49:48.480 --> 00:49:51.860
The piece that's missing but is
going to come, although I

00:49:51.860 --> 00:49:55.350
don't know when, is that C
programs should be able to be

00:49:55.350 --> 00:49:57.410
the main program and
call a Go library.

00:49:57.410 --> 00:49:58.370
That's the piece
that's missing.

00:49:58.370 --> 00:50:00.010
BRAD FITZPATRICK: To be clear,
you can still call from Go

00:50:00.010 --> 00:50:01.890
into C, you just have
to start in Go.

00:50:01.890 --> 00:50:03.770
You can go to C back to Go,
and that works fine.

00:50:03.770 --> 00:50:07.480
So you could make a tiny, tiny
Go program that embeds your C

00:50:07.480 --> 00:50:12.470
code as like the first and only
line of your Go program.

00:50:12.470 --> 00:50:15.340
That works, it's just
kind of a hack.

00:50:15.340 --> 00:50:18.760
ROB PIKE: Also, if C++ is the
language you want, there's the

00:50:18.760 --> 00:50:22.130
SWIG interface, Go is fully
supported by SWIG, but the

00:50:22.130 --> 00:50:24.910
same kind of constraints apply
there because it uses C Go

00:50:24.910 --> 00:50:28.390
under the covers I believe,
although I'm not sure.

00:50:28.390 --> 00:50:30.270
ANDREW GERRAND: There is some
work in the community

00:50:30.270 --> 00:50:31.410
towards this goal.

00:50:31.410 --> 00:50:35.150
I know that there's a Python
function call interface so

00:50:35.150 --> 00:50:38.420
that you can call into Go code
from Python, and it's in the

00:50:38.420 --> 00:50:41.110
early stages of its development,
but it works.

00:50:41.110 --> 00:50:44.050
So there's some momentum.

00:50:44.050 --> 00:50:45.980
ROB PIKE: And you can also call
PERL from Go, right Brad?

00:50:50.040 --> 00:50:52.160
AUDIENCE: Is there any interest
amongst the Go team

00:50:52.160 --> 00:50:55.070
in writing a new operating
system?

00:50:55.070 --> 00:50:56.320
ROB PIKE: No.

00:50:59.460 --> 00:51:01.570
AUDIENCE: Are there serious
plans to support static

00:51:01.570 --> 00:51:03.560
linking of libraries
called in by C Go?

00:51:09.310 --> 00:51:11.220
BRAD FITZPATRICK: It just
doesn't work right now, but

00:51:11.220 --> 00:51:12.980
people want it.

00:51:12.980 --> 00:51:15.290
It's just work, I guess,
not by me.

00:51:18.240 --> 00:51:21.140
AUDIENCE: Which is your favorite
misfeature in Go?

00:51:21.140 --> 00:51:23.910
By that, I mean, which feature
from other languages are you

00:51:23.910 --> 00:51:25.510
most happy Go is missing?

00:51:25.510 --> 00:51:26.825
Inheritance, exceptions?

00:51:35.410 --> 00:51:38.730
ROBERT GRIESEMER: I think I'm
happy that there's a lot of

00:51:38.730 --> 00:51:40.000
the [? 00 ?]

00:51:40.000 --> 00:51:43.750
not present that is in other
languages, because it allows

00:51:43.750 --> 00:51:50.240
you to think about your task
at hand, as opposed to the

00:51:50.240 --> 00:51:58.920
hierarchy or type system which
you then have to shape into

00:51:58.920 --> 00:52:01.710
whatever you want to do.

00:52:01.710 --> 00:52:05.280
DAVID SIMONS: I like the lack
of uninitialized variables,

00:52:05.280 --> 00:52:06.310
it's pretty good.

00:52:06.310 --> 00:52:08.450
ROB PIKE: That's not
exactly the same.

00:52:08.450 --> 00:52:12.930
I'd like to echo what Robert
said and point out that if you

00:52:12.930 --> 00:52:18.200
have a program in Java or C++,
you pretty much start by

00:52:18.200 --> 00:52:21.020
designing your type hierarchy,
and that's something you don't

00:52:21.020 --> 00:52:23.170
even do in Go, so that's
one point.

00:52:23.170 --> 00:52:25.700
But a sort of deeper point is
that it's a fair bit of work

00:52:25.700 --> 00:52:27.820
to do that, and there's a lot of
structure you have to build

00:52:27.820 --> 00:52:30.800
in order to use the types in
that hierarchy, and that means

00:52:30.800 --> 00:52:32.750
that if you find out after
a few days' work that the

00:52:32.750 --> 00:52:35.960
hierarchy's not quite the way
you wanted it, going back and

00:52:35.960 --> 00:52:37.550
changing it might not
be an option because

00:52:37.550 --> 00:52:38.820
it's too much work.

00:52:38.820 --> 00:52:42.730
So Go, by not having that type
hierarchy, makes it much

00:52:42.730 --> 00:52:46.370
easier to adapt the program as
it develops, because that

00:52:46.370 --> 00:52:49.960
structure just isn't there to
force a certain style on the

00:52:49.960 --> 00:52:50.690
rest of the program.

00:52:50.690 --> 00:52:51.940
Would you agree with that?

00:52:54.566 --> 00:52:56.770
ROBERT GRIESEMER: I think that's
exactly what happens

00:52:56.770 --> 00:52:58.290
when you write a large
piece of software.

00:52:58.290 --> 00:53:00.830
In the beginning, you think you
know what your structure,

00:53:00.830 --> 00:53:02.170
you sort of design it.

00:53:02.170 --> 00:53:03.030
It's not quite right.

00:53:03.030 --> 00:53:04.880
For the first couple of weeks,
you're going to tweak it,

00:53:04.880 --> 00:53:07.690
you're going to be a good
citizen and refactor and

00:53:07.690 --> 00:53:11.520
organize, and at some point you
hit 20,000 lines of code

00:53:11.520 --> 00:53:15.040
or whatever, and at that point,
if a bar comes up that

00:53:15.040 --> 00:53:18.460
really would require you to do
a massive refactoring, you're

00:53:18.460 --> 00:53:22.131
just not going to do it, and
your program is going to start

00:53:22.131 --> 00:53:27.390
to just look ugly and you're
going to hack it.

00:53:27.390 --> 00:53:30.680
ROB PIKE: Also, another thing
I don't miss is what I call

00:53:30.680 --> 00:53:36.500
stuttering, where the C style
of declarations maps to

00:53:36.500 --> 00:53:38.580
object-oriented programming
style, which you

00:53:38.580 --> 00:53:40.320
see in Java and C++.

00:53:40.320 --> 00:53:44.030
You get a lot of string string
equals new string kind of

00:53:44.030 --> 00:53:47.050
thing, except string is much
longer than string.

00:53:47.050 --> 00:53:50.180
And in Go, the declaration
style, this is one of the

00:53:50.180 --> 00:53:52.600
reasons we went with Pascal
style, is it gives you a

00:53:52.600 --> 00:53:56.260
chance to elide a lot of the
noise in the declarations and

00:53:56.260 --> 00:53:59.340
simply derive the type from the
expression, and that saves

00:53:59.340 --> 00:54:00.890
a remarkable amount
of typing and a

00:54:00.890 --> 00:54:02.140
remarkable amount of typing.

00:54:08.350 --> 00:54:12.330
ANDREW GERRAND: I really
appreciate not having optional

00:54:12.330 --> 00:54:15.230
arguments to functions so that
functions always have a

00:54:15.230 --> 00:54:18.440
specific set of arguments and
that's what it takes.

00:54:18.440 --> 00:54:21.200
I find in terms of readability,
that's awesome.

00:54:21.200 --> 00:54:26.160
By the same token, things like
this comprehensions, or even

00:54:26.160 --> 00:54:26.710
[INAUDIBLE]

00:54:26.710 --> 00:54:30.370
operators, these are things that
make code more convenient

00:54:30.370 --> 00:54:32.370
to write, but they make it much
more difficult to read.

00:54:35.630 --> 00:54:38.810
When I first started using Go,
I sort of found myself

00:54:38.810 --> 00:54:40.250
feeling, oh, I have to
write this for loop

00:54:40.250 --> 00:54:41.840
again, and so on.

00:54:41.840 --> 00:54:47.210
But now, the benefits have
manifested really strongly in

00:54:47.210 --> 00:54:50.100
interoperating with other
people's code.

00:54:50.100 --> 00:54:52.360
I think somebody else already
mentioned this too, but it's

00:54:52.360 --> 00:54:54.740
really empowering to be able
to put all your code in one

00:54:54.740 --> 00:54:59.210
file, and not being enforced to
have header files or have

00:54:59.210 --> 00:55:02.610
one file per class, or whatever
your import name is,

00:55:02.610 --> 00:55:03.410
have the file.

00:55:03.410 --> 00:55:05.320
Just like, you can hack
something up and then

00:55:05.320 --> 00:55:08.520
structure it later so it's
readable for other people, but

00:55:08.520 --> 00:55:10.240
you don't have to context switch
while you're writing

00:55:10.240 --> 00:55:11.990
code, jumping around files.

00:55:11.990 --> 00:55:13.590
ROB PIKE: There was a question
earlier about the design

00:55:13.590 --> 00:55:16.610
process, and another thing that
we really struggled with,

00:55:16.610 --> 00:55:19.040
but you can't tell now looking
at the language, is what a

00:55:19.040 --> 00:55:20.250
package was.

00:55:20.250 --> 00:55:22.665
There were endless debates about
the structure of package

00:55:22.665 --> 00:55:24.370
and how it went together.

00:55:24.370 --> 00:55:28.400
And it looks like it's sort of
obvious, but it was a really

00:55:28.400 --> 00:55:30.270
difficult thing to
figure that out.

00:55:30.270 --> 00:55:33.780
And maybe we were just stupid,
or maybe we were burned by

00:55:33.780 --> 00:55:36.110
using the wrong languages for
too long, but I think that is

00:55:36.110 --> 00:55:39.820
something that worked out
really, really well.

00:55:39.820 --> 00:55:43.700
AUDIENCE: What's the feedback
been from novice programmers?

00:55:43.700 --> 00:55:48.390
A lot of people using Go, and
everyone probably in this room

00:55:48.390 --> 00:55:52.040
is very experienced
in programming.

00:55:52.040 --> 00:55:54.760
But what about people new to
programming when they look at

00:55:54.760 --> 00:55:55.460
Go programs?

00:55:55.460 --> 00:55:57.220
What's their feedback been?

00:55:57.220 --> 00:55:58.750
ANDREW GERRAND: So I've taught
a bunch of classes at

00:55:58.750 --> 00:56:03.040
universities in Go, and I've
found that most people who

00:56:03.040 --> 00:56:06.410
have a very beginner level of
knowledge of programming in

00:56:06.410 --> 00:56:09.590
languages like C or Java pick
it up pretty quickly.

00:56:09.590 --> 00:56:14.010
The main stumbling block that
people who come from non-C

00:56:14.010 --> 00:56:17.580
backgrounds have is
with pointers.

00:56:17.580 --> 00:56:22.490
But I think that's just a
natural reaction when you've

00:56:22.490 --> 00:56:24.420
been using a language like Java,
which has pointers but

00:56:24.420 --> 00:56:26.930
just ties them behind the
concept of references, it's

00:56:26.930 --> 00:56:29.080
very strange to just deal
with them explicitly.

00:56:29.080 --> 00:56:33.380
But then people who came from
C who were beginners, I

00:56:33.380 --> 00:56:36.980
actually had a few come up to me
afterwards and say, wow, I

00:56:36.980 --> 00:56:39.080
actually understand pointers
now after using Go.

00:56:39.080 --> 00:56:43.140
It's so much easier than doing
it in C, even though just

00:56:43.140 --> 00:56:44.950
semantically, they're pretty
much the same.

00:56:47.670 --> 00:56:50.230
But I actually think that Go
is a fantastic teaching

00:56:50.230 --> 00:56:53.023
language, and I would love it
if universities and other

00:56:53.023 --> 00:56:56.850
training academies would take it
on as a teaching language.

00:56:56.850 --> 00:56:59.030
I think it's really well-suited
to that.

00:57:04.430 --> 00:57:07.000
AUDIENCE: In the early design
of Go, was there much

00:57:07.000 --> 00:57:09.700
consideration in incorporating
more functional language

00:57:09.700 --> 00:57:11.980
influence, something maybe
very fundamental, like a

00:57:11.980 --> 00:57:14.840
polymorphic type system, or
something a little bit easier,

00:57:14.840 --> 00:57:19.960
like having the API incorporated
[INAUDIBLE]?

00:57:19.960 --> 00:57:21.800
ROB PIKE: We had to talk
Ken into what's there.

00:57:24.400 --> 00:57:27.140
Early on, the closures
actually weren't true

00:57:27.140 --> 00:57:28.932
closures, they were just
function literals and you had

00:57:28.932 --> 00:57:31.770
to pass in all the parameters.

00:57:31.770 --> 00:57:33.680
It took awhile to convince
ourselves that we could

00:57:33.680 --> 00:57:35.920
actually do them efficiently
inside a compiled language,

00:57:35.920 --> 00:57:37.230
and there was a fair
bit of work.

00:57:37.230 --> 00:57:39.760
There's even a little bit of
runtime code generation when

00:57:39.760 --> 00:57:43.580
you run a lambda inside Go.

00:57:43.580 --> 00:57:46.070
It's not our background
functional languages exactly,

00:57:46.070 --> 00:57:49.840
I mean, I've written a lot of
LISP in my time, and I really

00:57:49.840 --> 00:57:51.590
think they're important, a
really important part of

00:57:51.590 --> 00:57:53.470
concurrent programming is the
ability to launch into little

00:57:53.470 --> 00:57:55.850
tiny computations, so it's
really important that we have

00:57:55.850 --> 00:58:00.480
the power, but the short answer
to your question is no.

00:58:00.480 --> 00:58:04.930
We didn't want to push harder
in that direction, although

00:58:04.930 --> 00:58:07.520
now looking back on it, I
kind of think we have.

00:58:07.520 --> 00:58:10.510
But I do think that what's there
is pretty expressive,

00:58:10.510 --> 00:58:12.812
because you do get true
lambdas and all that.

00:58:16.050 --> 00:58:18.160
ROBERT GRIESEMER: Yeah, I
think that's pretty much

00:58:18.160 --> 00:58:18.830
summarizing it.

00:58:18.830 --> 00:58:24.610
I think having the true closures
is a major boon for

00:58:24.610 --> 00:58:31.570
the language, and it wasn't
there in the beginning, and I

00:58:31.570 --> 00:58:36.260
actually wanted them from day
one, but we have them now, so

00:58:36.260 --> 00:58:40.070
I'm really happy about that.

00:58:40.070 --> 00:58:42.850
AUDIENCE: I really enjoy
programming with Go routines

00:58:42.850 --> 00:58:47.560
and channels, but I've also
been reading about data

00:58:47.560 --> 00:58:50.300
structures that can be accessed
safely from multiple

00:58:50.300 --> 00:58:51.330
threads in other languages.

00:58:51.330 --> 00:58:54.990
Is there any interest in adding
data structures to the

00:58:54.990 --> 00:58:57.880
standard library or to the
language that can be used

00:58:57.880 --> 00:59:01.870
safely from different
Go routines?

00:59:01.870 --> 00:59:03.670
ROB PIKE: There is a library,
the Sync Library, that lets

00:59:03.670 --> 00:59:06.140
you do the protection
yourself.

00:59:06.140 --> 00:59:08.200
I think the question you're
really asking is whether

00:59:08.200 --> 00:59:10.000
there's a notion of
immutability on

00:59:10.000 --> 00:59:12.900
the horizon for stuff?

00:59:12.900 --> 00:59:13.820
Is that what you're
getting at?

00:59:13.820 --> 00:59:18.940
AUDIENCE: Well, that's one side
of it, and there's also

00:59:18.940 --> 00:59:21.540
lock-free data structures that
people are playing with in

00:59:21.540 --> 00:59:24.800
Java and C++ that might be
interesting, like map data

00:59:24.800 --> 00:59:27.700
structures and list data
structures that could be used

00:59:27.700 --> 00:59:30.530
safely, so we don't have
to synchronize

00:59:30.530 --> 00:59:32.470
explicitly across channels.

00:59:32.470 --> 00:59:35.140
ROB PIKE: Dmitri Vyukov, who was
mentioned before, is doing

00:59:35.140 --> 00:59:37.700
garbage collector and scheduler
work, is probably as

00:59:37.700 --> 00:59:41.020
good at lock-free stuff as
anybody you might know, and I

00:59:41.020 --> 00:59:43.800
suspect in time, he will start
putting that stuff in.

00:59:43.800 --> 00:59:46.440
He's actually mooted a few
things like that already.

00:59:46.440 --> 00:59:49.810
I think there will be some
of those coming in.

00:59:49.810 --> 00:59:53.210
ROBERT GRIESEMER: I want to add,
there's also of course

00:59:53.210 --> 00:59:57.350
the lessons learned from Java
perhaps where many data

00:59:57.350 --> 01:00:00.050
structures were built from day
one so they could be used

01:00:00.050 --> 01:00:03.620
concurrently, and so they all
do locking, and it's an

01:00:03.620 --> 01:00:08.970
incredibly expensive proposition
in many ways, and

01:00:08.970 --> 01:00:11.930
it's not clear that it's the
right way to approach things.

01:00:11.930 --> 01:00:13.680
AUDIENCE: That was definitely
a mistake in Java it seems,

01:00:13.680 --> 01:00:16.220
for performance.

01:00:16.220 --> 01:00:17.520
ANDREW GERRAND: Thanks.

01:00:17.520 --> 01:00:17.890
All right.

01:00:17.890 --> 01:00:20.400
Well, we've done a full hour of
questions, which is great.

01:00:20.400 --> 01:00:23.730
Thank you everybody, for coming
along, and thanks, Go

01:00:23.730 --> 01:00:25.120
guys, for answering
all the questions.

