WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.410
 <i>Android patterns for performance</i> 

00:00:02.770 --> 00:00:05.540
 If there is one law of performance for everyone to follow, 

00:00:05.540 --> 00:00:07.750
 It avoids unnecessary actions. 

00:00:08.040 --> 00:00:09.200
 I'm Joanna Smith. 

00:00:09.200 --> 00:00:12.130
 Although it sounds simple, you may face a challenge in locating places 

00:00:12.130 --> 00:00:15.004
 Where your software instructions waste time on things that are not important. 

00:00:15.384 --> 00:00:17.550
 Let me show you an example so you can imagine it, 

00:00:17.550 --> 00:00:19.170
 It is excessive writing. 

00:00:19.480 --> 00:00:22.540
 Overwrite occurs when you type your application for pixels on the screen 

00:00:22.540 --> 00:00:25.862
 Just for another pixel or width to overwrite it later. 

00:00:26.312 --> 00:00:28.990
 All this I did to add color to the pixel the first time 

00:00:28.990 --> 00:00:30.590
 Is something totally useless. 

00:00:31.110 --> 00:00:33.020
 It is a repair technique that is called screening 

00:00:33.020 --> 00:00:34.700
 It means removing the code 

00:00:34.700 --> 00:00:37.360
 Or the situation in which treatment time is wasted. 

00:00:37.800 --> 00:00:40.410
 Sorting only takes you away from this 

00:00:40.410 --> 00:00:43.209
 But from "Off" to "F". 

00:00:43.869 --> 00:00:45.910
 To actually fix excessive writing problems, 

00:00:45.910 --> 00:00:47.450
 Try isolating screen parts 

00:00:47.450 --> 00:00:49.450
 Which you want to type but will not appear to the user 

00:00:49.450 --> 00:00:50.690
 Then avoid typing it. 

00:00:51.130 --> 00:00:53.220
 Since we are talking about this subject, we discuss the writing. 

00:00:53.220 --> 00:00:56.254
 Write down objects writing time, memory and battery. 

00:00:56.254 --> 00:00:59.030
 If possible, select views that will not participate in the final scene 

00:00:59.030 --> 00:01:01.418
 Avoid typing and will retrieve some frame time, 

00:01:01.860 --> 00:01:04.168
 Such as those that are overwritten when hidden 

00:01:04.168 --> 00:01:05.570
 By another layer of objects. 

00:01:05.570 --> 00:01:07.330
 But you also avoid writing objects 

00:01:07.330 --> 00:01:09.831
 Which are outside the screen, because it is a complete waste of time and memory. 

00:01:10.130 --> 00:01:12.150
 But for all objects blocked and off the screen, 

00:01:12.150 --> 00:01:13.630
 Learn to multiply the story. 

00:01:14.370 --> 00:01:15.782
 But sorting is not just for writing. 

00:01:15.782 --> 00:01:18.840
 To think about searching a database for a user who meets several criteria, 

00:01:19.280 --> 00:01:23.680
 Such as Texas residency, baldness and obsession with performance. 

00:01:24.160 --> 00:01:26.720
 Some developers who lack imagination may start looking at the database from the beginning, 

00:01:26.720 --> 00:01:29.150
 In each constraint a user is assigned an address in Texas 

00:01:29.150 --> 00:01:31.150
 And about hair color is not applicable, 

00:01:31.150 --> 00:01:34.180
 And about using the perfmatters label in the description of the profile. 

00:01:34.450 --> 00:01:36.410
 But it takes a long time. 

00:01:36.770 --> 00:01:38.660
 Smart developers will arrange queries 

00:01:38.660 --> 00:01:40.890
 To reduce the group of users you need to search for 

00:01:40.890 --> 00:01:41.890
 For each successive standard, 

00:01:42.330 --> 00:01:44.250
 Such as isolating people baldness first. 

00:01:44.550 --> 00:01:46.400
 We have just sorted out our list to a great extent. 

00:01:46.940 --> 00:01:50.460
 Then they can remove each non-state address and no Texas postal code, 

00:01:50.460 --> 00:01:53.460
 This makes us a much smaller user list. 

00:01:53.460 --> 00:01:55.300
 All we need now is to run the expanded search 

00:01:55.300 --> 00:01:57.180
 In their profiles for the perfmatters label 

00:01:57.180 --> 00:01:59.230
 In this very small number of records. 

00:01:59.610 --> 00:02:01.734
 So we found the person required. 

00:02:02.634 --> 00:02:05.050
 Sorting is useful in everything from writing a UI layer 

00:02:05.050 --> 00:02:07.570
 Through searching databases and accessing real-time services, 

00:02:07.570 --> 00:02:08.720
 Such as location. 

00:02:08.720 --> 00:02:11.640
 If your app, for example, alerts users based on local events, 

00:02:11.640 --> 00:02:14.252
 Such as an Android Developer event that includes a barbecue party, 

00:02:14.592 --> 00:02:16.950
 It is not logical to lose event updates 

00:02:16.950 --> 00:02:18.720
 Outside the area where the user lives. 

00:02:19.590 --> 00:02:22.030
 In each case, the basic principle remains the same, 

00:02:22.730 --> 00:02:25.950
 It is checking the relevance of the thing before wasting time on it. 

00:02:26.260 --> 00:02:27.820
 Because in most cases, 

00:02:27.820 --> 00:02:31.200
 Costing the object more than takes enough time 

00:02:31.200 --> 00:02:33.280
 To determine whether it should be treated at all. 

00:02:33.650 --> 00:02:36.664
 So it took time to think about the user and what he cared about, 

00:02:36.664 --> 00:02:39.060
 Then use the sort to help you focus on those things, 

00:02:39.060 --> 00:02:41.122
 In this case, there is no gain. 

00:02:41.122 --> 00:02:44.040
 Less effort in your app and a better experience for your users. 

00:02:45.470 --> 00:02:46.629
 The screening is a good start 

00:02:46.629 --> 00:02:48.800
 But performance is not limited to it. 

00:02:48.800 --> 00:02:50.920
 So watch the rest of Android Performance Patterns 

00:02:50.920 --> 00:02:53.770
 Consider joining the G + forum for tips, guidance, and help. 

00:02:54.030 --> 00:02:56.080
 So keep calm, collect your code information 

00:02:56.080 --> 00:02:57.740
 Always remember that performance is important. 

