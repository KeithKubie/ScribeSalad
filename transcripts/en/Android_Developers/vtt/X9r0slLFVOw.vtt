WEBVTT
Kind: captions
Language: en

00:00:00.660 --> 00:00:03.240
ANKUR KOTWAL: So, before we get
started into this week's

00:00:03.240 --> 00:00:06.760
topic, let's talk
about the news.

00:00:06.760 --> 00:00:11.590
So, really two pieces of news
for Android developers.

00:00:11.590 --> 00:00:14.640
Firstly, Google Play Services
has launched.

00:00:14.640 --> 00:00:16.900
We're really excited
about this.

00:00:16.900 --> 00:00:21.100
It now provides the OAuth
identity management.

00:00:24.650 --> 00:00:27.640
It provides you OAuth tokens so
that you can use a single

00:00:27.640 --> 00:00:31.260
nice API that abstracts the
whole OAuth side of things for

00:00:31.260 --> 00:00:33.870
you across all of our
Google services.

00:00:33.870 --> 00:00:38.130
And we also have the Google+
SDK as part of that.

00:00:38.130 --> 00:00:41.800
So Google Play Services
is quite interesting.

00:00:41.800 --> 00:00:44.580
What it is, is it's a component
that's actually

00:00:44.580 --> 00:00:48.806
going to be there on users'
devices as part of the Google

00:00:48.806 --> 00:00:50.120
Play Store.

00:00:50.120 --> 00:00:52.510
The Google Play Services
component will be installed.

00:00:52.510 --> 00:00:55.870
And now, as developers, you can
just go ahead and start

00:00:55.870 --> 00:00:59.260
using that new API.

00:00:59.260 --> 00:01:01.770
This is just the start of
something much bigger.

00:01:01.770 --> 00:01:04.150
Google Play Services
will grow.

00:01:04.150 --> 00:01:07.660
And OAuth2 and Google+
are finally here.

00:01:07.660 --> 00:01:09.210
So that's really good.

00:01:09.210 --> 00:01:12.160
And the other thing that I'm
really excited about is that

00:01:12.160 --> 00:01:16.260
we have a new build system
coming for the Android

00:01:16.260 --> 00:01:17.510
developer tools.

00:01:19.440 --> 00:01:26.200
Akim Zaveidurisham has put up
a document that sort of

00:01:26.200 --> 00:01:28.730
describes some of the changes
that are coming up.

00:01:28.730 --> 00:01:32.760
They're not available in a
stable release yet, but you

00:01:32.760 --> 00:01:35.350
can certainly go and have a look
at that document and see

00:01:35.350 --> 00:01:38.380
what kind of changes
are coming.

00:01:38.380 --> 00:01:39.860
Yeah, this is good stuff.

00:01:39.860 --> 00:01:42.610
More tools for developers
is always a good thing.

00:01:45.260 --> 00:01:49.510
It's tablet week, so our focus
today is to really use the

00:01:49.510 --> 00:01:51.350
word "tablet" as much
as possible.

00:01:51.350 --> 00:01:52.600
No, that's not true.

00:01:55.480 --> 00:01:59.890
We want to basically empower
developers to build apps that

00:01:59.890 --> 00:02:02.640
work well on phones
and tablets.

00:02:02.640 --> 00:02:06.140
We're actually going to have a
series of presentations on

00:02:06.140 --> 00:02:09.110
ADL+ over the coming weeks.

00:02:09.110 --> 00:02:10.840
Today's the first one, and
it's really about the

00:02:10.840 --> 00:02:14.310
fundamental building blocks
of these apps.

00:02:14.310 --> 00:02:15.660
And it's really Fragments--

00:02:15.660 --> 00:02:18.480
those are the components
that you use.

00:02:18.480 --> 00:02:21.480
So today is very much a
primer on Fragments.

00:02:21.480 --> 00:02:23.350
And so we're going to
cover a few things.

00:02:23.350 --> 00:02:25.910
But before we do, let's talk
about some fundamental goals

00:02:25.910 --> 00:02:28.110
that developers would
like to have, or we

00:02:28.110 --> 00:02:29.520
always want to have.

00:02:29.520 --> 00:02:31.460
We want to build phone
and tablet apps.

00:02:31.460 --> 00:02:33.980
Firstly, we want to have
a single app for

00:02:33.980 --> 00:02:35.940
multiple form factors.

00:02:35.940 --> 00:02:39.700
We don't want to have to manage
a different set of code

00:02:39.700 --> 00:02:42.420
for a phone version, for a
tablet version, or even for a

00:02:42.420 --> 00:02:43.860
Google TV version.

00:02:43.860 --> 00:02:48.330
As much as possible we want to
maximize our code reuse.

00:02:48.330 --> 00:02:51.940
And in doing so, you kind of
want to have your code be

00:02:51.940 --> 00:02:55.850
quite decoupled so that you
can build these reusable

00:02:55.850 --> 00:02:59.030
components and have them not
totally depend on the other

00:02:59.030 --> 00:03:00.940
components being there.

00:03:00.940 --> 00:03:03.980
Decoupling is obviously a really
good thing in general

00:03:03.980 --> 00:03:05.580
software design.

00:03:05.580 --> 00:03:07.800
And finally, you want to build
these apps such that they're

00:03:07.800 --> 00:03:09.800
backward compatible.

00:03:09.800 --> 00:03:13.380
Android 3.0, or Honeycomb,
is where we

00:03:13.380 --> 00:03:15.610
first introduced tablets.

00:03:15.610 --> 00:03:17.590
And prior to that, we had
Gingerbread and Froyo.

00:03:17.590 --> 00:03:19.410
Now Gingerbread is still
a very popular

00:03:19.410 --> 00:03:20.870
version of the platform.

00:03:20.870 --> 00:03:24.140
So when we talk about these
Fragments and utilizing them,

00:03:24.140 --> 00:03:27.070
we want to do it in a way that
still allows our apps to run

00:03:27.070 --> 00:03:28.310
on these older versions.

00:03:28.310 --> 00:03:30.610
So we're going to touch
on that, too.

00:03:30.610 --> 00:03:33.030
How do we make sure that they're
backward compatible,

00:03:33.030 --> 00:03:36.090
whilst keeping all of
these goals in mind?

00:03:36.090 --> 00:03:39.090
So, what are Fragments?

00:03:39.090 --> 00:03:40.480
Fragments--

00:03:40.480 --> 00:03:42.410
they're really reusable
components.

00:03:42.410 --> 00:03:46.190
So it's about grouping bits of
your UI, or other common

00:03:46.190 --> 00:03:49.680
functionality, so that you
can then use it in these

00:03:49.680 --> 00:03:51.030
standalone classes.

00:03:51.030 --> 00:03:55.380
So, when we think about taking
an app and making it available

00:03:55.380 --> 00:03:59.230
on tablets, what we want to do
is really promote the idea of

00:03:59.230 --> 00:04:01.600
the fact that you should
really rethink your UI.

00:04:01.600 --> 00:04:04.080
Don't just take your phone
layout and stretch it because

00:04:04.080 --> 00:04:06.580
that's not really a
good experience.

00:04:06.580 --> 00:04:10.650
And in the majority of cases,
stretching out a typical list

00:04:10.650 --> 00:04:13.260
or something like that on a
phone and just stretching it

00:04:13.260 --> 00:04:16.100
out onto a tablet doesn't really
result in a good user

00:04:16.100 --> 00:04:16.529
experience.

00:04:16.529 --> 00:04:20.769
And users never tend
to appreciate that.

00:04:20.769 --> 00:04:24.110
So, as you can see from this
diagram here, where you might

00:04:24.110 --> 00:04:26.300
have had two activities--

00:04:26.300 --> 00:04:27.500
one and two--

00:04:27.500 --> 00:04:31.340
what you would do is actually
take the contents of those

00:04:31.340 --> 00:04:33.750
activities, and put them
into Fragment.

00:04:33.750 --> 00:04:36.250
And on the phone, you would be
showing one Fragments at a

00:04:36.250 --> 00:04:39.070
time, whereas on the tablet you
could show both Fragments

00:04:39.070 --> 00:04:41.770
at a time within a
single Activity.

00:04:41.770 --> 00:04:44.780
So the Activity is still that
outer window, and you can see

00:04:44.780 --> 00:04:46.790
it based on the blue border.

00:04:46.790 --> 00:04:48.890
You still have activities
when you're running

00:04:48.890 --> 00:04:50.220
on phones and tablets.

00:04:50.220 --> 00:04:52.230
And we're not moving away
from activities.

00:04:52.230 --> 00:04:55.060
But we are taking out all of
that code that we had within

00:04:55.060 --> 00:04:58.940
the Activity, around the user
interface, and just regrouping

00:04:58.940 --> 00:05:00.860
it into Fragments.

00:05:00.860 --> 00:05:02.160
So what are Fragments?

00:05:02.160 --> 00:05:05.185
Well, Fragments are basically
reusable UI components.

00:05:08.720 --> 00:05:12.190
By grouping our contents that
we would have had in an

00:05:12.190 --> 00:05:14.790
Activity, it means
that we can be

00:05:14.790 --> 00:05:18.080
flexible with these Fragments.

00:05:18.080 --> 00:05:21.020
Being a Fragments isn't
just like an

00:05:21.020 --> 00:05:22.680
include in your layout.

00:05:22.680 --> 00:05:24.280
There's actually more
to it than that.

00:05:24.280 --> 00:05:27.720
It actually participates as
part of the life cycle.

00:05:27.720 --> 00:05:29.860
So Fragments actually
have a life cycle.

00:05:29.860 --> 00:05:31.850
And they're attached
to an Activity.

00:05:31.850 --> 00:05:34.600
And that's really important
because the Activity will

00:05:34.600 --> 00:05:36.260
initialize them at key points.

00:05:36.260 --> 00:05:37.400
It'll populate them.

00:05:37.400 --> 00:05:39.734
And there are some specific
overloads that you

00:05:39.734 --> 00:05:41.090
should be aware of.

00:05:41.090 --> 00:05:43.570
Fragments can also maintain
their own backstack.

00:05:43.570 --> 00:05:49.280
So, in a typical phone app, you
might go from one Activity

00:05:49.280 --> 00:05:50.560
to the next, to the next.

00:05:50.560 --> 00:05:54.690
But if you now start reusing
the contents of those

00:05:54.690 --> 00:05:58.010
activities into Fragments, you
might use a single Activity

00:05:58.010 --> 00:06:00.660
and just transition from one
Fragment to the next.

00:06:00.660 --> 00:06:03.450
Now when the user hits the
"Back" button, you don't want

00:06:03.450 --> 00:06:06.280
it to go from one Activity to
the previous one, you want to

00:06:06.280 --> 00:06:09.170
make sure you navigate backwards
through the Fragment

00:06:09.170 --> 00:06:12.440
stack before you go to the
previous Activity.

00:06:12.440 --> 00:06:15.010
So, Fragments allow this.

00:06:15.010 --> 00:06:17.250
The other thing to keep in mind
is that Fragments don't

00:06:17.250 --> 00:06:18.970
have to be UI components.

00:06:18.970 --> 00:06:22.610
They can just be background
workers that you instantiate

00:06:22.610 --> 00:06:25.520
and that participate as part
of the life cycle.

00:06:25.520 --> 00:06:29.780
So, we have an API called
findFragmentByTag.

00:06:29.780 --> 00:06:32.690
Typically what you'd have is a
Fragment that you'd put in a

00:06:32.690 --> 00:06:37.980
layout, and you'd do a find
view by ID, and grab the

00:06:37.980 --> 00:06:39.390
layout, and so on
and so forth.

00:06:39.390 --> 00:06:41.610
But you can actually instantiate
Fragments.

00:06:41.610 --> 00:06:45.000
In using the Fragment manager,
you cannot basically name

00:06:45.000 --> 00:06:47.220
them, or tag them.

00:06:47.220 --> 00:06:50.680
So this find Fragment by tag
is a way to basically get a

00:06:50.680 --> 00:06:53.820
hold of that Fragment at runtime
without having to rely

00:06:53.820 --> 00:06:57.270
on things like the
view hierarchy.

00:06:57.270 --> 00:07:01.170
So, let's talk a little bit
about Fragments and activities

00:07:01.170 --> 00:07:01.570
in general.

00:07:01.570 --> 00:07:05.590
So, the user interface
part is optional.

00:07:05.590 --> 00:07:08.460
Typically, in most
circumstances, you would use

00:07:08.460 --> 00:07:11.050
them with a user interface.

00:07:11.050 --> 00:07:12.540
You would use them
for grouping UI.

00:07:12.540 --> 00:07:13.730
But you don't have to.

00:07:13.730 --> 00:07:16.840
Whereas with an Activity, it
always has a user interface.

00:07:16.840 --> 00:07:20.360
It's always the part
that the user sees.

00:07:20.360 --> 00:07:22.450
Both of them tend to have
life cycle methods.

00:07:22.450 --> 00:07:24.720
And in fact, the Fragment tends
to have a few more life

00:07:24.720 --> 00:07:30.590
cycle methods than the Activity
in the typical UI

00:07:30.590 --> 00:07:33.270
style Fragment.

00:07:33.270 --> 00:07:35.210
Fragments can't be standalone.

00:07:35.210 --> 00:07:37.810
They are attached
to activities.

00:07:37.810 --> 00:07:39.430
And we actually have
an override called

00:07:39.430 --> 00:07:42.010
onAttach and onDetach.

00:07:42.010 --> 00:07:46.150
Now, the other thing you should
be aware of is the use

00:07:46.150 --> 00:07:47.170
of Intents.

00:07:47.170 --> 00:07:51.680
So typically we use Intents to
invoke certain pieces of

00:07:51.680 --> 00:07:55.270
functionality in
your Activity.

00:07:55.270 --> 00:07:58.710
That still holds true, except
with Fragments, Intents don't

00:07:58.710 --> 00:08:00.990
go fire up Fragments directly.

00:08:00.990 --> 00:08:03.490
You have to go through
an Activity.

00:08:03.490 --> 00:08:05.230
And we're going to clarify
this later.

00:08:05.230 --> 00:08:06.990
So what we're doing here
is best describing

00:08:06.990 --> 00:08:08.770
what Fragments are.

00:08:08.770 --> 00:08:11.720
We're going to look at now the
advantages of using Fragments.

00:08:11.720 --> 00:08:14.170
And then eventually we
will talk about--

00:08:14.170 --> 00:08:16.240
before we talk about
backwards support--

00:08:16.240 --> 00:08:19.070
we're going to talk about
communication, as well,

00:08:19.070 --> 00:08:20.450
between Fragments.

00:08:20.450 --> 00:08:21.840
So let's look at a
typical layout.

00:08:21.840 --> 00:08:25.180
On a phone, this is the people
app that we've had since Ice

00:08:25.180 --> 00:08:27.160
Cream Sandwich.

00:08:27.160 --> 00:08:29.370
And you'll see on the
left hand side

00:08:29.370 --> 00:08:31.120
you've got a list view.

00:08:31.120 --> 00:08:35.309
With this list view you have
your list of contacts there,

00:08:35.309 --> 00:08:37.280
and there's some tabs
across the top.

00:08:37.280 --> 00:08:39.919
You can swipe across
them and so on.

00:08:39.919 --> 00:08:42.740
It's a fairly standard list
view type screen with some

00:08:42.740 --> 00:08:44.690
actions along the bottom.

00:08:44.690 --> 00:08:48.540
Now, if we want to click Matias
there, it would take us

00:08:48.540 --> 00:08:51.110
from the list view for
that contact and go

00:08:51.110 --> 00:08:53.370
into the detail view.

00:08:53.370 --> 00:08:58.080
Now, a traditional phone app may
have implemented these as

00:08:58.080 --> 00:09:00.730
Activity 1 one for the list view
and Activity 2 for the

00:09:00.730 --> 00:09:01.750
detail view.

00:09:01.750 --> 00:09:05.570
But if we then reorganize our
code such that this list view

00:09:05.570 --> 00:09:09.320
part of it becomes a Fragment,
and the detailed view also

00:09:09.320 --> 00:09:13.390
becomes a Fragment, then what
happens is on the phone we

00:09:13.390 --> 00:09:15.320
still can still present
the same interface.

00:09:15.320 --> 00:09:18.610
But when we go something like
the tablet, we can show these

00:09:18.610 --> 00:09:20.940
multiple Fragments
at the same time.

00:09:20.940 --> 00:09:23.070
We're maximizing
our code reuse.

00:09:23.070 --> 00:09:25.760
We're not having to define
layouts multiple times, and

00:09:25.760 --> 00:09:29.000
even code multiple times,
or having really complex

00:09:29.000 --> 00:09:31.030
inheritance hierarchies.

00:09:31.030 --> 00:09:35.980
With Fragments, we can basically
show multiple pieces

00:09:35.980 --> 00:09:37.780
of UI at the same time.

00:09:37.780 --> 00:09:40.570
There is some extra code that
you need to do to distinguish

00:09:40.570 --> 00:09:41.965
between a phone layout
and a tablet layout.

00:09:41.965 --> 00:09:45.030
We're going to look
at that next.

00:09:45.030 --> 00:09:48.310
But the differences are really
phenomenal in terms of the

00:09:48.310 --> 00:09:51.570
overhead for you and
your developers.

00:09:51.570 --> 00:09:57.220
So, when it comes to defining
layouts, you might be saying,

00:09:57.220 --> 00:10:01.120
well, how can I say that this
layout is going to be for a

00:10:01.120 --> 00:10:02.370
phone or for a tablet?

00:10:02.370 --> 00:10:07.020
Well, in Eclipse, when you
define your resource or your

00:10:07.020 --> 00:10:10.960
layout directories, you can
basically say it's a layout

00:10:10.960 --> 00:10:14.440
directory, which will be the
default layout that gets used.

00:10:14.440 --> 00:10:16.840
Or you can have these
extra qualifiers.

00:10:16.840 --> 00:10:18.690
So, one of the qualifiers is
something that we call

00:10:18.690 --> 00:10:20.270
smallest width.

00:10:20.270 --> 00:10:23.260
And then you can specify
a number and a DP.

00:10:23.260 --> 00:10:26.460
Now, smallest width basically
says, that regardless of

00:10:26.460 --> 00:10:28.720
whether I'm holding it in
portrait or landscape view,

00:10:28.720 --> 00:10:33.020
what is the smallest dimension
on this device?

00:10:33.020 --> 00:10:36.040
Now, what we've done is that
we've got some metrics in

00:10:36.040 --> 00:10:39.840
there that tell you that this
is the range of values that

00:10:39.840 --> 00:10:43.585
will result in a tablet
UI, or phone UI.

00:10:43.585 --> 00:10:48.220
So, if you specify smallest
width 600, anything that has

00:10:48.220 --> 00:10:52.560
600 DPs or greater is considered
a tablet, okay?

00:10:52.560 --> 00:10:54.940
We've, in fact, added
an extra layer of

00:10:54.940 --> 00:10:56.400
differentiation there.

00:10:56.400 --> 00:10:59.550
If you specify 600 DP,
it'll get picked up

00:10:59.550 --> 00:11:00.980
by seven inch tablets.

00:11:00.980 --> 00:11:04.980
If you specify 720 DP, it'll
actually get picked up by 10

00:11:04.980 --> 00:11:06.060
inch tablets.

00:11:06.060 --> 00:11:08.740
So you may want to have a
different layout between your

00:11:08.740 --> 00:11:11.450
seven inch tablets, and
your 10 inch tablets.

00:11:11.450 --> 00:11:14.130
And this metric here
is how you do that.

00:11:14.130 --> 00:11:17.250
And you'd still have a
normal layout folder.

00:11:17.250 --> 00:11:20.190
And That normal layout folder is
what will get picked up or

00:11:20.190 --> 00:11:24.020
phones, the 600 DP for seven
inch tablets, and the 720 DP

00:11:24.020 --> 00:11:25.670
for 10 inch tablets.

00:11:25.670 --> 00:11:27.970
You don't have to
have all three.

00:11:27.970 --> 00:11:30.640
Nothing is sort of forcing
you to do so, but our

00:11:30.640 --> 00:11:32.110
recommendation is at
least have two.

00:11:32.110 --> 00:11:34.510
Have the default layout folder,
and then have the 600

00:11:34.510 --> 00:11:37.400
DP for your tablet UI.

00:11:37.400 --> 00:11:40.270
Now prior to Android 3.2--

00:11:40.270 --> 00:11:43.450
so really only Android
3.0 and 3.1--

00:11:43.450 --> 00:11:46.460
the only way that you could have
a tablet layout was to

00:11:46.460 --> 00:11:49.490
specify a res-large or a res.

00:11:49.490 --> 00:11:52.150
Sorry, that should say
layout-large and

00:11:52.150 --> 00:11:54.350
layout-xlarge directory.

00:11:54.350 --> 00:11:56.730
In fact, I'm going to just
fix that live right

00:11:56.730 --> 00:11:57.980
now, because I can.

00:12:02.620 --> 00:12:05.030
And we're done.

00:12:05.030 --> 00:12:07.540
So, it's a layout-large and
a layout-xlarge directory

00:12:07.540 --> 00:12:11.370
because prior to Android 3.2,
we didn't have that smallest

00:12:11.370 --> 00:12:12.670
width qualifier.

00:12:12.670 --> 00:12:16.360
So, a large or and extra large
layout would actually get

00:12:16.360 --> 00:12:18.810
picked up by those devices.

00:12:18.810 --> 00:12:21.870
We no longer recommend that you
use large and extra large

00:12:21.870 --> 00:12:25.530
qualifiers because it becomes
a little bit of a gray area.

00:12:25.530 --> 00:12:28.040
What defines a large, screen?

00:12:28.040 --> 00:12:31.240
Is it a seven inch tablet,
like the Nexus 7?

00:12:31.240 --> 00:12:35.110
Or is something like
a Galaxy Note

00:12:35.110 --> 00:12:36.920
considered a large screen?

00:12:36.920 --> 00:12:41.340
So, rather than having these
generic buckets, we now use

00:12:41.340 --> 00:12:45.250
the smallest width qualifier
and you should, too.

00:12:45.250 --> 00:12:47.920
So, at run time, how would you
tell between whether you're

00:12:47.920 --> 00:12:51.060
running in a phone layout,
or tablet layout?

00:12:51.060 --> 00:12:52.080
Well it's easy, right?

00:12:52.080 --> 00:12:55.350
Because in your Activity you're
going to have a layout

00:12:55.350 --> 00:12:56.480
that you load.

00:12:56.480 --> 00:12:59.210
And on the phone, you would
typically only be showing one

00:12:59.210 --> 00:13:00.820
Fragment at a time.

00:13:00.820 --> 00:13:02.820
On a tablet, you might
show more than

00:13:02.820 --> 00:13:04.190
one tablet at a time.

00:13:04.190 --> 00:13:09.550
So, what you can do is use a
findViewById API, and see if

00:13:09.550 --> 00:13:11.370
you can find both Fragments.

00:13:11.370 --> 00:13:13.430
For example, if you're going
to be able to find one

00:13:13.430 --> 00:13:17.270
Fragment, then you know that
you're running on a phone.

00:13:17.270 --> 00:13:19.410
If you're able to find both
Fragments, then you know that

00:13:19.410 --> 00:13:20.450
you're running on a tablet.

00:13:20.450 --> 00:13:23.240
And so that's that extra sort
of glue code that I was

00:13:23.240 --> 00:13:23.920
talking to.

00:13:23.920 --> 00:13:25.730
But it really belongs
in your Activity.

00:13:25.730 --> 00:13:28.520
Because remember, Fragments
themselves should be

00:13:28.520 --> 00:13:31.550
standalone, reusable components
that are fairly

00:13:31.550 --> 00:13:33.230
decoupled from everything
else.

00:13:33.230 --> 00:13:36.370
It's the Activity that kind of
binds the multiple friends, or

00:13:36.370 --> 00:13:38.040
really your layout
that binds the

00:13:38.040 --> 00:13:40.000
multiple Fragments together.

00:13:40.000 --> 00:13:42.630
So, you can just use a trick
like that with using

00:13:42.630 --> 00:13:44.520
findViewById and doing
a null check.

00:13:44.520 --> 00:13:47.830
And that should sort you out.

00:13:47.830 --> 00:13:50.800
So, we talked about
Intents before.

00:13:50.800 --> 00:13:53.880
Typically what happens is when
an Intents gets fired off,

00:13:53.880 --> 00:13:58.520
your Activity gets invoked and
told hey, here's an Intents.

00:13:58.520 --> 00:14:00.920
But you can't go from Intents
directly to a Fragment.

00:14:00.920 --> 00:14:02.670
It still comes through
an Activity.

00:14:02.670 --> 00:14:06.420
So, you might be wondering,
well, how do I manage that?

00:14:06.420 --> 00:14:09.550
How do I get an Intents to end
up invoking a Fragment?

00:14:09.550 --> 00:14:11.930
And the answer is it has to
go through an Activity.

00:14:11.930 --> 00:14:16.330
But let me just show you some
code that demonstrates how

00:14:16.330 --> 00:14:19.640
that propagation may work.

00:14:19.640 --> 00:14:21.950
So let me just highlight
the relevant section.

00:14:21.950 --> 00:14:24.710
So, here what's happened
is we're in the--

00:14:24.710 --> 00:14:27.080
it could happen in onCreate
or it could happen on

00:14:27.080 --> 00:14:28.910
onNewIntents--

00:14:28.910 --> 00:14:31.390
what you'd do is basically
do a get Intents code.

00:14:31.390 --> 00:14:35.240
So this code is actually in your
Activity, itself, right?

00:14:35.240 --> 00:14:36.540
And so we just do
a get Intents.

00:14:36.540 --> 00:14:37.680
We get the action.

00:14:37.680 --> 00:14:41.510
And we're just comparing whether
the Intents action

00:14:41.510 --> 00:14:45.640
matches whatever action it is
that we're interested in.

00:14:45.640 --> 00:14:48.870
So, once we do that in our
Activity, we can then go, OK I

00:14:48.870 --> 00:14:50.530
know that it is this action.

00:14:50.530 --> 00:14:53.370
So now I'm going to
go and get a hold

00:14:53.370 --> 00:14:56.210
off my noteless Fragment.

00:14:56.210 --> 00:14:59.500
So in this Activity there's
probably a list Fragment and a

00:14:59.500 --> 00:15:00.400
detail Fragment.

00:15:00.400 --> 00:15:02.920
So a list of notes, and then
the detail Fragment is

00:15:02.920 --> 00:15:04.490
probably the note itself.

00:15:04.490 --> 00:15:07.050
So, what we did is we
got the Intents.

00:15:07.050 --> 00:15:09.740
Now we managed to pull the
relevant Fragment out.

00:15:09.740 --> 00:15:14.730
And then finally we are able
to pass in some extra

00:15:14.730 --> 00:15:17.330
information.

00:15:17.330 --> 00:15:19.315
Or, sorry, from the Intents we
can get some extra information

00:15:19.315 --> 00:15:23.380
out as to which list item
we want to select, or

00:15:23.380 --> 00:15:25.230
so on and so forth.

00:15:25.230 --> 00:15:28.510
But this is an example of
where in the Activity we

00:15:28.510 --> 00:15:31.057
receive the Intents and then we
followed that through and

00:15:31.057 --> 00:15:33.420
passed it through the
relevant Fragment.

00:15:33.420 --> 00:15:36.230
So we are kind of starting to
spread out our code a little

00:15:36.230 --> 00:15:37.840
bit between different classes.

00:15:37.840 --> 00:15:42.460
But that's not necessarily
a bad thing, either.

00:15:42.460 --> 00:15:45.510
OK, so we talked about Intents
communication, but what about

00:15:45.510 --> 00:15:47.850
when you've got two Fragments
and you want to communicate

00:15:47.850 --> 00:15:49.230
with one another?

00:15:49.230 --> 00:15:52.780
You could do all sorts of sort
of trickery, where you've got

00:15:52.780 --> 00:15:54.060
Fragments talking
to Fragments.

00:15:54.060 --> 00:15:56.640
But it's generally not a good
thing because then you start

00:15:56.640 --> 00:15:58.860
to really closely couple
them together.

00:15:58.860 --> 00:16:00.650
Then one Fragment needs to
know whether the other

00:16:00.650 --> 00:16:03.790
Fragment exists, and has been
loaded, and so on and so

00:16:03.790 --> 00:16:06.290
forth, and then pass information
back and forth.

00:16:06.290 --> 00:16:09.800
Instead, what we recommend, is
you still use the Activity as

00:16:09.800 --> 00:16:11.260
kind of a proxy.

00:16:11.260 --> 00:16:14.570
So, what you would do to achieve
Fragment to Fragment

00:16:14.570 --> 00:16:16.730
communication is go
via the Activity.

00:16:16.730 --> 00:16:19.630
So, here you'll see that what
we recommended is that you

00:16:19.630 --> 00:16:21.380
define an interface
in Fragment 1--

00:16:21.380 --> 00:16:23.100
we're calling it Interface
A for now.

00:16:23.100 --> 00:16:26.570
Then Fragment 2 would have
Interface B defined.

00:16:26.570 --> 00:16:30.480
The Activity would implement
those methods.

00:16:30.480 --> 00:16:32.850
And then when those methods
are being called on those

00:16:32.850 --> 00:16:35.050
interfaces, it would
then pass it on to

00:16:35.050 --> 00:16:36.230
the relevant Fragment.

00:16:36.230 --> 00:16:39.540
And it may, in fact, like on
a phone, actually need to

00:16:39.540 --> 00:16:41.280
instantiate the second
Fragment.

00:16:41.280 --> 00:16:43.800
Because on a phone, both
Fragments may not have been

00:16:43.800 --> 00:16:45.770
instantiated, because
that single

00:16:45.770 --> 00:16:47.610
Fragment layout uploaded.

00:16:47.610 --> 00:16:49.330
So, again really the Activity's
that thing that's

00:16:49.330 --> 00:16:51.690
binding it all together,
right?

00:16:51.690 --> 00:16:54.620
So what would happen is that
once the interfaces are

00:16:54.620 --> 00:16:56.680
defined and the Activity's
implementing them, your

00:16:56.680 --> 00:16:59.780
Fragments are invoking the
Activity, and then the

00:16:59.780 --> 00:17:03.020
Activity in turn is calling
the Fragment.

00:17:03.020 --> 00:17:06.599
So let's look at some code
that demonstrates that.

00:17:06.599 --> 00:17:09.740
So, onAttach is within
a Fragment.

00:17:09.740 --> 00:17:13.250
That's an overload.

00:17:13.250 --> 00:17:17.380
Sorry, that's an override that
says that your Fragment has

00:17:17.380 --> 00:17:19.619
been attached to a particular
Activity.

00:17:19.619 --> 00:17:20.940
That's when it gets called.

00:17:20.940 --> 00:17:25.069
So when our Fragment gets
attached to an Activity, we're

00:17:25.069 --> 00:17:28.119
just storing that Activity as
a callback object within the

00:17:28.119 --> 00:17:30.400
Fragment, itself.

00:17:30.400 --> 00:17:34.510
And you'll notice that the type
of that callback object

00:17:34.510 --> 00:17:36.320
is this note list
event callback.

00:17:36.320 --> 00:17:41.110
That's our interface, which is
at the bottom of this page.

00:17:41.110 --> 00:17:43.500
But we'll talk about
that in a minute.

00:17:43.500 --> 00:17:45.690
But anyway, we store
it as an interface.

00:17:45.690 --> 00:17:49.970
And then on our Fragment, in
this unlist item click method,

00:17:49.970 --> 00:17:52.440
when we need to go and do
something about the fact that

00:17:52.440 --> 00:17:56.770
the user has selected something,
we then can do it

00:17:56.770 --> 00:17:58.080
one of two ways.

00:17:58.080 --> 00:18:01.540
We can just call "get Activity",
and then go call

00:18:01.540 --> 00:18:03.910
the do something method.

00:18:03.910 --> 00:18:07.910
Or we can use the interface,
itself, which we stored as a

00:18:07.910 --> 00:18:11.380
callback object, onAttach
method.

00:18:11.380 --> 00:18:15.020
Now, my personal preference
is to use the callback.

00:18:15.020 --> 00:18:16.150
I think it's cleaner.

00:18:16.150 --> 00:18:18.060
We've defined clear
interfaces.

00:18:18.060 --> 00:18:21.200
So again we're kind
of decoupling

00:18:21.200 --> 00:18:23.020
our code quite nicely.

00:18:23.020 --> 00:18:24.340
So, you'd call
callback.onListClicked(id).

00:18:28.040 --> 00:18:31.190
Now remember we talked about at
the start in this onAttach

00:18:31.190 --> 00:18:34.280
method, we stored this callback,
and we said it had

00:18:34.280 --> 00:18:36.180
to implement an interface.

00:18:36.180 --> 00:18:38.330
Well that's what this bit
at the bottom is.

00:18:38.330 --> 00:18:41.430
It's the interface that this
Fragment is defining.

00:18:41.430 --> 00:18:47.605
To say, hey, whichever object I
need to sort of inform that

00:18:47.605 --> 00:18:50.500
a particular action is taken,
that object will obviously

00:18:50.500 --> 00:18:52.390
implement this method, itself.

00:18:52.390 --> 00:18:56.500
And will pass a note ID,
or whatever it may be.

00:18:56.500 --> 00:18:59.060
So, communication between
Fragments--

00:18:59.060 --> 00:19:01.430
don't do it directly from
Fragment to Fragment.

00:19:01.430 --> 00:19:03.840
Have a proxy layer, and that's
typically the Activity.

00:19:03.840 --> 00:19:06.910
Because the Activity is the
thing that Fragments are

00:19:06.910 --> 00:19:09.540
attached to.

00:19:09.540 --> 00:19:11.820
So, we talked about some nice
things here, but I also

00:19:11.820 --> 00:19:14.550
mentioned that Fragments
came into Android 3.0.

00:19:14.550 --> 00:19:17.350
The good news is that we
actually introduced Fragments

00:19:17.350 --> 00:19:18.970
in the support library.

00:19:18.970 --> 00:19:21.090
So, the support library
is a reusable library.

00:19:21.090 --> 00:19:23.660
You may have heard me
mention it before.

00:19:23.660 --> 00:19:25.950
It's really simple to include
in your project.

00:19:25.950 --> 00:19:28.240
Within Eclipse, you just right
click the project, go to

00:19:28.240 --> 00:19:30.710
Android Tools, and say,
add support library.

00:19:30.710 --> 00:19:32.950
It will go and download
the latest version.

00:19:32.950 --> 00:19:36.880
Include the jar on your project,
and set up the

00:19:36.880 --> 00:19:37.500
[INAUDIBLE]

00:19:37.500 --> 00:19:37.760
as well.

00:19:37.760 --> 00:19:39.970
And the name space is
then available.

00:19:39.970 --> 00:19:42.910
So, we basically put backward
compatible Fragments in the

00:19:42.910 --> 00:19:44.240
support library.

00:19:44.240 --> 00:19:48.630
Now, my recommendation to
developers is use the support

00:19:48.630 --> 00:19:50.160
Fragments from the start.

00:19:50.160 --> 00:19:53.880
Any time you're building a new
app, start with Fragments.

00:19:53.880 --> 00:19:58.420
Think about tablets and phones
as effectively being first

00:19:58.420 --> 00:19:59.920
class citizens.

00:19:59.920 --> 00:20:03.915
Try not to start with a phone
app, and then migrate to a

00:20:03.915 --> 00:20:04.990
tablet app later.

00:20:04.990 --> 00:20:08.240
You may choose to do the tablet
side of things later

00:20:08.240 --> 00:20:11.170
on, but at least set up the
infrastructure and start using

00:20:11.170 --> 00:20:13.080
Fragments from the
very beginning.

00:20:13.080 --> 00:20:16.880
Because it's a lot easier
then to manage a tablet

00:20:16.880 --> 00:20:18.160
version of your app.

00:20:18.160 --> 00:20:20.700
Whereas if you don't use
Fragments, and then later on

00:20:20.700 --> 00:20:23.200
you have to go and reorganize
all of your activities, and so

00:20:23.200 --> 00:20:25.890
on, into Fragments, the overhead
is a lot more later

00:20:25.890 --> 00:20:27.570
on because you've got
a big chunk of code

00:20:27.570 --> 00:20:30.420
that you need to refactor.

00:20:30.420 --> 00:20:34.030
So, the support library
has Fragments.

00:20:34.030 --> 00:20:38.310
And one other really important
piece of advice is don't mix

00:20:38.310 --> 00:20:41.970
and match support Fragments with
the native Fragments that

00:20:41.970 --> 00:20:44.760
you'll find on Android
3.0 and upwards.

00:20:44.760 --> 00:20:45.940
They're different
implementation.

00:20:45.940 --> 00:20:46.780
They're different classes.

00:20:46.780 --> 00:20:49.050
So you kind of mix and match
a support Fragment

00:20:49.050 --> 00:20:50.300
and a native Fragment.

00:20:52.340 --> 00:20:55.070
But we are able to achieve
backward compatibility.

00:20:55.070 --> 00:20:58.350
And that is how all of our
internal apps work, as well.

00:20:58.350 --> 00:21:01.280
You've noticed I showed you
the people app, which is

00:21:01.280 --> 00:21:03.540
obviously an Ice Cream
Sandwich app.

00:21:03.540 --> 00:21:04.720
Even things like Gmail.

00:21:04.720 --> 00:21:10.180
Gmail uses multiple Fragments.

00:21:10.180 --> 00:21:14.280
Anyways, so that's backward
compatibility.

00:21:14.280 --> 00:21:18.780
And that's a bit of a
primer on Fragments.

00:21:18.780 --> 00:21:24.500
So let's move on to Q&amp;A. Does
anyone on the thread here have

00:21:24.500 --> 00:21:28.170
any questions on today's topic,
or even otherwise?

00:21:31.510 --> 00:21:35.340
I'm just going to look
at the thread.

00:21:41.380 --> 00:21:48.150
It doesn't look like there's
been any question posted.

00:21:48.150 --> 00:21:49.700
There's a question that says
are you going to share this

00:21:49.700 --> 00:21:51.130
presentation after
the session?

00:21:51.130 --> 00:21:52.230
And the answer is yes.

00:21:52.230 --> 00:21:56.140
It's available on YouTube
because the recording goes up

00:21:56.140 --> 00:21:57.890
and it'll be there.

00:21:57.890 --> 00:22:00.590
So you can go and view it
at any point in time.

00:22:03.330 --> 00:22:06.480
Alright, so there's no
questions there.

00:22:06.480 --> 00:22:10.140
My colleague Anirudh is joining
us from Hyderabad.

00:22:10.140 --> 00:22:12.140
Anriudh, should we move
to Google Moderator?

00:22:12.140 --> 00:22:15.380
ANIRUDH DEWANI: Yes, thanks
for the [INAUDIBLE]

00:22:15.380 --> 00:22:16.400
Ankur.

00:22:16.400 --> 00:22:21.020
So, let's take a few questions
in Moderator.

00:22:21.020 --> 00:22:22.980
The first one, and I'm going
to read it loud.

00:22:22.980 --> 00:22:26.600
"My music player app (audio
streaming) should work while

00:22:26.600 --> 00:22:29.270
I'm driving in a car
with 3G card.

00:22:29.270 --> 00:22:33.150
What the API features should
I consider as a developer?

00:22:33.150 --> 00:22:36.286
The player apps work excellent
with Wi-Fi, and some of the

00:22:36.286 --> 00:22:42.210
devices with 3G." Ankur, do
you wanna take that up?

00:22:42.210 --> 00:22:43.745
ANKUR KOTWAL: Yeah, sure.

00:22:43.745 --> 00:22:51.650
Look, in general, there is no no
specific API that you want

00:22:51.650 --> 00:22:55.180
to use to differentiate your
behavior, your app's behavior.

00:22:55.180 --> 00:22:57.330
But there's some strategy.

00:22:57.330 --> 00:23:01.380
So, with 3G, it's not a good
idea to continually

00:23:01.380 --> 00:23:03.830
have the radio on.

00:23:03.830 --> 00:23:08.320
As much as possible you want to
prefetch and chunk it up.

00:23:08.320 --> 00:23:10.870
If you can do that when you're
on Wi-Fi, that's even better.

00:23:10.870 --> 00:23:17.810
But streaming and asking for
chunks, or buffers, of data

00:23:17.810 --> 00:23:20.600
periodically is probably not
the best way to do it.

00:23:20.600 --> 00:23:23.052
Because it will have a
significant drain on the

00:23:23.052 --> 00:23:24.820
user's device.

00:23:24.820 --> 00:23:27.610
So yeah, prefetching is
one really good thing.

00:23:27.610 --> 00:23:30.450
Rater Meyer, our colleague,
presented at

00:23:30.450 --> 00:23:33.140
Google I/O this year.

00:23:33.140 --> 00:23:38.120
And the talk was making
good apps great.

00:23:38.120 --> 00:23:38.930
So check it out.

00:23:38.930 --> 00:23:40.730
There's some great advice
in there on how to

00:23:40.730 --> 00:23:42.050
achieve some of this.

00:23:42.050 --> 00:23:45.400
But what you can do to work out
whether you are connected

00:23:45.400 --> 00:23:48.610
to Wi-Fi, or 3G, is use the
connectivity manager.

00:23:48.610 --> 00:23:53.270
And then change your behavior
accordingly.

00:23:53.270 --> 00:23:55.860
And also keep in mind that if
you are pulling down lots of

00:23:55.860 --> 00:24:01.190
data, prefetch can be one of
those sensitive things.

00:24:01.190 --> 00:24:04.490
Just make sure the user's
OK with you doing that.

00:24:04.490 --> 00:24:05.970
It's a music player,
you said, right?

00:24:05.970 --> 00:24:09.990
So if the user has 2 GB of
music, you probably don't want

00:24:09.990 --> 00:24:12.750
to download that on their
3G connection.

00:24:12.750 --> 00:24:16.750
Because you are going to blow
through their data limit.

00:24:16.750 --> 00:24:18.280
Wi-Fi is typically better.

00:24:18.280 --> 00:24:20.500
Most people are OK with Wi-Fi.

00:24:20.500 --> 00:24:23.260
But again, you need to consider
their data limits on

00:24:23.260 --> 00:24:27.120
Wi-FI and tune your behavior
accordingly.

00:24:27.120 --> 00:24:29.740
Also, the last thing is if you
are sort of prefetching and

00:24:29.740 --> 00:24:33.750
caching, just keep in mind how
large your cache is becoming.

00:24:33.750 --> 00:24:34.940
You might want to manage that.

00:24:34.940 --> 00:24:38.170
You might want to have some
maximal threshold set on the

00:24:38.170 --> 00:24:44.000
app, itself, so that you're not
using up all of the user's

00:24:44.000 --> 00:24:46.250
storage capacity.

00:24:46.250 --> 00:24:48.940
Is there anything else you
want to add, Anirudh?

00:24:48.940 --> 00:24:52.680
ANIRUDH DEWANI: Yeah, so, he
also asked, what API features

00:24:52.680 --> 00:24:54.770
should I consider
as a developer?

00:24:54.770 --> 00:24:58.320
So, for the music app, the two
things I would recommend are

00:24:58.320 --> 00:25:00.780
play approach from the rich
notification bar.

00:25:00.780 --> 00:25:02.170
This is where you handle
your users.

00:25:02.170 --> 00:25:05.450
And also Lock Screen Wizard if
you have your controls there.

00:25:05.450 --> 00:25:09.760
Because if somebody's driving
a car with a 3G card, or

00:25:09.760 --> 00:25:13.050
playing with Wi-Fi, you don't
want him to unlock the phone

00:25:13.050 --> 00:25:15.700
and go in and stop your
music, or do whatever.

00:25:15.700 --> 00:25:18.370
So the Lock Screen Wizard and
notification bar controls bar

00:25:18.370 --> 00:25:19.800
controls are really good.

00:25:19.800 --> 00:25:23.130
Those are a couple of API
features you should look at.

00:25:23.130 --> 00:25:25.908
ANKUR KOTWAL: Actually, also the
Bluetooth Music Controls.

00:25:25.908 --> 00:25:27.540
ANIRUDH DEWANI: Yeah.

00:25:27.540 --> 00:25:29.890
ANKUR KOTWAL: So, we've got APIs
around that so you can

00:25:29.890 --> 00:25:33.840
respond to buttons on people's
Bluetooth headset, so when

00:25:33.840 --> 00:25:35.090
they say "Play, Pause,
Next Song".

00:25:37.582 --> 00:25:40.140
ANIRUDH DEWANI: Alright,
thanks for that update.

00:25:40.140 --> 00:25:44.310
So, the next question is, "I'm
trying to make an app using

00:25:44.310 --> 00:25:45.580
Connectivity API.

00:25:45.580 --> 00:25:48.330
Is it communication between
devices, or is it between

00:25:48.330 --> 00:25:49.460
applications?

00:25:49.460 --> 00:25:52.130
What is the primary connectivity
devices or

00:25:52.130 --> 00:25:53.390
applications?

00:25:53.390 --> 00:25:54.840
What is the security layer?

00:25:54.840 --> 00:26:00.400
Is it on app level or device
level?" So, I recently gave a

00:26:00.400 --> 00:26:04.540
talk on Connectivity API,
dealing [INAUDIBLE].

00:26:04.540 --> 00:26:06.340
I think the question is sort
of coming from there, as a

00:26:06.340 --> 00:26:07.310
follow-up question.

00:26:07.310 --> 00:26:08.820
So I'd like to answer this.

00:26:08.820 --> 00:26:13.960
So when we say Connectivity API,
what we really mean is

00:26:13.960 --> 00:26:18.066
wireless API is like Wi-Fi and
Google and being which it

00:26:18.066 --> 00:26:20.790
would use to communicating
between devices, and also with

00:26:20.790 --> 00:26:22.550
the Cloud like Wi-Fi.

00:26:22.550 --> 00:26:28.460
So is it communication between
devices or between

00:26:28.460 --> 00:26:29.170
applications?

00:26:29.170 --> 00:26:32.815
So, it's really a combination
between devices, but we've got

00:26:32.815 --> 00:26:35.020
some app level features
that you can use.

00:26:35.020 --> 00:26:39.960
For example, with Wi-Fi direct,
I talked about using

00:26:39.960 --> 00:26:42.510
Service Discovery, which is
an app level feature.

00:26:42.510 --> 00:26:45.972
So, if your app is using Wi-Fi
direct to connect with another

00:26:45.972 --> 00:26:52.170
device, these are available as
framework compliments just

00:26:52.170 --> 00:26:57.180
like telephony manager and
network connectivity manager.

00:26:57.180 --> 00:27:01.880
You have a Wi-Fi peer-to-peer
manager available in your app

00:27:01.880 --> 00:27:03.920
when you extend [INAUDIBLE].

00:27:03.920 --> 00:27:07.290
And you can use this Wi-Fi P2P
manager to discover other

00:27:07.290 --> 00:27:10.400
services around the
[INAUDIBLE].

00:27:10.400 --> 00:27:13.370
So the connection is really
between the devices because

00:27:13.370 --> 00:27:16.280
it's Wi-Fi, but then your
application has some extra

00:27:16.280 --> 00:27:19.100
features from the framework
available on top of which you

00:27:19.100 --> 00:27:20.320
can write your application.

00:27:20.320 --> 00:27:23.790
And the same goes for
security layers.

00:27:23.790 --> 00:27:29.460
So if you're using Wi-Fi direct,
for example, you have

00:27:29.460 --> 00:27:32.840
options to use something for the
framework which is like a

00:27:32.840 --> 00:27:35.490
key-based authentication or
you just use a pin-based

00:27:35.490 --> 00:27:38.770
authentication, the general
wireless security options

00:27:38.770 --> 00:27:39.920
available to you.

00:27:39.920 --> 00:27:43.970
But on top of that you build
something on your app as well.

00:27:43.970 --> 00:27:46.855
You could ask for pin codes
or you could ask for user

00:27:46.855 --> 00:27:48.170
accounts, or--

00:27:48.170 --> 00:27:50.510
And that same goes for
[INAUDIBLE] and other

00:27:50.510 --> 00:27:51.420
Connectivity APIs.

00:27:51.420 --> 00:27:55.220
So [INAUDIBLE], we provide
core infrastructure of

00:27:55.220 --> 00:28:00.560
security and data transfer
using APIs at the device

00:28:00.560 --> 00:28:02.220
level, at the framework level.

00:28:02.220 --> 00:28:05.720
And on top of that, we give you
some more flexibility in

00:28:05.720 --> 00:28:09.350
terms of what input.

00:28:09.350 --> 00:28:12.898
So, Ankur, would you like to
add something to that?

00:28:12.898 --> 00:28:16.180
ANKUR KOTWAL: No, I think that
was quite comprehensive.

00:28:16.180 --> 00:28:18.490
ANIRUDH DEWANI: Alright.

00:28:18.490 --> 00:28:21.166
Okay, the next question
is, and this is

00:28:21.166 --> 00:28:22.260
from Melbourne Jeff.

00:28:22.260 --> 00:28:25.200
"I'm trying to use a searchView
in an action bar

00:28:25.200 --> 00:28:26.450
and my theme is based on
Theme.Holo.Light.DarkActionBar.

00:28:29.300 --> 00:28:31.660
I have an issue in which I
cannot find where to set the

00:28:31.660 --> 00:28:34.610
color of the edit text
in the search view.

00:28:34.610 --> 00:28:38.930
Can I use a custom layout
for the searchView?

00:28:38.930 --> 00:28:42.110
So, I'm not really sure on
the answer for this one.

00:28:42.110 --> 00:28:48.910
And I think the answer is that
the attributes available on

00:28:48.910 --> 00:28:51.780
searchView are not customizable,
in the sense

00:28:51.780 --> 00:28:53.320
that they are not stylable
attributes.

00:28:53.320 --> 00:28:58.465
So if you need to change the
color, you probably would want

00:28:58.465 --> 00:29:02.870
to wrap the view from the
layout during runtime.

00:29:02.870 --> 00:29:06.480
Programmatically that is on PA
you would want to find the

00:29:06.480 --> 00:29:13.320
view with the search-View
ID inside your onCreate.

00:29:13.320 --> 00:29:15.870
And try to grab a reference
for the view.

00:29:15.870 --> 00:29:19.100
And then verify the
properties on it.

00:29:19.100 --> 00:29:20.440
By exploring the layout
final view

00:29:20.440 --> 00:29:23.290
searchView, it's not simple.

00:29:23.290 --> 00:29:29.400
What I can do is I'll send a
note to our UI team and see if

00:29:29.400 --> 00:29:32.450
they have any suggestions on
what can be done here.

00:29:32.450 --> 00:29:36.520
But I doubt if we can customize
the [INAUDIBLE]

00:29:36.520 --> 00:29:37.770
using stylable attributes.

00:29:41.650 --> 00:29:45.570
Alright, let's go to
the next question.

00:29:45.570 --> 00:29:47.820
"Hi, I am a beginner in
Android development.

00:29:47.820 --> 00:29:50.540
And I need some help about
getting information from an

00:29:50.540 --> 00:29:56.470
URL and displayed in a good
UI." So, I think this is a

00:29:56.470 --> 00:30:00.480
very basic question, a pretty
broad question.

00:30:00.480 --> 00:30:05.510
So, in terms of displaying it
in a good UI, we have plenty

00:30:05.510 --> 00:30:07.970
of UI conferences available
and some training classes

00:30:07.970 --> 00:30:12.690
available at Android.com.

00:30:12.690 --> 00:30:16.170
There are also a lot of patterns
and practices which

00:30:16.170 --> 00:30:20.470
you could learn about
from developers at

00:30:20.470 --> 00:30:22.260
Android.com/design.

00:30:22.260 --> 00:30:24.680
We have some design guidelines
and how to build a good UI.

00:30:24.680 --> 00:30:25.885
And some of those
sessions we've

00:30:25.885 --> 00:30:28.460
covered in our last show.

00:30:28.460 --> 00:30:31.500
So you could also visit
our playlist.

00:30:31.500 --> 00:30:35.320
From Youtube go back and catch
up on some of those sessions.

00:30:35.320 --> 00:30:37.650
So really, good UI is kind
of a broad question.

00:30:37.650 --> 00:30:40.670
And there's a lot of resources
available on

00:30:40.670 --> 00:30:41.710
our developer site.

00:30:41.710 --> 00:30:44.770
And you can choose some
of these live shows.

00:30:44.770 --> 00:30:50.380
When it comes to grabbing
information from a URL, so

00:30:50.380 --> 00:30:53.030
what you would need is internet
permission on your

00:30:53.030 --> 00:30:54.480
application, first thing.

00:30:54.480 --> 00:30:58.600
And then you could use a
standard Java URL connection

00:30:58.600 --> 00:31:01.840
APIs, which would allow you
to connect [INAUDIBLE]

00:31:01.840 --> 00:31:04.350
and you could set the
appropriate headers

00:31:04.350 --> 00:31:07.360
authentication Steam by
using URL connection.

00:31:07.360 --> 00:31:11.290
And then download the data
as an HTTP response.

00:31:11.290 --> 00:31:14.550
So that's the way
for doing it.

00:31:14.550 --> 00:31:17.620
And one thing to note here
is that if you must use

00:31:17.620 --> 00:31:21.780
Gingerbread, we recommend that
before she I'm going to

00:31:21.780 --> 00:31:25.660
different people losing URL
connection there so that was

00:31:25.660 --> 00:31:27.800
some issues with URL connection
client before

00:31:27.800 --> 00:31:28.210
[INAUDIBLE].

00:31:28.210 --> 00:31:32.120
So, if you are building an app
that's meant to be compatible

00:31:32.120 --> 00:31:36.190
across the entire range of
devices, and it should be, you

00:31:36.190 --> 00:31:37.760
should consider the fact.

00:31:37.760 --> 00:31:41.310
If you look at the runtime,
you could look at the

00:31:41.310 --> 00:31:42.280
build of the OS.

00:31:42.280 --> 00:31:44.120
And then choose do
use a different

00:31:44.120 --> 00:31:44.730
client to get the data.

00:31:44.730 --> 00:31:46.630
So that's [INAUDIBLE]

00:31:46.630 --> 00:31:47.880
client.

00:31:49.500 --> 00:31:53.470
Are there any more resources
you'd like to point to?

00:31:53.470 --> 00:31:56.160
ANKUR KOTWAL: No, just our
colleague David Chandler had

00:31:56.160 --> 00:32:01.950
written a nice little library to
fetch information from the

00:32:01.950 --> 00:32:04.760
net, basically passing
the URL.

00:32:04.760 --> 00:32:10.660
And it just sort of abstracted
a lot of detail for you.

00:32:10.660 --> 00:32:12.260
Yeah, look up David Chandler
on Google+.

00:32:12.260 --> 00:32:15.938
And he's got a really nice
library that you can use.

00:32:15.938 --> 00:32:17.188
ANIRUDH DEWANI: Alright,
great.

00:32:19.500 --> 00:32:22.000
ANKUR KOTWAL: I can take this
one. "Could you please

00:32:22.000 --> 00:32:25.570
describe the best strategy for
working with Fragments and

00:32:25.570 --> 00:32:27.720
loaders is in a map Activity?

00:32:27.720 --> 00:32:33.010
Any plans of supporting
Fragments in a map Activity?"

00:32:33.010 --> 00:32:36.840
So, the honest truth is it's
pretty difficult, right?

00:32:40.920 --> 00:32:44.930
The map Activity is something
that we sort of released

00:32:44.930 --> 00:32:47.440
fairly early on.

00:32:47.440 --> 00:32:51.040
And it obviously provides the
map component part of it.

00:32:51.040 --> 00:32:54.330
But it's not a traditional
Activity.

00:32:54.330 --> 00:32:56.720
What you need is a Fragment
Activity from a support

00:32:56.720 --> 00:32:58.420
library if you want
to use Fragments.

00:32:58.420 --> 00:33:01.880
So in some ways, map Activity
and Fragment activities are

00:33:01.880 --> 00:33:04.600
kind of divergent from
one another.

00:33:07.300 --> 00:33:09.540
I've seen developers do
it with all sorts

00:33:09.540 --> 00:33:11.850
of tricks and hacks.

00:33:11.850 --> 00:33:15.630
But I also know that there's
been some complications in

00:33:15.630 --> 00:33:18.860
having to do it that way.

00:33:18.860 --> 00:33:23.370
We would love to be able to just
use maps in a Fragment.

00:33:23.370 --> 00:33:26.240
We, as in Google, haven't
published anything yet.

00:33:26.240 --> 00:33:29.170
It's actually a fairly common
request that we get.

00:33:29.170 --> 00:33:30.250
And so, we are.

00:33:30.250 --> 00:33:32.110
We're definitely looking
into it.

00:33:32.110 --> 00:33:36.760
We don't have anything here to
announce from a map Fragment

00:33:36.760 --> 00:33:38.010
point of view.

00:33:40.100 --> 00:33:44.670
ANIRUDH DEWANI: So, I think that
was the last question.

00:33:44.670 --> 00:33:46.780
ANKUR KOTWAL: Just checking if
there's any other question on

00:33:46.780 --> 00:33:50.670
the on-air thread, which there
doesn't seem to be.

00:33:56.450 --> 00:34:00.040
Does anyone live have any other
questions before, or we

00:34:00.040 --> 00:34:03.780
should wrap up, is the
other question?

00:34:03.780 --> 00:34:05.250
ANIRUDH DEWANI: So, I
think [? Balisabu ?]

00:34:05.250 --> 00:34:07.990
from Bangalore who asked the
Connectivity API question I

00:34:07.990 --> 00:34:10.219
thought we handled.

00:34:10.219 --> 00:34:11.620
If you have other follow-up
questions, you could

00:34:11.620 --> 00:34:12.870
ask us right now.

00:34:15.659 --> 00:34:16.940
ANKUR KOTWAL: Alright, well
it doesn't look like it.

00:34:16.940 --> 00:34:19.230
Maybe he's shy.

00:34:19.230 --> 00:34:22.880
Or maybe he just doesn't have
any follow-up questions.

00:34:22.880 --> 00:34:25.260
On that note, I guess
we'll head off.

00:34:25.260 --> 00:34:26.895
Thank you for joining
us again.

00:34:26.895 --> 00:34:29.900
And we'll be back same
time next week.

00:34:29.900 --> 00:34:31.880
Thanks for joining.

00:34:31.880 --> 00:34:32.120
ANIRUDH DEWANI: Thank you.

00:34:32.120 --> 00:34:33.370
Bye-bye.

