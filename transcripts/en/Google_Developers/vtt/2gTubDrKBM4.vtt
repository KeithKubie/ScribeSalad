WEBVTT
Kind: captions
Language: en

00:00:11.904 --> 00:00:13.540
JOHN MCCUTCHAN: Hi, everyone.

00:00:13.540 --> 00:00:14.510
Thanks for coming.

00:00:14.510 --> 00:00:16.470
I'm John McCutchan.

00:00:16.470 --> 00:00:19.390
I'm a software engineer on
the Dart virtual machine.

00:00:19.390 --> 00:00:20.890
And later on today,
I'll give a talk

00:00:20.890 --> 00:00:22.310
on the Dart
programming language.

00:00:22.310 --> 00:00:23.726
But for now, I
want to talk to you

00:00:23.726 --> 00:00:26.801
all about creating
games in HTML5.

00:00:26.801 --> 00:00:31.720
This talk is going to
kind of cover everything,

00:00:31.720 --> 00:00:35.440
from the basic tech stack and
some frameworks to some kind

00:00:35.440 --> 00:00:39.240
interesting, cutting
edge ideas of how

00:00:39.240 --> 00:00:42.460
to make HTML5 games
really compelling.

00:00:42.460 --> 00:00:43.420
So let's get started.

00:00:46.570 --> 00:00:50.440
So there's a lot of success
stories out there right now.

00:00:50.440 --> 00:00:55.340
There's a 3D graphics and
physics engine designed

00:00:55.340 --> 00:00:59.780
for making HTML5 games produced
by the Turbulenz company.

00:00:59.780 --> 00:01:03.550
They make some really high tech
stuff, a very advanced physics

00:01:03.550 --> 00:01:05.390
engine and rendering engine.

00:01:05.390 --> 00:01:08.520
And it's entirely open source
so that you can go and grab

00:01:08.520 --> 00:01:12.030
it and start developing
with it for free.

00:01:12.030 --> 00:01:16.210
Nickelodeon has made
hundreds of HTML5 games

00:01:16.210 --> 00:01:18.730
and has a lot of
active users on them.

00:01:18.730 --> 00:01:24.180
And recently, as part of
a push for HTML5 games,

00:01:24.180 --> 00:01:27.510
the people behind "Cut the
Rope" ported it to HTML5,

00:01:27.510 --> 00:01:30.100
and they have a really good
kind of post mortem of what

00:01:30.100 --> 00:01:34.140
it took to go from Objective-C,
an iPhone application,

00:01:34.140 --> 00:01:37.050
to a native HTML5 game.

00:01:37.050 --> 00:01:40.130
And they seem to have had
a very positive experience.

00:01:43.640 --> 00:01:45.330
So there's a few
frameworks out there.

00:01:45.330 --> 00:01:46.750
I've already
mentioned Turbulenz.

00:01:46.750 --> 00:01:50.480
But an interesting
one is Impact.JS,

00:01:50.480 --> 00:01:56.030
which allows you to develop an
application once that will run

00:01:56.030 --> 00:02:01.930
on Android phones, iPhone,
in browsers, everywhere.

00:02:01.930 --> 00:02:08.210
And Impact is primarily used
for 2D graphics development.

00:02:08.210 --> 00:02:09.810
So these are some
frameworks that you

00:02:09.810 --> 00:02:12.265
might want to pick up instead
of starting from scratch.

00:02:16.760 --> 00:02:20.790
So I want to talk
about the tech stack.

00:02:20.790 --> 00:02:24.110
This talk is kind
of taking anyone

00:02:24.110 --> 00:02:26.360
who doesn't know anything
about HTML5 game development

00:02:26.360 --> 00:02:27.720
and bootstrapping you up.

00:02:27.720 --> 00:02:29.510
So it's really
important to understand

00:02:29.510 --> 00:02:33.430
what's available to
you as a developer.

00:02:33.430 --> 00:02:36.010
So this is at a
really high level.

00:02:36.010 --> 00:02:37.840
Along the top, we have
different languages

00:02:37.840 --> 00:02:43.180
that you can access the HTML5
APIs through, JavaScript, Dart.

00:02:43.180 --> 00:02:46.060
And on the right is PNaCl, and
I'll talk a little bit more

00:02:46.060 --> 00:02:47.930
about that later on.

00:02:47.930 --> 00:02:51.560
But HTML5, from a game
developer's perspective,

00:02:51.560 --> 00:02:56.930
consists mostly of
Canvas, WebGL, WebAudio,

00:02:56.930 --> 00:02:59.710
and some miscellaneous APIs,
which I'll cover momentarily.

00:03:03.020 --> 00:03:05.550
So the canvas that's
available in HTML5

00:03:05.550 --> 00:03:09.300
is a 2D pixel storage buffer.

00:03:09.300 --> 00:03:14.360
And this has 32 bits
per pixel of resolution.

00:03:14.360 --> 00:03:17.450
So this is a byte for red,
green, blue, and alpha.

00:03:17.450 --> 00:03:20.660
You can control how
large of a buffer

00:03:20.660 --> 00:03:22.890
you use to render into with
the width and the height

00:03:22.890 --> 00:03:23.990
properties.

00:03:23.990 --> 00:03:27.520
This is not how big it's
displayed on the page.

00:03:27.520 --> 00:03:30.820
You can scale up your
canvas to be full screen

00:03:30.820 --> 00:03:33.490
or as small as you want, but
you have to be aware of that

00:03:33.490 --> 00:03:37.450
when you're kind of creating
the resolution of the surface

00:03:37.450 --> 00:03:40.580
that your game will
be rendered upon.

00:03:40.580 --> 00:03:42.340
Canvas offers two
ways of interacting

00:03:42.340 --> 00:03:43.980
with the pixel data.

00:03:43.980 --> 00:03:49.700
You can issue 2-D vector
graphics operations and render

00:03:49.700 --> 00:03:52.250
in something like
SVG, PostScript,

00:03:52.250 --> 00:03:54.940
PDF rendering model.

00:03:54.940 --> 00:03:59.240
This allows you to have
really, really crisp looking

00:03:59.240 --> 00:04:01.760
graphics and shapes because
everything's vectorized,

00:04:01.760 --> 00:04:06.860
and regardless of how much
zoom you have applied,

00:04:06.860 --> 00:04:10.520
the lines are always
anti-aliased nicely.

00:04:10.520 --> 00:04:13.290
For more of a
direct approach, you

00:04:13.290 --> 00:04:17.089
can actually get at the pixel
data stored in the canvas.

00:04:17.089 --> 00:04:18.670
You can read it
with getImageData,

00:04:18.670 --> 00:04:21.519
and this returns a
typed array back to you.

00:04:21.519 --> 00:04:24.600
And then you can actually
alter the pixel color values

00:04:24.600 --> 00:04:26.091
directly.

00:04:26.091 --> 00:04:28.090
And then when you're done,
you can putImageData,

00:04:28.090 --> 00:04:30.154
and that will update
the data in the canvas

00:04:30.154 --> 00:04:31.445
element that's being displayed.

00:04:34.439 --> 00:04:35.980
So I want to take
a quick second here

00:04:35.980 --> 00:04:41.300
to show you a canvas-based game.

00:04:41.300 --> 00:04:45.770
This has actually been
written in Impact.JS.

00:04:45.770 --> 00:04:47.700
Sorry about the screen
resolution size.

00:04:47.700 --> 00:04:50.230
We're a little cramped here.

00:05:07.330 --> 00:05:10.180
So you get the idea
of the kind of game

00:05:10.180 --> 00:05:12.740
that you can make just
purely canvas based.

00:05:12.740 --> 00:05:15.310
And this is built
using Impact.JS,

00:05:15.310 --> 00:05:18.230
which has a level editor and a
lot of other content creation

00:05:18.230 --> 00:05:18.860
utilities.

00:05:18.860 --> 00:05:22.910
So you can get yourself
to a game of this caliber

00:05:22.910 --> 00:05:23.990
relatively quickly.

00:05:31.860 --> 00:05:36.060
Built on top of Canvas is WebGL.

00:05:36.060 --> 00:05:39.140
WebGL actually sits on
top of a canvas element,

00:05:39.140 --> 00:05:41.720
and instead of getting the
canvas rendering context,

00:05:41.720 --> 00:05:44.110
you get a WebGL
rendering context.

00:05:44.110 --> 00:05:49.360
Right now, WebGL 1.0 is
available in most browsers.

00:05:49.360 --> 00:05:52.340
It's just recently
become available in IE11.

00:05:52.340 --> 00:05:56.520
Before that, there was no
WebGL available in any Internet

00:05:56.520 --> 00:05:58.220
Explorer.

00:05:58.220 --> 00:06:03.440
So WebGL 1.0 kind of
lines up with OpenGL ES

00:06:03.440 --> 00:06:05.670
2.0, which is kind of old.

00:06:05.670 --> 00:06:08.290
It's from 2007.

00:06:08.290 --> 00:06:10.050
So that's almost
seven years old.

00:06:10.050 --> 00:06:12.870
It's starting to feel
a little out of date,

00:06:12.870 --> 00:06:15.916
but it's actually
almost as capable

00:06:15.916 --> 00:06:17.290
in terms of the
graphics that you

00:06:17.290 --> 00:06:21.480
can express as PlayStation
3 or an Xbox 360.

00:06:21.480 --> 00:06:23.010
So despite it being
seven years old,

00:06:23.010 --> 00:06:25.290
you can still make
really compelling

00:06:25.290 --> 00:06:28.620
3D content with WebGL 1.0.

00:06:28.620 --> 00:06:32.230
What's currently in development,
though, is WebGL 2.0.

00:06:32.230 --> 00:06:35.920
And this is mirroring OpenGL
ES 3.0, the specification

00:06:35.920 --> 00:06:38.810
that was just announced
this past summer.

00:06:38.810 --> 00:06:41.610
So next year, when WebGL 2.0
becomes a little bit more

00:06:41.610 --> 00:06:45.087
stable and people can start
experimenting with it,

00:06:45.087 --> 00:06:47.170
you're going to get a lot
of really cool features,

00:06:47.170 --> 00:06:51.450
and the graphics API is
going to be very current.

00:06:51.450 --> 00:06:54.240
I mean, cell phones are
just now getting access

00:06:54.240 --> 00:06:56.450
to OpenGL ES 3.0 content.

00:06:56.450 --> 00:07:02.460
So you can see how close the
HTML5 platform is aligning

00:07:02.460 --> 00:07:04.185
itself with native
software development.

00:07:08.237 --> 00:07:09.820
Of course, the big
question with WebGL

00:07:09.820 --> 00:07:11.760
is, what about mobile devices.

00:07:11.760 --> 00:07:15.420
One, can you use WebGL
on an Android device?

00:07:15.420 --> 00:07:20.860
And the answer is, in
Chrome 30 for Android,

00:07:20.860 --> 00:07:24.980
WebGL will be enabled by
default for many devices.

00:07:24.980 --> 00:07:27.080
Today, though, you can go
in, and you can actually

00:07:27.080 --> 00:07:30.150
enable an experimental
flag in Chrome on Android

00:07:30.150 --> 00:07:34.430
and get access to a WebGL
rendering context on the phone.

00:07:34.430 --> 00:07:36.270
So you can start
development today

00:07:36.270 --> 00:07:38.320
knowing that going
forward in time,

00:07:38.320 --> 00:07:41.205
WebGL will become more
pervasive on mobile platforms.

00:07:44.840 --> 00:07:47.820
So there's also WebAudio, and
this is how you play sounds.

00:07:47.820 --> 00:07:50.490
WebAudio is a really powerful
audio playback engine.

00:07:50.490 --> 00:07:52.830
It has extremely low latency.

00:07:52.830 --> 00:07:54.211
You can actually schedule clips.

00:07:54.211 --> 00:07:55.710
And when you're
making a video game,

00:07:55.710 --> 00:07:59.800
it's really important that when
the bullet graphically hits

00:07:59.800 --> 00:08:03.710
the wall, that the sound effect
plays at that exact instant.

00:08:03.710 --> 00:08:06.650
If they're out of sync, the
user experience is not the same.

00:08:06.650 --> 00:08:10.626
It's not as immersive
as it should be.

00:08:10.626 --> 00:08:12.750
But with WebAudio, you can
actually schedule clips.

00:08:12.750 --> 00:08:14.953
So in your game
logic, you know when

00:08:14.953 --> 00:08:16.710
the bullet is going
to hit the wall,

00:08:16.710 --> 00:08:18.934
or when the player--
when Mario's going

00:08:18.934 --> 00:08:20.100
to smash through the bricks.

00:08:20.100 --> 00:08:21.950
You can predict
forward in time when

00:08:21.950 --> 00:08:23.610
that's going to
occur and schedule

00:08:23.610 --> 00:08:25.730
the sound effect so
it happened then.

00:08:25.730 --> 00:08:28.632
So WebAudio is perfect
for creating video games.

00:08:28.632 --> 00:08:30.090
It also has some
really cool things

00:08:30.090 --> 00:08:33.049
like filters and 3D
positional effects.

00:08:33.049 --> 00:08:37.960
So you can actually, as the
player moves through the world,

00:08:37.960 --> 00:08:41.289
you can move the kind of
virtual microphone that

00:08:41.289 --> 00:08:44.240
is hearing sounds, playing
through your speakers,

00:08:44.240 --> 00:08:47.540
with the player, so that when
an enemy is behind the player,

00:08:47.540 --> 00:08:49.680
they'll actually
hear it if they have

00:08:49.680 --> 00:08:52.440
a sophisticated enough stereo.

00:08:52.440 --> 00:08:55.380
And of course, it supports
all the standard file formats.

00:08:55.380 --> 00:08:58.970
Some miscellaneous APIs
that are important for games

00:08:58.970 --> 00:09:03.050
are the fullscreen API, and this
allows you to take any element

00:09:03.050 --> 00:09:07.460
and actually have it
own the entire screen,

00:09:07.460 --> 00:09:08.360
and pointer lock.

00:09:08.360 --> 00:09:11.000
And pointer lock is really
important for first person

00:09:11.000 --> 00:09:11.580
shooters.

00:09:11.580 --> 00:09:15.860
And I've actually written an
article on how to implement

00:09:15.860 --> 00:09:20.290
"Quake" or "Doom"-style keyboard
and mouse input in an HTML5

00:09:20.290 --> 00:09:23.190
game using pointer lock.

00:09:23.190 --> 00:09:26.330
Something that will become more
and more important as games

00:09:26.330 --> 00:09:28.932
on the web become more
sophisticated is web workers.

00:09:28.932 --> 00:09:30.390
And web workers
will actually allow

00:09:30.390 --> 00:09:35.490
you to farm off work that
is computationally expensive

00:09:35.490 --> 00:09:38.160
and move it onto a
separate thread that

00:09:38.160 --> 00:09:39.897
doesn't block the
render process.

00:09:39.897 --> 00:09:41.480
By doing this, it
will allow your game

00:09:41.480 --> 00:09:44.450
to continue to have 60 frames
per second while doing work

00:09:44.450 --> 00:09:49.060
that might computationally
take a long time in an isolated

00:09:49.060 --> 00:09:54.190
worker, away from
your render thread.

00:09:54.190 --> 00:09:57.160
So I said we'd talk a
little bit about PNaCL.

00:09:57.160 --> 00:09:59.380
And PNaCL is Portable
Native Client.

00:09:59.380 --> 00:10:04.970
So Native Client gives
sandbox native code execution.

00:10:04.970 --> 00:10:10.090
So Native Client consists of a C
and C++ compiler and the Native

00:10:10.090 --> 00:10:14.300
Client SDK, which gives
you standard Unix APIs.

00:10:14.300 --> 00:10:18.100
So if you have an application
already written in C

00:10:18.100 --> 00:10:22.750
that runs on Mac OS or Linux,
porting to Native Client

00:10:22.750 --> 00:10:24.240
is trivial.

00:10:24.240 --> 00:10:27.470
All of the standard APIs that
you expect a Unix operating

00:10:27.470 --> 00:10:31.840
system to present to you,
they're available, they run.

00:10:31.840 --> 00:10:34.240
And you can actually
have POSIX threads.

00:10:34.240 --> 00:10:40.650
You can have a shared-memory
concurrent multi-threaded

00:10:40.650 --> 00:10:42.160
execution environment,
all running

00:10:42.160 --> 00:10:45.770
inside of the browser
safely and securely.

00:10:45.770 --> 00:10:50.050
You get things like standard
File I/O, BSD sockets.

00:10:50.050 --> 00:10:53.200
You can open up a TCP connection
and connect out to a server

00:10:53.200 --> 00:10:56.450
or have someone connect to you.

00:10:56.450 --> 00:11:00.620
Alongside of the C compiler
and the Native Client SDK,

00:11:00.620 --> 00:11:02.890
there is the Pepper Plugin API.

00:11:02.890 --> 00:11:06.050
And this actually exposes all
of the HTML5 features that

00:11:06.050 --> 00:11:10.100
I've just talked about,
like WebGL and Canvas,

00:11:10.100 --> 00:11:14.095
and actually gives you a C++
interface to those features,

00:11:14.095 --> 00:11:18.120
so you can actually leverage
all of these things that are

00:11:18.120 --> 00:11:22.770
available to HTML5 in C. And
of course, with Native Client,

00:11:22.770 --> 00:11:26.640
you get really close to
native CPU performance.

00:11:26.640 --> 00:11:30.120
And I've got a demo later on
showing how you can actually

00:11:30.120 --> 00:11:33.764
bridge these two worlds and
write a game that is partially

00:11:33.764 --> 00:11:35.555
written in JavaScript
and partially written

00:11:35.555 --> 00:11:38.120
in Native Client and get some
really exciting stuff out

00:11:38.120 --> 00:11:38.620
of it.

00:11:42.150 --> 00:11:44.320
So for those of
you who don't know,

00:11:44.320 --> 00:11:46.040
I come from the games industry.

00:11:46.040 --> 00:11:48.830
I used to work for
PlayStation for many years.

00:11:48.830 --> 00:11:50.970
And probably the thing
that game developers

00:11:50.970 --> 00:11:53.750
are obsessed the most
with is performance.

00:11:53.750 --> 00:11:56.860
And you want 60
frames per second.

00:11:56.860 --> 00:11:59.460
You want to have your
game run really smooth.

00:11:59.460 --> 00:12:03.730
So it's important that,
coming to the HTML5 platform,

00:12:03.730 --> 00:12:06.550
game developers understand where
some of the common performance

00:12:06.550 --> 00:12:07.080
traps are.

00:12:10.960 --> 00:12:14.620
So JavaScript lets you be really
fast and loose with types.

00:12:14.620 --> 00:12:16.670
Everything in
JavaScript is an object,

00:12:16.670 --> 00:12:18.881
and you can manipulate
it anytime you want.

00:12:18.881 --> 00:12:21.130
You can add a new property
to an object in JavaScript.

00:12:21.130 --> 00:12:23.100
You can remove a property.

00:12:23.100 --> 00:12:24.400
You can do whatever you want.

00:12:24.400 --> 00:12:27.010
But your JavaScript
execution engine,

00:12:27.010 --> 00:12:31.030
like V8 or SpiderMonkey,
they really, really

00:12:31.030 --> 00:12:35.500
want you to be as
static as possible.

00:12:35.500 --> 00:12:37.640
So in the VM world,
we call this modifying

00:12:37.640 --> 00:12:40.070
the shape of an object, meaning
whenever you add or remove

00:12:40.070 --> 00:12:41.670
a property, you're
changing the way

00:12:41.670 --> 00:12:45.820
this object looks in terms
of the memory layout.

00:12:45.820 --> 00:12:48.440
And JavaScript engines
want a static shape.

00:12:48.440 --> 00:12:51.090
So if you see this
code here on the wall,

00:12:51.090 --> 00:12:53.500
we have a Player class.

00:12:53.500 --> 00:12:58.920
And inside there, we
add the x property,

00:12:58.920 --> 00:13:02.720
the y property, health property.

00:13:02.720 --> 00:13:06.350
And then your code
instantiates the Player class.

00:13:06.350 --> 00:13:10.610
And then at some point later on,
indicated by this arrow here,

00:13:10.610 --> 00:13:14.660
some piece of code adds the
items array to the player.

00:13:14.660 --> 00:13:18.530
The player now can hold
items in its inventory.

00:13:18.530 --> 00:13:22.620
But the moment that happens,
the runtime undoes all

00:13:22.620 --> 00:13:25.140
of the code optimization that
has occurred, and your game

00:13:25.140 --> 00:13:27.210
starts running slowly
for a little while.

00:13:27.210 --> 00:13:28.400
It can recover.

00:13:28.400 --> 00:13:32.070
But if you do this enough, the
JavaScript execution engine

00:13:32.070 --> 00:13:37.040
will just throw up its hands
and say, objects of this class

00:13:37.040 --> 00:13:41.111
change so frequently, I
can't optimize for them.

00:13:41.111 --> 00:13:43.360
And at that point, the
performance of your application

00:13:43.360 --> 00:13:44.484
is going to suffer greatly.

00:13:47.390 --> 00:13:49.850
Similarly, all method
dispatch in JavaScript

00:13:49.850 --> 00:13:51.150
is done at run-time.

00:13:51.150 --> 00:13:52.720
But again, your
JavaScript engine

00:13:52.720 --> 00:13:56.140
wants you to be as
strict as possible

00:13:56.140 --> 00:13:58.280
to get the most performance.

00:13:58.280 --> 00:14:02.140
So inside the function
tickObject on the slide,

00:14:02.140 --> 00:14:06.700
you can see that a variable
called obj is passed in,

00:14:06.700 --> 00:14:09.030
and then the tick
method is invoked in it.

00:14:09.030 --> 00:14:12.070
And since JavaScript
doctyped, so long

00:14:12.070 --> 00:14:14.950
as obj can respond to tick,
this code will execute.

00:14:14.950 --> 00:14:15.560
It's safe.

00:14:15.560 --> 00:14:16.710
It's great.

00:14:16.710 --> 00:14:19.100
But if there's many
different types

00:14:19.100 --> 00:14:21.990
of objects being seen
at that call site

00:14:21.990 --> 00:14:24.920
where the arrow is, the
JavaScript engine again

00:14:24.920 --> 00:14:27.930
will say, OK, well, first
it was just one type.

00:14:27.930 --> 00:14:29.820
Now it's a few types,
and I'm OK with that.

00:14:29.820 --> 00:14:31.820
But then after
four or five types,

00:14:31.820 --> 00:14:36.110
it's just going to give up
because the state of the world

00:14:36.110 --> 00:14:40.890
is so dynamic that the
gains from optimizing

00:14:40.890 --> 00:14:42.650
are thrown away every
time you deoptimize.

00:14:46.702 --> 00:14:48.660
A final performance trap
that you should really

00:14:48.660 --> 00:14:53.090
be aware of with HTML5 games is
the cost of garbage collection.

00:14:53.090 --> 00:14:56.360
Every single time
your game allocates

00:14:56.360 --> 00:15:00.900
memory-- some examples
are at the red arrow,

00:15:00.900 --> 00:15:06.420
calling new on a class, using
array literals or an object map

00:15:06.420 --> 00:15:07.070
literal.

00:15:07.070 --> 00:15:08.620
There are memory allocations.

00:15:08.620 --> 00:15:10.930
Every single one of
these brings your game

00:15:10.930 --> 00:15:13.530
closer and closer and
closer to a pause.

00:15:13.530 --> 00:15:15.690
And when it's paused,
nothing is happening.

00:15:15.690 --> 00:15:17.347
You could be in the
middle of updating

00:15:17.347 --> 00:15:18.680
the player's state in the world.

00:15:18.680 --> 00:15:20.210
Everything is frozen.

00:15:20.210 --> 00:15:23.330
A couple milliseconds tick by,
and you've dropped a frame,

00:15:23.330 --> 00:15:25.530
and the experience
isn't that great.

00:15:25.530 --> 00:15:31.600
There's also some less obvious
locations of memory allocation.

00:15:31.600 --> 00:15:34.480
If you have unoptimized
code or code

00:15:34.480 --> 00:15:37.000
that you triggered a
deoptimization, which we just

00:15:37.000 --> 00:15:40.260
talked about, just
doing simple arithmetic,

00:15:40.260 --> 00:15:43.580
like adding numbers together or
multiplying numbers together,

00:15:43.580 --> 00:15:48.010
every single one of those
operations allocates memory.

00:15:48.010 --> 00:15:49.890
And by doing so,
you're moving yourself

00:15:49.890 --> 00:15:52.170
closer to this
GC, which is going

00:15:52.170 --> 00:15:55.020
to cause a hiccup in your game.

00:15:59.050 --> 00:16:01.400
So I want to talk a
little bit about tools.

00:16:01.400 --> 00:16:04.360
There's a CPU profiler
and a memory profiler

00:16:04.360 --> 00:16:06.120
built into Chrome.

00:16:06.120 --> 00:16:09.579
And I'm not going to talk about
the memory profiler today.

00:16:09.579 --> 00:16:11.870
But I will spend some time
talking about different ways

00:16:11.870 --> 00:16:14.900
to profile CPU
usage in your game.

00:16:14.900 --> 00:16:18.160
Again, game development is
often about squeezing out

00:16:18.160 --> 00:16:20.280
the last little
bit of performance,

00:16:20.280 --> 00:16:22.540
so knowing the tools
that are available to you

00:16:22.540 --> 00:16:26.500
can really help you
make a compelling game.

00:16:26.500 --> 00:16:30.150
So there are two primary
ways of profiling CPU usage.

00:16:30.150 --> 00:16:33.040
The first is sampling, and
the second is structural.

00:16:33.040 --> 00:16:36.810
So sampling is what happens when
you go into Chrome DevTools,

00:16:36.810 --> 00:16:39.250
and you go to
Profiling, and you say,

00:16:39.250 --> 00:16:41.620
collect a JavaScript
CPU profile.

00:16:41.620 --> 00:16:43.010
That's doing sampling profiling.

00:16:43.010 --> 00:16:44.968
And I'm going to go into
a little bit of detail

00:16:44.968 --> 00:16:46.550
about what exactly that is.

00:16:46.550 --> 00:16:50.150
Whereas structural profiling
is a bit harder to get to,

00:16:50.150 --> 00:16:52.980
but it can sometimes provide
you with much more insightful

00:16:52.980 --> 00:16:56.980
information, and we'll see why.

00:16:56.980 --> 00:16:59.370
So sampling CPU
profilers, what they

00:16:59.370 --> 00:17:03.490
do is at a fixed frequency,
say once a millisecond,

00:17:03.490 --> 00:17:05.010
they pause your program.

00:17:05.010 --> 00:17:07.900
Instantaneously, they stop
the program's execution.

00:17:07.900 --> 00:17:09.359
They unwind the call stack.

00:17:09.359 --> 00:17:11.839
They figure out
where your code is.

00:17:11.839 --> 00:17:14.210
They record that, and
then your application

00:17:14.210 --> 00:17:16.430
resumes execution again.

00:17:16.430 --> 00:17:19.990
So let's look at a
little example here.

00:17:19.990 --> 00:17:23.440
So let's say that the code is
executing inside bar, right?

00:17:23.440 --> 00:17:27.750
So the sample tick comes in
and pauses your application.

00:17:27.750 --> 00:17:29.920
So bar was called
by foo, and foo

00:17:29.920 --> 00:17:31.479
was called by your main program.

00:17:31.479 --> 00:17:33.270
So the call stack you
can see on the right.

00:17:33.270 --> 00:17:35.760
This is what's collected
by a sampling profiler.

00:17:35.760 --> 00:17:42.960
So at this instant in time, this
is what your program was up to.

00:17:42.960 --> 00:17:45.430
But there's a big
assumption baked into this,

00:17:45.430 --> 00:17:50.400
is that that sample, that
instantaneous moment of looking

00:17:50.400 --> 00:17:53.760
at what your program is doing,
is actually representative

00:17:53.760 --> 00:17:57.600
of what your program is
doing between the samples.

00:17:57.600 --> 00:18:02.050
So if we take a sample, and
then a millisecond goes by,

00:18:02.050 --> 00:18:07.290
and the profiler takes another
sample, and so on and so on,

00:18:07.290 --> 00:18:11.120
we have now four sample of
what your program is doing.

00:18:11.120 --> 00:18:13.400
But what we don't have
is what your program

00:18:13.400 --> 00:18:15.130
was doing between those samples.

00:18:15.130 --> 00:18:19.080
I mean a millisecond is
an eternity for a CPU.

00:18:19.080 --> 00:18:22.510
You could be doing a lot
of things in a millisecond.

00:18:22.510 --> 00:18:25.060
And so this is kind of what
sampling profilers miss out on.

00:18:25.060 --> 00:18:28.210
They don't know what you're
doing between those sample

00:18:28.210 --> 00:18:29.890
ticks.

00:18:29.890 --> 00:18:36.490
So a way to make sample-based
profiling more useful and more

00:18:36.490 --> 00:18:39.330
valuable to you as a
developer is to let it

00:18:39.330 --> 00:18:42.316
run for a long period of
time, because by letting

00:18:42.316 --> 00:18:43.690
it run for a long
period of time,

00:18:43.690 --> 00:18:48.020
you get this coarse average
of what your game has

00:18:48.020 --> 00:18:52.100
been doing across
many, many frames.

00:18:52.100 --> 00:18:55.400
Of course, this doesn't
help you diagnose spikes.

00:18:55.400 --> 00:18:57.580
But it does give you a
very accurate picture

00:18:57.580 --> 00:19:00.165
of what's going on
in a broader sense.

00:19:04.690 --> 00:19:07.400
So when samples are processed
after the sampling is done,

00:19:07.400 --> 00:19:08.790
there are two
pieces of data that

00:19:08.790 --> 00:19:11.680
are extracted from each sample.

00:19:11.680 --> 00:19:14.940
So the first piece of
data is the percentage

00:19:14.940 --> 00:19:18.130
of samples where the
function was a leaf.

00:19:18.130 --> 00:19:20.180
That's like the top
of the call stack.

00:19:20.180 --> 00:19:22.530
It's the thing that's
executing right then.

00:19:22.530 --> 00:19:26.970
The second piece of
data is the percentage

00:19:26.970 --> 00:19:29.470
of samples where the function
was just present in the call

00:19:29.470 --> 00:19:30.920
stack.

00:19:30.920 --> 00:19:35.570
So you can see here that the
first type, exclusive time,

00:19:35.570 --> 00:19:39.240
is blue, bar, because it's
at the top of the call stack.

00:19:39.240 --> 00:19:43.580
Underneath that is foo,
which is inclusive.

00:19:43.580 --> 00:19:47.514
So foo was in the call stack,
but it wasn't actually running

00:19:47.514 --> 00:19:48.680
at the moment of the sample.

00:19:48.680 --> 00:19:50.090
It's not actually
doing any work.

00:19:50.090 --> 00:19:51.990
It's just waiting
for bar to return,

00:19:51.990 --> 00:19:54.800
and then it will continue
on with its execution.

00:19:54.800 --> 00:19:57.335
So these are the two pieces
of data that you get out

00:19:57.335 --> 00:20:01.650
of a sampling-based profiler,
just the percentage of samples

00:20:01.650 --> 00:20:04.820
that you were at the top or
the percentage of samples

00:20:04.820 --> 00:20:07.520
where you were somewhere
in the call stack.

00:20:11.220 --> 00:20:12.660
Let's contrast
sampling profilers

00:20:12.660 --> 00:20:15.530
with structural profilers.

00:20:15.530 --> 00:20:18.390
So in structural CPU
profilers, functions

00:20:18.390 --> 00:20:22.220
are instrumented to record
their entry and exit times.

00:20:22.220 --> 00:20:24.270
So if we look at this,
we have this buffer here.

00:20:24.270 --> 00:20:26.920
So foo gets called
by your main program.

00:20:26.920 --> 00:20:31.340
When we enter foo, we record the
timestamp that foo was entered.

00:20:31.340 --> 00:20:34.430
Then we enter bar, and
we record that timestamp.

00:20:34.430 --> 00:20:36.926
Then we exit bar, and
now we're back in foo,

00:20:36.926 --> 00:20:38.810
and we record the timestamp.

00:20:38.810 --> 00:20:41.330
And then we exit foo, and
then we record the timestamp.

00:20:41.330 --> 00:20:44.990
So if you call foo, foo
calls bar, bar returns,

00:20:44.990 --> 00:20:46.489
this is the data
that you collect

00:20:46.489 --> 00:20:47.530
in a structural profiler.

00:20:50.200 --> 00:20:52.030
So after this data
has been processed,

00:20:52.030 --> 00:20:54.810
there are three data
points per function.

00:20:54.810 --> 00:20:57.450
You get the actual
amount of time.

00:20:57.450 --> 00:21:00.130
Like the sampling profiler
gives you the number of samples,

00:21:00.130 --> 00:21:02.890
the number of times on that
one millisecond interval

00:21:02.890 --> 00:21:03.970
that you were running.

00:21:03.970 --> 00:21:05.678
Whereas structural
will actually give you

00:21:05.678 --> 00:21:07.390
exact timing information.

00:21:07.390 --> 00:21:11.360
The inclusive time, how
much time, including time

00:21:11.360 --> 00:21:13.770
spent in your children,
were you executing,

00:21:13.770 --> 00:21:15.652
and then the
exclusive time, which

00:21:15.652 --> 00:21:17.110
is how much time
were you executing

00:21:17.110 --> 00:21:18.380
at the top of the call stack.

00:21:18.380 --> 00:21:20.960
This is actually how
much time that function

00:21:20.960 --> 00:21:23.690
is using on the CPU.

00:21:23.690 --> 00:21:25.190
And unlike sampling
profilers, you

00:21:25.190 --> 00:21:27.950
can actually get the
exact call count.

00:21:27.950 --> 00:21:30.200
So you can know how many
times a function is called,

00:21:30.200 --> 00:21:33.560
how much time each one of
those function calls took.

00:21:33.560 --> 00:21:38.850
It's a much more detailed,
high resolution amount of data.

00:21:38.850 --> 00:21:41.610
But there's a cost
because there's

00:21:41.610 --> 00:21:44.450
a lot more involved in
gathering these timestamps

00:21:44.450 --> 00:21:47.437
and recording the entry
and exit of every function,

00:21:47.437 --> 00:21:49.270
whereas sampling profilers
can just tick in.

00:21:49.270 --> 00:21:51.186
They can just go tick,
tick, tick, tick, tick.

00:21:51.186 --> 00:21:51.970
It's very fast.

00:21:51.970 --> 00:21:56.310
So the question becomes,
which one should you use?

00:21:56.310 --> 00:21:58.114
And the answer is both.

00:21:58.114 --> 00:22:00.530
You should typically start
with a sampling-based profiler,

00:22:00.530 --> 00:22:02.580
and this will give
you a broad overview

00:22:02.580 --> 00:22:05.200
of where you should be looking.

00:22:05.200 --> 00:22:08.840
And then, kind of like using
break points when you're

00:22:08.840 --> 00:22:12.570
debugging your software, you
should go in and structurally

00:22:12.570 --> 00:22:17.110
profiler chunks of your code
so that you can figure out

00:22:17.110 --> 00:22:19.320
exactly how long the
slow parts are taking

00:22:19.320 --> 00:22:23.050
and where in particular--
when, let's say, collision

00:22:23.050 --> 00:22:26.910
detection is slow, you want
to figure out exactly why

00:22:26.910 --> 00:22:28.880
and where in your
collision detection code

00:22:28.880 --> 00:22:29.960
the slowdown occurs.

00:22:29.960 --> 00:22:32.650
And that's where the
structural profiling will help.

00:22:32.650 --> 00:22:36.276
So just as a summary, in
terms of the contrast,

00:22:36.276 --> 00:22:38.800
sampling gives you
approximate time.

00:22:38.800 --> 00:22:42.410
You can kind of ballpark
it with sampling.

00:22:42.410 --> 00:22:44.670
But structural gives you
the exact amount of time

00:22:44.670 --> 00:22:47.570
that your code has
been executing for.

00:22:47.570 --> 00:22:50.280
Similarly, structural profiling
gives you the exact call count,

00:22:50.280 --> 00:22:53.190
where sampling gives you
a rough approximation.

00:22:53.190 --> 00:22:56.300
Every sample that is taken that
your function is executing,

00:22:56.300 --> 00:22:57.950
you know it was
running, but you don't

00:22:57.950 --> 00:23:01.680
know if it ever returned
or, between two samples,

00:23:01.680 --> 00:23:03.290
if it was running
the whole time.

00:23:03.290 --> 00:23:05.920
Structural profiling
will tell you this.

00:23:05.920 --> 00:23:07.620
The great thing about
sampling profiling

00:23:07.620 --> 00:23:09.540
is that the overhead is tiny.

00:23:09.540 --> 00:23:10.680
It's really, really small.

00:23:10.680 --> 00:23:12.900
You can almost do it for free.

00:23:12.900 --> 00:23:14.650
Whereas structural
profiling, the overhead

00:23:14.650 --> 00:23:15.750
typically can be large.

00:23:15.750 --> 00:23:19.565
And if you insert these
structural markers

00:23:19.565 --> 00:23:20.940
throughout your
entire code base,

00:23:20.940 --> 00:23:24.000
you can drastically slow
down your program, which

00:23:24.000 --> 00:23:26.490
is why I recommend using it
kind of the way you use break

00:23:26.490 --> 00:23:28.860
points, where you kind
of, as you're searching

00:23:28.860 --> 00:23:31.580
for that needle in the
haystack, you move them around,

00:23:31.580 --> 00:23:33.800
and you insert them and
remove them from your code.

00:23:38.440 --> 00:23:40.620
So I've already kind of
covered this a little bit,

00:23:40.620 --> 00:23:43.630
but sampling profiling in
Chrome is just built in.

00:23:43.630 --> 00:23:46.690
You just go to the Profiles
tab in the developer's tool,

00:23:46.690 --> 00:23:48.890
and you can access it.

00:23:48.890 --> 00:23:50.900
There are different ways
to view the samples.

00:23:50.900 --> 00:23:53.740
There's heavy or
the bottom-up view.

00:23:53.740 --> 00:23:56.060
And these are functions
by impact on performance.

00:23:56.060 --> 00:23:59.320
So these are just the most
expensive, exclusive amount

00:23:59.320 --> 00:24:01.320
of time running, they're
going to be at the top.

00:24:01.320 --> 00:24:03.480
There's also the tree,
which just starts at main

00:24:03.480 --> 00:24:07.810
and lets you kind of fan out and
see the whole flow of execution

00:24:07.810 --> 00:24:10.730
as it's occurred.

00:24:10.730 --> 00:24:12.980
You can also filter
by selected functions.

00:24:12.980 --> 00:24:17.740
So if you know that you're
only interested in functions

00:24:17.740 --> 00:24:20.800
in this class, you
can actually kind of

00:24:20.800 --> 00:24:24.320
grep through all the profiling
data and just see that.

00:24:27.260 --> 00:24:29.034
So to use structural
profiling in Chrome,

00:24:29.034 --> 00:24:30.700
it's a little bit
more involved, but I'm

00:24:30.700 --> 00:24:33.960
going to walk you
through the process now.

00:24:33.960 --> 00:24:38.000
If you open up a new tab, and
you go to chrome://tracing,

00:24:38.000 --> 00:24:43.110
you get this internal profiler
that's built to really profile

00:24:43.110 --> 00:24:44.770
the guts of Chrome.

00:24:44.770 --> 00:24:49.530
But you can access and export
data from JavaScript into this,

00:24:49.530 --> 00:24:52.000
and this will give you
the structural profiling

00:24:52.000 --> 00:24:54.560
that I've been talking about.

00:24:54.560 --> 00:24:56.820
So the big trick here
is that you actually

00:24:56.820 --> 00:24:59.325
have to go into your
JavaScript code and instrument

00:24:59.325 --> 00:25:04.590
it by inserting console.time and
console.timeEnd function calls.

00:25:04.590 --> 00:25:06.310
So inside foo, you
can see that there's

00:25:06.310 --> 00:25:09.910
console.time foo,
console.timeEnd foo, similarly

00:25:09.910 --> 00:25:12.100
in bar.

00:25:12.100 --> 00:25:14.160
The overhead of
these macros is tiny

00:25:14.160 --> 00:25:16.710
when Chrome tracing is not on.

00:25:16.710 --> 00:25:18.960
So you can, in
some circumstances,

00:25:18.960 --> 00:25:22.030
just leave them in without a
noticeable performance impact.

00:25:22.030 --> 00:25:24.586
But when Chrome
tracing is on, that's

00:25:24.586 --> 00:25:25.960
when they actually
get evaluated,

00:25:25.960 --> 00:25:27.390
and the data is
collected, and then

00:25:27.390 --> 00:25:28.770
the performance
impact can be larger.

00:25:28.770 --> 00:25:31.390
So it's important to understand
that structure profiling can

00:25:31.390 --> 00:25:34.394
kind of skew the
performance characteristics

00:25:34.394 --> 00:25:35.060
of your program.

00:25:38.250 --> 00:25:40.850
So once you've gone and you've
inserted the console.time

00:25:40.850 --> 00:25:42.974
and timeEnds
throughout your code,

00:25:42.974 --> 00:25:44.390
you then go over
to Chrome tracing

00:25:44.390 --> 00:25:46.050
and you start recording.

00:25:46.050 --> 00:25:49.032
You go back to your tab,
you interact with it,

00:25:49.032 --> 00:25:50.240
you run the game for a while.

00:25:50.240 --> 00:25:52.840
Then you go back,
and you press stop.

00:25:52.840 --> 00:25:56.430
And then you can inspect
the Chrome tracing timeline.

00:25:56.430 --> 00:26:00.840
And how you do that is kind of
beyond the scope of this talk.

00:26:00.840 --> 00:26:03.670
But there are many articles,
and I've given talks

00:26:03.670 --> 00:26:06.540
in the past that go into much
more detail about how you

00:26:06.540 --> 00:26:10.040
can actually inspect
the timeline.

00:26:12.910 --> 00:26:14.340
But the most
important thing when

00:26:14.340 --> 00:26:15.840
it comes to performance
in your game

00:26:15.840 --> 00:26:18.770
is that you should
actually have a budget.

00:26:18.770 --> 00:26:21.110
So before you go and
start writing your game,

00:26:21.110 --> 00:26:24.140
you should try and divvy up
the 16 milliseconds that you

00:26:24.140 --> 00:26:27.770
have for your frame
to various subsystems,

00:26:27.770 --> 00:26:33.560
maybe three milliseconds for
AI, five milliseconds to draw,

00:26:33.560 --> 00:26:35.592
two milliseconds for
the player movement,

00:26:35.592 --> 00:26:36.550
or something like that.

00:26:36.550 --> 00:26:39.020
You should know
how much time you

00:26:39.020 --> 00:26:43.170
want to devote to each system
before you start development.

00:26:43.170 --> 00:26:45.842
And you should track
this over time.

00:26:45.842 --> 00:26:47.550
Like I said at the
beginning of the talk,

00:26:47.550 --> 00:26:51.170
I work on the Dart
VM, and we have

00:26:51.170 --> 00:26:53.110
bots that, after
every single commit

00:26:53.110 --> 00:26:55.774
we make, the bots go
out and actually run

00:26:55.774 --> 00:26:56.690
a bunch of benchmarks.

00:26:56.690 --> 00:26:59.260
And they will tell
you, you increased

00:26:59.260 --> 00:27:01.500
the speed of this
benchmark by 2%,

00:27:01.500 --> 00:27:06.410
or you decreased the speed
of this chunk of code by 20%.

00:27:06.410 --> 00:27:09.640
And this is graphed over time.

00:27:09.640 --> 00:27:10.515
So you make a commit.

00:27:10.515 --> 00:27:12.140
And you can go in,
and you can actually

00:27:12.140 --> 00:27:14.040
confirm that not
only have you not

00:27:14.040 --> 00:27:16.200
regressed the
performance of your game,

00:27:16.200 --> 00:27:19.390
but that you've increased
it the way you expect to.

00:27:19.390 --> 00:27:23.890
And you can see this
continued over time.

00:27:23.890 --> 00:27:26.120
So if you really are
serious about performance,

00:27:26.120 --> 00:27:29.760
investing in something like this
might seem a bit heavy upfront,

00:27:29.760 --> 00:27:31.670
but it really does pay
dividends in the end.

00:27:43.600 --> 00:27:47.220
Now I want to talk about
Portable Native Client

00:27:47.220 --> 00:27:50.430
Acceleration Modules.

00:27:50.430 --> 00:27:55.210
So what if you could have 90%
of your application written

00:27:55.210 --> 00:28:00.330
in JavaScript, written
in just the DOM, just JS,

00:28:00.330 --> 00:28:02.810
but like 10% of
your application,

00:28:02.810 --> 00:28:06.020
where the CPU performance
really matters,

00:28:06.020 --> 00:28:08.760
could be written in C and C++?

00:28:08.760 --> 00:28:11.190
This is what Native Client
Acceleration Modules gives you.

00:28:13.970 --> 00:28:18.775
It allows you to extend
JavaScript or Dart with C++.

00:28:18.775 --> 00:28:20.260
So NaCl works like this.

00:28:20.260 --> 00:28:23.430
You feed C++ code into
the NaCl compiler.

00:28:23.430 --> 00:28:28.350
And the output of this is the
NaCl EXE and a manifest file.

00:28:28.350 --> 00:28:31.940
You insert a single
tag inside your HTML

00:28:31.940 --> 00:28:35.240
which references that manifest.

00:28:35.240 --> 00:28:37.890
And then, boom, your
Native Client application

00:28:37.890 --> 00:28:42.610
is actually executing
inside that tag at close

00:28:42.610 --> 00:28:44.630
to native speed.

00:28:44.630 --> 00:28:48.480
So NaCl gives you a secure
C/C++ runtime for the web.

00:28:48.480 --> 00:28:50.780
Existing C and C++ code works.

00:28:50.780 --> 00:28:54.740
There are people who have
successfully run C# code under

00:28:54.740 --> 00:28:58.430
the NaCl sandbox.

00:28:58.430 --> 00:29:01.139
And as discussed, you can
interact with the browser

00:29:01.139 --> 00:29:02.680
through the Pepper
API and get access

00:29:02.680 --> 00:29:05.430
to 3D graphics and
all of the great stuff

00:29:05.430 --> 00:29:08.850
that's available in HTML5.

00:29:08.850 --> 00:29:11.115
But it requires that
the entire application

00:29:11.115 --> 00:29:15.290
be written in C. That's kind
of the classic NaCl story.

00:29:15.290 --> 00:29:19.460
But we can leverage NaCl as
an acceleration framework.

00:29:19.460 --> 00:29:21.870
Just kind of how you
leverage your GPU

00:29:21.870 --> 00:29:24.290
to draw really fast
3D graphics, you

00:29:24.290 --> 00:29:28.860
can leverage NaCl to do
the computation for you

00:29:28.860 --> 00:29:29.510
very quickly.

00:29:33.030 --> 00:29:36.314
So the questions are, can we
provide the native performance

00:29:36.314 --> 00:29:36.980
where it counts?

00:29:36.980 --> 00:29:39.660
Because if you look
at most applications,

00:29:39.660 --> 00:29:42.330
there's only a few places where
performance really matters.

00:29:42.330 --> 00:29:45.500
The rest of it,
it's fast enough.

00:29:45.500 --> 00:29:47.300
You'll never slow it down.

00:29:47.300 --> 00:29:49.290
But code where you're
executing it in a loop

00:29:49.290 --> 00:29:50.970
or doing a lot of
computation, that's

00:29:50.970 --> 00:29:53.320
where you want the
native performance.

00:29:53.320 --> 00:29:56.021
And that's what Native Client
Acceleration Modules give you.

00:29:56.021 --> 00:29:58.270
So at a really high level,
it kind of works like this.

00:29:58.270 --> 00:30:04.240
By passing messages via
postMessage between the NaCl

00:30:04.240 --> 00:30:10.020
module and the JavaScript world
through your render process,

00:30:10.020 --> 00:30:13.080
you can kind of
send work to C++,

00:30:13.080 --> 00:30:15.460
have the work execute there.

00:30:15.460 --> 00:30:17.050
And then when the
work is done, you'll

00:30:17.050 --> 00:30:22.500
get a message back
giving you the result.

00:30:22.500 --> 00:30:23.560
So how do you build this?

00:30:23.560 --> 00:30:26.170
Well, you take an
existing C++ library,

00:30:26.170 --> 00:30:27.820
or you write a new one.

00:30:27.820 --> 00:30:30.480
And then you expose--
you put an interface

00:30:30.480 --> 00:30:33.540
on top of that library that's
built around message passing.

00:30:33.540 --> 00:30:38.410
It's built around the idea of
asynchronous computation, where

00:30:38.410 --> 00:30:40.860
you're delivered a bundle
that you're expected

00:30:40.860 --> 00:30:44.640
to do some work with, and then
later on, asynchronously, you

00:30:44.640 --> 00:30:47.860
reply with the result.

00:30:47.860 --> 00:30:52.020
So that requires a bit of a
work queue on the C++ side.

00:30:52.020 --> 00:30:54.380
I have some code on
GitHub that makes

00:30:54.380 --> 00:30:57.970
this very straightforward to do.

00:30:57.970 --> 00:31:00.810
And then the final step is that
you write kind of the mirror

00:31:00.810 --> 00:31:05.430
of the C++ message passing
API in JavaScript or Dart,

00:31:05.430 --> 00:31:10.060
so that you have an API that's
available to your script that

00:31:10.060 --> 00:31:13.145
says, OK, go and do some
work over in native land.

00:31:13.145 --> 00:31:14.770
And then when that
native land is done,

00:31:14.770 --> 00:31:17.770
call this callback, just
like an onClick or something

00:31:17.770 --> 00:31:22.060
like that, when the
work is finished.

00:31:22.060 --> 00:31:24.840
So I ported the
Bullet physics engine

00:31:24.840 --> 00:31:27.070
to Native Client
Acceleration Modules,

00:31:27.070 --> 00:31:29.501
and it took about a day.

00:31:29.501 --> 00:31:30.850
It was very straightforward.

00:31:34.790 --> 00:31:37.110
So in terms of
consumption of-- let's say

00:31:37.110 --> 00:31:39.900
you went and downloaded my
Bullet physics acceleration

00:31:39.900 --> 00:31:40.950
module.

00:31:40.950 --> 00:31:42.890
You really just have
to add a script tag

00:31:42.890 --> 00:31:46.739
to get the interface to it
and then add the embed tag.

00:31:46.739 --> 00:31:49.030
The cool thing about Native
Client Acceleration Modules

00:31:49.030 --> 00:31:51.600
is that they actually don't
take any space up for rendering.

00:31:51.600 --> 00:31:52.430
They're invisible.

00:31:52.430 --> 00:31:54.740
They're just kind of like
this background workhorse

00:31:54.740 --> 00:31:58.970
that you can call into and have
it do some work and come out.

00:31:58.970 --> 00:32:02.910
So it's really as simple as
using something like jQuery.

00:32:02.910 --> 00:32:06.230
So some example
applications for it

00:32:06.230 --> 00:32:08.490
would be like Bullet
physics, simulating hundreds

00:32:08.490 --> 00:32:12.810
of rigid bodies, blazing
fast zip decompression,

00:32:12.810 --> 00:32:15.820
video encoding and
processing, image processing,

00:32:15.820 --> 00:32:19.790
any-- these are examples of
algorithms where you really

00:32:19.790 --> 00:32:23.560
need computational power
that is not always available

00:32:23.560 --> 00:32:24.770
in JavaScript.

00:32:24.770 --> 00:32:26.420
But by using an
acceleration module,

00:32:26.420 --> 00:32:28.716
you can leverage
native performance

00:32:28.716 --> 00:32:29.715
where it really matters.

00:32:33.200 --> 00:32:36.380
So this is a graph
of how many times

00:32:36.380 --> 00:32:39.150
can you send a message to a
Native Client Acceleration

00:32:39.150 --> 00:32:43.510
Module and get a reply
within five seconds.

00:32:43.510 --> 00:32:45.610
The x-axis is how
large of a message

00:32:45.610 --> 00:32:48.320
it is, so starting at 16
bytes and going all the way up

00:32:48.320 --> 00:32:51.230
to 16 megs.

00:32:51.230 --> 00:32:56.870
So you can see that the drop off
starts around 4K message size.

00:32:56.870 --> 00:32:59.380
And 4K is actually
a reasonable amount

00:32:59.380 --> 00:33:02.360
of data to transmit
across the wire.

00:33:02.360 --> 00:33:04.000
And it continues to go down.

00:33:06.770 --> 00:33:11.040
But what's really interesting is
that even at 256K per message,

00:33:11.040 --> 00:33:13.640
the round trip is
only a millisecond.

00:33:13.640 --> 00:33:16.080
And this is asynchronous,
so your JavaScript

00:33:16.080 --> 00:33:20.010
is executing code as this
millisecond ticks across.

00:33:20.010 --> 00:33:21.530
So at the beginning
of your frame,

00:33:21.530 --> 00:33:23.880
you can go and send
a few messages.

00:33:23.880 --> 00:33:26.430
The Native Client Acceleration
Module can do the computation.

00:33:26.430 --> 00:33:27.804
And then you'll
get that callback

00:33:27.804 --> 00:33:30.720
later on before
your frame is done.

00:33:30.720 --> 00:33:34.930
So in terms of throughput,
the opposite shape the graph.

00:33:34.930 --> 00:33:36.480
As the message size
gets bigger, you

00:33:36.480 --> 00:33:38.780
get more data through this pipe.

00:33:38.780 --> 00:33:43.800
And it peaks around 420
megabytes per second

00:33:43.800 --> 00:33:47.670
if you're sending about a
one megabyte frame of data.

00:33:50.280 --> 00:33:53.290
So Native Client
Acceleration Modules

00:33:53.290 --> 00:33:56.310
also allow for multiple
acceleration modules

00:33:56.310 --> 00:33:57.875
to be used on the same page.

00:33:57.875 --> 00:34:00.030
You're not just limited to one.

00:34:00.030 --> 00:34:01.190
You could have many.

00:34:01.190 --> 00:34:02.680
I have an example
application where

00:34:02.680 --> 00:34:05.890
I have a compressor
and a decompressor.

00:34:05.890 --> 00:34:07.821
So I can send something
to the compressor,

00:34:07.821 --> 00:34:09.570
get the compressed
data back, send it over

00:34:09.570 --> 00:34:11.710
to the decompressor, and
get the same data back

00:34:11.710 --> 00:34:12.626
that I had originally.

00:34:12.626 --> 00:34:15.290
And this is all
within the same page.

00:34:15.290 --> 00:34:17.780
It offers really low
latency and high throughput.

00:34:17.780 --> 00:34:20.540
To give you some context
to these numbers,

00:34:20.540 --> 00:34:24.570
let's say you wanted to stream
1080p video at 60 hertz.

00:34:24.570 --> 00:34:27.620
It's only 240
megabytes per second,

00:34:27.620 --> 00:34:30.699
which is 60% of the bandwidth
that you have available.

00:34:30.699 --> 00:34:34.610
And if you were to do this,
the latency on these requests

00:34:34.610 --> 00:34:36.460
is only eight milliseconds.

00:34:36.460 --> 00:34:39.719
So it's very practical.

00:34:39.719 --> 00:34:41.580
The throughput and
the latency are well

00:34:41.580 --> 00:34:44.560
within acceptable means.

00:34:44.560 --> 00:34:50.340
And also, think about physically
simulating 1,000 rigid bodies.

00:34:50.340 --> 00:34:53.940
You only need seven
megs of data per frame.

00:34:53.940 --> 00:34:56.310
And that's only 1.7%
of the bandwidth.

00:34:56.310 --> 00:35:00.520
So you could be doing
video streaming and physics

00:35:00.520 --> 00:35:03.400
simulation and still have lots
of bandwidth available to you,

00:35:03.400 --> 00:35:05.360
and the latency would
be very reasonable.

00:35:10.250 --> 00:35:13.900
So I want to pause
right here and actually

00:35:13.900 --> 00:35:19.140
show you a Native Client
Acceleration Module in action.

00:35:22.990 --> 00:35:30.560
So here's a stack of
Jenga blocks 20 high.

00:35:30.560 --> 00:35:36.442
And I can pick up a block
and interact with it.

00:35:36.442 --> 00:35:38.940
Whoosh.

00:35:38.940 --> 00:35:42.920
What you're seeing here is
what the simulation time is.

00:35:42.920 --> 00:35:47.700
So right now, the simulation
for this entire physics scene

00:35:47.700 --> 00:35:50.015
is a couple microseconds.

00:35:50.015 --> 00:35:52.570
It's super fast because
it's running in native C.

00:35:52.570 --> 00:35:54.340
But the graphics
that you're seeing,

00:35:54.340 --> 00:35:56.690
I'm just using three.js.

00:35:56.690 --> 00:35:58.465
The Native Client
Acceleration Module

00:35:58.465 --> 00:36:00.540
is doing all of the
work, and it's just

00:36:00.540 --> 00:36:04.400
sending the transformation
matrices back across the wire.

00:36:04.400 --> 00:36:08.056
So we could do 400 random
cubes, 400 random cylinders,

00:36:08.056 --> 00:36:09.710
just some random shapes.

00:36:09.710 --> 00:36:10.750
It doesn't matter.

00:36:10.750 --> 00:36:14.020
It's extremely fast because
it's actually running C code

00:36:14.020 --> 00:36:16.600
and just transmitting the
transformation matrices back

00:36:16.600 --> 00:36:17.250
every frame.

00:36:31.220 --> 00:36:34.700
So let's look at the performance
of the NaCl Acceleration

00:36:34.700 --> 00:36:39.300
Module versus machine translated
JavaScript, like [INAUDIBLE],

00:36:39.300 --> 00:36:41.850
asm.js, something like that.

00:36:41.850 --> 00:36:45.850
So what we're seeing
here, the y-axis

00:36:45.850 --> 00:36:48.490
is the microseconds
to compute the frame.

00:36:48.490 --> 00:36:52.950
The blue line is the NaCl
acceleration module time.

00:36:52.950 --> 00:36:56.860
And the red line is the
JavaScript execution time.

00:36:56.860 --> 00:37:01.630
You might be wondering,
where is the blue line?

00:37:01.630 --> 00:37:05.290
It's that fast that it's
so low on that graph.

00:37:05.290 --> 00:37:08.150
So let's zoom in.

00:37:08.150 --> 00:37:11.010
Well, actually, before we do
that, it's important to note,

00:37:11.010 --> 00:37:14.220
look at how spiky the
JavaScript execution is.

00:37:14.220 --> 00:37:16.434
It's really all over the place.

00:37:16.434 --> 00:37:18.100
It's very important
with a game that you

00:37:18.100 --> 00:37:19.786
have consistent
performance every frame.

00:37:19.786 --> 00:37:20.910
You want it to be the same.

00:37:20.910 --> 00:37:22.540
You want to see a
flat line there.

00:37:22.540 --> 00:37:24.480
But you have these
bizarre spikes.

00:37:24.480 --> 00:37:27.790
Probably deoptimizations
have occurred,

00:37:27.790 --> 00:37:29.530
and then the engine
recovers, and then

00:37:29.530 --> 00:37:33.210
another deoptimization occurs.

00:37:33.210 --> 00:37:36.940
So if we zoom in, look at
how smooth and flat and also

00:37:36.940 --> 00:37:39.900
how low the NaCl
acceleration module

00:37:39.900 --> 00:37:42.285
computation time is
versus JavaScript.

00:37:45.150 --> 00:37:46.950
Now what about compressing?

00:37:46.950 --> 00:37:49.320
Let's say you wanted
to use the gzip

00:37:49.320 --> 00:37:52.150
algorithm to do
some compression.

00:37:52.150 --> 00:37:55.800
Again, red is
JavaScript, and blue

00:37:55.800 --> 00:37:58.360
is NaCl Acceleration Module.

00:37:58.360 --> 00:38:01.560
You can see the performance
difference is huge.

00:38:01.560 --> 00:38:05.270
And again, the
performance of NaCl code

00:38:05.270 --> 00:38:10.820
is very stable, which
is always attractive.

00:38:10.820 --> 00:38:14.070
Look at how bumpy that is.

00:38:14.070 --> 00:38:18.610
Similarly, with decompression
timing, fewer data points here,

00:38:18.610 --> 00:38:21.760
but the same story holds.

00:38:21.760 --> 00:38:25.240
Really inconsistent JavaScript
execution performance,

00:38:25.240 --> 00:38:27.540
very stable native performance.

00:38:27.540 --> 00:38:29.650
And you can pass the
data back and forth

00:38:29.650 --> 00:38:32.260
between these two
worlds asynchronously

00:38:32.260 --> 00:38:36.790
without interrupting your
JavaScript execution.

00:38:36.790 --> 00:38:38.580
So NaCl Acceleration
Modules are at least

00:38:38.580 --> 00:38:40.790
an order of magnitude
faster than machine

00:38:40.790 --> 00:38:43.360
translated JavaScript
code, and they

00:38:43.360 --> 00:38:44.750
offer consistent performance.

00:38:44.750 --> 00:38:50.750
These are both very attractive
qualities to game developers.

00:38:50.750 --> 00:38:53.370
So you might have some
concerns, like NaCl

00:38:53.370 --> 00:38:55.020
is only available
in Chrome, right?

00:38:55.020 --> 00:38:58.330
So if you want to make an
application built around this,

00:38:58.330 --> 00:39:02.040
well, maybe you're
restricted to just Chrome.

00:39:02.040 --> 00:39:05.440
But I know I've been
kind of demonstrating

00:39:05.440 --> 00:39:07.640
how much better
Native Client performs

00:39:07.640 --> 00:39:09.210
than machine
translated JavaScript.

00:39:09.210 --> 00:39:12.630
But at least you can have a
polyfill where your application

00:39:12.630 --> 00:39:18.290
will run in browsers that
don't support Native Client.

00:39:18.290 --> 00:39:20.600
Not at the great performance
that you've seen,

00:39:20.600 --> 00:39:23.130
but they still run.

00:39:23.130 --> 00:39:25.900
Also, applications that
require many back and forth

00:39:25.900 --> 00:39:28.700
messages with a lot of
chatter back and forth,

00:39:28.700 --> 00:39:31.010
like, NaCl can't make
progress without hearing

00:39:31.010 --> 00:39:34.100
back from JavaScript
and vice versa,

00:39:34.100 --> 00:39:36.612
this is not good for Native
Client Acceleration Modules.

00:39:36.612 --> 00:39:38.070
You really want
something where you

00:39:38.070 --> 00:39:41.280
can pass some work across
and then continue on.

00:39:41.280 --> 00:39:43.170
But if you need to
kind of synchronously

00:39:43.170 --> 00:39:45.140
be chattering back
and forth, you're

00:39:45.140 --> 00:39:47.830
not going to see as large
of a performance win.

00:39:47.830 --> 00:39:49.480
So it's really ideal
for applications

00:39:49.480 --> 00:39:54.710
that are heavily
HTML5-based, with kind

00:39:54.710 --> 00:39:57.520
of like 10% native
code execution.

00:40:01.072 --> 00:40:02.530
NaCl Acceleration
Modules are going

00:40:02.530 --> 00:40:05.060
to allow us to bring new types
of applications to the web.

00:40:05.060 --> 00:40:07.910
It's going to allow us
to keep the flexibility

00:40:07.910 --> 00:40:11.130
and the productivity of working
in a language like JavaScript,

00:40:11.130 --> 00:40:16.520
but keep great performance
that you get from native code

00:40:16.520 --> 00:40:19.490
where you really need it.

00:40:19.490 --> 00:40:22.240
And the usage, if you
are a web developer that

00:40:22.240 --> 00:40:23.939
is consuming an
acceleration module,

00:40:23.939 --> 00:40:25.105
it's really straightforward.

00:40:25.105 --> 00:40:28.190
You just include a script
tag and an embed tag,

00:40:28.190 --> 00:40:29.030
and you're done.

00:40:29.030 --> 00:40:31.450
You make the calls, and
it feels like JavaScript.

00:40:36.850 --> 00:40:40.310
So this morning, Eric
Bidelman talked to you

00:40:40.310 --> 00:40:43.220
all about Polymer, which
is really exciting.

00:40:43.220 --> 00:40:45.380
I think Polymer is one of
the most exciting pieces

00:40:45.380 --> 00:40:46.530
of technology on the web.

00:40:46.530 --> 00:40:48.510
AUDIENCE: Woo!

00:40:48.510 --> 00:40:52.380
JOHN MCCUTCHAN:
That's right, woo-er.

00:40:52.380 --> 00:40:54.630
So I've been playing
with the idea of,

00:40:54.630 --> 00:40:56.820
why not make an entire
3D graphics engine

00:40:56.820 --> 00:40:59.040
built out of custom elements?

00:40:59.040 --> 00:41:02.870
Why do we have to
write WebGL JavaScript

00:41:02.870 --> 00:41:05.480
code to create 3D scenes?

00:41:05.480 --> 00:41:07.620
Why can't we just
create a new set

00:41:07.620 --> 00:41:13.039
of elements that express
a 3D scene in HTML?

00:41:13.039 --> 00:41:14.580
And I just want to
give a quick demo.

00:41:14.580 --> 00:41:18.200
It's very early, but
it's kind of cool.

00:41:18.200 --> 00:41:20.190
So this is like a
rough sketch of kind

00:41:20.190 --> 00:41:21.430
of what it would look like.

00:41:21.430 --> 00:41:25.010
Like you would have game-app,
game-player, game-stage,

00:41:25.010 --> 00:41:26.481
game-static-mesh.

00:41:26.481 --> 00:41:28.230
All of these things
are kind of expressing

00:41:28.230 --> 00:41:30.140
these really high
level concepts that

00:41:30.140 --> 00:41:35.070
are meaningful to your game,
but it's just in pure HTML.

00:41:35.070 --> 00:41:41.690
So let me switch over
to the Dart Editor

00:41:41.690 --> 00:41:47.980
and show you a quick demo here.

00:41:47.980 --> 00:41:49.480
This is alpha level software.

00:41:49.480 --> 00:41:53.040
So please be forgiving
if any glitches occur.

00:42:00.300 --> 00:42:03.210
So this is a really kind
of simple scene here.

00:42:03.210 --> 00:42:05.850
We have this green
arc is spinning.

00:42:05.850 --> 00:42:09.050
We've got this plane
rotating and the ground.

00:42:09.050 --> 00:42:12.630
This is expressed
entirely in HTML.

00:42:12.630 --> 00:42:14.960
The only bit of code, and
I'll show you in a moment,

00:42:14.960 --> 00:42:17.320
is just to animate
the properties.

00:42:17.320 --> 00:42:20.190
But let me show you what you
could do in a world like this.

00:42:25.910 --> 00:42:29.130
So if we were to open
up Chrome DevTools

00:42:29.130 --> 00:42:32.730
and go over to the Elements
pane, we can expand,

00:42:32.730 --> 00:42:36.210
and we can say, OK, so
here's our scene tag.

00:42:36.210 --> 00:42:39.180
And then we have an
axis-aligned bounding box.

00:42:39.180 --> 00:42:43.310
There's that arc
with the green color,

00:42:43.310 --> 00:42:46.630
and there's its start and
end angle as it's rotating.

00:42:46.630 --> 00:42:48.510
It's updating right
in the Elements pane.

00:42:51.180 --> 00:42:53.910
But let's just go
down here and say,

00:42:53.910 --> 00:42:58.610
what if we just edited
the HTML and did this?

00:43:18.261 --> 00:43:18.760
There.

00:43:18.760 --> 00:43:23.160
We just added a yellow
3D sphere to the scene

00:43:23.160 --> 00:43:26.140
just by editing HTML.

00:43:26.140 --> 00:43:33.780
We can go in and maybe
change the radius to be five.

00:43:36.738 --> 00:43:39.080
And there, it's shrunk.

00:43:39.080 --> 00:43:42.610
So imagine where you could
create a 3D graphics world

00:43:42.610 --> 00:43:46.440
expressed entirely in
HTML with custom elements.

00:43:46.440 --> 00:43:50.720
This to me is an example
of how powerful Polymer is.

00:43:50.720 --> 00:43:52.610
A lot of the way people
talk about Polymer

00:43:52.610 --> 00:43:56.520
right now is kind of
encapsulating a bunch of divs.

00:43:56.520 --> 00:43:57.990
But you can actually
take Polymer

00:43:57.990 --> 00:44:00.810
to a totally different
level and use

00:44:00.810 --> 00:44:05.410
it to create really complicated
applications with tags

00:44:05.410 --> 00:44:11.400
that kind of are meaningless
in a strictly HTML5 world.

00:44:11.400 --> 00:44:14.250
As a final little
demo here, I'll

00:44:14.250 --> 00:44:23.860
show you a simple
Minecraft-like world.

00:44:23.860 --> 00:44:26.940
Again, it's all just
HTML at this point.

00:44:32.890 --> 00:44:37.770
So the tags here are just
transform tags and draw

00:44:37.770 --> 00:44:40.960
this mesh and use this texture.

00:44:40.960 --> 00:44:43.830
You can write a
WebGL application

00:44:43.830 --> 00:44:45.390
without writing any code.

00:44:45.390 --> 00:44:48.550
You just have a texture tag,
and you give it a source,

00:44:48.550 --> 00:44:50.340
just like an image
tag, and it's going

00:44:50.340 --> 00:44:53.120
to go and fetch that and
upload it into a WebGL texture

00:44:53.120 --> 00:44:54.890
for you.

00:44:54.890 --> 00:45:05.120
So that's an interesting
use of Polymer I think.

00:45:05.120 --> 00:45:11.090
So hopefully, people
will start experimenting

00:45:11.090 --> 00:45:13.180
with Polymer in this way.

00:45:13.180 --> 00:45:15.360
And I hope to have
more impressive demos

00:45:15.360 --> 00:45:16.690
as things mature.

00:45:21.280 --> 00:45:26.120
So I left PlayStation and I
joined Google because I really

00:45:26.120 --> 00:45:28.400
believe strongly that
the web and HTML5

00:45:28.400 --> 00:45:31.870
games are the future of gaming.

00:45:31.870 --> 00:45:34.450
The technology that's
available inside browsers

00:45:34.450 --> 00:45:35.970
is so powerful today.

00:45:35.970 --> 00:45:38.430
It's kind of
amazing that we take

00:45:38.430 --> 00:45:40.820
for granted that
within a web browser,

00:45:40.820 --> 00:45:43.110
you have the same
capabilities that you have

00:45:43.110 --> 00:45:46.590
within a PlayStation
3 or an Xbox 360.

00:45:46.590 --> 00:45:49.480
To me, that's really
exciting because the web

00:45:49.480 --> 00:45:52.230
is so dynamic and flexible, and
everything happens so quickly

00:45:52.230 --> 00:45:54.850
there, and everyone
has a web browser.

00:45:54.850 --> 00:45:58.940
So I personally believe
that HTML5 games are

00:45:58.940 --> 00:46:01.140
the future of gaming, and
I hope that you guys all

00:46:01.140 --> 00:46:05.930
create really awesome
games going forward.

00:46:05.930 --> 00:46:06.990
Thank you.

00:46:06.990 --> 00:46:22.887
[APPLAUSE]

