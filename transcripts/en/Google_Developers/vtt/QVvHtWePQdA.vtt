WEBVTT
Kind: captions
Language: en

00:00:06.660 --> 00:00:10.880
DON OLMSTEAD: So,
as Tony mentioned,

00:00:10.880 --> 00:00:12.682
my name is Don Olmstead.

00:00:12.682 --> 00:00:15.540
I work over at Sony
Network Entertainment,

00:00:15.540 --> 00:00:20.680
and I wrote the WebGL
layer for the PS4.

00:00:20.680 --> 00:00:24.590
So, obviously, thank
you all for coming.

00:00:24.590 --> 00:00:27.890
And really, it's been an amazing
response with everything.

00:00:27.890 --> 00:00:30.480
And definitely
excited to be here.

00:00:30.480 --> 00:00:34.330
So Tony gave sort of the grand
overview of what is WebGL.

00:00:34.330 --> 00:00:35.990
The next speakers
are probably going

00:00:35.990 --> 00:00:39.170
to give a bunch of
fun, cool demos.

00:00:39.170 --> 00:00:43.480
And I'm here to blind you
with computer science.

00:00:43.480 --> 00:00:48.960
So, I'm definitely not going
to give you any fun whiz

00:00:48.960 --> 00:00:50.580
bang demos or
anything like that,

00:00:50.580 --> 00:00:53.360
but afterwards,
you're going to have

00:00:53.360 --> 00:00:56.210
a much better understanding
on how WebGL actually

00:00:56.210 --> 00:00:58.020
works under the hood.

00:00:58.020 --> 00:01:01.210
And the reality
is that, yeah, you

00:01:01.210 --> 00:01:03.880
might be using a
framework like three

00:01:03.880 --> 00:01:06.680
or any other of the
many frameworks,

00:01:06.680 --> 00:01:09.010
but there's a good chance
that if you're really,

00:01:09.010 --> 00:01:11.170
really pushing the
hardware, eventually

00:01:11.170 --> 00:01:12.550
you're going to outgrow it.

00:01:12.550 --> 00:01:16.580
And then you're going to need
to come down to my level here.

00:01:16.580 --> 00:01:22.440
So, I wanted to
start off with what

00:01:22.440 --> 00:01:27.130
I did for the PS4 and some
of the choices we made here.

00:01:27.130 --> 00:01:30.030
So, let's talk about the PS4.

00:01:30.030 --> 00:01:33.720
We released in November,
the same day this meet-up

00:01:33.720 --> 00:01:35.670
was announced.

00:01:35.670 --> 00:01:41.550
And actually we sold a
million units in a single day.

00:01:41.550 --> 00:01:47.930
And sales continued to be pretty
good, 4.2 million in 2013.

00:01:47.930 --> 00:01:52.030
And obviously, the best
part is that every time you

00:01:52.030 --> 00:01:56.260
log in you are
running WebGL code.

00:01:56.260 --> 00:01:59.330
So, why did we end
up using WebGL?

00:01:59.330 --> 00:02:01.410
Well, to be honest, it
was really more or less

00:02:01.410 --> 00:02:04.550
a pragmatic decision.

00:02:04.550 --> 00:02:06.490
So here I'm going
to talk a little bit

00:02:06.490 --> 00:02:09.259
about the architecture
of the PlayStation store,

00:02:09.259 --> 00:02:12.280
which is what our team works on.

00:02:12.280 --> 00:02:15.130
So, we really
wanted the same code

00:02:15.130 --> 00:02:17.370
to run on multiple platforms.

00:02:17.370 --> 00:02:20.290
And obviously, the most
important avenue for this

00:02:20.290 --> 00:02:22.500
is PlayStation hardware itself.

00:02:22.500 --> 00:02:27.080
So this is the PS3 and the PS4.

00:02:27.080 --> 00:02:32.750
But, we also wanted to support
people working in the browser.

00:02:32.750 --> 00:02:35.250
And this is just to
make devs' lives easier,

00:02:35.250 --> 00:02:37.780
in case they were away
from their hardware,

00:02:37.780 --> 00:02:42.550
and really, that's where
the WebGL usage started.

00:02:42.550 --> 00:02:45.090
So, actually, most of
our devs use Chrome,

00:02:45.090 --> 00:02:46.710
and if you went to
our booth outside,

00:02:46.710 --> 00:02:48.550
you could actually
see the PlayStation

00:02:48.550 --> 00:02:51.370
store running in Chrome.

00:02:51.370 --> 00:02:58.080
And that was more
or less what we had.

00:02:58.080 --> 00:03:00.150
So in this case,
I wanted to start

00:03:00.150 --> 00:03:03.390
by giving more of an overview
of what it is we actually have.

00:03:03.390 --> 00:03:06.360
What does our software
stack look like.

00:03:06.360 --> 00:03:11.750
So, in the case of the PS3, the
bottom is actually PhyreEngine.

00:03:11.750 --> 00:03:14.360
And PhyreEnginer
is a game engine

00:03:14.360 --> 00:03:17.760
provided by Sony
for all licensees.

00:03:17.760 --> 00:03:21.540
And, actually, it
powered Journey.

00:03:21.540 --> 00:03:23.840
So same set of code there.

00:03:23.840 --> 00:03:28.610
On top of that, we had an API
layer we called TriLithium.

00:03:28.610 --> 00:03:33.110
So, this is actually
a JavaScript API

00:03:33.110 --> 00:03:35.040
for drawing a 2D scene.

00:03:35.040 --> 00:03:36.460
I was not involved
in the naming.

00:03:40.960 --> 00:03:45.500
So, actually, this is all
bound to a JavaScript VM,

00:03:45.500 --> 00:03:51.840
and it allowed our programmers
to create this UI layer, which

00:03:51.840 --> 00:03:55.280
is more or less a home-grown,
immediate-mode GUI, made

00:03:55.280 --> 00:03:58.020
to look DOM-ish.

00:03:58.020 --> 00:04:03.920
And on top of that, our devs ran
and made the PlayStation store.

00:04:03.920 --> 00:04:06.910
So let's talk about the PS4.

00:04:06.910 --> 00:04:09.220
So obviously, we had
a large codebase,

00:04:09.220 --> 00:04:11.330
we needed compatibility
with the PS3,

00:04:11.330 --> 00:04:14.930
we also wanted
more web features,

00:04:14.930 --> 00:04:18.430
and we didn't have time to
rewrite the whole thing.

00:04:18.430 --> 00:04:23.540
So we actually have a
working port of WebKit

00:04:23.540 --> 00:04:25.610
that powers our browser.

00:04:25.610 --> 00:04:28.610
This is more or less
where I normally work in,

00:04:28.610 --> 00:04:30.720
on the rendering side there.

00:04:30.720 --> 00:04:33.490
And to actually do the
port, what we needed to do

00:04:33.490 --> 00:04:37.670
was recreate that TriLithium
layer, but in WebGL.

00:04:37.670 --> 00:04:40.270
So that meant for
us our UI framework

00:04:40.270 --> 00:04:44.620
didn't have to change,
and neither did the store.

00:04:44.620 --> 00:04:47.830
So we had a problem.

00:04:47.830 --> 00:04:52.310
We reached a point where launch
was looming in front of us,

00:04:52.310 --> 00:04:55.710
and basically, the
performance was not there.

00:04:55.710 --> 00:04:59.920
And really, the user experience
was suffering because of it.

00:04:59.920 --> 00:05:03.380
So we started
investigating the issue,

00:05:03.380 --> 00:05:07.660
and my assertion was
it's JavaScript's fault.

00:05:07.660 --> 00:05:12.720
So, for me, the
avenue to go would

00:05:12.720 --> 00:05:17.140
be to attract attack that
bottom TriLithium layer

00:05:17.140 --> 00:05:20.530
and fix it, essentially.

00:05:20.530 --> 00:05:22.935
So, I started
optimizing this layer,

00:05:22.935 --> 00:05:25.740
but I really wasn't getting
the performance gains

00:05:25.740 --> 00:05:30.000
I actually wanted, and what I
thought was actually possible.

00:05:30.000 --> 00:05:32.090
So, we're really
close to launch,

00:05:32.090 --> 00:05:36.060
performance isn't there,
so what do you do?

00:05:36.060 --> 00:05:38.580
Well as a seasoned
developer knows,

00:05:38.580 --> 00:05:43.210
you burn everything
to the ground.

00:05:43.210 --> 00:05:47.290
And in its place, create
something awesome.

00:05:47.290 --> 00:05:51.390
So, really I only recommend
that as a last resort,

00:05:51.390 --> 00:05:53.440
and I more or less
went down this route

00:05:53.440 --> 00:05:57.620
because I was already touching
a good amount of the code,

00:05:57.620 --> 00:06:02.950
and I really wanted to open
up all the optimizations

00:06:02.950 --> 00:06:05.420
that really I'm here
to talk to you about.

00:06:05.420 --> 00:06:08.680
So, with the intro, let's begin.

00:06:08.680 --> 00:06:10.950
So what do you need to know?

00:06:10.950 --> 00:06:13.769
Well, first off,
if you're actually

00:06:13.769 --> 00:06:15.810
trying to figure out what's
going with your WebGL

00:06:15.810 --> 00:06:19.890
application, you
want to profile.

00:06:19.890 --> 00:06:22.460
So you need to
profile and figure out

00:06:22.460 --> 00:06:29.000
exactly where your app
is spending its time.

00:06:29.000 --> 00:06:32.250
And if rendering turns
out to be a problem,

00:06:32.250 --> 00:06:35.100
and you're using
WebGL, you really

00:06:35.100 --> 00:06:37.740
need to understand two things.

00:06:37.740 --> 00:06:42.570
So that's how does WebGL
slot into the browser?

00:06:42.570 --> 00:06:46.560
You need to know how WebGL
works so you can optimize

00:06:46.560 --> 00:06:49.870
your interaction with the API.

00:06:49.870 --> 00:06:53.300
So then, you walk
further up the stack.

00:06:53.300 --> 00:06:57.850
You need to start thinking about
how you're submitting geometry.

00:06:57.850 --> 00:07:00.760
And of course,
you need to ensure

00:07:00.760 --> 00:07:05.840
that work is being
done completely

00:07:05.840 --> 00:07:08.780
in the animation loop itself.

00:07:08.780 --> 00:07:14.640
All right, so first off, let's
talk about animation frame.

00:07:14.640 --> 00:07:17.880
So you basically have
16.6 milliseconds

00:07:17.880 --> 00:07:19.240
to do all your work.

00:07:19.240 --> 00:07:25.350
And honestly, it's safer if you
finish quite a bit before then.

00:07:25.350 --> 00:07:28.740
So, if you finish in
the allotted time,

00:07:28.740 --> 00:07:32.240
you'll get, of course,
the silky smooth 60 FPS,

00:07:32.240 --> 00:07:35.770
the holy grail of all
graphics programming.

00:07:35.770 --> 00:07:39.740
And if you don't do it,
you're going to drop a frame.

00:07:39.740 --> 00:07:43.120
And if you do it enough,
your user experience

00:07:43.120 --> 00:07:44.790
will definitely suffer.

00:07:44.790 --> 00:07:47.520
The animations themselves
will look jerky,

00:07:47.520 --> 00:07:49.180
the controls will seem laggy.

00:07:49.180 --> 00:07:50.350
It's not good.

00:07:50.350 --> 00:07:55.610
And this was more or less the
state we were in beforehand.

00:07:55.610 --> 00:07:59.240
So the other thing to
remember is, on top of that,

00:07:59.240 --> 00:08:01.790
the browser is doing
plenty of other things

00:08:01.790 --> 00:08:04.900
that can further
limit your frame time.

00:08:04.900 --> 00:08:09.360
So, the big one of course, is
the waste monster, also known

00:08:09.360 --> 00:08:12.120
as the garbage collector.

00:08:12.120 --> 00:08:15.610
And you have to remember,
it can trigger at any time

00:08:15.610 --> 00:08:17.900
and take as much
time as it wants.

00:08:17.900 --> 00:08:20.120
It doesn't care.

00:08:20.120 --> 00:08:23.800
So, you also need to know that
other browser events are going

00:08:23.800 --> 00:08:26.310
to happen outside of
the animation frame.

00:08:26.310 --> 00:08:29.520
And this is something we're
going to circle back to later

00:08:29.520 --> 00:08:30.020
on.

00:08:32.809 --> 00:08:34.880
So when you're
profiling, we need

00:08:34.880 --> 00:08:37.610
to look at what
happens during a frame.

00:08:37.610 --> 00:08:40.110
And we use a profiler.

00:08:40.110 --> 00:08:44.260
There are actually two types
available to the web dev,

00:08:44.260 --> 00:08:45.570
in Chrome specifically.

00:08:45.570 --> 00:08:49.970
So you have that
sampling profiler,

00:08:49.970 --> 00:08:53.490
and this will essentially
take little snapshots

00:08:53.490 --> 00:08:56.540
to try and determine
where the time is

00:08:56.540 --> 00:08:59.420
being spent within your app.

00:08:59.420 --> 00:09:03.230
And that's essentially what you
find in the Chrome Developer

00:09:03.230 --> 00:09:05.460
Tools.

00:09:05.460 --> 00:09:08.370
So, something that's
a bit more advanced

00:09:08.370 --> 00:09:11.130
is a structural profiler.

00:09:11.130 --> 00:09:14.090
So in this case, you're
actually inserting code

00:09:14.090 --> 00:09:18.970
into your code to figure out
where your time's being spent.

00:09:18.970 --> 00:09:22.260
And this is something
you'll find if you use

00:09:22.260 --> 00:09:26.330
chrome://tracing, and you'll
basically litter your code with

00:09:26.330 --> 00:09:29.290
console time, console time end.

00:09:29.290 --> 00:09:31.620
But there's an even
better solution,

00:09:31.620 --> 00:09:34.020
which is the Web
Tracing Framework.

00:09:34.020 --> 00:09:37.590
Unfortunately, the Web Tracing
Framework came out a little bit

00:09:37.590 --> 00:09:40.600
after when I would
have really liked it,

00:09:40.600 --> 00:09:43.610
but it's a solution from
Google, and obviously,

00:09:43.610 --> 00:09:46.195
one of the programmers is
a smart ass because WTF.

00:09:50.850 --> 00:09:55.350
So you have your structural
profiler, what do you do?

00:09:55.350 --> 00:09:56.860
Where do you begin?

00:09:56.860 --> 00:10:01.030
So, really, you want
to place markers

00:10:01.030 --> 00:10:03.760
at various points of
interest in your code.

00:10:03.760 --> 00:10:06.820
For graphics application,
typically, there's an update,

00:10:06.820 --> 00:10:07.969
and then there's a render.

00:10:07.969 --> 00:10:09.510
So these are the
sort of things where

00:10:09.510 --> 00:10:12.580
you want to place
the markers, and then

00:10:12.580 --> 00:10:16.440
continue deep diving
further and further.

00:10:16.440 --> 00:10:19.040
And from there, you'll
be able to figure out

00:10:19.040 --> 00:10:20.470
what exactly is going on.

00:10:23.230 --> 00:10:26.140
So, here's a little slide
with what the Web Tracing

00:10:26.140 --> 00:10:28.850
Framework will give you.

00:10:28.850 --> 00:10:31.680
If you look here, obviously
really hard to tell,

00:10:31.680 --> 00:10:34.435
but over on this side is the
update, over on this side

00:10:34.435 --> 00:10:36.860
is the render.

00:10:36.860 --> 00:10:39.040
So, this particular
trace, it was

00:10:39.040 --> 00:10:42.620
from an example game
on their home page.

00:10:42.620 --> 00:10:46.490
And you can see how this
is a lot of information.

00:10:46.490 --> 00:10:51.020
And if you're familiar
with chrome://tracing,

00:10:51.020 --> 00:10:54.400
you'll see it's presented
in a much nicer way.

00:10:54.400 --> 00:10:57.660
With chrome://tracing,
you get everything,

00:10:57.660 --> 00:11:01.670
which is a bit harder
to drill down into.

00:11:01.670 --> 00:11:04.300
So I definitely recommend
playing with it on your own

00:11:04.300 --> 00:11:07.070
and it also does some
other fun things,

00:11:07.070 --> 00:11:09.530
like the garbage collection,
so it'll actually tell you

00:11:09.530 --> 00:11:12.360
where the garbage
collection's happening.

00:11:12.360 --> 00:11:14.420
So, let's say we
ran our application,

00:11:14.420 --> 00:11:17.270
and we are seeing a good amount
of time in the render portion.

00:11:17.270 --> 00:11:20.440
So what do we do?

00:11:20.440 --> 00:11:23.940
It's really important to know
what's going on under the hood.

00:11:23.940 --> 00:11:26.180
So in this case, I'm
going to talk about Blink.

00:11:26.180 --> 00:11:28.420
And I'm going to talk
about Blink because WebKit

00:11:28.420 --> 00:11:32.260
is way more
convoluted than Blink.

00:11:32.260 --> 00:11:34.940
So in our app, we're going
to make a WebGL call.

00:11:34.940 --> 00:11:38.062
So we're in our JavaScript
code, and from there, the call

00:11:38.062 --> 00:11:39.645
goes into the
V8WebGLRenderingContext.

00:11:42.350 --> 00:11:45.480
So, basically,
any of the browser

00:11:45.480 --> 00:11:50.420
APIs that end up getting
exposed to the application,

00:11:50.420 --> 00:11:53.230
they tend to be auto
generated, and there's actually

00:11:53.230 --> 00:11:57.280
an interface definition language
that generates all this.

00:11:57.280 --> 00:12:01.060
So this is the same thing
with the WebGL base.

00:12:01.060 --> 00:12:02.760
So, from there,
we're going to end up

00:12:02.760 --> 00:12:05.300
in the WebGLRenderingContext.

00:12:05.300 --> 00:12:07.560
And at this point,
we're going to handle

00:12:07.560 --> 00:12:12.570
any sort of validation and
any sort of security checks.

00:12:12.570 --> 00:12:15.670
So after that, we
can take a detour

00:12:15.670 --> 00:12:19.220
to the ContextSupport class.

00:12:19.220 --> 00:12:22.710
The naming's not there,
actually, Brandon Jones,

00:12:22.710 --> 00:12:26.830
one of the Chrome GPU
developers, was telling me,

00:12:26.830 --> 00:12:29.840
no, your diagram's wrong,
here's how it is now.

00:12:29.840 --> 00:12:32.500
So there is some sort
of ContextSupport class

00:12:32.500 --> 00:12:35.577
that will essentially do
stuff like loading a texture.

00:12:35.577 --> 00:12:37.160
But really where
it's going to end up,

00:12:37.160 --> 00:12:39.790
is a WebGraphicsContext.

00:12:39.790 --> 00:12:43.180
So, the thing to remember
is that WebGL is not

00:12:43.180 --> 00:12:45.920
the only thing running
in the browser.

00:12:45.920 --> 00:12:48.270
So, there are certain
conditions that

00:12:48.270 --> 00:12:54.110
will cause your web page
to be promoted to the GPU.

00:12:54.110 --> 00:12:59.770
And web devs typically do this
with a translation of zero.

00:12:59.770 --> 00:13:01.440
So any of that,
they're kind of hoping

00:13:01.440 --> 00:13:04.290
it's going to promote
it to the graphics card,

00:13:04.290 --> 00:13:07.310
and hopefully it's faster.

00:13:07.310 --> 00:13:11.240
Now, that WebGraphicsContext,
what it does,

00:13:11.240 --> 00:13:13.170
is it fills a command buffer.

00:13:13.170 --> 00:13:15.610
And that command buffer
ends up getting picked up

00:13:15.610 --> 00:13:18.160
by the GPU process.

00:13:18.160 --> 00:13:21.080
So, obviously,
there's a lot of code.

00:13:21.080 --> 00:13:24.200
And this is more or less
the 1,000-foot view.

00:13:24.200 --> 00:13:26.300
But this kind of
gives you an idea

00:13:26.300 --> 00:13:32.110
on what happens every time
you make a call into WebGL.

00:13:32.110 --> 00:13:34.750
So what's the takeaway?

00:13:34.750 --> 00:13:38.410
Well, every time
you call into WebGL,

00:13:38.410 --> 00:13:41.070
there's always going to be
some amount of overhead.

00:13:41.070 --> 00:13:43.420
And you're not going
to be able to avoid it.

00:13:43.420 --> 00:13:48.890
It's there completely by design,
to ensure security, as well as

00:13:48.890 --> 00:13:52.630
support other things the
browser is actually doing.

00:13:52.630 --> 00:13:55.990
So what this means is
there's a hard limit

00:13:55.990 --> 00:13:58.800
to the number of calls
that can happen in a frame.

00:13:58.800 --> 00:14:01.970
Now, the exact number is really
going to vary on the hardware,

00:14:01.970 --> 00:14:05.490
but because of this,
we need to make

00:14:05.490 --> 00:14:08.970
sure we are making the smallest
possible number of calls

00:14:08.970 --> 00:14:10.910
to WebGL.

00:14:10.910 --> 00:14:16.280
So, how do we know what
calls should actually occur?

00:14:16.280 --> 00:14:20.220
Well, WebGL itself
is a state machine.

00:14:20.220 --> 00:14:25.280
So what that means is that
when you make a WebGL call

00:14:25.280 --> 00:14:28.050
you are very likely
to be changing state.

00:14:28.050 --> 00:14:30.710
There's some calls that
won't change state,

00:14:30.710 --> 00:14:34.010
but the good chunk of them, if
you're actually doing any work,

00:14:34.010 --> 00:14:37.500
are going to modify
some form of state.

00:14:37.500 --> 00:14:40.940
So this could be
multiple things.

00:14:40.940 --> 00:14:44.270
So you can affect the entirety
of the rendering context,

00:14:44.270 --> 00:14:46.260
so you can do
something like change

00:14:46.260 --> 00:14:48.010
the depth test you're using.

00:14:48.010 --> 00:14:52.010
And that's going to be when
you change it, it's there,

00:14:52.010 --> 00:14:55.890
and that's what's happening.

00:14:55.890 --> 00:15:00.460
You can also change the
state of a WebGL object.

00:15:00.460 --> 00:15:02.680
WebGL object is
basically anything

00:15:02.680 --> 00:15:06.700
you would make through
a create function.

00:15:06.700 --> 00:15:10.730
So, this includes stuff like
textures, your shader programs,

00:15:10.730 --> 00:15:12.650
and your buffers.

00:15:12.650 --> 00:15:16.060
So, if a call that
should change state

00:15:16.060 --> 00:15:20.240
does not actually change
any state after execution,

00:15:20.240 --> 00:15:24.790
this is known as
a redundant call.

00:15:24.790 --> 00:15:27.700
So, in this case, I'm going
to give you an example.

00:15:27.700 --> 00:15:32.110
So on the left, we have
just a simple batching code,

00:15:32.110 --> 00:15:36.480
it's just going to be
interacting with the program,

00:15:36.480 --> 00:15:40.230
saying some uniforms, and
then it's off on its way.

00:15:40.230 --> 00:15:44.830
On the right, I'm
giving a diagram on

00:15:44.830 --> 00:15:48.980
what's happening in the totality
of the rendering context,

00:15:48.980 --> 00:15:52.520
as well as what's happening with
the individual program itself.

00:15:52.520 --> 00:15:56.160
So if we step through
this function,

00:15:56.160 --> 00:15:59.330
first off, we hit gl.useProgram.

00:15:59.330 --> 00:16:03.010
So this is going to bind the
program to the pipeline you're

00:16:03.010 --> 00:16:06.570
now rendering with that
particular program.

00:16:06.570 --> 00:16:09.230
You're going to call
and modify the uniform.

00:16:09.230 --> 00:16:13.300
Now, in this case, we are taking
the alpha within the shader

00:16:13.300 --> 00:16:16.030
and we're setting it to 0.5.

00:16:16.030 --> 00:16:19.370
That's cool because we
were at zero before.

00:16:19.370 --> 00:16:25.500
Now we go ahead and we
modify the texture unit

00:16:25.500 --> 00:16:29.230
our sampler is referring to,
and we're setting it to zero.

00:16:29.230 --> 00:16:32.330
Well the thing is,
it was already zero,

00:16:32.330 --> 00:16:35.440
and essentially, this
call did nothing.

00:16:35.440 --> 00:16:37.710
And of course, if
you're doing this,

00:16:37.710 --> 00:16:43.480
you're paying the price for
it, as it's a redundant call.

00:16:43.480 --> 00:16:46.010
So how do we stop this?

00:16:46.010 --> 00:16:49.650
Well this actually requires
some brains in the application.

00:16:49.650 --> 00:16:52.570
Basically, if you're writing
a renderer for WebGL,

00:16:52.570 --> 00:16:56.700
you basically need to mirror
the entire state of WebGL

00:16:56.700 --> 00:16:59.410
within your application.

00:16:59.410 --> 00:17:02.040
So, whenever a call is
made, essentially, we

00:17:02.040 --> 00:17:04.910
need to compare
the current value

00:17:04.910 --> 00:17:07.680
to the value we
want to set it to.

00:17:07.680 --> 00:17:11.460
And if it's not equal, we can
go ahead and let the call slide

00:17:11.460 --> 00:17:12.660
through.

00:17:12.660 --> 00:17:16.829
If it is equal, we want
to stop it in its tracks.

00:17:16.829 --> 00:17:19.460
And, like I said,
the renderer needs

00:17:19.460 --> 00:17:23.940
to be designed to handle this
for every single instance

00:17:23.940 --> 00:17:28.410
of WebGL call to be optimal.

00:17:28.410 --> 00:17:32.960
So, in this example, I grab some
of the code from the TriLithium

00:17:32.960 --> 00:17:36.320
API, and this is one
of those cases where

00:17:36.320 --> 00:17:41.130
we are limiting the
number of calls.

00:17:41.130 --> 00:17:45.980
And this is just a simple front
door, it has a current state.

00:17:45.980 --> 00:17:47.580
When you try and
set the value, it

00:17:47.580 --> 00:17:52.340
compares it to the current
value within the front door.

00:17:52.340 --> 00:17:55.170
And like I said,
if it's different,

00:17:55.170 --> 00:17:57.250
we go ahead and make the call.

00:17:57.250 --> 00:17:59.580
If it's the same, we
ignore it completely.

00:18:02.510 --> 00:18:06.190
So really, this was
a big win for us.

00:18:06.190 --> 00:18:11.010
The older version of the
API did nothing like this.

00:18:11.010 --> 00:18:13.940
So it drastically cut
down the number of calls

00:18:13.940 --> 00:18:17.110
and here are some
results for you.

00:18:17.110 --> 00:18:20.930
So at best, we're making a
quarter of the number of calls.

00:18:20.930 --> 00:18:26.230
That meant that in some cases,
3/4 of the number of calls

00:18:26.230 --> 00:18:28.850
were worthless.

00:18:28.850 --> 00:18:31.220
And at worst, we seem
to be making about half

00:18:31.220 --> 00:18:33.490
the number of calls we made.

00:18:33.490 --> 00:18:38.220
And my completely
unscientific study of it

00:18:38.220 --> 00:18:43.940
seemed to say that it
was about 1/3 on average.

00:18:43.940 --> 00:18:46.610
And really, at
this point in time,

00:18:46.610 --> 00:18:49.350
everything started
feeling a lot better.

00:18:49.350 --> 00:18:54.400
It was a lot less scary that
I burned everything down.

00:18:54.400 --> 00:19:01.260
And people were quite a bit
more receptive at this point.

00:19:01.260 --> 00:19:06.360
So, with our optimized renderer
in place, we need to go higher.

00:19:06.360 --> 00:19:09.340
Remember, you can still
get yourself in trouble

00:19:09.340 --> 00:19:12.720
if you aren't submitting your
geometry in an optimal way.

00:19:12.720 --> 00:19:17.450
So, here are some general
rules you should be following.

00:19:17.450 --> 00:19:20.720
If you can't see
it, don't drive.

00:19:20.720 --> 00:19:24.690
Basically, you want to compare
the geometry to the camera.

00:19:24.690 --> 00:19:27.450
If the camera can see it,
go ahead and let it through.

00:19:27.450 --> 00:19:31.260
If it can't, stop
it in its tracks.

00:19:31.260 --> 00:19:36.820
We also want to submit any
opaque geometry front to back.

00:19:36.820 --> 00:19:41.350
Now, the rationale here is
if you have a large geometry,

00:19:41.350 --> 00:19:43.700
and it's fairly close
to you, but there's

00:19:43.700 --> 00:19:48.540
another geometry behind it,
you draw that one first.

00:19:48.540 --> 00:19:52.910
The depth test for that second
geometry is likely a fail.

00:19:52.910 --> 00:19:55.040
And if you have a
fragment shader that's

00:19:55.040 --> 00:19:59.910
taking up a good amount of time,
that can save you some work,

00:19:59.910 --> 00:20:05.200
and it's definitely
optimization you should try for.

00:20:05.200 --> 00:20:09.180
But also remember
on the converse,

00:20:09.180 --> 00:20:12.260
the opposite is true for
your transparent geometry.

00:20:12.260 --> 00:20:15.300
You want to render
them the opposite way.

00:20:15.300 --> 00:20:18.860
Otherwise, your blending
will not look correct.

00:20:18.860 --> 00:20:20.570
And of course,
what you want to do

00:20:20.570 --> 00:20:25.920
is also to try to group
geometry with the same state.

00:20:25.920 --> 00:20:28.330
And this is to
minimize the amount

00:20:28.330 --> 00:20:32.364
of calls we're
going into web geo.

00:20:32.364 --> 00:20:37.020
Of course, the most important
rule of optimization,

00:20:37.020 --> 00:20:41.500
optimize for your case,
not the general case.

00:20:41.500 --> 00:20:44.640
You really need to think
about how you're scene works,

00:20:44.640 --> 00:20:46.680
you need to figure
out your requirements,

00:20:46.680 --> 00:20:49.810
and you need to design
your algorithm around this.

00:20:49.810 --> 00:20:51.500
And that's how
you will really be

00:20:51.500 --> 00:20:55.830
able to push the hardware
in new and interesting ways.

00:20:55.830 --> 00:20:58.430
So in this case, what did
the PlayStation store scene

00:20:58.430 --> 00:21:00.250
look like?

00:21:00.250 --> 00:21:03.000
The tree was pretty deep.

00:21:03.000 --> 00:21:05.480
We had a lot of nodes
that were basically

00:21:05.480 --> 00:21:08.020
used to position other nodes.

00:21:08.020 --> 00:21:15.880
And the worst case I saw
was a tree with 26 levels.

00:21:15.880 --> 00:21:21.830
It was a ton of nodes, not a
lot of actual drawable entities.

00:21:21.830 --> 00:21:25.830
The other thing to remember,
in the PlayStation store,

00:21:25.830 --> 00:21:28.860
was our textures were unique.

00:21:28.860 --> 00:21:33.400
So we would constantly be
requesting product images,

00:21:33.400 --> 00:21:39.680
text, and that didn't really
allow us to do sheeting.

00:21:39.680 --> 00:21:41.340
Texture sheeting
is a technique you

00:21:41.340 --> 00:21:47.510
would use to limit the number
of times you switch a texture.

00:21:47.510 --> 00:21:50.660
CSS can also do
something like this.

00:21:50.660 --> 00:21:55.420
Definitely the perf guys
will tell you to do this.

00:21:55.420 --> 00:22:01.180
So, another thing that was a
characteristic of our scene,

00:22:01.180 --> 00:22:03.860
was the objects themselves
weren't too mobile.

00:22:03.860 --> 00:22:08.780
So that means that really
the only time stuff

00:22:08.780 --> 00:22:12.650
would start moving is
when you had user input.

00:22:12.650 --> 00:22:17.530
And we also had a
requirement that some areas

00:22:17.530 --> 00:22:22.690
needed to be clipped
to some bounding area.

00:22:22.690 --> 00:22:26.890
So with that in
mind, what did we do?

00:22:26.890 --> 00:22:30.130
So since things weren't
moving that much,

00:22:30.130 --> 00:22:33.830
the visible set was only
computed when the tree changed.

00:22:33.830 --> 00:22:37.510
So the visible set meaning,
we run through our tree,

00:22:37.510 --> 00:22:41.000
we figure out what is
actually available to draw,

00:22:41.000 --> 00:22:46.010
and we use that to
feed the renderer.

00:22:46.010 --> 00:22:49.701
The scene was deep, so
rather than bubbling up

00:22:49.701 --> 00:22:51.450
the bounding volumes,
which is what you'll

00:22:51.450 --> 00:22:57.680
see in a lot of engines
where the bounding volume

00:22:57.680 --> 00:23:02.035
of the object below
affects the one up higher,

00:23:02.035 --> 00:23:05.890
and we bubble up, up, up,
up, all the way to the top.

00:23:05.890 --> 00:23:08.950
So, this didn't
really help us, and it

00:23:08.950 --> 00:23:12.630
would have created a
hell of a lot more work,

00:23:12.630 --> 00:23:14.950
because, as I said,
a lot of the things

00:23:14.950 --> 00:23:17.970
have to do with positioning.

00:23:17.970 --> 00:23:23.000
And, in our case,
whenever we-- So

00:23:23.000 --> 00:23:27.310
we use those bonding volumes as
the actual points of clipping.

00:23:27.310 --> 00:23:33.700
And when the intersected
bounding volume was met,

00:23:33.700 --> 00:23:35.730
what we would do,
is intersect those,

00:23:35.730 --> 00:23:38.060
and use that smaller
bounding volume

00:23:38.060 --> 00:23:41.510
to affect the geometry
further down the tree.

00:23:41.510 --> 00:23:43.830
So let me give you
an example of that.

00:23:43.830 --> 00:23:50.360
So, let's say that in the
case of the yellowish nodes,

00:23:50.360 --> 00:23:54.200
those actually have clipping
volumes associated with them.

00:23:54.200 --> 00:23:57.490
So, we work our
way down the left

00:23:57.490 --> 00:23:59.620
and we compare those
two clipping volumes.

00:23:59.620 --> 00:24:00.950
We do an intersection.

00:24:00.950 --> 00:24:03.230
They do intersect,
so then we use

00:24:03.230 --> 00:24:08.450
that smaller volume to
compare the leaf node.

00:24:08.450 --> 00:24:12.360
In this case, it passes, so
it's added to the visible side.

00:24:12.360 --> 00:24:17.040
So then we're going to continue
down over on this side,

00:24:17.040 --> 00:24:21.710
and we just compare
it with that top one.

00:24:21.710 --> 00:24:27.830
And we find it's within our
view, so it goes through.

00:24:27.830 --> 00:24:30.020
Now we go further down
into the right side.

00:24:30.020 --> 00:24:34.050
So we're comparing these two
and seeing the intersection.

00:24:34.050 --> 00:24:37.310
So there's actually no
intersection, so at that point,

00:24:37.310 --> 00:24:39.103
we can say, all
right, we're not even

00:24:39.103 --> 00:24:42.500
going to bother with
the rest of you guys.

00:24:42.500 --> 00:24:47.590
So, that's more or less how the
algorithm worked in our case.

00:24:47.590 --> 00:24:51.330
So, the last tip for
you is to keep your work

00:24:51.330 --> 00:24:53.490
within the animation frame.

00:24:53.490 --> 00:24:55.250
So, as I mentioned,
the browser has

00:24:55.250 --> 00:24:57.920
a ton of other things going on.

00:24:57.920 --> 00:25:00.832
It does not think
you're that important.

00:25:00.832 --> 00:25:02.290
So, there are things
that are going

00:25:02.290 --> 00:25:04.680
to happen outside of your frame.

00:25:04.680 --> 00:25:08.180
The big one there would
obviously be timeouts.

00:25:08.180 --> 00:25:12.620
And it also includes
getting your images,

00:25:12.620 --> 00:25:18.280
getting your HTTP
requests, and of course,

00:25:18.280 --> 00:25:22.510
remember, if there's an event
or series of events that take up

00:25:22.510 --> 00:25:27.270
a good amount of your time, you
can completely drop a frame,

00:25:27.270 --> 00:25:29.330
and you will be
looking at your frame

00:25:29.330 --> 00:25:33.100
and say, well, I was ready
in five milliseconds.

00:25:33.100 --> 00:25:34.467
I don't know what happened.

00:25:34.467 --> 00:25:36.550
Well, most likely a timeout
of some kind happened.

00:25:39.590 --> 00:25:43.080
So to combat this, we looked
at how resources were actually

00:25:43.080 --> 00:25:45.880
being created within the store.

00:25:45.880 --> 00:25:49.090
So, any time a user
ended up in a new view,

00:25:49.090 --> 00:25:51.500
there were a ton of
requests going out.

00:25:51.500 --> 00:25:53.480
So we were requesting
information

00:25:53.480 --> 00:25:57.100
on how things are
laid out, images,

00:25:57.100 --> 00:26:01.160
getting text, all those things.

00:26:01.160 --> 00:26:07.770
Yeah, so, ton of texture,
ton of product art, and we

00:26:07.770 --> 00:26:10.620
also had our text.

00:26:10.620 --> 00:26:13.460
So, to keep the
frame rates steady,

00:26:13.460 --> 00:26:17.920
we decided to basically
pay off the amount

00:26:17.920 --> 00:26:22.490
of time over a series of frames.

00:26:22.490 --> 00:26:25.600
So to do this, we
created a Task Manager,

00:26:25.600 --> 00:26:28.990
because why not have an
operating system construct

00:26:28.990 --> 00:26:30.420
in your WebGL program?

00:26:33.500 --> 00:26:36.460
So it's not really complicated,
it's just a simple [INAUDIBLE],

00:26:36.460 --> 00:26:41.560
[INAUDIBLE] priority,
it wasn't really needed.

00:26:41.560 --> 00:26:46.980
So, in our case, what
exactly is a task for us?

00:26:46.980 --> 00:26:49.680
So, when image is
received, we actually

00:26:49.680 --> 00:26:53.950
defer the loading to
the animation frame.

00:26:53.950 --> 00:26:58.060
So we get the response, we
say, OK, you are our task,

00:26:58.060 --> 00:27:00.246
I'm going to insert
you to the queue,

00:27:00.246 --> 00:27:02.510
and you are going to run
at some time in the future.

00:27:05.510 --> 00:27:09.380
So, we also did text
creation that way.

00:27:09.380 --> 00:27:13.470
Our text creation could
probably be a bit better,

00:27:13.470 --> 00:27:16.140
there's certainly
some optimizations

00:27:16.140 --> 00:27:19.430
we could do there, like a
bitmap font or things like that.

00:27:19.430 --> 00:27:24.996
But, due to the amount of
time of me going nuclear,

00:27:24.996 --> 00:27:26.370
didn't really have
time for that.

00:27:26.370 --> 00:27:28.740
So we actually used Canvas.

00:27:28.740 --> 00:27:32.980
And whenever we request
a new batch of text,

00:27:32.980 --> 00:27:35.240
it actually busts it
up into three steps.

00:27:35.240 --> 00:27:38.460
So initially we compute
the layout, from there,

00:27:38.460 --> 00:27:42.620
we take that and draw
it into the canvas.

00:27:42.620 --> 00:27:45.800
And then, another task comes
around and actually uploads

00:27:45.800 --> 00:27:47.540
the canvas to a texture.

00:27:47.540 --> 00:27:50.261
Those last two end up
being slotted right next

00:27:50.261 --> 00:27:51.760
to each other, so
didn't really have

00:27:51.760 --> 00:27:54.820
to worry about
anything in there.

00:27:54.820 --> 00:27:59.910
So, to keep our
frame rates steady,

00:27:59.910 --> 00:28:03.240
we needed to limit the
amount of time we actually

00:28:03.240 --> 00:28:06.200
took to run these tasks.

00:28:06.200 --> 00:28:11.820
So, that pretty much
ensures the application has

00:28:11.820 --> 00:28:14.460
enough time for anything
else it wants to do.

00:28:14.460 --> 00:28:19.000
Like an update in
renderer and all that.

00:28:19.000 --> 00:28:21.870
So obviously, it's not
a perfect solution,

00:28:21.870 --> 00:28:24.070
because there is
essentially no way

00:28:24.070 --> 00:28:26.630
to stop a task
once it's started.

00:28:26.630 --> 00:28:28.820
When you upload a
texture, it's going

00:28:28.820 --> 00:28:31.130
to take however long
it's going to take.

00:28:31.130 --> 00:28:32.520
And that's it.

00:28:32.520 --> 00:28:35.220
So if you had the case where you
set something for, let's say,

00:28:35.220 --> 00:28:41.110
five milliseconds, and you had
your task finished at four,

00:28:41.110 --> 00:28:43.140
it's going to kick
off another one,

00:28:43.140 --> 00:28:46.540
and if that one goes another
five milliseconds, really

00:28:46.540 --> 00:28:48.190
not much you can do.

00:28:48.190 --> 00:28:51.890
So really, at this point, to
do that, we more or less played

00:28:51.890 --> 00:28:55.750
with the numbers and
figured out exactly

00:28:55.750 --> 00:29:00.530
what felt good in terms
of the frame rate,

00:29:00.530 --> 00:29:03.960
versus how quickly the
assets were appearing.

00:29:03.960 --> 00:29:07.490
So if you made it super quick,
you're always going to get 60,

00:29:07.490 --> 00:29:11.290
but, things are going
to creep in slower.

00:29:11.290 --> 00:29:14.990
So it's definitely a
balancing game there.

00:29:14.990 --> 00:29:18.680
So, obviously, our task manager,
nothing special, first in,

00:29:18.680 --> 00:29:20.090
first out.

00:29:20.090 --> 00:29:23.830
We look at the number
of tasks, we compare it

00:29:23.830 --> 00:29:28.420
to whatever our maximum
time span is, we pop a task,

00:29:28.420 --> 00:29:30.580
we run it, we check
it, and we keep

00:29:30.580 --> 00:29:34.920
going until we either run out
of tasks or we run out of time.

00:29:34.920 --> 00:29:36.830
So, like I said,
nothing special,

00:29:36.830 --> 00:29:42.430
but it actually really helped
us keep that frame rate.

00:29:42.430 --> 00:29:45.400
So, in conclusion
here, if you want

00:29:45.400 --> 00:29:49.990
to optimize a WebGL application,
you need to do the following.

00:29:49.990 --> 00:29:53.950
You need to ensure you renderer
is optimal by preventing

00:29:53.950 --> 00:29:56.910
redundant calls,
you need to optimize

00:29:56.910 --> 00:30:00.920
how geometry is submitted
to your application.

00:30:00.920 --> 00:30:04.340
And really to avoid
any sort of jank,

00:30:04.340 --> 00:30:07.230
you need to keep the work
on the animation frame.

00:30:07.230 --> 00:30:09.840
So if you follow
these rules, you'll

00:30:09.840 --> 00:30:13.270
be able to really push your
application even further,

00:30:13.270 --> 00:30:19.250
and create even more compelling,
awesome experiences with WebGL.

00:30:19.250 --> 00:30:23.350
So, now we are in the shameless
self-promotion portion

00:30:23.350 --> 00:30:31.100
of the talk, so
this particular talk

00:30:31.100 --> 00:30:35.280
is more or less a PS4-themed
version of an article

00:30:35.280 --> 00:30:39.430
wrote for "HTML5 Game
Development Insights,"

00:30:39.430 --> 00:30:42.050
currently available for
pre-order on Apress.

00:30:42.050 --> 00:30:47.020
And it has a lot of great
input from other devs,

00:30:47.020 --> 00:30:51.702
and the pirate guy helped
out, as I'm sure you've seen.

00:30:51.702 --> 00:30:53.204
AUDIENCE: Oh, kill your crew.

00:30:53.204 --> 00:30:54.620
DON OLMSTEAD: Yes,
kill your crew.

00:30:57.250 --> 00:31:00.050
All right, so, any
questions we're

00:31:00.050 --> 00:31:02.380
deferring to the QA panel.

00:31:02.380 --> 00:31:05.150
But here's obviously my
contact info on the right.

00:31:08.000 --> 00:31:12.430
I'm pretty good with g+, I also
go to various other speaking

00:31:12.430 --> 00:31:17.220
gigs, like speaking at the
DartSF meet up next month,

00:31:17.220 --> 00:31:19.390
because Dart is awesome.

00:31:19.390 --> 00:31:22.460
And of course,
SNEI is hiring, we

00:31:22.460 --> 00:31:25.820
have a booth here, we
have a PlayStation 4,

00:31:25.820 --> 00:31:29.610
and obviously, if you're a
web dev, one of the things

00:31:29.610 --> 00:31:32.040
that really sucks
about web dev, is

00:31:32.040 --> 00:31:34.860
worrying about older browsers.

00:31:34.860 --> 00:31:39.100
And we don't really have that,
since we own the browser,

00:31:39.100 --> 00:31:40.960
so you're never
really going to have

00:31:40.960 --> 00:31:44.460
to worry about IE8 or
anything like that.

00:31:44.460 --> 00:31:47.990
So, definitely thank
you guys for having me.

