WEBVTT
Kind: captions
Language: en

00:00:01.610 --> 00:00:02.640
RYAN: Hello, everyone.

00:00:02.640 --> 00:00:06.800
Welcome back for the last
session of the day here.

00:00:06.800 --> 00:00:08.470
And we're culminating
with a really great

00:00:08.470 --> 00:00:10.470
session here by Yanick.

00:00:10.470 --> 00:00:12.810
Yanick is from EA and he's
going to come up and talk

00:00:12.810 --> 00:00:16.820
about how they've built their
mobile games servers on Google

00:00:16.820 --> 00:00:17.520
App Engine.

00:00:17.520 --> 00:00:21.300
So really practical use of a lot
of the things that you've

00:00:21.300 --> 00:00:23.620
learned today, and he's going
to give you some tips and

00:00:23.620 --> 00:00:24.620
tricks as well.

00:00:24.620 --> 00:00:27.490
So welcome, Yanick.

00:00:27.490 --> 00:00:29.900
YANICK BELANGER: Thank
you, Ryan.

00:00:29.900 --> 00:00:32.380
So hello, my name is Yanick
Belanger, I'm a

00:00:32.380 --> 00:00:34.160
architecture lead--

00:00:34.160 --> 00:00:37.170
server architecture lead at
Electronic Arts, specifically,

00:00:37.170 --> 00:00:40.990
at the playing [INAUDIBLE]
studio up there in Montreal.

00:00:40.990 --> 00:00:44.250
If you want to know, yes, we
still have that much snow up

00:00:44.250 --> 00:00:46.200
there in Canada.

00:00:46.200 --> 00:00:50.570
So I'm here today to talk about
how we integrate Google

00:00:50.570 --> 00:00:55.450
App Engine in our development
of our mobile game servers.

00:00:55.450 --> 00:00:56.360
OK?

00:00:56.360 --> 00:00:57.460
I'm not a sales guy.

00:00:57.460 --> 00:01:00.750
I'm not here to promote App
Engine, I'm not here to

00:01:00.750 --> 00:01:02.880
promote our games as well.

00:01:02.880 --> 00:01:07.590
I'm simply here because we
believe in my team that Google

00:01:07.590 --> 00:01:11.370
App Engine is really an amazing
piece of technology.

00:01:11.370 --> 00:01:15.830
So let's jump first on a really
quick scenario, OK?

00:01:15.830 --> 00:01:17.610
Let's say you're a small
game company.

00:01:17.610 --> 00:01:20.960
You've developed an amazing
new game, OK?

00:01:20.960 --> 00:01:22.290
It's going to be awesome.

00:01:22.290 --> 00:01:24.520
This game is a multiplayer
games.

00:01:24.520 --> 00:01:26.630
You have your server ready.

00:01:26.630 --> 00:01:29.720
It sits right under your desk
using this old Pentium that

00:01:29.720 --> 00:01:31.010
was laying around.

00:01:31.010 --> 00:01:32.090
OK?

00:01:32.090 --> 00:01:33.690
And you launch the
game, finally.

00:01:33.690 --> 00:01:36.180
It's a great game.

00:01:36.180 --> 00:01:38.560
It gets immediate success.

00:01:38.560 --> 00:01:39.670
It's a viral game.

00:01:39.670 --> 00:01:41.720
Everybody talks about it.

00:01:41.720 --> 00:01:45.180
You get a major response
from the market.

00:01:45.180 --> 00:01:49.990
But eventually, what you see
is that your old machine is

00:01:49.990 --> 00:01:53.980
smoking badly and you
get [INAUDIBLE].

00:01:53.980 --> 00:01:56.670
So how can you prevent that?

00:01:56.670 --> 00:01:59.220
You have to plan for success.

00:01:59.220 --> 00:02:03.730
And typically, using a standard
technology stack on

00:02:03.730 --> 00:02:07.850
the server side, it means that
you have to invest a lot of

00:02:07.850 --> 00:02:13.760
money and time and resources in
proving that your platform

00:02:13.760 --> 00:02:18.640
will stay alive in the event
of a successful game.

00:02:18.640 --> 00:02:20.820
That's where Google App
Engine make sense.

00:02:20.820 --> 00:02:23.880
It makes sense for small
companies, and it also makes

00:02:23.880 --> 00:02:25.870
sense for big companies
like EA.

00:02:28.640 --> 00:02:31.100
So what's App Engine exactly?

00:02:31.100 --> 00:02:31.250
OK.

00:02:31.250 --> 00:02:33.810
I'm not here to describe in
details what's App Engine.

00:02:33.810 --> 00:02:36.870
I mean, we, during the previous
sessions we had a

00:02:36.870 --> 00:02:39.080
pretty good overview of
what's App Engine.

00:02:39.080 --> 00:02:43.040
There's tons of good resources
on the internet, good videos

00:02:43.040 --> 00:02:45.350
that describes what's
App Engine.

00:02:45.350 --> 00:02:48.840
But let's say a quick
overview of what is

00:02:48.840 --> 00:02:49.890
this platform exactly.

00:02:49.890 --> 00:02:54.880
It's a platform as a service
Cloud computing.

00:02:54.880 --> 00:02:56.360
It means that you sit--

00:02:56.360 --> 00:02:58.210
your application will
sit on top of a

00:02:58.210 --> 00:03:00.070
very high level platform.

00:03:00.070 --> 00:03:03.940
It's pretty different than a
IAAS infrastructure as a

00:03:03.940 --> 00:03:06.840
service platform where you
basically have to manage your

00:03:06.840 --> 00:03:11.380
OS, your software stack.

00:03:11.380 --> 00:03:14.200
App Engine, as I said, is
a high level platform.

00:03:14.200 --> 00:03:15.950
You have no infrastructure
to manage.

00:03:15.950 --> 00:03:22.190
You can build your application
using Java, Python or Go.

00:03:22.190 --> 00:03:25.530
It's built using
existing Google

00:03:25.530 --> 00:03:27.780
technology and Google services.

00:03:27.780 --> 00:03:31.560
It's the same type of technology
that's used for

00:03:31.560 --> 00:03:33.420
their search engine,
for example.

00:03:33.420 --> 00:03:36.640
It's also automatically
scalable.

00:03:36.640 --> 00:03:39.700
It's an auto scaling system,
which means they will allocate

00:03:39.700 --> 00:03:44.430
new instances for you as your
traffic goes up and deallocate

00:03:44.430 --> 00:03:46.000
dues when the traffic
goes down.

00:03:46.000 --> 00:03:48.290
So at the end you pay
for what you use.

00:03:51.800 --> 00:03:55.110
At EA we use App Engine
to develop

00:03:55.110 --> 00:03:57.980
mobile connected games.

00:03:57.980 --> 00:04:00.160
They all have a pretty strong

00:04:00.160 --> 00:04:03.560
integration with social networks.

00:04:03.560 --> 00:04:07.260
Most of them are asynchronous
turn-based games, so

00:04:07.260 --> 00:04:10.240
multiplayer games, but we also
have single player games.

00:04:12.810 --> 00:04:17.200
We use other solutions for
two types of game.

00:04:17.200 --> 00:04:21.970
Real time is kind of hard to
achieve on App Engine because

00:04:21.970 --> 00:04:25.320
it's a shared infrastructure
with thousands of other

00:04:25.320 --> 00:04:28.440
application, to have a
predictable timing on App

00:04:28.440 --> 00:04:30.600
Engine is pretty hard.

00:04:30.600 --> 00:04:31.470
OK?

00:04:31.470 --> 00:04:34.130
So we have a different
solution for that.

00:04:34.130 --> 00:04:36.750
For casino-like games--

00:04:36.750 --> 00:04:39.230
this is pretty interesting
because for casino game you

00:04:39.230 --> 00:04:42.200
need really quick

00:04:42.200 --> 00:04:44.020
synchronization with your server.

00:04:44.020 --> 00:04:46.810
And that's currently not
possible from App Engine

00:04:46.810 --> 00:04:49.910
because they don't support a
dedicated channel between

00:04:49.910 --> 00:04:53.290
mobile client and your server.

00:04:53.290 --> 00:04:55.320
They have a pretty
good technology.

00:04:55.320 --> 00:04:58.520
They're a channel service for
web clients, but there's

00:04:58.520 --> 00:05:00.540
nothing for mobile
clients yet.

00:05:00.540 --> 00:05:04.540
It doesn't mean you can't use
a hybrid solution where you

00:05:04.540 --> 00:05:09.300
would host all the non-real time
aspect of your game on

00:05:09.300 --> 00:05:13.550
App Engine to manage profile,
manage matchmaking, your

00:05:13.550 --> 00:05:15.470
manager micro transactions.

00:05:15.470 --> 00:05:18.100
And have a separate system
hosted, for example, on

00:05:18.100 --> 00:05:21.910
Compute Engine or you're
in-house system for the real

00:05:21.910 --> 00:05:23.260
time aspect of the game.

00:05:27.130 --> 00:05:28.590
They're delivering
high quality.

00:05:28.590 --> 00:05:31.140
That's an interesting topic.

00:05:31.140 --> 00:05:34.450
App Engine is really an easy
platform to work with.

00:05:34.450 --> 00:05:37.190
You can quickly code and
deploy, in a matter of

00:05:37.190 --> 00:05:40.970
minutes, an application on App
Engine and like that it's

00:05:40.970 --> 00:05:43.925
available on the internet.

00:05:43.925 --> 00:05:45.240
It will scale.

00:05:45.240 --> 00:05:47.000
It's all great.

00:05:47.000 --> 00:05:51.610
That being said, don't expect
to code quickly something on

00:05:51.610 --> 00:05:56.790
App Engine and expect your
application to have a great,

00:05:56.790 --> 00:05:57.650
great quality.

00:05:57.650 --> 00:06:00.610
You have to have best practices,
technical knowledge

00:06:00.610 --> 00:06:01.940
of the platform.

00:06:01.940 --> 00:06:05.140
You have to add up
job processes.

00:06:05.140 --> 00:06:07.920
So I'll give you a quick review
of our approach to

00:06:07.920 --> 00:06:11.060
achieve high quality servers
on App Engine.

00:06:11.060 --> 00:06:14.463
And how we leverage the platform
strength to do it.

00:06:18.330 --> 00:06:20.160
First, this is really
important.

00:06:20.160 --> 00:06:24.620
This is not something everybody
understand at first,

00:06:24.620 --> 00:06:27.860
but we need to keep everything
as simple as possible.

00:06:27.860 --> 00:06:30.470
App Engine itself is pretty
simple to use.

00:06:30.470 --> 00:06:32.790
They have a simple API.

00:06:32.790 --> 00:06:35.270
So we need to keep everything
pretty simple.

00:06:35.270 --> 00:06:36.010
Why?

00:06:36.010 --> 00:06:39.540
Well, first, by keeping your
implementations and your

00:06:39.540 --> 00:06:43.290
design simple, you get the
more consistent quality.

00:06:43.290 --> 00:06:48.660
You get an application that is
easier to learn for the new

00:06:48.660 --> 00:06:49.400
developers.

00:06:49.400 --> 00:06:54.580
You get a platform that
is easier to refactor.

00:06:54.580 --> 00:06:55.340
OK?

00:06:55.340 --> 00:06:59.660
For example, we don't add use
lists abstractions on top of

00:06:59.660 --> 00:07:00.210
App Engine.

00:07:00.210 --> 00:07:03.635
We connect directly
to their API.

00:07:03.635 --> 00:07:07.590
If is no real goal, no real
benefit of having an

00:07:07.590 --> 00:07:09.440
abstraction, we don't do it.

00:07:09.440 --> 00:07:14.720
These are the basic principles
of agile software development.

00:07:14.720 --> 00:07:17.540
App Engine offers a great API.

00:07:17.540 --> 00:07:21.340
So why should we add an
abstraction on top of it if we

00:07:21.340 --> 00:07:22.780
don't need to?

00:07:22.780 --> 00:07:23.980
OK?

00:07:23.980 --> 00:07:26.080
We don't over engineer
our solutions.

00:07:26.080 --> 00:07:30.750
We code for the requirement
we have today, not for the

00:07:30.750 --> 00:07:34.230
requirements we're going
to have next week.

00:07:34.230 --> 00:07:38.750
And we try to keep the design
as simple as possible so we

00:07:38.750 --> 00:07:42.920
can refactor the design next
week when we have new

00:07:42.920 --> 00:07:44.810
requirements.

00:07:44.810 --> 00:07:47.900
We also leverage a lot
third-party libraries.

00:07:47.900 --> 00:07:51.140
There are tons of
them out there.

00:07:51.140 --> 00:07:54.330
We use JAVA for our
game servers.

00:07:54.330 --> 00:07:58.290
And there are really great
third-parties like Google

00:07:58.290 --> 00:08:01.660
Guice for dependence injection,
Jersey for your

00:08:01.660 --> 00:08:06.430
RESTful API, Makito
for the unit test.

00:08:06.430 --> 00:08:09.990
Those are all well-tested,
proven libraries that you

00:08:09.990 --> 00:08:11.300
should use.

00:08:11.300 --> 00:08:15.690
If you start coding something
that is there to solve a

00:08:15.690 --> 00:08:17.540
common problem, you're
probably wrong.

00:08:17.540 --> 00:08:20.730
There are tons of existing
libraries out there.

00:08:20.730 --> 00:08:21.740
Use them.

00:08:21.740 --> 00:08:25.800
We don't try reinvent the
wheel, basically.

00:08:25.800 --> 00:08:29.140
We also use components
within the company.

00:08:29.140 --> 00:08:32.454
There's no goal to recode
the same low

00:08:32.454 --> 00:08:33.630
level stuff every time.

00:08:33.630 --> 00:08:37.049
So we have what we call
our toolkit library--

00:08:37.049 --> 00:08:41.505
App Engine tool kit library--
where you can find basically a

00:08:41.505 --> 00:08:46.120
set of reusable components,
reusable building blocks.

00:08:46.120 --> 00:08:47.560
They're all optional
building blocks.

00:08:47.560 --> 00:08:50.400
It's not a framework, it's
pretty different.

00:08:50.400 --> 00:08:53.330
And that's where we share across
all our games, the

00:08:53.330 --> 00:08:56.370
common stuff to handle
matchmaking, for example,

00:08:56.370 --> 00:08:58.110
micro transaction validations,

00:08:58.110 --> 00:08:59.585
connection to external services.

00:09:04.200 --> 00:09:07.780
Another approach we have is this
principle, test early and

00:09:07.780 --> 00:09:09.170
test often.

00:09:09.170 --> 00:09:14.220
The idea is that the cost of
finding a bug is exponential

00:09:14.220 --> 00:09:17.840
as your development process
is going forward.

00:09:17.840 --> 00:09:21.870
I mean, the best place to find
a bug-- this is not really a

00:09:21.870 --> 00:09:25.660
test phase but it's a great
place to find a bug-- is in

00:09:25.660 --> 00:09:28.120
your compiler, directly
in your editor.

00:09:28.120 --> 00:09:31.060
You see right away when there's
an issue with the call

00:09:31.060 --> 00:09:32.010
your doing.

00:09:32.010 --> 00:09:32.810
You fix it.

00:09:32.810 --> 00:09:34.520
It takes five seconds.

00:09:34.520 --> 00:09:36.850
The investment is minimal.

00:09:36.850 --> 00:09:37.200
OK?

00:09:37.200 --> 00:09:38.730
You don't lose your time.

00:09:38.730 --> 00:09:39.980
It's fixed.

00:09:41.990 --> 00:09:43.120
We do unit testing.

00:09:43.120 --> 00:09:45.430
These are great place, also,
to find your bugs.

00:09:45.430 --> 00:09:48.570
And regression bugs, also.

00:09:48.570 --> 00:09:53.230
We do unit test to test in
isolation our components.

00:09:53.230 --> 00:09:57.060
App Engine offers a great set
of stubs for their services

00:09:57.060 --> 00:10:02.180
that will help you a lot to
develop your unit test.

00:10:02.180 --> 00:10:03.820
We also do integration test.

00:10:03.820 --> 00:10:09.140
Integration test is basically
you want to validate that the

00:10:09.140 --> 00:10:13.430
integration of your different
components is as expected.

00:10:13.430 --> 00:10:13.770
OK?

00:10:13.770 --> 00:10:15.805
You want test the
glue between the

00:10:15.805 --> 00:10:17.370
loose components, basically.

00:10:17.370 --> 00:10:21.080
We also use integration test
as a kind of a black box

00:10:21.080 --> 00:10:24.870
testing, where we inject traffic
just like a real

00:10:24.870 --> 00:10:28.176
client would do, and we
validate the result.

00:10:28.176 --> 00:10:31.840
App Engine offers a great local
development environment

00:10:31.840 --> 00:10:34.990
for that where you can start
easily on your development

00:10:34.990 --> 00:10:39.720
machine server that will mimic
pretty well what you end up

00:10:39.720 --> 00:10:42.450
having on a real Cloud.

00:10:42.450 --> 00:10:46.340
So what we have, using Maven
for Java, we have a process

00:10:46.340 --> 00:10:54.500
that will compile the server,
execute the unit test, start

00:10:54.500 --> 00:11:00.050
the server, execute the
integration test and validate

00:11:00.050 --> 00:11:01.030
that everything is OK.

00:11:01.030 --> 00:11:07.040
And these steps take less than
two or three minutes, usually.

00:11:07.040 --> 00:11:08.820
This aspect is very important.

00:11:08.820 --> 00:11:10.920
It has to be fast so that
your developer will

00:11:10.920 --> 00:11:12.470
run them every time.

00:11:12.470 --> 00:11:15.570
You want to validate the
quality every time.

00:11:15.570 --> 00:11:18.400
You want to test often,
basically.

00:11:18.400 --> 00:11:25.410
And the last place you can
find your bug before they

00:11:25.410 --> 00:11:29.410
reach the players is
in the QA team.

00:11:29.410 --> 00:11:30.730
But this is costly.

00:11:30.730 --> 00:11:35.420
Basically, you lose a lot of
time, it's a lot of money, a

00:11:35.420 --> 00:11:39.190
lot of time when you
find bugs there.

00:11:39.190 --> 00:11:41.730
It's preferable to find them
in the previous steps.

00:11:44.450 --> 00:11:47.690
We also have a typical
continuous integration

00:11:47.690 --> 00:11:51.720
environment that will build our
servers and test them on

00:11:51.720 --> 00:11:56.040
every commit in our source
control system.

00:11:56.040 --> 00:11:59.300
The build system will also
automatically deploy our new

00:11:59.300 --> 00:12:04.590
versions on the App Engine
environment on the Cloud.

00:12:04.590 --> 00:12:08.450
And some of these environments
we even switch on

00:12:08.450 --> 00:12:11.860
automatically the new versions
so that another team can start

00:12:11.860 --> 00:12:15.550
testing right away with
the new version.

00:12:15.550 --> 00:12:21.040
We also have a dedicated team at
EA that is a specialized in

00:12:21.040 --> 00:12:23.000
doing load test-- system test.

00:12:23.000 --> 00:12:24.170
OK.

00:12:24.170 --> 00:12:27.560
Even though App Engine isn't a
[INAUDIBLE] scaling system,

00:12:27.560 --> 00:12:30.520
you still have to prove that
your application will scale

00:12:30.520 --> 00:12:35.500
well on App Engine, that it
will perform well and at a

00:12:35.500 --> 00:12:37.490
reasonable cost.

00:12:37.490 --> 00:12:41.940
So, in summary, our approach to
achieve high quality on App

00:12:41.940 --> 00:12:43.800
Engine is not rocket science.

00:12:43.800 --> 00:12:48.490
I mean, we use basic agile
software development

00:12:48.490 --> 00:12:49.600
principles.

00:12:49.600 --> 00:12:52.590
We try to keep everything
as simple as possible.

00:12:52.590 --> 00:12:56.530
We leverage the tools we have
in App Engine to death to

00:12:56.530 --> 00:12:59.100
launch a local environment.

00:12:59.100 --> 00:13:03.120
And, most of all, App Engine is
really a key component in

00:13:03.120 --> 00:13:04.970
achieving high quality.

00:13:04.970 --> 00:13:08.890
It basically handles
all the hard stuff.

00:13:08.890 --> 00:13:13.540
It also gives you a great
SDK with great

00:13:13.540 --> 00:13:16.240
documentation, nice tools.

00:13:16.240 --> 00:13:17.530
So that's pretty neat.

00:13:22.680 --> 00:13:25.710
You know, App Engine is a
very different platform.

00:13:25.710 --> 00:13:27.930
It has some particularities.

00:13:27.930 --> 00:13:32.410
It will generally scale and
perform well as long as your

00:13:32.410 --> 00:13:35.550
application doesn't prevent
it to do so.

00:13:35.550 --> 00:13:38.970
So we've learned over the past
two years some strategies and

00:13:38.970 --> 00:13:42.510
good practices that I'd like
to share with you today.

00:13:42.510 --> 00:13:49.640
These are not, by the way, the
absolute rules from God for

00:13:49.640 --> 00:13:52.910
implementing stuff on App
Engine, but it's coming from

00:13:52.910 --> 00:13:56.140
real games that are currently
on the market.

00:13:56.140 --> 00:13:57.490
It works well.

00:13:57.490 --> 00:14:00.660
So first of all, by building
your application on App

00:14:00.660 --> 00:14:03.530
Engine, you leverage a lot of
Google's own technology.

00:14:03.530 --> 00:14:09.070
And to make it work correctly
your application has to fit

00:14:09.070 --> 00:14:10.430
the Google philosophy.

00:14:10.430 --> 00:14:13.130
We call it the Googly
Will or Googly Way.

00:14:13.130 --> 00:14:15.680
Depends on the reference.

00:14:15.680 --> 00:14:18.400
The general goal with the Googly
way is to have a fast

00:14:18.400 --> 00:14:21.290
and small request.

00:14:21.290 --> 00:14:25.460
The idea is that the latency or
the response time is a good

00:14:25.460 --> 00:14:27.630
indicator of the amount
of resource you're

00:14:27.630 --> 00:14:29.190
using in your request.

00:14:29.190 --> 00:14:34.450
So higher response time usually
means higher cost.

00:14:34.450 --> 00:14:37.960
There are some tricks to improve
the response time on

00:14:37.960 --> 00:14:38.460
App Engine.

00:14:38.460 --> 00:14:41.690
I will cover them in the
next few sections.

00:14:41.690 --> 00:14:45.270
Your application has to be
designed also to run on the

00:14:45.270 --> 00:14:46.630
distributed environment.

00:14:46.630 --> 00:14:49.040
But this is really an
abstract concept.

00:14:49.040 --> 00:14:52.060
What does it mean exactly to
design an application to run

00:14:52.060 --> 00:14:54.880
on a distributed environment?

00:14:54.880 --> 00:15:02.410
Well, App Engine offers an API
that is an entry point to

00:15:02.410 --> 00:15:06.210
they're distributed
infrastructure.

00:15:06.210 --> 00:15:06.780
OK?

00:15:06.780 --> 00:15:10.140
An entry point to distribute
your data and your processes.

00:15:10.140 --> 00:15:11.810
So you have to use
them wisely.

00:15:11.810 --> 00:15:15.190
That's pretty much
it on App Engine.

00:15:15.190 --> 00:15:17.600
That's what it means to design
for a distributed

00:15:17.600 --> 00:15:19.000
environments.

00:15:19.000 --> 00:15:25.120
So I like the idea of having a
nice limited silo per user.

00:15:25.120 --> 00:15:27.780
A nice limited data and
processing silo.

00:15:27.780 --> 00:15:30.540
You keep every user as
independent as possible.

00:15:30.540 --> 00:15:37.300
So that way the App Engine
runtime will distribute them

00:15:37.300 --> 00:15:40.590
in their data centers.

00:15:40.590 --> 00:15:44.150
In practice, though, it's almost
impossible to have well

00:15:44.150 --> 00:15:45.960
isolated users.

00:15:45.960 --> 00:15:48.840
You have things like
games, for example.

00:15:48.840 --> 00:15:52.060
In a multi-player game a game
is shared between two users.

00:15:52.060 --> 00:15:56.330
So it's not a real contention
point, but you still have to

00:15:56.330 --> 00:15:58.970
handle the current currency.

00:15:58.970 --> 00:16:01.880
A more extreme contention
point would be

00:16:01.880 --> 00:16:03.370
a matchmaking queue.

00:16:03.370 --> 00:16:06.500
This is really tricky
to implement.

00:16:06.500 --> 00:16:09.830
It's a contention point because
everybody wants to

00:16:09.830 --> 00:16:15.000
enter this queue, so you have
to manage that with care.

00:16:15.000 --> 00:16:18.620
There are strategies to handle
contention points.

00:16:18.620 --> 00:16:23.220
We'll give you some in
the next slides.

00:16:26.060 --> 00:16:30.780
Something else we've learned
is that NoSQL is really

00:16:30.780 --> 00:16:32.270
different than SQL.

00:16:32.270 --> 00:16:39.080
We use a DataStore to store
pretty much all our data.

00:16:39.080 --> 00:16:42.680
The DataStore on App Engine
is a NoSQL [INAUDIBLE]

00:16:42.680 --> 00:16:45.250
persistence storage.

00:16:45.250 --> 00:16:46.450
It's all managed by Google.

00:16:46.450 --> 00:16:47.180
It's pretty cool.

00:16:47.180 --> 00:16:50.520
You don't have to worry
about charting or

00:16:50.520 --> 00:16:54.520
redundancies or backups.

00:16:54.520 --> 00:16:58.250
It may look similar to your
normal relational database,

00:16:58.250 --> 00:17:02.370
but there are fundamental
differences that requires a

00:17:02.370 --> 00:17:06.230
major shift in the way you
design your storage.

00:17:06.230 --> 00:17:11.410
One of the most common mistakes
that a new developer

00:17:11.410 --> 00:17:16.500
with NoSQL will do is to try
to normalize its data, just

00:17:16.500 --> 00:17:21.839
like it would do with
a normal SQL system.

00:17:21.839 --> 00:17:24.550
This is a mistake because on
App Engine with a DataStore

00:17:24.550 --> 00:17:26.710
you want to minimize the
number of operations.

00:17:26.710 --> 00:17:31.550
These operations are costly
and longer than in your

00:17:31.550 --> 00:17:37.750
typical SQL system, and you want
to handle them with care.

00:17:37.750 --> 00:17:43.180
So by denormalizing your data
structure, you can achieve

00:17:43.180 --> 00:17:45.890
some pretty good
optimizations.

00:17:45.890 --> 00:17:50.180
By denormalizing, I mean, to
regroup and even sometimes to

00:17:50.180 --> 00:17:53.490
duplicate your data.

00:17:53.490 --> 00:17:55.650
I'll give you an example.

00:17:55.650 --> 00:17:58.550
Let's take all the data that
is related to a player.

00:17:58.550 --> 00:18:01.940
You have its profile,
you have some stats,

00:18:01.940 --> 00:18:03.610
you have its purchases.

00:18:06.990 --> 00:18:12.080
In our game we regroup them, all
loose data, in one entity.

00:18:12.080 --> 00:18:13.690
It's called a player.

00:18:13.690 --> 00:18:19.420
So that way we can optimize a
lot the operations we do with

00:18:19.420 --> 00:18:20.770
the DataStore.

00:18:20.770 --> 00:18:23.880
You also have to adapt your data
model for the use cases.

00:18:23.880 --> 00:18:28.100
I'll show you some real world
use case later in this

00:18:28.100 --> 00:18:30.000
presentation.

00:18:30.000 --> 00:18:33.560
The way you access your data
is also quite different.

00:18:33.560 --> 00:18:34.740
You're limited.

00:18:34.740 --> 00:18:35.020
OK?

00:18:35.020 --> 00:18:38.650
For example, with queries you
can't do a joint operation.

00:18:38.650 --> 00:18:42.750
You can not do a query on
a non-index operation.

00:18:42.750 --> 00:18:44.485
It limits a lot what
you can do.

00:18:44.485 --> 00:18:47.580
You even have to modify your
data model sometimes to

00:18:47.580 --> 00:18:48.870
execute a query.

00:18:48.870 --> 00:18:51.240
So that's a hard constraint.

00:18:51.240 --> 00:18:56.100
But it's there for the ultimate
goal, to reach high

00:18:56.100 --> 00:19:00.480
scalability and high
reliability.

00:19:00.480 --> 00:19:05.140
Also, one of the most important
things, I think,

00:19:05.140 --> 00:19:08.710
about the DataStore is that
your developers must

00:19:08.710 --> 00:19:11.220
understand very well
how it works.

00:19:11.220 --> 00:19:13.100
OK?

00:19:13.100 --> 00:19:14.720
You must read about
the DataStre.

00:19:14.720 --> 00:19:18.900
You must understand everything
about the ancestors, the

00:19:18.900 --> 00:19:23.430
eventually consistent queries,
the hot tablet issues you can

00:19:23.430 --> 00:19:25.910
get that will compromise
your scalability.

00:19:25.910 --> 00:19:28.940
You have to understand all that
because the DataStore is

00:19:28.940 --> 00:19:31.800
going to be probably the most
used service in your

00:19:31.800 --> 00:19:35.410
application, and it will drive
by itself probably half of the

00:19:35.410 --> 00:19:39.120
cost of your running
instances.

00:19:45.540 --> 00:19:48.580
I was talking about the
great third parties.

00:19:48.580 --> 00:19:53.380
There are great third parties
to manipulate the DataStore.

00:19:53.380 --> 00:19:55.560
For Java it's called
Objectifier.

00:19:55.560 --> 00:19:57.170
For [INAUDIBLE]

00:19:57.170 --> 00:19:59.570
it's called NDB.

00:19:59.570 --> 00:20:03.830
Those are higher level APIs that
will handle stuff like

00:20:03.830 --> 00:20:06.900
object mapping, transaction
management,

00:20:06.900 --> 00:20:08.770
caching, auto retries.

00:20:08.770 --> 00:20:11.600
They are great, great tools.

00:20:11.600 --> 00:20:15.400
They will save you a lot
of lines of code.

00:20:15.400 --> 00:20:16.650
Let's go to this last box.

00:20:20.260 --> 00:20:21.440
Caching.

00:20:21.440 --> 00:20:27.750
Well, for the last few slides
I've talked a lot about how to

00:20:27.750 --> 00:20:32.220
lower the number for
operations you do.

00:20:32.220 --> 00:20:35.430
A good way to achieve
that is to avoid

00:20:35.430 --> 00:20:37.370
reaching the costly resources.

00:20:37.370 --> 00:20:40.650
And caching is a good
way to avoid that.

00:20:40.650 --> 00:20:41.890
OK?

00:20:41.890 --> 00:20:46.460
It will lower your cost at the
end if you use caching wisely.

00:20:46.460 --> 00:20:51.740
There are different techniques
to cache in different layers.

00:20:51.740 --> 00:20:54.010
First I'll talk about
in-memory caching.

00:20:54.010 --> 00:20:56.160
This is very limited because--

00:20:56.160 --> 00:20:59.980
keep in mind that you have
multiple instances running

00:20:59.980 --> 00:21:03.490
that host your applications.

00:21:03.490 --> 00:21:06.100
In-memory caching is
not distributed

00:21:06.100 --> 00:21:07.260
across these instances.

00:21:07.260 --> 00:21:08.510
So it's very limited.

00:21:10.780 --> 00:21:12.820
I'll give you an example
of what kind of

00:21:12.820 --> 00:21:14.520
caching we do in-memory.

00:21:14.520 --> 00:21:19.370
Let's say you have within your
application two components at

00:21:19.370 --> 00:21:21.187
different times during
a request that

00:21:21.187 --> 00:21:24.390
access a user profile.

00:21:24.390 --> 00:21:29.630
Usually because they're well
isolated and well encapsulated

00:21:29.630 --> 00:21:31.140
they don't talk to each other.

00:21:31.140 --> 00:21:35.460
So one component will fetch
the user profile once and,

00:21:35.460 --> 00:21:41.160
eventually, in your process, in
the same request, you fetch

00:21:41.160 --> 00:21:44.500
through the other components
the same user profile.

00:21:44.500 --> 00:21:46.050
So by adding a layer--

00:21:46.050 --> 00:21:48.440
an in-memory caching layer--

00:21:48.440 --> 00:21:54.220
you prevent paying the costs
for the second access.

00:21:54.220 --> 00:21:55.730
But you have to be careful.

00:21:55.730 --> 00:21:57.670
It's very limited.

00:21:57.670 --> 00:22:01.010
The ultimate caching tool in
App Engine is Memcache.

00:22:01.010 --> 00:22:08.200
Memcache is a low latency
distributed caching system.

00:22:08.200 --> 00:22:10.760
And best of all, it's
free on App Engine.

00:22:10.760 --> 00:22:12.470
It's totally free.

00:22:12.470 --> 00:22:14.360
But it doesn't mean you have
to cache everything.

00:22:14.360 --> 00:22:15.160
OK?

00:22:15.160 --> 00:22:18.220
You have to be careful because
the space is limited and you

00:22:18.220 --> 00:22:21.445
have to cache only the
most used resources.

00:22:24.280 --> 00:22:26.180
Things that we cache
and memcache.

00:22:26.180 --> 00:22:32.150
Well, pretty much all our
persistent data is cached.

00:22:32.150 --> 00:22:35.650
Let's say if we fetch your
list of friends from your

00:22:35.650 --> 00:22:37.590
favorite social network,
we cache

00:22:37.590 --> 00:22:41.120
this information usually.

00:22:41.120 --> 00:22:45.310
Another layer where you could
cache is by leveraging the

00:22:45.310 --> 00:22:48.690
edge cache on Google's
infrastructure.

00:22:48.690 --> 00:22:53.040
By using the proper HTTP cache
control header in your

00:22:53.040 --> 00:22:57.830
response, you can enable this
caching in the Google front

00:22:57.830 --> 00:22:59.290
end infrastructure.

00:22:59.290 --> 00:23:04.020
So that way your next request
will hit the cache instead of

00:23:04.020 --> 00:23:05.720
going to your application.

00:23:05.720 --> 00:23:09.240
So you save a lot of
reparations there.

00:23:09.240 --> 00:23:13.900
And finally, probably the most
effective place to cache is on

00:23:13.900 --> 00:23:14.710
the client side.

00:23:14.710 --> 00:23:17.930
This is not well implemented
in most of the games

00:23:17.930 --> 00:23:18.940
I've seen so far.

00:23:18.940 --> 00:23:20.530
But it's very efficient.

00:23:20.530 --> 00:23:25.010
When you do it correctly,
there are known and well

00:23:25.010 --> 00:23:30.420
defined HTTP caching mechanism
for client side caching with

00:23:30.420 --> 00:23:34.520
headers like If None Match
and If Modified Since.

00:23:34.520 --> 00:23:39.620
Those will greatly reduce your
operations on the server side.

00:23:43.410 --> 00:23:45.680
We've also adapted other
techniques to

00:23:45.680 --> 00:23:47.840
optimise our games.

00:23:52.550 --> 00:23:55.940
First we try to reduce our
instant start up time as much

00:23:55.940 --> 00:23:57.460
as possible.

00:23:57.460 --> 00:23:59.990
This is especially a problem
with Java application because

00:23:59.990 --> 00:24:02.740
the start up time is quite
hard than the Python

00:24:02.740 --> 00:24:04.730
applications.

00:24:04.730 --> 00:24:10.250
The idea is that App Engine will
allocate new instances

00:24:10.250 --> 00:24:12.050
when your traffic goes up.

00:24:12.050 --> 00:24:16.290
So if you take a long time to
start your instances, you

00:24:16.290 --> 00:24:19.020
prevent App Engine from scaling
automatically and

00:24:19.020 --> 00:24:20.050
efficiently.

00:24:20.050 --> 00:24:21.300
I'll give you an example.

00:24:24.050 --> 00:24:29.230
In one of our projects we had
a marketing campaign to send

00:24:29.230 --> 00:24:32.890
push notifications
to all our users.

00:24:32.890 --> 00:24:37.590
And within two minutes the
traffic jammed from the normal

00:24:37.590 --> 00:24:40.750
rate to 30 times the
normal rate.

00:24:40.750 --> 00:24:44.840
Something that would be almost
impossible to handle with a

00:24:44.840 --> 00:24:47.420
traditional system.

00:24:47.420 --> 00:24:51.390
Our application wasn't fully
optimized for a start up time

00:24:51.390 --> 00:24:55.740
and we had some issues,
user impacting

00:24:55.740 --> 00:24:56.980
issues, for a few minutes.

00:24:56.980 --> 00:25:01.100
But, eventually, App Engine
managed to ramp up

00:25:01.100 --> 00:25:03.660
efficiently.

00:25:03.660 --> 00:25:06.710
We also use Appstats
for profiling.

00:25:06.710 --> 00:25:07.980
Appstats is a nice tool.

00:25:07.980 --> 00:25:10.520
It is provided with their SDK.

00:25:10.520 --> 00:25:15.980
It will show you the resource
you use within your request.

00:25:15.980 --> 00:25:21.030
So it helps a lot if you want
to target your optimization.

00:25:21.030 --> 00:25:25.150
We use other techniques for
parallelism as well.

00:25:25.150 --> 00:25:27.720
All kind of parallelism like
just multi-threat.

00:25:27.720 --> 00:25:32.400
Sometimes you want to spawn a
new threat in your request and

00:25:32.400 --> 00:25:35.110
do some job in the background.

00:25:35.110 --> 00:25:38.180
We leverage the asynchronous
API for the

00:25:38.180 --> 00:25:40.860
DataStore and memcache.

00:25:40.860 --> 00:25:45.265
We also use the batch operations
for memcache and

00:25:45.265 --> 00:25:46.250
the DataStore.

00:25:46.250 --> 00:25:49.380
We use batch process
in our background

00:25:49.380 --> 00:25:50.660
task as much as possible.

00:25:50.660 --> 00:25:55.590
Those won't save you money,
they will just lower the

00:25:55.590 --> 00:25:56.840
response time, basically.

00:26:06.900 --> 00:26:12.150
In the next section I will cover
some typical feature we

00:26:12.150 --> 00:26:13.390
have in our game.

00:26:13.390 --> 00:26:15.990
Some typical feature,
not all of them.

00:26:15.990 --> 00:26:18.790
Games are pretty complex
these days.

00:26:18.790 --> 00:26:20.320
And I'll show you
how we implement

00:26:20.320 --> 00:26:23.570
them using App Engine.

00:26:23.570 --> 00:26:28.530
There may be other
implementation strategies,

00:26:28.530 --> 00:26:32.780
it's up to you to decide if they
are appropriate or not.

00:26:32.780 --> 00:26:33.010
OK.

00:26:33.010 --> 00:26:35.920
First, the easiest feature, your
profile and game state

00:26:35.920 --> 00:26:36.740
persistence.

00:26:36.740 --> 00:26:38.410
It looks pretty simple.

00:26:38.410 --> 00:26:40.940
You just called the DataStore
API, you store your

00:26:40.940 --> 00:26:42.470
data, and that's it.

00:26:42.470 --> 00:26:44.000
Problem solved.

00:26:44.000 --> 00:26:45.230
But not so fast.

00:26:45.230 --> 00:26:47.380
You have to be careful with
the design of your

00:26:47.380 --> 00:26:48.090
persistence.

00:26:48.090 --> 00:26:52.130
As I said, you have to
denormalize your data to

00:26:52.130 --> 00:26:55.250
optimize your operations
and lower your costs.

00:26:55.250 --> 00:27:00.060
And you have to design
the persistence by

00:27:00.060 --> 00:27:01.530
looking at the use case.

00:27:01.530 --> 00:27:03.630
Let's take the profile,
for example.

00:27:03.630 --> 00:27:05.860
Well profile is pretty simple.

00:27:05.860 --> 00:27:07.610
You have as much read
operations and write

00:27:07.610 --> 00:27:10.630
operations, there's nothing
special about it.

00:27:10.630 --> 00:27:12.520
But the game state
is different.

00:27:12.520 --> 00:27:15.860
In some of our games the game
state has a lot of read

00:27:15.860 --> 00:27:19.110
operations, and very few
write operations.

00:27:19.110 --> 00:27:20.420
The reason is pretty simple.

00:27:20.420 --> 00:27:24.880
We use, because we don't have a
dedicated channel to update

00:27:24.880 --> 00:27:28.320
the client on the game state,
we use polling mainly in the

00:27:28.320 --> 00:27:32.110
main screen of our games where
we see all the active games.

00:27:32.110 --> 00:27:36.080
We have polling requests coming
in every 10 seconds

00:27:36.080 --> 00:27:40.270
executing a query to have the
list of active games.

00:27:40.270 --> 00:27:44.500
So this is a lot of costly
read operations.

00:27:44.500 --> 00:27:47.960
You have to execute a
query plus a fetch

00:27:47.960 --> 00:27:50.410
for all your games.

00:27:50.410 --> 00:27:54.030
So we've adapted in some of our
games a technique called

00:27:54.030 --> 00:27:58.930
materialized views where you
basically store the result of

00:27:58.930 --> 00:28:02.110
a query concretely in
your DataStore.

00:28:02.110 --> 00:28:05.310
And you update this
table on every

00:28:05.310 --> 00:28:09.160
update on the game state.

00:28:09.160 --> 00:28:13.070
So what you end up having is
really an entity that contains

00:28:13.070 --> 00:28:16.220
the result that is expected
to display the

00:28:16.220 --> 00:28:17.140
list of active game.

00:28:17.140 --> 00:28:23.480
And it optimizes a lot the
number of operations required.

00:28:23.480 --> 00:28:26.960
Those two examples
are not really--

00:28:26.960 --> 00:28:29.670
doesn't represent really
a contention point.

00:28:29.670 --> 00:28:30.310
OK?

00:28:30.310 --> 00:28:34.100
There is no right contentions
with them, but you still have

00:28:34.100 --> 00:28:36.360
to manage the optimistic
currency

00:28:36.360 --> 00:28:38.080
nature of the DataStore.

00:28:38.080 --> 00:28:43.500
You have to retry even though
if you use Objectify or NDB

00:28:43.500 --> 00:28:44.985
they will handle that for
you automatically.

00:28:48.960 --> 00:28:50.250
Social connectivity.

00:28:50.250 --> 00:28:54.060
Well, pretty much all the games
these days have social

00:28:54.060 --> 00:28:55.400
integration.

00:28:55.400 --> 00:28:57.830
Everybody wants to play
against their friends.

00:28:57.830 --> 00:28:59.130
It's all cool.

00:28:59.130 --> 00:29:01.410
It's not that complex
to implement.

00:29:01.410 --> 00:29:05.850
We use the URL fetch service
and memcache

00:29:05.850 --> 00:29:09.640
to cache some resources.

00:29:09.640 --> 00:29:14.160
For example, a typical call to
your favorite social network

00:29:14.160 --> 00:29:16.760
will take maybe a few hundred
milliseconds.

00:29:16.760 --> 00:29:19.210
It has an impact on
the response time.

00:29:19.210 --> 00:29:22.210
It has an impact on the
user experience.

00:29:22.210 --> 00:29:23.600
It has an impact
on your costs.

00:29:23.600 --> 00:29:28.780
So we use memcache to
cache for x minutes.

00:29:28.780 --> 00:29:31.200
The list of threats,
for example.

00:29:31.200 --> 00:29:36.980
There is also a safety quota
on App Engine for URL fetch

00:29:36.980 --> 00:29:37.780
operations.

00:29:37.780 --> 00:29:40.010
There are quotas, by the way,
for pretty much all

00:29:40.010 --> 00:29:42.890
operations, but the first
one you will hit is

00:29:42.890 --> 00:29:45.670
probably the URL fetch.

00:29:45.670 --> 00:29:48.810
And memcache helps a lot with
that so you lower your number

00:29:48.810 --> 00:29:50.060
of fetch operations.

00:29:54.050 --> 00:29:56.710
Next feature, mobile
push notification.

00:29:56.710 --> 00:30:03.750
Mobile push notifications are
a complex beast to integrate

00:30:03.750 --> 00:30:05.915
in your application.

00:30:05.915 --> 00:30:09.780
Basically because there are a
lot of particularities with

00:30:09.780 --> 00:30:13.360
all the different mobile
platforms out there.

00:30:13.360 --> 00:30:20.320
It's not easy to implement and
there are-- you have to keep

00:30:20.320 --> 00:30:23.130
in mind that there are third
party services out there that

00:30:23.130 --> 00:30:27.450
offers a higher level, like a
kind of aggregated view that

00:30:27.450 --> 00:30:30.480
will help you a lot
implementing push

00:30:30.480 --> 00:30:31.900
notifications.

00:30:31.900 --> 00:30:35.560
Those third party services
are costly, though,

00:30:35.560 --> 00:30:36.750
so you have to choose.

00:30:36.750 --> 00:30:41.050
Either you pay the cost of
implementing, or the cost of

00:30:41.050 --> 00:30:43.300
using these third
party services.

00:30:43.300 --> 00:30:46.180
In our case, since we have
multiple games we've decided

00:30:46.180 --> 00:30:50.420
to connect directly to
the mobile platforms.

00:30:50.420 --> 00:30:53.180
We use background
tasks for that.

00:30:53.180 --> 00:30:55.770
This is a perfect example of
something you can do in

00:30:55.770 --> 00:30:56.420
background.

00:30:56.420 --> 00:31:02.750
You don't depend on the status
of these push notifications.

00:31:02.750 --> 00:31:06.450
And background task are really
good because they will retry

00:31:06.450 --> 00:31:10.430
automatically for you if they
are configured to do so.

00:31:10.430 --> 00:31:17.520
For Android and Amazon we use
the URL fetch service to do an

00:31:17.520 --> 00:31:20.980
HTTP call to their service.

00:31:20.980 --> 00:31:23.490
For iOS it's a different
story.

00:31:23.490 --> 00:31:28.630
OK? iOS use a custom protocol
on top of TCP and,

00:31:28.630 --> 00:31:31.710
unfortunately, currently
we have no support--

00:31:31.710 --> 00:31:32.910
no official support--

00:31:32.910 --> 00:31:36.840
for socket connection from
an App Engine instance.

00:31:36.840 --> 00:31:42.180
So we have in EA an in-house
system that will

00:31:42.180 --> 00:31:44.200
handle that for you.

00:31:44.200 --> 00:31:47.700
So our App Engine application
can [INAUDIBLE] through HTTP

00:31:47.700 --> 00:31:50.030
to this system that will
push notification

00:31:50.030 --> 00:31:52.790
on the socket protocol.

00:31:52.790 --> 00:31:57.310
We are testing the new
experimental socket support in

00:31:57.310 --> 00:32:01.060
App Engine and, currently,
it works pretty well.

00:32:01.060 --> 00:32:07.140
We plan to have our next
game using the socket

00:32:07.140 --> 00:32:10.240
implementation directly instead
of going through a

00:32:10.240 --> 00:32:11.490
different system.

00:32:14.350 --> 00:32:16.640
Client assets.

00:32:16.640 --> 00:32:19.820
There are graphics, there are
sounds, there are client

00:32:19.820 --> 00:32:24.230
configurations, all kinds of
resources that your client--

00:32:24.230 --> 00:32:28.260
mobile client-- needs
at start up.

00:32:28.260 --> 00:32:31.800
We usually serve them directly
from our App Engine

00:32:31.800 --> 00:32:32.950
application.

00:32:32.950 --> 00:32:36.590
There are different solutions
for that.

00:32:36.590 --> 00:32:38.570
You can use Google Cloud
Storage, which

00:32:38.570 --> 00:32:40.570
is a different system.

00:32:40.570 --> 00:32:43.880
It's not directly related to App
Engine, but you can access

00:32:43.880 --> 00:32:46.960
your data from App Engine.

00:32:46.960 --> 00:32:49.950
It's more appropriate
for bigger assets.

00:32:49.950 --> 00:32:54.520
It can handle pretty much
any size you want.

00:32:54.520 --> 00:32:58.140
Monitor solution would be to
package these assets directly

00:32:58.140 --> 00:32:59.540
in your App Engine
applications.

00:32:59.540 --> 00:33:03.880
You have to mark them as being
public in your descriptor

00:33:03.880 --> 00:33:07.110
file, so that way App Engine
will distribute them

00:33:07.110 --> 00:33:11.860
automatically to their content
delivery network.

00:33:11.860 --> 00:33:16.110
So you get an excellent
response time

00:33:16.110 --> 00:33:17.480
anywhere in the world.

00:33:20.860 --> 00:33:22.650
Matchmaking.

00:33:22.650 --> 00:33:24.080
This is a beast, really.

00:33:24.080 --> 00:33:26.670
It's not easy to implement
matchmaking.

00:33:26.670 --> 00:33:28.710
Matchmaking making is the
process of matching two or

00:33:28.710 --> 00:33:32.250
more random players together.

00:33:32.250 --> 00:33:35.140
It's the perfect contention
point.

00:33:35.140 --> 00:33:39.710
Everybody wants to write in
the matchmaking queue.

00:33:39.710 --> 00:33:42.730
We have different techniques
to implement that.

00:33:42.730 --> 00:33:46.930
First, the most used technique
we have is a component from

00:33:46.930 --> 00:33:51.340
our toolkit named the
matchmaking service that is

00:33:51.340 --> 00:33:53.610
implemented using memcache.

00:33:53.610 --> 00:33:57.580
You can use memcache as
a short lived storage.

00:33:57.580 --> 00:34:01.870
It's not reliable, but it
works well enough for

00:34:01.870 --> 00:34:03.940
matchmaking.

00:34:03.940 --> 00:34:07.760
Because it's not reliable, we
have a fallback mechanism that

00:34:07.760 --> 00:34:12.150
is less optimal, but
it still works.

00:34:12.150 --> 00:34:16.389
And we also have to implement
the [INAUDIBLE]

00:34:16.389 --> 00:34:20.060
system on memcache because even
though memcache is really

00:34:20.060 --> 00:34:22.520
fast, you still get some
contention issues as the

00:34:22.520 --> 00:34:25.320
traffic goes up.

00:34:25.320 --> 00:34:29.489
You can also use back end
instances on App Engine to

00:34:29.489 --> 00:34:32.540
implement the matchmaking
queue.

00:34:32.540 --> 00:34:39.570
Back end instances are a kind
of instance that is stateful

00:34:39.570 --> 00:34:41.739
and long lived.

00:34:41.739 --> 00:34:45.639
The problem, though, is that
they're not auto scaling, so

00:34:45.639 --> 00:34:48.290
you have to manage
them by yourself.

00:34:48.290 --> 00:34:51.560
But it's a very good place to
store the matchmaking queue

00:34:51.560 --> 00:34:52.810
directly in memory.

00:34:55.449 --> 00:34:58.590
There could be a third solution
for-- if you don't

00:34:58.590 --> 00:35:02.530
plan for success, you could
store directly to matchmaking

00:35:02.530 --> 00:35:03.820
queue in the DataStore.

00:35:03.820 --> 00:35:06.710
But the contention is really an
issue with the DataStore.

00:35:06.710 --> 00:35:08.830
You have--

00:35:08.830 --> 00:35:14.360
you can probably write on a
given DataStore entity maybe

00:35:14.360 --> 00:35:16.460
twice per second.

00:35:16.460 --> 00:35:17.960
It's really an issue.

00:35:17.960 --> 00:35:21.115
But if you don't plan for
success you could do it.

00:35:21.115 --> 00:35:24.370
It works well.

00:35:24.370 --> 00:35:26.960
Microtransaction validation.

00:35:26.960 --> 00:35:30.470
It's a standard feature now in
most of the mobile games.

00:35:30.470 --> 00:35:32.710
In-app billing is a reality.

00:35:32.710 --> 00:35:34.930
We have to implement it.

00:35:34.930 --> 00:35:38.040
The game server is the authority
for everything

00:35:38.040 --> 00:35:39.290
related to transactions.

00:35:42.030 --> 00:35:45.130
For security reasons we have
to validate they receipt on

00:35:45.130 --> 00:35:48.090
the server side before
we apply the

00:35:48.090 --> 00:35:50.390
result to the user profile.

00:35:50.390 --> 00:35:55.260
There are tons and tons of
hacked requests coming from,

00:35:55.260 --> 00:36:02.220
for example, jail breaking
iOS device.

00:36:02.220 --> 00:36:06.840
For Android, it's only a
matter of evaluating a

00:36:06.840 --> 00:36:09.240
signature using a certificate.

00:36:09.240 --> 00:36:12.210
So it's all done directly
in the instance.

00:36:12.210 --> 00:36:16.650
For Amazon and Apple you have
to do an HTTP call to their

00:36:16.650 --> 00:36:19.160
system to validate
the transaction,

00:36:19.160 --> 00:36:20.410
validate the receipt.

00:36:22.760 --> 00:36:24.650
And last feature.

00:36:24.650 --> 00:36:27.420
This is not directly related to
your game play, but it's an

00:36:27.420 --> 00:36:31.140
important tool to optimize your
game balance, to optimize

00:36:31.140 --> 00:36:34.300
your retention, optimize
your profitability.

00:36:34.300 --> 00:36:36.910
It's business intelligence.

00:36:36.910 --> 00:36:39.180
You need metrics to know what's

00:36:39.180 --> 00:36:43.110
going on in your server.

00:36:43.110 --> 00:36:47.090
Your analyst will basically need
a broad range of data to

00:36:47.090 --> 00:36:51.600
do extraction and do aggregation
and extraction to

00:36:51.600 --> 00:36:52.850
have the meaningful numbers.

00:36:55.490 --> 00:36:59.400
We have, for example, a matrix
for the average number of

00:36:59.400 --> 00:37:05.350
games per player, the sales
number per region.

00:37:05.350 --> 00:37:08.180
These are valid matrix.

00:37:08.180 --> 00:37:12.170
We have two strategies for
those matrix, currently.

00:37:12.170 --> 00:37:16.560
First is to execute a MapReduce
directly in the App

00:37:16.560 --> 00:37:18.230
Engine application.

00:37:18.230 --> 00:37:19.470
This is not optimal.

00:37:19.470 --> 00:37:22.640
It is limited because it
requires a code change every

00:37:22.640 --> 00:37:24.340
time you want to extract
a new metric.

00:37:24.340 --> 00:37:26.630
It's not really useful.

00:37:26.630 --> 00:37:30.450
We are testing a new solution
to [? dam ?]

00:37:30.450 --> 00:37:35.510
the data, the meaningful
evidence on BigQuery and give

00:37:35.510 --> 00:37:38.440
our analysts access to the
BigQuery environments so they

00:37:38.440 --> 00:37:41.270
can extract pretty much
anything they like.

00:37:46.610 --> 00:37:51.160
So let's now introduce a
major buzz word in this

00:37:51.160 --> 00:37:52.050
presentation.

00:37:52.050 --> 00:37:53.230
Let's talk about DevOps.

00:37:53.230 --> 00:37:57.450
Everybody wants to talk about
DevOps these days.

00:37:57.450 --> 00:37:59.620
So let's get back to the
initial scenario.

00:37:59.620 --> 00:38:02.490
You're a small company, you've
developed your game, it's

00:38:02.490 --> 00:38:05.490
going to be amazing.

00:38:05.490 --> 00:38:08.850
The server has been implemented
on App Engine this

00:38:08.850 --> 00:38:10.440
time, so it's better.

00:38:10.440 --> 00:38:11.565
Your game is bug free.

00:38:11.565 --> 00:38:14.900
It's been load tested up to
gazillions of players.

00:38:14.900 --> 00:38:16.340
It works well.

00:38:16.340 --> 00:38:17.670
But there is still
something missing

00:38:17.670 --> 00:38:20.060
before launching a game.

00:38:20.060 --> 00:38:21.485
What's going to be your
support model?

00:38:24.020 --> 00:38:28.800
The good news is Google site
reliability engineers monitor

00:38:28.800 --> 00:38:30.180
the platform for you.

00:38:30.180 --> 00:38:35.710
So most of the platform
is monitored by Google

00:38:35.710 --> 00:38:36.470
themselves.

00:38:36.470 --> 00:38:39.140
All you have to monitor is
really the interaction in your

00:38:39.140 --> 00:38:42.460
thin layer that is
your application.

00:38:42.460 --> 00:38:44.970
Your application is really just
a thin layer on top of

00:38:44.970 --> 00:38:45.520
the platform.

00:38:45.520 --> 00:38:47.710
A thin, stateless layer.

00:38:47.710 --> 00:38:51.520
So what could go wrong
with this layer?

00:38:51.520 --> 00:38:54.640
Well, things can go wrong
in this layer sometimes.

00:38:54.640 --> 00:38:58.350
So, in this context, where
Google monitors the system for

00:38:58.350 --> 00:39:03.350
you, does it still make sense to
use a standard multi-tiered

00:39:03.350 --> 00:39:06.030
support model?

00:39:06.030 --> 00:39:08.250
In our team we don't think so.

00:39:08.250 --> 00:39:13.530
We're in transition to adapt
a full DevOp model.

00:39:13.530 --> 00:39:16.380
And there are few reasons
for that.

00:39:16.380 --> 00:39:21.550
First, their support team
is kind of redundant.

00:39:21.550 --> 00:39:26.580
Let's take a typical scenario
where the system fails.

00:39:26.580 --> 00:39:30.920
Their support team currently see
that there's an issue with

00:39:30.920 --> 00:39:32.140
the system.

00:39:32.140 --> 00:39:36.720
There are some metrics that are
wrong, so there is nothing

00:39:36.720 --> 00:39:37.630
they can do, basically.

00:39:37.630 --> 00:39:40.710
They can not reboot the servers,
they cannot execute a

00:39:40.710 --> 00:39:42.390
job on the database.

00:39:42.390 --> 00:39:46.320
So every time they end up
calling us and asking us,

00:39:46.320 --> 00:39:48.620
what's going on, what
can we do with that.

00:39:48.620 --> 00:39:51.390
On our side, most of
the time there's

00:39:51.390 --> 00:39:53.290
nothing we can do either.

00:39:53.290 --> 00:39:57.310
We look at the Google App Engine
status page, we see

00:39:57.310 --> 00:40:00.190
there is an issue currently with
the platform, Google is

00:40:00.190 --> 00:40:02.230
already working on it.

00:40:02.230 --> 00:40:03.310
There's not much we can do.

00:40:03.310 --> 00:40:05.300
We wait.

00:40:05.300 --> 00:40:07.850
Often, in a matter of minutes,
it's resolved

00:40:07.850 --> 00:40:10.850
and everybody's happy.

00:40:10.850 --> 00:40:13.370
That was a pretty cool picture
that one of our managers took

00:40:13.370 --> 00:40:16.840
during one of our down time
where we were sitting on

00:40:16.840 --> 00:40:21.520
couches playing NHL 2013 while
the server was down, and

00:40:21.520 --> 00:40:23.440
everybody was like, what
are they doing?

00:40:23.440 --> 00:40:24.540
The server is down currently.

00:40:24.540 --> 00:40:26.380
But there's nothing we can do.

00:40:26.380 --> 00:40:27.320
Google's working on it.

00:40:27.320 --> 00:40:28.570
No problem.

00:40:32.760 --> 00:40:36.570
Another reason why we will adapt
the DevOp model is we

00:40:36.570 --> 00:40:40.130
are already pretty much
responsible for all the

00:40:40.130 --> 00:40:42.600
operation steps.

00:40:42.600 --> 00:40:44.820
We deploy our application
ourselves.

00:40:44.820 --> 00:40:49.350
We manage our application,
our App Engine

00:40:49.350 --> 00:40:51.290
environments ourselves.

00:40:51.290 --> 00:40:54.670
We handle pretty much every
aspect of operations.

00:40:54.670 --> 00:40:56.710
We have short development
cycles.

00:40:56.710 --> 00:41:02.430
We deploy every week, so we're
very close to have a real

00:41:02.430 --> 00:41:03.510
DevOp model.

00:41:03.510 --> 00:41:09.560
The only thing that is shaky
is the support from the

00:41:09.560 --> 00:41:12.810
support team that we
want to remove.

00:41:12.810 --> 00:41:15.040
And if there's an [INAUDIBLE]

00:41:15.040 --> 00:41:18.770
to do, only us, the developer,
can do it.

00:41:18.770 --> 00:41:23.400
Because your system is really
your code with App Engine.

00:41:23.400 --> 00:41:27.460
So on the developer understands
well the dynamics

00:41:27.460 --> 00:41:30.280
of the code and can
fix the problem.

00:41:30.280 --> 00:41:32.950
So you need your developer
anyway.

00:41:32.950 --> 00:41:36.560
The only thing missing with
App Engine is a proper

00:41:36.560 --> 00:41:39.700
monitoring tool for your
application layer.

00:41:39.700 --> 00:41:42.230
OK?

00:41:42.230 --> 00:41:45.500
They don't prevent you from
developing your own system,

00:41:45.500 --> 00:41:49.400
and that's what we've
done at EA.

00:41:49.400 --> 00:41:53.510
We have basic metric
libraries that we

00:41:53.510 --> 00:41:56.690
use to increase counters.

00:41:56.690 --> 00:42:01.700
Those counters get transferred
periodically to a third party

00:42:01.700 --> 00:42:06.650
monitoring system where we can
set thresholds and alarms.

00:42:06.650 --> 00:42:10.650
And we get notified when
something is wrong.

00:42:10.650 --> 00:42:13.260
So that's supposed to
be in production.

00:42:13.260 --> 00:42:16.500
We're still using the Legacy
support model, but we're

00:42:16.500 --> 00:42:17.750
moving to this system.

00:42:22.830 --> 00:42:26.190
Well, that's pretty
much it, already.

00:42:26.190 --> 00:42:30.340
Well, to summarize this
presentation, we're really

00:42:30.340 --> 00:42:34.500
pleased with App Engine in
our game development.

00:42:34.500 --> 00:42:38.500
It's been really
a great story.

00:42:38.500 --> 00:42:40.420
We've been using it
for two years now.

00:42:40.420 --> 00:42:42.110
We've learned a lot.

00:42:42.110 --> 00:42:44.970
I think we achieved good
qualities with our systems

00:42:44.970 --> 00:42:46.220
because of App Engine.

00:42:49.600 --> 00:42:52.680
When it's been released, like
four years ago, App Engine, in

00:42:52.680 --> 00:42:54.830
my opinion, was a
game changer.

00:42:54.830 --> 00:42:59.340
It was really a right step
in the right direction.

00:42:59.340 --> 00:43:04.010
It enables you to focus your
work on your game.

00:43:04.010 --> 00:43:05.460
We are game developers.

00:43:05.460 --> 00:43:07.780
We are not specialists--

00:43:07.780 --> 00:43:09.610
infrastructure specialists--

00:43:09.610 --> 00:43:13.520
so you can focus on
what you do best.

00:43:13.520 --> 00:43:15.370
So it's a great system.

00:43:15.370 --> 00:43:18.736
I recommend, really, everybody
to use it.

00:43:18.736 --> 00:43:19.340
Thank you.

00:43:19.340 --> 00:43:20.600
Do you have any questions?

00:43:20.600 --> 00:43:32.054
[APPLAUSE]

00:43:32.054 --> 00:43:32.552
AUDIENCE: Hi.

00:43:32.552 --> 00:43:33.470
YANICK BELANGER: Hi.

00:43:33.470 --> 00:43:34.630
AUDIENCE: One quick question.

00:43:34.630 --> 00:43:38.070
Why did you choose to use Java
to do all of your App Engine

00:43:38.070 --> 00:43:41.405
programming as opposed to one
of the other languages?

00:43:41.405 --> 00:43:43.070
YANICK BELANGER: That's an
interesting question.

00:43:43.070 --> 00:43:50.830
Well, we had good Java
developers in our team.

00:43:50.830 --> 00:43:54.780
Nobody knew Python
really well.

00:43:54.780 --> 00:43:57.660
Go was a new language.

00:43:57.660 --> 00:44:01.270
It would have been cool to use
Go but we decided to go with

00:44:01.270 --> 00:44:04.370
Java because everybody knew
Java pretty well.

00:44:04.370 --> 00:44:07.500
Actually, besides start up--

00:44:07.500 --> 00:44:10.710
the increased start up time
on App Engine, Java

00:44:10.710 --> 00:44:11.960
works pretty well.

00:44:17.620 --> 00:44:19.660
Other questions?

00:44:19.660 --> 00:44:21.350
Well, that's it.

00:44:21.350 --> 00:44:22.600
Thank you, guys.

