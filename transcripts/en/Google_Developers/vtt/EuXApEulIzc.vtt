WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.479
&gt;&gt; HEARDEN: We're now going to talk about
the Wave Editor and how it works, and in particular,

00:00:06.479 --> 00:00:16.760
how to extend it with its extension mechanisms.
And we're joined over VC by our glowing sphere

00:00:16.760 --> 00:00:23.449
of genius, Dan Danilatos, who wrote the editor.
So any difficult questions, I'm just going

00:00:23.449 --> 00:00:32.500
to field off to him. So, just to give some
context by Wave editor, we mean the rich text

00:00:32.500 --> 00:00:38.360
editor that runs in the browser and that sits
on top of the operational transform layer

00:00:38.360 --> 00:00:47.550
that Wave provides. So, it's about editing
content using operations to describe the content,

00:00:47.550 --> 00:00:52.760
applying operations that come in, and all
these operations are then just handled by

00:00:52.760 --> 00:01:02.470
Wave and the network. So, in order to understand
why the editor is structured the way it is,

00:01:02.470 --> 00:01:08.870
it's important to understand the goals that
were set out when writing the editor, and

00:01:08.870 --> 00:01:14.540
this is probably the most concise description
that we can have which is it's a toolkit for

00:01:14.540 --> 00:01:24.000
rich, extensible, real-time, collaborative
editing. So rich, as in rich text; it's extensible

00:01:24.000 --> 00:01:29.350
in that you can add loads of programmatic
extensions to it; it's real-time, so it's

00:01:29.350 --> 00:01:35.030
fast, it's live; and it's collaborative, which
means it operates on a distributed document

00:01:35.030 --> 00:01:41.230
model. Now, you make local mutations; they
get sent out, incoming operations from a server

00:01:41.230 --> 00:01:50.640
can come in and apply. So it enables having
a rich document model that is kept semantically

00:01:50.640 --> 00:01:57.310
clean. The rendering is a completely separate
concern. The document model is separate, which

00:01:57.310 --> 00:02:05.810
means it can be designed using a structure
that performs well under transform. And by

00:02:05.810 --> 00:02:11.840
keeping the rendering separate, it means that
we can use proper semantic HTML. We can use

00:02:11.840 --> 00:02:19.040
HTML the way it was meant to be used with
paragraphs, line breaks, list elements; all

00:02:19.040 --> 00:02:28.810
the proper semantic mark up. The core parts
of the editor help abstract away browser quirks

00:02:28.810 --> 00:02:35.810
as well. It gives a consistent API for adding
in editing behavior and there's an API for

00:02:35.810 --> 00:02:42.310
building extensions to the editor, and these
extensions, we call "doodads". And the reason

00:02:42.310 --> 00:02:46.900
that they're called doodads is because widgets
and gadgets are both names that were already

00:02:46.900 --> 00:02:54.990
taken. So, when we say the editor, it's not
a completely clear definition of what that

00:02:54.990 --> 00:03:01.819
is because it's an open, extensible system.
But usually, what we mean is the core framework

00:03:01.819 --> 00:03:11.230
of the editor and the Wave of document model
underneath it, as well as a bunch of sort

00:03:11.230 --> 00:03:18.989
of standard default features that are installed
like paragraphs, bullets, styling, maybe some

00:03:18.989 --> 00:03:27.099
other doodads like image thumbnails and maybe
gadgets; but it's an open-ended set of features.

00:03:27.099 --> 00:03:33.430
So, it's not--when we say the editor, it's
not a clear cut definition of everything that

00:03:33.430 --> 00:03:40.660
encompasses. But yeah, the design goal is
that you can add in lots of extra features

00:03:40.660 --> 00:03:49.050
and these features operate at the same level
as most of the core features in the editor.

00:03:49.050 --> 00:03:54.739
So the first question that you need to address
when you're building an editor in a browser

00:03:54.739 --> 00:04:00.870
is how much to use the browser's native support
for editing, which is called contentEditable.

00:04:00.870 --> 00:04:06.910
And some web editors entirely let the browser
do everything, for example, the closure editor

00:04:06.910 --> 00:04:13.330
that's used in Gmail. It's all based on contentEditable
so everything you type, the browser is doing

00:04:13.330 --> 00:04:21.709
all the editing and updating the DOM natively.
Other web editors like Bespin, which is the

00:04:21.709 --> 00:04:26.120
Mozilla editor, everything's handled programmatically,
so everything you type, it is JavaScript code

00:04:26.120 --> 00:04:34.319
that's executing and updating the DOM. So
in Wave, the editor, it tries to strike a

00:04:34.319 --> 00:04:38.979
balance between the speed and convenience
of letting the browser do its thing, but as

00:04:38.979 --> 00:04:46.409
well as the application flexibility of handling
everything ourselves. So we try and leverage

00:04:46.409 --> 00:04:52.300
what the browser does well. So fast typing,
selection support, moving the current around,

00:04:52.300 --> 00:04:59.639
cut and paste, IMEs; these kinds of things,
we let contentEditable do its thing, but for

00:04:59.639 --> 00:05:03.949
many other things, we handle them all programmatically.
So the editor is designed so that you can

00:05:03.949 --> 00:05:07.749
strike a balance, you can do whatever you
want to do manually, or you can let the browser

00:05:07.749 --> 00:05:18.409
do whatever you want by default. So it's kind
of content editable on a very tight leash.

00:05:18.409 --> 00:05:23.909
So the bulk of this talk is now going to talk
about rendering the document model. So even

00:05:23.909 --> 00:05:31.460
though this isn't really part of editing,
it's a core part of interacting with the editor.

00:05:31.460 --> 00:05:37.310
So by rendering the document model, we mean
in Wave, the document model is this clean

00:05:37.310 --> 00:05:43.939
semantic model, doesn't know anything about
HTML. It's just a representation of the document

00:05:43.939 --> 00:05:49.400
and uses line elements to separate lines.
There's text, it's all wrapped in the body

00:05:49.400 --> 00:05:59.289
element, and it's all very simple structure
and we use the XML part of the document for

00:05:59.289 --> 00:06:04.569
structure like text and lines. But for stylistic
things, we don't use structural elements;

00:06:04.569 --> 00:06:10.960
instead, we use annotations and you might
recall from other talks how annotations work.

00:06:10.960 --> 00:06:19.509
We'll see some more annotations later in this
talk. So an example of this separation between

00:06:19.509 --> 00:06:25.699
the logical model and the rendering comes
up when we try and extend the editor, for

00:06:25.699 --> 00:06:30.830
example, with an image thumbnail. So here
is an example of an image thumbnail that we

00:06:30.830 --> 00:06:37.270
might want to embed in the editor content.
And in choosing a logical representation for

00:06:37.270 --> 00:06:42.550
the data in this model, we're free to choose
whatever representation we want. So in this

00:06:42.550 --> 00:06:48.809
case, we represent everything structurally.
There's an image element with an attachment

00:06:48.809 --> 00:06:54.639
attribute that will identify some image. Within
that image element is a caption element that

00:06:54.639 --> 00:06:59.319
contains some caption text, but we're not
constrained to use something that will work

00:06:59.319 --> 00:07:08.229
with HTML; we can use whatever data model
we want. And this simple, clean, logical model

00:07:08.229 --> 00:07:15.689
then renders to some disgusting HTML, because
HTML is not at all designed for arbitrary

00:07:15.689 --> 00:07:22.879
layout and drawing. So instead of having an
editor operate on HTML, which would mean logical

00:07:22.879 --> 00:07:27.449
content looking like something on the right
which is ugly, the logical content is kept

00:07:27.449 --> 00:07:35.939
clean and there's a whole rendering system
within the editor to render to arbitrary HTML.

00:07:35.939 --> 00:07:42.490
So this correspondence between the logical
model and the rendering model is done by using

00:07:42.490 --> 00:07:48.021
references between two trees. So, on the left,
we have a picture of what the logical content

00:07:48.021 --> 00:07:52.929
might look like. In this case, just an image
element that contains one child, which is

00:07:52.929 --> 00:07:58.009
a caption, the image element has an attribute
on it. On the right, its corresponding HTML

00:07:58.009 --> 00:08:04.249
which is the big, heavyweight tree of elements
and the correspondence between these two trees

00:08:04.249 --> 00:08:11.349
is kept with references from--bidirectional
references between various nodes in the tree.

00:08:11.349 --> 00:08:15.449
So in this case, the image element maps to
some top level div and the caption element

00:08:15.449 --> 00:08:27.310
maps to where it appears in the rendering.
So there's two main flows within the editor

00:08:27.310 --> 00:08:31.400
just like, if you remember from the talk yesterday
about the Wave panel, there's two main control

00:08:31.400 --> 00:08:37.990
flows which is when--sorry, two main data
flows from when data goes in the model into

00:08:37.990 --> 00:08:43.150
the display and from when events happen in
the display, mapping them back to changes

00:08:43.150 --> 00:08:49.470
in the model. And these flows are called rendering
and UI handling. If you look in the code,

00:08:49.470 --> 00:08:55.330
the rendering is all done through a type called
node mutation handler. So anything that does

00:08:55.330 --> 00:09:01.520
rendering, they're all node mutation handlers
and handling display events are done by what

00:09:01.520 --> 00:09:10.010
are called node event handlers. So now we're
going to talk about the rendering flow. So

00:09:10.010 --> 00:09:15.610
in that caption example, that was a fairly
simple mapping. And by simple, it means that

00:09:15.610 --> 00:09:19.820
ancestral relationships are preserved. There
was a cap--there was an image element that

00:09:19.820 --> 00:09:26.240
had a caption child in the corresponding HTML.
The rendering of the image was still an ancestor

00:09:26.240 --> 00:09:32.250
of the rendering of the caption. The editor
permits more complicated mappings that don't

00:09:32.250 --> 00:09:38.960
need to preserve that kind of simple relationship,
so one of the key examples is how we render

00:09:38.960 --> 00:09:47.450
lines. So in the logical document, a line
is encoded as a line element followed by some

00:09:47.450 --> 00:09:54.090
text, and then when we render that to HTML,
we want to use proper HTML mark up, so it's

00:09:54.090 --> 00:10:03.330
text wrapped as a paragraph element. So how
on earth we do these more complicated mappings?

00:10:03.330 --> 00:10:07.510
And in order to explain this in a bit more
detail, I'm going to introduce the concept

00:10:07.510 --> 00:10:15.960
of local nodes, and local nodes are parts
of the logical document that are not considered

00:10:15.960 --> 00:10:22.970
part of the persistent content. Local nodes
will only show up on--in the client that creates

00:10:22.970 --> 00:10:28.110
them; they're not transmitted to the server.
It's just an extra overlay of extra information

00:10:28.110 --> 00:10:34.840
within the structure of the document. So they
take up zero size, incoming operations that

00:10:34.840 --> 00:10:40.660
touch the document just know how to apply
around these local bits of state. If you're

00:10:40.660 --> 00:10:45.150
interested in the code that does it, there's
a classical persistent content and that contains

00:10:45.150 --> 00:10:49.990
all the details of how to resolve conflicts
like server operations applying in places

00:10:49.990 --> 00:10:57.140
where local nodes currently are. But these
local nodes of just some local overlaid state

00:10:57.140 --> 00:11:04.050
is a key mechanism that's used in the editor
for doing rendering. So back to this example

00:11:04.050 --> 00:11:12.010
of how do we render lines. The trick is to
apply some local nodes to the content to transform

00:11:12.010 --> 00:11:17.150
it into an intermediate representation which
is more suitable for rendering. So in this

00:11:17.150 --> 00:11:23.910
case, any text that follows a line element,
we take that entire chunk of text and wrap

00:11:23.910 --> 00:11:31.030
it in a local node and you can identify local
nodes because they all start with "l:." And

00:11:31.030 --> 00:11:35.290
once these local nodes are in place, it's
a much simpler mapping to map this to the

00:11:35.290 --> 00:11:45.630
rendered HTML. So this end to end mapping--sorry,
that will come up on the next slide. So these

00:11:45.630 --> 00:11:53.110
local nodes, you know, one of their main uses
is for an intermediate representation to assist

00:11:53.110 --> 00:11:58.830
with rendering, but they can really be used
for anything. Arbitrary features that you

00:11:58.830 --> 00:12:04.780
install in the editor can put in their own
local nodes wherever they want for, you know,

00:12:04.780 --> 00:12:15.340
local bookkeeping specific to your feature.
So how is this local overlay of state, how

00:12:15.340 --> 00:12:22.560
is this exposed? The document model supports
different views. And two of the main views

00:12:22.560 --> 00:12:31.260
it exposes are the persistent view which exposes
just the content that is persisted on the

00:12:31.260 --> 00:12:35.660
server, so just the content that is shared
with everyone else. There's the full view

00:12:35.660 --> 00:12:41.400
which extends the state with all the local
nodes. There are some other views as well,

00:12:41.400 --> 00:12:47.000
but they're not important for this talk. But
the key thing to take away is that the document

00:12:47.000 --> 00:12:52.010
model is a view--based model where all these
different views are all overlaid on the same

00:12:52.010 --> 00:13:01.980
state. So this diagram shows you the control
flow of what happens through this intermediate

00:13:01.980 --> 00:13:07.930
representation. So on the left, there's the
persistent model and when line elements show

00:13:07.930 --> 00:13:16.200
up in this persistent model, the corresponding
event handler for the line elements gets notified

00:13:16.200 --> 00:13:21.500
of them. They--it wraps the blocks of text
that follow the line elements, wraps them

00:13:21.500 --> 00:13:26.850
in these local paragraphs nodes. When these
local paragraph nodes show up, the renderer

00:13:26.850 --> 00:13:33.270
for those nodes observes them and figures
out how to update the display with HTML that

00:13:33.270 --> 00:13:37.340
will look like a paragraph. So these renderers
are kind of chained together through this

00:13:37.340 --> 00:13:44.940
data flow. And the next thing I'm going to
talk about is annotations and how annotations

00:13:44.940 --> 00:13:51.779
are rendered. So you might recall that annotations
are not structural parts of the document.

00:13:51.779 --> 00:13:59.240
It's a separate data structure that sits alongside
the document. And the abstraction is that

00:13:59.240 --> 00:14:04.650
for every item in the document, an item being
a character or an element style on one end,

00:14:04.650 --> 00:14:11.930
for every item, there's a map of key value
pairs. So in this case, we have two ranges

00:14:11.930 --> 00:14:23.420
of annotations that overlap. So annotations,
you know, can freely overlap and this makes

00:14:23.420 --> 00:14:28.900
it not trivial to paint them because HTML
doesn't have any first class support for this

00:14:28.900 --> 00:14:40.910
kind of abstraction. So, because annotations
are usually used for sort of more decorative

00:14:40.910 --> 00:14:47.430
mark up, like style or just some extra metadata,
it's not always essential that every client

00:14:47.430 --> 00:14:52.730
has to paint them and it's usually quite fine
for the clients to ignore annotations that

00:14:52.730 --> 00:15:00.670
they don't know how to render, because most
of the key content is in the structure. So

00:15:00.670 --> 00:15:07.190
in Google Wave and Wave in a Box, the kinds
of things that we use annotations for, we

00:15:07.190 --> 00:15:13.080
use them for tracking cursor positions and
selection as you see multiple people editing

00:15:13.080 --> 00:15:18.940
a document and you see their name next to
some location, that's done using annotations.

00:15:18.940 --> 00:15:22.740
Links and spelling corrections, those are
done through annotations. Diff highlighting

00:15:22.740 --> 00:15:32.210
looks so--they are used fairly extensively.
So because HTML has no abstraction that corresponds

00:15:32.210 --> 00:15:40.020
in any way to these annotations that describe
or that apply it to items in the document,

00:15:40.020 --> 00:15:44.880
it's not immediately obvious how to render
them. But the trick that we use is to use

00:15:44.880 --> 00:15:54.050
these local nodes again as an intermediate
representation. So on this slide, you can

00:15:54.050 --> 00:16:01.529
see an example logical model on the left,
and I should point out it's a slightly old

00:16:01.529 --> 00:16:08.780
slide. You'll see Ps in there but we don't
have Ps in our logical model. Imagine that

00:16:08.780 --> 00:16:14.070
they are the...and you can see a bunch of
annotations on them. So there's an annotation

00:16:14.070 --> 00:16:21.860
on the misspelling of "haev." On the "this,"
there's a link annotation. And the design

00:16:21.860 --> 00:16:26.740
rendering that we want, the way we want to
show it up in HTML is pictured on the right

00:16:26.740 --> 00:16:32.330
where the misspelling has a red underline
on it, and at the right hand boundary of it,

00:16:32.330 --> 00:16:39.610
there's a drop down there to correct it. So
how do we get there? And the trick is there's

00:16:39.610 --> 00:16:46.190
a classical annotation painter. And what the
annotation painter does is it identifies spreads

00:16:46.190 --> 00:16:54.000
and boundaries of regions of the document
that have--that share the same set of annotations.

00:16:54.000 --> 00:17:00.350
So in those contiguous regions, it wraps them
and spreads and puts in boundary nodes that

00:17:00.350 --> 00:17:10.369
indicate boundaries. So in this example, the
text H-A-E-V that was annotated as a misspelling,

00:17:10.369 --> 00:17:18.579
the annotation painter has wrapped this with
a local node to identify it as a spread, and

00:17:18.579 --> 00:17:22.949
it's put a boundary node after that identifies
that there was a change in the annotation

00:17:22.949 --> 00:17:29.610
value there. So once all these decorating
local nodes are in place, you can see that

00:17:29.610 --> 00:17:37.490
mapping these representation of spreads and
boundaries, mapping this to HTML that looks

00:17:37.490 --> 00:17:41.080
like--that will give the rendering we want,
this is much more straightforward now that

00:17:41.080 --> 00:17:51.100
we have this intermediate state.
So along with local nodes, there's the equivalent

00:17:51.100 --> 00:17:57.230
concept for annotations. So local annotations
again, they're not persisted. They're sort

00:17:57.230 --> 00:18:02.259
of overlaid onto the document content. They
behave just like regular annotations; you

00:18:02.259 --> 00:18:07.950
can annotate any part of the document. The
key--the key difference that makes local annotations

00:18:07.950 --> 00:18:14.600
special is that unlike persistent annotations,
local annotations don't have to use just primitive

00:18:14.600 --> 00:18:20.490
values. So annotations is a key value pairs.
Local annotations are free to use any type

00:18:20.490 --> 00:18:25.499
for the values, including object references
because they are not sent to the server, they're

00:18:25.499 --> 00:18:30.649
not persisted; it's just local in their client
session. So this is very handy for a number

00:18:30.649 --> 00:18:39.440
of UI features if they want to store state
in the document. So that covers very briefly,

00:18:39.440 --> 00:18:44.309
that covers the rendering path and there are
just a couple of slides on the event handling

00:18:44.309 --> 00:18:51.039
path. This diagram here gives you an overview
of the structure of the event handling flow

00:18:51.039 --> 00:18:58.289
in the editor. Going from bottom to top, there's--the
editor responds to native browser events;

00:18:58.289 --> 00:19:05.490
typing, clicking, pasting, and there's a layer
on top that normalizes these events and tries

00:19:05.490 --> 00:19:12.929
to abstract away browser quirks and the different
event models that are on every browser. It

00:19:12.929 --> 00:19:20.601
also makes the events a bit more semantic
in the context of editing, so it will interpret

00:19:20.601 --> 00:19:26.539
events like selection movement and Enter being
pressed. This kind of events, it makes them

00:19:26.539 --> 00:19:36.220
first class and it also routes the events
to the layer above. And above, there's a kind

00:19:36.220 --> 00:19:40.549
of first class distinction between things
that do things programmatically versus the

00:19:40.549 --> 00:19:44.740
things that let the browser do its thing with
contentEditable and then try and observe what

00:19:44.740 --> 00:19:49.019
it did and synthesize operations out of that.
Now there's some other ones we call extractors.

00:19:49.019 --> 00:19:55.950
So there's a few extractors built in, but
most things in the editor are done through

00:19:55.950 --> 00:20:02.649
handlers, and handlers operate at the same
level as custom handlers that you add when

00:20:02.649 --> 00:20:09.659
you add your own doodads. And yeah, handlers
observe events and mutate the document model

00:20:09.659 --> 00:20:15.459
above it. Yeah, question?
&gt;&gt; What were the extractors again?

00:20:15.459 --> 00:20:19.539
&gt;&gt; HEARDEN: There's--they'll show up in the
following slides, but the two main extractors

00:20:19.539 --> 00:20:28.909
are there's a text extractor and a paste extractor.
&gt;&gt; So does these two extract the text that

00:20:28.909 --> 00:20:30.590
the user is talking about?
&gt;&gt; HEARDEN: Yeah. So it's--rather than interpret

00:20:30.590 --> 00:20:37.019
a browser event entirely manually, we let
the browser do something natively and then

00:20:37.019 --> 00:20:51.549
observe what it did to--what it did to the
DOM and then interpret an operation

00:20:51.549 --> 00:20:52.559
out of that.
&gt;&gt; So in this model, I say to the character,

00:20:52.559 --> 00:20:53.559
the character produces read immediately and
then to post process it to find out what the

00:20:53.559 --> 00:20:54.559
character was?
&gt;&gt; HEARDEN: Yes. So that will show up--that

00:20:54.559 --> 00:20:59.559
example will show up in a couple of slides.
So yeah, this is just a bit more detail on

00:20:59.559 --> 00:21:05.509
what those event layers are, but I've already
talked about it. So, this example--so I'm

00:21:05.509 --> 00:21:13.009
now going to go through, I think, about five
quick examples of the flow of editing interaction

00:21:13.009 --> 00:21:19.860
in the editor. First one being the 99 percent
case of just typing regular characters, and

00:21:19.860 --> 00:21:26.380
again, the goal is to get--is to make it fast.
Even tiny bits of latency as you're typing

00:21:26.380 --> 00:21:34.539
is very easily noticed. So this--so typing
events, we let contentEditable usually do

00:21:34.539 --> 00:21:40.559
its thing. We schedule a time out to run a
little bit later to observe what the browser

00:21:40.559 --> 00:21:46.399
and native editor does and extract operations
out of that. So this means that typing is

00:21:46.399 --> 00:21:55.279
just as fast as it is in a native contentEditable
region. But that's only for very basic typing.

00:21:55.279 --> 00:22:08.299
&gt;&gt; [INDISTINCT].
&gt;&gt; HEARDEN: More or less. Yeah. Yeah.

00:22:08.299 --> 00:22:15.480
So for something a bit more sophisticated
like pressing Enter, where--yeah, Enter is

00:22:15.480 --> 00:22:23.999
kind of handled specially. There's custom
logic that's registered in the paragraph doodad,

00:22:23.999 --> 00:22:29.259
and this handles the event completely manually
by splitting a line, by putting in a line

00:22:29.259 --> 00:22:35.710
element, and then the corresponding renderers
kick in after that. So the reason this example

00:22:35.710 --> 00:22:42.059
is important is that the way Enter behaves
is different in paragraphs versus if you're

00:22:42.059 --> 00:22:47.790
in bulleted list or a numbered list. And all
this behavior is done--in Wave editor, it's

00:22:47.790 --> 00:22:52.700
all done completely programmatically. It's
all under application control and this just

00:22:52.700 --> 00:22:56.850
demonstrates the flexibility of you can either
let the browser do its thing or you can have

00:22:56.850 --> 00:23:06.139
complete application control. So paste is--paste
is an example of something that's a little

00:23:06.139 --> 00:23:16.650
special. In order to protect the logical content
and to protect the rendering, we do need to

00:23:16.650 --> 00:23:21.400
let the browser do a paste somewhere because
otherwise, we don't know what the paste is

00:23:21.400 --> 00:23:25.289
going to be, but we don't want it to go directly
into the rendering because that might munge

00:23:25.289 --> 00:23:33.029
it up. So paste is handled by moving the selection
to an off-screen element. The browser will

00:23:33.029 --> 00:23:37.919
paste some content in there and then paste
is handled through an extractor. The thing

00:23:37.919 --> 00:23:41.639
goes in and looks at what the browser pasted
in that off-screen element and interprets

00:23:41.639 --> 00:23:48.119
that as Wave XML and makes the corresponding
logical insertions into the document. And

00:23:48.119 --> 00:23:54.090
I should mention that this trick also lets
us do semantic paste where if you select some

00:23:54.090 --> 00:23:58.049
content within a Wave document, then paste
it somewhere else within a Wave document,

00:23:58.049 --> 00:24:03.900
it's not that the paste comes through as HTML
and we kind of have to reverse engineer what

00:24:03.900 --> 00:24:10.559
was the Wave XML that went in there; there's
a special path that lets us preserve exactly

00:24:10.559 --> 00:24:17.109
what semantic HTML that was used in that case.
So there's just two more examples, one is

00:24:17.109 --> 00:24:22.879
a stylistic example. So when you hit Ctrl+B,
what happens? Again, we don't let the native

00:24:22.879 --> 00:24:27.320
contentEditable editor handle this because
the native editors do all sorts of crazy stuff

00:24:27.320 --> 00:24:33.210
to the DOM. Instead, there's a key handler
that's registered in the editor that handles

00:24:33.210 --> 00:24:40.760
this and it's handled by using a style annotation.
So it annotates the logical content with the

00:24:40.760 --> 00:24:44.940
region that's being selected and puts an annotation
on it and then the annotation painter kicks

00:24:44.940 --> 00:24:49.940
in, puts in the spread nodes and the boundary
nodes. And there are registered paint functions

00:24:49.940 --> 00:24:59.809
that paint this annotation using CSS style
attributes. And the last example, I'm not

00:24:59.809 --> 00:25:06.490
going to explain anything about how it works
other than for IME keyboard input, this is

00:25:06.490 --> 00:25:11.359
too hard to do programmatically so instead,
this is something that's let through to the

00:25:11.359 --> 00:25:16.619
editor--let through to the contentEditable
native editor and then we extract what comes

00:25:16.619 --> 00:25:23.850
up. Okay, so we're going well for time. Any
questions on content--yes?

00:25:23.850 --> 00:25:31.730
&gt;&gt; What's IME?
&gt;&gt; HEARDEN: IME stands for Input M--something

00:25:31.730 --> 00:25:34.729
Extension. Dan, what's the right...?
&gt;&gt; DANILATOS: Input Method Editor.

00:25:34.729 --> 00:25:40.190
&gt;&gt; HEARDEN: Input Method Editor. It's for,
like, a multi-lingual--like talking in Chinese

00:25:40.190 --> 00:25:50.249
or talking in...
&gt;&gt; So, our editors, we live around of actually

00:25:50.249 --> 00:26:08.053
not the [INDISTINCT] well then, the issues
we have is it's just so slow to rebuild the

00:26:08.053 --> 00:26:09.053
DOM. How did you guys solve--what do you do
when someone makes the change that comes across

00:26:09.053 --> 00:26:10.053
the network as just one character, and you
know, you build a DOM.

00:26:10.053 --> 00:26:13.559
&gt;&gt; HEARDEN: No, no, no. So everything is mutated
incrementally in place. So, in the case of

00:26:13.559 --> 00:26:19.799
a remote operation coming in to insert a character,
that will get inserted in place in the logical

00:26:19.799 --> 00:26:26.049
content. You might remember in one of the
earlier slides, the mapping between the logical

00:26:26.049 --> 00:26:29.830
content and the rendering, there are these
bidirectional references between various nodes

00:26:29.830 --> 00:26:34.120
so there's sort of intelligent, incremental
stuff that just makes incremental mutations

00:26:34.120 --> 00:26:43.960
to the rendering. It's not completely rebuilt
all the time. Any other questions? Okay, great.

00:26:43.960 --> 00:26:48.429
Maybe just take a quick--a quick one or two
minute break because the next talk, we're

00:26:48.429 --> 00:28:02.369
going to go through building a doodad, which
is going to be fun. So I will just get that

00:28:02.369 --> 00:28:21.809
set up. Okay, let's get back into it. Do a
lightning run through extending Wave content.

00:28:21.809 --> 00:28:26.899
So we're going to build a doodad and give
you a flavor for the development process of

00:28:26.899 --> 00:28:34.919
building a doodad as well. So, just one slide
here; most of this talk is going to be inside

00:28:34.919 --> 00:28:40.419
Eclipse and inside something that just got
checked in yesterday or the day before, which

00:28:40.419 --> 00:28:46.559
is called the Editor Test Harness. And so,
I'll give a quick tour of the editor test

00:28:46.559 --> 00:28:53.850
harness, what it is, how to use it; and then
if there's time, I might just briefly describe

00:28:53.850 --> 00:29:01.389
some examples of existing doodads that are
used within Wave. Then we're going to build

00:29:01.389 --> 00:29:07.840
an example doodad, and the doodad we're going
to build comes from--there's a tutorial that's

00:29:07.840 --> 00:29:15.059
now online, I think, that's quite in depth
and yeah, quite detailed; covers all parts

00:29:15.059 --> 00:29:19.769
of how to write a doodad and how to add custom
behavior and custom renderings within the

00:29:19.769 --> 00:29:37.090
editor. All right. So, the Editor Test Harness,
you can run it in a number of ways. I'll just--so,

00:29:37.090 --> 00:29:42.450
if you have a recent update of the Mercurial
Repository main links, this is the library's

00:29:42.450 --> 00:29:50.639
repository. There's a package in there, clienteditor.harness,
and within there, there's a launch configuration

00:29:50.639 --> 00:29:58.950
you can run. When you run it, it will start
up GWT's hosted mode server and then you launch

00:29:58.950 --> 00:30:05.629
that and you'll get an application that looks
like this, and what is on screen here. Most

00:30:05.629 --> 00:30:11.350
of it doesn't fit too well on a narrow screen,
but here there are two editors on this page.

00:30:11.350 --> 00:30:20.700
There's an editor here on the left. You can
see me typing here. So, on the left, there's

00:30:20.700 --> 00:30:26.299
an editor operations that are coming out of
the editor and then getting applied to a second

00:30:26.299 --> 00:30:32.389
editor over on the right just so you can have--it
gives you a mock environment of two concurrent

00:30:32.389 --> 00:30:35.909
editors happening. You can edit in either
one; operations get propagated back and forth

00:30:35.909 --> 00:30:43.279
between the two. Below the editor, you can
see here the logical content that is in yellow.

00:30:43.279 --> 00:30:49.399
So here it's the document and the body element,
the line elements and the text within them;

00:30:49.399 --> 00:30:55.239
and you can see that these are being--these
are being wrapped in some local nodes. You

00:30:55.239 --> 00:31:03.019
can see the local paragraph elements here.
And on the right, you can see the HTML to

00:31:03.019 --> 00:31:10.109
which that state has been rendered. So, here,
it's all divs and ULs, and line breaks and

00:31:10.109 --> 00:31:14.869
things. And this mapping is--yeah, you can
see the correspondence between this rendering

00:31:14.869 --> 00:31:19.929
and the logical content now that's being marked
up with local nodes. Now, there's lots of

00:31:19.929 --> 00:31:25.450
buttons for doing fancy stuff. The main--the
main stuff that we're going to use is just

00:31:25.450 --> 00:31:37.710
typing in one editor and there's also a--there's
also a field here where you can enter in the

00:31:37.710 --> 00:31:42.359
logical content that you want to show up in
the editor just to help bootstrap development.

00:31:42.359 --> 00:31:59.789
Okay, so the doodad we're going to build is
an image doodad that looks very much like

00:31:59.789 --> 00:32:09.259
the image thumbnail doodad that's in Google
Wave. And what's in it--so it's an inline--it's

00:32:09.259 --> 00:32:14.360
an inline image doodad. It's got an image
and it's got a caption within it that you

00:32:14.360 --> 00:32:20.169
can type in. And so, we're going to--we're
going to have time to build the whole thing

00:32:20.169 --> 00:32:36.119
from scratch but what I'm going to do instead
is point out the finished content and, like,

00:32:36.119 --> 00:32:41.720
poke and prod it around a little bit. So,
there's two main--two main clauses here that

00:32:41.720 --> 00:32:48.340
will be a concern. One is what's called the
entry point module. So, I know most of you

00:32:48.340 --> 00:32:55.229
haven't done much work with GWT before, but
the unit of modularization in GWT is called

00:32:55.229 --> 00:33:01.340
a module. And you build your application up
out of these GWT modules and you nominate

00:33:01.340 --> 00:33:06.210
one module to be the entry point for your
application. So, this code here is just saying,

00:33:06.210 --> 00:33:16.899
"Here's a module to be an entry point and
the minimum code that you need to get things

00:33:16.899 --> 00:33:25.409
running." I clicked the right button this
time. That one. The minimum you would need

00:33:25.409 --> 00:33:29.669
to get things running looks just like this.
You create and edit a harness object and you

00:33:29.669 --> 00:33:36.239
just run it, and that's it. And if you do
that, you'll get the page that I just showed

00:33:36.239 --> 00:33:44.309
you before. But in this tutorial, we've put
in a bunch of things to work with the doodad

00:33:44.309 --> 00:33:51.299
that we're writing. And the doodad we're going
to write is called "my doodad" and the key

00:33:51.299 --> 00:33:58.940
part of installing a doodad is typically a
static register method on the doodad that

00:33:58.940 --> 00:34:06.909
accepts a registry into which it registers
its various parts. So, we're going to start

00:34:06.909 --> 00:34:31.330
off from the very--so, from the very base
case, when there's nothing registered, what

00:34:31.330 --> 00:34:37.540
happens--so now I'll just refresh the harness.
This is Eclipse—this is GWT's hosted mode,

00:34:37.540 --> 00:34:46.400
code server running. It's recompiling the
application. So, if we put in the logical

00:34:46.400 --> 00:34:53.220
content a reference to MyDoodad then what
shows up is a default rendering. And the default

00:34:53.220 --> 00:34:57.430
rendering of doodad is just a gray box with
the name of the doodad typed in it. So if

00:34:57.430 --> 00:35:02.980
you see this, this means that the default
renderer is kicking in, but what we want to

00:35:02.980 --> 00:35:15.020
do is register our own renderer. So, simplest
case is here, we have a simple renderer. What

00:35:15.020 --> 00:35:22.360
we do with it is to register that renderer
for the tag name of our doodad and the tag

00:35:22.360 --> 00:35:31.990
name, in this case, is MyDoodad. And what
does that renderer look like? So this is that

00:35:31.990 --> 00:35:47.190
renderer. You can see it extends a mutation
handler. That's not good. And the way it's

00:35:47.190 --> 00:35:52.440
going to render the logical content of the
doodad is just to translate it to an HTML

00:35:52.440 --> 00:36:01.610
image element, and that's this code here.
And it also responds to modifications of the--I

00:36:01.610 --> 00:36:11.100
should point it out. The way we want to represent
the state of our doodad, to start of with,

00:36:11.100 --> 00:36:17.660
this just has a reference attribute that points
to where the image is. So, in code, we just

00:36:17.660 --> 00:36:21.770
translate that to the source attribute of
an HTML image element. So that's the simple

00:36:21.770 --> 00:36:31.440
renderer.
So, if we write that and register that, these

00:36:31.440 --> 00:36:40.550
doodads will start showing up like this. So,
it's just an HTML image. It wasn't that nice

00:36:40.550 --> 00:36:48.462
and easy. So, the next thing we--we can do
is attach some behavior to this doodad. And

00:36:48.462 --> 00:36:58.370
we're going to do that with a simple event
handler. And we have to register that event

00:36:58.370 --> 00:37:12.670
handler. And the behavior we're going to add
is this code here. All we have to do is to

00:37:12.670 --> 00:37:16.340
say that when the doodad gets activated, we've
registered a JavaScript event handler so that

00:37:16.340 --> 00:37:21.880
when we click on it, it brings up a prompt
that will let us change the reference attribute

00:37:21.880 --> 00:37:32.110
of it. So, that's all this code here. It's
pretty tight and compact. So I'm now installing

00:37:32.110 --> 00:37:49.810
that handler. Refresh and see the next stage
of the doodad. To remember one of the...let's

00:37:49.810 --> 00:38:03.020
try this doodad. So, we click on it and the
handler we registered is now being invoked.

00:38:03.020 --> 00:38:11.080
And the code in our handler takes the value
that we put into this window prompt; updates

00:38:11.080 --> 00:38:16.660
the ref attribute in the logical content,
and we'll see the renderer that we've registered,

00:38:16.660 --> 00:38:22.650
the renderer kick in and update the rendering
by changing the source attribute of the HTML

00:38:22.650 --> 00:38:29.590
image element. So, that's how--that's all
it takes to add custom rendering and event

00:38:29.590 --> 00:38:37.110
handling to elements in the editor. The next
thing we're going to do is use some more sophisticated

00:38:37.110 --> 00:39:05.170
rendering. And that...and yeah, I'll just...and
this more sophisticated rendering is going

00:39:05.170 --> 00:39:13.170
to use a GWT widget to do the rendering. And
in the editor extension mechanism, if you

00:39:13.170 --> 00:39:17.830
want to put in GWT widgets rather than just
native HTML, then there's a special mutation

00:39:17.830 --> 00:39:26.390
handler that takes care of a lot of the GWT
hook-up for you. So in this case, we're running

00:39:26.390 --> 00:39:35.540
a GWT renderer, and again, it has the same
sort of structure on modifications of the

00:39:35.540 --> 00:39:52.431
ref attribute we translate them to modifications
of on the widget. So, that GWT widget itself--that

00:39:52.431 --> 00:39:56.860
GWT widget itself is just--in this example,
it's just a stock standard Wave running a

00:39:56.860 --> 00:40:00.880
GWT widget, there's a corresponding UI binder
template that just declaratively describes

00:40:00.880 --> 00:40:15.080
the HTML. Before I go into any detail about
implementation of that widget...so now, we

00:40:15.080 --> 00:40:22.390
should see a more sophisticated rendering.
So, it's a bit fancier, it's--you know, I've

00:40:22.390 --> 00:40:35.610
got a beveled background for it. So, it's
using a GWT widget. Eclipse is going to die

00:40:35.610 --> 00:40:57.610
on me now. Here we go. So, the next thing
is to attach--is attach the behavior again,

00:40:57.610 --> 00:41:02.820
and to also think about starting to render
that caption element. So, within that--the

00:41:02.820 --> 00:41:06.430
logical content, there is a caption element
with the image element. And how are we going

00:41:06.430 --> 00:41:33.990
to render that? Let's see...that should do
the--that should do the trick. So, the key

00:41:33.990 --> 00:41:45.000
thing to understand about having doodads for
composite structure is this concept of a doodads

00:41:45.000 --> 00:41:53.280
container nodelet to this method here. So,
the usual case where you have a composite

00:41:53.280 --> 00:41:59.390
structure that you want to render, in this
case, there's an image element--sorry, there's

00:41:59.390 --> 00:42:05.700
a "MyDoodad" element that has a caption within
it. Usually, you want the rendering of the

00:42:05.700 --> 00:42:11.890
child to be contained somewhere within the
rendering of the parent. And for this 99 percent

00:42:11.890 --> 00:42:18.280
use case, there's a very simple way that you
can specify how to hook up the two renderings.

00:42:18.280 --> 00:42:23.160
So you've got a rendering for the--for your
doodad which renders to that GWT widget I

00:42:23.160 --> 00:42:30.060
showed you before. There'd be a separate rendering
for the caption element and there's some default

00:42:30.060 --> 00:42:38.620
behavior that looks--when the editor is rendering
these two parts, it tries to look for where

00:42:38.620 --> 00:42:45.230
to put the child within the rendering of its
parent and you can claim--you can declare

00:42:45.230 --> 00:42:53.930
where you want it to go by overwriting this
container nodelet method. So, now we should

00:42:53.930 --> 00:43:06.260
see the image with a rendering of a caption
in it. And there we go. So, this caption part

00:43:06.260 --> 00:43:11.300
has been rendered by a separate renderer and
the editor knows how to hook it up using that

00:43:11.300 --> 00:43:49.800
container nodelet mechanism. And there's only
one other--one next step that I wanted to

00:43:49.800 --> 00:44:03.160
point out. So, by default--by default, if
you hook up a widget like this or hook up

00:44:03.160 --> 00:44:10.160
a doodad like this, you'll typically run to
lots of usability issues, in particular, how

00:44:10.160 --> 00:44:19.190
do you get--how do you get your carrot inside
that caption box? So, the editor has no way

00:44:19.190 --> 00:44:25.050
of knowing, you know, how to do this for you.
So the default behavior that you'd see is

00:44:25.050 --> 00:44:31.970
if you're before the image and you hit the
right arrow key, it's just going to jump all

00:44:31.970 --> 00:44:37.470
the way over your entire image and jump down
to the text after it. But what we want to

00:44:37.470 --> 00:44:44.460
do in this case is, one way, before the image,
if we hit the right arrow like I'll do now,

00:44:44.460 --> 00:44:48.870
we want this behavior where the carrot is
placed inside the caption element. And similarly,

00:44:48.870 --> 00:44:53.910
if you're at the end of the caption element
and you hit the right arrow, we want to have

00:44:53.910 --> 00:45:00.300
the behavior where it'll put the cursor on
the right hand of the entire image. And this

00:45:00.300 --> 00:45:10.340
is all quite simple to specify. There's a
caption event handler here. This isn't the

00:45:10.340 --> 00:45:18.960
one I want. This is the one I want; this caption
event handler here. So, you might recall that

00:45:18.960 --> 00:45:29.430
in the layering of the event flow in the editor,
there's a normalization layer. Part of that

00:45:29.430 --> 00:45:37.180
is to express events in a language that is
more suitable for--it's more suitable for

00:45:37.180 --> 00:45:44.490
an editing experience, and so it translates
it into events like handle left after node.

00:45:44.490 --> 00:45:54.780
So, this event--this callback gets called
on your doodad when the carrot is after the

00:45:54.780 --> 00:46:01.900
node and there's has been a selection event
of moving it to the left. And so, all we're

00:46:01.900 --> 00:46:08.330
doing here, in this case, is saying if the
carrot is on the right of the entire image

00:46:08.330 --> 00:46:13.210
thumbnail and the user hits the left arrow,
you want to move the carrot and put it at

00:46:13.210 --> 00:46:21.440
the end of the caption, and that's this code
here, that's all it's doing. And similarly,

00:46:21.440 --> 00:46:26.090
you know, if they hit right while they're--right
before the image thumbnail, I want to put--move

00:46:26.090 --> 00:46:33.810
the carrot and move the selection inside the--inside
the caption. And then we get the behavior

00:46:33.810 --> 00:46:42.220
that you can see here. You hit right, we're
in the caption and at the end of the caption,

00:46:42.220 --> 00:46:45.860
things just keep flowing. And you can add--in
Google Wave, we add extra custom behavior

00:46:45.860 --> 00:46:51.420
like for when you hit tab. When you hit tab
inside the caption, it will move to adjacent

00:46:51.420 --> 00:46:55.940
captions and other image thumbnails. So these
kinds of things are all very easy to hookup

00:46:55.940 --> 00:47:04.280
with the doodad API. So that's all that I
wanted to show you in code. There's only one

00:47:04.280 --> 00:47:09.150
other thing that I wanted to talk about in
this talk and that's--so this is all--everything

00:47:09.150 --> 00:47:13.720
you've seen so far has been structural which
is given XML elements, how to paint them,

00:47:13.720 --> 00:47:19.680
how to handle events around XML elements.
What I haven't talked about at all is how

00:47:19.680 --> 00:47:33.230
to register doodads, the control renderings
of annotations. So, the--like I mentioned

00:47:33.230 --> 00:47:39.930
before, the annotation painter breaks up the
annotations into spreads and boundaries, and

00:47:39.930 --> 00:47:45.190
those two abstractions of spreads and boundaries,
these are the abstractions that you use to

00:47:45.190 --> 00:47:51.940
specify renderings, annotations. So there's
two kinds of functions you can register to

00:47:51.940 --> 00:47:59.920
paint annotations, one is a regular PaintFunction
and that says for any region that is covered

00:47:59.920 --> 00:48:08.670
by a particular annotation, apply these attributes
across the elements in that region. So, for

00:48:08.670 --> 00:48:15.551
example, a bold annotation that covers some
text in a region, that gets--that annotation

00:48:15.551 --> 00:48:23.620
gets rendered by a Piantfunction that puts
on a style attribute with font Wave bold.

00:48:23.620 --> 00:48:30.800
The second of function is a BoundaryFunction
and these functions get invoked at the boundaries

00:48:30.800 --> 00:48:39.530
where annotation values change. So, best example
of this would be the spelling--the spell correction

00:48:39.530 --> 00:48:46.070
annotation, where the little dropdown arrow
that you see on the right of the text, that

00:48:46.070 --> 00:48:54.080
gets rendered through a BoundaryFunction.
And a BoundaryFunction just specifies that

00:48:54.080 --> 00:49:01.760
given a location where, on the left, the annotations
has one value and, on the right, annotation

00:49:01.760 --> 00:49:09.900
has a different value; we can insert nodes
at that boundary. So, in the spell correction

00:49:09.900 --> 00:49:16.540
PaintFunction or the spell correction BoundaryFunction
it says, "Where the value changes from..."

00:49:16.540 --> 00:49:21.900
there is a spell correction here to--there
is no spell correction here. It inserts a

00:49:21.900 --> 00:49:27.590
node at that location, and these are local
nodes that get inserted. So, that should explain

00:49:27.590 --> 00:49:37.720
how you can specify paintings for annotations
using the doodad API. And we now have five

00:49:37.720 --> 00:49:41.640
minutes for any questions. Do you have any
questions? Yeah, okay.

00:49:41.640 --> 00:49:47.820
&gt;&gt; So if I want to, I can come up with my
doodad as [INDISTINCT] and start putting that

00:49:47.820 --> 00:50:06.670
into my Waves then the--I need to have push
[INDISTINCT] that knows how to spread the

00:50:06.670 --> 00:50:14.170
[inaudible], right?
&gt;&gt; HEARNDEN: It would be best to do that.

00:50:14.170 --> 00:50:20.150
There's always a default rendering that kicks
in which you saw at the start where any doodads

00:50:20.150 --> 00:50:26.540
where the other doesn't have painters or renderers
registered for them, just get rendered as

00:50:26.540 --> 00:50:33.130
gray boxes. So it won't break someone else's
client, but they won't get a particularly

00:50:33.130 --> 00:50:40.411
good experience. In the Google Wave client,
there's a whole separate system of extensions

00:50:40.411 --> 00:50:45.770
where clients can install their own doodads,
like through your toolbars and various things.

00:50:45.770 --> 00:50:55.970
But it's usually best to propagate the codes
so everyone has it. Anyone ready to write

00:50:55.970 --> 00:51:04.660
their own doodads now? Yep? Okay, Darren (ph)
is there anything you wanted to throw in?

00:51:04.660 --> 00:51:14.470
&gt;&gt; DARREN (ph): No, not much. That's basically
it. Just a couple of examples for use of annotations,

00:51:14.470 --> 00:51:20.060
so the light bulb at the end of links is also
boundary in the wake. Selections, when you

00:51:20.060 --> 00:51:25.470
see other people's selections, the little
blob that shows their name, that's another

00:51:25.470 --> 00:51:33.280
boundary node as well. Yes, that's basically
it. But--and the other—the other thing to

00:51:33.280 --> 00:51:39.510
point out is--while on that example we did
like an image search; it's a very widget kind

00:51:39.510 --> 00:51:46.180
of example, basically, everything is written
with the same--so every single feature in

00:51:46.180 --> 00:51:54.050
the editor like from paragraphs, bullets,
you know, image thumbnails, gadgets themselves;

00:51:54.050 --> 00:52:03.440
yeah, links. Basically everything is done
with the same API. So, it's not just for building

00:52:03.440 --> 00:52:10.700
widgets that respond to events, it's for arbitrary
editing functionality. That's all.

00:52:10.700 --> 00:52:15.610
&gt;&gt; HEARNDEN: Oh, one last question?
&gt;&gt; [INDISTINCT].

00:52:15.610 --> 00:52:28.440
&gt;&gt; HEARNDEN: Yeah, it's done using the same
API, yup.

00:52:28.440 --> 00:52:30.601
&gt;&gt; [INDISTINCT].
&gt;&gt; HEARNDEN: Yup.

00:52:30.601 --> 00:52:33.320
&gt;&gt; [INDISTINCT].
&gt;&gt; HEARNDEN: Yup, that's right. Yeah, so that's

00:52:33.320 --> 00:52:37.550
the kind of--demonstrates that the API is
powerful enough to do a wide range of editing

00:52:37.550 --> 00:52:38.550
features. All right, thank you very much.
sically everything is done with the same API.

00:52:38.550 --> 00:52:39.550
So, it's not just for building widgets that
respond to events, it's for arbitrary editing

00:52:39.550 --> 00:52:40.550
functionality. That's all.
&gt;&gt; HEARNDEN: Oh, one last question?

00:52:40.550 --> 00:52:41.550
&gt;&gt; [INDISTINCT].
&gt;&gt; HEARNDEN: Yeah, it's done using the same

00:52:41.550 --> 00:52:42.550
API, yup.
&gt;&gt; [INDISTINCT].

00:52:42.550 --> 00:52:42.552
&gt;&gt; HEARNDEN: Yup.
&gt;&gt; [

