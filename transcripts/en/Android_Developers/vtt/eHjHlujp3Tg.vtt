WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.410
[MUSIC PLAYING]

00:00:07.092 --> 00:00:08.550
RETO MEIER: Good
morning, everyone.

00:00:08.550 --> 00:00:09.620
My name is Reto Meier.

00:00:09.620 --> 00:00:12.060
I'm a developer
advocate here at Google.

00:00:12.060 --> 00:00:18.170
Now, technically, I'm a DA on
the Google Cloud DevRel team.

00:00:18.170 --> 00:00:20.080
So if any of you
bump into my boss

00:00:20.080 --> 00:00:22.820
or I mean really anyone
from the Google Cloud team,

00:00:22.820 --> 00:00:25.130
and they ask how the
presentation went,

00:00:25.130 --> 00:00:28.430
if you could tell them that I
presented how to build a Cloud

00:00:28.430 --> 00:00:34.610
backend for your mobile app,
that would really help me out.

00:00:34.610 --> 00:00:37.190
Now, what I am presenting is
hopefully what everyone is here

00:00:37.190 --> 00:00:40.430
to see, is Android
Protips, a fresh look

00:00:40.430 --> 00:00:44.390
at expert advice for
advanced Android developers.

00:00:44.390 --> 00:00:47.000
As the title suggests, this
will be a very technical talk.

00:00:47.000 --> 00:00:48.710
There will be a lot of code.

00:00:48.710 --> 00:00:50.270
If you are not
comfortable with code,

00:00:50.270 --> 00:00:53.090
or if you came to hopefully
see the Grateful Dead,

00:00:53.090 --> 00:00:55.340
you are in the wrong place.

00:00:55.340 --> 00:00:58.340
You are also about
20 years late.

00:00:58.340 --> 00:01:00.225
Now, just to get a
feel for to make sure

00:01:00.225 --> 00:01:02.600
we have the right people in
the audience, how many of you

00:01:02.600 --> 00:01:04.800
are developing for
Android right now?

00:01:04.800 --> 00:01:07.651
I mean, not now now, but
like at home and at work.

00:01:07.651 --> 00:01:08.150
OK.

00:01:08.150 --> 00:01:08.690
Most of you.

00:01:08.690 --> 00:01:09.430
Not everyone.

00:01:09.430 --> 00:01:09.950
That's cool.

00:01:09.950 --> 00:01:11.824
Like there's some Android
curious folks here.

00:01:11.824 --> 00:01:14.132
Some dead heads in the
wrong place and time.

00:01:14.132 --> 00:01:15.840
I think there's some
folks up on the bank

00:01:15.840 --> 00:01:16.923
just working on their tan.

00:01:16.923 --> 00:01:18.650
And that's cool too.

00:01:18.650 --> 00:01:19.760
Everyone's welcome.

00:01:19.760 --> 00:01:21.480
Thank you for coming.

00:01:21.480 --> 00:01:25.000
Now, this is actually a pretty
special year for Android.

00:01:25.000 --> 00:01:26.930
This marks the
10-year anniversary

00:01:26.930 --> 00:01:29.572
of Android Development,
which is super exciting.

00:01:29.572 --> 00:01:31.280
Obviously, not everyone's
been developing

00:01:31.280 --> 00:01:32.690
on Android for quite that long.

00:01:32.690 --> 00:01:34.065
How many have you
been developing

00:01:34.065 --> 00:01:35.800
for more than two years?

00:01:35.800 --> 00:01:36.451
Yeah?

00:01:36.451 --> 00:01:36.950
Wow.

00:01:36.950 --> 00:01:38.550
Five years?

00:01:38.550 --> 00:01:39.560
A few hands down.

00:01:39.560 --> 00:01:40.460
What about 10 years?

00:01:40.460 --> 00:01:42.290
Do we have any
ten-year veterans?

00:01:42.290 --> 00:01:43.180
A few.

00:01:43.180 --> 00:01:44.099
Nice.

00:01:44.099 --> 00:01:44.765
Congratulations.

00:01:44.765 --> 00:01:46.550
Yeah, round of applause
for the 10 years.

00:01:50.330 --> 00:01:52.310
I, too, have that
honor, that privilege

00:01:52.310 --> 00:01:54.650
of having been developing
for Android for 10 years.

00:01:54.650 --> 00:01:56.660
I even brought receipts.

00:01:56.660 --> 00:02:00.350
This is my very first
question on Stack Overflow,

00:02:00.350 --> 00:02:04.050
asking about the Maps
API for the 0.9 beta SDK,

00:02:04.050 --> 00:02:06.410
which those handful
of 10-year veterans

00:02:06.410 --> 00:02:10.130
will hopefully remember,
maybe hopefully not remember.

00:02:10.130 --> 00:02:11.930
This is not my first
Google I/O. This

00:02:11.930 --> 00:02:13.730
is not my first Protip session.

00:02:13.730 --> 00:02:16.040
So I'm curious, and this
will be the last question

00:02:16.040 --> 00:02:18.830
I ask for a little while
at least, how many of you

00:02:18.830 --> 00:02:23.060
have been to a previous and
seen one of my previous Protip

00:02:23.060 --> 00:02:24.350
sessions?

00:02:24.350 --> 00:02:25.791
That's a decent handful.

00:02:25.791 --> 00:02:26.290
All right.

00:02:26.290 --> 00:02:28.580
And you still came to this.

00:02:28.580 --> 00:02:29.580
All right.

00:02:29.580 --> 00:02:31.840
That's reassuring.

00:02:31.840 --> 00:02:34.482
So thank you for that.

00:02:34.482 --> 00:02:35.940
I actually spent
a fair bit of time

00:02:35.940 --> 00:02:37.731
over the last couple
of months looking back

00:02:37.731 --> 00:02:39.459
over these sessions.

00:02:39.459 --> 00:02:41.000
And at first, it
was because I wanted

00:02:41.000 --> 00:02:42.290
to gain some inspiration.

00:02:42.290 --> 00:02:44.000
You know, like, what
are the cool things

00:02:44.000 --> 00:02:45.170
we used to talk about?

00:02:45.170 --> 00:02:47.660
Gain some of the excitement
from the early days of Android.

00:02:47.660 --> 00:02:52.220
But I quickly realized
that not everything

00:02:52.220 --> 00:02:58.800
that I had said in those early
days has held up all that well.

00:02:58.800 --> 00:03:01.610
So as a result, what I'm
actually going to be presenting

00:03:01.610 --> 00:03:05.210
this year is looking
at all the things

00:03:05.210 --> 00:03:06.710
that we've said
in previous years

00:03:06.710 --> 00:03:08.330
and giving it a
bit of an update.

00:03:08.330 --> 00:03:11.480
So the real, real title
slide for today's session

00:03:11.480 --> 00:03:14.300
is actually Android
Protips Fixed.

00:03:19.070 --> 00:03:20.900
Sorry.

00:03:20.900 --> 00:03:22.430
So the goal here
is to provide you

00:03:22.430 --> 00:03:24.470
with all the tips and
tricks and best practices

00:03:24.470 --> 00:03:25.969
and good advice
that's going to help

00:03:25.969 --> 00:03:29.400
us develop great apps for
the next decade of Android

00:03:29.400 --> 00:03:29.900
development.

00:03:29.900 --> 00:03:32.730
And in order to do
that effectively,

00:03:32.730 --> 00:03:34.480
I want you to take the
same journey as me.

00:03:34.480 --> 00:03:38.410
So we're going to start
by going back in time.

00:03:38.410 --> 00:03:41.300
We're going to go back
through previous Google

00:03:41.300 --> 00:03:46.460
I/Os, previous Protip
sessions, all the way back

00:03:46.460 --> 00:03:48.580
to the very, very beginning.

00:03:52.001 --> 00:03:52.500
OK.

00:03:52.500 --> 00:03:54.920
We may have gone too far back.

00:03:54.920 --> 00:03:56.840
This is me in kindergarten.

00:03:56.840 --> 00:03:58.002
Happy child.

00:03:58.002 --> 00:03:59.960
I don't know what a
fragment is, and I've never

00:03:59.960 --> 00:04:01.126
heard of a content provider.

00:04:04.030 --> 00:04:05.440
That will change.

00:04:05.440 --> 00:04:07.650
Also, side note, I didn't
know I was presenting

00:04:07.650 --> 00:04:09.108
in the amphitheater,
and that there

00:04:09.108 --> 00:04:11.500
would be a 400 foot screen.

00:04:11.500 --> 00:04:13.360
If I had known that,
I may have included

00:04:13.360 --> 00:04:16.540
fewer pictures of myself.

00:04:16.540 --> 00:04:19.184
Take note if you're
ever in this situation.

00:04:19.184 --> 00:04:20.350
Clearly, we're too far back.

00:04:20.350 --> 00:04:22.120
So let's just bump it
a few years forward.

00:04:22.120 --> 00:04:25.150
I think I can do that
with one of these buttons.

00:04:25.150 --> 00:04:25.900
Let's have a look.

00:04:25.900 --> 00:04:26.950
Yes.

00:04:26.950 --> 00:04:28.300
Yeah, this is more like it.

00:04:28.300 --> 00:04:31.110
Don't I look young?

00:04:31.110 --> 00:04:31.652
This is 2008.

00:04:31.652 --> 00:04:33.526
And I remember this,
because this is actually

00:04:33.526 --> 00:04:35.530
the cover photo for
my first Android book.

00:04:35.530 --> 00:04:37.930
And we took this
photo just after I'd

00:04:37.930 --> 00:04:39.970
gotten the first
round of editor notes

00:04:39.970 --> 00:04:41.980
back from the first draft.

00:04:41.980 --> 00:04:46.130
And the next day, Android
released the 1.0 SDK.

00:04:46.130 --> 00:04:48.610
And up until then, I'd been
writing based on the 0.9 beta.

00:04:48.610 --> 00:04:49.930
And I knew what was coming.

00:04:49.930 --> 00:04:51.690
You know, the clue
was in the name.

00:04:51.690 --> 00:04:53.440
But I figured how much
is going to change?

00:04:53.440 --> 00:04:53.940
Right?

00:04:53.940 --> 00:04:56.770
1.0 from 0.9, 0.8 to
0.9 was pretty minor,

00:04:56.770 --> 00:05:00.220
so it should just be a
couple of little things.

00:05:00.220 --> 00:05:04.250
Turns out a lot can
change, like really a lot.

00:05:08.010 --> 00:05:11.850
I'd actually written an entire
chapter on the [? G Talk ?]

00:05:11.850 --> 00:05:15.390
data API, which it
was pretty cool,

00:05:15.390 --> 00:05:18.300
but it did not exist
in the 1.0 SDK.

00:05:18.300 --> 00:05:20.700
It's 30 pages of hard work.

00:05:20.700 --> 00:05:21.730
I didn't remove it.

00:05:21.730 --> 00:05:25.140
I ended up leaving it in the
book, because by the time

00:05:25.140 --> 00:05:26.600
it came out, who knows?

00:05:26.600 --> 00:05:27.330
Right?

00:05:27.330 --> 00:05:29.440
Android moves quickly.

00:05:29.440 --> 00:05:31.320
Well, it's been 10 years.

00:05:31.320 --> 00:05:32.700
It never got put back in.

00:05:32.700 --> 00:05:34.950
And eventually, I removed
it from future revisions

00:05:34.950 --> 00:05:36.450
of the book.

00:05:36.450 --> 00:05:37.980
Anyway, the reason
I mention this

00:05:37.980 --> 00:05:40.350
is because I've spent
most of the past 10 years

00:05:40.350 --> 00:05:43.020
going around talking
about Android,

00:05:43.020 --> 00:05:46.500
giving advice on the best way
of doing things, the latest

00:05:46.500 --> 00:05:48.540
and greatest APIs that
you can take advantage

00:05:48.540 --> 00:05:50.870
of to build great apps.

00:05:50.870 --> 00:05:53.070
And I do this with the
knowledge that sometimes

00:05:53.070 --> 00:05:57.760
within months, even weeks, these
things are going to change.

00:05:57.760 --> 00:05:59.760
They're going to be
replaced with something more

00:05:59.760 --> 00:06:01.470
efficient, more comprehensive.

00:06:01.470 --> 00:06:04.740
And in fact, weeks and months
is a best case scenario.

00:06:04.740 --> 00:06:06.420
I remember one
particular incident.

00:06:06.420 --> 00:06:09.390
I had just finished a
keynote, very exciting.

00:06:09.390 --> 00:06:11.490
Google Developer
Day in Prague, I

00:06:11.490 --> 00:06:15.660
think it was, What's
New in Cupcake.

00:06:15.660 --> 00:06:17.520
I've been doing
this for a while.

00:06:17.520 --> 00:06:19.380
And I stepped off stage.

00:06:19.380 --> 00:06:22.740
And just as my foot hit the
ground, we released Donut.

00:06:22.740 --> 00:06:25.800
So in that instance, I had
about three nanoseconds

00:06:25.800 --> 00:06:28.050
of being current before
everything I said

00:06:28.050 --> 00:06:30.390
was effectively outdated.

00:06:30.390 --> 00:06:32.790
Now, despite how all
of that may sound,

00:06:32.790 --> 00:06:35.230
this is actually
really a good thing.

00:06:35.230 --> 00:06:37.440
Well, for you, not
so much for me.

00:06:37.440 --> 00:06:38.950
But for you, it's a good thing.

00:06:38.950 --> 00:06:40.980
It demonstrates
how quickly Android

00:06:40.980 --> 00:06:45.750
is evolving to give users and
developers the things that they

00:06:45.750 --> 00:06:48.287
need to be able
to be successful.

00:06:48.287 --> 00:06:49.620
There's always been a trade-off.

00:06:49.620 --> 00:06:51.960
And I know you all have
felt this pain where

00:06:51.960 --> 00:06:54.706
the new platform comes
out, awesome new APIs,

00:06:54.706 --> 00:06:56.580
great new functionality
to take advantage of.

00:06:56.580 --> 00:07:00.900
But you know it's going to take
a while before lots of users

00:07:00.900 --> 00:07:02.489
are on that platform.

00:07:02.489 --> 00:07:04.530
And at the same time, some
of the older platforms

00:07:04.530 --> 00:07:06.850
are going to take a few
years before they go away.

00:07:06.850 --> 00:07:09.110
So you have to do
this trade-off.

00:07:09.110 --> 00:07:10.860
Is it worth putting
in the time and effort

00:07:10.860 --> 00:07:13.862
to take advantage of the new
APIs, the new functionality,

00:07:13.862 --> 00:07:16.320
knowing that it's going to have
to be backwards compatible,

00:07:16.320 --> 00:07:18.736
and you're going to have to
maintain that code potentially

00:07:18.736 --> 00:07:19.260
for years.

00:07:19.260 --> 00:07:20.250
So when do you do that?

00:07:23.420 --> 00:07:29.500
Well, the thing is what makes
us really excited is that now we

00:07:29.500 --> 00:07:33.550
have Jetpack, right, which
incorporates all of the Android

00:07:33.550 --> 00:07:35.909
Support Library, Android
Architecture components.

00:07:35.909 --> 00:07:38.200
And if you take Jetpack and
combine it with Google Play

00:07:38.200 --> 00:07:41.970
Services, we end up with
an increasing surface area

00:07:41.970 --> 00:07:45.430
of APIs, which don't rely on
having the latest platform

00:07:45.430 --> 00:07:45.930
version.

00:07:45.930 --> 00:07:48.340
So you can take advantage of
the new functionality that's

00:07:48.340 --> 00:07:49.420
available.

00:07:49.420 --> 00:07:51.880
And we'll take care of writing
all of the boilerplate code

00:07:51.880 --> 00:07:54.870
to make it backwards
compatible for you.

00:07:54.870 --> 00:07:56.037
So this is a nice advantage.

00:07:56.037 --> 00:07:56.536
Right?

00:07:56.536 --> 00:07:58.720
Suddenly that trade-off
isn't quite as expensive.

00:07:58.720 --> 00:08:01.900
Now, it's still one of
the big pluses of this

00:08:01.900 --> 00:08:04.160
as well is that we're no
longer tied to the framework.

00:08:04.160 --> 00:08:04.660
Right?

00:08:04.660 --> 00:08:06.670
So we can continue to
launch new features,

00:08:06.670 --> 00:08:09.460
fix bugs, encapsulate
more best practices,

00:08:09.460 --> 00:08:10.780
take care of more edge cases.

00:08:10.780 --> 00:08:15.130
We can do all of this in
between platform releases, which

00:08:15.130 --> 00:08:17.770
is great for developers,
not so awesome for those

00:08:17.770 --> 00:08:19.450
of us trying to talk about it.

00:08:19.450 --> 00:08:22.120
Things change more rapidly.

00:08:22.120 --> 00:08:23.050
But there's a price.

00:08:23.050 --> 00:08:23.290
Right?

00:08:23.290 --> 00:08:25.560
If you want to take advantage
of this cool new stuff,

00:08:25.560 --> 00:08:28.990
you have to reconsider some of
the fundamental architectural

00:08:28.990 --> 00:08:31.581
choices in how we
build our apps.

00:08:31.581 --> 00:08:33.789
And so I'm going to talk
today a little bit about why

00:08:33.789 --> 00:08:35.890
I think now is the
right time to do that.

00:08:35.890 --> 00:08:39.906
But if we bring it down
to its real fundamentals,

00:08:39.906 --> 00:08:41.530
what we're trying to
do is keep our app

00:08:41.530 --> 00:08:47.230
looking fresh, lightweight,
full of potential.

00:08:47.230 --> 00:08:54.430
If not, we quickly risk becoming
visibly older, outdated,

00:08:54.430 --> 00:08:59.710
a little bloated maybe, harder
to maintain, harder to manage.

00:08:59.710 --> 00:09:02.860
And there's an analogy
for high cholesterol,

00:09:02.860 --> 00:09:05.170
but I couldn't figure it out.

00:09:05.170 --> 00:09:05.920
You get the idea.

00:09:05.920 --> 00:09:07.210
Right?

00:09:07.210 --> 00:09:09.760
So before we sort
of dive into some

00:09:09.760 --> 00:09:12.280
of the tips, which
we do need to update,

00:09:12.280 --> 00:09:14.470
I did want to spend just
a little bit of time

00:09:14.470 --> 00:09:16.660
highlighting a handful
of Protips which

00:09:16.660 --> 00:09:19.720
have stood the test of
time, that like a fine wine

00:09:19.720 --> 00:09:22.495
or a sharp cheddar,
actually aged pretty well.

00:09:25.790 --> 00:09:28.570
There's probably more than
just the ones on this list.

00:09:28.570 --> 00:09:29.960
But this is the highlights.

00:09:29.960 --> 00:09:32.220
And what you'll notice about
these particular Protips

00:09:32.220 --> 00:09:35.940
is that they're not really
specific to Android.

00:09:35.940 --> 00:09:38.490
They're not even really
specific to mobile development.

00:09:38.490 --> 00:09:40.920
This is just good best
practice that you should always

00:09:40.920 --> 00:09:44.770
be keeping in mind when
building any engineering app.

00:09:44.770 --> 00:09:47.100
So let's not dwell
too much on the things

00:09:47.100 --> 00:09:49.120
that we know are
still good ideas.

00:09:49.120 --> 00:09:51.810
Let's take a look at some of
the things which have changed,

00:09:51.810 --> 00:09:56.200
which have perhaps not
aged quite as well.

00:09:56.200 --> 00:09:59.650
Now, everything on this list
you can pretty much still do,

00:09:59.650 --> 00:10:02.340
but it's all been replaced
with newer APIs that

00:10:02.340 --> 00:10:05.250
are more efficient, that
encapsulate a bigger

00:10:05.250 --> 00:10:07.110
amount of functionality.

00:10:07.110 --> 00:10:09.060
Sometimes the underlying
hardware has changed

00:10:09.060 --> 00:10:11.920
or the UI paradigm has changed.

00:10:11.920 --> 00:10:15.002
But a lot of it
you can still do.

00:10:15.002 --> 00:10:17.460
And that's actually kind of a
theme for a lot of the things

00:10:17.460 --> 00:10:18.876
that we're going
to be looking at.

00:10:18.876 --> 00:10:21.330
There has always been ways
of achieving certain things,

00:10:21.330 --> 00:10:24.810
but there's now significantly
better ways, simpler ways which

00:10:24.810 --> 00:10:27.510
involve less code,
less hacky workarounds,

00:10:27.510 --> 00:10:29.460
making it more predictable
and easier for you

00:10:29.460 --> 00:10:34.500
to maintain and manage your
code bases going forward.

00:10:34.500 --> 00:10:36.225
So we know things have changed.

00:10:36.225 --> 00:10:37.350
I've said that a few times.

00:10:37.350 --> 00:10:40.355
But there's certain things we've
always been able to rely on.

00:10:40.355 --> 00:10:41.000
Right?

00:10:41.000 --> 00:10:45.020
You write your Android code
in Java language syntax.

00:10:45.020 --> 00:10:47.540
And all of the
application components

00:10:47.540 --> 00:10:49.010
are basically the same.

00:10:49.010 --> 00:10:50.960
We use the same core components.

00:10:50.960 --> 00:10:52.130
They interact the same way.

00:10:52.130 --> 00:10:55.170
They achieve the
same end results.

00:10:55.170 --> 00:10:58.370
And that's something we've
been able to rely on until--

00:10:58.370 --> 00:11:00.150
basically, until now.

00:11:00.150 --> 00:11:03.740
The last year or so things
have fundamentally changed.

00:11:03.740 --> 00:11:05.780
Android Studio 3
introduced Kotlin

00:11:05.780 --> 00:11:07.970
as a first class language
for Android development.

00:11:07.970 --> 00:11:10.640
And that's actually what
we're encouraging people

00:11:10.640 --> 00:11:12.260
to use as their
primary development

00:11:12.260 --> 00:11:14.480
language for Android.

00:11:14.480 --> 00:11:16.910
We saw the introduction
of Android Architecture

00:11:16.910 --> 00:11:19.600
Components, which introduced
ViewModels, LiveData,

00:11:19.600 --> 00:11:22.100
and the Room Database to
significantly simplify

00:11:22.100 --> 00:11:25.460
the way we manage data and
have it interact properly

00:11:25.460 --> 00:11:28.200
with the activity lifecycle.

00:11:28.200 --> 00:11:32.180
We also have the JobScheduler,
which almost entirely

00:11:32.180 --> 00:11:35.570
eliminates the need to create
your own custom background

00:11:35.570 --> 00:11:37.910
services and the
intent receivers

00:11:37.910 --> 00:11:41.340
that we sometimes set up to
monitor device state to control

00:11:41.340 --> 00:11:44.480
when our services are
run, which is a good thing

00:11:44.480 --> 00:11:47.690
because in Android 0 we
actually deprecated the ability

00:11:47.690 --> 00:11:49.670
to have long running
background services

00:11:49.670 --> 00:11:51.877
when your app is in
the background as well.

00:11:51.877 --> 00:11:53.960
And at the same time, most
of the intent receivers

00:11:53.960 --> 00:11:55.876
that you may have used
to monitor device state

00:11:55.876 --> 00:11:59.065
have also largely
been deprecated.

00:11:59.065 --> 00:12:01.190
Another good thing, of
course, things move quickly.

00:12:01.190 --> 00:12:05.120
JobScheduler already deprecated
as of yesterday morning.

00:12:07.790 --> 00:12:09.830
So now we have
Work Manager, which

00:12:09.830 --> 00:12:12.200
is nice because it does the
same stuff as JobScheduler,

00:12:12.200 --> 00:12:13.235
but it's backwards compatible.

00:12:13.235 --> 00:12:13.770
All right?

00:12:13.770 --> 00:12:16.160
So you're starting to see
some of the trends of what

00:12:16.160 --> 00:12:18.807
we're trying to achieve here.

00:12:18.807 --> 00:12:21.140
So we should dig into some
of this stuff in a little bit

00:12:21.140 --> 00:12:22.589
more detail.

00:12:22.589 --> 00:12:25.130
And something which I've talked
about it most of these Protip

00:12:25.130 --> 00:12:28.040
sessions was the first thing
I talked about and comes up

00:12:28.040 --> 00:12:32.480
every year, I like
to focus on what's

00:12:32.480 --> 00:12:33.897
happening in the background.

00:12:37.240 --> 00:12:41.110
Sometimes it's easy to miss
until you really focus on it.

00:12:41.110 --> 00:12:46.189
So the first Protip
I gave, back in 2010,

00:12:46.189 --> 00:12:47.730
first session, first
Android session,

00:12:47.730 --> 00:12:50.561
first real session on a big
stage, was very exciting.

00:12:50.561 --> 00:12:51.810
And this was the first Protip.

00:12:51.810 --> 00:12:53.700
So I thought let's have
a look at what I said,

00:12:53.700 --> 00:12:54.908
and see how well it holds up.

00:12:54.908 --> 00:12:57.114
So this is the first
thing I ever advised.

00:12:57.114 --> 00:12:57.780
[VIDEO PLAYBACK]

00:12:57.780 --> 00:12:59.720
- So it's important
that you move anything

00:12:59.720 --> 00:13:02.400
which can in any way take
longer than just a fraction

00:13:02.400 --> 00:13:04.830
of a second and interrupt
the UI flow that you move it

00:13:04.830 --> 00:13:06.207
into a background thread.

00:13:06.207 --> 00:13:08.040
So there's a number of
ways you can do that.

00:13:08.040 --> 00:13:09.840
The most simple
and straightforward

00:13:09.840 --> 00:13:11.790
is, of course, just
to use Java Threading.

00:13:11.790 --> 00:13:15.570
What we've created in Android
is a task called async task.

00:13:15.570 --> 00:13:16.510
[END PLAYBACK]

00:13:16.510 --> 00:13:18.390
[CHEERS AND APPLAUSE]

00:13:22.352 --> 00:13:24.060
RETO MEIER: Yeah, you
know what they say,

00:13:24.060 --> 00:13:28.830
the giant screen actually
removes 20 pounds.

00:13:28.830 --> 00:13:32.310
So it's kind of true.

00:13:32.310 --> 00:13:32.810
Right?

00:13:32.810 --> 00:13:35.610
Like, kind of, like we don't
want to block the UI thread.

00:13:35.610 --> 00:13:37.790
But the context around
what I was talking about

00:13:37.790 --> 00:13:40.040
was trying to eliminate
these application

00:13:40.040 --> 00:13:43.520
not responding dialogs, which
have evolved over the years.

00:13:43.520 --> 00:13:45.470
They look a little
bit different now.

00:13:45.470 --> 00:13:47.150
They used to be very
common because it

00:13:47.150 --> 00:13:49.200
was easy to block the
foreground thread.

00:13:49.200 --> 00:13:49.700
Right?

00:13:49.700 --> 00:13:51.590
If you tried to do
a data transfer,

00:13:51.590 --> 00:13:55.020
for example, it would block and
that would be a bad experience.

00:13:55.020 --> 00:13:58.440
And so for Android 3.0, we
introduced a runtime exception.

00:13:58.440 --> 00:14:00.620
So if you tried to
access the internet

00:14:00.620 --> 00:14:02.930
through our runtime exception,
the app would crash.

00:14:02.930 --> 00:14:05.644
Strong encouragement for
developers to not do that.

00:14:05.644 --> 00:14:07.310
More recently, we've
done similar things

00:14:07.310 --> 00:14:11.130
with file system access with
database access as well.

00:14:11.130 --> 00:14:13.940
Now, in Android P this
is no longer a problem

00:14:13.940 --> 00:14:16.190
because we don't
show ANR dialogs.

00:14:16.190 --> 00:14:17.960
We just crash the app.

00:14:17.960 --> 00:14:21.160
So that's not a better
outcome for your users.

00:14:21.160 --> 00:14:23.420
But it's a much stronger
signal to us as developers

00:14:23.420 --> 00:14:25.640
that we need to make sure
that we're taking care

00:14:25.640 --> 00:14:27.900
of this particular problem.

00:14:27.900 --> 00:14:29.750
Now, I did mention one
solution, and it got

00:14:29.750 --> 00:14:34.520
some love, the old async task.

00:14:34.520 --> 00:14:37.490
It's a reasonable solution
to the stated problem.

00:14:37.490 --> 00:14:39.629
We need to move everything
off the foreground

00:14:39.629 --> 00:14:40.670
onto a background thread.

00:14:40.670 --> 00:14:42.170
And that's what async task does.

00:14:42.170 --> 00:14:43.970
Creates a background
thread, and then it

00:14:43.970 --> 00:14:46.490
has these two handlers
which are called.

00:14:46.490 --> 00:14:48.230
Marshall back to
the UI thread so you

00:14:48.230 --> 00:14:51.870
can update the UI when you've
got progress or a final result

00:14:51.870 --> 00:14:53.600
to display.

00:14:53.600 --> 00:14:55.820
I would like to tell you
that the only thing missing

00:14:55.820 --> 00:14:59.600
from that is that now you
have to write it in Kotlin.

00:14:59.600 --> 00:15:01.880
It's better.

00:15:01.880 --> 00:15:03.140
Kotlin looks nicer.

00:15:03.140 --> 00:15:05.120
It's certainly more concise.

00:15:05.120 --> 00:15:08.414
But you still have the
same fundamental problem,

00:15:08.414 --> 00:15:10.580
where if you're doing this
stuff within an activity,

00:15:10.580 --> 00:15:14.280
if the user rotates the phone,
it's all going to go wrong.

00:15:14.280 --> 00:15:14.780
Right?

00:15:14.780 --> 00:15:17.000
Your thread is going to get
killed, your async task.

00:15:17.000 --> 00:15:19.050
And that's kind of your
best case scenario.

00:15:19.050 --> 00:15:20.120
You may leak context.

00:15:20.120 --> 00:15:22.100
You may try and
update a UI element

00:15:22.100 --> 00:15:24.740
that just doesn't exist, or
is in the process of getting

00:15:24.740 --> 00:15:26.330
killed and recreated.

00:15:26.330 --> 00:15:28.170
It's problematic.

00:15:28.170 --> 00:15:30.440
Now, back in that
first I/O session,

00:15:30.440 --> 00:15:32.200
I had a solution for this.

00:15:32.200 --> 00:15:33.200
It was a great solution.

00:15:33.200 --> 00:15:35.780
The advice was
you should move it

00:15:35.780 --> 00:15:40.610
to a service, which it's fair
to say this advice has not

00:15:40.610 --> 00:15:42.770
aged spectacularly well.

00:15:42.770 --> 00:15:46.650
Now, the general principle
is still pretty reasonable.

00:15:46.650 --> 00:15:47.150
Right?

00:15:47.150 --> 00:15:48.899
It's like you have
something long running,

00:15:48.899 --> 00:15:50.690
so you're in your
activity, you use

00:15:50.690 --> 00:15:53.690
an intent to start a service,
probably an intent service.

00:15:53.690 --> 00:15:55.770
And that goes and does
the time consuming work.

00:15:55.770 --> 00:15:58.280
Maybe it's pulling
something down from a server

00:15:58.280 --> 00:16:00.170
or interacting with a
database or performing

00:16:00.170 --> 00:16:02.210
some complex calculation.

00:16:02.210 --> 00:16:05.190
And when it's finished, it sends
an intent back to the activity.

00:16:05.190 --> 00:16:08.780
And it then updates
the UI accordingly.

00:16:08.780 --> 00:16:09.600
Basic stuff.

00:16:09.600 --> 00:16:11.760
And it's a reasonable approach.

00:16:11.760 --> 00:16:14.630
But it does introduce
some new challenges.

00:16:14.630 --> 00:16:16.380
Services are
heavyweight components.

00:16:16.380 --> 00:16:16.880
Right?

00:16:16.880 --> 00:16:18.190
We don't really
want to create them.

00:16:18.190 --> 00:16:19.981
We want to kill them
as quickly as possible

00:16:19.981 --> 00:16:23.242
to gain back some of
their system resources.

00:16:23.242 --> 00:16:25.700
And they keep running, even
when your activity isn't, which

00:16:25.700 --> 00:16:27.110
is kind of the point.

00:16:27.110 --> 00:16:30.320
But now you have to keep in
mind your activity lifecycle.

00:16:30.320 --> 00:16:31.010
What's it doing?

00:16:31.010 --> 00:16:32.750
Have you actually
exited the app?

00:16:32.750 --> 00:16:34.820
Have you transitioned
to a new activity?

00:16:34.820 --> 00:16:36.200
Should the service keep running?

00:16:36.200 --> 00:16:37.319
Should it be canceled?

00:16:37.319 --> 00:16:39.110
All of this stuff you
need to keep in mind.

00:16:39.110 --> 00:16:40.530
And it's doable.

00:16:40.530 --> 00:16:44.319
It's just a lot of
work to get right.

00:16:44.319 --> 00:16:46.610
And of course, because services
run at a high priority,

00:16:46.610 --> 00:16:49.160
it actually prevents the
system from killing your app

00:16:49.160 --> 00:16:50.637
to gain resources
if it needs to.

00:16:50.637 --> 00:16:52.970
And there's no guarantee that
your service will actually

00:16:52.970 --> 00:16:56.030
keep running if your
app is forced quit.

00:16:56.030 --> 00:17:00.170
So there's another problem,
which is in Android O,

00:17:00.170 --> 00:17:02.840
you can't guarantee that your
background services will be

00:17:02.840 --> 00:17:04.130
running when you want them to.

00:17:04.130 --> 00:17:05.690
You can't start a
background service

00:17:05.690 --> 00:17:07.550
when your app is in the
background from a broadcast

00:17:07.550 --> 00:17:07.940
receiver.

00:17:07.940 --> 00:17:09.710
And they will be killed
after a few minutes,

00:17:09.710 --> 00:17:11.834
even if they were initiated
while your activity was

00:17:11.834 --> 00:17:14.609
in the foreground.

00:17:14.609 --> 00:17:17.089
Now, for really
time-consuming things,

00:17:17.089 --> 00:17:22.220
which you need to have run, this
is still a reasonable approach.

00:17:22.220 --> 00:17:24.319
You have an activity,
uses the service

00:17:24.319 --> 00:17:27.220
to then download
data from a server,

00:17:27.220 --> 00:17:29.720
say, nice time-consuming
operation.

00:17:29.720 --> 00:17:31.577
And then that saves
it to a database.

00:17:31.577 --> 00:17:33.660
And then your activity
just monitors the database.

00:17:33.660 --> 00:17:36.170
So it's kind of a one-way
flow, which is nice.

00:17:36.170 --> 00:17:37.880
But there is a catch.

00:17:37.880 --> 00:17:39.800
There's always a catch.

00:17:39.800 --> 00:17:42.920
And the catch is that this
is not an efficient way

00:17:42.920 --> 00:17:44.285
to use the cell radio.

00:17:44.285 --> 00:17:47.280
And back in 2012, I'm not going
to go into too much detail,

00:17:47.280 --> 00:17:50.356
but I had this whole spiel
about how the cell radio works.

00:17:50.356 --> 00:17:51.730
And every time
you do a transfer,

00:17:51.730 --> 00:17:52.940
it turns on the radio.

00:17:52.940 --> 00:17:56.270
It stays in a standby state,
which draws more power.

00:17:56.270 --> 00:18:00.260
And the goal is that it reduces
latency for future transfers.

00:18:00.260 --> 00:18:01.517
That's all great.

00:18:01.517 --> 00:18:03.350
And the reason it's
important for us to know

00:18:03.350 --> 00:18:05.820
is that if you're doing
lots of transfers,

00:18:05.820 --> 00:18:07.610
you can keep the
radio turned on.

00:18:07.610 --> 00:18:09.450
It's going to draw
power more quickly.

00:18:09.450 --> 00:18:12.200
So we have some specific
advice for this, which

00:18:12.200 --> 00:18:15.470
was you should deal with that.

00:18:15.470 --> 00:18:17.120
You know how it works now.

00:18:17.120 --> 00:18:21.270
Efficiency is
important, so fix it.

00:18:21.270 --> 00:18:23.240
I had this whole
metaphor to help.

00:18:23.240 --> 00:18:24.170
It was about cookies.

00:18:24.170 --> 00:18:26.420
I have a friend who's an
artist, and this is an excuse

00:18:26.420 --> 00:18:28.070
to get him to draw things.

00:18:28.070 --> 00:18:30.590
And the idea here was to
use the big cookie model

00:18:30.590 --> 00:18:32.870
where you're minimizing the
total number of transfers

00:18:32.870 --> 00:18:35.335
that you are using
across the app lifecycle.

00:18:35.335 --> 00:18:37.460
So if you have something
that's not time sensitive,

00:18:37.460 --> 00:18:40.190
like analytics, you
queue that up and wait.

00:18:40.190 --> 00:18:43.730
Next time there's a
user initiated refresh,

00:18:43.730 --> 00:18:46.420
you send all of the queued data.

00:18:46.420 --> 00:18:48.410
You also look into
the future to see

00:18:48.410 --> 00:18:50.570
is there anything which
is going to be scheduled

00:18:50.570 --> 00:18:53.170
to happen in a few minutes,
and let's just do that first.

00:18:53.170 --> 00:18:56.489
So it was a way to
manually batch and bundle

00:18:56.489 --> 00:18:59.030
all of your transfers so that
they happened at the same time,

00:18:59.030 --> 00:19:02.780
and you get some
increased efficiency.

00:19:02.780 --> 00:19:06.650
As I'm sure you can
believe, doing all of this

00:19:06.650 --> 00:19:08.410
and understanding
how to do it right

00:19:08.410 --> 00:19:12.770
was complicated enough that
a roomful of engineers, much

00:19:12.770 --> 00:19:15.590
like yourselves, back
at Moscone believed

00:19:15.590 --> 00:19:18.230
that this was a
legitimate equation you

00:19:18.230 --> 00:19:19.850
needed to solve in
order to figure out

00:19:19.850 --> 00:19:21.810
how to do this right.

00:19:21.810 --> 00:19:22.310
It's not.

00:19:22.310 --> 00:19:25.010
This is just made up.

00:19:25.010 --> 00:19:27.757
By 2012, we had a
solution-- a solution,

00:19:27.757 --> 00:19:28.840
which was the SyncAdapter.

00:19:28.840 --> 00:19:33.270
And the SyncAdapter we claimed
was pretty straightforward,

00:19:33.270 --> 00:19:36.470
which is fair to say was a lie.

00:19:39.920 --> 00:19:42.150
Now, it's still better
than doing it all yourself.

00:19:42.150 --> 00:19:45.210
Once you set it up, it's
not that complicated.

00:19:45.210 --> 00:19:45.710
Right?

00:19:45.710 --> 00:19:48.890
You're able to trigger a
one-off for a periodic transfer.

00:19:48.890 --> 00:19:52.550
And a SyncAdapter will handle
all of the background work,

00:19:52.550 --> 00:19:54.050
doing the batching
and time shifting

00:19:54.050 --> 00:19:56.322
form multiple of your
requests that happen

00:19:56.322 --> 00:19:57.530
within a sort of time window.

00:19:57.530 --> 00:19:59.738
So you don't have to think
about when you trigger it.

00:19:59.738 --> 00:20:01.720
You just do and
trust the SyncAdapter

00:20:01.720 --> 00:20:04.640
to handle the timing for you.

00:20:04.640 --> 00:20:07.070
Unfortunately, to
make this work you

00:20:07.070 --> 00:20:10.820
needed to have a
SyncAdapter, fair enough.

00:20:10.820 --> 00:20:13.610
SyncAdapter runs
within its own service.

00:20:13.610 --> 00:20:17.720
Of course, you also need to have
an Account Manager, which isn't

00:20:17.720 --> 00:20:19.220
used, but is part of the API.

00:20:19.220 --> 00:20:22.160
And the Account Authenticator
also needs its own service

00:20:22.160 --> 00:20:23.030
to run in.

00:20:23.030 --> 00:20:23.530
OK.

00:20:23.530 --> 00:20:24.710
I'm seeing a trend.

00:20:24.710 --> 00:20:26.840
You also need to have
a content provider.

00:20:26.840 --> 00:20:29.900
Again, doesn't need to be
used, but needs to exist.

00:20:29.900 --> 00:20:32.300
You do all of this,
write it all in Java,

00:20:32.300 --> 00:20:34.522
and then there's
maybe a dozen XML

00:20:34.522 --> 00:20:36.980
files you need to write as
well, plus the manifest changes.

00:20:36.980 --> 00:20:41.900
And then you're good to
go, your SyncAdapter works.

00:20:41.900 --> 00:20:45.050
It's fair to say that a lot of
people trying to make this work

00:20:45.050 --> 00:20:49.640
found it to be kind
of frustrating.

00:20:49.640 --> 00:20:53.540
And of course, it only batched
and bundled your transfers

00:20:53.540 --> 00:20:58.070
within your own app, which
is why 2013, great year,

00:20:58.070 --> 00:21:01.210
Android 5, we introduced
the JobScheduler API,

00:21:01.210 --> 00:21:03.210
which has now been replaced.

00:21:03.210 --> 00:21:05.180
JobScheduler works at
the platform level.

00:21:05.180 --> 00:21:06.680
So it does the
batching and bundling

00:21:06.680 --> 00:21:09.620
for all of the apps
at the same time

00:21:09.620 --> 00:21:13.130
to be able to take advantage not
just of several radio battery

00:21:13.130 --> 00:21:16.199
improvements, but all of
the resource improvements

00:21:16.199 --> 00:21:18.740
that we're trying to do, things
like stand by and [INAUDIBLE]

00:21:18.740 --> 00:21:19.760
mode and all of this.

00:21:23.190 --> 00:21:26.750
So within your app, you
create a new job service

00:21:26.750 --> 00:21:29.870
that does the asynchronous
background updates.

00:21:29.870 --> 00:21:31.746
In this case, we're
using the AsyncTask,

00:21:31.746 --> 00:21:34.370
which we can use now because we
don't have the same memory leak

00:21:34.370 --> 00:21:35.610
problems.

00:21:35.610 --> 00:21:37.460
And then within your
specific activity,

00:21:37.460 --> 00:21:39.110
you just define the
criteria that you

00:21:39.110 --> 00:21:41.497
need in order for that job
to be successfully executed.

00:21:41.497 --> 00:21:43.830
If it needs to be on the
interent, needs to be charging,

00:21:43.830 --> 00:21:45.230
et cetera.

00:21:45.230 --> 00:21:46.140
How urgent is it?

00:21:46.140 --> 00:21:47.390
What is your preferred timing?

00:21:47.390 --> 00:21:48.110
Is it periodic?

00:21:48.110 --> 00:21:49.830
All of that sort of stuff.

00:21:49.830 --> 00:21:51.740
And the JobScheduler
will then handle

00:21:51.740 --> 00:21:53.840
all of the background
work for you

00:21:53.840 --> 00:21:56.360
in the most efficient
way possible.

00:21:56.360 --> 00:21:59.090
The only thing which would be
better than the JobScheduler

00:21:59.090 --> 00:22:02.960
is if it worked in a backwards
compatible way, which

00:22:02.960 --> 00:22:07.580
is why we launched Work Manager,
which is part of JetPack.

00:22:07.580 --> 00:22:10.310
Now, to use Work Manager, it
works basically the same way.

00:22:10.310 --> 00:22:11.870
You create a new
worker, and that

00:22:11.870 --> 00:22:13.760
is where you are
defining the background

00:22:13.760 --> 00:22:15.770
work that needs to be done.

00:22:15.770 --> 00:22:17.990
And then within your activity,
you do the same thing.

00:22:17.990 --> 00:22:19.550
You specify the
constraints that need

00:22:19.550 --> 00:22:22.160
to be met before this
work can be accomplished.

00:22:22.160 --> 00:22:25.220
And then WorkManager will
handle all of this for you

00:22:25.220 --> 00:22:27.110
in the background,
same as JobScheduler.

00:22:27.110 --> 00:22:31.520
But it now also encapsulates
the best practice solution

00:22:31.520 --> 00:22:33.590
for earlier platform releases.

00:22:33.590 --> 00:22:35.780
I think it goes back to 4.4.

00:22:35.780 --> 00:22:37.850
So it'll use the latest
and greatest JobScheduler

00:22:37.850 --> 00:22:40.430
if you're running on the latest
platform, all the way back

00:22:40.430 --> 00:22:43.820
to probably AlarmManager, for
some of the earlier platform

00:22:43.820 --> 00:22:44.714
releases.

00:22:44.714 --> 00:22:46.130
And again, you
don't need to write

00:22:46.130 --> 00:22:48.980
any of that boilerplate code
for backwards compatibility.

00:22:48.980 --> 00:22:50.075
We do all of that for you.

00:22:50.075 --> 00:22:51.950
You don't have to maintain
it, find the bugs,

00:22:51.950 --> 00:22:52.820
find the edge cases.

00:22:52.820 --> 00:22:55.114
You can rely on WorkManager
to take care of that.

00:22:55.114 --> 00:22:56.780
And of course, this
is going to continue

00:22:56.780 --> 00:22:58.500
to improve in future releases.

00:22:58.500 --> 00:23:01.370
So as JobScheduler continues
to improve on the platform,

00:23:01.370 --> 00:23:04.610
WorkManager is going to be able
to evolve to take advantage

00:23:04.610 --> 00:23:07.380
of some of those changes.

00:23:07.380 --> 00:23:09.320
You can learn all
about WorkManager.

00:23:09.320 --> 00:23:13.540
And stage two today at 5:30,
I recommend going along.

00:23:13.540 --> 00:23:17.150
It's a really cool new API.

00:23:17.150 --> 00:23:19.430
So WorkManager,
it's great if it's

00:23:19.430 --> 00:23:21.350
something which is
genuinely time consuming,

00:23:21.350 --> 00:23:24.462
and it needs to be initiated
on the client side.

00:23:24.462 --> 00:23:26.420
Now, one of the things
which we've always said,

00:23:26.420 --> 00:23:29.010
and which really hasn't changed
is that wherever possible,

00:23:29.010 --> 00:23:31.100
you should eliminate
periodic refreshes.

00:23:31.100 --> 00:23:33.740
And any updates that need
to happen based on changes

00:23:33.740 --> 00:23:36.830
on the server side should
be initiated by the server,

00:23:36.830 --> 00:23:39.760
preferably using
Google Cloud Messaging.

00:23:39.760 --> 00:23:43.670
By which, of course, I mean
Firebase Cloud Messaging,

00:23:43.670 --> 00:23:46.640
because GCM was
deprecated in April.

00:23:46.640 --> 00:23:48.350
Things move quickly.

00:23:48.350 --> 00:23:50.300
Now, Firebase Cloud
Messaging takes

00:23:50.300 --> 00:23:54.794
advantage of the same scalable,
reliable GCM infrastructure

00:23:54.794 --> 00:23:56.210
that we've been
using in the past,

00:23:56.210 --> 00:24:00.110
but also improves delivery
reporting and reliability.

00:24:00.110 --> 00:24:03.440
It also adds a web console
so you can send notifications

00:24:03.440 --> 00:24:09.240
to your apps without having to
have your own server instance.

00:24:09.240 --> 00:24:12.380
Now, for transfers, this gives
us a pretty good solution.

00:24:12.380 --> 00:24:14.810
But there's really
no way that this

00:24:14.810 --> 00:24:17.240
is a viable solution for
being able to maintain

00:24:17.240 --> 00:24:20.680
a small amount of data
whenever the phone rotates.

00:24:20.680 --> 00:24:23.780
And for that matter, using
singletons or overwriting

00:24:23.780 --> 00:24:26.990
the application class,
which I may or may not

00:24:26.990 --> 00:24:31.670
have said in previous
years, is similarly

00:24:31.670 --> 00:24:34.850
considered somewhat distasteful.

00:24:34.850 --> 00:24:39.600
So which is why in
Android 3.0, we introduced

00:24:39.600 --> 00:24:42.012
headless fragments and loaders.

00:24:42.012 --> 00:24:44.870
I assume everyone is
familiar with both of these.

00:24:47.760 --> 00:24:49.920
Fragments were designed
to break your UI up

00:24:49.920 --> 00:24:53.100
into chunks that were
independent, reusable,

00:24:53.100 --> 00:24:54.780
and interchangeable.

00:24:54.780 --> 00:24:58.710
And the key was they were also
aware of the parent activity

00:24:58.710 --> 00:25:00.340
lifecycle.

00:25:00.340 --> 00:25:03.210
Now, the trick with
headless fragments

00:25:03.210 --> 00:25:04.770
was that they didn't have a UI.

00:25:04.770 --> 00:25:08.340
So you could configure them to
be retained across an activity

00:25:08.340 --> 00:25:10.497
restart based on a
configuration change.

00:25:10.497 --> 00:25:12.330
And this is really nice
because it meant now

00:25:12.330 --> 00:25:14.850
we have some way to store
our data model that's

00:25:14.850 --> 00:25:17.280
independent of the
activity being recreated

00:25:17.280 --> 00:25:20.570
every time the
configuration changes.

00:25:20.570 --> 00:25:23.430
But managing
fragments was tricky.

00:25:23.430 --> 00:25:25.320
And if you attended the
first Android session

00:25:25.320 --> 00:25:28.650
this morning here, you see
just how tricky it was.

00:25:28.650 --> 00:25:31.440
You can add and remove
fragments from any activity.

00:25:31.440 --> 00:25:33.930
You can have multiple
instances of the same fragment

00:25:33.930 --> 00:25:36.250
within the same activity.

00:25:36.250 --> 00:25:38.860
The fragment transactions
are all done asynchronously.

00:25:38.860 --> 00:25:41.250
So you can't guarantee
when something is there.

00:25:41.250 --> 00:25:43.440
And it's got its own
life cycle to manage.

00:25:43.440 --> 00:25:45.010
Now, none of this was great.

00:25:45.010 --> 00:25:45.510
All right?

00:25:45.510 --> 00:25:47.218
You were able to
achieve what you wanted,

00:25:47.218 --> 00:25:51.750
but it was complicated
to make this all work.

00:25:51.750 --> 00:25:55.000
Now loading, loading was better.

00:25:55.000 --> 00:25:58.530
Loaders made it easier to
asynchronously load data

00:25:58.530 --> 00:26:00.631
within your fragments
and activities.

00:26:00.631 --> 00:26:02.130
And then you could
observe and react

00:26:02.130 --> 00:26:05.584
to changes in the loader
within the activity

00:26:05.584 --> 00:26:07.500
based on whenever the
underlying data changed.

00:26:07.500 --> 00:26:10.500
And in most cases, you had to
handle all of that plumbing

00:26:10.500 --> 00:26:13.500
yourself, which meant you needed
to load the data from wherever

00:26:13.500 --> 00:26:14.730
it was stored.

00:26:14.730 --> 00:26:17.700
You needed to then observe
changes within that underlying

00:26:17.700 --> 00:26:19.750
data and bubble it back
up through the loader

00:26:19.750 --> 00:26:21.333
so that you could
have the simple code

00:26:21.333 --> 00:26:26.440
in your activity, which was
unless you used CursorLoader.

00:26:26.440 --> 00:26:29.460
Now, CursorLoader was great
because it did most of the work

00:26:29.460 --> 00:26:30.840
for you.

00:26:30.840 --> 00:26:33.420
You initialized the loader
within the activity or fragment

00:26:33.420 --> 00:26:34.860
at creation time.

00:26:34.860 --> 00:26:37.560
And then you just filled
in a number of callbacks

00:26:37.560 --> 00:26:40.740
to create a new cursor and
then to receive the results

00:26:40.740 --> 00:26:43.420
so that you can update
the UI accordingly.

00:26:43.420 --> 00:26:46.619
Now, initializing a CursorLoader
was pretty straightforward.

00:26:46.619 --> 00:26:48.660
You pass in the authority
of the content provider

00:26:48.660 --> 00:26:50.451
that you want to query
in the SQL statement

00:26:50.451 --> 00:26:53.160
that you want to use to
get back your results.

00:26:53.160 --> 00:26:55.442
All that gets passed
into a ContentResolver.

00:26:55.442 --> 00:26:57.150
It goes to your content
provider and gets

00:26:57.150 --> 00:27:01.747
you back a cursor that you can
then use to update your UI.

00:27:01.747 --> 00:27:03.330
But by definition,
that meant that you

00:27:03.330 --> 00:27:05.350
needed to make your data
available via a content

00:27:05.350 --> 00:27:05.850
provider.

00:27:09.022 --> 00:27:10.980
Actually, you know what,
I'm going to come back

00:27:10.980 --> 00:27:12.060
to content providers.

00:27:12.060 --> 00:27:16.000
I'm just going to leave
them there for a moment.

00:27:16.000 --> 00:27:16.500
OK.

00:27:16.500 --> 00:27:17.732
So take a step back.

00:27:17.732 --> 00:27:19.440
We've got headless
fragments and loaders.

00:27:19.440 --> 00:27:21.570
And technically, that
enables us to do everything

00:27:21.570 --> 00:27:23.607
that we need to do.

00:27:23.607 --> 00:27:24.690
There's a problem, though.

00:27:24.690 --> 00:27:27.420
It's really hard to get
them to work together,

00:27:27.420 --> 00:27:29.880
understand how to make them
work across multiple activities

00:27:29.880 --> 00:27:33.060
and fragments and the various
different implementations

00:27:33.060 --> 00:27:34.140
of both.

00:27:34.140 --> 00:27:37.260
In fact, getting it all to
work reliably and well was,

00:27:37.260 --> 00:27:39.810
again, it was
frustrating, which is

00:27:39.810 --> 00:27:42.330
why we're all so excited
to see Android Architecture

00:27:42.330 --> 00:27:43.830
Components.

00:27:43.830 --> 00:27:45.990
Android Architecture
Components introduced

00:27:45.990 --> 00:27:49.380
ViewModels, LiveData,
and the room database.

00:27:49.380 --> 00:27:51.790
And this all effectively
replaces fragments and loaders

00:27:51.790 --> 00:27:56.630
as a simple way to separate
your UI and your UI data.

00:27:56.630 --> 00:28:00.060
The ViewModel itself is actually
really simple to create.

00:28:00.060 --> 00:28:02.451
You start with a property
that stores the data

00:28:02.451 --> 00:28:03.450
that you want to expose.

00:28:03.450 --> 00:28:06.040
In this case, we're
using a mutable LiveData

00:28:06.040 --> 00:28:08.010
because LiveData is cool.

00:28:08.010 --> 00:28:09.630
And then you expose
a method, which is

00:28:09.630 --> 00:28:11.300
going to return that property.

00:28:11.300 --> 00:28:14.314
And so the first time it's
going to populate that property.

00:28:14.314 --> 00:28:16.730
And then from then on, it will
return that cached version.

00:28:20.950 --> 00:28:23.050
Then you have a method
which does that population.

00:28:23.050 --> 00:28:24.740
And again, this is
done asynchronously.

00:28:24.740 --> 00:28:27.100
In this case, again, we
are using our old friend

00:28:27.100 --> 00:28:28.870
the asynchronous task.

00:28:28.870 --> 00:28:32.350
Then whenever the value of the
immutable LiveData changes,

00:28:32.350 --> 00:28:34.510
that is going to
trigger any observers

00:28:34.510 --> 00:28:35.910
that you have attached to it.

00:28:35.910 --> 00:28:38.530
So back in your activity,
all you need to do

00:28:38.530 --> 00:28:40.480
is request the ViewModels.

00:28:40.480 --> 00:28:44.390
Ask for the specific ViewModel
class that you've just created.

00:28:44.390 --> 00:28:47.470
And then call that
ViewModel's data

00:28:47.470 --> 00:28:50.950
access method, which will
either then populate the data

00:28:50.950 --> 00:28:52.030
and return it.

00:28:52.030 --> 00:28:54.490
Either way, you'd add
an observer to that.

00:28:54.490 --> 00:28:55.930
And then your
observed trigger is

00:28:55.930 --> 00:28:58.330
going to get called, both
the first time you attach

00:28:58.330 --> 00:29:01.390
the observer and then any
time the underlying LiveData

00:29:01.390 --> 00:29:03.640
changes.

00:29:03.640 --> 00:29:05.980
Now, the beauty of
ViewModels is that they

00:29:05.980 --> 00:29:07.310
survive activity restart.

00:29:07.310 --> 00:29:10.440
So we don't have to deal with
that particular scenario.

00:29:10.440 --> 00:29:13.240
And the beauty of LiveData
is that it understands

00:29:13.240 --> 00:29:15.280
the activity lifecycle.

00:29:15.280 --> 00:29:18.970
So the first time
the app is run,

00:29:18.970 --> 00:29:22.210
your ViewModel gets created,
populates the LiveData

00:29:22.210 --> 00:29:25.450
from the underlying data
source, sends the results back

00:29:25.450 --> 00:29:28.150
via the ObserveHandler
within your activity.

00:29:28.150 --> 00:29:31.960
And then if someone
rotates their phone,

00:29:31.960 --> 00:29:34.300
the activity gets
destroyed, gets recreated,

00:29:34.300 --> 00:29:37.330
but the existing
ViewModel is returned.

00:29:37.330 --> 00:29:40.660
The existing Data is returned
via the ObserveHandler.

00:29:40.660 --> 00:29:43.160
And it's triggered with the
latest version of the data,

00:29:43.160 --> 00:29:46.540
whether it's been updated
or not in the interim.

00:29:46.540 --> 00:29:48.400
In fact, LiveData
is really smart

00:29:48.400 --> 00:29:52.900
because it only sends updates
via the ObserveHandler

00:29:52.900 --> 00:29:54.280
when the activity is active.

00:29:54.280 --> 00:29:57.220
Because you don't need to update
the activity if the UI isn't

00:29:57.220 --> 00:30:00.170
actually visible.

00:30:00.170 --> 00:30:03.040
So if there is new data, it
will wait and then transfer it

00:30:03.040 --> 00:30:06.590
once the activity
becomes active.

00:30:06.590 --> 00:30:09.550
As a total result, what we
do is we feel less like this

00:30:09.550 --> 00:30:15.240
and much more like this,
which is always our goal.

00:30:15.240 --> 00:30:16.975
Content providers.

00:30:16.975 --> 00:30:19.360
I promised I'd come back
to content providers.

00:30:19.360 --> 00:30:23.830
And just as some context,
this is what happens.

00:30:23.830 --> 00:30:25.465
This is the number
of students enrolled

00:30:25.465 --> 00:30:28.810
in each of the lessons of
our Android Eudacity class.

00:30:28.810 --> 00:30:31.630
And as you can see,
the highlighted columns

00:30:31.630 --> 00:30:34.409
are when we get to content
providers and loaders.

00:30:34.409 --> 00:30:36.700
So you get the impression
this is something that people

00:30:36.700 --> 00:30:38.560
find a little frustrating.

00:30:38.560 --> 00:30:39.790
We've improved it since then.

00:30:39.790 --> 00:30:41.800
It's not quite so grim now.

00:30:41.800 --> 00:30:43.750
And some of what we're
going to talk about now

00:30:43.750 --> 00:30:47.350
actually explains some
of those improvements.

00:30:47.350 --> 00:30:48.646
Why is it so frustrating?

00:30:48.646 --> 00:30:50.020
Well this is the
boilerplate code

00:30:50.020 --> 00:30:51.644
for creating a simple
content provider.

00:30:51.644 --> 00:30:54.740
I'm sure many of you have
built something like this.

00:30:54.740 --> 00:30:58.330
In truth, it's really just
the first couple of methods.

00:30:58.330 --> 00:30:59.870
It goes on for a little while.

00:30:59.870 --> 00:31:02.170
And now, keep in
mind, this isn't doing

00:31:02.170 --> 00:31:03.580
anything particularly special.

00:31:03.580 --> 00:31:06.130
It's just passing content
resolve requests straight

00:31:06.130 --> 00:31:08.450
through to a SQLite database.

00:31:08.450 --> 00:31:10.580
Now, obviously, that's
just the content provider.

00:31:10.580 --> 00:31:12.670
Then you need to
create a contract that

00:31:12.670 --> 00:31:15.460
defines the column names
that you want to use

00:31:15.460 --> 00:31:17.237
to be able to interact with it.

00:31:17.237 --> 00:31:19.570
Then, of course, you need to
create your own SQLite Open

00:31:19.570 --> 00:31:22.210
Helper, which is how you
create, update, and access

00:31:22.210 --> 00:31:24.130
the underlying database.

00:31:24.130 --> 00:31:26.560
Now, all of this
operates on cursors,

00:31:26.560 --> 00:31:30.040
which is probably not what
you're using in your UI.

00:31:30.040 --> 00:31:33.190
So you'll need to create a
class to represent the records

00:31:33.190 --> 00:31:34.960
in the database, just nice.

00:31:34.960 --> 00:31:36.910
It's actually quite
simple in Kotlin.

00:31:36.910 --> 00:31:40.390
But you'll also need code to
convert between those class

00:31:40.390 --> 00:31:44.519
objects and conent values
to add rows to your tables.

00:31:44.519 --> 00:31:46.060
And you'll need to
be able to convert

00:31:46.060 --> 00:31:48.316
between cursors and lists
of your class objects.

00:31:48.316 --> 00:31:49.690
Somewhere along
the line you need

00:31:49.690 --> 00:31:51.070
to set up a bunch
of observers so

00:31:51.070 --> 00:31:54.400
that if the database
changes, your list of objects

00:31:54.400 --> 00:31:56.260
also gets updated.

00:31:56.260 --> 00:31:58.540
It's a lot of code for
something which should

00:31:58.540 --> 00:32:00.340
be relatively straightforward.

00:32:00.340 --> 00:32:01.180
A quick one.

00:32:01.180 --> 00:32:05.750
Is there anyone here who
gets paid per line of code?

00:32:05.750 --> 00:32:06.250
No.

00:32:06.250 --> 00:32:06.950
OK.

00:32:06.950 --> 00:32:09.910
So if there is, and
you were just too shy,

00:32:09.910 --> 00:32:13.240
that old method actually
works really well.

00:32:13.240 --> 00:32:14.890
Stick with that.

00:32:14.890 --> 00:32:17.560
For the rest of us, this is
where the Room Database really

00:32:17.560 --> 00:32:19.180
comes into its own.

00:32:19.180 --> 00:32:22.360
So it's part of Android
Architecture Components, now

00:32:22.360 --> 00:32:23.290
part of Jetpack.

00:32:23.290 --> 00:32:24.880
And all you need
to do is you start

00:32:24.880 --> 00:32:26.180
with the class definition.

00:32:26.180 --> 00:32:26.920
Right?

00:32:26.920 --> 00:32:30.449
Defines the columns that
you want within your class.

00:32:30.449 --> 00:32:31.990
And you just add an
annotation to say

00:32:31.990 --> 00:32:34.690
this is an entity that I
want to use in a database.

00:32:34.690 --> 00:32:38.860
And this is the primary
key for this table.

00:32:38.860 --> 00:32:41.140
Then you create a
new Room Database,

00:32:41.140 --> 00:32:43.390
which includes
each of the tables

00:32:43.390 --> 00:32:45.410
that you want to have
within that database.

00:32:45.410 --> 00:32:49.330
And you return an instance
of the data access object.

00:32:49.330 --> 00:32:52.300
And that is the class where you
specify all of your database

00:32:52.300 --> 00:32:54.430
interactions-- your
inserts, deletes, updates,

00:32:54.430 --> 00:32:55.709
and your queries--

00:32:55.709 --> 00:32:58.000
as many of them as you want
in as many different styles

00:32:58.000 --> 00:32:59.150
as you want.

00:32:59.150 --> 00:33:02.740
Now, you'll notice that the
queries here return LiveData.

00:33:02.740 --> 00:33:05.620
And that's really cool because
if you're storing your UI data

00:33:05.620 --> 00:33:07.770
in your ViewModel,
which obviously you

00:33:07.770 --> 00:33:09.940
are because that's the
right way to do things now.

00:33:09.940 --> 00:33:13.240
It actually simplifies that
ViewModel significantly.

00:33:13.240 --> 00:33:16.300
You just request access to
the Room Database's access

00:33:16.300 --> 00:33:21.320
object, execute the query,
which returns LiveData itself.

00:33:21.320 --> 00:33:23.750
Then you just pass that
LiveData right back through

00:33:23.750 --> 00:33:26.480
to any activity or
fragment which requests it.

00:33:26.480 --> 00:33:28.470
Back in the activity,
it works the same way.

00:33:28.470 --> 00:33:30.420
You've got the
same ObserveHandler

00:33:30.420 --> 00:33:33.440
getting the same
LiveData representing

00:33:33.440 --> 00:33:34.949
a collection of objects.

00:33:34.949 --> 00:33:37.490
And you can use that to update
the UI whenever the underlying

00:33:37.490 --> 00:33:39.140
database changes.

00:33:39.140 --> 00:33:41.690
So you've got the same outcome
that you did before, but

00:33:41.690 --> 00:33:44.210
10 times less boilerplate code.

00:33:44.210 --> 00:33:46.730
10 times less code that you
have to maintain and alter.

00:33:46.730 --> 00:33:48.560
If you change a column
name, beforehand, it

00:33:48.560 --> 00:33:51.170
was a lot of places
that could go wrong.

00:33:51.170 --> 00:33:54.260
Now, you just modify the class.

00:33:54.260 --> 00:33:57.080
Now, if you combine that
with the WorkManager,

00:33:57.080 --> 00:34:01.770
you actually get a really clean
solution to this whole process.

00:34:01.770 --> 00:34:02.270
Right?

00:34:02.270 --> 00:34:05.690
The WorkManager downloads
data from a server.

00:34:05.690 --> 00:34:07.880
It updates the Room
Database accordingly,

00:34:07.880 --> 00:34:10.310
which then sends the
LiveData to the ViewModel

00:34:10.310 --> 00:34:12.070
within the activity
and fragment,

00:34:12.070 --> 00:34:13.980
or fragment, that
you want to use,

00:34:13.980 --> 00:34:17.270
which then via the
ObserveHandler updates the UI.

00:34:17.270 --> 00:34:20.000
So if you're not one of the
lucky folks who are still

00:34:20.000 --> 00:34:21.800
getting paid by
line of code, this

00:34:21.800 --> 00:34:25.480
is probably a better solution.

00:34:25.480 --> 00:34:28.610
So speaking of better solutions,
what else have we got?

00:34:28.610 --> 00:34:31.219
I wanted to talk a little bit
about Android Location Services

00:34:31.219 --> 00:34:33.177
because this is, again,
a topic that I've spent

00:34:33.177 --> 00:34:34.939
a lot of time talking about.

00:34:37.670 --> 00:34:39.620
Being able to find
the current position

00:34:39.620 --> 00:34:42.800
and put it on a map
somewhere is something

00:34:42.800 --> 00:34:47.409
that's been part of Android
since the very first beta SDK.

00:34:47.409 --> 00:34:49.580
And so by 2011, I'd
actually managed

00:34:49.580 --> 00:34:52.310
to amass quite a
collection of Protips

00:34:52.310 --> 00:34:54.830
for how to take advantage
of the Location Manager

00:34:54.830 --> 00:34:57.540
in the most efficient and
effective way possible.

00:34:57.540 --> 00:35:01.970
It was a big topic in a couple
of my Android Protips talks.

00:35:01.970 --> 00:35:04.360
So I went to the
location team, said

00:35:04.360 --> 00:35:07.730
I've built a project which
encapsulates all of our best

00:35:07.730 --> 00:35:10.700
practices, all of the things
which we tell people to do.

00:35:10.700 --> 00:35:14.000
And it's fair to say
that they were impressed.

00:35:14.000 --> 00:35:16.940
By which I mean it really
left an impression.

00:35:16.940 --> 00:35:19.970
They then went away
and did what they do,

00:35:19.970 --> 00:35:21.740
which is fixed everything.

00:35:21.740 --> 00:35:24.320
And so where beforehand
I had all these classes

00:35:24.320 --> 00:35:29.360
and interfaces they went
away and gave me an API

00:35:29.360 --> 00:35:33.200
as part of the Fused
Location Provider, which

00:35:33.200 --> 00:35:34.790
does all the magic for you.

00:35:34.790 --> 00:35:37.700
It encapsulated all those best
practices within a small number

00:35:37.700 --> 00:35:40.130
of simple APIs.

00:35:40.130 --> 00:35:42.740
All you need to do here is
tell it what's more important,

00:35:42.740 --> 00:35:45.440
battery life or accuracy.

00:35:45.440 --> 00:35:47.120
How often do you
want to get results?

00:35:47.120 --> 00:35:49.400
And the Fused Location
Provider goes and does

00:35:49.400 --> 00:35:52.970
all of the hard work for you.

00:35:52.970 --> 00:35:55.280
Now, that said, things
have changed a little bit.

00:35:55.280 --> 00:35:57.520
In Oreo, we made some
changes, some new restrictions

00:35:57.520 --> 00:35:59.270
about how you can
receive location updates

00:35:59.270 --> 00:36:01.103
while your app is in
the background in order

00:36:01.103 --> 00:36:02.150
to save battery life.

00:36:02.150 --> 00:36:04.640
And specifically,
that means that if you

00:36:04.640 --> 00:36:06.590
are in the background,
you only received

00:36:06.590 --> 00:36:11.422
updates from Location Manager
or the FLP a few times an hour.

00:36:11.422 --> 00:36:13.380
There's a few ways that
you can deal with this.

00:36:13.380 --> 00:36:14.210
Right?

00:36:14.210 --> 00:36:15.890
You can make a
foreground service, which

00:36:15.890 --> 00:36:18.260
is what we do with navigation.

00:36:18.260 --> 00:36:21.770
Another approach is
to use geofences.

00:36:21.770 --> 00:36:24.290
So for those of you who
remember the very first version

00:36:24.290 --> 00:36:28.040
of geofencing on Android
were proximity alerts.

00:36:28.040 --> 00:36:31.730
Proximity alerts were bad.

00:36:31.730 --> 00:36:34.610
Easy enough to set up, specify
a lat long or radius around

00:36:34.610 --> 00:36:35.200
a point.

00:36:35.200 --> 00:36:37.580
And they would fairly
reliably trigger

00:36:37.580 --> 00:36:38.960
if you went across
that boundary.

00:36:38.960 --> 00:36:40.640
Now the challenge
was the way that it

00:36:40.640 --> 00:36:45.200
achieved that was by turning
on and leaving on your GPS.

00:36:45.200 --> 00:36:47.810
So as long as you had
a proximity alarm set,

00:36:47.810 --> 00:36:49.760
it would keep the GPS
running permanently,

00:36:49.760 --> 00:36:51.530
which is not what the
documentation said.

00:36:51.530 --> 00:36:54.220
But it is what happened.

00:36:54.220 --> 00:36:56.990
Now luckily, the same
Google Play services launch,

00:36:56.990 --> 00:36:59.030
which gave us the fused
location provider also

00:36:59.030 --> 00:37:01.210
gave us a real
geofencing API, which

00:37:01.210 --> 00:37:07.100
had all the functionality
that was claimed

00:37:07.100 --> 00:37:11.270
to be done with
proximity alerts but also

00:37:11.270 --> 00:37:14.330
gave you a few
additional improvements,

00:37:14.330 --> 00:37:17.420
the most important of which
was that it didn't keep

00:37:17.420 --> 00:37:20.180
the GPS locked permanently on.

00:37:20.180 --> 00:37:22.760
We can take our geofences
to the next level

00:37:22.760 --> 00:37:25.700
with the Awareness API,
which adds additional context

00:37:25.700 --> 00:37:29.540
signals, which allow us to
make more complicated fences.

00:37:29.540 --> 00:37:31.460
Specifically, we can
add date and time,

00:37:31.460 --> 00:37:34.650
proximity to beacons, user
activity, if they're walking,

00:37:34.650 --> 00:37:37.350
cycling, driving,
and device state.

00:37:37.350 --> 00:37:39.470
And you can combine all
those conditions together,

00:37:39.470 --> 00:37:42.350
such as in this example where
we have one fence, which

00:37:42.350 --> 00:37:45.260
is triggered if you drive
within 1,000 meters of a given

00:37:45.260 --> 00:37:48.200
location between 10 and six.

00:37:48.200 --> 00:37:50.120
We have a little
bit of time left.

00:37:50.120 --> 00:37:53.310
One thing I learned in 2018
is that there's a new way to--

00:37:53.310 --> 00:37:54.860
I'm sorry, that
should be there's

00:37:54.860 --> 00:37:57.110
a new way to control media.

00:37:57.110 --> 00:37:59.070
Right.

00:37:59.070 --> 00:38:01.550
Now back in the day,
controlling media playback

00:38:01.550 --> 00:38:02.870
was done with MediaPlayer.

00:38:02.870 --> 00:38:05.424
I'm going to buzz through
this pretty quickly.

00:38:05.424 --> 00:38:08.090
Mainly, it meant that you had to
listen to media buttons getting

00:38:08.090 --> 00:38:09.090
clicked.

00:38:09.090 --> 00:38:10.670
Now, of course, you
can control media

00:38:10.670 --> 00:38:12.260
a bunch of different ways.

00:38:12.260 --> 00:38:13.940
So we've got a better
solution, which

00:38:13.940 --> 00:38:17.470
is Exoplayer, which effectively
replaces the framework media

00:38:17.470 --> 00:38:20.126
players, easy to
customize and extend.

00:38:20.126 --> 00:38:22.500
Again, I'm not going to go
through the full details here.

00:38:22.500 --> 00:38:25.240
I had a couple of slides, but I
have been speaking too slowly.

00:38:25.240 --> 00:38:28.540
So I recommend that you go to
Mark and Andrew's talk tomorrow

00:38:28.540 --> 00:38:32.320
morning at 10:30 to
get all of the details.

00:38:32.320 --> 00:38:34.824
Now, not all of the changes
in Android have been in code.

00:38:34.824 --> 00:38:36.490
Some of the biggest
changes are actually

00:38:36.490 --> 00:38:38.890
in the availability
of Android expertise.

00:38:38.890 --> 00:38:42.441
Back when we started, we didn't
have Slack and Google developer

00:38:42.441 --> 00:38:42.940
experts.

00:38:42.940 --> 00:38:45.640
We didn't even have
Stack Overflow.

00:38:45.640 --> 00:38:47.200
What we did have was IRC.

00:38:47.200 --> 00:38:48.850
We had Google developer groups.

00:38:48.850 --> 00:38:51.160
We had some DevRel people,
which spoke at conferences.

00:38:51.160 --> 00:38:55.240
And that still kind of
happens, but the big change now

00:38:55.240 --> 00:38:58.600
is that we're just voices
within a much larger developer

00:38:58.600 --> 00:39:00.054
ecosystem.

00:39:00.054 --> 00:39:02.470
There are now lots and lots
of people around the world who

00:39:02.470 --> 00:39:03.260
help each other.

00:39:03.260 --> 00:39:06.400
This is just a small selection
of the 90 Google developer

00:39:06.400 --> 00:39:09.310
experts specializing
in Android and Kotlin

00:39:09.310 --> 00:39:10.270
all around the world.

00:39:10.270 --> 00:39:13.240
So this is just a small amount
of the extended engineering

00:39:13.240 --> 00:39:16.370
team that we have
helping the community.

00:39:16.370 --> 00:39:18.130
Similarly, we've got
Android conferences

00:39:18.130 --> 00:39:19.010
all around the world.

00:39:19.010 --> 00:39:21.640
This is a small selection of
some of the Android events

00:39:21.640 --> 00:39:24.490
that people pointed out to me
on Twitter a couple of weeks

00:39:24.490 --> 00:39:28.060
ago when I asked what the best
conferences to go to were.

00:39:28.060 --> 00:39:30.400
Because really, the biggest
tip that I can give you

00:39:30.400 --> 00:39:33.040
is that, much more than
changes in the tooling

00:39:33.040 --> 00:39:36.040
or the frameworks of the APIs
or Jetpack or anything else,

00:39:36.040 --> 00:39:38.080
much more than that,
the biggest thing

00:39:38.080 --> 00:39:40.780
driving Android development
forward is the community.

00:39:40.780 --> 00:39:43.050
It's the people around
you, the people online.

00:39:43.050 --> 00:39:45.160
We're all helping each
other with Android.

00:39:45.160 --> 00:39:46.997
And it's important
because we know

00:39:46.997 --> 00:39:48.580
that the one thing
that doesn't change

00:39:48.580 --> 00:39:50.350
is that things are
going to change.

00:39:50.350 --> 00:39:53.607
So take advantage of things like
Jetpack to make things simpler.

00:39:53.607 --> 00:39:54.940
Work with the people around you.

00:39:54.940 --> 00:39:59.020
And hopefully your apps
will survive much longer

00:39:59.020 --> 00:40:01.000
than my pro tips.

00:40:01.000 --> 00:40:01.776
Thank you.

00:40:01.776 --> 00:40:02.768
[APPLAUSE]

00:40:02.768 --> 00:40:06.002
[MUSIC PLAYING]

