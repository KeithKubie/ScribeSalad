WEBVTT
Kind: captions
Language: en

00:00:02.520 --> 00:00:03.750
STEVE MALKOS: Welcome.

00:00:03.750 --> 00:00:05.390
I'm truly excited
to be here today

00:00:05.390 --> 00:00:08.880
to talk to you guys about
location and sensors.

00:00:08.880 --> 00:00:11.060
Get the clicker.

00:00:11.060 --> 00:00:12.250
My name's Steve Malkos.

00:00:12.250 --> 00:00:14.690
I'm the Technical Program
Manager for the Android

00:00:14.690 --> 00:00:16.890
Location and Context Team.

00:00:16.890 --> 00:00:19.650
I was amazed earlier
today to hear Sundar talk

00:00:19.650 --> 00:00:22.960
so much on sensors and context.

00:00:22.960 --> 00:00:25.120
Being part of the
location and context team,

00:00:25.120 --> 00:00:28.230
we touch every part
of Google, and I'm

00:00:28.230 --> 00:00:30.370
truly excited about that.

00:00:30.370 --> 00:00:34.050
So without further ado--
OK, let's get into it.

00:00:34.050 --> 00:00:37.070
Today, we carry the
world in our pocket.

00:00:37.070 --> 00:00:40.030
We carry more computing
power and faster data

00:00:40.030 --> 00:00:42.240
speeds than we did
just nearly half

00:00:42.240 --> 00:00:45.290
a decade ago from
our desktop PCs.

00:00:45.290 --> 00:00:48.160
One item that has remained the
same throughout our computing

00:00:48.160 --> 00:00:52.120
history has been building
these innovative software

00:00:52.120 --> 00:00:53.360
applications.

00:00:53.360 --> 00:00:57.680
And you guys are continuously
shaping this world.

00:00:57.680 --> 00:00:58.880
But we need to do more.

00:00:58.880 --> 00:01:00.210
We can do more.

00:01:00.210 --> 00:01:02.583
We could build deeper
and richer experiences.

00:01:05.260 --> 00:01:07.920
In this talk,
we'll focus on what

00:01:07.920 --> 00:01:11.170
it takes to build an
awareness application.

00:01:11.170 --> 00:01:15.250
We'll go through
sensors and location,

00:01:15.250 --> 00:01:19.080
focusing on bringing richer
experiences by using them.

00:01:19.080 --> 00:01:22.290
Then, we'll take a deep dive
into the Android sensor hub

00:01:22.290 --> 00:01:23.900
and go through the
cool new things

00:01:23.900 --> 00:01:26.110
that we're building for it.

00:01:26.110 --> 00:01:28.410
Awesome.

00:01:28.410 --> 00:01:30.580
OK, so what does
it take to build

00:01:30.580 --> 00:01:32.510
these highly contextual apps?

00:01:32.510 --> 00:01:36.990
So what does it take to build
these high-quality apps?

00:01:36.990 --> 00:01:44.529
Today-- sorry, the
notes are not right.

00:01:44.529 --> 00:01:46.570
FEMALE SPEAKER: Let me
take care of that for you.

00:01:49.900 --> 00:01:52.960
STEVE MALKOS: Our phones are
very personal and interactive.

00:01:52.960 --> 00:01:55.980
They have transformed the
way we compose our day.

00:01:55.980 --> 00:01:59.540
We use them to get traffic
info, health and safety,

00:01:59.540 --> 00:02:01.910
and notifications and much more.

00:02:01.910 --> 00:02:04.530
So it's understandable
that your biggest concerns

00:02:04.530 --> 00:02:09.650
are on how to make your apps
more contextually aware.

00:02:09.650 --> 00:02:11.480
So let's focus on
what it takes to build

00:02:11.480 --> 00:02:12.750
these high-quality apps.

00:02:12.750 --> 00:02:15.090
When creating these
awareness applications,

00:02:15.090 --> 00:02:18.460
there are typically three main
layers that we need to look at.

00:02:18.460 --> 00:02:22.530
That's sensors, algorithms,
and user experiences.

00:02:22.530 --> 00:02:26.430
Think of an awareness
application like a human sense.

00:02:26.430 --> 00:02:29.800
For example, your inner ear
acts as the accelerometer

00:02:29.800 --> 00:02:31.640
and gyroscope of the device.

00:02:31.640 --> 00:02:34.500
Your eyes act as
the camera sensor.

00:02:34.500 --> 00:02:37.640
That raw data from
your ears to your eyes

00:02:37.640 --> 00:02:40.900
gets sent up to your brain and
processed like the algorithms

00:02:40.900 --> 00:02:42.660
on the device.

00:02:42.660 --> 00:02:46.220
That's then classified into
the context and outputs

00:02:46.220 --> 00:02:49.200
as the user experience,
like I'm running,

00:02:49.200 --> 00:02:51.100
or I'm running with a buddy.

00:02:51.100 --> 00:02:56.050
MEMS Sensors allows us to take
a deeper programming perspective

00:02:56.050 --> 00:03:00.560
on comprehending the
environment around us.

00:03:00.560 --> 00:03:03.010
So when building these
contextual applications,

00:03:03.010 --> 00:03:06.280
we're going to focus on
these four main pillars.

00:03:06.280 --> 00:03:10.660
That's coverage, accuracy,
latency, and power.

00:03:10.660 --> 00:03:13.770
We'll refer to these pillars
throughout the entire talk.

00:03:13.770 --> 00:03:16.760
These are the building blocks
for creating higher quality

00:03:16.760 --> 00:03:18.170
applications.

00:03:18.170 --> 00:03:21.970
Let's walk through
examples of each of these.

00:03:21.970 --> 00:03:24.540
The first pillar is coverage.

00:03:24.540 --> 00:03:30.180
For location it must work all
the time-- indoors, outdoors,

00:03:30.180 --> 00:03:31.920
and in every country.

00:03:31.920 --> 00:03:34.770
At Google, we're continuing
to improve our coverage

00:03:34.770 --> 00:03:37.080
maps with our
crowdsourced models

00:03:37.080 --> 00:03:40.980
and Google databases to
make location better.

00:03:40.980 --> 00:03:43.610
For activity recognition,
it has to support

00:03:43.610 --> 00:03:46.760
a wide array of different
types of activities,

00:03:46.760 --> 00:03:51.710
like I'm running, or I'm
walking, or I'm in a vehicle.

00:03:51.710 --> 00:03:57.070
And nearby notifications needs
to work across a wide array

00:03:57.070 --> 00:03:58.910
of different types of devices.

00:03:58.910 --> 00:04:03.040
Finally, sensors have to
work seamlessly and uniformly

00:04:03.040 --> 00:04:04.412
across the entire ecosystem.

00:04:08.070 --> 00:04:10.420
The second pillar, accuracy.

00:04:10.420 --> 00:04:14.240
From the macro view, GPS
must be very accurate.

00:04:14.240 --> 00:04:16.529
Users don't want position jumps.

00:04:16.529 --> 00:04:20.300
They want the positions to be
under 5 meters all the time.

00:04:20.300 --> 00:04:22.840
Indoor and outdoor
transitions also

00:04:22.840 --> 00:04:26.180
have to be as
smooth as possible.

00:04:26.180 --> 00:04:29.430
From the macro view that we
saw on the previous column

00:04:29.430 --> 00:04:32.280
to the micro view on
position accuracies,

00:04:32.280 --> 00:04:35.620
it must work perfectly
for our virtual world.

00:04:35.620 --> 00:04:38.020
Examples a better
virtual reality

00:04:38.020 --> 00:04:39.430
could come from sensors.

00:04:39.430 --> 00:04:44.380
Sensors that output less
drift at lower noise.

00:04:44.380 --> 00:04:47.740
A user also wants very
accurate activity detection.

00:04:47.740 --> 00:04:52.110
For example, it's not OK
to classify biking activity

00:04:52.110 --> 00:04:56.770
if you're shaking your
leg in a moving car.

00:04:56.770 --> 00:05:00.480
The third column that I'd
like to discuss is latency.

00:05:00.480 --> 00:05:03.190
From the macro view,
users don't want

00:05:03.190 --> 00:05:04.810
to wait for their positions.

00:05:04.810 --> 00:05:07.890
Location should show
up instantaneously.

00:05:07.890 --> 00:05:11.720
And activity detection needs
to happen near real time,

00:05:11.720 --> 00:05:13.760
so the user's entire
activity can be

00:05:13.760 --> 00:05:17.460
tracked with almost no latency.

00:05:17.460 --> 00:05:20.810
From the macro to the
micro on latencies,

00:05:20.810 --> 00:05:23.430
our sensors cannot lag.

00:05:23.430 --> 00:05:26.460
When we have sensor and
display lags like this,

00:05:26.460 --> 00:05:32.010
your virtual world can go
from making a beautiful scene

00:05:32.010 --> 00:05:35.130
to making you
nauseated very quickly.

00:05:35.130 --> 00:05:38.460
We want the experience
to be crystal clear.

00:05:38.460 --> 00:05:41.820
We take great care in ensuring
that our sensor latency

00:05:41.820 --> 00:05:43.480
requirements are met.

00:05:43.480 --> 00:05:46.160
This ensures that when you
write your applications,

00:05:46.160 --> 00:05:48.530
you can be certain
that they'll perform

00:05:48.530 --> 00:05:51.720
to your user's expectations.

00:05:51.720 --> 00:05:54.120
Our final column, power.

00:05:54.120 --> 00:05:57.390
That's battery life, one of
the most important columns

00:05:57.390 --> 00:05:59.280
when building your applications.

00:05:59.280 --> 00:06:01.730
We all know that if your
application sucks up

00:06:01.730 --> 00:06:03.820
the user's battery
life, they'll quickly

00:06:03.820 --> 00:06:06.030
uninstall it from their device.

00:06:06.030 --> 00:06:08.150
We need to make it
where you guys don't

00:06:08.150 --> 00:06:09.920
have to worry about power.

00:06:09.920 --> 00:06:13.050
We can do this by
avoiding too many knobs.

00:06:13.050 --> 00:06:15.080
Simplicity is key.

00:06:15.080 --> 00:06:18.260
Power has even two sub-pillars.

00:06:18.260 --> 00:06:20.710
That's latency and accuracy.

00:06:20.710 --> 00:06:24.240
It means we could run more
often improving on latencies.

00:06:24.240 --> 00:06:27.370
It also means we could get
access to more signals,

00:06:27.370 --> 00:06:30.290
thus improving on accuracy.

00:06:30.290 --> 00:06:34.020
So in the theme of building
better user experiences

00:06:34.020 --> 00:06:38.350
by bringing higher quality
applications focused

00:06:38.350 --> 00:06:42.370
on coverage, accuracy,
latency, and power, let's

00:06:42.370 --> 00:06:46.137
hear from Ashutosh
on Android sensors.

00:06:46.137 --> 00:06:48.133
[APPLAUSE]

00:06:53.123 --> 00:06:54.367
ASHUTOSH: Hi.

00:06:54.367 --> 00:06:55.950
Thanks, Steve, for
setting out the lay

00:06:55.950 --> 00:06:57.824
of the land for the rest
of the presentation.

00:06:57.824 --> 00:06:59.790
I'm Ashutosh, and over
the next few minutes,

00:06:59.790 --> 00:07:02.420
we shall be talking about how we
set about achieving these four

00:07:02.420 --> 00:07:04.250
pillars of contextual sensors.

00:07:04.250 --> 00:07:07.050
I hope to give you some insight
into the challenges we face

00:07:07.050 --> 00:07:10.829
and the power we derived in
working with the ecosystem.

00:07:10.829 --> 00:07:12.870
I shall show you some of
the new and shiny things

00:07:12.870 --> 00:07:15.480
we have in store for
you for Android N.

00:07:15.480 --> 00:07:17.560
And finally, we'll share
some of the lessons

00:07:17.560 --> 00:07:19.530
that we have learned
in developing Android

00:07:19.530 --> 00:07:23.510
experiences, which will probably
be of value to you as well.

00:07:23.510 --> 00:07:25.640
A challenge that we face
is a constant tension

00:07:25.640 --> 00:07:27.800
between increasing
coverage but formally

00:07:27.800 --> 00:07:30.430
defining new sensors
in Android and ensuring

00:07:30.430 --> 00:07:32.510
that we can keep a
consistent user experience

00:07:32.510 --> 00:07:33.910
across the ecosystem.

00:07:33.910 --> 00:07:35.360
Let me give you an example.

00:07:35.360 --> 00:07:37.660
We have received requests
to allow accelerometers

00:07:37.660 --> 00:07:40.180
that only support two axes.

00:07:40.180 --> 00:07:42.527
These are required
for low-end markets

00:07:42.527 --> 00:07:44.610
where the z-axis is not
required if the only thing

00:07:44.610 --> 00:07:46.980
that accelerometer does is
detect landscape and portrait

00:07:46.980 --> 00:07:48.340
detection.

00:07:48.340 --> 00:07:50.500
On the other hand,
we have been asked

00:07:50.500 --> 00:07:54.172
to mandate a higher dynamic
range for accelerometers

00:07:54.172 --> 00:07:56.630
because it allows some safety
applications to be developed,

00:07:56.630 --> 00:07:58.830
which can potentially
save lives.

00:07:58.830 --> 00:08:00.800
The problem is that
these two goals

00:08:00.800 --> 00:08:03.140
are mutually contradictory.

00:08:03.140 --> 00:08:06.080
A sensor that only
supports two axes

00:08:06.080 --> 00:08:08.010
will not have a
high-dynamic range.

00:08:08.010 --> 00:08:11.480
The economics of the
industry work against it.

00:08:11.480 --> 00:08:13.060
The example goes to coverage.

00:08:13.060 --> 00:08:15.640
We must ensure that all
Android sensors can eke out

00:08:15.640 --> 00:08:19.170
the maximum visibility from the
hardware while also ensuring

00:08:19.170 --> 00:08:22.440
that the application developers
seek consistent APIs across all

00:08:22.440 --> 00:08:24.720
of Android.

00:08:24.720 --> 00:08:28.330
Over the years, we've steadily
added new formal definitions.

00:08:28.330 --> 00:08:30.700
While the major physical
sensors, like Excel, Gyro,

00:08:30.700 --> 00:08:32.600
and Mag were defined
very early on,

00:08:32.600 --> 00:08:35.159
we've continued to define
new capabilities, like sensor

00:08:35.159 --> 00:08:39.350
fusion, geomagnetic rotation
vector, and new center

00:08:39.350 --> 00:08:41.330
types for completely
new form factors

00:08:41.330 --> 00:08:43.650
like Android [INAUDIBLE].

00:08:43.650 --> 00:08:45.700
These new capabilities
increase coverage

00:08:45.700 --> 00:08:47.437
to develop awareness
applications

00:08:47.437 --> 00:08:49.020
because more sensor
types mean that we

00:08:49.020 --> 00:08:51.210
can get more data about
the world around us

00:08:51.210 --> 00:08:53.350
and derive richer inferences.

00:08:53.350 --> 00:08:56.220
We're adding a few things this
year for the Android N release.

00:08:56.220 --> 00:08:59.400
Let me walk you
through some of them.

00:08:59.400 --> 00:09:01.340
Let's start with
something really exciting.

00:09:01.340 --> 00:09:03.420
All orientation
sensors thus far were

00:09:03.420 --> 00:09:05.089
centered around orientation.

00:09:05.089 --> 00:09:06.880
They provided the
orientation of the device

00:09:06.880 --> 00:09:09.300
in terms of roll, pitch,
and yaw with reference

00:09:09.300 --> 00:09:12.350
to either true north of gravity
or an arbitrary initial point.

00:09:12.350 --> 00:09:15.210
We're adding the three
axes of translation freedom

00:09:15.210 --> 00:09:17.730
by introducing the
6DOF sensor type.

00:09:17.730 --> 00:09:19.940
Apps will not only
know the orientation,

00:09:19.940 --> 00:09:23.190
but the precise displacement
of the device in the world.

00:09:23.190 --> 00:09:25.330
This means that motion
control in games

00:09:25.330 --> 00:09:28.499
can go just beyond tracking
where the user is looking.

00:09:28.499 --> 00:09:31.040
Now they will be able to move
the player in the virtual world

00:09:31.040 --> 00:09:33.130
just as the player
moves in the real world.

00:09:33.130 --> 00:09:35.540
You can walk and not
just been in place.

00:09:35.540 --> 00:09:39.160
Augmented reality experiences
will be even more immersive now

00:09:39.160 --> 00:09:41.890
that they can mirror
the user's movements.

00:09:41.890 --> 00:09:44.880
Just to set
expectations, this sensor

00:09:44.880 --> 00:09:47.720
is not likely to be widely
pervasive across Android.

00:09:47.720 --> 00:09:50.440
But we believe that the
introduction of a formal sensor

00:09:50.440 --> 00:09:53.350
type is required
to give the system

00:09:53.350 --> 00:09:55.955
a push towards augmented
reality applications.

00:09:58.624 --> 00:10:00.040
On the wearables
fun factor, we're

00:10:00.040 --> 00:10:01.920
extending the
capabilities of what

00:10:01.920 --> 00:10:03.859
is available through
the heart rate sensor.

00:10:03.859 --> 00:10:06.150
Thus far, you have been able
to get an average snapshot

00:10:06.150 --> 00:10:08.040
of the heartbeat
measurement, which is great,

00:10:08.040 --> 00:10:10.480
but it leaves a lot of
information on the table.

00:10:10.480 --> 00:10:12.800
We will expose a much
more finer-grained event

00:10:12.800 --> 00:10:15.810
for every heartbeat, which
should more or less correspond

00:10:15.810 --> 00:10:18.834
to the systolic peak
for each heartbeat.

00:10:18.834 --> 00:10:21.250
This will enable a whole new
class of fitness and wellness

00:10:21.250 --> 00:10:24.140
applications, like
reporting and monitoring

00:10:24.140 --> 00:10:26.720
mental stress, physical
stress, overtraining,

00:10:26.720 --> 00:10:29.300
exercise recovery, and
sleep analysis, et cetera.

00:10:29.300 --> 00:10:33.200
And you guys will be
writing all of them.

00:10:33.200 --> 00:10:35.740
One of the most often repeated
requests from our developers

00:10:35.740 --> 00:10:38.580
to us was to expose the hardware
capabilities to determine

00:10:38.580 --> 00:10:39.927
the motion state of the device.

00:10:39.927 --> 00:10:42.010
We are adding these sensors
to the Android sensors

00:10:42.010 --> 00:10:44.080
API as one-shot events.

00:10:44.080 --> 00:10:45.804
We shall exposed two of them.

00:10:45.804 --> 00:10:47.470
One shall fire if the
device centers are

00:10:47.470 --> 00:10:49.370
a stationary state
and one that fires

00:10:49.370 --> 00:10:50.850
if the device starts moving.

00:10:50.850 --> 00:10:53.183
We hope that this will allow
the applications to be more

00:10:53.183 --> 00:10:55.010
judicious in the use
of system resources

00:10:55.010 --> 00:10:57.840
and developers will use this
ability of motion determination

00:10:57.840 --> 00:11:01.987
in low-powered hardware to
get their resource usage.

00:11:01.987 --> 00:11:04.320
Finally, this year we realized
that applicant processors

00:11:04.320 --> 00:11:06.480
and display controllers
are now smart enough

00:11:06.480 --> 00:11:07.690
to enter low-power states.

00:11:07.690 --> 00:11:10.140
If only we did not keep pinging
the application processor

00:11:10.140 --> 00:11:13.310
with x amount of data to
compute the device orientation.

00:11:13.310 --> 00:11:15.110
So we're formalizing
the screen orientation

00:11:15.110 --> 00:11:18.280
as a new sensor type that can
be implemented by the OEMs

00:11:18.280 --> 00:11:21.260
to get the low-power domains to
compute the device orientation.

00:11:21.260 --> 00:11:23.069
However, developers
can and should

00:11:23.069 --> 00:11:25.360
continue to use the Android
Activity and Window Manager

00:11:25.360 --> 00:11:26.730
APIs.

00:11:26.730 --> 00:11:29.020
Android will ensure that
regardless of the underlying

00:11:29.020 --> 00:11:31.720
sensor support, your app will
continue to work seamlessly

00:11:31.720 --> 00:11:34.960
across all addressable devices,
and if the sensor is supported,

00:11:34.960 --> 00:11:38.510
you get all the power benefits.

00:11:38.510 --> 00:11:40.630
Finally, we are
adding capabilities

00:11:40.630 --> 00:11:42.870
to allow applications
on an Android device

00:11:42.870 --> 00:11:45.590
to discover and subscribe
to external sensors

00:11:45.590 --> 00:11:47.230
through the sensor's API.

00:11:47.230 --> 00:11:49.240
By external sensors
here, I mean any sensor

00:11:49.240 --> 00:11:50.640
that is not present
on the device

00:11:50.640 --> 00:11:51.900
when the device boots up.

00:11:51.900 --> 00:11:54.420
Now, this can be
unnecessary for the device

00:11:54.420 --> 00:11:56.170
that physically
attaches to the device

00:11:56.170 --> 00:11:59.550
or a truly external device
that connects wirelessly

00:11:59.550 --> 00:12:00.960
to your phone.

00:12:00.960 --> 00:12:03.520
This is a nod to the central
roles our phones have

00:12:03.520 --> 00:12:07.110
in our lives and the realization
that a single device cannot be

00:12:07.110 --> 00:12:09.790
all things to all of the
people all of the time.

00:12:09.790 --> 00:12:11.549
Device capabilities
can be augmented,

00:12:11.549 --> 00:12:13.090
and we want to
provide a standard way

00:12:13.090 --> 00:12:15.990
to access such data.

00:12:15.990 --> 00:12:18.910
What is coming up is exciting,
and I cannot wait to see what

00:12:18.910 --> 00:12:21.493
cool things that developers will
come up with these new sensor

00:12:21.493 --> 00:12:23.080
types.

00:12:23.080 --> 00:12:25.330
Having decided how we
want increased coverage,

00:12:25.330 --> 00:12:27.910
how do we establish
accuracy and consistency?

00:12:27.910 --> 00:12:30.732
How do we ensure that when a
new API version is released,

00:12:30.732 --> 00:12:32.190
what makes it to
the app developers

00:12:32.190 --> 00:12:34.380
is consistent across Android?

00:12:34.380 --> 00:12:36.770
This is a complex process
and involves the hard work

00:12:36.770 --> 00:12:39.540
of hundreds of talented people
across the Android ecosystem.

00:12:39.540 --> 00:12:42.650
Let me walk you through
some of the challenges.

00:12:42.650 --> 00:12:44.130
Android is diverse.

00:12:44.130 --> 00:12:45.760
Just on the hardware
side, there are

00:12:45.760 --> 00:12:49.270
300-plus OEMs, 200-plus
carriers and operators,

00:12:49.270 --> 00:12:52.800
hundreds of component vendors,
dozens of CPU SoC vendors

00:12:52.800 --> 00:12:54.430
with a range of products.

00:12:54.430 --> 00:12:56.820
There are dominant players
that have huge market shares,

00:12:56.820 --> 00:12:59.520
and there's a long tail that
caters to very specific niche

00:12:59.520 --> 00:13:00.420
cases.

00:13:00.420 --> 00:13:03.570
Somehow we have to ensure that
we're listening to everyone

00:13:03.570 --> 00:13:06.399
and helping everyone in
the ecosystem succeed.

00:13:06.399 --> 00:13:08.190
And then there's the
sheer range of devices

00:13:08.190 --> 00:13:09.350
that Android can support.

00:13:09.350 --> 00:13:12.430
All of the devices on this
slide are Android devices,

00:13:12.430 --> 00:13:15.314
the same specifications
rule them all, more or less.

00:13:15.314 --> 00:13:16.980
There are a few
restrictions or mandates

00:13:16.980 --> 00:13:18.410
that Android stipulates.

00:13:18.410 --> 00:13:20.499
As an example,
it's completely OK

00:13:20.499 --> 00:13:22.790
to make an Android device
without a single sensor type,

00:13:22.790 --> 00:13:24.380
not even an accelerometer.

00:13:24.380 --> 00:13:25.970
That sounds bizarre
if one thinks

00:13:25.970 --> 00:13:28.399
of Android purely as
a cell phone platform

00:13:28.399 --> 00:13:30.690
but is immediately obvious
once you think of Android TV

00:13:30.690 --> 00:13:33.106
products and convince yourself
that determining the device

00:13:33.106 --> 00:13:38.020
orientation of a TV would be
an [INAUDIBLE] case at best.

00:13:38.020 --> 00:13:40.690
So what does it really
mean to support a sensor?

00:13:40.690 --> 00:13:42.330
What sensor should
a device have?

00:13:42.330 --> 00:13:45.630
What guarantees, if many, are
made explicit of the developer?

00:13:45.630 --> 00:13:46.910
And how?

00:13:46.910 --> 00:13:49.370
These are difficult
questions that keep us busy.

00:13:49.370 --> 00:13:51.150
And versus agreement
on these goals,

00:13:51.150 --> 00:13:53.320
how does this diverse
ecosystem take its cues?

00:13:53.320 --> 00:13:55.600
What tools do we use
to make this happen?

00:13:55.600 --> 00:13:57.100
In a nutshell, we
drive this process

00:13:57.100 --> 00:13:59.010
by creating standards
for Android,

00:13:59.010 --> 00:14:01.034
producing exemplary
Android devices at Google,

00:14:01.034 --> 00:14:02.450
and working in
tight collaboration

00:14:02.450 --> 00:14:04.550
with our partners.

00:14:04.550 --> 00:14:06.110
The very first step
is the definition

00:14:06.110 --> 00:14:07.830
of Android compatibility.

00:14:07.830 --> 00:14:11.030
An Android device is supposed to
meet 100% of the specifications

00:14:11.030 --> 00:14:12.820
as defined in the
Android Compatibility

00:14:12.820 --> 00:14:14.937
Document, the Android CDD.

00:14:14.937 --> 00:14:16.770
It goes into lots of
gory details about what

00:14:16.770 --> 00:14:18.700
kind of sensor should
be on a device, how they

00:14:18.700 --> 00:14:20.600
should be announced,
and if announced,

00:14:20.600 --> 00:14:22.150
what bar they must meet.

00:14:22.150 --> 00:14:24.490
We tuned the CDD language
to advise the ecosystem

00:14:24.490 --> 00:14:26.610
on what is coming down
the road and match them

00:14:26.610 --> 00:14:28.910
into more aspirational
requirements.

00:14:28.910 --> 00:14:31.890
The CDD is enforced through
the CTS, a Compatibility Test

00:14:31.890 --> 00:14:32.660
Suite.

00:14:32.660 --> 00:14:34.710
All Android devices
must pass the CTS.

00:14:34.710 --> 00:14:38.180
There are no exceptions or
any waivers for any device.

00:14:38.180 --> 00:14:40.950
We keep adding CTS tests to
patch hold in our testing.

00:14:40.950 --> 00:14:44.350
Note however, that the CTS is
an enforcement organism only.

00:14:44.350 --> 00:14:47.020
It cannot possibly cover
the entire specifications

00:14:47.020 --> 00:14:48.025
exhaustively.

00:14:48.025 --> 00:14:50.970
The artifact of
record is the CDD.

00:14:50.970 --> 00:14:52.589
What do we expect of developers?

00:14:52.589 --> 00:14:54.130
Please take a look
at the Android CDD

00:14:54.130 --> 00:14:57.480
if you're looking to deploy an
app across a large user base.

00:14:57.480 --> 00:15:00.340
It will help such expectations
on what is standardized

00:15:00.340 --> 00:15:02.800
and what to expect.

00:15:02.800 --> 00:15:04.870
Google devices are
another tool we use.

00:15:04.870 --> 00:15:06.650
All Google devices
are great devices.

00:15:06.650 --> 00:15:09.690
They also serve to set a bar
for the rest of the OEMs.

00:15:09.690 --> 00:15:12.950
Our Nexus device is subject to a
lot of scrutiny outside Google.

00:15:12.950 --> 00:15:14.730
The OEM scrutinize
it to make sure

00:15:14.730 --> 00:15:17.790
that their devices in that class
are as good as, or even better,

00:15:17.790 --> 00:15:18.857
than the Nexus.

00:15:18.857 --> 00:15:20.690
They also use that
opportunity to figure out

00:15:20.690 --> 00:15:22.400
the holes in our specifications.

00:15:22.400 --> 00:15:25.470
If something is ambiguous,
a reasonably good assumption

00:15:25.470 --> 00:15:28.010
would be to go along with
what the Nexus is doing.

00:15:28.010 --> 00:15:29.540
The implication here is obvious.

00:15:29.540 --> 00:15:32.110
Do test your applications
on Google devices.

00:15:32.110 --> 00:15:34.470
I think most of you follow
this practice already,

00:15:34.470 --> 00:15:36.640
but please, however, go
beyond just the Nexus

00:15:36.640 --> 00:15:38.440
that launches this year.

00:15:38.440 --> 00:15:41.470
Do test the applications
on previous Nexus devices

00:15:41.470 --> 00:15:46.660
and extend your testing
to, say, Android 1 devices.

00:15:46.660 --> 00:15:49.057
On the sensor side,
we go even further.

00:15:49.057 --> 00:15:51.140
Last year Google wrote the
sensor stack completely

00:15:51.140 --> 00:15:51.940
by itself.

00:15:51.940 --> 00:15:55.450
And we are releasing the
complete sensor stack

00:15:55.450 --> 00:15:58.401
source for the Nexus
devices in open source.

00:15:58.401 --> 00:16:00.400
You can get the code for
the sensors of software

00:16:00.400 --> 00:16:02.460
at the depository on this slide.

00:16:02.460 --> 00:16:04.570
We have two primary
reasons to do this.

00:16:04.570 --> 00:16:07.060
The first is to make life
easier for the ecosystem.

00:16:07.060 --> 00:16:08.740
They now have access
to the source code

00:16:08.740 --> 00:16:10.494
that runs on the Nexus
devices and should

00:16:10.494 --> 00:16:12.410
be able to comply with
all the requirements we

00:16:12.410 --> 00:16:15.050
are putting forth and
hopefully even do better.

00:16:15.050 --> 00:16:16.500
The second is guidance.

00:16:16.500 --> 00:16:18.600
We hope that simply by
releasing the source code,

00:16:18.600 --> 00:16:21.610
we can wear intents and
expectations very loudly.

00:16:21.610 --> 00:16:23.610
In fact, if you look at
the source code released

00:16:23.610 --> 00:16:26.320
you will find the beginnings
and the genesis of some

00:16:26.320 --> 00:16:29.230
of the future work that we
shall release in Android N.

00:16:29.230 --> 00:16:31.520
We have not written a ton
of formal documentation yet,

00:16:31.520 --> 00:16:33.100
but we are finding
that our partners are

00:16:33.100 --> 00:16:34.766
reading the release
source and coming up

00:16:34.766 --> 00:16:39.290
with a very good idea
about what to expect.

00:16:39.290 --> 00:16:41.770
Finally, we must continue
to build internal expertise

00:16:41.770 --> 00:16:44.130
to keep abreast of the
developments in this space.

00:16:44.130 --> 00:16:46.090
We learn constantly
and continue to invest

00:16:46.090 --> 00:16:48.650
in internal capabilities
to learn more about sensors

00:16:48.650 --> 00:16:49.910
and their algorithms.

00:16:49.910 --> 00:16:51.380
Let me show you
how here at Google

00:16:51.380 --> 00:16:53.886
we're innovating new
groundbreaking methods to test

00:16:53.886 --> 00:16:56.010
our solutions and improve
the quality of our sensor

00:16:56.010 --> 00:16:56.510
algorithms.

00:16:56.510 --> 00:16:59.550
Can I play the video, please.

00:16:59.550 --> 00:17:00.640
[MUSIC PLAYING]

00:17:00.640 --> 00:17:03.000
In this video, you'll
see Matt programming one

00:17:03.000 --> 00:17:05.280
of our robotic arms
to simulate arm

00:17:05.280 --> 00:17:08.230
swinging for pedestrian
[INAUDIBLE] solutions.

00:17:08.230 --> 00:17:10.300
In this example, you'll
see two things happening.

00:17:10.300 --> 00:17:13.778
First, Matt will start by
using a motion capture system.

00:17:13.778 --> 00:17:16.027
The motion capture system
is able to record Matt's arm

00:17:16.027 --> 00:17:18.670
swings with
centimeter-level precision.

00:17:18.670 --> 00:17:21.069
We then translate the exact
motion of that capture system

00:17:21.069 --> 00:17:22.720
into a robotic arm.

00:17:22.720 --> 00:17:24.119
The robotic arm
then repetitively

00:17:24.119 --> 00:17:26.690
tests that specific scenario
on an automated basis

00:17:26.690 --> 00:17:28.380
again and again.

00:17:28.380 --> 00:17:30.140
That gives us the
ground crews for us

00:17:30.140 --> 00:17:32.960
to test our algorithms
and sensor solutions.

00:17:32.960 --> 00:17:33.480
Let's watch.

00:17:50.340 --> 00:17:51.131
That was cool.

00:17:51.131 --> 00:17:53.422
And Matt seemed to be having
way too much fun on there.

00:18:05.920 --> 00:18:08.080
The final tool in our
chest is collaboration

00:18:08.080 --> 00:18:09.630
with our partners.

00:18:09.630 --> 00:18:12.710
We work very closely with our
partners throughout the year

00:18:12.710 --> 00:18:16.360
to make sure that they are
aware of what we are doing.

00:18:16.360 --> 00:18:18.567
This is a symbiotic
relationship.

00:18:18.567 --> 00:18:21.150
The partners want to make sure
that their product roadmaps are

00:18:21.150 --> 00:18:23.566
aligned with ours so they're
not caught by surprise by any

00:18:23.566 --> 00:18:24.980
of the announcements we make.

00:18:24.980 --> 00:18:26.940
We on the other hand
want to make sure

00:18:26.940 --> 00:18:29.040
that we're not
shouting into thin air

00:18:29.040 --> 00:18:31.657
and have realistic expectations
about what is achievable.

00:18:31.657 --> 00:18:33.490
We meet them constantly
throughout the year.

00:18:33.490 --> 00:18:35.500
Every year we hold
an Android boot camp

00:18:35.500 --> 00:18:37.270
and give them a
glimpse of our plans.

00:18:37.270 --> 00:18:39.490
On the sensors
side last year, we

00:18:39.490 --> 00:18:41.990
conducted many summits with
sensor vendors, SOC vendors,

00:18:41.990 --> 00:18:43.440
and the OEMs.

00:18:43.440 --> 00:18:46.179
If we are successful,
nothing that I'm saying today

00:18:46.179 --> 00:18:47.970
would be a surprise to
any of our partners.

00:18:47.970 --> 00:18:49.700
They should be sitting
back and saying,

00:18:49.700 --> 00:18:51.990
we've got this taken care of.

00:18:51.990 --> 00:18:55.437
Just a cool thing for you-- why
do you think they listen to us?

00:18:55.437 --> 00:18:57.020
Other than our
charming personalities,

00:18:57.020 --> 00:18:59.320
the reason they do
is because they want

00:18:59.320 --> 00:19:01.320
to reach you, the developers.

00:19:01.320 --> 00:19:03.580
Some of the best and the
brightest on this planet

00:19:03.580 --> 00:19:06.200
are developing incredibly
exciting technologies,

00:19:06.200 --> 00:19:09.390
and they want them
to be exposed to you.

00:19:09.390 --> 00:19:11.820
We are merely
facilitating this meeting

00:19:11.820 --> 00:19:14.990
of immensely creative and
smart people from both worlds.

00:19:14.990 --> 00:19:17.870
The ecosystem is what we
derive our inference from.

00:19:17.870 --> 00:19:20.160
The ecosystem is what we serve.

00:19:20.160 --> 00:19:22.510
Takeaway-- reach out to us.

00:19:22.510 --> 00:19:24.270
Let us know what
you're looking for.

00:19:24.270 --> 00:19:25.000
What is missing?

00:19:25.000 --> 00:19:26.270
What needs improvement?

00:19:26.270 --> 00:19:28.677
What is truly exceptional
and you want more of?

00:19:28.677 --> 00:19:30.260
You'll find plenty
of ways to reach us

00:19:30.260 --> 00:19:33.689
at the end of the presentation.

00:19:33.689 --> 00:19:35.230
The Android sensor's
API has not only

00:19:35.230 --> 00:19:37.120
become richer by adding
more sensor types,

00:19:37.120 --> 00:19:39.370
it also gives great
control for the developers

00:19:39.370 --> 00:19:40.749
to optimize system performance.

00:19:40.749 --> 00:19:42.290
In the next few
minutes, I would like

00:19:42.290 --> 00:19:43.914
to talk about some
recommendations that

00:19:43.914 --> 00:19:47.210
will make your apps scale across
different tiers of devices

00:19:47.210 --> 00:19:49.730
and should under the hood
optimize for the hardware

00:19:49.730 --> 00:19:51.140
that your app is using.

00:19:51.140 --> 00:19:52.972
I will use power as an example.

00:19:52.972 --> 00:19:54.430
As to the extent
possible, you want

00:19:54.430 --> 00:19:56.620
to spend as little
power for your apps.

00:19:56.620 --> 00:19:59.490
Let us look at some ways that
will help you achieve this.

00:20:02.560 --> 00:20:04.610
On many devices, there's
a multilayered approach

00:20:04.610 --> 00:20:07.120
to processing, at least as
far as sensors are concerned.

00:20:07.120 --> 00:20:09.850
At the very source, there are
sensors like the accelerometers

00:20:09.850 --> 00:20:11.120
and the gyroscopes.

00:20:11.120 --> 00:20:13.800
Sensors today have come
a long way from years ago

00:20:13.800 --> 00:20:15.820
and themselves consume
very little power.

00:20:15.820 --> 00:20:17.410
They're really power efficient.

00:20:17.410 --> 00:20:19.950
Accelerometers and gyros today
take less than a milliwatt

00:20:19.950 --> 00:20:21.650
to sample data.

00:20:21.650 --> 00:20:25.370
They embed smart algorithms like
gestures and motion detection.

00:20:25.370 --> 00:20:27.600
Some even have rudimentary
programming frameworks

00:20:27.600 --> 00:20:29.526
for customization.

00:20:29.526 --> 00:20:31.150
Then there's the
application processor.

00:20:31.150 --> 00:20:32.858
This is your big
honking chip that you're

00:20:32.858 --> 00:20:34.956
using when you're running
apps or playing games.

00:20:34.956 --> 00:20:36.330
Running the
application processor

00:20:36.330 --> 00:20:37.975
takes a substantial
amount of power.

00:20:37.975 --> 00:20:40.350
So if every time you try to
process a single measurement,

00:20:40.350 --> 00:20:41.933
you wake up the
application processor,

00:20:41.933 --> 00:20:43.977
it becomes limiting
very quickly.

00:20:43.977 --> 00:20:45.560
All the power savings
from the sensors

00:20:45.560 --> 00:20:48.610
are dwarfed if the application
processor wakes up too often.

00:20:48.610 --> 00:20:51.550
It consumes a lot of power
and is incredibly powerful

00:20:51.550 --> 00:20:53.580
competition but is
also very power-hungry.

00:20:53.580 --> 00:20:55.470
It has to stay on
for a few seconds

00:20:55.470 --> 00:20:57.700
even if it needs to do a
little bit of processing.

00:20:57.700 --> 00:20:59.849
It needs time to
wake up and sleep.

00:20:59.849 --> 00:21:01.640
If every time you get
a sensor measurement,

00:21:01.640 --> 00:21:02.790
you wake up the
application processor,

00:21:02.790 --> 00:21:04.630
it never gets a
chance to go to sleep.

00:21:04.630 --> 00:21:06.620
So getting the application
processor to sleep

00:21:06.620 --> 00:21:08.610
is a key power-savings
technique.

00:21:08.610 --> 00:21:10.690
Modern hardware adds
an additional layer

00:21:10.690 --> 00:21:12.140
for sensor processing.

00:21:12.140 --> 00:21:14.760
We show that as a sensor
hub in this diagram.

00:21:14.760 --> 00:21:16.430
This low-power
compute domain may

00:21:16.430 --> 00:21:18.830
be part of the sensor itself,
a special power domain

00:21:18.830 --> 00:21:21.280
on the SOC, or a discrete chip.

00:21:21.280 --> 00:21:23.750
Its goal, however, is the
same-- to offload competition

00:21:23.750 --> 00:21:26.400
from the application
processor and save power.

00:21:26.400 --> 00:21:29.300
There are a few hooks
on the sensor's API

00:21:29.300 --> 00:21:32.326
that let you achieve this
goal-- for example, batching.

00:21:32.326 --> 00:21:33.950
You can use the
sensor's API to specify

00:21:33.950 --> 00:21:36.560
the maximum delay your
application can tolerate

00:21:36.560 --> 00:21:38.310
to receive sensor data.

00:21:38.310 --> 00:21:41.440
This means less frequent updates
to the operating processor.

00:21:41.440 --> 00:21:43.619
The events can be grouped
and processed together.

00:21:43.619 --> 00:21:45.410
The bigger those toys
buffer than the hubs,

00:21:45.410 --> 00:21:47.850
the more power is saved.

00:21:47.850 --> 00:21:50.107
Another design pattern
is to specify the goal

00:21:50.107 --> 00:21:52.190
that you want to achieve
and then be woken up when

00:21:52.190 --> 00:21:54.370
that situation becomes true.

00:21:54.370 --> 00:21:57.750
Then the low-power hardware
can monitor for the decision

00:21:57.750 --> 00:22:00.560
to become true instead of the
main application processor.

00:22:00.560 --> 00:22:02.759
This allows always on
monitoring of events

00:22:02.759 --> 00:22:05.300
that would have been prohibitive
by looking at the raw sensor

00:22:05.300 --> 00:22:07.390
data all the time.

00:22:07.390 --> 00:22:10.214
As an example, if you wanted
to change the app behavior,

00:22:10.214 --> 00:22:12.380
when it looks like the user
has moved from one place

00:22:12.380 --> 00:22:13.930
to another, you can
use a combination

00:22:13.930 --> 00:22:16.910
of geofences and the
significant motion sensor type

00:22:16.910 --> 00:22:18.560
to gate your processing.

00:22:18.560 --> 00:22:20.720
For the end release, we
have added new sensor types

00:22:20.720 --> 00:22:22.570
to detect motion
and stationarity.

00:22:22.570 --> 00:22:24.910
By using the right triggers,
you will consume power

00:22:24.910 --> 00:22:30.190
only when needed, and not just
a moment of interest for you.

00:22:30.190 --> 00:22:32.770
A less obvious design
pattern is to use the highest

00:22:32.770 --> 00:22:34.310
level of abstraction possible.

00:22:34.310 --> 00:22:36.460
While the APIs may
look like they're all

00:22:36.460 --> 00:22:38.030
exposed at one
level-- if you become

00:22:38.030 --> 00:22:40.789
a little familiar with
how the system is built,

00:22:40.789 --> 00:22:42.580
you will be able to
see where in the system

00:22:42.580 --> 00:22:44.380
the APIs are tapping into.

00:22:44.380 --> 00:22:46.780
Take, for example, the
sensors, accelerometers, gyros,

00:22:46.780 --> 00:22:48.030
and magnetometers.

00:22:48.030 --> 00:22:50.070
If you access the
raw data, the system

00:22:50.070 --> 00:22:52.720
must ensure of its
end of the contract

00:22:52.720 --> 00:22:55.050
and give you accurate,
reliable, and timely data.

00:22:55.050 --> 00:22:57.660
It cannot and should
not put in any smarts.

00:22:57.660 --> 00:22:59.980
However, if you ask for
the rotation vector,

00:22:59.980 --> 00:23:02.440
the same sensors are
used and data is fused.

00:23:02.440 --> 00:23:05.000
It may be tempting to roll
your own sensor fusion

00:23:05.000 --> 00:23:07.070
algorithm by processing
the raw data directly.

00:23:07.070 --> 00:23:11.220
However, you will lose hardware
optimizations on the table.

00:23:11.220 --> 00:23:13.890
As an example,
most devices today,

00:23:13.890 --> 00:23:16.210
if they're computing the
rotation vector in hardware,

00:23:16.210 --> 00:23:20.130
sample the underlying sensors
at an extremely high rate,

00:23:20.130 --> 00:23:22.500
sometimes in the
order of kilohertz.

00:23:22.500 --> 00:23:25.950
There is no way we can support
that frequency of updates

00:23:25.950 --> 00:23:29.400
on the application processor.

00:23:29.400 --> 00:23:32.450
And if by rolling your own
sensor fusion algorithms,

00:23:32.450 --> 00:23:37.087
you will be leaving power
and performance on the table.

00:23:37.087 --> 00:23:38.170
So this is pretty complex.

00:23:38.170 --> 00:23:40.940
I hear you.

00:23:40.940 --> 00:23:43.380
We have been trying to come
up with a specification

00:23:43.380 --> 00:23:45.150
the less the application
developers know

00:23:45.150 --> 00:23:47.540
that the sensors on a
device are top notch.

00:23:47.540 --> 00:23:50.660
In the [INAUDIBLE] release,
we added exactly such a signal

00:23:50.660 --> 00:23:51.940
for the developers.

00:23:51.940 --> 00:23:53.740
We call it Hi-Fi sensors.

00:23:53.740 --> 00:23:55.460
If the feature is
defined, you will

00:23:55.460 --> 00:23:57.520
know that the sensors
are really accurate.

00:23:57.520 --> 00:23:59.920
There are stringent requirements
on the resolution range

00:23:59.920 --> 00:24:02.060
and performance of all
the expected sensors.

00:24:02.060 --> 00:24:05.140
You will know that a large
batch size is supported allowing

00:24:05.140 --> 00:24:06.450
you to conserve battery.

00:24:06.450 --> 00:24:08.660
You will know that the
time stamps on the sensors

00:24:08.660 --> 00:24:11.020
will be very highly accurate.

00:24:11.020 --> 00:24:13.680
For many applications that
integrate sensor values

00:24:13.680 --> 00:24:15.740
over time-- for example,
Dead Reckoning--

00:24:15.740 --> 00:24:17.580
and error in the time
stamps is the same

00:24:17.580 --> 00:24:20.980
as an error in the sensor
value itself, and often worse.

00:24:20.980 --> 00:24:23.590
Finally, you will know the
sensors are low latency.

00:24:23.590 --> 00:24:26.230
Hi-Fi sensors have stringent
latency requirements

00:24:26.230 --> 00:24:29.320
to support all possible
real-time interactive use

00:24:29.320 --> 00:24:30.630
cases that we have run into.

00:24:33.670 --> 00:24:35.820
Checking for the Hi-Fi
sensor support is very easy.

00:24:35.820 --> 00:24:37.576
This code snippet
shows you how to do it.

00:24:37.576 --> 00:24:39.950
We're simply looking for a
feature string to be declared.

00:24:39.950 --> 00:24:41.825
So with a quick query
to the package manager,

00:24:41.825 --> 00:24:44.800
you can be assured that your
device has great sensors

00:24:44.800 --> 00:24:46.890
and will support all
the fundamentals pillars

00:24:46.890 --> 00:24:49.280
of contextual awareness.

00:24:49.280 --> 00:24:50.950
Sensor capabilities
are improving,

00:24:50.950 --> 00:24:52.210
getting more ubiquitous.

00:24:52.210 --> 00:24:55.360
I'm guessing a huge demand for
these additional capabilities.

00:24:55.360 --> 00:24:57.292
We are the location
and context team.

00:24:57.292 --> 00:24:59.250
We're constantly working
on integrating sensors

00:24:59.250 --> 00:25:02.790
into everyday user experiences
to make Android devices useful

00:25:02.790 --> 00:25:04.410
and a delight to use.

00:25:04.410 --> 00:25:07.237
Location is the other
huge and complex answer

00:25:07.237 --> 00:25:08.445
that [INAUDIBLE] is consumed.

00:25:08.445 --> 00:25:10.360
I will hand it over
to David to walk you

00:25:10.360 --> 00:25:13.862
through that part of the story.

00:25:13.862 --> 00:25:15.766
[APPLAUSE]

00:25:19.100 --> 00:25:20.400
DAVID: Thanks, Ashutosh.

00:25:20.400 --> 00:25:22.620
Hi, I'm David, and I work
as a software engineer

00:25:22.620 --> 00:25:24.494
on the Android location team.

00:25:24.494 --> 00:25:26.910
You've just heard about a lot
of the exciting capabilities

00:25:26.910 --> 00:25:29.040
we have with low-level
sensors, and now I'm

00:25:29.040 --> 00:25:31.630
going to talk about our
higher-level location APIs

00:25:31.630 --> 00:25:36.450
and how they do a lot of the
sensor fusion work for you.

00:25:36.450 --> 00:25:39.000
The Fused Location
Provider is our primary API

00:25:39.000 --> 00:25:40.710
for producing locations.

00:25:40.710 --> 00:25:43.450
It combines many of the sensors
Ashutosh just talked about,

00:25:43.450 --> 00:25:48.110
including GPS, Wi-Fi, cell,
accelerometer, magnetometer,

00:25:48.110 --> 00:25:49.830
and gyroscope.

00:25:49.830 --> 00:25:52.520
It's used by Google Maps to
power the current location

00:25:52.520 --> 00:25:54.800
blue dot and by
Google Now to provide

00:25:54.800 --> 00:25:56.770
invisible assistance
like reminding you

00:25:56.770 --> 00:25:59.440
where you parked your car.

00:25:59.440 --> 00:26:02.400
Android apps provide input
hints on accuracy requirements

00:26:02.400 --> 00:26:04.710
and frequency, and
the FLP decides

00:26:04.710 --> 00:26:07.550
which sensor to turn on in
order to manage both power

00:26:07.550 --> 00:26:11.580
and accuracy within the
constraints of user settings.

00:26:11.580 --> 00:26:13.070
In the next few
slides, I'll dive

00:26:13.070 --> 00:26:15.120
into the details of
some of these sensors

00:26:15.120 --> 00:26:16.972
and show how the FLP uses them.

00:26:19.860 --> 00:26:23.310
GPS is one of the most mature
location sensors that we use.

00:26:23.310 --> 00:26:25.580
And when it works, it
usually works great.

00:26:25.580 --> 00:26:28.430
It shines outdoors when you
have a clear view of the sky.

00:26:28.430 --> 00:26:31.220
But it has some trouble in
cities with tall buildings.

00:26:31.220 --> 00:26:34.360
And when you're indoors, it
often doesn't work at all.

00:26:34.360 --> 00:26:36.530
It's relatively power
hungry and eats the battery

00:26:36.530 --> 00:26:38.620
pretty quickly when active.

00:26:38.620 --> 00:26:42.580
The FLP will use GPS when an app
requests the highest accuracy

00:26:42.580 --> 00:26:44.110
location available.

00:26:44.110 --> 00:26:47.210
It will also sometimes use
GPS for a balanced power app

00:26:47.210 --> 00:26:50.350
request on newer devices
that support GPS batching.

00:26:52.940 --> 00:26:55.230
Wi-Fi is another staple
location technology

00:26:55.230 --> 00:26:56.820
that has become
more and more useful

00:26:56.820 --> 00:27:00.390
as Wi-Fi access points have
proliferated around the world.

00:27:00.390 --> 00:27:02.570
Unlike the GPS, it
works well indoors

00:27:02.570 --> 00:27:04.910
where people
typically have Wi-Fi.

00:27:04.910 --> 00:27:07.114
The accuracy usually
isn't as good as GPS,

00:27:07.114 --> 00:27:09.530
but it's good enough to tell
you what part of the building

00:27:09.530 --> 00:27:12.550
you're in and often
what floor you're on.

00:27:12.550 --> 00:27:14.770
Like GPS, the power
isn't great, but it

00:27:14.770 --> 00:27:17.090
can be improved by reducing
the location frequency.

00:27:19.532 --> 00:27:21.740
And knowing which cell tower
you're connected to also

00:27:21.740 --> 00:27:24.080
gives a very coarse
estimate of location.

00:27:24.080 --> 00:27:26.640
It can usually tell you which
city you're in and sometimes

00:27:26.640 --> 00:27:27.950
which neighborhood.

00:27:27.950 --> 00:27:31.680
Unlike GPS and Wi-Fi, it
works both indoors and out.

00:27:31.680 --> 00:27:33.180
And the battery
life is great given

00:27:33.180 --> 00:27:35.290
that the cell modem is
continually reconnecting

00:27:35.290 --> 00:27:38.390
to cell towers anyway.

00:27:38.390 --> 00:27:41.910
So GPS, Wi-Fi, and cell are the
foundation of location sensors

00:27:41.910 --> 00:27:43.914
surfaced through the FLP.

00:27:43.914 --> 00:27:45.330
But one of the
best parts of using

00:27:45.330 --> 00:27:47.790
the FLP in your applications
is that you continually

00:27:47.790 --> 00:27:50.050
take advantage of new
Google developments

00:27:50.050 --> 00:27:53.510
in both hardware adoption
and algorithm improvements.

00:27:53.510 --> 00:27:55.830
Most of these improvements
become active in your apps

00:27:55.830 --> 00:27:57.830
without any code changes.

00:27:57.830 --> 00:27:59.470
In the next few
slides, I'll highlight

00:27:59.470 --> 00:28:01.489
some of the improvements
we've recently made

00:28:01.489 --> 00:28:03.655
and show how to take advantage
of them in your apps.

00:28:06.390 --> 00:28:08.660
As I mentioned before,
dense urban environments

00:28:08.660 --> 00:28:11.020
are very challenging for GPS.

00:28:11.020 --> 00:28:12.600
When driving near
tall buildings,

00:28:12.600 --> 00:28:14.690
it's common for the
location to drift or jump

00:28:14.690 --> 00:28:16.680
to the wrong block.

00:28:16.680 --> 00:28:19.160
At Google, we test
GPS on a variety

00:28:19.160 --> 00:28:21.250
of phones and environments.

00:28:21.250 --> 00:28:23.920
This image shows a
setup for a driving test

00:28:23.920 --> 00:28:25.730
that we perform in
San Francisco, which

00:28:25.730 --> 00:28:30.230
is one of the harshest GPS
environments on the west coast.

00:28:30.230 --> 00:28:33.460
We use a military grade
inertial navigation system

00:28:33.460 --> 00:28:35.820
that provides centimeter-level
accuracy in order

00:28:35.820 --> 00:28:38.870
to collect ground truth
location for comparison.

00:28:38.870 --> 00:28:41.700
We also take video imagery
to compare position jumps

00:28:41.700 --> 00:28:46.380
and lags when all devices
are in navigation mode.

00:28:46.380 --> 00:28:48.220
This gives us the
automated ability

00:28:48.220 --> 00:28:50.915
to count and measure each
device's position jump

00:28:50.915 --> 00:28:53.380
or lag and then produce
a report listing

00:28:53.380 --> 00:28:55.440
the exact moment when
a device experienced

00:28:55.440 --> 00:28:58.590
these lags and jumps.

00:28:58.590 --> 00:29:01.820
This is an example test drive
in downtown San Francisco.

00:29:01.820 --> 00:29:04.390
You can see a lot of
issues with this track.

00:29:04.390 --> 00:29:07.440
Positions clump together,
poor latency, and even

00:29:07.440 --> 00:29:10.952
some positions inside buildings.

00:29:10.952 --> 00:29:12.660
In order to solve some
of these problems,

00:29:12.660 --> 00:29:15.140
we've work with our
GPS chipset partners

00:29:15.140 --> 00:29:17.350
to incorporate their sensor
fusion algorithms that

00:29:17.350 --> 00:29:20.690
combine accelerometer,
gyroscope, magnetometer,

00:29:20.690 --> 00:29:24.840
and barometer with raw GPS
pseudoranges, the chips that

00:29:24.840 --> 00:29:26.580
can fall back to
these other sensors

00:29:26.580 --> 00:29:29.456
when the GPS signal is weak
providing a much better user

00:29:29.456 --> 00:29:29.955
experience.

00:29:32.670 --> 00:29:34.850
This image shows the
before-and-after result

00:29:34.850 --> 00:29:39.060
of this GPS chipset fusion
working on a Nexus 6P.

00:29:39.060 --> 00:29:40.810
You can see the
blue line provides

00:29:40.810 --> 00:29:42.710
a much more stable
position resulting

00:29:42.710 --> 00:29:45.522
from this fusion as the user
drives in an urban environment.

00:29:48.240 --> 00:29:51.910
We've also tackled accuracy
in our Wi-Fi location models.

00:29:51.910 --> 00:29:55.010
Over the last year, we've
improved indoor median accuracy

00:29:55.010 --> 00:29:56.827
by 40%.

00:29:56.827 --> 00:29:58.660
In Google Maps, this
can mean the difference

00:29:58.660 --> 00:30:00.537
between knowing you're
in a shopping mall

00:30:00.537 --> 00:30:02.870
and knowing how close you are
to the actual store you're

00:30:02.870 --> 00:30:06.090
trying to find.

00:30:06.090 --> 00:30:08.780
We've added significant use
of the inertial sensors--

00:30:08.780 --> 00:30:12.140
accelerometer, gyroscope,
and magnetometer.

00:30:12.140 --> 00:30:14.590
These sensors don't tell us
where the user is directly,

00:30:14.590 --> 00:30:16.610
but they describe
how the user moves,

00:30:16.610 --> 00:30:19.210
so we can use them in
conjunction with GPS and Wi-Fi

00:30:19.210 --> 00:30:21.670
to improve location.

00:30:21.670 --> 00:30:24.380
One example of how the
FLP uses the accelerometer

00:30:24.380 --> 00:30:27.020
is by activating it when
the device is stationary

00:30:27.020 --> 00:30:28.940
in order to save power.

00:30:28.940 --> 00:30:31.740
Rather than performing costly
Wi-Fi scans over and over

00:30:31.740 --> 00:30:35.020
again, we rely on the
low-power accelerometer

00:30:35.020 --> 00:30:37.230
to tell us when the device
moves at which point

00:30:37.230 --> 00:30:39.790
we resume Wi-Fi scanning.

00:30:39.790 --> 00:30:41.630
We also use all three
of these sensors

00:30:41.630 --> 00:30:44.500
to improve the accuracy
of Wi-Fi location.

00:30:44.500 --> 00:30:47.190
If you open Google Maps
indoors and walk around,

00:30:47.190 --> 00:30:50.460
you may notice the blue dot
follow you around the building.

00:30:50.460 --> 00:30:52.620
As I mentioned
before, Wi-Fi accuracy

00:30:52.620 --> 00:30:54.450
alone is not that great.

00:30:54.450 --> 00:30:57.040
But by using sensors,
we can count your steps,

00:30:57.040 --> 00:30:58.940
detect when you
turn, and combine

00:30:58.940 --> 00:31:00.830
this information
with Wi-Fi to hone in

00:31:00.830 --> 00:31:02.088
on a more accurate location.

00:31:05.220 --> 00:31:07.400
Now Ashutosh already talked
about sensor batching,

00:31:07.400 --> 00:31:10.310
where we can accumulate sensor
data on low-power hardware

00:31:10.310 --> 00:31:12.070
and process it later.

00:31:12.070 --> 00:31:13.850
Likewise, we've added
support in the FLP

00:31:13.850 --> 00:31:17.070
for location batching where it
collects location data at lower

00:31:17.070 --> 00:31:21.490
power and processes a batch
of locations after the fact.

00:31:21.490 --> 00:31:25.480
If your application doesn't
need immediate location updates,

00:31:25.480 --> 00:31:28.850
you can save significant
battery by requesting batching.

00:31:28.850 --> 00:31:32.150
This allows the FLP to utilize
sensor batching under the hood

00:31:32.150 --> 00:31:35.490
and also to consolidate
network queries.

00:31:35.490 --> 00:31:36.990
An example of this
use case might

00:31:36.990 --> 00:31:40.260
be a fitness app that
tracks the user's activity.

00:31:40.260 --> 00:31:42.510
They usually periodically
want to check their progress

00:31:42.510 --> 00:31:44.380
throughout the day but
doesn't necessarily

00:31:44.380 --> 00:31:45.485
need constant updates.

00:31:48.550 --> 00:31:50.980
Unlike the other FLP
improvements I've mentioned,

00:31:50.980 --> 00:31:52.990
location batching
requires code changes

00:31:52.990 --> 00:31:55.840
in order to activate the
power savings in your app.

00:31:55.840 --> 00:31:58.520
Here's a code example
to activate batching.

00:31:58.520 --> 00:32:00.320
You use a location
request object

00:32:00.320 --> 00:32:03.290
to provide your apps
constrains to the FLP.

00:32:03.290 --> 00:32:05.170
The set interval
method tells the FLP

00:32:05.170 --> 00:32:07.640
how frequently to
compute locations.

00:32:07.640 --> 00:32:09.670
To activate batching
the magic wait call

00:32:09.670 --> 00:32:12.450
is setMaxWaitTime,
which tells the FLP

00:32:12.450 --> 00:32:16.270
how frequently to deliver
locations to your app.

00:32:16.270 --> 00:32:18.400
So in this particular
example, the FLP

00:32:18.400 --> 00:32:20.180
will compute a
location every minute

00:32:20.180 --> 00:32:22.880
but will deliver them to the
app every 5 minutes, typically

00:32:22.880 --> 00:32:24.110
in batches of 5 locations.

00:32:27.670 --> 00:32:29.950
Now, back to the
fitness app example.

00:32:29.950 --> 00:32:31.870
Let's say it's batching
the user's locations,

00:32:31.870 --> 00:32:33.578
and then the user
opens the app and wants

00:32:33.578 --> 00:32:35.660
to see their
progress immediately.

00:32:35.660 --> 00:32:38.060
The app can call
flushLocations, which

00:32:38.060 --> 00:32:40.600
tells the FLP to interrupt
the batch in progress

00:32:40.600 --> 00:32:44.710
and deliver the most up-to-date
locations as soon as possible.

00:32:44.710 --> 00:32:47.080
The user will see all
locations collected in the app

00:32:47.080 --> 00:32:50.080
and then batching will continue
as previously requested.

00:32:50.080 --> 00:32:52.264
So by making a few
code modifications,

00:32:52.264 --> 00:32:53.680
the fitness app
can take advantage

00:32:53.680 --> 00:32:56.510
of location batching with
significant power savings

00:32:56.510 --> 00:32:59.040
while still providing the same
responsive user experience.

00:33:03.529 --> 00:33:06.070
Now that we've seen the latest
features of the Fused Location

00:33:06.070 --> 00:33:08.630
Provider, I want to briefly
overview another set

00:33:08.630 --> 00:33:11.860
of location APIs-- geofencing.

00:33:11.860 --> 00:33:14.180
The geofencing APIs
notify your app

00:33:14.180 --> 00:33:17.670
when the user enters or exits
predefined areas of interest,

00:33:17.670 --> 00:33:19.910
such as their work or home.

00:33:19.910 --> 00:33:21.979
It's built on top
of the FLP, so it

00:33:21.979 --> 00:33:23.520
inherits all the
new features we just

00:33:23.520 --> 00:33:26.810
talked about that improve
accuracy and conserve power.

00:33:26.810 --> 00:33:30.120
In addition, geofencing
uses activity recognition

00:33:30.120 --> 00:33:32.910
to dynamically manage power
based on the user's speed

00:33:32.910 --> 00:33:37.510
and proximity to the
geofences of interest.

00:33:37.510 --> 00:33:39.490
This code sample shows
how to incorporate

00:33:39.490 --> 00:33:41.480
geofencing into your apps.

00:33:41.480 --> 00:33:43.980
You define up to 100
circular regions of interest

00:33:43.980 --> 00:33:46.190
and register for notification.

00:33:46.190 --> 00:33:48.780
I've highlighted the set
notification responsiveness

00:33:48.780 --> 00:33:51.130
call because it's very
important for minimizing

00:33:51.130 --> 00:33:52.770
power consumption.

00:33:52.770 --> 00:33:54.750
It specifies the
delay you can tolerate

00:33:54.750 --> 00:33:57.850
and receiving notification
when the user enters or exits

00:33:57.850 --> 00:33:58.830
a geofence.

00:33:58.830 --> 00:34:00.470
So your options set
this to be as high

00:34:00.470 --> 00:34:04.580
as is reasonable
for your use case.

00:34:04.580 --> 00:34:07.250
So I've shown a brief
overview of our location APIs

00:34:07.250 --> 00:34:09.860
and how they do the work of
fusing the latest and greatest

00:34:09.860 --> 00:34:11.689
sensor technologies for you.

00:34:11.689 --> 00:34:13.230
Now I'll hand it
back to Steve, who's

00:34:13.230 --> 00:34:15.679
going to talk about our
upcoming hardware features

00:34:15.679 --> 00:34:19.320
and how we plan to incorporate
them into our APIs.

00:34:19.320 --> 00:34:20.216
Great.

00:34:20.216 --> 00:34:22.036
[APPLAUSE]

00:34:24.323 --> 00:34:25.239
STEVE MALKOS: Awesome.

00:34:25.239 --> 00:34:26.429
Thanks, David.

00:34:26.429 --> 00:34:29.560
We just heard how we're moving
more and more algorithms down

00:34:29.560 --> 00:34:31.810
into our low-power
processing domains,

00:34:31.810 --> 00:34:34.780
or how we just want to
offload as much as we can

00:34:34.780 --> 00:34:36.980
from the main
application processor.

00:34:36.980 --> 00:34:38.670
Next, I'm going to
take a deep dive

00:34:38.670 --> 00:34:40.800
and talk to you about
the Android Sensor

00:34:40.800 --> 00:34:44.780
Hub and the cool new things
that we're building for it.

00:34:44.780 --> 00:34:45.489
OK.

00:34:45.489 --> 00:34:47.530
Our mission with the
Android Sensor Hub

00:34:47.530 --> 00:34:50.690
is to use all sensors
in all wireless radios

00:34:50.690 --> 00:34:53.320
on a mobile device so
we could have a better

00:34:53.320 --> 00:34:56.230
understanding of the state
of the user's context

00:34:56.230 --> 00:34:57.950
and location.

00:34:57.950 --> 00:35:00.850
We want to simplify our
user's interactions.

00:35:00.850 --> 00:35:03.710
For example, pick up
to wake the device.

00:35:03.710 --> 00:35:06.580
We want to augment human
memory and knowledge,

00:35:06.580 --> 00:35:12.540
like we did with Google
Now with Where's My Car.

00:35:12.540 --> 00:35:15.390
And we want the users to
have a better understanding

00:35:15.390 --> 00:35:19.070
of themselves, like Google Fit.

00:35:19.070 --> 00:35:20.660
So what did we launch?

00:35:20.660 --> 00:35:24.180
In Marshmallow, we launched
a standalone microcontroller,

00:35:24.180 --> 00:35:26.570
which runs always on processing.

00:35:26.570 --> 00:35:29.850
We did this on the
Nexus 5X and 6P,

00:35:29.850 --> 00:35:32.810
and we open-sourced
it to the ecosystem.

00:35:32.810 --> 00:35:34.960
Why did we need this
separate processor?

00:35:34.960 --> 00:35:37.240
Today the cost of
computing activities

00:35:37.240 --> 00:35:40.280
in an always on fashion
for location and activity

00:35:40.280 --> 00:35:44.380
recognition is really cost
prohibitive because of power.

00:35:44.380 --> 00:35:48.210
By introducing this tiny
three-by-three-millimeter chip,

00:35:48.210 --> 00:35:51.650
we could reduce latencies,
improve accuracies without

00:35:51.650 --> 00:35:54.330
hardly affecting the
user's battery life.

00:35:54.330 --> 00:35:56.610
I'd like to highlight though
that sensor hubs are not

00:35:56.610 --> 00:35:57.690
anything new.

00:35:57.690 --> 00:35:59.680
They've been around
for many years.

00:35:59.680 --> 00:36:03.080
However at Google, we wanted
to standardize on this output

00:36:03.080 --> 00:36:06.520
so that there's more
consistency in the ecosystem.

00:36:06.520 --> 00:36:08.260
This gives us better
insurances that when

00:36:08.260 --> 00:36:10.090
you write your
applications, they'll

00:36:10.090 --> 00:36:14.150
work the same
across all Android.

00:36:14.150 --> 00:36:15.260
So what did we do?

00:36:15.260 --> 00:36:16.320
How did we do this?

00:36:16.320 --> 00:36:19.250
We connected the following
into the Android Sensor Hub--

00:36:19.250 --> 00:36:22.970
accelerometer, gyroscope,
magnetometer, barometer,

00:36:22.970 --> 00:36:25.140
proximity and
ambient light sensor.

00:36:25.140 --> 00:36:27.170
By establishing
these connections,

00:36:27.170 --> 00:36:29.374
we were able to
achieve the following.

00:36:29.374 --> 00:36:31.290
I'm not going to read
through this whole list,

00:36:31.290 --> 00:36:33.880
but I want to highlight
some examples.

00:36:33.880 --> 00:36:36.150
It's running everything
in sensors.h.

00:36:36.150 --> 00:36:39.390
This includes things like
game-rotation vectors gravity.

00:36:39.390 --> 00:36:41.140
We're running significant
motion detector,

00:36:41.140 --> 00:36:44.470
which is the primary use
case for Android Does' mode.

00:36:44.470 --> 00:36:47.600
All of our activity-recognition
models are in this hub.

00:36:47.600 --> 00:36:51.240
And we introduced new
gestures, like Double Twist,

00:36:51.240 --> 00:36:53.600
which is a private sensor
that you could register

00:36:53.600 --> 00:36:56.780
your application to today.

00:36:56.780 --> 00:36:59.030
So what are we saving
in terms of power?

00:36:59.030 --> 00:36:59.940
It's quite simple.

00:36:59.940 --> 00:37:02.260
When you run activity
recognition on the application

00:37:02.260 --> 00:37:05.090
processor, it consumes
quite a bit of power.

00:37:05.090 --> 00:37:06.640
When we introduce
sensor batching,

00:37:06.640 --> 00:37:09.200
we were able to cut that
number down in half.

00:37:09.200 --> 00:37:11.690
Running that same
activity-recognition model

00:37:11.690 --> 00:37:13.780
on the Android
Sensor Hub costs us

00:37:13.780 --> 00:37:18.170
just a fraction of the power,
and this is just the start.

00:37:18.170 --> 00:37:21.970
So here's a sneak peek on what
we're working on this year.

00:37:21.970 --> 00:37:24.560
I'm going to highlight
some of the big items.

00:37:24.560 --> 00:37:27.750
We're introducing
GPS pseudoranges.

00:37:27.750 --> 00:37:31.750
This is groundbreaking as
it's the first time in history

00:37:31.750 --> 00:37:36.400
a mobile application will have
direct access to the raw GPS

00:37:36.400 --> 00:37:37.650
measurements.

00:37:37.650 --> 00:37:41.200
This is beneficial to many,
but especially the phone makers

00:37:41.200 --> 00:37:43.610
because they could use these
measurements to help them

00:37:43.610 --> 00:37:46.370
in their GPS
performance testing.

00:37:46.370 --> 00:37:49.150
And if you ever
had a bright idea

00:37:49.150 --> 00:37:53.490
on how to use GPS measurements,
now's your time to shine.

00:37:53.490 --> 00:37:55.590
We're also introducing
personalized

00:37:55.590 --> 00:37:57.960
activity-recognition
models because we all

00:37:57.960 --> 00:38:00.680
know my step length is
different from your step length.

00:38:00.680 --> 00:38:02.840
By having a personalized
model, we'll

00:38:02.840 --> 00:38:07.554
be able to better our accuracies
for activity recognition.

00:38:07.554 --> 00:38:08.970
With the Android
Sensor Hub, we'll

00:38:08.970 --> 00:38:11.290
introduce downloadable code.

00:38:11.290 --> 00:38:14.270
In Marshmallow when we
launched activity recognition,

00:38:14.270 --> 00:38:17.690
we lost the capability of
updating our algorithms

00:38:17.690 --> 00:38:20.440
frequently but gained
the power savings

00:38:20.440 --> 00:38:24.260
by running those in
the low-power domain.

00:38:24.260 --> 00:38:27.230
In Android N,
we'll have the best

00:38:27.230 --> 00:38:29.670
of both worlds--
low-power activity

00:38:29.670 --> 00:38:32.330
recognition with the
capabilities of continually

00:38:32.330 --> 00:38:34.420
updating our algorithms.

00:38:34.420 --> 00:38:38.450
We'll also connect GPS,
Wi-Fi, and cell directly

00:38:38.450 --> 00:38:43.050
into the Sensor Hub, which I'll
talk about in the next slide.

00:38:43.050 --> 00:38:45.490
So by adding these additional
connectivity signals,

00:38:45.490 --> 00:38:49.730
we're going to move our entire
location engine into the Hub.

00:38:49.730 --> 00:38:53.540
I noted earlier that
power has two sub-pillars.

00:38:53.540 --> 00:38:56.050
Those were latency and accuracy.

00:38:56.050 --> 00:38:59.980
By moving the location stack
down into the low-power domain,

00:38:59.980 --> 00:39:02.890
we'll improve geofencing
because the location

00:39:02.890 --> 00:39:03.970
engine's running there.

00:39:03.970 --> 00:39:06.690
So latency will become
better because we

00:39:06.690 --> 00:39:09.390
could run more
often, and accuracies

00:39:09.390 --> 00:39:12.020
will become better because
we will have access

00:39:12.020 --> 00:39:14.020
to more signals.

00:39:14.020 --> 00:39:15.820
So those are the main
themes for this year.

00:39:15.820 --> 00:39:19.100
Let's touch a bit in the future.

00:39:19.100 --> 00:39:22.800
In order to truly understand
the state of a user's context

00:39:22.800 --> 00:39:26.240
and location, we need to
answer the following three

00:39:26.240 --> 00:39:27.950
key questions.

00:39:27.950 --> 00:39:29.300
Where's the user?

00:39:29.300 --> 00:39:34.240
Examples-- GPS, latitude,
longitude, geofencing,

00:39:34.240 --> 00:39:40.020
which is within your circle
or not, and semantic location,

00:39:40.020 --> 00:39:41.720
like where am I?

00:39:41.720 --> 00:39:44.080
I'm in Starbucks.

00:39:44.080 --> 00:39:48.110
For activity, we need to
answer, what is the user doing?

00:39:48.110 --> 00:39:50.640
Are they walking,
running, on a bike?

00:39:50.640 --> 00:39:55.080
And for nearby, we need to
answer, which devices can I

00:39:55.080 --> 00:39:56.550
connect to?

00:39:56.550 --> 00:39:59.390
Which Chromecast
devices are nearby?

00:39:59.390 --> 00:40:03.280
So in order to achieve or answer
these three key questions,

00:40:03.280 --> 00:40:05.660
we need to push down
everything listed here

00:40:05.660 --> 00:40:07.730
into the low-power
compute domain.

00:40:07.730 --> 00:40:10.360
For a location, we're already
working on the Fused Location

00:40:10.360 --> 00:40:12.950
Provider and
geofencing this year.

00:40:12.950 --> 00:40:15.220
For activity recognition,
we'll continue

00:40:15.220 --> 00:40:18.920
to add new sensors and new
activity-recognition algorithms

00:40:18.920 --> 00:40:20.820
down into the low-power domain.

00:40:20.820 --> 00:40:24.140
And for nearby, we'll work
on adding nearby connections

00:40:24.140 --> 00:40:26.540
and messages into
the low-power domain.

00:40:26.540 --> 00:40:29.630
So by answering these
three key questions,

00:40:29.630 --> 00:40:31.860
the Android Sensor
Hub will bring

00:40:31.860 --> 00:40:35.970
the best of Google's databases,
machine-learning algorithms,

00:40:35.970 --> 00:40:39.290
and Google infrastructure
at the lowest power.

00:40:39.290 --> 00:40:41.830
This will allow us
to bring you always

00:40:41.830 --> 00:40:45.280
on location and
personalized context.

00:40:45.280 --> 00:40:48.160
We'll continue to add
more and more signals down

00:40:48.160 --> 00:40:49.930
into these low-power domains.

00:40:49.930 --> 00:40:54.750
We've already achieved activity
recognition and sensors

00:40:54.750 --> 00:40:57.320
in Marshmallow and soon
are about to launch

00:40:57.320 --> 00:40:59.200
location and
dynamically downloadable

00:40:59.200 --> 00:41:01.940
code in N. The
future will become

00:41:01.940 --> 00:41:05.730
more and more contextually aware
and, by adding these signals,

00:41:05.730 --> 00:41:08.810
will help make you
deeper, richer experiences

00:41:08.810 --> 00:41:10.200
in your applications.

00:41:10.200 --> 00:41:13.140
We're truly excited
about these possibilities

00:41:13.140 --> 00:41:16.700
and are looking forward to
ushering a new wave of APIs

00:41:16.700 --> 00:41:18.440
for your applications.

00:41:18.440 --> 00:41:19.884
Thank you.

00:41:19.884 --> 00:41:21.852
[APPLAUSE]

00:41:26.780 --> 00:41:30.890
So I have one last
slide if we could go--

00:41:30.890 --> 00:41:32.630
we have a new developers site.

00:41:32.630 --> 00:41:35.227
This is a nice refresh site.

00:41:35.227 --> 00:41:36.727
Go to
developers.google.com/location

00:41:36.727 --> 00:41:37.227
awareness.

00:41:40.890 --> 00:41:45.270
We've placed all of our APIs in
a fresh new look for you guys

00:41:45.270 --> 00:41:48.930
to access our location
and context information.

00:41:48.930 --> 00:41:51.270
We also have a quick
survey that we'd

00:41:51.270 --> 00:41:54.890
be really interested in getting
your feedback on our sensor

00:41:54.890 --> 00:41:55.410
APIs.

00:41:55.410 --> 00:41:58.560
So please go to the
second link and fill out

00:41:58.560 --> 00:41:59.750
this quick and easy survey.

00:41:59.750 --> 00:42:02.200
You could do it at your
leisure or do it right now.

00:42:02.200 --> 00:42:04.340
And then lastly,
David, Ashutosh,

00:42:04.340 --> 00:42:06.110
and I will hang outside
for a little while

00:42:06.110 --> 00:42:07.510
if you guys have any questions.

00:42:07.510 --> 00:42:10.460
Or we have office hours
on Thursday and Friday

00:42:10.460 --> 00:42:11.560
at these times.

00:42:11.560 --> 00:42:12.950
Thank you very much.

00:42:12.950 --> 00:42:14.150
[APPLAUSE]

00:42:15.650 --> 00:42:18.100
[MUSIC PLAYING]

