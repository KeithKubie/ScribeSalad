WEBVTT
Kind: captions
Language: en

00:00:00.020 --> 00:00:03.720
The same problem of summing up from one to ten

00:00:04.860 --> 00:00:06.860
is actually done by what would appear to be magic

00:00:07.900 --> 00:00:11.660
by simply going, "sum... one... ten."

00:00:11.820 --> 00:00:12.340
Done.

00:00:12.340 --> 00:00:13.820
It's not quite as easy as that.

00:00:16.660 --> 00:00:20.280
One of the questions that I get asked umm when introduce myself as a computer scientist is

00:00:20.280 --> 00:00:24.480
what exactly is I do and the easiest answer for that is, "programming."

00:00:25.060 --> 00:00:26.360
There are different styles and

00:00:27.420 --> 00:00:29.420
a lot of people might not be aware of them

00:00:29.420 --> 00:00:35.460
so, today, I'm just going contrast two of the most popular ones.

00:00:35.640 --> 00:00:38.180
Namely, imperative programming and functional programming.

00:00:38.300 --> 00:00:40.600
Adding the numbers from one to ten in two languages

00:00:40.780 --> 00:00:41.820
Java and Haskell

00:00:42.380 --> 00:00:43.680
So, we'll start with Java.

00:00:45.040 --> 00:00:49.940
We begin by introducing a variable, "total", an integer and saying, "well, that's zero to start with."

00:00:50.460 --> 00:00:51.380
because we haven't added anything up yet.

00:00:51.860 --> 00:00:53.060
and that's comparatively easy.

00:00:53.460 --> 00:00:56.980
and the actual meat of the loop is done by opening up a for loop

00:00:57.900 --> 00:01:02.580
where we say, "for some number int i = 0

00:01:03.500 --> 00:01:09.100
and i less than or equal to ten then i plus plus

00:01:09.100 --> 00:01:10.800
and what that means here

00:01:10.800 --> 00:01:15.280
is we've got this little tracking variable, i, which we initialize to zero

00:01:15.700 --> 00:01:18.500
we're going to be repeating this loop as long as it's less than

00:01:18.500 --> 00:01:19.620
or equal to 10.

00:01:19.620 --> 00:01:22.300
And every time we repeat the loop, we're going to increase "i" by 1.

00:01:22.300 --> 00:01:23.860
We're adding numbers 1 to 10

00:01:23.860 --> 00:01:25.620
so the obvious thing to do

00:01:25.980 --> 00:01:29.560
is to say we'll change the variable "total" to the result of

00:01:29.560 --> 00:01:31.240
"total" plus "i."

00:01:31.800 --> 00:01:33.800
All we have here, is we've got an appearance of

00:01:34.820 --> 00:01:36.820
the "equals" sign--some people would look at this and go

00:01:37.620 --> 00:01:39.620
"Right. This is clearly the mathematical definition of 'equals'."

00:01:39.620 --> 00:01:41.440
"which means that the left hand is equal to the right hand side."

00:01:41.720 --> 00:01:43.720
Now, that's not the case in Java and other "C-like" languages.

00:01:43.720 --> 00:01:45.400
What this single "equals" actual means

00:01:45.680 --> 00:01:51.280
is, um, an assignment. We're saying that "total" is now equal to the previous

00:01:51.520 --> 00:01:55.200
value of "total" and we've added to it in some way. In this way we've added 1 to it.

00:01:56.509 --> 00:02:00.860
equals then we would be checking for
equality in which case this total equals

00:02:00.860 --> 00:02:07.039
total plus what I would be false in all
cases except for when I was 0 so this

00:02:07.039 --> 00:02:10.940
kind of statement that involves
variables such as total is

00:02:10.940 --> 00:02:14.990
characteristic imperative languages
where the main method of computation is

00:02:14.990 --> 00:02:17.180
assignment of values to variables

00:02:17.180 --> 00:02:24.140
that's going to say we start with total
zero its a 50 total equals 0 plus 0 0

00:02:24.140 --> 00:02:27.800
then we go back we increase i buy one

00:02:27.800 --> 00:02:34.250
so now we say okay total is 0 plus 1
which is one we go back is now to total

00:02:34.250 --> 00:02:35.660
is 1 plus 2

00:02:35.660 --> 00:02:39.980
it's now three and we repeat once we get
to the ends then we're done

00:02:39.980 --> 00:02:46.280
if we want to call total then it would
just be the result of going 1 + 2 + 3 +

00:02:46.280 --> 00:02:50.000
w and eventually at the end of it will
have total if we were to do a calling it

00:02:50.000 --> 00:02:50.990
is 55

00:02:50.990 --> 00:02:55.400
because that's the sum from one step
this is a characteristic of imperative

00:02:55.400 --> 00:02:58.140
programming in that we are referring two
variables

00:02:58.140 --> 00:03:03.900
that are defined globally this is a
simple example of adding a couple of

00:03:03.900 --> 00:03:05.910
numbers up in an imperative language

00:03:05.910 --> 00:03:09.720
namely this is done in java

00:03:09.720 --> 00:03:13.709
what I'd like to do now having just
spoken about the mathematical definition

00:03:13.709 --> 00:03:17.940
of equals move on to a another language
in which to do this something from one

00:03:17.940 --> 00:03:18.450
to ten

00:03:18.450 --> 00:03:21.440
namely Haskell which is a functional
programming language

00:03:21.440 --> 00:03:27.890
so the same problem of something up from
one to ten is actually done by what

00:03:27.890 --> 00:03:30.530
would appear to be magic are simply
going

00:03:30.530 --> 00:03:34.100
some 110 done

00:03:34.100 --> 00:03:37.250
it's not quite as easy as that there is
a library function in the background

00:03:37.250 --> 00:03:40.310
that's explaining how some actually
works

00:03:40.310 --> 00:03:43.220
the first thing that we need to know
about the sum function is what it's type

00:03:43.220 --> 00:03:50.750
is so we would say that the function sum
is the function that takes a list of

00:03:50.750 --> 00:03:51.440
integers

00:03:51.440 --> 00:03:56.030
this is syntax for list and it returns a
single integer

00:03:56.030 --> 00:04:00.920
namely if we take a list from one to ten
we're going to return some of them and

00:04:00.920 --> 00:04:04.040
what we're going to do now is we're
going to define this function in terms

00:04:04.040 --> 00:04:11.480
of pattern matching a function can have
multiple definitions associated with the

00:04:11.480 --> 00:04:17.180
value that's given to it what pattern
matching ends is a way of deciding which

00:04:17.180 --> 00:04:21.739
definition of a function to apply in a
given case depending on the structure of

00:04:21.739 --> 00:04:26.480
the input so let's say that we are
looking at a function that takes lists

00:04:26.480 --> 00:04:30.919
then that function could be looking at
an empty list

00:04:30.919 --> 00:04:34.220
it could be looking at a list with one
element in it or it could be looking at

00:04:34.220 --> 00:04:39.169
one with more than that and a simpler
example perhaps is a function is defined

00:04:39.169 --> 00:04:40.400
over the billions

00:04:40.400 --> 00:04:44.900
so a billion value can either be true or
false and a function that's to find out

00:04:44.900 --> 00:04:50.120
of that the obvious one will be not so
not true is false not false is true and

00:04:50.120 --> 00:04:51.560
if we're using pattern matching

00:04:51.560 --> 00:04:55.910
I'm going to take my value and say is it
true if the value that I've got is true

00:04:55.910 --> 00:04:59.630
then i use the function definition of
going to false if the value that I've

00:04:59.630 --> 00:05:03.980
got is false it will say look at this
first line and well if I got true no i

00:05:03.980 --> 00:05:07.280
don't i'll go down to the next one and
also

00:05:07.280 --> 00:05:10.460
okay well I've got a match there when
you look at a function your input

00:05:10.460 --> 00:05:15.110
you will try and match from the top say
is that the 1i need no right

00:05:15.110 --> 00:05:20.000
look at the next one is that the one I
need no is next one and it may be the

00:05:20.000 --> 00:05:25.730
case that you don't have all of the
patterns necessary to fully define your

00:05:25.730 --> 00:05:28.080
function in which case a school will
give you an error

00:05:28.080 --> 00:05:34.979
it's a non-exhaustive patterns so if we
have this sum of a single number

00:05:34.979 --> 00:05:38.550
this is a list of one element we say
that the results of the sum of one

00:05:38.550 --> 00:05:44.069
number is just that one number and if we
have a list of more than one number then

00:05:44.069 --> 00:05:45.569
we would write it like this

00:05:45.569 --> 00:05:49.740
some and ends this is just shorthand for
saying that the element that's at the

00:05:49.740 --> 00:05:54.000
front of the list we call n all the
other elements are called ends and we

00:05:54.000 --> 00:06:00.330
were just define that as n plus some
ends so this function sum is defined

00:06:00.330 --> 00:06:03.240
recursively that is to say it's defined
in terms of itself

00:06:03.240 --> 00:06:05.430
what I might like to do for some people
aren't familiar with functional

00:06:05.430 --> 00:06:07.949
programming is going through a very
quick example of how the sum function

00:06:07.949 --> 00:06:12.690
works some of 452

00:06:13.229 --> 00:06:17.580
so we can refer to this function here
and throughout and see how this is

00:06:17.580 --> 00:06:20.969
equivalent to the java representation
that we've got over here

00:06:20.969 --> 00:06:25.139
so what pattern matching involves we
look down and say are we looking at a

00:06:25.139 --> 00:06:26.370
single list

00:06:26.370 --> 00:06:30.120
no we're not so we can move down to the
next pattern and we say okay

00:06:30.120 --> 00:06:37.289
in this instance this for is the end of
this 52 is the ends so this is defined

00:06:37.289 --> 00:06:47.129
to be 4 plus the son of 52 grand next
step we're going again

00:06:47.129 --> 00:06:50.339
summers are defined in terms of itself
we haven't gotten down to the base value

00:06:50.339 --> 00:06:52.229
yet so we're going to have to carry on

00:06:52.229 --> 00:06:56.580
so we do so by saying okay so what you
mean by the base for them

00:06:56.580 --> 00:07:01.949
ok so functional programming the main
method of computation for that is

00:07:01.949 --> 00:07:06.120
applying arguments to functions as
compared with Java but it's assigning

00:07:06.120 --> 00:07:09.180
values to variables by here when I say
we've reached a value

00:07:09.930 --> 00:07:14.819
I mean that we've evaluated a singleton
and returned and so to carry on with

00:07:14.819 --> 00:07:22.919
this evaluation hear what I want to do
is to say okay that's some five plus sum

00:07:22.919 --> 00:07:28.979
of two because in this instance here
this was the end and this was the ends

00:07:28.979 --> 00:07:33.719
and now I carry on and I say oh well if
I'm going to be corrected going to

00:07:33.719 --> 00:07:39.149
bracket that and say four plus five plus
now i can look and say

00:07:39.660 --> 00:07:43.560
pattern matching start from the top have
I got a single to list yes I do

00:07:43.560 --> 00:07:46.620
so what am I going to return just that
number two

00:07:47.190 --> 00:07:54.660
so now I can start boiling it down so
that's 4 plus 7 equals 11

00:07:54.660 --> 00:07:58.860
so wyd gone through here is just a quick
example of how a functional programming

00:07:58.860 --> 00:08:06.540
would take the approach to some function
defining what the some actually does as

00:08:06.540 --> 00:08:11.160
opposed to looking down and doing it in
terms of variables saying will track

00:08:11.160 --> 00:08:15.570
this and add it to this and eventually
the result will fall outfit

00:08:15.570 --> 00:08:19.800
it's it's probably worth saying though
that this isn't how some is defined in

00:08:19.800 --> 00:08:28.890
my Haskell high bring it is actually
defined as some fold l + 0 but that is

00:08:28.890 --> 00:08:31.680
dark out that I don't want to get into
it

00:08:31.680 --> 00:08:36.180
this video so one particularly important
thing to take away here given that i've

00:08:36.180 --> 00:08:39.870
been contrasting these two is that in
this example here where I've been

00:08:39.870 --> 00:08:41.880
something one to ten in java

00:08:41.880 --> 00:08:46.470
this is revolved somewhat around this
variable total which has been evolving

00:08:46.470 --> 00:08:48.600
as the for loop progresses

00:08:48.600 --> 00:08:53.880
I've been updating this total variable
and increasing it to reflect a new value

00:08:53.880 --> 00:08:55.860
until I get to the end of the for loop

00:08:55.860 --> 00:08:59.370
so this is characteristic of imperative
programming languages

00:08:59.370 --> 00:09:03.150
the fact that i have a external global
variable that i can update a will

00:09:03.150 --> 00:09:07.860
whereas in functional programming and
high school there is no state externally

00:09:07.860 --> 00:09:13.110
I'm not calling anything from outside
this sum function this sum from 1 to 10

00:09:13.110 --> 00:09:17.850
is defined entirely in terms of itself
there is no reference to a total or

00:09:17.850 --> 00:09:21.600
something that's not explicitly
reachable from inside this function body

00:09:21.600 --> 00:09:25.560
and that's because functional
programming languages or purely

00:09:25.560 --> 00:09:28.800
functional programming languages don't
allow for side effects and a particular

00:09:28.800 --> 00:09:32.610
example of a side effect is a mutable
state swear by mutable

00:09:32.610 --> 00:09:36.480
I mean it can mutate you can update it
so it can change from one value to

00:09:36.480 --> 00:09:38.640
another as a program progresses

00:09:38.640 --> 00:09:43.050
it's worth saying that these are both
high level instances of languages and

00:09:43.050 --> 00:09:46.770
particularly simple instances of
fragments from these high-level

00:09:46.770 --> 00:09:47.760
languages

00:09:47.760 --> 00:09:52.080
these do look quite different in the way
that they approach things but they will

00:09:52.080 --> 00:09:53.020
be boiled down

00:09:53.020 --> 00:09:56.530
to machine code and very similar machine
go to that given that it does something

00:09:56.530 --> 00:10:01.270
quite simple and in effectively the same
way it's something one to ten it's not

00:10:01.270 --> 00:10:07.780
something that can be done very very
complicated ways by different compilers

00:10:07.780 --> 00:10:12.430
what if the university is just a
computer simulation

00:10:13.180 --> 00:10:16.420
how would we know what sort of things
when we expect to see

00:10:16.930 --> 00:10:20.650
could we have our tab could we ever be
able to work out that work

00:10:20.650 --> 00:10:25.210
you know living in proud of a simulation
of words and being pivoted down putting

00:10:25.210 --> 00:10:28.690
all the elements lesson on one side and
then Christ on the other side

00:10:28.690 --> 00:10:32.920
I mean it that does not get any to
something like side so you can see it's

00:10:32.920 --> 00:10:36.940
kind of it's done all the left hand side
and I start doing the right hand side so

00:10:36.940 --> 00:10:39.010
the paper it does all the left hand side

00:10:39.010 --> 00:10:42.670
it's another pivot keeps doing this this
animal until it's sorted

