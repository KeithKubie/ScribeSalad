WEBVTT
Kind: captions
Language: en

00:00:04.150 --> 00:00:06.840
&gt;&gt;Jorge Lucangeli Obes: Good morning, everyone,
and thanks for joining the session.

00:00:06.840 --> 00:00:09.240
My name is Jorge, and I work with the Chrome
Security team.

00:00:09.240 --> 00:00:14.480
Today I'll be talking about how to make Chrome
apps and extensions be more secure.

00:00:14.480 --> 00:00:20.020
And as the subtitle of the talk says, we want
to focus on keeping the users of these apps

00:00:20.020 --> 00:00:21.189
and extensions safe.

00:00:21.189 --> 00:00:27.250
Now, a lot of work has been done, not only
by Google, but by other browser vendors as

00:00:27.250 --> 00:00:29.429
well, to make browsers more secure.

00:00:29.429 --> 00:00:31.310
What does this mean?

00:00:31.310 --> 00:00:36.410
It's harder now for a malicious Web site,
any random Web site to compromise a browser

00:00:36.410 --> 00:00:42.230
in a way in which it would allow the attacker
to execute arbitrary code in the user's device.

00:00:42.230 --> 00:00:48.350
However, in order to also protect the user's
data, the data that the user keeps in your

00:00:48.350 --> 00:00:54.150
Web app or Chrome app or Chrome extension,
we need the help of you, the developers.

00:00:54.150 --> 00:00:58.980
The browser by itself cannot completely protect
the user's data from attack.

00:00:58.980 --> 00:01:05.939
Now, the good news is that the Web platform
itself has been exposed to untrusted content

00:01:05.939 --> 00:01:08.600
or malicious content basically from the start.

00:01:08.600 --> 00:01:12.720
That doesn't mean we're always scared about
this malicious content, but we've made a lot

00:01:12.720 --> 00:01:18.010
of progress integrating features that allow
developers to make their Web apps more secure.

00:01:18.010 --> 00:01:23.470
However, we haven't seen the level of adoption
that we would have liked.

00:01:23.470 --> 00:01:28.280
And an objective of the session is to tell
you about these features so that you can use

00:01:28.280 --> 00:01:30.890
them and make your applications more secure.

00:01:30.890 --> 00:01:35.150
The browser, together with the application
developers, will really make applications

00:01:35.150 --> 00:01:36.830
secure.

00:01:36.830 --> 00:01:45.090
Now, of course, a 45-minute long talk is not
enough to cover every single aspect of Web

00:01:45.090 --> 00:01:47.190
app security, so I'm going to focus on the
client side.

00:01:47.190 --> 00:01:51.799
I'm going to try to go over the features that
can be leveraged both by regular Web apps,

00:01:51.799 --> 00:01:57.820
by Chrome apps, Chrome extensions, even the
ones that run offline.

00:01:57.820 --> 00:02:02.960
Now, I talked about the Web platform and how
we have incorporated features that help developers

00:02:02.960 --> 00:02:04.630
make more secure Web apps.

00:02:04.630 --> 00:02:10.259
I'm going to focus on two of them which we
believe, the security community at large believe

00:02:10.259 --> 00:02:12.409
provide the best bang for the buck.

00:02:12.409 --> 00:02:14.689
Number one, content security policy.

00:02:14.689 --> 00:02:20.739
If people here attended a talk on Wednesday
about Manifest Version 2 and Extensions Version

00:02:20.739 --> 00:02:24.040
2, they probably have heard about CSP.

00:02:24.040 --> 00:02:27.349
And they probably also have heard about HTML5
sandboxed iFrames.

00:02:27.349 --> 00:02:31.389
I'm going to talk about these two technologies
and show how you use them, common pitfalls

00:02:31.389 --> 00:02:38.079
that occur when you use them, so that you
can leave the talk and at least if you leave

00:02:38.079 --> 00:02:42.220
the talk and try to use some of these features
in your apps and extensions, I will be very,

00:02:42.220 --> 00:02:44.050
very happy indeed.

00:02:44.050 --> 00:02:49.730
Now, before going in-depth into the features
I want to take a couple of seconds to go over

00:02:49.730 --> 00:02:51.659
the same origin policy real quick.

00:02:51.659 --> 00:03:00.169
The same origin policy is the basic security
policy that browsers and user agents try to

00:03:00.169 --> 00:03:02.099
get Web sites to comply to in the Web.

00:03:02.099 --> 00:03:07.180
And the same origin policy basically says
that two objects can interact directly if

00:03:07.180 --> 00:03:09.890
and only if they belong to the same origin.

00:03:09.890 --> 00:03:16.700
An origin, which is taken from the URI of
those subjects by looking into the schema,

00:03:16.700 --> 00:03:19.220
the host and the port of that URI.

00:03:19.220 --> 00:03:24.999
Now, the good thing about talking and reasoning
about origins is that the most common security

00:03:24.999 --> 00:03:28.159
vulnerabilities can be described in terms
of origins.

00:03:28.159 --> 00:03:32.949
When untrusted content or script gains the
authority or runs in the context of a particular

00:03:32.949 --> 00:03:35.159
origin, we talk about cross-site scripting.

00:03:35.159 --> 00:03:39.900
When a possibly malicious origin gets the
network access privileges, the Web request

00:03:39.900 --> 00:03:43.180
privileges of another origin, we talk about
cross-site request forgery.

00:03:43.180 --> 00:03:46.969
And for some reason which I don't understand,
people really like to say cross-site scripting

00:03:46.969 --> 00:03:51.200
with an X and cross-site request forgery with
a C. I will never get that.

00:03:51.200 --> 00:03:57.199
Now, a lot of the features that I'm going
to talk about today can be very easily implemented

00:03:57.199 --> 00:04:01.790
in an extensions manifest or a Chrome apps
manifest.

00:04:01.790 --> 00:04:07.699
But after helping many teams at Google write
more secure apps and extensions, either for

00:04:07.699 --> 00:04:12.529
Chrome or for Chrome OS, I notice that people
made the same mistakes over and over again

00:04:12.529 --> 00:04:18.060
not because they didn't know what they had
to do, but because there's some tricky, like,

00:04:18.060 --> 00:04:23.560
nuances that one has to know in order to make
CSP or sandbox iFrames work correctly.

00:04:23.560 --> 00:04:28.750
So I wrote a very simple app, which I call
Manifest Lint.

00:04:28.750 --> 00:04:33.360
Not very creative, but that's what I got.

00:04:33.360 --> 00:04:37.129
It will highlight sections of the manifest
that are okay from a security perspective

00:04:37.129 --> 00:04:39.400
and sections that might need help.

00:04:39.400 --> 00:04:43.900
In this case I am feeding the actual manifest
of the Manifest Lint application to itself

00:04:43.900 --> 00:04:46.979
and it's telling me that I'm not setting a
content security policy.

00:04:46.979 --> 00:04:54.370
Now, I will go deeper into content security
policy in a couple of slides.

00:04:54.370 --> 00:04:57.960
But first I want to show you what happens
when one develops an application and doesn't

00:04:57.960 --> 00:05:01.250
really take into account security.

00:05:01.250 --> 00:05:10.770
Now, I wrote this application in time to demo
it at I/O, and one could wonder what happens

00:05:10.770 --> 00:05:16.639
if the application takes a manifest in that
text area and displays the highlighted manifest

00:05:16.639 --> 00:05:18.360
on the other side.

00:05:18.360 --> 00:05:24.199
Now, what happens if the application receives
a manifest that is not necessarily benign,

00:05:24.199 --> 00:05:27.009
that is malicious or malformed?

00:05:27.009 --> 00:05:28.729
Well, let's try that.

00:05:28.729 --> 00:05:33.419
I'm going to switch video, and if I cannot
make this demo work after what Sergey did

00:05:33.419 --> 00:05:37.129
on Wednesday, I'm going to feel really, really
bad.

00:05:37.129 --> 00:05:44.180
[ Laughter ]
&gt;&gt;Jorge Lucangeli Obes: Okay.

00:05:44.180 --> 00:05:45.590
Awesome.

00:05:45.590 --> 00:05:51.530
Now, the extension -- the app basically takes
a manifest and displays it highlighted on

00:05:51.530 --> 00:05:52.530
the other side.

00:05:52.530 --> 00:05:57.509
It also saves the manifests to local storage
so that I can bring them back and not have

00:05:57.509 --> 00:05:59.240
to input them all the time.

00:05:59.240 --> 00:06:03.220
Now, what happens if I input this manifest?

00:06:03.220 --> 00:06:07.210
I hope -- yeah, font size is okay.

00:06:07.210 --> 00:06:08.909
Which has a very weird description.

00:06:08.909 --> 00:06:13.430
It's got HTML tags in its description and
image tag and JavaScript.

00:06:13.430 --> 00:06:15.659
It's not looking good.

00:06:15.659 --> 00:06:24.849
If I input this manifest into my extension,
nothing will happen, but maybe eventually

00:06:24.849 --> 00:06:32.990
the user might go over a part of the manifest
and I hope it reads, but that's one of the

00:06:32.990 --> 00:06:35.250
things that's stored in local storage.

00:06:35.250 --> 00:06:43.669
Now, we don't expect just random input to
be able to read local storage of the application.

00:06:43.669 --> 00:06:45.800
And in this case it's just manifest.

00:06:45.800 --> 00:06:50.509
It's not really secret or private, but this
could be user's data, private data, email,

00:06:50.509 --> 00:06:56.460
whatever, anything that's stored in the app
or the extensions origin is now available

00:06:56.460 --> 00:07:02.590
just one confusion, one trick away from an
attacker.

00:07:02.590 --> 00:07:09.700
I'm going to go back to the slides.

00:07:09.700 --> 00:07:16.389
What's the problem?

00:07:16.389 --> 00:07:17.810
That's the problem.

00:07:17.810 --> 00:07:26.300
I'm using eval to parse JSON and I'm using
inner HTML to display the highlighted manifest.

00:07:26.300 --> 00:07:34.499
Now, I'm not going to go very deep into what
the exploit does, but it's basically using

00:07:34.499 --> 00:07:41.080
the fact that I'm using inner HTML to inject
script into the application that is triggered

00:07:41.080 --> 00:07:43.639
when the user mouses over the image.

00:07:43.639 --> 00:07:48.110
Now, since I'm -- since the use of inner HTML
basically allows me to inject any sort of

00:07:48.110 --> 00:07:54.999
tag or script that I want, that's basically
giving a straight way for an attacker to get

00:07:54.999 --> 00:07:56.780
malicious input into my application.

00:07:56.780 --> 00:08:00.819
And this is where content security policy
comes in.

00:08:00.819 --> 00:08:05.949
In a nutshell, content security policy is
a way for me, the application or extension

00:08:05.949 --> 00:08:13.710
developer, to tell the browser, only allow
me, the application, to load resources or

00:08:13.710 --> 00:08:17.250
script from this whitelist or trusted sources.

00:08:17.250 --> 00:08:24.340
Now, it might be -- might sound kind of weird
since I'm telling the browser to restrict

00:08:24.340 --> 00:08:30.129
what I'm -- what me, the application, is allowed
to do, but since we've seen in the demo that

00:08:30.129 --> 00:08:37.730
it's very easy to hijack the behavior of an
application, it's a very powerful tool, CSP,

00:08:37.730 --> 00:08:44.730
and it allows me to -- beforehand to say I
don't want to be able to load anything outside

00:08:44.730 --> 00:08:48.150
of these trusted sources.

00:08:48.150 --> 00:08:54.710
By doing this, by not allowing the application
to load script or resources from untrusted

00:08:54.710 --> 00:09:04.200
sources, we prevent most cross-site scripting
attacks; however, in order to be able to tell

00:09:04.200 --> 00:09:09.600
whether the script or the resource that we
are loading actually belongs in the whitelist

00:09:09.600 --> 00:09:14.510
or not, we need to be able to tell where that
script comes from.

00:09:14.510 --> 00:09:19.960
And the problem is that we are not always
able to do that if the script that we're loading

00:09:19.960 --> 00:09:24.210
is included in-line, in the application.

00:09:24.210 --> 00:09:32.320
There's no way for the browser to tell whether
inline script has been put there by the developer

00:09:32.320 --> 00:09:37.090
or has been injected due to a bug in the application.

00:09:37.090 --> 00:09:42.320
The only way in which CSP can fulfill its
purpose and actually block things that are

00:09:42.320 --> 00:09:49.700
not in the whitelist is to ban all the uses
of inline script or features in JavaScript

00:09:49.700 --> 00:09:56.080
that turn strings into code because you can
never be sure whether the inline script was

00:09:56.080 --> 00:09:59.950
malicious or not or whether the string that's
been turned into code by eval is malicious

00:09:59.950 --> 00:10:01.050
or not.

00:10:01.050 --> 00:10:03.160
Now, how do we use it?

00:10:03.160 --> 00:10:06.950
If you're writing Chrome app or in extension
it's really, really simple.

00:10:06.950 --> 00:10:13.250
You just add one line to the manifest called,
very creatively, content security policy.

00:10:13.250 --> 00:10:19.470
And a content security policy itself is just
a list of allowed sources for different types

00:10:19.470 --> 00:10:21.090
of resources.

00:10:21.090 --> 00:10:25.890
In this case what we're saying is that by
default the application is only allowed to

00:10:25.890 --> 00:10:28.820
load resources from its own origin.

00:10:28.820 --> 00:10:33.490
That's what the, quote, self quote, token
says.

00:10:33.490 --> 00:10:38.500
Now in case of scripts we want to allow the
application to load scripts from its own origin,

00:10:38.500 --> 00:10:45.500
the extension package, as well as the googleapis.com
site.

00:10:45.500 --> 00:10:53.840
And in case of styles, CSP does include a
token called unsafe inline, also with quotes.

00:10:53.840 --> 00:11:00.740
This can -- this can be used to turn off the
requirement for a script not to be inline;

00:11:00.740 --> 00:11:05.880
however, if we use an unsafe inline token
in the script source line we're basically

00:11:05.880 --> 00:11:08.060
defeating the purpose of CSP.

00:11:08.060 --> 00:11:12.040
We are not gaining any advantage.

00:11:12.040 --> 00:11:17.260
Styles are not the same thing in the sense
that they don't directly execute code.

00:11:17.260 --> 00:11:24.310
And in most cases it's the trade-off between
not being able to use inline style and the

00:11:24.310 --> 00:11:28.020
possible exposure to malicious CSS.

00:11:28.020 --> 00:11:33.140
And buggy parsing CSS code in the browser
is really not that problematic.

00:11:33.140 --> 00:11:39.350
The most important thing in this case is we
cannot load script from anywhere else but

00:11:39.350 --> 00:11:40.970
those two sources.

00:11:40.970 --> 00:11:48.100
Now, if I try to load this, my application,
with this new manifest, I'm not going to do

00:11:48.100 --> 00:11:52.940
it in the computer because the text of a JavaScript
console is very hard to make bigger.

00:11:52.940 --> 00:11:59.620
So that's exactly what Chrome prints if I
try to load my existing application with this

00:11:59.620 --> 00:12:01.580
new manifest.

00:12:01.580 --> 00:12:05.250
And it's basically saying what we expected
it to say.

00:12:05.250 --> 00:12:08.830
If content security policy doesn't allow inline
script, then, of course, Chrome is refusing

00:12:08.830 --> 00:12:10.580
to run inline script.

00:12:10.580 --> 00:12:14.370
If content security policy doesn't allow in-line
event handling, which is basically the same

00:12:14.370 --> 00:12:19.710
as in-line script, it's JavaScript code that's
included in-line in HTML.

00:12:19.710 --> 00:12:21.920
And Chrome has complained about one more thing.

00:12:21.920 --> 00:12:26.760
It complaining about the fact that I'm loading
jQuery or HTTP.

00:12:26.760 --> 00:12:31.450
Now, in a regular Web site this wouldn't necessarily
be a problem since you're already loading

00:12:31.450 --> 00:12:33.510
the Web site over HTTP.

00:12:33.510 --> 00:12:36.890
The fact that you're loading script over HTTP,
it's really not that problematic.

00:12:36.890 --> 00:12:42.690
However, if you're running on extensions,
extensions get more privileged access to the

00:12:42.690 --> 00:12:44.200
browser compared to regular sites.

00:12:44.200 --> 00:12:45.200
They have access to APIs.

00:12:45.200 --> 00:12:48.000
The normal sites don't have access to.

00:12:48.000 --> 00:12:52.820
If you're leading script over HTTP, you're
exposed to what we call mine-in-the-middle

00:12:52.820 --> 00:12:54.670
attacks.

00:12:54.670 --> 00:13:01.030
If you're using your extension at a Starbucks
hot spot, then any person sitting at that

00:13:01.030 --> 00:13:07.040
Starbucks hot spot can intercept the loading
of that -- that script loading over HTTP,

00:13:07.040 --> 00:13:11.480
change it and make you run malicious script
in the origin of your extension, which has

00:13:11.480 --> 00:13:13.700
privileged access to the browser's API.

00:13:13.700 --> 00:13:19.650
And as we've seen, from there to stealing
private data is just some code away.

00:13:19.650 --> 00:13:26.050
Now, we need to change, of course, these few
things in order to make my teeny-tiny application

00:13:26.050 --> 00:13:30.170
work with CSP.

00:13:30.170 --> 00:13:31.680
That's basically what we're going to do.

00:13:31.680 --> 00:13:40.440
I change the jQuery loading to load over HTTP,
which is a source that I have enabled in CSP.

00:13:40.440 --> 00:13:48.790
And I'm going to -- I'm going to extract all
my JavaScript code into a .js file, which

00:13:48.790 --> 00:13:51.470
is something I should have done in the beginning.

00:13:51.470 --> 00:13:56.730
Best practices for Web development call for
separation of the structure of the document

00:13:56.730 --> 00:14:00.810
in HTTP, the behavior in JavaScript and the
style in CSS.

00:14:00.810 --> 00:14:02.710
This is the easy part.

00:14:02.710 --> 00:14:09.640
I also have to get rid of inline event handling,
which I can very easily translate to native

00:14:09.640 --> 00:14:13.570
JavaScript using a bit of jQuery magic.

00:14:13.570 --> 00:14:20.890
I'm saying that the lint function is going
to be the handler of the link that I use to

00:14:20.890 --> 00:14:23.480
tell my application to process the manifest.

00:14:23.480 --> 00:14:29.490
And finally, I have to change my eval function
into JSON parse.

00:14:29.490 --> 00:14:35.160
Now, I didn't use the fact that the application
was using eval to run my exploit.

00:14:35.160 --> 00:14:40.030
I just used the fact that it was running HTML;
however, since the application was using eval

00:14:40.030 --> 00:14:45.430
to parse JSON, instead of doing crazy things
with tasks, I could just send a JavaScript

00:14:45.430 --> 00:14:47.990
statement as a manifest.

00:14:47.990 --> 00:14:57.470
Now, that would have been slightly cheating
in my opinion because there needs to be at

00:14:57.470 --> 00:15:02.180
least an impression of, well, this could have
seemed like a regular manifest in order for

00:15:02.180 --> 00:15:04.960
the exploit chain to be somewhat credible.

00:15:04.960 --> 00:15:10.430
If I'm just telling the user to paste something
that starts with alert as a manifest, then

00:15:10.430 --> 00:15:11.950
I'm kind of cheating.

00:15:11.950 --> 00:15:18.310
The good thing is that I'm not going to get
rid of inner HTML.

00:15:18.310 --> 00:15:19.370
And now we'll see why.

00:15:19.370 --> 00:15:26.700
I don't really need to get rid of inner HTML,
although it would be very good to do.

00:15:26.700 --> 00:15:30.760
What happens if I try to do the same thing?

00:15:30.760 --> 00:15:36.910
Just so you see that I'm not faking it, I'm
going to go back to the demo and I'm going

00:15:36.910 --> 00:15:44.300
to try to load the same -- it happens.

00:15:44.300 --> 00:15:53.850
We broke everything.

00:15:53.850 --> 00:15:58.300
I'm going to use exactly the same manifest
in the safe version of the application that

00:15:58.300 --> 00:16:01.930
loads with the content security policy that
you guys have seen.

00:16:01.930 --> 00:16:08.490
If I try to do that, it will load, but if
I mouse over the little square, which have

00:16:08.490 --> 00:16:11.500
the onload attribute, nothing happens.

00:16:11.500 --> 00:16:17.730
And the console, which clearly you guys cannot
read that, but it says "Refuse to execute

00:16:17.730 --> 00:16:20.490
event handler because of content security
policy."

00:16:20.490 --> 00:16:23.550
So I'm protected, which is really cool.

00:16:23.550 --> 00:16:32.970
It's the same thing that is on the slide,
my demo failure slide.

00:16:32.970 --> 00:16:41.610
And the interesting thing is that the way
I see it, CSP allows the application or extension

00:16:41.610 --> 00:16:48.200
developer to rely on the browser as a safety
net.

00:16:48.200 --> 00:16:54.720
I'm pretty sure that I covered every single
base, I'm pretty sure that I tied every loose

00:16:54.720 --> 00:17:01.290
end, but just in case I haven't, please, you
browser, make sure that I don't screw up.

00:17:01.290 --> 00:17:05.949
This is what I'm talking about when I say
that application developers and browser developers

00:17:05.949 --> 00:17:09.030
have to work together in order to protect
users.

00:17:09.030 --> 00:17:14.510
The browser can make sure that your application
never uses unsafe script.

00:17:14.510 --> 00:17:19.260
You guys have to use the feature that the
browser provides in order to allow the browser

00:17:19.260 --> 00:17:22.439
to do this.

00:17:22.439 --> 00:17:27.000
Now, people might say, "Well, that's a really,
really simple app.

00:17:27.000 --> 00:17:28.880
It doesn't really do anything useful."

00:17:28.880 --> 00:17:31.590
And you might very well be right.

00:17:31.590 --> 00:17:37.280
So I want to move over to something that's
very dear to my heart, which is the Chrome

00:17:37.280 --> 00:17:39.560
OS document viewer.

00:17:39.560 --> 00:17:44.140
We applied these two security features to
the Chrome OS document viewer.

00:17:44.140 --> 00:17:50.860
The Chrome OS document viewer allows Chrome
OS users to open a lot of different document

00:17:50.860 --> 00:17:55.970
types, including Office files, online on their
Chrome OS devices directly from the Chrome

00:17:55.970 --> 00:17:57.840
OS file manager.

00:17:57.840 --> 00:18:03.730
Everything runs on the Web/Chrome platform
and it runs offline.

00:18:03.730 --> 00:18:08.920
Now, when the developers of the development
viewer were working on the application, we

00:18:08.920 --> 00:18:13.570
wanted to make sure that it was a safe application.

00:18:13.570 --> 00:18:17.810
Opening Office documents, it's dangerous,
and we wanted to make sure that we could do

00:18:17.810 --> 00:18:19.260
it in a safe way.

00:18:19.260 --> 00:18:25.150
So the first thing the developers did was
apply a content security policy to this app

00:18:25.150 --> 00:18:27.400
or extension.

00:18:27.400 --> 00:18:28.550
In this case it's an app.

00:18:28.550 --> 00:18:34.440
It doesn't really change that much from what
I did with my demo app, but it's interesting

00:18:34.440 --> 00:18:39.270
that they are also using unsafe inline for
styles, and this makes a lot of sense because

00:18:39.270 --> 00:18:45.180
if you're writing a document viewer you cannot
really predict what kinds of crazy document

00:18:45.180 --> 00:18:49.390
formatting the author of those documents might
do.

00:18:49.390 --> 00:18:54.100
So you need to create script -- sorry, styles
on the fly dynamically and load them inline.

00:18:54.100 --> 00:18:59.290
Now, in this case, again, this is a matter
of it's a trade-off between the functionality

00:18:59.290 --> 00:19:04.750
of the application, basic functionality of
the application, which is displaying the styles

00:19:04.750 --> 00:19:09.220
that are included in the document I want to
view, and security, which is I'm not really

00:19:09.220 --> 00:19:16.830
happy with loading inline CSS because it might
open me to be -- to injection for malicious

00:19:16.830 --> 00:19:20.970
CSS, but we trust the CSS parser in Chrome.

00:19:20.970 --> 00:19:26.420
If killing inline styles kills the purpose
of a document viewer, then we need to allow

00:19:26.420 --> 00:19:27.420
it.

00:19:27.420 --> 00:19:34.390
Security is always, most of the times, about
tradeoffs.

00:19:34.390 --> 00:19:41.250
Another interesting thing is that I'm using
a couple more resource sources that I haven't

00:19:41.250 --> 00:19:46.300
shown before, which are image source, which
of course governs which images can be loaded

00:19:46.300 --> 00:19:48.090
by the application.

00:19:48.090 --> 00:19:49.860
And I'm using blob URIs for images.

00:19:49.860 --> 00:19:51.360
I going to come back to blob URIs.

00:19:51.360 --> 00:19:53.549
I wanted to show it today so it stays in your
mind.

00:19:53.549 --> 00:19:55.900
I'm going to come back to blob URIs.

00:19:55.900 --> 00:19:57.280
I'm also using frame source.

00:19:57.280 --> 00:20:01.310
Now content security policy includes more
types of sources.

00:20:01.310 --> 00:20:02.400
There's a bunch of them.

00:20:02.400 --> 00:20:06.770
I'm not going to go over them, but if you
type content security policy in Google it

00:20:06.770 --> 00:20:12.360
takes you directly to the list of it.

00:20:12.360 --> 00:20:15.340
Now we come probably the crucial part of the
talk.

00:20:15.340 --> 00:20:21.670
Which is -- CSP is awesome, and it really
prevents cross-site scripting, but we haven't

00:20:21.670 --> 00:20:25.620
seen that much adoption by the development
community.

00:20:25.620 --> 00:20:34.750
So the only way we saw to make this really
happen was to force, to make a default CSP

00:20:34.750 --> 00:20:40.820
policy apply by default when absent extensions
start using Manifest V2.

00:20:40.820 --> 00:20:47.210
Now, if people here attended the talk on Wednesday
about Manifest V2, they probably have an idea

00:20:47.210 --> 00:20:50.300
of what the schedule will look like for Manifest
V2.

00:20:50.300 --> 00:20:55.850
I'm going to go over the schedule again, but
let's see exactly what exactly is forced by

00:20:55.850 --> 00:20:59.100
Manifest V2 in terms of CSP.

00:20:59.100 --> 00:21:04.280
The first line, script source self, object
source self, it's going to be the default,

00:21:04.280 --> 00:21:06.920
unchangeable, "unloosenable".

00:21:06.920 --> 00:21:12.730
CSP policy that's going to be used in all
(indiscernible) extensions that use Manifest

00:21:12.730 --> 00:21:14.440
V2.

00:21:14.440 --> 00:21:18.030
The reason for this is the same that I've
been talking about.

00:21:18.030 --> 00:21:24.530
If -- if your upper extension loads inline
script, the browser cannot really tell whether

00:21:24.530 --> 00:21:28.530
the script that is executing comes from a
trusted source or not.

00:21:28.530 --> 00:21:30.690
The same thing happens with plug-ins.

00:21:30.690 --> 00:21:38.210
If we cannot -- if you are loading a plug-in
over HTTP, and you run on public Wi-Fi, then

00:21:38.210 --> 00:21:42.600
the plug-in that you are getting in your extension
does not necessarily look like the plug-in

00:21:42.600 --> 00:21:43.870
that you thought you were getting.

00:21:43.870 --> 00:21:48.810
It might have been changed in transit and
you can have no way of telling.

00:21:48.810 --> 00:21:53.670
Both scripts and plug-ins run code in the
context of your extension.

00:21:53.670 --> 00:21:58.090
If we cannot be sure that that code is trusted,
we cannot give that code the privileges that

00:21:58.090 --> 00:21:59.090
the extension has.

00:21:59.090 --> 00:22:02.240
So that's going to be the default.

00:22:02.240 --> 00:22:09.740
However, in both cases, since we trust the
resources that we load over HTTPS, it's allowed

00:22:09.740 --> 00:22:13.870
to include HTTPS sources both as script source
and as plug-in source.

00:22:13.870 --> 00:22:19.670
You can load plug-ins and scripts over HTTPS
because it's very much guaranteed that the

00:22:19.670 --> 00:22:24.770
scripts you're going to get is the script
that you actually want to get.

00:22:24.770 --> 00:22:29.870
One more thing that you can do with CSP, which
is interesting, is that when you write Chrome

00:22:29.870 --> 00:22:35.471
apps and extensions, you use host permissions
in order to govern which Web sites you can

00:22:35.471 --> 00:22:41.210
inject content script into, but those same
permissions govern which hosts you can do

00:22:41.210 --> 00:22:43.820
XHR requests to.

00:22:43.820 --> 00:22:48.820
If you need to do XHR requests to a smaller
number of hosts than what you need to inject

00:22:48.820 --> 00:22:55.021
the script into, you can further restrict
the hosts that you allow XHR requests to happen

00:22:55.021 --> 00:22:57.940
against by using the connect source directly.

00:22:57.940 --> 00:23:05.110
It might seem like not a very big deal, but
security is always about restricting privilege,

00:23:05.110 --> 00:23:09.280
allowing things to have the least amount of
privilege possible so that if something goes

00:23:09.280 --> 00:23:16.120
wrong, a compromise happens, the thing that
gets compromised will never be able to do

00:23:16.120 --> 00:23:19.020
more than it was allowed to do in the beginning.

00:23:19.020 --> 00:23:21.720
That's basically what we're trying to do with
CSP.

00:23:21.720 --> 00:23:26.290
Now, this is basically how it's going to happen
with Manifest V2.

00:23:26.290 --> 00:23:34.059
Chrome 21, which goes to stable in mid August,
it's going to block uploading new items to

00:23:34.059 --> 00:23:36.900
the Chrome Web store that have Manifest V1.

00:23:36.900 --> 00:23:46.230
With Chrome 23 that goes stable in early November,
even existing items that use Manifest Version

00:23:46.230 --> 00:23:50.020
1 will not be able to be updated to new version.

00:23:50.020 --> 00:23:56.300
And Chrome will stop packaging apps and extensions
that have Manifest V1.

00:23:56.300 --> 00:24:03.830
Now in the beginning of 2013, we will remove
Manifest Version 1 items from search results,

00:24:03.830 --> 00:24:07.770
so that they are very, very hard to find.

00:24:07.770 --> 00:24:14.920
In the middle, beginning of Q2 of 2013, we
will completely remove all Manifest V1 items

00:24:14.920 --> 00:24:21.960
from the Chrome Web store and eventually Chrome
will refuse to load them at all, whatsoever.

00:24:21.960 --> 00:24:28.500
Now, it's almost a year from now, right, until
it doesn't really work anymore and the changes

00:24:28.500 --> 00:24:33.100
are not really that big.

00:24:33.100 --> 00:24:37.179
But the important thing is that this is the
only way that we can guarantee that your users

00:24:37.179 --> 00:24:40.560
and the users of Chrome browser and the Chrome
extension and the Chrome platform don't get

00:24:40.560 --> 00:24:42.950
compromised.

00:24:42.950 --> 00:24:49.059
It's not necessarily because the application
developer is writing a malicious app, but

00:24:49.059 --> 00:24:54.840
it's for the attacker to have a way in, you
just have to make one mistake.

00:24:54.840 --> 00:25:01.200
For -- for the browser/app to win, you have
to -- you have to tie every single loose end,

00:25:01.200 --> 00:25:02.710
so it's an uphill battle.

00:25:02.710 --> 00:25:08.670
But we have some tools that help us win the
battle and we really need you guys to start

00:25:08.670 --> 00:25:10.270
using these tools.

00:25:10.270 --> 00:25:18.520
Now, the other good thing about CSP is that
it's also available or in fact it came up

00:25:18.520 --> 00:25:21.230
as a solution for the regular drive-by Web.

00:25:21.230 --> 00:25:25.960
It's currently supported in Firefox and Chrome
using the X content security policy in the

00:25:25.960 --> 00:25:30.920
case of Firefox and the X WebKit CSP in Chrome.

00:25:30.920 --> 00:25:42.480
Eventually, we hope this will be supported
in all browsers.

00:25:42.480 --> 00:25:49.750
Now, there's some more issues that can come
up with CSP.

00:25:49.750 --> 00:25:52.220
And I wanted to take a couple of minutes to
discuss them.

00:25:52.220 --> 00:25:59.890
An issue that we have seen a lot with CSP
is how we talked about how it completely balanced

00:25:59.890 --> 00:26:05.620
the use of eval because there's no way of
telling where that string that's being turned

00:26:05.620 --> 00:26:06.680
into code comes from.

00:26:06.680 --> 00:26:08.720
It's the same problem as within inline script.

00:26:08.720 --> 00:26:12.410
The browser cannot be sure whether that script
is actually something the application developer

00:26:12.410 --> 00:26:18.190
wrote and not something that a malicious user
wrote.

00:26:18.190 --> 00:26:25.230
The problem is that many Web frameworks use
eval to do templating, for example, and if

00:26:25.230 --> 00:26:27.110
we ban eval, then these things are not going
to work.

00:26:27.110 --> 00:26:34.020
And in effect, there's a very cool starter
kit for ember.js that basically brings up

00:26:34.020 --> 00:26:43.130
single-header (indiscernible) page using the
templating engine for ember.js which is handlebars.

00:26:43.130 --> 00:26:47.320
Now if we use operate, very, very recently
content security policy similar to the one

00:26:47.320 --> 00:26:56.070
that we used before, we are allowing loading
scripts over HTTPS, we are allowing inline

00:26:56.070 --> 00:26:57.730
styles.

00:26:57.730 --> 00:27:05.930
This is basically what the ember.js -- what
the ember.js index -- index HTML page looks

00:27:05.930 --> 00:27:06.930
like.

00:27:06.930 --> 00:27:11.720
It's true we are allowing the loading of that
script, everything else is loading from the

00:27:11.720 --> 00:27:13.670
extensions on package.

00:27:13.670 --> 00:27:18.600
But if we try to load it, we get a very, very,
very nasty error which basically says something

00:27:18.600 --> 00:27:24.320
like code generation from scripts is disallowed
in this context.

00:27:24.320 --> 00:27:29.990
It also points us to a source file and a line,
which basically says something like function

00:27:29.990 --> 00:27:33.309
applies, something, something.

00:27:33.309 --> 00:27:38.900
This is never going to work with a CSP policy
that actually does work as intended.

00:27:38.900 --> 00:27:41.800
Now, there are two ways around this.

00:27:41.800 --> 00:27:49.370
Way number one is for this frameworks to move
away from eval and other code generation functions.

00:27:49.370 --> 00:27:57.370
Now, if you are actually writing the new package
apps and using Manifest Version 2 as we introduced

00:27:57.370 --> 00:28:05.770
during I/O, there's another way of doing this,
which is using new attribute for manifest,

00:28:05.770 --> 00:28:07.380
which is called sandbox.

00:28:07.380 --> 00:28:14.260
Which I'm not going to go into specifically
in the version that's used in the manifest.

00:28:14.260 --> 00:28:22.500
I'm going to cover it more generally, so that
it can be used also in the drive-by Web.

00:28:22.500 --> 00:28:29.780
Before moving on to the next, to HTML5 sandbox
iFrames, a very big CSP don't, unsafe in-line

00:28:29.780 --> 00:28:34.470
and unsafe eval or script source, completely
defeat the purpose of CSP.

00:28:34.470 --> 00:28:35.470
Please don't do it.

00:28:35.470 --> 00:28:41.890
If you need to do this, you probably are doing
something not wrong, but you are doing something

00:28:41.890 --> 00:28:42.890
insecurely.

00:28:42.890 --> 00:28:44.890
So please think again.

00:28:44.890 --> 00:28:50.030
If you need to include this in your CSP policy,
then please, please, think about why you need

00:28:50.030 --> 00:28:51.230
to do it.

00:28:51.230 --> 00:28:56.550
Now, the good thing about CSP is that it provides
a very effectively live place for resources,

00:28:56.550 --> 00:28:59.100
but it's not very granular.

00:28:59.100 --> 00:29:02.440
It's either you are allowed to load this or
you're not.

00:29:02.440 --> 00:29:08.840
What we would like to have is a way of maybe
running script in our application, but not

00:29:08.840 --> 00:29:13.050
giving that script access to the extensions
or the applications origin.

00:29:13.050 --> 00:29:15.110
It seems like there's nothing in between.

00:29:15.110 --> 00:29:19.040
It's either not running at all or running
and giving complete access to user's data

00:29:19.040 --> 00:29:21.040
and everything.

00:29:21.040 --> 00:29:23.510
That's where HTML5 sandbox iFrames come from.

00:29:23.510 --> 00:29:28.740
What we would like to do is to load that script,
execute it, but execute it in a different

00:29:28.740 --> 00:29:32.400
origin than the actual application or extension
origins.

00:29:32.400 --> 00:29:34.160
In fact, let's go even further.

00:29:34.160 --> 00:29:38.720
We want to run it in an origin that's different
from any other origin out there.

00:29:38.720 --> 00:29:40.170
We call those unique origins.

00:29:40.170 --> 00:29:45.360
They are by definition different from any
other origin there is.

00:29:45.360 --> 00:29:49.980
This is where the HTML5 iFrame sandbox attribute
comes in.

00:29:49.980 --> 00:29:57.220
It allows loading resources, content or script
safely inside an iFrame that will get less

00:29:57.220 --> 00:30:00.440
privilege than a regular iFrame.

00:30:00.440 --> 00:30:04.750
And we can completely control which of these
privileges we give back and which ones we

00:30:04.750 --> 00:30:06.860
keep away from the iFrame.

00:30:06.860 --> 00:30:14.380
Now, it's as simple as using the sandbox attribute
on a regular iFrame.

00:30:14.380 --> 00:30:19.820
If we do that, the code that we load inside
the iFrame will be restricted in this way.

00:30:19.820 --> 00:30:24.860
It will live in a unique origin, so we won't
be able to access directly the application

00:30:24.860 --> 00:30:29.690
of the extensions, DOM structure or script
or anything.

00:30:29.690 --> 00:30:33.660
It actually -- if we don't do anything else,
it won't even be allowed to run scripts at

00:30:33.660 --> 00:30:34.680
all.

00:30:34.680 --> 00:30:36.870
Or submit forms.

00:30:36.870 --> 00:30:39.320
Or navigate the top page.

00:30:39.320 --> 00:30:40.790
Or load plug-ins.

00:30:40.790 --> 00:30:42.320
Or create pop-ups.

00:30:42.320 --> 00:30:48.371
Now, almost all of those things can be re-enabled
individually by giving arguments to the sandbox

00:30:48.371 --> 00:30:49.980
attribute.

00:30:49.980 --> 00:30:52.559
Except the loading of plug-ins, which so far
cannot be re-enabled.

00:30:52.559 --> 00:31:05.830
Now, I said that we might want to use sandbox
iFrames to run script in a different origin.

00:31:05.830 --> 00:31:13.090
So going back to the Chrome OS document viewer,
what the document viewer developers did was

00:31:13.090 --> 00:31:20.500
run most of the JavaScript that displayed
the final document inside a sandbox iFrame.

00:31:20.500 --> 00:31:22.040
And why did they do this?

00:31:22.040 --> 00:31:29.840
Well, even though we might be pretty confident
about the JavaScript that we wrote, if there's

00:31:29.840 --> 00:31:34.559
no need for that JavaScript to directly access
all of the private information that an application

00:31:34.559 --> 00:31:39.140
such as a document viewer might have, why
give it that privilege?

00:31:39.140 --> 00:31:40.410
If it doesn't need it?

00:31:40.410 --> 00:31:45.030
If anything goes wrong with the JavaScript
that I wrote, which if I'm parsing a document,

00:31:45.030 --> 00:31:49.850
as heavy as like a spreadsheet or something
like that, a lot of things can probably go

00:31:49.850 --> 00:31:50.850
wrong.

00:31:50.850 --> 00:31:56.280
So since that code doesn't need to access
every single file that I'm using in my document

00:31:56.280 --> 00:31:59.030
viewer, let's just not give it access to that.

00:31:59.030 --> 00:32:03.890
Let's just give it the one file that it needs
to display, so if anything goes wrong, it

00:32:03.890 --> 00:32:09.800
cannot go and steal every single file that
I own and ship it away to somewhere.

00:32:09.800 --> 00:32:13.270
So that's what the document viewer developers
did.

00:32:13.270 --> 00:32:18.130
They kept most of the document viewer inside
of a sandbox iFrame, which was only allowed

00:32:18.130 --> 00:32:25.820
to run script, and load pop-ups, but nothing
else, no forms, no plug-ins, nothing.

00:32:25.820 --> 00:32:31.580
In this way, if anything goes wrong with that
code, the JavaScript will not be able to access

00:32:31.580 --> 00:32:35.670
the extension or the apps origin where probably
the rest of the document, the user's documents

00:32:35.670 --> 00:32:37.070
live.

00:32:37.070 --> 00:32:39.030
And this is a very good thing.

00:32:39.030 --> 00:32:45.840
Now, inside the sandboxed iFrame, there's
really not that much that changes.

00:32:45.840 --> 00:32:50.750
This code is basically loading a lot of JavaScript
to do its job, to parse the document, and

00:32:50.750 --> 00:32:51.750
display the document.

00:32:51.750 --> 00:32:56.510
But it looks like every other single web app
that might be out there, except for one teeny

00:32:56.510 --> 00:33:03.510
tiny detail, which comes from the fact that
that JavaScript code lives inside a unique

00:33:03.510 --> 00:33:04.680
origin.

00:33:04.680 --> 00:33:08.710
There's no way for the JavaScript code outside
of the Sandbox and the JavaScript code inside

00:33:08.710 --> 00:33:10.160
the sandbox to talk directly.

00:33:10.160 --> 00:33:14.480
They need to use some sort of inter-origin
API.

00:33:14.480 --> 00:33:20.419
And the most recent inter-origin API that
they can use, of course, is postMessage.

00:33:20.419 --> 00:33:35.340
It's explicitly designed to -- 
in a very JavaScript-y way, with asynchronous

00:33:35.340 --> 00:33:37.250
message handling.

00:33:37.250 --> 00:33:44.110
Now, this is what -- this is what -- what
message handling function might look for postMessage

00:33:44.110 --> 00:33:45.860
in the drive-by Web.

00:33:45.860 --> 00:33:52.450
The thing is that it is for security reasons,
it is good to check if the message that I

00:33:52.450 --> 00:33:59.000
got over postMessage is being sent to me and
that's what the event origin tells me.

00:33:59.000 --> 00:34:05.330
When you post a message using postMessage,
you say I'm intending this origin to be the

00:34:05.330 --> 00:34:06.590
recipient.

00:34:06.590 --> 00:34:09.460
When you get the message you say, hey, was
I the recipient?

00:34:09.460 --> 00:34:15.629
Is event.origin the source that I expected?

00:34:15.629 --> 00:34:23.419
Since they live in unique origins, their origin
is known, so we cannot really use that to

00:34:23.419 --> 00:34:29.569
make sure that both sides of the postMessage
interaction are who they are.

00:34:29.569 --> 00:34:35.069
But still is the only way we have to talk
to a sandboxed iFrame, so we are going to

00:34:35.069 --> 00:34:38.479
have to use it anyways.

00:34:38.479 --> 00:34:43.970
Inside the iFrame, we just need to get our
parent window and postMessage to that.

00:34:43.970 --> 00:34:48.339
Outside the iFrame, we just need to actually
find the iFrame, get its content window and

00:34:48.339 --> 00:34:51.980
postMessage to that.

00:34:51.980 --> 00:35:00.559
Now, again, the objective of sandboxed iFrames
is to be able to use script that we might

00:35:00.559 --> 00:35:05.910
not be comfortable with accessing our origin
but we might need to use it to set up a particular

00:35:05.910 --> 00:35:07.130
aspect of our application.

00:35:07.130 --> 00:35:12.269
In the case of the document viewer, the script
was displaying the final document to a user,

00:35:12.269 --> 00:35:17.920
but it had no need to access every single
other document.

00:35:17.920 --> 00:35:23.960
By running it in a unique origin, we guaranteed
that even if anything that -- anything that

00:35:23.960 --> 00:35:28.420
went wrong, even if something that we didn't
think could go wrong actually did go wrong,

00:35:28.420 --> 00:35:33.470
there was no way for that code, even if it
was compromised, to access any other document.

00:35:33.470 --> 00:35:34.470
Which is a very good thing.

00:35:34.470 --> 00:35:40.119
You don't want one malformed document that
you want it to see to steal every other single

00:35:40.119 --> 00:35:45.049
document that you have.

00:35:45.049 --> 00:35:50.309
A very -- other very important thing, more
don'ts.

00:35:50.309 --> 00:35:53.369
Security is filled with don'ts.

00:35:53.369 --> 00:36:00.240
If we can both restrict the limitation of
not running script and the limitation of running

00:36:00.240 --> 00:36:05.099
in a unique origin, we can do it, we can do
them both at the same time.

00:36:05.099 --> 00:36:11.849
However, if we do them both at the same time,
since the iFrame will be living in the same

00:36:11.849 --> 00:36:17.789
origin as the enclosing page and JavaScript
will be allowed to run inside the iFrame,

00:36:17.789 --> 00:36:22.270
there's nothing preventing that JavaScript
running inside the iFrame.

00:36:22.270 --> 00:36:26.650
To get a reference to the actual iFrame, since
it's living in the same origin, and just take

00:36:26.650 --> 00:36:29.089
the Sandbox out of it, out.

00:36:29.089 --> 00:36:36.769
So either never use those two together, because
again as with unsafe inline and unsafe eval,

00:36:36.769 --> 00:36:42.749
you are completing defeating the purpose of
the sandbox in the first place or make sure

00:36:42.749 --> 00:36:49.349
that the script that you are including doesn't
have code that can do this.

00:36:49.349 --> 00:36:55.280
You might not -- it's -- you might not be
sure that your script will not fail with a

00:36:55.280 --> 00:36:59.890
malformed office document, but you can be
sure that it's not actually searching for

00:36:59.890 --> 00:37:01.730
iFrames and removing sandbox attributes.

00:37:01.730 --> 00:37:03.869
So sandbox iFrame don't.

00:37:03.869 --> 00:37:07.660
Please don't do this because it defeats the
purpose and as many people say, a false sense

00:37:07.660 --> 00:37:10.450
of security is even worse than being insecure.

00:37:10.450 --> 00:37:11.910
So please don't do this.

00:37:11.910 --> 00:37:16.819
Now, I mentioned at the beginning of the talk
that I wanted to cover some common issues

00:37:16.819 --> 00:37:21.579
and pitfalls that came up when people tried
to do this in actual applications and I'm

00:37:21.579 --> 00:37:24.890
going to go over those real quick.

00:37:24.890 --> 00:37:33.809
We talked about most the CSP restrictions,
the really only really -- the only actual

00:37:33.809 --> 00:37:37.950
pain point that we found was the use of eval
for templating (indiscernible) -- everything

00:37:37.950 --> 00:37:44.680
else, even if it takes some work, is just
a matter of constructing script and constructing

00:37:44.680 --> 00:37:46.720
event handling from HTML files.

00:37:46.720 --> 00:37:50.700
It shouldn't be impossible.

00:37:50.700 --> 00:37:55.380
We talked about how -- about how once we get
stuff into a different origin so that it doesn't

00:37:55.380 --> 00:37:59.970
have access to the user's data, we need to
talk to it as if it were a different origin

00:37:59.970 --> 00:38:04.579
because it actually is, so we need to use
inter-origin communication mechanisms such

00:38:04.579 --> 00:38:06.289
as postMessage.

00:38:06.289 --> 00:38:13.069
Now, I want to go over some weird interactions
that can happen when you use both CSP and

00:38:13.069 --> 00:38:17.930
sandboxed iFrames at the same time, which
might not be evident when you start using

00:38:17.930 --> 00:38:21.980
them, but it's good to know about them so
that you can know what to do when they actually

00:38:21.980 --> 00:38:27.460
show up, if you decide to use that, which
you should.

00:38:27.460 --> 00:38:32.950
This is what the final manifest for the Chrome
OS document viewer roughly looks like.

00:38:32.950 --> 00:38:38.390
They managed to implement both sandbox iFrames
and CSP in document viewer app, which makes

00:38:38.390 --> 00:38:39.390
it really secure.

00:38:39.390 --> 00:38:44.690
I'm very happy opening a file in -- sorry
-- in the document viewer because it means

00:38:44.690 --> 00:38:49.150
that the actual document that I'm viewing
has almost no access to anything else on my

00:38:49.150 --> 00:38:54.089
system and that's something that's very cool
from a security standpoint, because if anything

00:38:54.089 --> 00:38:58.819
goes wrong, there's nothing else that can
be accessed.

00:38:58.819 --> 00:38:59.869
Nothing can be stolen.

00:38:59.869 --> 00:39:03.609
Nothing can be affected, which is cool.

00:39:03.609 --> 00:39:08.490
What happens, the key thing to realize is
that once we get the sandbox iFrame inside

00:39:08.490 --> 00:39:15.230
a unique origin, when that iFrame tries to
load resources from the browser's perspective,

00:39:15.230 --> 00:39:21.589
it will look as if those requests came from
outside the extension.

00:39:21.589 --> 00:39:25.849
Because the iFrame is not going to be living
in the extensions origin.

00:39:25.849 --> 00:39:30.710
Now, with manifest V1, you were allowed to
load everything you wanted from any origin.

00:39:30.710 --> 00:39:37.650
In manifest V2, if an origin different from
the extensions or the apps origin tries to

00:39:37.650 --> 00:39:42.829
load a resource from the app, the browser
will forbid that, and that's where Web access

00:39:42.829 --> 00:39:44.650
resources come from.

00:39:44.650 --> 00:39:55.170
If we want to load from the session package,
we need to list it in Web accessible resources.

00:39:55.170 --> 00:40:02.010
And also, this also applies not only to the
main Web accessible resources line, it also

00:40:02.010 --> 00:40:04.170
applies to CSP.

00:40:04.170 --> 00:40:11.309
The things that we're loading inside the sandbox
iFrame, those requests will not look as if

00:40:11.309 --> 00:40:14.109
they came from the extension or the app.

00:40:14.109 --> 00:40:17.540
They will look as if they came from a different
origin.

00:40:17.540 --> 00:40:26.109
So CSP will not allow those requests to go
forward by matching the "self" token in the

00:40:26.109 --> 00:40:27.779
CSP line.

00:40:27.779 --> 00:40:34.821
It will actually need to match that to a different
line that will have Chrome extension URI as

00:40:34.821 --> 00:40:38.799
-- the Chrome extension URI as its URI.

00:40:38.799 --> 00:40:47.950
Now, if you are running the new package apps
that come with the apps V2, that we introduced

00:40:47.950 --> 00:40:52.900
for I/O, there's a slightly simpler way to
do this, which I'm not going to have time

00:40:52.900 --> 00:40:54.049
to explain that talk.

00:40:54.049 --> 00:40:59.980
But there was a talk on Wednesday that explained
it in more depth, and if anybody wants to

00:40:59.980 --> 00:41:05.430
learn about that, please feel free to find
me after the talk.

00:41:05.430 --> 00:41:12.250
But the core point to remember is that once
we manage to get stuff into the sandbox iFrame,

00:41:12.250 --> 00:41:16.609
it's running inside and encouraging, then
it will have -- it will live in origin for

00:41:16.609 --> 00:41:23.940
everything, even for resource loading, and
that might need to have us change some of

00:41:23.940 --> 00:41:28.349
the CSP policies that we are using.

00:41:28.349 --> 00:41:32.700
And again, we're seeing that I'm using -- or
the document viewer developers were URIs for

00:41:32.700 --> 00:41:39.269
images and the reason that that happens is
that not only we kept script in a different

00:41:39.269 --> 00:41:44.869
origin from our main application origin, we
also put it in a unique origin, which is slightly

00:41:44.869 --> 00:41:48.059
different than just a different origin.

00:41:48.059 --> 00:41:51.400
Unique origins cannot access any persistent
local storage.

00:41:51.400 --> 00:41:55.079
No HTML5 APIs, no persistent local storage.

00:41:55.079 --> 00:42:00.049
Now, imagine if you're obligation developer
and you had a great idea for a Chromized document

00:42:00.049 --> 00:42:06.849
viewer, and you want to display documents
that might have images inside them.

00:42:06.849 --> 00:42:12.160
These images are probably encoded inside the
documents in some way which we don't really

00:42:12.160 --> 00:42:21.940
care about, but if you're not doing your processing,
or some of your processing inside the sandbox

00:42:21.940 --> 00:42:26.700
iFrame, you need a way to get that information
inside the iFrame.

00:42:26.700 --> 00:42:31.359
You might be extracting the images outside
the iFrame, or even better, in a different

00:42:31.359 --> 00:42:32.359
iFrame.

00:42:32.359 --> 00:42:40.410
And you need a way to provide that -- to get
that information inside the iFrame.

00:42:40.410 --> 00:42:46.849
Now, the only way you have to actually communicate
with the code inside the iFrame is by using

00:42:46.849 --> 00:42:47.849
post message.

00:42:47.849 --> 00:42:52.339
So you might say, well, I'll have to take
the binary data from the image, turn it into

00:42:52.339 --> 00:42:57.609
Base64, ship it over using post message, decode
it back to binary inside the iFrame.

00:42:57.609 --> 00:42:58.650
That works.

00:42:58.650 --> 00:43:00.569
Not very performant.

00:43:00.569 --> 00:43:08.119
You have two Base64 to binary conversions
that you don't really need, and that's where

00:43:08.119 --> 00:43:11.170
typed arrays come in.

00:43:11.170 --> 00:43:15.509
JavaScript actually can deal perfectly well
with binary data.

00:43:15.509 --> 00:43:22.029
You just create an array buffer, the size
you need in this case, 8 bytes, and then you

00:43:22.029 --> 00:43:29.059
can cover that array buffer with different
what we call views which allow you to manipulate

00:43:29.059 --> 00:43:31.990
that array buffer using different data types.

00:43:31.990 --> 00:43:38.969
In this case we can manipulate it either as
an array of signed bytes or as an array of

00:43:38.969 --> 00:43:46.749
signed 32 bit, but the best way about -- the
best thing array buffers is that they can

00:43:46.749 --> 00:43:54.390
very easily be turned into objects that can
be loaded in the browser.

00:43:54.390 --> 00:43:59.220
If the code outside the iFrame or inside a
different iFrame sends us an array buffer

00:43:59.220 --> 00:44:05.839
over post message, we can easily turn it into
a blob, and then we can create a URL -- a

00:44:05.839 --> 00:44:09.150
URL from that blob that will look something
like that.

00:44:09.150 --> 00:44:11.329
We don't really care what it looks like.

00:44:11.329 --> 00:44:17.009
We really care about the fact that it can
be used as a source for all sorts of tasks.

00:44:17.009 --> 00:44:22.940
This is how the document viewer developers
manage to do the parsing of the documents

00:44:22.940 --> 00:44:30.460
in one sandbox, and displaying in the document
in a different sandbox, passing binary data

00:44:30.460 --> 00:44:36.119
back and forth using a very efficient mechanism
that doesn't need any encoding whatsoever.

00:44:36.119 --> 00:44:42.089
Not only that, once you get the blob URI inside
the sandbox, you can use it all the times

00:44:42.089 --> 00:44:43.170
you want.

00:44:43.170 --> 00:44:50.640
It's a way of getting a URI pointing directly
to a chunk of bytes in the browser's memory.

00:44:50.640 --> 00:44:57.779
This made possible to write a very secure
document viewer app and still keep all the

00:44:57.779 --> 00:45:01.229
functionality that one would expect from a
document viewer.

00:45:01.229 --> 00:45:08.920
Now, I mostly talked about JavaScript today.

00:45:08.920 --> 00:45:13.739
Good news is that the Chrome platform also
includes a way of getting all these same security

00:45:13.739 --> 00:45:16.450
guarantees for native code.

00:45:16.450 --> 00:45:24.960
There were a lot of talks about (NaCl) Native
Client, in I/O, your -- you will probably

00:45:24.960 --> 00:45:29.280
find them, the videos online after I/O ends.

00:45:29.280 --> 00:45:34.480
(NaCl) allows you to get all the same guaranties
that we can give for JavaScript code running

00:45:34.480 --> 00:45:39.029
inside a sandbox iFrame for native code, native
C or C++ code.

00:45:39.029 --> 00:45:44.410
And the best thing is that the communication
with this sandbox code uses the same interface

00:45:44.410 --> 00:45:48.369
that you can use to talk to JavaScript which
is a post message based API.

00:45:48.369 --> 00:45:54.319
So you can get the same guaranties that you
can get with sandbox JavaScript, no access

00:45:54.319 --> 00:45:58.489
to the application's origin, using the same
API.

00:45:58.489 --> 00:46:05.759
Your JavaScript code can both talk to JavaScript
or to native code with the same security guaranties.

00:46:05.759 --> 00:46:10.160
Now, take aways, and we'll move into questions.

00:46:10.160 --> 00:46:13.160
Please, please, please, use CSP.

00:46:13.160 --> 00:46:14.440
Please.

00:46:14.440 --> 00:46:20.069
Let Chrome, the browser, be the safety net.

00:46:20.069 --> 00:46:26.989
Just make some very small changes, move scripts
out of HTML, removing line handling -- inline

00:46:26.989 --> 00:46:28.750
handling and stop worrying.

00:46:28.750 --> 00:46:35.650
As long as you do stuff this way, the browser
will take care of not allowing malicious script

00:46:35.650 --> 00:46:37.089
to go through.

00:46:37.089 --> 00:46:40.930
This removes -- this blocks most cases of
cross-site scripting.

00:46:40.930 --> 00:46:42.519
It does.

00:46:42.519 --> 00:46:47.069
Because a browser can make sure that this
doesn't happen in only one place.

00:46:47.069 --> 00:46:50.839
You have to make sure it doesn't happen in
every single way -- place you use inner HTML

00:46:50.839 --> 00:46:52.849
or e-mail or server or everything.

00:46:52.849 --> 00:46:59.210
Let us let the browser help the app make sure
that this doesn't happen.

00:46:59.210 --> 00:47:04.729
And if you need to run script that you're
not comfortable with, you don't really want

00:47:04.729 --> 00:47:10.530
it to be able to access the application or
the extension's origin, put it in a sandbox

00:47:10.530 --> 00:47:11.530
iFrame.

00:47:11.530 --> 00:47:12.530
That's what they are for.

00:47:12.530 --> 00:47:18.450
It will run very happily, talk over post message,
but if anything goes wrong, it won't have

00:47:18.450 --> 00:47:19.529
any other privilege.

00:47:19.529 --> 00:47:23.869
It won't be able to access anything in the
extension of the app's origin.

00:47:23.869 --> 00:47:26.039
That's a good thing.

00:47:26.039 --> 00:47:30.069
Thank you for joining the session.

00:47:30.069 --> 00:47:36.710
[ Applause ]
&gt;&gt;Jorge Lucangeli Obes: That's my e-mail.

00:47:36.710 --> 00:47:39.549
My public Google+ account.

00:47:39.549 --> 00:47:40.609
The slides are going to be posted.

00:47:40.609 --> 00:47:43.700
I saw some people taking pictures of the slides.

00:47:43.700 --> 00:47:45.160
Don't worry.

00:47:45.160 --> 00:47:49.559
And, yeah, we're open for questions.

00:47:49.559 --> 00:47:50.719
There's mics, yeah.

00:47:50.719 --> 00:47:51.739
There's mics.

00:47:51.739 --> 00:47:53.589
&gt;&gt;&gt; Hey, so good talk.

00:47:53.589 --> 00:47:55.839
My question is a bit of a tangent, though.

00:47:55.839 --> 00:48:00.979
Have you guys seen very many actually malicious
Chrome Apps or extensions?

00:48:00.979 --> 00:48:08.190
&gt;&gt;Jorge Lucangeli Obes: We take out approximately
a dozen malicious extensions either per day

00:48:08.190 --> 00:48:10.630
or per week from the Chrome store, yes.

00:48:10.630 --> 00:48:11.630
&gt;&gt;&gt; Okay.

00:48:11.630 --> 00:48:15.640
What kind of attack patterns do they use in
general, if can you tell us?

00:48:15.640 --> 00:48:17.829
&gt;&gt;Jorge Lucangeli Obes: No.

00:48:17.829 --> 00:48:20.349
It's probably better to contact press, yes.

00:48:20.349 --> 00:48:21.349
&gt;&gt;&gt; Okay.

00:48:21.349 --> 00:48:22.349
Okay.

00:48:22.349 --> 00:48:23.349
Fair enough.

00:48:23.349 --> 00:48:24.349
Thanks.

00:48:24.349 --> 00:48:25.769
&gt;&gt;Jorge Lucangeli Obes: More questions?

00:48:25.769 --> 00:48:27.400
No more questions?

00:48:27.400 --> 00:48:31.329
Don't be shy.

00:48:31.329 --> 00:48:43.299
&gt;&gt;&gt; So what's wrong with attributes that have
JavaScript code in them, if they're just in

00:48:43.299 --> 00:48:50.059
the static source of the page, as opposed
to being injected via inner HTML or the DOM

00:48:50.059 --> 00:48:51.059
API?

00:48:51.059 --> 00:48:53.089
&gt;&gt;Jorge Lucangeli Obes: For the browser?

00:48:53.089 --> 00:48:55.099
From the browser's perspective?

00:48:55.099 --> 00:48:57.000
There's no difference.

00:48:57.000 --> 00:49:05.410
So the browser -- the browser doesn't know
that the -- the on mouse-over script that

00:49:05.410 --> 00:49:08.640
I added in the first demo is actually malicious.

00:49:08.640 --> 00:49:14.780
I want the browser to be able to -- I would
like the browser to be able to block anything

00:49:14.780 --> 00:49:22.729
that got injected by inner HTML as opposed
to stuff that got injected -- that got put

00:49:22.729 --> 00:49:24.829
there statically in the page.

00:49:24.829 --> 00:49:27.859
But there's -- in reality, there's no way
of telling the difference.

00:49:27.859 --> 00:49:30.710
Once the DOM tree gets built, it's the same
thing.

00:49:30.710 --> 00:49:31.710
Right?

00:49:31.710 --> 00:49:37.130
The thing to include using inner HTML becomes
part of the DOM tree just as everything else

00:49:37.130 --> 00:49:40.770
you included statically in the page.

00:49:40.770 --> 00:49:46.390
So the browser cannot really tell the difference
between those two scripts.

00:49:46.390 --> 00:49:50.459
We can -- if -- we can discuss it after.

00:49:50.459 --> 00:49:51.459
&gt;&gt;&gt; Okay.

00:49:51.459 --> 00:49:52.680
Good idea.

00:49:52.680 --> 00:49:55.119
&gt;&gt;&gt; This question is more related to your
talk.

00:49:55.119 --> 00:50:00.890
So you talk about using the X content security
policy header in the talk.

00:50:00.890 --> 00:50:04.480
Recently the IATF deprecated the X prefix
for headers.

00:50:04.480 --> 00:50:09.469
Do you know if Google is like trying to move
toward standardizing what that header is?

00:50:09.469 --> 00:50:11.440
&gt;&gt;Jorge Lucangeli Obes: Eventually -- no.

00:50:11.440 --> 00:50:14.700
Eventually we want to standardize.

00:50:14.700 --> 00:50:22.150
I'm not exactly sure what the timeline is
for that, but there's definitely people you

00:50:22.150 --> 00:50:23.509
can ask that if you want to.

00:50:23.509 --> 00:50:25.759
I can tell who you can ask.

00:50:25.759 --> 00:50:26.759
&gt;&gt;&gt; Okay.

00:50:26.759 --> 00:50:27.759
Sure.

00:50:27.759 --> 00:50:28.759
Thanks.

00:50:28.759 --> 00:50:29.890
&gt;&gt;Jorge Lucangeli Obes: Right there.

00:50:29.890 --> 00:50:35.079
&gt;&gt;&gt; I'm curious if you know the status of
CSP support in browsers other than Chrome.

00:50:35.079 --> 00:50:39.889
&gt;&gt;Jorge Lucangeli Obes: I don't.

00:50:39.889 --> 00:50:43.940
&gt;&gt;&gt; Kind of a continuation from that: What's
the status of this in the Android WebView?

00:50:43.940 --> 00:50:50.079
&gt;&gt;Jorge Lucangeli Obes: That's a very good
question that should be asked to Android developers.

00:50:50.079 --> 00:50:51.279
Yeah.

00:50:51.279 --> 00:51:02.459
&gt;&gt;&gt; Hey, sorry, look, I think a big raisin
for not allowing inline JavaScript is because

00:51:02.459 --> 00:51:09.119
you're basically assuming that it's all malicious
and you've got this policy to say if it's

00:51:09.119 --> 00:51:14.349
not -- if any JavaScripts come from anywhere
else apart from where we said, malicious,

00:51:14.349 --> 00:51:15.540
right, even if it isn't.

00:51:15.540 --> 00:51:21.609
Is there much effort going into actually determining
whether JavaScript is malicious or not?

00:51:21.609 --> 00:51:27.750
&gt;&gt;Jorge Lucangeli Obes: You probably run very,
very quickly into, like, halting problem stuff,

00:51:27.750 --> 00:51:28.750
right?

00:51:28.750 --> 00:51:30.719
That's basically the case.

00:51:30.719 --> 00:51:35.569
You cannot have a way of telling what source
code does that is 100% accurate so --

00:51:35.569 --> 00:51:36.569
&gt;&gt;&gt; Yeah.

00:51:36.569 --> 00:51:41.279
&gt;&gt;Jorge Lucangeli Obes: The only way to make
sure that -- it goes back to the same thing:

00:51:41.279 --> 00:51:47.700
For an attacker to win, you just need one
bug, and in order for the rest of the people

00:51:47.700 --> 00:51:53.469
to win, you need to tie every single loose
end, and going down a path that basically

00:51:53.469 --> 00:51:58.819
has a lot of false positives and false negatives,
and very hard rules, it's just opening the

00:51:58.819 --> 00:52:04.759
door for not one bug, but a million bugs,
so we want to cut the problem from the root,

00:52:04.759 --> 00:52:12.759
and since it's perfectly okay, there's no
major differences except for evil, let's just

00:52:12.759 --> 00:52:15.489
do what's safe for the user.

00:52:15.489 --> 00:52:16.630
It's -- it's exactly the same.

00:52:16.630 --> 00:52:21.749
It's just -- instead of having in HTML, do
it in JavaScript, instead of having it in

00:52:21.749 --> 00:52:25.930
code, do it in our .js files, and we can guaranty
-- we can guaranty, we can say this is not

00:52:25.930 --> 00:52:28.509
going to is happen, ever, ever, ever.

00:52:28.509 --> 00:52:29.509
No exceptions.

00:52:29.509 --> 00:52:33.709
&gt;&gt;&gt; Well, unless your JavaScript on your server
gets compromised.

00:52:33.709 --> 00:52:38.989
You can still be pulling it in from trusted
sources but it's been compromised anyway.

00:52:38.989 --> 00:52:42.959
&gt;&gt;Jorge Lucangeli Obes: Well, exactly, but,
I mean, since -- it should -- would have to

00:52:42.959 --> 00:52:47.809
be compromised either in the Web site that
is serving over HTTPS or in the actual expansion

00:52:47.809 --> 00:52:53.700
package, which is a couple of orders of magnitude
higher than just sitting at a Starbucks WiFi

00:52:53.700 --> 00:52:55.519
and running something.

00:52:55.519 --> 00:52:59.900
&gt;&gt;&gt; Which sort of gives rise to actually checking
whether the JavaScript itself is malicious.

00:52:59.900 --> 00:53:01.230
&gt;&gt;Jorge Lucangeli Obes: Yes.

00:53:01.230 --> 00:53:03.650
&gt;&gt;&gt; So you kind of need to do it eventually.

00:53:03.650 --> 00:53:05.130
&gt;&gt;Jorge Lucangeli Obes: But again, tradeoff,
right?

00:53:05.130 --> 00:53:06.130
&gt;&gt;&gt; Yeah.

00:53:06.130 --> 00:53:11.329
&gt;&gt;Jorge Lucangeli Obes: We can make sure that
by -- there were some stats -- there was a

00:53:11.329 --> 00:53:16.569
very interesting paper by a group -- a research
group at Berkeley that got published in the

00:53:16.569 --> 00:53:27.519
beginning of 2012, by restricting inline JavaScript,
and restricting HTTPS or HTTP script loading,

00:53:27.519 --> 00:53:35.509
you could completely eliminate 95% of all
the vulnerabilities in the top 100 extensions

00:53:35.509 --> 00:53:37.470
in the Chrome Web store.

00:53:37.470 --> 00:53:43.319
Now, the tradeoff for that is incredibly good.

00:53:43.319 --> 00:53:49.459
It's just a couple of simple changes that
are still best practices for Web app development

00:53:49.459 --> 00:53:51.420
get rid of 95% of the vulnerabilities.

00:53:51.420 --> 00:53:52.420
&gt;&gt;&gt; Yeah.

00:53:52.420 --> 00:53:54.420
&gt;&gt;Jorge Lucangeli Obes: It's like we need
to do this.

00:53:54.420 --> 00:53:56.900
Guys, we need to do this.

00:53:56.900 --> 00:54:01.929
Guys and girls, of course.

00:54:01.929 --> 00:54:02.929
&gt;&gt;&gt; Can we get -- sorry.

00:54:02.929 --> 00:54:04.019
&gt;&gt;Jorge Lucangeli Obes: That's okay.

00:54:04.019 --> 00:54:07.511
&gt;&gt;&gt; Can we get CSP to work in IE using Chrome
Frame, maybe?

00:54:07.511 --> 00:54:11.650
&gt;&gt;Jorge Lucangeli Obes: That's a very good
question to which I don't know the answer

00:54:11.650 --> 00:54:14.640
with, but I'm going find the answer because
it is a very good question.

00:54:14.640 --> 00:54:16.859
&gt;&gt;&gt; I'm following you so post it.

00:54:16.859 --> 00:54:18.910
&gt;&gt;Jorge Lucangeli Obes: Okay.

00:54:18.910 --> 00:54:20.450
I'll post it.

00:54:20.450 --> 00:54:21.450
Good.

00:54:21.450 --> 00:54:22.450
&gt;&gt;&gt; Great, thanks.

00:54:22.450 --> 00:54:28.059
&gt;&gt;&gt; So you mentioned that because of blocks
eval, you know, blocks templating use cases,

00:54:28.059 --> 00:54:31.660
I think I did catch -- so what's the alternative
do you do on something like client side templating?

00:54:31.660 --> 00:54:35.910
&gt;&gt;Jorge Lucangeli Obes: So the alternative
-- two alternatives: Number one, try to make

00:54:35.910 --> 00:54:38.380
templating people more like from evil.

00:54:38.380 --> 00:54:46.549
Alternative number two, if you are writing
and one of the new package apps for the Chrome

00:54:46.549 --> 00:54:51.549
platform, this doesn't work in the drive-by
Web, just for the Chrome platform, you are

00:54:51.549 --> 00:54:57.160
able to say in the manifest using the sandbox
attribute -- in the manifest, not in the iFrame,

00:54:57.160 --> 00:55:04.119
in the manifest, you are able to say this
document, when it's loaded inside an iFrame

00:55:04.119 --> 00:55:11.949
or in a window, it should be put in something
very similar to a sandbox iFrame; however,

00:55:11.949 --> 00:55:20.219
in this new sandbox document, you cannot remove
the same origin restriction.

00:55:20.219 --> 00:55:22.819
You cannot say, hey, this has to live in the
same origin.

00:55:22.819 --> 00:55:24.309
You cannot do that.

00:55:24.309 --> 00:55:30.670
Since we don't allow that in the Chrome platform
version of sandbox iFrames, we can't allow

00:55:30.670 --> 00:55:32.280
evil.

00:55:32.280 --> 00:55:36.410
What we don't want to do is to say you can
run evil and you can also remove the same

00:55:36.410 --> 00:55:37.680
origin restriction.

00:55:37.680 --> 00:55:44.119
So if you do it through the manifest, you
can apply a different kind of security policy

00:55:44.119 --> 00:55:50.349
to that document you loaded inside the sandbox
-- sandbox which can never ever live in the

00:55:50.349 --> 00:55:52.839
same origin as your application.

00:55:52.839 --> 00:55:56.309
If you want to go over the code, we can check
it out outside.

00:55:56.309 --> 00:56:03.069
But if you search for sandbox in the new version
2 documentation, it's right there.

00:56:03.069 --> 00:56:04.069
&gt;&gt;&gt; Okay.

00:56:04.069 --> 00:56:05.069
Thank you.

00:56:05.069 --> 00:56:08.970
&gt;&gt;Jorge Lucangeli Obes: I think we are good
to go.

00:56:08.970 --> 00:56:10.140
Thank you.

00:56:10.140 --> 00:56:10.730
[ Applause ]

