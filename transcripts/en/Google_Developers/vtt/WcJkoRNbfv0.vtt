WEBVTT
Kind: captions
Language: en

00:12:38.644 --> 00:12:45.239
&gt;&gt; Ladies and gentlemen, will 
you please take your seats as 

00:12:45.240 --> 00:12:49.460
the keynote session is about to 
commence.  Thank you.

00:15:42.256 --> 00:15:46.765
&gt;&gt; Good morning, everyone.  I'm 
Jason, and I lead the developer 

00:15:46.766 --> 00:15:48.862
product group at Google.  I'm so
 excited to be here with all of 

00:15:48.863 --> 00:15:57.154
you at Google Developer Days, 
Europe.  This region is an 

00:15:57.155 --> 00:16:01.292
amazing one for technology.  
Startup hubs blossoming across 

00:16:01.293 --> 00:16:07.523
the continent from London to 
Paris to Berlin and Warsaw, the 

00:16:07.524 --> 00:16:09.598
talent here is incredible.
In fact, a few years ago, when I

00:16:09.599 --> 00:16:13.731
 was a CEO at  

00:16:17.832 --> 00:16:21.971
Shazan in London, we would hire 
across the  continent.  Some of 

00:16:21.972 --> 00:16:26.139
the best developers came from 
Germany and Greece and Lithuania

00:16:26.140 --> 00:16:30.269
 and Poland.  And fast forward 
to today, Europe has more 

00:16:30.270 --> 00:16:34.455
developers than the United 
States and Canada combined.

00:16:36.543 --> 00:16:40.690
[ Applause ]
Which is why it's really 

00:16:40.691 --> 00:16:44.865
exciting to have Google 
Developer Days here so that we 

00:16:44.866 --> 00:16:46.936
can meet and work with all of 
you.  We want to give you what 

00:16:46.937 --> 00:16:51.114
you need to turn your ideas into
 reality.  Whether you're 

00:16:51.115 --> 00:16:57.369
building a mobile app or using 
new  technologies like AR and 

00:16:57.370 --> 00:16:59.453
machine learning.  We want to 
enable you to focus on the 

00:16:59.454 --> 00:17:03.588
problems you're trying to solve 
and minimize the pain points of 

00:17:03.589 --> 00:17:07.759
building a product.
And in addition to building 

00:17:07.760 --> 00:17:11.939
products to help you succeed, 
we're also working on building 

00:17:11.940 --> 00:17:16.149
out trainings to deepen your 
technical capabilities year 

00:17:16.150 --> 00:17:20.332
round.  Today I'm happy to share
 that we've opened our mobile 

00:17:20.333 --> 00:17:24.472
web certification that will 
enable you to further expand 

00:17:24.473 --> 00:17:28.651
your web skills.  And on the 
ground, our team is working in 

00:17:28.652 --> 00:17:34.907
over 130 countries.  And within 
Europe, we've reached over 

00:17:34.908 --> 00:17:39.060
185,000 developers just this 
year through local events and 

00:17:39.061 --> 00:17:43.258
programs.  We have, in Europe, 
over 200 developer experts, many

00:17:45.337 --> 00:17:47.438
 of whom are in this room today,
 who are sharing their expertise

00:17:49.544 --> 00:17:53.698
 and are continuing to expand 
the developer ecosystem through 

00:17:53.699 --> 00:17:59.965
programs such as women tech 
makers, the Google Development 

00:17:59.966 --> 00:18:06.224
Agency program, and our Google 
Development Groups.  Last year 

00:18:06.225 --> 00:18:14.579
we started our Launchpad 
accelerator program and brings 

00:18:14.580 --> 00:18:18.740
them to Silicon Valley to meet 
with leads.  In our class, the 

00:18:18.741 --> 00:18:24.977
first startup from Poland.  
These three entrepreneurs saw 

00:18:24.978 --> 00:18:29.145
the need to provide therapy at 
scale for autistic children.

00:18:29.146 --> 00:18:31.225
In respondent, they created Dr.

00:18:35.283 --> 00:18:37.368
 Omnibus, for children with 
special education needs.  

00:18:37.369 --> 00:18:41.530
Allowing children to learn 
behavior patterns and responses 

00:18:41.531 --> 00:18:43.600
to real-life scenarios, and 
their teachers and therapists 

00:18:43.601 --> 00:18:47.770
can review their progress.
The best part is that students 

00:18:47.771 --> 00:18:49.846
can play these games on their 
own, allowing them to get 

00:18:49.847 --> 00:18:56.118
therapy every day rather than 
once a week, which makes an 

00:18:56.119 --> 00:18:58.211
incredible impact long-term.  
This is just one of many stories

00:19:00.298 --> 00:19:02.398
 how the Europe development 
community is making a big 

00:19:02.399 --> 00:19:06.551
impact.
Now, I'd like to bring up some 

00:19:06.552 --> 00:19:08.623
of my colleagues to share 
updates across our developer 

00:19:08.624 --> 00:19:14.857
platforms.  And let's start with
 how we're making the Android 

00:19:14.858 --> 00:19:23.182
development process easier.  
Please welcome D  

00:19:25.253 --> 00:19:29.405
DAN: Right.  Thank you, Jason.  
It is the best time ever to be 

00:19:29.406 --> 00:19:33.578
an Android developer.  Now, I 
have been developing for Android

00:19:33.579 --> 00:19:37.721
 for almost nine years and spent
 seven of those years at Google.

00:19:37.722 --> 00:19:41.929
  But I have never seen anything
 like what we have now.  An 

00:19:41.930 --> 00:19:46.112
incredible confluence of 
meaningful developer  changes.  

00:19:46.113 --> 00:19:50.286
We're seeing ever more powerful 
tooling.  A clear path forward 

00:19:50.287 --> 00:19:52.370
for app design.  A new 
programming language and 

00:19:52.371 --> 00:19:56.516
fundamental improvements to the 
distribution model.  And many of

00:19:56.517 --> 00:20:00.662
 this change derives from 
listening to all of you in the 

00:20:00.663 --> 00:20:02.744
developer community.
And all of this is happening 

00:20:02.745 --> 00:20:06.938
amidst the incredible momentum 
that Android continues to have. 

00:20:06.939 --> 00:20:11.097
 I mean, we're seeing 2 billion 
active devices on Android and 82

00:20:13.188 --> 00:20:17.351
 billion apps installed from 
Play.  And what is even more 

00:20:17.352 --> 00:20:19.421
amazing is how this momentum is 
making so many developers 

00:20:19.422 --> 00:20:23.596
successful.  The number of 
developers are over a million 

00:20:23.597 --> 00:20:27.787
installs grew 35% in the past 
year.  Now, to leverage this 

00:20:27.788 --> 00:20:31.979
distribution to build great 
businesses, we expanded direct 

00:20:31.980 --> 00:20:38.234
carrier building to reach 900 
million devices with over 140 

00:20:38.235 --> 00:20:42.429
million operators.  And the 
number of people buying on Play 

00:20:42.430 --> 00:20:44.506
grew by almost 30% this past 
year.

00:20:46.584 --> 00:20:48.657
That's not enough.  We know we 
can make distribution even 

00:20:48.658 --> 00:20:52.828
better by removing the friction 
from app installs and making the

00:20:54.901 --> 00:20:59.091
 entire experience more dynamic.
  So instant apps is one of the 

00:20:59.092 --> 00:21:05.325
big bets in bringing users to 
your apps and our early adopters

00:21:05.326 --> 00:21:09.511
 are seeing it.  And they saw 
that sharing content increased 

00:21:09.512 --> 00:21:15.748
55% in their instant app.  And  
Vimeo increased session 

00:21:15.749 --> 00:21:19.899
durations by 130%.  Jet found 
that the conversion rate in 

00:21:19.900 --> 00:21:21.972
their shopping app increased by 
27% and there are many many 

00:21:21.973 --> 00:21:28.251
stories like these.
At I/O we opened up Android 

00:21:28.252 --> 00:21:32.400
instant apps to all Android 
developers.  Which means anyone 

00:21:32.401 --> 00:21:36.555
can now build and publish an 
instant app.  Since then we have

00:21:36.556 --> 00:21:40.700
 made instant apps available to 
more than 500 million across 

00:21:40.701 --> 00:21:46.992
countries where Google operates.
  And we organize the product 

00:21:46.993 --> 00:21:51.156
into feature modules and use the
 code in the instant app and 

00:21:51.157 --> 00:21:53.229
your installable  app.  We're 
easying the process of 

00:21:53.230 --> 00:22:01.607
refactoring your app into the 
feature modules by using the new

00:22:01.608 --> 00:22:03.608
 module

00:22:07.701 --> 00:22:09.795
 modulear vise Android studio.  
And we have space saving shares 

00:22:09.796 --> 00:22:13.961
libraries and asset deliver to 
on the wire compression.  When 

00:22:13.962 --> 00:22:20.192
you're ready, upload the instant
 app APK with the installable in

00:22:20.193 --> 00:22:28.470
 the console.  Visit g.co/
instant/apps.  Since you are 

00:22:28.471 --> 00:22:32.620
here, you heard the exciting 
news from I/O.  We're now 

00:22:32.621 --> 00:22:38.903
offering first class support for
 the Kotlin in Android.  And 

00:22:38.904 --> 00:22:43.078
Kotlin support is now built into
 Android Studio.  So --

00:22:43.079 --> 00:22:45.156
[ Applause ]
So, you know, obviously I don't 

00:22:45.157 --> 00:22:49.320
have to tell you this, why 
Kotlin?  And that's because the 

00:22:49.321 --> 00:22:53.477
community really wanted it.  
Kotlin is a mature production-

00:22:55.595 --> 00:22:57.706
ready language that's been 
around for five years.  And so 

00:22:57.707 --> 00:23:01.938
we investigated.  And people 
that were investigating became 

00:23:01.939 --> 00:23:06.112
Kotlin champions.  As developers
, languages are the tools that 

00:23:06.113 --> 00:23:12.410
we use to express our thoughts. 
 And with Kotlin, there's so 

00:23:12.411 --> 00:23:16.630
much less noise between what I 
want to say and how I say it.  

00:23:16.631 --> 00:23:20.803
And since our announcement at 
Google I/O, it's been growing 

00:23:20.804 --> 00:23:24.963
like crazy.  It's great to see 
so many of you adopting it.  But

00:23:24.964 --> 00:23:29.129
 to be here, we have added 
Kotlin as an additional program.

00:23:29.130 --> 00:23:33.320
  We're not replaces the Java 
programming language or C++, and

00:23:33.321 --> 00:23:39.554
 we support as much Kotlin as 
you want.  From 0 to  100%.  It 

00:23:39.555 --> 00:23:43.722
operates 100% with the Java 
language.  That means you can 

00:23:43.723 --> 00:23:45.814
keep every line of code and  
seamlessly call from Kotlin into

00:23:45.815 --> 00:23:52.058
 the Java programming language 
and back and you can start with 

00:23:52.059 --> 00:23:56.236
as little as a single Kotlin 
class.  And partnering,

00:23:56.237 --> 00:24:00.425
 we are here and giving a talk 
on Kotlin today.  Please swing 

00:24:00.426 --> 00:24:02.491
by to learn more if you haven't 
 already.

00:24:02.492 --> 00:24:06.663
Now, minimizing install friction
 with instant apps and support 

00:24:06.664 --> 00:24:08.742
of the common programming 
language are two of the ways we 

00:24:08.743 --> 00:24:12.908
have listened to your  feedback.
  You want faster, easier 

00:24:12.909 --> 00:24:15.002
development with better tools 
and libraries.  So Android 

00:24:15.003 --> 00:24:21.272
Studio, our official IDE, 
purpose-built for Android, and 

00:24:21.273 --> 00:24:25.447
we keep increasing our 
investment.  We focused on speed

00:24:25.448 --> 00:24:29.644
 and smarts and platform support
 and new libraries for 

00:24:29.645 --> 00:24:33.862
architecture.  And this is going
 to migrate to stable release --

00:24:33.863 --> 00:24:35.974
 soon.  And you can see the 
speed and smarts updates we have

00:24:38.048 --> 00:24:40.113
 made to Android Studio behind 
me.  But one thing in particular

00:24:42.197 --> 00:24:46.384
, your  feedback made driving 
down sync and build time our 

00:24:46.385 --> 00:24:50.576
number one priority.  
Benchmarking with a real-life, 

00:24:50.577 --> 00:24:56.793
hundred module since 2.2, build 
time dropped from 3 minutes to 2

00:24:56.794 --> 00:25:00.967
 seconds.  We're continuing to 
build on performance.  And for 

00:25:00.968 --> 00:25:07.236
me, super-exciting, for the 
emulators, we added the Play 

00:25:07.237 --> 00:25:11.409
store for end to end testing.  
And now platform support.  We 

00:25:11.410 --> 00:25:17.688
released the latest dessert name
for Android.  You'll find 

00:25:17.689 --> 00:25:19.765
Android Oreo, system images,

00:25:23.868 --> 00:25:30.087
 improved files.  And a download
 dependencies, you don't have to

00:25:30.088 --> 00:25:36.352
 go to the  SDK manager anymore.
  We are now distributing 

00:25:36.353 --> 00:25:42.614
through our repository.  And 
making them easier.  Providing a

00:25:42.615 --> 00:25:46.770
 guide for best practices and 
life  cycles.  We launched a 

00:25:46.771 --> 00:25:50.954
preview of new architecture 
components.  Libraries and 

00:25:50.955 --> 00:25:57.200
common tasks, a  ViewModel, data
 storage, life cycle management.

00:25:57.201 --> 00:26:01.414
  And soon, announcing support 
for paging, making it  easier to

00:26:01.415 --> 00:26:08.561
 use recycler view.  App quality
 -- yeah.  Very excited about 

00:26:08.562 --> 00:26:10.625
that.
So app quality is an essential 

00:26:10.626 --> 00:26:14.768
piece to growing a business.  
And we took apps and analyzed 

00:26:14.769 --> 00:26:18.917
app quality and business 
success.  When apps move from 

00:26:18.918 --> 00:26:23.074
average to good quality, we see 
a six fold speed increase and 

00:26:23.075 --> 00:26:27.238
spend, and a seven fold increase
 in retention.  Quality is 

00:26:27.239 --> 00:26:31.409
queen.  Now, your app quality 
might differ depending on the 

00:26:31.410 --> 00:26:35.546
type of device it's running on. 
 So to make sure the targeting 

00:26:35.547 --> 00:26:39.692
devices working best for your 
app, you can target specific 

00:26:39.693 --> 00:26:43.922
devices in the Play console.  
Yeah.  It's awesome.  Been 

00:26:43.923 --> 00:26:46.017
waiting for that forever.
You can browse a detailed device

00:26:46.018 --> 00:26:52.267
 catalog.  If you need a certain
 amount of RAM, have specific 

00:26:52.268 --> 00:26:56.420
system on system shift, you can 
set target rules.  And you can 

00:26:56.421 --> 00:27:00.589
see your installs, ratings and 
revenue details per device.

00:27:00.590 --> 00:27:06.822
Now, we've got Android Vitals in
 the dash console.  You can 

00:27:06.823 --> 00:27:11.022
pinpoint common issues like  
excessive crash rates, frozen 

00:27:11.023 --> 00:27:15.196
frames, slow  rendering, 
excessive wakeups and more.  

00:27:15.197 --> 00:27:23.525
These are enhanced by improved 
profilers in Android Studio and 

00:27:23.526 --> 00:27:27.126
new instrumentation in the 
platform.  Speaking of the 

00:27:23.526 --> 00:27:27.701
platform, Android I/O adds so 
much for the developers.  Such 

00:27:27.702 --> 00:27:33.948
as vastly improved font support,
 notification channels, a new 

00:27:33.949 --> 00:27:38.123
native AI.  Massive improvements
 in the run time, including a 

00:27:38.124 --> 00:27:44.335
series of optimizations to make 
your apps run smoother.   

00:27:44.336 --> 00:27:48.534
Adaptive icons and harden 
security with Google Play now 

00:27:48.535 --> 00:27:54.780
enabled on every device with 
Google Play.  Improved 

00:27:54.781 --> 00:27:58.946
accessibility, wide color, and 
extra long screens.  And I'll be

00:27:58.947 --> 00:28:03.106
 diving into all of this and 
much many in detail later today.

00:28:03.107 --> 00:28:07.275
  But let's talk about some of 
the ways we're extending the 

00:28:07.276 --> 00:28:11.466
Android platform.
Last week we announced and 

00:28:11.467 --> 00:28:17.731
launched AR Core.  Now --
[ Applause ]

00:28:17.732 --> 00:28:21.905
ARCore is a platform for build
ing augmented reality apps on 

00:28:21.906 --> 00:28:26.050
Android and uses three key 
technologies to integrate 

00:28:26.051 --> 00:28:28.127
virtual content with the real 
world as seen through the camera

00:28:30.200 --> 00:28:34.353
.  Motion  tracking so the phone
 can track its position relative

00:28:34.354 --> 00:28:38.521
 to the world.  Environment it 
will understanding, allows it to

00:28:38.522 --> 00:28:42.663
 see the ground or coffee table.
  And light estimation allows 

00:28:42.664 --> 00:28:44.722
the phone to estimate the 
current lighting conditions.  

00:28:44.723 --> 00:28:48.877
Now, this is being offered as an
 early preview.  You can 

00:28:48.878 --> 00:28:53.029
experiment with and build new AR
 experiences.  And this is an 

00:28:53.030 --> 00:28:55.101
opportunity for you to get 
feedback on an early version of 

00:28:55.102 --> 00:28:59.273
the API.  And this preview is 
the first step in a journey to 

00:28:59.274 --> 00:29:03.463
enabling AR capabilities across 
the entire Android ecosystem.  

00:29:03.464 --> 00:29:07.665
Check out the documentation 
pages to learn more.

00:29:07.666 --> 00:29:11.845
All right.  Switch gears.  
Literally.  Android  Auto.  It's

00:29:11.846 --> 00:29:15.999
 early days, but incredible 
growth.  We have increased the 

00:29:16.000 --> 00:29:20.167
number of Android cars to over 
50 car brands.  And there are 

00:29:20.168 --> 00:29:22.223
over 300 compatible

00:29:26.294 --> 00:29:30.466
  models today.  It's triple 
from a year ago.  And it's 

00:29:30.467 --> 00:29:32.558
becoming a standard feature in 
every car.  And we have made it 

00:29:32.559 --> 00:29:36.724
available with a stand alone 
phone app, opening up the 

00:29:36.725 --> 00:29:38.794
platform and ecosystem to 
millions are of drivers no 

00:29:38.795 --> 00:29:45.072
matter the car they're driving. 
 With WhatsApp and Aloe, or the 

00:29:45.073 --> 00:29:51.342
latest Apple releases, we have 
great apps.  It's growing 

00:29:51.343 --> 00:29:55.511
rapidly, but this is just the 
beginning.  We're working with 

00:29:55.512 --> 00:30:01.824
two European partners, Audi and 
Volvo on systems powered by 

00:30:01.825 --> 00:30:03.912
Android and we're excited to 
partner with them to usher in 

00:30:03.913 --> 00:30:10.178
the future of  connective cars. 
 Now, voice input is critical 

00:30:10.179 --> 00:30:12.272
for safety reasons.  And the 
Google system can have the voice

00:30:12.273 --> 00:30:18.520
 as we move from a mobile first 
world to an AI first world.  And

00:30:20.602 --> 00:30:24.775
 we want to be the best 
copilots.  Your assistant can

00:30:24.776 --> 00:30:26.839
talk about traffic, show gas 
stations, play your favorite 

00:30:26.840 --> 00:30:31.005
song.  And many of these 
experiences are only possible 

00:30:31.006 --> 00:30:37.237
because developers like you are 
developing the right APIs.  

00:30:37.238 --> 00:30:39.300
Thank you.
Now to the living room.  Android

00:30:39.301 --> 00:30:43.489
 TV has seen amazing device 
growth.  Strong partnerships 

00:30:43.490 --> 00:30:47.629
with pay TV operators and others
 allowed us to double the number

00:30:49.715 --> 00:30:51.802
 of activated devices in 2016.  
We expect that trend to continue

00:30:51.803 --> 00:30:55.970
 and further increase.  We are  
seeing this across the set top 

00:30:55.971 --> 00:31:00.136
box and in the smart TV form 
factors, including the many 

00:31:00.137 --> 00:31:04.294
European solutions powered by 
Android TV.  And expanded our 

00:31:04.295 --> 00:31:08.456
international footprint to more 
than 70 countries and more than 

00:31:08.457 --> 00:31:14.714
3,000 apps in the Play store.  
And the way we redefine the 

00:31:14.715 --> 00:31:16.797
experience.  This is channel
Based and content first.  

00:31:16.798 --> 00:31:20.980
Divided into channel rows, each 
created by a media app to 

00:31:20.981 --> 00:31:27.267
display a window of content 
relevant to you.  And selecting 

00:31:27.268 --> 00:31:35.567
program takes you in.  You need 
to finish binge watching.  And 

00:31:35.568 --> 00:31:39.715
what is relevant to you.  And 
you can easily transition media 

00:31:39.716 --> 00:31:43.899
apps from other Android devices.
  And we have made big updates 

00:31:43.900 --> 00:31:45.975
to the library, such as the 
playback element, allowing 

00:31:45.976 --> 00:31:50.141
detailed seek thumbnails.  And, 
of course,  integrated the 

00:31:50.142 --> 00:31:52.205
Google Assistant.  Allows you to
 search, launch video content, 

00:31:52.206 --> 00:31:58.436
and then dim the lights when you
 want to watch, all using your 

00:31:58.437 --> 00:32:00.518
voice.
All right.  Let's switch to 

00:32:00.519 --> 00:32:02.588
something a little bit closer.  
Android Wear.  During the 

00:32:02.589 --> 00:32:08.863
holiday period last year, 
Android Wear saw 72% growth.  

00:32:08.864 --> 00:32:13.040
And that was before we launched 
Android Wear 2.0.  The number of

00:32:15.124 --> 00:32:17.200
 brands supporting it doubled 
from 12 to  24.  And the choice 

00:32:17.201 --> 00:32:23.444
of Android Wear watches doubled 
from 23 last year to 46.  And 

00:32:23.445 --> 00:32:29.740
it's enabling fashionable 
watches, such as the connected 

00:32:29.741 --> 00:32:35.973
modular, and the Louis Vitton.  
And partners across many price 

00:32:35.974 --> 00:32:40.129
points and brands.  And apps are
 taking advantage of Android 

00:32:40.130 --> 00:32:44.302
Wear 2.0 and the stand alone 
functionality.  This app from 

00:32:44.303 --> 00:32:48.482
our partner, telegram, you're 
connected to an Android or 

00:32:48.483 --> 00:32:52.659
iPhone, or without a phone at 
all.  And it's never been 

00:32:52.660 --> 00:32:58.908
easier.  Another feature to 
Android Wear 2 opinions 0, 

00:32:58.909 --> 00:33:03.097
allows watch faces to look at 
extra information without 

00:33:03.098 --> 00:33:07.256
needing code.  Select the watch 
faces they want with the most 

00:33:07.257 --> 00:33:11.408
important information they care 
about, available at a glance.  

00:33:11.409 --> 00:33:15.555
Here the financial investment 
app is showing your

00:33:15.556 --> 00:33:19.747
overall portfolio value.  You 
can tap on individual stocks to 

00:33:19.748 --> 00:33:21.826
see their values.  Finally, as 
part of the launch, we announced

00:33:21.827 --> 00:33:23.914
 that the Google Assistant is 
now on your

00:33:28.008 --> 00:33:34.238
 wrist.  Going forward, apart, 
you will have another option to 

00:33:34.239 --> 00:33:38.392
bring a service to Android Wear 
for  options for Google on Wear.

00:33:38.393 --> 00:33:42.548
  And we're excited about the 
new capabilities.

00:33:42.549 --> 00:33:46.734
All right.  With so many ways 
for people to interact with 

00:33:46.735 --> 00:33:50.897
Android, the strong community, 
the improvements in the 

00:33:50.898 --> 00:33:55.079
platform, tooling, and language 
and distribution of Google Play,

00:33:55.080 --> 00:34:01.353
 it really is the best time ever
 to be an Android developer.  

00:34:01.354 --> 00:34:03.447
Please, check out the sessions, 
the trainings and the code labs 

00:34:03.448 --> 00:34:07.600
to learn how we're helping 
developers make Android great.  

00:34:07.601 --> 00:34:09.661
Now, all of the Android form 
factors are tapping into the

00:34:15.769 --> 00:34:19.906
 pour are tapping into the 
Google Assistant.  And welcome 

00:34:19.907 --> 00:34:28.188
to the stage Tilke to talk about
 what it means to developers.  

00:34:28.189 --> 00:34:30.189
Thank you.

00:34:34.271 --> 00:34:38.504
&gt;&gt; Thanks, Dan.  Hi, everyone.  
As you just heard, the Google 

00:34:38.505 --> 00:34:42.672
Assistant is now available 
across many device.  From your 

00:34:42.673 --> 00:34:46.841
phone to your car, to your watch
 and TV.  It is also available 

00:34:46.842 --> 00:34:53.097
on Google Home, and all the 
devices powered by the Google 

00:34:53.098 --> 00:34:57.259
Assistant SDK.  Tomorrow you'll 
here more about these from my 

00:34:57.260 --> 00:35:03.510
colleague, Beshad who will talk 
about the improvements on the 

00:35:03.511 --> 00:35:09.764
devices.  But today I want to 
focus on what you -- as 

00:35:09.765 --> 00:35:11.765
developers -- can do to bring 
the

00:35:13.840 --> 00:35:18.005
 power of the Assistant to your 
own apps.  With the Assistant 

00:35:18.006 --> 00:35:20.070
across devices, you can grow 
your user base in a new way.

00:35:22.138 --> 00:35:26.296
But more importantly, you can 
build apps for entirely new 

00:35:26.297 --> 00:35:28.297
assistive use cases.  Things 
that were

00:35:30.369 --> 00:35:32.452
 previously not suited for the 
voice-only interface of Google 

00:35:32.453 --> 00:35:36.664
Home.  Like shopping for 
clothes.  Or ordering food from 

00:35:36.665 --> 00:35:40.833
a lengthy menu.  With UI 
elements like image carousels, 

00:35:40.834 --> 00:35:45.018
lists and suggestion chips, 
users can see more details.  

00:35:45.019 --> 00:35:47.105
They can also  seamlessly 
transition between voice, 

00:35:47.106 --> 00:35:51.272
typing, or taps in a single 
conversation to easily get 

00:35:51.273 --> 00:35:59.621
things done with your app.
We also want to make -- help you

00:35:59.622 --> 00:36:01.705
 grow your business by making it
 easy to make purchases through 

00:36:01.706 --> 00:36:05.844
the Google Assistant.  We 
designed the transactions 

00:36:05.845 --> 00:36:10.022
experience to be easy and 
lightweight for users and 

00:36:10.023 --> 00:36:14.196
developers alike.  For payments 
-- available in Europe soon -- 

00:36:14.197 --> 00:36:16.299
you can choose Google-
facilitated

00:36:20.400 --> 00:36:24.557
 payments.  And they're easy to 
integrate and use cards that 

00:36:24.558 --> 00:36:28.717
users stored with Google for 
free.  Or use a payment method 

00:36:28.718 --> 00:36:30.799
that they have provided you.  
You can use seamless account 

00:36:30.800 --> 00:36:34.977
linking to enable users to sign 
into an existing account.  Or 

00:36:34.978 --> 00:36:37.060
create a new account with just 
two taps.

00:36:39.153 --> 00:36:43.297
But a transaction isn't over 
when the user  pays.  The users 

00:36:43.298 --> 00:36:47.449
may want to check on, modify, or
 reorder an item, which they can

00:36:49.539 --> 00:36:53.688
 do from the transaction history
 view accessible in the Google 

00:36:53.689 --> 00:36:57.891
Assistant.  Finally, we built a 
new order updates feature that 

00:36:57.892 --> 00:37:02.078
we're currently testing in the 
U.S. to make it easier for the 

00:37:02.079 --> 00:37:08.275
users to reengage with your app.
  You can send status updates 

00:37:08.276 --> 00:37:12.432
asynchronously, like when a car 
arrives to pick them up or food 

00:37:12.433 --> 00:37:16.623
is delivered.  But none of this 
matters it people can't discover

00:37:16.624 --> 00:37:22.987
 your app.  At I/O, we rolled 
out a new app directory that 

00:37:22.988 --> 00:37:24.988
will

00:37:27.061 --> 00:37:31.261
 come to Europe along with the 
Assistant.  Not only categories 

00:37:27.061 --> 00:37:31.228
and user ratings, it allows 
users to try your app directly 

00:37:31.229 --> 00:37:35.356
from the directory page.  Users 
can create a shortcut for your 

00:37:35.357 --> 00:37:39.508
app for an easy way to invoke 
it.  For example, instead of 

00:37:39.509 --> 00:37:45.746
saying, okay, Google, ask 
forecaster Joe what's the surf 

00:37:45.747 --> 00:37:49.915
report for the outer bank?  You 
can just say, okay, Google, is 

00:37:49.916 --> 00:37:54.090
the surf up?  And to make 
planning your app easier, the

00:37:54.091 --> 00:37:58.239
Assistant is also learning from 
the directory and from the 

00:37:58.240 --> 00:38:00.302
information provided by you -- 
the developer.  Thanks to these 

00:38:00.303 --> 00:38:04.464
signals, the assistant can often
 respond to general requests 

00:38:04.465 --> 00:38:10.721
like, play a game, with a few 
different options from third 

00:38:10.722 --> 00:38:12.817
parties.
Improving discovery is very 

00:38:12.818 --> 00:38:19.083
important for us.  So you can 
expect ongoing investment and  

00:38:19.084 --> 00:38:23.261
improvements in this area.  It 
is also important to us that the

00:38:23.262 --> 00:38:29.511
 developer process is smooth.  
That's  why, at I/O, we launched

00:38:29.512 --> 00:38:33.671
 a new developer console.  The 
actions console helps you work 

00:38:33.672 --> 00:38:39.897
as a team and collect data on 
your app's usage, performance, 

00:38:39.898 --> 00:38:44.044
and user discovery patterns.  It
 is integrated with the Firebase

00:38:44.045 --> 00:38:48.216
 and Google Cloud consoles to 
share the data in your apps.  In

00:38:48.217 --> 00:38:52.373
 addition to the console, we are
 providing access to developer 

00:38:52.374 --> 00:38:56.537
tools that allow you to quickly 
and easily build apps for the 

00:38:56.538 --> 00:38:58.618
Assistant.  Since the launch of 
our platform, we have worked 

00:38:58.619 --> 00:39:04.838
with an expanding number of 
developer tool companies to make

00:39:04.839 --> 00:39:09.023
 their solutions compatible with
 actions on Google.  We have 

00:39:09.024 --> 00:39:15.248
expanded the capabilities of 
API,  API.AI, our conversation 

00:39:15.249 --> 00:39:17.331
building tool.  Launching new 
features,

00:39:21.430 --> 00:39:25.563
 prebuilt agents and in-dialogue
 analytics.  While we are still 

00:39:25.564 --> 00:39:27.830
in the early days of the 
platform,

00:39:25.564 --> 00:39:31.844
we are focused on making it more
 robust and expanding its reach 

00:39:31.845 --> 00:39:35.989
and its capabilities.  We 
recently launched in UK and 

00:39:35.990 --> 00:39:40.151
Australian English and will 
launch the platform in French, 

00:39:40.152 --> 00:39:42.228
German, and other languages 
following this year.

00:39:42.229 --> 00:39:46.420
We're super-excited for the road
 ahead and we want more of you 

00:39:46.421 --> 00:39:50.591
to join us by developing for the
 platform.  With an addressable 

00:39:50.592 --> 00:39:54.741
audience of more than 100 
million devices, new 

00:39:54.742 --> 00:39:56.828
capabilities like transactions 
and an improved developer 

00:39:56.829 --> 00:39:58.908
experience, we think this is an 
incredible opportunity for all 

00:39:58.909 --> 00:40:05.193
of us.  Now, the magic of the 
Assistant is enabled by Google's

00:40:05.194 --> 00:40:09.335
 deep investment in AI and the 
cloud.  So to tell you more 

00:40:09.336 --> 00:40:15.560
about how you can use it 
directly, please welcome Sara.

00:40:17.633 --> 00:40:19.633
[ Applause ]

00:40:25.746 --> 00:40:27.746
SARA: Thanks,

00:40:29.829 --> 00:40:33.966
 Tilke.  I'm incredibly excited 
to tell you about machine 

00:40:33.967 --> 00:40:38.127
learning.  I'm Sara Robinson on 
the Google Cloud platform team 

00:40:38.128 --> 00:40:42.275
focused on big data and machine 
learning.  Any time we see ML on

00:40:42.276 --> 00:40:46.458
 a slide, it gets a lot of 
people's attention.  But before 

00:40:46.459 --> 00:40:48.568
diving into the details, I want 
to talk about what machine 

00:40:48.569 --> 00:40:50.682
learning actually is.  At a high
 level, machine learning 

00:40:50.683 --> 00:40:54.864
involves teaching computers to 
recognize patterns in the same 

00:40:54.865 --> 00:40:59.000
way that our brains do.  Over 
time, as machine learning models

00:40:59.001 --> 00:41:01.089
 are given more examples and 
experience, they can improve and

00:41:03.149 --> 00:41:05.228
 start to generalize on examples
 that they haven't seen before. 

00:41:05.229 --> 00:41:09.410
 With more data, they're able to
 generate better predictions.

00:41:09.411 --> 00:41:15.657
Does anybody remember how they 
learned their first language?  

00:41:15.658 --> 00:41:19.817
Your parents didn't give you a 
dictionary and a bunch of 

00:41:19.818 --> 00:41:21.888
grammar books, that would be 
weird.  Instead, you learned 

00:41:21.889 --> 00:41:26.057
over time after being exposed to
 examples.  So, for example, 

00:41:26.058 --> 00:41:28.058
since

00:41:30.148 --> 00:41:36.394
 you had pierogies for dinner, 
you saw them on your plate, and 

00:41:36.395 --> 00:41:40.555
heard it, and next time you had 
them for dinner, you said that's

00:41:40.556 --> 00:41:44.705
 a pierogi.  And that's how 
machine learning works too.  To 

00:41:44.706 --> 00:41:48.843
summarize, machine learning is 
loosely based on how the human 

00:41:48.844 --> 00:41:52.971
brain learns with mathematical 
neurons that mimic the neurons 

00:41:52.972 --> 00:41:57.159
in our brain.  They take a 
vector as input, transform those

00:41:57.160 --> 00:42:03.402
 values and output new values.  
And machine learning models lets

00:42:03.403 --> 00:42:07.560
 you solve problems without 
requiring you to have exactly 

00:42:07.561 --> 00:42:09.622
the solution.  And as I 
mentioned before, with more and 

00:42:09.623 --> 00:42:11.684
more data, these systems are 
able to generate better  

00:42:11.685 --> 00:42:15.875
predictions.
Now, many people see the term 

00:42:15.876 --> 00:42:20.056
"Machine  learning," and 
immediately think it's something

00:42:20.057 --> 00:42:24.214
  solely for experts.  Take a 
look back 60 years ago, this was

00:42:24.215 --> 00:42:28.351
 the case.  This is the first 
neural network invented in 1957.

00:42:30.426 --> 00:42:32.504
  It was an electronic device 
that demonstrated the ability to

00:42:32.505 --> 00:42:36.674
 identify shape.  Back then, if 
you wanted to work on machine 

00:42:36.675 --> 00:42:40.808
learning, you needed access to 
extensive academic and computing

00:42:40.809 --> 00:42:44.991
 resources.  Fast forward to 
today.  At Google even just 

00:42:44.992 --> 00:42:51.203
since 2012 the number of 
products using machine learning 

00:42:51.204 --> 00:42:55.388
has grown dramatically.  But at 
Google, we don't think machine 

00:42:55.389 --> 00:42:57.451
learning should be just for 
experts.  We want to put machine

00:42:57.452 --> 00:42:59.522
 learning into the hands of 
every developer and data 

00:42:59.523 --> 00:43:01.591
scientist -- that's all of you 
-- with a computer and a machine

00:43:03.710 --> 00:43:05.792
 learning problem they want to 
solve.

00:43:05.793 --> 00:43:09.950
On Google Cloud platform we have
 two ways to help you integrate 

00:43:09.951 --> 00:43:14.104
ML into your own applications.  
First, if you're new to machine 

00:43:14.105 --> 00:43:18.253
learning, we have six 
pre-trained APIs to give you 

00:43:18.254 --> 00:43:20.334
access to machine learning 
models with a single

00:43:24.434 --> 00:43:26.503
 REST API request.  And if you 
want to build and train from 

00:43:26.504 --> 00:43:32.764
scratch, we have a variety of 
tools to help you do that as 

00:43:32.765 --> 00:43:34.876
well.  Let's start with the pre-
trained APIs.  We have a growing

00:43:34.877 --> 00:43:39.029
 number of models that are 
already trained and continuously

00:43:39.030 --> 00:43:45.280
 updated using Google's own 
domain expertise and data sets. 

00:43:45.281 --> 00:43:51.524
 For example, the speech APIs 
allows developers to put speech 

00:43:51.525 --> 00:43:53.618
to text into their own 
applications.  Similar to okay 

00:43:53.619 --> 00:43:55.619
Google.  I'm going to

00:43:57.704 --> 00:43:59.808
 talk about the APIs in detail 
later on.  But I'm going to give

00:43:59.809 --> 00:44:06.067
 an example of one.  I'm going 
with the vision API, let's 

00:44:06.068 --> 00:44:08.133
developers better understand 
their images.  You can try out 

00:44:08.134 --> 00:44:10.227
all of our machine learning

00:44:14.332 --> 00:44:18.530
 APIs directly in the browser.  
I can upload an image and see 

00:44:18.531 --> 00:44:20.621
what vision API  responds.  
Click on this.

00:44:20.622 --> 00:44:24.808
And I'm going to choose a selfie
 from yesterday in Krakow.  It's

00:44:24.809 --> 00:44:31.049
 a little  silly.  See what the 
vision API responds.  It 

00:44:31.050 --> 00:44:35.196
identifies landmarks.  Landmark 
detection is one of the 

00:44:35.197 --> 00:44:39.374
features.  It knows the building
 and able to identify Main 

00:44:39.375 --> 00:44:43.523
Market Square.  The face 
detection identifies my face and

00:44:45.596 --> 00:44:49.753
 is also able to identify the 
emotions, joy and surprise.  I 

00:44:49.754 --> 00:44:51.840
won't go over all of the 
response types in the browser, 

00:44:51.841 --> 00:45:00.154
but you can try this out.  Go to
 cloud.google.com/vision.

00:45:00.155 --> 00:45:04.309
So you have seen the machine 
learning APIs used across a 

00:45:04.310 --> 00:45:08.462
variety of industries to 
accomplish common tasks like 

00:45:08.463 --> 00:45:12.631
classifying images, identifying 
inappropriate content, 

00:45:12.632 --> 00:45:16.788
extracting subjects from a text 
document and more.  But many 

00:45:16.789 --> 00:45:20.976
have use cases beyond these 
common machine learning tasks.  

00:45:20.977 --> 00:45:27.238
If you want to build your own 
data for custom tasks, we have 

00:45:27.239 --> 00:45:31.384
that as well.  We know data is 
at the core of any machine 

00:45:31.385 --> 00:45:33.477
learning problem and you need a 
foundation of good data to get 

00:45:33.478 --> 00:45:37.616
started.  So in order to help 
you prepare your data, we have 

00:45:37.617 --> 00:45:41.765
tools to help invest, transform,
 clean, and store your data on 

00:45:41.766 --> 00:45:45.917
Google Cloud Platform.  Once 
your data is ready, you can 

00:45:45.918 --> 00:45:50.070
train, deploy, and serve your 
models at scale on manage Google

00:45:50.071 --> 00:45:54.226
 infrastructure.
In addition to all of this, the 

00:45:54.227 --> 00:45:58.419
Google brain team has provided 
an open source library called 

00:45:58.420 --> 00:46:04.657
TensorFlow.  From the beginning,
 we wanted everybody to benefit.

00:46:04.658 --> 00:46:08.825
  It's an open source project on
 GitHub.  It's phenomenal.  It's

00:46:10.916 --> 00:46:17.184
 the most popular project on 
GitHub with over 60,000 GitHub 

00:46:17.185 --> 00:46:19.266
stars and contributions from 
many companies, not just Google.

00:46:19.267 --> 00:46:25.496
  I want to show you TensorFlow 
playground, a  visualization of 

00:46:25.497 --> 00:46:29.662
a neural network in a browser.  
So the dataset is called double 

00:46:29.663 --> 00:46:33.867
spiral.  And the data could be 
anything.  We're classifying it 

00:46:33.868 --> 00:46:40.077
into one of two categories.  Say
 it's email data, either Spam or

00:46:40.078 --> 00:46:42.078
 not Spam

00:46:44.155 --> 00:46:48.336
.   The orange dots, Spam, the 
others, not Spam.  Say we have a

00:46:48.337 --> 00:46:52.545
 data point right here, we can 
almost immediately classify that

00:46:52.546 --> 00:46:54.630
 as Spam, as an orange dot.  But
 it's much more difficult to 

00:46:54.631 --> 00:46:58.789
teach a computer these 
underlying patterns.  And before

00:46:58.790 --> 00:47:02.959
 we start training, our neural 
network's predictions don't make

00:47:02.960 --> 00:47:05.038
 too much sense.  This is the 
output or the

00:47:05.039 --> 00:47:09.197
prediction of the network.  Most
 orange dots are being 

00:47:09.198 --> 00:47:13.365
classified as blue.  So if we 
start training, we can see that 

00:47:13.366 --> 00:47:17.527
our loss, or error, is 
decreasing slowly and able to 

00:47:17.528 --> 00:47:21.691
identify complex patterns in the
 dataset.  We look at each 

00:47:21.692 --> 00:47:27.919
individual neuron, we see 
they're performing simple 

00:47:27.920 --> 00:47:30.012
classification tasks.  But 
moving through the data, it's 

00:47:30.013 --> 00:47:32.107
slowly able to each complex 
patterns.  And with more 

00:47:32.108 --> 00:47:36.273
training, we can see that it's 
able to identify this 

00:47:36.274 --> 00:47:40.474
double-spiral pattern.  As we 
went through training, our loss 

00:47:40.475 --> 00:47:44.596
decreased, the accuracy of our 
model increased, and it's able 

00:47:44.597 --> 00:47:52.946
to classify almost all of the 
points.  Check this out at 

00:47:52.947 --> 00:47:59.185
playground.tensorFlow.org.  And 
in addition to being a powerful 

00:47:59.186 --> 00:48:03.316
framework, TensorFlow is 
designed to run anywhere.  Not 

00:48:03.317 --> 00:48:07.494
only on the cloud ML emergency, 
but in your own servers, own 

00:48:07.495 --> 00:48:09.577
data centers and on VMs and 
other cloud providers and 

00:48:09.578 --> 00:48:15.827
compile them down to ARM code 
and run them on mobile devices. 

00:48:15.828 --> 00:48:17.906
 If you want to utilize Google's
 infrastructure to ingest data, 

00:48:17.907 --> 00:48:22.066
train
your model and run predictions 

00:48:22.067 --> 00:48:26.204
at scale, we have cloud machine 
learning engine.  To use it, 

00:48:26.205 --> 00:48:28.294
prepare your training data in 
Google Cloud storage or big 

00:48:28.295 --> 00:48:36.601
query,y your TensorFlow code 
locally, and use the AI to run 

00:48:36.602 --> 00:48:40.750
predictions on ML emergency.  
And for tasks like training a 

00:48:40.751 --> 00:48:47.000
model, we support GPUs, allowing
 you to significantly accelerate

00:48:49.076 --> 00:48:53.235
 your workloads.  You can go to 
this to learn more about it.

00:48:53.236 --> 00:48:57.400
There's one more thing to share 
with you.  One thing that's true

00:48:57.401 --> 00:49:01.526
 at Google, great software 
shines brightest with great 

00:49:01.527 --> 00:49:05.695
hardware underneath.  We  
started are several years ago to

00:49:05.696 --> 00:49:09.840
 see what we could accomplish 
with our own accelerators.  The 

00:49:09.841 --> 00:49:16.096
result was a tensor processing 
unit, TPU, announced at Google 

00:49:16.097 --> 00:49:20.252
I/O.  It was built specifically 
for machine learning and 

00:49:20.253 --> 00:49:24.418
tailored for TensorFlow.  We 
have been running TPUs in our 

00:49:24.419 --> 00:49:28.591
data centers for more than a 
year, and they deliver an order 

00:49:28.592 --> 00:49:32.779
of magnitude better performance 
per watt for learning.  They are

00:49:32.780 --> 00:49:39.015
 in alpha.  You want to sign up,
 cloud.google.com/TPU.  And 

00:49:39.016 --> 00:49:43.168
finally, if you remember just 
one thing from this 

00:49:43.169 --> 00:49:45.240
presentation, remember that our 
goal on Google cloud platform is

00:49:47.309 --> 00:49:51.469
 to democratize ML learning.  
Not only to

00:49:55.573 --> 00:49:59.729
 those, but to developers and 
data  scientists.  And now over 

00:49:59.730 --> 00:50:05.989
to Tal to talk about the latest 
in mobile web.

00:50:05.990 --> 00:50:10.130
TAL: Thanks, Sara.  Hi, 
everyone.  My name is Tal from 

00:50:10.131 --> 00:50:16.370
the Chrome team and I'm expected
 to tell you about some of the 

00:50:16.371 --> 00:50:20.538
great improvements on the web.  
The web is big.  With over 2 

00:50:20.539 --> 00:50:24.671
billion instances of Chrome, we 
know that the web has tremendous

00:50:24.672 --> 00:50:26.759
 reach.  But one of the true 
strengths of the web is that 

00:50:26.760 --> 00:50:33.031
it's bigger than a single 
browser.  So regardless of 

00:50:33.032 --> 00:50:37.175
whether it's a laptop or a 
desktop or a phone, they all 

00:50:37.176 --> 00:50:39.261
have a browser.  So any 
web-based experience is 

00:50:39.262 --> 00:50:43.417
available on these billions of 
devices today.  And we have seen

00:50:43.418 --> 00:50:45.517
 this have a real impact on how 
many users web apps are reaching

00:50:47.575 --> 00:50:49.637
.
We've all seen how quickly 

00:50:49.638 --> 00:50:53.793
mobile has been  growing.  And 
native apps have been growing at

00:50:53.794 --> 00:50:57.990
 an incredible pace with it.  
But what's really remarkable is 

00:50:57.991 --> 00:51:00.090
that even with the web's large 
initial reach, we have seen the 

00:51:00.091 --> 00:51:06.338
average monthly web audience 
growing even faster.  And 

00:51:06.339 --> 00:51:08.429
because of this growth, we're 
seeing the web expand into new 

00:51:08.430 --> 00:51:14.677
areas with experiences like web 
VR being built on the web 

00:51:14.678 --> 00:51:16.758
platform.  And the web continues
 to pop up in more and more 

00:51:16.759 --> 00:51:20.923
places.  Even some you might not
 expect.  We now see the web 

00:51:20.924 --> 00:51:27.152
popping up on watches, TVs, or 
even fridges.

00:51:27.153 --> 00:51:29.231
So with the web pretty much 
everywhere, we're constantly 

00:51:29.232 --> 00:51:33.410
trying to push the boundaries on
 what it can actually do.  Over 

00:51:33.411 --> 00:51:37.593
the past yearing with we've 
shipped hundreds of additional 

00:51:37.594 --> 00:51:41.768
APIs that cover a range of 
capabilities.  From making it 

00:51:41.769 --> 00:51:45.972
easy to integrate payments into 
your web experience, to  making 

00:51:45.973 --> 00:51:50.129
it possible to build fully-
capable offline media 

00:51:50.130 --> 00:51:52.215
experiences directly on the web.
And with all of these new 

00:51:52.216 --> 00:51:54.281
experiences, we've seen a 
massive growth in experiences 

00:51:54.282 --> 00:52:02.677
built on the web.  Accelerated 
mobile pages -- or AMP -- allows

00:52:02.678 --> 00:52:04.745
 publishers to easily create 
fast articles.  And since 

00:52:04.746 --> 00:52:11.029
launch, we've seen this grow to 
over 2 billion AMP pages across 

00:52:11.030 --> 00:52:17.269
900,000 domains.  And beyond AMP
 pages, the modern mobile web 

00:52:17.270 --> 00:52:19.363
also allows developers to build 
rich, mobile experiences with 

00:52:19.364 --> 00:52:25.613
something that we call 
progressive web apps, or PWAs.  

00:52:25.614 --> 00:52:29.798
PWAs are about helping web 
developers leverage the web's 

00:52:29.799 --> 00:52:33.961
reach with now capabilities to 
build high-class, immersive 

00:52:33.962 --> 00:52:38.108
experiences.  They can load 
quickly.  They work offline.  

00:52:38.109 --> 00:52:40.176
And they can even send 
notifications to users.  And 

00:52:40.177 --> 00:52:44.316
we've seen a number of amazing 
experiences taking advantage of 

00:52:44.317 --> 00:52:46.398
these new  capabilities.  As 
just one example, Twitter 

00:52:46.399 --> 00:52:50.575
recently launched a new web 
experience.  Here they have a 

00:52:50.576 --> 00:52:54.747
polished, fast, immersive 
experience that work on any 

00:52:54.748 --> 00:52:58.924
connection and can send users 
notifications.  And since it's 

00:52:58.925 --> 00:53:00.995
built
completely on the web platform, 

00:53:00.996 --> 00:53:03.085
it's already accessible on 
billions of devices.

00:53:05.182 --> 00:53:07.260
And with an immersive experience
 like this, we want to make sure

00:53:07.261 --> 00:53:11.439
 that it's really easy for users
 to get back to it.  The home 

00:53:11.440 --> 00:53:15.606
screen has existed for some time
 and allows you to add any 

00:53:15.607 --> 00:53:19.771
experience to their Android home
 screen.  But with the improved 

00:53:19.772 --> 00:53:23.942
add to home screen flow, when 
you add a PWA to the home 

00:53:23.943 --> 00:53:28.119
screen, it's fully integrated 
into the  platform.  To users 

00:53:28.120 --> 00:53:36.435
it's like any other app 
experience.  It will appear in 

00:53:36.436 --> 00:53:40.631
the app launcher and in 
settings.  But since it's a PWA,

00:53:42.723 --> 00:53:46.876
 it's small.  Users can get an 
immersive experience without 

00:53:46.877 --> 00:53:51.064
additional storage space.  And 
with this improved experience, 

00:53:51.065 --> 00:53:53.164
it's available now.  With all of
 these new capabilities, we've 

00:53:53.165 --> 00:53:57.337
also been working to make sure 
that it's super-easy for web 

00:53:57.338 --> 00:53:59.425
developers to build these 
experiences.  We'll be going 

00:53:59.426 --> 00:54:05.660
into a lot more detail about 
PWAs throughout the web track 

00:54:05.661 --> 00:54:07.732
over the next two days.  But no 
matter how you're  building your

00:54:07.733 --> 00:54:16.102
 web app, lighthouse is a tool 
to help you.  Lighthouse is a 

00:54:16.103 --> 00:54:20.282
Chrome extension
tool to audit your site to 

00:54:20.283 --> 00:54:22.378
identify how to improve 
performance, accessibility, and 

00:54:22.379 --> 00:54:28.666
progressive web appiness.  And 
we're excited to announce as of 

00:54:28.667 --> 00:54:32.861
M60, Lighthouse is integrated 
into Chrome Dev tools.  You can 

00:54:32.862 --> 00:54:37.028
quickly see how your Website is 
doing and what to do next 

00:54:37.029 --> 00:54:41.196
directly in Chrome.  With all of
 these tools, we have seen how 

00:54:41.197 --> 00:54:43.253
easy it can be for companies to 
take advantage of these new 

00:54:43.254 --> 00:54:45.327
capabilities for their web 
experience.  To give one example

00:54:47.419 --> 00:54:49.419
, there's

00:54:51.504 --> 00:54:57.763
 Trivago that build a PWA.  It's
 on the web, and users can get 

00:54:57.764 --> 00:55:01.915
to it easily.  And with the new 
add to home, it can be launched 

00:55:01.916 --> 00:55:06.135
from the home screen.  When you 
open it, you get a high-class, 

00:55:06.136 --> 00:55:10.313
immersive experience that can 
even work if you're offline.  

00:55:10.314 --> 00:55:12.393
And built to be resilient 
against different network 

00:55:12.394 --> 00:55:14.394
conditions, so you get a

00:55:16.488 --> 00:55:18.563
 seamless experience back 
online.  But what's really 

00:55:18.564 --> 00:55:22.743
incredible is this was built by 
two three core engineers in just

00:55:22.744 --> 00:55:24.845
 a couple of months.  And this 
is just one example of many.  

00:55:24.846 --> 00:55:26.938
Leveraging
 the modern mobile web is now 

00:55:26.939 --> 00:55:31.103
the norm around the world.  
Whether you're building a PWA 

00:55:31.104 --> 00:55:35.278
from scratch or leveraging the 
latest capabilities on your  

00:55:35.279 --> 00:55:37.356
existing web experience, 
companies everywhere are seeing 

00:55:37.357 --> 00:55:41.550
a tangible impact on their key 
metrics.  With the modern mobile

00:55:41.551 --> 00:55:47.851
 web, it's possible to easily 
build immersive, fully capable 

00:55:47.852 --> 00:55:49.934
experiences that can reach 
billions of people around the 

00:55:49.935 --> 00:55:54.110
world today.  And now let's turn
 our focus to what we're going 

00:55:54.111 --> 00:55:58.247
to make it easier to develop 
apps and grow your business.  

00:55:58.248 --> 00:56:02.411
Please welcome Francis.
[ Applause ]

00:56:08.513 --> 00:56:12.659
FRANCIS: Thanks, Tal.  Hi, I'm 
Francis and I lead the Firebase 

00:56:12.660 --> 00:56:16.818
product team.  Our mission is to
 help developers build a better 

00:56:16.819 --> 00:56:21.024
app and grow a successful 
business.  Since I/O 2016, we've

00:56:21.025 --> 00:56:25.178
 expanded Firebase from a set of
 backend services to a broad 

00:56:25.179 --> 00:56:29.363
mobile platform to solve many of
 the problem use face across the

00:56:29.364 --> 00:56:33.518
 life cycle of an app.  From 
helping you build faster and 

00:56:33.519 --> 00:56:37.698
easier with real-time database 
and cloud storage, to helping 

00:56:37.699 --> 00:56:41.844
you better understand and grow 
your app with tools like 

00:56:41.845 --> 00:56:43.937
analytics and cloud messaging.  
Whether you're starting 

00:56:43.938 --> 00:56:48.115
something new or looking to 
extend an existing app, we're 

00:56:48.116 --> 00:56:50.172
here to help you so you can 
channel more of your time and 

00:56:50.173 --> 00:56:54.320
energy towards creating value 
for your users.  And we deliver 

00:56:54.321 --> 00:56:58.507
all of this in a single, easy to
 use SDK available across 

00:56:58.508 --> 00:57:00.585
platforms.
To date, there are over 1 

00:57:00.586 --> 00:57:04.744
million developers using 
Firebase, and we're humbled so 

00:57:04.745 --> 00:57:08.933
many of you have taken this 
journey with us.  We're deeply 

00:57:08.934 --> 00:57:13.102
committed to Firebase and 
doubling down on our efforts to 

00:57:13.103 --> 00:57:17.256
help developers succeed.  On 
that note, earlier this year 

00:57:17.257 --> 00:57:21.412
we're excited to have the Fabric
 team join us at Google.  Since 

00:57:21.413 --> 00:57:27.680
launching analytics in 2011, our
 teams shared a similar mission.

00:57:27.681 --> 00:57:29.765
  Now we're working together to 
integrate the two  platforms and

00:57:29.766 --> 00:57:36.024
 bring you the best of both in a
 thoughtful way.  We are 

00:57:36.025 --> 00:57:40.196
bringing Crashlytics to Firebase
 to make that our flagship 

00:57:40.197 --> 00:57:46.540
product.  If you're an existing 
customer of Fabric orfire base, 

00:57:46.541 --> 00:57:48.541
we will pave a smooth

00:57:50.654 --> 00:57:56.882
 transition.  We are working to 
bring the sign in to Firebase 

00:57:56.883 --> 00:58:01.041
authentication.  You can extend 
the app, enable uses to sign in 

00:58:01.042 --> 00:58:05.201
with a phone number.  They need 
to do a one-time verification 

00:58:05.202 --> 00:58:11.449
and they're in.  With Firebase 
Auth, we provide a headless API 

00:58:11.450 --> 00:58:13.509
so you can have full control and
 customize the API

00:58:17.595 --> 00:58:19.672
 to fit the look and feel of the
 app.  In addition to 

00:58:19.673 --> 00:58:23.873
integrating with Fabric, we have
 made many updates over the last

00:58:23.874 --> 00:58:28.025
 year and I would like to 
highlight them for you.  And one

00:58:28.026 --> 00:58:34.298
 is to manage servers to focus 
on build great Apps.  We have 

00:58:34.299 --> 00:58:40.551
released cloud function for 
Firebase.  You can deploy 

00:58:40.552 --> 00:58:42.620
JavaScript to the cloud and have
 it basted on an HTTP request or

00:58:42.621 --> 00:58:46.789
 other events across Firebase.  
For example, you can set up an 

00:58:46.790 --> 00:58:51.092
example with Firebase off to 
automatically send a push 

00:58:51.093 --> 00:58:55.286
notification when a new user 
signs up.  Or set up a function 

00:58:55.287 --> 00:58:59.498
with storage so you can do 
server-side processing with 

00:58:59.499 --> 00:59:01.615
machine learning when a new 
image is uploaded.  Or use 

00:59:01.616 --> 00:59:05.809
functions with hosting to create
 a fully dynamic Website without

00:59:05.810 --> 00:59:09.954
 managing any servers.  
Functions is a great way to 

00:59:09.955 --> 00:59:14.138
extend your app and enables true
 serverless development.

00:59:14.139 --> 00:59:16.218
So we just talked about how 
Firebase helps you build more 

00:59:16.219 --> 00:59:22.478
easily.  Let's such gears and 
talk about how it can help you 

00:59:22.479 --> 00:59:24.479
focus

00:59:26.585 --> 00:59:28.656
 on app quality.  We spend time 
testing our apps, but in the 

00:59:28.657 --> 00:59:34.926
wild, sometimes end users 
experience something entirely 

00:59:34.927 --> 00:59:37.017
different based on diversity of 
devices or network conditions.  

00:59:37.018 --> 00:59:41.178
When apps don't perform well, 
it's frustrating for everyone.  

00:59:41.179 --> 00:59:45.355
That's why we released Firebase 
performance monitoring.  You can

00:59:45.356 --> 00:59:49.523
 monitor with one line of code 
to automatically measure the 

00:59:49.524 --> 00:59:53.703
startup time and network 
latency.  And you can add custom

00:59:55.770 --> 00:59:59.946
 to measure the app.  And you 
can drill in deeper to filter 

00:59:59.947 --> 01:00:04.101
databased on the country, app 
version or device type to get a 

01:00:04.102 --> 01:00:06.187
sense of how users are really 
experiencing your app and not 

01:00:06.188 --> 01:00:12.465
just in your office Wi-Fi.  
Performance monitoring is a nice

01:00:14.542 --> 01:00:18.716
 complement to Crashlytics and 
analytics to find the bottle  

01:00:18.717 --> 01:00:22.884
necks that are impacting user 
engagement or business bottom 

01:00:22.885 --> 01:00:27.021
line.  Speaking of analytics, we
 have made a number of updates 

01:00:27.022 --> 01:00:29.098
on this
front.  Earlier in the year, we 

01:00:29.099 --> 01:00:33.266
released stream Vue to give you 
a real time view of how users 

01:00:33.267 --> 01:00:37.413
are interacting with the app.  
We have added custom parameter 

01:00:37.414 --> 01:00:41.548
reporting to give you the next 
level of insights in addition to

01:00:41.549 --> 01:00:45.738
 the events that you log.  For 
example, say the logged entitles

01:00:45.739 --> 01:00:49.897
 are happening when a user 
passes around a game.  Now you 

01:00:49.898 --> 01:00:51.989
can get reports for the custom 
parameters, the type of game 

01:00:51.990 --> 01:00:56.165
played or the average number of 
points awarded.  We have worked 

01:00:56.166 --> 01:01:00.307
with the team to give you 
insights to which ad on which 

01:01:00.308 --> 01:01:04.446
screen are earning you the most 
so you can really optimize both 

01:01:04.447 --> 01:01:08.611
your ad revenue along with the 
user engagement with the broader

01:01:08.612 --> 01:01:14.858
 analytics insights you get.
we have also enhanced the 

01:01:14.859 --> 01:01:21.148
experience with  BigQuery.  Join
 it with custom data sets and 

01:01:21.149 --> 01:01:29.516
perform ad hoc analysis.  You 
can use it with data Studio to 

01:01:29.517 --> 01:01:31.630
create reports.  Essentially, 
you can build your own analytics

01:01:33.695 --> 01:01:35.765
 UI the way you want.  In 
addition to  building features, 

01:01:35.766 --> 01:01:39.937
we have recently launched a 
Firebase alpha program that 

01:01:39.938 --> 01:01:46.176
gives access to  unreleased 
products.  This is a great 

01:01:46.177 --> 01:01:48.237
opportunity to provide early 
feedback and help shape 

01:01:48.238 --> 01:01:52.427
Firebase.  Incorporating 
customer feedback is a key part 

01:01:52.428 --> 01:01:54.530
of the development process and 
we look forward to hearing from 

01:01:54.531 --> 01:01:58.682
developers like you.  Just sign 
up at the URL.  Now, we just 

01:01:58.683 --> 01:02:02.835
shared some of the updates we 
have made since last year.  To 

01:02:02.836 --> 01:02:06.984
learn more and hear what we have
 been up to, we'll be hosting 

01:02:06.985 --> 01:02:13.202
the Firebase Dev summit in 
Amsterdam at the end of October.

01:02:13.203 --> 01:02:15.292
  You can learn more at Firebase
.google.com.  And I look forward

01:02:15.293 --> 01:02:21.557
 to seeing many of you there.  I
 look forward to hearing your 

01:02:21.558 --> 01:02:23.643
feedback and continue to work 
hard to build a

01:02:23.644 --> 01:02:27.890
better app and grow a more 
successful business.  Thank you.

01:02:27.891 --> 01:02:29.984
[ Applause ]
Now I would like to bring Jason 

01:02:29.985 --> 01:02:32.090
back on.

01:02:38.207 --> 01:02:42.385
JASON: Thanks, Francis.  As you 
see, we're continuing to work 

01:02:42.386 --> 01:02:46.556
hard to improve the developer 
experience for Google's 

01:02:46.557 --> 01:02:48.635
products.  Tomorrow morning 
you'll hear more about the 

01:02:48.636 --> 01:02:52.796
products our engineering teams 
at Google are building here in 

01:02:52.797 --> 01:02:56.960
Europe.  Whether it's our 
compression team in Switzerland,

01:02:56.961 --> 01:03:03.241
 amazing compiler and language 
work in Denmark, or our cloud 

01:03:03.242 --> 01:03:05.348
team in Poland that's scaling 
the cloud, you'll also have the 

01:03:05.349 --> 01:03:11.599
opportunity to dive deep into a 
number of our products covering 

01:03:11.600 --> 01:03:15.767
Android to Firebase to the 
mobile web.  Plus sand boxes to 

01:03:15.768 --> 01:03:17.836
help you experience products 
firsthand, instructor-led  

01:03:17.837 --> 01:03:24.067
trainings and codelabs to get 
you trained on the latest APIs 

01:03:24.068 --> 01:03:28.211
today.  In addition to all of 
this, we have a large number of 

01:03:28.212 --> 01:03:30.301
Googlers who are available for 
one-on-one consultations through

01:03:30.302 --> 01:03:32.374
 office hours.  Not only can 
they help you understand our 

01:03:32.375 --> 01:03:38.620
products, but more importantly, 
they're here to get your  

01:03:38.621 --> 01:03:40.698
feedback.  I do have one other 
thing to mention before you head

01:03:42.772 --> 01:03:46.923
 off to the breakout sessions
today.  Last year we partnered 

01:03:46.924 --> 01:03:48.995
with Udacity to provide  10,000 
Android scholarships to European

01:03:51.100 --> 01:03:53.182
 developers.   We were 
overwhelmed by the demand for 

01:03:53.183 --> 01:03:57.352
the scholarship and were truly 
amazed by some of the stories 

01:03:57.353 --> 01:04:01.509
that came out of it.  Let's take
 a look at a story of a former 

01:04:01.510 --> 01:04:05.669
literature teacher turned coder.
  Play the video.

01:05:50.170 --> 01:05:52.170
[ Applause ]

01:05:58.677 --> 01:06:02.875
So this story is just one of 
many that  motivates us to 

01:06:02.876 --> 01:06:04.952
continue programs like this.  
That's why today I'm excited to 

01:06:04.953 --> 01:06:07.024
announce that we're  extending 
our partnership with Udacity to 

01:06:07.025 --> 01:06:13.253
begin the Udacity scholarship 
challenge.  This time, with 

01:06:13.254 --> 01:06:17.424
enough space for 60,000 aspiring
 developers across Europe and 

01:06:17.425 --> 01:06:23.710
select parts of Amea.
[ Applause ] and we're also 

01:06:23.711 --> 01:06:27.929
expanding the scope to include 
both Android and mobile web 

01:06:27.930 --> 01:06:32.065
development.  So please visit 
the Website to sign up and learn

01:06:32.066 --> 01:06:36.215
 more.
[ Applause ]

01:06:36.216 --> 01:06:40.389
So as you heard from the 
speakers today, we're really 

01:06:40.390 --> 01:06:44.532
excited about the possibilities 
for  developers to build some 

01:06:44.533 --> 01:06:46.622
truly amazing things.  We're 
looking forward to getting to 

01:06:46.623 --> 01:06:50.839
know you over the next two and 
hear what's on your mind.  Thank

01:06:50.840 --> 01:06:55.012
 you, and have fun.
[ Applause ]

01:36:12.859 --> 01:36:21.495
&gt;&gt; Hey.  Hello and welcome to 
Krakow.  For those of you from 

01:36:21.496 --> 01:36:25.674
Krakow, I thank you for 
welcoming us to your, you know, 

01:36:25.675 --> 01:36:27.764
beautiful city.  Here is 
actually a photograph from the 

01:36:27.765 --> 01:36:31.913
last time I was in Krakow.  When
 the temperature was like minus 

01:36:31.914 --> 01:36:36.064
20 degrees Celsius.  I have been
 happy to see some sunshine in 

01:36:36.065 --> 01:36:44.419
Krakow.  Anyway, my name is Sam 
Dutton.  I'm a developer 

01:36:44.420 --> 01:36:48.585
advocate for the web.  Work for 
Google.  Based in London.  I'm 

01:36:48.586 --> 01:36:50.691
here today and tomorrow with a 
bunch of other Googlists -- like

01:36:50.692 --> 01:36:54.877
 people working on Chrome and 
some really brilliant web 

01:36:54.878 --> 01:36:56.977
developers.  So, please, if you 
have questions, come and chat in

01:36:56.978 --> 01:37:01.140
 the web area.  Come and check 
out  Lighthouse and all the 

01:37:01.141 --> 01:37:05.279
other stuff that we've got.
I wanted to cover some of the 

01:37:05.280 --> 01:37:09.448
stuff from the keynote in a 
little more detail and really 

01:37:09.449 --> 01:37:13.600
give an overview of the web 
today.  You know, I want to give

01:37:13.601 --> 01:37:17.754
 a high-level overview, but also
 some of the business reasons 

01:37:17.755 --> 01:37:19.888
why I think it makes sense to 
build  progressive web apps.  So

01:37:19.889 --> 01:37:24.073
 we're going to go into that 
now.  There will be sessions 

01:37:24.074 --> 01:37:28.260
later with more technical detail
 about building for the web.  So

01:37:28.261 --> 01:37:32.436
 like you heard earlier, in a 
word, the web is big.  There 

01:37:32.437 --> 01:37:36.598
are, like, now over 5 billion 
devices out there that can 

01:37:36.599 --> 01:37:40.775
access web content.  This is 
incredible.  You know, you get 

01:37:40.776 --> 01:37:44.967
this instant broad reach with 
the web.  And this didn't 

01:37:44.968 --> 01:37:49.118
happen, you know, because of 
luck.  You have -- the web is 

01:37:49.119 --> 01:37:53.290
this open, decentralized 
platform.  There are no  

01:37:53.291 --> 01:37:57.455
gatekeepers.  You know, Websites
 get massive reach.  Users get 

01:37:57.456 --> 01:38:01.622
-- I don't know -- like low 
friction.  Which is great.  And 

01:38:01.623 --> 01:38:03.709
I think, you know, we've all 
seen charts like this, mobile 

01:38:03.710 --> 01:38:09.975
computing is at the heart of 
this revolution.  There's

01:38:09.976 --> 01:38:12.047
been this explosion of computing
 on mobile.  And, you know, we 

01:38:12.048 --> 01:38:18.258
now use more mobile devices than
 desktop computers and so on.  

01:38:18.259 --> 01:38:20.344
And this is really a challenge 
for developers.  We've also 

01:38:20.345 --> 01:38:24.557
reached this point now -- you 
know, particularly notice this 

01:38:24.558 --> 01:38:28.712
in some  regions -- where a lot 
of users coming online are 

01:38:28.713 --> 01:38:32.900
actually, you know, mobile-only.
  They never use a desktop  or a

01:38:32.901 --> 01:38:34.981
 laptop device.  And, again, 
this is a really interesting 

01:38:34.982 --> 01:38:41.249
challenge for the web.
Of course, on mobile, most users

01:38:41.250 --> 01:38:45.409
 spend most of their time in 
native apps, yeah?  Rather than 

01:38:45.410 --> 01:38:49.588
the web.  You know, apps that 
seem to be more predictable.  

01:38:49.589 --> 01:38:53.749
They have great reengagement 
features.  All this good stuff 

01:38:53.750 --> 01:38:57.901
in native apps.  Well, I could 
cut my presentation short right 

01:38:57.902 --> 01:39:02.087
now and say, well, build native.
  We could all go home.  There 

01:39:02.088 --> 01:39:06.312
is a flipside to this, though.  
And I'm sure you understand it, 

01:39:06.313 --> 01:39:12.602
particularly app developers in 
the audience here.  App usage is

01:39:12.603 --> 01:39:16.816
 highly concentrated.  Users 
tend to only use a few apps.  

01:39:16.817 --> 01:39:21.004
They see native apps as a big 
commitment to device space and 

01:39:21.005 --> 01:39:27.259
time and cost.  Native apps are 
engaging, but only a few are 

01:39:27.260 --> 01:39:31.444
worth installing.  Based on a 
recent study, the average user 

01:39:31.445 --> 01:39:35.609
is installed like zero apps per 
month.  This certainly does not 

01:39:35.610 --> 01:39:39.829
mean that users are not  using 
native apps.  But, you know, by 

01:39:39.830 --> 01:39:43.982
contrast, from our own data, 
something like the average 

01:39:43.983 --> 01:39:48.164
mobile user visits like around 
100 sites per month.  You know, 

01:39:48.165 --> 01:39:56.502
this is the power of URL
st and the web.

01:39:58.583 --> 01:40:00.676
   Particularly to me.
And one way to think of the 

01:40:00.677 --> 01:40:04.893
native and web apps are the 
capabilities.  Native apps start

01:40:04.894 --> 01:40:11.163
 up quickly and reliably when 
you tap the icon.  They tend to 

01:40:11.164 --> 01:40:13.164
work off

01:40:15.251 --> 01:40:19.465
 offline.  Who here -- when do 
you open a web browser when 

01:40:19.466 --> 01:40:27.824
you're not online?  That's not 
what you do.  Native apps have 

01:40:27.825 --> 01:40:29.825
push notifications and have 
access to

01:40:31.927 --> 01:40:36.116
 device cameras microphones and 
so on.  In contrast, the web is 

01:40:36.117 --> 01:40:42.382
maybe seen as safer, more 
respectful of privacy, maybe.  

01:40:42.383 --> 01:40:46.558
But hasn't had those 
capabilities.  What if we could 

01:40:46.559 --> 01:40:48.659
add those  capabilities so the 
web could get that engagement 

01:40:48.660 --> 01:40:52.839
and meet those UX expectations? 
 We could have the best of both 

01:40:52.840 --> 01:40:59.083
worlds.  And, you know, this is 
what progressive web Apps 

01:40:59.084 --> 01:41:03.269
represent.  A user experience 
that's good enough -- integrated

01:41:03.270 --> 01:41:05.377
 enough -- so you can actually 
earn a place on the home screen.

01:41:05.378 --> 01:41:09.577
  And the notification without 
having to give up that reach to 

01:41:09.578 --> 01:41:13.770
get that.  This is really the 
core point.  Progressive weapon 

01:41:13.771 --> 01:41:15.898
apps is really just a term for 
--

01:41:15.899 --> 01:41:22.219
look -- radically improving the 
quality of the  end-to-end user 

01:41:22.220 --> 01:41:26.383
experience.  We want to learn 
from native Apps.  Take what's 

01:41:26.384 --> 01:41:30.539
best from native apps and bring 
that to the web.  And this 

01:41:30.540 --> 01:41:32.607
requires being really honest 
about what matters to user.  So 

01:41:32.608 --> 01:41:36.783
in order to do that, I think we 
need to focus on four things.  

01:41:36.784 --> 01:41:40.973
We need to make the web fast.  
We need to make web experiences 

01:41:40.974 --> 01:41:43.061
better integrated device, you 
know, hardware platforms and 

01:41:43.062 --> 01:41:47.216
other apps.  We need to make 
sure that web experiences are 

01:41:47.217 --> 01:41:51.382
reliable and we need to keep 
users engaged.  So I want to 

01:41:51.383 --> 01:41:55.575
look at each of those properties
 in a little more detail.

01:41:55.576 --> 01:42:01.802
From a good native app, users 
don't expect janky scrolling or 

01:42:01.803 --> 01:42:08.045
bad experience.  The web has had
 a bad name for slow 

01:42:08.046 --> 01:42:10.151
performance.  Particularly on 
mobile.  Like in-page 

01:42:10.152 --> 01:42:12.233
performance like scrolling and 
so on as well as load 

01:42:12.234 --> 01:42:16.418
performance.  And in a sense, an
 app has to be kind of 

01:42:16.419 --> 01:42:20.636
invisible.  You know, users 
should not be aware that they're

01:42:20.637 --> 01:42:22.719
 actually loading an app.  It 
should just work.  We want to 

01:42:22.720 --> 01:42:26.868
see that on the web.  This isn't
 just a kind of abstract goal.  

01:42:26.869 --> 01:42:33.115
No, we all know that time is 
money on the web.  This data 

01:42:33.116 --> 01:42:37.275
shows just how much that is 
true.  After only like a little 

01:42:37.276 --> 01:42:41.445
more than 3 seconds, something 
like  20% of your users will 

01:42:41.446 --> 01:42:47.727
abandon the experience.  And, 
you know, there's evidence that 

01:42:47.728 --> 01:42:51.898
users are getting shorter 
attention spans.  That this is 

01:42:51.899 --> 01:42:56.087
getting tighter every year.
So a couple of other numbers, 

01:42:56.088 --> 01:43:00.231
you know.  It takes the average 
web page on mobile 19 seconds to

01:43:00.232 --> 01:43:04.398
 load on a 3G connection.  You 
know, that's really bad for 

01:43:04.399 --> 01:43:10.730
everyone.  For every 1 second 
delay in load, we calculate that

01:43:10.731 --> 01:43:14.898
 the sites lose something like 7
% of conversion.  So that's 

01:43:14.899 --> 01:43:16.975
really bad for business.  You 
know, we really need to fix 

01:43:16.976 --> 01:43:23.261
this.  And one of the -- I think
 one of the side effects, you 

01:43:23.262 --> 01:43:25.370
know, thinking about this on the
 web -- the reach of the web -- 

01:43:25.371 --> 01:43:29.526
is that you do not have control 
where users start in your 

01:43:29.527 --> 01:43:33.729
experience.  Like which page 
they hit first on your site.  

01:43:33.730 --> 01:43:37.910
You can't dictate, like, you can
 with a native app where users 

01:43:37.911 --> 01:43:44.180
start.  So in working to make 
sure that wherever someone 

01:43:44.181 --> 01:43:46.271
starts, they start fast.  Pages 
need to be reliable and fast 

01:43:46.272 --> 01:43:48.351
from the first time that users 
load them.

01:43:50.443 --> 01:43:56.713
And to fix this, last year we 
started working on a project of 

01:43:56.714 --> 01:44:00.909
mobile pages, AMP.  This is an 
open source project to create 

01:44:00.910 --> 01:44:05.095
super-fast web pages.  We know 
that accessing pages on the 

01:44:05.096 --> 01:44:11.388
mobile web can be painful, and 
AMP is a framework to make sure 

01:44:11.389 --> 01:44:15.528
they load reliably.  We have 
been able to prove this over the

01:44:15.529 --> 01:44:19.668
 last year.  AMP pages load on 
average in less than a second.  

01:44:19.669 --> 01:44:23.854
They use 10% less data compared 
to non-AMP pages.  This is 

01:44:23.855 --> 01:44:28.025
particularly important for users
 where data is expensive.  Where

01:44:28.026 --> 01:44:32.203
 people are really constrained 
by the use of data.  A good 

01:44:32.204 --> 01:44:38.438
example of this, doing great 
work, actually.  The  Weather 

01:44:38.439 --> 01:44:42.624
Channel, have seen a four time 
increase on the AMP articles 

01:44:42.625 --> 01:44:51.009
from the main page.  That's like
 a 90% click through rate.  

01:44:51.010 --> 01:44:55.164
Which is fantastic.  Since 
launching this year.  And an 

01:44:55.165 --> 01:44:59.310
example of these giant 
hailstones.  They get that at 

01:44:59.311 --> 01:45:01.405
weather.com, and AMP is really 
Faying off for them.  Now, AMP 

01:45:01.406 --> 01:45:05.590
was originally focused on 
publishers and static content.  

01:45:05.591 --> 01:45:11.836
The format has been constantly
evolving.  To support really 

01:45:11.837 --> 01:45:18.129
critical new features like 
E-commerce.  You can use AMP to 

01:45:18.130 --> 01:45:22.295
build interactive and engaging 
pages.  And a lot of E-commerce 

01:45:22.296 --> 01:45:28.591
partners have really started to 
do that.  Our last summit eBay 

01:45:28.592 --> 01:45:32.834
launched all their product 
listing pages on AMP.  Over 15 

01:45:32.835 --> 01:45:37.044
million pages.  Reliably load in
 less than a second.  And 

01:45:37.045 --> 01:45:45.449
launching product pages 
worldwide on app.  Users can go 

01:45:45.450 --> 01:45:49.603
from searching on Google to 
buying on eBay in 3 seconds.  So

01:45:49.604 --> 01:45:53.744
 for AMP, since launch, there 
have been over 2 billion AMP 

01:45:53.745 --> 01:45:57.878
pages.  900,000 domains.  And 
every second 58 AMP pages are 

01:45:57.879 --> 01:45:59.959
released into the  wild.  
Incredible.

01:45:59.960 --> 01:46:06.193
If you want to learn more about 
AMP, check out Ben Morss' 

01:46:06.194 --> 01:46:08.290
presentation after lunch today. 
 We have an AMP training session

01:46:10.368 --> 01:46:12.443
 tomorrow afternoon as well.  
You'll find that AMP and 

01:46:12.444 --> 01:46:16.602
progressive web apps, they work 
really well.  The two attitudes 

01:46:16.603 --> 01:46:22.822
work well together.  To build 
sites, as the slogan goes: to 

01:46:22.823 --> 01:46:27.045
start faster and stay fast.
So as well as speed, users 

01:46:27.046 --> 01:46:33.289
expect this app-like integration
 for their device hardware, 

01:46:33.290 --> 01:46:35.380
operating system and other apps.
  You know that feeling when you

01:46:35.381 --> 01:46:37.381
 use a

01:46:39.470 --> 01:46:43.625
 great native app, you can get 
the tight focus and focus on 

01:46:43.626 --> 01:46:45.688
what you want to achieve and 
forget that you're using an app.

01:46:45.689 --> 01:46:51.936
  Users shouldn't have to feel 
like they're easing through a 

01:46:51.937 --> 01:46:56.080
browser in order to access your 
app.  Users shouldn't have to 

01:46:56.081 --> 01:47:00.203
think about the fact that on the
 web, using their phone, tablet 

01:47:00.204 --> 01:47:04.378
or desktop to complete the 
tasks.  One example that's dear 

01:47:04.379 --> 01:47:10.614
to my heart and worked on is 
media.  In the past it's been 

01:47:10.615 --> 01:47:14.775
really difficult to get media 
working on the web.  People felt

01:47:14.776 --> 01:47:18.905
 like they had to consume media 
in an app.  Isn't the case 

01:47:18.906 --> 01:47:23.050
anymore.  We worked hard across 
platforms to make media more 

01:47:23.051 --> 01:47:29.262
effective and also just to 
ensure that, you know -- to be 

01:47:29.263 --> 01:47:33.413
included in the page and it just
 works.  We have great new APIs 

01:47:33.414 --> 01:47:37.591
to build robust, secure, and 
efficient media experiences that

01:47:37.592 --> 01:47:41.747
 can even work offline.
This is a particularly important

01:47:41.748 --> 01:47:48.046
 problem to solve, you know.  
Over 70% of Internet traffic now

01:47:48.047 --> 01:47:52.239
 is actually video.  The number 
is increasing.  It's incredible.

01:47:52.240 --> 01:47:56.388
  You know, we need all the 
browsers to ensure that we are 

01:47:56.389 --> 01:48:02.607
getting this complete solution 
across different browsers to the

01:48:02.608 --> 01:48:08.829
 mobile web for media.  So you 
have these new APIs that are  

01:48:08.830 --> 01:48:10.916
improving capability for media 
on the web.  I would really 

01:48:10.917 --> 01:48:15.085
recommend checking out -- this 
is Paul Lewis' fantastic 

01:48:15.086 --> 01:48:23.373
progressive web app.  It's bit. 
bit.ly/pwa-media.  It gives

01:48:25.454 --> 01:48:27.532
 precaching for faster loads.  
Orientation chain gives you 

01:48:27.533 --> 01:48:31.685
instant full screen.  You get 
custom controls, thumbnails and 

01:48:31.686 --> 01:48:33.755
so on.
For me, this is amazing.  This 

01:48:33.756 --> 01:48:37.944
is amazing to see this happening
 on the web.  It's a beautiful  

01:48:37.945 --> 01:48:40.012
app.  I really recommend that.  
So the technology is opening up 

01:48:40.013 --> 01:48:46.243
the web to even more platforms, 
even more experiences.  With web

01:48:48.312 --> 01:48:56.601
 VR APE, this expressive  pourer
 on the web.  And experience 

01:48:56.602 --> 01:49:00.762
this from VR creators.  Creators
 from around the world directly 

01:49:00.763 --> 01:49:09.056
to the browser.  With company 
like SketchFab  bringing this 

01:49:09.057 --> 01:49:13.229
VR.  I believe they have 1.5 
million you can explore.  This 

01:49:13.230 --> 01:49:17.379
would look wonderful if everyone
 here had a VR headset.  Would 

01:49:17.380 --> 01:49:21.560
also look weird, I guess.  You 
would get a sense of what was 

01:49:21.561 --> 01:49:25.693
possible.  But looking forward 
to the advent of augmented 

01:49:25.694 --> 01:49:27.768
reality, this idea of connecting
 information data from the 

01:49:27.769 --> 01:49:34.000
physical world.  We think the 
web is going to play a pivotal 

01:49:34.001 --> 01:49:38.149
role there as well.
Thinking about integration, I 

01:49:38.150 --> 01:49:42.279
wanted to touch on new 
capabilities also for E-commerce

01:49:44.349 --> 01:49:48.496
.  You know, mobile commerce is 
a huge deal.  Last year mobile 

01:49:48.497 --> 01:49:52.630
commerce was worth -- just in 
the U.S. -- it was worth 

01:49:52.631 --> 01:49:54.705
something like $123 billion.  
You can imagine from the figure 

01:49:54.706 --> 01:49:58.857
is for Europe.  This is actually
 a fundamental challenge to the 

01:49:58.858 --> 01:50:05.116
web.  So the web has gone 
mobile, but conversions are -- 

01:50:05.117 --> 01:50:09.264
we calculate -- something like 
one-third lower on mobile than  

01:50:09.265 --> 01:50:13.408
desktop.  You know, this makes 
sense.  It's hard to enter data 

01:50:13.409 --> 01:50:17.577
on a phone.  And we need better 
integration, you know, because 

01:50:17.578 --> 01:50:21.746
E--commerce is really all about 
removing friction.

01:50:21.747 --> 01:50:27.983
So browsers improve this with 
autofilaments.  Great.  Today on

01:50:27.984 --> 01:50:32.134
 Chrome we have something like 9
 billion forms of passwords that

01:50:32.135 --> 01:50:36.289
 are autofilled each month.  
Which is good.  But it's not 

01:50:36.290 --> 01:50:40.457
enough.  The payment request API
 goes a step further than this. 

01:50:40.458 --> 01:50:44.623
 This is a W3C standard for 
browsers to present a, you know,

01:50:44.624 --> 01:50:48.784
 a standardized interface for 
users to enter payment and 

01:50:48.785 --> 01:50:54.990
shipping data.  So users get, 
you know, consistent secure 

01:50:54.991 --> 01:50:59.127
experience.  And developers 
don't have to reinvent the wheel

01:50:59.128 --> 01:51:07.421
 every time.  And this goes up 
to an E-commerce giant.  Like in

01:51:07.422 --> 01:51:11.583
 the screen here, the browser 
can securely store email 

01:51:11.584 --> 01:51:17.806
shipping, credit card data on 
file for the user.  The browser 

01:51:17.807 --> 01:51:24.021
can provide a merchant with all 
this in one form, pre-populated 

01:51:24.022 --> 01:51:30.273
to reduce friction.  So you can 
see that the web has become a 

01:51:30.274 --> 01:51:36.502
highly capable platform.  It's 
tightly integrated with 

01:51:36.503 --> 01:51:38.583
operating system, hardware 
capabilities.  We just need 

01:51:38.584 --> 01:51:44.793
better reliability as well.
As present users have not come 

01:51:44.794 --> 01:51:48.964
to expect the web to work 
without a network connection.  

01:51:48.965 --> 01:51:53.103
And don't even boother to try 
when connectivity is slow or 

01:51:53.104 --> 01:51:57.248
intermittent.  We need to change
 that perception.  Web apps must

01:51:57.249 --> 01:52:01.385
 be reliable.  When a user taps 
like on a home screen icon, they

01:52:01.386 --> 01:52:05.534
 expect it to load instantly and
 reliably.  Launched from the 

01:52:05.535 --> 01:52:11.764
home screen, apps should never, 
ever show.  Thinking back to the

01:52:11.765 --> 01:52:15.896
  '90s when the web was growing 
up, does anybody know what this 

01:52:15.897 --> 01:52:17.990
is?  Maybe not.  Maybe a few 
people.  For those who have 

01:52:17.991 --> 01:52:22.115
never seen them, this is how we 
got online.  Probably from some 

01:52:22.116 --> 01:52:26.275
monolithic desktop somewhere in 
the house or basement or 

01:52:26.276 --> 01:52:30.432
something.  With this modem.  
You had to put the whole house 

01:52:30.433 --> 01:52:36.659
on online mode.  Back in the 
day, 56K to me was  exciting.  

01:52:36.660 --> 01:52:42.906
We grew up on 14K.  What you 
have to do is yell to the whole 

01:52:42.907 --> 01:52:47.090
house, "Don't pick up the  
phone!" or that would kill the 

01:52:47.091 --> 01:52:51.264
connection.  In those days we 
knew we were online because 

01:52:51.265 --> 01:52:55.403
nothing else was happening.
Now, we think of Internet 

01:52:55.404 --> 01:53:01.606
connectivity kind of more like a
 utility like gas or 

01:53:01.607 --> 01:53:05.743
electricity.  Almost like 
oxygen.  Users are expecting 

01:53:05.744 --> 01:53:07.812
connectivity to be available all
 the tomb.  And, you know, we've

01:53:07.813 --> 01:53:14.047
 become used to this.  And this 
means that, you know, seeing 

01:53:14.048 --> 01:53:18.176
this dinosaur is just not an 
option.  Can you imagine if you 

01:53:18.177 --> 01:53:22.331
went to a native app and you got
 some kind of system-generated 

01:53:22.332 --> 01:53:26.462
error message, you know?  When 
the device was offline.  You 

01:53:26.463 --> 01:53:32.719
would just think, what?  This is
 crazy.  We have become used to 

01:53:32.720 --> 01:53:34.801
this on the web.  We have to 
deal with this.  We have to 

01:53:34.802 --> 01:53:38.955
solve this.  The other problem 
is -- as we know -- mobile 

01:53:38.956 --> 01:53:43.102
phones are not just online or 
offline, they're a binary state.

01:53:43.103 --> 01:53:47.278
  The existence, is it on or is 
it off?  Get the problems with 

01:53:47.279 --> 01:53:51.417
cell connectivity.  You have 
four bars here, but you do not 

01:53:51.418 --> 01:53:53.481
have a working connection.  So 
it's not just no connection that

01:53:55.548 --> 01:53:59.674
 breaks our experience, slow or 
intermittent connections can 

01:53:59.675 --> 01:54:03.810
really be worse for users.
And like I say, mobile apps 

01:54:03.811 --> 01:54:07.956
should -- as much as I love the 
cute little dinosaur -- they 

01:54:07.957 --> 01:54:14.189
should never show him.  No other
 app will show this.  And so in 

01:54:14.190 --> 01:54:18.357
order for web apps to earn their
 place on the home screen, we 

01:54:18.358 --> 01:54:20.432
need to make them reliable even 
when the network is not reliable

01:54:22.505 --> 01:54:26.666
.  And this is where service 
workers come in.  I wanted to 

01:54:26.667 --> 01:54:30.799
ask, who has heard of service 
workers and feels they have a 

01:54:30.800 --> 01:54:34.961
pretty good idea of why they're 
game changing for the web?  Oh, 

01:54:34.962 --> 01:54:39.135
that's great, actually.  Hooray!
  That's really good to see.  

01:54:39.136 --> 01:54:41.212
You know, for those of you who 
don't know about service workers

01:54:43.306 --> 01:54:47.461
, the traditional web model has 
been you type in a URL, click on

01:54:47.462 --> 01:54:51.619
 a link -- whatever.  And the 
browser goes to the network, 

01:54:51.620 --> 01:54:53.701
looks up the web server and  
retrieves the resources required

01:54:53.702 --> 01:54:59.972
 for a page.  Now, the browser, 
of course, has an HTTP cache.  

01:54:59.973 --> 01:55:04.146
You  know, if the network is 
down you get a visit from our 

01:55:04.147 --> 01:55:08.302
friend, the dinosaur.  And the 
user experience, obviously, can 

01:55:08.303 --> 01:55:12.475
be even worse with flakey
 connectivity.  So a service 

01:55:12.476 --> 01:55:18.693
worker is a client-side proxy.  
Acts as an intermediary between 

01:55:18.694 --> 01:55:22.837
your app and the outside world. 
 You write a service worker in 

01:55:22.838 --> 01:55:31.147
JavaScript in a separate file, 
kind of like a web worker.  And 

01:55:31.148 --> 01:55:33.232
after that, it's installed and 
can respond to

01:55:37.341 --> 01:55:39.419
 events like network requests.  
And the service worker can use 

01:55:39.420 --> 01:55:43.576
the cache API to cache resources
 and work with index DB for data

01:55:45.649 --> 01:55:49.791
 and so on.  And that enables 
you -- the developer -- the site

01:55:49.792 --> 01:55:53.931
 designer -- to decide when to 
use the cache and when to go to 

01:55:53.932 --> 01:55:58.105
the network.  This is extremely 
powerful.

01:55:58.106 --> 01:56:02.254
Service workers are acting like 
proxy in the outside world.  

01:56:02.255 --> 01:56:06.415
This means they can handle 
incoming events as well as 

01:56:06.416 --> 01:56:08.476
outgoing requests.  Push 
notifications are a great 

01:56:08.477 --> 01:56:10.562
example of this.  Push messages 
are received, you know, by the 

01:56:10.563 --> 01:56:16.810
operating system via whatever 
push service it uses.  And then 

01:56:16.811 --> 01:56:23.044
passed on to browser.  The push 
event from the browser then 

01:56:23.045 --> 01:56:27.217
wakes up the relevant service 
worker and then goes to the push

01:56:27.218 --> 01:56:31.399
 handler.  It means that the 
browser cannot evenly be open.  

01:56:31.400 --> 01:56:37.631
This is fantastic for reducing 
usage of memory and so on.

01:56:37.632 --> 01:56:43.874
I think, you know, this kind of 
capability for engagement and 

01:56:43.875 --> 01:56:45.958
reengagement is where 
progressive web apps, you know, 

01:56:45.959 --> 01:56:52.159
are really coming alive.  So, of
 course, a truly engaging app 

01:56:52.160 --> 01:56:56.328
needs to go beyond being just 
functional and reliable and 

01:56:56.329 --> 01:57:00.497
ensure that like the whole 
experience is delightful and it 

01:57:00.498 --> 01:57:02.564
makes it easier, you know, for 
the user to do what they need to

01:57:02.565 --> 01:57:06.715
 do.  Really good experiences on
 the web.  You have the right 

01:57:06.716 --> 01:57:10.860
capabilities, use them at the 
right time in a beautiful way.  

01:57:10.861 --> 01:57:17.110
Twitter is a great example of 
this.  They launched a 

01:57:17.111 --> 01:57:19.181
progressive web app in spring 
this year.  They noticed that 

01:57:19.182 --> 01:57:23.354
their web traffic was growing 
and yet the experience wasn't 

01:57:23.355 --> 01:57:27.515
great.  So they set out to 
redesign their mobile web 

01:57:27.516 --> 01:57:31.667
experiences with PWA.  And this 
is a great place to look to see 

01:57:31.668 --> 01:57:35.801
what can be done on the web.
They had three goals in mind.  

01:57:35.802 --> 01:57:39.968
They needed to cope with slow or
 flakey networks, and they had 

01:57:39.969 --> 01:57:46.203
to consume less data.  This is 
critically important for the 

01:57:46.204 --> 01:57:50.340
global service for all of their 
users.  And Twitter needs to 

01:57:50.341 --> 01:57:54.498
work well for a huge variety of 
smartphones from high end to low

01:57:54.499 --> 01:58:00.731
 end.  And they have tiny levels
 of storage and limited CPU.  

01:58:00.732 --> 01:58:04.873
For those with phones in your 
hand, check out  mobile

01:58:06.958 --> 01:58:09.035
.twitter.com.  You can see how 
fast and smooth the scrolling is

01:58:11.128 --> 01:58:13.206
.  Performance is a huge 
priority for Twitter.  They can 

01:58:13.207 --> 01:58:17.360
access photos and videos for 
upload.  You can see a Tweet 

01:58:17.361 --> 01:58:21.540
going on here.  And, of course, 
the web can now send push 

01:58:21.541 --> 01:58:23.616
notifications.  You know, on 
Android,

01:58:29.720 --> 01:58:33.884
 they appear alongside native 
notifications.  Twitter is now 

01:58:33.885 --> 01:58:38.009
sending out something like 10 
million push notifications per 

01:58:38.010 --> 01:58:40.010
day, which is incredib

01:58:42.094 --> 01:58:46.241
What I really love, though, is 
Twitter can deliver this 

01:58:46.242 --> 01:58:48.307
experience at a fraction of the 
side compared to native.  You 

01:58:48.308 --> 01:58:52.484
can see here the difference that
 a progressive web app can make.

01:58:52.485 --> 01:58:56.627
  So how can a  PWA be so small?
  Well, you know, when you 

01:58:56.628 --> 01:59:00.771
download an app, you download 
everything that the app needs.  

01:59:00.772 --> 01:59:09.079
Which is why you get those data 
sizes.  But the PWA can leverage

01:59:09.080 --> 01:59:13.251
 the browser and install more 
assets and data as required.  

01:59:13.252 --> 01:59:17.375
And, again, this is a huge deal.
  We need to remember that like 

01:59:17.376 --> 01:59:21.538
for a lot of users in many 
regions, the constraint is 

01:59:21.539 --> 01:59:25.673
actually from data costs as well
 as connectivity.  We need to 

01:59:25.674 --> 01:59:29.818
remember that and bear that in 
mind.  So as you might expect, 

01:59:29.819 --> 01:59:33.993
Twitter is getting great metrics
 for their PWA compared to their

01:59:33.994 --> 01:59:36.076
 previous mobile experience.  
And they're getting something 

01:59:36.077 --> 01:59:38.147
like a million daily visits.  
Users coming from the home 

01:59:38.148 --> 01:59:42.281
screen icon.  Which is great.  I
 have seen the same from a 

01:59:42.282 --> 01:59:48.483
company called Ola.  This is 
like India's largest ride  

01:59:48.484 --> 01:59:50.554
hailing service.  You
know, their mission was to build

01:59:50.555 --> 01:59:56.796
 mobility for a billion, you 
know, Indians.  Incredible 

01:59:56.797 --> 02:00:00.948
scale.  We started like six 
years ago -- the co-founders.  

02:00:00.949 --> 02:00:02.949
They would actually drive  
customers

02:00:05.024 --> 02:00:09.155
 if they show up.  Now up to a 
million rides a day.  Something 

02:00:09.156 --> 02:00:11.238
like that.  But that was not 
enough when their target was, 

02:00:11.239 --> 02:00:15.409
like, billions of  users.  What 
they needed to do was to target 

02:00:15.410 --> 02:00:19.570
tier 2 and tier 3 cities.  These
 are smaller cities.  20 to 

02:00:19.571 --> 02:00:23.710
maybe 100K in size.  A lot of 
users in those cities get flakey

02:00:25.776 --> 02:00:29.919
 connectivity and are using, you
 know, cheaper smart phones.  

02:00:29.920 --> 02:00:34.069
And it makes sense for those 
people not to actually install 

02:00:34.070 --> 02:00:38.224
apps because of limited storage 
and the cost of data.

02:00:38.225 --> 02:00:44.481
So with Ola, their progressive 
web app, you get smooth 

02:00:44.482 --> 02:00:48.624
navigation -- which is great -- 
a fantastic, robust UX.  And, 

02:00:48.625 --> 02:00:52.801
you know, great functionality.  
Even on low bandwidth.  So since

02:00:52.802 --> 02:00:56.964
 launch what they've seen is 
that things are going well for 

02:00:56.965 --> 02:01:01.103
them in the cities.  But what's 
really nice is they're seeing 

02:01:01.104 --> 02:01:05.235
great conversions up in the tier
 3 cities.  Up like 30%.  This 

02:01:05.236 --> 02:01:07.292
is a fundamental point that 
progressive web apps, allowing 

02:01:07.293 --> 02:01:11.435
them to address new audiences 
and new markets.

02:01:11.436 --> 02:01:15.600
One stat I would really like 
from them, actually, is that 

02:01:15.601 --> 02:01:19.737
like 20% of their progressive 
web app bookings are actually 

02:01:19.738 --> 02:01:23.871
from users who had previously 
uninstalled the app.  You know, 

02:01:23.872 --> 02:01:28.018
this is fantastic.  It's worth 
remembering that a lot of users 

02:01:28.019 --> 02:01:30.126
because of device memory 
constraints -- whatever -- are 

02:01:30.127 --> 02:01:34.287
regularly uninstalling apps.  
And you don't get that on the 

02:01:34.288 --> 02:01:38.443
web.  If you want to find out 
more about like what Ola and 

02:01:38.444 --> 02:01:40.631
Twitter have done, check out 
their case studies on web 

02:01:40.632 --> 02:01:44.767
fundamentals.  I'll be sharing a
 link to that at the end of the 

02:01:44.768 --> 02:01:48.902
presentation.  Just briefly 
getting back to the topic of 

02:01:48.903 --> 02:01:50.993
engagement, you know, when a 
user visits your site, you can 

02:01:50.994 --> 02:01:55.138
now prompt them to add the site 
to their home screen.  Great 

02:01:55.139 --> 02:02:01.367
example of doing it really well 
is Trivago -- the travel site.  

02:02:01.368 --> 02:02:05.527
They have a progressive web app 
for something like 55 domains 

02:02:05.528 --> 02:02:11.756
globally.  Incredible.  And the 
add to home screen works really,

02:02:11.757 --> 02:02:15.915
 really well.  This app is now 
tightly integrated with the 

02:02:15.916 --> 02:02:20.072
Android device.  It's in the app
launch like other apps and part 

02:02:20.073 --> 02:02:24.242
of Android settings -- which is 
pretty.

02:02:24.243 --> 02:02:28.382
But given this focus on Android,
 you might be wondering, well, 

02:02:28.383 --> 02:02:30.455
is this progressive web app  
thing -- like, is this a Google 

02:02:30.456 --> 02:02:34.608
thing?  And the answer is no.  A
 big part of what makes 

02:02:34.609 --> 02:02:36.692
progressive web apps so 
successful is that multiple 

02:02:36.693 --> 02:02:40.829
browsers are committed to them. 
 You know, developer adoption is

02:02:40.830 --> 02:02:44.977
 obviously growing.  But so is 
browser support.  Opera, 

02:02:44.978 --> 02:02:51.219
Samsung, Microsoft, Mozilla are 
on board.  The features are 

02:02:51.220 --> 02:02:55.367
discussed.  And service workers 
are in development for Safari, 

02:02:55.368 --> 02:02:59.518
which is great.  But progressive
 web apps are really about the 

02:02:59.519 --> 02:03:01.593
attitude to building web 
experiences that work well for 

02:03:01.594 --> 02:03:05.765
all your users so you can count 
on reaching users that are 

02:03:05.766 --> 02:03:09.911
important to you.  The word 
"Progressive" -- progressive web

02:03:12.005 --> 02:03:14.085
 apps.  It's not there by 
accident.  We need to focus on 

02:03:14.086 --> 02:03:18.256
the end-to-end user experience 
that can give a dramatic impact 

02:03:18.257 --> 02:03:24.464
to your business.  Even with 
users who haven't experienced 

02:03:24.465 --> 02:03:30.717
the full  power of web apps 
because they're using a device 

02:03:30.718 --> 02:03:38.995
without a certain feature.
Lanco me built this great PWA.  

02:03:38.996 --> 02:03:43.182
I want to call this out because 
something like 60% of their 

02:03:43.183 --> 02:03:47.352
users are on iOS.  What they 
found was when they built their 

02:03:47.353 --> 02:03:53.591
progressive web app and used the
 techniques we're advocating and

02:03:53.592 --> 02:03:55.676
 you can learn more about today,
 they were getting much higher 

02:03:55.677 --> 02:03:59.841
engagement.  This is fantastic. 
 You know?  It just means that 

02:03:59.842 --> 02:04:01.912
this is a good investment for 
you no matter what the browser 

02:04:01.913 --> 02:04:08.173
mix is that you're  targeting.
Gartner recently published a 

02:04:08.174 --> 02:04:12.327
report advocating that PWAs 
should be part of a mobile 

02:04:12.328 --> 02:04:14.390
development strategy.  And, you 
know, this idea that progressive

02:04:14.391 --> 02:04:20.635
 web apps will begin to replace 
general purpose apps.  So I know

02:04:20.636 --> 02:04:24.812
 this, you know, this sounds 
great.  But I also know that 

02:04:24.813 --> 02:04:28.967
reality sinks in, you know, you 
go back to your day job.  And 

02:04:28.968 --> 02:04:31.063
you think about building a 
progressive web app that can 

02:04:31.064 --> 02:04:35.222
seem like this huge undertaking.
  But implementing these 

02:04:35.223 --> 02:04:39.369
techniques need not be this 
monolithic refactoring task.  I 

02:04:39.370 --> 02:04:41.440
want to talk about some ways to 
get started.

02:04:41.441 --> 02:04:45.612
First and foremost, you need 
security, yeah?   HTTPS is table

02:04:45.613 --> 02:04:49.777
 stakes for progressive web 
apps.  Keep your users and 

02:04:49.778 --> 02:04:51.843
business safe.  This is not just
 for sites that work with 

02:04:51.844 --> 02:04:55.986
sensitive data.  You know, any 
site can be a target that's 

02:04:55.987 --> 02:05:00.127
vulnerable for attack.  And the 
green lock, you know, indicates 

02:05:00.128 --> 02:05:06.364
that site is secure.  It is a 
secure connection between your 

02:05:06.365 --> 02:05:08.445
users and your site.  This means
 three things.  The user must be

02:05:10.512 --> 02:05:12.587
 able to trust that the site is 
actually you, not a scammer or a

02:05:14.679 --> 02:05:20.910
 phisher.  They must be assured 
that no one can tamper with the 

02:05:20.911 --> 02:05:25.049
content.  And then be sure that 
no one is listening to the 

02:05:25.050 --> 02:05:29.316
intersection between them and 
your site.  The web has this 

02:05:29.317 --> 02:05:31.392
tremendous reach and lack of 
friction.  Keeping users safe is

02:05:31.393 --> 02:05:37.616
 absolutely Paramount.  And for 
this reason HTTPS is mandatory 

02:05:37.617 --> 02:05:43.843
for many of the APIs on the web.
  Including service worker, 

02:05:43.844 --> 02:05:50.069
geolocation, camera access, so 
on.  So once you have moved to a

02:05:50.070 --> 02:05:54.224
 secure domain, three approaches
 to moving to a progressive web 

02:05:54.225 --> 02:05:56.225
app. 
You can build from the ground up

02:05:56.300 --> 02:05:58.396
.  You can start with a simple 
version or focus on a single 

02:05:58.397 --> 02:06:02.528
feature.  Just want to have a 
quick look at these.  So 

02:06:02.529 --> 02:06:04.635
starting from the ground up 
makes sense.  When you go 

02:06:04.636 --> 02:06:08.807
through a re-design.  Starting 
from scratch, you can build that

02:06:10.870 --> 02:06:12.956
 app-ness in from the start 
using service workers and so on.

02:06:12.957 --> 02:06:19.164
  OLX is a great example of 
this.  They launched their site 

02:06:19.165 --> 02:06:25.391
for classified ads in many India
.  Providing great markets and 

02:06:25.392 --> 02:06:29.542
they have seen fantastic 
improvements to times to 

02:06:29.543 --> 02:06:33.694
interactive, drops in bounce 
rates and so on.  They wanted to

02:06:33.695 --> 02:06:35.772
 reengage with their users, 
yeah?  Including their mobile 

02:06:35.773 --> 02:06:39.901
app users.  And they've had 
fantastic results with that.  

02:06:39.902 --> 02:06:44.047
And, again, they built this 
right from scratch.  But, of 

02:06:44.048 --> 02:06:46.126
course, not everyone can do 
this.  You know, starting from 

02:06:46.127 --> 02:06:48.127
scratch is not realistic

02:06:50.195 --> 02:06:56.423
 as an example.  But a different
 approach is Air Berlin.  They 

02:06:56.424 --> 02:07:00.552
built this post-check-in app 
where you can get all the 

02:07:00.553 --> 02:07:02.637
details.  Your flight.  They 
weren't able to start

02:07:02.638 --> 02:07:06.779
everything from scratch.  Check 
out their stuff.  They have done

02:07:06.780 --> 02:07:10.933
 a beautiful job of this.  You 
can get your boarding pass, all 

02:07:10.934 --> 02:07:15.086
those details, even when the app
 is, then, offline.  Now, the 

02:07:15.087 --> 02:07:19.241
final strategy is, you know, 
just the define is to pick on 

02:07:19.242 --> 02:07:23.387
one particular strategy.  
Whether.com have done a great 

02:07:23.388 --> 02:07:25.471
job with this with 
notifications.  I would really, 

02:07:25.472 --> 02:07:29.623
really recommend -- they've 
rolled this out in like 60 

02:07:29.624 --> 02:07:33.774
languages -- if you're looking 
at UX for notifications, I would

02:07:33.775 --> 02:07:35.835
 really recommend you look at 
what they've done.  They done a 

02:07:35.836 --> 02:07:39.997
beautiful job of this within a 
PWA experience.

02:07:39.998 --> 02:07:44.176
And they've seen, you know, 
great results from this.  A 

02:07:44.177 --> 02:07:48.333
million opt ins within a month 
and so on.  So check out their 

02:07:48.334 --> 02:07:52.528
work.  I thoroughly recommend 
that.  So, you know, I would 

02:07:52.529 --> 02:07:57.603
look at these  different -- if 
you're thinking of building a 

02:07:57.604 --> 02:08:05.924
progressive web app.  Come along
 to Ewa's talk  later.  It's an 

02:08:05.925 --> 02:08:08.009
excellent talk and she'll talk 
about how you can get started.  

02:08:08.010 --> 02:08:12.154
Great momentum, different 
verticals, you know, with travel

02:08:12.155 --> 02:08:16.310
 companies on the web.  We've 
seen, like, publishers.  

02:08:16.311 --> 02:08:20.490
Partners like Forbes.  Forbes 
has seen double in user 

02:08:20.491 --> 02:08:24.653
engagement since the launch of 
their PWA, which is fantastic.  

02:08:24.654 --> 02:08:33.131
And in E-commerce sites as well.
  Fandango, Alibaba, they have 

02:08:33.132 --> 02:08:37.289
all invested successfully in web
 Apps.  And newer services like 

02:08:37.290 --> 02:08:41.436
ride sharing companies.  This is
 a sample of some of the people 

02:08:41.437 --> 02:08:43.437
actively working with PWA

02:08:45.523 --> 02:08:47.610
s.  Check out their work.  They 
have done beautiful work 

02:08:47.611 --> 02:08:49.687
building great sites.  And 
they're just finding ways to 

02:08:49.688 --> 02:08:53.850
start down this path.  Investing
 in -- I

02:08:53.851 --> 02:08:58.020
don't know -- in the mobile web 
and getting down this path of 

02:08:58.021 --> 02:09:02.187
building progressive web Apps.  
So I think progressive web apps 

02:09:02.188 --> 02:09:06.350
for the company.  Giving them 
reach and capability.  The 

02:09:06.351 --> 02:09:10.504
ability to target new audiences 
and new markets which is 

02:09:10.505 --> 02:09:12.587
incredibly exciting on the web. 
 If you want to learn more about

02:09:12.588 --> 02:09:14.670
 this, we have some great 
sessions coming up.

02:09:14.671 --> 02:09:18.833
Some good presences today and 
tomorrow.  We'll have, like I 

02:09:18.834 --> 02:09:25.110
say, a lot of expert web 
Googlers on hand to answer your 

02:09:25.111 --> 02:09:27.173
questions and solve your  
problems.  I would strongly 

02:09:27.174 --> 02:09:31.339
recommend the training sessions 
from Sara Clark and her team.  

02:09:31.340 --> 02:09:33.433
Really good people running those
 sessions.  And if you want to 

02:09:33.434 --> 02:09:37.619
find out more, please check out 
web fundamentals like case 

02:09:37.620 --> 02:09:41.762
studies, resources at  
developers.google.com/web.  Most

02:09:41.763 --> 02:09:45.906
 of all, please feel free to 
come and talk to us.  Any of the

02:09:45.907 --> 02:09:50.074
 Googlers -- there's a bunch of 
web Googlers here.  We're here 

02:09:50.075 --> 02:09:52.124
to learn what you're doing on 
the web.  What we can do to make

02:09:52.125 --> 02:09:56.282
 the web better and to help you,
 you know, build better 

02:09:56.283 --> 02:09:58.370
experiences for all your users. 
 Thank you very much.  And we'll

02:10:00.456 --> 02:10:04.626
 see you around.  Thank you.
[ Applause ]

02:19:54.025 --> 02:19:56.025
. 
&gt;&gt; Testing testing test

02:19:58.115 --> 02:20:00.204
ing, testing testing testing

02:20:20.347 --> 02:20:22.427
.  
&gt;&gt; Testing testing testing, this

02:20:22.428 --> 02:20:26.580
 is a test for Google Developer 
Days. 

02:20:34.717 --> 02:20:36.796
This is a captioning test. 

02:21:35.194 --> 02:21:37.259
.  
&gt;&gt; Hello, everyone.  My name is 

02:21:37.260 --> 02:21:39.260
re

02:21:41.370 --> 02:21:45.544
Rebecca Franks and where will 
speak to you about Android 

02:21:45.545 --> 02:21:49.726
things and how I think it is the
 IoT platform for everyone.  

02:21:49.727 --> 02:21:53.932
What is Android things? Android 
things is an extension of the 

02:21:53.933 --> 02:21:58.094
Android platform for IoT and 
embedded devices.  We have known

02:22:00.162 --> 02:22:04.328
 Android for years, but it was 
available for us on our watches,

02:22:06.398 --> 02:22:10.564
 and also in our cars with 
Android auto.  And now, with 

02:22:10.565 --> 02:22:14.717
Android things, you can have 
Android on any devices that you 

02:22:14.718 --> 02:22:18.910
can imagine.
So Android Things is ideal for 

02:22:18.911 --> 02:22:23.073
powerful, intelligent devices 
that need to be secure.  Some 

02:22:23.074 --> 02:22:27.217
examples of where Android Things
 work well is in the retail 

02:22:27.218 --> 02:22:31.354
industry, for things such as 
interactive ads, or vending 

02:22:31.355 --> 02:22:35.498
machines, powered by Android.
And also, in the business 

02:22:35.499 --> 02:22:43.810
industry, with things such as 
cameras, access control and 

02:22:43.811 --> 02:22:45.876
smart access meters.
And in the logistics industry, 

02:22:45.877 --> 02:22:52.106
you can think of using Android 
Things in asset tracking or 

02:22:52.107 --> 02:22:54.191
predictive service.
But Android things is also very 

02:22:54.192 --> 02:23:00.381
suitable for home automation.
So, a smart doorbell, or an 

02:23:00.382 --> 02:23:04.530
energy monitoring system will 
also do well with Android 

02:23:04.531 --> 02:23:06.864
Things.
So, a question that you are 

02:23:04.531 --> 02:23:10.764
probably wondering is: How 
similar is Android's 

02:23:10.765 --> 02:23:14.921
developments to Android Things? 
And the answer is, it is very, 

02:23:14.922 --> 02:23:19.116
very similar.  So when you are 
developing for Android Things, 

02:23:19.117 --> 02:23:21.206
you are using the Android SDK.  
So all the APIs, and all the 

02:23:21.207 --> 02:23:25.387
things that you learned as an 
Android developer are similar 

02:23:25.388 --> 02:23:31.616
for you to do Android Things.  
You are also using Android 

02:23:31.617 --> 02:23:33.617
Studio, so you are hold

02:23:35.732 --> 02:23:39.891
ing it to your Android Things 
device. 

02:23:39.892 --> 02:23:44.046
You can also use the Play 
Services, the nearby API or 

02:23:44.047 --> 02:23:48.200
vision API, you can use on 
Android Things.  And because it 

02:23:48.201 --> 02:23:52.366
is Android as well, you can use 
there

02:23:56.470 --> 02:24:04.738
 the Firebase ATKs.  You can 
also use the cloud platform, so 

02:24:04.739 --> 02:24:06.823
the core, you can use with 
Android things.

02:24:06.824 --> 02:24:15.112
And the base part is because it 
is -- you can use any -- if

02:24:17.180 --> 02:24:23.397
 you are a big fan of Java, you 
can do that with Android Things 

02:24:23.398 --> 02:24:25.463
as well. 
So now we have seen how similar 

02:24:25.464 --> 02:24:29.627
Android things is to Android 
developments.  But there's a 

02:24:29.628 --> 02:24:31.719
couple of differences you have 
to keep in mind when you are 

02:24:31.720 --> 02:24:37.946
developing for Android Things.  
So the first is you know the 

02:24:37.947 --> 02:24:42.114
play store you are shipping your
 app on to.  Your app is running

02:24:42.115 --> 02:24:44.236
 on the device, and there's no 
such thing as a play store where

02:24:44.237 --> 02:24:50.431
 you can go and install web apps
 from.  And there is also a set 

02:24:50.432 --> 02:24:52.513
of APIs that are available to 
you.  So things such as your 

02:24:54.583 --> 02:24:56.583
notifications

02:24:58.680 --> 02:25:02.835
 -- 
And when you are developing for 

02:25:02.836 --> 02:25:04.911
Android Things, you are using 
custom hardware, that's the 

02:25:04.912 --> 02:25:09.068
biggest difference when you are 
developing for Android versus 

02:25:09.069 --> 02:25:13.228
Android Things.  So what you 
hold is what you ship.

02:25:13.229 --> 02:25:21.518
So when you are on the Play 
Store and downloading from

02:25:23.595 --> 02:25:25.687
 the app store, you are shipping
 the hardware and the software 

02:25:25.688 --> 02:25:27.688
together. 

02:25:30.004 --> 02:25:34.193
 a single-purpose device.  And 
what I mean by that is your app 

02:25:34.194 --> 02:25:40.415
and your platform device, that 
is the only thing that will be 

02:25:40.416 --> 02:25:42.521
there, there is nothing else, so
 the users are not install ing 

02:25:42.522 --> 02:25:48.716
anything else on the device.  
And then you are deploying to 

02:25:48.717 --> 02:25:50.786
your clients.

02:25:54.885 --> 02:25:59.075
 typical stack of a traditional 
Android

02:26:03.164 --> 02:26:05.164
 mobile device.

02:26:07.258 --> 02:26:09.370
 a rich set of APIs for our apps
 to use.

02:26:09.371 --> 02:26:13.507
And applications provide a 
userface for general use cases, 

02:26:13.508 --> 02:26:19.758
such as our launchers, or 
phones, and our messaging apps. 

02:26:21.849 --> 02:26:23.912
 With Android Things, we are 
using a couple of different APIs

02:26:23.913 --> 02:26:28.045
 and applications that have been
 available for you as an Android

02:26:28.046 --> 02:26:36.407
 developer.  So the default apps
 are removed, you no longer have

02:26:36.408 --> 02:26:38.488
 the messaging capabilities on 
Android Things.

02:26:38.489 --> 02:26:42.664
And it also means that the APIs 
are monitoring behavior.  So if 

02:26:42.665 --> 02:26:44.665
you have

02:26:46.746 --> 02:26:48.795
 notifications --.
And now, when you are developing

02:26:48.796 --> 02:26:52.978
 for Android Things, you get the
 Android Things support as part 

02:26:52.979 --> 02:27:01.300
of your development.  So things 
such as Peripheral I/O and 

02:27:01.301 --> 02:27:03.383
device management, we will go in
 detail to those a little bit 

02:27:03.384 --> 02:27:07.540
later. 
So Android Things uses a system 

02:27:07.541 --> 02:27:11.754
on module architecture, or an 
SoM architecture.  The system is

02:27:11.755 --> 02:27:13.831
 designed around a core 
computing module that is located

02:27:13.832 --> 02:27:22.146
 on a bigger breakout board in 
prototyping and development.  

02:27:22.147 --> 02:27:26.280
And when you go into production,
 this is used on a platform that

02:27:26.281 --> 02:27:30.452
 you would ship to your client. 
 This reduces costs and 

02:27:30.453 --> 02:27:32.453
simplifies development because

02:27:34.554 --> 02:27:38.704
 the hybrid design is in the 
sample. 

02:27:38.705 --> 02:27:44.962
The Google package creates a 
stable bed to rely on.  So if it

02:27:44.963 --> 02:27:49.118
 changes, you don't need to 
worry as much because the 

02:27:49.119 --> 02:27:51.227
package is supported. 
And

02:27:55.308 --> 02:27:57.404
 it makes it a lot easier to 
use. 

02:28:01.512 --> 02:28:03.588
And this is before you ship them
 to your clients.  This can be 

02:28:03.589 --> 02:28:05.589
very

02:28:07.667 --> 02:28:11.823
, and we are using the 
architecture design to simplify 

02:28:11.824 --> 02:28:13.894
costs as Google handles the 
complexity for you.

02:28:13.895 --> 02:28:18.053
So when you are developing with 
Android Things, there's a couple

02:28:18.054 --> 02:28:24.282
 of things that are managed by 
Google and things that are 

02:28:24.283 --> 02:28:28.416
managed by you.  So that 
includes the framework, the 

02:28:28.417 --> 02:28:34.639
hardware libraries, and the 
Linex Kernel, you don't need to 

02:28:34.640 --> 02:28:36.747
worry about that.  And you as a 
developer need to worry about

02:28:40.844 --> 02:28:45.005
 the apps and the user drivers. 

02:28:49.092 --> 02:28:51.163
 So the console is what you 
would use as a developer to ship

02:28:53.237 --> 02:28:55.237
 to your devices. 

02:28:57.324 --> 02:29:03.570
So you would manage your IoT 
product on the console, you can 

02:29:03.571 --> 02:29:09.806
download the latest Android 
things on the image, and you can

02:29:09.807 --> 02:29:13.946
 build factory images that 
contain OEM applications along 

02:29:13.947 --> 02:29:15.947
with the system image.

02:29:18.049 --> 02:29:24.290
 console itself, you also push 
OTA to your clients, and if you 

02:29:24.291 --> 02:29:28.490
go to partner.Android.com/
things/console, you can see this

02:29:30.566 --> 02:29:32.645
.
And taking a quick look at the 

02:29:32.646 --> 02:29:34.714
console, though, this is what 
you would see if you are 

02:29:34.715 --> 02:29:38.902
developing your app.
So, this is the -- I created 

02:29:38.903 --> 02:29:47.209
this candy dispenser, and where 
will set the -- this is what you

02:29:47.210 --> 02:29:49.210
 would receive. 

02:29:53.298 --> 02:29:57.446
And on this console, you can see
 where you would download on 

02:29:57.447 --> 02:29:59.447
what you are shipping.

02:30:01.545 --> 02:30:03.545
bundle, and this is

02:30:05.670 --> 02:30:11.893
 what contains what you want to 
ship, as well as your size.  You

02:30:11.894 --> 02:30:16.090
 can also use the version of 
Android Things from your core, 

02:30:16.091 --> 02:30:20.246
and then you can download this 
factory image on the devices 

02:30:20.247 --> 02:30:22.247
that you are using.

02:30:24.338 --> 02:30:28.526
 you are already using a device 
in production, you can use the 

02:30:28.527 --> 02:30:30.613
same process, select the bundle,
 SX

02:30:34.685 --> 02:30:36.771
and your image.
Of course, so we have a little 

02:30:36.772 --> 02:30:40.917
bit of background on how Android
 Things works and what it is, so

02:30:40.918 --> 02:30:42.985
 I will take a quick look at how
 we develop for Android Things.

02:30:47.096 --> 02:30:49.210
ill get started with Android 
Things, you need to purchase or 

02:30:49.211 --> 02:30:55.439
obtain a Developer Kit.  There 
are two that I like, the NXPI.

02:30:57.516 --> 02:30:59.589
MX7D, or the

02:31:05.669 --> 02:31:07.669
 raspberry

02:31:09.747 --> 02:31:11.834
Raspberry Pi 3.  You start up 
the device and then you would 

02:31:11.835 --> 02:31:15.963
have Android Things running on 
it.  From this point on, you can

02:31:15.964 --> 02:31:22.218
 connect over to a Raspberry Pi 
or cable.

02:31:30.317 --> 02:31:38.706
 the NXP more than the Raspberry
 Pi. 

02:31:38.707 --> 02:31:42.846
And we can use custom hardware 
with the devices.  And in order 

02:31:42.847 --> 02:31:44.934
to access these different 
hardware

02:31:49.039 --> 02:31:51.104
 peripherals, there are 
different options we need to 

02:31:51.105 --> 02:31:55.253
use.  So I like to think of it 
as two different ways, one being

02:31:55.254 --> 02:31:57.330
 the difficult way and one being
 the easy way.

02:31:59.414 --> 02:32:03.611
And the peripheral I/O extension
 is what I think of as more of a

02:32:05.684 --> 02:32:07.777
 difficult way, but basically 
what this gives you is access to

02:32:07.778 --> 02:32:11.929
 all the different protocols 
that you might be used to if you

02:32:11.930 --> 02:32:13.930
 have done any kind

02:32:16.020 --> 02:32:22.249
 of development forward.  So 
things such as your GPIO, or PWM

02:32:24.313 --> 02:32:28.479
 protocol, you can get access to
 them using the Peripheral I/O 

02:32:28.480 --> 02:32:30.541
measure.  This does sound a 
little bit tricky, if this is 

02:32:30.542 --> 02:32:32.626
not your thing, you can head to

02:32:36.701 --> 02:32:38.701
 the per

02:32:40.791 --> 02:32:42.864
Peripheral Driver Library on 
GitHub, and that allows you to 

02:32:42.865 --> 02:32:47.036
use things with your Android 
Things application.

02:32:47.037 --> 02:32:51.235
You can use a similar motor, or 
all that is available to your in

02:32:51.236 --> 02:32:53.236
 your link down below.
And so,

02:32:55.312 --> 02:33:01.531
 I like to think of it as, you 
don't know what you are doing 

02:33:01.532 --> 02:33:05.675
with Android things, you can get
 to the GitHub library.  If you 

02:33:05.676 --> 02:33:07.749
want local access, you can use 
the standard protocols.

02:33:11.834 --> 02:33:13.946
 to quickly build an app.  This 
is basically what we have on the

02:33:13.947 --> 02:33:15.947
 screen here is

02:33:20.045 --> 02:33:26.268
 a board.  So this is simple, 
why are Android Things involved,

02:33:26.269 --> 02:33:30.422
 but we have Android Things 
control the LED when the battery

02:33:30.423 --> 02:33:32.482
 is pressed.  So what we're 
going to do, we're going to have

02:33:34.557 --> 02:33:36.628
 two pins that we are using in 
this case.

02:33:36.629 --> 02:33:44.926
And this is what I like to refer
 to as the Pinout Diagram.  If 

02:33:44.927 --> 02:33:51.184
you have these devices, you will
 see that there's a button on 

02:33:51.185 --> 02:33:57.427
the Raspberry Pi.  So what you 
want to do now, you are going to

02:33:57.428 --> 02:34:01.572
 be using 

02:34:05.648 --> 02:34:09.786
BCM12 and 21.
So in the studio, you go into 

02:34:09.787 --> 02:34:13.943
and create an application, and 
in the Android studio, we create

02:34:13.944 --> 02:34:18.101
 the project.  And then we would
 link it to Android Things as an

02:34:20.189 --> 02:34:24.345
 option we want to build for.  
We can choose to have -- and 

02:34:24.346 --> 02:34:30.580
then automatically, it compounds
 the dependencies.

02:34:36.683 --> 02:34:40.871
 is -- to make sure we have the 
latest version.  

02:34:50.974 --> 02:34:55.142
And this indicates that we are 
using the library in store. 

02:34:55.143 --> 02:34:57.212
And then, we add

02:35:01.312 --> 02:35:05.484
ed -- when the device re-boots, 
it automatically views the 

02:35:05.485 --> 02:35:07.561
activity we created.  You need 
to add the stuff yourself if you

02:35:07.562 --> 02:35:09.627
 have not run through the

02:35:13.712 --> 02:35:17.859
 create -- your Android Things 
project from scratch.  We need 

02:35:17.860 --> 02:35:19.860
to use it yourself.

02:35:21.967 --> 02:35:26.163
 what I'm going to do is use the
 button from the GitHub support 

02:35:26.164 --> 02:35:28.219
library that we saw earlier.
So I'm just using it within 

02:35:28.220 --> 02:35:32.367
cradle, putting it in my cradle 
file, and now I get access to a 

02:35:34.434 --> 02:35:36.525
button.
So I would create a new button 

02:35:36.526 --> 02:35:42.769
by setting a new equals new 
Button, and I give it what we 

02:35:42.770 --> 02:35:49.010
were talking about earlier.  In 
this case, BCM6, Pressed When 

02:35:49.011 --> 02:35:55.248
Low.  This is not the same as 
Android.widget.button, it is a 

02:35:55.249 --> 02:35:57.339
different thing from the Android
 support line.  And now what you

02:35:57.340 --> 02:36:03.584
 can do is set an on-click 
listener on the button.

02:36:03.585 --> 02:36:07.789
And all we're going to do in 
this case is set the value to 

02:36:07.790 --> 02:36:11.946
true or false.
And now, this might be a little 

02:36:11.947 --> 02:36:18.163
bit confusing for us, but we 
will get into the -- next.

02:36:18.164 --> 02:36:22.334
The next thing we need to do is 
make sure that we close the 

02:36:22.335 --> 02:36:26.496
access that we have.  This makes
 sure that we free up any 

02:36:26.497 --> 02:36:30.639
resources we were using before. 
 To get access to the led that 

02:36:30.640 --> 02:36:32.700
we had before, we go to the

02:36:36.777 --> 02:36:38.867
 Peripheral Manager Server API. 
 This is provided by the Android

02:36:38.868 --> 02:36:45.087
 support library, you can use it
 by importing the compiled 

02:36:45.088 --> 02:36:51.304
dependency.  And so we would 
just then say, service.open 

02:36:51.305 --> 02:36:57.529
Gpio, and then we would set the 
direction out initially low.  

02:36:57.530 --> 02:37:01.702
And then we will set it as true 
or false if we need to.

02:37:01.703 --> 02:37:03.804
And now,

02:37:07.883 --> 02:37:12.018
 we get a false when the user 
lets up their finger. 

02:37:12.019 --> 02:37:14.085
And then you need to close up 
this as well, you are

02:37:18.153 --> 02:37:22.294
 not -- you are going to LED 
GPIO.closed. 

02:37:22.295 --> 02:37:26.422
And then you have a blinking LED
 powered by Android Things.

02:37:26.423 --> 02:37:32.638
So now that we've seen how to 
build a simple Android Things 

02:37:32.639 --> 02:37:34.712
project, there's a couple of 
examples I want to go through 

02:37:34.713 --> 02:37:36.782
that I want you to look to if 
you go to

02:37:40.876 --> 02:37:42.940
 hacksterio/Google.

02:37:47.051 --> 02:37:51.255
Smith, the Edison Candle.  This 
is a candle powered by Android 

02:37:51.256 --> 02:37:55.411
Things and this example is for 
you to understand how to go from

02:37:55.412 --> 02:37:57.493
 a prototype to production and 
all the different things you 

02:37:57.494 --> 02:38:01.641
would need in order to get 
there.  So be sure to check out 

02:38:01.642 --> 02:38:05.797
that project on Hackster.
And the next project I want to 

02:38:05.798 --> 02:38:12.044
highlight is the piano hero, 
this is on display if you go to 

02:38:12.045 --> 02:38:14.114
the Android Things stand.  This 
is basically using a keyboard, 

02:38:14.115 --> 02:38:22.403
power up Android Things, you can
 play guitar hero with a piano. 

02:38:22.404 --> 02:38:26.570
And then one other one I would 
like to talk about is my only 

02:38:26.571 --> 02:38:32.792
one, this is an electricity 
monitoring app.  And in South 

02:38:32.793 --> 02:38:39.044
Africa, we suffer regularly from
 power outages.  And I have this

02:38:39.045 --> 02:38:43.203
 problem where I don't know if I
 have at power at home versus 

02:38:43.204 --> 02:38:47.378
when I didn't, I built this app 
using Android Things and 

02:38:49.475 --> 02:38:53.633
Fairbase ATKs.  This runs on my 
Pi at home, and when I don't 

02:38:53.634 --> 02:38:55.634
have power, I

02:38:57.721 --> 02:38:59.798
 can determine if the power is 
off or back on.  It also keeps 

02:38:59.799 --> 02:39:06.034
track of how long I have had 
power for at my house, which is 

02:39:06.035 --> 02:39:12.279
really useful. 
How I did that, with Firebase, 

02:39:12.280 --> 02:39:14.280
you get a nice

02:39:16.373 --> 02:39:22.643
 HDK, connected, and this tells 
you if you are connected to the 

02:39:22.644 --> 02:39:28.872
internet or not.  So this is 
just a monitor for connectivity,

02:39:28.873 --> 02:39:35.090
 but my network is more reliable
 than my power. 

02:39:35.091 --> 02:39:39.259
So you add a value event 
listener on this. And then for 

02:39:39.260 --> 02:39:47.561
this part, on the snapshot, you 
can determine if you are online 

02:39:47.562 --> 02:39:51.694
or not.  And if you are, it is 
service equals true and you add 

02:39:51.695 --> 02:39:55.837
the disconnect listener.  This 
is where it is super powerful.  

02:39:55.838 --> 02:39:57.906
And the listener says, when this
 client disconnects from the 

02:39:57.907 --> 02:40:04.141
server, set the value to true or
 false.  And on the server, I'm 

02:40:04.142 --> 02:40:06.228
using the Firebase cloud 
functions to determine if I 

02:40:06.229 --> 02:40:10.381
should send a notification or 
not.  I'm monitoring this, and 

02:40:10.382 --> 02:40:12.458
if anything changes, a push 
notification is sent out to the 

02:40:12.459 --> 02:40:14.523
device.

02:40:18.616 --> 02:40:20.740
 actually built myself is what 
we call an AI Candy Dispenser.  

02:40:20.741 --> 02:40:29.022
So this one has been built by 
Alvaro Viebrantz, you can find 

02:40:29.023 --> 02:40:31.023
it on hack

02:40:33.106 --> 02:40:37.279
Hackster as well.  It is using 
the TensorFlow API offline on 

02:40:37.280 --> 02:40:39.357
the device.  So how it works, 
when you press the button, it 

02:40:39.358 --> 02:40:45.611
asks you to please show me a 
photo of a cat or a lion or 

02:40:45.612 --> 02:40:47.676
something like that.
And then you have to quickly 

02:40:47.677 --> 02:40:51.827
search for one on the internet, 
or maybe you have some of those 

02:40:51.828 --> 02:40:55.971
objects lying around, and then 
show this image to the device, 

02:40:55.972 --> 02:41:00.112
and then it uses TensorFlow to 
try to classify the image it has

02:41:00.113 --> 02:41:06.316
 on the device, and then if it 
is a cat or a lion, you got it 

02:41:06.317 --> 02:41:12.529
right, and it dispenses candy.  
This is all powered using 

02:41:12.530 --> 02:41:14.581
Android Things and the 
TensorFlow libraries. 

02:41:14.582 --> 02:41:18.725
So I encourage you to add your 
project

02:41:22.811 --> 02:41:29.053
 tohackster io/Google.  So if 
you are using Android things, 

02:41:29.054 --> 02:41:31.125
please share so everyone else 
can see. 

02:41:31.126 --> 02:41:37.350
So why Android things? It is the
 power of Android in your own 

02:41:37.351 --> 02:41:41.522
hands on these devices.  Google 
manages the complexity of 

02:41:41.523 --> 02:41:45.703
automatic and secure objects, 
and it is easier for you as a 

02:41:45.704 --> 02:41:49.839
developer to manage the same 
thing. 

02:41:49.840 --> 02:41:54.007
If you are curious about 
learning more, at 1:00, there's 

02:41:54.008 --> 02:42:00.209
an instructor-led training about
 hands-on with Android Things 

02:42:00.210 --> 02:42:04.375
and creating your own IoT 
devices.  I will be available if

02:42:04.376 --> 02:42:08.530
 you have any questions, and if 
you are on your way out

02:42:12.647 --> 02:42:16.801
, you can look at your own 
device yourself. 

02:42:16.802 --> 02:42:18.879
So, thank you very much.
(Applause). 

02:47:24.292 --> 02:47:26.795
Test.

03:05:47.895 --> 03:05:52.534
EWA: Hello, everyone, my name is
 Ewa Gasperowicz.  I'm a 

03:05:52.535 --> 03:05:56.711
developer engineer at Google.  
And I'm very happy to see you 

03:05:56.712 --> 03:06:00.885
today and especially in the 
beautiful city of Krakow which 

03:06:00.886 --> 03:06:02.956
I'm very proud of.  So welcome.
[ Applause ]

03:06:05.040 --> 03:06:09.232
My intention today is to shed 
some light on the process of 

03:06:09.233 --> 03:06:13.391
transforming an existing Website
 into a progressive web op.  We 

03:06:13.392 --> 03:06:17.558
and my team recently went 
through a few such processes.  

03:06:17.559 --> 03:06:21.702
And I would like to share with 
you some of the things we found 

03:06:21.703 --> 03:06:30.008
out on the way.
Probably by now you've heard a 

03:06:30.009 --> 03:06:34.181
little bit about progressive web
 apps.  The notion of PWAs is 

03:06:34.182 --> 03:06:36.261
making rounds in the industry.  
And if you have been to a 

03:06:36.262 --> 03:06:40.381
session about PWA in the morning
 -- have you been?  Plenty of 

03:06:40.382 --> 03:06:48.745
people.  You probably know all 
of them by now.  But even with 

03:06:48.746 --> 03:06:50.837
that, progressive web apps are 
experiences that combine the 

03:06:50.838 --> 03:06:57.072
best of the web and the best of 
the apps.  They are web 

03:06:57.073 --> 03:07:01.227
experiences, which means they 
have the wonderful reach of the 

03:07:01.228 --> 03:07:05.367
web.  There is no installation 
and every new experience is just

03:07:05.368 --> 03:07:09.504
 one click away.
At the same time, they are used 

03:07:09.505 --> 03:07:15.740
to extend the capabilities of 
modern apps.  It means they are 

03:07:15.741 --> 03:07:19.884
fast and don't wait for the user
 to load or react.  They are 

03:07:19.885 --> 03:07:21.955
integrated, which means they 
feel like a natural part of your

03:07:24.033 --> 03:07:28.168
 device.  They are variable, 
which means they load and 

03:07:28.169 --> 03:07:30.255
operate no matter the 
circumstances.  And they are 

03:07:30.256 --> 03:07:34.416
engaging, which means they give 
you pleasure from using them.

03:07:34.417 --> 03:07:42.738
This all sounds very new and 
very exciting.  But is it 

03:07:42.739 --> 03:07:46.873
really?  Some years back when I 
first got my hands on a 

03:07:46.874 --> 03:07:53.097
smartphone and started to browse
 the web, I totally expected it 

03:07:53.098 --> 03:07:55.197
to work just like on  desktop.  
My expectation was that if I 

03:07:55.198 --> 03:07:59.340
visit a URL, it actually will 
load, right?  That's not too 

03:07:59.341 --> 03:08:05.583
much to ask.  And I expected it 
to load quickly within my 

03:08:05.584 --> 03:08:09.739
attention span.  And keep in 
mind that for people like me -- 

03:08:09.740 --> 03:08:13.909
people like me don't want to get
 stuck on the leading screen 

03:08:13.910 --> 03:08:18.054
forever.  If for people like me,
 the "Forever" usually means 30 

03:08:18.055 --> 03:08:22.185
seconds.  That's the reality we 
live in.  30 seconds is already 

03:08:22.186 --> 03:08:26.333
forever in mobile.  I wanted it 
to work fast.  I wanted it to 

03:08:26.334 --> 03:08:30.475
work smoothly so I could enjoy 
using the app.  And I wanted to 

03:08:30.476 --> 03:08:34.615
have an easy way to access the 
content and be fully immersed in

03:08:34.616 --> 03:08:36.692
 the experience.
So those expectations are pretty

03:08:36.693 --> 03:08:44.992
 old.  It's not anything new to 
expect your Website to work 

03:08:44.993 --> 03:08:51.272
really well just in the way we 
describe progressive web apps.  

03:08:51.273 --> 03:08:57.526
So why do we even introduce this
 concept of progressive web apps

03:08:57.527 --> 03:09:01.659
 as a new concept if all we want
 to talk about are actually 

03:09:01.660 --> 03:09:05.810
Websites just done so well that 
the user has ever pleasure from 

03:09:05.811 --> 03:09:14.170
using it?  We use progressive 
web app notion to build a mental

03:09:14.171 --> 03:09:16.263
 model and to communicate better
 about our expectations towards 

03:09:16.264 --> 03:09:22.470
the modern web.  It just makes 
it easier for us to wrap our 

03:09:22.471 --> 03:09:28.725
heads around.  It also allows us
 to effectively communicate the 

03:09:28.726 --> 03:09:30.837
 expectations and the new 
possibilities that are coming to

03:09:30.838 --> 03:09:37.091
 the web.  And by talking about 
PWA, we can encode those 

03:09:37.092 --> 03:09:41.274
expectations into didn't models.
  Here you can see three of the 

03:09:41.275 --> 03:09:45.446
models.  The first one is 
describing behaviors of a 

03:09:45.447 --> 03:09:49.636
progressive web app.   Fast, 
integrated, variable and 

03:09:49.637 --> 03:09:53.827
engaging.  The second one is a 
PWA checklist.  If you just 

03:09:53.828 --> 03:09:55.904
Google it and go to the first 
result, you

03:09:55.905 --> 03:10:00.061
will see a checklist of features
 that you can pay attention to 

03:10:00.062 --> 03:10:02.126
in order to enable 
progressiveness in your app.  

03:10:02.127 --> 03:10:10.521
And finally, we encode a set of 
tools in a tool called 

03:10:10.522 --> 03:10:14.685
Lighthouse.  Lighthouse can 
audit the Website and give a 

03:10:14.686 --> 03:10:16.785
report how progressive or not 
progressive it is.

03:10:16.786 --> 03:10:20.972
So these are three different 
models, three different formats 

03:10:20.973 --> 03:10:25.156
of describing a progressive web 
app, but actually the notion is 

03:10:25.157 --> 03:10:29.302
the same.  I'm going to use 
different tools like this today 

03:10:29.303 --> 03:10:33.483
to talk about progressiveness 
and thousand achieve it on your 

03:10:33.484 --> 03:10:35.570
own Website.
Okay.  Getting from a Website to

03:10:37.668 --> 03:10:41.802
 a progressive web app is a 
process.  It looks roughly like 

03:10:41.803 --> 03:10:48.041
this.  As most of the projects, 
it starts with a thought -- an 

03:10:48.042 --> 03:10:54.282
idea -- right?  In my case, it's
 coffee, so here you go.  We 

03:10:54.283 --> 03:10:58.426
start with coffee.  And by 
drinking coffee, you can also 

03:10:58.427 --> 03:11:00.503
ponder about the scope of the 
project.  About the things you 

03:11:00.504 --> 03:11:04.667
want to achieve.  After that, 
once you're done with your 

03:11:04.668 --> 03:11:10.910
coffee, you can go and analyze 
your Website to understand your 

03:11:10.911 --> 03:11:15.093
starting point.  You need to 
have a reference point once 

03:11:15.094 --> 03:11:19.275
you're done implementing PWA 
features to know how you do.  

03:11:19.276 --> 03:11:23.454
Next step is to prioritize.  And
 the truth is, we rarely have 

03:11:23.455 --> 03:11:29.673
the resources to implement all 
of the stuff at once, right?  

03:11:29.674 --> 03:11:33.851
And the cool thing about PWA is 
that it's a modular concept.  

03:11:33.852 --> 03:11:38.042
It's not an emerging technology.
  You can actually pick and 

03:11:38.043 --> 03:11:42.234
choose what deployment and in 
what order.  I'm going to talk a

03:11:42.235 --> 03:11:46.383
 little bit about that.  You 
should set your user base and 

03:11:46.384 --> 03:11:50.562
your business needs.  So always 
talk to your stakeholders

03:11:50.563 --> 03:11:54.749
while prioritizing PWA features.
Then you should prepare your 

03:11:54.750 --> 03:11:58.939
tools.  Every job is easier when
 you choose the right tools to 

03:11:58.940 --> 03:12:07.254
perform it.  Finally, you can 
just execute your plan and 

03:12:07.255 --> 03:12:09.363
implement the features.  I'll 
talk about some issues you can 

03:12:09.364 --> 03:12:15.624
encounter at this step.  It's a 
broad topic and by no means can 

03:12:15.625 --> 03:12:19.767
I be exhaustive here.  At the 
end there is sometimes an 

03:12:19.768 --> 03:12:21.822
overlooked step.  The 
evaluation.  Measure and 

03:12:21.823 --> 03:12:26.016
evaluate.  It gives you both a 
nice summary of how you did in 

03:12:26.017 --> 03:12:30.201
your migration from Websites to 
progressive web app, but it can 

03:12:30.202 --> 03:12:34.387
also be a very valuable starting
 point for your next iteration 

03:12:34.388 --> 03:12:38.583
on the project.  This is how the
 process looks like.  And we're 

03:12:38.584 --> 03:12:42.722
going to follow it throughout 
this presentation.  Okay.  So 

03:12:42.723 --> 03:12:48.989
while drinking our coffee, let's
 talk about the scope of PWA.  

03:12:48.990 --> 03:12:50.990
What this notion actually 
includes.

03:12:51.067 --> 03:12:53.159
We know the goal.  We want to 
deliver the delightful user 

03:12:53.160 --> 03:13:01.575
experience.  But what are the 
actual practical deliverables?  

03:13:01.576 --> 03:13:07.837
Usually when we talk about PWA, 
we talk about these three core 

03:13:07.838 --> 03:13:09.920
technologies first.  We talk 
about service worker and related

03:13:12.004 --> 03:13:14.100
 techniques like caching.  They 
allow you to offer your users an

03:13:16.185 --> 03:13:18.274
 offline experience.  But also 
they can improve reliability of 

03:13:18.275 --> 03:13:22.460
your app which can now work 
under the circumstances and also

03:13:24.554 --> 03:13:28.724
 positively influence the speed 
for your second-time visitors.  

03:13:28.725 --> 03:13:30.822
Push notifications allow you to 
send the user a message and 

03:13:30.823 --> 03:13:37.082
bring them back to your app or 
reengage them.  Add to home 

03:13:37.083 --> 03:13:43.329
screen allows you to make your 
app feel like a first-class 

03:13:43.330 --> 03:13:47.489
citizen on your mobile.  The 
user can install it to their 

03:13:47.490 --> 03:13:49.596
home screen and access it 
easily, making it easy for them 

03:13:49.597 --> 03:13:55.881
to go back to your app again.
And a lot of it is enabled by 

03:13:55.882 --> 03:14:00.025
HTTPS, which is a bottom line of
 a secure web experience.  I 

03:14:00.026 --> 03:14:04.192
like to call these three 
features a native parity core 

03:14:04.193 --> 03:14:06.278
because they actually allow us 
these days to do on the web the 

03:14:06.279 --> 03:14:10.500
same things that just recently 
were possible only on native 

03:14:10.501 --> 03:14:14.640
apps.  And while they make me 
super-excited about the future 

03:14:14.641 --> 03:14:16.720
of the web, I think there is 
much more to

03:14:20.849 --> 03:14:22.932
 progressive web apps than just 
the native priority.  Well, list

03:14:22.933 --> 03:14:27.089
 fill some of this white space. 
 Let's add the performance 

03:14:27.090 --> 03:14:31.276
factor.  I cannot stress enough 
how important it is to make your

03:14:31.277 --> 03:14:35.432
 site fast and performant.  
Preferably before you implement 

03:14:35.433 --> 03:14:37.517
service worker rules and

03:14:41.588 --> 03:14:43.709
 add to home screen.  A lot of 
techniques like optimizing your 

03:14:43.710 --> 03:14:49.996
assets, especially images, a 
docking script, and making good 

03:14:49.997 --> 03:14:54.186
use of browser cache.  Getting 
this part right is especially 

03:14:54.187 --> 03:14:56.293
important for your  first-time 
visitors who do not have a 

03:14:56.294 --> 03:15:00.484
service worker yet or are on 
browsers that don't fully 

03:15:00.485 --> 03:15:04.629
support it yet.  They have to 
rely on the network

03:15:04.630 --> 03:15:10.869
in order to get to your site, so
 by making it more performant by

03:15:10.870 --> 03:15:15.043
 using different techniques, you
 make life easier for them as 

03:15:15.044 --> 03:15:19.227
well.
As a matter of fact, going for 

03:15:19.228 --> 03:15:21.307
PWA features is, in general, a 
very good audit opportunity.  

03:15:21.308 --> 03:15:27.541
Not only for performance issues,
 but also for UX issues and for 

03:15:27.542 --> 03:15:31.696
other problems with your site.  
It is crucial to make your 

03:15:31.697 --> 03:15:35.892
Website of generally good 
quality before adding the 

03:15:35.893 --> 03:15:40.042
additional complexity of PWA 
features.  I personally call it 

03:15:40.043 --> 03:15:44.224
PWA readiness.  Especially if 
you plan to implement offline 

03:15:44.225 --> 03:15:48.376
down the line, you need to be 
respectful of user resources 

03:15:48.377 --> 03:15:52.556
like bandwidth and memory.  And 
you don't want to push through 

03:15:52.557 --> 03:15:58.803
the cache a bloated Website.  
Similarly, you don't want to 

03:15:58.804 --> 03:16:00.866
send push notifications to the 
user only for him to come back 

03:16:00.867 --> 03:16:05.019
to your site and discover he can
 not perform the action he was 

03:16:05.020 --> 03:16:09.175
asked to do because your forms 
are convoluted or are not 

03:16:09.176 --> 03:16:13.318
accessible, right?  So first 
reck to fix basic issues with 

03:16:13.319 --> 03:16:19.519
your site and only then will we 
move on to the PWA features.

03:16:19.520 --> 03:16:25.742
All right.  Our site is PWA 
ready, it's  performant, we 

03:16:25.743 --> 03:16:29.921
already have an idea how to 
implement service worker, push 

03:16:29.922 --> 03:16:34.072
and add to home screen.  Is this
 all we need to care about?  The

03:16:34.073 --> 03:16:36.177
 web is always evolving.  And 
only recently two features where

03:16:36.178 --> 03:16:42.423
 were added to the platform: 
credentials management and 

03:16:42.424 --> 03:16:46.632
payment.  I'm sure there will be
 more APIs coming that will make

03:16:46.633 --> 03:16:50.810
 your user experience even 
better on your Website.  So you 

03:16:50.811 --> 03:16:54.955
always need to keep an open mind
 about what's coming and what 

03:16:54.956 --> 03:17:01.227
you can use in your projects.
Finally, all of this is nothing 

03:17:01.228 --> 03:17:09.584
if you don't top it off with a 
great UX.  Good UX, engagement, 

03:17:09.585 --> 03:17:11.649
and without it you might find 
the gain from implementing all 

03:17:11.650 --> 03:17:15.817
the underlying features is less 
than expected.  Just as I 

03:17:15.818 --> 03:17:19.978
described with the push all of 
the service worker.  So always 

03:17:19.979 --> 03:17:24.168
make sure that all of these 
features are tied by a nice and 

03:17:24.169 --> 03:17:26.243
smooth UX.
Finally, it's also a great 

03:17:26.244 --> 03:17:30.381
comfort and a good practice to 
make decisions based on data.  

03:17:30.382 --> 03:17:36.598
For this, you need to measure 
things.  Both before and after 

03:17:36.599 --> 03:17:40.743
the implementation of the PWA 
feature.  Actually throughout 

03:17:40.744 --> 03:17:46.979
the whole process.  So that's 
the full scope -- in my opinion 

03:17:46.980 --> 03:17:49.044
-- of PWA functions.  It's much 
more than just the service 

03:17:49.045 --> 03:17:53.206
worker, right?  These are all 
the areas that you should take 

03:17:53.207 --> 03:17:59.435
into account or at least think 
about when investigating how to 

03:17:59.436 --> 03:18:05.665
approach adding PWA features to 
your site.  That's a big chart 

03:18:05.666 --> 03:18:09.832
and a lot to digest and quite a 
lot of steps.  How do you 

03:18:09.833 --> 03:18:14.002
implement it?  One at a time.  
So let's start.

03:18:14.003 --> 03:18:16.101
With our coffee, we understand 
the scope of our project.  Let's

03:18:16.102 --> 03:18:22.332
 actually start it.  We start 
with analyzers.  First you need 

03:18:22.333 --> 03:18:26.517
to audit the Website in order to
 understand the current state of

03:18:26.518 --> 03:18:34.865
 the app.  And in order to do 
that, we provide a very good  

03:18:34.866 --> 03:18:41.119
tool -- Lighthouse.  Lighthouse 
is for web diagnostics.  It's a 

03:18:41.120 --> 03:18:45.282
Chrome extension that allows you
 to measure how close your web 

03:18:45.283 --> 03:18:49.418
app is to a progressive web app.
  When you start the  extension 

03:18:49.419 --> 03:18:51.513
-- Lighthouse -- and run your 
Website through it, it gives you

03:18:51.514 --> 03:18:55.723
 back a score and a report that 
summarizes the state of your app

03:18:55.724 --> 03:19:01.935
 for you.  This is how the 
report -- average report might 

03:19:01.936 --> 03:19:04.021
look, right?  There are 
different areas where you need 

03:19:04.022 --> 03:19:10.310
to pay attention to.  And there 
is also a long list with 

03:19:10.311 --> 03:19:14.474
explanations why your Website 
got this score and not another. 

03:19:14.475 --> 03:19:18.631
 Together with the links of 
thousand make things better.  

03:19:18.632 --> 03:19:24.908
Apart from being a diagnostic 
tool, it's also a very good 

03:19:24.909 --> 03:19:26.983
educational tool.  Just by 
checking reports on your 

03:19:26.984 --> 03:19:29.062
Website, you can
learn a lot about how you can 

03:19:29.063 --> 03:19:31.139
make this Website better.
One feature I wanted to pull out

03:19:31.140 --> 03:19:35.310
 was the share button in the top
 right corner.  Apart from 

03:19:35.311 --> 03:19:39.463
sharing, it allows you to save 
this report in JSON format.  I 

03:19:39.464 --> 03:19:41.526
really encourage you to save 
your report before you start any

03:19:43.613 --> 03:19:47.741
 projects.  Because it provides 
you a benchmark and a reference 

03:19:47.742 --> 03:19:53.980
point that you can compare to 
once your project finishes.

03:19:53.981 --> 03:19:58.139
Of course, Lighthouse is not the
 only tool.  There are other 

03:19:58.140 --> 03:20:02.285
ones.  And most of them actually
 also allow you to save the data

03:20:04.371 --> 03:20:10.646
 somewhere.  So if you have only
 15 minutes to analyze your 

03:20:10.647 --> 03:20:12.750
site, record and save the 
results from the tools mentioned

03:20:14.821 --> 03:20:18.998
 above.  Lighthouse, the 
security panel in Chrome  

03:20:18.999 --> 03:20:21.079
DevTools, page

03:20:25.159 --> 03:20:27.159
spied insights, web

03:20:31.276 --> 03:20:35.454
 webpage test.  It will help you
 after implementation.  We 

03:20:35.455 --> 03:20:37.540
analyzed the Website and know 
exactly how it performs in 

03:20:37.541 --> 03:20:43.809
different areas.  Now it's time 
to prioritize.

03:20:43.810 --> 03:20:45.928
This is all the areas I 
mentioned you should take into 

03:20:45.929 --> 03:20:50.084
account.  So the question is, 
where to start?  I would say, 

03:20:50.085 --> 03:20:52.085
start at

03:20:54.173 --> 03:20:58.323
 the beginning.  Ensure PWA 
readiness.  No amount of PWA 

03:20:58.324 --> 03:21:02.476
features will solve unresponsive
 clutter or a janky Website.  So

03:21:02.477 --> 03:21:06.648
 before you add new complexity, 
you want your site to be as 

03:21:06.649 --> 03:21:10.809
lean, smooth, working and 
optimized as reasonably 

03:21:10.810 --> 03:21:14.961
possible.  In particular, based 
on your outcome, of course, 

03:21:14.962 --> 03:21:19.110
because each site differs, you 
might look into areas like 

03:21:19.111 --> 03:21:25.393
optimizing images.  Is there a 
gain?  Remove unnecessary code. 

03:21:25.394 --> 03:21:31.659
 Leverage browser caching before
 even switching to service 

03:21:31.660 --> 03:21:35.814
workers.  Avoid blocking code.  
And divide big, monolithic 

03:21:35.815 --> 03:21:39.979
JavaScript into smaller chunks 
if adequate for your Website.  

03:21:39.980 --> 03:21:42.051
These are common things that are
 very well known.  But, you 

03:21:42.052 --> 03:21:48.335
know, as your Website evolves 
over time, sometimes they're 

03:21:48.336 --> 03:21:50.415
overlooked and they kind of go 
offtrack.

03:21:50.416 --> 03:21:56.692
So going for PWAs is actually 
good at the moment to stop for a

03:21:56.693 --> 03:22:00.873
 moment, audit them again and 
fix the issues if your encounter

03:22:00.874 --> 03:22:05.087
 any.  Let me show you an 
example.  Sometime ago I was 

03:22:05.088 --> 03:22:11.370
working on a  Women 
Techmakers.org site.  I was 

03:22:11.371 --> 03:22:15.519
preparing it for some upcoming 
PWA features.  Here you can see 

03:22:15.520 --> 03:22:19.704
 some -- here you can see the 
network panel of the Chrome 

03:22:19.705 --> 03:22:25.971
Devtools.  What I did here, I 
sorted by size.  And focusing 

03:22:25.972 --> 03:22:32.236
only on the very top of the list
, you can find the best targets 

03:22:32.237 --> 03:22:38.456
for optimization.  Here the two 
biggest files were the API file 

03:22:38.457 --> 03:22:42.637
and the hero image you can see 
on the home page.  The question 

03:22:42.638 --> 03:22:47.360
was, how to optimize those?  
Start with the hero image.  It's

03:22:47.361 --> 03:22:51.514
 a hero image.  It needs to be 
as big as Vueport, but not 

03:22:51.515 --> 03:22:55.660
bigger than that.  So I created 
other versions of the file.  I 

03:22:55.661 --> 03:22:59.813
saved the medium and small I 
thinks.  I added a few break 

03:22:59.814 --> 03:23:08.189
points to my  CSS.  And as an 
outcome on the page, I got a 21%

03:23:10.252 --> 03:23:14.433
 gain of rate of the images on 
that site.  And this all took 

03:23:14.434 --> 03:23:16.522
maybe six minutes all
together to perform.  And this 

03:23:16.523 --> 03:23:24.863
21% gain -- just by optimizing 
one image.  Really small 

03:23:24.864 --> 03:23:29.044
improvements can lead to big 
gains in this area.  Similarly, 

03:23:29.045 --> 03:23:33.210
I was able to replace heavy 
assets with simpler ones.  

03:23:33.211 --> 03:23:37.358
Previously we used the player 
API for video on the page.  

03:23:37.359 --> 03:23:43.590
Which, today, is actually 
possible to do a simple iFrame 

03:23:43.591 --> 03:23:47.757
with the correct configuration 
to run the video.  So I replaced

03:23:47.758 --> 03:23:56.104
 it with the i frame, and the 
whole 400 kilobytes

03:23:58.193 --> 03:24:00.279
 were deleted.  It's one line of
 code.  We realized we didn't 

03:24:00.280 --> 03:24:06.536
use the full extent of the 
Logstash library, just a few 

03:24:06.537 --> 03:24:12.809
functions.  Replace with the 
core, and 20 kilobytes down -- 

03:24:12.810 --> 03:24:16.970
it's not a great deal amount of 
download data, but those small 

03:24:16.971 --> 03:24:21.137
gains do add up.
Finally, we started to leverage 

03:24:21.138 --> 03:24:27.384
browser caching better.  In the 
previous version of the site, we

03:24:27.385 --> 03:24:31.556
 were caching our assets -- 
sorry.  We were  versioning our 

03:24:31.557 --> 03:24:33.632
assets by the build version.  
This means that with each build 

03:24:33.633 --> 03:24:37.776
of our site this number changed 
and the name of the file 

03:24:37.777 --> 03:24:41.958
changed.  Which means the 
browser would need to download 

03:24:41.959 --> 03:24:46.135
it again, even if this 
particular asset did not change.

03:24:46.136 --> 03:24:50.293
  Just because the overall build
 for the site changed.  So we 

03:24:50.294 --> 03:24:56.554
switched to the content-based 
caching instead.  Now only if 

03:24:56.555 --> 03:25:00.723
the content changes we change 
the hash and therefore the file 

03:25:00.724 --> 03:25:02.817
name.  And this way we can 
optimize the browser caching.  

03:25:02.818 --> 03:25:09.074
This allows the user to download
 much more resources than in the

03:25:09.075 --> 03:25:13.237
 previous use case.  So you can 
see all of those changes were 

03:25:13.238 --> 03:25:17.369
pretty simple and were very easy
 to achieve.  And they did add 

03:25:17.370 --> 03:25:23.699
up to big gains on our Website. 
 Once you are PWA ready, you 

03:25:23.700 --> 03:25:32.074
should ensure safety of your 
users.  We want to develop 

03:25:32.075 --> 03:25:34.151
great, progressive web apps in 
order to

03:25:34.152 --> 03:25:38.324
leverage the frictionless and 
accessible web out there.

03:25:38.325 --> 03:25:44.594
But the web is also dangerous.  
So keeping your users safe is 

03:25:44.595 --> 03:25:48.773
hugely important.  So I would go
 for HTTPS as one of the first 

03:25:48.774 --> 03:25:53.005
things you implement on your 
site if you go for a PWA.  Also,

03:25:53.006 --> 03:25:59.247
 a lot of new web APIs are 
actually requiring HTTPS to be 

03:25:59.248 --> 03:26:03.425
enabled on your site.  So it 
should be a natural step to 

03:26:03.426 --> 03:26:09.655
take.  Once your site is PWA 
secure, you can simply follow 

03:26:09.656 --> 03:26:13.842
your business need.  And this 
pretty much depends on your site

03:26:13.843 --> 03:26:15.925
 and your business.  For  
example, if user acquisition is 

03:26:15.926 --> 03:26:22.199
important for your business, you
 should focus on perf.  Because 

03:26:22.200 --> 03:26:26.405
performance site that loads 
quickly on the first visit 

03:26:26.406 --> 03:26:28.496
allows you to gain some more 
users.

03:26:28.497 --> 03:26:36.849
If you have a huge bounce rate 
because of unperformant site, 

03:26:36.850 --> 03:26:41.027
users don't see it in the first 
place.  It so for user 

03:26:41.028 --> 03:26:45.223
acquisition, focus on perf.  If 
you are focusing on users in low

03:26:47.330 --> 03:26:51.498
 connectivity areas, then you 
focus on offline.  Implementing 

03:26:51.499 --> 03:26:55.669
service worker and the offline 
experience.  This is where the 

03:26:55.670 --> 03:26:59.822
big gain for your users is.
User retention, focus on push 

03:26:59.823 --> 03:27:04.025
and add to home screens.  This 
allows you reengage users in 

03:27:04.026 --> 03:27:08.218
your experience.  And you can 
pick and choose because PWA is 

03:27:08.219 --> 03:27:12.390
modular and you can see which 
areas benefit your business best

03:27:14.467 --> 03:27:16.536
.
All right.  Now we are choosing 

03:27:16.537 --> 03:27:20.707
the tools.  And there is a lot 
of tools out there, right?  

03:27:20.708 --> 03:27:27.007
There is a lot of tools.  There 
are some starter packs and 

03:27:27.008 --> 03:27:29.099
generators for different 
frameworks and libraries that 

03:27:29.100 --> 03:27:33.293
allow you to build a progressive
 web app from scratch.  But I 

03:27:33.294 --> 03:27:37.433
want to focus on migrating an  
existing Website to a PWA.  

03:27:37.434 --> 03:27:41.647
That's why I will give a 
shoutout to one library in 

03:27:41.648 --> 03:27:45.832
particular.  It's the  Workbox 
library.  When developing 

03:27:45.833 --> 03:27:52.046
offline  experience, things 
might get a little bit fiddley. 

03:27:52.047 --> 03:27:54.132
 There is also a lot of 
boilerplate because many  tasks 

03:27:54.133 --> 03:27:58.268
are simply repetitive -- like 
caching.  So my advice is, don't

03:27:58.269 --> 03:28:04.529
 do things by hand.  They might 
bite you.  Remove both stress 

03:28:04.530 --> 03:28:10.760
and bowler plate with  Workbox. 
 And luckily at quarter to 3:00 

03:28:10.761 --> 03:28:16.995
we have a wonderful workshop for
 you for Website with PWA with  

03:28:16.996 --> 03:28:21.158
Workbox on the floor.  If you 
want to see the ins and out you 

03:28:21.159 --> 03:28:23.255
can get from the library for 
your Website, check out that 

03:28:23.256 --> 03:28:27.399
training.
Yay.  Finally.  We go to the 

03:28:27.400 --> 03:28:29.469
point where we can implement our

03:28:33.559 --> 03:28:37.755
 PWA features.  This is the 
hardest part because it differs 

03:28:37.756 --> 03:28:39.822
a lot from project to project, 
right?  So instead, let me share

03:28:41.900 --> 03:28:48.158
 with you an example of how we 
solved an offline dilemma in the

03:28:48.159 --> 03:28:56.507
 tech maker's site.  It helps 
you solve PWA features in this 

03:28:56.508 --> 03:29:02.794
case, offalone.  This is a Women
  Techmakers slide.  It's a 

03:29:02.795 --> 03:29:06.966
beautiful site.  A visual 
experience.  Lots of images.  

03:29:06.967 --> 03:29:11.140
Really, really nice inside.  And
 I was supposed to implement 

03:29:11.141 --> 03:29:15.322
offline experience for it.  If I
 wanted to save all of this to 

03:29:15.323 --> 03:29:19.495
cache, that would be very, very 
heavy.  So  caching all the 

03:29:19.496 --> 03:29:21.602
images was rather a no-go.
How about no

03:29:25.709 --> 03:29:29.869
 images?  Well, the site looks 
kind of ugly.  But it's also 

03:29:29.870 --> 03:29:34.034
unusable.  I can't go to a 
different sub page because the 

03:29:34.035 --> 03:29:38.223
menu button is  missing.  It's 
unusable.  Therefore caching no 

03:29:38.224 --> 03:29:42.385
 images was also a no-go.  How 
do we find a middle point?  How 

03:29:42.386 --> 03:29:44.491
do we negotiate this?  Well, I 
took a different look at the 

03:29:44.492 --> 03:29:50.763
Website to really understand its
 structure.  I divided images by

03:29:50.764 --> 03:29:57.054
 function.  Let's take a look.  
The yellow images are the 

03:29:57.055 --> 03:30:01.224
navigational and action images. 
 They are there so the user can 

03:30:01.225 --> 03:30:05.384
navigate and perform activities 
on our Website.  Therefore, 

03:30:05.385 --> 03:30:09.547
they're crucial for the site to 
be fully functional.  Then the 

03:30:09.548 --> 03:30:11.602
red ones are branding and 
priority.  They allow you to 

03:30:11.603 --> 03:30:15.797
connect with your user.  They're
 very important

03:30:18.835 --> 03:30:22.999
.  The end user recognizes which
 suit they're looking at.  

03:30:23.000 --> 03:30:27.218
They're  high-priority images.  
The blue ones are decorative.  

03:30:27.219 --> 03:30:29.319
They make the site look nice.  
They add to the experience.  But

03:30:29.320 --> 03:30:33.469
 if they're missing, they don't 
break anything. 

03:30:33.470 --> 03:30:39.686
The site is less rich, but still
 usable.  And the third type of 

03:30:39.687 --> 03:30:43.854
picture, the green ones, I call 
informative.  It looks nice and 

03:30:43.855 --> 03:30:48.075
adds to the graphical layer of 
the site, but they also convey 

03:30:48.076 --> 03:30:50.169
some message within them.  So 
how do we deal with those four 

03:30:50.170 --> 03:30:56.432
different types of images?
Well, for navigation and action 

03:30:56.433 --> 03:31:02.693
images, I just inlined them with
 SVG.  They're usually small, so

03:31:02.694 --> 03:31:06.870
 it's easy to do.  And if you 
embed them in your cached HTML, 

03:31:06.871 --> 03:31:11.057
they're going to be there.  
Problem solved.  Don't need a 

03:31:11.058 --> 03:31:13.159
caching strategy with them 
because if HTML is there, your 

03:31:13.160 --> 03:31:19.389
images are there as well.
Now, branding and priority, I 

03:31:19.390 --> 03:31:23.586
want always -- I want for them 
to always be there because 

03:31:23.587 --> 03:31:27.741
they're important for me because
 of my business case.  So I 

03:31:27.742 --> 03:31:31.922
precached them.  When a user 
enters the site, in this case I 

03:31:31.923 --> 03:31:38.167
precached them with the workbox 
library.  And they are important

03:31:38.168 --> 03:31:42.350
 and without them, the 
experience would be broken.  

03:31:42.351 --> 03:31:48.581
Now, decorative, I employed the 
run time cache strategy.  As the

03:31:48.582 --> 03:31:52.744
 user navigates through the site
 and online, I download the 

03:31:52.745 --> 03:31:56.913
pictures and save to the cache. 
 There is high likelihood that 

03:31:56.914 --> 03:31:59.015
the user will want to go back to
 the sites later on when they're

03:32:01.099 --> 03:32:03.180
 offline.  But if the user 
doesn't venture to some parts of

03:32:03.181 --> 03:32:09.432
 my site, I just go and fall 
back.  A place holder, right?  

03:32:09.433 --> 03:32:13.591
The site maybe looks less rich, 
but it's usable and I didn't 

03:32:13.592 --> 03:32:17.758
blow the cache with a lot of 
decorative  images.

03:32:17.759 --> 03:32:21.905
Now, informative images are kind
 of fancy ones in the slot.  

03:32:21.906 --> 03:32:26.074
Because here I use the full 
power of the service worker.  

03:32:26.075 --> 03:32:30.229
Service worker is just a 
JavaScript file, which means you

03:32:30.230 --> 03:32:36.488
 can put a lot of logic into it.
  Here I want not save all to 

03:32:36.489 --> 03:32:40.696
the user cache, but still convey
 the message, who are the 

03:32:40.697 --> 03:32:42.783
sponsors?  So instead of the 
logos, I generate the images on 

03:32:42.784 --> 03:32:49.066
the fly in service worker by 
using the alt text from the 

03:32:49.067 --> 03:32:53.236
image tag, right?  So instead of
  saving all the images, I 

03:32:53.237 --> 03:32:57.389
generate them on the fly to not 
have an image,

03:33:01.467 --> 03:33:03.535
 but still convey the message.  
This is an example of how you 

03:33:03.536 --> 03:33:05.646
deal with images and for 
different strategies.  The 

03:33:05.647 --> 03:33:11.870
message I want to convey is that
 you should really look deeply 

03:33:11.871 --> 03:33:13.967
into the structure of your site 
and type of content you have and

03:33:13.968 --> 03:33:16.047
 try to divide it and come up 
with different strategies to 

03:33:16.048 --> 03:33:20.244
different parts of your company.
  And this way you can provide 

03:33:20.245 --> 03:33:26.492
the best user experience for 
your users while offline.

03:33:28.556 --> 03:33:30.634
Okay.  Once we implement 
everything, we need to evaluate 

03:33:30.635 --> 03:33:36.886
the site.  And this often is an 
overlooked step.  Remember when 

03:33:36.887 --> 03:33:41.056
I told you to save the  
snapshots of data from before 

03:33:41.057 --> 03:33:47.284
the implementation?  Well, now 
they come in handy.  You can go 

03:33:47.285 --> 03:33:53.576
again through the audit propose 
and record all the same traces 

03:33:53.577 --> 03:33:59.864
and record the outcome with the 
previous version.  Hopefully it 

03:33:59.865 --> 03:34:04.023
will give you a surge of joy as 
you see metrics improve on your 

03:34:04.024 --> 03:34:08.183
site.  However, there is one 
caveat.  Metrics are helpful, 

03:34:08.184 --> 03:34:12.340
but they're only metrics.  
Getting 100 on Lighthouse is 

03:34:12.341 --> 03:34:16.524
great.  I can assure you, it 
feels really good.  And it may 

03:34:16.525 --> 03:34:18.624
also help to convince your 
stakeholders about the impact 

03:34:18.625 --> 03:34:20.625
you achieved and

03:34:22.323 --> 03:34:26.457
 maybe get your project funding 
for the next dooration, but it 

03:34:26.458 --> 03:34:30.622
does not answer how users are 
finding your changes, right?

03:34:30.623 --> 03:34:32.723
And as a matter of fact PWA 
influences many areas of your 

03:34:32.724 --> 03:34:36.936
app.  It influences the UX.  For
 example, now you have to 

03:34:36.937 --> 03:34:39.030
consider a lot of offline 
scenarios.  For example, how 

03:34:39.031 --> 03:34:43.239
users will try to buy your 
product when they're in offline 

03:34:43.240 --> 03:34:49.505
mode.  It influences your 
workflow.  You need to add to 

03:34:49.506 --> 03:34:53.688
user's cache, and it's hard to 
do it through managing the 

03:34:53.689 --> 03:34:57.842
process manually.  Maybe invest 
in some build tools and into 

03:34:57.843 --> 03:35:04.089
your workflow optimization.  
Influences your measuring.  Now,

03:35:04.090 --> 03:35:08.275
 a lot of the interactions might
 happen offline.  You need to 

03:35:08.276 --> 03:35:14.527
implement offline analytics.  
And it might influence your SEO,

03:35:14.528 --> 03:35:16.605
 so You should check if nothing 
changed there or things were 

03:35:16.606 --> 03:35:24.970
even improved on the SEO part.
So that's the process.

03:35:27.072 --> 03:35:29.124
  That's how we got from the 
Website to PWA.  First we 

03:35:29.125 --> 03:35:31.236
analyzed the Website, then we 
prioritize

03:35:35.301 --> 03:35:39.501
ed and what we wanted to focus 
on.  We get a set of tools to 

03:35:39.502 --> 03:35:43.738
perform those actions.  Then we 
implement our changes.  And then

03:35:43.739 --> 03:35:50.049
 we evaluate it.  An important 
thing is, this can be an 

03:35:50.050 --> 03:35:54.222
iterative process, right?  With 
each ending point where you 

03:35:54.223 --> 03:35:58.383
measure can also be a starting 
point for the next iteration of 

03:35:58.384 --> 03:36:02.529
your Website.  The web 
development and your Websites 

03:36:02.530 --> 03:36:04.589
will develop over time as well, 
and your users will change over 

03:36:04.590 --> 03:36:08.732
time, so you need to keep going 
back and checking what can be 

03:36:08.733 --> 03:36:10.815
done to provide an experience 
for them.

03:36:10.816 --> 03:36:17.049
Luckily, you're not alone in 
this road for perfection of your

03:36:17.050 --> 03:36:21.241
 Website.  There is a lot of 
resources.  And a lot of them 

03:36:21.242 --> 03:36:27.448
are available today at this 
conference.  There is Lighthouse

03:36:27.449 --> 03:36:31.613
 too.  You can use it both as a 
Chrome extension and online.  

03:36:31.614 --> 03:36:35.797
And there is one real life 
Lighthouse on the first  floor, 

03:36:35.798 --> 03:36:42.047
so feel free to give it a try.  
There are site clinics where you

03:36:42.048 --> 03:36:46.224
 can look at the healthiness of 
your site with Googlers.  We 

03:36:46.225 --> 03:36:48.303
have some office hours.  If you 
have questions after this 

03:36:48.304 --> 03:36:52.432
session or want to talk to me, 
I'll be present in the office 

03:36:52.433 --> 03:36:54.517
hours area on the first floor 
after this session.  There is 

03:36:54.518 --> 03:37:02.817
the training, quarter to 3:00, 
that works through Workbox.  And

03:37:02.818 --> 03:37:06.972
 the progressive section on 
developers.google.com that I 

03:37:06.973 --> 03:37:11.152
encourage you to check out.  
Thank you very much.  I hope you

03:37:11.153 --> 03:37:17.378
 enjoyed the session, and see 
you around.

03:37:17.379 --> 03:37:19.379
[ Applause ]

03:50:49.133 --> 03:50:53.601
&gt;&gt; Hello, I'm Ben Morss, a 
developer advocate at Google.  

03:50:53.602 --> 03:50:59.803
I'm here to talk about PWA -- 
progressive web apps.  If you 

03:50:59.804 --> 03:51:03.961
have seen Sam's talk, ewa's 
talk, you have heard this use.  

03:51:03.962 --> 03:51:10.177
And AMP, accelerated mobile 
pages.  I'm curious, who has 

03:51:10.178 --> 03:51:14.359
heard the acronym PWA before?  
All right. maybe two-thirds.  

03:51:14.360 --> 03:51:20.588
How about AMP?  Okay.  Very 
good.  In the context, not a 

03:51:20.589 --> 03:51:26.839
guitar amp.  They had amps back 
here.  This is the other kind of

03:51:28.910 --> 03:51:33.116
 AMP, accelerated mobile pages. 
 And PWA and AMP, putting them 

03:51:33.117 --> 03:51:37.238
together, how this is powerful, 
elegant and easy to do.  And 

03:51:37.239 --> 03:51:41.411
I'll show you an example of how 
to do this called the shadow 

03:51:41.412 --> 03:51:47.678
reader.
The first question is: why?  

03:51:47.679 --> 03:51:53.901
Progressive web apps are these 
immersive full-screen app-like 

03:51:53.902 --> 03:51:55.968
experiences on the web.  And 
accelerated mobile  pages are 

03:51:55.969 --> 03:52:02.202
best known for somewhat simpler 
kinds of pages.  Maybe for 

03:52:02.203 --> 03:52:06.347
publishers, maybe a way to get 
to Google's cache.  And kind of 

03:52:06.348 --> 03:52:10.505
a simplification of the web for 
performance reasons.  How do 

03:52:10.506 --> 03:52:14.646
these things fit together and 
why bother with this?  It's 

03:52:14.647 --> 03:52:18.804
because of what I call the web 
app dilemma.

03:52:18.805 --> 03:52:22.955
So let's go back about 18 years 
ago.  Back then web pages were 

03:52:22.956 --> 03:52:29.160
simple.  If there was any 
complexity, it was on the 

03:52:29.161 --> 03:52:35.387
backend.  Perl, maybe PHP making
  things happen.  Generating 

03:52:35.388 --> 03:52:41.587
HTML.  The frontend was just 
HTML.  Maybe some CSS -- which 

03:52:41.588 --> 03:52:45.742
was brand new back then -- and 
not a whole lot of this cute 

03:52:45.743 --> 03:52:47.816
language called JavaScript.  
JavaScript was not like a real 

03:52:47.817 --> 03:52:51.970
language, it was a toy language 
back then  used for little 

03:52:51.971 --> 03:52:54.066
things.  Remember this thing 
over here, you can move your 

03:52:54.067 --> 03:52:58.213
cursor over the button and it 
would change color.  That was 

03:52:58.214 --> 03:53:00.295
pretty cool.  That was 
JavaScript.  That was pretty 

03:53:00.296 --> 03:53:02.387
easy.
Today it's more complicated.  

03:53:02.388 --> 03:53:06.546
There's a lot to learn.  A lot 
of choices.  You can make it 

03:53:06.547 --> 03:53:12.778
very, very full-featured 
frontend web app with many  

03:53:12.779 --> 03:53:16.965
frameworks, JavaScript, it can 
get complicated.  There's down 

03:53:16.966 --> 03:53:19.035
sides to that.  This might be 
you if you're spending a lot of 

03:53:19.036 --> 03:53:23.232
time learning new technologies, 
maintaining a complicated app, 

03:53:23.233 --> 03:53:27.403
trying to follow all your 
callbacks, going through the  

03:53:27.404 --> 03:53:31.549
code, trying to do various 
tweaks to get things to perform 

03:53:31.550 --> 03:53:33.688
better.  And speaking of 
performance, unfortunately for 

03:53:33.689 --> 03:53:37.859
your convenience as a developer,
 the user pays a price.  So 

03:53:37.860 --> 03:53:44.136
notice how web apps have gotten 
bigger in the last six years.  

03:53:44.137 --> 03:53:48.325
Tripled  in size.  Images, 
video.  But also JavaScript has 

03:53:48.326 --> 03:53:52.482
gotten very, very big.  Do you 
have a site that has right now 

03:53:52.483 --> 03:53:58.696
15, 20, maybe 30 JavaScript 
files on it?  400K of 

03:53:58.697 --> 03:54:00.762
JavaScript?  Maybe some large 
frameworks that are loading 

03:54:00.763 --> 03:54:09.075
before anything else happens?   
Using up CPU and battery power? 

03:54:09.076 --> 03:54:13.237
 It takes a lot of
time for a good web app.  Was 

03:54:13.238 --> 03:54:17.410
thinking about this walking 
around the city.  This is a 

03:54:17.411 --> 03:54:19.496
picture I took in Krakow.  
There's music that's supposed to

03:54:19.497 --> 03:54:25.737
 be  playing.  There it is.  
Mozart.  Why am I playing Mozart

03:54:25.738 --> 03:54:29.901
 at a web developer's 
conference?  It reminded me of 

03:54:29.902 --> 03:54:38.202
the movie, Amadeus.  It reminded
 me of that.  I showed this 

03:54:38.203 --> 03:54:44.447
every year when I was a music 
teacher, otherwise they couldn't

03:54:44.448 --> 03:54:46.535
 stand classical music.  I was 
thinking about elegance and 

03:54:46.536 --> 03:54:52.754
beauty.  And it was quieter, and
 then louder and louder.  

03:54:52.755 --> 03:54:54.823
Elegant, beautiful things are 
important.  They endure.  

03:54:54.824 --> 03:54:59.006
Simplicity is good.  When things
 are simple, they're 

03:54:59.007 --> 03:55:03.148
maintainable for users.  
Elegance means fewer bugs.   In 

03:55:03.149 --> 03:55:09.398
five years, your code will still
 work.  Simplicity and elegance 

03:55:09.399 --> 03:55:11.489
matters.  Isn't one of the goals
 of life making something 

03:55:11.490 --> 03:55:15.671
beautiful?  This is a goal also 
of this PWA AMP pattern.  Making

03:55:18.331 --> 03:55:20.415
 things beautiful and simple and
 elegant again on the web.

03:55:20.416 --> 03:55:24.564
If web is too hard, can I make 
an app instead?  Wouldn't that 

03:55:24.565 --> 03:55:30.806
be easier?  If you saw Sam's 
talk, you would know all the 

03:55:30.807 --> 03:55:37.064
time is in major apps, Gmail, 
Facebook, what's app.  If you're

03:55:37.065 --> 03:55:41.235
 making an app, chances are 
small people will use it or 

03:55:41.236 --> 03:55:45.410
download it.  The average number
 of apps a user installed in a 

03:55:45.411 --> 03:55:49.574
month is zero.  So the web is 
pretty important on mobile 

03:55:49.575 --> 03:55:53.748
phones and will not go away any 
time soon.

03:55:53.749 --> 03:55:55.852
So make a simple Website.  
That's not going to work.  Users

03:55:55.853 --> 03:56:00.010
 expect something better today. 
 They want a real web app 

03:56:00.011 --> 03:56:04.196
experience.  What do we do?  
Like a baby, we can cry.  Or 

03:56:04.197 --> 03:56:08.367
maybe there's an easier way?  
Happy baby.  Is there one?  

03:56:08.368 --> 03:56:12.547
There's not.   Okay.  Thanks a 
lot, guys.  Wait, wait, wait.  I

03:56:12.548 --> 03:56:16.709
 have more slides to show.  I'm 
just kidding.  I think the 

03:56:16.710 --> 03:56:20.909
easier way here is PWA and AMP. 
 What is that?  PWA you have 

03:56:20.910 --> 03:56:25.078
seen before in talks today, 
provides app-like experience on 

03:56:25.079 --> 03:56:29.241
the web.  I won't go into this 
in detail.  You have seen this 

03:56:29.242 --> 03:56:33.380
before.  But things load quickly
, they're engaging as a good app

03:56:33.381 --> 03:56:35.478
 would be.  They're quick, users
 aren't waiting around, they 

03:56:35.479 --> 03:56:39.671
work offline.  All these things 
people expect from mobile phone 

03:56:39.672 --> 03:56:43.853
experiences like they're on 
messaging, like they're on 

03:56:43.854 --> 03:56:48.013
another app.  They want these 
things also from a Website.  A 

03:56:48.014 --> 03:56:52.161
fast, good experience.
So what is AMP?  Accelerated 

03:56:52.162 --> 03:56:56.350
mobile pages.  People think of 
it as a thing that was started 

03:56:56.351 --> 03:56:58.448
for publishers.  Most major 
publishers in the world use AMP 

03:56:58.449 --> 03:57:02.631
in some way or another.  But 
it's more than  that.  It's not 

03:57:02.632 --> 03:57:06.792
just for publishers.  It's not 
just a way to make simple, light

03:57:08.857 --> 03:57:13.009
 web pages or to get into 
Google's search AMP carousel, 

03:57:13.010 --> 03:57:17.178
it's a new pattern to make the 
web easier and simpler and 

03:57:17.179 --> 03:57:21.354
faster for users and also for 
all of you.

03:57:21.355 --> 03:57:25.510
What is AMP?  A brief summary.  
It's an ecosystem for fast, 

03:57:25.511 --> 03:57:29.670
beautiful responsive pages.  As 
you heard earlier today, there's

03:57:29.671 --> 03:57:33.832
 over 2 billion  pages on the 
web that use AMP.  Over a 

03:57:33.833 --> 03:57:37.994
million domains now use AMP.  
AMP helps enforce good 

03:57:37.995 --> 03:57:40.064
performance and good looks.  
It's basically a response to 

03:57:40.065 --> 03:57:44.216
bloat on the web.  It's making 
things simpler, easier again.S 

03:57:44.217 --> 03:57:48.359
it doesn't cover all cases, but 
it covers most cases.  Very few 

03:57:48.360 --> 03:57:54.571
web pages right now would lose 
that much if converted to AMP.  

03:57:54.572 --> 03:57:58.740
Even though the first thing up 
there, AMP allows you to write 

03:57:58.741 --> 03:58:04.975
no JavaScript.  No JavaScript at
 all.  A little pause.  Probably

03:58:04.976 --> 03:58:09.127
 some people are crying.  People
 are clapping.  Yes, you're 

03:58:09.128 --> 03:58:11.212
free!  You're  free.  You can 
still use JavaScript, but not on

03:58:11.213 --> 03:58:15.400
 an AMP page.  It's already 
there.  Because if you want 

03:58:15.401 --> 03:58:19.544
things that are interactive, 
that are easy to use.  You want 

03:58:19.545 --> 03:58:21.628
things like an image carousel 
where the images slide around on

03:58:21.629 --> 03:58:25.793
 the screen.  Users can't 
understand these things, but 

03:58:25.794 --> 03:58:29.947
they're popular.  Or a
video embedded or a menu -- all 

03:58:29.948 --> 03:58:34.093
come with AMP.  That's the 
second thing up there.  It's a 

03:58:34.094 --> 03:58:38.223
super-set with HTML.  Instead of
 custom web components that do 

03:58:38.224 --> 03:58:42.406
those things that don't come 
with HTML, but should.  HTML was

03:58:44.500 --> 03:58:50.752
 created for making documents, 
not complicated web Apps.  With 

03:58:50.753 --> 03:58:55.001
AMP, you get everything back 
from HTML.  You lose 

03:58:55.002 --> 03:58:57.063
flexibility, but you're coding 
less.  You can code other 

03:58:57.064 --> 03:59:01.228
places.  And if you love CSS, 
sorry to tell you this, it 

03:59:01.229 --> 03:59:07.446
restricts your CSS to 50K or 
less.  Which, honestly, is 

03:59:07.447 --> 03:59:11.586
enough formost pages out there. 
 Probably all pages.  The idea 

03:59:11.587 --> 03:59:15.772
behind all these things, no 
JavaScript web components and 

03:59:15.773 --> 03:59:22.031
less CSS is to make the pages 
faster.  So they tend to load on

03:59:22.032 --> 03:59:26.184
 3G connections in a second, 2 
seconds.  Which users like quite

03:59:26.185 --> 03:59:30.326
 a bit and which makes your 
companies money.  It's good.

03:59:30.327 --> 03:59:34.481
And don't forget the elegance 
thing as well.  Your pages -- 

03:59:34.482 --> 03:59:36.563
your code -- is more beautiful. 
 It's simpler.  You're not 

03:59:36.564 --> 03:59:40.740
trying to reinvent the wheel.  
The wheel is already there for 

03:59:40.741 --> 03:59:44.915
you as part of AMP.  This had 
sounds kind of hard, right?  

03:59:44.916 --> 03:59:49.065
I've got to learn two new 
things.  PWA and AMP?  I can't 

03:59:49.066 --> 03:59:53.232
do  that.  I don't have time.  
Actually, it's not as hard as it

03:59:53.233 --> 03:59:55.351
 sounds.
And to prove that, we have 

03:59:55.352 --> 03:59:59.513
created a simple example called 
the shadow reader.  Whenever I 

03:59:59.514 --> 04:00:05.761
say shadow, I'll say it like the
 up to face over here.  The 

04:00:05.762 --> 04:00:09.921
shadow reader.  Because I have 
no shame.  Let's say you work 

04:00:09.922 --> 04:00:11.990
for a major news publisher and 
you have a Website that's out 

04:00:11.991 --> 04:00:14.089
there.  But the boss knows that 
people want to use a web app.  

04:00:14.090 --> 04:00:20.315
They're sick of the Website.  
Stick of the pages.  He wants a 

04:00:20.316 --> 04:00:24.491
news  reader app.  So your 
assignment from this  

04:00:24.492 --> 04:00:26.565
stern-looking boss over here -- 
you're the person with the hat 

04:00:26.566 --> 04:00:32.856
-- is to make a web app out of 
existing web pages.  The site 

04:00:32.857 --> 04:00:37.022
already uses AMP.  So how do we 
do that?  How do we take things 

04:00:37.023 --> 04:00:41.202
that already exist, those AMP 
pages, and get those into a nice

04:00:43.289 --> 04:00:50.292
,  immersive progressive web 
experience?  Well, PWA with AMP 

04:00:50.293 --> 04:00:54.426
is your answer.  So why are AMPs
 useful in a progressive web app

04:00:54.427 --> 04:01:00.678
 context?  Let's describe ways 
that AMP can be used that hasn't

04:01:00.679 --> 04:01:04.852
 been used so far.  But starting
 to be used now and play on the 

04:01:04.853 --> 04:01:06.948
 strengths
of the web components library.  

04:01:06.949 --> 04:01:13.181
First, how AMP can be used as 
web components, second as rich 

04:01:13.182 --> 04:01:17.348
data.  And third, AMP pages can 
be portable,  embeddable content

04:01:17.349 --> 04:01:19.434
 units that you can embed in 
other pages thanks to the magic 

04:01:19.435 --> 04:01:25.669
of shadow DOM.
I love that name, shadow DOM.  

04:01:25.670 --> 04:01:29.822
First of all, AMP as web 
components.  This actually is 

04:01:29.823 --> 04:01:33.978
kind of obvious.  AMP is really 
a library of web components.  

04:01:33.979 --> 04:01:38.139
Here are some examples of those 
things over here.  Let's say you

04:01:38.140 --> 04:01:40.213
 want to make one of those 
lovely image sliders that users 

04:01:40.214 --> 04:01:44.385
tend to object to, but people 
love these things.  And there it

04:01:44.386 --> 04:01:48.534
 is.  That's an entire carousel.
  That's done.  So AMP carousel,

04:01:48.535 --> 04:01:52.698
 you must specify width and 
height.  The pages are laid out 

04:01:52.699 --> 04:01:56.838
in advance.  As they load, the 
pages shift around.  So all of 

04:01:56.839 --> 04:02:01.007
your dimensions for images, ads,
 everything else, are specified 

04:02:01.008 --> 04:02:03.094
in advance.  And there is a 
couple of images.  The AMP image

04:02:03.095 --> 04:02:09.335
 tag.  And you're done.  There 
it is.  Your carousel.  Things 

04:02:09.336 --> 04:02:11.404
lazy load.  It's all good.  
You're done.

04:02:13.496 --> 04:02:17.627
Number two, AMP as rich data.  
This is kind of a weirder idea, 

04:02:17.628 --> 04:02:21.793
but kind of a cool idea once you
 get the idea.  Idea.  It's a 

04:02:21.794 --> 04:02:28.013
good word to say several times 
in a row.  AMP as rich data.  

04:02:28.014 --> 04:02:32.163
Often when  making your web app,
 you have a shell and loading in

04:02:32.164 --> 04:02:38.440
 JSON and converting in JSON to 
HTML using template, some kind 

04:02:38.441 --> 04:02:40.563
of logic.  This can be a 
fragile, difficult process.  So 

04:02:40.564 --> 04:02:46.848
instead of doing that, you can 
use HTML itself as the data.  

04:02:46.849 --> 04:02:50.997
It's a rich data source that 
includes layout information, 

04:02:50.998 --> 04:02:55.149
includes components.  It's like 
a whole page layout.  It's kind 

04:02:55.150 --> 04:03:01.464
of like markdown steroids.  It's
 kind of this really powerful, 

04:03:01.465 --> 04:03:03.586
rich dataset.  So what I mean by
 that -- here's a typical 

04:03:03.587 --> 04:03:05.660
example.  Say you have an 
article on your web app that 

04:03:05.661 --> 04:03:11.891
you're making over  here, and 
they aren't very good.  You have

04:03:11.892 --> 04:03:16.037
 an article about that, usual 
data sources.  Data, whatever.  

04:03:16.038 --> 04:03:20.214
On the bottom here, maybe you 
have an image of a guitar.  

04:03:20.215 --> 04:03:22.308
Maybe you have H2, a link.  
Maybe you have an ad in there.  

04:03:22.309 --> 04:03:26.499
This is like data.
So you can pull this in to your 

04:03:26.500 --> 04:03:32.738
web app.  Which goes along with 
the idea that AMP can be 

04:03:32.739 --> 04:03:36.884
portable, embeddable content 
units.  So you can grab some 

04:03:36.885 --> 04:03:41.029
part of a page which is AMP and 
stick it into your progressive 

04:03:41.030 --> 04:03:45.176
web app.  So, again, taking an 
AMP page or some AMP stuff and 

04:03:45.177 --> 04:03:47.257
using that in a different 
application.

04:03:49.338 --> 04:03:51.417
So you could actually take your 
web pages already that exist and

04:03:51.418 --> 04:03:57.634
 cram those things into a web 
app.  And here you are with your

04:03:57.635 --> 04:04:01.787
 hat thinking, oh, here is the 
key to my project over here.  I 

04:04:01.788 --> 04:04:05.944
don't have much time.  I can use
 this pattern, taking our 

04:04:05.945 --> 04:04:10.106
existing app pages and putting 
them with our new, immersive PWA

04:04:12.197 --> 04:04:16.372
.  But how?  The first key is 
the magic of shadow DOM.  Shadow

04:04:18.488 --> 04:04:22.651
 DOM is simple, it's kind of 
cool and magical.  It's a DOM 

04:04:22.652 --> 04:04:28.894
sub tree that's fully 
encapsulated inside an HTML 

04:04:28.895 --> 04:04:33.066
element.  All the HTML and CSS 
is living inside elements in 

04:04:33.067 --> 04:04:37.219
fact DOM.  Shadow DOM.  It's 
part of the web components idea.

04:04:37.220 --> 04:04:43.486
  And AMP comes in a version 
called shadow AMP, which allows 

04:04:43.487 --> 04:04:45.559
entirely valid accelerated 
mobile page to exist inside 

04:04:45.560 --> 04:04:51.832
another page.  This allows you 
to AMP just one subsection of 

04:04:51.833 --> 04:04:53.911
the web page which we're going 
to need in our app we're making 

04:04:53.912 --> 04:04:58.080
today.
How does this work?  On the top 

04:04:58.081 --> 04:05:02.224
over there you see we're loading
 up not the usual AMP library, 

04:05:02.225 --> 04:05:06.381
but the shadow AMP library.  And
 then on the bottom you see 

04:05:06.382 --> 04:05:10.533
we're going to actually -- once 
AMP exists -- we're just going 

04:05:10.534 --> 04:05:14.709
to attach shadow doc over there.
  Three arguments.  The 

04:05:14.710 --> 04:05:16.774
container where the shadow root 
should be, the document itself, 

04:05:16.775 --> 04:05:20.944
and the URL from which the 
document came originally.  The 

04:05:20.945 --> 04:05:25.135
complicated thing is this is 
loaded asynchronous.  So you 

04:05:25.136 --> 04:05:29.294
can't call attached shadow doc 
until it's loaded.  So we use 

04:05:29.295 --> 04:05:31.295
this

04:05:32.308 --> 04:05:36.241
 asynchronous callback pattern 
to do that.  You see in the 

04:05:32.308 --> 04:05:38.550
middle that function means AMP 
ready, takes the callback, and 

04:05:38.551 --> 04:05:42.702
simply looks for a global called
 "AMP."  If that global already 

04:05:42.703 --> 04:05:46.880
exists, it adds that callback to
 an array of callbacks.  If it 

04:05:46.881 --> 04:05:51.066
doesn't exist, it defines that 
empty array.  So this way, as 

04:05:51.067 --> 04:05:55.216
AMP is still  loading, you can 
keep on calling callback to the 

04:05:55.217 --> 04:05:59.399
object.  When it loads up, then 
it calls back and then it runs 

04:05:59.400 --> 04:06:01.486
everything.  It may sound 
complicated,

04:06:01.487 --> 04:06:03.548
but it actually isn't that 
complicated.  I'll say it simply

04:06:05.630 --> 04:06:07.692
 with fewer words.  You load the
 shadow AMP asynchronous.  Once 

04:06:07.693 --> 04:06:15.964
it's loaded, you can use the 
attached shadow doc message to 

04:06:15.965 --> 04:06:18.039
attach the AMP document 
somewhere inside an existing 

04:06:18.040 --> 04:06:20.129
page.
Let's take a look at this now 

04:06:20.130 --> 04:06:22.213
because it's  getting pretty 
abstract.  Let's go over to demo

04:06:24.309 --> 04:06:30.548
 over here and -- interesting.  
Might have been logged out 

04:06:30.549 --> 04:06:34.707
during this time.  It's back.  
This is the shadow reader.  Here

04:06:34.708 --> 04:06:40.975
 it is.  In this case it uses 
The  Guardian as the backend.  

04:06:40.976 --> 04:06:47.226
The news is kind of depressing 
today.  Sorry for that.  There's

04:06:47.227 --> 04:06:51.412
 two modes.  The cards mode.  
Shows stop stories as a series 

04:06:51.413 --> 04:06:53.506
of cards.  And clicking into a 
card, look for one that's not 

04:06:53.507 --> 04:06:55.603
bad and scary.  Here we go.  A 
black hole.  That's kind of 

04:06:55.604 --> 04:07:01.839
cool.  It's not scary yet.
Clicking on that, you see a bit 

04:07:01.840 --> 04:07:03.941
of animation and it pops out and
 there's the article mode.  It's

04:07:03.942 --> 04:07:10.162
 like the mode of this 
application.  There it is.  

04:07:10.163 --> 04:07:12.240
Enormous black hole.  Not a 
problem for a long time as far 

04:07:12.241 --> 04:07:16.428
as we can tell.  And by the way,
 this bottom over here is all 

04:07:16.429 --> 04:07:20.582
the AMP page.  That's all AMP.  
If you go back over here, you're

04:07:20.583 --> 04:07:22.666
 back here.  There are sections.
  And so on.  If you look at 

04:07:22.667 --> 04:07:28.897
this here, we can see with HTML,
 which is very small, 

04:07:28.898 --> 04:07:30.967
unfortunately, if you can see 
this -- the very bottom, there's

04:07:30.968 --> 04:07:35.125
 a thing called "Article" over 
here.  And if somewhere in 

04:07:35.126 --> 04:07:39.285
there, if you can see it, this 
is called" Shadow root."  And in

04:07:39.286 --> 04:07:43.468
 there is an entire AMP page 
just hiding in there.  And 

04:07:43.469 --> 04:07:45.556
there's the  body.  All the 
content there on the shadow 

04:07:45.557 --> 04:07:49.731
root.  I know this is very hard 
to see.  But try it out.   

04:07:49.732 --> 04:07:51.823
AMP.card is out there.  It's 
public.  You can use  it.  Check

04:07:51.824 --> 04:07:56.003
 this out.  The code is out 
there too.  Check it out.  See 

04:07:56.004 --> 04:07:58.062
how it's built.  Let's go back 
to the slides now.  We're going 

04:07:58.063 --> 04:08:00.158
to
talk about more about how this 

04:08:00.159 --> 04:08:06.385
thing is built.
How is this thing built?  As we 

04:08:06.386 --> 04:08:10.574
discussed already before, 
there's your AMP page.  Let me 

04:08:10.575 --> 04:08:14.747
move then to the PWA.  That's 
the real key.  And three things 

04:08:14.748 --> 04:08:18.936
happen.  The first thing is the 
AMP content gets pulled in from 

04:08:18.937 --> 04:08:23.092
the RSS feed.  And then we 
inject the HTML right into the 

04:08:23.093 --> 04:08:29.338
DOM.  And then around all that 
is the progressive web app 

04:08:29.339 --> 04:08:31.411
making this  nice, immersive 
experience we were talking about

04:08:31.412 --> 04:08:37.683
 here.  Here's the first step.  
Not that complicated.  Pull the 

04:08:37.684 --> 04:08:41.865
AMP content in from the feed and
 you can see we use good old XHR

04:08:41.866 --> 04:08:48.129
 over here.  You can use fetch, 
but the response to HTML is 

04:08:48.130 --> 04:08:50.225
actually a parsed DOM here.  
Once you have this back, you 

04:08:50.226 --> 04:08:56.428
have the document object.  You 
can tick that right into the DOM

04:08:56.429 --> 04:08:58.509
 of the page.  This is very 
convenient.  And we're going to 

04:08:58.510 --> 04:09:02.654
remove parts we're not going to 
move here.  On the top, for 

04:09:02.655 --> 04:09:06.840
example, the guardian doesn't 
have the header.  We don't want 

04:09:06.841 --> 04:09:11.003
to see this as part of the app 
experience.  Remove things from 

04:09:11.004 --> 04:09:13.090
the DOM you don't want.  Take 
out side bars

04:09:13.091 --> 04:09:21.480
and headers.  Just leave what 
you need.  Step two, inject the 

04:09:21.481 --> 04:09:27.747
AMP HTML into the DOM.  Use the 
shadow root and use the doc to 

04:09:27.748 --> 04:09:31.901
take the AMP document and stick 
it right there into the shadow 

04:09:31.902 --> 04:09:33.965
DOM.
And then all around that is a 

04:09:33.966 --> 04:09:38.130
nice progressive web app which 
has the kind of features you 

04:09:38.131 --> 04:09:42.318
want from progressive web apps. 
 It loads quickly with an app 

04:09:42.319 --> 04:09:48.566
shell.  As the app moves around,
 as you go through the app, 

04:09:48.567 --> 04:09:50.651
things are loading quickly.  The
 experience is immersive 

04:09:50.652 --> 04:09:53.060
throughout, like an app would 
be.  You have the possibility of

04:09:55.143 --> 04:09:59.316
 on Android adding to the home 
screen.  And an app-like 

04:09:59.317 --> 04:10:03.496
display, taking away the whole 
URL bar.  And content is 

04:10:03.497 --> 04:10:05.590
available also offline.  How do 
those things work?

04:10:07.695 --> 04:10:11.874
Quickly, the first thing, 
initial load is simple.  Let me 

04:10:11.875 --> 04:10:16.052
show you again.  If I can get 
back to the computer here.  

04:10:16.053 --> 04:10:20.230
There's an actual original 
payload that comes with this.  A

04:10:20.231 --> 04:10:24.388
 lot of CSS.  The HTML is pretty
 simple.  A couple of things 

04:10:24.389 --> 04:10:28.538
here and then notice as we go 
along here -- see if I can zoom 

04:10:28.539 --> 04:10:34.762
there a little bit -- you see 
the little tildes other there.  

04:10:34.763 --> 04:10:38.932
See those things?  If you use  
Facebook, loading your feed, and

04:10:38.933 --> 04:10:43.087
 the things that are resembling 
things in your feed.  It gives 

04:10:43.088 --> 04:10:47.249
the user the impression things 
are loading when they're not 

04:10:47.250 --> 04:10:51.388
there quite yet.  Users like 
that if it's partially loaded 

04:10:51.389 --> 04:10:55.530
and they can see it load.  This 
is like that, but pure text.  So

04:10:55.531 --> 04:10:59.747
 before any loading at all, you 
have something that kind of 

04:10:59.748 --> 04:11:03.909
resembles how the app is going 
to look.  A set of lovely 

04:11:03.910 --> 04:11:08.052
tildes.  Let's go back now to 
the slides, please.  Thank you 

04:11:08.053 --> 04:11:12.210
very  much.
So -- yeah.  Simple, simple 

04:11:12.211 --> 04:11:14.294
initial load over there.  And 
that thing at the top over there

04:11:14.295 --> 04:11:18.466
 is so it can know whether it's 
actually from the URL in cards 

04:11:18.467 --> 04:11:22.667
mode or article mode and apply 
the right kind of UI skeleton so

04:11:22.668 --> 04:11:26.846
 you have that nice kind of 
loading in the beginning.

04:11:26.847 --> 04:11:30.998
And then, of course, as the app 
moves along, things move faster.

04:11:30.999 --> 04:11:39.338
  As you have AMP pages, AMP  
pages load fast.  They're 

04:11:39.339 --> 04:11:43.503
simple.  And you use ShadowDOM 
to get those things into your 

04:11:43.504 --> 04:11:47.680
PWA.  Then the immersive 
experience is easy to do.  I'm 

04:11:47.681 --> 04:11:49.743
going to go back to the demo 
here one last time.  We can see 

04:11:49.744 --> 04:11:53.934
these lovely animations over 
here.  Again, this is just a 

04:11:53.935 --> 04:11:58.072
normal web app, so you can make 
it nicely happen.  You click on 

04:11:58.073 --> 04:12:02.246
this black hole over here.  It 
animates leftwards nicely.  

04:12:02.247 --> 04:12:06.415
Change articles.  Things merge 
around smoothly.  There's stuff 

04:12:06.416 --> 04:12:10.575
for accessibility, for screen 
readers, all those things you 

04:12:10.576 --> 04:12:14.728
need to do because you have all 
the PowerShell of PWAs and CSS 

04:12:14.729 --> 04:12:18.880
and all those things.  Again, 
try it out yourselves at home if

04:12:18.881 --> 04:12:25.102
 you would like to.  Let's get 
back to the slides.  This is 

04:12:25.103 --> 04:12:29.273
easy for the PWA, you have the 
manifests.  For Android, the 

04:12:29.274 --> 04:12:31.362
icons let you add things to the 
screen -- the home screen, that 

04:12:31.363 --> 04:12:37.619
is.  And display stand alone 
just tells Android to display 

04:12:37.620 --> 04:12:41.785
the app in a full
immersive-like app experience.  

04:12:41.786 --> 04:12:48.041
This part is super-simple.
Finally, offline content.  This 

04:12:48.042 --> 04:12:52.209
can be challenging when you do 
service worker.  The caching 

04:12:52.210 --> 04:12:54.319
might be complicated sometimes. 
 It involves coding, some 

04:12:54.320 --> 04:12:58.476
promises, things like that.  But
 in this case, it was simple.  

04:12:58.477 --> 04:13:02.636
We used Workbox as a work 
around.  Throwing out Workbox JS

04:13:04.720 --> 04:13:08.867
.  This was the only library 
used in the making of this had 

04:13:08.868 --> 04:13:13.023
whole web app.  No Angular, no 
React.  Not even jQuery.  The 

04:13:13.024 --> 04:13:15.097
code here is incredibly small to
 make this happen.  In fact, 

04:13:15.098 --> 04:13:19.245
minimize is about 10K of 
JavaScript behind the  scenes.  

04:13:19.246 --> 04:13:27.598
That's it.  About 10K.  Workbox 
makes it simple.  Here is the 

04:13:27.599 --> 04:13:31.791
lovely cache for the queries.  
You set your route, declare your

04:13:33.884 --> 04:13:35.959
 strategy, and you're all done. 
 The service worker has maybe 30

04:13:35.960 --> 04:13:40.137
 lines of code.  So there's 
offline content.  We also 

04:13:40.138 --> 04:13:42.245
pre-cache some things like 
images, other things that are 

04:13:42.246 --> 04:13:46.400
important for the app.
Like I was just saying a minute 

04:13:46.401 --> 04:13:50.578
ago, there was no framework used
 in the making of this app.  Not

04:13:50.579 --> 04:13:54.752
 even jQuery.  These are samples
 from the code.  A little bit 

04:13:54.753 --> 04:13:58.961
ponderous in some cases.  
Document.query selector, all 

04:13:58.962 --> 04:14:05.187
these things., jQuery makes it 
simply, but this is to show you 

04:14:05.188 --> 04:14:09.334
didn't need jQuery for this.  
It's pretty simple.  It's just 

04:14:09.335 --> 04:14:11.427
JavaScript.  But not much 
JavaScript.  A little bit like 

04:14:11.428 --> 04:14:15.585
the old days.
So this is good.  The web app.  

04:14:15.586 --> 04:14:19.741
The boss likes you.  You can 
keep your job.  Triumph.  

04:14:19.742 --> 04:14:23.882
Happiness.  All those things.  
So you're happy, then you think,

04:14:23.883 --> 04:14:28.043
 great, I have made this awesome
 PWA, but is this  AMP, though? 

04:14:28.044 --> 04:14:32.202
 I thought this AMP thing was 
important because I have to get 

04:14:32.203 --> 04:14:38.438
into Google's search carousel 
and the app cache and make 

04:14:38.439 --> 04:14:40.539
Google happy in some way.  This 
is not an AMP over here.  I have

04:14:42.628 --> 04:14:46.819
 made a normal web page.  Is 
that okay?  Can I do that?  And 

04:14:46.820 --> 04:14:48.904
--  yes, you can.  Who cares?  
Go ahead and do it.

04:14:48.905 --> 04:14:55.123
In this case, main app would not
 pass AMP validation -- it isn't

04:14:55.124 --> 04:15:01.345
 supposed to -- but it's fast 
and uses AMP.  It works really, 

04:15:01.346 --> 04:15:03.427
really well.  If you want to get
 the Google AMP cache in the 

04:15:03.428 --> 04:15:07.606
first page, there's a pattern 
for that.  The first page is  

04:15:07.607 --> 04:15:09.682
AMP -- the landing page can be 
AMPed.  And

04:15:13.298 --> 04:15:17.440
 they have an install service 
worker component.  You can 

04:15:17.441 --> 04:15:21.624
install service worker behind 
the scenes, and then go to the 

04:15:21.625 --> 04:15:25.775
next, PWA, and then AMP behind 
that again.  You can use these 

04:15:25.776 --> 04:15:29.910
in various ways to get the  
benefits of AMP.  Pre-rendering 

04:15:29.911 --> 04:15:34.078
and finding the link in Google 
search or elsewhere with the AMP

04:15:34.079 --> 04:15:40.321
 cache.  And PWA starts up, you 
can use AMP components to make 

04:15:40.322 --> 04:15:44.471
your life easier.  And same with
 publishing, and applies in 

04:15:44.472 --> 04:15:48.642
other kinds of ways.  What if 
you have a site that's like a 

04:15:48.643 --> 04:15:52.843
lead Gen site.  Long form, five 
different screens were your 

04:15:52.844 --> 04:15:57.014
name, address, birthday, 
neighbor's name, dog's name, 

04:15:57.015 --> 04:16:01.188
cat's name, the name of the tree
 in your front art.  All those 

04:16:01.189 --> 04:16:05.350
things.  This
happens sometimes.  With your 

04:16:05.351 --> 04:16:11.663
users -- if you use AMP, comes 
with nice, formulated form 

04:16:11.664 --> 04:16:17.907
fields.  And like with the 
articles, instead of  pages of 

04:16:17.908 --> 04:16:22.082
articles, you control the form. 
 You control the experience.  

04:16:22.083 --> 04:16:26.233
Users can't stand it when they 
fill out a form and face a long 

04:16:26.234 --> 04:16:28.315
load.  In the PWA things can 
load more quickly.  Especially 

04:16:28.316 --> 04:16:32.486
if they're AMP.  You can go back
 and forth, you can control the 

04:16:32.487 --> 04:16:36.656
screen.  Make it fun for the 
user to fill out this long form.

04:16:36.657 --> 04:16:38.657
  Register now.
Anotherred

04:16:40.743 --> 04:16:44.877
another idea, E-commerce.  
Various E-commerce sites are 

04:16:44.878 --> 04:16:49.059
using AMP for all sorts of 
things, product pages, listing 

04:16:49.060 --> 04:16:53.225
pages.  And up to and including 
the checkout process.  It's 

04:16:53.226 --> 04:16:57.415
possible with AMP.  That's the 
payment request API.  So in this

04:16:57.416 --> 04:16:59.511
 case, I imagine instead of your
 news articles, a series of 

04:16:59.512 --> 04:17:03.684
product pages all written with 
AMP so they're fast.  Users are 

04:17:03.685 --> 04:17:07.880
getting around to actually have 
things loaded.  And dynamic 

04:17:07.881 --> 04:17:12.048
content is possible with AMP as 
well.  There's AMP state, AMP 

04:17:12.049 --> 04:17:16.186
list, various components that 
let you change things on the 

04:17:16.187 --> 04:17:18.273
screen dynamically.  So you 
change the number of things 

04:17:18.274 --> 04:17:22.454
you're buying,  prices can 
change, shipping costs can 

04:17:22.455 --> 04:17:26.620
change with user input and so on
 and so forth.  Or imagine the 

04:17:26.621 --> 04:17:28.699
travel application.  Instead of 
articles, you have hotel.  Hotel

04:17:30.794 --> 04:17:32.878
 information.  And you go back 
to  hotels.

04:17:32.879 --> 04:17:39.196
So, again, all possible with AMP
 in a PWA context.  The upshot 

04:17:39.197 --> 04:17:41.297
is this makes you money.  
Because the users are happy 

04:17:41.298 --> 04:17:43.381
because they have a better 
experience.  They're not 

04:17:43.382 --> 04:17:47.552
abandoning the pages as much.  
And a lot of data show us AMP 

04:17:47.553 --> 04:17:51.721
pages tend to get better user 
engagement.  Data shows that  

04:17:51.722 --> 04:17:55.884
faster pages get better user 
engagement, better conversions, 

04:17:55.885 --> 04:17:57.965
lower bounce.  So the users are 
staying on for longer on your 

04:17:57.966 --> 04:18:02.120
app and they're converting.  
They're buying something, or 

04:18:02.121 --> 04:18:06.251
they're viewing an ad.  Whatever
 it is.  Ad support in AMP is 

04:18:06.252 --> 04:18:08.331
also very advanced these days so
 you're getting money from the 

04:18:08.332 --> 04:18:13.303
users.  You also make money 
because developers are spending 

04:18:13.304 --> 04:18:15.365
less time working on their app. 
 Things are simpler for them.  

04:18:15.366 --> 04:18:19.513
So you can make things more  
quickly.  So you make money on 

04:18:19.514 --> 04:18:21.600
both sides of the coin.
Which, of course, isn't your 

04:18:21.601 --> 04:18:23.661
motivation because you're 
programmers.  You don't care 

04:18:23.662 --> 04:18:27.812
about the money.  You care about
 the duty of your code.  The 

04:18:27.813 --> 04:18:32.023
integrity of your work.  Money 
is one of those things that gets

04:18:32.024 --> 04:18:36.185
 you rent and maybe occasional 
Doritos or soup.  Or

04:18:42.291 --> 04:18:44.291
 kielbasa and

04:18:46.373 --> 04:18:48.476
 dumpings over here.  It's not 
just because of the money you're

04:18:50.563 --> 04:18:52.661
 making and retiring early or 
becoming a manager, you didn't 

04:18:52.662 --> 04:18:56.828
create this terrible 
Frankenstein web app was that 

04:18:56.829 --> 04:19:00.986
hodgepodge of stuff you found on
 the Internet and copied and  

04:19:00.987 --> 04:19:05.141
pasted them together.  You don't
 have to panic.  This is 

04:19:05.142 --> 04:19:09.311
something in old town as well.  
Instead, you have a lovely, 

04:19:09.312 --> 04:19:11.410
maintainable, elegant code 
that's going to work for longer.

04:19:11.411 --> 04:19:15.568
  That people will like in a 
couple years.  Future 

04:19:15.569 --> 04:19:17.661
programmers at your company will
 see your code and smile instead

04:19:17.662 --> 04:19:21.807
 of thinking, why did they make 
all this stuff?  It's crazy.  It

04:19:23.894 --> 04:19:26.760
 looks easy, it's elegant and 
maintainable.  And the 

04:19:26.761 --> 04:19:28.837
conclusion -- isn't life about 
creating

04:19:28.838 --> 04:19:30.911
something beautiful?  This is 
your chance to do that.  PWA and

04:19:30.912 --> 04:19:35.057
 AMP.  Thank you very much.
[ Applause ]

04:51:37.023 --> 04:51:39.442
&gt;&gt; I'll wait for you to settle 
down.

04:51:47.555 --> 04:51:51.703
  Hi, everyone.  My name is 
Shailen Tuli

04:51:55.742 --> 04:51:59.608
.  I'm a developer program 
engineer working on Android at 

04:51:55.742 --> 04:52:02.022
Google.  And I'm here to talk to
 you about building great apps. 

04:52:02.023 --> 04:52:06.188
 Android O.  Android O is kind 
of a big topic.  There are lots 

04:52:06.189 --> 04:52:10.407
of cool things in O.  And 
there's a talk later in the 

04:52:10.408 --> 04:52:14.564
afternoon that's going to cover 
many of them.  My talk is going 

04:52:14.565 --> 04:52:20.792
to talk about -- it's going to 
focus on a couple of topics.  

04:52:20.793 --> 04:52:24.936
Basically what you can and 
cannot do with regard to 

04:52:24.937 --> 04:52:31.197
background work in your O apps. 
 And what you can and cannot do 

04:52:31.198 --> 04:52:33.264
with regard to location 
gathering when your app is in 

04:52:33.265 --> 04:52:35.340
the background.  This is going 
to be a fairly technical talk.  

04:52:35.341 --> 04:52:39.503
I'm going to focus on just those
 two issues.

04:52:41.594 --> 04:52:43.672
And I have a lot of material, so
 I'm going to go a little fast. 

04:52:43.673 --> 04:52:51.254
 So you have been warned.  Okay.
  So why focus on background so 

04:52:51.255 --> 04:52:55.439
much?  Why focus on background 
limits coming in O and the 

04:52:55.440 --> 04:52:59.586
location  limits?  Because first
 I believe these are some of the

04:52:59.587 --> 04:53:01.676
 biggest changes in the 
platform.  And these are changes

04:53:01.677 --> 04:53:07.998
 that have really, really great 
consequences to you app 

04:53:07.999 --> 04:53:10.085
developers because I believe 
these  changes make Android an 

04:53:10.086 --> 04:53:12.163
even better platform for writing
 apps.

04:53:12.164 --> 04:53:16.289
So that's what I'm going to be 
focusing on.  I'll talk, of 

04:53:16.290 --> 04:53:20.460
course, about what the changes 
are.  What strategies you can 

04:53:20.461 --> 04:53:22.534
use to deal with them.  I'll 
talk a little bit about 

04:53:22.535 --> 04:53:26.695
historically how we got to this 
point where we have to limit 

04:53:26.696 --> 04:53:30.844
what kind of background work 
goes on generally and 

04:53:30.845 --> 04:53:33.762
specifically with regard to 
location.  So sort of a little 

04:53:33.763 --> 04:53:37.969
historical overview of things.
Okay.  So pretty much everything

04:53:37.970 --> 04:53:44.235
 I'm going to cover in this 
talk, system health, basically 

04:53:44.236 --> 04:53:50.509
good RAM management, or battery.
  So how to get more battery 

04:53:50.510 --> 04:53:52.600
performant stuff happening in 
your apps.  What I'll do is 

04:53:52.601 --> 04:53:58.829
start with a little overview and
 just talk about a few things 

04:53:58.830 --> 04:54:02.982
that gives you a sense of what's
 happening in O.  And then a 

04:54:02.983 --> 04:54:07.175
deep dive into each of these 
topics afterwards.

04:54:07.176 --> 04:54:11.349
So the first thing in regards to
 system health is there is a 

04:54:11.350 --> 04:54:13.421
limitation in O that there will 
be no startup services in the 

04:54:13.422 --> 04:54:17.591
background.  This is kind of a 
big deal.  But it really only 

04:54:17.592 --> 04:54:21.769
applies to startup services in 
the background.  In the 

04:54:21.770 --> 04:54:25.934
foreground, you can keep doing 
what you're doing now.  The 

04:54:25.935 --> 04:54:30.098
other system health issue is 
that there will be fairly 

04:54:30.099 --> 04:54:37.211
substantial limits on implicit 
broadcasts.  So you can still 

04:54:37.212 --> 04:54:39.558
have explicit broadcasts, you 
can  dynamically register for 

04:54:39.559 --> 04:54:43.733
broadcasts, but broadcasts that 
go into your manifest, there are

04:54:43.734 --> 04:54:46.137
 going to be quite a lot of 
limits based on those.  Again

04:54:50.286 --> 04:54:52.379
, we'll explore these.  So the 
question is, when?  When do all 

04:54:52.380 --> 04:54:54.467
these things happen?  When do 
you have to worry about these 

04:54:54.468 --> 04:55:00.737
things?  The answer is when you 
implement your target SDK 

04:55:00.738 --> 04:55:04.912
version for target O.  That 
means distant to some people, 

04:55:04.913 --> 04:55:09.075
maybe not so distant to others. 
 But I would urge everyone to 

04:55:09.076 --> 04:55:15.316
start thinking about this and 
thinking about it now, because 

04:55:15.317 --> 04:55:17.390
even today users of your
apps can go into the settings of

04:55:17.391 --> 04:55:20.246
 their phones, figure out how 
much work they're doing in the 

04:55:20.247 --> 04:55:24.476
background, decide if that work 
is too much and essentially 

04:55:24.477 --> 04:55:26.564
curtail that work.
So like it or not, the limits on

04:55:26.565 --> 04:55:32.790
 background work that you can 
do, those are here already.  So 

04:55:32.791 --> 04:55:34.867
it's something that you, as app 
developers, kind of have to deal

04:55:34.868 --> 04:55:41.100
 with.  You'll deal with it much
 more substantially when you 

04:55:41.101 --> 04:55:45.270
upgrade to O, but you have to 
deal with them now as well.  

04:55:45.271 --> 04:55:49.441
That's system health.  And let's
 talk about the battery now.  

04:55:49.442 --> 04:55:55.710
That's the focus of the changes 
coming in O.  So basically 

04:55:55.711 --> 04:55:57.809
what's happening is that for 
battery reasons, what kind of 

04:55:57.810 --> 04:56:04.071
location gathering you can do in
 the background is going to be 

04:56:04.072 --> 04:56:08.236
substantially throttled.  So if 
you have gotten use to the idea 

04:56:08.237 --> 04:56:10.341
of having very frequent updates,
 for instance, in the foreground

04:56:12.440 --> 04:56:14.522
 and in the background, the 
foreground stuff is going to 

04:56:14.523 --> 04:56:16.607
remain the same.  The background
 stuff will be quite different. 

04:56:16.608 --> 04:56:20.739
 So the question is, when does 
this kick in?  When do these 

04:56:20.740 --> 04:56:26.999
limits kick in?  And the answer 
is they kick in now.  For any 

04:56:27.000 --> 04:56:33.261
app running on an O device, 
regardless of SDK version, the 

04:56:33.262 --> 04:56:37.471
limits are here.  If you have an
app that does something with 

04:56:37.472 --> 04:56:43.730
location and the target is M or 
L, that app actually behaves 

04:56:43.731 --> 04:56:45.815
quite differently without you 
having to change a leadership of

04:56:45.816 --> 04:56:52.086
 code.  That app when it's run 
on an O device is going to 

04:56:52.087 --> 04:56:56.238
behave differently.  Could 
behave differently.  This is a 

04:56:56.239 --> 04:57:00.394
fairly significant change as 
well.  If you have a location 

04:57:00.395 --> 04:57:02.485
component to your apps, you are 
going to have to deal with.

04:57:02.486 --> 04:57:08.207
So these are big changes.  No 
startup services, limits on what

04:57:08.208 --> 04:57:10.338
 you can do with broadcasts, 
limits to what you can do with 

04:57:10.339 --> 04:57:14.553
the background.  So the question
 is, why are we doing this?  How

04:57:14.554 --> 04:57:16.661
 did we get here?  What's really
 going on?  So the first thing 

04:57:16.662 --> 04:57:20.813
is, we're not doing this because
 we like being difficult or we 

04:57:20.814 --> 04:57:24.982
just like making people's lives 
difficult.  We're doing this 

04:57:24.983 --> 04:57:29.141
because this is essentially 
better for the platform.  It's 

04:57:29.142 --> 04:57:31.222
better for the users.  The users
 want us to build -- want you --

04:57:31.223 --> 04:57:37.548
 to build apps that are really, 
really important.  That do 

04:57:37.549 --> 04:57:39.634
really great things with RAM 
management.  That do really 

04:57:39.635 --> 04:57:43.809
great things with battery.  The 
changes that we've introduced in

04:57:43.810 --> 04:57:47.968
 O have been a long time in the 
coming.  So I'm going to get to 

04:57:47.969 --> 04:57:52.135
all the details in a minute or 
two.  But I'm going to take it 

04:57:52.136 --> 04:57:56.333
and talk about how we got here 
starting in Marshmallow.  So go 

04:57:56.334 --> 04:58:02.547
back to Marshmallow.  That's 
when we introduced Doze.  So 

04:58:02.548 --> 04:58:06.726
what's Doze?  Just a recap, when
 your device is stationary, not

04:58:06.727 --> 04:58:10.883
charging, and the screen is off 
-- essentially when it's not 

04:58:10.884 --> 04:58:17.120
being used -- we said you can't 
go crazy and do all sorts of 

04:58:17.121 --> 04:58:19.203
things in the background.  You 
have to channel your background 

04:58:19.204 --> 04:58:23.359
work into  well-defined 
maintenance windows.  When a 

04:58:23.360 --> 04:58:25.461
device is sitting there, it 
should not be doing crazy things

04:58:27.547 --> 04:58:31.685
.  It should be a quiet machine.
  That's where those came in.

04:58:31.686 --> 04:58:35.820
Android M also gave us app 
standby.  And the idea is if you

04:58:35.821 --> 04:58:39.975
 have background network 
activity, how that activity was 

04:58:39.976 --> 04:58:42.065
done was actually dependent on 
how much or how little the user 

04:58:42.066 --> 04:58:48.281
was interacting with your app.  
Again, the idea is if there's 

04:58:48.282 --> 04:58:50.366
background work being done, 
let's do this very carefully.  

04:58:50.367 --> 04:58:56.569
And in Android N, we gave you 
Doze Light, like Doze, but the 

04:58:56.570 --> 04:59:00.749
difference is the device is not 
stationary.  Think of I have my 

04:59:00.750 --> 04:59:02.827
phone right here.  It's not on. 
 Obviously, it's not charging.  

04:59:02.828 --> 04:59:06.981
But it's moving because I'm 
moving.  And, again, the idea 

04:59:06.982 --> 04:59:11.177
was -- even then -- you do 
background work pretty  

04:59:11.178 --> 04:59:13.240
carefully.
So all of this started off a 

04:59:13.241 --> 04:59:17.416
couple of releases ago, and what
 you are seeing in O is pretty 

04:59:17.417 --> 04:59:23.631
much a very natural progression 
for what we introduced in M and 

04:59:23.632 --> 04:59:27.793
in N.  So the other stuff that's
 very significant is -- starting

04:59:27.794 --> 04:59:29.858
 in N -- we started paying 
attention to some broadcasts 

04:59:29.859 --> 04:59:34.033
that we felt were excessively 
noisy, that were causing system 

04:59:34.034 --> 04:59:38.243
health problems, crashing.  Very
 visible jank for users.  And we

04:59:38.244 --> 04:59:42.391
 decided to curtail what you 
could do with those broadcasts. 

04:59:42.392 --> 04:59:46.563
 So in Android N we said, for 
instance, the connection action 

04:59:46.564 --> 04:59:50.728
broadcast.  You could not listen
 to this in the register.  And 

04:59:50.729 --> 04:59:54.885
you could no longer register for
 this in your  management.

04:59:54.886 --> 04:59:59.062
And the reason was that it was 
an extremely noisy broadcast.  

04:59:59.063 --> 05:00:03.201
We didn't want you waking up 
apps, doing connective lead 

05:00:03.202 --> 05:00:05.287
changes -- it was too expensive.
  Similarly, there were two 

05:00:05.288 --> 05:00:09.467
other broadcasts that were 
targeted in N.  And that's 

05:00:09.468 --> 05:00:13.648
action new picture, action new 
video.  These are fired when a 

05:00:13.649 --> 05:00:19.934
user takes a picture or creates 
a little video.  And so this is 

05:00:19.935 --> 05:00:22.697
-- action new picture is 
actually a great example to 

05:00:22.698 --> 05:00:25.599
consider when you think about 
what the system health 

05:00:25.600 --> 05:00:27.693
implications are of allowing a 
broadcast like that to happen.

05:00:27.694 --> 05:00:29.792
So imagine a user takes out 
their phone, takes a photograph.

05:00:31.849 --> 05:00:38.113
  At that point, there are -- 
let's  say -- 20 apps on the 

05:00:38.114 --> 05:00:40.187
user's device which have 
registered for this broadcast.  

05:00:40.188 --> 05:00:44.341
The system says, all right!  
Let's go!  Let's wake you up.  

05:00:44.342 --> 05:00:48.471
Off you go.  One, two, three, 
four, five.  And each of those 

05:00:48.472 --> 05:00:52.627
apps all wants to do great, 
impressive things.  What 

05:00:52.628 --> 05:00:56.810
doesn'tment to impress the user,
 right?  They start services and

05:00:56.811 --> 05:01:00.958
 expensive stuff.  Before you 
know, the system is saying, hey,

05:01:00.959 --> 05:01:07.287
 apps, seven, eight -- I can't 
start you until I kill one, two,

05:01:09.354 --> 05:01:11.436
 three.  It's turbulent, it's 
launching stuff, creating stuff,

05:01:11.437 --> 05:01:17.664
 killing stuff, doing whatever 
it can.  Heaven forbid the user 

05:01:17.665 --> 05:01:21.842
takes a second or a third 
picture -- even more crazy.  In 

05:01:21.843 --> 05:01:26.004
Android N we said this is no way
 for an operating system to be 

05:01:26.005 --> 05:01:30.179
behaving.  You cannot write this
 in the manifest.  We're to the 

05:01:30.180 --> 05:01:34.371
going crazy every time somebody 
takes a picture.  So that's the 

05:01:34.372 --> 05:01:38.551
background of that.  Modify now,
 the location stuff that we're 

05:01:38.552 --> 05:01:42.695
going
to talk about is largely due to 

05:01:42.696 --> 05:01:46.859
batteries.  And battery has been
 a huge issue for us year after 

05:01:46.860 --> 05:01:51.055
year.  In our surveys, 
developers tell us -- the users 

05:01:51.056 --> 05:01:55.234
tell us -- sorry -- one in three
 people saw that battery is the 

05:01:55.235 --> 05:01:59.409
number one concern for them 
about Android.

05:01:59.410 --> 05:02:05.635
And what happens is users -- 
rightly or  wrongly -- associate

05:02:05.636 --> 05:02:07.714
 location with battery drain.  
And because they do that, they 

05:02:07.715 --> 05:02:11.873
go and disable location all 
together, which makes all the 

05:02:11.874 --> 05:02:16.034
nice apps you guys have written 
not work at all.  Or they work 

05:02:16.035 --> 05:02:18.120
in a degraded manner.  This is 
not good for the app developer. 

05:02:18.121 --> 05:02:22.309
 It's not good for the user.  
It's not good for Android as a 

05:02:22.310 --> 05:02:28.547
platform.  So this time in O 
Google has taken a very serious 

05:02:28.548 --> 05:02:30.548
approach to battery management

05:02:32.627 --> 05:02:38.908
.  And targeted background of 
location as a primary which 

05:02:38.909 --> 05:02:40.968
needs to be carefully managed 
for battery to work well.

05:02:40.969 --> 05:02:45.108
All right.  So that's the 
historical stuff.  One more 

05:02:45.109 --> 05:02:47.109
little segue before we

05:02:49.173 --> 05:02:53.307
 dive into it.  All through this
 time, we are talking about 

05:02:53.308 --> 05:02:58.252
startup services, implicit 
broadcasts, location.  And it's 

05:02:58.253 --> 05:03:00.337
a good thing to take a minute 
and say what exactly is 

05:03:00.338 --> 05:03:02.420
foreground?  What exactly is 
background.  It's sort of 

05:03:02.421 --> 05:03:08.700
obvious at one level, maybe not 
so obvious at another.  So the 

05:03:08.701 --> 05:03:12.869
obvious stuff.  When you have a 
visible app component -- when 

05:03:12.870 --> 05:03:17.012
the user can see your app, when 
your activity is started or 

05:03:17.013 --> 05:03:19.294
resumed, you're in the 
foreground.  When you have a 

05:03:19.295 --> 05:03:21.363
widget, you're in the foreground
.  Fairly obvious.  When you 

05:03:21.364 --> 05:03:25.532
have a foreground service, you 
are considered foreground.  Kind

05:03:25.533 --> 05:03:29.708
 of obvious.  It's a foreground 
service.  Knowing the foreground

05:03:31.803 --> 05:03:33.888
 -- stay with the foreground.  
You are in the foreground with a

05:03:33.889 --> 05:03:38.049
 foreground service.  When you 
have a bound service and there 

05:03:38.050 --> 05:03:42.234
is a client in the foreground 
binding to that service, you are

05:03:42.235 --> 05:03:44.311
 then also in the foreground.  
When you have a content provider

05:03:44.312 --> 05:03:46.392
 and there
is something that is in the 

05:03:46.393 --> 05:03:50.565
foreground accessing the content
 provider, you are, then, also 

05:03:50.566 --> 05:03:54.715
in the foreground.
And then there's a slew of sort 

05:03:54.716 --> 05:03:58.884
of very  specialized cases which
 -- if you read about  these -- 

05:03:58.885 --> 05:04:00.971
you will understand, yeah, these
 have to be foreground.  An 

05:04:00.972 --> 05:04:05.145
accessibility service, for 
instance, has to perform all 

05:04:05.146 --> 05:04:07.224
sorts of actions on behalf of 
the user.  It has to be 

05:04:07.225 --> 05:04:11.398
considered foreground.  
Notification, listener service, 

05:04:11.399 --> 05:04:15.552
indicator, wall paper service.  
You can find documentation on 

05:04:15.553 --> 05:04:19.718
developer.android.com explaining
 all of this pretty carefully.

05:04:19.719 --> 05:04:23.882
The good news is, in all of 
these cases that I mentioned, 

05:04:23.883 --> 05:04:28.042
nothing that relates to 
background limit for Android.  

05:04:28.043 --> 05:04:32.201
If you're in the foreground, you
 can pretty much do whatever you

05:04:32.202 --> 05:04:36.354
 could do in any release up 
until now.  Nothing really 

05:04:36.355 --> 05:04:42.577
changes for you.  But when are 
you now not in the foreground?  

05:04:42.578 --> 05:04:46.736
When are you in the background? 
 No visible app component.  

05:04:46.737 --> 05:04:53.008
You're stuck.  There's no widget
.  You brought in a started 

05:04:53.009 --> 05:04:55.116
service that is not a foreground
 service.  That will put you in 

05:04:55.117 --> 05:04:59.289
the background.  You are in a 
job service.  We'll be talking 

05:04:59.290 --> 05:05:03.434
about jobs later on.  But when 
you're in that part of the code,

05:05:03.435 --> 05:05:07.621
 you are, again, going to be in 
the background.  And when you 

05:05:07.622 --> 05:05:13.839
are dealing with the broadcast 
inside your broadcast 

05:05:13.840 --> 05:05:15.927
receiver,ing you also, this time
, are in the background.  In all

05:05:18.027 --> 05:05:20.125
 of these cases the background 
limits that have been introduced

05:05:22.200 --> 05:05:24.272
, they will apply.
So it's kind of a big deal.  

05:05:24.273 --> 05:05:28.436
Trivial apps can do without 
dealing with broadcasts and 

05:05:28.437 --> 05:05:32.624
services, et cetera.  Most 
people don't write trivial apps.

05:05:32.625 --> 05:05:36.812
  They write mature apps.  Those
 apps will be affected by these 

05:05:36.813 --> 05:05:38.876
changes.  So I'm going to dive 
into services and what's 

05:05:38.877 --> 05:05:43.060
changing with services in 
Android O.  Lots of fun stuff.  

05:05:43.061 --> 05:05:47.280
As I said, this is a pretty 
technical talk, so we will go 

05:05:47.281 --> 05:05:51.458
deep into this.
From now on applications can no 

05:05:51.459 --> 05:05:55.609
longer freely execute background
 services.  So the idea is we 

05:05:55.610 --> 05:05:57.702
want you to stop thinking of our
 services and start thinking 

05:05:57.703 --> 05:06:01.902
about jobs.  The jobs get you 
there, fire this job, for the 

05:06:01.903 --> 05:06:04.002
kind of work that you would 
currently give to services.  

05:06:04.003 --> 05:06:08.169
Apps that are doing ongoing work
 with regard to broadcasts 

05:06:08.170 --> 05:06:12.355
should also start thinking about
 jobs.  Because, you know,  

05:06:12.356 --> 05:06:16.513
starting a service, for 
instance, to do something in 

05:06:16.514 --> 05:06:20.706
response to a broadcast will no 
longer be possible.

05:06:20.707 --> 05:06:26.980
The idea of these changes is 
fundamentally, it's expensive 

05:06:26.981 --> 05:06:31.146
work, or potentially expensive 
is being done on behalf of the 

05:06:31.147 --> 05:06:33.232
user, the user should be aware 
of that.  It should be visible 

05:06:33.233 --> 05:06:37.402
to the user.  If you are doing 
things that cost the user 

05:06:37.403 --> 05:06:43.704
battery, RAM, whatever, are the 
user should sort of say, hey, I 

05:06:43.705 --> 05:06:47.845
know you're doing this.  I 
approve.  This is  making my app

05:06:47.846 --> 05:06:54.073
 experience good.  We don't want
 work being done quietly in a 

05:06:54.074 --> 05:06:58.303
less than December tin manner 
without the approval.  That's 

05:06:58.304 --> 05:07:00.304
the

05:07:02.416 --> 05:07:06.572
 guiding principle behind the 
changes.  If you do it in the 

05:07:06.573 --> 05:07:08.573
foreground, illegal

05:07:10.183 --> 05:07:12.270
 state exception.  If it's  
pending, it won't work.  You 

05:07:12.271 --> 05:07:14.349
will get a log warning.  
Basically there isn't a way -- 

05:07:14.350 --> 05:07:18.535
when you're in the background --
 to start service anymore.

05:07:18.536 --> 05:07:22.699
So this is pretty -- this is 
kind of a big  deal.  I don't 

05:07:22.700 --> 05:07:26.850
know if you'll think it's a big 
deal.  But when I first found 

05:07:26.851 --> 05:07:31.013
out about this, I said, whoa.  
That's a big deal.  But there 

05:07:31.014 --> 05:07:37.277
are actually some very practical
 ways in which this is softened 

05:07:37.278 --> 05:07:39.352
up.  One is that there is a 
grace period.  So services 

05:07:39.353 --> 05:07:43.494
continue to run on for a while 
once you lose your foreground 

05:07:43.495 --> 05:07:47.652
status.  So take an example of 
you have an app.  The app does 

05:07:47.653 --> 05:07:51.801
some -- the user is using the 
app.  It launches a service.  

05:07:51.802 --> 05:07:55.942
Service is doing fine.  And then
 the user swipes away your app. 

05:07:55.943 --> 05:08:00.095
 It's gone now.  It's no longer 
in the foreground.  The service 

05:08:00.096 --> 05:08:04.269
won't be cut off immediately.  
There will be a few minutes of 

05:08:04.270 --> 05:08:06.339
grace period where the service 
will continue to run, at which 

05:08:06.340 --> 05:08:10.524
point the system will step in 
and say, okay, enough of that.  

05:08:10.525 --> 05:08:14.717
Get off of the service.  And 
effectively what will happen in 

05:08:14.718 --> 05:08:18.887
a few minutes is the services 
will be called and it will be as

05:08:18.888 --> 05:08:23.019
 if the services are called stop
 self.  The system will just do 

05:08:23.020 --> 05:08:25.099
that for
you.

05:08:27.168 --> 05:08:31.401
But, it's nice that it's not 
abrupt.  There is a grace 

05:08:31.402 --> 05:08:33.495
period.  The second is I think 
the realization that sometimes 

05:08:33.496 --> 05:08:35.564
when you are in the background, 
your app is going to want to 

05:08:35.565 --> 05:08:43.939
respond to certain events.  They
 may be very user-visible  

05:08:43.940 --> 05:08:48.098
events, other kinds of events.  
There's a process to temporarily

05:08:48.099 --> 05:08:50.200
 wait list Apps.  To keep

05:08:54.328 --> 05:08:56.404
 apps as if they're in the 
foreground.  This is best 

05:08:56.405 --> 05:09:00.574
explained with examples.  Say 
you have a high priority cloud 

05:09:00.575 --> 05:09:04.742
message coming down to your 
device.  It sees the 

05:09:04.743 --> 05:09:08.889
restrictions and your app wants 
to do something with it.  We 

05:09:08.890 --> 05:09:13.077
give you a period of a few 
seconds -- less than a minute --

05:09:13.078 --> 05:09:17.272
 where by you can be considered 
foreground and launch services. 

05:09:17.273 --> 05:09:23.503
 Similarly, if you have an SMS 
delivery, you may want to 

05:09:23.504 --> 05:09:25.582
respond to that.  There's a 
short window where you're given 

05:09:25.583 --> 05:09:29.752
temporary foreground status and 
you can respond to that.

05:09:29.753 --> 05:09:33.920
And in Android O, notifications 
are kind of a big deal.  When 

05:09:33.921 --> 05:09:38.099
you are responding to a 
notification action at any time,

05:09:38.100 --> 05:09:42.278
 and there's a pending intent 
involved, at that point you are 

05:09:42.279 --> 05:09:48.523
treated as if you are in the 
foreground.  This is a very 

05:09:48.524 --> 05:09:50.602
pragmatic approach the framework
 team has taken.  By and  large,

05:09:50.603 --> 05:09:52.682
 we don't want to do any 
expensive work in the background

05:09:54.784 --> 05:09:56.861
.  But we understand there are 
some cases where you'll need to 

05:09:56.862 --> 05:09:58.944
do it, and here's how you do  
it.  So this

05:10:03.045 --> 05:10:07.206
 whitelisting process should 
impact -- help most developers 

05:10:07.207 --> 05:10:11.369
target what they need to do 
pretty effectively.  That's our 

05:10:11.370 --> 05:10:15.529
hope.  Foreground services are 
not affected by any of this.  So

05:10:15.530 --> 05:10:19.699
 you can have a foreground 
service, have a persistent 

05:10:19.700 --> 05:10:23.907
notification.  The user sees 
that -- life is good.  The only 

05:10:23.908 --> 05:10:28.107
problem is that foreground 
services have typically within 

05:10:28.108 --> 05:10:32.293
done in two steps.  Start a 
service in the background and 

05:10:32.294 --> 05:10:36.491
then promote it to foreground.  
The first part is not going to 

05:10:36.492 --> 05:10:38.552
work anymore.  You can't start 
services in the

05:10:38.553 --> 05:10:44.823
background.  There's a new API 
for starting foreground 

05:10:44.824 --> 05:10:46.929
services.  It just does it for 
you.

05:10:46.930 --> 05:10:51.102
We'll talk more about foreground
 services at the appropriateness

05:10:51.103 --> 05:10:55.266
 of foreground services in a 
bit.  So a question I was asked 

05:10:55.267 --> 05:11:03.594
when I did this presentation in 
India by a developer, do you 

05:11:03.595 --> 05:11:07.743
expose an API where I can tell 
if it's safe to start service or

05:11:07.744 --> 05:11:11.874
 not?  No, we do not.  It's for 
the app developer to figure out 

05:11:11.875 --> 05:11:13.976
when it's safe or not safe to 
start a service.  Essentially, 

05:11:13.977 --> 05:11:16.087
you have to figure out when 
you're in the foreground and not

05:11:18.154 --> 05:11:22.314
 in the foreground and go with 
that.  So that's the gist of the

05:11:22.315 --> 05:11:26.467
 services part.  A couple other 
points to tidy  up, bound 

05:11:26.468 --> 05:11:30.604
services are unchanged.
Because we're thinking much more

05:11:30.605 --> 05:11:34.755
 about foreground and background
, there are some semantics of 

05:11:34.756 --> 05:11:38.946
this that are interesting.  So, 
for instance, if I am bounding 

05:11:38.947 --> 05:11:41.021
-- if I'm in the foreground and 
I'm binding to one of my own 

05:11:41.022 --> 05:11:45.193
services, that's no big deal.  
If I'm not foreground and I'm 

05:11:45.194 --> 05:11:47.287
binding to somebody else's 
service and they're in the 

05:11:47.288 --> 05:11:51.429
background, then they, too, will
 be considered foreground.  

05:11:51.430 --> 05:11:53.518
Because a foreground client 
elevates their status to 

05:11:53.519 --> 05:11:55.598
foreground as well.
So these are sort of things that

05:11:57.696 --> 05:12:02.136
, as you start thinking in sort 
of all semantics, in all terms 

05:12:02.137 --> 05:12:08.371
much more, will be very obvious.
  It's not what I was thinking 

05:12:08.372 --> 05:12:10.472
about when I was writing code.  
This is going to be a little bit

05:12:10.473 --> 05:12:18.852
 of an adjustment as we go into 
O.  All right.  Here we go.  

05:12:18.853 --> 05:12:25.104
Question that's asked of me, 
what about intent services?  You

05:12:25.105 --> 05:12:29.277
 have talked about startup 
services, what about intent 

05:12:29.278 --> 05:12:31.339
services?  They are startup 
services.  Everything I have 

05:12:31.340 --> 05:12:35.521
said about startup services 
applies to them.  In fact, this 

05:12:35.522 --> 05:12:41.772
is kind of a big deal.  So the 
support library now has service 

05:12:41.773 --> 05:12:45.937
for the jobintentservice and 
could be considered a 

05:12:45.938 --> 05:12:50.108
replacement for intentservice.  
We'll talk about this in a 

05:12:50.109 --> 05:12:52.186
minute.  Fundamentally we would 
like to start thinking that jobs

05:12:54.279 --> 05:12:56.385
 are the way we want to go about
 this.  Services, expensive 

05:12:56.386 --> 05:13:02.681
broadcasts, are really -- have 
served us well and worked well 

05:13:02.682 --> 05:13:06.821
up until O.  But from now on job
 scheduler, job dispatcher and 

05:13:06.822 --> 05:13:13.090
jobs are a real Swiss Army Knife
 as you go forward building

05:13:13.091 --> 05:13:15.181
 your apps.
So that's services.  A lot of 

05:13:15.182 --> 05:13:17.182
stuff to take in.  A lot of

05:13:19.314 --> 05:13:23.458
 changes.  So I'm going to throw
 more stuff at you now.  

05:13:23.459 --> 05:13:27.623
Background limits and 
broadcasts.  So the limitation 

05:13:27.624 --> 05:13:33.901
is on implicit broadcasts and 
the gist of it is that limits to

05:13:33.902 --> 05:13:40.139
 implicit broadcasts delivered 
to manifest and find reviewers 

05:13:40.140 --> 05:13:42.213
are not going to be honored for 
the most part.

05:13:42.214 --> 05:13:48.462
So at this point, the question 
comes -- what is an explicit 

05:13:48.463 --> 05:13:52.688
broadcast?  An compliment 
broadcast?  You'll see confusing

05:13:52.689 --> 05:13:56.887
 answers about that.  The answer
 is if a broadcast is explicitly

05:13:56.888 --> 05:14:03.132
 targeted at someone, something,
 a target, an app, then you can 

05:14:03.133 --> 05:14:09.394
put it in the manifest.  If it 
is not a broadcast sent out into

05:14:09.395 --> 05:14:13.538
 the wild, it's compliment, 
don't put in the manifest.  

05:14:13.539 --> 05:14:15.631
Take, for example, action 
package  replaced.  If you 

05:14:15.632 --> 05:14:19.789
register for this before O in N 
and lower, you will have this 

05:14:19.790 --> 05:14:26.017
broadcast go off every time any 
package is placed on your 

05:14:26.018 --> 05:14:28.018
device.  That's pretty

05:14:30.089 --> 05:14:36.344
 noisy, right?
In contrast, my package replace.

05:14:36.345 --> 05:14:38.404
  This package is sent only to 
me because my package has been 

05:14:38.405 --> 05:14:42.579
replaced.  So this is kind of a 
big distinction.  It's not 

05:14:42.580 --> 05:14:44.640
always incredibly intuitive.  
But this is something that 

05:14:44.641 --> 05:14:46.737
developers would have to think 
about.  Explicit broadcasts can 

05:14:46.738 --> 05:14:52.976
still be put in the  manifest, 
no problem.  Now, there are some

05:14:57.076 --> 05:15:03.310
 implicit broadcasts that the 
framework team know need to be 

05:15:03.311 --> 05:15:05.391
allowed.  If you follow these, 
there's a good reason why each 

05:15:05.392 --> 05:15:11.622
one of these is permitted to be 
put in O in your manifest.  So 

05:15:11.623 --> 05:15:15.764
action boot completed.  This  
fires once.  It's required by 

05:15:15.765 --> 05:15:17.844
apps to set up jobs, et cetera, 
et cetera.  It's not hugely 

05:15:17.845 --> 05:15:24.104
disruptive.  It's okay.  Action 
locale changed.  Well, your 

05:15:24.105 --> 05:15:28.256
locale presumably doesn't change
 a whole lot, and when it does, 

05:15:28.257 --> 05:15:32.455
it's not unreasonable that apps 
will want to respond to that.  

05:15:32.456 --> 05:15:36.622
Action headset plug.  The user 
plugs in their headset.  So at 

05:15:36.623 --> 05:15:42.852
that point does the user -- 
they're involved.  And some app 

05:15:42.853 --> 05:15:44.937
may want
to respond to that.  This is not

05:15:47.021 --> 05:15:49.082
 hugely disruptive.  When you 
have SMS, you want to respond.  

05:15:49.083 --> 05:15:53.262
This is a partial list.  The 
whole documentation is there on 

05:15:53.263 --> 05:15:59.527
Android.developer.com.  And it 
will explain to you where all 

05:15:59.528 --> 05:16:03.691
these broadcasts -- while 
they're  implicit, are 

05:16:03.692 --> 05:16:07.895
completely okay.
The dynamic registration for 

05:16:07.896 --> 05:16:12.066
broadcast is completely okay.  
Nothing of this has changed.  So

05:16:12.067 --> 05:16:16.222
 you can always use context or 
register receiver, and long as 

05:16:16.223 --> 05:16:20.380
the context is valid, you'll get
 whatever broadcast is 

05:16:20.381 --> 05:16:24.528
registered here.  That's 
completely okay.  It's not 

05:16:24.529 --> 05:16:28.677
changed.  The idea is if the app
 is used with a context, it's 

05:16:28.678 --> 05:16:32.836
not hugely disruptive to get the
 broadcast.  If your app is 

05:16:32.837 --> 05:16:34.901
asleep, that's a different 
thing.

05:16:34.902 --> 05:16:39.056
So that's the way to think about
 these limitations that are 

05:16:39.057 --> 05:16:43.198
being used.  So at this point 
you're thinking, well, this is 

05:16:43.199 --> 05:16:49.496
fantastic for developer -- for 
users, right?  Your battery is 

05:16:49.497 --> 05:16:51.610
preserved, your system health is
 so much better.  No long-

05:16:53.699 --> 05:16:55.790
running services.  All the noise
 generated by these broadcasts, 

05:16:55.791 --> 05:16:59.971
that's pretty much quite a down.
  What about me?  The developer?

05:16:59.972 --> 05:17:04.130
  I had great ideas and plans.  
What am I supposed to do?  So 

05:17:04.131 --> 05:17:10.365
let's talk a little bit about 
that.  What you can do is a 

05:17:10.366 --> 05:17:12.446
bunch of strategies.  So first, 
instead of having  long-running 

05:17:12.447 --> 05:17:18.805
services, if there is some 
stimulus that changes something 

05:17:18.806 --> 05:17:20.888
in your app or that wants to 
change something in your app, 

05:17:20.889 --> 05:17:25.072
use cloud messaging.  It's 
fantastic.  Use cloud messaging.

05:17:25.073 --> 05:17:27.196
  If you use high priority it 
will pierce through those.  It 

05:17:27.197 --> 05:17:31.350
will give you temporary 
foreground status and you're 

05:17:31.351 --> 05:17:35.551
good to go.  If you use normal 
priority, that's still very good

05:17:35.552 --> 05:17:39.696
 because now the operating 
system can judiciously, 

05:17:39.697 --> 05:17:43.876
carefully, efficiently
schedule the work that you want 

05:17:43.877 --> 05:17:45.961
to do.  Normal priority should 
be your default.  You don't want

05:17:45.962 --> 05:17:50.149
 to abuse this.  You want to 
preserve the system health that 

05:17:50.150 --> 05:17:54.358
comes from that.
Another thing is that 

05:17:54.359 --> 05:17:56.444
restructure use  
jobintentservice.  I mentioned 

05:17:56.445 --> 05:18:00.663
that a few slides  ago.  
Jobintentservice is part of the 

05:18:00.664 --> 05:18:04.856
support library.  It's very new.
  It should be considered a 

05:18:04.857 --> 05:18:13.200
replacement for intentservice.  
It's aware of background limits 

05:18:13.201 --> 05:18:15.298
and it will do the right thing. 
 In the apps, it will run 

05:18:15.299 --> 05:18:19.514
context.service.  And O and 
beyond O apps, it will run job

05:18:23.605 --> 05:18:27.805
scheduler for work.  This is a 
pretty good way to have all that

05:18:27.806 --> 05:18:29.906
  abstracted away and you don't 
have to think about  it.

05:18:33.981 --> 05:18:36.055
Wakefulbroadcastreceiver is 
deprecated.  The whole point was

05:18:36.056 --> 05:18:38.176
 that you're handling a 
broadcast when you kick off a 

05:18:38.177 --> 05:18:42.372
service or something like that. 
 You can't do that anymore, 

05:18:42.373 --> 05:18:46.508
there's really no reason to have
 this sticking around.

05:18:46.509 --> 05:18:48.509
And finally

05:18:49.711 --> 05:18:51.816
 -- and this is kind of an 
important conceptual point -- 

05:18:51.817 --> 05:18:53.904
you want the operating system to
 be your friend, right?  So go 

05:18:53.905 --> 05:18:55.964
back to that example I gave of 
somebody taking a picture and it

05:18:58.048 --> 05:19:02.219
 spins off the starting off of 
10, 15, 20 apps.  All of which 

05:19:02.220 --> 05:19:06.353
are now starting services.  At 
that point the operating system 

05:19:06.354 --> 05:19:10.531
can do one of two things: it can
 either run your app, or it can 

05:19:10.532 --> 05:19:14.685
kill your app.  It can not do 
anything else.  It will try to 

05:19:14.686 --> 05:19:16.772
run everything, but when it 
loses the ability to run 

05:19:16.773 --> 05:19:20.931
everything, it kills it.  You 
don't want the  operating system

05:19:20.932 --> 05:19:25.067
 to be turned into a killer.  
You want to schedule -- your 

05:19:25.068 --> 05:19:27.605
work to be scheduled 
intelligently by the operating 

05:19:27.606 --> 05:19:29.606
system.  So for that reason it's
 much better

05:19:30.746 --> 05:19:32.836
 to use jobs.  When you use jobs
 the operating system can say, 

05:19:32.837 --> 05:19:39.084
all right, one, two, three.  I 
run you now.  Four, five -- run 

05:19:39.085 --> 05:19:43.228
you.  One again.  It can 
schedule that intelligently.  

05:19:43.229 --> 05:19:47.376
You want to go for that.  We 
encourage you to use job 

05:19:47.377 --> 05:19:53.655
scheduler as much as you can.
And the big topic topic: you can

05:19:53.656 --> 05:19:57.813
 use foreground services for 
doing all sorts of great work 

05:19:57.814 --> 05:20:01.969
and there are no limits.  So a 
very big temptation would say, 

05:20:01.970 --> 05:20:06.139
oh, my god, so much is changing 
in O.  I'm going to slap on a 

05:20:06.140 --> 05:20:08.225
foreground service and I don't 
have to think about this.  The 

05:20:08.226 --> 05:20:14.562
problem with that is the 
foreground service has a certain

05:20:14.563 --> 05:20:20.863
 meaning.  When I'm listening to
 music, I'm in a fitness app, 

05:20:20.864 --> 05:20:22.953
using maps and navigation, it 
makes sense there's a 

05:20:22.954 --> 05:20:27.154
notification at the top and it's
 doing work for me even when I'm

05:20:27.155 --> 05:20:31.334
 not actively engaging in the 
app.  If that's the case in your

05:20:31.335 --> 05:20:35.503
 apps, use a foreground service.
  It's a fantastic reason.  If 

05:20:35.504 --> 05:20:39.667
not, the user is going to say, 
what the hell, there's a 

05:20:39.668 --> 05:20:45.890
notification at the top telling 
them there's work being done.  

05:20:45.891 --> 05:20:50.072
They can stop the work or 
uninstall your app.  Don't want 

05:20:50.073 --> 05:20:54.237
to happen.  If it doesn't make 
sense, think of the other 

05:20:54.238 --> 05:20:56.327
strategies that we have outlined
 and go with those.

05:20:56.328 --> 05:21:00.507
And finally, since O is pretty 
much putting you in a position 

05:21:00.508 --> 05:21:03.192
where you have to think about 
background and what you're doing

05:21:03.193 --> 05:21:07.390
 in the background, I think it's
 a good time to ask.  Do you 

05:21:07.391 --> 05:21:09.464
really need to do all this 
background work?  I think there 

05:21:09.465 --> 05:21:15.711
has been a sense for many, many,
 many years now in Android that 

05:21:15.712 --> 05:21:17.800
it's cool to just spin up 
something and have it run 

05:21:17.801 --> 05:21:22.020
forever and ever in the 
background and the system will 

05:21:22.021 --> 05:21:24.113
somehow handle it.  Now the 
system is telling you, no, no.  

05:21:24.114 --> 05:21:28.319
We don't want to handle it.  We 
don't want this to happen.  So 

05:21:28.320 --> 05:21:30.394
if we are really at the point 
where we are questioning all 

05:21:30.395 --> 05:21:34.587
this, it's a good time to ask, 
hey, I started doing all this 

05:21:34.588 --> 05:21:38.791
background work three years, 
four years ago in my app, do I 

05:21:38.792 --> 05:21:42.944
really still need to do this?  
The answer sometimes will be no.

05:21:42.945 --> 05:21:47.093
  You don't need to do this.  In
 which case you shouldn't.

05:21:47.094 --> 05:21:51.268
Fast segue to location.  So 
first of all, location is kind 

05:21:51.269 --> 05:21:55.411
of a huge topic.  It's use ared 
in a ton of apps.  In fact, when

05:21:55.412 --> 05:21:57.412
 I started looking  ating

05:21:59.520 --> 05:22:05.744
 at logs to see who was using 
are location, I didn't through 

05:22:05.745 --> 05:22:07.816
all these apps were using 
location.  But they are.  And in

05:22:07.817 --> 05:22:09.817
 Android O, the

05:22:15.911 --> 05:22:20.083
 location is significant.  
People treat location as a 

05:22:20.084 --> 05:22:22.170
battery drain.  They turn off 
location and your apps don't 

05:22:22.171 --> 05:22:26.334
work properly.  We believe this 
doesn't help anyone.  We believe

05:22:26.335 --> 05:22:30.516
 that location should be used 
wisely, efficiently.  It should 

05:22:30.517 --> 05:22:32.517
not be conflated

05:22:34.594 --> 05:22:36.665
 as an automatic battery drain. 
 We want people to love their 

05:22:36.666 --> 05:22:42.897
location apps, right?  So this 
is where kind of big changes 

05:22:42.898 --> 05:22:44.976
have happened in O.  And you 
will  see -- while this may seem

05:22:47.062 --> 05:22:49.136
 a little dramatic at first -- 
you can see how much better an 

05:22:49.137 --> 05:22:51.236
experience this would be going 
forward for app developers.

05:22:53.319 --> 05:22:59.579
So the location limits are the 
background apps will receive 

05:22:59.580 --> 05:23:01.642
location in a very throttled 
way.  So when you're in the 

05:23:01.643 --> 05:23:05.809
foreground, you can pretty much 
request location -- I don't know

05:23:05.810 --> 05:23:09.951
 -- as often as you want.  Say 
you want updates, you can have 

05:23:09.952 --> 05:23:12.029
location updates, 30 seconds, 
whatever.  Once you go in the 

05:23:12.030 --> 05:23:16.183
background, we will give you 
location updates a few times an 

05:23:16.184 --> 05:23:24.509
hour.  That's it.
So this is kind of a big deal.  

05:23:24.510 --> 05:23:30.760
And this will happen regardless 
of the targeted version.  So on 

05:23:30.761 --> 05:23:37.050
your N apps, M apps, L apps -- 
whatever.  This will start 

05:23:37.051 --> 05:23:41.193
happening now the moment all 
devices start appearing.  You 

05:23:41.194 --> 05:23:47.511
can use batching.  And what that
 does, it collects location ever

05:23:47.512 --> 05:23:51.671
 so many times and delivers all 
the location data to you in a 

05:23:51.672 --> 05:23:55.821
batched way.  And that's the way
 that you can get more data 

05:23:55.822 --> 05:23:57.822
points.  You trade

05:23:59.913 --> 05:24:04.076
 trade latency for more data.  
But the data will only be 

05:24:04.077 --> 05:24:08.244
delivered a few times an hour.  
The changes in O and Wi-Fi 

05:24:08.245 --> 05:24:12.379
scanning.  So we could have an 
entire talk about what makes 

05:24:12.380 --> 05:24:16.549
location expensive, what doesn't
 make it expensive.  But GPS is 

05:24:16.550 --> 05:24:22.788
very expensive.  Super-accurate,
 but very expensive.  Wi-Fi 

05:24:22.789 --> 05:24:28.675
isn't actually that cheap.  So 
the deal is no location will be 

05:24:28.676 --> 05:24:30.767
-- when the device is at the 
same static access point.  

05:24:30.768 --> 05:24:34.943
There's no need for it.  Your 
location isn't changing.  We're 

05:24:34.944 --> 05:24:39.087
going to be judicious in making 
Wi-Fi scans.  Because they're 

05:24:39.088 --> 05:24:41.156
expensive.
And this is good for a lot of 

05:24:41.157 --> 05:24:47.393
people.  For me, I spend, I 
don't know, ten, 12, 15 hours at

05:24:49.490 --> 05:24:53.645
 home.  I'm connected to the 
same Wi-Fi.  Why the hell does 

05:24:53.646 --> 05:24:55.728
location services have to 
compute my location over and 

05:24:55.729 --> 05:24:57.840
over?  It's not changing.  
Similarly when I'm at work and I

05:24:59.902 --> 05:25:06.090
 spend eight, ten, hopefully not
 15 hours at work -- again, I'm 

05:25:06.091 --> 05:25:10.261
connected to the same Wi-Fi.  
Nothing is changing.  Why does 

05:25:10.262 --> 05:25:14.465
location service have to expend 
energies trying to compute my 

05:25:14.466 --> 05:25:18.649
location?  Most people spend a 
lot of time at home or at work. 

05:25:18.650 --> 05:25:20.725
 So there's a lot of changes to 
Wi-Fi scanning that actually 

05:25:20.726 --> 05:25:27.002
make O much better.
There's also changes in O to how

05:25:29.103 --> 05:25:33.268
 geofencing works.  So it was 
quite normal up until O to scan 

05:25:33.269 --> 05:25:39.482
for geofencing every few seconds
.  And we have now made that not

05:25:39.483 --> 05:25:43.640
 every few seconds, but around a
 two minute latency.  This is 

05:25:43.641 --> 05:25:47.798
sort of big.  But what we 
noticed is that even going from 

05:25:47.799 --> 05:25:54.100
tens of seconds to two minutes 
for geofencing latency, it was 

05:25:54.101 --> 05:26:00.346
dramatic battery performance.  
In some device, it was 10X.  

05:26:00.347 --> 05:26:04.528
It's device-dependent, so not 
always 10X.  But it was 

05:26:04.529 --> 05:26:10.737
dramatic.  That's another piece 
that's coming..  So up until now

05:26:10.738 --> 05:26:12.823
 everything I have said about 
location is about what happens 

05:26:12.824 --> 05:26:19.060
when you run your M app, L app, 
on an old device.  What happens 

05:26:19.061 --> 05:26:21.135
when you actually start 
targeting O?  What happens to 

05:26:21.136 --> 05:26:23.234
location?
So the first thing is, you know,

05:26:25.298 --> 05:26:29.480
 we have always told you when 
you request locations, use a 

05:26:29.481 --> 05:26:33.655
pending intent.getservice.  
That's one of the arguments you 

05:26:33.656 --> 05:26:39.867
pass to your location request.  
You can't do that anymore 

05:26:39.868 --> 05:26:43.997
because it's O.  There's no 
getservice, background services 

05:26:43.998 --> 05:26:46.068
can't be started.  So you have 
to have a different strategy.  

05:26:46.069 --> 05:26:52.336
And that strategy is you use 
pendingintent.getbroadcast and 

05:26:52.337 --> 05:26:58.612
go and register an explicit 
broadcast in your manifest and 

05:26:58.613 --> 05:27:00.689
that will work.  So the 
targeting of O is not hugely 

05:27:00.690 --> 05:27:06.953
hard.  I think it will -- it 
should be fairly  painless to do

05:27:06.954 --> 05:27:11.152
 it.  Getting adjusted to the 
idea that you are running on O 

05:27:11.153 --> 05:27:15.375
when you hadn't planned to is 
going to be an adjustment.  I 

05:27:15.376 --> 05:27:17.376
would urge all

05:27:19.172 --> 05:27:21.972
 of you to start thinking about 
this task.

05:27:19.172 --> 05:27:23.354
So what are good location 
strategies?  What can you do as 

05:27:23.355 --> 05:27:25.436
developers now?  Frankly, the 
location stuff -- these changes 

05:27:25.437 --> 05:27:29.608
are here now.  Sooner or later 
all devices are going to start 

05:27:29.609 --> 05:27:31.609
running your

05:27:32.682 --> 05:27:35.393
 apps on those O devices, and 
they will notice the location 

05:27:35.394 --> 05:27:37.495
works differently.  So a very 
good  strategy, instead of 

05:27:37.496 --> 05:27:41.668
having long-running services or 
expensive and very fast location

05:27:41.669 --> 05:27:45.841
 updates in the background, is 
to start using geofencing much 

05:27:45.842 --> 05:27:50.037
more.  We have generally found 
that people use geofencing less 

05:27:50.038 --> 05:27:56.294
than we would like them to.  
Geofencing is  very, very, very 

05:27:56.295 --> 05:27:58.295
supremely

05:28:00.370 --> 05:28:04.562
 optimized for  performance.  I 
have a geofence around the 

05:28:04.563 --> 05:28:08.755
Krakow airport and around the 
airport I'll be flying to in a 

05:28:08.756 --> 05:28:10.843
couple of days in San Francisco,
 location services knows there's

05:28:10.844 --> 05:28:17.075
 no reason for it to expend any 
cycles trying to track 

05:28:17.076 --> 05:28:21.234
geofencing.  I'm not there.  But
 it also knows I'm actually not 

05:28:21.235 --> 05:28:27.474
that far from the Krakow 
airport.  It can very causally 

05:28:27.475 --> 05:28:29.718
and
judiciously monitor that.  So a 

05:28:29.719 --> 05:28:33.903
lot of the use cases for 
location updates involve updates

05:28:33.904 --> 05:28:40.148
 around an area.  When am I near
 home?  When am I near a 

05:28:40.149 --> 05:28:42.260
restaurant?  When am I leaving a
 place?  Et cetera, et cetera.  

05:28:42.261 --> 05:28:46.417
And geofencing can be a huge, 
huge asset.  So please use it as

05:28:46.418 --> 05:28:50.599
 much as you can.  Use batching.
  I  promised to talk more about

05:28:50.600 --> 05:28:52.691
 batching.  So I'll do that now.
  Essentially, what you're doing

05:28:52.692 --> 05:28:54.758
 is, when you're in the 
background, you're only going to

05:28:54.759 --> 05:28:58.908
 get updates a few times an 
hour.  But you can get more data

05:28:58.909 --> 05:29:03.184
 points as long as you're 
prepared to give up the -- the 

05:29:03.185 --> 05:29:09.412
tradeoff is with latency.  So 
look at this.  So you create a 

05:29:09.413 --> 05:29:14.798
location request.  You set  its 
interval to be ten minutes.  So 

05:29:14.799 --> 05:29:16.874
say give my location updates 
every ten minutes.  And then you

05:29:16.875 --> 05:29:21.046
 say, but deliver them no later 
than 30 minutes.  So in a normal

05:29:21.047 --> 05:29:25.211
 situation, what will happen is 
you will get three location data

05:29:25.212 --> 05:29:29.418
 points every 30 minutes in this
 kind of a case.  If you didn't 

05:29:29.419 --> 05:29:33.590
set the max wait time, you would
 not

05:29:33.591 --> 05:29:37.737
get batching, and therefore you 
would miss out on data points.

05:29:37.738 --> 05:29:41.906
Another very, very important 
location strategy in the age of 

05:29:41.907 --> 05:29:46.084
O is to get your location 
passively.  So what are we 

05:29:46.085 --> 05:29:50.255
talking about here?  Basically, 
location is computed on a device

05:29:50.256 --> 05:29:54.412
 basis.  Not just an app basis. 
 So when your app is in the 

05:29:54.413 --> 05:29:58.585
background, and therefore 
getting fairly infrequent 

05:29:58.586 --> 05:30:02.785
location updates, another device
 -- another app -- may be in the

05:30:02.786 --> 05:30:04.912
 foreground.  It may be a 
mapping app or another app that 

05:30:04.913 --> 05:30:11.142
gets location updates quite a 
lot.  Location services, free of

05:30:11.143 --> 05:30:13.203
 charge, will make that stuff 
available to you -- the data 

05:30:13.204 --> 05:30:17.378
points available to you -- and 
to any other app that's in the 

05:30:17.379 --> 05:30:21.551
background.  This kind of 
opportunistic location gathering

05:30:21.552 --> 05:30:27.806
 I think is extremely good.  
It's -- we believe it's 

05:30:27.807 --> 05:30:29.894
underutilized and we would like 
developers to use it much more. 

05:30:29.895 --> 05:30:34.070
 So here's an example how you 
can do that.  Again, you create 

05:30:34.071 --> 05:30:38.221
a location request.  You set the
 interval to ten minutes.  You 

05:30:38.222 --> 05:30:42.387
set the max wait time for 
batching to 30 minutes.  Then 

05:30:42.388 --> 05:30:46.520
you set the fastest interval to,
let's say, two minutes.  Meaning

05:30:48.605 --> 05:30:52.746
, if I'm in the background and 
anybody else is consuming 

05:30:52.747 --> 05:30:56.909
location data, every couple of 
minutes let me know about the 

05:30:56.910 --> 05:30:58.969
data.  And given the sheer 
number of apps that use 

05:30:58.970 --> 05:31:01.064
location, there's a pretty good 
chance that when the user is 

05:31:01.065 --> 05:31:05.227
using their phone or something 
else, they will be gathering 

05:31:05.228 --> 05:31:07.321
location data and then you can 
have it for free.

05:31:07.322 --> 05:31:13.551
So that's a very important 
strategy.  I would urge all of 

05:31:13.552 --> 05:31:17.681
you to use it.  While you're 
down all this, you know, because

05:31:17.682 --> 05:31:24.263
 of these changes in O, we're 
putting development in a 

05:31:24.264 --> 05:31:26.344
position where they kind of had 
to rethink their location 

05:31:26.345 --> 05:31:30.480
strategies from scratch.  If 
you're going to do that, think 

05:31:30.481 --> 05:31:36.703
of it for pre-O apps also.  If 
you're running an N, M, or L 

05:31:36.704 --> 05:31:42.950
app, that too can use the same 
principles put forward in O and 

05:31:42.951 --> 05:31:45.015
become more battery efficient.  
Why wait?  You can start making 

05:31:45.016 --> 05:31:49.147
things better now.
So fundamentally location is 

05:31:49.148 --> 05:31:53.318
expensive in one of three ways 
related to frequency, latency, 

05:31:53.319 --> 05:32:01.642
or accuracy.  So O is saying to 
us on the frequency axis

05:32:03.729 --> 05:32:05.797
, when you're in the background,
 don't be so frequent.  You can 

05:32:05.798 --> 05:32:12.030
implement that now for your M 
and N apps.  Again, latency.  

05:32:12.031 --> 05:32:14.115
Sometimes it's okay -- sometimes
 you want the real-time 

05:32:14.116 --> 05:32:18.272
experience.  But sometimes it's 
actually okay to wait a few 

05:32:18.273 --> 05:32:20.360
seconds before you get the 
location data that has been 

05:32:20.361 --> 05:32:22.446
computed for you.  So use 
batching, like we just talked 

05:32:22.447 --> 05:32:28.660
about.  You can do that now.  If
 you're using geofence, you can 

05:32:28.661 --> 05:32:32.828
use a responsiveness time.  The 
more you give it, the better 

05:32:32.829 --> 05:32:34.900
your battery performance will 
be.  You can do all of these 

05:32:34.901 --> 05:32:41.320
things now for your apps.
And when you're at it, I mean, O

05:32:41.321 --> 05:32:45.500
 isn't really dealing with 
accuracy that much.  If you're 

05:32:45.501 --> 05:32:47.606
rethinking everything in regards
 to location, you might as well 

05:32:47.607 --> 05:32:53.868
say, do I really need high 
accuracy all the time?  Maybe I 

05:32:53.869 --> 05:32:55.938
can use a balance power 
accuracy, maybe no power.  There

05:32:55.939 --> 05:33:00.093
 are a lot of  options.  You can
 read our documentation on this.

05:33:00.094 --> 05:33:04.238
  Do I need the best, greatest, 
most expensive location updates 

05:33:04.239 --> 05:33:10.488
all the time?  Probably not.  
And finally, foreground 

05:33:10.489 --> 05:33:14.668
services.  You can go right 
ahead and just completely bypass

05:33:16.758 --> 05:33:18.834
 all these location limits in O 
by running a foreground service.

05:33:18.835 --> 05:33:22.995
  But you just have to make sure
 the user will really approve of

05:33:22.996 --> 05:33:27.155
 that service.  Otherwise they 
will get annoyed with your app 

05:33:27.156 --> 05:33:29.232
and probably uninstall it.  
Don't want that.

05:33:29.233 --> 05:33:35.459
That's basically it.  A lot of 
stuff.  I'm around if you have 

05:33:35.460 --> 05:33:39.593
apps that you think are going to
 be now struggling with some of 

05:33:39.594 --> 05:33:41.658
these O limits, please come and 
talk to me.  I would love to 

05:33:41.659 --> 05:33:47.889
hear your story.  And happy 
coding.  Thank you.

05:33:51.965 --> 05:33:53.965
[ Applause ]

05:46:28.389 --> 05:46:35.036
&gt;&gt; Hello, everyone.  Welcome to 
machine  learning APIs by 

05:46:35.037 --> 05:46:39.244
example.  I'm going to teach you
 how you can use pre-trained 

05:46:39.245 --> 05:46:45.539
APIs to access  pre-trained AI 
models.  I'm Sara Robinson,

05:46:49.629 --> 05:46:53.800
 Srob Tweets.  I focus on then 
in learning and big data.  I'm 

05:46:53.801 --> 05:46:57.953
based in New York.  This is my 
first time in Poland.  Super-

05:47:00.038 --> 05:47:02.123
computed to be here.
[ Applause ]

05:47:02.124 --> 05:47:04.251
Thank you.  I'm going to talk 
about what machine learning is. 

05:47:04.252 --> 05:47:06.326
 At a high level, machine  
learning is teaching computers 

05:47:06.327 --> 05:47:12.596
to recognize patterns in the way
 that our brains do.  Over time,

05:47:12.597 --> 05:47:14.684
 as machine learning models are 
given more examples and 

05:47:14.685 --> 05:47:16.836
experience, they can improve.  
And with more data, able to

05:47:20.911 --> 05:47:22.978
 make better predictions.  It's 
easy for a child to look at a 

05:47:22.979 --> 05:47:27.153
cat and a dog.  But it's much 
more difficult to teach a 

05:47:27.154 --> 05:47:31.314
computer to do the same thing.  
Pretend we don't have any 

05:47:31.315 --> 05:47:35.473
machine learning models or deep 
neural networks.  And try  human

05:47:37.526 --> 05:47:41.672
-powered image detection.  If we
 were to write an algorithm to 

05:47:41.673 --> 05:47:43.734
differentiate between the two, 
what are some things to look 

05:47:43.735 --> 05:47:47.896
for?  Shout it out.  I heard 
color.  That's a good one.  So 

05:47:47.897 --> 05:47:54.134
for color, are the majority of 
the pixels red?  If so, it's an 

05:47:54.135 --> 05:47:58.276
apple, otherwise it's an orange.
  That would work pretty well in

05:47:58.277 --> 05:48:00.363
 this example.  But what if we 
have gray scale images.  We have

05:48:02.433 --> 05:48:08.663
 to start over again.  Some 
things so look for?  Stem, 

05:48:08.664 --> 05:48:10.775
texture.  We
could look at those qualities 

05:48:10.776 --> 05:48:17.027
and take us through the gray 
scale images.  What if we got 

05:48:17.028 --> 05:48:23.280
crazy and added a mango to the 
equation?  Then we start over.  

05:48:23.281 --> 05:48:29.541
You  getted why the.  They're 
all similar.  They're fruit and 

05:48:29.542 --> 05:48:33.694
circular.  It would be a lot 
easier with two images that look

05:48:33.695 --> 05:48:37.865
 nothing alike.  What if we have
 a picture of a dog and a mop.  

05:48:37.866 --> 05:48:42.079
They have pretty much nothing in
 common.  The mop is not living 

05:48:42.080 --> 05:48:46.229
or  breathing, no eyes, nose, or
 ears.  It's actually kind of 

05:48:46.230 --> 05:48:48.327
difficult.
So here we have pictures of 

05:48:48.328 --> 05:48:52.487
sheep dogs and  mops, four of 
each.  It's kind of hard, even 

05:48:52.488 --> 05:48:56.634
for the human eye, to be able to
 distinguish between the  two.  

05:48:56.635 --> 05:49:00.801
So the point I'm trying make 
here, what if we have photos of 

05:49:00.802 --> 05:49:02.886
everything?  We don't know what 
 photos our users in our 

05:49:02.887 --> 05:49:07.058
application might upload.  Might
 not just be fruits or animals. 

05:49:07.059 --> 05:49:11.235
 We'll have photos of all sorts 
of things.  And in in addition 

05:49:11.236 --> 05:49:15.382
to photos, we might have other 
types of unstructured data such 

05:49:15.383 --> 05:49:21.641
as video, audio were text.  And 
on Google Cloud Platform, there 

05:49:21.642 --> 05:49:25.788
are two ways to make sense of 
the sun structured data.  If you

05:49:25.789 --> 05:49:28.667
 want to build and train your 
own machine learning from 

05:49:28.668 --> 05:49:35.752
scratch, we have TensorFlow.  If
 you want to run it on managed 

05:49:35.753 --> 05:49:37.825
Google infrastructure, you can 
use cloud machine learning 

05:49:37.826 --> 05:49:40.313
engine.  What I'm going to focus
 on today is the right-hand 

05:49:40.314 --> 05:49:42.388
side.  This is what I like to 
call friendly machine learning. 

05:49:42.389 --> 05:49:46.561
 So these are APIs that give you
 access to pre-trained models 

05:49:46.562 --> 05:49:50.741
with a single REST API request. 
 I'm

05:49:50.742 --> 05:49:52.812
going to cover all these APIs in
 the presentation.  And I'll

05:49:56.899 --> 05:49:58.972
 dive right in with the vision 
API.  It's a complex image

05:50:03.069 --> 05:50:07.232
 request with a REST API rest.  
First, companies that are using 

05:50:07.233 --> 05:50:11.382
it in production.  The example 
on the left is Disney.  They use

05:50:13.444 --> 05:50:17.601
 a vision API for a game for 
Pete's Dragon.  It was a 

05:50:17.602 --> 05:50:21.761
scavenger hunt-type game.  They 
had to take a picture of an item

05:50:23.850 --> 05:50:28.036
, a couch or a computer.  If 
they took a picture of the item,

05:50:28.037 --> 05:50:32.189
 the app would superimpose 
Elliott the dragon on the photo.

05:50:32.190 --> 05:50:34.266
  They needed to verify that the
 user's image matched the clue 

05:50:34.267 --> 05:50:40.513
it was given, and the vision API
 was a great fit for that.  

05:50:40.514 --> 05:50:44.677
Realtor.com is a real estate 
service and use the recognition 

05:50:44.678 --> 05:50:48.821
feature to extract text.  So 
when somebody is looking for 

05:50:48.822 --> 05:50:52.955
houses and they use the 
Realtor.com app.  They can take 

05:50:52.956 --> 05:50:57.127
a picture of the for sale sign 
and be immediately connected to 

05:50:57.128 --> 05:51:01.303
the correct listing.  They are 
using the vision API to extract 

05:51:01.304 --> 05:51:05.425
the text and direct them to the 
relevant listing.

05:51:05.426 --> 05:51:09.584
These are the core features.  
Label detection will tell you 

05:51:09.585 --> 05:51:13.751
what is this a picture of.  Face
 detection will tell you, are 

05:51:13.752 --> 05:51:15.824
there faces in the image?  Where
 are the faces located and what 

05:51:15.825 --> 05:51:22.074
are the different emotions?  
Happy?  Sad?  Angry or  

05:51:22.075 --> 05:51:26.219
surprised?  I mentioned with 
real

05:51:30.297 --> 05:51:34.465
 Realtor.com, and you can 
extract the image.  And content 

05:51:34.466 --> 05:51:38.642
detection will tell you, is this
 image appropriate or not?  And 

05:51:38.643 --> 05:51:41.627
this is useful for pretty much 
any site with  user-generated 

05:51:41.628 --> 05:51:43.628
content.  So you can -- instead 
of

05:51:44.630 --> 05:51:46.723
 having somebody manually review
 the content, is it appropriate 

05:51:46.724 --> 05:51:52.935
or not?  You can send to the 
APIs and only review a subset of

05:51:52.936 --> 05:51:57.066
 the images.  And landmark 
detection and logo detection can

05:51:59.152 --> 05:52:03.302
 find company logos in an image.
  To look at the responses.  

05:52:03.303 --> 05:52:07.477
Face detection.  This is a 
selfie with two of my teammates.

05:52:07.478 --> 05:52:09.544
  We took this last year in 
Jordan.  And face detection 

05:52:09.545 --> 05:52:11.545
returns an

05:52:12.629 --> 05:52:14.715
 object for each face it finds 
on the image.  The JSON response

05:52:14.716 --> 05:52:21.139
 we see is just for my face.
Head wear, unlikely, I'm not 

05:52:21.140 --> 05:52:25.298
wearing a hat.  Both teammates 
are.  And joy likelihood, very  

05:52:25.299 --> 05:52:29.502
likely.  I was excited, on 
vacation, taking selfies.  And 

05:52:29.503 --> 05:52:35.780
returns data on where features 
are.  And then if we look at 

05:52:35.781 --> 05:52:37.863
landmark detection, you can take
 this picture of a common 

05:52:37.864 --> 05:52:42.050
landmark.  This is the Eiffel 
tower, right?  It's actually not

05:52:42.051 --> 05:52:49.155
 the Eiffel tower.  It is the 
Paris hotel and casino in Las 

05:52:49.156 --> 05:52:52.133
Vegas.  And I wanted to see if 
the vision API could spot the 

05:52:52.134 --> 05:52:56.311
difference.  It could.  It 
correctly identified this as the

05:52:56.312 --> 05:53:00.475
 Paris hotel and casino.  And 
you'll notice that the MID and 

05:53:00.476 --> 05:53:04.627
the response.  The MID maps to 
Google's knowledge graph.  If 

05:53:04.628 --> 05:53:08.793
you want more information on the
 entity, send to the knowledge 

05:53:08.794 --> 05:53:10.876
graph API to get more 
information on the Paris hotel 

05:53:10.877 --> 05:53:17.104
and casino.  We get a box of 
where this is found, and the 

05:53:17.105 --> 05:53:23.354
latitude, longitudinal.  And 
additional features in the 

05:53:23.355 --> 05:53:27.510
vision API, one is crop hints.  
Suggested crop dimensions for 

05:53:27.511 --> 05:53:31.678
the photo.  Web annotations, 
search the at the time had for

05:53:31.679 --> 05:53:33.765
details on your image.  And I'll
 get into that more.  And 

05:53:33.766 --> 05:53:40.017
document text annotations 
improves the OCR model for the 

05:53:40.018 --> 05:53:46.224
APIs.  So it's easier to 
identify large blocks of text.  

05:53:46.225 --> 05:53:48.225
If you have an image

05:53:50.306 --> 05:53:52.388
 of a menu or business card, it 
can break it down into words and

05:53:54.474 --> 05:53:56.546
 symbols.  I want to focus more 
on the web annotations.  And to 

05:53:56.547 --> 05:54:00.740
do that, I have this image of a 
car.  It's not just any car.  

05:54:00.741 --> 05:54:02.828
It's the car from the Harry 
Potter movies.  I'm a big Harry 

05:54:02.829 --> 05:54:07.020
Potter fan and it's on display 
in a museum.  This is the car 

05:54:07.021 --> 05:54:11.160
from the second movie.  I wanted
 to see what entities the is web

05:54:11.161 --> 05:54:15.294
 annotations end point was able 
to find.  The first one I found 

05:54:15.295 --> 05:54:23.627
was this is a Ford Anglia, which
 is the correct kind of car.  

05:54:23.628 --> 05:54:27.771
And the museum in Singapore 
where it's currently on display.

05:54:27.772 --> 05:54:31.927
  And finally, it was able to 
tell me this is from Harry 

05:54:31.928 --> 05:54:34.016
Potter.  So the way that it does
 this, it finds similar images 

05:54:34.017 --> 05:54:38.172
from across the web, and based 
on the context of the pages 

05:54:38.173 --> 05:54:40.267
where those other images were 
found, it's

05:54:40.268 --> 05:54:44.420
able to extract these entities.
We also get -- in addition to 

05:54:44.421 --> 05:54:48.571
the entities, we will get 
additional details on the image.

05:54:50.673 --> 05:54:52.754
  We'll get all the URLs where 
the image is found.  This is 

05:54:52.755 --> 05:54:56.918
useful if you have an app where 
users are uploading images and 

05:54:56.919 --> 05:54:58.993
you want to make sure the image 
is  theirs, unique, hasn't been 

05:54:58.994 --> 05:55:03.307
seen before.  You can use full 
matching images to guarantee 

05:55:03.308 --> 05:55:05.992
that.  Patient matching images, 
exactly what it sounds.  It will

05:55:08.076 --> 05:55:12.546
 give you URLs of visually 
similar images.  This is like a 

05:55:12.547 --> 05:55:14.547
reverse

05:55:15.672 --> 05:55:17.732
 search.  We might see images of
 the car in another context.  

05:55:17.733 --> 05:55:21.902
And page matching, show the URL 
where all the exact image 

05:55:21.903 --> 05:55:26.036
matches were found.
You can try this in the browser 

05:55:26.037 --> 05:55:30.198
with your own images.  Go to 
cloud.google.com/vision.  Try it

05:55:30.199 --> 05:55:34.337
 out and see if it's right for 
your application before you 

05:55:34.338 --> 05:55:36.414
start writing code.  And in case
 you were  wondering about the 

05:55:36.415 --> 05:55:40.608
sheep dog versus mop example 
from before, this is what the 

05:55:40.609 --> 05:55:44.780
API returned for the bottom 
picture.  It's 99% sure that 

05:55:44.781 --> 05:55:53.083
it's a dog, and even 77% that 
it's a Komondor -- the exact 

05:55:53.084 --> 05:55:55.175
creed of dog this is.  And able 
to identify this as a broom or 

05:55:55.176 --> 05:55:59.364
tool.  I won't show you the 
response for all of them.  But 

05:55:59.365 --> 05:56:03.505
the API identified three out of 
four correctly.  Which is good 

05:56:03.506 --> 05:56:07.682
considering this model wasn't 
trained to specifically identify

05:56:07.683 --> 05:56:11.845
 pictures of sheep dogs and 
mops.  It was able to off almost

05:56:11.846 --> 05:56:14.643
 all of them correctly.
So that was the

05:56:17.662 --> 05:56:21.853
 vision API.  Now I want to move
 into the speech API, that let's

05:56:21.854 --> 05:56:26.028
 you implement speech to text 
transcription in your 

05:56:26.029 --> 05:56:30.197
applications in over 110 
languages.  One company using 

05:56:30.198 --> 05:56:34.351
this API  is Azar.  This is a 
chat application.  They have 

05:56:34.352 --> 05:56:38.484
connected over 15 million 
matches so far and they're using

05:56:38.485 --> 05:56:44.757
 the speech API any time an 
audio snippet is sent.  They'll 

05:56:44.758 --> 05:56:51.811
transcribe with the speech API. 
 And the translation API.  Any 

05:56:51.812 --> 05:56:55.952
time the two matches don't use 
the same language, transcribe is

05:56:55.953 --> 05:57:00.099
 with the speech API and 
translate it into the host 

05:57:00.100 --> 05:57:04.264
language.
We recently launched a new 

05:57:04.265 --> 05:57:06.402
feature in the speech API a 
couple of weeks ago, speech time

05:57:08.475 --> 05:57:10.545
  stamps.  So if you specify in 
your API request, instead of 

05:57:10.546 --> 05:57:14.687
just getting the transcription, 
you'll get the start and end 

05:57:14.688 --> 05:57:18.864
time for each word in the 
transcription, making it easy to

05:57:18.865 --> 05:57:23.551
 search for text within your 
audio.  So I'm going to go into 

05:57:23.552 --> 05:57:25.552
a demo shortly of the API.

05:57:26.616 --> 05:57:28.681
  Briefly, I'm going to explain 
how it works.  I wrote a batch 

05:57:28.682 --> 05:57:32.849
script that's going to call the 
speech API.  First it will make 

05:57:32.850 --> 05:57:37.026
a  recording using SoX, a 
command line utility for audio. 

05:57:37.027 --> 05:57:39.103
 Then create an API request in a
 JSON file, send it to the 

05:57:39.104 --> 05:57:43.243
speech API and then receive the 
response back.

05:57:43.244 --> 05:57:49.513
So let's go to the demo.  Cool. 
 So the way that I'm going to 

05:57:49.514 --> 05:57:51.600
call my script is just with

05:57:55.692 --> 05:57:59.856
  bash.sh.  And I'm going to 
record something.  Here we go.  

05:57:59.857 --> 05:58:06.105
I am super-excited to be in 
Krakow, Poland, for Google 

05:58:06.106 --> 05:58:08.177
Developer Days Europe.  And I'm 
going to send that to the API.  

05:58:08.178 --> 05:58:14.441
While I do that, this is when 
the request file looks like.  It

05:58:16.516 --> 05:58:18.595
 did a pretty good job.  It's 
93% confident that it 

05:58:18.596 --> 05:58:20.657
transcribed it correctly.  I 
want to briefly talk about what 

05:58:20.658 --> 05:58:24.817
the request file looks like.  So
 here in how config, we need to 

05:58:24.818 --> 05:58:31.060
tell the API the encoding type 
of our audio using flak, the 

05:58:31.061 --> 05:58:35.224
sample rate and hertz.  The 
language code -- if you leave 

05:58:35.225 --> 05:58:39.397
this out, defaults to English.  
Transcribing in another 

05:58:39.398 --> 05:58:41.460
language, just specify the 
language code you're using.  You

05:58:41.461 --> 05:58:45.617
 can optionally pass in some 
phrases.  If you have proper 

05:58:45.618 --> 05:58:47.696
nouns specific to the 
application that the API may not

05:58:49.794 --> 05:58:51.860
 recognize normally, you can 
give it hints of things to look 

05:58:51.861 --> 05:58:56.015
for.  We can also give it a 
parameter called max 

05:58:56.016 --> 05:58:58.113
alternatives.  You
notice here we got three 

05:58:58.114 --> 05:59:00.190
possible transcriptions back.  
So you can use max  alternatives

05:59:00.191 --> 05:59:04.324
 to specify that.  And this then
 you can pass your content as an

05:59:04.325 --> 05:59:10.555
 encoded string or as the URL of
 an audio file stored in Google 

05:59:10.556 --> 05:59:12.643
cloud storage.  That is how the 
speech API works.  And I have 

05:59:12.644 --> 05:59:18.901
one more speech API demo I want 
to show you to highlight the 

05:59:18.902 --> 05:59:23.090
timestamps feature.  Here I have
 a video talking about the 

05:59:23.091 --> 05:59:25.162
Google platform pricing 
philosophy.  And below the video

05:59:25.163 --> 05:59:29.309
 I have a transcription that the
 speech API gave back.  Now, 

05:59:29.310 --> 05:59:33.466
what I can do with timestamps, 
is I built a demo that we can 

05:59:33.467 --> 05:59:35.536
search through the transcript, 
essentially.  So if I click on 

05:59:35.537 --> 05:59:39.733
this, we can skip to the exact 
point in our audio where this 

05:59:39.734 --> 05:59:45.957
occurs.  Is if I go to another 
line, you get the idea.  So the 

05:59:45.958 --> 05:59:48.026
timestamps feature I'm really 
excited about.  Because it makes

05:59:50.089 --> 05:59:52.167
 it easy to search a large 
library of video content using 

05:59:52.168 --> 05:59:57.124
the transcription.  The way that
 I did this was that I extracted

05:59:57.125 --> 05:59:59.344
 the audio from the video and 
sent it

05:59:59.345 --> 06:00:03.554
to the speech API.
And I have a bunch of videos 

06:00:03.555 --> 06:00:07.721
about Cloud, Firebase.  So say I
 want to search for all my 

06:00:07.722 --> 06:00:09.812
videos that mention Firebase.  I
 can do that here and I can 

06:00:09.813 --> 06:00:14.144
actually jump to the exact 
moment in the video where I see 

06:00:14.145 --> 06:00:18.436
Firebase.  This video is a 
screen cast tutorial about 

06:00:18.437 --> 06:00:22.622
Firebase Hosting, and we can see
 all the points that mention 

06:00:22.623 --> 06:00:24.690
Firebase.  Which is pretty cool.
  In this video, we've only got 

06:00:24.691 --> 06:00:28.867
one mention of Firebase.  So if 
our job was to look through the 

06:00:28.868 --> 06:00:33.004
video and find all the mentions 
of Firebase, chances are we 

06:00:33.005 --> 06:00:37.145
might miss it.  But with the 
speech API's timestamp feature, 

06:00:37.146 --> 06:00:39.228
we're able to jump right to that
 point in the video.

06:00:39.229 --> 06:00:43.399
So that's an example of the 
timestamps feature of the speech

06:00:43.400 --> 06:00:49.673
 API.  We can go back to the 
slides now.  So with the speech 

06:00:49.674 --> 06:00:51.739
API you can transcribe audio.  
Once you have that text 

06:00:51.740 --> 06:00:55.936
transcription, the next thing 
you might want to do is extract 

06:00:55.937 --> 06:01:00.128
more data from it.  And that's 
where the natural language API 

06:01:00.129 --> 06:01:04.279
comes into play.  So with the 
natural language API, you can 

06:01:04.280 --> 06:01:08.454
extract entities, sentiment, and
 syntax from your text.  One 

06:01:08.455 --> 06:01:12.616
company that's using it is 
Wotric.  And they're a customer 

06:01:12.617 --> 06:01:14.705
feedback platform.  So what they
 enabled customers to do, if you

06:01:14.706 --> 06:01:18.874
 look at the box in the top 
right, the customers place these

06:01:18.875 --> 06:01:23.005
 feedback forms in many various 
places throughout the 

06:01:23.006 --> 06:01:27.151
application and ask how is the 
experience on a speck page from 

06:01:27.152 --> 06:01:31.279
zero to ten.  They rate the 
experience with open-ended 

06:01:31.280 --> 06:01:37.549
feedback.  And Wootric's job is 
to make sense of the feedback.  

06:01:37.550 --> 06:01:41.716
It's easy to make sense of the 
numbered feedback, but it's 

06:01:41.717 --> 06:01:43.772
difficult with the open-ended 
text.  They're using all three 

06:01:43.773 --> 06:01:45.877
of the natural language API to 
do

06:01:45.878 --> 06:01:50.046
this.  Entity and syntax 
annotation to extract the 

06:01:50.047 --> 06:01:54.223
subject and see how people are 
talking about different topics. 

06:01:54.224 --> 06:01:56.319
 And sentiment analysis to 
gauge, did the number scored 

06:01:56.320 --> 06:02:00.476
line up with the open-ended 
feedback that they gave?  And so

06:02:00.477 --> 06:02:06.734
 this enabled them to do things 
like say they have a high 

06:02:06.735 --> 06:02:10.917
priority customer who is angry 
about usability.  They can route

06:02:10.918 --> 06:02:17.166
 it.  And they are able to route
 and respond in near real-time, 

06:02:17.167 --> 06:02:19.241
instead of having people 
manually go through each 

06:02:19.242 --> 06:02:23.383
open-ended response.  I want to 
talk about each of the three 

06:02:23.384 --> 06:02:27.530
methods of the natural language 
API.  The first is extracting 

06:02:27.531 --> 06:02:31.731
entities.  I have a Harry Potter
 example again.  I took a 

06:02:31.732 --> 06:02:35.878
sentence about J.K. Rowling from
 her Wikipedia page and I wanted

06:02:35.879 --> 06:02:40.043
 to find what was in the 
example.  I got these five back.

06:02:40.044 --> 06:02:44.208
  And looking  closely at the 
JSON response it gave for each 

06:02:44.209 --> 06:02:46.295
one.
So it notice these are three 

06:02:46.296 --> 06:02:50.452
different ways of referring to 
J.K. Rowling.  The third one is 

06:02:50.453 --> 06:02:54.657
a pen name for a different 
series.  That's a topic for 

06:02:54.658 --> 06:02:58.830
another talk.  But all point to 
her Wikipedia page.  It's able 

06:02:58.831 --> 06:03:02.979
to normalize the mentions of the
 same thing.  In our JSON 

06:03:02.980 --> 06:03:09.216
response we get back the name, 
the type of entity -- she's a 

06:03:09.217 --> 06:03:13.420
person.  And the metadata, and 
maps to her knowledge graph.  

06:03:13.421 --> 06:03:15.518
And then the Wikipedia

06:03:19.610 --> 06:03:25.826
 URL for her.  And similarly, 
maps to the United Kingdom.  It 

06:03:25.827 --> 06:03:30.019
would have mapped to the same 
entity ID.  And a similar one 

06:03:30.020 --> 06:03:34.189
for Harry Potter.  And if you 
have entities that don't have a 

06:03:34.190 --> 06:03:36.256
Wikipedia page associated with 
them, the

06:03:40.356 --> 06:03:44.538
 API will identify those, just 
no metadata.  If it said my 

06:03:44.539 --> 06:03:48.685
name, the metadata would be 
empty because I don't have a 

06:03:48.686 --> 06:03:52.870
Wikipedia page.  Not yet at 
least.

06:03:52.871 --> 06:03:54.948
And analyze sentiment.  This 
might be on a restaurant review.

06:03:57.075 --> 06:04:01.224
  The food was terrible.  I will
 not be going back.  If I was a 

06:04:01.225 --> 06:04:05.418
manager of the restaurant, I 
want to flag and respond.  I 

06:04:05.419 --> 06:04:11.673
don't want to go through all the
 reviews.  But I can get data on

06:04:11.674 --> 06:04:15.855
 the sentiment of the text.  Two
 values.  The first is score.  

06:04:15.856 --> 06:04:22.061
And score will tell us on a 
negative one to one, how 

06:04:22.062 --> 06:04:24.128
positive or negative?  And 
magnitude tells us, regardless 

06:04:24.129 --> 06:04:28.278
of positive or negative, how 
strong is it?  This is zero to 

06:04:28.279 --> 06:04:32.446
infinity normalized to the 
length of the text.  Since this 

06:04:32.447 --> 06:04:36.601
is short, we get a small number 
of .9.  And then the last method

06:04:36.602 --> 06:04:42.860
 of the API  is analyzing 
syntax.  Gives us more 

06:04:42.861 --> 06:04:44.941
linguistic details on the 
content of the text.  Here we 

06:04:44.942 --> 06:04:49.098
have the language, the natural 
language API helps us understand

06:04:49.099 --> 06:04:53.279
 text.  The first is a 
dependency graph.  This is a 

06:04:53.280 --> 06:04:59.506
dependency parse tree that tells
 us how the different words 

06:04:59.507 --> 06:05:01.582
relate to each other.  This is 
one of the pieces of data we get

06:05:01.583 --> 06:05:07.838
 back.  And we get the parse
label, which tells us the role 

06:05:07.839 --> 06:05:12.009
of each word in the seasons.   
Helps is the root word, API  is 

06:05:12.010 --> 06:05:16.178
the nominal subject.  Tells us 
the word of each word.  And part

06:05:16.179 --> 06:05:20.342
 of speech.  Tells us an 
adjective, a verb, a pro noun.  

06:05:20.343 --> 06:05:28.718
And then Lemma, the canonical 
form of the verb.  And here, the

06:05:28.719 --> 06:05:34.950
 helps, con noncal form is help.
  And when you are are counting 

06:05:34.951 --> 06:05:37.023
how many times they happen, you 
don't want to count helps and 

06:05:37.024 --> 06:05:41.164
help as two separate mentions, 
they're one word.  So you would 

06:05:41.165 --> 06:05:47.407
use the canonical way to do 
that.  And then morphology in 

06:05:47.408 --> 06:05:49.485
the text.  This is going to be 
different depending on which 

06:05:49.486 --> 06:05:53.656
language you send to the API.  
This is a visualization of all 

06:05:53.657 --> 06:05:57.853
the JSON you get back.  You can 
create your own if you go to the

06:05:57.854 --> 06:05:59.942
 natural language products page.
  There's a try it in the 

06:05:59.943 --> 06:06:06.170
browser.  You can enter your own
 text -- I'll share a link -- 

06:06:06.171 --> 06:06:08.252
you can enter your own text and 
share the  visualizations as 

06:06:08.253 --> 06:06:14.496
well.  So now a demo know 
focused on the syntax end point 

06:06:14.497 --> 06:06:16.963
how to use that in an 
application.  I

06:06:14.497 --> 06:06:18.696
have been running some natural 
language processing on Tweets 

06:06:18.697 --> 06:06:27.011
using the #GDD Europe.  And I 
called a node script with the 

06:06:27.012 --> 06:06:29.094
Twitter  streaming APU and 
looking for Tweets with that 

06:06:29.095 --> 06:06:35.351
hashtag.  It won't give me all 
the Tweets, but it will give me 

06:06:35.352 --> 06:06:39.512
a subset of Tweets.  And I take 
the Tweets and take the text and

06:06:39.513 --> 06:06:41.595
 send that through to the 
natural language API for 

06:06:41.596 --> 06:06:45.754
processing and store in big 
query.  That's Google cloud 

06:06:45.755 --> 06:06:49.933
platform's big data as a service
 tool.  It lets you analyze 

06:06:49.934 --> 06:06:52.014
really large data sets 
super-fast.

06:06:54.108 --> 06:06:58.292
So let's switch to a demo.  
There we go.  Okay.  So this is 

06:06:58.293 --> 06:07:04.568
the big query web UI.  It lets 
me look at the big data query

06:07:08.657 --> 06:07:10.728
 directly in the browser.  I 
have the schema for my table.  

06:07:10.729 --> 06:07:14.917
So I'm storing the ID of each 
Tweet, the text of each Tweet, 

06:07:14.918 --> 06:07:19.087
when it was created, how many 
followers the user has, the 

06:07:19.088 --> 06:07:25.335
hashtags as a JSON string which 
I get from the Twitter API, and 

06:07:25.336 --> 06:07:29.525
then the score and magnitude.  
So we can preview this.  Looks 

06:07:29.526 --> 06:07:35.769
like we have collected about 840
 Tweets, which is small for big 

06:07:35.770 --> 06:07:42.055
query.  Big query is for lots of
 data.  This is a demo.  We have

06:07:42.056 --> 06:07:48.280
 the text of the Tweets, the 
tags, and then the giant string 

06:07:48.281 --> 06:07:52.467
of the response.  And we write 
our query strings in SQL.  How 

06:07:52.468 --> 06:07:56.608
am I going to parse this giant 
JSON string with SQL?  The 

06:07:56.609 --> 06:08:00.791
answer is big query has user 
defined functions.  Allows you 

06:08:00.792 --> 06:08:04.944
to write custom JavaScript 
functions to parse different 

06:08:04.945 --> 06:08:09.106
columns in the table.  Here I'm 
going to find what adjectives 

06:08:09.107 --> 06:08:13.302
people are using when they use 
GDDeurope.  And I

06:08:13.303 --> 06:08:17.459
look for each token, and if the 
part of speech is adjective, I'm

06:08:17.460 --> 06:08:21.621
 going to do a running count.  
So I'm running this query and 

06:08:21.622 --> 06:08:27.894
look at the results.  Pretty 
positive attitude about GDD 

06:08:27.895 --> 06:08:29.957
Europe.  This is good.  These 
are the most commonly used right

06:08:29.958 --> 06:08:36.243
 now.  Again, what's really cool
 about this is this is on all 

06:08:36.244 --> 06:08:42.558
840 of our Tweets and really 
fast.  3.1 seconds.  Ran the 

06:08:42.559 --> 06:08:46.719
custom query on all the Tweets 
in the table.  Which is cool.  

06:08:46.720 --> 06:08:52.981
One more query for you.  I am a 
fan of emojis.  Which are they 

06:08:52.982 --> 06:08:57.106
using most frequently?  It looks
 like the laughing crying is a 

06:08:57.107 --> 06:09:03.382
popular one, clapping, Firebase.
  Overall not too many.  Maybe 

06:09:03.383 --> 06:09:07.564
people should use more in their 
Tweets.  But the goal is to show

06:09:07.565 --> 06:09:11.722
 what you can do with the syntax
  endpoint of the with natural 

06:09:11.723 --> 06:09:13.802
language API.  To see the 
sentiment around a particular 

06:09:13.803 --> 06:09:20.003
topic.  So that's the demo.  We 
can go back to the slides now.

06:09:20.004 --> 06:09:24.205
So another thing you might want 
to do with  text, in addition to

06:09:24.206 --> 06:09:30.438
 analyze it or transcribe it, is
 translate it into many 

06:09:30.439 --> 06:09:32.516
languages to support all the 
users in your application.  The 

06:09:32.517 --> 06:09:36.651
translation API lets you 
translate text in over 100 

06:09:36.652 --> 06:09:40.828
languages.  Before we get into 
it, I want to look at Google 

06:09:40.829 --> 06:09:47.085
translate.  Anyone else here use
 it?  I'm a big fan.  Especially

06:09:47.086 --> 06:09:49.170
 when I travel somewhere where 
English isn't the first language

06:09:51.250 --> 06:09:55.401
.  I was in Japan and really 
wanted to order okta poppas.  

06:09:55.402 --> 06:09:59.554
Found out the word was taco, I 
was confused.  But go with it.  

06:09:59.555 --> 06:10:05.832
So I showed it to the waiter and
 I got octopus back.  So Google 

06:10:05.833 --> 06:10:07.909
translate success.  But you want
 to do more with Google 

06:10:07.910 --> 06:10:14.142
translate than translate the 
word for  octopus.  And it 

06:10:14.143 --> 06:10:16.196
exposes all the functionality of
 Google translate to developers.

06:10:16.197 --> 06:10:22.473
  One company that's using the 
translation API  is Airbnb.  60%

06:10:22.474 --> 06:10:26.672
 of the bookings are connecting 
people that use the app in 

06:10:26.673 --> 06:10:28.783
different languages.  And 
they're using the translation 

06:10:28.784 --> 06:10:32.968
API not only
to translate listings, but also 

06:10:32.969 --> 06:10:35.039
reviews and conversations.  And 
they found that using the 

06:10:35.040 --> 06:10:39.207
translation API significantly 
improves a guest's likelihood to

06:10:39.208 --> 06:10:41.293
 book.
Here is a Python example of how 

06:10:41.294 --> 06:10:45.459
you would call the translation 
API using the Google Cloud 

06:10:45.460 --> 06:10:49.604
module for Python.  And notice 
here that we just passed in the 

06:10:49.605 --> 06:10:53.765
string of the text we would like
 to translate and the target 

06:10:53.766 --> 06:10:55.854
text language.  We don't need to
 tell it the source language.  

06:10:55.855 --> 06:11:00.015
The API can detect that for us. 
 And if you also just want to 

06:11:00.016 --> 06:11:04.157
use the API to detect the 
language of text.  So there's 

06:11:04.158 --> 06:11:06.220
inputting text in a variety of 
languages, you can use the 

06:11:06.221 --> 06:11:10.400
detect language endpoint to do 
that.  So we get our translation

06:11:10.401 --> 06:11:14.527
 result.  Pretty straightforward
.  One improvement we made to 

06:11:14.528 --> 06:11:18.691
the API was an improvement to 
the model call the neural 

06:11:18.692 --> 06:11:22.859
machine translation.  The way 
that the model worked before 

06:11:22.860 --> 06:11:24.947
with first generation 
translation, it would take each 

06:11:24.948 --> 06:11:29.111
word in the sentence and 
translate it word for word.  

06:11:29.112 --> 06:11:33.259
This is similar to what you 
might do if you were traveling 

06:11:33.260 --> 06:11:37.407
and had a dictionary and had a 
sentence to translate and did a 

06:11:37.408 --> 06:11:39.490
lookup.  You would probably get 
your idea across, but

06:11:39.491 --> 06:11:43.647
it wouldn't be perfect.  And 
what neural machine translation 

06:11:43.648 --> 06:11:45.739
does is it takes the context of 
the surrounding words around 

06:11:45.740 --> 06:11:51.981
each word in a sentence and it's
 able to produce much higher 

06:11:51.982 --> 06:11:56.133
quality translations.  There's a
 great article about it.  Bit.

06:11:58.195 --> 06:12:04.423
ly/nyt-ai-awakening picture.  
And to highlight the 

06:12:04.424 --> 06:12:08.586
differences, I have a Harry 
Potter example again.  There's a

06:12:08.587 --> 06:12:12.745
 lot of text on the slide.  I'll
 explain it.  Is the original 

06:12:12.746 --> 06:12:16.903
Spanish translation.  So Harry 
Potter was translated into over 

06:12:16.904 --> 06:12:21.064
70 languages.  Didn't use a 
translation API.  Wouldn't have 

06:12:21.065 --> 06:12:25.227
worked well.  They had somebody 
translating the text for each 

06:12:25.228 --> 06:12:29.379
one.  This is the original 
Spanish translation.  And into 

06:12:29.380 --> 06:12:31.452
English in the first generation 
in the middle and the improved 

06:12:31.453 --> 06:12:35.623
neural machine translation on 
the right.  I have bolded some 

06:12:35.624 --> 06:12:37.702
of the differences.  You can see
 these are small improvements, 

06:12:37.703 --> 06:12:41.827
but they make a big difference 
in terms of the overall quality 

06:12:41.828 --> 06:12:46.004
of the translation.
So that is the translation API. 

06:12:46.005 --> 06:12:48.079
 And the last  API I want to 
share with all of you is the 

06:12:48.080 --> 06:12:54.381
video intelligence API.  This is
 our newest machine  learning 

06:12:54.382 --> 06:12:58.570
API on Google Cloud Platform.  
It lets you understand your 

06:12:58.571 --> 06:13:02.708
video's entities at shot, frame,
 or video level.  One company 

06:13:02.709 --> 06:13:08.993
using it is Cantemo.  They're a 
media asset management company. 

06:13:08.994 --> 06:13:11.067
 Their users have tons of 
content uploaded into the system

06:13:13.148 --> 06:13:17.331
.  And they're using the video 
API to help users better search 

06:13:17.332 --> 06:13:21.523
large libraries of video.
The best way to see how the 

06:13:21.524 --> 06:13:23.603
video API works is through a 
demo.  And so the demo I'm going

06:13:25.718 --> 06:13:29.892
 to show you here is what I've 
got is a video of a Super Bowl 

06:13:29.893 --> 06:13:34.090
commercial for Google Home.  And
 I'm going to play the video.  

06:13:34.091 --> 06:13:38.239
And you'll notice that it starts
 with a mountain pass.  Goes to 

06:13:38.240 --> 06:13:42.399
a house.  A cityscape.  Lots of 
scenes changing in the video.  

06:13:42.400 --> 06:13:46.586
Now we see a dog.  I won't play 
the whole thing.  But you get 

06:13:46.587 --> 06:13:48.655
the idea.  Lots of scene changes
 in the video.  And if you were 

06:13:48.656 --> 06:13:52.838
to manually transcribe what's 
happening, watch the whole 

06:13:52.839 --> 06:13:57.094
thing, watch what's happening 
and store the tags in database 

06:13:57.095 --> 06:14:01.286
somewhere.  And with video API, 
it essentially does all of that 

06:14:01.287 --> 06:14:05.472
for you.  So the JSON response 
tells you at a high level what 

06:14:05.473 --> 06:14:09.636
is  happening, what the video is
 about, and in a granular level,

06:14:09.637 --> 06:14:13.782
 what is happening in each scene
 of the video.  So if we look 

06:14:13.783 --> 06:14:17.928
below this, we can see the 
examples.  It knew there was a 

06:14:17.929 --> 06:14:19.986
dog in the video and exactly 
when that dog appeared.  It knew

06:14:19.987 --> 06:14:24.149
 that it  ended with birthday
cake.  And if we scroll down, we

06:14:24.150 --> 06:14:28.349
 can see it identified -- even 
the type of dog that we have 

06:14:28.350 --> 06:14:30.416
there.  And it's also able to 
identify that mountain pass from

06:14:30.417 --> 06:14:34.586
 the beginning scene.
So that's pretty cool.  And this

06:14:34.587 --> 06:14:38.761
 is just one video.  So chances 
are, if you want to analyze  

06:14:38.762 --> 06:14:40.827
videos, probably got a lot of 
videos sitting around in storage

06:14:40.828 --> 06:14:44.995
 buckets.  And the video API 
with the JSON response you get 

06:14:44.996 --> 06:14:49.150
back, it makes it really easy to
 search a large library of 

06:14:49.151 --> 06:14:51.206
videos.  So if you look here, 
I've got lots of videos.  Let's 

06:14:51.207 --> 06:14:57.504
say I'm a sports media company 
and I have lots of sports 

06:14:57.505 --> 06:14:59.586
footage and I want to create a 
highlight reel just of one 

06:14:59.587 --> 06:15:01.665
specific type of content.  Say I
 want to create a highlight reel

06:15:01.666 --> 06:15:07.923
 of all my baseball clips in my 
videos.  So without the video 

06:15:07.924 --> 06:15:12.063
API, I would have to have 
somebody manually watching the 

06:15:12.064 --> 06:15:16.244
video to find baseball.  This is
 easy with the API.  I search 

06:15:16.245 --> 06:15:20.387
baseball, I get back not only 
which videos have baseball, but 

06:15:20.388 --> 06:15:22.463
we can see all the scenes with 
baseball in them.  So this video

06:15:24.548 --> 06:15:26.606
 is almost entirely about 
baseball.

06:15:26.607 --> 06:15:30.758
I like this example here.  We 
have a long video and there's 

06:15:30.759 --> 06:15:32.861
one tiny baseball clip in the 
video.  So here we have the year

06:15:32.862 --> 06:15:37.024
 in search video which Google 
publishes at the end of every 

06:15:37.025 --> 06:15:43.269
year highlighting top searches. 
 And skip here, we can see that 

06:15:43.270 --> 06:15:47.421
baseball clip.  It's actually 
when the Cubs won the World  

06:15:47.422 --> 06:15:51.570
Series last year.  I was excited
 about that.  So if somebody's 

06:15:51.571 --> 06:15:55.745
job was to scan for that clip, 
chances are they might miss it. 

06:15:55.746 --> 06:16:02.031
 It's only one or two seconds of
 the video.  But with video API,

06:16:02.032 --> 06:16:04.108
 it's easy to make the library 
searchable.  One more search.

06:16:04.109 --> 06:16:08.259
I'm going to search for beach 
because it might be nice to be 

06:16:08.260 --> 06:16:12.403
on a beach today.  It's a little
 cold today.  A little rainy.  

06:16:12.404 --> 06:16:16.556
Can't go to a beach, but search 
for beach videos.  Next best 

06:16:16.557 --> 06:16:20.741
thing.  Here we can find the 
beach clips in all of our 

06:16:20.742 --> 06:16:22.839
videos.  Which is pretty cool.  
So something that used to take 

06:16:22.840 --> 06:16:26.995
hours, now with the video 
intelligence API you can do in 

06:16:26.996 --> 06:16:33.245
seconds or minutes.
Let's go back to the slides.  So

06:16:33.246 --> 06:16:35.321
 just briefly, I want to share 
how the demo works because it 

06:16:35.322 --> 06:16:39.469
uses a couple of other Google 
Cloud Platform products as well.

06:16:39.470 --> 06:16:45.700
  All the videos are stored in a
 Google Cloud storage bucket, 

06:16:45.701 --> 06:16:49.861
and I have a cloud function 
listening on the bucket.  That 

06:16:49.862 --> 06:16:54.007
is triggered every time a new 
video is added.  Make sure it's 

06:16:54.008 --> 06:16:58.182
a video file, and if it is, send
 it to the video API for 

06:16:58.183 --> 06:17:02.334
processing.  And you can pass in
 the parameters the storage 

06:17:02.335 --> 06:17:06.507
bucket where you would like to 
write the annotations to.  Once 

06:17:06.508 --> 06:17:10.660
it's done annotating the  video,
 you can write to a separate 

06:17:10.661 --> 06:17:18.930
bucket.  And NodeJS, and running
 on app engine.  It's not 

06:17:18.931 --> 06:17:23.075
calling the video directly.  
It's getting the video from one 

06:17:23.076 --> 06:17:25.154
cloud storage bucket and the 
associated metadata from 

06:17:25.155 --> 06:17:31.408
another.  This is what the 
response looks like for label 

06:17:31.409 --> 06:17:35.580
detection.  Here we have a video
 with a scene of bird's eye 

06:17:35.581 --> 06:17:41.851
view.  And the location data.  
The start and end time in 

06:17:41.852 --> 06:17:45.185
microseconds that it occurred in
 the video.  If it

06:17:41.852 --> 06:17:46.003
occurred more than once, I would
 have more than one in the 

06:17:46.004 --> 06:17:48.088
response.  And a confidence 
score.  How confident is it that

06:17:50.156 --> 06:17:52.156
 it correctly labeled the scene 
of our

06:17:53.537 --> 06:17:55.715
 video?
So that's all I've got for the 

06:17:55.716 --> 06:17:59.893
APIs.  I encourage you to try 
them all out in the browser.  As

06:17:59.894 --> 06:18:04.049
 I mentioned for the vision API 
in the browser, you can

06:18:07.102 --> 06:18:09.102
 do that for all the APIs

06:18:10.104 --> 06:18:12.176
.  Your text, video, try it out,
 see the API response.  If you 

06:18:12.177 --> 06:18:16.326
want the code for most of the 
demos I showed today, it's 

06:18:16.327 --> 06:18:18.405
available in the two repos 
listed there.  I'll let you all 

06:18:18.406 --> 06:18:22.539
get a picture of that slide real
 quick.

06:18:22.540 --> 06:18:24.612
And thank you.  Thanks for 
having me.

06:18:28.699 --> 06:18:30.699
[ Applause ]

06:18:32.786 --> 06:18:36.955
If you have feedback, I would 
love to hear it.  So just go to 

06:18:36.956 --> 06:18:43.198
this link or follow the QR code 
to fill out a feedback form.  

06:18:43.199 --> 06:18:45.199
Thank you.

06:23:18.717 --> 06:23:25.308
&gt;&gt; Hello everyone.  Can you hear
 me?  I'm Dan Galpin, and Lisa 

06:23:25.309 --> 06:23:29.470
Wray and I will be giving you a 
tour of the latest support 

06:23:29.471 --> 06:23:31.584
library updates.  We have so 
much to cover.  I'm going to 

06:23:31.585 --> 06:23:35.806
jump into it.  Up with of the 
biggest changes in O is we added

06:23:37.899 --> 06:23:39.899
  adaptive launch

06:23:41.988 --> 06:23:46.136
 icons.  You saw they were using
 custom launchers with custom 

06:23:46.137 --> 06:23:54.490
icons, and Android shapes and 
sayses were all random.  They 

06:23:54.491 --> 06:23:58.709
would shrink or run with a color
 or shape.  We can do something 

06:23:58.710 --> 06:24:02.946
better than this.  What we did 
was create adaptive icon to 

06:24:02.947 --> 06:24:07.102
enable this type of 
customization, you app provides 

06:24:07.103 --> 06:24:13.365
icons in two layers.  Background
 and foreground.  So if the OEM 

06:24:13.366 --> 06:24:17.526
finds a rounded rectangle, they 
will see this.  And circular 

06:24:17.527 --> 06:24:25.853
shape, like this.  This is cool.
  Goes every way in the UI over 

06:24:25.854 --> 06:24:29.997
the title bar and in the shared 
sheet dialogue.  So to support 

06:24:29.998 --> 06:24:36.226
wider ranges of icon sizes, not 
every is the same size as you 

06:24:36.227 --> 06:24:40.396
have noticed, bigger than  48DP,
 we recommend that apps contain 

06:24:40.397 --> 06:24:44.574
an icon asset of 72DP in size.  
So if

06:24:44.575 --> 06:24:50.812
they want to render icons in 
60DB, it will not be 

06:24:50.813 --> 06:24:52.888
super-sampled.  The actual size 
of the foreground and background

06:24:54.975 --> 06:24:59.145
 layer that we want apps to 
upgrade to is 108DP.  We 

06:24:59.146 --> 06:25:03.302
recommend that both the 
foreground and background are 

06:25:03.303 --> 06:25:05.362
padded with 25% extra image 
around each side.  We want to 

06:25:05.363 --> 06:25:09.529
use it to add delightful an 
makeses such as pulsing.  And 

06:25:09.530 --> 06:25:13.693
this is just an example -- no, 
we haven't added this -- but 

06:25:13.694 --> 06:25:17.860
someday we might.  You can now 
control how your brand is going 

06:25:17.861 --> 06:25:24.086
to look no matter what icon 
shape you choose while 

06:25:24.087 --> 06:25:26.178
integrating into the visual 
design.  This is important.  

06:25:26.179 --> 06:25:30.370
This is what we have done, added
 the adaptive icon class to Oreo

06:25:32.452 --> 06:25:34.528
.  And has one  drawable 
attribute.  And to help this out

06:25:36.594 --> 06:25:38.665
, we added this fractional inset
 value.

06:25:38.666 --> 06:25:42.834
And this means your inset can 
now be density variant, which is

06:25:42.835 --> 06:25:49.073
 really, really cool.  So as it 
turns out, 18 over 8 is 16%.  So

06:25:49.074 --> 06:25:53.253
 if you use this value to pad 
your 72DP launcher icon, there 

06:25:53.254 --> 06:25:58.169
will be no size increase from a 
non-adaptive icon that's big 

06:25:58.170 --> 06:26:02.326
enough.  But better yet, the 
really cool thing is because 

06:26:02.327 --> 06:26:10.612
these are only in O, Android N, 
the vectorial drawable came 

06:26:10.613 --> 06:26:16.889
expressive enough to have the 
vector icons.  Which is really 

06:26:16.890 --> 06:26:18.996
cool.  So once again, O made a 
bunch of critical changes to 

06:26:18.997 --> 06:26:23.189
other areas too.  Not just 
adaptive icons.

06:26:27.281 --> 06:26:29.380
  They could only block for 
spending a Spamming notification

06:26:31.464 --> 06:26:37.697
.  We increased notification 
channels, and they have the same

06:26:37.698 --> 06:26:40.415
 behavior and user cans control 
them.  And the user can click 

06:26:40.416 --> 06:26:42.504
here and see the categories.  
The category reveals per

06:26:44.567 --> 06:26:46.655
-category like vibration and 
sound, et cetera.  And we added 

06:26:46.656 --> 06:26:52.893
dots to the  launcher.  A low 
stress way to see if apps have 

06:26:52.894 --> 06:26:59.654
notifications.  And pressing the
 icon reveals the notification. 

06:26:59.655 --> 06:27:03.811
 And widgets installed easy so
people don't have to stress and 

06:27:03.812 --> 06:27:10.058
figure out how to install them. 
 And the stuff that was per 

06:27:10.059 --> 06:27:14.201
notification is on the channel 
now.  This is cool.  You can set

06:27:14.202 --> 06:27:18.352
 the stuff on a channel.  Okay. 
 I have a bullet point slide, 

06:27:18.353 --> 06:27:20.425
sorry.  Seriously, don't 
overwhelm your user with 

06:27:20.426 --> 06:27:26.651
channels.  Make them make sense,
 give reasonable defaults.  And 

06:27:26.652 --> 06:27:32.876
you can use notification to set 
channels.  And if you're using 

06:27:32.877 --> 06:27:39.097
Oreo, your notifications are not
 going to show up.  App  

06:27:39.098 --> 06:27:43.240
widgets.  Way back in Android 
7.1, we added nifty launcher 

06:27:43.241 --> 06:27:47.374
shortcuts, and they could pin to
 the  launcher and apps could 

06:27:47.375 --> 06:27:49.496
request it's pinned.  But there 
was no indication to the app 

06:27:49.497 --> 06:27:53.629
that it worked, and the user 
wasn't notified that it was 

06:27:53.630 --> 06:27:57.791
happening, which wasn't great 
for users or developers.  It 

06:27:57.792 --> 06:27:59.857
doesn't work anymore if you're 
targeting O.  We now have the 

06:27:59.858 --> 06:28:07.012
new way with shortcut manager.  
It has an  API and takes the 

06:28:07.013 --> 06:28:09.013
same shortcut

06:28:10.078 --> 06:28:12.157
 info, and the  launcher asks 
the user whether to use it and 

06:28:12.158 --> 06:28:16.300
where to place it.  And the app
can update the shortcut icon 

06:28:16.301 --> 06:28:20.465
later with this as well.  And 
custom shortcuts were also in 7

06:28:22.540 --> 06:28:24.625
.1.  Allowed shortcuts to be 
added from the widget tray with 

06:28:24.626 --> 06:28:30.875
an optional configuration 
screen.  And the Oreo API  is 

06:28:30.876 --> 06:28:35.034
improved there.  You can put the
 activity with the filter.  And 

06:28:35.035 --> 06:28:41.269
in 7.1, return the shortcut as 
intent extras directly to the 

06:28:41.270 --> 06:28:43.353
activity return.  Which is okay.
  But now wrap the 

06:28:43.354 --> 06:28:47.504
functionality, allowing the app 
to update the shortcut.  Again, 

06:28:47.505 --> 06:28:49.571
making the launch better.  And 
this has been a really long time

06:28:49.572 --> 06:28:53.752
 coming.
But we actually have a way for 

06:28:53.753 --> 06:28:57.899
you to surface your app widgets 
in your app.  Like that you no  

06:28:57.900 --> 06:29:02.048
longer to have beg the user to 
find it in the  launcher.  You 

06:29:02.049 --> 06:29:06.198
can say, I have an app widget, 
please install it on your 

06:29:06.199 --> 06:29:08.276
behalf.  Get prompted and added 
to the home screen.  It's 

06:29:08.277 --> 06:29:12.442
awesome.  I can't believe it 
took us this long.  Let's talk 

06:29:12.443 --> 06:29:16.645
about autofill.  Apps 
automatically work with 

06:29:16.646 --> 06:29:20.800
autofill, but you can do a 
better job by providing hints.  

06:29:20.801 --> 06:29:24.964
And you can mark fields for 
autofill to ignore.  You can 

06:29:24.965 --> 06:29:29.119
also integrate it more deeply.  
You can request autofill in your

06:29:29.120 --> 06:29:33.270
 app.  And you can use autofill 
on completely custom views such 

06:29:33.271 --> 06:29:40.429
as those with open GL or Vulcan.
  And no matter how you build 

06:29:40.430 --> 06:29:42.521
your apps, you should consider 
doing this.  And this is kind of

06:29:42.522 --> 06:29:48.764
 cool.  You have a Website -- 
the Google autofill provider can

06:29:48.765 --> 06:29:52.944
 actually share credential 
information between the web and 

06:29:52.945 --> 06:29:55.036
the app if you create a digital 
asset link.  This is pretty 

06:29:55.037 --> 06:29:57.124
straightforward.  You have to 
put something on your server.

06:29:57.125 --> 06:30:03.350
Some JSON here.  That allows you
 to say you want to share login 

06:30:03.351 --> 06:30:05.432
 credentials between the Website
 and the app.  And modify the 

06:30:05.433 --> 06:30:09.599
manifest with a string that 
points to a similar JSON 

06:30:09.600 --> 06:30:13.741
resource that has a list of web 
permissions just like on the 

06:30:13.742 --> 06:30:19.956
Website.  And that's  it.  Two 
steps, pair for the Website.  It

06:30:19.957 --> 06:30:22.018
 works for autofill and also the
 first step to implementing 

06:30:22.019 --> 06:30:24.103
smart lock.  This lets

06:30:27.103 --> 06:30:31.259
 your users automatically log in
.  If you don't want to go all 

06:30:31.260 --> 06:30:33.335
the way to smart lock, you can 
use this.

06:30:35.390 --> 06:30:41.635
And we added cool StrictMode 
behavior.  This is great.  It 

06:30:41.636 --> 06:30:48.146
can detect unbuffered I/O.  And 
VM policy allows you to detect 

06:30:48.147 --> 06:30:50.147
untagged sockets as well as 
whens a content

06:30:52.230 --> 06:30:56.380
 URI  is not, the calling app is
 not granting permission.  It's 

06:30:56.381 --> 06:31:00.522
not useful.  And seeker file 
disrupters are for providers.  

06:31:00.523 --> 06:31:04.676
You can use this for large audio
 and video files.  Another thing

06:31:04.677 --> 06:31:08.858
 we did was added proper support
 for caching.  So the quota can 

06:31:08.859 --> 06:31:13.022
change depending how frequently 
the user actually interacts with

06:31:13.023 --> 06:31:15.099
 the app.  And the amount  used 
-- and the amount used.  Well, 

06:31:15.100 --> 06:31:19.225
the allocate actually takes, you
 know, deletable cache into 

06:31:19.226 --> 06:31:23.405
account.  So pretty slick.  And 
there's tons more stuff in O.  

06:31:23.406 --> 06:31:25.484
I'm not going through it all 
here.  Most of you have seen a 

06:31:25.485 --> 06:31:29.631
lot of this stuff.  But 
enhancements to accessibility, 

06:31:29.632 --> 06:31:33.804
including the ability for users 
to add an accessibility button 

06:31:33.805 --> 06:31:37.960
with soft navigation.  Paging 
and content providers.  Great 

06:31:37.961 --> 06:31:44.230
stuff to make it run faster like
 a current copy collector and 

06:31:44.231 --> 06:31:46.308
changes in media.  But
let's get into the support 

06:31:46.309 --> 06:31:50.457
library.  You know what I'm 
going to say here, devices with 

06:31:50.458 --> 06:31:56.710
SDK's less than 14 are less than
 1% of the the users.  So we 

06:31:56.711 --> 06:32:00.873
have updated the library and 
gotten rud of these guys.  So we

06:32:00.874 --> 06:32:02.965
 are focusing on what most 
developers are targeting.  The 

06:32:02.966 --> 06:32:07.145
newer version is 14.  And Google
 Play services also  recently 

06:32:07.146 --> 06:32:11.300
dropped this support in version 
10.2.  You can use an older 

06:32:11.301 --> 06:32:15.467
version of the support library 
if you want to really target 

06:32:15.468 --> 06:32:19.688
that.  And dropping AI 14,

06:32:23.780 --> 06:32:27.942
 benefits, and there is more to 
go in later versions.  Our 

06:32:27.943 --> 06:32:34.165
public API surface reduced by 30
 classes of methods.  And what 

06:32:34.166 --> 06:32:36.242
we need to do now is you can 
still use a lot of these things 

06:32:36.243 --> 06:32:40.375
are AR, but you can start 
getting rid of the deprecated 

06:32:40.376 --> 06:32:44.521
stuff because we're actually 
going to get rid of it to even 

06:32:44.522 --> 06:32:46.600
make things smaller.  And using 
the

06:32:50.661 --> 06:32:56.898
 Google Maven on Android Studio 
2.3.  And using plugins, you can

06:32:56.899 --> 06:33:01.031
  say -- this is kind of sweet. 
 Text and fonts.  One of my 

06:33:01.032 --> 06:33:03.105
favorite things.  I love fonts. 
 In the old

06:33:03.106 --> 06:33:07.270
world -- how many did custom 
fonts on their Android app?  A 

06:33:07.271 --> 06:33:11.416
lot of you.  You had to load 
type face into the constructer, 

06:33:11.417 --> 06:33:15.565
and use the custom text view 
everywhere.  Yeah.  But now you 

06:33:15.566 --> 06:33:19.696
have resource type with single 
font files as well as families. 

06:33:19.697 --> 06:33:23.862
 And font files get a resource 
ID.  And you can make the 

06:33:23.863 --> 06:33:28.610
families, which are groups of 
fonts together.  You can say I 

06:33:28.611 --> 06:33:30.683
want normal to be this font, and
 bold to be this font, et 

06:33:30.684 --> 06:33:36.894
cetera.  Very, very sweet.  This
 webpack generates bar.font.

06:33:38.955 --> 06:33:43.079
myfont.  And the textview is 
used, and it can handle families

06:33:45.161 --> 06:33:47.249
.  The same thing you have been 
using all the time.  Both 

06:33:47.250 --> 06:33:51.374
textile attributes as well as 
style spans are supported, which

06:33:51.375 --> 06:33:55.545
 is really great.  And you can 
define them in styles as usual. 

06:33:55.546 --> 06:33:59.710
 Use in code by resources.  And 
most importantly, it's imported 

06:33:59.711 --> 06:34:03.875
on API 14 and above in the 
support library.  So go out 

06:34:03.876 --> 06:34:08.055
there and use more fonts.  And 
the only problem is that fonts 

06:34:08.056 --> 06:34:10.121
bloat the size of your app.  So 
we had to think about this.  The

06:34:12.209 --> 06:34:18.427
 top 25 fonts in Google
fonts actually average 500 

06:34:18.428 --> 06:34:20.517
kilobytes or more.  And not 
optimized for mobile.  How do we

06:34:20.518 --> 06:34:24.676
 fix this?  Of course we added 
downloadable fonts.  And the 

06:34:24.677 --> 06:34:28.812
font provider fetches and serves
 to the apps so you don't have 

06:34:28.813 --> 06:34:32.961
to bundle them anymore.  This is
 cool because the font provider 

06:34:32.962 --> 06:34:37.109
is shared between apps.  Gives 
you memory, framework had, space

06:34:37.110 --> 06:34:41.271
 savings.  And with Google Play 
services and Google fonts you 

06:34:41.272 --> 06:34:45.435
get over  800 fonts.  So it's 
really nice.  And you code, you 

06:34:45.436 --> 06:34:49.607
can request the fonts using a 
font request.  It's like 

06:34:49.608 --> 06:34:53.776
authority and package and certs 
for security and callbacks for 

06:34:53.777 --> 06:34:57.927
success or failure now exist.
And then you -- and, of course, 

06:34:57.928 --> 06:35:00.014
you just use

06:35:06.106 --> 06:35:10.285
 fontscontractcompat.  Don't use
 on a UI thread.  And you can 

06:35:10.286 --> 06:35:14.452
throw them into XML.  It's ease 
to use.  It's a string array.  

06:35:14.453 --> 06:35:18.590
And it actually is pretty  cool.
  So we have done full 

06:35:18.591 --> 06:35:24.821
integration with Android Studio.
  We have boring text in the 

06:35:24.822 --> 06:35:29.020
layout.  A beautiful selection 
of fonts.  I'm going to search 

06:35:29.021 --> 06:35:31.021
for unwith.  There we are.

06:35:35.102 --> 06:35:39.265
 yesteryear.  It's going to show
 up and add the beautiful file 

06:35:39.266 --> 06:35:43.399
to the  project.  Pretty sweet. 
 Check out the sample app, and 

06:35:43.400 --> 06:35:49.657
the guide on Googledeveloper.com
 for more info.  And it's all 

06:35:49.658 --> 06:35:53.847
supported in API 14 plus.  So 
nothing worse when someone sends

06:35:53.848 --> 06:35:58.003
 a message, get a box, no 
information.  It's time to get 

06:35:58.004 --> 06:36:02.139
rid of this  because -- and this
 is there because the system has

06:36:02.140 --> 06:36:06.381
 always bundled the emoji.  And 
they are adding new, and it's 

06:36:06.382 --> 06:36:08.467
hard to keep up unless we can 
make it show up.  So the support

06:36:08.468 --> 06:36:16.767
 library has access to the new 
font and checks for glyph if it 

06:36:16.768 --> 06:36:18.768
it can be rendered

06:36:20.855 --> 06:36:25.023
.  The download just happens to 
integrate with downloadable 

06:36:25.024 --> 06:36:29.181
fonts.  Add the dependencies, 
make the font request and 

06:36:29.182 --> 06:36:33.319
initialize on your application. 
 Very simple.  You don't have to

06:36:33.320 --> 06:36:37.455
 bundle the emoji font with your
 app.  You can.  Targeting non 

06:36:37.456 --> 06:36:43.684
-GMS devices, you can do that.  
Adds about 7 megabytes.  In a 

06:36:43.685 --> 06:36:47.844
similar way with bundling the 
emoji config.  Very 

06:36:47.845 --> 06:36:54.064
straightforward.  Again, you 
have to use these emoji text 

06:36:54.065 --> 06:37:00.307
views.  You can use emoji text 
and button instead of edit text 

06:37:00.308 --> 06:37:04.443
and button.  But you have to 
integrate it in yourself.  We 

06:37:04.444 --> 06:37:08.624
supply these to help you out.
And now, tacos and unicorns both

06:37:10.706 --> 06:37:12.794
 exist.  Important things for us
 to get across.  So check out 

06:37:12.795 --> 06:37:19.037
the sample.  More information.  
Now, one caveat  here, we didn't

06:37:19.038 --> 06:37:23.169
 actually backport this all the 
way to Kit Kat.  This does 

06:37:23.170 --> 06:37:31.514
require API 19 plus.  That's the
 one minor caveat.  You'll get 

06:37:31.515 --> 06:37:37.726
to fu on older devices.  
Textview autosizing.  How many 

06:37:37.727 --> 06:37:41.889
have built their own textview 
autosizer?  Yes.  I have been 

06:37:41.890 --> 06:37:48.120
wanting this feature forever.  
It text resizes to fill in its 

06:37:48.121 --> 06:37:50.193
container.  I can't tell you how
 excited I was that we built 

06:37:50.194 --> 06:37:56.443
this thing.  Use the autosize 
text type uniform.  And you can 

06:37:56.444 --> 06:38:00.616
either use an array of preset 
sizes or values.  Or min and max

06:38:02.699 --> 06:38:08.925
 size.  It's easy.  And again, 
to API 14 plus.  We brought 

06:38:08.926 --> 06:38:13.067
improvements to vectordrawible. 
 If it looks like this in 

06:38:13.068 --> 06:38:17.215
Android Studio, and shove this 
in.  Might be what you get 

06:38:17.216 --> 06:38:23.453
before.  You get weird 
artifacts.  We're using them on 

06:38:23.454 --> 06:38:27.622
fill rules.  It's a big TBD in 
the source code if you went and 

06:38:27.623 --> 06:38:31.769
looked.  So it  fill-rule 
defines

06:38:31.770 --> 06:38:33.847
which are inside and outside.  
And we added support for this 

06:38:33.848 --> 06:38:35.921
which you actually fixed finally
 in

06:38:40.016 --> 06:38:44.197
 24.  Back dated to 14 plus.  It
 mean yours vectors are more 

06:38:44.198 --> 06:38:46.260
likely to work.  You know how 
awesome this is that we finally 

06:38:46.261 --> 06:38:52.524
fixed it.  We also did -- 
imported the stuff from animated

06:38:54.599 --> 06:39:00.830
 drawable for data morphing.  
This is cool.  That is an 

06:39:00.831 --> 06:39:04.983
example of shape shafter to 
generate compatible images with 

06:39:04.984 --> 06:39:09.140
matching path formats.  And 
what's going on at the  XML 

06:39:09.141 --> 06:39:15.364
level.  The startling image, 
buffalo, extract the data.  And 

06:39:15.365 --> 06:39:17.441
go to elephant.  String 
resources and then an object

06:39:21.520 --> 06:39:23.593
 animater.  And it's more of a 
buffalo to a hippo.  And once 

06:39:23.594 --> 06:39:29.793
again, tie it all together in an
 mated vector XML.  We can do 

06:39:29.794 --> 06:39:33.969
stuff with bundle  XML formats 
to make this even cleaner.  So, 

06:39:33.970 --> 06:39:38.146
again, we can actually use an 
element here and it inlines the 

06:39:38.147 --> 06:39:42.317
flow from the buffalo drawable 
and do the same with the 

06:39:42.318 --> 06:39:44.412
animation attribute.  We have a 
bundle that includes the entire 

06:39:44.413 --> 06:39:48.575
vector drawable animation which 
is really cool.  We

06:39:48.576 --> 06:39:52.731
have a patent -- once again, 
parody.  This is complicated.  

06:39:52.732 --> 06:39:58.961
We can take a simple example and
 show how it works.  It wants to

06:39:58.962 --> 06:40:03.151
 shrink a square, but have an 
interesting acceleration curve. 

06:40:03.152 --> 06:40:07.320
 Use the path interpolater.  
This is cool.  Make the can 

06:40:07.321 --> 06:40:11.457
curve that drops off quickly.  
It slowly tapers off.  The morph

06:40:11.458 --> 06:40:15.621
 animation, and set the 
interpolater to be our path 

06:40:15.622 --> 06:40:19.777
interpolater.  And we can bundle
 and this results in this cool, 

06:40:19.778 --> 06:40:21.859
slightly more cool animation.  
Still just a rectangle.

06:40:21.860 --> 06:40:26.062
Okay.  Final thing I'm going to 
talk about is transition support

06:40:26.063 --> 06:40:30.275
 library.  So if you've noticed 
that we actually added some 

06:40:30.276 --> 06:40:32.349
transition type in

06:40:36.434 --> 06:40:42.650
  lollipop and above, available 
in the transition library.  You 

06:40:42.651 --> 06:40:46.807
have to have the dash, dash, 
node as an option.  And after 

06:40:46.808 --> 06:40:53.008
that, you can use all the same 
transition XMLs for platform 

06:40:53.009 --> 06:41:01.346
transition API on 14 and above. 
 I'm talking so fast, I want the

06:41:01.347 --> 06:41:05.482
 collaborator.  The star of the 
show.  I'm the opening act.  

06:41:05.483 --> 06:41:09.627
Welcome Lisa Wray who is going 
to talk about some amazing 

06:41:09.628 --> 06:41:11.711
animation --
[ Applause ]

06:41:11.712 --> 06:41:17.965
&gt;&gt; Thank you.  So I only have 
one thing to talk about.  That's

06:41:20.040 --> 06:41:24.195
 physics-based animations.  So 
we have known for a long time 

06:41:24.196 --> 06:41:28.340
that motion is important in 
material design.  Natural 

06:41:28.341 --> 06:41:32.507
movement inspired by  forces in 
the real world.  And I've tried 

06:41:32.508 --> 06:41:34.568
-- I really have -- but it 
hasn't always been easy.  So the

06:41:34.569 --> 06:41:40.800
 support library has now 
introduced two  physics-based 

06:41:40.801 --> 06:41:47.027
animation.  Not approximations 
of motion, but motion based on 

06:41:47.028 --> 06:41:51.170
natural forces.  Could you have 
done this before?  Maybe, but 

06:41:51.171 --> 06:41:53.241
wouldn't have been easy.  These 
ideas are now central to the way

06:41:53.242 --> 06:41:57.460
 we can animate.  My hope is to 
make this type of motion easy 

06:41:57.461 --> 06:42:01.628
for you think about and easy for
 you to use in your app.  Some 

06:42:01.629 --> 06:42:04.557
things that are easy now that 
were hard before.  Responding to

06:42:04.558 --> 06:42:08.712
 user interaction by which I 
just mean a touch.  Chaining 

06:42:08.713 --> 06:42:12.862
animations.  Modifying them on 
the fly.  Getting great natural 

06:42:12.863 --> 06:42:17.014
movement with much less visual 
jank.  So I'm going to step 

06:42:17.015 --> 06:42:19.104
through the mechanics of the two
 dynamic animations we have

06:42:19.105 --> 06:42:26.062
right now, and then we'll mix it
 up.  So the first, a fling 

06:42:26.063 --> 06:42:28.063
animation.  Starts with an 
initial velocity

06:42:29.074 --> 06:42:31.163
, slows down and ends gradually.
  So every time that color 

06:42:31.164 --> 06:42:33.262
changes, it's starting a new 
fling.

06:42:35.344 --> 06:42:39.487
And here is the simplest fling 
that you can make.  Ball is a 

06:42:39.488 --> 06:42:43.683
view.  Translation Y is the 
property we're changing.  And 

06:42:43.684 --> 06:42:47.865
it's velocity is  pixels per 
second.  I discovered while 

06:42:47.866 --> 06:42:54.079
making this, the pixels are a 
lot smaller than I thought.  

06:42:54.080 --> 06:42:58.243
Everything else is default.  You
 can customize a fling by the 

06:42:58.244 --> 06:43:02.413
factor which it slows down.  So 
here's an example of friction.  

06:43:02.414 --> 06:43:06.593
So from left, you have high 
friction to low friction on the 

06:43:06.594 --> 06:43:10.734
right.  So the less friction 
that you have, the more distance

06:43:10.735 --> 06:43:13.696
 your view will travel for a 
given velocity.

06:43:15.779 --> 06:43:19.928
And here's a string animation.  
And it looks just like what we'd

06:43:19.929 --> 06:43:24.083
 imagine from the motion of a 
physical spring.  It's the force

06:43:24.084 --> 06:43:26.156
 back to the end point of the 
spring.  And you can even get a 

06:43:26.157 --> 06:43:30.326
bounce.  So every time the color
 changes, that is a new spring 

06:43:30.327 --> 06:43:34.495
animation.  And here's the 
simplest spring you can possibly

06:43:36.570 --> 06:43:40.738
 make.  Ball is a view.  
Translation Y is the property 

06:43:40.739 --> 06:43:42.833
we're changing.  And zero is 
where it's going to stop which 

06:43:42.834 --> 06:43:46.988
is its final translation at 
equilibrium.  And its velocity 

06:43:46.989 --> 06:43:51.165
is pixels per second.  And 
everything else is defaults and 

06:43:51.166 --> 06:43:55.307
it just goes.
So to customize this, you can 

06:43:55.308 --> 06:43:59.458
call get spring on your 
animation, and that gives you 

06:43:59.459 --> 06:44:03.588
the internal spring force object
.  And that has a damping ratio,

06:44:03.589 --> 06:44:07.772
 a stuffness, and you can set 
the final position.  Damping is 

06:44:07.773 --> 06:44:11.908
the ratio by which the size of 
your bounce is reduced over 

06:44:11.909 --> 06:44:16.072
time.  And the default is medium
 bouncy.  In general the lower 

06:44:16.073 --> 06:44:18.157
the number, the more oscillation
 you'll see.  AKA, bouncing.  

06:44:18.158 --> 06:44:22.304
Before the force is going to 
reach equilibrium.  At one, you 

06:44:22.305 --> 06:44:26.444
get critical damping, which 
means no bounce.  And at zero, 

06:44:26.445 --> 06:44:32.705
no damping, infinite bounce.  
Don't do that.  In general, 

06:44:32.706 --> 06:44:34.776
please do not underdamp your  
views.  This crazy bouncing is 

06:44:34.777 --> 06:44:38.969
what made me think at first, why
 on earth would you want to do 

06:44:38.970 --> 06:44:43.119
this to a view?  Try little or 
no bounce and you'll be 

06:44:43.120 --> 06:44:45.189
surprised how useful this 
animation can be.

06:44:45.190 --> 06:44:49.339
Stiffness is like the stiffness 
of a physical spring.  So for a 

06:44:49.340 --> 06:44:53.478
given velocity, how far will it 
travel from the endpoint and how

06:44:53.479 --> 06:44:57.640
 fast will be pulled back?  This
 example has no bounce so that 

06:44:57.641 --> 06:44:59.732
you can see the difference in 
the stiffness better.  The  

06:44:59.733 --> 06:45:03.907
lowest stiffness is on the left,
 so it's traveling further.  The

06:45:06.014 --> 06:45:08.095
 highest stiffness is on the 
right.  And you can also create 

06:45:08.096 --> 06:45:12.255
your own external spring force 
in order to share among multiple

06:45:12.256 --> 06:45:16.400
 animations.  We'll see why you 
might want to do that in a 

06:45:16.401 --> 06:45:18.474
moment.
So one thing you might want to 

06:45:18.475 --> 06:45:22.640
do with these animations is 
allow user input.  So velocity 

06:45:22.641 --> 06:45:26.804
tracker is one option to handle 
this.  It's an oldy, but a 

06:45:26.805 --> 06:45:30.951
goody.  This class has been 
around since API-1.  It does 

06:45:30.952 --> 06:45:35.121
what it says on the tin.  It 
tracks velocity from a user's 

06:45:35.122 --> 06:45:41.421
touch.  You can also use  
gesturedetector if you only hear

06:45:43.491 --> 06:45:45.593
 what the end state of the fling
 is because the fling callback 

06:45:45.594 --> 06:45:49.749
has velocity.  So how do you use
 this?  We're going with vasty 

06:45:49.750 --> 06:45:51.879
tracker for now.  Use it on the 
touch listener of the parent of 

06:45:51.880 --> 06:45:56.050
the view you want to track.  
Parent is the word.  Call 

06:45:56.051 --> 06:46:00.194
Velocity tracker, obtained.  And
 feed in the user's touch events

06:46:00.195 --> 06:46:04.352
 starting with down and 
continuing with move.

06:46:04.353 --> 06:46:10.603
Then in action up, you'll call 
compute current velocity, and it

06:46:10.604 --> 06:46:16.874
 will compute a nice velocity 
for you.  After you are done, 

06:46:16.875 --> 06:46:21.064
make sure to clear it.  It's X 
and Y.  Then you're going to 

06:46:21.065 --> 06:46:25.252
start two dynamic animations at 
the same time, one for the X 

06:46:25.253 --> 06:46:29.400
velocity and one for the Y 
velocity.  They're going to run 

06:46:29.401 --> 06:46:31.498
simultaneously.  And as you can 
see, this is enough.  This gives

06:46:33.589 --> 06:46:39.808
 you a smoothly moving interact 
 iive two dimensional 

06:46:39.809 --> 06:46:43.953
interaction.  And you can see it
 works pretty well.  Be careful 

06:46:43.954 --> 06:46:46.025
when you fling.  They do not 
automatically stay on the 

06:46:46.026 --> 06:46:50.183
screen, and when they're gone, 
they do not come back.

06:46:50.184 --> 06:46:56.408
Just like other animations 
you're familiar  with, dynamic 

06:46:56.409 --> 06:47:00.585
animation has end and update.  
That's how I was changing them 

06:47:00.586 --> 06:47:02.675
in the earlier demonstration and
 changing the ball colors to 

06:47:02.676 --> 06:47:04.772
repeat over and over again.  So 
let's change to fling 

06:47:04.773 --> 06:47:11.038
animations.  We're going to 
fling, just as we did before, 

06:47:11.039 --> 06:47:15.194
using the velocity from our drag
 listener and velocity  tracker.

06:47:15.195 --> 06:47:19.333
  And create one for X and one 
for Y to get natural movement.  

06:47:19.334 --> 06:47:23.498
Then we're going to stop the 
first animation at the edge and 

06:47:23.499 --> 06:47:25.580
create a new one in a different 
direction, giving the impression

06:47:27.680 --> 06:47:33.924
 the ball has bounced.  This 
time, add an update and end 

06:47:33.925 --> 06:47:36.006
listener to the updates.  And we
 will check to see if it's

06:47:40.135 --> 06:47:44.268
 slipped out of the bounds of 
its parents.  There's probably a

06:47:40.135 --> 06:47:44.276
 better way to do this, but 
that's an exercise for the 

06:47:44.277 --> 06:47:48.463
reader.  If it did go outside, 
we'll cancel the animation.  

06:47:48.464 --> 06:47:52.616
We'll get a callback to on 
animation end.  If we cancel it,

06:47:52.617 --> 06:47:56.763
 meaning it hit the edge, then 
fling it back.  I made an 

06:47:56.764 --> 06:47:58.834
extension on View
 here.  We'll use the velocity 

06:47:58.835 --> 06:48:03.006
past here, which is the 
remanuallying velocity from the 

06:48:03.007 --> 06:48:05.086
 canceled animation.  And we'll 
use it in the opposite direction

06:48:07.192 --> 06:48:09.286
, which is the minus sign you'll
 see there.  Of course, it's not

06:48:11.378 --> 06:48:15.560
 exactly this simple.  What this
 does is it flings the ball 

06:48:15.561 --> 06:48:19.709
straight back at you because it 
reverses both of its velocities 

06:48:19.710 --> 06:48:21.784
-- X and Y.  So what we really 
want is natural reflection.  We 

06:48:21.785 --> 06:48:28.035
want it to only reverse its 
velocity on one axis and 

06:48:28.036 --> 06:48:30.117
continue on the other.  And that
 will give us the 90 degree 

06:48:30.118 --> 06:48:34.266
bounce angle.  So it's not too 
hard.  It looks like this.  If 

06:48:34.267 --> 06:48:40.486
it's hitting the horizontal 
edge, reverse X.  Otherwise, 

06:48:40.487 --> 06:48:44.612
reverse Y.  And we get a nice 
reflection, or bounce.  And it 

06:48:44.613 --> 06:48:48.801
also works with different 
animations.

06:48:50.885 --> 06:48:52.996
Ever seen something like this?  
There's an app that keeps trying

06:48:52.997 --> 06:48:57.150
 to do this on my home screen.  
I don't know why I'm encouraging

06:48:57.151 --> 06:48:59.255
 you to do this.  It's 
interesting because it's quite 

06:48:59.256 --> 06:49:05.481
simple.  It's sort of a sticky 
effect.  Fling to the edge and 

06:49:05.482 --> 06:49:09.638
it absorbs the momentum with the
 bounce.  It's going to do 

06:49:09.639 --> 06:49:11.724
something like this.  The thing 
to note is we're  using the 

06:49:11.725 --> 06:49:15.855
ball's current translation value
 as the end value for the spring

06:49:17.922 --> 06:49:19.989
.  So we're going to fling as 
before with an end listener.  

06:49:19.990 --> 06:49:22.052
And then when we get the 
callback, go ahead and oscillate

06:49:24.132 --> 06:49:28.262
 until you reach equilibrium.  
Dissipating the remaining 

06:49:28.263 --> 06:49:37.482
velocity.
Chaining springs.  There was a 

06:49:37.483 --> 06:49:39.483
cool demo in the Google I/O talk

06:49:40.558 --> 06:49:47.552
 I went to of three springs.  If
 you want to look that up, do.  

06:49:47.553 --> 06:49:49.553
I'm not going to talk about

06:49:50.820 --> 06:49:52.820
 it here.  This is inspired by a

06:49:53.858 --> 06:50:00.098
 screen in the plaid app by Nick
 Butcher -- sorry, Nick.  They 

06:50:00.099 --> 06:50:06.341
translate up, one after another.
  In that fact, the distance 

06:50:06.342 --> 06:50:10.500
translated, the delay of each 
element and the interpolation 

06:50:10.501 --> 06:50:14.660
used to accelerate are all  
hard-coded by hand.  That's a 

06:50:14.661 --> 06:50:18.793
pain in the butt.  Here, it's 
all done with the same chained 

06:50:18.794 --> 06:50:23.152
spring we just saw with the 
balls.  I'll go through how that

06:50:23.153 --> 06:50:25.230
 works.  So what's actually 
going on here?  These two 

06:50:25.231 --> 06:50:29.876
springs are almost exactly the 
same effect.  Obviously, the top

06:50:29.877 --> 06:50:34.044
 ball -- the blue ball -- is the
 lead.  The yellow ball follows 

06:50:34.045 --> 06:50:38.286
it.  And the green ball follows 
the yellow ball.  Almost as if 

06:50:38.287 --> 06:50:42.788
they're chained together with 
bouncy springs.

06:50:42.789 --> 06:50:46.915
In the actual app example, the 
lead view is the headline and 

06:50:46.916 --> 06:50:53.133
icons.  The next view, the 
paragraphs, follow it.  And 

06:50:53.134 --> 06:50:57.325
finally the tab is following the
 paragraphs.  There's no rule 

06:50:57.326 --> 06:50:59.406
that these views actually have 
to be in a line in terms of 

06:50:59.407 --> 06:51:03.545
position.  They can be anywhere.
  What matters is the 

06:51:03.546 --> 06:51:07.722
propagation of effects from one 
animation to the next.  So how 

06:51:07.723 --> 06:51:11.890
do I do this?  Instead of a  
touchlistener, I started with a 

06:51:11.891 --> 06:51:16.026
fixed sprung animation on the 
headline.  Instead of a 

06:51:16.027 --> 06:51:20.188
velocity, I gave a start value. 
 Basically I said pull the 

06:51:20.189 --> 06:51:24.350
spring back this far and start 
it there.  And I gave it an 

06:51:24.351 --> 06:51:28.497
update listener, which we have 
seen before.  Then I made a 

06:51:28.498 --> 06:51:30.564
spring animation for the 
paragraphs.  Exact same thing.  

06:51:30.565 --> 06:51:34.729
In the listener, getting  
callbacks from the headline, I 

06:51:34.730 --> 06:51:38.881
call animate to final position 
on the paragraph animation.  

06:51:38.882 --> 06:51:43.011
This is a really important and 
useful method.  So it's going to

06:51:43.012 --> 06:51:47.172
 do two things.  One, it sets 
the new final position of the 

06:51:47.173 --> 06:51:51.351
paragraph spring to the current
position of the headline 

06:51:51.352 --> 06:51:57.632
animation.  And two, it starts 
the paragraph animation if it 

06:51:57.633 --> 06:52:01.771
hasn't yet.
And finally, do the same thing 

06:52:01.772 --> 06:52:05.942
for the fab.  Start an update 
listener on the paragraphs and 

06:52:05.943 --> 06:52:08.016
chain a spring animation to 
that.  And that's how chaining 

06:52:08.017 --> 06:52:12.243
works.  The difference here from
 what we were doing before with 

06:52:12.244 --> 06:52:18.490
flings is they were subsequent, 
one after another.  These are 

06:52:18.491 --> 06:52:20.572
happening simultaneously.  You 
might notice, if you were 

06:52:20.573 --> 06:52:24.735
looking closely, I  used the 
spring on the outside of the 

06:52:24.736 --> 06:52:26.850
views and the scale of the fab. 
 So what else can you animate?  

06:52:26.851 --> 06:52:31.021
You can animate a lot of 
built-in properties.  Certainly 

06:52:31.022 --> 06:52:33.095
everything I can think of 
flinging or springing off the 

06:52:33.096 --> 06:52:39.315
top of my head.  You can animate
 alpha, translation, scroll, 

06:52:39.316 --> 06:52:45.552
scale, and X, Y, and Z, absolute
 positions, including 

06:52:45.553 --> 06:52:47.636
transition.  If you want to make
 a custom property that groups a

06:52:47.637 --> 06:52:49.710
 couple of these, make an 
instance of

06:52:53.811 --> 06:52:58.292
 floatpropertycompat.  And set 
the minimum range so it doesn't 

06:52:58.293 --> 06:53:02.428
animate tiny bits forever.  And 
start every animation at a start

06:53:02.429 --> 06:53:04.494
 value and give a minimum and 
maximum.  And

06:53:07.580 --> 06:53:13.808
 finally, quits the
animations.  If they stop, it 

06:53:13.809 --> 06:53:17.957
will crash.  These are available
 from Jellybean and above.  I'm 

06:53:17.958 --> 06:53:24.202
sure you got all of that.  If 
you didn't, the code is on my 

06:53:24.203 --> 06:53:26.276
GitHub, Lisawray/fizz

06:53:32.385 --> 06:53:36.560
Wray/physics-playground.  
They're way more than bouncing 

06:53:36.561 --> 06:53:40.726
balls, they're a great way to 
bring interaction to your 

06:53:40.727 --> 06:53:44.921
current UI.  So I look forward 
to seeing what you make with 

06:53:44.922 --> 06:53:49.139
them.  Thank you.
[ Applause ]

06:53:55.237 --> 06:53:57.355
Thank you so much.

07:10:10.667 --> 07:10:15.632
&gt;&gt; Hi, everyone.  I'm Tom.  I'm 
one of the technical leads in 

07:10:15.633 --> 07:10:21.883
the VR and AR efforts in Google.
  We specialize in developer 

07:10:21.884 --> 07:10:26.035
productivity tools.  I'm excited
 just a week after announcing 

07:10:26.036 --> 07:10:28.115
ARCore to talk to you about the 
ARCore

07:10:32.195 --> 07:10:36.366
 SDK preview and how you can add
 AR capabilities to your Android

07:10:36.367 --> 07:10:38.489
 apps.  So just a quick run 
through of what we're going to 

07:10:38.490 --> 07:10:42.644
talk about today.  So we're 
going to talk about AR and it's 

07:10:42.645 --> 07:10:44.729
closely related cousin, VR.  
We're going to talk about the 

07:10:44.730 --> 07:10:48.903
concepts that underpin ARCore.  
A walk through the API.  We're 

07:10:48.904 --> 07:10:53.086
going to talk through all the 
options that we have to build 

07:10:53.087 --> 07:10:55.167
our AR content.  And talk about 
the options for

07:10:59.254 --> 07:11:03.425
 for building your code as well.
So before we get into the 

07:11:03.426 --> 07:11:07.602
technical details, I really want
 to start with what immersive 

07:11:07.603 --> 07:11:11.759
computing means.  Where we've 
come from and what can it do for

07:11:11.760 --> 07:11:18.001
 you?  I'm always asked why AR 
and VR?  We have mobile devices.

07:11:18.002 --> 07:11:22.161
  It's great.  Why should we do 
these other things?  So with 

07:11:22.162 --> 07:11:26.457
card board, daydream and tango, 
we have been investing for quite

07:11:29.539 --> 07:11:31.539
 some time.  And we believe that
 interacting with data in a more

07:11:31.630 --> 07:11:33.722
 natural way is the future.  And
 immersive computing removes the

07:11:35.785 --> 07:11:37.874
 distractions between you and 
your computing.  So I want to 

07:11:37.875 --> 07:11:42.035
take a minute discussing these 
technologies before we jump into

07:11:42.036 --> 07:11:46.218
 some code.
So we think of AR and VR as 

07:11:46.219 --> 07:11:50.386
being points on a spectrum of 
immersive computing.  On the far

07:11:50.387 --> 07:11:54.566
 left, reality, the world as we 
know it that we're in  today.  

07:11:54.567 --> 07:11:56.654
If it we start to add digital 
content into our reality, then 

07:11:56.655 --> 07:12:02.895
we start to augment it.  Hence, 
augmented reality.  And if we 

07:12:02.896 --> 07:12:09.149
completely replace that reality 
with a virtual, we have virtual 

07:12:09.150 --> 07:12:13.314
 reality.  And so AR can bring 
any of your digital content to 

07:12:13.315 --> 07:12:19.577
you and in your world.  Such as 
this guy posing with the dog.  

07:12:19.578 --> 07:12:23.740
So some of the benefits of AR, 
you can see objects at real size

07:12:23.741 --> 07:12:28.545
 and scale in your world.  
Imagine being able to buy 

07:12:28.546 --> 07:12:30.603
furniture and being able to see 
if it actually fits in your 

07:12:30.604 --> 07:12:34.734
house before you buy it?
You can also see things in 

07:12:34.735 --> 07:12:36.817
context.  Again, imagine buying 
that furniture and making sure 

07:12:36.818 --> 07:12:40.980
that it matches with all the 
other decorating in your house. 

07:12:40.981 --> 07:12:43.444
 And imagine being able to 
annotate the real

07:12:46.556 --> 07:12:48.637
 world.  Like post it notes 
without causing a real physical 

07:12:48.638 --> 07:12:56.944
mess.  And also has the ability 
for natural input for 3D scenes.

07:12:56.945 --> 07:12:59.034
  If you have used digital 
creation and content tools, it's

07:13:01.145 --> 07:13:03.238
 hard to control that camera in 
your scene.  With augmented 

07:13:03.239 --> 07:13:07.418
reality, you hold your phone and
 just look at it.  And anyone 

07:13:07.419 --> 07:13:09.500
can do it.
And then if you replace 

07:13:09.501 --> 07:13:13.654
everything in your world with 
the virtual -- with digital 

07:13:13.655 --> 07:13:17.790
content -- you have virtual 
reality.  It allows you to go to

07:13:17.791 --> 07:13:21.962
 places and visit worlds in an 
instant.  And some benefits of 

07:13:21.963 --> 07:13:26.099
this are you get complete 
immersion.  You really feel like

07:13:26.100 --> 07:13:28.194
 you have been transported to 
another place.  And there's some

07:13:28.195 --> 07:13:32.338
 really, really huge innovations
 in input that really lets you 

07:13:32.339 --> 07:13:38.550
work naturally in your world.  
Both VR and AR enable us to 

07:13:38.551 --> 07:13:42.738
experience computing more like 
we experience the real world.  

07:13:42.739 --> 07:13:45.517
And both take advantage of a lot
 of the same technologies.

07:13:45.518 --> 07:13:49.664
So back in 2014 we started with 
the idea that your devices 

07:13:49.665 --> 07:13:53.839
should be able to understand 
more of the world.  So with 

07:13:53.840 --> 07:13:58.044
dedicated hardware, tango  
allowed us to understand the 

07:13:58.045 --> 07:14:00.103
depth and build great 
applications from being able to 

07:14:00.104 --> 07:14:04.290
measure your world.  Being able 
to map and share your house.  

07:14:04.291 --> 07:14:06.355
And to be able to play some 
games on your table top with 

07:14:06.356 --> 07:14:14.651
your friends.  We built two 
consumer devices with Asys and 

07:14:14.652 --> 07:14:18.787
Lenovo and created over a 
hundred applications for tango. 

07:14:18.788 --> 07:14:22.959
 And you we can do more with 
software than three years ago 

07:14:22.960 --> 07:14:25.043
and don't have to rely on custom

07:14:29.130 --> 07:14:31.202
 sensors.  And leads us to last 
week's announce want with ARCore

07:14:33.279 --> 07:14:37.423
.  Last week we announced 
ARCore.  It's a preview SDK to 

07:14:37.424 --> 07:14:41.595
get up and running.  We're 
building applications right now.

07:14:41.596 --> 07:14:45.741
  It takes everything from tango
 and makes it available on the 

07:14:45.742 --> 07:14:49.925
phone you have today, no cameras
 or sensors required

07:14:54.018 --> 07:14:56.100
 required.  It's in development,
 and we want to get your 

07:14:56.101 --> 07:14:58.194
feedback to make this work for 
you.

07:14:58.195 --> 07:15:02.353
And with 2 billion devices out 
there, we have a huge potential 

07:15:02.354 --> 07:15:06.513
audience for this technology.  
With ARCore so far running on 

07:15:06.514 --> 07:15:12.748
the pixel, pixel XL and the 
galaxy S8 we run on millions.  

07:15:12.749 --> 07:15:18.982
And working with Samsung, Asi 
and others.  So we anticipate we

07:15:18.983 --> 07:15:23.141
 are going to run on 100 million
 devices.  And we're working 

07:15:23.142 --> 07:15:27.284
with the hardware vendors to 
make this possible with a really

07:15:27.285 --> 07:15:29.344
 consistent bar for quality and 
high performance in the same way

07:15:29.345 --> 07:15:37.659
 that we did with Daydream.  
Before getting into the code, 

07:15:37.660 --> 07:15:39.742
it's important to understand 
some of the fundamental concepts

07:15:39.743 --> 07:15:43.946
 behind AR so you know how AR is
 working under the hood.

07:15:43.947 --> 07:15:48.105
So there are three main concepts
 to think  about.  One is motion

07:15:48.106 --> 07:15:54.339
 tracking.  Two is environmental
 understanding.  And three is 

07:15:54.340 --> 07:15:58.530
light estimation.  So let's go 
through them in a little bit of 

07:15:58.531 --> 07:16:02.685
detail now.  So to render AR 
content, you need a virtual 

07:16:02.686 --> 07:16:06.838
camera that matches your 
physical camera.  You render the

07:16:06.839 --> 07:16:11.015
 virtual scene, you compose it 
with your camera and you're 

07:16:11.016 --> 07:16:15.187
done.  This sounds simple.  It's
 actually really, really hard.  

07:16:15.188 --> 07:16:19.342
Your phone gyro scope is great 
for rotation, it can drift over 

07:16:19.343 --> 07:16:25.572
time.  And the axel ROMer is 
great for instantaneous inputs, 

07:16:25.573 --> 07:16:29.712
not so good for actual position.
  The hard part of getting AR 

07:16:29.713 --> 07:16:31.766
right is figuring out the 
translation and rotation of the 

07:16:31.767 --> 07:16:35.976
device in real time so you can 
render digital  objects with the

07:16:38.060 --> 07:16:40.156
 same virtual camera as your 
physical camera.  If you get 

07:16:40.157 --> 07:16:42.226
this wrong, objects in the world
 are

07:16:46.307 --> 07:16:50.475
 misaligned with the virtual 
components and won't appear 

07:16:50.476 --> 07:16:52.551
properly rooted in the world.
And you can see how effective we

07:16:52.552 --> 07:16:54.552
 have done this

07:16:56.618 --> 07:16:58.706
 ARCore with the scare crow that
 looks like everyone else 

07:16:58.707 --> 07:17:07.028
queuing for tacos.  To do this, 
we look the at camera and the 

07:17:07.029 --> 07:17:15.342
inertia using concurrent come 
try and mapping.  COM.  It 

07:17:15.343 --> 07:17:19.496
tracks over successive rings and
 builds up the point cloud to 

07:17:19.497 --> 07:17:21.620
localize against that point 
cloud.  This, combined with the 

07:17:21.621 --> 07:17:25.798
high-frequency INU gives you 
rotation and translation in the 

07:17:25.799 --> 07:17:29.977
world to render your virtual 
content in exactly the right 

07:17:29.978 --> 07:17:34.130
place.  This is over and above 
other experiences you may have 

07:17:34.131 --> 07:17:38.281
tried which only uses the 
gyroscope to get the rotation 

07:17:38.282 --> 07:17:40.353
which has the problem of content
  sliding around your world and 

07:17:40.354 --> 07:17:44.528
you can't move in closer for a 
better look.  This is key for 

07:17:44.529 --> 07:17:48.688
creating digital content of the 
real world.  So this 

07:17:48.689 --> 07:17:50.776
illustration is an example of 
the device tracking feature 

07:17:50.777 --> 07:17:54.942
points in your world that create
 a cloud.  When it does it for 

07:17:54.943 --> 07:18:01.170
real.
So motion tracking, really 

07:18:01.171 --> 07:18:03.241
important.  Environmental 
understanding is also 

07:18:03.242 --> 07:18:07.391
super-important.  Rendering 
content isn't actually that 

07:18:07.392 --> 07:18:09.471
interesting by itself.  You need
 to be able to interact with 

07:18:09.472 --> 07:18:13.635
your world as well.  So ARCore 
is looking for clusters of those

07:18:13.636 --> 07:18:19.858
 feature points that appear to 
lie on common, horizontal 

07:18:19.859 --> 07:18:21.934
surfaces and makes the surfaces 
available to your app as planes.

07:18:21.935 --> 07:18:28.253
  Since planes are 
mathematically infinite, ARCore 

07:18:28.254 --> 07:18:30.321
provides the bounds of the 
surfaces as a polygon.  And you 

07:18:30.322 --> 07:18:34.473
can place objects in your world 
like this Android guy here.

07:18:34.474 --> 07:18:37.448
So planes are detected on 
horizontal

07:18:40.552 --> 07:18:44.418
 surfaces such as the floor, 
tables, kitchen countertops, 

07:18:40.552 --> 07:18:46.798
benches, chairs, you name it.  
However, because ARCore uses 

07:18:46.799 --> 07:18:50.936
feature points to detect these 
surfaces, flat surfaces without 

07:18:50.937 --> 07:18:53.021
any texture or  
highly-reflective surfaces might

07:18:55.098 --> 07:18:59.254
 not be detected properly.
And then finally, light 

07:18:59.255 --> 07:19:03.407
estimation.  So ARCore is able 
to detect information about the 

07:19:03.408 --> 07:19:05.492
current environment's lighting 
and gives you a valuable 

07:19:05.493 --> 07:19:09.644
representing that given 
intensity of the camera image.  

07:19:09.645 --> 07:19:13.798
This lets you light your scene 
of the virtual objects under the

07:19:13.799 --> 07:19:15.872
 same conditions of the 
environment which increases that

07:19:15.873 --> 07:19:17.959
 sense of realism.  If you don't
 do this, your digital objects 

07:19:17.960 --> 07:19:22.123
will stand out and not appear to
 be a part that have world, 

07:19:22.124 --> 07:19:26.317
which is really, really key to 
realistic rendering.  And some 

07:19:26.318 --> 07:19:28.396
really fun effects, like you 
have a lion who gets scared when

07:19:28.397 --> 07:19:32.558
 you turn out the lights.
And it might seem frivolous, but

07:19:32.559 --> 07:19:34.945
 it's actually really important.
  If you've ever taken your 

07:19:34.946 --> 07:19:36.946
camera and just

07:19:38.030 --> 07:19:42.177
 looked at a light source or 
pointed out the window, the 

07:19:42.178 --> 07:19:44.264
autoexposure of the camera 
changes that range hugely.  It 

07:19:44.265 --> 07:19:48.470
can be really not so great it 
you don't take this into 

07:19:48.471 --> 07:19:50.545
account.
So now we've gone through the 

07:19:50.546 --> 07:19:56.788
main concepts of ARCore.  Let's 
jump into code and see what it 

07:19:56.789 --> 07:20:00.950
takes to build an AR application
 in Java.  So this is how I 

07:20:00.951 --> 07:20:05.114
think of the API.  You create a 
session which represents the AR 

07:20:05.115 --> 07:20:09.296
session you're running.  Once 
you have this, you update the 

07:20:09.297 --> 07:20:11.377
session and you have a frame.  
Once you have a frame, that 

07:20:11.378 --> 07:20:13.462
represents your camera

07:20:17.573 --> 07:20:19.653
 and the metadata that goes 
alongside that.  You create 

07:20:19.654 --> 07:20:23.794
planes.  Once you have planes, 
you're able to create anchors.  

07:20:23.795 --> 07:20:27.960
With anchors, you can place 
content in your real world.  And

07:20:27.961 --> 07:20:29.961
 the hello

07:20:32.028 --> 07:20:38.290
AR app is on GitHub and it's 
great to work with this.  So 

07:20:38.291 --> 07:20:42.420
going through the code, it's 
really, raylets to start an 

07:20:42.421 --> 07:20:46.597
ARCore session.  Just start a 
session.  We provide a default 

07:20:46.598 --> 07:20:48.691
configuration file which 
basically turns on every part of

07:20:48.692 --> 07:20:52.825
 the API.  Motion tracking, 
plane finding, light estimation.

07:20:52.826 --> 07:21:01.116
  A simple way to check if your 
device does not support ARCore. 

07:21:01.117 --> 07:21:05.297
 And when we come to render our 
application, first thing we do 

07:21:05.298 --> 07:21:09.466
is clear the frame.
And then we simply call 

07:21:09.467 --> 07:21:13.613
session.update.  One of the key 
concepts to understand here is, 

07:21:13.614 --> 07:21:15.695
when you created your session, 
one of the things you might want

07:21:15.696 --> 07:21:21.894
 to change within your config is
 whether it's using blocking or 

07:21:21.895 --> 07:21:26.070
latest camera image.  If it uses
 blocking, it basically gives 

07:21:26.071 --> 07:21:30.275
you a frame at the rate at which
 your camera runs.  Which kind 

07:21:30.276 --> 07:21:32.354
of makes sense.  You don't want 
to render any faster than you 

07:21:32.355 --> 07:21:36.534
have to.  You want to make sure 
that every pose aligns with 

07:21:36.535 --> 07:21:38.609
every frame.  But for some of 
your applications where you want

07:21:40.698 --> 07:21:44.885
 a really smooth update, you 
have animations, you might just 

07:21:44.886 --> 07:21:49.330
want to render as fast as you 
can and at the expense of power 

07:21:49.331 --> 07:21:51.411
and performance.
So once you have a frame, we 

07:21:51.412 --> 07:21:59.720
have this helper function.  Hit 
test.  Which helps us do custom 

07:21:59.721 --> 07:22:01.781
array into the world based on a 
touch location and see if you 

07:22:01.782 --> 07:22:05.971
have touched one of these 
planes.  If it  collided and the

07:22:05.972 --> 07:22:10.113
 tap was within the bounds of 
that detected plane, go into the

07:22:10.114 --> 07:22:14.267
 anchor.  And we'll go into 
anchors more later.  We have to 

07:22:14.268 --> 07:22:16.334
see if the frame was actually 
tracking.  You know, if you put 

07:22:16.335 --> 07:22:20.510
your hand in front of the camera
 or something and you're not 

07:22:20.511 --> 07:22:22.586
tracking, you want to make sure 
that your intersections are 

07:22:22.587 --> 07:22:26.744
correct.
And then you query the frame for

07:22:26.745 --> 07:22:30.869
 all the data that you need to 
render your objects.  And don't 

07:22:30.870 --> 07:22:35.018
worry if you haven't used 
projection matrices before and 

07:22:35.019 --> 07:22:39.182
you don't know from a view 
matrix is.  That's okay.  As 

07:22:39.183 --> 07:22:41.300
mentioned earlier, to render 
this AR content, you have to 

07:22:41.301 --> 07:22:45.435
match the field of view of your 
virtual camera with the field of

07:22:45.436 --> 07:22:51.674
 view of the real camera.  The 
projection matrix has all the  

07:22:51.675 --> 07:22:53.753
properties you need and take the
 ARCore session to get access to

07:22:53.754 --> 07:22:57.934
 those.  And in this example we 
set the range of objects that 

07:22:57.935 --> 07:23:02.126
you'll render from 10 
centimeters to 100 meters.  And 

07:23:02.127 --> 07:23:06.286
then the view matrix is what 
contains out information from 

07:23:06.287 --> 07:23:10.450
motion  tracking.  That contains
 the pose of where the camera is

07:23:12.512 --> 07:23:14.597
 in the world.  And finally, 
getting access to the lighting 

07:23:14.598 --> 07:23:18.730
estimation.  Just a simple call.
  Once you have that value, you 

07:23:18.731 --> 07:23:22.877
can either use it for some 
logic, or use it to affect your 

07:23:22.878 --> 07:23:27.040
rendering and your lighting.
And then finally, we loop over 

07:23:27.041 --> 07:23:31.191
all of our  an cores we have 
placed in the world.  And if 

07:23:31.192 --> 07:23:35.329
they're being tracked, we render
 those objects.  So if the 

07:23:35.330 --> 07:23:37.405
projection matrix contain the 
camera  properties and the view 

07:23:37.406 --> 07:23:43.693
matrix contains the camera 
location, the model matrix 

07:23:43.694 --> 07:23:45.786
contains the location of that 
anchor within the world.  And 

07:23:45.787 --> 07:23:54.108
with the combined model view 
projection matrix, you can put 

07:23:54.109 --> 07:23:56.202
pixels on the screen and 
properly overlay on top of your 

07:23:56.203 --> 07:24:00.386
camera feed.
So talking about anchors, why do

07:24:00.387 --> 07:24:06.580
 we need  anchor?  What is this 
concept of an anchor?  You might

07:24:06.581 --> 07:24:10.759
 think, it's three-dimensional 
space.  Why not call it the 

07:24:10.760 --> 07:24:14.894
origin and place your objects 
relative to that?  So it turns 

07:24:14.895 --> 07:24:16.976
out there's actually some error 
in the poses you get back from 

07:24:16.977 --> 07:24:23.193
motion  tracking.  Motion 
tracking is constantly updating 

07:24:23.194 --> 07:24:27.372
 its understanding of the world.
  And if you use anchors, as 

07:24:27.373 --> 07:24:29.449
this understanding of the world 
updates, the pose of your models

07:24:29.450 --> 07:24:33.611
 will update as well.  A good 
example where you want to use 

07:24:33.612 --> 07:24:37.803
anchors is, imagine walking 
around a building in a loop.  

07:24:37.804 --> 07:24:39.886
When you get back to where you 
started, that drift will have 

07:24:39.887 --> 07:24:44.025
accumulated over time and you 
want to use anchors to make sure

07:24:44.026 --> 07:24:50.281
 that all stays correct.
And so if you place an anchor in

07:24:50.282 --> 07:24:52.375
 the world, you should make sure
 you place the digital object on

07:24:52.376 --> 07:24:54.376
 top

07:24:56.456 --> 07:25:00.603
 of that anchor as well.  Any 
time there's error in the 

07:25:00.604 --> 07:25:02.674
rotation, the further away from 
the anchor, you will end up with

07:25:04.766 --> 07:25:08.916
 a lever arm effect where you're
 pivoting around the center of 

07:25:08.917 --> 07:25:13.072
the object and it's translated 
off from where it wants to be.  

07:25:13.073 --> 07:25:17.205
And think about these anchors 
are there to root your digital 

07:25:17.206 --> 07:25:19.271
objects -- your physical objects
 -- in the world.  If I was 

07:25:19.272 --> 07:25:25.500
going to place an object on a 
chair, I want to create one 

07:25:25.501 --> 07:25:27.592
anchor for the chair, place the 
object on the chair.  Ten 

07:25:27.593 --> 07:25:31.786
objects on my desk, I don't need
 to create ten anchors.  Just 

07:25:31.787 --> 07:25:38.027
create one and place them all 
relative to it.  Again, avoid 

07:25:38.028 --> 07:25:42.211
the global coordinate systems.  
You'll have a bad time if you 

07:25:42.212 --> 07:25:44.282
use those.
So we kind of skipped over this.

07:25:46.392 --> 07:25:48.468
  Apart from clearing the 
screen, we didn't really talk 

07:25:48.469 --> 07:25:52.643
about rendering 3D.  Rendering 
3D is actually a really big 

07:25:52.644 --> 07:25:56.811
topic that I couldn't possibly 
cover in a 30-minute talk here 

07:25:56.812 --> 07:26:00.955
today.  But to give you 
something to look at, there are 

07:26:00.956 --> 07:26:09.284
a few options.  You can use open
 GL/ES directly.  And we have 

07:26:09.285 --> 07:26:13.441
great tutorials to get  started 
on developer.android.com.  Or 

07:26:13.442 --> 07:26:17.604
frameworks such as Rajawali that
 does a lot of the heavy  

07:26:17.605 --> 07:26:23.847
lifting.  Or look at our sample 
which contains model rendering 

07:26:23.848 --> 07:26:25.942
code if you want to place some 
objects in had your world.

07:26:25.943 --> 07:26:32.250
So not only does ARCore work 
with Java, it also works with 

07:26:32.251 --> 07:26:36.414
Unity and Unreal.  And we have 
done a lot of work to make sure 

07:26:36.415 --> 07:26:40.548
it integrates really well.  
Common game engines like these, 

07:26:40.549 --> 07:26:42.626
they remove a lot of the 
complexity from managing a 

07:26:42.627 --> 07:26:46.793
complex 3D scene so you can 
actually focus on actually 

07:26:46.794 --> 07:26:50.958
building your application.  So 
weave ported helloAR into Unity.

07:26:50.959 --> 07:26:55.141
  You can see it there.  It 
exercises all of those same 

07:26:55.142 --> 07:26:57.227
APIs.  And we have designed it 
so you can  easily get up to 

07:26:57.228 --> 07:27:03.479
speed, use those scripts and  
prefabs in your own application 

07:27:03.480 --> 07:27:07.634
and it becomes part of the SDK 
when you download it.

07:27:07.635 --> 07:27:11.795
And similarly, the same for 
Unreal as well.  We have done 

07:27:11.796 --> 07:27:13.878
everything to make building your
 AR applications really easy 

07:27:13.879 --> 07:27:18.035
using the tools that you're most
 familiar with.

07:27:18.036 --> 07:27:24.297
So another option is WebbXR.  So
 real web standards for AR don't

07:27:24.298 --> 07:27:26.398
 exist yet.  But these 
prototypes allow web developers 

07:27:26.399 --> 07:27:30.541
to start building augmented 
reality web experiences today.  

07:27:30.542 --> 07:27:34.734
Their experiments will teach us 
all what AR on the web will look

07:27:34.735 --> 07:27:38.904
 like.  And hopefully make the 
design standards faster and 

07:27:38.905 --> 07:27:43.074
better designed.  These are 
built on top of web VR.  If 

07:27:43.075 --> 07:27:47.213
you're familiar with that, it's 
easy to get up and running with 

07:27:47.214 --> 07:27:51.331
WebXR.  And this demo also works
 in experimental versions of 

07:27:51.332 --> 07:27:55.505
Chrome for AR kit as well on iOS
.

07:27:55.506 --> 07:28:01.767
And so we've talked a lot about 
building AR applications, but 

07:28:01.768 --> 07:28:05.922
the really hard part is, how do 
I get content?  We all know how 

07:28:05.923 --> 07:28:10.124
to create content for 2D.  We 
know how to get images.  We know

07:28:10.125 --> 07:28:14.307
 how to get text, fonts, videos.
  We know how to create them and

07:28:14.308 --> 07:28:18.488
 we know how to use them in our 
applications.  So Google have 

07:28:18.489 --> 07:28:22.634
been working in AR and VR for 
quite some time.  We've made 

07:28:22.635 --> 07:28:26.817
creating this content really, 
really easy.  Which is why we 

07:28:26.818 --> 07:28:30.998
created blocks.  So blocks let's
 you build 3D content in VR 

07:28:30.999 --> 07:28:37.256
really  quickly.  And even if 
you don't have a VR head sed, 

07:28:37.257 --> 07:28:41.432
take a look at the library.  Any
 content is available for 

07:28:41.433 --> 07:28:43.514
download.  So let's take a quick
 look at some of the content 

07:28:43.515 --> 07:28:47.684
that our creators have built 
from blocks.  So if you want 

07:28:47.685 --> 07:28:49.685
this guy,

07:28:51.769 --> 07:28:55.926
 are a men chef in your kitchen,
 is that is available to you.  

07:28:55.927 --> 07:29:02.206
And if you want this guy to 
watch over you at night on your 

07:29:02.207 --> 07:29:04.290
bedside table, you can live that
 dream.  It's really impressive 

07:29:04.291 --> 07:29:06.374
what people have made using 
blocks. 

07:29:06.375 --> 07:29:12.649
It's a super easy way to get 3D 
content in your application.  

07:29:12.650 --> 07:29:16.818
Led head to our blocks Website, 
download it and give it a play. 

07:29:16.819 --> 07:29:20.993
 It's really, really fun 
building in VR.  Before we 

07:29:20.994 --> 07:29:25.157
finish, I would love to give you
 a taste of some of the things 

07:29:25.158 --> 07:29:27.248
that we built in ARCore.

07:30:41.508 --> 07:30:43.508
[ Applause ]

07:30:45.599 --> 07:30:49.744
So this has been a whirlwind 
tour of the capabilities of 

07:30:49.745 --> 07:30:53.922
ARCore.  And all the information
 you need to get started is 

07:30:53.923 --> 07:30:56.000
there today on our Website.  So 
we've talked about the 

07:30:56.001 --> 07:31:00.157
fundamentals of AR, we've talked
 about the options you have to 

07:31:00.158 --> 07:31:02.255
build your AR applications, and 
we've talked about how to build 

07:31:02.256 --> 07:31:10.540
content for those applications. 
 With actively  seeking feedback

07:31:10.541 --> 07:31:12.613
 from developers such as 
yourselves through this phase.  

07:31:12.614 --> 07:31:16.772
And monitoring GitHub and other 
channels closely so we're 

07:31:16.773 --> 07:31:20.978
building a platform that works 
for what you want to build.  You

07:31:20.979 --> 07:31:25.123
 can see the  AR next big shift 
in what's possible for the 

07:31:25.124 --> 07:31:29.278
mobile devices.  Get started 
with the ARCore today.  We 

07:31:29.279 --> 07:31:31.350
really can't wait to see what 
you've built.  Thank you.

07:31:31.351 --> 07:31:33.351
[ Applause ]

