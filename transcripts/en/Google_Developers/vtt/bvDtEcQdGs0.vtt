WEBVTT
Kind: captions
Language: en

00:00:01.000 --> 00:00:05.500
AUDIENCE: [APPLAUSE]

00:00:05.500 --> 00:00:07.500
ERIK TOTH: Whoa.

00:00:07.500 --> 00:00:08.180
Thanks.

00:00:08.180 --> 00:00:11.360
So my name's Eric.

00:00:11.360 --> 00:00:13.120
That's me.

00:00:13.120 --> 00:00:15.880
So I'm engineering
manager at Paypal.

00:00:15.880 --> 00:00:18.497
And I think Dan alluded
to it earlier in his talk,

00:00:18.497 --> 00:00:20.580
we've been working with
Node for a couple of years

00:00:20.580 --> 00:00:25.220
now, getting it as a first-class
platform to build applications.

00:00:25.220 --> 00:00:28.180
So I'm going to talk a little
bit tonight about Node.js

00:00:28.180 --> 00:00:32.729
at scale, and I know that
that's a little bit ambiguous.

00:00:32.729 --> 00:00:37.330
I think Node.js at scale--
what does that mean?

00:00:37.330 --> 00:00:40.000
And in fact, for getting
Node into Paypal,

00:00:40.000 --> 00:00:46.230
it meant a lot of things,
but I think the main things

00:00:46.230 --> 00:00:48.060
that it meant for
us were scaling

00:00:48.060 --> 00:00:50.057
across three
different dimensions.

00:00:50.057 --> 00:00:51.140
It wasn't just technology.

00:00:51.140 --> 00:00:52.680
It wasn't like we
can pick a technology

00:00:52.680 --> 00:00:53.580
and just roll it out.

00:00:53.580 --> 00:00:55.170
Everybody would use it
with no loss of products,

00:00:55.170 --> 00:00:56.290
and Bob's your uncle.

00:00:56.290 --> 00:00:58.350
You just move on from there.

00:00:58.350 --> 00:01:01.380
What it actually meant was that
we needed to figure out how

00:01:01.380 --> 00:01:04.180
to scale Node and
get across people,

00:01:04.180 --> 00:01:07.690
educate a whole lot of people
in JavaScript and Node best

00:01:07.690 --> 00:01:12.150
practices, and that meant
transforming C++ and Java

00:01:12.150 --> 00:01:15.930
developers into JavaScript
developers and Node developers

00:01:15.930 --> 00:01:18.070
as well as bring
front end engineers,

00:01:18.070 --> 00:01:20.070
who are well versed
in JavaScript

00:01:20.070 --> 00:01:22.900
but didn't necessarily have
a lot of experience building

00:01:22.900 --> 00:01:25.322
server side stuff in Node
and understanding the Node

00:01:25.322 --> 00:01:27.655
ecosystem and what it really
meant to build applications

00:01:27.655 --> 00:01:29.560
at Node.

00:01:29.560 --> 00:01:32.150
It also meant that we needed
to look at our processes.

00:01:32.150 --> 00:01:35.530
A lot of process where
defined around Java,

00:01:35.530 --> 00:01:38.580
around other stacks, and
were built specifically

00:01:38.580 --> 00:01:40.460
for those stacks,
wherein you brought Node,

00:01:40.460 --> 00:01:44.180
there wasn't really an
analogous-- a proper fit.

00:01:44.180 --> 00:01:46.180
So what did that mean for
how our processes were

00:01:46.180 --> 00:01:47.520
built over time?

00:01:47.520 --> 00:01:50.136
And then finally, we could
really address the technology

00:01:50.136 --> 00:01:51.510
and see how can
we integrate Node

00:01:51.510 --> 00:01:54.820
into a lot of proprietary stuff
that we run and a lot of not

00:01:54.820 --> 00:01:58.390
proprietary stuff, and where
we could take advantage of what

00:01:58.390 --> 00:02:01.260
teams have done before and where
we need to forge new ground.

00:02:01.260 --> 00:02:04.462
But unfortunately, when you
come to talks like this,

00:02:04.462 --> 00:02:05.920
people just want
to see technology.

00:02:05.920 --> 00:02:07.460
They want to see code.

00:02:07.460 --> 00:02:10.385
But I think one of the better
things about the Node community

00:02:10.385 --> 00:02:13.360
and about how you
think about software

00:02:13.360 --> 00:02:16.050
and you build
software in Node is

00:02:16.050 --> 00:02:18.200
that it's only partially
the technology.

00:02:18.200 --> 00:02:21.050
A big portion of it is
around bringing new people

00:02:21.050 --> 00:02:23.570
into the fold,
bringing new engineers

00:02:23.570 --> 00:02:26.860
into understanding how to write
JavaScript and Node JavaScript,

00:02:26.860 --> 00:02:28.160
and mentorship.

00:02:28.160 --> 00:02:30.260
And I think one of the
most interesting things

00:02:30.260 --> 00:02:33.140
about the community
for me is that there's

00:02:33.140 --> 00:02:36.750
a very concerted effort put
towards bringing in people that

00:02:36.750 --> 00:02:39.760
either don't know how to
write code in general,

00:02:39.760 --> 00:02:42.350
or just never tried it, and
embracing them and saying

00:02:42.350 --> 00:02:44.360
that this is something
that's for everybody

00:02:44.360 --> 00:02:45.693
and you can build awesome stuff.

00:02:45.693 --> 00:02:48.870
And Dan had mentioned
things like Node bots,

00:02:48.870 --> 00:02:50.630
the Internet of
Things-- like people

00:02:50.630 --> 00:02:53.910
can build stuff, build
anything they want,

00:02:53.910 --> 00:02:58.140
with a very straight-- arguably
straightforward language.

00:02:58.140 --> 00:02:59.670
We don't want to start that.

00:02:59.670 --> 00:03:01.000
AUDIENCE: [INAUDIBLE].

00:03:01.000 --> 00:03:03.170
ERIK TOTH: Yeah, really.

00:03:03.170 --> 00:03:05.100
But it's approachable,
and the Node community

00:03:05.100 --> 00:03:09.460
has made it more
approachable in my opinion.

00:03:09.460 --> 00:03:11.430
So even though the
first two phases

00:03:11.430 --> 00:03:13.830
are kind of the boring part
because we want technology,

00:03:13.830 --> 00:03:15.580
I'm going to talk about
them a little bit,

00:03:15.580 --> 00:03:18.090
at least how they pertain to
Paypal and some of the things

00:03:18.090 --> 00:03:19.680
that we've worked through.

00:03:19.680 --> 00:03:22.370
So first of all, scaling people,
and when you say like that,

00:03:22.370 --> 00:03:23.800
it sounds real weird.

00:03:23.800 --> 00:03:26.110
But it's about growing
people, and it's

00:03:26.110 --> 00:03:29.660
about educating people and
making people comfortable

00:03:29.660 --> 00:03:32.450
working in this environment.

00:03:32.450 --> 00:03:35.527
So there's the old analogy,
teach a person to fish--

00:03:35.527 --> 00:03:37.360
or give a person a fish,
they eat for a day.

00:03:37.360 --> 00:03:40.520
Teach a person-- whatever.

00:03:40.520 --> 00:03:44.310
It was very coincidental
that, while writing this,

00:03:44.310 --> 00:03:47.210
I remember that my buddy John
Charles wrote this bot that

00:03:47.210 --> 00:03:49.670
slaps people with
trouts for Slack.

00:03:49.670 --> 00:03:51.090
It's very strange.

00:03:51.090 --> 00:03:53.130
This isn't to indicate
that I actually

00:03:53.130 --> 00:03:54.970
taught John Charles anything.

00:03:54.970 --> 00:03:56.750
He actually teaches
me stuff every day,

00:03:56.750 --> 00:03:58.333
but it was something
that reminded me,

00:03:58.333 --> 00:04:00.600
like once you have a
team that's tight knit

00:04:00.600 --> 00:04:03.390
and people teach each
other all the time,

00:04:03.390 --> 00:04:06.520
it's just an incredible
ecosystem which you can grow

00:04:06.520 --> 00:04:07.580
and your team can grow.

00:04:07.580 --> 00:04:09.330
And you can do things
like slap each other

00:04:09.330 --> 00:04:10.560
with fish over Slack.

00:04:10.560 --> 00:04:12.350
It's pretty awesome.

00:04:12.350 --> 00:04:15.590
But that's all to say that
writing code isn't enough,

00:04:15.590 --> 00:04:19.120
and in the macro
level at Paypal,

00:04:19.120 --> 00:04:23.590
we had to train hundreds of
engineers, that's one thing.

00:04:23.590 --> 00:04:27.010
But then now, I'm a relatively
new engineering manager,

00:04:27.010 --> 00:04:30.170
I realize that it's not enough
just to put them in classrooms

00:04:30.170 --> 00:04:32.699
and say learn this stuff and
let's go churn out stuff.

00:04:32.699 --> 00:04:34.240
It's really important,
and again, I'm

00:04:34.240 --> 00:04:36.115
going to tie this back
to the Node community,

00:04:36.115 --> 00:04:37.890
that there's this
notion of mentorship,

00:04:37.890 --> 00:04:40.820
and there's this notion of
helping everyone around you

00:04:40.820 --> 00:04:42.920
grow because when
everybody grows,

00:04:42.920 --> 00:04:44.830
the whole ecosystem grows.

00:04:44.830 --> 00:04:47.694
So just kind of a wrap-up to
the people thing, something

00:04:47.694 --> 00:04:49.360
that I've instituted
on my team, and I'm

00:04:49.360 --> 00:04:52.310
hoping to be able to roll
out to other teams on Paypal,

00:04:52.310 --> 00:04:53.885
is kind of this
two-phased approach.

00:04:53.885 --> 00:04:55.510
And if anybody likes
the idea and wants

00:04:55.510 --> 00:04:58.360
to try it on their team,
that'd be incredible.

00:04:58.360 --> 00:05:01.600
One is, riffing off of
the Learn You concept,

00:05:01.600 --> 00:05:04.890
is every week I
allocate for my team

00:05:04.890 --> 00:05:07.100
a certain amount of time
to learn a new technology.

00:05:07.100 --> 00:05:08.420
It doesn't matter what it is.

00:05:08.420 --> 00:05:10.400
Just learn something
because anything you learn

00:05:10.400 --> 00:05:14.340
can be somehow applied
back to your everyday work.

00:05:14.340 --> 00:05:16.850
So we do things
like learning Elm,

00:05:16.850 --> 00:05:22.500
like learning Rust, like
learning Angular, any front end

00:05:22.500 --> 00:05:24.439
frameworks, React.js,
that type of stuff.

00:05:24.439 --> 00:05:26.480
And when we talk about it
at the end of the week,

00:05:26.480 --> 00:05:28.620
we see how can some
of these concepts

00:05:28.620 --> 00:05:30.320
feed back into how
we work with Node

00:05:30.320 --> 00:05:33.350
and how we work with other
organizations or teams

00:05:33.350 --> 00:05:37.650
around the company and
what that looks like.

00:05:37.650 --> 00:05:40.270
So that's every other week,
and then the alternating weeks,

00:05:40.270 --> 00:05:44.600
I challenge my team to
contribute code to some project

00:05:44.600 --> 00:05:46.100
that either you're
passionate about

00:05:46.100 --> 00:05:47.370
or that you use on
a regular basis,

00:05:47.370 --> 00:05:49.110
and this is something that has
been huge in the Node community

00:05:49.110 --> 00:05:49.609
for me.

00:05:49.609 --> 00:05:53.730
And it's directly taught me how
I can not only contribute just

00:05:53.730 --> 00:05:55.290
by putting my own
code out there,

00:05:55.290 --> 00:05:58.130
but I can contribute by
reading other people's code,

00:05:58.130 --> 00:06:01.090
understanding how other
people solve problems,

00:06:01.090 --> 00:06:03.790
and then taking that and
either contribute directly

00:06:03.790 --> 00:06:05.880
to that or wrapping that
into how I solve problems

00:06:05.880 --> 00:06:09.440
and ultimately build
better software.

00:06:09.440 --> 00:06:13.324
So as far as wrapping up the
growing people aspect of it,

00:06:13.324 --> 00:06:14.990
I think there are
very constructive ways

00:06:14.990 --> 00:06:17.550
you can help your team
directly contribute

00:06:17.550 --> 00:06:22.420
to the Node community, which
is exceedingly embraces anybody

00:06:22.420 --> 00:06:25.310
who wants to contribute,
but also add value

00:06:25.310 --> 00:06:27.790
to them personally and
your team as a whole

00:06:27.790 --> 00:06:31.310
and make your team
just operate better.

00:06:31.310 --> 00:06:34.430
So moving on from
that, the second point,

00:06:34.430 --> 00:06:38.970
the second boring point I
guess, is the scaling process,

00:06:38.970 --> 00:06:44.080
and this is not to indicate that
process always has to scale up.

00:06:44.080 --> 00:06:46.410
In our case, actually,
processes scale down,

00:06:46.410 --> 00:06:48.130
and Node was one
of those factors.

00:06:48.130 --> 00:06:52.140
And in fact, it was a bit of a
catalyst for some of the things

00:06:52.140 --> 00:06:54.332
that scaled down.

00:06:54.332 --> 00:06:55.790
So I'm going to
talk about a couple

00:06:55.790 --> 00:06:59.310
of specific things that
happened for us at Paypal.

00:07:02.660 --> 00:07:05.800
This is not to say that JVM
expertise isn't important.

00:07:08.460 --> 00:07:11.550
In my experience, I've
observed that sometimes there

00:07:11.550 --> 00:07:14.500
are JVM experts
that exist merely

00:07:14.500 --> 00:07:17.470
to wallpaper over the fact that
engineers don't necessarily

00:07:17.470 --> 00:07:20.050
pay attention to performance
when they build applications.

00:07:20.050 --> 00:07:22.840
Performance is a value add
by another organization

00:07:22.840 --> 00:07:25.835
after an application gets built.

00:07:25.835 --> 00:07:27.700
That can't hold true with Node.

00:07:27.700 --> 00:07:31.209
Engineers need to understand the
consequences of the decisions

00:07:31.209 --> 00:07:32.250
when they write software.

00:07:32.250 --> 00:07:34.030
They need to
understand, maybe not

00:07:34.030 --> 00:07:38.800
quite to the level of Trevor--
that's pretty awesome,

00:07:38.800 --> 00:07:41.320
but I don't know that
it's generally applicable.

00:07:41.320 --> 00:07:43.010
But they definitely
need to understand

00:07:43.010 --> 00:07:45.980
that when I'm writing code, when
I'm interacting with a network

00:07:45.980 --> 00:07:48.970
resource, with the file system,
doing anything-- just you're

00:07:48.970 --> 00:07:51.470
talking about maybe some
system level stuff isn't

00:07:51.470 --> 00:07:53.420
the right fit for
Node, engineers

00:07:53.420 --> 00:07:55.515
need to understand
that there are

00:07:55.515 --> 00:07:57.140
certain consequences
of their decisions

00:07:57.140 --> 00:07:59.970
and that there are some things
that are not a natural fit.

00:07:59.970 --> 00:08:01.750
But that's OK.

00:08:01.750 --> 00:08:05.630
I don't think it's right to
expect that engineers can just

00:08:05.630 --> 00:08:09.630
bang out code, and then somebody
else can clean up after them.

00:08:09.630 --> 00:08:11.890
So I think part of
the process thing

00:08:11.890 --> 00:08:14.602
is making the process
of educating engineers,

00:08:14.602 --> 00:08:16.310
understanding that
there are consequences

00:08:16.310 --> 00:08:20.120
to their decisions, and that
right design is-- right design?

00:08:20.120 --> 00:08:22.330
That doesn't really make sense.

00:08:22.330 --> 00:08:26.110
But that thinking about
design before you start coding

00:08:26.110 --> 00:08:30.312
has a meaningful impact, and you
can still build great software,

00:08:30.312 --> 00:08:32.770
and you don't have to have
these other guys that come along

00:08:32.770 --> 00:08:35.520
and cleanup for people that
just need to meet deadlines

00:08:35.520 --> 00:08:41.210
and just, I don't know,
check things off their list.

00:08:41.210 --> 00:08:43.960
So let's move on
to the next thing,

00:08:43.960 --> 00:08:46.740
and this is not an
anti-Java thing.

00:08:46.740 --> 00:08:52.490
This is just from multiple
Java shops that I've worked at.

00:08:52.490 --> 00:08:54.070
I've really seen
that, if you have

00:08:54.070 --> 00:08:56.330
platforms that take a
lot of time to deploy

00:08:56.330 --> 00:08:58.357
and a lot of time for
applications to start

00:08:58.357 --> 00:09:00.440
and a lot of time to find
caches and a lot of time

00:09:00.440 --> 00:09:05.610
to do all this stuff, you
start designing your system

00:09:05.610 --> 00:09:08.430
to have to avoid doing
things like restarts.

00:09:08.430 --> 00:09:13.100
And one of things that the Node
community embraces, and it's

00:09:13.100 --> 00:09:14.890
generally by virtue
of the fact that you

00:09:14.890 --> 00:09:18.660
have small processes
and very discreet things

00:09:18.660 --> 00:09:22.260
that your applications
are intended to do,

00:09:22.260 --> 00:09:24.480
you no longer have to
worry about accommodating

00:09:24.480 --> 00:09:26.192
10 minute, 15 minute
startup times.

00:09:26.192 --> 00:09:28.650
You can write applications that
are very good at that thing

00:09:28.650 --> 00:09:32.390
that they do, and they can
be resilient to some types

00:09:32.390 --> 00:09:35.100
of situations, but they can also
fail and restart very quickly

00:09:35.100 --> 00:09:42.420
and take traffic without
much of a hiccup, if any.

00:09:42.420 --> 00:09:44.914
And this is really just
about controlling complexity.

00:09:44.914 --> 00:09:47.080
There's nothing that wrong
with hot swapping things,

00:09:47.080 --> 00:09:49.550
about flushing caches
into other caches.

00:09:49.550 --> 00:09:50.650
It's not a bad design.

00:09:50.650 --> 00:09:52.620
In a lot of cases,
that's good design.

00:09:52.620 --> 00:09:54.480
But there are so many
times that complexity

00:09:54.480 --> 00:09:58.020
is added to counter problems
elsewhere in your stack,

00:09:58.020 --> 00:10:00.580
like it takes 10 minutes,
15 minutes for applications

00:10:00.580 --> 00:10:02.890
to startup.

00:10:02.890 --> 00:10:05.020
Not withstanding that,
especially for developer

00:10:05.020 --> 00:10:07.920
experiences, if your app takes
10 minutes to start up just

00:10:07.920 --> 00:10:10.130
when a developer is
trying to do their work,

00:10:10.130 --> 00:10:10.950
they're not going
to get anything

00:10:10.950 --> 00:10:12.510
done during the day,
especially when you talk

00:10:12.510 --> 00:10:14.968
about the back end to front
end, where engineers are trying

00:10:14.968 --> 00:10:19.290
to write HTML JavaScript in
CSS, but they are bound by-- I

00:10:19.290 --> 00:10:21.439
got to bounce my server
because I made a change.

00:10:21.439 --> 00:10:22.980
That change is a
payload that I need,

00:10:22.980 --> 00:10:26.400
and now I go take
a coffee break.

00:10:26.400 --> 00:10:28.180
And then the last
kind of big thing

00:10:28.180 --> 00:10:29.740
that-- I guess
it's not the last.

00:10:29.740 --> 00:10:32.800
Next to the last major
thing that I've noticed,

00:10:32.800 --> 00:10:35.470
which I think Node has been a
little bit of a catalyst for,

00:10:35.470 --> 00:10:38.060
but it was already happening
to a certain extent,

00:10:38.060 --> 00:10:42.654
is-- and again, this is probably
somewhat specific to Paypal.

00:10:42.654 --> 00:10:44.070
For people at small
organizations,

00:10:44.070 --> 00:10:45.790
you probably don't
run into this.

00:10:45.790 --> 00:10:47.970
But there can be a lot
of layers between you

00:10:47.970 --> 00:10:50.220
and where your code is
actually running in production.

00:10:50.220 --> 00:10:53.320
There can be situations where
you hand off some artifact,

00:10:53.320 --> 00:10:54.840
and then it goes
into a black box,

00:10:54.840 --> 00:10:56.881
and you find out, OK, it's
running in production.

00:10:56.881 --> 00:10:59.090
Go check this system to
find out how it's performing

00:10:59.090 --> 00:11:01.090
or whatever.

00:11:01.090 --> 00:11:04.370
And there's been
incredible, relating back

00:11:04.370 --> 00:11:07.767
to, specifically, Paypal, this
great renaissance of developers

00:11:07.767 --> 00:11:09.350
have the control of
their own destiny.

00:11:09.350 --> 00:11:10.660
They have control
of their deployment.

00:11:10.660 --> 00:11:12.690
They have control of
the code that goes out.

00:11:12.690 --> 00:11:15.080
They understand all the
processes, all the steps that

00:11:15.080 --> 00:11:16.760
happen between--
when they're ready,

00:11:16.760 --> 00:11:20.360
they build their artifact,
they deploy it, it runs.

00:11:20.360 --> 00:11:22.240
They can see everything
in that process,

00:11:22.240 --> 00:11:23.740
and it gives them
a lot more freedom

00:11:23.740 --> 00:11:26.500
to understand-- again tying it
back to the understanding what

00:11:26.500 --> 00:11:29.840
your code is doing in
production or having ownership

00:11:29.840 --> 00:11:31.970
over things like performance.

00:11:31.970 --> 00:11:33.470
When you can see
that transparently,

00:11:33.470 --> 00:11:37.250
and you don't have these layers
in between you and your code,

00:11:37.250 --> 00:11:39.560
it's really easy to feel
empowered to do something

00:11:39.560 --> 00:11:41.840
about it.

00:11:41.840 --> 00:11:45.602
And then finally,
this is-- I don't

00:11:45.602 --> 00:11:46.810
know if it's a process thing.

00:11:46.810 --> 00:11:47.810
I don't know what it is.

00:11:47.810 --> 00:11:51.950
But moving from
Maven to NPM is kind

00:11:51.950 --> 00:11:55.380
of a big-- it's kind
of awesome, and there's

00:11:55.380 --> 00:11:59.250
a little shout out
in there to Kappa.

00:11:59.250 --> 00:12:02.240
So at Paypal, we
haven't yet migrated.

00:12:02.240 --> 00:12:04.620
We've done the beta
test for NPM Enterprise.

00:12:04.620 --> 00:12:07.650
So in the meantime, we've
run our own registry,

00:12:07.650 --> 00:12:13.070
and we use a thing we wrote
called Kappa to proxy requests.

00:12:13.070 --> 00:12:17.470
So we publish all of our private
modules to one NPM registry,

00:12:17.470 --> 00:12:20.659
and then Kappa will check
that registry for a module.

00:12:20.659 --> 00:12:22.200
If it doesn't exist,
it'll then check

00:12:22.200 --> 00:12:26.410
Public, which gives us nice
separation between where

00:12:26.410 --> 00:12:30.450
our proprietary code
lives and Public NPM.

00:12:30.450 --> 00:12:33.590
And it turns out that,
for a lot of use cases,

00:12:33.590 --> 00:12:34.860
that's really good.

00:12:34.860 --> 00:12:36.700
And in fact, for us-- excuse me.

00:12:36.700 --> 00:12:39.340
Just to kind of get
a idea of the scale

00:12:39.340 --> 00:12:41.870
that people are working
in Node at Paypal,

00:12:41.870 --> 00:12:43.430
right now, Kappa
is serving-- and it

00:12:43.430 --> 00:12:46.240
may be up because I just
grabbed this number about a week

00:12:46.240 --> 00:12:47.180
and a half ago.

00:12:47.180 --> 00:12:50.080
We're serving about half
a million pages-- sorry,

00:12:50.080 --> 00:12:53.010
half a million packages,
Node modules, per day

00:12:53.010 --> 00:12:56.490
through our private
Kappa instance.

00:12:56.490 --> 00:12:59.450
So there's a lot of
[INAUDIBLE] and PMIs going on.

00:12:59.450 --> 00:13:02.730
There's a lot of builds going on
that are [INAUDIBLE] packages,

00:13:02.730 --> 00:13:05.530
and there's a lot of people
that are publishing packages

00:13:05.530 --> 00:13:08.430
to our private registry.

00:13:08.430 --> 00:13:13.380
So I think it's been a really
interesting observation

00:13:13.380 --> 00:13:16.660
to see how processes,
these big processes that

00:13:16.660 --> 00:13:19.050
put a lot of people between
you and where your code goes,

00:13:19.050 --> 00:13:22.110
have started to erode to support
being able to iterate quickly,

00:13:22.110 --> 00:13:24.740
like Dan said, to be able
to observe and understand

00:13:24.740 --> 00:13:28.890
performance implications and
really just build applications

00:13:28.890 --> 00:13:33.460
very, very quickly and, in a
lot of cases, fairly robustly.

00:13:33.460 --> 00:13:36.620
These applications
are pretty good.

00:13:36.620 --> 00:13:40.520
So finally, scaling--
now, the technology part,

00:13:40.520 --> 00:13:44.760
which probably everybody's here
to talk about or here about.

00:13:44.760 --> 00:13:50.352
So Scaling Node.js-- so
I doubt anybody knows me

00:13:50.352 --> 00:13:52.560
personally from my involvement
in the Node community.

00:13:52.560 --> 00:13:56.620
Maybe some do, but
Paypal had introduced--

00:13:56.620 --> 00:13:59.270
it's been a while now,
maybe a year and a half.

00:13:59.270 --> 00:14:02.270
--this kind of frameworky thing
that sits on top of Express

00:14:02.270 --> 00:14:03.630
called Kraken.js.

00:14:03.630 --> 00:14:08.740
So Kraken.js was our
attempt to help scale Node

00:14:08.740 --> 00:14:11.920
across our organization, not
from a performance perspective,

00:14:11.920 --> 00:14:13.800
but take some of
the tribal knowledge

00:14:13.800 --> 00:14:16.730
out of setting up web
application servers

00:14:16.730 --> 00:14:19.065
and make it a repeatable
processes that you could have

00:14:19.065 --> 00:14:21.920
a predictable
application by default

00:14:21.920 --> 00:14:24.140
and let application
developers focus

00:14:24.140 --> 00:14:26.730
on building great products
and not think about wiring up

00:14:26.730 --> 00:14:28.450
all the low level
details that it

00:14:28.450 --> 00:14:31.990
takes to just get a baseline
robust server going.

00:14:34.575 --> 00:14:36.450
So that happened about
a year and a half ago.

00:14:36.450 --> 00:14:37.825
We're definitely
making progress.

00:14:37.825 --> 00:14:40.040
We're not still stuck there.

00:14:40.040 --> 00:14:42.790
Right now, we have about
30 web applications

00:14:42.790 --> 00:14:44.930
running in production.

00:14:44.930 --> 00:14:48.050
Some notable examples
are our homepage.

00:14:48.050 --> 00:14:50.510
It's not yet at 100%
traffic, but they're

00:14:50.510 --> 00:14:52.420
ramping up right now.

00:14:52.420 --> 00:14:55.160
Interesting kind
of hand-wavy stat

00:14:55.160 --> 00:14:57.660
that, only because I don't
think I can say actual numbers,

00:14:57.660 --> 00:15:00.257
is that they're on a
trajectory to use about half

00:15:00.257 --> 00:15:01.840
the number of servers
that were needed

00:15:01.840 --> 00:15:05.120
for the previous version that
was written in Java, which

00:15:05.120 --> 00:15:08.130
is a pretty awesome feat,
especially since traffic

00:15:08.130 --> 00:15:13.140
has grown since we were
running in Java before.

00:15:13.140 --> 00:15:15.510
And that's actually prior
to any optimization passes.

00:15:15.510 --> 00:15:16.370
They're right now
at the point where

00:15:16.370 --> 00:15:19.140
they're running optimization
passes over their application

00:15:19.140 --> 00:15:21.030
and focusing on very
specific bottlenecks,

00:15:21.030 --> 00:15:24.530
so that's been a really
encouraging thing.

00:15:24.530 --> 00:15:29.050
Things like the consumer
customer homepage, My Account

00:15:29.050 --> 00:15:33.382
page when you log in, 100%
US-- I think I wrote it down.

00:15:33.382 --> 00:15:33.881
Maybe not.

00:15:36.590 --> 00:15:40.200
--US, UK, and Germany I
think, 100% of traffic

00:15:40.200 --> 00:15:43.200
all running on Node.

00:15:43.200 --> 00:15:47.180
So we've got a couple of
applications running on Node.

00:15:47.180 --> 00:15:49.504
We've got a couple people
that know how to write apps.

00:15:49.504 --> 00:15:51.170
We've been able to
scale it pretty well,

00:15:51.170 --> 00:15:54.940
but there's definitely
been hiccups along the way.

00:15:54.940 --> 00:15:59.600
And I'm not sure--
I'm going to say it,

00:15:59.600 --> 00:16:03.800
that I think other than actual
programming errors, the lion's

00:16:03.800 --> 00:16:06.830
share of issues that you
run into with scaling Node

00:16:06.830 --> 00:16:09.490
all come back to some
form of back pressure,

00:16:09.490 --> 00:16:13.060
whether it's CPU constraints
that you have-- it's basically

00:16:13.060 --> 00:16:16.000
resource constraints based
on decisions that you make.

00:16:16.000 --> 00:16:18.190
So I have a lot of
network connections,

00:16:18.190 --> 00:16:20.870
and my downstream services
can't handle the load.

00:16:20.870 --> 00:16:24.670
This is why I consume resources
just by virtue of the fact

00:16:24.670 --> 00:16:27.440
that I have thousands of
concurrent connections open,

00:16:27.440 --> 00:16:29.890
or I'm doing a lot of
template rendering,

00:16:29.890 --> 00:16:31.780
like Trevor mentioned.

00:16:31.780 --> 00:16:34.480
So my CPU is bound
by some work that I'm

00:16:34.480 --> 00:16:37.471
doing that really has nothing to
do with my core business value

00:16:37.471 --> 00:16:37.970
issue.

00:16:37.970 --> 00:16:39.886
It's something that's a
side effect of needing

00:16:39.886 --> 00:16:41.290
to render pages or whatever.

00:16:41.290 --> 00:16:44.140
So one of the things that
we're trying to focus on

00:16:44.140 --> 00:16:46.450
is finding ways to
address those bottlenecks

00:16:46.450 --> 00:16:50.200
and allow teams to still
build applications quickly,

00:16:50.200 --> 00:16:55.930
but help fix some of
those potential pitfalls

00:16:55.930 --> 00:16:58.457
of back pressure.

00:16:58.457 --> 00:17:00.790
So one of the things that
I've been working on recently,

00:17:00.790 --> 00:17:03.450
that hopefully is
going to be rolled out,

00:17:03.450 --> 00:17:05.430
is this module called Levee.

00:17:05.430 --> 00:17:08.750
Now, we're going to get
into code a little bit.

00:17:08.750 --> 00:17:11.890
So if anybody's familiar with
the circuit breaker pattern,

00:17:11.890 --> 00:17:15.599
this is based off of, actually,
an existing module out there,

00:17:15.599 --> 00:17:18.220
and I'm going to look
at his name quickly.

00:17:18.220 --> 00:17:19.150
I guess I can't.

00:17:19.150 --> 00:17:20.930
Not going to bounce out of this.

00:17:20.930 --> 00:17:22.540
There is a Node
circuit breaker module

00:17:22.540 --> 00:17:24.180
that this is heavily
influenced by.

00:17:24.180 --> 00:17:25.640
It's really good.

00:17:25.640 --> 00:17:28.030
I just had another direction
that I wanted to take,

00:17:28.030 --> 00:17:31.220
so I decided to
try my hand at it.

00:17:31.220 --> 00:17:33.850
But what a circuit
breaker pattern

00:17:33.850 --> 00:17:37.240
is, is if I have an
application that's

00:17:37.240 --> 00:17:39.430
talking to services--
actually, before I go on

00:17:39.430 --> 00:17:43.110
with that, circuit breaker in
Node, and actually in Netflix,

00:17:43.110 --> 00:17:45.940
is Histrix, is a JVM
based implementation

00:17:45.940 --> 00:17:48.740
of this same pattern,
which is pretty awesome.

00:17:48.740 --> 00:17:51.940
So this is just my crack
at making it for Node.

00:17:51.940 --> 00:17:53.920
But basically, if I
have a service that

00:17:53.920 --> 00:17:57.150
exceeds its SLA on
the client, I can

00:17:57.150 --> 00:18:01.420
observe-- let's say I have
five requests timeout.

00:18:01.420 --> 00:18:03.840
I can actually trip
the circuit breaker

00:18:03.840 --> 00:18:05.910
and put it into an
open state, meaning

00:18:05.910 --> 00:18:08.220
I will fast fail
subsequent connections

00:18:08.220 --> 00:18:09.600
for a certain amount of time.

00:18:09.600 --> 00:18:11.420
After a certain amount
of time has elapsed,

00:18:11.420 --> 00:18:14.650
I will allow a single request
through as kind of a smoke test

00:18:14.650 --> 00:18:16.710
to see if that
application has recovered.

00:18:16.710 --> 00:18:17.730
If it has, great.

00:18:17.730 --> 00:18:19.970
The breaker closes,
and I resume traffic.

00:18:19.970 --> 00:18:21.960
If it hasn't, I go
ahead and reset,

00:18:21.960 --> 00:18:24.400
and then after a certain
amount of time, I try again.

00:18:24.400 --> 00:18:25.900
So this is a really
interesting way

00:18:25.900 --> 00:18:28.870
of dealing with back pressure,
where instead of just timing

00:18:28.870 --> 00:18:30.370
out and keeping a
ton of connections

00:18:30.370 --> 00:18:32.230
open, or the
application goes down,

00:18:32.230 --> 00:18:35.610
and I just get thousands
of econ reset errors,

00:18:35.610 --> 00:18:39.410
I can actually set up a fallback
mechanism that allows me to put

00:18:39.410 --> 00:18:43.240
in a fake payload or
some sort of message

00:18:43.240 --> 00:18:46.630
that I can use for
my internal clients

00:18:46.630 --> 00:18:50.230
or my code in my application,
but also doesn't repeatedly

00:18:50.230 --> 00:18:55.290
hammer my API's or my services
such that they can't recover.

00:18:55.290 --> 00:18:57.440
It takes the traffic
burden away for them.

00:18:57.440 --> 00:19:00.360
So if they need to be restarted,
or if they're just slowing down

00:19:00.360 --> 00:19:02.370
because they can't
handle that traffic,

00:19:02.370 --> 00:19:05.070
it gives them that
built-in recovery time.

00:19:05.070 --> 00:19:07.960
So a quick just very
fast example of this

00:19:07.960 --> 00:19:11.760
is-- so this is an example using
the REQ module by the Happy.js

00:19:11.760 --> 00:19:13.390
crew, [INAUDIBLE].

00:19:13.390 --> 00:19:15.870
So normally, you'd
just write req dot get,

00:19:15.870 --> 00:19:17.530
and you have this
thing called downtime

00:19:17.530 --> 00:19:19.520
because it's not up very often.

00:19:19.520 --> 00:19:20.990
And you get back after calling.

00:19:20.990 --> 00:19:22.190
You're getting your stats.

00:19:22.190 --> 00:19:23.731
You get an error,
you get a response,

00:19:23.731 --> 00:19:25.360
and then you get the payload.

00:19:25.360 --> 00:19:31.220
So with Levee, I grayed out
the stuff that doesn't change.

00:19:31.220 --> 00:19:34.800
You can wrap the GET call
in this Create Breaker,

00:19:34.800 --> 00:19:39.010
so you have this circuit
breaker instance.

00:19:39.010 --> 00:19:41.660
So now, you can call the
same API, circuit dot run,

00:19:41.660 --> 00:19:43.490
and you give it the call.

00:19:43.490 --> 00:19:45.590
And after a certain
number of failures

00:19:45.590 --> 00:19:47.640
in this particular
configuration,

00:19:47.640 --> 00:19:49.079
you'll still get
an error message,

00:19:49.079 --> 00:19:50.870
but after those failures,
the error message

00:19:50.870 --> 00:19:54.550
will say I'm not calling that
anymore and just fast failing

00:19:54.550 --> 00:19:57.340
because the service is down,
and there's nothing I can do.

00:19:57.340 --> 00:19:59.780
And it doesn't make sense for
me to use resources and keep

00:19:59.780 --> 00:20:02.940
connections open on a
service that may take 5 or 10

00:20:02.940 --> 00:20:06.310
minutes to return
or just be down.

00:20:06.310 --> 00:20:09.260
So that's the first pass,
but then the second pass

00:20:09.260 --> 00:20:11.560
is I can configure
a fallback now.

00:20:11.560 --> 00:20:15.370
So if I had this
Create Breaker before,

00:20:15.370 --> 00:20:18.810
I can then create a fallback
that is always successful.

00:20:18.810 --> 00:20:22.200
So I don't have to then think
about, well, what if it's down,

00:20:22.200 --> 00:20:23.510
I get error messages back.

00:20:23.510 --> 00:20:25.940
I may get a few error
messages at the beginning

00:20:25.940 --> 00:20:28.180
until I hit that threshold,
but after that, I've

00:20:28.180 --> 00:20:30.760
got a backup payload
that will suffice

00:20:30.760 --> 00:20:32.980
for running my application,
or at least notifying

00:20:32.980 --> 00:20:36.120
the rest of my application
that this service is down

00:20:36.120 --> 00:20:37.980
for a certain amount of time.

00:20:37.980 --> 00:20:41.030
So again, this is
something that we're

00:20:41.030 --> 00:20:42.750
going to be tryout at Paypal.

00:20:42.750 --> 00:20:46.110
Netflix has used this
pattern with great success.

00:20:46.110 --> 00:20:48.060
And I think when we're
talking about Node,

00:20:48.060 --> 00:20:49.560
and we're talking
about performance,

00:20:49.560 --> 00:20:51.900
something about back
pressure being a major issue,

00:20:51.900 --> 00:20:55.840
and even if you talk to the
Walmart guys on Black Friday,

00:20:55.840 --> 00:20:57.784
the Node process
isn't the problem.

00:20:57.784 --> 00:20:59.700
It's the fact that it
can send traffic so fast

00:20:59.700 --> 00:21:01.320
to other applications
that may not

00:21:01.320 --> 00:21:03.820
be able to deal with that
amount of traffic that

00:21:03.820 --> 00:21:05.720
could potentially
become the issue.

00:21:05.720 --> 00:21:08.774
So I'm a big fan of the
circuit breaker pattern.

00:21:08.774 --> 00:21:10.690
I'm going to run through
these next two things

00:21:10.690 --> 00:21:12.648
really quickly because
I'm going a little over,

00:21:12.648 --> 00:21:17.380
but Dan very briefly talked
about API's and about REST

00:21:17.380 --> 00:21:21.220
API's and REST specifications.

00:21:21.220 --> 00:21:23.460
So another thing that a guy
on my team is working on,

00:21:23.460 --> 00:21:27.760
Trevor Livingston, is this
thing called Swaggerize Express,

00:21:27.760 --> 00:21:30.692
and it's a spec first
approach to building services,

00:21:30.692 --> 00:21:31.900
to building RESTful services.

00:21:31.900 --> 00:21:36.510
So at Paypal, part of the
process of building a service

00:21:36.510 --> 00:21:39.160
is you define the
API for that service,

00:21:39.160 --> 00:21:41.330
and you iterate on
that design before you

00:21:41.330 --> 00:21:43.890
start writing code, which
is really boring for people

00:21:43.890 --> 00:21:45.650
that like to write code.

00:21:45.650 --> 00:21:47.800
But on the other hand,
what that means is

00:21:47.800 --> 00:21:50.600
you have a document that is
the canonical representation

00:21:50.600 --> 00:21:53.750
of your API, from which
documentation falls out,

00:21:53.750 --> 00:21:55.640
from which your
implementation can fall out,

00:21:55.640 --> 00:21:59.354
and from which client API's or
client modules can fall out.

00:21:59.354 --> 00:22:01.020
So when we thought
about it, we thought,

00:22:01.020 --> 00:22:03.330
all right, well, everybody
is spending this time putting

00:22:03.330 --> 00:22:04.660
effort into building
this document.

00:22:04.660 --> 00:22:06.660
How about we use that
document to not only drive

00:22:06.660 --> 00:22:08.330
the generation of
these apps, but then

00:22:08.330 --> 00:22:10.621
drive the validation of these
endpoints, the validation

00:22:10.621 --> 00:22:12.780
of the inputs and
outputs, and continue

00:22:12.780 --> 00:22:15.100
to use that document
as a canonical resource

00:22:15.100 --> 00:22:18.430
to describe the API for
both clients and servers,

00:22:18.430 --> 00:22:21.852
but then also to help ensure
that these apps are stable when

00:22:21.852 --> 00:22:23.560
they're being built
and then when they're

00:22:23.560 --> 00:22:25.020
running in production?

00:22:25.020 --> 00:22:27.197
So just a quick
snippet of code--

00:22:27.197 --> 00:22:28.530
it doesn't really describe much.

00:22:31.050 --> 00:22:34.420
Basically, you just use
it with Express right now.

00:22:34.420 --> 00:22:36.610
The API JSON is your
Swagger document

00:22:36.610 --> 00:22:39.752
that describes your API,
assumes that you've already

00:22:39.752 --> 00:22:41.210
run the generation
step, and you've

00:22:41.210 --> 00:22:42.810
built out the
scaffolding for the API.

00:22:42.810 --> 00:22:44.430
You have a reference
to your handlers

00:22:44.430 --> 00:22:49.480
and then a reference
to your documentation.

00:22:49.480 --> 00:22:52.639
And then finally,
it's a working name.

00:22:52.639 --> 00:22:54.180
I don't think
[INAUDIBLE] has come up

00:22:54.180 --> 00:22:56.740
with a-- I think we're still
working on the name for it

00:22:56.740 --> 00:22:58.370
right now.

00:22:58.370 --> 00:23:00.694
But another thing
that we've observed

00:23:00.694 --> 00:23:02.360
when running applications
in production,

00:23:02.360 --> 00:23:04.610
specifically web
applications, is

00:23:04.610 --> 00:23:06.780
that it's important
to instrument your app

00:23:06.780 --> 00:23:08.810
to understand what it's
doing in production,

00:23:08.810 --> 00:23:11.730
but more importantly, is
instrumenting your app

00:23:11.730 --> 00:23:13.650
to understand what
business value it's

00:23:13.650 --> 00:23:15.980
adding, which means
that you're potentially

00:23:15.980 --> 00:23:18.669
doing a lot more
logging of specific data

00:23:18.669 --> 00:23:20.710
as it pertains to what's
flowing through the app.

00:23:20.710 --> 00:23:23.520
Not is my app healthy, how
much memory is it using;

00:23:23.520 --> 00:23:26.430
but is my app actually
fulfilling the metrics

00:23:26.430 --> 00:23:28.640
that the product
team has established

00:23:28.640 --> 00:23:30.114
for what it should be doing?

00:23:30.114 --> 00:23:32.280
So when you're talking about
doing a lot of logging,

00:23:32.280 --> 00:23:34.530
we have a lot of services
that are socket based,

00:23:34.530 --> 00:23:37.452
that are REST based.

00:23:37.452 --> 00:23:38.660
I guess none of that matters.

00:23:38.660 --> 00:23:40.610
What matters is
what we've observed

00:23:40.610 --> 00:23:43.160
is people will either write
just giant JSON objects

00:23:43.160 --> 00:23:46.850
or they'll write a lot of code
to pluck individual values out

00:23:46.850 --> 00:23:48.900
of these gigantic
payloads in order

00:23:48.900 --> 00:23:50.530
to do this type of reporting.

00:23:50.530 --> 00:23:53.554
And some teams just
hand rule this property

00:23:53.554 --> 00:23:54.970
on this property
on this property,

00:23:54.970 --> 00:23:57.180
and they write this really
really brittle thing

00:23:57.180 --> 00:23:59.820
that traverses this
giant JSON structure.

00:23:59.820 --> 00:24:01.815
Some teams use an
existing implementation

00:24:01.815 --> 00:24:05.610
of JSON path, which
unfortunately is

00:24:05.610 --> 00:24:08.540
the source of some
CPU contention,

00:24:08.540 --> 00:24:13.030
very heavily regular expression
based implementation,

00:24:13.030 --> 00:24:16.310
and also does this
parsing of the selector

00:24:16.310 --> 00:24:19.430
and the evaluation of the
data in the same step.

00:24:19.430 --> 00:24:24.700
So what [INAUDIBLE] came up with
was something that breaks that

00:24:24.700 --> 00:24:27.050
into two steps, and
you use the selector

00:24:27.050 --> 00:24:28.560
to compile an evaluator.

00:24:28.560 --> 00:24:30.310
And then at runtime,
you run the evaluator

00:24:30.310 --> 00:24:33.330
your object, meaning that we can
get these giant payloads back,

00:24:33.330 --> 00:24:35.390
JSON payloads back,
from our services.

00:24:35.390 --> 00:24:37.390
We can write a selector
that plucks off

00:24:37.390 --> 00:24:40.010
individual values
from that payload

00:24:40.010 --> 00:24:43.570
and then just logs what it needs
with as little CPU overhead

00:24:43.570 --> 00:24:46.870
as possible and, more
importantly, less brittle

00:24:46.870 --> 00:24:50.330
logging code spread all
over our application.

00:24:50.330 --> 00:24:53.810
So that's just a quick example
of transposer dot create.

00:24:53.810 --> 00:24:55.594
So you create your
implementation

00:24:55.594 --> 00:24:57.760
based on the selector, and
then at runtime, you just

00:24:57.760 --> 00:25:00.840
run it over the
data but you want.

00:25:00.840 --> 00:25:04.310
And just a couple
of stats for what

00:25:04.310 --> 00:25:07.000
she's been able to do with it,
the existing implementation

00:25:07.000 --> 00:25:10.630
the team is using for--
so this is recursively

00:25:10.630 --> 00:25:13.620
select any property
with the name ID

00:25:13.620 --> 00:25:15.301
is what this top one is.

00:25:15.301 --> 00:25:16.550
She's been able to improve it.

00:25:16.550 --> 00:25:17.700
This is her module.

00:25:17.700 --> 00:25:20.330
This is the existing module.

00:25:20.330 --> 00:25:22.350
And we're hoping
that, again bringing

00:25:22.350 --> 00:25:26.220
that back to the no.js scale,
to be able to grab data

00:25:26.220 --> 00:25:29.520
at runtime, do logging
without any or minimal effect

00:25:29.520 --> 00:25:32.220
to the customer experience.

00:25:32.220 --> 00:25:35.820
Hopefully, this will
help us get that far.

00:25:35.820 --> 00:25:39.580
But anyway, so
that's all I have.

00:25:39.580 --> 00:25:41.950
Kind of rambling
quick, but hopefully,

00:25:41.950 --> 00:25:44.840
it gave everybody
some insight into how

00:25:44.840 --> 00:25:47.660
we've been able to
scale Node at Paypal.

00:25:47.660 --> 00:25:51.146
AUDIENCE: [APPLAUSE]

00:25:58.120 --> 00:26:00.381
MALE SPEAKER: All
right, thank you Eric.

00:26:00.381 --> 00:26:00.880
Cool.

00:26:00.880 --> 00:26:04.860
So Guillermo's just
getting mic'd up here.

00:26:04.860 --> 00:26:06.610
Once again, so another
about half an hour,

00:26:06.610 --> 00:26:08.530
take a quick break after that.

00:26:08.530 --> 00:26:11.910
And then we'll do the Q&amp;A
with all the speakers.

00:26:11.910 --> 00:26:15.850
Are there any quick
questions for Eric

00:26:15.850 --> 00:26:18.200
while we're setting up?

00:26:18.200 --> 00:26:19.840
Eric, come on back.

00:26:19.840 --> 00:26:20.930
Any quick questions here?

00:26:20.930 --> 00:26:21.430
Yep?

00:26:21.430 --> 00:26:22.207
Go for it.

00:26:22.207 --> 00:26:23.698
AUDIENCE: Yeah, you [INAUDIBLE]?

00:26:40.370 --> 00:26:42.480
ERIK TOTH: So the
question was I had

00:26:42.480 --> 00:26:46.370
given this kind of high
level statistics of it's

00:26:46.370 --> 00:26:51.730
been taking less machines to
drive the Node implementation

00:26:51.730 --> 00:26:55.580
of a particular
application, but it had JVM.

00:26:55.580 --> 00:26:59.190
The specific thing that
I attribute that to

00:26:59.190 --> 00:27:03.760
is that the application did
not a ton of business logic,

00:27:03.760 --> 00:27:09.020
but really the logic was
around composing pages.

00:27:09.020 --> 00:27:12.380
So it was very amenable
to large caches

00:27:12.380 --> 00:27:15.750
and just literally writing
buffers out to the response.

00:27:15.750 --> 00:27:17.390
It made some service
calls, not as

00:27:17.390 --> 00:27:19.181
many as our other
heavyweight applications.

00:27:22.242 --> 00:27:23.950
It's a small plug to
Kraken, but the fact

00:27:23.950 --> 00:27:26.725
that it's based on a very
lightweight thing instead

00:27:26.725 --> 00:27:32.270
of-- to say that
it's faster than JVM

00:27:32.270 --> 00:27:33.500
makes a lot of assumptions.

00:27:33.500 --> 00:27:37.480
We have frameworks built on top
of frameworks in any platform.

00:27:37.480 --> 00:27:38.900
For our particular
implementation,

00:27:38.900 --> 00:27:42.110
the fact that Kraken
was lightweight for what

00:27:42.110 --> 00:27:47.110
they needed based on Express,
that it didn't provide

00:27:47.110 --> 00:27:50.910
any features they
didn't need, it just

00:27:50.910 --> 00:27:52.720
inherently had a
lot of less overhead

00:27:52.720 --> 00:27:54.350
to do that specific task.

00:27:56.805 --> 00:27:58.930
It could mostly be attributed
to our implementation

00:27:58.930 --> 00:28:01.300
on top of the JVM, but it
was just an observation

00:28:01.300 --> 00:28:05.820
that, for our business, half
the servers is half the servers.

00:28:05.820 --> 00:28:07.380
It is what it is.

00:28:07.380 --> 00:28:09.181
But it was a little
hand-wavy, I agree,

00:28:09.181 --> 00:28:11.055
and it really depends
on your implementation.

00:28:11.055 --> 00:28:14.620
It depends on the stack that you
build within your organization.

00:28:14.620 --> 00:28:16.720
But as a direct
report for us, it

00:28:16.720 --> 00:28:19.360
was a really big win
at the end of the day.

00:28:19.360 --> 00:28:21.450
So cool.

00:28:21.450 --> 00:28:23.000
All right.

