WEBVTT
Kind: captions
Language: en

00:00:07.890 --> 00:00:08.890
ROMAIN GUY: Good afternoon,
everyone.

00:00:08.890 --> 00:00:10.750
And welcome to the session
on writing

00:00:10.750 --> 00:00:12.050
custom views for Android.

00:00:12.050 --> 00:00:14.940
And the title is a bit
misleading, because we won't

00:00:14.940 --> 00:00:17.930
be showing code, or we won't
be writing code.

00:00:17.930 --> 00:00:18.960
My name is Romain Guy.

00:00:18.960 --> 00:00:20.000
And this is Adam Powell.

00:00:20.000 --> 00:00:21.150
And we both work on the Android

00:00:21.150 --> 00:00:23.080
Framework Team at Google.

00:00:23.080 --> 00:00:24.770
Adam works a lot on
the UI Toolkit.

00:00:24.770 --> 00:00:27.090
And you have seen his work in
the action bar, the view

00:00:27.090 --> 00:00:28.730
pager, the support library.

00:00:28.730 --> 00:00:30.590
He's the mind behind
all of that.

00:00:30.590 --> 00:00:34.300
I focus mostly on graphics,
performance, and animations.

00:00:34.300 --> 00:00:36.360
But I've done a little bit of
UI Toolkit in the past.

00:00:36.360 --> 00:00:38.220
So I think I know what
I'm talking about.

00:00:41.060 --> 00:00:43.950
ADAM POWELL: So why would you
actually want to write your

00:00:43.950 --> 00:00:45.200
own custom views?

00:00:45.200 --> 00:00:46.630
Isn't the framework good
enough for that?

00:00:46.630 --> 00:00:47.670
Are we missing something?

00:00:47.670 --> 00:00:50.780
Well, usually the framework
has what you need.

00:00:50.780 --> 00:00:54.415
But between the framework and
the support library, you kind

00:00:54.415 --> 00:00:55.990
of have what you need
to get everything

00:00:55.990 --> 00:00:58.250
in the design guide.

00:00:58.250 --> 00:01:01.460
And reusing those framework
components ensures the user is

00:01:01.460 --> 00:01:03.340
familiar with the
patterns there.

00:01:03.340 --> 00:01:05.620
And hopefully the components
are stable.

00:01:05.620 --> 00:01:09.660
But sometimes you just really
need to stand out.

00:01:09.660 --> 00:01:12.730
So just like Larry was saying
this morning, your app is

00:01:12.730 --> 00:01:15.390
doing something unique.

00:01:15.390 --> 00:01:17.670
Otherwise why are
you writing it?

00:01:17.670 --> 00:01:20.900
You might need graphs, other
data visualizations, other

00:01:20.900 --> 00:01:22.980
things that just are
really unique to

00:01:22.980 --> 00:01:25.450
what your app is doing.

00:01:25.450 --> 00:01:26.990
Maybe you need some
sort of custom

00:01:26.990 --> 00:01:28.720
interaction with your content.

00:01:28.720 --> 00:01:30.580
I mean, not everything
fits within a list

00:01:30.580 --> 00:01:32.390
view or a scroll view.

00:01:32.390 --> 00:01:33.810
And touch is a great
way to feel

00:01:33.810 --> 00:01:35.390
connected to your content.

00:01:35.390 --> 00:01:37.615
And writing a view gives you
full control over that.

00:01:41.160 --> 00:01:42.500
So who here uses

00:01:42.500 --> 00:01:44.850
RelativeLayout, for an example?

00:01:44.850 --> 00:01:45.670
A lot of hands.

00:01:45.670 --> 00:01:46.730
That's great.

00:01:46.730 --> 00:01:48.380
Probably because this
guy told you to.

00:01:48.380 --> 00:01:50.500
ROMAIN GUY: Now a while ago,
I wrote a blog that was

00:01:50.500 --> 00:01:51.450
misinterpreted.

00:01:51.450 --> 00:01:53.720
And now everybody thinks they
should be using RelativeLayout

00:01:53.720 --> 00:01:54.510
all the time.

00:01:54.510 --> 00:01:56.050
Please don't.

00:01:56.050 --> 00:01:58.160
ADAM POWELL: It's a
great view, right?

00:01:58.160 --> 00:01:59.590
ROMAIN GUY: It works.

00:01:59.590 --> 00:02:02.220
We can get to that later,
if we have time.

00:02:02.220 --> 00:02:03.000
ADAM POWELL: Sure.

00:02:03.000 --> 00:02:06.640
So RelativeLayout will measure
child views more than once in

00:02:06.640 --> 00:02:08.910
order to solve some of the
constraints that you give it.

00:02:08.910 --> 00:02:12.030
So being generic has a cost.

00:02:12.030 --> 00:02:14.900
A little domain knowledge
can go a long way for

00:02:14.900 --> 00:02:16.150
optimization.

00:02:19.010 --> 00:02:22.260
Really, there should always be
one part of your app that can

00:02:22.260 --> 00:02:24.670
catch someone's eye from across
a room, something

00:02:24.670 --> 00:02:26.050
that's instantly identifiable.

00:02:26.050 --> 00:02:28.770
If one of your users is using
your app in a coffee shop,

00:02:28.770 --> 00:02:31.080
someone clear across the
room should be able to

00:02:31.080 --> 00:02:32.470
tell what it is.

00:02:32.470 --> 00:02:34.900
So you want to make your
app fun and satisfying.

00:02:34.900 --> 00:02:36.620
And the design guidelines
are great.

00:02:36.620 --> 00:02:40.060
But apps that do unique things
will always beg for some sort

00:02:40.060 --> 00:02:41.340
of innovative ways to do them.

00:02:44.250 --> 00:02:47.520
So members of the Android
community have already given

00:02:47.520 --> 00:02:50.570
several talks lately that have
been really great, and given a

00:02:50.570 --> 00:02:53.040
lot of information on writing
custom views.

00:02:53.040 --> 00:02:55.100
And not only that, there
are a lot of great

00:02:55.100 --> 00:02:56.370
code examples available.

00:02:56.370 --> 00:02:58.870
And Android Open Source project
itself is a great

00:02:58.870 --> 00:03:00.482
resource for you to look at.

00:03:00.482 --> 00:03:04.130
But realistically, we want to
keep this talk a little bit

00:03:04.130 --> 00:03:08.150
more abstract, as you
were saying earlier.

00:03:08.150 --> 00:03:12.440
So in writing our own custom
views, and helping others

00:03:12.440 --> 00:03:15.180
write them as well, we found
a lot of common patterns

00:03:15.180 --> 00:03:16.730
emerged from this.

00:03:16.730 --> 00:03:18.020
And we found ourselves
giving the same

00:03:18.020 --> 00:03:20.660
recommendations over and over.

00:03:20.660 --> 00:03:23.090
And we're going to spend most of
our time here today talking

00:03:23.090 --> 00:03:26.580
about those experiences and what
worked well, what didn't,

00:03:26.580 --> 00:03:28.760
and what can really help you
from getting caught in a

00:03:28.760 --> 00:03:29.610
[? rapple ?]

00:03:29.610 --> 00:03:32.320
of the internal design
of your components.

00:03:32.320 --> 00:03:34.790
So to do that, we still need
some context about how the

00:03:34.790 --> 00:03:35.880
system works.

00:03:35.880 --> 00:03:39.870
So we'll go ahead
and start with--

00:03:39.870 --> 00:03:42.680
ROMAIN GUY: But just before on
the previous slide, don't

00:03:42.680 --> 00:03:44.640
believe the "Tips and
Trick" bullet.

00:03:44.640 --> 00:03:45.850
We removed that section.

00:03:45.850 --> 00:03:46.870
So there won't be tips
and there won't be

00:03:46.870 --> 00:03:48.220
tricks for you today.

00:03:48.220 --> 00:03:49.370
ADAM POWELL: Well, we might
have some tips and tricks

00:03:49.370 --> 00:03:50.170
along the way.

00:03:50.170 --> 00:03:51.730
ROMAIN GUY: Yeah,
along the way.

00:03:51.730 --> 00:03:53.070
So we'll start with
Live of a View.

00:03:53.070 --> 00:03:54.470
So how many of you have
ever seen the

00:03:54.470 --> 00:03:57.290
Activity Lifecycle Diagram?

00:03:57.290 --> 00:03:57.930
All right.

00:03:57.930 --> 00:04:01.352
How many of you understand the
Activity Lifecycle Diagram?

00:04:01.352 --> 00:04:04.050
You're a bunch of liars.

00:04:04.050 --> 00:04:05.740
I've been on the team
for six years.

00:04:05.740 --> 00:04:07.920
I still don't get it.

00:04:07.920 --> 00:04:08.600
I exaggerate.

00:04:08.600 --> 00:04:10.530
But it's complicated.

00:04:10.530 --> 00:04:14.850
But the Lifecycle Diagram of
Activities makes guarantees

00:04:14.850 --> 00:04:17.959
about the methods that will
be invoked on your

00:04:17.959 --> 00:04:19.010
activities and when.

00:04:19.010 --> 00:04:20.570
And we have similar
things for views.

00:04:20.570 --> 00:04:22.360
It's a lot simpler,
as you will see.

00:04:22.360 --> 00:04:25.750
But we have guarantees
that we can promise.

00:04:25.750 --> 00:04:28.070
So the life of a view is
made of three things.

00:04:28.070 --> 00:04:29.970
We have the attachment
and detachment.

00:04:29.970 --> 00:04:32.250
And this is actually a very
important part of

00:04:32.250 --> 00:04:33.170
the life of a view.

00:04:33.170 --> 00:04:36.170
And I've never or rarely seen
articles online talk about it,

00:04:36.170 --> 00:04:38.170
or examples focusing on that.

00:04:38.170 --> 00:04:41.935
Then with traversals that you
may know as drawing and layout

00:04:41.935 --> 00:04:43.260
and measurement.

00:04:43.260 --> 00:04:46.320
And finally, we have the state
saving and restoring.

00:04:46.320 --> 00:04:49.150
So let's get started with the
attachment and detachment.

00:04:49.150 --> 00:04:50.510
Actually, another quick poll.

00:04:50.510 --> 00:04:54.030
How many of you have used that
method onAttachedToWindow?

00:04:54.030 --> 00:04:55.570
All right, that's pretty good.

00:04:55.570 --> 00:04:58.880
So whenever you attach a view
to a parent-- so you call a

00:04:58.880 --> 00:05:01.990
ViewGroup, that add view-- if
that parent already belongs to

00:05:01.990 --> 00:05:05.630
window, in UI Toolkit
[? Balance ?] we said that the

00:05:05.630 --> 00:05:06.820
view gets attached
to the window.

00:05:06.820 --> 00:05:08.950
So you get this call back,
onAttachedToWindow.

00:05:08.950 --> 00:05:12.450
And this is where the view
knows it can be active.

00:05:12.450 --> 00:05:15.510
So this is where you should
start allocating any resources

00:05:15.510 --> 00:05:15.980
you might need.

00:05:15.980 --> 00:05:19.460
This is where you can register
listeners on other pieces of

00:05:19.460 --> 00:05:21.860
the application on the system.

00:05:21.860 --> 00:05:24.555
And for instance, in list view,
when you attach a list

00:05:24.555 --> 00:05:28.070
view to a window, this is when
we attach a listener to your

00:05:28.070 --> 00:05:30.410
adaptor after so that list
view knows when the data

00:05:30.410 --> 00:05:32.810
changes in the adaptor.

00:05:32.810 --> 00:05:34.460
And again, you should
take a look at the

00:05:34.460 --> 00:05:35.190
source code of Android.

00:05:35.190 --> 00:05:37.850
So if you look at the source
code of view.java, or

00:05:37.850 --> 00:05:41.180
AbsListView.java, you will see
the kind of things that we do

00:05:41.180 --> 00:05:42.610
in onAttachedToWindow.

00:05:42.610 --> 00:05:45.200
But even more important is the
second callback called

00:05:45.200 --> 00:05:47.480
onDetachedFromWindow.

00:05:47.480 --> 00:05:50.060
So we call that callback
whenever a view is removed

00:05:50.060 --> 00:05:53.400
from its parent and if that
parent is attached to window.

00:05:53.400 --> 00:05:54.830
This can happen for a
number of reasons.

00:05:54.830 --> 00:05:57.170
Maybe the view is getting
recycled in the list view when

00:05:57.170 --> 00:05:57.960
you're scrolling.

00:05:57.960 --> 00:06:01.270
Maybe you called remove view
on the parent of that view.

00:06:01.270 --> 00:06:03.920
Or maybe we are tearing
down the activity.

00:06:03.920 --> 00:06:06.710
When we tear down the activity
when there's a finished event

00:06:06.710 --> 00:06:08.970
on the activity, we're going
to remove every view.

00:06:08.970 --> 00:06:11.440
And we're going to detach
them from the window.

00:06:11.440 --> 00:06:13.200
This callback is very important,
because this is

00:06:13.200 --> 00:06:15.200
where you can stop doing
any kind of work

00:06:15.200 --> 00:06:16.240
that was already scheduled.

00:06:16.240 --> 00:06:18.780
So if you had scheduled an
animation, like a scroll or a

00:06:18.780 --> 00:06:23.450
fling, if you had a background
thread running, you can stop

00:06:23.450 --> 00:06:25.410
those things right here.

00:06:25.410 --> 00:06:27.690
Also, if you had allocated
resources like a drawing cache

00:06:27.690 --> 00:06:30.170
of some sort, or any other
resource that your custom view

00:06:30.170 --> 00:06:32.750
might need, this is a
very good place to

00:06:32.750 --> 00:06:34.030
clean up those resources.

00:06:34.030 --> 00:06:36.480
A good example is for the
hardware renderer.

00:06:36.480 --> 00:06:39.510
So in Android 3.0, we added
Hardware Acceleration.

00:06:39.510 --> 00:06:42.660
And we created a lot of native
objects that attached views

00:06:42.660 --> 00:06:45.010
during the lifecycle
of the view.

00:06:45.010 --> 00:06:46.890
And when the view gets detached
from the window, this

00:06:46.890 --> 00:06:49.380
is where we can destroy those
native objects, because we

00:06:49.380 --> 00:06:51.700
know that the view will not be
shown on screen anymore.

00:06:51.700 --> 00:06:53.060
So we make sure to promise
when you get

00:06:53.060 --> 00:06:56.640
onDetachFromWindow, you can
destroy all these resources.

00:06:56.640 --> 00:06:59.130
Of course, this is a promise
that we make.

00:06:59.130 --> 00:07:01.220
But sometimes when you implement
your own custom

00:07:01.220 --> 00:07:05.180
views, and you try to be, let's
say, smart about your

00:07:05.180 --> 00:07:07.950
lifecycle of the view, you might
run into real issues

00:07:07.950 --> 00:07:10.310
where the view will be detached
but it's not.

00:07:10.310 --> 00:07:13.540
Or the view will think it
is attached, it is not

00:07:13.540 --> 00:07:14.670
attached and it is.

00:07:14.670 --> 00:07:16.790
We've run into a number of
bugs like that in our own

00:07:16.790 --> 00:07:17.470
applications.

00:07:17.470 --> 00:07:18.210
ADAM POWELL: A couple.

00:07:18.210 --> 00:07:20.940
ROMAIN GUY: So be very careful
when you use AdView,

00:07:20.940 --> 00:07:21.590
RemoveView.

00:07:21.590 --> 00:07:24.680
And View Group has a number
of methods where you can

00:07:24.680 --> 00:07:27.760
temporarily detach a view
from the window.

00:07:27.760 --> 00:07:30.525
So if you're using those
methods, be very careful.

00:07:30.525 --> 00:07:33.280
And that's about it for the
lifecycle of a view.

00:07:33.280 --> 00:07:34.270
So what is missing?

00:07:34.270 --> 00:07:36.190
What is missing is all the
events that you get on an

00:07:36.190 --> 00:07:39.830
activity, so things like
onPause, onResume, onStop.

00:07:39.830 --> 00:07:42.180
And we have a lot of requests
from people who are asking to

00:07:42.180 --> 00:07:46.140
get those lifecycle events
on View itself.

00:07:46.140 --> 00:07:49.340
The reason why we don't have
those lifecycle events on view

00:07:49.340 --> 00:07:51.860
is about abstraction
and layering.

00:07:51.860 --> 00:07:55.480
The way the Android framework is
built, we try to layer our

00:07:55.480 --> 00:07:56.890
packages on top of each other.

00:07:56.890 --> 00:07:59.500
So what you see on the side
right here is actually the

00:07:59.500 --> 00:08:01.310
layering that we have
internally.

00:08:01.310 --> 00:08:03.940
So the android.app package that
contains activity and

00:08:03.940 --> 00:08:07.220
context sits on top of pretty
much everything else.

00:08:07.220 --> 00:08:09.555
At the bottom, we have
android.widget, where you have

00:08:09.555 --> 00:08:11.190
your text view, your list
view, your image

00:08:11.190 --> 00:08:12.470
view, things like that.

00:08:12.470 --> 00:08:14.890
And that sits on top
of android.view.

00:08:14.890 --> 00:08:18.790
So you could actually build a
version, I would say the fork

00:08:18.790 --> 00:08:21.470
of Android, where you get
rid of android.widget.

00:08:21.470 --> 00:08:22.700
And you just keep
android.view.

00:08:22.700 --> 00:08:26.060
And the system would
just work.

00:08:26.060 --> 00:08:30.610
So instead of adding those
activity lifecycle events to

00:08:30.610 --> 00:08:32.929
views, what you should do is
create your own sets of

00:08:32.929 --> 00:08:35.100
listeners or callbacks
in your custom views.

00:08:35.100 --> 00:08:38.049
So here, there's a very simple
example of custom listeners

00:08:38.049 --> 00:08:39.880
that you could specify
on your view.

00:08:39.880 --> 00:08:42.390
And it will be the
responsibility of the activity

00:08:42.390 --> 00:08:45.160
to invoke those callbacks
on the view.

00:08:45.160 --> 00:08:47.800
Another way of doing it is just
to add methods straight

00:08:47.800 --> 00:08:48.750
to your class.

00:08:48.750 --> 00:08:51.740
If you have used GL SurfaceView
that's used to do

00:08:51.740 --> 00:08:54.430
OpenGL rendering, this
is what happens.

00:08:54.430 --> 00:08:57.290
This view has its
own on pause, on

00:08:57.290 --> 00:08:58.740
stop, on resume methods.

00:08:58.740 --> 00:09:01.310
And it is your responsibility
when you add that view to an

00:09:01.310 --> 00:09:05.780
activity to call those methods
at the right time.

00:09:05.780 --> 00:09:07.495
So we don't need to add support

00:09:07.495 --> 00:09:08.380
for that in the framework.

00:09:08.380 --> 00:09:09.560
You can do it yourself.

00:09:09.560 --> 00:09:11.020
We know it's a bit more work.

00:09:11.020 --> 00:09:14.570
But you can easily write utility
libraries or classes

00:09:14.570 --> 00:09:16.620
in your code to help
you do that.

00:09:16.620 --> 00:09:18.920
I briefly mentioned
traversals before.

00:09:18.920 --> 00:09:21.850
And traversals are scheduled
in three different ways.

00:09:21.850 --> 00:09:23.480
They can be scheduled
by animations.

00:09:23.480 --> 00:09:25.550
And we're talking about the new
animation system that was

00:09:25.550 --> 00:09:27.010
introduced in Honeycomb.

00:09:27.010 --> 00:09:30.550
The old animation system is
actually part of drawing.

00:09:30.550 --> 00:09:34.290
Traversals can also be triggered
by requestLayout and

00:09:34.290 --> 00:09:35.300
Invalidate.

00:09:35.300 --> 00:09:37.660
And this is what the traversal
looks like.

00:09:37.660 --> 00:09:39.860
And if you want to be really
scared, go look at

00:09:39.860 --> 00:09:42.320
ViewRootImpl.java in the
source code of Android.

00:09:42.320 --> 00:09:44.580
And look there's a method called
perform traversals.

00:09:44.580 --> 00:09:46.350
And try to understand
what it does.

00:09:46.350 --> 00:09:48.630
Once again, I've been writing
code in that method for years.

00:09:48.630 --> 00:09:50.670
And I still don't
quite get it.

00:09:50.670 --> 00:09:51.880
Don't laugh.

00:09:51.880 --> 00:09:54.630
It's true.

00:09:54.630 --> 00:09:56.920
So we first start
with animation.

00:09:56.920 --> 00:09:58.980
So with a new animation
system, there will be

00:09:58.980 --> 00:10:01.330
callbacks related to animations
that will be

00:10:01.330 --> 00:10:03.760
triggered at the beginning
of a traversal.

00:10:03.760 --> 00:10:06.480
Then we're going to do the
measurement pass, then the

00:10:06.480 --> 00:10:09.810
layout pass, and finally
the drawing pass.

00:10:09.810 --> 00:10:13.100
The order that you see those
events on screen is

00:10:13.100 --> 00:10:14.350
guaranteed.

00:10:17.760 --> 00:10:20.070
If you see a layout, there will
always be a draw after.

00:10:20.070 --> 00:10:22.360
You can't see a draw and
then the layout.

00:10:22.360 --> 00:10:24.765
What can happen, though, is you
could have a measure in

00:10:24.765 --> 00:10:26.170
the layout and not a draw.

00:10:26.170 --> 00:10:28.660
Or you could have a draw but not
a measure in the layout.

00:10:28.660 --> 00:10:31.320
The only tricky part here is
that the measure and the

00:10:31.320 --> 00:10:32.740
layout always happen together.

00:10:32.740 --> 00:10:35.020
You cannot have one without the
other, unless you're doing

00:10:35.020 --> 00:10:38.440
something really bad in
your application.

00:10:38.440 --> 00:10:38.750
ADAM POWELL: All right.

00:10:38.750 --> 00:10:40.010
So let's dive a little
bit deeper on

00:10:40.010 --> 00:10:41.460
some of these topics.

00:10:41.460 --> 00:10:43.040
So measurement and layout
is where we'll

00:10:43.040 --> 00:10:44.330
go ahead and begin.

00:10:44.330 --> 00:10:46.840
All views know how to measure
themselves and

00:10:46.840 --> 00:10:48.540
lay out their content.

00:10:48.540 --> 00:10:51.930
And leaf node views that don't
actually have any children

00:10:51.930 --> 00:10:54.640
should measure their internally
displayed content

00:10:54.640 --> 00:10:56.610
and go ahead and lay
that content out

00:10:56.610 --> 00:10:59.420
during these two steps.

00:10:59.420 --> 00:11:02.620
So ViewGroups on the other hand
organize, measure, and

00:11:02.620 --> 00:11:04.200
lay out a series
of child views.

00:11:08.990 --> 00:11:12.750
So RequestLayout is the first
step in this whole process.

00:11:12.750 --> 00:11:16.210
At some point, some
piece of state

00:11:16.210 --> 00:11:17.870
changed within your view.

00:11:17.870 --> 00:11:21.620
RequestLayout is the signal to
the view system that it needs

00:11:21.620 --> 00:11:25.830
to recalculate the measurement
and layout of the views.

00:11:25.830 --> 00:11:28.870
So it means something
very specific in

00:11:28.870 --> 00:11:29.900
terms of what changed.

00:11:29.900 --> 00:11:32.880
I means that something changed
that can alter the size, and

00:11:32.880 --> 00:11:35.760
by extension the layout within
all the ancestors moving up

00:11:35.760 --> 00:11:37.010
the hierarchy.

00:11:39.120 --> 00:11:41.150
So RequestLayout is recursive.

00:11:41.150 --> 00:11:44.240
A change in the size of a leaf
node way down at the bottom of

00:11:44.240 --> 00:11:47.340
the tree can influence the size
going all the way up the

00:11:47.340 --> 00:11:49.710
tree as well.

00:11:49.710 --> 00:11:51.210
ROMAIN GUY: And this is actually
one of the reasons

00:11:51.210 --> 00:11:54.025
why we often mention that you
shouldn't have too many views

00:11:54.025 --> 00:11:56.650
in your application,
in your UI.

00:11:56.650 --> 00:11:59.340
And more importantly, we said
that you shouldn't have too

00:11:59.340 --> 00:12:00.400
deep of a tree.

00:12:00.400 --> 00:12:02.190
And this is one of the reasons,
because every time we

00:12:02.190 --> 00:12:04.860
call RequestLayout, we have to
walk all the way back up.

00:12:04.860 --> 00:12:06.650
So when you call RequestLayout
once, it

00:12:06.650 --> 00:12:07.410
doesn't really matter.

00:12:07.410 --> 00:12:09.390
But if you [? update ?] a lot of
views and every one of them

00:12:09.390 --> 00:12:13.020
tries to go back up the tree,
it can take up a significant

00:12:13.020 --> 00:12:13.590
amount of time.

00:12:13.590 --> 00:12:16.510
We have optimizations in the
UI Toolkit to avoid doing

00:12:16.510 --> 00:12:17.820
extra work.

00:12:17.820 --> 00:12:19.520
But every bit can help.

00:12:19.520 --> 00:12:20.820
ADAM POWELL: That's right.

00:12:20.820 --> 00:12:25.940
So because of this process,
anything can change.

00:12:25.940 --> 00:12:29.540
It can dramatically change the
way that the view's parent,

00:12:29.540 --> 00:12:31.880
grandparent, or
great-grandparent measures and

00:12:31.880 --> 00:12:35.700
lays out the other
views around it.

00:12:35.700 --> 00:12:38.890
So on measure, it's
where your view

00:12:38.890 --> 00:12:41.160
implements the measure step.

00:12:41.160 --> 00:12:44.340
It's called by the actual
measure method within view to

00:12:44.340 --> 00:12:46.920
determine the view's size.

00:12:46.920 --> 00:12:49.540
In a ViewGroup, again, this
is a recursive process.

00:12:49.540 --> 00:12:52.830
So ViewGroups will go ahead and
call measure on each one

00:12:52.830 --> 00:12:54.120
of their child views.

00:12:54.120 --> 00:12:55.570
And then they can use
the results to help

00:12:55.570 --> 00:12:57.000
decide their own size.

00:12:59.940 --> 00:13:03.860
So the parameters onMeasure
are these packed

00:13:03.860 --> 00:13:04.860
measure spec values.

00:13:04.860 --> 00:13:07.070
They're packed into
a 32-bit end.

00:13:07.070 --> 00:13:11.930
So the make MeasureSpec method
goes ahead and packs a size

00:13:11.930 --> 00:13:14.930
and a mode code into
these values.

00:13:14.930 --> 00:13:18.270
And then the getSize and getMode
methods listed here

00:13:18.270 --> 00:13:19.520
unpack them for you.

00:13:19.520 --> 00:13:21.590
And we'll go ahead and talk a
little bit more about measure

00:13:21.590 --> 00:13:22.840
spec modes in a bit.

00:13:25.450 --> 00:13:27.620
When a ViewGroup is measured,
it has a responsibility to

00:13:27.620 --> 00:13:29.810
make sure that it's child
views have been properly

00:13:29.810 --> 00:13:31.160
measured as well.

00:13:31.160 --> 00:13:33.580
A layout request may have
originated from a leaf node

00:13:33.580 --> 00:13:35.000
deep down the hierarchy.

00:13:35.000 --> 00:13:37.210
And depending on how a ViewGroup
decides to arrange

00:13:37.210 --> 00:13:41.290
its children, one small change
in size down the leaf node can

00:13:41.290 --> 00:13:44.230
drastically alter the
layout above it.

00:13:44.230 --> 00:13:47.550
If this sounds expensive, it's
because it really can be.

00:13:47.550 --> 00:13:49.870
Multi-pass measurement in
a ViewGroup is sometimes

00:13:49.870 --> 00:13:51.690
necessary when you're trying
to resolve different

00:13:51.690 --> 00:13:53.300
constraints for a layout.

00:13:53.300 --> 00:13:56.700
But because of that, it can
really add up fast.

00:13:56.700 --> 00:13:58.640
And this is usually a good
time to dust off your

00:13:58.640 --> 00:14:02.040
algorithm analysis techniques.

00:14:02.040 --> 00:14:05.040
So finally, onMeasure doesn't
actually return a value.

00:14:05.040 --> 00:14:07.650
Instead you call
setMeasuredDimension to set

00:14:07.650 --> 00:14:09.380
width and height explicitly.

00:14:09.380 --> 00:14:10.570
This is enforced.

00:14:10.570 --> 00:14:12.700
If you forget to do this, then
the framework is going to

00:14:12.700 --> 00:14:15.500
throw an exception and
crash your app.

00:14:15.500 --> 00:14:19.840
The sizes that you set here
are reported by the

00:14:19.840 --> 00:14:22.740
getMeasuredWidth and
getMeasuredHeight methods, not

00:14:22.740 --> 00:14:25.000
the normal getWidth and
getHeight methods you may be

00:14:25.000 --> 00:14:26.640
familiar with.

00:14:26.640 --> 00:14:28.960
This is because the process
is two step.

00:14:28.960 --> 00:14:31.660
GetWidth and getHeight don't
actually have their values

00:14:31.660 --> 00:14:34.910
initialized until layout
is complete.

00:14:34.910 --> 00:14:38.240
So you can use the measured size
of these child views to

00:14:38.240 --> 00:14:41.460
decide your own size or perform
any other bookkeeping

00:14:41.460 --> 00:14:42.870
after the child's
measure returns.

00:14:46.150 --> 00:14:47.400
So back to modes.

00:14:49.780 --> 00:14:51.100
There are three different
modes.

00:14:51.100 --> 00:14:52.650
The first one is EXACTLY.

00:14:52.650 --> 00:14:55.190
And it means exactly
what it says.

00:14:55.190 --> 00:14:58.000
This mode can be used if there's
a fixed size specified

00:14:58.000 --> 00:15:00.780
or if the parent view has
otherwise calculated a fixed

00:15:00.780 --> 00:15:01.860
size for it.

00:15:01.860 --> 00:15:04.540
So if you're familiar with the
match parents that you might

00:15:04.540 --> 00:15:07.630
set in the LayoutParams or
weight that you might use in

00:15:07.630 --> 00:15:10.380
linear layout, these are good
examples of when we might use

00:15:10.380 --> 00:15:12.480
the EXACTLY mode.

00:15:12.480 --> 00:15:16.350
It's common to go ahead and do
a second pass to finalize a

00:15:16.350 --> 00:15:18.950
measurement in a multi-pass
scenario.

00:15:18.950 --> 00:15:20.320
And weight is one of these.

00:15:20.320 --> 00:15:23.760
Since we distribute whatever
leftover weight is still

00:15:23.760 --> 00:15:26.100
remaining after we've measured
all the child views, we use

00:15:26.100 --> 00:15:28.850
EXACTLY to go ahead and lock in
the extra size to each one

00:15:28.850 --> 00:15:32.110
of the child views.

00:15:32.110 --> 00:15:35.940
So AT_MOST specifies an upper
bound with the implication

00:15:35.940 --> 00:15:38.805
that the view should usually
be conservative with that.

00:15:38.805 --> 00:15:41.720
The measured size should always
be less than or equal

00:15:41.720 --> 00:15:44.520
to the size reported
in the MeasureSpec.

00:15:44.520 --> 00:15:48.030
When you give a view width of
wrap content, then the stock

00:15:48.030 --> 00:15:52.040
framework layouts will use
AT_MOST to measure that child.

00:15:52.040 --> 00:15:54.890
The view has the option of
consuming up to that specified

00:15:54.890 --> 00:15:59.000
size if it really wants to.

00:15:59.000 --> 00:16:00.880
And finally, you have the
UNSPECIFIED mode.

00:16:00.880 --> 00:16:03.980
This is where we just really
don't know anything enough to

00:16:03.980 --> 00:16:06.850
tell you how to measure in this
particular dimension.

00:16:06.850 --> 00:16:08.630
The view has potentially
infinite space

00:16:08.630 --> 00:16:09.860
available to it.

00:16:09.860 --> 00:16:12.250
So this is really common for
things like scroll containers,

00:16:12.250 --> 00:16:14.560
so scroll view, list
view, et cetera.

00:16:14.560 --> 00:16:17.160
The limits are based only on the
content that you're trying

00:16:17.160 --> 00:16:17.940
to place there.

00:16:17.940 --> 00:16:20.650
So most views still treat
this the same way that

00:16:20.650 --> 00:16:22.000
they do with AT_MOST.

00:16:22.000 --> 00:16:25.200
They just don't impose the
upper bound constraint.

00:16:25.200 --> 00:16:27.110
The implication is that the view
should still try and be

00:16:27.110 --> 00:16:28.810
as conservative as
possible and wrap

00:16:28.810 --> 00:16:30.060
tightly around the content.

00:16:33.090 --> 00:16:35.570
So making sure that you actually
get the right measure

00:16:35.570 --> 00:16:38.100
specs that match what your child
views want, it can be a

00:16:38.100 --> 00:16:39.210
little bit tricky.

00:16:39.210 --> 00:16:41.450
There are few utilities in the
framework that can help out

00:16:41.450 --> 00:16:42.870
with this, though.

00:16:42.870 --> 00:16:46.190
One of these utilities is the
getChildMeasureSpec method.

00:16:46.190 --> 00:16:48.630
It understands the standard
framework patterns for how

00:16:48.630 --> 00:16:50.290
layout params and measure
specs should

00:16:50.290 --> 00:16:51.320
interact with one another.

00:16:51.320 --> 00:16:53.540
It's kind of a handshake between
the two that happens

00:16:53.540 --> 00:16:57.080
during measurement
and the parent.

00:16:57.080 --> 00:17:05.000
So for example, if a parent
has exactly 300 pixels

00:17:05.000 --> 00:17:07.980
available to it and a child
wants to wrap content within

00:17:07.980 --> 00:17:13.760
it, then the spec that we'll
actually send to that child is

00:17:13.760 --> 00:17:16.060
300 pixels in the
AT_MOST mode.

00:17:20.619 --> 00:17:24.770
So once measurement is complete,
layout is just a

00:17:24.770 --> 00:17:26.470
matter of positioning
the child views that

00:17:26.470 --> 00:17:27.730
we've already measured.

00:17:27.730 --> 00:17:30.550
So usually this is where we
apply offsets, padding,

00:17:30.550 --> 00:17:34.050
margins, so on and so forth.

00:17:34.050 --> 00:17:36.790
And while ViewGroups can often
implement multi-pass

00:17:36.790 --> 00:17:40.100
measurement to get things
just right, layout

00:17:40.100 --> 00:17:42.300
will only happen once.

00:17:42.300 --> 00:17:44.860
If there's some expensive
computation that you need to

00:17:44.860 --> 00:17:47.900
perform during the whole measure
layout sequence, then

00:17:47.900 --> 00:17:50.300
you should really try and defer
it to layout if you can

00:17:50.300 --> 00:17:51.170
to be more efficient.

00:17:51.170 --> 00:17:53.710
That way you don't get caught
up in these multiple measure

00:17:53.710 --> 00:17:55.090
passes that can happen.

00:17:55.090 --> 00:17:57.310
And even if your own custom
view doesn't do multiple

00:17:57.310 --> 00:18:00.670
measure passes, some view that's
further above you in

00:18:00.670 --> 00:18:02.590
the hierarchy may be
performing that.

00:18:02.590 --> 00:18:04.590
So you still want to be as
optimal as possible.

00:18:07.150 --> 00:18:10.240
So this two phase measurement
in layout means that you'll

00:18:10.240 --> 00:18:12.170
often want a way to get at some
of the data that you've

00:18:12.170 --> 00:18:15.170
already computed in onMeasure
so that you don't have to

00:18:15.170 --> 00:18:17.180
compute it twice.

00:18:17.180 --> 00:18:20.470
GetMeasuredWidth and Height are
always there for you to

00:18:20.470 --> 00:18:21.850
use for this purpose.

00:18:21.850 --> 00:18:24.480
But sometimes you need to have
more info than that.

00:18:24.480 --> 00:18:26.640
You'll want to wait for child
views to communicate extra

00:18:26.640 --> 00:18:29.810
configuration data to your
layout code in general, such

00:18:29.810 --> 00:18:32.210
as gravity, for one example.

00:18:32.210 --> 00:18:33.650
ROMAIN GUY: We're going to
talk about LayoutParams.

00:18:33.650 --> 00:18:35.990
But just before we get started,
so we mentioned the

00:18:35.990 --> 00:18:38.100
three different measure
spec modes.

00:18:38.100 --> 00:18:40.110
It's real scary and intimidating
when you're

00:18:40.110 --> 00:18:42.600
trying to write a custom view
and you think about how can I

00:18:42.600 --> 00:18:43.790
implement all those modes?

00:18:43.790 --> 00:18:44.595
You don't have to.

00:18:44.595 --> 00:18:46.790
If you write a custom view and
you know exactly how it's

00:18:46.790 --> 00:18:49.190
going to be used in your UI, you
know it's always going to

00:18:49.190 --> 00:18:52.470
be match parent, match parent,
just implement the measure

00:18:52.470 --> 00:18:54.080
spec exactly.

00:18:54.080 --> 00:18:56.270
That's the big difference
between what you can do in a

00:18:56.270 --> 00:18:57.750
custom view.

00:18:57.750 --> 00:18:58.680
You can cut corners.

00:18:58.680 --> 00:18:59.920
You can cheat.

00:18:59.920 --> 00:19:01.180
You can make it a lot
more efficient.

00:19:01.180 --> 00:19:03.880
And what we can do in our views
in the framework is we

00:19:03.880 --> 00:19:06.200
have to make them work in
all possible situations.

00:19:06.200 --> 00:19:08.440
So our code is a lot more
complicated and harder to

00:19:08.440 --> 00:19:09.290
[? optimize ?]

00:19:09.290 --> 00:19:10.160
than what you can do.

00:19:10.160 --> 00:19:12.530
And this is why we keep telling
people, you should try

00:19:12.530 --> 00:19:15.280
to create custom views whenever
you can, because you

00:19:15.280 --> 00:19:18.230
can make them a lot easier to
write and much more efficient

00:19:18.230 --> 00:19:19.950
than the ones that we have.

00:19:19.950 --> 00:19:23.340
For instance, if you are trying
use all the different

00:19:23.340 --> 00:19:25.475
widgets that we have in the UI
Toolkit to create a really

00:19:25.475 --> 00:19:28.450
complex UI and it doesn't quite
work, you can write a

00:19:28.450 --> 00:19:29.360
custom view instead.

00:19:29.360 --> 00:19:30.870
It's going to be easier.

00:19:30.870 --> 00:19:34.360
You might spend less time
writing that Java code than

00:19:34.360 --> 00:19:37.160
trying to come up with the magic
XML incantation that's

00:19:37.160 --> 00:19:37.975
going to do what you want.

00:19:37.975 --> 00:19:40.700
And it's also going to
be more efficient.

00:19:40.700 --> 00:19:43.470
So to create the measure specs
for your children, if you're

00:19:43.470 --> 00:19:45.540
writing a custom view that
extends ViewGroups, or if

00:19:45.540 --> 00:19:48.670
you're writing a custom layout,
you will be very

00:19:48.670 --> 00:19:50.070
interested in LayoutParams.

00:19:50.070 --> 00:19:52.730
So LayoutParams, you know
what they are from

00:19:52.730 --> 00:19:53.840
XML most of the time.

00:19:53.840 --> 00:19:55.860
They are all those attributes
that sell to layout

00:19:55.860 --> 00:19:59.890
underscore, and a map to a class
that is typically called

00:19:59.890 --> 00:20:00.330
LayoutParams.

00:20:00.330 --> 00:20:05.290
And it's static in your class
of the layout it belongs to.

00:20:05.290 --> 00:20:07.990
So the base class is called
ViewGroup.LayoutParams.

00:20:07.990 --> 00:20:10.450
But we also have
LinearLayout.LayoutParams.

00:20:10.450 --> 00:20:10.720
We have

00:20:10.720 --> 00:20:12.480
FrameLayout.LayoutParams, and so on.

00:20:12.480 --> 00:20:13.960
You don't have to
do it this way.

00:20:13.960 --> 00:20:15.810
This is just the recommended
way.

00:20:15.810 --> 00:20:17.860
The base LayoutParams
class will give you

00:20:17.860 --> 00:20:18.840
a width and a height.

00:20:18.840 --> 00:20:20.190
There's another one
you can use.

00:20:20.190 --> 00:20:21.760
It's called margin
layout params.

00:20:21.760 --> 00:20:24.415
It will give you the extra
margin parameters if you need

00:20:24.415 --> 00:20:27.580
bespoke margins in your
customer group.

00:20:27.580 --> 00:20:29.480
So LayoutParams are really
dumb objects.

00:20:29.480 --> 00:20:31.540
They are just here
to store data.

00:20:31.540 --> 00:20:33.690
They just store the arguments
that you're getting from the

00:20:33.690 --> 00:20:35.120
view when it's added
to the ViewGroup.

00:20:35.120 --> 00:20:36.640
So either from code--

00:20:36.640 --> 00:20:38.460
when you say add view, you press
the view, then the set

00:20:38.460 --> 00:20:39.300
of LayoutParams--

00:20:39.300 --> 00:20:40.810
or from XML, you can
[? import ?] the

00:20:40.810 --> 00:20:42.730
LayoutParams from XML.

00:20:42.730 --> 00:20:45.080
And you know about the
width and height.

00:20:45.080 --> 00:20:47.600
But in LinearLayout, we
mentioned the weight.

00:20:47.600 --> 00:20:49.770
This is one of the params
that we store in

00:20:49.770 --> 00:20:52.300
LinearLayout.LayoutParams.

00:20:52.300 --> 00:20:54.190
It's always a mouthful
[INAUDIBLE].

00:20:54.190 --> 00:20:54.690
ADAM POWELL: It is.

00:20:54.690 --> 00:20:57.700
ROMAIN GUY: We need
to rename them.

00:20:57.700 --> 00:20:58.490
Beyond LayoutParams.

00:20:58.490 --> 00:21:00.450
So if you create custom
LayoutParams because you want

00:21:00.450 --> 00:21:03.570
more than the width and the
height, there are four other

00:21:03.570 --> 00:21:05.120
methods that you should
implement

00:21:05.120 --> 00:21:06.160
in your custom ViewGroup.

00:21:06.160 --> 00:21:08.160
So we have one called
check LayoutParams.

00:21:08.160 --> 00:21:10.580
This is invoked when you add
a view to a ViewGroup.

00:21:10.580 --> 00:21:13.570
If that group already has
LayoutParams attached to it,

00:21:13.570 --> 00:21:15.910
we're going to call check
LayoutParams to see if those

00:21:15.910 --> 00:21:19.590
LayoutParams are compatible
with the ViewGroup.

00:21:19.590 --> 00:21:21.550
So usually what views
do here, it's just

00:21:21.550 --> 00:21:23.130
an instance of check.

00:21:23.130 --> 00:21:25.960
So if you look at LinearLayout,
it just does the

00:21:25.960 --> 00:21:29.080
parameters instance of
LinearLayout.LayoutParams.

00:21:29.080 --> 00:21:29.980
But you could do a lot more.

00:21:29.980 --> 00:21:33.280
If you have a lot of custom
parameters, you could vary the

00:21:33.280 --> 00:21:35.950
constraints, for instance, and
throw an exception if they

00:21:35.950 --> 00:21:37.590
don't work.

00:21:37.590 --> 00:21:40.340
Generic LayoutParams, the
texture LayoutParams

00:21:40.340 --> 00:21:42.980
attribute, can be used
to do conversion.

00:21:42.980 --> 00:21:45.980
So if you add a view that was
previously in the frame layout

00:21:45.980 --> 00:21:48.646
and it has frame layout
LayoutParams, and then that

00:21:48.646 --> 00:21:51.280
view is added to your ViewGroup,
and if you know how

00:21:51.280 --> 00:21:53.900
to convert those frame layouts,
LayoutParams in your

00:21:53.900 --> 00:21:56.690
LayoutParams, you can do
so in that method.

00:21:56.690 --> 00:21:59.630
Generic LayoutParams within an
attribute set, this is what's

00:21:59.630 --> 00:22:02.730
used when we inflate the
LayoutParams from XML.

00:22:02.730 --> 00:22:05.200
So the default behavior here
that we use-- actually, that's

00:22:05.200 --> 00:22:06.630
what we use all the time--

00:22:06.630 --> 00:22:09.710
we just call the constructor
or LayoutParams [INAUDIBLE]

00:22:09.710 --> 00:22:10.500
the attribute set.

00:22:10.500 --> 00:22:12.420
And all the work
is done there.

00:22:12.420 --> 00:22:14.690
And finally, default
LayoutParams.

00:22:14.690 --> 00:22:16.750
If you don't specify
LayoutParams when you add a

00:22:16.750 --> 00:22:20.350
view from code, we're going to
try to guess what's the best

00:22:20.350 --> 00:22:22.000
configuration for ViewGroup.

00:22:22.000 --> 00:22:24.410
So typically in the frame
layout, we're going to do

00:22:24.410 --> 00:22:26.380
match parents, match parents.

00:22:26.380 --> 00:22:28.360
A linear layout will do
something like wrap content,

00:22:28.360 --> 00:22:30.980
wrap content, something
like that.

00:22:30.980 --> 00:22:33.320
But don't forget that
LayoutParams can also be used

00:22:33.320 --> 00:22:34.420
to store private data.

00:22:34.420 --> 00:22:36.540
So if you do a lot of expensive
computations during

00:22:36.540 --> 00:22:39.260
the measure pass or even doing
the layout pass, you can store

00:22:39.260 --> 00:22:41.800
all that data per child
in the LayoutParams.

00:22:41.800 --> 00:22:43.810
So if you go look at the source
code of RelativeLayout,

00:22:43.810 --> 00:22:45.930
for instance, that's exactly
what it does.

00:22:45.930 --> 00:22:49.040
It does its own private fields
to keep track of

00:22:49.040 --> 00:22:50.900
what's going on.

00:22:50.900 --> 00:22:52.850
I want to talk briefly
about drawing.

00:22:52.850 --> 00:22:55.320
We won't spend too much time on
it, because we have a lot

00:22:55.320 --> 00:22:57.255
of other sessions
about rendering.

00:22:57.255 --> 00:23:00.500
But the way to trigger a joint
traversal is to call

00:23:00.500 --> 00:23:02.100
Invalidate.

00:23:02.100 --> 00:23:04.530
I'm sure a lot of you are
familiar with that method.

00:23:04.530 --> 00:23:06.860
And just like with the
RequestLayout, it's a

00:23:06.860 --> 00:23:07.625
recursive algorithm.

00:23:07.625 --> 00:23:09.260
So it's going to walk
up the tree.

00:23:09.260 --> 00:23:10.960
So I'm going to call Invalidate
on the parents

00:23:10.960 --> 00:23:11.330
[INAUDIBLE]

00:23:11.330 --> 00:23:13.030
something called
InvalidateChild.

00:23:13.030 --> 00:23:15.250
And those methods are actually
pretty expensive.

00:23:15.250 --> 00:23:17.790
RequestLayout is pretty cheap
because all it does, it sends

00:23:17.790 --> 00:23:19.990
a flag saying I want
to layout.

00:23:19.990 --> 00:23:23.880
Invalidate has to keep track of
animations, of bounds, of

00:23:23.880 --> 00:23:25.860
transforms, things like that.

00:23:25.860 --> 00:23:28.450
So again, if you go look at the
source code that occurs,

00:23:28.450 --> 00:23:31.020
you'll see that it's not a
trivial method to call.

00:23:31.020 --> 00:23:32.910
Again, we try to optimize
those calls.

00:23:32.910 --> 00:23:36.950
So if you have two siblings
of a ViewGroup that call

00:23:36.950 --> 00:23:41.250
Invalidate, only one of them
will go all the way up.

00:23:41.250 --> 00:23:43.260
Calling Invalidate without any
parameters will mark the

00:23:43.260 --> 00:23:45.160
entire view as dirty.

00:23:45.160 --> 00:23:47.580
There's a variant of Invalidate
that takes four

00:23:47.580 --> 00:23:48.290
parameters.

00:23:48.290 --> 00:23:50.950
It's a sub-rectangle of the view
that you want to redraw.

00:23:50.950 --> 00:23:53.850
So whenever you can, if you have
enough information about

00:23:53.850 --> 00:23:56.240
what's going on inside the
view, try to use a second

00:23:56.240 --> 00:23:57.080
variant of the method.

00:23:57.080 --> 00:24:00.060
It will be a lot cheaper for
the UI Toolkit and for your

00:24:00.060 --> 00:24:03.840
application to do the redraw
when we come back down.

00:24:03.840 --> 00:24:06.530
So once we call Invalidate,
we're going to call the draw

00:24:06.530 --> 00:24:09.910
method on your view, and
possibly on other views.

00:24:09.910 --> 00:24:12.390
So the draw method in the base
view class is final.

00:24:12.390 --> 00:24:15.570
You cannot override that method,
because it does a lot

00:24:15.570 --> 00:24:18.225
of bookkeeping that we don't
want you to mess with.

00:24:18.225 --> 00:24:20.290
And trust me, you really
don't want to have

00:24:20.290 --> 00:24:22.080
to deal with that.

00:24:22.080 --> 00:24:25.850
Draw will invoke the methods
that you can override.

00:24:25.850 --> 00:24:27.350
So the first one is
called onDrawing.

00:24:27.350 --> 00:24:29.270
I'm sure a lot of you are
familiar with that method.

00:24:29.270 --> 00:24:33.610
So how many of you have ever
implemented the onDraw method?

00:24:33.610 --> 00:24:34.220
That's really good.

00:24:34.220 --> 00:24:35.480
ADAM POWELL: They have
lots of experience.

00:24:35.480 --> 00:24:38.550
ROMAIN GUY: So the only goal
of the onDraw method is to

00:24:38.550 --> 00:24:40.000
draw the content of the view.

00:24:40.000 --> 00:24:41.260
You don't have to draw
a background.

00:24:41.260 --> 00:24:44.620
The base view class, the draw
method will do that for you.

00:24:44.620 --> 00:24:46.940
But any other content you want
to draw, like text view.

00:24:46.940 --> 00:24:49.360
That's where you do it.

00:24:49.360 --> 00:24:50.640
There's a little trick.

00:24:50.640 --> 00:24:51.850
We have a method that--

00:24:51.850 --> 00:24:52.740
I hate that name.

00:24:52.740 --> 00:24:53.570
It's so confusing--

00:24:53.570 --> 00:24:54.820
setWillNotDraw(true).

00:24:57.730 --> 00:24:59.110
Again, after six years, still
get it wrong every time

00:24:59.110 --> 00:25:00.100
I try to use it.

00:25:00.100 --> 00:25:02.200
And it's even worse, because
internally it's implemented as

00:25:02.200 --> 00:25:03.590
a bit inside the [INAUDIBLE].

00:25:03.590 --> 00:25:05.940
So with all the mess that
you have to use,

00:25:05.940 --> 00:25:08.140
it gets really confusing.

00:25:08.140 --> 00:25:09.780
ViewGroup by default
will set that flad.

00:25:09.780 --> 00:25:13.680
So when that flag is set, you
promise that you do not want

00:25:13.680 --> 00:25:14.420
to do anything.

00:25:14.420 --> 00:25:15.550
Your children will draw.

00:25:15.550 --> 00:25:17.120
But you're not been going
to draw anything.

00:25:17.120 --> 00:25:17.900
You don't have a background.

00:25:17.900 --> 00:25:19.560
You don't want to draw anything

00:25:19.560 --> 00:25:20.790
on top of your children.

00:25:20.790 --> 00:25:23.030
So in that case, we're going
to skip the onDraw call.

00:25:23.030 --> 00:25:25.050
And we're going to call directly
in the other method

00:25:25.050 --> 00:25:26.530
called dispatchDraw.

00:25:26.530 --> 00:25:29.700
And dispatchDraw is another
pretty complex method.

00:25:29.700 --> 00:25:31.060
But you can override it.

00:25:31.060 --> 00:25:33.200
It's responsible for drawing
the children.

00:25:33.200 --> 00:25:35.900
And this is where we apply all
the transforms, like the

00:25:35.900 --> 00:25:41.150
alpha, rotation, scaling, and
animations with the old

00:25:41.150 --> 00:25:42.400
animation system.

00:25:42.400 --> 00:25:44.270
And for every child, we
call a method called

00:25:44.270 --> 00:25:45.310
ViewGroup.drawChild.

00:25:45.310 --> 00:25:47.670
So if you want to override that
method entirely, make

00:25:47.670 --> 00:25:50.060
sure that you call the drawChild
method for every one

00:25:50.060 --> 00:25:51.130
of your children.

00:25:51.130 --> 00:25:54.460
Otherwise you're not going to
get animations working or

00:25:54.460 --> 00:25:56.460
transforms.

00:25:56.460 --> 00:25:59.570
There's a big difference between
software and hardware

00:25:59.570 --> 00:26:01.830
rendering in the way we call
those drawing methods.

00:26:01.830 --> 00:26:03.865
So as I mentioned before, we
introduced hardware rendering

00:26:03.865 --> 00:26:06.350
in Android 3.0.

00:26:06.350 --> 00:26:10.390
And in software, if you call
Invalidate, we're going to

00:26:10.390 --> 00:26:13.370
call the draw method of every
view that's a parent of the

00:26:13.370 --> 00:26:14.390
view that called Invalidate.

00:26:14.390 --> 00:26:17.310
We are also going to call the
draw method of any view that

00:26:17.310 --> 00:26:19.450
intersects with the
dirty region.

00:26:19.450 --> 00:26:22.950
So if you have views stacked on
top of each other, and even

00:26:22.950 --> 00:26:25.420
if they're siblings, we are
going to call a draw method on

00:26:25.420 --> 00:26:26.750
every one of those views.

00:26:26.750 --> 00:26:28.700
So it can be pretty expensive.

00:26:28.700 --> 00:26:31.250
In hardware, however, we are a
completely different system.

00:26:31.250 --> 00:26:32.940
And I won't go into
details here.

00:26:32.940 --> 00:26:36.640
There was a talk two years
ago explaining

00:26:36.640 --> 00:26:37.980
how it works exactly.

00:26:37.980 --> 00:26:41.650
But only the view that calls
Invalidate will see its draw

00:26:41.650 --> 00:26:42.970
method invoked.

00:26:42.970 --> 00:26:43.880
This is much more efficient.

00:26:43.880 --> 00:26:46.150
You can imagine that if you have
10 parents, and suddenly

00:26:46.150 --> 00:26:49.780
we have to call only one method
instead of 11, it's

00:26:49.780 --> 00:26:51.300
going to be a lot faster.

00:26:51.300 --> 00:26:54.130
So you can refer to that talk,
"Accelerated Android

00:26:54.130 --> 00:26:57.380
Rendering," where we explained
in detail how the new

00:26:57.380 --> 00:26:59.670
rendering system works.

00:26:59.670 --> 00:27:00.670
ADAM POWELL: All right.

00:27:00.670 --> 00:27:03.600
So a lot of your views are going
to have instant state.

00:27:03.600 --> 00:27:05.940
This is some extra information
that you're going to want to

00:27:05.940 --> 00:27:08.030
be able to save for later.

00:27:08.030 --> 00:27:10.070
Android app components
can come and go

00:27:10.070 --> 00:27:11.390
at any time, remember.

00:27:11.390 --> 00:27:13.510
So process containers
get killed.

00:27:13.510 --> 00:27:17.020
Activities get recreated if you
change the orientation or

00:27:17.020 --> 00:27:18.340
something else changes.

00:27:18.340 --> 00:27:20.990
But views can actually save
their own state for later in a

00:27:20.990 --> 00:27:24.820
way that can be persisted
by the system.

00:27:24.820 --> 00:27:27.950
So two methods control this
save and restore process,

00:27:27.950 --> 00:27:31.810
named onSaveInstanceState and
onRestoreInstanceState.

00:27:31.810 --> 00:27:34.680
And the easiest way to write
one of these instance state

00:27:34.680 --> 00:27:39.310
objects that gets persisted is
to extend the base saved state

00:27:39.310 --> 00:27:42.080
in a static inner class
of your view.

00:27:42.080 --> 00:27:45.010
And this establishes conventions
for how sub class

00:27:45.010 --> 00:27:48.650
and super class state get
organized within this

00:27:48.650 --> 00:27:49.920
persistent bundle.

00:27:49.920 --> 00:27:53.860
So the standard naming
convention is just in a class

00:27:53.860 --> 00:27:56.850
called saved state
within your view.

00:27:56.850 --> 00:27:59.710
Views need to have an ID for
their instance state to be

00:27:59.710 --> 00:28:00.480
saved and restored.

00:28:00.480 --> 00:28:02.530
This is really important.

00:28:02.530 --> 00:28:05.640
This also needs to be unique
within your view hierarchy.

00:28:05.640 --> 00:28:08.580
This is how we actually match up
what data to pump back into

00:28:08.580 --> 00:28:11.690
the onRestore method when your
views get recreated.

00:28:11.690 --> 00:28:14.250
So if you duplicate the ID
within multiple views within

00:28:14.250 --> 00:28:16.950
your hierarchy, we're going to
restore that same state to

00:28:16.950 --> 00:28:19.130
multiple views, which probably
isn't what you want.

00:28:21.810 --> 00:28:24.960
So the mechanisms behind
actually saving the instance

00:28:24.960 --> 00:28:26.600
state are pretty well
documented.

00:28:26.600 --> 00:28:30.240
But what you save is a more
interesting question.

00:28:30.240 --> 00:28:32.270
Don't bother saving anything
that's a part

00:28:32.270 --> 00:28:33.650
of your data model.

00:28:33.650 --> 00:28:37.060
Instead, save things that are
a reflection of the views

00:28:37.060 --> 00:28:41.050
state as it relates to the
user's interaction with it.

00:28:41.050 --> 00:28:42.880
So you really want to
keep these concerns

00:28:42.880 --> 00:28:44.400
as separate as possible.

00:28:44.400 --> 00:28:46.780
Normal data loading within your
app is going to take care

00:28:46.780 --> 00:28:48.490
of reflecting the state
of your data model.

00:28:48.490 --> 00:28:50.770
There's really no reason to save
it a second time and have

00:28:50.770 --> 00:28:52.820
multiple sources of truth.

00:28:52.820 --> 00:28:55.750
Instead, the view instance
state should take care of

00:28:55.750 --> 00:28:59.080
leaving the details where
the user left them.

00:28:59.080 --> 00:29:02.340
So things like uncommitted user
input can be a little bit

00:29:02.340 --> 00:29:05.810
of a grey area in this, like
text entered in the field if

00:29:05.810 --> 00:29:08.500
you have a really long
form, for example.

00:29:08.500 --> 00:29:10.920
In many cases, we'll go ahead
and save this for you.

00:29:10.920 --> 00:29:13.430
So Edit Text will automatically
persist whatever

00:29:13.430 --> 00:29:15.320
text the user's entered.

00:29:15.320 --> 00:29:16.340
ROMAIN GUY: So basically you're
telling people to not

00:29:16.340 --> 00:29:17.680
be like a webpage--

00:29:17.680 --> 00:29:19.200
like when you reload the webpage
and all your stuff

00:29:19.200 --> 00:29:19.635
disappears?

00:29:19.635 --> 00:29:20.885
ADAM POWELL: Yeah, basically.

00:29:24.080 --> 00:29:26.780
So next we have touch events.

00:29:26.780 --> 00:29:27.530
Touch events are fun.

00:29:27.530 --> 00:29:29.840
They're really a key
component of any

00:29:29.840 --> 00:29:31.680
interactive view these days.

00:29:31.680 --> 00:29:35.060
So the basic event handling,
again, is well documented.

00:29:35.060 --> 00:29:37.130
But what happens when it
gets more complex?

00:29:37.130 --> 00:29:39.700
What happens when you actually
have views at multiple levels

00:29:39.700 --> 00:29:41.485
of the hierarchy that
need to negotiate?

00:29:44.080 --> 00:29:47.490
Well, first off, it's important
to know what a

00:29:47.490 --> 00:29:49.370
consistent event stream means.

00:29:49.370 --> 00:29:52.460
Android has this idea of a
consistent event stream when

00:29:52.460 --> 00:29:54.460
it comes to motion
event objects.

00:29:54.460 --> 00:29:57.700
This is a guarantee from other
parts of the view system to

00:29:57.700 --> 00:29:59.310
your views.

00:29:59.310 --> 00:30:02.090
You really shouldn't break this
guarantee you when you

00:30:02.090 --> 00:30:04.100
write your views and
you end up sending

00:30:04.100 --> 00:30:05.090
events to other views.

00:30:05.090 --> 00:30:06.770
You want to make sure that
these guarantees hold.

00:30:09.400 --> 00:30:12.480
So ACTION_DOWN starts
a new gesture.

00:30:12.480 --> 00:30:14.470
It's really the beginning
of a touch interaction.

00:30:14.470 --> 00:30:18.570
It's when the first touch point
contacts the stream.

00:30:18.570 --> 00:30:21.590
And then throughout the course
of a gesture, you might get

00:30:21.590 --> 00:30:25.530
additional ACTION_POINTER_DOWN
and ACTION_POINTER_UP events

00:30:25.530 --> 00:30:28.170
as more touch points beyond
the first enter

00:30:28.170 --> 00:30:29.520
and leave the screen.

00:30:29.520 --> 00:30:32.410
Now each one of these pointers
has an ID attached to it.

00:30:32.410 --> 00:30:36.410
And these can be used to track
the same touch point when you

00:30:36.410 --> 00:30:39.320
have multiple touch
points active.

00:30:39.320 --> 00:30:42.500
ACTION_POINTER_DOWN is the start
of a specific pointer

00:30:42.500 --> 00:30:43.680
becoming valid.

00:30:43.680 --> 00:30:48.260
And UP is that pointer
becoming invalid.

00:30:48.260 --> 00:30:50.230
So while a gesture is in
progress, you'll get the

00:30:50.230 --> 00:30:52.690
steady stream of action
move events as those

00:30:52.690 --> 00:30:54.180
pointers move around.

00:30:54.180 --> 00:30:57.660
These events contain info about
every touch point that's

00:30:57.660 --> 00:31:00.710
currently in contact
with the screen.

00:31:00.710 --> 00:31:02.750
And you'll have been told about
each and every one of

00:31:02.750 --> 00:31:05.200
these through either the
initial ACTION_DOWN or

00:31:05.200 --> 00:31:06.970
ACTION_POINTER_DOWN events.

00:31:06.970 --> 00:31:10.010
And if any of them leave the
screen, you'll be told through

00:31:10.010 --> 00:31:15.020
an ACTION_POINTER_UP or the
final ACTION_UP event.

00:31:15.020 --> 00:31:18.600
ACTION_UP or ACTION_CANCEL ends
the current gesture in

00:31:18.600 --> 00:31:19.610
progress entirely.

00:31:19.610 --> 00:31:21.620
It means the user is done
interacting with the screen

00:31:21.620 --> 00:31:22.970
for the time being.

00:31:22.970 --> 00:31:25.390
ACTION_UP means that
it ended normally.

00:31:25.390 --> 00:31:27.690
ACTION_CANCEL means that
something else took the user's

00:31:27.690 --> 00:31:29.460
control away from your view.

00:31:29.460 --> 00:31:32.590
So what this means is that
ACTION_UP is where you should

00:31:32.590 --> 00:31:36.150
do things like fling, or
actually apply a click event.

00:31:36.150 --> 00:31:39.100
Whereas ACTION_CANCEL should
never commit an action,

00:31:39.100 --> 00:31:41.740
because you never really know
what took the user's control

00:31:41.740 --> 00:31:42.990
away from that view.

00:31:45.770 --> 00:31:48.810
Now when you have multiple views
working together to form

00:31:48.810 --> 00:31:51.940
your UI's full touch
interaction, it's important to

00:31:51.940 --> 00:31:54.660
factor that interaction
appropriately across your

00:31:54.660 --> 00:31:56.130
different views.

00:31:56.130 --> 00:31:59.090
Now Android gives you several
tools for views to collaborate

00:31:59.090 --> 00:32:01.690
and decide which view should
actually be responsible for

00:32:01.690 --> 00:32:04.900
handling a current touch
interaction.

00:32:04.900 --> 00:32:07.580
Now onTouchEvent is the
simplest of these.

00:32:07.580 --> 00:32:10.760
If a view returns true from
onTouchEvent for an initial

00:32:10.760 --> 00:32:14.340
ACTION_DOWN, then the rest of
the event stream will be sent

00:32:14.340 --> 00:32:15.480
to that view.

00:32:15.480 --> 00:32:18.440
So it'll try and find the
deepest view that will accept

00:32:18.440 --> 00:32:20.850
a touch event.

00:32:20.850 --> 00:32:22.610
It's kind of like focus for
touch events, really.

00:32:25.650 --> 00:32:28.000
Now parent views have an
additional method that they

00:32:28.000 --> 00:32:30.810
can use for this, and that's
onInterceptTouchEvent.

00:32:30.810 --> 00:32:33.570
This will be called for each
event that one of the parent

00:32:33.570 --> 00:32:36.010
views' children receives.

00:32:36.010 --> 00:32:38.620
By returning true for this, the
parent can go ahead and

00:32:38.620 --> 00:32:41.580
steal the event stream away
from the child view.

00:32:41.580 --> 00:32:44.230
The child will get an
ACTION_CANCEL event, since

00:32:44.230 --> 00:32:47.010
that's what a view receives
whenever the event stream is

00:32:47.010 --> 00:32:48.740
taken away from it
for some reason.

00:32:48.740 --> 00:32:52.460
And the parent will receive the
rest of the current events

00:32:52.460 --> 00:32:55.350
stream through its own
onTouchEvent method, not

00:32:55.350 --> 00:32:57.700
through the
onInterceptTouchEvent method.

00:32:57.700 --> 00:33:00.770
Now onIntercept is a great way
to implement things like

00:33:00.770 --> 00:33:02.300
scrolling and dragging.

00:33:02.300 --> 00:33:04.100
But it can really be
insufficient if you have

00:33:04.100 --> 00:33:06.886
several levels of
nested views.

00:33:06.886 --> 00:33:09.470
Now list views inside view pages
are a great example.

00:33:12.210 --> 00:33:15.610
So to handle this case, we
have this method that--

00:33:15.610 --> 00:33:18.210
what is it with our framework
having all these mouthful of

00:33:18.210 --> 00:33:19.990
constants and methods in here?

00:33:19.990 --> 00:33:21.840
ROMAIN GUY: We have to be very
specific in the names.

00:33:21.840 --> 00:33:22.500
ADAM POWELL: Right.

00:33:22.500 --> 00:33:23.750
So we have requestDisallowI
nterceptTouchEvent.

00:33:27.000 --> 00:33:30.410
Now by calling this method on a
parent view, a view can stop

00:33:30.410 --> 00:33:32.890
the parent's onIntercept method
from being called for

00:33:32.890 --> 00:33:34.920
the remaining events
in the gesture.

00:33:34.920 --> 00:33:37.780
And in the case of something
like the list view inside the

00:33:37.780 --> 00:33:40.300
view pager, list view
invokes this method.

00:33:40.300 --> 00:33:43.920
And then it actually will lock
the pager to the current page.

00:33:43.920 --> 00:33:46.730
The pager or has no idea that
you're moving back and forth

00:33:46.730 --> 00:33:48.090
left and right.

00:33:48.090 --> 00:33:50.860
And so therefore you won't move
between pages if you just

00:33:50.860 --> 00:33:54.750
want to make a really sloppy
scroll within that list.

00:33:54.750 --> 00:33:56.060
So speaking of sloppy
scrolling--

00:33:59.150 --> 00:34:01.090
well, in a second.

00:34:01.090 --> 00:34:05.130
One way or another, these
three methods, when put

00:34:05.130 --> 00:34:07.120
together, it means that you
can write custom views and

00:34:07.120 --> 00:34:09.639
ViewGroups without being too
concerned about how you're

00:34:09.639 --> 00:34:10.840
going to compose them.

00:34:10.840 --> 00:34:11.920
And this is really important.

00:34:11.920 --> 00:34:15.500
It means that you can keep all
these concerns separate within

00:34:15.500 --> 00:34:17.185
the different custom views
that you might write.

00:34:17.185 --> 00:34:19.870
The right thing will just happen
naturally as long as

00:34:19.870 --> 00:34:22.739
you don't nest strolling
along the same axis.

00:34:22.739 --> 00:34:25.630
I mean, how many times have we
all been using a webpage, and

00:34:25.630 --> 00:34:27.620
we'll go ahead and scroll with
a mouse wheel or something

00:34:27.620 --> 00:34:29.850
like that, and then suddenly
scrolling stops because there

00:34:29.850 --> 00:34:32.350
was this other internally
scrolling region that your

00:34:32.350 --> 00:34:34.370
cursor just happened to
be hovering over?

00:34:34.370 --> 00:34:35.860
You don't want to build that
within a touch UI.

00:34:39.920 --> 00:34:42.550
For this whole game of rock,
paper, scissors to work, you

00:34:42.550 --> 00:34:45.130
really an opportunity to
determine the user's intent

00:34:45.130 --> 00:34:48.130
before committing to one action
versus the other.

00:34:48.130 --> 00:34:51.130
And view configuration is a
class in the framework that

00:34:51.130 --> 00:34:56.460
has a lot of constants and other
values that control how

00:34:56.460 --> 00:34:59.850
the framework tunes these
sorts of things.

00:34:59.850 --> 00:35:02.770
In this case, you have
getScaledTouchSlot.

00:35:02.770 --> 00:35:04.860
Now this is going to be a
distance reported back to you

00:35:04.860 --> 00:35:07.980
in pixels adjusted for the
density of the current screen

00:35:07.980 --> 00:35:11.530
that is the distance that you
have to travel in terms of

00:35:11.530 --> 00:35:15.370
touch motion before you actually
commit to scrolling

00:35:15.370 --> 00:35:17.570
within that view.

00:35:17.570 --> 00:35:21.030
So having this slop within that
gets checked within your

00:35:21.030 --> 00:35:24.260
onIntercept method for a
scrolling container means that

00:35:24.260 --> 00:35:27.090
the child views have an
opportunity to say, no,

00:35:27.090 --> 00:35:29.830
actually I want this event
stream, and call

00:35:29.830 --> 00:35:31.830
requestDisallowI
nterseptTouchEvent up to the

00:35:31.830 --> 00:35:33.750
parent, so on and so forth.

00:35:33.750 --> 00:35:35.710
ROMAIN GUY: And view
configuration is a very useful

00:35:35.710 --> 00:35:40.530
class if you're doing anything
useful with your custom view,

00:35:40.530 --> 00:35:43.030
like touch handling, or even
animations or drawing.

00:35:43.030 --> 00:35:45.290
You might want to take a look at
view configuration and the

00:35:45.290 --> 00:35:47.170
kind of data it exposes.

00:35:47.170 --> 00:35:51.500
Because everything in that class
is meant to help you be

00:35:51.500 --> 00:35:53.400
consistent with the existing
UI Toolkit.

00:35:53.400 --> 00:35:57.010
So if you need a duration, there
may be a duration in

00:35:57.010 --> 00:36:00.080
there that matches your needs.

00:36:00.080 --> 00:36:02.010
So make sure to take
a look at it.

00:36:02.010 --> 00:36:04.530
And the class is actually
pretty well documented.

00:36:04.530 --> 00:36:06.460
You can once again look at the
source code of the Android

00:36:06.460 --> 00:36:09.240
platform and see
how we use it.

00:36:09.240 --> 00:36:10.870
So we have four minutes
left for questions.

00:36:10.870 --> 00:36:13.010
So if you have a question,
please walk up to the mics in

00:36:13.010 --> 00:36:15.120
the aisles.

00:36:15.120 --> 00:36:17.190
And before you leave the
room, there are bar

00:36:17.190 --> 00:36:18.270
codes by the door.

00:36:18.270 --> 00:36:20.300
You can scan them if you want
to rate the session.

00:36:20.300 --> 00:36:23.735
And we'll be at the office hours
on the floor to answer

00:36:23.735 --> 00:36:25.380
all your questions throughout
the day.

00:36:25.380 --> 00:36:26.017
ADAM POWELL: That's right.

00:36:26.017 --> 00:36:27.770
Thank you for coming.

00:36:27.770 --> 00:36:32.530
[APPLAUSE]

00:36:32.530 --> 00:36:33.630
AUDIENCE: Hello.

00:36:33.630 --> 00:36:34.350
I have a question.

00:36:34.350 --> 00:36:37.100
I want to implement view that's
like a heartbeat, like

00:36:37.100 --> 00:36:38.300
it's pulsing.

00:36:38.300 --> 00:36:41.390
But what I want it to do is I
will have that method like it

00:36:41.390 --> 00:36:43.860
posts every second or so.

00:36:43.860 --> 00:36:47.140
And I wanted animation
that posts back.

00:36:47.140 --> 00:36:48.470
So how should I do that?

00:36:48.470 --> 00:36:51.660
Should I have in my view some
kind of timer that draws the

00:36:51.660 --> 00:36:54.540
circle smaller and smaller
every 20 milliseconds?

00:36:54.540 --> 00:36:56.750
Should this be part
of the view?

00:36:56.750 --> 00:36:57.780
ROMAIN GUY: So you should
definitely use

00:36:57.780 --> 00:36:59.100
the animation framework.

00:36:59.100 --> 00:37:03.610
And tomorrow I'm giving a talk
with Chet Haase on animations.

00:37:03.610 --> 00:37:05.210
And this is the kind of
animation that we're going to

00:37:05.210 --> 00:37:06.150
talk about.

00:37:06.150 --> 00:37:09.500
AUDIENCE: And the other quick
one is some phones send you

00:37:09.500 --> 00:37:14.240
back an app event after 15
seconds, something like that,

00:37:14.240 --> 00:37:16.340
that's in the original
[? matrix. ?]

00:37:16.340 --> 00:37:19.350
I want to have a little button
which is press and hold.

00:37:19.350 --> 00:37:22.550
But after 15 seconds, it
give me app event.

00:37:22.550 --> 00:37:24.390
How can I do that?

00:37:24.390 --> 00:37:26.000
ADAM POWELL: That was the
same on the Motorola

00:37:26.000 --> 00:37:26.740
Zoom, wasn't it?

00:37:26.740 --> 00:37:27.820
ROMAIN GUY: Yeah.

00:37:27.820 --> 00:37:29.930
Sounds like a bug in the
[? touch dryer. ?]

00:37:29.930 --> 00:37:33.920
AUDIENCE: Any workaround for
this, that you know about?

00:37:33.920 --> 00:37:35.190
[INTERPOSING VOICES]

00:37:35.190 --> 00:37:36.580
ADAM POWELL: Unfortunately
that's one of those things

00:37:36.580 --> 00:37:38.990
where there are some devices out
there with touch firmware

00:37:38.990 --> 00:37:40.360
that try and do this.

00:37:40.360 --> 00:37:43.330
It's basically because the
device is trying to account

00:37:43.330 --> 00:37:45.860
for a noise or other sources of
error that might be in the

00:37:45.860 --> 00:37:47.910
environment so that you don't
have this permanent touch

00:37:47.910 --> 00:37:48.850
point down.

00:37:48.850 --> 00:37:52.170
Unfortunately, it ends up being
way too aggressive.

00:37:52.170 --> 00:37:54.620
Because if you're in a case
where you're holding down the

00:37:54.620 --> 00:37:56.850
gas pedal in a racing game, or
something like that, that

00:37:56.850 --> 00:37:58.270
becomes really problematic.

00:37:58.270 --> 00:37:59.940
And unfortunately, there's just
not a whole lot you can

00:37:59.940 --> 00:38:01.260
do about it.

00:38:01.260 --> 00:38:03.750
AUDIENCE: Thank you.

00:38:03.750 --> 00:38:04.140
AUDIENCE: Hi.

00:38:04.140 --> 00:38:06.600
So when you started, you
mentioned that there was a

00:38:06.600 --> 00:38:08.630
blog post about RelativeLayouts
that was

00:38:08.630 --> 00:38:10.756
misinterpreted.

00:38:10.756 --> 00:38:12.240
Yeah, it was misinterpreted.

00:38:12.240 --> 00:38:13.880
Everybody I know follows that.

00:38:13.880 --> 00:38:15.680
So could you elaborate
on that a little bit?

00:38:15.680 --> 00:38:21.590
ROMAIN GUY: So I think the
original post was about not

00:38:21.590 --> 00:38:24.520
using a linear layout with an
image in the text view and

00:38:24.520 --> 00:38:25.730
using only a single text view.

00:38:25.730 --> 00:38:27.310
Or maybe you could use only--

00:38:27.310 --> 00:38:27.710
no.

00:38:27.710 --> 00:38:29.660
It was about using a
RelativeLayout to avoid

00:38:29.660 --> 00:38:31.130
nesting linear layouts.

00:38:31.130 --> 00:38:33.240
AUDIENCE: That and weights,
I think, as well, right?

00:38:33.240 --> 00:38:34.690
ROMAIN GUY: Yeah, something
like that.

00:38:34.690 --> 00:38:35.950
ADAM POWELL: It was specifically
in the context of

00:38:35.950 --> 00:38:37.820
list items, too, right?

00:38:37.820 --> 00:38:38.300
ROMAIN GUY: That's correct.

00:38:38.300 --> 00:38:40.530
So it was the context of list
items to avoid nesting a

00:38:40.530 --> 00:38:42.810
vertical linear layout in a
horizontal linear layout.

00:38:42.810 --> 00:38:45.680
So it's still true, if
you're using weights.

00:38:45.680 --> 00:38:49.350
But using your RelativeLayout
to do everything is not the

00:38:49.350 --> 00:38:50.960
right answer.

00:38:50.960 --> 00:38:53.650
So if a firm layout does the job
because you need to stack

00:38:53.650 --> 00:38:57.200
views, or if you just want to
put the view side by side, go

00:38:57.200 --> 00:38:58.990
view linear layout
or firm layout.

00:38:58.990 --> 00:39:01.670
A RelativeLayout will always
do two measure passes.

00:39:01.670 --> 00:39:02.890
So when you nest,
then, you get an

00:39:02.890 --> 00:39:05.072
exponential measurement algorithm.

00:39:05.072 --> 00:39:07.778
AUDIENCE: Thank you.

00:39:07.778 --> 00:39:08.870
ROMAIN GUY: Last question.

00:39:08.870 --> 00:39:14.670
AUDIENCE: Hi, I have a
custom view that was

00:39:14.670 --> 00:39:16.370
a background shadow.

00:39:16.370 --> 00:39:20.650
And I noticed that it
works OK until 4.2.

00:39:20.650 --> 00:39:25.340
And in 4.2, I get some visual
artifacts that are strange.

00:39:25.340 --> 00:39:27.900
Is there anything that changed
in the rendering?

00:39:27.900 --> 00:39:29.180
ROMAIN GUY: Not that
I can think of.

00:39:29.180 --> 00:39:31.060
It might be a bug on our side.

00:39:31.060 --> 00:39:34.800
Or you might have been
relying on the but

00:39:34.800 --> 00:39:36.360
that existed before.

00:39:36.360 --> 00:39:39.380
I would need to see code
and a running example.

00:39:39.380 --> 00:39:41.910
Send me an APK that
[? repositions ?]

00:39:41.910 --> 00:39:42.320
the issue.

00:39:42.320 --> 00:39:43.450
And we can take a look
at it and see if it's

00:39:43.450 --> 00:39:44.120
a bug on our side.

00:39:44.120 --> 00:39:46.280
ADAM POWELL: Or if you'd like
we'll be in the Sandbox.

00:39:46.280 --> 00:39:47.350
ROMAIN GUY: For office
hours, yes.

00:39:47.350 --> 00:39:49.480
AUDIENCE: If possible,
another question.

00:39:49.480 --> 00:39:54.070
Is there an easy way to add
margins to a list item entry?

00:39:54.070 --> 00:39:54.660
ROMAIN GUY: To what?

00:39:54.660 --> 00:39:58.190
AUDIENCE: To a list view
entry to add margins?

00:39:58.190 --> 00:40:00.780
Because the margins are
cut by the list view.

00:40:00.780 --> 00:40:03.060
ROMAIN GUY: Oh, you should
use the padding instead.

00:40:03.060 --> 00:40:05.400
AUDIENCE: Even if we
have a background?

00:40:05.400 --> 00:40:07.500
ROMAIN GUY: Well, use padding
in the parent view.

00:40:07.500 --> 00:40:08.820
And then you put the
background inside.

00:40:08.820 --> 00:40:10.120
AUDIENCE: OK, thanks.

00:40:10.120 --> 00:40:12.700
ROMAIN GUY: Thank you.

00:40:12.700 --> 00:40:13.720
We are out of time.

00:40:13.720 --> 00:40:15.960
Come to the office hours
in the Sandbox.

00:40:15.960 --> 00:40:17.260
ADAM POWELL: Yep, happy to
answer your questions at

00:40:17.260 --> 00:40:18.530
office hours.

00:40:18.530 --> 00:40:19.780
Thanks.

