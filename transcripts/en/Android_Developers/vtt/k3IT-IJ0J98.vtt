WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:02.570
ADAM POWELL: Hello,
everyone, and welcome to What

00:00:02.570 --> 00:00:04.019
the Fragment.

00:00:04.019 --> 00:00:06.160
So I'm Adam Powell.

00:00:06.160 --> 00:00:08.250
I'm a member of the
Android Framework Team,

00:00:08.250 --> 00:00:10.005
specifically on the UI Toolkit.

00:00:10.005 --> 00:00:12.130
But I've spent a fair amount
of time with fragments

00:00:12.130 --> 00:00:12.963
over the years here.

00:00:12.963 --> 00:00:16.020
And hopefully we can go over
some interesting information

00:00:16.020 --> 00:00:17.180
here.

00:00:17.180 --> 00:00:21.929
So the first thing that people
tend to ask is why Fragments?

00:00:21.929 --> 00:00:23.720
There's a lot of
information out on the web

00:00:23.720 --> 00:00:27.080
as people have used the
API, gotten kind of familiar

00:00:27.080 --> 00:00:29.940
with it, and, in some ways,
kind of gotten bitten by it.

00:00:29.940 --> 00:00:31.481
There's a lot of
complexity there.

00:00:31.481 --> 00:00:33.230
And in fact, some
members of the community

00:00:33.230 --> 00:00:37.360
have put together a few
diagrams of just how complex

00:00:37.360 --> 00:00:40.240
the Fragment lifecycle
can be if you combine it

00:00:40.240 --> 00:00:43.090
with the full Activity
lifecycle as well.

00:00:43.090 --> 00:00:50.840
So you can start up at the
top here, and we keep going,

00:00:50.840 --> 00:00:51.915
and there's some more.

00:00:54.900 --> 00:00:55.400
Whew.

00:00:55.400 --> 00:00:55.640
OK.

00:00:55.640 --> 00:00:56.710
Well, we got to the end.

00:00:56.710 --> 00:00:58.879
So the blurriness that
you're seeing here

00:00:58.879 --> 00:01:01.170
isn't just because it's a
low-res version of the image,

00:01:01.170 --> 00:01:03.840
it's just your eyes glazing over
as you try and take all of this

00:01:03.840 --> 00:01:06.270
in.

00:01:06.270 --> 00:01:11.090
And this is kind of your
reaction after reading over it.

00:01:11.090 --> 00:01:15.244
So why Fragments?

00:01:15.244 --> 00:01:17.160
If this is kind of the
reaction that everybody

00:01:17.160 --> 00:01:20.340
has had over the last few years
out in the developer community,

00:01:20.340 --> 00:01:23.770
why is it still something that
we're pushing or promoting

00:01:23.770 --> 00:01:26.334
as a way to build
your applications?

00:01:26.334 --> 00:01:27.750
Well, to start
with that, we'll go

00:01:27.750 --> 00:01:29.458
over just kind of a
little bit of history

00:01:29.458 --> 00:01:32.740
about where Fragments came from.

00:01:32.740 --> 00:01:36.740
So some of you might have seen a
Google+ post by Dianne Hackborn

00:01:36.740 --> 00:01:40.120
this past weekend where she
went into some detail about

00:01:40.120 --> 00:01:43.160
the Android component model,
and how it's really not intended

00:01:43.160 --> 00:01:45.420
to impose a lot of
higher level architecture

00:01:45.420 --> 00:01:46.910
on your applications.

00:01:46.910 --> 00:01:49.590
Instead, it's really just meant
to be a series of smarter entry

00:01:49.590 --> 00:01:50.360
points.

00:01:50.360 --> 00:01:52.770
So in a traditional
program that you

00:01:52.770 --> 00:01:55.809
might have seen in classes
or so on and so forth,

00:01:55.809 --> 00:01:58.100
you start from a main function,
and you run to the end.

00:01:58.100 --> 00:02:00.870
And you might start a message
loop in the middle there.

00:02:00.870 --> 00:02:03.250
And what Activities really
give you to start with

00:02:03.250 --> 00:02:06.010
is just kind of a smarter
entry point, a place where

00:02:06.010 --> 00:02:08.449
the system can send you
other messages about what's

00:02:08.449 --> 00:02:09.669
going on to your application.

00:02:09.669 --> 00:02:14.770
And these are just turned into
callbacks on an object instead.

00:02:14.770 --> 00:02:17.690
So there were some other goals
in the design of Activities

00:02:17.690 --> 00:02:20.210
as well, which one of
those is that apps always

00:02:20.210 --> 00:02:22.640
stay in the state
where you left them.

00:02:22.640 --> 00:02:25.240
So in order to do that, you
have this well-defined Activity

00:02:25.240 --> 00:02:27.790
lifecycle and a compact
state representation

00:02:27.790 --> 00:02:29.750
that you can use so that
the process can die,

00:02:29.750 --> 00:02:32.450
come back later,
restore from that state.

00:02:32.450 --> 00:02:36.160
All of this is stuff that
you're probably familiar with.

00:02:36.160 --> 00:02:38.090
Also, apps can call
other apps to complete

00:02:38.090 --> 00:02:41.100
a task in the form of Activity
is called with intent.

00:02:41.100 --> 00:02:43.240
And each one of those
flows is represented

00:02:43.240 --> 00:02:45.540
as one of these encapsulated
units in the form

00:02:45.540 --> 00:02:48.600
of these Activities.

00:02:48.600 --> 00:02:50.330
So over time,
Activities just started

00:02:50.330 --> 00:02:52.770
getting big and complex.

00:02:52.770 --> 00:02:55.120
And basically, the way that
you deal with complexity

00:02:55.120 --> 00:02:57.700
is that you factor
out smaller pieces

00:02:57.700 --> 00:02:59.810
so that you can compose them.

00:02:59.810 --> 00:03:03.710
Back in the
pre-Android 3.0 days,

00:03:03.710 --> 00:03:06.050
we had this thing called
LocalActivityManager

00:03:06.050 --> 00:03:08.370
that could work in concert
with a TabHost widget

00:03:08.370 --> 00:03:11.900
that you can see here in the
old Gingerbread dialer app.

00:03:11.900 --> 00:03:14.270
So each one of these pieces
in each one of these tabs

00:03:14.270 --> 00:03:17.030
actually contained
a full activity.

00:03:17.030 --> 00:03:21.830
So that kind of gave some
weird pieces of the code

00:03:21.830 --> 00:03:24.440
there, in terms of how
the code would interact.

00:03:24.440 --> 00:03:26.310
There are ideas in
the Activity lifecycle

00:03:26.310 --> 00:03:27.684
that just really
don't make sense

00:03:27.684 --> 00:03:30.760
in this kind of composed model.

00:03:30.760 --> 00:03:32.430
And then this happened.

00:03:32.430 --> 00:03:36.130
And we're not going
to talk about that.

00:03:36.130 --> 00:03:39.890
So larger screens happened,
and larger screens

00:03:39.890 --> 00:03:41.190
mean larger problems.

00:03:41.190 --> 00:03:43.470
So we have this
idea of, how do you

00:03:43.470 --> 00:03:45.940
want to present these multiple
small screens worth of UI

00:03:45.940 --> 00:03:48.680
that you may have already built
in an existing application,

00:03:48.680 --> 00:03:51.660
and then sort of scale that
out across other screens?

00:03:51.660 --> 00:03:53.500
Is there a smaller
unit of composition

00:03:53.500 --> 00:03:55.190
that you could use for that?

00:03:55.190 --> 00:03:57.750
And so that other unit
of composition, spoilers,

00:03:57.750 --> 00:03:59.170
is Fragments.

00:03:59.170 --> 00:04:00.890
So this was introduced
around Honeycomb

00:04:00.890 --> 00:04:04.382
to try to solve some
of these problems.

00:04:04.382 --> 00:04:05.840
The first one of
these goals though

00:04:05.840 --> 00:04:08.224
was really just to break up
these giant Activity classes.

00:04:08.224 --> 00:04:09.640
And this is a
problem that happens

00:04:09.640 --> 00:04:11.936
whether you're dealing just
with small phone screens

00:04:11.936 --> 00:04:14.310
or if you're trying to scale
across many different screen

00:04:14.310 --> 00:04:15.340
sizes.

00:04:15.340 --> 00:04:19.130
And it's just kind of natural
that as app complexity grows,

00:04:19.130 --> 00:04:21.800
so does the complexity
of these big entry

00:04:21.800 --> 00:04:24.800
points that can grow to be
these god objects if you're not

00:04:24.800 --> 00:04:27.184
careful.

00:04:27.184 --> 00:04:29.350
We also kind of wanted to
fix some of these problems

00:04:29.350 --> 00:04:31.720
with LocalActivityManager
for when you do compose them

00:04:31.720 --> 00:04:33.700
in these smaller constructs.

00:04:33.700 --> 00:04:35.710
So you have lots of
these abstractions

00:04:35.710 --> 00:04:39.134
at the Activity level that
just don't work well when you

00:04:39.134 --> 00:04:40.300
start composing it this way.

00:04:40.300 --> 00:04:43.310
These are usually things
that aren't quite as well

00:04:43.310 --> 00:04:45.629
covered as, like, the Core
Activity State diagram.

00:04:45.629 --> 00:04:47.170
But they're all
cases that still need

00:04:47.170 --> 00:04:49.003
to be handled in a
general purpose solution.

00:04:51.662 --> 00:04:54.120
One of the other things that
we wanted to do with Fragments

00:04:54.120 --> 00:04:57.730
was to encapsulate
navigation state.

00:04:57.730 --> 00:05:02.420
So the state of your Fragments
can represent the full state

00:05:02.420 --> 00:05:04.250
of your Activity
in a way that can

00:05:04.250 --> 00:05:09.720
be preserved through state save
and restore through a process

00:05:09.720 --> 00:05:10.870
def.

00:05:10.870 --> 00:05:13.520
So we have things like an
Activity-local back stock,

00:05:13.520 --> 00:05:16.932
which some people find
useful and some people don't.

00:05:16.932 --> 00:05:18.890
But managed dialogs was
one of the other things

00:05:18.890 --> 00:05:20.306
that this really
tried to address.

00:05:20.306 --> 00:05:22.740
Dialog Fragment is something
that a lot of people

00:05:22.740 --> 00:05:24.010
do use at this point.

00:05:24.010 --> 00:05:26.390
And it's because you basically
get the state restoration

00:05:26.390 --> 00:05:27.920
for free if you
rotate the screen

00:05:27.920 --> 00:05:30.566
or go through any other
sorts of config changes.

00:05:30.566 --> 00:05:32.190
Back before Fragments,
this was handled

00:05:32.190 --> 00:05:34.140
by just kind of this
first-class facility that

00:05:34.140 --> 00:05:36.530
was provided by Activities
where you refer to a dialog

00:05:36.530 --> 00:05:37.400
by its ID.

00:05:37.400 --> 00:05:40.105
There's this whole other
creation process involved

00:05:40.105 --> 00:05:42.230
in terms of, like, yes, I
want to create the dialog

00:05:42.230 --> 00:05:42.870
with this ID.

00:05:42.870 --> 00:05:45.520
We would persist that ID
and try to build everything

00:05:45.520 --> 00:05:46.400
back up from scratch.

00:05:46.400 --> 00:05:48.725
And that ended up just being
very one-off and kind of

00:05:48.725 --> 00:05:49.600
awkward to work with.

00:05:52.136 --> 00:05:53.760
And the final goal
of that was probably

00:05:53.760 --> 00:05:56.440
the most obvious in terms of how
we pitched the API when it was

00:05:56.440 --> 00:05:58.960
first released is this
idea of decomposing

00:05:58.960 --> 00:06:00.940
these master/detail UIs.

00:06:00.940 --> 00:06:02.880
So if you have two
screens, that on a phone

00:06:02.880 --> 00:06:04.470
might look something
like this, where

00:06:04.470 --> 00:06:06.550
you've got a list
of conversations,

00:06:06.550 --> 00:06:08.800
as well as the actual
conversation itself.

00:06:08.800 --> 00:06:11.500
As you drill down
by tapping into it,

00:06:11.500 --> 00:06:15.690
use the Back button to get
back to where you were before.

00:06:15.690 --> 00:06:17.100
In another
configuration, you can

00:06:17.100 --> 00:06:18.680
take what's essentially
the same code

00:06:18.680 --> 00:06:20.452
and have it look like this.

00:06:20.452 --> 00:06:21.910
So this is something
that you might

00:06:21.910 --> 00:06:27.060
be familiar with from a lot
of UIs that you've seen here.

00:06:27.060 --> 00:06:29.130
And since then, we
kept building on it.

00:06:29.130 --> 00:06:31.522
So we had ViewPager and
the FragmentPagerAdapter,

00:06:31.522 --> 00:06:33.230
which a lot of people
still kind of think

00:06:33.230 --> 00:06:35.120
is the way to use
a ViewPager, just

00:06:35.120 --> 00:06:37.640
because we don't have a
stock adapter for dealing

00:06:37.640 --> 00:06:40.040
with just bare Views.

00:06:40.040 --> 00:06:41.880
So we've got
Loaders, which allow

00:06:41.880 --> 00:06:43.800
you to do similar
things of persisting

00:06:43.800 --> 00:06:47.540
some sort of a request
across configuration changes,

00:06:47.540 --> 00:06:51.060
keep it going, whether or not
the lifecycle might otherwise

00:06:51.060 --> 00:06:51.830
interrupt.

00:06:51.830 --> 00:06:53.460
Ian Lake has a
great post on Medium

00:06:53.460 --> 00:06:54.950
about this that
all of you should

00:06:54.950 --> 00:06:57.140
go read if you haven't as well.

00:06:57.140 --> 00:06:59.280
And then we also had this
idea of child fragments.

00:06:59.280 --> 00:07:01.740
So I mean, if you can nest
one level deep in terms

00:07:01.740 --> 00:07:03.680
of putting Fragments
inside an Activity, well,

00:07:03.680 --> 00:07:06.150
why can't you put Fragments
inside a Fragment?

00:07:06.150 --> 00:07:09.050
So that was an idea that
had a lot of support

00:07:09.050 --> 00:07:11.240
in terms of a lot of
developers were requesting

00:07:11.240 --> 00:07:14.860
this, both within Google and
external developers as well.

00:07:14.860 --> 00:07:17.170
And it got added I think
sometime around the Jellybean

00:07:17.170 --> 00:07:17.670
time frame.

00:07:21.600 --> 00:07:22.782
So how did it work out?

00:07:22.782 --> 00:07:24.240
I mean, some of
you kind of already

00:07:24.240 --> 00:07:25.615
know the answer
to this question.

00:07:25.615 --> 00:07:29.530
But these are sort of what we
took as stewards of the API,

00:07:29.530 --> 00:07:34.310
as some of the lessons
from Fragments.

00:07:34.310 --> 00:07:36.607
So the first problem
is that Fragments

00:07:36.607 --> 00:07:38.190
are so general that
they become really

00:07:38.190 --> 00:07:39.940
difficult to explain to people.

00:07:39.940 --> 00:07:44.720
So is it just a pain of a UI,
like in the Gmail example?

00:07:44.720 --> 00:07:47.190
Is it something like dialog
Fragments and something meant

00:07:47.190 --> 00:07:49.092
to deal with manage dialogs?

00:07:49.092 --> 00:07:51.550
Or is it something different
altogether, like you can still

00:07:51.550 --> 00:07:54.680
have headless Fragments that
can act completely independently

00:07:54.680 --> 00:07:55.750
of anything else?

00:07:55.750 --> 00:07:57.500
And we didn't give a
whole lot of guidance

00:07:57.500 --> 00:08:01.200
in terms of how to use these
things because we kind of felt

00:08:01.200 --> 00:08:03.790
like we didn't want to be
too prescriptive about it.

00:08:03.790 --> 00:08:05.430
And that ended up
really hurting us.

00:08:08.560 --> 00:08:12.050
So of course, the idea of
even more life cycle to manage

00:08:12.050 --> 00:08:13.930
was really kind
of a killer here.

00:08:13.930 --> 00:08:15.989
And the bugs really didn't help.

00:08:15.989 --> 00:08:17.780
This is really what
killed a lot of people.

00:08:17.780 --> 00:08:20.546
Whenever I've
talked to developers

00:08:20.546 --> 00:08:22.670
about what they would change
about the Fragment API

00:08:22.670 --> 00:08:25.510
or what problems they have
in using the Fragment API,

00:08:25.510 --> 00:08:28.880
a lot of times what happens is
that you build up a Fragment

00:08:28.880 --> 00:08:31.070
transaction, you commit
it, and then something

00:08:31.070 --> 00:08:33.630
works completely differently
from how you expect.

00:08:33.630 --> 00:08:37.330
It's not particularly
intuitive, some of these things.

00:08:37.330 --> 00:08:41.206
And it might kind of remove the
entire point of a bunch of code

00:08:41.206 --> 00:08:42.955
that you just spent a
lot of time writing.

00:08:46.330 --> 00:08:48.980
So this was another thing that
caused a lot of misconceptions.

00:08:48.980 --> 00:08:51.090
I mean, Fragments, they're
just kind of like Views, right?

00:08:51.090 --> 00:08:52.715
I mean, you can stick
this Fragment tag

00:08:52.715 --> 00:08:54.410
in one of your layout
files, inflate it,

00:08:54.410 --> 00:08:57.690
and you get a Fragment for free.

00:08:57.690 --> 00:09:00.000
In hindsight, the Fragment
tag was this great piece

00:09:00.000 --> 00:09:02.590
of syntactic sugar that
really confused people

00:09:02.590 --> 00:09:04.110
a lot more than
it helped in terms

00:09:04.110 --> 00:09:07.110
of just general education.

00:09:07.110 --> 00:09:11.279
So this immediately made people
think that Fragment equals View

00:09:11.279 --> 00:09:13.362
and that this is on the
same level of abstraction.

00:09:16.890 --> 00:09:20.470
So if we kind of know where
things went off the rails,

00:09:20.470 --> 00:09:22.966
then how might we start
trying to use Fragments

00:09:22.966 --> 00:09:24.216
a little bit more effectively?

00:09:28.350 --> 00:09:30.010
Well, the first
thing to keep in mind

00:09:30.010 --> 00:09:32.630
here is that
Fragments are roughly

00:09:32.630 --> 00:09:34.210
equivalent to an
Activity in terms

00:09:34.210 --> 00:09:36.770
of the level of abstraction
that they act on.

00:09:36.770 --> 00:09:39.390
They're composable entry points.

00:09:39.390 --> 00:09:41.170
And their lifecycle
and inputs are really

00:09:41.170 --> 00:09:43.520
controlled by
their surroundings.

00:09:43.520 --> 00:09:45.990
They optionally manage
a UI presentation.

00:09:45.990 --> 00:09:49.400
And they're really part of the
whatever in Model View whatever

00:09:49.400 --> 00:09:51.530
in terms of the
architectural patterns

00:09:51.530 --> 00:09:53.522
that you may be using
within your application.

00:09:53.522 --> 00:09:54.730
They're not Views themselves.

00:09:54.730 --> 00:09:56.188
And they're really
not meant to be.

00:09:58.680 --> 00:10:02.970
Seriously, they're not
just fancy View groups.

00:10:02.970 --> 00:10:05.480
Fragments implement UIs
just by using Views.

00:10:05.480 --> 00:10:06.700
They compose Views.

00:10:06.700 --> 00:10:08.590
They wire things up
to Views in order

00:10:08.590 --> 00:10:11.490
to do something
more interesting.

00:10:11.490 --> 00:10:14.010
And this really comes
down to a core idea

00:10:14.010 --> 00:10:16.920
that isn't communicated
all that widely

00:10:16.920 --> 00:10:20.490
that we kind of keep this idea
of an abstraction hierarchy

00:10:20.490 --> 00:10:23.470
across the different
packages in the framework.

00:10:23.470 --> 00:10:26.420
And the higher level packages
are things like android.app,

00:10:26.420 --> 00:10:29.714
whereas the Views and widgets
are further down the stack.

00:10:29.714 --> 00:10:31.380
And what this means
in practice in terms

00:10:31.380 --> 00:10:34.200
of the organization of code
within the Android framework,

00:10:34.200 --> 00:10:36.410
is that anything
at a higher level

00:10:36.410 --> 00:10:39.030
can import anything from a lower
level, but not the other way

00:10:39.030 --> 00:10:39.980
around.

00:10:39.980 --> 00:10:41.460
And if you go
looking through AOSP,

00:10:41.460 --> 00:10:44.043
you'll probably find a couple
of places where we mess this up.

00:10:44.043 --> 00:10:45.070
And yes, we know it.

00:10:45.070 --> 00:10:46.176
We're sorry.

00:10:46.176 --> 00:10:48.800
But overall, it's managed to be
a pretty good way of organizing

00:10:48.800 --> 00:10:50.216
some of this stuff
and making sure

00:10:50.216 --> 00:10:54.690
that things keep a level
of responsibility that's

00:10:54.690 --> 00:10:58.730
kind of appropriate for
that type of component.

00:10:58.730 --> 00:11:01.140
So an example of
this is that you

00:11:01.140 --> 00:11:03.070
might have a
Fragment that depends

00:11:03.070 --> 00:11:06.210
on a View
OnClickListener in order

00:11:06.210 --> 00:11:08.001
to implement that interface.

00:11:08.001 --> 00:11:09.750
This is an example of
a Fragment just kind

00:11:09.750 --> 00:11:12.665
of applying policy to a series
of Views that it's using.

00:11:15.670 --> 00:11:16.170
Come on.

00:11:19.960 --> 00:11:22.580
So while Fragments
can depend on Views,

00:11:22.580 --> 00:11:25.544
and implement the interface
as exposed by those of Views,

00:11:25.544 --> 00:11:27.460
it's important to remember
that the Views have

00:11:27.460 --> 00:11:31.070
no knowledge of Fragments, that
fragments really kind of sit

00:11:31.070 --> 00:11:33.820
as the policy layer
above whatever

00:11:33.820 --> 00:11:38.330
UI that you've built visually
and out of the structure that

00:11:38.330 --> 00:11:41.358
is used to generate input
events, so on and so forth.

00:11:44.710 --> 00:11:47.990
So really, they're kind of a
glue component in this case.

00:11:47.990 --> 00:11:50.590
They provide coordination
of these different View

00:11:50.590 --> 00:11:53.620
components, or even of other
components within your app.

00:11:53.620 --> 00:11:56.000
They allow you to wire
up the View events,

00:11:56.000 --> 00:11:59.390
the Input events that you may
be generating from those Views,

00:11:59.390 --> 00:12:03.090
and tell them something
interesting to do.

00:12:03.090 --> 00:12:05.290
And all of that ends up
being driven by a knowledge

00:12:05.290 --> 00:12:06.540
of the external lifecycle.

00:12:06.540 --> 00:12:08.490
What's going on outside the app?

00:12:08.490 --> 00:12:10.990
What's going on
outside the context

00:12:10.990 --> 00:12:12.730
of that particular
Fragment or Activity?

00:12:16.610 --> 00:12:19.270
So this is something that
others have definitely said,

00:12:19.270 --> 00:12:21.780
and I will totally echo here.

00:12:21.780 --> 00:12:24.480
Don't use a Fragment when just
a composite custom ViewGroup,

00:12:24.480 --> 00:12:26.650
or even just a layout
resource that you can use an

00:12:26.650 --> 00:12:29.700
include tag, will
do the job better.

00:12:29.700 --> 00:12:31.980
A lot of times people
use this as a point

00:12:31.980 --> 00:12:35.090
where they can pivot, where
they can decide what type of UI

00:12:35.090 --> 00:12:37.180
to show based on
other conditions.

00:12:37.180 --> 00:12:39.910
And between the resource
system and custom ViewGroups,

00:12:39.910 --> 00:12:41.660
you can solve that
problem without getting

00:12:41.660 --> 00:12:42.892
into lifecycle constructs.

00:12:46.470 --> 00:12:47.970
The real question
to ask when you're

00:12:47.970 --> 00:12:51.140
talking about using a custom
ViewGroup or a Fragment

00:12:51.140 --> 00:12:54.060
in these cases, is does
it implement mechanism

00:12:54.060 --> 00:12:56.070
or does it implement policy?

00:12:56.070 --> 00:12:59.540
Is it an isolated widget that
generates its own input events?

00:12:59.540 --> 00:13:01.762
And these might be
really complex as well.

00:13:01.762 --> 00:13:03.970
I mean, we've got some things
in more recent versions

00:13:03.970 --> 00:13:06.400
of the Support Library
like CoordinatorLayout

00:13:06.400 --> 00:13:09.250
that are able to impose
very complex behaviors

00:13:09.250 --> 00:13:11.680
on their child views,
things that you

00:13:11.680 --> 00:13:14.290
can push and pull and move
around, swipe to dismiss,

00:13:14.290 --> 00:13:15.434
so on and so forth.

00:13:15.434 --> 00:13:17.600
But all of those essentially
are still just the user

00:13:17.600 --> 00:13:19.260
acting on the UI.

00:13:19.260 --> 00:13:21.380
You might be able to
swipe a snackbar away.

00:13:21.380 --> 00:13:23.230
You might be able
to click a Apply

00:13:23.230 --> 00:13:26.180
button on a snackbar in a
CoordinatorLayout or something.

00:13:26.180 --> 00:13:28.960
But what that actually
means to the application

00:13:28.960 --> 00:13:32.240
is policy that's imposed
by some other component.

00:13:32.240 --> 00:13:34.770
And that's more where
Fragments sit in the layering.

00:13:37.740 --> 00:13:39.390
So we also can't
talk about Fragments

00:13:39.390 --> 00:13:42.090
and dealing with some of
the associated complexity

00:13:42.090 --> 00:13:44.820
without talking
about saved state.

00:13:44.820 --> 00:13:47.940
So the navigational
state of your application

00:13:47.940 --> 00:13:51.270
is partially composed by the
Fragments that are currently

00:13:51.270 --> 00:13:53.810
attached to it.

00:13:53.810 --> 00:13:55.310
These may have
changed over time.

00:13:55.310 --> 00:13:58.280
Contents may have shifted during
flight, so on and so forth,

00:13:58.280 --> 00:14:01.454
where, if you have something
like master/detail UIs, then

00:14:01.454 --> 00:14:03.620
you might have a very
different Fragment that you're

00:14:03.620 --> 00:14:07.110
showing if you were drilled
into item A versus drilled

00:14:07.110 --> 00:14:09.225
into item B in that list.

00:14:09.225 --> 00:14:10.850
And that's something
that, ideally, you

00:14:10.850 --> 00:14:12.349
don't want to have
to track yourself

00:14:12.349 --> 00:14:14.700
in terms of other state.

00:14:14.700 --> 00:14:17.322
As it gets restored,
as your process dies,

00:14:17.322 --> 00:14:19.072
you come back into it,
so on and so forth.

00:14:22.162 --> 00:14:24.370
So that means that setup of
Fragments is conditional.

00:14:24.370 --> 00:14:26.070
And this is another one of
those kind of weird things

00:14:26.070 --> 00:14:27.230
that everybody sees
when they first

00:14:27.230 --> 00:14:28.438
start working with Fragments.

00:14:28.438 --> 00:14:30.920
Well, why am I doing
this extra check

00:14:30.920 --> 00:14:33.100
here when I'm setting
up this initial state?

00:14:33.100 --> 00:14:35.250
And that's partially
because the Fragments

00:14:35.250 --> 00:14:39.630
are going to be restored as
part of that onCreate call.

00:14:39.630 --> 00:14:42.080
Now, this has historically
gotten a little bit

00:14:42.080 --> 00:14:47.170
weird in that, if you were
dealing with child fragments,

00:14:47.170 --> 00:14:49.457
when that reinflation
happens, really

00:14:49.457 --> 00:14:51.040
wasn't consistent
with the way that it

00:14:51.040 --> 00:14:54.280
happens with Fragments that
are attached to Activities.

00:14:54.280 --> 00:14:56.820
Now, over the last
several months

00:14:56.820 --> 00:15:01.710
we've really kind of dived
into the Fragment APIs

00:15:01.710 --> 00:15:03.810
and tried to clean up
a lot of these cases

00:15:03.810 --> 00:15:06.370
where the behavior was just
unexpected or inconsistent.

00:15:06.370 --> 00:15:08.661
Because these are the things
that really made everybody

00:15:08.661 --> 00:15:10.430
hate the API to start with.

00:15:10.430 --> 00:15:13.980
So as of Android N and Support
Library version 24, which

00:15:13.980 --> 00:15:16.430
is available as part of
the preview SDK right now,

00:15:16.430 --> 00:15:19.520
child fragments are, just
as with Activity-attached

00:15:19.520 --> 00:15:22.050
Fragments, they're
consistently re-inflated

00:15:22.050 --> 00:15:24.000
during the super.onCreate
call that you

00:15:24.000 --> 00:15:25.497
make within your own code.

00:15:25.497 --> 00:15:27.080
So that way, after
you make that call,

00:15:27.080 --> 00:15:29.110
you know that those
fragments that

00:15:29.110 --> 00:15:32.180
were stored from instance state
are attached to your Activity.

00:15:32.180 --> 00:15:34.490
You can do find Fragment
by tag and actually expect

00:15:34.490 --> 00:15:35.219
to find it there.

00:15:35.219 --> 00:15:36.635
You won't end up
with duplicates--

00:15:36.635 --> 00:15:37.330
[APPLAUSE]

00:15:37.330 --> 00:15:40.050
--when you try to
deal with that case.

00:15:40.050 --> 00:15:42.780
Thank you.

00:15:42.780 --> 00:15:46.046
So that alone makes things a
whole lot easier to deal with.

00:15:46.046 --> 00:15:47.920
AUDIENCE: With all the
legal state exception.

00:15:47.920 --> 00:15:48.806
ADAM POWELL: Hmm?

00:15:48.806 --> 00:15:50.680
AUDIENCE: With all the
legal state exception.

00:15:50.680 --> 00:15:52.388
ADAM POWELL: The
illegal state exception?

00:15:52.388 --> 00:15:53.030
Which one?

00:15:53.030 --> 00:15:53.990
We'll get to it in a minute.

00:15:53.990 --> 00:15:54.490
OK.

00:15:54.490 --> 00:15:55.910
[LAUGHTER]

00:15:57.350 --> 00:16:01.120
So again, we keep coming back
to this idea of Fragment states

00:16:01.120 --> 00:16:03.120
and that giant diagram.

00:16:03.120 --> 00:16:06.340
So how do we just stop worrying
and love the lifecycle here

00:16:06.340 --> 00:16:08.990
because every one of
these stages of lifecycle

00:16:08.990 --> 00:16:12.100
really does represent a
significant event that

00:16:12.100 --> 00:16:13.877
can happen to your application.

00:16:13.877 --> 00:16:15.460
And just because we
have a lot of them

00:16:15.460 --> 00:16:17.720
there doesn't necessarily mean
that you have to care about all

00:16:17.720 --> 00:16:18.610
of them all the time.

00:16:18.610 --> 00:16:20.110
A lot of Fragments
that you'll write

00:16:20.110 --> 00:16:22.150
will only implement a
couple of these methods.

00:16:22.150 --> 00:16:23.699
But just having all
the options there

00:16:23.699 --> 00:16:25.490
can be really overwhelming
when you're just

00:16:25.490 --> 00:16:26.531
looking at documentation.

00:16:29.100 --> 00:16:32.250
So that big flowch--
I couldn't tell

00:16:32.250 --> 00:16:33.820
you everything on
that big flowchart

00:16:33.820 --> 00:16:36.262
at once off the top
of my head either.

00:16:36.262 --> 00:16:38.220
But the nice part about
this is that you really

00:16:38.220 --> 00:16:41.150
don't have to hold all of
that in your head at once

00:16:41.150 --> 00:16:44.120
because even though those
interactions look very complex,

00:16:44.120 --> 00:16:48.010
really, the Fragment lifecycle
is driven by what's essentially

00:16:48.010 --> 00:16:50.250
a single integer value.

00:16:50.250 --> 00:16:53.320
So this is straight out of
the Fragment source code

00:16:53.320 --> 00:16:56.869
where we have these six states
that Fragments move between.

00:16:56.869 --> 00:16:58.410
And the nice thing
about these states

00:16:58.410 --> 00:17:01.490
is that this isn't like a
completely connected graph

00:17:01.490 --> 00:17:03.480
of states, this is linear.

00:17:03.480 --> 00:17:06.170
So when Fragments move
from one state to another,

00:17:06.170 --> 00:17:08.560
they move through all of
the other states in turn,

00:17:08.560 --> 00:17:11.200
dispatching the appropriate
methods to the Fragment

00:17:11.200 --> 00:17:14.819
to deal with those
lifecycle events.

00:17:14.819 --> 00:17:17.280
So this leads to something
really kind of convenient,

00:17:17.280 --> 00:17:19.260
which is that all you
need to think about

00:17:19.260 --> 00:17:22.900
is what invariants do I need
to enforce for my new state?

00:17:22.900 --> 00:17:25.020
You can keep your thinking
very much constrained

00:17:25.020 --> 00:17:27.849
to each one of these
individual lifecycle methods

00:17:27.849 --> 00:17:29.990
so that you don't have
to worry about the state

00:17:29.990 --> 00:17:32.620
of the entire
application in aggregate

00:17:32.620 --> 00:17:36.190
when you're dealing with this.

00:17:36.190 --> 00:17:38.890
More importantly, you can
say, what minimum state

00:17:38.890 --> 00:17:40.400
will this component be in?

00:17:40.400 --> 00:17:41.660
Or what can I count on?

00:17:41.660 --> 00:17:44.165
Since again, the fragment
states are linear.

00:17:44.165 --> 00:17:45.540
So if you know
that you're up all

00:17:45.540 --> 00:17:46.914
the way at the
resumed state, you

00:17:46.914 --> 00:17:49.260
know that you've been through
all of the other methods.

00:17:49.260 --> 00:17:51.100
And this is one of those
things that kind of

00:17:51.100 --> 00:17:52.910
seems obvious in hindsight.

00:17:52.910 --> 00:17:55.730
But again, as you're looking
through the smorgasbord

00:17:55.730 --> 00:17:59.620
of methods that you can
override on Fragment itself,

00:17:59.620 --> 00:18:01.800
sometimes this kind of
gets lost in the noise.

00:18:05.980 --> 00:18:08.220
So let's go ahead and talk
about a few other things.

00:18:08.220 --> 00:18:11.990
We talked about one bug fix
that was pretty significant,

00:18:11.990 --> 00:18:13.870
which is that the
child FragmentManager

00:18:13.870 --> 00:18:16.936
state is guaranteed after
the super.onCreate call.

00:18:16.936 --> 00:18:18.560
Now, this is subtly
different from what

00:18:18.560 --> 00:18:22.840
I said earlier about restoring
Fragments from instant state

00:18:22.840 --> 00:18:26.380
because there was this really
kind of a fun bug that happens.

00:18:26.380 --> 00:18:29.132
So how many of you use
executePendingTransactions

00:18:29.132 --> 00:18:30.840
for some part of your
work with Fragments

00:18:30.840 --> 00:18:32.410
or have tried in the past?

00:18:32.410 --> 00:18:32.910
OK.

00:18:32.910 --> 00:18:34.310
Keep your hand up
if you ended up

00:18:34.310 --> 00:18:37.440
regretting doing that during
a debugging session later.

00:18:37.440 --> 00:18:37.940
OK.

00:18:37.940 --> 00:18:38.440
Yeah.

00:18:38.440 --> 00:18:41.070
That's a pretty close
match for some of that.

00:18:41.070 --> 00:18:44.770
So executePendingTransactions
is this really handy method

00:18:44.770 --> 00:18:47.412
on the FragmentManager
that tells it, OK,

00:18:47.412 --> 00:18:49.120
all of those things
that you've queued up

00:18:49.120 --> 00:18:52.580
with FragmentTransaction.commit,
do all of them

00:18:52.580 --> 00:18:55.430
right now, all of them
that you've got pending.

00:18:55.430 --> 00:18:58.260
And that's got a couple
of interesting issues

00:18:58.260 --> 00:19:00.810
with it that we'll
get into in a minute.

00:19:00.810 --> 00:19:03.400
But one of the interesting
things about that

00:19:03.400 --> 00:19:07.120
is that you have
expectations after that call.

00:19:07.120 --> 00:19:09.950
Specifically, if you've
committed one or more Fragment

00:19:09.950 --> 00:19:12.320
transactions before
that, then you

00:19:12.320 --> 00:19:14.450
expect those
Fragments that you've

00:19:14.450 --> 00:19:16.450
committed in that
transaction to be brought up

00:19:16.450 --> 00:19:18.550
to a particular state
in the lifecycle,

00:19:18.550 --> 00:19:20.862
usually matching the container.

00:19:20.862 --> 00:19:22.320
Well, it turns out
that that wasn't

00:19:22.320 --> 00:19:23.730
actually how things worked.

00:19:23.730 --> 00:19:25.940
Some of you probably
found this out.

00:19:25.940 --> 00:19:28.270
And this, again, came
down to this idea of what

00:19:28.270 --> 00:19:29.860
happens with child fragments.

00:19:29.860 --> 00:19:33.370
And you're probably noticing
a bit of a theme here.

00:19:33.370 --> 00:19:38.740
So what would happen instead is
that the child fragment manager

00:19:38.740 --> 00:19:42.080
itself wouldn't be brought
up to the new state

00:19:42.080 --> 00:19:46.490
until long after the
parents onCreate returned.

00:19:46.490 --> 00:19:49.410
So all of these invariants
that should make it a lot more

00:19:49.410 --> 00:19:52.390
easy to reason
about your program,

00:19:52.390 --> 00:19:55.710
especially when you're saying
that, hey, resolve everything

00:19:55.710 --> 00:19:57.590
right now,
executePendingTransactions,

00:19:57.590 --> 00:19:59.590
well, all that just kind
of went out the window.

00:19:59.590 --> 00:20:03.220
So that made things a lot more
difficult. That's now fixed.

00:20:03.220 --> 00:20:05.070
So again, you know
that you don't

00:20:05.070 --> 00:20:08.990
have to worry about that after
the call the super.onCreate.

00:20:08.990 --> 00:20:12.700
So executePendingTransactions
had another kind of problem

00:20:12.700 --> 00:20:17.330
as well, which was that it makes
everything happen right now.

00:20:17.330 --> 00:20:20.040
And the issue with that is that
different parts of your program

00:20:20.040 --> 00:20:22.080
might be committing
Fragment transactions

00:20:22.080 --> 00:20:23.840
at different times.

00:20:23.840 --> 00:20:26.370
So as soon as you say
executePendingTransaction

00:20:26.370 --> 00:20:29.010
in one piece, you may have
just caused a side effect

00:20:29.010 --> 00:20:31.260
to that effects
some other library

00:20:31.260 --> 00:20:33.060
that you imported
that uses Fragments,

00:20:33.060 --> 00:20:35.640
and you didn't
even know about it.

00:20:35.640 --> 00:20:38.650
So we went ahead and we
added a commitNow method

00:20:38.650 --> 00:20:40.990
to FragmentTransaction,
which basically

00:20:40.990 --> 00:20:42.540
does the same thing,
but really kind

00:20:42.540 --> 00:20:44.250
of what you wanted
instead, which is, no,

00:20:44.250 --> 00:20:45.520
just this transaction.

00:20:45.520 --> 00:20:47.850
Commit this one right now.

00:20:47.850 --> 00:20:50.830
This does have one
particular limitation, which

00:20:50.830 --> 00:20:53.560
is that you can't deal with
Fragments on the back stack

00:20:53.560 --> 00:20:56.330
if you use commitNow,
just because if you have

00:20:56.330 --> 00:20:58.510
other Fragment
transactions pending,

00:20:58.510 --> 00:21:01.510
you don't want to create
inversions in your back stack

00:21:01.510 --> 00:21:03.011
in terms of when
those really apply.

00:21:06.430 --> 00:21:09.210
We also added a Fragment
onAttachFragment method

00:21:09.210 --> 00:21:12.630
to match the Fragment Activity
and Activity onAttachFragment

00:21:12.630 --> 00:21:13.430
method.

00:21:13.430 --> 00:21:14.930
This is kind of
useful when you want

00:21:14.930 --> 00:21:17.030
to go ahead and configure
a Fragment as it's

00:21:17.030 --> 00:21:18.700
being attached to its parent.

00:21:18.700 --> 00:21:21.140
If you want to do any sort
of injection of dependencies,

00:21:21.140 --> 00:21:26.110
if you want to do any sort
of wiring up of listeners

00:21:26.110 --> 00:21:27.952
within that local
Activity for other events

00:21:27.952 --> 00:21:30.410
that it might publish, this is
a pretty good time to do it,

00:21:30.410 --> 00:21:32.034
except there really
wasn't a good place

00:21:32.034 --> 00:21:34.620
to do this with child
fragments before.

00:21:34.620 --> 00:21:36.634
This was something that
was entirely skipped.

00:21:36.634 --> 00:21:38.550
You couldn't even do it
in the parent Activity

00:21:38.550 --> 00:21:41.133
if you wanted to because it was
only ever called on the parent

00:21:41.133 --> 00:21:45.502
Activity if and only if the
Fragment was attached directly

00:21:45.502 --> 00:21:47.210
to the Activity, not
any of the children.

00:21:51.950 --> 00:21:55.010
So a few other notes that
are kind of useful here.

00:21:55.010 --> 00:21:58.010
This is one that some developers
ran into fairly recently

00:21:58.010 --> 00:22:01.510
as we fixed some other bugs
around Fragment transitions,

00:22:01.510 --> 00:22:06.700
which is that to obtain the
state of a Fragment transition,

00:22:06.700 --> 00:22:08.200
we have to interrogate
the Fragment.

00:22:08.200 --> 00:22:09.866
We have to call a
method on the Fragment

00:22:09.866 --> 00:22:13.080
to get the transition values
and what it should do.

00:22:13.080 --> 00:22:15.790
But in order to make that
make sense to that Fragment,

00:22:15.790 --> 00:22:17.998
we have to bring the Fragment
up to the created state

00:22:17.998 --> 00:22:20.320
before we ask it
about the transition.

00:22:20.320 --> 00:22:23.060
So what that means,
in effect, is

00:22:23.060 --> 00:22:25.570
that we have to bring some
Fragments up to the created

00:22:25.570 --> 00:22:27.327
state before they
become fully attached,

00:22:27.327 --> 00:22:29.410
or before they replace
whatever Fragment that they

00:22:29.410 --> 00:22:31.160
were replacing before.

00:22:31.160 --> 00:22:34.199
So this is one of those things
that's good to be aware of.

00:22:34.199 --> 00:22:36.240
Don't assume that just
because your Fragment goes

00:22:36.240 --> 00:22:38.440
through the attach
and create steps

00:22:38.440 --> 00:22:40.180
that all of the
other surrounding

00:22:40.180 --> 00:22:41.900
state about a
FragmentTransaction

00:22:41.900 --> 00:22:43.805
has necessarily happened yet.

00:22:43.805 --> 00:22:45.180
Again, this is
something that you

00:22:45.180 --> 00:22:47.804
want to make sure that you keep
your thinking within a Fragment

00:22:47.804 --> 00:22:50.354
implementation scoped
just to that Fragment.

00:22:50.354 --> 00:22:52.770
Make sure that it's not trying
to take on responsibilities

00:22:52.770 --> 00:22:53.535
outside of itself.

00:22:56.700 --> 00:22:59.000
And again, they
really work best when

00:22:59.000 --> 00:23:01.922
they can behave as isolated
from their surroundings.

00:23:01.922 --> 00:23:03.380
One of the things
that I see people

00:23:03.380 --> 00:23:06.500
do a lot is that when a
Fragment becomes attached,

00:23:06.500 --> 00:23:09.440
and again, just because
you have problems

00:23:09.440 --> 00:23:12.344
with state restoration
of more complex objects,

00:23:12.344 --> 00:23:14.510
it's pretty common for
people to say, OK, well, when

00:23:14.510 --> 00:23:16.500
I get attached to
my Activity, I'm

00:23:16.500 --> 00:23:19.430
going to go ahead, grab the
Activity, and go fishing.

00:23:19.430 --> 00:23:21.550
I'll go ahead and
check out if I can

00:23:21.550 --> 00:23:26.370
find other Fragments, other
sibling Fragments by tag,

00:23:26.370 --> 00:23:28.420
grab any other sort of
associated information

00:23:28.420 --> 00:23:30.760
from that Activity, down
cast it to a specific type,

00:23:30.760 --> 00:23:32.510
so on and so forth.

00:23:32.510 --> 00:23:34.879
And while this ends up
being pretty convenient,

00:23:34.879 --> 00:23:36.670
it also means that
those Fragments suddenly

00:23:36.670 --> 00:23:39.190
become a whole lot less
reusable elsewhere.

00:23:39.190 --> 00:23:42.584
And while you may not care about
that right from the outset,

00:23:42.584 --> 00:23:45.000
it is one of those things that
tends to come back and bite

00:23:45.000 --> 00:23:45.891
people later on.

00:23:45.891 --> 00:23:48.390
And then they wonder, why didn't
we have some other facility

00:23:48.390 --> 00:23:51.365
to do this, to do a cleaner
injection of the dependencies,

00:23:51.365 --> 00:23:52.570
so on and so forth.

00:23:56.780 --> 00:23:58.940
So that was a lot of
information really fast.

00:23:58.940 --> 00:24:00.491
And some of it
probably didn't answer

00:24:00.491 --> 00:24:01.990
a lot of the core
questions that you

00:24:01.990 --> 00:24:05.560
may have had coming in here,
which is, I really don't

00:24:05.560 --> 00:24:07.110
like this API that I've used.

00:24:07.110 --> 00:24:09.310
Why should-- like,
change my mind.

00:24:09.310 --> 00:24:11.460
Why should I go back and
give it another chance?

00:24:14.777 --> 00:24:16.610
And really, the core
issue here is that apps

00:24:16.610 --> 00:24:18.460
aren't getting any smaller.

00:24:18.460 --> 00:24:22.420
So when you start working,
especially across a large teams

00:24:22.420 --> 00:24:26.570
and across code bases that have
lasted for a very long time,

00:24:26.570 --> 00:24:28.792
architectural patterns don't
end up being universal.

00:24:28.792 --> 00:24:30.250
And this is part
of what Dianne was

00:24:30.250 --> 00:24:33.500
trying to get to in her post
over this weekend as well.

00:24:33.500 --> 00:24:35.500
If you have a very
long-lived code base,

00:24:35.500 --> 00:24:38.710
then what was popular and
the obvious way that everyone

00:24:38.710 --> 00:24:41.730
should build their apps back
when the code base was started,

00:24:41.730 --> 00:24:44.800
isn't necessarily true when
you're maintaining it years

00:24:44.800 --> 00:24:45.526
down the road.

00:24:48.620 --> 00:24:52.460
So one solution to that
is to try to create

00:24:52.460 --> 00:24:55.180
standard, smarter components.

00:24:55.180 --> 00:24:58.010
So how many of you have
taken a look at integration

00:24:58.010 --> 00:24:59.800
steps for some
library for Android,

00:24:59.800 --> 00:25:01.210
and you see something that
looks kind of like what's

00:25:01.210 --> 00:25:02.380
on the slide here?

00:25:02.380 --> 00:25:04.680
OK go ahead and add this
snippet to your onCreate,

00:25:04.680 --> 00:25:06.914
this other thing to your
OnStart, this one onStop.

00:25:06.914 --> 00:25:09.330
I'm pretty sure that some of
our own libraries from Google

00:25:09.330 --> 00:25:11.404
have these types of
instructions as well,

00:25:11.404 --> 00:25:13.570
things where you need to
call some particular method

00:25:13.570 --> 00:25:15.572
from some part of
your lifecycle.

00:25:15.572 --> 00:25:17.780
And really, that just makes
these integrations really

00:25:17.780 --> 00:25:18.430
kind of messy.

00:25:21.470 --> 00:25:24.070
So instead of that,
well, we could just have,

00:25:24.070 --> 00:25:25.880
well, add this Fragment instead.

00:25:25.880 --> 00:25:29.369
And we'll go ahead and take care
of those extra lifecycle steps.

00:25:29.369 --> 00:25:31.910
And that suddenly makes it a
lot more reusable and a lot less

00:25:31.910 --> 00:25:33.530
error-prone.

00:25:33.530 --> 00:25:36.240
And the nice thing
about this is really

00:25:36.240 --> 00:25:39.920
that-- or even better, you can
just use one of these tags.

00:25:39.920 --> 00:25:44.810
I mean, even though we had
issues around general education

00:25:44.810 --> 00:25:47.300
around Fragments on
what they can do,

00:25:47.300 --> 00:25:49.250
it's really powerful
to be able to say,

00:25:49.250 --> 00:25:50.250
here's a piece of my UI.

00:25:50.250 --> 00:25:52.460
I just want to drop this
completely self-contained

00:25:52.460 --> 00:25:54.910
component here, and
then not think about it,

00:25:54.910 --> 00:25:57.580
to be able to just configure
it, possibly from other XML

00:25:57.580 --> 00:26:01.560
attributes as specified
there, and then just let

00:26:01.560 --> 00:26:03.040
that component do its thing.

00:26:06.120 --> 00:26:08.696
So the idea here is to
really try and provide

00:26:08.696 --> 00:26:10.570
these single points of
high-level integration

00:26:10.570 --> 00:26:11.700
that everyone can use.

00:26:11.700 --> 00:26:13.860
And that last part
is really key.

00:26:13.860 --> 00:26:15.390
Again, not everyone
is going to be

00:26:15.390 --> 00:26:17.800
using the same architectural
patterns that your app does.

00:26:17.800 --> 00:26:19.700
And your own app may
not use those patterns

00:26:19.700 --> 00:26:21.530
the same way over time either.

00:26:21.530 --> 00:26:23.870
But Fragments are kind of
uniquely positioned here.

00:26:23.870 --> 00:26:26.790
And that's because Fragments
really closely mirror

00:26:26.790 --> 00:26:28.050
that Activity lifecycle.

00:26:28.050 --> 00:26:29.910
There are a few
differences here and there,

00:26:29.910 --> 00:26:32.790
but by and large, as you're
thinking about invariance

00:26:32.790 --> 00:26:34.730
to enforce within a
Fragment, they really

00:26:34.730 --> 00:26:36.450
match what you do
with Activities

00:26:36.450 --> 00:26:40.382
as part of that core entry point
idea for Android components.

00:26:40.382 --> 00:26:41.840
So that means that
essentially they

00:26:41.840 --> 00:26:44.410
can sit below that
level of abstraction

00:26:44.410 --> 00:26:45.930
of your higher-level
architecture

00:26:45.930 --> 00:26:48.090
that you impose upon
your application.

00:26:48.090 --> 00:26:50.620
And that makes them reusable
as components in the same way

00:26:50.620 --> 00:26:52.266
that Views are
reusable to Fragments.

00:26:55.760 --> 00:26:57.377
So when Fragments
are communicating

00:26:57.377 --> 00:26:58.960
with the rest of the
world, you really

00:26:58.960 --> 00:27:01.450
need to be careful about
the types of configuration

00:27:01.450 --> 00:27:04.840
dependencies that
you end up creating.

00:27:04.840 --> 00:27:08.050
Again, this comes
down to that issue of,

00:27:08.050 --> 00:27:10.410
are you going fishing
in your parent activity,

00:27:10.410 --> 00:27:12.570
or in your parent
Fragment for that matter,

00:27:12.570 --> 00:27:13.610
for other dependencies?

00:27:13.610 --> 00:27:15.362
And is that Fragment
going to blow up

00:27:15.362 --> 00:27:16.570
if those things aren't there?

00:27:16.570 --> 00:27:18.060
Are those dependencies
documented?

00:27:18.060 --> 00:27:20.610
How is someone who's using
that Fragment necessarily going

00:27:20.610 --> 00:27:22.920
to know that that's
a requirement?

00:27:22.920 --> 00:27:25.600
Now, in a code base
within a particular team,

00:27:25.600 --> 00:27:27.050
again, this may
not be a problem.

00:27:27.050 --> 00:27:29.946
But as things grow
over time, we tend

00:27:29.946 --> 00:27:31.570
to see a lot of these
patterns show up.

00:27:35.255 --> 00:27:36.630
And that means
that you really do

00:27:36.630 --> 00:27:38.296
need to consider your
audience as you're

00:27:38.296 --> 00:27:39.580
building these things.

00:27:39.580 --> 00:27:41.970
If you're building
libraries, the answer to this

00:27:41.970 --> 00:27:43.640
is going to be a
lot different from

00:27:43.640 --> 00:27:45.223
if you're just
building another screen

00:27:45.223 --> 00:27:46.670
within your own application.

00:27:46.670 --> 00:27:49.440
In your own application, sure,
go ahead and take a dependency

00:27:49.440 --> 00:27:52.130
on some internal component.

00:27:52.130 --> 00:27:53.967
I mean, it might help.

00:27:53.967 --> 00:27:54.550
It might hurt.

00:27:54.550 --> 00:27:57.330
But at the very least,
you're not passing this out

00:27:57.330 --> 00:27:58.871
to the rest of the wider world.

00:28:01.520 --> 00:28:04.190
And also, if you are
offering the ability

00:28:04.190 --> 00:28:07.770
to use Fragments that are these
standalone drop-in components,

00:28:07.770 --> 00:28:11.440
the onInflate method is sorely
underused in some of these.

00:28:11.440 --> 00:28:14.000
So this lets you do the same
thing that you do with Views,

00:28:14.000 --> 00:28:16.450
specify some
configuration attributes.

00:28:16.450 --> 00:28:18.380
It might be something
like an API key.

00:28:18.380 --> 00:28:21.560
It might be something like
any other sort of information

00:28:21.560 --> 00:28:23.869
that you need to pass to
that Fragment as arguments.

00:28:23.869 --> 00:28:26.160
But you can do it without
having to muck around with it

00:28:26.160 --> 00:28:29.370
and code necessarily
during that initial startup

00:28:29.370 --> 00:28:30.630
phase of your application.

00:28:30.630 --> 00:28:33.200
Because again, you want to
try to have one integration

00:28:33.200 --> 00:28:34.209
point with these things.

00:28:34.209 --> 00:28:35.250
Thank you all for coming.

00:28:35.250 --> 00:28:35.750
[APPLAUSE]

00:28:35.750 --> 00:28:37.050
Thank you.

00:28:37.050 --> 00:28:40.400
[MUSIC PLAYING]

