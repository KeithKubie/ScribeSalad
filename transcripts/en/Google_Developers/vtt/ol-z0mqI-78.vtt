WEBVTT
Kind: captions
Language: en

00:00:02.155 --> 00:00:03.220
YIWEN ZHAN: Hello?

00:00:03.220 --> 00:00:04.170
Hello, everyone.

00:00:04.170 --> 00:00:05.380
FABRICE DIMEGLIO:
Hello, everyone.

00:00:05.380 --> 00:00:07.450
YIWEN ZHAN: My name is Yiwen,
and I'm product manager on the

00:00:07.450 --> 00:00:10.140
internationalization team
here at Google.

00:00:10.140 --> 00:00:10.930
FABRICE DIMEGLIO: My name
is Fabrice DiMeglio.

00:00:10.930 --> 00:00:13.840
And I'm working in the Android
formatting, focusing on UI and

00:00:13.840 --> 00:00:15.800
right-to-left support.

00:00:15.800 --> 00:00:17.030
YIWEN ZHAN: And today we're
here to give you a

00:00:17.030 --> 00:00:18.730
walk-through of how to build
your Android apps

00:00:18.730 --> 00:00:20.400
for a global audience.

00:00:20.400 --> 00:00:21.890
Now before we start,
I had a few

00:00:21.890 --> 00:00:23.530
questions for the audience.

00:00:23.530 --> 00:00:25.840
How many of you already have
your apps available in a

00:00:25.840 --> 00:00:28.140
language other than English?

00:00:28.140 --> 00:00:29.820
OK, wow, that's pretty good.

00:00:29.820 --> 00:00:31.410
How many of you have your
app available on

00:00:31.410 --> 00:00:33.650
more than five languages?

00:00:33.650 --> 00:00:34.740
That's great.

00:00:34.740 --> 00:00:36.710
What about right-to-left
languages?

00:00:36.710 --> 00:00:38.410
Has anyone targeted those yet?

00:00:38.410 --> 00:00:40.890
Wow, I'm really impressed.

00:00:40.890 --> 00:00:43.920
Now how many of you are
interested in expanding your

00:00:43.920 --> 00:00:46.550
app into a more global
audience?

00:00:46.550 --> 00:00:48.780
OK, given that you're all at
this talk, you should all be

00:00:48.780 --> 00:00:51.340
raising your hand here.

00:00:51.340 --> 00:00:54.590
As you can see from this quick
survey, everyone is interested

00:00:54.590 --> 00:00:56.240
in internationalizing
their app.

00:00:56.240 --> 00:00:58.540
But the process of
internationalization can be a

00:00:58.540 --> 00:00:59.580
bit daunting.

00:00:59.580 --> 00:01:02.040
And today we're here to teach
you some tips and show you

00:01:02.040 --> 00:01:06.410
some tools that make this
process a little easier.

00:01:06.410 --> 00:01:08.790
But first, let's take a look
at why it's important.

00:01:08.790 --> 00:01:11.320
Android has a lot of global
momentum going for it.

00:01:11.320 --> 00:01:13.750
More than 900 million
Android devices

00:01:13.750 --> 00:01:15.080
are activated worldwide.

00:01:15.080 --> 00:01:19.760
And every single day 1.5 million
new Android devices

00:01:19.760 --> 00:01:21.330
are being activated.

00:01:21.330 --> 00:01:24.420
In total, over 48 billion apps
have been downloaded from the

00:01:24.420 --> 00:01:27.580
Google Play in over
190 countries.

00:01:27.580 --> 00:01:30.830
That's a lot of users, a lot
of them international.

00:01:30.830 --> 00:01:33.650
Now if your app were only
available in English, how much

00:01:33.650 --> 00:01:37.500
of this user base do you think
you've tapped into?

00:01:37.500 --> 00:01:40.540
Here's a pie chart of the
internet users in the world,

00:01:40.540 --> 00:01:41.550
grouped by language.

00:01:41.550 --> 00:01:43.970
And as you can see here, English
speakers make up

00:01:43.970 --> 00:01:47.590
approximately a quarter of the
world's internet user base.

00:01:47.590 --> 00:01:50.620
To reach the remaining 3/4 of
the world's internet users,

00:01:50.620 --> 00:01:54.830
you're going to have to
make your app global.

00:01:54.830 --> 00:01:56.940
So some of you might be
wondering, what exactly does

00:01:56.940 --> 00:01:58.770
it take to make an app global?

00:01:58.770 --> 00:02:01.600
Well, on the left, I have the
Google I/O app in English.

00:02:01.600 --> 00:02:04.680
And if I want to release the
Google I/O app in all the

00:02:04.680 --> 00:02:07.160
other languages that I wanted
to, I can do so in three

00:02:07.160 --> 00:02:08.250
simple steps--

00:02:08.250 --> 00:02:11.730
preparing, translating,
and testing.

00:02:11.730 --> 00:02:15.490
Preparing involves thinking
about which languages you want

00:02:15.490 --> 00:02:18.040
to expand into and updating
your code so that is

00:02:18.040 --> 00:02:19.930
internationally friendly.

00:02:19.930 --> 00:02:22.790
Translating involves finding
translators well versed in app

00:02:22.790 --> 00:02:23.630
translation.

00:02:23.630 --> 00:02:26.160
And we'll show you some tools
that make this easier.

00:02:26.160 --> 00:02:27.530
And lastly, is testing.

00:02:27.530 --> 00:02:29.640
After you get back your
translations, your need to

00:02:29.640 --> 00:02:31.380
test them before you
launch your app.

00:02:31.380 --> 00:02:34.220
We'll also show you some tools
to make this easier.

00:02:34.220 --> 00:02:37.290
So the rest of this talk will
be a deep dive on each of

00:02:37.290 --> 00:02:38.540
these three sections.

00:02:40.940 --> 00:02:43.190
First, you'll have to
think about strategy

00:02:43.190 --> 00:02:44.460
for language expansion.

00:02:44.460 --> 00:02:46.920
Which languages do you
want to target first?

00:02:46.920 --> 00:02:48.710
There's a few ways you
could do this.

00:02:48.710 --> 00:02:50.190
One is by metrics.

00:02:50.190 --> 00:02:52.460
You can look at metrics, such as
the top languages that are

00:02:52.460 --> 00:02:55.290
being used on the web today, or
maybe metrics specific to

00:02:55.290 --> 00:02:58.030
the category your app is in, to
figure out which languages

00:02:58.030 --> 00:03:00.810
make sense to expand
into first.

00:03:00.810 --> 00:03:02.700
Another way is by
language groups.

00:03:02.700 --> 00:03:04.010
Some language groups
are easier to

00:03:04.010 --> 00:03:05.700
localize into than others.

00:03:05.700 --> 00:03:07.910
So if your app is in English,
it might be a good idea to

00:03:07.910 --> 00:03:11.440
start off with other languages
in Latin script, such as

00:03:11.440 --> 00:03:13.290
Spanish, French, or German.

00:03:15.960 --> 00:03:17.760
Now we've been using
a few terms here--

00:03:17.760 --> 00:03:20.130
internationalization
and localization.

00:03:20.130 --> 00:03:22.360
What do those mean?

00:03:22.360 --> 00:03:24.620
Internationalization is
designing an app such that

00:03:24.620 --> 00:03:27.470
it's adaptable for various
languages and cultures.

00:03:27.470 --> 00:03:30.930
For example, if you were to
design a layout that works

00:03:30.930 --> 00:03:33.930
across all languages and
cultures, that's an example of

00:03:33.930 --> 00:03:35.500
internationalization.

00:03:35.500 --> 00:03:37.530
It's sort of like a
one-size-fits-all solution for

00:03:37.530 --> 00:03:40.430
the next piece, localization.

00:03:40.430 --> 00:03:43.300
Localization is the actual
adaptation of your app into a

00:03:43.300 --> 00:03:45.330
specific language and culture.

00:03:45.330 --> 00:03:47.730
For example, if you want to
launch your app in France,

00:03:47.730 --> 00:03:50.220
you'd have to translate your
UI strings into French, and

00:03:50.220 --> 00:03:52.840
maybe add some local flavor,
such as French holidays.

00:03:52.840 --> 00:03:55.330
That's an example
of localization.

00:03:55.330 --> 00:03:58.340
Internationalization, as you
might have noticed can be a

00:03:58.340 --> 00:03:59.300
mouthful to say.

00:03:59.300 --> 00:04:02.240
So it's commonly referenced as
I18N, which we simply means

00:04:02.240 --> 00:04:04.290
there's 18 letters between
I and the N in

00:04:04.290 --> 00:04:05.960
internationalization.

00:04:05.960 --> 00:04:08.310
Now this reference also
translates over to

00:04:08.310 --> 00:04:14.620
localization, which is commonly
referenced as L10N.

00:04:14.620 --> 00:04:16.190
So that's it for the overview.

00:04:16.190 --> 00:04:17.750
Now we're going to take
a deep dive on how to

00:04:17.750 --> 00:04:19.360
prepare your app.

00:04:19.360 --> 00:04:21.740
When your app is available in
one native language, such as

00:04:21.740 --> 00:04:24.670
English, a lot of things you do
in that language might not

00:04:24.670 --> 00:04:27.420
necessarily work when you
try to internationalize.

00:04:27.420 --> 00:04:30.310
And now we'll give you some
examples of this and teach you

00:04:30.310 --> 00:04:35.430
how to make your app so that's
more internationally friendly.

00:04:35.430 --> 00:04:38.130
The first and one of the most
important things to do is to

00:04:38.130 --> 00:04:40.170
design a single flexible
layout--

00:04:40.170 --> 00:04:42.710
a layout that works across
all locales.

00:04:42.710 --> 00:04:45.520
A common pitfall of developers
is to design a layout that's

00:04:45.520 --> 00:04:47.740
pixel perfect for the native
language that they're

00:04:47.740 --> 00:04:48.790
programming in.

00:04:48.790 --> 00:04:51.060
And when they go to
internationalize their app,

00:04:51.060 --> 00:04:54.850
realize that the layout starts
breaking across languages.

00:04:54.850 --> 00:04:57.460
As you can see from this example
here, a string of text

00:04:57.460 --> 00:05:01.000
translated from English into
German and Japanese cause the

00:05:01.000 --> 00:05:03.810
text to vary a lot in both
length and width.

00:05:03.810 --> 00:05:07.230
German language is a language
that's commonly known for

00:05:07.230 --> 00:05:09.560
very, very long message
strings.

00:05:09.560 --> 00:05:12.100
And Japanese, along with
languages such as Chinese and

00:05:12.100 --> 00:05:14.470
Korean, are known for
being very short.

00:05:14.470 --> 00:05:16.620
So you have to keep this in
mind and design a layout

00:05:16.620 --> 00:05:17.850
that's really generous
and works

00:05:17.850 --> 00:05:19.100
across different languages.

00:05:21.400 --> 00:05:24.260
Now the next few pieces of our
tips are a bit more technical.

00:05:24.260 --> 00:05:26.280
So let's start with
a snippet of code.

00:05:26.280 --> 00:05:28.760
Say I'm building an Android
app that's just a virtual

00:05:28.760 --> 00:05:31.080
Android store that sells
Android dolls.

00:05:31.080 --> 00:05:34.260
And here is a method in my code
that displays the number

00:05:34.260 --> 00:05:37.950
of Android dolls sold
on a given date.

00:05:37.950 --> 00:05:41.190
So while this method works
really well in English, it

00:05:41.190 --> 00:05:42.420
might not work well you
when you try to

00:05:42.420 --> 00:05:43.960
internationalize your app.

00:05:43.960 --> 00:05:45.930
Let's take a look at each
of the problems, and how

00:05:45.930 --> 00:05:47.940
we could fix them.

00:05:47.940 --> 00:05:49.780
Well, the first problem you
might encounter is the

00:05:49.780 --> 00:05:52.780
question, how do you get these
strings to a translator, if

00:05:52.780 --> 00:05:55.480
they're hardcoded
into your code?

00:05:55.480 --> 00:05:58.760
Hardcoding strings into the
application itself is a big

00:05:58.760 --> 00:06:00.850
no-no, when it comes
internationalization.

00:06:00.850 --> 00:06:03.040
Not only does this make it hard
for you to manage and

00:06:03.040 --> 00:06:05.500
organize your strings, it makes
it nearly impossible for

00:06:05.500 --> 00:06:07.100
the translator to find them.

00:06:07.100 --> 00:06:09.180
You can either give your
translator all of your code

00:06:09.180 --> 00:06:10.220
and have them dig through it.

00:06:10.220 --> 00:06:12.950
Or you can manually take them
out, give them to a

00:06:12.950 --> 00:06:14.760
translator, then manually
put them back in for

00:06:14.760 --> 00:06:16.030
every single language.

00:06:16.030 --> 00:06:17.310
That's a lot of work.

00:06:17.310 --> 00:06:20.260
So what should you
be doing instead?

00:06:20.260 --> 00:06:22.950
You should use a strings.xml
file, which is located under

00:06:22.950 --> 00:06:26.020
the res/values directory
of your application.

00:06:26.020 --> 00:06:28.620
In here, you can list out all of
the strings that are being

00:06:28.620 --> 00:06:30.870
used in your application.

00:06:30.870 --> 00:06:34.060
And back inside your code, you
can use the getString method,

00:06:34.060 --> 00:06:37.250
along with R.string.name
to pull that message

00:06:37.250 --> 00:06:40.570
back into your code.

00:06:40.570 --> 00:06:42.510
So now you have a strings.xml
file.

00:06:42.510 --> 00:06:44.640
And you can easily send this
off to a translator for

00:06:44.640 --> 00:06:45.830
translation.

00:06:45.830 --> 00:06:47.300
But what else could
be wrong here?

00:06:47.300 --> 00:06:49.890
Well, to the translator,
some of these things

00:06:49.890 --> 00:06:50.700
make a lot of sense.

00:06:50.700 --> 00:06:52.510
And they'll probably know
how to translate them.

00:06:52.510 --> 00:06:55.010
But what about some of the
shorter strings, such as the

00:06:55.010 --> 00:06:56.220
word, account?

00:06:56.220 --> 00:06:58.750
The account to a translator
could mean bank account or

00:06:58.750 --> 00:06:59.970
maybe user account.

00:06:59.970 --> 00:07:02.620
And maybe these two words can
translate to different things

00:07:02.620 --> 00:07:04.450
across different languages.

00:07:04.450 --> 00:07:08.300
So in order for the translator
to translate with high

00:07:08.300 --> 00:07:10.870
quality, you'll have to provide
a bit more context for

00:07:10.870 --> 00:07:13.406
your strings.xml.

00:07:13.406 --> 00:07:17.765
The easiest way to do this is to
provide comments about each

00:07:17.765 --> 00:07:19.610
string in your strings.xml.

00:07:19.610 --> 00:07:22.010
This comment can include
information such as the

00:07:22.010 --> 00:07:25.030
background for that string, any
trademarks or terminology

00:07:25.030 --> 00:07:28.500
you think the translator might
not understand, or if this

00:07:28.500 --> 00:07:30.380
piece of string belongs to
a restrictive part of the

00:07:30.380 --> 00:07:33.360
layout, such as a button, adding
in a character limit so

00:07:33.360 --> 00:07:35.790
that the translator
can abide by that

00:07:35.790 --> 00:07:37.840
Other ways is to provide
context are to send

00:07:37.840 --> 00:07:40.440
translators screenshots of your
app, or if your app is

00:07:40.440 --> 00:07:43.550
already available in Google
Play, sending them a link so

00:07:43.550 --> 00:07:46.800
they can download and try
it out for themselves.

00:07:46.800 --> 00:07:49.100
So now the translator has
a bit more context.

00:07:49.100 --> 00:07:52.520
What else in this piece of
code can confuse them?

00:07:52.520 --> 00:07:56.660
Well, let's take a look at
this piece of text, %1$d.

00:07:56.660 --> 00:07:59.120
To you, this is pretty obvious
that it's a parameter.

00:07:59.120 --> 00:08:00.800
But what does it mean
to a translator?

00:08:00.800 --> 00:08:02.640
It looks like absolute
gibberish to them.

00:08:02.640 --> 00:08:04.180
And what if they tried
to translate it?

00:08:04.180 --> 00:08:07.730
It would break your code, which
would be pretty bad.

00:08:07.730 --> 00:08:09.980
What you should do here is wrap
all your parameters in

00:08:09.980 --> 00:08:11.580
xliff placeholders.

00:08:11.580 --> 00:08:14.230
Xliff is an international
standard that helps you

00:08:14.230 --> 00:08:17.080
preserve your parameters
across localization.

00:08:17.080 --> 00:08:20.050
And it works with a variety of
localized tools, including the

00:08:20.050 --> 00:08:22.860
one by Google, which I'll
show you later.

00:08:22.860 --> 00:08:25.520
So all parameters in your app,
or anything that you don't

00:08:25.520 --> 00:08:28.500
want translated, simply wrap
them in an xliff:g tag to

00:08:28.500 --> 00:08:31.480
preserve them in the process
of translation.

00:08:31.480 --> 00:08:33.880
To provide your translators
with a bit more context on

00:08:33.880 --> 00:08:36.510
what each parameter means,
remember to fill out the ID

00:08:36.510 --> 00:08:39.020
and example attributes.

00:08:39.020 --> 00:08:42.510
So this is getting progressively
better, but what

00:08:42.510 --> 00:08:44.030
else could go wrong?

00:08:44.030 --> 00:08:47.130
Let's see, this piece of code
works for most quantities in

00:08:47.130 --> 00:08:48.230
the English language.

00:08:48.230 --> 00:08:49.840
But what about the
quantity of one?

00:08:49.840 --> 00:08:53.110
You shouldn't be saying one
Androids were sold on, right?

00:08:53.110 --> 00:08:55.610
So in English you can fix this
pretty easily with an if/else

00:08:55.610 --> 00:08:58.670
loop in your code using a
special case when it's one,

00:08:58.670 --> 00:09:01.450
and say one Android
was sold on.

00:09:01.450 --> 00:09:03.030
But this doesn't necessarily
translate over

00:09:03.030 --> 00:09:04.690
across to other languages.

00:09:04.690 --> 00:09:07.060
Let's take a look.

00:09:07.060 --> 00:09:09.880
So unfortunately, plurals vary
across different languages.

00:09:09.880 --> 00:09:11.850
And there's no one-to-one
mapping of plurals rules

00:09:11.850 --> 00:09:13.260
across languages.

00:09:13.260 --> 00:09:14.690
Here's a few examples.

00:09:14.690 --> 00:09:17.350
In Chinese, plurals all
exist in one form.

00:09:17.350 --> 00:09:19.990
And the word, doll, translates
into wawa, no matter what the

00:09:19.990 --> 00:09:21.340
quantity is.

00:09:21.340 --> 00:09:24.070
In English, as we all know,
there's two forms--

00:09:24.070 --> 00:09:26.990
doll for one, and for everything
else, dolls.

00:09:26.990 --> 00:09:28.840
In Polish, there's
three forms.

00:09:28.840 --> 00:09:31.860
The word, doll, translates into
lalka, if there's one.

00:09:31.860 --> 00:09:34.700
It translates into lalki, if
it's a number that ends in two

00:09:34.700 --> 00:09:37.010
to four but excludes 12 to 14.

00:09:37.010 --> 00:09:40.440
And it translates into lalek
for everything else.

00:09:40.440 --> 00:09:42.620
But it can even more
complicated.

00:09:42.620 --> 00:09:47.255
In a language that's specific to
a region of France, Breton,

00:09:47.255 --> 00:09:48.640
there's five different
ways you could

00:09:48.640 --> 00:09:50.260
translate a plural message.

00:09:50.260 --> 00:09:53.000
And each of these ways is
very, very specific.

00:09:53.000 --> 00:09:55.890
So as you can see, plurals can
get pretty complex across

00:09:55.890 --> 00:09:56.990
different languages.

00:09:56.990 --> 00:10:01.040
How do we even begin to
internationalize that?

00:10:01.040 --> 00:10:02.920
Thankfully, Android can provide
some support through

00:10:02.920 --> 00:10:04.150
quantity strings.

00:10:04.150 --> 00:10:07.520
For messages in your app that
involved plurals, remember to

00:10:07.520 --> 00:10:09.410
wrap them inside
a plurals tag.

00:10:09.410 --> 00:10:12.260
And then for a given language
that you're in, list out all

00:10:12.260 --> 00:10:15.340
the various ways you can display
that message, given

00:10:15.340 --> 00:10:16.240
the quantity.

00:10:16.240 --> 00:10:18.930
So in English, there's two
ways you can display it--

00:10:18.930 --> 00:10:21.270
one way for the quantity of
one and another way for

00:10:21.270 --> 00:10:23.080
everything else.

00:10:23.080 --> 00:10:24.560
But what happens in
other languages?

00:10:24.560 --> 00:10:27.910
As you can see, the number of
plural messages that you can

00:10:27.910 --> 00:10:30.970
possibly have vary
across languages.

00:10:30.970 --> 00:10:33.190
So Android supports the
international standard of six

00:10:33.190 --> 00:10:34.870
different quantity types--

00:10:34.870 --> 00:10:38.310
one, two, few, more,
and other.

00:10:38.310 --> 00:10:40.960
Some of these quantity types,
such as zero or one, are

00:10:40.960 --> 00:10:42.250
pretty obvious in
what they mean

00:10:42.250 --> 00:10:43.860
across different languages.

00:10:43.860 --> 00:10:46.720
Other quantity types, such as
few or more are a little more

00:10:46.720 --> 00:10:49.240
vague and mean different things
in different languages.

00:10:49.240 --> 00:10:51.470
And there are plenty of
resources online telling you

00:10:51.470 --> 00:10:53.180
for a given language
exactly what the

00:10:53.180 --> 00:10:55.520
quantity type maps to.

00:10:55.520 --> 00:10:57.810
So when you're getting your app
translated, make sure that

00:10:57.810 --> 00:10:59.680
all of your strings are
in a plural tag.

00:10:59.680 --> 00:11:02.190
And the translator will figure
out which client types work

00:11:02.190 --> 00:11:04.050
for that language and translate
the strings

00:11:04.050 --> 00:11:06.910
properly for you.

00:11:06.910 --> 00:11:09.540
Now back inside your app, you
can use the getQuantityString

00:11:09.540 --> 00:11:13.570
method, and then call
R.plurals.name, to pull up the

00:11:13.570 --> 00:11:15.020
correct plural string.

00:11:15.020 --> 00:11:17.060
And given the quantity, Android
will automatically

00:11:17.060 --> 00:11:19.550
figure out which plural string
they should be using, so that

00:11:19.550 --> 00:11:23.450
plurals are handled properly
all throughout your app.

00:11:23.450 --> 00:11:25.610
So we're almost done with
optimizations that make your

00:11:25.610 --> 00:11:27.260
code internationally friendly.

00:11:27.260 --> 00:11:30.600
There's one last thing you can
do to update your code.

00:11:30.600 --> 00:11:32.330
You'll notice that our string
includes a date.

00:11:32.330 --> 00:11:34.690
And as many of you know, dates
are displayed in different

00:11:34.690 --> 00:11:36.530
ways across different
languages.

00:11:36.530 --> 00:11:39.440
How do we fix that?

00:11:39.440 --> 00:11:41.600
Android APIs provide
support here.

00:11:41.600 --> 00:11:44.800
You can use a library called
SimpleDateFormat to configure

00:11:44.800 --> 00:11:47.090
custom date formats
for your dates.

00:11:47.090 --> 00:11:50.670
And in a post JB-MR1 version,
we'll provide a call, called

00:11:50.670 --> 00:11:53.970
getBestDateTimeFormat, which
given the user locale, will

00:11:53.970 --> 00:11:56.540
automatically figure out the
proper date format for you to

00:11:56.540 --> 00:11:58.070
display dates in.

00:11:58.070 --> 00:12:00.800
And then you can simply use
String.format, give it a user

00:12:00.800 --> 00:12:03.530
locale, the format, and
the date, and it will

00:12:03.530 --> 00:12:05.590
automatically generate
the right string

00:12:05.590 --> 00:12:08.820
for that given locale.

00:12:08.820 --> 00:12:11.340
Android APIs also supports
internationalization of other

00:12:11.340 --> 00:12:14.700
values such as phone numbers,
decimals, currencies, and

00:12:14.700 --> 00:12:15.660
percentages.

00:12:15.660 --> 00:12:18.060
And you can use the libraries
below to make these values

00:12:18.060 --> 00:12:20.510
internationally friendly.

00:12:20.510 --> 00:12:22.960
Now the last tip is also
pretty important.

00:12:22.960 --> 00:12:25.990
And to demonstrate, I'll show
you an example of how Google

00:12:25.990 --> 00:12:28.206
did it wrong.

00:12:28.206 --> 00:12:32.160
Does anyone know what
movie this is?

00:12:32.160 --> 00:12:36.510
OK, it's "Breakfast at
Tiffany's." And many of you,

00:12:36.510 --> 00:12:38.880
if you've lived in the United
States and speak English, know

00:12:38.880 --> 00:12:40.210
this cultural reference.

00:12:40.210 --> 00:12:42.720
So when you go into Google
calendar to create a calendar

00:12:42.720 --> 00:12:45.115
event, it's no surprise to you
when the example, they provide

00:12:45.115 --> 00:12:47.570
you is "Breakfast at Tiffany's."
You understand it,

00:12:47.570 --> 00:12:49.690
and it's cool that it's
a cultural reference.

00:12:49.690 --> 00:12:53.500
But what happens when Google
Calendar went international?

00:12:53.500 --> 00:12:56.610
Well, in Hindi, the string,
"Breakfast at Tiffany's"

00:12:56.610 --> 00:12:59.260
literally translated over into
breakfast at Tiffany's.

00:12:59.260 --> 00:13:01.840
And to Hindi users, they
had absolutely no

00:13:01.840 --> 00:13:03.070
idea what this meant.

00:13:03.070 --> 00:13:04.520
Why are they getting
breakfast?

00:13:04.520 --> 00:13:06.780
And who is this woman named
Tiffany's, because they didn't

00:13:06.780 --> 00:13:08.590
understand the cultural
reference.

00:13:08.590 --> 00:13:10.880
So this is an example of--

00:13:10.880 --> 00:13:13.290
even if you translate all your
strings correctly, that

00:13:13.290 --> 00:13:16.740
doesn't necessarily mean it's
friendly for that language.

00:13:16.740 --> 00:13:18.970
So what should you
be doing instead?

00:13:18.970 --> 00:13:20.780
Calendar is working
on fixing this.

00:13:20.780 --> 00:13:23.780
Now, in Chinese, if you try to
create a calendar event, it

00:13:23.780 --> 00:13:26.460
instead says [SPEAKING CHINESE],
which

00:13:26.460 --> 00:13:29.390
simply means to get Peking
duck at a really famous

00:13:29.390 --> 00:13:31.360
Beijing restaurant.

00:13:31.360 --> 00:13:34.140
This is an example of providing
cultural references,

00:13:34.140 --> 00:13:36.830
so that you add local flavor for
the language that you're

00:13:36.830 --> 00:13:38.260
localizing into.

00:13:38.260 --> 00:13:40.580
So when you're getting your
strings translated, and if you

00:13:40.580 --> 00:13:43.470
have any part of your app that
requires local flavor, such as

00:13:43.470 --> 00:13:46.970
cultural references or maybe
even holidays in that country,

00:13:46.970 --> 00:13:49.540
be sure the translator knows
this and doesn't translate all

00:13:49.540 --> 00:13:50.790
those strings literally.

00:13:53.030 --> 00:13:55.450
So that's it for all the general
tips and tricks for

00:13:55.450 --> 00:13:58.040
updating your code to make it
internationally friendly.

00:13:58.040 --> 00:14:00.510
There is now a special set of
languages that require a bit

00:14:00.510 --> 00:14:01.450
more support--

00:14:01.450 --> 00:14:02.730
right-to-left languages.

00:14:02.730 --> 00:14:05.296
And I'll let Fabrice talk
more about this.

00:14:05.296 --> 00:14:07.820
FABRICE DIMEGLIO: Thank
you, Yiwen.

00:14:07.820 --> 00:14:10.630
So let's talk about
right-to-left support.

00:14:10.630 --> 00:14:14.290
Right to left, or RTL is a
natural writing direction for

00:14:14.290 --> 00:14:16.550
Arabic, Persian, and
Hebrew speakers.

00:14:16.550 --> 00:14:19.030
It represents roughly
300 million to

00:14:19.030 --> 00:14:20.060
half a billion people.

00:14:20.060 --> 00:14:23.130
So that's quite a lot, and
surely part of this next 6

00:14:23.130 --> 00:14:28.040
million people that will use
internet and mobile devices.

00:14:28.040 --> 00:14:32.900
It's also related to bug 5597,
which has been filed in 209,

00:14:32.900 --> 00:14:36.530
actually end of 209 on our
external bug tracking system

00:14:36.530 --> 00:14:40.500
and concerning Arabic
language support.

00:14:40.500 --> 00:14:43.610
This bug, up to a couple of
weeks ago, was the most-wanted

00:14:43.610 --> 00:14:44.770
bug to be fixed.

00:14:44.770 --> 00:14:47.650
And it got roughly
9,000 stars.

00:14:47.650 --> 00:14:50.500
So that's quite a lot.

00:14:50.500 --> 00:14:52.300
Let's see what we have done.

00:14:52.300 --> 00:14:56.830
So first of all, here is a
screenshot of the Setting app,

00:14:56.830 --> 00:15:02.890
running on Jelly Bean, on a
Nexus 7 with an Arabic locale.

00:15:02.890 --> 00:15:04.885
If you know how to read Arabic,
you will notice that

00:15:04.885 --> 00:15:07.320
the Arabic text is rendered
correctly and beautifully from

00:15:07.320 --> 00:15:08.920
right to left.

00:15:08.920 --> 00:15:13.560
The main issue here is
concerning this alignment.

00:15:13.560 --> 00:15:15.910
For example, in the Action bar,
you can see that the text

00:15:15.910 --> 00:15:19.250
is aligned on the left instead
of being aligned on the right.

00:15:19.250 --> 00:15:22.260
We can also notice, on the other
row, that sometimes the

00:15:22.260 --> 00:15:24.730
alignment is not correct, on
the left or on the right.

00:15:24.730 --> 00:15:26.890
So it's not consistent.

00:15:26.890 --> 00:15:30.780
Last but not least, UI widgets
are flowing from left to right

00:15:30.780 --> 00:15:33.890
instead of flowing from
right to left.

00:15:33.890 --> 00:15:36.070
So what can we do to
improve the user

00:15:36.070 --> 00:15:38.980
experience for Arabic speakers?

00:15:38.980 --> 00:15:43.810
Here is the same app, running
on Jelly Bean MR1.

00:15:43.810 --> 00:15:46.550
And now you can see that
everything flows nicely from

00:15:46.550 --> 00:15:47.260
right to left.

00:15:47.260 --> 00:15:50.170
It's total natural direction
for Arabic speakers.

00:15:50.170 --> 00:15:51.640
The text is rendered
beautifully

00:15:51.640 --> 00:15:52.670
from right to left.

00:15:52.670 --> 00:15:57.930
And the alignment is consistent
and on the right.

00:15:57.930 --> 00:15:59.270
So what we need is
actually layout

00:15:59.270 --> 00:16:02.450
mirroring and text alignment.

00:16:02.450 --> 00:16:03.960
How can we achieve that?

00:16:03.960 --> 00:16:05.310
Good news!

00:16:05.310 --> 00:16:09.630
RTL support is built in into
View and ViewGroup, so that

00:16:09.630 --> 00:16:13.260
all UI framework widgets
are supporting RTL.

00:16:13.260 --> 00:16:14.850
So I'm listing here six steps.

00:16:14.850 --> 00:16:17.300
The first one, one and
two, are compulsory.

00:16:17.300 --> 00:16:18.440
Three and four are optional.

00:16:18.440 --> 00:16:21.690
And five and six are about
testing your app on pre and

00:16:21.690 --> 00:16:23.990
post JB-MR1 and also validating
your work with

00:16:23.990 --> 00:16:26.770
native speakers.

00:16:26.770 --> 00:16:30.120
So let's talk about the
first steps, the

00:16:30.120 --> 00:16:32.770
AndroidManifest first.

00:16:32.770 --> 00:16:35.130
We're introducing a new
attribute for the application

00:16:35.130 --> 00:16:37.350
tag, called supportsRtl.

00:16:37.350 --> 00:16:40.530
And if you supportsRtl equal
true, it means actually that

00:16:40.530 --> 00:16:42.520
your app is willing
to support RTL.

00:16:42.520 --> 00:16:44.050
And then the framework
will do the necessary

00:16:44.050 --> 00:16:46.680
stuff to make it happen.

00:16:46.680 --> 00:16:51.240
But also you need to use SDK
targets, the SDK 17 and more,

00:16:51.240 --> 00:16:53.350
by activating those APIs--

00:16:53.350 --> 00:16:55.335
so basically two little
changes into your

00:16:55.335 --> 00:16:56.585
AndroidManifest.

00:16:58.190 --> 00:17:00.080
Now step two is about
updating layout and

00:17:00.080 --> 00:17:02.320
taking care about resources.

00:17:02.320 --> 00:17:04.319
So if you remember well what
you're doing with layout, you

00:17:04.319 --> 00:17:07.180
have left and right properties,
so padding left,

00:17:07.180 --> 00:17:10.040
right, gravity left,
gravity right.

00:17:10.040 --> 00:17:12.880
Now we are introducing start
and end properties.

00:17:12.880 --> 00:17:15.780
And those properties are
[INAUDIBLE] once.

00:17:15.780 --> 00:17:17.780
And we are considering left and
right as absolute once.

00:17:17.780 --> 00:17:20.800
So going from start/end
to left/right is

00:17:20.800 --> 00:17:22.460
a resolution process.

00:17:22.460 --> 00:17:24.369
And if you're from left-to-right
direction,

00:17:24.369 --> 00:17:26.440
start/end means left/right.

00:17:26.440 --> 00:17:27.950
And if you are from
right-to-left direction,

00:17:27.950 --> 00:17:30.650
start/end means right/left.

00:17:30.650 --> 00:17:32.760
So this resolution
process is done

00:17:32.760 --> 00:17:35.450
automatically and is two fold.

00:17:35.450 --> 00:17:38.830
API level 17 and plus-- so
Jelly Bean MR1 and plus,

00:17:38.830 --> 00:17:41.630
start/end are resolved and
override any value you may

00:17:41.630 --> 00:17:44.370
have defined for left/right.

00:17:44.370 --> 00:17:47.090
If you're API level 17 and
below, start/end are just

00:17:47.090 --> 00:17:49.140
ignored, and everything
works as before,

00:17:49.140 --> 00:17:50.390
left/right are used.

00:17:54.630 --> 00:17:57.500
So for your reference, here is
the full table for start/end

00:17:57.500 --> 00:18:01.350
property resolution, three
columns on the left for 17 and

00:18:01.350 --> 00:18:04.520
plus and three columns on the
right for 16 and below.

00:18:04.520 --> 00:18:07.810
In yellow, I have highlighted
two columns where actually

00:18:07.810 --> 00:18:09.900
start/end and left/right are
defined at the same time.

00:18:09.900 --> 00:18:12.100
And this is exactly what
I said before.

00:18:12.100 --> 00:18:14.530
And you can also notice that w
are trying really hard to get

00:18:14.530 --> 00:18:17.050
start/end properties used.

00:18:17.050 --> 00:18:19.130
Otherwise, we're just using
left and right.

00:18:22.520 --> 00:18:24.320
What are the start/end
properties we're introducing

00:18:24.320 --> 00:18:27.670
in API level 17 so far,
Jelly Bean MR1?

00:18:27.670 --> 00:18:31.500
It's about padding, drawables,
layout margin, and a bunch of

00:18:31.500 --> 00:18:33.300
properties for creative
layout.

00:18:38.840 --> 00:18:42.630
Now the second step also
is about RTL resources.

00:18:42.630 --> 00:18:44.120
And there's good news here.

00:18:44.120 --> 00:18:47.050
Aapt compare is also supporting
RTL through a new

00:18:47.050 --> 00:18:53.390
modifier called -ldrtl where
"ld" means layout direction.

00:18:53.390 --> 00:18:55.720
So if you look at those two
screen shots here, they are

00:18:55.720 --> 00:18:58.630
coming from an app where the
developer decided to include

00:18:58.630 --> 00:19:02.710
some drawables for Farsi,
Arabic, and also drawables

00:19:02.710 --> 00:19:07.040
depending on the density
of the device.

00:19:07.040 --> 00:19:11.270
So if you are running this app
on the device with Arabic

00:19:11.270 --> 00:19:15.900
locale, it will pick up the
drawable from drawable-r- the

00:19:15.900 --> 00:19:18.050
density of the device.

00:19:18.050 --> 00:19:20.630
Then it should go to drawable-
the density of the device and

00:19:20.630 --> 00:19:21.880
then to drawable.

00:19:21.880 --> 00:19:26.110
But by the virtual introducing
global-ldrtl- the density it

00:19:26.110 --> 00:19:28.830
will hijack actually the
resolution process.

00:19:28.830 --> 00:19:32.700
So that first it would be
resolving to drawable-r then

00:19:32.700 --> 00:19:37.860
into drawable-ldrtl because
Arabic is an RTL language.

00:19:37.860 --> 00:19:41.020
And then into drawable-
the density

00:19:41.020 --> 00:19:42.620
and then into drawable.

00:19:42.620 --> 00:19:44.230
So that's pretty much
the same thing.

00:19:44.230 --> 00:19:46.330
OK, everything is resolved
from most

00:19:46.330 --> 00:19:47.610
specific to most generic.

00:19:50.660 --> 00:19:51.980
Now you're doing step
one and two.

00:19:51.980 --> 00:19:54.035
And you're pretty happy when
you start seeing your app

00:19:54.035 --> 00:19:57.000
running for the first time
on Jelly Bean MR1.

00:19:57.000 --> 00:20:00.380
But sometimes you need
to tune the result.

00:20:00.380 --> 00:20:03.400
And tuning is about layout
and tuning text.

00:20:03.400 --> 00:20:06.340
So here is, on the left, a
screen shot of the dialer app

00:20:06.340 --> 00:20:08.410
I was working on a couple
of weeks ago.

00:20:08.410 --> 00:20:10.180
And as you can see, everything
flows nicely

00:20:10.180 --> 00:20:12.620
from right to left.

00:20:12.620 --> 00:20:15.570
But the main problem here is
the first row of buttons.

00:20:15.570 --> 00:20:17.230
Actually, it's the
dialer itself.

00:20:17.230 --> 00:20:20.010
It's also doing auto-layout
mirroring.

00:20:20.010 --> 00:20:21.970
And if you know how to read
Arabic, you will see that the

00:20:21.970 --> 00:20:24.860
first row is saying 3-2-1.

00:20:24.860 --> 00:20:27.160
An Arabic speaker would say, no,
that's incorrect, Fabrice.

00:20:27.160 --> 00:20:30.810
It should be 1-2-3, which is the
screenshot on the right.

00:20:30.810 --> 00:20:32.210
So how can you achieve that?

00:20:34.890 --> 00:20:37.960
Well, we are introducing a new
property for View, called

00:20:37.960 --> 00:20:40.150
layout direction.

00:20:40.150 --> 00:20:44.310
And if you take the example I
was talking about just before,

00:20:44.310 --> 00:20:45.910
this is a linear layout
with [INAUDIBLE].

00:20:45.910 --> 00:20:48.180
So you can say LinearLayout
android: layoutDirection equal

00:20:48.180 --> 00:20:49.300
left to right.

00:20:49.300 --> 00:20:51.010
And then everything will flow
from left to right.

00:20:51.010 --> 00:20:53.310
You'll forcing the
layout direction.

00:20:53.310 --> 00:20:55.490
The API is pretty
simple here--

00:20:55.490 --> 00:20:58.760
 and
getLayoutDirection.

00:20:58.760 --> 00:21:01.540
The most interesting part,
sorry, is about actually the

00:21:01.540 --> 00:21:04.050
default value, which
is set to inherit.

00:21:04.050 --> 00:21:05.600
Inherit means actually
that the view

00:21:05.600 --> 00:21:06.510
doesn't know its value.

00:21:06.510 --> 00:21:08.760
It will ask its parent
to get the value.

00:21:08.760 --> 00:21:11.260
And if the parent doesn't have
it, it will go up to the View

00:21:11.260 --> 00:21:13.390
chain, up to View root.

00:21:13.390 --> 00:21:15.070
And the View root would
have the locale--

00:21:15.070 --> 00:21:17.670
what is my direction.

00:21:17.670 --> 00:21:20.530
This resolution process
is done during the

00:21:20.530 --> 00:21:21.740
View measure pass.

00:21:21.740 --> 00:21:24.310
And it's done before we are
calling you guys on measure,

00:21:24.310 --> 00:21:27.140
so that you're 100% sure that
the layout direction is

00:21:27.140 --> 00:21:28.900
resolved before we
are calling you.

00:21:31.510 --> 00:21:35.630
Now the path for layout
direction, we have two other

00:21:35.630 --> 00:21:38.420
probabilities dealing
with text.

00:21:38.420 --> 00:21:39.620
The first one is
textDirection.

00:21:39.620 --> 00:21:41.150
And the second one is
textAlignment And they are

00:21:41.150 --> 00:21:43.710
using the same pattern
for the API.

00:21:43.710 --> 00:21:46.630
TextDirection is all about
defining heuristics, so that

00:21:46.630 --> 00:21:48.320
you can define actually
the overall

00:21:48.320 --> 00:21:50.360
direction for a paragraph.

00:21:50.360 --> 00:21:51.220
The default value
is very strong.

00:21:51.220 --> 00:21:53.720
It means actually that the first
strong Unicode char will

00:21:53.720 --> 00:21:55.150
give its directionality to the

00:21:55.150 --> 00:21:58.320
directionality of the paragraph.

00:21:58.320 --> 00:22:01.250
You can also define your
own heuristics.

00:22:01.250 --> 00:22:03.350
And you can define, for example,
a char count, where

00:22:03.350 --> 00:22:05.390
you would count the number of
characters that are left to

00:22:05.390 --> 00:22:07.020
right, and the number of
characters that are right to

00:22:07.020 --> 00:22:10.255
left and decide the overall
paragraph direction.

00:22:12.790 --> 00:22:15.410
Now let's talk a little bit
about text alignment.

00:22:15.410 --> 00:22:18.110
As we have seen before, it
was a little bit tricky.

00:22:18.110 --> 00:22:21.510
The default value now if you say
text alignment is gravity.

00:22:21.510 --> 00:22:24.940
It means that, as before, you
would be using gravity left,

00:22:24.940 --> 00:22:27.250
gravity right, or gravity
start and gravity end.

00:22:27.250 --> 00:22:29.490
But the most interesting part
here is that you can say text

00:22:29.490 --> 00:22:31.690
alignment view start
or view end.

00:22:31.690 --> 00:22:33.760
That means actually that the
alignment of the text will be

00:22:33.760 --> 00:22:35.570
at the beginning of the view
or the end of the view.

00:22:39.440 --> 00:22:43.000
Using text elements like this
has been really easy.

00:22:43.000 --> 00:22:48.720
And as I've done the conversion
of the RLT support

00:22:48.720 --> 00:22:52.690
for the Setting app, it was
very useful actually.

00:22:52.690 --> 00:22:56.970
Now suppose you have
some custom view.

00:22:56.970 --> 00:23:00.370
If you're dealing with gravity
left and gravity right, let's

00:23:00.370 --> 00:23:03.680
say you need to go to gravity
start and gravity end.

00:23:03.680 --> 00:23:05.810
If you're manipulating gravity,
you need to use

00:23:05.810 --> 00:23:08.820
getAbsoluteGravity, so that
you're going from start/end to

00:23:08.820 --> 00:23:10.070
left/right.

00:23:11.860 --> 00:23:14.500
We've introduced a new API
called onRtlPropertiesChanged,

00:23:14.500 --> 00:23:17.990
so that whenever layout
direction, text alignment or

00:23:17.990 --> 00:23:20.630
text direction is changing, you
have a call back, and you

00:23:20.630 --> 00:23:23.370
can do whatever you want.

00:23:23.370 --> 00:23:26.040
Now if you're defining,
redefining, onMeasure, and

00:23:26.040 --> 00:23:29.860
onLayout, then you need to do
something, obviously, because

00:23:29.860 --> 00:23:32.150
basically your layout was
flowing from left to right.

00:23:32.150 --> 00:23:34.700
So you will need to flow
it from right to left.

00:23:34.700 --> 00:23:36.120
So measurement can be changed.

00:23:36.120 --> 00:23:39.220
And layout will be changed.

00:23:39.220 --> 00:23:41.500
But the good news is that
you can always use

00:23:41.500 --> 00:23:43.840
getLayoutDirection and know the
current layout direction

00:23:43.840 --> 00:23:46.530
or the view.

00:23:46.530 --> 00:23:49.690
Last but not least, if you're
dealing with draw and issuing

00:23:49.690 --> 00:23:52.580
your own canvas command, then
you're on your own.

00:23:52.580 --> 00:23:54.540
We are not providing anything
for doing that.

00:23:59.230 --> 00:24:01.560
Now let's talk about
compatibility for pre JB-MR1.

00:24:04.170 --> 00:24:08.770
So the good news is that as
before, all new attributes are

00:24:08.770 --> 00:24:11.500
ignored from one platform level
to the previous one.

00:24:11.500 --> 00:24:15.190
So all new RTL attributes
will be ignored.

00:24:15.190 --> 00:24:18.020
So if you're ignoring start
and end, what's left?

00:24:18.020 --> 00:24:19.090
Mostly nothing.

00:24:19.090 --> 00:24:21.535
So the trick here is actually
to have start/end properties

00:24:21.535 --> 00:24:24.650
in addition to the
left/right ones.

00:24:24.650 --> 00:24:27.740
So, it's duplication here.

00:24:27.740 --> 00:24:30.190
But you need to consider also
starts for extracting actually

00:24:30.190 --> 00:24:32.900
those left/right properties into
a start file, and then

00:24:32.900 --> 00:24:36.700
providing your own start
file for v17 or -dlrtl.

00:24:36.700 --> 00:24:39.440
And that will fix the problem.

00:24:39.440 --> 00:24:41.820
A great example here is the
Google Keep app that you may

00:24:41.820 --> 00:24:44.030
have downloaded from
Google Play store.

00:24:44.030 --> 00:24:46.870
So the Google Keep app is the
first app to support RTL that

00:24:46.870 --> 00:24:49.320
has been released
on Google Play.

00:24:49.320 --> 00:24:51.370
And as you can see in this
screenshot, the Google Keep

00:24:51.370 --> 00:24:53.020
app is running on
Jelly Bean MR-1.

00:24:53.020 --> 00:24:55.210
And everything flows nicely
from right to left.

00:24:55.210 --> 00:24:58.490
The text is aligned correctly
and beautifully rendered.

00:24:58.490 --> 00:25:00.580
And also the notes
by themselves,

00:25:00.580 --> 00:25:01.610
are using your layout.

00:25:01.610 --> 00:25:03.160
And the layout is going
from right to left.

00:25:07.360 --> 00:25:09.350
Now let's talk about tools
support for RTL.

00:25:09.350 --> 00:25:13.070
So as I said before, aapt
compiler has been modified for

00:25:13.070 --> 00:25:16.240
supporting -ldrtl resources.

00:25:16.240 --> 00:25:18.280
But you want to debug
your view hierarchy.

00:25:18.280 --> 00:25:23.130
And we have introduced RTL
support for HierarchyViewer.

00:25:23.130 --> 00:25:27.110
So as you can see in those two
screenshots, when you're

00:25:27.110 --> 00:25:30.940
selecting a view, you can see
many properties that are

00:25:30.940 --> 00:25:32.810
related to RTL--

00:25:32.810 --> 00:25:35.210
getRawTextDirection,
TextAlignment,

00:25:35.210 --> 00:25:38.530
TextDirection, and more.

00:25:38.530 --> 00:25:42.010
In a future release, we will
release also RTL rules for

00:25:42.010 --> 00:25:42.820
[INAUDIBLE]

00:25:42.820 --> 00:25:45.530
so that whenever you're dealing
with RTL properties

00:25:45.530 --> 00:25:48.210
Link will check and warn you
if anything's wrong.

00:25:52.830 --> 00:25:56.150
Now let's talk about a
small case, which is

00:25:56.150 --> 00:25:57.680
user-generated content.

00:25:57.680 --> 00:25:59.840
So this case is actually
pretty interesting.

00:25:59.840 --> 00:26:03.510
So as you can see in the first
line of the screenshot, I was

00:26:03.510 --> 00:26:06.620
formatting some phone number
with a [INAUDIBLE] string.

00:26:06.620 --> 00:26:11.270
And sorry, the formatting
is not correct.

00:26:11.270 --> 00:26:12.360
It's a little bit strange.

00:26:12.360 --> 00:26:14.350
And if you know a little bit
about text rendering, we are

00:26:14.350 --> 00:26:15.370
using the U bidi algorithm.

00:26:15.370 --> 00:26:18.760
And it's doing the right stuff,
because the presence of

00:26:18.760 --> 00:26:23.110
the space and the plus
do some [INAUDIBLE].

00:26:23.110 --> 00:26:25.760
So for having the correct
rendering that you see on row

00:26:25.760 --> 00:26:28.580
number two, you will need to
use a new class, called

00:26:28.580 --> 00:26:29.640
BidiFormatter.

00:26:29.640 --> 00:26:33.440
And this BidiFormatter will
be released post JB-MR1.

00:26:33.440 --> 00:26:35.490
It will be available in the
framework and support library.

00:26:35.490 --> 00:26:38.630
And you will say get instance
for my context Unicode, write

00:26:38.630 --> 00:26:42.250
this string, which is the stuff
translators would do

00:26:42.250 --> 00:26:46.860
actually, by themselves, by
hand, injecting Unicode marks,

00:26:46.860 --> 00:26:48.200
or Bidi control marks.

00:26:52.490 --> 00:26:55.990
Now let's talk about some
tips and tricks.

00:26:55.990 --> 00:26:58.960
So if in your code you're using
String.valueOf an int,

00:26:58.960 --> 00:27:04.980
or any number, any type, then
you should remember that the

00:27:04.980 --> 00:27:07.010
format will be Latin.

00:27:07.010 --> 00:27:09.200
If you want to have actually a
format corresponding to your

00:27:09.200 --> 00:27:15.640
locale, you should use format
with %d as the first argument.

00:27:15.640 --> 00:27:18.290
As I said before, don't forget
that get.LayoutDirection is

00:27:18.290 --> 00:27:20.060
available anywhere in View.

00:27:20.060 --> 00:27:22.070
So you can say
getLayoutDirection equal equal

00:27:22.070 --> 00:27:23.410
LAYOUT_DIRECTION_RTL.

00:27:23.410 --> 00:27:25.840
And then you will know that
you're in RTL context or not.

00:27:29.490 --> 00:27:32.172
I previously said that all
UI framework widgets are

00:27:32.172 --> 00:27:33.010
supporting RTL.

00:27:33.010 --> 00:27:34.960
GridLayout is one of them.

00:27:34.960 --> 00:27:37.500
And GridLayout is supporting
RTL as RelativeLayout.

00:27:37.500 --> 00:27:40.060
But GridLayout is a better
layout than RelativeLayout.

00:27:40.060 --> 00:27:44.060
So please use GridLayout.

00:27:44.060 --> 00:27:47.240
If you're dealing with locale,
getDirectionLayoutFromLocale

00:27:47.240 --> 00:27:50.010
from TextUtils is a new API that
allows you to know the

00:27:50.010 --> 00:27:52.700
direction of the locale.

00:27:52.700 --> 00:27:53.250
[INAUDIBLE]

00:27:53.250 --> 00:27:55.590
is also used when you are
dealing with framework calls

00:27:55.590 --> 00:28:00.450
at the top of the View tree,
where we are asking the

00:28:00.450 --> 00:28:03.330
direction of the locale.

00:28:03.330 --> 00:28:06.310
And then if you're dealing with
database, SQLite or any

00:28:06.310 --> 00:28:07.470
others, don't forget about

00:28:07.470 --> 00:28:09.090
formatting your query correctly.

00:28:09.090 --> 00:28:13.910
If you're using format %d, it
will be formatted with the

00:28:13.910 --> 00:28:17.040
corresponding locale, and it
will probably not be good for

00:28:17.040 --> 00:28:17.820
your database.

00:28:17.820 --> 00:28:19.000
And you have SQL exceptions.

00:28:19.000 --> 00:28:22.000
So use format with locale as the
first argument, and locale

00:28:22.000 --> 00:28:23.860
should be US.

00:28:23.860 --> 00:28:24.710
Last but not least--

00:28:24.710 --> 00:28:27.140
I've seen this in
several apps--

00:28:27.140 --> 00:28:30.050
be aware of numbers in tables
and column names.

00:28:30.050 --> 00:28:35.110
That can be also lead to the
same SQL exceptions.

00:28:35.110 --> 00:28:37.550
So as you can see, it's
pretty easy to add RTL

00:28:37.550 --> 00:28:39.490
support to an app.

00:28:39.490 --> 00:28:43.230
And Arabic, Hebrew, Persian
users would be really

00:28:43.230 --> 00:28:44.870
delighted to see that.

00:28:44.870 --> 00:28:47.520
So we are looking for a while to
have this support from your

00:28:47.520 --> 00:28:50.410
app into Google Play.

00:28:50.410 --> 00:28:52.760
Now I would like to do a small
demo, if you don't mind.

00:28:56.150 --> 00:29:00.380
So I'm switching to a machine.

00:29:00.380 --> 00:29:04.570
So this is a phone
put in Arabic.

00:29:04.570 --> 00:29:07.410
This is JB-MR1.

00:29:07.410 --> 00:29:13.110
And I'm going back to my
machine, and I will use this

00:29:13.110 --> 00:29:16.350
awesome new tool called
Android Studio.

00:29:19.260 --> 00:29:22.690
So you can see this is
a manifest here--

00:29:22.690 --> 00:29:26.310
OK, basic app created
with the Studio.

00:29:26.310 --> 00:29:30.970
And here, I have highlighted
that for you, supportsRTL

00:29:30.970 --> 00:29:32.710
equals false.

00:29:32.710 --> 00:29:40.220
So I'm just writing this
app right now,

00:29:40.220 --> 00:29:41.475
pushing it to the device.

00:29:45.450 --> 00:29:47.970
And here is what you
see on the device.

00:29:47.970 --> 00:29:52.940
Hello, world, centered
with an action bar.

00:29:52.940 --> 00:30:00.440
Now I'm going back to my code,
and I'm saying suportsRTL

00:30:00.440 --> 00:30:03.080
equal true.

00:30:03.080 --> 00:30:06.960
Also please notice that the
target SDK version is 17 here.

00:30:06.960 --> 00:30:18.620
I'm pushing the same app,
going to the device.

00:30:18.620 --> 00:30:22.380
And now you see that the action
bar is laid out from

00:30:22.380 --> 00:30:23.630
right to left.

00:30:25.870 --> 00:30:28.320
So let's have a little
bit more fun.

00:30:28.320 --> 00:30:33.940
OK, going back here, and gravity
was center here.

00:30:33.940 --> 00:30:42.910
So I'm using now another
TextView using viewStart,

00:30:42.910 --> 00:30:44.530
pushing the app to the device.

00:30:52.730 --> 00:30:53.890
There it is.

00:30:53.890 --> 00:30:55.140
The text is aligned
on the right.

00:30:57.650 --> 00:31:01.550
So I will pass the clicker
now back to Yiwen.

00:31:01.550 --> 00:31:02.110
YIWEN ZHAN: Great.

00:31:02.110 --> 00:31:03.360
Thanks, Fabrice.

00:31:05.800 --> 00:31:08.610
So now that's it for all of the
tips and tricks in making

00:31:08.610 --> 00:31:10.520
your code internationally
friendly.

00:31:10.520 --> 00:31:13.020
The next step is to get
your app translated.

00:31:13.020 --> 00:31:15.800
Historically, developers have
found some trouble here, in

00:31:15.800 --> 00:31:18.640
that they had to search the
internet for high-quality

00:31:18.640 --> 00:31:22.500
translators who were well versed
in app translation.

00:31:22.500 --> 00:31:24.790
As you might have seen in the
keynote, we're launching an

00:31:24.790 --> 00:31:27.710
app translation service that
makes this easier.

00:31:27.710 --> 00:31:30.740
Starting now in Developer
Console, you can order

00:31:30.740 --> 00:31:33.260
translations for your
strings.xml files in a few

00:31:33.260 --> 00:31:35.280
simple clicks.

00:31:35.280 --> 00:31:37.690
And you've seen this demo in
the keynote already, so I

00:31:37.690 --> 00:31:38.750
won't demo it again.

00:31:38.750 --> 00:31:41.630
But what I will show you is what
happens after you order a

00:31:41.630 --> 00:31:42.880
translation.

00:31:48.470 --> 00:31:50.770
So now I'm in Developer
Console.

00:31:50.770 --> 00:31:52.820
And I just placed the
translation earlier today for

00:31:52.820 --> 00:31:56.180
my I/O app strings.

00:31:56.180 --> 00:31:58.540
And if I were to click on this
button, I can check the

00:31:58.540 --> 00:32:00.910
progress of those
translations.

00:32:00.910 --> 00:32:03.170
So as you see here, I ordered
my translation for three

00:32:03.170 --> 00:32:03.880
languages--

00:32:03.880 --> 00:32:05.680
German, Japanese, and French.

00:32:05.680 --> 00:32:07.140
And you can see translators
making

00:32:07.140 --> 00:32:09.260
progress in these languages.

00:32:09.260 --> 00:32:12.380
What happens here is that
translators, working for the

00:32:12.380 --> 00:32:15.390
translation companies that
Google is working with, are

00:32:15.390 --> 00:32:18.840
busy translating our app in
Google Translation Manager, a

00:32:18.840 --> 00:32:21.030
hub central for app
translation.

00:32:21.030 --> 00:32:23.120
And if you were to click on one
of these languages, you

00:32:23.120 --> 00:32:25.360
can see the translator's
work in progress.

00:32:25.360 --> 00:32:26.845
So let me check out the
German translations.

00:32:29.530 --> 00:32:31.760
So now I'm in Translation
Manager, the toolkit that the

00:32:31.760 --> 00:32:34.130
translator is using to
translate our app.

00:32:34.130 --> 00:32:35.900
And as you can see here,
all the strings in your

00:32:35.900 --> 00:32:38.930
strings.xml file are parsed out
in a way that's easy for

00:32:38.930 --> 00:32:41.300
the translator to understand
and translate.

00:32:41.300 --> 00:32:43.380
Let's take a look at a specific
message, and see how

00:32:43.380 --> 00:32:46.640
the translator is
translating it.

00:32:46.640 --> 00:32:48.950
So you can see here on the left
is the message string

00:32:48.950 --> 00:32:51.010
itself, along with
the description.

00:32:51.010 --> 00:32:53.050
And we put that description
from the comment that you

00:32:53.050 --> 00:32:54.530
leave above that
message string.

00:32:54.530 --> 00:32:56.220
So it's important to leave
some context for your

00:32:56.220 --> 00:32:58.990
translators through comments.

00:32:58.990 --> 00:33:00.910
As you see from the word,
remaining time,

00:33:00.910 --> 00:33:02.180
that's a place holder.

00:33:02.180 --> 00:33:05.050
This is because this was wrapped
in an xliff tag.

00:33:05.050 --> 00:33:07.710
And this placeholder will
now be preserved across

00:33:07.710 --> 00:33:10.080
translations.

00:33:10.080 --> 00:33:12.900
Let's take a look at a few
other translations.

00:33:12.900 --> 00:33:15.550
Just scrolling down, you'll see
that the translator has

00:33:15.550 --> 00:33:17.460
made some progress on
the translations.

00:33:17.460 --> 00:33:20.190
And then for the I/O Live one,
they left a comment.

00:33:20.190 --> 00:33:23.010
So we have comments in this
toolkit to encourage

00:33:23.010 --> 00:33:25.230
communication between developers
and translators, so

00:33:25.230 --> 00:33:28.120
they can work together to
produce the most high-quality

00:33:28.120 --> 00:33:29.800
translations for your app.

00:33:29.800 --> 00:33:31.500
Let's take a look at what
this comment says.

00:33:34.790 --> 00:33:36.960
So here we forgot to leave
some context for the

00:33:36.960 --> 00:33:37.270
translator.

00:33:37.270 --> 00:33:39.950
And they're a little confused
as to what I/O Live means.

00:33:39.950 --> 00:33:40.830
Is there a trademark?

00:33:40.830 --> 00:33:42.630
And should we be
translating it?

00:33:42.630 --> 00:33:45.380
And when the translator leaves
a comment, I, as a developer,

00:33:45.380 --> 00:33:47.250
will get an email with
that comment.

00:33:47.250 --> 00:33:50.390
So I can simply look in that
email, and then come into this

00:33:50.390 --> 00:33:52.420
toolkit to respond
to this comment.

00:33:52.420 --> 00:33:58.170
Now, I can just tell him, no,
this shouldn't be translated.

00:33:58.170 --> 00:34:00.300
Now this translator will get an
email with this response,

00:34:00.300 --> 00:34:01.660
and they'll know not to
translate that string.

00:34:05.010 --> 00:34:07.680
Let's take a look at a
few more examples.

00:34:07.680 --> 00:34:10.929
So at the very end is a message
that's in a plural.

00:34:10.929 --> 00:34:13.150
And here, we provide plural
support by offering a

00:34:13.150 --> 00:34:16.394
translator up to six ways to
translate any strings that are

00:34:16.394 --> 00:34:17.780
listed as plurals.

00:34:17.780 --> 00:34:20.530
This allows you to provide
proper plural support across a

00:34:20.530 --> 00:34:22.900
variety of languages.

00:34:22.900 --> 00:34:24.540
So that's it for the toolkit.

00:34:24.540 --> 00:34:27.270
And once the translator's done
translating, they'll mark the

00:34:27.270 --> 00:34:28.500
translation as complete.

00:34:28.500 --> 00:34:30.980
And you'll be able to
download it from

00:34:30.980 --> 00:34:32.369
Play Developer Console.

00:34:32.369 --> 00:34:34.300
Now here, as you can
see, the Japanese

00:34:34.300 --> 00:34:35.340
strings are already done.

00:34:35.340 --> 00:34:36.679
And I can download them.

00:34:36.679 --> 00:34:38.000
What happens when
I download them?

00:34:41.560 --> 00:34:45.550
What I get is a strings.xml
file, all set in Japanese.

00:34:45.550 --> 00:34:48.550
And all you have to do now is
simply put this back into the

00:34:48.550 --> 00:34:50.820
right place in your
application.

00:34:50.820 --> 00:34:53.420
And your application will
be ready in Japanese.

00:34:53.420 --> 00:34:55.620
If you're using Android
Developer Tools, you can make

00:34:55.620 --> 00:34:58.120
this process even easier as
Android Developer Tools will

00:34:58.120 --> 00:35:01.230
automatically download them into
the correct locations in

00:35:01.230 --> 00:35:02.504
your application for you.

00:35:05.230 --> 00:35:12.180
So now after this process, your
app should be properly

00:35:12.180 --> 00:35:12.930
translated.

00:35:12.930 --> 00:35:15.010
If you're interested in trying
this out, this is a pilot

00:35:15.010 --> 00:35:17.110
program starting in
Developer Console.

00:35:17.110 --> 00:35:19.910
So be sure to sign up for
the pilot program.

00:35:19.910 --> 00:35:22.170
And you can find this sign-up
under the APK

00:35:22.170 --> 00:35:23.420
page for a given app.

00:35:27.230 --> 00:35:28.970
So now all of your strings
are translated.

00:35:28.970 --> 00:35:29.710
Are you done?

00:35:29.710 --> 00:35:30.190
Not yet.

00:35:30.190 --> 00:35:33.910
There's one more step--
testing your app.

00:35:33.910 --> 00:35:36.690
The first and more important
thing for you to test is the

00:35:36.690 --> 00:35:39.330
layout, making sure that your
app translations didn't break

00:35:39.330 --> 00:35:40.220
your layout.

00:35:40.220 --> 00:35:43.060
And in Android Studio, as you
might have seen in the

00:35:43.060 --> 00:35:45.410
keynote, we're providing a
really easy way to do this,

00:35:45.410 --> 00:35:47.790
where you can see the different
layouts for

00:35:47.790 --> 00:35:51.260
different locales all at once
and see the translations in

00:35:51.260 --> 00:35:52.090
those layouts.

00:35:52.090 --> 00:35:53.750
And in the translations
that are breaking,

00:35:53.750 --> 00:35:54.820
you have two options.

00:35:54.820 --> 00:35:57.060
You can either modify the layout
so that they don't

00:35:57.060 --> 00:35:59.460
break, or go back and talk to
your translators, to get an

00:35:59.460 --> 00:36:01.800
alternate translation.

00:36:01.800 --> 00:36:04.230
That's one piece of testing
you should do.

00:36:04.230 --> 00:36:06.700
For the next piece of testing,
I'll start out with a story

00:36:06.700 --> 00:36:09.200
for why that's important.

00:36:09.200 --> 00:36:11.530
So here's an example of a sign
that's been translated from

00:36:11.530 --> 00:36:13.110
English into Welsh.

00:36:13.110 --> 00:36:16.010
And to most users who only speak
English and not Welsh,

00:36:16.010 --> 00:36:18.670
this looks like a perfectly
normal well-translated sign.

00:36:18.670 --> 00:36:21.450
The English makes sense, and
you assume the Welsh down

00:36:21.450 --> 00:36:23.190
below also makes sense.

00:36:23.190 --> 00:36:25.390
But what does it actually
say in Welsh?

00:36:25.390 --> 00:36:27.600
Well, it says, I am not
at the office right.

00:36:27.600 --> 00:36:31.340
Now please send over any strings
to be translated.

00:36:31.340 --> 00:36:33.530
So it looks like somebody
made a mistake here.

00:36:33.530 --> 00:36:36.400
What happened here was the
translator was on vacation at

00:36:36.400 --> 00:36:38.620
the time these strings were
sent for translation.

00:36:38.620 --> 00:36:41.270
And the people who sent the
translations, who didn't speak

00:36:41.270 --> 00:36:43.520
Welsh, assumed that their
vacation responder was their

00:36:43.520 --> 00:36:44.730
actual translation.

00:36:44.730 --> 00:36:47.040
So they went off and
printed this sign.

00:36:47.040 --> 00:36:48.200
So what is this lesson here?

00:36:48.200 --> 00:36:51.260
The lesson is that doing just
visual checks isn't enough, if

00:36:51.260 --> 00:36:52.850
you don't understand
that language.

00:36:52.850 --> 00:36:55.500
What you need to do is speak
to native speakers of that

00:36:55.500 --> 00:36:57.470
language and make sure
your app makes sense

00:36:57.470 --> 00:36:58.780
in that given language.

00:36:58.780 --> 00:37:00.810
So if you have friends or family
who speak a language

00:37:00.810 --> 00:37:03.070
that you're translating your
app into, that's easy.

00:37:03.070 --> 00:37:04.220
Just hand them the
app, and tell

00:37:04.220 --> 00:37:05.500
them to give you feedback.

00:37:05.500 --> 00:37:07.390
But what if you don't?

00:37:07.390 --> 00:37:09.490
Well, thankfully Play Developer
Console just

00:37:09.490 --> 00:37:12.060
recently launched alpha-beta
testing, which let's you

00:37:12.060 --> 00:37:14.300
incrementally roll out
your app to a very

00:37:14.300 --> 00:37:15.940
small subset of users.

00:37:15.940 --> 00:37:17.970
And that way you can get
feedback from these users,

00:37:17.970 --> 00:37:20.400
which aren't counted towards
your review, to help you fine

00:37:20.400 --> 00:37:22.450
tune your app, before
you launch it to

00:37:22.450 --> 00:37:27.200
100% in a given language.

00:37:27.200 --> 00:37:29.920
So that's it for all the tips
and tricks and all the various

00:37:29.920 --> 00:37:33.070
tools that can help you on your
journey to make your apps

00:37:33.070 --> 00:37:34.830
available to a global
audience.

00:37:34.830 --> 00:37:36.100
The next step is really easy.

00:37:36.100 --> 00:37:38.180
Once you've done all the
preparation, all the

00:37:38.180 --> 00:37:41.040
translation, and the testing,
just upload your APK to

00:37:41.040 --> 00:37:42.550
distribute in Google Play.

00:37:42.550 --> 00:37:44.520
And in the Developer Console,
there are settings where you

00:37:44.520 --> 00:37:46.440
can tweak the countries and
languages that you want to

00:37:46.440 --> 00:37:47.690
distribute your app into.

00:37:50.010 --> 00:37:51.400
So that's it for our talk.

00:37:51.400 --> 00:37:52.600
We hope you found it useful.

00:37:52.600 --> 00:37:55.740
And we're really excited to see
more apps available to a

00:37:55.740 --> 00:37:57.850
global audience in
Google Play.

00:37:57.850 --> 00:37:58.460
Thank you.

00:37:58.460 --> 00:38:01.160
And if you have any questions,
we can answer--

00:38:01.160 --> 00:38:02.500
we have two minutes to
answer questions now.

00:38:02.500 --> 00:38:04.330
But you can drop by
office hours later

00:38:04.330 --> 00:38:06.382
to ask us more questions.

00:38:06.382 --> 00:38:07.374
FABRICE DIMEGLIO: Thank you.

00:38:07.374 --> 00:38:08.862
YIWEN ZHAN: Thank you.

00:38:08.862 --> 00:38:13.822
[APPLAUSE]

00:38:13.822 --> 00:38:14.450
YIWEN ZHAN: Question?

00:38:14.450 --> 00:38:15.640
AUDIENCE: Hi, there.

00:38:15.640 --> 00:38:19.250
Loving the translations, but
my translators are my users

00:38:19.250 --> 00:38:21.050
who are great at volunteering.

00:38:21.050 --> 00:38:23.280
Can I use that fantastic
tool to let them do the

00:38:23.280 --> 00:38:24.300
translation?

00:38:24.300 --> 00:38:25.820
YIWEN ZHAN: Yes, that's a great
question, and that's

00:38:25.820 --> 00:38:28.450
something that we've thought
about in the past as well.

00:38:28.450 --> 00:38:30.740
Right now, we're launching
it only to professional

00:38:30.740 --> 00:38:33.780
translators, in that we wanted
to promote high-quality

00:38:33.780 --> 00:38:34.440
translations.

00:38:34.440 --> 00:38:37.990
But that's definitely the next
step that we're going towards.

00:38:37.990 --> 00:38:38.670
AUDIENCE: Can you--

00:38:38.670 --> 00:38:39.490
any hints?

00:38:39.490 --> 00:38:40.890
Timing?

00:38:40.890 --> 00:38:41.920
YIWEN ZHAN: Unfortunately,
I can't promise

00:38:41.920 --> 00:38:43.130
anything right now.

00:38:43.130 --> 00:38:44.480
But we're definitely keeping
that in mind.

00:38:44.480 --> 00:38:44.710
AUDIENCE: That'd be great.

00:38:44.710 --> 00:38:45.780
And, I mean, just one point--

00:38:45.780 --> 00:38:47.890
the users, they actually know
the context of the app.

00:38:47.890 --> 00:38:48.860
And they know what
that stuff means.

00:38:48.860 --> 00:38:50.270
YIWEN ZHAN: Definitely,
I agree.

00:38:50.270 --> 00:38:53.200
Thank you.

00:38:53.200 --> 00:38:56.050
AUDIENCE: So if we have an app
that's gone through several

00:38:56.050 --> 00:39:00.420
revisions, and it's translated
in several languages, and

00:39:00.420 --> 00:39:05.170
we're adding some activities,
adding some new strings, how

00:39:05.170 --> 00:39:09.890
do we manage getting just
getting those new strings

00:39:09.890 --> 00:39:11.000
translated?

00:39:11.000 --> 00:39:13.320
YIWEN ZHAN: Yes, and that's
also a great question.

00:39:13.320 --> 00:39:16.410
And that's something that
we're keeping in mind.

00:39:16.410 --> 00:39:18.390
Right now, we don't offer that
support in the pilot program.

00:39:18.390 --> 00:39:21.180
But we're working very fast to
offer support for that, in

00:39:21.180 --> 00:39:23.610
terms of allowing you to
incrementally translate the

00:39:23.610 --> 00:39:24.700
new strings in your app.

00:39:24.700 --> 00:39:26.430
So that will be coming
really soon.

00:39:26.430 --> 00:39:27.680
AUDIENCE: Thank you.

00:39:29.830 --> 00:39:32.860
YIWEN ZHAN: Any other
questions?

00:39:32.860 --> 00:39:34.510
AUDIENCE: One of the things
that I've found really

00:39:34.510 --> 00:39:38.760
difficult is doing the actual
layouts that are agnostic of

00:39:38.760 --> 00:39:39.730
text length.

00:39:39.730 --> 00:39:41.340
One of the things that we
developed at [INAUDIBLE]

00:39:41.340 --> 00:39:44.890
was a text view that
automatically resizes based on

00:39:44.890 --> 00:39:48.480
the character length and just
had a minimum size.

00:39:48.480 --> 00:39:51.430
So I was wondering if you guys
thought about offering

00:39:51.430 --> 00:39:52.130
anything like that?

00:39:52.130 --> 00:39:54.250
Because that would be really
useful for getting around the

00:39:54.250 --> 00:39:57.560
pain of internationalizing
actual layouts.

00:39:57.560 --> 00:40:00.080
YIWEN ZHAN: Yeah, that's
really good feedback.

00:40:00.080 --> 00:40:01.190
We'll keep that in mind.

00:40:01.190 --> 00:40:04.040
We'll talk to the Android
[INAUDIBLE] team.

00:40:04.040 --> 00:40:06.320
Thank you.

00:40:06.320 --> 00:40:08.240
AUDIENCE: Is the translation
tool able to handle things

00:40:08.240 --> 00:40:12.490
like XML entities, Unicode
characters, or you've got

00:40:12.490 --> 00:40:14.550
anything special
to handle this?

00:40:14.550 --> 00:40:17.070
YIWEN ZHAN: Yes, most of those
should be handled within the

00:40:17.070 --> 00:40:17.870
translation tool.

00:40:17.870 --> 00:40:22.460
So we handle almost all things
that have some sort of

00:40:22.460 --> 00:40:23.710
international standard
to them.

00:40:23.710 --> 00:40:24.155
AUDIENCE: Great.

00:40:24.155 --> 00:40:25.816
Thank you.

00:40:25.816 --> 00:40:27.342
FABRICE DIMEGLIO: OK, I think
we need to close.

00:40:27.342 --> 00:40:27.840
YIWEN ZHAN: OK.

00:40:27.840 --> 00:40:28.830
I think we're out of time.

00:40:28.830 --> 00:40:30.700
But if you have more questions,
you can drop by

00:40:30.700 --> 00:40:31.570
office hours.

00:40:31.570 --> 00:40:33.890
We were also passing out
stickers earlier during the

00:40:33.890 --> 00:40:36.920
talk for localized Androids, as
you can see on my laptop.

00:40:36.920 --> 00:40:39.820
We have about them available
in 13 different languages.

00:40:39.820 --> 00:40:42.380
So if you want more of those,
also drop by office hours.

00:40:42.380 --> 00:40:42.970
Thank you.

00:40:42.970 --> 00:40:43.410
FABRICE DIMEGLIO: Thank you.

00:40:43.410 --> 00:40:44.660
Bye.

