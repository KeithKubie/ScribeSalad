WEBVTT
Kind: captions
Language: en

00:00:03.070 --> 00:00:03.310
DIRK BALFANZ: So, OK.

00:00:03.310 --> 00:00:05.210
Welcome everybody to the--

00:00:05.210 --> 00:00:07.700
I think it's about the last
session of the day here.

00:00:07.700 --> 00:00:09.690
My name is Dirk Balfanz.

00:00:09.690 --> 00:00:13.080
I'm a member of the Security
Team at Google, where I work

00:00:13.080 --> 00:00:18.190
on authentication, user
authentication issues: things

00:00:18.190 --> 00:00:21.320
like 2 factor authentication,
OpenID,

00:00:21.320 --> 00:00:23.210
OAuth, things like that.

00:00:23.210 --> 00:00:25.980
The title of the session
is ClientLogin #FAIL.

00:00:25.980 --> 00:00:28.900
There's a URL down here on the
slide, where you can leave

00:00:28.900 --> 00:00:32.180
real time feedback about
the session.

00:00:32.180 --> 00:00:35.170
It's goo.gl/2Qxx6.

00:00:35.170 --> 00:00:39.800
And the hashtags for this
track are GoogleAPIs in

00:00:39.800 --> 00:00:42.750
addition to the io2011.

00:00:42.750 --> 00:00:45.520
So what we're going to talk
about in this session are

00:00:45.520 --> 00:00:49.140
installed applications, and in
particular, what you need to

00:00:49.140 --> 00:00:52.940
do when you need to authenticate
Google APIs from

00:00:52.940 --> 00:00:55.740
an installed application.

00:00:55.740 --> 00:01:00.570
Traditionally the API you use
to obtain authentication

00:01:00.570 --> 00:01:03.700
tokens for installed application
is called

00:01:03.700 --> 00:01:04.849
ClientLogin.

00:01:04.849 --> 00:01:07.530
But I'm going to explain why
ClientLogin is actually not a

00:01:07.530 --> 00:01:10.170
good choice for your users.

00:01:10.170 --> 00:01:12.540
I'm going to briefly talk a
little bit about application

00:01:12.540 --> 00:01:16.420
specific passwords, which are
sort of a stopgap for

00:01:16.420 --> 00:01:19.380
applications that can't move
away from ClientLogin.

00:01:19.380 --> 00:01:23.850
But most of the time I'm going
to talk about OAuth, OAuth 2.0

00:01:23.850 --> 00:01:27.190
in particular, and how it can
be used for installed

00:01:27.190 --> 00:01:28.260
applications.

00:01:28.260 --> 00:01:30.840
And I expect to be talking
about 45 minutes or so,

00:01:30.840 --> 00:01:32.940
leaving time for questions
at the end.

00:01:35.650 --> 00:01:37.220
So--

00:01:37.220 --> 00:01:37.700
Excuse me.

00:01:37.700 --> 00:01:40.450
So what are installed
applications?

00:01:40.450 --> 00:01:43.080
Installed applications are
anything that the user

00:01:43.080 --> 00:01:48.160
downloads on their machine,
installs and that are not

00:01:48.160 --> 00:01:49.470
bound by the rules of the web.

00:01:49.470 --> 00:01:51.870
There's no same origin policy
that this application

00:01:51.870 --> 00:01:53.740
needs to abide by.

00:01:53.740 --> 00:01:58.010
They have access to a whole
bunch of platform APIs that

00:01:58.010 --> 00:01:59.920
you couldn't access otherwise
from a web

00:01:59.920 --> 00:02:01.490
application, for example.

00:02:01.490 --> 00:02:04.830
So if you have a video editor
that uploads videos to

00:02:04.830 --> 00:02:07.100
YouTube, that's an installed
application.

00:02:07.100 --> 00:02:11.700
If you have a photo viewer that
can access your Picasa

00:02:11.700 --> 00:02:14.250
web albums, that's an installed
application.

00:02:14.250 --> 00:02:18.250
Your IMAP clients, your
Thunderbirds, your Mac Mails,

00:02:18.250 --> 00:02:21.310
your Talk clients,
and so forth.

00:02:21.310 --> 00:02:22.425
Those are all installed
applications.

00:02:22.425 --> 00:02:24.370
And the ones that we're
interested in here are the

00:02:24.370 --> 00:02:28.050
ones that need to authenticate
to Google APIs.

00:02:28.050 --> 00:02:30.320
Your iPhone apps, your Android
apps, those are installed

00:02:30.320 --> 00:02:33.370
applications, the native apps
that you get from the Android

00:02:33.370 --> 00:02:38.730
market and the App Store,
I guess it's called.

00:02:38.730 --> 00:02:41.850
And you guys, as developers,
you probably deal with just

00:02:41.850 --> 00:02:44.790
your command line tools that
sometimes also need to

00:02:44.790 --> 00:02:46.770
authenticate to Google APIs--

00:02:46.770 --> 00:02:49.620
for example, the App Engine
config tool that you use.

00:02:49.620 --> 00:02:51.950
And there's a bunch of
screenshots of a variety of

00:02:51.950 --> 00:02:55.550
installed applications
on the slide.

00:02:55.550 --> 00:02:59.170
So I mentioned previously that
today, what installed

00:02:59.170 --> 00:03:02.460
applications often do is when
they need to authenticate to a

00:03:02.460 --> 00:03:06.490
Google API, they used this
endpoint that we have called

00:03:06.490 --> 00:03:09.630
ClientLogin to exchange,
basically, a username and

00:03:09.630 --> 00:03:11.770
password for an auth token.

00:03:11.770 --> 00:03:14.310
Then you take the auth token,
and you take it to your

00:03:14.310 --> 00:03:17.240
application, your
API endpoint.

00:03:17.240 --> 00:03:17.850
And that's how you

00:03:17.850 --> 00:03:19.960
authenticate to the API endpoint.

00:03:19.960 --> 00:03:22.270
The user experience looks
something like this.

00:03:22.270 --> 00:03:25.090
The application draws some
window on the screen

00:03:25.090 --> 00:03:25.800
and says, hey user.

00:03:25.800 --> 00:03:26.760
What is your username?

00:03:26.760 --> 00:03:27.886
What is your password?

00:03:27.886 --> 00:03:29.830
The user enters the username
and password.

00:03:29.830 --> 00:03:34.250
And then the app takes that to
the ClientLogin endpoint.

00:03:34.250 --> 00:03:36.615
Whenever I have a little demo
thing on the slide, I'm going

00:03:36.615 --> 00:03:38.430
to try and show you
how this works.

00:03:38.430 --> 00:03:41.290
Don't let me go through a slide
that has one of the demo

00:03:41.290 --> 00:03:42.850
things on there without
actually doing it.

00:03:42.850 --> 00:03:44.100
I might forget.

00:03:46.870 --> 00:03:50.640
So I have a little cheat
sheet here also.

00:03:50.640 --> 00:03:52.870
You do not want to have
to wait for me typing.

00:03:52.870 --> 00:03:55.290
Trust me.

00:03:55.290 --> 00:03:57.010
So hitting the ClientLogin
endpoint is

00:03:57.010 --> 00:03:57.870
really pretty easy.

00:03:57.870 --> 00:04:00.860
All you need is curl
basically.

00:04:00.860 --> 00:04:04.420
So it's on google.com/accou
nts/ClientLogin.

00:04:04.420 --> 00:04:06.380
If you give it an email,
you give your password.

00:04:06.380 --> 00:04:10.020
And you say which service
you want to access.

00:04:10.020 --> 00:04:14.940
In this case, CP is the address
book, the contact API.

00:04:14.940 --> 00:04:18.190
And that returns a bunch
of auth tokens.

00:04:18.190 --> 00:04:19.730
The one that's interesting
here is the

00:04:19.730 --> 00:04:22.790
third one down here.

00:04:22.790 --> 00:04:24.040
Let me extract that.

00:04:30.140 --> 00:04:31.745
So now you have the auth
token that you can use

00:04:31.745 --> 00:04:34.220
to access an API.

00:04:34.220 --> 00:04:38.610
So again, curl is really all
you need here for this.

00:04:38.610 --> 00:04:41.115
You put the auth token in
an authorization header.

00:04:41.115 --> 00:04:42.970
It says GoogleLogin
auth=token.

00:04:42.970 --> 00:04:46.680
And then we hit the endpoint
for the contact's API.

00:04:46.680 --> 00:04:48.650
And you get back a whole
bunch of JSON.

00:04:48.650 --> 00:04:53.450
Let me see if I can clean out
the JSON with a little

00:04:53.450 --> 00:04:58.330
function here that just sort
of filters stuff out.

00:04:58.330 --> 00:05:00.612
Sorry.

00:05:00.612 --> 00:05:02.590
OK.

00:05:02.590 --> 00:05:05.720
Let me fetch the JSON here.

00:05:05.720 --> 00:05:07.470
Is it in there?

00:05:07.470 --> 00:05:08.400
Yup.

00:05:08.400 --> 00:05:12.870
And so this is names.

00:05:12.870 --> 00:05:14.400
It was just a little function
that filters--

00:05:14.400 --> 00:05:15.540
goes to the JSON [INAUDIBLE].

00:05:15.540 --> 00:05:17.960
So this is the complete address
book of this example

00:05:17.960 --> 00:05:19.610
user that I started off with.

00:05:19.610 --> 00:05:21.260
There's only two people
in there.

00:05:21.260 --> 00:05:23.480
OK, so that's how ClientLogin
works.

00:05:26.370 --> 00:05:29.220
But sometimes it doesn't.

00:05:29.220 --> 00:05:32.740
There's a bunch of different use
cases in which ClientLogin

00:05:32.740 --> 00:05:33.850
stops working.

00:05:33.850 --> 00:05:35.470
Here's one of them: CAPTCHAs.

00:05:35.470 --> 00:05:37.890
Sometimes the Google log in
system decides to throw a

00:05:37.890 --> 00:05:41.360
CAPTCHA at the user
after they log in.

00:05:41.360 --> 00:05:44.390
Maybe because the log in
looked suspicious.

00:05:44.390 --> 00:05:47.580
We're suspecting that this might
be a bot that has maybe

00:05:47.580 --> 00:05:50.360
stolen the password and
is not the real user.

00:05:50.360 --> 00:05:53.320
And to try to distinguish
bots from users,

00:05:53.320 --> 00:05:54.870
we throw out CAPTCHAs.

00:05:54.870 --> 00:05:56.940
And there's actually a provision
in the ClientLogin

00:05:56.940 --> 00:05:58.630
protocol to deal
with CAPTCHAs.

00:05:58.630 --> 00:06:02.590
The server could signal that
a CAPTCHA solution

00:06:02.590 --> 00:06:04.350
by the user is needed.

00:06:04.350 --> 00:06:08.750
But many installed applications
either don't

00:06:08.750 --> 00:06:11.170
implement that part of the
protocol or maybe implement it

00:06:11.170 --> 00:06:12.050
incorrectly.

00:06:12.050 --> 00:06:15.230
And as a result, what you have
is that a user, that if they

00:06:15.230 --> 00:06:18.290
were to log in through the
web, they would log in.

00:06:18.290 --> 00:06:19.080
They would see the CAPTCHA.

00:06:19.080 --> 00:06:20.310
They would solve the CAPTCHA.

00:06:20.310 --> 00:06:21.700
And they would be on
their merry way.

00:06:21.700 --> 00:06:24.430
If they used one of those
applications that maybe

00:06:24.430 --> 00:06:27.660
doesn't implement the CAPTCHA
part quite right, they are

00:06:27.660 --> 00:06:28.700
actually stuck.

00:06:28.700 --> 00:06:32.130
And they can't use
that application.

00:06:32.130 --> 00:06:35.390
Another application is 2-Step
Verification, our 2 factor

00:06:35.390 --> 00:06:39.770
auth solution that we launched
a couple months ago.

00:06:39.770 --> 00:06:42.150
And while I said there was a
provision in the protocol for

00:06:42.150 --> 00:06:46.250
CAPTCHAs, there is actually no
programmatic equivalent for

00:06:46.250 --> 00:06:48.090
2-Step Verification.

00:06:48.090 --> 00:06:53.010
So if you're logging into Google
on the website, you

00:06:53.010 --> 00:06:54.570
would type username
and password.

00:06:54.570 --> 00:06:58.360
And then you would see as the
next page, a page that asks

00:06:58.360 --> 00:06:59.620
you for your one
time password.

00:06:59.620 --> 00:07:00.670
And you would enter that.

00:07:00.670 --> 00:07:04.540
And then you would be logged in
to your application or into

00:07:04.540 --> 00:07:05.770
Google in general.

00:07:05.770 --> 00:07:09.270
There's no equivalent of this
on the programmatic side, on

00:07:09.270 --> 00:07:11.010
the ClientLogin endpoint.

00:07:11.010 --> 00:07:14.860
So users that have signed up for
2-Step Verification cannot

00:07:14.860 --> 00:07:15.920
use ClientLogin.

00:07:15.920 --> 00:07:18.220
It doesn't work for them.

00:07:18.220 --> 00:07:20.350
Here's another example:
OpenID.

00:07:20.350 --> 00:07:24.600
Google is a relying party
to, at this point,

00:07:24.600 --> 00:07:28.020
Yahoo, HotMail and AOL.

00:07:28.020 --> 00:07:31.445
So users that have usernames
that are at yahoo.com, at

00:07:31.445 --> 00:07:35.570
hotmail.com, and so forth, can
choose to turn on OpenID.

00:07:35.570 --> 00:07:38.420
And what happens when one of
those users goes to the Google

00:07:38.420 --> 00:07:41.440
log in page, they actually
get redirected

00:07:41.440 --> 00:07:44.280
to Yahoo, for example.

00:07:44.280 --> 00:07:46.220
And that's where they type
in their password.

00:07:46.220 --> 00:07:49.210
Yahoo becomes what we call
an identity provider.

00:07:49.210 --> 00:07:51.390
And then they get redirected
to Google, which plays the

00:07:51.390 --> 00:07:53.370
role of the relying party.

00:07:53.370 --> 00:07:55.600
And that's how you log in.

00:07:55.600 --> 00:07:59.860
And again, if you have a user
like that, ClientLogin doesn't

00:07:59.860 --> 00:08:03.910
work for them, because they
actually log in at Yahoo, and

00:08:03.910 --> 00:08:04.780
not at Google.

00:08:04.780 --> 00:08:07.485
And there's no programmatic
equivalent of this sort of log

00:08:07.485 --> 00:08:08.920
in dance that OpenID uses.

00:08:11.660 --> 00:08:12.810
Here's another example.

00:08:12.810 --> 00:08:16.250
When we make acquisitions, like
YouTube or something like

00:08:16.250 --> 00:08:19.920
that, we try to harmonize the
account system so that users

00:08:19.920 --> 00:08:23.090
can log in to these new
services on the

00:08:23.090 --> 00:08:24.430
Google log in page.

00:08:24.430 --> 00:08:28.390
But sometimes there's sort of
some extra set up steps needed

00:08:28.390 --> 00:08:31.220
to make sure that the user
can use this new service.

00:08:31.220 --> 00:08:33.059
This happened, for example,
with YouTube.

00:08:33.059 --> 00:08:35.559
And I think on the first
slide, I had a little

00:08:35.559 --> 00:08:38.360
screenshot of a blog post
that shared the

00:08:38.360 --> 00:08:39.740
same name as the session.

00:08:39.740 --> 00:08:41.850
The YouTube team actually
blogged about this a couple

00:08:41.850 --> 00:08:43.870
months ago.

00:08:43.870 --> 00:08:48.750
So again, if you are logging in
on the web page, all that's

00:08:48.750 --> 00:08:51.510
necessary is you answer a
couple more questions.

00:08:51.510 --> 00:08:55.920
You get taken through additional
steps to sign in.

00:08:55.920 --> 00:08:56.980
And you're good to go.

00:08:56.980 --> 00:09:00.030
But if you were to connect to
ClientLogin, it would just

00:09:00.030 --> 00:09:01.640
say, oh you can't log
in to the service.

00:09:01.640 --> 00:09:03.150
This account is not in
the right state to

00:09:03.150 --> 00:09:05.820
log in for this service.

00:09:05.820 --> 00:09:09.150
And there's a bunch of
other examples where

00:09:09.150 --> 00:09:10.140
this doesn't work.

00:09:10.140 --> 00:09:14.830
I mentioned that Google is a
relying party to Yahoo, AOL

00:09:14.830 --> 00:09:17.900
and HotMail, meaning that users
type their password

00:09:17.900 --> 00:09:18.870
actually on those sites.

00:09:18.870 --> 00:09:20.870
And then they get redirected
to Google and log in there.

00:09:20.870 --> 00:09:23.470
We're also relying parties to
thousands and thousands of

00:09:23.470 --> 00:09:25.160
other identity providers.

00:09:25.160 --> 00:09:28.950
And this is in the Google Apps
world, in the enterprise world

00:09:28.950 --> 00:09:30.550
and universities.

00:09:30.550 --> 00:09:34.490
So there, an enterprise
or a university runs

00:09:34.490 --> 00:09:36.450
their own log in server.

00:09:36.450 --> 00:09:39.540
And users go there, log in
over there, type their

00:09:39.540 --> 00:09:40.490
password over there.

00:09:40.490 --> 00:09:41.560
And then they get redirected.

00:09:41.560 --> 00:09:45.950
The protocol used there is
SAML, which is a little

00:09:45.950 --> 00:09:46.820
different from OpenID.

00:09:46.820 --> 00:09:49.700
But it's basically
the same idea.

00:09:49.700 --> 00:09:52.210
And in this case, Google
doesn't even have the

00:09:52.210 --> 00:09:54.660
passwords for those users,
so ClientLogin

00:09:54.660 --> 00:09:58.310
couldn't possibly work.

00:09:58.310 --> 00:10:00.970
A couple more examples: other
account wizards for, for

00:10:00.970 --> 00:10:02.630
example, hijacked accounts.

00:10:02.630 --> 00:10:06.060
If a user comes to Google and
they type their username and

00:10:06.060 --> 00:10:09.610
password, and we have seen some
suspicious activity from

00:10:09.610 --> 00:10:11.770
the account that might indicate,
again, that the

00:10:11.770 --> 00:10:16.600
account maybe has been taken
over by a hacker, we may

00:10:16.600 --> 00:10:17.580
suspend your account.

00:10:17.580 --> 00:10:20.280
And instead of logging into
Google, we might say, hey,

00:10:20.280 --> 00:10:23.530
answer a few more questions to
make sure that you're really

00:10:23.530 --> 00:10:27.030
you and not the attacker that
highjacked your account.

00:10:27.030 --> 00:10:29.090
And we call that a
recovery flow.

00:10:29.090 --> 00:10:31.960
And again, that recovery
flow exists on the web.

00:10:31.960 --> 00:10:35.440
No programmatic equivalent
for it on

00:10:35.440 --> 00:10:37.520
the ClientLogin endpoint.

00:10:37.520 --> 00:10:40.590
And we may decide in the future
to add more speed bumps

00:10:40.590 --> 00:10:41.720
to the log in process.

00:10:41.720 --> 00:10:44.740
We might say, well, if you're
logging in from an unusual IP

00:10:44.740 --> 00:10:46.950
address for this account, or
from an unusual country from

00:10:46.950 --> 00:10:51.170
this account, we might ask you a
few more questions before we

00:10:51.170 --> 00:10:53.110
log you in to Google.

00:10:53.110 --> 00:10:54.990
And we might actually change
and adjust what

00:10:54.990 --> 00:10:56.260
those speed bumps are.

00:10:56.260 --> 00:10:57.700
On the web this is really
easy to do.

00:10:57.700 --> 00:10:59.840
We just change the web
pages we serve

00:10:59.840 --> 00:11:02.540
after the log in page.

00:11:02.540 --> 00:11:05.260
But in the programmatic world,
it's hard to do if you have

00:11:05.260 --> 00:11:08.560
clients out there that don't
know that Google might be

00:11:08.560 --> 00:11:11.670
throwing new speed bumps
at them during log in.

00:11:11.670 --> 00:11:15.720
So all those things don't
work in ClientLogin.

00:11:15.720 --> 00:11:21.900
So let me show you a demo of
what it looks like if you are

00:11:21.900 --> 00:11:24.765
a user for which ClientLogin
doesn't work, but you can log

00:11:24.765 --> 00:11:28.010
in on the web just fine.

00:11:28.010 --> 00:11:29.660
So this is the Google
homepage.

00:11:29.660 --> 00:11:30.950
Nobody's logged in right now.

00:11:30.950 --> 00:11:33.590
I click on log in.

00:11:33.590 --> 00:11:37.320
And I type a username that
ends in @yahoo.com.

00:11:37.320 --> 00:11:40.360
This is one of those
OpenID users.

00:11:40.360 --> 00:11:41.810
I don't have to type
in a password here.

00:11:41.810 --> 00:11:45.830
If I say sign in, I get
redirected to Yahoo.

00:11:45.830 --> 00:11:50.180
And I type my password
over here.

00:11:50.180 --> 00:11:51.150
And now I'm logged
in to Google.

00:11:51.150 --> 00:11:53.950
And I can use Google services
like Calendar and Picasa Web

00:11:53.950 --> 00:11:55.200
and so forth.

00:11:57.120 --> 00:11:58.370
OK.

00:12:04.960 --> 00:12:06.210
And let me also show you--

00:12:06.210 --> 00:12:09.080
I think, at this point--

00:12:09.080 --> 00:12:12.870
I also want to show you what
happens if one of those users

00:12:12.870 --> 00:12:14.580
tries to use ClientLogin.

00:12:14.580 --> 00:12:15.900
Where's my cheat sheet?

00:12:15.900 --> 00:12:18.140
Right here.

00:12:18.140 --> 00:12:20.920
So if I take the same user,
and I try to hit the

00:12:20.920 --> 00:12:25.330
ClientLogin endpoint, there's
the same account name here, I

00:12:25.330 --> 00:12:26.210
just get an error back.

00:12:26.210 --> 00:12:28.410
So I can log in on the web, but
I can't use ClientLogin.

00:12:32.040 --> 00:12:34.350
All right, so we've seen a
bunch of examples where

00:12:34.350 --> 00:12:35.470
ClientLogin fails.

00:12:35.470 --> 00:12:37.980
So one of the sort of
workarounds that we have are

00:12:37.980 --> 00:12:39.030
these things we call

00:12:39.030 --> 00:12:41.770
application-specific passwords.

00:12:41.770 --> 00:12:45.040
An application-specific
password is a

00:12:45.040 --> 00:12:46.350
computer-generated password--

00:12:46.350 --> 00:12:49.310
Google will generate
it for the user--

00:12:49.310 --> 00:12:50.610
that works just like
a password.

00:12:50.610 --> 00:12:53.100
In particular, you can't use
it on the ClientLogin

00:12:53.100 --> 00:12:56.350
endpoint, but you can
have many of them.

00:12:56.350 --> 00:12:58.770
They're labeled, the usernames,
when they ask

00:12:58.770 --> 00:13:00.280
Google to create new ones.

00:13:00.280 --> 00:13:01.760
And you can revoke them.

00:13:01.760 --> 00:13:04.580
And those are useful for clients
that, for whatever

00:13:04.580 --> 00:13:08.840
reason, can't really move away
from ClientLogin or other

00:13:08.840 --> 00:13:11.380
protocols that use username
and password based

00:13:11.380 --> 00:13:12.730
authentication.

00:13:12.730 --> 00:13:18.000
So if you have an iMap client,
a Chat client, Talk client,

00:13:18.000 --> 00:13:21.130
old Android devices that aren't
upgraded to the latest

00:13:21.130 --> 00:13:25.040
version, Exchange clients, and
so forth, users can go to a

00:13:25.040 --> 00:13:29.230
page that is linked from their
account overview page.

00:13:29.230 --> 00:13:32.330
And they can ask Google to
generate one of those

00:13:32.330 --> 00:13:35.900
application-specific
passwords for them.

00:13:35.900 --> 00:13:38.930
And then you take that password,
and you type it in

00:13:38.930 --> 00:13:40.790
the password field
of wherever the

00:13:40.790 --> 00:13:42.040
application asks for a password.

00:13:48.400 --> 00:13:49.680
So that sounds pretty good.

00:13:49.680 --> 00:13:53.900
And it works with Legacy Clients
for many of the use

00:13:53.900 --> 00:13:55.720
cases that I mentioned
earlier.

00:13:55.720 --> 00:13:58.020
It works for users that have
signed up for 2-Step

00:13:58.020 --> 00:13:59.230
Verification.

00:13:59.230 --> 00:14:01.810
It works for OpenID users.

00:14:01.810 --> 00:14:05.190
It could work for SAML users
if the enterprise admin has

00:14:05.190 --> 00:14:06.640
switched it on.

00:14:06.640 --> 00:14:09.490
But it does provide a pretty
bad user experience,

00:14:09.490 --> 00:14:10.960
especially if it's
on some device.

00:14:10.960 --> 00:14:13.510
If I want to configure the
exchange client on my iPhone

00:14:13.510 --> 00:14:14.270
or something.

00:14:14.270 --> 00:14:18.660
I probably would need to walk
up to my desktop and log in.

00:14:18.660 --> 00:14:19.700
Go to the accounts page.

00:14:19.700 --> 00:14:21.690
Go to the application-specific
passwords page.

00:14:21.690 --> 00:14:23.710
Generate one of those
passwords.

00:14:23.710 --> 00:14:24.530
Copy it over.

00:14:24.530 --> 00:14:26.760
It's not that great.

00:14:26.760 --> 00:14:30.470
And some of those use cases that
I talked about actually

00:14:30.470 --> 00:14:31.560
still don't work even with

00:14:31.560 --> 00:14:33.130
application-specific passwords.

00:14:33.130 --> 00:14:35.610
If your account is suspended
because of some hijacking

00:14:35.610 --> 00:14:37.400
suspicion, it's suspended.

00:14:37.400 --> 00:14:40.090
And you have to go through
a web flow to

00:14:40.090 --> 00:14:42.330
recover your password.

00:14:42.330 --> 00:14:46.370
If it's one of those set up
situations where the account

00:14:46.370 --> 00:14:50.290
is to be set up for YouTube or
something, you have to do that

00:14:50.290 --> 00:14:50.740
on the web.

00:14:50.740 --> 00:14:55.420
And the application specific
password just won't work.

00:14:55.420 --> 00:14:59.440
So really the message is, when
ClientLogin fails, just stop

00:14:59.440 --> 00:15:00.300
using ClientLogin.

00:15:00.300 --> 00:15:02.320
Just don't do it.

00:15:02.320 --> 00:15:08.320
And what you're supposed to
use instead is OAuth.

00:15:08.320 --> 00:15:11.520
You may have heard that OAuth
is used, or probably know,

00:15:11.520 --> 00:15:17.180
that OAuth is used a lot on the
web for connecting what

00:15:17.180 --> 00:15:20.070
are also called relying parties
to service providers.

00:15:20.070 --> 00:15:23.170
But it does also work for
installed applications.

00:15:23.170 --> 00:15:24.750
And in fact, you don't even
need a web browser.

00:15:24.750 --> 00:15:28.700
And I'll demo that
in a moment.

00:15:28.700 --> 00:15:33.270
The idea is basically in OAuth
that instead of asking the

00:15:33.270 --> 00:15:35.710
user to type in their username
and password directly into the

00:15:35.710 --> 00:15:38.730
application, you use
a web browser.

00:15:38.730 --> 00:15:40.840
You either launch the web
browser that's available on

00:15:40.840 --> 00:15:45.490
the platform and ask the user to
complete the OAuth flow in

00:15:45.490 --> 00:15:46.100
the browser.

00:15:46.100 --> 00:15:50.140
Or you frame a WebView.

00:15:50.140 --> 00:15:53.950
Those are available on all
platforms that I know of.

00:15:53.950 --> 00:15:55.710
And you take the user
through the OAuth

00:15:55.710 --> 00:15:57.560
flow in that WebView.

00:15:57.560 --> 00:16:02.490
So in the browser the
user authenticates.

00:16:02.490 --> 00:16:05.370
They may get redirected
to Yahoo or wherever.

00:16:05.370 --> 00:16:07.620
They may be asked for
their second factor.

00:16:07.620 --> 00:16:08.850
They may be asked
for a CAPTCHA.

00:16:08.850 --> 00:16:10.690
They may be asked for all sorts
of things, but at some

00:16:10.690 --> 00:16:13.040
point they're going
to be logged in.

00:16:13.040 --> 00:16:16.110
And then they see this OAuth
approval screen, where they're

00:16:16.110 --> 00:16:18.980
being told what kind of
privileges they're giving to

00:16:18.980 --> 00:16:20.340
the installed application.

00:16:20.340 --> 00:16:23.370
And then the user has a chance
to click on Allow Access.

00:16:23.370 --> 00:16:27.660
And then the installed app ends
up with the OAuth token.

00:16:27.660 --> 00:16:31.160
And those OAuth tokens are
really easy to use.

00:16:31.160 --> 00:16:34.220
In OAuth 2.0, there's no more
signatures, no more crypto.

00:16:34.220 --> 00:16:37.540
It's really all quite easy.

00:16:37.540 --> 00:16:39.620
You stick them even in the same
place that ClientLogin

00:16:39.620 --> 00:16:41.240
tokens used to go.

00:16:41.240 --> 00:16:44.020
It's in the authorization
header.

00:16:44.020 --> 00:16:44.940
Put the token right there.

00:16:44.940 --> 00:16:50.070
You can use that to access
the Google API endpoints.

00:16:50.070 --> 00:16:54.020
The only difference is that
ClientLogin tokens are

00:16:54.020 --> 00:16:56.590
typically valid for about
two weeks or so.

00:16:56.590 --> 00:16:59.760
OAuth tokens are valid
for about an hour.

00:16:59.760 --> 00:17:03.125
So the two week time frame
typically means that when the

00:17:03.125 --> 00:17:06.099
user interacts with your
application, they are done

00:17:06.099 --> 00:17:07.670
interacting with
the application

00:17:07.670 --> 00:17:09.640
before that token expires.

00:17:09.640 --> 00:17:12.819
But the one hour expiration
time is not so sure.

00:17:12.819 --> 00:17:17.660
So what do you need to do is
actually get a fresh OAuth

00:17:17.660 --> 00:17:19.910
token when the OAuth token
stops working.

00:17:19.910 --> 00:17:22.599
So what happens is that out of
the OAuth flow, you end up

00:17:22.599 --> 00:17:23.319
with two tokens.

00:17:23.319 --> 00:17:26.319
There's a refresh token that
doesn't expire-- it lasts

00:17:26.319 --> 00:17:28.560
forever until the user
revokes it--

00:17:28.560 --> 00:17:31.710
but cannot be used to access
API endpoints.

00:17:31.710 --> 00:17:33.560
And then there's the
access token.

00:17:33.560 --> 00:17:36.680
That's the thing that you take
to the OAuth endpoint in lieu

00:17:36.680 --> 00:17:38.720
of the ClientLogin token.

00:17:38.720 --> 00:17:40.620
And that's the thing that
expires after an hour.

00:17:40.620 --> 00:17:44.730
So you need to write your code
such that if and when the

00:17:44.730 --> 00:17:47.400
access token stops working, use
the refresh token to help

00:17:47.400 --> 00:17:48.720
yourself to a new
access token.

00:17:48.720 --> 00:17:50.230
And then you use that.

00:17:50.230 --> 00:17:53.020
That's the only difference
really to ClientLogin.

00:17:53.020 --> 00:17:56.340
And we have explained this in
our developer documentation.

00:17:56.340 --> 00:18:00.320
If you search for OAuth 2.0
Google, you get to a page that

00:18:00.320 --> 00:18:03.300
not only explains OAuth 2.0 in
general, but in particular

00:18:03.300 --> 00:18:06.950
sort of customizes it for the
Google endpoints that we use

00:18:06.950 --> 00:18:08.820
for OAuth 2.0.

00:18:11.630 --> 00:18:15.280
The next two slides I have
just show you what the UI

00:18:15.280 --> 00:18:18.440
typically looks like to the user
when an application uses

00:18:18.440 --> 00:18:20.370
OAuth instead of ClientLogin.

00:18:20.370 --> 00:18:23.540
So just as a reminder, on the
web if you have a relying

00:18:23.540 --> 00:18:28.470
party, it's a web app that, say,
wants to get access to

00:18:28.470 --> 00:18:32.790
some parts of the account that
the user has in Google, for

00:18:32.790 --> 00:18:34.150
example, the address book.

00:18:34.150 --> 00:18:38.680
Then what the relying party,
the web app, does, it says,

00:18:38.680 --> 00:18:41.050
hey, I would really like to have
access to your address

00:18:41.050 --> 00:18:44.410
book because I want to help you
manage your address book,

00:18:44.410 --> 00:18:46.040
for example.

00:18:46.040 --> 00:18:48.530
So click if you want to set
up that functionality.

00:18:48.530 --> 00:18:49.220
The user clicks that.

00:18:49.220 --> 00:18:50.680
They get redirected to Google.

00:18:50.680 --> 00:18:55.040
They see a screen like this one
on the slide right now.

00:18:55.040 --> 00:18:57.825
And then chances are, they are
already logged in because they

00:18:57.825 --> 00:18:59.420
are Google users, and
they're logged in.

00:18:59.420 --> 00:19:02.480
So they immediately see
this page right here.

00:19:02.480 --> 00:19:04.640
And then they click
on Allow Access.

00:19:04.640 --> 00:19:09.170
And then Google redirects back
to that relying party with the

00:19:09.170 --> 00:19:10.670
OAuth token in the
redirect URL.

00:19:10.670 --> 00:19:12.930
And that's how the relying
party ends up

00:19:12.930 --> 00:19:15.650
with the OAuth token.

00:19:15.650 --> 00:19:18.170
So what does it look like for
installed applications?

00:19:18.170 --> 00:19:22.580
Here's a screenshot from an
app that we ship to our

00:19:22.580 --> 00:19:24.780
enterprise customers.

00:19:24.780 --> 00:19:26.540
And it runs on Windows.

00:19:26.540 --> 00:19:27.690
And you can see it
really doesn't

00:19:27.690 --> 00:19:28.430
look that much different.

00:19:28.430 --> 00:19:32.520
On the left there is a native
window on Microsoft Windows,

00:19:32.520 --> 00:19:35.295
where we explain to the user, if
you click here, we're going

00:19:35.295 --> 00:19:39.610
to launch the browser to set
up this application.

00:19:39.610 --> 00:19:41.440
And then the next thing the user
knows is that they are

00:19:41.440 --> 00:19:43.590
staring at the normal browser,
at the normal OAuth window.

00:19:43.590 --> 00:19:45.305
They're probably already
logged in.

00:19:45.305 --> 00:19:48.230
So the next thing they see
is this approval screen.

00:19:48.230 --> 00:19:50.400
They say Allow Access.

00:19:50.400 --> 00:19:53.010
And then the native application
puts itself back

00:19:53.010 --> 00:19:56.606
in the foreground and consumes
the OAuth token and takes it

00:19:56.606 --> 00:19:57.140
from there.

00:19:57.140 --> 00:20:00.970
So we wrote a little library
that we use internally to give

00:20:00.970 --> 00:20:05.810
to our teams that write native
apps for Windows.

00:20:05.810 --> 00:20:08.320
And we're in the process of
sort of cleaning it up a

00:20:08.320 --> 00:20:11.380
little bit so that it's
suitable for public

00:20:11.380 --> 00:20:11.940
consumption.

00:20:11.940 --> 00:20:15.250
And so, hopefully we will be
able to release this open

00:20:15.250 --> 00:20:19.000
source soon so you guys
have some help with

00:20:19.000 --> 00:20:20.250
this kind of flow.

00:20:25.600 --> 00:20:28.080
Next screenshot is from iOS.

00:20:28.080 --> 00:20:30.190
There we actually have a library
available right now

00:20:30.190 --> 00:20:31.650
that you can go and download.

00:20:31.650 --> 00:20:34.600
A few slides from now,
I'll have a link that

00:20:34.600 --> 00:20:36.470
points to the library.

00:20:36.470 --> 00:20:38.730
It looks very similar.

00:20:38.730 --> 00:20:41.320
I don't actually have
the shot of the app

00:20:41.320 --> 00:20:42.430
launching the process.

00:20:42.430 --> 00:20:46.280
I guess that would be sort of
the picture on the left of the

00:20:46.280 --> 00:20:49.680
first phone here, but
similar idea.

00:20:49.680 --> 00:20:52.235
You have an app that says, hey,
I'd like have access to

00:20:52.235 --> 00:20:53.040
the address book.

00:20:53.040 --> 00:20:53.670
Click here.

00:20:53.670 --> 00:20:54.240
The user clicks there.

00:20:54.240 --> 00:20:57.820
The next thing they see is
a WebView that takes them

00:20:57.820 --> 00:20:59.630
through the OAuth flow.

00:20:59.630 --> 00:21:01.710
So in this case, the
user has to log in.

00:21:01.710 --> 00:21:04.170
And then after they log
in, they see the

00:21:04.170 --> 00:21:06.290
OAuth approval page.

00:21:06.290 --> 00:21:07.780
They say, Allow Access.

00:21:07.780 --> 00:21:12.110
And then at that point, the
native app that is framing the

00:21:12.110 --> 00:21:15.540
WebView, in this case, would
just close the WebView, would

00:21:15.540 --> 00:21:20.220
help itself to the token and
would take it from there.

00:21:20.220 --> 00:21:23.850
And I actually have a
demo of that that

00:21:23.850 --> 00:21:25.140
uses a different library.

00:21:25.140 --> 00:21:25.960
And on the iPad--

00:21:25.960 --> 00:21:28.869
let me try and switch over and
show you how that works.

00:21:34.970 --> 00:21:36.220
I brought my iPad.

00:21:39.980 --> 00:21:40.580
Can you guys see that?

00:21:40.580 --> 00:21:41.390
OK, great.

00:21:41.390 --> 00:21:43.450
And I have an app on here that
you probably have heard about.

00:21:43.450 --> 00:21:44.650
It's called Flipboard.

00:21:44.650 --> 00:21:51.150
And Flipboard is an app that
sort of curates interesting

00:21:51.150 --> 00:21:54.330
news items by connecting to
various accounts that I might

00:21:54.330 --> 00:21:56.680
have, Facebook, Twitter,
and so forth.

00:21:56.680 --> 00:21:58.960
And one of the accounts
you can add is a

00:21:58.960 --> 00:22:00.626
Google Reader account.

00:22:00.626 --> 00:22:03.441
So let me show you
how that works.

00:22:03.441 --> 00:22:05.060
Add an account.

00:22:05.060 --> 00:22:06.310
Google Reader.

00:22:08.680 --> 00:22:10.710
And you can see it's
a WebView.

00:22:10.710 --> 00:22:13.010
I'm being redirected
to Google.

00:22:13.010 --> 00:22:16.310
Let's log in as of those users
for which ClientLogin doesn't

00:22:16.310 --> 00:22:17.560
actually work.

00:22:20.312 --> 00:22:21.562
[TYPING]

00:22:32.180 --> 00:22:33.810
DIRK BALFANZ: So that redirects
me to Yahoo.

00:22:33.810 --> 00:22:35.060
[TYPING]

00:22:48.120 --> 00:22:49.230
DIRK BALFANZ: So I log in.

00:22:49.230 --> 00:22:50.830
This is the approval screen.

00:22:50.830 --> 00:22:53.390
These guys actually use
our OAuth 1.0 version

00:22:53.390 --> 00:22:54.940
of the OAuth flow.

00:22:54.940 --> 00:22:57.540
It's actually a little bit more
complicated because in

00:22:57.540 --> 00:22:59.890
OAuth 1.0 there's still crypto
involved and so forth.

00:22:59.890 --> 00:23:03.270
And the approval screen is
not quite as pretty.

00:23:03.270 --> 00:23:07.540
But they have been having this
in place for awhile, since

00:23:07.540 --> 00:23:09.200
before we launched OAuth 2.0.

00:23:09.200 --> 00:23:12.890
So you guys probably want to
skip the whole OAuth 1.0

00:23:12.890 --> 00:23:16.610
version of this and skip
straight to OAuth 2.0.

00:23:16.610 --> 00:23:20.390
But the concept is really
exactly the same.

00:23:20.390 --> 00:23:23.110
And I say, Grant Access here.

00:23:23.110 --> 00:23:27.050
I get this new section in
Flipboard that is now

00:23:27.050 --> 00:23:28.870
connected to my Google
Reader account.

00:23:28.870 --> 00:23:32.840
And this worked for an account
for which ClientLogin is not

00:23:32.840 --> 00:23:34.090
functional.

00:23:35.720 --> 00:23:36.220
OK.

00:23:36.220 --> 00:23:38.072
Let's get back to the slides.

00:23:45.150 --> 00:23:49.500
So you might have noticed that
sometimes I used an external

00:23:49.500 --> 00:23:51.200
browser when I showed
you the screenshots

00:23:51.200 --> 00:23:52.150
of the Windows version.

00:23:52.150 --> 00:23:54.130
There was an external browser
that was launched.

00:23:54.130 --> 00:23:55.590
And sometimes we use WebViews.

00:23:55.590 --> 00:23:58.840
On the iOS examples, both the
screenshots I had of Google's

00:23:58.840 --> 00:24:00.340
own library, as well
as the Flipboard

00:24:00.340 --> 00:24:02.800
example used WebViews.

00:24:02.800 --> 00:24:06.390
So when should you use which?

00:24:06.390 --> 00:24:08.430
External browser
versus WebView.

00:24:08.430 --> 00:24:11.330
So I talked to a bunch
of developers at

00:24:11.330 --> 00:24:12.800
Google about this.

00:24:12.800 --> 00:24:17.130
And I got sort of sometimes
conflicting opinions on this.

00:24:17.130 --> 00:24:20.180
And I tried to sort of
synthesize what I'd learned

00:24:20.180 --> 00:24:23.700
into a set of three rules.

00:24:23.700 --> 00:24:27.080
And I'm not sure this is
necessarily the final word on

00:24:27.080 --> 00:24:28.080
this question.

00:24:28.080 --> 00:24:31.530
I'm actually also curious if you
guys have tried this and

00:24:31.530 --> 00:24:33.070
have come down one
way or another.

00:24:33.070 --> 00:24:37.420
I'm interested in hearing you
guys' opinion on this.

00:24:37.420 --> 00:24:40.880
But from the experience that
I have gained sort of

00:24:40.880 --> 00:24:43.580
vicariously by talking
to developers.

00:24:43.580 --> 00:24:46.510
This is the set of rules
that I came up with.

00:24:46.510 --> 00:24:47.600
Rule #1.

00:24:47.600 --> 00:24:51.260
Use an external browser like we
did in that screenshot from

00:24:51.260 --> 00:24:52.480
the Windows application.

00:24:52.480 --> 00:24:55.180
And the main advantage of using
an external browser is

00:24:55.180 --> 00:24:59.420
that very, very likely, your
user is already logged in.

00:24:59.420 --> 00:25:02.420
And they don't have to go
through the log in process:

00:25:02.420 --> 00:25:03.720
typing their password.

00:25:03.720 --> 00:25:05.320
Perhaps typing their OTP.

00:25:05.320 --> 00:25:07.590
Perhaps when they get redirected
to Yahoo-- you

00:25:07.590 --> 00:25:10.520
might have noticed I had to type
my username twice, once

00:25:10.520 --> 00:25:11.900
into Google and once
onto Yahoo.

00:25:11.900 --> 00:25:15.340
Because OpenID just isn't quite
convenient enough to

00:25:15.340 --> 00:25:17.560
carry that over from one
side to the other.

00:25:17.560 --> 00:25:20.590
So all those inconveniences
go away.

00:25:20.590 --> 00:25:23.610
And the user is very likely
already logged in.

00:25:23.610 --> 00:25:27.710
And they just have a one click
sort of approval experience at

00:25:27.710 --> 00:25:28.620
this point.

00:25:28.620 --> 00:25:30.510
And there's other
benefits too.

00:25:30.510 --> 00:25:35.380
The password is not typed
directly into the application.

00:25:35.380 --> 00:25:40.770
On the web we certainly do frown
upon it quite a bit, if

00:25:40.770 --> 00:25:45.850
a web app is asking for your
Google username and password.

00:25:45.850 --> 00:25:48.060
There it's considered
really bad practice.

00:25:48.060 --> 00:25:51.040
For installed applications, this
is a little more common.

00:25:51.040 --> 00:25:53.680
But really if you can avoid
it, it's just sort of nice

00:25:53.680 --> 00:25:57.490
security hygiene
not to do that.

00:25:57.490 --> 00:25:59.950
You could also imagine that
maybe you're in an enterprise

00:25:59.950 --> 00:26:02.690
setting, and the users use some
sort of plug-in that uses

00:26:02.690 --> 00:26:05.180
curb or also whatnot
to authenticate to

00:26:05.180 --> 00:26:08.160
their log in server.

00:26:08.160 --> 00:26:11.720
And those plug-ins tend to work
in stand-alone browsers,

00:26:11.720 --> 00:26:12.615
but not in WebViews.

00:26:12.615 --> 00:26:16.720
But more simply, if you just
think of password managers

00:26:16.720 --> 00:26:20.220
that users use to autofill their
username and password,

00:26:20.220 --> 00:26:23.830
those tend to work in
stand-alone browsers, but not

00:26:23.830 --> 00:26:26.340
in WebViews.

00:26:26.340 --> 00:26:27.240
Also imagine--

00:26:27.240 --> 00:26:30.260
I talked earlier a little bit
about these speed bumps that

00:26:30.260 --> 00:26:33.145
service providers sometimes
choose to throw into the log

00:26:33.145 --> 00:26:36.700
in process when something
looks unusual.

00:26:36.700 --> 00:26:39.470
And one of the things that
they might do is use

00:26:39.470 --> 00:26:41.970
risk-based authentication, where
they look at certain

00:26:41.970 --> 00:26:44.660
signals from the client.

00:26:44.660 --> 00:26:48.630
And those might look different
if you're using a stand-alone

00:26:48.630 --> 00:26:50.280
browser versus a WebView.

00:26:50.280 --> 00:26:53.120
So if you choose to use a
WebView, you might make it

00:26:53.120 --> 00:26:57.710
more likely for your users to go
through extra speed bumps.

00:26:57.710 --> 00:26:58.930
So that's Rule #1.

00:26:58.930 --> 00:26:59.730
Use an external browser.

00:26:59.730 --> 00:27:00.415
Rule #2.

00:27:00.415 --> 00:27:02.760
If that doesn't work,
use a WebView.

00:27:02.760 --> 00:27:03.850
Why might it not work?

00:27:03.850 --> 00:27:08.490
So for example in iOS, if you
launch an external browser,

00:27:08.490 --> 00:27:10.780
your application gets
put to sleep.

00:27:10.780 --> 00:27:12.822
And you don't really get
a guarantee that it's

00:27:12.822 --> 00:27:16.170
ever woken up again.

00:27:16.170 --> 00:27:20.610
In addition, there's no
back button on iOS.

00:27:20.610 --> 00:27:23.340
If the user decides that, oh,
they didn't really want to go

00:27:23.340 --> 00:27:26.000
there, they want to go back,
there's no good way to go back

00:27:26.000 --> 00:27:28.420
to the native application.

00:27:28.420 --> 00:27:30.510
Because your application is put
to sleep, the way it gets

00:27:30.510 --> 00:27:35.900
woken up is by it registering
a URL and handing that URL.

00:27:35.900 --> 00:27:37.990
But there's no guarantee that
there isn't some other app

00:27:37.990 --> 00:27:40.540
that also registered the
same callback URL.

00:27:40.540 --> 00:27:44.820
So, maybe some other app will
end up with your OAuth tokens.

00:27:44.820 --> 00:27:51.110
So on iOS we, therefore, often
see solutions where they frame

00:27:51.110 --> 00:27:53.830
the WebView and do it
inside a WebView.

00:27:53.830 --> 00:27:57.050
And the price you pay is that
you're very likely, as the

00:27:57.050 --> 00:28:00.230
user, to have to type in your
username and password because

00:28:00.230 --> 00:28:04.100
the cookie jar is separate in
your application from the

00:28:04.100 --> 00:28:06.700
cookie jar that the stand-alone
browser uses on

00:28:06.700 --> 00:28:11.620
the platform.

00:28:11.620 --> 00:28:14.540
And then Rule #3 is, sometimes
use a WebView anyway.

00:28:14.540 --> 00:28:18.100
If you know that all those
advantages that I have listed

00:28:18.100 --> 00:28:22.740
here under Rule #1 certainly
don't apply to your use case,

00:28:22.740 --> 00:28:24.690
then it's OK to use a WebView.

00:28:24.690 --> 00:28:28.240
One example of this is the
Android team does this in

00:28:28.240 --> 00:28:30.220
their out of box experience.

00:28:30.220 --> 00:28:32.550
When you buy a new phone
or tablet, and

00:28:32.550 --> 00:28:34.130
you unpack the box.

00:28:34.130 --> 00:28:35.680
You turn it on for
the first time.

00:28:35.680 --> 00:28:38.700
One of the things you do there,
in the beginning, is

00:28:38.700 --> 00:28:41.770
you provision your account.

00:28:41.770 --> 00:28:43.810
You type a username
and password.

00:28:43.810 --> 00:28:47.280
And at that point, you know that
the user has never used a

00:28:47.280 --> 00:28:50.280
stand-alone browser on this
platform to log in.

00:28:50.280 --> 00:28:54.440
There's no chance that any of
these advantages from Rule #1

00:28:54.440 --> 00:28:55.620
could possibly kick in.

00:28:55.620 --> 00:29:00.060
So you might as well use
a WebView in this case.

00:29:00.060 --> 00:29:00.400
OK.

00:29:00.400 --> 00:29:06.065
So this is sort of my
synthesized rules of when to

00:29:06.065 --> 00:29:10.510
use a WebView and when to
use an embedded browser.

00:29:10.510 --> 00:29:14.880
So the next two slides I have
are about sort of hands on, I

00:29:14.880 --> 00:29:18.870
guess, recommendations
on how to do this.

00:29:18.870 --> 00:29:22.340
How to implement this for
installed applications.

00:29:22.340 --> 00:29:26.380
And first, I'm going to talk
about desktop platforms.

00:29:26.380 --> 00:29:28.660
Windows/OS X.

00:29:28.660 --> 00:29:31.430
And there we found a trick that
works sort of across a

00:29:31.430 --> 00:29:36.910
variety of platforms, Linux/OS
X, Windows, pretty much the

00:29:36.910 --> 00:29:39.900
same way on all the platforms.
And what we do is we scrape

00:29:39.900 --> 00:29:42.320
the OAuth token from
a window title.

00:29:42.320 --> 00:29:47.440
When you go and register your
native application with the

00:29:47.440 --> 00:29:50.470
APIs console at Google, you
say, this is a native

00:29:50.470 --> 00:29:52.180
application.

00:29:52.180 --> 00:29:54.940
You get a client ID, client
secret, and you're being told

00:29:54.940 --> 00:29:58.780
that your redirect URL is this
funny urn, this funny string

00:29:58.780 --> 00:30:00.640
here, urn:ietf, blah,
blah, blah.

00:30:00.640 --> 00:30:03.020
And then, so you put that
redirect URL, during the OAuth

00:30:03.020 --> 00:30:05.730
flow, as your redirect URL.

00:30:05.730 --> 00:30:08.120
And when we see that particular
redirect URL--

00:30:08.120 --> 00:30:10.670
when the user sees the approvals
page and says, allow

00:30:10.670 --> 00:30:15.380
access, instead of redirecting
back to some web app that sits

00:30:15.380 --> 00:30:18.040
out there, which we don't have
in this case, we actually

00:30:18.040 --> 00:30:20.190
redirect to a page at Google.

00:30:20.190 --> 00:30:23.510
And what that page does, it puts
the OAuth token in the

00:30:23.510 --> 00:30:25.250
title bar of the browser.

00:30:25.250 --> 00:30:27.050
And then the native application,
the installed

00:30:27.050 --> 00:30:30.910
application, can sit in the
background and just look

00:30:30.910 --> 00:30:33.240
through all the windows that
are open on the desktop and

00:30:33.240 --> 00:30:36.320
look for one of the windows that
has that string in the

00:30:36.320 --> 00:30:40.230
title bar and scrape
it out of there.

00:30:40.230 --> 00:30:41.480
Let me show you how
that works.

00:30:45.583 --> 00:30:48.420
It takes a couple seconds
here for the screen

00:30:48.420 --> 00:30:51.300
to come back up.

00:30:51.300 --> 00:30:53.542
OK.

00:30:53.542 --> 00:30:55.520
Where's my cheat sheet?

00:30:55.520 --> 00:30:56.100
All right.

00:30:56.100 --> 00:31:01.600
So I went and registered
with the APIs console.

00:31:01.600 --> 00:31:06.130
I got a client ID and a client
secret, which you see here.

00:31:06.130 --> 00:31:09.800
And then what I'll do next
is I'll just launch a web

00:31:09.800 --> 00:31:15.780
browser, the web browser that
is native to the platform.

00:31:15.780 --> 00:31:18.690
And I point it to the OAuth
2.0 endpoint that said,

00:31:18.690 --> 00:31:19.940
accounts.google.
com/o/oauth2/auth.

00:31:21.420 --> 00:31:22.920
I have to say what
my client ID is.

00:31:22.920 --> 00:31:25.040
And I have to say what
my redirect URI is.

00:31:25.040 --> 00:31:27.690
And it's this funny urn that
I mentioned a moment ago.

00:31:27.690 --> 00:31:29.640
And I say what API I
want to access to.

00:31:29.640 --> 00:31:33.370
And again, this is the
address book API.

00:31:33.370 --> 00:31:36.850
So when I do that a browser
gets launched.

00:31:36.850 --> 00:31:40.050
Again I'm already logged in,
which is very likely what's

00:31:40.050 --> 00:31:42.130
happening to your users also.

00:31:42.130 --> 00:31:46.370
And notice how I'm this user
that actually for which

00:31:46.370 --> 00:31:48.460
ClientLogin doesn't work.

00:31:48.460 --> 00:31:51.380
And when I say, Allow Access,
I am now at a page that has

00:31:51.380 --> 00:31:53.460
basically the token
on the page.

00:31:53.460 --> 00:31:58.760
But also it put it right here
in the title of the browser.

00:31:58.760 --> 00:32:01.670
And you could write your
application in a way-- and

00:32:01.670 --> 00:32:02.300
it's not showing me.

00:32:02.300 --> 00:32:03.660
Anyway you can kind of see it.

00:32:03.660 --> 00:32:05.050
You could write your application
in a way that

00:32:05.050 --> 00:32:06.810
says, go through
the OAuth flow.

00:32:06.810 --> 00:32:09.380
And when you get to the page
with the funny random stuff on

00:32:09.380 --> 00:32:13.530
it, copy that and paste it
into the application.

00:32:13.530 --> 00:32:15.740
Or you can write your
application such that it sits

00:32:15.740 --> 00:32:20.030
in the background and looks
for this event to happen.

00:32:20.030 --> 00:32:24.790
And just to show you how that
might work, I put a little bit

00:32:24.790 --> 00:32:26.793
of code together here
that I prepared.

00:32:30.670 --> 00:32:32.330
We're going to try and
scrape that token off

00:32:32.330 --> 00:32:34.040
that title bar now.

00:32:34.040 --> 00:32:36.050
I'm importing a bunch of this--
this is really all

00:32:36.050 --> 00:32:36.400
pretty standard stuff.

00:32:36.400 --> 00:32:38.210
The only thing I had to actually
go and download is

00:32:38.210 --> 00:32:40.730
this app script, Python library,
which is just a

00:32:40.730 --> 00:32:44.022
little bit of glue between
Python and AppleScript.

00:32:44.022 --> 00:32:45.620
In the real world, you
probably wouldn't use

00:32:45.620 --> 00:32:45.980
AppleScript.

00:32:45.980 --> 00:32:49.950
But for this demo, it was pretty
easy to get going.

00:32:49.950 --> 00:32:53.000
And then I'll make myself
just a few very

00:32:53.000 --> 00:32:55.350
simple functions here.

00:32:55.350 --> 00:32:58.260
The first one is a function
that, given one of those

00:32:58.260 --> 00:33:01.880
AppleScript process objects
returns a list of all the

00:33:01.880 --> 00:33:03.990
windows that belong
to that process.

00:33:03.990 --> 00:33:08.030
And since that method might
throw, I'm catching that and

00:33:08.030 --> 00:33:11.130
returning the empty list. So
it's safe to ask any process

00:33:11.130 --> 00:33:14.060
object out there what its
list of windows are.

00:33:14.060 --> 00:33:17.590
The next function here is given
a list of window title's

00:33:17.590 --> 00:33:20.580
list of strings, it uses regular
expression matching to

00:33:20.580 --> 00:33:22.570
see whether one of those looks
like it might have one of

00:33:22.570 --> 00:33:23.920
those OAuth thingys in it.

00:33:23.920 --> 00:33:27.790
And if so, extracts
it and returns it.

00:33:27.790 --> 00:33:33.220
And then the last little
function here that I have is

00:33:33.220 --> 00:33:34.440
the one that does
the actual work.

00:33:34.440 --> 00:33:38.490
It uses this app script layer,
glue layer, to add to the

00:33:38.490 --> 00:33:41.430
AppleScript engine to
connect to an app

00:33:41.430 --> 00:33:42.800
called System Events.

00:33:42.800 --> 00:33:46.400
And that app is one I can ask
for a list of all the running

00:33:46.400 --> 00:33:48.080
processes on the system.

00:33:48.080 --> 00:33:50.960
And then I ask each of these
processes for a list of

00:33:50.960 --> 00:33:53.370
windows that belong
to the process.

00:33:53.370 --> 00:33:54.700
Now I have a list of lists.

00:33:54.700 --> 00:33:56.630
So I need to sort of
flatten that down.

00:33:56.630 --> 00:33:58.640
That's what this line does.

00:33:58.640 --> 00:34:00.130
Now I have a list of windows.

00:34:00.130 --> 00:34:04.735
And then I extract the code
from that list of windows.

00:34:07.540 --> 00:34:13.110
And so when I call that
function, hopefully we now

00:34:13.110 --> 00:34:16.710
just screen scrape that code
off the title bar.

00:34:16.710 --> 00:34:19.685
And that is actually not quite
our OAuth token yet.

00:34:19.685 --> 00:34:23.159
This is just a one time use code
that you need to exchange

00:34:23.159 --> 00:34:24.889
for your OAuth token.

00:34:24.889 --> 00:34:26.739
And again, there's a little
method that--

00:34:26.739 --> 00:34:30.090
function that shows you
how to do this.

00:34:30.090 --> 00:34:32.580
Again we're using curl just to
hit this particular endpoint.

00:34:32.580 --> 00:34:33.830
It's on accounts.google.
com/o/oauth2/token.

00:34:37.010 --> 00:34:42.590
You put your client ID, your
client secret, and this token

00:34:42.590 --> 00:34:43.650
we just scraped.

00:34:43.650 --> 00:34:44.380
Where did I put it?

00:34:44.380 --> 00:34:46.510
Right here.

00:34:46.510 --> 00:34:49.080
And that returns a little bit
of JSON that has the refresh

00:34:49.080 --> 00:34:51.679
token, this long-lived token,
the access token, which will

00:34:51.679 --> 00:34:53.389
expire in an hour in it.

00:34:53.389 --> 00:34:55.050
And we right now are
only interested

00:34:55.050 --> 00:34:55.690
in the access token.

00:34:55.690 --> 00:35:00.750
And so I'm peeling that
out of the response.

00:35:00.750 --> 00:35:02.000
So let's call that method.

00:35:06.500 --> 00:35:07.830
And there's our access token.

00:35:07.830 --> 00:35:10.590
So you will probably do that
sitting in the background,

00:35:10.590 --> 00:35:13.160
trying to scrape the token
off your browser.

00:35:13.160 --> 00:35:14.310
So now let's see whether
we can hit an

00:35:14.310 --> 00:35:15.880
API with that token.

00:35:24.220 --> 00:35:25.670
And there you go.

00:35:25.670 --> 00:35:28.340
Actually, let me see.

00:35:28.340 --> 00:35:33.620
I have somewhere this thing that
filters through all the--

00:35:33.620 --> 00:35:34.020
there you go.

00:35:34.020 --> 00:35:36.320
So that's the address book of
this guy that couldn't use

00:35:36.320 --> 00:35:37.140
ClientLogin.

00:35:37.140 --> 00:35:39.820
We started off with an example
of an account that was using

00:35:39.820 --> 00:35:41.250
ClientLogin.

00:35:41.250 --> 00:35:48.160
So that's the trick that we
found to work pretty well

00:35:48.160 --> 00:35:54.360
across different platforms.
Other practices that are

00:35:54.360 --> 00:35:57.840
sometimes recommended are to run
a little web server inside

00:35:57.840 --> 00:35:59.360
your installed application.

00:35:59.360 --> 00:36:02.950
And then use as the redirect
URI something that says,

00:36:02.950 --> 00:36:05.800
http://localhost:port.

00:36:05.800 --> 00:36:08.080
We found that to be a
little unreliable,

00:36:08.080 --> 00:36:09.210
especially on Windows.

00:36:09.210 --> 00:36:12.890
There's often firewalls running
that at the very least

00:36:12.890 --> 00:36:16.660
throw up some confusing screens
that users don't quite

00:36:16.660 --> 00:36:20.005
know what to deal with that warn
them or perhaps sometimes

00:36:20.005 --> 00:36:22.360
even forbid it altogether.

00:36:22.360 --> 00:36:24.510
Another practice that is
sometimes recommended is to

00:36:24.510 --> 00:36:25.790
use a custom scheme.

00:36:25.790 --> 00:36:27.930
So as your redirect your URI
say, something, something,

00:36:27.930 --> 00:36:30.430
fubar, colon, slash,
slash, redirect.

00:36:30.430 --> 00:36:31.750
Or something like that.

00:36:31.750 --> 00:36:36.480
And again, it's a little
unreliable to use this

00:36:36.480 --> 00:36:40.570
practice because you don't know
that there isn't another

00:36:40.570 --> 00:36:42.050
app that registered
the same redirect.

00:36:42.050 --> 00:36:44.900
And now that app on the platform
gets the token

00:36:44.900 --> 00:36:48.150
instead of your app.

00:36:48.150 --> 00:36:48.560
OK.

00:36:48.560 --> 00:36:53.150
So that's how to do it on
a desktop platform.

00:36:53.150 --> 00:36:56.460
On iOS I mentioned earlier that
we have a library that

00:36:56.460 --> 00:36:57.620
you can download.

00:36:57.620 --> 00:36:59.520
There's the link where
you can go.

00:36:59.520 --> 00:37:02.750
There's an OAuth 1.0 version
of this that comes actually

00:37:02.750 --> 00:37:05.010
with our GData-Objective-C
Library.

00:37:05.010 --> 00:37:08.600
But now we have an OAuth 2.0
version also available.

00:37:08.600 --> 00:37:12.430
That stand-alone that's
available at this URL.

00:37:12.430 --> 00:37:16.070
This library uses a WebView
unlike what I just demoed

00:37:16.070 --> 00:37:19.530
where it popped up the
stand-alone browser.

00:37:19.530 --> 00:37:23.750
And the trick it uses there to
get to the OAuth token is that

00:37:23.750 --> 00:37:28.400
because the application hosts
the WebView, you can register

00:37:28.400 --> 00:37:32.025
callbacks every time the URL
changes that the WebView is

00:37:32.025 --> 00:37:33.440
asked to go visit.

00:37:33.440 --> 00:37:34.690
So there you just--

00:37:34.690 --> 00:37:38.480
you intercept at that moment
when after the user hits

00:37:38.480 --> 00:37:42.690
Allow, the server serves a 3.02
to the redirect URI with

00:37:42.690 --> 00:37:45.560
that token in the URL.

00:37:45.560 --> 00:37:47.275
So at that point, the
application can just intercept

00:37:47.275 --> 00:37:52.580
it, grab the token out of the
URL and take it from there.

00:37:52.580 --> 00:37:56.800
I mentioned earlier that using a
WebView is sort of necessary

00:37:56.800 --> 00:37:58.960
in iOS because of some
usability issues.

00:37:58.960 --> 00:38:02.350
But you pay the price by
virtually guaranteeing that

00:38:02.350 --> 00:38:04.352
the user has to type their
username and password.

00:38:04.352 --> 00:38:06.980
So one of the projects I'm
currently working on is to try

00:38:06.980 --> 00:38:10.750
to get rid of the necessity
for the user to type their

00:38:10.750 --> 00:38:12.320
username and password.

00:38:12.320 --> 00:38:16.690
And to use another installed
application on the phone, the

00:38:16.690 --> 00:38:21.080
Google Mobile App, as sort of
an account manager, which

00:38:21.080 --> 00:38:22.350
would store--

00:38:22.350 --> 00:38:24.950
probably in Keychain or
something like that--

00:38:24.950 --> 00:38:26.770
credentials for the user.

00:38:26.770 --> 00:38:30.440
And so the user wouldn't
have to type them.

00:38:30.440 --> 00:38:32.150
And so hopefully we'll
have something

00:38:32.150 --> 00:38:33.400
like that in the future.

00:38:35.730 --> 00:38:35.960
OK.

00:38:35.960 --> 00:38:38.610
I haven't talked about
Android much today.

00:38:38.610 --> 00:38:40.120
And the reason I haven't
talked about Android is

00:38:40.120 --> 00:38:44.080
because on Android things work
a little differently.

00:38:44.080 --> 00:38:47.485
I did mention how one of the
things you do when you use an

00:38:47.485 --> 00:38:50.650
Android device in the very
beginning is just provision

00:38:50.650 --> 00:38:53.220
Google accounts with it as part
of sort of the out of box

00:38:53.220 --> 00:38:54.240
experience.

00:38:54.240 --> 00:38:59.120
And then the phone stores not
the password, but sort of the

00:38:59.120 --> 00:39:02.000
moral equivalent of a password
for the user.

00:39:02.000 --> 00:39:06.240
And as a result, users are
really not used to

00:39:06.240 --> 00:39:09.480
applications ever asking
them for their Google

00:39:09.480 --> 00:39:10.840
username and password.

00:39:10.840 --> 00:39:14.140
Instead what applications do on
Android is they can ask the

00:39:14.140 --> 00:39:17.250
operating system, say, dear
operating system, I need an

00:39:17.250 --> 00:39:18.270
auth token.

00:39:18.270 --> 00:39:20.850
And then the operating
system just provides.

00:39:20.850 --> 00:39:24.520
And what the operating system
provides, in this case, is a

00:39:24.520 --> 00:39:27.800
ClientLogin token.

00:39:27.800 --> 00:39:33.590
And the component that you ask
for the password is called the

00:39:33.590 --> 00:39:34.800
AccountManager.

00:39:34.800 --> 00:39:37.460
And today when the application
asks for such a token, the

00:39:37.460 --> 00:39:42.650
thing that you get back is
a ClientLogin token.

00:39:42.650 --> 00:39:44.850
And that's OK.

00:39:44.850 --> 00:39:47.370
The problem with ClientLogin
tokens is not so much that you

00:39:47.370 --> 00:39:50.380
can't use them with
Google APIs.

00:39:50.380 --> 00:39:52.900
The problem with ClientLogin
is that you can't get the

00:39:52.900 --> 00:39:56.300
ClientLogin tokens for a
large class of users.

00:39:56.300 --> 00:39:59.810
But on Android, we made it so
that even for the kinds of

00:39:59.810 --> 00:40:03.050
users for which ClientLogin per
se doesn't work, you can

00:40:03.050 --> 00:40:04.690
still ask for ClientLogin
tokens.

00:40:04.690 --> 00:40:08.300
And the OS will still give them
to you even for a 2-Step

00:40:08.300 --> 00:40:11.110
Verification user, even
for an OpenID user.

00:40:11.110 --> 00:40:14.920
So on Android the need to move
away from ClientLogin is a

00:40:14.920 --> 00:40:18.730
little less pressing because
the OS can do magic

00:40:18.730 --> 00:40:21.360
essentially and can give
you ClientLogin tokens.

00:40:21.360 --> 00:40:25.230
Having said that, we are working
on OAuth 2.0 support

00:40:25.230 --> 00:40:29.030
on Android, where the
application can say, hey OS, I

00:40:29.030 --> 00:40:31.980
would like, not a ClientLogin
token, but an OAuth token.

00:40:31.980 --> 00:40:34.900
And then the OS provides just
like it does today with the

00:40:34.900 --> 00:40:38.230
ClientLogin tokens.

00:40:38.230 --> 00:40:40.880
The screenshot I have on here
on the slide is actually for

00:40:40.880 --> 00:40:43.550
the sort of the ClientLogin
version of

00:40:43.550 --> 00:40:44.820
what this looks like.

00:40:44.820 --> 00:40:47.730
And it typically happens
like this.

00:40:47.730 --> 00:40:51.200
The application calls the
AccountManager, which is part

00:40:51.200 --> 00:40:55.230
of the OS, and says, hey, give
me a list of all the Google

00:40:55.230 --> 00:40:57.410
accounts that are provisioned
on the phone.

00:40:57.410 --> 00:41:00.150
Then the AccountManager returns
the list. And the app,

00:41:00.150 --> 00:41:02.860
then, displays that list for
the user to choose which

00:41:02.860 --> 00:41:05.710
account they would like to use
at this point in time.

00:41:05.710 --> 00:41:07.050
The user picks one.

00:41:07.050 --> 00:41:09.840
And then the app goes back to
the AccountManager and says,

00:41:09.840 --> 00:41:12.530
OK, now I would like a token for
this account that the user

00:41:12.530 --> 00:41:13.880
just picked.

00:41:13.880 --> 00:41:16.040
And at this point, contact
switches to the

00:41:16.040 --> 00:41:16.830
AccountManager.

00:41:16.830 --> 00:41:18.970
You can see that the look and
feel is quite different.

00:41:18.970 --> 00:41:23.440
The AccountManager shows the
approval screen, and if and

00:41:23.440 --> 00:41:26.170
when the user approves, hands
the token back to the

00:41:26.170 --> 00:41:30.400
application, which then over
here, is happy and goes ahead

00:41:30.400 --> 00:41:32.770
with using that token.

00:41:32.770 --> 00:41:35.340
And in OAuth 2.0, this is likely
going to look very,

00:41:35.340 --> 00:41:35.910
very similar.

00:41:35.910 --> 00:41:37.930
The AccountManager just does
it for the application.

00:41:37.930 --> 00:41:39.470
The application doesn't
have to worry

00:41:39.470 --> 00:41:41.840
about any of this stuff.

00:41:41.840 --> 00:41:42.470
OK.

00:41:42.470 --> 00:41:44.050
Next think I want to talk about
is the device flow.

00:41:44.050 --> 00:41:48.230
I mentioned very early on that
sometimes you don't even need

00:41:48.230 --> 00:41:49.480
a web browser.

00:41:52.250 --> 00:41:56.410
And this also works for devices
that have bad user

00:41:56.410 --> 00:42:00.890
input methods or maybe no user
input methods available.

00:42:00.890 --> 00:42:04.620
Think Picture Frame or
something like that.

00:42:04.620 --> 00:42:09.580
So what happens there is that
OAuth provides what we call a

00:42:09.580 --> 00:42:14.200
device flow, where the native
application that runs, let's

00:42:14.200 --> 00:42:18.820
say on Picture Frame, contacts
Google and gets a user-- and

00:42:18.820 --> 00:42:22.030
how do we call-- activation
code, an activation code and a

00:42:22.030 --> 00:42:23.780
device code.

00:42:23.780 --> 00:42:26.980
It displays the activation code
to the user and says,

00:42:26.980 --> 00:42:30.370
hey, why don't you go to Google,
to this certain page

00:42:30.370 --> 00:42:32.990
at Google, type in this
activation code.

00:42:32.990 --> 00:42:39.020
And once you approve access, the
application that's running

00:42:39.020 --> 00:42:42.635
on the device will have access
to whatever account the user

00:42:42.635 --> 00:42:44.810
is using at Google.

00:42:44.810 --> 00:42:45.730
Let me show you how
that works.

00:42:45.730 --> 00:42:50.210
I also have a little code
snippet for that.

00:42:50.210 --> 00:42:53.330
Device flow.

00:42:53.330 --> 00:42:57.660
So the application starting on
the device would go to this

00:42:57.660 --> 00:42:59.990
particular URL, currently
by running--

00:42:59.990 --> 00:43:02.490
this is still on Sandbox, so
this isn't launched in

00:43:02.490 --> 00:43:07.040
production, but it's available
for testing.

00:43:07.040 --> 00:43:11.140
Contact the Sandbox at Google
where it gets back a little

00:43:11.140 --> 00:43:14.520
bit of data that has the user
code in it that you would

00:43:14.520 --> 00:43:17.050
display to the user and say,
hey, take this user code and

00:43:17.050 --> 00:43:18.480
enter it at Google.

00:43:18.480 --> 00:43:23.960
It has a device code, which
we're going to use to poll in

00:43:23.960 --> 00:43:26.020
the background and ask
Google, hey, has the

00:43:26.020 --> 00:43:27.160
user approved yet?

00:43:27.160 --> 00:43:28.240
Has the user approved yet?

00:43:28.240 --> 00:43:30.460
Has the user approved yet?

00:43:30.460 --> 00:43:37.310
And it has also the URL that
the user should go to.

00:43:37.310 --> 00:43:39.870
So let's pull out the device
code out of this because we

00:43:39.870 --> 00:43:43.050
use it to poll.

00:43:43.050 --> 00:43:46.850
And let's see whether the
user is approved yet.

00:43:46.850 --> 00:43:49.480
Well, no they haven't.

00:43:49.480 --> 00:43:52.890
But let's now assume
that we're maybe

00:43:52.890 --> 00:43:54.810
on a different device.

00:43:54.810 --> 00:43:58.280
I walk over to the PC in the
corner or on my tablet

00:43:58.280 --> 00:43:59.880
or what have you.

00:43:59.880 --> 00:44:05.610
And I go to this URL.

00:44:05.610 --> 00:44:12.360
I enter the activation code
that the device hopefully

00:44:12.360 --> 00:44:14.116
displays to the user.

00:44:14.116 --> 00:44:15.373
Where am I?

00:44:15.373 --> 00:44:17.690
Here.

00:44:17.690 --> 00:44:19.270
And after I do that,
I see, again, the

00:44:19.270 --> 00:44:20.930
OAuth approval screen.

00:44:20.930 --> 00:44:23.340
I say, Allow Access.

00:44:23.340 --> 00:44:24.720
And then you see why this
is not launched

00:44:24.720 --> 00:44:25.390
in production yet.

00:44:25.390 --> 00:44:30.000
It's still sort of
in testing mode.

00:44:30.000 --> 00:44:33.470
But anyway, so now if we try
the same call again, we

00:44:33.470 --> 00:44:37.340
actually do get back the result
from the server that

00:44:37.340 --> 00:44:39.640
says, yes, approval
has been granted.

00:44:39.640 --> 00:44:40.720
Here's your refresh token.

00:44:40.720 --> 00:44:41.710
Here's your access token.

00:44:41.710 --> 00:44:44.510
And we would take it from there
just like we did when we

00:44:44.510 --> 00:44:47.250
scraped that code from
the window title.

00:44:50.260 --> 00:44:52.260
So that's the device flow.

00:44:52.260 --> 00:44:53.720
It's ready for testing.

00:44:53.720 --> 00:44:58.140
There's a email address on the
screen that you can email if

00:44:58.140 --> 00:44:59.820
you maybe want to get--

00:44:59.820 --> 00:45:03.375
stay in touch with us and know
when this launch is for real.

00:45:03.375 --> 00:45:04.960
Or just have questions
about it.

00:45:04.960 --> 00:45:06.190
I'm not even sure
that we have the

00:45:06.190 --> 00:45:07.820
documentation out publicly.

00:45:07.820 --> 00:45:11.400
So if you email that, maybe
someone will just send you an

00:45:11.400 --> 00:45:14.700
explanation on how to use it.

00:45:14.700 --> 00:45:15.940
All right.

00:45:15.940 --> 00:45:18.710
So I think I have maybe
two slides left or so.

00:45:18.710 --> 00:45:20.050
OAuth for XMPP, IMAP/POP/SMTP.

00:45:23.180 --> 00:45:26.260
So far I've talked about RESTful
APIs that use the

00:45:26.260 --> 00:45:27.250
ClientLogin endpoint.

00:45:27.250 --> 00:45:30.140
There are other protocols that
don't use ClientLogin, but

00:45:30.140 --> 00:45:34.200
that have that same assumption
built into them that the user

00:45:34.200 --> 00:45:36.950
authenticates with a username
and a password.

00:45:36.950 --> 00:45:37.790
XMPP/IMAP.

00:45:37.790 --> 00:45:40.160
In the protocol it says, this
is where the username goes,

00:45:40.160 --> 00:45:41.710
this is where the
password goes.

00:45:41.710 --> 00:45:44.480
And if you have a user account
that doesn't use a password to

00:45:44.480 --> 00:45:47.580
authenticate to the server,
those things break.

00:45:47.580 --> 00:45:50.670
We launched a while ago
support for OAuth 1.0

00:45:50.670 --> 00:45:52.660
and IMAP and SMTP.

00:45:52.660 --> 00:45:56.310
So let's say, an IMAP client
would do in this case, they

00:45:56.310 --> 00:45:59.280
would take the user through
the OAuth flow, out of the

00:45:59.280 --> 00:46:02.590
OAuth flow in the OAuth 1.0 case
pops an access token and

00:46:02.590 --> 00:46:03.850
a token secret.

00:46:03.850 --> 00:46:07.020
And then you use the secret to
create the signed assertion of

00:46:07.020 --> 00:46:08.550
a bunch of different
parameters.

00:46:08.550 --> 00:46:11.000
And you'd put that assertion
where the password normally

00:46:11.000 --> 00:46:14.870
would go in XMPP or IMAP.

00:46:14.870 --> 00:46:18.520
And we're currently working on
an OAuth 2.0 version of this,

00:46:18.520 --> 00:46:19.410
which should be much easier.

00:46:19.410 --> 00:46:20.860
You just take the token.

00:46:20.860 --> 00:46:22.490
And you put it where the
password would go.

00:46:22.490 --> 00:46:25.540
And it should be really easy.

00:46:25.540 --> 00:46:29.180
We're also working on the same
thing for XMPP, where we're

00:46:29.180 --> 00:46:31.090
skipping the OAuth 1.0
version of this.

00:46:31.090 --> 00:46:32.560
We're going to go straight
to OAuth 2.0.

00:46:32.560 --> 00:46:35.540
And there is a standardized
way of doing this that is

00:46:35.540 --> 00:46:39.840
currently being hashed out in
a bunch of standardization

00:46:39.840 --> 00:46:40.830
committees.

00:46:40.830 --> 00:46:43.290
And when these guys get their
act together, I assume we'll

00:46:43.290 --> 00:46:49.150
support whatever that standard
is that is agreed upon there.

00:46:49.150 --> 00:46:49.550
OK.

00:46:49.550 --> 00:46:51.080
I think this is pretty much
my last slide here.

00:46:51.080 --> 00:46:56.490
One thing that-- a couple of
sort of thoughts in parting is

00:46:56.490 --> 00:46:59.040
that installed applications
can't keep secrets.

00:46:59.040 --> 00:47:02.800
When you go to the APIs console,
and you register your

00:47:02.800 --> 00:47:05.580
app with Google, and you say,
this is an installed

00:47:05.580 --> 00:47:07.470
application, you get a
client ID, and you

00:47:07.470 --> 00:47:09.690
get a client secret.

00:47:09.690 --> 00:47:11.230
That secret isn't
really secret.

00:47:11.230 --> 00:47:13.350
Anyone who downloads your
application can reverse

00:47:13.350 --> 00:47:15.880
engineer your application
and can find out

00:47:15.880 --> 00:47:17.000
what that secret is.

00:47:17.000 --> 00:47:19.810
So don't treat the secret
as if it were a secret.

00:47:19.810 --> 00:47:21.645
We, certainly, on the
server side, don't.

00:47:21.645 --> 00:47:25.670
We have other mechanisms in
place that sort of look out

00:47:25.670 --> 00:47:28.820
for behavior that is either
malicious or benign just based

00:47:28.820 --> 00:47:30.160
on the client ID.

00:47:30.160 --> 00:47:34.750
Never, ever, ever use the same
Client ID and secret for a

00:47:34.750 --> 00:47:37.120
native app and a web app.

00:47:37.120 --> 00:47:40.020
For web apps, those secrets
actually can stay secret.

00:47:40.020 --> 00:47:41.870
And we use them to authenticate,
to strongly

00:47:41.870 --> 00:47:45.260
authenticate OAuth clients.

00:47:45.260 --> 00:47:49.450
And the last thing I want to
mention that the scopes that

00:47:49.450 --> 00:47:52.400
you use to identify the servers
you want to talk to in

00:47:52.400 --> 00:47:55.340
OAuth are somewhat more--

00:47:55.340 --> 00:47:57.920
there's more of them than we
used to have for ClientLogin.

00:47:57.920 --> 00:48:01.240
Some of our teams now have sort
of fine-grained scope,

00:48:01.240 --> 00:48:03.880
maybe a read-only scope and a
read/write scope and so forth.

00:48:03.880 --> 00:48:06.980
So it's easier to ask just for
the privileges that you need

00:48:06.980 --> 00:48:11.140
for your application instead
of asking for too much.

00:48:11.140 --> 00:48:12.090
All right.

00:48:12.090 --> 00:48:15.230
So to summarize, I started
off explaining a bunch of

00:48:15.230 --> 00:48:18.440
different use cases in which
ClientLogin fails

00:48:18.440 --> 00:48:20.340
for a class of users.

00:48:20.340 --> 00:48:23.850
One of the classes of users
I mentioned was OpenID.

00:48:23.850 --> 00:48:29.680
Today when a user that has an
@yahoo.com email address uses

00:48:29.680 --> 00:48:31.940
that for the Google
account, they can

00:48:31.940 --> 00:48:34.550
opt in to using OpenID.

00:48:34.550 --> 00:48:36.560
We may, in the future, decide
that this is such a great

00:48:36.560 --> 00:48:39.490
experience not to have to have
yet another password for

00:48:39.490 --> 00:48:42.650
Google for the Yahoo users that
we just switch it on for

00:48:42.650 --> 00:48:43.920
all of them.

00:48:43.920 --> 00:48:45.410
And the same with
AOL and HotMail.

00:48:45.410 --> 00:48:48.150
And if and when we decide to do
that, a large fraction of

00:48:48.150 --> 00:48:50.750
Google users will just no
longer be able to use

00:48:50.750 --> 00:48:51.350
ClientLogin.

00:48:51.350 --> 00:48:53.590
That's something to keep
in mind if you're using

00:48:53.590 --> 00:48:55.750
ClientLogin currently.

00:48:55.750 --> 00:48:57.920
And I mentioned other use cases
in which ClientLogin

00:48:57.920 --> 00:48:58.920
also breaks.

00:48:58.920 --> 00:49:00.850
I talked a little bit about
application-specific

00:49:00.850 --> 00:49:03.390
passwords, but they're really
just a stopgap.

00:49:03.390 --> 00:49:06.220
And what you should be doing,
and what I spend most of my

00:49:06.220 --> 00:49:09.150
time talking about was OAuth
2.0 and how to use it from

00:49:09.150 --> 00:49:10.850
installed applications.

00:49:10.850 --> 00:49:14.030
To learn more go to Ryan's
session tomorrow.

00:49:14.030 --> 00:49:16.520
He'll talk a little bit more
about OpenID and OAuth.

00:49:16.520 --> 00:49:21.200
And as I mentioned earlier,
search for OAuth 2.0 Google,

00:49:21.200 --> 00:49:24.180
and you'll get the page where
we explain all of

00:49:24.180 --> 00:49:26.720
this in some detail.

00:49:26.720 --> 00:49:27.090
All right.

00:49:27.090 --> 00:49:28.680
And with that, I'm ready
to take questions.

00:49:28.680 --> 00:49:33.260
Again, the feedback URL and the
hashtags are on the slide.

00:49:33.260 --> 00:49:36.100
If you have questions, please
use the microphone so they're

00:49:36.100 --> 00:49:38.600
being recorded.

00:49:38.600 --> 00:49:40.600
Anyone?

00:49:40.600 --> 00:49:41.850
OK.

00:49:45.300 --> 00:49:47.450
AUDIENCE: You recommended
that applications

00:49:47.450 --> 00:49:50.460
don't store any secrets.

00:49:50.460 --> 00:49:54.300
What if I'm building an
application where the user

00:49:54.300 --> 00:49:56.660
would want the application
to remember the password?

00:49:56.660 --> 00:49:57.710
You know, they install it.

00:49:57.710 --> 00:49:59.390
They type in the username
and password once.

00:49:59.390 --> 00:50:02.490
They click a check box, and
we never ask again.

00:50:02.490 --> 00:50:03.450
DIRK BALFANZ: Right.

00:50:03.450 --> 00:50:05.280
Well, I wouldn't say that
applications should never

00:50:05.280 --> 00:50:06.560
store a secret.

00:50:06.560 --> 00:50:08.930
And today many applications
store passwords.

00:50:08.930 --> 00:50:11.440
And I think that has certain
advantages not to have to type

00:50:11.440 --> 00:50:14.410
the password every time I want
to use the application.

00:50:14.410 --> 00:50:16.845
One thing that is nice about
OAuth is that the secret--

00:50:16.845 --> 00:50:19.640
this refresh token that
doesn't expire--

00:50:19.640 --> 00:50:22.510
that secret that you could
choose to store--

00:50:22.510 --> 00:50:23.610
I think that's fine--

00:50:23.610 --> 00:50:25.920
it's actually finer
scoped than the

00:50:25.920 --> 00:50:26.860
password would have been.

00:50:26.860 --> 00:50:29.820
So the secrets that you end
up storing isn't quite as

00:50:29.820 --> 00:50:32.490
powerful as the password
would have been.

00:50:32.490 --> 00:50:35.545
And it's also revocable if
something goes wrong.

00:50:35.545 --> 00:50:36.880
The user realizes, oh this

00:50:36.880 --> 00:50:38.770
application is sort of abusive.

00:50:38.770 --> 00:50:40.832
They can go and revoke
the token.

00:50:40.832 --> 00:50:45.070
So I think it's fine to store a
refresh token, for example,

00:50:45.070 --> 00:50:46.170
in the Keychain.

00:50:46.170 --> 00:50:50.250
Use good tools that you have
on the platform, Data

00:50:50.250 --> 00:50:52.650
Protection API, Keychain
and so forth.

00:50:52.650 --> 00:50:54.360
But I think it's OK to put them

00:50:54.360 --> 00:50:56.363
there, the refresh tokens.

00:50:56.363 --> 00:50:57.613
AUDIENCE: OK.

00:51:03.620 --> 00:51:05.730
DIRK BALFANZ: OK.

00:51:05.730 --> 00:51:10.035
Everybody wants to go play with
their new Galaxy Tabs?

00:51:10.035 --> 00:51:10.780
All right.

00:51:10.780 --> 00:51:12.350
Well, thank you.

