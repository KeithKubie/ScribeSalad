WEBVTT
Kind: captions
Language: en

00:00:00.310 --> 00:00:03.440
In addition to defining
the notion of a language itself,

00:00:03.440 --> 00:00:06.970
we wanted to find some operations on
languages and establish some notation.

00:00:08.160 --> 00:00:12.850
We'll illustrate using these two
languages over the zero one alphabet.

00:00:12.850 --> 00:00:14.290
Since languages are set,

00:00:14.290 --> 00:00:19.900
we have the usual operations of union,
intersection and complement.

00:00:19.900 --> 00:00:23.680
For example, A union B consists
of these three strings.

00:00:23.680 --> 00:00:31.380
0, from both A and B,
10 from A, and 11 from B.

00:00:31.380 --> 00:00:36.610
The intersection contains only
those strings in both languages.

00:00:36.610 --> 00:00:38.050
Just the string 0 here.

00:00:39.430 --> 00:00:42.120
To define the complement of
a language we need to make clear

00:00:42.120 --> 00:00:44.110
what it is that we're completing.

00:00:44.110 --> 00:00:47.410
It's not sufficient just to say
that it's everything not in A.

00:00:48.460 --> 00:00:53.840
For this particular A that would include
strings with characters besides 0 and 1.

00:00:53.840 --> 00:00:56.780
Or maybe even infinite
sequences of zeros and ones.

00:00:56.780 --> 00:00:58.380
Which we don't want.

00:00:58.380 --> 00:01:02.570
The complement therefore, is designed so
as to complete the set of all strings

00:01:02.570 --> 00:01:06.870
over the relevant alphabet,
in this case the binary alphabet.

00:01:06.870 --> 00:01:09.630
Usually, the alphabet over
which the language is defined

00:01:09.630 --> 00:01:11.900
will be clear from context.

00:01:11.900 --> 00:01:14.670
In this case,
the complement of A will be infinite,

00:01:14.670 --> 00:01:18.330
including the empty string,
not zero however.

00:01:18.330 --> 00:01:21.786
It will include 1, it will include 00,

00:01:21.786 --> 00:01:26.593
it will include 01,
it will not include 10, however.

00:01:26.593 --> 00:01:31.154
It will include 11,
it will include 000, and so on and so

00:01:31.154 --> 00:01:33.450
forth for all longer strings.

00:01:34.610 --> 00:01:37.157
In addition to these
standard set operations,

00:01:37.157 --> 00:01:40.543
we also define an operation for
concatenating two languages.

00:01:40.543 --> 00:01:45.940
The concatenation of A and B is just
all strings that you can form by taking

00:01:45.940 --> 00:01:51.000
a string from A, let's say x, and
appending to it a string y from B.

00:01:52.220 --> 00:01:57.160
In our examples,
the set AB would be 0 0.

00:01:57.160 --> 00:02:00.040
The first 0 coming from A and
the second from B.

00:02:01.100 --> 00:02:07.600
011, with the 0 coming from A, and
the 11 coming from B, and so forth.

00:02:08.830 --> 00:02:12.150
Of course, we can also concatenate
a language with itself.

00:02:12.150 --> 00:02:13.740
As I've done here in this example.

00:02:14.790 --> 00:02:18.300
Instead of writing AA,
we often write A squared.

00:02:18.300 --> 00:02:22.780
And in general, when want to concatenate
a language with itself k times,

00:02:22.780 --> 00:02:25.140
we write A to the kth power.

00:02:25.140 --> 00:02:26.740
Note that for k equals 0,

00:02:26.740 --> 00:02:31.540
this is defined as the language
containing exactly the empty string.

00:02:31.540 --> 00:02:35.100
When we want to concatenate any number
of strings from a language together,

00:02:35.100 --> 00:02:36.740
to form a new language.

00:02:36.740 --> 00:02:39.860
We use an operator known as Kleene Star.

00:02:39.860 --> 00:02:44.850
This can be thought of as the union of
all possible powers of the language.

00:02:44.850 --> 00:02:48.620
When we want to exclude the empty
string, we use the Plus Operator

00:02:48.620 --> 00:02:53.300
instead, which insists that at
least one string from A be used.

00:02:53.300 --> 00:02:55.560
Notice the difference in
the starting indices.

00:02:56.560 --> 00:02:59.460
For example, this string here is in A*.

00:02:59.460 --> 00:03:04.798
There's a way that I can break it up so
that each part is in the language A.

00:03:04.798 --> 00:03:10.150
Note that A* doesn't include
infinite sequences of symbols.

00:03:10.150 --> 00:03:14.110
Each individual string from
A must be a finite length and

00:03:14.110 --> 00:03:17.920
you're only allowed to concatenate
a finite number of those together.

00:03:17.920 --> 00:03:19.830
For those who have studied
regular expressions,

00:03:19.830 --> 00:03:21.780
this should seem quite familiar.

00:03:21.780 --> 00:03:23.400
In fact, one gets the notation for

00:03:23.400 --> 00:03:26.905
regular expressions by treating
individual symbols as languages.

00:03:26.905 --> 00:03:33.027
For example, 0* is the set of all
strings consisting entirely of zeros.

00:03:33.027 --> 00:03:37.192
We'll also commonly refer to sigma
star meaning all possible strings over

00:03:37.192 --> 00:03:38.391
the alphabet sigma.

