WEBVTT
Kind: captions
Language: en

00:00:04.420 --> 00:00:05.260
TED SANDER: Hello.

00:00:05.260 --> 00:00:08.740
Welcome to Upgrading the
Engine Mid-flight-- How Google

00:00:08.740 --> 00:00:12.600
Improves its Web Apps
Without Downtime.

00:00:12.600 --> 00:00:13.790
I'm Ted Sander.

00:00:13.790 --> 00:00:14.990
This is Paul Rohde.

00:00:14.990 --> 00:00:18.720
And we're going to be your
guides on this journey.

00:00:18.720 --> 00:00:23.275
So flashback, 2013
Google I/O, a developer

00:00:23.275 --> 00:00:26.390
is watching all the
sessions from his computer,

00:00:26.390 --> 00:00:30.360
learning about Polymer,
about Dart, about Angular,

00:00:30.360 --> 00:00:32.490
about removing jank
from his web apps,

00:00:32.490 --> 00:00:35.770
about improving the render
speed of his application.

00:00:35.770 --> 00:00:37.740
And he just gets really
excited about all

00:00:37.740 --> 00:00:40.130
this cool new
technology they can use.

00:00:40.130 --> 00:00:43.710
The speakers make it seem
so easy and so powerful.

00:00:43.710 --> 00:00:47.610
It just excites him and
gets him very excited again.

00:00:47.610 --> 00:00:50.090
So during his
downtime, he starts

00:00:50.090 --> 00:00:53.240
using all this new technology,
and it's easy and wonderful

00:00:53.240 --> 00:00:56.000
and just makes him love
programming again, right?

00:00:56.000 --> 00:00:57.880
It's just fun to
do and everything

00:00:57.880 --> 00:00:59.670
just simple and powerful.

00:00:59.670 --> 00:01:03.660
And he can build great apps
using all this technology.

00:01:03.660 --> 00:01:07.160
But every morning, he
wakes up, gets in his car

00:01:07.160 --> 00:01:09.870
and drives to work, sits
down at his computer

00:01:09.870 --> 00:01:11.610
and is just frustrated.

00:01:11.610 --> 00:01:13.770
He makes a line of
code chains, takes him

00:01:13.770 --> 00:01:17.190
about 15 to 20 minutes
to see it on the screen.

00:01:17.190 --> 00:01:19.125
He's about five levels
away from the DOM.

00:01:19.125 --> 00:01:21.350
He doesn't even remember
what it looks like anymore.

00:01:21.350 --> 00:01:23.050
He's hardly touching HTML.

00:01:23.050 --> 00:01:25.180
It's in this other
language that's

00:01:25.180 --> 00:01:27.520
being translated a couple
times before it actually

00:01:27.520 --> 00:01:29.050
gets to the render.

00:01:29.050 --> 00:01:32.360
He can't use all the cool new
tools in Chrome and everything

00:01:32.360 --> 00:01:34.365
else because the
app's just huge,

00:01:34.365 --> 00:01:36.250
and he can't even do anything.

00:01:36.250 --> 00:01:38.380
And it's just so
frustrating, he just

00:01:38.380 --> 00:01:40.000
doesn't want to deal with it.

00:01:40.000 --> 00:01:45.270
So he has this
crazy idea, right?

00:01:45.270 --> 00:01:47.780
What if he could have
that excellent environment

00:01:47.780 --> 00:01:48.850
that he has at home?

00:01:48.850 --> 00:01:50.820
What if he could bring
it and actually do

00:01:50.820 --> 00:01:52.270
the same things at work?

00:01:52.270 --> 00:01:53.760
What if he could
get all the power

00:01:53.760 --> 00:01:56.360
from all those cool
technologies that he worked with

00:01:56.360 --> 00:02:01.010
and just make development fun
again, even at work, right?

00:02:01.010 --> 00:02:06.530
So he goes to his co-worker, and
he tells him this crazy idea.

00:02:06.530 --> 00:02:09.039
And they start
working through it.

00:02:09.039 --> 00:02:10.970
And there's just so much code.

00:02:10.970 --> 00:02:12.390
There's so much legacy code.

00:02:12.390 --> 00:02:14.700
They have all these tools
that they can use with.

00:02:14.700 --> 00:02:16.570
The problem just
seems impossible.

00:02:16.570 --> 00:02:18.270
It just seems so hard.

00:02:18.270 --> 00:02:19.770
They don't even
know where to start.

00:02:19.770 --> 00:02:23.460
Where do you even begin
on this journey, right?

00:02:23.460 --> 00:02:27.160
It just seems like
it's unattainable.

00:02:27.160 --> 00:02:30.150
And that developer is me, right?

00:02:30.150 --> 00:02:33.500
And I don't work for some
government contractor.

00:02:33.500 --> 00:02:35.550
I don't work for a
bank or something

00:02:35.550 --> 00:02:38.310
like that or some other
old school system.

00:02:38.310 --> 00:02:40.360
I work for Google, right?

00:02:40.360 --> 00:02:44.880
The people who developed all
this cool new technology.

00:02:44.880 --> 00:02:46.580
Even at Google we
have these problems.

00:02:46.580 --> 00:02:51.520
We have these problems of these
old systems and these older

00:02:51.520 --> 00:02:52.870
applications that we've made.

00:02:52.870 --> 00:02:55.480
We don't magically get
all the new Polymer stuff

00:02:55.480 --> 00:02:57.990
just because we snapped our
fingers, and we invented it.

00:02:57.990 --> 00:03:00.820
It doesn't magically become into
every single one of our apps,

00:03:00.820 --> 00:03:01.390
right?

00:03:01.390 --> 00:03:05.290
We still have to day-to-day
deal with upgrading and making

00:03:05.290 --> 00:03:07.620
it happen and making all
this new technology go

00:03:07.620 --> 00:03:08.680
into our apps.

00:03:08.680 --> 00:03:11.160
And this is like, and I'm sure
many of you in the audience

00:03:11.160 --> 00:03:12.156
can relate, right?

00:03:12.156 --> 00:03:13.030
You're sitting there.

00:03:13.030 --> 00:03:14.946
You're learning about
all this new technology,

00:03:14.946 --> 00:03:18.002
and you're going, there's no way
I can use that at work, right?

00:03:18.002 --> 00:03:20.210
There's just so much work
that would need to be done,

00:03:20.210 --> 00:03:21.830
I don't even know
where to start.

00:03:21.830 --> 00:03:23.780
I don't even know
where to begin, right?

00:03:23.780 --> 00:03:25.490
Or maybe perhaps
you have the luxury

00:03:25.490 --> 00:03:28.220
of having a complete
green field system.

00:03:28.220 --> 00:03:30.080
You can start
everything from scratch,

00:03:30.080 --> 00:03:32.120
and you can do
whatever you want.

00:03:32.120 --> 00:03:34.860
But how do you make
sure that in one I/O,

00:03:34.860 --> 00:03:39.110
that in three I/Os, that in five
I/Os, and six years later, how

00:03:39.110 --> 00:03:41.330
can you ensure
that you, too, can

00:03:41.330 --> 00:03:43.420
use all the new technology
that's coming out then?

00:03:43.420 --> 00:03:47.900
What kind of practices can you
do to make sure that happens?

00:03:47.900 --> 00:03:53.120
So our goal for today is to
give you some of the challenges

00:03:53.120 --> 00:03:56.880
that we went through in trying
to upgrade our apps and some

00:03:56.880 --> 00:04:01.110
of the strategies that we had
so that we could make it happen.

00:04:01.110 --> 00:04:03.600
We'll give you some
examples on how we did that,

00:04:03.600 --> 00:04:07.070
but the more important is
the strategy and the tools

00:04:07.070 --> 00:04:10.760
that we tried to enforce to
make sure that we could make

00:04:10.760 --> 00:04:14.060
this upgrade much more easier,
more like a walk in a park

00:04:14.060 --> 00:04:18.089
and less like
scaling a mountain.

00:04:18.089 --> 00:04:19.529
PAUL ROHDE: Wow.

00:04:19.529 --> 00:04:23.660
I've never ever had to
deal with that ever.

00:04:23.660 --> 00:04:26.424
TED SANDER: You're lucky.

00:04:26.424 --> 00:04:27.840
PAUL ROHDE: You
guys have all seen

00:04:27.840 --> 00:04:30.120
this happen if you've
been in development

00:04:30.120 --> 00:04:31.620
for any amount of time.

00:04:31.620 --> 00:04:34.912
You've seen small applications
grow into large applications.

00:04:34.912 --> 00:04:36.120
You've seen these challenges.

00:04:36.120 --> 00:04:39.140
As systems get larger,
they strain the edges

00:04:39.140 --> 00:04:40.734
of what you can actually do.

00:04:40.734 --> 00:04:42.150
The technology
start to break down

00:04:42.150 --> 00:04:44.540
as your applications get bigger.

00:04:44.540 --> 00:04:46.920
And just maintaining
code after a while

00:04:46.920 --> 00:04:49.760
slowly gets to the
point where you just

00:04:49.760 --> 00:04:51.420
don't want to do it anymore.

00:04:51.420 --> 00:04:54.020
So today we're going to
talk through, like Ted said,

00:04:54.020 --> 00:04:56.650
what we've gone through, some
strategy we've been through.

00:04:56.650 --> 00:04:59.470
And we're going to cover
it in four major areas.

00:04:59.470 --> 00:05:02.420
First, we're going to talk about
large applications and just

00:05:02.420 --> 00:05:03.599
any application.

00:05:03.599 --> 00:05:05.640
We're going to talk about
how we break them apart

00:05:05.640 --> 00:05:07.360
into smaller pieces.

00:05:07.360 --> 00:05:10.280
We have huge applications,
and lots and lots of people

00:05:10.280 --> 00:05:12.430
work on them, so how do
we take 100 engineers

00:05:12.430 --> 00:05:15.150
and distribute it across
a single front end?

00:05:15.150 --> 00:05:16.702
So we'll talk about that.

00:05:16.702 --> 00:05:18.410
Second, we're going
to talk about testing

00:05:18.410 --> 00:05:20.150
because if you're
building a large front

00:05:20.150 --> 00:05:21.842
end or any large
application, you

00:05:21.842 --> 00:05:23.300
want to make sure
that it continues

00:05:23.300 --> 00:05:25.580
to work day after day.

00:05:25.580 --> 00:05:28.457
You may release it on
day one, and it may work.

00:05:28.457 --> 00:05:31.040
But how do you make sure that
it continues to work on day two,

00:05:31.040 --> 00:05:34.344
on day three, and release
number five, ten, 15,

00:05:34.344 --> 00:05:36.760
all the way out through the
life cycle of the application.

00:05:36.760 --> 00:05:38.301
So we're going to
talk about testing,

00:05:38.301 --> 00:05:41.364
what we do, how we do it, what
we found that's important.

00:05:41.364 --> 00:05:42.780
So we're going to
talk about that.

00:05:42.780 --> 00:05:47.022
Third, we want to make the
front end engineers productive.

00:05:47.022 --> 00:05:49.480
Like Ted said, you want to take
the development environment

00:05:49.480 --> 00:05:50.550
that you have at
home, the ability

00:05:50.550 --> 00:05:52.633
to go and hack stuff up
and build something really

00:05:52.633 --> 00:05:55.094
quickly, and then be able
to take that to work.

00:05:55.094 --> 00:05:56.510
So we want to show
you how to take

00:05:56.510 --> 00:05:58.590
that to work, what we've
done to make front end

00:05:58.590 --> 00:06:00.930
engineers productive,
and the tools that we use

00:06:00.930 --> 00:06:06.790
to pick frameworks and
tools that work for us.

00:06:06.790 --> 00:06:10.080
Fourth and finally, we're
going to tie this all together.

00:06:10.080 --> 00:06:12.140
We ended up with
Dart, but we're going

00:06:12.140 --> 00:06:14.460
to talk about how the
language takes everything

00:06:14.460 --> 00:06:17.470
that we're going to talk about
in the first three sections,

00:06:17.470 --> 00:06:19.192
and how it ties it all together.

00:06:19.192 --> 00:06:21.817
And then we're going to wrap it
up, and then we'll be all done.

00:06:23.902 --> 00:06:25.360
TED SANDER: So this
is great, Paul.

00:06:25.360 --> 00:06:28.210
I mean, but how in the world
are we ever going to start?

00:06:28.210 --> 00:06:31.680
We have hundreds of engineers,
millions of lines of code.

00:06:31.680 --> 00:06:33.820
It's just this huge, large app.

00:06:33.820 --> 00:06:37.052
How are we ever going to begin
to start porting this over

00:06:37.052 --> 00:06:38.800
to the new language?

00:06:38.800 --> 00:06:40.740
PAUL ROHDE: It's
a great question.

00:06:40.740 --> 00:06:42.600
We have huge front
ends at Google.

00:06:42.600 --> 00:06:45.790
These are not small,
little blog pages.

00:06:45.790 --> 00:06:48.270
We have applications that
have over a million lines

00:06:48.270 --> 00:06:50.300
of front end code.

00:06:50.300 --> 00:06:51.750
That's a lot.

00:06:51.750 --> 00:06:54.300
Not only that, we have hundreds
of engineers working on them.

00:06:54.300 --> 00:06:56.270
Now you'll see these
strains regardless

00:06:56.270 --> 00:06:57.610
of the size of the project
or the number of people

00:06:57.610 --> 00:06:59.026
you have working
on them, but just

00:06:59.026 --> 00:07:02.450
imagine how hard it is to deal
with a code base of that size

00:07:02.450 --> 00:07:04.480
and have that many engineers.

00:07:04.480 --> 00:07:10.001
Now take that, and release your
front end every single week.

00:07:10.001 --> 00:07:11.250
Think about that for a second.

00:07:11.250 --> 00:07:14.380
That's a hard
problem to deal with.

00:07:14.380 --> 00:07:16.530
As applications get
bigger, you have

00:07:16.530 --> 00:07:19.820
to avoid this place where
your applications can just

00:07:19.820 --> 00:07:22.950
start imploding on themselves.

00:07:22.950 --> 00:07:25.400
You want to avoid this.

00:07:25.400 --> 00:07:27.950
So we have a strategy.

00:07:27.950 --> 00:07:30.079
We want to divide
and conquer our apps.

00:07:30.079 --> 00:07:32.120
This is kind of what our
application looked like.

00:07:32.120 --> 00:07:35.930
You have one big front
end, one JavaScript binary,

00:07:35.930 --> 00:07:38.290
that has lots of
little sub-pieces.

00:07:38.290 --> 00:07:41.014
And this is the problem
because if you have something

00:07:41.014 --> 00:07:42.430
like this, where
every piece talks

00:07:42.430 --> 00:07:43.888
in different parts
of the app, it's

00:07:43.888 --> 00:07:46.850
hard to take a single
piece, pull it out, and work

00:07:46.850 --> 00:07:48.440
on it in isolation.

00:07:48.440 --> 00:07:49.410
So what do we do?

00:07:49.410 --> 00:07:51.190
We had to do something
for this because we

00:07:51.190 --> 00:07:53.189
needed to be able to have
all these engineers be

00:07:53.189 --> 00:07:55.310
productive and
actually build things.

00:07:55.310 --> 00:07:56.810
So we took it, and
we split it up.

00:08:00.670 --> 00:08:03.925
All right, so in
this case-- and this

00:08:03.925 --> 00:08:06.050
is not the only way we can
do it-- but in our case,

00:08:06.050 --> 00:08:07.850
we built the message bus.

00:08:07.850 --> 00:08:09.340
Very small, very simple.

00:08:09.340 --> 00:08:11.444
It was just one little
piece of JavaScript

00:08:11.444 --> 00:08:13.610
that let us pass messages
between other applications

00:08:13.610 --> 00:08:14.867
on the page.

00:08:14.867 --> 00:08:17.200
Now I guess a little context
is the front end that we're

00:08:17.200 --> 00:08:18.950
talking about is all
a single application.

00:08:18.950 --> 00:08:21.970
It's a single page, but we broke
it up into smaller sub-apps,

00:08:21.970 --> 00:08:25.860
and each app talks to the other
apps through this message bus.

00:08:25.860 --> 00:08:28.180
What this allowed
us to do, because we

00:08:28.180 --> 00:08:29.910
had separate
JavaScript binaries,

00:08:29.910 --> 00:08:34.880
is we can now replace any
single application individually.

00:08:34.880 --> 00:08:37.750
A team of developers can work
on one single application

00:08:37.750 --> 00:08:40.070
without having to deal with
a lot of the interactions

00:08:40.070 --> 00:08:41.520
of the other pieces.

00:08:41.520 --> 00:08:42.940
It lets us version things.

00:08:42.940 --> 00:08:47.660
It lets teams release
things on different dates.

00:08:47.660 --> 00:08:50.810
How many of you have sat back
and had to everybody coordinate

00:08:50.810 --> 00:08:52.160
for the same release?

00:08:52.160 --> 00:08:55.960
Having 200 engineers or even
100 engineers or even 10,

00:08:55.960 --> 00:08:58.760
just getting them all to get
their code in so that you

00:08:58.760 --> 00:09:00.737
can actually release
something is really hard.

00:09:00.737 --> 00:09:02.570
So being able to have
smaller sub-teams that

00:09:02.570 --> 00:09:04.900
release independently and
develop their own features,

00:09:04.900 --> 00:09:07.580
and it can all work together
in one cohesive way is

00:09:07.580 --> 00:09:08.770
really, really powerful.

00:09:13.220 --> 00:09:15.934
So it's this idea of
one simple interface.

00:09:15.934 --> 00:09:17.850
In our case, this was
really, really powerful.

00:09:17.850 --> 00:09:20.840
Having a single point of
failure and a single place

00:09:20.840 --> 00:09:23.239
where everything coordinates
was really powerful.

00:09:23.239 --> 00:09:24.780
Now, globals are
generally bad so you

00:09:24.780 --> 00:09:27.810
don't want to do this all
the time, but in this case,

00:09:27.810 --> 00:09:29.730
it enabled us to do so
many other things that

00:09:29.730 --> 00:09:30.604
were really valuable.

00:09:33.710 --> 00:09:35.000
So that's that.

00:09:35.000 --> 00:09:38.870
And my slides are
being wonderful.

00:09:38.870 --> 00:09:39.840
Here's an example.

00:09:39.840 --> 00:09:41.770
We got some concrete
code examples.

00:09:41.770 --> 00:09:45.550
Just we have a global context,
which has a message bus in it,

00:09:45.550 --> 00:09:47.220
and a simple send and listen.

00:09:47.220 --> 00:09:49.620
In our case, we used
just JavaScript maps

00:09:49.620 --> 00:09:52.290
with string variables
and then just passed

00:09:52.290 --> 00:09:53.620
them back and forth.

00:09:53.620 --> 00:09:56.207
Very simple, all
done by convention,

00:09:56.207 --> 00:09:58.290
but again, it was something
that was very powerful

00:09:58.290 --> 00:10:01.510
and enabled us to do
a lot of new things.

00:10:01.510 --> 00:10:02.220
So this is cool.

00:10:02.220 --> 00:10:03.500
So you can take your app,
and you can build it.

00:10:03.500 --> 00:10:05.380
And you can break it
apart into small pieces.

00:10:05.380 --> 00:10:07.910
And this is good regardless
of the application

00:10:07.910 --> 00:10:09.180
that you're building.

00:10:09.180 --> 00:10:12.320
But if you do this,
all of a sudden,

00:10:12.320 --> 00:10:14.720
your applications have a lot
of code they need to share.

00:10:14.720 --> 00:10:18.410
So Ted, how are we going
to deal with this problem?

00:10:18.410 --> 00:10:20.250
We want to be able to
share all this code,

00:10:20.250 --> 00:10:22.886
but we don't want to duplicate
it and write it all over again.

00:10:22.886 --> 00:10:23.670
TED SANDER: Yeah,
it's a good question.

00:10:23.670 --> 00:10:25.120
I mean, you have all
these different apps.

00:10:25.120 --> 00:10:26.745
They're written in
different languages.

00:10:26.745 --> 00:10:28.300
There's configuration
between them.

00:10:28.300 --> 00:10:31.410
There's the APIs that all
need to talk similarly.

00:10:31.410 --> 00:10:33.750
How in the world are we going
to make this happen across

00:10:33.750 --> 00:10:35.800
all these different apps?

00:10:35.800 --> 00:10:39.150
Well, the strategy is to always
have a single source of truth.

00:10:39.150 --> 00:10:40.490
And what do I mean by that?

00:10:40.490 --> 00:10:42.800
Well, you don't want
to have to hand write

00:10:42.800 --> 00:10:44.250
two different things.

00:10:44.250 --> 00:10:47.820
You don't want to have your
API written in handwritten Dart

00:10:47.820 --> 00:10:50.560
and then handwritten
in JavaScript.

00:10:50.560 --> 00:10:53.057
Because then, what's going
to happen is somebody's

00:10:53.057 --> 00:10:55.390
going to change one and then
forget to change the other,

00:10:55.390 --> 00:10:56.890
and you're going
to have this hidden

00:10:56.890 --> 00:10:58.491
bug that you're
never going to find.

00:10:58.491 --> 00:11:00.740
And this pattern comes up a
lot for this single source

00:11:00.740 --> 00:11:04.590
of truth, for configurations,
for APIs, stuff like that.

00:11:04.590 --> 00:11:07.470
So let's take an example.

00:11:07.470 --> 00:11:08.610
AdWords API.

00:11:08.610 --> 00:11:11.750
As you can imagine, we want to
use as many people as possible

00:11:11.750 --> 00:11:15.200
to use AdWords API
as they would like.

00:11:15.200 --> 00:11:17.190
It's 100,000 lines of code.

00:11:17.190 --> 00:11:19.370
And this is just
four interfaces.

00:11:19.370 --> 00:11:22.020
I'm not talking about the
limitation of the AdWords API

00:11:22.020 --> 00:11:24.600
at all, just the API itself.

00:11:24.600 --> 00:11:27.040
And there's 34 services
that people can use.

00:11:27.040 --> 00:11:28.655
And we ourselves
use this service.

00:11:28.655 --> 00:11:31.040
We dogfood our own API.

00:11:31.040 --> 00:11:33.080
So the APIs that
developers are using

00:11:33.080 --> 00:11:36.430
are the APIs that
we use ourselves.

00:11:36.430 --> 00:11:38.180
Now we want to
allow any developer

00:11:38.180 --> 00:11:41.680
to be able to write using
this API as possible.

00:11:41.680 --> 00:11:43.110
It makes Google money.

00:11:43.110 --> 00:11:44.990
AdWords API makes us money.

00:11:44.990 --> 00:11:47.430
So any [INAUDIBLE] language
the developer wants to use,

00:11:47.430 --> 00:11:49.150
we want to support if we can.

00:11:49.150 --> 00:11:51.640
So there's six total
client languages

00:11:51.640 --> 00:11:55.300
that we have, and we'd be crazy
to write 100,000 lines of code

00:11:55.300 --> 00:11:56.430
six times.

00:11:56.430 --> 00:11:58.140
It's just not going to happen.

00:11:58.140 --> 00:12:01.340
So how do we do this?

00:12:01.340 --> 00:12:04.300
Well, we generate our API.

00:12:04.300 --> 00:12:08.730
We have one consistent API,
and we generate everything else

00:12:08.730 --> 00:12:11.190
from that in all
the other languages.

00:12:11.190 --> 00:12:14.070
So having a single
source of truth.

00:12:14.070 --> 00:12:18.270
So let's do a very simple
example for a configuration.

00:12:18.270 --> 00:12:19.760
At Google, we love protobuffers.

00:12:19.760 --> 00:12:22.160
We use them all over the place.

00:12:22.160 --> 00:12:23.760
So we have a very
simple protobuffer.

00:12:23.760 --> 00:12:25.910
It's a rainbow that has
the number of colors

00:12:25.910 --> 00:12:27.970
that it could have.

00:12:27.970 --> 00:12:32.520
From this, we can generate
the Java code very simply.

00:12:32.520 --> 00:12:35.200
It has its getters and setters.

00:12:35.200 --> 00:12:39.150
And we can generate
the Dart code.

00:12:39.150 --> 00:12:41.510
And protobufs support
some other languages, too.

00:12:41.510 --> 00:12:44.100
So we have the one
single source of truth,

00:12:44.100 --> 00:12:46.100
which is the protobuf,
and from that

00:12:46.100 --> 00:12:49.420
we can generate the language
independent versions that we

00:12:49.420 --> 00:12:50.289
need.

00:12:50.289 --> 00:12:52.580
And you can generate this
using the dart-protoc-plugin.

00:12:55.512 --> 00:12:56.220
OK, that's great.

00:12:56.220 --> 00:12:59.130
You could use protobufs
for configuration.

00:12:59.130 --> 00:13:02.050
You can use Yammer for
configuration, anything

00:13:02.050 --> 00:13:03.750
that supports
multiple languages,

00:13:03.750 --> 00:13:06.250
and you can get
along fine there.

00:13:06.250 --> 00:13:08.130
But what about your API?

00:13:08.130 --> 00:13:10.750
Well, you could use protobufs.

00:13:10.750 --> 00:13:11.780
You could use JSON.

00:13:11.780 --> 00:13:13.530
You could also use
Google Cloud Endpoints.

00:13:13.530 --> 00:13:15.570
That supports many
different languages.

00:13:15.570 --> 00:13:21.570
Or you could use Thrift or
a similar system to do this.

00:13:21.570 --> 00:13:24.170
So here's a very simple example.

00:13:24.170 --> 00:13:28.670
Let's say we want to send those
rainbow objects to our server.

00:13:28.670 --> 00:13:32.050
Luckily for us, in Dart,
it's really, really easy.

00:13:32.050 --> 00:13:34.610
You have a URL to the
endpoint of your service,

00:13:34.610 --> 00:13:38.670
and then you can actually just
post on a request to JSON,

00:13:38.670 --> 00:13:42.570
and protobuffers actually
have JSON support built in.

00:13:42.570 --> 00:13:44.740
You also could do it in
binary, but we found out

00:13:44.740 --> 00:13:46.550
the JSON was way
faster than binary

00:13:46.550 --> 00:13:48.382
so that's why we
chose that direction.

00:13:53.042 --> 00:13:54.100
PAUL ROHDE: Cool.

00:13:54.100 --> 00:13:55.912
So we can generate stuff.

00:13:55.912 --> 00:13:56.620
We can do things.

00:13:56.620 --> 00:13:58.380
We can break apart
our application.

00:13:58.380 --> 00:14:00.100
But that doesn't
really mean anything

00:14:00.100 --> 00:14:02.687
unless we can actually
make sure it's still works.

00:14:02.687 --> 00:14:04.270
I mean, you want it
to be able to work

00:14:04.270 --> 00:14:06.660
one day, the next day,
and the day after.

00:14:06.660 --> 00:14:09.300
And we've seen some pretty
bad examples of code

00:14:09.300 --> 00:14:14.526
that failed that was
not very well tested.

00:14:14.526 --> 00:14:15.900
I think that there
should be ways

00:14:15.900 --> 00:14:19.010
that we should be able to ensure
that a code continues to work

00:14:19.010 --> 00:14:21.320
and that it actually works
the way you intend it to,

00:14:21.320 --> 00:14:21.750
which is really.

00:14:21.750 --> 00:14:22.340
Important

00:14:22.340 --> 00:14:24.070
So how are we going to do that?

00:14:24.070 --> 00:14:25.653
TED SANDER: Yeah,
so this problem even

00:14:25.653 --> 00:14:27.425
goes farther than that.

00:14:27.425 --> 00:14:29.800
The landscape we
live in, everything's

00:14:29.800 --> 00:14:31.380
moving really, really fast.

00:14:31.380 --> 00:14:33.290
The Angular team,
we use Angular.

00:14:33.290 --> 00:14:35.290
Angular's making changes
to improve their system

00:14:35.290 --> 00:14:37.580
every single day,
every single week.

00:14:37.580 --> 00:14:38.160
Polymer.

00:14:38.160 --> 00:14:40.630
Polymer's actually
a moving target.

00:14:40.630 --> 00:14:42.800
A lot of these are in spec,
but they change things

00:14:42.800 --> 00:14:45.710
and make things different every
single day, every single week.

00:14:45.710 --> 00:14:48.320
So you have the
libraries, the whole Earth

00:14:48.320 --> 00:14:49.760
is shaking under
you and changing.

00:14:49.760 --> 00:14:51.970
How do you make sure that
all that's working, too?

00:14:51.970 --> 00:14:53.760
It's a big problem.

00:14:53.760 --> 00:14:55.970
And the only way that
we've had to solve this

00:14:55.970 --> 00:14:57.520
was test coverage.

00:14:57.520 --> 00:14:58.640
Test coverage is key.

00:14:58.640 --> 00:15:00.460
So what do I mean
by test coverage?

00:15:00.460 --> 00:15:03.200
That means how much of
your production code

00:15:03.200 --> 00:15:05.950
is covered by tests?

00:15:05.950 --> 00:15:08.780
How much unit tests, how
many integration tests,

00:15:08.780 --> 00:15:10.940
How many UI tests do you have?

00:15:10.940 --> 00:15:13.257
Luckily, all the languages
we chose and stuff like that

00:15:13.257 --> 00:15:14.340
make it really easy to do.

00:15:14.340 --> 00:15:17.540
And at Google, we
have an idea, and that

00:15:17.540 --> 00:15:20.080
is the idea of test sizes.

00:15:20.080 --> 00:15:23.870
Not all tests are created equal.

00:15:23.870 --> 00:15:25.900
So there's three
different versions

00:15:25.900 --> 00:15:27.860
that we have at
Google, and we like

00:15:27.860 --> 00:15:29.840
to categorize them as this.

00:15:29.840 --> 00:15:31.360
And one is small test.

00:15:31.360 --> 00:15:33.610
Small tests run
very, very quickly,

00:15:33.610 --> 00:15:35.290
less than 100 milliseconds.

00:15:35.290 --> 00:15:38.370
Mostly they're unit tests
and that kind of level,

00:15:38.370 --> 00:15:40.580
and we'll talk a little
bit about what that is.

00:15:40.580 --> 00:15:41.790
Then we have medium tests.

00:15:41.790 --> 00:15:45.010
Medium tests execute
in about a second,

00:15:45.010 --> 00:15:47.659
and these are UI tests,
integration tests,

00:15:47.659 --> 00:15:49.200
things that still
run pretty quickly,

00:15:49.200 --> 00:15:51.140
but they're a little
bit more complex.

00:15:51.140 --> 00:15:52.930
Then we have large tests.

00:15:52.930 --> 00:15:55.120
These things can take
up to 15 minutes.

00:15:55.120 --> 00:15:56.460
They're insane.

00:15:56.460 --> 00:16:01.170
We have full stack tests, maybe
they're performance tests,

00:16:01.170 --> 00:16:03.336
and largely they're
automated tests.

00:16:03.336 --> 00:16:04.085
So what are these?

00:16:04.085 --> 00:16:06.400
These are the web
browser is actually

00:16:06.400 --> 00:16:10.330
running to input the
code on your web page.

00:16:10.330 --> 00:16:13.190
So you actually see the
text being filled out.

00:16:13.190 --> 00:16:15.330
You see the select
boxes being chosen.

00:16:15.330 --> 00:16:17.640
It makes you feel really
good because your web page is

00:16:17.640 --> 00:16:21.580
actually working, and that's
the way the test is working.

00:16:21.580 --> 00:16:23.250
So it gives you a
security blanket,

00:16:23.250 --> 00:16:26.720
but they're so long to run,
they're actually not that good.

00:16:26.720 --> 00:16:30.640
So here's what your desired test
coverage you want it to look

00:16:30.640 --> 00:16:31.140
like.

00:16:31.140 --> 00:16:34.700
You want to have about 10%
covered by large tests.

00:16:34.700 --> 00:16:36.320
You don't want to
use them too often.

00:16:36.320 --> 00:16:38.620
You want to maybe
have a smoke test

00:16:38.620 --> 00:16:40.990
or a stress test,
something like that,

00:16:40.990 --> 00:16:43.240
just to make sure
everything's still working.

00:16:43.240 --> 00:16:45.350
Medium tests,
those are UI tests.

00:16:45.350 --> 00:16:46.934
UIs usually you have
a little bit more

00:16:46.934 --> 00:16:48.849
of these because they
take a little bit longer

00:16:48.849 --> 00:16:51.350
to run because you need a
browser and interact with DOM.

00:16:51.350 --> 00:16:52.900
And then you have
your small tests.

00:16:52.900 --> 00:16:56.590
So medium tests, you want about
50% coverage, and small tests,

00:16:56.590 --> 00:16:58.830
you want about 70% coverage.

00:16:58.830 --> 00:17:01.210
And if you're going to have
more coverage on small tests,

00:17:01.210 --> 00:17:02.570
then that's good.

00:17:02.570 --> 00:17:05.470
Small tests are just the
unit tests like I said.

00:17:05.470 --> 00:17:06.730
But this was our problem.

00:17:06.730 --> 00:17:09.980
This is what our test
coverage looked like.

00:17:09.980 --> 00:17:12.700
We had all of these large tests.

00:17:12.700 --> 00:17:16.990
Our tests sometimes took hours
to run on our application.

00:17:16.990 --> 00:17:19.730
Because we felt really good
with these automated tests.

00:17:19.730 --> 00:17:22.450
We could see that
everything was working.

00:17:22.450 --> 00:17:25.329
It was actually running
our application fully,

00:17:25.329 --> 00:17:29.060
and it made us feel really
good inside to see it working.

00:17:29.060 --> 00:17:32.900
But it made the tests
what we call flaky,

00:17:32.900 --> 00:17:34.290
and what does flaky mean?

00:17:34.290 --> 00:17:38.420
Flaky means that you had
the test errored out,

00:17:38.420 --> 00:17:39.530
and the test didn't work.

00:17:39.530 --> 00:17:44.360
It failed, but really if you run
it again, it's going to pass.

00:17:44.360 --> 00:17:47.070
There's nothing to make that
test fail in the actual code.

00:17:47.070 --> 00:17:49.270
It's just because it
took too long to run.

00:17:49.270 --> 00:17:51.880
It timed out,
something like that.

00:17:51.880 --> 00:17:54.240
And then we had this
problem with medium tests.

00:17:54.240 --> 00:17:56.020
Medium tests, UI
tests, got a bad rap.

00:17:56.020 --> 00:17:57.234
They were hard to write.

00:17:57.234 --> 00:17:58.650
There were some
problem with them,

00:17:58.650 --> 00:18:00.941
and everybody was like, Oh,
I don't want to write them.

00:18:00.941 --> 00:18:03.440
I'll just write an
automated test instead.

00:18:03.440 --> 00:18:06.340
And it created this
huge problem that we

00:18:06.340 --> 00:18:08.190
couldn't rely on our tests.

00:18:08.190 --> 00:18:10.670
They would fail all
the time for no reason,

00:18:10.670 --> 00:18:12.970
and you were just like,
oh well, the build's red,

00:18:12.970 --> 00:18:15.553
but that's probably just because
it's going to work next time.

00:18:15.553 --> 00:18:17.420
I won't worry about it.

00:18:17.420 --> 00:18:20.370
So how did we fix this?

00:18:20.370 --> 00:18:22.991
Well, luckily, the tools
that we decided to use

00:18:22.991 --> 00:18:25.490
make it really easy, and there
were some philosophy changes,

00:18:25.490 --> 00:18:26.680
too.

00:18:26.680 --> 00:18:30.780
So one thing is quickly,
what do the unit

00:18:30.780 --> 00:18:32.470
tests look like in Dart?

00:18:32.470 --> 00:18:34.140
Well, it's really easy to write.

00:18:34.140 --> 00:18:35.930
You want to keep
it really simple.

00:18:35.930 --> 00:18:38.350
You want to have one action,
and for that one action,

00:18:38.350 --> 00:18:40.100
you want to make
sure that it has

00:18:40.100 --> 00:18:42.400
the expected value
that you expect.

00:18:42.400 --> 00:18:45.250
You want to try to only test
very little things if you can.

00:18:45.250 --> 00:18:48.270
Don't have a unit
test that tries

00:18:48.270 --> 00:18:50.200
to cover like every
single inspection

00:18:50.200 --> 00:18:51.800
that you want in
that one unit test.

00:18:51.800 --> 00:18:52.570
Why?

00:18:52.570 --> 00:18:54.600
Because the next developer
that comes along,

00:18:54.600 --> 00:18:57.790
he won't know if it's failing
because one specific thing

00:18:57.790 --> 00:19:01.790
or it's failing 3/4 because
of something specific.

00:19:01.790 --> 00:19:04.660
If you make it really specific,
then they can look at the title

00:19:04.660 --> 00:19:07.160
and hopefully go, oh, I don't
even need to look at the code.

00:19:07.160 --> 00:19:10.240
I can figure out exactly
why this is breaking.

00:19:10.240 --> 00:19:13.866
So another problem that we
had was asynchronous testing.

00:19:13.866 --> 00:19:15.240
Asynchronous
testing was actually

00:19:15.240 --> 00:19:19.450
really hard in our old
system, but luckily Dart

00:19:19.450 --> 00:19:20.800
makes it a little easier.

00:19:20.800 --> 00:19:24.090
But Angular makes it
very easy, and I'll even

00:19:24.090 --> 00:19:26.800
use asynchronous testing
using Dart Angular

00:19:26.800 --> 00:19:30.340
without needing Angular at all.

00:19:30.340 --> 00:19:32.820
So what do I mean by this?

00:19:32.820 --> 00:19:37.400
Well, Angular turns
asynch testing

00:19:37.400 --> 00:19:40.660
into synchronous testing,
which is awesome.

00:19:40.660 --> 00:19:43.430
They like to call
it time travel.

00:19:43.430 --> 00:19:45.700
They actually control the clock.

00:19:45.700 --> 00:19:47.850
So if we look at
our little example,

00:19:47.850 --> 00:19:49.612
there's a future in
there, and that future

00:19:49.612 --> 00:19:51.820
is not going to be run right
away when it's declared.

00:19:51.820 --> 00:19:54.600
It's going to be run
later at some time.

00:19:54.600 --> 00:19:57.050
In the Dart regular unit
test, you just kind of say

00:19:57.050 --> 00:19:58.430
that there'll be a future later.

00:19:58.430 --> 00:20:01.090
And you can hook onto it,
and it will eventually

00:20:01.090 --> 00:20:02.280
allow you to test it.

00:20:02.280 --> 00:20:05.150
But using Angular,
as you can see,

00:20:05.150 --> 00:20:07.040
at first, it's a false value.

00:20:07.040 --> 00:20:08.930
But then you give up
your rendering loop,

00:20:08.930 --> 00:20:11.380
and you say, oh, please do
whatever you need to do.

00:20:11.380 --> 00:20:14.010
Please leap forward into time.

00:20:14.010 --> 00:20:15.650
And then the future's
actually run,

00:20:15.650 --> 00:20:17.850
and we can actually make
sure that the value's

00:20:17.850 --> 00:20:19.530
what we expect.

00:20:19.530 --> 00:20:22.390
Turning asynchronous testing
into synchronous testing.

00:20:22.390 --> 00:20:24.170
Super powerful,
made it less flaky.

00:20:26.900 --> 00:20:27.892
OK, UI tests.

00:20:27.892 --> 00:20:28.850
Here's another problem.

00:20:28.850 --> 00:20:32.130
We didn't like writing UI
tests, They were hard for us.

00:20:32.130 --> 00:20:34.880
Again, Angular to the rescue.

00:20:34.880 --> 00:20:38.970
So there's a way to easily
have testbed, which sets up

00:20:38.970 --> 00:20:41.360
your Angular components
and directives.

00:20:41.360 --> 00:20:45.660
And then you can actually pull
out the Angular object itself

00:20:45.660 --> 00:20:48.020
and then play with
the Angular object,

00:20:48.020 --> 00:20:50.650
rather than using
DOM manipulation

00:20:50.650 --> 00:20:53.980
or sending DOM event somewhere,
doing something kind of crazy

00:20:53.980 --> 00:20:54.580
like that.

00:20:54.580 --> 00:20:57.840
You can actually test the
higher level object, which

00:20:57.840 --> 00:21:01.130
makes it very easy, yet at the
same time, you have the HTML.

00:21:01.130 --> 00:21:03.820
So you can quickly make
a little snippet of HTML

00:21:03.820 --> 00:21:05.310
and start testing things nicely.

00:21:08.170 --> 00:21:10.230
OK, so we have this
problem at Google

00:21:10.230 --> 00:21:12.480
that since all these
other teams are working

00:21:12.480 --> 00:21:14.350
on completely
separate things, how

00:21:14.350 --> 00:21:17.572
can you make sure that
the team next to you

00:21:17.572 --> 00:21:19.530
didn't change their
interface or make something

00:21:19.530 --> 00:21:20.920
that's going to break you?

00:21:20.920 --> 00:21:23.310
And I have a great
example for this.

00:21:23.310 --> 00:21:26.420
And that's in 1999,
there was this project,

00:21:26.420 --> 00:21:29.390
and it was called
the Mars Orbital.

00:21:29.390 --> 00:21:32.380
And the Mars Orbital
gave out the project

00:21:32.380 --> 00:21:35.370
to a couple different
government contractors,

00:21:35.370 --> 00:21:40.100
and the systems, in
separation, worked great.

00:21:40.100 --> 00:21:41.680
Each government
contractor tested it,

00:21:41.680 --> 00:21:43.560
and it worked awesome.

00:21:43.560 --> 00:21:45.710
But it turned out one
government contractor

00:21:45.710 --> 00:21:47.020
was using English units.

00:21:47.020 --> 00:21:47.982
They used feet.

00:21:47.982 --> 00:21:49.440
And the other
government contractor

00:21:49.440 --> 00:21:51.670
decided to use metric
like the rest of the world

00:21:51.670 --> 00:21:54.360
does, but NASA doesn't
use metric, by the way.

00:21:54.360 --> 00:21:56.970
They use English.

00:21:56.970 --> 00:22:00.500
So when this is actually
going up to Mars,

00:22:00.500 --> 00:22:04.160
when it was about to orbit
Mars, the systems freaked out

00:22:04.160 --> 00:22:06.566
because one was telling
it the feet value,

00:22:06.566 --> 00:22:08.190
and the other one
was expecting metric.

00:22:08.190 --> 00:22:11.060
So it thought it was going
to crash land into Mars.

00:22:11.060 --> 00:22:11.669
So it bailed.

00:22:11.669 --> 00:22:12.960
It's like, Oh, I'm out of here.

00:22:12.960 --> 00:22:14.040
We got to make sure
this doesn't happen.

00:22:14.040 --> 00:22:15.581
I don't want to
crash land into Mars.

00:22:15.581 --> 00:22:18.095
And actually sling
shot right past it.

00:22:18.095 --> 00:22:20.260
$100 million mistake
that could have

00:22:20.260 --> 00:22:22.080
been solved with
integration testing.

00:22:22.080 --> 00:22:25.030
And this happens for us, too.

00:22:25.030 --> 00:22:29.450
You have maybe a library
that you don't quite rely on

00:22:29.450 --> 00:22:32.244
or it's a little sketchy,
but you need to use it.

00:22:32.244 --> 00:22:33.910
Maybe you're worried
about them changing

00:22:33.910 --> 00:22:35.650
their interface,
something like that.

00:22:35.650 --> 00:22:37.250
And you want to
test the integration

00:22:37.250 --> 00:22:38.480
between your pieces.

00:22:38.480 --> 00:22:40.740
Or for us, we have those
integration points.

00:22:40.740 --> 00:22:41.970
We split up all the apps.

00:22:41.970 --> 00:22:44.970
We need to make sure that if
somebody changes one interface,

00:22:44.970 --> 00:22:48.520
that it's not going to break
some other application.

00:22:48.520 --> 00:22:51.750
And so here's a really
simple interface,

00:22:51.750 --> 00:22:55.310
simple way to test two widgets.

00:22:55.310 --> 00:22:58.240
I just came from Brazil,
and one of the problems

00:22:58.240 --> 00:23:00.490
that I had there is
every time I tried

00:23:00.490 --> 00:23:04.330
to enter my information
into an airline form

00:23:04.330 --> 00:23:06.640
or whatever it might
be, Brazil actually

00:23:06.640 --> 00:23:09.500
has different telephone input.

00:23:09.500 --> 00:23:11.367
So here's an
example of something

00:23:11.367 --> 00:23:13.950
where you could have one, which
is the country selector, which

00:23:13.950 --> 00:23:15.990
allows you to select
which country you're from,

00:23:15.990 --> 00:23:18.450
and the other's the
telephone input.

00:23:18.450 --> 00:23:20.980
So when you choose Brazil,
the telephone input

00:23:20.980 --> 00:23:24.570
should change and should give
you the right input for Brazil.

00:23:24.570 --> 00:23:26.160
If you have the
US, then it should

00:23:26.160 --> 00:23:28.930
be the right input
for the US, You

00:23:28.930 --> 00:23:32.390
don't need to fully test
each widget in this test.

00:23:32.390 --> 00:23:34.670
You just want to make
sure that that interaction

00:23:34.670 --> 00:23:39.540
between the two is working
in the way that you expect.

00:23:39.540 --> 00:23:44.910
OK, and lastly, we are
always testing at Google.

00:23:44.910 --> 00:23:46.660
And luckily, it's not
QA testing because I

00:23:46.660 --> 00:23:48.200
wouldn't get any work done.

00:23:48.200 --> 00:23:51.610
It's not me clicking buttons
because that wouldn't be fun,

00:23:51.610 --> 00:23:55.420
and honestly, I probably
wouldn't find too many bugs.

00:23:55.420 --> 00:23:57.430
But we are always testing.

00:23:57.430 --> 00:23:59.560
Our cloud is always
testing our code.

00:23:59.560 --> 00:24:01.250
So what do I mean by this?

00:24:01.250 --> 00:24:03.750
Well, every time before
we check in any code,

00:24:03.750 --> 00:24:06.230
we make sure it works
on our code base.

00:24:06.230 --> 00:24:08.420
Any time any other team
checks in the code,

00:24:08.420 --> 00:24:12.380
like Angular or Polymer, we
make sure that that code works.

00:24:12.380 --> 00:24:14.120
And we've got our
own tools to do this,

00:24:14.120 --> 00:24:17.494
but you, too, can do
something like this.

00:24:17.494 --> 00:24:18.660
And here's an example of it.

00:24:18.660 --> 00:24:20.270
It's Travis.

00:24:20.270 --> 00:24:23.040
Travis and Jenkins are two
good tools that you could use,

00:24:23.040 --> 00:24:25.320
and the Angular Dart
project actually

00:24:25.320 --> 00:24:28.420
uses it externally for GitHub
so you could check their page

00:24:28.420 --> 00:24:30.630
to make sure that they're
working correctly,

00:24:30.630 --> 00:24:34.610
and make sure everything
works well there.

00:24:34.610 --> 00:24:39.510
So Paul, like I said before,
we had this problem of there's

00:24:39.510 --> 00:24:40.370
so much DOM.

00:24:40.370 --> 00:24:43.860
We had this div soup, and
writing front ends was hard.

00:24:43.860 --> 00:24:46.375
I was like five
levels above the DOM.

00:24:46.375 --> 00:24:48.910
I didn't even know what
it looked like anymore.

00:24:48.910 --> 00:24:51.030
How are we going to
fix that problem?

00:24:51.030 --> 00:24:52.730
PAUL ROHDE: Yeah,
it's a hard problem.

00:24:58.390 --> 00:25:01.620
When I first started,
our front ends,

00:25:01.620 --> 00:25:05.190
they would take 15 to
20 minutes to compile.

00:25:05.190 --> 00:25:08.300
So I would go, and I would sit
down and I'd make a change,

00:25:08.300 --> 00:25:09.890
and then I would go play
Candy Crush for a little while

00:25:09.890 --> 00:25:11.140
and wait for my code to compile.

00:25:11.140 --> 00:25:12.681
Then I would go back
and actually see

00:25:12.681 --> 00:25:13.940
what actually happened.

00:25:13.940 --> 00:25:18.380
And this is terrible, waiting
that long for something

00:25:18.380 --> 00:25:20.490
to compile.

00:25:20.490 --> 00:25:23.110
There's just no way that that's
going to make me productive.

00:25:23.110 --> 00:25:24.860
Some applications were
a little bit worse.

00:25:24.860 --> 00:25:26.110
Some were a little bit better.

00:25:26.110 --> 00:25:28.490
But having the compile time
that just took that long

00:25:28.490 --> 00:25:30.930
to actually see a
change, your mind

00:25:30.930 --> 00:25:33.350
just does this mental
context switch.

00:25:33.350 --> 00:25:34.460
And you have to go back.

00:25:34.460 --> 00:25:36.168
You have to remember
what you were doing,

00:25:36.168 --> 00:25:37.910
what you changed
why you changed it.

00:25:37.910 --> 00:25:40.440
And it also means you end
up coding really badly.

00:25:40.440 --> 00:25:43.232
You end up sitting down and
writing like 120 lines of code

00:25:43.232 --> 00:25:45.190
because you don't want
to wait for the compile,

00:25:45.190 --> 00:25:49.370
and you just hit Go, and
I hope that was right.

00:25:49.370 --> 00:25:50.540
So this was one problem.

00:25:50.540 --> 00:25:52.900
So as we started looking
forward and saying, OK,

00:25:52.900 --> 00:25:54.187
what do we want to do next?

00:25:54.187 --> 00:25:56.270
This was one of the problems
we wanted to address.

00:25:56.270 --> 00:25:58.770
We wanted front end
developers to be productive,

00:25:58.770 --> 00:26:01.780
to make a change and
instantly see it happen.

00:26:01.780 --> 00:26:03.350
So that was one problem.

00:26:03.350 --> 00:26:07.780
The other problem was we got
really far away from the DOM.

00:26:07.780 --> 00:26:12.650
Now back about five years ago or
so, this was really important.

00:26:12.650 --> 00:26:15.160
Like how many of you
remember seeing polyfills

00:26:15.160 --> 00:26:18.000
make rounded corners
on buttons and things?

00:26:18.000 --> 00:26:21.109
Or how many times did you
try to align stuff with CSS,

00:26:21.109 --> 00:26:21.900
but it didn't work?

00:26:21.900 --> 00:26:24.310
But it worked in one browser,
and then another browser

00:26:24.310 --> 00:26:24.820
didn't work.

00:26:27.340 --> 00:26:29.750
So we got farther away from
the DOM for good reason

00:26:29.750 --> 00:26:32.699
because the browsers weren't
able to be consistent.

00:26:32.699 --> 00:26:33.990
So now the browsers are tested.

00:26:33.990 --> 00:26:36.660
Now they all work fairly well,
and the alignment usually

00:26:36.660 --> 00:26:39.730
works most of the
way you expect it to.

00:26:39.730 --> 00:26:41.407
But I still have this problem.

00:26:41.407 --> 00:26:42.865
Because I was using
frameworks that

00:26:42.865 --> 00:26:44.440
were farther away
from the DOM, I

00:26:44.440 --> 00:26:46.899
could build something in the
prototype in a couple of days.

00:26:46.899 --> 00:26:48.273
I'm usually pretty
good with CSS.

00:26:48.273 --> 00:26:49.520
I'm pretty good with HTML.

00:26:49.520 --> 00:26:51.353
I could throw something
together and make it

00:26:51.353 --> 00:26:54.160
all work and function basically
the way that I wanted it to.

00:26:54.160 --> 00:26:56.661
But then I would
take that prototype,

00:26:56.661 --> 00:26:59.160
and then I wanted to actually
build it in a production code.

00:26:59.160 --> 00:27:00.900
Now obviously there's going
to be some amount of overhead

00:27:00.900 --> 00:27:02.620
to do this because there's all
the [? edge kiss ?] you have

00:27:02.620 --> 00:27:04.790
to account for and
things like that.

00:27:04.790 --> 00:27:07.770
But if it took me
two days to build it,

00:27:07.770 --> 00:27:10.530
it would take me two
weeks to actually--

00:27:10.530 --> 00:27:12.530
even longer, even a
month-- to actually build

00:27:12.530 --> 00:27:15.870
a final version of
whatever I wanted to build.

00:27:15.870 --> 00:27:19.680
And this just killed my joy
of actually building stuff.

00:27:19.680 --> 00:27:21.600
So as we went
forward and we wanted

00:27:21.600 --> 00:27:23.290
to do something
different, we started

00:27:23.290 --> 00:27:25.420
looking at what can we do
to get closer to the DOM,

00:27:25.420 --> 00:27:29.090
and what can we do to solve
some of these problems?

00:27:29.090 --> 00:27:33.470
So the strategy was, we
don't want to fight the HTML.

00:27:33.470 --> 00:27:35.060
HTML's gotten a lot better.

00:27:35.060 --> 00:27:36.770
You've gotten a lot
closer to the DOM.

00:27:36.770 --> 00:27:39.130
We've seen all the cool stuff
that Polymer's been doing.

00:27:39.130 --> 00:27:40.505
You want to get
closer to the DOM

00:27:40.505 --> 00:27:42.850
so that when you're
writing applications,

00:27:42.850 --> 00:27:45.540
you're not writing this big,
vague abstract sense of like,

00:27:45.540 --> 00:27:47.764
I need a thing.

00:27:47.764 --> 00:27:48.680
You want to extend it.

00:27:48.680 --> 00:27:51.210
You want to make the
DOM more powerful.

00:27:51.210 --> 00:27:54.950
So we picked up
AngularDart, which

00:27:54.950 --> 00:27:56.380
is, you guys should
have all heard

00:27:56.380 --> 00:27:58.300
about Angular at
this point in time.

00:27:58.300 --> 00:27:59.920
But Angular has two flavors now.

00:27:59.920 --> 00:28:02.920
They've got a Dart
flavor and a JS flavor.

00:28:02.920 --> 00:28:05.250
We'll talk about Dart
in the last section,

00:28:05.250 --> 00:28:08.610
but I want to talk about
Angular really quick.

00:28:08.610 --> 00:28:11.080
It has a lot of the very
same underlying constructs

00:28:11.080 --> 00:28:14.440
as Polymer, and it
gives you behaviors.

00:28:14.440 --> 00:28:16.990
This idea that you
want very simple things

00:28:16.990 --> 00:28:19.620
that you can then
bind into your model.

00:28:19.620 --> 00:28:22.430
This is really powerful because
it gets you close to the HTML.

00:28:22.430 --> 00:28:23.971
You can write your
page, and then you

00:28:23.971 --> 00:28:25.830
can add little
behaviors to the HTML

00:28:25.830 --> 00:28:27.280
that you've already written.

00:28:27.280 --> 00:28:29.210
This is really useful because
we have like prototypers that

00:28:29.210 --> 00:28:31.355
would go, we'd have a mock that
would be built up, and hey,

00:28:31.355 --> 00:28:32.390
you want to build this?

00:28:32.390 --> 00:28:35.120
And then they come in and
someone would build the HTML,

00:28:35.120 --> 00:28:37.390
and then I'm now
able as an engineer

00:28:37.390 --> 00:28:40.400
to take that and just extend
it and fill in all the missing

00:28:40.400 --> 00:28:42.970
pieces.

00:28:42.970 --> 00:28:45.240
So what does it look
like to have behaviors?

00:28:45.240 --> 00:28:48.667
Angular has some very simple
things, like ng-repeat.

00:28:48.667 --> 00:28:49.500
They're very simple.

00:28:49.500 --> 00:28:50.220
It does one thing.

00:28:50.220 --> 00:28:51.928
It takes a piece of
DOM, and it stamps it

00:28:51.928 --> 00:28:53.570
out over and over again.

00:28:53.570 --> 00:28:56.729
And it lets you have a
model that is discrete.

00:28:56.729 --> 00:28:58.270
Now this is really
useful when you're

00:28:58.270 --> 00:29:00.010
trying to test things, when
you're trying to build business

00:29:00.010 --> 00:29:02.460
logic, and you want to make
sure that your code actually

00:29:02.460 --> 00:29:04.802
does what you expect it to
do without adding timers,

00:29:04.802 --> 00:29:06.760
without adding DOM
manipulation, without adding

00:29:06.760 --> 00:29:09.132
all this extra
fluff to your code.

00:29:09.132 --> 00:29:11.590
All you want to do is want to
say, I have a list of people,

00:29:11.590 --> 00:29:13.410
and I want to add a new person.

00:29:13.410 --> 00:29:16.236
You don't want to say, I want
to keep a mapping of person

00:29:16.236 --> 00:29:18.860
to DOM element, and then when I
add it, I now create a new one.

00:29:18.860 --> 00:29:19.600
And then I append it.

00:29:19.600 --> 00:29:20.580
And did I append it
in the right place?

00:29:20.580 --> 00:29:21.780
Did I not append it
in the right place?

00:29:21.780 --> 00:29:23.730
Now I want to remove this one
so now I have to go to the DOM,

00:29:23.730 --> 00:29:24.730
and I have to remove it.

00:29:24.730 --> 00:29:26.354
You just want to have
a list of people,

00:29:26.354 --> 00:29:27.880
and you want to
say, Add and Remove.

00:29:27.880 --> 00:29:29.900
And Angular let's you do this.

00:29:29.900 --> 00:29:32.870
The other example I
give is ng-if, but only

00:29:32.870 --> 00:29:34.830
because with these
two behaviors,

00:29:34.830 --> 00:29:37.700
you can now compose
things together.

00:29:37.700 --> 00:29:40.320
This is what becomes really,
really powerful is this idea

00:29:40.320 --> 00:29:42.620
that you have these simple
behaviors like gears

00:29:42.620 --> 00:29:45.670
that you can then take
and you can put together.

00:29:45.670 --> 00:29:48.240
And you can compose
repeats with ifs,

00:29:48.240 --> 00:29:51.350
and you can build a
huge, very functional UI

00:29:51.350 --> 00:29:55.530
in a very short amount of
time that's very solid.

00:29:55.530 --> 00:29:57.030
And that's what you
wanted, and this

00:29:57.030 --> 00:29:59.620
is part of the reason
why we picked this,

00:29:59.620 --> 00:30:03.710
this whole idea that you want
simple things that you can then

00:30:03.710 --> 00:30:05.030
compose together.

00:30:05.030 --> 00:30:09.190
A gear is very, very
simple, but a clock is easy.

00:30:09.190 --> 00:30:11.300
Now when you're
building application,

00:30:11.300 --> 00:30:12.967
you need lots and
lots of simple pieces,

00:30:12.967 --> 00:30:14.800
and it's important to
realize the difference

00:30:14.800 --> 00:30:15.910
between simple and easy.

00:30:15.910 --> 00:30:18.620
Simple you can compose together
very easily without effort.

00:30:18.620 --> 00:30:20.900
You can't reduce it any farther.

00:30:20.900 --> 00:30:22.320
With ng-repeat,
for instance, you

00:30:22.320 --> 00:30:26.097
can't take away anything
from the actual behavior.

00:30:26.097 --> 00:30:28.680
If you took it away, it wouldn't
actually be a repeat anymore.

00:30:28.680 --> 00:30:29.880
Same thing with if.

00:30:29.880 --> 00:30:32.250
It's about as simple as
you can possibly make it.

00:30:32.250 --> 00:30:33.810
A clock, on the
other hand, is great.

00:30:33.810 --> 00:30:36.454
It's very self-contained, and
it has a really good usage.

00:30:36.454 --> 00:30:37.870
But it's one of
those things where

00:30:37.870 --> 00:30:39.690
it's the final
state of something.

00:30:39.690 --> 00:30:42.224
You can't take a clock and
compose it with another clock.

00:30:42.224 --> 00:30:44.390
You have to rip it apart
and take all the gears out.

00:30:44.390 --> 00:30:46.090
And then you can
build the dual clock.

00:30:46.090 --> 00:30:48.200
But there's a lot
of work involved

00:30:48.200 --> 00:30:50.500
in ripping it apart and
putting it back together.

00:30:50.500 --> 00:30:52.310
It may be easy
because it tells time,

00:30:52.310 --> 00:30:55.900
and you can wind it and change
it, but it's not simple.

00:30:55.900 --> 00:30:57.810
And it's an important
distinction.

00:30:57.810 --> 00:31:01.820
They're both good, but they
just have different purposes.

00:31:01.820 --> 00:31:05.480
So you guys have seen lots of
Polymer component stuff today,

00:31:05.480 --> 00:31:07.407
and Angular is built
on the same foundation.

00:31:07.407 --> 00:31:09.115
It uses the same
underlying technologies.

00:31:09.115 --> 00:31:10.990
It uses Shadow DOM.

00:31:10.990 --> 00:31:13.437
It uses the web
component spec, and it

00:31:13.437 --> 00:31:15.270
uses all these same
underlying technologies.

00:31:15.270 --> 00:31:17.567
It just does it a
little bit differently.

00:31:17.567 --> 00:31:19.150
Regardless of what
technology you use,

00:31:19.150 --> 00:31:22.310
you want to have a story
for building components

00:31:22.310 --> 00:31:25.780
to isolate things in your
page, especially when you

00:31:25.780 --> 00:31:27.020
start talking about CSS.

00:31:27.020 --> 00:31:31.034
CSS is the last remaining global
variable on your web pages.

00:31:31.034 --> 00:31:33.200
You want to get rid of that
so that you can actually

00:31:33.200 --> 00:31:36.920
have object-oriented programming
and apply it to your web pages

00:31:36.920 --> 00:31:40.072
and not just as this global
thing that styles everything.

00:31:40.072 --> 00:31:41.530
So this is really
useful, and we've

00:31:41.530 --> 00:31:42.654
seen this be really useful.

00:31:42.654 --> 00:31:44.820
This is an example
of what it looks

00:31:44.820 --> 00:31:46.320
like if you opened
up the inspector.

00:31:46.320 --> 00:31:47.850
It's basically a
bunch of elements

00:31:47.850 --> 00:31:50.960
that exist behind
the actual element,

00:31:50.960 --> 00:31:52.430
and it lets you scope things.

00:31:52.430 --> 00:31:54.500
So your style element
doesn't leak outwards.

00:31:54.500 --> 00:31:56.630
It doesn't leak down.

00:31:56.630 --> 00:31:59.230
And it prevents this mess
when you build really

00:31:59.230 --> 00:32:00.060
big applications.

00:32:00.060 --> 00:32:03.530
It's really easy for developers
to write styles that step

00:32:03.530 --> 00:32:04.346
on each other.

00:32:04.346 --> 00:32:06.720
I don't know how many of you
have ever written web pages,

00:32:06.720 --> 00:32:09.210
but have you ever seen
somebody write a paragraph tag

00:32:09.210 --> 00:32:11.570
with a red important tag
and try to figure out

00:32:11.570 --> 00:32:13.317
where that actually came from?

00:32:13.317 --> 00:32:14.900
It's really hard,
and so this actually

00:32:14.900 --> 00:32:20.740
gives you real scoping
that's just much better.

00:32:20.740 --> 00:32:23.800
And that's really powerful.

00:32:23.800 --> 00:32:25.300
TED SANDER: So that's great.

00:32:25.300 --> 00:32:29.430
I mean, we seem to have
a story figured out

00:32:29.430 --> 00:32:32.686
to make it better for developers
to write HTML and be closer

00:32:32.686 --> 00:32:35.310
to what the actual designers are
making and that kind of stuff.

00:32:35.310 --> 00:32:36.710
But how in the
world are we going

00:32:36.710 --> 00:32:39.190
to make sure that
this works for 100

00:32:39.190 --> 00:32:40.814
engineers, a million
lines of code?

00:32:40.814 --> 00:32:42.230
How are we going
to make sure it's

00:32:42.230 --> 00:32:44.474
going to scale every
single time we use it,

00:32:44.474 --> 00:32:45.890
and that five years
down the road,

00:32:45.890 --> 00:32:48.530
we're not deciding
to do something else?

00:32:48.530 --> 00:32:50.620
PAUL ROHDE: Yeah,
that's a good question.

00:32:50.620 --> 00:32:53.820
I mean, like you said, we have
lots and lots of engineers.

00:32:53.820 --> 00:32:56.680
We have huge code bases.

00:32:56.680 --> 00:32:59.060
And we want to be able to
build these huge front ends,

00:32:59.060 --> 00:33:00.940
and we want to
build them quickly.

00:33:00.940 --> 00:33:02.440
And then once we
build them, we want

00:33:02.440 --> 00:33:04.650
to be able to change
them because that's

00:33:04.650 --> 00:33:06.027
how you build business.

00:33:06.027 --> 00:33:06.860
You build something.

00:33:06.860 --> 00:33:07.470
You take it.

00:33:07.470 --> 00:33:08.890
You iterate on it.

00:33:08.890 --> 00:33:14.020
So we picked up on Dart.

00:33:14.020 --> 00:33:17.010
We loved a lot of things
about the language itself.

00:33:17.010 --> 00:33:20.240
But mostly, it was able
to take what we have,

00:33:20.240 --> 00:33:23.620
and we were able to tie it
into one cohesive tool set.

00:33:23.620 --> 00:33:27.350
So instead of having a
mishmash of one thing,

00:33:27.350 --> 00:33:30.350
another thing, two libraries
here, one library here,

00:33:30.350 --> 00:33:33.370
a different language
underneath JavaScript,

00:33:33.370 --> 00:33:34.990
we wanted to build
a stack that we

00:33:34.990 --> 00:33:37.800
could have a very
clean, well-defined way

00:33:37.800 --> 00:33:41.417
to build front ends that worked
for a lot of different people.

00:33:41.417 --> 00:33:43.000
And we wanted to
have a cohesive story

00:33:43.000 --> 00:33:44.900
of how you can build
a front end quickly

00:33:44.900 --> 00:33:47.970
and how you can continue to
scale that from one or two

00:33:47.970 --> 00:33:51.410
engineers all the way
up to 100 to 200 to 300.

00:33:51.410 --> 00:33:54.140
So we wanted these tools, and
we wanted to be able to do this.

00:33:54.140 --> 00:33:56.640
And we picked up on Dart, and
I'll explain in just a second.

00:33:56.640 --> 00:33:59.520
So like I said, Dart has a lot
of different things about it.

00:33:59.520 --> 00:34:00.592
It's batteries included.

00:34:00.592 --> 00:34:02.550
It has all the different
pieces that we needed,

00:34:02.550 --> 00:34:04.860
and I'll show you why.

00:34:04.860 --> 00:34:08.846
The first thing that we wanted
is we wanted it to be fast.

00:34:08.846 --> 00:34:10.679
And this is a big huge
selling point for us.

00:34:10.679 --> 00:34:14.389
We wanted our front ends to
run just as fast as JavaScript.

00:34:14.389 --> 00:34:16.679
Because if it wasn't
going to be fast enough,

00:34:16.679 --> 00:34:18.489
why not just do
JavaScript, right?

00:34:18.489 --> 00:34:20.860
Because we have to run
it in JavaScript anyways.

00:34:20.860 --> 00:34:25.760
So even Dart it compiles a JS,
and it runs just as fast as JS.

00:34:25.760 --> 00:34:28.404
It's fast, and it also has
a bunch of other things

00:34:28.404 --> 00:34:29.570
that we liked about it, too.

00:34:36.409 --> 00:34:40.070
So Dart is fast, and my slides
will eventually keep up.

00:34:40.070 --> 00:34:42.210
Yes, there we go.

00:34:42.210 --> 00:34:44.150
In a lot of benchmarks,
specifically, you

00:34:44.150 --> 00:34:46.566
can go on the Dart web page,
and you can go look these up.

00:34:46.566 --> 00:34:49.290
There's a bunch of benchmarks,
and what we really cared about

00:34:49.290 --> 00:34:52.900
was Dart to JS because
even though Chrome

00:34:52.900 --> 00:34:55.090
may be coming along and
iterating really fast,

00:34:55.090 --> 00:34:56.980
we still knew that we
had to run a JavaScript

00:34:56.980 --> 00:34:58.452
at least for a good
amount of time.

00:34:58.452 --> 00:35:00.160
And a lot of browsers
were not ever going

00:35:00.160 --> 00:35:03.020
to adopt any sort of engine
other than JavaScript.

00:35:03.020 --> 00:35:05.080
So that was a core
requirement was

00:35:05.080 --> 00:35:07.260
that it had to be just
as fast as JavaScript.

00:35:07.260 --> 00:35:08.034
And it is.

00:35:08.034 --> 00:35:09.950
And it gives us a lot
of other things as well,

00:35:09.950 --> 00:35:11.860
beyond just JavaScript.

00:35:11.860 --> 00:35:14.850
The biggest one is types.

00:35:14.850 --> 00:35:17.510
I don't know how many of
you tried to grip a file

00:35:17.510 --> 00:35:19.730
to replace a string
in JavaScript,

00:35:19.730 --> 00:35:22.955
but you have no idea if
it actually worked or not.

00:35:22.955 --> 00:35:24.580
We wanted to be able
to do refactoring.

00:35:24.580 --> 00:35:27.990
We have large teams of
people, and you want your code

00:35:27.990 --> 00:35:31.040
to be readable, but you also
want it to be refactorable.

00:35:31.040 --> 00:35:32.720
You want to be able
to take a class,

00:35:32.720 --> 00:35:36.832
remove it, change it, modify
it, rename things, and know

00:35:36.832 --> 00:35:38.290
that when you change
it, it's going

00:35:38.290 --> 00:35:41.160
to change in all the places
you actually care about.

00:35:41.160 --> 00:35:43.060
If you don't, then you
end up in this soup

00:35:43.060 --> 00:35:46.120
of trying to figure out
exactly why this method exists

00:35:46.120 --> 00:35:48.310
sometimes and not other times.

00:35:48.310 --> 00:35:49.356
And we didn't want that.

00:35:49.356 --> 00:35:50.480
And so Dart gives us types.

00:35:50.480 --> 00:35:53.350
It also makes it so it can
optimize the JS faster.

00:35:53.350 --> 00:35:55.880
And we can do that some with
closure in JavaScript, too,

00:35:55.880 --> 00:35:59.830
but just having built-in
support was really nice.

00:35:59.830 --> 00:36:02.630
As an example, not only
does it give you types,

00:36:02.630 --> 00:36:04.150
but it's still dynamic.

00:36:04.150 --> 00:36:06.970
It still lets you do all
those JavaScript-y things.

00:36:06.970 --> 00:36:09.410
As an example here,
this is the same method

00:36:09.410 --> 00:36:11.480
with types and without types.

00:36:11.480 --> 00:36:12.980
So you still get
all the flexibility

00:36:12.980 --> 00:36:16.110
that you have with
JavaScript, but by default you

00:36:16.110 --> 00:36:17.700
want to put in
types, but you don't

00:36:17.700 --> 00:36:19.134
have to if you don't need to.

00:36:19.134 --> 00:36:21.300
Or if you have a case where
you really don't want to

00:36:21.300 --> 00:36:24.154
and you want to jump into
more Javascript-y type things.

00:36:24.154 --> 00:36:25.570
And this is really
important as we

00:36:25.570 --> 00:36:27.487
build web front ends
because a lot of times

00:36:27.487 --> 00:36:29.820
you run into these cases where
you want to build things,

00:36:29.820 --> 00:36:32.940
either statically
and dynamically.

00:36:32.940 --> 00:36:37.300
So gave this to us.

00:36:37.300 --> 00:36:41.530
Next, Dart gave us
a package manager.

00:36:41.530 --> 00:36:43.370
It's really hard to
manage dependencies

00:36:43.370 --> 00:36:46.160
if you don't have a good
system for managing it.

00:36:46.160 --> 00:36:47.960
Now you might have
a good system,

00:36:47.960 --> 00:36:50.130
but if you don't have a
consistent system that's

00:36:50.130 --> 00:36:52.550
shared between a whole
bunch of different things,

00:36:52.550 --> 00:36:55.350
that's really hard to deal with.

00:36:55.350 --> 00:36:56.480
Do you pick require JS?

00:36:56.480 --> 00:36:59.075
Do you pick a whole bunch of
different package managers?

00:36:59.075 --> 00:37:00.270
Do you use node?

00:37:00.270 --> 00:37:04.440
What do you use to
manage code dependencies?

00:37:04.440 --> 00:37:07.550
So Dart, again with this whole
theme of there's batteries

00:37:07.550 --> 00:37:10.340
included, it gives
you a package manager

00:37:10.340 --> 00:37:13.432
that can let you manage all
the dependencies of your code.

00:37:13.432 --> 00:37:14.890
And this is really,
really powerful

00:37:14.890 --> 00:37:16.690
because then you don't have
to fight over which package

00:37:16.690 --> 00:37:18.050
manager you're actually using.

00:37:18.050 --> 00:37:19.270
And if you use a
different library that

00:37:19.270 --> 00:37:20.728
happens to use
something different,

00:37:20.728 --> 00:37:24.080
you're not restricted
because of that.

00:37:24.080 --> 00:37:27.890
So that was really
important for us.

00:37:27.890 --> 00:37:31.316
I have an example up here if
what it actually looks like.

00:37:31.316 --> 00:37:33.690
The pubspec.yaml was basically
just a configuration file.

00:37:33.690 --> 00:37:35.852
You don't have to pay
too much attention to it.

00:37:35.852 --> 00:37:37.560
But it lets you specify
the dependencies.

00:37:37.560 --> 00:37:39.350
It's all pulled through pub.

00:37:39.350 --> 00:37:41.100
It's got a central ecosystem.

00:37:41.100 --> 00:37:43.720
And you can get new
ones, either pub get,

00:37:43.720 --> 00:37:46.420
and pub upgrade lets you
upgrade existing dependencies

00:37:46.420 --> 00:37:47.744
and things like that.

00:37:47.744 --> 00:37:49.910
But it's just a simple
dependency management system,

00:37:49.910 --> 00:37:51.618
but it's baked into
the language and it's

00:37:51.618 --> 00:37:53.720
part of the whole ecosystem
that comes with it.

00:37:53.720 --> 00:37:56.270
We picked Dart not just
because of the language,

00:37:56.270 --> 00:37:59.670
but because of the ecosystem.

00:37:59.670 --> 00:38:02.450
So that's about all we
got for you guys today.

00:38:02.450 --> 00:38:04.990
Hopefully, that was at
least useful to at least see

00:38:04.990 --> 00:38:07.026
some of what we do
at Google and see

00:38:07.026 --> 00:38:08.650
what it's like for
engineers to come up

00:38:08.650 --> 00:38:10.790
and actually speak and
share a little bit of what

00:38:10.790 --> 00:38:12.866
we do every day.

00:38:12.866 --> 00:38:13.490
I'm Paul Rohde.

00:38:13.490 --> 00:38:15.070
This is Ted Sanders.

00:38:15.070 --> 00:38:17.380
We'll be around a little
bit to answer questions

00:38:17.380 --> 00:38:18.490
if you want to come
up to the stage,

00:38:18.490 --> 00:38:19.350
and we'll talk to you later.

00:38:19.350 --> 00:38:20.808
But that's all we
got for you guys.

00:38:20.808 --> 00:38:22.230
Thank you.

