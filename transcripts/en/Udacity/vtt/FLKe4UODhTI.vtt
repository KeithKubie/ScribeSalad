WEBVTT
Kind: captions
Language: en

00:00:00.420 --> 00:00:04.420
Another participant in the development of design principles is Arthur Riel,

00:00:04.420 --> 00:00:08.770
whose book is titled Design Heuristics, referenced on the class resources page.

00:00:08.770 --> 00:00:11.650
Here are some examples of Riel's heuristics.

00:00:11.650 --> 00:00:14.180
You will notice the overlap with some of the principles,

00:00:14.180 --> 00:00:15.770
principles that we have already talked about.

00:00:15.770 --> 00:00:18.490
These particular heuristics don't have

00:00:18.490 --> 00:00:24.120
names that are catchy like the but they do exhibit.

00:00:24.120 --> 00:00:28.390
Advice to you about situations that you want to avoid or

00:00:29.390 --> 00:00:32.159
ways of structuring your code that you want to try to promote.

00:00:32.159 --> 00:00:36.120
First one is, most of the methods defined on a class should be using most of

00:00:36.120 --> 00:00:39.330
the data members of the class most of the time.

00:00:39.330 --> 00:00:42.385
Otherwise there's an opportunity to split the class into pieces that indi-,

00:00:42.385 --> 00:00:44.190
individually obey this principle.

00:00:44.190 --> 00:00:48.010
Another Riel Heuristic, check constraints in constructors,

00:00:48.010 --> 00:00:50.470
rather than in method preconditions where possible.

00:00:50.470 --> 00:00:53.260
Following this principle will reduce the overall amount of checking that

00:00:53.260 --> 00:00:55.660
needs to be done by the class.

00:00:55.660 --> 00:01:00.120
Another Heuristic, factor the commonality of data, behavior, and interfaces as

00:01:00.120 --> 00:01:04.819
high as possible in the inheritance hierarchy, thereby facilitating reuse.

00:01:04.819 --> 00:01:07.680
This of course is standard O-O dogma.

00:01:07.680 --> 00:01:09.480
Here's another Riel heuristic.

00:01:09.480 --> 00:01:13.140
Inheritance should be used only to model a generalization hierarchy,

00:01:13.140 --> 00:01:16.820
hierarchy and not to facilitate the sharing of implementation code.

00:01:16.820 --> 00:01:19.980
We've heard this one many times in this course.

00:01:19.980 --> 00:01:23.680
Another prefer composition which we can also think of

00:01:23.680 --> 00:01:25.630
as aggregation or delegation.

00:01:25.630 --> 00:01:26.900
Over inheritance.

00:01:26.900 --> 00:01:29.990
Particularly with respect to implementation inheritance.

00:01:29.990 --> 00:01:30.750
Another.

00:01:30.750 --> 00:01:31.920
It should be illegal for

00:01:31.920 --> 00:01:36.700
a derived class to override a base class method with a no-op method.

00:01:36.700 --> 00:01:39.760
That is, essentially, a method that does nothing instead of

00:01:39.760 --> 00:01:42.320
the behavior that the base class prescribes.

00:01:42.320 --> 00:01:43.770
Doing so, by the way,

00:01:43.770 --> 00:01:46.870
would violate the substitution principle that we saw earlier.

00:01:46.870 --> 00:01:49.610
Riel also suggests that we not change the state of

00:01:49.610 --> 00:01:52.490
an object without going through its public interface.

00:01:52.490 --> 00:01:55.070
Doing so would violate information hiding.

00:01:55.070 --> 00:02:00.640
If we, kind of extend this idea to deal with, subclassing, and

00:02:00.640 --> 00:02:04.200
we strictly obeyed it, this heuristic, it would mean that a method in

00:02:04.200 --> 00:02:08.360
a class cannot change an instance variable without calling the setter.

00:02:09.470 --> 00:02:11.440
Method in that class.

00:02:11.440 --> 00:02:13.760
That is, you couldn't make a direct assignment to an attribute.

00:02:13.760 --> 00:02:15.640
You'd have to call the setter which did it.

00:02:15.640 --> 00:02:17.240
And another Riel principle,

00:02:17.240 --> 00:02:20.380
users of a class must be dependent on it's public interface.

00:02:20.380 --> 00:02:22.940
But a class should not be dependent on it's users.

00:02:22.940 --> 00:02:25.810
Finally here are two Riel heuristics indicating how you

00:02:25.810 --> 00:02:29.870
should distribute key design knowledge among the components of a system.

00:02:29.870 --> 00:02:34.220
Distribute system intelligence horizontally as uniformly as possible.

00:02:34.220 --> 00:02:37.630
That is, don't artificially concentrate knowledge in one place.

00:02:37.630 --> 00:02:42.020
This heuristic is sometimes expressed as, do not create God classes, or

00:02:42.020 --> 00:02:43.870
God objects in your system.

00:02:43.870 --> 00:02:48.140
A corollary heuristic is to distribute system intelligence vertically down

00:02:48.140 --> 00:02:50.650
narrow and deep containment hierarchies.

00:02:50.650 --> 00:02:53.180
You're, I encourage you to have a look at Riel's book,

00:02:53.180 --> 00:02:55.140
where there's many more such pieces of advice.

