WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:03.290
[MUSIC PLAYING]

00:00:06.110 --> 00:00:07.850
HANS BOEHM: Hello, welcome.

00:00:07.850 --> 00:00:09.040
I'm Hans Boehm.

00:00:09.040 --> 00:00:12.130
I'm a software engineer in
the Android Runtime Group,

00:00:12.130 --> 00:00:15.020
and I'm here to talk to you
about how to manage native C++

00:00:15.020 --> 00:00:16.150
from memory and Android.

00:00:21.000 --> 00:00:23.160
Generally, most
Android applications

00:00:23.160 --> 00:00:27.730
are written in Java today,
maybe Kotlin in the future.

00:00:27.730 --> 00:00:30.030
But there are sometimes
reasons to also write pieces

00:00:30.030 --> 00:00:34.320
of the application
in C or C++ code.

00:00:34.320 --> 00:00:37.680
It may be the case that you can
implement some algorithm more

00:00:37.680 --> 00:00:42.190
efficiently in a
language like C++.

00:00:42.190 --> 00:00:46.260
Or you may have a native library
that already exists that you

00:00:46.260 --> 00:00:49.020
wanted to use or the like.

00:00:49.020 --> 00:00:51.720
Here, we're really talking about
multi-language applications

00:00:51.720 --> 00:00:54.070
that combines Java and C++.

00:00:57.770 --> 00:01:00.320
It turns out that even if you're
in the business of writing

00:01:00.320 --> 00:01:03.740
100% Java apps, as
you may be, some

00:01:03.740 --> 00:01:06.710
of what I'm going to
talk about may still

00:01:06.710 --> 00:01:10.650
be an issue in certain
isolated cases.

00:01:10.650 --> 00:01:14.480
For example, if you look
at the Android platform

00:01:14.480 --> 00:01:17.510
implementation, the Big
Integer implementation

00:01:17.510 --> 00:01:21.440
that you are using-- if you're
using Big Integer at all,

00:01:21.440 --> 00:01:25.490
is actually implemented in
terms of native code underneath.

00:01:25.490 --> 00:01:27.980
And in other cases,
that sort of thing

00:01:27.980 --> 00:01:29.691
may actually show through.

00:01:29.691 --> 00:01:31.940
So that was one of the reasons
I got involved in this.

00:01:31.940 --> 00:01:33.650
I actually spent
some time working

00:01:33.650 --> 00:01:35.150
on the Android
calculator app which

00:01:35.150 --> 00:01:37.230
happens to be a major
kind of Big Integer.

00:01:41.050 --> 00:01:44.820
Here we're going to
use a running example

00:01:44.820 --> 00:01:48.490
of a hypothetical C++ package
that we want to access from

00:01:48.490 --> 00:01:51.980
Java language code that
manipulates polynomials over

00:01:51.980 --> 00:01:52.600
GF2.

00:01:52.600 --> 00:01:55.070
Does anybody know
what that means?

00:01:55.070 --> 00:01:55.570
Good.

00:01:55.570 --> 00:01:56.528
You're not supposed to.

00:01:56.528 --> 00:01:58.395
It doesn't matter.

00:01:58.395 --> 00:01:59.770
As far as we are
concerned, these

00:01:59.770 --> 00:02:01.930
are basically bit vectors
with an odd notion

00:02:01.930 --> 00:02:02.776
of multiplication.

00:02:02.776 --> 00:02:04.150
But I don't even
care about that.

00:02:04.150 --> 00:02:08.460
I'm not going to show you
the C++ code actually.

00:02:08.460 --> 00:02:11.350
This particular example is
good because it turns out

00:02:11.350 --> 00:02:13.510
that in spite of the fact
that it seems esoteric,

00:02:13.510 --> 00:02:16.630
modern hardware often has
hardware support for this.

00:02:16.630 --> 00:02:19.930
So you can actually build a
blazingly fast really low level

00:02:19.930 --> 00:02:21.230
implementation.

00:02:21.230 --> 00:02:23.410
So what we want to do
is we have this library,

00:02:23.410 --> 00:02:26.430
and we want to call that
library from Java code.

00:02:30.290 --> 00:02:33.680
So what this looks
like roughly--

00:02:33.680 --> 00:02:39.170
is the following is the
code that you see up here.

00:02:39.170 --> 00:02:44.300
So the important part here
is we have a Java class,

00:02:44.300 --> 00:02:48.680
which logically owns a C++
object that actually contains

00:02:48.680 --> 00:02:51.530
the guts of the implementation,
that actually implements

00:02:51.530 --> 00:02:56.090
the real functionality, which
I'm not going to show you.

00:02:56.090 --> 00:02:59.810
What the Java object
holds is Java long,

00:02:59.810 --> 00:03:02.300
which is really a C++
pointer in disguise.

00:03:05.060 --> 00:03:06.747
What it's going to
do is for example,

00:03:06.747 --> 00:03:08.330
when you want to
multiply two of these

00:03:08.330 --> 00:03:12.080
is it's eventually going to call
this native multiply function.

00:03:12.080 --> 00:03:15.530
It's going to pass
it to Java longs.

00:03:15.530 --> 00:03:17.750
This is going to go
into some JNI code,

00:03:17.750 --> 00:03:21.350
which will cast those Java
longs, the C++ pointers,

00:03:21.350 --> 00:03:23.990
and manipulate the C++ objects.

00:03:23.990 --> 00:03:26.870
And in this particular case,
we turned another Java long,

00:03:26.870 --> 00:03:30.230
which is really a C++ pointer.

00:03:30.230 --> 00:03:35.630
So the Java level multiplication
routine is really one that just

00:03:35.630 --> 00:03:42.060
gives me back a new binary poly
object containing this Java

00:03:42.060 --> 00:03:45.440
long, which really
points to C++ code,

00:03:45.440 --> 00:03:52.787
which I obtained the underlying
C++ pointer by calling this

00:03:52.787 --> 00:03:53.870
native multiplier routine.

00:03:56.490 --> 00:03:58.550
So here is a
pictorial presentation

00:03:58.550 --> 00:03:59.990
of what this looks like.

00:03:59.990 --> 00:04:02.360
I have the Java
object at the top

00:04:02.360 --> 00:04:05.570
of the slide, which
is the only thing

00:04:05.570 --> 00:04:08.030
that my client actually sees.

00:04:08.030 --> 00:04:12.050
So I want the client to be
able to treat this Java object

00:04:12.050 --> 00:04:14.480
as though it were implemented
completely in Java,

00:04:14.480 --> 00:04:17.779
and ignore the fact that
there's C++ code underneath.

00:04:17.779 --> 00:04:20.660
The dot dash line
here is the Java long,

00:04:20.660 --> 00:04:25.190
which is really a C++ pointer,
which sort of points to the C++

00:04:25.190 --> 00:04:28.100
object representation, though
Java doesn't know that.

00:04:28.100 --> 00:04:31.010
And inside the C++ object
representation there may be

00:04:31.010 --> 00:04:33.740
additional pointers that
point to additional C++ data

00:04:33.740 --> 00:04:36.960
structures.

00:04:36.960 --> 00:04:40.440
So what's the problem
with doing this?

00:04:40.440 --> 00:04:42.420
The problem comes
into play when we

00:04:42.420 --> 00:04:46.680
try to think about how
memory gets managed

00:04:46.680 --> 00:04:49.310
and how objects get allocated.

00:04:49.310 --> 00:04:52.500
On the Java language side
we have a garbage collector

00:04:52.500 --> 00:04:54.344
that cleans up after
us, and we generally

00:04:54.344 --> 00:04:56.010
don't have to worry
about this too much.

00:04:56.010 --> 00:04:58.135
When things are no longer
referenced, they go away.

00:04:58.135 --> 00:05:01.820
When they become
unreachable they go away.

00:05:01.820 --> 00:05:05.490
On the C++ side we have a manual
memory management discipline

00:05:05.490 --> 00:05:09.150
usually, which means we
explicitly need to call some

00:05:09.150 --> 00:05:12.510
delete function, some deleter in
order to deallocate the memory

00:05:12.510 --> 00:05:15.540
when it's no longer reachable.

00:05:15.540 --> 00:05:16.980
So how do we actually do that?

00:05:16.980 --> 00:05:19.740
We have to arrange for somebody
to call the delete function

00:05:19.740 --> 00:05:20.895
on the C++ object.

00:05:23.530 --> 00:05:25.660
So here's the traditional
way to do this.

00:05:25.660 --> 00:05:27.960
And the point of
this talk is largely

00:05:27.960 --> 00:05:31.410
to talk you out of
doing it this way.

00:05:31.410 --> 00:05:34.470
So the traditional
way of doing this,

00:05:34.470 --> 00:05:36.360
which has the
attraction admittedly

00:05:36.360 --> 00:05:38.970
that it's relatively simple to
write the code compared to what

00:05:38.970 --> 00:05:41.940
I'm going to show you,
is that in addition

00:05:41.940 --> 00:05:43.950
to things like the
native multiply method,

00:05:43.950 --> 00:05:46.770
I'll have a native delete
method to which I also

00:05:46.770 --> 00:05:49.010
pass a Java long.

00:05:49.010 --> 00:05:51.720
And then the native delete
method will again convert that

00:05:51.720 --> 00:05:54.510
to the C++ pointer and
invoke delete on it or invoke

00:05:54.510 --> 00:05:55.860
the appropriate deleter on it.

00:05:59.550 --> 00:06:04.670
I will call that native delete
lead from a Java finalizer.

00:06:04.670 --> 00:06:07.380
The finalizer is
invoked more or less

00:06:07.380 --> 00:06:09.700
when the object
becomes unreachable.

00:06:09.700 --> 00:06:12.070
So that then goes ahead and
invokes the end of delete,

00:06:12.070 --> 00:06:15.330
and allocates the
C++ object as well.

00:06:15.330 --> 00:06:18.210
I'll show you some reasons
why this is problematic here.

00:06:21.600 --> 00:06:26.000
So I'll go through a long
list of finalizer problems.

00:06:26.000 --> 00:06:29.700
Finalizers have a deserved
reputation for being hazardous.

00:06:29.700 --> 00:06:31.650
And I'll only confirm that here.

00:06:31.650 --> 00:06:34.710
But I'll actually emphasize
some relatively lesser

00:06:34.710 --> 00:06:36.270
known problems,
which in my opinion,

00:06:36.270 --> 00:06:38.260
are actually the most
serious ones to try

00:06:38.260 --> 00:06:40.080
to get to come to grips with.

00:06:40.080 --> 00:06:43.810
And then I'll show you
how to work around those.

00:06:43.810 --> 00:06:49.200
So the first problem is that if
two objects become unreachable,

00:06:49.200 --> 00:06:52.860
the finalizers actually
run in arbitrary order.

00:06:52.860 --> 00:06:55.440
That includes the case
in which two objects that

00:06:55.440 --> 00:06:59.130
points to each other become
unreachable at the same time,

00:06:59.130 --> 00:07:02.060
they can be finalized
in the wrong order.

00:07:02.060 --> 00:07:06.780
Meaning that the second one
to be finalized actually

00:07:06.780 --> 00:07:09.960
tries to access an object
that's already been finalized.

00:07:09.960 --> 00:07:12.916
I'll go into some
more details there.

00:07:12.916 --> 00:07:15.540
So as a result of that what can
happen is that you can then get

00:07:15.540 --> 00:07:20.890
dangling pointers and CD
allocated C++ objects.

00:07:20.890 --> 00:07:24.870
The thing you keep in mind here
is that as a result of dangling

00:07:24.870 --> 00:07:28.830
pointers in this environment
is that you very often end up

00:07:28.830 --> 00:07:32.070
corrupting the C++ heap.

00:07:32.070 --> 00:07:37.300
But worse than that, the Java
language runtime actually

00:07:37.300 --> 00:07:40.360
relies on that C++ heap as well.

00:07:40.360 --> 00:07:43.200
So when this happens,
often what you end up with

00:07:43.200 --> 00:07:46.320
is also a corrupted
Java run time.

00:07:46.320 --> 00:07:49.110
And you may end up seeing caches
that actually look like Java

00:07:49.110 --> 00:07:50.880
garbage caches, or the like.

00:07:55.390 --> 00:08:00.300
So here's to illustrate
how this can go wrong,

00:08:00.300 --> 00:08:02.670
here's a sample client
application that

00:08:02.670 --> 00:08:05.520
actually uses the binary
poly class that we just

00:08:05.520 --> 00:08:07.450
talked about.

00:08:07.450 --> 00:08:10.860
And this, in combination
with the previous class,

00:08:10.860 --> 00:08:11.970
will definitely break.

00:08:11.970 --> 00:08:14.610
So definitely do not do this.

00:08:14.610 --> 00:08:17.630
So what this is doing
in its finalized method,

00:08:17.630 --> 00:08:19.770
it just doing
something innocuous

00:08:19.770 --> 00:08:23.910
on my binary poly, which is
this field that happens to hold

00:08:23.910 --> 00:08:25.860
a pointer to the binary poly.

00:08:25.860 --> 00:08:28.830
Now the problem here is
that it's entirely possible

00:08:28.830 --> 00:08:35.190
that my binary poly object
actually gets finalized first.

00:08:35.190 --> 00:08:39.270
So what you are accessing
here is an mMyBinary poly,

00:08:39.270 --> 00:08:42.190
which actually has
already been finalized.

00:08:42.190 --> 00:08:45.180
So by the time you
access it at the pointer,

00:08:45.180 --> 00:08:49.170
the C++ object underlying it
will have been deallocated.

00:08:49.170 --> 00:08:51.630
And the native pointer
that you're using actually

00:08:51.630 --> 00:08:54.270
points to nowhere.

00:08:54.270 --> 00:08:57.760
So that's a bad thing.

00:08:57.760 --> 00:08:59.880
There's a second
problem with finalizers,

00:08:59.880 --> 00:09:01.890
which is actually
turns out to be more

00:09:01.890 --> 00:09:04.050
complicated to work around.

00:09:04.050 --> 00:09:07.800
And it's less
important on Android,

00:09:07.800 --> 00:09:09.570
but it's generally
important when

00:09:09.570 --> 00:09:12.390
writing Java language code.

00:09:12.390 --> 00:09:14.370
So by Java language rules--

00:09:14.370 --> 00:09:16.470
and this is not currently
true on Android,

00:09:16.470 --> 00:09:19.470
not currently believed
to be true on Android--

00:09:19.470 --> 00:09:21.810
object x's finalizer
may actually

00:09:21.810 --> 00:09:25.680
be invoked while one of x's
methods is still running.

00:09:25.680 --> 00:09:28.750
So while I'm still running
a method on that object,

00:09:28.750 --> 00:09:31.860
that object may end
up getting finalized.

00:09:31.860 --> 00:09:34.230
This can result in the
same sort of phenomena.

00:09:34.230 --> 00:09:36.630
I get native heap
corruption, and as a result,

00:09:36.630 --> 00:09:39.540
possibly Java
runtime corruption.

00:09:39.540 --> 00:09:43.180
Let me explain why that happens.

00:09:43.180 --> 00:09:46.320
So here's again, an excerpt
from the binary poly class.

00:09:49.770 --> 00:09:51.077
I use multiply before.

00:09:51.077 --> 00:09:52.035
I'll use it again here.

00:09:52.035 --> 00:09:54.060
So I have this native
multiply method

00:09:54.060 --> 00:09:57.150
that gets called by multiply.

00:09:57.150 --> 00:09:59.910
If you look at what this
actually gets compiled to--

00:09:59.910 --> 00:10:00.780
and this isn't real.

00:10:00.780 --> 00:10:04.305
This is sort of pseudo code.

00:10:04.305 --> 00:10:11.310
The pseudo code it gets compiled
to look something like this.

00:10:11.310 --> 00:10:15.670
So what happens when I want
to multiply two values,

00:10:15.670 --> 00:10:19.590
I first end up retrieving
the native handles

00:10:19.590 --> 00:10:20.760
from both of them.

00:10:20.760 --> 00:10:21.960
In this case, from this.

00:10:21.960 --> 00:10:25.750
And I may put this in here
explicitly to make that clear.

00:10:25.750 --> 00:10:27.750
So I retrieve a native
handle from this.

00:10:27.750 --> 00:10:30.540
And I retrieve a native
handle from other.

00:10:30.540 --> 00:10:34.950
Then I might allocate the
new binary poly object.

00:10:34.950 --> 00:10:39.340
And then I will go ahead
and call the native method.

00:10:39.340 --> 00:10:41.550
So the problem
with this is if we

00:10:41.550 --> 00:10:45.600
look at the uses of
the actual Java object,

00:10:45.600 --> 00:10:48.570
the last use of this
and other actually

00:10:48.570 --> 00:10:51.650
happened before I allocate
the new binary poly.

00:10:55.230 --> 00:10:57.420
And from that point
on, this method

00:10:57.420 --> 00:11:00.450
doesn't use either
this or other anymore.

00:11:00.450 --> 00:11:02.530
And it may so happen
that this is, in fact,

00:11:02.530 --> 00:11:04.410
the last call on those.

00:11:04.410 --> 00:11:07.324
So this is in fact, the point
at which those become garbage.

00:11:07.324 --> 00:11:09.240
And the garbage collector
notices that they're

00:11:09.240 --> 00:11:10.990
no longer reachable.

00:11:10.990 --> 00:11:16.530
So what can happen at
that point if the ABI's

00:11:16.530 --> 00:11:18.850
are designed to allow this?

00:11:18.850 --> 00:11:21.990
And if all the stars
line up just right?

00:11:21.990 --> 00:11:25.240
It can in fact happen that the
garbage collector at that point

00:11:25.240 --> 00:11:30.000
decides that this and
other are no longer needed,

00:11:30.000 --> 00:11:35.830
and again, for the finalizers
on both of those to get invoked.

00:11:35.830 --> 00:11:39.450
Roughly where the new
binary poly happens or goes.

00:11:39.450 --> 00:11:42.804
What then happens is that
when we call native multiply,

00:11:42.804 --> 00:11:44.220
we don't need the
objects anymore,

00:11:44.220 --> 00:11:46.320
but we still need
the native handles.

00:11:46.320 --> 00:11:49.200
But now the native handles
have been deallocated.

00:11:49.200 --> 00:11:51.630
So in fact, I'm
accessing objects

00:11:51.630 --> 00:11:54.090
that are no longer around.

00:11:54.090 --> 00:11:57.300
This is allowed by the Java
language specification,

00:11:57.300 --> 00:12:01.440
and is something that has been
seen on occasion in the wild,

00:12:01.440 --> 00:12:02.940
but it doesn't
happen very often.

00:12:06.660 --> 00:12:09.670
There are more problems
with finalizers.

00:12:09.670 --> 00:12:11.350
You can see a lot
of them by looking

00:12:11.350 --> 00:12:14.680
at Joshua Bloch's
"Effective Java" book, which

00:12:14.680 --> 00:12:17.290
actually has a section on
it, entitled I believe,

00:12:17.290 --> 00:12:18.310
Avoid Finalizers.

00:12:21.420 --> 00:12:23.530
One thing to
indicate the problems

00:12:23.530 --> 00:12:28.690
is that the plan is I
believe, to deprecate

00:12:28.690 --> 00:12:32.110
to finalize in JDK 9.

00:12:32.110 --> 00:12:34.510
Another issue, which I'll
look out occasionally

00:12:34.510 --> 00:12:39.790
here a little bit is that
for this to work correctly,

00:12:39.790 --> 00:12:42.820
if you run an application
that allocates lots

00:12:42.820 --> 00:12:46.240
of native memory and
relatively little Java memory,

00:12:46.240 --> 00:12:49.630
it may actually not be the case
that the garbage collector runs

00:12:49.630 --> 00:12:52.430
promptly enough to
actually invoke finalizers.

00:12:52.430 --> 00:12:55.910
So the other mechanism I'll
suggest in a minute here.

00:12:55.910 --> 00:12:57.580
So you actually
may have to invoke

00:12:57.580 --> 00:12:59.830
these system dot GC
and system dot run

00:12:59.830 --> 00:13:02.800
finalization occasionally,
which is tricky to do,

00:13:02.800 --> 00:13:05.230
because if you do it too much,
it will greatly slow down

00:13:05.230 --> 00:13:06.490
your application.

00:13:06.490 --> 00:13:09.520
And many people have
fallen into that trap.

00:13:09.520 --> 00:13:11.710
There's a more subtle
issue that they sometimes

00:13:11.710 --> 00:13:15.430
finalizers actually extend the
lifetime of the Java object

00:13:15.430 --> 00:13:17.890
for another garbage
collection cycle, which

00:13:17.890 --> 00:13:19.760
means for generational
garbage collected,

00:13:19.760 --> 00:13:21.990
they may actually
cause it to survive

00:13:21.990 --> 00:13:25.060
and through the old
generation, the lifetime

00:13:25.060 --> 00:13:26.920
may be greatly
extended as a result

00:13:26.920 --> 00:13:29.500
of just having a finalizer.

00:13:29.500 --> 00:13:34.240
And there are other issues
which I won't go into here.

00:13:34.240 --> 00:13:36.480
So how do you really
delete C++ objects?

00:13:41.750 --> 00:13:44.120
I should point out that
usual advice here, which

00:13:44.120 --> 00:13:48.530
I'll skim over briefly
is to use explicit close

00:13:48.530 --> 00:13:49.820
and tie with resources.

00:13:49.820 --> 00:13:54.950
So Java has a syntactic facility
which allows essentially C++

00:13:54.950 --> 00:13:56.420
style distraction.

00:13:56.420 --> 00:14:00.380
When you leave a scope, you
can arrange to explicitly call

00:14:00.380 --> 00:14:02.120
the close function.

00:14:02.120 --> 00:14:05.450
And that works when
it's applicable.

00:14:05.450 --> 00:14:09.110
So there are cases like file
like object, system allocated

00:14:09.110 --> 00:14:12.480
objects, and so on where that's
generally the right approach.

00:14:12.480 --> 00:14:14.780
And that's the main
recommendation.

00:14:14.780 --> 00:14:17.240
On the other hand, there are
many cases in my experience

00:14:17.240 --> 00:14:19.430
where that doesn't work.

00:14:19.430 --> 00:14:21.480
And in general, people
already use this when

00:14:21.480 --> 00:14:25.010
in those cases where
it's applicable.

00:14:25.010 --> 00:14:29.040
So for example, if
I mentioned the java

00:14:29.040 --> 00:14:31.899
lang Big Integer in the
example in the platform.

00:14:31.899 --> 00:14:33.440
You really don't
want to have to call

00:14:33.440 --> 00:14:36.950
Big Integer dot close every time
one of those goes out of scope.

00:14:36.950 --> 00:14:38.570
That would be
completely untenable.

00:14:38.570 --> 00:14:40.621
And there are many
more examples like that

00:14:40.621 --> 00:14:41.620
in the Android platform.

00:14:45.490 --> 00:14:47.890
I should warn you
that for the solutions

00:14:47.890 --> 00:14:49.630
I'm talking about
here, a lot of this

00:14:49.630 --> 00:14:51.250
is actually not fully settled.

00:14:51.250 --> 00:14:55.090
And the community as a whole,
this is sort of beyond Android

00:14:55.090 --> 00:14:57.659
as well, is still
trying to figure out

00:14:57.659 --> 00:14:58.825
what the right way to do is.

00:14:58.825 --> 00:15:00.850
These are mostly sort
of general Java language

00:15:00.850 --> 00:15:03.060
issues that are actually
not specific to Android.

00:15:05.680 --> 00:15:09.730
But there seems to be agreement
that you shouldn't use object

00:15:09.730 --> 00:15:11.740
dot finalize, as
evidenced by the fact

00:15:11.740 --> 00:15:16.570
that it's going to be deprecated
sometime in the future.

00:15:16.570 --> 00:15:18.460
So the advice here--
and I'll go into how

00:15:18.460 --> 00:15:21.580
to do this-- is we use
something called Java

00:15:21.580 --> 00:15:25.080
lang phantom reference instead.

00:15:25.080 --> 00:15:26.920
Many of you may have
encountered that.

00:15:26.920 --> 00:15:28.840
As far as I can tell,
most people look at it

00:15:28.840 --> 00:15:32.620
and ignore it because
it's somewhat complicated

00:15:32.620 --> 00:15:35.140
and probably appears even more
complicated than it actually

00:15:35.140 --> 00:15:36.650
is.

00:15:36.650 --> 00:15:38.590
It's not very commonly
used, but it actually

00:15:38.590 --> 00:15:42.070
is a better replacement
for finalizers.

00:15:42.070 --> 00:15:44.320
It avoids the problem
that the finalizer

00:15:44.320 --> 00:15:48.910
can see finalize objects
because of the auditing issues.

00:15:48.910 --> 00:15:52.180
Phantom references ensure that
you run on the cleanup code

00:15:52.180 --> 00:15:54.820
only when the object
really is about to go away

00:15:54.820 --> 00:15:58.600
and nobody can use it and
nobody can see it anymore.

00:15:58.600 --> 00:16:01.250
It certainly deals with the
finalized replication issues.

00:16:01.250 --> 00:16:04.210
It's not going away.

00:16:04.210 --> 00:16:07.540
It also ends up dealing with
some of the more subtle issues

00:16:07.540 --> 00:16:09.550
there, though not all of them.

00:16:09.550 --> 00:16:12.190
It does not deal with the
premature cleanup issue

00:16:12.190 --> 00:16:14.020
that I mentioned earlier
that an object can

00:16:14.020 --> 00:16:16.420
be finalized while one of
its methods is still running,

00:16:16.420 --> 00:16:18.290
for example.

00:16:18.290 --> 00:16:19.990
The major difficulty
with using it--

00:16:19.990 --> 00:16:21.820
and I'll go through
an example here--

00:16:21.820 --> 00:16:24.040
is that it's
relatively complicated

00:16:24.040 --> 00:16:25.820
to use at the moment.

00:16:25.820 --> 00:16:27.822
And we're in the process
of making that better.

00:16:27.822 --> 00:16:29.530
I think various groups
are in the process

00:16:29.530 --> 00:16:31.660
of making that better.

00:16:31.660 --> 00:16:34.249
So Java 9 actually
has this notion

00:16:34.249 --> 00:16:36.415
of a cleaner, which makes
this a little bit simpler.

00:16:39.010 --> 00:16:41.230
Inside the platform
we actually have

00:16:41.230 --> 00:16:43.420
something called native
allocation registry

00:16:43.420 --> 00:16:45.250
that deals with some of this.

00:16:45.250 --> 00:16:48.460
Is at the moment
not a public API,

00:16:48.460 --> 00:16:49.852
but if you're
interested in this,

00:16:49.852 --> 00:16:51.310
we're trying to
assess whether that

00:16:51.310 --> 00:16:53.850
would be good to make
that a public API

00:16:53.850 --> 00:16:56.560
and whether this is the
right API to do that with.

00:17:00.350 --> 00:17:02.240
So what should you use instead?

00:17:02.240 --> 00:17:04.250
Well, I mentioned these
phantom references.

00:17:04.250 --> 00:17:06.085
So what are they?

00:17:06.085 --> 00:17:11.780
A phantom reference is shown
here with a ghost next to it.

00:17:11.780 --> 00:17:16.490
It's an object that's
associated with the object whose

00:17:16.490 --> 00:17:18.710
lifetime you want to monitor.

00:17:18.710 --> 00:17:25.819
So it doesn't actually point
to or refer to the binary poly

00:17:25.819 --> 00:17:28.280
object that we want
monitored and then we

00:17:28.280 --> 00:17:30.170
want to be cleaned up after.

00:17:30.170 --> 00:17:32.300
So you can sort of think
of the phantom reference

00:17:32.300 --> 00:17:35.990
as the last will and
testament of the Java object.

00:17:35.990 --> 00:17:38.840
It tells you what to do,
how to clean up the object

00:17:38.840 --> 00:17:40.085
once the Java object dies.

00:17:42.740 --> 00:17:47.540
So the way this works
normally, in order

00:17:47.540 --> 00:17:49.580
to actually use a
phantom reference,

00:17:49.580 --> 00:17:51.840
you'll usually inherit from it.

00:17:51.840 --> 00:17:56.000
And the inherited derive class,
the class derived from phantom

00:17:56.000 --> 00:17:59.360
reference will have a
pointer to the C++ object,

00:17:59.360 --> 00:18:03.270
along with the Java
binary poly object.

00:18:03.270 --> 00:18:07.105
There's also a reference queue
off to the side here, which--

00:18:07.105 --> 00:18:09.960
and I'll show you what roll
that plays in a second here.

00:18:09.960 --> 00:18:12.050
Notice that I've put those
ground symbols in here

00:18:12.050 --> 00:18:16.010
in a few places to indicate
that those objects that we

00:18:16.010 --> 00:18:18.150
need to make sure don't
get garbage collected.

00:18:18.150 --> 00:18:20.010
So we need to have some
mechanism for keeping those

00:18:20.010 --> 00:18:20.510
around.

00:18:20.510 --> 00:18:23.030
That applies to both the phantom
reference and the reference

00:18:23.030 --> 00:18:24.810
queue.

00:18:24.810 --> 00:18:26.310
So what happens?

00:18:26.310 --> 00:18:30.210
After binary poly
becomes unreachable,

00:18:30.210 --> 00:18:32.250
the phantom
reference itself gets

00:18:32.250 --> 00:18:35.137
added to the associated
reference queue.

00:18:35.137 --> 00:18:36.720
And that's basically
all that happens.

00:18:36.720 --> 00:18:39.330
The Java object gets
immediately collected.

00:18:39.330 --> 00:18:40.920
There's no longer
any need for it,

00:18:40.920 --> 00:18:43.860
because the Phantom reference
itself knows how to clean up.

00:18:48.600 --> 00:18:52.330
So I'll show you a sort of
quick implementation of this

00:18:52.330 --> 00:18:54.910
here in this case.

00:18:54.910 --> 00:18:56.710
This pub actually
is fairly easy.

00:18:56.710 --> 00:18:59.980
So we've modified
binary poly to deal

00:18:59.980 --> 00:19:02.800
with this sort of
reference clean up.

00:19:02.800 --> 00:19:05.110
And what I've done
is on the next slide

00:19:05.110 --> 00:19:09.190
I'll show you a BP phantom
reference implementation that

00:19:09.190 --> 00:19:10.685
inherits from phantom reference.

00:19:10.685 --> 00:19:12.310
It's a kind of phantom
reference that's

00:19:12.310 --> 00:19:16.150
specialized with some
additional functionality here.

00:19:16.150 --> 00:19:20.470
And what this does here is we
still have the native delete

00:19:20.470 --> 00:19:23.020
method that actually
deallocates the C++ object.

00:19:27.040 --> 00:19:29.320
Whenever I allocate
a binary object,

00:19:29.320 --> 00:19:34.270
I now do it through this
factory method which [INAUDIBLE]

00:19:34.270 --> 00:19:35.870
and allocates the object.

00:19:35.870 --> 00:19:39.010
But then immediately
goes and registers it

00:19:39.010 --> 00:19:41.650
through a static method
in BP phantom reference

00:19:41.650 --> 00:19:44.170
the way I've
implemented it here.

00:19:44.170 --> 00:19:47.520
Now once BP phantom reference?

00:19:47.520 --> 00:19:52.860
So that fits on a slide in
the same way that in the sense

00:19:52.860 --> 00:19:55.050
that the old Midas commercial,
if you remember that.

00:19:59.380 --> 00:20:03.430
So I've stretched it to
fit it on a slide here.

00:20:03.430 --> 00:20:05.940
So what that does is
it introduces a couple

00:20:05.940 --> 00:20:07.920
of static data structures.

00:20:07.920 --> 00:20:10.180
One of them is the
actual reference queue,

00:20:10.180 --> 00:20:14.550
which will be used to enqueue
these BP phantom differences

00:20:14.550 --> 00:20:17.850
once the corresponding Java
object is no longer needed.

00:20:17.850 --> 00:20:23.040
And I also need to have
a concurrently set here.

00:20:23.040 --> 00:20:27.360
Some way to just keep the
BP phantom references around

00:20:27.360 --> 00:20:30.100
so they don't get garbage
collected themselves.

00:20:30.100 --> 00:20:34.290
So I just keep those
around, basically until they

00:20:34.290 --> 00:20:37.300
are explicitly removed.

00:20:37.300 --> 00:20:44.490
So what I do then is
whenever I can select

00:20:44.490 --> 00:20:47.760
one of these BP phantom
references, I first of all

00:20:47.760 --> 00:20:49.290
can select the
Phantom reference,

00:20:49.290 --> 00:20:52.620
giving it the Java object
and the reference queue.

00:20:52.620 --> 00:20:54.510
This tells the underlying
phantom reference

00:20:54.510 --> 00:20:58.080
implementation to
watch that Java object,

00:20:58.080 --> 00:21:00.060
and put it on the
queue that I gave it

00:21:00.060 --> 00:21:01.680
when the Java object goes away.

00:21:04.210 --> 00:21:06.930
And then I also remember
the native handle,

00:21:06.930 --> 00:21:09.630
so I can actually invoke
the deallocation function

00:21:09.630 --> 00:21:12.070
when it's time.

00:21:12.070 --> 00:21:14.610
So what happens when I
register one of these things?

00:21:14.610 --> 00:21:17.400
So I registers the Java object
and the corresponding native

00:21:17.400 --> 00:21:18.960
handle.

00:21:18.960 --> 00:21:22.770
I create a new BP
phantom reference.

00:21:22.770 --> 00:21:26.030
And I add it to my set
here, just to make sure

00:21:26.030 --> 00:21:27.030
that it doesn't go away.

00:21:30.390 --> 00:21:33.210
And this is sort of part of
the ugliness of this scheme,

00:21:33.210 --> 00:21:35.880
unfortunately that
we're trying do address.

00:21:35.880 --> 00:21:39.180
At some point, every once
in a while I actually

00:21:39.180 --> 00:21:42.000
need to arrange that everything
that's on the reference

00:21:42.000 --> 00:21:43.640
queue gets deleted.

00:21:43.640 --> 00:21:47.730
And I've done that here by
providing a method duty leads,

00:21:47.730 --> 00:21:50.550
which just checks
whether there's anything

00:21:50.550 --> 00:21:52.540
available for deletion.

00:21:52.540 --> 00:21:56.100
And if so, it goes
ahead and deletes that.

00:21:56.100 --> 00:21:59.160
In other contexts, you may
want to do this differently.

00:21:59.160 --> 00:22:01.960
Rather than just pulling
when something is available,

00:22:01.960 --> 00:22:04.865
you may actually want a separate
thread for this and block.

00:22:04.865 --> 00:22:07.290
It sort of depends
on the context.

00:22:07.290 --> 00:22:11.180
It's a little bit tricky here
to do this well in the launch

00:22:11.180 --> 00:22:14.130
system, because the
easy way to do this

00:22:14.130 --> 00:22:16.080
is to create a new thread
for every class that

00:22:16.080 --> 00:22:18.400
does this, which may or may
not be acceptable depending

00:22:18.400 --> 00:22:19.650
on how many of these you have.

00:22:25.020 --> 00:22:27.710
So then in order to
actually make this work,

00:22:27.710 --> 00:22:32.060
my application needs to do the
following things periodically.

00:22:32.060 --> 00:22:35.000
In simple cases, you can skip
the system dot GC and system

00:22:35.000 --> 00:22:36.389
dot run finalization.

00:22:36.389 --> 00:22:38.930
If he noticed that the garbage
collector isn't running enough

00:22:38.930 --> 00:22:41.570
because you're not allocating
enough Java objects in order

00:22:41.570 --> 00:22:44.700
to actually trigger it, you
may have to explicitly do that.

00:22:44.700 --> 00:22:47.180
But usually, that's
not an issue.

00:22:47.180 --> 00:22:49.070
But you do have
to regularly call

00:22:49.070 --> 00:22:51.650
BP phantom reference dot
do Deletes to actually do

00:22:51.650 --> 00:22:53.800
the cleanup the way
I've done things here.

00:22:57.540 --> 00:23:01.050
So the next problem
here that I mentioned

00:23:01.050 --> 00:23:04.670
is the prematuring queueing
while a method is still

00:23:04.670 --> 00:23:07.530
running.

00:23:07.530 --> 00:23:10.110
As I said, this is not
actually an issue for Android,

00:23:10.110 --> 00:23:13.170
but it is an issue
for portable code.

00:23:13.170 --> 00:23:19.270
So there's a partial solution
to this in actually in Java 9,

00:23:19.270 --> 00:23:21.540
which is this thing called
a reachability fence, which

00:23:21.540 --> 00:23:25.230
you can explicitly invoke to
tell the implementation don't

00:23:25.230 --> 00:23:27.740
let the argument go away yet.

00:23:27.740 --> 00:23:29.740
It should still be live
to the garbage collector

00:23:29.740 --> 00:23:33.360
even though it might
not look like it.

00:23:33.360 --> 00:23:35.250
That's not really
available basically,

00:23:35.250 --> 00:23:38.130
in any implementation that
you can use at the moment.

00:23:38.130 --> 00:23:41.430
So the best solution that my
colleagues and I could come up

00:23:41.430 --> 00:23:45.040
with at the moment
is the following,

00:23:45.040 --> 00:23:46.710
which is relatively
simple, but not

00:23:46.710 --> 00:23:48.005
exactly performance neutral.

00:23:51.520 --> 00:23:55.660
Is that instead of have a
simple methods like multiply,

00:23:55.660 --> 00:23:59.200
that just invoke the native
method with the native handles.

00:23:59.200 --> 00:24:01.930
What we do instead is we
invoke the native method

00:24:01.930 --> 00:24:04.460
with both the native handles
and the Java objects.

00:24:07.370 --> 00:24:10.460
So what I do instead is I have
a native multiply that takes

00:24:10.460 --> 00:24:13.240
the two J objects as well.

00:24:13.240 --> 00:24:15.710
And current implementations,
though the spec

00:24:15.710 --> 00:24:19.970
doesn't 100% guarantee that,
current implementations are

00:24:19.970 --> 00:24:22.190
essentially guaranteed
that this and other turns

00:24:22.190 --> 00:24:26.120
into a local ref, which tells
the garbage collector to keep

00:24:26.120 --> 00:24:29.450
these around as long as the
native method is running

00:24:29.450 --> 00:24:31.280
so things will actually
work out correctly

00:24:31.280 --> 00:24:33.930
at the expense of passing
additional parameters through J

00:24:33.930 --> 00:24:39.330
and I. Again, this
is recommended

00:24:39.330 --> 00:24:41.700
if you write portable code.

00:24:41.700 --> 00:24:44.610
For Android, I currently
wouldn't recommend doing that.

00:24:44.610 --> 00:24:46.170
Eventually sometime
in the future,

00:24:46.170 --> 00:24:49.350
I think better we will probably
have a better solution to this.

00:24:57.070 --> 00:25:00.100
So one more hazard that I
want to go over quickly,

00:25:00.100 --> 00:25:05.800
in part because this is
near and dear to my heart.

00:25:05.800 --> 00:25:09.850
Because it took several months
of several people's time

00:25:09.850 --> 00:25:12.400
to debug platform code
that had this issue.

00:25:12.400 --> 00:25:15.400
If you are using C++
code in this way,

00:25:15.400 --> 00:25:18.040
you need to be really careful
that you are actually calling

00:25:18.040 --> 00:25:21.730
it correctly and not violating
the C++ rules underneath.

00:25:21.730 --> 00:25:25.090
And that can be quite
tricky to do correctly.

00:25:25.090 --> 00:25:27.894
So in particular, if you're
calling C++ code from Java

00:25:27.894 --> 00:25:30.310
threads, it still has to be
thread safe as though you were

00:25:30.310 --> 00:25:34.350
calling it from
multiple C++ threads.

00:25:34.350 --> 00:25:36.350
And you have to make sure
to follow those rules.

00:25:36.350 --> 00:25:40.000
This is a bit aggravated by
the fact that some Android

00:25:40.000 --> 00:25:43.420
framework classes actually
use C++ code internally.

00:25:43.420 --> 00:25:46.510
So this gets back to the point
I was making at the beginning

00:25:46.510 --> 00:25:49.420
that you have to make sure to
use those frameworks classes

00:25:49.420 --> 00:25:51.910
correctly, because otherwise
you can run into this problem

00:25:51.910 --> 00:25:53.840
even without actually
writing native code.

00:25:58.910 --> 00:26:02.840
One issue that's particularly
subtle on the C++ side that

00:26:02.840 --> 00:26:05.360
actually contributed to this
problem that we spend lots

00:26:05.360 --> 00:26:10.670
of time on is that often on the
C++ side when you call delete,

00:26:10.670 --> 00:26:13.070
you actually end up invoking
some reference counting

00:26:13.070 --> 00:26:16.430
mechanism that then takes care
of the underlying C++ objects

00:26:16.430 --> 00:26:18.253
that are indirectly referenced.

00:26:20.860 --> 00:26:24.830
You have to be really careful
in doing that correctly.

00:26:24.830 --> 00:26:28.400
I highly recommend using an
expert developed implementation

00:26:28.400 --> 00:26:29.750
of reference counting.

00:26:29.750 --> 00:26:31.340
Not to [INAUDIBLE] your own.

00:26:31.340 --> 00:26:33.290
I spent a lot of
time recently fixing

00:26:33.290 --> 00:26:35.450
bugs in the Android
platform reference counting

00:26:35.450 --> 00:26:37.400
implementations.

00:26:37.400 --> 00:26:40.110
So it's not too likely.

00:26:40.110 --> 00:26:43.220
I think that most people
will get this right

00:26:43.220 --> 00:26:44.459
implementing it themselves.

00:26:44.459 --> 00:26:46.250
There are a whole bunch
of different issues

00:26:46.250 --> 00:26:49.010
here having to do with
memory altering bugs and self

00:26:49.010 --> 00:26:50.690
assignments and so on.

00:26:50.690 --> 00:26:53.510
It only is a tiny
amount of code,

00:26:53.510 --> 00:26:55.820
but it's a really
tricky piece of code.

00:26:59.457 --> 00:27:01.540
But assuming you have a
correct reference counting

00:27:01.540 --> 00:27:06.340
implementation, it's still
hard to use it correctly.

00:27:06.340 --> 00:27:08.530
So one thing you
have to remember,

00:27:08.530 --> 00:27:10.150
the rules vary a
little bit, depending

00:27:10.150 --> 00:27:11.130
on the implementation.

00:27:11.130 --> 00:27:13.960
But for something
like std share ptr,

00:27:13.960 --> 00:27:17.290
when you create a
shared ptr to something,

00:27:17.290 --> 00:27:20.500
the object will be
deallocated when

00:27:20.500 --> 00:27:23.990
the reference count associated
with copies of that shared ptr

00:27:23.990 --> 00:27:25.240
goes to 0.

00:27:25.240 --> 00:27:30.370
So creating multiple
shared ptr's

00:27:30.370 --> 00:27:33.530
corresponding to the same
underlying [INAUDIBLE] pointer

00:27:33.530 --> 00:27:36.070
it's not likely to work well.

00:27:36.070 --> 00:27:38.290
It's also not
likely to work well

00:27:38.290 --> 00:27:40.080
to generate a reference
counted pointer

00:27:40.080 --> 00:27:43.240
to this in the constructor
for a similar sort of reason.

00:27:43.240 --> 00:27:45.640
Because probably by the time
you leave the constructor,

00:27:45.640 --> 00:27:47.350
that reference count
will have gone to 0,

00:27:47.350 --> 00:27:48.766
and you will
deallocate the object

00:27:48.766 --> 00:27:51.970
before you ever leave the
constructor, which is not good.

00:27:51.970 --> 00:27:55.020
So you have to be careful
with that sort of thing.

00:27:55.020 --> 00:27:59.830
The thread safety rules are
in some ways even more subtle,

00:27:59.830 --> 00:28:03.830
and also something that you
really want to watch out for.

00:28:03.830 --> 00:28:09.190
So assuming here I have a bunch
of shared ptr's, it's actually

00:28:09.190 --> 00:28:14.080
OK, according to the normal
C++ thread safety rules,

00:28:14.080 --> 00:28:19.240
if I take x, the shared ptr
x, and copy it simultaneously

00:28:19.240 --> 00:28:22.960
in two different threads to
two different other pointers,

00:28:22.960 --> 00:28:25.030
this will [INAUDIBLE]
simultaneously update

00:28:25.030 --> 00:28:27.310
the reference count
associated with x.

00:28:27.310 --> 00:28:28.060
But that's OK.

00:28:28.060 --> 00:28:29.950
It's the implementation's
job to make sure

00:28:29.950 --> 00:28:32.220
that that works correctly.

00:28:32.220 --> 00:28:33.990
So that's fine.

00:28:33.990 --> 00:28:36.000
What's not fine,
and what in fact

00:28:36.000 --> 00:28:38.310
caused this sort of
long standing bug

00:28:38.310 --> 00:28:42.210
that we have to deal with here,
is the last thing on the slide

00:28:42.210 --> 00:28:45.330
here, simultaneous assignments
to the same reference

00:28:45.330 --> 00:28:46.740
counted pointers.

00:28:46.740 --> 00:28:50.070
If I simultaneously assign
even null to the same reference

00:28:50.070 --> 00:28:52.260
counted pointer, that
looks pretty benign.

00:28:52.260 --> 00:28:54.060
I'm assigning the same
thing concurrently

00:28:54.060 --> 00:28:56.890
to two different threads,
what could go wrong.

00:28:56.890 --> 00:29:00.630
The problem is it's disallowed
by C++ rules for good reason.

00:29:00.630 --> 00:29:03.720
Because what happens
here is both threads

00:29:03.720 --> 00:29:07.890
will try to simultaneously
[INAUDIBLE] the reference

00:29:07.890 --> 00:29:12.940
count associated with
the original value of P.

00:29:12.940 --> 00:29:16.300
If they erase each other just
right so they both do this

00:29:16.300 --> 00:29:19.780
before either one actually
assigns null to the pointer,

00:29:19.780 --> 00:29:22.060
they will end up
both [INAUDIBLE]

00:29:22.060 --> 00:29:24.910
that reference count, which
originally had a value of 1

00:29:24.910 --> 00:29:30.680
because it was referenced
by P. That doesn't go well.

00:29:30.680 --> 00:29:32.990
In the [INAUDIBLE]
reference count decrement

00:29:32.990 --> 00:29:34.040
is always death.

00:29:39.270 --> 00:29:46.350
So summarizing here, important
point is avoid finalization.

00:29:46.350 --> 00:29:50.250
Use Java lang phantom
reference instead.

00:29:50.250 --> 00:29:52.080
Currently, that's a
little bit clumsy,

00:29:52.080 --> 00:29:56.940
but it avoids you also all
sort of potential headaches.

00:29:56.940 --> 00:29:59.290
If you want to read
up on this more,

00:29:59.290 --> 00:30:04.350
I suggest you actually look up
the Java 9 reachability fence

00:30:04.350 --> 00:30:05.887
construct and discussion.

00:30:05.887 --> 00:30:07.470
That'll give you a
little more insight

00:30:07.470 --> 00:30:11.430
as to why some of these
things are a problem,

00:30:11.430 --> 00:30:16.560
and particular why you have to
worry about premature clean up

00:30:16.560 --> 00:30:18.090
with the Java semantics.

00:30:18.090 --> 00:30:20.490
Again, not so much on Android.

00:30:20.490 --> 00:30:26.640
And stay tuned for future
improvements in this area here.

00:30:26.640 --> 00:30:29.550
If you allocate a
lot of C++ objects,

00:30:29.550 --> 00:30:32.220
if that's where most of your
heap space ends up getting

00:30:32.220 --> 00:30:35.890
spent, then you should think
about explicit GC triggering.

00:30:35.890 --> 00:30:37.200
But doing it very carefully.

00:30:37.200 --> 00:30:39.690
Make sure you keep track
of how much C++ memory

00:30:39.690 --> 00:30:40.860
you've allocated.

00:30:40.860 --> 00:30:43.290
And when you've allocated a
lot, so you think it might be

00:30:43.290 --> 00:30:48.060
useful, then you can invoke the
garbage collector so phantom

00:30:48.060 --> 00:30:50.790
references for dead objects
getting queued at that point,

00:30:50.790 --> 00:30:54.160
so you can actually do the
C++ clean up at that point.

00:30:54.160 --> 00:30:56.910
Otherwise, if you are not
allocating any Java memory,

00:30:56.910 --> 00:30:58.500
usually that Java
garbage collector

00:30:58.500 --> 00:31:02.060
will not otherwise
get triggered.

00:31:02.060 --> 00:31:05.290
Be careful with C++ memory
management and understand

00:31:05.290 --> 00:31:05.790
the rules.

00:31:10.510 --> 00:31:14.580
So we actually have a little
bit of time for questions

00:31:14.580 --> 00:31:17.430
here, if there are any.

00:31:17.430 --> 00:31:18.310
That's the end of it.

00:31:18.310 --> 00:31:19.726
Thank you very
much for attending.

00:31:19.726 --> 00:31:23.026
[APPLAUSE]

00:31:25.894 --> 00:31:31.460
[MUSIC PLAYING]

