WEBVTT
Kind: captions
Language: en

00:09:24.573 --> 00:09:29.051
  AN33 Android UI and Layouts  
&gt;&gt; Good morning, everyone.  So, 

00:09:29.052 --> 00:09:30.938
my name is nibbling Las and this
 is John and we are going to 

00:09:30.939 --> 00:09:38.471
talk to you today about 
constraint layouts.    A new 

00:09:38.472 --> 00:09:40.472
layout.

00:09:43.786 --> 00:09:48.489
&gt;&gt; JOHN: What is layout all 
about?  Basically you need to 

00:09:48.490 --> 00:09:54.594
position this on the screen 
based on something that UI given

00:09:56.867 --> 00:10:00.059
 you, for example, so you have 
to lay them out in some 

00:10:00.060 --> 00:10:01.988
particular fashion on a screen. 
 What happens if you have 

00:10:01.989 --> 00:10:07.186
another screen that you have to 
layout?  If they are fixed 

00:10:07.187 --> 00:10:11.259
position, on the new screen, it 
is not going to look right.  

00:10:11.260 --> 00:10:16.142
Things are too far away from the
 edges and things like that.  

00:10:16.143 --> 00:10:18.511
Now how many screens woulds you 
actually have to do if you have 

00:10:18.512 --> 00:10:26.925
to do every screen out there?  
5,4 Sunday a rough         

00:10:32.754 --> 00:10:38.968
  5,400.  That is 30 language, 
landscape, portrait, many, many 

00:10:38.969 --> 00:10:41.319
devices.  It will take you a 
really long time.  That's why 

00:10:41.320 --> 00:10:48.326
from the beginning, Android had 
layouts.  They are able to 

00:10:48.327 --> 00:10:55.215
adjust sizes and position things
 dynamically for you.  There are

00:10:55.614 --> 00:11:00.822
 a bunch of different layouts we
 can talk about.  You can divide

00:11:01.216 --> 00:11:06.210
 them into two basic categories.
  Simple layouts and complex 

00:11:06.211 --> 00:11:09.999
layouts.
The classic simple laysought 

00:11:10.000 --> 00:11:14.829
LinearLayout.  Essentially, you 
put your widgets inside of it 

00:11:14.830 --> 00:11:23.778
and you a rule or column of 
buttons or widgets.  Now you can

00:11:23.779 --> 00:11:27.516
 build very complex layouts just
 using LinearLayout by doing 

00:11:27.517 --> 00:11:33.737
deep nesting but deep nesting 
has its performance problems.

00:11:33.834 --> 00:11:40.594
On the other happened, if you 
use a complex layout, like 

00:11:40.595 --> 00:11:45.247
relative layout or grid layout, 
it will create shallow 

00:11:45.248 --> 00:11:50.025
hierarchies but without a good 
builder to use them, it's 

00:11:50.026 --> 00:11:54.400
actually very difficult to keep 
them stable.  We need something 

00:11:54.401 --> 00:12:01.133
new to help us with that stuff. 
 That is why --

00:12:01.134 --> 00:12:08.776
&gt;&gt; NICOLAS: That is why we are 
now presenting you

00:12:11.843 --> 00:12:18.357
 conlayouts cornstraint layouts.
  And basically it is small in 

00:12:18.358 --> 00:12:20.358
the

00:12:24.290 --> 00:12:31.742
 library -- this is designed to 
redeuce hierarchies from the 

00:12:31.743 --> 00:12:35.081
beginning to walk within studio.
  And if you started to look a 

00:12:35.082 --> 00:12:40.649
little bit at constraint layout 
already, it might look a little 

00:12:40.650 --> 00:12:46.717
bit -- between two different 
jets -- that seems pretty 

00:12:46.718 --> 00:12:54.113
similar to what ConstraintLayout
 does.  But it does that and 

00:12:54.114 --> 00:12:57.455
more.  And as it is more 
expressive, you should be able 

00:12:57.456 --> 00:13:02.814
to reduce nesting and as John 
said, nesting is not a great 

00:13:02.815 --> 00:13:09.308
thing for preferences.
It's also in the library which 

00:13:09.309 --> 00:13:14.396
means not only can you use it 
from Day One but we also will be

00:13:14.501 --> 00:13:19.773
 able to -- push new features 
and you will be able to get them

00:13:21.717 --> 00:13:26.545
 instantly.  It is also -- which
 you don't care too much about 

00:13:26.546 --> 00:13:29.703
that.  But allows us to easily 
add new features and finally, it

00:13:31.742 --> 00:13:39.891
 comes with a great builder that
 was created -- the same team 

00:13:39.892 --> 00:13:47.356
worked on the constraint lay out
 and UIBer to make a -- UI 

00:13:47.357 --> 00:13:50.243
Builder and flex and I believe 
easy to use.  We started to 

00:13:50.244 --> 00:13:54.077
create a new layout system 
because we are not currently 

00:13:54.078 --> 00:13:56.885
happy with the design, but we 
just started with something very

00:13:57.597 --> 00:14:01.597
 genetic.  We need an equation 
solver and on top of that, we 

00:14:01.598 --> 00:14:09.357
had equations but the problem 
with that is with the equation 

00:14:09.358 --> 00:14:12.851
-- we could have stopped there. 
 We have equation, that's great.

00:14:12.852 --> 00:14:18.416
  Virtual layouts and that's it.
  But the issue with that is it 

00:14:18.417 --> 00:14:21.172
is very easy for us to create a 
system that is not only complex,

00:14:21.492 --> 00:14:26.587
 may not perform really well and
 can also be unpredictable in 

00:14:26.588 --> 00:14:31.468
the way it reacts.  So that is 
why we built on top of the 

00:14:31.469 --> 00:14:37.175
equation system very simple but 
expressive system of constraints

00:14:37.352 --> 00:14:42.191
 and that allows us to control 
the type of constraints and the 

00:14:42.192 --> 00:14:47.697
type of equation that runs and 
on top of preferences.

00:14:48.035 --> 00:14:53.348
On top of that, we built the UI 
Builder plus tools to create the

00:14:54.358 --> 00:14:59.658
 constraint for you and further 
tools we will demo later.  So, 

00:14:59.659 --> 00:15:03.183
very quickly constraint model.  
If you want to create the 

00:15:03.184 --> 00:15:09.059
connection, you just drag to a 
target.  And the other thing to 

00:15:09.060 --> 00:15:13.328
do is if you drag that, you can 
specify a margin.  That is all 

00:15:13.329 --> 00:15:17.263
the a connection is.  It's 
saying take one side, move it to

00:15:17.404 --> 00:15:21.349
 a target and possibly keep a 
specific gap.

00:15:22.759 --> 00:15:26.964
And you can not make those 
connections across the bottom, 

00:15:26.965 --> 00:15:28.965
left, right

00:15:31.163 --> 00:15:37.888
 and -- at first glance that is 
it.  The other thing that is 

00:15:37.889 --> 00:15:42.209
different and particularly 
relative to layouts is what if 

00:15:42.210 --> 00:15:46.399
you set the connection on both 
end.  Both on the left and 

00:15:46.400 --> 00:15:50.630
right?  If you have a widget 
that is fixed size, that sounds 

00:15:50.631 --> 00:15:56.296
impossible, right?  The left 
side cannot be matching it's 

00:15:56.297 --> 00:16:00.324
constraint at the same time as 
the right side matches 

00:16:00.325 --> 00:16:04.992
constraint if the widget does 
not resize.  What we do in that 

00:16:04.993 --> 00:16:07.990
case is just center it.  And 
because it is centered and we 

00:16:07.991 --> 00:16:14.689
can tweak the result, we let you
 decide how much bias you want 

00:16:14.690 --> 00:16:17.504
to one side or the other.  And 
you can also do that directly 

00:16:17.505 --> 00:16:23.505
into the UI Builder or use the 
inspector.  And what if you want

00:16:23.867 --> 00:16:30.130
 to resize a widget is in this 
case, think about it -- we do 

00:16:30.131 --> 00:16:34.114
not support -- what we do 
support is something more match 

00:16:34.115 --> 00:16:38.086
constraints.  What that will do 
is resize the widget so 

00:16:38.087 --> 00:16:41.931
constraint you define, define 
the size of the widget.

00:16:42.538 --> 00:16:47.651
And those are important aspect 
that is often comes when you try

00:16:48.995 --> 00:16:54.927
 to do complex UI.  You want the
 widget to become.  And the 

00:16:54.928 --> 00:16:57.791
first case is -- the widget is 
invisible.  If you do that, 

00:16:57.792 --> 00:17:01.185
nothing changes.  That is easy. 
 Just not drawn on screen.  What

00:17:01.860 --> 00:17:08.531
 we do is we collapse the widget
 that you map as a single point 

00:17:08.532 --> 00:17:13.040
and we discard the margins.  So 
it disappeared but hierarchy of 

00:17:13.041 --> 00:17:17.882
constraint still applies.  So it
 allows to you have a lot more 

00:17:17.883 --> 00:17:20.744
reactive user interface 
behaviors.

00:17:21.283 --> 00:17:27.424
All right.  Some of you might 
have attributes and yes, we did 

00:17:27.425 --> 00:17:32.970
build a great UI Builder and we 
do think that UI Builder will 

00:17:32.971 --> 00:17:37.820
create the UIs and make your 
life easy.  But if you do want 

00:17:37.821 --> 00:17:43.805
to use the XML or the 
programming you can still do it.

00:17:43.919 --> 00:17:46.814
  It's a normal group.  You see 
you have access to everything.  

00:17:46.815 --> 00:17:49.683
If you look at those attributes,
 it sounds like there is a lot. 

00:17:49.794 --> 00:17:55.269
 But actually, not so much.  If 
you look at those, those are the

00:17:55.404 --> 00:17:58.327
 usual once.  Justifying width 
and size and text size and stuff

00:17:59.068 --> 00:18:01.905
 like that.
To do with us really.  And then 

00:18:01.906 --> 00:18:09.485
you have virtual attributes that
 actually is for the tool.  If 

00:18:09.486 --> 00:18:13.858
you do things program taically 
you don't care about that at 

00:18:13.859 --> 00:18:18.367
all.  When you push to device, 
those attributes get stripped 

00:18:18.368 --> 00:18:20.917
out.  So really the one we care 
about are those in the middle 

00:18:20.918 --> 00:18:24.364
and really the four in the 
middle, manager in and stuff, 

00:18:24.365 --> 00:18:28.926
you probably know them already. 
 So we only have two more 

00:18:28.927 --> 00:18:30.677
attributes.  Constraint on the 
left and constraint on the top. 

00:18:30.678 --> 00:18:36.778
 So it is pretty attractive.  We
 think the UI build ser great 

00:18:36.779 --> 00:18:39.865
and if you have issues with your
 UI Builder, if it doesn't work 

00:18:39.866 --> 00:18:43.412
for your work flow, tell us.  We
 really want to hear from you 

00:18:43.413 --> 00:18:48.425
and make your life easy.
All right.  Let's talk about the

00:18:48.530 --> 00:18:57.862
 layout stuff.  So, we can XM R 
and see results directly live

00:18:58.905 --> 00:19:04.619
 or you can -- XML -- you can 
have both views at the same time

00:19:04.806 --> 00:19:09.009
 or stay with one.  Integrate 
into studio.  And we really try 

00:19:09.010 --> 00:19:12.754
to make it so is there an 
immediate feedback.  And so it 

00:19:12.755 --> 00:19:17.165
is really easy to use.  Things 
get predictable and you're not 

00:19:17.166 --> 00:19:22.658
surprised like you might have 
been in the past with whatever 

00:19:22.659 --> 00:19:26.796
the layout -- wherever you 
decide to put the widgets.  And 

00:19:26.797 --> 00:19:34.264
we just redid this in 2.2 
preview.  It's in alpha.  We 

00:19:34.265 --> 00:19:38.169
welcome reports.
All right --

00:19:38.170 --> 00:19:41.643
&gt;&gt; NICOLAS: One of the nice 
things the new layout is the 

00:19:41.644 --> 00:19:49.212
inspector.  This gives you -- 
JOHN: Iconified view of a signal

00:19:49.363 --> 00:19:54.737
 womenit that you selected.  The
 arrows on the left and right 

00:19:54.738 --> 00:20:00.301
and up and down show you which 
Sites have been constrained, the

00:20:01.646 --> 00:20:04.544
 numbers show you the margins 
that have been set.  And you can

00:20:04.945 --> 00:20:09.433
 actually just move your mouse 
over them and edit the margins 

00:20:09.434 --> 00:20:15.676
directly.  The slide allows you 
to adjust by us if you're 

00:20:15.677 --> 00:20:19.673
connected on both sides so you 
have a bias.  The arrows inside 

00:20:19.674 --> 00:20:24.632
show whether your wrap content 
or spread or fixed width.  Okay.

00:20:24.633 --> 00:20:31.397
  Let's go to the demo now and 
on the laptop.

00:20:31.398 --> 00:20:34.001
&gt;&gt; NICOLAS: So you can see that 
studio.  And if you played with 

00:20:34.002 --> 00:20:38.855
it already, that should be 
familiar.  And you can see here 

00:20:38.856 --> 00:20:43.637
it just shows the constraint 
layout and I can switch design 

00:20:43.638 --> 00:20:48.424
mode.  We have two modes, design
 mode where it shows what things

00:20:48.839 --> 00:20:51.655
 look like on the device and you
 have the blueprint mode and you

00:20:52.017 --> 00:20:55.776
 can also have both of them at 
the same time if you prefer.  

00:20:55.777 --> 00:20:59.268
So, why did we do the blueprint 
mode?  Because simply sometimes 

00:20:59.269 --> 00:21:03.319
what you show in terms of layout
 doesn't actually appear in the 

00:21:03.320 --> 00:21:07.972
interface like for example, if 
you look at the button.  The 

00:21:07.973 --> 00:21:12.145
button shows smaller than what 
it is.  So the blueprint mode, 

00:21:12.146 --> 00:21:15.815
think about it as an X-ray of 
your current layout and only 

00:21:15.816 --> 00:21:21.034
show you information that 
pertains to the layout.  So, we 

00:21:21.035 --> 00:21:25.209
constructed so you can drag 
wherever you want.  And you do 

00:21:25.210 --> 00:21:30.058
have some guidelines to help you
 position.  We follow the 

00:21:30.059 --> 00:21:33.983
Material Design guideline for 
instance.  And it is very easy 

00:21:33.984 --> 00:21:37.154
to use.  Without doing any 
constraints so far, you can move

00:21:37.348 --> 00:21:40.274
 it wherever you want.  It's 
pretty good when you're simply 

00:21:40.275 --> 00:21:43.842
playing around or trying to 
design your UI how things really

00:21:44.494 --> 00:21:48.839
 fit.  So if you create the 
connection, we just animate 

00:21:48.840 --> 00:21:50.983
directly.  You can see that if I
 don't create the connection, we

00:21:51.138 --> 00:21:56.703
 still show you what will happen
 if you release and create the 

00:21:56.704 --> 00:22:05.295
connection.  And it works with 
the system.  So if I drag a 

00:22:05.296 --> 00:22:09.997
button and you know, I kill this
 connection, everything moves 

00:22:09.998 --> 00:22:15.647
together.  So, you can see here 
it is only constraint.  So 

00:22:15.648 --> 00:22:18.549
vertically nothing changes and I
 can create a connection like 

00:22:18.550 --> 00:22:22.285
that.  You can destroy all the 
connection by clicking this.  

00:22:22.286 --> 00:22:26.669
And just adding your things and 
create those connections.  There

00:22:27.072 --> 00:22:31.364
 are two different modes to 
create connections.  One is this

00:22:31.887 --> 00:22:34.827
 manual one and I think it is 
very important because we want 

00:22:34.828 --> 00:22:40.887
you to be able to easily tweak 
the UI.  But there is one that 

00:22:40.888 --> 00:22:46.958
is a little bit more easy to use
 in some cases, which is the 

00:22:46.959 --> 00:22:53.235
auto alliance and if we go on 
auto alignments.  Auto alignment

00:22:53.415 --> 00:22:59.847
 works with this icon here.  
This little U-shaped magnet.  If

00:22:59.987 --> 00:23:05.072
 that is on, if I put my widget 
on a guideline, it will create 

00:23:05.073 --> 00:23:08.954
those connections and you can 
see small animation as long as 

00:23:08.955 --> 00:23:12.085
animation is not finished, I can
 still move things around.  If I

00:23:12.210 --> 00:23:19.329
 let it go, then the widget will
 be constrained.  So if I resize

00:23:19.330 --> 00:23:28.302
 -- if I resize that you can see
 constraints are applied.  And I

00:23:28.509 --> 00:23:35.261
 think we talk about tools now.
&gt;&gt; JOHN: One more piece to 

00:23:35.262 --> 00:23:38.365
alignment that you might have 
forgotten.  One of the nice 

00:23:38.366 --> 00:23:42.514
things about auto alignment is 
that when you put an object like

00:23:42.931 --> 00:23:47.338
 this, the fact that you see the
 guidelines allows it to 

00:23:47.339 --> 00:23:52.182
connect.  So as long as you can 
see the guidelines, you'll be 

00:23:52.183 --> 00:23:55.185
able to let it go and it will 
connect for you.  So it could be

00:23:55.647 --> 00:24:02.044
 a quick way, especially for 
very simple UIs to be built.

00:24:02.506 --> 00:24:10.709
The next thing I wanted to show 
you is, what we call our tools. 

00:24:10.907 --> 00:24:17.138
 So because we are so much rich 
UI layout-type environment, we 

00:24:17.139 --> 00:24:22.991
wanted to add tools a lot like 
the stuff that you would see in 

00:24:22.992 --> 00:24:26.871
PowerPoint or any of the Visio, 
or graphical tools.  So, at the 

00:24:26.872 --> 00:24:33.463
top you will see a collection of
 widgets.  And they work in 

00:24:33.464 --> 00:24:43.437
standard ways where -- where 
they align left, right,

00:24:43.741 --> 00:24:46.946
 middle, that kind of thing.  
There is a special mode.  If you

00:24:48.700 --> 00:24:53.539
 have the magnet turned on when 
you issue those, it will 

00:24:53.540 --> 00:24:58.541
actually create constraints for 
you.  So, if you care about 

00:24:58.542 --> 00:25:01.495
having constraints very 
specifically left aligned, you 

00:25:01.496 --> 00:25:07.088
can use this to -- to tell you 
how would that happen?

00:25:07.089 --> 00:25:11.968
&gt;&gt; NICOLAS: And it's how we want
 the tool to be used in a very 

00:25:11.969 --> 00:25:15.278
flexible way.  Some people might
 just as they go along, just 

00:25:15.279 --> 00:25:20.284
create the constraints.  Or some
 people might just prefer to 

00:25:20.285 --> 00:25:23.061
layout the widget.  And then 
build a constraint.  It's really

00:25:23.341 --> 00:25:28.391
 up to you.
&gt;&gt; JOHN: So it helps in a lot of

00:25:28.747 --> 00:25:32.837
 situations like to where you 
just aligning things, putting 

00:25:32.838 --> 00:25:37.912
things together like this, 
setting up.  And you can see 

00:25:37.913 --> 00:25:44.665
fairly quickly I can come up 
with a reasonable amount of 

00:25:44.666 --> 00:25:53.275
alignment and packing of things 
and ways we like to use it.

00:25:54.052 --> 00:26:02.147
For the next piece -- I wanted 
to talk to you about

00:26:04.264 --> 00:26:12.294
 inference.  Now inference is a 
fairly complicated system.  What

00:26:12.447 --> 00:26:20.915
 we are doing is just one button
.  Don't press it yet.  What we 

00:26:20.916 --> 00:26:25.796
do, when you press that button, 
we calculate the probability of 

00:26:25.797 --> 00:26:32.342
all possible connections up and 
then we walk through a series of

00:26:34.356 --> 00:26:39.600
 algorithms which will make 
connections for you.  By the end

00:26:39.775 --> 00:26:43.437
 of it, all things will be 
properly constrained.  There are

00:26:43.951 --> 00:26:47.456
 a couple of things that are a 
bit magical.  But there are a 

00:26:47.457 --> 00:26:51.886
couple of things to remember 
about it.  Three things to 

00:26:51.887 --> 00:26:55.874
remember.  It will never really 
move a widget on you.  It will 

00:26:55.875 --> 00:27:00.163
apply constraints wherever you 
left your widgets beforehand.  

00:27:00.164 --> 00:27:05.536
So it's not going to suddenly 
push a widget off skew or 

00:27:05.537 --> 00:27:15.401
something like that.
It will do some small changes

00:27:16.464 --> 00:27:21.729
 whenever there is -- trying to 
do alignment of things.  But 

00:27:21.730 --> 00:27:26.544
that is okay.  By the end of the
 pass, all of the things are 

00:27:26.545 --> 00:27:30.640
guaranteed to be constrained.  
If you have a constraint 

00:27:30.641 --> 00:27:33.700
beforehand, it will honor those 
constraints.  So it will never 

00:27:33.701 --> 00:27:37.189
destroy an existing constraint 
that you have created.  So you 

00:27:37.190 --> 00:27:41.902
can create constraints and then 
let it finish the job for you.  

00:27:41.903 --> 00:27:47.007
And in fact, in the demos, you 
saw, a lot were some manually 

00:27:47.008 --> 00:27:52.729
created constraints.  Sometimes 
it will do auto constraint.  Go 

00:27:52.730 --> 00:27:59.274
ahead Nicolas and press the 
button.  Let's see what happens.

00:27:59.363 --> 00:28:03.496
  It made a bunch of 
constraints.  It aligned 

00:28:03.497 --> 00:28:11.280
everything.  Now resize the 
widget.  Resize the screen.  So 

00:28:11.281 --> 00:28:13.989
that was done just by drawing 
out the widgets in the right 

00:28:13.990 --> 00:28:17.848
space and it can align them.  If
 you didn't like a particular 

00:28:17.849 --> 00:28:23.298
constraint it made, you can 
change it yourself or add a new 

00:28:23.299 --> 00:28:24.880
constraint.
&gt;&gt; NICOLAS: So for example, I 

00:28:24.881 --> 00:28:27.731
can still go and destroy the 
connections and say actually I 

00:28:27.732 --> 00:28:31.550
really wanted that one to be 
connected on the top.  And 

00:28:31.551 --> 00:28:34.398
actually here you can see that 
we have a couple of modes to 

00:28:34.399 --> 00:28:41.250
create those connections.  So by
 default it creates the Toolbar 

00:28:41.251 --> 00:28:47.303
on the top.  But if I press 
control, it will create with the

00:28:47.304 --> 00:28:49.310
 current distance and sometimes 
that is kind of nice.  Because 

00:28:49.311 --> 00:28:52.226
if you just want to create the 
constraint but you are happy 

00:28:52.227 --> 00:28:57.524
with the current way the widgets
 are positioned, that is a 

00:28:57.525 --> 00:28:59.525
timesaver.
&gt;&gt; JOHN: So another thing you

00:29:02.473 --> 00:29:03.741
 can do is if you already laid 
out and added a bunch of 

00:29:03.742 --> 00:29:07.967
constraints but you need a new 
piece of UI on the system, add a

00:29:08.421 --> 00:29:18.356
 new piece of UI in there.  Now,
 you can just press the button 

00:29:18.357 --> 00:29:20.462
again.
&gt;&gt; NICOLAS: The auto connect was

00:29:20.877 --> 00:29:24.341
 on.  It automatically tried to 
create those connections.  But 

00:29:24.342 --> 00:29:29.292
you can also do it here.
&gt;&gt; JOHN: And it added all the 

00:29:29.293 --> 00:29:31.164
constraints in to fill in the 
widget.

00:29:31.165 --> 00:29:34.136
&gt;&gt; NICOLAS: And you can see the 
constraint it created was not 

00:29:34.137 --> 00:29:39.042
the same as the auto connection 
one.  And that is actually 

00:29:39.043 --> 00:29:42.895
because auto connect when you 
look at the amounts that are 

00:29:42.896 --> 00:29:45.862
close to you, so that is why it 
shows you the guidelines and 

00:29:45.863 --> 00:29:49.595
those guidelines if you drop the
 widget at this moment, will 

00:29:49.596 --> 00:29:54.389
create constraints where the 
guidelines originate from.  The 

00:29:54.390 --> 00:29:57.521
auto inference on the other hand
 look at the big picture.

00:29:57.522 --> 00:30:02.766
&gt;&gt; JOHN: So it might pick things
 from based on alignments to 

00:30:02.767 --> 00:30:05.162
probabilities, fairly 
complicated and in the future we

00:30:05.307 --> 00:30:14.000
 are trying to do like more 
advanced algorithms in there.

00:30:14.100 --> 00:30:18.275
&gt;&gt; NICOLAS: I want to repeat 
what John said earlier.  The 

00:30:18.276 --> 00:30:21.366
auto inference is not going to 
move things around.  It will 

00:30:21.367 --> 00:30:24.873
very hard try to keep the widget
 where you put them.  That means

00:30:25.128 --> 00:30:27.324
 if you're not happy with the 
result, you can still go back 

00:30:27.325 --> 00:30:32.335
and edit it and it also tries to
 make the connection that makes 

00:30:32.336 --> 00:30:34.336
sense.
That might not be the connection

00:30:34.531 --> 00:30:38.138
 you had in mind but it say 
connection that makes sense when

00:30:38.472 --> 00:30:41.477
 you look at the entire system. 
 It doesn't go crazy, that's 

00:30:41.478 --> 00:30:44.876
what I'm trying to say.  That's 
why it is important to have 

00:30:44.877 --> 00:30:52.749
those manual capabilities to add
 constraints.  We see it more as

00:30:53.536 --> 00:30:56.917
 a -- between you and the tool. 
 The tool will help you get you 

00:30:56.918 --> 00:31:00.698
there 90% of the way and save 
you a ton of time and just focus

00:31:01.039 --> 00:31:04.416
 on what is left.
&gt;&gt; JOHN: Even if it doesn't work

00:31:05.086 --> 00:31:14.051
 out, always undo.
&gt;&gt; NICOLAS: So let's simply 

00:31:14.052 --> 00:31:17.599
build something common like a 
row.  If I want to create a row 

00:31:17.600 --> 00:31:21.031
like that, I can use the tools 
as well.  I can if I just want 

00:31:21.032 --> 00:31:30.202
to center, I can just do that.  
And if I look at the recycle 

00:31:30.203 --> 00:31:34.881
now, it appears here but of 
course it is taking all the 

00:31:34.882 --> 00:31:40.695
space.  So if I map now the 
constraint layouts to be 

00:31:40.696 --> 00:31:42.736
rebelling om pens, you can

00:31:45.928 --> 00:31:49.297
 see -- recompense -- you can 
see how it is in recycle view.  

00:31:49.298 --> 00:31:54.745
You can just continue and add 
more stuff and that is it.  You 

00:31:54.746 --> 00:31:58.775
can easily hold your rows.  So 
it doesn't automatically have to

00:31:59.093 --> 00:32:03.415
 work with the UI.  You can use 
it for your main UI and you can 

00:32:03.416 --> 00:32:08.987
use it for something as simple 
as a row like that.  It is just 

00:32:08.988 --> 00:32:14.570
automatic.  And you can see the 
result.

00:32:14.960 --> 00:32:18.935
And let me just create just to 
show you quickly how to create a

00:32:19.215 --> 00:32:25.156
 new layout file.  So you can 
instant preview 2.2.  Loot see 

00:32:25.157 --> 00:32:28.830
demo.  You just go here and type
 ConstraintLayout and what that 

00:32:28.831 --> 00:32:32.690
will do, it will create the 
file.  It actually will 

00:32:32.691 --> 00:32:41.369
automatically add if that was 
not the case -- contains 

00:32:41.370 --> 00:32:43.715
constraint layouts and you can 
then build something.  And you 

00:32:43.716 --> 00:32:47.759
can still use the design mode if
 you prefer the design mode.  

00:32:47.760 --> 00:32:51.193
That is still working fine.  We 
just in that case, show the 

00:32:51.194 --> 00:32:56.400
different constraint as a 
overlay on top of the system.  

00:32:56.401 --> 00:33:00.268
Or you can just switch to 
blueprint.  I prefer blueprint 

00:33:00.269 --> 00:33:04.252
because it makes things easier 
for me.  But the design mode is 

00:33:04.253 --> 00:33:10.881
really useful to show you how 
things look.  So if you want to 

00:33:10.882 --> 00:33:15.882
just build like a dialogue like 
that, you could have something 

00:33:15.883 --> 00:33:25.643
up just like that and let'ssade 
actually use e-mail and

00:33:27.496 --> 00:33:34.055
 just plain text here and then 
you can see that up the 

00:33:34.056 --> 00:33:40.150
connection was here, up like 
that, and that is it.  And we 

00:33:40.151 --> 00:33:45.187
are doing anything else, I have 
my dialogue.  You can see 

00:33:45.188 --> 00:33:51.400
resides.  If you want to 
reinvent -- repent.  Sorry.

00:33:51.401 --> 00:33:54.637
&gt;&gt; JOHN: You might want to --
&gt;&gt; NICOLAS: Yes.  And you can 

00:33:54.638 --> 00:33:57.963
still go back and kill all the 
constraints and do the 

00:33:57.964 --> 00:34:01.327
inference.  It does a pretty 
good job as well.  And you can 

00:34:01.328 --> 00:34:07.212
not hear that we constrained on 
the baseline for instance.  

00:34:07.213 --> 00:34:13.781
Another thing that is for the 
demo, we can go back to the 

00:34:13.782 --> 00:34:15.782
Slides.

00:34:18.616 --> 00:34:21.933
Just to summarize a little bit 
what we showed you.  So, there 

00:34:21.934 --> 00:34:26.976
is a new constraint.  A new 
layout.  ConstraintLayout is a 

00:34:26.977 --> 00:34:31.283
small undo library.  100 
kilobytes.  We think we 

00:34:31.284 --> 00:34:33.932
developed to move fast and the 
new features, it is really built

00:34:34.378 --> 00:34:41.619
 on top of flexible base.  And 
what is good for us is that we 

00:34:41.620 --> 00:34:45.158
can control and move on the 
developments and to make sure 

00:34:45.159 --> 00:34:49.200
that the preferences will 
sustain.  It is compatible with 

00:34:49.201 --> 00:34:52.796
most things out there and this 
is active development.  I want 

00:34:52.797 --> 00:34:59.331
to -- we just released it this 
week.  It's coming just as a 

00:34:59.332 --> 00:35:05.218
preview.  We want you to check 
it out.  Check the UI Builder.  

00:35:05.219 --> 00:35:11.110
And we will fix the bugs if any 
but the reason we announced it 

00:35:11.111 --> 00:35:15.268
at I/O is because we continuing 
is really enough to gather some 

00:35:15.269 --> 00:35:18.065
feedback and that is something 
we are keen on.  We to hear from

00:35:18.605 --> 00:35:20.605
 you.  Our job is to make your 
life

00:35:23.006 --> 00:35:27.889
 easier.  On the UI Builder as 
you saw, the UI Builder is 

00:35:27.890 --> 00:35:31.008
trying to automatically react to
 your actions and to help you, 

00:35:31.009 --> 00:35:37.854
to give you some guidance and 
you can use inference to create 

00:35:37.855 --> 00:35:47.085
connections to save you time.  
You can still go back and just 

00:35:47.086 --> 00:35:50.126
inference.  And same as the 
ConstraintLayout itself.  It's 

00:35:50.127 --> 00:35:56.030
the same team that works on -- 
why is why they are well 

00:35:56.031 --> 00:35:59.586
integrated together.  So, all 
that is said for 

00:35:59.587 --> 00:36:02.588
ConstraintLayout and applies for
 the UI Builder.  By the way, 

00:36:02.589 --> 00:36:06.194
2.2 preview there is a new UI 
Builder for ConstraintLayout and

00:36:06.436 --> 00:36:13.306
 also a new UI builder for the 
older layout you already use in 

00:36:13.307 --> 00:36:21.284
your applications.  If you use 
the UI Builder in studio, this 

00:36:21.285 --> 00:36:26.155
the new one is a step up.  And 
this will get better over time.

00:36:26.260 --> 00:36:30.754
Let me talk briefly about what 
we have in mind for

00:36:33.988 --> 00:36:37.538
 the next versions.  So if you 
remember the slide from earlier 

00:36:37.539 --> 00:36:41.908
about the equation and 
constraints, clearly, we are 

00:36:41.909 --> 00:36:46.512
going to focus on following the 
-- improving performance.  We 

00:36:46.513 --> 00:36:50.858
have a ton of optimization we 
are going to -- obvious ones we 

00:36:50.859 --> 00:36:56.054
haven't yet done.  So we really 
want to focus on that.  For the 

00:36:56.055 --> 00:37:00.397
equation then we generate from 
the constraint, we have some 

00:37:00.398 --> 00:37:03.467
interesting ideas.  
Automatically take them and 

00:37:03.468 --> 00:37:06.504
simplify them and auto myself 
them.  But for

00:37:09.884 --> 00:37:14.084
 constraint -- auto myself them 
-- there is a couple of things 

00:37:09.884 --> 00:37:16.265
we can do and we could have 
demoed it but in addition to the

00:37:16.422 --> 00:37:21.703
 basic constraints that we 
demonstrated, we have the 

00:37:21.704 --> 00:37:26.733
concept of helpers.  One of the 
helpers we have in the preview 

00:37:26.734 --> 00:37:30.798
actually is the guideline.  You 
can create a guideline, a 

00:37:30.799 --> 00:37:34.572
Photoshop guideline, something 
like that, something to work 

00:37:34.573 --> 00:37:38.343
with and set the guideline and 
make it relative to one side or 

00:37:38.344 --> 00:37:44.221
the other or the dimension of 
the container, and simply 

00:37:44.222 --> 00:37:46.626
constraint your wing tote that 
guideline.  The interesting 

00:37:46.627 --> 00:37:50.878
thing -- widget to this 
guideline.  This is not a new 

00:37:50.879 --> 00:37:55.147
layout.  This is just an object 
we used to generate the right 

00:37:55.148 --> 00:37:59.948
equations.  We have a ton of 
ideas of all types of objects 

00:37:59.949 --> 00:38:05.534
like that to help you create 
more advanced layouts.  And also

00:38:05.855 --> 00:38:09.730
 another thing we look for at 
I/O and we know is important is 

00:38:09.731 --> 00:38:15.108
that all we talked so far with 
the demo, let's you create 

00:38:15.109 --> 00:38:17.545
constraints, position 
constraints from one-to-one.  Of

00:38:17.546 --> 00:38:21.084
 course it can be from one 
widget to many widgets for the 

00:38:21.085 --> 00:38:26.700
two axis but it is going to be 
from one widget to do something 

00:38:26.701 --> 00:38:30.416
else.  And you want to actually 
consider positioning and 

00:38:30.417 --> 00:38:34.001
grouping.  You want to say, yes,
 sure.  But I want this group of

00:38:35.250 --> 00:38:37.924
 stuff to be vertically 
positioned.  And we have concept

00:38:38.117 --> 00:38:42.021
 of virtual containers and 
similarly to the guidelines, 

00:38:42.022 --> 00:38:45.600
those things don't have to end 
up in the hierarchy.  So once we

00:38:45.776 --> 00:38:49.935
 create them, they will actually
 appear in the XML as a normal 

00:38:49.936 --> 00:38:54.588
tag.  You will see them.  But 
when we inflate XML, we can drop

00:38:54.714 --> 00:38:58.484
 on the floor and simply use 
them to write equations.  So you

00:38:59.680 --> 00:39:03.864
 still have the power of using 
Groups without the implication 

00:39:03.865 --> 00:39:08.330
in terms of hierarchy.  You can 
think of this system as a way of

00:39:09.079 --> 00:39:14.268
 decoupling the layout from the 
viewer and the shallower the 

00:39:14.269 --> 00:39:17.954
hierarchy, the better in terms 
of differences but also other 

00:39:17.955 --> 00:39:20.845
things.
One particular thing that I'm 

00:39:20.846 --> 00:39:23.088
really keen on exploring is if 
you have a shallow hierarchy, 

00:39:23.089 --> 00:39:28.052
that should make your life a ton
 easier dealing with animations.

00:39:28.156 --> 00:39:32.414
  I think if you try to do 
animation with very deep nested 

00:39:32.415 --> 00:39:35.855
hierarchies, it can be very 
annoying because something that 

00:39:35.856 --> 00:39:41.205
is really deep done, you want to
 maybe move somewhere else and 

00:39:41.206 --> 00:39:45.043
it is very difficult to do right
 now.  But, if you are do not 

00:39:45.044 --> 00:39:49.986
have a hierarchy and serving 
kind of flat, it's much nicer.  

00:39:49.987 --> 00:39:55.986
And of course for the inference 
and tuning, we have some 

00:39:55.987 --> 00:40:00.268
interesting ideas in studio and 
the concept is simply, we want 

00:40:00.269 --> 00:40:04.107
you to give you a step up.  
Don't start from scratch.  If 

00:40:04.108 --> 00:40:06.691
you design something, maybe 
there is something in what it 

00:40:06.692 --> 00:40:12.310
gives you that we can use.
And John may have something to 

00:40:12.311 --> 00:40:15.411
say about that.
&gt;&gt; JOHN: So the inference and 

00:40:15.412 --> 00:40:21.171
tools are a combination that we 
see a lot of future of making 

00:40:21.172 --> 00:40:24.957
your life very easy.  So one of 
the things we want to do is back

00:40:25.161 --> 00:40:31.561
 the probability ies by machine 
learning.  So we look at what 

00:40:31.562 --> 00:40:34.853
layouts are out there.  What are
 all the Google layouts that are

00:40:34.963 --> 00:40:39.801
 created and see how they are 
working and try to learn from 

00:40:39.802 --> 00:40:45.412
them.  Tools to help you more 
easily beautify and organize and

00:40:47.429 --> 00:40:51.575
 arrange your widgets on the 
screen more dynamics associated 

00:40:51.576 --> 00:40:55.034
with when I put things on the 
screen so it will automatically 

00:40:55.035 --> 00:40:57.953
infer containers and virtual 
containers and guidelines and 

00:40:57.954 --> 00:41:02.339
things like that as well.  So 
there is a lot of room to grow 

00:41:02.340 --> 00:41:09.509
in that area as well.
&gt;&gt; NICOLAS: Thank you for your 

00:41:09.510 --> 00:41:13.954
attendance.  Check out this code
 lab that lets you walk you 

00:41:13.955 --> 00:41:18.820
through the first steps in using
 ConstraintLayout and download 

00:41:18.821 --> 00:41:22.084
the preview.  There is a ton of 
things you saw in the previous 

00:41:22.085 --> 00:41:27.587
sessions of studio.  You can use
 tool studio and we can take 

00:41:27.588 --> 00:41:32.641
some Q&amp;A now and there are some 
mics that you can come up to if 

00:41:32.642 --> 00:41:34.315
you want.
[ Applause ]

00:41:34.316 --> 00:41:36.800
&gt;&gt; JOHN: Thank you.

00:41:45.883 --> 00:41:50.064
&gt;&gt; AUDIENCE MEMBER: Heo.  Hi.  I
 was curious.  How expensive is 

00:41:50.065 --> 00:41:53.308
the on measure and on layout 
after this?

00:41:53.309 --> 00:41:59.040
&gt;&gt; NICOLAS: That is a good 
question.  So I don't know the 

00:41:59.041 --> 00:42:02.286
preferences are not where we 
think they will be because we 

00:42:02.287 --> 00:42:08.428
just released it so we actually 
think that we should be a lot 

00:42:08.429 --> 00:42:16.330
better.  As I said, there is 
optization.  But in terms of 

00:42:16.331 --> 00:42:22.581
cost, we do one pass for 
measuring each widget so, and 

00:42:22.582 --> 00:42:25.599
unless the widget is set to 
match the constraint and in that

00:42:26.158 --> 00:42:32.101
 case, we do two passes.  So 
overall, it should be really 

00:42:32.102 --> 00:42:34.599
efficient.
&gt;&gt; JOHN: That is pretty similar 

00:42:34.600 --> 00:42:39.013
to where you are right now.
&gt;&gt; Knack knack match constraint 

00:42:39.014 --> 00:42:43.427
will be two measures, yes.
&gt;&gt; AUDIENCE MEMBER: Thank you.

01:11:51.554 --> 01:11:55.820
 to do is get users logged into 
your app.  It would be easy to 

01:11:55.821 --> 01:12:00.353
have a ride sharing app where 
anonymous drivers are giving 

01:12:00.354 --> 01:12:03.158
people to nonce muspeople to 
anonymous people.  That seems 

01:12:03.159 --> 01:12:06.663
like a recipe for disaster.  You
 want to get people bogged in 

01:12:06.664 --> 01:12:10.044
and identified so they have 
assurance this is a legit thing.

01:12:10.458 --> 01:12:14.747
  You dock that with fire 
Firebase.  You can get logged in

01:12:15.105 --> 01:12:20.543
 with minimal friction.  So 
we'll accept Google Plus log 

01:12:20.544 --> 01:12:22.391
ins, Facebook, Twitter and 
GitHub.  Regular e-mail and 

01:12:22.392 --> 01:12:26.175
password and if you bring your 
own authentication you can 

01:12:26.176 --> 01:12:28.555
integrate that as well.  The 
good thing about this is once we

01:12:28.912 --> 01:12:34.466
 have user identity, we can 
access profile pictures to help 

01:12:34.467 --> 01:12:36.467
drivers locate passengers 
passengers locate drivers.

01:12:36.577 --> 01:12:39.846
But if the profile picture isn't
 appropriate or missing, what 

01:12:39.847 --> 01:12:44.315
can you do is use Firebase 
Storage to provide a place for 

01:12:44.316 --> 01:12:47.544
people to take pictures of 
themselves and store that in 

01:12:47.545 --> 01:12:53.762
places.  So, once you have them 
stored, then use that to help 

01:12:53.763 --> 01:12:58.838
drivers and passengers find each
 other.  Now, Firebase Storage 

01:12:58.839 --> 01:13:04.695
is built on top of Google Cloud 
Storage and it scales to Peta 

01:13:04.696 --> 01:13:08.477
bytes of Storage.  It's big.  
But that roughly translates to 

01:13:08.478 --> 01:13:11.198
billions of photos.  So you will
 never run out of space when you

01:13:12.931 --> 01:13:16.545
 need it.  Now, you probably 
want drivers to be able to 

01:13:16.546 --> 01:13:19.707
locate passengers wherever they 
are so if a passenger has moved,

01:13:19.859 --> 01:13:23.833
 that driver needs to respond to
 that.  What you can do is use 

01:13:23.834 --> 01:13:32.129
Firebase Realtime Database to 
write the user's longitude, cord

01:13:32.701 --> 01:13:33.765
 nants into the Realtime 
Database and the driver can 

01:13:33.766 --> 01:13:36.711
receive that in realtime.  So 
think of like data going into 

01:13:36.712 --> 01:13:40.149
the Cloud, into the database and
 being distributed in realtime 

01:13:40.150 --> 01:13:46.418
to those listening to it.  So 
not only can drivers find 

01:13:46.419 --> 01:13:47.787
passengers location, the 
passengers can see where a 

01:13:47.788 --> 01:13:51.533
driver is.  It gives you 
assurance that things are going 

01:13:51.534 --> 01:13:57.894
according to plan.
Now, if you are using 

01:13:57.895 --> 01:14:00.833
authentication along with 
database and Storage, what can 

01:14:00.834 --> 01:14:05.150
you do is set up rules so that 
the data you store in your 

01:14:05.151 --> 01:14:08.457
database and in your file 
Storage is protected by 

01:14:08.458 --> 01:14:10.382
authentication rules and you 
write those rules yourself.  You

01:14:10.383 --> 01:14:14.957
 determine who can see what 
other contents.  So you can be 

01:14:14.958 --> 01:14:19.831
sure your passenger and driver's
 data is see cured safely.  And 

01:14:19.832 --> 01:14:23.638
-- secured -- you probably don't
 79 to be glued to your app all 

01:14:23.639 --> 01:14:27.517
the time.  So imagine you hailed
 a ride and it's like 10 minutes

01:14:28.287 --> 01:14:31.350
 away.  You don't want to stare 
at your app for 10 minutes.  So 

01:14:31.351 --> 01:14:34.447
what can you do is allow the 
user to put the app away and 

01:14:34.448 --> 01:14:38.450
then send a message to them when
 the driver appears and use 

01:14:38.451 --> 01:14:41.264
Firebase Cloud Messaging for 
that.  So you can get users back

01:14:41.504 --> 01:14:44.529
 into your app at the time 
something is important to them. 

01:14:44.716 --> 01:14:47.521
 So for a passenger when the 
driver arrives, they'll need to 

01:14:47.522 --> 01:14:50.466
know that.  Send them hay 
notification.  Likewise, if 

01:14:50.467 --> 01:14:53.428
you're a driver, you might want 
to know where passengers are if 

01:14:53.429 --> 01:14:56.445
there is a passenger nearby who 
wants a ride, get a notification

01:14:56.915 --> 01:15:00.419
 for that as well.
Now, it's worth noting these are

01:15:01.327 --> 01:15:05.169
 event-driven Notifications.  So
 Firebase Cloud Messaging is 

01:15:05.170 --> 01:15:08.029
great for times when there is 
something in the system that 

01:15:08.030 --> 01:15:11.568
changed and you need to know 
about that in the app.  Now it's

01:15:11.569 --> 01:15:14.148
 a different kind of 
notification called Firebase 

01:15:14.149 --> 01:15:17.204
Notifications.  What this gives 
you is a way to type in message 

01:15:17.205 --> 01:15:21.795
ands send them to the users in 
the console.  So you can say, 

01:15:21.796 --> 01:15:24.537
remind users if they haven't 
used the app in a while.  Or you

01:15:25.030 --> 01:15:28.570
 can say advertise a promotion. 
 So if you have 20% off rides 

01:15:28.571 --> 01:15:32.039
send a notification to everyone 
and get them back into the app.

01:15:32.141 --> 01:15:38.365
Now if you're trying to perform 
an experiment you might want to 

01:15:38.366 --> 01:15:42.526
figure out is it authentication 
better shally or late?  You want

01:15:42.751 --> 01:15:46.869
 to know the right time in the 
app to get users authenticated. 

01:15:46.870 --> 01:15:51.387
 So, a lot of people might turn 
away if there is early 

01:15:51.388 --> 01:15:54.450
authentication.  They might not 
want to bother with that.  So 

01:15:54.451 --> 01:15:58.797
far experiment and say, I'll 
test out early testing out early

01:15:58.928 --> 01:16:01.516
 and late after the user poked 
around in the app a little bit. 

01:16:01.517 --> 01:16:03.517
 If you want to know which

01:16:06.232 --> 01:16:08.380
 works better, usury moat config
 to perform that experiment.  So

01:16:08.381 --> 01:16:12.457
 -- Firebase Remote Config.  So 
this is a great way to find out 

01:16:12.458 --> 01:16:17.072
how your app works better for 
your users.

01:16:17.355 --> 01:16:19.694
Now you probably want to get the
 word out about your app.  So 

01:16:19.695 --> 01:16:24.399
the best way to do that is to 
hook into relevant searches.  So

01:16:24.597 --> 01:16:28.871
 on Google people might be 
searching for say, a taxi.  Or 

01:16:28.872 --> 01:16:32.446
airport transportation.  In this
 case, use Google AdWords along 

01:16:32.447 --> 01:16:35.414
with Firebase, to hook into 
those search results and have 

01:16:35.415 --> 01:16:40.193
your app appear.  It's 
essentially a relevant add in 

01:16:40.194 --> 01:16:41.267
search results to get people 
into your app at the time they 

01:16:41.268 --> 01:16:46.113
are looking for it.
Another way to get users into 

01:16:46.114 --> 01:16:51.112
your app is with Dynamic Links. 
 So it's a bridge between your 

01:16:51.113 --> 01:16:54.646
reb content and mobile content. 
 It's easy to get web traffic.  

01:16:54.647 --> 01:16:59.188
It's easy to hook into searches 
that way.  Everyone knows,use a 

01:16:59.189 --> 01:17:01.429
web browedder but you might want
 to push people into your mobile

01:17:02.545 --> 01:17:04.479
 app for that are unique 
experience.  So Dynamic Links 

01:17:04.480 --> 01:17:07.898
can do that.  It's great for 
marketing promotions.  You can 

01:17:07.899 --> 01:17:10.460
say have a special link that 
people will follow and then that

01:17:10.662 --> 01:17:14.072
 links directly into the app for
 a first time experience that 

01:17:14.073 --> 01:17:18.531
keeps them engaged.  And also if
 they don't have the app 

01:17:18.532 --> 01:17:21.051
installed, what Dynamic Links 
will do is get you installed 

01:17:21.052 --> 01:17:25.341
into the app and then it will 
take them directly to the 

01:17:25.342 --> 01:17:28.358
content.  Now, in the past, deep
 links always had the problem of

01:17:28.492 --> 01:17:32.373
 not being able to survive this 
installation process.  But with 

01:17:32.374 --> 01:17:35.804
Dynamic Links, now you can.  You
 can get users installed and 

01:17:35.805 --> 01:17:39.067
directly to the content you 
want.

01:17:39.436 --> 01:17:43.411
Now there is Firebase Invites 
which is built on top of that.  

01:17:43.412 --> 01:17:46.288
This let's happy users invite 
other happy users.

01:17:46.368 --> 01:17:50.641
This is word-of-mouth marketing.
  The best twiget users.  

01:17:50.642 --> 01:17:55.132
Glowing reviews from your happy 
users are more likely to create 

01:17:55.133 --> 01:17:58.857
retention for the users they had
 refer.  Now invites are built 

01:17:58.858 --> 01:18:01.818
on top.  All the power of 
dynamics links with the 

01:18:01.819 --> 01:18:04.292
personalization that an 
invitation gives.  And we found 

01:18:04.293 --> 01:18:08.599
this increases retention 
drastically.

01:18:11.957 --> 01:18:13.916
Now, the last component I'd like
 to talk about for this app, the

01:18:13.917 --> 01:18:17.018
 ride sharing app, is Analytics.
  Now it is the core component. 

01:18:17.019 --> 01:18:19.363
 This is the thing that ties 
together the rest of the 

01:18:19.364 --> 01:18:23.511
Firebase platform.  So with 
Analytics, the obvious benefit 

01:18:23.512 --> 01:18:28.143
is that you can know how your 
app is doing.  It's worth noting

01:18:28.338 --> 01:18:32.113
 this is a new component.  This 
is not a remake or rehash of 

01:18:32.114 --> 01:18:35.595
something else, this is built 
for Firebase for mobile 

01:18:35.596 --> 01:18:38.244
applications.  You can know how 
people are using your app and 

01:18:38.245 --> 01:18:41.763
also measure the efficacy of 
your AdWords and your 

01:18:41.764 --> 01:18:46.304
invitations and know how users 
are interacting with your app 

01:18:46.305 --> 01:18:49.554
from external sources and it 
works well with Notifications as

01:18:49.555 --> 01:18:52.973
 well.  So now with Analytics, 
define an audience of users who 

01:18:52.974 --> 01:18:55.992
you want to target.  So say you 
want to target everyone who took

01:18:56.422 --> 01:19:00.476
 a ride in Boston in the last 
week or so.  Now get them to get

01:19:00.702 --> 01:19:04.151
 back in your app and type a 
notification and say, we hope 

01:19:04.152 --> 01:19:08.862
you enjoyed your ride.  Would 
you consider taking another one?

01:19:09.282 --> 01:19:14.447
So that is 10.  I show 15 up 
here.  We only talked about 10.

01:19:14.660 --> 01:19:20.266
That is a lot of components.  A 
great twibuild a ride sharing 

01:19:20.267 --> 01:19:24.204
app.  What about the other 5?  I
 have a second app idea and it 

01:19:24.205 --> 01:19:29.194
is totally neat.  It's a recipe 
sharing app.  I call it iChef'd.

01:19:29.444 --> 01:19:32.558
  I'm bad at making mobile app 
names.  Run with me with this.  

01:19:32.559 --> 01:19:38.218
So imagine you have an app that 
is Android, iOS and mobile web 

01:19:38.219 --> 01:19:41.847
and desktop web.  You're 
scattering your app and trying 

01:19:41.848 --> 01:19:45.475
to reach as many people as 
possible.  You generally want 

01:19:45.476 --> 01:19:49.779
your app to be used anonymously 
so if people are just doing 

01:19:49.780 --> 01:19:53.414
regular Web Searches, they might
 log in but not logged in yet 

01:19:53.415 --> 01:19:57.250
but they'll find a recipe, 
search for other recipes, enjoy 

01:19:57.251 --> 01:20:01.881
the app anonymously, but if you 
want someone like integrate 

01:20:01.882 --> 01:20:04.522
their own recipes in your app, 
you might want to get them 

01:20:04.523 --> 01:20:08.280
logged in.  This is how this app
 works.  So the first thing 

01:20:08.281 --> 01:20:11.355
obviously you'll need a place to
 store all of your recipe data. 

01:20:11.584 --> 01:20:14.964
 So, you can use Firebase 
Realtime Database for that.  Now

01:20:15.159 --> 01:20:18.477
 it's worth noting that recipes 
aren't really realtime.  There 

01:20:18.478 --> 01:20:21.419
is nothing like dynamic.  Once 
you created a recipe and put 

01:20:21.420 --> 01:20:24.363
data in there, it's not going to
 change.  Nothing really 

01:20:24.364 --> 01:20:27.877
realtime about it.  Realtime 
Database can handle that but 

01:20:27.878 --> 01:20:33.132
what can you do is say, create a
 realtime chat associated with 

01:20:33.133 --> 01:20:36.452
each and every recipe.  So that 
everyone who logs in can talk 

01:20:36.453 --> 01:20:41.409
about it with their friends and 
with the person who gave the 

01:20:41.410 --> 01:20:45.280
recipe.  Your website and mobile
 app is much more interactable. 

01:20:45.281 --> 01:20:49.708
 Is that a word?  Interactive.  
I think that's a better word.

01:20:49.781 --> 01:20:54.750
Now of course you want people 
who are submitting resfees take 

01:20:54.751 --> 01:21:00.651
pictures of the recipe maybe at 
various stages so you want 

01:21:00.652 --> 01:21:06.964
people to upload photos.  
Firebase Storage scales massive 

01:21:06.965 --> 01:21:07.742
lyely and you will never worry 
about space again.  Now for the 

01:21:07.743 --> 01:21:10.204
website of things, if you have a
 mobile app, you generally don't

01:21:10.574 --> 01:21:14.346
 worry about the deployment.  It
 is deployed oat user device.  

01:21:14.347 --> 01:21:18.585
You need a way to get your 
static content out there.  You 

01:21:18.586 --> 01:21:25.432
have HTML and JavaScript and 
Firebase Hosting gives you a way

01:21:25.883 --> 01:21:30.824
 to deploy your static content 
over SSL so everything is SSL 

01:21:30.825 --> 01:21:32.842
protected.  Certificates are 
deployed automatically and you 

01:21:32.843 --> 01:21:34.843
don't have to worry about it.

01:21:39.250 --> 01:21:43.450
This is a simple command line to
 deploy as often as you want.  

01:21:39.250 --> 01:21:41.474
It's worth noting that if there 
are graphical assets you don't 

01:21:41.475 --> 01:21:45.793
want to package into your 
Android or iOS app, apply those 

01:21:45.794 --> 01:21:50.112
and then load those as needed so
 that can shrink down your 

01:21:50.113 --> 01:21:56.708
original APK size if you're an 
ab Droid developer or the iOS 

01:21:56.709 --> 01:22:01.748
can be drunk down.  Now this is 
important -- shrunk down:  So 

01:22:01.749 --> 01:22:06.385
having a small initial app is 
important.  Deploy the rest of 

01:22:06.386 --> 01:22:10.098
your content on hosting and load
 it on demand.  Get people 

01:22:10.099 --> 01:22:15.817
logged in and authentication can
 do that.  What advantage does 

01:22:15.818 --> 01:22:17.423
authentication provide?  
Essentially encouraging people 

01:22:17.424 --> 01:22:21.651
to join in and be social.  Say 
log in.  Have an identity.  Have

01:22:21.834 --> 01:22:27.105
 a space within your app.  Let 
them interact with each other.  

01:22:27.106 --> 01:22:30.982
Now do things user-to-user 
communications.  Store specific 

01:22:30.983 --> 01:22:34.897
data per user.  So if users want
 to favorite recipes, store that

01:22:35.160 --> 01:22:39.173
 within their space.  If users 
want to follow other recipe 

01:22:39.174 --> 01:22:42.291
creators, they can do that.  
Store information about them and

01:22:42.464 --> 01:22:45.842
 help them navigate your app 
better.

01:22:45.843 --> 01:22:49.468
Now I was trying to figure out 
how to use Firebase Cloud 

01:22:49.469 --> 01:22:52.105
messaging?
It's an event-driven messaging 

01:22:52.106 --> 01:22:55.626
system but how might you use it 
in an app like thissan?

01:22:55.627 --> 01:22:58.965
Unsung feature in Cloud 
Messaging.  When you send a 

01:22:58.966 --> 01:23:01.908
Cloud message it doesn't have to
 contain text of a message you 

01:23:01.909 --> 01:23:05.786
want someone to read.  You can 
use it to ping the app to say 

01:23:05.787 --> 01:23:09.710
hey, there is new content.  You 
should load this and cash it so 

01:23:09.711 --> 01:23:12.298
when the user opens it up they 
have fresh content.  So for 

01:23:12.299 --> 01:23:15.494
example if you have a user 
logged in and they have 

01:23:15.495 --> 01:23:18.635
favorited some other users, they
 want to know when they updated 

01:23:18.636 --> 01:23:25.238
new recipes, ping the app.  The 
users can Kay I have new 

01:23:25.239 --> 01:23:29.832
download it.  And the recipes 
are all there.  This makes for a

01:23:30.294 --> 01:23:32.894
 very pleasant and more natural 
experience than opening up and 

01:23:32.895 --> 01:23:38.236
waiting for the content that 
they were hoping to find.

01:23:38.237 --> 01:23:41.965
Now again you can usury moat 
config for more things than just

01:23:42.063 --> 01:23:45.472
 AB testing.  So let's say you 
have or doing a massive redesign

01:23:45.682 --> 01:23:49.050
 of your website.  So everything
 is changed, the look and feel 

01:23:49.051 --> 01:23:52.153
and colors and the whole 
experience and you want to log 

01:23:52.154 --> 01:23:57.708
all at the same time for all 
your users at say during like a 

01:23:57.709 --> 01:23:59.861
television event or some 
marketing push.  It's important 

01:23:59.862 --> 01:24:04.104
it is all available right at the
 same time.  In the past, you 

01:24:04.105 --> 01:24:08.251
might have had to publish a new 
app to the App Store and wait 

01:24:08.252 --> 01:24:11.476
for approval.  Same thing with 
the play store T doesn't give 

01:24:11.477 --> 01:24:15.418
you guarantee when that app hits
 the market.  It's hard to make 

01:24:15.419 --> 01:24:17.939
sure that everyone gets the 
experience at the same time.  

01:24:17.940 --> 01:24:21.760
With Remote Config, what can you
 do is essentially create a 

01:24:21.761 --> 01:24:26.054
switch in the dash board to say,
 I want to switch from the old 

01:24:26.055 --> 01:24:28.128
experience to the new experience
 immediately so be sure that 

01:24:28.129 --> 01:24:31.255
everyone who is using your app 
gets the experience you want at 

01:24:31.256 --> 01:24:35.176
the time that you want it.  And 
as a side benefit, if something 

01:24:35.177 --> 01:24:38.800
goes wrong with that new 
experience, say it is called the

01:24:38.948 --> 01:24:42.301
 app to crash, turn it off.  
Revert features having problems 

01:24:42.302 --> 01:24:49.960
with the flip of a switch.
Now, for apps like iChef'd that 

01:24:49.961 --> 01:24:53.028
has content on the web and on 
mobile apps and they are 

01:24:53.029 --> 01:24:56.424
parallel.  Generally looking at 
the same time on iOS, Android 

01:24:56.425 --> 01:25:00.272
and the web, use App Indexing.  
The advantage there is that 

01:25:00.273 --> 01:25:02.968
Google will naturally scan all 
your web content and index it 

01:25:02.969 --> 01:25:06.973
and make it easily searchable.  
But you can use app indexing to 

01:25:06.974 --> 01:25:10.602
get content in your mobile apps 
index as well.  So all you have 

01:25:10.603 --> 01:25:13.965
to do is write a few simple 
rules to say how your web 

01:25:13.966 --> 01:25:17.885
content Maps into your mobile 
content and App Indexing will 

01:25:17.886 --> 01:25:22.277
let users do searchings and link
 in your mobile app into the 

01:25:22.278 --> 01:25:24.989
recipe that is they are looking 
for.  So if they are on

01:25:29.577 --> 01:25:31.108
 Android, go to the Android app 
and iOS, web to web.  It makes 

01:25:31.109 --> 01:25:35.435
for a seamless experience.  And 
also a benefit of knowing that 

01:25:35.436 --> 01:25:38.934
usage within your app promotes 
rankings within Google.  So if 

01:25:38.935 --> 01:25:43.137
you have active mobile users, 
you can be sure that activity 

01:25:43.138 --> 01:25:47.964
will help the ranking within 
your overall search results.

01:25:48.420 --> 01:25:55.121
Now with Dynamic Links, one 
thing you can do is link between

01:25:56.180 --> 01:25:59.291
 remote version and web version.
  It's easy to draw traffic to 

01:25:59.292 --> 01:26:02.608
your website.  What if you want 
to push people into the mobile 

01:26:02.609 --> 01:26:05.826
app?  Say if someone is looking 
at a recipe in the mobile view, 

01:26:05.827 --> 01:26:09.844
and you want someone or want 
them to go into your iOS app, 

01:26:09.845 --> 01:26:12.563
provide a link on the web page, 
say view this on mobile.  When 

01:26:12.564 --> 01:26:15.050
they do that, they can get 
installed and get right to the 

01:26:15.051 --> 01:26:18.919
content anding  you Drive them 
to a more pleasant experience 

01:26:18.920 --> 01:26:28.770
for their device.
My Slides are not advancing.

01:26:29.159 --> 01:26:38.832
  There we go.  So again, with 
invites you want happy users to 

01:26:38.833 --> 01:26:41.546
refer happy users.  Another 
benefit.  So with invite since 

01:26:41.547 --> 01:26:45.275
they are built on top of Dynamic
 Links, what can you do is embed

01:26:45.885 --> 01:26:50.486
 context in your invites to say 
give people a referral bonus to 

01:26:50.487 --> 01:26:55.484
say, invite a friend and that 
friend then gets a 5 dollars off

01:26:55.685 --> 01:26:58.393
 their grocery bill.
So if you have like a deal with 

01:26:58.394 --> 01:27:02.967
a grocery store you could say 
for everyone who invites one of 

01:27:02.968 --> 01:27:05.879
their friends we'll give them a 
coupon and that makes for a 

01:27:05.880 --> 01:27:14.103
great first time experience and 
greatly increases retention.  

01:27:14.104 --> 01:27:16.650
There we go.
So again with AdWords just like 

01:27:16.651 --> 01:27:19.254
before, you probably want to 
hook into search results or 

01:27:19.255 --> 01:27:22.468
things like recipe book and 
dinner ideas.  The Google 

01:27:22.469 --> 01:27:26.995
AdWords integration will 
definitely help Drive traffic to

01:27:26.996 --> 01:27:27.736
 your mobile app and of course 
you want to monetize the thing. 

01:27:27.737 --> 01:27:30.675
 You don't want use tours use 
this free forever.  You want 

01:27:30.676 --> 01:27:34.004
them to use it if free but you 
need to get paid at the end of 

01:27:34.005 --> 01:27:38.702
the day.  So add by Google is 
another integration.  It's the 

01:27:38.703 --> 01:27:42.415
same AdMob you already know 
monetizing great apps for years 

01:27:42.416 --> 01:27:46.034
and now it works great with 
Firebase.  One new feature in 

01:27:46.035 --> 01:27:48.819
AdMob you should know about.  
It's called native express.  

01:27:48.820 --> 01:27:50.820
What

01:27:56.791 --> 01:28:01.057
 it let's you do is include ads 
in your app that match the look 

01:27:56.791 --> 01:28:00.791
and feel of your app.  So this 
is great for putting adds in 

01:27:56.791 --> 01:28:00.021
scrolling list.  So if you added
 a scrolling list that looks 

01:28:00.022 --> 01:28:03.695
like the other items in the 
scrolling list, users are more 

01:28:03.696 --> 01:28:05.696
likely

01:28:07.425 --> 01:28:11.558
 to notice it and click on it 
and should Drive more revenue to

01:28:07.425 --> 01:28:09.616
 your app.
This iset fromy exciting.  

01:28:09.617 --> 01:28:11.598
Developers have been asking for 
this a long time.  It's great 

01:28:11.599 --> 01:28:16.438
for games.  Games have their own
 styling.  If you can pult ads 

01:28:16.439 --> 01:28:20.363
in your game, it creates for a 
less jarring experience.  And of

01:28:20.963 --> 01:28:23.237
 course, Analytics again, the 
thing that ties it all together,

01:28:23.511 --> 01:28:27.011
 measure the efficacy of your 
invitations and Dynamic Links 

01:28:27.012 --> 01:28:30.839
and ad words and eventually we 
hope that Analytics have even 

01:28:30.840 --> 01:28:34.664
better and tighter integration. 
 So, I highly recommend you look

01:28:35.116 --> 01:28:39.469
 at Analytics.  You can over at 
the Firebase tent, we have demos

01:28:39.612 --> 01:28:43.656
 and you can tauck to people who
 are very knowledgeable about 

01:28:43.657 --> 01:28:46.757
this.
Now I have gone over 13 

01:28:46.758 --> 01:28:49.563
components.  There are two left.
  My counting ask very good.  I 

01:28:49.564 --> 01:28:54.352
took math in school.  So what is
 missing here?  Well, the 13 

01:28:54.353 --> 01:28:57.535
components I talked about are 
great for adding features and

01:29:00.790 --> 01:29:02.463
 functionality.  Two more things
 are left.  What we can do with 

01:29:02.464 --> 01:29:06.571
Firebase is Test Lab.  We have 
Firebase Test Lab for Android.  

01:29:06.572 --> 01:29:10.861
You can test your app on devices
 hosted in the Cloud.  So with 

01:29:10.862 --> 01:29:14.922
Firebase, we own the devices.  
Google owns and manages them and

01:29:14.923 --> 01:29:16.923
 you can test on them.
This is great because if you 

01:29:16.924 --> 01:29:19.726
ever done Android development, 
you know you can end up with 

01:29:19.727 --> 01:29:22.680
stacks of mobile devices on your
 desk.  And I had this problem 

01:29:22.681 --> 01:29:26.945
too where I had a cabinet full 
of devices and the team I was 

01:29:26.946 --> 01:29:30.708
working with would grab devices 
and get lost.  Never find the 

01:29:30.709 --> 01:29:34.580
thing you wanted.  You had 
tangled cables on your desk if 

01:29:34.581 --> 01:29:37.014
you were testing on different 
devices.  A terrible situation. 

01:29:37.336 --> 01:29:41.022
 You should abandon that and do 
testing in the Cloud.  So we 

01:29:41.023 --> 01:29:45.658
have phones, small tablets, 
large tablets across a variety 

01:29:45.659 --> 01:29:49.086
of OEMs.  They are always ready 
and waiting if are you to do 

01:29:49.087 --> 01:29:53.422
your test.  So if you're an 
Android developer, you believey 

01:29:53.423 --> 01:29:57.037
know you can write -- probably 
know you can write 

01:29:57.038 --> 01:29:59.283
instrumentation test and run 
those on your desktop.  It's not

01:30:00.063 --> 01:30:04.288
 scalable.  You can deploy them 
to Firebase Test Lab and we'll 

01:30:04.289 --> 01:30:07.804
run those instrumentation tests 
against the set of devices you 

01:30:07.805 --> 01:30:11.409
selected and we run them 
concurrently.  You don't run 

01:30:11.410 --> 01:30:15.449
them in order.  You get very 
fast comprehensive results 

01:30:15.450 --> 01:30:18.574
immediately.  If you're not into
 writing unit tests and who is? 

01:30:18.961 --> 01:30:22.997
 Writing test isn't fun.  You 
can also have an automated test 

01:30:22.998 --> 01:30:29.110
like crawl your app for you.  We
 dhal a robo test.  This robot 

01:30:29.111 --> 01:30:32.837
here no robot on your app.
This is like an artist 

01:30:32.838 --> 01:30:35.616
imagination what have a robo 
test is like.  But what happens 

01:30:35.617 --> 01:30:40.303
is, we have software that looks 
at the UI wing nits your app and

01:30:41.362 --> 01:30:45.797
 pushings buttons -- widgets -- 
selects drop downs and goes 

01:30:45.798 --> 01:30:48.970
through menu items and if there 
is a crash, you will know about 

01:30:48.971 --> 01:30:52.728
it.  And it takes screen shots 
along the way so you know that 

01:30:52.729 --> 01:30:57.179
everything is rendering properly
 on the devices you decideed.  

01:30:57.180 --> 01:31:01.342
Now this is a device rack.  We 
had a photographer come in and 

01:31:01.343 --> 01:31:08.392
make nice foesose.  This is like
 a serber farm.  So I really 

01:31:08.393 --> 01:31:11.808
want to visit the device lab 
some day.  I haven't been there 

01:31:11.809 --> 01:31:15.631
yet.  We have one on Google 
campus and one in Atlanta.  I 

01:31:15.632 --> 01:31:20.247
think this is fascinating.  We 
have a lighter version in the 

01:31:20.248 --> 01:31:22.926
Firebase tent so if you want to 
see what it looks like, we have 

01:31:22.927 --> 01:31:29.612
a demo for you to see.  Lastly, 
there is also a crash reporting 

01:31:29.613 --> 01:31:34.410
component.  So, you can do all 
the testing you want on devices 

01:31:34.411 --> 01:31:37.013
in the Cloud but users will find
 a problem.  So use Firebase 

01:31:37.014 --> 01:31:42.568
crash reporting to observe and 
triage those crashes so grouped 

01:31:42.569 --> 01:31:45.839
by type.  You can see similar 
crashes and order them by 

01:31:45.840 --> 01:31:48.695
severity so you know which ones 
to tackle first.  This should 

01:31:48.696 --> 01:31:52.370
help your overall app quality.  
Now the way I see Test Lab and 

01:31:52.371 --> 01:31:55.020
crash reporting working 
together, is that during 

01:31:55.021 --> 01:31:57.720
development, you will make use 
of Test Lab in the cloudy to 

01:31:57.721 --> 01:32:01.343
make sure that all of your tests
 are working as planned.  Then 

01:32:01.344 --> 01:32:07.403
for Android, when you publish to
 an alpha or beta channel, 

01:32:07.404 --> 01:32:09.762
another test a prerelease 
report.  This is a robo test.

01:32:10.183 --> 01:32:14.241
This will give you a quick check
 to see is my app launching and 

01:32:14.242 --> 01:32:18.473
working okay on a variety of 
devices?  Then of course your 

01:32:18.474 --> 01:32:21.691
alpha and beta users experience 
crashes and that will report 

01:32:21.692 --> 01:32:24.654
back to the dashboard and use 
that to create new tests to make

01:32:24.920 --> 01:32:27.670
 sure that you fix those 
properly and when you promote 

01:32:27.671 --> 01:32:31.992
your app from alpha or beta to 
production, you then have actual

01:32:32.216 --> 01:32:34.803
 live production grade crash 
reporting.  So this is a great 

01:32:34.804 --> 01:32:39.199
way to ensure app quality 
throughout your development life

01:32:39.200 --> 01:32:41.387
 cycle.
So that is all 15 components.  

01:32:41.388 --> 01:32:44.875
Again, you can take as many of 
these or as few of these as you 

01:32:44.876 --> 01:32:47.667
want.  I'm a big fan of using as
 many as possible especially for

01:32:48.182 --> 01:32:51.202
 new apps.  Now I understand 
that established apps may 

01:32:51.203 --> 01:32:53.639
already have solutions for some 
of these in place and that's 

01:32:53.640 --> 01:32:57.616
fine.  Keep using them.  But if 
you want to replace anything, or

01:32:57.701 --> 01:33:00.523
 if you want to create a new app
 on top of Firebase that is 

01:33:00.524 --> 01:33:03.338
great as well.  I have been very
 excited to talk to developers 

01:33:03.339 --> 01:33:07.021
who are going to build things on
 top of Firebase.  Now one of 

01:33:07.022 --> 01:33:11.703
our early access partners Malang
 Studio had very specific things

01:33:11.704 --> 01:33:14.849
 on say about it.  So here is 
what they did.  They built three

01:33:17.819 --> 01:33:24.555
 apps.    It helps couples plan 
a anniversary and me.time and a 

01:33:24.556 --> 01:33:27.632
School of Rock.  Some of these I
 believe are not in languages 

01:33:27.633 --> 01:33:32.281
that are English so beware that 
if you download one of these it 

01:33:32.282 --> 01:33:35.239
may not make sense but you can 
see Firebase in action.  Now 

01:33:35.240 --> 01:33:38.289
what they did is they showed us 
this chart of how they used 

01:33:38.290 --> 01:33:40.607
Firebase and you can see 
across-the-board.  They are 

01:33:40.608 --> 01:33:45.127
making heavy use of Firebase and
 they loved it.  So more solid 

01:33:45.128 --> 01:33:48.562
icons are components they 
integrated.  The faded out ones 

01:33:48.563 --> 01:33:50.875
are the ones they are planning 
in the future.  They didn't goat

01:33:51.073 --> 01:33:54.194
 it yet.  They were excited to 
tell us about how they were able

01:33:54.457 --> 01:33:59.639
 to use Firebase they gave us 
some quotes.  The CTO of Malang 

01:33:59.640 --> 01:34:01.640
Studio said:

01:34:05.922 --> 01:34:07.922
[ Reading ]

01:34:16.244 --> 01:34:19.618
Now I love in LEGO brick 
analogy.  This is how we 

01:34:19.619 --> 01:34:23.804
intended Firebase to work.  We 
give you these components and 

01:34:23.805 --> 01:34:27.478
created infrastructure you don't
 have to create.  You can focus 

01:34:27.479 --> 01:34:33.626
on user's experience.  And their
 CEO went on to say:

01:34:33.716 --> 01:34:35.720
[ Reading ]

01:34:45.307 --> 01:34:50.589
We are saying here that as an 
app developer, mew you might 

01:34:50.590 --> 01:34:54.292
have to assemble something from 
a bunch of other components but 

01:34:54.293 --> 01:34:57.924
with Firebase you get one thing 
that gives you all the core oral

01:34:58.077 --> 01:35:00.583
 of your infrastructure you 
need.  Once you have that in 

01:35:00.584 --> 01:35:04.604
place, you don't have to worry 
about server farms or scaling up

01:35:04.826 --> 01:35:08.172
 or creating revenue or drawing 
users into the app.  All of that

01:35:08.347 --> 01:35:12.360
 is there.  You can focus on the
 app and your users and the 

01:35:12.361 --> 01:35:16.764
experience they want to have.
So that is all I have.  If you 

01:35:16.765 --> 01:35:20.006
want to learn more about 
Firebase components, there is 

01:35:20.007 --> 01:35:23.806
another talk here at 3 p.m., 
Todd will talk about how the 

01:35:23.807 --> 01:35:29.642
individual clusters of 
components work well together.  

01:35:29.643 --> 01:35:32.463
I like this talk.  I like the 
idea that components are like 

01:35:32.464 --> 01:35:33.983
LEGO bricks.  He will provide 
that experience.  If you have 

01:35:33.984 --> 01:35:39.797
any questions about Firebase, 
visit any one of these URLs.  If

01:35:39.798 --> 01:35:44.187
 you want to get deeper into it,
 there is a code lab called 

01:35:44.188 --> 01:35:48.614
FriendlyChat.  You will actually
 walk through the integration 

01:35:48.615 --> 01:35:52.485
like 7 or 8 components and see 
how they work and then 

01:35:52.486 --> 01:35:55.547
FriendlyPix, a live app which 
will demonstrate a lot of 

01:35:55.548 --> 01:35:57.951
Firebase features.  I'm really 
excited about Firebase and I 

01:35:57.952 --> 01:36:02.349
can't wait to see what you 
build.  Thank you very much.

01:36:02.485 --> 01:36:04.485
[ Applause ]

01:36:07.432 --> 01:36:11.635
Now we have a few minutes left. 
 I'll take some questions.  I 

01:36:11.636 --> 01:36:15.380
think there is microphones in 
each aisle.  So if you have 

01:36:15.381 --> 01:36:25.208
anything, please let me know.
&gt;&gt; AUDIENCE MEMBER: Hi.  Do you

01:36:25.495 --> 01:36:30.853
 plan at some point to integrate
 phone number base log in?  

01:36:30.854 --> 01:36:35.478
Because you know, we talk about 
mobile and e-mail and password. 

01:36:35.479 --> 01:36:41.667
 It's adapted and it's kind of 
useful to have like a SMS-base. 

01:36:41.668 --> 01:36:45.691
 So are you planning to 
integrate into the future?  I 

01:36:45.692 --> 01:36:52.012
mean understand with custom log 
in but if it is by Google that 

01:36:52.013 --> 01:36:54.962
would be better.
&gt;&gt; Dug Doug so looking for SMS 

01:36:54.963 --> 01:36:56.701
or like phone number based 
authentication?

01:36:56.702 --> 01:37:00.484
&gt;&gt; AUDIENCE MEMBER: Yes.
&gt;&gt; DOUG: I don't know of any 

01:37:00.485 --> 01:37:04.158
plans for that but I know that 
is something hay lot of people 

01:37:04.159 --> 01:37:06.602
want.  I think if you join us at
 the Firebase tented, there are 

01:37:06.603 --> 01:37:10.075
people who are more 
knowledgeable about 

01:37:10.076 --> 01:37:12.076
authentications.  It doesn't 
exist

01:37:15.894 --> 01:37:20.160
 today.  Stay tuned and find out
 what the we have in the future.

01:37:15.894 --> 01:37:17.638
&gt;&gt; AUDIENCE MEMBER: Thank you.
&gt;&gt; DOUG: Anyone else?

01:37:17.639 --> 01:37:19.639
&gt;&gt; AUDIENCE MEMBER: Hello.  Is 
there

02:11:13.888 --> 02:11:20.550
 if it looks right, it is right.
  So ma what they are seeing is 

02:11:20.551 --> 02:11:24.048
the UI in terms of what the user
 believes.  The trick we use is 

02:11:24.049 --> 02:11:27.825
that we only create and layout 
the views the user can see right

02:11:29.252 --> 02:11:34.878
 now.  And as the user scrolls, 
we continue to layute more 

02:11:34.879 --> 02:11:36.495
items.  The image you should 
have in your heads right now is 

02:11:36.496 --> 02:11:44.099
the bit from Wallace and grommet
 where you're quickly laying the

02:11:44.444 --> 02:11:47.362
 track in front of the moving 
train.  And it uses adapter 

02:11:47.363 --> 02:11:51.221
components.  This is a component
 provided by the application 

02:11:51.222 --> 02:11:56.421
itself.  And it is used to 
create and populate the item of 

02:11:56.422 --> 02:11:57.799
views on demand.  You got get 
view method in the adapter used 

02:11:57.800 --> 02:12:00.939
to query the adapter for a 
particular view to show a data 

02:12:00.940 --> 02:12:06.691
item that corresponds to a 
particular position in the list.

02:12:07.033 --> 02:12:09.824
  And the extra trick we do is 
pass in a special convert view 

02:12:09.825 --> 02:12:13.534
that is guaranteed to be of the 
same item type that the adapter 

02:12:13.535 --> 02:12:16.642
believes that new position to be
 so you can reuse the same view 

02:12:16.643 --> 02:12:20.474
and you don't have to pay the 
cost of inflation again.

02:12:20.728 --> 02:12:24.713
And over time, we continue to 
add more and more features to 

02:12:24.714 --> 02:12:27.013
ListView because there were 
things that people needed in 

02:12:27.014 --> 02:12:31.682
their apps.  And this question 
kind of came up a lot.  So, 

02:12:31.683 --> 02:12:35.678
ListView grew feature after 
feature and you can go back and 

02:12:35.679 --> 02:12:37.679
watch this talk from I/O 2010

02:12:40.425 --> 02:12:42.337
 if you want to see a few of 
them.

02:12:42.338 --> 02:12:47.070
&gt;&gt; Really nice.  You should 
watch it.  I enjoyed it.

02:12:47.071 --> 02:12:50.214
&gt;&gt; If you want to see our 
classic Us and some of that talk

02:12:50.312 --> 02:12:56.909
 as well.  Yes.  As we kept 
adding features, we hit a 

02:12:56.910 --> 02:13:01.270
complexity overdraft point the. 
 We had so many features that 

02:13:01.271 --> 02:13:05.658
kind sorted interacted with each
 other but all a little bit one 

02:13:05.659 --> 02:13:07.860
off and all of these long 
features

02:13:11.011 --> 02:13:11.612
 that led to a lot of very 
strange interactions and what 

02:13:11.613 --> 02:13:15.653
that meant in practice is that 
everybody wrote their apps such 

02:13:15.654 --> 02:13:19.660
that things worked how they want
 today to but a lot of things 

02:13:19.661 --> 02:13:23.172
they were the result of 
undefined behavior in ListView 

02:13:23.173 --> 02:13:27.032
implementation itself.  And once
 enough apps start doing that 

02:13:27.033 --> 02:13:32.454
that is defacto API we have to 
support.  Any small change we 

02:13:32.455 --> 02:13:36.800
have to do to improve for core 
cases ends up breaking some apps

02:13:37.089 --> 02:13:39.595
 that they want to use some 
place else.

02:13:40.145 --> 02:13:44.875
We also have a lot of duplicated
 functionality in ListView.  

02:13:44.876 --> 02:13:49.274
Like ListView selections or view
 focus.  Which ones do we use?  

02:13:49.275 --> 02:13:54.761
The view hierarchy already knows
 how to hand keyboard focus but 

02:13:54.762 --> 02:13:58.785
ListView had its own idea of 
this in terms of current 

02:13:58.786 --> 02:14:03.368
selection, selector drawable 
drawn behind or over the views 

02:14:03.369 --> 02:14:07.364
depending on the config Ages you
 set up and -- configurations.  

02:14:07.365 --> 02:14:11.107
And this led to overlap and 
meant that if you start using 

02:14:11.108 --> 02:14:14.238
more complex views in your 
ListView items, you have to 

02:14:14.239 --> 02:14:20.541
switch over to the set items can
 focus option that disables 

02:14:20.542 --> 02:14:24.172
ListView internal selection 
handling and lets you use the 

02:14:24.173 --> 02:14:28.976
focus handling instead.  
Similarly, we had the same issue

02:14:29.290 --> 02:14:33.410
 around item click listeners 
versus view click listeners and 

02:14:33.411 --> 02:14:36.728
general touch handling.  So 
ListView provided a very nice 

02:14:36.729 --> 02:14:40.936
convenience where you could set 
an item click listener on the 

02:14:40.937 --> 02:14:44.676
ListView itself and get clicks 
for anything that happens in 

02:14:44.677 --> 02:14:46.397
this list.  This makes sense for
 list that are uniform where you

02:14:46.398 --> 02:14:49.368
 have a list of items and you 
just want to pick something from

02:14:49.717 --> 02:14:55.022
 it.  Like a pop up menus we 
have from the overflow menu of 

02:14:55.023 --> 02:14:58.336
your apps today.  But, 
ultimately, you can also just go

02:14:58.474 --> 02:15:01.764
 ahead and attach click 
listeners to these views 

02:15:01.765 --> 02:15:06.072
themselves and which one was 
going to handle the events was 

02:15:06.073 --> 02:15:09.495
sometimes not always clear or 
intuitive.  So people ask us a 

02:15:09.496 --> 02:15:13.483
lot of times, which one do I 
use?  The answer always ended up

02:15:13.906 --> 02:15:18.170
 being, it depends.  How complex
 are your list items?  And any 

02:15:18.171 --> 02:15:21.101
time you have to very a lot of 
types of clarifying questions 

02:15:21.102 --> 02:15:25.192
about like, okay, what are you 
trying to do?  Then that really 

02:15:25.193 --> 02:15:27.764
kind of complicates the 
developer story.

02:15:27.979 --> 02:15:33.318
But really the big thing that 
kind of kicked off the whole 

02:15:33.319 --> 02:15:37.659
RecyclerView effort was that 
ListView animations are really, 

02:15:37.660 --> 02:15:40.730
really difficult.  And the core 
problem is that adapters don't 

02:15:40.731 --> 02:15:42.889
tell us enough to do them smart.
  So,

02:15:46.733 --> 02:15:49.794
 when you change an adapter, you
 say notify dataset change and 

02:15:49.795 --> 02:15:53.064
the assumption is, anything 
could have changed.  We are not 

02:15:53.065 --> 02:15:57.338
entirely sure what and we are 
just going to go ahead and 

02:15:57.339 --> 02:16:00.719
rebind the items visible and go 
from there.  And over time, we 

02:16:00.720 --> 02:16:04.964
had a few prototypes, some of 
them done by members of the 

02:16:04.965 --> 02:16:08.067
team.  Some of them done by 
members of the community.  All 

02:16:08.068 --> 02:16:12.226
to try to show items animating 
in and out as the dataset 

02:16:12.227 --> 02:16:14.227
changes and do

02:16:15.671 --> 02:16:16.959
 so in a way that is intuitive 
but all individual really major 

02:16:16.960 --> 02:16:21.030
limitations.  Most of these had 
to do with again, internal 

02:16:21.031 --> 02:16:24.141
implementation and details of 
ListView that absent come to 

02:16:24.142 --> 02:16:27.862
rely O we couldn't fix these 
things to make them possible.

02:16:27.951 --> 02:16:35.199
So, actually just end up making 
this face in ListView.

02:16:35.200 --> 02:16:39.032
&gt;&gt; YIGIT: Look at the regret in 
his face like I'm not sure I 

02:16:39.033 --> 02:16:46.310
should do this.  Like I'm I'm 
going to regret this.

02:16:46.311 --> 02:16:54.663
&gt;&gt; Ad he wear this is face a 
lot.  And this is a duplicated 

02:16:54.664 --> 02:17:00.442
functionality.
&gt;&gt; YIGIT: Like the Slides.

02:17:00.443 --> 02:17:03.429
&gt;&gt; ADAM: So as we moved on, 
people started to use much, much

02:17:03.685 --> 02:17:06.657
 more complex layout in their 
ListView items.  We went from 

02:17:06.658 --> 02:17:09.773
something like that very simple 
setting screen in gingerbread to

02:17:10.452 --> 02:17:14.756
 suddenly people showing items 
from a full social stream with 

02:17:14.757 --> 02:17:20.677
many different components and 
points of interaction.  So, the 

02:17:20.678 --> 02:17:23.287
simple grids and list we 
provided with lis view and grid 

02:17:23.288 --> 02:17:26.291
view weren't enough to handle 
these use cases appropriately.  

02:17:26.292 --> 02:17:30.822
People started wanting to create
 these sorts of staggered grids,

02:17:31.882 --> 02:17:34.444
 responsive layouts and so 
forth.  And really if you wanted

02:17:34.823 --> 02:17:38.363
 to change these types of 
layouts, you were rewriting a 

02:17:38.364 --> 02:17:43.955
lot of core code thatless view 
used to do this adapter base 

02:17:43.956 --> 02:17:48.088
recycling.  So if we have a do 
over, what would we change?  One

02:17:48.089 --> 02:17:51.376
 of the things we wanted to do 
was to elevate the best 

02:17:51.377 --> 02:17:55.405
practices of working with 
ListView to first class API.  We

02:17:55.663 --> 02:18:00.194
 had a view holder pattern that 
we went over in the world of 

02:18:00.195 --> 02:18:04.668
ListView talk linked earlier in 
the talk here, and the nice 

02:18:04.669 --> 02:18:08.393
thing about the view holder 
pattern that existed for 

02:18:08.394 --> 02:18:12.237
ListView, it gave one point 
where you could collect a bunch 

02:18:12.238 --> 02:18:14.835
of attributes about a 
RecycledView you were going to 

02:18:14.836 --> 02:18:19.012
work with and have that single 
point of access.  Cache a lot of

02:18:19.213 --> 02:18:24.914
 these by ID calls you make to 
inflated view sub hierarchy and 

02:18:24.915 --> 02:18:29.446
on older devices that made a big
 difference and as you wereet 

02:18:29.447 --> 02:18:34.732
craking more and more complex 
item layouts it mattered even 

02:18:34.733 --> 02:18:39.112
more.  We thought let's go ahead
 and make that part of the core 

02:18:39.113 --> 02:18:41.989
API.  Instead of having this be 
a best practice that everybody 

02:18:41.990 --> 02:18:44.853
has to read blog posts to figure
 out, let's make sure this is 

02:18:44.854 --> 02:18:48.862
something that you see as soon 
as you read the documentation 

02:18:48.863 --> 02:18:52.281
when working with RecyclerView. 
 We wanted to separate view 

02:18:52.282 --> 02:18:55.968
creation and binding.  This was 
something that happened in the 

02:18:55.969 --> 02:18:59.839
cursure adapters that many have 
probably used if you work with 

02:18:59.840 --> 02:19:03.099
sequel databases or content 
providers as your backing data 

02:19:03.100 --> 02:19:05.100
source for your ListView 
adapters.

02:19:05.217 --> 02:19:09.046
We separated out on create 
versus on bind step in those.  

02:19:09.047 --> 02:19:12.813
But if you're just writing a raw
 ListView adapter yourself then 

02:19:12.814 --> 02:19:16.275
this was essentially a question 
of the very first couple of 

02:19:16.276 --> 02:19:21.413
lines of code in your get view 
method where if convert view 

02:19:21.414 --> 02:19:23.848
equals null then fall through 
and do the binding there.  And 

02:19:23.849 --> 02:19:27.358
this was one of the things that 
was fairly easy to forget to do.

02:19:27.446 --> 02:19:32.923
  If you forget do it, then that
 means you lose out on this 

02:19:32.924 --> 02:19:36.072
recycling mechanic that ListView
 gave you to boost your 

02:19:36.073 --> 02:19:38.480
performance.  Sometimes it 
wasn't really clear why this was

02:19:38.481 --> 02:19:43.890
 happening from the outside.
And next we really kind of 

02:19:43.891 --> 02:19:47.764
wanted to throw out a bunch of 
this selection handling that 

02:19:47.765 --> 02:19:51.907
really only made sense for these
 very simplified list and just 

02:19:51.908 --> 02:19:54.793
rely on the framework's normal 
focus and input

02:19:57.951 --> 02:20:01.464
 handling.  Because this was 
again just comes down to 

02:20:01.465 --> 02:20:04.313
simplicity of working with the 
rest of the framework and 

02:20:04.314 --> 02:20:06.583
reinforcing the consistency of 
working with the rest of the 

02:20:06.584 --> 02:20:09.631
view hierarchy.
And then selfishly, we also 

02:20:09.632 --> 02:20:12.809
wanted a little bit more easier 
maintenance on our end because I

02:20:13.054 --> 02:20:18.276
 don't know if any of you have 
taken a look at the interns in 

02:20:18.277 --> 02:20:20.277
AOSP, I'm pretty sure it could 
be used to

02:20:24.080 --> 02:20:24.687
 scare small children.  So we 
wanted to keep the core 

02:20:24.688 --> 02:20:27.601
universal.  So all of those 
things that were a total pain to

02:20:27.905 --> 02:20:31.022
 rewrite yourself if you tried 
to write your own recycling 

02:20:31.023 --> 02:20:34.238
container, we wanted to have a 
way to give that to developers 

02:20:34.239 --> 02:20:36.538
more or less Federal free in a 
canned form so they didn't have 

02:20:36.539 --> 02:20:40.658
to sort of rediscover all the 
things we had to do the hard 

02:20:40.659 --> 02:20:42.925
way.
And we wanted to make sure that 

02:20:42.926 --> 02:20:45.515
you could still implement all of
 these other long tail features 

02:20:45.516 --> 02:20:50.350
that ListView provided as API on
 ListView itself as other plug 

02:20:50.351 --> 02:20:53.313
ins that we could sort of share 
and mix-and-match to get the 

02:20:53.314 --> 02:20:58.669
experience that you wanted.
We needed smarter adapters too. 

02:20:58.978 --> 02:21:01.726
 Again, the problem with 
ListView adapters is you could 

02:21:01.727 --> 02:21:03.962
say notify dataset changed.  
Okay.

02:21:04.801 --> 02:21:07.861
What changed?  I don't know.  
And that was about all you knew.

02:21:07.952 --> 02:21:10.766
  And this makes animations 
really difficult.  We'll get to 

02:21:10.767 --> 02:21:15.805
that a little bit further on 
down the line.  So RecyclerView 

02:21:15.806 --> 02:21:18.968
adapters tell us what changed 
not just that something changed.

02:21:19.074 --> 02:21:22.149
  Now if you're working with a 
data source that doesn't provide

02:21:23.276 --> 02:21:27.754
 that sort of fine messaging, 
still use the old ListView 

02:21:27.755 --> 02:21:30.868
style, something changed, go 
forward it out.  We'll make a 

02:21:30.869 --> 02:21:34.121
best effort attempt at dealing 
with it but really if you have 

02:21:34.122 --> 02:21:36.674
any knowledge of what the 
specific changes in your dataset

02:21:37.083 --> 02:21:39.083
 are,

02:21:40.919 --> 02:21:41.564
 you can get a lot better 
results.

02:21:41.565 --> 02:21:45.100
So this also means that we can 
do more efficient recycling not 

02:21:45.101 --> 02:21:48.820
just animations.  If we know 
that only a particular item in 

02:21:48.821 --> 02:21:51.572
the adapter changed, then we 
don't have to rebind everything 

02:21:51.573 --> 02:21:55.453
that is on this screen.  We only
 have to rebind that one view 

02:21:55.454 --> 02:21:58.827
and this can safely a lot of 
time in the measurement and 

02:21:58.828 --> 02:22:02.491
layout phases of applying 
updates.

02:22:02.907 --> 02:22:08.354
  &gt;&gt; YIGIT: So, that was 
recycling.  So make mistakes we 

02:22:08.355 --> 02:22:11.515
learn from ListView now like 
okay, how do you write recycle 

02:22:11.516 --> 02:22:15.139
view not repeat the same 
mistakes?  And the major thing 

02:22:15.140 --> 02:22:20.603
you recycle view is we tried to 
make the architecture of recycle

02:22:20.750 --> 02:22:23.816
 view and we will go through the
 details of it.  I think it is 

02:22:23.817 --> 02:22:26.667
very important.  I believe most 
of you already use it.  It's 

02:22:26.668 --> 02:22:31.781
good to know who does what and 
which one you should use or 

02:22:31.782 --> 02:22:37.089
customize depending on use case.
  So we have recycle view the 

02:22:37.090 --> 02:22:44.971
main view.  Major components.  
LayoutManager and item and then 

02:22:44.972 --> 02:22:51.599
adapter.  So LayoutManagers most
 provide content yourself and a 

02:22:51.600 --> 02:22:55.645
good default one to write 
yourself so late manager 

02:22:55.646 --> 02:22:57.646
positions the wheels,

02:22:59.866 --> 02:23:00.918
 ItemAnimator animates them and 
then adapter provides the wheels

02:23:00.919 --> 02:23:04.960
 and recycle is the bootses.  So
 center allocation that 

02:23:04.961 --> 02:23:07.922
communicates with all these 
components make them work 

02:23:07.923 --> 02:23:12.118
together.  So we look at the 
layout manager.  It has linear

02:23:15.213 --> 02:23:18.607
 list.  It has recycle view.  It
 doesn't know or doesn't care 

02:23:18.608 --> 02:23:26.015
about how items are laid out.  
Or scrolling.  Recycle view 

02:23:26.016 --> 02:23:30.474
handles like the interactions 
with the finger but tells the 

02:23:30.475 --> 02:23:33.270
LayoutManager to scroll because 
the LayoutManager knows where 

02:23:33.271 --> 02:23:42.326
the views are.  Sore if your to 
focus reversal because the V 

02:23:42.327 --> 02:23:46.477
framer handles it.  But if 
you're focusing and need one 

02:23:46.478 --> 02:23:50.377
more item, it is the layout 
measure that brings it because 

02:23:50.378 --> 02:23:56.028
it didn't exist before.
Accessibility.  Recycle provides

02:23:56.290 --> 02:23:59.904
 basic information about those 
items but LayoutManager is the 

02:23:59.905 --> 02:24:08.218
one that knows the title or you 
could custom delegate to say 

02:24:08.219 --> 02:24:14.625
like focus on this or initial 
information that only you can 

02:24:14.626 --> 02:24:19.507
provide.  Rye cycler view 
delegate API for this.

02:24:19.508 --> 02:24:25.604
&gt;&gt; ADAM: So similar to ListView,
 RecyclerView still relies on 

02:24:25.605 --> 02:24:28.401
adapters.  RecyclerView 
adapter's responsibilities are 

02:24:28.402 --> 02:24:31.061
to create the view but also to 
create the view holder.  And the

02:24:31.217 --> 02:24:36.075
 view holder is what we really 
use as the tracking element for 

02:24:36.076 --> 02:24:38.980
recycling.  So, when you're 
binding an item, you don't just 

02:24:38.981 --> 02:24:43.559
bind to the view, you bind it to
 the whole view holder.  This is

02:24:43.719 --> 02:24:47.529
 something to use to tissue 
other information as well.  Of 

02:24:47.530 --> 02:24:51.863
course it's the adapter's 
responsibility to notify changes

02:24:52.240 --> 02:24:58.188
 that happen to the dataset or 
if the data is out of sync.

02:24:59.257 --> 02:25:03.774
So, in contrast to ListView 
where you can use this item 

02:25:03.775 --> 02:25:06.748
click listener type of model for
 things, the adapter is 

02:25:06.749 --> 02:25:10.124
responsible for configging the 
item interaction handling.  

02:25:10.125 --> 02:25:15.431
These are your click listeners, 
and touch listeners and so on.  

02:25:15.432 --> 02:25:18.597
Adapters also deal with your 
multiple view types and sort of 

02:25:18.598 --> 02:25:23.386
being able to keep track of the 
different ViewHolders that you 

02:25:23.387 --> 02:25:29.447
may be tracking.
&gt;&gt; YIGIT: In the ListView world 

02:25:29.448 --> 02:25:34.223
you need to give us how many 
wheel types you have verses in 

02:25:34.224 --> 02:25:38.729
RecyclerView they are unlimited.
  So I suggest just use our 

02:25:38.730 --> 02:25:43.252
layout as the main type.
&gt;&gt; ADAM: Right.  So your view 

02:25:43.253 --> 02:25:47.462
type IDs no longer need to be 
contiguous.  So as long as you 

02:25:47.463 --> 02:25:49.463
have any sort of unique 
identifier that you

02:25:51.987 --> 02:25:53.519
 can use to identify a view 
type, then go ahead and use it 

02:25:53.520 --> 02:25:56.601
and RecyclerView isn't going to 
care.  That means you can use 

02:25:56.602 --> 02:26:02.970
this handy trick of using layout
 resource ID itself and since 

02:26:02.971 --> 02:26:06.791
APT already gainer these ID will
 be unique, it makes a pretty 

02:26:06.792 --> 02:26:10.346
good stand in for that 
identifier.

02:26:10.827 --> 02:26:15.673
Went too fast there.  So the 
adapter also deals with things 

02:26:15.674 --> 02:26:19.653
like recycler recovery.  We have
 an on fail to recycle view 

02:26:19.654 --> 02:26:23.179
concept.  So why get something 
fail to repsyche toll view?  We 

02:26:23.180 --> 02:26:26.758
are trying to keep in mind that 
people are doing more and more 

02:26:26.759 --> 02:26:30.122
complex things with their UIs 
and in those cases you might 

02:26:30.123 --> 02:26:33.580
start making a lot of changes to
 your views that are very 

02:26:33.581 --> 02:26:37.276
difficult to reverse.  So, in 
those cases, where we know a 

02:26:37.277 --> 02:26:41.562
view has been left in an 
inconsistent state, then we can 

02:26:41.563 --> 02:26:44.642
communicate that back and forth 
to the adapter so the adapter is

02:26:44.778 --> 02:26:49.725
 able to recover from a case 
where a view has been messed 

02:26:49.726 --> 02:26:52.760
with kind of beyond the normal 
bounds of expectation.

02:26:52.966 --> 02:26:57.172
And again, we have the granular 
data change events as added to 

02:26:57.173 --> 02:27:06.638
sort of handle efficiency and 
performance.  Animations.  That

02:27:08.260 --> 02:27:11.470
 one.
&gt;&gt; YIGIT: So let's deep dive 

02:27:11.471 --> 02:27:16.330
into the holder.  Because 
everyone needs this and you 

02:27:16.331 --> 02:27:19.454
spend most of your time there.  
It is important to know the life

02:27:20.142 --> 02:27:23.469
 cycle of a view holder.  So we 
will go through it.  What 

02:27:23.470 --> 02:27:28.766
happens when you create it.  
What are the stages?  So while 

02:27:28.767 --> 02:27:34.238
the layout measure is 
calculating layout, it tells 

02:27:34.239 --> 02:27:37.752
RecyclerView, get in position 5.
  So it wants to get in that 

02:27:37.753 --> 02:27:41.221
position, recycle view checks 
the cache because if you already

02:27:42.037 --> 02:27:46.104
 have it in the cache, we will 
return it to the lie out 

02:27:46.105 --> 02:27:50.080
manager.  If not -- 
LayoutManager.  So if you didn't

02:27:52.117 --> 02:27:56.348
 have it, recycle view will ask 
adapter what is the type of this

02:27:56.864 --> 02:28:01.145
 field?  And adapter returns, 
double check the pool.  This 

02:28:01.146 --> 02:28:06.773
might be a shared pool like the 
RecyclerView.  Do we have a view

02:28:07.449 --> 02:28:10.630
 holder for this type?  If it 
says no, we tell adapter to 

02:28:10.631 --> 02:28:17.074
create one.  So this is when we 
create a view holder.  Or maybe 

02:28:17.075 --> 02:28:25.669
the pool returned the item and 
it will tell adapter bind this 

02:28:25.670 --> 02:28:29.956
position to this view holder and
 runs and give it back to the 

02:28:29.957 --> 02:28:36.118
layout manager.  Layout manager 
will edit lack to recycler and 

02:28:36.119 --> 02:28:40.796
tell that adapter this has been 
added to layout.  This is say 

02:28:40.797 --> 02:28:43.579
good hipt for your adapter to 
know that okay, users about to 

02:28:43.580 --> 02:28:49.301
see this field.
So other case where layout 

02:28:49.302 --> 02:28:54.559
measure say okay remove and 
recycle this view.  Okay I 

02:28:54.560 --> 02:28:59.140
remove this view let you know so
 if you have things inside that 

02:28:59.141 --> 02:29:05.812
view, you can on cache remove 
from memory.  And then we will 

02:29:05.813 --> 02:29:10.659
check, okay is this view level 
lit for this position?  If it 

02:29:10.660 --> 02:29:14.906
is, we will cache it.  The idea 
is that if the lab measure 

02:29:14.907 --> 02:29:17.556
aspect for that position again, 
we can give it without talking 

02:29:17.557 --> 02:29:19.557
to the

02:29:22.550 --> 02:29:23.221
 adapter.  This is again for 
performance reasons.  And the 

02:29:23.222 --> 02:29:26.985
cache -- I will tell that 
operator, we got rid of this 

02:29:26.986 --> 02:29:31.622
view now you know it will be 
used for that position so you 

02:29:31.623 --> 02:29:38.513
can even further memory cleanup.
&gt;&gt; ADAM: This is a important 

02:29:38.514 --> 02:29:43.318
step learned from ListView.  
Where ListView added this 

02:29:43.319 --> 02:29:46.412
RecycledView listener used to 
track when a view was no longer 

02:29:46.413 --> 02:29:49.977
in use and again because people 
create much, much more complex 

02:29:49.978 --> 02:29:55.144
UIs in these sorts of recycling 
contains ethis allows you to 

02:29:55.145 --> 02:29:59.472
take a step and say instead of 
leaves these built Maps attached

02:29:59.791 --> 02:30:03.005
 to views being held in a cache 
off screen, let's clean those 

02:30:03.006 --> 02:30:06.526
things up but still retain the 
core view structure so we can 

02:30:06.527 --> 02:30:10.706
rebind it later.
&gt;&gt; YIGIT: So if it is not well 

02:30:10.707 --> 02:30:16.237
lit, so say maybe the item has 
-- because adapter told us or 

02:30:16.238 --> 02:30:20.449
item was changed and the 
contents of the view doesn't 

02:30:20.450 --> 02:30:25.312
represent that position anymore.
  We send it to the pool and 

02:30:25.313 --> 02:30:29.750
tell adapter about it.  Another 
use case where LayoutManager 

02:30:29.751 --> 02:30:35.623
recall layout after some adapter
 changes and that doesn't use 

02:30:35.624 --> 02:30:42.159
some of the views.  So, all the 
views from one-5 let's say and 

02:30:42.160 --> 02:30:47.461
that makes -- only use 8 and 
other two are missing.  

02:30:47.462 --> 02:30:50.155
RecyclerView says we understand 
the LayoutManager doesn't want 

02:30:50.156 --> 02:30:55.969
these views anymore so but you 
may want to fade them out 

02:30:55.970 --> 02:31:01.941
instead of disappearing them 
instantly.  So for each 

02:31:01.942 --> 02:31:06.268
disappearing, it will make them 
children again and hide them 

02:31:06.269 --> 02:31:10.562
from the LayoutManager.  We will
 go into details later but the 

02:31:10.563 --> 02:31:15.815
list of children from the layout
 mother-in-law's perspective are

02:31:18.348 --> 02:31:21.953
 not -- from the LayoutManager's
 perspective are not the same.  

02:31:21.954 --> 02:31:28.596
So it will tell them to make 
children and it says okay, I can

02:31:28.785 --> 02:31:31.630
 do whatever you want then 
RecyclerView will remove them 

02:31:31.631 --> 02:31:36.862
and tell the adapter they are 
going away.  And then we will 

02:31:36.863 --> 02:31:39.976
recycle it.
So, how do we lose a view 

02:31:39.977 --> 02:31:42.716
holder?  This is very important 
because if you're losings view 

02:31:42.717 --> 02:31:50.305
holder you will hit problems.  
So same thing happened.  I want 

02:31:50.306 --> 02:31:52.306
to get rid

02:31:53.673 --> 02:31:55.410
 of this view.  RecyclerView is 
like no, okay I approximate ut 

02:31:55.411 --> 02:32:00.981
this into the pool.  And the 
pool -- this is what Adam 

02:32:00.982 --> 02:32:06.775
mentioned earlier.  If we have 
animate        animating 

02:32:06.776 --> 02:32:11.659
contents, you have a button 
doing animation.  That means if 

02:32:11.660 --> 02:32:17.617
a view is animating, we cannot 
use it for other view holder.  

02:32:17.618 --> 02:32:20.497
Imagine it phased out and the 
bind it to something else and 

02:32:20.498 --> 02:32:23.951
then it is faded out.  You want 
fresh views.

02:32:23.952 --> 02:32:27.441
&gt;&gt; ADAM: A few other cases to 
cause views to have a transient 

02:32:27.442 --> 02:32:29.524
state as well.
This is part of the framework 

02:32:29.525 --> 02:32:34.704
not just RecyclerView itself.  
So for example if you have a 

02:32:34.705 --> 02:32:37.893
edit text widget a piece of text
 the user entered and they 

02:32:37.894 --> 02:32:41.369
created a selection across 
several words but maybe not 

02:32:41.370 --> 02:32:44.684
others.  That is this complex 
interaction the user created we 

02:32:44.685 --> 02:32:46.792
didn't want to make the 
developer's responsibility I to 

02:32:46.793 --> 02:32:50.745
sort of track and restore that 
if that particular item is 

02:32:50.746 --> 02:32:54.973
rebound across other context.
&gt;&gt; YIGIT: So what will happen is

02:32:55.147 --> 02:33:03.447
 that now we cannot reue us that
 view and reare removing so we 

02:33:03.448 --> 02:33:07.638
give it a chance.  Hey, I could 
not recycle this view.  Can I 

02:33:07.639 --> 02:33:09.639
recycle?  Because most of the

02:33:12.128 --> 02:33:15.728
 time it is because of 
animations with selection, you 

02:33:12.128 --> 02:33:15.354
can recover from that state.  
The only problem is that we 

02:33:15.355 --> 02:33:22.376
cannot do it because we don't 
know what is going on.  So you 

02:33:22.377 --> 02:33:26.658
can add animations or clear 
selected state.  Or you can even

02:33:26.824 --> 02:33:32.010
 say do not -- I know I fixed 
this -- like recycle it.  I will

02:33:32.790 --> 02:33:38.913
 use it.  Or if the adapter does
 not provide this method, by 

02:33:38.914 --> 02:33:42.940
default, it returns false.  So 
we will have to destroy the view

02:33:44.563 --> 02:33:51.276
 holder.  So you don't want 
this.  The moral of the story is

02:33:52.764 --> 02:33:58.108
 if -- don't create animations. 
 We had the animator to do these

02:33:58.362 --> 02:34:03.203
 things properly.  So if you 
want to animate, and they 

02:34:03.204 --> 02:34:06.730
receive correct life cycle 
events so that we can recycle 

02:34:06.731 --> 02:34:10.800
and take care of recycling views
 animating.

02:34:10.801 --> 02:34:12.801
&gt;&gt; ADAM: You can forget about 
everything that just happened on

02:34:12.829 --> 02:34:16.470
 that slide before you as long 
as you implement the 

02:34:16.471 --> 02:34:19.225
ItemAnimator interface.  If 
you're doing it yourself, you're

02:34:19.752 --> 02:34:22.363
 on youren and will you have to 
handle all these problems 

02:34:22.364 --> 02:34:24.251
yourself.
&gt;&gt; YIGIT: The major thing you 

02:34:24.252 --> 02:34:27.818
start using recycler, you need 
to forget everything you learned

02:34:28.055 --> 02:34:35.228
 in ListView.  Also some bits 
are not valid will hurt you 

02:34:35.229 --> 02:34:40.030
hear.  So another use case where
 we will lose views is recycle 

02:34:40.031 --> 02:34:45.149
viewer is I downloaded this 
view, we tried to put it into 

02:34:45.150 --> 02:34:50.462
the pool but spool limited per 
size per item type.  So, if you 

02:34:50.463 --> 02:34:55.458
have way too many types, like 
you know what?  We have no space

02:34:55.653 --> 02:35:00.036
 for it.  Throw it out.  So why 
would this happen?  Why would we

02:35:00.239 --> 02:35:04.225
 create views that we already 
have developed them unused in 

02:35:04.226 --> 02:35:12.421
the pool?  Well, this usually 
happens if -- so if you have too

02:35:12.528 --> 02:35:16.563
 many older types, why will it 
happen is mostly because of 

02:35:16.564 --> 02:35:20.797
animations.  Like you told us, I
 have seen this.  We are like to

02:35:20.984 --> 02:35:30.398
 make it animate ed, so if you 
say something like this, 

02:35:30.399 --> 02:35:34.240
recycler is like, looking for 
every visible child by default 

02:35:34.241 --> 02:35:36.695
behavior.  I have to create 
another view holder to represent

02:35:36.851 --> 02:35:43.625
 the child so I can cross them 
-- crossfade.  That means you 

02:35:43.626 --> 02:35:46.611
duplicate the number of 
ViewHolders.  Those animations 

02:35:46.612 --> 02:35:50.265
are finished and you try to put 
them all back to the pool and 

02:35:50.266 --> 02:35:53.436
they are like, I don't need this
 many items.  Just throw them 

02:35:53.437 --> 02:35:58.938
out.  So don't do that.  When an
 item changed, tell us what 

02:35:58.939 --> 02:36:04.142
changed is really, really 
important.  And correct 

02:36:04.143 --> 02:36:08.009
animation.  Or other cases you 
notice the views are being lost,

02:36:08.096 --> 02:36:13.850
 you can change the type, the 
size per type in the pool.

02:36:13.851 --> 02:36:16.318
&gt;&gt; ADAM: This comes up when you 
have cases where again social 

02:36:16.319 --> 02:36:19.182
streams are really big use case 
for this as well.  You might 

02:36:19.183 --> 02:36:23.456
have some posts that are very 
long that fill an entire screen 

02:36:23.457 --> 02:36:25.249
by themselves or might have 
several posts that are similar 

02:36:25.250 --> 02:36:30.346
very short.  And if you have 
items that are drastically 

02:36:30.347 --> 02:36:32.459
different sizes like that, then 
the number of items that can be 

02:36:32.460 --> 02:36:34.912
attached at one time is going to
 vary pretty greatly.  Those are

02:36:35.211 --> 02:36:38.021
 cases where you want to measure
 what your app behavior is under

02:36:38.169 --> 02:36:42.837
 use cases and tune the size of 
the RecyclerView pool

02:36:47.036 --> 02:36:51.046
 accordingly.  So item 
animators.  Items common to go 

02:36:51.047 --> 02:36:56.333
over time.  And again we want to
 use a smarter way of figuring 

02:36:56.334 --> 02:36:58.502
out exactly what it was that 
changed.  So let's say we added 

02:36:58.503 --> 02:37:04.225
a new item in between H&amp;I in the
 diagram here.  So now we have P

02:37:04.320 --> 02:37:09.987
 in the middle.  So no longer 
sorted.  Ignore that.  What 

02:37:09.988 --> 02:37:13.745
happens if something disappears?
  Well, now we have another 

02:37:13.746 --> 02:37:17.890
image of a list.  Now the 
interesting thing here -- and 

02:37:17.891 --> 02:37:20.795
then of course we have the case 
where an item simply changes and

02:37:21.088 --> 02:37:25.189
 it's contents change in place. 
 So the interesting thing in 

02:37:25.190 --> 02:37:30.337
these cases is that there is 
always some side effects when 

02:37:30.338 --> 02:37:35.960
you add and remove views.  So, 
we added view P here.  I&amp;J got 

02:37:35.961 --> 02:37:42.480
moved down and K is completely 
gone.  When we remove something 

02:37:42.481 --> 02:37:50.480
really similar happens.  So, we 
remove item H, I, J, K, but L is

02:37:50.745 --> 02:37:54.356
 new on the screen.  We had to 
get a new view in order to show 

02:37:54.357 --> 02:38:00.342
it in that case.  So, without 
extra information -- sorry.  

02:38:00.343 --> 02:38:02.664
Change, first.  And of course 
this is one of the easy cases.  

02:38:02.665 --> 02:38:07.591
We can just go ahead and 
crossfade between these.

02:38:07.592 --> 02:38:10.877
So, if we are handling things 
this way, if an item is removed,

02:38:11.046 --> 02:38:15.477
 we can fade it out.  When an 
item is added we fade it in.  

02:38:15.478 --> 02:38:19.556
And if an item is sort of moving
 around on screen, we can 

02:38:19.557 --> 02:38:23.694
Translate T our default item 
animation handlers can handle 

02:38:23.695 --> 02:38:27.381
this no problem.  Changing, we 
just on do a simple crossfade in

02:38:27.711 --> 02:38:30.325
 place.  As long as we don't 
have cases where that item 

02:38:30.326 --> 02:38:33.429
changed size, we are in a super 
easy case.  Otherwise it means 

02:38:33.430 --> 02:38:37.012
other items are moverring and we
 get into the same cases as 

02:38:37.013 --> 02:38:40.047
before.  But can we do better 
than this?  There is kind of a 

02:38:40.048 --> 02:38:45.029
key problem in these cases.  
Which is that if all we know is 

02:38:45.030 --> 02:38:47.327
that something changed in the 
adapter and here is the new 

02:38:47.328 --> 02:38:51.724
state, like with ListView, then 
how do we really tell the 

02:38:51.725 --> 02:38:56.787
difference between an item that 
was removed from the adapter 

02:38:56.788 --> 02:38:59.211
after this versus an item that 
just was knocked off screen and 

02:38:59.212 --> 02:39:01.984
is no longer there?  When we are
 putting together these sorts of

02:39:02.556 --> 02:39:05.034
 animations, this is suddenly 
really important.  Similarly, 

02:39:05.035 --> 02:39:09.189
how do we know if something came
 on screen because other things 

02:39:09.190 --> 02:39:12.705
moved around it or if it is a 
new item in the adapter itself? 

02:39:13.258 --> 02:39:16.939
 Again, without their being a 
representation of those views 

02:39:16.940 --> 02:39:20.871
attached to the parent from the 
outset, we don't necessarily 

02:39:20.872 --> 02:39:26.283
know.  So we can do better 
because now we know this.  We 

02:39:26.284 --> 02:39:29.712
know that conceptually, coming 
back to this smoke and mirrors 

02:39:29.713 --> 02:39:33.110
analogy from before, even though
 we only have a certain number 

02:39:33.111 --> 02:39:37.696
of items attached to the group 
at a time, conceptually we have 

02:39:37.697 --> 02:39:41.689
a lot of items that come before 
and after what is being shown on

02:39:42.099 --> 02:39:44.346
 screen.
So, we can get a little bit 

02:39:44.347 --> 02:39:46.851
predictive about this if we are 
willing to ask the adapter some 

02:39:46.852 --> 02:39:49.434
additional questions and 
specifically in conjunction with

02:39:50.372 --> 02:39:56.262
 the layout manager.  So, as we 
add this item here and we have 

02:39:56.263 --> 02:40:00.287
to delete K, in this case we 
know that K is still present if 

02:40:00.288 --> 02:40:04.136
the adapter hasn't told us it is
 gone.  We know it is just 

02:40:04.137 --> 02:40:09.896
sliding off screen instead.  
Similarly with removal we can 

02:40:09.897 --> 02:40:14.319
use the same trick.  We can ask 
the layout manager show stuff 

02:40:14.320 --> 02:40:18.341
around what I'm doing so I have 
the added context to be able 

02:40:18.342 --> 02:40:20.342
toic ta the before and after 
states and animate it

02:40:24.376 --> 02:40:26.376
 correctly.

02:40:28.800 --> 02:40:36.224
  &gt;&gt; YIGIT: So, the way this 
works about ItemAnimator is the 

02:40:36.225 --> 02:40:39.657
prediction animations is the 
RecyclerView can show a view of 

02:40:39.658 --> 02:40:44.819
the adapter in the past.  So how
 we can do this is like if you 

02:40:44.820 --> 02:40:49.863
have new items in the adapter, 
we don't tell them the layout 

02:40:49.864 --> 02:40:54.395
manager because it always sits 
in between.  What we do is we 

02:40:54.396 --> 02:40:59.853
show a different field.  For 
example, before we plotted that,

02:40:59.946 --> 02:41:03.725
 there was layout manager in 
animator and the a view and is 

02:41:03.726 --> 02:41:06.835
that a always fight this view is
 might happen no this is mine.  

02:41:06.836 --> 02:41:11.939
Wait I want it animated, wait I 
want to recycle it.  So always a

02:41:13.148 --> 02:41:17.969
 conflict.  The way we solved 
this is ChildHelper.  When 

02:41:17.970 --> 02:41:20.648
LayoutManager says I want to get
 the child in the position or 

02:41:20.649 --> 02:41:24.223
remove it or do whatever I want 
it, RecyclerView doesn't call it

02:41:24.647 --> 02:41:29.127
 um.  We don't change the 
children instantly.  We start 

02:41:29.128 --> 02:41:36.553
with the com Pope ent that is 
responsible to create this 

02:41:36.554 --> 02:41:39.579
contacts.  And then the 
ChildHelper decides layout 

02:41:39.580 --> 02:41:42.845
mother-in-law told me to remove 
it but ItemAnimator told me to 

02:41:42.846 --> 02:41:46.064
animate it so I will keep it 
until animator is done.  We 

02:41:46.065 --> 02:41:50.706
don't want layout managers to 
get more complex trying to 

02:41:50.707 --> 02:41:53.296
understand animations so for the
 layout memory they look like 

02:41:53.297 --> 02:41:58.914
they disappeared but they are 
actually real children in the 

02:41:58.915 --> 02:42:03.086
real world.  So, child is 
responsible to provide virtual 

02:42:03.087 --> 02:42:06.949
list to the layout 
mother-in-law.  So for example 

02:42:06.950 --> 02:42:11.281
-- LayoutManager.  Let's assume 
this view has been removed.  So 

02:42:11.282 --> 02:42:17.147
while you remove animations if 
the LayoutManager tries to get 

02:42:17.148 --> 02:42:20.564
the child in third position, it 
is going to return Barcelona and

02:42:20.772 --> 02:42:27.201
 if the RecyclerView if you try 
to get RecyclerView child it is 

02:42:27.202 --> 02:42:30.802
-- so between these components 
helps us with these things 

02:42:30.803 --> 02:42:36.766
without making this complex.
And animation is complete, they 

02:42:36.767 --> 02:42:43.140
start to return the same.  
AdapterHelper is the same thing 

02:42:43.141 --> 02:42:49.114
but doing the same -- so when 
you like have that adapter send 

02:42:49.115 --> 02:42:53.179
all notified changes a bunch of 
things happening in the list and

02:42:53.400 --> 02:42:57.215
 it is like what is going on?  I
 have no idea what is going on. 

02:42:57.216 --> 02:43:01.041
 It is hard for LayoutManager to
 track things because it is 

02:43:01.042 --> 02:43:06.513
already busy checking UI.  So 
AdapterHelper is to the rescue. 

02:43:06.514 --> 02:43:11.665
 So when you say notify item in 
adapter, we record it and 

02:43:11.666 --> 02:43:14.594
request a layout.  We know 
something happened.  That's it. 

02:43:14.678 --> 02:43:18.299
 The only thing we do is keep 
the information about it.  And 

02:43:18.300 --> 02:43:24.168
now as you add more notifiers we
 keep them in a list.  Let's say

02:43:24.460 --> 02:43:28.646
 during this moment before we 
recalculated the layout we know 

02:43:28.647 --> 02:43:34.758
adapter contents have changed, 
user clicked on the button.  And

02:43:35.188 --> 02:43:41.610
 you want to get the item.  Get 
in position for item at 59 which

02:43:41.767 --> 02:43:46.595
 was clicked.  But we know there
 is a new item in this so we 

02:43:46.596 --> 02:43:54.060
know that in that adapter it is 
at position 6.  So even if it is

02:43:54.246 --> 02:43:57.814
 not recalculated if you need to
 access your adapter items, we 

02:43:57.815 --> 02:44:04.837
provide you the right position. 
 So, this simply happens by 

02:44:04.838 --> 02:44:07.320
checking what you told us 
before.

02:44:11.385 --> 02:44:13.222
And let's say you send more 
updates.  And then we will go 

02:44:13.223 --> 02:44:17.121
through them, it request layouts
 honored by the system and start

02:44:18.650 --> 02:44:20.650
 preparing new layouts and

02:44:23.026 --> 02:44:24.495
 then this time, the adapter is 
going to provide the 

02:44:24.496 --> 02:44:26.862
LayoutManager the fake 
positions.  So how does it work?

02:44:26.956 --> 02:44:33.273
  What we do is when I talk 
about faking the adapter 

02:44:33.274 --> 02:44:36.768
contents, is we reorder your 
updates first.  So the idea is 

02:44:36.769 --> 02:44:40.184
everything we have to tell to 
the lab manager first we tell 

02:44:40.185 --> 02:44:45.513
about them.  And then everything
 else we tell about them later.

02:44:45.619 --> 02:44:53.444
So if you look -- you remove two
 items from 61, we know that 61 

02:44:53.445 --> 02:45:01.236
we reordered -- okay.  If you 
want this removed, run 

02:45:01.237 --> 02:45:03.237
LayoutManager

02:45:05.613 --> 02:45:08.215
 recalculating previous state, -
 asks for item 60, I can provide

02:45:08.688 --> 02:45:13.047
 it.  I don't know to tell 
LayoutManager that item has been

02:45:14.338 --> 02:45:17.777
 deleted but item 61 I don't 
have it.  So what I do is divide

02:45:18.009 --> 02:45:21.421
 that new operation into two.  I
 tell the LayoutManager, like 

02:45:21.422 --> 02:45:24.449
before you callculate the 
layout, the item 61 is gone.  

02:45:24.450 --> 02:45:30.266
Just let you know.  It does the 
preplay out, guess to the post 

02:45:30.267 --> 02:45:35.810
layout phase and this finding 
adapter updates tells or enables

02:45:35.927 --> 02:45:39.680
 us to fake that content source 
LayoutManager so all it has to 

02:45:39.681 --> 02:45:43.535
do is ask it to layout twice and
 then predict all the rest of 

02:45:43.536 --> 02:45:50.363
the animations so almost need to
 know anything about that.

02:45:50.950 --> 02:45:54.106
  &gt;&gt; ADAM: All right.  We'll try
 to move some of other features 

02:45:54.107 --> 02:45:58.090
here a little bit more quickly. 
 So ItemDecorations.  ListView 

02:45:58.091 --> 02:46:02.008
has the ability like many other 
one off features in ListView to 

02:46:02.009 --> 02:46:05.799
draw dividers between items.  
And so we needed to make sure 

02:46:05.800 --> 02:46:08.224
this functionality was 
preserved.  So ItemDecorations 

02:46:08.225 --> 02:46:14.931
allow you to do custom drawing 
on the RecyclerView canvass 

02:46:14.932 --> 02:46:18.578
itself.  Not necessarily just 
individual items within it.  We 

02:46:18.579 --> 02:46:22.298
can also go ahead and add 
offsets to view bounds using a 

02:46:22.299 --> 02:46:25.065
test case of the divider you 
need to make sure have you 

02:46:25.066 --> 02:46:29.389
couple pixels of space the 
divider consumes rather than 

02:46:29.390 --> 02:46:32.860
drawing over or under the item 
views.  And you can also have 

02:46:32.861 --> 02:46:37.344
multiple ItemDecorations.  They 
stack.  These ItemDecorations 

02:46:37.345 --> 02:46:41.894
can affect views again in sort 
of a stack-like manner.  

02:46:41.895 --> 02:46:51.120
ItemDecorations so we can draw 
items over our list

02:46:53.658 --> 02:46:57.624
 items here -- come on.
So, another important thing here

02:46:57.920 --> 02:47:02.879
 is the get item offsets.
This is really what lets us add 

02:47:02.880 --> 02:47:06.807
space.  This is nice if you're 
doing a card background around 

02:47:06.808 --> 02:47:09.529
several items at once like a 
grouping of some sort.  But you 

02:47:09.530 --> 02:47:14.120
can also do it on single items 
too.  So we can expand the space

02:47:14.554 --> 02:47:17.162
 around a particular item 
because maybe that's anier we 

02:47:17.163 --> 02:47:22.388
will draw in -- an area that we 
will draw in.

02:47:24.568 --> 02:47:30.582
So we get on draw which will 
draw underneath the item views 

02:47:30.583 --> 02:47:34.710
before we actually draw the item
 views themselves.  Which is 

02:47:34.711 --> 02:47:38.468
then followed by the items 
themselves.  And then we get on 

02:47:38.469 --> 02:47:42.512
draw over which allows us a 
chance to draw on top of the 

02:47:42.513 --> 02:47:45.591
item views in case that becomes 
relevant in your particular 

02:47:45.592 --> 02:47:48.491
situation.  So in this case, we 
are doing or just otherwise 

02:47:48.492 --> 02:47:52.337
decorating these things.
So, you need to be careful about

02:47:54.336 --> 02:47:58.575
 item digerations because it is 
drawing phase might be in the 

02:47:58.576 --> 02:48:01.325
middle of several other 
operations RecyclerView is 

02:48:01.326 --> 02:48:03.897
doing.  There are a lot of 
things that RecyclerView does to

02:48:04.028 --> 02:48:07.346
 sort of try and present a 
consistent view of the world to 

02:48:07.347 --> 02:48:09.971
adapters versus layout managers 
as we are doing animations and 

02:48:09.972 --> 02:48:13.398
so on and so forth.  So the 
adapter's view of the world may 

02:48:13.399 --> 02:48:16.284
not be what you're seeing on 
screen right then.  So make sure

02:48:16.598 --> 02:48:20.359
 that you don't use the 
ItemDecorations to access the 

02:48:20.360 --> 02:48:22.192
adapter.  Keep the necessary 
information about things you 

02:48:22.193 --> 02:48:26.450
need to draw in the view holder 
itself.  The ItemDecoration can 

02:48:26.451 --> 02:48:29.624
access the view holder at will 
because it is data about what is

02:48:30.024 --> 02:48:33.129
 being displayed on screen right
 now.

02:48:33.561 --> 02:48:37.200
And the general rules around 
drawing apply.  This is a pretty

02:48:37.475 --> 02:48:39.843
 hot code paths.
This is being called 60 frames 

02:48:39.844 --> 02:48:42.473
per second if everything is 
going right.  So try not to 

02:48:42.474 --> 02:48:47.365
allocate memory to anything too 
expensive.  You can go ahead and

02:48:49.397 --> 02:48:54.080
 usury cycler view get child 
view holder method to get a 

02:48:54.081 --> 02:48:58.296
child view attached to the 
RecyclerView at the time.  So 

02:48:58.297 --> 02:49:01.702
RecycledView Pool is important 
to know about because it allows 

02:49:01.703 --> 02:49:06.050
you to pull pretty neat tricks 
depending on the type of UI 

02:49:06.051 --> 02:49:09.687
you're creating.  So it normally
 would be internal 

02:49:09.688 --> 02:49:13.543
implementation detail where we 
are holding extra ViewHolders.  

02:49:13.544 --> 02:49:18.915
But the cool thing is you can 
share it between multiple 

02:49:18.916 --> 02:49:21.148
recycler views or other custom 
view Groups you have written 

02:49:21.149 --> 02:49:23.549
that need to do similar 
operation that is need uniform 

02:49:23.550 --> 02:49:29.430
views of this type.
Again, always make sure that you

02:49:29.703 --> 02:49:31.707
 keep these scopes to a single 
activity.  These things are 

02:49:31.708 --> 02:49:35.002
holding views.  Views hold on to
 a context.  Context are 

02:49:35.003 --> 02:49:37.818
inflated with activity and you 
can get yourself into trouble if

02:49:38.038 --> 02:49:41.163
 you end up leaking those 
activity context by accident.  

02:49:41.164 --> 02:49:44.635
So make sure they are scoped to 
a single activity at most.  You 

02:49:44.636 --> 02:49:49.695
see UIs like this in terms of 
the Android lien back library 

02:49:49.696 --> 02:49:53.772
for Androidative.  You have 
multiple rows, RecyclerView is 

02:49:53.773 --> 02:49:57.490
held within recycler views.  But
 the inner most child items are 

02:49:57.491 --> 02:50:00.968
all of uniformed type.  We can 
share the RecycledView

02:50:01.074 --> 02:50:03.120
              RecycledView Pool 
across all the individual rows 

02:50:03.121 --> 02:50:06.121
and this allows us to be much, 
much more efficient in terms of 

02:50:06.122 --> 02:50:10.538
how we allocate those and manage
 those pools.

02:50:13.913 --> 02:50:19.142
  &gt;&gt; YIGIT: So, as we start 
adding more functions to 

02:50:19.143 --> 02:50:23.266
RecyclerView, we try to 
implement as components.  So 

02:50:23.267 --> 02:50:27.943
drag and drop.  If you look at 
ListView there is a bunch of 

02:50:27.944 --> 02:50:30.689
libraryings and only some work 
for your case.  So we wanted to 

02:50:30.690 --> 02:50:35.444
learn from our mistakes.  But 
design item touch up we wanted 

02:50:35.445 --> 02:50:41.204
them to be independent of the 
layouts.  So to use item touch 

02:50:41.205 --> 02:50:47.960
up, you can do drag and drop.  
Just provide this

02:50:52.581 --> 02:50:58.472
 class -- I have a view holder, 
how can I move this view holder 

02:50:58.473 --> 02:51:02.944
up and down and left and right? 
 You can tell us what should I 

02:51:02.945 --> 02:51:08.247
do when that item is moved so 
let's say the user move it to 

02:51:08.248 --> 02:51:11.493
somewhere else and then now you 
need to change that after.  

02:51:11.494 --> 02:51:15.675
Similar swipe.  The user is 
swiping to the right.  So all 

02:51:15.676 --> 02:51:20.648
you have to do is tell us how 
the view holder cable moved.  

02:51:20.649 --> 02:51:29.672
Tell or do what you need to 
change in your adapter moved or 

02:51:29.673 --> 02:51:34.083
swiped.  So, you can drag and 
drop and swipe at the same time 

02:51:34.084 --> 02:51:43.683
in the same LayoutManager T just
 works.  So this is a -- flag.  

02:51:43.684 --> 02:51:48.332
In this example I say each item 
can be dragged up and down and 

02:51:48.333 --> 02:51:55.135
you can swipe it towards the 
end.  So it also supports RTF.  

02:51:55.136 --> 02:51:59.772
If you say and, your call base 
will receive the same things 

02:51:59.773 --> 02:52:01.470
like parameters left and right. 
 Your call-backs will receive 

02:52:01.471 --> 02:52:07.275
left and right      right.  So 
you can also customize how it is

02:52:07.447 --> 02:52:10.147
 drawn in the demos we have a 
sample that you can make it fade

02:52:10.615 --> 02:52:17.010
 away as you swipe.  You just 
override in the call back.  And 

02:52:17.011 --> 02:52:21.915
drag and drop or swipe yourself 
maybe have a custom button 

02:52:21.916 --> 02:52:26.414
there.  I need too go faster.  
Okay.  We'll go through tips and

02:52:28.277 --> 02:52:29.242
 tricks.
&gt;&gt; ADAM: Quickly here.  So 

02:52:29.243 --> 02:52:32.508
again, as we talked about 
before, we want to be for 

02:52:32.509 --> 02:52:35.676
efficient with RecyclerView 
adapters than with ListView.  So

02:52:35.780 --> 02:52:38.356
 if you don't update a 
particular item you don't get on

02:52:38.530 --> 02:52:43.385
 bind for that item.  We are 
able to reuse that view in 

02:52:43.386 --> 02:52:46.586
place.
So, even move operations we 

02:52:46.587 --> 02:52:49.195
don't have to go back to the 
adapt tore ask for that data 

02:52:49.196 --> 02:52:52.551
again because it hasn't changed.
  Why should we do the extra 

02:52:52.552 --> 02:52:57.053
work?  So we don't get in 
validate on that view.  We make 

02:52:57.054 --> 02:53:01.425
sure that cache works.  We have 
happy kittens.  And then what 

02:53:01.426 --> 02:53:05.010
that means is a side effect is 
since items can be added or 

02:53:05.011 --> 02:53:08.982
removed around it and items can 
move, when you bind your views, 

02:53:08.983 --> 02:53:12.325
don't make assumptions the 
position you're initially bound 

02:53:12.326 --> 02:53:14.326
for is always

02:53:16.251 --> 02:53:16.820
 going to be the position 
corresponding to that data item.

02:53:16.821 --> 02:53:21.119
  Again this is a perfect 
example of what can end up going

02:53:21.434 --> 02:53:25.205
 wrong.  You want to make sure 
that you access the position 

02:53:25.206 --> 02:53:29.634
live from the view holder 
itself.  The view holder know 

02:53:29.635 --> 02:53:34.190
what is is going on.  In this 
case, there we go.  The view 

02:53:34.191 --> 02:53:36.587
holder knows what the adapter 
position is right now so we make

02:53:36.749 --> 02:53:40.695
 sure to keep that updated for 
you so you don't have to track 

02:53:40.696 --> 02:53:43.293
it.  Make sure you don't 
accidently close over the value 

02:53:43.294 --> 02:53:45.997
of the adapter position by 
accident.

02:53:45.998 --> 02:53:47.998
&gt;&gt; YIGIT:

02:53:49.935 --> 02:53:53.999
 And a little mouse will not let
 you do that.  So use item 

02:53:54.000 --> 02:53:58.602
change with payload.  So when 
you item change like time 

02:53:58.603 --> 02:54:03.083
change, use it with payload.  It
 will make your online more 

02:54:03.084 --> 02:54:07.054
efficient.  You can have better 
animations.  So you can just 

02:54:07.055 --> 02:54:14.037
check if you have payloads, so 
if there is no payloads -- if 

02:54:14.038 --> 02:54:17.303
there is, we guarantee the view 
hold ser being reused for that 

02:54:17.304 --> 02:54:20.724
position so you don't have to 
set everything.  You only set 

02:54:20.725 --> 02:54:23.513
what has changed and you hold 
that information from the 

02:54:23.514 --> 02:54:26.804
payload.  It is very efficient 
and great for animations.  

02:54:26.805 --> 02:54:33.127
Another mistake we see commonly 
like you have a view and return 

02:54:33.128 --> 02:54:38.956
the same one -- don't do it.  If
 you create new view holder.  

02:54:38.957 --> 02:54:44.176
Don't try to return the same you
 have.  We

02:54:48.216 --> 02:54:50.216
 will --

02:54:52.544 --> 02:54:58.027
Adapter versus layout positions 
is something we previously 

02:54:58.028 --> 02:55:02.225
mentioned.  But a view let's say
 you move that item at this 

02:55:02.226 --> 02:55:05.950
point, you can see the adapter 
positions and layout positions 

02:55:05.951 --> 02:55:10.023
or some items are different 
until the next layout is 

02:55:10.024 --> 02:55:13.745
calculated because now it is 
calculated as a courtesy.  So 

02:55:13.746 --> 02:55:18.893
once the view system tells us to
 refresh yourself, now all the 

02:55:18.894 --> 02:55:23.280
items have the same layout 
position in that position.  So 

02:55:23.281 --> 02:55:26.137
that position is very -- if you 
need to access your data, layout

02:55:26.286 --> 02:55:30.685
 position is good if you want to
 know what is below at the point

02:55:31.305 --> 02:55:34.604
 to predict something.
&gt;&gt; ADAM: And that is it.

02:55:34.605 --> 02:55:39.577
&gt;&gt; Thank you.  Yes!
[ Applause ]

04:01:02.737 --> 04:01:02.739
 .
&gt;&gt; EMILY (CART captioner):  

04:01:02.740 --> 04:01:05.293
Standing by.

04:08:18.598 --> 04:08:18.717
,
&gt;&gt; EMILY (CART captioner):  

04:08:18.718 --> 04:08:18.922
Standing by.  Testing, one, two,
 three,.

04:08:18.923 --> 04:08:22.372
&gt;&gt; EMILY (CART captioner):  
Standing by            

04:08:46.528 --> 04:08:48.528
                                 emwe
lcome t

04:08:50.306 --> 04:08:57.401
o "how AMP                      

04:08:57.402 --> 04:08:59.510
Test                    

04:09:18.457 --> 04:09:24.034
APPLAUSE ]
&gt;&gt; Hello, I/O.  My name is Addie

04:09:24.250 --> 04:09:28.886
 Osmani  ni.  You might have 
heard of progressive Web apps.  

04:09:28.887 --> 04:09:31.326
It might seem like they went 
from being this great idea to 

04:09:31.630 --> 04:09:34.735
now being talked about 
everywhere.  It sort of e

04:09:35.365 --> 04:09:39.882
scalated kind of quickly.
Now, for many of us in this room

04:09:40.179 --> 04:09:42.754
, maybe you're working on an 
existing app, or you're thinking

04:09:42.910 --> 04:09:45.465
 about the next app you're going
 to be building.  Maybe you're 

04:09:45.466 --> 04:09:50.748
building it with a JavaScript 
light Re or a framework, and 

04:09:50.749 --> 04:09:53.719
maybe you have progressive 
enhancement in mind because you 

04:09:53.720 --> 04:09:58.485
want to make sure the experience
s you're crafting for many users

04:09:58.637 --> 04:10:00.891
 as possible.
We're going to keep that in mind

04:10:01.051 --> 04:10:03.156
 today.
Now, before we continue, it's 

04:10:03.157 --> 04:10:05.874
probably useful to remind 
ourselves what a progressive web

04:10:06.036 --> 04:10:09.953
 app is.  So progressive Web 
apps use modern Web cape 

04:10:10.252 --> 04:10:14.511
ability ies to deliver app-like 
experiences.  They evolve       

04:10:14.512 --> 04:10:19.039
 evolve from page in browser 
tabs to tabs that exist on a u

04:10:19.190 --> 04:10:21.764
ser's home screen and exhibit 
reliable performance.

04:10:21.830 --> 04:10:24.328
Now, this is an app called small
er pictures that I've been 

04:10:24.329 --> 04:10:28.112
working on.  It's base ically a 
photo app that lets you compress

04:10:28.113 --> 04:10:31.321
 images on the go.  And it's got
 features like the Web app 

04:10:31.322 --> 04:10:37.487
install banner, splash screen, 
offline support.

04:10:37.488 --> 04:10:40.809
And when I got to Mountain View,
 I thought it would be useful to

04:10:40.989 --> 04:10:43.876
 test this app out.  I took a 
picture of the bathroom in my 

04:10:44.149 --> 04:10:46.734
hotel.  Something I discovered 
after doing this was that that b

04:10:46.891 --> 04:10:51.991
athroom actually has a better 
contribution graph than I do.

04:10:51.992 --> 04:10:56.022
[LAUGHTER]
&gt;&gt;  

04:10:56.023 --> 04:11:00.039
&gt;&gt; You            you might be 
are they union       unique to 

04:11:00.040 --> 04:11:02.444
Chrome.  Often talked about in 
the context of the Chrome 

04:11:02.445 --> 04:11:05.490
browser.  The answer is 
absolutely not.  If you take a 

04:11:05.930 --> 04:11:10.639
look at Opera on Android, you've
 seen they've got a progressive 

04:11:10.769 --> 04:11:14.290
Web app story as well.  The Web 
app install banner working, 

04:11:14.291 --> 04:11:17.334
splash screen, offline support 
thanks to server worker.  It's 

04:11:17.335 --> 04:11:19.357
not just them     them.  If you 
take a look at Firefox         

04:11:20.553 --> 04:11:23.017
Firefox on Android as well, they
 similarly got a lot of e

04:11:23.149 --> 04:11:28.300
xplorations in this area going 
on at the home screen features, 

04:11:28.621 --> 04:11:31.797
offline support, web banner b
eing experimented with at the m

04:11:32.078 --> 04:11:33.793
oment.
When you're building a progress

04:11:33.794 --> 04:11:36.401
ive Web app and you have p
rogressive enhancement as sort 

04:11:36.402 --> 04:11:41.489
of a core ten net     net of the
 experiences you've trying to 

04:11:41.490 --> 04:11:43.490
craft, they just work for 
everybody,

04:11:47.840 --> 04:11:51.706
 regardless of whether they're 
on satisfy         satisfy 

04:11:47.840 --> 04:11:51.221
far             Safari on Ios, 
they're trying to look at your 

04:11:51.222 --> 04:11:54.264
content from an area that might 
have seriously limited connecti

04:11:54.833 --> 04:11:56.533
vity.
When you're crafting these e

04:11:56.534 --> 04:11:59.100
xperiences with acttures like 
              act     

04:11:59.101 --> 04:12:02.491
architectures, it makes sense to
 be able to ship experiences f

04:12:02.651 --> 04:12:06.285
aster for everybody.
Are progressive Web apps a 

04:12:06.286 --> 04:12:09.164
polymer only thing?  At I/O this
 year we did show a first-class 

04:12:09.473 --> 04:12:12.754
experience for building progress
ive Web apps using polymer, but 

04:12:12.755 --> 04:12:16.883
you can use any tech stack to 
create progressive apps.  In 

04:12:16.884 --> 04:12:19.296
fact, over the last few months, 
we've seen an increase ing 

04:12:19.297 --> 04:12:22.920
number of really large apps 
launched using progressive Web 

04:12:22.921 --> 04:12:27.355
app features. first one is 5 
miles.  It's sort of a Pinterest

04:12:28.868 --> 04:12:32.265
 meets craigslist.  They launch
ed a full progressive Web app 

04:12:32.266 --> 04:12:34.702
with an application shell 
architecture at the home screen,

04:12:35.011 --> 04:12:39.090
 splash screen.  This was built 
using angular JS.  They found 

04:12:39.407 --> 04:12:41.619
their at the home screen 
experience led to 30 percent 

04:12:41.620 --> 04:12:46.968
better conversions.  Similarly, 
flip cart, they saw three times 

04:12:46.969 --> 04:12:50.332
more time on their site with 
progressive Web app, 70 percent 

04:12:50.333 --> 04:12:54.524
conversion rate from ad users.  
That's an app built using  React

04:12:54.823 --> 04:13:01.076
.  We saw Cilio app, buying and 
selling goods locally.  This is 

04:13:01.077 --> 04:13:07.597
an app built using React.  This 
is universal yaiveva         

04:13:07.598 --> 04:13:12.308
JavaScript.  The progressive Web
 app equals native.  The user 

04:13:12.309 --> 04:13:15.081
acquisition costs were ten times
 cheaper than native.  Because 

04:13:15.082 --> 04:13:20.264
they used Web push notifications
, they saw improved user 

04:13:20.265 --> 04:13:23.114
retention and they used service 
side rendering and found that 

04:13:23.115 --> 04:13:26.423
reduced bounce rates with things
 like sharing posts and buying a

04:13:26.570 --> 04:13:28.417
ds.
So today we're going to talk 

04:13:28.418 --> 04:13:33.434
about how to build progressive 
Web apps using React, angular, 

04:13:33.435 --> 04:13:39.362
and ember JS.  Before we do t
hat, let's talk about waiting.

04:13:40.250 --> 04:13:43.476
Waiting is something we all have
 to do as a part of our daily 

04:13:43.477 --> 04:13:46.537
lives.  It's sort of this 
frustrating thing.  You could be

04:13:46.538 --> 04:13:50.212
 at a restaurant waiting        
 waiting for someone to bring 

04:13:50.213 --> 04:13:54.600
you a menu or someone to bring 
you your food.  And 20 or 30 

04:13:54.601 --> 04:13:57.800
minutes could easily pass by and
 you're still wondering, should 

04:13:57.965 --> 04:14:01.595
I go up?  Should I ask someone 
for a menu?  Ask someone in if 

04:14:01.596 --> 04:14:05.725
the food is ready?  You could be
 waiting maybe an hour, two 

04:14:05.726 --> 04:14:08.197
hours.  It gets to a point where
 you start questioning your life

04:14:08.198 --> 04:14:12.357
 choices and start wondering 
should I just eat my wallet 

04:14:12.358 --> 04:14:13.868
instead.
On the Web, the equivalent of t

04:14:13.869 --> 04:14:18.025
his is your users considering l
eaving your site or app, and 

04:14:18.026 --> 04:14:23.346
that's not something you want.
So the key differentiator 

04:14:23.347 --> 04:14:28.086
between the old Web and new Web 
is native apps have got reliable

04:14:28.534 --> 04:14:30.366
 performance and that's 
something we like to be able to 

04:14:30.367 --> 04:14:33.582
strive for with the experiences 
we're shipping on the Web.  How 

04:14:33.583 --> 04:14:37.734
do we deliver native caliber 
features while still being able 

04:14:38.031 --> 04:14:40.336
to use JavaScript            
JavaScript libraries and 

04:14:40.337 --> 04:14:42.297
frameworks?
Well, before we talk about that,

04:14:42.298 --> 04:14:44.891
 there are a few key moments 
that we need to keep in mind w

04:14:45.030 --> 04:14:49.160
hen it comes to user experience 
and performance.  The first is, 

04:14:49.161 --> 04:14:52.945
is it happening?  Time to first 
paint.  Now, this is when you're

04:14:53.099 --> 04:14:55.858
 showing your user a splash 
screen or a loading         

04:14:55.859 --> 04:14:58.140
loading indicator, some feedback
 that indicates your navigation 

04:14:58.141 --> 04:15:01.647
has started in your page.  Next 
you have time to first 

04:15:01.648 --> 04:15:07.471
meaningful paint.  This is the, 
is it useful moment.  This g

04:15:07.630 --> 04:15:09.893
enerally focuses on paints above
 the full content, headline text

04:15:10.194 --> 04:15:13.845
, something they can actually 
use and find useful.

04:15:14.017 --> 04:15:16.433
Then you've got time to first 
meaningful 

04:15:16.434 --> 04:15:18.434
\interaction\intersection.  

04:15:18.818 --> 04:15:20.656
           meaningful 
interaction.  If the user goes 

04:15:20.657 --> 04:15:23.731
tapping         tapping around 
your UI, is something going to 

04:15:25.061 --> 04:15:27.241
happen?
Now, at I/O this clear, we 

04:15:27.242 --> 04:15:31.185
announce ed a new tool called  
Lighthouse.  It's a Chrome 

04:15:31.186 --> 04:15:33.768
extension and a CLI that checks 
that you have your progressive W

04:15:34.066 --> 04:15:38.171
eb app features in check.
If  It also has initial support 

04:15:38.172 --> 04:15:41.677
for loading performance metrics.
  Also on the slide is Web page 

04:15:41.678 --> 04:15:44.427
task.  It's a tool that's been a
round for quite some time, but b

04:15:44.724 --> 04:15:47.606
ase ically helps you performance
 profile your sites on real-

04:15:47.901 --> 04:15:50.336
world devices with different 
types of network connectivity 

04:15:50.794 --> 04:15:55.176
profiles. one metric both of 
these tools look at is the speed

04:15:55.498 --> 04:16:00.031
 index.  A metric that looks at 
how visually complete the page 

04:16:00.032 --> 04:16:04.485
is.  For the apps we're looking 
at today, the direct, angular 

04:16:04.486 --> 04:16:08.069
apps, the targets on kale are g
oing to be a speed index of a 

04:16:08.070 --> 04:16:11.777
thousand.  Ideally things load
ing in under a second.  3G our 

04:16:11.778 --> 04:16:16.537
target is 3,000.  Under three 
seconds.  On repeat view using 

04:16:16.538 --> 04:16:20.205
service worker, our goal is to 
make sure we're loading thing as

04:16:20.368 --> 04:16:23.530
 close to possible.  Under a 
thousand is great but as close 

04:16:23.531 --> 04:16:26.267
to zero as possible.
At I/O we're talking about 

04:16:26.268 --> 04:16:29.924
killing the offline dinosaur  
       dinosaur.  Ideally you 

04:16:29.925 --> 04:16:31.183
want to be able to build 
experiences             

04:16:31.184 --> 04:16:33.742
experiences where you're no long
er having to play that game.  

04:16:33.743 --> 04:16:40.578
You're actually giving users s
omething valuable:  I spent too 

04:16:40.579 --> 04:16:44.210
much time on this slide and made
 poor life decisions, sorry.

04:16:44.523 --> 04:16:47.562
The service worker is the 
baseline.  Runs separate from y

04:16:47.740 --> 04:16:50.139
our page.  Response to events 
like network requests and gives 

04:16:50.140 --> 04:16:53.646
you the ability to define really
 well-crafted       crafted 

04:16:53.647 --> 04:16:57.241
offline experiences.
Now, service worker gives us the

04:16:57.242 --> 04:16:59.230
 opportunity really to start 
rethinking our application 

04:16:59.231 --> 04:17:02.331
architectures.  One such 
architecture is the application 

04:17:02.332 --> 04:17:05.566
shell architecture.  And the 
idea here is that we try shipp

04:17:05.702 --> 04:17:11.804
ing down the network as quickly 
as possible.  Just look at the 

04:17:11.805 --> 04:17:15.684
content necessary to up-load a
pplication UI.  Things like the 

04:17:15.685 --> 04:17:19.011
toolbar         toolbar, drawer,
 maybe some cards.  Then later 

04:17:19.012 --> 04:17:23.589
on we dine      dynamically 
populate that view with your c

04:17:23.733 --> 04:17:26.865
ontent.  This model works well 
for single page applications, b

04:17:27.170 --> 04:17:30.775
ut it's nuance ed.  You might be
 working on a content-heavy site

04:17:30.776 --> 04:17:34.254
 and might be more important for
 you to get actual test down to 

04:17:34.255 --> 04:17:37.289
users first.  Just keep that in 
mind when evaluate ing options 

04:17:37.290 --> 04:17:39.290
when it comes to these 
architectures.

04:17:39.407 --> 04:17:41.285
But if the application shell 
architecture does make sense for

04:17:41.286 --> 04:17:44.520
 your app, the way you achieve 
some of these improvements in 

04:17:44.521 --> 04:17:47.417
addition to service worker is 
doing things like relying on 

04:17:47.418 --> 04:17:51.498
critical path CSS.  Inline ing 
the critical styles for your a

04:17:51.817 --> 04:17:56.987
pplication shell and the 
document head.  Loading in the 

04:17:56.988 --> 04:17:59.726
java      JavaScript for the 
current view.  We can use things

04:17:59.727 --> 04:18:04.217
 like the A sync, and libraries 
from the fillment group to be a

04:18:04.662 --> 04:18:09.030
ble to load in the content that 
we need.nd the performance wins 

04:18:09.031 --> 04:18:13.580
of such a model are actually q
uite stark.  What you'll see if 

04:18:13.581 --> 04:18:18.279
this is working, here, is on r
epeat view it's almost instant. 

04:18:18.280 --> 04:18:20.745
 This is like the simplest 
version of the application a

04:18:21.488 --> 04:18:23.488
rchitecture we could come up 
with.  You've got instant p

04:18:23.524 --> 04:18:26.155
erformance for the repeat visit 
compared to the first visit 

04:18:26.156 --> 04:18:34.633
where it took much, much longer.
 let's talk about React.  React 

04:18:34.634 --> 04:18:39.975
is a UI library for create ing 
interactive, stateful and reuse 

04:18:40.476 --> 04:18:44.573
able components built by F
acebook.  Virtual DOMs, trying 

04:18:44.574 --> 04:18:47.600
to keep your components up to 
date.  It works really well on b

04:18:47.759 --> 04:18:52.708
oth the client and server.
Now, I'm a big fan of hacker 

04:18:52.709 --> 04:18:55.989
news.  I use it every day, and I
 thought, you know, maybe it 

04:18:55.990 --> 04:19:01.200
would be useful to be able to 
try using Hacker News offline.  

04:19:01.201 --> 04:19:03.480
Unfortunately it doesn't work 
offline on the site.  You'll get

04:19:03.481 --> 04:19:05.796
 the dinosaur if you try using 
it.

04:19:05.902 --> 04:19:08.681
By the way, this is the dinosaur
 that we have over in the mobile

04:19:09.286 --> 04:19:13.872
 Web area.  You might notice 
that it seems to have like four 

04:19:13.873 --> 04:19:17.039
legs for some reason and two 
arms.

04:19:17.115 --> 04:19:20.684
[LAUGHTER] I just wanted to 
clarify on behalf of the Chrome 

04:19:20.685 --> 04:19:24.281
team the back two legs have been
 deprecate ed but haven't been 

04:19:24.282 --> 04:19:28.739
removed just yet.
[LAUGHTER]

04:19:28.847 --> 04:19:34.858
&gt;&gt; So back in 2014, hacker news 
announce ed they have an open 

04:19:34.859 --> 04:19:38.811
API that anyone could go and 
build a Hacker News

04:19:54.093 --> 04:19:55.031
 client with.  That was based on
 Firebase.  Realtime API.  Any 

04:19:55.032 --> 04:19:55.337
time someone goes and makes a 
comment, you can stream that 

04:19:55.338 --> 04:19:55.640
latest content through to your 
clients.  So I decide ed to go 

04:19:55.641 --> 04:19:55.972
on GitHub and find out if 
anybody had been hacking on a 

04:19:55.973 --> 04:19:56.246
really interesting hacker news 
client.  I found this one by 

04:19:56.247 --> 04:19:59.120
Johnny Buchanan.  This is a 
really nice client.  Lets you 

04:19:59.252 --> 04:20:02.740
take a look at all the different
 views available in hacker news.

04:20:03.039 --> 04:20:05.982
  Got new comment, show, ask 
jobs and it will highlight any 

04:20:05.983 --> 04:20:10.161
time a new comment is updated or
 someone has edited their 

04:20:10.162 --> 04:20:12.140
comment.
Unfortunately this didn't work 

04:20:12.141 --> 04:20:14.322
offline either.  I thought it 
would be kind of interesting if 

04:20:14.323 --> 04:20:16.323
you went in and

04:20:18.261 --> 04:20:19.057
 explored what it would be like 
to take this complex React app 

04:20:19.058 --> 04:20:22.677
and turn it into a progressive 
Web app that worked offline.  

04:20:22.678 --> 04:20:25.038
The first thing we needed to do 
was make it response ive.  I 

04:20:25.194 --> 04:20:29.059
know that sounds silly but it's 
quite a common thing to forget 

04:20:29.060 --> 04:20:31.862
this one step.  So we went and 
optimize ed things like the 

04:20:31.863 --> 04:20:34.839
amount of view port real estate 
being used on mobile.  We wanted

04:20:34.840 --> 04:20:38.517
 to make sure it actually used 
up as much space as possible on 

04:20:38.518 --> 04:20:42.101
IOS and Android.  We wanted to 
avoid things like overlapping 

04:20:42.527 --> 04:20:44.413
menu items.  We fixed       
fixed those as well.  All of 

04:20:44.414 --> 04:20:48.014
this is just done using media 
queries and nothing particularly

04:20:48.151 --> 04:20:50.501
 special.
The next thing we added was the 

04:20:50.502 --> 04:20:53.789
web app manifest.  When is this 
project?  I notice ed they had a

04:20:53.930 --> 04:20:59.376
 tiny fab con.  That wasn't 
going to cut it.  I redid it in 

04:20:59.377 --> 04:21:01.986
sketch and set up the Web 
manifest so we could launch this

04:21:02.148 --> 04:21:04.953
 screen from the home screen and
 get a splash screen.  This is w

04:21:06.222 --> 04:21:09.858
hat the manifest looks like.  We
 have a background color set for

04:21:09.859 --> 04:21:11.537
 the slash screen and another 
color set for the theme color 

04:21:11.538 --> 04:21:15.286
and our icons defined in there 
as well.

04:21:15.390 --> 04:21:19.082
This application is a lot more 
complex than it might initially 

04:21:19.083 --> 04:21:22.455
seem.  We have this large set of
 complex realtime data being 

04:21:22.560 --> 04:21:25.220
streamed to the client and then 
we have this application UI, 

04:21:25.221 --> 04:21:28.235
this skeleton, that we're using 
across all of our different 

04:21:28.236 --> 04:21:31.821
views.  So we're going to split 
this problem into two parts.  

04:21:31.822 --> 04:21:34.264
The first is cache ing our 
application skeleton and the 

04:21:34.265 --> 04:21:36.713
next part is going to look at 
content cache ing.

04:21:36.843 --> 04:21:39.790
Now, for cache ing our 
application skeleton, we're 

04:21:39.791 --> 04:21:45.433
going to use two libraries:  SW 
precache, which is a build tool 

04:21:45.434 --> 04:21:48.779
that will help you precache all 
of the assets you need for your 

04:21:48.780 --> 04:21:52.238
first application shell render, 
and SW toolbox, which is a l

04:21:52.691 --> 04:21:56.327
ibrary for handling all of your 
dynamic views and content that 

04:21:56.328 --> 04:22:00.925
might get rendered later on.
Now, in this application, like 

04:22:00.926 --> 04:22:03.831
many React apps, we're just 
using web pack behind the scenes

04:22:03.993 --> 04:22:09.967
 for a module bump link     ling
.  It can add on after the fact.

04:22:10.125 --> 04:22:14.246
  I've got some scripts set up 
for this project.  SW precast 

04:22:14.571 --> 04:22:16.955
        precache is another step
 I run after the build is create

04:22:16.956 --> 04:22:20.581
 complete ed.  Configure ing 
using a precache config file and

04:22:21.472 --> 04:22:24.293
 my pack is adjacent.  This is 
what the conflict file looks 

04:22:24.294 --> 04:22:27.939
like, importing in toolbox, some
 rules for runtime cache ing, 

04:22:27.940 --> 04:22:32.240
and I'm able to configure things
 like what other files I might 

04:22:32.241 --> 04:22:33.726
like to have cache ed inside t
here.

04:22:33.727 --> 04:22:36.725
In runtime cache ing I can 
specify what other origins I 

04:22:36.726 --> 04:22:39.220
would like to be cache ed.  In 
this case I've set it up to c

04:22:39.501 --> 04:22:42.740
ache anything come back from 
Firebase, from the Hacker News 

04:22:42.741 --> 04:22:47.127
Firebase API, and also to cache 
things like Google fonts or 

04:22:47.128 --> 04:22:51.394
anything coming back from the 
Google CDM. step is going and 

04:22:51.708 --> 04:22:55.473
actually registering my service 
worker.  I add this boilerplate 

04:22:55.649 --> 04:22:57.405
            boilerplate code to 
the index file and make sure 

04:22:57.406 --> 04:23:00.656
it's registering the service w
orker generate ed by SW precache

04:23:01.210 --> 04:23:02.900
.
I go and load up my page and l

04:23:02.901 --> 04:23:06.919
ook at a repeat view, I can see 
all of my static assets are 

04:23:06.920 --> 04:23:10.211
being serviced from the server 
worker cache in dev tools.

04:23:10.212 --> 04:23:13.426
I go into airplane mode and 
check out this app and I'm happy

04:23:13.894 --> 04:23:17.242
.  I've already opened this up 
before.  I'm starting to look at

04:23:17.243 --> 04:23:19.309
 content I've seen previously, 
but there's something wrong here

04:23:20.096 --> 04:23:23.347
.  Although my application shell
 consistently renders really, 

04:23:23.825 --> 04:23:27.484
really fast offline, as soon as 
I close that app, I'm still in 

04:23:27.485 --> 04:23:32.068
airplane mode, I launch it from 
the home screen, I get this:  No

04:23:32.069 --> 04:23:35.957
 content.  The reason for that 
is Firebase's offline support is

04:23:35.958 --> 04:23:38.556
 limited to the session the user
 currently has.  As soon as you 

04:23:38.734 --> 04:23:41.414
close that off and try, you know
, going and relaunching from the

04:23:41.415 --> 04:23:43.686
 home screen, you're not going t
o be able to get that same s

04:23:43.842 --> 04:23:46.050
ession data back.  You need to a
ctually cache it a little bit 

04:23:46.051 --> 04:23:51.196
separately.
So that leads us on to content 

04:23:51.197 --> 04:23:53.318
cache ing and something I've s
pent the last four weeks trying 

04:23:53.319 --> 04:23:57.967
to solve.  So Firebase generally
, you know, because it's 

04:23:57.968 --> 04:24:01.212
realtime, it works using web 
sockets.  This is just expecting

04:24:01.213 --> 04:24:04.572
 some Web socket frames in dev 
schools.  You've got bits and 

04:24:04.573 --> 04:24:08.647
pieces of comment and metadata 
you might use to construct 

04:24:08.807 --> 04:24:12.276
comments page.w, I first thought
 maybe it would be an 

04:24:12.277 --> 04:24:16.543
interesting to store anything 
that comes back here in index DB

04:24:16.779 --> 04:24:20.108
.  Unfortunately I'd forgotten 
that it's the worst API known to

04:24:20.412 --> 04:24:24.658
 man and should probably be 
burned.  Luckily there exists a 

04:24:24.659 --> 04:24:30.487
number of good ab straxes for  
              abstractions, Dexi

04:24:30.833 --> 04:24:37.418
 by Jake Archibald.  Here we are
 inside of react once again.  

04:24:37.419 --> 04:24:40.304
I'm consume ing the fair base 
API the same way you would today

04:24:40.456 --> 04:24:44.244
.  I thought maybe I could be a 
little bit clever.  What if I'd 

04:24:44.245 --> 04:24:47.970
built some middleware that would
 base ically positiony anything 

04:24:47.971 --> 04:24:51.345
coming back from the Firebase 
API to the index and we stored 

04:24:51.346 --> 04:24:58.075
that.  Seems like a not terrible
 idea, right?  Unfortunately, 

04:24:58.301 --> 04:25:01.371
what happened there is if you 
went and saw any story on the t

04:25:01.663 --> 04:25:06.209
op stories page and you opened 
it up, about ten to 15 seconds 

04:25:06.210 --> 04:25:10.807
later you'd end up with three to
 4,000 records.  You wait 

04:25:10.808 --> 04:25:13.545
another many, it will grow to 
four or 5,000 because you're 

04:25:13.546 --> 04:25:17.423
dealing with real-time data 
constantly update ing index DB 

04:25:17.424 --> 04:25:22.397
as you go.n mobile, if you open 
an app where you've had a large 

04:25:22.398 --> 04:25:25.989
number of records stored because
 you've been looking at lots of 

04:25:25.990 --> 04:25:28.545
pages, you want all of them to 
work offline, what will happen 

04:25:28.704 --> 04:25:31.723
is in this app we had to I hadr
ate           I had       

04:25:31.724 --> 04:25:34.238
iterate over the entire 
collection.  It ended up grind

04:25:34.397 --> 04:25:37.545
ing Chrome to a halt.  That 
wasn't good enough.

04:25:37.546 --> 04:25:40.685
So I then said, okay, well, 
maybe I should rethink this p

04:25:40.840 --> 04:25:43.028
roblem a little bit.  What      
  What if we just used web work

04:25:43.297 --> 04:25:46.787
ers.  I was using local forage. 
 I thought I'm going to batch 

04:25:46.788 --> 04:25:49.122
all of my rights for this a
pplication and only try storing 

04:25:49.123 --> 04:25:53.709
them maybe every 30 seconds 
instead.  Unfortunately index DB

04:25:53.710 --> 04:25:58.228
 is still really bad when it 
comes to these problems, and I 

04:25:58.229 --> 04:26:03.355
found that still wasn't good 
enough for this A.

04:26:03.455 --> 04:26:07.543
I had this revelation.  I was s
itting in an airport lounge and 

04:26:07.544 --> 04:26:10.103
I thought, well, I don't really 
need this data to be entirely 

04:26:10.104 --> 04:26:14.252
fresh.  I don't need it to be 
update ing every second so I 

04:26:14.253 --> 04:26:17.362
have every single comment.  I 
realized that Firebase actually 

04:26:17.363 --> 04:26:21.916
has a rest API.  The rest API a
llows you to base ically go and 

04:26:21.917 --> 04:26:27.969
fetch a static version of 
content from an end point and 

04:26:27.970 --> 04:26:30.379
that's something much easy ier 
for to you cache.  Imagine we 

04:26:30.380 --> 04:26:33.122
have our comment page and all of
 these different comments.  I 

04:26:33.123 --> 04:26:37.549
just have like JSON end points 
for every single one I can go an

04:26:37.693 --> 04:26:40.521
d cache.  That's what we do.  I 
introduced an offline mode into 

04:26:40.522 --> 04:26:43.056
the react hacker        Hacker 
News client       client.  I'm 

04:26:43.924 --> 04:26:47.548
still online, launched my app, 
going to take a look at one of 

04:26:47.549 --> 04:26:49.849
the Google articles here.ou'll 
see this is a page that has a 

04:26:50.007 --> 04:26:56.503
lot of comments, content.  We're
 scrolling.  Maybe I'm on the t

04:26:56.833 --> 04:26:59.980
ube or a bus or something, but I
 want to be able to view that 

04:26:59.981 --> 04:27:05.319
content offline.  I'm going to a
irplane mode, relaunch that app.

04:27:05.320 --> 04:27:07.777
  With content cache ing in 
place now using the rest API, I 

04:27:07.778 --> 04:27:11.102
can cache all of that data in 
the server worker cache instead 

04:27:11.103 --> 04:27:15.697
of using just index       Index 
D B.  You'll see it just works. 

04:27:15.698 --> 04:27:16.605
 I can load any of the pages 
I've previously visited and 

04:27:16.606 --> 04:27:23.544
they'll just work fine offline. 
 I ended up delaying a 300 

04:27:23.545 --> 04:27:25.775
person flight ten minutes so I 
could get the pro request in for

04:27:25.776 --> 04:27:27.807
 this feature because that was 
how happy I was I got this w

04:27:31.105 --> 04:27:32.482
orking.
Now, one of the lessons there 

04:27:32.483 --> 04:27:35.989
was that I had to rethink what I
 wanted my offline experience to

04:27:36.172 --> 04:27:38.834
 be.  The technical side of 
getting service worker set up 

04:27:38.835 --> 04:27:42.212
and cache ing set             
cache ing, that wasn't hard; it 

04:27:42.213 --> 04:27:44.516
was just crafting the right user
 experience.

04:27:44.604 --> 04:27:46.740
Next we're going to talk a 
little bit about universal 

04:27:46.741 --> 04:27:50.721
rendering.  So Paul Lewis put up
 these interesting graphs a few 

04:27:50.722 --> 04:27:54.258
weeks ago.  In a JavaScript base
 rendering you're usually 

04:27:54.259 --> 04:27:57.645
reliant on all the script to be 
downloaded            downloaded

04:27:57.646 --> 04:28:01.305
 before you can render the page.
  Ends up wasting a lot of time 

04:28:01.306 --> 04:28:05.303
when the HTML arrives to give th
e user something meaningful on 

04:28:05.304 --> 04:28:07.671
the screen.  Something slightly 
better is the situation where we

04:28:07.672 --> 04:28:10.178
 see a lot of frameworks moving 
in at the moment.  You have a 

04:28:10.179 --> 04:28:13.216
server render with hydration 
where you send a view to the 

04:28:13.361 --> 04:28:16.104
user.  The downside is you're 
still rely      reliant on the 

04:28:16.105 --> 04:28:19.665
JavaScript to be loaded up 
before someone can interact with

04:28:19.666 --> 04:28:21.656
 your application.  This can 
result in a little bit of an 

04:28:21.657 --> 04:28:25.173
uncanny valley, where the user 
sees the application but they 

04:28:25.174 --> 04:28:28.373
tap and nothing actually h
appens.

04:28:28.478 --> 04:28:31.079
Somewhere that would be amazing 
to see a lot of frameworks moved

04:28:31.080 --> 04:28:33.696
 to is this idea of progressive 
rendering and bootstrap where yo

04:28:33.907 --> 04:28:39.644
u send a functionally viable but
 minimal view in HTML with your 

04:28:40.287 --> 04:28:43.728
JavaScript and ACS and it 
unlocks more features as the 

04:28:43.729 --> 04:28:47.331
user starts navigating around i
t.  I'd love to see moving more 

04:28:47.499 --> 04:28:49.372
in that direction.
For the service signed rendering

04:28:49.373 --> 04:28:53.910
 portion of the react, react 
router was amazing.  Worked 

04:28:53.911 --> 04:28:57.190
really well on the server.  We 
found we were able to use most 

04:28:57.191 --> 04:29:00.425
routes with very little effort. 
 We just put together a quick 

04:29:00.426 --> 04:29:02.780
express server to get this set 
up.  Some of the little lessons 

04:29:02.781 --> 04:29:05.608
I learned along the way were 
make ing sure we properly guard

04:29:05.766 --> 04:29:10.152
ed ourselves around globals.  
The staff was still make ing use

04:29:10.153 --> 04:29:12.133
 of things like local and 
session storage.  We had to 

04:29:12.134 --> 04:29:14.565
guard ourselves so that wouldn't
 fall over.  We had to minimize 

04:29:14.566 --> 04:29:18.859
reliance on things like the DOM,
 .  The previous author was u

04:29:19.005 --> 04:29:21.871
sing the DOM to parse out the 
host name so we had to switch 

04:29:21.872 --> 04:29:24.748
away from doing that.
Here's where we ended up.  

04:29:24.749 --> 04:29:29.693
Started off in a place where on 
cable we had a speed index of 

04:29:29.694 --> 04:29:32.459
2,063.  By the time we'd added 
service worker and service side 

04:29:32.763 --> 04:29:35.841
rendering and we used all these 
content cache ing techniques 

04:29:35.842 --> 04:29:38.779
together, we got to a place 
where we had a speed index of 

04:29:38.780 --> 04:29:40.780
almost a thousand.  Close to 
perfect.

04:29:43.991 --> 04:29:48.079
ow, on 3G, where it's even worse
, we're still in a pretty good 

04:29:48.080 --> 04:29:50.550
place.  We're in a place where 
we started off with a speed 

04:29:50.551 --> 04:29:55.855
index of almost 4,000 and we end
 up with service worker and c

04:29:56.896 --> 04:29:59.359
ontent cache we've got a speed 
of 1400.

04:29:59.448 --> 04:30:02.139
Now, these type experiences, 
this is something that I've done

04:30:02.442 --> 04:30:06.386
 over the last couple of weeks 
on an existing large  React code

04:30:06.554 --> 04:30:08.935
 base.  If you're in a position 
where you have something similar

04:30:09.107 --> 04:30:11.531
 and you want to turn it into a 
progressive Web app, it's very 

04:30:11.532 --> 04:30:15.576
possible.  The tools are just 
there.  I encourage you to try 

04:30:16.426 --> 04:30:18.252
that out.
Next up we have angular JS.  

04:30:18.253 --> 04:30:21.056
Angular is a framework that's 
been around a very long time.  

04:30:21.057 --> 04:30:24.613
It tries to tackle building 
complex applications, originally

04:30:24.614 --> 04:30:27.679
 focused very much around being 
data first and using declare 

04:30:27.993 --> 04:30:30.820
ative HTML and data binding.  
I'm going to talk about angular 

04:30:30.821 --> 04:30:34.028
too.  Before we do that, I know 
there are still people that 

04:30:34.029 --> 04:30:37.328
building on angular one or have 
existing legacy angular one 

04:30:37.329 --> 04:30:40.243
apps.  You might be wondering, a
 lot of this progressive w

04:30:57.452 --> 04:30:58.067
eb app stuff, great, does it 
work with angular one?  Yes, but

04:30:58.068 --> 04:30:58.476
 with caveats         caveats.  
So I tried building an angular 

04:30:58.477 --> 04:30:58.623
1.5 app just to demonstrate
             demonstrate this.  

04:30:58.624 --> 04:30:58.794
I was trying to think of what 
app I would build.  I 

04:30:58.795 --> 04:30:58.889
initial        initially thought
 of building an app that would 

04:30:58.890 --> 04:30:59.067
show me the nearest places I 
could go and sky dive.  Then I 

04:30:59.068 --> 04:31:01.387
realized that I don't sky dive. 
 The closest thing to me 

04:31:01.824 --> 04:31:04.339
skydiving is probably me zooming
 in on a Google map really fast.

04:31:04.340 --> 04:31:07.727
  That's base ically the same 
thing.  So I'm fine with that.

04:31:08.834 --> 04:31:13.176
So this is the app that I built.
  It's called Cherry.  This took

04:31:13.322 --> 04:31:18.025
 an hour or two.  Using angular 
one.  Home screen features, 

04:31:18.026 --> 04:31:20.586
splash screen, offline support 
with service worker       

04:31:20.587 --> 04:31:22.951
worker.  Unfortunately the downs
ide to this app is that it just 

04:31:22.952 --> 04:31:31.382
doesn't meet our performance 
budget.  You take a look at, on 

04:31:31.383 --> 04:31:34.096
3G, where your goals are for 
fast first paint is take     

04:31:34.097 --> 04:31:36.424
taking 2500 milliseconds for f
irst paint in this app.  Our sp

04:31:36.872 --> 04:31:42.870
eed index metrics are 8,400.  
That's crazy.  We shouldn't be t

04:31:42.996 --> 04:31:45.550
ake ing so long for our users to
 be able to start using this 

04:31:46.278 --> 04:31:48.561
application.
Luckily with service worker in 

04:31:48.562 --> 04:31:51.013
place we are able to slash these
 numbers in half.  If you're in 

04:31:51.014 --> 04:31:55.550
a place where you can't in the 
near term move over to rewriting

04:31:55.551 --> 04:31:58.714
 the application to use a modern
 framework, I would consider 

04:31:58.852 --> 04:32:00.966
using service worker.  Still g
oing to get some wins but not 

04:32:00.967 --> 04:32:03.393
quite as good as something that 
has support for service side 

04:32:03.394 --> 04:32:07.851
rendering and is developed with 
mobile in mind.

04:32:07.852 --> 04:32:10.510
That takes us to angular two.  
It's component based, uses 

04:32:10.511 --> 04:32:14.069
directives and has an improved 
dependency injection model.  The

04:32:14.238 --> 04:32:17.525
 angular mobile team have been 
focusing a lot of their time 

04:32:17.526 --> 04:32:20.053
trying to make it easy ier to 
build progressive Web apps using

04:32:20.343 --> 04:32:22.539
 their tooling.  We're going to 
talk a little bit about that.

04:32:22.675 --> 04:32:25.553
Now, to get started with angular
 two apps a lot of the time 

04:32:25.554 --> 04:32:28.140
they'll recommend using the 
angular CLI.  Does everything f

04:32:28.312 --> 04:32:32.771
rom setting up your typescript, 
boot strapping your app, using 

04:32:32.772 --> 04:32:38.022
system JS to load your app.  
It's going to use that to 

04:32:38.023 --> 04:32:42.392
scaffold up a new app.
A new plague to keep in mind is 

04:32:42.393 --> 04:32:45.890
mobile.  Mobile will give you 
all of this:  When you create a 

04:32:45.891 --> 04:32:48.611
new app it's going to give you a
 few extra things to help you 

04:32:48.612 --> 04:32:50.802
make a progress         
progressive Web app.  Going and 

04:32:50.803 --> 04:32:54.043
scaffolding you out a Web 
application manifest, build 

04:32:54.044 --> 04:32:56.950
stuff to show your applications 
root component and service 

04:32:56.951 --> 04:32:58.951
worker support for application 

04:33:01.208 --> 04:33:03.344
cashing.
Things at the home screen are 

04:33:03.345 --> 04:33:06.291
still possible, splash screen, 
ads on home screen icons.  All o

04:33:06.421 --> 04:33:10.204
f those are fleshed out for you.
  The manifest doesn't look too 

04:33:10.205 --> 04:33:12.369
different to the manifest you 
looked at today.  It's exactly 

04:33:12.370 --> 04:33:14.814
what you'd expect it to be.
Now, most of the time when we're

04:33:15.127 --> 04:33:19.313
 developing apps, we use a site 
called real fab con generator

04:33:19.923 --> 04:33:24.897
.net.  Avoids you having to hand
 craft these yourself.

04:33:24.898 --> 04:33:27.004
Next up we've got the 
application shell.  By creating 

04:33:27.005 --> 04:33:31.794
a new project with the angular C
LI and mobile flag, the 

04:33:31.795 --> 04:33:33.170
application already has a build 
step configured to go and 

04:33:33.171 --> 04:33:35.456
generate you an application 
shell from your root component. 

04:33:35.613 --> 04:33:39.392
 Here we're going to use the ma
in component that angular 

04:33:39.393 --> 04:33:42.697
created for us to create a shell
.  We're going to do something 

04:33:42.698 --> 04:33:45.670
with angular material.  Let's 
say we will just add a toolbar 

04:33:45.671 --> 04:33:49.006
to this application.  We MPM in
stall the dependencies we need 

04:33:49.007 --> 04:33:52.170
for this toolbar and then we 
register the toolbar inside of 

04:33:52.171 --> 04:33:57.461
our main Holo mobile component 
in this case.  We see we've got 

04:33:57.758 --> 04:34:00.984
application shell directors 
helping us to set up the shell. 

04:34:01.129 --> 04:34:03.990
 We've got our toolbar in place.
  This isn't particularly useful

04:34:04.156 --> 04:34:07.521
 yet.  We're going to go and add
 in a proper toolbar in there 

04:34:07.522 --> 04:34:12.349
inside of our template.  It says
 hello mobile.  So far this is 

04:34:12.350 --> 04:34:17.293
fine.  Isn't particularly excite
 ing.at is excite ing is these 

04:34:17.294 --> 04:34:22.696
two little helpers.  These two 
helpers are shell render and 

04:34:22.697 --> 04:34:26.576
shell no render.  Shell render 
will allow you to define any UI 

04:34:26.577 --> 04:34:34.784
you want to display on the 
screen before your main bundle 

04:34:34.785 --> 04:34:37.718
-- shell render displayed after 
the entire application is fully 

04:34:37.719 --> 04:34:40.234
rendered out    out.  You can de
fine your application shell 

04:34:40.376 --> 04:34:44.053
dlairttively right inside of 
your component.

04:34:44.110 --> 04:34:47.025
In this case we can do things 
like make sure the toolbar and a

04:34:47.345 --> 04:34:52.241
t least a loading spinner.  That
 thing we wanted to achieve for 

04:34:52.242 --> 04:34:55.296
first paint is in place and we 
can use shell no render for 

04:34:55.297 --> 04:34:59.620
anything that comes after the 
fact.w, the angular mobile t

04:35:00.218 --> 04:35:02.523
oolkit comes with support for 
generating a Service Worker that

04:35:02.524 --> 04:35:05.680
 will automatically cache your 
assets for you.  It doesn't yet 

04:35:05.828 --> 04:35:08.700
entirely support things like 
dynamic cache ing, but it does 

04:35:08.701 --> 04:35:11.130
cache ing for your static assets
.

04:35:11.419 --> 04:35:15.541
And you can go and start using 
these on serve, using the prod 

04:35:15.542 --> 04:35:20.361
flag, on build again using the p
rod flag.  I've been hacking on 

04:35:20.362 --> 04:35:24.074
a little dribble API client 
called Barry using this stuff.  

04:35:24.075 --> 04:35:27.248
I found it particularly good for
 that.  Offline support wasn't 

04:35:27.249 --> 04:35:30.021
difficult to get in place.
And using the CLI it was actual

04:35:30.464 --> 04:35:33.540
ly going to scaffold you out one
 of these files in the 

04:35:33.541 --> 04:35:37.236
background.  Angular Service 
Worker manifest.  It contains b

04:35:37.382 --> 04:35:41.464
ase ically all the files going 
to be cashed as well as a hatch 

04:35:41.465 --> 04:35:45.712
to know Service Worker to let 
you know if they're stale or 

04:35:45.713 --> 04:35:47.565
not.
What do the numbers look like?  

04:35:47.566 --> 04:35:51.432
We're going to take a look at an
 angular weather app that the 

04:35:51.433 --> 04:35:54.617
team had been working on.  This 
uses the application shell model

04:35:55.069 --> 04:35:59.180
, angular CLI, a lot of the 
tooling they've recently been 

04:35:59.181 --> 04:36:02.354
working on.  With Lighthouse 
these are the metrics they 

04:36:02.355 --> 04:36:06.042
currently get.
First paint is about 1,083 

04:36:06.043 --> 04:36:08.043
milliseconds.  That could be b
etter.  Speed index 

04:36:11.109 --> 04:36:15.677
is 2,271.  Repeat visit is 599.
These aren't terrible numbers.  

04:36:15.678 --> 04:36:18.136
Actually pretty good.  But we 
can do better.  Recently the 

04:36:18.137 --> 04:36:21.282
angular mobile team have also 
been looking at offline 

04:36:21.283 --> 04:36:25.000
compilation.  Now, in angular 
one, template compilation can 

04:36:25.001 --> 04:36:28.024
happen many times during your 
application's life cycle.  And 

04:36:28.602 --> 04:36:31.843
angular two tries to move some 
of this work into a build step, 

04:36:31.844 --> 04:36:36.146
make ing it a lot more efficient
.  So offline compilation 

04:36:36.147 --> 04:36:39.132
happens during a build step as I
 said.  It no longer happens 

04:36:39.133 --> 04:36:42.479
during the browser.  We convert 
things like templates into code 

04:36:42.480 --> 04:36:45.425
on the server so we don't have 
to ship the compile er at all.  

04:36:45.426 --> 04:36:47.862
What this leads to in terms of 
application performance is some 

04:36:47.863 --> 04:36:52.107
stark differences.  Fast first 
paint is happening at 479 

04:36:52.108 --> 04:36:54.526
milliseconds.  Speed index, 
almost exactly where we want it 

04:36:54.527 --> 04:36:58.670
to be.  Very close to 1,000.  
And repeat visit is close to 

04:36:58.671 --> 04:37:01.692
nothing.  You're getting base 
ically an instant application on

04:37:01.693 --> 04:37:07.845
 repeat visit.  Kind of awesome.
Now, we also want to take a look

04:37:07.846 --> 04:37:11.064
 at what server side rendering 
would look like for these 

04:37:11.065 --> 04:37:13.794
application.  We can still 
squeeze out more performance 

04:37:13.795 --> 04:37:18.928
here.  Getting your users to 
first view really fast is kind 

04:37:18.929 --> 04:37:21.587
of critical these days.  Angular
 universal base ically helps you

04:37:21.755 --> 04:37:25.973
 achieve this with prerenderring
 on the server.  The way this w

04:37:26.286 --> 04:37:29.621
orks is, whenever a user goes 
and click on a link to your web 

04:37:29.622 --> 04:37:33.717
app, angular universal is going 
to service side render the 

04:37:33.718 --> 04:37:38.209
initial response, get it to you.
  A user at least has a UI in 

04:37:38.367 --> 04:37:41.938
front of them they can look at. 
 A couple seconds later it will 

04:37:41.939 --> 04:37:45.069
async newsily         
news     nously load in the 

04:37:45.070 --> 04:37:48.293
bundle.  This is sometimes c
alled hydration.  It just means 

04:37:48.294 --> 04:37:51.576
you lead yourself to having a 
pretty good perceived load time 

04:37:51.577 --> 04:37:56.329
performance overall.  Some of 
the interesting things I came 

04:37:56.330 --> 04:37:57.584
across in this experience over 
the last couple of weeks was 

04:37:57.585 --> 04:38:02.523
this notion of user events being
 stuck in uncanny valleys is 

04:38:02.524 --> 04:38:06.647
pretty much consistent through 
react, angular and ember.  

04:38:06.648 --> 04:38:09.297
Service side rendering you're 
still going to end up in places 

04:38:09.298 --> 04:38:13.509
where the user can still end up 
clicking, touching pieces of UI 

04:38:13.510 --> 04:38:16.532
where they're trying to have t
hings happen and be stuck until 

04:38:16.533 --> 04:38:20.132
your entire content bundle has 
ended up there.

04:38:20.189 --> 04:38:24.543
So in the angular community, gap
 events is the term they use.  

04:38:24.544 --> 04:38:27.985
Things the user is going to try 
accomplishing while they're 

04:38:27.986 --> 04:38:30.648
still waiting for boot strapping
 to occur.  But thankfully the 

04:38:30.649 --> 04:38:33.361
angular team have been working 
on a interesting solution called

04:38:34.197 --> 04:38:36.458
 pre\boot\boat that base ically 
allows you to respond and p

04:38:36.920 --> 04:38:39.714
layback events.
I'm not saying this is the 

04:38:39.715 --> 04:38:42.602
perfect solution to this problem
.  It's very interesting though.

04:38:42.922 --> 04:38:46.470
  It pht user does try 
interacting with your app, as 

04:38:46.471 --> 04:38:48.525
soon as it finishes b
ootstrapping, it will replay 

04:38:48.686 --> 04:38:51.218
those events for you so they 
still -- they're not having to 

04:38:51.366 --> 04:38:55.594
redo work.  Kind of interesting.
To get this set up again, we use

04:38:55.595 --> 04:38:58.386
 express.  Just import in a
ngular universal.  Doesn't take 

04:38:58.512 --> 04:39:02.220
a lot of work.  And this is what
 the numbers look like.  We 

04:39:02.221 --> 04:39:08.760
start off with a speed index of 
2,640 on 3G.  Once you've added 

04:39:08.761 --> 04:39:11.566
an offline compilation, Service 
Worker, universal rendering, 

04:39:11.567 --> 04:39:15.177
we're down to almost nothing.  
You're in a place where 

04:39:15.349 --> 04:39:17.506
universal render       rendering
 and has made a huge difference.

04:39:17.647 --> 04:39:21.504
  This is very much true of the 
React app we were working on 

04:39:21.505 --> 04:39:23.962
earlier as well.  Service side r
endering makes a really huge 

04:39:24.435 --> 04:39:25.941
difference.
As you can see, with Service 

04:39:25.942 --> 04:39:29.912
Worker in place again,  Repeat 
visit is close to nothing.  

04:39:29.913 --> 04:39:32.698
Users are going to feel it's i
nstant.

04:39:32.804 --> 04:39:36.630
Now, the angular mobile team are
 working on make ing all of the 

04:39:36.631 --> 04:39:39.692
developer conveniences around 
this stuff a lot more low f

04:39:40.023 --> 04:39:42.780
riction.  Some of this work is 
very much early on.  They're 

04:39:42.781 --> 04:39:45.730
working on improving the Service
 Worker support, adding 

04:39:45.731 --> 04:39:49.778
passthrough cache ing support, a
 data savings mode, make ing 

04:39:49.779 --> 04:39:52.971
sure they're looking at HV2 and 
how that interacts with Service 

04:39:52.972 --> 04:39:56.806
Worker and improving the docs.  
If you're working on an angular 

04:39:56.807 --> 04:39:59.014
app, go check out mobile t
oolkit.

04:39:59.188 --> 04:40:04.545
Finally, we have ember JS.  
Ember is a framework for 

04:40:04.546 --> 04:40:07.001
building ambitious Web 
applications.  Utilizes 

04:40:07.002 --> 04:40:12.551
components.  Routing in Ember is
 a core tenant        tenet t

04:40:13.044 --> 04:40:15.806
here.  Similar to the react 
route er works fine on both the 

04:40:15.807 --> 04:40:20.363
client and server.
Now, interestingly frameworks 

04:40:20.364 --> 04:40:28.928
have a bad rap when it comes to 
performance, right?  Henrich Jor

04:40:29.076 --> 04:40:33.776
steg, I think he was talking 
about angular one and ember, 

04:40:33.777 --> 04:40:37.098
disqualify ied them for use.  
This is mainly down to bundle s

04:40:37.417 --> 04:40:41.299
ize.  Ember as a framework has a
 relatively large bundle size.  

04:40:41.300 --> 04:40:44.552
The ember team acknowledge ed 
this a couple months ago and 

04:40:44.553 --> 04:40:46.749
looked at how they could improve
 the situation with Mobile in m

04:40:46.893 --> 04:40:50.030
ind.  They've taken a look at 
both first and repeat boot for 

04:40:50.031 --> 04:40:52.654
this problem.  On first 
\boot\boat they're looking at 

04:40:52.786 --> 04:40:59.254
           look              
           booth      boot.

04:40:59.385 --> 04:41:02.734
On repeat they're looking at S
ervice Worker.  Also look     

04:41:02.735 --> 04:41:06.012
looking at some interesting 
ideas.  String loading which 

04:41:06.013 --> 04:41:09.135
means shipping JavaScript as st
rings so you only pay the 

04:41:09.136 --> 04:41:12.051
valuation cost for modules 
they're using.  And projects f

04:41:12.971 --> 04:41:16.603
elt for streaming back features 
you're not using in Ember.

04:41:16.604 --> 04:41:19.201
I was trying to think about what
 progressive app I built for 

04:41:19.202 --> 04:41:24.219
this and I came across the idea 
of building a puzzle app that 

04:41:24.220 --> 04:41:26.236
would build outside when you're 
complete.  Maybe not the best 

04:41:26.237 --> 04:41:31.895
idea.  Ended up on Zoope cool 
blog.  This is the final thing 

04:41:32.048 --> 04:41:37.557
we ended up building for Ember. 
 Offline first ember application

04:41:37.558 --> 04:41:41.501
 that works instantly, meets our
 performance targets, uses 

04:41:41.502 --> 04:41:45.053
service side rendering.  Works 
without JavaScript enabled, by 

04:41:45.054 --> 04:41:48.102
the way.  Let's take a look at 
how something like this can be 

04:41:48.103 --> 04:41:51.113
constructed.
Applications and Ember are craft

04:41:51.270 --> 04:41:58.345
ed using the Ember CLI.  You 
install it, scaffold out your 

04:41:58.518 --> 04:42:01.817
application architecture, very 
basic file structure.  Go and 

04:42:01.818 --> 04:42:05.707
serve it.  Very basic app out of
 the end of that.w, routes and 

04:42:05.708 --> 04:42:07.975
make ing sure your routes are 
right and you have a good 

04:42:07.976 --> 04:42:10.838
routing setup will make things 
like service side rendering so 

04:42:11.129 --> 04:42:15.992
much easy ier.  We make sure in 
this application we've got our 

04:42:15.993 --> 04:42:18.328
routes figured out.  Base ically
 got very simple routes.  One 

04:42:18.329 --> 04:42:22.023
for different categories we've 
got going on.  One is by 

04:42:22.767 --> 04:42:25.030
articles four.  Off the content 
for this application, actually 

04:42:25.031 --> 04:42:30.178
just exists in JSON files.  I 
could be using a backen API of 

04:42:30.179 --> 04:42:33.043
some sort, just cache ing stuff 
coming back from Firebase.  In 

04:42:33.044 --> 04:42:35.760
this case I have all of my data 
locally.  It makes cache ing 

04:42:35.761 --> 04:42:39.852
easy ier.
This is one of our very basic 

04:42:39.853 --> 04:42:44.807
application looks like.  We've 
used ember CSI, added some CSS, 

04:42:44.808 --> 04:42:47.510
using templates to load in the 
content.  Nothing particularly 

04:42:47.782 --> 04:42:50.533
complex just yet.
Now, the first thing we're going

04:42:50.534 --> 04:42:53.694
 to do is add in the Web app 
manifest.  Similar to the other 

04:42:53.695 --> 04:42:56.399
sites, it's not particularly 
difficult.  It's something that 

04:42:56.400 --> 04:42:59.270
takes five minutes a lot of the 
time.  We add this in.  This 

04:42:59.271 --> 04:43:03.646
makes sure that when the user 
comes to trying to add the site 

04:43:03.647 --> 04:43:06.830
to the home screen or launch it 
they're able to get home screen,

04:43:06.987 --> 04:43:11.657
 splash screen icons in place.
Next up we have Service Worker s

04:43:11.796 --> 04:43:16.183
upport.  About a year ago the 
Ember team said they'd been 

04:43:16.184 --> 04:43:22.662
watching some of Jake ash much 
balanced                   Ar   

04:43:22.663 --> 04:43:28.075
Archibald.  They wanted to take 
platform features and try to 

04:43:28.076 --> 04:43:32.950
make them useable for users with
 stle friction as possible and a

04:43:33.239 --> 04:43:35.701
utomate that process as much as 
they can.  Ember wanted to make 

04:43:35.702 --> 04:43:39.045
this something that's free.  
They're not quite yet there with

04:43:39.046 --> 04:43:42.129
 their baked-in support for 
Service Worker.  The community 

04:43:42.287 --> 04:43:46.214
put together an add Ann for CLI 
called broccoli Service Worker. 

04:43:46.673 --> 04:43:48.791
 One of the cool things about 
broccoli Service Worker, it 

04:43:48.792 --> 04:43:52.037
happens to about bel on top of 
Service Worker toolbox.  That 

04:43:52.038 --> 04:43:55.148
thing we've been using for our 
React app earlier on.  The 

04:43:55.149 --> 04:43:58.268
configuration for this looks a 
little bit like this.  Base 

04:43:58.586 --> 04:44:01.005
ically we're inside our Ember 
environment            

04:44:01.006 --> 04:44:03.121
environment.  I'm just saying I
'd like to make sure D bug 

04:44:03.122 --> 04:44:06.236
messages are enabled and the 
Service Worker is enabled.  But 

04:44:06.237 --> 04:44:10.294
I can actually get control over 
a lot more offline experience.  

04:44:10.295 --> 04:44:13.590
Being able to set things like 
network first URL    URLs, past 

04:44:13.591 --> 04:44:16.975
include and seclude         
exclude.

04:44:17.059 --> 04:44:21.342
When dumbs to Service Worker 
toolbox, you get quite a lot of 

04:44:21.343 --> 04:44:23.343
control over different network 
strategies.  Able to say I'd l

04:44:23.444 --> 04:44:26.187
ike to you go out to the network
 first and then fall back to the

04:44:26.188 --> 04:44:29.378
 cache or use the cache first 
and then fall back to the 

04:44:29.379 --> 04:44:33.072
network or try to race both 
strategies and make sure 

04:44:33.073 --> 04:44:35.625
whichever wins actually delivers
 through the content.  A lot of 

04:44:35.626 --> 04:44:37.961
flexibility there.
Once we have offline support in 

04:44:37.962 --> 04:44:41.430
place, I'm able to launch my 
application in airplane mode and

04:44:41.737 --> 04:44:45.124
 view any of the content I've 
previously seen.  I can go and 

04:44:45.719 --> 04:44:49.695
read articles, look at menu 
items.  All of it just works 

04:44:49.696 --> 04:44:53.600
offline pretty seamlessly.
Now, next up we've got server 

04:44:53.790 --> 04:44:57.491
side rendering with fast      
fastb      fastboot.  When it c

04:44:57.667 --> 04:45:00.859
omes to server side rendering 
and adding it after the fact to 

04:45:00.860 --> 04:45:05.115
a framework level application, 
ember has got this just down to 

04:45:07.067 --> 04:45:11.558
an art when it comes to fastboot
.  I found this easy to set up. 

04:45:11.868 --> 04:45:15.568
 It took very little 
configuration.  Fastboot is a 

04:45:15.569 --> 04:45:17.734
middleware for rendering 
          rendering ember apps 

04:45:17.735 --> 04:45:20.649
on the server        server.  
The idea is in a traditional 

04:45:20.650 --> 04:45:23.359
client side app, browser is 
going to have to request a bunch

04:45:23.655 --> 04:45:26.618
 of static assets from the asset
 server.  While those are load

04:45:26.822 --> 04:45:29.501
     loading, users are going to
 end up having to look at a 

04:45:29.502 --> 04:45:33.520
white screen.  So the way they 
solve this with fastboot is by 

04:45:33.521 --> 04:45:36.813
run    running an instance of 
ember in node on the server.  

04:45:36.814 --> 04:45:39.282
When a request comes in we have 
the app already warmed up in 

04:45:39.283 --> 04:45:42.514
cache and memory.  They tell the
 URL you're trying to reach that

04:45:42.658 --> 04:45:47.360
 you want it rendered on the 
server and send it back down. 

04:45:47.361 --> 04:45:53.757
you instale ember CLI fastboot. 
 The one thing I had to keep in 

04:45:53.758 --> 04:45:56.655
mind was make ing sure that 
anything I'm using that's going 

04:45:56.656 --> 04:46:03.766
to be fetching data from other 
origins or an API takes in mind 

04:46:03.767 --> 04:46:07.434
that you're going to be running 
this code both on the client and

04:46:07.435 --> 04:46:17.156
 server.  You end up needing to 
use ans IOS more     morphic.

04:46:17.462 --> 04:46:22.693
  I ended up using the fetched 
data, any time I fetched it 

04:46:22.694 --> 04:46:25.417
would work fine on both the 
client and server.  I end up 

04:46:25.607 --> 04:46:28.111
with this, service side renderi
ng working fine.  This is 

04:46:28.112 --> 04:46:34.088
working pretty fast on Safari 
and IOS as well.  Might not have

04:46:34.089 --> 04:46:36.554
 Service Worker support yet, but
 service side rendering works 

04:46:36.555 --> 04:46:40.631
fine.
One of the benefits to this is 

04:46:40.632 --> 04:46:43.650
of course that the content from 
application is all just there.  

04:46:43.651 --> 04:46:46.395
I'm not waiting for any 
JavaScript in order for the user

04:46:46.978 --> 04:46:49.868
 to be able to read the a
rticles.  If they're in a place 

04:46:49.869 --> 04:46:52.286
where they have limited network 
connectivity, everything will 

04:46:52.287 --> 04:46:56.442
just work.
Another benefit is this works 

04:46:56.443 --> 04:47:00.424
without jaive       JavaScript 
enabled as well.  You might be 

04:47:00.425 --> 04:47:03.336
wondering, great, I can read 
content, but what about my user 

04:47:03.337 --> 04:47:07.333
UI?  I spent a little bit of 
time recrafting the drawer menu 

04:47:07.334 --> 04:47:10.565
for this application entirely in
 CSS, and that just means that 

04:47:10.719 --> 04:47:14.699
my user is able to use some UI 
with the content in place, even 

04:47:14.700 --> 04:47:17.881
if my JavaScript bundle is still
 loading with the rest of the 

04:47:17.882 --> 04:47:21.453
framework.
And then we've got a little bit 

04:47:21.454 --> 04:47:24.961
of final performance 
optimization to squeeze as much 

04:47:24.962 --> 04:47:27.561
as we can out at the very end.  
This is what our index looks 

04:47:27.562 --> 04:47:29.229
like for this application 
           application.  It's u

04:47:29.230 --> 04:47:33.659
sing some template helpers.e of 
the things I want to add is 

04:47:33.660 --> 04:47:38.179
critical path CSS we talked a
bout earlier for the application

04:47:38.180 --> 04:47:42.213
 shell.
We install an add-on called 

04:47:42.214 --> 04:47:47.207
imperC       ember CLI content. 
 We can figure that in the build

04:47:47.661 --> 04:47:50.089
.  For this application it's not
 got a lot of styles.  I don't 

04:47:50.242 --> 04:47:53.408
need to do anything special to 
get my critical path CSS.  I'm 

04:47:53.409 --> 04:47:57.232
going to inline the entire style
 sheet inside my document head.

04:47:59.950 --> 04:48:05.265
Finally we've got that one 
problem of large framework still

04:48:05.853 --> 04:48:08.276
 being large frameworks.  
Unfortunately this is something 

04:48:08.277 --> 04:48:12.674
the frameworks still have to 
solve on their own.   Embore 

04:48:12.675 --> 04:48:18.632
before UGs a bit is almost 700 
bill bites                700 

04:48:18.633 --> 04:48:23.478
kill bites in size.  I don't 
want that to block rendering.  I

04:48:23.479 --> 04:48:25.894
 would have myvendor script as 
well as the main application 

04:48:25.895 --> 04:48:29.261
code for my app.  But in this 
case I'm probably going to have 

04:48:29.562 --> 04:48:33.094
to use something like defer 
because ember can't make scripts

04:48:33.245 --> 04:48:40.517
 for you by default.  We've got 
things like J something inside 

04:48:40.518 --> 04:48:44.757
the application.
Also something we can take care 

04:48:44.896 --> 04:48:48.893
of.  Allows script fob 
downloaded without blocking the 

04:48:48.894 --> 04:48:52.677
page.  Defer claims to do the 
same thing except it's supposed 

04:48:53.129 --> 04:48:58.017
to guarantee script execution 
order.  The spec says that it 

04:48:58.018 --> 04:48:59.889
should be download         
downloading all of your scripts 

04:48:59.890 --> 04:49:03.124
together and execute ing them 
before DOM content loaded.  

04:49:03.125 --> 04:49:04.819
Unfortunately in some other 
browsers that's not exactly the 

04:49:04.820 --> 04:49:09.492
case.  In IE less than ten.  It 
might execute your second script

04:49:09.493 --> 04:49:13.368
 halfway through the execution o
f your first script.  Yea 

04:49:13.369 --> 04:49:19.684
browsers.  But we're still going
 to use defer in this case to 

04:49:19.685 --> 04:49:23.763
avoid blocking.
But at the very end of all of 

04:49:23.927 --> 04:49:26.381
this, so we've got service side 
rendering in place, Service 

04:49:26.382 --> 04:49:31.979
Worker in place as well.  We've 
taken speed index of almost 

04:49:31.980 --> 04:49:34.355
3,000, trimmed it down with s
ervice side rendering           

04:49:34.356 --> 04:49:35.856
rendering using fast food, 
trimmed it down with the 

04:49:35.857 --> 04:49:41.234
optimizations we've made even 
further.  In repeat visit it's c

04:49:41.378 --> 04:49:43.505
lose to instant, close to 
nothing.

04:49:43.506 --> 04:49:47.772
Now, I'm really excite ed about 
the ember team exploring how to 

04:49:47.773 --> 04:49:50.190
bake in these ideas directly 
into the CLI.  I'm also excite e

04:49:50.288 --> 04:49:52.382
xcite ed about the angular team 
doing this and really excite ed 

04:49:52.383 --> 04:49:57.016
about the react community 
embracing Service Worker as a 

04:49:57.017 --> 04:49:59.017
core tenet

04:50:12.309 --> 04:50:13.022
 in the applications we're 
building there as well.

04:50:13.023 --> 04:50:13.821
So three take aways for today 
are:  Do less and be lazy     

04:50:13.822 --> 04:50:14.333
lazy.  If you're going to be 
trying to ship bytes down to 

04:50:14.334 --> 04:50:17.747
your users, try to ship the thin
nest, smallest bundle possible. 

04:50:18.236 --> 04:50:21.602
 This will benefit absolutely 
everyone.  And be lazy just 

04:50:21.721 --> 04:50:23.718
means lazy ily load in 
everything else that you need a

04:50:23.719 --> 04:50:27.406
fter the fact.
Design for constrained envir

04:50:27.691 --> 04:50:30.208
onments.  You know, a lot of the
 time we're building things 

04:50:30.209 --> 04:50:33.901
these days, we're testing things
 out on high-end phones or 

04:50:33.902 --> 04:50:37.242
computers.  A lot of our users 
aren't going to have that.  

04:50:37.243 --> 04:50:38.907
They're not going to have a 
perfect Internet connection all 

04:50:38.908 --> 04:50:41.767
the time.  They're going to be 
in places where they'll have 

04:50:41.768 --> 04:50:46.320
limited connectivity, maybe 
using devices that are like CPU 

04:50:46.321 --> 04:50:50.237
bound or aren't as powerful as 
things we're testing on.

04:50:50.364 --> 04:50:53.779
If you're developing with c
onstrained environments in mind,

04:50:53.999 --> 04:50:56.554
 you're going to be able though 
ship experience that is benefit 

04:50:56.555 --> 04:51:00.072
everyone, hopefully lead to 
performance improvements there.

04:51:00.162 --> 04:51:03.444
And go for progressive.  Because
 now is a good time.  Looking at

04:51:03.736 --> 04:51:05.857
 all the frameworks and 
libraries we've been looking at 

04:51:05.858 --> 04:51:08.713
today, all of them are exploring
 things like server side r

04:51:08.863 --> 04:51:12.380
endering.  All of them have got 
the ability to use Service 

04:51:12.381 --> 04:51:15.862
Worker as a first class citizen 
and have it work well and lead 

04:51:15.863 --> 04:51:19.906
to performance improvements, 
have it lead to reliable 

04:51:19.907 --> 04:51:22.170
performance.  That thing we're t
rying to hit with the rest of 

04:51:22.171 --> 04:51:27.472
Web apps.  Everything else, from
 like setting up your Web app 

04:51:27.473 --> 04:51:31.106
manifest and so on, that stuff 
is still quite trivial to do.  

04:51:31.107 --> 04:51:33.370
And it's not to say that instant
 application            

04:51:33.371 --> 04:51:36.167
applications with things I've 
shown you today are the end; i

04:51:36.456 --> 04:51:38.913
t's really just the beginning.  
There's still a bit of work we 

04:51:38.914 --> 04:51:43.317
have to do on both the jaive 
      JavaScript engine and 

04:51:43.318 --> 04:51:45.544
framework side when it comes to 
performance after the fact.  

04:51:45.545 --> 04:51:49.610
I've been focusing on load 
performance a lot today.  

04:51:49.611 --> 04:51:53.286
There's stale lot we can do 
after the fact so when your user

04:51:53.287 --> 04:51:55.608
 is interacting with the app it 
still stays instant after that.

04:51:57.267 --> 04:52:00.645
So please go check out our new 
progressive Web app page or our 

04:52:00.646 --> 04:52:06.524
Web fundamentals.  I hope this 
has been useful.  Thank you.

04:52:06.564 --> 04:52:08.564
[

04:56:10.145 --> 04:56:12.145
 APPLAUSE ]

04:58:07.637 --> 04:58:09.637
       2 p.m....

04:58:11.740 --> 04:58:14.273
 MW5 - How AMP Achieves its 
Speed 2 p.m.

05:09:12.916 --> 05:09:16.973
[ Applause ]
&gt;&gt; MALTE: Hi, everyone.  My name

05:09:17.165 --> 05:09:20.939
 is Malte and I'm the tech lead 
for Google.  That means that I 

05:09:20.940 --> 05:09:24.409
kind of manage the team that 
works full-time on the open 

05:09:24.410 --> 05:09:27.619
source project for Google and I 
kinda also wrote some of the 

05:09:27.620 --> 05:09:31.666
code, I guess.  Which is 
important because we want to 

05:09:31.667 --> 05:09:37.997
dive into how it works today and
 how it achieves the speed.  So 

05:09:37.998 --> 05:09:40.380
even if ample might not be for 
you because you're working on an

05:09:41.440 --> 05:09:44.560
 online batching app or 
whatever, you can take advantage

05:09:44.673 --> 05:09:48.656
 of the techniques we use and 
make your own thing way faster 

05:09:48.657 --> 05:09:55.895
than it might be right now.  So 
I said AMP, it sands for 

05:09:55.896 --> 05:09:58.612
accelerated pages       pages 
and I'm never going to say it 

05:09:58.613 --> 05:10:02.891
again, now you know what it 
means.  It's about super fast 

05:10:02.892 --> 05:10:09.099
content on the Web.  Now AMS an 
open source project launched 

05:10:09.100 --> 05:10:11.710
inside Google in our search 
engine, which most of you 

05:10:11.711 --> 05:10:16.805
probably used every so often.  
And we have this carousel here. 

05:10:17.026 --> 05:10:21.595
 It just boom goes up.  So load 
times are way, way faster than 

05:10:21.596 --> 05:10:25.522
we see on the normal Web.  And 
you can swipe the results and 

05:10:25.523 --> 05:10:28.304
that's something you dock with 
an every day Web page.  So that 

05:10:28.305 --> 05:10:31.910
is AMP.  You can go to your 
browser and switch

05:10:35.441 --> 05:10:36.036
 for something you see and you 
should see these AMP results.

05:10:36.037 --> 05:10:43.996
So, AMS pretty fast but we 
haven't talked that much about 

05:10:43.997 --> 05:10:45.488
how fast it is.  And frankly we 
didn't know.  It was an 

05:10:45.489 --> 05:10:50.064
experiment but it's been out 
there for a while now.  This is 

05:10:50.065 --> 05:10:54.608
what we sorry across all traffic
 where Google Search is leading 

05:10:54.609 --> 05:11:00.467
to AMP results.  Sowed meetian 
load time is under one second.  

05:11:00.468 --> 05:11:04.699
The exact number is 711.  It is 
pretty substantially under one 

05:11:04.700 --> 05:11:07.766
second.  Which if yow heard 
about rail and that is like 

05:11:07.767 --> 05:11:15.199
really where you want to be.  
But, one important part of 

05:11:15.200 --> 05:11:16.787
performance optimization is that
 you can't only look at your 

05:11:16.788 --> 05:11:20.861
median user.  That is important 
because 50% have a better 

05:11:20.862 --> 05:11:25.849
experience and 50% are worse.  
So what we typically do is look 

05:11:25.850 --> 05:11:29.787
at the percentile of users that 
have a really bad Internet 

05:11:29.788 --> 05:11:34.330
connection loading the biggest 
Web page.  And so for them, we 

05:11:34.331 --> 05:11:39.212
are still seeing load times 
faster than 8 seconds.  Which 

05:11:39.213 --> 05:11:42.933
might seem slow and I find slow 
and I'm not happy with, but if 

05:11:42.934 --> 05:11:48.772
you look at the control group of
 similar pages that are not AMP,

05:11:49.023 --> 05:11:54.512
 they have average load time of 
22 seconds.  So the 1% worst AMP

05:11:54.873 --> 05:11:58.812
 loads are still much better 
than the average non--AMP loads.

05:11:58.915 --> 05:12:02.644
  Which I think it is pretty 
exciting.  And all of this, like

05:12:02.841 --> 05:12:06.412
 the one second that we see at 
the median is obviously not 

05:12:06.413 --> 05:12:09.852
instant but for a technique that
 I'm going explain today, called

05:12:10.670 --> 05:12:15.571
 pre-rendering, you go from fast
 to instant.

05:12:16.156 --> 05:12:21.612
A number we mentioned yesterday 
is there is quite some momentum 

05:12:21.613 --> 05:12:25.696
around AMP.  And so looking at 
Google Search index, there is a 

05:12:25.697 --> 05:12:31.169
crazy number of 125 million Docs
 and growing every day.  And 

05:12:31.170 --> 05:12:34.824
obviously this could be like 
only Wikipedia but what I find 

05:12:34.825 --> 05:12:37.678
more exciting and pretty 
humbling is that there is 

05:12:37.679 --> 05:12:43.046
apparently 640,000 Web pages 
already different domains who in

05:12:43.322 --> 05:12:46.577
 some form or another 
implemented AMP.  Which is 

05:12:46.578 --> 05:12:50.553
really cool.  And it's Earl I.  
It's an open source project and 

05:12:50.554 --> 05:12:54.727
we are shipping new releases 
every week.  Very recently we 

05:12:54.728 --> 05:13:00.230
finally supported menus which I 
agree is an important feature.  

05:13:00.231 --> 05:13:04.100
We are working on Forms and 
supporting all kinds of features

05:13:04.535 --> 05:13:09.023
 like pretty advanced like fly 
and side templating.

05:13:09.183 --> 05:13:14.470
On the next slide, this is my 
favorite technology aboutasm.  

05:13:14.471 --> 05:13:19.082
Look at this.  The average 
mobile site in the back.  It's 

05:13:19.083 --> 05:13:23.766
not winning.  And what I find 
important to emphasize is that 

05:13:23.767 --> 05:13:26.877
if you're pan tuning your site, 
you are going to win this race. 

05:13:27.492 --> 05:13:31.628
 AMP is not about winning this 
race but AMP is about being up 

05:13:31.629 --> 05:13:36.376
there in front.  And more 
importantly, all AMP pages are 

05:13:36.377 --> 05:13:38.895
pretty uniformly up there in 
front.

05:13:39.191 --> 05:13:43.567
And I think if there is anything
 seek ressauce to how this works

05:13:43.568 --> 05:13:45.878
 -- secret sauce -- it probably 
my answer

05:13:49.026 --> 05:13:55.149
 is going to be the AMP 
validator.  This is how this 

05:13:55.150 --> 05:14:02.006
really looks.  So you can go to 
every page and add development 

05:14:02.007 --> 05:14:05.782
equals 1 to the UR R and you 
will get these error messages or

05:14:07.044 --> 05:14:11.467
 hopefully none.  But they are 
just like compiling errors.  

05:14:11.468 --> 05:14:14.177
Because we are developers and we
 are used to this, like for us 

05:14:14.178 --> 05:14:18.101
it's like a to-do list.  We are 
like cool.  I'm just going to 

05:14:18.102 --> 05:14:20.670
fix them.
That is awesome.  The other 

05:14:20.671 --> 05:14:26.821
affect this has and I might just
 speak from personal opinion, 

05:14:26.822 --> 05:14:28.781
that sometimes you might like 
have some disagreements about 

05:14:28.782 --> 05:14:36.239
what the right thing to do is 
and so, in this case, the AMP 

05:14:36.240 --> 05:14:42.622
validator can say that's not a 
good idea.  So going from the 

05:14:42.623 --> 05:14:45.277
basic stuff, let's go into how 
AMP works.

05:14:45.869 --> 05:14:49.693
So we developed this new 
rendering engine for documents 

05:14:49.694 --> 05:14:53.931
which no, we did not because why
 would you?  I think it's 

05:14:53.932 --> 05:14:59.759
amazing we are in 2016 and all 
these browser and they are all 

05:14:59.760 --> 05:15:02.814
great.  And looking back 10 
years that was not the case.  So

05:15:02.815 --> 05:15:07.749
 I think we are in exciting 
times for development.  You 

05:15:07.750 --> 05:15:13.504
don't really have to wor I about
 browsers anymore.  And so AMPs 

05:15:13.505 --> 05:15:18.078
are just Web pages.  They don't 
have a special rendering engine.

05:15:18.189 --> 05:15:22.480
  Just Web pages.  And that is 
why everything that AMP is doing

05:15:23.294 --> 05:15:28.990
 internal tow gain performance 
is equally applicable to all 

05:15:28.991 --> 05:15:32.110
non--AMP Web pages.
Diving into what is going on 

05:15:32.111 --> 05:15:36.295
there, I want to talk about 
front loading.  And I have to 

05:15:36.296 --> 05:15:41.083
tell you a secret.  And I hope 
my friend from the Chrome team 

05:15:41.084 --> 05:15:46.137
aren't mad about me but here it 
is.  Browsers really hate Web 

05:15:46.138 --> 05:15:49.662
fonts.  By the way this is my 
son and he is extremely 

05:15:49.663 --> 05:15:53.141
unimpressed with like the Web in
 general.  You'll see throughout

05:15:53.594 --> 05:15:57.607
 this presentation.  So here is 
what is going on.  That is why 

05:15:57.608 --> 05:16:02.893
I'm saying they hate Web fonts. 
 Apparently, developers 

05:16:02.894 --> 05:16:05.158
sometimes put like font face 
annotations in their CSS that 

05:16:05.159 --> 05:16:10.442
they don't really use on their 
page.  The browser really is 

05:16:10.443 --> 05:16:14.511
careful about downloading fonts.
What they do is look at your CSS

05:16:14.684 --> 05:16:18.360
 and then they look at all the 
other CSS and then look at your 

05:16:18.361 --> 05:16:22.915
JavaScript and then apply the 
styles to the page.  And at the 

05:16:22.916 --> 05:16:26.283
very moment where they like 
could have rendered the page, 

05:16:26.284 --> 05:16:33.426
they go, okay, I'm going to 
network and fetch the font.  And

05:16:33.538 --> 05:16:37.180
 Chrome, and FireFox will wait 
three seconds, Safari will wait 

05:16:37.181 --> 05:16:40.503
forever.  So the font is 
entirely in the critical path of

05:16:41.145 --> 05:16:43.522
 rendering your page.  So 
getting that optimized is 

05:16:43.523 --> 05:16:46.508
extremely critical for good Web 
performance.

05:16:47.971 --> 05:16:51.415
Summarizing all your style 
Sheets and all your synchronous 

05:16:51.416 --> 05:16:56.430
strips that are in the hat 
block, font, download.  In code 

05:16:56.431 --> 05:17:01.188
that means if you have a script 
source or style sheet, those 

05:17:01.189 --> 05:17:04.489
will slow down fonts from even 
being started to put on the 

05:17:04.490 --> 05:17:09.121
network.
Now, AMP has certain rules about

05:17:09.696 --> 05:17:14.333
 how it likes HTML to look and 
for this reason, what we say is,

05:17:14.447 --> 05:17:17.933
 you can have style Sheets but 
they have to be in line in the 

05:17:17.934 --> 05:17:22.396
style type.  And yes, they can 
be script text but they do need 

05:17:22.397 --> 05:17:26.695
to have the attributes which 
then takes it out of the 

05:17:26.696 --> 05:17:29.854
critical path and browser will 
happily try to render the page 

05:17:29.855 --> 05:17:34.813
and they'll have the fonts.  The
 result of that is that AMP can 

05:17:34.814 --> 05:17:37.138
having downloaded the document, 
which is important for rendering

05:17:37.584 --> 05:17:43.082
 it, initiate the HTP request 
for the fonts with zero HTP 

05:17:43.083 --> 05:17:48.283
request in the critical path 
which is a big improvement for 

05:17:48.284 --> 05:17:50.180
performance.
So there is a problem, though.  

05:17:50.181 --> 05:17:55.572
And that is why this slide 
exists.  This slide is trumped 

05:17:55.573 --> 05:17:58.171
down.  It looks much, much worse
 in reality because there is 

05:17:58.172 --> 05:18:03.635
window prefixes going on.  So 
every AMP document contains this

05:18:04.618 --> 05:18:06.994
 bit of foil page.  While I 
think it is pretty cool 

05:18:06.995 --> 05:18:10.618
technique, it has some problems.
  What is going on?  Because of 

05:18:10.619 --> 05:18:13.978
the strip tags have the acing 
attributes, some of them are 

05:18:13.979 --> 05:18:18.026
actually needed to render the 
page, you would get incomplete 

05:18:18.027 --> 05:18:20.966
render early in the life cycle 
which looks not very good.

05:18:22.317 --> 05:18:27.177
And so, one common technique to 
avoid that is to manually hide 

05:18:27.178 --> 05:18:30.513
the page by saying, for example,
 visibility hidden, and then 

05:18:30.514 --> 05:18:34.515
when the script loads, say okay,
 now it is visible.  So while 

05:18:34.516 --> 05:18:38.501
that works, it has one important
 downside.  If for example your 

05:18:38.502 --> 05:18:41.300
network fails that the 
millisecond and that strip never

05:18:42.251 --> 05:18:45.962
 downloads, it could happen that
 the page stays completely blank

05:18:46.734 --> 05:18:49.179
 because it says it should be 
blank.  And that is why I think 

05:18:49.180 --> 05:18:52.781
this is such a brilliant idea 
which came from like some person

05:18:53.251 --> 05:18:57.084
 commenting on a GitHub issue.  
Why don't you use a CSS 

05:18:57.085 --> 05:19:00.354
animation as a time load 
mechanism?  So what is going on 

05:19:00.355 --> 05:19:05.402
here is that AMP will go and 
after eight seconds, show the 

05:19:05.403 --> 05:19:10.100
page if the JavaScript fails to 
load.  So typically the 

05:19:10.101 --> 05:19:13.828
JavaScript is much, much faster 
and very likely could be 

05:19:13.829 --> 05:19:16.827
attached so you would never 
reach that but it is very 

05:19:16.828 --> 05:19:22.024
important that you have this 
extra robustness for the page 

05:19:22.025 --> 05:19:24.632
will eventually show if there is
 no JavaScript.

05:19:24.986 --> 05:19:29.223
Great.  So with that, I want to 
talk about my favorite topic 

05:19:29.224 --> 05:19:34.122
which is static but responsive 
layout.  So, for this, I'm going

05:19:34.693 --> 05:19:41.979
 to show you a little video and 
I'm going ask you to read the 

05:19:41.980 --> 05:19:43.980
text.

05:19:45.494 --> 05:19:49.232
  Please read me -- this is a 
nowing when an

05:19:53.764 --> 05:19:55.820
 element -- - annoying -- when I
 was first thinking about AMP, I

05:19:57.703 --> 05:20:02.439
 had this one idea that this is 
really the worst thing on the 

05:20:02.440 --> 05:20:06.505
Internet.  And if I would do 
anything at all, in AMP, I would

05:20:06.829 --> 05:20:14.101
 make it so just this would 
never ever happen.  And now I'm 

05:20:14.102 --> 05:20:17.995
going explain to you why it 
can't happen.  And it's again 

05:20:17.996 --> 05:20:23.457
pretty simple.  So in AMP, every
 single element has to have its 

05:20:23.458 --> 05:20:27.248
size defined in the mark up and 
it is much easier to see what 

05:20:27.249 --> 05:20:33.057
that means in code.  So if you 
use this Web component called 

05:20:33.058 --> 05:20:37.138
AMP-image to look at images, and
 you can lease out the width and

05:20:37.524 --> 05:20:40.213
 height, it is mandatory on this
 Web component.  What will 

05:20:40.214 --> 05:20:44.593
happen in a browser is when it 
has an image tag and no height 

05:20:44.594 --> 05:20:48.981
on it, it will say it is 
probably zero pixel high and 

05:20:48.982 --> 05:20:52.097
then it will fetch it and then 
go it's not zero pixel high.  

05:20:52.098 --> 05:20:55.969
Why would an image be zero pixel
 high and then everything moves 

05:20:55.970 --> 05:20:59.657
down.  So what is mandatory with
 the height, a browser can put a

05:20:59.922 --> 05:21:04.570
 box and then fill it in when it
 is time to have the image back 

05:21:04.571 --> 05:21:10.329
from the network.
Now with this requirement of put

05:21:12.347 --> 05:21:15.119
 the width and height and source
 cold, how does this work 

05:21:15.120 --> 05:21:18.772
together with responsive design 
and I want to emphasize that AMP

05:21:19.026 --> 05:21:21.996
 is from the ground up designed 
with responsive design in mind. 

05:21:22.256 --> 05:21:26.295
 Here is the answer.  And that 
is a great example of how Web 

05:21:26.296 --> 05:21:29.603
components can be really, really
 nice in Web developments.  All 

05:21:29.604 --> 05:21:33.113
you do is put layout equals 
responsive on the element and 

05:21:33.114 --> 05:21:36.482
what AMB will do, it will say 
thank you for the width and 

05:21:36.483 --> 05:21:40.857
height, I'm going to use that to
 populate the aspect ratio and 

05:21:40.858 --> 05:21:45.872
size the image to the available 
space horizontally and make the 

05:21:45.873 --> 05:21:48.304
height based on the aspect 
ratio.

05:21:49.889 --> 05:21:55.430
So, coming from this, there are 
those situations where you can't

05:21:55.574 --> 05:21:59.542
 predict the size.  Again this 
is also a nice example of the 

05:21:59.543 --> 05:22:04.008
collaboration on the open source
 project where I initially was 

05:22:04.009 --> 05:22:07.987
like, you're out of luck.  You 
can't do anything.  And then 

05:22:07.988 --> 05:22:11.463
publishers were, sometimes we do
 kind of need to resize things 

05:22:11.464 --> 05:22:15.804
so we gave in and came up with a
 pretty good model to make it 

05:22:15.805 --> 05:22:22.419
work nonetheless.
So when AMP thinks about a page,

05:22:22.828 --> 05:22:25.915
 it considers things based on 
where they are relative to the 

05:22:25.916 --> 05:22:28.911
position of the viewport.  The 
view sport what you currently 

05:22:28.912 --> 05:22:32.833
see.  So if you already scrolled
 down, some stuff above and 

05:22:32.834 --> 05:22:36.058
there is always probably if a 
page is longer than the 

05:22:36.059 --> 05:22:39.920
viewport, there will be 
something below.  And so, if 

05:22:39.921 --> 05:22:43.101
something is below the viewport 
and it says I would like to be 

05:22:43.102 --> 05:22:46.524
bigger than originally planned, 
then AMP says that is cool 

05:22:46.525 --> 05:22:49.638
because that can't really affect
 what is in the viewport.  

05:22:49.639 --> 05:22:53.049
Similarly, but slightly more 
nifty, if it's above the 

05:22:53.050 --> 05:22:57.402
viewport, you can still allow 
resizing because you can know 

05:22:57.403 --> 05:23:02.135
how the height changed and you 
can just subtract that from 

05:23:02.136 --> 05:23:05.725
scroll top and end up having 
everything in viewport staying 

05:23:05.726 --> 05:23:10.698
in the same spot as before.
But finally we come to stuff 

05:23:10.699 --> 05:23:16.143
that is currently in viewport 
and there AMS pretty 

05:23:16.144 --> 05:23:19.966
opinionated, you can not resize 
it.  That is until user actually

05:23:20.364 --> 05:23:22.557
 interacted with that element.  
So, what you can do for example,

05:23:22.661 --> 05:23:27.221
 if you need to resize, AMP will
 say no, but you can show a 

05:23:27.222 --> 05:23:31.825
little button to say like, allow
 resize and then AMP will say, 

05:23:31.826 --> 05:23:35.132
user agreed that is fine and 
from that moment on that thing 

05:23:35.133 --> 05:23:39.473
can change little size however 
it wants.

05:23:40.082 --> 05:23:45.989
Great so from that I want to 
talk about the next topic.  So, 

05:23:45.990 --> 05:23:51.122
AMP is designed so it knows very
 little like about how to do 

05:23:51.123 --> 05:23:55.277
anything.  It can load images 
and simple videos and text 

05:23:55.278 --> 05:23:58.296
obviously but that is about it. 
 And for everything else there 

05:23:58.297 --> 05:24:03.415
is extensions which are just Web
 components you load.  Think 

05:24:03.416 --> 05:24:07.025
about Tweets, Instagrams, 
YouTube videos all kinds of 

05:24:07.026 --> 05:24:11.424
stuff.  There is dozens of them.
  So to load them put the script

05:24:11.623 --> 05:24:15.132
 tag on your page.  It has the 
same attribute so that it 

05:24:15.133 --> 05:24:21.729
doesn't block your page and then
 you put this in this case, 

05:24:21.730 --> 05:24:25.251
AMP-YouTube tag on your page.  
It has to be width and height 

05:24:25.252 --> 05:24:29.053
which is pretty typical for a 
video typically.  And then but 

05:24:29.054 --> 05:24:33.560
the thing with Web components 
is, when the browser sees this 

05:24:33.561 --> 05:24:38.451
like AMP does YouTube and hasn't
 learned what it means, it will 

05:24:38.452 --> 05:24:43.607
go, HMMM, let's draw it like a 
spam.  I don't know what width 

05:24:43.608 --> 05:24:47.744
and height means.  Let's make it
 in-line element.  And that is 

05:24:47.745 --> 05:24:52.267
not the best default and it 
leads to the same kind of affect

05:24:52.268 --> 05:24:56.054
 of the page jumping around.
And it is so bad that from is 

05:24:56.055 --> 05:25:01.755
even a name for it.  So the 
flash of unstyle Web components.

05:25:01.870 --> 05:25:07.856
  And there is several ways how 
to work around it.  The easiest 

05:25:07.857 --> 05:25:11.928
way is to just wait for the 
extensions to load.  That will 

05:25:11.929 --> 05:25:16.060
be similar to a technique we are
 using to wait for the main 

05:25:16.061 --> 05:25:21.451
script to load which is the 
visibility hidden and visible 

05:25:21.452 --> 05:25:25.374
thing I explained.
But, we want to do better.  

05:25:25.375 --> 05:25:28.574
Because some more complex pages 
might have 10 extensions and now

05:25:29.554 --> 05:25:33.369
 you have to make a request to 
finish for something to be 

05:25:33.370 --> 05:25:39.231
shown.  They pile up.  So 
instead, AMP can render the page

05:25:39.372 --> 05:25:43.063
 before all extensions are 
loaded and here is how it works.

05:25:43.160 --> 05:25:48.961
So, the core AMP JavaScript 
library, the one that is 

05:25:48.962 --> 05:25:53.311
blocking page layout, it knows 
how to layout elements even 

05:25:53.312 --> 05:25:55.891
though it has no videos.  So it 
goes and says, I

05:25:59.289 --> 05:25:59.560
 actually know what widthing and
 height means and what layout 

05:25:59.561 --> 05:26:03.732
responsive means and what fixed 
height means and it will draw a 

05:26:03.733 --> 05:26:08.590
box.  It's not actually great 
but it can make it CSS obviously

05:26:08.731 --> 05:26:13.787
 and then eventually, that 
YouTube extension downloads and 

05:26:13.788 --> 05:26:17.919
then that YouTube extension will
 say fill in that box.  And that

05:26:18.274 --> 05:26:23.565
 is a load behavior that we are 
all used to because that is how 

05:26:23.566 --> 05:26:28.412
images usually load on they and 
people perceive it as a decent 

05:26:28.413 --> 05:26:31.619
experience.
So to summarize, in AMP, the 

05:26:31.620 --> 05:26:34.294
extension siding is independent 
from their implementation.  So 

05:26:34.295 --> 05:26:38.061
you don't have to know what 
YouTube is to make a box for, 

05:26:38.062 --> 05:26:40.995
tube video.  The extension 
loaded with a script so they 

05:26:40.996 --> 05:26:44.821
don't block anything.  The box 
is reserved immediately and then

05:26:45.029 --> 05:26:50.110
 filled with content when the 
extension loads.

05:26:51.251 --> 05:26:53.401
Coming from this pretty 
AMP-specific thing, I want to 

05:26:53.402 --> 05:26:57.591
come to a topic that is really 
applicable to every single Web 

05:26:57.592 --> 05:27:03.246
app out there.  And that is 
mutation fetching.  There is a 

05:27:03.247 --> 05:27:06.639
simple rule that everyone should
 follow.  You shouldn't 

05:27:06.640 --> 05:27:10.686
interleaf reading and writing to
 the DOM.  Unfortunately, it is 

05:27:10.687 --> 05:27:14.470
really hard to do this in 
practice.  Here is a contrived 

05:27:14.471 --> 05:27:20.057
but not that unrealistic example
 of about how to do this.  So, 

05:27:20.058 --> 05:27:26.775
your code might say win doe 
something.  Besides that it 

05:27:26.776 --> 05:27:26.959
would set the height of 
something and it will say, how 

05:27:26.960 --> 05:27:31.276
high are you?  And then you say 
like this other thing has to be 

05:27:31.277 --> 05:27:36.645
sides as well and what is your 
height?  Right?  So, this you 

05:27:36.646 --> 05:27:39.306
might not write code looic this 
but if you have a team of more 

05:27:39.307 --> 05:27:42.801
than one person and there is 
more than one thing on the page 

05:27:42.802 --> 05:27:46.131
going on you're getting into a 
situation where in each 

05:27:46.132 --> 05:27:49.788
animation frame you might do 
various operations that are 

05:27:49.789 --> 05:27:53.874
acting on various parts of a 
page.  And it comes with a big 

05:27:53.875 --> 05:27:59.160
problem.  Which is that browsers
 when you read from the DO.

05:27:59.267 --> 05:28:03.247
And say like what is your 
height?  Or what is your width? 

05:28:03.248 --> 05:28:06.372
 Or any of these like things 
that require laying out the 

05:28:06.373 --> 05:28:10.722
page, they trigger recall 
declaration of style which means

05:28:11.284 --> 05:28:18.471
 that how does the CSS affect 
the page layout on the DOM 

05:28:18.472 --> 05:28:22.953
elements -- recall declaration 
-- and so that triggers the 

05:28:22.954 --> 05:28:25.539
style application and if you 
want to make an application that

05:28:25.695 --> 05:28:29.075
 runs at 60 frames per second, 
you might be able to afford two 

05:28:29.076 --> 05:28:34.116
of those even though you really 
shouldn't but at 3 your mobile 

05:28:34.117 --> 05:28:37.600
device will pass out and say I'm
 beginning to jinx the hell out 

05:28:37.601 --> 05:28:41.361
of this.  Fortunately there is a
 very easy waway to make this 

05:28:41.362 --> 05:28:44.856
better.  Which is it to 
absolutely change the order in 

05:28:44.857 --> 05:28:48.981
which operations are executed.
So like here, if you first do 

05:28:48.982 --> 05:28:53.520
all the rights, and then you do 
all the reads for the DOM, there

05:28:53.986 --> 05:28:57.110
 is exactly one style 
calculation triggered and as you

05:28:57.615 --> 05:29:03.922
 can see, it's pretty easy to 
match unlimited number of 

05:29:03.923 --> 05:29:06.543
operations.  It's really hard to
 manually write an application 

05:29:06.544 --> 05:29:11.527
that is larger than one file to 
adhere to such a strict rule.  

05:29:11.528 --> 05:29:16.507
So that is why there are helpful
 libraries that make it easy.  

05:29:16.508 --> 05:29:22.307
If you are ever looking at the 
AMP source code, it has a 

05:29:22.308 --> 05:29:25.224
library and it says, I'm going 
to execute all the measures and 

05:29:25.225 --> 05:29:31.557
then I'll execute all the mew 
talks and there is a popular 

05:29:31.558 --> 05:29:35.301
library called FastDOM that does
 a similar thing and it really 

05:29:35.302 --> 05:29:41.030
helps withizey API to make the 
DOM operations execute in ideal 

05:29:41.031 --> 05:29:42.844
order.
With that I want to move to the 

05:29:42.845 --> 05:29:50.054
next topic which is Analytics.  
So obviously Analytics is really

05:29:50.249 --> 05:29:53.480
 important like you want to know
 how many people come to your 

05:29:53.481 --> 05:29:57.561
app, what they are doing, where 
are they clicking, how much time

05:29:57.711 --> 05:30:03.183
 they spend and how they scroll 
and that is really great but 

05:30:03.184 --> 05:30:10.558
what happens is sometimes more 
of them come in and I have this 

05:30:10.559 --> 05:30:13.816
like, went through this myself 
where you like talk to the sales

05:30:14.043 --> 05:30:17.865
 person from a vendor and they 
say like we have this awesome 

05:30:17.866 --> 05:30:24.842
new metric and I'm like, yes!
So we are -- and you realize a 

05:30:24.843 --> 05:30:29.883
new vendor like that is one 
thing you always reported to 

05:30:29.884 --> 05:30:33.976
your mother-in-law slightly 
dipped.  And then you realize 

05:30:33.977 --> 05:30:39.184
users there is not less users, 
it's just that that new vendor 

05:30:39.185 --> 05:30:44.678
terps that metric different so 
you panic and put the whole 

05:30:44.679 --> 05:30:48.276
thing back in.  So in practice, 
that happens all the time and so

05:30:48.429 --> 05:30:52.630
 we are seeing Sites that have 
like 5, 10, 15 of these.  And it

05:30:53.602 --> 05:30:57.193
 turns out that basically too 
much of everything is really bad

05:30:57.573 --> 05:31:02.999
 for performance.  However, we 
challenge ourselves thinking 

05:31:03.000 --> 05:31:08.828
there is really very the you can
 do about this being a problem 

05:31:08.829 --> 05:31:13.011
so would there be a way to have 
both?  So essentially, 

05:31:13.012 --> 05:31:17.163
all-you-can-eat Analytics and 
still have good performance.

05:31:17.341 --> 05:31:22.606
And the solution that seems 
relatively obvious in retrospect

05:31:22.862 --> 05:31:29.098
 is to separate instrumentation 
from reporting.  So in AMP, the 

05:31:29.099 --> 05:31:31.986
instrumentation so the thing 
that measures your scroll 

05:31:31.987 --> 05:31:36.830
progress, that measures clicks, 
exists only once and it is built

05:31:37.079 --> 05:31:42.515
 into AMP and then it can report
 stuff so however many times you

05:31:42.711 --> 05:31:48.091
 as a developer choose.  So, 
basically what is the deal is 

05:31:48.092 --> 05:31:54.162
that AMP knows how to talk to 
major Analytics vendors and then

05:31:54.472 --> 05:31:59.399
 just basically pings them and 
says user scrolled and they 

05:31:59.400 --> 05:32:02.020
interpret that information.  And
 if you have for example 

05:32:02.021 --> 05:32:05.373
in-house Analytics or AMP 
doesn't directly support your 

05:32:05.374 --> 05:32:08.830
favorite vendor, add config 
yourself.  This is how it looks 

05:32:08.831 --> 05:32:14.873
on the open source project.  So 
just randomly chose this and 

05:32:14.874 --> 05:32:20.283
this describes how to create a 
request when you track a 

05:32:20.284 --> 05:32:25.326
picture.  There is just a rule 
saying use this and then put 

05:32:25.327 --> 05:32:31.395
this stuff on the back.  And so,
 basically it's just a 

05:32:31.396 --> 05:32:35.014
configuration that says given an
 event, how to construct a URL 

05:32:35.015 --> 05:32:40.764
so that score tracks that as a 
page view and this file is long 

05:32:40.765 --> 05:32:45.410
and for every major vendor has a
 small rule set and that is how 

05:32:45.411 --> 05:32:50.377
you can like talk to them all 
but only pay the costs of 

05:32:50.378 --> 05:32:56.645
figuring out when you need to 
talk to them exactly once.

05:32:56.956 --> 05:33:01.388
With that, from Analytics I want
 to go to the final topic and it

05:33:01.683 --> 05:33:06.333
 is slightly different bauds it 
doesn't necessarily apply to the

05:33:06.467 --> 05:33:09.235
 general Web.  That is instant 
loading.  As already like I 

05:33:09.236 --> 05:33:12.363
talked about very quickly at the
 beginning, instant loading is 

05:33:12.364 --> 05:33:19.954
achieved through pre-rendering. 
 And pre-rendering means that 

05:33:19.955 --> 05:33:26.349
you render something before the 
user said I want to go there.  

05:33:26.350 --> 05:33:29.865
So, on a Google Search result 
that would mean we think they 

05:33:29.866 --> 05:33:33.970
probably click on the first 
result.  It's not the worst 

05:33:33.971 --> 05:33:36.846
guess.  So let's render it 
already.  And that obviously 

05:33:36.847 --> 05:33:40.970
comes to some problems, right?  
Because the user might not go 

05:33:40.971 --> 05:33:44.644
there but now you already used 
that bandwidth and that CPU and 

05:33:44.645 --> 05:33:49.348
the mobile CPU means battery and
 that RAM to render the page and

05:33:49.592 --> 05:33:53.657
 that could be problematic.  And
 it was in fact that so 

05:33:53.658 --> 05:33:58.120
problematic that the native 
version of rendering, is 

05:33:58.121 --> 05:34:02.995
essentially unusable on mobile.
Now, to solve this problem we 

05:34:02.996 --> 05:34:06.339
went through a series of 
insights that led us from it 

05:34:06.340 --> 05:34:10.130
being essentially impossible to 
working really well.  And the 

05:34:10.131 --> 05:34:12.961
first insight which is by the 
way the most important insight 

05:34:12.962 --> 05:34:17.034
when you think about performance
 optimizations in general, is 

05:34:17.035 --> 05:34:21.396
that humans are kind of slow.  
And I mean that in the best 

05:34:21.397 --> 05:34:28.456
possible way.  So our reaction 
time is in the order of two 

05:34:28.457 --> 05:34:34.829
seconds.  So, from that you can 
say in order to appear instant, 

05:34:34.830 --> 05:34:39.377
you only have to appear instant.
  You don't have to be actually 

05:34:39.378 --> 05:34:43.116
be all the way done.  And here 
is what that means in practice. 

05:34:43.215 --> 05:34:48.366
 So this is a typical website, 
right?  It's not.  Because this 

05:34:48.367 --> 05:34:50.943
is a typical website.  It's 
really long.

05:34:51.961 --> 05:34:55.541
But, for something to appear as 
having loaded instantly, the 

05:34:55.542 --> 05:34:59.613
only thing that is really 
important is that the thing that

05:34:59.778 --> 05:35:05.922
 I see when I go to the page is 
already done.  Everything else 

05:35:05.923 --> 05:35:09.698
because reaction time is like, I
 can start downloading all the 

05:35:09.699 --> 05:35:12.812
other images for example, that 
instant where I show the page, 

05:35:12.813 --> 05:35:17.268
where the user clicks it.  What 
AMP does. when it is in 

05:35:17.269 --> 05:35:21.306
prerender mode, it will say any 
resource that isn't visible by 

05:35:21.307 --> 05:35:26.015
the user, the instant the page 
is shown to them, will not be 

05:35:26.016 --> 05:35:30.562
downloaded at all during 
prerender mode.  So that saves 

05:35:30.563 --> 05:35:36.138
all the bandwidth that is -- 
wouldn't have been necessary in 

05:35:36.139 --> 05:35:40.168
a case where the user never goes
 to that page.  It's typical for

05:35:40.518 --> 05:35:44.611
 a page to maybe have like one 
image or two images in the first

05:35:44.852 --> 05:35:48.282
 report but overall the pages 
have many, many more images so 

05:35:48.283 --> 05:35:53.794
not downloading them saves a lot
 of bandwidth.  That leaves the 

05:35:53.795 --> 05:35:59.495
harder problem, which is CP.
And RAM usage on mobile.  Which 

05:35:59.496 --> 05:36:04.112
is a big, big problem.
And in AMP,

05:36:08.497 --> 05:36:09.710
 it is relatively well optimized
 so we are pretty confident that

05:36:09.711 --> 05:36:14.674
 CPU usage of AMP itself is 
okay.  But loading all these 

05:36:14.675 --> 05:36:19.218
bits, so it might be YouTube 
videos Instagrams, et cetera.  

05:36:19.219 --> 05:36:22.996
So first of all AMP doesn't 
control them and to be honest, 

05:36:22.997 --> 05:36:31.387
some of them do a lot of CPU.  
And for this reason, AMP does

05:36:33.048 --> 05:36:36.266
 this.  That was all the way 
clear?  I can do it again.  So 

05:36:36.267 --> 05:36:41.208
when AMP prerenders a document, 
it will not actually load any of

05:36:41.462 --> 05:36:45.190
 the extensions implementation. 
 So in the YouTube case you can 

05:36:45.191 --> 05:36:50.098
do really well because you can 
guess the post URLs.  So it will

05:36:50.251 --> 05:36:54.021
 put a poster on the page so it 
looks complete but the expensive

05:36:54.526 --> 05:36:59.385
 part, the YouTube iframe that 
loads JavaScript isn't actually 

05:36:59.386 --> 05:37:04.289
loaded.  So when the user then 
expresses intent that they want 

05:37:04.290 --> 05:37:09.392
to go to the page, AML go and 
say, we'll load the YouTube 

05:37:09.393 --> 05:37:12.710
iframe because they might want 
to watch the video.  But the 

05:37:12.711 --> 05:37:17.647
page looks pretty complete and 
so that user gets it 

05:37:17.648 --> 05:37:20.170
gratification that everything is
 done even though in fact not 

05:37:20.171 --> 05:37:25.717
everything is done.
And so with this leaves two 

05:37:25.718 --> 05:37:29.024
techniques, only loading stuff 
that is actually visible and 

05:37:29.025 --> 05:37:33.018
only loading stuff we know the 
CP.

05:37:33.146 --> 05:37:36.185
And RAM use sage relatively 
minimal.  You get the capability

05:37:36.843 --> 05:37:40.664
 to prerender pages on mobile 
where it is really feasible with

05:37:41.079 --> 05:37:47.836
 a general Web page.
So again, like you have seen 

05:37:47.837 --> 05:37:52.050
initially with the development 
equals 1.  Put a fragment 

05:37:52.051 --> 05:37:54.051
parameter

05:37:55.243 --> 05:37:59.443
 on anymore document.  Try this 
in a browser and say prerender 

05:37:55.243 --> 05:37:58.688
equals one.  And that puts any 
AMP document in prerender mode. 

05:37:58.813 --> 05:38:00.813
 And you'll see

05:38:03.303 --> 05:38:07.303
 it's not useful for yourself 
because there won't be images 

05:38:03.303 --> 05:38:06.076
loaded that aren't in the 
initial viewport.  So scroll 

05:38:06.077 --> 05:38:11.465
down and nothing loads.  Same 
thing with other things.  The 

05:38:11.466 --> 05:38:16.520
page as far as first viewport 
goes, looks very complete.  And 

05:38:16.521 --> 05:38:20.202
then there is a message API 
where you can tell the page 

05:38:20.203 --> 05:38:24.548
you're now being shown to a 
person.  Go loadering else.

05:38:25.309 --> 05:38:30.516
And that together gets that -- 
that is how Google Search work. 

05:38:31.336 --> 05:38:34.746
 So it would load an iframe and 
tell tell you're in prerender 

05:38:34.747 --> 05:38:38.513
and then when the user clicks it
 send a post message saying 

05:38:38.514 --> 05:38:42.377
you're being shown.  Go crazy 
loading everything you need.

05:38:42.590 --> 05:38:45.919
And with that, that was kind of 
all I wanted to talk about in 

05:38:45.920 --> 05:38:51.830
terms of optimization.  I wrote 
this blog post a while ago.  And

05:38:51.831 --> 05:38:56.419
 I do have the URL again at the 
end which goes through the 

05:38:56.420 --> 05:39:00.205
entire list of optimizations 
that all AMP page vs. and I like

05:39:01.282 --> 05:39:03.505
 to say they can't not have it 
because

05:39:06.622 --> 05:39:09.631
 AMP guarantees it.  But can be 
used as a nice resource all the 

05:39:09.632 --> 05:39:17.132
things that might apply to a 
non-AMP Web page.  Still I 

05:39:17.133 --> 05:39:19.691
personally am very impatient and
 I'm not satisfied at all with 

05:39:19.692 --> 05:39:25.165
the speed of AMP.  So, what is 
your favorite AMP site?

05:39:28.809 --> 05:39:32.809
The it's still too slow.  It 
might use an extension that is 

05:39:28.809 --> 05:39:32.581
not very optimized or you might 
find that you find some case 

05:39:32.582 --> 05:39:35.713
where did is slow.  That is the 
most exciting thing about AMP 

05:39:35.714 --> 05:39:41.877
which is that you can help.  As 
an open source project, send a 

05:39:41.878 --> 05:39:45.414
request and we are shipping 
every week.  So, I think it is 

05:39:45.415 --> 05:39:48.830
pretty amazing that you have 
this level of impact because 

05:39:48.831 --> 05:39:52.559
every AMP page runs the latest 
version.  So if you send a page 

05:39:52.560 --> 05:39:56.720
to AM.  And saw it was like 
460,000 domains using it, a week

05:39:57.263 --> 05:40:04.073
 later, they will all run your 
poll request.  So make a big 

05:40:04.074 --> 05:40:06.644
difference and what I like to 
say is that this has been 

05:40:06.645 --> 05:40:09.489
working so far.  And we really 
want to thank all of you for 

05:40:09.490 --> 05:40:17.270
sending these contributions.  
So, AMP wanted to GitHub last 

05:40:17.271 --> 05:40:21.906
October and we so far got tone 
1,954 requests.  But what is 

05:40:21.907 --> 05:40:26.967
even nice ser that it comes from
 160 different contributors.  

05:40:26.968 --> 05:40:32.037
So, I have a team, not 160, not 
even close.  So it has been a 

05:40:32.038 --> 05:40:34.692
really, really cool 
collaborative effort and again 

05:40:34.693 --> 05:40:36.983
thank you all because we 
wouldn't have been able to do it

05:40:37.158 --> 05:40:41.872
 without you.
A few more things in terms of 

05:40:41.873 --> 05:40:45.790
bookkeeping because I really 
want to point to this.  It's not

05:40:46.056 --> 05:40:50.861
 a book but I thought it was 
funny.  So this website called 

05:40:50.862 --> 05:40:57.451
AMP by example.com and so I 
personally I know JavaScript, 

05:40:57.452 --> 05:41:00.284
not the best Web developer and 
this is just like examples for 

05:41:00.285 --> 05:41:04.944
all the things you might do in 
AMP and it is like output and 

05:41:04.945 --> 05:41:09.191
the source code and copy paste 
yourself to happiness.  It's 

05:41:09.192 --> 05:41:12.232
really useful if you want to get
 started with AMP.  Another 

05:41:12.233 --> 05:41:16.005
shout out is that Google 
yesterday launched an AMI called

05:41:16.280 --> 05:41:18.280
 the

05:41:19.887 --> 05:41:22.591
 AMPURLAPI.
This is applicable to you if you

05:41:22.894 --> 05:41:26.970
 have either a Web app or native
 app that has links and you 

05:41:26.971 --> 05:41:30.371
might want to say it is good for
 all users if we pointed them to

05:41:30.473 --> 05:41:35.997
 the A MP version of those URLs.
  So you can say hey, is there 

05:41:35.998 --> 05:41:40.278
an A MP version for this and 
they will say yes or no.

05:41:42.279 --> 05:41:45.671
Coming from this it was first 
shown yesterday and it's a topic

05:41:46.023 --> 05:41:49.691
 I'm super excited about.  So, 
my talk is almost over.  I would

05:41:50.224 --> 05:41:56.325
 ask all of you to go to the 
theater after this 3 p.m. where 

05:41:56.326 --> 05:42:01.832
Alex will talk about how AMP 
relates to progressive WebEx.  

05:42:01.833 --> 05:42:05.392
And they work really well 
together.  A nice demo yesterday

05:42:05.511 --> 05:42:12.118
 in the "Washington Post" which 
totally impressed me.  Anyway, 

05:42:12.119 --> 05:42:17.122
that is all I have.  Here is the
 link to our Docs.  Our GitHub, 

05:42:17.123 --> 05:42:19.373
and again the blog posts.  Thank
 you very much.

05:42:19.374 --> 05:42:21.374
[ Applause ]

05:56:22.155 --> 05:56:22.715
 FB22 - 5 Neat Mobile 
Development Tricks with Google  

05:56:22.716 --> 05:56:24.716
3PM

06:09:12.292 --> 06:09:17.388
    3PM.
&gt;&gt; TODD: Hi, everybody.  We got 

06:09:17.389 --> 06:09:21.852
-- hi, everybody!
Wow!

06:09:22.480 --> 06:09:26.867
Like last section on the last 
day and we still have people 

06:09:26.868 --> 06:09:30.908
that are awake.  
Congratulations.  We made it to 

06:09:30.909 --> 06:09:33.857
the last session on the last day
 of the conference.  I don't 

06:09:33.858 --> 06:09:38.660
know about you, but I kind of 
feel like this guy.  Maybe you 

06:09:38.661 --> 06:09:42.595
feel like this guy too maybe 
because your brain is full or 

06:09:42.596 --> 06:09:48.571
you partied too hard last night 
or like me, you woke up at 4:00 

06:09:48.572 --> 06:09:52.315
in the morning and couldn't go 
back to sleep.  Either way, 

06:09:52.316 --> 06:09:55.322
congratulations.  Thank you for 
being awake and alert and a good

06:09:55.890 --> 06:09:58.483
 audience.  I already can tell, 
you're going to be a great 

06:09:58.484 --> 06:10:01.656
audience.  So let's talk about 
Firebase.  As you may have 

06:10:01.657 --> 06:10:06.704
heard, Firebase is aviette of 
integrated products designed to 

06:10:06.705 --> 06:10:10.231
help you earn money.  Maybe we 
mentioned that before.  And we 

06:10:10.232 --> 06:10:13.086
have been calling it a suite but
 for a lot of these talks I feel

06:10:13.281 --> 06:10:16.764
 like we generally have been 
talking about features in 

06:10:16.765 --> 06:10:20.610
isolation and for this session 
what I'd like to do is show you 

06:10:20.611 --> 06:10:24.364
some of the cool tricks that you
 can do when have the various 

06:10:24.365 --> 06:10:27.536
features of the new Firebase 
platform working together in a 

06:10:27.537 --> 06:10:32.293
few hypothetical scenarios and 5
 neat tricks you can do with the

06:10:32.490 --> 06:10:37.668
 new Firebase platform.  Let's 
look at those now.  #trick 

06:10:37.669 --> 06:10:43.837
Number 1.  I'm with the band or 
Dynamic Links plus -- equals 

06:10:43.838 --> 06:10:47.756
notification goodness.  Let's 
start off by talking about our 

06:10:47.757 --> 06:10:51.819
brand new ticket app, ticket 
picker.  The hot new way for you

06:10:52.023 --> 06:10:55.534
 to get tickets on certain 
baseball games.  And they 

06:10:55.535 --> 06:11:01.134
decided as a good market ploy to
 draw users in, they will set up

06:11:01.601 --> 06:11:05.433
 a companion site where you can 
read news and gossip and get 

06:11:05.434 --> 06:11:09.794
tour dates about your favorite 
bands and sort of a way to draw 

06:11:09.795 --> 06:11:12.876
people in to draw people in, 
they will add a nice button that

06:11:13.373 --> 06:11:16.676
 says, if you're interested in 
getting tickets for the rolling 

06:11:16.677 --> 06:11:19.801
stones, then click on this 
button and try out our app.  By 

06:11:19.802 --> 06:11:24.428
the way, I'd like to point out 
that is difficult to draw a 

06:11:24.429 --> 06:11:28.695
scope.  I then just looks like a
 sad pancake but that is why I'm

06:11:29.252 --> 06:11:32.638
 a Developer Advocate not an 
artist.

06:11:32.854 --> 06:11:37.277
So this sounds like a situation 
for Dynamic Links.  If you know 

06:11:37.278 --> 06:11:40.224
what Firebase Dynamic Links are,
 they are mobile deep links that

06:11:40.414 --> 06:11:44.750
 work the way you want them to. 
 With one link that we can put 

06:11:44.751 --> 06:11:48.516
on our site, we can either take 
the user to the iOS or the 

06:11:48.517 --> 06:11:52.304
Android version of their app if 
they have it in signaled and if 

06:11:52.305 --> 06:11:56.947
they don't have it installed, we
 can take them to the app or 

06:11:56.948 --> 06:12:00.477
play store and if the user had 
to install our app first, 

06:12:00.478 --> 06:12:03.577
Firebase Dynamic Links can 
retrieve that original Lincoln 

06:12:03.578 --> 06:12:06.352
text and remember what link user
 clicked on to get them into the

06:12:06.944 --> 06:12:11.005
 app in the first place so we 
can deliver the user a first 

06:12:11.006 --> 06:12:14.465
time experience that is relevant
 to the link they clinked on.  

06:12:14.466 --> 06:12:17.323
So rather than showing a boring 
homepage, we know they installed

06:12:18.139 --> 06:12:22.488
 our app because they are 
interested in the rolling cones 

06:12:22.489 --> 06:12:25.605
and maybe we can show them 
information that is relevant 

06:12:25.606 --> 06:12:29.184
that way.  So the link to try 
out to get into our app would 

06:12:29.185 --> 06:12:33.734
look a little like this.
And I can break it down for you 

06:12:33.735 --> 06:12:37.655
if you're not familiar with 
Dynamic Links and you probably 

06:12:37.656 --> 06:12:40.452
aren't.  First we added these 
entries for the appropriate play

06:12:40.672 --> 06:12:45.640
 and App Store IDs as well as 
your iOS bundle identifier.  

06:12:45.641 --> 06:12:48.815
This lets us know which place in
 the play store or App Store to 

06:12:48.816 --> 06:12:51.675
redirect the user if they don't 
have the app installed.  We also

06:12:51.882 --> 06:12:55.485
 will add in these UTM tracking 
tags and if you don't know what 

06:12:55.486 --> 06:12:58.587
they are, they are sort of 
hierarchal way of representing 

06:12:58.588 --> 06:13:01.951
any kind of marketing campaign. 
 So you have got like your Uber 

06:13:01.952 --> 06:13:05.346
spring 2016 campaign and then 
within that, you have your 

06:13:05.347 --> 06:13:08.705
various sources, like the 
companion website or maybe an 

06:13:08.706 --> 06:13:12.645
e-mail blast and that sort of 
thing and various content and 

06:13:12.646 --> 06:13:15.658
medium.  You can break it down 
in different ways.

06:13:16.075 --> 06:13:18.958
And all that information will 
get captured in Firebase 

06:13:18.959 --> 06:13:23.916
Analytics when the user clicks 
on this Deeplink.  And then we 

06:13:23.917 --> 06:13:26.655
have the link parameter itself 
and this is the information that

06:13:26.817 --> 06:13:30.778
 gets passed into your app when 
it first opens up.  And in this 

06:13:30.779 --> 06:13:33.460
case, we are deciding that we 
are going to capture the band 

06:13:33.461 --> 06:13:36.669
that the user was browsing when 
they decided to click on this 

06:13:36.670 --> 06:13:39.636
link.  So, we know that the 
featured band here happens to be

06:13:40.001 --> 06:13:42.931
 the rolling cones and that will
 be able to realize when we 

06:13:42.932 --> 06:13:47.833
process this URL.  So by 
analyzing this link information,

06:13:47.948 --> 06:13:50.494
 we first opened the app instead
 of our sign in page, our app 

06:13:50.495 --> 06:13:53.519
can analyze that link parameter 
and say the user was interested 

06:13:53.520 --> 06:13:58.180
in our app because they were 
looking at a page for the 

06:13:58.181 --> 06:14:01.269
rolling cones so maybe we should
 show them relevant info and 

06:14:01.270 --> 06:14:05.619
then we show a bunch of dates 
when they first open our app 

06:14:05.620 --> 06:14:08.377
instead of that sign in screen.
This is important.  The user 

06:14:08.378 --> 06:14:11.333
said I'm willing to go ahead and
 install your app because I'm 

06:14:11.334 --> 06:14:14.486
super interested in this data.  
So why not make sure they can 

06:14:14.487 --> 06:14:18.332
get that data they are 
interested in right away?  And 

06:14:18.333 --> 06:14:22.328
so this is dynamics and maybe 
you been this.  But we also do a

06:14:22.634 --> 06:14:26.477
 lot more with this link and 
knowing what that featured band 

06:14:26.478 --> 06:14:29.129
was.  For instance, our app can 
automatically subscribe the user

06:14:29.375 --> 06:14:33.870
 to the rolling scopes Firebase 
Cloud Messaging topic.  If you 

06:14:33.871 --> 06:14:38.231
want to know what topics are, 
they are ad-hoc Groups that any 

06:14:38.232 --> 06:14:41.463
client can subscribe to on the 
Cloud Messaging server.  So 

06:14:41.464 --> 06:14:45.942
basically we can tell the Cloud 
Messaging server, send this 

06:14:45.943 --> 06:14:49.576
message to any client that 
subscribed themselves to this 

06:14:49.577 --> 06:14:53.970
topic, rolling cones orb any 
other band.  Firebase Cloud 

06:14:53.971 --> 06:14:56.126
Messaging kept track of which 
clients subscribed themselves to

06:14:56.276 --> 06:15:00.197
 that topic and it can send the 
inform to all the devices 

06:15:00.198 --> 06:15:04.074
without your having to keep 
track if it on your server 

06:15:04.075 --> 06:15:07.344
somewhere.  So when the rolling 
cones decide we are going to 

06:15:07.345 --> 06:15:11.729
make new ticket sales available,
 you can schedule a future 

06:15:11.730 --> 06:15:14.186
message through Firebase 
Notifications.  You can see here

06:15:14.536 --> 06:15:17.929
 that in addition to sending a 
message we can scheduling a 

06:15:17.930 --> 06:15:20.065
message to be sent at a 
particular time.  And schedule

06:15:23.523 --> 06:15:26.738
 messages in a specific time 
zone because tickets are going 

06:15:26.739 --> 06:15:30.763
on sale 9 a.m. all across the 
world globally.    We can ma 

06:15:30.764 --> 06:15:34.043
make sure that notification gets
 sent out globally so everyone 

06:15:34.044 --> 06:15:36.561
has a chance to get tickets 
before they sell out.  And then 

06:15:36.562 --> 06:15:41.459
we are sending this set of 
Notifications to devices that 

06:15:41.460 --> 06:15:45.274
have subscribed to the rolling 
cones topic and then we can also

06:15:45.418 --> 06:15:49.659
 capture conversion even here.  
So, various events in Firebase 

06:15:49.660 --> 06:15:51.945
Analytics that are important to 
your app like being able to 

06:15:51.946 --> 06:15:56.386
purchase a ticket, you can tell 
by these Analytics, let's make 

06:15:56.387 --> 06:15:59.397
these one version events that we
 really care about.

06:16:00.171 --> 06:16:03.381
And then so you can track 
whether a notification has led a

06:16:03.738 --> 06:16:07.759
 user to complete one of these 
events.  And this is really 

06:16:07.760 --> 06:16:12.628
important for daughter-in-lawing
 whether your Notifications are 

06:16:12.629 --> 06:16:18.325
being -- important for knowing 
whether your Notifications are 

06:16:18.326 --> 06:16:22.661
spammy.  If very few people are 
opening them and not completing 

06:16:22.662 --> 06:16:26.757
a ticket purchase, maybe it's 
spammy.  If you targeted your 

06:16:26.758 --> 06:16:28.569
Notifications correctly, then 
the percentage of people who get

06:16:28.570 --> 06:16:31.279
 the notification open it and 
then go ahead and complete a 

06:16:31.280 --> 06:16:35.124
purchase will be much higher and
 that is a good way of judging 

06:16:35.125 --> 06:16:37.819
whether or not these 
notifications are effective.  

06:16:37.820 --> 06:16:40.884
And this in coming band is also 
seems like a pretty good 

06:16:40.885 --> 06:16:42.971
starting value for a user 
property of like the

06:16:46.649 --> 06:16:50.649
 user's favorite band.  Maybe we
 can change that on the app 

06:16:46.649 --> 06:16:47.941
later.
This seems like a good starting 

06:16:47.942 --> 06:16:51.819
point and then we can do a lot 
of floaters Firebase Analytics 

06:16:51.820 --> 06:16:56.248
based on the favorite fans bands
 of our users like the number of

06:16:56.401 --> 06:16:58.896
 people who said, yes, I'm 
interestedded in reviewing this 

06:16:58.897 --> 06:17:04.201
app and we can facility they're 
by various user properties 

06:17:04.202 --> 06:17:05.602
included their favorite band so 
we can see for everybody who 

06:17:05.603 --> 06:17:09.224
listed the rolling cones as 
their favorite band, how many of

06:17:09.514 --> 06:17:12.534
 them decided they were okay 
reviewing my app?  So we can get

06:17:12.684 --> 06:17:16.002
 a better idea of how these 
different bands of different 

06:17:16.003 --> 06:17:18.749
bands behave and if we say we 
really need more people 

06:17:18.750 --> 06:17:23.920
reviewing our app and it turns 
out that bands or the rolling 

06:17:23.921 --> 06:17:30.484
cones are more likely to review 
our app than fans of W2, we can 

06:17:30.485 --> 06:17:32.485
figure that out in Firebase 
Analytics.

06:17:32.796 --> 06:17:36.718
And then because we used all of 
these UTM tags to record all the

06:17:37.122 --> 06:17:40.536
 Deeplink info, we can evaluate 
the performance of the companion

06:17:40.877 --> 06:17:44.122
 site.  We can look at all of 
the companion site users and see

06:17:44.379 --> 06:17:47.396
 how they behave not just did 
they click on these links to get

06:17:47.592 --> 06:17:51.428
 into our app but are they more 
or less likely to perform these 

06:17:51.429 --> 06:17:55.495
important conversion actions 
like buying a ticket, like 

06:17:55.496 --> 06:17:59.473
subscribing to our newsletter, 
like signing up for premium 

06:17:59.474 --> 06:18:04.029
service like sharing the app 
with our friends.  So when the 

06:18:04.030 --> 06:18:08.033
CEO says we seem to be spending 
a lot of money on this companion

06:18:11.186 --> 06:18:13.263
 site, we can say yes, it is 
getting us users which we know, 

06:18:13.264 --> 06:18:16.278
but we can also decide it's 
getting us users that are 

06:18:16.279 --> 06:18:19.457
valuable to us because they are 
buying tickets or sending the 

06:18:19.458 --> 06:18:23.607
app to their friends.  And maybe
 it's because that nice Deeplink

06:18:23.769 --> 06:18:26.123
 experience is giving them a 
better experience and they are 

06:18:26.124 --> 06:18:28.395
more interested in our app in 
the first place.  That say lot 

06:18:28.396 --> 06:18:33.321
you can do by adding in one 
Dynamic Link to your banners.

06:18:33.442 --> 06:18:38.179
I'm going to move to trick 
number 2.  Birds of a feather.O 

06:18:38.180 --> 06:18:41.647
Firebase authentication plus the
 Realtime Database plus Storage 

06:18:41.648 --> 06:18:46.501
equals some group photo sharing.
  This one gets into some crazy 

06:18:46.502 --> 06:18:50.468
rules here but stick with me.  
So this is our fun bird watching

06:18:50.848 --> 06:18:54.749
 app, birdie hunt.  They decided
 they will add a new feature for

06:18:55.081 --> 06:18:58.404
 users to be able to share 
photos of birds they found with 

06:18:58.405 --> 06:19:03.634
the public.  Like I found a good
 pick of a chickadee and I say 

06:19:03.635 --> 06:19:07.306
everybody check out this 
picture.  And so, clearly in 

06:19:07.307 --> 06:19:10.766
seems like a good use case for 
Firebase Storage.  A place where

06:19:10.995 --> 06:19:14.644
 we can store all of our photos 
in the Cloud.  That is what it 

06:19:14.645 --> 06:19:21.343
was made for storing large data.
  People used to like base 64 in

06:19:21.946 --> 06:19:26.858
 this data and stick it in the 
Realtime Database now.  Guilty. 

06:19:26.990 --> 06:19:32.552
 This is way better.  Now when 
we do that, when we basically 

06:19:32.553 --> 06:19:36.691
add a -- up load a file to 
Storage, in the completion 

06:19:36.692 --> 06:19:40.420
handler what you'll get back is 
metadata and among that metadata

06:19:40.538 --> 06:19:44.660
 one of the most important 
things is a download URL to the 

06:19:44.661 --> 06:19:49.823
a file you uploaded.  The U are.
  L of the file plus tokens.  

06:19:49.824 --> 06:19:52.536
But this is what you're going to
 have to be able to download 

06:19:52.537 --> 06:19:55.579
that photo.
And then we can store these URLs

06:19:55.696 --> 06:19:59.795
 in the database.  We can create
 an album photos object and 

06:19:59.796 --> 06:20:03.400
create a different object for 
each different album and within 

06:20:03.401 --> 06:20:06.469
there create photos with the 
name and URL and just like that,

06:20:06.645 --> 06:20:10.340
 people can see our photo 
albums.  Which sounds great but 

06:20:10.341 --> 06:20:15.288
it turns out I didn't know this,
 bird watching Groups are very 

06:20:15.289 --> 06:20:17.875
cutthroat and competitive.  They
 didn't want other Groups to see

06:20:18.084 --> 06:20:21.394
 the photos they took.  They 
only wanted to share with other 

06:20:21.395 --> 06:20:24.138
people in their bird watching 
group.  Who knew?  We can still 

06:20:24.139 --> 06:20:29.019
do that.  Partly by taking 
advantage of Firebase sign in 

06:20:29.020 --> 06:20:31.615
which allows you to sign in your
 user from a number of different

06:20:32.284 --> 06:20:35.767
 providers.  We have Google and 
Facebook and Twitter and GitHub 

06:20:35.768 --> 06:20:40.443
as well as letting you use your 
own e-mail and password and you 

06:20:40.444 --> 06:20:44.756
don't have to deal with storing 
passwords on your end.  When we 

06:20:44.757 --> 06:20:50.020
use Firebase auth, we get back a
 unique ID no matter how they 

06:20:50.021 --> 06:20:53.862
signed in.  You get beck a 
consistent Firebase user object 

06:20:53.863 --> 06:20:57.232
that has a unique ID that you 
won't have name collisions 

06:20:57.233 --> 06:21:01.812
across the different sign in 
providers which is nice.  Now 

06:21:01.813 --> 06:21:05.135
take that and store basically 
the Members who can view the 

06:21:05.136 --> 06:21:09.789
various albums in our album 
members and ID sections.  We can

06:21:10.309 --> 06:21:14.818
 stick our various user IDs into
 this object and maybe list some

06:21:15.174 --> 06:21:17.434
 administration rules.  Some 
people are owners and some are 

06:21:17.435 --> 06:21:21.067
editors and some are viewers.  
Once we get that in there, now 

06:21:21.068 --> 06:21:24.915
we need to write some rules.  We
 need to tell the near base 

06:21:24.916 --> 06:21:28.616
database, for someone to see 
this photo here, their user ID 

06:21:28.617 --> 06:21:34.455
must exist in the corresponding 
album object.  Does that make 

06:21:34.456 --> 06:21:37.285
sense?
So how do we do that?  We do 

06:21:37.286 --> 06:21:41.775
that with these rules, which I 
know look complicated at first 

06:21:41.776 --> 06:21:45.147
but if you break it down, you 
can see basically we are just 

06:21:45.148 --> 06:21:48.300
going up the tree a little bit. 
 We are saying for any object in

06:21:48.461 --> 06:21:52.029
 the album photos object, so to 
go up the tree a little bit and 

06:21:52.030 --> 06:21:54.940
go down and find the 
corresponding album members 

06:21:54.941 --> 06:21:58.923
object N there, if there is a 
child that has the same user ID 

06:21:58.924 --> 06:22:01.888
as the user who is currently 
signed in, then they are allowed

06:22:02.136 --> 06:22:06.076
 to read this album and if it 
turns out the value of that 

06:22:06.077 --> 06:22:08.788
object happens to be editor 
owner then they are allowed to 

06:22:08.789 --> 06:22:12.143
write into this album and that 
is basically all we are saying 

06:22:12.144 --> 06:22:15.918
here with this code.  But wait, 
how do we know how to put those 

06:22:15.919 --> 06:22:19.117
user IDs in there in the first 
place?  We can actually have 

06:22:19.118 --> 06:22:22.785
rules for that as well.
Let's say we want to have a way 

06:22:22.786 --> 06:22:27.195
for members on to request they 
join a particular album.  I say 

06:22:27.196 --> 06:22:31.450
I would looic to view this 
album, please let me in.  We can

06:22:31.451 --> 06:22:34.480
 create an album joiner's object
 where people add in their own 

06:22:34.481 --> 06:22:38.053
user ID to make requests and 
then the owner of any particular

06:22:38.682 --> 06:22:42.500
 album has the power to remove 
people from the album and put 

06:22:42.501 --> 06:22:45.928
them into the album members 
object.  So let's look at the 

06:22:45.929 --> 06:22:48.868
rules needed to do that.  First 
we need to say that anybody can 

06:22:48.869 --> 06:22:53.176
add their own user ID to a 
joiner's object.  It is just 

06:22:53.177 --> 06:22:55.979
request to join and anyone can 
do that.  Doesn't mean they'll 

06:22:55.980 --> 06:22:58.987
get approved but anyone can.  So
 we would do that with this 

06:22:58.988 --> 06:23:02.522
rule.  Basically within album 
joiners for any arbitrary album,

06:23:02.772 --> 06:23:07.151
 for any arbitrary user ID you 
can write your own user ID.

06:23:07.250 --> 06:23:13.271
That is all we are saying here. 
 Next up we need to say that 

06:23:13.272 --> 06:23:17.503
anybody -- basically we can say 
that if you want to alter 

06:23:17.504 --> 06:23:20.554
anything, besides the process of
 writing your own user ID, you 

06:23:20.555 --> 06:23:24.674
need to be the album owner.  So 
we do that using this same sort 

06:23:24.675 --> 06:23:27.520
of let's go up the tree and then
 down the tree to the 

06:23:27.521 --> 06:23:30.815
corresponding album member's 
object and see if the sign in 

06:23:30.816 --> 06:23:34.970
user is listed as the owner.  
Then congratulations you can 

06:23:34.971 --> 06:23:40.072
read and write to this album 
joiner's object.  And then we 

06:23:40.073 --> 06:23:44.469
also want to say album owners 
can alter anything in theironal 

06:23:44.470 --> 06:23:48.455
bum object which say simpler 
rule.  We say if you're listed, 

06:23:48.456 --> 06:23:52.234
then write in here.  And then 
for brand new albums, we'll say 

06:23:52.235 --> 06:23:56.523
that any owner can create 
anybody a brand new album as 

06:23:56.524 --> 06:24:00.025
long as they list themselves as 
the owner.  That's what you do 

06:24:00.026 --> 06:24:05.799
here.  We say you can create a 
new album object as long as it 

06:24:05.800 --> 06:24:11.131
doesn't already exist and you 
are the the owner.  So maybe 

06:24:11.132 --> 06:24:13.201
your first reaction upon seeing 
all of this is, I'm going to 

06:24:13.202 --> 06:24:17.224
give up and make my database all
 readable and writable because 

06:24:17.225 --> 06:24:20.349
this seems strange and wierd.  
And it is.  It is kind of 

06:24:20.350 --> 06:24:23.252
strange and wierd at first.  I 
certainly wasn't able to figure 

06:24:23.253 --> 06:24:26.325
this out without having a 
Firebase engineer next to me and

06:24:26.481 --> 06:24:29.746
 I know all of you don't have 
the value of having a engineer 

06:24:29.747 --> 06:24:33.474
sitting next to you.  About you 
I can give you the next best 

06:24:33.475 --> 06:24:36.807
thing, his phone number.  Frank.
  He is willing to help out and 

06:24:36.808 --> 06:24:45.242
answer questions.  I'm sorry?  
Apparently that was not a 

06:24:45.243 --> 06:24:48.670
sincere - I'm just going to move
 on.  Instead I'm going to say 

06:24:48.671 --> 06:24:52.125
get the next next best thing 
which is this cool tool that 

06:24:52.126 --> 06:24:57.039
Firebase has where you can 
pretend to signed sign in as any

06:24:57.220 --> 06:25:00.206
 user and simulate any kind of 
read or write call and what will

06:25:00.376 --> 06:25:03.590
 happen is Firebase will go 
through all of the rules in the 

06:25:03.591 --> 06:25:08.725
database and let you know which 
ones it is applying, whether it 

06:25:08.726 --> 06:25:10.981
evaluates to true or false and 
then tell you whether this 

06:25:10.982 --> 06:25:14.351
operation would have succeeded 
or not.  So it is kind of cool. 

06:25:14.471 --> 06:25:17.119
 Like that is how I was able to 
verify that all of these rules 

06:25:17.120 --> 06:25:20.833
on my Slides were legit was by 
sort of going through all the 

06:25:20.834 --> 06:25:26.878
simulated reads and writes and 
making sure that yes, someone 

06:25:26.879 --> 06:25:28.860
can, an owner is allowed to 
remove somebody from the 

06:25:28.861 --> 06:25:32.536
joiner's list and so on.  I 
encourage to you give this a 

06:25:32.537 --> 06:25:35.832
try.  It's available the UI 
improved a little bit as well.  

06:25:35.833 --> 06:25:38.711
It's available in the database 
in this button on the right that

06:25:39.824 --> 06:25:42.428
 says -- I forget what it says 
now.  Like experiments or 

06:25:42.429 --> 06:25:45.813
something like that.
So because these rules they are 

06:25:45.814 --> 06:25:48.844
wierd at first but they are also
 incredibly powerful.  Once you 

06:25:48.845 --> 06:25:52.009
starred playing with them, they 
can be kind of fun and I know 

06:25:52.010 --> 06:25:54.228
security isn't supposed to be 
fun.  It's supposed to be very 

06:25:54.229 --> 06:25:57.889
serious and all that but it's 
fun to play around with.

06:25:58.199 --> 06:26:03.131
So let's move on to trick Number
 3.  We test in production or 

06:26:03.132 --> 06:26:07.173
using road config plus Crash 
Reporting plus Analytics plus 

06:26:07.174 --> 06:26:10.369
notifications to turn disasters 
around.  So, let's revisit 

06:26:10.370 --> 06:26:16.743
ticket picker.  And one day 
their CEO says I have this great

06:26:17.107 --> 06:26:20.825
 idea for a new ticket auction 
feature.  Instead of just 

06:26:20.826 --> 06:26:23.429
selling and buying tickets, 
we'll let people put their 

06:26:23.430 --> 06:26:25.899
tickets up for auction and 
everybody can bid and like 

06:26:25.900 --> 06:26:29.363
whoever the highest bidder is 
gets the ticket.  Does not this 

06:26:29.364 --> 06:26:33.090
sound fantastic?  It does.  I'm 
glad you agree because I told 

06:26:33.091 --> 06:26:36.553
our investors we would have it 
ready by income week.  Don't 

06:26:36.554 --> 06:26:40.734
worry, I have a plan.  I have 
been analyzing all the work we 

06:26:40.735 --> 06:26:44.017
do.  Turns out it breaks down 
into four things here.  We 

06:26:44.018 --> 06:26:48.544
develop features, cool features 
and write the unit test and add 

06:26:48.545 --> 06:26:52.389
in sweet an maitions and compose
 funny release notes.  We are 

06:26:52.390 --> 06:26:56.210
doing a whole Calvin and Hobbs 
fiction thing that is very 

06:26:56.211 --> 06:26:58.922
popular.  We analyze this stuff 
and found out that people love 

06:26:58.923 --> 06:27:03.923
the features and the animations 
and release notes.  Totally fun 

06:27:03.924 --> 06:27:07.804
and interesting.  But writing 
unit test are so boring.  I 

06:27:07.805 --> 06:27:13.586
looked at all the time engineers
 spend writing these and not one

06:27:15.304 --> 06:27:22.785
 good feature has come out.  
Just skip it.  Tara from 

06:27:22.786 --> 06:27:25.974
engineering was not super 
impressed when while the CEO 

06:27:25.975 --> 06:27:29.427
decided to push forward with the
 whole test plan, he made one 

06:27:29.428 --> 06:27:32.597
valuable concession, all right 
let's role it out gradually.  So

06:27:32.808 --> 06:27:36.072
 the first day we'll role it out
 to like a very small percentage

06:27:36.175 --> 06:27:39.539
 of the population and then 
we'll expand it.  And maybe in a

06:27:40.141 --> 06:27:43.999
 couple of days we'll go to 15% 
and so on until the entire world

06:27:44.494 --> 06:27:49.893
 is full of our red auction 
goodness.  So here is how they 

06:27:49.894 --> 06:27:53.066
did it.  Here is how you do a 
gradual roll out using Firebase.

06:27:53.166 --> 06:27:58.108
  First off, they added a ticket
 auction enabled value in 

06:27:58.109 --> 06:28:01.630
Firebase Remote Config so this 
is basically a value that you 

06:28:01.631 --> 06:28:05.100
can read in from a real config 
that says, should I enable this 

06:28:05.101 --> 06:28:08.319
option?  What can you do in real
 config is create conditions.  

06:28:08.320 --> 06:28:12.191
Certain Groups of users for whom
 certain values apply.  And one 

06:28:12.192 --> 06:28:15.730
thing you can do with conditions
 is create random Groups of 

06:28:15.731 --> 06:28:19.024
users.  They said we are going 
to create a ticket auction 

06:28:19.025 --> 06:28:22.597
experiment condition which will 
apply to 10% of the population. 

06:28:22.709 --> 06:28:27.370
 Or this can be whatever we 
want.  We'll start with 10.  So 

06:28:27.371 --> 06:28:31.066
we'll flag this value or set 
this value to true if they are 

06:28:31.067 --> 06:28:33.674
in the ticket auction experiment
 and otherwise we will set it to

06:28:34.402 --> 06:28:38.673
 false.  And because Karen is 
super paranoid, she said let's 

06:28:38.674 --> 06:28:41.837
also suppress that review 
dialogue for anybody that is in 

06:28:41.838 --> 06:28:44.901
that experiment because I'm not 
entirely sure we want to 

06:28:44.902 --> 06:28:49.801
encourage reviews from people in
 this thing yet.  I'm not super 

06:28:49.802 --> 06:28:52.516
confident yet in our auction 
feature.  So that is something 

06:28:52.517 --> 06:28:56.126
you can also do pretty easily 
using Remote Config is change 

06:28:56.127 --> 06:29:00.882
when you want to show that.  
Please review our dialogue to 

06:29:00.883 --> 06:29:03.284
users.
So then in their code it's 

06:29:03.285 --> 06:29:08.695
simple to usury moat config to 
whether or not to enable this 

06:29:08.696 --> 06:29:13.127
feature.  And then basically 
also report back through 

06:29:13.128 --> 06:29:15.226
Firebase Analytics the 
experiment type that the user is

06:29:15.386 --> 06:29:20.466
 in by setting auer property.  
So we'll create a user property 

06:29:20.467 --> 06:29:22.826
called, is this user in the 
auction experiment and set it to

06:29:23.302 --> 06:29:27.375
 1 or 0 if they are in the 
auction.  And then Firebase 

06:29:27.376 --> 06:29:31.435
Analytics, let's create an 
audience based on people for 

06:29:31.436 --> 06:29:35.461
whom this experiment type is 
equal to true.  So for anybody 

06:29:35.462 --> 06:29:39.042
who has user property of I am in
 this experiment, we will add 

06:29:39.043 --> 06:29:43.054
them to a Firebase audience and 
the wear Firebase audiences is 

06:29:43.055 --> 06:29:46.549
work is they buildup over time. 
 It's distributed to the client.

06:29:46.650 --> 06:29:49.199
  So as people start using the 
app and the client realizes they

06:29:49.407 --> 06:29:54.481
 are in this auction experiment,
 they will get added to this 

06:29:54.482 --> 06:29:56.733
audience.  So, our app is 
updated and released to the 

06:29:56.734 --> 06:29:59.658
world and we decide to gradually
 turn on this feature by 

06:29:59.659 --> 06:30:03.670
changing the percent in the 
experiment T will go from 2% to 

06:30:03.671 --> 06:30:08.952
like 10% and then 20% and so on.
  And we change these random 

06:30:08.953 --> 06:30:13.179
values, it is that same random 
group of 10% plus the next 

06:30:13.180 --> 06:30:16.742
random group of 10T doesn't pick
 an entirely different 20% of 

06:30:16.743 --> 06:30:19.938
the population.  So we gradually
 role it out to our users and 

06:30:19.939 --> 06:30:23.395
then we decide to see how things
 are going.  So we go over and 

06:30:23.396 --> 06:30:26.916
look on Firebase Crash Reporting
 and this is terrible.  And if 

06:30:26.917 --> 06:30:30.963
we look below, the biggest 
culprit seems to be a method, 

06:30:30.964 --> 06:30:34.168
start new auction.  So, 
apparently that might be the 

06:30:34.169 --> 06:30:37.345
culprit and even worse, we can 
go and break out our spending 

06:30:37.346 --> 06:30:40.418
reports by this user property 
and see that people who are now 

06:30:40.419 --> 06:30:42.686
in the auction experiment aren't
 spending everything and this is

06:30:42.951 --> 06:30:46.264
 terrible and our CEO goes to 
engineering and says how could 

06:30:46.265 --> 06:30:49.360
have let this happen?  And Karen
 sighs and says don't worry, we 

06:30:49.361 --> 06:30:52.792
have a plan.  So first of all, 
we can usury moat config to shut

06:30:52.916 --> 06:30:58.121
 down the experiment.  We change
 this condition back to zero and

06:30:58.398 --> 06:31:02.223
 the auction disappears from 
everybody's app.  We have an 

06:31:02.224 --> 06:31:05.061
audience full of everybody who 
is in this experiment and we can

06:31:05.428 --> 06:31:08.439
 apologize to them and it is 
amazing how much goodwill you 

06:31:08.440 --> 06:31:10.888
can gain when you apologize when
 you mess things up.

06:31:11.233 --> 06:31:15.560
Sorry about the lineos 
Wednesday.  Anyway, we can use 

06:31:15.561 --> 06:31:19.309
Firebase Notifications to send 
an apology to everybody in that 

06:31:19.310 --> 06:31:23.430
audience saying hey, sorry we 
had some issues with our 

06:31:23.431 --> 06:31:26.954
auctions.  We turned off this 
feature and maybe as an added 

06:31:26.955 --> 06:31:29.427
bonus, here is a little coupon 
code or something in the 

06:31:29.428 --> 06:31:32.585
notification.  And because it is
 being targeted to just this 

06:31:32.586 --> 06:31:36.352
audience, the other 80% of the 
population using the app isn't 

06:31:36.353 --> 06:31:39.169
like, what are they talking 
about?  I never seen this.  So 

06:31:39.170 --> 06:31:43.035
this sort of thing can be 
useful.  It's a good way of 

06:31:43.036 --> 06:31:46.257
turning a negative experience 
into a positive one and show how

06:31:46.513 --> 06:31:50.432
 you care.  Karen saves the 
company and everything is good 

06:31:50.433 --> 06:31:55.656
with the world.  Stop coming up 
with ideas.  They are all 

06:31:55.657 --> 06:31:57.657
terrible.
Let's move on to trick Number 4.

06:31:57.689 --> 06:32:02.967
  The dreaming boy store front 
Analytics plus AdWords plus 

06:32:02.968 --> 06:32:07.491
Remote Config plus Firebase 
Hosting equal promotions to 

06:32:07.492 --> 06:32:11.958
swoon over.  Chat em up is a new
 chat app that makes most money 

06:32:11.959 --> 06:32:15.951
selling stickners their in-App 
Store.  It happens that the lead

06:32:16.097 --> 06:32:18.822
 person at which the em up is 
really good friends with the 

06:32:18.823 --> 06:32:22.385
Manager of The hot new boy band 
coming out of the U.K., the 

06:32:22.386 --> 06:32:27.680
dream boys.  So, the hot new 
band with the hit new song, you 

06:32:27.681 --> 06:32:32.922
can't debug my love.  Freaky 
looking boy band.  And so 

06:32:32.923 --> 06:32:36.860
anyway, they say you know what 
would be great?  What if we had 

06:32:36.861 --> 06:32:41.075
a dreamy boys branded seconds of
 our sticker shop.  That would 

06:32:41.076 --> 06:32:43.730
be fantastic.  They start 
negotiating deals and royalties 

06:32:43.731 --> 06:32:46.837
and all that.  We decided we 
wanted to make this thing a 

06:32:46.838 --> 06:32:50.166
success as soon as it launches. 
 So as early as we can, we will 

06:32:50.167 --> 06:32:54.588
start creating a few audiences 
and in Firebase Analytics and 

06:32:54.589 --> 06:32:57.884
target their initial 
demographic, females in the 

06:32:57.885 --> 06:33:02.102
U.K., second demographic is 
males in Switzerland over 55.  

06:33:02.103 --> 06:33:06.620
I'll be hon theft took marketing
 by surprise but there you go.  

06:33:06.621 --> 06:33:09.455
And then target our heavy 
sticker users.  These are people

06:33:09.601 --> 06:33:13.294
 who purchased a sticker from 
our in-app sticker store.  That 

06:33:13.295 --> 06:33:16.462
is probably an audience we 
created already because we care 

06:33:16.463 --> 06:33:19.648
about them.  Very clearly the 
people that are going to most 

06:33:19.649 --> 06:33:23.177
likely to purchase stickers in 
the future are people probably 

06:33:23.178 --> 06:33:25.598
purchased stickers in the past. 
 This is definitely ef a group 

06:33:25.599 --> 06:33:30.176
we want to capture in a Firebase
 Analytics audience.  Let's fast

06:33:30.298 --> 06:33:33.162
 forward to a few months later. 
 The deal is signed.  We have a 

06:33:33.163 --> 06:33:36.374
new store front and stay that is
 fantastic.  We have should to 

06:33:36.375 --> 06:33:39.916
get the word out.  So because we
 connected Firebase in AdWords, 

06:33:39.917 --> 06:33:41.917
we can use these

06:33:43.503 --> 06:33:44.191
 audiences directly in our 
remarketing campaign.  If you 

06:33:44.192 --> 06:33:47.934
have done a remarketing campaign
 in AdWords, you might know that

06:33:48.088 --> 06:33:52.528
 you're allowed to basically 
target specific remarketing 

06:33:52.529 --> 06:33:57.512
lists and these can be everybody
 who has ever used your app ever

06:33:57.661 --> 06:34:01.146
 but now that you can connect 
Firebase and AdWords, you can 

06:34:01.147 --> 06:34:05.085
target audiences you built-up 
right within Analytics and that 

06:34:05.086 --> 06:34:08.300
turns out to be really useful.  
Like we can actually target just

06:34:08.640 --> 06:34:11.949
 the people that purchased 
stickers in our app before with 

06:34:11.950 --> 06:34:14.880
remarketing campaigns.  Sore we 
can also target our women in the

06:34:15.122 --> 06:34:18.964
 U.K. and older Swiss men.
And so those people will start 

06:34:18.965 --> 06:34:23.049
to see remarketing adds designed
 to get them into their app and 

06:34:23.050 --> 06:34:29.025
hopefully making more purchases.
  It turns out we could use 

06:34:29.026 --> 06:34:33.739
Remote Config to display a 
message to our sticker audience 

06:34:33.740 --> 06:34:39.127
create conditions based on 
random Groups of users or your 

06:34:39.128 --> 06:34:43.611
device type or your country.  
But we can also tar get certain 

06:34:43.612 --> 06:34:48.270
Firebase audiences.  So we 
coulda add a welcome message to 

06:34:48.271 --> 06:34:51.191
let them know about recent new 
addition to our app.  And 

06:34:51.192 --> 06:34:54.997
honestly, this is a good 
application for Remote Config is

06:34:54.998 --> 06:34:57.627
 any kind of message of the day 
feature.  You can immediately 

06:34:57.628 --> 06:35:00.456
push out any new message you 
want to send to your users using

06:35:00.666 --> 06:35:04.177
 Remote Config.  And with 
conditions, you can target just 

06:35:04.178 --> 06:35:06.677
specific Groups of users who 
might be interested.  So not 

06:35:06.678 --> 06:35:09.193
everybody is getting all these 
message of the days all the time

06:35:09.360 --> 06:35:14.527
 if they don't want them.  And 
we can also do things as long as

06:35:14.640 --> 06:35:18.849
 we are using Remote Config, 
change the banner image for our 

06:35:18.850 --> 06:35:21.975
sticker store so it can be 
something special for that group

06:35:21.976 --> 06:35:24.983
 of users who purchased stickers
 from us in the past.  Maybe we 

06:35:24.984 --> 06:35:28.442
say instead of using whatever 
local image we would normally 

06:35:28.443 --> 06:35:31.513
use on the device, let's grab 
something remotely.  And so we 

06:35:31.514 --> 06:35:35.601
can go from our boring old 
sticker shop banner to whatever 

06:35:35.602 --> 06:35:40.543
you call this.  That's Evan.  
The rebel of the group.  I hear 

06:35:40.544 --> 06:35:45.337
he might be a vampire as well.  
We are going for smoldering but 

06:35:45.338 --> 06:35:48.019
I think we just ended up with 
tired bauds that is whatness 

06:35:48.020 --> 06:35:52.376
when you take pictures the week 
before I/O.  Everyone looks 

06:35:52.377 --> 06:35:53.905
tired!
But that is the kind of thing to

06:35:53.906 --> 06:35:58.051
 do with Remote Config.  And by 
the way, I don't know if you 

06:35:58.052 --> 06:36:01.913
noticed, the URL for that banner
 image is being provided by 

06:36:01.914 --> 06:36:07.639
Firebase Hosting and that is the
 best place for need to put 

06:36:07.640 --> 06:36:11.822
static images you want to 
retrieve by using HTP calls and 

06:36:11.823 --> 06:36:15.599
that's a good question.  So yes,
 you may have noticed two ways 

06:36:15.600 --> 06:36:19.430
to retrieve images.  Have you 
Firebase Storage and Firebase 

06:36:19.431 --> 06:36:22.036
Hosting.  Both are good.  
Generally speaking, you want to 

06:36:22.037 --> 06:36:26.575
use Firebase Storage for user 
generated content.  Images that 

06:36:26.576 --> 06:36:30.883
users have up loaded, 
recordings, that sort of thing. 

06:36:31.084 --> 06:36:36.674
 Federal what I call read only 
assets, like your ebb site and 

06:36:36.675 --> 06:36:40.037
images and data you want your 
app to download later, Hosting 

06:36:40.038 --> 06:36:43.401
is appropriate.  It gets it out 
to the world everywhere and 

06:36:43.402 --> 06:36:47.947
makes it super fast and easier 
for you to download also free I 

06:36:47.948 --> 06:36:50.784
believe, which is nice.
So let's move on to trick Number

06:36:51.283 --> 06:36:55.564
 5.  Are you ready for this 
jelly?  Or basically Remote 

06:36:55.565 --> 06:37:01.284
Config plus Dynamic Links plus 
Firebase database and Firebase 

06:37:01.285 --> 06:37:06.069
Analytics for replays that 
matter.  Let's talk about the 

06:37:06.070 --> 06:37:10.049
latest match puzzle game.  The 
developers wanted to add a share

06:37:10.327 --> 06:37:13.575
 my level feature so if you had 
a great replay, you can send it 

06:37:13.576 --> 06:37:17.098
to your friends.  They can try 
the exact same level and see if 

06:37:17.099 --> 06:37:20.520
they can beat your score and 
watch your replay later.  It 

06:37:20.521 --> 06:37:25.973
sound like a cool way of doing 
it.  So again, this seems like a

06:37:26.065 --> 06:37:29.445
 uses case for Dynamic Links.  
Whatever e-mail this app 

06:37:29.446 --> 06:37:32.206
generates for whatever post or 
how we want to share this 

06:37:32.207 --> 06:37:36.650
replay, we probably want that 
link to get into our app to be 

06:37:36.651 --> 06:37:41.290
Dynamic Link so click on that 
link and take them into the app 

06:37:41.291 --> 06:37:44.555
and load up the level by 
analyzing that link parameter 

06:37:44.556 --> 06:37:47.573
and they don't have the app 
installed so we can take them to

06:37:47.683 --> 06:37:52.012
 the play store or App Store.  
And we totally store all that 

06:37:52.013 --> 06:37:54.827
replay information in the 
Firebase database.

06:37:55.031 --> 06:37:58.760
But there is one big question.  
So typically, if user doesn't 

06:37:58.761 --> 06:38:02.467
have the app installed, the 
default Dynamic Link process is 

06:38:02.468 --> 06:38:05.998
to take users to the App Store 
or play store and wait for them 

06:38:05.999 --> 06:38:08.902
to install the app.  You values 
another option when dealing with

06:38:09.968 --> 06:38:14.015
 Firebase Dynamic Links.  We can
 send people to a fall-back page

06:38:14.361 --> 06:38:16.971
 instead, like a marketing page 
where we tell them more about 

06:38:16.972 --> 06:38:20.292
the app and how fantastic it is 
and get them excited about it 

06:38:20.293 --> 06:38:22.790
before we send them to the App 
Store where they are given the 

06:38:22.791 --> 06:38:26.363
option of whether to install it 
or not.  And there is advantages

06:38:26.878 --> 06:38:30.315
 and disvalues to both.  The 
first way is one fewer click.  

06:38:30.316 --> 06:38:33.647
You can get into the app or play
 store immediately but the other

06:38:34.266 --> 06:38:39.839
 way, maybe gives the user more 
context before we ask them to 

06:38:39.840 --> 06:38:42.423
install something H is better?  
It seems like a good opportunity

06:38:42.634 --> 06:38:45.486
 for a AB test.
That is something we can do with

06:38:45.599 --> 06:38:49.580
 Remote Config.  Cest up a test 
condition delivering to a random

06:38:49.836 --> 06:38:55.216
 group of users and we'll look 
at 50% of our users instead 

06:38:55.217 --> 06:38:57.860
doing a gradual roll out so do a
 true AB test.

06:38:58.272 --> 06:39:02.635
And then we can set our value of
 replay uses marketing page to 

06:39:02.636 --> 06:39:06.409
be true or false depending on 
the useners this experiment and 

06:39:06.410 --> 06:39:08.635
then basically within whatever 
code we are going to be using to

06:39:08.854 --> 06:39:12.347
 build out this Dynamic Link 
from the app, we can look and 

06:39:12.348 --> 06:39:15.784
see, is this value true?  If so,
 then let's add on these two 

06:39:15.785 --> 06:39:20.200
extra parameters, the A if.  L 
and IFL parameter to our Dynamic

06:39:21.291 --> 06:39:24.297
 Link which tells Firebase 
Dynamic Links what Web page to 

06:39:24.298 --> 06:39:30.590
send the user to instead.  So 
half of our users the link they 

06:39:30.591 --> 06:39:34.264
will share with friends looks 
like this.  And the other half 

06:39:34.265 --> 06:39:37.256
will have a link that looks like
 this, basically the same link 

06:39:37.257 --> 06:39:42.565
as before but now we have these 
fall back page URLs specified.  

06:39:42.566 --> 06:39:45.530
And again with the tiny bit of 
JavaScript, that marketing page 

06:39:45.531 --> 06:39:49.551
that we then have that tells the
 user how fantastic this app is 

06:39:49.552 --> 06:39:53.161
and now don't you really want to
 go and install it?  When they 

06:39:53.162 --> 06:39:56.546
click on the link to install, we
 can still kind of generate our 

06:39:56.547 --> 06:40:00.280
own Dynamic Link so that when 
the user does open up that app, 

06:40:00.281 --> 06:40:03.618
we remembered through the entire
 process what that replay was 

06:40:03.619 --> 06:40:06.880
and take our user right into 
that replay as soon as they 

06:40:06.881 --> 06:40:11.431
start up the app.  And how do we
 track this?  How do we see 

06:40:11.432 --> 06:40:14.852
which is successful?  The 
easiest way is to adjust the 

06:40:14.853 --> 06:40:17.653
parameters that we talked about 
earlier.  We can create that for

06:40:18.568 --> 06:40:23.564
 each link.  And then start 
tracking conversion metrics.  

06:40:23.565 --> 06:40:26.930
Like who made the in app 
purchase based on did you visit 

06:40:26.931 --> 06:40:30.663
the fall back page first or 
taken there directly from the 

06:40:30.664 --> 06:40:34.583
e-mail?  And so not only can we 
see which users clicked on which

06:40:34.584 --> 06:40:38.082
 links the most but also see 
which users then stuck around 

06:40:38.083 --> 06:40:42.211
and made a purchase and got into
 it.  Maybe the marketing page 

06:40:42.212 --> 06:40:45.592
got you more psyched to try the 
app and stick with it because 

06:40:45.593 --> 06:40:48.635
chances are, you're not going to
 win that replay if this is the 

06:40:48.636 --> 06:40:51.495
first time you ever tried the 
game.  So that is valuable.

06:40:51.660 --> 06:40:54.727
And by the way, you don't need 
to stop with testing a single 

06:40:54.728 --> 06:40:59.150
page or not.  It's very easy to 
ABC test different pages.  

06:40:59.151 --> 06:41:02.931
Create conditions for 33% of 
over use and 66% and then set 

06:41:02.932 --> 06:41:05.402
different options of which 
marketing page do we send people

06:41:05.595 --> 06:41:09.521
 to or maybe we don't send them 
to one at all.  Based on these 

06:41:09.522 --> 06:41:12.342
conditions.  And we think about 
it, if this e-mail content is 

06:41:12.343 --> 06:41:16.383
being generated, it has tho come
 from somewhere too.  Why not 

06:41:16.384 --> 06:41:20.538
use Remote Config to test what 
e-mails we are going to send and

06:41:20.539 --> 06:41:23.019
 test what screenshot the app is
 going to put in there.  What 

06:41:23.020 --> 06:41:28.010
the button will say.  All that 
stuff fairly easy to set up and 

06:41:28.011 --> 06:41:32.098
AB test using Remote Config.  So
 there you go.  5 ways to use 

06:41:32.099 --> 06:41:35.254
elements like Storage and 
Analytics and notifications and 

06:41:35.255 --> 06:41:38.361
Remote Config and all together 
to make a more compelling app.

06:41:38.489 --> 06:41:43.282
This might shock some of you but
 these were contrived examples 

06:41:43.283 --> 06:41:47.068
with fake companies.  I know.  
Right.  Surprising.

06:41:47.306 --> 06:41:50.477
But probably some of this does 
apply to your situation.  Maybe 

06:41:50.478 --> 06:41:53.340
you have a companion site where 
you're trying to bring users 

06:41:53.341 --> 06:41:56.487
into your app and you want to 
make that more powerful.  Or 

06:41:56.488 --> 06:42:00.419
maybe an added feature you're 
not confident in and maybe you 

06:42:00.420 --> 06:42:03.381
want to try a gradual roll out 
first.  Maybe you have your own 

06:42:03.382 --> 06:42:06.545
set of deep links or sharing 
e-mails and you want to AB test 

06:42:06.546 --> 06:42:10.472
that stuff.  So think about it. 
 Maybe a couple of these 

06:42:10.473 --> 06:42:14.745
examples might not be exactly 
pertinent to your situation but 

06:42:14.746 --> 06:42:17.416
maybe they will inspire to you 
think of something similar that 

06:42:17.417 --> 06:42:20.429
would be cool.  So I know at 
this point I'm like the teacher 

06:42:20.430 --> 06:42:23.029
on the last day of class and 
everybody is waiting for the 

06:42:23.030 --> 06:42:26.748
bell to ring.  Maybe some of you
 have planes to catch.  I just 

06:42:26.749 --> 06:42:31.036
want to say thank you very much 
for coming to I/O.  Every year 

06:42:31.037 --> 06:42:34.774
like the week before I'm always 
up super late and not sleeping 

06:42:34.775 --> 06:42:38.069
and trying to get this stuff 
done and is this worth it?  And 

06:42:38.070 --> 06:42:40.749
then I come to these events and 
talk to people who are like 

06:42:40.750 --> 06:42:44.848
super excited and positive and a
 little bit nerdy like me, and 

06:42:44.849 --> 06:42:47.655
it's just really nice.  Like 
it's just really nice to be able

06:42:48.217 --> 06:42:52.551
 to sort of chat with all of you
 and sort of meet other people 

06:42:52.552 --> 06:42:56.317
and please just continue to be 
positive and a little bit nerdy 

06:42:56.318 --> 06:43:00.684
because I think that is great.  
So anyway, sorry.  If you want 

06:43:00.685 --> 06:43:04.232
more information about Firebase,
 here is the website.  We have a

06:43:04.789 --> 06:43:08.327
 support page and a YouTube and 
Twitter feed and with that, I'm 

