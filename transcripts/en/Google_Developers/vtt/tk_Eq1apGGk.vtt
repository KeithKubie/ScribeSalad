WEBVTT
Kind: captions
Language: en

00:00:09.360 --> 00:00:13.080
HOI LAIM: We have got a lot,
a lot of content for you.

00:00:13.080 --> 00:00:15.490
So onstage we have
five speakers.

00:00:15.490 --> 00:00:17.950
Going to talk about
a variety of topics.

00:00:17.950 --> 00:00:20.430
So I would start with Android
Wear, and some of the things

00:00:20.430 --> 00:00:24.420
that you may not know about,
or some of the top tips

00:00:24.420 --> 00:00:26.580
as we develop Android Wear 2.0.

00:00:26.580 --> 00:00:28.140
Then I'm going to
have Mark, who will

00:00:28.140 --> 00:00:29.400
give an update on Android TV.

00:00:29.400 --> 00:00:30.640
Give us a wave.

00:00:30.640 --> 00:00:31.920
Woo hoo.

00:00:31.920 --> 00:00:34.230
And then we have Santiago,
who's going to give us

00:00:34.230 --> 00:00:36.620
an update on ExoPlayer.

00:00:36.620 --> 00:00:38.310
And then we have Aga,
who will take you

00:00:38.310 --> 00:00:41.100
behind the scene on our
development of Android

00:00:41.100 --> 00:00:43.650
2.0 and some the components
that we've built.

00:00:43.650 --> 00:00:45.540
And last but definitely
not least, we

00:00:45.540 --> 00:00:48.630
have Dan, who's going to talk
about pro audio or Android

00:00:48.630 --> 00:00:49.130
audio.

00:00:49.130 --> 00:00:50.338
DANIEL GALPIN: Android audio.

00:00:50.338 --> 00:00:51.370
HOI LAIM: Android audio.

00:00:51.370 --> 00:00:53.160
So get your hashtag ready.

00:00:53.160 --> 00:00:55.290
Each of our speakers
have six minutes.

00:00:55.290 --> 00:00:57.250
Actually, my clock
already started.

00:00:57.250 --> 00:00:58.500
What's going on?

00:00:58.500 --> 00:01:00.360
OK, so let's get going.

00:01:00.360 --> 00:01:01.750
Android Wear.

00:01:01.750 --> 00:01:03.450
And what I'm going
to do, I'm going

00:01:03.450 --> 00:01:05.410
to talk about three
things that is a little

00:01:05.410 --> 00:01:09.120
[INAUDIBLE] to developers,
and quite often is not

00:01:09.120 --> 00:01:13.740
immediately obvious when you
develop for Android Wear.

00:01:13.740 --> 00:01:17.130
The first thing is, if your
app is standalone, please,

00:01:17.130 --> 00:01:19.140
please tell us.

00:01:19.140 --> 00:01:22.470
So at the start of
Android Wear back in 2014

00:01:22.470 --> 00:01:24.570
the only way for
the watch to connect

00:01:24.570 --> 00:01:27.660
to the internet via the
phone through Bluetooth.

00:01:27.660 --> 00:01:31.380
We have subsequently added both
Wi-Fi and satellite connection

00:01:31.380 --> 00:01:33.680
to the watch, but you
still needed a phone

00:01:33.680 --> 00:01:35.625
with Android Wear 1.0.

00:01:35.625 --> 00:01:39.270
With 2.0 we have added a
new way for you to connect,

00:01:39.270 --> 00:01:42.390
which is via direct
HTTP connection.

00:01:42.390 --> 00:01:44.955
What this means is if you
have connection code based

00:01:44.955 --> 00:01:48.150
on your mobile, you could just
reuse exactly the same code

00:01:48.150 --> 00:01:49.170
on your watch.

00:01:49.170 --> 00:01:54.210
So that's what's been launch
with Android Wear 2.0.

00:01:54.210 --> 00:01:56.800
The advantages of
that is, of course,

00:01:56.800 --> 00:02:01.034
you can run your app even if
they are paired to an iPhone.

00:02:01.034 --> 00:02:02.700
Because there is no
additional component

00:02:02.700 --> 00:02:04.890
required on the phone.

00:02:04.890 --> 00:02:08.940
Another advantage is that
users can now directly install

00:02:08.940 --> 00:02:10.949
your app from the watch itself.

00:02:10.949 --> 00:02:13.710
We have Play Store on
the watch so the user

00:02:13.710 --> 00:02:16.740
can download whatever
they want onto their most

00:02:16.740 --> 00:02:19.530
personalized device.

00:02:19.530 --> 00:02:22.920
And in order for you to tell
us that your app support

00:02:22.920 --> 00:02:25.680
this functionality of accessing
the internet directly,

00:02:25.680 --> 00:02:28.580
all you need to do is
put on this metadata

00:02:28.580 --> 00:02:33.150
tag in your Android Wear
app android manifest XML.

00:02:33.150 --> 00:02:35.400
And after you do that,
we will put your app

00:02:35.400 --> 00:02:38.070
onto the Play Store
on the watch and it

00:02:38.070 --> 00:02:40.800
will be accessible to both
users that's using an Android

00:02:40.800 --> 00:02:43.800
phone as well as an iPhone.

00:02:43.800 --> 00:02:47.040
Next, standalone architecture.

00:02:47.040 --> 00:02:51.360
So many of you have heard
about model view controller.

00:02:51.360 --> 00:02:52.884
So that's pretty
much done, right?

00:02:52.884 --> 00:02:54.300
Standalone
architecture, you know,

00:02:54.300 --> 00:02:55.966
you just put your
services in the cloud,

00:02:55.966 --> 00:02:58.200
or your display
logic on the device.

00:02:58.200 --> 00:03:01.110
Done, lightning talk.

00:03:01.110 --> 00:03:03.450
In reality, it's not quite that.

00:03:03.450 --> 00:03:09.510
So today the center of
gravity for the user

00:03:09.510 --> 00:03:10.690
is a lot about mobile.

00:03:10.690 --> 00:03:12.750
You know, you heard
about mobile first.

00:03:12.750 --> 00:03:16.260
And quite often we forgot about
all the other form factors

00:03:16.260 --> 00:03:17.790
that a user already have.

00:03:17.790 --> 00:03:20.320
And it doesn't even need
to be another form factor.

00:03:20.320 --> 00:03:23.280
It could just be the same
user with another phone.

00:03:23.280 --> 00:03:27.360
And this particular pitfall
is particularly easy

00:03:27.360 --> 00:03:31.650
to fall into if you have
a user credential that

00:03:31.650 --> 00:03:34.440
is telephone-based,
meaning that when

00:03:34.440 --> 00:03:37.830
a user log into one device,
you lock them out of another.

00:03:37.830 --> 00:03:41.280
And I see this assumption being
built into app again and again.

00:03:41.280 --> 00:03:45.060
And when they come to extend
their app to other form

00:03:45.060 --> 00:03:47.490
factors, this really,
really hit them

00:03:47.490 --> 00:03:50.250
because the user can only log
into one device at any one

00:03:50.250 --> 00:03:51.310
time.

00:03:51.310 --> 00:03:54.330
So at a very, very minimum, I
would strongly encourage you,

00:03:54.330 --> 00:03:57.930
even if you are just startup
that is bootstrapping,

00:03:57.930 --> 00:04:03.060
or you're working on a
project over the weekends,

00:04:03.060 --> 00:04:06.610
build the assumption that a user
will have more than one device.

00:04:06.610 --> 00:04:08.850
So allow multiple
security tokens

00:04:08.850 --> 00:04:11.170
to be active at any one point.

00:04:11.170 --> 00:04:13.680
You don't need to build
cloud-based, messaging,

00:04:13.680 --> 00:04:17.113
synchronization, none
of that at the start.

00:04:17.113 --> 00:04:18.779
Maybe when you get
your serious funding,

00:04:18.779 --> 00:04:21.751
then you could do that.

00:04:21.751 --> 00:04:23.250
The next thing that
we realized when

00:04:23.250 --> 00:04:26.930
we start building for Android
Wear 2.0 which support all

00:04:26.930 --> 00:04:32.570
of login is that the a lot
of the time, the first time

00:04:32.570 --> 00:04:35.460
the user access your app
could be via the Android Wear

00:04:35.460 --> 00:04:37.620
device, which means
that they may not

00:04:37.620 --> 00:04:39.190
have an account to sign in.

00:04:39.190 --> 00:04:41.730
So if you assume that
the user can just

00:04:41.730 --> 00:04:46.200
have this sign in
button for the app,

00:04:46.200 --> 00:04:49.480
you may be missing a
whole chunk of users.

00:04:49.480 --> 00:04:52.700
So what we will encourage you to
do as you build an [INAUDIBLE]

00:04:52.700 --> 00:04:56.490
experiences, also put in a
Register button so that you can

00:04:56.490 --> 00:04:59.820
enable users that's coming
in from other form factors--

00:04:59.820 --> 00:05:02.580
be it Android Wear,
be it Android TV--

00:05:02.580 --> 00:05:04.620
to actually register
for your service

00:05:04.620 --> 00:05:08.220
the very first time that
they are logging in.

00:05:08.220 --> 00:05:11.360
Last but not least,
Android Wear for China.

00:05:11.360 --> 00:05:16.180
So we are in China, and
it is extremely popular.

00:05:16.180 --> 00:05:20.500
It is our second largest market
around the world behind the US.

00:05:20.500 --> 00:05:23.920
And as you know, many
of the Google services

00:05:23.920 --> 00:05:26.170
are not available in China.

00:05:26.170 --> 00:05:28.410
So one of the things
that you should

00:05:28.410 --> 00:05:31.960
do as you use Google Play
services on Android Wear

00:05:31.960 --> 00:05:34.520
is to check that
it is available.

00:05:34.520 --> 00:05:36.230
So there's two ways to do this.

00:05:36.230 --> 00:05:41.800
One is when you are connecting
to the Google Play services,

00:05:41.800 --> 00:05:46.810
check if the connection fail
that the API is available.

00:05:46.810 --> 00:05:49.320
And then second, if you
have a variety of APIs,

00:05:49.320 --> 00:05:52.630
let's say five of them, and you
need it, and if three of them

00:05:52.630 --> 00:05:55.750
connect and you still want them
to work, then you could do this

00:05:55.750 --> 00:05:58.420
and say, add API if available.

00:05:58.420 --> 00:06:01.210
And then check that the
API is actually available

00:06:01.210 --> 00:06:04.430
before you use it.

00:06:04.430 --> 00:06:06.790
And there are three
types of services

00:06:06.790 --> 00:06:11.680
that is available in China in
a Google Play services package.

00:06:11.680 --> 00:06:13.030
The first one is Google Fit.

00:06:13.030 --> 00:06:16.750
You can get the seven-day
step count from that.

00:06:16.750 --> 00:06:18.400
Second, Fused Location Provider.

00:06:18.400 --> 00:06:21.190
We really, really
recommend that you use it

00:06:21.190 --> 00:06:22.630
if you're trying
to get location.

00:06:22.630 --> 00:06:25.290
It has a lot of battery
optimization built in,

00:06:25.290 --> 00:06:27.190
as well as all the
different combinations

00:06:27.190 --> 00:06:28.780
of ways of getting location.

00:06:28.780 --> 00:06:31.540
So just let us take
care of that for you.

00:06:31.540 --> 00:06:34.000
Last but not least,
since Android 1.0 we

00:06:34.000 --> 00:06:35.200
have the wear data layer.

00:06:35.200 --> 00:06:39.010
So to use it you will
need Google Play Services.

00:06:39.010 --> 00:06:42.370
And if you want to compile just
once, against the Google Play

00:06:42.370 --> 00:06:46.030
Services once, for both
rest of world and China,

00:06:46.030 --> 00:06:50.950
then you should compile
with the version 10.2.0.

00:06:50.950 --> 00:06:52.960
And what it enables you
to do is for your app

00:06:52.960 --> 00:06:56.894
to run both within China
and also outside of China.

00:06:56.894 --> 00:06:58.810
So with that, I'll hand
over to Mark, who will

00:06:58.810 --> 00:07:00.481
talk to you about Android TV.

00:07:00.481 --> 00:07:00.980
Thank you.

00:07:00.980 --> 00:07:05.577
[APPLAUSE]

00:07:05.577 --> 00:07:07.660
MARK BACHINGER: Yeah, let's
talk about Android TV.

00:07:07.660 --> 00:07:10.060
You've maybe already
seen the keynote

00:07:10.060 --> 00:07:12.700
where we announced the new cool
features for Android TV coming

00:07:12.700 --> 00:07:13.480
soon.

00:07:13.480 --> 00:07:15.560
I'm going to talk
about two of them.

00:07:15.560 --> 00:07:18.760
One is that Google Assistant
on Android TV, and the other

00:07:18.760 --> 00:07:20.680
is the new lounge
screen, the new home

00:07:20.680 --> 00:07:24.160
screen starting with Android O.

00:07:24.160 --> 00:07:25.780
Google Assistant
goes Android TV.

00:07:25.780 --> 00:07:27.640
That's not really
surprising news.

00:07:27.640 --> 00:07:30.340
We want to have Google
Assistant on every surface

00:07:30.340 --> 00:07:31.840
on every platform available.

00:07:31.840 --> 00:07:36.050
So Android TV is just
the next logical step.

00:07:36.050 --> 00:07:38.290
What do you need to
do as a developer

00:07:38.290 --> 00:07:42.640
to make your app integrating
with Google Assistant?

00:07:42.640 --> 00:07:46.690
There are basically two ways
Google Assistant interact

00:07:46.690 --> 00:07:47.590
with your app.

00:07:47.590 --> 00:07:51.490
First it needs to find the
content your apps provide.

00:07:51.490 --> 00:07:54.940
So it needs a way to query
your app for content.

00:07:54.940 --> 00:07:58.300
This is done by using
a service provider.

00:07:58.300 --> 00:08:00.400
And second, once the
content is found,

00:08:00.400 --> 00:08:02.530
it needs a way to
play this content.

00:08:02.530 --> 00:08:07.180
It needs a way to remote control
your app and do playback.

00:08:07.180 --> 00:08:10.510
For this it uses the
media session API.

00:08:10.510 --> 00:08:13.690
Both of these are kind of
well-known technologies.

00:08:13.690 --> 00:08:17.990
We have these on Android TVs
since the very first launch

00:08:17.990 --> 00:08:19.820
a few years ago.

00:08:19.820 --> 00:08:23.920
So what we see here is that
old universal or global search

00:08:23.920 --> 00:08:28.930
that's exactly the feature
on the former Android TV

00:08:28.930 --> 00:08:33.100
versions, which uses the service
provider as well as the Google

00:08:33.100 --> 00:08:33.850
Assistant does.

00:08:33.850 --> 00:08:36.460
Google Assistant now
re-uses this service

00:08:36.460 --> 00:08:40.030
and provides a new, more
modern-looking user interface

00:08:40.030 --> 00:08:43.600
like we see here the
presentation of the results

00:08:43.600 --> 00:08:45.640
for the query action movies.

00:08:45.640 --> 00:08:48.520
Now the user can choose
from these movies and start

00:08:48.520 --> 00:08:50.400
playback.

00:08:50.400 --> 00:08:51.430
How far is that?

00:08:51.430 --> 00:08:54.355
These are well-known
technologies.

00:08:54.355 --> 00:08:57.310
There's a lot of documentation
available on developer

00:08:57.310 --> 00:08:58.195
android.com.

00:08:58.195 --> 00:09:01.900
There is a DAC guide,
making TV apps searchable,

00:09:01.900 --> 00:09:04.030
and there is also
a lean back sample

00:09:04.030 --> 00:09:07.780
app, which provides sample code
which you can use and adapt

00:09:07.780 --> 00:09:10.730
for your app.

00:09:10.730 --> 00:09:13.090
So now Assistant now
found the content,

00:09:13.090 --> 00:09:16.840
or the user found via Assistant
the content he wants to watch,

00:09:16.840 --> 00:09:22.750
and now Assistant uses the media
session API to start playback.

00:09:22.750 --> 00:09:27.010
We see here this callback
of the media session

00:09:27.010 --> 00:09:28.960
where the media commands arrive.

00:09:28.960 --> 00:09:32.230
And you in your app just
need to delegate these calls

00:09:32.230 --> 00:09:34.190
to the player you are using.

00:09:34.190 --> 00:09:39.280
In this case it's an
ExoPlayer instance.

00:09:39.280 --> 00:09:41.890
Media session is as well
already well-documented.

00:09:41.890 --> 00:09:45.300
There is a guide on
developer android.com

00:09:45.300 --> 00:09:46.960
working with media session.

00:09:46.960 --> 00:09:51.370
And there is also a media
session extension for ExoPlayer

00:09:51.370 --> 00:09:55.533
which provides out in the box
integration with the media

00:09:55.533 --> 00:09:56.032
session.

00:09:59.139 --> 00:10:00.930
So now let's have a
look at the new content

00:10:00.930 --> 00:10:05.340
first launcher experience, the
new home screen of Android TV.

00:10:05.340 --> 00:10:07.620
We see here this
row-based layout.

00:10:07.620 --> 00:10:12.120
On the top we see the
arrow with favorite apps.

00:10:12.120 --> 00:10:14.070
But then we see
these channels rows.

00:10:14.070 --> 00:10:17.700
Channel rows with programs
which an app wants to advertise

00:10:17.700 --> 00:10:21.030
to the user for recommendation.

00:10:21.030 --> 00:10:24.690
Each app can at least place one
such a channel row on the home

00:10:24.690 --> 00:10:27.300
screen, and the
launcher application

00:10:27.300 --> 00:10:31.170
takes the data to displays
these rows from a database

00:10:31.170 --> 00:10:32.920
from a content provider.

00:10:32.920 --> 00:10:36.960
So your app needs to insert
data into exactly this content

00:10:36.960 --> 00:10:38.110
provider.

00:10:38.110 --> 00:10:40.440
Let's have a look how
this looks like in code.

00:10:40.440 --> 00:10:44.850
We have here a sample method
which adds such a channel

00:10:44.850 --> 00:10:47.490
row to the content provider.

00:10:47.490 --> 00:10:51.540
At the very start we just
create a builder instance,

00:10:51.540 --> 00:10:55.110
in this case a channel builder
instance, which we then

00:10:55.110 --> 00:10:59.720
populate with the properties
we want to use for our channel.

00:10:59.720 --> 00:11:02.160
In the next step, we
use now this builder

00:11:02.160 --> 00:11:06.000
to build the content values
and insert these content

00:11:06.000 --> 00:11:10.470
values into our content
provider via the TV

00:11:10.470 --> 00:11:13.800
contract we are using.

00:11:13.800 --> 00:11:17.220
In the next step now we want
to add a logo to our channel.

00:11:17.220 --> 00:11:21.870
So the user can easily recognize
to which app a row below,

00:11:21.870 --> 00:11:23.430
is a channel row belongs.

00:11:23.430 --> 00:11:27.700
And we use the store channel
channel logo method here

00:11:27.700 --> 00:11:32.820
to which we pass the channel
ID and the logo as a bitmap.

00:11:32.820 --> 00:11:35.190
Now finally, we want
to make this channel

00:11:35.190 --> 00:11:37.050
visible on the home screen.

00:11:37.050 --> 00:11:39.810
For this we request
it to make it

00:11:39.810 --> 00:11:43.200
browsable with the request
channel browsable method

00:11:43.200 --> 00:11:44.840
and pass our channel ID.

00:11:48.590 --> 00:11:51.950
Now we have such a channel row
visible on the home screen.

00:11:51.950 --> 00:11:54.200
And of course, we
want to add programs.

00:11:54.200 --> 00:11:57.820
This works in the very same
way, or in a very similar way.

00:11:57.820 --> 00:11:59.840
Again, we create a
builder instance,

00:11:59.840 --> 00:12:04.220
and this time it's a
preview program instance.

00:12:04.220 --> 00:12:07.070
And we populate the
data in this builder.

00:12:07.070 --> 00:12:09.730
Most importantly the
channel ID, of course,

00:12:09.730 --> 00:12:12.500
to which we link our
program to a given

00:12:12.500 --> 00:12:15.020
channel we've already created.

00:12:15.020 --> 00:12:18.800
Once we add a title,
description, and post art URI,

00:12:18.800 --> 00:12:22.880
we now can take the
content values, again built

00:12:22.880 --> 00:12:26.180
by our builder, and
insert it into the content

00:12:26.180 --> 00:12:27.655
provider of the TV contract.

00:12:32.560 --> 00:12:36.430
This API is already
documented in more detail

00:12:36.430 --> 00:12:37.955
on developer android.com.

00:12:37.955 --> 00:12:41.320
You'll find a guide about
displaying recommendations

00:12:41.320 --> 00:12:44.770
in the Android TV home
screen, which provides you

00:12:44.770 --> 00:12:48.040
with more details about how
you can maintain your channel

00:12:48.040 --> 00:12:51.780
and program data
in the database.

00:12:51.780 --> 00:12:55.330
With this, I'll point you to
our sandbox, Android TV sandbox,

00:12:55.330 --> 00:12:57.880
where you can play around
with the new launcher

00:12:57.880 --> 00:13:00.540
screen, and also the
Android TV office hours.

00:13:00.540 --> 00:13:02.980
We are happy to answer
your detailed question

00:13:02.980 --> 00:13:04.610
about Android TV.

00:13:04.610 --> 00:13:07.580
With this I give over to
Santiago from the ExoPlayer

00:13:07.580 --> 00:13:08.440
team.

00:13:08.440 --> 00:13:10.273
SANTIAGO SEIFERT: Thank
you very much, Mark.

00:13:10.273 --> 00:13:12.370
[APPLAUSE]

00:13:12.370 --> 00:13:14.980
Hello.

00:13:14.980 --> 00:13:16.590
Let's talk about ExoPlayer.

00:13:16.590 --> 00:13:19.270
ExoPlayer is an application
level media library

00:13:19.270 --> 00:13:19.840
for Android.

00:13:19.840 --> 00:13:23.320
It's an alternative to
Android platform media player.

00:13:23.320 --> 00:13:27.290
And the ExoPlayer library
has four main goals.

00:13:27.290 --> 00:13:29.914
The first goal is to reduce
the effects of fragmentation.

00:13:29.914 --> 00:13:31.330
Media playback on
Android has been

00:13:31.330 --> 00:13:34.480
flagged to be one of
the most affected areas

00:13:34.480 --> 00:13:37.060
by fragmentation.

00:13:37.060 --> 00:13:39.800
And ExoPlayer moves the
majority of the media player

00:13:39.800 --> 00:13:42.770
reimplementation to
the application layer.

00:13:42.770 --> 00:13:46.600
And so it's possible to update
through regular application

00:13:46.600 --> 00:13:49.630
updates, hence reducing the
effects of fragmentation.

00:13:49.630 --> 00:13:54.610
Most ExoPlayer functionality
works from Jellybean onwards.

00:13:54.610 --> 00:13:58.030
That covers the vast
majority of Android devices.

00:13:58.030 --> 00:14:03.650
Our second goal in the least is
to provide advanced features.

00:14:03.650 --> 00:14:06.490
So you already possibly
know that ExoPlayer

00:14:06.490 --> 00:14:08.860
provides some features
not currently supported

00:14:08.860 --> 00:14:12.160
by the media player API.

00:14:12.160 --> 00:14:15.370
This includes dash, smooth
streaming, persistent caching.

00:14:15.370 --> 00:14:17.980
There are others, but we
are also constantly working

00:14:17.980 --> 00:14:19.490
to add new features.

00:14:19.490 --> 00:14:23.710
So our latest additions
include a set of tools

00:14:23.710 --> 00:14:26.350
for downloading almost
any kind of media

00:14:26.350 --> 00:14:28.840
and playing it offline.

00:14:28.840 --> 00:14:31.560
There is also dynamic playlists.

00:14:31.560 --> 00:14:34.120
So you can create
dynamic playlists,

00:14:34.120 --> 00:14:38.360
modify them on the fly.

00:14:38.360 --> 00:14:41.040
This functionality is
also built in the player.

00:14:41.040 --> 00:14:44.740
So if we know enough
anticipation what

00:14:44.740 --> 00:14:48.160
media is coming, we
can shorten by a lot

00:14:48.160 --> 00:14:52.900
the gap between items
in the playlist.

00:14:52.900 --> 00:14:56.390
And you can do very cool stuff
with this, like for example,

00:14:56.390 --> 00:14:57.280
[INAUDIBLE].

00:14:57.280 --> 00:14:59.810
Which brings me to
my next feature,

00:14:59.810 --> 00:15:03.240
which is there is this
new component called

00:15:03.240 --> 00:15:06.250
buffer audio
processors, which allow

00:15:06.250 --> 00:15:09.550
many interesting audio features,
like the playback speed

00:15:09.550 --> 00:15:12.670
adjustment all the way back
from Jellybean onwards,

00:15:12.670 --> 00:15:15.820
and spatial audio
for virtual reality.

00:15:15.820 --> 00:15:18.730
And finally on a slightly
more technical level,

00:15:18.730 --> 00:15:23.170
there is support for the
full sync standard now.

00:15:23.170 --> 00:15:27.870
So we have had support for
sync for a long time now.

00:15:27.870 --> 00:15:30.481
Well, long time,
it has been around.

00:15:30.481 --> 00:15:32.980
And now we have added support
for the three remaining scheme

00:15:32.980 --> 00:15:33.890
types.

00:15:33.890 --> 00:15:35.650
Most interestingly,
these include

00:15:35.650 --> 00:15:39.850
CBCS, which is the scheme
type required by HLS for DRM

00:15:39.850 --> 00:15:41.290
protected content.

00:15:41.290 --> 00:15:43.930
So this is interesting
for content providers.

00:15:43.930 --> 00:15:48.160
This is by no means an
exhaustive list, but

00:15:48.160 --> 00:15:49.640
[INAUDIBLE].

00:15:49.640 --> 00:15:53.230
So there are a ton of
use cases for ExoPlayer.

00:15:53.230 --> 00:15:55.720
We know for a fact
that no size fits all.

00:15:55.720 --> 00:15:59.980
So the ability to customize
is one of the core principles

00:15:59.980 --> 00:16:01.540
in ExoPlayer.

00:16:01.540 --> 00:16:05.200
So this is our third goal,
to allow customization.

00:16:05.200 --> 00:16:08.320
So say, for example, that you
have amazing content which

00:16:08.320 --> 00:16:09.940
you want to stream
to Android devices

00:16:09.940 --> 00:16:13.730
and you come up with
a custom DRM scheme.

00:16:13.730 --> 00:16:17.650
So you create a component and
you inject it into ExoPlayer.

00:16:17.650 --> 00:16:19.900
Then after shipping and
having some metrics,

00:16:19.900 --> 00:16:22.030
you realize you
also want to tweak

00:16:22.030 --> 00:16:24.850
the way you mesh your
bandwidth because the network

00:16:24.850 --> 00:16:28.390
conditions of certain users,
you want just to tweak it.

00:16:28.390 --> 00:16:33.610
And by the way, it's also good
to customize the adaptation

00:16:33.610 --> 00:16:34.240
mechanism.

00:16:34.240 --> 00:16:36.640
So you create
components for that,

00:16:36.640 --> 00:16:38.170
you inject them to ExoPlayer.

00:16:38.170 --> 00:16:39.730
After shipping,
taking new metrics,

00:16:39.730 --> 00:16:43.870
you realize that you would
also like to customize

00:16:43.870 --> 00:16:45.760
the way you buffer the media.

00:16:45.760 --> 00:16:47.890
So you also create
all these components.

00:16:47.890 --> 00:16:51.490
All these things you can
inject into ExoPlayer.

00:16:51.490 --> 00:16:54.790
There are tons of hotspots for
injecting custom components

00:16:54.790 --> 00:16:58.400
in ExoPlayer at very
different abstraction levels.

00:16:58.400 --> 00:17:01.120
And now I'm going to speak
about our fourth goal, which

00:17:01.120 --> 00:17:04.630
is enable easy integration
with related libraries.

00:17:04.630 --> 00:17:10.359
Extensions are ExoPlayer modules
with external dependencies.

00:17:10.359 --> 00:17:12.250
For example, the IMA extension.

00:17:12.250 --> 00:17:16.420
For media distributors
who want to monetize

00:17:16.420 --> 00:17:19.869
their media, this
extension, which

00:17:19.869 --> 00:17:25.270
is a wrapper around the Google's
interactive media's SDK,

00:17:25.270 --> 00:17:29.033
it makes it extremely easy to
play ads along your content.

00:17:29.033 --> 00:17:32.110
And as a playlist, it's
integrated into the player.

00:17:32.110 --> 00:17:36.460
So you can reduce and almost
eliminate the weight cost

00:17:36.460 --> 00:17:40.180
by buffering [INAUDIBLE]
during media playback.

00:17:43.800 --> 00:17:46.280
There's also the cast
extension, which is quite new.

00:17:46.280 --> 00:17:51.000
Apps using ExoPlayer can
now almost effortlessly

00:17:51.000 --> 00:17:54.300
cast their content into
cast compatible devices.

00:17:54.300 --> 00:17:57.324
And you can even use
your custom UI components

00:17:57.324 --> 00:17:58.740
if you have any
that you are using

00:17:58.740 --> 00:18:01.590
to control ExoPlayer
to control playback

00:18:01.590 --> 00:18:03.990
on cast compatible devices.

00:18:03.990 --> 00:18:06.790
But Chromecast on TV is
not all we have in mind.

00:18:06.790 --> 00:18:08.940
There is also the media
session extension,

00:18:08.940 --> 00:18:13.560
which allows a ExoPlayer
instance to publish a media

00:18:13.560 --> 00:18:15.040
session.

00:18:15.040 --> 00:18:17.220
Therefore, you can control
that playback session

00:18:17.220 --> 00:18:19.890
from other apps
in other devices.

00:18:19.890 --> 00:18:23.670
And the images
above is being used

00:18:23.670 --> 00:18:28.020
on a mobile device
and Android [? out. ?]

00:18:28.020 --> 00:18:30.240
So this is very interesting.

00:18:30.240 --> 00:18:34.920
So ExoPlayer can also use, maybe
you know in virtual reality

00:18:34.920 --> 00:18:37.980
environments, but the
GVR extension also

00:18:37.980 --> 00:18:40.620
adds support for spatial
audio in ExoPlayer,

00:18:40.620 --> 00:18:41.760
which is very cool.

00:18:41.760 --> 00:18:44.670
It's also possible thanks
to audio processors,

00:18:44.670 --> 00:18:46.630
which I've mentioned before.

00:18:46.630 --> 00:18:48.925
There are many other extensions.

00:18:48.925 --> 00:18:51.300
Due to time constraints I'm
not going to delve into them.

00:18:51.300 --> 00:18:55.286
But I just want to mention that
most of them, or many of them,

00:18:55.286 --> 00:18:56.910
can be used to bundle
your own software

00:18:56.910 --> 00:18:58.435
recorders into applications.

00:18:58.435 --> 00:19:00.810
So you can make sure there is
support for specific codecs

00:19:00.810 --> 00:19:03.450
you're looking for on all
devices you want to ship for.

00:19:06.180 --> 00:19:08.760
So that's all from me.

00:19:08.760 --> 00:19:12.540
Please check our
medium blogspot.

00:19:12.540 --> 00:19:15.550
Try out the new stuff, the
new extensions, new features.

00:19:15.550 --> 00:19:19.080
Hope to see you tomorrow
at the office hours.

00:19:19.080 --> 00:19:21.588
Thank you very much,
I'll leave you with Aga.

00:19:21.588 --> 00:19:29.850
[APPLAUSE]

00:19:29.850 --> 00:19:32.280
AGNIEZKA MADURSKA:
Thank you, Santiago.

00:19:32.280 --> 00:19:34.770
Today I wanted to spend a
little time talking about one

00:19:34.770 --> 00:19:37.350
of the new APIs that we
launched with Android

00:19:37.350 --> 00:19:39.630
Wear and the support library.

00:19:39.630 --> 00:19:44.190
And it's got to do with
round screens and with lists.

00:19:44.190 --> 00:19:47.450
So this is our new
Wear 2.0 launcher

00:19:47.450 --> 00:19:51.190
that I started working on around
maybe a year and a half ago.

00:19:51.190 --> 00:19:53.340
And what we wanted to
do with this launcher is

00:19:53.340 --> 00:19:56.760
we wanted it to be fast, we
wanted it to be easy to use.

00:19:56.760 --> 00:19:58.440
But most importantly,
we wanted it

00:19:58.440 --> 00:20:02.890
to fit in with the curved screen
that all the new watches have.

00:20:02.890 --> 00:20:06.720
So round watches are by far
the most popular watches

00:20:06.720 --> 00:20:07.500
at the moment.

00:20:07.500 --> 00:20:11.850
Users love them, and they are
much, much, much more popular

00:20:11.850 --> 00:20:12.850
than the square ones.

00:20:12.850 --> 00:20:16.350
So we wanted to adjust our
design to that new trend

00:20:16.350 --> 00:20:19.200
and make it visually
more appealing and more

00:20:19.200 --> 00:20:22.170
fitting with the round UI.

00:20:22.170 --> 00:20:25.560
So this is how we
wanted it to look here

00:20:25.560 --> 00:20:29.730
on the left-hand side,
which is all grand.

00:20:29.730 --> 00:20:30.510
We knew that.

00:20:30.510 --> 00:20:33.430
But we needed to figure
out how to implement it.

00:20:33.430 --> 00:20:36.510
So this is what I
got from my designers

00:20:36.510 --> 00:20:39.900
here on the right-hand side,
which generally when you first

00:20:39.900 --> 00:20:41.850
look at it looks fabulous.

00:20:41.850 --> 00:20:44.640
A lot of people forget that
the launcher is static.

00:20:44.640 --> 00:20:46.340
I'm not exactly sure
why they forget,

00:20:46.340 --> 00:20:49.160
but the launcher is
not static, I'm sorry.

00:20:49.160 --> 00:20:50.890
You can scroll it up and down.

00:20:50.890 --> 00:20:53.400
And once you scroll
it up and down,

00:20:53.400 --> 00:20:55.950
you need to be able to
animate those elements

00:20:55.950 --> 00:20:59.920
in the launcher alongside the
curve that we want to achieve.

00:20:59.920 --> 00:21:03.150
And you don't only want to
animate them just like they

00:21:03.150 --> 00:21:05.040
are, you want to scale them.

00:21:05.040 --> 00:21:06.810
So you can see the
ones here at the top

00:21:06.810 --> 00:21:09.180
are slightly smaller than
the one in the center, which

00:21:09.180 --> 00:21:10.260
we want to focus on.

00:21:10.260 --> 00:21:13.980
If it's in the center,
that's the focused item.

00:21:13.980 --> 00:21:18.930
So for regular straight
lists, a lot of the work

00:21:18.930 --> 00:21:20.490
is done by Android framework.

00:21:20.490 --> 00:21:22.620
But when Android
was being designed

00:21:22.620 --> 00:21:25.380
nobody exactly thought
about round screens--

00:21:25.380 --> 00:21:27.940
like it's not a
thing for phones.

00:21:27.940 --> 00:21:31.270
So this was a new
challenge for us.

00:21:31.270 --> 00:21:35.340
So when I started
looking at the code,

00:21:35.340 --> 00:21:38.350
you can see on
the left-hand side

00:21:38.350 --> 00:21:40.230
here how the
straight list works.

00:21:40.230 --> 00:21:42.210
It's kind of straight.

00:21:42.210 --> 00:21:48.420
And when you scroll it, every
single element in the list

00:21:48.420 --> 00:21:51.030
moves by the same
amount of pixels

00:21:51.030 --> 00:21:55.200
at the same time, which creates
an illusion of scrolling.

00:21:55.200 --> 00:21:58.770
It's really a super
simple linear function.

00:21:58.770 --> 00:22:02.760
Now, this is not the case,
obviously, with the curved list

00:22:02.760 --> 00:22:03.940
that we have here.

00:22:03.940 --> 00:22:07.110
So you can see that not only
do we want to translate items

00:22:07.110 --> 00:22:10.870
on the y-axis, we also
for the curved list

00:22:10.870 --> 00:22:14.640
want to translate
them on the x-axis.

00:22:14.640 --> 00:22:17.040
So I'm OK with maths.

00:22:17.040 --> 00:22:18.990
So I figured the
function out for this.

00:22:18.990 --> 00:22:21.720
You can translate x
to y by using a very

00:22:21.720 --> 00:22:28.660
simple circle-based function.

00:22:28.660 --> 00:22:30.289
So I was very
pleased with myself.

00:22:30.289 --> 00:22:32.830
I went back to my design team,
I built a prototype, and said,

00:22:32.830 --> 00:22:34.250
hey, you guys, it's working.

00:22:34.250 --> 00:22:36.060
It's fine, it's looking well.

00:22:36.060 --> 00:22:39.330
They say, Aga, this
is really not good.

00:22:39.330 --> 00:22:40.432
No.

00:22:40.432 --> 00:22:41.640
It's really, really terrible.

00:22:41.640 --> 00:22:42.515
We can't launch this.

00:22:42.515 --> 00:22:45.390
There is no way, that was
so bad, Aga, so horrible.

00:22:45.390 --> 00:22:46.260
No way.

00:22:46.260 --> 00:22:49.980
What we really want is this.

00:22:49.980 --> 00:22:53.490
We want the circles to be
equidistant from each other,

00:22:53.490 --> 00:22:56.640
how you see here, which
means you can't linearly just

00:22:56.640 --> 00:23:02.160
translate and have the y
position exactly like you would

00:23:02.160 --> 00:23:05.010
have it in the straight list.

00:23:05.010 --> 00:23:08.160
You not only need to
translate in the x direction,

00:23:08.160 --> 00:23:10.435
you also need to do
it in the y direction.

00:23:10.435 --> 00:23:13.950
So you can see there's a
slight slope to these lines

00:23:13.950 --> 00:23:15.690
here and here.

00:23:15.690 --> 00:23:21.450
Also for the eagle-eyed view
here, the slope goes up here,

00:23:21.450 --> 00:23:24.800
but on the flip side here
on the bottom it goes down.

00:23:24.800 --> 00:23:29.250
So that just doesn't
make it easier at all.

00:23:29.250 --> 00:23:33.330
So instead of changing
just the value of x,

00:23:33.330 --> 00:23:37.170
we needed to change both
the values of x and y.

00:23:37.170 --> 00:23:38.910
So this is a problem in Android.

00:23:38.910 --> 00:23:43.540
Because once you change the
x or y values of any view,

00:23:43.540 --> 00:23:47.470
that triggers a new
layout path each time.

00:23:47.470 --> 00:23:51.810
So if you're changing y in
a vertically scrolling list,

00:23:51.810 --> 00:23:54.900
you will trigger a layout pass
on, and on, and on, and on,

00:23:54.900 --> 00:23:57.210
and on, because the old value--

00:23:57.210 --> 00:24:00.390
sorry, the new value is
treated as an old value

00:24:00.390 --> 00:24:02.850
on the next pass.

00:24:02.850 --> 00:24:05.600
And this is obviously
not what we wanted,

00:24:05.600 --> 00:24:10.210
or that would completely kind of
block the device, so not cool.

00:24:10.210 --> 00:24:12.810
So instead of changing
the value of y,

00:24:12.810 --> 00:24:16.720
we decided to translate the
view by just a little bit.

00:24:16.720 --> 00:24:18.450
So that is a very
subtle difference.

00:24:18.450 --> 00:24:22.680
Translations in Android do
not trigger a layout pass.

00:24:22.680 --> 00:24:25.230
So this was a simple
solution, and we

00:24:25.230 --> 00:24:29.650
were pleased with it to
implement it in the launcher.

00:24:29.650 --> 00:24:33.740
But as you can see, this is
probably not a unique problem.

00:24:33.740 --> 00:24:38.410
So we discovered that actually
it works for us for the curve,

00:24:38.410 --> 00:24:41.990
but it could work
for any other path.

00:24:41.990 --> 00:24:44.710
So that's why on the top of
the solution for the long term,

00:24:44.710 --> 00:24:47.320
my team built an
API that enables

00:24:47.320 --> 00:24:51.220
you to use any chosen path,
however funky it might be,

00:24:51.220 --> 00:24:51.720
right?

00:24:51.720 --> 00:24:53.080
Like this thing here.

00:24:53.080 --> 00:24:54.580
I mean, if you want
to implement it,

00:24:54.580 --> 00:24:55.913
you can implement it, basically.

00:24:55.913 --> 00:24:58.270
I don't know why, but you can.

00:24:58.270 --> 00:25:02.536
And the only caveat is that we
will not give you the maths.

00:25:02.536 --> 00:25:03.910
We will not do
the maths for you.

00:25:03.910 --> 00:25:04.826
I had enough of maths.

00:25:04.826 --> 00:25:11.270
So we will give you a container,
the wearable recycler view.

00:25:11.270 --> 00:25:13.600
We will give you
all the callbacks.

00:25:13.600 --> 00:25:16.480
But you need to supply
us with the path.

00:25:16.480 --> 00:25:21.355
And then how the path is used
is a little bit like this.

00:25:21.355 --> 00:25:25.540
So this will go live in Android
O when it drops to open source.

00:25:25.540 --> 00:25:28.990
This is the curve that
we used for the launcher.

00:25:28.990 --> 00:25:30.400
I won't bore you with details.

00:25:30.400 --> 00:25:33.460
It's basically a Bezier
curve with some extra details

00:25:33.460 --> 00:25:35.290
here and there.

00:25:35.290 --> 00:25:37.890
So this is a kind of maths
that you might want to do.

00:25:37.890 --> 00:25:40.900
It's not as scary as
it looks, it's fine.

00:25:40.900 --> 00:25:43.450
And then when you have
the maths for the path,

00:25:43.450 --> 00:25:46.210
this is how you would
actually use it in code.

00:25:46.210 --> 00:25:48.550
And this line here is the
crucial one where you just

00:25:48.550 --> 00:25:51.580
get the tangent line
to the path you have,

00:25:51.580 --> 00:25:56.620
and then apply the positions
to the children in the view.

00:25:56.620 --> 00:26:00.160
So here again, this is
the general architecture

00:26:00.160 --> 00:26:01.570
of the API.

00:26:01.570 --> 00:26:04.810
This is all provided in the
Wear UI support library, which

00:26:04.810 --> 00:26:07.150
is now part of Android
Support Library, which means

00:26:07.150 --> 00:26:09.220
it's going to get open sourced.

00:26:09.220 --> 00:26:13.510
And this is the chosen path
that you need to provide.

00:26:13.510 --> 00:26:16.850
What is specifically not
provided is the scaling,

00:26:16.850 --> 00:26:17.980
but that's pretty trivial.

00:26:17.980 --> 00:26:19.750
We didn't provide
this part of the API

00:26:19.750 --> 00:26:22.990
because you might want to put
in different shapes of children

00:26:22.990 --> 00:26:26.770
into the wearable recycler view.

00:26:26.770 --> 00:26:29.440
So to learn more
about this API, you

00:26:29.440 --> 00:26:31.420
can search for
wearable recycler view.

00:26:31.420 --> 00:26:34.390
The curving layout callback
and generally curved

00:26:34.390 --> 00:26:35.590
layout Android Wear.

00:26:35.590 --> 00:26:38.309
It's in the developer
documentation,

00:26:38.309 --> 00:26:39.850
and obviously you
can just Google it.

00:26:39.850 --> 00:26:43.000
There's plenty of stuff
on Stack Overflow.

00:26:43.000 --> 00:26:44.000
So that's all from me.

00:26:44.000 --> 00:26:45.610
I hope this has
going to be helpful.

00:26:45.610 --> 00:26:47.860
And with that I'll
hand over to Dan.

00:26:52.061 --> 00:26:53.560
DANIEL GALPIN: All
right, thank you.

00:26:53.560 --> 00:26:54.550
That was pretty awesome.

00:26:54.550 --> 00:26:56.216
All right, let's jump
right into AAudio,

00:26:56.216 --> 00:26:57.580
because we're short on time.

00:26:57.580 --> 00:27:00.100
First of all, why a new API?

00:27:00.100 --> 00:27:02.799
We already have open
SLES and Java APIs.

00:27:02.799 --> 00:27:04.840
But we've listened to a
lot of developer feedback

00:27:04.840 --> 00:27:08.380
and you guys have told us that
audio processing with open SLES

00:27:08.380 --> 00:27:12.700
is really hard, and we think
we can make it easier to use.

00:27:12.700 --> 00:27:14.410
And you know, all of
these original APIs

00:27:14.410 --> 00:27:16.840
go through the original
audio flinger framework.

00:27:16.840 --> 00:27:19.090
But since making huge changes
there could potentially

00:27:19.090 --> 00:27:21.877
break lots of apps,
AAudio has a new server,

00:27:21.877 --> 00:27:23.710
so we can do some pretty
radical things that

00:27:23.710 --> 00:27:27.790
should get us some big
performance enhancements.

00:27:27.790 --> 00:27:29.680
So it uses the
concept of streams.

00:27:29.680 --> 00:27:32.350
And in this case, we can see
a stream flowing from the mic

00:27:32.350 --> 00:27:34.391
all the way back to the
app, and all the way back

00:27:34.391 --> 00:27:35.170
to the headphones.

00:27:35.170 --> 00:27:37.210
And these streams are
straightforward to create

00:27:37.210 --> 00:27:39.117
using a builder
design pattern, which

00:27:39.117 --> 00:27:41.200
allows you to create a
builder with your requested

00:27:41.200 --> 00:27:43.000
customizations that
can be then used

00:27:43.000 --> 00:27:45.129
to create multiple streams.

00:27:45.129 --> 00:27:46.170
And this is kind of cool.

00:27:46.170 --> 00:27:48.461
You can actually set up the
builder as kind of a rubber

00:27:48.461 --> 00:27:50.830
stamp to create audio streams.

00:27:50.830 --> 00:27:53.590
So in this code we have
the AAudio stream builder.

00:27:53.590 --> 00:27:56.500
And this gets you a default
stream, which is probably

00:27:56.500 --> 00:27:58.420
a stereo audio output stream.

00:27:58.420 --> 00:28:00.490
And here's how you would
request specific values

00:28:00.490 --> 00:28:01.780
for direction and format.

00:28:01.780 --> 00:28:04.270
So you can see you get input
and output streams from this.

00:28:04.270 --> 00:28:05.770
And once you set
up the stream you

00:28:05.770 --> 00:28:07.597
can call open stream
on the builder.

00:28:07.597 --> 00:28:09.430
And if you didn't set
things like the sample

00:28:09.430 --> 00:28:11.720
rate and format, you'll
need to query them.

00:28:11.720 --> 00:28:13.810
And finally, you'll get
the frames per burst

00:28:13.810 --> 00:28:18.020
from the audio stream to get
the optimal read-write size.

00:28:18.020 --> 00:28:19.990
And this is kind of
how this all works.

00:28:19.990 --> 00:28:23.770
In AAudio, a buffer refers to
these arrays of these bursts.

00:28:23.770 --> 00:28:26.710
And data is written
in these bursts

00:28:26.710 --> 00:28:29.500
through the DAC, which
actually turns audio

00:28:29.500 --> 00:28:32.470
into something your
headphones can actually hear.

00:28:32.470 --> 00:28:33.910
And in this diagram,
this app, has

00:28:33.910 --> 00:28:36.220
generated two bursts of
data, and the first burst

00:28:36.220 --> 00:28:37.190
will be written.

00:28:37.190 --> 00:28:40.960
And as you might expect, you
can start, and pause, and flush

00:28:40.960 --> 00:28:43.360
or stop your stream, and
all with asynchronous calls.

00:28:43.360 --> 00:28:45.645
And for most use
cases this is optimal.

00:28:45.645 --> 00:28:48.020
But we do have functions you
can synchronize these things

00:28:48.020 --> 00:28:49.390
if you need to.

00:28:49.390 --> 00:28:51.069
All right, again,
it's a simple API.

00:28:51.069 --> 00:28:52.610
We've got to cover
it in six minutes.

00:28:52.610 --> 00:28:54.940
So how do you get data in
and out of the streams?

00:28:54.940 --> 00:28:57.820
OK, so for apps that don't
need super low latency,

00:28:57.820 --> 00:28:59.650
you can just use
blocking writes.

00:28:59.650 --> 00:29:01.690
And here we're in a
loop, and the blocking

00:29:01.690 --> 00:29:04.390
write function returns either
the number of frames written

00:29:04.390 --> 00:29:05.590
or an error.

00:29:05.590 --> 00:29:07.340
And this blocking
write can time out,

00:29:07.340 --> 00:29:09.490
so we might only get part
of the frames written.

00:29:09.490 --> 00:29:12.809
So we need to make sure
to handle that case.

00:29:12.809 --> 00:29:14.350
But when you need
the lowest latency,

00:29:14.350 --> 00:29:16.540
you need to be running
on a special thread

00:29:16.540 --> 00:29:17.980
to do your audio processing on.

00:29:17.980 --> 00:29:21.400
Maybe one that's
scheduled with SCHED_FIFO.

00:29:21.400 --> 00:29:23.200
So you write this
callback function,

00:29:23.200 --> 00:29:25.810
and AAudio will pass through
the stream parameter, any user

00:29:25.810 --> 00:29:28.450
data that you need, the audio
data buffer, and the number

00:29:28.450 --> 00:29:30.910
of frames, and then you
can render your audio right

00:29:30.910 --> 00:29:34.000
into that audio buffer on
the high priority thread.

00:29:34.000 --> 00:29:38.126
So you set up this callback
actually in the building.

00:29:38.126 --> 00:29:39.750
All right, some people
were like, well,

00:29:39.750 --> 00:29:41.390
what I really want to do
is do audio processing.

00:29:41.390 --> 00:29:43.265
That means I need to
take audio that comes in

00:29:43.265 --> 00:29:44.470
and turn it into something.

00:29:44.470 --> 00:29:45.260
How do I do that?

00:29:45.260 --> 00:29:46.843
How do I mix two or
more input streams

00:29:46.843 --> 00:29:48.190
and send it to an output?

00:29:48.190 --> 00:29:50.560
So what you do we recommend
is using the stream

00:29:50.560 --> 00:29:53.440
as the master callback,
usually the output stream.

00:29:53.440 --> 00:29:54.820
And in this simple
example, we're

00:29:54.820 --> 00:29:56.610
just passing data
from input to output.

00:29:56.610 --> 00:29:57.952
Oh, I love my square there.

00:29:57.952 --> 00:30:00.160
And we read from the input
stream with a zero timeout

00:30:00.160 --> 00:30:01.699
to do a non-blocking read.

00:30:01.699 --> 00:30:03.490
And that goes right
into the output buffer.

00:30:03.490 --> 00:30:05.948
And notice that it may take a
couple of calls for these two

00:30:05.948 --> 00:30:07.540
streams to synchronize.

00:30:07.540 --> 00:30:09.520
The output stream, input stream.

00:30:09.520 --> 00:30:12.580
OK, finally let's talk about
dynamic latency tuning.

00:30:12.580 --> 00:30:14.066
And this is kind of important.

00:30:14.066 --> 00:30:15.940
Because looking back at
our previous diagram,

00:30:15.940 --> 00:30:18.160
we have two bursts ready
to be consumed by the DAC.

00:30:18.160 --> 00:30:20.020
And if we're glitching because
we're getting preempted

00:30:20.020 --> 00:30:22.020
all the time, we might
want to add another burst

00:30:22.020 --> 00:30:23.460
to our renderer.

00:30:23.460 --> 00:30:26.120
And so this is kind of the
way we do this simplified.

00:30:26.120 --> 00:30:27.910
We can detect
overruns or underruns

00:30:27.910 --> 00:30:30.840
we've had on our output stream
by calling get x run count.

00:30:30.840 --> 00:30:32.830
And if it's changed
since the last time

00:30:32.830 --> 00:30:34.850
you checked you've got a glitch.

00:30:34.850 --> 00:30:37.660
So you can just add another
burst to your buffer size.

00:30:37.660 --> 00:30:38.950
Pretty straightforward.

00:30:38.950 --> 00:30:43.960
So once again, here is basic
AAudio using a blocking write.

00:30:43.960 --> 00:30:44.860
OK, really simple.

00:30:44.860 --> 00:30:46.060
We've got a stream builder.

00:30:46.060 --> 00:30:47.422
We've opened a stream.

00:30:47.422 --> 00:30:48.380
Pretty straightforward.

00:30:48.380 --> 00:30:49.900
We request start.

00:30:49.900 --> 00:30:53.650
And then while we're processing,
we just write frames.

00:30:53.650 --> 00:30:57.190
Like kind of how you
should work, right?

00:30:57.190 --> 00:30:59.440
And then we close it and
we're done, because you know,

00:30:59.440 --> 00:31:00.190
we're always good.

00:31:00.190 --> 00:31:01.570
And this is a C
API, so we really

00:31:01.570 --> 00:31:03.070
need to make sure
we close things.

00:31:03.070 --> 00:31:05.560
And here is just a
partial equivalent

00:31:05.560 --> 00:31:09.010
of what we'd have to
do this in open SLES.

00:31:09.010 --> 00:31:10.730
So again, you know,
the goal is not just

00:31:10.730 --> 00:31:12.670
to only make audio
higher performance,

00:31:12.670 --> 00:31:15.100
but it also gives us-- it
makes it much easier to write

00:31:15.100 --> 00:31:16.800
these programs entirely.

00:31:16.800 --> 00:31:19.120
And so now you're saying,
like, but wait, this

00:31:19.120 --> 00:31:22.760
is only in Android O. How
am I going to use this?

00:31:22.760 --> 00:31:25.840
And so the good news we have
for that is that we're actually

00:31:25.840 --> 00:31:28.210
working on a C++ wrapper.

00:31:28.210 --> 00:31:29.770
And this wrapper
is not only going

00:31:29.770 --> 00:31:32.420
to be able to target
Android O and AAudio,

00:31:32.420 --> 00:31:34.870
but it's actually going to
work on older Android platforms

00:31:34.870 --> 00:31:35.780
as well.

00:31:35.780 --> 00:31:38.320
And so you'll actually be able
to use this new simplified

00:31:38.320 --> 00:31:40.278
interface-- in fact, in
some ways almost easier

00:31:40.278 --> 00:31:41.230
because it's C++--

00:31:41.230 --> 00:31:45.190
on both older and newer
versions of Android.

00:31:45.190 --> 00:31:46.211
So pretty cool.

00:31:46.211 --> 00:31:47.710
It's going to have
similar concepts.

00:31:47.710 --> 00:31:48.505
It's going to use DLsim.

00:31:48.505 --> 00:31:50.338
It's just going to use
DLsim runtime linking

00:31:50.338 --> 00:31:53.330
to talk to AAudio, or it's
going to have a backend that

00:31:53.330 --> 00:31:56.390
talks to open SLES.

00:31:56.390 --> 00:31:57.440
So cool, and that's it.

00:31:57.440 --> 00:31:58.970
We've covered it
in four minutes.

00:31:58.970 --> 00:32:02.120
It's that easy.

00:32:02.120 --> 00:32:02.900
And it really is.

00:32:02.900 --> 00:32:05.159
Like, honestly, the
audio developers

00:32:05.159 --> 00:32:07.700
we've worked with who've used
this API already have come back

00:32:07.700 --> 00:32:10.744
and said thank you.

00:32:10.744 --> 00:32:12.410
How many people here
have actually tried

00:32:12.410 --> 00:32:14.940
using open SLES to
do their audio app?

00:32:14.940 --> 00:32:15.440
See?

00:32:15.440 --> 00:32:18.860
That's how popular it is!

00:32:18.860 --> 00:32:21.467
Anyway, so on behalf of myself
and all of the presenters

00:32:21.467 --> 00:32:23.300
who've come to the stage
do lightning talks,

00:32:23.300 --> 00:32:24.380
thank you all for coming.

00:32:24.380 --> 00:32:27.710
And you know, we're going
to have office hours.

00:32:27.710 --> 00:32:30.750
So today you can come to
Android Wear office hours.

00:32:30.750 --> 00:32:33.050
We're going to have Android
Auto office hours tomorrow,

00:32:33.050 --> 00:32:34.689
and ExoPlayer office hours.

00:32:34.689 --> 00:32:36.230
So if there are any
burning questions

00:32:36.230 --> 00:32:39.057
you had on any of these topics,
please come by and talk to us.

00:32:39.057 --> 00:32:40.640
You can also, if you
see me out there,

00:32:40.640 --> 00:32:43.940
I can try to answer
questions on AAudio,

00:32:43.940 --> 00:32:45.800
which is also pretty cool.

00:32:45.800 --> 00:32:46.800
And that's it.

00:32:46.800 --> 00:32:48.320
So thank you on
behalf of the panel.

00:32:48.320 --> 00:32:51.370
[APPLAUSE]

