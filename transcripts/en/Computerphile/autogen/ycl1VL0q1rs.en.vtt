WEBVTT
Kind: captions
Language: en

00:00:00.030 --> 00:00:02.030
Well, let me begin by asking you a question

00:00:02.290 --> 00:00:05.940
Okay, what do you think the simplest program we could write

00:00:05.940 --> 00:00:07.029
well

00:00:07.029 --> 00:00:10.000
Not being a programmer but having done a lot of computerphile videos.

00:00:10.000 --> 00:00:12.900
I suspect we're going for hello world here

00:00:14.980 --> 00:00:16.320
So, yeah hello world

00:00:16.320 --> 00:00:21.990
I mean, it's probably the classic one everyone start with if we... we can even write it on a piece of paper

00:00:22.359 --> 00:00:26.519
I'm going to use C to talk about this. You could write it in any programming language of your choice

00:00:27.369 --> 00:00:33.898
Let me guess you walked into Dixon's and wrote a rather rude version of hello world. I didn't you, probably did

00:00:35.620 --> 00:00:39.480
Oh, so the scrolling on the screen thing your basic is effectively hello world

00:00:39.480 --> 00:00:40.700
It's basically hello world

00:00:40.700 --> 00:00:45.869
So I'd go some prints something and then yeah, that's the more advanced version. But yeah, I think so

00:00:45.870 --> 00:00:48.809
We could write it and see we have our main function

00:00:48.969 --> 00:00:52.889
we have to have a few arguments if we're doing this properly because otherwise we'll get

00:00:53.020 --> 00:00:55.799
Complaints in the comments and then we can do a printer

00:00:56.590 --> 00:00:58.590
hello dot dot

00:00:58.930 --> 00:01:01.439
Backslash Ames we want to go to a new line at the end

00:01:02.289 --> 00:01:03.399
and

00:01:03.399 --> 00:01:06.268
A head of files and we've written Heather world

00:01:06.270 --> 00:01:12.990
These pens are bought because they're a bit quieter and yet there's always a compromise somewhere isn't there's no other perfect pen

00:01:12.990 --> 00:01:16.680
Now we've got pens that you can't actually read so there's a hello world program

00:01:17.350 --> 00:01:22.949
And on the face of it it is one of the simplest programs you can write you can understand the instructions

00:01:23.860 --> 00:01:30.509
That's going on and it says print whatever string it is. Hello world and it print it out. You compile it and you run it

00:01:31.240 --> 00:01:37.199
But actually when you think about what's going is it a lot a lot of functionality is being hidden behind there

00:01:37.200 --> 00:01:37.900
It's a good illustration

00:01:37.900 --> 00:01:43.109
And one of the things you see a lot in computer science is that we build computer systems by using layers of abstraction

00:01:43.630 --> 00:01:49.649
So we're making use of a code library. So what we've already got here is a level of abstraction in that

00:01:50.229 --> 00:01:54.629
Printf does a lot of things it can do more than just print out a single line of text

00:01:55.180 --> 00:01:58.799
we can actually get it to print out numbers integers as

00:02:00.130 --> 00:02:03.479
Text so we can read them on the screen and it will convert them from the integer

00:02:03.820 --> 00:02:06.899
to think so that's code libraries hiding a whole layer of

00:02:08.470 --> 00:02:15.089
Instructions so we can think about this in terms of we get another bit paper. Let's turn it upside down and use the Australian version

00:02:17.140 --> 00:02:20.250
We can think about we write our program and we're writing it

00:02:21.490 --> 00:02:23.160
And I've used the wrong pen again

00:02:23.160 --> 00:02:28.169
We're writing it in C and we're making use of that C standard library to actually make it do things

00:02:28.170 --> 00:02:30.540
but of course as we know

00:02:31.300 --> 00:02:37.680
The computers don't understand C. They understand their machine code. So actually we already have to convert this into

00:02:38.500 --> 00:02:45.119
The machine code for the program so we convert it into the machine code for the CPU that we're running on in this case

00:02:45.190 --> 00:02:50.309
It's an x86 thing, but we could run it on a six eight thousand. We could run another Zed 8006 five or a two

00:02:51.970 --> 00:02:57.449
PowerPC whatever type of computer you wanted to so we've already got on two layers of abstraction there

00:02:57.450 --> 00:02:59.730
We've got without stretching away how the hardware works

00:03:00.550 --> 00:03:04.770
Because as soon as you write it and see we can then compile it to run on different CPUs

00:03:05.200 --> 00:03:07.649
But we've also started to abstract away

00:03:08.170 --> 00:03:14.699
How we actually print something out so we can use printf to print a number we can use it to print text

00:03:14.890 --> 00:03:17.160
But we don't have to know how to convert a number

00:03:17.740 --> 00:03:19.060
into

00:03:19.060 --> 00:03:21.060
Text what does the F stand for?

00:03:21.970 --> 00:03:26.550
Okay. Well, that's a very good thing printf time to print formatted and that's what I was talking about

00:03:26.550 --> 00:03:31.950
So you can say I want to print this number and you can also say I want it formatted to look like this

00:03:31.950 --> 00:03:37.979
So I want this many of leading zeroes. I want this many decimal places afterwards and so on you can format the output

00:03:38.010 --> 00:03:40.799
Hence the app so we've got a program here

00:03:40.800 --> 00:03:45.660
We've got a hello world program and we want to print out the variable with a 42 in it

00:03:46.390 --> 00:03:48.899
We can say print out hello world

00:03:49.720 --> 00:03:53.970
And we can put a % D in there. Just say we want to print out a number and

00:03:55.330 --> 00:03:57.600
Then we can compile that program

00:04:00.520 --> 00:04:06.179
Of course they have not made any mistakes and if we run that thing it prints out the number 42

00:04:06.180 --> 00:04:13.380
And again, this is a good example of that abstraction. If I were to print out that number with four leading zeros, I can say

00:04:14.290 --> 00:04:16.290
% 0 for D

00:04:16.419 --> 00:04:18.419
Compile it again

00:04:19.810 --> 00:04:26.410
And it prints it out 0 0 for 2 all that sort of complexity well do I print out that number

00:04:26.770 --> 00:04:28.779
Okay, well had open time ago divide it by 10

00:04:29.150 --> 00:04:33.609
The remainder will be that did you I need to put it last than the rest of the number and then I drew that again

00:04:34.190 --> 00:04:38.140
That's all abstracted away from me as a programmer. I can think about what I want to write

00:04:38.900 --> 00:04:42.519
At a high level, which is our different out hello world followed by the number

00:04:43.520 --> 00:04:47.589
With two leading zeros, and we could write that so we've already abstracted that away

00:04:48.950 --> 00:04:55.659
But that standard library then still needs to print that out. So it needs to take each of the characters its generated and

00:04:56.540 --> 00:04:58.460
Print them out on screen

00:04:58.460 --> 00:05:00.460
or send them to

00:05:00.680 --> 00:05:07.090
the serial teletype that you're dealing with or however it is you're outputting these things because if you think about it a

00:05:07.400 --> 00:05:09.400
modern computer system

00:05:09.980 --> 00:05:15.819
I'm sitting at my computer here typing the commands in to run that program just written on this system

00:05:16.430 --> 00:05:22.030
but I could have logged in remotely using SSH or something to another computer system and run the program there and

00:05:22.190 --> 00:05:24.339
Then it would have had to do something different

00:05:24.340 --> 00:05:28.060
So in this case, it's printing it on my local screen if I'd logged in to a different machine

00:05:28.060 --> 00:05:33.040
You would have to run the program there send the characters. He wants to print having encrypted them

00:05:34.040 --> 00:05:37.569
to my machine and then print them out sue got a different thing so

00:05:38.600 --> 00:05:46.270
Even the C standard library is built to print things out but it's built on and I was stretching in this case that abstraction

00:05:46.880 --> 00:05:49.989
Is the operating system so we can add another

00:05:50.540 --> 00:05:57.730
Layer of abstraction, which is the operating system and most operating systems. Certainly the modern ones. We get UNIX windows mac

00:05:57.730 --> 00:06:04.119
o s-- viscose whatever one you were to do will provide some level of abstraction so you can just say print this and

00:06:04.430 --> 00:06:07.870
It will then send it to the right thing and do the right thing based on what you go

00:06:07.870 --> 00:06:10.900
So I hello world program are suddenly gone from being one

00:06:11.450 --> 00:06:17.529
Line that prints things out, but that's then opened a can of worms because it's using a library

00:06:17.570 --> 00:06:23.679
It's also being converted to machine code we can see that so we can tell the compiler to just produce the machine code for us

00:06:23.680 --> 00:06:25.270
And then if we open that up

00:06:25.270 --> 00:06:31.659
We get the machine code version here. And as you can see that's quite a lot more lines of text that we've got

00:06:31.660 --> 00:06:35.980
There we can see there the call to printf and we're doing various things to get that

00:06:36.140 --> 00:06:40.609
How that works is perhaps another video on how we call the function in the machine code

00:06:40.610 --> 00:06:44.659
So let's backtrack a bit from printf because as we've talked about that's a more complicated

00:06:45.270 --> 00:06:51.710
Implementation it can format the text and let's just think about how we can just print a single string to the screen

00:06:51.710 --> 00:06:55.069
so let's rewrite this program to use put's which is another

00:06:55.710 --> 00:07:00.799
C standard library function that can print out. I think this one can't do formatted text

00:07:00.800 --> 00:07:05.270
So remove our additions and so we now got a slightly simpler

00:07:05.490 --> 00:07:09.500
Version of hello world that still does the same thing and then it prints out hello world

00:07:09.840 --> 00:07:13.579
It also prints an extra new line because puts my app as a standard output

00:07:13.580 --> 00:07:16.639
It adds a new line to use it got slightly from bit of functionality

00:07:17.190 --> 00:07:22.309
But we can start to think about how that works. So what that is given as input is

00:07:23.009 --> 00:07:25.939
the string hello world, which is

00:07:26.789 --> 00:07:33.468
Arranged in memory suddenly. Our program is getting more complicated because we're actually having to think about how things are stored in there as

00:07:35.129 --> 00:07:40.218
Basically a series of memory locations one after the other with the H followed by the e

00:07:40.740 --> 00:07:48.409
Followed by the L followed by another L followed by an O and so on and so what pot-stirring would have to do

00:07:48.930 --> 00:07:53.329
For a naive implementation would do is its points at the H it gets that character

00:07:53.580 --> 00:07:57.830
Prints it out to the screen and it gets the next character prints it out to the screen

00:07:57.930 --> 00:08:02.569
Then it gets the next character prints out of screen and so on until it gets to some end

00:08:02.759 --> 00:08:03.419
marker

00:08:03.419 --> 00:08:06.978
Which in C is done by putting a 0?

00:08:07.229 --> 00:08:12.829
Character the ASCII code 0 to represent the end of string or the programming language do it differently pascal

00:08:12.830 --> 00:08:16.460
For example, put the length of the string at the beginning as a number

00:08:16.460 --> 00:08:22.009
So it's said to be x characters and then it print out X characters C says the strings ended by putting a 0

00:08:22.500 --> 00:08:24.419
at the end

00:08:24.419 --> 00:08:28.788
So we've already what looked like a simple program when we take away the layer of abstraction

00:08:29.789 --> 00:08:32.208
becomes more complicated now actually

00:08:32.209 --> 00:08:36.589
if you were to implement this you wouldn't print each character separately because

00:08:36.990 --> 00:08:40.190
to print it we said we have to call the operating system and

00:08:40.380 --> 00:08:46.760
Every time we call the operating system we have to pass control from the user mode to supervisor mode

00:08:46.760 --> 00:08:51.229
The operating system's mode which takes some time. So actually what we would do

00:08:51.730 --> 00:08:58.510
Send it directly as a string to the operating system and then the operating system will print out that whole string for us

00:08:58.510 --> 00:09:03.129
So we can change our program to do that in that we now use the command

00:09:03.649 --> 00:09:08.109
Write write consented lots of different places so we can set it to the standard output

00:09:08.110 --> 00:09:10.110
Which on UNIX is number one?

00:09:10.130 --> 00:09:15.039
Send the string and now we need to tell it how many characters there are so hello has got five worlds got five

00:09:15.040 --> 00:09:19.990
That's ten. I've got a space and a new line. That's 12. So we want to send 12

00:09:21.079 --> 00:09:23.349
Characters so let's compile that version up

00:09:24.290 --> 00:09:28.149
And I haven't put the right header in for

00:09:29.209 --> 00:09:33.309
That so we're getting a error message that was included to my harridans

00:09:34.190 --> 00:09:38.709
It's to work and now if you run hello world, it's still prints. Hello world

00:09:38.709 --> 00:09:45.009
But we've taken away another layer of abstraction in that this case my C program is directly calling

00:09:45.260 --> 00:09:49.059
the operating system so we removed that level of

00:09:50.209 --> 00:09:54.909
abstraction now as we said the operating system code then has to

00:09:55.610 --> 00:09:59.260
interact with all the different things and on a system like UNIX

00:10:00.529 --> 00:10:03.609
Because of the heritage of it back to the 1970s and earlier

00:10:04.579 --> 00:10:08.619
it emulates a Tele time machine and a teletype machine was basically

00:10:09.649 --> 00:10:14.169
Typewriter that was controlled by electronics and you sent the characters and in move things one after the other

00:10:14.690 --> 00:10:21.039
Printing the characters out onto paper not unlike this and then when you sent the line feed character

00:10:21.440 --> 00:10:23.889
You actually move to the next line

00:10:24.019 --> 00:10:24.519
actually

00:10:24.519 --> 00:10:28.089
the original teletypes required you to send both a carriage return and

00:10:28.430 --> 00:10:31.930
A line feed because you have to send the thing back to the beginning of the carriage

00:10:31.930 --> 00:10:37.690
So these are mechanical bits of there's a mechanical bits of things and actually you still see this today

00:10:37.819 --> 00:10:42.909
the reason why UNIX and Windows differ on how text files are encoded is

00:10:43.279 --> 00:10:45.698
That Windows and carries both the carriage return

00:10:45.860 --> 00:10:51.639
Which sends things back to the end and the line feed to go on to the next line that you have to send?

00:10:51.860 --> 00:10:55.089
To the teletype whereas the eunuch said. Well actually

00:10:55.790 --> 00:11:00.490
What was going to send that different things have different things will just send a line feed and so the UNIX operating system

00:11:00.949 --> 00:11:03.129
Abstracted that away so our hello world program

00:11:04.610 --> 00:11:06.790
simple and is simple

00:11:07.520 --> 00:11:11.139
Because there's a whole load of other things going on which are hidden from us

00:11:11.140 --> 00:11:16.359
They're abstracted away so we can think about it in terms of I want to print out this line of text

00:11:16.610 --> 00:11:20.320
But actually under the hood there's lots of things going on extra bits of code

00:11:20.320 --> 00:11:24.010
Which are doing things even things like when it appears on screen?

00:11:24.830 --> 00:11:30.369
The operating system is having to think. Well, actually, I've got to draw the dots that make up the edge here and

00:11:31.130 --> 00:11:37.390
Because the way a teletype certainly in the Western world has been designed to work means of the ease following

00:11:37.790 --> 00:11:39.790
That then I've got to fin the e

00:11:40.610 --> 00:11:46.120
After that and work out what positions they're going on. And so if you were to look at all the code necessary

00:11:46.820 --> 00:11:48.380
To write hello world

00:11:48.380 --> 00:11:52.989
From the bare Hardware bearing in mind that you've got to find out what Hardware you've got on there

00:11:53.120 --> 00:11:58.359
And then talk to it in the right place you find it would be a lot of code to do a very simple program

00:11:59.270 --> 00:12:02.169
Like hello world. Is there a simpler program?

00:12:03.110 --> 00:12:05.110
It's a program. It doesn't do anything

00:12:07.880 --> 00:12:09.880
Well if I just

00:12:10.340 --> 00:12:11.510
delete

00:12:11.510 --> 00:12:16.210
That we think that a program that starts and stops and doesn't do anything

00:12:16.400 --> 00:12:19.599
With that still call operating systems and open libraries and things

00:12:20.030 --> 00:12:22.269
So this is interesting things that yeah, this is a good point

00:12:22.270 --> 00:12:26.650
Is that actually that program if we compile it and have a look at the machine code?

00:12:27.080 --> 00:12:34.389
We now see that actually there isn't much there. This is basically the whole code here. The rest is just setting up various things

00:12:34.390 --> 00:12:40.960
So it works what the compiler have done things there then and yes, we've now got we've got about four or five instruction

00:12:41.480 --> 00:12:42.860
but

00:12:42.860 --> 00:12:44.860
That isn't the beginning of our program

00:12:45.110 --> 00:12:46.840
When you compile the C program?

00:12:46.840 --> 00:12:50.139
There's an extra bit that's joined on to the beginning that's linked onto the beginning

00:12:50.360 --> 00:12:55.599
Which sets up the operators and research how much memory this program needs and so on and gets things to the point

00:12:55.880 --> 00:12:58.809
Where that prone could work? So actually that isn't the whole program

00:12:58.910 --> 00:13:00.640
But it's getting close enough

00:13:00.640 --> 00:13:01.690
and of course

00:13:01.690 --> 00:13:05.650
We still have to bear in mind that we've got to boot the computer when we turn the computer on

00:13:06.140 --> 00:13:10.689
The computer starts in a defined way. It starts executing code at a defined location

00:13:11.360 --> 00:13:16.090
Your BIOS is then there in a modern machine or you fei in a really modern machine

00:13:16.610 --> 00:13:22.100
Executing things that will then start to the point where it can load the operating system the operating systems loading up

00:13:22.320 --> 00:13:26.120
So it can talk to various other things and so on

00:13:26.450 --> 00:13:30.499
And there's all these layers hidden behind this to the point where we can just literally type

00:13:31.140 --> 00:13:32.880
run this program

00:13:32.880 --> 00:13:39.110
Layers of abstraction are great in computer science because it means that we can think about the program. We want to write hello world

00:13:39.900 --> 00:13:42.290
Rather than having to think about all the nitty-gritty

00:13:43.980 --> 00:13:45.980
Details that we actually to get that implemented

00:13:48.270 --> 00:13:52.490
Now the problem is if I send this off to the website I've just given them my password

00:13:52.490 --> 00:13:53.160
I mean not quite

00:13:53.160 --> 00:13:57.110
Because sha-1 is hash but that could be broken especially if my password is not good

00:13:57.110 --> 00:14:03.439
Right and also he's got a bunch of these passwords and hashes already computed in this database

00:14:03.440 --> 00:14:05.440
So as soon as he sees that I've got the hash

