WEBVTT
Kind: captions
Language: en

00:00:05.694 --> 00:00:07.610
LUKE BAYES: So we're
going to talk about HTML5

00:00:07.610 --> 00:00:11.760
Everywhere, how and why
YouTube uses the web platform.

00:00:11.760 --> 00:00:13.730
First off, this is
Steven Robertson.

00:00:13.730 --> 00:00:17.700
He's an engineer on the player
infrastructure team at YouTube.

00:00:17.700 --> 00:00:21.430
Steven makes sure that videos
playback in the HTML5 web

00:00:21.430 --> 00:00:25.330
platform across desktop,
mobile, and TV devices.

00:00:25.330 --> 00:00:28.160
So he's basically responsible
for video playback library that

00:00:28.160 --> 00:00:31.315
runs on a huge spectrum
of device playbacks.

00:00:31.315 --> 00:00:32.189
My name's Luke Bayes.

00:00:32.189 --> 00:00:35.557
I'm the engineering manager
for the YouTube HTML5 TV team.

00:00:35.557 --> 00:00:37.140
So a lot of what I
talk about is going

00:00:37.140 --> 00:00:39.940
to be really centered around
how we get HTML5 and video

00:00:39.940 --> 00:00:43.050
playbacks on the TV devices.

00:00:43.050 --> 00:00:46.400
Steven is going to talk in a
little bit more general terms.

00:00:46.400 --> 00:00:47.950
So just to kind of
set expectations,

00:00:47.950 --> 00:00:50.110
we're going to talk a little
bit about why the web platform.

00:00:50.110 --> 00:00:51.734
We'll go through some
of the challenges

00:00:51.734 --> 00:00:55.180
that we faced getting there
and then where we're headed.

00:00:55.180 --> 00:00:57.550
So, first off, our
assertion is that YouTube

00:00:57.550 --> 00:01:00.540
should be viewable by
everyone on every screen.

00:01:00.540 --> 00:01:02.240
Now, when we talk
about this, we're

00:01:02.240 --> 00:01:05.319
talking about a huge array
of playback environments,

00:01:05.319 --> 00:01:07.000
and it's not just
us that thinks this.

00:01:07.000 --> 00:01:09.300
It turns out our users are
really excited about getting

00:01:09.300 --> 00:01:11.840
YouTube content no matter
where they happen to be.

00:01:11.840 --> 00:01:15.095
And when we say everyone,
we actually mean everyone.

00:01:15.095 --> 00:01:17.220
So we're actually running
YouTube around the world.

00:01:17.220 --> 00:01:19.136
We're running it on a
huge variety of devices.

00:01:19.136 --> 00:01:22.130
We'll get into some of
those details as we go.

00:01:22.130 --> 00:01:25.039
And as we try to get this
playback environment working,

00:01:25.039 --> 00:01:27.080
one of the things that we
came to a few years ago

00:01:27.080 --> 00:01:29.450
was that we believe,
our assertion is,

00:01:29.450 --> 00:01:32.160
that the web is finally a
viable option for distributing

00:01:32.160 --> 00:01:35.120
immersive experiences
across diverse environments.

00:01:35.120 --> 00:01:38.010
So this wasn't true
even a few years ago.

00:01:38.010 --> 00:01:39.055
It wasn't quite ready.

00:01:39.055 --> 00:01:40.680
And in fact, there
were a lot of things

00:01:40.680 --> 00:01:42.030
that just weren't possible.

00:01:42.030 --> 00:01:44.690
Our assertion today is that
it's actually possible now,

00:01:44.690 --> 00:01:48.030
and even though it is still
a little bit difficult.

00:01:48.030 --> 00:01:50.660
So some of the critiques of
the web platform in general

00:01:50.660 --> 00:01:51.850
is that it's actually
pretty difficult

00:01:51.850 --> 00:01:53.433
to get the kind of
experience you want

00:01:53.433 --> 00:01:55.500
or get the kind of
functionality that you want,

00:01:55.500 --> 00:01:57.125
and the truth is it
is difficult still.

00:01:57.125 --> 00:01:59.380
We do make a huge investment
in getting this platform

00:01:59.380 --> 00:02:00.390
to work well.

00:02:00.390 --> 00:02:02.070
But we believe that
investment is less

00:02:02.070 --> 00:02:04.390
than it would be if we
leaned into native platforms

00:02:04.390 --> 00:02:05.931
across the kind of
devices that we're

00:02:05.931 --> 00:02:08.350
going to talk about today.

00:02:08.350 --> 00:02:08.964
So why?

00:02:08.964 --> 00:02:10.380
Why would we do
such a crazy thing

00:02:10.380 --> 00:02:13.300
as try to get the web platform
to work in these environments?

00:02:13.300 --> 00:02:14.710
So first off, we've got tools.

00:02:14.710 --> 00:02:16.500
So a lot of you
might know there's

00:02:16.500 --> 00:02:18.942
a huge number of great tools
available for developing web

00:02:18.942 --> 00:02:21.400
applications, and those tools
are getting better and better

00:02:21.400 --> 00:02:21.900
every year.

00:02:21.900 --> 00:02:23.635
They're evolving
much more quickly

00:02:23.635 --> 00:02:25.010
than some of the
native platforms

00:02:25.010 --> 00:02:26.969
that we've had to deal
with in some of the TV--

00:02:26.969 --> 00:02:29.218
certainly in the TV environments
where they don't even

00:02:29.218 --> 00:02:30.570
exist and probably never will.

00:02:30.570 --> 00:02:32.028
Now these tools
give us the ability

00:02:32.028 --> 00:02:34.610
to get visibility directly
into our applications runtime

00:02:34.610 --> 00:02:35.440
environment.

00:02:35.440 --> 00:02:36.930
They let us debug
what's going on.

00:02:36.930 --> 00:02:40.130
They let us profile
that functionality,

00:02:40.130 --> 00:02:41.766
let us make it faster.

00:02:41.766 --> 00:02:43.140
Some of these
tools are basically

00:02:43.140 --> 00:02:45.360
the kind of tools you see
in regular web browser

00:02:45.360 --> 00:02:46.450
desktop environments.

00:02:46.450 --> 00:02:47.590
But some of these
tools are also the kind

00:02:47.590 --> 00:02:49.090
of-- what it takes
to edit this code.

00:02:49.090 --> 00:02:50.590
So some of these
native environments

00:02:50.590 --> 00:02:52.950
we've dealt with in
the TV world were

00:02:52.950 --> 00:02:54.860
you had to pull up
somebody's custom IDE.

00:02:54.860 --> 00:02:56.720
You couldn't even use
a regular text editor

00:02:56.720 --> 00:02:57.720
to build an application.

00:02:57.720 --> 00:03:00.030
So these are very
important aspects

00:03:00.030 --> 00:03:02.870
of how we deliver functionality.

00:03:02.870 --> 00:03:04.310
Now for us on the
TV team, we also

00:03:04.310 --> 00:03:05.768
had a huge issue
with coordination.

00:03:05.768 --> 00:03:08.580
So we had to coordinate with
a lot of different device

00:03:08.580 --> 00:03:10.550
partners and a lot
of different browser

00:03:10.550 --> 00:03:12.740
vendors, a lot of different
people around the world.

00:03:12.740 --> 00:03:14.240
And when we were
considering leaning

00:03:14.240 --> 00:03:15.395
into some of the native
applications that

00:03:15.395 --> 00:03:16.811
are available in
that environment,

00:03:16.811 --> 00:03:19.370
the coordination effort
was very difficult,

00:03:19.370 --> 00:03:21.587
especially when we
started considering what

00:03:21.587 --> 00:03:22.920
if we built our own environment?

00:03:22.920 --> 00:03:25.390
What if we built a new platform
that doesn't exist before

00:03:25.390 --> 00:03:28.220
and we tried to deliver
that on these devices?

00:03:28.220 --> 00:03:30.610
Now that coordination would
involve a lot of discussions

00:03:30.610 --> 00:03:31.800
around what surface
does it have?

00:03:31.800 --> 00:03:32.620
What are the APIs?

00:03:32.620 --> 00:03:33.870
What APIs does it need?

00:03:33.870 --> 00:03:35.470
A lot of that
coordination disappeared

00:03:35.470 --> 00:03:36.670
when we moved to the web.

00:03:36.670 --> 00:03:38.750
So we basically said,
here's some standards.

00:03:38.750 --> 00:03:40.089
Implement to those standards.

00:03:40.089 --> 00:03:41.880
Here are some vendors
that actually deliver

00:03:41.880 --> 00:03:43.510
browsers for these
embedded devices.

00:03:43.510 --> 00:03:46.010
You can work with those vendors,
who have a lot of expertise

00:03:46.010 --> 00:03:49.510
in getting this platform to
work with these limited hardware

00:03:49.510 --> 00:03:50.430
constraints.

00:03:50.430 --> 00:03:52.600
And those vendors basically
supported our partners

00:03:52.600 --> 00:03:53.110
in a lot of ways.

00:03:53.110 --> 00:03:54.670
And some of our partners
leaned into the web themselves

00:03:54.670 --> 00:03:57.350
and had engineers on their
teams build web browsers

00:03:57.350 --> 00:03:58.710
that worked on these devices.

00:03:58.710 --> 00:04:00.570
So the web platform
gave us a lot

00:04:00.570 --> 00:04:02.640
of benefits in terms of
the cost of coordination.

00:04:02.640 --> 00:04:04.240
Now, we still invest
pretty heavily there.

00:04:04.240 --> 00:04:06.156
We work really closely
with a lot of partners,

00:04:06.156 --> 00:04:07.000
which I'll get into.

00:04:07.000 --> 00:04:08.920
But that cost is
much less than it

00:04:08.920 --> 00:04:11.128
would have been if we had
something that we invented,

00:04:11.128 --> 00:04:12.350
for example.

00:04:12.350 --> 00:04:14.770
We also get huge benefits for
distribution and deployment.

00:04:14.770 --> 00:04:17.570
So we have millions of devices
around the world running

00:04:17.570 --> 00:04:20.170
these web browsers, which then
runs a single application.

00:04:20.170 --> 00:04:23.172
When we run this application, we
can deploy it every single day.

00:04:23.172 --> 00:04:24.880
We deploy the production
every single day

00:04:24.880 --> 00:04:28.640
for the video player, but
also the TV application.

00:04:28.640 --> 00:04:31.640
And we push it out to devices
without any sort of cost there.

00:04:31.640 --> 00:04:34.770
We don't have to go through
some certification process.

00:04:34.770 --> 00:04:37.080
We don't have to sit down
and say, here's my thing.

00:04:37.080 --> 00:04:38.420
Does it meet these requirements?

00:04:38.420 --> 00:04:39.590
We don't get rejected.

00:04:39.590 --> 00:04:42.210
We simply push our binary to
production and it's out there.

00:04:42.210 --> 00:04:43.450
When we have a bug
we need to fix,

00:04:43.450 --> 00:04:45.420
that needs to be dealt
with right away, we fix it,

00:04:45.420 --> 00:04:45.990
we push it.

00:04:45.990 --> 00:04:48.110
When we have a feature we want
to get out, we implement it,

00:04:48.110 --> 00:04:49.310
we test it, we push it.

00:04:49.310 --> 00:04:51.400
That process is actually
incredibly fast.

00:04:51.400 --> 00:04:53.220
And we're able to
use a lot of tools

00:04:53.220 --> 00:04:55.595
that you get to use when you're
doing regular desktop web

00:04:55.595 --> 00:04:58.090
development like Jasmine
and Karma-- test tools.

00:04:58.090 --> 00:05:01.650
We have thousands of unit
tests that run in 30 seconds.

00:05:01.650 --> 00:05:03.995
So our engineers are able to
be very productive compared

00:05:03.995 --> 00:05:05.870
to some of these other
custom environments we

00:05:05.870 --> 00:05:08.240
were facing on the TV.

00:05:08.240 --> 00:05:10.280
Now all that said,
we think it's great.

00:05:10.280 --> 00:05:11.660
But it's still not--
we still have problems.

00:05:11.660 --> 00:05:12.380
We have challenges.

00:05:12.380 --> 00:05:14.296
So one of the biggest
challenges my team faces

00:05:14.296 --> 00:05:15.290
is in fragmentation.

00:05:15.290 --> 00:05:17.780
So we have a hugely
varied device environment

00:05:17.780 --> 00:05:21.130
that the TV application
needs to run in.

00:05:21.130 --> 00:05:22.620
That involves--
pretty typical what

00:05:22.620 --> 00:05:25.119
you'd expect-- we've got some
basic browser vendors like you

00:05:25.119 --> 00:05:26.710
run with any desktop
web application,

00:05:26.710 --> 00:05:28.459
or mobile web application
for that matter.

00:05:28.459 --> 00:05:32.404
You got the Chrome, the
Opera, Firefox, IE, Safari.

00:05:32.404 --> 00:05:34.820
Now one of the things that
came for us that was surprising

00:05:34.820 --> 00:05:36.460
was that Opera actually
has a huge footprint

00:05:36.460 --> 00:05:38.090
in the embedded
device space, and they

00:05:38.090 --> 00:05:40.423
have a lot of expertise in
getting those devices to work

00:05:40.423 --> 00:05:43.410
well with browser applications.

00:05:43.410 --> 00:05:45.910
So for the TV application we
also had to lean into consoles.

00:05:45.910 --> 00:05:48.490
So this application runs
on pretty much every web

00:05:48.490 --> 00:05:49.240
console out there.

00:05:49.240 --> 00:05:51.226
The ones that are
missing are coming soon.

00:05:51.226 --> 00:05:52.975
We got this application
running on the PS3

00:05:52.975 --> 00:05:55.530
and learned pretty quickly this
isn't like a regular TV input

00:05:55.530 --> 00:05:56.030
device.

00:05:56.030 --> 00:05:58.450
We've got a game controller
that has a lot of other buttons.

00:05:58.450 --> 00:05:59.825
So you get a lot
of functionality

00:05:59.825 --> 00:06:02.854
you can add when you're on the
PS3 with a richer input device.

00:06:02.854 --> 00:06:05.020
Then we go to the Xbox One
and we learn, oh my gosh,

00:06:05.020 --> 00:06:08.000
they've got all these other
input devices like your voice.

00:06:08.000 --> 00:06:09.675
You can gesture around
with the Kinect.

00:06:09.675 --> 00:06:11.300
We had to add support
for those things,

00:06:11.300 --> 00:06:13.390
so we've got another
set of complexity

00:06:13.390 --> 00:06:15.212
there to get that to work well.

00:06:15.212 --> 00:06:17.420
But we were able to build
that on top of the existing

00:06:17.420 --> 00:06:18.230
application foundations.

00:06:18.230 --> 00:06:19.771
So we still have a
single binary that

00:06:19.771 --> 00:06:21.230
goes out to all these devices.

00:06:21.230 --> 00:06:23.930
We have a single team that
implements that functionality.

00:06:23.930 --> 00:06:24.920
Then we got to the
Wii U, and we've

00:06:24.920 --> 00:06:26.336
got this game that
some of you may

00:06:26.336 --> 00:06:28.354
have seen where you
can sort of be watching

00:06:28.354 --> 00:06:29.895
a video on the big
screen, navigating

00:06:29.895 --> 00:06:31.730
the application on the game pad.

00:06:31.730 --> 00:06:33.680
Suddenly we've got the
regular game control,

00:06:33.680 --> 00:06:35.921
but we've also got like
touch inputs and a stylus

00:06:35.921 --> 00:06:37.170
you can touch around on there.

00:06:37.170 --> 00:06:38.830
So we had all these
very interesting input

00:06:38.830 --> 00:06:40.788
devices that were very
challenging for our team

00:06:40.788 --> 00:06:41.300
to support.

00:06:41.300 --> 00:06:42.470
But at the end of
the day, we still

00:06:42.470 --> 00:06:44.540
have the same application
that we can sort of put

00:06:44.540 --> 00:06:47.000
into these other modes depending
on some of these differences.

00:06:47.000 --> 00:06:48.375
And we're able to
lean in to some

00:06:48.375 --> 00:06:50.410
of those differences
across these platforms

00:06:50.410 --> 00:06:52.534
without having to reimplement
an entire application

00:06:52.534 --> 00:06:54.417
and essentially chase
the same functionality

00:06:54.417 --> 00:06:56.750
in this environment and build
all the same functionality

00:06:56.750 --> 00:06:58.260
in this environment and build
all the same functionality

00:06:58.260 --> 00:06:59.093
in that environment.

00:06:59.093 --> 00:07:00.830
We can very easily
add just what we

00:07:00.830 --> 00:07:03.249
needed for these
different environments.

00:07:03.249 --> 00:07:05.040
So this application,
once we got it on some

00:07:05.040 --> 00:07:06.990
consoles we went out and
started talking to other device

00:07:06.990 --> 00:07:09.600
partners, people that make smart
TVs and Blu-ray disc players.

00:07:09.600 --> 00:07:11.016
We've got this
application running

00:07:11.016 --> 00:07:13.240
on pretty much every
Samsung, Sony, Panasonic,

00:07:13.240 --> 00:07:16.750
LG-- pretty much every smart
TV, Blu-ray disc player

00:07:16.750 --> 00:07:18.960
that has application-like
functionality built into it

00:07:18.960 --> 00:07:21.940
or connected devices
that's come out since 2012.

00:07:21.940 --> 00:07:25.160
This was a huge, huge
effort, but again it's

00:07:25.160 --> 00:07:26.415
the same application.

00:07:26.415 --> 00:07:28.540
We then started talking
over to the top box makers,

00:07:28.540 --> 00:07:31.095
like Roku, of course
Chromecast, Boxee and TiVo.

00:07:31.095 --> 00:07:33.470
We've got this application
running in these environments.

00:07:33.470 --> 00:07:36.120
Now some of these have very
different device capabilities,

00:07:36.120 --> 00:07:37.510
but they all have
pretty similar inputs.

00:07:37.510 --> 00:07:39.968
Of course Chromecast accepted,
which is second screen only,

00:07:39.968 --> 00:07:42.659
which is a pretty
amazing experience.

00:07:42.659 --> 00:07:43.950
Then we get into set-top boxes.

00:07:43.950 --> 00:07:47.357
We're also working with
ISPs and cable providers.

00:07:47.357 --> 00:07:49.690
We've got the application
running in these environments.

00:07:49.690 --> 00:07:51.390
Now, some of these devices
that these guys have

00:07:51.390 --> 00:07:52.682
are actually extremely limited.

00:07:52.682 --> 00:07:54.265
They're so limited
that you can't even

00:07:54.265 --> 00:07:55.310
put a browser on them.

00:07:55.310 --> 00:07:56.768
So there are some
providers they've

00:07:56.768 --> 00:07:59.200
been working with that
actually take our application,

00:07:59.200 --> 00:08:02.890
load it up on a web server, and
then stream the user experience

00:08:02.890 --> 00:08:04.837
directly to the cable
box over a video feed.

00:08:04.837 --> 00:08:06.920
And you might have heard
of companies like OnLive.

00:08:06.920 --> 00:08:08.605
We've got a couple
deployments already

00:08:08.605 --> 00:08:09.980
where people are
using technology

00:08:09.980 --> 00:08:12.550
like that to get this web
based application working

00:08:12.550 --> 00:08:15.101
in an extremely limited
hardware environment.

00:08:15.101 --> 00:08:17.100
Once we started working
with all these partners,

00:08:17.100 --> 00:08:18.766
we learned, well, a
lot of them actually

00:08:18.766 --> 00:08:20.064
have the same SOC manufacturer.

00:08:20.064 --> 00:08:22.480
They actually get the same
software and chip module makers

00:08:22.480 --> 00:08:24.271
that basically deploy
into the fundamentals

00:08:24.271 --> 00:08:26.940
of their device environments.

00:08:26.940 --> 00:08:30.050
So we started working
with those manufacturers

00:08:30.050 --> 00:08:33.502
around the world to get
different device media codecs

00:08:33.502 --> 00:08:35.960
implemented so we could get
hardware decoding for the codes

00:08:35.960 --> 00:08:37.960
that we care about, we could
get some of the performance

00:08:37.960 --> 00:08:38.927
improvements we need.

00:08:38.927 --> 00:08:41.010
We've been working very
closely with those people.

00:08:41.010 --> 00:08:42.610
And as we've gotten
through this,

00:08:42.610 --> 00:08:44.770
we now have an
ecosystem that spreads

00:08:44.770 --> 00:08:47.690
across literally thousands
of very distinct device

00:08:47.690 --> 00:08:49.550
models, hundreds of
brands, and we've

00:08:49.550 --> 00:08:52.780
got the same application
running on all of these devices

00:08:52.780 --> 00:08:54.420
in an ecosystem
that used to be--

00:08:54.420 --> 00:08:57.300
even just a few years
ago-- extremely fragmented,

00:08:57.300 --> 00:08:59.910
where you would have to build
tens of different applications

00:08:59.910 --> 00:09:02.864
in order to get something
working in this environment.

00:09:02.864 --> 00:09:04.780
So I'm going to talk a
little bit about this--

00:09:04.780 --> 00:09:06.696
I've been talking a
little bit about this sort

00:09:06.696 --> 00:09:07.970
of fragmentation.

00:09:07.970 --> 00:09:10.650
But when I talk about getting an
immersive user experience, what

00:09:10.650 --> 00:09:12.150
I really want to
show you is-- we're

00:09:12.150 --> 00:09:14.450
not talking about just getting
something that works at all.

00:09:14.450 --> 00:09:16.366
We're talking about
something that works well.

00:09:16.366 --> 00:09:18.750
And I'm going to show
you a little bit what's

00:09:18.750 --> 00:09:21.070
coming in the TV
experience here.

00:09:21.070 --> 00:09:23.780
So we've been working hard to
get a new user experience that

00:09:23.780 --> 00:09:25.876
provides all of YouTube's
content on the TV.

00:09:25.876 --> 00:09:27.750
And it gives you the
information architecture

00:09:27.750 --> 00:09:29.124
that you may have
become familiar

00:09:29.124 --> 00:09:31.760
with as you use YouTube,
but from your TV device.

00:09:31.760 --> 00:09:34.737
This was extremely challenging
to get working at all.

00:09:34.737 --> 00:09:37.320
And we've actually leaned into
getting it working really well.

00:09:37.320 --> 00:09:38.986
So when I say immersive
user experience,

00:09:38.986 --> 00:09:41.830
I'm talking about sort of a
rich, native-like application

00:09:41.830 --> 00:09:44.970
functionality that's
smooth and loads well,

00:09:44.970 --> 00:09:47.440
and basically lets you
move around and get at all

00:09:47.440 --> 00:09:49.060
the content you're
familiar with.

00:09:49.060 --> 00:09:51.620
We've even got like
little parallax tricks.

00:09:51.620 --> 00:09:53.577
So we've got a nice,
clean environment.

00:09:53.577 --> 00:09:54.660
You can get at your guide.

00:09:54.660 --> 00:09:56.130
You can get at
your subscriptions.

00:09:56.130 --> 00:09:57.960
And you can actually
navigate all of the content.

00:09:57.960 --> 00:09:59.620
So this is coming
out to these devices.

00:09:59.620 --> 00:10:02.160
Over the next few months we're
going to be rolling this out.

00:10:02.160 --> 00:10:04.701
And this is what I mean when I
say immersive user experience.

00:10:07.650 --> 00:10:10.850
All right, see if that comes up.

00:10:10.850 --> 00:10:12.517
So, now to get an
experience like that,

00:10:12.517 --> 00:10:14.100
it took a lot of
focus on performance.

00:10:14.100 --> 00:10:16.580
So we had to really dig
into performance here.

00:10:16.580 --> 00:10:18.110
And when we did that there's
a lot of different ways

00:10:18.110 --> 00:10:19.943
you can measure performance
and, as Googlers

00:10:19.943 --> 00:10:21.902
we kind of look into--
we want to have metrics.

00:10:21.902 --> 00:10:22.984
We want to look at charts.

00:10:22.984 --> 00:10:24.960
We want to see all these
charts and everything.

00:10:24.960 --> 00:10:27.418
And some aspects of performance
are really easy to measure.

00:10:27.418 --> 00:10:29.410
So we talk about here,
this is our start time.

00:10:29.410 --> 00:10:30.868
This is our
application start time,

00:10:30.868 --> 00:10:33.096
sometime around
December of last year

00:10:33.096 --> 00:10:35.470
when we really leaned into--
we had a lot of the features

00:10:35.470 --> 00:10:36.610
we needed to get
working, and we really

00:10:36.610 --> 00:10:37.943
wanted to lean into performance.

00:10:37.943 --> 00:10:39.620
How do we optimize
this application?

00:10:39.620 --> 00:10:41.270
So we instrumented
the application.

00:10:41.270 --> 00:10:43.794
We started getting charts
coming out every day.

00:10:43.794 --> 00:10:46.210
This chart here basically has
a yellow line at the bottom.

00:10:46.210 --> 00:10:48.040
That's how long it
took for our JavaScript

00:10:48.040 --> 00:10:49.417
to download and
become available.

00:10:49.417 --> 00:10:51.750
The top line is as soon as
our application interface was

00:10:51.750 --> 00:10:53.860
available so a user could
click around the UI.

00:10:53.860 --> 00:10:55.675
In the middle are
various checkpoints

00:10:55.675 --> 00:10:56.936
that we instrumented.

00:10:56.936 --> 00:10:58.060
They're not that important.

00:10:58.060 --> 00:11:00.480
But what is important is that
essentially once we looked

00:11:00.480 --> 00:11:02.647
into this we saw some
opportunities for improvement,

00:11:02.647 --> 00:11:04.271
we implemented them,
and we pushed them

00:11:04.271 --> 00:11:05.780
to every single
device that we had.

00:11:05.780 --> 00:11:08.320
We didn't have to have
independent teams basically

00:11:08.320 --> 00:11:11.254
working on this performance
story and getting there.

00:11:11.254 --> 00:11:12.920
Now there's other
aspects of performance

00:11:12.920 --> 00:11:14.750
that actually aren't
very easy to measure.

00:11:14.750 --> 00:11:16.560
And one feature in
what I just showed

00:11:16.560 --> 00:11:19.060
you is as you move right to
left there's an animation there.

00:11:19.060 --> 00:11:20.620
That animation takes some time.

00:11:20.620 --> 00:11:23.250
So there's a temptation even
with some people in our area

00:11:23.250 --> 00:11:25.470
that want to say, hey, I
want to see measurements

00:11:25.470 --> 00:11:26.800
for your animated performance.

00:11:26.800 --> 00:11:29.059
Well, the animation
takes 100 milliseconds

00:11:29.059 --> 00:11:30.850
whether you want to
make it-- if we make it

00:11:30.850 --> 00:11:33.130
faster than 100 milliseconds,
it doesn't exist.

00:11:33.130 --> 00:11:35.492
So some of these things are
a little more qualitative,

00:11:35.492 --> 00:11:36.950
a little more
subjective, and we've

00:11:36.950 --> 00:11:38.930
got-- what that means
is that our team has

00:11:38.930 --> 00:11:43.607
to sort of own that experience,
a little more the beauty

00:11:43.607 --> 00:11:46.190
of that experience as opposed
to just sort of implementing it.

00:11:46.190 --> 00:11:47.610
And this is kind of
a different skill

00:11:47.610 --> 00:11:48.901
set from your typical engineer.

00:11:48.901 --> 00:11:51.190
So we work very closely
with UX and Design to get

00:11:51.190 --> 00:11:53.294
that experience to work well.

00:11:53.294 --> 00:11:55.460
Now of course we've got the
quantitative performance

00:11:55.460 --> 00:11:55.760
metrics.

00:11:55.760 --> 00:11:56.580
Then we've got qualitative.

00:11:56.580 --> 00:11:58.220
But then we've just
got the raw memory.

00:11:58.220 --> 00:12:00.110
So when we get into
these TV devices,

00:12:00.110 --> 00:12:03.590
we've got very, very limited
memory, very strong network

00:12:03.590 --> 00:12:06.537
conditions, and
very limited CPU.

00:12:06.537 --> 00:12:08.370
Now this is a very
different device profiles

00:12:08.370 --> 00:12:10.840
than what you might find on
a desktop or laptop computer,

00:12:10.840 --> 00:12:12.290
and even on mobile
devices today.

00:12:12.290 --> 00:12:14.415
Most mobile devices now
have quite a lot of memory,

00:12:14.415 --> 00:12:16.300
twice what most TVs
have, and they also

00:12:16.300 --> 00:12:18.975
have-- their constraints are
much more in the network layer.

00:12:18.975 --> 00:12:20.600
So you'll make very
different tradeoffs

00:12:20.600 --> 00:12:22.360
depending on what platform
you're working at.

00:12:22.360 --> 00:12:24.735
But it's nice to be able to
build an application that you

00:12:24.735 --> 00:12:26.490
can move into those
environments and then

00:12:26.490 --> 00:12:28.780
optimize on the differences.

00:12:28.780 --> 00:12:30.360
So for us, memory
was a big problem.

00:12:30.360 --> 00:12:31.818
We have the typical
memory problems

00:12:31.818 --> 00:12:33.972
like any web application--
JavaScript, entities.

00:12:33.972 --> 00:12:36.430
You substantiate a few thousand
objects, you got a problem.

00:12:36.430 --> 00:12:38.610
You substantiate a bunch of DOM
elements, you got a problem.

00:12:38.610 --> 00:12:39.880
The thing that
surprised us most was

00:12:39.880 --> 00:12:42.254
what we found when we got into
the graphics and rendering

00:12:42.254 --> 00:12:43.610
layer of these browsers.

00:12:43.610 --> 00:12:45.820
So we started out by
getting into the PS3.

00:12:45.820 --> 00:12:48.850
And we were crashing
basically every 15 minutes

00:12:48.850 --> 00:12:51.660
or so when we first
built the application.

00:12:51.660 --> 00:12:53.577
And we had to sort of learn why.

00:12:53.577 --> 00:12:54.410
Why are we crashing?

00:12:54.410 --> 00:12:56.830
Well, we figured out there
was some rendering problem.

00:12:56.830 --> 00:12:58.580
We were working with
our browser team that

00:12:58.580 --> 00:13:00.950
also was porting
Chromium to that device.

00:13:00.950 --> 00:13:02.180
And they started talking
about, hey, your rendering

00:13:02.180 --> 00:13:02.830
is taking a long time.

00:13:02.830 --> 00:13:03.900
Your rendering is
causing problems.

00:13:03.900 --> 00:13:04.790
It's fragmenting memory.

00:13:04.790 --> 00:13:06.270
So we had to say
what's a render layer?

00:13:06.270 --> 00:13:07.700
Well, a rendering
layer is a bitmap

00:13:07.700 --> 00:13:10.074
that the browser creates when
compositing visual elements

00:13:10.074 --> 00:13:11.770
for display on the screen.

00:13:11.770 --> 00:13:16.610
Now, each render layer costs
you width times height times 4.

00:13:16.610 --> 00:13:18.890
So this is-- you can think
of a browser window, right?

00:13:18.890 --> 00:13:20.390
You've got the width
of the browser,

00:13:20.390 --> 00:13:21.130
the height of the browser.

00:13:21.130 --> 00:13:22.170
You multiply it times 4.

00:13:22.170 --> 00:13:23.050
Well, why 4?

00:13:23.050 --> 00:13:24.930
Well, OK, you've got the red
channel, the green channel,

00:13:24.930 --> 00:13:26.650
the blue channel, and
then the alpha channel.

00:13:26.650 --> 00:13:28.858
So basically when the browser
takes your application,

00:13:28.858 --> 00:13:30.244
it loads the full
screen, creates

00:13:30.244 --> 00:13:31.660
a render layer of
the full screen.

00:13:31.660 --> 00:13:33.560
Then it breaks up
your DOM elements.

00:13:33.560 --> 00:13:35.269
And at many of those
points in your tree,

00:13:35.269 --> 00:13:37.018
it'll actually create
another render layer

00:13:37.018 --> 00:13:39.170
that's the size of that
element and its children.

00:13:39.170 --> 00:13:40.878
So in our case, when
you saw those tiles,

00:13:40.878 --> 00:13:43.257
we get a different render
layer for each of those tiles.

00:13:43.257 --> 00:13:44.840
Now as the browser
renders every frame

00:13:44.840 --> 00:13:47.298
it's splitting up all of those
entities into render layers,

00:13:47.298 --> 00:13:49.500
creating bitmaps, and then
compositing them together

00:13:49.500 --> 00:13:51.751
into a single bitmap.

00:13:51.751 --> 00:13:53.250
So when we got to
PS3-- this is just

00:13:53.250 --> 00:13:55.510
an example of what our
application looks like.

00:13:55.510 --> 00:13:56.968
And this is what
I'm talking about.

00:13:56.968 --> 00:13:59.550
Each of these rectangles is
essentially a render layer.

00:13:59.550 --> 00:14:01.300
We got to the PS3
our graphics memory

00:14:01.300 --> 00:14:02.680
was looking a lot like this.

00:14:02.680 --> 00:14:04.730
So as we go over
time, our memory

00:14:04.730 --> 00:14:07.600
was essentially getting
allocated and then freed

00:14:07.600 --> 00:14:10.110
and then allocated and freed,
and, allocated and freed.

00:14:10.110 --> 00:14:12.237
And even though we actually
had enough free memory

00:14:12.237 --> 00:14:14.320
to do what we needed to
do, we were fragmenting it

00:14:14.320 --> 00:14:15.470
with this process.

00:14:15.470 --> 00:14:17.874
And that's what was
causing the crash.

00:14:17.874 --> 00:14:19.540
We couldn't get enough
contiguous memory

00:14:19.540 --> 00:14:21.039
to allocate what
we needed to render

00:14:21.039 --> 00:14:24.300
another frame after about
10 minutes of moving around.

00:14:24.300 --> 00:14:24.910
So we dug in.

00:14:24.910 --> 00:14:26.410
Well, what does
make a render layer?

00:14:26.410 --> 00:14:27.642
How do we control this thing?

00:14:27.642 --> 00:14:29.100
Is there any way
we can control it?

00:14:29.100 --> 00:14:31.197
We found that there's
a few CSS styles

00:14:31.197 --> 00:14:33.280
that you apply to elements
that causes the browser

00:14:33.280 --> 00:14:34.530
to generate a render layer.

00:14:34.530 --> 00:14:35.930
Of course, we get
the root layer.

00:14:35.930 --> 00:14:38.138
But also, if you set absolute
or relative positioning

00:14:38.138 --> 00:14:40.960
in any element, CSS
opacity and transforms

00:14:40.960 --> 00:14:42.440
force a render layer.

00:14:42.440 --> 00:14:45.150
Now, once we dug into that,
we realized we could actually

00:14:45.150 --> 00:14:48.430
sit down and force render layers
to stop compositing and stay

00:14:48.430 --> 00:14:51.997
resident in memory over time by
using hacks that were publicly

00:14:51.997 --> 00:14:54.080
available at the time and
are no longer good to do

00:14:54.080 --> 00:14:57.105
on desktop environments but were
great in the TV environment.

00:14:57.105 --> 00:14:59.210
And for example, I'm
talking about translateZ.

00:14:59.210 --> 00:15:01.699
So we told the browser,
hey, put this element

00:15:01.699 --> 00:15:03.990
and its children into a single
bitmap and keep it there

00:15:03.990 --> 00:15:06.050
and don't free it
on every frame.

00:15:06.050 --> 00:15:08.700
Once we did that,
our PS3 usage--

00:15:08.700 --> 00:15:10.820
our memory usage on
rendering looked a lot more

00:15:10.820 --> 00:15:11.910
like this red line.

00:15:11.910 --> 00:15:13.170
It became a lot more stable.

00:15:13.170 --> 00:15:16.400
And our application runtimes
grew beyond six hours.

00:15:16.400 --> 00:15:18.050
So this was a huge
difference for us,

00:15:18.050 --> 00:15:20.960
just learning how CSS works
in these browser environments

00:15:20.960 --> 00:15:24.039
and getting that
performance under control.

00:15:24.039 --> 00:15:26.580
Now, Steven's going to come up
here and talk to you about how

00:15:26.580 --> 00:15:29.878
we got video playback to work.

00:15:29.878 --> 00:15:31.690
STEVEN ROBERTSON: Thanks, Luke.

00:15:31.690 --> 00:15:33.680
So on the player
infrastructure team,

00:15:33.680 --> 00:15:35.340
our goal is to
deliver you video that

00:15:35.340 --> 00:15:38.740
starts fast, looks great,
and never rebuffers.

00:15:38.740 --> 00:15:40.870
We're not there yet.

00:15:40.870 --> 00:15:44.002
So if you typed in "why is"
into Google not too long ago,

00:15:44.002 --> 00:15:46.210
you'd actually see one of
the top results come up is,

00:15:46.210 --> 00:15:49.860
"Why is YouTube so slow?"

00:15:49.860 --> 00:15:52.860
This is a serious problem for
our creators and our viewers,

00:15:52.860 --> 00:15:54.530
and we're committed
to solving it.

00:15:54.530 --> 00:15:57.494
One of our best tools for
doing so is adaptive streaming.

00:15:57.494 --> 00:15:59.160
With adaptive streaming,
we take a video

00:15:59.160 --> 00:16:01.180
and split it into chunks.

00:16:01.180 --> 00:16:03.710
And by making requests for
those chunks independently,

00:16:03.710 --> 00:16:05.980
we get a lot more
flexibility over how

00:16:05.980 --> 00:16:09.360
we deal with changing or
just bad network conditions.

00:16:09.360 --> 00:16:12.850
Now, that flexibility
isn't unlimited.

00:16:12.850 --> 00:16:14.930
The media pipelines
are, well, pipelined.

00:16:14.930 --> 00:16:19.080
So as you introduce
media data, it sort of

00:16:19.080 --> 00:16:20.770
locks you in for a few seconds.

00:16:20.770 --> 00:16:23.382
And any time you make a
decision about what to do,

00:16:23.382 --> 00:16:24.840
that decision is
going to constrain

00:16:24.840 --> 00:16:26.549
your options for the
next few seconds.

00:16:26.549 --> 00:16:28.090
So you have to make
the right choice,

00:16:28.090 --> 00:16:30.060
otherwise we might
show a buffer spinner

00:16:30.060 --> 00:16:33.874
or we'll show video quality
that's unnecessarily too low.

00:16:33.874 --> 00:16:35.290
That means that
every time we make

00:16:35.290 --> 00:16:37.041
an ABR choice we're
predicting the future,

00:16:37.041 --> 00:16:38.540
figuring out what's
going to happen.

00:16:38.540 --> 00:16:39.670
And that's always hard.

00:16:39.670 --> 00:16:42.740
Which is why we spend so
much time tuning the crap out

00:16:42.740 --> 00:16:45.340
of this algorithm.

00:16:45.340 --> 00:16:47.910
So we use-- the primary
method for doing

00:16:47.910 --> 00:16:50.550
so is an AB test framemark
that lets us run experiments

00:16:50.550 --> 00:16:52.400
on real user metrics.

00:16:52.400 --> 00:16:55.890
And we're testing not just
for quantitative performance,

00:16:55.890 --> 00:17:00.590
such as whether or not the user
saw a buffer spinner, but also

00:17:00.590 --> 00:17:02.510
qualitative such as watch time.

00:17:02.510 --> 00:17:06.150
And the web platform has
been fantastic for that.

00:17:06.150 --> 00:17:10.069
We've seen that by being able to
push code changes to production

00:17:10.069 --> 00:17:12.750
so quickly, we iterate
on experiments.

00:17:12.750 --> 00:17:16.329
In fact, my personal average
is about two new experiments

00:17:16.329 --> 00:17:18.050
launched per week.

00:17:18.050 --> 00:17:22.510
And you couldn't have that sort
of serialized dependency of we

00:17:22.510 --> 00:17:25.829
learned something, we move on,
and create a new experiment

00:17:25.829 --> 00:17:29.440
that applies that learning on a
platform that had a longer lead

00:17:29.440 --> 00:17:30.160
time.

00:17:30.160 --> 00:17:32.580
So this has been
tremendously advantageous.

00:17:32.580 --> 00:17:35.680
But, as Luke mentioned,
we have a player binary

00:17:35.680 --> 00:17:39.730
that runs on multiple
device platforms,

00:17:39.730 --> 00:17:42.130
but they're all built
on the web platform.

00:17:42.130 --> 00:17:44.430
And this has really
had an unexpected level

00:17:44.430 --> 00:17:47.710
of benefit in terms of
being able to deploy

00:17:47.710 --> 00:17:51.280
the same code across multiple
platforms at the same time.

00:17:51.280 --> 00:17:53.480
So I'll give you some examples.

00:17:53.480 --> 00:17:54.570
We had a device.

00:17:54.570 --> 00:17:57.670
It was one of the TV
HTML5 style devices.

00:17:57.670 --> 00:18:00.570
And this device would
buffer, for no reason

00:18:00.570 --> 00:18:02.250
that we could tell initially.

00:18:02.250 --> 00:18:03.660
It'd be on a great network.

00:18:03.660 --> 00:18:06.090
If you were streaming
video from another computer

00:18:06.090 --> 00:18:07.900
or mobile device,
that would work fine.

00:18:07.900 --> 00:18:10.624
But on this device, the video
would enter a buffering state

00:18:10.624 --> 00:18:11.790
and it would never leave it.

00:18:11.790 --> 00:18:12.890
You'd just have the
spinner up there

00:18:12.890 --> 00:18:14.098
for the rest of your session.

00:18:14.098 --> 00:18:16.540
If you'd seek, it'd
sort of snap out of it,

00:18:16.540 --> 00:18:17.570
but we didn't want that.

00:18:17.570 --> 00:18:20.690
We wanted users to just have
an uninterrupted experience.

00:18:20.690 --> 00:18:23.370
And so, we knew that
this was happening

00:18:23.370 --> 00:18:25.880
because we have
instrumentation in the player.

00:18:25.880 --> 00:18:28.280
We have quality of
experience metrics

00:18:28.280 --> 00:18:30.440
that show us what
the player is doing

00:18:30.440 --> 00:18:31.942
from a client-side perspective.

00:18:31.942 --> 00:18:34.400
And then we join that with what
we know our video streaming

00:18:34.400 --> 00:18:36.800
servers are doing, so that
we can get a perspective.

00:18:36.800 --> 00:18:39.960
And with this device, we saw
that the streaming servers'

00:18:39.960 --> 00:18:42.639
view of the connection
was all great.

00:18:42.639 --> 00:18:45.180
People had a strong connection
to YouTube, so it wasn't that,

00:18:45.180 --> 00:18:48.080
but the client was still
encountering those rebuffers.

00:18:48.080 --> 00:18:49.550
So we needed more detail.

00:18:49.550 --> 00:18:52.490
We built a solution
using standard XML

00:18:52.490 --> 00:18:55.630
HTTP progress events
that allows us

00:18:55.630 --> 00:18:57.160
to get more insight
into requests.

00:18:57.160 --> 00:18:58.410
So this is what you're seeing.

00:18:58.410 --> 00:19:00.370
The horizontal
axis here is time.

00:19:00.370 --> 00:19:02.590
The vertical is data
rate, which is basically

00:19:02.590 --> 00:19:04.075
the user's bandwidth.

00:19:04.075 --> 00:19:06.200
And this is a single request
that we're looking at.

00:19:06.200 --> 00:19:08.650
And we can see that the
request starts great,

00:19:08.650 --> 00:19:12.220
and then for some
reason it just cuts off

00:19:12.220 --> 00:19:14.380
to this extremely low
bandwidth condition.

00:19:14.380 --> 00:19:16.190
But critically, it's
not zero bandwidth.

00:19:16.190 --> 00:19:18.424
There was still a packet
coming in every few seconds.

00:19:18.424 --> 00:19:20.590
And that meant our time-out
logic wasn't triggering,

00:19:20.590 --> 00:19:22.380
because the number
of bytes was still

00:19:22.380 --> 00:19:25.060
going up within
the time-out time.

00:19:25.060 --> 00:19:28.720
And so once we identified
that this was happening

00:19:28.720 --> 00:19:31.070
in correlation with
those infinite rebuffers,

00:19:31.070 --> 00:19:33.390
we started digging deeper
at the level of TCP.

00:19:33.390 --> 00:19:35.420
And we found that
what was happening

00:19:35.420 --> 00:19:36.884
was this device
had a flaky radio.

00:19:36.884 --> 00:19:38.800
It would disconnect for
a fraction of a second

00:19:38.800 --> 00:19:41.960
and come back, but when it did,
all of the packets on the wire

00:19:41.960 --> 00:19:42.970
already were dropped.

00:19:42.970 --> 00:19:44.470
And so you'd end
up with hundreds of

00:19:44.470 --> 00:19:47.550
dropped packets and selective
acknowledgements going back

00:19:47.550 --> 00:19:48.780
to the server for that.

00:19:48.780 --> 00:19:50.600
This would put TCP
in a weird state

00:19:50.600 --> 00:19:53.050
where the congestion window
would clamp down and not

00:19:53.050 --> 00:19:53.631
reopen.

00:19:53.631 --> 00:19:55.505
It would take a long
time for that to happen.

00:19:55.505 --> 00:19:57.840
And so that's what was
causing these events.

00:19:57.840 --> 00:20:00.540
Once we knew that, we were
able to go back to the player,

00:20:00.540 --> 00:20:03.220
use the same standard
browser technology

00:20:03.220 --> 00:20:04.756
to detect this condition.

00:20:04.756 --> 00:20:06.130
It's a little
finicky because you

00:20:06.130 --> 00:20:08.260
needed to work around
situations that

00:20:08.260 --> 00:20:10.190
were real bandwidth changes.

00:20:10.190 --> 00:20:12.770
But we had a solution
in place that

00:20:12.770 --> 00:20:15.320
was able to detect this and
then simply cancel the request

00:20:15.320 --> 00:20:17.150
and start a new one.

00:20:17.150 --> 00:20:18.640
And the new request
would of course

00:20:18.640 --> 00:20:20.820
work great, because it
was a new TCP session.

00:20:20.820 --> 00:20:23.750
So this saved the device.

00:20:23.750 --> 00:20:26.770
Its own performance went
from basically unusable

00:20:26.770 --> 00:20:29.090
to very substantially good.

00:20:29.090 --> 00:20:30.690
On TV as a whole,
this experiment

00:20:30.690 --> 00:20:35.390
led to a 60% less time
spent rebuffering.

00:20:35.390 --> 00:20:38.160
But what surprised us was that
when we ran this experiment

00:20:38.160 --> 00:20:40.180
we ran it across all
platforms simultaneously,

00:20:40.180 --> 00:20:43.680
because it's essentially free
to do so using the web platform.

00:20:43.680 --> 00:20:45.190
And we found out
that it was also

00:20:45.190 --> 00:20:47.120
improving the
experience on desktops.

00:20:47.120 --> 00:20:48.800
We didn't even know
we had this problem.

00:20:48.800 --> 00:20:50.440
And the reason why
was we introduced

00:20:50.440 --> 00:20:52.660
all of our instrumentation
about the player

00:20:52.660 --> 00:20:55.940
well after this problem
started appearing on desktops.

00:20:55.940 --> 00:20:59.060
And on desktops, users have
learned that if they seek,

00:20:59.060 --> 00:21:00.510
the request will be canceled.

00:21:00.510 --> 00:21:01.924
And they'll start a new one.

00:21:01.924 --> 00:21:04.090
So they were essentially
emulating the same behavior

00:21:04.090 --> 00:21:05.780
that we are able to
add to our player.

00:21:05.780 --> 00:21:06.920
But they had to
do that manually,

00:21:06.920 --> 00:21:08.520
which meant it interrupted
the experience.

00:21:08.520 --> 00:21:10.080
Some users didn't
figure this out.

00:21:10.080 --> 00:21:11.050
It was bad all around.

00:21:11.050 --> 00:21:14.110
So having this single view
where we can take our learning

00:21:14.110 --> 00:21:16.230
and apply it seamlessly
across devices

00:21:16.230 --> 00:21:19.710
can allow us to understand
much more about the player

00:21:19.710 --> 00:21:21.310
as it reacts in
different environments

00:21:21.310 --> 00:21:22.790
to different stimuli.

00:21:22.790 --> 00:21:25.660
And so we can have this
learning on all of our platforms

00:21:25.660 --> 00:21:26.285
simultaneously.

00:21:28.990 --> 00:21:30.866
Now, there's another
sort of learning

00:21:30.866 --> 00:21:32.740
that you can get from
multi-platform devices,

00:21:32.740 --> 00:21:34.790
and this is a case
of divergence.

00:21:34.790 --> 00:21:37.520
So we have an input
bandwidth signal.

00:21:37.520 --> 00:21:39.360
And again, this
is the same style

00:21:39.360 --> 00:21:42.070
of graph captured from clients.

00:21:42.070 --> 00:21:44.530
Horizontal axis is time,
vertical axis is data rate.

00:21:44.530 --> 00:21:47.560
We're going to talk about
the two signals separately.

00:21:47.560 --> 00:21:50.260
And if you think you've
seen a lot of graphs today,

00:21:50.260 --> 00:21:51.770
you're not wrong.

00:21:51.770 --> 00:21:55.480
So these are the two signals.

00:21:55.480 --> 00:21:57.330
The first one is
exemplary of a condition

00:21:57.330 --> 00:22:01.390
that you might find
on a laptop computer.

00:22:01.390 --> 00:22:03.229
Most of our desktop
site usage is actually

00:22:03.229 --> 00:22:04.520
coming from laptops these days.

00:22:04.520 --> 00:22:05.800
And of course, you
can take that laptop

00:22:05.800 --> 00:22:06.967
and move it to another room.

00:22:06.967 --> 00:22:08.466
If you do that, you
might experience

00:22:08.466 --> 00:22:10.160
a change in your
Wi-Fi signal strength,

00:22:10.160 --> 00:22:11.740
corresponding
change in bandwidth.

00:22:11.740 --> 00:22:15.662
We want a bandwidth filter to
respond quickly to that change,

00:22:15.662 --> 00:22:17.120
and so that's why
on desktop we use

00:22:17.120 --> 00:22:19.380
a multi-tap rolling
percentile filter.

00:22:19.380 --> 00:22:22.610
Basically this means we look at
the past few seconds of data.

00:22:22.610 --> 00:22:25.900
We evaluate what the 40th,
50th, 60th percentiles are.

00:22:25.900 --> 00:22:29.640
We use that composite metric
to make our ABR decisions on.

00:22:29.640 --> 00:22:30.640
And you can see it does.

00:22:30.640 --> 00:22:33.210
It tracks this with
a very short lag.

00:22:33.210 --> 00:22:35.620
It tracks this input signal
and essentially rejects

00:22:35.620 --> 00:22:36.840
all of its old history.

00:22:36.840 --> 00:22:39.140
Now, on TV we do
something different.

00:22:39.140 --> 00:22:42.109
On TV the experience
is different.

00:22:42.109 --> 00:22:44.150
The devices don't have
the memory to buffer head,

00:22:44.150 --> 00:22:47.510
so we can't offer
a forced HD button.

00:22:47.510 --> 00:22:51.260
And we find that users on
TV desire HD a lot more.

00:22:51.260 --> 00:22:53.540
So even though it's not
quite as responsive,

00:22:53.540 --> 00:22:56.900
we use an exponentially
weighted moving average on TV.

00:22:56.900 --> 00:22:58.670
And we discovered
this-- we didn't

00:22:58.670 --> 00:23:00.610
know that this solution
was going to work.

00:23:00.610 --> 00:23:02.470
We were actually just
trying things out

00:23:02.470 --> 00:23:04.240
across all of our
platforms at once.

00:23:04.240 --> 00:23:06.040
We found that one
filter worked better

00:23:06.040 --> 00:23:10.640
on one platform and another on a
different set of circumstances,

00:23:10.640 --> 00:23:11.890
for a lot of reasons.

00:23:11.890 --> 00:23:13.840
But these are some of them.

00:23:13.840 --> 00:23:15.640
And that's critical,
because we didn't

00:23:15.640 --> 00:23:17.860
expect there to be
these differences.

00:23:17.860 --> 00:23:22.700
We sort of found out that once
we had arrived at this test

00:23:22.700 --> 00:23:25.000
configuration, we saw
these different responses

00:23:25.000 --> 00:23:26.400
on different devices.

00:23:26.400 --> 00:23:29.670
And we were able to
take advantage of that.

00:23:29.670 --> 00:23:31.410
One more example signal.

00:23:31.410 --> 00:23:33.690
This is a very spiky signal.

00:23:33.690 --> 00:23:34.752
A lot of outliers here.

00:23:34.752 --> 00:23:36.460
If you're seeing this
on a desktop device

00:23:36.460 --> 00:23:40.120
you might be surprised,
because in most circumstances

00:23:40.120 --> 00:23:43.010
there are glitches like that,
but they're not so regular.

00:23:43.010 --> 00:23:45.230
Those are sort of aberrations.

00:23:45.230 --> 00:23:48.070
And the sliding percentile
window used on desktop

00:23:48.070 --> 00:23:50.040
does a great job of
rejecting those signals.

00:23:50.040 --> 00:23:52.660
On TV, we actually want to
incorporate those signals

00:23:52.660 --> 00:23:55.835
because it turns out that that's
how those devices communicate.

00:23:55.835 --> 00:23:59.400
Their radios tends to lock
on and transmit in bursts

00:23:59.400 --> 00:24:00.240
more often.

00:24:00.240 --> 00:24:02.950
And so it's appropriate for that
weighted average to do this.

00:24:02.950 --> 00:24:06.140
And again, we would not have
discovered these differences

00:24:06.140 --> 00:24:09.270
if we didn't have
the platform that

00:24:09.270 --> 00:24:12.810
allowed us to run all of those
experiments on every platform

00:24:12.810 --> 00:24:14.060
simultaneously.

00:24:14.060 --> 00:24:15.870
We didn't anticipate
this being a need,

00:24:15.870 --> 00:24:18.410
but by having all of that
information available,

00:24:18.410 --> 00:24:20.670
we were able to really
lean in on the differences

00:24:20.670 --> 00:24:23.930
in the platform and do
comparative analyses

00:24:23.930 --> 00:24:26.780
all at the same time with
essentially no overhead

00:24:26.780 --> 00:24:28.660
in terms of our experimentation.

00:24:28.660 --> 00:24:31.400
So all of that has been
fantastic for optimizing

00:24:31.400 --> 00:24:37.040
our delivery of adaptive
video on multiple devices.

00:24:37.040 --> 00:24:42.100
And for a sort of view on
how well we're doing in this,

00:24:42.100 --> 00:24:45.457
this is people searching for
"YouTube PS3 slow" over time.

00:24:45.457 --> 00:24:47.040
That point right
there, where it drops

00:24:47.040 --> 00:24:49.370
to essentially zero,
that's when we introduced

00:24:49.370 --> 00:24:51.200
adaptive streaming on the PS3.

00:24:51.200 --> 00:24:52.920
So we are making progress.

00:24:52.920 --> 00:24:54.630
We're hardly done yet.

00:24:54.630 --> 00:24:57.790
We've got a lot more way to go,
but this-- the web technology

00:24:57.790 --> 00:25:01.030
has allowed us to
iterate extremely quickly

00:25:01.030 --> 00:25:04.830
and build a solution
that's great for users.

00:25:04.830 --> 00:25:07.050
Now, we're also interested
in moving the web forward.

00:25:07.050 --> 00:25:10.840
Not just using the web
platform as a method

00:25:10.840 --> 00:25:13.040
for moving YouTube forward,
but actually advancing

00:25:13.040 --> 00:25:14.870
the web platform itself.

00:25:14.870 --> 00:25:17.960
So one example for
this is Media Source.

00:25:17.960 --> 00:25:20.229
Media Source is
the way that we did

00:25:20.229 --> 00:25:21.520
everything I just talked about.

00:25:21.520 --> 00:25:25.800
It's the adaptive
streaming solution

00:25:25.800 --> 00:25:27.440
as part of the web platform.

00:25:27.440 --> 00:25:32.487
And it's essential for all of
the adaptive streaming to work.

00:25:32.487 --> 00:25:34.820
It's the way that we communicate
with the browser stack.

00:25:34.820 --> 00:25:37.600
That took essentially
three years, maybe four

00:25:37.600 --> 00:25:39.720
if you count the
initial time when

00:25:39.720 --> 00:25:41.890
it started being
worked on internally.

00:25:41.890 --> 00:25:44.710
But it still took three years
to get universal adoption.

00:25:44.710 --> 00:25:47.180
And we think that
this should be faster.

00:25:47.180 --> 00:25:51.770
So as sort of a counter
example, you can consider VP9.

00:25:51.770 --> 00:25:54.120
VP9 is a technology
that allows us

00:25:54.120 --> 00:25:59.770
to deliver twice the video
quality at a given connection.

00:25:59.770 --> 00:26:03.300
So if you could only play
480p, you can now hit 720.

00:26:03.300 --> 00:26:07.450
And it's not a strict
apples to apples comparison

00:26:07.450 --> 00:26:09.820
there, because VP9 is
more of a web technology

00:26:09.820 --> 00:26:11.630
rather than a web standard.

00:26:11.630 --> 00:26:15.250
But the fact is that we started
looking at VP9 in earnest--

00:26:15.250 --> 00:26:17.270
we published this
spec about a year ago.

00:26:17.270 --> 00:26:19.360
And right now it's used
billions of times per day.

00:26:19.360 --> 00:26:22.520
It's making people's
experience dramatically better.

00:26:22.520 --> 00:26:26.010
And it's seen adoption
across a number of browsers.

00:26:26.010 --> 00:26:27.660
In fact, by this
time next year, we

00:26:27.660 --> 00:26:30.940
expect it to be in hundreds
or thousands of unique device

00:26:30.940 --> 00:26:31.900
models.

00:26:31.900 --> 00:26:34.440
And this kind of
coverage is possible

00:26:34.440 --> 00:26:38.120
because there was a huge
joint effort between YouTube,

00:26:38.120 --> 00:26:41.080
one of the largest consumers of
video, between the Chrome team,

00:26:41.080 --> 00:26:44.170
but also between YouTube's
external hardware partners,

00:26:44.170 --> 00:26:46.590
between a lot of hardware and
software companies working

00:26:46.590 --> 00:26:48.940
with the Chrome team on
extending their reach,

00:26:48.940 --> 00:26:52.020
between the Android team as
they push out the platform.

00:26:52.020 --> 00:26:57.110
So getting the adoption of
these technologies universally

00:26:57.110 --> 00:26:58.652
is important.

00:26:58.652 --> 00:27:00.860
It allows us to accelerate
the development-- not just

00:27:00.860 --> 00:27:04.710
of apps using the web platform,
but of the web platform itself.

00:27:04.710 --> 00:27:06.970
And we're looking
forward to doing

00:27:06.970 --> 00:27:10.850
more of that to continue
to advance this experience.

00:27:10.850 --> 00:27:12.900
All right, thank you very much.

00:27:12.900 --> 00:27:13.720
If you have--

00:27:13.720 --> 00:27:20.254
[APPLAUSE]

00:27:20.254 --> 00:27:21.920
STEVEN ROBERTSON: If
you have questions,

00:27:21.920 --> 00:27:22.700
please come up to the mics.

00:27:22.700 --> 00:27:23.908
We'd be happy to answer them.

00:27:36.107 --> 00:27:36.648
AUDIENCE: Hi.

00:27:36.648 --> 00:27:37.606
Thank you for the talk.

00:27:37.606 --> 00:27:39.170
It was very informative.

00:27:39.170 --> 00:27:41.410
So a lot of this stuff is
a little bit over my head,

00:27:41.410 --> 00:27:43.284
so maybe this question
won't make much sense,

00:27:43.284 --> 00:27:50.780
but you talked a lot about
HTML5 and the broader web.

00:27:50.780 --> 00:27:55.070
And you just mentioned VP9 being
implemented by major browsers.

00:27:55.070 --> 00:27:58.650
What is the situation in
embedded devices land?

00:27:58.650 --> 00:28:05.600
Like, is VP9 supported
by smart TVs?

00:28:05.600 --> 00:28:08.291
And more so HTML5 standards.

00:28:08.291 --> 00:28:10.290
LUKE BAYES: So that's
actually a great question.

00:28:10.290 --> 00:28:13.047
When I talked about us working
with the SOC manufacturers,

00:28:13.047 --> 00:28:14.630
so we've actually
been working closely

00:28:14.630 --> 00:28:16.255
with the people making
the chips to get

00:28:16.255 --> 00:28:17.964
VP9 decoding at
the hardware level.

00:28:17.964 --> 00:28:20.130
And when we do that,
essentially all of our partners

00:28:20.130 --> 00:28:23.150
get it for free with the
next generation of devices.

00:28:23.150 --> 00:28:24.580
So this is coming to TVs.

00:28:24.580 --> 00:28:26.530
This is coming to smart
Blu-ray disc players.

00:28:26.530 --> 00:28:29.110
This is coming to over-the-top
boxes, set-top boxes.

00:28:29.110 --> 00:28:31.040
This is the kind of
movement that we're really

00:28:31.040 --> 00:28:31.830
excited about.

00:28:31.830 --> 00:28:34.669
So yeah, definitely.

00:28:34.669 --> 00:28:35.460
AUDIENCE: Hi, guys.

00:28:35.460 --> 00:28:37.560
Thank you for a nice talk.

00:28:37.560 --> 00:28:43.100
I was wondering, you mentioned
that you support some input

00:28:43.100 --> 00:28:49.690
from consoles, but web doesn't
really support all of that.

00:28:49.690 --> 00:28:57.210
At least not the Xbox thingy
that tracks your movement.

00:28:57.210 --> 00:28:58.491
So how do you do that?

00:28:58.491 --> 00:29:00.740
LUKE BAYES: So that's actually
another great question.

00:29:00.740 --> 00:29:03.270
So we have these very
interesting and unique input

00:29:03.270 --> 00:29:04.060
devices.

00:29:04.060 --> 00:29:05.140
And there are
cases where we have

00:29:05.140 --> 00:29:07.015
to move a little bit
outside of web standards

00:29:07.015 --> 00:29:09.110
and expose another interface
at the browser level.

00:29:09.110 --> 00:29:11.380
But there are also cases where
we could treat, for example,

00:29:11.380 --> 00:29:11.880
gestures.

00:29:11.880 --> 00:29:14.171
We were able to implement
that at our application layer

00:29:14.171 --> 00:29:15.292
as if it were a mouse.

00:29:15.292 --> 00:29:17.750
And so we were able to hide
that abstraction in the browser

00:29:17.750 --> 00:29:20.070
itself and then expose
it to the JavaScript

00:29:20.070 --> 00:29:21.404
as if it was just a mouse input.

00:29:21.404 --> 00:29:23.569
So we were able to use the
[INAUDIBLE] web standards

00:29:23.569 --> 00:29:26.270
to take advantage of things that
don't appear on their surface

00:29:26.270 --> 00:29:27.920
to be a part of a web standards.

00:29:27.920 --> 00:29:30.260
AUDIENCE: All right, thank you.

00:29:30.260 --> 00:29:32.760
AUDIENCE: It sounds like you
guys spent three years building

00:29:32.760 --> 00:29:34.850
a platform to ensure
good web delivery

00:29:34.850 --> 00:29:36.781
to a variety of devices.

00:29:36.781 --> 00:29:39.280
But every other video company
that's trying to deliver video

00:29:39.280 --> 00:29:40.590
faces these same problems.

00:29:40.590 --> 00:29:43.157
So what should they do
if they're not YouTube?

00:29:43.157 --> 00:29:45.490
LUKE BAYES: Yeah, so we
actually work with many of them,

00:29:45.490 --> 00:29:46.702
as it turns out.

00:29:46.702 --> 00:29:48.160
So we work pretty
closely with many

00:29:48.160 --> 00:29:49.790
of these other video providers.

00:29:49.790 --> 00:29:52.330
And they're leveraging some
of the same technologies

00:29:52.330 --> 00:29:54.642
that we do especially on
these device environments.

00:29:54.642 --> 00:29:55.850
AUDIENCE: I will talk to you.

00:29:55.850 --> 00:29:58.294
LUKE BAYES: Great.

00:29:58.294 --> 00:30:01.270
AUDIENCE: How are you doing?

00:30:01.270 --> 00:30:03.160
I had a question
about developers

00:30:03.160 --> 00:30:05.160
who are building on top
of the YouTube platform.

00:30:05.160 --> 00:30:07.776
Currently the YouTube
APIs are quite rich

00:30:07.776 --> 00:30:09.150
and are getting
better every day,

00:30:09.150 --> 00:30:10.894
but there still are
limitations that

00:30:10.894 --> 00:30:12.310
obviously the
things you presented

00:30:12.310 --> 00:30:13.310
don't have to deal with.

00:30:13.310 --> 00:30:16.880
For example, on desktop
apps, developers

00:30:16.880 --> 00:30:19.650
have to interface with
the YouTube videos

00:30:19.650 --> 00:30:22.010
through the iFrame, which
your apps don't have to do.

00:30:22.010 --> 00:30:24.330
And then on other
platforms it may not

00:30:24.330 --> 00:30:26.600
be possible if there's
no developer API.

00:30:26.600 --> 00:30:28.660
So I'm curious just
kind of how you

00:30:28.660 --> 00:30:30.400
see the ecosystem
continue to evolve.

00:30:30.400 --> 00:30:33.510
Do you see APIs being
developed to allow developers

00:30:33.510 --> 00:30:37.840
to work on top of the YouTube
platform on game consoles

00:30:37.840 --> 00:30:40.179
and other devices like that?

00:30:40.179 --> 00:30:42.470
LUKE BAYES: Do you want to--
I can talk about consoles.

00:30:42.470 --> 00:30:45.380
Yeah, so, one of the
other things that came up

00:30:45.380 --> 00:30:48.989
is in these embedded devices
and device environments--

00:30:48.989 --> 00:30:51.280
part of your question is
about interacting with YouTube

00:30:51.280 --> 00:30:53.230
directly from within
another application.

00:30:53.230 --> 00:30:54.646
There's another
aspect of it which

00:30:54.646 --> 00:30:56.340
is about presenting
YouTube content

00:30:56.340 --> 00:30:58.007
but playing it back
in our application.

00:30:58.007 --> 00:30:59.590
And so there's an
aspect of that where

00:30:59.590 --> 00:31:00.965
our device partners,
for example,

00:31:00.965 --> 00:31:04.220
are using YouTube's APIs to
show YouTube content to users,

00:31:04.220 --> 00:31:07.270
and even personalized content
outside of our application.

00:31:07.270 --> 00:31:09.200
And then when a user
selects that content

00:31:09.200 --> 00:31:11.380
they can play it back
directly in our application.

00:31:11.380 --> 00:31:13.680
And this is an area where
every device partner has

00:31:13.680 --> 00:31:16.690
a very different way of
messaging from one application

00:31:16.690 --> 00:31:17.790
environment to another.

00:31:17.790 --> 00:31:20.514
But because we're on the web,
we are able to simply use URLs.

00:31:20.514 --> 00:31:22.930
We're able to say, hey, just
feed us a properly structured

00:31:22.930 --> 00:31:25.587
URL and we can launch the right
video or the right channel

00:31:25.587 --> 00:31:27.170
or the right playlist
and get the user

00:31:27.170 --> 00:31:28.930
the experience they're
really looking for.

00:31:28.930 --> 00:31:30.090
I think that second
part of your question

00:31:30.090 --> 00:31:31.310
is actually very important.

00:31:31.310 --> 00:31:35.610
And we are working on trying
to improve those teams.

00:31:35.610 --> 00:31:38.820
There's a lot of tradeoffs
there in terms of security

00:31:38.820 --> 00:31:43.052
and monetization
and trustworthiness.

00:31:43.052 --> 00:31:45.010
So there are issues there,
but we're definitely

00:31:45.010 --> 00:31:48.530
trying to improve the
ecosystem across the web.

00:31:48.530 --> 00:31:49.680
But it's a long road there.

00:31:49.680 --> 00:31:50.066
AUDIENCE: Good.

00:31:50.066 --> 00:31:50.840
Thank you very much.

00:31:50.840 --> 00:31:51.548
LUKE BAYES: Sure.

00:31:56.656 --> 00:31:58.155
AUDIENCE: Can you
go into any detail

00:31:58.155 --> 00:32:02.780
or give us a general overview
into how you collect and report

00:32:02.780 --> 00:32:04.910
on those metrics that
you made available

00:32:04.910 --> 00:32:06.035
across all those platforms?

00:32:06.035 --> 00:32:07.493
LUKE BAYES: There's
one for Strobe.

00:32:07.493 --> 00:32:08.830
STEVEN ROBERTSON: Sure.

00:32:08.830 --> 00:32:14.450
So we have infrastructure that
collects anonymized statistics

00:32:14.450 --> 00:32:18.870
based on the
individual playbacks.

00:32:18.870 --> 00:32:23.330
And some of that is
measured within the browser.

00:32:23.330 --> 00:32:25.400
So we have just JavaScript
code that executes.

00:32:25.400 --> 00:32:29.080
We look at current time and
have this really gnarly,

00:32:29.080 --> 00:32:30.870
denoising algorithm
to work around

00:32:30.870 --> 00:32:33.210
a bunch of pathologies in
a lot of the older devices.

00:32:33.210 --> 00:32:35.204
Newer devices are
better in part--

00:32:35.204 --> 00:32:36.620
and actually in
substantial part--

00:32:36.620 --> 00:32:40.630
because as part of the
YouTube certification program,

00:32:40.630 --> 00:32:44.940
we're making sure that devices
have clean input reporting

00:32:44.940 --> 00:32:48.090
and conform to the specs.

00:32:48.090 --> 00:32:51.215
So on the newer devices
it's just not as necessary.

00:32:51.215 --> 00:32:53.630
But we generate all
of that information

00:32:53.630 --> 00:32:56.455
from looking at the signals
that the device itself generates

00:32:56.455 --> 00:32:57.830
and then just
making sure that it

00:32:57.830 --> 00:33:00.890
does what we expect when
it logs those things.

00:33:00.890 --> 00:33:03.240
And then for the
server side, just as

00:33:03.240 --> 00:33:05.700
part of normal
server side logging,

00:33:05.700 --> 00:33:08.000
we grab all of that
information about the video.

00:33:08.000 --> 00:33:10.260
And we actually do--
it's more than just

00:33:10.260 --> 00:33:11.400
per request information.

00:33:11.400 --> 00:33:14.360
We'll look at some
values over time,

00:33:14.360 --> 00:33:16.150
such as a sampled
bandwidth or something.

00:33:16.150 --> 00:33:17.890
And we use a lot of
that and combine it

00:33:17.890 --> 00:33:21.260
in order to get an aggregated
view of the performance

00:33:21.260 --> 00:33:26.100
of each device as it's
playing back video.

00:33:26.100 --> 00:33:28.320
Is there a particular
question that you had or--

00:33:28.320 --> 00:33:29.964
AUDIENCE: Just
wondered in general.

00:33:29.964 --> 00:33:31.380
LUKE BAYES: Our
client and servers

00:33:31.380 --> 00:33:33.820
are both instrumented to
emit into a logging pipeline.

00:33:33.820 --> 00:33:35.690
And then we have lots
and lots of analytics

00:33:35.690 --> 00:33:36.730
around that logging.

00:33:36.730 --> 00:33:38.900
There's actually a
privacy story there

00:33:38.900 --> 00:33:40.840
that was really
fascinating for me

00:33:40.840 --> 00:33:42.380
when I joined the organization.

00:33:42.380 --> 00:33:44.588
I had this expectation like,
Google knows everything,

00:33:44.588 --> 00:33:45.150
it's amazing!

00:33:45.150 --> 00:33:46.650
And when I got to
YouTube, I found

00:33:46.650 --> 00:33:49.350
that I wasn't allowed to access
most of the things I really

00:33:49.350 --> 00:33:50.856
was interested in finding.

00:33:50.856 --> 00:33:52.980
So I want to look at what
this particular user did,

00:33:52.980 --> 00:33:54.354
because they just
reported a bug.

00:33:54.354 --> 00:33:56.100
I'm not allowed to
see that information.

00:33:56.100 --> 00:33:58.410
So our logging pipeline,
as Steven said,

00:33:58.410 --> 00:34:00.066
is actually anonymized.

00:34:00.066 --> 00:34:02.190
It's very difficult to look
at a particular session

00:34:02.190 --> 00:34:03.356
or a particular interaction.

00:34:03.356 --> 00:34:06.240
We end up looking at things
in aggregate and anonymized.

00:34:06.240 --> 00:34:07.980
So it's this weird
thing where it's

00:34:07.980 --> 00:34:09.170
like, I really want
to see these details,

00:34:09.170 --> 00:34:10.378
but I'm actually not allowed.

00:34:10.378 --> 00:34:13.600
So that was a strange moment
for me when I discovered that.

00:34:13.600 --> 00:34:15.850
I was like, oh, the people
actually doing these things

00:34:15.850 --> 00:34:17.725
don't have access to a
lot of the information

00:34:17.725 --> 00:34:19.232
I thought they did.

00:34:19.232 --> 00:34:21.989
AUDIENCE: Thank you.

00:34:21.989 --> 00:34:26.420
AUDIENCE: So I have
a pretty-- a question

00:34:26.420 --> 00:34:28.310
to the development
of the platform.

00:34:28.310 --> 00:34:33.040
So as you said that you
used the web platform.

00:34:33.040 --> 00:34:37.940
And over the web platform
you were developing the API,

00:34:37.940 --> 00:34:41.409
developing the software
for the YouTube platform

00:34:41.409 --> 00:34:43.750
over TV as well as for the
desktop and everything,

00:34:43.750 --> 00:34:45.230
using the same things.

00:34:45.230 --> 00:34:49.750
And what happened was that while
you were developing for the TV,

00:34:49.750 --> 00:34:52.280
you realized that there were
some things which, actually--

00:34:52.280 --> 00:34:54.710
like the example
that you gave-- were

00:34:54.710 --> 00:34:57.089
that little improvement
to the desktop as well,

00:34:57.089 --> 00:34:58.380
the desktop experience as well.

00:34:58.380 --> 00:35:03.040
So, my question is that there
are so many different kinds

00:35:03.040 --> 00:35:08.170
of platforms out there, and
you're using, I would say,

00:35:08.170 --> 00:35:11.570
the same piece of software
throughout all the platforms

00:35:11.570 --> 00:35:13.930
to render your stuff.

00:35:13.930 --> 00:35:18.979
So couldn't it be more better if
you had separate teams for it?

00:35:18.979 --> 00:35:21.020
Of course, it would be
the management [INAUDIBLE]

00:35:21.020 --> 00:35:23.300
but the [INAUDIBLE] could
be substantially improved

00:35:23.300 --> 00:35:24.977
or the performance
could be improved.

00:35:24.977 --> 00:35:26.810
LUKE BAYES: That's
something I brushed over.

00:35:26.810 --> 00:35:29.630
So we actually do
have different teams

00:35:29.630 --> 00:35:32.210
that work on the application
layer of these platforms.

00:35:32.210 --> 00:35:34.220
We have a separate team
and a separate binary

00:35:34.220 --> 00:35:36.227
and a separate application
for mobile web.

00:35:36.227 --> 00:35:38.310
We have a separate team
and a separate application

00:35:38.310 --> 00:35:40.290
for the desktop and laptop web.

00:35:40.290 --> 00:35:42.290
And then we have a separate
team and application

00:35:42.290 --> 00:35:43.380
for the TV application.

00:35:43.380 --> 00:35:46.730
Now Steven's team builds
the playback environment.

00:35:46.730 --> 00:35:49.390
So they have a single playback
binary that all of those teams

00:35:49.390 --> 00:35:52.700
consume, but we do have unique
applications for these very

00:35:52.700 --> 00:35:54.012
different input experiences.

00:35:54.012 --> 00:35:55.470
STEVEN ROBERTSON:
Yeah, and I think

00:35:55.470 --> 00:35:57.530
that the critical
component of that

00:35:57.530 --> 00:35:59.972
is that within most
applications there

00:35:59.972 --> 00:36:02.430
are teams that go horizontally
for a particular experience.

00:36:02.430 --> 00:36:05.171
There are teams that go
vertically for a core concern,

00:36:05.171 --> 00:36:07.170
especially if you have a
multi-device experience

00:36:07.170 --> 00:36:08.280
that you want.

00:36:08.280 --> 00:36:12.845
And being able to structure your
teams in that way is helpful.

00:36:12.845 --> 00:36:14.720
Being able to structure
your code in that way

00:36:14.720 --> 00:36:15.780
is also really helpful.

00:36:15.780 --> 00:36:17.479
And the web platform
lets us do both.

00:36:17.479 --> 00:36:18.645
AUDIENCE: Thank you so much.

00:36:21.782 --> 00:36:22.490
AUDIENCE: Thanks.

00:36:22.490 --> 00:36:24.360
That was very interesting talk.

00:36:24.360 --> 00:36:26.880
I was just wondering if you
guys received a lot of pushback

00:36:26.880 --> 00:36:28.338
from any of those
partners when you

00:36:28.338 --> 00:36:32.660
came to them with this idea
of really relying on the web.

00:36:32.660 --> 00:36:35.620
And also, are you finding any--

00:36:35.620 --> 00:36:38.319
LUKE BAYES: They
were so frustrating.

00:36:38.319 --> 00:36:40.360
AUDIENCE: And also, are
you finding any platforms

00:36:40.360 --> 00:36:44.490
where that just is--
it's just not working?

00:36:44.490 --> 00:36:48.860
LUKE BAYES: So we did have
a lot of conversations

00:36:48.860 --> 00:36:52.164
early on with partners around
what is the right technology

00:36:52.164 --> 00:36:53.330
to deliver this application.

00:36:53.330 --> 00:36:56.160
And there was a lot
of back and forth

00:36:56.160 --> 00:36:58.600
with what the right
decision was there.

00:36:58.600 --> 00:37:02.860
We were able to get universal
adoption in the TV environment,

00:37:02.860 --> 00:37:04.979
mainly because as soon
as we had any application

00:37:04.979 --> 00:37:07.520
on these devices, our partners
learned that their users spend

00:37:07.520 --> 00:37:09.460
most of their time
in our application.

00:37:09.460 --> 00:37:11.935
So they realized if they
put our logo in their box,

00:37:11.935 --> 00:37:12.741
they sell more TVs.

00:37:12.741 --> 00:37:14.115
They realize that
they put them--

00:37:14.115 --> 00:37:16.130
that people are using
their device more.

00:37:16.130 --> 00:37:18.852
So we had a certain
amount of leverage.

00:37:18.852 --> 00:37:21.310
And we were able to put this
environment into these devices

00:37:21.310 --> 00:37:23.654
that we think will benefit
a lot more organizations--

00:37:23.654 --> 00:37:25.320
other organizations
in addition to ours.

00:37:28.330 --> 00:37:30.580
And, sorry, what was the
second part of your question?

00:37:30.580 --> 00:37:31.370
AUDIENCE: Are
there any platforms

00:37:31.370 --> 00:37:33.470
where that strategy is
just really not working?

00:37:33.470 --> 00:37:34.428
LUKE BAYES: Absolutely.

00:37:34.428 --> 00:37:36.252
So we currently
have-- in the TV team,

00:37:36.252 --> 00:37:37.710
we actually have
a native team that

00:37:37.710 --> 00:37:39.792
builds an application
for the Xbox 360.

00:37:39.792 --> 00:37:41.250
So there are
platforms that we just

00:37:41.250 --> 00:37:42.720
can't get what we want there.

00:37:42.720 --> 00:37:44.410
And we will lean
into those as needed,

00:37:44.410 --> 00:37:48.395
but we try extremely hard to
get on to the web platform.

00:37:48.395 --> 00:37:49.020
AUDIENCE: Cool.

00:37:49.020 --> 00:37:49.561
Thanks a lot.

00:37:55.420 --> 00:37:57.880
LUKE BAYES: Any other questions?

00:37:57.880 --> 00:37:58.690
All right.

00:37:58.690 --> 00:37:58.920
STEVEN ROBERTSON: Thank you.

00:37:58.920 --> 00:38:00.253
LUKE BAYES: Thank you very much.

00:38:00.253 --> 00:38:01.500
[APPLAUSE]

