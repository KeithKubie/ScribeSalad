WEBVTT
Kind: captions
Language: en

00:00:02.172 --> 00:00:03.480
 When it comes to performance 

00:00:03.480 --> 00:00:07.030
 Sometimes it is not the big flagrant subjects that are causing the most problems, 

00:00:07.030 --> 00:00:11.216
 They are small things that when added together create huge problems for your application. 

00:00:11.216 --> 00:00:12.340
 My name is Colt McCannless, 

00:00:12.340 --> 00:00:15.870
 One of the ideal examples of small things combined that lead to major problems, 

00:00:15.870 --> 00:00:19.193
 Is an advantage in Java programming language known as Autoboxing automatic packaging 

00:00:19.327 --> 00:00:23.284
 Note that for Java, initial styles like int, bool and float 

00:00:23.363 --> 00:00:26.293
 Great for matching IEEE standards and hardware definitions. 

00:00:26.293 --> 00:00:29.033
 But this also prevents them from being used 

00:00:29.033 --> 00:00:30.615
 With public groups provided by the operating environment. 

00:00:30.615 --> 00:00:33.952
 Instead, Java provides versions of objects from these primitive styles 

00:00:33.999 --> 00:00:35.949
 Such as java.lang.Integer 

00:00:36.034 --> 00:00:38.313
 Which give you the same functions as the initial correct pattern, 

00:00:38.384 --> 00:00:41.189
 But can be used with public groups. 

00:00:41.432 --> 00:00:43.541
 This is where the role of automatic packaging comes. 

00:00:43.541 --> 00:00:44.956
 Automatic packaging at its core 

00:00:44.956 --> 00:00:48.830
 Converts from initial patterns to their counterparts of objects on your behalf, 

00:00:48.854 --> 00:00:51.900
 So you do not have to worry about any of those conversions in your code 

00:00:51.900 --> 00:00:53.495
 Which is pretty cool overall 

00:00:53.497 --> 00:00:55.458
 Take this simple loop, for example. 

00:00:55.458 --> 00:00:57.329
 We can handle the Integer object easily 

00:00:57.329 --> 00:01:00.620
 In the same way if it is an initial correct pattern without any additional installation. 

00:01:00.690 --> 00:01:03.430
 But unfortunately, the nature is free of manual control of this function 

00:01:03.430 --> 00:01:05.360
 Come with some performance penalties. 

00:01:05.360 --> 00:01:08.861
 Note, for each step of the Integer object copy of the loop, 

00:01:08.908 --> 00:01:12.815
 The operating environment must create a new Integer object and put an initial value in it 

00:01:12.816 --> 00:01:16.531
 Before they are able to be added to the other Integer object. 

00:01:16.744 --> 00:01:19.160
 This means that at any time you convert automatic packaging, 

00:01:19.160 --> 00:01:21.323
 The allocation of a new object will occur with it. 

00:01:21.434 --> 00:01:26.869
 Compare this with a copy using primary styles that do not require any additional allocation loads. 

00:01:27.188 --> 00:01:28.779
 This is really painful to watch, 

00:01:28.780 --> 00:01:32.045
 Because these organisms are larger than their primary counterparts, 

00:01:32.046 --> 00:01:35.546
 Where the Integer object takes a size of 16 bytes, instead of four for the initial style 

00:01:35.547 --> 00:01:39.840
 Further performance is also required to achieve the desired value 

00:01:40.141 --> 00:01:44.547
 It mainly creates a double blow to memory issues and operating environment performance. 

00:01:44.644 --> 00:01:47.340
 Now, you need to be aware that this problem does not simply appear 

00:01:47.340 --> 00:01:49.664
 With our fabricated examples like a loop for here 

00:01:49.696 --> 00:01:54.148
 Both. It appears at any time correlates a general set with an initial pattern, 

00:01:54.288 --> 00:01:57.242
 It is a special problem for containers such as HashMap. 

00:01:57.432 --> 00:02:00.523
 Basically any time you do by inserting, modifying, or retrieving values 

00:02:00.547 --> 00:02:03.321
 With this general container, while there is a primary pattern included, 

00:02:03.423 --> 00:02:06.140
 It will eventually end up with encapsulated or uncoated values 

00:02:06.140 --> 00:02:09.088
 Which is the exact reason for the availability of the Android platform 

00:02:09.183 --> 00:02:13.889
 Custom containers to be used in these cases instead of HashMap 

00:02:14.090 --> 00:02:16.510
 The family of SparseMap containers 

00:02:16.510 --> 00:02:20.241
 All designed specifically to combat the problem of automatic packaging 

00:02:20.680 --> 00:02:24.409
 Which eliminates both operating environment additions and reducing their impact on memory. 

00:02:24.630 --> 00:02:29.370
 Now if you are not sure where automatic encapsulation can cause trouble in your code, 

00:02:29.370 --> 00:02:32.340
 Android Studio tools can help you track it 

00:02:32.440 --> 00:02:35.673
 If you use the Customization Tracker tool, keep your attention anywhere 

00:02:35.704 --> 00:02:39.310
 You have a set of Integer objects that all come from a single calling site. 

00:02:39.310 --> 00:02:44.515
 In TraceView, watch out for an influx of calls to Integer.value 

00:02:44.516 --> 00:02:45.946
 For any reason given. 

00:02:45.946 --> 00:02:50.283
 Each of these reports is a clear sign of automatic packaging. 

00:02:50.450 --> 00:02:52.200
 While low performance level 

00:02:52.200 --> 00:02:54.705
 Is the easiest and most common fix found on it, 

00:02:55.050 --> 00:02:59.930
 These small problems start with really accumulating and really cause great problems if left unchecked. 

00:02:59.938 --> 00:03:03.619
 This is why you need to check out the rest of the content of Android performance patterns 

00:03:03.620 --> 00:03:05.338
 To see what is also working in the shade 

00:03:05.361 --> 00:03:08.768
 And, certainly, do not forget to join our community on Google+ as well 

00:03:08.919 --> 00:03:11.110
 For tips and other great tips. 

00:03:11.111 --> 00:03:15.153
 So keep calm, write your code, and always remember, performance is important. 

