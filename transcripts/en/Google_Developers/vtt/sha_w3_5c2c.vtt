WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:01.083
AUSTIN ROBISON: All right.

00:00:01.083 --> 00:00:02.360
Good morning, everybody.

00:00:02.360 --> 00:00:04.361
It's great to see a really
packed house in here.

00:00:04.361 --> 00:00:05.735
It looks like
standing room only.

00:00:05.735 --> 00:00:07.510
We're really excited
today to talk

00:00:07.510 --> 00:00:10.530
to you guys about Android Wear.

00:00:10.530 --> 00:00:11.510
I'm Austin Robison.

00:00:11.510 --> 00:00:13.779
I'm a product manager
with the team.

00:00:13.779 --> 00:00:15.070
JUSTIN KOH: And I'm Justin Koh.

00:00:15.070 --> 00:00:16.570
I'm an engineering
lead on the team.

00:00:16.570 --> 00:00:17.653
AUSTIN ROBISON: Excellent.

00:00:17.653 --> 00:00:19.980
And we have been so
thrilled with the excitement

00:00:19.980 --> 00:00:21.360
that we've gotten from you
guys throughout the rest

00:00:21.360 --> 00:00:22.470
of the conference.

00:00:22.470 --> 00:00:24.570
I think the third floor
area where the devices

00:00:24.570 --> 00:00:27.520
are out there has been
mobbed the entire time that I

00:00:27.520 --> 00:00:28.270
have walked by.

00:00:28.270 --> 00:00:30.160
So thank you for
all of your support,

00:00:30.160 --> 00:00:32.380
and we're really excited
to talk about what

00:00:32.380 --> 00:00:34.370
we're doing with Android Wear.

00:00:34.370 --> 00:00:36.785
So I wanted to start with
a quick overview of what

00:00:36.785 --> 00:00:38.200
Android Wear is all about.

00:00:38.200 --> 00:00:40.400
And we'll dive into some
code and really show you

00:00:40.400 --> 00:00:44.160
what it's like to build
applications for Wear.

00:00:44.160 --> 00:00:46.750
So we all love our smartphones.

00:00:46.750 --> 00:00:48.870
They're rich and
engaging, and they

00:00:48.870 --> 00:00:52.117
can deliver these are really
deep engrossing experiences.

00:00:52.117 --> 00:00:54.450
But I think this is a picture
that we can all relate to,

00:00:54.450 --> 00:00:56.980
sitting around, we're all
focusing on our phones

00:00:56.980 --> 00:00:58.750
and not on the people around us.

00:00:58.750 --> 00:01:00.550
So technology can
be distracting,

00:01:00.550 --> 00:01:03.000
and here's where we saw an
opportunity with Android Wear

00:01:03.000 --> 00:01:04.810
to make this better.

00:01:04.810 --> 00:01:07.540
Android Wear delivers
information just when

00:01:07.540 --> 00:01:09.830
you need it and
just in a glance.

00:01:09.830 --> 00:01:11.830
And really, that means
you can be more connected

00:01:11.830 --> 00:01:14.000
to the people around
you and the people who

00:01:14.000 --> 00:01:15.270
aren't with you at that time.

00:01:15.270 --> 00:01:17.429
So if you look at
that in a timeline,

00:01:17.429 --> 00:01:19.720
this is something that I
think we have all experienced.

00:01:19.720 --> 00:01:22.546
You feel your phone buzz in
your pockets, you pull it out,

00:01:22.546 --> 00:01:25.170
and you're like, OK, well, I got
some email notifications here.

00:01:25.170 --> 00:01:27.086
You go to your inbox,
and next thing you know,

00:01:27.086 --> 00:01:28.590
you spend several
minutes distracted

00:01:28.590 --> 00:01:32.280
from the world around
you, really engaged

00:01:32.280 --> 00:01:34.380
with what you're doing,
but not necessarily

00:01:34.380 --> 00:01:36.110
present with what's going on.

00:01:36.110 --> 00:01:39.470
So with Android Wear and having
these glanceable notifications

00:01:39.470 --> 00:01:43.040
on your wrist, you can have more
interaction throughout the day,

00:01:43.040 --> 00:01:44.851
have them shorter
and less distracting

00:01:44.851 --> 00:01:46.350
from the world
around you, but still

00:01:46.350 --> 00:01:50.900
get more information
about what's happening.

00:01:50.900 --> 00:01:53.460
So to deliver this
new interaction model,

00:01:53.460 --> 00:01:56.520
we created an entirely new UI.

00:01:56.520 --> 00:01:59.460
Now, what that is is a
vertical stream of contextually

00:01:59.460 --> 00:02:00.430
ranked cards.

00:02:00.430 --> 00:02:02.630
So you have the most
important information for you

00:02:02.630 --> 00:02:04.255
at the top of the
stream, ready for you

00:02:04.255 --> 00:02:06.050
to glance down and
take a look at it.

00:02:06.050 --> 00:02:10.680
This is completely automated
from a Android perspective

00:02:10.680 --> 00:02:12.970
of having your notifications
bridged across.

00:02:12.970 --> 00:02:15.780
It also has Google Now
cards, and importantly, it

00:02:15.780 --> 00:02:17.290
has your third
party content, which

00:02:17.290 --> 00:02:19.770
is what we're going to
be talking about today.

00:02:19.770 --> 00:02:21.419
So earlier this
year, we launched

00:02:21.419 --> 00:02:23.210
a developer preview
that allowed you to get

00:02:23.210 --> 00:02:25.870
started experimenting
with your apps of what

00:02:25.870 --> 00:02:28.340
it would be like to bring
your experience to the wrist.

00:02:28.340 --> 00:02:32.060
So this allowed you to take
your notification objects

00:02:32.060 --> 00:02:34.320
on your phone and really
be able to augment

00:02:34.320 --> 00:02:36.980
them to have additional
pages of information,

00:02:36.980 --> 00:02:40.310
to be able to bundle these
things together in stacks,

00:02:40.310 --> 00:02:43.200
and to be able to
have voice replies.

00:02:43.200 --> 00:02:45.220
So what we're making
available today

00:02:45.220 --> 00:02:48.780
is an SDK that allows you to
extend those experiences even

00:02:48.780 --> 00:02:50.590
further, where you're
running code directly

00:02:50.590 --> 00:02:53.545
on the wearable using all of
the familiar Android tools

00:02:53.545 --> 00:02:56.179
that you are already
used to using.

00:02:56.179 --> 00:02:57.970
So we're going to
introduce a few APIs that

00:02:57.970 --> 00:03:01.550
allow you to send data back
and forth between the wearable

00:03:01.550 --> 00:03:05.210
and your phone, as well
as generate custom UI

00:03:05.210 --> 00:03:09.020
and integrate with Voice Actions
through intent filtering,

00:03:09.020 --> 00:03:11.270
just like on the phone.

00:03:11.270 --> 00:03:13.900
So we've been battle
testing these APIs

00:03:13.900 --> 00:03:16.850
with dozens of third
party partners.

00:03:16.850 --> 00:03:18.910
And we've had some really
great apps be created.

00:03:18.910 --> 00:03:21.089
You've seen several of them
featured in the keynote.

00:03:21.089 --> 00:03:23.130
You've seen several of
them in previous sessions.

00:03:23.130 --> 00:03:24.755
I'm going to walk
through a couple more

00:03:24.755 --> 00:03:29.450
here, just to give you an idea
of the types of things that

00:03:29.450 --> 00:03:32.670
are now possible with this SDK.

00:03:32.670 --> 00:03:35.970
So Runtastic is a
social fitness platform.

00:03:35.970 --> 00:03:39.870
And their Wear integration helps
users control those sessions

00:03:39.870 --> 00:03:40.860
from their wrist.

00:03:40.860 --> 00:03:42.850
So you can say, OK,
Google, start running.

00:03:42.850 --> 00:03:45.820
And they'll post a notification
to that stream that

00:03:45.820 --> 00:03:48.870
has a running timer
of your current run.

00:03:48.870 --> 00:03:52.480
They can also show new
UI inside of these cards

00:03:52.480 --> 00:03:55.850
with a new platform feature
called Display Intents that

00:03:55.850 --> 00:03:58.230
allow you to embed
an activity directly

00:03:58.230 --> 00:04:01.920
into these cards for
drawing your own UI.

00:04:01.920 --> 00:04:04.334
On the right here
we also see a piece

00:04:04.334 --> 00:04:06.250
of data that was generated
in the phone, which

00:04:06.250 --> 00:04:08.287
is your route that can
be synchronized across

00:04:08.287 --> 00:04:08.870
automatically.

00:04:08.870 --> 00:04:11.880
And we'll go into the
details of how you do that.

00:04:11.880 --> 00:04:13.742
Another example, Philips Hue.

00:04:13.742 --> 00:04:15.200
They are connected
light bulbs that

00:04:15.200 --> 00:04:18.964
allow you to change their
colors from your phone.

00:04:18.964 --> 00:04:20.630
There's a display out
on the third floor

00:04:20.630 --> 00:04:22.270
here, really fantastic.

00:04:22.270 --> 00:04:24.620
Maybe they're down on
the second floor, sorry.

00:04:24.620 --> 00:04:27.260
And what their app does
is when you come home,

00:04:27.260 --> 00:04:29.810
it posts this contextual
card to the stream

00:04:29.810 --> 00:04:32.000
that allows you to then
control your lighting.

00:04:32.000 --> 00:04:34.620
They also can launch
a full screen activity

00:04:34.620 --> 00:04:37.280
to draw their own UI to have
a more immersive experience

00:04:37.280 --> 00:04:38.910
while you're
controlling that app,

00:04:38.910 --> 00:04:40.720
and then get back to the stream.

00:04:40.720 --> 00:04:43.220
So important to note here is
that we're really focusing apps

00:04:43.220 --> 00:04:44.710
around micro interactions.

00:04:44.710 --> 00:04:47.660
So we want users to be able
to get into your feature,

00:04:47.660 --> 00:04:49.280
complete a task,
and then get back

00:04:49.280 --> 00:04:51.730
to that stream as
quickly as possible.

00:04:51.730 --> 00:04:54.200
If there's an action that
requires deeper integration,

00:04:54.200 --> 00:04:56.740
we want to forward that
user back to the phone.

00:04:56.740 --> 00:04:59.760
And we've also made
that very easy for you.

00:04:59.760 --> 00:05:01.860
One more example
here, Glympse, which

00:05:01.860 --> 00:05:04.270
is a social location
sharing application.

00:05:04.270 --> 00:05:07.100
So you can send your
location to your friends.

00:05:07.100 --> 00:05:10.010
On the wearable, we can
send contact information

00:05:10.010 --> 00:05:12.630
from your phone across, so you
can have a list of contacts

00:05:12.630 --> 00:05:15.380
to look through to be able
to send those locations.

00:05:15.380 --> 00:05:19.390
When you receive a Glympse, you
can also then see in real time

00:05:19.390 --> 00:05:22.700
the progress of your
friend coming to you.

00:05:22.700 --> 00:05:25.262
So let's take a
look at what we're

00:05:25.262 --> 00:05:27.470
going to be looking at for
the rest of the talk here.

00:05:27.470 --> 00:05:31.280
So Justin just got this
adorable new puppy,

00:05:31.280 --> 00:05:33.990
and so we've built a little
slide control app here

00:05:33.990 --> 00:05:38.700
for showing some
pictures of that puppy.

00:05:38.700 --> 00:05:41.700
So we've got a phone
and a wearable up here.

00:05:41.700 --> 00:05:44.790
When we start on
this slide show,

00:05:44.790 --> 00:05:48.180
we can post a notification to
the stream on the right here.

00:05:48.180 --> 00:05:50.620
As you scroll through the
ViewPager on the left,

00:05:50.620 --> 00:05:52.600
we're updating in
real time on the right

00:05:52.600 --> 00:05:56.070
the title of the slide, as well
as the number of the slide.

00:05:56.070 --> 00:05:58.730
We also have an action that
allows you to go backwards.

00:05:58.730 --> 00:06:01.340
Tapping on that first
piece also allows

00:06:01.340 --> 00:06:04.030
you to advance the
slides on the phone.

00:06:04.030 --> 00:06:05.960
So we're using it
as a remote control.

00:06:05.960 --> 00:06:07.920
And we're using all
of these new APIs

00:06:07.920 --> 00:06:12.820
to provide a seamless
experience across both devices.

00:06:12.820 --> 00:06:14.700
So if we take a look
at what it takes

00:06:14.700 --> 00:06:17.630
to build this
application, when we write

00:06:17.630 --> 00:06:19.940
an app for a phone or
a tablet, typically we

00:06:19.940 --> 00:06:22.620
have one APK per app.

00:06:22.620 --> 00:06:25.270
But with Android Wear,
we're extending that concept

00:06:25.270 --> 00:06:28.770
to expand across both devices.

00:06:28.770 --> 00:06:31.069
So we have an APK that
runs directly on the phone,

00:06:31.069 --> 00:06:32.610
and we have an APK
that runs directly

00:06:32.610 --> 00:06:36.670
on the wearable that are
both part of your app.

00:06:36.670 --> 00:06:39.110
Google Play services is
what brings these two things

00:06:39.110 --> 00:06:42.080
together and where we're going
to talk about a new set of APIs

00:06:42.080 --> 00:06:45.140
that allow you to send
data between the two

00:06:45.140 --> 00:06:48.450
and facilitate
that communication.

00:06:48.450 --> 00:06:53.880
So the wearable services consist
of three APIs, a Data API,

00:06:53.880 --> 00:06:56.640
a Message API, and a Node API.

00:06:56.640 --> 00:06:59.020
These are both callable
from either side, so

00:06:59.020 --> 00:07:01.460
from the wearable
or from the phone.

00:07:01.460 --> 00:07:04.020
And all of your data is
private to your application

00:07:04.020 --> 00:07:06.490
across the link.

00:07:06.490 --> 00:07:09.420
So if we dig into here first
and look at the Node API,

00:07:09.420 --> 00:07:11.100
this is used for
discovering when

00:07:11.100 --> 00:07:13.520
nodes come into and out
of a connected state.

00:07:13.520 --> 00:07:15.280
So when we have a
pairing established

00:07:15.280 --> 00:07:17.390
between a watch and
a phone, for example,

00:07:17.390 --> 00:07:21.386
we can be notified when we
come into connection range.

00:07:21.386 --> 00:07:22.760
So you might use
this in your app

00:07:22.760 --> 00:07:25.720
to know when a wearable is
present to toggle features

00:07:25.720 --> 00:07:26.647
on and off.

00:07:26.647 --> 00:07:28.480
We might display an
icon to show that you're

00:07:28.480 --> 00:07:29.850
connected to a wearable.

00:07:29.850 --> 00:07:31.660
It's a very simple
API for just being

00:07:31.660 --> 00:07:35.170
aware of when the
wearable is present.

00:07:35.170 --> 00:07:37.950
Built on top of that
is the Message API.

00:07:37.950 --> 00:07:40.340
So this is a low
latency mechanism

00:07:40.340 --> 00:07:43.730
for sending byte arrays back
and forth between the devices.

00:07:43.730 --> 00:07:45.390
And they can be
filtered on pads,

00:07:45.390 --> 00:07:48.580
which Justin will
explain in detail later.

00:07:48.580 --> 00:07:51.190
So in the puppy
example, when we are

00:07:51.190 --> 00:07:54.500
tapping on the
card in the stream

00:07:54.500 --> 00:07:57.250
or tapping that Back
button to go backwards,

00:07:57.250 --> 00:08:00.670
we're calling sendMessage to
send a simple control back

00:08:00.670 --> 00:08:03.240
to the phone, which
receives that message

00:08:03.240 --> 00:08:05.930
and then moves the ViewPager.

00:08:05.930 --> 00:08:08.450
The Data API is
the biggest piece

00:08:08.450 --> 00:08:10.550
of this new wearable service.

00:08:10.550 --> 00:08:12.125
It's a replicated data store.

00:08:12.125 --> 00:08:14.370
You can think about
it as a shared cache.

00:08:14.370 --> 00:08:17.470
So we have the ability
to put data into this,

00:08:17.470 --> 00:08:19.140
and take data out
of it, be notified

00:08:19.140 --> 00:08:21.840
when it changes on either
side, and we take care

00:08:21.840 --> 00:08:24.270
of synchronizing that
data between devices.

00:08:24.270 --> 00:08:27.420
So you don't need to worry about
devices that are intermittently

00:08:27.420 --> 00:08:30.870
connected, what to do
when you have extended

00:08:30.870 --> 00:08:32.716
periods of not being connected.

00:08:32.716 --> 00:08:34.090
We do all of the
hard work there.

00:08:34.090 --> 00:08:36.215
And all you have to do from
the outside is put data

00:08:36.215 --> 00:08:37.760
into the store and take it out.

00:08:40.890 --> 00:08:43.220
So in the puppy
example, we might

00:08:43.220 --> 00:08:45.940
put the title of the slide
and that slide number

00:08:45.940 --> 00:08:46.990
into the store.

00:08:46.990 --> 00:08:48.760
Google Play services
replicates that

00:08:48.760 --> 00:08:53.490
across to the wearable,
where we can then

00:08:53.490 --> 00:08:55.310
update that notification
in real time.

00:08:55.310 --> 00:08:59.210
So we can have the data
sent back and forth there.

00:08:59.210 --> 00:09:00.710
So now I'm going
to turn things over

00:09:00.710 --> 00:09:02.084
to Justin for a
little bit, who's

00:09:02.084 --> 00:09:04.830
going to walk us
through using these APIs

00:09:04.830 --> 00:09:06.910
and really dig into
some of the code, which

00:09:06.910 --> 00:09:11.016
I know you're all excited about.

00:09:11.016 --> 00:09:12.200
Take it away, Justin.

00:09:12.200 --> 00:09:13.575
JUSTIN KOH: Thanks
a lot, Austin.

00:09:13.575 --> 00:09:16.080
Whoa, little drinking
problem there.

00:09:16.080 --> 00:09:17.697
So you'll have to excuse me.

00:09:17.697 --> 00:09:20.280
We just got our new puppy, and
I'm incredibly allergic to her.

00:09:20.280 --> 00:09:21.860
So I've developed
a bit of a cough.

00:09:21.860 --> 00:09:23.484
So if you see me
about to go like this,

00:09:23.484 --> 00:09:25.900
everyone kinda ear muffs.

00:09:25.900 --> 00:09:29.825
So let's take a look at the
overall building blocks that

00:09:29.825 --> 00:09:31.590
are going to make
up our application.

00:09:31.590 --> 00:09:33.190
On the left-hand
side here, we see

00:09:33.190 --> 00:09:35.760
we have our ViewPager that's
going to have a couple

00:09:35.760 --> 00:09:38.540
fragments, these
slide fragments.

00:09:38.540 --> 00:09:42.170
And when the user slides
from left to right,

00:09:42.170 --> 00:09:44.960
we're going to
update our data item.

00:09:44.960 --> 00:09:49.660
We're going to update
the index from 1 to 2.

00:09:49.660 --> 00:09:52.510
We push this into
the data store.

00:09:52.510 --> 00:09:56.180
And that event is going to
get over to the wearable.

00:09:56.180 --> 00:10:01.100
And we're going to update a
notification when that happens.

00:10:01.100 --> 00:10:05.100
So to begin, we need to
download Android Studio

00:10:05.100 --> 00:10:06.420
and create a new project.

00:10:06.420 --> 00:10:09.570
So I've created a new project
here called Slide Control.

00:10:09.570 --> 00:10:12.760
You can see that Android Studio
now supports multiple form

00:10:12.760 --> 00:10:15.350
factors, all the form factors
that we talked about yesterday.

00:10:15.350 --> 00:10:16.650
Wear is one of those.

00:10:16.650 --> 00:10:18.407
So you just click
the check box here,

00:10:18.407 --> 00:10:20.740
and Android Studio is going
to take care of packaging up

00:10:20.740 --> 00:10:24.500
this glanceable portion of
your APK, or this watch APK,

00:10:24.500 --> 00:10:27.180
into your phone application
so that it can be distributed

00:10:27.180 --> 00:10:29.860
through the Play Store.

00:10:29.860 --> 00:10:32.420
Let's start by setting
up the phone UI.

00:10:32.420 --> 00:10:34.940
So like I said, this
activity is ViewPager,

00:10:34.940 --> 00:10:36.453
and it has a couple
fragments in it,

00:10:36.453 --> 00:10:38.924
with the background
image, title of the slide.

00:10:38.924 --> 00:10:40.590
And these are all the
files that make up

00:10:40.590 --> 00:10:41.881
the two different applications.

00:10:41.881 --> 00:10:45.340
Again, on the left, we've got
the phone APK files in green.

00:10:45.340 --> 00:10:48.990
On the right, we've got the
wearable APK files in blue.

00:10:48.990 --> 00:10:51.670
Let's take a look at the
presentation activity.

00:10:51.670 --> 00:10:54.200
And this is the ViewPager one.

00:10:54.200 --> 00:10:56.810
And we can see that the
first thing we need to do

00:10:56.810 --> 00:10:59.410
is to create a
Google API client.

00:10:59.410 --> 00:11:03.150
That's your entry point into all
of these Google Play services.

00:11:03.150 --> 00:11:06.067
So the new API here
is the Wearable API.

00:11:06.067 --> 00:11:07.900
So I'm going to build
my client and stash it

00:11:07.900 --> 00:11:10.316
away somewhere so I can use
it throughout my application's

00:11:10.316 --> 00:11:11.540
life cycle.

00:11:11.540 --> 00:11:14.180
Next thing I want to do
is wire up my ViewPager

00:11:14.180 --> 00:11:16.100
so that when those
events happen,

00:11:16.100 --> 00:11:18.140
we can update the Data Store.

00:11:18.140 --> 00:11:20.960
And I do that by creating
an OnPageChangedListener

00:11:20.960 --> 00:11:24.300
and calling updateDataItem.

00:11:24.300 --> 00:11:25.800
Let's take a look at data items.

00:11:25.800 --> 00:11:30.890
So like we said, URIs are
everything in this Data API.

00:11:30.890 --> 00:11:32.690
And we do that because
it's really easy

00:11:32.690 --> 00:11:37.420
to create them and parse them
using existing Android classes.

00:11:37.420 --> 00:11:40.050
So in this case, I am
creating a data item

00:11:40.050 --> 00:11:42.610
that's going to
manage the state.

00:11:42.610 --> 00:11:44.980
What is the current index
and the current title

00:11:44.980 --> 00:11:47.820
of the presentation
slide that I'm on?

00:11:47.820 --> 00:11:50.970
So I create this /state path.

00:11:50.970 --> 00:11:54.140
And internally, the Data API
is going to create this fully

00:11:54.140 --> 00:11:58.970
qualified URI, wear://,
nodeid, and state.

00:11:58.970 --> 00:12:00.930
Now, you don't have to
worry about that as much

00:12:00.930 --> 00:12:01.513
as developers.

00:12:01.513 --> 00:12:03.720
You can just worry about
the paths, et cetera.

00:12:03.720 --> 00:12:06.430
But knowing that this
is the format of the URI

00:12:06.430 --> 00:12:08.930
will help you later
when it comes time

00:12:08.930 --> 00:12:14.080
to reconstitute these
URIs on the other side.

00:12:14.080 --> 00:12:16.810
Data items are byte
arrays at their base,

00:12:16.810 --> 00:12:18.890
but we know that
working with byte arrays

00:12:18.890 --> 00:12:21.710
can be not that flexible.

00:12:21.710 --> 00:12:24.630
It's really nice to be able
to work at the key value pair

00:12:24.630 --> 00:12:26.060
level, like a bundle.

00:12:26.060 --> 00:12:27.660
So we've created
a key value pair

00:12:27.660 --> 00:12:31.090
object called the Data Map,
which stores primitive types.

00:12:31.090 --> 00:12:33.480
Unlike a bundle, we
won't be storing anything

00:12:33.480 --> 00:12:35.570
like parcelables
or binders in there

00:12:35.570 --> 00:12:38.540
because this item
is going to be sent

00:12:38.540 --> 00:12:41.430
to all of the nodes
in our network.

00:12:41.430 --> 00:12:43.150
So in this case, I
create a data map,

00:12:43.150 --> 00:12:45.108
and I'm going to put in
these primitive types--

00:12:45.108 --> 00:12:47.320
the current index, the
total number of slides,

00:12:47.320 --> 00:12:49.940
and the title of the
current slide we're on.

00:12:49.940 --> 00:12:52.729
Finally, I just insert
it into the store.

00:12:52.729 --> 00:12:54.145
And it's going to
get synchronized

00:12:54.145 --> 00:12:57.900
to all of the connected nodes.

00:12:57.900 --> 00:13:01.420
On the wearable side, we want
to be able to receive this.

00:13:01.420 --> 00:13:05.810
And we want to be running
a service to do so.

00:13:05.810 --> 00:13:10.260
Now, we don't want all of
the different applications

00:13:10.260 --> 00:13:13.210
to have to be running constant
services all the time just

00:13:13.210 --> 00:13:16.230
to listen for a message.

00:13:16.230 --> 00:13:19.540
And so what we've done is we've
created this abstract class,

00:13:19.540 --> 00:13:21.880
the WearableListenerService,
which

00:13:21.880 --> 00:13:24.700
implements all of the
different callback methods

00:13:24.700 --> 00:13:27.630
that you're going to be using
with these wearable APIs.

00:13:27.630 --> 00:13:29.200
That's NodeListener,
MessageListener,

00:13:29.200 --> 00:13:31.000
and DataListener.

00:13:31.000 --> 00:13:32.450
So I have subclassed
this here in

00:13:32.450 --> 00:13:35.430
a PresentationListenerService,
and I just

00:13:35.430 --> 00:13:38.310
insert that into my
Android manifest.

00:13:38.310 --> 00:13:41.940
By doing so, the Google
Play services APK

00:13:41.940 --> 00:13:45.180
is going to manage the life
cycle of this service for me

00:13:45.180 --> 00:13:47.070
so it's not always
running and consuming

00:13:47.070 --> 00:13:50.960
resources, precious
resources, on my wearable.

00:13:50.960 --> 00:13:54.430
Let's go over here to
PresentationListenerSerivce.

00:13:54.430 --> 00:14:00.950
And you'll see that the
DataListener interface

00:14:00.950 --> 00:14:02.990
has one method, OnDataChanged.

00:14:02.990 --> 00:14:06.450
When I get that, I'm going to
check the path because there

00:14:06.450 --> 00:14:08.305
may be multiple messages
in my application.

00:14:08.305 --> 00:14:09.680
And I want to make
sure I'm doing

00:14:09.680 --> 00:14:12.740
the right thing with
the right data item.

00:14:12.740 --> 00:14:16.510
So if the state, remember
we set this up as the state,

00:14:16.510 --> 00:14:18.770
is the data item's
path, then I'm

00:14:18.770 --> 00:14:22.350
going to either create or
update the notification,

00:14:22.350 --> 00:14:23.640
if it's just being changed.

00:14:23.640 --> 00:14:25.120
And if it's being
deleted, I want

00:14:25.120 --> 00:14:27.040
to remove that notification
from the stream

00:14:27.040 --> 00:14:30.890
because it's no longer
relevant to the user.

00:14:30.890 --> 00:14:34.930
In handleStateChanged, we're
going to extract our data map.

00:14:34.930 --> 00:14:38.152
We're going to get all of
those primitives out of there,

00:14:38.152 --> 00:14:39.860
and we're going to
post our notification.

00:14:39.860 --> 00:14:41.430
Now, I know this
is a lot of code.

00:14:41.430 --> 00:14:42.960
I'm going to walk
through it step by step.

00:14:42.960 --> 00:14:44.620
What are the things
that we want to do?

00:14:44.620 --> 00:14:46.750
We want to get an intent
back into our service

00:14:46.750 --> 00:14:48.850
when the user taps
that first card.

00:14:48.850 --> 00:14:50.350
So to do so, it's
just like Android.

00:14:50.350 --> 00:14:53.680
I'm going to create a
PendingIntent to our service.

00:14:53.680 --> 00:14:56.350
And I'm going to use an
action on this intent

00:14:56.350 --> 00:14:57.984
to determine what
the user wants to do.

00:14:57.984 --> 00:14:59.400
Do they want to
advance the slide,

00:14:59.400 --> 00:15:00.691
or do they want to go previous?

00:15:02.850 --> 00:15:04.550
Next thing I'm going
to do is create

00:15:04.550 --> 00:15:06.800
a NotificationManagerCompat
object,

00:15:06.800 --> 00:15:08.410
which is in the support library.

00:15:08.410 --> 00:15:10.120
So building this
basic notification

00:15:10.120 --> 00:15:13.030
is just like building a
notification on the phone.

00:15:13.030 --> 00:15:14.300
I've got my title.

00:15:14.300 --> 00:15:15.280
I've got my text.

00:15:15.280 --> 00:15:16.680
And like Austin
said, we're going

00:15:16.680 --> 00:15:19.635
to setOngoing because this
represents an ongoing process.

00:15:23.000 --> 00:15:26.880
Finally, we're going to augment
or extend our notification

00:15:26.880 --> 00:15:30.980
with the new APIs that exist
in the support library.

00:15:30.980 --> 00:15:33.300
So I'm going to create
a new action which

00:15:33.300 --> 00:15:35.630
will be the advance action.

00:15:35.630 --> 00:15:38.560
By default, if I were to
have created a content

00:15:38.560 --> 00:15:42.746
intent, on Android Wear we would
render this as a blue circle.

00:15:42.746 --> 00:15:44.120
But if you notice
from the demos,

00:15:44.120 --> 00:15:47.890
we wanted to be able to just tap
the card and advance the slide.

00:15:47.890 --> 00:15:51.980
So I've created my action
here with a drawable and just

00:15:51.980 --> 00:15:53.300
some text.

00:15:53.300 --> 00:15:55.930
And I've called
setContentAction.

00:15:55.930 --> 00:15:59.170
That's going to hoist that
action on to the card.

00:15:59.170 --> 00:16:02.140
And if you remember from
the design talk that you

00:16:02.140 --> 00:16:03.920
may have seen,
Designing for Wearables,

00:16:03.920 --> 00:16:05.882
we're going to want to
make that icon blue so

00:16:05.882 --> 00:16:07.840
that the user knows that
they can tap the card.

00:16:07.840 --> 00:16:09.089
That's going to be the signal.

00:16:09.089 --> 00:16:12.010
When they see blue, that's
an actionable thing.

00:16:12.010 --> 00:16:13.860
Finally, we extend our builder.

00:16:13.860 --> 00:16:17.150
And that's going to create
that notification that you see.

00:16:17.150 --> 00:16:19.140
Now of course, with
even more code,

00:16:19.140 --> 00:16:21.160
we can add in the
previous action.

00:16:21.160 --> 00:16:24.437
We just create a different
intent with a different action,

00:16:24.437 --> 00:16:26.020
with a different
action on the intent,

00:16:26.020 --> 00:16:28.395
and then we create a different
action on the notification

00:16:28.395 --> 00:16:29.830
itself.

00:16:29.830 --> 00:16:32.160
So as a reward for getting
through all that code,

00:16:32.160 --> 00:16:33.326
here's a picture of a puppy.

00:16:36.340 --> 00:16:39.480
So on the phone
side, we're going

00:16:39.480 --> 00:16:42.226
to want to receive
some messages.

00:16:42.226 --> 00:16:44.100
So first of all, we have
to send the message.

00:16:44.100 --> 00:16:45.260
So in this case,
we're going to see

00:16:45.260 --> 00:16:47.385
that I'm going to tap on
the Previous Slide button,

00:16:47.385 --> 00:16:51.050
and it's going to go back there.

00:16:51.050 --> 00:16:54.162
And that's still going to be
in PresentationListenerService.

00:16:54.162 --> 00:16:55.870
Remember, when that
pending intent fires,

00:16:55.870 --> 00:16:58.210
it's going to come
back into our service.

00:16:58.210 --> 00:17:01.760
And check what is the action
of the intent that came in.

00:17:01.760 --> 00:17:03.260
And I'm going to
just send a control

00:17:03.260 --> 00:17:05.359
message using the Message API.

00:17:05.359 --> 00:17:07.430
So I take a Google
API client where

00:17:07.430 --> 00:17:10.520
I've added the Wearable API, and
I'm just going to send 1 byte.

00:17:10.520 --> 00:17:13.970
So it's either going to be 0
to go forward or 1 to go back.

00:17:13.970 --> 00:17:18.510
And I'm going to send this to
a specific node, the node that

00:17:18.510 --> 00:17:20.030
owns the data item.

00:17:20.030 --> 00:17:22.150
Remember, I can
get this by parsing

00:17:22.150 --> 00:17:25.460
the path of the data item.

00:17:25.460 --> 00:17:28.079
And I'm going to send this on
its own specific path, which

00:17:28.079 --> 00:17:31.440
we're going to call
the control path.

00:17:31.440 --> 00:17:35.240
Over on the phone side, we make
ViewPresentationActivity also

00:17:35.240 --> 00:17:39.536
implement a
MessageListener interface.

00:17:39.536 --> 00:17:41.160
That means that it's
going to implement

00:17:41.160 --> 00:17:42.118
this onMessageReceived.

00:17:44.310 --> 00:17:47.841
So if it is a control message,
we just take that first byte

00:17:47.841 --> 00:17:50.090
and we decide whether we're
going to advance the slide

00:17:50.090 --> 00:17:52.890
or go to the previous slide.

00:17:52.890 --> 00:17:54.750
When that happens, we
update the ViewPager.

00:17:54.750 --> 00:17:56.990
We just call setCurrentItem
on the ViewPager.

00:17:56.990 --> 00:17:59.750
And then that's going to fire
the OnPageChangeListener, which

00:17:59.750 --> 00:18:02.496
will update the data item and
come all the way back around.

00:18:02.496 --> 00:18:03.870
So this is a really
good pattern.

00:18:03.870 --> 00:18:06.520
You want to make sure that your
data items are sort of owned

00:18:06.520 --> 00:18:08.080
by one of the nodes
in your system.

00:18:08.080 --> 00:18:10.780
In this case, the data
item is owned by the phone.

00:18:10.780 --> 00:18:13.240
We could have tried to edit
it on the wearable side

00:18:13.240 --> 00:18:15.089
and have that synchronize
back and forth.

00:18:15.089 --> 00:18:16.130
That gets a little messy.

00:18:16.130 --> 00:18:20.170
It's much better to do data
item owned buy one of the nodes,

00:18:20.170 --> 00:18:21.910
and then you send
messages to update it,

00:18:21.910 --> 00:18:24.200
and then you just have
this virtuous cycle

00:18:24.200 --> 00:18:26.600
going around and around.

00:18:26.600 --> 00:18:28.840
So as we see here, when
we get our message,

00:18:28.840 --> 00:18:31.700
we are going to just go
back to the previous slide.

00:18:36.000 --> 00:18:40.920
So let's talk a little bit
about extending this use case.

00:18:40.920 --> 00:18:43.666
Now, if I'm giving a
longer presentation,

00:18:43.666 --> 00:18:46.040
it might be good to have this
notification in the stream.

00:18:46.040 --> 00:18:49.420
I want my watch to be able to
timeout back to the home screen

00:18:49.420 --> 00:18:51.040
so I'm not burning power.

00:18:51.040 --> 00:18:53.070
But if I'm giving a
much shorter, a more

00:18:53.070 --> 00:18:55.920
condensed presentation,
I would maybe

00:18:55.920 --> 00:19:01.530
want to control what activity
is on top so that, as a user,

00:19:01.530 --> 00:19:03.760
I can just kind of slide
around and not really

00:19:03.760 --> 00:19:06.110
have to worry about
what I'm doing.

00:19:06.110 --> 00:19:10.280
And to do this, I'm going to
create a custom activity that's

00:19:10.280 --> 00:19:12.320
running on the wearable.

00:19:12.320 --> 00:19:13.750
Let's take a look at that.

00:19:13.750 --> 00:19:17.210
So in the slide we
see we can slide over,

00:19:17.210 --> 00:19:20.670
and we have another action
here called the Full screen.

00:19:20.670 --> 00:19:22.480
And when I tap on it,
I'm going to bring up

00:19:22.480 --> 00:19:25.866
a activity on the wearable
that has a ViewPager.

00:19:25.866 --> 00:19:26.990
And these are synchronized.

00:19:26.990 --> 00:19:30.680
So when I swipe over
here, it's going

00:19:30.680 --> 00:19:33.840
to update the ViewPager
running on the phone.

00:19:33.840 --> 00:19:35.340
It also has some
other things that I

00:19:35.340 --> 00:19:38.350
might want for my presentation
like the current time,

00:19:38.350 --> 00:19:41.800
and maybe I want to go red
when I'm going over time,

00:19:41.800 --> 00:19:44.360
or things like that.

00:19:44.360 --> 00:19:49.590
So let's talk about how to
get this data, the image

00:19:49.590 --> 00:19:51.350
and the titles, over
to the wearable.

00:19:51.350 --> 00:19:53.040
We want to use the data layer.

00:19:53.040 --> 00:19:54.760
We want to do it efficiently.

00:19:54.760 --> 00:19:57.990
We could just keep updating
our state data item,

00:19:57.990 --> 00:20:00.052
but that means that
every time it changes,

00:20:00.052 --> 00:20:01.760
we're going to have
to send all that data

00:20:01.760 --> 00:20:03.670
over and over and over again.

00:20:03.670 --> 00:20:07.262
So instead, I'm going to store
my data in several data items.

00:20:07.262 --> 00:20:09.470
And they're each going to
have their own unique path.

00:20:09.470 --> 00:20:16.230
So it's going to be wear://, the
node ID, then slide/ the index.

00:20:16.230 --> 00:20:19.650
And so you can see here I've
got three different data items.

00:20:19.650 --> 00:20:21.810
And over here on
the wearable, I use

00:20:21.810 --> 00:20:25.347
that to inflate some card
fragments for my activity.

00:20:25.347 --> 00:20:27.430
We're going to call this
the SlideControlActivity.

00:20:30.110 --> 00:20:31.970
So let's see how we do that.

00:20:35.140 --> 00:20:39.960
In our SlideControlActivity,
we have a very simple layout.

00:20:39.960 --> 00:20:41.520
It's just a ViewPager.

00:20:41.520 --> 00:20:43.120
But remember, I
want to make sure

00:20:43.120 --> 00:20:45.990
that this doesn't timeout
to the home screen.

00:20:45.990 --> 00:20:49.510
And I do that by setting
android:keepScreenOn to true.

00:20:49.510 --> 00:20:51.220
Again, just like you
would do on a phone

00:20:51.220 --> 00:20:55.240
if you had some sort of
media playing application.

00:20:55.240 --> 00:20:58.730
Now, remember, with great power
comes great responsibility.

00:20:58.730 --> 00:21:00.632
You want to be kind
to people's batteries.

00:21:00.632 --> 00:21:02.090
You don't want to
be in a situation

00:21:02.090 --> 00:21:04.030
where the user might
accidentally end up

00:21:04.030 --> 00:21:07.550
in this full screen activity
and it doesn't efficiently

00:21:07.550 --> 00:21:08.790
go to sleep.

00:21:08.790 --> 00:21:13.030
So we want to watch out for--
with keepScreenOn, you probably

00:21:13.030 --> 00:21:16.570
want to keep track of
the user's timeout.

00:21:16.570 --> 00:21:18.216
You might want to
make it settable.

00:21:18.216 --> 00:21:19.590
And if the user
hasn't interacted

00:21:19.590 --> 00:21:21.900
with the device for a
certain period of time,

00:21:21.900 --> 00:21:24.450
just finish your activity.

00:21:24.450 --> 00:21:28.260
We also want to key activities
to a user's context.

00:21:28.260 --> 00:21:31.250
So remember, with
PresentationListenerService,

00:21:31.250 --> 00:21:34.940
when the users finished viewing
the slide show on their phone,

00:21:34.940 --> 00:21:36.620
we removed the notification.

00:21:36.620 --> 00:21:40.800
Similarly, when the users
finished viewing the slide show

00:21:40.800 --> 00:21:43.520
on their phone, we also
want to exit this activity

00:21:43.520 --> 00:21:44.930
if it's running.

00:21:44.930 --> 00:21:48.150
And the final note is to
watch out for wakelocks.

00:21:48.150 --> 00:21:50.770
It's very important on wearables
with the smaller battery

00:21:50.770 --> 00:21:53.060
capacity to just
really be cognizant

00:21:53.060 --> 00:21:55.790
of your users' batteries.

00:21:55.790 --> 00:22:01.570
So let's take a look over
here in SlideControlActivity.

00:22:01.570 --> 00:22:04.230
And we've set this
up very much like

00:22:04.230 --> 00:22:06.160
the PresentationListenerService.

00:22:06.160 --> 00:22:08.940
So we've got our
handleStateChanged method here.

00:22:08.940 --> 00:22:11.870
We're going to extract
our presentation data,

00:22:11.870 --> 00:22:14.920
and we're just going to
set the ViewPager that's

00:22:14.920 --> 00:22:17.070
running on the wearable
to be the same index

00:22:17.070 --> 00:22:20.587
as the index on the phone.

00:22:20.587 --> 00:22:22.920
We also want to be able to
control it from the wearable.

00:22:22.920 --> 00:22:24.671
So I create another
OnPageChangedListener,

00:22:24.671 --> 00:22:26.920
and now I'm going to send a
different type of message.

00:22:26.920 --> 00:22:29.560
Instead of that control
forward and backwards message,

00:22:29.560 --> 00:22:31.680
I'm going to send a
new type of message

00:22:31.680 --> 00:22:33.666
on a different
path called slide.

00:22:33.666 --> 00:22:35.290
And here the byte is
just going to say,

00:22:35.290 --> 00:22:39.350
what is the desired index
that I want to have?

00:22:39.350 --> 00:22:43.920
Back on the phone side in
the ViewPresentaionActivity,

00:22:43.920 --> 00:22:49.190
if I see the message coming
in on the slide path,

00:22:49.190 --> 00:22:51.810
then I'm going to parse
that out from the byte,

00:22:51.810 --> 00:22:53.310
and I'm just going
to send it there.

00:22:53.310 --> 00:22:57.070
Once again, I will then trigger
the OnPageChangedListener,

00:22:57.070 --> 00:23:00.240
which will trigger Update Item,
and everything goes around.

00:23:00.240 --> 00:23:02.090
Virtuous cycle.

00:23:02.090 --> 00:23:04.090
And here we see the
results of that.

00:23:07.340 --> 00:23:09.650
There we go.

00:23:09.650 --> 00:23:12.610
So by default, Android
Wear activities

00:23:12.610 --> 00:23:15.130
can be dismissed by
swiping left to right.

00:23:15.130 --> 00:23:17.230
This even works
with our ViewPager.

00:23:17.230 --> 00:23:20.250
If we swipe over a few
times and swipe back,

00:23:20.250 --> 00:23:21.800
everything works
the way you expect.

00:23:21.800 --> 00:23:24.390
When I'm on the first slide,
if I swipe from left to right,

00:23:24.390 --> 00:23:26.419
I'm going to dismiss
that activity.

00:23:26.419 --> 00:23:28.960
But remember, I'm in the middle
of a high stakes presentation

00:23:28.960 --> 00:23:30.668
here, and I don't want
to accidentally do

00:23:30.668 --> 00:23:32.880
that if I'm moving around.

00:23:32.880 --> 00:23:35.440
So when we want to
override that behavior,

00:23:35.440 --> 00:23:36.760
it's definitely possible.

00:23:36.760 --> 00:23:39.050
And it's possible without
a line of Java code.

00:23:39.050 --> 00:23:44.400
It's just updating a style
and your Android manifest.

00:23:44.400 --> 00:23:46.970
So we come over
here, and you create

00:23:46.970 --> 00:23:48.755
a theme in your
application that inherits

00:23:48.755 --> 00:23:51.420
from the device default theme.

00:23:51.420 --> 00:23:54.312
We're still running
KitKat on the wearable,

00:23:54.312 --> 00:23:56.270
and so we don't have
these material themes yet.

00:23:56.270 --> 00:23:58.230
So we're Theme.DeviceDefault.

00:23:58.230 --> 00:24:01.620
You should definitely use
those in your applications.

00:24:01.620 --> 00:24:03.270
We have a new
attribute here called

00:24:03.270 --> 00:24:05.037
android:windowSwipeToDismiss.

00:24:05.037 --> 00:24:06.620
By setting this to
false, you're going

00:24:06.620 --> 00:24:08.860
to do disable that
default behavior of being

00:24:08.860 --> 00:24:11.460
able to swipe an activity away.

00:24:11.460 --> 00:24:13.900
Then I just set that as
my theme in the activity.

00:24:16.660 --> 00:24:19.980
Now, I don't want the user to
get locked into my activity,

00:24:19.980 --> 00:24:20.480
though.

00:24:20.480 --> 00:24:22.200
They should know how to get out.

00:24:22.200 --> 00:24:24.272
By default, all
Android Wear devices,

00:24:24.272 --> 00:24:25.730
you can put your
palm on the screen

00:24:25.730 --> 00:24:29.180
to go back to the home screen,
but that's not necessarily

00:24:29.180 --> 00:24:31.730
as elegant as we'd like to do.

00:24:31.730 --> 00:24:35.380
We'd like to establish a
pattern for these full screen

00:24:35.380 --> 00:24:36.660
applications.

00:24:36.660 --> 00:24:39.095
And what we've come up
with is a long press.

00:24:39.095 --> 00:24:41.034
So when you long
press, we're going

00:24:41.034 --> 00:24:42.482
to bring up this red circle.

00:24:42.482 --> 00:24:44.940
And then if you tap it, we're
going to finish the activity.

00:24:44.940 --> 00:24:48.160
We've created a support class
to make it very easy for you

00:24:48.160 --> 00:24:50.500
to do this in your
own applications.

00:24:50.500 --> 00:24:52.920
So I'm going to
update my layouts,

00:24:52.920 --> 00:24:57.200
and I'm going to create
a DismissOverlayView so

00:24:57.200 --> 00:24:58.850
that it just hangs out on top.

00:24:58.850 --> 00:25:01.880
And it's going to be
hidden by default.

00:25:01.880 --> 00:25:03.670
Over here in
SlideControlActivity,

00:25:03.670 --> 00:25:07.290
I just need to get a
reference to that overlay view

00:25:07.290 --> 00:25:09.420
and then use a GestureDetector.

00:25:09.420 --> 00:25:11.604
I could've used a
long click listener

00:25:11.604 --> 00:25:13.020
if I had a different
type of view,

00:25:13.020 --> 00:25:16.520
but with ViewPager, it's easier
to use a GestureDetector.

00:25:16.520 --> 00:25:18.820
So again, just like
using it on the phone,

00:25:18.820 --> 00:25:20.340
I create a GestureDetector.

00:25:20.340 --> 00:25:22.330
I'm going to feed
motion events to it,

00:25:22.330 --> 00:25:23.990
and when I get the
long press, I'll

00:25:23.990 --> 00:25:25.391
show my DismissOverlayView.

00:25:25.391 --> 00:25:27.890
DismissOverlayView is going to
take care of everything else.

00:25:27.890 --> 00:25:30.440
When the user taps on it, it's
going to exit the activity

00:25:30.440 --> 00:25:31.730
and go back to the stream.

00:25:34.275 --> 00:25:35.650
Final thing we
want to talk about

00:25:35.650 --> 00:25:39.664
are assets-- getting picture
data over to the wearable.

00:25:39.664 --> 00:25:41.080
Obviously, that's
what we're going

00:25:41.080 --> 00:25:44.210
to want to do to create these
rich, awesome experiences

00:25:44.210 --> 00:25:46.150
for our users.

00:25:46.150 --> 00:25:48.790
So everything that
we're doing is

00:25:48.790 --> 00:25:52.880
in the name of
efficiency-- efficiency

00:25:52.880 --> 00:25:55.560
for battery life, et cetera.

00:25:55.560 --> 00:25:59.470
So let's say I had an app
that used a contact photo.

00:25:59.470 --> 00:26:01.206
That's a very common use case.

00:26:01.206 --> 00:26:02.580
And say that
somebody else wanted

00:26:02.580 --> 00:26:05.330
to use that exact
same contact photo.

00:26:05.330 --> 00:26:09.580
Well, we don't want to have
to transmit multiple copies.

00:26:09.580 --> 00:26:13.030
So by putting these assets
into our data layer,

00:26:13.030 --> 00:26:18.330
we will take a hash and
only send one copy over.

00:26:18.330 --> 00:26:20.050
Now on the other
side of the link,

00:26:20.050 --> 00:26:23.140
these applications don't really
know that another application

00:26:23.140 --> 00:26:24.520
was using that same asset.

00:26:24.520 --> 00:26:27.380
They just see it as
their own private copy.

00:26:27.380 --> 00:26:28.730
So it's all secure.

00:26:28.730 --> 00:26:29.400
It's all there.

00:26:29.400 --> 00:26:30.886
It's great.

00:26:30.886 --> 00:26:33.010
We're going to use those
assets with our puppy app,

00:26:33.010 --> 00:26:35.840
although who else is going to
be using pictures of my puppy?

00:26:35.840 --> 00:26:40.220
We're going to want to not send
the full resolution image over,

00:26:40.220 --> 00:26:40.810
however.

00:26:40.810 --> 00:26:45.410
So the resolution on the
Nexus 5 is much higher

00:26:45.410 --> 00:26:46.780
than the one on the wearable.

00:26:46.780 --> 00:26:48.250
So I'm going to want
to make sure that only

00:26:48.250 --> 00:26:49.624
I'm sending the
image data that's

00:26:49.624 --> 00:26:53.590
necessary for display
on a smaller device.

00:26:53.590 --> 00:26:57.530
So to do that, we go into
ViewPresentationActivity.

00:26:57.530 --> 00:27:00.810
And here we're going
to call this function

00:27:00.810 --> 00:27:02.626
for each of the slides
in our presentation.

00:27:02.626 --> 00:27:04.500
I'll probably do this
in an asynchronous task

00:27:04.500 --> 00:27:06.080
when I'm loading it up.

00:27:06.080 --> 00:27:10.770
I'm going to create my
data items at a known URI,

00:27:10.770 --> 00:27:13.270
so in this case slide/index.

00:27:13.270 --> 00:27:14.520
I'm going to put the title in.

00:27:14.520 --> 00:27:16.130
And now I'm going
to create an asset.

00:27:16.130 --> 00:27:19.050
All of my slide objects
know how to create

00:27:19.050 --> 00:27:23.410
a smaller version of themselves,
just as a byte array.

00:27:23.410 --> 00:27:25.750
From there, I send that
to Asset.createFromBytes,

00:27:25.750 --> 00:27:27.230
and I put it into the map.

00:27:27.230 --> 00:27:29.780
And then it's going to
intelligently send that over

00:27:29.780 --> 00:27:31.830
to the wearable.

00:27:31.830 --> 00:27:37.210
On the wearable side in
the SlideControlActivity,

00:27:37.210 --> 00:27:40.390
I'm going to again use an
asynchronous task, or a loader,

00:27:40.390 --> 00:27:41.970
to load this up.

00:27:41.970 --> 00:27:46.000
And here's where we see the
importance of the paths.

00:27:46.000 --> 00:27:49.570
Since I know that it's going
to be wear:// et cetera,

00:27:49.570 --> 00:27:53.640
I can send these URIs around
and build upon them in order

00:27:53.640 --> 00:27:56.710
to derive queries
for these data items.

00:27:56.710 --> 00:27:59.870
And so here I'm going to load
up each of the different data

00:27:59.870 --> 00:28:02.230
items from the data layer.

00:28:02.230 --> 00:28:04.550
I'm going to extract the asset.

00:28:04.550 --> 00:28:07.230
And from those bytes, I'm
going to create a bitmap

00:28:07.230 --> 00:28:10.130
that I can then use
to update my UI.

00:28:10.130 --> 00:28:13.240
And that's what we got.

00:28:13.240 --> 00:28:17.530
So now I'm going to
turn it back to Austin.

00:28:17.530 --> 00:28:18.790
AUSTIN ROBISON: All right.

00:28:18.790 --> 00:28:19.540
Thank you, Justin.

00:28:19.540 --> 00:28:24.230
[APPLAUSE]

00:28:24.230 --> 00:28:27.230
So we hope that's given
you a taste of what's

00:28:27.230 --> 00:28:30.170
possible with these new APIs
and with this new form factor

00:28:30.170 --> 00:28:32.330
and has sparked some
ideas for your own apps,

00:28:32.330 --> 00:28:33.450
or maybe even new apps.

00:28:33.450 --> 00:28:38.320
So we're all very excited to
see what you go and create.

00:28:38.320 --> 00:28:40.290
For more information,
you guys can visit

00:28:40.290 --> 00:28:43.760
developer.android.com/wear,
download the SDK,

00:28:43.760 --> 00:28:44.857
and get started there.

00:28:44.857 --> 00:28:45.690
There's an emulator.

00:28:45.690 --> 00:28:48.530
You can use it with the devices
that you got at the giveaway.

00:28:48.530 --> 00:28:50.710
And you can get started there.

00:28:50.710 --> 00:28:54.000
We also have even more
information about these APIs

00:28:54.000 --> 00:28:55.574
available as I/O Bytes.

00:28:55.574 --> 00:28:56.990
Those are up on
YouTube right now.

00:28:56.990 --> 00:28:58.520
You can go check them out.

00:28:58.520 --> 00:29:01.770
And with that, we will thank
you, and we'll take questions.

00:29:01.770 --> 00:29:05.100
There's microphones right
in the aisle ways here.

00:29:05.100 --> 00:29:05.800
Thank you.

00:29:05.800 --> 00:29:08.800
[APPLAUSE]

00:29:12.770 --> 00:29:13.270
Yes?

00:29:13.270 --> 00:29:18.590
AUDIENCE: You mentioned
that the wearable leverages

00:29:18.590 --> 00:29:20.070
the Google Play services.

00:29:20.070 --> 00:29:21.980
So does this mean
that we can't connect

00:29:21.980 --> 00:29:25.120
to Kindle devices and
that kind of thing?

00:29:25.120 --> 00:29:27.940
AUSTIN ROBISON:
So the connection

00:29:27.940 --> 00:29:30.780
is driven by Google
Play services.

00:29:30.780 --> 00:29:34.600
So we are compatible with
any Android device running

00:29:34.600 --> 00:29:36.843
4.3 or greater with
the Play Store.

00:29:36.843 --> 00:29:37.676
AUDIENCE: Thank you.

00:29:40.167 --> 00:29:41.750
AUSTIN ROBISON: Let's
go to this side.

00:29:41.750 --> 00:29:42.291
AUDIENCE: Hi.

00:29:42.291 --> 00:29:46.140
Is it possible to leave your
custom activity on and let

00:29:46.140 --> 00:29:48.860
the device go to sleep,
or does that automatically

00:29:48.860 --> 00:29:52.400
exit to the home screen when
the wakelock is released?

00:29:52.400 --> 00:29:54.500
JUSTIN KOH: It's going
to automatically time out

00:29:54.500 --> 00:29:57.452
after 30 seconds
to the home screen.

00:29:57.452 --> 00:29:58.160
AUDIENCE: Gotcha.

00:29:58.160 --> 00:30:00.860
So there's no way to
just leave the app on,

00:30:00.860 --> 00:30:02.907
like say you're
doing a presentation,

00:30:02.907 --> 00:30:05.240
and you want to let it go to
sleep while you're talking,

00:30:05.240 --> 00:30:08.334
and then you open up and
then you want to swipe again?

00:30:08.334 --> 00:30:10.250
JUSTIN KOH: So that's
where you would probably

00:30:10.250 --> 00:30:12.437
use the notifications
that we showed

00:30:12.437 --> 00:30:13.520
in the first part of this.

00:30:13.520 --> 00:30:14.470
AUDIENCE: Oh, gotcha.

00:30:14.470 --> 00:30:14.970
Gotcha.

00:30:14.970 --> 00:30:15.880
OK, great.

00:30:15.880 --> 00:30:16.469
Thank you.

00:30:16.469 --> 00:30:17.302
AUSTIN ROBISON: Mhm.

00:30:17.302 --> 00:30:17.802
Over here.

00:30:17.802 --> 00:30:19.690
AUDIENCE: You guys
talked about the watch

00:30:19.690 --> 00:30:22.150
as basically just a
remote control and the UI,

00:30:22.150 --> 00:30:25.610
but what about when the watch
is providing like gyroscope,

00:30:25.610 --> 00:30:30.450
or movements, and heartbeats
and things like that?

00:30:30.450 --> 00:30:33.070
How are you dealing
with sensors?

00:30:33.070 --> 00:30:34.835
JUSTIN KOH: So
remember that it is

00:30:34.835 --> 00:30:36.210
Android running
on this wearable.

00:30:36.210 --> 00:30:39.120
So you register a sensor
listener for the type of sensor

00:30:39.120 --> 00:30:42.730
that you want to consume.

00:30:42.730 --> 00:30:44.132
And then remember
that these APIs

00:30:44.132 --> 00:30:45.840
are callable from both
sides of the link.

00:30:45.840 --> 00:30:48.450
So you can collect sensor
data on the wearable

00:30:48.450 --> 00:30:49.960
and then send it
to your instance

00:30:49.960 --> 00:30:51.376
of your app running
on your phone.

00:30:53.870 --> 00:30:59.280
AUDIENCE: So you mentioned that
you can install discrete apps

00:30:59.280 --> 00:31:01.150
on the phone themselves.

00:31:01.150 --> 00:31:01.650
Right?

00:31:01.650 --> 00:31:05.320
So how do you switch
between app to app?

00:31:05.320 --> 00:31:07.660
Where's the menu, if
you will, or where's

00:31:07.660 --> 00:31:10.330
the listing of all the apps
that you have on your phone?

00:31:10.330 --> 00:31:11.950
AUSTIN ROBISON: So
the UI is really

00:31:11.950 --> 00:31:13.900
designed to be post-grid.

00:31:13.900 --> 00:31:18.550
So it is intentionally
missing that grid of apps.

00:31:18.550 --> 00:31:22.120
So we encourage developers
to think about putting cards

00:31:22.120 --> 00:31:23.850
into that stream
when they're relevant

00:31:23.850 --> 00:31:25.700
or to register
for Voice Actions.

00:31:25.700 --> 00:31:29.120
You can also say, OK,
Google, start app name,

00:31:29.120 --> 00:31:31.354
and be able to bring that
application up on demand.

00:31:31.354 --> 00:31:33.520
You can also get to that
through the cue card, which

00:31:33.520 --> 00:31:36.040
is the touch menu when
you tap on the device.

00:31:36.040 --> 00:31:37.880
AUDIENCE: So just a
follow-up question.

00:31:37.880 --> 00:31:41.110
Are there preset voice
commands, or can you

00:31:41.110 --> 00:31:42.754
define your own voice command?

00:31:42.754 --> 00:31:44.170
AUSTIN ROBISON:
The voice commands

00:31:44.170 --> 00:31:46.230
are part of the platform.

00:31:46.230 --> 00:31:48.390
So on developer.android.com
there's

00:31:48.390 --> 00:31:49.890
some documentation
that can tell you

00:31:49.890 --> 00:31:53.890
how to register for the action
intents that are available.

00:31:53.890 --> 00:31:56.080
We also would love to
hear your suggestions

00:31:56.080 --> 00:32:00.050
for extending those actions
to other phrases or other use

00:32:00.050 --> 00:32:00.709
cases.

00:32:00.709 --> 00:32:01.250
AUDIENCE: OK.

00:32:01.250 --> 00:32:01.880
Thank you.

00:32:01.880 --> 00:32:03.477
AUSTIN ROBISON: Mhm.

00:32:03.477 --> 00:32:05.810
AUDIENCE: So it might be
related to the sensor question.

00:32:05.810 --> 00:32:08.245
Can I get access to
voice time series?

00:32:11.402 --> 00:32:13.110
JUSTIN KOH: For what
sort of application?

00:32:13.110 --> 00:32:14.651
AUDIENCE: Say I want
to record memos.

00:32:18.267 --> 00:32:19.850
JUSTIN KOH: You will
want to make sure

00:32:19.850 --> 00:32:22.020
that the codec is
available on the device.

00:32:22.020 --> 00:32:24.215
And there are
different codecs that

00:32:24.215 --> 00:32:26.350
are available on
these devices than you

00:32:26.350 --> 00:32:28.020
might expect from the phone.

00:32:28.020 --> 00:32:31.510
So what we do for our
voice is we actually

00:32:31.510 --> 00:32:35.350
stream the bytes using the
Message API over to the phone,

00:32:35.350 --> 00:32:38.117
and then use the phone
to process the data.

00:32:38.117 --> 00:32:39.200
Just to be more efficient.

00:32:39.200 --> 00:32:41.302
AUDIENCE: As a developer,
I'm able to do that too?

00:32:41.302 --> 00:32:42.010
JUSTIN KOH: Yeah.

00:32:42.010 --> 00:32:44.530
So you can set up an audio
record and get raw bytes

00:32:44.530 --> 00:32:45.450
and send those.

00:32:45.450 --> 00:32:46.200
AUDIENCE: Perfect.

00:32:46.200 --> 00:32:49.050
AUSTIN ROBISON: You can also,
part of the voice recognition

00:32:49.050 --> 00:32:51.157
intent, if you
just want to record

00:32:51.157 --> 00:32:53.490
and have us do the transcription
to get the string back,

00:32:53.490 --> 00:32:57.640
but if you want the raw bytes,
then you can get the raw bytes.

00:32:57.640 --> 00:33:00.116
JUSTIN KOH: But watch
out for the codecs.

00:33:00.116 --> 00:33:01.000
AUSTIN ROBISON: Yes?

00:33:01.000 --> 00:33:01.541
AUDIENCE: Hi.

00:33:01.541 --> 00:33:03.520
So my question is
about the way you

00:33:03.520 --> 00:33:04.880
instantiate a lot of this stuff.

00:33:04.880 --> 00:33:07.805
Everything you've shown here
touches activities and passes

00:33:07.805 --> 00:33:09.120
in this.

00:33:09.120 --> 00:33:11.110
Notifications tend
to mostly live

00:33:11.110 --> 00:33:12.940
outside the activity
in my mind, right?

00:33:12.940 --> 00:33:15.099
So the context that
your passing into,

00:33:15.099 --> 00:33:16.640
does it have be an
activity, or can I

00:33:16.640 --> 00:33:18.300
run it from a service
or an application?

00:33:18.300 --> 00:33:19.883
JUSTIN KOH: It can
run from a service,

00:33:19.883 --> 00:33:21.397
or yeah, the
application context.

00:33:21.397 --> 00:33:22.980
In fact, using the
application context

00:33:22.980 --> 00:33:23.980
is usually a good thing.

00:33:23.980 --> 00:33:24.640
AUDIENCE: OK.

00:33:24.640 --> 00:33:25.760
So a quick follow-up then.

00:33:25.760 --> 00:33:27.400
Also about the bitmaps.

00:33:27.400 --> 00:33:28.974
I mean, in my
experience, it's always

00:33:28.974 --> 00:33:30.932
been so dangerous to play
with the byte arrays,

00:33:30.932 --> 00:33:32.762
and especially
with BitmapFactory,

00:33:32.762 --> 00:33:34.470
unless you're using
something like Picasa

00:33:34.470 --> 00:33:35.804
to handle a lot of that for you.

00:33:35.804 --> 00:33:37.178
So in your
recommendation, you're

00:33:37.178 --> 00:33:39.030
saying go launch an
AsyncTask to the bitmap

00:33:39.030 --> 00:33:41.890
stuff in the background.

00:33:41.890 --> 00:33:43.460
Is there any
potential that you're

00:33:43.460 --> 00:33:47.050
going to be working towards
offering an actual framework

00:33:47.050 --> 00:33:49.620
around that to help us with
memory management, as opposed

00:33:49.620 --> 00:33:51.910
to us having to rely
on outside sources?

00:33:51.910 --> 00:33:53.660
JUSTIN KOH: Well, on
developer.android.com

00:33:53.660 --> 00:33:56.380
there are a series
of developer articles

00:33:56.380 --> 00:33:58.920
on dealing with large bitmaps.

00:33:58.920 --> 00:34:01.650
For example, using
LRU caches, et cetera.

00:34:01.650 --> 00:34:04.220
And that's our current
recommendation.

00:34:04.220 --> 00:34:04.790
AUDIENCE: OK.

00:34:04.790 --> 00:34:06.800
Thanks.

00:34:06.800 --> 00:34:08.150
AUSTIN ROBISON: Yeah?

00:34:08.150 --> 00:34:11.390
AUDIENCE: So my
question is about Glass.

00:34:11.390 --> 00:34:14.350
Glass kind of seems separate
from all this wearable.

00:34:14.350 --> 00:34:17.305
So if we're targeting Glass
and Android wearables,

00:34:17.305 --> 00:34:20.030
do we need to develop
separately for that?

00:34:20.030 --> 00:34:24.690
And GDK, the Glass SDK,
it seems not as capable

00:34:24.690 --> 00:34:26.739
as this, what we just saw.

00:34:26.739 --> 00:34:28.435
So what's the plan
to reconcile this?

00:34:28.435 --> 00:34:29.310
AUSTIN ROBISON: Sure.

00:34:29.310 --> 00:34:30.495
So the Wear team
and the Glass team

00:34:30.495 --> 00:34:31.730
work very closely together.

00:34:31.730 --> 00:34:33.820
In fact, yesterday we
announced that you'll

00:34:33.820 --> 00:34:36.290
be able to take the
Android Wear notifications,

00:34:36.290 --> 00:34:41.120
so the augmenting APIs, and have
those appear directly on Glass.

00:34:41.120 --> 00:34:43.239
So we're absolutely
working together

00:34:43.239 --> 00:34:46.000
to make sure that we have
a consistent set of APIs

00:34:46.000 --> 00:34:48.746
across all of our
wearables in the company.

00:34:48.746 --> 00:34:50.120
And there'll be
more coming soon.

00:34:50.120 --> 00:34:50.800
AUDIENCE: OK.

00:34:50.800 --> 00:34:54.550
So does Android Studio support
for wearables [INAUDIBLE]

00:34:54.550 --> 00:34:56.290
here in different form factors?

00:34:56.290 --> 00:34:58.450
Is that going to
extend to Glass as well

00:34:58.450 --> 00:35:01.970
so we have one APK
that runs or that

00:35:01.970 --> 00:35:04.630
has components that
support Glass as well?

00:35:04.630 --> 00:35:07.720
JUSTIN KOH: It'll be one
project, multiple APKs.

00:35:07.720 --> 00:35:11.579
And in the slide that I showed,
there is a check box for Glass.

00:35:11.579 --> 00:35:12.120
AUDIENCE: OK.

00:35:12.120 --> 00:35:13.034
Thank you so much.

00:35:13.034 --> 00:35:15.200
JUSTIN KOH: And I forgot
to mention this in my talk,

00:35:15.200 --> 00:35:18.676
but yes, these are going to
be-- all Android projects,

00:35:18.676 --> 00:35:20.050
you can create an
Android library

00:35:20.050 --> 00:35:22.080
project to store shared code.

00:35:22.080 --> 00:35:24.720
So in my example, I have
a presentation object

00:35:24.720 --> 00:35:26.965
and a slide object that
I use on both sides.

00:35:26.965 --> 00:35:29.090
I put that into an Android
library project and link

00:35:29.090 --> 00:35:30.630
both of those from
my phone project

00:35:30.630 --> 00:35:31.838
and from my wearable project.

00:35:34.210 --> 00:35:34.960
AUDIENCE: Hi, yes.

00:35:34.960 --> 00:35:36.640
I was wondering
if there is going

00:35:36.640 --> 00:35:39.350
to be future support
for wearables

00:35:39.350 --> 00:35:43.040
and connecting with Android
TV, or Android Auto,

00:35:43.040 --> 00:35:47.430
other of those components for
connecting devices like that?

00:35:47.430 --> 00:35:50.055
AUSTIN ROBISON: So
the same notifications

00:35:50.055 --> 00:35:52.390
that I just spoke
about Glass will also

00:35:52.390 --> 00:35:53.650
function with Android Auto.

00:35:53.650 --> 00:35:56.130
So we are absolutely
thinking about this

00:35:56.130 --> 00:36:00.220
as a pan-Android compatibility.

00:36:00.220 --> 00:36:02.390
So we definitely are
working very closely

00:36:02.390 --> 00:36:04.220
with all of those other teams.

00:36:04.220 --> 00:36:06.300
We're working towards a
really compelling feature

00:36:06.300 --> 00:36:08.440
that we'll be able to tell
you about in the future.

00:36:08.440 --> 00:36:09.330
JUSTIN KOH: Right.

00:36:09.330 --> 00:36:10.871
I think what's
important to note here

00:36:10.871 --> 00:36:12.900
is that, like we said
yesterday in the keynote,

00:36:12.900 --> 00:36:14.670
the phone is like your brain.

00:36:14.670 --> 00:36:16.237
And so you can
control your phone,

00:36:16.237 --> 00:36:17.820
and then your phone's
driving your TV,

00:36:17.820 --> 00:36:20.254
or it's driving
your car, and that's

00:36:20.254 --> 00:36:21.670
what really links
it all together.

00:36:21.670 --> 00:36:23.200
AUSTIN ROBISON: Yeah?

00:36:23.200 --> 00:36:27.130
AUDIENCE: Are we going to be
able to hard set the sample

00:36:27.130 --> 00:36:29.385
rate and the
sensitivity for the IMU

00:36:29.385 --> 00:36:31.334
that's on the wearable devices?

00:36:31.334 --> 00:36:33.000
JUSTIN KOH: For the
what on the devices?

00:36:33.000 --> 00:36:34.470
AUDIENCE: The IMU.

00:36:34.470 --> 00:36:37.440
Like the accelerometer,
gyroscope, and compass.

00:36:37.440 --> 00:36:39.590
JUSTIN KOH: You can
use the Android APIs

00:36:39.590 --> 00:36:41.870
for setting the update rate.

00:36:41.870 --> 00:36:44.150
AUDIENCE: OK, but I mean
the sensitivity itself.

00:36:44.150 --> 00:36:46.020
Because the gyroscope
and accelerometer

00:36:46.020 --> 00:36:48.300
have different
sensitivities built in,

00:36:48.300 --> 00:36:50.880
and they are indicative
for different sort

00:36:50.880 --> 00:36:52.447
of movement states.

00:36:52.447 --> 00:36:54.280
AUSTIN ROBISON: If you
can do it on a phone,

00:36:54.280 --> 00:36:55.529
you can do it on the wearable.

00:36:55.529 --> 00:36:56.731
AUDIENCE: OK.

00:36:56.731 --> 00:36:57.230
Thanks.

00:36:57.230 --> 00:36:59.214
JUSTIN KOH: Can you
do it on a phone?

00:36:59.214 --> 00:37:00.014
AUDIENCE: No.

00:37:00.014 --> 00:37:00.930
JUSTIN KOH: All right.

00:37:00.930 --> 00:37:02.746
AUSTIN ROBISON: All
right, feature request.

00:37:02.746 --> 00:37:03.245
Yes?

00:37:03.245 --> 00:37:04.740
AUDIENCE: Two small things.

00:37:04.740 --> 00:37:06.514
Can you request
resources directly

00:37:06.514 --> 00:37:07.930
from the internet
on the wearable,

00:37:07.930 --> 00:37:10.820
or are they all just
passed through the device?

00:37:10.820 --> 00:37:13.450
JUSTIN KOH: We recommend passing
it through the data layer.

00:37:13.450 --> 00:37:17.980
And that's because we're
not supporting a full HTP

00:37:17.980 --> 00:37:19.250
stack on the wearable.

00:37:19.250 --> 00:37:20.360
AUDIENCE: I gotcha.

00:37:20.360 --> 00:37:24.100
And do you get screen on, screen
off events from the wearable

00:37:24.100 --> 00:37:24.600
as well?

00:37:24.600 --> 00:37:25.449
JUSTIN KOH: You do.

00:37:25.449 --> 00:37:25.990
AUDIENCE: OK.

00:37:25.990 --> 00:37:27.490
And you could just
register for them

00:37:27.490 --> 00:37:29.770
in the manifest or broadcast
receiver or something?

00:37:29.770 --> 00:37:30.730
JUSTIN KOH: You can.

00:37:30.730 --> 00:37:32.321
What are you trying
to do, though?

00:37:32.321 --> 00:37:34.070
Sounds like you're
trying to do something.

00:37:34.070 --> 00:37:35.230
AUDIENCE: Yeah, I
got an idea brewing.

00:37:35.230 --> 00:37:35.630
JUSTIN KOH: All right.

00:37:35.630 --> 00:37:36.550
AUDIENCE: Let you know after.

00:37:36.550 --> 00:37:37.549
JUSTIN KOH: Sounds good.

00:37:37.549 --> 00:37:38.603
Looking forward to it.

00:37:38.603 --> 00:37:39.086
AUSTIN ROBISON: All right.

00:37:39.086 --> 00:37:39.570
Yeah?

00:37:39.570 --> 00:37:41.403
AUDIENCE: What do you
recommend for testing?

00:37:41.403 --> 00:37:43.980
Will Espresso have support for
wearable for automated testing

00:37:43.980 --> 00:37:44.896
or anything like that?

00:37:44.896 --> 00:37:47.640
Or is there something coming up?

00:37:47.640 --> 00:37:49.860
JUSTIN KOH: Is that like
a UI automation package?

00:37:49.860 --> 00:37:52.470
AUDIENCE: Yeah, the Espresso
and things like that.

00:37:52.470 --> 00:37:55.290
JUSTIN KOH: We do use
uiautomators in our testing

00:37:55.290 --> 00:37:55.790
internally.

00:37:55.790 --> 00:37:58.750
So any of the same
tools that would

00:37:58.750 --> 00:38:01.400
work on a phone or a tablet
would work on the wearable.

00:38:01.400 --> 00:38:03.483
AUDIENCE: Do you need have
both the phone emulator

00:38:03.483 --> 00:38:06.114
and the wearable running
or just one of them?

00:38:06.114 --> 00:38:07.530
JUSTIN KOH: You
mean if you wanted

00:38:07.530 --> 00:38:09.080
to set up like an
integration test

00:38:09.080 --> 00:38:10.650
with like phone
talking to wearable?

00:38:10.650 --> 00:38:12.950
AUDIENCE: [INAUDIBLE]
What do you guys recommend

00:38:12.950 --> 00:38:15.375
for testing, I guess,
for those kind of things?

00:38:15.375 --> 00:38:17.500
AUSTIN ROBISON: So there's
a couple different ways.

00:38:17.500 --> 00:38:20.680
You can, with the
SDK, have your phone

00:38:20.680 --> 00:38:22.289
connected to your
computer over USB.

00:38:22.289 --> 00:38:23.830
That can either then
be communicating

00:38:23.830 --> 00:38:26.900
with a wearable emulator, which
is a really good testing set

00:38:26.900 --> 00:38:29.040
up, or you can have
it then communicating

00:38:29.040 --> 00:38:31.590
with a real device, as well,
that can be connected over ADB.

00:38:31.590 --> 00:38:35.780
So the support of having all
of those different devices

00:38:35.780 --> 00:38:37.497
in different states
is there in the SDK.

00:38:37.497 --> 00:38:38.330
AUDIENCE: All right.

00:38:38.330 --> 00:38:39.630
Thank you.

00:38:39.630 --> 00:38:40.620
AUSTIN ROBISON: Yes?

00:38:40.620 --> 00:38:41.990
AUDIENCE: Do you have
a way to stream audio

00:38:41.990 --> 00:38:43.820
directly from the
wearable to the phone?

00:38:43.820 --> 00:38:46.650
So if I want to make a
telephony app, I can do that?

00:38:46.650 --> 00:38:50.220
JUSTIN KOH: Well, in the devices
that we announced yesterday,

00:38:50.220 --> 00:38:51.230
there are no speakers.

00:38:51.230 --> 00:38:55.310
So you'd only be able to talk
but not get anything back.

00:38:55.310 --> 00:38:58.180
But I think there was an earlier
question about getting access

00:38:58.180 --> 00:38:59.084
to the raw bytes.

00:38:59.084 --> 00:38:59.750
AUDIENCE: Right.

00:38:59.750 --> 00:39:02.140
But that won't be streaming.

00:39:02.140 --> 00:39:03.267
Or can it be streamed?

00:39:03.267 --> 00:39:04.600
JUSTIN KOH: Through [INAUDIBLE]?

00:39:04.600 --> 00:39:06.710
We are streaming
in our application,

00:39:06.710 --> 00:39:07.750
using the Message API.

00:39:07.750 --> 00:39:08.530
AUDIENCE: OK.

00:39:08.530 --> 00:39:09.050
That's it.

00:39:09.050 --> 00:39:10.037
Thank you.

00:39:10.037 --> 00:39:10.870
AUSTIN ROBISON: Yes?

00:39:10.870 --> 00:39:12.620
AUDIENCE: Could you
talk a little bit more

00:39:12.620 --> 00:39:15.390
about the existing new voice
commands and the process

00:39:15.390 --> 00:39:17.130
will be for applying
for voice commands?

00:39:17.130 --> 00:39:19.160
I was just trying to
check it out online,

00:39:19.160 --> 00:39:22.210
and one of your voice
command pages gives a 404.

00:39:22.210 --> 00:39:23.960
AUSTIN ROBISON:
The developer pages

00:39:23.960 --> 00:39:26.090
are being updated
right now, or at least

00:39:26.090 --> 00:39:29.006
they were before I got on stage.

00:39:29.006 --> 00:39:30.380
There's a page on
there that will

00:39:30.380 --> 00:39:32.840
list all of the
platform intents.

00:39:32.840 --> 00:39:34.600
So there are I
think about a dozen

00:39:34.600 --> 00:39:37.110
in there that support
things from call

00:39:37.110 --> 00:39:39.930
a car, to start a
run, to take a note.

00:39:39.930 --> 00:39:42.840
You register for those as you
register for any other intent.

00:39:42.840 --> 00:39:44.650
If you'd like to
request more of them,

00:39:44.650 --> 00:39:47.300
you can either speak with
your dev rel representative,

00:39:47.300 --> 00:39:49.410
or you can go to
the G+ community,

00:39:49.410 --> 00:39:52.430
where we'll have a form that
you can fill out to request

00:39:52.430 --> 00:39:53.910
additional Voice Actions.

00:39:53.910 --> 00:39:56.560
So that's +Android
Wear Developers.

00:39:56.560 --> 00:39:58.810
AUDIENCE: So is that going
to be the same set of Voice

00:39:58.810 --> 00:40:01.140
Actions we have
on Glass as well?

00:40:01.140 --> 00:40:02.655
Because they have
their own voice

00:40:02.655 --> 00:40:03.821
command application process.

00:40:03.821 --> 00:40:04.490
Is that--

00:40:04.490 --> 00:40:06.156
AUSTIN ROBISON: Today
they are separate.

00:40:06.156 --> 00:40:07.064
AUDIENCE: OK.

00:40:07.064 --> 00:40:07.564
Thank you.

00:40:07.564 --> 00:40:08.949
AUSTIN ROBISON: Mhm.

00:40:08.949 --> 00:40:09.490
AUDIENCE: Hi.

00:40:09.490 --> 00:40:11.926
What is the AOSP story
for Android Wear?

00:40:11.926 --> 00:40:13.676
AUSTIN ROBISON: You
want to take that one?

00:40:13.676 --> 00:40:14.142
You know that one?

00:40:14.142 --> 00:40:15.267
All right, I know that one.

00:40:15.267 --> 00:40:16.820
OK.

00:40:16.820 --> 00:40:22.320
So the parts of Android Wear
that are built on top of KitKat

00:40:22.320 --> 00:40:24.600
and are built on top of
the existing AOSP parts

00:40:24.600 --> 00:40:27.490
will be open source, just like
any other release of Android.

00:40:27.490 --> 00:40:30.280
The Google Play services and
our proprietary first party apps

00:40:30.280 --> 00:40:32.810
will not be open source, so
it's just like on the phone.

00:40:32.810 --> 00:40:35.970
AUDIENCE: So I won't be able to
build my own AOSP-based phone?

00:40:35.970 --> 00:40:36.714
Watch, I mean.

00:40:36.714 --> 00:40:37.713
AUSTIN ROBISON: Correct.

00:40:37.713 --> 00:40:38.546
AUDIENCE: Thank you.

00:40:40.940 --> 00:40:43.340
AUDIENCE: Hi, so I think
this is great stuff,

00:40:43.340 --> 00:40:46.200
and I appreciate the fact
that Google is thinking

00:40:46.200 --> 00:40:49.880
about disconnecting
people from their devices

00:40:49.880 --> 00:40:53.140
just so they can be
more human, basically.

00:40:53.140 --> 00:40:56.930
But my question is this kind
of variable stuff still needs

00:40:56.930 --> 00:41:00.030
the phone to be in proximity.

00:41:00.030 --> 00:41:03.520
I want to know what happens if
the phone is not in proximity.

00:41:03.520 --> 00:41:07.430
So one scenario would be let's
say I want to go for a run.

00:41:07.430 --> 00:41:09.500
And I don't care about
taking calls or anything

00:41:09.500 --> 00:41:12.090
at that point, but if a
friend texts me and says,

00:41:12.090 --> 00:41:14.660
hey, I'm going to run
late for the next thing,

00:41:14.660 --> 00:41:16.310
then I might want to see that.

00:41:16.310 --> 00:41:18.580
Or might want to reply
that, hey, OK, I'm

00:41:18.580 --> 00:41:20.810
going to take a longer
run, in that case.

00:41:20.810 --> 00:41:21.440
Whatever.

00:41:21.440 --> 00:41:23.530
So how does that
interaction happen

00:41:23.530 --> 00:41:26.060
and if there is room
to do that right now,

00:41:26.060 --> 00:41:28.220
or if there is a
plan for future?

00:41:28.220 --> 00:41:29.720
AUSTIN ROBISON: So
today the devices

00:41:29.720 --> 00:41:31.080
use Bluetooth for connectivity.

00:41:31.080 --> 00:41:34.410
So when you are out of
Bluetooth range with your phone,

00:41:34.410 --> 00:41:37.110
then you have no connectivity,
but you can still

00:41:37.110 --> 00:41:39.230
access the data items that
are in your data store.

00:41:39.230 --> 00:41:41.790
For example, you can
still do a few actions

00:41:41.790 --> 00:41:43.780
on the device itself
through touch.

00:41:43.780 --> 00:41:46.150
In the future, we
definitely think

00:41:46.150 --> 00:41:50.380
about a connected constellation
of devices on your body.

00:41:50.380 --> 00:41:53.610
So in the future, we
will explore this.

00:41:53.610 --> 00:41:55.910
I think that's the direction
that the industry's going

00:41:55.910 --> 00:41:57.690
in-- more and more connectivity.

00:41:57.690 --> 00:41:59.482
There are power trade-offs
to be made here.

00:41:59.482 --> 00:42:01.565
But it's definitely something
that we think about.

00:42:01.565 --> 00:42:02.340
AUDIENCE: OK.

00:42:02.340 --> 00:42:04.060
So just one question.

00:42:04.060 --> 00:42:06.650
I mean, you said we can still
do a few things when it's out

00:42:06.650 --> 00:42:08.760
of Bluetooth range,
but whatever I

00:42:08.760 --> 00:42:10.640
do it's not going to--
I mean, if I, say,

00:42:10.640 --> 00:42:13.767
send a text to someone, it's
not going to actually send it

00:42:13.767 --> 00:42:15.350
because it can't
connect to the phone.

00:42:15.350 --> 00:42:16.150
JUSTIN KOH: That's correct.

00:42:16.150 --> 00:42:16.775
AUDIENCE: Yeah.

00:42:16.775 --> 00:42:17.360
OK, awesome.

00:42:17.360 --> 00:42:18.170
Thank you.

00:42:18.170 --> 00:42:19.310
AUSTIN ROBISON: Mhm.

00:42:19.310 --> 00:42:21.770
AUDIENCE: Yeah, so
following on the HTP stack,

00:42:21.770 --> 00:42:25.630
I know this is basically an
Android Wear OEM agreement as

00:42:25.630 --> 00:42:28.930
far as things like hardware
they have to support.

00:42:28.930 --> 00:42:33.460
Are you guys going to
release-- can we expect a GPS?

00:42:33.460 --> 00:42:35.870
I know heart rate is going
to be on some devices

00:42:35.870 --> 00:42:37.850
but not on others.

00:42:37.850 --> 00:42:40.610
I'm just curious as to what
specific hardware is going

00:42:40.610 --> 00:42:44.312
to be guaranteed in every
Wear-compatible device.

00:42:44.312 --> 00:42:46.020
AUSTIN ROBISON: So in
the beginning here,

00:42:46.020 --> 00:42:49.550
having the accelerometer
IMU package is part of it.

00:42:49.550 --> 00:42:51.330
The heart rate is
part of the platform.

00:42:51.330 --> 00:42:53.420
It is optional.

00:42:53.420 --> 00:42:55.830
And in the future, we will
be narrowing that down

00:42:55.830 --> 00:42:57.379
and releasing more information.

00:42:57.379 --> 00:42:57.920
AUDIENCE: OK.

00:42:57.920 --> 00:43:00.600
Is there anything you can
mention today as far as GPS?

00:43:00.600 --> 00:43:01.100
AUSTIN ROBISON: Not today.

00:43:01.100 --> 00:43:01.710
AUDIENCE: Not today.

00:43:01.710 --> 00:43:02.010
All right.

00:43:02.010 --> 00:43:02.630
Thank you.

00:43:02.630 --> 00:43:02.780
JUSTIN KOH: All right.

00:43:02.780 --> 00:43:03.740
Last question, I think.

00:43:03.740 --> 00:43:06.040
We're getting the
wrap it up signal.

00:43:06.040 --> 00:43:09.520
AUDIENCE: You're going
to post the puppy app?

00:43:09.520 --> 00:43:10.255
JUSTIN KOH: Yes.

00:43:10.255 --> 00:43:12.330
I need to finish it.

00:43:12.330 --> 00:43:14.130
I want to.

00:43:14.130 --> 00:43:15.880
AUDIENCE: It's a good
point to start from.

00:43:15.880 --> 00:43:16.559
Thanks.

00:43:16.559 --> 00:43:18.100
JUSTIN KOH: We have
plenty of samples

00:43:18.100 --> 00:43:21.010
as well, like with different
parts of the puppy app.

00:43:21.010 --> 00:43:22.760
The puppy app kind of
draws them together,

00:43:22.760 --> 00:43:25.980
but we have samples written by
some of our great team members

00:43:25.980 --> 00:43:28.080
sitting here in
the front row which

00:43:28.080 --> 00:43:30.530
will be targeted at some
of the different things

00:43:30.530 --> 00:43:31.720
that we're doing.

00:43:31.720 --> 00:43:31.920
AUSTIN ROBISON: All right.

00:43:31.920 --> 00:43:32.777
Last last question.

00:43:32.777 --> 00:43:34.110
JUSTIN KOH: Super last question.

00:43:34.110 --> 00:43:37.007
AUDIENCE: You mentioned no
speakers on their thing,

00:43:37.007 --> 00:43:39.090
but I'm wondering if you
guys have integrated talk

00:43:39.090 --> 00:43:41.560
back so that it could
work on a device that

00:43:41.560 --> 00:43:43.857
does have a headphone input.

00:43:43.857 --> 00:43:44.940
AUSTIN ROBISON: Not today.

00:43:44.940 --> 00:43:47.791
AUDIENCE: Will you be planning
on any kind of accessibility?

00:43:47.791 --> 00:43:49.540
AUSTIN ROBISON:
Accessiblity is definitely

00:43:49.540 --> 00:43:51.581
something that is very
important to the platform,

00:43:51.581 --> 00:43:53.830
and we'll be improving upon
that in future releases.

00:43:53.830 --> 00:43:54.250
AUDIENCE: OK.

00:43:54.250 --> 00:43:54.670
JUSTIN KOH: All right.

00:43:54.670 --> 00:43:55.430
AUSTIN ROBISON: All right.

00:43:55.430 --> 00:43:55.850
JUSTIN KOH: Thanks, everybody.

00:43:55.850 --> 00:43:57.391
AUSTIN ROBISON:
Thank you, everybody.

00:43:57.391 --> 00:43:59.410
[APPLAUSE]

