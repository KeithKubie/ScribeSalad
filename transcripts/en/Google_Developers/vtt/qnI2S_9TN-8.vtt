WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:02.495
[MUSIC PLAYING]

00:00:08.990 --> 00:00:11.262
THOMAS STEINER:
[NON-ENGLISH SPEECH]

00:00:16.390 --> 00:00:18.280
My name is Thomas Steiner.

00:00:18.280 --> 00:00:20.440
I'm based out of the
Hamburg, Germany office.

00:00:20.440 --> 00:00:24.850
And I work on mobile web stuff,
m mostly with big partners.

00:00:24.850 --> 00:00:28.070
And with me today is my
guest speaker, Steven.

00:00:28.070 --> 00:00:30.560
Steven, do you want to come
up and introduce yourself?

00:00:30.560 --> 00:00:31.934
STEVEN SONEFF:
Hi, so I'm Steven.

00:00:31.934 --> 00:00:33.930
I'm a product manager
at Google in California.

00:00:33.930 --> 00:00:36.280
And I'm just visiting, guest
speaking today on the topic

00:00:36.280 --> 00:00:39.367
of identity and authentication
on the mobile web.

00:00:39.367 --> 00:00:40.450
THOMAS STEINER: Thank you.

00:00:44.550 --> 00:00:46.230
So today, we want
to show you what's

00:00:46.230 --> 00:00:50.280
next for the web, or as
an alternative title,

00:00:50.280 --> 00:00:53.550
exploring about flags.

00:00:53.550 --> 00:00:57.570
But before we get started,
here's a fair warning.

00:00:57.570 --> 00:00:59.090
There's a lot of content coming.

00:00:59.090 --> 00:01:02.740
And I'm going to speak fast,
probably even too fast.

00:01:02.740 --> 00:01:05.550
So hold onto your seats.

00:01:05.550 --> 00:01:08.640
And especially, watch
out for all the links.

00:01:08.640 --> 00:01:10.470
So many of the
slides have links.

00:01:10.470 --> 00:01:13.830
And of course, you can just
snap a photo of the slide,

00:01:13.830 --> 00:01:18.460
so you can look up some of the
content after the presentation.

00:01:18.460 --> 00:01:19.740
So let's get going.

00:01:19.740 --> 00:01:20.900
Let's get started.

00:01:20.900 --> 00:01:23.820
Our first big topic area
is Progressive Web Apps,

00:01:23.820 --> 00:01:25.090
or short PWAs.

00:01:28.110 --> 00:01:31.680
Let me show you how you
can, with PWAs, create

00:01:31.680 --> 00:01:33.720
immersive, full-screen
experiences.

00:01:33.720 --> 00:01:38.250
Because your apps deserve a
lot of screen real estate.

00:01:38.250 --> 00:01:43.830
So some of you may remember
from I/O 2016, the Paper Planes

00:01:43.830 --> 00:01:45.460
World app.

00:01:45.460 --> 00:01:48.420
It's actually still up
at paperplanes.world.

00:01:48.420 --> 00:01:51.900
If you go online, you
can test this app.

00:01:51.900 --> 00:01:55.600
If you launch this application,
you might notice something.

00:01:55.600 --> 00:01:56.640
This is a web app.

00:01:56.640 --> 00:01:59.990
But if you look at
the screen at the top,

00:01:59.990 --> 00:02:03.720
there is no network signal,
no clock, no battery status

00:02:03.720 --> 00:02:05.030
indication.

00:02:05.030 --> 00:02:09.250
It's a true fully immersive,
full-screen experience.

00:02:09.250 --> 00:02:11.940
And it can do this by
setting the display

00:02:11.940 --> 00:02:14.610
property in your web app
manifest to the value

00:02:14.610 --> 00:02:16.680
of full screen--

00:02:16.680 --> 00:02:21.360
pretty new, very exciting
for game developers.

00:02:21.360 --> 00:02:25.560
And yeah, hopefully, you try
it out for your application.

00:02:25.560 --> 00:02:27.500
For PWAs, we also
have an improved add

00:02:27.500 --> 00:02:29.400
to homescreen experience.

00:02:29.400 --> 00:02:32.790
Many users install
the PWA, they will not

00:02:32.790 --> 00:02:36.270
be able to find PWAs in
the Android app drawer,

00:02:36.270 --> 00:02:39.130
just within all your
other native applications.

00:02:39.130 --> 00:02:42.300
So they look, and
behave, and finally,

00:02:42.300 --> 00:02:44.880
react as true
native applications.

00:02:44.880 --> 00:02:46.380
So you can just
search for your app,

00:02:46.380 --> 00:02:48.970
find it in your app drawer.

00:02:48.970 --> 00:02:51.270
And there's something
that a lot of developers

00:02:51.270 --> 00:02:52.830
have really been
looking forward to.

00:02:52.830 --> 00:02:57.300
You can now also update the icon
and change the application name

00:02:57.300 --> 00:02:59.580
after your application
is installed.

00:02:59.580 --> 00:03:01.650
And something that's
really cool as well

00:03:01.650 --> 00:03:04.590
is, with the improved
flow, you can now,

00:03:04.590 --> 00:03:07.230
based on the scope
attribute that [INAUDIBLE]

00:03:07.230 --> 00:03:13.830
in the Web App Manifest, create
an Android intent filter that

00:03:13.830 --> 00:03:17.100
allows you to react
whenever your URL pattern

00:03:17.100 --> 00:03:19.440
within the scope is hit.

00:03:19.440 --> 00:03:25.644
So your application can just
open directly whenever it is

00:03:25.644 --> 00:03:27.810
being mentioned-- somewhere
in a chat, for example--

00:03:27.810 --> 00:03:32.790
and then directly go
into the PWA experience.

00:03:32.790 --> 00:03:34.680
The next thing is
the Web Share API.

00:03:34.680 --> 00:03:38.250
Because we all do know
that sharing is caring.

00:03:38.250 --> 00:03:43.920
And if you want to do that on
pretty much any site in 2017,

00:03:43.920 --> 00:03:46.299
you end up with an
experience like the one

00:03:46.299 --> 00:03:47.590
that you can see on this slide.

00:03:47.590 --> 00:03:51.000
So a lot of screen real
estate is, in a sense,

00:03:51.000 --> 00:03:54.000
wasted for all these
sharing buttons.

00:03:54.000 --> 00:03:57.240
And of course, looking at the
sharing buttons, all this,

00:03:57.240 --> 00:04:00.910
the one social network that you
actually would want to share on

00:04:00.910 --> 00:04:02.550
is not on the list.

00:04:02.550 --> 00:04:05.070
And as we have seen
in the previous slide

00:04:05.070 --> 00:04:07.290
with the full-screen
experience, sometimes

00:04:07.290 --> 00:04:09.300
also just the URL bar is hidden.

00:04:09.300 --> 00:04:13.590
So you need a different way
of sharing your application.

00:04:13.590 --> 00:04:16.930
And this brings me
to the Web Share API.

00:04:16.930 --> 00:04:21.060
It's directly integrated with
the native Android sharing

00:04:21.060 --> 00:04:22.830
dialog, which is really cool.

00:04:22.830 --> 00:04:27.540
Because there, you have
a truly native experience

00:04:27.540 --> 00:04:29.500
of sharing your content.

00:04:29.500 --> 00:04:31.110
So if you look at
this code snippet,

00:04:31.110 --> 00:04:33.810
it's very short,
navigator.share.

00:04:33.810 --> 00:04:36.000
And then it can give a title.

00:04:36.000 --> 00:04:37.530
You can give a text.

00:04:37.530 --> 00:04:38.910
And you can give a URL.

00:04:38.910 --> 00:04:41.520
And this allows it to
change the URL that

00:04:41.520 --> 00:04:42.910
is displayed on the screen.

00:04:42.910 --> 00:04:46.110
So for example, when
you think of something

00:04:46.110 --> 00:04:49.710
that is hosted somewhere
or embedded in an AppCache,

00:04:49.710 --> 00:04:52.020
for example.

00:04:52.020 --> 00:04:54.570
The next topic is
push notifications.

00:04:54.570 --> 00:04:58.830
And actually, the next thing
is most interesting or only

00:04:58.830 --> 00:05:01.170
interesting for macOS users.

00:05:01.170 --> 00:05:04.380
Because finally, on
macOS, the notifications

00:05:04.380 --> 00:05:08.190
are integrated directly in
the native system Notification

00:05:08.190 --> 00:05:08.830
Center.

00:05:08.830 --> 00:05:11.440
So they'll no longer
feel like strangers.

00:05:11.440 --> 00:05:14.220
They're now just
native notifications,

00:05:14.220 --> 00:05:18.090
which also means they respect
your devices or your system's

00:05:18.090 --> 00:05:20.380
do not disturb setting,
which is super,

00:05:20.380 --> 00:05:21.900
super powerful, of course.

00:05:21.900 --> 00:05:23.520
Because you don't
want to be disturbed

00:05:23.520 --> 00:05:26.680
by notifications when you give
a presentation, for example.

00:05:26.680 --> 00:05:30.040
So now, finally,
this is possible.

00:05:30.040 --> 00:05:32.910
So the next topic is kind
of an interesting topic.

00:05:32.910 --> 00:05:36.420
Some companies ship down
3 megabytes of image data

00:05:36.420 --> 00:05:38.860
and then shrink it down
on the client side.

00:05:38.860 --> 00:05:44.560
And other companies have
worries about performance

00:05:44.560 --> 00:05:47.520
of the service worker,
so service work boot

00:05:47.520 --> 00:05:48.690
time being too long.

00:05:48.690 --> 00:05:52.680
So this is pretty
exciting new API--

00:05:52.680 --> 00:05:56.200
or it's an origin
trial, actually--

00:05:56.200 --> 00:05:57.840
navigation preload.

00:05:57.840 --> 00:06:03.160
What this does is
it kind of makes

00:06:03.160 --> 00:06:06.250
the time where the
service worker boots up

00:06:06.250 --> 00:06:10.660
not waiting time, but parallel
time that your app can already

00:06:10.660 --> 00:06:12.740
use for a navigation request.

00:06:12.740 --> 00:06:16.810
So if you look at
this little diagram

00:06:16.810 --> 00:06:20.300
here down at the
bottom of the slide,

00:06:20.300 --> 00:06:22.800
you can see the service
of the boot time before

00:06:22.800 --> 00:06:26.630
and the service of the boot time
after this trial is activated.

00:06:26.630 --> 00:06:29.000
So you can see, it's
running in parallel.

00:06:29.000 --> 00:06:30.950
So the request can
already happen.

00:06:30.950 --> 00:06:32.290
So how do you use that?

00:06:32.290 --> 00:06:36.160
If you look at this code, you
can see, there's two events--

00:06:36.160 --> 00:06:38.080
the activate event
and the fetch event.

00:06:38.080 --> 00:06:41.650
In the activate event, with
his highlighted yellow line,

00:06:41.650 --> 00:06:45.420
waitselfregistra
tionnavigationpreload.enable,

00:06:45.420 --> 00:06:48.970
you enable navigation preload.

00:06:48.970 --> 00:06:51.040
And then in your fetch
listener, after going

00:06:51.040 --> 00:06:55.870
through the chain of, do I
have the cached response,

00:06:55.870 --> 00:06:59.680
no or yes, you can then
check if maybe there

00:06:59.680 --> 00:07:02.530
is a preloaded response
available that you can then

00:07:02.530 --> 00:07:04.030
directly ship to the user.

00:07:04.030 --> 00:07:08.290
So this allows you to get
content to the user faster

00:07:08.290 --> 00:07:13.780
without waiting time for
the service worker to boot.

00:07:13.780 --> 00:07:19.120
On mobile, you now have a pretty
exciting new way of signing up.

00:07:19.120 --> 00:07:21.460
And for this, let me
bring Steven on stage.

00:07:21.460 --> 00:07:23.380
STEVEN SONEFF: OK,
thanks, Thomas.

00:07:23.380 --> 00:07:27.790
So what we'll talk
about here is one part

00:07:27.790 --> 00:07:30.510
of the experience of
building a mobile web

00:07:30.510 --> 00:07:31.916
app that is often frustrating.

00:07:31.916 --> 00:07:33.040
And it's only a small part.

00:07:33.040 --> 00:07:36.140
But it's often a big problem
that developers encounter.

00:07:36.140 --> 00:07:38.290
And it's how to get people
signed in and signed up

00:07:38.290 --> 00:07:39.862
on such a small screen.

00:07:39.862 --> 00:07:41.320
You've probably
all had experiences

00:07:41.320 --> 00:07:43.090
that looked like
this before, where

00:07:43.090 --> 00:07:46.110
you have to remember a
username, password, type it

00:07:46.110 --> 00:07:47.452
in on a mobile keyboard.

00:07:47.452 --> 00:07:48.910
And perhaps, you've
added something

00:07:48.910 --> 00:07:51.740
like Google Sign-In or
Facebook Login to your app.

00:07:51.740 --> 00:07:52.990
But there are people using it.

00:07:52.990 --> 00:07:55.150
There's always been
a concern about what

00:07:55.150 --> 00:07:58.520
data gets shared, how these
work on a mobile browser,

00:07:58.520 --> 00:08:00.369
and how you'll end
up back on the site.

00:08:00.369 --> 00:08:02.410
So what my team has been
thinking about at Google

00:08:02.410 --> 00:08:04.669
is ways to improve
this experience

00:08:04.669 --> 00:08:06.460
for the mobile browsers
that are out there.

00:08:06.460 --> 00:08:08.740
And what we are
working on right now

00:08:08.740 --> 00:08:11.050
is a new and unreleased API.

00:08:11.050 --> 00:08:13.450
It adds an I-frame
to your mobile site,

00:08:13.450 --> 00:08:17.730
where you can offer a one-tap
sign up or sign in experience.

00:08:17.730 --> 00:08:19.300
This gets someone
in to your site

00:08:19.300 --> 00:08:22.870
or signed up through
checkout or conversion flows

00:08:22.870 --> 00:08:24.880
with as little
friction as possible.

00:08:24.880 --> 00:08:27.340
And as a new thing, we'd
love to hear the feedback

00:08:27.340 --> 00:08:30.280
from developers like you on how
this might fit into your site.

00:08:30.280 --> 00:08:32.620
So check out the link
or send me an email.

00:08:32.620 --> 00:08:35.169
Stick around for questions
after to discuss more.

00:08:35.169 --> 00:08:38.000
And send us feedback on this
part of the mobile experience.

00:08:38.000 --> 00:08:38.500
Thank you.

00:08:42.679 --> 00:08:45.200
THOMAS STEINER: So
how can you use that?

00:08:45.200 --> 00:08:49.650
Essentially, there's two
API calls that you can make.

00:08:49.650 --> 00:08:53.080
For auto sign in, you can
use smartlog.retrieve.

00:08:53.080 --> 00:08:57.330
And for auto sign up, you
can use a smartlog.hint

00:08:57.330 --> 00:08:59.065
with a couple of
configuration things.

00:08:59.065 --> 00:09:00.440
So as I said,
you're not supposed

00:09:00.440 --> 00:09:03.170
to understand this code
in this short time.

00:09:03.170 --> 00:09:06.860
This is just for you to
get an idea about what

00:09:06.860 --> 00:09:09.180
will be possible pretty soon.

00:09:09.180 --> 00:09:13.800
So let's get back
to PWAs in general.

00:09:13.800 --> 00:09:16.460
A question that we get a lot
when people develop a PWA

00:09:16.460 --> 00:09:20.840
and we talk about cache as well,
what even am I allowed to use?

00:09:20.840 --> 00:09:23.120
Like, how much
storage do I have?

00:09:23.120 --> 00:09:27.440
Or if they already have a cache
and it's full with content

00:09:27.440 --> 00:09:31.100
or somewhat full with content,
they're wondering about,

00:09:31.100 --> 00:09:34.560
how much of my cache I'm
actually already using?

00:09:34.560 --> 00:09:37.130
So with the new
Storage Estimation API,

00:09:37.130 --> 00:09:38.960
you can now find out.

00:09:38.960 --> 00:09:43.670
So you just very easily call
navigator.storage.estimate.

00:09:43.670 --> 00:09:45.620
And then when the
promise fulfills,

00:09:45.620 --> 00:09:49.160
you get data about how much
storage you're already using

00:09:49.160 --> 00:09:52.040
and how much storage
is available in total.

00:09:52.040 --> 00:09:57.390
So super useful feature,
a long time thing that was

00:09:57.390 --> 00:10:02.000
awaited very, very eagerly
by developers of PWA.

00:10:02.000 --> 00:10:04.970
So let's move on to the
next big topic area, which

00:10:04.970 --> 00:10:07.100
is media-related APIs.

00:10:07.100 --> 00:10:09.260
Media on the web
is very exciting.

00:10:09.260 --> 00:10:11.450
And the first API that
I want to talk about

00:10:11.450 --> 00:10:14.150
is the Image Capture
API, because you should

00:10:14.150 --> 00:10:17.580
be zooming in on what matters.

00:10:17.580 --> 00:10:21.300
So on the screenshot, you can
see what matters is my face.

00:10:21.300 --> 00:10:24.960
So I'm zooming in on my face
in this stupid animation

00:10:24.960 --> 00:10:26.870
that I created for this slide.

00:10:26.870 --> 00:10:30.120
So this API allows you to
actually natively zoom in.

00:10:30.120 --> 00:10:33.370
And so this is not
software-enlarged.

00:10:33.370 --> 00:10:36.000
This is a native
zoom of the camera.

00:10:36.000 --> 00:10:41.850
And you can use this
directly from your browser.

00:10:41.850 --> 00:10:43.570
And this is how you do it.

00:10:43.570 --> 00:10:47.880
So for this little demo
here, you can see the slider.

00:10:47.880 --> 00:10:51.030
And the slider does need to
know, of course, how much

00:10:51.030 --> 00:10:51.800
can it slide?

00:10:51.800 --> 00:10:54.030
So what is the maximum
zoom level, essentially?

00:10:54.030 --> 00:10:56.590
And you can see in this
short snippet of code

00:10:56.590 --> 00:10:58.380
how, from a media
stream, I first

00:10:58.380 --> 00:11:03.600
get the video track, the first
one, check its capabilities.

00:11:03.600 --> 00:11:09.300
And from the track, I check
the available settings.

00:11:09.300 --> 00:11:12.900
And then I can use that
to update and create

00:11:12.900 --> 00:11:14.735
my user interface like this.

00:11:14.735 --> 00:11:18.960
I'll use it to zoom in with
the capabilities of the device

00:11:18.960 --> 00:11:21.430
directly being used
and being applied.

00:11:21.430 --> 00:11:24.300
So that's pretty
cool, pretty exciting.

00:11:24.300 --> 00:11:27.090
Something even cooler
and even more exciting

00:11:27.090 --> 00:11:29.310
is the Shape Detection
API that allows

00:11:29.310 --> 00:11:32.250
you to detect faces,
read barcodes,

00:11:32.250 --> 00:11:35.940
and even to run Optical
Character Recognition, OCR,

00:11:35.940 --> 00:11:37.870
right in the browser.

00:11:37.870 --> 00:11:40.560
You can see this
little demo here.

00:11:40.560 --> 00:11:42.840
I was just holding
that phone and pointing

00:11:42.840 --> 00:11:44.280
to different
browser tabs where I

00:11:44.280 --> 00:11:47.430
had open, first, a
QR code, and then

00:11:47.430 --> 00:11:52.150
on a second tab, a face
and some text here.

00:11:52.150 --> 00:11:53.910
So you can see
how, in real time,

00:11:53.910 --> 00:11:58.600
the API detects the different
objects on this page.

00:11:58.600 --> 00:12:02.910
So this is directly
integrated in the browser.

00:12:02.910 --> 00:12:05.310
So let me quickly
show you how it works.

00:12:05.310 --> 00:12:09.000
You first need to initialize
the different detectors, so

00:12:09.000 --> 00:12:11.550
the face detector,
the text detector

00:12:11.550 --> 00:12:13.110
and the barcode detector.

00:12:13.110 --> 00:12:15.860
And then you can just
listen for events.

00:12:15.860 --> 00:12:17.640
So everything is promise-based.

00:12:17.640 --> 00:12:21.000
So you can queue up all
the different promises,

00:12:21.000 --> 00:12:25.080
facedetector.detect,
textdetector.detect, and so on.

00:12:25.080 --> 00:12:28.740
And then you will get
the detected object

00:12:28.740 --> 00:12:30.120
in the results--

00:12:30.120 --> 00:12:33.600
so pretty cool,
super easy to use.

00:12:33.600 --> 00:12:35.940
If you check out
this demo, you will

00:12:35.940 --> 00:12:39.410
see it's 100 lines of
code and everything

00:12:39.410 --> 00:12:41.900
directly working and
running in the browser, so

00:12:41.900 --> 00:12:43.620
super exciting, super cool API.

00:12:43.620 --> 00:12:48.460
I think this unlocks a lot
of cool new applications.

00:12:48.460 --> 00:12:51.010
The next thing is the
Media Session API.

00:12:51.010 --> 00:12:53.660
When you're playing
media content on the web,

00:12:53.660 --> 00:12:56.040
you want to know, of course,
well, what is playing?

00:12:56.040 --> 00:12:57.210
When is it playing?

00:12:57.210 --> 00:13:00.540
And on a mobile device, you,
of course, want to control.

00:13:00.540 --> 00:13:05.400
You want to skip forward,
go to the next track, pause.

00:13:05.400 --> 00:13:08.910
This is all possible now
with the Media Session API.

00:13:08.910 --> 00:13:14.130
You can see meta information
of the currently playing media.

00:13:14.130 --> 00:13:17.020
And you can, of course,
directly control it.

00:13:17.020 --> 00:13:20.610
So let me show you how this
works, and first, what kind

00:13:20.610 --> 00:13:22.540
of metadata you can control.

00:13:22.540 --> 00:13:25.210
So in the screenshot here,
you can see there's a title.

00:13:25.210 --> 00:13:26.010
There's an artist.

00:13:26.010 --> 00:13:26.920
There's an album.

00:13:26.920 --> 00:13:28.050
There's artwork.

00:13:28.050 --> 00:13:30.930
And then you have two
different action handlers

00:13:30.930 --> 00:13:33.540
that you can set, so seek
backward, previous track,

00:13:33.540 --> 00:13:34.560
and so on.

00:13:34.560 --> 00:13:36.930
So a lot of things possible.

00:13:36.930 --> 00:13:39.930
This block of code might first
look pretty intimidating.

00:13:39.930 --> 00:13:42.810
But actually, it's
just two big things.

00:13:42.810 --> 00:13:45.460
On the first half,
I'm just setting

00:13:45.460 --> 00:13:49.590
here all the different media
metadata in the object.

00:13:49.590 --> 00:13:51.840
And then at the
second half, I'm just

00:13:51.840 --> 00:13:53.880
connecting the different
action handlers

00:13:53.880 --> 00:13:58.210
and connecting functions
to the different events.

00:13:58.210 --> 00:13:59.730
So super easy to use.

00:13:59.730 --> 00:14:01.950
Again, very powerful,
great integration

00:14:01.950 --> 00:14:05.650
in the native operating system.

00:14:05.650 --> 00:14:09.520
WebVR, big topic,
super cool thing,

00:14:09.520 --> 00:14:11.970
because sometimes the
real reality actually

00:14:11.970 --> 00:14:13.560
is not real enough.

00:14:13.560 --> 00:14:18.510
So WebVR allows you to create
compelling VR experiences

00:14:18.510 --> 00:14:19.880
right in the browser.

00:14:19.880 --> 00:14:23.670
It's an open standard
that, yeah, just allows

00:14:23.670 --> 00:14:27.390
you to directly program
these kind of experiences,

00:14:27.390 --> 00:14:31.072
so that everyone can get
VR experiences very easily.

00:14:31.072 --> 00:14:33.030
On this demo created by
Martin [? Split, ?] you

00:14:33.030 --> 00:14:35.610
can see how this
could change the lives

00:14:35.610 --> 00:14:38.490
for interior designers,
for example, who could just

00:14:38.490 --> 00:14:40.290
pass on a link to
the work that they've

00:14:40.290 --> 00:14:41.520
created to their clients.

00:14:41.520 --> 00:14:44.330
They don't have to install
any native 3D viewer software

00:14:44.330 --> 00:14:45.210
or anything.

00:14:45.210 --> 00:14:47.780
They can just take
out their VR goggles,

00:14:47.780 --> 00:14:50.540
cardboards, whatever, and
just have a quick look at how

00:14:50.540 --> 00:14:52.740
their future home might look--

00:14:52.740 --> 00:14:56.430
super cool, directly
in the browser.

00:14:56.430 --> 00:15:00.310
Performance, this is super
important, of course.

00:15:00.310 --> 00:15:02.890
We preach performance a lot.

00:15:02.890 --> 00:15:05.920
Performance-Related
APIs no longer

00:15:05.920 --> 00:15:10.360
allow you to have an excuse for
having a bad-performing site.

00:15:10.360 --> 00:15:12.580
Network Information
API is something

00:15:12.580 --> 00:15:15.790
that you can use to know
how fast you can go.

00:15:15.790 --> 00:15:17.570
Let me show you what
you can do here.

00:15:17.570 --> 00:15:20.290
So based on the connection
type of the user,

00:15:20.290 --> 00:15:22.890
you can now adopt
your experience.

00:15:22.890 --> 00:15:26.680
So for example, you could show
someone low-resolution image

00:15:26.680 --> 00:15:30.740
assets when they are
on a slow connection.

00:15:30.740 --> 00:15:35.260
And you can, of course, also be
on mobile in a true mobile way.

00:15:35.260 --> 00:15:37.030
So sometimes,
you're in a tunnel.

00:15:37.030 --> 00:15:38.200
Sometimes you are--

00:15:38.200 --> 00:15:40.330
I don't know-- somewhere
in the countryside.

00:15:40.330 --> 00:15:42.520
And then sometimes, you
are just in the city.

00:15:42.520 --> 00:15:45.970
So what I'm getting at
is connections change.

00:15:45.970 --> 00:15:48.070
So of, course, you
don't want to have

00:15:48.070 --> 00:15:50.590
someone with a
low-res experience

00:15:50.590 --> 00:15:52.450
for the entire session.

00:15:52.450 --> 00:15:55.480
But sometimes, when they
have a good connection,

00:15:55.480 --> 00:15:58.010
you, of course, want to
give them high-res images.

00:15:58.010 --> 00:16:01.210
And you can see in this code
how you can, first of all,

00:16:01.210 --> 00:16:03.830
just read out the information,
but then, of course,

00:16:03.830 --> 00:16:05.680
be notified when the
connection changes.

00:16:09.330 --> 00:16:10.350
Why is this important?

00:16:10.350 --> 00:16:13.560
Well, you, of course,
have media queries.

00:16:13.560 --> 00:16:17.640
So you could say, well, this
user is on a retina display

00:16:17.640 --> 00:16:21.300
super high-resolution capable.

00:16:21.300 --> 00:16:24.360
But actually, combined
with network information,

00:16:24.360 --> 00:16:27.120
it might, after all, not
make sense to show them

00:16:27.120 --> 00:16:29.380
super high-resolution images.

00:16:29.380 --> 00:16:32.160
So this is just a
short example how

00:16:32.160 --> 00:16:36.330
you can programmatically from
JavaScript query media queries,

00:16:36.330 --> 00:16:40.860
check for the result, and then
combine it with the Connection

00:16:40.860 --> 00:16:43.110
API to see, well, is
the connection actually

00:16:43.110 --> 00:16:46.330
right now good enough for
supporting high-res images?

00:16:46.330 --> 00:16:49.200
So you can directly
work with media queries

00:16:49.200 --> 00:16:52.890
and with the Connection
API together.

00:16:52.890 --> 00:16:55.190
Then there is the
Core Performance API.

00:16:55.190 --> 00:16:57.890
Because you do care--
or should be caring--

00:16:57.890 --> 00:17:00.410
what's happening
when a page loads.

00:17:00.410 --> 00:17:04.550
For this, I was very quickly
auditing the actual event

00:17:04.550 --> 00:17:07.040
page for the GDD.

00:17:07.040 --> 00:17:09.410
So there's a lot
of different things

00:17:09.410 --> 00:17:11.589
that you can get and
calculate dynamically.

00:17:11.589 --> 00:17:13.880
So you can see here, I'm
getting the perf data

00:17:13.880 --> 00:17:17.329
from the
window.performance.timing

00:17:17.329 --> 00:17:18.224
object.

00:17:18.224 --> 00:17:20.390
And then you can calculate
a number of things, like,

00:17:20.390 --> 00:17:23.240
for example, the page load
time, or the connect time,

00:17:23.240 --> 00:17:24.510
or the render time.

00:17:24.510 --> 00:17:27.560
And these are core metrics
that you could then just

00:17:27.560 --> 00:17:30.120
simply report back to
your analytics back.

00:17:30.120 --> 00:17:33.020
And I guess you could
see how the real users

00:17:33.020 --> 00:17:36.020
in the real world out
there experience my page.

00:17:36.020 --> 00:17:37.907
And if then see
alarming numbers,

00:17:37.907 --> 00:17:39.740
then it's probably a
good idea to get going,

00:17:39.740 --> 00:17:44.120
and improve your site,
and make it load faster

00:17:44.120 --> 00:17:45.390
or render faster.

00:17:45.390 --> 00:17:47.430
So that's really cool.

00:17:47.430 --> 00:17:50.964
But then, this is only
one part of the story.

00:17:50.964 --> 00:17:52.880
Something more interesting
and more important,

00:17:52.880 --> 00:17:57.800
actually, is making sure that
content in a meaningful way

00:17:57.800 --> 00:17:59.190
gets to the user.

00:17:59.190 --> 00:18:02.630
So what it can do now is,
with the Paint Timing API,

00:18:02.630 --> 00:18:04.600
information about
key painting events--

00:18:04.600 --> 00:18:09.080
so when did what content
arrive at the user's device?

00:18:09.080 --> 00:18:11.060
And there's even a
performance observer,

00:18:11.060 --> 00:18:13.130
so you can get
dynamically notified

00:18:13.130 --> 00:18:16.500
and react whenever a
certain paint event happens.

00:18:16.500 --> 00:18:21.210
So I was auditing this page on
a simulated slow 3G connection.

00:18:21.210 --> 00:18:23.360
And you can see here
in the console--

00:18:23.360 --> 00:18:25.520
it's relatively small, I
think, but you can still

00:18:25.520 --> 00:18:26.810
maybe see it--

00:18:26.810 --> 00:18:30.200
the first paint and the
first contentful paint.

00:18:30.200 --> 00:18:32.330
So when was the first
moment where something,

00:18:32.330 --> 00:18:34.280
no matter what, was painted?

00:18:34.280 --> 00:18:36.650
And when was the first moment
where something meaningful

00:18:36.650 --> 00:18:37.250
was painted?

00:18:37.250 --> 00:18:39.120
So for example,
text, for example,

00:18:39.120 --> 00:18:41.390
an image, so that
people can actually

00:18:41.390 --> 00:18:44.390
consume content and not just
stare at a gray background

00:18:44.390 --> 00:18:47.520
or a white background--
so super useful API.

00:18:47.520 --> 00:18:51.020
And of course, this
is a core metrics

00:18:51.020 --> 00:18:53.780
that you can then, again,
report back to your analytics

00:18:53.780 --> 00:18:58.560
and see if everything is OK.

00:18:58.560 --> 00:19:02.240
Clients Hints, also
a very exciting topic

00:19:02.240 --> 00:19:06.680
that allows you to adopt
and see what kind of device

00:19:06.680 --> 00:19:08.780
you have to do with.

00:19:08.780 --> 00:19:11.750
We have in Chrome
telemetry, so we kind of

00:19:11.750 --> 00:19:14.910
get a feeling of what's
going on with the browser.

00:19:14.910 --> 00:19:19.190
And we've noticed that a lot
of foreground tab crashes

00:19:19.190 --> 00:19:23.150
are actually due to
out-of-memory exception.

00:19:23.150 --> 00:19:25.380
So when the device
runs out of memory,

00:19:25.380 --> 00:19:27.650
the Chrome tab might crash.

00:19:27.650 --> 00:19:30.320
So you can see here
an Android phone

00:19:30.320 --> 00:19:33.120
more on the cheap
end of the spectrum.

00:19:33.120 --> 00:19:36.350
So for these kind of devices,
it might be a good idea

00:19:36.350 --> 00:19:39.470
to maybe not serve
super, super high-res,

00:19:39.470 --> 00:19:43.520
super RAM-heavy experiences.

00:19:43.520 --> 00:19:45.290
But many adopt it.

00:19:45.290 --> 00:19:46.680
So how can that work?

00:19:46.680 --> 00:19:48.830
First of all, the
service can advertise

00:19:48.830 --> 00:19:51.230
that they support Client Hints.

00:19:51.230 --> 00:19:55.640
For this, there's a new HTTP
header called accept-ch, so CH

00:19:55.640 --> 00:19:56.780
for Client Hints.

00:19:56.780 --> 00:20:00.720
And then it can provide a list
of the different client hints

00:20:00.720 --> 00:20:02.660
that your server
actually supports,

00:20:02.660 --> 00:20:04.940
in this case, device memory.

00:20:04.940 --> 00:20:07.460
And clients can then--
so user agents-- can then

00:20:07.460 --> 00:20:11.870
send the device memory, for
example, and say, by the way,

00:20:11.870 --> 00:20:13.600
I'm a poorish device.

00:20:13.600 --> 00:20:16.730
I have 0.5 gigs of RAM only.

00:20:16.730 --> 00:20:19.880
So that then the server
can adopt the experience

00:20:19.880 --> 00:20:21.149
accordingly.

00:20:21.149 --> 00:20:22.940
And also, you can read
all this information

00:20:22.940 --> 00:20:25.400
on the client side
with JavaScript.

00:20:25.400 --> 00:20:28.640
So you can just have a look
at navigator.devicememory

00:20:28.640 --> 00:20:31.460
and see, what is the actual
hardware device memory

00:20:31.460 --> 00:20:32.540
right now?

00:20:32.540 --> 00:20:36.510
And you can also see, how
many cores does the CPU have?

00:20:36.510 --> 00:20:38.940
So when you kind
of program a game,

00:20:38.940 --> 00:20:41.150
for example, you
can decide, should I

00:20:41.150 --> 00:20:44.480
use the heavy textures, or sure
I use the lighter textures--

00:20:44.480 --> 00:20:49.320
dependent on device memory and
or the hardware concurrency.

00:20:49.320 --> 00:20:52.010
So how many cores
does the CPU have--

00:20:52.010 --> 00:20:54.830
super exciting,
great, new features.

00:20:54.830 --> 00:20:59.320
Which then brings us to
Hardware-Related APIs.

00:20:59.320 --> 00:21:00.820
The first API that
I want to mention

00:21:00.820 --> 00:21:03.790
is the Web Bluetooth API,
which allows you to communicate

00:21:03.790 --> 00:21:06.530
with nearby Bluetooth devices.

00:21:06.530 --> 00:21:09.430
In this demo here, created
by Francois Beaufort,

00:21:09.430 --> 00:21:11.290
you can see how,
with his phone, he's

00:21:11.290 --> 00:21:13.196
controlling Bluetooth candles.

00:21:13.196 --> 00:21:15.070
I wasn't sure that this
kind of thing exists.

00:21:15.070 --> 00:21:16.720
But actually, it does exist--

00:21:16.720 --> 00:21:18.460
Bluetooth candles.

00:21:18.460 --> 00:21:20.560
And can see here why
this could be fun.

00:21:20.560 --> 00:21:23.470
You can just allow
anyone with a device

00:21:23.470 --> 00:21:28.160
that is in range to control
the experience here.

00:21:28.160 --> 00:21:32.050
It's using the GAT, so
Generic Attribute Profile,

00:21:32.050 --> 00:21:37.670
and uses Bluetooth 4, so
very energy-efficient.

00:21:37.670 --> 00:21:40.360
It's partially implemented
in Chrome and Android, Linux,

00:21:40.360 --> 00:21:42.670
macOS, and in Chrome OS--

00:21:42.670 --> 00:21:43.670
very exciting API.

00:21:46.600 --> 00:21:50.250
The next thing as well is
WebUSB, which allows you, well,

00:21:50.250 --> 00:21:54.210
as the name suggests, to
expose USB devices directly

00:21:54.210 --> 00:21:56.340
to websites.

00:21:56.340 --> 00:21:59.300
This is, of course, not for
any and all USB devices,

00:21:59.300 --> 00:22:02.850
but for USB devices that were
specifically designed for that.

00:22:02.850 --> 00:22:05.350
In this demo here created
by Kenneth [? Rhodes ?]

00:22:05.350 --> 00:22:07.890
Christiansen you
can see how he's

00:22:07.890 --> 00:22:10.950
using WebUSB to talk
to an arduino board

00:22:10.950 --> 00:22:16.240
to then display text
on a dot matrix screen.

00:22:16.240 --> 00:22:18.810
So these devices need to
be specifically designed

00:22:18.810 --> 00:22:20.670
for being used on the web.

00:22:20.670 --> 00:22:23.110
And it's obviously HTTPS only.

00:22:23.110 --> 00:22:24.960
So this is a very powerful API.

00:22:24.960 --> 00:22:28.890
So we want to be sure
that this is HTTPS only.

00:22:28.890 --> 00:22:31.080
And of course, it has
to be user-initiated.

00:22:31.080 --> 00:22:33.630
So you can't just
silently, secretly

00:22:33.630 --> 00:22:35.220
connect to a USB device.

00:22:35.220 --> 00:22:38.070
It's always after
a user gesture.

00:22:38.070 --> 00:22:41.190
Again, implemented in Chrome,
on Android, Linux, macOS,

00:22:41.190 --> 00:22:43.740
and in Chrome OS.

00:22:43.740 --> 00:22:47.700
And today, there
is one more thing.

00:22:47.700 --> 00:22:50.940
Today, we are launching
WebSCSI, which

00:22:50.940 --> 00:22:55.290
allows you to revive
your old SCSI hard disks,

00:22:55.290 --> 00:22:57.940
bringing the '80s
back to the web.

00:22:57.940 --> 00:23:01.530
SCSI is a Small Computer
System Interface,

00:23:01.530 --> 00:23:03.510
a set of standards
for transferring

00:23:03.510 --> 00:23:06.760
data between computers
and peripheral devices.

00:23:06.760 --> 00:23:11.600
WebSCSI emulates a SCSI
controller right in the browser

00:23:11.600 --> 00:23:15.090
and defines
interfaces for access.

00:23:15.090 --> 00:23:18.330
It's landed in Chromium 64
Technology Preview Canary

00:23:18.330 --> 00:23:19.010
Nightly--

00:23:19.010 --> 00:23:23.090
very excited about that
This was, of course, a joke.

00:23:23.090 --> 00:23:26.250
But what I was getting
at, this is not the end.

00:23:26.250 --> 00:23:28.620
This is just the beginning.

00:23:28.620 --> 00:23:29.660
The web is so great.

00:23:29.660 --> 00:23:31.100
The web is ever-evolving.

00:23:31.100 --> 00:23:32.780
And if you want to
stay up-to-date,

00:23:32.780 --> 00:23:36.056
we very much invite you to
subscribe to developers.googl

00:23:36.056 --> 00:23:40.940
e.com/web/updates and be
notified of all the new,

00:23:40.940 --> 00:23:42.680
great things that are coming.

00:23:42.680 --> 00:23:46.430
With that, [NON-ENGLISH SPEECH],,
Thomas Steiner and Stephen

00:23:46.430 --> 00:23:47.930
Soneff.

00:23:47.930 --> 00:23:51.280
[MUSIC PLAYING]

