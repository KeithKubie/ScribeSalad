WEBVTT
Kind: captions
Language: en

00:00:00.380 --> 00:00:02.796
PAUL LEWIS: So yes, we're going
to talk about performance.

00:00:02.796 --> 00:00:06.890
We're going to be talking about
both page load performance,

00:00:06.890 --> 00:00:08.470
so getting things
to load quickly.

00:00:08.470 --> 00:00:10.560
And then we're going to
be talking about 60 frames

00:00:10.560 --> 00:00:13.780
a second kind of stuff as well,
the runtime aspects of this.

00:00:13.780 --> 00:00:16.430
So introducing the panel then.

00:00:16.430 --> 00:00:18.290
So at the far right
we have Pat Meenan,

00:00:18.290 --> 00:00:20.320
Software Engineer on Chrome.

00:00:20.320 --> 00:00:23.272
If you've ever used
something like WebPagetest,

00:00:23.272 --> 00:00:25.230
you've used one of the
finest performance tools

00:00:25.230 --> 00:00:26.960
that we have available today.

00:00:26.960 --> 00:00:29.915
And if you haven't, go to
webpagetest.org and shove

00:00:29.915 --> 00:00:32.049
in your site and find
out how you're doing.

00:00:32.049 --> 00:00:35.050
It really is that good.

00:00:35.050 --> 00:00:38.930
To his left, my right,
that's Paul Irish, which

00:00:38.930 --> 00:00:42.580
I think most of us know him--
Product Manager on Chrome.

00:00:42.580 --> 00:00:45.420
I think we do know him from
things like jQuery Modernizr,

00:00:45.420 --> 00:00:47.370
and of course Chrome DevTools.

00:00:47.370 --> 00:00:51.440
He's sort of been involved
in that for a good long time.

00:00:51.440 --> 00:00:53.560
To my right we've got
Siddharth Vijayakrishnan.

00:00:53.560 --> 00:00:56.670
And he's a product manager
focusing on Chrome's network

00:00:56.670 --> 00:00:59.960
stack, ensuring that Chrome
loads in the best way possible.

00:00:59.960 --> 00:01:02.960
And he's also responsible for
the Chrome data compression

00:01:02.960 --> 00:01:04.260
proxy on Android, as well.

00:01:04.260 --> 00:01:07.300
To my left it's Nat Duca.

00:01:07.300 --> 00:01:08.884
He's a software
engineer on Chrome.

00:01:08.884 --> 00:01:10.300
And if you've heard
the word jank,

00:01:10.300 --> 00:01:13.420
then essentially that's
down to Nat, pretty much.

00:01:13.420 --> 00:01:17.157
He's the person behind Chrome's
trace-viewer GPU rasterization.

00:01:17.157 --> 00:01:19.740
Basically, I discovered pretty
early on in my career at Google

00:01:19.740 --> 00:01:21.850
the most graphics
roads kind of lead back

00:01:21.850 --> 00:01:24.610
to him, for good or ill.

00:01:24.610 --> 00:01:26.950
To his left it's Jan.

00:01:26.950 --> 00:01:28.440
And he's a software
engineer works

00:01:28.440 --> 00:01:31.675
on things like mod_pagespeed
or nginx pagespeed.

00:01:31.675 --> 00:01:33.800
So if you never tried those,
you absolutely should.

00:01:33.800 --> 00:01:35.800
They can make a world of
difference to your site.

00:01:35.800 --> 00:01:38.050
They optimize your content
automatically on the server

00:01:38.050 --> 00:01:41.910
side, so you don't have to think
quite as hard about all that.

00:01:41.910 --> 00:01:44.630
And then at the far
left, a late addition

00:01:44.630 --> 00:01:47.050
and a very kind and
willing person to join,

00:01:47.050 --> 00:01:48.670
is Alex Russell.

00:01:48.670 --> 00:01:51.260
He's going to hopefully help
us out a little bit with things

00:01:51.260 --> 00:01:52.700
about ServiceWorker because
it's going to come up.

00:01:52.700 --> 00:01:55.110
Let's be honest, it's been on
the tip of everybody's tongue

00:01:55.110 --> 00:01:56.090
for the last day or so.

00:01:56.090 --> 00:01:58.280
So all right.

00:01:58.280 --> 00:01:59.650
So we'll get started.

00:01:59.650 --> 00:02:01.230
Question from a guy called Paul.

00:02:01.230 --> 00:02:03.320
I like how this starts already.

00:02:03.320 --> 00:02:04.690
Oh yeah, oh yeah.

00:02:04.690 --> 00:02:06.940
Paul for performance,
performance with Pauls.

00:02:06.940 --> 00:02:07.890
It's good.

00:02:07.890 --> 00:02:09.570
"Performance is
a massive area--"

00:02:09.570 --> 00:02:12.070
it's a fair question-- "so where
should I invest my efforts?

00:02:12.070 --> 00:02:14.960
On the network or on the
client and rendering pipeline?

00:02:14.960 --> 00:02:17.340
And if I can't do
all of it, what

00:02:17.340 --> 00:02:20.140
do I spend the bulk
of my time on?"

00:02:20.140 --> 00:02:22.340
Who wants to go?

00:02:22.340 --> 00:02:22.840
Pat.

00:02:22.840 --> 00:02:24.423
PAT MEENAN: I think
it's largely going

00:02:24.423 --> 00:02:27.330
to depend on what kind
of app and experience

00:02:27.330 --> 00:02:28.410
you're delivering.

00:02:28.410 --> 00:02:31.260
If you're delivering sort of
more of a content experience,

00:02:31.260 --> 00:02:33.718
you're probably going to want
to focus more on the loading.

00:02:33.718 --> 00:02:36.060
If you're delivering sort
of a rich app-interactive

00:02:36.060 --> 00:02:40.360
experience, you can afford to
spend more time on the loading

00:02:40.360 --> 00:02:42.720
to get all of the experience
there ahead of time,

00:02:42.720 --> 00:02:46.010
and have the rich interactions
and really smooth interactivity

00:02:46.010 --> 00:02:46.854
with the user.

00:02:46.854 --> 00:02:48.270
PAUL LEWIS: Does
that sort of bank

00:02:48.270 --> 00:02:50.165
on having ServiceWorker there?

00:02:50.165 --> 00:02:52.079
Are you sort of saying,
well, you know what?

00:02:52.079 --> 00:02:54.120
Actually we just figure
that that first load will

00:02:54.120 --> 00:02:56.080
take the hit, and then
we hope that things

00:02:56.080 --> 00:02:57.520
will be better for feature load?

00:02:57.520 --> 00:03:00.220
PAT MEENAN: I mean just look
at how your users are going

00:03:00.220 --> 00:03:01.870
to interact with
your content, right?

00:03:01.870 --> 00:03:05.320
If they're going to
interact with it as an app,

00:03:05.320 --> 00:03:07.430
focus on their
actual interactions.

00:03:07.430 --> 00:03:09.790
If they're going to
go to it to consume

00:03:09.790 --> 00:03:13.090
content and sort of jump
away, get the content to them

00:03:13.090 --> 00:03:14.907
as quickly as you can.

00:03:14.907 --> 00:03:16.490
PAUL LEWIS: Nat, do
you feel the same?

00:03:16.490 --> 00:03:17.656
NAT DUCA: Oh, yeah, totally.

00:03:17.656 --> 00:03:19.820
I mean, this all begins
with a model of your users

00:03:19.820 --> 00:03:23.340
and who you're trying to attract
to make money from or exploit

00:03:23.340 --> 00:03:25.440
in some way.

00:03:25.440 --> 00:03:25.940
Right?

00:03:25.940 --> 00:03:27.670
Clearly.

00:03:27.670 --> 00:03:30.632
So if you have
terrible jank, it's

00:03:30.632 --> 00:03:31.840
going to drop them right out.

00:03:31.840 --> 00:03:33.060
So there's sort of
this baseline you

00:03:33.060 --> 00:03:34.120
need to achieve
across the board.

00:03:34.120 --> 00:03:35.900
If you have a 10
second page load time,

00:03:35.900 --> 00:03:38.060
you're going to lose people,
and you need not to do that.

00:03:38.060 --> 00:03:40.601
Once you get down into sort of
the baseline of you are mostly

00:03:40.601 --> 00:03:43.120
smooth and you are
mostly quickly loading,

00:03:43.120 --> 00:03:44.680
then you get into this nuance.

00:03:44.680 --> 00:03:46.870
So first of all, get that
baseline established.

00:03:46.870 --> 00:03:48.200
And then from there
you want to decide,

00:03:48.200 --> 00:03:49.866
are people returning
to your site enough

00:03:49.866 --> 00:03:52.620
to start benefiting from
cache ability and things

00:03:52.620 --> 00:03:53.620
on that side.

00:03:53.620 --> 00:03:56.400
And the cool thing here is
there's this trade off of,

00:03:56.400 --> 00:03:58.566
especially if you could
start assuming ServiceWorker

00:03:58.566 --> 00:03:59.910
or cacheability.

00:03:59.910 --> 00:04:02.400
You start being able to
simplify your loading process

00:04:02.400 --> 00:04:07.379
and have a little more free time
to do great, smooth UI effects.

00:04:07.379 --> 00:04:08.670
But you really have to do both.

00:04:08.670 --> 00:04:11.220
You have to plan to figure
out how to afford to do both.

00:04:11.220 --> 00:04:12.630
And then if you can't
afford to do both,

00:04:12.630 --> 00:04:14.046
you're going to
have to figure out

00:04:14.046 --> 00:04:16.690
which side to simplify
in order to get

00:04:16.690 --> 00:04:18.370
to the end of your launch.

00:04:22.077 --> 00:04:24.160
PAUL IRISH: I was going
to add in one thing, which

00:04:24.160 --> 00:04:28.020
is think about it from
the user perspective.

00:04:28.020 --> 00:04:30.880
The page load is like
your introduction to them.

00:04:30.880 --> 00:04:32.929
And if you are just like
stuttering while you're

00:04:32.929 --> 00:04:34.470
introducing yourself
to someone, it's

00:04:34.470 --> 00:04:36.160
not going to really
work out so well.

00:04:36.160 --> 00:04:37.060
So there's the introduction.

00:04:37.060 --> 00:04:38.518
And then there's
where you actually

00:04:38.518 --> 00:04:39.560
demonstrate your value.

00:04:39.560 --> 00:04:41.710
And that's more of like
the application performing,

00:04:41.710 --> 00:04:44.690
and things are smooth, and not
breaking user expectations.

00:04:44.690 --> 00:04:47.400
And so obviously we have
to do both of these things.

00:04:47.400 --> 00:04:51.710
It comes a lot down to using
what your users pain points

00:04:51.710 --> 00:04:52.210
are.

00:04:52.210 --> 00:04:54.090
And so getting good
feedback from them

00:04:54.090 --> 00:04:57.599
on like it feels
weird, it feels slow.

00:04:57.599 --> 00:04:59.390
And then tell me more
about the slow thing.

00:04:59.390 --> 00:05:02.790
Well, I come to it
every single day

00:05:02.790 --> 00:05:05.714
and it takes so long for
it to get up and running.

00:05:05.714 --> 00:05:08.130
Then you understand that it's
all about that initial load.

00:05:08.130 --> 00:05:09.680
So you have to do both.

00:05:09.680 --> 00:05:13.200
And just identify,
work with your user

00:05:13.200 --> 00:05:16.510
to identify what
is really impacting

00:05:16.510 --> 00:05:19.020
their perception
of the experience.

00:05:19.020 --> 00:05:21.720
PAUL LEWIS: OK, fair enough.

00:05:21.720 --> 00:05:24.920
I guess related to that,
there's another question

00:05:24.920 --> 00:05:25.860
from another Paul.

00:05:25.860 --> 00:05:29.170
I fully approved of all the
Paul's asking the questions,

00:05:29.170 --> 00:05:30.170
incidentally.

00:05:30.170 --> 00:05:32.970
"If I was a developer in India
or another emerging economy,

00:05:32.970 --> 00:05:35.560
where would you now tell
them to focus their efforts?"

00:05:35.560 --> 00:05:38.367
Is that the same, or do we
think that it changes matters?

00:05:38.367 --> 00:05:40.950
PAT MEENAN: First of all, sort
of one thing that really grinds

00:05:40.950 --> 00:05:43.220
me about the question
is, you don't

00:05:43.220 --> 00:05:45.470
need to be a developer
in an emerging market

00:05:45.470 --> 00:05:47.450
to target an emerging market.

00:05:47.450 --> 00:05:48.666
So, let's face it.

00:05:48.666 --> 00:05:50.040
The emerging
markets are actually

00:05:50.040 --> 00:05:51.620
going to have a lot
more mobile users

00:05:51.620 --> 00:05:53.340
than the non-emerging markets.

00:05:53.340 --> 00:05:56.340
So hopefully we're all
targeting all of them.

00:05:56.340 --> 00:05:58.920
And the things that you do
for the emerging markets,

00:05:58.920 --> 00:06:02.410
if it's a situation where
bandwidth is severely limited

00:06:02.410 --> 00:06:05.110
or network connectivity is
limited, a lot of the things

00:06:05.110 --> 00:06:07.480
that we've been talking
about here for offline

00:06:07.480 --> 00:06:08.380
are going to be huge.

00:06:08.380 --> 00:06:11.120
Like ServiceWorker
is going to be huge.

00:06:11.120 --> 00:06:13.480
Reducing the amount of stuff
you're shoving down to them

00:06:13.480 --> 00:06:16.220
is going to be huge, especially
on the initial load and stuff

00:06:16.220 --> 00:06:17.776
like that.

00:06:17.776 --> 00:06:19.150
But everything
you do for them is

00:06:19.150 --> 00:06:22.180
going to be beneficial for
all of your user base anyway.

00:06:25.450 --> 00:06:27.100
PAUL LEWIS: So let
me put it this way.

00:06:27.100 --> 00:06:30.520
According to the HTTP Archive
I checked, 58% of the web

00:06:30.520 --> 00:06:33.750
has pages that are one
megabyte or larger.

00:06:33.750 --> 00:06:35.380
That was as of the
start of this month.

00:06:35.380 --> 00:06:36.620
And certainly we're pushing--

00:06:36.620 --> 00:06:39.240
PAT MEENAN: Actually, it's
close to two megabytes, I think.

00:06:39.240 --> 00:06:39.650
PAUL LEWIS: Yeah.

00:06:39.650 --> 00:06:41.650
PAT MEENAN: Which is
scaring the crap out of me.

00:06:41.650 --> 00:06:42.650
PAUL LEWIS: Yeah, right?

00:06:42.650 --> 00:06:46.490
And so we're kind of pushing to
have these richer experiences,

00:06:46.490 --> 00:06:49.550
which kind of implies more
JavaScript, more resources,

00:06:49.550 --> 00:06:51.680
just more, more,
more of everything.

00:06:51.680 --> 00:06:54.810
And even without ServiceWorker,
if you're talking about, say,

00:06:54.810 --> 00:06:58.000
somewhere where ServiceWorker
hasn't shipped that much.

00:06:58.000 --> 00:07:00.510
Should we be looking
at say, lo-fi versions

00:07:00.510 --> 00:07:01.970
of sites and apps?

00:07:01.970 --> 00:07:03.350
Where is that dividing line?

00:07:03.350 --> 00:07:05.600
Do we sort of go, well
actually, I look at this market

00:07:05.600 --> 00:07:07.650
and maybe it doesn't
do so well here.

00:07:07.650 --> 00:07:10.830
And I want users here, therefore
I'm going to scale things back?

00:07:10.830 --> 00:07:13.230
What do I do for the people
who have good connections?

00:07:13.230 --> 00:07:14.615
Lots of things in there.

00:07:14.615 --> 00:07:15.782
Who wants to tackle that?

00:07:15.782 --> 00:07:16.990
JAN MAESSEN: Bad connections.

00:07:16.990 --> 00:07:19.750
I think a lot of us
sitting in this room--

00:07:19.750 --> 00:07:24.470
at least, if we're developers
in the US, like I am-- sort of

00:07:24.470 --> 00:07:28.860
don't realize just how bad bad
connectivity really can be.

00:07:28.860 --> 00:07:34.380
So when it takes 10 seconds to
get the first 15 of your page

00:07:34.380 --> 00:07:39.530
downloaded, and 30 seconds to
just get the rest of the HTML

00:07:39.530 --> 00:07:44.140
down, the other megabyte
of image resources

00:07:44.140 --> 00:07:46.510
just isn't even on the map yet.

00:07:46.510 --> 00:07:51.340
So the only way to address that
kind of market is to simplify.

00:07:51.340 --> 00:07:55.010
And that might mean you should
be simplifying your entire app

00:07:55.010 --> 00:07:56.870
experience.

00:07:56.870 --> 00:07:59.680
PAUL LEWIS: So what we do
then to make that actually

00:07:59.680 --> 00:08:01.740
a real thing then
for developers?

00:08:01.740 --> 00:08:03.810
Like you say, it's
very easy to forget.

00:08:03.810 --> 00:08:05.770
And unless a developer
is very willing

00:08:05.770 --> 00:08:07.620
to go and, say, spend
time with WebPagetest

00:08:07.620 --> 00:08:09.770
and manually set
up all these tests,

00:08:09.770 --> 00:08:12.790
how can it be more
front of mind?

00:08:12.790 --> 00:08:15.030
ALEX RUSSELL: I think the
answer is user research.

00:08:15.030 --> 00:08:18.830
You need to be talking to users
and studying them, and studying

00:08:18.830 --> 00:08:21.460
their behavior, and
studying their actions.

00:08:21.460 --> 00:08:23.640
I know that it's very
difficult to classify users

00:08:23.640 --> 00:08:25.640
on poor connections,
in many cases.

00:08:25.640 --> 00:08:29.350
You can sort of understand
the total RTT time

00:08:29.350 --> 00:08:30.730
from your first
payload, and then

00:08:30.730 --> 00:08:32.980
understand maybe something
about their latency.

00:08:32.980 --> 00:08:34.690
And I know that
that's difficult.

00:08:34.690 --> 00:08:36.630
We have looked at
Google at systems

00:08:36.630 --> 00:08:38.380
that will allow us
to classify users

00:08:38.380 --> 00:08:42.667
based on those sorts of signals
that we get from the network.

00:08:42.667 --> 00:08:44.500
But those aren't available
to everybody yet.

00:08:44.500 --> 00:08:48.630
So I think there's a tools
gap-- understanding who

00:08:48.630 --> 00:08:50.840
your users are, where
they're coming from,

00:08:50.840 --> 00:08:53.580
what sorts of experiences
they're having.

00:08:53.580 --> 00:08:55.820
Real user metrics are
an important component.

00:08:55.820 --> 00:08:58.180
And then doing science
about the performance,

00:08:58.180 --> 00:09:00.630
as opposed to guessing.

00:09:00.630 --> 00:09:03.640
Like talking to users, looking
at the actual performance,

00:09:03.640 --> 00:09:05.040
looking at the
actual engagement,

00:09:05.040 --> 00:09:06.650
and then running
tests, A/B tests.

00:09:06.650 --> 00:09:07.860
You've got to test.

00:09:07.860 --> 00:09:10.060
Like introduce
artificial latency.

00:09:10.060 --> 00:09:12.270
See how it affects
usage of your site.

00:09:12.270 --> 00:09:14.680
Come back and see what happens
if you reduce the latency.

00:09:14.680 --> 00:09:16.680
If you do a performance
pass, what does it improve?

00:09:16.680 --> 00:09:17.804
Does it improve engagement?

00:09:17.804 --> 00:09:20.210
Does it improve responsiveness?

00:09:20.210 --> 00:09:22.140
You'll figure out
where to invest only

00:09:22.140 --> 00:09:24.100
by looking at the problem
with an open mind.

00:09:24.100 --> 00:09:25.600
PAUL IRISH: I was
going to add thing

00:09:25.600 --> 00:09:27.058
that is pretty
concrete here, which

00:09:27.058 --> 00:09:31.960
is, there's a lot of APIs
available for identifying what

00:09:31.960 --> 00:09:35.630
the network story is and
collecting it from the wilds.

00:09:35.630 --> 00:09:41.190
So navigation timing, you can
reconstruct the entire network

00:09:41.190 --> 00:09:43.907
waterfall for every single page
load, for every single user.

00:09:43.907 --> 00:09:46.240
Send that back to the server,
and then take a look at it

00:09:46.240 --> 00:09:48.160
in aggregate, see
what's happening.

00:09:48.160 --> 00:09:51.970
Even in Google Analytics, you
can get the page load timings

00:09:51.970 --> 00:09:53.282
for absolutely all your users.

00:09:53.282 --> 00:09:53.990
Segment them out.

00:09:53.990 --> 00:09:57.137
You can get an idea of how long
things are taking right now.

00:09:57.137 --> 00:09:58.970
So that's definitely
something to look into.

00:09:58.970 --> 00:10:01.510
NAT DUCA: One thing that I'd
love everybody's feedback

00:10:01.510 --> 00:10:04.390
on here is, some
peeps at Facebook

00:10:04.390 --> 00:10:06.870
have been throwing around
this idea of device classes

00:10:06.870 --> 00:10:08.990
and network classes, which
is separate from like

00:10:08.990 --> 00:10:10.200
whether you have Wi-Fi.

00:10:10.200 --> 00:10:13.510
It's more about, OK,
you got good pings,

00:10:13.510 --> 00:10:16.610
terrible pings, low
pings, whatever.

00:10:16.610 --> 00:10:20.260
And then the same thing,
you have a 2010 device,

00:10:20.260 --> 00:10:22.810
you have a 2011-era device.

00:10:22.810 --> 00:10:25.290
We obviously don't
have this on the web.

00:10:25.290 --> 00:10:28.072
It strikes me that this
is kind of interesting.

00:10:28.072 --> 00:10:29.530
Please reach out
to us if you think

00:10:29.530 --> 00:10:32.190
that's something we
should be pursuing.

00:10:32.190 --> 00:10:33.300
It seems interesting.

00:10:33.300 --> 00:10:36.230
One other comment there-- keep
in mind that like 640 by 480

00:10:36.230 --> 00:10:39.830
is back when you go to
the developing world.

00:10:39.830 --> 00:10:44.310
So you don't need a megabyte
of JPEG for 640 by 480.

00:10:44.310 --> 00:10:47.734
Or 480 by 600, I guess,
because they make it vertical.

00:10:47.734 --> 00:10:49.150
SIDDHARTH
VIJAYAKRISHNAN: In terms

00:10:49.150 --> 00:10:52.305
of reducing the bytes
transferred over the wire,

00:10:52.305 --> 00:10:53.930
with the Chrome data
compression proxy,

00:10:53.930 --> 00:10:57.350
we found that a few simple
things actually go a long way.

00:10:57.350 --> 00:11:00.840
So the proxy actually does some
very simple transformations.

00:11:00.840 --> 00:11:02.130
It applies gzip.

00:11:02.130 --> 00:11:06.200
So in 2014, it is surprising the
number of websites and servers

00:11:06.200 --> 00:11:07.880
that don't use gzip,
even though it's

00:11:07.880 --> 00:11:11.750
just one line in the
Apache config file.

00:11:11.750 --> 00:11:15.720
Transcoding images
to WebP huge gain.

00:11:15.720 --> 00:11:18.600
CSS minification, stripping
white space from JavaScript.

00:11:18.600 --> 00:11:21.810
These are small things, but
in aggregate, the Chrome data

00:11:21.810 --> 00:11:24.420
compression proxy achieves
about 50% reduction

00:11:24.420 --> 00:11:25.830
in the bytes transferred.

00:11:25.830 --> 00:11:27.824
So even those simple
things can go a long way

00:11:27.824 --> 00:11:29.490
in actually reducing
the number of bytes

00:11:29.490 --> 00:11:33.930
that you have to send
out to the client.

00:11:33.930 --> 00:11:36.430
JAN MAESSEN: And I'll point out
that, in fact, mod_pagespeed

00:11:36.430 --> 00:11:40.060
can do that it exactly
for your website.

00:11:40.060 --> 00:11:41.590
The Chrome data
compression proxy

00:11:41.590 --> 00:11:45.940
is doing for users what
we do for site owners.

00:11:45.940 --> 00:11:49.740
So if you're not serving
WebPs, for example, to Chrome

00:11:49.740 --> 00:11:51.390
enabled devices,
you should think

00:11:51.390 --> 00:11:53.590
about serving WebPs to
Chrome enabled devices.

00:11:53.590 --> 00:11:56.010
And we can do that for you,
but there are other techniques

00:11:56.010 --> 00:11:58.160
out there to do the same thing.

00:11:58.160 --> 00:12:00.740
And that's a huge
savings in bandwidth

00:12:00.740 --> 00:12:03.750
for devices that support that.

00:12:03.750 --> 00:12:05.500
PAUL LEWIS: All right,
so let's move on.

00:12:05.500 --> 00:12:09.360
"With the shift to
HTTP/2 and SPDY with SSL,

00:12:09.360 --> 00:12:11.580
is it better to have
multiple smaller files

00:12:11.580 --> 00:12:12.614
or fewer larger files?"

00:12:12.614 --> 00:12:14.530
We're going straight
into the technical stuff.

00:12:14.530 --> 00:12:15.550
And that was from Matt.

00:12:15.550 --> 00:12:18.795
It doesn't look like a Paul to
me, but let's ask it anyway.

00:12:18.795 --> 00:12:20.170
SIDDHARTH
VIJAYAKRISHNAN: I think

00:12:20.170 --> 00:12:22.270
the short answer there is yes.

00:12:22.270 --> 00:12:26.010
HTTP/2 has features like
multiplexing, priorities,

00:12:26.010 --> 00:12:29.770
stream dependencies,
all of which

00:12:29.770 --> 00:12:32.750
work much better when you
actually have multiple smaller

00:12:32.750 --> 00:12:33.420
files.

00:12:33.420 --> 00:12:35.390
The one caveat that
I would add is,

00:12:35.390 --> 00:12:39.270
you have to make sure that-- so
domain sharding was something

00:12:39.270 --> 00:12:41.890
that people use in
the past to get around

00:12:41.890 --> 00:12:46.457
the limits of two
connections per host.

00:12:46.457 --> 00:12:48.040
That is not going
to work with HTTP/2.

00:12:48.040 --> 00:12:54.850
With HTTP/2, you have to
make sure that your host--

00:12:54.850 --> 00:12:57.075
so domain sharding
is not something

00:12:57.075 --> 00:12:59.330
that you should be
doing for HTTP/2.

00:12:59.330 --> 00:13:04.390
Today, if your host
resolves to the same IP,

00:13:04.390 --> 00:13:06.090
then Chrome will
sort of transparently

00:13:06.090 --> 00:13:07.880
unshard this for you.

00:13:07.880 --> 00:13:10.540
But that's not something
that is recommended

00:13:10.540 --> 00:13:13.110
for HTTP/2 going forward.

00:13:13.110 --> 00:13:14.570
PAUL LEWIS: Is
there other things?

00:13:14.570 --> 00:13:16.870
Are there other, let's say,
best practices that we've

00:13:16.870 --> 00:13:20.370
baked into developers heads
over the past years about how

00:13:20.370 --> 00:13:24.720
to do what with HTTP as it is
today that actually now break--

00:13:24.720 --> 00:13:26.910
for want of a better
word-- when we hit HTTP/2?

00:13:26.910 --> 00:13:30.800
And how do they migrate
from one to the other?

00:13:30.800 --> 00:13:32.640
And is there a
seamless path for them?

00:13:32.640 --> 00:13:33.770
Or is it just--

00:13:33.770 --> 00:13:34.520
SIDDHARTH VIJAYAKRISHNAN:
For the most part

00:13:34.520 --> 00:13:34.980
the transformations--

00:13:34.980 --> 00:13:35.350
PAUL LEWIS: [INAUDIBLE].

00:13:35.350 --> 00:13:35.710
SIDDHARTH VIJAYAKRISHNAN: Yeah.

00:13:35.710 --> 00:13:37.085
The most part,
the transformation

00:13:37.085 --> 00:13:39.380
should be handled by
the server itself.

00:13:39.380 --> 00:13:42.450
So for things like
priorities and push,

00:13:42.450 --> 00:13:44.450
the servers are typically
configured to do that.

00:13:44.450 --> 00:13:46.690
So the developers don't really
have to do a lot of work.

00:13:46.690 --> 00:13:47.900
But you have to
actually go and make

00:13:47.900 --> 00:13:50.520
sure that the version of the
server that you're running,

00:13:50.520 --> 00:13:52.410
whether it's Nginx or
Apache, have actually

00:13:52.410 --> 00:13:54.340
implemented the
features correctly.

00:13:54.340 --> 00:13:56.270
Because when we did some
analysis in the past,

00:13:56.270 --> 00:13:58.160
we found that some
versions of Nginx,

00:13:58.160 --> 00:14:00.012
for example, got
prioritization wrong.

00:14:00.012 --> 00:14:01.595
I think that's been
fixed now, but you

00:14:01.595 --> 00:14:03.886
have to make sure that the
version that you're actually

00:14:03.886 --> 00:14:05.940
running is something that
supports all of these.

00:14:05.940 --> 00:14:07.410
PAUL LEWIS: And is there going
to be some kind of page logic

00:14:07.410 --> 00:14:09.600
there that kind of goes,
hey, if this is HTTP/2,

00:14:09.600 --> 00:14:11.850
it just like spits
out all the files?

00:14:11.850 --> 00:14:13.906
Or if it's HTTP
1, actually I want

00:14:13.906 --> 00:14:16.610
you to serve the concat
version of all my resources,

00:14:16.610 --> 00:14:17.580
like old school?

00:14:17.580 --> 00:14:18.246
PAT MEENAN: Yes.

00:14:18.246 --> 00:14:20.810
So there are some
old best practices

00:14:20.810 --> 00:14:24.499
that are no longer
applicable-- or necessary

00:14:24.499 --> 00:14:26.290
I guess is probably a
better way to put it.

00:14:26.290 --> 00:14:28.320
Spriting is no longer
really something

00:14:28.320 --> 00:14:29.960
that you have to worry about.

00:14:29.960 --> 00:14:32.280
Concatenating the
files together,

00:14:32.280 --> 00:14:34.430
also not something you
really have to worry about.

00:14:34.430 --> 00:14:37.160
Being able to version
the individual resources

00:14:37.160 --> 00:14:39.780
and change just the one file
that changed without having

00:14:39.780 --> 00:14:42.810
to push down your whole package
is one of those huge things.

00:14:42.810 --> 00:14:44.780
Sharding, also.

00:14:44.780 --> 00:14:46.980
Serving content off
of a static domain

00:14:46.980 --> 00:14:48.970
instead of your main domain.

00:14:48.970 --> 00:14:51.730
All of these things that
sort of require another DNS

00:14:51.730 --> 00:14:56.867
lookup or another socket
connect sort of hurt you.

00:14:56.867 --> 00:14:59.200
So if you can serve as much
as possible off of your base

00:14:59.200 --> 00:15:03.510
domain, you're going to get
as much benefit as possible.

00:15:03.510 --> 00:15:05.695
So domain sharding
was a big deal

00:15:05.695 --> 00:15:08.010
when there were only two
connections per host.

00:15:08.010 --> 00:15:10.710
It's been a long time
since that's been the case.

00:15:10.710 --> 00:15:13.490
So that's no longer
something that you even

00:15:13.490 --> 00:15:16.720
have to care about, is it a
new browser or an old browser.

00:15:16.720 --> 00:15:19.140
If someone is still
using IE 6, OK, they'll

00:15:19.140 --> 00:15:20.660
have a slightly
slower experience

00:15:20.660 --> 00:15:22.530
because you're not
domain sharding.

00:15:22.530 --> 00:15:24.290
Yeah, they'll get over it.

00:15:24.290 --> 00:15:25.110
Or hopefully--

00:15:25.110 --> 00:15:27.150
PAUL LEWIS: Kind of feels like
they might have other problems

00:15:27.150 --> 00:15:29.060
if their browser is
that old at this point.

00:15:29.060 --> 00:15:30.851
PAT MEENAN: And we're
actually at the point

00:15:30.851 --> 00:15:33.040
now where all of
the modern browsers

00:15:33.040 --> 00:15:36.630
support SPDY or HTTP/2.

00:15:36.630 --> 00:15:38.829
It's going to be kind of
a little period in time

00:15:38.829 --> 00:15:40.620
where you're going to
have to sort of think

00:15:40.620 --> 00:15:42.490
about supporting both.

00:15:42.490 --> 00:15:47.100
IE 11 is sort of the
one edge case, where

00:15:47.100 --> 00:15:50.750
I guess on Windows 7 it doesn't
support it, but on Windows 8

00:15:50.750 --> 00:15:52.100
it does.

00:15:52.100 --> 00:15:55.230
But Safari rolled it out with
iOS 8, Firefox has had it,

00:15:55.230 --> 00:15:56.220
Chrome has had it.

00:15:59.690 --> 00:16:01.620
Look at your market
share for your user base,

00:16:01.620 --> 00:16:05.270
but you're probably at the
point where you can just shift.

00:16:05.270 --> 00:16:06.660
It degrades gracefully.

00:16:06.660 --> 00:16:09.290
If someone happens to be on
one of the older browsers,

00:16:09.290 --> 00:16:11.660
they'll get a slightly
slower experience.

00:16:11.660 --> 00:16:13.940
But it saves your life
a whole lot of effort.

00:16:13.940 --> 00:16:15.570
And everyone on
the newer browsers

00:16:15.570 --> 00:16:17.390
gets the really
great experience.

00:16:17.390 --> 00:16:20.610
And, you know, while
you're doing all of this,

00:16:20.610 --> 00:16:22.850
you also sort of
back in yourself

00:16:22.850 --> 00:16:24.970
to be able to do all
of the new cool stuff,

00:16:24.970 --> 00:16:27.150
like ServiceWorkers
that needs TLS.

00:16:27.150 --> 00:16:29.400
And if you want
fast TLS experience,

00:16:29.400 --> 00:16:32.080
you're going to want
to use SPDY or HTTP/2.

00:16:32.080 --> 00:16:34.920
So sort of do all of this
to get prepared to use

00:16:34.920 --> 00:16:37.450
all of the cool new stuff.

00:16:37.450 --> 00:16:39.200
PAUL LEWIS: All right,
so let's move on.

00:16:39.200 --> 00:16:42.130
A question from somebody who
label themselves as Time Hat.

00:16:42.130 --> 00:16:45.270
I'm not quite sure what
that is, but anyway.

00:16:45.270 --> 00:16:47.086
"For larger web
apps, what have you

00:16:47.086 --> 00:16:48.960
found to be the best
balance between serving?

00:16:48.960 --> 00:16:51.950
Like all resources needed
upfront, larger initial delay,

00:16:51.950 --> 00:16:54.590
providing resources needed
for a set of functionality

00:16:54.590 --> 00:16:57.120
on demand, like
just holding off?

00:16:57.120 --> 00:17:00.290
And how does that change with
ServiceWorker, if at all?"

00:17:00.290 --> 00:17:01.680
PAT MEENAN: Just really quickly.

00:17:01.680 --> 00:17:03.150
For the love of
God, please don't

00:17:03.150 --> 00:17:05.859
try to load something
the minute or the instant

00:17:05.859 --> 00:17:08.369
a user is trying
to do an action.

00:17:08.369 --> 00:17:11.520
You can fiddle and get
stuff in during idle cycles

00:17:11.520 --> 00:17:13.740
if you don't want to sort
of pay the upfront cost.

00:17:13.740 --> 00:17:17.260
But you really don't want to get
in the way of their activity.

00:17:17.260 --> 00:17:19.010
So if you're going
to delay something,

00:17:19.010 --> 00:17:22.970
don't delay it until they
actually go to use it.

00:17:22.970 --> 00:17:24.780
JAN MAESSEN: A second
order of concern here

00:17:24.780 --> 00:17:28.960
is to beware of radio
shutdown on mobile devices.

00:17:28.960 --> 00:17:32.130
That once the radios been
idle for long enough, it's

00:17:32.130 --> 00:17:35.490
going to take you longer to spin
the radio up and start loading

00:17:35.490 --> 00:17:38.630
the resources than it might
have done to load the resources

00:17:38.630 --> 00:17:41.291
you needed upfront while
the radio was still running.

00:17:41.291 --> 00:17:43.540
And it's going to eat more
of their battery too, which

00:17:43.540 --> 00:17:45.200
is going to piss them off.

00:17:45.200 --> 00:17:48.770
PAUL LEWIS: So since
there's no radio API,

00:17:48.770 --> 00:17:51.240
how should a developer attack
that particular problem?

00:17:51.240 --> 00:17:52.025
Should they just kind
of go, you know what?

00:17:52.025 --> 00:17:54.860
I'm just going to do it all up
front and hope for the best.

00:17:54.860 --> 00:17:57.080
What if it then, we're
talking about one, two, three

00:17:57.080 --> 00:17:57.910
megs of stuff?

00:17:57.910 --> 00:17:59.410
ALEX RUSSELL: So
we actually sort of

00:17:59.410 --> 00:18:02.530
see these problems show up
in large scale Google Apps.

00:18:02.530 --> 00:18:05.740
So Google Docs and
Gmail have this problem.

00:18:05.740 --> 00:18:08.000
They're putting megabytes
and JavaScript on the wire

00:18:08.000 --> 00:18:11.300
to help you get
through your day.

00:18:11.300 --> 00:18:12.950
And in Gmail's
case, what you see

00:18:12.950 --> 00:18:15.595
is that they will load
the whole package up front

00:18:15.595 --> 00:18:19.079
to optimize for
interaction latency.

00:18:19.079 --> 00:18:20.870
And Google Docs takes
a different approach,

00:18:20.870 --> 00:18:23.245
which is interesting, because
they've sort of constructed

00:18:23.245 --> 00:18:25.570
their applications so that
you load the initial content

00:18:25.570 --> 00:18:26.860
and you get the document.

00:18:26.860 --> 00:18:28.450
And then they load in editors.

00:18:28.450 --> 00:18:31.320
You load in these packages of
things, which sort of decorate

00:18:31.320 --> 00:18:33.824
the UI and make it
more interesting.

00:18:33.824 --> 00:18:35.490
The thing you can do
with ServiceWorkers

00:18:35.490 --> 00:18:37.700
that will allow you to maybe
do better in the future

00:18:37.700 --> 00:18:38.920
is if you structure
of your application

00:18:38.920 --> 00:18:41.180
in that way, where you've
loaded initial experience

00:18:41.180 --> 00:18:43.030
and then you decorate it later.

00:18:43.030 --> 00:18:45.636
You can make sure that
you've got those things

00:18:45.636 --> 00:18:47.010
starting to install,
and starting

00:18:47.010 --> 00:18:50.000
to be kept at your
initial page for you

00:18:50.000 --> 00:18:53.470
when you install your
ServiceWorker and register it.

00:18:53.470 --> 00:18:55.150
That activation and
installation phase

00:18:55.150 --> 00:18:57.310
will happen pretty
much while you've

00:18:57.310 --> 00:18:59.290
got the radio warmed
up the first time.

00:18:59.290 --> 00:19:01.070
And then the next time
you load the page,

00:19:01.070 --> 00:19:03.694
the Service Worker can know that
it's got those cache's filled,

00:19:03.694 --> 00:19:06.034
it's in control, you can
serve the full experience.

00:19:06.034 --> 00:19:08.450
So again, it's progressive
enhancement, the network layer.

00:19:08.450 --> 00:19:14.000
And it's going to be available
on mobile for Android

00:19:14.000 --> 00:19:15.060
beta in a couple weeks.

00:19:15.060 --> 00:19:16.970
And very soon towards
the end of the year.

00:19:16.970 --> 00:19:20.650
So you could start taking
advantage of that now.

00:19:20.650 --> 00:19:22.800
NAT DUCA: Please keep an
eye on your sprite sheets.

00:19:22.800 --> 00:19:24.950
We went through this
lovely experience recently.

00:19:24.950 --> 00:19:31.060
Where a well-meaning app
had a 26 megabyte sprite

00:19:31.060 --> 00:19:39.030
sheet for all the icons in
three different pixel densities.

00:19:39.030 --> 00:19:40.410
And that was unfortunate.

00:19:43.910 --> 00:19:47.420
So we've seen people putting
their eyes towards SVG,

00:19:47.420 --> 00:19:51.900
using source set, and
the picture element.

00:19:51.900 --> 00:19:55.730
And try to really use the
[? swish ?] screen if you can,

00:19:55.730 --> 00:19:58.680
because that combined
with HTTP/2--

00:19:58.680 --> 00:20:03.520
we're trying to articulate
a more sane way to do this.

00:20:03.520 --> 00:20:06.840
The reality of supporting
older browsers is still there.

00:20:06.840 --> 00:20:11.470
But say what you mean
is a really good thing

00:20:11.470 --> 00:20:14.460
to keep trying to do.

00:20:14.460 --> 00:20:17.670
Because 26 megabytes
is rough for us.

00:20:17.670 --> 00:20:19.200
PAUL LEWIS: Yeah,
that's sizable.

00:20:19.200 --> 00:20:20.995
That's something
else, isn't that?

00:20:20.995 --> 00:20:21.620
NAT DUCA: Yeah.

00:20:21.620 --> 00:20:22.150
PAUL LEWIS: OK.

00:20:22.150 --> 00:20:23.316
NAT DUCA: It was a good day.

00:20:23.316 --> 00:20:25.410
PAUL LEWIS: Yeah, I bet it was.

00:20:25.410 --> 00:20:26.750
But on the ServiceWorker thing.

00:20:26.750 --> 00:20:28.240
I get that it's the first load.

00:20:28.240 --> 00:20:29.250
You still have to care.

00:20:29.250 --> 00:20:31.740
And you still have to kind
of do a good first loading

00:20:31.740 --> 00:20:33.600
experience.

00:20:33.600 --> 00:20:37.110
And for more second
load and beyond,

00:20:37.110 --> 00:20:40.150
does that just solve all
network performance issues now?

00:20:40.150 --> 00:20:40.680
Are we done?

00:20:40.680 --> 00:20:42.960
Can we just kind
of say that's it?

00:20:42.960 --> 00:20:44.090
Now it's solved.

00:20:44.090 --> 00:20:46.423
Or is there anything that
ServiceWorker doesn't actually

00:20:46.423 --> 00:20:48.199
fix for us on the
networking side?

00:20:48.199 --> 00:20:50.490
ALEX RUSSELL: Aside from
actually making your breakfast

00:20:50.490 --> 00:20:51.940
and letting you ride
to work on a unicorn--

00:20:51.940 --> 00:20:53.882
PAUL LEWIS: Hey, I'm not
trying to dig at you.

00:20:53.882 --> 00:20:55.090
I'm trying to just make sure.

00:20:55.090 --> 00:20:57.215
Because we've all been
like, ServiceWorker, woohoo!

00:20:57.215 --> 00:21:00.510
And I'm just trying to make
sure is there any gotcha here.

00:21:00.510 --> 00:21:01.584
That's like--

00:21:01.584 --> 00:21:03.000
ALEX RUSSELL: So
it's worth noting

00:21:03.000 --> 00:21:05.749
that there are going to be
many users in the next couple

00:21:05.749 --> 00:21:08.040
of years who don't have
ServiceWorker-enabled browsers.

00:21:08.040 --> 00:21:11.620
And it's going to create
tension in your design.

00:21:11.620 --> 00:21:13.762
It's going to create a
difference that you're

00:21:13.762 --> 00:21:14.970
going to have to reckon with.

00:21:14.970 --> 00:21:16.924
And again, that first
load experience matters.

00:21:16.924 --> 00:21:18.840
And it's also important
to note that if you're

00:21:18.840 --> 00:21:20.675
going to be caching 26
megabyte spreadsheets

00:21:20.675 --> 00:21:22.800
into a ServiceWorker-- I
don't know that that makes

00:21:22.800 --> 00:21:25.940
it saner, but you
could-- you still

00:21:25.940 --> 00:21:27.840
have to download
the 26 megabytes.

00:21:27.840 --> 00:21:31.860
And if someone is paying per
kilobyte for a connection,

00:21:31.860 --> 00:21:36.480
that's still a pretty
crappy thing to do a person.

00:21:36.480 --> 00:21:39.150
And in fact, it could be
worse than today's experience.

00:21:39.150 --> 00:21:41.650
Because you're not going to see
the loading bar necessarily.

00:21:41.650 --> 00:21:44.725
And these may be bits of
UI that don't reflect stuff

00:21:44.725 --> 00:21:46.100
that you're
currently displaying.

00:21:46.100 --> 00:21:48.370
So it's going to be
worth paying attention

00:21:48.370 --> 00:21:49.940
to the overall budget.

00:21:49.940 --> 00:21:52.780
Again, we're going to
make the navigation timing

00:21:52.780 --> 00:21:54.366
and the resource
timing APIs available

00:21:54.366 --> 00:21:56.990
from inside the ServiceWorker at
some point in the near future,

00:21:56.990 --> 00:22:00.600
which will allow us to let you
have a handle on what you're

00:22:00.600 --> 00:22:03.100
doing and what the network looks
like from that perspective.

00:22:03.100 --> 00:22:04.220
But you are going
to have to stitch

00:22:04.220 --> 00:22:05.830
those experiences
together yourself.

00:22:05.830 --> 00:22:07.460
And it does create tension.

00:22:07.460 --> 00:22:09.900
It is going to
create opportunities,

00:22:09.900 --> 00:22:11.640
but they're
opportunities that we

00:22:11.640 --> 00:22:15.180
expect that you're going to
have to be careful about.

00:22:15.180 --> 00:22:16.670
PAUL LEWIS: Great.

00:22:16.670 --> 00:22:18.470
Just on ServiceWorker,
one final one.

00:22:18.470 --> 00:22:19.910
I think it's quite
good, this one.

00:22:19.910 --> 00:22:22.357
"Where is the line between
relying on the browser's

00:22:22.357 --> 00:22:24.690
historical caching mechanism,
like cache-control headers

00:22:24.690 --> 00:22:27.270
and so forth, and implementing
your own caching and saying,

00:22:27.270 --> 00:22:28.050
I will deal with this?

00:22:28.050 --> 00:22:30.500
Especially for starting on less
frequently changing content,

00:22:30.500 --> 00:22:32.833
where you're not quite sure,
should I go to the network,

00:22:32.833 --> 00:22:33.850
should I not."

00:22:33.850 --> 00:22:35.260
ALEX RUSSELL: So
the mental model

00:22:35.260 --> 00:22:37.640
that you can adopt when you're
thinking about the caches

00:22:37.640 --> 00:22:39.360
API instead of a
ServiceWorker is

00:22:39.360 --> 00:22:41.020
that it's like
reference counting,

00:22:41.020 --> 00:22:42.310
if you're familiar with that.

00:22:42.310 --> 00:22:45.220
It's the HTTP cache
sits logically

00:22:45.220 --> 00:22:46.520
behind the ServiceWorker.

00:22:46.520 --> 00:22:50.590
So it's like documents consults
service worker, consults cache,

00:22:50.590 --> 00:22:51.750
consults network.

00:22:51.750 --> 00:22:53.470
So there's now several
layers of faulting

00:22:53.470 --> 00:22:54.569
when you make a request.

00:22:54.569 --> 00:22:56.110
You can get it from
the ServiceWorker

00:22:56.110 --> 00:22:58.307
maybe and its caches.

00:22:58.307 --> 00:23:00.140
Or you can get it from
the local HTTP cache,

00:23:00.140 --> 00:23:01.790
if it's not expired
or evicted there.

00:23:01.790 --> 00:23:04.248
And maybe you can get it from
the network, if none of those

00:23:04.248 --> 00:23:05.760
have joy for you.

00:23:05.760 --> 00:23:09.930
And so what that means is
that the ServiceWorker's

00:23:09.930 --> 00:23:11.940
primary advantage
in terms of caching

00:23:11.940 --> 00:23:15.130
is knowing what's there,
not necessarily anything

00:23:15.130 --> 00:23:17.600
to do with eviction.

00:23:17.600 --> 00:23:18.580
Caches are coherent.

00:23:18.580 --> 00:23:21.980
That is to say, if you evict a
cache, it's going to all gone.

00:23:21.980 --> 00:23:24.390
And that's their primary virtue.

00:23:24.390 --> 00:23:27.920
You otherwise don't know
the state of the HTTP cache.

00:23:27.920 --> 00:23:30.660
ServiceWorkers let you hold
on to something longer then

00:23:30.660 --> 00:23:33.410
your cache headers would
otherwise allow you to.

00:23:33.410 --> 00:23:35.780
So the primary benefit
is that now you

00:23:35.780 --> 00:23:38.000
can understand what's
there and hold onto it

00:23:38.000 --> 00:23:40.840
in a way that is more reliable.

00:23:40.840 --> 00:23:43.980
The browser, when it goes to
throw away older resources,

00:23:43.980 --> 00:23:45.280
won't throw yours away.

00:23:45.280 --> 00:23:48.011
But if both the HTTP cache
would have still had it,

00:23:48.011 --> 00:23:49.760
and your ServiceWorker
is holding onto it,

00:23:49.760 --> 00:23:51.380
well it's still
going to be there.

00:23:51.380 --> 00:23:53.491
And when you're populating
your ServiceWorker,

00:23:53.491 --> 00:23:54.990
all the caching
headers that you set

00:23:54.990 --> 00:23:59.100
for the HTTP cache
will take control.

00:23:59.100 --> 00:24:02.310
So that is to say that if you
set so long expires header

00:24:02.310 --> 00:24:03.790
on some resource
that you are then

00:24:03.790 --> 00:24:05.874
going to hold onto from
inside your ServiceWorker,

00:24:05.874 --> 00:24:07.498
we don't have to go
back to the network

00:24:07.498 --> 00:24:09.580
to get it when you start
populating this caches.

00:24:09.580 --> 00:24:11.360
And so it's still
useful thing to do

00:24:11.360 --> 00:24:14.440
to set some distance forward
in the future for resources

00:24:14.440 --> 00:24:17.685
that you're going to put
in a ServiceWorker cache.

00:24:17.685 --> 00:24:20.060
PAUL LEWIS: Don't forget you
can ask questions in person.

00:24:20.060 --> 00:24:22.110
You can also tweet @ChromiumDev.

00:24:22.110 --> 00:24:24.642
And you can ask your questions
and I will find them.

00:24:24.642 --> 00:24:25.850
PAT MEENAN: And really quick.

00:24:25.850 --> 00:24:27.730
I think along those
lines, one of things

00:24:27.730 --> 00:24:29.720
that has me most excited
about ServiceWorker

00:24:29.720 --> 00:24:32.420
is being able to
stomp on the cache

00:24:32.420 --> 00:24:35.090
expires of
third-party resources.

00:24:35.090 --> 00:24:38.110
So I can do things like
stale-while-revalidate

00:24:38.110 --> 00:24:42.560
in ServiceWorker for the
ads.js, where I can say, hey,

00:24:42.560 --> 00:24:44.522
I'll always serve
whatever I have,

00:24:44.522 --> 00:24:46.230
then go out and fetch
whatever the latest

00:24:46.230 --> 00:24:47.313
version is on the network.

00:24:47.313 --> 00:24:49.020
If the network's
not there, great, it

00:24:49.020 --> 00:24:50.539
doesn't fail my page at all.

00:24:50.539 --> 00:24:51.330
ALEX RUSSELL: Yeah.

00:24:51.330 --> 00:24:53.010
One of the other things
that we've seen teams

00:24:53.010 --> 00:24:54.560
here talking about
with ServiceWorkers

00:24:54.560 --> 00:24:55.400
is-- they're starting
to investigate

00:24:55.400 --> 00:24:57.940
it-- is that many of our teams
have very large JavaScript

00:24:57.940 --> 00:25:00.797
payloads, and they'd like
to only serve a delta.

00:25:00.797 --> 00:25:02.380
But if you don't
know what's in cache,

00:25:02.380 --> 00:25:03.950
then you can't figure
out which delta to send

00:25:03.950 --> 00:25:05.030
and you don't know
how to apply it.

00:25:05.030 --> 00:25:06.010
The ServiceWorker
would let you do

00:25:06.010 --> 00:25:07.040
all of that programmatically.

00:25:07.040 --> 00:25:08.920
You could do it yourself
in code because you

00:25:08.920 --> 00:25:10.181
have all of the control.

00:25:10.181 --> 00:25:11.930
You have the ability
to start implementing

00:25:11.930 --> 00:25:14.910
truly exotic
strategies for reducing

00:25:14.910 --> 00:25:17.480
not just that upfront burden
and that second time burden,

00:25:17.480 --> 00:25:21.810
but the ongoing upgrade
costs of your application.

00:25:21.810 --> 00:25:23.340
NAT DUCA: Alex, in
a previous panel,

00:25:23.340 --> 00:25:24.990
mentioned this concept
of an app shell.

00:25:24.990 --> 00:25:26.364
And I think it's
really important

00:25:26.364 --> 00:25:29.590
to take that to heart in then
running with your caching

00:25:29.590 --> 00:25:30.740
decisions.

00:25:30.740 --> 00:25:34.219
This notion that the most
important thing for you to do--

00:25:34.219 --> 00:25:36.260
and this just falls out
of building a native app,

00:25:36.260 --> 00:25:39.790
for example-- is to get your
app up, get a spinner up

00:25:39.790 --> 00:25:41.860
if you have to,
but get content up.

00:25:41.860 --> 00:25:44.660
And go to server to
get more content.

00:25:44.660 --> 00:25:48.720
Or get your interface
up, and then show,

00:25:48.720 --> 00:25:50.380
and then provide clicking.

00:25:50.380 --> 00:25:52.940
And as long as you've got
enough of your shell up

00:25:52.940 --> 00:25:55.440
that you can provide
visual feedback

00:25:55.440 --> 00:25:56.910
that you're getting something.

00:25:56.910 --> 00:25:59.540
So if you tap down, if you
don't have your data back yet,

00:25:59.540 --> 00:26:04.620
give them some visual bling
that says, yo, I'm working.

00:26:04.620 --> 00:26:07.700
This is a much, much, much
better experience for people.

00:26:07.700 --> 00:26:11.510
And so if you start with that
idea of building a shell that

00:26:11.510 --> 00:26:13.750
then goes to the network,
you're going to end up,

00:26:13.750 --> 00:26:16.762
I think, in a better
place in the total run.

00:26:16.762 --> 00:26:18.470
Than if you start
bottom up and think I'm

00:26:18.470 --> 00:26:22.156
still shooting a page across
the wire in its entirety.

00:26:22.156 --> 00:26:24.030
SIDDHARTH VIJAYAKRISHNAN:
One note of caution

00:26:24.030 --> 00:26:27.380
about HTTP caches though,
is that you should never

00:26:27.380 --> 00:26:30.670
assume that reading
from the cache

00:26:30.670 --> 00:26:33.420
is always faster than
going out to the network.

00:26:33.420 --> 00:26:38.510
We have seen cases where they
take about the same time.

00:26:38.510 --> 00:26:40.910
This is because disk
reads from mobile

00:26:40.910 --> 00:26:43.690
can sometimes be
really painfully slow.

00:26:43.690 --> 00:26:45.440
ALEX RUSSELL: And it
gets worse on desktop

00:26:45.440 --> 00:26:48.070
where you've got anti-virus
software, which is, again,

00:26:48.070 --> 00:26:53.750
written primarily as a
practical joke on users.

00:26:53.750 --> 00:26:56.539
But disk reads can
be very, very bad.

00:26:56.539 --> 00:26:58.830
I'm not just up here to try
to sell you ServiceWorkers,

00:26:58.830 --> 00:27:00.780
but you should get some.

00:27:00.780 --> 00:27:02.860
But ServiceWorkers will
also allow you to race

00:27:02.860 --> 00:27:03.530
to the network.

00:27:03.530 --> 00:27:05.196
They'll let you race
disk in the network

00:27:05.196 --> 00:27:07.230
and respond with whichever
one comes back first.

00:27:07.230 --> 00:27:09.210
You have the control
to do that yourself.

00:27:09.210 --> 00:27:11.630
Which is, again, a new thing
you couldn't do before.

00:27:11.630 --> 00:27:13.110
So I'm very excited about that.

00:27:13.110 --> 00:27:16.020
PAUL LEWIS: I'm pretty sure
Jake's Trained to Thrill

00:27:16.020 --> 00:27:17.290
sample does that exact model.

00:27:17.290 --> 00:27:19.440
So if you're like,
how would I do that?

00:27:19.440 --> 00:27:20.080
There you go.

00:27:20.080 --> 00:27:20.260
ALEX RUSSELL: Yeah.

00:27:20.260 --> 00:27:22.860
And in terms of building
a shell and populating it.

00:27:22.860 --> 00:27:25.420
I, again, can't recommend
Jake's Trained to Thrill code

00:27:25.420 --> 00:27:26.550
base enough.

00:27:26.550 --> 00:27:29.640
It sort of has eked
out every last ounce

00:27:29.640 --> 00:27:30.864
of network performance there.

00:27:30.864 --> 00:27:33.030
Getting you out of the gates
quickly the first time.

00:27:33.030 --> 00:27:35.210
And then building
the app in a way that

00:27:35.210 --> 00:27:38.060
lets you be as fast
as you can locally.

00:27:38.060 --> 00:27:39.930
And then loading
new content later.

00:27:39.930 --> 00:27:43.070
It's a beautiful
exposition of how

00:27:43.070 --> 00:27:45.044
to architect your
app with the network.

00:27:45.044 --> 00:27:45.960
PAUL LEWIS: All right.

00:27:45.960 --> 00:27:48.340
So we're going to switch
gears up to the bit

00:27:48.340 --> 00:27:50.340
after it's loaded.

00:27:50.340 --> 00:27:51.590
60 frames a second.

00:27:51.590 --> 00:27:54.090
This is a question from your
lovely, warm-hearted moderator.

00:27:54.090 --> 00:27:57.430
60 frames a second seems
so hard to get on mobile,

00:27:57.430 --> 00:28:00.012
often requiring hacks
and code contortions.

00:28:00.012 --> 00:28:01.220
What's being done about this?

00:28:01.220 --> 00:28:04.200
And can we ever
realistically expect

00:28:04.200 --> 00:28:07.660
60 frames a second on
mobile to be the norm?

00:28:07.660 --> 00:28:09.805
NAT DUCA: Yes.

00:28:09.805 --> 00:28:12.180
PAUL LEWIS: And what's being
done to make that a reality?

00:28:12.180 --> 00:28:14.055
NAT DUCA: He's such a
warm-hearted moderator.

00:28:14.055 --> 00:28:15.540
PAUL LEWIS: I know.

00:28:15.540 --> 00:28:18.420
NAT DUCA: So Ryan
was up yesterday

00:28:18.420 --> 00:28:22.190
and gave this overview of how
we're just seriously focused

00:28:22.190 --> 00:28:24.150
on being wicked fast.

00:28:24.150 --> 00:28:28.200
We've done a huge amount
of work over the last year,

00:28:28.200 --> 00:28:30.940
not just looking
at 60 FPS, but just

00:28:30.940 --> 00:28:32.390
all the little details of that.

00:28:32.390 --> 00:28:35.500
Hundreds and hundreds
of bug fixes.

00:28:35.500 --> 00:28:39.610
60 or so major projects that
have gotten Chrome from that

00:28:39.610 --> 00:28:43.650
cited number of a 129.

00:28:43.650 --> 00:28:45.957
Not quite 128, which
would've been pleasing.

00:28:45.957 --> 00:28:47.040
PAUL LEWIS: Very pleasing.

00:28:47.040 --> 00:28:49.206
NAT DUCA: Very pleasing in
[? a monk ?] kind of way.

00:28:49.206 --> 00:28:52.060
PAUL LEWIS: I just
love all that.

00:28:52.060 --> 00:28:54.359
NAT DUCA: So we've
done that, but we're

00:28:54.359 --> 00:28:55.400
going to keep doing that.

00:28:55.400 --> 00:28:58.200
And so for example, the
GPU Rasterization project.

00:28:58.200 --> 00:29:00.860
We have it on some smaller
set of devices now.

00:29:00.860 --> 00:29:03.280
We're going to try to
get that everywhere.

00:29:03.280 --> 00:29:06.100
And then we're really looking
at all the secondary things

00:29:06.100 --> 00:29:08.390
on the main thread that happen.

00:29:08.390 --> 00:29:13.730
So for example, we're
looking at whether GC

00:29:13.730 --> 00:29:16.040
is hitting the right
time, right scheduling.

00:29:16.040 --> 00:29:17.960
We're looking at how
input is delivered

00:29:17.960 --> 00:29:19.751
and trying to figure
out ways to coordinate

00:29:19.751 --> 00:29:24.790
your scroll with your scroll
handler, for instance.

00:29:24.790 --> 00:29:26.095
What else are we doing, Paul?

00:29:26.095 --> 00:29:27.220
PAUL IRISH: Slimming Paint.

00:29:27.220 --> 00:29:28.261
NAT DUCA: Slimming Paint.

00:29:28.261 --> 00:29:32.860
We're re-architecting the
entire blank rendering engine,

00:29:32.860 --> 00:29:36.730
from the way it was
done since it was WebKit

00:29:36.730 --> 00:29:39.440
to this whole new thing that
we think will give us about two

00:29:39.440 --> 00:29:41.876
x more performance on Paint.

00:29:41.876 --> 00:29:42.750
Which is pretty cool.

00:29:42.750 --> 00:29:43.510
PAUL IRISH: Yeah, it's great.

00:29:43.510 --> 00:29:44.260
NAT DUCA: Or more.

00:29:44.260 --> 00:29:45.485
Five sometimes.

00:29:45.485 --> 00:29:47.709
PAUL IRISH: Yeah, it's a lot.

00:29:47.709 --> 00:29:50.250
It's interesting because a lot
of times you'll hear something

00:29:50.250 --> 00:29:51.666
like, Paul Lewis
will give a talk,

00:29:51.666 --> 00:29:54.860
and tell you these are
things like to follow.

00:29:54.860 --> 00:29:56.390
And these are your tips.

00:29:56.390 --> 00:29:58.870
And you should go and
write your app like this.

00:29:58.870 --> 00:29:59.680
And the good stuff.

00:29:59.680 --> 00:30:01.440
Yeah, certainly.

00:30:01.440 --> 00:30:04.820
And same time, we don't
just let Paul do the work

00:30:04.820 --> 00:30:06.480
and then say that
Chrome is done.

00:30:06.480 --> 00:30:08.200
We are very invested
in making sure

00:30:08.200 --> 00:30:10.990
that we can give you
that awesome performance

00:30:10.990 --> 00:30:12.990
that we're all chasing
after without you

00:30:12.990 --> 00:30:14.650
having to do all those hacks.

00:30:14.650 --> 00:30:16.900
So that's why a lot of
these projects like Ganesh,

00:30:16.900 --> 00:30:19.530
like Slimming Paint, a
lot of input latency work

00:30:19.530 --> 00:30:22.270
is all about what are
the fundamental platform

00:30:22.270 --> 00:30:24.400
improvements that we can
make to get you there,

00:30:24.400 --> 00:30:26.320
so you don't have to do things.

00:30:26.320 --> 00:30:28.570
PAUL LEWIS: One of the things
I often stand up and say

00:30:28.570 --> 00:30:29.880
is like, transform
an [? opac state. ?]

00:30:29.880 --> 00:30:31.980
Because these are like the
compositor only things,

00:30:31.980 --> 00:30:34.160
and everything
else will possibly

00:30:34.160 --> 00:30:36.630
cause huge jank
problems, probably.

00:30:36.630 --> 00:30:39.129
And so, do these
improvements actually

00:30:39.129 --> 00:30:41.420
mean that you could transition
width, height, left, top

00:30:41.420 --> 00:30:44.710
without causing a major problem?

00:30:44.710 --> 00:30:46.910
PAUL IRISH: So yes.

00:30:46.910 --> 00:30:49.784
So right now transform
capacity, fast.

00:30:49.784 --> 00:30:51.450
Fast across all
browsers, every browser.

00:30:51.450 --> 00:30:52.950
This is just something
that we-- all

00:30:52.950 --> 00:30:54.660
browsers, just through the GPU.

00:30:54.660 --> 00:30:58.110
When you animate, pretty
much every other attribute,

00:30:58.110 --> 00:30:59.590
it requires a lot more work.

00:30:59.590 --> 00:31:00.450
Things are slower.

00:31:00.450 --> 00:31:02.680
So that's why animate
left and top, or animate

00:31:02.680 --> 00:31:06.230
in height, not so great.

00:31:06.230 --> 00:31:08.250
It's painful, it's not good.

00:31:08.250 --> 00:31:12.040
A lot of the effects that
you see that are coming out

00:31:12.040 --> 00:31:14.570
is very dependent on a things
like a height animation.

00:31:14.570 --> 00:31:16.940
You have a height image and
you have things fading out.

00:31:16.940 --> 00:31:18.846
That should look and work great.

00:31:18.846 --> 00:31:20.220
And right now the
best you can do

00:31:20.220 --> 00:31:23.990
is basically just like try
and fake it with transforms.

00:31:23.990 --> 00:31:25.390
And it doesn't really work.

00:31:25.390 --> 00:31:27.410
And we don't think
you should have

00:31:27.410 --> 00:31:30.404
to go through those sorts of
contortions as a developer

00:31:30.404 --> 00:31:31.570
to get the sorts of effects.

00:31:31.570 --> 00:31:33.790
NAT DUCA: I like asking people
how many properties there

00:31:33.790 --> 00:31:34.365
are in CSS.

00:31:36.900 --> 00:31:39.270
And actually it's kind
of hard to answer it,

00:31:39.270 --> 00:31:41.280
which is very telling.

00:31:41.280 --> 00:31:44.600
But it's something like
115, if you're conservative,

00:31:44.600 --> 00:31:48.570
or 300 or 400, if you start
looking at the real world.

00:31:48.570 --> 00:31:49.580
It's a lot.

00:31:49.580 --> 00:31:50.170
Two are fast.

00:31:53.040 --> 00:31:54.460
Maybe three.

00:31:54.460 --> 00:31:55.840
PAUL IRISH: Yeah, two.

00:31:55.840 --> 00:31:58.090
NAT DUCA: There are two
directions that this could go.

00:31:58.090 --> 00:32:04.470
And where this heads is partly
a technical problem and partly

00:32:04.470 --> 00:32:07.800
audience participation
with other vendors.

00:32:07.800 --> 00:32:10.190
One direction is
that the browser

00:32:10.190 --> 00:32:13.300
starts making
painting properties.

00:32:13.300 --> 00:32:15.600
So look at csstriggers.com.

00:32:15.600 --> 00:32:16.970
PAUL LEWIS: Yeah.

00:32:16.970 --> 00:32:19.710
NAT DUCA: Painting properties,
like border color--

00:32:19.710 --> 00:32:21.340
this doesn't affect
where things are,

00:32:21.340 --> 00:32:23.900
it just changes the
visual appearance.

00:32:23.900 --> 00:32:27.760
We can make those
really, really fast.

00:32:27.760 --> 00:32:31.390
But if you look at all the
effects you see on mobile,

00:32:31.390 --> 00:32:33.800
things move around, right?

00:32:33.800 --> 00:32:35.740
It's nice for things
to change colors,

00:32:35.740 --> 00:32:38.450
but what really makes something
compelling is things move.

00:32:38.450 --> 00:32:41.380
And that's CSS layout,
and layout should be fast.

00:32:41.380 --> 00:32:44.940
The data show, when we
really, really dig into it,

00:32:44.940 --> 00:32:49.740
that we can run layout at 60
FPS without breaking a sweat.

00:32:49.740 --> 00:32:51.757
It's just that nobody
ever measured carefully

00:32:51.757 --> 00:32:52.590
and determined that.

00:32:52.590 --> 00:32:55.050
So where we think we
should go in the platform

00:32:55.050 --> 00:32:58.720
is to actually enable 60 FPS
mutation of any of your CSS

00:32:58.720 --> 00:33:01.910
properties, because that's
the natural way to do it.

00:33:01.910 --> 00:33:06.090
But that is a opinion held
by a lot of Chrome engineers.

00:33:06.090 --> 00:33:09.160
And we kind of need to
hear the audiences voice

00:33:09.160 --> 00:33:11.220
about whether that's
what you want too.

00:33:11.220 --> 00:33:12.777
Or whether you'd like us to--

00:33:12.777 --> 00:33:13.771
[APPLAUSE]

00:33:13.771 --> 00:33:16.619
PAUL LEWIS: That
sounds like a yes.

00:33:16.619 --> 00:33:18.910
It's hard to discern, I think
they need to clap louder.

00:33:18.910 --> 00:33:20.419
No it's--

00:33:20.419 --> 00:33:21.710
NAT DUCA: Go over to Cupertino.

00:33:21.710 --> 00:33:23.168
PAUL LEWIS: Just
to be super clear,

00:33:23.168 --> 00:33:24.860
you're saying that
you think it's

00:33:24.860 --> 00:33:27.100
possible to reach
60 frames a second,

00:33:27.100 --> 00:33:29.380
no matter which CSS
properties you change.

00:33:29.380 --> 00:33:31.290
NAT DUCA: Yes.

00:33:31.290 --> 00:33:32.380
PAUL LEWIS: I like that.

00:33:32.380 --> 00:33:34.022
PAT MEENAN: What about the "or"?

00:33:34.022 --> 00:33:36.230
PAUL LEWIS: Yeah, what was
part two of this one, Nat?

00:33:36.230 --> 00:33:38.170
NAT DUCA: Well, so
the hard part here

00:33:38.170 --> 00:33:42.370
is that requires some
really hard examination

00:33:42.370 --> 00:33:44.490
of the fundamentals
of web rendering.

00:33:44.490 --> 00:33:46.380
You have to really
start going we're

00:33:46.380 --> 00:33:48.530
going to optimize the
core of the render,

00:33:48.530 --> 00:33:53.040
rather than bolt on compositing
magic on the outside.

00:33:53.040 --> 00:33:56.070
And so what leads us to the
point of being able to say,

00:33:56.070 --> 00:33:58.050
we think we can
do this, is a year

00:33:58.050 --> 00:33:59.670
worth of major re-architecture.

00:33:59.670 --> 00:34:02.080
And another year already
planned of even more

00:34:02.080 --> 00:34:03.480
major re-architecture.

00:34:03.480 --> 00:34:05.470
That's a lot of work.

00:34:05.470 --> 00:34:08.139
We can do this because Chrome
and Google were determined

00:34:08.139 --> 00:34:09.139
to move the web forward.

00:34:09.139 --> 00:34:10.430
And so we think we can do this.

00:34:10.430 --> 00:34:14.969
But this is a tough order for
our friends in other vendors.

00:34:14.969 --> 00:34:16.864
And so the more
pragmatic thing here

00:34:16.864 --> 00:34:18.780
is to say, oh, that's
going to be really hard.

00:34:18.780 --> 00:34:22.330
Let's make background
color easy to animate.

00:34:22.330 --> 00:34:24.510
So it's a tough space.

00:34:24.510 --> 00:34:27.780
We sort of recognize
the tension here.

00:34:27.780 --> 00:34:29.949
I still think CSS is a
frigging awesome thing,

00:34:29.949 --> 00:34:31.040
and it's a shame to
throw it out when

00:34:31.040 --> 00:34:32.630
you want to grow
something taller.

00:34:32.630 --> 00:34:36.586
And you have to do
so by bypassing it.

00:34:36.586 --> 00:34:38.710
PAUL LEWIS: So in the
interim, while not everything

00:34:38.710 --> 00:34:44.370
is 60 FPS, 60 frames a second,
if, say, 30 frames a second

00:34:44.370 --> 00:34:47.400
looks less janky than
something variable.

00:34:47.400 --> 00:34:49.989
Are we saying to developers,
just kind of still go for 60,

00:34:49.989 --> 00:34:51.780
and just don't worry
about everything less?

00:34:51.780 --> 00:34:54.860
Or are there ways in which
we'd say, well, actually you

00:34:54.860 --> 00:34:56.210
should throttle back?

00:34:56.210 --> 00:34:58.890
Are we looking at ways that
we'd suggest people throttle?

00:34:58.890 --> 00:35:01.590
Or are we just sort of saying,
go for the best you can.

00:35:01.590 --> 00:35:03.021
And we'll try and do the rest.

00:35:03.021 --> 00:35:05.270
ALEX RUSSELL: So the web
proper platform traditionally

00:35:05.270 --> 00:35:06.478
has had a series of problems.

00:35:06.478 --> 00:35:08.910
You heard about web components
yesterday and Polymer.

00:35:08.910 --> 00:35:11.855
And that came from
some of us asking

00:35:11.855 --> 00:35:15.050
a question like, why can't
I do what the browser does?

00:35:15.050 --> 00:35:18.686
Why can't I run script to
do what it's clearly doing?

00:35:18.686 --> 00:35:19.560
It's parsing a thing.

00:35:19.560 --> 00:35:19.840
It's got a tag name.

00:35:19.840 --> 00:35:21.160
It looks it up in the table.

00:35:21.160 --> 00:35:23.060
It creates an instance of
that thing and spits it back.

00:35:23.060 --> 00:35:25.000
Why can't I be part
of that conversation?

00:35:25.000 --> 00:35:27.880
It's doing that work, why
can't I be part of it?

00:35:27.880 --> 00:35:31.710
Implicit in this question is
the reality that today in CSS,

00:35:31.710 --> 00:35:33.020
you can't be part of it.

00:35:33.020 --> 00:35:36.220
There's just no way that
you could figure out

00:35:36.220 --> 00:35:41.050
how style recalc is happening,
or when a frame is generated,

00:35:41.050 --> 00:35:42.820
and control that in
any meaningful way.

00:35:42.820 --> 00:35:44.680
We have requestAnimationFrame,
which is effectively

00:35:44.680 --> 00:35:46.138
a bolt on that
tells you when we're

00:35:46.138 --> 00:35:49.020
going to swap buffers
or something like that.

00:35:49.020 --> 00:35:51.800
And we've got CSS animations.

00:35:51.800 --> 00:35:53.430
But there's no API
that connects them.

00:35:53.430 --> 00:35:55.470
This is one of the fundamental
challenges of the way

00:35:55.470 --> 00:35:57.930
that we have to design new APIs
for the web platform, which

00:35:57.930 --> 00:35:59.810
is to draw these
connections together.

00:35:59.810 --> 00:36:03.080
And it's something that we,
frankly, on the API design

00:36:03.080 --> 00:36:05.490
side, have traditionally
done a very poor job of.

00:36:05.490 --> 00:36:07.554
Because it's much easier
to design a new feature

00:36:07.554 --> 00:36:08.470
that solves a problem.

00:36:08.470 --> 00:36:10.110
That someone says, hey,
I've got this problem.

00:36:10.110 --> 00:36:11.401
I want to make things animated.

00:36:11.401 --> 00:36:12.719
OK, we'll design some CSS.

00:36:12.719 --> 00:36:14.010
Hey, you can animate something.

00:36:14.010 --> 00:36:14.890
But I can't animate everything.

00:36:14.890 --> 00:36:16.010
But I want control.

00:36:16.010 --> 00:36:16.930
How do I do it?

00:36:16.930 --> 00:36:18.650
What we didn't do
was say, well here's

00:36:18.650 --> 00:36:20.500
an API that gives
you control that

00:36:20.500 --> 00:36:22.050
lets you do all this stuff.

00:36:22.050 --> 00:36:23.954
We have, I think
collectively, made

00:36:23.954 --> 00:36:26.120
a shift on the back of the
extensible web manifesto,

00:36:26.120 --> 00:36:28.930
and some of that other thinking
over the last couple of years,

00:36:28.930 --> 00:36:30.990
about how to deliver
new features to you.

00:36:30.990 --> 00:36:33.420
And I think the thing you
can continue to demand of us

00:36:33.420 --> 00:36:35.260
is why aren't those
two things connected?

00:36:35.260 --> 00:36:37.640
Tell me how we connect those.

00:36:37.640 --> 00:36:39.520
If I want to do it at
30 frames a second,

00:36:39.520 --> 00:36:42.040
what is the API that I
use to make that happen?

00:36:42.040 --> 00:36:43.140
Tell me what it is.

00:36:43.140 --> 00:36:45.330
And today, talking
to us, the answer

00:36:45.330 --> 00:36:47.810
is we haven't given it
to you, and that's on us.

00:36:47.810 --> 00:36:50.050
Our bad.

00:36:50.050 --> 00:36:52.360
NAT DUCA: I feel like I want
a bug report for this one.

00:36:52.360 --> 00:36:53.068
PAUL LEWIS: Yeah.

00:36:53.068 --> 00:36:53.827
That sounds good.

00:36:53.827 --> 00:36:55.660
NAT DUCA: The web needs
something like this.

00:36:55.660 --> 00:36:58.280
We do have the frame timing
API, I guess, coming.

00:36:58.280 --> 00:37:00.840
And that's going
to be pretty cool.

00:37:00.840 --> 00:37:03.250
And this gets back to some
of those device classes.

00:37:03.250 --> 00:37:05.660
Like, hey, yo, this is
like a really cheap device.

00:37:05.660 --> 00:37:10.920
Maybe I should show
the non-animated UI.

00:37:10.920 --> 00:37:13.000
So for example, we've
been working very closely

00:37:13.000 --> 00:37:16.030
with-- in L, so in
lollipop-- you'll

00:37:16.030 --> 00:37:18.290
see a new look to Google search.

00:37:18.290 --> 00:37:23.070
And that switches between a
"full material design with lots

00:37:23.070 --> 00:37:27.580
of animations" version and
a "it's still the same look,

00:37:27.580 --> 00:37:30.840
but there's no animations
on lower-end end devices."

00:37:30.840 --> 00:37:32.880
And that's a pretty
good technique.

00:37:32.880 --> 00:37:35.320
Right now, we do that
by user agent sniffing.

00:37:35.320 --> 00:37:36.939
[SIGHS]

00:37:36.939 --> 00:37:39.230
PAUL LEWIS: See, they sigh,
but really they enjoy that.

00:37:39.230 --> 00:37:40.310
NAT DUCA: But we do this.

00:37:40.310 --> 00:37:40.850
Yes, I know.

00:37:40.850 --> 00:37:42.975
PAUL LEWIS: They go actually,
I'm going to do that.

00:37:42.975 --> 00:37:44.150
NAT DUCA: It's this thing.

00:37:44.150 --> 00:37:45.422
We might want to do better.

00:37:45.422 --> 00:37:46.880
PAUL LEWIS: Going
back to the point

00:37:46.880 --> 00:37:49.614
you made about the
extensible web and so on,

00:37:49.614 --> 00:37:50.780
and explaining the platform.

00:37:50.780 --> 00:37:52.070
But there's been a rise.

00:37:52.070 --> 00:37:53.190
There's Famous.

00:37:53.190 --> 00:37:54.520
There is React.

00:37:54.520 --> 00:37:56.870
They sort of
virtualize the platform

00:37:56.870 --> 00:37:58.800
and explain things
in a different way,

00:37:58.800 --> 00:38:02.300
and then sort of
bake out to screen.

00:38:02.300 --> 00:38:06.270
And they certainly project
breakthroughs, right?

00:38:06.270 --> 00:38:08.400
By achieving 60 frames
a second for web apps,

00:38:08.400 --> 00:38:10.600
mobile apps, and
they've introduced

00:38:10.600 --> 00:38:13.560
DOM WebGL crazy mixed modes.

00:38:13.560 --> 00:38:14.880
What are the thoughts on this?

00:38:14.880 --> 00:38:18.370
Like should we be looking
at this kind of thing?

00:38:18.370 --> 00:38:19.920
Are there any
drawbacks that we see

00:38:19.920 --> 00:38:22.810
when people go in
this direction?

00:38:22.810 --> 00:38:27.080
Is that something you
guys want to talk about?

00:38:27.080 --> 00:38:29.535
NAT DUCA: I'm looking at
Paul, but I can attempt to--

00:38:29.535 --> 00:38:30.080
PAUL IRISH: Give it a shot.

00:38:30.080 --> 00:38:30.705
Give it a shot.

00:38:30.705 --> 00:38:32.060
NAT DUCA: OK.

00:38:32.060 --> 00:38:34.320
Famous is leading the way
in a lot of regards on this.

00:38:34.320 --> 00:38:35.340
And there are a couple
other frameworks

00:38:35.340 --> 00:38:36.550
that are just awesome.

00:38:39.480 --> 00:38:41.510
We want to look at those
effects and make sure

00:38:41.510 --> 00:38:43.635
that everybody can get to
them without a framework.

00:38:43.635 --> 00:38:46.400
And this is somewhat like the
story with Web Components,

00:38:46.400 --> 00:38:49.690
where we go, OK, you
can build a framework.

00:38:49.690 --> 00:38:52.690
But this is sometimes a
symptom of some deeper

00:38:52.690 --> 00:38:55.330
problem in the platform.

00:38:55.330 --> 00:38:57.800
If you have to do and
adopt an entire framework

00:38:57.800 --> 00:39:00.890
to move something from the
left side of the screen

00:39:00.890 --> 00:39:06.400
to the right side of the
screen, something's wrong.

00:39:06.400 --> 00:39:07.470
And we should fix that.

00:39:07.470 --> 00:39:08.530
Now--

00:39:08.530 --> 00:39:11.200
[APPLAUSE]

00:39:12.670 --> 00:39:15.670
I'll stop there.

00:39:15.670 --> 00:39:17.700
Ranting to the-- yeah.

00:39:17.700 --> 00:39:20.744
PAUL IRISH: Well, so,
I kind of disagree.

00:39:20.744 --> 00:39:21.410
NAT DUCA: Great.

00:39:21.410 --> 00:39:21.880
PAUL IRISH: In that--

00:39:21.880 --> 00:39:22.546
PAUL LEWIS: Yay.

00:39:22.546 --> 00:39:23.996
Conflict, go!

00:39:23.996 --> 00:39:26.160
Sorry, I was not
fighting for that at all.

00:39:26.160 --> 00:39:27.660
PAUL IRISH: Well,
basically I feel

00:39:27.660 --> 00:39:32.840
as though pulling off
a fantastic 60 FPS UI

00:39:32.840 --> 00:39:33.920
is really hard.

00:39:33.920 --> 00:39:36.650
And there's not a
huge amount of people

00:39:36.650 --> 00:39:39.650
that like know enough
to really do it.

00:39:39.650 --> 00:39:42.790
And so in many ways
for that experience,

00:39:42.790 --> 00:39:44.580
to see it scale
across all developers,

00:39:44.580 --> 00:39:48.550
we need frameworks to exist that
have that expertise behind it.

00:39:48.550 --> 00:39:50.790
This is just manage of
distribution of expertise

00:39:50.790 --> 00:39:52.123
and making sure that it's there.

00:39:52.123 --> 00:39:54.310
So things that like
Famous are doing,

00:39:54.310 --> 00:39:57.520
and things that Polymer
and Ionic are pursuing,

00:39:57.520 --> 00:40:00.120
it's all kind of
like giving everyone

00:40:00.120 --> 00:40:01.900
the ability to pull
this stuff off.

00:40:01.900 --> 00:40:05.920
And it's really important,
I think, as a developer,

00:40:05.920 --> 00:40:08.010
to target the sort of
experience that you want

00:40:08.010 --> 00:40:09.601
and chase that down.

00:40:09.601 --> 00:40:11.850
And maybe you go through a
framework, and that's good.

00:40:11.850 --> 00:40:13.391
On the platform, we
want to make sure

00:40:13.391 --> 00:40:17.490
that that effect is absolutely
available for everyone.

00:40:17.490 --> 00:40:22.260
But anyways, the sort
of things-- so Famous

00:40:22.260 --> 00:40:25.000
and what they're doing on
the UI is very inspiring.

00:40:25.000 --> 00:40:27.680
The sort of virtual DOM
stuff that React has done

00:40:27.680 --> 00:40:30.040
and now Ember is adopting
is really exciting.

00:40:30.040 --> 00:40:32.450
And it drives a lot of
the conversations that

00:40:32.450 --> 00:40:34.800
happen on the web
platform on how

00:40:34.800 --> 00:40:37.999
we can make sure that the sorts
of things that they're chasing,

00:40:37.999 --> 00:40:39.540
we just deliver
right out of the box.

00:40:39.540 --> 00:40:42.260
NAT DUCA: As always, Dr. Irish
is completely right here.

00:40:42.260 --> 00:40:46.180
So, you know, there's
the long-term,

00:40:46.180 --> 00:40:47.600
which I'm speaking
to, of like we

00:40:47.600 --> 00:40:49.090
want to bring this to everybody.

00:40:49.090 --> 00:40:52.212
But the reality is this
darn tough right now.

00:40:52.212 --> 00:40:53.920
One thing that's really
cool, by the way,

00:40:53.920 --> 00:40:55.900
is this Virtual DOM stuff.

00:40:55.900 --> 00:40:57.930
One of the fundamental
things we don't think we

00:40:57.930 --> 00:41:00.410
can make all that
much faster-- by which

00:41:00.410 --> 00:41:02.200
I mean I think we got
another 5x in us--

00:41:02.200 --> 00:41:04.500
but recalc style is hard.

00:41:04.500 --> 00:41:08.020
It's computationally evil.

00:41:08.020 --> 00:41:11.160
Somebody just did a
proof of how bad it is.

00:41:11.160 --> 00:41:12.879
It's terrible.

00:41:12.879 --> 00:41:13.920
PAUL LEWIS: How terrible?

00:41:17.411 --> 00:41:18.660
NAT DUCA: [? Runo ?] did this.

00:41:18.660 --> 00:41:20.520
He has this selector
that's like a comma

00:41:20.520 --> 00:41:22.850
a star comma a
twiddle star star.

00:41:22.850 --> 00:41:24.240
It's this horrible thing.

00:41:24.240 --> 00:41:25.190
PAUL LEWIS: That sounds
exactly like the CSS I'd write.

00:41:25.190 --> 00:41:27.770
NAT DUCA: It has to
recalc the entire world.

00:41:27.770 --> 00:41:29.550
This is not going to
get that much faster.

00:41:29.550 --> 00:41:32.810
Therefore, keep the
number of DOM elements

00:41:32.810 --> 00:41:34.515
that you have under control.

00:41:34.515 --> 00:41:35.890
And we've actually
been muttering

00:41:35.890 --> 00:41:39.452
about saying, keep to about
1,000 on mobile, not more.

00:41:39.452 --> 00:41:41.410
And then if you have to
have it more than 1,000

00:41:41.410 --> 00:41:46.410
due to scrolling, virtualize,
virtualize, defer,

00:41:46.410 --> 00:41:47.682
so on and so forth.

00:41:47.682 --> 00:41:48.640
So keep an eye on that.

00:41:48.640 --> 00:41:51.740
And Famous and React and a
bunch of people, you know,

00:41:51.740 --> 00:41:52.780
all the virtual lists.

00:41:52.780 --> 00:41:53.460
They're all doing this.

00:41:53.460 --> 00:41:55.126
This is super important
for performance.

00:41:57.670 --> 00:41:59.630
PAUL IRISH: Man.

00:41:59.630 --> 00:42:01.347
Descendant selectors.

00:42:01.347 --> 00:42:01.930
NAT DUCA: Yes.

00:42:01.930 --> 00:42:04.369
PAUL IRISH: It's a--
I've done presentations

00:42:04.369 --> 00:42:06.410
where I've been like,
guys, don't worry about it.

00:42:06.410 --> 00:42:07.320
Descendant selectors are fine.

00:42:07.320 --> 00:42:07.861
They're fast.

00:42:07.861 --> 00:42:09.270
Turns out--

00:42:09.270 --> 00:42:11.230
PAUL LEWIS: Is this is
an admission, my friend?

00:42:11.230 --> 00:42:13.340
PAUL IRISH: It is.

00:42:13.340 --> 00:42:14.910
NAT DUCA: Twiddle
is worse, though.

00:42:14.910 --> 00:42:16.700
PAUL IRISH: When we were in
2008, I was like they're slow.

00:42:16.700 --> 00:42:17.510
And then I'm like, they're fast.

00:42:17.510 --> 00:42:19.468
But it turns out they're
very fast to evaluate.

00:42:19.468 --> 00:42:23.686
But, this is that
recalc style thing.

00:42:23.686 --> 00:42:25.310
Descendant selector
in the recalc style

00:42:25.310 --> 00:42:27.590
introduces a lot more cost.

00:42:27.590 --> 00:42:29.680
And so staying specific
with class names--

00:42:29.680 --> 00:42:33.060
the sort of BEM style
class name architecture

00:42:33.060 --> 00:42:36.880
that people using these days
actually works incredibly well.

00:42:36.880 --> 00:42:38.790
And so [? taking ?]
your classes,

00:42:38.790 --> 00:42:40.910
very localized to
your component,

00:42:40.910 --> 00:42:44.400
is just a good way
to go going forward.

00:42:44.400 --> 00:42:47.797
And reduces this
cost of recalc style.

00:42:47.797 --> 00:42:49.630
PAUL LEWIS: To clarify
the recalc style bit.

00:42:49.630 --> 00:42:51.870
Does that mean that
during an animation--

00:42:51.870 --> 00:42:56.650
say I'm transitioning
something in an animation.

00:42:56.650 --> 00:42:58.810
Do we not figure out
that you're still

00:42:58.810 --> 00:43:02.090
talking about the same element,
and the recalc style just

00:43:02.090 --> 00:43:04.930
applies to that same element
that it did last frame?

00:43:04.930 --> 00:43:08.450
Or are you saying that we have
to kind of compute to the class

00:43:08.450 --> 00:43:11.010
name every single
time, and we never

00:43:11.010 --> 00:43:12.360
remember it between frames?

00:43:12.360 --> 00:43:13.732
Does that make sense?

00:43:13.732 --> 00:43:14.690
PAUL IRISH: Yeah, yeah.

00:43:14.690 --> 00:43:15.655
I think, uh--

00:43:15.655 --> 00:43:18.280
PAUL LEWIS: It just seems like,
it feels like if it's expensive

00:43:18.280 --> 00:43:19.580
we should do it
once and cache that.

00:43:19.580 --> 00:43:21.370
NAT DUCA: He's now gone
off in outer space.

00:43:21.370 --> 00:43:22.330
PAUL LEWIS: Sorry, man.

00:43:22.330 --> 00:43:23.250
I'm just thinking out loud.

00:43:23.250 --> 00:43:24.890
NAT DUCA: CSS is
computational evil.

00:43:24.890 --> 00:43:26.870
And here's the problem.

00:43:26.870 --> 00:43:32.200
Any time you do anything
at the sort of basic level,

00:43:32.200 --> 00:43:36.400
any time you mutate a class,
any time you mutate a style,

00:43:36.400 --> 00:43:40.400
technically we have to go
recompute the universe.

00:43:40.400 --> 00:43:41.640
Like every single element.

00:43:41.640 --> 00:43:45.527
So we learn Big O notation
in undergrad, right?

00:43:45.527 --> 00:43:47.985
Or somebody beats us over the
head with it, and we're like,

00:43:47.985 --> 00:43:48.920
screw this.

00:43:48.920 --> 00:43:51.790
But the fundamental
thing here is

00:43:51.790 --> 00:43:56.450
that CSS can get as bad as all
of the elements in your DOM

00:43:56.450 --> 00:43:59.900
times all of your selectors.

00:43:59.900 --> 00:44:03.000
And like this whole,
is descendant selector

00:44:03.000 --> 00:44:07.120
fast, is the ancestor
selector fast,

00:44:07.120 --> 00:44:09.380
that's actually just
a secondary sideshow.

00:44:09.380 --> 00:44:14.130
The fundamental is CSS is slow.

00:44:14.130 --> 00:44:17.460
And then we have these magical,
horrible, really painful

00:44:17.460 --> 00:44:20.930
to understand tricks
for certain selectors.

00:44:20.930 --> 00:44:23.590
That instead of having to check
all of the universe every time

00:44:23.590 --> 00:44:26.550
you do anything, we check
some of the universe.

00:44:26.550 --> 00:44:30.157
And so direct
descendant selectors

00:44:30.157 --> 00:44:32.740
are really the only ones that
we can do faster, or just class.

00:44:32.740 --> 00:44:37.235
So the BEM style happens to make
the computational complexity

00:44:37.235 --> 00:44:42.472
of this closer to the amount
of change you've done.

00:44:42.472 --> 00:44:43.930
PAUL LEWIS: Now,
earlier you said--

00:44:43.930 --> 00:44:45.470
NAT DUCA: Then I just
went off into outer space.

00:44:45.470 --> 00:44:46.330
PAUL LEWIS: I know,
but I like it.

00:44:46.330 --> 00:44:47.180
You can join me in the universe.

00:44:47.180 --> 00:44:48.500
NAT DUCA: We'll try
to explain this over,

00:44:48.500 --> 00:44:50.590
and over, and over, because
this one of the true evils.

00:44:50.590 --> 00:44:51.380
PAUL LEWIS: Earlier
you were saying

00:44:51.380 --> 00:44:53.440
that you'd be ashamed
to throw out CSS.

00:44:53.440 --> 00:44:55.790
But at the same time,
CSS is horrible and slow

00:44:55.790 --> 00:44:58.945
and we want people to make
fast performing sites and apps.

00:44:58.945 --> 00:44:59.570
NAT DUCA: Yeah.

00:44:59.570 --> 00:45:02.270
We need to make an effigy of it.

00:45:02.270 --> 00:45:05.500
PAUL IRISH: I think part of it
is just that, the issue here

00:45:05.500 --> 00:45:10.170
is that the algorithm and the
cost for calculating styles

00:45:10.170 --> 00:45:11.192
is it's specified.

00:45:11.192 --> 00:45:12.900
It is a thing that
all browsers agree on.

00:45:12.900 --> 00:45:16.200
And so it's not like something
that we can just make faster.

00:45:16.200 --> 00:45:17.700
ALEX RUSSELL: CSS--
by the way, this

00:45:17.700 --> 00:45:19.533
is one of the best
things about Shadow DOM--

00:45:19.533 --> 00:45:21.600
is that it finally lets
you encapsulate right.

00:45:21.600 --> 00:45:22.990
CSS works when it's small.

00:45:22.990 --> 00:45:25.830
CSS is fine when
you've got like five

00:45:25.830 --> 00:45:27.940
elements and a couple of rules.

00:45:27.940 --> 00:45:33.910
CSS scales like a
Buick off a cliff.

00:45:33.910 --> 00:45:34.647
It is terrible.

00:45:34.647 --> 00:45:36.980
PAUL LEWIS: That's bad, right,
for anybody who's like me

00:45:36.980 --> 00:45:38.271
and don't know what a Buick is.

00:45:38.271 --> 00:45:42.110
NAT DUCA: Although if
you have one element,

00:45:42.110 --> 00:45:44.000
it scales like a
Buick off the cliff.

00:45:44.000 --> 00:45:47.360
But if you have two elements
in your DOM, just two,

00:45:47.360 --> 00:45:50.600
and no selectors.

00:45:50.600 --> 00:45:55.142
We have to check 82 different
permutations just for two.

00:45:55.142 --> 00:45:56.600
So this is just to
give you an idea

00:45:56.600 --> 00:45:57.725
of the scope of this thing.

00:45:57.725 --> 00:45:58.740
It's pretty terrible.

00:45:58.740 --> 00:46:01.410
And then you have three,
and it's 82 times 3.

00:46:01.410 --> 00:46:01.910
It's bad.

00:46:01.910 --> 00:46:03.580
PAUL IRISH: And just
to scope all this,

00:46:03.580 --> 00:46:05.730
we're merely talking
about style calculation.

00:46:05.730 --> 00:46:09.890
And so this is the recalc
style, and purple, and timeline,

00:46:09.890 --> 00:46:12.310
which is a fraction of
everything that's happening.

00:46:12.310 --> 00:46:12.520
ALEX RUSSELL: Yeah.

00:46:12.520 --> 00:46:14.210
So we've paid a lot of attention
to this particular problem.

00:46:14.210 --> 00:46:15.580
And it's a small portion
of your frames today.

00:46:15.580 --> 00:46:17.038
You're going to
see a lot more time

00:46:17.038 --> 00:46:19.000
in well-architected
apps in Paint today.

00:46:19.000 --> 00:46:20.962
And so that's why we're focusing
in the next year on Paint

00:46:20.962 --> 00:46:21.570
Slimming.

00:46:21.570 --> 00:46:24.531
PAUL LEWIS: OK, as you-- Oh,
Jan, did you have something?

00:46:24.531 --> 00:46:25.030
OK.

00:46:25.030 --> 00:46:27.660
I just wanted to move us on.

00:46:27.660 --> 00:46:30.157
So "Chrome has landed a
lot of ES6 features lately.

00:46:30.157 --> 00:46:32.240
But they're often so slow
that they're not usable.

00:46:32.240 --> 00:46:33.281
Can you make them faster?

00:46:33.281 --> 00:46:35.662
Now I think yes, OK.

00:46:35.662 --> 00:46:37.120
But I think the
question is really,

00:46:37.120 --> 00:46:39.360
how do we prioritize our
performance workload?

00:46:39.360 --> 00:46:42.290
And how are we deciding
what needs optimizing when,

00:46:42.290 --> 00:46:44.270
and we make sure that
it fits developer needs.

00:46:44.270 --> 00:46:45.820
I think that what that's
really driving at.

00:46:45.820 --> 00:46:46.590
Are we all happy?

00:46:46.590 --> 00:46:47.240
Yeah.

00:46:47.240 --> 00:46:47.960
OK.

00:46:47.960 --> 00:46:49.050
Who wants to go?

00:46:49.050 --> 00:46:50.165
Who decides the workload?

00:46:52.177 --> 00:46:54.760
ALEX RUSSELL: So I just want to
give a little insight into how

00:46:54.760 --> 00:46:56.840
new language features get built.

00:46:56.840 --> 00:47:00.080
So one of the things
that I have done

00:47:00.080 --> 00:47:02.250
is to participate
in the TC39 process

00:47:02.250 --> 00:47:05.344
for defining new
standards for JavaScript,

00:47:05.344 --> 00:47:06.510
new features for JavaScript.

00:47:06.510 --> 00:47:10.510
And so defining a new feature
actually for the web platform

00:47:10.510 --> 00:47:11.740
requires iteration.

00:47:11.740 --> 00:47:14.430
It requires us to turn the
crank a couple times to decide

00:47:14.430 --> 00:47:18.865
that something that looks like
a real use case has a solution,

00:47:18.865 --> 00:47:20.740
and that we like the
solution, and that users

00:47:20.740 --> 00:47:22.940
like the solution, and
that we can make it fast.

00:47:22.940 --> 00:47:24.420
That's an iterative process.

00:47:24.420 --> 00:47:26.770
That's a process that
requires us to do experiments.

00:47:26.770 --> 00:47:27.900
See how they go.

00:47:27.900 --> 00:47:29.130
See how it feels.

00:47:29.130 --> 00:47:31.310
Write [? transpilers ?]
like traceur

00:47:31.310 --> 00:47:33.410
that will allow us to use
a feature early and then

00:47:33.410 --> 00:47:34.730
figure out how it goes.

00:47:34.730 --> 00:47:36.685
One of the things you
can always count on

00:47:36.685 --> 00:47:38.310
is that if a feature
gets a lot of use,

00:47:38.310 --> 00:47:40.950
we're going to make it fast,
as fast as we possibly can.

00:47:40.950 --> 00:47:42.372
That's a thing we do.

00:47:42.372 --> 00:47:44.580
That is one of the best
things that we could possibly

00:47:44.580 --> 00:47:45.280
do for you.

00:47:45.280 --> 00:47:47.280
And so we're going to
continue to focus on that.

00:47:47.280 --> 00:47:49.310
If there's a new ES6
feature, the reason

00:47:49.310 --> 00:47:52.030
that it might be slow
is that it's new.

00:47:52.030 --> 00:47:55.120
Now would you rather have a new
feature that isn't completely

00:47:55.120 --> 00:47:59.190
optimized all the way
through [INAUDIBLE] yet?

00:47:59.190 --> 00:48:01.230
Or would you rather not
have the new feature?

00:48:01.230 --> 00:48:03.646
And if your answer is I would
rather not have new feature,

00:48:03.646 --> 00:48:05.920
I think you're not
with it entirely.

00:48:05.920 --> 00:48:08.470
Because let's talk
about slow and fast.

00:48:08.470 --> 00:48:11.620
Slow and fast in
JavaScript today is,

00:48:11.620 --> 00:48:14.910
slow is 1,000 times
faster than fast

00:48:14.910 --> 00:48:17.390
was when I was writing
JavaScript and making

00:48:17.390 --> 00:48:18.440
libraries.

00:48:18.440 --> 00:48:21.570
Like we don't have
an interpreter in V8.

00:48:21.570 --> 00:48:23.450
We only JIT.

00:48:23.450 --> 00:48:25.860
OK, that's slow?

00:48:25.860 --> 00:48:29.220
OK, let's talk about your work
load and what you're doing.

00:48:29.220 --> 00:48:30.930
So these are relative questions.

00:48:30.930 --> 00:48:34.290
And today we're going to
introduce new features.

00:48:34.290 --> 00:48:36.980
We need to get new features
out faster, I agree with that.

00:48:36.980 --> 00:48:39.880
And those features need to get
faster, I agree with that too.

00:48:39.880 --> 00:48:44.400
Please form your question--
Linus Upson said this.

00:48:44.400 --> 00:48:46.120
Please phrase your
question in the form

00:48:46.120 --> 00:48:48.677
of a benchmark and we
will pay attention to it.

00:48:48.677 --> 00:48:50.260
PAUL LEWIS: We've
got a live question.

00:48:50.260 --> 00:48:51.095
Go for it.

00:48:51.095 --> 00:48:51.720
AUDIENCE: Sure.

00:48:55.040 --> 00:48:58.590
You talked a lot
about recalc style.

00:48:58.590 --> 00:49:01.240
And you mentioned virtual
lists and virtual DOMs.

00:49:01.240 --> 00:49:03.225
There's a lot of
frameworks kicking around.

00:49:03.225 --> 00:49:04.850
There's a lot
performance optimizations

00:49:04.850 --> 00:49:06.860
that we are trying
to do at the moment

00:49:06.860 --> 00:49:12.760
around batching expensive layout
triggering DOM operations.

00:49:12.760 --> 00:49:17.300
Most of that is a lot
of mental overhead

00:49:17.300 --> 00:49:20.650
and quite often very hackey.

00:49:20.650 --> 00:49:23.660
Are there ways that
the browser will

00:49:23.660 --> 00:49:27.010
be able to learn to take
care of this stuff in a more

00:49:27.010 --> 00:49:28.604
performant, more
intelligent way?

00:49:28.604 --> 00:49:30.520
And is that something
you're going to work on?

00:49:30.520 --> 00:49:34.670
NAT DUCA: One of
the things that I'm

00:49:34.670 --> 00:49:38.540
really excited about for this
coming year is a measure API.

00:49:38.540 --> 00:49:40.950
Finally, element.measure.

00:49:40.950 --> 00:49:42.600
And the reason I'm
excited about this--

00:49:42.600 --> 00:49:45.490
and you can measure an element
without even attaching it

00:49:45.490 --> 00:49:48.600
to the DOM by giving it
some initial constraints.

00:49:48.600 --> 00:49:51.636
It's going to be
frigging awesome.

00:49:51.636 --> 00:49:53.010
The reason this
is really neat is

00:49:53.010 --> 00:49:55.172
because right now,
all of this-- there

00:49:55.172 --> 00:49:56.880
are a couple of great
libraries out there

00:49:56.880 --> 00:50:01.900
that are sort of mutate
measure, measure mutate, right?

00:50:01.900 --> 00:50:04.540
That are meant to
avoid style thrashing.

00:50:04.540 --> 00:50:09.747
That's sort of the way to cope
with the web as it is today.

00:50:09.747 --> 00:50:11.330
But it's all a Bandaid
around the fact

00:50:11.330 --> 00:50:13.300
that any time you
attach to the DOM,

00:50:13.300 --> 00:50:14.810
there are these
global operations

00:50:14.810 --> 00:50:16.685
that happen that are
proportional to the size

00:50:16.685 --> 00:50:17.700
of the universe.

00:50:17.700 --> 00:50:20.630
And so when you want to measure
a little thing that's just

00:50:20.630 --> 00:50:23.820
the size of a card, and you
want to know, how wide is this?

00:50:23.820 --> 00:50:25.110
How wide does it want to be?

00:50:25.110 --> 00:50:26.680
Currently, we
actually recalculate

00:50:26.680 --> 00:50:29.360
the size of the
universe and recalculate

00:50:29.360 --> 00:50:30.527
all of your elements.

00:50:30.527 --> 00:50:32.110
And so this is why
it's actually slow.

00:50:34.730 --> 00:50:37.460
Measure will not
have this property.

00:50:37.460 --> 00:50:40.090
So it'll be considerably
less the suck.

00:50:40.090 --> 00:50:41.390
So that's coming.

00:50:41.390 --> 00:50:43.280
And I think we should
be super excited.

00:50:43.280 --> 00:50:47.050
PAUL LEWIS: So what's the
difference between getting

00:50:47.050 --> 00:50:49.650
a measurement-- like saying,
give me all the things

00:50:49.650 --> 00:50:53.590
you know about this-- and
then setting width and height.

00:50:55.949 --> 00:50:57.740
What are anticipating
developers are really

00:50:57.740 --> 00:50:59.650
going to use the measure
API for that they

00:50:59.650 --> 00:51:00.680
couldn't do otherwise?

00:51:00.680 --> 00:51:05.140
NAT DUCA: Well actually,
in the Dev summit site,

00:51:05.140 --> 00:51:08.900
we saw in Paul's
talk about you want

00:51:08.900 --> 00:51:10.692
to move a card from
where it is in your UI.

00:51:10.692 --> 00:51:12.066
You have a button
and you want it

00:51:12.066 --> 00:51:13.450
to grow to take over the screen.

00:51:13.450 --> 00:51:14.980
But you want it to
take it over the screen

00:51:14.980 --> 00:51:16.590
and maybe you want to center
it or something, right?

00:51:16.590 --> 00:51:19.000
So to do this, you have
to set up an animation

00:51:19.000 --> 00:51:21.040
to scale from one to the other.

00:51:21.040 --> 00:51:23.242
So that means you need
to know from and to.

00:51:23.242 --> 00:51:24.950
And typically, the
way you do that is you

00:51:24.950 --> 00:51:26.300
use getComputedSize.

00:51:26.300 --> 00:51:29.829
Or you do any number
of these, right?

00:51:29.829 --> 00:51:32.370
getClientBoundingRect, that's
the one that I'm trying to say.

00:51:32.370 --> 00:51:32.815
PAUL LEWIS: I love that.

00:51:32.815 --> 00:51:33.700
Oh, yeah.

00:51:33.700 --> 00:51:35.249
It's my new best friend, BFFs.

00:51:35.249 --> 00:51:37.290
NAT DUCA: I mean there is
getComputedStyle.width,

00:51:37.290 --> 00:51:38.960
which is funky.

00:51:38.960 --> 00:51:41.480
So there are all these
things that people do now.

00:51:41.480 --> 00:51:45.560
But those trigger
world-sized calculations.

00:51:45.560 --> 00:51:48.670
And so that's really the
thing we're trying to fix.

00:51:48.670 --> 00:51:51.220
PAUL IRISH: And do they have to?

00:51:51.220 --> 00:51:52.530
NAT DUCA: Yes.

00:51:52.530 --> 00:51:54.999
I mean, we can fix it.

00:51:54.999 --> 00:51:57.040
Like, we're continually
trying to make it better.

00:51:57.040 --> 00:52:00.290
But this gets to, is the
platform predictable?

00:52:03.580 --> 00:52:06.250
Like one of the nice things
about transform and opacity,

00:52:06.250 --> 00:52:10.354
as a developer, I think, is
that when you do figure out

00:52:10.354 --> 00:52:12.770
how to make your effect work
with the transform animation,

00:52:12.770 --> 00:52:14.619
it's going to be pretty fast.

00:52:14.619 --> 00:52:16.660
So there's this mental
model that you can form it

00:52:16.660 --> 00:52:21.100
in your head about if I do
it this way, it will be fast.

00:52:21.100 --> 00:52:25.671
When you do get computed client
bounding wrecked square thingy.

00:52:25.671 --> 00:52:27.170
PAUL LEWIS: That's
it's actual name.

00:52:27.170 --> 00:52:28.207
It's only alias to--

00:52:28.207 --> 00:52:29.040
[INTERPOSING VOICES]

00:52:29.040 --> 00:52:32.650
NAT DUCA: Thingy subfixes
to go with browser prefixes.

00:52:32.650 --> 00:52:36.630
When you do that, it
sometimes is fast.

00:52:36.630 --> 00:52:39.590
And then sometimes it's
catastrophically slow.

00:52:39.590 --> 00:52:41.470
That's fine for like
getting by, but I

00:52:41.470 --> 00:52:45.020
don't think that's what we want
to hang a web platform from.

00:52:45.020 --> 00:52:49.380
PAUL IRISH: I will point out, as
part of the render performance

00:52:49.380 --> 00:52:53.800
work that's happened recently,
a lot of these issues

00:52:53.800 --> 00:52:55.670
around layout thrashing
have gotten better.

00:52:55.670 --> 00:52:58.170
So if you go and look at like
those blog posts around layout

00:52:58.170 --> 00:53:00.040
thrashing and see the demo
where it's like, try this,

00:53:00.040 --> 00:53:00.998
it's terrible and slow.

00:53:00.998 --> 00:53:02.180
Try this, it's fast.

00:53:02.180 --> 00:53:04.820
Slow is actually not as
bad as it was before.

00:53:04.820 --> 00:53:06.660
So there's been
platform improvements

00:53:06.660 --> 00:53:08.510
to just make that faster.

00:53:08.510 --> 00:53:13.940
And we're a lot more
knowledgeable now on the Chrome

00:53:13.940 --> 00:53:15.710
side about when we
invalidate something,

00:53:15.710 --> 00:53:19.030
when we say that the geometry
or the pixels on that screen

00:53:19.030 --> 00:53:20.410
are our old.

00:53:20.410 --> 00:53:23.400
And we have a lot more insight
into how we do that, and make

00:53:23.400 --> 00:53:25.710
sure that we don't
over invalidate.

00:53:25.710 --> 00:53:28.590
So that means we can
reduce the amount of work

00:53:28.590 --> 00:53:29.560
that we end up doing.

00:53:29.560 --> 00:53:31.274
PAUL LEWIS: Question on tooling.

00:53:31.274 --> 00:53:32.940
"Page speed insights
and web based tests

00:53:32.940 --> 00:53:36.060
are both really useful to
help improve loading times.

00:53:36.060 --> 00:53:38.340
Are there any plans to
extend either or both

00:53:38.340 --> 00:53:41.059
to measure runtime concerns,
such as idle FPS, scrolling

00:53:41.059 --> 00:53:43.350
FPS, memory usage, long paint
times, and the prevalence

00:53:43.350 --> 00:53:45.930
of layout thrashing,
just as examples,?

00:53:45.930 --> 00:53:46.560
Pat?

00:53:46.560 --> 00:53:47.230
PAT MEENAN: Oh, is that all?

00:53:47.230 --> 00:53:48.610
PAUL LEWIS: Yeah, you know.

00:53:48.610 --> 00:53:49.318
PAT MEENAN: Yeah.

00:53:49.318 --> 00:53:51.340
I mean, so
traditionally it's been

00:53:51.340 --> 00:53:54.270
about figuring out where
people's pain points are,

00:53:54.270 --> 00:53:57.950
and trying to expose that
as easily as possible.

00:53:57.950 --> 00:53:59.890
Sort of the raw,
easy version of that

00:53:59.890 --> 00:54:02.440
was just implement
timeline and tracing.

00:54:02.440 --> 00:54:04.354
So you can get that
from both of them.

00:54:04.354 --> 00:54:06.020
One of the things
that's been on my list

00:54:06.020 --> 00:54:08.520
for probably the last year and
I just haven't had time to do

00:54:08.520 --> 00:54:09.910
yet is, to do a scroll test.

00:54:09.910 --> 00:54:12.440
After your page loads, go
ahead and fling the page,

00:54:12.440 --> 00:54:17.870
and do the same jank kind of
stuff that Telemetry does.

00:54:17.870 --> 00:54:20.370
It'd be interesting to get some
feedback from people on sort

00:54:20.370 --> 00:54:23.610
of what their pain points are,
and what they want measured.

00:54:23.610 --> 00:54:25.610
I kind of like being
able to provide

00:54:25.610 --> 00:54:28.630
sort of low-level information
and not try and round

00:54:28.630 --> 00:54:31.010
everything up to a,
yeah, you're doing great

00:54:31.010 --> 00:54:32.230
or you're not doing so great.

00:54:32.230 --> 00:54:34.712
It's like, OK, when you get
halfway through your page,

00:54:34.712 --> 00:54:36.420
you start to jank or
something like that.

00:54:36.420 --> 00:54:38.240
So that's why I've
sort of leaned

00:54:38.240 --> 00:54:41.570
on giving timeline
and tracing available,

00:54:41.570 --> 00:54:44.620
because you have like so
much data in there already

00:54:44.620 --> 00:54:48.180
and great presentation
in those tools.

00:54:48.180 --> 00:54:50.782
It's kind of one of
those fine lines to walk.

00:54:50.782 --> 00:54:52.740
JAN MAESSEN: And I know
the page speed insights

00:54:52.740 --> 00:54:56.820
team has been looking a
lot at mobile usability.

00:54:56.820 --> 00:55:02.230
And one of the aspects of
that is UI responsiveness.

00:55:02.230 --> 00:55:04.230
So far they've been
looking mostly at,

00:55:04.230 --> 00:55:07.320
can you use the UI at
all on a mobile device?

00:55:07.320 --> 00:55:10.166
Because that's a really
important question.

00:55:10.166 --> 00:55:11.790
That's sort of the
first order question

00:55:11.790 --> 00:55:13.370
when you're visiting on mobile.

00:55:13.370 --> 00:55:15.130
But I think sort of
the next big question

00:55:15.130 --> 00:55:19.660
is, now that you know
the UI is usable,

00:55:19.660 --> 00:55:23.540
you can touch the buttons.

00:55:23.540 --> 00:55:26.230
Are things actually
responding well?

00:55:26.230 --> 00:55:28.770
PAUL IRISH: I'm just going
to add a quick thing.

00:55:28.770 --> 00:55:32.570
The Chrome developer tools, you
can go in the network panel,

00:55:32.570 --> 00:55:33.820
see what the network activity.

00:55:33.820 --> 00:55:36.230
There is a waterfall.

00:55:36.230 --> 00:55:38.860
But for professionals that are
trying to understand the user

00:55:38.860 --> 00:55:40.860
experience of page loading,
pretty much everyone

00:55:40.860 --> 00:55:44.325
heads over to WebPagetest, where
they get a lot of information.

00:55:44.325 --> 00:55:47.006
At Dev tools, we're
really inspired by this.

00:55:47.006 --> 00:55:49.630
The sorts of things that you see
in Filmstrip and understanding

00:55:49.630 --> 00:55:53.100
speed index really
give a whole insight

00:55:53.100 --> 00:55:54.400
into what the critical path is.

00:55:54.400 --> 00:55:57.780
And so we are looking to
do more work around this.

00:55:57.780 --> 00:56:01.820
So that you get insight into
what is between the network

00:56:01.820 --> 00:56:05.262
request of the HTML and
users seeing the page

00:56:05.262 --> 00:56:07.220
loaded on the screen,
and have that information

00:56:07.220 --> 00:56:09.520
available to you right
inside the Dev tools.

00:56:09.520 --> 00:56:11.071
So a lot coming there.

00:56:11.071 --> 00:56:11.820
JAN MAESSEN: Yeah.

00:56:11.820 --> 00:56:13.361
I think it's really
important to look

00:56:13.361 --> 00:56:16.410
at stuff like the visual
completeness metrics.

00:56:16.410 --> 00:56:20.530
Because it's really easy to
get caught up in the numbers

00:56:20.530 --> 00:56:22.790
that the browser can
send back to you,

00:56:22.790 --> 00:56:26.276
and forget what this
really means for your users

00:56:26.276 --> 00:56:27.650
in terms of what
they're actually

00:56:27.650 --> 00:56:29.500
experiencing on the screen.

00:56:29.500 --> 00:56:32.600
And getting a feel for
tying those two together

00:56:32.600 --> 00:56:33.566
is really important.

00:56:33.566 --> 00:56:34.940
PAUL IRISH: Can
I ask a question?

00:56:34.940 --> 00:56:35.760
PAUL LEWIS: No.

00:56:35.760 --> 00:56:37.420
I ask the questions around here.

00:56:37.420 --> 00:56:39.250
When you're a
moderateor, you get to.

00:56:39.250 --> 00:56:40.744
Yeah, that's fine, go.

00:56:40.744 --> 00:56:41.740
PAUL IRISH: OK.

00:56:41.740 --> 00:56:44.490
Speed Index is probably one
of the best metrics-- that's

00:56:44.490 --> 00:56:46.290
generalized metrics--
for evaluating

00:56:46.290 --> 00:56:48.240
the user-perceived
load of the page.

00:56:48.240 --> 00:56:50.126
And I guess you invented it?

00:56:50.126 --> 00:56:50.750
Yeah, OK, cool.

00:56:50.750 --> 00:56:51.730
Awesome.

00:56:51.730 --> 00:56:53.440
So you can get it, it's great.

00:56:53.440 --> 00:56:55.860
You get it through
WebPagetest, and you can get it

00:56:55.860 --> 00:56:56.800
through [? Grameen ?] Telemetry.

00:56:56.800 --> 00:56:58.883
There's a lot of things
are kind of adopting speed

00:56:58.883 --> 00:57:01.840
and access as something
that's visible.

00:57:01.840 --> 00:57:04.250
I was just asking about the
work to have it available

00:57:04.250 --> 00:57:05.180
through the browser.

00:57:05.180 --> 00:57:07.360
And I know that's
something you were in.

00:57:07.360 --> 00:57:08.190
What's the story?

00:57:08.190 --> 00:57:10.076
PAT MEENAN: So the
current story is

00:57:10.076 --> 00:57:11.700
I tried to implement
it once in Chrome.

00:57:11.700 --> 00:57:14.179
And then that changed the
entire rendering architecture

00:57:14.179 --> 00:57:14.720
and broke it.

00:57:14.720 --> 00:57:15.250
PAUL LEWIS: As you do.

00:57:15.250 --> 00:57:16.666
It was a morning's
work, you know.

00:57:16.666 --> 00:57:18.420
PAT MEENAN: But no.

00:57:18.420 --> 00:57:20.520
More recently, we've
come up with sort

00:57:20.520 --> 00:57:24.200
of a ROM version of it that's
almost entirely JavaScript

00:57:24.200 --> 00:57:24.700
based.

00:57:24.700 --> 00:57:28.410
It's based on resource timing
that works surprisingly well.

00:57:28.410 --> 00:57:33.260
It correlates 90 plus percent
with the video version of it.

00:57:33.260 --> 00:57:35.040
So I want to try and
get a little feedback

00:57:35.040 --> 00:57:37.270
on using that in the
field, see how it goes.

00:57:37.270 --> 00:57:39.810
There's some privacy concerns
and some performance concerns

00:57:39.810 --> 00:57:44.550
with exposing too much low-level
stuff from the renderer

00:57:44.550 --> 00:57:46.520
out to the DOM for
the pages to consume.

00:57:46.520 --> 00:57:49.337
So we have to kind of figure out
where that line is going to be.

00:57:49.337 --> 00:57:50.920
NAT DUCA: One thing
that I'd just add.

00:57:50.920 --> 00:57:51.600
So sorry.

00:57:55.370 --> 00:57:59.820
This battle for FPS is hard
to balance against monitoring.

00:57:59.820 --> 00:58:01.622
One thing just
keep in mind, when

00:58:01.622 --> 00:58:03.330
you think about all
your page load times,

00:58:03.330 --> 00:58:06.850
also think about whether you're
leaving the thread responsive

00:58:06.850 --> 00:58:08.936
after or during the page load.

00:58:08.936 --> 00:58:10.310
Because the first
thing people do

00:58:10.310 --> 00:58:12.230
when they see your page
get visually complete

00:58:12.230 --> 00:58:14.355
is they're going to scroll
or they're going to tap.

00:58:14.355 --> 00:58:16.480
And if you're offloading
2 and 1/2 megabytes more

00:58:16.480 --> 00:58:18.777
of JavaScript and
parsing and executing it,

00:58:18.777 --> 00:58:20.360
they're not going
to have a good time.

00:58:20.360 --> 00:58:22.235
So you need to start
thinking about that too.

00:58:22.235 --> 00:58:23.818
This is a lot of
constraints, but this

00:58:23.818 --> 00:58:25.620
is sort of the emerging
side of the things.

00:58:25.620 --> 00:58:27.460
People load, and then they tap.

00:58:27.460 --> 00:58:29.810
And we don't have a great
experience there on the web.

00:58:29.810 --> 00:58:32.730
PAT MEENAN: And test that
on actual mobile devices.

00:58:32.730 --> 00:58:34.810
Because the CPUs
and memory on mobile

00:58:34.810 --> 00:58:39.290
is like orders of magnitude
slower than your desktop.

00:58:39.290 --> 00:58:42.350
In WebPagetest, for example, we
have the timeline little flame

00:58:42.350 --> 00:58:43.990
chart below the waterfall.

00:58:43.990 --> 00:58:46.800
And on desktop, it
was almost never

00:58:46.800 --> 00:58:49.846
worth even paying attention to,
because stuff happened so fast.

00:58:49.846 --> 00:58:51.470
But on mobile sites,
we actually end up

00:58:51.470 --> 00:58:53.430
seeing a lot of cases
where you're actually

00:58:53.430 --> 00:58:57.130
CPU constrained, even with
slow network conditions.

00:58:57.130 --> 00:58:58.530
And where the main
thread is like

00:58:58.530 --> 00:59:02.020
locked during the entire load
of your page and for some period

00:59:02.020 --> 00:59:02.520
after.

00:59:02.520 --> 00:59:05.280
PAUL LEWIS: I'm totally going
to promote the frame timing

00:59:05.280 --> 00:59:06.190
API at this point.

00:59:06.190 --> 00:59:09.060
Because even for devices
that you don't have,

00:59:09.060 --> 00:59:10.900
we're able to ship
the frame timing API,

00:59:10.900 --> 00:59:14.530
and that is open for your
feedback on the GitHub repo

00:59:14.530 --> 00:59:17.300
/WC3/frame-timing.

00:59:17.300 --> 00:59:19.770
Wow, it's like I memorized it.

00:59:19.770 --> 00:59:21.620
That would allow you
to start figuring out

00:59:21.620 --> 00:59:22.411
this kind of stuff.

00:59:22.411 --> 00:59:24.712
You'll see the CPU
time in your frames

00:59:24.712 --> 00:59:25.795
just after your page load.

00:59:25.795 --> 00:59:27.780
And go, you know what, I
have a real problem here.

00:59:27.780 --> 00:59:28.840
This is costing me users.

00:59:28.840 --> 00:59:32.500
They're leaving straight after
I do this horrible thing.

00:59:32.500 --> 00:59:34.830
So I think that's a good idea
that we should have that.

00:59:34.830 --> 00:59:36.720
But maybe that's just me.

00:59:36.720 --> 00:59:39.630
OK we, I'm afraid,
are out of time.

00:59:39.630 --> 00:59:40.680
So, I know.

00:59:40.680 --> 00:59:41.880
This was fun, wasn't it?

00:59:41.880 --> 00:59:44.845
[APPLAUSE]

