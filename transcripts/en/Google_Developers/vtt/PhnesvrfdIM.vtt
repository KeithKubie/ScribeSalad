WEBVTT
Kind: captions
Language: en

00:00:00.701 --> 00:00:01.767
Ray Cromwell: Okay, so...

00:00:01.767 --> 00:00:03.367
Hi, my name is Ray Cromwell,

00:00:03.367 --> 00:00:06.801
and I'm CTO of a company
called Timefire.

00:00:06.801 --> 00:00:09.467
And this presentation's
sort of a...

00:00:09.467 --> 00:00:11.234
if you saw my presentation
earlier on GQuery,

00:00:11.234 --> 00:00:12.968
this is sort of a little bit
higher level

00:00:12.968 --> 00:00:15.334
and more of an ad hoc
presentation

00:00:15.334 --> 00:00:17.567
about how to use G-W-T

00:00:17.567 --> 00:00:20.434
and many of the other
Google APIs

00:00:20.434 --> 00:00:24.234
to sort of build--or at least
try to build a product.

00:00:24.234 --> 00:00:26.234
So this is really about
my personal experience

00:00:26.234 --> 00:00:27.634
over like the last year

00:00:27.634 --> 00:00:29.467
of trying to build
an application

00:00:29.467 --> 00:00:30.968
and sort of
the steps that I took

00:00:30.968 --> 00:00:34.167
and how I was able to leverage
Google's offerings

00:00:34.167 --> 00:00:36.634
to sort of fill in holes
in what I was trying to do

00:00:36.634 --> 00:00:39.634
and sort of increase
my productivity.

00:00:39.634 --> 00:00:42.267
So...

00:00:42.267 --> 00:00:44.167
this presentation should
have been called

00:00:44.167 --> 00:00:45.601
"There's an API for that"

00:00:45.601 --> 00:00:46.934
instead of
"Building with Google APIs"

00:00:46.934 --> 00:00:49.200
because it seems there's
about seven presentations

00:00:49.200 --> 00:00:51.067
called
"Building with something".

00:00:51.067 --> 00:00:52.334
The one before in this room

00:00:52.334 --> 00:00:54.334
was also called
"Building with something."

00:00:54.334 --> 00:00:57.200
But really, if you look
at what's going on with Google,

00:00:57.200 --> 00:01:00.267
they're releasing
a tsunami of APIs.

00:01:00.267 --> 00:01:02.400
If you just go
to code.google.com,

00:01:02.400 --> 00:01:05.434
you'll see about 60 APIs
alone,

00:01:05.434 --> 00:01:07.934
and those are just sort of
the publicly documented ones.

00:01:07.934 --> 00:01:10.033
If you go
to code.google.com./p

00:01:10.033 --> 00:01:13.200
and search for sort of projects
that Googlers work on,

00:01:13.200 --> 00:01:16.567
there's far many...
far more than that.

00:01:16.567 --> 00:01:19.133
And they cover the full spectrum

00:01:19.133 --> 00:01:21.467
of needs for
an application developer

00:01:21.467 --> 00:01:23.200
for, you know, you have
client side frameworks,

00:01:23.200 --> 00:01:24.567
sever side frameworks.

00:01:24.567 --> 00:01:26.200
You have cloud services.
You have mobile.

00:01:26.200 --> 00:01:28.601
You have social.
You have commerce.

00:01:28.601 --> 00:01:31.634
Basically, if you have a need,

00:01:31.634 --> 00:01:34.367
there's probably an API for it.

00:01:34.367 --> 00:01:37.000
And, you know, that leads me
to sort of pose the question

00:01:37.000 --> 00:01:39.701
does Google have a platform?

00:01:39.701 --> 00:01:42.701
Because if you look at it,
it's starting to get that way.

00:01:42.701 --> 00:01:46.000
You know, people have been
sort of joking for years

00:01:46.000 --> 00:01:47.868
that, you know, Google should
do a web operating system,

00:01:47.868 --> 00:01:49.300
and I think, you know,

00:01:49.300 --> 00:01:51.634
they're dangerously close
to that right now.

00:01:51.634 --> 00:01:54.167
Maybe Wave will be that.

00:01:54.167 --> 00:01:56.501
So...

00:01:56.501 --> 00:01:59.801
here's what I see as sort of
the Application Ecosystem

00:01:59.801 --> 00:02:01.667
that Google offers right now.

00:02:01.667 --> 00:02:05.567
So I've sort of divided things
up into several blocks.

00:02:05.567 --> 00:02:08.868
And on the upper left-hand side,
you have client technology.

00:02:08.868 --> 00:02:11.133
So you can write today.

00:02:11.133 --> 00:02:13.067
You can write client side code
in JavaScript.

00:02:13.067 --> 00:02:14.434
You can do it in Android.

00:02:14.434 --> 00:02:16.467
You can do it with Flash,
actually.

00:02:16.467 --> 00:02:17.667
Like for example,

00:02:17.667 --> 00:02:19.934
Google Maps API
has a Flash client API.

00:02:19.934 --> 00:02:21.767
G-W-T, of course.

00:02:21.767 --> 00:02:27.167
What was just released
recently--O3D browser plugin.

00:02:27.167 --> 00:02:28.968
And actually, a lot of people
don't really realize

00:02:28.968 --> 00:02:30.767
that that icon in the upper
left corner is Google Earth,

00:02:30.767 --> 00:02:32.133
but Google Earth includes

00:02:32.133 --> 00:02:35.567
a full HTML5 WebKit browser
in it.

00:02:35.567 --> 00:02:37.968
So you can actually author
complete applications

00:02:37.968 --> 00:02:41.834
and run them and host them
inside of Google Earth itself.

00:02:41.834 --> 00:02:45.167
So then we move on over
to the server.

00:02:45.167 --> 00:02:47.868
And typically, when people
do server applications,

00:02:47.868 --> 00:02:52.467
they have their choice
of PHP, Java, Python, Ruby,

00:02:52.467 --> 00:02:55.968
everything in the LAMP framework
that people are used to

00:02:55.968 --> 00:03:00.133
However, now with AppEngine,
sort of a curious thing happens.

00:03:00.133 --> 00:03:06.501
You can run all of these
on Google's own servers today.

00:03:06.501 --> 00:03:12.834
So in a sense,
Google is sort of providing

00:03:12.834 --> 00:03:14.968
hosting services
for all of these languages,

00:03:14.968 --> 00:03:18.267
whether they have officially
announced it or not.

00:03:18.267 --> 00:03:21.200
The...
another crucial thing is

00:03:21.200 --> 00:03:23.033
how do you communicate
between a client server?

00:03:23.033 --> 00:03:24.801
So if you're building
a rich client like Flash

00:03:24.801 --> 00:03:28.100
or Android or G-W-T,

00:03:28.100 --> 00:03:29.934
you typically
have to communicate

00:03:29.934 --> 00:03:31.767
between a client and server,
ship data back and forth.

00:03:31.767 --> 00:03:33.701
There's a number of different
ways to do that.

00:03:33.701 --> 00:03:35.934
Probably people's favorite way
of doing it

00:03:35.934 --> 00:03:37.567
is with REST and JSON

00:03:37.567 --> 00:03:39.801
or some kind of XML format
like Atom.

00:03:39.801 --> 00:03:44.000
Or there's an API called
ProtocolBuffers

00:03:44.000 --> 00:03:47.467
which Google actually uses
for all of their internal stuff

00:03:47.467 --> 00:03:51.267
which is very compact,
and it has high performance.

00:03:51.267 --> 00:03:53.934
And for G-W-T, if you're using
G-W-T on a client side,

00:03:53.934 --> 00:03:55.601
you have the option
of GWT RPC,

00:03:55.601 --> 00:03:57.834
and I'll talk about maybe
how you can choose

00:03:57.834 --> 00:04:00.534
which one of those will fit
your application best

00:04:00.534 --> 00:04:02.400
a little bit later.

00:04:02.400 --> 00:04:07.234
And then, you know,
all the rage now is OpenSocial,

00:04:07.234 --> 00:04:09.567
Well, not OpenSocial,
but social networking.

00:04:09.567 --> 00:04:11.200
So Google has quite a number
of different ways

00:04:11.200 --> 00:04:12.601
to build social applications.

00:04:12.601 --> 00:04:14.567
You can use OpenSocial,

00:04:14.567 --> 00:04:16.534
you can use
Google Friend Connect,

00:04:16.534 --> 00:04:20.734
and you can actually use
the GData Contacts API

00:04:20.734 --> 00:04:23.400
to basically sort of have
pseudo friends network

00:04:23.400 --> 00:04:25.701
using like your Gmail contacts.

00:04:25.701 --> 00:04:28.300
And that's not
quite as well-known.

00:04:28.300 --> 00:04:30.267
They provide
a lot of utility services,

00:04:30.267 --> 00:04:32.100
which you see reused
over and over again,

00:04:32.100 --> 00:04:34.267
like in the Wave demo today,
you saw translation.

00:04:34.267 --> 00:04:36.167
Google provides
translation service.

00:04:36.167 --> 00:04:38.100
You have Maps and Geo,
of course.

00:04:38.100 --> 00:04:39.901
Visualization for charting.

00:04:39.901 --> 00:04:44.968
Search, authentication
like through...

00:04:44.968 --> 00:04:48.300
Google User service
on AppEngine.

00:04:48.300 --> 00:04:50.434
And then there's App Services,

00:04:50.434 --> 00:04:55.167
so for example, if you wanna
store spreadsheet data or...

00:04:55.167 --> 00:04:56.701
you know,
other kinds of documents,

00:04:56.701 --> 00:04:58.400
you can use Google Apps.

00:04:58.400 --> 00:05:00.200
And there's GData APIs
for all of those,

00:05:00.200 --> 00:05:02.133
so you can integrate them
into your application.

00:05:02.133 --> 00:05:04.934
Finally, if you want to monetize
your application you just built,

00:05:04.934 --> 00:05:07.334
down in the right-hand
corner you have

00:05:07.334 --> 00:05:09.400
AdSense
and Google Checkout.

00:05:09.400 --> 00:05:12.367
And I'd be remiss
if I didn't mention

00:05:12.367 --> 00:05:16.501
the fact that you can choose
to write applications today

00:05:16.501 --> 00:05:19.200
that transparently can move
back and forth

00:05:19.200 --> 00:05:21.067
between Google's AppEngine
datastore and MySQL,

00:05:21.067 --> 00:05:24.501
and I'll talk about that
a little bit later.

00:05:24.501 --> 00:05:27.367
Let me talk a little about
my application

00:05:27.367 --> 00:05:29.501
just as a way
to sort of demonstrate

00:05:29.501 --> 00:05:30.868
what I've been trying to build

00:05:30.868 --> 00:05:32.767
and how I was able to sort of
consume these APIs.

00:05:32.767 --> 00:05:38.300
So basically, I started off
with trying to build

00:05:38.300 --> 00:05:41.801
a application that was like
"Google Maps" but for "Time".

00:05:41.801 --> 00:05:44.033
The idea there was
basically Google Maps

00:05:44.033 --> 00:05:46.667
handles the spatial dimensions
really well.

00:05:46.667 --> 00:05:49.434
You can fly over vast datasets,
you can drop markers on them.

00:05:49.434 --> 00:05:50.968
People can collaborate.

00:05:50.968 --> 00:05:53.334
But there was nothing out there
that sort of allowed people

00:05:53.334 --> 00:05:57.234
to, you know, search for
vast amounts of time series data

00:05:57.234 --> 00:06:01.267
and fly over, just like
you would do in Google Maps,

00:06:01.267 --> 00:06:03.801
drop annotations on it,
and, you know,

00:06:03.801 --> 00:06:05.868
share your own insights
about that data.

00:06:05.868 --> 00:06:08.901
So I started to try to build
an application like that.

00:06:08.901 --> 00:06:10.934
So the first thing I did was

00:06:10.934 --> 00:06:13.000
I looked at client technologies.

00:06:13.000 --> 00:06:17.100
And one of the things I did was

00:06:17.100 --> 00:06:19.968
I originally wrote
a Charting API

00:06:19.968 --> 00:06:22.767
using pure JavaScript by hand.

00:06:22.767 --> 00:06:26.167
So the first thing I did was--
this was before GWT 1.3--

00:06:26.167 --> 00:06:29.767
I said, all right,
let me go use JavaScript.

00:06:29.767 --> 00:06:32.801
So I wrote a Charting API
in JavaScript

00:06:32.801 --> 00:06:35.133
and, to tell you the truth,
it kinda sucked.

00:06:35.133 --> 00:06:36.667
[laughs]

00:06:36.667 --> 00:06:39.033
Not because of JavaScript's
fault, per se,

00:06:39.033 --> 00:06:40.701
but there was a lot of things
I wanted to do

00:06:40.701 --> 00:06:43.367
with the Charting API
that it was just hard to do

00:06:43.367 --> 00:06:44.501
with JavaScript.

00:06:44.501 --> 00:06:46.000
Like I wanted to run it
on the server

00:06:46.000 --> 00:06:47.367
to generate thumbnails.

00:06:47.367 --> 00:06:49.534
I wanted to run it
in mobile devices.

00:06:49.534 --> 00:06:50.834
And I just couldn't do that

00:06:50.834 --> 00:06:52.601
with the library written
in hand code in JavaScript.

00:06:52.601 --> 00:06:55.434
So the first step was
as I got exposed to GWT,

00:06:55.434 --> 00:06:58.033
and I was like, wow,
I could write code in Java,

00:06:58.033 --> 00:07:00.534
and maybe, besides just
compiling it to JavaScript,

00:07:00.534 --> 00:07:02.701
maybe I could actually
run it in a servlet

00:07:02.701 --> 00:07:04.033
and generate thumbnails.

00:07:04.033 --> 00:07:06.133
And maybe I could run it
on J2ME devices.

00:07:06.133 --> 00:07:07.934
This was before Android.

00:07:07.934 --> 00:07:10.968
So this is an example
of the charting library I built,

00:07:10.968 --> 00:07:15.901
and one of the core features
I needed was performance.

00:07:15.901 --> 00:07:17.834
I was very, very concerned
about performance,

00:07:17.834 --> 00:07:19.467
because, you know,
looking at Google Maps,

00:07:19.467 --> 00:07:21.267
I was thinking, you know,
people could load up

00:07:21.267 --> 00:07:23.167
time series datasets
that were huge--

00:07:23.167 --> 00:07:25.133
tens of thousands,
hundreds of thousands,

00:07:25.133 --> 00:07:27.167
millions of data points,
potentially.

00:07:27.167 --> 00:07:28.701
And I wanted people
to just be able

00:07:28.701 --> 00:07:32.400
to smoothly fly over
that data...in real time

00:07:32.400 --> 00:07:34.200
without any kind of hiccups
in the browser.

00:07:34.200 --> 00:07:36.200
And G-W-T was able to help me

00:07:36.200 --> 00:07:38.033
deliver that kind of performance
in their browser.

00:07:38.033 --> 00:07:39.300
So for example,

00:07:39.300 --> 00:07:41.167
this is an example
of a dataset.

00:07:41.167 --> 00:07:43.667
It's got 22,000
data points in it.

00:07:43.667 --> 00:07:45.467
So I can like zoom in over this
in real time.

00:07:45.467 --> 00:07:47.334
You see how fast it updates.

00:07:47.334 --> 00:07:48.968
It's 80 frames per second.

00:07:48.968 --> 00:07:51.501
It's actually faster than most
games you'll get on your Xbox

00:07:51.501 --> 00:07:55.100
or Playstation 3
in terms of their update rate.

00:07:55.100 --> 00:07:58.033
Um...it allowed me to do

00:07:58.033 --> 00:07:59.868
stuff like real-time streaming

00:07:59.868 --> 00:08:02.000
using Comet
and streaming data in.

00:08:02.000 --> 00:08:06.734
Synthetic Dataset overlays,

00:08:06.734 --> 00:08:09.934
like, you know, let me add
a moving average to this.

00:08:09.934 --> 00:08:11.601
That's another example.

00:08:11.601 --> 00:08:13.300
But one of the cool things
I wanted to do

00:08:13.300 --> 00:08:15.501
is I wanted people to be able
to tell stories about the data,

00:08:15.501 --> 00:08:17.300
so you know, be able
to drop a marker on a data

00:08:17.300 --> 00:08:19.868
and say, hey, look at this,
something important here.

00:08:19.868 --> 00:08:22.767
Like maybe this point
right here in this dataset,

00:08:22.767 --> 00:08:25.100
which I think is unemployment,

00:08:25.100 --> 00:08:26.734
you know, maybe it represents
something important,

00:08:26.734 --> 00:08:28.567
so, you know,
maybe I should, you know,

00:08:28.567 --> 00:08:32.434
add a marker there like this
so that my friends can see it.

00:08:39.300 --> 00:08:40.667
I got clipped a little bit.

00:08:40.667 --> 00:08:42.067
But you can also--

00:08:42.067 --> 00:08:44.534
I can do something
like add an access marker.

00:08:44.534 --> 00:08:47.601
I'm gonna try this.

00:08:47.601 --> 00:08:49.667
You could put one down there,

00:08:49.667 --> 00:08:51.868
and that could represent like
a split in a stock or something.

00:08:51.868 --> 00:08:53.767
And you click it
and a little pop-up pops up

00:08:53.767 --> 00:08:55.033
just like in Maps.

00:08:55.033 --> 00:08:56.701
So this was like the genesis
of the idea,

00:08:56.701 --> 00:08:58.501
and I don't wanna talk about
this too much,

00:08:58.501 --> 00:09:00.133
'cause I'm not really here
to plug that.

00:09:00.133 --> 00:09:01.901
I want to sort of describe
my experience

00:09:01.901 --> 00:09:03.434
in trying to build this thing.

00:09:03.434 --> 00:09:05.868
So I got this far.

00:09:05.868 --> 00:09:08.834
And I was like, well,
what can I do next, right?

00:09:08.834 --> 00:09:11.567
Because this is just a chart.
You know, big deal.

00:09:11.567 --> 00:09:14.033
There's lots of charting
libraries out there.

00:09:14.033 --> 00:09:17.734
So I needed to take it
to the next level.

00:09:17.734 --> 00:09:20.868
And...one of the ways
I did that

00:09:20.868 --> 00:09:24.367
was by looking at how I could
make it more social.

00:09:24.367 --> 00:09:26.167
So I started looking
at OpenSocial

00:09:26.167 --> 00:09:28.133
and stuff like
Google Friend Connect.

00:09:28.133 --> 00:09:31.033
And I went and I built a...

00:09:31.033 --> 00:09:34.968
a widget that imbeds this
whole thing

00:09:34.968 --> 00:09:37.033
in an OpenSocial container.

00:09:37.033 --> 00:09:39.234
So what I'm gonna show you is

00:09:39.234 --> 00:09:41.701
a demo of something called--

00:09:41.701 --> 00:09:44.400
that I call Timelord.

00:09:44.400 --> 00:09:47.267
And this is that
Charting Application

00:09:47.267 --> 00:09:49.767
but hosted in an OpenSocial
container.

00:09:49.767 --> 00:09:52.667
And I'm not showing it live,
because actually

00:09:52.667 --> 00:09:55.033
I broke something this morning
in my code,

00:09:55.033 --> 00:09:56.667
so it actually didn't work.

00:09:56.667 --> 00:09:58.334
I'm gonna show you
a screencast of this.

00:09:58.334 --> 00:10:00.601
And what this is
is basically

00:10:00.601 --> 00:10:03.968
you can drop this chart
in an OpenSocial container,

00:10:03.968 --> 00:10:08.200
and people can...
annotate the data,

00:10:08.200 --> 00:10:10.100
make comments on it
just like a YouTube video,

00:10:10.100 --> 00:10:12.801
and it will actually
post those comments

00:10:12.801 --> 00:10:14.968
to the person's activity streams
to their friends.

00:10:14.968 --> 00:10:17.801
So for example, you see up
there on the top left it says

00:10:17.801 --> 00:10:24.334
Al Gore left a comment on
CO2 EPICA Ice Core with Modern.

00:10:24.334 --> 00:10:27.334
So he left some kind of comment
on a chart about CO2 data.

00:10:27.334 --> 00:10:32.234
So I'm gonna click that
and move forward a little bit.

00:10:32.234 --> 00:10:34.400
And you can see,
lo and behold,

00:10:34.400 --> 00:10:38.534
there's a chart here
with 800,000 years of CO2 data.

00:10:38.534 --> 00:10:40.300
Going back really far.

00:10:40.300 --> 00:10:41.634
And on the right-hand side

00:10:41.634 --> 00:10:43.300
you see a little YouTube-like
interface that says,

00:10:43.300 --> 00:10:45.834
"please
watch my mini-presentation."

00:10:45.834 --> 00:10:48.667
So as I was building this

00:10:48.667 --> 00:10:51.033
and adding the features
for people to drop markers

00:10:51.033 --> 00:10:52.934
and log things to OpenSocial,

00:10:52.934 --> 00:10:55.033
I thought, you know,
why not let the person

00:10:55.033 --> 00:10:57.067
tell a story
while they're at it?

00:10:57.067 --> 00:10:59.667
It's not enough to just say
drop a marker here

00:10:59.667 --> 00:11:01.000
and say there's something
funny going here,

00:11:01.000 --> 00:11:02.567
there's like
something interesting here.

00:11:02.567 --> 00:11:04.200
What if I could
tell a story about

00:11:04.200 --> 00:11:08.701
like why I think this data
is the way it is?

00:11:08.701 --> 00:11:11.834
So one of the APIs I looked at
to do this was

00:11:11.834 --> 00:11:13.601
the YouTube Chromeless
Player API.

00:11:13.601 --> 00:11:15.033
I don't know
if anyone's used it,

00:11:15.033 --> 00:11:17.434
but this is an enormous
productivity benefit

00:11:17.434 --> 00:11:19.067
because if I didn't have that,

00:11:19.067 --> 00:11:21.467
I'd have to actually build out
a video hosting service myself,

00:11:21.467 --> 00:11:24.767
build my own Flash Player,
export APIs for it.

00:11:24.767 --> 00:11:26.400
It would be just
a tremendous hurdle.

00:11:26.400 --> 00:11:28.801
I actually was able to implement
what you're about to see

00:11:28.801 --> 00:11:30.567
in one day.

00:11:30.567 --> 00:11:32.167
So what you're gonna see

00:11:32.167 --> 00:11:35.634
is a clip from Al Gore's movie,
"An Inconvenient Truth."

00:11:35.634 --> 00:11:39.701
And on the right-hand side,
the video's gonna play

00:11:39.701 --> 00:11:41.033
and Al Gore's gonna
walk across the stage,

00:11:41.033 --> 00:11:43.000
and he's gonna point out
various things

00:11:43.000 --> 00:11:44.300
about the data you're seeing.

00:11:44.300 --> 00:11:45.968
And on the left-hand side,

00:11:45.968 --> 00:11:48.067
the chart is going to react
to what he's saying,

00:11:48.067 --> 00:11:50.367
and it's going to basically
add things.

00:11:50.367 --> 00:11:52.701
So I'm gonna move it up
a little bit

00:11:52.701 --> 00:11:55.067
so we don't have to watch
too much of the movie

00:11:55.067 --> 00:11:58.067
and maybe get sued by
the MPAA or something.

00:11:58.067 --> 00:12:02.100
But here...at the top you see
there's a subtitle

00:12:02.100 --> 00:12:04.067
and it says
CO2 going back 800,000 years.

00:12:04.067 --> 00:12:06.501
Now, he's going to talk
about this chart

00:12:06.501 --> 00:12:09.300
and what parts of the chart
are in different eras.

00:12:09.300 --> 00:12:13.534
So I could turn on the audio.
I don't know if you can hear it.

00:12:13.534 --> 00:12:15.100
Al Gore:...outside of
a small group of scientists

00:12:15.100 --> 00:12:17.934
has seen this image.

00:12:17.934 --> 00:12:21.100
This is the present day,
uh, era.

00:12:21.100 --> 00:12:24.701
And that's the last Ice Age,
then it goes up.

00:12:24.701 --> 00:12:27.834
We're going back in time now,
650,000 years.

00:12:27.834 --> 00:12:30.734
That's the period of warming
between the last two Ice Ages.

00:12:30.734 --> 00:12:34.667
That's the second
and third Ice Age back--

00:12:34.667 --> 00:12:37.667
fourth, fifth, sixth,

00:12:37.667 --> 00:12:40.200
and seventh Ice Age back.

00:12:40.200 --> 00:12:42.734
Now, an important point.

00:12:42.734 --> 00:12:48.200
In all of this time,
650,000 years,

00:12:48.200 --> 00:12:51.033
the CO2 level
has never gone above

00:12:51.033 --> 00:12:53.901
300 parts per million.

00:12:53.901 --> 00:12:56.267
Now, as I said, they can
also measure temperature.

00:12:56.267 --> 00:12:57.701
Here's what the temperature...

00:12:57.701 --> 00:12:59.901
Cromwell: So Al's gonna make
a RPC call to the server

00:12:59.901 --> 00:13:02.434
and get a temperature dataset,
and now we'll this.

00:13:02.434 --> 00:13:05.834
This is all being driven by
text comments

00:13:05.834 --> 00:13:09.267
that are hidden behind
this video in actual comment.

00:13:09.267 --> 00:13:11.601
So there you go.
It's compared with temperature.

00:13:11.601 --> 00:13:13.400
So I'm not gonna
let that go on too long.

00:13:13.400 --> 00:13:16.734
But the key issue is here

00:13:16.734 --> 00:13:18.033
is basically
I created the system

00:13:18.033 --> 00:13:20.801
where people could write
little wiki-like syntax comments

00:13:20.801 --> 00:13:23.901
in the commentary, just like
you would do on YouTube.

00:13:23.901 --> 00:13:25.701
And you're able to reference
things from the chart

00:13:25.701 --> 00:13:28.267
and drop markers,
tell the chart to move somewhere

00:13:28.267 --> 00:13:30.000
and to compare it
with other datasets

00:13:30.000 --> 00:13:31.534
and all kinds of
like funky stuff.

00:13:31.534 --> 00:13:34.434
And by using the YouTube
Chromeless Player API,

00:13:34.434 --> 00:13:36.334
I was able to get
bi-directional syncing

00:13:36.334 --> 00:13:38.868
between the chart and the video
up in like one day.

00:13:38.868 --> 00:13:40.334
So if you move the chart around,

00:13:40.334 --> 00:13:42.968
the video actually can
go to the certain time code

00:13:42.968 --> 00:13:45.434
to actually react to where
that chart was supposed to be.

00:13:45.434 --> 00:13:47.901
You can sort of map
the time code of the video

00:13:47.901 --> 00:13:51.834
to like the timeline
on the chart itself.

00:13:51.834 --> 00:13:55.801
So without...showing
too much more of that,

00:13:55.801 --> 00:13:57.200
now I wanna start talking about,

00:13:57.200 --> 00:13:59.033
if you guys thought
that was interesting,

00:13:59.033 --> 00:14:02.133
how did I do that?

00:14:02.133 --> 00:14:04.968
But before I go forward,

00:14:04.968 --> 00:14:07.467
I wanna show you
another cool thing.

00:14:07.467 --> 00:14:09.334
Because I think
this is important

00:14:09.334 --> 00:14:12.567
when I get to
talking about G-W-T.

00:14:12.567 --> 00:14:15.801
I built an Android version
of this.

00:14:15.801 --> 00:14:18.634
Now, the interesting thing
about this,

00:14:18.634 --> 00:14:24.200
if I can get it working...
here we go...

00:14:24.200 --> 00:14:26.667
is that I didn't change
any of the code

00:14:26.667 --> 00:14:28.601
in the web version.

00:14:28.601 --> 00:14:32.734
I was able to compile
the web version

00:14:32.734 --> 00:14:34.834
that you just saw the point
in the OpenSocial container

00:14:34.834 --> 00:14:36.434
to a native Android App.

00:14:36.434 --> 00:14:37.767
It's not running
in the web browser.

00:14:37.767 --> 00:14:40.634
It's a native App
Java bytecode,

00:14:40.634 --> 00:14:43.934
or Dalvikvm code,
and just have it run in here.

00:14:43.934 --> 00:14:46.968
So you'll be able to see...

00:14:46.968 --> 00:14:49.133
it's doing some stuff now
with OAuth

00:14:49.133 --> 00:14:50.868
which I'll talk about
a little bit later,

00:14:50.868 --> 00:14:52.767
but it's gonna
go get a token.

00:14:52.767 --> 00:14:54.567
I'm gonna log it in.
Let me skip ahead.

00:14:54.567 --> 00:14:57.400
It's gonna ask me to approve,
give me an OAuth token.

00:14:57.400 --> 00:15:00.300
And there you see the same
sort of chart data.

00:15:00.300 --> 00:15:02.567
It's dropped some markers
on the chart.

00:15:02.567 --> 00:15:06.300
There's the ability to...

00:15:06.300 --> 00:15:08.501
go look at those markers,

00:15:08.501 --> 00:15:11.267
what the comments were
that people said.

00:15:11.267 --> 00:15:13.667
You can add a marker

00:15:13.667 --> 00:15:16.467
that you can share via
a number of different networks.

00:15:16.467 --> 00:15:19.701
So in this example,
it's gonna share...

00:15:19.701 --> 00:15:22.667
a comment via OpenSocial REST
with Al Gore.

00:15:22.667 --> 00:15:24.634
And what happens is

00:15:24.634 --> 00:15:27.467
when someone clicks this
and says,

00:15:27.467 --> 00:15:30.400
I want to share this comment
that I just made on this chart,

00:15:30.400 --> 00:15:33.033
it uses a REST OpenSocial API

00:15:33.033 --> 00:15:35.834
to post it back
to the container here.

00:15:35.834 --> 00:15:37.801
So now I'm gonna
go click on the inbox

00:15:37.801 --> 00:15:39.834
on my Partuza
OpenSocial container

00:15:39.834 --> 00:15:41.801
and you can see in the sent box

00:15:41.801 --> 00:15:43.400
that there's a message
sent to Al Gore,

00:15:43.400 --> 00:15:45.000
which says
come look at this chart.

00:15:45.000 --> 00:15:46.901
And I did that completely
from the mobile device.

00:15:46.901 --> 00:15:48.601
So it's like
the same functionality

00:15:48.601 --> 00:15:50.968
that's available
in the OpenSocial container

00:15:50.968 --> 00:15:52.968
is also available
on the mobile device.

00:15:52.968 --> 00:15:55.601
So hopefully,
that kinda gives you

00:15:55.601 --> 00:15:57.267
a taste of some of the cool
stuff you can do.

00:15:57.267 --> 00:15:59.434
The question is
like how do you do it,

00:15:59.434 --> 00:16:01.300
and how do you do it
without repeating code

00:16:01.300 --> 00:16:03.634
and running two clients
and things like that?

00:16:03.634 --> 00:16:06.100
So that's what I'm gonna
try to explain

00:16:06.100 --> 00:16:09.601
which is how to achieve...

00:16:09.601 --> 00:16:12.133
what I would say
is a lot of code re-use,

00:16:12.133 --> 00:16:16.634
between various client
technologies.

00:16:16.634 --> 00:16:19.200
So first thing
you should know about Android

00:16:19.200 --> 00:16:20.434
if you don't already,

00:16:20.434 --> 00:16:23.734
it's almost
a full J2SE Java stack.

00:16:23.734 --> 00:16:26.968
It has tight integration
with the WebKit browser.

00:16:26.968 --> 00:16:30.434
You have a local database,
you have 2D and 3D APIs.

00:16:30.434 --> 00:16:32.801
You have sort of
an externalized way

00:16:32.801 --> 00:16:34.601
of representing
widget layouts,

00:16:34.601 --> 00:16:36.167
which makes it really easy

00:16:36.167 --> 00:16:38.701
to separate presentation
and logic.

00:16:38.701 --> 00:16:40.968
So...how was this done,
right?

00:16:40.968 --> 00:16:43.100
Even in the Android Client,
how is it done?

00:16:43.100 --> 00:16:44.767
Well, G-W-T
is the foundation.

00:16:44.767 --> 00:16:47.000
If I didn't have G-W-T,

00:16:47.000 --> 00:16:48.434
I wouldn't have been able
to do this.

00:16:48.434 --> 00:16:50.133
So what happened is

00:16:50.133 --> 00:16:52.934
is that I write the App
to the G-W-T APIs

00:16:52.934 --> 00:16:56.334
with are a subset
of the normal Java APIs.

00:16:56.334 --> 00:16:59.901
And if you target those
and you stay within those APIs,

00:16:59.901 --> 00:17:02.868
it turns out that you can
compile that code cleanly

00:17:02.868 --> 00:17:06.467
and run it on Android
with very little changes.

00:17:06.467 --> 00:17:08.367
So, you know, you could
write a game

00:17:08.367 --> 00:17:10.534
that works
in an OpenSocial container

00:17:10.534 --> 00:17:11.767
on a social network,

00:17:11.767 --> 00:17:13.400
and then you could make
that same game run

00:17:13.400 --> 00:17:16.000
on the Android device and
put it on the Android Market.

00:17:16.000 --> 00:17:20.100
So I hope that's like
a very compelling use case.

00:17:20.100 --> 00:17:21.534
Now, obviously, though,

00:17:21.534 --> 00:17:23.601
there are platform-specific
things you have to do,

00:17:23.601 --> 00:17:27.367
so, you know, you just can't
target the, you know,

00:17:27.367 --> 00:17:28.834
GWT Emulation Library

00:17:28.834 --> 00:17:30.701
when you need to draw stuff
on Android

00:17:30.701 --> 00:17:34.067
or talk to native Android
widgets or handle events.

00:17:34.067 --> 00:17:36.767
So this is where...
Guice comes in.

00:17:36.767 --> 00:17:39.200
Guice Dependency Injection.

00:17:39.200 --> 00:17:41.267
So hopefully,
some of you have attended

00:17:41.267 --> 00:17:44.868
those sessions at Google IO
on dependency injection

00:17:44.868 --> 00:17:46.367
in the Guice Library.

00:17:46.367 --> 00:17:48.467
But I use this all over,

00:17:48.467 --> 00:17:50.701
and I've kind of fallen
in love with it.

00:17:50.701 --> 00:17:52.701
And so basically
what you do is this.

00:17:52.701 --> 00:17:55.701
You write as much code
as you can,

00:17:55.701 --> 00:17:57.601
sort of cleanly packaged

00:17:57.601 --> 00:18:01.434
and only using the GWT
JRE Emulation Library classes.

00:18:01.434 --> 00:18:05.601
And the 1.6 event system
in GWT,

00:18:05.601 --> 00:18:07.667
which there's a pack
that's called shared,

00:18:07.667 --> 00:18:09.267
and if you stick
to those interfaces,

00:18:09.267 --> 00:18:12.067
it can run in the server,
on the client, anywhere.

00:18:12.067 --> 00:18:15.133
It's sort of abstracted away
from the browser.

00:18:15.133 --> 00:18:18.200
And then what you do
is for device-specific

00:18:18.200 --> 00:18:20.234
or platform-specific stuff
that you need to do

00:18:20.234 --> 00:18:22.734
like wire up event handlers
or draw stuff to the screen,

00:18:22.734 --> 00:18:26.667
you use dependency injection
to inject implementations

00:18:26.667 --> 00:18:29.067
of those particular bits
of functionality.

00:18:29.067 --> 00:18:31.167
So like one of the things
I do to draw the chart

00:18:31.167 --> 00:18:34.167
is I use the HTML5 canvas
in the browser

00:18:34.167 --> 00:18:36.200
to do all the line drawing.

00:18:36.200 --> 00:18:39.033
But on Android, I actually
don't use the HTML5 canvas.

00:18:39.033 --> 00:18:42.467
I use the native Android
Graphics Libraries.

00:18:42.467 --> 00:18:43.968
So what I did is

00:18:43.968 --> 00:18:45.634
I just simply created
an interface called canvas

00:18:45.634 --> 00:18:49.167
that has many of the methods
like line and set colors

00:18:49.167 --> 00:18:52.534
and fill this and translate
and scale and rotate.

00:18:52.534 --> 00:18:55.434
And then I dependency inject
different versions.

00:18:55.434 --> 00:18:57.234
So on GWT,
I will dependency inject

00:18:57.234 --> 00:18:58.767
the one that's the HTML5 canvas

00:18:58.767 --> 00:19:00.634
and on Android,
I'll dependency inject

00:19:00.634 --> 00:19:02.901
the one that's a native
Android implementation.

00:19:02.901 --> 00:19:06.167
So you do have to write some
extra code on each platform,

00:19:06.167 --> 00:19:07.667
but it's very small.

00:19:07.667 --> 00:19:09.601
You maybe have to implement
one or two classes

00:19:09.601 --> 00:19:11.334
to get it up and running.

00:19:11.334 --> 00:19:15.634
Very powerful.

00:19:15.634 --> 00:19:18.400
One tricky thing is
wiring up EventHandler.

00:19:18.400 --> 00:19:21.133
So you know, the event handling
system on Android's

00:19:21.133 --> 00:19:22.667
completely different
than the browser one.

00:19:22.667 --> 00:19:26.434
On, you know, GWT you have
ClickHandlers or ClickListeners.

00:19:26.434 --> 00:19:30.901
On Android, it's
a completely different system.

00:19:30.901 --> 00:19:32.534
But what you can do is this.

00:19:32.534 --> 00:19:36.801
You can code all of your stuff
to the GWT 1.5--

00:19:36.801 --> 00:19:40.501
sorry, 1.6. event system
that was introduced.

00:19:40.501 --> 00:19:43.801
And they have interfaces
like HasClickHandler

00:19:43.801 --> 00:19:45.934
and has a method on it
like addClickHandler,

00:19:45.934 --> 00:19:47.100
and it takes the callback
function.

00:19:47.100 --> 00:19:48.868
It's gonna be called
when you--

00:19:48.868 --> 00:19:51.000
when somebody clicks
on that widget.

00:19:51.000 --> 00:19:57.067
And what you do is you
inject the device-specific

00:19:57.067 --> 00:19:58.601
implementation
of that interface.

00:19:58.601 --> 00:20:01.968
So for Android, you might
inject Android ClickHandler

00:20:01.968 --> 00:20:05.400
And for GWT, you might inject
like a browser ClickHandler.

00:20:05.400 --> 00:20:10.801
And essentially on GWT,
the Guice API's called GIN,

00:20:10.801 --> 00:20:13.067
so if you haven't heard of it,
it's sort of under the radar.

00:20:13.067 --> 00:20:15.834
It's one of those APIs
that's not on code.google.com.

00:20:15.834 --> 00:20:19.267
There is a dependency injection
framework for GWT called Gin

00:20:19.267 --> 00:20:22.634
which is actually just Guice
but implemented for Gin.

00:20:22.634 --> 00:20:25.767
So this is one way
where you can write

00:20:25.767 --> 00:20:28.767
one set of logic
for handling events

00:20:28.767 --> 00:20:32.434
and then sort of cleanly inject
platform-specific event handlers

00:20:32.434 --> 00:20:33.767
if you need to.

00:20:33.767 --> 00:20:35.868
Like if you need to specifically
handle something

00:20:35.868 --> 00:20:39.567
differently for the Android
device versus the browser.

00:20:39.567 --> 00:20:42.167
Typically, it boils down
to like network IO.

00:20:42.167 --> 00:20:44.033
Like, you know,
you need to either

00:20:44.033 --> 00:20:45.400
inject a script tag on GWT

00:20:45.400 --> 00:20:46.934
to basically load up
a rest call

00:20:46.934 --> 00:20:48.934
or on Android you have to use
the HTTPClient--

00:20:48.934 --> 00:20:51.934
things like that.

00:20:51.934 --> 00:20:53.968
So, what's Guice?

00:20:53.968 --> 00:20:56.300
It's dependency injection
like Spring,

00:20:56.300 --> 00:20:58.834
if you've used Spring before,

00:20:58.834 --> 00:21:00.901
but without the XML cruft.

00:21:00.901 --> 00:21:05.634
So it's all done with...
annotations.

00:21:05.634 --> 00:21:07.033
And they use a lot of
of method chaining,

00:21:07.033 --> 00:21:09.634
so if you saw my GWT Query
or GQuery presentation earlier,

00:21:09.634 --> 00:21:12.067
it uses the method chaining
technique

00:21:12.067 --> 00:21:14.434
to sort of make your code terse.

00:21:14.434 --> 00:21:16.634
It's very compact,
but it's very powerful.

00:21:16.634 --> 00:21:20.267
And there's the thing--
it now works as a Guice 2.0

00:21:20.267 --> 00:21:23.400
inside of AppEngine,
on Android, and in GWT.

00:21:23.400 --> 00:21:25.501
That means you can write code

00:21:25.501 --> 00:21:27.534
that you can deploy
to AppEngine on the server,

00:21:27.534 --> 00:21:28.834
run it as JavaScript,

00:21:28.834 --> 00:21:30.334
or run it inside
the mobile device.

00:21:30.334 --> 00:21:33.133
So there are some times
you want to write code

00:21:33.133 --> 00:21:35.100
that actually can run
in all three places,

00:21:35.100 --> 00:21:37.634
'cause it's very generic
utility code.

00:21:37.634 --> 00:21:41.200
So as I said, Gin is basically
Guice for G-W-T.

00:21:41.200 --> 00:21:43.234
it uses compile-time generators

00:21:43.234 --> 00:21:48.133
to do AOP-dependent style
method interception and stuff.

00:21:48.133 --> 00:21:50.000
Here's an example of what
dependency injection looks like

00:21:50.000 --> 00:21:51.100
if you've never seen it.

00:21:51.100 --> 00:21:53.801
So I could write a class called
Checkout

00:21:53.801 --> 00:21:57.734
and maybe it has to take another
class called OrderProcessor

00:21:57.734 --> 00:21:59.634
that knows how to process
the order.

00:21:59.634 --> 00:22:01.868
And typically,
the way you would write this

00:22:01.868 --> 00:22:04.267
is you might have
an OrderProcessorfactory

00:22:04.267 --> 00:22:06.033
you might call create
or getInstance,

00:22:06.033 --> 00:22:09.167
and it would basically return
the instance--

00:22:09.167 --> 00:22:11.300
the actual implementation
of OrderProcessor.

00:22:11.300 --> 00:22:13.334
There might be different
versions of OrderProcessor,

00:22:13.334 --> 00:22:14.701
depending on whether
you're against Checkout

00:22:14.701 --> 00:22:16.300
or whether
you're against PayPal.

00:22:16.300 --> 00:22:19.033
Maybe for testing you've got
a MOP OrderProcessor.

00:22:19.033 --> 00:22:20.968
But with Guice what you do

00:22:20.968 --> 00:22:25.334
is you just write @inject on
the constructor of this class.

00:22:25.334 --> 00:22:27.334
And that's it.
You're done.

00:22:27.334 --> 00:22:28.634
And then basically,

00:22:28.634 --> 00:22:31.334
there's a little config class
you write later

00:22:31.334 --> 00:22:33.167
where you say,
"Well, in this instance,

00:22:33.167 --> 00:22:36.567
"I wanted to inject
the PayPal OrderProcessor,

00:22:36.567 --> 00:22:38.033
"and in this instance,

00:22:38.033 --> 00:22:40.000
I want it to be at the Google
Checkout OrderProcessor."

00:22:40.000 --> 00:22:42.400
So it allows you sort of the rip
and replace functionality

00:22:42.400 --> 00:22:44.901
out of your code really easily

00:22:44.901 --> 00:22:47.234
without being too tangled
on factories

00:22:47.234 --> 00:22:50.033
and other stack dependencies.

00:22:50.033 --> 00:22:53.234
So this is
a list of the APIs

00:22:53.234 --> 00:22:56.133
that I'm gonna try to talk
about or cover in some way.

00:22:56.133 --> 00:22:57.434
And these are the ones

00:22:57.434 --> 00:22:58.934
that I've kind of been
prototyping

00:22:58.934 --> 00:23:00.367
and using with my application.

00:23:00.367 --> 00:23:02.767
OpenSocial, Friend Connect,
GWT, Android.

00:23:02.767 --> 00:23:04.734
Those are the tops.

00:23:04.734 --> 00:23:07.133
GViz. I'll show you a GViz
integration in a second.

00:23:07.133 --> 00:23:09.834
Hopefully, you'll find that
a little bit cool.

00:23:09.834 --> 00:23:14.467
Maps, ring tones, and...[laughs]
Spreadsheet.

00:23:14.467 --> 00:23:15.467
YouTube, Checkout.

00:23:15.467 --> 00:23:18.000
You saw the YouTube integration
already.

00:23:18.000 --> 00:23:21.501
So first let's talk about
Social, right?

00:23:21.501 --> 00:23:24.968
So there's usually three things
when you wanna sort of...

00:23:24.968 --> 00:23:27.267
integrate Social
into your application, right?

00:23:27.267 --> 00:23:29.000
You want to get
a list of the friends

00:23:29.000 --> 00:23:30.901
of the current
authorized user,

00:23:30.901 --> 00:23:33.734
you want to send messages
to those people sometimes,

00:23:33.734 --> 00:23:35.267
and you want to post
activities

00:23:35.267 --> 00:23:38.167
like, you know, somebody
just did this on this app,

00:23:38.167 --> 00:23:41.334
like I attained level 10 in,
you know, Sudoku or something

00:23:41.334 --> 00:23:43.267
so your friends can see it.

00:23:43.267 --> 00:23:45.801
And there's two current ways--

00:23:45.801 --> 00:23:47.801
I classify Google Friend Connect
as like a sub-class,

00:23:47.801 --> 00:23:49.601
so there's two current things
that Google provides

00:23:49.601 --> 00:23:51.000
that allow you to write
applications

00:23:51.000 --> 00:23:52.400
that leverage Social,

00:23:52.400 --> 00:23:54.501
unless you want to use
Facebook or something.

00:23:54.501 --> 00:23:57.534
You can use OpenSocial
and Google Friend Connect,

00:23:57.534 --> 00:23:58.801
and there's two different ways
to do it.

00:23:58.801 --> 00:24:00.834
You can use the Java Script APIs
or the REST APIs.

00:24:00.834 --> 00:24:03.534
And then there's the Google Data
Contacts API.

00:24:03.534 --> 00:24:05.234
And you can use that
in some instances

00:24:05.234 --> 00:24:07.767
where you're not inside
an OpenSocial container.

00:24:07.767 --> 00:24:11.267
The question is
is like how do you integrate...

00:24:11.267 --> 00:24:16.400
OpenSocial with GWT
and Android at the same time

00:24:16.400 --> 00:24:18.567
and limit the amount of code
that you're duplicating

00:24:18.567 --> 00:24:20.067
between the two?

00:24:20.067 --> 00:24:23.467
So typically,
what you might do

00:24:23.467 --> 00:24:26.901
is take the JavaScript APIs
on GWT for OpenSocial

00:24:26.901 --> 00:24:29.968
and use overlay types,
or JSNI, to wrap them.

00:24:29.968 --> 00:24:31.734
That's what a lot of people
would do.

00:24:31.734 --> 00:24:33.100
And then for Android,

00:24:33.100 --> 00:24:35.100
you would probably use
the REST APIs

00:24:35.100 --> 00:24:37.901
and you would fetch JSON
from the server

00:24:37.901 --> 00:24:41.367
using HTTP GETs.

00:24:41.367 --> 00:24:43.767
But then you might
get tired of that,

00:24:43.767 --> 00:24:45.300
because there's duplication.

00:24:45.300 --> 00:24:47.367
You gotta maintain
these overlay type classes

00:24:47.367 --> 00:24:48.734
with all these
adjusting methods,

00:24:48.734 --> 00:24:49.968
then you've gotta maintain
these REST classes,

00:24:49.968 --> 00:24:51.300
and they're sort of different.

00:24:51.300 --> 00:24:52.767
So you don't want to
repeat yourself.

00:24:52.767 --> 00:24:56.801
So the other thing
you can do is...

00:24:56.801 --> 00:25:01.834
you can instead delegate
the fetch logic on the server.

00:25:01.834 --> 00:25:04.567
So I could put all the
OpenSocial logic on the server

00:25:04.567 --> 00:25:06.734
that communicates with,
let's say, MySpace

00:25:06.734 --> 00:25:09.367
and pulls your Friends lists
that logs activities,

00:25:09.367 --> 00:25:13.300
and then I could make the client

00:25:13.300 --> 00:25:16.534
simply ask the server
to do it on their behalf.

00:25:16.534 --> 00:25:18.033
But then the problem is

00:25:18.033 --> 00:25:21.634
is that how do you talk to
the server

00:25:21.634 --> 00:25:23.734
using like Android and GWT

00:25:23.734 --> 00:25:27.033
and maybe Flash
and other things like that?

00:25:27.033 --> 00:25:30.200
So obviously, what we'd like
is like option 3,

00:25:30.200 --> 00:25:33.634
which is like both on GWT
and on Android.

00:25:33.634 --> 00:25:35.701
It's basically
the same API.

00:25:35.701 --> 00:25:37.534
It's like ask the server
to fetch it on your behalf

00:25:37.534 --> 00:25:41.067
via an RPC call.

00:25:41.067 --> 00:25:43.667
So I'll...
cover that in a second.

00:25:43.667 --> 00:25:45.634
Let me just
digress for a moment.

00:25:45.634 --> 00:25:48.400
The way I implement it
is I create an interface

00:25:48.400 --> 00:25:50.367
called ShareProvider,
and it has three methods on it--

00:25:50.367 --> 00:25:53.033
getContacts, sendMessage
and logActivity.

00:25:53.033 --> 00:25:57.334
And then I use Guice to inject
one of these three options here

00:25:57.334 --> 00:26:00.467
which I've experimented with
on each of the platforms.

00:26:00.467 --> 00:26:03.534
But obviously the best is to
only inject one implementation,

00:26:03.534 --> 00:26:04.901
which is option 3,

00:26:04.901 --> 00:26:07.000
which is both of them delegate
to the server and say,

00:26:07.000 --> 00:26:10.100
"Get me my Friends list."

00:26:10.100 --> 00:26:13.133
So...

00:26:13.133 --> 00:26:15.100
I'll just skip that
for a second.

00:26:15.100 --> 00:26:18.400
So how do you communicate
with the clientless server

00:26:18.400 --> 00:26:22.868
in sort of a cross
client-agnostic way?

00:26:25.234 --> 00:26:27.634
We have three options.

00:26:27.634 --> 00:26:30.133
You can use REST with JSON
or XML,

00:26:30.133 --> 00:26:31.734
which is what many people
would do today

00:26:31.734 --> 00:26:33.634
and many people would favor.

00:26:33.634 --> 00:26:35.567
But it's still kind of like
the de facto standard.

00:26:35.567 --> 00:26:37.000
It's readable.

00:26:37.000 --> 00:26:39.000
You can look in Firebug
and you can kind of see

00:26:39.000 --> 00:26:40.601
what's going back and forth
over the wire.

00:26:40.601 --> 00:26:43.000
It's easy to debug.

00:26:43.000 --> 00:26:45.901
But there are reasons why
you might not wanna do it.

00:26:45.901 --> 00:26:47.400
You can use ProtocolBuffers

00:26:47.400 --> 00:26:48.968
which is what Google uses
internally

00:26:48.968 --> 00:26:50.067
for almost all their stuff.

00:26:50.067 --> 00:26:51.467
So when you're doing searches

00:26:51.467 --> 00:26:54.634
or you're using Tchat
or spreadsheets or whatever,

00:26:54.634 --> 00:26:56.200
on the back end somewhere,

00:26:56.200 --> 00:26:59.467
there's like ProtocolBuffers
flying around Google's cluster.

00:26:59.467 --> 00:27:01.701
And then the other option
is GWT RPC,

00:27:01.701 --> 00:27:03.701
which is built into GWT.

00:27:03.701 --> 00:27:06.701
So the question is which one of
those three would you use?

00:27:06.701 --> 00:27:09.334
Well, let's look at REST,
for example.

00:27:09.334 --> 00:27:11.567
You basically
have to write code

00:27:11.567 --> 00:27:15.400
that serializes or de-serializes
your objects to JSON or XML.

00:27:15.400 --> 00:27:17.534
So if you're using GWT,
like I am

00:27:17.534 --> 00:27:18.767
and you've got a Java class

00:27:18.767 --> 00:27:20.000
and you've got to make
a utility class

00:27:20.000 --> 00:27:22.367
that can basically
take a GWT object

00:27:22.367 --> 00:27:26.067
and generate JSON from it
or generate XML.

00:27:26.067 --> 00:27:29.601
The pros is that you can port
this technique to any client

00:27:29.601 --> 00:27:31.434
or sever code.

00:27:31.434 --> 00:27:33.534
So, you know, you can write
a Python Library

00:27:33.534 --> 00:27:36.067
to interact with the same
servers that the GWT does,

00:27:36.067 --> 00:27:38.167
the GWT client does.

00:27:38.167 --> 00:27:40.334
And it's also very efficient
for the browser,

00:27:40.334 --> 00:27:41.868
so like JSON, you know,

00:27:41.868 --> 00:27:43.801
you can directly evaluate it
in a browser if you want.

00:27:43.801 --> 00:27:46.934
It's kind of very
targeted JavaScript,

00:27:46.934 --> 00:27:48.634
in terms of efficiency.

00:27:48.634 --> 00:27:50.467
The problem I ran into--

00:27:50.467 --> 00:27:52.801
because this is the first
implementation I did--

00:27:52.801 --> 00:27:55.667
is that if, you know,
one of the other guys

00:27:55.667 --> 00:27:57.634
who were working on our stuff,

00:27:57.634 --> 00:28:00.167
he changes one of the Java
objects

00:28:00.167 --> 00:28:02.634
and adds an extra field
or he renames a field,

00:28:02.634 --> 00:28:05.367
what happens is
is that everything breaks.

00:28:05.367 --> 00:28:08.167
And often, you don't know
that it's gonna be broken

00:28:08.167 --> 00:28:11.767
until you actually test it
in web mode

00:28:11.767 --> 00:28:14.934
or you test it end-to-end...
which is kind of bad.

00:28:14.934 --> 00:28:17.334
I'd prefer to know
when I'm editing the code

00:28:17.334 --> 00:28:19.434
that he refactored something.

00:28:19.434 --> 00:28:21.534
And also,
it's less efficient for mobile.

00:28:21.534 --> 00:28:24.033
So, you know, if you wanna
conserve battery power

00:28:24.033 --> 00:28:25.267
on these devices

00:28:25.267 --> 00:28:27.267
and you wanna decrease
the latency,

00:28:27.267 --> 00:28:30.033
you want to stay off
the radio as much as possible

00:28:30.033 --> 00:28:32.033
and download as few bytes
as possible.

00:28:32.033 --> 00:28:33.667
And then once you got
the data in,

00:28:33.667 --> 00:28:36.033
you don't want to take
that much time to parse it.

00:28:36.033 --> 00:28:38.033
So for Android,
you'd have to download

00:28:38.033 --> 00:28:41.033
sort of a very verbose
JSON syntax

00:28:41.033 --> 00:28:45.100
then convert all the numbers
from ascii into like

00:28:45.100 --> 00:28:47.334
actual doubles
or floats or whatever.

00:28:47.334 --> 00:28:51.701
And it could be a bad
experience for mobile users.

00:28:51.701 --> 00:28:53.934
So ProtocolBuffers
are an alternative, right?

00:28:53.934 --> 00:28:55.133
So like I said,

00:28:55.133 --> 00:28:57.334
they're used by
all Google services.

00:28:57.334 --> 00:28:58.734
They're compact and fast.

00:28:58.734 --> 00:29:02.767
They have this, actually,
this feature of composeability

00:29:02.767 --> 00:29:04.834
which is not too important
for what we're talking about.

00:29:04.834 --> 00:29:07.434
They're forward-compatible,
what will happen is

00:29:07.434 --> 00:29:09.701
is let's say someone has
a ProtocolBuffer

00:29:09.701 --> 00:29:11.467
which is just like
a data structure

00:29:11.467 --> 00:29:12.701
you can send back and forth.

00:29:12.701 --> 00:29:14.234
And it has four fields in it

00:29:14.234 --> 00:29:16.267
let's say like your
first name, last name,

00:29:16.267 --> 00:29:17.701
you know, age and gender.

00:29:17.701 --> 00:29:20.701
And somebody comes along
and they add another field.

00:29:20.701 --> 00:29:25.200
Well, what happens is,
a client who is working with--

00:29:25.200 --> 00:29:28.801
who's inspecting the other one
that only had four fields,

00:29:28.801 --> 00:29:30.567
and now he gets one
with a fifth field,

00:29:30.567 --> 00:29:32.400
can kind of conveniently
ignore these extra fields.

00:29:32.400 --> 00:29:34.367
So it's kind of
forward-compatible.

00:29:34.367 --> 00:29:35.701
It's a very nice feature.

00:29:35.701 --> 00:29:37.534
However, it doesn't have
any built-in polymorphism,

00:29:37.534 --> 00:29:39.400
so you can't have like
sub-classes.

00:29:39.400 --> 00:29:41.701
Like you can't have
an animal protocol buffer

00:29:41.701 --> 00:29:45.300
that has like a dog and cat
and horse like subtypes,

00:29:45.300 --> 00:29:48.033
sub-message types.

00:29:48.033 --> 00:29:50.567
But you can fake it.

00:29:50.567 --> 00:29:52.501
However,
I like to use GWT RPC,

00:29:52.501 --> 00:29:55.434
and the reason I like
to use GWT RPC

00:29:55.434 --> 00:29:57.601
is that there's no pain
to using it.

00:29:57.601 --> 00:29:59.634
You write an interface.

00:29:59.634 --> 00:30:02.100
You implement the interface
in a servlet.

00:30:02.100 --> 00:30:04.934
and then on the client
you invoke GWT RPC--

00:30:04.934 --> 00:30:08.467
GWT.create on the interface,
and it just works.

00:30:08.467 --> 00:30:11.534
And the performance
is very reasonable.

00:30:11.534 --> 00:30:13.767
And another cool thing
is actually, you know,

00:30:13.767 --> 00:30:15.934
you can sort of step through

00:30:15.934 --> 00:30:17.901
an RPC call
on your Java debugger

00:30:17.901 --> 00:30:20.100
and have the break point
run on the server.

00:30:20.100 --> 00:30:22.534
You can step like from client
to server almost.

00:30:22.534 --> 00:30:24.567
That's pretty cool.

00:30:24.567 --> 00:30:28.534
The problem is
it's very GWT-specific.

00:30:28.534 --> 00:30:30.033
You know, about about Android?

00:30:30.033 --> 00:30:34.067
If you wrote your servlet
using GWT RPC,

00:30:34.067 --> 00:30:36.834
how can people
who are using Android

00:30:36.834 --> 00:30:40.868
talk to your servlet now?

00:30:40.868 --> 00:30:43.234
Well, one of the things
I've been experimenting with,

00:30:43.234 --> 00:30:46.200
and this is something--

00:30:46.200 --> 00:30:48.000
I always try to throw in
something

00:30:48.000 --> 00:30:51.300
that's a little, you know,
off the beaten path--

00:30:51.300 --> 00:30:55.934
is using Android to talk
to GWT RPC servlets.

00:30:55.934 --> 00:30:58.000
So we implement GWT RPC
on the server,

00:30:58.000 --> 00:31:02.767
but then on the client
we implement GWT RPC in Android.

00:31:02.767 --> 00:31:04.567
An the way you can do this is

00:31:04.567 --> 00:31:06.701
is if you use
dependency injection,

00:31:06.701 --> 00:31:10.901
you can inject an implementation
of an RPC interface on Android.

00:31:10.901 --> 00:31:12.968
But let's say it's like,
you know, customer service,

00:31:12.968 --> 00:31:16.334
and there's a method called
like, you know, get...

00:31:16.334 --> 00:31:18.534
get account representative
or something, right?

00:31:18.534 --> 00:31:20.400
So it's an abstract interface.

00:31:20.400 --> 00:31:21.968
And what you can do in Guice

00:31:21.968 --> 00:31:26.501
is you can inject
a implementation of this

00:31:26.501 --> 00:31:28.667
by intercepting method calls
to it.

00:31:28.667 --> 00:31:33.634
Now, with Guice, basically,
I use this AOP Library,

00:31:33.634 --> 00:31:35.000
AOP Alliance Library
for doing that,

00:31:35.000 --> 00:31:36.667
and unfortunately,
it doesn't run on Android.

00:31:36.667 --> 00:31:39.968
'Cause Android doesn't want you
to dynamically modify byte code.

00:31:39.968 --> 00:31:42.367
But what Android does support

00:31:42.367 --> 00:31:45.667
is the original sort of
method interception technology

00:31:45.667 --> 00:31:48.100
that's built into the J2SE
that not many people use

00:31:48.100 --> 00:31:51.601
which is the
java.lang.reflect.Proxy.

00:31:51.601 --> 00:31:53.133
So what you can actually do

00:31:53.133 --> 00:31:57.267
is you could intercept calls
to that interface

00:31:57.267 --> 00:31:58.767
using this object

00:31:58.767 --> 00:32:01.567
and dynamically implement
a call to a method

00:32:01.567 --> 00:32:03.133
that has no underlying
implementation.

00:32:03.133 --> 00:32:05.234
So your get account
representative thing

00:32:05.234 --> 00:32:06.734
can be intercepted,

00:32:06.734 --> 00:32:08.534
and you can catch
that attempt to invoke it

00:32:08.534 --> 00:32:12.434
and then use what's called
the SerializationStreamWriter

00:32:12.434 --> 00:32:18.367
that comes in G-W-T
to invoke an RPC method

00:32:18.367 --> 00:32:20.100
over the wire.

00:32:20.100 --> 00:32:21.868
So you'd use the
SerializationStreamWriter,

00:32:21.868 --> 00:32:23.934
encode your method invocation,

00:32:23.934 --> 00:32:26.234
and then use the HTTPClient
to just send that over

00:32:26.234 --> 00:32:28.334
as like a post to the server.

00:32:28.334 --> 00:32:31.634
So it's...
I've prototyped it.

00:32:31.634 --> 00:32:33.734
It's kind of cool,
and if it can be made to work,

00:32:33.734 --> 00:32:36.868
Then you could actually
write one servlet

00:32:36.868 --> 00:32:40.033
that can serve mobile devices,
could serve GWT

00:32:40.033 --> 00:32:44.067
and maybe even
server-to-server calls.

00:32:44.067 --> 00:32:48.701
So I'm going to
digress a little bit

00:32:48.701 --> 00:32:50.501
and talk about
user management.

00:32:50.501 --> 00:32:52.634
So when you develop
an application these days,

00:32:52.634 --> 00:32:54.400
usually one of the first
things you start out with

00:32:54.400 --> 00:32:56.100
is making the user table
in your database.

00:32:56.100 --> 00:32:57.467
'Cause you gotta have users.

00:32:57.467 --> 00:32:59.400
So you gotta start using
a password,

00:32:59.400 --> 00:33:02.334
you gotta have a sign-up
method.

00:33:02.334 --> 00:33:05.667
You've gotta be able
to authorize them, and so on.

00:33:05.667 --> 00:33:07.934
But if you don't want to go
through all that hassle,

00:33:07.934 --> 00:33:10.334
what you can do is
if you deploy the AppEngine,

00:33:10.334 --> 00:33:14.167
you can leverage the existing
user service API that they have.

00:33:14.167 --> 00:33:15.901
In that case,
anybody can log in

00:33:15.901 --> 00:33:20.868
with their existing
Google credentials.

00:33:20.868 --> 00:33:22.801
The other thing is
is you could use a library

00:33:22.801 --> 00:33:24.934
called OpenID for Java,

00:33:24.934 --> 00:33:28.767
and you could take
any OpenID credential

00:33:28.767 --> 00:33:32.734
from other providers,
like Yahoo has OpenID,

00:33:32.734 --> 00:33:34.400
MySpace has OpenID, and so on.

00:33:34.400 --> 00:33:36.033
People could log into
your service

00:33:36.033 --> 00:33:39.067
with their MySpace credentials
or with their Yahoo credentials,

00:33:39.067 --> 00:33:41.968
in which case
you don't have to

00:33:41.968 --> 00:33:44.734
spend as much time implementing
the authentication piece of it.

00:33:44.734 --> 00:33:46.200
But more than that,

00:33:46.200 --> 00:33:48.033
it kind of lowers the barrier
to enter to your app,

00:33:48.033 --> 00:33:49.734
because now the user
doesn't have to go through

00:33:49.734 --> 00:33:51.901
a really boring sign-up process,

00:33:51.901 --> 00:33:54.534
"Let me think up
another password."

00:33:54.534 --> 00:33:56.100
You know, "Let me fill out
all my information."

00:33:56.100 --> 00:33:58.267
They can just sign in with their
existing credentials.

00:33:58.267 --> 00:34:00.634
So that's one of the APIs

00:34:00.634 --> 00:34:02.968
that sort of helps
your productivity.

00:34:02.968 --> 00:34:06.567
The other key piece, when
you're developing applications,

00:34:06.567 --> 00:34:09.267
is you know, how are you
gonna persist your data?

00:34:09.267 --> 00:34:10.767
And the traditional way
you do it, of course,

00:34:10.767 --> 00:34:12.567
little AMP stack, 
is you have my MySQL

00:34:12.567 --> 00:34:14.501
and you use Hibernate
or you use Rails

00:34:14.501 --> 00:34:15.868
or you use Django.

00:34:15.868 --> 00:34:17.267
Use one of those things,
basically,

00:34:17.267 --> 00:34:21.467
to take your objects
and map them onto the database.

00:34:21.467 --> 00:34:24.801
But Google provides
an alternative to that,

00:34:24.801 --> 00:34:27.601
so AppEngine,
as you've probably heard,

00:34:27.601 --> 00:34:29.234
is not a relational database.

00:34:29.234 --> 00:34:31.300
This is what Google uses
on their back end.

00:34:31.300 --> 00:34:34.667
It's totally different
datastore technology.

00:34:34.667 --> 00:34:38.367
However, they provide
an object relational layer

00:34:38.367 --> 00:34:41.968
based on the JDO standard.

00:34:41.968 --> 00:34:45.200
Now, you may not
have heard of JDO

00:34:45.200 --> 00:34:47.767
until like Google
started using it.

00:34:47.767 --> 00:34:52.467
You probably were using JPA.
JDO kind of died for a while.

00:34:52.467 --> 00:34:56.434
And JPA and Harmony
kind of owned it.

00:34:56.434 --> 00:34:59.667
But JDO actually has some
features that those don't.

00:34:59.667 --> 00:35:03.968
It actually
is more abstract than JPA.

00:35:03.968 --> 00:35:06.634
And JPA is tightly bound
to the idea

00:35:06.634 --> 00:35:07.968
of a relational database.

00:35:07.968 --> 00:35:09.834
JDO is actually so abstract

00:35:09.834 --> 00:35:12.367
that it can store data
to almost anything.

00:35:12.367 --> 00:35:15.267
So if you write your application
using JDO,

00:35:15.267 --> 00:35:18.300
you can move it from MySQL
to AppEngine and back,

00:35:18.300 --> 00:35:20.200
but more, if you go look
at the underlying

00:35:20.200 --> 00:35:23.934
data nucleus libraries
that Google is using,

00:35:23.934 --> 00:35:27.000
you could persist data
into Excel.

00:35:27.000 --> 00:35:28.868
You can persist data
into HML.

00:35:28.868 --> 00:35:32.734
You can persist data
into almost any storage format.

00:35:32.734 --> 00:35:34.701
So I mean, someone can hand you
an Excel file,

00:35:34.701 --> 00:35:37.200
you can basically do
a JDO Query across it.

00:35:37.200 --> 00:35:39.133
So it's really,
really flexible.

00:35:39.133 --> 00:35:43.701
And the interesting
question to me is...

00:35:43.701 --> 00:35:46.534
what of the native storage
in HTML5 are Android?

00:35:46.534 --> 00:35:48.400
You know, maybe a cool idea

00:35:48.400 --> 00:35:50.601
for maybe one of you guys
to explore is

00:35:50.601 --> 00:35:52.701
perhaps a JDO Mapping in GWT

00:35:52.701 --> 00:35:56.267
for mapping onto the native
storage mechanism

00:35:56.267 --> 00:35:59.234
in the browser that's being
made available these days.

00:35:59.234 --> 00:36:01.634
But the key takeaway here

00:36:01.634 --> 00:36:06.133
is that the JDO APIs that Google
sort of settled on

00:36:06.133 --> 00:36:08.234
are very, very flexible,

00:36:08.234 --> 00:36:10.968
and you can write an APP
that does not lock you in

00:36:10.968 --> 00:36:12.400
to AppEngine in any way.

00:36:12.400 --> 00:36:13.601
So if you're sort of thinking,

00:36:13.601 --> 00:36:16.367
vendor lock-in,
I'll be stuck on Google...

00:36:16.367 --> 00:36:19.300
if you use JDO,
you actually won't.

00:36:19.300 --> 00:36:21.100
It's kind of cool.

00:36:21.100 --> 00:36:24.968
Okay, so the next thing
that Google provides

00:36:24.968 --> 00:36:26.901
which is really powerful
is gadgets.

00:36:26.901 --> 00:36:29.634
So a lot of times,
you know...

00:36:29.634 --> 00:36:31.634
it might not even be necessary

00:36:31.634 --> 00:36:33.000
for you to develop
an application

00:36:33.000 --> 00:36:36.501
where you have to, you know,
develop an entire website.

00:36:36.501 --> 00:36:38.200
It's possible for you
to develop an application

00:36:38.200 --> 00:36:39.901
that lives entirely
within a gadget.

00:36:39.901 --> 00:36:41.501
And there have been
some success stories

00:36:41.501 --> 00:36:43.601
of people deploying gadgets
on like Google IO

00:36:43.601 --> 00:36:45.400
where they've made quite
a bit of money from it.

00:36:45.400 --> 00:36:51.567
But one of the cool things
is that if you develop a gadget,

00:36:51.567 --> 00:36:53.434
it can be embedded anywhere.

00:36:53.434 --> 00:36:55.667
You've seen it embedded
in Google Wave today

00:36:55.667 --> 00:36:56.901
at the keynote.

00:36:56.901 --> 00:36:58.601
It fits in OpenSocial
containers,

00:36:58.601 --> 00:37:00.100
Google Friend Connect sites,

00:37:00.100 --> 00:37:03.300
in Maps, Calendar,
Spreadsheets.

00:37:03.300 --> 00:37:06.200
In fact, there was just
announced yesterday

00:37:06.200 --> 00:37:08.033
the real-time Gadget API

00:37:08.033 --> 00:37:10.501
where you can drop gadgets
into the Google chat window

00:37:10.501 --> 00:37:12.200
and implement real-time games.

00:37:12.200 --> 00:37:14.467
So someone updates
a JavaScript object,

00:37:14.467 --> 00:37:16.234
the other people
you're chatting with,

00:37:16.234 --> 00:37:18.767
they instantly get notification,
just like in Google Wave.

00:37:18.767 --> 00:37:20.868
You get the notification
immediately.

00:37:20.868 --> 00:37:23.767
So what I'm gonna show you is,
and hopefully it's gonna work,

00:37:23.767 --> 00:37:26.200
I'm gonna show you...

00:37:26.200 --> 00:37:29.000
how I was able to leverage
Google Gadgets

00:37:29.000 --> 00:37:31.000
to solve a very real problem
I had.

00:37:31.000 --> 00:37:32.467
So I had the problem of like

00:37:32.467 --> 00:37:34.968
so how do I get data
into my system?

00:37:34.968 --> 00:37:38.367
I could write like a really
complex web-based GUI

00:37:38.367 --> 00:37:39.767
that was sort of like
a spreadsheet

00:37:39.767 --> 00:37:43.100
and allowed you to import a CSV
and some other stuff

00:37:43.100 --> 00:37:47.267
and then choose, you know,
what columns I want

00:37:47.267 --> 00:37:49.334
and how I want to basically
graph it.

00:37:49.334 --> 00:37:50.734
But instead, what I did,

00:37:50.734 --> 00:37:52.968
because that seemed
very daunting,

00:37:52.968 --> 00:37:55.467
is I leveraged the feature
of Google Spreadsheets,

00:37:55.467 --> 00:37:59.767
which allows you to drop Google
GViz gadgets into it.

00:37:59.767 --> 00:38:01.434
So here's a spreadsheet
I've got,

00:38:01.434 --> 00:38:05.367
and it's got
three time series in it--

00:38:05.367 --> 00:38:08.834
price, oil, and food.

00:38:08.834 --> 00:38:11.300
And in between, you can see

00:38:11.300 --> 00:38:13.167
that there's these columns
called Markers.

00:38:13.167 --> 00:38:14.434
So what's gonna happen

00:38:14.434 --> 00:38:16.467
is anywhere that there's
a column called Markers

00:38:16.467 --> 00:38:18.334
and it has text in it,

00:38:18.334 --> 00:38:21.434
it's gonna drop
a GMaps-type push-pin

00:38:21.434 --> 00:38:23.367
on that data point in the chart.

00:38:23.367 --> 00:38:24.601
So the cool thing is like

00:38:24.601 --> 00:38:26.267
if I want to chart
all three of these,

00:38:26.267 --> 00:38:30.501
I can just drag, select--
whoops.

00:38:30.501 --> 00:38:33.734
Just drag, select that...

00:38:33.734 --> 00:38:35.901
and hopefully,
this will work.

00:38:35.901 --> 00:38:39.634
The network connection is...

00:38:39.634 --> 00:38:41.901
not going to fight me.

00:38:49.734 --> 00:38:52.868
And let me just add
a little extra flag there

00:38:52.868 --> 00:38:54.934
in case something goes wrong.

00:38:54.934 --> 00:39:01.300
Okay, so let me click
apply and close.

00:39:01.300 --> 00:39:03.801
And...there we go.

00:39:03.801 --> 00:39:06.501
So basically what you can do

00:39:06.501 --> 00:39:10.534
is you can write gadgets
that live inside Google Apps,

00:39:10.534 --> 00:39:12.767
and what this gives me
is the capability

00:39:12.767 --> 00:39:15.467
to say to people who want
to put data into my system

00:39:15.467 --> 00:39:19.400
go take your Excel data
or your Google Spreadsheet data

00:39:19.400 --> 00:39:21.567
and drop this gadget
in there.

00:39:21.567 --> 00:39:24.000
Export your Excel data
into Google Spreadsheets

00:39:24.000 --> 00:39:25.467
and drop this gadget in there.

00:39:25.467 --> 00:39:28.033
And then you can share it
with people

00:39:28.033 --> 00:39:29.767
and publish it to the Web.

00:39:29.767 --> 00:39:34.400
So for example, this same
gadget you saw right there,

00:39:34.400 --> 00:39:36.701
it can appear on any website.

00:39:36.701 --> 00:39:41.200
So here it is embedded
on another website.

00:39:41.200 --> 00:39:43.501
Let's wait for it to load.

00:39:47.000 --> 00:39:48.701
Oh, there we go.

00:39:48.701 --> 00:39:50.634
So here that same gadget
as it's appearing here.

00:39:50.634 --> 00:39:52.934
So you don't actually
have to have the gadget

00:39:52.934 --> 00:39:54.100
live in the spreadsheet.

00:39:54.100 --> 00:39:55.367
You can drop the gadget
in the spreadsheet,

00:39:55.367 --> 00:39:57.934
and then you can go put it
in your own application

00:39:57.934 --> 00:39:59.434
like you would see here.

00:39:59.434 --> 00:40:01.267
And the cool thing
is if somebody updates the data

00:40:01.267 --> 00:40:04.234
in the spreadsheet,
it will be reflected here.

00:40:04.234 --> 00:40:09.801
So...that is...

00:40:09.801 --> 00:40:12.868
how you can make
Google Gadgets

00:40:12.868 --> 00:40:17.100
work for you and solve
a pressing API issue,

00:40:17.100 --> 00:40:22.234
like if you don't want to
build your own spreadsheet.

00:40:22.234 --> 00:40:23.701
So this is leveraging an API

00:40:23.701 --> 00:40:26.934
called the Google
Visualization API, GViz.

00:40:26.934 --> 00:40:29.200
I don't know if you guys
went to any of the sessions,

00:40:29.200 --> 00:40:31.701
but it's kind of
a cool API.

00:40:31.701 --> 00:40:35.300
You can pump data into it
using JavaScript for GWT

00:40:35.300 --> 00:40:37.801
and out pops any of,
let's say,

00:40:37.801 --> 00:40:39.734
15 or 20 different charts,

00:40:39.734 --> 00:40:42.334
pie charts, bar charts,
scatter charts,

00:40:42.334 --> 00:40:44.234
animated charts
and things like that.

00:40:44.234 --> 00:40:45.801
And a lot of the Google
products you see

00:40:45.801 --> 00:40:47.234
like Analytics
and all these things,

00:40:47.234 --> 00:40:49.367
they kind of leverage
this stuff.

00:40:49.367 --> 00:40:50.934
The cool thing is

00:40:50.934 --> 00:40:52.734
is that third parties
can submit new extensions.

00:40:52.734 --> 00:40:54.367
So let's say you guys
come up with

00:40:54.367 --> 00:40:58.868
a new way to visualize data.

00:40:58.868 --> 00:41:02.434
Maybe it's a spider graph
or one of these really bizarre

00:41:02.434 --> 00:41:04.634
or very artsy-looking graphs,

00:41:04.634 --> 00:41:06.167
hyperbolic charts
and things like that.

00:41:06.167 --> 00:41:07.534
You can write it up,

00:41:07.534 --> 00:41:09.434
and it could be
a JavaScript Library,

00:41:09.434 --> 00:41:11.834
it could be a GWT Library,
and you submit it to Google.

00:41:11.834 --> 00:41:14.467
And what will happen is
it will appear,

00:41:14.467 --> 00:41:17.133
if you submit it to them
and they approve it,

00:41:17.133 --> 00:41:18.801
in the spreadsheet.

00:41:18.801 --> 00:41:20.501
So when you go here
and you say insert

00:41:20.501 --> 00:41:23.834
and you pull up the gadget,
it actually will appear here.

00:41:23.834 --> 00:41:25.567
So there's like a list
of all the charts

00:41:25.567 --> 00:41:27.234
you can see here.

00:41:27.234 --> 00:41:31.367
So it's one way to sort of...
publish gadgets.

00:41:31.367 --> 00:41:32.667
And as you can see,

00:41:32.667 --> 00:41:34.033
there are commercial
gadgets here.

00:41:34.033 --> 00:41:35.901
Like FusionCharts is
actually a commercial product.

00:41:35.901 --> 00:41:38.901
So this can be used
to actually drive revenue.

00:41:38.901 --> 00:41:40.367
So if you've got
a charting product

00:41:40.367 --> 00:41:42.000
and people start
using it here,

00:41:42.000 --> 00:41:45.467
maybe they'll buy your license
to your real chart product.

00:41:49.934 --> 00:41:51.901
All right, so multimedia.

00:41:51.901 --> 00:41:54.400
So let's say you want
to basically

00:41:54.400 --> 00:41:56.701
write something
like TwitPic

00:41:56.701 --> 00:41:59.100
or one of these other
photosharing services.

00:41:59.100 --> 00:42:02.367
Or you wanna do like
a video hosting service.

00:42:02.367 --> 00:42:05.501
Rather than build your own
scalable massive picture

00:42:05.501 --> 00:42:07.434
and video hosting back in,

00:42:07.434 --> 00:42:09.300
you can actually leverage
Google's infrastructure

00:42:09.300 --> 00:42:11.801
using either
the Picasa GData API

00:42:11.801 --> 00:42:13.834
or the YouTube API.

00:42:13.834 --> 00:42:15.534
And what you can do
with these APIs

00:42:15.534 --> 00:42:17.033
is not only can you
get a list

00:42:17.033 --> 00:42:18.667
of like photos
that you've published to Google,

00:42:18.667 --> 00:42:21.734
you can actually upload
multimedia over the API.

00:42:21.734 --> 00:42:23.534
So you can take photos,
take videos,

00:42:23.534 --> 00:42:25.868
and you can push them
into Google's infrastructure.

00:42:25.868 --> 00:42:28.067
And then later on,
you can pull them out.

00:42:28.067 --> 00:42:30.133
And it's possible
to develop an API--

00:42:30.133 --> 00:42:32.534
sorry, a website that looks
completely different

00:42:32.534 --> 00:42:34.834
than a Picasa or YouTube.

00:42:34.834 --> 00:42:36.234
You can just sit it on top
of their APIs

00:42:36.234 --> 00:42:38.234
and sort of make a clone
website that looks different,

00:42:38.234 --> 00:42:40.634
maybe better.

00:42:40.634 --> 00:42:43.634
In particular, I use the
YouTube Chromeless Player API,

00:42:43.634 --> 00:42:45.434
and this is kind of
an interesting thing.

00:42:45.434 --> 00:42:48.434
Let's say you don't like the
way the YouTube Player looks.

00:42:48.434 --> 00:42:49.934
So you could write
an application

00:42:49.934 --> 00:42:52.634
that pushes video into YouTube

00:42:52.634 --> 00:42:55.334
and host it there
using the GData API.

00:42:55.334 --> 00:42:58.334
And then you can pull down
their Chromeless Player API,

00:42:58.334 --> 00:43:00.501
which is the Flash Player

00:43:00.501 --> 00:43:03.200
but without any of
the cruft around it.

00:43:03.200 --> 00:43:05.601
And then you could put on
your own UI on top of that,

00:43:05.601 --> 00:43:08.434
so you might wanna have
different buttons,

00:43:08.434 --> 00:43:10.501
buttons for adding annotations,
sharing with friends.

00:43:10.501 --> 00:43:12.000
You might want to totally
redesign the way it looks.

00:43:12.000 --> 00:43:13.367
And it's possible to do that.

00:43:13.367 --> 00:43:15.834
Obviously, with HTML5 video tag,
it'd be ever easier.

00:43:15.834 --> 00:43:17.067
But today you can do it

00:43:17.067 --> 00:43:18.501
with the YouTube Chromeless
Player API.

00:43:18.501 --> 00:43:21.767
Think of it as a way to sort
of emulate the video tag today

00:43:21.767 --> 00:43:25.434
using Google's infrastructure.

00:43:25.434 --> 00:43:29.667
Okay, so one of the last things
I wanted to talk about

00:43:29.667 --> 00:43:31.534
is Google Checkout.

00:43:31.534 --> 00:43:36.567
So we came to--after we did
all the stuff with the chart,

00:43:36.567 --> 00:43:39.701
we tried to do
a OEM licensing model.

00:43:39.701 --> 00:43:42.367
People said, hey, we want
to license a chart

00:43:42.367 --> 00:43:45.934
and we want to basically
use it in our application.

00:43:45.934 --> 00:43:48.200
But a number of people
came to us and said,

00:43:48.200 --> 00:43:49.868
"We don't want to license it.

00:43:49.868 --> 00:43:51.234
"We just want you to host this.

00:43:51.234 --> 00:43:52.868
"It's too much effort
for us to do our own builds,

00:43:52.868 --> 00:43:54.567
"build our own GWT APPs
and stuff like that.

00:43:54.567 --> 00:43:57.234
"We just want to like...you host
the data, you host the chart.

00:43:57.234 --> 00:43:59.934
We just wanna
pay a monthly fee."

00:43:59.934 --> 00:44:03.400
So approximately,
not even two months ago

00:44:03.400 --> 00:44:04.834
when Google AppEngine launched,

00:44:04.834 --> 00:44:09.501
we started doing a software
service implementation.

00:44:09.501 --> 00:44:11.033
And we came to the problem
of like,

00:44:11.033 --> 00:44:14.100
how do we...take orders?

00:44:14.100 --> 00:44:16.300
How do we take monthly orders?

00:44:16.300 --> 00:44:19.100
And Google recently launched,
if you're not aware of it,

00:44:19.100 --> 00:44:21.167
what's called
the subscription API.

00:44:21.167 --> 00:44:23.534
So you might have
like an online newsletter

00:44:23.534 --> 00:44:25.033
or you're selling some other
kind of digital good

00:44:25.033 --> 00:44:26.167
that you want people
to subscribe to

00:44:26.167 --> 00:44:27.601
and pay a monthly fee--

00:44:27.601 --> 00:44:29.667
maybe it's an online
multiplayer game or something

00:44:29.667 --> 00:44:31.300
There's a new API

00:44:31.300 --> 00:44:37.834
where you can charge somebody
a reoccurring monthly fee.

00:44:37.834 --> 00:44:40.334
So we looked at this
and we said,

00:44:40.334 --> 00:44:41.601
oh, wow, this is gonna--

00:44:41.601 --> 00:44:45.067
Google Checkout fits exactly
what we wanna do.

00:44:45.067 --> 00:44:47.934
We can use this to monetize
our software as a service.

00:44:47.934 --> 00:44:50.033
However...

00:44:50.033 --> 00:44:51.901
you know, how do we
integrate with it, right?

00:44:51.901 --> 00:44:53.701
There's a number of different
ways to integrate with it,

00:44:53.701 --> 00:44:55.234
an we sort of needed
a lower level of control

00:44:55.234 --> 00:44:56.767
of how Order Processing works.

00:44:56.767 --> 00:44:59.067
And Google
lets you have as much

00:44:59.067 --> 00:45:00.801
or as little control
as you want.

00:45:00.801 --> 00:45:02.634
So you could tell Google,

00:45:02.634 --> 00:45:05.234
handle all aspects
of the Google Checkout process.

00:45:05.234 --> 00:45:07.868
Like all I ever want
to see from you at the very end

00:45:07.868 --> 00:45:09.934
is an email that says you
charged the person's credit card

00:45:09.934 --> 00:45:11.734
and shipped the order to them.

00:45:11.734 --> 00:45:13.834
So they can handle
the entire workflow.

00:45:13.834 --> 00:45:17.300
Or you can actually intercept
that process

00:45:17.300 --> 00:45:18.634
at any point in time
with several APIs

00:45:18.634 --> 00:45:21.334
like the Merchant Calc API,
the Notification API,

00:45:21.334 --> 00:45:22.834
the Order Processing API

00:45:22.834 --> 00:45:26.434
and react to the different
stages of the order process.

00:45:26.434 --> 00:45:29.234
So we actually integrated
with the Notification API.

00:45:29.234 --> 00:45:30.968
We wanted to be notified

00:45:30.968 --> 00:45:34.133
after the person submitted
the shopping cart

00:45:34.133 --> 00:45:35.601
so that we could do
additional things

00:45:35.601 --> 00:45:37.334
like send you an API Key

00:45:37.334 --> 00:45:41.067
for using our widgets
and things like that.

00:45:41.067 --> 00:45:45.634
So this is what a checkout
flow looks like,

00:45:45.634 --> 00:45:50.501
and there's various parts
where you can integrate into it.

00:45:50.501 --> 00:45:55.033
We integrate only at
the level of Notification API.

00:45:55.033 --> 00:45:59.567
That's like the second
divider over.

00:45:59.567 --> 00:46:01.367
So the question is
how do you do it?

00:46:01.367 --> 00:46:03.100
There's many different ways
to do it,

00:46:03.100 --> 00:46:05.834
and we chose to use
the XML API to export.

00:46:05.834 --> 00:46:07.934
And since we were on AppEngine,

00:46:07.934 --> 00:46:10.934
we had to figure out
how do we do this quickly,

00:46:10.934 --> 00:46:13.000
'cause we were trying to do it
in two months before IO.

00:46:13.000 --> 00:46:14.400
We were trying to ready
this whole thing

00:46:14.400 --> 00:46:16.601
so that we could
show it off at IO.

00:46:16.601 --> 00:46:19.601
And there's this API that
comes with Java called JAXB.

00:46:19.601 --> 00:46:21.701
I don't know how many people
are familiar with it,

00:46:21.701 --> 00:46:23.501
but it basically
allows you to map--

00:46:23.501 --> 00:46:26.200
just like JDO can map
database data

00:46:26.200 --> 00:46:29.501
into object/relational mapping
into Java objects,

00:46:29.501 --> 00:46:32.501
JAXB can map XML
into Java POJOs.

00:46:32.501 --> 00:46:34.601
So what we did--

00:46:34.601 --> 00:46:38.200
Java beans, basically.
Java POJOs.

00:46:38.200 --> 00:46:39.667
Plain old Java objects.

00:46:39.667 --> 00:46:42.334
So you can say, I want this tag
to go into this field

00:46:42.334 --> 00:46:43.901
and this tag to go
into this field

00:46:43.901 --> 00:46:45.734
and this attribute to go
into that field, and so on.

00:46:45.734 --> 00:46:47.200
And it's bi-directional,

00:46:47.200 --> 00:46:50.501
so you can take Java objects
and turn them back into XML.

00:46:50.501 --> 00:46:52.634
The cool thing is
is that you start with a schema.

00:46:52.634 --> 00:46:55.300
So Google publishes
an XML schema

00:46:55.300 --> 00:46:57.934
for all of their
checkout-related APIs.

00:46:57.934 --> 00:47:01.968
You can pump that into
the JAXB schema compiler,

00:47:01.968 --> 00:47:04.734
and what it does
is it looks at the schema

00:47:04.734 --> 00:47:06.801
and it generates Java objects

00:47:06.801 --> 00:47:11.968
for every HXL element
that's important in the schema.

00:47:11.968 --> 00:47:14.567
And then once you got that,
you're pretty much done.

00:47:14.567 --> 00:47:16.667
You can take XML
from any source,

00:47:16.667 --> 00:47:19.334
like let's say from Google
notifying you,

00:47:19.334 --> 00:47:22.200
an XML message
from someone checking out,

00:47:22.200 --> 00:47:23.868
and you de-serialize it
into a Java object

00:47:23.868 --> 00:47:25.701
and just call
Getters and Setters.

00:47:25.701 --> 00:47:29.901
And...this diagram represents
like what we're doing,

00:47:29.901 --> 00:47:33.767
so we basically take
notifications back from Google

00:47:33.767 --> 00:47:35.267
at the bottom,

00:47:35.267 --> 00:47:37.400
and we de-serialize them
in a servlet into Java POJOs.

00:47:37.400 --> 00:47:38.868
We do our business logic,

00:47:38.868 --> 00:47:41.100
interact with the AppEngine
datastore,

00:47:41.100 --> 00:47:45.767
and we send requests back to
the checkout API.

00:47:45.767 --> 00:47:49.667
However...if you were to take
what I just told you

00:47:49.667 --> 00:47:51.467
and you go ahead and try it,

00:47:51.467 --> 00:47:53.567
you're gonna kinda be in
for a rude awakening,

00:47:53.567 --> 00:47:55.067
because, unfortunately,

00:47:55.067 --> 00:47:57.934
JAXB isn't a whitelisted API
on the AppEngine.

00:47:57.934 --> 00:48:01.400
So AppEngine has this notion
of what's allowed,

00:48:01.400 --> 00:48:03.267
what APIs are allowed
and which aren't.

00:48:03.267 --> 00:48:05.601
JAXB's actually part of
Java 6.

00:48:05.601 --> 00:48:09.167
It's part of the package
javax.xml.bind.

00:48:09.167 --> 00:48:12.234
But AppEngine
won't let you use it.

00:48:12.234 --> 00:48:14.901
So there's
a tricky workaround,

00:48:14.901 --> 00:48:16.267
and one of the things
you can do

00:48:16.267 --> 00:48:18.000
is you can use
these utilities like JARJAR

00:48:18.000 --> 00:48:19.767
or you can use IDE refactoring.

00:48:19.767 --> 00:48:23.234
And all you gotta do is move
it into another package.

00:48:23.234 --> 00:48:25.767
So you can move like
javax.whatever

00:48:25.767 --> 00:48:28.901
in AppEngine.javax,
and once you do that, it works.

00:48:28.901 --> 00:48:30.534
So if anybody in the audience

00:48:30.534 --> 00:48:32.934
is doing JAXB integration
in AppEngine--

00:48:32.934 --> 00:48:35.701
'cause this is a highly starred
issue in the issue tracker.

00:48:35.701 --> 00:48:37.100
It's got like 70 votes on it.

00:48:37.100 --> 00:48:38.634
If you're interested
in doing it,

00:48:38.634 --> 00:48:40.267
I have a build
of the JAXB Libraries

00:48:40.267 --> 00:48:41.367
that will work in AppEngine.

00:48:41.367 --> 00:48:44.868
So you can send me an email.

00:48:44.868 --> 00:48:47.634
So to recap,

00:48:47.634 --> 00:48:50.968
there's 60+ APIs documented
on code.google.com.

00:48:50.968 --> 00:48:53.234
There's a lot, lot more of 'em
like Guice,

00:48:53.234 --> 00:48:55.767
in code.google.com/p.

00:48:55.767 --> 00:49:00.901
There's lots of soft-launched
APIs in Google Labs.

00:49:00.901 --> 00:49:02.400
And there are related APIs

00:49:02.400 --> 00:49:04.200
that are totally hosted
on separated websites.

00:49:04.200 --> 00:49:07.501
Like Apache Shindig
is not really a Google API,

00:49:07.501 --> 00:49:09.767
but actually, it is
the reference implementation

00:49:09.767 --> 00:49:11.100
of OpenSocial.

00:49:11.100 --> 00:49:12.601
So if you want to open
Social container,

00:49:12.601 --> 00:49:13.868
make your own social network,

00:49:13.868 --> 00:49:16.334
you just go download Shindig,
and you're done.

00:49:16.334 --> 00:49:19.133
Chromium, the browser...

00:49:19.133 --> 00:49:22.000
and then various OpenSocial
Foundation and Open Web groups

00:49:22.000 --> 00:49:23.901
actually have their own
sort of libraries.

00:49:23.901 --> 00:49:25.200
And a lot of the people
who are in those groups

00:49:25.200 --> 00:49:27.501
are Googlers
who are contributing code.

00:49:27.501 --> 00:49:29.734
So sort of a lot of stealth
Google products out there

00:49:29.734 --> 00:49:31.667
that you may not know about.

00:49:31.667 --> 00:49:35.501
So just to summarize...

00:49:35.501 --> 00:49:38.400
there's an API for almost
everything you want to do

00:49:38.400 --> 00:49:40.200
as part of your normal
application needs

00:49:40.200 --> 00:49:42.033
provided by Google.

00:49:42.033 --> 00:49:45.000
But by no means am I saying
like only use Google Services.

00:49:45.000 --> 00:49:46.834
You might tie yourself
to Google so tightly

00:49:46.834 --> 00:49:49.367
you might find yourself wishing
that, you know,

00:49:49.367 --> 00:49:51.000
that you can
get away from them later.

00:49:51.000 --> 00:49:52.968
But when you're
developing an App

00:49:52.968 --> 00:49:54.400
that does allow rapid
prototyping--

00:49:54.400 --> 00:49:56.000
if you want to do
video hosting

00:49:56.000 --> 00:49:57.601
and picture hosting,
stuff like that--

00:49:57.601 --> 00:49:58.834
there's a back end
infrastructure.

00:49:58.834 --> 00:50:00.167
It's very scalable.

00:50:00.167 --> 00:50:02.100
You can just leverage
off the bat.

00:50:02.100 --> 00:50:04.400
I call it one-stop shopping.

00:50:04.400 --> 00:50:06.133
So whenever
I'm developing an App

00:50:06.133 --> 00:50:07.601
and I need to do something

00:50:07.601 --> 00:50:09.200
and I don't feel like
implementing myself,

00:50:09.200 --> 00:50:12.000
I go to Google and see if they
already got something for me.

00:50:12.000 --> 00:50:14.400
So that's basically it.

00:50:14.400 --> 00:50:17.133
I hope people
got a good taste

00:50:17.133 --> 00:50:19.200
of the big variety of APIs

00:50:19.200 --> 00:50:21.033
that you can sort of leverage
with Google,

00:50:21.033 --> 00:50:23.367
and I'm willing
to take any questions.

00:50:23.367 --> 00:50:27.501
[applause]

