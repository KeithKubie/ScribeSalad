WEBVTT
Kind: captions
Language: en

00:00:00.140 --> 00:00:02.140
Thanks, for coming out to
listen to me talk about Vulkan.

00:00:02.140 --> 00:00:03.800
I know it's the first
day of Google I/O.

00:00:03.800 --> 00:00:05.883
And hopefully, all the
excitement of the first day

00:00:05.883 --> 00:00:07.472
hasn't died down for you yet.

00:00:07.472 --> 00:00:08.930
It's the last talk
slot of the day,

00:00:08.930 --> 00:00:11.470
so I'm sure people may be
anxious to get out of here

00:00:11.470 --> 00:00:13.140
and start partying.

00:00:13.140 --> 00:00:15.110
But we are here to
talk about Vulkan.

00:00:15.110 --> 00:00:16.830
And it's exciting
all on its own.

00:00:16.830 --> 00:00:19.230
It's one of my favorite
topics to talk about.

00:00:19.230 --> 00:00:22.160
And I've recently been
asked to maybe tone down

00:00:22.160 --> 00:00:24.230
the Vulkan talk a little bit.

00:00:24.230 --> 00:00:27.180
So it may be good for
you or bad for you.

00:00:27.180 --> 00:00:28.220
Let's find out.

00:00:28.220 --> 00:00:30.610
So let's go ahead and jump in.

00:00:30.610 --> 00:00:34.590
So Vulkan-- lots of
rules and no mercy.

00:00:34.590 --> 00:00:37.240
I've used this line a little
bit in all of my Vulkan talks,

00:00:37.240 --> 00:00:39.740
because I feel it captures the
general spirit of how people

00:00:39.740 --> 00:00:41.330
feel about Vulkan right now.

00:00:41.330 --> 00:00:44.920
And it's a bit of a
joke, because Vulkan

00:00:44.920 --> 00:00:47.710
does bring a lot of
good things with it,

00:00:47.710 --> 00:00:49.457
but it does have a
lot of complications

00:00:49.457 --> 00:00:51.790
that, hopefully, this talk
will help address some of it.

00:00:55.650 --> 00:00:59.740
So a little bit of introduction
before we continue.

00:00:59.740 --> 00:01:02.270
As you can probably see from
the program, my name is Hai.

00:01:02.270 --> 00:01:04.860
I am a creative technology
lead on Google's Art,

00:01:04.860 --> 00:01:05.820
Copy &amp; Code team.

00:01:05.820 --> 00:01:09.350
And my role on that team is to
explore different technologies,

00:01:09.350 --> 00:01:12.710
to find out how we can leverage
them for creative work.

00:01:12.710 --> 00:01:14.430
And some of the
things that I explore

00:01:14.430 --> 00:01:17.180
are things like Vulkan-- how
do you leverage new graphics

00:01:17.180 --> 00:01:20.360
APIs for use in applications?

00:01:20.360 --> 00:01:24.380
And I started working with
Vulkan about last December,

00:01:24.380 --> 00:01:28.940
a couple of months before
the February 16th launch.

00:01:28.940 --> 00:01:31.280
I implemented Cinder's
Vulkan support

00:01:31.280 --> 00:01:33.370
on Android, Linux, and Windows.

00:01:33.370 --> 00:01:38.610
And then I subsequently ported
all the demos to Vulkan.

00:01:38.610 --> 00:01:41.140
Cinder is a C++ creative
coding framework.

00:01:41.140 --> 00:01:46.030
It runs on Android, iOS,
Linux, Windows, OS X.

00:01:46.030 --> 00:01:49.080
And it's open source under
the Simplified BSD License.

00:01:49.080 --> 00:01:51.960
Currently, the primary render
is OpenGL on the desktop

00:01:51.960 --> 00:01:56.110
and OpenGL ES on mobile.

00:01:56.110 --> 00:01:58.512
And that's where it is now.

00:01:58.512 --> 00:01:59.720
Will it change in the future?

00:01:59.720 --> 00:02:03.380
Probably, as Vulkan becomes
more popular, with the exception

00:02:03.380 --> 00:02:05.570
of iOS and OS X, of course.

00:02:05.570 --> 00:02:07.140
And Cinder gets
used in applications

00:02:07.140 --> 00:02:08.949
of all scales,
anything from mobile,

00:02:08.949 --> 00:02:11.540
to desktop, to very large-scale
installations that you

00:02:11.540 --> 00:02:13.450
might see in Times Square.

00:02:13.450 --> 00:02:16.130
Recently, Cinder has also
been used in the clouds

00:02:16.130 --> 00:02:18.140
to generate content.

00:02:18.140 --> 00:02:20.430
Vulkan support became
available in Cinder,

00:02:20.430 --> 00:02:23.350
as I mentioned earlier,
on Vulkan's launch date.

00:02:23.350 --> 00:02:25.830
Since Cinder is a
coding framework made

00:02:25.830 --> 00:02:28.470
to be used in very
many general cases,

00:02:28.470 --> 00:02:30.160
the implementation
is very much ongoing.

00:02:32.930 --> 00:02:36.310
So what this talk is not about--
this is an advanced level talk,

00:02:36.310 --> 00:02:38.490
so it's not an
introduction to Vulkan,

00:02:38.490 --> 00:02:40.964
it is not a tutorial
on Vulkan, and it's not

00:02:40.964 --> 00:02:42.380
an in-depth
examination of Vulkan.

00:02:42.380 --> 00:02:47.600
And if you'd like a really
good, quick read on Vulkan,

00:02:47.600 --> 00:02:51.720
RenderDoc has a really nice
Vulkan in 30 minutes document.

00:02:51.720 --> 00:02:54.220
And if you need to see
some tutorials on Vulkan,

00:02:54.220 --> 00:02:57.870
we have some tutorials
available on the GitHub repo.

00:02:57.870 --> 00:03:00.034
And if we were all
to sit here and do

00:03:00.034 --> 00:03:01.450
an in-depth
examination of Vulkan,

00:03:01.450 --> 00:03:03.892
it would probably
take about a month.

00:03:03.892 --> 00:03:06.100
But feel free, if you have
any questions specifically

00:03:06.100 --> 00:03:08.527
about any of the topics, to
stop me afterwards, or find me

00:03:08.527 --> 00:03:10.360
afterwards, and I'd
love to talk about them.

00:03:13.170 --> 00:03:16.390
So what this talk is about--
the bulk of this talk

00:03:16.390 --> 00:03:22.320
is how to get up and going
in Vulkan in a large way,

00:03:22.320 --> 00:03:25.510
not just writing sample code,
but actually getting something

00:03:25.510 --> 00:03:26.666
to production.

00:03:26.666 --> 00:03:31.730
And so it assumes that
you know about OpenGL ES.

00:03:31.730 --> 00:03:34.140
And it assumes that you know
a little bit about Vulkan,

00:03:34.140 --> 00:03:39.630
or some other explicit graphics
API, like Metal or DirectX 12.

00:03:39.630 --> 00:03:42.220
And since Vulkan
is definitely new,

00:03:42.220 --> 00:03:44.500
there are some sharp
edges in Vulkan.

00:03:44.500 --> 00:03:46.200
And I try to point
out the "gotchas"

00:03:46.200 --> 00:03:47.825
and why it's important
to pay attention

00:03:47.825 --> 00:03:51.510
to things like device
limits and the difference

00:03:51.510 --> 00:03:55.190
between desktop Vulkan
and mobile Vulkan.

00:03:55.190 --> 00:03:57.650
And there is a short
section on the things

00:03:57.650 --> 00:04:01.730
to consider if you're looking
for performance in Vulkan.

00:04:01.730 --> 00:04:04.230
And again, these are
kind of heavy topics.

00:04:04.230 --> 00:04:07.400
So if you find me say
something that's weird,

00:04:07.400 --> 00:04:10.040
and it's confusing,
please find me afterwards,

00:04:10.040 --> 00:04:13.410
and I'll be more than
happy to clarify them.

00:04:13.410 --> 00:04:16.149
All right, so to establish
a baseline between OpenGL ES

00:04:16.149 --> 00:04:19.504
and Vulkan-- so
this question gets

00:04:19.504 --> 00:04:20.920
asked more than
any other question

00:04:20.920 --> 00:04:22.600
when it comes to Vulkan.

00:04:22.600 --> 00:04:25.577
Is Vulkan faster than
OpenGL/OpenGL ES?

00:04:25.577 --> 00:04:26.410
The short answer is.

00:04:26.410 --> 00:04:28.570
Yes, but not from a direct port.

00:04:28.570 --> 00:04:29.390
Vulkan is new.

00:04:29.390 --> 00:04:32.810
And if you want to leverage
all the benefits of Vulkan,

00:04:32.810 --> 00:04:34.750
you will have to change
some of your code,

00:04:34.750 --> 00:04:36.690
if not a lot of your
code, and definitely some

00:04:36.690 --> 00:04:37.398
of your thinking.

00:04:40.930 --> 00:04:42.620
Vulkan on mobile's
feature set is

00:04:42.620 --> 00:04:46.230
comparable to that
have of OpenGL ES 3.1.

00:04:46.230 --> 00:04:48.420
However, it does go to
include compute, geometry,

00:04:48.420 --> 00:04:50.160
and tessellation shader support.

00:04:50.160 --> 00:04:51.700
It is an explicit API.

00:04:51.700 --> 00:04:56.560
The developer has direct
control of almost every object

00:04:56.560 --> 00:04:58.270
in the rendering pipeline.

00:04:58.270 --> 00:05:01.540
The developer's also responsible
for memory management.

00:05:01.540 --> 00:05:03.500
There are some new
objects and concepts

00:05:03.500 --> 00:05:05.130
that do come with the API.

00:05:05.130 --> 00:05:07.980
There are also things
that have similar names,

00:05:07.980 --> 00:05:09.470
but function
slightly differently.

00:05:12.540 --> 00:05:15.780
So one of the amazing
features that Vulkan supports

00:05:15.780 --> 00:05:17.055
is validation layers.

00:05:17.055 --> 00:05:18.555
And if this is the
first time you've

00:05:18.555 --> 00:05:20.013
heard of validation
layers, they're

00:05:20.013 --> 00:05:22.720
essentially an API-level
debugging error-checking tool

00:05:22.720 --> 00:05:30.410
that lets you figure out
what's happening in the API.

00:05:30.410 --> 00:05:33.710
It's a very dramatic
departure from glGetError.

00:05:33.710 --> 00:05:36.167
And the general rule of
thumb for validation layers

00:05:36.167 --> 00:05:38.250
is to turn them on at the
beginning of the project

00:05:38.250 --> 00:05:39.874
and leave them on
until you've shipped.

00:05:39.874 --> 00:05:41.734
The validation layers
are cross-platform,

00:05:41.734 --> 00:05:43.650
which means the same
validation code gets used

00:05:43.650 --> 00:05:46.720
on Android, Linux, and Windows.

00:05:46.720 --> 00:05:49.590
And one of the cool
aspects of the validation

00:05:49.590 --> 00:05:51.400
is this-- it's a
function call back

00:05:51.400 --> 00:05:54.510
that you can supply to the
validation layers, that

00:05:54.510 --> 00:05:57.520
gets triggered every time the
validation message triggered.

00:05:57.520 --> 00:05:59.930
And this is what the call
signature looks like.

00:05:59.930 --> 00:06:02.560
And this is what a
sample body looks like.

00:06:02.560 --> 00:06:06.630
As you can see, you can break it
down into whatever granularity

00:06:06.630 --> 00:06:09.600
that you need, based on
the validation criteria.

00:06:09.600 --> 00:06:10.990
And if you're on
a platform where

00:06:10.990 --> 00:06:13.200
you can't set break
points in the IDE,

00:06:13.200 --> 00:06:15.704
you could definitely set a
break point at any of these.

00:06:15.704 --> 00:06:17.120
And you can look
in the call stack

00:06:17.120 --> 00:06:19.203
to see where the validation
message was triggered.

00:06:21.720 --> 00:06:24.912
All right, so let's get a
little bit deeper with Vulkan.

00:06:24.912 --> 00:06:26.620
Some friendly reminders
before we start--

00:06:26.620 --> 00:06:28.280
and these are things
that if you're

00:06:28.280 --> 00:06:31.890
beginning a port from
OpenGL ES to Vulkan,

00:06:31.890 --> 00:06:33.840
it's good to keep
these in mind, even

00:06:33.840 --> 00:06:35.700
though they seem very trivial.

00:06:35.700 --> 00:06:37.480
The first thing is the
coordinate systems.

00:06:37.480 --> 00:06:40.140
Vulkan's coordinate system
is upper-left origin.

00:06:40.140 --> 00:06:42.785
And this includes both rendering
and texture coordinates.

00:06:42.785 --> 00:06:44.160
This one caught
me off guard when

00:06:44.160 --> 00:06:45.326
I was first working with it.

00:06:45.326 --> 00:06:47.620
Everything I rendered appeared
upside down and kind of

00:06:47.620 --> 00:06:48.119
backwards.

00:06:48.119 --> 00:06:50.890
And I thought I was doing
something very wrong.

00:06:50.890 --> 00:06:54.220
And so I went and stared
somebody down and asked them,

00:06:54.220 --> 00:06:55.750
why is it upper-left?

00:06:55.750 --> 00:06:58.740
And there wasn't a clear
answer, but it just is.

00:06:58.740 --> 00:07:02.280
And memory management
basics-- in OpenGL,

00:07:02.280 --> 00:07:05.590
you didn't really have to handle
a lot of allocations yourself,

00:07:05.590 --> 00:07:06.740
if any.

00:07:06.740 --> 00:07:08.450
In Vulkan, you have
to kind of handle

00:07:08.450 --> 00:07:10.480
the majority of the
allocations yourself.

00:07:10.480 --> 00:07:14.510
Buffers and images definitely,
and pools-- command pools

00:07:14.510 --> 00:07:17.700
are kind of handled for you,
but descriptor pools are not.

00:07:17.700 --> 00:07:20.630
You still have to point out
to Vulkan what you need.

00:07:23.096 --> 00:07:23.596
All right.

00:07:23.596 --> 00:07:27.320
So the first Vulkan
topic-- command buffers.

00:07:27.320 --> 00:07:29.220
So command buffers are
one of those things

00:07:29.220 --> 00:07:31.270
in OpenGL that you
hear a lot about,

00:07:31.270 --> 00:07:33.710
but you don't really have
explicit control over.

00:07:33.710 --> 00:07:36.100
In Vulkan, that changes a lot.

00:07:36.100 --> 00:07:37.750
They are one of
the primary things

00:07:37.750 --> 00:07:40.205
that you use to get pretty
much anything done in Vulkan.

00:07:40.205 --> 00:07:43.650
And command buffers have to be
allocated before they're used.

00:07:43.650 --> 00:07:48.110
And command buffers are
allocated from command pools.

00:07:48.110 --> 00:07:51.132
The command pools themselves
must belong to a queue family.

00:07:51.132 --> 00:07:53.340
And we'll talk about queue
families in just a minute.

00:07:53.340 --> 00:07:55.320
And when you're submitting
command buffers,

00:07:55.320 --> 00:07:58.580
command buffers have to be
submitted to the same queue

00:07:58.580 --> 00:08:01.910
family as the command pool.

00:08:01.910 --> 00:08:04.037
And also, when
you're submitting,

00:08:04.037 --> 00:08:06.120
you want to minimize the
number of command buffers

00:08:06.120 --> 00:08:07.530
that you're using per frame.

00:08:07.530 --> 00:08:09.648
And when you hear this,
don't try to use just one.

00:08:09.648 --> 00:08:11.356
If you try to use just
one command buffer

00:08:11.356 --> 00:08:15.080
to do everything, you're going
to end up starving the GPU.

00:08:15.080 --> 00:08:18.966
I also know that one
through experience.

00:08:18.966 --> 00:08:21.090
It becomes quite difficult
to try to fit everything

00:08:21.090 --> 00:08:23.089
into a single command
buffer, because you end up

00:08:23.089 --> 00:08:24.840
having to do a lot
of code gymnastics.

00:08:24.840 --> 00:08:28.390
So in order to ensure
the best performance,

00:08:28.390 --> 00:08:31.530
you're going to want to use
multiple command buffers,

00:08:31.530 --> 00:08:33.505
but minimize them
as much as possible.

00:08:36.021 --> 00:08:36.520
All right.

00:08:36.520 --> 00:08:38.669
So some sharp edges
on command buffers--

00:08:38.669 --> 00:08:41.140
one of the terms that gets
tossed around with Vulkan a lot

00:08:41.140 --> 00:08:42.480
is multi-threading.

00:08:42.480 --> 00:08:45.030
And while there is
a portion of the API

00:08:45.030 --> 00:08:48.730
that is implicitly thread-safe,
there are parts of the API

00:08:48.730 --> 00:08:51.529
that are not
implicitly thread-safe.

00:08:51.529 --> 00:08:53.320
You can't record to
the same command buffer

00:08:53.320 --> 00:08:55.570
from multiple threads, but
it's perfectly fine for you

00:08:55.570 --> 00:08:58.800
to record to multiple command
buffers on multiple threads.

00:08:58.800 --> 00:09:01.830
And you can do something where
you can record multiple command

00:09:01.830 --> 00:09:04.410
buffers on multiple threads
and then take all those command

00:09:04.410 --> 00:09:06.764
buffers and kick them over
to a single submission thread

00:09:06.764 --> 00:09:08.680
and submit all the command
buffers from there.

00:09:08.680 --> 00:09:10.360
That's perfectly fine.

00:09:10.360 --> 00:09:11.869
But if you're going
to do recording

00:09:11.869 --> 00:09:14.410
from multiple threads, make sure
that each one of the threads

00:09:14.410 --> 00:09:16.180
has access to its
own command pool.

00:09:19.230 --> 00:09:22.489
And directly related to
command buffers is queues.

00:09:22.489 --> 00:09:24.030
Queues is, again,
one of those things

00:09:24.030 --> 00:09:25.710
that you hear a lot
about in OpenGL,

00:09:25.710 --> 00:09:29.640
but you don't quite
have control of.

00:09:29.640 --> 00:09:31.654
In Vulkan, again,
it's very different.

00:09:31.654 --> 00:09:34.070
And it's important to understand
queues from, pretty much,

00:09:34.070 --> 00:09:36.220
their moment of creation.

00:09:36.220 --> 00:09:38.050
And queues,
implicitly, they have

00:09:38.050 --> 00:09:40.170
to belong to a queue family.

00:09:40.170 --> 00:09:42.740
And you know which queue
family they belong to

00:09:42.740 --> 00:09:44.860
through the queue family index.

00:09:44.860 --> 00:09:47.449
And there are a limited
number of queues.

00:09:47.449 --> 00:09:49.990
And you can find out how many
queues a queue family supports,

00:09:49.990 --> 00:09:54.310
by looking at a vkQueueFamiyProp
erties:queueCount.

00:09:54.310 --> 00:09:56.290
And we'll get to
the queue family

00:09:56.290 --> 00:09:57.470
properties in just a second.

00:09:57.470 --> 00:09:59.970
But if you find yourself
in a configuration

00:09:59.970 --> 00:10:02.110
where you want to do both
graphics and compute,

00:10:02.110 --> 00:10:04.880
you want to prefer the combined
queues over queues that

00:10:04.880 --> 00:10:06.880
support singular operations.

00:10:06.880 --> 00:10:10.160
So if you're looking to
do graphics and compute,

00:10:10.160 --> 00:10:12.280
look for a queue family
that supports both.

00:10:12.280 --> 00:10:14.160
And the primary reason
you want to do this

00:10:14.160 --> 00:10:17.720
is, at the initial
point of your port,

00:10:17.720 --> 00:10:19.861
it just makes things
easier to coordinate.

00:10:19.861 --> 00:10:21.610
Because if you start
using multiple queues

00:10:21.610 --> 00:10:24.179
from multiple queues, you will
have to do synchronization,

00:10:24.179 --> 00:10:25.970
and that can be a little
bit of a headache.

00:10:29.400 --> 00:10:31.530
When you're working
with queues, it's

00:10:31.530 --> 00:10:36.122
important that, if you need
to order the queue operations,

00:10:36.122 --> 00:10:37.830
do it through
synchronization primitives,

00:10:37.830 --> 00:10:43.090
and avoid using vkQueueWaitIdle
in performance critical code.

00:10:43.090 --> 00:10:45.960
There are times when there
are legitimate cases to use

00:10:45.960 --> 00:10:49.790
vkQueueWaitIdle, but a
lot of times there isn't.

00:10:49.790 --> 00:10:51.970
And through personal
experience, it's

00:10:51.970 --> 00:10:54.510
caused a lot of weird
bubbles in the pipeline

00:10:54.510 --> 00:10:57.125
and stalls that I didn't expect.

00:11:00.540 --> 00:11:03.150
And some sharp edges in
queues-- so not all queues

00:11:03.150 --> 00:11:03.940
are universal.

00:11:03.940 --> 00:11:06.670
The queue family dictates
what functionality each queue

00:11:06.670 --> 00:11:08.020
supports.

00:11:08.020 --> 00:11:09.640
And Android-specific
notes on queue

00:11:09.640 --> 00:11:12.550
is that, on Android, there is
at least one queue that supports

00:11:12.550 --> 00:11:14.610
both graphics and compute.

00:11:14.610 --> 00:11:17.277
And you can present from
any queue on Android.

00:11:17.277 --> 00:11:18.860
On the desktop, you
kind of have to go

00:11:18.860 --> 00:11:21.151
looking around to see which
queue supports presentation

00:11:21.151 --> 00:11:22.540
or not.

00:11:22.540 --> 00:11:26.290
And this almost goes without
saying, but it's worth saying.

00:11:26.290 --> 00:11:31.950
You've got to keep kind of
precise counts on the queues.

00:11:31.950 --> 00:11:34.430
There are devices that
only support one queue.

00:11:34.430 --> 00:11:35.950
So if a device
supports one queue,

00:11:35.950 --> 00:11:37.749
it implicitly only
has one queue family.

00:11:37.749 --> 00:11:39.290
So you want to check
these properties

00:11:39.290 --> 00:11:40.490
before you start
creating queues,

00:11:40.490 --> 00:11:42.425
because if you try to create
more than one queue on a device

00:11:42.425 --> 00:11:44.367
that only supports
one queue, you'll

00:11:44.367 --> 00:11:45.575
either get a hang or a crash.

00:11:48.941 --> 00:11:49.440
All right.

00:11:49.440 --> 00:11:51.210
Pipelines or pipeline
state objects,

00:11:51.210 --> 00:11:55.090
as some people like to
call them-- essentially,

00:11:55.090 --> 00:11:58.020
these are data structures
that have properties

00:11:58.020 --> 00:12:00.640
that control pretty much
everything that happens

00:12:00.640 --> 00:12:02.260
in the rendering process.

00:12:02.260 --> 00:12:06.160
And they're fixed functioned.

00:12:06.160 --> 00:12:08.485
So that means that,
once you compile them,

00:12:08.485 --> 00:12:10.710
you can't really change
any of their properties.

00:12:10.710 --> 00:12:12.820
There's a caveat to that,
since there are what

00:12:12.820 --> 00:12:14.430
are called dynamic properties.

00:12:14.430 --> 00:12:16.520
And the dynamic properties
can be readjusted

00:12:16.520 --> 00:12:21.420
or can be adjusted via
command buffer operations.

00:12:21.420 --> 00:12:25.080
And these include things like
viewports, scissors, or blend

00:12:25.080 --> 00:12:27.210
constants.

00:12:27.210 --> 00:12:28.990
How many pipelines can you have?

00:12:28.990 --> 00:12:31.820
If you find yourself having
hundreds or thousands

00:12:31.820 --> 00:12:34.110
of pipelines, that's
actually perfectly fine.

00:12:34.110 --> 00:12:37.030
A typical application
may have that many.

00:12:37.030 --> 00:12:39.370
And the reason, if you
think about it for a moment,

00:12:39.370 --> 00:12:40.920
the different
combinations of what

00:12:40.920 --> 00:12:43.710
you have in your
rendering states

00:12:43.710 --> 00:12:47.220
can easily create
hundreds of permutations.

00:12:47.220 --> 00:12:50.720
But if you're getting to the
point where it's over 10,000,

00:12:50.720 --> 00:12:54.450
you might want to
figure out if you're

00:12:54.450 --> 00:12:57.300
having too many
variations or too much

00:12:57.300 --> 00:13:00.100
granularity in your variations.

00:13:00.100 --> 00:13:01.940
You can also cache pipelines.

00:13:01.940 --> 00:13:03.601
And the caching
achieves two things.

00:13:03.601 --> 00:13:05.100
If you cache it at
the driver level,

00:13:05.100 --> 00:13:09.870
it helps speed up the
pipeline creation.

00:13:09.870 --> 00:13:13.460
You can also use a
selection mechanism,

00:13:13.460 --> 00:13:17.060
to where you can use
a premade pipeline.

00:13:17.060 --> 00:13:21.020
And you can do this by looking
at your pipeline properties

00:13:21.020 --> 00:13:23.925
and using a hashing function
to select the pipeline.

00:13:23.925 --> 00:13:24.425
Excuse me.

00:13:34.800 --> 00:13:37.230
All right, so descriptor
sets-- and descriptor sets

00:13:37.230 --> 00:13:38.980
are one of my favorite
areas in Vulkan,

00:13:38.980 --> 00:13:41.100
not because I have a
fond affection for them,

00:13:41.100 --> 00:13:44.310
but I had to spend so
much time with them.

00:13:44.310 --> 00:13:49.690
Descriptor sets are basically
how the C++ side gives you

00:13:49.690 --> 00:13:53.200
a perspective into the resource
that the shader will need.

00:13:53.200 --> 00:13:56.800
And there's a few things
that may catch you

00:13:56.800 --> 00:13:58.600
off guard about
descriptor sets, and we'll

00:13:58.600 --> 00:14:00.240
go over these things right now.

00:14:00.240 --> 00:14:01.940
The descriptors are
binding numbers.

00:14:01.940 --> 00:14:04.040
So you can sparsely
populate binding numbers

00:14:04.040 --> 00:14:07.140
on the descriptor sets,
but keep the gap small,

00:14:07.140 --> 00:14:12.340
because unused binding
numbers still take up memory.

00:14:12.340 --> 00:14:14.660
There also is a
max binding number.

00:14:14.660 --> 00:14:17.720
It's not obvious, but
if you try to assign

00:14:17.720 --> 00:14:20.670
a binding number
of, like, 32,000,

00:14:20.670 --> 00:14:22.980
most GPUs won't support it.

00:14:22.980 --> 00:14:24.480
And the validation
will call it out,

00:14:24.480 --> 00:14:28.520
and they'll tell you that
your binding number's too big.

00:14:28.520 --> 00:14:32.000
There's also a limit on
how many descriptor sets

00:14:32.000 --> 00:14:34.470
you can have bound at one time.

00:14:34.470 --> 00:14:39.150
And this gets reported to you
by maxBoundDescriptorSets.

00:14:39.150 --> 00:14:41.370
And right now, if you try
to bind more descriptor

00:14:41.370 --> 00:14:45.460
sets than your device supports,
you'll just get a crash.

00:14:45.460 --> 00:14:48.164
And the thing with
descriptor sets

00:14:48.164 --> 00:14:50.580
is that you will need to update
them once they've created,

00:14:50.580 --> 00:14:54.820
so the shader will know what
resources you're looking at.

00:14:54.820 --> 00:14:56.300
So the general
wisdom behind this

00:14:56.300 --> 00:14:58.008
is that you want to
group descriptor sets

00:14:58.008 --> 00:14:59.640
by update frequency.

00:14:59.640 --> 00:15:02.455
And you only should
update descriptors sets

00:15:02.455 --> 00:15:03.740
that have changed.

00:15:03.740 --> 00:15:06.045
Updating a descriptor
set is fairly expensive.

00:15:08.412 --> 00:15:10.120
All right, some sharp
edges on descriptor

00:15:10.120 --> 00:15:12.650
sets-- once you bind
the descriptor sets,

00:15:12.650 --> 00:15:15.734
you can't do any updates to
it, until the next iteration

00:15:15.734 --> 00:15:16.650
in the command buffer.

00:15:16.650 --> 00:15:20.290
And then you should do
that before binding.

00:15:20.290 --> 00:15:22.900
So here's the one
really confusing thing

00:15:22.900 --> 00:15:27.360
that caught me off guard
with binding descriptor sets.

00:15:27.360 --> 00:15:31.560
This function,
vkCmdBindDescriptorSets,

00:15:31.560 --> 00:15:34.410
there's a parameter on
there called firstSet.

00:15:34.410 --> 00:15:37.790
And it wasn't obvious from
the spec what this meant.

00:15:37.790 --> 00:15:41.810
And so I thought it meant the
index onto the pDescriptorSets,

00:15:41.810 --> 00:15:43.859
which is another parameter.

00:15:43.859 --> 00:15:45.400
And to give you a
better perspective,

00:15:45.400 --> 00:15:46.810
this is what it looks like.

00:15:46.810 --> 00:15:50.380
So at the bottom, you see
the function signature.

00:15:50.380 --> 00:15:54.530
So this parameter actually
refers to this field

00:15:54.530 --> 00:15:55.970
in your pipeline layout.

00:15:55.970 --> 00:15:59.030
And it's a little confusing,
because there's nothing

00:15:59.030 --> 00:16:00.730
that helps you figure this out.

00:16:00.730 --> 00:16:02.610
Somebody had to
point this out to me.

00:16:02.610 --> 00:16:05.760
Essentially, what this does is
it aligns the descriptor set

00:16:05.760 --> 00:16:06.920
layout that you told the
pipeline that you're going

00:16:06.920 --> 00:16:08.600
to use with the
ones you're passing

00:16:08.600 --> 00:16:10.940
into the BindDescriptorSets.

00:16:10.940 --> 00:16:14.654
So if you're running into a
place where you're binding,

00:16:14.654 --> 00:16:16.570
and you're getting a
crash, or you're binding,

00:16:16.570 --> 00:16:18.650
and you're getting a
fairly unexpected behavior,

00:16:18.650 --> 00:16:23.010
just make sure that these
two parameters align.

00:16:23.010 --> 00:16:26.250
All right, frame buffers--
so frame buffers in Vulkan

00:16:26.250 --> 00:16:28.924
are slightly different
than they are in OpenGL ES.

00:16:28.924 --> 00:16:30.590
You can think of frame
buffers in Vulkan

00:16:30.590 --> 00:16:33.310
as basically loosely
attachment pools.

00:16:33.310 --> 00:16:35.770
Essentially, they hold
an array of VkImageViews.

00:16:39.990 --> 00:16:43.194
The relationship between
framebuffers and render passes

00:16:43.194 --> 00:16:44.770
is fairly strict.

00:16:44.770 --> 00:16:46.600
The subpasses and
render passes refer

00:16:46.600 --> 00:16:48.700
to attachments by integer index.

00:16:48.700 --> 00:16:51.550
There's no ordering
requirements.

00:16:51.550 --> 00:16:54.930
And the attachments
in framebuffers

00:16:54.930 --> 00:16:57.732
must have the same
width and height.

00:16:57.732 --> 00:16:59.190
In the general
case, you still have

00:16:59.190 --> 00:17:01.610
to resolve any multi-sample
attachments to single sample

00:17:01.610 --> 00:17:06.690
before you use them in textures,
not much different from ES.

00:17:06.690 --> 00:17:10.150
So render passes-- as mentioned
before, subpasses inside

00:17:10.150 --> 00:17:13.530
of render passes refer to
framebuffers attachments

00:17:13.530 --> 00:17:15.650
via integer index.

00:17:15.650 --> 00:17:21.300
Subpass dependencies-- so when
you start working with Vulkan,

00:17:21.300 --> 00:17:24.089
you'll see a data structure
called subpass dependencies.

00:17:24.089 --> 00:17:26.030
And from a high-level
perspective,

00:17:26.030 --> 00:17:28.270
what this data structure
does is that it

00:17:28.270 --> 00:17:32.180
builds a dependency graph that
you pass into Vulkan to tell

00:17:32.180 --> 00:17:33.840
Vulkan the order
in which you want

00:17:33.840 --> 00:17:35.720
the subpasses to be processed.

00:17:35.720 --> 00:17:40.350
If you don't do this, some
GPUs will process the subpasses

00:17:40.350 --> 00:17:41.197
as they see fit.

00:17:41.197 --> 00:17:42.780
And this may not be
the order that you

00:17:42.780 --> 00:17:46.200
want them to be processed in.

00:17:46.200 --> 00:17:49.900
So make sure that, when
you're working with subpasses,

00:17:49.900 --> 00:17:52.037
be really clear and
explicit about which order

00:17:52.037 --> 00:17:53.620
you want subpasses
to be processed in,

00:17:53.620 --> 00:17:59.520
if you're going to use the
results of an earlier subpass

00:17:59.520 --> 00:18:01.830
in the next subpass.

00:18:01.830 --> 00:18:06.020
And additionally,
on subpasses, let's

00:18:06.020 --> 00:18:07.630
say you're on subpass
three, and you

00:18:07.630 --> 00:18:09.590
want to use something
from subpass zero,

00:18:09.590 --> 00:18:11.290
you need to preserve
that attachment.

00:18:11.290 --> 00:18:13.581
If you don't preserve the
attachments, what will happen

00:18:13.581 --> 00:18:16.180
is it will get destroyed
when the subpass completes.

00:18:16.180 --> 00:18:19.570
And further on the
subpasses, if you

00:18:19.570 --> 00:18:22.202
have subpasses that have
a multi-sample output,

00:18:22.202 --> 00:18:24.160
and you want them to get
automatically resolved

00:18:24.160 --> 00:18:30.117
to single sample, you can pass
in images into the subpass data

00:18:30.117 --> 00:18:32.450
structure that does this, and
they'll get resolved right

00:18:32.450 --> 00:18:33.620
as the subpass ends.

00:18:36.370 --> 00:18:38.172
So here's a diagram
that describes

00:18:38.172 --> 00:18:40.130
the relationship between
subpasses, and render,

00:18:40.130 --> 00:18:41.189
and framebuffers.

00:18:41.189 --> 00:18:42.980
You can see, on the
right, the framebuffers

00:18:42.980 --> 00:18:44.330
are basically just a list.

00:18:44.330 --> 00:18:47.930
And the render pass is
composed of multiple subpasses.

00:18:47.930 --> 00:18:50.566
And there's actually no need
for you to share one depth pass.

00:18:50.566 --> 00:18:51.940
You can have as
many depth passes

00:18:51.940 --> 00:18:54.314
as you want, assuming that
it's within the device limits.

00:18:57.250 --> 00:18:57.770
All right.

00:19:00.360 --> 00:19:02.950
So the next two topics-- image
layouts and pipeline barriers--

00:19:02.950 --> 00:19:05.200
I wish there was more time
to get in depth with these.

00:19:05.200 --> 00:19:09.350
They're actually pretty
complicated topics.

00:19:09.350 --> 00:19:12.200
So I will try to go over
them as best as I can.

00:19:12.200 --> 00:19:15.909
The behavior of image layouts
is they vary depending on GPU.

00:19:15.909 --> 00:19:17.950
Something GPUs require
very specific image layout

00:19:17.950 --> 00:19:19.780
transitions, others won't.

00:19:19.780 --> 00:19:22.760
The one thing you should know is
that all Vulkan implementations

00:19:22.760 --> 00:19:24.990
will accept
VK_IMAGE_LAYOUT_GENERAL

00:19:24.990 --> 00:19:26.670
for, pretty much,
all operations.

00:19:26.670 --> 00:19:29.140
You will take a performance
hit if you do that, though.

00:19:29.140 --> 00:19:31.435
So if you want to
ensure best performance,

00:19:31.435 --> 00:19:34.310
it's best to assume that all
GPUs require specific image

00:19:34.310 --> 00:19:35.060
layouts.

00:19:35.060 --> 00:19:39.090
And set your code to
handle it in that way.

00:19:39.090 --> 00:19:40.500
Transitions between
image layouts

00:19:40.500 --> 00:19:43.050
are both implicit and explicit.

00:19:43.050 --> 00:19:46.070
The image layouts can be
transitioned explicitly

00:19:46.070 --> 00:19:47.970
using pipeline barriers.

00:19:47.970 --> 00:19:51.060
And image layouts, they can
also be transitioned implicitly

00:19:51.060 --> 00:19:52.025
by render passes.

00:19:54.920 --> 00:19:59.690
And how that happens is there's
a field inside the subpasses

00:19:59.690 --> 00:20:05.107
that asks you, what do you want
this to be once you're done?

00:20:05.107 --> 00:20:06.690
You can also use the
validation layers

00:20:06.690 --> 00:20:11.010
to correct any image layout
errors that you may have.

00:20:11.010 --> 00:20:13.840
The validation layers are
very fond of screaming at you

00:20:13.840 --> 00:20:15.720
every time there's an
image layout error,

00:20:15.720 --> 00:20:19.760
so it's a good tool
to have around.

00:20:19.760 --> 00:20:22.660
All right, pipeline
barriers-- if you use OpenGL,

00:20:22.660 --> 00:20:24.810
they can be a little bit terse.

00:20:24.810 --> 00:20:27.130
There's two things I feel
like you should know.

00:20:27.130 --> 00:20:29.850
The first one is that,
while they do look complex,

00:20:29.850 --> 00:20:32.980
they become kind of second
nature with some practice.

00:20:32.980 --> 00:20:40.110
The other thing is there's
a restriction on pipeline

00:20:40.110 --> 00:20:41.430
barriers within render passes.

00:20:41.430 --> 00:20:46.020
And if you need to
issue a pipeline barrier

00:20:46.020 --> 00:20:48.180
within a render
pass, the subpass

00:20:48.180 --> 00:20:50.830
that you're going to issue
the pipeline barrier in

00:20:50.830 --> 00:20:53.500
needs to have a
dependency within itself.

00:20:53.500 --> 00:20:55.400
And you do that just
by telling the subpass

00:20:55.400 --> 00:20:59.582
the dependency to the integer
index of that subpass.

00:20:59.582 --> 00:21:01.540
And there's only two
types of pipeline barriers

00:21:01.540 --> 00:21:03.206
that you can issue
within a render pass,

00:21:03.206 --> 00:21:05.970
and that's VkMemoryBarrier
and VkImageMemoryBarrier.

00:21:09.700 --> 00:21:10.200
All right.

00:21:10.200 --> 00:21:12.610
So a little bit more advanced
on the memory management--

00:21:12.610 --> 00:21:17.150
since you're directly
responsible for the allocation

00:21:17.150 --> 00:21:20.787
in usage memory, just
like regular old C,

00:21:20.787 --> 00:21:22.120
you need to do balance checking.

00:21:22.120 --> 00:21:24.536
Make sure all your writes and
buffers are balance checked.

00:21:24.536 --> 00:21:26.587
If you write out of
bounds, some drivers

00:21:26.587 --> 00:21:27.920
will let you get away with that.

00:21:27.920 --> 00:21:31.090
And what it does is it creates
these incredibly difficult

00:21:31.090 --> 00:21:32.500
to track down bugs.

00:21:32.500 --> 00:21:33.880
They could create red herrings.

00:21:33.880 --> 00:21:36.412
It can create a situation
where you overwrite something

00:21:36.412 --> 00:21:38.120
inside the vertex
buffer, but it actually

00:21:38.120 --> 00:21:41.080
crashes when you try to do
something with uniform buffer.

00:21:41.080 --> 00:21:45.500
So build some code around
error checking to make sure

00:21:45.500 --> 00:21:48.340
that all your writes
are in bounds.

00:21:48.340 --> 00:21:52.800
And flushing is something
that's making it's way back.

00:21:52.800 --> 00:21:57.040
After you do any host
writes, make sure to flush.

00:21:57.040 --> 00:22:00.930
If you have command buffer
operations that do a read,

00:22:00.930 --> 00:22:03.130
all the things that
that read depends on

00:22:03.130 --> 00:22:06.090
must be flushed before that
read operation takes place.

00:22:06.090 --> 00:22:08.009
There is a slight
caveat to the flushing.

00:22:08.009 --> 00:22:10.342
If you allocated memory with
the VK MEMORY PROPERTY HOST

00:22:10.342 --> 00:22:13.180
COHERENT, you don't
need to flush.

00:22:15.990 --> 00:22:19.420
All right, shaders-- so
SPIR-V is the official shading

00:22:19.420 --> 00:22:20.720
language of Vulkan.

00:22:20.720 --> 00:22:23.300
And it is a lower
level language,

00:22:23.300 --> 00:22:26.700
so we're still using
GLSL for awhile.

00:22:26.700 --> 00:22:30.300
It must be compiled either
online or offline to SPIR-V,

00:22:30.300 --> 00:22:32.870
using either shaderc or glslang.

00:22:32.870 --> 00:22:36.280
The same shader code can be
used on both desktop and mobile.

00:22:36.280 --> 00:22:39.919
There is a big
change to uniforms.

00:22:39.919 --> 00:22:41.710
Obviously, you have to
use uniform buffers,

00:22:41.710 --> 00:22:45.720
but you can't have
standalone uniforms anymore.

00:22:45.720 --> 00:22:51.920
Uniforms have to be
within interface blocks.

00:22:51.920 --> 00:22:53.670
And the layout of
these interface blocks

00:22:53.670 --> 00:22:56.610
are governed by
the std140 rules.

00:22:56.610 --> 00:22:59.480
And if you've ever worked with
std140, it can be a little bit

00:22:59.480 --> 00:23:00.740
complicated.

00:23:00.740 --> 00:23:06.070
In Cinder, we use SPIR to
extract the offsets and size

00:23:06.070 --> 00:23:09.712
information from
the SPIR-V directly.

00:23:09.712 --> 00:23:12.170
And if that's something that
interests you, come talk to me

00:23:12.170 --> 00:23:14.430
afterwards, because it
saves us a lot of headache.

00:23:14.430 --> 00:23:16.920
The other thing is
that whoever is working

00:23:16.920 --> 00:23:20.710
on your team on bindings,
or between the shaders

00:23:20.710 --> 00:23:25.040
and descriptor sets, spend
some time understanding

00:23:25.040 --> 00:23:26.945
how they relate
with the descriptor

00:23:26.945 --> 00:23:27.820
sets and the shaders.

00:23:31.282 --> 00:23:32.990
There's obviously a
natural relationship,

00:23:32.990 --> 00:23:35.830
but it's really easy
to make an error in one

00:23:35.830 --> 00:23:38.770
and kind of ignore that it may
create an error in the other,

00:23:38.770 --> 00:23:40.686
because you do have to
keep them synchronized.

00:23:43.180 --> 00:23:48.260
All right, so performance
considerations-- so these

00:23:48.260 --> 00:23:51.360
are self-evident things
that we, hopefully,

00:23:51.360 --> 00:23:53.250
all hold to be true
when we're talking

00:23:53.250 --> 00:23:56.070
about performance in graphics.

00:23:56.070 --> 00:23:58.080
Obviously, minimize
host to GPU transfers,

00:23:58.080 --> 00:23:59.830
especially on mobile,
because that ends up

00:23:59.830 --> 00:24:02.160
taking a lot of power.

00:24:02.160 --> 00:24:05.010
Reduce round trips on any reads.

00:24:05.010 --> 00:24:07.650
That includes if you're
using depressed textures

00:24:07.650 --> 00:24:08.960
to speed things up.

00:24:08.960 --> 00:24:12.980
And in Vulkan, very specifically
try not to starve the GPU,

00:24:12.980 --> 00:24:15.110
because, when you
starve the GPU,

00:24:15.110 --> 00:24:18.290
the next round of you
pushing data to the GPU

00:24:18.290 --> 00:24:19.820
can easily over-saturate it.

00:24:22.475 --> 00:24:23.850
And with respect
to render loops,

00:24:23.850 --> 00:24:26.400
the best thing for you to do
is to keep multiple frames

00:24:26.400 --> 00:24:28.010
in flight with Vulkan.

00:24:28.010 --> 00:24:31.060
I find this, in Vulkan, to
actually be a lot easier

00:24:31.060 --> 00:24:33.050
to do than OpenGL.

00:24:33.050 --> 00:24:35.167
In OpenGL, at
times, I felt like I

00:24:35.167 --> 00:24:36.750
was at the mercy of
the driver of what

00:24:36.750 --> 00:24:39.950
I was doing when I was trying to
keep multiple frames in flight.

00:24:39.950 --> 00:24:42.710
With Vulkan, you
can very explicitly

00:24:42.710 --> 00:24:45.800
do this, because of
the nature of Vulkan.

00:24:45.800 --> 00:24:47.839
So if you have more than
one frame in flight--

00:24:47.839 --> 00:24:49.380
say you have two--
then you obviously

00:24:49.380 --> 00:24:51.546
have to double buffer all
your non-static resources.

00:24:51.546 --> 00:24:53.660
If you have three, then
you need to triple buffer

00:24:53.660 --> 00:24:56.460
your non-static resources,
and so on, and so forth.

00:24:56.460 --> 00:24:58.910
And this also includes things
like your command buffer.

00:24:58.910 --> 00:25:00.390
And the command buffers
are a good starting point,

00:25:00.390 --> 00:25:02.223
if you need to figure
out what resources are

00:25:02.223 --> 00:25:04.337
backing that particular frame.

00:25:04.337 --> 00:25:06.170
So you can start building
a dependency graph

00:25:06.170 --> 00:25:10.189
from the command buffer back
to the resource that you need.

00:25:10.189 --> 00:25:12.230
And so, since you have
multiple frames in flight,

00:25:12.230 --> 00:25:13.896
you'll probably need
to handle the frame

00:25:13.896 --> 00:25:16.420
rate throttling yourself.

00:25:16.420 --> 00:25:18.180
This takes a little
bit of work, and it

00:25:18.180 --> 00:25:22.040
requires both using the Vulkan
sync primitives plus some CPU

00:25:22.040 --> 00:25:23.130
side logic.

00:25:23.130 --> 00:25:25.170
And this is definitely
an area where you do not

00:25:25.170 --> 00:25:26.336
want to use vkQueueWaitIdle.

00:25:28.520 --> 00:25:29.020
I'm sorry.

00:25:29.020 --> 00:25:32.970
Some of the Vulkan function
names are really hard to say.

00:25:32.970 --> 00:25:35.471
And I know I'm screwing them
up, because they're a mouthful,

00:25:35.471 --> 00:25:36.470
and they're really long.

00:25:36.470 --> 00:25:37.530
So I apologize for that.

00:25:40.213 --> 00:25:40.713
All right.

00:25:40.713 --> 00:25:43.880
So here's something that
didn't exist in OpenGL,

00:25:43.880 --> 00:25:47.167
but I think it may be coming to
OpenGL soon, is push constants.

00:25:47.167 --> 00:25:49.250
So if you're looking to
do something really quick,

00:25:49.250 --> 00:25:50.170
and there's not a
whole lot of data

00:25:50.170 --> 00:25:52.910
that you need to pass between
your code and the shader code,

00:25:52.910 --> 00:25:54.840
you can use push constants.

00:25:54.840 --> 00:25:57.450
And push constants, they
don't require any buffers.

00:25:57.450 --> 00:25:59.350
They don't require
any descriptor setups.

00:25:59.350 --> 00:26:01.105
You can only push
128 bytes at a time.

00:26:03.750 --> 00:26:06.115
And the limitation on
them is that you can only

00:26:06.115 --> 00:26:09.790
have one push constant for
all shader stages, per shader.

00:26:09.790 --> 00:26:11.780
In 128 bytes, you can
fit at about two 4

00:26:11.780 --> 00:26:12.835
x 4 matrices in there.

00:26:12.835 --> 00:26:14.710
So you kind of have to
be a little bit clever

00:26:14.710 --> 00:26:16.720
in how you use them.

00:26:16.720 --> 00:26:18.725
And this sharp edge--
the size and the offsets

00:26:18.725 --> 00:26:19.725
must be a multiple of 4.

00:26:19.725 --> 00:26:21.230
It's not really a sharp edge.

00:26:21.230 --> 00:26:24.870
4 is the default machine size
for, pretty much, any GPU.

00:26:24.870 --> 00:26:28.870
So if your size and
offset is not 4,

00:26:28.870 --> 00:26:32.550
something went wrong
somewhere else, horribly.

00:26:32.550 --> 00:26:36.259
But they are really
quick and fast.

00:26:36.259 --> 00:26:38.300
And Cinder does have a
sample of how to use this.

00:26:41.240 --> 00:26:42.630
And here's what they look like.

00:26:42.630 --> 00:26:45.260
It just looks like
a uniform block,

00:26:45.260 --> 00:26:48.330
except where the layout
is, it has push constants.

00:26:48.330 --> 00:26:48.830
Excuse me.

00:26:59.050 --> 00:27:04.640
All right, so most projects
will probably start on desktop

00:27:04.640 --> 00:27:07.690
and go to mobile.

00:27:07.690 --> 00:27:11.670
If you're not doing that, then
you're really highly skilled.

00:27:11.670 --> 00:27:14.730
But for the rest
of us, pretty much,

00:27:14.730 --> 00:27:18.060
everything starts on desktop
and then migrates to mobile.

00:27:18.060 --> 00:27:22.020
So Vulkan-- the API actually
is crazy consistent.

00:27:22.020 --> 00:27:25.220
Cinder took three hours to port
from the desktop to mobile.

00:27:25.220 --> 00:27:27.330
And the only thing
that required changing

00:27:27.330 --> 00:27:30.730
was basically the WSI, or
Windows Systems Integration,

00:27:30.730 --> 00:27:32.550
and the swapchain.

00:27:32.550 --> 00:27:34.119
And it pretty much ran.

00:27:34.119 --> 00:27:35.660
So I'm not saying
that your code will

00:27:35.660 --> 00:27:37.670
take that short amount
of time to port,

00:27:37.670 --> 00:27:40.650
but you can trust that
the API's consistent.

00:27:40.650 --> 00:27:44.820
The only other area that's
different is the extensions.

00:27:44.820 --> 00:27:46.070
So that's for the API.

00:27:46.070 --> 00:27:48.290
Now, the properties
are a different story.

00:27:48.290 --> 00:27:49.960
So the properties
for the features

00:27:49.960 --> 00:27:52.660
are very different
from GPU to GPU.

00:27:52.660 --> 00:27:56.480
And those include things like
what image formats or buffer

00:27:56.480 --> 00:28:00.720
formats are host visible, and
what depth/stencil formats are

00:28:00.720 --> 00:28:01.660
supported.

00:28:01.660 --> 00:28:05.130
So don't assume that
the two devices that

00:28:05.130 --> 00:28:08.780
may be similar in capabilities
at their Vulkan completions

00:28:08.780 --> 00:28:10.000
are equal.

00:28:10.000 --> 00:28:11.840
I made that
assumption, and I found

00:28:11.840 --> 00:28:13.680
that to be completely not true.

00:28:13.680 --> 00:28:19.190
So if you must,
write a little tool

00:28:19.190 --> 00:28:21.670
that queries the
properties of the devices,

00:28:21.670 --> 00:28:23.450
so it solidifies
in your head what

00:28:23.450 --> 00:28:26.140
the devices are capable of.

00:28:26.140 --> 00:28:28.220
There's not a whole lot
of Vulcan implementations

00:28:28.220 --> 00:28:30.730
right now, so you can
keep track of it that way.

00:28:30.730 --> 00:28:32.102
But it really helps.

00:28:32.102 --> 00:28:33.560
The other thing
when you're porting

00:28:33.560 --> 00:28:36.080
is have a strategy to
find the best properties

00:28:36.080 --> 00:28:37.927
for that particular device.

00:28:37.927 --> 00:28:40.510
An example of this in Cinder is
that we have a function called

00:28:40.510 --> 00:28:43.070
vk::findBestDepthStencilFormat.

00:28:43.070 --> 00:28:45.710
And the reasoning for that is
that, on some of the devices,

00:28:45.710 --> 00:28:49.590
the best one was 32-bit
float, while others,

00:28:49.590 --> 00:28:53.220
only 16 and 24-bit
integers were supported.

00:28:53.220 --> 00:28:55.220
Or at minimum, you
can use properties

00:28:55.220 --> 00:28:57.090
that are known to work
across all devices.

00:28:59.775 --> 00:29:00.509
All right.

00:29:00.509 --> 00:29:02.300
The other thing that
you should be aware of

00:29:02.300 --> 00:29:06.420
is 3 channel format
support is very limited.

00:29:06.420 --> 00:29:09.790
And this includes both
image and buffer formats.

00:29:09.790 --> 00:29:12.150
So again, develop a
tool that generates

00:29:12.150 --> 00:29:14.680
a device support
on which formats

00:29:14.680 --> 00:29:17.310
are supported for the devices.

00:29:17.310 --> 00:29:21.360
And if you are relying on any
data packing on your vertex

00:29:21.360 --> 00:29:24.520
or images, and you're using
3 channel formats right now,

00:29:24.520 --> 00:29:29.420
you may have to change the
format that you're using, which

00:29:29.420 --> 00:29:31.490
leads me to the next point.

00:29:31.490 --> 00:29:35.920
If you're also staging transfers
between your source, your host

00:29:35.920 --> 00:29:38.960
data, and your GPU
data, you may have

00:29:38.960 --> 00:29:41.870
to transform the
data in the staging.

00:29:41.870 --> 00:29:45.280
An example of this is-- let's
say your host format is RGB.

00:29:45.280 --> 00:29:53.990
On some devices, RGB-8
isn't a visible host format.

00:29:53.990 --> 00:29:56.390
So you may have to
transform that to RGBA,

00:29:56.390 --> 00:30:01.500
copy it to the Vulkan
memory as RGBA,

00:30:01.500 --> 00:30:04.356
and then do the conversion
inside of Vulkan.

00:30:04.356 --> 00:30:05.730
The other way to
work around this

00:30:05.730 --> 00:30:07.700
is to do a direct
copy from buffer

00:30:07.700 --> 00:30:09.765
to image, using
vkCmdCopyBufferToImage.

00:30:13.112 --> 00:30:14.195
There is a caveat to that.

00:30:14.195 --> 00:30:14.960
I'll get to it in just a second.

00:30:14.960 --> 00:30:17.240
But this essentially
does a bit for bit copy

00:30:17.240 --> 00:30:19.730
from the buffer to the image.

00:30:19.730 --> 00:30:22.900
So you can basically just read
your image into the buffer

00:30:22.900 --> 00:30:25.580
and then dump it into
the image itself.

00:30:25.580 --> 00:30:28.116
The depth stencil
copies are very

00:30:28.116 --> 00:30:29.240
specific in their behavior.

00:30:29.240 --> 00:30:34.930
And there's a good portion of
the spec that talks about that.

00:30:34.930 --> 00:30:38.150
Compressed textures-- so
you should know-- I mean,

00:30:38.150 --> 00:30:40.280
we kind of want to
know, mostly these days,

00:30:40.280 --> 00:30:42.550
what formats are supported.

00:30:42.550 --> 00:30:44.377
The thing not to
do is don't assume

00:30:44.377 --> 00:30:46.460
that if it's supported in
OpenGL ES for the device

00:30:46.460 --> 00:30:47.710
that it's supported in Vulkan.

00:30:47.710 --> 00:30:48.969
It may not be.

00:30:48.969 --> 00:30:50.760
One nice thing about
Android in this regard

00:30:50.760 --> 00:30:54.570
is that all Android
Vulkan implementations

00:30:54.570 --> 00:30:59.670
will support ETC2, and some of
them will support ATSC as well.

00:30:59.670 --> 00:31:02.110
And just for completion,
the desktop support

00:31:02.110 --> 00:31:04.220
is essentially just
the BC formats.

00:31:04.220 --> 00:31:06.550
They may have slightly
more complicated names.

00:31:10.097 --> 00:31:11.180
Excuse me, for one second.

00:31:15.520 --> 00:31:17.950
OK, so this is the
last part of this,

00:31:17.950 --> 00:31:19.330
going from desktop to mobile.

00:31:19.330 --> 00:31:21.810
So again, not to harp on
image layouts too much,

00:31:21.810 --> 00:31:26.490
but some GPUs will require
image layout transitions,

00:31:26.490 --> 00:31:27.480
while others won't.

00:31:27.480 --> 00:31:29.650
It's just best to treat
them as if they all do.

00:31:29.650 --> 00:31:31.192
And this is a really
important point.

00:31:31.192 --> 00:31:33.441
I encourage you, if you have
any questions about this,

00:31:33.441 --> 00:31:34.510
please come talk to me.

00:31:34.510 --> 00:31:36.550
I can't say certain
things on stage,

00:31:36.550 --> 00:31:38.490
but I can give you
specific details

00:31:38.490 --> 00:31:40.210
if you want to know
more about this.

00:31:45.510 --> 00:31:47.150
So pay attention to
the device limits.

00:31:49.710 --> 00:31:54.597
This almost goes without saying,
but again, it catches people

00:31:54.597 --> 00:31:55.430
more often than not.

00:31:58.350 --> 00:32:01.980
Most of the vendors
will go above and beyond

00:32:01.980 --> 00:32:05.480
in certain areas of the
device limits, and not others.

00:32:05.480 --> 00:32:08.185
And some device vendors will
just kind of do the minimum.

00:32:08.185 --> 00:32:10.560
It's not because one vendor's
better than the other, it's

00:32:10.560 --> 00:32:12.310
just the implementation, right?

00:32:12.310 --> 00:32:16.505
But don't assume that
the same class of devices

00:32:16.505 --> 00:32:17.630
have similar functionality.

00:32:17.630 --> 00:32:19.480
They may not.

00:32:19.480 --> 00:32:23.550
And if you run into any errors,
especially with device limits,

00:32:23.550 --> 00:32:27.660
you can use a validation
layer to track them down.

00:32:27.660 --> 00:32:30.610
All right, so that's
about 41 slides

00:32:30.610 --> 00:32:33.010
of me talking without
showing you any pictures.

00:32:33.010 --> 00:32:37.940
And let me fix that right now.

00:32:37.940 --> 00:32:41.860
So I know that the
word "games" is

00:32:41.860 --> 00:32:43.110
used in the title of the talk.

00:32:43.110 --> 00:32:45.370
And I'm not going to show
you game engine demos,

00:32:45.370 --> 00:32:48.440
but I would like to show you
render demos, if that's OK.

00:32:48.440 --> 00:32:50.117
And the point of
these demos is to give

00:32:50.117 --> 00:32:52.450
more credence to the fact
that Vulkan is up and running,

00:32:52.450 --> 00:32:55.980
and you can do some pretty
amazing things with it already.

00:32:55.980 --> 00:32:59.090
And so hopefully, these examples
are visually enticing enough.

00:32:59.090 --> 00:33:00.423
Can we get to the demos, please?

00:33:04.670 --> 00:33:08.730
So this is a
flocking simulation.

00:33:08.730 --> 00:33:11.060
It runs almost
entirely on the GPU.

00:33:11.060 --> 00:33:16.740
It's a flock simulation of,
I think, about 4,000 fish.

00:33:16.740 --> 00:33:19.570
And essentially,
the fish simulation

00:33:19.570 --> 00:33:21.242
is running on the GPU.

00:33:21.242 --> 00:33:23.450
And there's a shark that
comes in every now and then,

00:33:23.450 --> 00:33:27.370
and it basically causes
the fish to disperse.

00:33:27.370 --> 00:33:29.940
The code for this is
actually open source.

00:33:29.940 --> 00:33:31.230
It's a sample on Cinder.

00:33:31.230 --> 00:33:34.886
If you want to get it and mess
with it, it's totally free.

00:33:34.886 --> 00:33:35.821
Oops.

00:33:35.821 --> 00:33:36.320
Stay awake.

00:33:39.089 --> 00:33:41.380
The original work was done
by my friend, Robert Hodgin.

00:33:41.380 --> 00:33:45.030
He was gracious enough to donate
it as part of the Vulkan launch

00:33:45.030 --> 00:33:47.780
date efforts.

00:33:47.780 --> 00:33:49.420
And the next demo
I want to show you

00:33:49.420 --> 00:33:53.880
is also another demo by Robert.

00:33:53.880 --> 00:33:57.480
And essentially, if you're
familiar with NASA's capture

00:33:57.480 --> 00:34:03.680
of sunspots, this is what
the images look like.

00:34:03.680 --> 00:34:06.880
So Robert wanted
to create something

00:34:06.880 --> 00:34:09.580
that was a real-time
version of the sunspots.

00:34:09.580 --> 00:34:13.250
So he just likes to
create pretty pictures.

00:34:13.250 --> 00:34:15.239
But it turns out to
be very beautiful.

00:34:15.239 --> 00:34:21.920
And the funny tidbit about
this is that, actually,

00:34:21.920 --> 00:34:24.370
more than a few
people have mistakenly

00:34:24.370 --> 00:34:27.469
thought this was the
actual NASA capture.

00:34:27.469 --> 00:34:30.250
So this one, unfortunately,
isn't open source.

00:34:30.250 --> 00:34:32.976
But if you would like the
APK to either one of these,

00:34:32.976 --> 00:34:34.184
just come find me afterwards.

00:34:34.184 --> 00:34:37.642
I'll be more than happy
to give it to you.

00:34:37.642 --> 00:34:38.850
Can we go back to the slides?

00:34:41.830 --> 00:34:42.330
All right.

00:34:42.330 --> 00:34:44.804
So to wrap things up, if
you want to want to look

00:34:44.804 --> 00:34:46.429
at Cinder's [INAUDIBLE]
implementation,

00:34:46.429 --> 00:34:47.804
it's at
github.com/cinder/Cinder.

00:34:47.804 --> 00:34:50.949
We're on the Vulcan branch.

00:34:50.949 --> 00:34:53.354
If you want to connect
with us about Vulkan,

00:34:53.354 --> 00:34:55.770
we really want to work with
you to make Vulkan successful.

00:34:55.770 --> 00:34:57.810
Please visit this URL.

00:34:57.810 --> 00:34:58.310
Cool.

00:34:58.310 --> 00:35:00.080
Well, thank you, guys.

