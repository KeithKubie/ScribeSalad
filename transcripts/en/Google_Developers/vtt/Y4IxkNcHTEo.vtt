WEBVTT
Kind: captions
Language: en

00:20:16.833 --> 00:20:19.717
&gt;&gt; Hey, everyone, my name is 
Andrew Gasparovic.  I  am an 

00:20:19.718 --> 00:20:25.480
engineer at Google research 
working on machine  intelligence

00:20:25.692 --> 00:20:32.219
.  And today, I'm excited to 
give you an  introduction in 

00:20:32.220 --> 00:20:35.786
machine learning using 
TensorFlow.  I'll  show you some

00:20:36.004 --> 00:20:38.777
 examples of how we've been 
using it at  Google.  And I'll 

00:20:38.778 --> 00:20:41.163
share with you a few recent and 
up  coming developments and then

00:20:41.356 --> 00:20:44.440
 talk about how you can get  
started solving real problems 

00:20:44.441 --> 00:20:50.189
with machine learning.  So  
first, let's talk about exactly 

00:20:50.190 --> 00:20:54.774
what it is that  TensorFlow does
 and why you might want to use 

00:20:54.775 --> 00:20:59.873
it.   TensorFlow lets you get 
straight to work solving all  

00:20:59.874 --> 00:21:04.299
kinds of machine learning tasks.
  The goal is that in  general, 

00:21:04.300 --> 00:21:07.601
no matter what your problem 
looks like,  TensorFlow should 

00:21:07.602 --> 00:21:14.004
be able to support it at some 
level of  the API.  And in 

00:21:14.005 --> 00:21:16.820
general, it's designed to be 
fast, so  it's optimized for the

00:21:17.640 --> 00:21:21.675
 hardware and the platforms that
  you actually want to use it 

00:21:21.676 --> 00:21:25.718
with.  One of the things  that I
 think really makes it unique in

00:21:25.724 --> 00:21:27.268
 terms of machine  learning 
frameworks

00:21:27.269 --> 00:21:33.581
  is that you can actually build
 a  model in let's say five or 

00:21:33.582 --> 00:21:36.476
ten lines of code and then  take
 that model and scale it all the

00:21:36.603 --> 00:21:43.147
 way up to  production.  So you 
can train that model on the 

00:21:43.148 --> 00:21:46.036
cluster  of tens or even 
hundreds of machines, and then 

00:21:46.037 --> 00:21:50.582
take that  model and serve it 
using super low

00:21:54.267 --> 00:21:58.095
 latentcy predictions.
So let's talk about what it is 

00:21:58.096 --> 00:22:00.582
when I say model  and how 
machine learning relates to that

00:22:00.992 --> 00:22:03.691
.
Here's a simple problem.  

00:22:03.692 --> 00:22:08.290
Predict whether an image  
contains a cat or a dog.  This 

00:22:08.291 --> 00:22:13.722
is something that would  be 
difficult or even impossible to 

00:22:13.723 --> 00:22:21.775
do with traditional  programming
 because how do you make a set 

00:22:21.776 --> 00:22:25.687
of rules of  what is a cat 
versus what is a dog?  And then 

00:22:25.688 --> 00:22:31.169
on top of  that capture all the 
variations like breeds, poses, 

00:22:31.170 --> 00:22:35.230
the  brightness and scaling of 
the image, all of that kind of  

00:22:35.231 --> 00:22:40.193
thing.  So what we can do 
instead is make a neuronetwork 

00:22:40.194 --> 00:22:42.969
neuronetwork, which is an 
extremely simplified version  of

00:22:43.389 --> 00:22:46.180
 how neurons in the brain work. 
 Each one of the dots  in this 

00:22:46.181 --> 00:22:49.583
image is a neuron, and they're 
all connected  together layer by

00:22:50.311 --> 00:22:56.730
 layer from the input of what we
 see to  the output of what we 

00:22:56.731 --> 00:23:00.757
understand.  And then what we do
  is we go through lots and lots

00:23:00.959 --> 00:23:05.911
 of examples of cat and  dog 
images.  They're all labeled 

00:23:05.912 --> 00:23:10.592
with the correct  category, and 
we try to make a prediction.  

00:23:10.593 --> 00:23:14.136
Initially,  all of those neurons
 are just randomly initializeed,

00:23:14.544 --> 00:23:21.146
 so  it's a complete guess.  
What we do is we calculate how

00:23:21.150 --> 00:23:24.984
   far we are from the guess to 
the correct answer, the  error, 

00:23:24.985 --> 00:23:29.747
and then we use that error to 
adjust the strength  of the 

00:23:29.748 --> 00:23:34.078
connections between the neurons.
  And basically,  we want to 

00:23:34.079 --> 00:23:36.155
slowly move towards the right 
answer.

00:23:36.663 --> 00:23:40.205
After we repeat that, you know, 
a million or so  times, let's 

00:23:40.206 --> 00:23:44.358
say say, then what you end up 
with is a nice  cat and dog 

00:23:44.359 --> 00:23:49.296
prediction model.  But what you 
actually  want to do is, you 

00:23:49.297 --> 00:23:53.543
know, build a cat and dog 
prediction  website; right?  A 

00:23:53.544 --> 00:23:58.904
user gives you a photo, and you 
have  to tell them whether 

00:23:58.905 --> 00:24:03.251
there's a cat or a dog in it.  
And  the connection strengths 

00:24:03.252 --> 00:24:07.276
that you learn during training  
are what allows your model now 

00:24:07.277 --> 00:24:11.539
to generalize.  So if you  give 
it this photo, even though it 

00:24:11.540 --> 00:24:14.826
has never seen it  before, and 
there's no label attached to it,

00:24:15.673 --> 00:24:19.311
 it can get  a dog prediction 
out, based on what the model 

00:24:19.312 --> 00:24:22.708
learned  via those weights 
attached to the neuron about, 

00:24:22.709 --> 00:24:26.220
you know know, the nature of 
cats versus dogs.  At least in 

00:24:26.221 --> 00:24:29.830
terms  of the images that it is 
seeing.

00:24:30.247 --> 00:24:34.369
But how much it can actually 
learn is a function  of the 

00:24:34.370 --> 00:24:39.434
model, size, and complexity.  
And we just didn't  have 

00:24:39.435 --> 00:24:43.175
computer power and the tools to 
experiment with  really big and 

00:24:43.176 --> 00:24:47.597
complicated models, until very 
recently.   This picture is 

00:24:47.598 --> 00:24:53.614
basically what neural networks 
used to  look like maybe five or

00:24:53.830 --> 00:24:56.032
 ten years ago.  And at that  
point, they had a small number 

00:24:56.033 --> 00:25:01.098
of neurons, they were  just 
fully connected between the 

00:25:01.099 --> 00:25:04.295
layers, if there were  that many
 layers, and then the end result

00:25:04.608 --> 00:25:07.198
 is they  weren't super powerful
.  In fact, for a problem like  

00:25:07.199 --> 00:25:10.408
computer vision, they were 
almost written off compared  to 

00:25:10.409 --> 00:25:16.692
a specializeed hand-tuned model 
that was built by  experts for 

00:25:16.693 --> 00:25:21.849
that exact task.
And you can compare that to a 

00:25:21.850 --> 00:25:24.120
neural network model  that we 
use today for image 

00:25:24.121 --> 00:25:27.900
classification, this is  called 
inception, and the idea is that 

00:25:27.901 --> 00:25:31.535
you feed in an  image, and you 
get a prediction of what's in 

00:25:31.536 --> 00:25:35.735
the image,  among thousands of 
categories.  I think it's, like,

00:25:36.115 --> 00:25:40.749
  17,000 potential classes.
And with a framework like 

00:25:40.750 --> 00:25:44.983
TensorFlow, you can  train a 
model like this that has, you 

00:25:44.984 --> 00:25:49.629
know, tons of  layers and is 
much more complicated than the 

00:25:49.630 --> 00:25:53.238
early  networks.  That's what we
 mean when we say deep learning 

00:25:53.239 --> 00:25:56.335
learning.  The deep in this case
 refers to a deeper  arrangement

00:25:57.672 --> 00:26:01.171
 of layers and the more 
complicated  connections that 

00:26:01.172 --> 00:26:04.673
comes with that.
The end result is that you have 

00:26:04.674 --> 00:26:08.798
millions or even  billions of 
neurons in your model.  And 

00:26:08.799 --> 00:26:15.114
that's what  allows a deep 
neural network to get results 

00:26:15.115 --> 00:26:22.207
that can  actually vastly out
perform the earlier hand built, 

00:26:22.208 --> 00:26:25.955
hand  tuned hand- hand-tuned 
models.

00:26:26.359 --> 00:26:29.154
But the specific reason why 
TensorFlow is so  efficient in 

00:26:29.155 --> 00:26:32.154
working with those huge networks
 is because  it turns the code 

00:26:32.155 --> 00:26:35.856
that you write into a graph of  
operations.  And it's the graph 

00:26:35.857 --> 00:26:41.668
that it actually runs.   The 
data, by the way, that flows 

00:26:41.669 --> 00:26:44.983
between those  operations are 
called tensors, which is where 

00:26:44.984 --> 00:26:48.500
the name  comes from.  And 
because your model's represented

00:26:48.741 --> 00:26:54.578
 as a  graph, you can do things 
like delaying or removing un 

00:26:54.579 --> 00:26:58.115
unnecessary operations, or even 
reusing partial results.   The 

00:26:58.116 --> 00:27:02.349
other thing that you can do 
really easily is the  process 

00:27:02.350 --> 00:27:06.503
called back propagation.  So if 
you remember  when we updated 

00:27:06.504 --> 00:27:09.897
the strength of connections in 
our model  based on the examples

00:27:10.641 --> 00:27:14.080
 that we saw and the error that 
we  calculated, that's the 

00:27:14.081 --> 00:27:19.748
process of back propagation.   
Because the model's represented 

00:27:19.749 --> 00:27:22.437
as a graph of operations  
instead of code, you don't have 

00:27:22.438 --> 00:27:25.440
to write additional code  for 
that, you can just compute and 

00:27:25.441 --> 00:27:27.441
apply those updates  
automatically.

00:27:28.143 --> 00:27:33.520
And another nice side effect of 
having a wrap  around is that 

00:27:33.521 --> 00:27:37.651
you can in your code using a 
one-line  decoration, I want 

00:27:37.652 --> 00:27:40.993
this part of the graph to run 
over  here, I want this part of 

00:27:40.994 --> 00:27:44.082
the graph to be distributed to  
a different set of machines.  Or

00:27:44.286 --> 00:27:47.962
 you can even say I want  this 
part of the graph that's very 

00:27:47.963 --> 00:27:52.228
math intensive to run  on a GPU 
while the data input code runs 

00:27:52.229 --> 00:27:59.060
back on the CPU.
And TensorFlow runs on CPUs and 

00:27:59.061 --> 00:28:05.464
GPUs out of the  box.  It also 
can load models and run 

00:28:05.465 --> 00:28:10.319
inference tasks  like doing a 
prediction or a classification 

00:28:10.320 --> 00:28:16.313
on iOS and  Android devices.  
And now even raspberry pi device

00:28:17.034 --> 00:28:22.722
.  And  inside of our data 
centers, we've been serving  

00:28:22.723 --> 00:28:26.327
TensorFlow graphs using the 
specially

00:28:31.877 --> 00:28:34.597
 hardware called TP TPU.  And 
then going forward in the 

00:28:34.598 --> 00:28:37.905
network, the strains  of 
connections between the neurons 

00:28:37.906 --> 00:28:42.456
for each layer.  That  is 
basically very large matrix math

00:28:42.732 --> 00:28:46.354
 operations, and  that's 
something that TPUs do a lot of 

00:28:46.355 --> 00:28:51.227
very quickly very  well.
Version two of the TPU hardware 

00:28:51.228 --> 00:28:55.643
we're calling the  cloud TPU, 
and I will talk a little bit 

00:28:55.644 --> 00:29:03.080
more about that  in a bit.
So once upon a time, Python was 

00:29:03.081 --> 00:29:06.812
basically the only  choice if 
you wanted to build a TensorFlow

00:29:08.358 --> 00:29:11.360
 graph.  And  it's still a 
perfectly great choice.  It's 

00:29:11.361 --> 00:29:14.971
very simple.   There's a lot of 
example code out there.  It 

00:29:14.972 --> 00:29:19.607
supports  everything out of the 
box.  But there's also support 

00:29:19.608 --> 00:29:22.822
for  a whole variety of other 
languages.  And since  

00:29:22.823 --> 00:29:28.201
TensorFlow is open source, there
 are a lot more  additional 

00:29:28.202 --> 00:29:31.704
language choices with community 
support that  are being added 

00:29:31.705 --> 00:29:34.710
all the time.
And so the end result is that

00:29:37.910 --> 00:29:39.963
 if you're interested 
interested, you can try out 

00:29:39.964 --> 00:29:43.063
TensorFlow in probably your  
favorite language right now, and

00:29:43.066 --> 00:29:46.474
 it will work out of the  box.
And I just wanted to mention, my

00:29:46.781 --> 00:29:52.508
 coworkers on the  TensorFlow 
serving team just announced 

00:29:52.509 --> 00:29:57.722
their 1.0 release  last month, 
which is a really huge milestone

00:29:58.222 --> 00:30:01.028
 for them  because TensorFlow 
serving is a very, very high  

00:30:01.029 --> 00:30:04.125
performance piece of 
infrastructure that you can use 

00:30:04.126 --> 00:30:10.754
to  load your models and then 
serve inference requests, low  

00:30:10.755 --> 00:30:17.971
latentcy on your servers.
Internally, we use it for about 

00:30:17.972 --> 00:30:20.666
800 products, but  we really 
wanted to release it as part of 

00:30:20.667 --> 00:30:26.339
the open  source distribution 
because it's such an important  

00:30:26.340 --> 00:30:30.177
aspect of, you know, a real 
world deployment.  That's  one 

00:30:30.178 --> 00:30:33.249
of the things that when we say 
TensorFlow is  production ready,

00:30:33.970 --> 00:30:36.581
 it's things like this that 
makes the  difference between 

00:30:36.582 --> 00:30:40.088
code that you write for doing  
research and being able to 

00:30:40.089 --> 00:30:45.970
actually run it in production  
solving real problems.

00:30:46.474 --> 00:30:48.474
Another one is a tool called

00:30:51.231 --> 00:30:54.392
 Tensor Board.  So  this is one 
of the visualizeers included in 

00:30:54.393 --> 00:30:58.714
the package.   This particular 
one is showing a clustering of 

00:30:58.715 --> 00:31:02.900
hand- hand-written digits that a
 model learned for that  

00:31:02.901 --> 00:31:07.208
particular task.
In general, visualizing what's 

00:31:07.209 --> 00:31:11.139
happening in a  particular model
 and then trying to debug 

00:31:11.140 --> 00:31:13.424
predictions  that you get out of
 it has traditionally been a 

00:31:13.425 --> 00:31:17.958
very  difficult aspect of 
machine learning.  It's kind of,

00:31:17.959 --> 00:31:23.048
 you  know, one of the achilles 
heels of a lot of machine  

00:31:23.049 --> 00:31:25.072
learning frameworks.

00:31:29.311 --> 00:31:30.958
  So that's something that we 
really  wanted to include 

00:31:30.959 --> 00:31:33.518
because that -- you wouldn't be 
able  to serve something in 

00:31:33.519 --> 00:31:35.902
production unless you were  
actually able to understand 

00:31:35.903 --> 00:31:42.174
what's going on inside of  the 
model and figure out if the 

00:31:42.175 --> 00:31:46.596
prediction that doesn't  match 
what you expected, why that's 

00:31:46.597 --> 00:31:48.597
happening.

00:31:50.006 --> 00:31:52.764
So that production readyiness in
 general has been  one of the 

00:31:52.765 --> 00:31:55.434
keys to the success of the 
framework and one  of the things

00:31:55.659 --> 00:32:02.140
 that makes it different.  
TensorFlow since  its release, 

00:32:02.141 --> 00:32:06.153
has been the number one machine 
learning  repository on GitHub. 

00:32:06.154 --> 00:32:10.174
 And it's really been incredible
  to see the adoption since it 

00:32:10.175 --> 00:32:14.190
was released.  This chart  shows
 the number of stars on GitHub 

00:32:14.191 --> 00:32:17.269
since it was  launched.  And 
last time I checked, it was I 

00:32:17.270 --> 00:32:20.822
think over,  like, 68,000 at 
this point.

00:32:24.055 --> 00:32:27.003
And I think one of the other 
reasons is because we  actually 

00:32:27.004 --> 00:32:31.869
take our place in the open 
source community  really 

00:32:31.870 --> 00:32:38.629
seriously, it's never been for 
us a matter of,  you know, 

00:32:38.630 --> 00:32:44.426
throwing code over the wall or 
taking a thump  from our source 

00:32:44.427 --> 00:32:49.295
code repository and just open 
sourcing  data, and that's the 

00:32:49.296 --> 00:32:53.145
end of it.  Open source and open
  source contributors have been 

00:32:53.146 --> 00:32:56.440
totally a first-class a first-
class part  of the process since

00:32:56.542 --> 00:33:00.064
 it was released.  At this point
,  we've had more than 1,000 

00:33:00.065 --> 00:33:03.671
external contributors on  
TensorFlow, and some of those 

00:33:03.672 --> 00:33:07.813
external commits have  added 
huge new features like 

00:33:07.814 --> 00:33:09.557
additional language that  was 
mentioned earlier.  Additional 

00:33:09.558 --> 00:33:13.785
hardware support, and  even 
whole new platforms that 

00:33:13.786 --> 00:33:18.531
TensorFlow runs on.
And the other aspect of our open

00:33:19.061 --> 00:33:24.109
 source work is  making sure 
that users are productive and 

00:33:24.110 --> 00:33:28.345
informed about  how best to use 
TensorFlow, so to do that, we've

00:33:28.562 --> 00:33:32.794
  answered thousands of 
questions on Stack Overflow, and

00:33:32.797 --> 00:33:39.404
  we are also very serious about
 looking into fixing  issues on 

00:33:39.405 --> 00:33:42.809
our GitHub issues page.  Because
 in general,  we want to have a 

00:33:42.810 --> 00:33:46.097
really seamless experience from 
the  time that you download the 

00:33:46.098 --> 00:33:50.770
framework to the time that  you 
actually launch a model in 

00:33:50.771 --> 00:33:55.704
production.
But just to be clear, you know, 

00:33:55.705 --> 00:34:02.212
we use TensorFlow  a lot within 
Google.  This graph shows the 

00:34:02.213 --> 00:34:06.348
number of  directories in our 
source control tree with models 

00:34:06.349 --> 00:34:11.388
in  them over time.  And the 
orange bar is when we  

00:34:11.389 --> 00:34:15.430
internally release TensorFlow 
for all projects to use.   So 

00:34:15.431 --> 00:34:19.126
you can see before that, there 
was interest to  machine 

00:34:19.127 --> 00:34:23.993
learning and some people white 
listed or using  our precursor 

00:34:23.994 --> 00:34:27.633
framework.  And then after it 
was released released, it just 

00:34:27.634 --> 00:34:31.662
exploded, and there are more 
than  6,000 products at Google 

00:34:31.663 --> 00:34:37.528
using TensorFlow today.  And,  
in fact, it's pretty much every 

00:34:37.529 --> 00:34:41.048
major Google product is  using 
TensorFlow and doing machine 

00:34:41.049 --> 00:34:44.752
learning in some form  or 
another.  And that has given us 

00:34:44.753 --> 00:34:48.173
a ton of feedback and  
opportunities to make TensorFlow

00:34:49.520 --> 00:34:53.560
 better by doing things  like 
streamlining the APIs that we 

00:34:53.561 --> 00:34:57.904
provide, adding new  high level 
APIs over time to make it easier

00:34:58.116 --> 00:35:05.341
 to use, and,  you know, also, 
just providing some of the 

00:35:05.342 --> 00:35:07.342
production- production-ready 
tools that I mentioned.

00:35:07.503 --> 00:35:10.382
So let me show you some of the 
things that we've  been 

00:35:10.383 --> 00:35:14.404
specifically using TensorFlow 
for because there's  so much 

00:35:14.405 --> 00:35:18.977
variety in the types of problems
, it's I think a  good 

00:35:18.978 --> 00:35:25.977
demonstration of how flexible it
 is as a framework.   Google 

00:35:25.978 --> 00:35:30.546
translate used to use a model 
that basically  translated word 

00:35:30.547 --> 00:35:35.306
by word.  Maybe a few phrases 
here and  there, but that was 

00:35:35.307 --> 00:35:38.413
basically the extent of it.  And
  then on top of that, it had 

00:35:38.414 --> 00:35:43.523
hundreds and thousands of  lines
 of hand-tuned code written with

00:35:43.525 --> 00:35:50.773
 the input of  linguists and 
language experts.  Even so, it 

00:35:50.774 --> 00:35:56.143
had a lot  of difficulty 
accommodating all the nuances 

00:35:56.144 --> 00:35:59.372
and  differences in languages.
So here's an example on the 

00:35:59.373 --> 00:36:03.171
right of it  translating a 
particular Chinese phrase into 

00:36:03.172 --> 00:36:07.349
where will  the restroom, which,
 you know, leaves a lot of room 

00:36:07.350 --> 00:36:12.379
for  improvement.  We've 
replaced that entire previous 

00:36:12.380 --> 00:36:17.667
system  with a new deep neural 
network-based system called  

00:36:17.668 --> 00:36:20.157
neural machine translation, and 
that's running on  TensorFlow.  

00:36:20.158 --> 00:36:23.335
And the end result is that many 
of the  language pairs have had 

00:36:23.336 --> 00:36:27.927
huge gains in translation  
quality, up to 85% in some cases

00:36:28.320 --> 00:36:32.337
.  And the reason why is  
because the model works by 

00:36:32.338 --> 00:36:36.867
considering a whole sequence  of
 words.  A sequence input and a 

00:36:36.868 --> 00:36:40.467
sequence output.  So  the end 
result is that you get a more 

00:36:40.468 --> 00:36:44.223
natural-sounding  output, much 
more like a human translator 

00:36:44.224 --> 00:36:51.440
would do.  For  instance, here, 
excuse me, where is the toilet? 

00:36:51.441 --> 00:36:54.239
 A much  better result.
And sticking with that 

00:36:54.240 --> 00:36:59.583
translation theme, we added  the
 word lens feature to the app, 

00:36:59.584 --> 00:37:02.791
and this is actually  running on
 the mobile device.  It works in

00:37:03.208 --> 00:37:07.048
 airplane mode mode, which is 
pretty incredible, considering 

00:37:07.049 --> 00:37:09.515
that it's  doing basically a 
combination of computer vision 

00:37:09.516 --> 00:37:13.867
and  translation all in the same
 model.  We had to add  features

00:37:14.068 --> 00:37:20.044
 to TensorFlow specifically to 
make things like  that possible.

00:37:20.158 --> 00:37:24.441
  And now, you can train a model
 on a  cluster of servers on one

00:37:24.699 --> 00:37:27.858
 machine, however you would do  
it normally, but then take that 

00:37:27.859 --> 00:37:31.300
model and reduce the  size of it
 to fit on the device while 

00:37:31.301 --> 00:37:38.823
keeping the  quality high.
And then Google photos is an 

00:37:38.824 --> 00:37:43.606
example of an already  great 
product that was enhanced by 

00:37:43.607 --> 00:37:46.606
adding machine  learning 
functionality to it.  So in 

00:37:46.607 --> 00:37:53.427
about six months  time, the team
 took that image-based 

00:37:53.428 --> 00:37:55.428
classification  system and got 
it working live in Google photos

00:37:55.622 --> 00:37:59.869
.  And  the idea is that you can
 take a term and search for it  

00:37:59.870 --> 00:38:04.202
in your photos for pretty much 
anything.  Like, you can  type 

00:38:04.203 --> 00:38:09.253
in beach and get photos of 
beaches, you can type in  photo 

00:38:09.254 --> 00:38:14.237
and get an image that contains 
umbrella in it or  even an 

00:38:14.238 --> 00:38:18.137
abstract term like sunny without
 previously  having added those 

00:38:18.138 --> 00:38:23.494
tags to your photos.
A more difficult image-based 

00:38:23.495 --> 00:38:28.253
task using another  deep neural 
network is the show and tell 

00:38:28.254 --> 00:38:34.232
model from  Google Research.
It takes an image input, and it 

00:38:34.233 --> 00:38:37.257
outputs a human- human-sounding 
caption.  It also starts with 

00:38:37.258 --> 00:38:40.439
that  inception model, but in 
this case, it's not just  

00:38:40.440 --> 00:38:43.113
classifying the objects that 
appear in the image, it's  

00:38:43.114 --> 00:38:48.093
actually writing a caption that 
sounds natural and  captures the

00:38:48.493 --> 00:38:50.801
 relationship between objects 
that appear in  the image.

00:38:50.997 --> 00:38:57.397
To do that, the model was fine-
tuned on examples  of images 

00:38:57.398 --> 00:39:01.409
that had human-generated 
captions.  And from  that, it 

00:39:01.410 --> 00:39:05.131
learned about relationships.  As
 a side effect  of that process,

00:39:05.428 --> 00:39:08.647
 the model actually got better 
at  describing details in the 

00:39:08.648 --> 00:39:11.439
images like colors because it  
found that those are things that

00:39:11.938 --> 00:39:17.409
 humans want to hear in  a 
caption that they like.

00:39:17.738 --> 00:39:20.837
So Google Research, by the way, 
open sourced the  entire model, 

00:39:20.838 --> 00:39:25.185
and there's an in-depth post 
about it on  the research blog, 

00:39:25.186 --> 00:39:29.130
and you can go there and follow 
the  links and try it out for 

00:39:29.131 --> 00:39:33.467
yourself.
One of the other things that 

00:39:33.468 --> 00:39:37.072
we've been doing at  Google 
research is working on diagnose

00:39:37.910 --> 00:39:43.155
ing a condition  called diabetic
 retinopathy using computer 

00:39:43.156 --> 00:39:48.728
vision.   Ideally photo and 
ophthalmologists, they take an 

00:39:48.729 --> 00:39:53.871
image  like this and analyze it 
for early signs of diabetic

00:39:57.832 --> 00:40:04.455
  neuropathy.  The problem is 
there aren't enough open  that

00:40:07.878 --> 00:40:11.918
  ophthalmologists going around,
 and the end result it is  the 

00:40:11.919 --> 00:40:13.919
leading cause of blindness in 
the world.

00:40:14.584 --> 00:40:17.716
So we published an article in 
the Journal of the  American 

00:40:17.717 --> 00:40:20.184
Medical Association, which shows
 that a  computer vision model 

00:40:20.185 --> 00:40:26.789
can actually be as good or even 
 slightly better than the 

00:40:26.790 --> 00:40:31.694
average ophthalmologists at  
diagnoseing the condition.  So 

00:40:31.695 --> 00:40:33.572
that's something we're  really 
excited about.  Because if we 

00:40:33.573 --> 00:40:37.588
can get the model  out there, 
then it will have a real impact 

00:40:37.589 --> 00:40:42.757
to help find  more of these 
cases Brits before it's too late

00:40:43.055 --> 00:40:47.387
.
And one last thing from the 

00:40:47.388 --> 00:40:52.427
research team is this  problem 
using a deep neural network to 

00:40:52.428 --> 00:40:56.264
actually learn  what kind of 
architectures are good for 

00:40:56.265 --> 00:40:59.049
solving  different types of 
problems.

00:40:59.873 --> 00:41:05.341
So what we're able to do is do a
 search from a  poor-performing 

00:41:05.342 --> 00:41:08.663
machine-learning model to one 
that's  much more accurate 

00:41:08.664 --> 00:41:11.511
without any human intervention 
in  between.  The model actually

00:41:12.472 --> 00:41:16.106
 builds a machine-learning  
model that solves the task.  And

00:41:16.405 --> 00:41:19.424
 those sort of problems  are 
called learnings learn, which is

00:41:19.824 --> 00:41:23.048
 a really exciting  area in the 
field of research, and there's 

00:41:23.049 --> 00:41:26.777
going to be a  lot more 
happening in the next couple of 

00:41:26.778 --> 00:41:31.305
years in that  area.
But just before you get the idea

00:41:31.710 --> 00:41:36.467
 that, you know,  TensorFlow is 
meant for long-term research or 

00:41:36.468 --> 00:41:40.607
meant for  big budget 
blockbuster apps, I wanted to 

00:41:40.608 --> 00:41:44.618
show you a  Japanese cucumber 
farmer.  His son in the back of 

00:41:44.619 --> 00:41:49.501
the  photo there built an 
automatic cucumber sorter using 

00:41:49.502 --> 00:41:53.640
 TensorFlow, along with an 
Arduino controller and a  

00:41:53.641 --> 00:41:57.961
raspberry  raspberry pi.  He 
trained the model by showing it 

00:41:57.962 --> 00:42:02.219
7,000  examples of cucumbers in 
nine different categories.  And 

00:42:02.220 --> 00:42:05.762
 so this is a job that his mom 
was doing for ten hours at  a 

00:42:05.763 --> 00:42:10.939
time after every cucumber 
harvest.  And in his words,  he 

00:42:10.940 --> 00:42:14.447
said I wanted to leave sorting 
to AI so that we can  focus more

00:42:14.860 --> 00:42:18.402
 on growing good cucumbers.  So 
after the  model was trained, he

00:42:18.662 --> 00:42:23.676
 hooked it up -- he hooked up a 
 conveyor belt to the controller

00:42:23.985 --> 00:42:30.193
, and an array of webcams  to 
the raspberry pi.  So as each 

00:42:30.194 --> 00:42:34.734
cucumber comes by the  belt, 
it's imaged by the webcam, it's 

00:42:34.735 --> 00:42:37.591
classified, and  it's sorted 
automatically, which I think is 

00:42:37.592 --> 00:42:41.975
just a  fantastic example of 
something really outside the box

00:42:42.710 --> 00:42:44.550
  that
  you can do practically with 

00:42:44.551 --> 00:42:52.702
machine learning.
And so TensorFlow was I think 

00:42:52.703 --> 00:42:57.845
really powerful for  solving all
 of those sort of problems as of

00:42:57.848 --> 00:43:03.589
 the 1.0  release.  But there 
have been quite a few new  

00:43:03.590 --> 00:43:06.758
developments since then.  So let
 me just go over a  couple of 

00:43:06.759 --> 00:43:10.472
those with you now.
First of all, it has gotten a 

00:43:10.473 --> 00:43:17.534
lot easier to use.   So I 
mention TensorFlow has always 

00:43:17.535 --> 00:43:19.993
been extremely  flexible with 
the goal of being able to solve 

00:43:19.994 --> 00:43:23.717
any sort  of problem that you 
throw at it.  But it wasn't 

00:43:23.718 --> 00:43:29.589
always  the easiest to use, 
necessarily.  It has the 

00:43:29.590 --> 00:43:32.199
distributed  execution engine at
 the bottom there, which is what

00:43:32.505 --> 00:43:36.848
  actually executes the graph of
 operations and  distributes 

00:43:36.849 --> 00:43:40.546
them among the processors and 
machines.   That has pretty much

00:43:40.749 --> 00:43:46.638
 stayed the same.  As of 1.0, 
then  we added a layers API with

00:43:46.642 --> 00:43:49.205
 the idea that you could  
construct a model without having

00:43:50.140 --> 00:43:53.739
 to actually mess around  with 
the graph and operations 

00:43:53.740 --> 00:43:58.285
directly.  But you still  had to
 build the actual network 

00:43:58.286 --> 00:44:00.549
architecture and all of  the 
layers and that sort of thing.  

00:44:00.550 --> 00:44:04.837
Still had to do that  part by 
hand.  And then we added on top 

00:44:04.838 --> 00:44:08.124
of that the  estimator API, 
which is a high level way to 

00:44:08.125 --> 00:44:12.891
take a model  and combine that 
with input and do the training 

00:44:12.892 --> 00:44:18.789
and  evaluation process.  Now as
 of 1.3, we added another  layer

00:44:19.284 --> 00:44:25.918
 on top of that
  for what we call the canned  

00:44:25.919 --> 00:44:29.202
estimator.  You can create a 
deep neural network  classifyier

00:44:29.358 --> 00:44:32.185
 in literally one line of code. 
 And then when  you use the high

00:44:32.397 --> 00:44:36.669
 level estimator APIs, you get a
 bunch  of things for free like 

00:44:36.670 --> 00:44:39.982
distributed training, automatic 
 snapshots, and the ability to 

00:44:39.983 --> 00:44:46.028
run on a mix of hardware  that 
you have like the CPUs Us and GP

00:44:46.140 --> 00:44:49.734
Us.  You also get all  of the 
best guarantees that the 

00:44:49.735 --> 00:44:52.012
performance improvements  that 
we've been making will actually 

00:44:52.013 --> 00:44:55.016
apply to your model model.  
We've started publishing 

00:44:55.017 --> 00:44:57.994
benchmarks of different  tasks 
running on different 

00:44:57.995 --> 00:45:04.056
combinations of hardware.   And 
that is important because it's 

00:45:04.057 --> 00:45:06.948
going to show how  we're going 
to continue to improve 

00:45:06.949 --> 00:45:09.828
performance over time time.  But
 it's also important because it 

00:45:09.829 --> 00:45:12.912
can tell you  how you should 
expect TensorFlow to behave on 

00:45:12.913 --> 00:45:16.408
the  combination of, you know, 
hardware that you have and the  

00:45:16.409 --> 00:45:21.698
problem that you're trying to 
solve.  And as far as un 

00:45:21.699 --> 00:45:26.205
uncommon configurations, here's 
the cloud TPU that I was  

00:45:26.206 --> 00:45:29.907
talking about earlier.
 It's the second generation  

00:45:29.908 --> 00:45:33.117
tensor processing unit.  The 
first generation we only  used 

00:45:33.118 --> 00:45:37.274
for accelerating the inference 
part of machine  learning.  The 

00:45:37.275 --> 00:45:39.275
second generation also 
accelerates  training.  And it's

00:45:39.743 --> 00:45:46.236
 a big improvement in general 
because  each cloud TPU does 180

00:45:47.489 --> 00:45:51.107
 teraflops individually.  But  
they're meant to be connected, 

00:45:51.108 --> 00:45:56.698
64 of them at a time into  these
 TPU pods.  One pod is 11.5 

00:45:56.699 --> 00:46:04.627
petaflops, which is an  enormous
 amount of operations.  And the 

00:46:04.628 --> 00:46:07.751
neural  translation that I 
talked about earlier used to 

00:46:07.752 --> 00:46:13.115
take a  full day to train on 32 
of the best GPUs that we could  

00:46:13.116 --> 00:46:16.741
get our hands on.  And now we 
train it to the same  accuracy 

00:46:16.742 --> 00:46:21.718
in about half a day using 
one-eighth of one of  these TPU 

00:46:21.719 --> 00:46:24.893
pods.  And the -- oh,.
[Applause]

00:46:29.240 --> 00:46:33.787
The cloud TPU, by the way, we're
 making available  on the cloud 

00:46:33.788 --> 00:46:38.060
platform to external users later
 on in the  year, and I'll have 

00:46:38.061 --> 00:46:40.614
a little bit more information 
about  that at the end of the 

00:46:40.615 --> 00:46:46.501
talk.
We also need to make sure that 

00:46:46.502 --> 00:46:50.526
we're fully taking  advantage of
 whatever hardware you give to 

00:46:50.527 --> 00:46:55.482
the machine  learning task, 
whether it is a TPU or the GPUs 

00:46:55.483 --> 00:46:59.193
that you  have, or even just the
 instructions that your CPU  

00:46:59.194 --> 00:47:02.709
supports.  So we've been working
 on a compiler that  converts 

00:47:02.710 --> 00:47:06.942
those graphs that I talked about
 directly into  assembly code.  

00:47:06.943 --> 00:47:11.800
It's called XLA, which is for  
accelerated linear algebra.  

00:47:11.801 --> 00:47:16.146
It's a requirement for  running 
on the TPUs, but it also runs in

00:47:16.868 --> 00:47:22.723
 Gitmo to  compile a graph for 
CPUs and GPUs so that it can 

00:47:22.724 --> 00:47:26.141
choose  exactly the right 
colonels for the hardware that 

00:47:26.142 --> 00:47:28.981
you  have available.  And then 
there's a third mode that's  

00:47:28.982 --> 00:47:32.402
meant for mobile where you can 
compile a model ahead of  time 

00:47:32.403 --> 00:47:35.173
and run predictions on the 
mobile device.

00:47:35.585 --> 00:47:39.811
The advantages that the compiled
 model is much  smaller, but it 

00:47:39.812 --> 00:47:42.724
still has the possibility of 
running  more efficiently as 

00:47:42.725 --> 00:47:47.683
well on the specific device.  
And  one last note about mobile 

00:47:47.684 --> 00:47:54.196
is we are working on  TensorFlow
 Lite, which is a whole new run 

00:47:54.197 --> 00:47:56.982
time that's  specifically built 
for Android mobile devices.  The

00:47:57.314 --> 00:48:01.337
 idea  is that you put a very 
slim engine in a mobile app,  

00:48:01.338 --> 00:48:04.744
which supports exactly the 
hardware that you have on the  

00:48:04.745 --> 00:48:07.941
device.  And then it leaves out 
all of the unnecessary  purpose 

00:48:07.942 --> 00:48:13.409
code.  When you combine that 
with an XLA  compiled model, you

00:48:13.412 --> 00:48:16.093
 get the efficient use of 
hardware  with a small memory 

00:48:16.094 --> 00:48:21.996
footprint.  And so you can do 
this  on-device inference tasks 

00:48:21.997 --> 00:48:28.418
like I showed earlier, as well  
as something new that we're 

00:48:28.419 --> 00:48:30.898
calling learning where you  can 
take advantage of a model that 

00:48:30.899 --> 00:48:34.424
has been trained and  running in
 the cloud somewhere, while 

00:48:34.425 --> 00:48:38.958
having your own  individual 
training data on the device.

00:48:39.277 --> 00:48:43.086
So it's never sent to the cloud,
 but you can  combine those 

00:48:43.087 --> 00:48:49.076
together on the device.
Even if you have a lot of 

00:48:49.077 --> 00:48:51.967
programming experience,  I will 
readyily admit that getting into

00:48:52.180 --> 00:48:57.060
 machine learning  can be 
daunting.  Very daunting.  And 

00:48:57.061 --> 00:48:59.726
one of the  benefits of trying 
out TensorFlow is that the stuff

00:49:00.026 --> 00:49:03.751
 you  play around with, you can 
eventually actually use in  

00:49:03.752 --> 00:49:09.539
production.  But still, I would 
like to give you some  tips on 

00:49:09.540 --> 00:49:12.816
how you can get started, no 
matter what level  you're at.

00:49:13.553 --> 00:49:16.852
First recommendation is to start
 at TensorFlow.org  because 

00:49:16.853 --> 00:49:23.670
there's a getting started 
section there that has  a nice 

00:49:23.671 --> 00:49:27.798
hands on direction to TensorFlow
, as well as some  machine-

00:49:28.311 --> 00:49:30.386
learning tasks that you would 
want to do with it it.  And they

00:49:30.562 --> 00:49:33.779
 assume some knowledge of Python
 for those  particular intros, 

00:49:33.780 --> 00:49:36.050
but that's about it.
And then if you start with those

00:49:36.360 --> 00:49:40.069
, you can progress  all the way 
through the tutorials to 

00:49:40.070 --> 00:49:43.259
building things  like a 
convolutional network, which is 

00:49:43.260 --> 00:49:47.081
good for image  classification, 
and a recurrent network, which 

00:49:47.082 --> 00:49:51.098
is good  for those language and 
translation tasks.

00:49:51.299 --> 00:49:55.759
And then there's also a really 
interesting demo of  different 

00:49:55.760 --> 00:50:03.272
neural network architectures and
 parameters at  play ground.

00:50:03.273 --> 00:50:07.813
tensorflow.org.  You can try the
 different  layers through the 

00:50:07.814 --> 00:50:12.085
neurons and the learning rate 
and get  an intuition about how 

00:50:12.086 --> 00:50:14.901
neural networks work by seeing  
the effect on a very simple 

00:50:14.902 --> 00:50:18.180
classification problem.
And then once you start -- once 

00:50:18.181 --> 00:50:21.916
you're ready to  start building 
real models to use in production

00:50:22.313 --> 00:50:30.213
, I  recommend using that high-
level estimator and a canned  

00:50:30.214 --> 00:50:33.353
estimator APIs because you get 
all of those automatic  benefits

00:50:33.664 --> 00:50:39.758
 like the save checkpoints, 
exporting the tensor  board, and

00:50:39.760 --> 00:50:42.149
 the ability to do additional 
training with  pretty much no 

00:50:42.150 --> 00:50:45.255
additional work.  So nine times 
out of  ten or even more than 

00:50:45.256 --> 00:50:47.695
that at this point, the 
estimators  and the canned 

00:50:47.696 --> 00:50:53.855
estimators are the way to go.
And then, of course, by using 

00:50:53.856 --> 00:50:58.625
estimators, you  could if you 
wanted to, move your model onto 

00:50:58.626 --> 00:51:08.074
cloud TPUs  down the road pretty
 much automatically.  And at G.

00:51:08.259 --> 00:51:12.491
co/GP G.co/GPU sign up, there's 
a sign up form if you're  

00:51:12.492 --> 00:51:14.679
interested in finding out more 
information about those.   That 

00:51:14.680 --> 00:51:20.420
link is also the place to go to 
find out about the  TensorFlow 

00:51:20.421 --> 00:51:24.700
research cloud.  So we're making
 1,000 of  those cloud TPUs 

00:51:24.701 --> 00:51:27.665
available for free to machine-
learning  researchers because 

00:51:27.666 --> 00:51:32.606
there are so many people that 
have  great ideas but limited 

00:51:32.607 --> 00:51:34.983
access to the kind of hardware  
to do the really 

00:51:34.984 --> 00:51:38.580
state-of-the-art research.
So check out that link as well 

00:51:38.581 --> 00:51:42.186
if you would like  to apply for 
that.

00:51:42.487 --> 00:51:48.307
And finally, there are a number 
of good online  courses for 

00:51:48.308 --> 00:51:52.326
machine learning.  I recommend 
checking out  the Google 

00:51:52.327 --> 00:51:59.028
developers YouTube channel.  And
 also, we  would ask to use deep

00:51:59.245 --> 00:52:03.888
 learning TensorFlow, which 
really  gets into the deep math 

00:52:03.889 --> 00:52:09.257
background of machine learning. 
  And if you like that course, 

00:52:09.258 --> 00:52:14.117
it's a step closer to  getting 
the machine learning nanodegree.

00:52:14.311 --> 00:52:16.492
I hope that you want to continue
 with machine  learning because 

00:52:16.493 --> 00:52:20.609
it is an incrediblely-exciting 
field.   It's more accessible 

00:52:20.610 --> 00:52:23.090
than ever, and there is so much 
 happening.  I want to thank you

00:52:23.300 --> 00:52:27.307
 for your time, and I  hope you 
enjoy the rest of your 

00:52:27.308 --> 00:52:32.072
conference.
If you are interested in giving 

00:52:32.073 --> 00:52:34.073
feedback,

00:52:35.437 --> 00:52:37.817
 you'll  have to look elsewhere.
  But thanks.

00:52:37.870 --> 00:52:39.870
[Applause]

01:01:14.949 --> 01:01:18.182
&gt;&gt; Hello, everybody,.  It's 
great to see you here.   My name

01:01:18.183 --> 01:01:22.521
 is Alexey Kokin, and I'm on the
 Google  development team.  We 

01:01:22.522 --> 01:01:26.679
work with developers across the 
 globe to help them grow on 

01:01:26.680 --> 01:01:33.039
Android platform.  If you  have 
been following our blogs 

01:01:33.040 --> 01:01:35.778
announcement this year,  you 
probably notice two important 

01:01:35.779 --> 01:01:39.652
messages that we gave.   One in 
Q1, and second a few months ago.

01:01:39.954 --> 01:01:43.655
  But we are  going to move away
 from just installs and

01:01:48.389 --> 01:01:55.095
 mute mutateers, and  we will 
start focusing on more complex 

01:01:55.096 --> 01:01:59.091
like engagement  or box.
Today we're going to talk about 

01:01:59.092 --> 01:02:01.562
in detail, first  of all, why 
it's important to have a quality

01:02:03.299 --> 01:02:10.797
 app and  we'll talk about new 
tools we have to help you  

01:02:10.798 --> 01:02:18.395
troubleshoot applications and in
 the end, we will  discuss how 

01:02:18.396 --> 01:02:24.893
you can benefit from having 
quality app and  what can Google

01:02:24.898 --> 01:02:30.388
 Play give investing out of time
 on  building applications.

01:02:31.111 --> 01:02:33.277
First of all, let's start with 
the basics.  Why it  is 

01:02:33.278 --> 01:02:38.737
important to have quality 
application.

01:02:39.568 --> 01:02:42.330
There are a lot of components 
for the quality of  applications

01:02:42.576 --> 01:02:48.595
 inside Google Play, and we'll 
talk in more  detail about each 

01:02:48.596 --> 01:02:51.204
and every one of the components 
today.

01:02:51.407 --> 01:02:55.639
One of the examples of 
applications in Play and  

01:02:55.640 --> 01:03:00.090
performance, we have seen the 
application moves on  average 

01:03:00.091 --> 01:03:06.658
quality, they display an amazing
 and some of the  most important

01:03:06.811 --> 01:03:09.810
 methods for application 
developers.  For  example, they 

01:03:09.811 --> 01:03:15.065
have seen up to seven times 
increased  retention and up to 

01:03:15.066 --> 01:03:18.167
six times lead in spend 
applications applications.  

01:03:18.168 --> 01:03:21.993
Those methods alone can make or 
break  your entire application 

01:03:21.994 --> 01:03:24.274
business.  So this is phenomenal
 phenomenal, and this is one of 

01:03:24.275 --> 01:03:30.456
the most crucial things  we can 
focus on in building your mobile

01:03:31.481 --> 01:03:33.970
 application.
Our partners work on data 

01:03:33.971 --> 01:03:37.795
devices, they generally  confirm
oire ideas about the 

01:03:37.796 --> 01:03:41.402
applications.  Some examples  
from them are examples of 

01:03:41.403 --> 01:03:45.109
significant user ratings after  
performance problems of the 

01:03:45.110 --> 01:03:47.110
applications.  Have a high  rate
 of

01:03:50.287 --> 01:03:56.248
 4.1, and they manage to do it 
to 4.5, and those  are great 

01:03:56.249 --> 01:03:58.934
results.  Those who work on 
applications, you  know how 

01:03:58.935 --> 01:04:03.074
difficult to grow when it's 
already high.

01:04:03.594 --> 01:04:09.781
Another partner, Lambda, they 
have focused on  performance.  

01:04:09.782 --> 01:04:15.965
And faster launch makes a lot of
 impact on  their business 

01:04:15.966 --> 01:04:21.786
critical.  As long as they gain 
a lot of  graphic, in fact, on 

01:04:21.787 --> 01:04:29.519
the monitoring on the LTV.
A lot of great applications can 

01:04:29.520 --> 01:04:34.508
use and more to  use important 
goods through such applications.

01:04:34.921 --> 01:04:41.440
And finally, there's the most 
important factor for  your 

01:04:41.441 --> 01:04:49.168
application in Google Play.  
Every user knows every  

01:04:49.169 --> 01:04:52.382
generating helps you more five 
star generating helps.   And the

01:04:52.579 --> 01:04:58.254
 statistics likes it.  50% of 
negative reviews as  I mentioned

01:04:58.485 --> 01:05:03.231
 stability and bugs.  And 60% of
 positive  reviews mention stuff

01:05:03.358 --> 01:05:11.021
 like speed, design, and  
performance.  You know

01:05:11.890 --> 01:05:15.922
Android Vitals is our new step 
to help you build  applications,

01:05:16.223 --> 01:05:18.223
 which we announced this

01:05:20.207 --> 01:05:29.123
 May.  This is by  Google to 
improve stability and 

01:05:29.124 --> 01:05:32.223
performance.  And you as  a 
application developer are the 

01:05:32.224 --> 01:05:36.066
important part of this  effort. 
 We are starting by focusing on 

01:05:36.067 --> 01:05:43.387
three main  performance.  The 
stability and rendering.  By  

01:05:43.388 --> 01:05:50.109
collecting data from devices all
 over the world,.

01:05:50.226 --> 01:05:55.267
To give you a little bit more 
inside of how  different from 

01:05:55.268 --> 01:06:00.019
other and what areas you should 
focus on  to improve your 

01:06:00.020 --> 01:06:07.660
application quality.
Again, support us in this 

01:06:07.661 --> 01:06:11.160
activity, and if you are  
speaking about application 

01:06:11.161 --> 01:06:16.143
stability or on the  performance
 on device here, even the 

01:06:16.144 --> 01:06:19.989
biggest display of  market can 
benefit to doing actual good 

01:06:19.990 --> 01:06:29.890
work or  decreasing this.  For 
example, Kabam

01:06:30.201 --> 01:06:33.826
 growing retention  of improving
 application performance.  And 

01:06:33.827 --> 01:06:37.751
everybody in  this room knows 
how important this metric is for

01:06:37.754 --> 01:06:41.391
 your  application.
So our three main areas.  First 

01:06:41.392 --> 01:06:48.408
area is stability.   Where we 
focus on crashes and the 

01:06:48.409 --> 01:06:50.294
application is not  responding 
when the application is frozen 

01:06:50.295 --> 01:06:56.584
for five  seconds or so.  Second
, major focal point is battery  

01:06:56.585 --> 01:07:02.866
because the main concern here is
 not to overly use the  battery 

01:07:02.867 --> 01:07:06.230
of your device.
And the third focused area is 

01:07:06.231 --> 01:07:11.874
rendering because of  the way 
everything is rendered faster 

01:07:11.875 --> 01:07:16.112
moved at 60 frames  per second. 
 And a lot of things if your UI 

01:07:16.113 --> 01:07:24.297
is slow,  from using the device 
application.

01:07:24.475 --> 01:07:31.199
So this three major areas, we 
have added a new  sections play 

01:07:31.200 --> 01:07:35.345
vitals.  And so so if there is 
one thing  after the 

01:07:35.346 --> 01:07:39.403
presentation, the developer 
console and check  this section 

01:07:39.404 --> 01:07:44.135
for some new insights.  I will 
consider my  mission a success. 

01:07:44.136 --> 01:07:49.811
 And if you will analyze some of
 the  data, this area and 

01:07:49.812 --> 01:07:52.596
performance improvements based 
on  the statistics available.

01:07:52.924 --> 01:07:59.229
And the best thing about Vitals 
is that they  already work.  You

01:07:59.230 --> 01:08:03.174
 don't have to implement new, 
you  don't have to do anything 

01:08:03.175 --> 01:08:06.991
because those statistics are  
available for you right now for 

01:08:06.992 --> 01:08:13.087
your -- for each and  every 
application.  And from this 

01:08:13.088 --> 01:08:16.910
users who can focus in  on the 
decorations.  So if you want to 

01:08:16.911 --> 01:08:24.857
help, you should  also this 
option on your device too.  It 

01:08:24.858 --> 01:08:30.782
will help you.
So let's go to the stability 

01:08:30.783 --> 01:08:36.021
areas, and I probably  will not 
be focusing a lot because each 

01:08:36.022 --> 01:08:41.090
and every review review, you 
definitely, you try to fix them.

01:08:41.417 --> 01:08:46.561
  But which  we call the 
application not responding and 

01:08:46.562 --> 01:08:52.708
happen when  the application is 
not responding.

01:08:55.506 --> 01:09:03.490
So definitely users experience 
embarked user  behaviors.  And 

01:09:03.491 --> 01:09:11.876
the issue cannot use.  But we 
can  because the response

01:09:14.484 --> 01:09:19.637
 and this information in Android
  Vitals.  You can head over to 

01:09:19.638 --> 01:09:21.919
the section of your  console, 
and you will see a lot of 

01:09:21.920 --> 01:09:27.516
information of the  performance 
and number in different views of

01:09:27.629 --> 01:09:31.574
 different  devices and 
application and versions.  There

01:09:31.575 --> 01:09:37.537
 are a lot,  one in particular 
we will definitely and 

01:09:37.538 --> 01:09:41.491
exclamation  point.  And 
generally, a lot means more than

01:09:41.918 --> 01:09:46.394
 5%.  So if  something is above 
5%, there's something definitely

01:09:46.516 --> 01:09:50.926
 to  focus on and analyze about.
There are a lot of additional 

01:09:50.927 --> 01:09:55.247
statistics in this  particular. 
 Here you can see

01:10:00.095 --> 01:10:05.880
, for example, you can see  how 
the user is impacted and the 

01:10:05.881 --> 01:10:07.902
effect.

01:10:11.082 --> 01:10:17.023
There is one questions.  We have
 found out that  the matter 

01:10:17.024 --> 01:10:21.971
actually a lot, and they have 
analyzed  applications on Google

01:10:21.974 --> 01:10:28.380
 Play and application rates, 
again again, above five, they 

01:10:28.381 --> 01:10:36.345
have around 30% more one-day un 
uninstallations.  So if you want

01:10:38.408 --> 01:10:40.408
 to avoid

01:10:42.842 --> 01:10:48.111
 -- even big  developers, like, 
for example, Twitter here has  

01:10:48.112 --> 01:10:52.346
benefited from the statistics 
and help them improve  

01:10:52.347 --> 01:10:54.948
experience for actually hundreds
 of millions of users  all over 

01:10:54.949 --> 01:11:02.047
the globe.
Next chart is battery.  Our 

01:11:02.048 --> 01:11:05.381
Android team is  working 
constantly on making some good 

01:11:05.382 --> 01:11:10.055
improvements to  increase the 
battery life of each and every 

01:11:10.056 --> 01:11:16.296
device.  The  best way to keep 
the battery alive is to

01:11:20.427 --> 01:11:23.933
 shut down most  of the features
 and hardware that is not used 

01:11:23.934 --> 01:11:26.942
right now.   You as the 
developer needs more power for 

01:11:26.943 --> 01:11:35.181
the  applications, keep the 
device alive and behavior speech

01:11:35.394 --> 01:11:37.510
  can be difficult.

01:11:40.850 --> 01:11:45.636
Wake lock.  You can definitely 
keep the device  awake when you 

01:11:45.637 --> 01:11:50.300
need some processing power in 
the  applications.  There is a 

01:11:50.301 --> 01:11:53.201
-- which is not that bad.  The  
full lock is performed from 

01:11:53.202 --> 01:11:56.973
device, the screen is off  and 
the user is usually actually 

01:11:56.974 --> 01:12:00.166
using the device, like,  playing
 a game or driving the car with 

01:12:00.167 --> 01:12:06.784
the screen or  watching some 
videos, and knows that he is 

01:12:06.785 --> 01:12:09.380
doing  something with the device
 and probably wasting the  

01:12:09.381 --> 01:12:13.015
battery.  So it's not a a high 
priority.  The priority  concern

01:12:13.321 --> 01:12:17.878
 is when the screen is off but 
the application is  still doing 

01:12:17.879 --> 01:12:22.002
something in the background.  
And sometimes,  this activity 

01:12:22.003 --> 01:12:29.237
can stuck and this wake lock can
 work for  a long time, 

01:12:29.238 --> 01:12:32.353
sometimes more than an hour.  
And when the  wake lock is stuck

01:12:32.878 --> 01:12:36.310
 for more than an hour, the 
behavior  inside the application

01:12:36.512 --> 01:12:41.168
 actually Android Vitals.
Again, if you head to the 

01:12:41.169 --> 01:12:43.757
specific section of the  
development console, you can see

01:12:44.669 --> 01:12:47.723
 a lot of statistics  where we 
show you how many

01:12:51.783 --> 01:12:54.290
 stuck wake locks you've had  in
 your application and the 

01:12:54.291 --> 01:12:59.502
particular Android version.   
The goal here is to have a wake 

01:12:59.503 --> 01:13:06.851
lock.  It's optimal from  our 
perspective.  And the wake lock 

01:13:06.852 --> 01:13:09.424
more than an hour,  then 
something definitely going wrong

01:13:10.327 --> 01:13:12.494
.
Why is this important?  We have 

01:13:12.495 --> 01:13:15.610
our own internal  study for 
devices inside Google, and we 

01:13:15.611 --> 01:13:24.997
have found out  that in 30% of 
cases when the users battery 

01:13:24.998 --> 01:13:33.165
charge and  lifetime value, 
lifetime of the device, -- so 

01:13:33.166 --> 01:13:41.435
keep an  eye on them and try to 
help users.

01:13:41.835 --> 01:13:44.629
Other thing when you can wake up
 the device in a  specific 

01:13:44.630 --> 01:13:47.334
period of time to perform some 
type of  correction.  Again, if 

01:13:47.335 --> 01:13:53.950
you do this more often, it will 
 drain battery more, and we look

01:13:54.362 --> 01:13:56.534
 at the battery behavior

01:13:59.925 --> 01:14:03.146
  four or more wake-ups per hour
.  If you do it ten times  or 

01:14:03.147 --> 01:14:06.243
more, it's something definitely 
to look after and  probably 

01:14:06.244 --> 01:14:09.678
increase the amount of wake-ups 
in this case.

01:14:10.082 --> 01:14:15.370
Again, the statistics that show 
you which specific  API the wake

01:14:15.876 --> 01:14:19.394
 up and how many times per hour.
  And the  worst-case scenario, 

01:14:19.395 --> 01:14:24.870
of course, is you have a wake-up
,  which then becomes stuck, 

01:14:24.871 --> 01:14:31.691
then it really means that the  
battery will be drained.  So 

01:14:31.692 --> 01:14:36.110
this is the main point to  avoid
 in terms of battery life.

01:14:36.543 --> 01:14:40.479
And the last thing but probably 
not the least is  rendering.  

01:14:40.480 --> 01:14:43.227
And as I said before, it's

01:14:47.046 --> 01:14:50.776
 generally fitting fitting.  We 
are tracking two major points 

01:14:50.777 --> 01:14:56.549
here.   There's a slow rendering
 and a slow rendering is when 50

01:14:56.556 --> 01:15:03.926
 50% of frames of the time 
greater than 60 milliseconds  

01:15:03.927 --> 01:15:08.778
and a frozen frame when a 
specific frame is 700  

01:15:08.779 --> 01:15:15.197
milliseconds or more.  And if 
you have this, again, you  go in

01:15:15.201 --> 01:15:19.221
 the console, and you will be 
able to see how fast  your UI is

01:15:21.271 --> 01:15:25.706
 rendered and.
In addition to the frozen flames

01:15:26.032 --> 01:15:33.914
, we will also  note the slow UI
.  When the UI spread, which has

01:15:34.626 --> 01:15:39.972
 a lot  of for processing 
activity goes, presume it should

01:15:40.390 --> 01:15:44.444
  increase the speed.  Again, 
this is something to look  for 

01:15:44.445 --> 01:15:52.592
and probably move this activity.
So using

01:15:55.158 --> 01:15:59.300
 troubleshoot the app issues and
 make it  more stable is one 

01:15:59.301 --> 01:16:01.365
thing particularly important now
 to  measure the

01:16:04.475 --> 01:16:08.838
 app in the Play store.  But 
there are other  components for 

01:16:08.839 --> 01:16:12.375
application quality, which are 
equally  important, and I'm 

01:16:12.376 --> 01:16:15.699
going to talk about them in the 
next  session.

01:16:15.922 --> 01:16:21.609
So what's a quality app?  First 
thing's first,  performance.  We

01:16:23.635 --> 01:16:28.721
 already model this discussion. 
 And  then there are features 

01:16:28.722 --> 01:16:34.307
that the users love.  There will
  be beautiful design which fill

01:16:34.613 --> 01:16:37.304
 guidelines and the  application
 should really focus on 

01:16:37.305 --> 01:16:41.219
supporting the latest  features 
and technologies.  This will 

01:16:41.220 --> 01:16:44.554
create a wonderful  experience 
for the users, and this will 

01:16:44.555 --> 01:16:49.459
make the users  love your 
applications more.

01:16:49.690 --> 01:16:52.361
First thing's first, the 
material design.  We have  been 

01:16:52.362 --> 01:16:55.149
speaking about material design 
for two or three  years already,

01:16:55.554 --> 01:17:00.392
 and in general, material design
 gets a  lot of quality not only

01:17:00.699 --> 01:17:03.898
 from Google itself but from  
independent designers all over 

01:17:03.899 --> 01:17:08.556
the world.  The materials  on 
how to implement material design

01:17:08.753 --> 01:17:10.774
 and how to

01:17:13.795 --> 01:17:16.385
  applications according to our 
guideline and you can  define 

01:17:16.386 --> 01:17:20.133
them.  Remember, that just using
 some of the  preview components

01:17:21.465 --> 01:17:27.980
, which are provided to you by  
material design is not enough 

01:17:27.981 --> 01:17:33.449
fully compliant.  Design  
property should design your 

01:17:33.450 --> 01:17:40.896
application from the ground  up 
using things.  And having some 

01:17:40.897 --> 01:17:46.263
universal patterns the  
applications Android platform 

01:17:46.264 --> 01:17:49.073
hearing familiar patterns  and 
elements in the application 

01:17:49.074 --> 01:17:52.775
design really helps our  users 
to be more engaged with the 

01:17:52.776 --> 01:17:57.916
application Android,  and it 
really helps them to start using

01:17:58.422 --> 01:18:04.008
 applications  faster.
Next thing, next big thing is 

01:18:04.009 --> 01:18:09.270
platform support.   First of all
, quality app.  You should 

01:18:09.271 --> 01:18:12.591
always check your  application's
 stability and performance 

01:18:12.592 --> 01:18:17.853
against the  latest professional
 system, and you should 

01:18:17.854 --> 01:18:23.197
definitely  use the latest 
available to build applications.

01:18:23.413 --> 01:18:26.621
  In  addition to that, a lot of
 other Android platforms out  

01:18:26.622 --> 01:18:31.490
there and the more of them 
support for your application.

01:18:32.943 --> 01:18:37.677
Remember that there are plenty 
of devices for  Android.  There 

01:18:37.678 --> 01:18:39.822
are wearables,

01:18:43.861 --> 01:18:48.705
 tablets, TVs.  Not all of  them
 of course is for your 

01:18:48.706 --> 01:18:56.437
application use case.  The  more
 considerable platform --

01:18:57.160 --> 01:19:00.703
For example, smart TVs.  When 
user is using your  application 

01:19:00.704 --> 01:19:05.763
not on a mobile device but on a 
smart TV,  the user tends to 

01:19:05.764 --> 01:19:09.472
spend a lot of time before a big
  screen and better engagement 

01:19:09.473 --> 01:19:12.673
for your entire application 
application.

01:19:13.086 --> 01:19:21.782
Wearables.  Wearables are mostly
, as in 75% of the  cases and if

01:19:21.785 --> 01:19:26.765
 the user is buying and using 
wearables is  definitely more 

01:19:26.766 --> 01:19:30.791
engaged and focused because 
already has  several devices, 

01:19:30.792 --> 01:19:33.499
which he uses frequently.  On 
the  wearable means the 

01:19:33.500 --> 01:19:37.323
application will stay not only 
on the  wearable device but on 

01:19:37.324 --> 01:19:40.113
the smartphone too, and the 
users  will return your 

01:19:40.114 --> 01:19:47.087
applications each time they go.
VR.  There are a lot of 

01:19:47.088 --> 01:19:54.763
buzzwords against VR, and  there
 are definitely a lot of use 

01:19:54.764 --> 01:20:01.912
cases right now.  Has  its own 
specific platforms, for example,

01:20:02.305 --> 01:20:09.112
 definitely have  longer but 
less frequent VR application.  

01:20:09.113 --> 01:20:16.121
There are a  lot of new ways to 
interact with the users within  

01:20:16.122 --> 01:20:21.221
virtual reality environment.
Next thing is monetizeation, and

01:20:21.224 --> 01:20:30.482
 we are definitely  believe that
 the user uses

01:20:31.317 --> 01:20:33.787
 your application for the  
content.

01:20:34.100 --> 01:20:38.080
So when you pass certain 
thresholds in

01:20:41.161 --> 01:20:43.161
 premium

01:20:44.922 --> 01:20:52.265
  quality generating.  And 
supporting of Android play for  

01:20:52.266 --> 01:20:58.261
scenarios in the context where 
Android Pay is available  and 

01:20:58.262 --> 01:21:01.057
one of the first companies in 
Europe which launched  in 

01:21:01.058 --> 01:21:08.791
support of Android Pay is also 
great, and you should  focus on 

01:21:08.792 --> 01:21:15.337
new.
Next thing as to think about the

01:21:17.347 --> 01:21:20.746
 easiness for  users.

01:21:24.387 --> 01:21:28.423
  Like user create accounts or 
sign into your  profile faster 

01:21:28.424 --> 01:21:37.091
and easier and focus on 
communicating  with the users 

01:21:37.092 --> 01:21:42.046
who leave feedback.  Keep your 
generating  above four.  So when

01:21:42.049 --> 01:21:44.832
 your application generating is 
four  or more, it basically 

01:21:44.833 --> 01:21:49.591
opens each and every door for  
featuring activities for a 

01:21:49.592 --> 01:21:55.460
collection inclusion.  So  this 
is important and users on their 

01:21:55.461 --> 01:21:58.969
own language in the  reviews 
sections will help you provide 

01:21:58.970 --> 01:22:02.559
great feedback  and communicate 
with them.

01:22:04.959 --> 01:22:09.320
The application itself some 
tools in Google Play  and data. 

01:22:09.321 --> 01:22:11.994
 First of all, there are a lot 
of things

01:22:19.105 --> 01:22:24.482
  Google Play listing.  Then you
 can use testing to see  what 

01:22:24.483 --> 01:22:31.972
works and what doesn't, and you 
can better your  apps in the 

01:22:31.973 --> 01:22:35.490
channel.
A lot of things to work on and 

01:22:35.491 --> 01:22:39.418
when you start to  think about 
your Appstore optimization, this

01:22:39.421 --> 01:22:46.248
 is your  number one destination
.  Title, icon, feature graphic,

01:22:46.666 --> 01:22:53.778
  videos and stuff like that, 
they also, they all can be  

01:22:53.779 --> 01:23:00.589
presented to a particular 
country.  Of course, those  

01:23:00.590 --> 01:23:03.366
wonders in terms of store.
And you see what works and what 

01:23:03.367 --> 01:23:11.539
doesn't, you can  use testing, 
run experiments in a specific 

01:23:11.540 --> 01:23:15.266
language and  understand what 
specific graphic screen or title

01:23:15.473 --> 01:23:19.461
 works  better for specific 
users.

01:23:20.831 --> 01:23:25.585
Why it's important?  Because 
it's one of the best  things to 

01:23:25.586 --> 01:23:33.079
improve.  17% is not the top 
number you can  get.  There are 

01:23:33.080 --> 01:23:38.342
some developers who get up to 30
% more  conversions of fully 

01:23:38.343 --> 01:23:43.496
optimizing Google Play.  And  
remember successful experiment 

01:23:43.497 --> 01:23:48.102
have a clear hypothesis  of 
testing, and you should have 

01:23:48.103 --> 01:23:54.261
some applications design  your 
testing.  They shouldn't be very

01:23:54.667 --> 01:23:57.583
 similar or results  won't be 
very --

01:23:57.910 --> 01:24:05.939
And the last session of our 
presentation is to  talk about 

01:24:05.940 --> 01:24:09.242
what you get from creating athe 
best quality  app.  There are 

01:24:09.243 --> 01:24:18.839
main things and main benefits to
 a  healthy app is search.  You 

01:24:18.840 --> 01:24:23.403
can get featured by our  Google 
Play team, and you could get 

01:24:23.404 --> 01:24:28.145
recognized and  receive certain 
awards from our colleagues.

01:24:28.352 --> 01:24:32.497
So first thing's first is 
visibility,  promotability, and 

01:24:32.498 --> 01:24:36.716
discoverability discoverability.
  The better your  generating is

01:24:37.746 --> 01:24:39.899
 and the better your

01:24:44.141 --> 01:24:51.859
 video, the more  graphics from 
the Google Play store.  Result 

01:24:51.860 --> 01:24:58.958
in  application engagement and 
Android, they impart in,  first 

01:24:58.959 --> 01:25:07.429
of all, in the search.  So when 
the user such as  applications 

01:25:07.430 --> 01:25:13.196
and having everything great in 
terms of  applications will help

01:25:13.199 --> 01:25:16.604
 you boost your application to 
the  top and get more traffic 

01:25:16.605 --> 01:25:19.617
and get more visible.  In  
addition to this, there are a 

01:25:19.618 --> 01:25:25.289
lot of different  collections 
inside Google Play store.  App 

01:25:25.290 --> 01:25:30.477
for work, app  for leisure, and 
stuff like that.  And around 90%

01:25:30.671 --> 01:25:35.919
 of  those collections, they're 
now automated.  So they are  

01:25:35.920 --> 01:25:41.419
graded by machine learning, 
which picks up the  application 

01:25:41.420 --> 01:25:49.765
and group them for the similar 
level theme  or similar.

01:25:50.379 --> 01:25:56.558
And those collections more 
usually have a better  quality. 

01:25:56.559 --> 01:26:00.880
 High quality apps before 
average quality apps  and 

01:26:00.881 --> 01:26:05.873
collections.  And, again, each 
and every Google Play  user see 

01:26:05.874 --> 01:26:10.314
a different Google Play home 
page, each time  they open the 

01:26:10.315 --> 01:26:14.358
Google Play store, and we try to
 show them  the contents that 

01:26:14.359 --> 01:26:18.410
they might be more interested in
.  So  having apps and more meta

01:26:18.728 --> 01:26:25.013
 collections, and those  
collections to the users more 

01:26:25.014 --> 01:26:29.144
for the use case.  And  this 
will get not just regular 

01:26:29.145 --> 01:26:34.801
installation and not just  
regular organic, but focused and

01:26:35.941 --> 01:26:39.661
 relevant graphic with  users 
who are more likely

01:26:42.863 --> 01:26:49.045
 applications.
And next thing is you can get 

01:26:49.046 --> 01:26:54.227
featured and be  included in the
 collections, which are curated 

01:26:54.228 --> 01:27:02.484
and  handpicked by our team, 
Google Play business development

01:27:02.812 --> 01:27:08.570
  and merchandising.  Each app 
is for featuring.  Goes  through

01:27:09.498 --> 01:27:13.848
 an extensive review from our 
team and analyzes  the quality 

01:27:13.849 --> 01:27:17.694
and analyzes its design and 
features and  provides them 

01:27:17.695 --> 01:27:20.253
feedback and provides them 
requirements  for

01:27:25.406 --> 01:27:29.376
 improvement.  When those 
requirements are met,  included 

01:27:29.377 --> 01:27:31.974
in some of our featured 
collection, for example example,

01:27:32.155 --> 01:27:39.483
 new and updated collections.  A
 lot of traffic  viewing.  Again

01:27:39.484 --> 01:27:43.213
, quality is always a factor for
 our  featuring requirements.  

01:27:43.214 --> 01:27:47.941
Now we have a lot of formal  
requirements, for example, your 

01:27:47.942 --> 01:27:52.891
ratings should be more  than 
four, you should have a good 

01:27:52.892 --> 01:27:56.848
generating in terms of  Android 
Vitals, so getting your app 

01:27:56.849 --> 01:28:00.920
updated is number  one.

01:28:04.184 --> 01:28:07.804
  Before getting --
Again, featuring is usually 

01:28:07.805 --> 01:28:13.503
really important for  developers
 and objects perspective.  So 

01:28:13.504 --> 01:28:20.918
you should get  featured and you
 can feel appreciated.  But the 

01:28:20.919 --> 01:28:27.975
traffic  you can get from a 
featuring is usually, the 

01:28:27.976 --> 01:28:31.369
traffic you  get organically 
from applications over the 

01:28:31.370 --> 01:28:35.317
course of  several months or 
several years of being 

01:28:35.318 --> 01:28:39.461
advertised in  search results 
including automated collections 

01:28:39.462 --> 01:28:45.895
is  generally better, bigger, 
and more than this one-time  

01:28:45.896 --> 01:28:49.304
featuring boost.  So working on 
a quality for featuring  is 

01:28:49.305 --> 01:28:55.391
great because it gets you 
visibility, but long-term  

01:28:55.392 --> 01:28:58.926
benefits of quality apps deliver
 better results over  time.

01:29:02.421 --> 01:29:10.500
And the last thing currently is 
you can get  specific awards in 

01:29:10.501 --> 01:29:14.038
Google Play.  Currently, we have
 two  types of awards and 

01:29:14.039 --> 01:29:16.039
recognitions

01:29:17.498 --> 01:29:21.664
.  First of all, done by  our 
colleagues in Google Play 

01:29:21.665 --> 01:29:24.000
merchandising, and

01:29:28.800 --> 01:29:34.138
 one app  gets buzz from social 
media which is new and hot, it 

01:29:34.139 --> 01:29:39.564
can  get featured as an 
application.  And there is 

01:29:39.565 --> 01:29:41.565
another

01:29:44.998 --> 01:29:51.491
  which we have launched just a 
few months ago, which  requires 

01:29:51.492 --> 01:29:56.878
-- showcases best Android apps 
on the platform,  which are the 

01:29:56.879 --> 01:30:01.946
best in terms of publication, 
design  feature, relyiability, 

01:30:01.947 --> 01:30:08.343
and user feedback.  So getting 
the  Android award is quite hard

01:30:08.756 --> 01:30:10.879
 in terms of effort and

01:30:18.125 --> 01:30:21.027
 what  you have to do.
But the applications, usually 

01:30:21.028 --> 01:30:24.945
the best Android  apps there are
.  And if you are looking 

01:30:24.946 --> 01:30:27.448
somewhere for  inspiration or if
 you are looking for best 

01:30:27.449 --> 01:30:32.427
practices,  just head out to the
 Android excellence portion of 

01:30:32.428 --> 01:30:36.218
the  Google Play store and check
 it out because definitely  

01:30:36.219 --> 01:30:41.682
applications, you can check, you
 can download, and you  can 

01:30:41.683 --> 01:30:47.589
probably reuse some of the -- in
 your own  applications.

01:30:47.780 --> 01:30:53.159
That's about all.  We'll have 
some office hours  later today. 

01:30:53.160 --> 01:30:56.895
 And if you have some additional
 questions  about how featuring 

01:30:56.896 --> 01:31:03.186
how Google Play works, how to 
get  featured, and how to 

01:31:03.187 --> 01:31:07.653
improve your application quality
,  please come in, and we can 

01:31:07.654 --> 01:31:09.124
discuss it.
Thank you.

01:31:09.125 --> 01:31:11.125
[Applause]

01:31:49.734 --> 01:31:51.734
for realtime captions...

01:31:56.009 --> 01:31:58.009
 test.  

01:39:19.973 --> 01:39:26.205
 testing testing.  This is a 
captioning test.  Please standby

01:39:26.206 --> 01:39:30.368
 for realtime captions.  The 
panel

01:39:48.523 --> 01:39:50.523
 Please standby...

01:46:44.495 --> 01:46:49.251
 Nandini, and I enable 
conversation between humans, 

01:46:49.252 --> 01:46:53.406
among businesses, and any 
combination in between, some of 

01:46:53.407 --> 01:46:55.555
which include some machines. 

01:46:59.648 --> 01:47:08.097
 series, developers? We just 
launched this as a teaser on 

01:47:08.098 --> 01:47:12.249
YouTube, but it's coming and you
 will hear all about that today.

01:47:12.250 --> 01:47:16.397
  But I want you to stop and 
take a picture in your mind 

01:47:16.398 --> 01:47:18.398
right now of why voice is

01:47:20.494 --> 01:47:24.680
 wonder what you're thinking.  
We're living in a time when 

01:47:24.681 --> 01:47:30.901
innovation is shifting our 
outlook so rapidly of our 

01:47:30.902 --> 01:47:32.902
future. 

01:47:34.981 --> 01:47:39.163
 It's worth taking a moment and 
figure out how different it can 

01:47:39.164 --> 01:47:43.366
be in a week's time, a month's 
time, and next year it will be a

01:47:45.429 --> 01:47:47.429
 different landscape than it is 
here. 

01:47:51.590 --> 01:47:57.898
 machines to speak on our 
behalf, to speak to us out loud 

01:47:57.899 --> 01:48:04.116
is so deep to our context as a 
culture and as human beings, it 

01:48:04.117 --> 01:48:06.180
makes us question where we are. 
 It makes us question where we 

01:48:06.181 --> 01:48:10.341
are with technology.  It really 
is putting us at the 

01:48:10.342 --> 01:48:14.499
intersection of technology and 
the human condition.  More than 

01:48:14.500 --> 01:48:20.736
ever before, we're actually 
confronting a 

01:48:24.811 --> 01:48:26.913
 have a lot more to say about 
that, but today's not the forum 

01:48:26.914 --> 01:48:31.115
for that.  Today we're just 
starting a conversation.  And 

01:48:31.116 --> 01:48:35.298
the hardest part about any 
conversation is listening.  So 

01:48:35.299 --> 01:48:39.450
we want you to know, developers,
 designers, businesses, we've 

01:48:39.451 --> 01:48:45.709
heard you.  We've seen the 
feedback from I/O and 

01:48:45.710 --> 01:48:51.929
conferences like this is the 
most valuable part of the 

01:48:51.930 --> 01:48:56.087
experience is interacting with 
other Googlers and those 

01:48:56.088 --> 01:48:58.088
creating

01:49:00.191 --> 01:49:02.191
 to create a different feedback 
loop for

01:49:04.375 --> 01:49:06.493
 helping you understand just how
 to get your arms around this 

01:49:06.494 --> 01:49:10.627
interface, and how you 
supplement that with other 

01:49:10.628 --> 01:49:12.628
elements like visuals. 

01:49:14.727 --> 01:49:18.895
 have to work with, how to 
create your landscape, how to 

01:49:18.896 --> 01:49:20.969
build your world for your users 
in

01:49:25.064 --> 01:49:31.314
 So in the first season, we just
 wrapped filming.  We have six 

01:49:31.315 --> 01:49:35.462
episodes.  We're going to have 
things like greetings and 

01:49:37.550 --> 01:49:39.633
good-byes.  How do you start and
 end a conversation.  How do you

01:49:39.634 --> 01:49:45.871
 identify users and authenticate
 them.  And, how do you make 

01:49:45.872 --> 01:49:50.031
money at this? Transactions are 
a big part.  We will show you 

01:49:50.032 --> 01:49:54.208
how to create custom voices to 
brand your experiences.  What 

01:49:54.209 --> 01:50:00.429
does it take to create character
 and persona? And also, what are

01:50:00.430 --> 01:50:02.430
 sounds involved

01:50:04.515 --> 01:50:10.772
 landscaping you can create in 
all of this that's an entirely 

01:50:10.773 --> 01:50:19.079
new world that will create 
gateways.  We will explore 

01:50:19.080 --> 01:50:21.161
deeper concepts and feature and 
highlight examples from the 

01:50:23.236 --> 01:50:25.236
eco-system.  We want to showcase
 what good looks

01:50:27.313 --> 01:50:31.493
 out there and what kind of 
people it takes to make this 

01:50:31.494 --> 01:50:35.642
work.  And then on each episode,
 we'll always feature guests 

01:50:35.643 --> 01:50:39.799
that will help us dig a little 
deeper, and they will be people 

01:50:39.800 --> 01:50:41.800
from the community. 

01:50:43.890 --> 01:50:45.980
 Sometimes they'll be Googlers 
and a lot of

01:51:04.185 --> 01:51:10.445
 I'm going to dance.  So we're 
going to do a little live show 

01:51:10.446 --> 01:51:14.595
today to talk a little bit about
 what this means and hopefully 

01:51:14.596 --> 01:51:18.768
get a little bit of insight.  
And we'll actually not answer 

01:51:18.769 --> 01:51:22.916
all your questions.  But we have
 a few questions that I've 

01:51:22.917 --> 01:51:27.073
gathered from social media and 
from our advocacy work that 

01:51:27.074 --> 01:51:31.225
we've done in that space.  To 
start off, I want to introduce 

01:51:31.226 --> 01:51:37.467
our panel.  We have, first, 
thrilled to have this great set 

01:51:37.468 --> 01:51:41.628
of panelists here that I 
personally selected because I 

01:51:41.629 --> 01:51:45.784
feel like they're most 
representative of where people 

01:51:45.785 --> 01:51:49.954
who have come at this and 
pivoted to this field from other

01:51:52.051 --> 01:51:56.227
 areas to give us some insight 
into their journey of how they 

01:51:56.228 --> 01:51:58.304
got here.  I think there are a 
lot of experts in the field, but

01:52:00.387 --> 01:52:04.541
 very few that are considered 
experts.  But there is just this

01:52:04.542 --> 01:52:10.771
 tapped in muscle that you don't
 realize we have.  That's what 

01:52:10.772 --> 01:52:14.912
I'm hoping you can get out of 
this today.  We'll start by 

01:52:14.913 --> 01:52:16.992
first we have Marc Paulina, who

01:52:21.101 --> 01:52:25.255
 together with Peter Hobson have
 created a new methodology and 

01:52:25.256 --> 01:52:31.505
interactive design.  To give you
 an idea on how we're really 

01:52:31.506 --> 01:52:33.579
taking the audience and building
 with the audience and viewers 

01:52:33.580 --> 01:52:37.727
in mind, we built this panel 
also directly from feedback from

01:52:37.728 --> 01:52:43.926
 you guys.  For example, Marc 
just ran a sprint with peter 

01:52:43.927 --> 01:52:46.005
with a small group across the 
street with this new 

01:52:48.074 --> 01:52:50.153
methodology, but it has to be 
done in a small scale.  We want 

01:52:50.154 --> 01:52:54.294
to scale that big, so we're 
going to show it on camera so 

01:52:54.295 --> 01:52:56.295
you can

01:52:58.385 --> 01:53:00.512
 Kimberly Harvey, who has

01:53:04.634 --> 01:53:06.634
 partnered

01:53:08.780 --> 01:53:12.990
 panel is a direct question from
 the GDD community. 

01:53:17.074 --> 01:53:19.074
 Research expert

01:53:23.175 --> 01:53:25.252
 asked for more representatives 
from UX

01:53:29.474 --> 01:53:35.759
 And if you don't already know 
him, Sachit has found the line 

01:53:35.760 --> 01:53:41.989
between design and engineering. 
 I credit him and his team for 

01:53:41.990 --> 01:53:46.135
pulling me out of my shell where
 I was working and doing more 

01:53:46.136 --> 01:53:48.213
advocacy work. 

01:53:52.334 --> 01:53:58.612
 example is the G plus 
community, we reached out to 

01:53:58.613 --> 01:54:04.849
David Wang, who's going to be on
 one of our very first episodes 

01:54:04.850 --> 01:54:06.850
talking about that from the 
product

01:54:08.944 --> 01:54:11.035
 management team.  These are all
 advocates for you, and we're 

01:54:11.036 --> 01:54:13.110
excited to get into some 
questions.  

01:54:17.186 --> 01:54:19.303
so, Sachit, let's start with 
you.  Voice.  What's all the 

01:54:19.304 --> 01:54:21.304
noise

01:54:23.416 --> 01:54:25.416
 for having me on the 

01:54:29.593 --> 01:54:33.776
 an introduction, I'm an 
engineer working mostly on 

01:54:33.777 --> 01:54:37.932
developer tooling.  I was 
working on the living room team 

01:54:37.933 --> 01:54:40.041
before on Android TV and cast, 
and Google Home became part of 

01:54:40.042 --> 01:54:46.286
the living room, and that's how 
I got sucked into this.  About a

01:54:46.287 --> 01:54:52.496
 year ago, Nandini and I were 
working on some of the first 

01:54:52.497 --> 01:54:56.644
samples.  If you ever have the 
chance to help with app 

01:54:58.715 --> 01:55:00.803
rebuilding, she has an 
extraordinary talent for the

01:55:06.980 --> 01:55:09.087
 get back to your question about
 what's all this noise about? I 

01:55:09.088 --> 01:55:15.291
think that this noise that we're
 hearing is the low, low hum of 

01:55:15.292 --> 01:55:21.535
the Sci-fi promise about voice 
recognition.  We are at very, 

01:55:23.617 --> 01:55:29.840
very, very early stages of the 
next motive interaction between 

01:55:29.841 --> 01:55:34.011
us and machines.  We've dreamt 
about it for days and it's 

01:55:34.012 --> 01:55:38.165
finally happening.  But it's 
still a little rough.  The 

01:55:40.244 --> 01:55:42.333
interactions are frustrating 
sometimes.  But listen through 

01:55:42.334 --> 01:55:48.571
the noise for the signal of the 
magical moments happening with 

01:55:48.572 --> 01:55:50.660
machines.  We will be talking 
about these days years from now 

01:55:50.661 --> 01:55:52.725
when it's working as they

01:55:58.869 --> 01:56:00.986
 What's all the noise about?

01:56:07.133 --> 01:56:11.342
 what is exciting about it is I 
feel like we're getting closer 

01:56:11.343 --> 01:56:15.513
and closer to a direct thought 
download.  I studied 

01:56:15.514 --> 01:56:17.582
communication and cross cultural
 communication

01:56:21.683 --> 01:56:25.870
 lot of different methods of 
communicating.  Some may be 

01:56:25.871 --> 01:56:30.030
watching on video, using 
gestures, words, systems of 

01:56:30.031 --> 01:56:32.104
writing are all around the 
world.  I feel like having 

01:56:32.105 --> 01:56:36.262
humans interact in a way that's 
been natural, because that's one

01:56:36.263 --> 01:56:40.396
 of the first skills that we 
learn as babies can kind of get 

01:56:40.397 --> 01:56:44.569
rid of some of the challenges we
 have, can get rid of some of 

01:56:44.570 --> 01:56:48.728
the challenges we have

01:56:52.838 --> 01:56:57.043
Marc, you've been a designer for
 a long time.  You started in 

01:56:57.044 --> 01:57:01.194
voice, actually way before we 
had the Google Assistant.  What

01:57:05.325 --> 01:57:07.444
 an interesting time at the 
moment.  Talking about the 

01:57:07.445 --> 01:57:13.683
journey that we've had, I wasn't
 a voice designer before I 

01:57:13.684 --> 01:57:22.026
started working on voice actions
 at Google.  I was working on 

01:57:22.027 --> 01:57:26.176
interactions in mobile, 
automotive and TVs.  Voice, for 

01:57:26.177 --> 01:57:30.324
me, was quite a stunning 
journey.  It was so different 

01:57:30.325 --> 01:57:34.454
than what I was used to.  For 
me, it's been really 

01:57:34.455 --> 01:57:38.605
enlightening thinking about 
voice and conversation and 

01:57:38.606 --> 01:57:44.851
natural user interfaces.  And 
how there's such an emergence of

01:57:46.918 --> 01:57:55.220
 AI, internet of things, 
robotics and so on.  So we've 

01:57:55.221 --> 01:58:01.459
got all of these natural usage 
bases that set people's 

01:58:01.460 --> 01:58:05.630
expectations so much higher than
 we've had before.  So, as a 

01:58:05.631 --> 01:58:09.774
designer, it's been exciting to 
try and create the new design 

01:58:09.775 --> 01:58:13.894
methodologies where we can 
understand people a lot more and

01:58:13.895 --> 01:58:18.051
 try to meet the expectations.  
It should just work.  But right 

01:58:18.052 --> 01:58:22.198
now with the technology how it 
is, there's a lot of really 

01:58:22.199 --> 01:58:24.199
interesting design

01:58:26.278 --> 01:58:28.388
 you know, that there is some 
kind of forgiveness there.  

01:58:28.389 --> 01:58:32.539
People are at this point where 
they're like, okay, we get that 

01:58:32.540 --> 01:58:36.694
it doesn't work perfectly all 
the time.  And it's great to see

01:58:36.695 --> 01:58:40.864
 that people are working on 
that, but, it's like, people get

01:58:40.865 --> 01:58:47.083
 the possibility, finally, which
 is so exciting.  Let's start.  

01:58:47.084 --> 01:58:53.304
I have a few questions.  I kind 
of pulled some from online and 

01:58:53.305 --> 01:58:57.447
others from asking around at the
 conference.  We do 

01:58:59.519 --> 01:59:03.671
user-centered research, very not
 last minute at all.  This one 

01:59:03.672 --> 01:59:07.812
comes from Twitter.  Is the 
Google Assistant

01:59:11.920 --> 01:59:16.117
Well, the first thing I would 
ask, Bob, is why do you think it

01:59:16.118 --> 01:59:20.278
 is a Girl Scout? What lends 
itself to that stereotype that 

01:59:20.279 --> 01:59:22.279
you

01:59:24.384 --> 01:59:28.581
 research.  But to answer the 
question, I would say that the 

01:59:28.582 --> 01:59:32.724
Assistant is not a girl scout, 
but it can facilitate 

01:59:32.725 --> 01:59:34.725
relationships like girl scouts. 

01:59:36.806 --> 01:59:38.908
 itself with personality, makes 
sure that the interactions we're

01:59:41.004 --> 01:59:43.071
 designing are on par with that 
personality, make sure that the 

01:59:43.072 --> 01:59:45.150
wording is right, and shows 
different parts of the

01:59:49.244 --> 01:59:53.417
 And the head of the doodle and 
personality team has a great 

01:59:53.418 --> 01:59:55.495
analogy.  You ask personality 
questions to poke at things and 

01:59:55.496 --> 01:59:59.705
ask it things that you can know 
what to expect an answer 

02:00:03.791 --> 02:00:05.908
 that.  It's a way of 
establishing trust.  So when you

02:00:05.909 --> 02:00:07.980
 establish trust with your 
neighbor, for example, you might

02:00:10.056 --> 02:00:16.294
 borrow a cup of sugar.  So 
grant says borrow a cup of sugar

02:00:16.295 --> 02:00:20.434
 before you ask for the lawn 
mower.  So how do you write 

02:00:20.435 --> 02:00:22.503
personality questions that are 
just about the character that 

02:00:22.504 --> 02:00:26.676
you're interacting with as 
opposed to the deeper 

02:00:28.773 --> 02:00:30.847
back-and-forth interaction about
 whatever it is the task that 

02:00:30.848 --> 02:00:32.848
you want to 

02:00:34.963 --> 02:00:36.963
 a great question. 

02:00:39.090 --> 02:00:43.300
 zinger via LinkedIn, probably 
for Sachit and maybe the others 

02:00:43.301 --> 02:00:47.515
the pipe in.  There's a common 
sentiment among developers who 

02:00:47.516 --> 02:00:53.743
are leery about starting project
 development in newer tools as 

02:00:53.744 --> 02:00:57.893
they have been burned in the 
past by abandonment

02:01:01.983 --> 02:01:06.153
 the community-based nature of 
design, can developers find 

02:01:06.154 --> 02:01:08.219
assurances that Google 
recognizes this pillar and won't

02:01:08.220 --> 02:01:14.439
 be abandoning support for the 
assistant SDK, or other related 

02:01:16.514 --> 02:01:20.670
projects? This is amazing.  To 
allow innovators create new 

02:01:20.671 --> 02:01:24.835
products and found businesses 
upon.  Well, I will say one 

02:01:24.836 --> 02:01:29.006
thing.  If we are doing that, 
none of us have any jobs.  So 

02:01:29.007 --> 02:01:31.007
we're here. 

02:01:33.104 --> 02:01:37.284
 from a developer perspective, 
you guys work with tools and 

02:01:37.285 --> 02:01:39.285
APIs, so what would you

02:01:41.416 --> 02:01:43.416
First, I would empathize with 
the

02:01:45.545 --> 02:01:49.722
 It was Brandon Hunter from 
LinkedIn who asked the

02:01:53.816 --> 02:01:55.929
 that before, and I certainly 
wouldn't want to inflict that on

02:01:55.930 --> 02:02:00.102
 anyone else.  I would say on 
this space that I think a little

02:02:00.103 --> 02:02:06.319
 bit extra of adventurous 
attitude is actually called for 

02:02:06.320 --> 02:02:08.320
here from the developers' point

02:02:10.406 --> 02:02:14.571
 terms of picking up knowledge 
around APIs and terminology and 

02:02:14.572 --> 02:02:16.682
figuring out what the design 
looks like for these types of 

02:02:16.683 --> 02:02:22.933
things will pay off 
exponentially in the future.  To

02:02:22.934 --> 02:02:27.090
 directly answer the question in
 terms of Google's investment in

02:02:27.091 --> 02:02:31.230
 the space, I think it's clear 
using the list of services and 

02:02:31.231 --> 02:02:35.389
APIs that the person asks the 
question, it's very clear that 

02:02:35.390 --> 02:02:39.537
we're trying to push an entier 
suite of products on developers 

02:02:39.538 --> 02:02:43.840
here.  It gives the idea that 
Google is trying to push heavily

02:02:43.841 --> 02:02:48.001
 into the space.  Internally, we
 are seeing this as sort of the 

02:02:48.002 --> 02:02:52.162
next step.  And this also is 
shown through the consumer side.

02:02:56.259 --> 02:02:58.390
 Assistant has a company 
initiative that reflects the 

02:02:58.391 --> 02:03:02.540
developer APIs and services that
 we're releasing. 

02:03:06.621 --> 02:03:08.702
 What's clear is if you look at 
the scope of what Google is 

02:03:08.703 --> 02:03:10.703
actually putting out there that 
we

02:03:12.794 --> 02:03:16.933
 see this as the next step for 
users and developer s and we 

02:03:16.934 --> 02:03:19.036
will be supporting this going 
forward. 

02:03:23.146 --> 02:03:27.338
 platforms going away.  Clearly 
the platform as a whole, the 

02:03:27.339 --> 02:03:29.404
conversational push as a whole 
isn't going anywhere, and we're 

02:03:29.405 --> 02:03:31.405
sticking to

02:03:33.497 --> 02:03:35.607
 Thank you.  Okay.  Let's pivot 
to design.  Marc, can you talk 

02:03:35.608 --> 02:03:37.674
about some of the design methods
 you have used

02:03:41.761 --> 02:03:48.048
So, as I said, learning the 
design process, being new to the

02:03:48.049 --> 02:03:50.119
 field is quite a challenge. 

02:03:54.214 --> 02:03:58.393
 that we used before for other 
experiences, for example, 

02:03:58.394 --> 02:04:02.547
designing apps, websites, and so
 on, for 

02:04:06.642 --> 02:04:10.823
 learning new methodologies.  So
 I, personally, take a lot from 

02:04:10.824 --> 02:04:12.910
service design theory.  One of 
the principles of service

02:04:16.996 --> 02:04:19.073
 design is that we 

02:04:23.145 --> 02:04:27.294
democratize the design process 
to come up with powerful 

02:04:27.295 --> 02:04:29.366
experiences and user-centered 
designs.  The way to do that as 

02:04:29.367 --> 02:04:33.518
a designer or researcher or 
anyone on the product team just 

02:04:33.519 --> 02:04:39.732
to be aware of who the user is 
and what the user needs.  And 

02:04:39.733 --> 02:04:41.733
keep asking the question, what's

02:04:43.840 --> 02:04:45.840
 their goal? What are their

02:04:47.973 --> 02:04:50.073
 you understand about the user 
the more interesting your design

02:04:50.074 --> 02:04:52.074
 will 

02:04:54.153 --> 02:04:58.335
 entire expectations of the 
natural user interfaces than 

02:04:58.336 --> 02:05:02.497
other types of interface.  And 
also, best practices for 

02:05:02.498 --> 02:05:08.718
conversation design.  So one 
principle we have over 

02:05:08.719 --> 02:05:10.804
conversation design is about 
failure.  With technology the 

02:05:10.805 --> 02:05:12.882
way it currently is is there can
 be a lot

02:05:16.996 --> 02:05:23.283
language, there's a lot of 
ambiguity.  We focus on this a 

02:05:23.284 --> 02:05:25.284
lot.  The happy

02:05:27.373 --> 02:05:31.529
 part is fairly straightforward,
 but the unhappy part is quite 

02:05:31.530 --> 02:05:39.820
complex.  There's also 
prototyping, so that's another 

02:05:39.821 --> 02:05:41.821
part is being able to validate

02:05:48.038 --> 02:05:56.397
 There's a reference in there 
somewhere.  Happy little trees, 

02:05:56.398 --> 02:06:04.716
the Bob Ross method.  So we can 
all talk, speak, gesture.  It's 

02:06:04.717 --> 02:06:08.848
the interface we learn first and
 know best.  We don't need help 

02:06:08.849 --> 02:06:10.931
understanding that.  So why do 
we need UX

02:06:15.040 --> 02:06:17.150
 UX research? Just because we 
know how to speak doesn't mean 

02:06:17.151 --> 02:06:23.373
we know the intention of what's 
going on.  Backstage, I was 

02:06:23.374 --> 02:06:25.441
saying let's say Marc was 
outside in the center of the 

02:06:25.442 --> 02:06:29.592
hall, and I was talking to 
someone and I said what does 

02:06:29.593 --> 02:06:33.759
Marc look like.  They would 
describe him in a certain way, 

02:06:33.760 --> 02:06:39.988
he's wearing white shoes.  But 
if Marc has been out for the flu

02:06:39.989 --> 02:06:42.063
 for the week and I turned to my
 boss and asked what Marc

02:06:46.141 --> 02:06:48.211
 looked like, he would say he 
looks a little better than last

02:06:52.327 --> 02:06:54.446
 completely different answer 
based on context.  If we're 

02:06:54.447 --> 02:06:56.545
designing an experience, we 
don't know until

02:07:00.637 --> 02:07:04.781
 we actually see it in motion, 
whether we iron out all of the 

02:07:04.782 --> 02:07:08.934
kinks and whether there are 
surprising behaviors that are

02:07:13.003 --> 02:07:15.003
 emerging

02:07:17.118 --> 02:07:19.118
 make sure you have everything 
covered. 

02:07:21.259 --> 02:07:23.379
 other disciplines as you get 
into this, but just from a 

02:07:23.380 --> 02:07:29.606
developer perspective, getting 
the ramp up into this, like what

02:07:29.607 --> 02:07:31.676
 can a developer bring into the

02:07:35.750 --> 02:07:39.952
 the great thing about our 
platform in particular is it's 

02:07:39.953 --> 02:07:44.114
mostly driven through the cloud.
  What that means is for 

02:07:44.115 --> 02:07:48.270
developers who have already been
 developing in the cloud, web 

02:07:48.271 --> 02:07:50.346
apps or APIs they have been 
building, they will bring all of

02:07:52.409 --> 02:07:56.565
 that experience in.  And the 
tools they use to provide to 

02:07:56.566 --> 02:07:58.648
abstract some of the harder 
problems like the natural 

02:07:58.649 --> 02:08:04.873
language understanding, those 
tools are fairly easy to 

02:08:04.874 --> 02:08:06.951
understand for anybody.  So 
first, learning that is fairly 

02:08:06.952 --> 02:08:11.096
simple.  There's a low barrier 
to entry.  And with your 

02:08:11.097 --> 02:08:13.172
existing cloud web knowledge and
 using basically efficient 

02:08:13.173 --> 02:08:17.320
coding practices around things 
like string manipulation, those 

02:08:17.321 --> 02:08:21.476
kind of things, you can build 
that pretty effectively on our 

02:08:21.477 --> 02:08:25.642
platform.  One of the things I'm
 actually really looking forward

02:08:25.643 --> 02:08:29.782
 to, hopefully that I want to 
see from the community is more 

02:08:29.783 --> 02:08:33.945
tooling and frameworks similar 
to frameworks on other platforms

02:08:36.014 --> 02:08:40.162
 like web apps if you just want 
to build a UI.  So I'm curious 

02:08:40.163 --> 02:08:44.319
to see how people will build 
with reference to voice

02:08:48.419 --> 02:08:50.531
 you're early in the process, 
you want to start prototyping.  

02:08:50.532 --> 02:08:52.611
So Marc, you have

02:08:56.699 --> 02:08:58.699
 suggestions on how to

02:09:00.848 --> 02:09:02.948
 I think about prototype, 
looking at something that I can 

02:09:02.949 --> 02:09:07.086
use early in the design process 
that I can learn quickly, and 

02:09:07.087 --> 02:09:13.333
it's really quickly.  So I think
 it's really important that we 

02:09:13.334 --> 02:09:17.530
invest in prototyping, 
especially if we don't have 

02:09:17.531 --> 02:09:21.680
years of experience working on 
voice user interfaces, and that 

02:09:21.681 --> 02:09:23.681
we're really learning on

02:09:25.789 --> 02:09:29.998
 methodology that we've used 
with some success designing 

02:09:29.999 --> 02:09:36.248
conversational UIs at Google, 
such as Wizard Of Oz 

02:09:36.249 --> 02:09:38.335
prototyping.  The idea is you 
remotely control the device that

02:09:38.336 --> 02:09:44.574
 the participant is using in a 
study environment.  But they 

02:09:44.575 --> 02:09:46.646
think they're speaking to the 
assistant, but

02:09:50.733 --> 02:09:52.733
 really they're speaking to me 
as the puppet 

02:09:56.871 --> 02:09:58.871
 what they believe is the 

02:10:00.994 --> 02:10:03.063
end-user experience, but there's
 no AI or cloud, it's me on the 

02:10:03.064 --> 02:10:05.064
other

02:10:07.158 --> 02:10:09.158
 gets in terms of

02:10:11.306 --> 02:10:13.439
 can go anywhere.  You never 
really know.  There's no set 

02:10:15.534 --> 02:10:17.617
path.  To feel natural, you need
 to be able to pivot in 

02:10:21.728 --> 02:10:25.890
 for that, the only person who 
can do that is a real person 

02:10:25.891 --> 02:10:32.113
doing that in realtime.  Wizard 
of Oz is powerful.  It can be as

02:10:34.198 --> 02:10:38.337
 simple as having a blue tooth 
speaker, audio files that you're

02:10:38.338 --> 02:10:40.417
 playing as they respond.  It's 
pretty good. 

02:10:44.497 --> 02:10:48.703
 early on in the design process 
is saying out loud, role 

02:10:48.704 --> 02:10:52.857
playing.  And Google design 
sprints, where I've got the 

02:10:52.858 --> 02:10:59.088
whole product time designing the
 conversations.  We actually do 

02:10:59.089 --> 02:11:03.253
investigative rehearsal, which 
is a methodology created by Adam

02:11:03.254 --> 02:11:09.470
 Lawrence.  And it's basically 
the idea is that you rehearse 

02:11:09.471 --> 02:11:11.545
the conversation in realtime, 
and then you investigate that 

02:11:11.546 --> 02:11:13.630
conversation, and you ask 
questions about it. 

02:11:17.741 --> 02:11:24.009
 most scrappiest, most low 
stability prototype you can 

02:11:24.010 --> 02:11:28.149
imagine, but incredibly powerful
 for the first draft of the 

02:11:28.150 --> 02:11:30.224
conversation, before you invest 
in any coded 

02:11:34.306 --> 02:11:36.414
 mention that you, for those 
sprints that you just talked 

02:11:36.415 --> 02:11:40.576
about, that you have the whole 
product team there.  What you're

02:11:40.577 --> 02:11:44.750
 facilitating is a conversation,
 to build a conversation, and it

02:11:44.751 --> 02:11:46.827
 creates better conversations in
 terms of the actual

02:11:50.943 --> 02:11:52.943
 whole product team there.  It 

02:11:55.510 --> 02:11:57.510
democratizes the 

02:11:59.604 --> 02:12:03.785
 user requirements, everyone 
understands their goal and maybe

02:12:03.786 --> 02:12:07.944
 business goals as well.  And 
everyone's thinking through that

02:12:07.945 --> 02:12:12.102
 at the same time and trying the
 stuff out.  It really is a 

02:12:12.103 --> 02:12:14.103
platform approach

02:12:16.189 --> 02:12:20.394
fact, that's probably a good 
place to close and wrap up and 

02:12:20.395 --> 02:12:24.534
to get everyone thinking about, 
you know -- I've been doing this

02:12:24.535 --> 02:12:28.682
 for a really, really long time.
  So hopefully, if you feel like

02:12:28.683 --> 02:12:32.851
 we raised more questions in 
this panel than answers, then 

02:12:32.852 --> 02:12:39.070
good.  Because there's a lot to 
talk about.  As I said at the 

02:12:39.071 --> 02:12:45.329
beginning, this is just the 
start of the conversation, there

02:12:47.403 --> 02:12:49.403
 are worldwide 

02:12:51.519 --> 02:12:57.792
 one of them, and it's a much 
larger one.  So a conversation 

02:12:57.793 --> 02:13:01.936
about the future of technology 
and, you know, where we are 

02:13:01.937 --> 02:13:04.027
today and where we're going from
 here is going to take a new 

02:13:04.028 --> 02:13:06.103
kind of eco-system.  This is 
called a conversation

02:13:10.198 --> 02:13:14.395
 help, we need to build this new
 eco-system.  We can actually, 

02:13:14.396 --> 02:13:20.615
at this point, take a quantum 
leap past this AI first world.  

02:13:20.616 --> 02:13:24.774
Words really matter, right? It's
 quite unfortunate that we call 

02:13:24.775 --> 02:13:30.990
it artificial at all when we 
need things like authentic and 

02:13:30.991 --> 02:13:35.136
advanced intelligence more than 
ever.  We are all starving to 

02:13:35.137 --> 02:13:43.427
amplify our own intelligence, so
 maybe amplified intelligence.  

02:13:45.507 --> 02:13:47.579
#fixtheglitch.  It doesn't 
matter, users come first.  If we

02:13:49.662 --> 02:13:51.735
 build a world using a 
people-first creative approach 

02:13:51.736 --> 02:13:55.891
to building solutions that 
people can use in their daily 

02:13:55.892 --> 02:14:00.035
lives, it's more than just 
talking and getting answers 

02:14:00.036 --> 02:14:02.107
anymore.  People want insight, 
and they actually want to be 

02:14:02.108 --> 02:14:06.260
able to do things in their 
world.  We wand to find those 

02:14:06.261 --> 02:14:08.261
micromoments that are

02:14:10.355 --> 02:14:12.485
 there's another A-word.  We 
just need the whole alphabet.  

02:14:16.579 --> 02:14:18.702
 disciplines at the table.  
Diverse voices, diverse 

02:14:18.703 --> 02:14:22.843
approaches, diverse thinking.  
This is really a time when, you 

02:14:22.844 --> 02:14:27.012
know, it's like I sit at the 
intersection of science and 

02:14:27.013 --> 02:14:33.222
culture, human interaction, 
human solution to a global 

02:14:33.223 --> 02:14:37.378
problem.  Like, we built these 
machines.  Let's make them work 

02:14:37.379 --> 02:14:41.552
on our behalf to make them 
connect more to each other and 

02:14:41.553 --> 02:14:43.627
the world and the things we want
 to get done.  I have been doing

02:14:43.628 --> 02:14:47.788
 this a long time, working with 
this technology.  But really, 

02:14:47.789 --> 02:14:51.934
it's my personal mission to give
 voice to others, and to help 

02:14:51.935 --> 02:14:56.107
create a culture that we can 
create experiences that 

02:14:56.108 --> 02:15:00.255
illustrate a shared vision of 
our future.  We need to 

02:15:00.256 --> 02:15:04.420
collectively recognize that good
 means going beyond don't be 

02:15:04.421 --> 02:15:08.569
evil or do what's right, but to 
create experiences to show how 

02:15:08.570 --> 02:15:10.690
it's done.  And so hopefully 
with this series, you want to 

02:15:10.691 --> 02:15:16.909
show what that looks like.  You 
want partner experiences to 

02:15:16.910 --> 02:15:21.058
showcase what you're creating 
for your users.  And you know, 

02:15:21.059 --> 02:15:25.206
for the common good of users 
everywhere.  So, you know, we 

02:15:25.207 --> 02:15:31.459
want to give insight to the 
kinds of people inside Google 

02:15:31.460 --> 02:15:35.617
who are building this, and also 
changing the lives and future 

02:15:35.618 --> 02:15:41.855
and technology, and also, you 
know, this is the power of 

02:15:41.856 --> 02:15:43.945
spoken language.  What kinds of 
people does it take to change 

02:15:43.946 --> 02:15:48.109
the landscape, you know? It's a 
disruptive environment.  It's a

02:15:52.222 --> 02:15:56.417
 living our legacies in 
realtime.  What are you going to

02:15:56.418 --> 02:15:58.501
 be known for? What kind of 
world are you creating for your 

02:15:58.502 --> 02:16:00.502
kids?

02:16:02.594 --> 02:16:06.805
 We're going to create some 
amazing things, and I can't wait

02:16:06.806 --> 02:16:08.873
 to see what you create.  Thank 
you so much to our panel and 

02:16:08.874 --> 02:16:10.959
thank you to the audience for 
being part of this exciting, 

02:16:10.960 --> 02:16:12.960
creative moment for us.  Thank 
you. 

03:20:16.704 --> 03:20:20.017
&gt;&gt; Good afternoon, all, and for 
those following  along on 

03:20:20.018 --> 03:20:24.048
YouTube at home, good morning, 
good afternoon,  good evening.  

03:20:24.049 --> 03:20:29.012
I'm Brett Morgan, I work on the 
developer  team for Google Maps 

03:20:29.013 --> 03:20:32.253
based in Sydney, Australia.  
That  means I do things like 

03:20:32.254 --> 03:20:38.435
write sample apps, write  
tutorials, Codelabs, and all of 

03:20:38.436 --> 03:20:43.172
that sort of things.  As  I said
, I look after Google Maps APIs.

03:20:43.484 --> 03:20:48.328
  Google Maps APIs  is the 
oldest Google Maps service has. 

03:20:48.329 --> 03:20:51.238
 Over ten years  old.  We have a
 lot of APIs.  We have a lot of 

03:20:51.239 --> 03:20:52.881
 interesting functionality that 
you can use in your  

03:20:52.882 --> 03:20:55.775
applications.  One of the things
 that we hear from  developers, 

03:20:55.776 --> 03:20:59.993
like yourself, is that that's 
great.  You've  got all of these

03:21:00.393 --> 03:21:02.968
 APIs, you've got this wonderful
  documentation, it tells you 

03:21:02.969 --> 03:21:05.459
what the arguments are, it  
tells you what the result is.  

03:21:05.460 --> 03:21:09.060
But how do I as a  developer 
take all of these APIs, glue 

03:21:09.061 --> 03:21:13.897
them together to  create 
something that solves a problem?

03:21:14.828 --> 03:21:19.154
  So the JA  developers relation
 team in Sydney came up with an 

03:21:19.155 --> 03:21:21.429
idea  of making solutions to 
show

03:21:21.430 --> 03:21:24.822
  you end to end how to solve  a
 problem.

03:21:29.444 --> 03:21:32.756
  So I just wanted to give you a
 little bit of  history here.  

03:21:32.757 --> 03:21:36.147
Every year we have an annual 
developer  conference, and a 

03:21:36.148 --> 03:21:40.369
couple of years ago, we decided 
to  move it from downtown San 

03:21:40.371 --> 03:21:43.145
Francisco where it had been  for
 quite a few years into Google's

03:21:45.203 --> 03:21:47.203
 backyard at

03:21:48.662 --> 03:21:51.341
 the  amphitheater.
Now, this was great.  Bigger 

03:21:51.342 --> 03:21:54.033
venue means we could  do bigger 
things, have more people come 

03:21:54.034 --> 03:22:01.107
along.  But how  do you take 
7,000 people from a bunch of 

03:22:01.108 --> 03:22:05.314
hotels all from  South Bay and 
get them into this one event?

03:22:05.518 --> 03:22:11.235
Well, there's a pretty easy 
answer to that.  You  get people

03:22:11.375 --> 03:22:16.627
 in buses and move people around
 with them.   But this is an 

03:22:16.628 --> 03:22:18.628
interesting opportunity for our 
relations  team.

03:22:18.771 --> 03:22:22.913
How can we best utilize Google 
Maps APIs to show  people where 

03:22:22.914 --> 03:22:28.344
their buses are, and how long 
it's going to  take them to get 

03:22:28.345 --> 03:22:33.302
between different points?
So Steve down in the front row 

03:22:33.303 --> 03:22:36.376
here and myself and  a bunch of 
others put together a solution 

03:22:36.377 --> 03:22:43.275
that actually  did this.  Showed
 attendees at Google IO the 

03:22:43.276 --> 03:22:45.738
realtime  location of their 
buses and also showed them 

03:22:45.739 --> 03:22:50.676
timetables  of how long the bus 
was going to take to get them 

03:22:50.677 --> 03:22:53.766
back  to their hotel.
So what we're going to do this 

03:22:53.767 --> 03:22:57.685
afternoon is walk  you through 
that solution.  A quick little 

03:22:57.686 --> 03:23:00.187
note here  what we're building 
is actually an asset tracker, 

03:23:00.188 --> 03:23:03.886
and  that one is specifically 
called out in our terms.  So  

03:23:03.887 --> 03:23:06.888
before you go ahead and 
implement an asset tracker,  

03:23:06.889 --> 03:23:11.943
please have a chat to our sales 
about a premium plan,  because 

03:23:11.944 --> 03:23:16.558
you're going to need it.
Okay.  Let's have an overview of

03:23:16.561 --> 03:23:21.193
 the transport  tracker solution
.  So here's the architecture.  

03:23:21.194 --> 03:23:24.292
For  those of you who attended 
the Flutter and Firebase talk  

03:23:24.293 --> 03:23:26.954
yesterday, this probably looks a
 little bit familiar.   It turns

03:23:27.153 --> 03:23:33.791
 out Firebase encourages you to 
actually  building this way.  It

03:23:33.794 --> 03:23:36.602
 does a very good job.
So what do we have here?  Well, 

03:23:36.603 --> 03:23:39.370
first part of the  problem is we
 have 30 odd buses running 

03:23:39.371 --> 03:23:41.871
around South Bay South Bay, and 
we want to know where they are. 

03:23:41.872 --> 03:23:47.337
 So what  we did is we put an 
Android phone on each bus with a

03:23:47.340 --> 03:23:51.069
  little suction cup holder to 
keep the phone out of the  way 

03:23:51.070 --> 03:23:56.644
of the driver and a USB Power 
Adapter.  And that had  a custom

03:23:56.843 --> 03:24:00.756
 application on it, which was 
then turning  around and 

03:24:00.757 --> 03:24:04.062
publishing to Firebase the 
location of the  bus.

03:24:04.267 --> 03:24:08.752
Firebase is wonderful.  It turns
 around and when  you push 

03:24:08.753 --> 03:24:12.644
information into it, it turns 
around and  notifies anything 

03:24:12.645 --> 03:24:19.885
that's listening on that path.
So following on from that, we 

03:24:19.886 --> 03:24:23.845
have a Node.js  process running 
in a Google compute engine 

03:24:23.846 --> 03:24:27.459
server in the  cloud actually 
being notified that this bus has

03:24:28.785 --> 03:24:32.843
 moved  from here here to here 
that process then cleans up that

03:24:33.143 --> 03:24:36.142
 data  and writes the cleaned up
 location of the bus along with 

03:24:36.143 --> 03:24:38.421
 timetable information, various 
other things back into  Firebase

03:24:39.146 --> 03:24:45.554
 in a different location, which 
then turns  around and changes 

03:24:45.555 --> 03:24:49.618
the display.
So at Google IO, we had big 60-

03:24:49.619 --> 03:24:54.680
inch LCD monitors  that had -- 
as you saw previously -- the 

03:24:54.681 --> 03:24:57.911
realtime  information of the bus
 and the timetable information. 

03:24:57.912 --> 03:25:00.420
  So this is the overview 
solution that I'm presenting  

03:25:00.421 --> 03:25:05.090
this information afternoon.
So let's dive in.  Let's start 

03:25:05.091 --> 03:25:08.090
with the first  component.  
These are the Android phones.  

03:25:08.091 --> 03:25:12.001
How do we get  the accurate 
location of the phone using 

03:25:12.002 --> 03:25:17.525
Android APIs?   Well, thanks to 
Steve's code lab, which some of 

03:25:17.526 --> 03:25:21.179
you  probably had a go at 
yesterday afternoon.  But if 

03:25:21.180 --> 03:25:23.743
you're  following on YouTube or 
you didn't, I'll have links at  

03:25:23.744 --> 03:25:26.228
the end of the talk that 
actually I'll link you to the  

03:25:26.229 --> 03:25:31.191
realtime code lab.
This, I just want to show you 

03:25:31.192 --> 03:25:35.450
the core component  that drives 
the ability to track the 

03:25:35.451 --> 03:25:40.616
location.
So we're doing to start with is 

03:25:40.617 --> 03:25:42.617
configuring a  location request.
  But

03:25:45.676 --> 03:25:48.493
 then reasonably aggressive here
,  we're asking for high 

03:25:48.494 --> 03:25:53.820
fidelity, high accuracy of the  
phone, and we're asking you 

03:25:53.821 --> 03:25:56.514
every ten seconds.  This  means 
the phone's going to be really 

03:25:56.515 --> 03:25:59.866
active.  The  circuit bug, the 
radio circuitry is always going 

03:25:59.867 --> 03:26:03.244
to be  on, so this is going to 
have battery implications, which

03:26:03.249 --> 03:26:06.742
  is why I mentioned before that
 when we installed the  phones 

03:26:06.743 --> 03:26:10.893
in the buses, we connected them 
up to USB phone  Chargers.  So 

03:26:10.894 --> 03:26:16.347
this is an explicit design 
consideration  when I turn 

03:26:16.348 --> 03:26:19.040
around and do this sort of thing
, you need  to be aware of is 

03:26:19.041 --> 03:26:21.533
this phone permanently connected
 to  power or not?

03:26:21.953 --> 03:26:24.745
Another thing that we 
implemented to deal with  this 

03:26:24.746 --> 03:26:27.631
was monitoring software.  So we 
had the phones  actually writing

03:26:28.144 --> 03:26:31.179
 their battery level into 
another part  of Firebase that 

03:26:31.180 --> 03:26:36.313
we had an admin user so that we 
could  see all about the phone, 

03:26:36.314 --> 03:26:39.714
the current location, and most  
importantly their power status. 

03:26:39.715 --> 03:26:43.563
 Because occasionally, a  bus 
driver would get into his bus 

03:26:43.564 --> 03:26:48.650
and go what's this  phone doing 
here, unplug it, and we would go

03:26:48.861 --> 03:26:52.321
 and find  the bus and get them 
to plug it back in.

03:26:52.601 --> 03:26:56.427
Okay.  So we configured how 
we're going to get  locations.  

03:26:56.428 --> 03:27:02.707
The next point is then use the 
location  provider API.  This 

03:27:02.708 --> 03:27:09.819
gives us -- fuses together 
cellular  tower data, GPS data, 

03:27:09.820 --> 03:27:13.235
Wi-Fi data to give us a more  
accurate depiction of where this

03:27:13.359 --> 03:27:18.931
 phone actually is.
We then configure whereabouts in

03:27:19.444 --> 03:27:23.067
 Firebase we're  going to write 
this location information.  But 

03:27:23.068 --> 03:27:27.326
finally,  we create a call back 
to hand to the location provider

03:27:27.541 --> 03:27:31.151
  API that we can actually then 
turn around and write the  

03:27:31.152 --> 03:27:35.944
results into Firebase.  And with
 this ten lines of code,  we are

03:27:36.148 --> 03:27:40.012
 now tracking this in realtime.

03:27:44.189 --> 03:27:48.318
Okay.  So we dealt with the 
first component.  Now  we move 

03:27:48.319 --> 03:27:53.220
to the heart of the system.  The
 Firebase  realtime database.  

03:27:53.221 --> 03:27:57.688
The Firebase realtime database 
is a  very powerful realtime 

03:27:57.689 --> 03:28:00.502
communication tool.  For me,  
while I was developing this 

03:28:00.503 --> 03:28:08.030
system, it was absolutely  
insanely powerful because 

03:28:08.031 --> 03:28:11.233
traditionally when you're  
developing a distributed system,

03:28:11.950 --> 03:28:14.762
 the main pain point you  have 
is understanding what the whole 

03:28:14.763 --> 03:28:21.176
system is doing.   Now, because 
I've got 30 phones wandering 

03:28:21.177 --> 03:28:25.506
around South  South Bay, I would
 like to know where they are, 

03:28:25.507 --> 03:28:29.319
what  they're doing and in this 
console, I can see which each  

03:28:29.320 --> 03:28:33.873
umph is doing at all times.
I can sit here and through this 

03:28:33.874 --> 03:28:36.668
console turn  around and make 
changes to the data structures 

03:28:36.669 --> 03:28:39.352
and see  what the downstream 
components do when faced with  

03:28:39.353 --> 03:28:43.268
certain edge cases.  This allows
 you to effectively have  

03:28:43.269 --> 03:28:46.773
realtime development in a 
distributed system.  You can  

03:28:46.774 --> 03:28:50.597
see what it's doing, change what
 it's doing, all while  looking 

03:28:50.598 --> 03:28:53.888
at a nice Web browser-based 
console.

03:28:56.177 --> 03:28:59.696
Okay.  So told you about the 
Android phones, they  put their 

03:28:59.697 --> 03:29:04.646
location information into 
Firebase, Firebase  then 

03:29:04.647 --> 03:29:09.930
notifies our Node.js process 
running on Google  compute 

03:29:09.931 --> 03:29:14.890
engine.  So this component has a
 couple of  things that it does.

03:29:15.228 --> 03:29:20.383
  It has a list of 
responsibilities,  but I'm going

03:29:20.384 --> 03:29:24.710
 to go through this.
The first one is while running 

03:29:24.711 --> 03:29:28.671
simulations, we  like to move 
things around the map.  To do 

03:29:28.672 --> 03:29:31.652
that, we need  to generate the 
paths the buses are going to 

03:29:31.653 --> 03:29:35.368
take.  They  start at a hotel, 
go to another hotel, and then 

03:29:35.369 --> 03:29:39.900
wind up  at Google IO.  We need 
to work out the path of all the 

03:29:39.901 --> 03:29:45.898
 roads, the roundabouts that 
that bus is going to take so  

03:29:45.899 --> 03:29:49.474
that the simulation looks real
istic.  The next thing I'm  

03:29:49.475 --> 03:29:52.624
going to show you is what the 
server does with the phone  

03:29:52.625 --> 03:29:58.204
location to tidy up the GPS data
.  Tends to be a bit  noisy.

03:29:58.617 --> 03:30:03.056
Okay.  So the first code snippet
.  Here's where  we're 

03:30:03.057 --> 03:30:06.660
generating a path.  Trip points 
is where we're  going to take 

03:30:06.661 --> 03:30:11.428
all the points of the path and 
take them  in and do things with

03:30:11.431 --> 03:30:13.096
 them later.  So this is 
effective effectively just in 

03:30:13.097 --> 03:30:16.753
the could you tell me later 
accumulateor.

03:30:17.144 --> 03:30:19.661
For every stop, I have a 
database of all the trips trips.

03:30:19.959 --> 03:30:22.544
  So what we're going to do is 
get the stops that  this trip is

03:30:22.764 --> 03:30:26.689
 going to make out of that 
database.  Here's  where we 

03:30:26.690 --> 03:30:33.410
create a directions API request.
  At its  simplest, a directions

03:30:33.516 --> 03:30:38.655
 request has a starting point 
and  ending point.  But in the 

03:30:38.656 --> 03:30:42.285
case we have multiple hotels  
that this bus was going to, we 

03:30:42.286 --> 03:30:46.618
have way points, which is  
between the origin and the 

03:30:46.619 --> 03:30:49.821
destination.
This is the line where we use 

03:30:49.822 --> 03:30:52.725
client library to  turn around 
and make a request to the 

03:30:52.726 --> 03:30:56.359
directions API.  I  just want to
 stop here for a second.  We 

03:30:56.360 --> 03:30:59.584
actually have  four client 
libraries.  One, as you can see 

03:30:59.585 --> 03:31:07.222
here in  Node.js, one for Go, 
one for Java, one for Python.  

03:31:07.223 --> 03:31:10.148
And  these client libraries take
 the Web service APIs like we  

03:31:10.149 --> 03:31:14.801
have, like directions API, road 
API, so on and so fourth  and 

03:31:14.802 --> 03:31:19.671
give you language-appropriate 
help.  So for Java and  go, we 

03:31:19.672 --> 03:31:23.501
expose to you what the result 
types are going to  be, so we 

03:31:23.502 --> 03:31:28.971
get -- if your browser or editor
 gives you  type completion or 

03:31:28.972 --> 03:31:35.875
what sort of thing.
Okay.  Now that we've made that 

03:31:35.876 --> 03:31:39.394
request using the  power to turn
 what's basically an 

03:31:39.395 --> 03:31:42.078
asynchronous operation  into 
something that looks synchronous

03:31:42.595 --> 03:31:46.646
, now we look at  the response. 
 Was it -- did it actually work?

03:31:46.855 --> 03:31:50.683
  And if  it did, now we 
actually interrogate the 

03:31:50.684 --> 03:31:54.225
response  structure.  So a 
directions response consists of 

03:31:54.226 --> 03:31:58.357
a set  of routes, and I'm just 
going to take the first one here

03:31:58.658 --> 03:32:02.220
  because I don't really care --
 well, I do care.  The  first 

03:32:02.221 --> 03:32:04.670
route is going to be the best 
route; right?

03:32:04.887 --> 03:32:08.115
For each route, we have a set of
 legs.  This  traditionally 

03:32:08.116 --> 03:32:15.114
shows up as different models.  
In each leg leg, there's a set 

03:32:15.115 --> 03:32:18.963
of steps.  And then finally in 
each  step, we have a polyline. 

03:32:18.964 --> 03:32:24.594
 So polyline is encoded format  
for a list of lat longs, 

03:32:24.595 --> 03:32:29.547
location points.  So to code  
this, I've got the points for 

03:32:29.548 --> 03:32:33.169
the step, and then I turn  
around and glue them all 

03:32:33.170 --> 03:32:36.503
together, put them in trip  
points, and then I use it later 

03:32:36.504 --> 03:32:38.504
for actually rendering  the 
buses going around in simulation

03:32:40.595 --> 03:32:44.988
.
So the second code snippet.  

03:32:44.989 --> 03:32:48.478
This is where I'm  going to deal
 with the bus.  So the bus is 

03:32:48.479 --> 03:32:52.419
walking  around -- walking?  
Driving.  Rolling around.  So we

03:32:52.422 --> 03:32:57.475
  have a bus moving around South
 Bay, it's checking in  every 

03:32:57.476 --> 03:33:01.224
two seconds through Firebase 
telling us where it  is.  So on 

03:33:01.225 --> 03:33:03.794
the server side, I collect a 
history of the  location of the 

03:33:03.795 --> 03:33:10.427
bus.  A couple of minutes, in 
this case,  and I take that 

03:33:10.428 --> 03:33:15.080
history, and I send it off to 
our snap  to road API.  So this 

03:33:15.081 --> 03:33:18.712
is part of our roads to API  
service.  So roads API knows 

03:33:18.713 --> 03:33:22.334
what all the roads are, and  I 
can turn around and give it a 

03:33:22.335 --> 03:33:25.273
couple of minutes of  history of
 the bus moving around.  And 

03:33:25.274 --> 03:33:31.958
roads API will  then take those 
points, do some mathematics, and

03:33:32.265 --> 03:33:34.969
 make a  best guess as to which 
road you're actually driving 

03:33:34.970 --> 03:33:37.955
down down.  So it effectively 
eliminates the noise from the  

03:33:37.956 --> 03:33:43.526
GPS track.
So then we -- because we're 

03:33:43.527 --> 03:33:45.687
actually interested in  the 
current location of the bus, we 

03:33:45.688 --> 03:33:50.479
take a list of  returned points 
and take the very last one.  

03:33:50.480 --> 03:33:56.691
It's worth  noting here that if 
you're plotting out a path to  

03:33:56.692 --> 03:34:00.863
something on a map, that you can
 also ask roads API to  insert 

03:34:00.864 --> 03:34:06.754
additional points because as I 
said, it knows  where 

03:34:06.755 --> 03:34:10.784
roundabouts are and curved roads
, so you can add  it additional 

03:34:10.785 --> 03:34:15.034
points to snapped road such that
 when you  plot it, it's a nice 

03:34:15.035 --> 03:34:21.127
line that actually follows the  
roads as opposed to just the 

03:34:21.128 --> 03:34:25.644
points that you sampled  using 
locations provider.

03:34:25.871 --> 03:34:28.551
In this case, we're not plotting
 anything, so I  didn't do that.

03:34:28.760 --> 03:34:32.143
  I've just taken the most 
recent point.

03:34:35.261 --> 03:34:36.810
   And of course there's error 
recovery.

03:34:36.811 --> 03:34:41.579
So now we're onto the final part
 of the system.

03:34:41.792 --> 03:34:46.408
This is where we put the buses 
and a timetable on  the map.

03:34:49.965 --> 03:34:53.377
  So you might have seen the map
 I showed you.   It doesn't look

03:34:53.379 --> 03:34:55.895
 like a standard Google map.  
Well, what  does the coated look

03:34:55.898 --> 03:34:58.335
 like?  It looks like this.  We 
have  a description language 

03:34:58.336 --> 03:35:01.662
that allows you to define the 
set  of rules that tells our 

03:35:01.663 --> 03:35:05.910
mapping engine how to render a  
map.  I don't know about you, 

03:35:05.911 --> 03:35:11.299
but I don't really want to  turn
 around and figure out how a map

03:35:11.478 --> 03:35:15.628
 renderer is using  this.  I 
would rather use a what you see 

03:35:15.629 --> 03:35:19.408
is what you get  wizard.  So 
what I would like to show you 

03:35:19.409 --> 03:35:23.946
now is show  you how to use a 
wizard to come up with a map 

03:35:23.947 --> 03:35:27.891
style.
Pray that the demo gods are 

03:35:27.892 --> 03:35:30.887
actually working.   Okay.  This 
is our wizard.  I would like to 

03:35:30.888 --> 03:35:33.487
create a  style.  Sydney, 
Australia

03:35:36.693 --> 03:35:39.902
.  Can't tell where this was  
written; right?

03:35:40.102 --> 03:35:43.936
Let's go to Krakow.  Okay.  This
 is the stock  standard Google 

03:35:43.937 --> 03:35:47.040
Maps styling.  But I'm creating 
an  application, and I don't 

03:35:47.041 --> 03:35:49.824
want this style.  I want  
something that speaks more to 

03:35:49.825 --> 03:35:55.299
Krakow.  Should we go with  
something that's completely 

03:35:55.300 --> 03:36:01.284
saturated?  Or respecting  
Krakow's history?  Should we go 

03:36:01.285 --> 03:36:04.590
with something retro?  I  think 
I like this.  But it has a bunch

03:36:04.898 --> 03:36:09.123
 of visual noise  on it that's 
not talking to me with the 

03:36:09.124 --> 03:36:13.791
application I'm  designing, so I
 can then turn around and -- 

03:36:13.792 --> 03:36:17.012
yeah, that's  better.  I've 
calmed down the map.  Maybe I 

03:36:17.013 --> 03:36:22.299
want to take  off the landmarks.
  Let's zoom in a bit.

03:36:31.857 --> 03:36:33.879
  How is that?   I'm happy with 
that.  Okay.

03:36:34.142 --> 03:36:36.116
If you want to dive in deeper 
and actually make  more 

03:36:36.117 --> 03:36:39.122
modifications, we have a deeper 
level here that you  can turn 

03:36:39.123 --> 03:36:41.123
around and play with the 
individual settings  and see the

03:36:41.203 --> 03:36:45.339
 results in realtime.  But I'm 
happy with  this map as it is.  

03:36:45.340 --> 03:36:49.059
So we give you two ways of using
  this map that you just 

03:36:49.060 --> 03:36:52.168
configured.
The first one here is the JSON 

03:36:52.169 --> 03:36:56.098
language that I was  showing you
 before.  This map styling 

03:36:56.099 --> 03:36:59.202
language is useful  in, 
obviously, Google Maps for Web. 

03:36:59.203 --> 03:37:02.516
 So using the  JavaScript API.  
But it also works the exact same

03:37:03.129 --> 03:37:06.662
  language on Android and iOS.  
So this way, you configure  your

03:37:06.864 --> 03:37:10.900
 map once and use it across all 
of your applications 

03:37:10.901 --> 03:37:12.901
applications.

03:37:14.725 --> 03:37:17.820
  Question also give you static 
maps, so if  you want to 

03:37:17.821 --> 03:37:22.061
configure it and style it in 
some way, you  can do this, and 

03:37:22.062 --> 03:37:25.916
this saves you from having to 
load a  JavaScript maps API.  A 

03:37:25.917 --> 03:37:29.110
much lighter response if you  
know you don't want your users 

03:37:29.111 --> 03:37:31.667
interacting with the map.

03:37:43.121 --> 03:37:45.728
Okay.  Now I've styled the map. 
 We're onto the  final part of 

03:37:45.729 --> 03:37:47.800
the journey where we've had the 
 information, start on the 

03:37:47.801 --> 03:37:52.736
Android phone, we cleaned it  up
 in compute engine, now we're 

03:37:52.737 --> 03:37:59.495
going to display it on a  map. 
we must be back in JavaScript 

03:37:59.496 --> 03:38:02.896
land, got a Firebase  database 
we're taking reference on, now 

03:38:02.897 --> 03:38:06.904
we're listening  to a different 
path in Firebase.  So this is 

03:38:06.905 --> 03:38:11.170
where the  compute engine hosted
 Node.js process and writing the

03:38:11.465 --> 03:38:14.253
  cleaned up location of the 
buses.

03:38:19.300 --> 03:38:25.096
So what I've done here, I'm 
writing an entry for  each bus. 

03:38:25.097 --> 03:38:31.898
 So thus I can look up all the 
buses all at  once.  I look at 

03:38:31.899 --> 03:38:36.050
each bus, and I have a routine 
here for  what color marker to 

03:38:36.051 --> 03:38:40.184
put for that bus depending on 
what  bus route that bus is 

03:38:40.185 --> 03:38:43.597
serviceing.
Then we create a marker.  Real

03:38:43.703 --> 03:38:47.628
istically, you need  a bit more 
complexity here to deal with re

03:38:47.629 --> 03:38:52.067
using markers markers  because 
if you kept creating new markers

03:38:53.200 --> 03:38:56.215
, you would have  the screen 
full of markers.  We move the 

03:38:56.216 --> 03:38:58.479
marker around,  and then you 
delay it when the bus goes out 

03:38:58.480 --> 03:39:00.495
of service.

03:39:06.317 --> 03:39:09.433
But I hear people out in the 
audience screaming  the Web's 

03:39:09.434 --> 03:39:14.907
great, but I want to put it on 
mobile as well.   How can we do 

03:39:14.908 --> 03:39:20.200
this?  Well, just so happens, we
 have the  same code for Java.  

03:39:20.201 --> 03:39:23.933
We've got types here, we're back
 in  Java land, we have a 

03:39:23.934 --> 03:39:30.875
database reference, we turn 
around  and create a child 

03:39:30.876 --> 03:39:35.957
listener to add to the Firebase 
to  notify us when things change

03:39:36.994 --> 03:39:41.558
.  This time around, I'm  just 
tracking a single bus, I'm not 

03:39:41.559 --> 03:39:46.697
turning around and  mapping all 
of them.  I've got out of the 

03:39:46.698 --> 03:39:51.766
Firebase, I've  got the lat, so 
that's the latitude of the bus, 

03:39:51.767 --> 03:39:56.184
 longitude, and the bus route.  
So now I have enough  

03:39:56.185 --> 03:40:01.493
information to turn around and 
configure a marker on the  map. 

03:40:01.494 --> 03:40:04.427
 Same logic applies here.  You 
probably want to  hold onto the 

03:40:04.428 --> 03:40:08.912
marker once you create it and 
move it  around.  Simple enough.

03:40:13.999 --> 03:40:16.815
Okay.  So just to go over a high
 level of what  we've just 

03:40:16.816 --> 03:40:20.868
covered, we started out in 
Android using  location provider

03:40:21.067 --> 03:40:25.086
 to get the location of an asset
, we  published that location 

03:40:25.087 --> 03:40:30.450
every ten seconds into Firebase,
  Firebase notified a Google 

03:40:30.451 --> 03:40:33.698
compute engine hosted Node.js  
process to cleanup that data and

03:40:35.029 --> 03:40:39.389
 deal with the GPS  location 
data.  That updated information 

03:40:39.390 --> 03:40:45.576
was written  back into Firebase,
 which controlled a front-end 

03:40:45.577 --> 03:40:49.220
Google  map-hosted dashboard 
that was shown to all the 

03:40:49.221 --> 03:40:54.537
attendees  at Google AI.  I've 
also shown you how to do this 

03:40:54.538 --> 03:40:58.955
with  mobile.
So where next?

03:40:59.159 --> 03:41:01.852
For starters, if you would like 
to see the  documentation for 

03:41:01.853 --> 03:41:05.571
the Google map solutions that 
we're  publishing, it's all up 

03:41:05.572 --> 03:41:09.401
on developers.Google.com.  If  
you would like to have a look at

03:41:10.309 --> 03:41:13.108
 our client libraries  and our 
open source code like the 

03:41:13.109 --> 03:41:17.436
samples -- sorry, like  the 
solutions, it's all up on GitHub

03:41:17.874 --> 03:41:22.509
.  And finally, the  code that 
you saw in this talk is actually

03:41:22.833 --> 03:41:27.877
 lifted out of  three Codelabs. 
 The first code lab was the one 

03:41:27.878 --> 03:41:31.177
that  Steve and I hosted 
yesterday, which was the asset  

03:41:31.178 --> 03:41:34.817
tracking code lab.  The code for
 the Node.js process was  lifted

03:41:35.652 --> 03:41:37.932
 out of the transport tracker 
back-end code lab.   And finally

03:41:38.119 --> 03:41:42.350
, the code that I showed at the 
very --  almost at the very end 

03:41:42.351 --> 03:41:45.537
of putting markers on a big  
Google map was taken out of the 

03:41:45.538 --> 03:41:50.305
transport tracker map.   And 
with that, I thank you for your 

03:41:50.306 --> 03:41:53.197
attention, and I  invite you to 
give us feedback.  Thank you 

03:41:53.198 --> 03:41:55.198
very much.
[Applause]

04:05:23.451 --> 04:05:28.966
&gt;&gt; My name is Thomas Steiner, 
I'm based out of the  Hamburg, 

04:05:28.967 --> 04:05:32.068
Germany office.  And I work on 
mostly Web stock stock.  And 

04:05:32.069 --> 04:05:35.170
with me today is my guest 
speaker Steven.   Steven, want 

04:05:35.171 --> 04:05:37.128
to come up and introduce 
yourself?

04:05:37.129 --> 04:05:40.841
&gt;&gt; Hi, so I'm Steven.  I'm 
product manager at  Google in 

04:05:40.842 --> 04:05:44.669
California.  I'm just visiting, 
guest speaking  today on the

04:05:50.074 --> 04:05:52.973
 identity on the mobile Web.
&gt;&gt; Thank you.  So today, we want

04:05:53.670 --> 04:05:57.389
 to show you  what's next for 
the Web or as an alternative 

04:05:57.390 --> 04:06:04.327
title,  exploring.  But before 
we get started, here's a fair  

04:06:04.328 --> 04:06:06.829
warning.  There's a lot of 
content coming, and I'm going  

04:06:06.830 --> 04:06:12.623
to speak fast.  Probably even 
too fast, so hold onto  your 

04:06:12.624 --> 04:06:15.966
seats and especially watch out 
for other links.  So  many of 

04:06:15.967 --> 04:06:19.380
the slides have links, and, of 
course, you can  just snap a 

04:06:19.381 --> 04:06:22.495
photo of the slides so you can 
look up some  of the content 

04:06:22.496 --> 04:06:26.659
after the presentation.
So let's get going.  Let's get 

04:06:26.660 --> 04:06:31.785
started.  Our first  big topic 
area is proving Web apps or 

04:06:31.786 --> 04:06:39.840
short, PWA.  Let  me show you 
how you can with PWA

04:06:43.048 --> 04:06:47.799
 create immerseive screen  
experiences.  Because your apps 

04:06:47.800 --> 04:06:52.519
take up a lot of real  estate.  
Some of you may remember iOS 

04:06:52.520 --> 04:06:57.918
2016, the paper paperplanes app 
is still an app.

04:07:01.737 --> 04:07:04.446
  Pu launch this  application, 
you might notice something.  

04:07:04.447 --> 04:07:07.326
This is a Web.   But if you 
notice on the screen at the top,

04:07:07.735 --> 04:07:14.308
 there is no  network signal, no
 clock, no battery status 

04:07:14.309 --> 04:07:16.515
notification notification.  It's
 a true full screen experience. 

04:07:16.516 --> 04:07:19.802
 And  you can do this by setting
 the display property in your  

04:07:19.803 --> 04:07:24.108
Web app to the value of full 
screen.

04:07:26.487 --> 04:07:30.208
Very exciting for game 
developers and, yeah,  hopefully

04:07:30.319 --> 04:07:32.319
 you can try it out for your 
application.

04:07:32.422 --> 04:07:38.425
For PWA, we also add to a home 
screen experience.   Install the

04:07:38.641 --> 04:07:43.818
 PWA, they will not be able to 
find PWAs in  the Android app 

04:07:43.819 --> 04:07:46.827
drawer, with just all the other 
native  applications.  So they 

04:07:46.828 --> 04:07:50.566
look and behave and finally 
react  as true native 

04:07:50.567 --> 04:07:57.303
applications, so you can just 
search for  your app.  And 

04:07:57.304 --> 04:07:59.685
something that a lot of 
developers have  really been 

04:07:59.686 --> 04:08:03.427
looking forward to, you can also
 now update  the icon and change

04:08:03.653 --> 04:08:05.912
 the application name after the 
 application has been installed.

04:08:06.223 --> 04:08:10.046
  And something that's  really 
cool as well is with the 

04:08:10.047 --> 04:08:14.908
improved flow, you can  now 
based on the scope attribute 

04:08:14.909 --> 04:08:21.221
there Android in the  Web app 
manifest, create an intent that 

04:08:21.222 --> 04:08:27.535
allows you to  react whenever 
your pattern within the scope, 

04:08:27.536 --> 04:08:34.317
so your  application can just 
open directly whenever it is.  

04:08:34.318 --> 04:08:37.516
And  I'm going to check, for 
example, and go into the PWA  

04:08:37.517 --> 04:08:41.878
experience.
The next thing is the Web share 

04:08:41.879 --> 04:08:44.877
API.  Because we  all know that 
sharing is caring.  And if you 

04:08:44.878 --> 04:08:51.482
want to do  that on pretty much 
any site in 2017, you end up 

04:08:51.483 --> 04:08:55.628
with an  experience like the one
 that you can see on the side.  

04:08:55.629 --> 04:08:59.042
 So a lot of screen real estate 
is in a sense wasted for  all of

04:08:59.044 --> 04:09:01.731
 these sharing buttons.  And, of
 course, looking  at the sharing

04:09:02.847 --> 04:09:08.362
 buttons, always there's one 
social  network that you would 

04:09:08.363 --> 04:09:12.085
actually want to share on is not
  on the list.  And now as we 

04:09:12.086 --> 04:09:16.455
have seen on the slide with  a 
full screen experience, 

04:09:16.456 --> 04:09:20.910
sometimes the URL bar is  hidden
, so you need a different way to

04:09:21.027 --> 04:09:24.564
 share your  application.  And 
this brings me to the Web share 

04:09:24.565 --> 04:09:28.206
API.   It's integrated with the 
native Android sharing dialogue 

04:09:28.207 --> 04:09:31.502
dialogue, which is really cool 
because there, you have a  truly

04:09:32.528 --> 04:09:34.824
 native experiences -- 
experience of sharing your  

04:09:34.825 --> 04:09:40.582
content.  So if you look at this
 code snippet, it's very  short.

04:09:41.638 --> 04:09:45.475
  Navigator.share.  You can give
 a title, you can  give a Texas,

04:09:45.584 --> 04:09:47.876
 and you can give a URL, and 
this allows  you

04:09:47.877 --> 04:09:52.422
  to change the URL that's 
displaced on the screen.   So, 

04:09:52.423 --> 04:09:56.131
for example, something that is 
hosted somewhere or  embedded in

04:09:56.136 --> 04:10:01.267
 the app cache, for example,.
The next topic is

04:10:11.670 --> 04:10:14.569
 Web notifications.  Directly in
  the native system notification

04:10:14.781 --> 04:10:18.389
 pattern, so they no  longer 
feel like strangers, they're now

04:10:19.522 --> 04:10:22.922
 just native  notifications.  
Which also means they respect 

04:10:22.923 --> 04:10:28.094
your  devices or your systems do
 not disturb setting, just  

04:10:28.095 --> 04:10:30.872
powerful because you don't want 
to be disturbed by  

04:10:30.873 --> 04:10:34.046
notifications when you give a 
presentation, for example,.

04:10:38.317 --> 04:10:41.396
   So the next topic is an 
interesting topic.  Some  

04:10:41.397 --> 04:10:44.305
companies ship down three 
megabytes of image data and  

04:10:44.306 --> 04:10:51.301
then ship it down on the site 
and other companies have  

04:10:51.302 --> 04:10:55.015
worries about performance of the
 service.  

04:11:04.047 --> 04:11:11.675
 Navigation preload.  What this 
does is it kind of  makes the 

04:11:11.676 --> 04:11:15.184
time or the service record boots
 up not  waiting time but 

04:11:15.185 --> 04:11:18.293
parallel time that your app can 
already  use for navigation 

04:11:18.294 --> 04:11:25.216
request.  So if you look at this
  little diagram here at the 

04:11:25.217 --> 04:11:28.433
bottom of the slides, you can  
see the service record boot time

04:11:28.735 --> 04:11:32.659
 before and the service  record 
boot time after this trial is 

04:11:32.660 --> 04:11:35.461
activated.  So you  can see it's
 running in parallel, so

04:11:35.462 --> 04:11:40.205
  the request can  already 
happen.  If you look at this 

04:11:40.206 --> 04:11:47.517
code, you can see  there's two 
events.  The activate event with

04:11:47.520 --> 04:11:51.240
 this  highlighted yellow line, 
the wait, navigation preload  

04:11:51.241 --> 04:11:56.020
enable, you enable navigation 
preload.  And then in your  

04:11:56.021 --> 04:12:03.476
fetch list now after going 
through the chain of do I  have

04:12:06.253 --> 04:12:10.725
 the response.  Maybe no or yes.
  You can check if  there's a 

04:12:10.726 --> 04:12:12.927
preloaded response that you can 
then ship to  the users.  So 

04:12:12.928 --> 04:12:15.409
this allows you to get content 
to the  user faster without 

04:12:15.410 --> 04:12:19.806
waiting time or the service 
worker  to boot.

04:12:20.765 --> 04:12:25.552
On mobile, you now have a pretty
 exciting new way  of signing up

04:12:26.983 --> 04:12:29.045
.  And this brings Steven on 
stage.

04:12:29.046 --> 04:12:34.309
&gt;&gt; Okay.  Thanks, Thomas.  So 
what we'll talk  about here is 

04:12:34.310 --> 04:12:38.044
one part of the experience of 
building a  mobile Web app that 

04:12:38.045 --> 04:12:41.800
is often frustrating.  It's only
 a  small part, but it's often a

04:12:42.208 --> 04:12:45.550
 big part developers  encounter.
  And that's how to get people 

04:12:45.551 --> 04:12:48.848
signed in and  signed up on a 
small screen.  You've probably 

04:12:48.849 --> 04:12:52.044
all had  experiences like this 
before where you have to 

04:12:52.045 --> 04:12:57.125
remember  user name, password, 
type it in on a mobile keyboard 

04:12:57.126 --> 04:12:59.934
and  perhaps you've added 
something like Facebook sign in 

04:12:59.935 --> 04:13:03.455
or  Google log in on your app.  
But there's not people using  it

04:13:03.683 --> 04:13:06.667
.  There's always a concern of 
what information gets  shared 

04:13:06.668 --> 04:13:10.058
and how you end up back on the 
site.  So what my  team has been

04:13:10.309 --> 04:13:13.332
 working on in Google is how to 
improve the  mobile experience 

04:13:13.333 --> 04:13:15.308
for the mobile browsers out 
there.   And what we're working 

04:13:15.309 --> 04:13:19.267
on out there is a new and un 
unreleased API that adds an I 

04:13:19.268 --> 04:13:22.895
frame to your mobile site  where
 you can offer one tap sign up 

04:13:22.896 --> 04:13:26.105
or sign in  experience.  This 
gets someone into your site or 

04:13:26.106 --> 04:13:31.072
signed  up through
  checkout or a conversion flow 

04:13:31.073 --> 04:13:34.284
with as little  friction as 
possible.  And as a new thing, 

04:13:34.285 --> 04:13:37.602
we would love  to hear feedback 
from developers like you on how 

04:13:37.603 --> 04:13:40.202
this  would work on your site.  
So check out the link or send  

04:13:40.203 --> 04:13:44.989
me an e-mail.  Send us feedback 
on this part of the  mobile app 

04:13:44.990 --> 04:13:47.301
experience.  Thank you.

04:13:50.335 --> 04:13:55.272
&gt;&gt; So I'm going to use that.  
Essentially, there's  two API 

04:13:55.273 --> 04:14:02.279
calls that you can make.  But 
auto sign in you  can use smart 

04:14:02.280 --> 04:14:10.768
log.retrieve or smart log, you 
can do  smart lock.hint.  You're

04:14:10.975 --> 04:14:15.423
 not spooned this code, it's  
just to give you an idea of what

04:14:15.427 --> 04:14:20.411
 will be possible soon.   So 
let's get back to PWAs in 

04:14:20.412 --> 04:14:25.874
general.  The question I  get a 
lot when people develop a PWA A 

04:14:25.875 --> 04:14:29.840
and develop caches,  what am I 
even allowed to use?  How much 

04:14:29.841 --> 04:14:37.012
storage do I  have?  Or if they 
already have a cache full of 

04:14:37.013 --> 04:14:40.533
content  or somewhat full of 
content, they're wondering how 

04:14:40.534 --> 04:14:45.929
much  of my cache am I using?  
So with a new storage Web API,  

04:14:45.930 --> 04:14:52.315
you can now find out.  You just 
very recently call  navigator.

04:14:52.317 --> 04:14:55.198
storage.estimate, then you get 
how much  storage you are 

04:14:55.199 --> 04:15:00.577
already using and how much 
storage is  available in total.

04:15:00.985 --> 04:15:04.089
A long time thing

04:15:09.959 --> 04:15:13.924
 by developers of PWA.  Let's  
move on to the next topic area, 

04:15:13.925 --> 04:15:18.782
which is media-related  APIs.  
Media on the Web is very 

04:15:18.783 --> 04:15:20.847
exciting and the next  thing I 
want to talk about is image 

04:15:20.848 --> 04:15:24.680
capture API.   Because you 
should be zooming in on what 

04:15:24.681 --> 04:15:28.080
matters.  So on  the screenshot,
 you can see what matters is my 

04:15:28.081 --> 04:15:32.022
face.   I'm zooming in on my 
face and the animation that I  

04:15:32.023 --> 04:15:36.253
created for the slide.  So this 
API allows you to  actually 

04:15:36.254 --> 04:15:41.620
natively zoom in.  So this is 
not large.  This  is native zoom

04:15:41.826 --> 04:15:48.247
 of the camera.  And you can use
 this  directly from your 

04:15:48.248 --> 04:15:50.552
browser, and this is how you do 
it.

04:15:50.852 --> 04:15:55.935
So for this little demo here, 
you can see the  slider and the 

04:15:55.936 --> 04:15:59.345
slider, that's of course how 
much can it  slide?  So what is 

04:15:59.346 --> 04:16:03.971
the maximum zoom level?  And you
 can  see this short snippet 

04:16:03.972 --> 04:16:08.927
code how from the media stream  
you first get the track, check 

04:16:08.928 --> 04:16:12.564
its capabilities, and  from the 
capabilities -- sorry from the 

04:16:12.565 --> 04:16:17.450
track, I check  the available 
settings, and I can use that to 

04:16:17.451 --> 04:16:23.268
-- yeah,  update and create my 
user interface to zoom in with 

04:16:23.269 --> 04:16:26.878
the  capabilities of the device 
directly being used and being  

04:16:26.879 --> 04:16:30.263
applied.
So that's pretty cool, pretty 

04:16:30.264 --> 04:16:33.596
exciting.  Something  even 
cooler and even more exciting is

04:16:34.019 --> 04:16:37.672
 the shape  detection API that 
allows you to detect faces, read

04:16:37.772 --> 04:16:46.622
 bar  codes, and even to run 
optimal character recognition  

04:16:46.623 --> 04:16:50.043
right in the browser.
I was just holding my phone and 

04:16:50.044 --> 04:16:53.058
pointing to  different browser 
tabs where I had opened first a 

04:16:53.059 --> 04:16:58.530
QR  code and then on a second 
tab, a face and some text here 

04:16:58.531 --> 04:17:01.212
here, you can see how in 
realtime the guided

04:17:04.919 --> 04:17:08.035
 detects  different objects on 
the page.  So this is directly  

04:17:08.036 --> 04:17:10.940
integrated in the browser.
So let me quickly show you how 

04:17:10.941 --> 04:17:15.047
it works.  You  first need to 
initialize the different 

04:17:15.048 --> 04:17:18.871
detectors, so the  face detector
, the text detector, and the bar

04:17:19.092 --> 04:17:22.394
 code  detector.  And then you 
can just listen for events.  So

04:17:26.000 --> 04:17:32.212
  everything you can cue up all 
the different detectors  and so 

04:17:32.213 --> 04:17:35.833
on, and then you will get the 
detected objects in  the results

04:17:36.036 --> 04:17:39.641
.
So really cool, super easy to 

04:17:39.642 --> 04:17:46.063
use.  If you check  out this 
demo, you will see its 100 lines

04:17:46.271 --> 04:17:49.708
 of code and  everything working
 directly in the browser.  So 

04:17:49.709 --> 04:17:52.611
super  exciting, super cool API.
  I think this unlocks a lot of 

04:17:52.612 --> 04:17:56.220
 cool applications.
The next thing is the media 

04:17:56.221 --> 04:18:00.489
session API.  Many  play media 
content on the Web.  You want to

04:18:00.494 --> 04:18:03.593
 know, of  course, well, what is
 playing, when is it playing, 

04:18:03.594 --> 04:18:07.812
and  on a mobile device, you of 
course want it controlled.   You

04:18:07.817 --> 04:18:13.185
 want to skip over, go to the 
next track, pause, this  is all 

04:18:13.186 --> 04:18:19.238
possible now with the session 
API.  You can see  meta

04:18:19.242 --> 04:18:23.630
information of the currently-
playing media, and you  can, of 

04:18:23.631 --> 04:18:26.733
course, directly control it.  
Let me show you as  well how 

04:18:26.734 --> 04:18:30.018
this works and what kind of 
metadata you can  control.  So 

04:18:30.019 --> 04:18:32.540
in the screenshot here, you can 
see there's  a title, there's an

04:18:32.728 --> 04:18:37.856
 artist, there's an album, 
there's  artwork, and then you 

04:18:37.857 --> 04:18:40.545
have different action that you  
have.

04:18:40.862 --> 04:18:45.204
So a lot of things possible.  
And this block of  code might 

04:18:45.205 --> 04:18:50.676
first look pretty intimidating, 
but actually,  it's just too big

04:18:50.981 --> 04:18:57.769
 things and the first half are 
sitting  here with the media.  

04:18:57.770 --> 04:19:00.770
And then on the second half, I'm
  just connecting the action 

04:19:00.771 --> 04:19:04.694
handleers and connecting  
functions with the different 

04:19:04.695 --> 04:19:07.928
events.  So super easy to  use. 
 Again, very powerful, great 

04:19:07.929 --> 04:19:09.929
integration

04:19:12.385 --> 04:19:15.049
, to a  native operating system.
What we are.  Big topic.  Super 

04:19:15.050 --> 04:19:18.901
cool thing because  sometimes, 
the real reality is actually not

04:19:19.101 --> 04:19:23.638
 real enough.   So what we are 
allows you to create compelling 

04:19:23.639 --> 04:19:28.943
VR  experiences right in the 
browser.  It's an open standard 

04:19:28.944 --> 04:19:33.608
 that just allows you to 
directly program these kinds of 

04:19:33.609 --> 04:19:38.322
 experiences so that everyone 
can get VR experiences very  

04:19:38.323 --> 04:19:43.961
easily.  You can see how this 
could change the lives for  

04:19:43.962 --> 04:19:46.647
interior designers, for example,
 who would just pass on  a link 

04:19:46.648 --> 04:19:51.205
to work that they've created to 
their clients.   You don't have 

04:19:51.206 --> 04:19:54.278
animated 3D or anything.  They 
can just  take out their VR 

04:19:54.279 --> 04:19:59.251
logos, cardboards, whatever and 
then  take a look at how their 

04:19:59.252 --> 04:20:04.254
future home might look.  Super  
cool directly in the browser.

04:20:04.553 --> 04:20:07.883
Performance.  This is super 
important, of course.   We 

04:20:07.884 --> 04:20:12.436
preach performance a lot.  
Performance APIs no longer  

04:20:12.437 --> 04:20:16.874
allow you to have an excuse for 
having a bad performing  site.  

04:20:16.875 --> 04:20:19.705
Network information API is 
something that you can  use to 

04:20:19.706 --> 04:20:25.143
know how fast it can go.  Let me
 show you what  you can do here.

04:20:25.337 --> 04:20:29.275
  So based on the connection 
type of the  user, you can now 

04:20:29.276 --> 04:20:32.264
adopt your experience.  So, for 
 example, you can show someone 

04:20:32.265 --> 04:20:36.396
low resolution image  assets 
when they are on a slow 

04:20:36.397 --> 04:20:42.397
connection.  And of  course on 
mobile in a true mobile way, so 

04:20:42.398 --> 04:20:47.038
sometimes  you're in a tunnel, 
sometimes you are on the country

04:20:47.348 --> 04:20:50.787
  side, and then sometimes you 
are in the city.  So what I  am 

04:20:50.788 --> 04:20:54.705
getting at is connections change
.  So of course you  don't want 

04:20:54.706 --> 04:20:59.238
to have someone with a low 
experience for the  entire 

04:20:59.239 --> 04:21:02.036
session.  But sometimes when 
they have a good  connection, 

04:21:02.037 --> 04:21:11.865
you of course want to keep them.
So you can see how the code 

04:21:11.866 --> 04:21:14.352
reads out the  information but 
then notifies when the 

04:21:14.353 --> 04:21:18.657
connection  changes.  Why is 
this important?  Well, you of 

04:21:18.658 --> 04:21:22.555
course  have media queries.  So 
you can say, well, this user is 

04:21:22.556 --> 04:21:29.937
 on a retina display super high 
resolution Apple book but  

04:21:29.938 --> 04:21:32.107
actually combined with that 
information, it might after  all

04:21:32.412 --> 04:21:36.860
 not make sense to show them 
super high resolution  images.  

04:21:36.861 --> 04:21:42.960
So this is just a short example 
of how you can  programmatically

04:21:43.475 --> 04:21:46.780
 from JavaScript check for the 
results,  then combine it with 

04:21:46.781 --> 04:21:50.411
the connection API to see if the
  connection actually right now 

04:21:50.412 --> 04:21:53.918
is good enough for  supporting 
high res images.  So you can 

04:21:53.919 --> 04:21:57.047
directly work  with media 
queries and with the connection 

04:21:57.048 --> 04:22:01.641
API together.
And there's the core performance

04:22:02.055 --> 04:22:04.743
 API because you  do care or 
should be caring what's 

04:22:04.744 --> 04:22:09.585
happening when a page  loads.  
For this, I was very quickly 

04:22:09.586 --> 04:22:15.456
auditing the actual  event page 
for the GP.  So there's a lot of

04:22:15.682 --> 04:22:17.723
 different  things that you can 
get and calculate and an take 

04:22:17.724 --> 04:22:23.599
the.   So I can see here I'm 
getting the data from the window

04:22:24.217 --> 04:22:25.793
. window.performance.timing 
object, and then you can  

04:22:25.794 --> 04:22:28.883
calculate a number of things.  
Like, for example, the  page 

04:22:28.884 --> 04:22:32.310
load time or the connect time or
 the render time,  and these are

04:22:32.626 --> 04:22:36.351
 core metrics that it could then
 just  simply report back to 

04:22:36.352 --> 04:22:40.279
your analytics back-end, and you
  can see how the real users in 

04:22:40.280 --> 04:22:44.527
the real world out there  
experience my page.  And you 

04:22:44.528 --> 04:22:47.528
then see alarming numbers,  it's
 probably a good idea to get 

04:22:47.529 --> 04:22:51.225
going and improve your  site and
 get it to load faster or render

04:22:51.949 --> 04:22:54.112
 faster.  So  that's really cool
.

04:22:54.241 --> 04:22:58.025
But then, this is only one part 
of the story.   Something more 

04:22:58.026 --> 04:23:02.775
interesting and more important, 
actually,  is making sure that 

04:23:02.776 --> 04:23:06.028
content in a meaningful way gets
 to  the user.  So what it can 

04:23:06.029 --> 04:23:11.257
do now is with a timing API,  
information about key painting 

04:23:11.258 --> 04:23:14.485
events.  So when did what  
content arrive at the user's 

04:23:14.486 --> 04:23:18.717
device?  And there's even a  
performance observer, so I can 

04:23:18.718 --> 04:23:25.844
get that notified and  react 
whenever a certain page happens.

04:23:26.147 --> 04:23:29.046
I was operating this page on a 
slow 3G connection,  and you can

04:23:29.047 --> 04:23:32.151
 see here on the console it's 
relatively  small I think, but 

04:23:32.152 --> 04:23:38.529
you can still maybe see it, the 
first  kind.  So when was the 

04:23:38.530 --> 04:23:41.301
first moment something no matter
  what was painted and when was 

04:23:41.302 --> 04:23:43.358
the first moment where  
something meaningful was painted

04:23:43.785 --> 04:23:46.669
?  So, for example, text text, 
for example, an image so that 

04:23:46.670 --> 04:23:50.597
people can actually  consume 
content, not just stair at a 

04:23:50.598 --> 04:23:52.864
gray background or  a white 
background.

04:23:53.991 --> 04:23:58.038
So for super easy for API, of 
course core metrics,  these are 

04:23:58.039 --> 04:24:01.986
core metrics that can, again, 
record back to  analytics and 

04:24:01.987 --> 04:24:07.419
see if everything is okay.
Client hints.  Also very 

04:24:07.420 --> 04:24:12.571
exciting topic.  That  allows 
you to adopt and see what kind 

04:24:12.572 --> 04:24:19.457
of device you have  to do with. 
 We have in Chrome telemetry, so

04:24:19.463 --> 04:24:21.961
 we have a  feeling of what's 
going on with the browser, and 

04:24:21.962 --> 04:24:27.314
we've  noticed that a lot of 
foreground crashes are actually 

04:24:27.315 --> 04:24:31.048
 due to out of memory exceptions
.  So when the device  runs out 

04:24:31.049 --> 04:24:36.432
of memory, the Chrome tab might 
crash.  So you  can see here an 

04:24:36.433 --> 04:24:42.000
Android phone more on the 
cheapened of  the spectrum.  For

04:24:42.002 --> 04:24:44.809
 these kinds of devices, it 
might be a  good idea to not 

04:24:44.810 --> 04:24:50.357
serve super, super high res, 
super RAM- RAM-heavy experiences

04:24:50.767 --> 04:24:57.239
, but maybe adopt it.  So, first
 of  all, servers can advertise 

04:24:57.240 --> 04:25:04.504
that they support.  For this  
there's a new code accept-CH,.  

04:25:04.505 --> 04:25:10.955
CH for client hint.  And  then 
it can provide different line 

04:25:10.956 --> 04:25:17.350
hints that it  supports, for 
instance, device memory.  And 

04:25:17.351 --> 04:25:20.253
then it can  send the device 
memory, for example, I'm a poor

04:25:20.436 --> 04:25:26.441
ish  device, I have .5 gigs of 
RAM only, so then the server  

04:25:26.442 --> 04:25:29.442
can adapt the experience 
accordingly.  And also, you can 

04:25:29.443 --> 04:25:30.372
 read
  out this information on the 

04:25:30.373 --> 04:25:33.791
client side with  JavaScript.  
So you can just have a look at 

04:25:33.792 --> 04:25:37.393
navigator. navigator.device 
memory and see what is the 

04:25:37.394 --> 04:25:41.920
actual  hardware device memory 
right now.  And you can also see

04:25:42.233 --> 04:25:45.815
  how many corresponds does the 
CPU have?  So when you  program 

04:25:45.816 --> 04:25:49.423
a game, for example, you can 
decide to use heavy  

04:25:49.424 --> 04:25:51.424
architectures or

04:25:54.099 --> 04:25:57.643
  textures or the heavy textures
?  And also, how many  

04:25:57.644 --> 04:26:02.275
corresponds does the CPU have?
Super exciting; right?  New 

04:26:02.276 --> 04:26:05.695
features.  Which then  brings us
 to hardware-related APIs.  The 

04:26:05.696 --> 04:26:08.679
first API that  I want to 
mention is the Web Bluetooth API

04:26:08.974 --> 04:26:12.370
, which allows  you to 
communicate with nearby 

04:26:12.371 --> 04:26:17.543
Bluetooth devices.  In  this 
demo here, you can see how with 

04:26:17.544 --> 04:26:21.875
his phone, he's  controlling 
Bluetooth canals.  I wasn't sure

04:26:22.204 --> 04:26:25.296
 that this  kind of thing exists
, but it does exist.  Bluetooth 

04:26:25.297 --> 04:26:27.993
 canals.  You can see why this 
would be fun.  You can  just 

04:26:27.994 --> 04:26:31.436
allow anyone with a device that 
is in range to  control the 

04:26:31.437 --> 04:26:38.277
experience here.
Using the app, so generic 

04:26:38.278 --> 04:26:45.674
profile, and uses  Bluetooth 
core.  So very energy efficient.

04:26:46.192 --> 04:26:51.966
  Implemented  in Android, Linux
, iOS, and in Chrome wear.  Very

04:26:52.175 --> 04:26:55.579
  exciting API.
The next thing is Web USB.  

04:26:55.580 --> 04:27:01.732
Which allows you, as  the name 
suggests, to expose USB devices 

04:27:01.733 --> 04:27:05.640
directly to  websites.  This is 
of course not for any and all US

04:27:05.962 --> 04:27:08.867
B  devices but for USB devices 
that are specifically  designed 

04:27:08.868 --> 04:27:10.949
for that.  And this demo here 
created by

04:27:14.245 --> 04:27:21.875
  Kenneth Rhodes, you can see 
how he is using an Arduino  

04:27:21.876 --> 04:27:23.843
board to display text on a 
screen.

04:27:23.844 --> 04:27:26.115
So these devices need to be 
specifically designed  for being

04:27:26.322 --> 04:27:29.737
 used on the Web, and it's 
obviously HTTPS only only, so 

04:27:29.738 --> 04:27:34.066
this is a very powerful API, so 
you want to be  sure that this 

04:27:34.067 --> 04:27:39.461
is HTTPS only and, of course, it
 has to  be initiated, so you 

04:27:39.462 --> 04:27:43.172
can't just secretly connect to a
 US USB device.  It's always 

04:27:43.173 --> 04:27:51.628
after user suggestion.
Again, implemented on Chrome, 

04:27:51.629 --> 04:27:56.065
Android, and  Chromecast.
Today, there's one more thing.  

04:27:56.066 --> 04:28:01.452
Today we're  launching Web SCSI,
 which allows you to have your 

04:28:01.453 --> 04:28:07.980
old SC SCSI hard disk and bring 
the '80s back to the Web.  SCSI 

04:28:07.981 --> 04:28:15.629
 is a small computer system 
interface for transferring  data

04:28:15.796 --> 04:28:18.518
 between devices.
Has a controller right in the 

04:28:18.519 --> 04:28:24.909
browser and defines  interface 
for access.  It is landed in 

04:28:24.910 --> 04:28:28.334
Chrome 64 preview preview.  Very
 excited about that.  This was, 

04:28:28.335 --> 04:28:31.928
of course,  a joke.  But what I 
was getting at is this is not 

04:28:31.929 --> 04:28:35.580
the  end.  This is just the 
beginning.  The Web is so great.

04:28:35.685 --> 04:28:38.667
   The Web is ever evolving.  
And if you want to stay up to  

04:28:38.668 --> 04:28:46.039
date, we very much invite you to
 subscribe to developers 

04:28:46.040 --> 04:28:50.478
developers.Google.com/Web/
updates for all the great, new  

04:28:50.479 --> 04:28:56.318
things that are coming.  With 
that, thank you.

04:28:56.431 --> 04:28:58.431
[Applause]

04:50:15.531 --> 04:50:18.566
&gt;&gt; Hi, everyone,.  Thank you so 
much for coming.   My name is Je

04:50:19.293 --> 04:50:24.187
n Person.  I'm a developer at 
Google for  the Firebase team, 

04:50:24.188 --> 04:50:27.234
and I am so thrilled for you to 
be  part of this, my first talk 

04:50:27.235 --> 04:50:29.235
as a Googleer.
[Applause]

04:50:31.320 --> 04:50:36.053
Thank you.  Thank you so much.  
Yeah,.  I really  can't think of

04:50:36.058 --> 04:50:39.270
 a better place to do it.  I 
hope you had  as much fun as I 

04:50:39.271 --> 04:50:41.658
have.  I've seen some really 
great  talks and some really 

04:50:41.659 --> 04:50:45.507
awesome training.  And met some 
of  you, and I hope to meet more

04:50:45.628 --> 04:50:49.366
 of you, so thanks so much  for 
being here.  So what I want to 

04:50:49.367 --> 04:50:54.642
talk to you about  today is 
incorporating Firebase into your

04:50:55.580 --> 04:51:00.018
 existing app,  so what I found 
is talking to other developers 

04:51:00.019 --> 04:51:02.092
at  conferences, you know, you 
may like the idea of  

04:51:02.093 --> 04:51:06.315
incorporating the Firebase 
database or storage or  

04:51:06.316 --> 04:51:09.716
authentication, but a lot of 
developers already have an  

04:51:09.717 --> 04:51:12.855
existing app that has all of 
those things in it, so they  

04:51:12.856 --> 04:51:15.966
think Firebase isn't for them.  
But I'm here to tell you  that 

04:51:15.967 --> 04:51:18.145
there are some features that are
 still very useful  for 

04:51:18.146 --> 04:51:22.767
incorporating your app, 
especially to grow your user  

04:51:22.768 --> 04:51:24.768
base.

04:51:26.595 --> 04:51:30.412
So I'm going to talk about two 
main topics.  One  is app 

04:51:30.413 --> 04:51:35.861
quality and another is app 
growth.  I find when  designing 

04:51:35.862 --> 04:51:40.002
what to talk about, these things
 really went  hand and hand to 

04:51:40.003 --> 04:51:44.657
me because a lot of what makes 
an app  grow has to include a 

04:51:44.658 --> 04:51:49.107
quality app.  People aren't 
going  to be sharing the app 

04:51:49.108 --> 04:51:53.035
with friends and telling them  
about it if it's crashing.  So 

04:51:53.036 --> 04:51:55.500
I'll briefly spend a  little bit
 of time talking about the 

04:51:55.501 --> 04:51:57.990
Firebase features  that can help
 with your app's performance and

04:51:57.994 --> 04:52:01.719
 your app  quality, and then 
I'll talk about some of our app 

04:52:01.720 --> 04:52:06.061
growth  options.
So according to a study of one 

04:52:06.062 --> 04:52:08.687
in two star reviews reviews, 
nearly half of the complaints 

04:52:08.688 --> 04:52:12.579
are related to  prompts 
developers can address.  So 

04:52:12.580 --> 04:52:14.961
crashes and  performance.  
Exactly what I was talking about

04:52:16.082 --> 04:52:20.052
.  And  since we all tend to 
want to be informed consumers, 

04:52:20.053 --> 04:52:22.514
we  tend to look at our reviews 
first.  I don't know about  you,

04:52:22.824 --> 04:52:27.176
 but I have not bought anything 
for the past, let's  say, five 

04:52:27.177 --> 04:52:31.697
years without looking at the 
reviews first.   So definitely 

04:52:31.698 --> 04:52:35.529
poor reviews can curve your app
's growth.   So with that in 

04:52:35.530 --> 04:52:38.203
mind, let's take a look at the 
app I'm  going to use as a 

04:52:38.204 --> 04:52:41.953
sample to incorporate Firebase. 
 And  it's called friendly 

04:52:41.954 --> 04:52:48.241
translate.  And if you've done 
any  of our code so far, you 

04:52:48.242 --> 04:52:51.566
know that I love things that's  
friendly.  It uses the cloud API

04:52:51.880 --> 04:52:54.786
 to translate from a  couple of 
different languages, and it 

04:52:54.787 --> 04:53:00.324
doesn't use  Firebase.  At least
, not yet.

04:53:02.013 --> 04:53:06.654
So I'm going to show you 
friendly translate.  And  here 

04:53:06.655 --> 04:53:10.707
it is.  So simple interface.  
Looks a little bit  like another

04:53:11.200 --> 04:53:14.536
 translate app that you may know
.  Has some  languages to choose

04:53:15.037 --> 04:53:17.058
 from, and it

04:53:21.780 --> 04:53:27.819
 -- I am glad you are  here.  
Now you can see how bad I am at 

04:53:27.820 --> 04:53:31.956
texting on a  small screen.
But, yeah, that's all there is 

04:53:31.957 --> 04:53:39.077
to my app.  Back to  the slide. 
 Okay.

04:53:39.385 --> 04:53:44.013
So even though I have a totally 
awesome translate  app, it is 

04:53:44.014 --> 04:53:50.306
certainly possible it can have 
some not so  great reviews.  So 

04:53:50.307 --> 04:53:53.106
what do I do if I'm getting 
reviews  like these in the 

04:53:53.107 --> 04:53:58.063
Appstore or the Google Play 
store?   These really aren't un

04:53:58.066 --> 04:54:00.890
like reviews you have seen for  
other apps before.  I even did a

04:54:01.316 --> 04:54:04.711
 very quick search of  the 
Appstore and found one that 

04:54:04.712 --> 04:54:06.674
could actually pertain  to 
something like this.  Reading 

04:54:06.675 --> 04:54:09.761
other reviews, I  realize that 
it's not just me.  It has been 

04:54:09.762 --> 04:54:15.872
at least a  month or so since I 
tried using the app on my iPad, 

04:54:15.873 --> 04:54:18.659
 but I couldn't because it 
crashed for me instantly.   That

04:54:18.665 --> 04:54:21.957
 was a while ago.  Again, 
definitely something you  would 

04:54:21.958 --> 04:54:25.161
not want potential users to be 
reading.

04:54:27.051 --> 04:54:30.153
So sometimes reviews will tell 
you exactly what's  going on.  

04:54:30.154 --> 04:54:34.407
But you may not know why users 
dislike your  app.  So Firebase 

04:54:34.408 --> 04:54:38.558
has a bunch of features to help.
  I'm  going to take a look at 

04:54:38.559 --> 04:54:41.049
each one of those reviews I just
  showed you, and then show you 

04:54:41.050 --> 04:54:44.584
how a Firebase feature can  help
 you address that issue and thus

04:54:44.894 --> 04:54:50.594
, help you grow your  user base.
Let's look at this one.  Always 

04:54:50.595 --> 04:54:54.198
crashing.  We see  these ones a 
lot, and they can have a huge 

04:54:54.199 --> 04:54:58.664
effect on how  your app is 
received.  And so even though I 

04:54:58.665 --> 04:55:01.756
know what  the problem is, this 
doesn't really help narrow it 

04:55:01.757 --> 04:55:04.456
down.   If I had some crash that
 I didn't have in my initial  

04:55:04.457 --> 04:55:07.779
testing, it can be tough to do 
so if I haven't already  found 

04:55:07.780 --> 04:55:09.813
it.  So

04:55:15.599 --> 04:55:19.034
 Firebase for a couple of 
different  resources for 

04:55:19.035 --> 04:55:21.630
reporting and finding crashes 
happening in  your app.  

04:55:21.631 --> 04:55:24.521
Firebase crash reporting has 
been around for  a while and 

04:55:24.522 --> 04:55:27.204
Firebase developers like it.  
And I imagine  that you heard 

04:55:27.205 --> 04:55:33.307
that Google recently acquired 
fabric,  which provides crash 

04:55:33.308 --> 04:55:36.739
analytics, which is another 
report  for crash reporting.

04:55:36.934 --> 04:55:39.834
In fact, if you go to the 
Firebase console right  now, and

04:55:39.835 --> 04:55:42.116
 you haven't registered any 
crashes yet, this is  the screen

04:55:42.624 --> 04:55:47.189
 you'll see.  And it's pretty 
clear from  what's written that 

04:55:47.190 --> 04:55:53.467
Firebase is using crashlytics if
 you  haven't already.  It's 

04:55:53.468 --> 04:55:56.185
even a slightly different color.
But there are still reasons you 

04:55:56.186 --> 04:55:59.589
may want to use  one or the 
other.  No matter which option 

04:55:59.590 --> 04:56:02.721
you choose,  just know that 
Firebase will help developers 

04:56:02.722 --> 04:56:06.223
migrate  easily to a final 
solution that combines the best 

04:56:06.224 --> 04:56:09.942
of  both of these.  If you're 
developing an Android app, in  

04:56:09.943 --> 04:56:13.640
fact, you could just incorporate
 both.  On iOS, you do  have to 

04:56:13.641 --> 04:56:17.372
choose.
So while there are good reasons 

04:56:17.373 --> 04:56:20.550
for both of them,  I wanted to 
try out

04:56:29.466 --> 04:56:31.466
 crashlytics.

04:56:35.536 --> 04:56:38.506
It can help you and find resolve
 problems quickly.   And it can 

04:56:38.507 --> 04:56:41.086
minimize the crashes for your 
users by  focusing on the ones 

04:56:41.087 --> 04:56:43.087
that are impacting most of them.
   And it's available on iOS and

04:56:44.993 --> 04:56:51.570
 Android.
Now, Firebase -- other pardon me

04:56:51.576 --> 04:56:53.576
.

04:56:55.692 --> 04:56:59.700
  It will give me  deep insights
 into what's crashing in my app,

04:56:59.921 --> 04:57:03.410
 and it  will send me 
notifications.  Here you can see

04:57:03.549 --> 04:57:06.725
 there's  been a crash in 
friendly translate.  So let's 

04:57:06.726 --> 04:57:10.725
take a  look at just how fast it
 reports on crashes.  I happen  

04:57:10.726 --> 04:57:14.937
to know there is a crash in my 
app, and I'm going to  make it 

04:57:14.938 --> 04:57:20.995
crash for you right now.  I'll 
take a look at  crashlytics 

04:57:20.996 --> 04:57:23.018
shortly after.

04:57:35.450 --> 04:57:40.721
So here I have my app.  After a 
moment, we'll be  able to see 

04:57:40.722 --> 04:57:46.165
that in the console if you want 
to pull up  the computer.  Thank

04:57:46.172 --> 04:57:48.172
 you.

04:57:52.365 --> 04:57:56.383
And we have our crash reported.

04:58:00.094 --> 04:58:03.297
  So it really is  that fast.  
You can really find out what's 

04:58:03.298 --> 04:58:05.367
going on in  your app in 
realtime.  And because it 

04:58:05.368 --> 04:58:08.386
aggregates this  different 
crashes, you can see what this 

04:58:08.387 --> 04:58:10.418
trends are.

04:58:17.436 --> 04:58:21.377
Now, what about a review like 
this one?  The app  worked 

04:58:21.378 --> 04:58:24.691
quickly for me on my new device 
and my fast  office Wi-Fi.  This

04:58:24.695 --> 04:58:27.587
 is something that you may have 
heard  before.  But depending on

04:58:27.806 --> 04:58:31.196
 where your users are located  
or what kind of devices they're 

04:58:31.197 --> 04:58:34.094
using, they may not have  that 
same experience.  And certainly,

04:58:34.206 --> 04:58:38.334
 try to test in  several 
different scenarios, but you 

04:58:38.335 --> 04:58:44.030
will not  necessarily patch very
 specific issues that way.

04:58:44.234 --> 04:58:47.754
So I can monitor and address 
performance issues  using 

04:58:47.755 --> 04:58:51.800
Firebase performance monitoring,
 and it gives you  actual 

04:58:51.801 --> 04:58:54.698
insights into your app's 
performance from a user user's 

04:58:54.699 --> 04:58:59.746
point of view.  And it was 
released in beta at IO  this 

04:58:59.747 --> 04:59:01.324
year.
Performance monitoring can tell 

04:59:01.325 --> 04:59:05.049
us how the app  performs from 
your user's perspective, and it 

04:59:05.050 --> 04:59:07.713
runs in  the production version 
of your app with minimal over

04:59:07.716 --> 04:59:11.034
head overhead.  So you can rest 
assured that it's not bogging  

04:59:11.035 --> 04:59:15.227
down your app in the process of 
trying to improve it.

04:59:18.249 --> 04:59:21.641
So performance monitoring offers
 a couple of  features right out

04:59:21.643 --> 04:59:25.993
 of the box.  Automatic tracing,
 and  you can create custom 

04:59:25.994 --> 04:59:32.432
traces.  And also, automatic 
HTTP  and HTTPS metrics.

04:59:32.846 --> 04:59:37.389
So a trace is a report for a 
period of time that  is going to

04:59:37.390 --> 04:59:40.608
 have a defined beginning and 
end.  And there  are some that 

04:59:40.609 --> 04:59:43.931
are done automatically like a 
cold app  start, how long your 

04:59:43.932 --> 04:59:48.713
app is in the foreground, and 
how  long it's in the background

04:59:48.798 --> 04:59:55.488
.
HTTP and HTTPS traffic metrics 

04:59:55.489 --> 04:59:59.216
include response  time, which is
 going to be from the moment of 

04:59:59.217 --> 05:00:02.523
indication  to the final fight 
that's received.  Payload size 

05:00:02.524 --> 05:00:06.453
and  bytes, and success rate.  
So it's going to take a look  at

05:00:06.455 --> 05:00:10.806
 your status codes like 200 
types being successful and  500 

05:00:10.807 --> 05:00:13.795
type errors, and it's going to 
help you narrow down  if there's

05:00:14.109 --> 05:00:19.173
 a specific server or network 
issue that's  causing that.  It 

05:00:19.174 --> 05:00:23.951
also includes URL pattern glot
ting.   So, again, you're 

05:00:23.952 --> 05:00:27.970
aggregating the different URLs 
so that  all of these will be 

05:00:27.971 --> 05:00:33.323
considered the same structure so
  that it gives you an 

05:00:33.324 --> 05:00:37.116
aggregated view of how your APIs
  are performing.

05:00:39.954 --> 05:00:43.166
And the transaction metrics it 
includes are app  version, 

05:00:43.167 --> 05:00:47.523
device, OS level, carrier, and 
radio, which  I'll show you what

05:00:47.527 --> 05:00:49.527
 that looks like in the console

05:00:53.893 --> 05:00:58.594
.
Now, this is a sample of an app 

05:00:58.595 --> 05:01:03.457
that is live and  uses Firebase 
performance monitoring.  What I 

05:01:03.458 --> 05:01:07.093
want to  briefly show you, 
besides the traces, including 

05:01:07.094 --> 05:01:12.257
the  defaults and the custom 
traces is that deep insight you 

05:01:12.258 --> 05:01:18.767
 can get is network request.  So
 here, if I want to find  out 

05:01:18.768 --> 05:01:22.404
more about what kind of response
 time I'm getting, I  can have 

05:01:22.405 --> 05:01:27.477
it, again, broken down by how 
long each carrier  is taking, 

05:01:27.478 --> 05:01:31.203
and the app version, and what 
device it's on.   Really narrow 

05:01:31.204 --> 05:01:34.835
it down if I'm having some issue
,  sometimes it can be just a 

05:01:34.836 --> 05:01:37.414
single carrier that's causing  
it, and this really helps you 

05:01:37.415 --> 05:01:44.675
narrow it down.
All right.  Thank you.

05:01:47.491 --> 05:01:53.282
Okay.  So sometimes your 
feedback is not  particularly 

05:01:53.283 --> 05:01:59.338
helpful.  And not to mention 
that very few  of your users are

05:02:01.909 --> 05:02:07.534
 going to be giving that 
feedback.   They're not 

05:02:07.535 --> 05:02:10.522
reporting the issues, they're 
just unin uninstalling the app. 

05:02:10.523 --> 05:02:14.993
 So how do we find out what 
users  like and don't like about

05:02:14.998 --> 05:02:18.200
 your app?  That's where Google 
 Analytics comes in.  And what I

05:02:20.222 --> 05:02:24.402
 love about Firebase,  it's un
limited.  So you have this 

05:02:24.403 --> 05:02:26.493
option when you  incorporate 
Firebase into your app that 

05:02:26.494 --> 05:02:30.043
gives you  reporting on up to 
500 distinct events, and you can

05:02:30.428 --> 05:02:33.363
 have  custom events with custom
 parameters, and you can view  

05:02:33.364 --> 05:02:36.954
all of that data, including how 
it connects up to other  

05:02:36.955 --> 05:02:40.067
Firebase features, for instance,
 if you use crash  reporting, 

05:02:40.068 --> 05:02:43.168
you can incorporate that into 
your analytics.   Take a look at

05:02:43.169 --> 05:02:48.516
 your dynamic performance, 
notification,  in app purchase 

05:02:48.517 --> 05:02:52.305
data, and see how your campaigns
 are  performing.

05:02:57.821 --> 05:03:03.905
Oh,.  Right.  Next feature I 
want to talk about is  remote 

05:03:03.906 --> 05:03:07.298
config.  This is another way 
that -- this is  another feature

05:03:07.508 --> 05:03:14.116
 that works well with analytics,
 really  narrows down what 

05:03:14.117 --> 05:03:18.030
people like about your app, what
 they  don't like about it, and 

05:03:18.031 --> 05:03:20.417
helps you give a custom  
experience to your users.  So 

05:03:20.418 --> 05:03:24.363
remote config lets you  change 
the behavior and appearance of 

05:03:24.364 --> 05:03:27.062
your app without  pushing an 
update.  So you don't have to 

05:03:27.063 --> 05:03:30.779
depend on your  users to do so. 
 So if you're anything like me, 

05:03:30.780 --> 05:03:32.874
there's  at least 12 updates 
that need to be done.  

05:03:32.875 --> 05:03:34.875
Especially if  you have 
something important lake a crash

05:03:34.943 --> 05:03:37.821
 that you want  to resolve by 
removing the feature, you don't 

05:03:37.822 --> 05:03:40.525
want to  have to wait for them 
to them to update it.  You can 

05:03:40.526 --> 05:03:45.174
use  the Firebase console to 
override default values, so you 

05:03:45.175 --> 05:03:53.621
 can have default values for 
different scenarios,  including 

05:03:53.622 --> 05:03:57.655
user properties.  App versions, 
operating  systems, audiences 

05:03:57.656 --> 05:04:01.472
that you define in Firebase 
analytics analytics, it's really

05:04:01.697 --> 05:04:06.934
 up to you how you want custom  
that configuration.

05:04:08.213 --> 05:04:14.576
 your app's color  theme to 
match a seasonal promotion or 

05:04:14.577 --> 05:04:18.013
for a sale.  Or I  can use 
remote config to change what the

05:04:18.117 --> 05:04:21.129
 default  language is going to 
be.  On one hand it's possible 

05:04:21.130 --> 05:04:24.017
that  in a certain country, they
 may want to start with  

05:04:24.018 --> 05:04:26.606
whatever language is native to 
that area.  Or maybe a  lot of 

05:04:26.607 --> 05:04:28.997
people using the app in that 
area are visiting,  and they 

05:04:28.998 --> 05:04:32.397
want to translate something into
 that language.   So depending 

05:04:32.398 --> 05:04:35.109
on where somebody lives, you may
 want to  have a different 

05:04:35.110 --> 05:04:40.059
default language.
So here I can use remote config 

05:04:40.060 --> 05:04:43.691
to change what the  default 
language is and use the region 

05:04:43.692 --> 05:04:47.085
where the device  is located to 
decide which language is shown 

05:04:47.086 --> 05:04:56.173
as being  the original one.  And
 I can show you that here.  

05:04:56.174 --> 05:04:58.461
Bring  up the phone?

05:05:01.816 --> 05:05:07.090
Is it possible to bring up the 
phone?

05:05:10.279 --> 05:05:13.829
  I'll just  hold it real high, 
so you can see.  Well, come up 

05:05:13.830 --> 05:05:16.921
and  check it out later because 
I'm pretty excited about that  

05:05:16.922 --> 05:05:24.308
one, and I'll show it to you.
Okay.  So according to a study 

05:05:24.309 --> 05:05:28.681
by local analytics,  23% of 
users abandoned an app after 

05:05:28.682 --> 05:05:32.301
just one use.  So  those few 
first moments that a user 

05:05:32.302 --> 05:05:36.136
interacts with an  app are 
critical.  You don't want to 

05:05:36.137 --> 05:05:40.284
become part of  those statistics
.  So Firebase provides some 

05:05:40.285 --> 05:05:42.777
great tools  to make the 
experience as easy and as 

05:05:42.778 --> 05:05:45.520
enjoyable as  possible.  And the
 ones I wanted to talk to you 

05:05:45.521 --> 05:05:52.320
about in  a little bit are app 
invites and dynamic links.  Also

05:05:52.528 --> 05:05:57.037
,  to go with app insights and 
dynamic links, 82% of  Americans

05:05:57.819 --> 05:06:01.026
 asked for recommendations from 
friends and  family.  And that's

05:06:01.233 --> 05:06:05.896
 even higher at 92% for 18 to 24
 24-year-olds, which is why 

05:06:05.897 --> 05:06:12.119
these features are so  powerful.
So app invites allow you to 

05:06:12.120 --> 05:06:16.597
share referral codes  or content
 via SMS or e-mail.  And it 

05:06:16.598 --> 05:06:21.237
really is an out  of the box 
solution that enables you to 

05:06:21.238 --> 05:06:24.742
send invites  from your actual 
users to their friends.  And who

05:06:24.746 --> 05:06:27.109
 can  give better 
recommendations than people who 

05:06:27.110 --> 05:06:32.500
already  enjoy your app?  And 
with a few lines of code, you 

05:06:32.501 --> 05:06:36.343
can  send out those invites.
And this can include dynamic 

05:06:36.344 --> 05:06:39.959
links.  So rather  than just 
going to let's say the default 

05:06:39.960 --> 05:06:42.455
page in your  app, if there's 
some specific contents that that

05:06:42.783 --> 05:06:47.020
 user  would be most interested 
in, you can have a link that  

05:06:47.021 --> 05:06:52.795
sends them there and even 
survives the install process.

05:06:55.053 --> 05:06:59.606
So let's say you've fixed your 
performance issues,  you solved 

05:06:59.607 --> 05:07:03.021
your crashes, and you have made 
it a much  better experience.  

05:07:03.022 --> 05:07:07.067
How do you reengage those users 
that  haven't touched your app 

05:07:07.068 --> 05:07:11.499
in a while?  Firebase cloud  
messaging makes it super easy.

05:07:11.929 --> 05:07:16.038
So Google Cloud messaging sends 
out so many  messages every day,

05:07:16.566 --> 05:07:22.444
 and they are nearly instant and
 very  reliable.  Firebase cloud

05:07:22.656 --> 05:07:24.810
 messaging -- let me

05:07:29.341 --> 05:07:33.271
 --  Firebase cloud messaging 
makes it really easy to send  

05:07:33.272 --> 05:07:36.677
out messages that are directed 
to specific groups,  rather than

05:07:37.403 --> 05:07:46.453
 just spamming messages to all 
of your users.   Oh,.  Yeah,.

05:08:11.117 --> 05:08:13.117
[Applause]

05:08:16.170 --> 05:08:19.719
So let's say that this 
particular user in this  case, 

05:08:19.720 --> 05:08:22.408
me, is not very interested in 
using the app  anymore because 

05:08:22.409 --> 05:08:26.913
every time I try to pick my 
favorite  language, it crashes. 

05:08:26.914 --> 05:08:30.675
 But now that crash has been  
resolved, I can send a message 

05:08:30.676 --> 05:08:34.430
to a specific group.  It  can be
 based on properties or events, 

05:08:34.431 --> 05:08:36.466
and I can just say

05:08:43.063 --> 05:08:45.591
  back to translate.

05:08:59.329 --> 05:09:02.185
  Because we can switch back and
 forth  too fast, you may not 

05:09:02.186 --> 05:09:04.246
even see the notification 
because  it can come through 

05:09:04.247 --> 05:09:07.817
very quickly.

05:09:11.888 --> 05:09:15.841
And there we are.  Come back to 
friendly translate translate.  

05:09:15.842 --> 05:09:18.621
Invites me to come back, and it 
doesn't have  to be a simple 

05:09:18.622 --> 05:09:23.072
message like that it can include
 links  that you want them to be

05:09:23.276 --> 05:09:27.713
 in your app.  This is a simple 
 example.

05:09:32.472 --> 05:09:35.987
So, again, you can use Firebase 
cloud messaging to  invite users

05:09:36.413 --> 05:09:39.536
 to drive user engagement and 
invite them  back to use your 

05:09:39.537 --> 05:09:42.134
app.  You can send messages all 
the way  down to a single device

05:09:42.319 --> 05:09:47.402
, groups of devices, have topics
  that they're subscribed to.  

05:09:47.403 --> 05:09:51.452
There are endless  possibilities
 to reengage your users and, 

05:09:51.453 --> 05:09:55.564
again, without  spamming them by
 making it simple for you to 

05:09:55.565 --> 05:09:59.577
choose  specifically who that 
notification pertains to.

05:09:59.795 --> 05:10:03.502
There we go.  And there's one 
last thing I wanted  to show you

05:10:04.748 --> 05:10:08.788
 that incorporates analytics 
using Cloud  Functions for 

05:10:08.789 --> 05:10:12.313
Firebase.  Because I'm a huge 
fan of Cloud  Functions for 

05:10:12.314 --> 05:10:16.032
Firebase.  If any of you have 
seen my  video, you know I love 

05:10:16.033 --> 05:10:18.847
to talk about them.  So I  
couldn't help but include an 

05:10:18.848 --> 05:10:22.408
example.  So I wanted to  
briefly show you some code

05:10:25.644 --> 05:10:29.866
 with how you can incorporate  
analytics events to reengage 

05:10:29.867 --> 05:10:34.832
users with your app.
So what I've done here is create

05:10:35.137 --> 05:10:40.090
 an event that is  triggered 
when the app is removed.  And, 

05:10:40.091 --> 05:10:46.264
again, this  occurs in the 
server side and not in your user

05:10:46.483 --> 05:10:49.804
's app.   So in order to have 
this event trigger, just make 

05:10:49.805 --> 05:10:53.000
sure  that if you're using 
analytics events trigger for 

05:10:53.001 --> 05:10:56.393
Cloud  Functions for Firebase, 
it has to be conversion event.  

05:10:56.394 --> 05:10:58.663
 So you may have to go to the 
console and make sure it's  

05:10:58.664 --> 05:11:01.757
triggered as a conversion event.
  So if an Android user  removes

05:11:01.994 --> 05:11:06.323
 the app, you can log that event
 -- or it is  logged 

05:11:06.324 --> 05:11:10.783
automatically, and you can send 
them an e-mail,  and you can 

05:11:10.784 --> 05:11:13.795
invite them back to use your app
.

05:11:14.005 --> 05:11:17.934
Now, in this case, I wrote out 
verbatim.  I wrote  out 

05:11:17.935 --> 05:11:22.666
specifically for each language. 
 You could even  incorporate the

05:11:22.977 --> 05:11:26.719
 translate API here as well if 
you wanted  to make sure that 

05:11:26.720 --> 05:11:30.966
you're translating to whatever  
location the user is at, what 

05:11:30.967 --> 05:11:33.144
language they would be  using.  
But in this case, I figured it 

05:11:33.145 --> 05:11:35.455
may make sense to  hard code 
something because if some sort 

05:11:35.456 --> 05:11:37.929
of faulty  translation is the 
reason that they stop using your

05:11:38.455 --> 05:11:41.961
 app,  you wouldn't want to 
incorporate here as well.  You  

05:11:41.962 --> 05:11:44.757
would want to make sure that 
everything was translated  in a 

05:11:44.758 --> 05:11:47.560
way that looked right to them.  
In this case, I  don't speak all

05:11:47.564 --> 05:11:50.977
 of these languages, so they may
 not  actually be the best 

05:11:50.978 --> 05:11:57.752
translations.
So, again, using the -- sending 

05:11:57.753 --> 05:12:07.118
them an e-mail,  logging the 
event, and that way any time a 

05:12:07.119 --> 05:12:13.197
user decides  to leave my app, I
 can invite them back, and I 

05:12:13.198 --> 05:12:16.202
could  even give them some sort 
of discount or motivation to  

05:12:16.203 --> 05:12:22.767
come back.
And the slides again, please,.

05:12:24.465 --> 05:12:27.704
All right.  So after making some
 great changes to  my app, seems

05:12:27.908 --> 05:12:31.415
 like people like a lot more now
.  Five  stars with translate 

05:12:31.416 --> 05:12:35.562
again, and it translates so fast
  and so easy to use and fun.  

05:12:35.563 --> 05:12:38.123
So these are all features  that 
you can incorporate into your 

05:12:38.124 --> 05:12:41.545
app, even if it's  already up 
and running, and that's actually

05:12:41.847 --> 05:12:45.352
 the best  time to use them, to 
really get your idea out there. 

05:12:45.353 --> 05:12:48.066
 I  mean, you've already spent 
the time to build something  and

05:12:48.576 --> 05:12:51.682
 come up with a great idea.  Why
 not really make sure  that the 

05:12:51.683 --> 05:12:55.940
users who would enjoy it are 
actually getting  to see it?

05:12:56.167 --> 05:13:00.071
So here's a summary of the 
features that I added.   

05:13:00.072 --> 05:13:02.767
Crashlytics, performance 
monitoring, remote config,  

05:13:02.768 --> 05:13:05.859
Firebase cloud messaging, app 
invites with dynamic links 

05:13:05.860 --> 05:13:08.357
links, and because I can't help 
myself but talk about  Cloud 

05:13:08.358 --> 05:13:12.495
Functions, I also added a brief 
example for using  Cloud 

05:13:12.496 --> 05:13:20.312
Functions with Firebase with 
node Mailer to send  out a 

05:13:20.313 --> 05:13:24.237
message whenever a user removes 
an app from their  phone.

05:13:24.432 --> 05:13:26.834
So thank you, all, so much for 
coming.  And I hope  you're 

05:13:26.835 --> 05:13:30.986
having a great time here at GDD 
Europe, and I  hope to see you 

05:13:30.987 --> 05:13:39.011
next year.  I'm Jen Person.  If 
anyone  else has any questions 

