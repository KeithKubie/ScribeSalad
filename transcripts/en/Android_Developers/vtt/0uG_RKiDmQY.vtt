WEBVTT
Kind: captions
Language: en

00:00:00.500 --> 00:00:03.690
[GOOGLE LOGO MUSIC]

00:00:03.690 --> 00:00:05.790
XIAOWEN XIN: Now, I
first tried out Android

00:00:05.790 --> 00:00:07.940
when I tried out the
HTC Dream phone, which

00:00:07.940 --> 00:00:10.530
was the first commercial device
that launched with Android not

00:00:10.530 --> 00:00:12.540
more than 10 years ago.

00:00:12.540 --> 00:00:16.410
At launch, Android was known for
its transparency and openness,

00:00:16.410 --> 00:00:19.480
and we still stand by
these principles today.

00:00:19.480 --> 00:00:21.480
And since then, Android
has made its way

00:00:21.480 --> 00:00:23.880
into the hands of
billions of consumers

00:00:23.880 --> 00:00:27.180
and some of the most demanding
enterprise environments.

00:00:27.180 --> 00:00:30.780
And in order to protect all
of our users and their data,

00:00:30.780 --> 00:00:32.790
security is a top priority.

00:00:32.790 --> 00:00:34.610
And we're making
measurable progress

00:00:34.610 --> 00:00:38.880
in raising the bar across
the mobile ecosystem.

00:00:38.880 --> 00:00:41.267
We run a vulnerability
rewards program,

00:00:41.267 --> 00:00:43.350
which is a bounty program
with some of the highest

00:00:43.350 --> 00:00:48.480
payouts in the industry, paying
up to $200,000 for a security

00:00:48.480 --> 00:00:51.710
exploit chain that
compromises your device.

00:00:51.710 --> 00:00:54.420
High rewards plus
our open source code

00:00:54.420 --> 00:00:57.120
fosters a vibrant
community of researchers

00:00:57.120 --> 00:01:01.980
who help us find bugs before
they affect our users.

00:01:01.980 --> 00:01:05.410
And in 2018, there were
zero critical security

00:01:05.410 --> 00:01:08.740
vulnerabilities affecting
the Android platform that

00:01:08.740 --> 00:01:11.470
were publicly disclosed
without a security update

00:01:11.470 --> 00:01:14.310
or mitigation available.

00:01:14.310 --> 00:01:17.890
As another data point,
there are a number

00:01:17.890 --> 00:01:21.040
of vulnerability discovery
and disclosure competitions

00:01:21.040 --> 00:01:24.190
that invite hackers from around
the world to come and break

00:01:24.190 --> 00:01:26.620
mobile devices and are paid
up to hundreds of thousands

00:01:26.620 --> 00:01:28.840
of dollars to do so.

00:01:28.840 --> 00:01:30.970
At [INAUDIBLE],, I
own, which is one

00:01:30.970 --> 00:01:33.430
of the most well-known
competitions of this kind,

00:01:33.430 --> 00:01:35.650
Google Pixel has a
great track record

00:01:35.650 --> 00:01:39.240
of being unbroken
year after year.

00:01:39.240 --> 00:01:41.660
Now, we know that these
results were achieved

00:01:41.660 --> 00:01:44.930
on fully patched,
up-to-date devices

00:01:44.930 --> 00:01:47.180
and that the ability
to patch a device

00:01:47.180 --> 00:01:50.180
is critical to its
security posture.

00:01:50.180 --> 00:01:52.250
And we're doing a lot
to increase patch rates

00:01:52.250 --> 00:01:54.230
across the ecosystem.

00:01:54.230 --> 00:01:57.440
At the technical level, we've
re-architected the operating

00:01:57.440 --> 00:02:01.520
system to make patching easy
for device makers and seamless

00:02:01.520 --> 00:02:03.650
for users-- to make updates
easy for device makers

00:02:03.650 --> 00:02:05.810
and seamless for users.

00:02:05.810 --> 00:02:08.930
And beyond the technical level,
our ecosystem of partners

00:02:08.930 --> 00:02:11.077
have come together to form
a strong collaboration

00:02:11.077 --> 00:02:12.035
and to remove barriers.

00:02:15.550 --> 00:02:20.760
And in Q4 of 2018, we saw 84%
more devices receive a security

00:02:20.760 --> 00:02:25.460
update compared to
Q4 the prior year.

00:02:25.460 --> 00:02:28.330
Now, we know that security
threats come in many forms,

00:02:28.330 --> 00:02:30.580
and some of them, like
phishing and spyware,

00:02:30.580 --> 00:02:32.470
don't need to actually
compromise your device

00:02:32.470 --> 00:02:36.730
and bypass the security
model in order to harm users.

00:02:36.730 --> 00:02:38.890
So Android devices
with Google services

00:02:38.890 --> 00:02:43.570
have Google Play Protect built
in and enabled by default.

00:02:43.570 --> 00:02:46.540
We leverage a combination
of human security expertise

00:02:46.540 --> 00:02:49.870
and state-of-the-art machine
learning to find potentially

00:02:49.870 --> 00:02:52.360
harmful apps before
they find our users.

00:02:55.100 --> 00:02:59.550
And in 2018, we saw a 20%
year-over-year decline

00:02:59.550 --> 00:03:01.590
in the proportion of
devices that installed

00:03:01.590 --> 00:03:04.120
a potentially harmful app.

00:03:04.120 --> 00:03:08.020
All of this data plus a lot more
is available in our annual Year

00:03:08.020 --> 00:03:09.980
In Review report.

00:03:09.980 --> 00:03:12.640
We also publish a quarterly
transparency report

00:03:12.640 --> 00:03:15.960
with details on the overall
health of the ecosystem.

00:03:15.960 --> 00:03:18.730
To find links to these
reports along with a lot more

00:03:18.730 --> 00:03:21.750
information, visit the Android
Security Center website

00:03:21.750 --> 00:03:26.390
at Android.com/Security.

00:03:26.390 --> 00:03:26.940
OK.

00:03:26.940 --> 00:03:30.960
So that was a quick overview
of how we're doing today.

00:03:30.960 --> 00:03:33.180
Now, developers in the
audience and everyone else

00:03:33.180 --> 00:03:34.890
in the audience
probably came here

00:03:34.890 --> 00:03:37.960
to learn more about
what's new in Android Q.

00:03:37.960 --> 00:03:40.050
And there were a lot of changes.

00:03:40.050 --> 00:03:42.360
They fall under
three categories--

00:03:42.360 --> 00:03:48.290
privacy, updatability,
and hardening.

00:03:48.290 --> 00:03:50.450
Now, privacy's a huge
focus area for us

00:03:50.450 --> 00:03:53.030
and has been for many years.

00:03:53.030 --> 00:03:55.820
We made dozens of changes across
all aspects of the operating

00:03:55.820 --> 00:03:57.880
system.

00:03:57.880 --> 00:04:00.210
We're giving users a lot
more transparency over access

00:04:00.210 --> 00:04:01.830
to their data.

00:04:01.830 --> 00:04:04.775
We're giving users more
control over their location

00:04:04.775 --> 00:04:06.150
and then with
further restricting

00:04:06.150 --> 00:04:09.000
app access to persistent
device identifiers.

00:04:09.000 --> 00:04:11.890
Now, this is just the
tip of the iceberg.

00:04:11.890 --> 00:04:13.710
There was a talk
yesterday at I/O

00:04:13.710 --> 00:04:16.170
focused on privacy for Android.

00:04:16.170 --> 00:04:20.820
So take a look at the recording
for that to learn more.

00:04:20.820 --> 00:04:23.370
Next, updatability.

00:04:23.370 --> 00:04:26.340
We're building upon the momentum
that we started with Project

00:04:26.340 --> 00:04:28.080
Treble a couple of years ago.

00:04:28.080 --> 00:04:31.540
And this year, we
launched Project Mayline.

00:04:31.540 --> 00:04:35.880
With Project Mayline, a
few system components,

00:04:35.880 --> 00:04:37.830
including some
security-critical ones,

00:04:37.830 --> 00:04:40.820
will now be updated
directly by Google.

00:04:40.820 --> 00:04:43.470
So for example, the
media frameworks,

00:04:43.470 --> 00:04:47.840
which accounted for about 40%
of the bugs that were patched

00:04:47.840 --> 00:04:50.730
in last year's monthly
security bulletin,

00:04:50.730 --> 00:04:54.090
will now be updated by Google
on all new devices that

00:04:54.090 --> 00:04:57.680
launch with Android
Q. And device makers

00:04:57.680 --> 00:04:59.600
can also choose
to have Conscrypt,

00:04:59.600 --> 00:05:02.630
which is Android's TLS
provider, also updated directly

00:05:02.630 --> 00:05:04.640
by Google.

00:05:04.640 --> 00:05:08.430
With this in place, future
bugs affecting these components

00:05:08.430 --> 00:05:10.730
can now be fixed
much more quickly

00:05:10.730 --> 00:05:13.070
across the entire
ecosystem, so we don't

00:05:13.070 --> 00:05:16.190
leave our users vulnerable.

00:05:16.190 --> 00:05:19.550
To learn more about this, we
published a blog post yesterday

00:05:19.550 --> 00:05:21.890
on the Android Developers
blog, so take a look

00:05:21.890 --> 00:05:26.240
at that to find out more.

00:05:26.240 --> 00:05:27.535
And finally, hardening.

00:05:30.340 --> 00:05:32.140
Android leads the
ecosystem in leveraging

00:05:32.140 --> 00:05:35.460
compiler-level mitigations such
as sanitizers, control flow

00:05:35.460 --> 00:05:38.310
integrity, and Hardware
ASan, and many more

00:05:38.310 --> 00:05:40.590
to harden the operating system.

00:05:40.590 --> 00:05:42.960
In Android Q, we
expanded the usage

00:05:42.960 --> 00:05:45.170
of these techniques
in the kernel

00:05:45.170 --> 00:05:48.120
as well as the most critical
parts of the user space

00:05:48.120 --> 00:05:51.540
to significantly reduce the
potential exploitability

00:05:51.540 --> 00:05:54.450
of bugs in these areas.

00:05:54.450 --> 00:05:58.360
Now, these hardening tools
can also be leveraged by apps.

00:05:58.360 --> 00:06:01.960
For example, for apps that
target the Android Q API level,

00:06:01.960 --> 00:06:05.290
you'll now have execute-only
memory enabled by default.

00:06:05.290 --> 00:06:08.800
This marks executable
memory regions

00:06:08.800 --> 00:06:12.590
as not readable, which
strengthens ASLR, Address Space

00:06:12.590 --> 00:06:14.620
Layout Randomization.

00:06:14.620 --> 00:06:16.360
To learn more
about hardening, we

00:06:16.360 --> 00:06:18.890
have a blog post coming out
in the next couple of days

00:06:18.890 --> 00:06:22.250
to the Android Developers Blog.

00:06:22.250 --> 00:06:23.260
OK.

00:06:23.260 --> 00:06:26.770
So that was a quick overview
of how the operating system is

00:06:26.770 --> 00:06:29.468
becoming even more secure
with Android Q. Now,

00:06:29.468 --> 00:06:31.510
the developers in the
audience probably came here

00:06:31.510 --> 00:06:33.250
to learn more about
what we can do

00:06:33.250 --> 00:06:34.470
to make our apps more secure.

00:06:37.860 --> 00:06:40.290
So last year we launched
industry-leading APIs

00:06:40.290 --> 00:06:42.900
such as Strongbox and
Protected Confirmation.

00:06:42.900 --> 00:06:46.210
And this year we're
building upon that momentum.

00:06:46.210 --> 00:06:48.550
So for the remainder
of this session,

00:06:48.550 --> 00:06:51.990
we'll cover a few
topics in encryption,

00:06:51.990 --> 00:06:57.540
in application signing keys,
and then user authentication.

00:06:57.540 --> 00:07:00.580
We'll also cover a couple of
really exciting areas, a couple

00:07:00.580 --> 00:07:03.420
of really big areas that
we're working on that promise

00:07:03.420 --> 00:07:07.180
to be very impactful
in the future.

00:07:07.180 --> 00:07:07.830
OK.

00:07:07.830 --> 00:07:09.450
Let's now dive into
the first topic--

00:07:09.450 --> 00:07:10.812
encryption.

00:07:10.812 --> 00:07:13.020
This is an area where we've
gotten a lot of questions

00:07:13.020 --> 00:07:15.120
from developers over the years.

00:07:15.120 --> 00:07:18.100
Developers want to know, is
my data actually encrypted

00:07:18.100 --> 00:07:19.900
on the device?

00:07:19.900 --> 00:07:23.400
Now, the answer has always
been fairly complicated.

00:07:23.400 --> 00:07:25.440
While the vast majority
of new Android devices

00:07:25.440 --> 00:07:28.440
fully encrypt user
data, there are a number

00:07:28.440 --> 00:07:31.500
of low-end devices such
as Android Go devices sold

00:07:31.500 --> 00:07:35.790
primarily in developing markets
that use low-end hardware

00:07:35.790 --> 00:07:39.260
and don't have hardware
acceleration for encryption.

00:07:39.260 --> 00:07:40.760
And so encryption
on those devices

00:07:40.760 --> 00:07:45.510
causes noticeable slowdowns and
makes the device hard to use.

00:07:45.510 --> 00:07:48.710
And this affects not just phones
and not just Android devices.

00:07:48.710 --> 00:07:51.050
Smartwatches, Internet
of Things appliances,

00:07:51.050 --> 00:07:52.820
and similar smart,
connected devices

00:07:52.820 --> 00:07:55.780
often reuse the same
hardware as in phones.

00:07:55.780 --> 00:07:59.800
And so they inherit the
same hardware limitations.

00:07:59.800 --> 00:08:01.870
To address this, we
set out to create

00:08:01.870 --> 00:08:03.820
an encryption mode
that can run fast

00:08:03.820 --> 00:08:06.620
without additional hardware.

00:08:06.620 --> 00:08:09.360
And the result is Adiantum.

00:08:09.360 --> 00:08:11.790
Adiantum is a new
encryption mode

00:08:11.790 --> 00:08:14.640
created by Google engineers
and cryptographers designed

00:08:14.640 --> 00:08:19.600
specifically for disk encryption
on low-end ARM devices.

00:08:19.600 --> 00:08:22.170
It has a couple of
very nice properties.

00:08:22.170 --> 00:08:26.900
First, Adiantum was designed
to run using only operations

00:08:26.900 --> 00:08:29.340
that all CPUs natively
support, so it

00:08:29.340 --> 00:08:31.650
doesn't need digital hardware.

00:08:31.650 --> 00:08:35.640
And our benchmarks running
purely on CPUs, Adiantum

00:08:35.640 --> 00:08:39.809
runs five times as
fast as AES, which

00:08:39.809 --> 00:08:43.020
is the standard cipher
used on Android today.

00:08:43.020 --> 00:08:46.180
And so, besides being fast,
from a security perspective,

00:08:46.180 --> 00:08:49.860
Adiantum only uses well known
cryptographic primitives

00:08:49.860 --> 00:08:52.600
with well known
security properties.

00:08:52.600 --> 00:08:54.740
And because we developed
it fully in the open,

00:08:54.740 --> 00:08:56.880
we got a lot of
input and feedback

00:08:56.880 --> 00:09:00.210
from the worldwide community
of security researchers

00:09:00.210 --> 00:09:03.310
to help us make sure
that it works correctly.

00:09:03.310 --> 00:09:06.260
And so besides being
fast and being secure,

00:09:06.260 --> 00:09:10.490
Adiantum now levels the playing
field for all Android users.

00:09:10.490 --> 00:09:14.870
While high-end, premium devices
with specialized hardware

00:09:14.870 --> 00:09:17.090
will always have
an edge in speed

00:09:17.090 --> 00:09:19.370
as well as some
security properties,

00:09:19.370 --> 00:09:23.690
low-end devices now also have
a tool to help them encrypt

00:09:23.690 --> 00:09:24.980
and secure their user data.

00:09:27.980 --> 00:09:32.650
So now with Android Q,
100% of compatible devices

00:09:32.650 --> 00:09:35.200
launching with Q will
now encrypt user data

00:09:35.200 --> 00:09:36.790
with no exceptions.

00:09:36.790 --> 00:09:40.690
So this includes all form
factors supported by Android,

00:09:40.690 --> 00:09:42.730
including the phone
in your pocket,

00:09:42.730 --> 00:09:45.010
the tablets that your
kids may be playing with,

00:09:45.010 --> 00:09:47.860
the Android-based TV that
may be in your living room,

00:09:47.860 --> 00:09:51.040
and the Android Auto-based
car that you may be driving.

00:09:51.040 --> 00:09:53.650
So this is a huge
milestone for Android.

00:09:53.650 --> 00:09:55.570
And beyond Android, it's
also a huge milestone

00:09:55.570 --> 00:09:57.890
for the entire community.

00:09:57.890 --> 00:09:59.890
Adiantum is fully
open sourced and has

00:09:59.890 --> 00:10:02.520
been merged into Linux 5.0.

00:10:02.520 --> 00:10:05.710
And so in today's world, where
computation is increasingly

00:10:05.710 --> 00:10:09.850
moving to the edge, often
to low-power devices,

00:10:09.850 --> 00:10:13.300
device makers, regardless of
whether your device is running

00:10:13.300 --> 00:10:15.700
Android or not,
now have a new tool

00:10:15.700 --> 00:10:17.000
to help secure your user data.

00:10:19.760 --> 00:10:20.360
OK.

00:10:20.360 --> 00:10:23.480
So Adiantum is great
for new devices,

00:10:23.480 --> 00:10:25.310
but device makers
in the audience,

00:10:25.310 --> 00:10:27.770
you probably have apps that
need to run on older devices

00:10:27.770 --> 00:10:29.242
as well.

00:10:29.242 --> 00:10:30.950
And so you need a
solution for encryption

00:10:30.950 --> 00:10:33.080
that runs everywhere.

00:10:33.080 --> 00:10:35.210
Now, unfortunately,
writing an encryption layer

00:10:35.210 --> 00:10:38.090
is far from easy and
mistakes are common,

00:10:38.090 --> 00:10:40.610
mistakes such as
reusing nonces or not

00:10:40.610 --> 00:10:44.080
having enough entropy
in your key generation.

00:10:44.080 --> 00:10:46.820
And what's worse is that these
mistakes often go unnoticed

00:10:46.820 --> 00:10:49.410
until an incident happens.

00:10:49.410 --> 00:10:52.890
And so, this year, in
order to make that easier,

00:10:52.890 --> 00:10:56.024
we have built a security
library into Jetpack.

00:10:56.024 --> 00:10:58.920
[APPLAUSE]

00:10:58.920 --> 00:11:01.430
Thank you.

00:11:01.430 --> 00:11:03.770
The Jetpack security
library was built

00:11:03.770 --> 00:11:06.050
based on our experiences
talking with developers,

00:11:06.050 --> 00:11:08.990
talking with all of you
about your top pain points.

00:11:08.990 --> 00:11:15.050
And the goal here is to make 80%
of the most common tasks really

00:11:15.050 --> 00:11:17.120
easy to get right.

00:11:17.120 --> 00:11:20.060
These tasks include
encrypting files,

00:11:20.060 --> 00:11:24.100
encrypting shared preferences,
and securing our API keys.

00:11:24.100 --> 00:11:26.690
And under the hood, the
Jetpack security library

00:11:26.690 --> 00:11:28.820
handles all the boring
details for you,

00:11:28.820 --> 00:11:32.330
such as creating and managing
your keys and secure hardware.

00:11:32.330 --> 00:11:35.450
And we use industry-standard
best practices.

00:11:35.450 --> 00:11:38.020
The Jetpack security library
is in alpha this week

00:11:38.020 --> 00:11:41.040
and exports to
Android 6.0 and above.

00:11:41.040 --> 00:11:44.177
So, if encryption is a pain
point for you, take a look

00:11:44.177 --> 00:11:45.260
and give us your feedback.

00:11:48.080 --> 00:11:48.740
OK.

00:11:48.740 --> 00:11:51.620
So we've now talked a lot
about encryption of your data

00:11:51.620 --> 00:11:54.770
at rest with Adiantum, with
the Jetpack security library.

00:11:54.770 --> 00:11:57.105
Now, what about encryption
of your data in transit,

00:11:57.105 --> 00:11:57.980
your network traffic?

00:12:01.140 --> 00:12:03.870
Last year we launched
DNS over TLS, which

00:12:03.870 --> 00:12:05.560
encrypts your DNS traffic.

00:12:05.560 --> 00:12:08.070
And this year, we're
improving HTTPS

00:12:08.070 --> 00:12:12.810
by enabling TLS 1.3
by default. TLS 1.3 is

00:12:12.810 --> 00:12:16.740
a new revision of the TLS
standard, finalized by the IETF

00:12:16.740 --> 00:12:18.430
in August of last year.

00:12:18.430 --> 00:12:21.390
It is faster because it can
often complete the connection

00:12:21.390 --> 00:12:24.660
handshake in fewer round trips,
making connection times up

00:12:24.660 --> 00:12:26.700
to 40% faster.

00:12:26.700 --> 00:12:29.220
It's more secure because
it removes support

00:12:29.220 --> 00:12:31.290
for problematic features.

00:12:31.290 --> 00:12:33.540
And it uses a
redesigned handshake

00:12:33.540 --> 00:12:36.790
that fixes several weaknesses.

00:12:36.790 --> 00:12:39.900
And finally, it is more
private, because it encrypts

00:12:39.900 --> 00:12:41.700
more than a
negotiation handshake

00:12:41.700 --> 00:12:45.340
to protect the identities of
the participating parties.

00:12:45.340 --> 00:12:48.640
Now, how do you use
TLS 1.3 in Android?

00:12:48.640 --> 00:12:50.870
For web browsing,
modern browsers,

00:12:50.870 --> 00:12:54.760
such as Chrome and Firefox,
have already enabled support.

00:12:54.760 --> 00:12:58.570
For apps, if your app uses
Chrome Custom Tabs or WebView,

00:12:58.570 --> 00:13:02.140
then you'll also be
using TLS 1.3 by default

00:13:02.140 --> 00:13:03.640
if the server
supports it regardless

00:13:03.640 --> 00:13:06.960
of the Android platform
version that you're running on.

00:13:06.960 --> 00:13:12.520
And on Android Q, if your app
uses Android's built-in TLS

00:13:12.520 --> 00:13:14.410
provider called
Conscrypt, then you'll

00:13:14.410 --> 00:13:17.710
also be using TLS 1.3 by default
regardless of your app's target

00:13:17.710 --> 00:13:19.940
API level.

00:13:19.940 --> 00:13:20.440
OK.

00:13:20.440 --> 00:13:22.580
So encryption's getting better.

00:13:22.580 --> 00:13:25.550
The next question to ask is,
is anyone using encryption?

00:13:25.550 --> 00:13:29.120
Are apps actually encrypting
their network traffic?

00:13:29.120 --> 00:13:31.630
So we pulled some numbers.

00:13:31.630 --> 00:13:34.600
And we're really happy to see
that for apps in the Play Store

00:13:34.600 --> 00:13:37.900
targeting Android
Pie, more than 80%

00:13:37.900 --> 00:13:41.140
are now using
NetworkSecurityConfig to block

00:13:41.140 --> 00:13:43.910
clear-text network traffic.

00:13:43.910 --> 00:13:49.360
And another 5% of apps are
blocking clear text by default,

00:13:49.360 --> 00:13:51.910
with a few manually
configured exceptions.

00:13:51.910 --> 00:13:53.232
So these are great numbers.

00:13:53.232 --> 00:13:54.940
And a big thank you
to all the developers

00:13:54.940 --> 00:13:57.520
out there who are encrypting
your network traffic

00:13:57.520 --> 00:13:59.770
and securing your user data.

00:13:59.770 --> 00:14:02.590
Now, if you own one of these
remaining apps that's still

00:14:02.590 --> 00:14:04.780
allowing clear text
by default, please

00:14:04.780 --> 00:14:06.202
take a look at
your configuration

00:14:06.202 --> 00:14:07.660
and see if there's
anything you can

00:14:07.660 --> 00:14:11.080
do to choose to switch
to a safer default.

00:14:11.080 --> 00:14:13.690
Moving forward, we'll be
adding more hints and warnings

00:14:13.690 --> 00:14:17.363
into both Android Studio as well
as the Play Developer Console

00:14:17.363 --> 00:14:19.030
to help developers
ensure that we're all

00:14:19.030 --> 00:14:25.430
using encryption and HTTPS
as much as possible OK.

00:14:25.430 --> 00:14:28.520
So we've talked about encryption
with encryption of your data

00:14:28.520 --> 00:14:30.750
at rest, encryption of
your data in transit.

00:14:30.750 --> 00:14:35.410
Let's now switch gears and talk
about application signing keys.

00:14:35.410 --> 00:14:37.290
So this is an area
where we've gotten

00:14:37.290 --> 00:14:40.570
a lot of questions from
developers in the past as well.

00:14:40.570 --> 00:14:43.620
I've personally had meetings
with a few top developers

00:14:43.620 --> 00:14:45.630
where this is a huge pain point.

00:14:45.630 --> 00:14:49.237
The issue here is that there
are some apps in the Play

00:14:49.237 --> 00:14:51.570
Store, especially a few that
have been in the Play Store

00:14:51.570 --> 00:14:54.540
for a long time, that are
now using application signing

00:14:54.540 --> 00:14:56.820
keys that are no
longer strong enough.

00:14:56.820 --> 00:14:58.440
Maybe they didn't
have enough entropy

00:14:58.440 --> 00:15:00.540
when they were generated,
or maybe the developer

00:15:00.540 --> 00:15:03.060
has lost access to
their keys, or a spec

00:15:03.060 --> 00:15:05.590
that has been compromised.

00:15:05.590 --> 00:15:08.443
So, in order to make
key management easier,

00:15:08.443 --> 00:15:10.360
a couple of years ago,
we launched app signing

00:15:10.360 --> 00:15:13.350
by Google Play,
where apps can opt in

00:15:13.350 --> 00:15:17.200
to have Google Play
manage your signing keys

00:15:17.200 --> 00:15:20.020
and protected against
many types of compromise.

00:15:20.020 --> 00:15:23.800
Since launch, we've seen that
a large majority of new apps

00:15:23.800 --> 00:15:26.600
are now opting in
to app signing.

00:15:26.600 --> 00:15:30.530
Now, while key
management is now easier,

00:15:30.530 --> 00:15:32.750
there remains a gap
for many existing apps

00:15:32.750 --> 00:15:34.700
who are using weak
keys and need a way

00:15:34.700 --> 00:15:36.000
to move to a stronger key.

00:15:38.640 --> 00:15:40.220
And so, in order
to help with that,

00:15:40.220 --> 00:15:43.070
this year we're launching
key upgrade for new installs

00:15:43.070 --> 00:15:45.360
by Google Play.

00:15:45.360 --> 00:15:49.530
If your app is already using
app signing by Google Play

00:15:49.530 --> 00:15:51.810
and if you're using
a weak key, you

00:15:51.810 --> 00:15:54.630
can now ask Google Play to
manage a second, stronger

00:15:54.630 --> 00:15:57.560
key on your behalf.

00:15:57.560 --> 00:16:00.850
And the way that this works is
that for your existing users

00:16:00.850 --> 00:16:03.440
who already have
your app installed,

00:16:03.440 --> 00:16:05.080
all updates to that
app will continue

00:16:05.080 --> 00:16:07.740
to be signed by
the original key.

00:16:07.740 --> 00:16:11.520
Now, on the other hand, for your
new users and returning users,

00:16:11.520 --> 00:16:14.340
on devices that don't currently
have your app installed,

00:16:14.340 --> 00:16:16.900
new installs will be signed
by the new key and an update

00:16:16.900 --> 00:16:20.260
to that will also be
signed by the new key.

00:16:20.260 --> 00:16:22.860
So this is how we can
gradually move your user base

00:16:22.860 --> 00:16:27.750
to primarily using the original
key to using the new key,

00:16:27.750 --> 00:16:32.460
for example, when a user
of yours buys a new phone

00:16:32.460 --> 00:16:35.090
and installs your app
on that new phone.

00:16:35.090 --> 00:16:38.240
Now, you may be wondering, why
are we using the new key only

00:16:38.240 --> 00:16:40.100
for new installs?

00:16:40.100 --> 00:16:44.000
The main reason here is that
older Android platform versions

00:16:44.000 --> 00:16:46.990
do not have great
support for key rotation.

00:16:46.990 --> 00:16:50.480
And so if we try to update your
app to a new version signed

00:16:50.480 --> 00:16:54.320
by a different key, the platform
will reject that update.

00:16:54.320 --> 00:16:56.760
And so this approach of
gradually moving your apps

00:16:56.760 --> 00:16:59.550
from using the old key
to using the new key

00:16:59.550 --> 00:17:03.280
is the most non-disruptive.

00:17:03.280 --> 00:17:07.960
Now, the good news here is that
Android Pie added great support

00:17:07.960 --> 00:17:10.390
for key rotation natively
into the platform.

00:17:10.390 --> 00:17:13.069
And support is coming as well.

00:17:13.069 --> 00:17:17.650
So in the future, on new
Android platform versions,

00:17:17.650 --> 00:17:20.210
we'll be able to move existing
installs to the new key

00:17:20.210 --> 00:17:20.710
as well.

00:17:24.560 --> 00:17:27.069
Enabling this
feature is very easy.

00:17:27.069 --> 00:17:28.965
First, make sure
you already opted in

00:17:28.965 --> 00:17:31.290
to app signing by Google Play.

00:17:31.290 --> 00:17:34.080
Then go to the App Signing page
on the Google Play Developer

00:17:34.080 --> 00:17:39.860
Console and click on Request
Key Upgrade to get started.

00:17:39.860 --> 00:17:42.650
The rest of the developer
workflow doesn't change.

00:17:42.650 --> 00:17:45.170
You can continue to
upload a single artifact,

00:17:45.170 --> 00:17:48.032
whether it's your APK or
your application bundle,

00:17:48.032 --> 00:17:49.490
and Google Play
will transparently,

00:17:49.490 --> 00:17:52.100
in the background, sign
it with either the old key

00:17:52.100 --> 00:17:55.070
or the new key and deliver the
right version to the end user.

00:17:57.848 --> 00:17:58.470
OK.

00:17:58.470 --> 00:18:00.220
Before you enable this,
there are a couple

00:18:00.220 --> 00:18:02.170
of things to keep in mind.

00:18:02.170 --> 00:18:04.420
Because you are going to be
changing your application

00:18:04.420 --> 00:18:07.030
signing key, you need to
check for dependencies

00:18:07.030 --> 00:18:09.030
on that old signing key.

00:18:09.030 --> 00:18:12.540
For example, if you're using
any third-party services that

00:18:12.540 --> 00:18:15.060
recognize your app based
on the signing key,

00:18:15.060 --> 00:18:17.490
you'll probably want to
update them to also recognize

00:18:17.490 --> 00:18:19.510
the new key.

00:18:19.510 --> 00:18:22.180
Also, if you're using any
platform features that

00:18:22.180 --> 00:18:25.180
depend on the signing keys,
such as signature permissions,

00:18:25.180 --> 00:18:27.190
then you'll probably
want to refactor your app

00:18:27.190 --> 00:18:31.260
to achieve your objectives
in a different manner.

00:18:31.260 --> 00:18:35.070
Now, as I mentioned earlier,
this is a temporary limitation.

00:18:35.070 --> 00:18:37.670
Android Pie added in great
support for key rotation

00:18:37.670 --> 00:18:40.710
natively into the platform, and
Play support is coming as well.

00:18:40.710 --> 00:18:43.548
So in the future, you'll be
able to both rotate your key

00:18:43.548 --> 00:18:45.590
as well as continue to
use platform features that

00:18:45.590 --> 00:18:47.900
depend on the signing key
on new platform versions.

00:18:50.730 --> 00:18:51.230
OK.

00:18:51.230 --> 00:18:53.500
So we've talked about
encryption of your data

00:18:53.500 --> 00:18:57.030
at rest, encryption of
your data in transit.

00:18:57.030 --> 00:18:59.580
We also talked about your
application signing keys.

00:18:59.580 --> 00:19:04.740
Let's now turn to the last
topic, user authentication.

00:19:04.740 --> 00:19:07.950
This is another area where
we've gotten a lot of questions

00:19:07.950 --> 00:19:09.830
from developers over the years.

00:19:09.830 --> 00:19:13.055
And it's easy to see why.

00:19:13.055 --> 00:19:15.120
There are a lot of
security-sensitive apps

00:19:15.120 --> 00:19:18.090
such as banking apps,
password managers that

00:19:18.090 --> 00:19:20.800
need to prevent unauthorized
access to their apps.

00:19:20.800 --> 00:19:24.960
And so they need to authenticate
their users on a regular basis,

00:19:24.960 --> 00:19:27.350
and we want to make that easy.

00:19:27.350 --> 00:19:29.550
So last year, in
order to do this,

00:19:29.550 --> 00:19:32.680
we launched the
BiometricPrompt API.

00:19:32.680 --> 00:19:37.390
BiometricPrompt allows apps
to use a common interface

00:19:37.390 --> 00:19:38.385
to authenticate.

00:19:38.385 --> 00:19:40.450
And so users get a
consistent experience

00:19:40.450 --> 00:19:42.520
across all of their apps.

00:19:42.520 --> 00:19:44.470
And BiometricPrompt is
built in a generic way

00:19:44.470 --> 00:19:47.950
to support a wide variety of
biometric types such as face,

00:19:47.950 --> 00:19:50.460
fingerprint, and iris.

00:19:50.460 --> 00:19:53.420
Since launch, we've seen
a lot of apps adopt this,

00:19:53.420 --> 00:19:57.090
and we've also noticed
a few gaps in coverage.

00:19:57.090 --> 00:20:00.040
And so this year, we've updated
the underlying framework

00:20:00.040 --> 00:20:02.510
with more robust support
for face and fingerprint,

00:20:02.510 --> 00:20:07.020
and we've also updated the
API to support more use cases.

00:20:07.020 --> 00:20:09.230
So let's now dive
in and take a look

00:20:09.230 --> 00:20:10.895
at the new features
in BiometricPrompt

00:20:10.895 --> 00:20:16.300
in Android Q. First,
BiometricPrompt now

00:20:16.300 --> 00:20:19.270
supports both an implicit
confirmation flow as well as

00:20:19.270 --> 00:20:22.970
an explicit confirmation flow.

00:20:22.970 --> 00:20:25.370
The explicit confirmation
flow is the default flow,

00:20:25.370 --> 00:20:28.420
and it's how
BiometricPrompt works today.

00:20:28.420 --> 00:20:31.480
In the explicit flow, the user
must explicitly do something

00:20:31.480 --> 00:20:33.520
to confirm the
transaction, such as tap

00:20:33.520 --> 00:20:35.410
their finger to the
fingerprint sensor

00:20:35.410 --> 00:20:37.250
or, if they're
using face or iris,

00:20:37.250 --> 00:20:40.280
they need to press a button
to confirm the transaction.

00:20:40.280 --> 00:20:43.000
The explicit flow should
be used for all high-value

00:20:43.000 --> 00:20:46.300
transactions, such as payments.

00:20:46.300 --> 00:20:48.360
Now, new in BiometricPrompt
in Android Q

00:20:48.360 --> 00:20:51.520
is our support for an
implicit confirmation flow.

00:20:51.520 --> 00:20:53.770
In the implicit flow,
the user doesn't actually

00:20:53.770 --> 00:20:56.653
need to do anything to
confirm the transaction.

00:20:56.653 --> 00:20:58.570
And this is useful if--
for example, let's say

00:20:58.570 --> 00:21:00.490
you're a personal
diary app, and you

00:21:00.490 --> 00:21:03.970
want to authenticate your
user, and your user, let's say,

00:21:03.970 --> 00:21:06.660
is using face authentication.

00:21:06.660 --> 00:21:08.730
Now, when the user
starts your app,

00:21:08.730 --> 00:21:11.880
you can use BiometricPrompt
to authenticate your user

00:21:11.880 --> 00:21:14.490
using their face and
transition immediately

00:21:14.490 --> 00:21:18.400
into a signed-in state without
the user having to do anything.

00:21:18.400 --> 00:21:23.490
So this provides a much lighter
weight, much more seamless user

00:21:23.490 --> 00:21:25.930
experience to your users.

00:21:25.930 --> 00:21:27.420
So the implicit
confirmation flow

00:21:27.420 --> 00:21:30.480
is best for transactions
that are easily reversible,

00:21:30.480 --> 00:21:33.326
such as sign-in and autofill.

00:21:33.326 --> 00:21:36.390
In order to select the
implicit confirmation flow,

00:21:36.390 --> 00:21:39.800
call the API on your screen, and
note that while the system will

00:21:39.800 --> 00:21:41.840
do its best to honor
this, there are

00:21:41.840 --> 00:21:43.760
situations where user
confirmation will still

00:21:43.760 --> 00:21:45.180
be required.

00:21:45.180 --> 00:21:45.680
OK.

00:21:45.680 --> 00:21:47.638
So this is one great
feature of BiometricPrompt

00:21:47.638 --> 00:21:54.080
in Android Q. Another great
feature is that apps can now

00:21:54.080 --> 00:21:59.330
give users the option of having
more options to authenticate

00:21:59.330 --> 00:22:00.752
to the app.

00:22:00.752 --> 00:22:02.210
This is really
useful in situations

00:22:02.210 --> 00:22:05.130
where biometric authentication
may not work very well,

00:22:05.130 --> 00:22:08.550
such as face authentication
in poor lighting conditions.

00:22:08.550 --> 00:22:11.390
So in those situations,
apps can now

00:22:11.390 --> 00:22:14.600
give users the option to
use their device pin/pattern

00:22:14.600 --> 00:22:17.210
password to authenticate
to the app, which

00:22:17.210 --> 00:22:21.530
can give a much better user
experience in those situations.

00:22:21.530 --> 00:22:24.250
Now, of course, it may not
be appropriate for all apps,

00:22:24.250 --> 00:22:27.530
and so apps can also not
allow a fallback [INAUDIBLE]

00:22:27.530 --> 00:22:28.555
default flow.

00:22:28.555 --> 00:22:29.930
If you don't have
a fallback, you

00:22:29.930 --> 00:22:32.590
can always use your
app-specific methods,

00:22:32.590 --> 00:22:34.820
such as your
app-specific password

00:22:34.820 --> 00:22:38.190
to authenticate your user.

00:22:38.190 --> 00:22:39.240
OK.

00:22:39.240 --> 00:22:41.672
So that was a second
great feature.

00:22:41.672 --> 00:22:43.880
We'll talk about one last
feature for BiometricPrompt

00:22:43.880 --> 00:22:49.880
in Android Q. And that is
that apps now have the ability

00:22:49.880 --> 00:22:52.790
to check on the status of
biometric authentication

00:22:52.790 --> 00:22:54.390
on the device.

00:22:54.390 --> 00:22:56.810
So this is useful
if, for example, you

00:22:56.810 --> 00:23:00.650
are the owner of this
beautiful app on the screen.

00:23:00.650 --> 00:23:04.010
You want to show this Enable
Biometric Sign-In toggle

00:23:04.010 --> 00:23:07.040
if and only if the device
actually supports biometric

00:23:07.040 --> 00:23:10.400
prompts and the user
has enrolled in it.

00:23:10.400 --> 00:23:12.710
So you can now
check for the status

00:23:12.710 --> 00:23:14.930
of biometric authentication
on that device

00:23:14.930 --> 00:23:18.398
by calling the
API on the screen.

00:23:18.398 --> 00:23:20.440
All right, so that was a
quick overview of what's

00:23:20.440 --> 00:23:22.873
new for BiometricPrompt
in Android Q.

00:23:22.873 --> 00:23:24.790
Since we're talking about
user authentication,

00:23:24.790 --> 00:23:27.960
I have two more
pieces of good news.

00:23:27.960 --> 00:23:31.950
First, as of earlier this
year, Android 7.0 and above

00:23:31.950 --> 00:23:34.860
is now FIDO2-certified.

00:23:34.860 --> 00:23:42.390
This means that, if you're
a website on Android,

00:23:42.390 --> 00:23:44.700
you can now use
WebAuthn to authenticate

00:23:44.700 --> 00:23:47.100
your user without a password.

00:23:47.100 --> 00:23:51.990
So your users can use their lock
screen pin/pattern password,

00:23:51.990 --> 00:23:55.860
or their biometric, or their
second-factor FIDO-compliant

00:23:55.860 --> 00:23:58.600
security key to
authenticate to your app.

00:23:58.600 --> 00:24:01.620
So this allows us
to extend the ease

00:24:01.620 --> 00:24:04.590
of password-less
authentication to the web.

00:24:04.590 --> 00:24:08.040
Native apps on Android can
access equivalent functionality

00:24:08.040 --> 00:24:10.620
by calling the FIDO2 APIs
provided by Google Play

00:24:10.620 --> 00:24:12.230
services.

00:24:12.230 --> 00:24:12.920
OK.

00:24:12.920 --> 00:24:17.210
So another piece of good news
is that, as of last month,

00:24:17.210 --> 00:24:19.000
you can now use
your Android phone

00:24:19.000 --> 00:24:22.100
as a second-factor security key
to authenticate to your Google

00:24:22.100 --> 00:24:23.360
account.

00:24:23.360 --> 00:24:24.770
Now, second-factor
authentication

00:24:24.770 --> 00:24:27.890
is probably one of the most
important things you can do

00:24:27.890 --> 00:24:29.870
to secure your online account.

00:24:29.870 --> 00:24:33.320
And not all second-factor
authentication methods

00:24:33.320 --> 00:24:35.970
provide the same
security guarantees.

00:24:35.970 --> 00:24:39.830
And so this integration
here hits a sweet spot

00:24:39.830 --> 00:24:42.410
in convenience and security.

00:24:42.410 --> 00:24:44.360
Today it works for
Google accounts.

00:24:44.360 --> 00:24:48.800
And we're working on
standardizing the protocol,

00:24:48.800 --> 00:24:53.170
so that we can bring it to
other websites in the future.

00:24:53.170 --> 00:24:53.760
All right.

00:24:53.760 --> 00:24:55.890
So we've spent the
last few minutes

00:24:55.890 --> 00:24:58.380
talking about user
authentication online.

00:24:58.380 --> 00:25:01.620
We've also done a lot of work to
make user authentication really

00:25:01.620 --> 00:25:03.580
easy in the real world.

00:25:03.580 --> 00:25:06.930
So I'd like to bring René
onstage to tell us more about

00:25:06.930 --> 00:25:07.699
that.

00:25:07.699 --> 00:25:08.697
[APPLAUSE]

00:25:08.697 --> 00:25:09.780
RENÉ MAYRHOFER: Thank you.

00:25:14.690 --> 00:25:15.890
XIAOWEN XIN: Hey, René.

00:25:15.890 --> 00:25:20.510
My six-month-old son just got
his first driver's license.

00:25:20.510 --> 00:25:22.970
Unfortunately, his onesies,
they don't have pockets,

00:25:22.970 --> 00:25:26.810
so he doesn't have a great
way to carry this plastic card

00:25:26.810 --> 00:25:27.800
around with him.

00:25:27.800 --> 00:25:31.310
So can we do something to
help him out with that?

00:25:31.310 --> 00:25:34.460
RENÉ MAYRHOFER: Well, I would
say six months may be a bit

00:25:34.460 --> 00:25:36.370
young to be driving
or carrying a phone,

00:25:36.370 --> 00:25:39.413
but let's talk about that,
because I think many of us have

00:25:39.413 --> 00:25:42.080
that same usability problem-- of
having too many things to carry

00:25:42.080 --> 00:25:43.190
around.

00:25:43.190 --> 00:25:48.110
So joking aside, I'm very happy
to talk about a few details

00:25:48.110 --> 00:25:52.230
on exciting upcoming
areas in Android security.

00:25:52.230 --> 00:25:55.820
The first is what we call
identity credentials.

00:25:55.820 --> 00:25:57.560
And this is about
an electronic ID.

00:25:57.560 --> 00:26:00.020
Electronic ID has
been an active topic

00:26:00.020 --> 00:26:03.320
in research and early
projects for quite a while.

00:26:03.320 --> 00:26:05.780
And, before coming
to Google, I actually

00:26:05.780 --> 00:26:08.280
myself have worked for
three years in that space,

00:26:08.280 --> 00:26:11.210
so please excuse me for being
just a little bit excited

00:26:11.210 --> 00:26:14.480
about this topic reaching
a level of maturity that

00:26:14.480 --> 00:26:17.170
allows us to bring to
end users right now.

00:26:20.910 --> 00:26:23.370
What I'm very happy
to announce is

00:26:23.370 --> 00:26:27.540
that Android will support
Electronic Identity in the form

00:26:27.540 --> 00:26:31.170
that we also call identification
in the physical world.

00:26:31.170 --> 00:26:35.070
That may be the mobile driving
licenses that we just see here.

00:26:35.070 --> 00:26:38.730
That might also be future
travel documents or simple cloud

00:26:38.730 --> 00:26:41.010
membership cards.

00:26:41.010 --> 00:26:44.310
Now, in all of those use
cases, Android Support

00:26:44.310 --> 00:26:50.070
will focus on strong security
and privacy guarantees.

00:26:50.070 --> 00:26:53.670
As is typical with Android,
we are designing an open API

00:26:53.670 --> 00:26:58.680
to allow apps to use such new
hardware and platform support.

00:26:58.680 --> 00:27:04.230
This new Identity Credential
API will support the development

00:27:04.230 --> 00:27:06.510
of so-called holder apps.

00:27:06.510 --> 00:27:08.730
These holder apps
are applications

00:27:08.730 --> 00:27:13.680
that support a specific
form of Electronic Identity,

00:27:13.680 --> 00:27:16.740
like, for example, those
mobile driving licenses.

00:27:16.740 --> 00:27:19.680
Those apps are free to define
their own communication

00:27:19.680 --> 00:27:22.140
protocols to the
Verifier or Reader apps,

00:27:22.140 --> 00:27:26.040
for example, through NFC
or other wireless channels

00:27:26.040 --> 00:27:29.250
as well as their communication
to the respective issuing

00:27:29.250 --> 00:27:32.130
authority of that credential.

00:27:32.130 --> 00:27:35.610
Android implements a
new credential store

00:27:35.610 --> 00:27:37.950
that can be accessed
through this API

00:27:37.950 --> 00:27:41.880
and manages secure storage
of all such provisioned

00:27:41.880 --> 00:27:43.170
credentials.

00:27:43.170 --> 00:27:45.120
Depending on hardware
support, this

00:27:45.120 --> 00:27:48.570
will be backed by
OEM-specific secure hardware

00:27:48.570 --> 00:27:50.970
with respective
attestation, as you

00:27:50.970 --> 00:27:55.830
might know from key master
and Strongbox key attestation.

00:27:55.830 --> 00:27:57.720
Now, within that
credential store,

00:27:57.720 --> 00:28:00.270
every app that provisions
such credentials

00:28:00.270 --> 00:28:04.350
has its own private store
of attributes belonging

00:28:04.350 --> 00:28:06.810
to this particular document.

00:28:06.810 --> 00:28:09.810
And the store will transparently
handle their secured

00:28:09.810 --> 00:28:13.080
persistence and access
control for apps

00:28:13.080 --> 00:28:15.390
that created those items.

00:28:15.390 --> 00:28:18.780
Users will, in addition, be
able to view a transaction

00:28:18.780 --> 00:28:22.920
log of all accesses to
their credential attributes

00:28:22.920 --> 00:28:26.520
to ensure transparency of
those identity documents

00:28:26.520 --> 00:28:29.160
in pretty much the
same way that the call

00:28:29.160 --> 00:28:32.810
log does that for incoming
and outgoing calls.

00:28:32.810 --> 00:28:37.270
Now, unfortunately, some of
the international standards,

00:28:37.270 --> 00:28:39.960
including the ISO working
group for mobile driving

00:28:39.960 --> 00:28:42.630
licenses that Google is
also contributing to,

00:28:42.630 --> 00:28:46.260
haven't locked down yet at this
point to a sufficient extent

00:28:46.260 --> 00:28:50.310
that we were comfortable
merging this API directly

00:28:50.310 --> 00:28:51.940
into the Q platform.

00:28:51.940 --> 00:28:54.370
However, in the
very near future,

00:28:54.370 --> 00:28:57.540
we will be releasing a
new Jetpack compatibility

00:28:57.540 --> 00:29:00.000
library that implements
the credential

00:29:00.000 --> 00:29:03.400
store within an app's
private data directory.

00:29:03.400 --> 00:29:07.080
This API is not expected to
change significantly, so,

00:29:07.080 --> 00:29:09.210
as soon as this
library is released,

00:29:09.210 --> 00:29:14.190
all developers are free to
start developing such Electronic

00:29:14.190 --> 00:29:15.900
Identity holder apps.

00:29:15.900 --> 00:29:19.260
The library will be compatible
with the vast majority

00:29:19.260 --> 00:29:22.440
of Android devices out there
in the field at the moment.

00:29:22.440 --> 00:29:27.270
In future versions, we expect
a new HAL implementation

00:29:27.270 --> 00:29:31.380
for OEM-specific back ends
based on secure hardware that

00:29:31.380 --> 00:29:35.640
will be used by a credential
store system service

00:29:35.640 --> 00:29:39.700
and made available through new
Framework APIs that will very,

00:29:39.700 --> 00:29:42.940
very closely match the APIs
that we will soon release

00:29:42.940 --> 00:29:44.760
in that compatibility library.

00:29:44.760 --> 00:29:46.750
If the hardware
supports it-- and to me,

00:29:46.750 --> 00:29:48.690
that's one of the most
exciting parts there.

00:29:48.690 --> 00:29:51.540
This will also allow what
we call Direct Access.

00:29:51.540 --> 00:29:54.870
Direct Access is using
your identity credential,

00:29:54.870 --> 00:29:57.540
your document, even
if the main phone

00:29:57.540 --> 00:30:01.200
battery is too low
to power the CPU

00:30:01.200 --> 00:30:02.670
and therefore to boot Android.

00:30:02.670 --> 00:30:05.550
So just using, for example,
an NFC tap to the reader,

00:30:05.550 --> 00:30:07.950
you will still be able
to use that document even

00:30:07.950 --> 00:30:09.660
if the phone no longer boots.

00:30:09.660 --> 00:30:11.760
That, of course, requires
some hardware support,

00:30:11.760 --> 00:30:14.790
but support for this
is already in the HAL,

00:30:14.790 --> 00:30:18.870
in the draft HAL specifications
as well as the API that you

00:30:18.870 --> 00:30:21.870
will be able to start using.

00:30:21.870 --> 00:30:23.960
With that secure
hardware support,

00:30:23.960 --> 00:30:26.970
devices can also
give the highest end

00:30:26.970 --> 00:30:31.320
certifiable security and
privacy guarantees for users

00:30:31.320 --> 00:30:33.780
as well as the
issuing authorities.

00:30:33.780 --> 00:30:37.642
Now, to give a small sneak peek
of what that API looks like,

00:30:37.642 --> 00:30:38.850
it's pretty simple, actually.

00:30:38.850 --> 00:30:42.120
An API would first create an
instance of the credential

00:30:42.120 --> 00:30:46.500
store and use that
reference to provision

00:30:46.500 --> 00:30:50.490
a new credential, a new
document, as we also say,

00:30:50.490 --> 00:30:52.650
which can actually have
multiple, what we call,

00:30:52.650 --> 00:30:54.180
namespaces in there.

00:30:54.180 --> 00:30:55.840
One namespace
could, for example,

00:30:55.840 --> 00:31:00.270
be that draft standard of the
ISO mobile driving license,

00:31:00.270 --> 00:31:03.840
but could also be extended
within the same document

00:31:03.840 --> 00:31:07.740
with another namespace that
could add additional attributes

00:31:07.740 --> 00:31:11.100
to make this document
a real ID travel

00:31:11.100 --> 00:31:15.030
document within the
United States here.

00:31:15.030 --> 00:31:16.890
After creating,
after provisioning

00:31:16.890 --> 00:31:18.930
such a new credential,
an app can also

00:31:18.930 --> 00:31:23.440
request a proof, an attestation
that all those attributes were

00:31:23.440 --> 00:31:27.280
provisioned into the secure
hardware exactly as provided

00:31:27.280 --> 00:31:30.550
by the issuing authority
and sent that proof back

00:31:30.550 --> 00:31:34.030
to the issuing authority
for verification there.

00:31:34.030 --> 00:31:36.160
Now I'd like to
change tack a little

00:31:36.160 --> 00:31:38.380
and move on to the
second upcoming topic

00:31:38.380 --> 00:31:43.000
that I am very pleased to talk
about, which is how we mitigate

00:31:43.000 --> 00:31:46.300
against what we call insider
attacks in the Android

00:31:46.300 --> 00:31:47.930
ecosystem.

00:31:47.930 --> 00:31:50.410
There are, actually, multiple
efforts towards that goal,

00:31:50.410 --> 00:31:52.330
but here on this
talk, I would like

00:31:52.330 --> 00:31:54.850
to primarily speak about
firmware transparency

00:31:54.850 --> 00:31:56.195
on multiple layers.

00:31:56.195 --> 00:31:57.820
Now, if I speak about
insiders, what do

00:31:57.820 --> 00:31:59.530
I actually mean by that?

00:31:59.530 --> 00:32:04.240
An insider is any person
who has privileged access

00:32:04.240 --> 00:32:07.650
to information or resources.

00:32:07.650 --> 00:32:11.090
That is intentionally a
very broad definition.

00:32:11.090 --> 00:32:14.280
It includes hardware,
and protocol designers,

00:32:14.280 --> 00:32:17.760
of course software
developers, but also logistics

00:32:17.760 --> 00:32:19.770
and retail shop personnel.

00:32:19.770 --> 00:32:23.190
In fact, many of you, most
of you listening to this talk

00:32:23.190 --> 00:32:26.530
will be insiders in
one way or the other.

00:32:26.530 --> 00:32:31.080
And that just includes access
to your own app signing key.

00:32:31.080 --> 00:32:36.100
Now, with so much complexity,
so many stakeholders

00:32:36.100 --> 00:32:38.740
in the supply chain
contributing to what

00:32:38.740 --> 00:32:42.850
goes into making a modern mobile
phone, a modern mobile device,

00:32:42.850 --> 00:32:44.950
the big question is, how
can users actually trust

00:32:44.950 --> 00:32:46.900
their own device?

00:32:46.900 --> 00:32:51.520
Our answer to that is focusing
on transparency on many layers,

00:32:51.520 --> 00:32:55.990
from hardware all the way up to
the apps and the dynamic code

00:32:55.990 --> 00:32:57.610
those apps actually load.

00:32:57.610 --> 00:33:00.580
In addition to the app
signing upgrade key feature

00:33:00.580 --> 00:33:03.160
that Xiaowen mentioned
earlier in her talk,

00:33:03.160 --> 00:33:06.980
I would like to dive into
two other of those layers.

00:33:06.980 --> 00:33:09.460
The first layer is
the system layer,

00:33:09.460 --> 00:33:12.370
which contains the main
operating system itself.

00:33:12.370 --> 00:33:15.910
Android has always been
among the most transparent OS

00:33:15.910 --> 00:33:17.700
by being open source.

00:33:17.700 --> 00:33:21.130
At last year's
Android Pie, we edited

00:33:21.130 --> 00:33:24.280
end-to-end,
client-side-encrypted backups

00:33:24.280 --> 00:33:29.290
to mitigate against insider
attacks on such backups.

00:33:29.290 --> 00:33:33.250
And that even includes
Google servers, Google server

00:33:33.250 --> 00:33:35.230
administrators in
that threat model

00:33:35.230 --> 00:33:37.960
of being considered insiders.

00:33:37.960 --> 00:33:41.350
Now, we go one step further
towards the transparency

00:33:41.350 --> 00:33:46.450
of the system by focusing on
the system software that's

00:33:46.450 --> 00:33:48.550
running on the device itself.

00:33:48.550 --> 00:33:50.830
A new version of
ABB tool can now

00:33:50.830 --> 00:33:54.910
be used to compute the top-level
digest of the Android system

00:33:54.910 --> 00:33:58.460
image if the device is
using the standard vbmeta

00:33:58.460 --> 00:34:00.820
format for verified boot.

00:34:00.820 --> 00:34:05.380
For Pixel 3 and 3A phones, you
can download the latest factory

00:34:05.380 --> 00:34:09.300
images and independently
compute this digest.

00:34:09.300 --> 00:34:14.139
Now, when the device boots,
the updated boot loader

00:34:14.139 --> 00:34:17.800
will verify this vbmeta
digest, and all the associated

00:34:17.800 --> 00:34:21.489
partitions mentioned
within this vb metadata,

00:34:21.489 --> 00:34:25.840
and pass on the measured
hash to key master running

00:34:25.840 --> 00:34:28.000
in TrustZone, as
well as Strongbox

00:34:28.000 --> 00:34:31.550
running on the Titan M chip.

00:34:31.550 --> 00:34:34.630
This is true for both
Pixel 3 and Pixel 3A

00:34:34.630 --> 00:34:36.610
phones as of today.

00:34:36.610 --> 00:34:41.530
An app can create the private
key in Key Master or Strongbox,

00:34:41.530 --> 00:34:45.639
request an attestation
certificate for those keys,

00:34:45.639 --> 00:34:49.900
and that certificate will
now contain a new field

00:34:49.900 --> 00:34:54.790
with exactly this measured hash
as seen early on in the boot

00:34:54.790 --> 00:34:58.210
chain by the boot loader itself
before even passing control

00:34:58.210 --> 00:35:00.400
over to the Android kernel.

00:35:00.400 --> 00:35:03.640
Now, by matching that hash into
that attestation certificate

00:35:03.640 --> 00:35:05.470
with the one computed
independently

00:35:05.470 --> 00:35:08.120
and offline from the
official factory images,

00:35:08.120 --> 00:35:10.870
it is certain that
this device is actually

00:35:10.870 --> 00:35:13.630
running one of the official
factory images that

00:35:13.630 --> 00:35:15.550
has passed all the
checks, that has

00:35:15.550 --> 00:35:17.860
gone through all the testing.

00:35:17.860 --> 00:35:20.170
And not one that may
have been modified

00:35:20.170 --> 00:35:24.220
for an individual or just
a small group of devices.

00:35:24.220 --> 00:35:25.900
Coming at the second
layer, I would

00:35:25.900 --> 00:35:29.230
like to point out here
is the firmware that

00:35:29.230 --> 00:35:32.480
runs below the main
operating system.

00:35:32.480 --> 00:35:35.110
So if a device is
lost or stolen,

00:35:35.110 --> 00:35:37.510
how can we make sure that
data is safe even when

00:35:37.510 --> 00:35:40.540
we assume insider
attacks with access

00:35:40.540 --> 00:35:42.970
to firmware signing keys?

00:35:42.970 --> 00:35:46.060
That is where we add what we
call insider attack resistance

00:35:46.060 --> 00:35:47.630
on the layers below a device.

00:35:47.630 --> 00:35:50.420
Let me quickly explain
how that works.

00:35:50.420 --> 00:35:53.290
The first line of defense
is that cryptographic keys

00:35:53.290 --> 00:35:56.270
are generated and stored
in secure hardware,

00:35:56.270 --> 00:35:57.820
like the Titan M chip.

00:35:57.820 --> 00:36:01.090
This is tied into verified boot
and will only make those keys

00:36:01.090 --> 00:36:04.270
available-- for example,
for device-level decryption

00:36:04.270 --> 00:36:07.780
for the key that is used
for [INAUDIBLE] on device,

00:36:07.780 --> 00:36:10.570
when the proper user
knowledge factor--

00:36:10.570 --> 00:36:12.790
that is pin-code,
password, or pattern--

00:36:12.790 --> 00:36:14.570
is entered by the user.

00:36:14.570 --> 00:36:20.230
However, an insider with access
to such signing keys leaked,

00:36:20.230 --> 00:36:22.660
whatever went wrong
there, could potentially

00:36:22.660 --> 00:36:26.320
create a Trojanized firmware
that, when you update the Titan

00:36:26.320 --> 00:36:28.540
M or other secure
element to that,

00:36:28.540 --> 00:36:31.080
would make those
cryptographic keys

00:36:31.080 --> 00:36:34.870
available without performing
that verification for the user

00:36:34.870 --> 00:36:37.500
knowledge factor.

00:36:37.500 --> 00:36:39.950
With Strongbox insider
attack resistance,

00:36:39.950 --> 00:36:42.640
we take the next
step of mitigating

00:36:42.640 --> 00:36:44.020
against such attacks.

00:36:44.020 --> 00:36:47.590
By default, every update
to the Titan M firmware

00:36:47.590 --> 00:36:51.550
will invalidate all keys
that are stored inside.

00:36:51.550 --> 00:36:53.230
Only when the user
knowledge factor

00:36:53.230 --> 00:36:56.410
is available during the
update itself will the keys

00:36:56.410 --> 00:36:59.470
be migrated to work on the
new version of the firmware.

00:36:59.470 --> 00:37:01.810
Now, if an attacker has a
correctly signed firmware

00:37:01.810 --> 00:37:05.560
update but doesn't have access
to the user pin, password,

00:37:05.560 --> 00:37:09.520
or pattern, they can still
force-apply that update.

00:37:09.520 --> 00:37:12.035
To the boot loader, it looks
like a legitimate update.

00:37:12.035 --> 00:37:14.410
It's correctly signed, it has
an updated version counter,

00:37:14.410 --> 00:37:15.310
and so on.

00:37:15.310 --> 00:37:16.900
They can force that
update to apply.

00:37:16.900 --> 00:37:19.320
But without having the
user knowledge factor

00:37:19.320 --> 00:37:23.020
at the same time, this will
make all keys inaccessible

00:37:23.020 --> 00:37:25.300
and therefore be roughly
equivalent to a factory data

00:37:25.300 --> 00:37:27.130
reset.

00:37:27.130 --> 00:37:29.620
Coming back to the
multiple different layers

00:37:29.620 --> 00:37:31.900
that I talked about,
we have to conclude

00:37:31.900 --> 00:37:36.010
that every one of those layers
will require different methods

00:37:36.010 --> 00:37:37.510
to mitigate insider attacks.

00:37:37.510 --> 00:37:43.610
However, transparency is a
key component to all of them.

00:37:43.610 --> 00:37:46.780
We are trying hard to make
it possible for developers

00:37:46.780 --> 00:37:51.160
and users to verify what
is happening on every layer

00:37:51.160 --> 00:37:55.240
and to audit instead of having
to trust all those parties

00:37:55.240 --> 00:37:57.490
in that complex supply chain.

00:37:57.490 --> 00:38:02.200
Whenever reasonably
possible, we take ourselves

00:38:02.200 --> 00:38:06.700
out of the trust equation,
so that you don't actually

00:38:06.700 --> 00:38:10.570
have to take our word for
it but can verify yourself.

00:38:10.570 --> 00:38:13.420
As app developers,
we recommend you

00:38:13.420 --> 00:38:17.380
do similar analysis of
what insider attacks on any

00:38:17.380 --> 00:38:19.750
of the components that are
under your direct control

00:38:19.750 --> 00:38:23.570
could look like and what you
can do to mitigate against that.

00:38:23.570 --> 00:38:26.830
We are all in this together,
and the open source nature

00:38:26.830 --> 00:38:29.320
of Android luckily
makes it easier

00:38:29.320 --> 00:38:32.620
to build this kind
of transparency.

00:38:32.620 --> 00:38:35.800
Now, thanks a lot for all
your attention on what

00:38:35.800 --> 00:38:38.770
was a very dense session
with a lot of detail.

00:38:38.770 --> 00:38:42.250
And special thanks to all of you
coming in here in the morning

00:38:42.250 --> 00:38:43.565
after the big party.

00:38:43.565 --> 00:38:44.440
Highly appreciate it.

00:38:44.440 --> 00:38:45.340
Thanks.

00:38:45.340 --> 00:38:46.840
[APPLAUSE]

00:38:46.840 --> 00:38:50.790
[GOOGLE LOGO MUSIC]

