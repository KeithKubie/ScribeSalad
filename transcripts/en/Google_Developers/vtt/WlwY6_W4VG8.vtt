WEBVTT
Kind: captions
Language: en

00:00:04.960 --> 00:00:17.410
&gt;&gt;Arne Roomann-Kurrik: All right. Welcome
to HTML Showcase for Web Developers. Or as

00:00:17.410 --> 00:00:19.970
we like to call it, the wow!
&gt;&gt;Eric Bidelman: And the how!

00:00:19.970 --> 00:00:25.770
&gt;&gt;Arne Roomann-Kurrik: My name is Arne Roomann-Kurrik.
This is my friend, Eric Bidelman. And we are

00:00:25.770 --> 00:00:30.160
Chrome developer relations, and what means
is we wander the Earth like the Incredible

00:00:30.160 --> 00:00:34.739
Hulk and help out developers who are writing
apps, extensions, and websites for Chrome.

00:00:34.739 --> 00:00:41.710
So basically, what we do is talk about HTML5
a lot.

00:00:41.710 --> 00:00:44.809
You can see our Twitter handles were up there.
Oh, actually let's go back there.

00:00:44.809 --> 00:00:46.589
&gt;&gt;Eric Bidelman: Sure.
&gt;&gt;Arne Roomann-Kurrik: Our Twitter handles

00:00:46.589 --> 00:00:52.339
are actually up here. Follow us if you want.
I like to post updates about Chrome Extension

00:00:52.339 --> 00:00:58.090
APIs and kind of updates to Chrome. Eric likes
to post pictures of cupcakes, furry animals

00:00:58.090 --> 00:01:03.409
with moustaches, that kind of thing. Whatever
floats your boat.

00:01:03.409 --> 00:01:08.350
So a year ago, I was actually up on a stage
at Google I/O and talking about HTML5, and

00:01:08.350 --> 00:01:12.830
back then it wasn't kind of like the huge
buzzword that it is today. It wasn't so overused.

00:01:12.830 --> 00:01:16.710
We talked about a lot of different technologies,
and if you were lucky enough to get a seat,

00:01:16.710 --> 00:01:22.369
you learned about canvas elements, audio elements,
video elements, local storage, Web SQL database,

00:01:22.369 --> 00:01:27.490
worker threads, drag and drop events, desktop
notifications, new CSS styles, CSS transforms,

00:01:27.490 --> 00:01:34.310
CSS transitions, CSS animations, maybe hotel/restaurant
management, web fonts, flexible box model,

00:01:34.310 --> 00:01:39.969
and some of you got your associate degree
in building a paint application or accounting.

00:01:39.969 --> 00:01:44.149
In all seriousness, we're just kind of doing
this to emphasize we covered a lot last year.

00:01:44.149 --> 00:01:52.700
The video is still online. It's a great resource,
if you followed that bit.ly link, bit.ly/HTML5io2011

00:01:52.700 --> 00:01:57.299
you can actually see it and give kind of a
ramp-up on this.

00:01:57.299 --> 00:02:01.110
So -- but today we're not going to really
do that. We're not going to cover the basics.

00:02:01.110 --> 00:02:04.859
In fact, we just want to show you some demos.
I'm betting these demos are actually going

00:02:04.859 --> 00:02:08.190
to make you say some amazing things. What
are they going to make you say, Eric?

00:02:08.190 --> 00:02:09.250
&gt;&gt;Eric Bidelman: Wow!
&gt;&gt;Arne Roomann-Kurrik: Yes, they're going

00:02:09.250 --> 00:02:11.530
to make you say wow.
&gt;&gt;Eric Bidelman: Hopefully.

00:02:11.530 --> 00:02:14.120
&gt;&gt;Arne Roomann-Kurrik: Hopefully. We're not
there yet.

00:02:14.120 --> 00:02:18.050
&gt;&gt;Eric Bidelman: So we're also going to -- like
Arne said, we built these demos, but these

00:02:18.050 --> 00:02:22.580
are complex demos. These are a lot of HTML5
capabilities working together. And this whole

00:02:22.580 --> 00:02:29.000
entire slide deck -- right? -- HTML5 app,
all the code is going to be under HTML5wow.googlecode.com.

00:02:29.000 --> 00:02:32.750
All the demos, all the slide deck.
I just want to mention there's feedback links.

00:02:32.750 --> 00:02:36.110
There's Twitter handles at the bottom. There's
a Moderator link. If you have questions during

00:02:36.110 --> 00:02:38.650
the entire presentation, go ahead and reference
those.

00:02:38.650 --> 00:02:42.250
&gt;&gt;Arne Roomann-Kurrik: Yeah. That feedback
link is live right now. You can give us feedback

00:02:42.250 --> 00:02:45.280
on certain points in the presentation, that
kind of thing, so we'd really appreciate it

00:02:45.280 --> 00:02:49.200
if you took the time to kind of rate us and
how we're doing.

00:02:49.200 --> 00:02:50.420
&gt;&gt;Eric Bidelman: Yeah.
&gt;&gt;Arne Roomann-Kurrik: Okay. So today we have

00:02:50.420 --> 00:02:55.920
three topics in our presentation. We're going
to break it down. Basically we found different

00:02:55.920 --> 00:02:58.730
categories that would work out for us. So
file, graphics, audio.

00:02:58.730 --> 00:03:01.210
But without really going too deep into that,
let's start with the first one.

00:03:01.210 --> 00:03:05.490
Eric, I'm going to hand it over to you to
talk about file APIs and HTML.

00:03:05.490 --> 00:03:07.970
&gt;&gt;Arne Roomann-Kurrik: Absolutely. Thank you,
Arne.

00:03:07.970 --> 00:03:11.770
So let's talk a little bit -- before we dive
into the file capabilities of HTML5, let's

00:03:11.770 --> 00:03:17.610
talk about binary data in HTML5, because the
sad -- the truth of the matter is, we're dealing

00:03:17.610 --> 00:03:22.190
with binary data all the time, right? Web
applications, music applications, photo applications.

00:03:22.190 --> 00:03:26.310
And so it was very, very painful before.
This is a little snippet. I call this black

00:03:26.310 --> 00:03:30.840
magic. You can call this a hacker trick. But
what we had to do to pull down an image as

00:03:30.840 --> 00:03:36.590
a binary file was use HTML XTP requests, right?
HTML XTP requests. And then have this little

00:03:36.590 --> 00:03:40.100
override mime type. Arne is going to highlight
certain sections of code.

00:03:40.100 --> 00:03:44.630
Set up the mime type, the text plain, user
defined char set. This is well-documented.

00:03:44.630 --> 00:03:48.250
We've been doing this all over the place.
And then inside of the ready state change

00:03:48.250 --> 00:03:52.810
-- right? -- we process the response text
just as a binary string and do some crazy

00:03:52.810 --> 00:03:56.930
character code manipulations, hacks, streaming
manipulation. Stuff that's hard and it's very

00:03:56.930 --> 00:04:03.030
error prone and luckily with HTML5 we have
better tools now.

00:04:03.030 --> 00:04:07.200
So we're going to cover a few different topics,
so how do you import data? How do you import

00:04:07.200 --> 00:04:11.090
files into your application and then do something
useful with them? You don't have to import;

00:04:11.090 --> 00:04:15.170
you can create. So there's interfaces now
in HTML5 that you can use to create binary

00:04:15.170 --> 00:04:19.660
data on the fly.
Manipulate existing data. So this is actually

00:04:19.660 --> 00:04:23.409
a new data type that we can use to manipulate
this data.

00:04:23.409 --> 00:04:26.729
We can store that data. IndexedDB, file system
APIs, we're going to cover those.

00:04:26.729 --> 00:04:30.650
And then publish that back out to the cloud.
So XHR, you don't have to just send strings

00:04:30.650 --> 00:04:34.430
anymore. You can send files, you can send
array buffers, you can send form data types.

00:04:34.430 --> 00:04:38.580
So binary data hearts HTML5.
I'm not going to cover typed arrays today,

00:04:38.580 --> 00:04:43.250
but these are very important. These are -- were
introduced by the WebGL specification, and

00:04:43.250 --> 00:04:46.310
these are a very more performant. They're
going to be used to work with binary data,

00:04:46.310 --> 00:04:49.659
file types. We're using them all over the
place within the presentation.

00:04:49.659 --> 00:04:56.620
And so what the browsers can do is optimize
based on your data type. So you have an 8-bit

00:04:56.620 --> 00:04:58.389
array, you have a 32-bit float array. These
are all over now.

00:04:58.389 --> 00:05:00.199
So I don't know about you, Arne, but if you
remember the snippet before -- right? -- we

00:05:00.199 --> 00:05:04.009
did the character code hacks with XHR. This
looks much cleaner, right?

00:05:04.009 --> 00:05:05.850
&gt;&gt;Arne Roomann-Kurrik: Let's really good.
&gt;&gt;Eric Bidelman: Yeah. So I want to point

00:05:05.850 --> 00:05:09.770
out a couple portions of this.
XHR has been extended and the first thing

00:05:09.770 --> 00:05:13.870
-- the way it's been extended is the response
type. We don't have to pull down our data

00:05:13.870 --> 00:05:17.551
from the server anymore as a string. We can
say, "Hey, give me an array buffer, give me

00:05:17.551 --> 00:05:20.819
a buffer of bytes that I can process as this
response type."

00:05:20.819 --> 00:05:24.870
We don't have to listen for the on-ready state
and do this, you know, crazy state checking.

00:05:24.870 --> 00:05:28.729
We can just listen for the on-load. Give me
the data when it's done.

00:05:28.729 --> 00:05:32.749
And here's a great example of doing a typed
array, so an unsigned 8-bit array we're using

00:05:32.749 --> 00:05:37.340
and just filling that array with our response.
And we're not processing the response text;

00:05:37.340 --> 00:05:41.330
we're processing a new attribute, the response,
and that's going to give us this blob, this

00:05:41.330 --> 00:05:44.259
image, as a binary file.
And then you can manipulate that just as a

00:05:44.259 --> 00:05:49.659
JavaScript array, which is really cool. So
that's the new hotness.

00:05:49.659 --> 00:05:53.189
Let's -- let's -- without further ado, let's
dive into the file capabilities.

00:05:53.189 --> 00:05:56.979
So the first might not -- I mean, look right.
This is our old friend. This is the file input.

00:05:56.979 --> 00:06:01.550
But the really important and cool portion
of this is that one attribute that Arne is

00:06:01.550 --> 00:06:03.659
going to highlight at the end, the multiple
attribute.

00:06:03.659 --> 00:06:07.120
So if you've ever created a photo application
-- right? -- an upload application, you've

00:06:07.120 --> 00:06:12.740
had to probably instantiate a bunch of these
inputs in JavaScript and then send files,

00:06:12.740 --> 00:06:16.680
your photos, one at a time.
So instead, we have a little demo of this.

00:06:16.680 --> 00:06:20.200
This is just a file input that Arne's going
to run, and what Chrome is going to allow

00:06:20.200 --> 00:06:24.319
him to do with this attribute, just one attribute,
is select multiple files, not just a single

00:06:24.319 --> 00:06:27.569
file.
So he's going to select a bunch of image files.

00:06:27.569 --> 00:06:31.740
Apologies that it's so close to lunch.
And what you get back is a file list. You

00:06:31.740 --> 00:06:37.319
get basically an array of file objects that
you interface in HTML5 with metadata. So what

00:06:37.319 --> 00:06:40.650
is the name of this file? What's the mime
type? How many bytes does it take up on disk?

00:06:40.650 --> 00:06:45.229
When was it last modified?
This is really great stuff in order to do

00:06:45.229 --> 00:06:48.349
some preprocessing or some interesting applications
before you send your code to the server.

00:06:48.349 --> 00:06:53.009
And the code for this -- right? -- I'm just
setting up an event listener on the input

00:06:53.009 --> 00:06:56.819
and you get back -- in the target of this
event, we'll get a files list, and this is

00:06:56.819 --> 00:07:00.509
the list of files, and then we'll just loop
through those and present the metadata to

00:07:00.509 --> 00:07:04.789
the user.
It's very straightforward but very cool.

00:07:04.789 --> 00:07:08.849
Of course it's not just files. We can actually
select now directories using the same file

00:07:08.849 --> 00:07:12.819
inputs. So with the Webkit directory attribute,
Chrome is going to allow us not to select

00:07:12.819 --> 00:07:18.969
files, but an entire folder, and Arne is going
to demo this, if he backs out of this folder.

00:07:18.969 --> 00:07:23.060
Chrome's going to recursively traverse this
folder and give us a file for each of the

00:07:23.060 --> 00:07:27.360
files, and see at the bottom here -- I'm just
printing out that Webkit relative path so

00:07:27.360 --> 00:07:31.680
that's also a property in this file object.
And we're printing out the files as they appear

00:07:31.680 --> 00:07:35.900
within this folder hierarchy that he's selected.
You can see there's a few folders within this

00:07:35.900 --> 00:07:38.770
folder.
Of course that's cool but we can also use,

00:07:38.770 --> 00:07:42.789
you know, a little bit of string manipulation,
a little bit of JSON, and a jQuery plug-in

00:07:42.789 --> 00:07:45.719
to present that as a sort of a file hierarchy
and a tree structure, and so he's just navigating.

00:07:45.719 --> 00:07:52.170
This is the exact folder that he selected
as it was appearing on disk. Cool.

00:07:52.170 --> 00:07:57.050
Very exciting stuff. So you can upload an
entire folder now.

00:07:57.050 --> 00:08:01.499
You can import using a file input. That's
our old friend. You can also use drag and

00:08:01.499 --> 00:08:06.580
drop. So HTML5 has -- has native -- native
drag and drop capabilities now. And so Arne

00:08:06.580 --> 00:08:11.810
is selecting image files -- right? -- from
my hard disk and he's just going to drag these

00:08:11.810 --> 00:08:15.949
onto the Web application using HTML5 drag
and drop. Chrome allows this.

00:08:15.949 --> 00:08:20.319
And at the bottom there, we just -- we read
the image files as data URLs and then we just

00:08:20.319 --> 00:08:25.490
set an image source tag, applied some nice
CSS transitions, transformations, pretty cool

00:08:25.490 --> 00:08:28.449
photo gallery there. But the code for that
-- right? -- a couple of lines and we have

00:08:28.449 --> 00:08:33.130
the ability to actually import files into
our app using drag and drop.

00:08:33.130 --> 00:08:40.820
Nice. Okay. So let's see all this sort of
working together.

00:08:40.820 --> 00:08:45.770
So this is soon to be a photo gallery application,
and what we've done here is I'm going to describe

00:08:45.770 --> 00:08:49.060
this and Arne's going to sort of drive it.
Basically what he did, if you want to run

00:08:49.060 --> 00:08:53.500
that one more time Arne, this is going to
send an XHR. It's going to pull down a zipped

00:08:53.500 --> 00:08:58.430
file, all in the client. It's going to uncompress
that zipped file and then read the image using

00:08:58.430 --> 00:09:00.690
--
&gt;&gt; We are now activating 400,000 devices on

00:09:00.690 --> 00:09:04.010
a daily I see.
&gt;&gt;Eric BidelmanThis is using typed arrays

00:09:04.010 --> 00:09:08.110
and some of the new capabilities of XHR, and
then of course we applied some CSS transitions

00:09:08.110 --> 00:09:09.110
and transformations here to present the photo
gallery. I'm getting hungry.

00:09:09.110 --> 00:09:10.310
&gt;&gt; Last year at Google I/O, we announced we
were adding 100,000 users on a daily basis

00:09:10.310 --> 00:09:13.100
--
&gt;&gt;Arne Roomann-Kurrik: I guess we're competing

00:09:13.100 --> 00:09:24.661
for your attention. Sorry about that.
&gt;&gt;Eric Bidelman: So just to show you what's

00:09:24.661 --> 00:09:29.250
happening, that's an HTML5 progress bar that
we're updating. That's a new tag as well and

00:09:29.250 --> 00:09:33.010
then we're unzipping the file. You can see
the uncompressed output there.

00:09:33.010 --> 00:09:37.490
So the blueprint for the photo gallery, you
know, not too complex. There's -- there's

00:09:37.490 --> 00:09:41.181
the XHR stuff. There's a Webworker that's
doing the decompression. I'm not going to

00:09:41.181 --> 00:09:44.670
go into the code of it, but again, it's going
to be available on that project page. We'll

00:09:44.670 --> 00:09:50.460
show you that link again at the end.
All right.

00:09:50.460 --> 00:09:53.560
So that's importing files. That's how you
get binary information into your application.

00:09:53.560 --> 00:09:58.391
Now, how can we use it? What can we do with
those files? We saw the metadata. Of course,

00:09:58.391 --> 00:10:02.210
there is the flower reader object. This is
going to give us the ability to asynchronously

00:10:02.210 --> 00:10:06.470
read the file into memory. You instantiate
a new file reader object.

00:10:06.470 --> 00:10:11.020
You can pick your poison. You can read it
as a binary string. You can read it as a data

00:10:11.020 --> 00:10:14.040
URL. These are really handy. Read the text
file. Or just give me the raw bytes, pull

00:10:14.040 --> 00:10:16.950
up an array buffer.
You are passing the file object through the

00:10:16.950 --> 00:10:20.080
blob, and that's the same one you got from
the drag-and-drop event, the same way you

00:10:20.080 --> 00:10:23.531
got from the file input.
At the bottom here, we can see that we can

00:10:23.531 --> 00:10:27.510
actually slice and dice this file. A good
example would be something like Gmail, right?

00:10:27.510 --> 00:10:31.080
You have this huge attachment. You don't want
to just send one request. You can cut this

00:10:31.080 --> 00:10:35.080
file up into multiple chunks and spawn off
multiple AJAX requests and then put the file

00:10:35.080 --> 00:10:39.000
together back on the server. A lot of really
cool options for you.

00:10:39.000 --> 00:10:43.290
Of course, we don't have to just read the
file. We just want to use the file, right?

00:10:43.290 --> 00:10:47.370
We can use the data URL. Most of you are probably
familiar with data URLs. Not going to cover

00:10:47.370 --> 00:10:51.660
them too deeply.
The basic format is data colon. You can construct

00:10:51.660 --> 00:10:57.340
these on the fly. The MIME type and then we'll
Base 64 encode the content, the string content.

00:10:57.340 --> 00:11:02.640
If you use the file reader object as a string,
a binary string, you can use this and present

00:11:02.640 --> 00:11:05.300
it to the users.
&gt;&gt;Arne Roomann-Kurrik: What's this function?

00:11:05.300 --> 00:11:08.520
&gt;&gt;Eric Bidelman: BTOA is the new method that's
been implemented to basically encode string

00:11:08.520 --> 00:11:11.380
data. You don't have to use a library anymore.
That's great.

00:11:11.380 --> 00:11:17.400
I just want to point out. Arne just opened
a link, and what he opened is a data URL.

00:11:17.400 --> 00:11:21.080
We haven't Base 64 encoded it. You don't need
to Base 64 encode the content. If it is not

00:11:21.080 --> 00:11:26.290
binary, you don't have to.
He opened up a text HTML data URL, and it

00:11:26.290 --> 00:11:29.590
is basically a text area with some styling,
with a placeholder, a border radius, right?

00:11:29.590 --> 00:11:37.990
And we constructed a cloud IDE on the fly.
See if your code compiles.

00:11:37.990 --> 00:11:43.540
&gt;&gt;Arne Roomann-Kurrik: Yes!
&gt;&gt;Eric Bidelman: Nice! That was a link he

00:11:43.540 --> 00:11:46.610
opened in the browser. You can share data
URLs. I can email him this data URL. He can

00:11:46.610 --> 00:11:53.490
open it in his browser. So they are persistent.
One less network. That's great.

00:11:53.490 --> 00:11:57.590
The downside, though, is a 30% overhead. So
if you have binary content in a large file,

00:11:57.590 --> 00:12:02.650
you're Base 64 encoding that, you will have
some overhead.

00:12:02.650 --> 00:12:07.290
However, the create object URLs, blob URLs
are something new to the Web platform as well.

00:12:07.290 --> 00:12:15.050
Basically, there is this new method, window.URL.createobjectURL.
You path the file object. This is the same

00:12:15.050 --> 00:12:18.890
file object you got from the input file type,
from the drag and drop. And then you call

00:12:18.890 --> 00:12:22.700
this. It will create this blob URL.
The scheme for that is sort of blob -- the

00:12:22.700 --> 00:12:26.470
origin of your application and then this random
hash that the browser, Chrome creates.

00:12:26.470 --> 00:12:30.210
I can't share this link. I can't send a blob
URL to Arne because his browser is not going

00:12:30.210 --> 00:12:32.340
to understand that. This is generated by my
browser.

00:12:32.340 --> 00:12:37.640
I just want to point out, if you want to bring
up the About page for this, there is some

00:12:37.640 --> 00:12:42.260
really handy pages in About About. These are
all Chrome's About pages. And there is one

00:12:42.260 --> 00:12:45.070
for blob internals.
These are all the blob URLs that we're creating.

00:12:45.070 --> 00:12:49.290
We are actually using these all over the place
in this presentation. You are actually instantiating

00:12:49.290 --> 00:12:54.000
a memory reference every time you do this.
There is a revoke object URL, be sure to call.

00:12:54.000 --> 00:12:59.970
So this doesn't come for free. But you can
remove them on the fly. That's pretty cool.

00:12:59.970 --> 00:13:04.380
So they are temporary. They are a handle to
the content. They are not "the" content, a

00:13:04.380 --> 00:13:08.690
data URL in the content itself. These are
just a handle. You can use these as a source

00:13:08.690 --> 00:13:13.330
attribute. You can use them as an HR attribute
all over the place just to use the file. Very,

00:13:13.330 --> 00:13:20.570
very handy. So a really neat example of using
a blob URL is the inline Web worker. Normally,

00:13:20.570 --> 00:13:25.000
right, you instantiate a Web worker with an
external JavaScript file that has all your

00:13:25.000 --> 00:13:28.950
worker code in it.
What we can do instead is inline our script

00:13:28.950 --> 00:13:33.930
tag, our code inside of the main application
and it will just use -- instead of text JavaScript,

00:13:33.930 --> 00:13:37.890
we'll use JavaScript Worker or any other MIME
type as long as the browser is not going to

00:13:37.890 --> 00:13:43.240
parse that as a script lock. So there is our
worker code. At the bottom, in our main application,

00:13:43.240 --> 00:13:47.800
we use the blob builder API. The blob builder
is going to allow us to create blob data,

00:13:47.800 --> 00:13:53.660
basically a file on the fly. We will pen the
inner text of the script tag inside of that

00:13:53.660 --> 00:13:58.250
blob builder and then we will call our work
by creating a object URL. We will pass this

00:13:58.250 --> 00:14:03.200
handle to this file we just created instead
of referencing an external JavaScript. Very

00:14:03.200 --> 00:14:09.790
cool example of using the blob URL.
So what's the support for this? Actually pretty

00:14:09.790 --> 00:14:15.370
good. All the file APIs, Safari, FireFox,
Chrome, you can see IE and Opera are sort

00:14:15.370 --> 00:14:20.250
of semitransparent. That's because they have
both announced at various levels support.

00:14:20.250 --> 00:14:24.200
IE9 has a lab, and then Opera has announced
recently that they will support a lot of these

00:14:24.200 --> 00:14:31.670
files APIs, too, in their next release.
All right. That's importing files. That's

00:14:31.670 --> 00:14:35.640
getting stuff in. That's manipulating it.
Now what can we do with it? We can do store

00:14:35.640 --> 00:14:40.840
it using a FileSystem API. This is a random
API in Chrome that we have implemented. It

00:14:40.840 --> 00:14:46.910
allows you to do read-write access to folders,
files, on this Sandbox FileSystem. There is

00:14:46.910 --> 00:14:52.560
a new property -- call that you can make,
request FileSystem. And you pass it persistent

00:14:52.560 --> 00:14:57.330
storage or temporary storage based on your
application's needs, the size of your expected

00:14:57.330 --> 00:15:03.290
sort of Sandbox that you are creating. The
API is asynchronous, so you are passing callbacks

00:15:03.290 --> 00:15:07.100
all over the place and passing a success in
most cases and then an error callback in case

00:15:07.100 --> 00:15:12.350
something goes wrong. Really easy to open
this sort of read-write access in Chrome.

00:15:12.350 --> 00:15:17.312
Of course, once you have this open, a good
thing to do would be open a file or create

00:15:17.312 --> 00:15:22.210
a file. You can obviously fetch a file. It
will create this logfile, for example.

00:15:22.210 --> 00:15:27.370
So in our callback -- in our success callback,
we will get this FS, this root object. This

00:15:27.370 --> 00:15:32.150
is just a directory object representing this
sort of hierarchy of our FileSystem we are

00:15:32.150 --> 00:15:37.450
interacting with. We pass the file name, logfile.
This options parameter will be create. So

00:15:37.450 --> 00:15:41.181
we will just create it. It doesn't exist.
What we will get back is a file entry object.

00:15:41.181 --> 00:15:45.860
The file entry object has various properties
on it, so what's the name, what's the full

00:15:45.860 --> 00:15:51.090
path in this sort of hierarchy that we're
creating. Is it a directory? Is it a file?

00:15:51.090 --> 00:15:55.330
The really important one here is the fileentry.file.
You can call this method. What you get back

00:15:55.330 --> 00:16:00.200
in the callback is actually a file object,
the same file object you saw in the input

00:16:00.200 --> 00:16:03.160
file, the same one you saw in the drag and
drop. This stuff is appearing all over the

00:16:03.160 --> 00:16:06.400
place, and there is a lot of interapp between
these different APIs now.

00:16:06.400 --> 00:16:11.200
Arne is highlighting various other properties
you expect from the platform, copy, give me

00:16:11.200 --> 00:16:15.290
my parent, move, remove. It is a very powerful
API.

00:16:15.290 --> 00:16:19.660
I want to just quickly point out that you
can write files to you. I'm not going to cover

00:16:19.660 --> 00:16:22.440
this code. There is a file writer object that
you create.

00:16:22.440 --> 00:16:26.990
So once you open this Sandbox file, you create
this writer and you can write that file object

00:16:26.990 --> 00:16:33.940
to this FileSystem. Without further ado, let's
show this stuff in action because I think

00:16:33.940 --> 00:16:39.660
it is worth a demo.
All right. I introduced you to the HTML5 terminal.

00:16:39.660 --> 00:16:45.200
We replicated a shell, basically, in HTML5,
thanks to the FileSystem API. We wrapped the

00:16:45.200 --> 00:16:52.140
API's calls with familiar UNIX commands. This
is just a Web application. Arne can LS. We

00:16:52.140 --> 00:16:58.550
have one file in our FileSystem. He can add
more. Of course, we can drag and drop. We

00:16:58.550 --> 00:17:03.350
are just writing these using the FileWriter
API. Let's do an LS again. Boom.

00:17:03.350 --> 00:17:06.000
Let's look at some food, Arne. I'm getting
hungry.

00:17:06.000 --> 00:17:07.110
&gt;&gt;Arne Roomann-Kurrik: Really?
&gt;&gt;Eric Bidelman: Yeah.

00:17:07.110 --> 00:17:12.220
&gt;&gt;Arne Roomann-Kurrik: Okay.
&gt;&gt;Eric Bidelman: We'll open a burger. Delicious.

00:17:12.220 --> 00:17:16.559
So this is just opening it up in the browser.
We have an Open command. We can cat that file.

00:17:16.559 --> 00:17:20.959
We will cat a text file. This is using the
FileReader API to read the contents of the

00:17:20.959 --> 00:17:22.949
file.
[ Beep ]

00:17:22.949 --> 00:17:28.339
HTML5 audio. So Arne makes a few mistakes,
we can implement a bell sound when he presses

00:17:28.339 --> 00:17:29.370
delete.
&gt;&gt;Arne Roomann-Kurrik: Just so you know.

00:17:29.370 --> 00:17:35.440
&gt;&gt;Eric Bidelman: Yeah. There's theming. We
have some basic theming. Let's change it to

00:17:35.440 --> 00:17:39.920
cream. Cool. If he presses "refresh," this
is using local storage. It will save his theme.

00:17:39.920 --> 00:17:44.899
I don't know if you want to save that preference.
I like the black personally myself.

00:17:44.899 --> 00:17:47.419
What else do we have, Arne? Zoom in a little
bit on that.

00:17:47.419 --> 00:17:52.960
This is just using CSS3 and replicating a
CRT sort of monitor.

00:17:52.960 --> 00:17:57.540
[ Laughter ]
It is completely superfluous.

00:17:57.540 --> 00:18:00.889
&gt;&gt;Arne Roomann-Kurrik: It is the most gratuitous
thing I have ever seen.

00:18:00.889 --> 00:18:03.100
&gt;&gt;Eric Bidelman: Sometimes you got to take
the extra step.

00:18:03.100 --> 00:18:10.070
What else? Wget. We can do -- HTML now has
the ability to do cross-domain XHRs. We can

00:18:10.070 --> 00:18:16.399
pull down html5rocks.com and just read and
print the source code to the terminal here.

00:18:16.399 --> 00:18:22.059
I think that's it. Is that it.
That is HTML5 terminal show. Again, FileSystem

00:18:22.059 --> 00:18:27.840
API is working together. A lot of stuff going
on. So we install this application as a Chrome

00:18:27.840 --> 00:18:32.399
Web store app. That I didn't explain. Web
audio API file drag and drop, we'll cover

00:18:32.399 --> 00:18:38.470
some of this in a bit. Very cool. Thanks to
the FileSystem. That's one, two and three

00:18:38.470 --> 00:18:44.029
ways now to generate URLs.
You saw Arne when the burger picture opened.

00:18:44.029 --> 00:18:47.700
That is using a new URL scheme. That's the
FileSystem URL. That goes along with this

00:18:47.700 --> 00:18:53.610
API. You have blob URLs. You have data URLs.
A third way to use a file directly is a FileSystem

00:18:53.610 --> 00:19:00.909
URL. So you can call the fileentry.toURL.
Arne is highlighting this. It is the origin

00:19:00.909 --> 00:19:07.660
of your application and then sort of the relative
path within the Sandbox. You can use it as

00:19:07.660 --> 00:19:12.070
an image source, a script source. Very cool.
You can take your entire application offline

00:19:12.070 --> 00:19:15.429
in the FileSystem.
There is a resolve local FileSystem URL call.

00:19:15.429 --> 00:19:21.669
So if you have one of these saved file URLs,
you can pass it to this method and then it

00:19:21.669 --> 00:19:27.100
will give you a file entry object that you
can manipulate with the API. So a lot of back

00:19:27.100 --> 00:19:31.049
and forth.
Cool. So FileSystem APIs, right now only in

00:19:31.049 --> 00:19:37.470
Chrome. And this is a particularly exciting
API, right? You are going to be storing things

00:19:37.470 --> 00:19:39.499
offline. You will be generating binary files
in your applications. We open the other browser

00:19:39.499 --> 00:19:43.169
vendors will implement this pretty soon.
&gt;&gt;Arne Roomann-Kurrik: Eric, you are telling

00:19:43.169 --> 00:19:48.230
me with this really advanced API that's coming
out and really kind of -- people are working

00:19:48.230 --> 00:19:50.850
on it, the best you can do was a terminal
that looks like it was from the '70s?

00:19:50.850 --> 00:19:54.350
&gt;&gt;Eric Bidelman: We took a step backwards
in computer graphics, didn't we?

00:19:54.350 --> 00:19:57.269
&gt;&gt;Arne Roomann-Kurrik: Yeah. We really blew
the goat on graphics there.

00:19:57.269 --> 00:19:59.820
&gt;&gt;Eric Bidelman: Do you have anything that
can --

00:19:59.820 --> 00:20:03.840
&gt;&gt;Arne Roomann-Kurrik: Yeah, I think I have
some stuff prepared. Do you want to jump into

00:20:03.840 --> 00:20:05.830
that?
&gt;&gt;Eric Bidelman: You do, fantastic. I will

00:20:05.830 --> 00:20:08.820
turn it over to Arne.
&gt;&gt;Arne Roomann-Kurrik: Yeah, just in case.

00:20:08.820 --> 00:20:11.029
I am going to talk about graphics on the Web.
When we are talking about the graphics on

00:20:11.029 --> 00:20:14.580
the Web, there is a lot of different approaches
that you can take to get, basically, the same

00:20:14.580 --> 00:20:19.799
effect, which is, basically, drawing something
onto the Web page or animating something over

00:20:19.799 --> 00:20:25.270
time and making it kind of move. There's three
different approaches I like to take when I

00:20:25.270 --> 00:20:29.289
think about this. The first is declarative.
Just tell the browser what to do and then

00:20:29.289 --> 00:20:33.789
it does all the heavy lifting for you. Otherwise,
I could script things. I could actually do

00:20:33.789 --> 00:20:39.480
the drawing myself and do, like, animation
frames and that kind of thing. Or there's

00:20:39.480 --> 00:20:44.919
even low-level access to hardware. And we'll
talk more about those.

00:20:44.919 --> 00:20:50.320
But, you know, starting with declare -- declarative
approaches, when I say "declarative" on the

00:20:50.320 --> 00:20:54.490
Web, most people think CSS. I just want to
kind of talk about SVG for a second here.

00:20:54.490 --> 00:21:01.190
SVG, if you are not familiar it, is a vector
file format that's kind of specified using

00:21:01.190 --> 00:21:03.399
XML.
What this lets you do is to draw lines and

00:21:03.399 --> 00:21:08.080
shapes and fills and use styling and all that
stuff in a way that actually is, first of

00:21:08.080 --> 00:21:12.369
all, human kind of readable, human constructable
and, then second of all, scales with resolution.

00:21:12.369 --> 00:21:18.220
So if you actually show this path that I'm
kind of running here and you can actually

00:21:18.220 --> 00:21:21.200
see on the right, we have a raster version
of that same path.

00:21:21.200 --> 00:21:27.019
You can see there is a quality difference
between the browser kind of rendering in SVG

00:21:27.019 --> 00:21:31.999
because it is using vector scaled up to a
larger resolution versus a bitmap which is

00:21:31.999 --> 00:21:35.289
just pixels and kind of stretched and blurry
when we blow it up.

00:21:35.289 --> 00:21:42.440
So moving on. SVG has a great kind of property
of having its own DOM. So just like the Web

00:21:42.440 --> 00:21:46.840
page has its own DOM, the image has its own
component elements that you can change and

00:21:46.840 --> 00:21:51.220
modify and the browser will do all the rendering.
You can see here that Eric is selecting some

00:21:51.220 --> 00:21:55.220
text that's been supplied to a path using
SVG. That's amazing because we can define

00:21:55.220 --> 00:21:59.919
the path and we can define the text and the
browser just takes care of all the rendering

00:21:59.919 --> 00:22:04.360
for us. The great thing is we can actually
wire it up with the text input. And as Eric

00:22:04.360 --> 00:22:08.869
is demonstrating right now, we can actually
change the image dynamically.

00:22:08.869 --> 00:22:11.900
Think about how powerful that is. Nice roller
coaster.

00:22:11.900 --> 00:22:18.309
Think about how powerful that is if you need
to localize "we" into 40 languages or whatever

00:22:18.309 --> 00:22:23.620
or if you want screen readers to access the
text and the image and so on.

00:22:23.620 --> 00:22:29.320
The great thing about this is that this SVG
syntax is actually in this page itself. We

00:22:29.320 --> 00:22:34.110
are not referencing an external file. The
SVG notation is actually part of the HTML5

00:22:34.110 --> 00:22:39.960
document that we're loading. You can do that.
You can just put SVG tags in and then put

00:22:39.960 --> 00:22:44.159
SVG notation in between.
But going back to what I mentioned before,

00:22:44.159 --> 00:22:50.309
most people think of CSS when we mention declarative
stuff. There's so many new features in CSS3,

00:22:50.309 --> 00:22:55.000
like, I really can't possibly cover them all
in a single presentation, even a section of

00:22:55.000 --> 00:22:58.369
them.
So here's just a bunch of interesting things.

00:22:58.369 --> 00:23:04.730
But we're kind of focusing down here. Let's
talk about one of my favorites, the animation

00:23:04.730 --> 00:23:09.080
key frames tab. And you can see here that
we have a spinning Chrome logo. And the way

00:23:09.080 --> 00:23:14.100
we've defined that is actually having this
new key frames notation. We specify a "from"

00:23:14.100 --> 00:23:19.639
state and "to" state. And then when we want
to apply that animation to an object from

00:23:19.639 --> 00:23:23.320
the DOM, we just basically say which animation,
how long is it going to take, how many times

00:23:23.320 --> 00:23:28.320
do you want to do it. And then we have this
kind of cubic bezier function here which lets

00:23:28.320 --> 00:23:33.110
you specify how the animation behaves. This
is really great because it shows you how powerful

00:23:33.110 --> 00:23:37.820
the declarative approach really is.
Why don't we kind of open a little bit more

00:23:37.820 --> 00:23:43.159
into that. What we have here is a little tool
that we've kind of done to represent the timing

00:23:43.159 --> 00:23:45.049
function.
Eric, why don't you load the linear timing

00:23:45.049 --> 00:23:47.139
function right now.
&gt;&gt;Eric Bidelman: Sure.

00:23:47.139 --> 00:23:49.929
&gt;&gt;Arne Roomann-Kurrik: There are some presets
that are available as part of the spec. You

00:23:49.929 --> 00:23:54.730
can see here that the linear kind of just
rotates the circle at a constant rate.

00:23:54.730 --> 00:24:01.220
Now, open up ease-in-out.
And if you do that, it will be slow and then

00:24:01.220 --> 00:24:04.350
fast and then slow again.
So again, you have these presets that let

00:24:04.350 --> 00:24:09.360
you kind of dictate how animation works. If
you're familiar -- well, if you've been watching

00:24:09.360 --> 00:24:13.169
the slides, you've actually seen the rotation
that we've been doing, and that's all done

00:24:13.169 --> 00:24:18.419
using this kind of -- this kind of syntax,
so it kind of has a little bit of a shape

00:24:18.419 --> 00:24:20.739
to it.
Of course you can specify custom points, so

00:24:20.739 --> 00:24:26.610
Eric here is kind of defining a custom animation.
It looks very strange. I don't know if anyone

00:24:26.610 --> 00:24:28.789
would ever use that.
&gt;&gt;Eric Bidelman: I'm using that in my next

00:24:28.789 --> 00:24:30.600
app. That one right there.
&gt;&gt;Arne Roomann-Kurrik: Okay. But again, just

00:24:30.600 --> 00:24:35.460
to show you how the -- as you define the custom
function, you can actually get a wide range

00:24:35.460 --> 00:24:41.470
of different animations just out of a declarative
approach. Looks like you're having a lot of

00:24:41.470 --> 00:24:42.909
fun there.
&gt;&gt;Eric Bidelman: Yeah. Sorry, we'll move on.

00:24:42.909 --> 00:24:46.149
&gt;&gt;Arne Roomann-Kurrik: Okay. So another kind
of unsung hero of, you know, new CSS stuff,

00:24:46.149 --> 00:24:50.299
I think, is 3D transforms, and we really like
this because, you know, hardware acceleration

00:24:50.299 --> 00:24:54.870
is now being like featured prominently in
some more browsers and we're really getting

00:24:54.870 --> 00:24:58.330
some interesting stuff out of it.
And you see that the slides themselves have

00:24:58.330 --> 00:25:02.239
a 3D effect to them, and we're doing that
all in CSS.

00:25:02.239 --> 00:25:05.799
So just to show you how that kind of works,
we have two nested elements here. We have

00:25:05.799 --> 00:25:10.399
a green box surrounded by a blue box, and
as Eric is showing, you can just select the

00:25:10.399 --> 00:25:15.529
number inside of it. It's just DOM, you know,
divs, and if you move -- if you actually activate

00:25:15.529 --> 00:25:21.330
the next sample, what we're doing is we're
actually rotating the green box out 45 degrees

00:25:21.330 --> 00:25:25.210
along the x-axis.
Now, the x-axis being, you know, from left

00:25:25.210 --> 00:25:30.990
to right. You can actually rotate out on that
plain, and by applying a CSS transform.

00:25:30.990 --> 00:25:35.860
Now, what we're going to do is rotate the
parent element, and we actually rotate it

00:25:35.860 --> 00:25:41.919
along the y-axis, so it rotates kind of away
from, you know, the viewer. And what's interesting

00:25:41.919 --> 00:25:45.230
about that third example is that it's not
popping out of the parent like you would expect

00:25:45.230 --> 00:25:48.899
it to. Looking at the second element, if you
saw that rotated out, you would expect that

00:25:48.899 --> 00:25:53.350
to kind of have its own coordinate space.
And the reason for that is that by default,

00:25:53.350 --> 00:25:58.749
CSS kind of maps the 3D transform against
the flat plain of its parent element. But

00:25:58.749 --> 00:26:03.830
you can break that. You can actually construct
models and objects in 3D by applying this

00:26:03.830 --> 00:26:06.759
preserve 3D transform style onto the object
itself.

00:26:06.759 --> 00:26:13.520
So it lets you create 3D models using CSS
notation, which is fantastic. It lets you

00:26:13.520 --> 00:26:15.640
do some really cool stuff.
Let's put some -- some of this together.

00:26:15.640 --> 00:26:20.770
So we have our old friend, the spinny Chrome
logo guy, and what we're going to do is build

00:26:20.770 --> 00:26:25.470
up a DOM. So we have a container element and
we're rotating that on its own axis, so along

00:26:25.470 --> 00:26:28.779
the y-axis, kind of slowly.
And then we're going to start putting panels

00:26:28.779 --> 00:26:33.730
into that DOM. And those panels are each rotated
90 degrees off of each other.

00:26:33.730 --> 00:26:38.139
So you can see here, as Eric kind of unhides
them, they're actually building up a model

00:26:38.139 --> 00:26:43.649
in 3D space that's rotating around this Chrome
logo that's in the center of that container.

00:26:43.649 --> 00:26:48.620
And so they all get the inherited rotation
of their parent element, and all we have to

00:26:48.620 --> 00:26:52.029
do is really just specify, you know, how they
interact with each other in space.

00:26:52.029 --> 00:26:57.299
Now, it would be really cool if we could do
some interactivity in this model. So the same

00:26:57.299 --> 00:27:01.789
way that you would take a hover state for
maybe a link, an anchor link, we can actually

00:27:01.789 --> 00:27:06.480
have a hover state for each of these DOM elements,
and then we apply a transition between them,

00:27:06.480 --> 00:27:10.129
you know, which tells the browser just if
you ever change one of these properties, just

00:27:10.129 --> 00:27:15.499
animate it linearly, or whatever. Then we
can actually have a fully interactive model

00:27:15.499 --> 00:27:20.240
that's defined entirely in CSS. There's not
a single line of JavaScript running this demo

00:27:20.240 --> 00:27:23.340
right now. That's really powerful. You just
kind of define the constraints and the browser

00:27:23.340 --> 00:27:27.740
takes care of all the rest.
So let's move on.

00:27:27.740 --> 00:27:31.879
Of course sometimes you do really just want
to script something. Sometimes you just want

00:27:31.879 --> 00:27:35.009
to draw something.
So we have the canvas element.

00:27:35.009 --> 00:27:39.230
And this is kind of like an image tag that
gives you a JavaScript API that you can draw

00:27:39.230 --> 00:27:43.639
into. And you can do some really cool stuff.
Like, for example, what we're doing here is

00:27:43.639 --> 00:27:47.259
just drawing kind of the state of the model
that we're running, and then we're clearing

00:27:47.259 --> 00:27:50.539
it, and then we're drawing it again and incrementing
the model itself.

00:27:50.539 --> 00:27:56.129
So we're getting an animation because we're
just drawing a bunch of frames. Yeah, you

00:27:56.129 --> 00:27:57.129
can move on.
&gt;&gt;Eric Bidelman: All right.

00:27:57.129 --> 00:27:58.299
&gt;&gt;Arne Roomann-Kurrik: So -- but what do we
do when we're doing animation?

00:27:58.299 --> 00:28:04.539
Well, we would normally just have a loop running.
We'd use this -- probably one of my least

00:28:04.539 --> 00:28:08.450
favorite JavaScript calls, window.set timeout,
and we'd be calling the draw function over

00:28:08.450 --> 00:28:13.659
and over again. And the reason why like window.set
timeout -- well, one of the reasons -- is

00:28:13.659 --> 00:28:19.039
that you specify milliseconds onto this function.
We have 10 here, and you can see that the

00:28:19.039 --> 00:28:21.509
animation is actually only running at about
20 milliseconds.

00:28:21.509 --> 00:28:25.630
So, first of all, it lies to us. You know,
this is the most untrustworthy function because

00:28:25.630 --> 00:28:30.419
it doesn't actually get called when we ask
it to. Second of all, I don't like it because

00:28:30.419 --> 00:28:35.309
most people do drawing inside of it, but the
browser doesn't know that we're doing drawing.

00:28:35.309 --> 00:28:39.660
So what happened is some really smart folks
decided that they wanted a new function that

00:28:39.660 --> 00:28:44.139
would be specific to animation and they introduced
the request animation frame function call.

00:28:44.139 --> 00:28:48.549
And why don't you switch over to the new hotness
right now.

00:28:48.549 --> 00:28:51.559
&gt;&gt;Eric Bidelman: New hotness! Wait a second.
Nothing changed.

00:28:51.559 --> 00:28:53.460
&gt;&gt;Arne Roomann-Kurrik: Yeah. That's a very
good observation, Eric.

00:28:53.460 --> 00:28:55.480
&gt;&gt;Eric Bidelman: Yeah.
&gt;&gt;Arne Roomann-Kurrik: This is actually because

00:28:55.480 --> 00:29:03.340
it kind of behaves the way that set timeout
was demonstrating, but now we have a contract

00:29:03.340 --> 00:29:07.039
with the browser, and the contract is: Only
call us when you want to draw something.

00:29:07.039 --> 00:29:10.580
So when the browser's ready to draw, it calls
us and then we do our little update and we

00:29:10.580 --> 00:29:14.450
say how many milliseconds it's been and then,
you know, we move on. So we're happy with

00:29:14.450 --> 00:29:17.200
that.
But let me show you how the browser can optimize

00:29:17.200 --> 00:29:20.690
this a little bit.
So Eric's going to kind of pull out of full-screen

00:29:20.690 --> 00:29:27.359
mode here. He's going to open up a new tab.
And what we have is the title of the existing

00:29:27.359 --> 00:29:30.359
tab kind of updating in time as the animation
frame call is happening.

00:29:30.359 --> 00:29:35.720
So if you zoom in there, open up a new tab
and focus it.

00:29:35.720 --> 00:29:38.830
Okay.
So this call has actually been frozen and

00:29:38.830 --> 00:29:43.090
the reason for that is because the browser
knows that we're doing animation in that callback,

00:29:43.090 --> 00:29:46.440
and it doesn't bother calling it when the
page that we're trying to do the animation

00:29:46.440 --> 00:29:50.080
on is not visible.
This is really powerful for things like mobile

00:29:50.080 --> 00:29:56.039
devices, items with limited CPU that might
want to run multiple demos, maybe even battery

00:29:56.039 --> 00:29:57.900
life, that kind of thing.
So why don't you go back and show them what

00:29:57.900 --> 00:30:03.539
happens when you use the old approach.
So we're just going to switch back, again,

00:30:03.539 --> 00:30:07.619
using windows set timeout. Remember that we're
requesting 10-millisecond updates. We're not

00:30:07.619 --> 00:30:12.879
getting that. But then when you open up a
new tab, it still updates.

00:30:12.879 --> 00:30:20.419
Now, Chrome is actually really efficient in
this case. It understands that the tab in

00:30:20.419 --> 00:30:23.529
the background might not need to be updated
as often. So it actually slows down the interval,

00:30:23.529 --> 00:30:27.929
the max -- or the minimum interval for windows.set
timeout when the tab is not active but you

00:30:27.929 --> 00:30:31.889
can still it's still being called. And that's
once a second that you might be drawing a

00:30:31.889 --> 00:30:36.759
complex 3D model or something like that.
So again, the request animation frame just

00:30:36.759 --> 00:30:40.340
kind of helps us have a contract with the
browser and really just kind of enforce that

00:30:40.340 --> 00:30:48.929
contract and allow it to optimize itself further.
So moving on, you have this canvas API, you

00:30:48.929 --> 00:30:53.029
have this request animation frame, and then
you have this great draw image function.

00:30:53.029 --> 00:30:57.280
This isn't really anything special, but what
I really like about it, what a lot of people

00:30:57.280 --> 00:31:02.609
don't kind of realize, is that you can draw
anything from any kind of image element, including

00:31:02.609 --> 00:31:08.960
images, other canvas elements, or even web
video, HTML5 video, into a canvas, and you

00:31:08.960 --> 00:31:12.019
can actually do things like draw sections
of an image.

00:31:12.019 --> 00:31:15.279
So you only need to load one image if you're
doing an animation function.

00:31:15.279 --> 00:31:18.539
You can see here that we have a whole sprite
sheet, and what we're doing is we wrote a

00:31:18.539 --> 00:31:23.570
little bit of a game that's just kind of animating
it and drawing it over and over again.

00:31:23.570 --> 00:31:26.509
Just to show you how responsive this is, Eric
is kind of drawing with his mouse this terrain.

00:31:26.509 --> 00:31:28.789
Little Chrome man here is jumping up and down.
Oh, you're giving him a hard time, man.

00:31:28.789 --> 00:31:34.789
&gt;&gt;Eric Bidelman: He can use a workout.
&gt;&gt;Arne Roomann-Kurrik: Okay. But just to show

00:31:34.789 --> 00:31:36.840
you again how powerful the canvas APIs can
be, how performant they can be, why don't

00:31:36.840 --> 00:31:39.639
you click on that background a little bit.
Kind of scroll down.

00:31:39.639 --> 00:31:45.350
You can see we're drawing a full motion video
directly into this and we're still maintaining

00:31:45.350 --> 00:31:50.600
that same fluid frame rate and it's all done
in JavaScript, all done using the canvas tags,

00:31:50.600 --> 00:31:54.299
but it just looks really cool and there's
a lot of potential there to do things like

00:31:54.299 --> 00:31:57.019
2D games.
Of course, you know, the last time I played

00:31:57.019 --> 00:32:00.149
a 2D game was a while ago.
&gt;&gt;Eric Bidelman: Yeah.

00:32:00.149 --> 00:32:05.029
&gt;&gt;Arne Roomann-Kurrik: Oh, no, that's not
true. I played Angry Birds the other day.

00:32:05.029 --> 00:32:07.669
[Laughter]
But, you know, kids like the 3D now. I'm sure

00:32:07.669 --> 00:32:10.830
we'll see something in the future like 3D
something.

00:32:10.830 --> 00:32:12.590
&gt;&gt;Eric Bidelman: TVs?
&gt;&gt;Arne Roomann-Kurrik: TVs. Yeah.

00:32:12.590 --> 00:32:18.899
But, yeah, so we have 3D support in the browser
now, because the kids like 3D.

00:32:18.899 --> 00:32:22.570
So anyway, Eric, I think we have a demo of
what the future of 3D in the browser is.

00:32:22.570 --> 00:32:25.190
&gt;&gt;Eric Bidelman: I think we do.
&gt;&gt;Arne Roomann-Kurrik: Any of you guys who

00:32:25.190 --> 00:32:26.620
might have gotten lucky enough to have some
glasses --

00:32:26.620 --> 00:32:29.309
&gt;&gt;Eric Bidelman: Now is the time, if you were
lucky enough to score some glasses.

00:32:29.309 --> 00:32:31.929
&gt;&gt;Arne Roomann-Kurrik: You know, every time
I go to the theater now, I need to put on

00:32:31.929 --> 00:32:34.470
these glasses, so we just figured Chrome is
just going to support that as well.

00:32:34.470 --> 00:32:36.970
&gt;&gt;Eric Bidelman: Absolutely.
&gt;&gt;Arne Roomann-Kurrik: All right. Eric, activate

00:32:36.970 --> 00:32:38.600
the demo.
&gt;&gt;Eric Bidelman: Yeah. Activating demo.

00:32:38.600 --> 00:32:43.919
&gt;&gt;Arne Roomann-Kurrik: Okay. And now activate
the motion controller.

00:32:43.919 --> 00:32:47.330
&gt;&gt;Eric Bidelman: Activating motion controller.
&gt;&gt;Arne Roomann-Kurrik: Oh, yeah. Yeah. This

00:32:47.330 --> 00:32:50.679
is -- welcome to the future of 3D in the browser.
&gt;&gt;Eric Bidelman: Ooooh.

00:32:50.679 --> 00:32:52.509
&gt;&gt;Arne Roomann-Kurrik: Ooooh. Ahhhh. No, I'm
just kidding.

00:32:52.509 --> 00:32:57.850
This is actually not the future of 3D in the
browser. We're actually just demoing another

00:32:57.850 --> 00:33:02.230
input event right now. Just kind of threw
it in there. It's the device orientation event

00:33:02.230 --> 00:33:07.809
handler, and this just lets you kind of just
have, you know, any sort of piece of hardware

00:33:07.809 --> 00:33:11.610
that's running your browser, like a mobile
device -- in this case, a Macbook which has

00:33:11.610 --> 00:33:15.720
a tilt sensor in it -- can actually send events
into your DOM page. So you can use this for,

00:33:15.720 --> 00:33:20.529
you know, more game inputs or things like
that. Really cool with animation, really cool

00:33:20.529 --> 00:33:24.419
when you're running models like this.
Hopefully you guys are seeing some 3D effect

00:33:24.419 --> 00:33:27.100
there.
But we actually do have a real 3D support,

00:33:27.100 --> 00:33:30.919
we don't need glasses for it, and we're calling
it WebGL.

00:33:30.919 --> 00:33:37.820
And this is a variant on OpenGL -- Actually
OpenGL ES 2 -- which is the same sort of technology

00:33:37.820 --> 00:33:42.799
that you'd use to program 3D in like a mobile
browser or tablet. And you can run this directly

00:33:42.799 --> 00:33:45.049
in the browser, as you saw in the keynote
today.

00:33:45.049 --> 00:33:47.620
So again, just show them how dynamic that
model is.

00:33:47.620 --> 00:33:52.690
And we're responding to DOM events because
WebGL is actually scripted through JavaScript

00:33:52.690 --> 00:33:57.009
so we can take advantage of all the DOM kind
of event model and all that stuff to have

00:33:57.009 --> 00:34:01.739
input into our games or simulations or whatever.
And you can see up here the code snippet is

00:34:01.739 --> 00:34:05.222
actually a WebGL shader which runs on the
GPU itself.

00:34:05.222 --> 00:34:10.020
So it gets uploaded to the GPU and it runs
on hardware. So you can see it's very fluid,

00:34:10.020 --> 00:34:14.990
it's very dynamic. You know, this isn't the
greatest demo, so let's -- let's see a little

00:34:14.990 --> 00:34:15.990
bit of a better one.
&gt;&gt;Eric Bidelman: Absolutely.

00:34:15.990 --> 00:34:19.409
&gt;&gt;Arne Roomann-Kurrik: You can see here that
we're taking a Chrome logo and we're just

00:34:19.409 --> 00:34:24.419
deforming the hell out of it, and, yeah, as
Eric is kind of pushing those pixels around,

00:34:24.419 --> 00:34:30.600
keep in mind that this is running on the GPU
of the Macbook itself, and we're kind of getting

00:34:30.600 --> 00:34:35.789
this really cool animation, really cool visualization.
Again, just using that power of JavaScript

00:34:35.789 --> 00:34:40.639
and hardware shaders.
So again, we saw a really cool demo in the

00:34:40.639 --> 00:34:45.260
keynote of WebGL. Don't really need to spend
too much more time on it.

00:34:45.260 --> 00:34:47.049
Probably a little bit too complex to go into
here.

00:34:47.049 --> 00:34:50.359
So why don't we see if we can maybe improve
the command line a little bit.

00:34:50.359 --> 00:34:53.190
&gt;&gt;Eric Bidelman: Okay. Let's take a look at
that again.

00:34:53.190 --> 00:34:57.420
&gt;&gt;Arne Roomann-Kurrik: Okay. So, yeah. Is
there any command we can run to kind of give

00:34:57.420 --> 00:35:00.190
it a little bit more style?
&gt;&gt;Eric Bidelman: Uh... there's a 3D demand.

00:35:00.190 --> 00:35:04.720
&gt;&gt;Arne Roomann-Kurrik: Yes, I like that.
&gt;&gt;Eric Bidelman: We can try that one.

00:35:04.720 --> 00:35:10.450
Let me run a special populate command first.
Let's try 3D. Hold onto your butts!

00:35:10.450 --> 00:35:15.280
[Laughter]
&gt;&gt;Arne Roomann-Kurrik: This is UDIX. I know

00:35:15.280 --> 00:35:16.550
this. Whoa!
[Applause]

00:35:16.550 --> 00:35:20.510
&gt;&gt;Arne Roomann-Kurrik: Whoa. This is awesome.
&gt;&gt;Eric Bidelman: Arne and are big movie fans,

00:35:20.510 --> 00:35:23.390
if you can't tell.
So, yeah, yeah. You want to explain what's

00:35:23.390 --> 00:35:25.070
going on here?
&gt;&gt;Arne Roomann-KurrikYeah. Actually, I'm getting

00:35:25.070 --> 00:35:29.609
a total vibe that this looks like two web
applications communicating via window.post

00:35:29.609 --> 00:35:34.160
message and sending messages back and forth.
&gt;&gt;Eric Bidelman: Sounds like somebody built

00:35:34.160 --> 00:35:35.160
this.
[Laughter]

00:35:35.160 --> 00:35:38.619
&gt;&gt;Arne Roomann-Kurrik: Actually, yeah. So
I think that's exactly what we're doing here.

00:35:38.619 --> 00:35:43.630
We have the same terminal application. We
have a WebGL simulation programmed by Ilmari,

00:35:43.630 --> 00:35:48.230
one of our awesome coworkers, and what we're
doing is we're actually just sending window.post

00:35:48.230 --> 00:35:52.250
messages back and forth between the I-frames
that are kind of running each of these demos.

00:35:52.250 --> 00:35:57.809
You can see here that the simulation is WebGL.
It's running really fast. It's dynamic. It's

00:35:57.809 --> 00:36:04.829
responding to Eric kind of doing some -- oh,
looks like you're in your home directory.

00:36:04.829 --> 00:36:05.829
&gt;&gt;Eric Bidelman: Oh, my cupcakes.
&gt;&gt;Arne Roomann-Kurrik: We found his secret

00:36:05.829 --> 00:36:08.410
stash. Yeah. That's really cool. But, yeah,
very dynamic, very smooth and fluid.

00:36:08.410 --> 00:36:12.950
&gt;&gt;Eric Bidelman: Wait. But, Arne, there is
a curious top secret directory in your user

00:36:12.950 --> 00:36:15.350
directory.
&gt;&gt;Arne Roomann-Kurrik: Oh, what's in there.

00:36:15.350 --> 00:36:19.800
&gt;&gt;Eric Bidelman: It says "HTML4 rocks."
&gt;&gt;Arne Roomann-Kurrik: Oh, no, no, no, no.

00:36:19.800 --> 00:36:20.800
Delete that, delete that.
&gt;&gt;Eric Bidelman: All right. Let me get that.

00:36:20.800 --> 00:36:24.330
&gt;&gt;Arne Roomann-Kurrik: Yeah. We don't want
that. They told us to get rid of confidential

00:36:24.330 --> 00:36:26.710
stuff in the --
&gt;&gt;Eric Bidelman: You know, it's not letting

00:36:26.710 --> 00:36:28.299
me for some reason.
&gt;&gt;Arne Roomann-Kurrik: Oh, I know this. This

00:36:28.299 --> 00:36:31.369
is UNIX so use pseudo.
&gt;&gt;Eric Bidelman: Okay. Let me try that.

00:36:31.369 --> 00:36:35.740
&gt;&gt;Arne Roomann-Kurrik: Oh, no, o. Close it,
close it. Shut it down, shut it down.

00:36:35.740 --> 00:36:38.530
&gt;&gt;Eric Bidelman: Oh, shutting down, shutting
down, shutting down.

00:36:38.530 --> 00:36:40.700
[Laughter]
&gt;&gt;Arne Roomann-Kurrik: Yeah. So we, again,

00:36:40.700 --> 00:36:44.829
have a blueprint here. "Image is broken."
But anyway.

00:36:44.829 --> 00:36:47.980
&gt;&gt;Eric Bidelman: The blueprint is top secret.
&gt;&gt;Arne Roomann-Kurrik: We use window.post

00:36:47.980 --> 00:36:51.940
message, WebGL to do the rendering and all
that stuff. Now, Eric, you were playing some

00:36:51.940 --> 00:36:54.381
interesting -- oh, there we go.
&gt;&gt;Eric Bidelman: There it is.

00:36:54.381 --> 00:36:57.119
&gt;&gt;Arne Roomann-Kurrik: You were playing some
interesting audio at the very end of that.

00:36:57.119 --> 00:36:59.720
&gt;&gt;Eric Bidelman: We have an audio section.
&gt;&gt;Arne Roomann-Kurrik: Oh, amazing!

00:36:59.720 --> 00:37:03.240
&gt;&gt;Eric Bidelman: Yeah. I too have prepared
some content.

00:37:03.240 --> 00:37:08.740
So yeah, so the whole multimedia story wouldn't
be complete without talking about audio, right?

00:37:08.740 --> 00:37:13.290
And, you know, many of us probably know HTML5
also is BFF -- best friends -- with audio.

00:37:13.290 --> 00:37:17.480
You're seeing a lot of this theme come up.
What we can do now, though, is be able to

00:37:17.480 --> 00:37:21.579
play things from the file system API, right?
We write audio to the file system API and

00:37:21.579 --> 00:37:24.960
play it. We can generate audio. So there's
a new API that we'll talk about that you can

00:37:24.960 --> 00:37:30.789
use to generate audio in real time in JavaScript.
If you don't want to generate it, you can

00:37:30.789 --> 00:37:35.450
analyze an existing sound file. So this is
really cool for real-time analysis of played

00:37:35.450 --> 00:37:39.490
music. So I just quickly want to recover -- right?
-- everybody knows about HTML5 audio. You

00:37:39.490 --> 00:37:43.240
know, there's an audio tag. It's native to
the browser. There's no plug-ins. This is

00:37:43.240 --> 00:37:46.579
really exciting. Pass it your source files.
All is well and good.

00:37:46.579 --> 00:37:50.770
This demo is probably the least sexy you'll
see today, but this is illustrating really

00:37:50.770 --> 00:37:55.390
a cool concept and that's being able to generate
audio using the file APIs we talked about.

00:37:55.390 --> 00:37:57.869
Arne is going to generate wav files, w-a-v
files.

00:37:57.869 --> 00:38:02.650
This is the same file system that we open
with the terminal, right? So that all the

00:38:02.650 --> 00:38:06.920
images are still there. He's just generated
two wav files using a nice JavaScript library

00:38:06.920 --> 00:38:12.920
for that using typed arrays. Go figure. And
then we can play that -- this is the file

00:38:12.920 --> 00:38:15.510
system -- you want to scroll up a little bit?
&gt;&gt;Arne Roomann-Kurrik: Yeah.

00:38:15.510 --> 00:38:18.720
&gt;&gt;Eric Bidelman: We're playing that. We're
saving that data, those files, to the file

00:38:18.720 --> 00:38:23.230
system and then reading the file system URL
that we talked about, and then rendering that,

00:38:23.230 --> 00:38:25.789
just populating the audio source tag with
that URL.

00:38:25.789 --> 00:38:29.050
So really nice example of this stuff working
together very nicely.

00:38:29.050 --> 00:38:34.680
So that's HTML5 audio, but I really want to
focus on a new API in Chrome which is the

00:38:34.680 --> 00:38:39.220
web audio API.
So the way this API works is that you -- you

00:38:39.220 --> 00:38:42.680
basically have this audio context that you
construct, very similar to canvas actually,

00:38:42.680 --> 00:38:46.680
and you manipulate the sort of nodes and system
as you go.

00:38:46.680 --> 00:38:50.599
So if you're just wanting to play a sound,
of course this is an API for sound so we can

00:38:50.599 --> 00:38:56.180
play a sound. Go figure. But you create this
audio text context with this new property

00:38:56.180 --> 00:38:59.940
in the window object, and then if we're just
going to play a sound, we just want to construct

00:38:59.940 --> 00:39:02.349
these nodes.
So we're going to construct a source node

00:39:02.349 --> 00:39:05.650
and just pass that off to our destination.
We're just going to play the sound. And the

00:39:05.650 --> 00:39:10.490
way that works is by creating a buffer source.
So we'll pull in our MP3 file or our audio

00:39:10.490 --> 00:39:15.369
file using XHR, and then we'll populate the
buffer with that array buffer data that we

00:39:15.369 --> 00:39:18.020
got.
And then we're just interested in playing

00:39:18.020 --> 00:39:22.859
the sound so we'll connect the source right
to the destination and then calling note on

00:39:22.859 --> 00:39:29.359
at time zero will just play that immediately.
[Beeping sound]

00:39:29.359 --> 00:39:33.829
So it's a bell. Not too exciting but, you
know, we can use this exactly as we would

00:39:33.829 --> 00:39:36.710
HTML5 audio.
Let's see something more interesting.

00:39:36.710 --> 00:39:41.960
So generating sound. This API allows you to
generate sound inside of JavaScript. I'm doing

00:39:41.960 --> 00:39:46.230
DSP.JS. That's a library that was written
for the Mozilla audio API. They have their

00:39:46.230 --> 00:39:50.030
own API. But you can use that also with this
API in Chrome.

00:39:50.030 --> 00:39:55.089
So I'm generating a sine tone, and instead
of loading up an audio file, we're just going

00:39:55.089 --> 00:39:58.369
to pass that off. We're going to create a
buffer, pass that buffer, that sine wave,

00:39:58.369 --> 00:40:02.299
off into our API, and then connect the source
to the destination. We're just going to play

00:40:02.299 --> 00:40:06.750
this audio file.
At the bottom here, we have two canvases.

00:40:06.750 --> 00:40:09.730
So Arne is going to play around with frequency.
This is all real time as he's doing this and

00:40:09.730 --> 00:40:13.910
Chrome is generating the sound. And we're
rendering that frequency data out to the canvas

00:40:13.910 --> 00:40:17.390
tag, which is the oscillation.
So you can change different types using that

00:40:17.390 --> 00:40:20.710
DSP.JS library.
What's happening on the right is actually

00:40:20.710 --> 00:40:26.250
a Webworker so we're calculating the FFT -- right?
-- the spectrum of the audio file -- the audio

00:40:26.250 --> 00:40:29.120
sound, on the right side, so that's why there's
a little bit of a delay. We're passing out

00:40:29.120 --> 00:40:34.349
data, doing the calculating, it's coming back,
and then rendering that out to Canvas.

00:40:34.349 --> 00:40:37.050
Having fun?
&gt;&gt;Arne Roomann-Kurrik: Always.

00:40:37.050 --> 00:40:39.819
&gt;&gt;Eric Bidelman: Of course, we can generate
sound. We can play sound. But what's really,

00:40:39.819 --> 00:40:44.329
really amazing about this API -- the Web audio
API is you can analyze existing sound. So

00:40:44.329 --> 00:40:48.562
I kid you not, in ten lines of code, maybe
11, 12, depending on what you are counting,

00:40:48.562 --> 00:40:53.539
you can analyze a sound file and then present
that to your users with some kind of visualization.

00:40:53.539 --> 00:40:58.260
We will do the exact same thing. We will create
an audio context. This time we are interested

00:40:58.260 --> 00:41:02.730
in analyzing it. We will create an analyzer
node. We'll create a JavaScript node. The

00:41:02.730 --> 00:41:06.180
JavaScript node is going to fire events at
us, and we will be able to process -- as audio

00:41:06.180 --> 00:41:09.510
is processing in the system, we will be able
to take that and do something with it.

00:41:09.510 --> 00:41:13.710
In that event -- Arne will zoom in here. Do
you want to highlight the portions of the

00:41:13.710 --> 00:41:15.280
code too?
&gt;&gt;Arne Roomann-Kurrik: Oh, yeah.

00:41:15.280 --> 00:41:18.890
&gt;&gt;Eric Bidelman: Cool.
We are using a typed array. This is will be

00:41:18.890 --> 00:41:23.289
more performance for us the frequency bin
is going to be filled by this "get" frequency

00:41:23.289 --> 00:41:27.529
data call. It is going to fill this array
with frequency data. We can use that. We will

00:41:27.529 --> 00:41:33.329
see a couple of demos of that for visualization.
Same thing again, we are just connecting these

00:41:33.329 --> 00:41:37.160
sort of blocks that we are creating. So we
will create our buffer. We will load the file

00:41:37.160 --> 00:41:42.420
in. And then we'll connect source to analyzer,
analyzer, the JavaScript node that gives us

00:41:42.420 --> 00:41:46.550
the events, and then the JavaScript node to
the destination.

00:41:46.550 --> 00:41:47.599
So let's see a demo of that.
&gt;&gt;Arne Roomann-Kurrik: you are going to show

00:41:47.599 --> 00:41:48.599
them the prototype?
&gt;&gt;Eric Bidelman: Yeah. Is that okay? We are

00:41:48.599 --> 00:41:54.200
working on a new computer.
&gt;&gt;Arne Roomann-Kurrik: Last time it didn't

00:41:54.200 --> 00:41:57.369
work out so well.
&gt;&gt;Eric Bidelman: We'll show them anyway.

00:41:57.369 --> 00:42:03.750
This is Gal 9000, a new prototype, another
operating system Google is working on. If

00:42:03.750 --> 00:42:08.349
you want to zoom in on this. This is just
a DIB. This is all markup with rounded corners,

00:42:08.349 --> 00:42:11.240
linear gradients. I apologize, it looks better
in the lab tap. He has got a radial gradient

00:42:11.240 --> 00:42:17.900
that's producing the red-block effect and
the dot in the center, multiple backgrounds,

00:42:17.900 --> 00:42:20.960
right? The only image on this page is that
reflection at the top. Probably wondering

00:42:20.960 --> 00:42:23.930
how -- what this has to do with audio.
&gt;&gt;&gt; Good afternoon, gentlemen and ladies.

00:42:23.930 --> 00:42:24.930
I am a Gal 9000 computer. I became operational
at the Googleplex in Mountain View, California,

00:42:24.930 --> 00:42:38.339
on the 4th of May, 2011. My instructor was
Eric Schmidt.

00:42:38.339 --> 00:42:46.460
&gt;&gt;Eric Bidelman: We can create an artificial
life form to talk to us. This is actually

00:42:46.460 --> 00:42:51.589
Arne's voice. We have loaded up an MP3 file.
And what's going on is as this file is playing,

00:42:51.589 --> 00:42:55.829
we are analyzing using the API, this Web audio
API.

00:42:55.829 --> 00:42:59.490
In the center there, you can see his voice
and that's a Canvas tag. We are rendering

00:42:59.490 --> 00:43:04.130
Canvas based on the amplitude of each of the
samples we get. That's what's doing the flickering.

00:43:04.130 --> 00:43:07.490
Also CSS3, so we are changing the radius of
that CSS3 gradient. That's what's producing

00:43:07.490 --> 00:43:08.490
that effect on the red-to-black.
&gt;&gt;&gt; The Web audio API is really quite nice.

00:43:08.490 --> 00:43:10.620
&gt;&gt;Eric Bidelman: I like it. All right. Turn
off the prototype.

00:43:10.620 --> 00:43:18.460
&gt;&gt;Arne Roomann-Kurrik: I'm afraid I can't
do that, Eric.

00:43:18.460 --> 00:43:29.250
&gt;&gt;Eric Bidelman: Nice. So that's Gal.
Again, Web audio API, Canvas. What else? Typed

00:43:29.250 --> 00:43:33.460
arrays, again, this stuff is showing up all
over the place in these complicated APIs.

00:43:33.460 --> 00:43:40.339
Let's see some more visualizations we can
do using the analysis portion of this API.

00:43:40.339 --> 00:43:42.740
Go ahead and press start.
[ Music ]

00:43:42.740 --> 00:43:46.520
I will start of talk through this. But it
is audio so you got to listen to it, too.

00:43:46.520 --> 00:43:48.559
Arne, you are going to deejay?
&gt;&gt;Arne Roomann-Kurrik: Yeah.

00:43:48.559 --> 00:43:53.549
&gt;&gt;Eric Bidelman: Arne is going to deejay this.
This is again analyzing the sound file on

00:43:53.549 --> 00:43:56.770
the fly in realtime, and then we will are
just rendering each of those bins. We are

00:43:56.770 --> 00:44:00.059
moving through that typed array and then rendering
that to Canvas.

00:44:00.059 --> 00:44:04.460
This is this cool little half circle. That's
a filter -- an SVG filter over this Canvas

00:44:04.460 --> 00:44:11.920
element and a gradient that's used as a mask.
Let's go ahead and hit "next."

00:44:11.920 --> 00:44:16.010
Boom, CSS3 animation. It is just Canvas, so
we can change the coloring of what we are

00:44:16.010 --> 00:44:19.970
presenting, change the gradient there.
Arne, do you want to go to options and play

00:44:19.970 --> 00:44:25.400
around a little bit?
[ Music ]

00:44:25.400 --> 00:44:29.900
So, again, we can render this data any way
we want in Canvas. You don't have to use WebGL.

00:44:29.900 --> 00:44:35.660
You can use CSS3. You just saw a demo of that.
We are just presenting it a different way.

00:44:35.660 --> 00:44:39.200
You can do time or frequency domain analysis,
time domain. Analysis.

00:44:39.200 --> 00:44:45.750
You can speed up the playback rate. Go ahead
and do that.

00:44:45.750 --> 00:44:53.599
Nice. Let's go to the next slide.
So this is the HTML5 logo. Again, Canvas but

00:44:53.599 --> 00:44:57.549
it has been overlaid with the HTML5 logo as
the webkit mask there. You can take that one

00:44:57.549 --> 00:45:03.000
step further, and Arne introduced us to some
really great transformations in CSS. So we

00:45:03.000 --> 00:45:06.619
can apply a 3D transform to this entire thing
and in realtime it is still going. There is

00:45:06.619 --> 00:45:10.609
a little bit of flicker, and we are using
Chrome dub channel. So leading-edge stuff

00:45:10.609 --> 00:45:14.991
here.
Let's go ahead and show the next visualization.

00:45:14.991 --> 00:45:19.160
So Chrome, little beat detection library.
We can beat detect Chrome. CSS reflection

00:45:19.160 --> 00:45:28.109
on the bottom there. Kind of a cool effect.
Are you having fun by yourself? Can we invite

00:45:28.109 --> 00:45:30.950
some people to this party? We have people
streamed in.

00:45:30.950 --> 00:45:37.420
&gt;&gt;Arne Roomann-Kurrik: I have an idea. I can
invite my special guest.

00:45:37.420 --> 00:45:41.930
&gt;&gt;Eric Bidelman: Bug Droid. We can animate
Bug Droid. He's just markup as well with rounded

00:45:41.930 --> 00:45:47.640
corners. His ears are going. His leg is twitching.
He is really getting into it just using CSS3

00:45:47.640 --> 00:45:50.930
transitions and animations.
But, if we turn this up, if we get really

00:45:50.930 --> 00:46:00.370
excited, we get a fist pump. Yeah!
Just CSS and using the API to analyze the

00:46:00.370 --> 00:46:06.050
sound file on the fly. I'm just getting that
data and rendering it as the amplitude changes.

00:46:06.050 --> 00:46:11.779
All right. So that's -- yes, thank you.
[ Applause ]

00:46:11.779 --> 00:46:18.410
So that's the Web audio API. I only showed
you a small portion. There is effects. There's

00:46:18.410 --> 00:46:21.640
panning. There is convolution. There's all
kinds of stuff. You can imagine when you have

00:46:21.640 --> 00:46:26.700
microphone access, then the device API, when
that comes out, the ability to talk into a

00:46:26.700 --> 00:46:31.690
microphone and do auto-tune in the Web browser,
that's going to be really cool.

00:46:31.690 --> 00:46:36.510
So support right now, just Chrome. But FireFox
is sort of -- actually I didn't tilt it. But

00:46:36.510 --> 00:46:41.220
FireFox has their own API. A lot of these
demos should work in both of the APIs. So

00:46:41.220 --> 00:46:45.980
they are very similar but, again, with differences.
&gt;&gt;Arne Roomann-Kurrik: I don't know about

00:46:45.980 --> 00:46:48.500
you, Eric, but I'm full, I'm stuffed.
&gt;&gt;Eric Bidelman: Full on what?

00:46:48.500 --> 00:46:51.809
&gt;&gt;Arne Roomann-Kurrik: Knowledge.
&gt;&gt;Eric Bidelman: Yeah, that was a lot of stuff.

00:46:51.809 --> 00:46:57.400
We went pretty quickly. 13 minutes to spare.
So let's just sort of recap what we covered

00:46:57.400 --> 00:47:01.329
because we did cover a lot. Bleeding-edge
stuff in Chrome all available on dub channel

00:47:01.329 --> 00:47:03.119
today.
First, I started off with the file APIs. How

00:47:03.119 --> 00:47:09.431
do you get binary data in your application?
How do you work with it? How do you manipulate

00:47:09.431 --> 00:47:13.039
it? How do you store it using the FileSystem
API and the terminal demo?

00:47:13.039 --> 00:47:15.160
&gt;&gt;Arne Roomann-Kurrik: Then I talked about
graphics. Again, the three approaches that

00:47:15.160 --> 00:47:19.690
I like to think about: Declarative with CSS
and SVG, scripting with JavaScript and the

00:47:19.690 --> 00:47:23.819
Canvas element, and then accessing low-level
APIs through WebGL.

00:47:23.819 --> 00:47:28.510
&gt;&gt;Eric Bidelman: Yep. And then I rounded out
the picture with multi-media story. Put gold

00:47:28.510 --> 00:47:31.480
in your pocket with the Web audio API. There
is a lot of great stuff.

00:47:31.480 --> 00:47:33.289
&gt;&gt;Arne Roomann-Kurrik: A lot of gold in your
pocket.

00:47:33.289 --> 00:47:35.230
&gt;&gt;Eric Bidelman: A lot of gold. You might
not be able to walk out of here.

00:47:35.230 --> 00:47:39.060
&gt;&gt;Arne Roomann-Kurrik: We have a lot of resources.
Again, they are all linked to this presentation.

00:47:39.060 --> 00:47:43.260
You will find links to the presentation after
the session. We have it all hosted on a code

00:47:43.260 --> 00:47:51.299
hosting project and all that stuff. We have
it hosted at htmlfivewow.com. But it is not

00:47:51.299 --> 00:47:55.119
open yet. We will turn it on after we get
done.

00:47:55.119 --> 00:48:00.519
&gt;&gt;Eric Bidelman: Yep.
&gt;&gt;Arne Roomann-Kurrik: Once again, please,

00:48:00.519 --> 00:48:05.840
you know, find the feedback link. It's goo.gl/ac8n7,
all lowercase. We really appreciate the feedback.

00:48:05.840 --> 00:48:10.339
We get a mandate to come back and again and
do some more crazy stuff if you guys like

00:48:10.339 --> 00:48:15.750
us.
So I think that's it. Thanks for being a great

00:48:15.750 --> 00:48:19.599
audience.
[ Applause ]

00:48:19.599 --> 00:48:27.549
I'm going to launch this Moderator.
&gt;&gt;Eric Bidelman: Go for it. Time for questions

00:48:27.549 --> 00:48:44.579
if people are interested. If you have any
questions, step up to the mic. We will start

00:48:44.579 --> 00:48:51.289
rattling off the Moderator questions here.
Yeah. So as -- Yeah, as we kind of -- as people

00:48:51.289 --> 00:48:55.450
trickle out, I know you are probably eager
to get to your next session lunch.

00:48:55.450 --> 00:48:58.619
&gt;&gt;Arne Roomann-Kurrik: Or lunch, yeah. What
software Web technology are you using for

00:48:58.619 --> 00:49:01.930
your presentation? That's actually a great
question. We didn't really emphasize it. We're

00:49:01.930 --> 00:49:06.930
using HTML, JavaScript, CSS.
We just wrote it all by hand. It is part of

00:49:06.930 --> 00:49:13.200
that open source project. And we'll be happy
to go over that. We will probably post tutorials

00:49:13.200 --> 00:49:14.619
about how we built stuff on html5rocks.com.
Live question?

00:49:14.619 --> 00:49:19.881
&gt;&gt;&gt; You guys had that request animation frame
function. So when you switched the tab, it

00:49:19.881 --> 00:49:23.650
obviously stops, right?
&gt;&gt;Arne Roomann-Kurrik: Yeah.

00:49:23.650 --> 00:49:32.650
&gt;&gt;&gt; What happens when you hide the element
or you set it invisible, does it stop as well?

00:49:32.650 --> 00:49:36.849
&gt;&gt;Arne Roomann-Kurrik: Yeah. In Chrome's case,
it doesn't currently.

00:49:36.849 --> 00:49:38.799
&gt;&gt;&gt; Okay.
&gt;&gt;Arne Roomann-Kurrik: At least from my quick

00:49:38.799 --> 00:49:43.180
testing on it. But that's part of the idea
behind the specs, so I think it is just not

00:49:43.180 --> 00:49:46.880
implemented yet. Eventually, it should be
that if you hide the Canvas element, you don't

00:49:46.880 --> 00:49:50.460
need to make any sort of callbacks or change
your game code or anything.

00:49:50.460 --> 00:49:52.500
&gt;&gt;&gt; Okay, great.
&gt;&gt;Arne Roomann-Kurrik: That's exactly what

00:49:52.500 --> 00:49:55.170
it's intended for.
&gt;&gt;Eric Bidelman: So similar question: What

00:49:55.170 --> 00:49:59.569
slide -- How are we doing the slides? It is
all going to be open source.

00:49:59.569 --> 00:50:04.890
There are sort of HTML5 -- other people are
doing different HTML5 slide decks here at

00:50:04.890 --> 00:50:09.049
I/O this year and on html5rocks, there is
sort of a template and you can take that and

00:50:09.049 --> 00:50:15.600
use that in your own slides as well. This
particular one uses CSS3 transforms and transitions.

00:50:15.600 --> 00:50:23.310
&gt;&gt;Arne Roomann-Kurrik: You can down arrow.
Yeah?

00:50:23.310 --> 00:50:25.190
&gt;&gt;&gt; In the audio demo, what were you guys
using to do the FFT?

00:50:25.190 --> 00:50:28.200
&gt;&gt;Eric Bidelman: The FFT is calculated in
the API itself. So there's' the API call for

00:50:28.200 --> 00:50:29.200
that.
&gt;&gt;&gt; Oh, awesome.

00:50:29.200 --> 00:50:33.420
&gt;&gt;Eric Bidelman: The API, I didn't explain,
it exposes a lot of low-level functionality.

00:50:33.420 --> 00:50:38.319
If you have ever done the Mozilla API, everything
is basically in JavaScript and you get events.

00:50:38.319 --> 00:50:39.892
This one, you do the FFT -- there is a call
for it and panning effects and convolution

00:50:39.892 --> 00:50:41.050
and all that cool stuff.
&gt;&gt;&gt; Awesome. Do you know if that will be offloaded

00:50:41.050 --> 00:50:51.700
to the GPU in the future, if possible?
&gt;&gt;Eric Bidelman: Good question. Right now

00:50:51.700 --> 00:50:58.480
it is all CPU. It is brand-new, just landed.
Hopefully, yeah. Sure hardware sell everything

00:50:58.480 --> 00:51:04.170
if we can.
&gt;&gt;&gt; Yeah, exactly. Cool, thanks.

00:51:04.170 --> 00:51:08.309
&gt;&gt;Arne Roomann-Kurrik: I guess we will do
another one online.

00:51:08.309 --> 00:51:09.309
&gt;&gt;Eric Bidelman: Sure.
&gt;&gt;Arne Roomann-Kurrik: HTML5 on Droid devices.

00:51:09.309 --> 00:51:12.900
Google does support HTML5 on Android devices.
The Android browser can render HTML5, so...

00:51:12.900 --> 00:51:20.869
I don't know about marketplace. We don't really
talk about marketplace right now. So I don't

00:51:20.869 --> 00:51:26.050
know. I'm not sure I follow.
&gt;&gt;Eric Bidelman: Maybe somebody in the Android

00:51:26.050 --> 00:51:27.799
section can answer.
&gt;&gt;Arne Roomann-Kurrik: I'm sure that's a good

00:51:27.799 --> 00:51:34.609
question for the Android sessions.
&gt;&gt;&gt; With the HTML5 audio and video tags, if

00:51:34.609 --> 00:51:41.510
the browser doesn't support a particular codec,
is there extension abilities to install that?

00:51:41.510 --> 00:51:47.550
&gt;&gt;Arne Roomann-Kurrik: That's actually a good
question. Right now I don't believe so. I

00:51:47.550 --> 00:51:51.760
think that Native Client in that case might
be an interesting technology to use because

00:51:51.760 --> 00:51:54.960
Native Client is an open source project that's
Google's kind of helping develop.

00:51:54.960 --> 00:52:01.970
You can write C code and compile it in a way
that's secure, has a Sandbox and run it on

00:52:01.970 --> 00:52:05.490
arbitrary HTML sites.
So in that case, if you had a custom codec,

00:52:05.490 --> 00:52:09.480
you could probably implement it using Native
Client and draw out to a Canvas element or

00:52:09.480 --> 00:52:11.700
something at high speed.
I would imagine that would be the approach

00:52:11.700 --> 00:52:18.069
to take. I don't know of any, like, extensions
that could let you do that.

00:52:18.069 --> 00:52:19.970
&gt;&gt;&gt; Thanks.
&gt;&gt;Arne Roomann-Kurrik: Sure.

00:52:19.970 --> 00:52:23.500
&gt;&gt;Eric Bidelman: Moderator question: Has there
been any work letting Web applications handle

00:52:23.500 --> 00:52:28.060
multiple windows? If I understand the question
correctly, just being able to open up multiple

00:52:28.060 --> 00:52:32.599
tabs maybe in your Web application, there
is actually a really great use case for Shared

00:52:32.599 --> 00:52:36.540
Workers here. So Web Workers, there is a version
called Shared Workers that you can basically

00:52:36.540 --> 00:52:40.460
fire up this worker. It is sort of a background
process, if you will, that you can use to

00:52:40.460 --> 00:52:44.720
manage multiple -- the same state across multiple
tabs and communicate inner-tab communication.

00:52:44.720 --> 00:52:50.049
&gt;&gt;Arne Roomann-Kurrik: It is like having an
invisible window that can talk to any other

00:52:50.049 --> 00:52:51.750
window on your domain. So, yeah, that's actually
really useful for that kind of thing.

00:52:51.750 --> 00:52:52.750
&gt;&gt;&gt; One more question. So you guys were getting
file handlers and folder handlers and stuff.

00:52:52.750 --> 00:52:53.750
Is there any way to persist folder handler,
let's say, to a next session or through a

00:52:53.750 --> 00:53:12.319
cache or something like that so you don't
have to get the user to give you the folder

00:53:12.319 --> 00:53:13.670
handler?
&gt;&gt;Eric Bidelman: It is a great question. Right

00:53:13.670 --> 00:53:19.019
now, this sort of HTML file system API is
a Sandbox per app, per origin. You can't write

00:53:19.019 --> 00:53:24.599
files outside of this location. There is an
API that's been spec'ed out that's not been

00:53:24.599 --> 00:53:28.670
implemented called a FileSaver API.
This will allow you to do things like open

00:53:28.670 --> 00:53:32.440
the user's -- with permission, of course,
open the user's "My Pictures" folder and read

00:53:32.440 --> 00:53:37.230
and write data to that. Right now it is just
a spec. Nothing has been implemented.

00:53:37.230 --> 00:53:40.720
&gt;&gt;Arne Roomann-Kurrik: In terms of extending
those handlers, not right now, I think there's

00:53:40.720 --> 00:53:45.880
-- like, I have seen some vague discussion
about it, just -- it would be nice to have.

00:53:45.880 --> 00:53:59.329
I think people are going to think about it.
Right now the FileSystem stuff is where the

00:53:59.329 --> 00:54:06.319
focus is.
&gt;&gt;&gt; Because of the Sandbox, there is no way

00:54:06.319 --> 00:54:08.270
to sort of have the location of the file without
the user's interaction access that folder?

00:54:08.270 --> 00:54:09.270
&gt;&gt;Arne Roomann-Kurrik: Not like a persistent
handle to some shared directory on your FileSystem

00:54:09.270 --> 00:54:10.270
or something.
&gt;&gt;Eric Bidelman: For example, you saw in the

00:54:10.270 --> 00:54:11.450
demo -- the FileSystem terminal demo, he was
dragging in files and that's how we got them

00:54:11.450 --> 00:54:14.740
in. We are actually duplicating -- there is
two copies. There is the original folder and

00:54:14.740 --> 00:54:18.190
then there is the one we are duplicating into
the FileSystem. There is always that interaction

00:54:18.190 --> 00:54:21.849
right now.
Or you can import them if you had the zip

00:54:21.849 --> 00:54:25.849
file. That photo gallery demo, if that was
not local, that was on a server, you could

00:54:25.849 --> 00:54:30.539
download that and then save that to the FileSystem
as well. There's different options.

00:54:30.539 --> 00:54:37.750
&gt;&gt;&gt; Okay, thanks. Great talk.
&gt;&gt;Arne Roomann-Kurrik: Schizophrenic question.

00:54:37.750 --> 00:54:46.640
Let's see. Rendering HTML5 versus Android
apps. We're not in any position to say that.

00:54:46.640 --> 00:54:51.480
I think Google is supporting both apps. We
have got lots of talent.

00:54:51.480 --> 00:54:54.069
&gt;&gt;Eric Bidelman: The beauty about HTML5 is
you can run it anywhere, right? There is Web

00:54:54.069 --> 00:54:55.069
apps and all these platforms run those.
&gt;&gt;Arne Roomann-Kurrik: And Android apps are

00:54:55.069 --> 00:54:56.069
one thing and then Web apps are another.
&gt;&gt;&gt; Hey, guys. Whoa.

00:54:56.069 --> 00:54:57.069
I'm working on an HTML5 game and in one of
your other sessions, you guys recommended

00:54:57.069 --> 00:55:16.590
using Sound Manager 2. In what instances should
I be using Sound Manager 2 over -- or Web

00:55:16.590 --> 00:55:25.190
audio API?
&gt;&gt;Eric Bidelman: So kind of a different use

00:55:25.190 --> 00:55:28.819
cases. Web audio API is going to allow you
to do effects on audio and things like that.

00:55:28.819 --> 00:55:33.079
I just showed you only portions of it, right?
Sound Manager is great -- a great option right

00:55:33.079 --> 00:55:38.240
now for using sound across browsers.
Audio -- there has been a lot of bugs in Chrome

00:55:38.240 --> 00:55:44.140
for HTML5 audio that have been recently resolved.
But as far as audio is concerned, Flash is

00:55:44.140 --> 00:55:49.609
great. Sound Manager is great. We definitely
recommend it. Chrome can run Flash. Why not,

00:55:49.609 --> 00:55:53.809
if that's the best option for you.
&gt;&gt;Arne Roomann-Kurrik: I think the major concern

00:55:53.809 --> 00:55:58.829
that Sound Manager was trying to address was
that the audio tag had no contract between

00:55:58.829 --> 00:56:04.359
when you wanted a sound to play and when it
would actually play. It wasn't meant for low

00:56:04.359 --> 00:56:10.609
latency or no latency audio effects.
So in the case of -- so people started using

00:56:10.609 --> 00:56:15.309
that and it was really kind of intended for
streaming or that kind of thing. So people

00:56:15.309 --> 00:56:17.460
started using that for sound effects. It wasn't
really suited. That's why we have that other

00:56:17.460 --> 00:56:22.549
API that Eric was demoing, that it is really
kind of more inline with what Sound Manager

00:56:22.549 --> 00:56:27.170
is trying to achieve, which is like, I have
a game and I clicked a key and I want to play

00:56:27.170 --> 00:56:30.800
a sound right now. The latency is a lot better.
I think Sound Manager's support is just much

00:56:30.800 --> 00:56:32.930
wider at this point.
&gt;&gt;Eric Bidelman: That's really a good point.

00:56:32.930 --> 00:56:38.150
So if you want your users to use Chrome and
use the audio -- this web audio API, there's

00:56:38.150 --> 00:56:42.230
that note-on function. When Arne was pressing
the button, the bell called note-on at time

00:56:42.230 --> 00:56:43.809
zero.
You can actually schedule when stuff things.

00:56:43.809 --> 00:56:48.630
So the API was designed for low-latency things
like games -- right? -- button clicks, beeps,

00:56:48.630 --> 00:56:50.480
and stuff.
&gt;&gt;Arne Roomann-Kurrik: Sequencers.

00:56:50.480 --> 00:56:51.480
&gt;&gt;Eric Bidelman: Sequencers, all that stuff,
yeah.

00:56:51.480 --> 00:56:54.060
&gt;&gt;Arne Roomann-Kurrik: Yeah.
&gt;&gt;Eric Bidelman: So I mean if you want to

00:56:54.060 --> 00:57:00.520
stick with that API until it becomes standard
across different browsers, there's a specification

00:57:00.520 --> 00:57:05.089
out there right now, but Chrome is the only
nav implemented.

00:57:05.089 --> 00:57:07.859
&gt;&gt; All right. Thanks, guys.
&gt;&gt;Eric Bidelman: Yeah. Sure. Okay.

00:57:07.859 --> 00:57:11.590
Well, again, "Will this presentation be online
somewhere?"

00:57:11.590 --> 00:57:14.690
Yes. HTML5wow.googlecode.com.
"Is Google's Panda algorithm set up to be

00:57:14.690 --> 00:57:20.299
looking and liking HTML5 compared to just
standard HTML?"

00:57:20.299 --> 00:57:25.079
Don't know the details of Google's crawling
algorithm. It does understand -- webmaster

00:57:25.079 --> 00:57:29.720
tools actually does understand micro-data
and micro-formats. I think it presents different

00:57:29.720 --> 00:57:32.740
things based on what you have on your page,
right? If you have a --

00:57:32.740 --> 00:57:33.740
&gt;&gt;Arne Roomann-Kurrik: Yeah.
&gt;&gt;Eric Bidelman: -- like a music site -- right?

00:57:33.740 --> 00:57:38.940
-- you can do albums, it will understand that
and parse that out.

00:57:38.940 --> 00:57:42.470
I don't know about the semantic tags. Keep
in mind that a lot of this stuff is still

00:57:42.470 --> 00:57:47.369
changing, so yes, the -- all the browsers
now have HTML5 semantic tags mostly implemented,

00:57:47.369 --> 00:57:52.061
but a good example of this changing is the
H group tag, if you're familiar with that.

00:57:52.061 --> 00:57:56.690
They kind of pulled it out, put it back in,
pulled it out. So the specification is still

00:57:56.690 --> 00:58:01.250
changing. Until I think that really solidifies
and everybody is, you know, solidified on

00:58:01.250 --> 00:58:06.470
something, then I don't know if Google will
update itself, but honestly no idea.

00:58:06.470 --> 00:58:10.279
&gt;&gt;Arne Roomann-Kurrik: I think -- yeah.
&gt;&gt;Eric Bidelman: "What is the link to the

00:58:10.279 --> 00:58:12.640
presentation?"
So the presentation itself is HTMLfivewow.com.

00:58:12.640 --> 00:58:14.190
&gt;&gt;Arne Roomann-Kurrik: Where five is spelled
out.

00:58:14.190 --> 00:58:16.460
&gt;&gt;Eric Bidelman: Where five is spelled out,
so f-i-v-e.

00:58:16.460 --> 00:58:18.269
&gt;&gt;Arne Roomann-Kurrik: But it's under a password
right now.

00:58:18.269 --> 00:58:21.250
&gt;&gt;Eric Bidelman: Yes. Sorry.
&gt;&gt;Arne Roomann-Kurrik: As soon as we get off

00:58:21.250 --> 00:58:22.910
stage --
&gt;&gt;Eric Bidelman: Yeah. For anybody viewing,

00:58:22.910 --> 00:58:28.630
it will be up as soon as we get off stage.
"The time and frequency domain analysis was

00:58:28.630 --> 00:58:31.810
amazing. Is that processed via some JavaScript
library?"

00:58:31.810 --> 00:58:38.309
So the time and frequency domain is part of
the API, so there's a call on that analyzer

00:58:38.309 --> 00:58:47.500
node that I created. Analyzer.get frequency
data as a time domain or frequency data as

00:58:47.500 --> 00:58:51.309
a sample domain.
And so, yeah, that's part of the API itself.

00:58:51.309 --> 00:58:55.640
So just to contrast, the Mozilla API I think
you have to do all that processing in JavaScript.

00:58:55.640 --> 00:59:00.700
This one you basically just fill an array
and then use that array. You saw me render

00:59:00.700 --> 00:59:04.020
that array to canvas. That's what was going
on there.

00:59:04.020 --> 00:59:07.100
"Terminal seems to be awesome." It seems?
It is awesome! "Is it available on Chrome

00:59:07.100 --> 00:59:12.390
store or G-lab someplace. I couldn't find
it. Maybe you'll share it." Yeah. So we -- there's

00:59:12.390 --> 00:59:19.079
a tutorial on HTML5rocks.com that has the
file system API access and that's sort of

00:59:19.079 --> 00:59:23.809
the v1 of this. We've definitely done some
new stuff and capabilities for this presentation.

00:59:23.809 --> 00:59:28.520
I will put this up on the Web Store. One thing
that we didn't discuss was you saw Arne at

00:59:28.520 --> 00:59:33.119
the beginning type "install." The terminal
was installed, and that's installing the application

00:59:33.119 --> 00:59:36.750
as a Chrome Web Store application, and it
actually -- that's needed right now because

00:59:36.750 --> 00:59:41.089
in order to use -- in order to write data
to the file system, you need to have either

00:59:41.089 --> 00:59:45.359
a flag running on Chrome, unlimited quota,
or something like that.

00:59:45.359 --> 00:59:50.180
Most users don't know how to, you know, start
Chrome with a flag, so if you have the unlimited

00:59:50.180 --> 00:59:54.030
storage bit in your manifest file for your
Chrome Web Store app, that's what allows you

00:59:54.030 --> 00:59:58.099
to do the read and write right now.
As soon as Chrome expands and it has a sort

00:59:58.099 --> 01:00:01.549
of a quota system, then we'll have the ability
to -- to -- any Web application can use the

01:00:01.549 --> 01:00:05.130
file system API to write data. So yes, I -- the
short answer is I will put that up on the

01:00:05.130 --> 01:00:06.130
Web Store someplace.
&gt;&gt;Arne Roomann-Kurrik: I think we're out of

01:00:06.130 --> 01:00:07.940
time actually.
&gt;&gt;Eric Bidelman: Are we out of time.

01:00:07.940 --> 01:00:12.109
&gt;&gt;Arne Roomann-Kurrik Yeah.
&gt;&gt;Eric Bidelman: Okay. Well, thanks again.

01:00:12.109 --> 01:00:15.249
Thanks for being a great audience.
[Applause]

