WEBVTT
Kind: captions
Language: en

00:00:01.230 --> 00:00:03.200
All right, we are live.

00:00:03.200 --> 00:00:06.285
Hi everyone, may name is Mark,
I am co-chair at Udacity for

00:00:06.285 --> 00:00:09.310
the intro to programming nano-degree.

00:00:09.310 --> 00:00:10.807
Joining me online is Luke.

00:00:10.807 --> 00:00:12.421
He is also another co-chair.

00:00:12.421 --> 00:00:15.877
And today, we're just going
to do a little broadcast and

00:00:15.877 --> 00:00:17.320
talk about functions.

00:00:18.550 --> 00:00:23.239
What are functions, how do we use
functions, what are the tips and

00:00:23.239 --> 00:00:27.344
tricks to use functions and
what are the common gotchas and

00:00:27.344 --> 00:00:31.665
the common things that you need
to lookout for in functions.

00:00:31.665 --> 00:00:38.000
The majority of everyone will
be learning Python, right now.

00:00:38.000 --> 00:00:43.305
And you will be learning functions or
have learned functions.

00:00:43.305 --> 00:00:47.190
And we feel like this is
a very important concept,

00:00:48.510 --> 00:00:53.700
such as, much like loops and decisions
things like if and else statements.

00:00:53.700 --> 00:00:56.890
These functions make up a core,

00:00:56.890 --> 00:01:01.475
I think a very very core
core concept in programming.

00:01:01.475 --> 00:01:02.455
What do you think Luke, like,

00:01:02.455 --> 00:01:05.865
how important are functions,
pages, in programming?

00:01:05.865 --> 00:01:06.755
&gt;&gt; Without.

00:01:06.755 --> 00:01:08.555
So functions are.

00:01:08.555 --> 00:01:10.355
I mean,
they are one of the most basic things.

00:01:10.355 --> 00:01:13.395
They're one of the most foundational
things you do in programming.

00:01:13.395 --> 00:01:16.835
Everything you do,
if you're a competent programmer,

00:01:16.835 --> 00:01:20.023
will involve writing lots and
lots of functions.

00:01:20.023 --> 00:01:24.540
They're, sort of one
of the smaller bits of

00:01:25.750 --> 00:01:28.470
the programming world that
you will use constantly.

00:01:28.470 --> 00:01:31.300
It's very very foundational,
it's something that you have to,

00:01:31.300 --> 00:01:34.900
you really should make sure that you
understand very well about what it is,

00:01:34.900 --> 00:01:37.030
how to use it, everything like that.

00:01:38.800 --> 00:01:40.057
&gt;&gt; Yeah.

00:01:40.057 --> 00:01:42.472
Great thanks for your viewpoint Luke.

00:01:42.472 --> 00:01:46.859
I agree with you,
if functions do not exist,

00:01:46.859 --> 00:01:51.593
we would not be able to
program as efficiently and

00:01:51.593 --> 00:01:55.184
as elegantly as we can in this world.

00:01:55.184 --> 00:02:00.318
So again if you want, one that you
should walk away from this broadcast

00:02:00.318 --> 00:02:05.192
is functions are very important and
you should invest the time into

00:02:05.192 --> 00:02:10.155
practicing creating as many functions
as you can because trust me,

00:02:10.155 --> 00:02:16.820
trust us, this will help you with it for
the rest of your programming career.

00:02:16.820 --> 00:02:21.419
Great, so
we're going to start doing our,

00:02:21.419 --> 00:02:25.530
start to talk about our presentation.

00:02:25.530 --> 00:02:29.600
So, but if you have any
questions relating to functions,

00:02:29.600 --> 00:02:34.540
please post these online and we'll
address these questions for you as well.

00:02:34.540 --> 00:02:35.490
So Luke you have the floor.

00:02:36.710 --> 00:02:37.210
&gt;&gt; Okay.

00:02:38.350 --> 00:02:40.760
So the first thing that we
really should establish from,

00:02:40.760 --> 00:02:43.460
we're talking about functions,
is exactly what a function is.

00:02:44.810 --> 00:02:48.800
So functions which we'll also probably
refer to as procedures since they're

00:02:48.800 --> 00:02:50.830
the same thing in Python.

00:02:50.830 --> 00:02:53.690
They're bits of code that
you can call repetitively.

00:02:53.690 --> 00:02:56.210
And generally when you think
about functions you're thinking

00:02:56.210 --> 00:02:59.760
about something with defined input and
defined output.

00:02:59.760 --> 00:03:04.110
But foundationally in Python
functions are something that you can

00:03:04.110 --> 00:03:08.900
define once and
then use as many times as you'd like.

00:03:08.900 --> 00:03:12.180
So if I were to screen
share a little bit here.

00:03:13.590 --> 00:03:17.300
So the first thing,

00:03:17.300 --> 00:03:21.720
as far as using functions that you
should know, is how to make them.

00:03:21.720 --> 00:03:26.220
So you start a function
with the keyword def,

00:03:26.220 --> 00:03:30.340
that's your definition of the function.

00:03:30.340 --> 00:03:31.840
Then you give it some name.

00:03:34.020 --> 00:03:37.610
The name would be some function here and

00:03:37.610 --> 00:03:43.370
then these two parentheses
are necessary for a function.

00:03:43.370 --> 00:03:46.960
It is where you would define
some parameter if you had one.

00:03:46.960 --> 00:03:49.130
We'll go over what those are later.

00:03:49.130 --> 00:03:51.990
But you need here because
we're going to use just

00:03:51.990 --> 00:03:53.620
a function with no parameters what so
ever.

00:03:54.760 --> 00:03:56.290
Then you need a colon and

00:03:56.290 --> 00:04:00.780
then whatever is inside that indentation
is going to be your function.

00:04:00.780 --> 00:04:05.384
That's going to be the code you can
reuse however often as you want.

00:04:05.384 --> 00:04:09.552
[CROSSTALK]
&gt;&gt; Sorry to interrupt you, but

00:04:09.552 --> 00:04:16.180
I just want to really emphasize how
important indentations are in Python.

00:04:16.180 --> 00:04:20.584
You will find some other programs,
they don't care about indentation, but

00:04:20.584 --> 00:04:24.380
in order to be able to define your
functions appropriately you need

00:04:24.380 --> 00:04:27.429
to indent all the lines that
belong in your function or

00:04:27.429 --> 00:04:29.422
else your function will not work.

00:04:29.422 --> 00:04:33.090
[BLANK_AUDIO]

00:04:33.090 --> 00:04:35.494
&gt;&gt; And
as we're going on with indentation,

00:04:35.494 --> 00:04:38.587
it's un-indenting back to
where the function was,

00:04:38.587 --> 00:04:42.380
the same level the function is to
find out that ends the function.

00:04:43.430 --> 00:04:46.820
You can also end the function with
a return statement, which we'll go over

00:04:46.820 --> 00:04:51.700
later, but that's not really ending
where the definition would end,

00:04:51.700 --> 00:04:54.510
that's just ending where
the code will stop running.

00:04:54.510 --> 00:04:57.680
But in Python,
the function end is where it unindents.

00:04:58.860 --> 00:05:02.990
But so as we were kind of
going over with the function,

00:05:02.990 --> 00:05:05.110
you give it some code to run in here.

00:05:05.110 --> 00:05:08.310
So let's just say we're going to print.

00:05:09.860 --> 00:05:12.685
Hello world.

00:05:12.685 --> 00:05:14.542
So that's what the function does.

00:05:14.542 --> 00:05:20.072
Now to call the function you simply
call it by saying the name no def,

00:05:20.072 --> 00:05:25.420
no colon here and with the given
parameters you're going to use.

00:05:25.420 --> 00:05:30.780
So if I were to run this, which I
obviously had right before we started,

00:05:30.780 --> 00:05:33.300
I'm going to get the output,
Hello World.

00:05:33.300 --> 00:05:37.070
In fact, I can do this however many
times I want with calling the function.

00:05:39.260 --> 00:05:44.990
And it will run three times here,
three times.

00:05:44.990 --> 00:05:48.457
Hopefully all that's visible for
you, but yeah.

00:05:48.457 --> 00:05:51.980
So now as we keep going here,

00:05:51.980 --> 00:05:55.520
there's a few things to note about
functions that are very important.

00:05:57.170 --> 00:06:00.720
Functions create something
called a local scope.

00:06:00.720 --> 00:06:05.520
So a variable that you make inside
of a function doesn't exist

00:06:05.520 --> 00:06:07.720
outside of the function.

00:06:07.720 --> 00:06:12.050
This is in contrast with
a global scope where

00:06:12.050 --> 00:06:16.770
some variable that you make
will be available at all times.

00:06:16.770 --> 00:06:20.240
So as a quick example of that,
let's just

00:06:21.810 --> 00:06:26.740
make some function that does
something pretty simple.

00:06:28.280 --> 00:06:32.310
So here we're having a global
variable called a = 6, and

00:06:32.310 --> 00:06:35.140
we're having a local
variable called a = 5.

00:06:35.140 --> 00:06:39.520
So both variables are named a but
they're not the same variable.

00:06:39.520 --> 00:06:43.370
So we can see that when
we're running our function,

00:06:43.370 --> 00:06:47.720
printing out a string,
that prints out a and

00:06:47.720 --> 00:06:53.300
remember we redefined a here as equal
to five and then after our function is

00:06:53.300 --> 00:06:58.550
done running, we can print
what the global variable is.

00:07:06.260 --> 00:07:11.889
And as we run that whole thing, you'll
see that inside the function a = 5 and

00:07:11.889 --> 00:07:16.030
then outside,
a = 6 because it never got redefined.

00:07:16.030 --> 00:07:19.440
This a has nothing to do with this a.

00:07:19.440 --> 00:07:22.700
Although they have the same name,
they don't point to the same object.

00:07:25.270 --> 00:07:30.070
One thing to note here is that this a
right here, after we run some function,

00:07:30.070 --> 00:07:30.860
it's destroyed.

00:07:30.860 --> 00:07:32.298
It ceases to exist.

00:07:32.298 --> 00:07:35.878
So that's,

00:07:35.878 --> 00:07:41.070
with how global works if we were
to take out this a equals five,

00:07:41.070 --> 00:07:44.480
you'll notice that the functions
should still work.

00:07:45.870 --> 00:07:50.379
All of a sudden we're just using the
global version of a since we never make

00:07:50.379 --> 00:07:51.697
a local version of a.

00:07:51.697 --> 00:07:56.729
However, if we take out this

00:07:56.729 --> 00:08:01.347
this string a right here.

00:08:01.347 --> 00:08:06.845
Is going to produce an error.

00:08:06.845 --> 00:08:09.780
So I make this a little larger.

00:08:09.780 --> 00:08:12.530
It runs this successfully and

00:08:12.530 --> 00:08:17.090
then when it gets to here,
this A isn't, doesn't exist anymore.

00:08:17.090 --> 00:08:18.190
It's gone.

00:08:18.190 --> 00:08:21.750
So this produces an error
saying that A is not defined.

00:08:23.730 --> 00:08:28.492
The reason again why that happens is
this A is global it can work anywhere.

00:08:28.492 --> 00:08:33.429
This A is local,
it only works inside the function.

00:08:35.179 --> 00:08:40.600
So for a way around that we have
something called parameters

00:08:40.600 --> 00:08:45.770
as far as how we're going to
get in some variable that we

00:08:45.770 --> 00:08:50.520
actually want to use inside the function
without relying on global variables.

00:08:50.520 --> 00:08:51.800
So as a quick aside here,

00:08:51.800 --> 00:08:55.440
global variables are generally
a big no no in programming.

00:08:55.440 --> 00:08:58.694
Sometimes you're going to end up using
them just because they're easiest for

00:08:58.694 --> 00:09:00.120
the short thing you're doing.

00:09:00.120 --> 00:09:03.307
But you should if there's a way
to avoid global variables,

00:09:03.307 --> 00:09:04.710
avoid global variables,

00:09:04.710 --> 00:09:08.983
always stick to local variables because
then you can't screw something up that

00:09:08.983 --> 00:09:12.576
you don't think you're going to
screw up with your function but.

00:09:12.576 --> 00:09:15.801
[BLANK_AUDIO]

00:09:15.801 --> 00:09:17.400
So on to parameters.

00:09:18.400 --> 00:09:21.309
So I'll just copy and paste this quick.

00:09:21.309 --> 00:09:26.489
A parameter is some value that
can be passed into a function.

00:09:26.489 --> 00:09:31.681
So here,
I made some same name as a function

00:09:31.681 --> 00:09:38.130
that I pass in parameter_1 and
parameter_2.

00:09:38.130 --> 00:09:44.340
So when you actually do that to call it,
those values can be anything you want.

00:09:44.340 --> 00:09:48.430
So it doesn't have to like, they don't
have to be called parameter one or

00:09:48.430 --> 00:09:52.020
parameter two, you don't have to pass
a variable that has that same name.

00:09:52.020 --> 00:09:56.030
All you have to do is put them in
order and they both have to exist.

00:09:56.030 --> 00:10:00.360
So if I were to run this,
I'm going to get.

00:10:00.360 --> 00:10:03.720
First I'm going to run print parameter_1
which you can see is Hello World here.

00:10:03.720 --> 00:10:07.515
And the second thing I'm going to get
is 2 since that's what I passed in for

00:10:07.515 --> 00:10:08.880
paramenter_2.

00:10:08.880 --> 00:10:12.030
Now if I only gave this Hello World,

00:10:12.030 --> 00:10:14.450
what's going to happen is that
I'm going to get an error.

00:10:14.450 --> 00:10:19.030
Because the function takes two
parameters, arguments another name for

00:10:19.030 --> 00:10:23.130
parameters here, and
then I only gave it one.

00:10:23.130 --> 00:10:26.520
So that's always something you
have to watch out for here.

00:10:29.030 --> 00:10:31.500
This can also be done with variables.

00:10:31.500 --> 00:10:35.550
So let's say instead

00:10:35.550 --> 00:10:40.050
of passing in Hello World I want to pass
in a variable that says Hello World.

00:10:42.000 --> 00:10:49.715
And then b = 2, so I'll get the same
thing here by passing in two variables,

00:10:49.715 --> 00:10:55.380
the same way I would have with just
the print function as a print statement.

00:10:55.380 --> 00:11:00.380
Where that will once again
pass in a the value of a to

00:11:00.380 --> 00:11:05.510
parameter one and
the value of b to parameter two.

00:11:05.510 --> 00:11:11.450
One quick thing to note here is what
happens to parameter one doesn't affect

00:11:11.450 --> 00:11:15.740
a because these are things that
are called immutable objects.

00:11:16.818 --> 00:11:21.730
So if you've, depending on how far
you've gotten into the course,

00:11:21.730 --> 00:11:26.260
you'll have found things like lists and
dictionaries to be mutable objects as

00:11:26.260 --> 00:11:31.620
opposed to immutable objects which are
things like string, ints, floats, your

00:11:31.620 --> 00:11:38.600
standard variables that you probably
use the most that aren't containers.

00:11:38.600 --> 00:11:41.980
So a good quick starting point for

00:11:41.980 --> 00:11:47.800
mutability is a good understanding
of variables themselves.

00:11:47.800 --> 00:11:53.419
So here if I can just open
up interpreter here and

00:11:53.419 --> 00:11:56.936
do this more easily that way.

00:11:56.936 --> 00:12:06.392
[BLANK_AUDIO]

00:12:06.392 --> 00:12:10.486
I run it straight from straight from
the command line here at the terminal.

00:12:10.486 --> 00:12:14.830
So just running Python.

00:12:14.830 --> 00:12:20.774
So with the variables, a variable points
to a value that it holds in Python.

00:12:20.774 --> 00:12:26.121
So, say I have a = 5, a is,
no, that was supposed to.

00:12:26.121 --> 00:12:28.234
[BLANK_AUDIO]

00:12:28.234 --> 00:12:31.860
So, it's already running Python, a = 5.

00:12:31.860 --> 00:12:35.396
a now is a variable that
points to the value of five.

00:12:35.396 --> 00:12:39.834
[BLANK_AUDIO]

00:12:39.834 --> 00:12:40.611
Sorry.

00:12:42.710 --> 00:12:47.385
When you change an immutable value for
an immutable variable what

00:12:47.385 --> 00:12:51.730
you're doing is you're changing
what the thing points to.

00:12:51.730 --> 00:12:55.670
So you're not actually
changing the constant five,

00:12:55.670 --> 00:13:00.130
you're changing a to
point to some new value.

00:13:00.130 --> 00:13:03.430
So I can see this with the id function.

00:13:03.430 --> 00:13:06.200
This gives me what it's pointing to.

00:13:06.200 --> 00:13:11.790
If I were to just change that to six,
what I get, if I say id (a),

00:13:11.790 --> 00:13:16.895
is a completely,
notice that this is different than this.

00:13:18.205 --> 00:13:21.475
That it's pointing to
an entirely different object.

00:13:21.475 --> 00:13:26.895
So five here being an object and six
being an object where they're explicitly

00:13:26.895 --> 00:13:30.465
not the same thing that's been
pointed to, they're different values.

00:13:30.465 --> 00:13:34.375
Now if I tried that same
thing with a mutable object.

00:13:34.375 --> 00:13:37.337
So let's just say a list of some sort.

00:13:37.337 --> 00:13:42.310
So now I'm going to say a is
some lists and I take id of a.

00:13:42.310 --> 00:13:44.362
I can alter that list.

00:13:44.362 --> 00:13:48.913
[BLANK_AUDIO]

00:13:48.913 --> 00:13:51.940
So just to show its altered,
it's now that.

00:13:51.940 --> 00:13:57.120
And I get the exact same value for
id of a.

00:13:57.120 --> 00:13:58.530
It points to the same object.

00:13:58.530 --> 00:14:00.690
The list is still the same list.

00:14:00.690 --> 00:14:02.160
It's just mutated.

00:14:02.160 --> 00:14:02.960
It's changed.

00:14:04.550 --> 00:14:05.293
&gt;&gt; Hey Luke.

00:14:05.293 --> 00:14:07.782
&gt;&gt; Yeah.
&gt;&gt; Can you increase the font size a bit?

00:14:07.782 --> 00:14:11.419
&gt;&gt; Gotcha.

00:14:11.419 --> 00:14:18.173
So quick overview of what I did,
now with legible font sizes.

00:14:18.173 --> 00:14:23.082
When I switched a from equaling five
to six ints which are immutable values,

00:14:23.082 --> 00:14:24.780
the id actually changed.

00:14:26.340 --> 00:14:28.960
Because six and five are constants.

00:14:28.960 --> 00:14:33.350
They didn't change the pointer
that a referred to had to.

00:14:33.350 --> 00:14:36.600
Now when I made it a list,

00:14:36.600 --> 00:14:41.960
the id did not change when I changed the
list because the list itself changed.

00:14:41.960 --> 00:14:44.020
Instead of the pointer.

00:14:44.020 --> 00:14:50.550
So that's that's how variables work as
far, in Python, and that's going to have

00:14:50.550 --> 00:14:57.140
pretty dramatic effects with what
we're doing with functions here.

00:14:57.140 --> 00:15:00.160
So moving back to sublime.

00:15:04.230 --> 00:15:10.510
If I pass in an immutable variable or
a mutable variable to a function.

00:15:10.510 --> 00:15:16.040
What happens to the variable inside
the function happens to it outside.

00:15:16.040 --> 00:15:18.940
When I pass in an immutable variable,

00:15:20.220 --> 00:15:25.220
you can see with the very
word immutable that variable,

00:15:25.220 --> 00:15:29.800
what happens inside the function does
not affect what value is passed in.

00:15:29.800 --> 00:15:34.440
So let's just write up a quick
little part to show this.

00:15:36.120 --> 00:15:39.630
Let's have some function and
give it some list as a parameter.

00:15:41.050 --> 00:15:44.349
Inside the function we can just append.

00:15:44.349 --> 00:15:45.892
[BLANK_AUDIO]

00:15:45.892 --> 00:15:50.437
On to the list and then let's print

00:15:50.437 --> 00:15:54.997
out what a local variable that is.

00:15:54.997 --> 00:15:59.826
[BLANK_AUDIO]

00:15:59.826 --> 00:16:05.640
Now if we define some list over here and
then pass it into the function.

00:16:08.970 --> 00:16:11.050
A is our parameter here.

00:16:11.050 --> 00:16:13.450
It's given to some list.

00:16:14.700 --> 00:16:18.800
Then what happens when we
print out A after that?

00:16:19.910 --> 00:16:27.356
[BLANK_AUDIO]

00:16:27.356 --> 00:16:31.963
Notice that what happened
inside also happened outside.

00:16:31.963 --> 00:16:35.533
[BLANK_AUDIO]

00:16:35.533 --> 00:16:40.618
That same exact thing does
not happen if I were to,

00:16:40.618 --> 00:16:44.830
say, give this the value of five.

00:16:44.830 --> 00:16:48.900
And even though we're calling it
some list, I just add one to it.

00:16:48.900 --> 00:16:51.960
[BLANK_AUDIO]

00:16:51.960 --> 00:16:56.990
As previously demonstrated the Local
changes to 6, the Global does not.

00:16:56.990 --> 00:16:58.430
It's not altered.

00:16:58.430 --> 00:17:02.180
The immutable object is not
mutated inside the list.

00:17:03.870 --> 00:17:07.740
This instead the some_list the parameter

00:17:07.740 --> 00:17:12.301
becomes a Local variable even though
a was a Global variable a parameter

00:17:12.301 --> 00:17:16.900
some_list which is given the value
of a is now a local variable.

00:17:16.900 --> 00:17:18.589
It's destroyed at
the end of the function

00:17:19.690 --> 00:17:22.200
a itself is not altered because of that.

00:17:25.690 --> 00:17:28.440
So what do we want to do if
we want to actually get out

00:17:28.440 --> 00:17:31.310
some value from function for
something of a value.

00:17:31.310 --> 00:17:38.870
Well that's where return statements
come from or come in so let's just

00:17:38.870 --> 00:17:44.180
change this it doesn't say list because
that looks bad for readability purposes.

00:17:44.180 --> 00:17:48.030
So with some value some value here

00:17:50.110 --> 00:17:56.520
let's say I want to actually change the
value there and get something out of it.

00:17:56.520 --> 00:18:01.570
Let's return some lists return
does exactly what it looks like.

00:18:01.570 --> 00:18:03.200
It gives the variable back.

00:18:04.280 --> 00:18:09.398
So how I would do that is I would
assign some variable here, X,

00:18:09.398 --> 00:18:13.990
and then X takes

00:18:13.990 --> 00:18:19.630
whatever this variable was here,
and it just takes the value.

00:18:19.630 --> 00:18:21.090
So, quickly doing that.

00:18:21.090 --> 00:18:25.430
&gt;&gt; I think you need to change

00:18:25.430 --> 00:18:31.277
some_list to some_value.

00:18:31.277 --> 00:18:32.280
&gt;&gt; Yep.

00:18:32.280 --> 00:18:36.138
&gt;&gt; And one more on line 2.

00:18:36.138 --> 00:18:37.850
Yes.

00:18:37.850 --> 00:18:42.560
There you go.

00:18:42.560 --> 00:18:45.820
So I didn't actually do
anything with x here.

00:18:45.820 --> 00:18:47.930
Well I did yes I did I printed it out.

00:18:47.930 --> 00:18:52.210
So this is the value taken
from the returned value.

00:18:54.310 --> 00:18:58.010
So one cool thing here is you can
actually return multiple values here.

00:19:00.530 --> 00:19:03.730
So that's technically
returning a couple.

00:19:03.730 --> 00:19:06.650
As you can see if I do this again.

00:19:06.650 --> 00:19:08.180
It gives it a tuple value to X.

00:19:09.190 --> 00:19:13.650
But at the same time I could
do something like this, and

00:19:13.650 --> 00:19:15.800
it will actually understand
what I want to do there.

00:19:18.730 --> 00:19:20.720
X will just take the first value of Y,

00:19:20.720 --> 00:19:23.400
and Z are not equal to 1 and
2 because that's what I returned.

00:19:25.050 --> 00:19:30.200
So a return value also stops
the function wherever it's at so

00:19:30.200 --> 00:19:35.040
if I added that at the end of it.

00:19:35.040 --> 00:19:38.660
This will never be read because
it's afterwards a return statement

00:19:40.200 --> 00:19:42.840
Notice nothing changed
when I built that.

00:19:42.840 --> 00:19:45.750
The high right there
simply doesn't get read.

00:19:45.750 --> 00:19:48.670
It exists as part of
the function definition.

00:19:48.670 --> 00:19:54.360
But because it comes after a return in
the sequence that the programs run.

00:19:54.360 --> 00:19:57.950
So the program will run this line,
then this line, and then this line.

00:19:57.950 --> 00:19:59.730
This line will end the program.

00:19:59.730 --> 00:20:01.770
And it will never see the print high.

00:20:06.680 --> 00:20:13.270
So you can do multiple things
with the returned value.

00:20:13.270 --> 00:20:16.740
For instance,
you can print it out directly.

00:20:16.740 --> 00:20:20.080
So let's just take out
these print statements.

00:20:22.260 --> 00:20:25.423
[BLANK_AUDIO]

00:20:25.423 --> 00:20:30.223
So I could print what's returned
from some function here, and

00:20:30.223 --> 00:20:33.290
I'll get a couple that's returned.

00:20:33.290 --> 00:20:34.650
I'll get some value one too.

00:20:36.045 --> 00:20:39.525
So I don't even have to save
it in about a variable.

00:20:39.525 --> 00:20:43.735
I can also just run it and here nothing
would happen since that is printed

00:20:43.735 --> 00:20:48.572
out and assigned basically not assigned
what's returned to anything anything if

00:20:48.572 --> 00:20:53.662
that's if I'm looking for something that
the function did in here to say some

00:20:53.662 --> 00:20:58.312
mutable value that I wanted changed but
didn't actually care what was returned.

00:20:58.312 --> 00:21:00.812
I don't have to deal
with what's returned but

00:21:00.812 --> 00:21:03.719
it's generally useful to
deal with what's returned.

00:21:05.450 --> 00:21:11.100
That's actually a very important thing
sometimes as a beginner a lot of people

00:21:11.100 --> 00:21:14.360
might get a little confused with the
difference between print and returns.

00:21:15.460 --> 00:21:18.170
So print simply this console right here

00:21:19.340 --> 00:21:24.540
print simply says puts whatever value
you're printing on to that console it.

00:21:24.540 --> 00:21:28.530
It literally prints to what
you as a human can read

00:21:28.530 --> 00:21:30.480
it doesn't alter
the state of the program.

00:21:30.480 --> 00:21:33.990
It doesn't alter the flow of
how the program is running.

00:21:33.990 --> 00:21:37.550
All it does is show you something
that you want from program.

00:21:37.550 --> 00:21:40.930
Return on the other hand has
absolutely nothing to the console,

00:21:40.930 --> 00:21:45.500
it ends a function and
brings that value from that function to

00:21:45.500 --> 00:21:49.490
some external variable if you
assign it to an external variable.

00:21:51.640 --> 00:21:53.200
Which actually brings
me to another thing.

00:21:54.220 --> 00:21:56.890
Let's say I don't return anything.

00:21:56.890 --> 00:21:57.980
I return nothing.

00:21:57.980 --> 00:21:59.970
What do you think will happen here?

00:22:02.990 --> 00:22:03.830
First I have to print X.

00:22:06.920 --> 00:22:11.580
Notice that even without returning
anything what happens is that I

00:22:11.580 --> 00:22:12.800
end up returning none.

00:22:12.800 --> 00:22:14.440
I can even do that without
the return statement.

00:22:15.830 --> 00:22:20.790
So it still returns none
because in Python none is,

00:22:20.790 --> 00:22:23.660
it's what would be
considered a null value.

00:22:23.660 --> 00:22:27.910
Null in other programming
languages is often what's used

00:22:27.910 --> 00:22:29.840
in what Python is none.

00:22:29.840 --> 00:22:33.430
It's essentially a value
that has no value.

00:22:34.540 --> 00:22:37.500
It has the value it has is none.

00:22:37.500 --> 00:22:42.160
Its literally its own value type so
it's not a string it's

00:22:42.160 --> 00:22:46.050
just a value none the same is true and
false would be Boolean's.

00:22:46.050 --> 00:22:51.390
But all functions or
procedures in Python returns something

00:22:52.760 --> 00:22:56.070
by which I mean if you don't assign
a returned you returned none.

00:22:57.150 --> 00:22:59.730
So if you ever get none where
you weren't expecting it,

00:22:59.730 --> 00:23:01.800
when you're trying to print something.

00:23:01.800 --> 00:23:05.280
That's probably a sign that
you're possibly printing, or

00:23:05.280 --> 00:23:08.200
you meant to return, or
something like that where

00:23:08.200 --> 00:23:12.250
you're printing the value from
a function that doesn't return anything.

00:23:12.250 --> 00:23:15.460
Sometimes you explicitly
want to return none.

00:23:15.460 --> 00:23:18.370
That that tends to be the case when you

00:23:18.370 --> 00:23:21.790
are testing explicitly to see if
you get to a state in the program.

00:23:23.560 --> 00:23:27.630
It's a nice default holder, since it
doesn't really take up any space.

00:23:27.630 --> 00:23:31.860
As far as if you're going to
change some value into say a list.

00:23:31.860 --> 00:23:35.830
It's a nice default value which
we want to get into here but

00:23:35.830 --> 00:23:39.460
it has its uses but
that's that's sort of the main point.

00:23:42.730 --> 00:23:45.610
That's one of the reasons
actually that Python

00:23:45.610 --> 00:23:49.508
doesn't have a difference between
procedures and functions.

00:23:49.508 --> 00:23:54.633
So in math a function is
something which maps some unique

00:23:54.633 --> 00:24:00.641
input to some output for example F
of x = nx + b equation of a line.

00:24:00.641 --> 00:24:04.437
In programming languages the functions
tend to be something pretty similar.

00:24:04.437 --> 00:24:08.111
It takes input in the form
of parameters/arguments and

00:24:08.111 --> 00:24:11.530
it gives output from what it returns.

00:24:11.530 --> 00:24:15.240
But in some programming languages
functions don't actually affect

00:24:15.240 --> 00:24:15.940
anything other.

00:24:15.940 --> 00:24:19.480
Like outside of that,
if there are no mutatable values,

00:24:19.480 --> 00:24:23.740
then what happens in the function
stays in the function.

00:24:23.740 --> 00:24:26.750
It only has parameters and
input and output.

00:24:28.910 --> 00:24:32.850
On the other side of that in some other
programming languages procedures might

00:24:32.850 --> 00:24:39.030
just be sort of subroutines, things that
you run that don't return any values but

00:24:39.030 --> 00:24:41.830
which just do something to
other values in the program.

00:24:42.890 --> 00:24:46.710
By the way, a quick aside.

00:24:46.710 --> 00:24:51.900
When a function does do things other
than take input and give output,

00:24:51.900 --> 00:24:54.630
it actually alters some mutable values.

00:24:54.630 --> 00:24:59.000
We call that alteration
a side effect of the program.

00:24:59.000 --> 00:25:02.410
So sometimes a side effect of
the function, I should say.

00:25:02.410 --> 00:25:06.250
Sometimes you are literally, a side
effect of the function is the whole

00:25:06.250 --> 00:25:09.800
point, so
it's sort of a misnomer in that effect.

00:25:09.800 --> 00:25:14.870
But that it's a piece of terminology
you might find useful at some point.

00:25:16.690 --> 00:25:18.908
Another reason why Python procedures and

00:25:18.908 --> 00:25:23.091
functions aren't actually different is
that you'll notice that since every

00:25:23.091 --> 00:25:26.450
function returns something there
isn't like a true procedure

00:25:26.450 --> 00:25:30.275
that doesn't return anything because
you implicitly returned none.

00:25:30.275 --> 00:25:33.959
[BLANK_AUDIO]

00:25:33.959 --> 00:25:38.400
Did you have anything to add Mark?

00:25:38.400 --> 00:25:42.320
&gt;&gt; Other than the fact that
we've noticed a lot of people

00:25:42.320 --> 00:25:47.345
get confused between print
statements and return statements.

00:25:47.345 --> 00:25:51.165
And yeah it's really
like to likely emphasize

00:25:51.165 --> 00:25:54.425
print is really different from return,
they are two different things.

00:25:56.295 --> 00:26:00.475
The only common thing is they
get you some sort of value.

00:26:00.475 --> 00:26:04.220
Then you have to,
you manipulate this value because

00:26:05.290 --> 00:26:09.170
a lot of people will create a function
and then they'll print the function.

00:26:09.170 --> 00:26:10.810
They run and they print it and

00:26:10.810 --> 00:26:15.327
they're like okay that's the value that
I got from my function but in essence

00:26:15.327 --> 00:26:20.020
you're running a print statement and
then you're returning none.

00:26:20.020 --> 00:26:25.427
So it's a very subtle difference but
I think it's worth reemphasizing.

00:26:26.910 --> 00:26:28.280
&gt;&gt; Okay.

00:26:28.280 --> 00:26:31.960
&gt;&gt; And yeah, it looks like
we don't have any questions,

00:26:31.960 --> 00:26:35.560
it looks like our viewers ate,
they're getting it.

00:26:35.560 --> 00:26:37.134
We hope everyone is getting it.

00:26:37.134 --> 00:26:40.609
Can you show us an example of
multiple returns statements?

00:26:40.609 --> 00:26:42.060
What would that look like?

00:26:42.060 --> 00:26:47.079
&gt;&gt; Okay, so let's screen share again.

00:26:50.770 --> 00:26:55.078
So I'm assuming you're referring to and
if statements?

00:26:55.078 --> 00:26:59.060
&gt;&gt; Yeah if statements,
like that's a very common way to do it.

00:26:59.060 --> 00:27:03.402
&gt;&gt; Okay, so let's say.

00:27:03.402 --> 00:27:06.850
&gt;&gt; Can you increase size
of the text right there?

00:27:06.850 --> 00:27:07.418
&gt;&gt; Okay.

00:27:07.418 --> 00:27:08.637
&gt;&gt; Yeah.

00:27:08.637 --> 00:27:15.569
[CROSSTALK] The window is like
small Luke, like the window itself.

00:27:15.569 --> 00:27:17.298
Can you increase that window?

00:27:17.298 --> 00:27:19.145
There we go, yeah, yeah better.

00:27:19.145 --> 00:27:23.599
&gt;&gt; That's weird to me because
the window is actually bigger

00:27:23.599 --> 00:27:27.846
just now than it was for
most of the presentation.

00:27:27.846 --> 00:27:28.874
&gt;&gt; Okay.

00:27:28.874 --> 00:27:32.030
&gt;&gt; Who knows, weird quirks.

00:27:32.030 --> 00:27:36.947
So a lot of times you can have returned
different things depending on what

00:27:36.947 --> 00:27:38.085
you're doing.

00:27:38.085 --> 00:27:40.574
Let's, actually return the type,

00:27:40.574 --> 00:27:45.240
like let's return different things
based on the type of some value.

00:27:45.240 --> 00:27:48.870
So with Python we don't actually
have to specify what type our

00:27:48.870 --> 00:27:51.760
parameters are for a function.

00:27:51.760 --> 00:27:54.800
Which is a lot different than
a lot of other languages.

00:27:54.800 --> 00:27:56.310
Say, in C or C++ or Java,

00:27:56.310 --> 00:28:00.628
you're going to have to specify that
say if you want an integer here,

00:28:00.628 --> 00:28:04.250
you're going to actually have to specify
that you want an int in that spot.

00:28:04.250 --> 00:28:08.221
So the program doesn't crash, but

00:28:08.221 --> 00:28:13.360
here we can return different
things depending on whether or

00:28:13.360 --> 00:28:17.720
not we have an int.

00:28:17.720 --> 00:28:22.410
And then we can just maybe
return a value of that int

00:28:23.760 --> 00:28:27.180
verses if we have

00:28:29.940 --> 00:28:37.110
something that's not an int.

00:28:37.110 --> 00:28:40.110
We can just return
a straight string like that.

00:28:40.110 --> 00:28:45.450
And then we can run on this function
on a variety of different things.

00:28:45.450 --> 00:28:49.190
So let's say 25, that should get one.

00:28:49.190 --> 00:28:53.856
Actually let's print all these out so
that we can see what we have.

00:28:53.856 --> 00:28:58.572
And then let's print.

00:28:58.572 --> 00:29:00.534
Actually this should be fun.

00:29:00.534 --> 00:29:05.310
25.0 since that should be a float.

00:29:05.310 --> 00:29:06.638
We run this.

00:29:06.638 --> 00:29:09.180
We'll notice that the first
one is an int and so

00:29:09.180 --> 00:29:13.870
returns one, the second one is not an
int, so it returns a string, not an int.

00:29:15.600 --> 00:29:19.720
We have different return statements here
because well we have an if statement

00:29:19.720 --> 00:29:24.248
that goes from one place to another
depending on what some_value is.

00:29:24.248 --> 00:29:30.070
Actually one big trip-up
that is found quite

00:29:30.070 --> 00:29:35.490
a few times here would be something
like a while statement or a for loop.

00:29:35.490 --> 00:29:40.630
So let's say I

00:29:40.630 --> 00:29:45.050
want to just print that if statement or
some value ten times.

00:29:47.330 --> 00:29:49.624
So let's make a counter.

00:29:49.624 --> 00:29:55.224
I'll just do that for loop for

00:29:55.224 --> 00:29:59.261
e in range (10).

00:29:59.261 --> 00:30:04.525
If you do this, you're going to end up

00:30:04.525 --> 00:30:09.955
only doing it once because the function

00:30:09.955 --> 00:30:14.410
will end as soon as you get here.

00:30:16.060 --> 00:30:19.516
So, it's only going to run once,

00:30:19.516 --> 00:30:24.762
whereas if you had wanted to
print it out more times or

00:30:24.762 --> 00:30:29.068
wanted to make some
list actually have it.

00:30:29.068 --> 00:30:38.305
[BLANK_AUDIO]

00:30:38.305 --> 00:30:42.290
You have to move the return
to outside of the for loop.

00:30:42.290 --> 00:30:44.830
Inside the for loop,
anytime you hit that return,

00:30:44.830 --> 00:30:48.650
it's going to end the function
even in the middle of a loop.

00:30:48.650 --> 00:30:50.990
So that's one big thing to
remember about return statements.

00:30:54.060 --> 00:30:57.240
A return statement ends
the function immediately.

00:30:57.240 --> 00:31:01.060
Regardless of whether it's in
something that shouldn't necessarily.

00:31:01.060 --> 00:31:05.474
You wouldn't think of ending without
ending that with something like

00:31:05.474 --> 00:31:06.300
a for loop.

00:31:06.300 --> 00:31:08.430
A return statement always
ends the function.

00:31:09.910 --> 00:31:14.243
There's actually some fun things you
can to with return statements that

00:31:14.243 --> 00:31:18.740
you won't really encounter so
much in this class,

00:31:18.740 --> 00:31:22.590
although CS 101 has quite a bit
of it which is recursion.

00:31:23.680 --> 00:31:26.880
So you technically don't need loops,

00:31:26.880 --> 00:31:29.950
although Python's not particularly
well set up for recursion.

00:31:29.950 --> 00:31:33.370
Because you could use
a function to call itself.

00:31:34.570 --> 00:31:37.420
So instead of returning some value,

00:31:37.420 --> 00:31:40.050
we could actually return
some function here.

00:31:41.060 --> 00:31:45.569
Which you'll notice is going to be an
infinite loop because it's just going to

00:31:45.569 --> 00:31:48.455
keep calling itself over and
over and over again.

00:31:48.455 --> 00:31:55.504
But if we say, made an if statement
that, I just typed an if statement.

00:31:55.504 --> 00:31:59.389
If we make an if statement that
has some base value that So

00:31:59.389 --> 00:32:03.108
you can think of a recursion
sort of like in the same way

00:32:03.108 --> 00:32:06.710
as a loop it has to have
stopping condition.

00:32:06.710 --> 00:32:08.760
We'll call this a base case and

00:32:08.760 --> 00:32:12.180
that stopping condition is
what sort of ends the loop.

00:32:12.180 --> 00:32:16.550
And then there the recursion
will sort of and

00:32:16.550 --> 00:32:21.370
then keep each value will be finally
returned to the function that called it

00:32:21.370 --> 00:32:24.080
and then at last you
are function will end.

00:32:24.080 --> 00:32:27.730
One of the reasons Python's actually
not particularly well suited for it

00:32:27.730 --> 00:32:32.390
is that it was actually kind of welding
on the scope of this class but it.

00:32:34.350 --> 00:32:37.600
Each function has a certain amount of
overhead and you just straight up run

00:32:37.600 --> 00:32:43.260
out of memory for how many
functions are simultaneously called

00:32:43.260 --> 00:32:47.090
instead of one function ending and
then calling the next one.

00:32:47.090 --> 00:32:49.770
So a while loop doesn't
really take up much memory.

00:32:49.770 --> 00:32:52.140
It just keeps on going over and over.

00:32:52.140 --> 00:32:58.250
Whereas recursion takes up a lot of
memory in something like Python.

00:32:58.250 --> 00:33:00.610
Should I demonstrate
an actual recursive case?

00:33:02.180 --> 00:33:03.483
&gt;&gt; Yeah, just something very simple.

00:33:03.483 --> 00:33:04.749
&gt;&gt; Okay.

00:33:04.749 --> 00:33:07.015
&gt;&gt; Would suffice.

00:33:07.015 --> 00:33:11.489
&gt;&gt; Okay, so let's say.

00:33:11.489 --> 00:33:20.769
[BLANK_AUDIO]

00:33:20.769 --> 00:33:25.253
Let's make a counter here.

00:33:25.253 --> 00:33:28.069
Take this out.

00:33:28.069 --> 00:33:33.830
So if count = 0, we're going

00:33:33.830 --> 00:33:38.925
to have that be our base case

00:33:38.925 --> 00:33:44.473
just return some value else.

00:33:44.473 --> 00:33:51.653
[BLANK_AUDIO]

00:33:51.653 --> 00:33:53.733
Return.

00:33:53.733 --> 00:33:55.393
[BLANK_AUDIO]

00:33:55.393 --> 00:33:59.933
Some function.

00:33:59.933 --> 00:34:04.595
Some value plus one plus one.

00:34:04.595 --> 00:34:08.804
So this is kind of a pointless
function but we can call it anyway.

00:34:08.804 --> 00:34:12.335
&gt;&gt; [CROSSTALK] Minus one, right?

00:34:12.335 --> 00:34:13.310
Yeah.
&gt;&gt; Yes.

00:34:13.310 --> 00:34:15.150
Well, unless I start with
a negative number that would,

00:34:16.380 --> 00:34:19.969
recursion has the same fun with loops
is, only it takes a little bit getting

00:34:19.969 --> 00:34:23.620
used to in your head about if
I started out with a count.

00:34:25.340 --> 00:34:26.400
Bigger than zero.

00:34:26.400 --> 00:34:28.730
If I had plus one here
it would never end.

00:34:28.730 --> 00:34:32.449
It would just get basically
an infinite loop but

00:34:32.449 --> 00:34:35.150
an infinite loop that ends more
quickly than normal because

00:34:35.150 --> 00:34:38.110
Python will tell me that hey
I'm completely out of memory.

00:34:38.110 --> 00:34:45.199
But then I can do that and see what
I get out for my final value here.

00:34:46.991 --> 00:34:52.018
It looks like and I needed that.

00:34:52.018 --> 00:34:53.260
Yay.

00:34:53.260 --> 00:34:56.797
So it returns every value between 25 and

00:34:56.797 --> 00:35:01.400
35 because I print some
value every time and

00:35:01.400 --> 00:35:05.560
then ten is how many times
I'm going to call itself.

00:35:06.730 --> 00:35:09.540
And then it simply adds
one to count every third,

00:35:09.540 --> 00:35:11.150
subtracts one to count
until we get to zero.

00:35:11.150 --> 00:35:14.190
When we get to zero,
it actually prints some value.

00:35:14.190 --> 00:35:17.530
To show you how the difference between
this and a normal infinite loop.

00:35:17.530 --> 00:35:22.660
If I were to actually give this,
let's just give it a negative number so

00:35:22.660 --> 00:35:25.530
it destroys itself nice and quick.

00:35:27.560 --> 00:35:33.980
Notice that it actually hit the maximum
recursion depth pretty quickly.

00:35:33.980 --> 00:35:37.080
You could be sitting in an infinite
loop wondering if your program's just

00:35:37.080 --> 00:35:42.270
slow for minutes if you have
a particularly involved

00:35:42.270 --> 00:35:45.270
program that has to go through
a fantastically large argument of data.

00:35:45.270 --> 00:35:47.700
But with recursion,
if you go too deeply,

00:35:47.700 --> 00:35:53.820
the program will basically cut itself
off right there in only half a second.

00:35:53.820 --> 00:35:56.760
The main problem with that is that
if you actually have a lot of stuff

00:35:56.760 --> 00:36:00.930
you have to go through the program
cuts itself off in half a second and

00:36:00.930 --> 00:36:03.220
you'll never get through all of it.

00:36:03.220 --> 00:36:07.378
It will just make an error even though
theoretically that shouldn't have to be

00:36:07.378 --> 00:36:09.903
one if you had a computer
with infinite memory.

00:36:09.903 --> 00:36:12.423
[BLANK_AUDIO]

00:36:12.423 --> 00:36:18.080
But that's just a quick aside there
it's a pretty recursion something and

00:36:18.080 --> 00:36:24.180
using algorithms quite a bit for
at least like saying graph theory.

00:36:24.180 --> 00:36:26.000
It's pretty useful.

00:36:26.000 --> 00:36:29.790
It's easier to think of in
certain cases obviously loops

00:36:31.160 --> 00:36:34.430
actually tend to be faster
in almost all languages.

00:36:36.390 --> 00:36:39.160
So sometimes where you use recursion and

00:36:39.160 --> 00:36:42.550
anything that's possible with
recursion is also possible with loops.

00:36:43.550 --> 00:36:46.461
But sometimes it's easier
to set up recursion and

00:36:46.461 --> 00:36:50.754
then it is to set up a loop and so It's
useful to do something with recursion

00:36:50.754 --> 00:36:52.991
because it's simply much easier to.

00:36:52.991 --> 00:37:03.836
[BLANK_AUDIO]

00:37:03.836 --> 00:37:07.745
Shall we do another recursive thing
that maybe has a point or should I?

00:37:07.745 --> 00:37:10.360
&gt;&gt; I think I think we're good Luke,
yeah.

00:37:10.360 --> 00:37:13.110
We don't want to overload our students.

00:37:13.110 --> 00:37:15.850
But I think that was a good, let me

00:37:17.960 --> 00:37:22.720
switch to my broadcast
over here at the office.

00:37:22.720 --> 00:37:25.540
Recursion is just another
way to use functions,

00:37:25.540 --> 00:37:30.510
and once you get the hang up like
of knowing how to return things,

00:37:30.510 --> 00:37:38.030
know how to process parameters arguments
and know how to process them and then

00:37:38.030 --> 00:37:42.710
basically take these functions and use
something you're day to day programming.

00:37:42.710 --> 00:37:46.760
Recursion will will start
to get making them a little

00:37:46.760 --> 00:37:51.370
more sense especially if
it involved programs or

00:37:51.370 --> 00:37:56.560
problems that involve algorithms or
any arrest type of mathematical or

00:37:56.560 --> 00:38:02.970
calculation where you're not sure about
the length of like total calculations

00:38:02.970 --> 00:38:07.550
like let's assume that I will not be
able to calculate ten things right.

00:38:07.550 --> 00:38:12.740
I could just simply use a loop but
if I want to be able to calculate

00:38:12.740 --> 00:38:17.710
It may be 10 things, it may be
15 things, it may be 120 things.

00:38:17.710 --> 00:38:20.850
I don't know until I
actually execute it.

00:38:20.850 --> 00:38:23.670
That's when recursion is
actually really, really useful.

00:38:23.670 --> 00:38:27.170
But yeah, thanks Luke for showing us,
giving us a little sneak peek.

00:38:27.170 --> 00:38:31.780
So again, in summary about functions.

00:38:31.780 --> 00:38:33.410
Functions are again, very important.

00:38:33.410 --> 00:38:36.350
These are the building
blocks of programming.

00:38:36.350 --> 00:38:41.290
They're very, very basic ways to
increase your efficiency as a coder and

00:38:41.290 --> 00:38:42.870
also to increase your power.

00:38:42.870 --> 00:38:47.800
But again, these are the base
things that you need to know in

00:38:47.800 --> 00:38:52.600
programming in order for you to be able
to do like any other fancy stuff that

00:38:52.600 --> 00:38:57.190
you you may have seen that other
people have have done in programming.

00:38:58.300 --> 00:39:02.930
You know, functions are made of,
you know, inputs and outputs.

00:39:02.930 --> 00:39:07.270
So basically a function,
is a way to map an input to an output.

00:39:07.270 --> 00:39:12.170
You take some sort of input,
we call that a parameter or an argument.

00:39:12.170 --> 00:39:16.070
We do something to it and
we transform it in some way.

00:39:16.070 --> 00:39:20.620
And then we give it an output,
we actually return it.

00:39:20.620 --> 00:39:28.306
Or and or change the argument if it's
mutable variable such as a list.

00:39:28.306 --> 00:39:33.550
We actually process it and
that's why procedures and

00:39:33.550 --> 00:39:39.410
functions are used interchangeably
because again it's you're

00:39:39.410 --> 00:39:44.450
changing something, and
you're either returning the variable or

00:39:44.450 --> 00:39:48.050
you change the variable and
then you're just returning none.

00:39:48.050 --> 00:39:48.910
&gt;&gt; What else?

00:39:48.910 --> 00:39:52.250
800 things to,

00:39:52.250 --> 00:39:57.893
there are still walk away with.

00:39:57.893 --> 00:40:01.453
&gt;&gt; So functions again,
they're very, very foundational.

00:40:01.453 --> 00:40:04.379
Make sure you have a good
grasp on functions.

00:40:04.379 --> 00:40:07.223
It's always good to try
some stuff out yourself.

00:40:07.223 --> 00:40:10.006
So, maybe try out some
stuff with local and

00:40:10.006 --> 00:40:14.571
global scope thinking about what
those mutable valuable variables,

00:40:14.571 --> 00:40:20.260
how they'll actually change depending
on what you do inside your function.

00:40:20.260 --> 00:40:22.720
For instance the difference
between defining a new

00:40:24.220 --> 00:40:25.800
mutable variable inside your function,

00:40:25.800 --> 00:40:29.760
which would be local scope versus
changing that mutable variable that you

00:40:29.760 --> 00:40:34.610
had from a global scope which
will be from the global scope.

00:40:34.610 --> 00:40:37.378
It's good to play around
with this stuff, so

00:40:37.378 --> 00:40:41.720
that's I suppose was my only
real recommendation there.

00:40:43.140 --> 00:40:46.450
&gt;&gt; Awesome, well thanks Luke for
that awesome presentation yeah.

00:40:46.450 --> 00:40:52.090
So hopefully you walk away watching
this broadcast and you're fired up, you

00:40:52.090 --> 00:40:56.970
could just try it yourself, just create
functions and just practice with it.

00:40:56.970 --> 00:41:02.110
Again, practice makes It's
very true in programming.

00:41:03.480 --> 00:41:05.820
The world's your playground.

00:41:05.820 --> 00:41:07.640
You just fire up your
Python interpreter and

00:41:07.640 --> 00:41:10.970
just play around with
exactly what Luke did.

00:41:10.970 --> 00:41:15.180
And hopefully you'll start to get a good

00:41:15.180 --> 00:41:20.060
intuitive sense of what these
functions are in Python.

00:41:20.060 --> 00:41:20.720
Great.

00:41:20.720 --> 00:41:27.230
So we hope everyone got something
away from these functions.

00:41:27.230 --> 00:41:33.130
I think next week, look at what,
what are we talking about next week.

00:41:33.130 --> 00:41:34.160
Let's see.

00:41:42.050 --> 00:41:42.820
Loading here.

00:41:42.820 --> 00:41:44.606
So what's next week.

00:41:44.606 --> 00:41:54.606
[BLANK_AUDIO]

00:41:59.274 --> 00:42:05.230
19th would be next week,
I think it looks like it's style.

00:42:05.230 --> 00:42:11.160
The importance of founding coding style
site, and then it was slower here.

00:42:11.160 --> 00:42:17.583
So yeah, basically coding style for
HTML, CSS, and Python style.

00:42:17.583 --> 00:42:24.200
So this is another very important
thing concept to learn is how do you

00:42:24.200 --> 00:42:28.510
program in a good style that
makes your code readable and

00:42:28.510 --> 00:42:31.540
sharable and
also makes it more organized?

00:42:31.540 --> 00:42:36.040
Because I really think if how you
style and how you organize your code

00:42:38.700 --> 00:42:45.820
tells a lot of about how
efficient your program can run.

00:42:45.820 --> 00:42:52.600
That's what I'm a big big proponent of
making sure that your style, your your

00:42:52.600 --> 00:42:56.690
variables define right, your organizing
your code cleanly and clearly.

00:42:56.690 --> 00:43:00.850
It shows that you you have good
sense of what you're doing and

00:43:00.850 --> 00:43:01.530
where you're going.

00:43:03.170 --> 00:43:05.630
Awesome, well hopefully
we'll see you next week.

00:43:05.630 --> 00:43:07.405
All right and thank everyone.

00:43:07.405 --> 00:43:07.905
Bye.

