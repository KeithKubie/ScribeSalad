WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:06.980
&gt;&gt; NORTH: Now we're going to spend about half
an hour talking about the details of the Wave

00:00:06.980 --> 00:00:11.509
data model and how that sort of--the various
layers of the obstruction that we have. This

00:00:11.509 --> 00:00:16.200
will help you understand how Wave works, the
system. And also if you dive into the code,

00:00:16.200 --> 00:00:22.730
what are some of the various things they're
doing in there. I think that the changing

00:00:22.730 --> 00:00:27.269
time zone is catching up with me so I'm sorry
if my voice is starting go. But I'll stay

00:00:27.269 --> 00:00:32.390
in the microphone. Can everyone still hear
me okay at the back of the room at the moment?

00:00:32.390 --> 00:00:48.284
Yeah, nods, all right. What's up? All right,
I think it was the feedback. All right, so

00:00:48.284 --> 00:00:50.649
I'm going to do it in a kind of bottom up
way. I'm going to start at the bottom with

00:00:50.649 --> 00:00:56.320
the sort of the most basic components and
build up the out-layers of obstruction so

00:00:56.320 --> 00:01:00.100
you can see where we're going. So to start
with the--you won't see anything to do with--well,

00:01:00.100 --> 00:01:05.730
the word, "blip" won't appear for quite a
while and it's a good thing. Okay, so wave

00:01:05.730 --> 00:01:13.400
documents you probably at least roughly familiar
with. So wave document is a structured rich

00:01:13.400 --> 00:01:20.940
text document. We use an XML-like tree structure
for the content of the document. If you look

00:01:20.940 --> 00:01:26.030
at a document in sort of one of our debug
output or something it looks very much like

00:01:26.030 --> 00:01:31.110
XML, it's probably a subset of XML. You could
pass it with an XML passer. It's not strictly

00:01:31.110 --> 00:01:36.910
XML and that we don't--it doesn't conform
to various XML standards. And there's lots

00:01:36.910 --> 00:01:41.970
of stuff you can put in XML that you can't
put in wave documents. And the reason--it

00:01:41.970 --> 00:01:47.870
looks like XML because it's very convenient,
it maps an IC to a browser DOM for rendering.

00:01:47.870 --> 00:01:53.710
But lots of the way data is represented in
Wave is very much governed by its need to

00:01:53.710 --> 00:01:58.720
behave well under operational transform and
so arbitrary XML doesn't behave well under

00:01:58.720 --> 00:02:03.750
operational transform it's difficult to get
concurrent behavior to resolve nicely. And

00:02:03.750 --> 00:02:07.840
so we arrived at the structure that I'll talking
about after sort of number of iterations of

00:02:07.840 --> 00:02:17.390
different models to arrive at one that sort
of preserves intense naturally under operational

00:02:17.390 --> 00:02:25.440
transform. So, we use an XML tree-like structure
for the structural content. And then we have

00:02:25.440 --> 00:02:30.620
stand-off annotations for styling information
and metadata about the document. And so these

00:02:30.620 --> 00:02:34.381
are not something that you find in XML and
they don't--they're not part of the structure

00:02:34.381 --> 00:02:40.890
of the document. So we'll talk about each
of these in a bit of detail. The document

00:02:40.890 --> 00:02:46.041
structure here this is what a document that's
representing a blip, a message, looks like

00:02:46.041 --> 00:02:53.550
inside Wave. So you can see it's tree-structured
with a body as kind of a top level tag. We

00:02:53.550 --> 00:02:57.090
have line tags and gadget tags and there's
a few other tags that you can find inside

00:02:57.090 --> 00:03:04.910
a blip document. We have schemas that define
what can go in here but the schema is one

00:03:04.910 --> 00:03:10.569
item of Wave's data model that needs a lot
of work. The schemas are not currently enforced

00:03:10.569 --> 00:03:15.340
in Wave in a Box and they're currently represented
in Java code rather than any kind of declarity

00:03:15.340 --> 00:03:20.191
of the--in declarative way. And so schema
is something we have some time for discussion

00:03:20.191 --> 00:03:24.210
later on in the week about what we should
be doing with schemas, and you know, how we

00:03:24.210 --> 00:03:30.090
can do it better. All right, so this is an
example of a wave document. It looks like

00:03:30.090 --> 00:03:33.800
XML but it's not exactly like XML. If anyone
spot anything that's a bit weird about this

00:03:33.800 --> 00:03:40.730
document that you wouldn't do naively?
&gt;&gt; [INDISTINCT]

00:03:40.730 --> 00:03:44.260
&gt;&gt; NORTH: Yeah, so they're only...
&gt;&gt; [INDISTINCT]

00:03:44.260 --> 00:03:48.310
&gt;&gt; NORTH: You're right, on the second and
third lines, the content, the words, "wave

00:03:48.310 --> 00:03:54.060
summit," and who's coming to the summit are
not nested inside the line elements; it's

00:03:54.060 --> 00:03:59.670
after end of the line element. And that's
an arrangement we arrived at--after a bit

00:03:59.670 --> 00:04:07.130
of experimentation and lot's of code and the
reason we do that is for operational transform.

00:04:07.130 --> 00:04:13.900
So it turns out to be very, very difficult
to build operation components and the right-correct

00:04:13.900 --> 00:04:18.591
intention-preserving transformation code if
you put the content inside the line element.

00:04:18.591 --> 00:04:24.600
If two people concurrently on different computers,
you know, on the other side of the world both

00:04:24.600 --> 00:04:28.590
carriage-return inside this nested element
you need to sort of--sorry, you're probably

00:04:28.590 --> 00:04:34.630
familiar with HTML. If you hit carriage return
inside the--inside a PL in an HTML, what you

00:04:34.630 --> 00:04:40.190
want is basically the insert, a slash P and
then a P. It's the point where you hit carriage

00:04:40.190 --> 00:04:44.770
return so you then have two paragraphs. If
two people do that concurrently inside the

00:04:44.770 --> 00:04:49.410
same paragraph that's not too hard to resolve.
If someone presses backspace over, one of

00:04:49.410 --> 00:04:53.521
those sort of breaks, you want the paragraphs
to merge, it becomes a trickier to resolve

00:04:53.521 --> 00:05:00.080
with someone also is splitting it at the same
point or a different point. And we also want

00:05:00.080 --> 00:05:04.520
to be able to undo these operations, have
inverts--inversion of all these operations

00:05:04.520 --> 00:05:12.220
so you can undo your changes when you are
doing things. And so the operational transform

00:05:12.220 --> 00:05:16.360
code to handle this kind of thing blew out
and we never correctly implemented it despite

00:05:16.360 --> 00:05:20.680
a lot of trying. Until eventually we decided,
"Oh, if we just put the text outside of the

00:05:20.680 --> 00:05:24.990
line elements the problem goes away." Now,
with two people on this line here want to

00:05:24.990 --> 00:05:28.800
break the line at two different points you
just--in here and here, concurrently they

00:05:28.800 --> 00:05:35.460
can insert the line/line pair and a line/line
pair here, and that's just a really easy transformation

00:05:35.460 --> 00:05:40.830
that's just two insertions. And there's no
sort of--and if someone else's is backspacing

00:05:40.830 --> 00:05:46.581
over them it all just resolves nicely. And
so we can write it correctly. We can do lots

00:05:46.581 --> 00:05:52.199
of testing to sort of almost prove. We should
be able to theoretically prove it but we don't

00:05:52.199 --> 00:05:59.630
have a mathematical proof at all if the transform
is correct. So that that's one example of

00:05:59.630 --> 00:06:02.650
solving an unnatural--it doesn't look like
the way you would naÃ¯vely represent it in

00:06:02.650 --> 00:06:12.860
an XML but it behaves much, much better under
operational transform. Sorry. And again, please

00:06:12.860 --> 00:06:15.400
stick your hand up if you have any questions
throughout this talk. Yeah?

00:06:15.400 --> 00:06:23.170
&gt;&gt; Do you guys--you mentioned [INDISTINCT].
&gt;&gt; NORTH: We thought about it and there's

00:06:23.170 --> 00:06:28.330
a few different ways you can think about embedding
tables in Wave. It is work that we sort of

00:06:28.330 --> 00:06:32.729
had underway. I think, actually, Dan might
have dumped a bunch of the code that would

00:06:32.729 --> 00:06:37.600
halfway to do it. He said he was about to.
We've got a bit of a way towards implementing

00:06:37.600 --> 00:06:39.449
it.
&gt;&gt; [INDISTINCT]

00:06:39.449 --> 00:06:45.540
&gt;&gt; NORTH: I think there probably isn't. But
I think we were trying to dig it out. It wasn't

00:06:45.540 --> 00:06:48.479
fully functional what we've started putting
some of the building box in place. Sorry,

00:06:48.479 --> 00:06:54.479
the question for the rest of the Internet
was whether there's any support for tables.

00:06:54.479 --> 00:06:58.020
And that's another good example of the data
model. It doesn't just map directly into Wave.

00:06:58.020 --> 00:07:02.110
If you just put an HTML table inside Wave,
the transform of people adding rows and columns

00:07:02.110 --> 00:07:10.919
to the table is horrible. But we do have a
sort of more indirect mechanism of doing it

00:07:10.919 --> 00:07:21.110
and we will work in towards that. Yeah?
&gt;&gt; Along the same lines of [INDISTINCT].

00:07:21.110 --> 00:07:26.000
&gt;&gt; NORTH: Question was that, "Is there any
way to split a video or images?" So we have

00:07:26.000 --> 00:07:32.310
a basic embedding of images. So there's an
image thumbnail. It was an image tag which

00:07:32.310 --> 00:07:38.820
works of it like image tag in HTML it refers
to, or refers to an attachment ID or URL,

00:07:38.820 --> 00:07:43.650
do these both. There's one that refers to
a URL frame, it's like an HTML tag. And there's

00:07:43.650 --> 00:07:48.949
one that refers--excuse me, to an image that's
attached to a wave as an attachment. If you

00:07:48.949 --> 00:07:53.300
saw the Wave demo you can sort of drop photos
in a wave and that sort of attached to it

00:07:53.300 --> 00:07:59.610
like email attachments are. And you can refer
to them from an element inside the wave as

00:07:59.610 --> 00:08:06.889
well. Video, again, not naively but by embedding
a--oh, I can't remember what the tag name

00:08:06.889 --> 00:08:11.100
is--gadget, I guess. You can embed a YouTube
video inside a wave by just embedding a YouTube

00:08:11.100 --> 00:08:15.580
gadget inside the wave. That doesn't actually
put the video content inside the wave but

00:08:15.580 --> 00:08:25.491
it refers to it in the same way that you embedded
it in an HTML page. Okay, so what you don't

00:08:25.491 --> 00:08:34.259
find in the XML-style content is a style in
mockups, a style kind of mockup. And so if

00:08:34.259 --> 00:08:40.019
we--Wave can support colors and fonts and
headings and all that kind of stuff. But we

00:08:40.019 --> 00:08:48.050
don't do it like a naÃ¯ve HTML would do it.
The problem, of course--again, it doesn't

00:08:48.050 --> 00:08:52.329
play well with operational transform. If you
have nested pairs of tags, if you want to

00:08:52.329 --> 00:08:56.649
mess the bold inside a font tag and someone
hits carriage return in the middle you've

00:08:56.649 --> 00:09:02.449
now got a doubly hard a problem just split
them out and resolve concurrently. And, of

00:09:02.449 --> 00:09:08.290
course, it's just ugly when you have to munge
the structure of your document to represent

00:09:08.290 --> 00:09:14.649
the fact that various style regions overlap,
which is of course how you end up doing it

00:09:14.649 --> 00:09:19.519
in your naÃ¯ve HTML before CSS. So, instead,
we use stand-off annotations. And an annotation

00:09:19.519 --> 00:09:25.880
sort of paints a region of the document with
a key value pair. And so, down at the bottom

00:09:25.880 --> 00:09:29.490
here, I've tried to represent what it looks
like. So, not represented inside the content

00:09:29.490 --> 00:09:34.279
of--inside the tree content of the document
but in a separate data structure held next

00:09:34.279 --> 00:09:41.249
to it is a set of key value pairs and a region
of the document that they spend, a non-empty

00:09:41.249 --> 00:09:46.480
region of the document. And so you--and annotations
can overlap perfectly fine. You can have as

00:09:46.480 --> 00:09:56.970
many annotations as many as you like, and
the operational transform is very easy to

00:09:56.970 --> 00:10:00.829
get to work for most cases. There's an edge
case that's--is a bit difficult that we ran

00:10:00.829 --> 00:10:09.139
and recently fixed. Right, so they can overlap.
So, font styles, colors, head--not heading

00:10:09.139 --> 00:10:15.889
types. Heading types are represented as attributes
on an element. And things like the spelling

00:10:15.889 --> 00:10:19.370
when the origin is misspelled, the spelling
agent goes and annotates that region with

00:10:19.370 --> 00:10:24.420
the--and in cache, if those has been misspelled
and appoint it to some corrections. Question?

00:10:24.420 --> 00:10:32.149
&gt;&gt; Won't the annotation of those [INDISTINCT]?
&gt;&gt; NORTH: Oh, there's a dodgy case when you're

00:10:32.149 --> 00:10:40.269
deleting at the end of an annotated region
when someone else is deleting or inserting.

00:10:40.269 --> 00:10:45.041
It was quite contrived and took a long time
for us to discover it through lots and lots

00:10:45.041 --> 00:10:52.019
of randomized testing. I personally bug about
it recently on our bug track I probably didn't

00:10:52.019 --> 00:10:58.009
give you quite enough information. Suffice
to say it was a case deepened and transformed

00:10:58.009 --> 00:11:08.239
something to do with deleting annotative regions.
Okay, so structure and annotations separately

00:11:08.239 --> 00:11:12.069
doing--each doing what it's good at doing
and then each transforms fairly natural. Okay,

00:11:12.069 --> 00:11:18.550
I think I went over this. So, they paint a
structural content here. A good way of thinking

00:11:18.550 --> 00:11:23.069
about it is a key value but it's painting
some region. So if you delete, delete the

00:11:23.069 --> 00:11:28.319
painted region, the annotation is gone there's
nothing for it to paint. If you insert a content

00:11:28.319 --> 00:11:32.559
in the middle of an annotated region it is
also annotated it just naturally keeps its

00:11:32.559 --> 00:11:42.410
annotation. If you--and it behaves extremely
well concurrently. If you--if there's a paragraph

00:11:42.410 --> 00:11:46.970
and someone is typing in the middle of it
and you select the whole paragraph and hit,

00:11:46.970 --> 00:11:50.670
"bold," then not only does the paragraph turn
bold but all the characters that they typed

00:11:50.670 --> 00:11:54.269
even if they're on the wire somewhere, they've
already type them, they still end up bold

00:11:54.269 --> 00:12:01.569
in the document as it comes out. Thanks to
the transform. They also--we have an inheriting

00:12:01.569 --> 00:12:07.559
scheme for annotations. So if there's a region
of text that has some annotation and you insert

00:12:07.559 --> 00:12:13.089
another character at the very end of that
region it inherits the annotation of the item

00:12:13.089 --> 00:12:19.790
to what's left of the annotations. So, again,
if you're--again, this is a bit of a tradeoff,

00:12:19.790 --> 00:12:23.379
but the good side of the tradeoff is if you're
typing it at the end of a paragraph that's

00:12:23.379 --> 00:12:26.970
styled with some font you don't have to keep
sending the same annotations with each character.

00:12:26.970 --> 00:12:30.749
You just send the characters that you're sending
and they naturally inherit the annotation

00:12:30.749 --> 00:12:44.769
values from the character to their left. Questions?
Okay. You should--it's certainly on Google

00:12:44.769 --> 00:12:48.489
Wave. You can get a look at the--oh, sorry,
on a Wave sandbox, you can get a look at the

00:12:48.489 --> 00:12:53.699
annotations and the structure of a document
by looking at the edited debug menu. I think

00:12:53.699 --> 00:12:58.740
it's only visible on Wave sandbox. But that
shows you some of the content of what your

00:12:58.740 --> 00:13:05.619
blip documents look like. So just briefly
then on operations, much of this is being

00:13:05.619 --> 00:13:10.049
covered in other talks at the various Google
I/Os and so on so I'm not going to go too

00:13:10.049 --> 00:13:16.569
deeply into the operations and the transform.
But in brief, an operation is a function of

00:13:16.569 --> 00:13:22.220
document state that transforms a document
from one state to the next. An operation instructed

00:13:22.220 --> 00:13:27.079
is as a sequence of components so the operation
streams are over the document and applies

00:13:27.079 --> 00:13:32.069
mutations to the document as it streams over
it. So, the basic mutation is retained which

00:13:32.069 --> 00:13:37.139
is to not mutate so you can sort of retain
a bunch of characters that are already in

00:13:37.139 --> 00:13:42.549
the document as they are. Then you can insert
and delete characters, insert and delete elements,

00:13:42.549 --> 00:13:48.480
the--what you know as external tags, start/end.
Then, of course, by the end of the--by--a

00:13:48.480 --> 00:13:53.949
whole operation has to preserve the nesting
of the well form and nest of the structure.

00:13:53.949 --> 00:14:01.220
Update and replace attributes on elements
or an element like a line element can have

00:14:01.220 --> 00:14:05.480
an attribute on it. So, for example, headings
are represented by an attribute that's placed

00:14:05.480 --> 00:14:11.049
on the line element and that marks that whole
line as a heading. Much the same way as you

00:14:11.049 --> 00:14:15.880
might have, yeah, heading tag in a--well,
it probably won't have a dedicated tag, it's

00:14:15.880 --> 00:14:21.619
just a type of line. And then annotation boundaries.
So annotation boundary is just saying you're

00:14:21.619 --> 00:14:25.499
at this point this key becomes this value.
And then at some point there needs to be another

00:14:25.499 --> 00:14:28.410
annotation boundary that says, "All right,
this annotation has ended," and that defines

00:14:28.410 --> 00:14:35.819
a painted region. So graphically then, down
at the bottom here there's these two operations.

00:14:35.819 --> 00:14:42.629
The way to interpret this graphic is that
each horizontal line is a document state.

00:14:42.629 --> 00:14:47.519
So the document starts out in this--in this--in
this state represented by this line and the

00:14:47.519 --> 00:14:52.319
operation is the space between the horizontal
lines. And so a white box here is just a retain

00:14:52.319 --> 00:14:57.089
component that says, "Just keep this part
of the document as is." Then a red component

00:14:57.089 --> 00:15:04.350
is a--some deletion or deletion of either
characters or elements. And so you can see

00:15:04.350 --> 00:15:08.570
this region collapses out of the document
when this operation is applied. Then over

00:15:08.570 --> 00:15:14.819
here, this green triangle is an insertion
component. And so as this component of the

00:15:14.819 --> 00:15:20.319
operation is applied, content is inserted
in the middle. And so then this diagram shows

00:15:20.319 --> 00:15:24.649
two operations. So you can see two operations
can take the document through a series of

00:15:24.649 --> 00:15:28.790
states. And, you know, the components can
overlap in here. Part of the inserted content

00:15:28.790 --> 00:15:38.649
is deleted in the next--the next component
of the operation. Wave operations are composable,

00:15:38.649 --> 00:15:43.069
which means for any pair of operations like
this, you can collapse them into one operation

00:15:43.069 --> 00:15:48.769
which represents the same mutation and then
out with any number of operations. They can

00:15:48.769 --> 00:15:56.419
all be collapsed, composed into one operation
on--in the domain of a single document. And

00:15:56.419 --> 00:16:02.350
this is--this is how we represent our documents.
You know, on disc, the structure of the daughter

00:16:02.350 --> 00:16:07.069
end document is purely defined as the sequence
of operations that mutate the empty document

00:16:07.069 --> 00:16:15.540
into some state. Operations are also invertible.
So for any operation, you can compute an operation

00:16:15.540 --> 00:16:22.079
that does--has the opposite effect when applied
to a document that's sort of in a state after

00:16:22.079 --> 00:16:26.209
the first one. You could make that computation
without reference to the document. You only

00:16:26.209 --> 00:16:30.030
need an operation to be able to compute its
inverse you don't need reference to the document

00:16:30.030 --> 00:16:36.519
it applies to. And they can--and they transform.
So there's three important--three important

00:16:36.519 --> 00:16:40.829
properties. They are composable, invertible,
and they transform against each other, which

00:16:40.829 --> 00:16:48.319
means the server is able to compute intention
preserving result, intention preserving changes

00:16:48.319 --> 00:16:54.720
to operations committed by different clients
at different points in the document. But if

00:16:54.720 --> 00:16:59.759
you want more detail about operations, perhaps
chat one of us later or have a look at some

00:16:59.759 --> 00:17:07.422
of the Google I/O talks from, I guess, the
2009 ones. They probably have the most detail.

00:17:07.422 --> 00:17:15.180
And there are some other videos on YouTube
as well describing this. Are there any questions?

00:17:15.180 --> 00:17:21.310
All right. Awesome. Okay, so we jump up a
level. We get to Wavelets. A wavelet is a

00:17:21.310 --> 00:17:25.880
collection of documents and a collection of
participants who are participating on that

00:17:25.880 --> 00:17:34.020
collection of documents. Let's go from the
top. So a wavelet has an ID. Well, it has

00:17:34.020 --> 00:17:39.500
two IDs; a wave ID and a wavelet ID. Both
of these have the form of some domain which

00:17:39.500 --> 00:17:48.540
hosts the thing and then some unique pseudo-random
part--unique that identifies it. And a wavelet

00:17:48.540 --> 00:17:52.820
has two IDs. One, which identifies the wave
it's in, and one which identifies it within

00:17:52.820 --> 00:18:02.060
the wavelet. Then as a bunch of participants,
all the participants share the wavelet equally

00:18:02.060 --> 00:18:08.790
in a funny naÃ¯ve case. So if you are a participant
on a wavelet, you can view and mutate anything

00:18:08.790 --> 00:18:15.640
in the wavelet. Access control is something
we build on top of this layer. It's then just

00:18:15.640 --> 00:18:21.660
a bag of documents. The documents have identifiers.
The identifiers are frequently structured

00:18:21.660 --> 00:18:27.670
so there's a special document that's named,
"Conversation," which I'll talk about a bit

00:18:27.670 --> 00:18:30.320
later. These documents--each message in a
wave conversation is backed by one document.

00:18:30.320 --> 00:18:35.500
There's also other documents that implement
other sort of aspects of a conversational

00:18:35.500 --> 00:18:40.190
wave like the tags that are applied to it.
So they're--these are all represented inside

00:18:40.190 --> 00:18:43.760
documents. They're all mutated by document
ops. They're not special things in the protocol.

00:18:43.760 --> 00:18:51.050
Everything is just wavelets which are bags
of documents. So the two operations that apply

00:18:51.050 --> 00:18:56.800
to a wavelet are to add and remove participants
and then to just apply an operation to some

00:18:56.800 --> 00:19:05.550
document that's part of the wavelet. And so,
wavelets are nothing else that's special.

00:19:05.550 --> 00:19:14.850
Questions? Cool. Okay, a wave then--finally,
we're up to the level where we can talk about

00:19:14.850 --> 00:19:19.580
what a wave is, that's nothing more than a
collection of wavelets. It's not a question

00:19:19.580 --> 00:19:24.140
that's explicitly stored anywhere. It's simply
the set of wavelets that share a wave ID.

00:19:24.140 --> 00:19:29.920
So a wave is added--a wavelet is added to
a wave simply by giving it a wave ID of that

00:19:29.920 --> 00:19:37.040
wave. And this means that a wave is not necessarily
hosted even on one service provider. So we

00:19:37.040 --> 00:19:42.600
could have a wave on acmewave.com, and someone
else on the federated Wave sandbox.com could

00:19:42.600 --> 00:19:49.140
add a wavelet to that wave, perhaps representing
a private reply, and only add Wave sandbox.com

00:19:49.140 --> 00:19:53.950
participants to that wavelet, and Acmewave
would never see that wavelet. It's still logically

00:19:53.950 --> 00:19:59.700
part of the wave but Acmewave only has a partial
view of it in this case. I mean, so that the

00:19:59.700 --> 00:20:04.720
daughter of that private reply on Wave sandbox
never travels across near the incident to

00:20:04.720 --> 00:20:09.930
Acmewave. You don't even need to trust Acmewave
at all to be able to have a wave--a wavelet

00:20:09.930 --> 00:20:14.630
that's part of that wave. Yeah, question?
&gt;&gt; [INDISTINCT]

00:20:14.630 --> 00:20:19.760
&gt;&gt; NORTH: That's right. The only reason it
would find out is if someone who does know

00:20:19.760 --> 00:20:25.070
that it exists adds an Acmewave participant,
and then the Wave sandbox, the Wave sandbox

00:20:25.070 --> 00:20:32.630
server, will tell Acmewave that the wavelet
exists and you should go and fetch the data.

00:20:32.630 --> 00:20:36.530
But normally, outside a federation, you know,
most of the wavelets in a wave are hosted

00:20:36.530 --> 00:20:40.930
on one machine and you can just sort of--just
scan of the data stores and so on to discover

00:20:40.930 --> 00:20:49.500
which wave looks a part of the same wave.
Okay. So then we also have a concept that's

00:20:49.500 --> 00:20:53.770
not stored anywhere but represented in a running
way system which is a Wave view. And that's

00:20:53.770 --> 00:21:00.310
one user's--one client's view of the wavelets
in a wave that it participates on. So a wave

00:21:00.310 --> 00:21:04.070
might have a bundle of wavelets. Some of them
might be shared by lots of people. Some of

00:21:04.070 --> 00:21:08.760
them might be private wavelets that only has
only one participant. A client's view is the

00:21:08.760 --> 00:21:17.190
wavelets where that client's, you know, address
participates on that wave. And so in the code,

00:21:17.190 --> 00:21:22.080
it's the client front end which computes the
client's view. It has access to the wave person,

00:21:22.080 --> 00:21:26.800
sees all the wavelets. It computes the client's
view and sends only the deltas that are in

00:21:26.800 --> 00:21:39.970
view to a particular client. Any questions?
We're cool. All right. So what I've described

00:21:39.970 --> 00:21:49.180
up till now is what we think of as the core--the
sort of the core of Wave. It's an attempt

00:21:49.180 --> 00:21:56.870
to be an application diagnostic tool bag of,
you know, concurrent documents with participation

00:21:56.870 --> 00:22:00.870
upon which application models can be built.
And the application model which everyone is

00:22:00.870 --> 00:22:04.440
familiar with is the conversation which is,
of course, the one it was originally designed

00:22:04.440 --> 00:22:12.680
for. So a conversation then is an abstract
data model that we embed in this--in this

00:22:12.680 --> 00:22:18.360
substrate of wavelets and documents. So the
way a conversation is represented is there's

00:22:18.360 --> 00:22:24.450
one document per blip, so one document per
conversational message. There's another document

00:22:24.450 --> 00:22:29.450
which describes the--describes the--yeah,
the structure of the blips; which blips are

00:22:29.450 --> 00:22:34.440
replies to which, which blips are in which
threads, and how those things are nested within

00:22:34.440 --> 00:22:39.720
the wavelet. And so it's described inside
the document rather than being sort of represented

00:22:39.720 --> 00:22:45.080
deep into the core. And then private replies,
I briefly discussed a separate wavelet. So,

00:22:45.080 --> 00:22:48.980
a conversation might have a number of wavelets.
Some of them will be conversational wavelets

00:22:48.980 --> 00:22:53.780
that everyone is participating on. Some of
them will be private user on the wavelets

00:22:53.780 --> 00:22:57.470
that only--normally have only one participant
on them and they contain sort of your metadata

00:22:57.470 --> 00:23:02.091
about the conversation. And some might be
private replies which are conversational but

00:23:02.091 --> 00:23:09.890
are only shared with the subset of the participants.
So I can talk a little bit about how that

00:23:09.890 --> 00:23:18.880
nesting happens. So there's a special document
inside each conversational wave called conversation,

00:23:18.880 --> 00:23:25.650
and here's an example of one. And it describes
the nesting of threads and messages. So there's

00:23:25.650 --> 00:23:30.570
an implicit root thread in the conversation.
And then this root thread has two blips; the

00:23:30.570 --> 00:23:34.230
one right at the top and the one right at
the bottom. And then there's a reply to that

00:23:34.230 --> 00:23:38.320
first blip. Someone near--in the wave client,
like, quick--hit--like, clicked on the first

00:23:38.320 --> 00:23:43.710
blip and hit "Reply", and that spawns a new
thread and that thread has two blips as well.

00:23:43.710 --> 00:23:48.870
So these two. And then this blip again has
a reply, and there's just a single message

00:23:48.870 --> 00:23:53.081
inside that. I should really have had a slide
that shows you what the wave panel looks like

00:23:53.081 --> 00:24:03.070
with this conversation but I didn't do that.
So that model is the conversation is a thread,

00:24:03.070 --> 00:24:07.430
a thread has a number of blips, and each blip
can have threads and a thread has blips and

00:24:07.430 --> 00:24:12.600
so on, mutually, recursively. And then that
give us--that gives us the threaded conversations

00:24:12.600 --> 00:24:22.780
that make--a part of what makes Wave useful.
So the flow then to--when you hit, you know,

00:24:22.780 --> 00:24:31.500
"Reply," in your Wave client. Your Wave client
first goes and sticks in some, you know, body

00:24:31.500 --> 00:24:36.150
tag and an empty line in some new document
that invents. It picks a new document in,

00:24:36.150 --> 00:24:39.330
it sticks and empty line in it. And then it
comes along to the conversation manifest and

00:24:39.330 --> 00:24:42.660
sticks a new entry in the right point here
describing where that new blip appears in

00:24:42.660 --> 00:24:49.000
the conversational structure. And so--and
then the reverse process when someone else--when

00:24:49.000 --> 00:24:54.020
some other client receives those mutations.
It sees an empty line up here in some new

00:24:54.020 --> 00:24:57.560
document ID, but it doesn't know what that
is yet, and then it sees an entry up here

00:24:57.560 --> 00:24:59.620
in the conversation manifest and goes, "Ah,
there's a new blip," and renders it and then

00:24:59.620 --> 00:25:08.710
goes and looks up that document for the content.
Okay, any questions about this so far? Yes?

00:25:08.710 --> 00:25:15.070
&gt;&gt; [INDISTINCT] have example where you have
a private conversation and a private [INDISTINCT]

00:25:15.070 --> 00:25:20.920
&gt;&gt; NORTH: I don't have any one on screen but
I can describe how that's represented as well.

00:25:20.920 --> 00:25:26.520
So a private reply is another wavelet, it
has its own conversation document like this

00:25:26.520 --> 00:25:32.020
that describes the structure of each conversation.
The difference being that the conversation

00:25:32.020 --> 00:25:37.150
element, sort of, the top level element of
its manifest, also it describes a point in

00:25:37.150 --> 00:25:48.830
the parent conversation where it's embedded.
So our current code--our current code, I think,

00:25:48.830 --> 00:25:56.110
describes the message that it's in a reply
to so it identify a blip ID of the reply,

00:25:56.110 --> 00:26:00.600
but I don't think it appropriately yet describes
where. So you can do--oh, we can't do inline

00:26:00.600 --> 00:26:07.080
reply, that's right. You can't do inline private
replies yet. All right, so attributes on the

00:26:07.080 --> 00:26:11.470
conversation element. There is a reply wavelet
ID which says, "This wavelet is a private

00:26:11.470 --> 00:26:16.150
reply to some other wavelet," then a reply
blip ID which says--and within that wavelet

00:26:16.150 --> 00:26:23.930
the blip with this identifier is the one that
this is a reply to. So each private reply

00:26:23.930 --> 00:26:29.760
wavelet is its own wavelet, has its own manifest
describing the layout of blips and references

00:26:29.760 --> 00:26:35.630
by name where it should appear in its parent
conversation. This has the effect that there's

00:26:35.630 --> 00:26:39.460
no trace of the private reply in the parent
conversation. Someone who doesn't participate

00:26:39.460 --> 00:26:42.700
on it cannot know that it exists, let alone
see the content. Yeah?

00:26:42.700 --> 00:26:50.300
&gt;&gt; How do you identify it with where it goes
[INDISTINCT]?

00:26:50.300 --> 00:26:59.000
&gt;&gt; NORTH: Just by identifier. So it's--a private
reply is always in reply to some blip. So

00:26:59.000 --> 00:27:03.510
that blip has an ID and we just name that
ID in this wavelet conversation manifest.

00:27:03.510 --> 00:27:08.020
At the moment we can't describe it with any
more precision than in a reply to this message.

00:27:08.020 --> 00:27:13.330
Did that make sense? Not quite? Let's chat
it out again later. Yeah?

00:27:13.330 --> 00:27:18.930
&gt;&gt; How popular was private replies to a lot
it can do?

00:27:18.930 --> 00:27:23.780
&gt;&gt; NORTH: Do you know the steps are?
&gt;&gt; And, maybe. If you would, did you have

00:27:23.780 --> 00:27:31.300
[INDISTINCT] how many if you will use [INDISTINCT]?
&gt;&gt; [INDISTINCT] made public but very small.

00:27:31.300 --> 00:27:33.450
&gt;&gt; Yeah.
&gt;&gt; Very, very small.

00:27:33.450 --> 00:27:38.960
&gt;&gt; NORTH: It was pretty small.
&gt;&gt; [INDISTINCT]

00:27:38.960 --> 00:27:48.450
&gt;&gt; NORTH: It probably scaled a bit with, sort
of, how happy you were--technically savvy,

00:27:48.450 --> 00:27:54.362
it was not in the most discoverable feature.
It was not immediately obvious how they work

00:27:54.362 --> 00:27:55.362
either, so.
&gt;&gt; These people were just [INDISTINCT] in

00:27:55.362 --> 00:28:01.830
a way at that time anyways, so.
&gt;&gt; NORTH: So they're not widely used. I don't

00:28:01.830 --> 00:28:05.410
think Wave in a Box supports them right now
but, you know, we'll work towards it. It didn't

00:28:05.410 --> 00:28:09.210
seem like a blocker for us having something
working. Yeah?

00:28:09.210 --> 00:28:16.390
&gt;&gt; If the private reply references blip in
the parent conversation.

00:28:16.390 --> 00:28:21.430
&gt;&gt; NORTH: Yeah?
&gt;&gt; Will this delete it? What happens to the

00:28:21.430 --> 00:28:24.690
entire reply?
&gt;&gt; NORTH: The question was if the private

00:28:24.690 --> 00:28:28.390
reply reference is a blip and that blip is
deleted, what happens? The private reply is

00:28:28.390 --> 00:28:32.500
basically often the client picks somewhere
to attach it, you know, probably at the very

00:28:32.500 --> 00:28:35.011
bottom of the wave or something. It's still
there but we don't know where to point it

00:28:35.011 --> 00:28:39.410
anymore. So, I guess, a trade off of the fact
that there's no trace of it in the parent

00:28:39.410 --> 00:28:50.960
wavelet is that the--someone who doesn't know
about its existence can't fix that up. What's

00:28:50.960 --> 00:28:58.650
next? Okay. So the conversation is one of
these models that we embed on top of the wave

00:28:58.650 --> 00:29:04.110
core model. Other things that we embed, tags.
So in Google Wave each wave has a bunch of

00:29:04.110 --> 00:29:10.050
tags; tags are shared. The tags each represented
in another document inside the wavelet, the

00:29:10.050 --> 00:29:17.130
document is called tags. And it's just, basically,
it looks like a list of XML structure elements

00:29:17.130 --> 00:29:25.070
called tag with a value if it's the value
of tag. So we embed--we represent this list

00:29:25.070 --> 00:29:28.809
of, you know, arbitrary data that's attached
to a conversation just in another document.

00:29:28.809 --> 00:29:36.730
Per use of data, so every--on Google Wave,
I don't know if they're live on Wave in a

00:29:36.730 --> 00:29:42.260
Box yet. I don't know if it's quite been hooked
up yet. Each user has a bunch of data about

00:29:42.260 --> 00:29:46.640
their interaction with a wave. So when you
view a wave we keep track of, you know, which

00:29:46.640 --> 00:29:50.100
messages you have viewed. So when you coma
back you can see a, you know, a green light

00:29:50.100 --> 00:29:57.400
marking messages they didn't use since when
we looked at it. And we can track when you

00:29:57.400 --> 00:30:00.820
hit the archive button to make the wave go
away until it, you know, is changed again

00:30:00.820 --> 00:30:05.170
or when you put in it in a folder. All that
is sort of information that's only--that's

00:30:05.170 --> 00:30:08.010
private to you. It's your interaction with
the wave it's not shared with other people.

00:30:08.010 --> 00:30:13.480
But we also store that, you know, in Wave
and so the way that works is another wavelet

00:30:13.480 --> 00:30:19.470
which we call your user data wavelet. I mean,
it has an ID which includes your address so

00:30:19.470 --> 00:30:24.961
it's sort of you can--the ID is well-known
to you so you can look it up. You are the

00:30:24.961 --> 00:30:28.540
only participant on it so it just never gets
sent to other clients at all; it's not in

00:30:28.540 --> 00:30:33.090
their view. It never gets federated because
there's no one from federated service who

00:30:33.090 --> 00:30:39.690
participates in it. And so it represents folders
in the read state and in which things you've

00:30:39.690 --> 00:30:43.290
seen and read which--and you can unmarked
things as unread whether you've got something

00:30:43.290 --> 00:30:48.960
in a folder or so on. All inside data structures
that are embedded inside another wavelet inside

00:30:48.960 --> 00:30:53.190
the wave that only you can see. So I'm not
going to show you all of the ways they're

00:30:53.190 --> 00:30:59.740
variously embedded. There's code--there's
code which is in the repository which describes

00:30:59.740 --> 00:31:04.760
ways to embed basic data structures like lists
and maps inside wave documents. And Dave Hern

00:31:04.760 --> 00:31:10.610
is going to talk about that on Wednesday morning,
I think, a bit more about how you can embed

00:31:10.610 --> 00:31:15.170
your own data structure inside wave's document
model. Folders, archive, follow--yeah, okay,

00:31:15.170 --> 00:31:16.384
so all of those things.
&gt;&gt; So, Alex...

00:31:16.384 --> 00:31:17.384
&gt;&gt; NORTH: Yeah?
&gt;&gt; If you were to gather 100,000 users reading

00:31:17.384 --> 00:31:36.740
the same document and they point some archive...
&gt;&gt; NORTH: Yeah.

00:31:36.740 --> 00:31:37.740
&gt;&gt; ...the opposite, actual stores in way on
a server grows to accommodate those individual

00:31:37.740 --> 00:31:38.740
states, all 100,000 users?
&gt;&gt; NORTH: Yes, the question was if you have

00:31:38.740 --> 00:31:41.250
hundreds of thousands--excuse me, hundreds
of thousands of people all watching the same

00:31:41.250 --> 00:31:45.970
wave, does the state on the server grow to,
you know, in scale with that? And the answer

00:31:45.970 --> 00:31:48.890
is, yes. Each of them ends up with the user
data wavelet, but normally pretty small. It's

00:31:48.890 --> 00:31:56.040
like a couple of documents, but, yes, it grows.
If you of course--yeah. The answer is yes.

00:31:56.040 --> 00:31:58.730
If you didn't have that, I'm not trying to
excuse it, but if you didn't have that, of

00:31:58.730 --> 00:31:59.730
course, you would be storing the data in some
other data store or somewhere else.

00:31:59.730 --> 00:32:00.730
&gt;&gt; You know it might be interesting just to
think about [INDISTINCT] work for the [INDISTINCT]

00:32:00.730 --> 00:32:01.730
in a way to distribute the documented state.
You know, that if you only store the data

00:32:01.730 --> 00:32:02.730
for the users that are directly [INDISTINCT]
to store that [INDISTINCT]?

00:32:02.730 --> 00:32:27.679
&gt;&gt; NORTH: So

00:32:27.679 --> 00:32:31.320
the question was can federation be used to
sort of spread that--spread that load a bit?

00:32:31.320 --> 00:32:38.640
And the answer is, yes, at least in a way.
If you have a wave and it has lots of participants

00:32:38.640 --> 00:32:43.470
from other federated servers on it, the server
hosting the conversational wavelet that doesn't

00:32:43.470 --> 00:32:47.809
host the user data, their own wave servers
host it. Their own user data wavelets and

00:32:47.809 --> 00:32:54.980
never federate--and never federated with you
because no one users on your server participates.

00:32:54.980 --> 00:32:59.130
So if you--if you have lost of federated users
then, yeah, their own service providers host

00:32:59.130 --> 00:33:10.200
their own user data so that does spread it
a little bit.

00:33:10.200 --> 00:33:16.990
&gt;&gt; So note that the different wavelets within
the same wave are not sort of a transaction

00:33:16.990 --> 00:33:23.160
or a unit or something like that so they don't
need to be hosted by the same server. If you

00:33:23.160 --> 00:33:31.429
have a multi-server data store then you can
choose to sort of shot this so that the user

00:33:31.429 --> 00:33:35.160
data is--are used that a way with this is
hosted on another machine and the conversation

00:33:35.160 --> 00:33:40.690
wavelet that it belongs to.
&gt;&gt; So you're saying including the documents

00:33:40.690 --> 00:33:47.550
itself would that be a way?
&gt;&gt; So you would have--you would want to put

00:33:47.550 --> 00:33:54.450
like one wavelet in this--in one place because
there's one transaction unit, but there are

00:33:54.450 --> 00:33:58.500
many waves--so many used data wave that's
in one wave. There are all different wavelets

00:33:58.500 --> 00:34:02.210
and you can choose to have them hosted in
different storage package.

00:34:02.210 --> 00:34:07.670
&gt;&gt; That would then--so I'm assuming you're
talking about a distributed versus centralized

00:34:07.670 --> 00:34:09.489
storage provider?
&gt;&gt; NORTH: Uh-hmm.

00:34:09.489 --> 00:34:12.829
&gt;&gt; What happens if one of the distributed
notes falls off? [INDISTINCT] distributed

00:34:12.829 --> 00:34:14.419
notes you can't actually recover the wavelets
from there.

00:34:14.419 --> 00:34:16.549
&gt;&gt; [INDISTINCT] if the company [INDISTINCT]
that wave service has a repeat [INDISTINCT]

00:34:16.549 --> 00:34:29.609
on

00:34:29.609 --> 00:34:40.429
it when they only have that it's certainly
one machine...

00:34:40.429 --> 00:34:49.460
&gt;&gt; Yes.
&gt;&gt; That's the problem with their architect.

00:34:49.460 --> 00:35:02.819
&gt;&gt; Yeah, but if they're talking about a distributed
wave storage [INDISTINCT] which takes out

00:35:02.819 --> 00:35:11.970
a couple of wavelet. All of a sudden you're
missing a wavelet when you throw--throwing

00:35:11.970 --> 00:35:16.099
errors.
&gt;&gt; You don't--you don't throw all eggs in

00:35:16.099 --> 00:35:17.429
a basket.
&gt;&gt; So they should be sinking their ships then?

00:35:17.429 --> 00:35:18.429
&gt;&gt; [INDISTINCT] machine?
&gt;&gt; So the...

00:35:18.429 --> 00:35:19.429
&gt;&gt; The architectural issue that's outside
of this scope of design of wave.

00:35:19.429 --> 00:35:21.099
&gt;&gt; Well, waves at the moment is essential
as all [INDISTINCT].

00:35:21.099 --> 00:35:22.099
&gt;&gt; Wave in a Box is--if that code is written
on the work on one server. The core concepts

00:35:22.099 --> 00:35:23.099
don't requires that it will be on one business
server. Google is listing their wave on one

00:35:23.099 --> 00:35:24.099
server.
&gt;&gt; Yeah, so, I think we are still progressing

00:35:24.099 --> 00:35:25.709
off the topic here but I'm happy to explain
how we organize that.

00:35:25.709 --> 00:35:31.920
&gt;&gt; NORTH: Yeah, that machine is full all the
time and obviously we didn't--didn't lose

00:35:31.920 --> 00:35:38.130
too much data. Right. Okay, now I'm going
to talk--so that's the concept. We had the--right

00:35:38.130 --> 00:35:42.470
at the bottom are documents which are mutated
by operation--oh, sorry. Question, yeah?

00:35:42.470 --> 00:35:52.061
&gt;&gt; So does the combination of [INDISTINCT]
to look for any other models on [INDISTINCT]

00:35:52.061 --> 00:35:53.140
models that [INDISTINCT] composition?
&gt;&gt; NORTH: The composition is the main one.

00:35:53.140 --> 00:35:58.460
These metadata-type models that are related
to the conversation are another one. We've

00:35:58.460 --> 00:36:03.150
explored a few other ones but didn't sort
of get them done. In some--there are some

00:36:03.150 --> 00:36:06.460
things that the wave model is not good for
and there are some that it is good for.

00:36:06.460 --> 00:36:10.970
&gt;&gt; Spreadsheet?
&gt;&gt; NORTH: Yes, our tables don't--sorry, spreadsheet

00:36:10.970 --> 00:36:14.109
is like a table. We definitely went through
a lot of conceptual thinking about it but,

00:36:14.109 --> 00:36:19.960
you know, it didn't--it wasn't--we didn't
implement anything. See a table structure

00:36:19.960 --> 00:36:26.720
looks unnatural inside a wave, but it still
ends up being very highly concurrences on.

00:36:26.720 --> 00:36:30.460
We have good sort of best practices for embedding
data structures that we sort of developed

00:36:30.460 --> 00:36:36.160
and hope to communicate with you over these--the
next few days, but I can't point to anything

00:36:36.160 --> 00:36:38.800
else concrete.
&gt;&gt; Suggest [INDISTINCT] wavelets.

00:36:38.800 --> 00:36:41.319
&gt;&gt; NORTH: Suggest wavelets? Do people even
know how they are supposed to work?

00:36:41.319 --> 00:36:46.880
&gt;&gt; [INDISTINCT] I think--I think that they
are operational [INDISTINCT].

00:36:46.880 --> 00:36:51.880
&gt;&gt; NORTH: Yeah, okay.
&gt;&gt; [INDISTINCT]

00:36:51.880 --> 00:36:59.400
&gt;&gt; NORTH: Yup, sure. Okay. So in Google Wave
when you type in, you know, start a new wave,

00:36:59.400 --> 00:37:03.410
type some content in and so when I hit the
add participant button, Google Wave tries

00:37:03.410 --> 00:37:07.080
to be very smart about who appears at top
of that list by analyzing the content and

00:37:07.080 --> 00:37:12.290
content you've shared with other users inside
wave. And the way it communicates to you what

00:37:12.290 --> 00:37:16.630
the participant's suggestion should be is
through another wavelet. There's another wavelet

00:37:16.630 --> 00:37:19.319
in the wave that has a rank to ordering of
participants.

00:37:19.319 --> 00:37:22.650
&gt;&gt; Per user?
&gt;&gt; NORTH: Per--yes, per user. So, it's inside

00:37:22.650 --> 00:37:28.230
your user data wavelets so no one else sees
your suggestions. Another one which occurs

00:37:28.230 --> 00:37:33.571
to me is spelling corrections. So, when you
have to spell each inside the conversation

00:37:33.571 --> 00:37:41.059
there's another document that our spelling
agent writes which has a bunch of--has one

00:37:41.059 --> 00:37:48.720
entry per misspelled word in the conversational
content. In the conversational content, the

00:37:48.720 --> 00:37:52.249
spelling agent annotates a misspelled region
and gives it some ID which is a look up into

00:37:52.249 --> 00:37:58.529
the corresponding spell document and then
that contains, you know, a list of suggestions

00:37:58.529 --> 00:38:01.290
with your rank orderings and scores and so
on.

00:38:01.290 --> 00:38:05.479
&gt;&gt; It's the attachment of data docs as the
upload progresses.

00:38:05.479 --> 00:38:10.220
&gt;&gt; NORTH: Oh yeah, attachments is another
one. So, an attachment like an image that

00:38:10.220 --> 00:38:15.320
you attach to a wave, the actual binary data
is, you know, your blob stored somewhere,

00:38:15.320 --> 00:38:19.900
but the metadata describing it is in another
document. These are what we all what we call

00:38:19.900 --> 00:38:22.999
data documents. Documents that are not blip
documents we tend to call data documents and

00:38:22.999 --> 00:38:28.480
that has a sort of a record structure embedded
in it that describes the file name, the percentage

00:38:28.480 --> 00:38:35.200
that's uploaded. So, that's sort of live updates
as the attachment uploads, the mime type and

00:38:35.200 --> 00:38:42.039
stuff like that. So, it's a very simple sort
of record structures are very easy to embed.

00:38:42.039 --> 00:38:51.039
Yes?
&gt;&gt; Can you spell the--Wave in a Box go big?

00:38:51.039 --> 00:39:04.549
How can a user have standard set of pages
and invite every conversations without having

00:39:04.549 --> 00:39:08.181
to ask specifically [INDISTINCT]? So like
spelling, you have to add, it's already there.

00:39:08.181 --> 00:39:09.181
What type of the user basically defined the
row instead of agents summarized that are

00:39:09.181 --> 00:39:10.181
always present?
&gt;&gt; NORTH: So, right now, Wave in a Box lacks

00:39:10.181 --> 00:39:14.230
that. The question was how can users of Wave
in a box have things like spelling that sort

00:39:14.230 --> 00:39:20.180
of act on/or waves. Right now, Wave in a box
doesn't have that functionality. Someone mentioned

00:39:20.180 --> 00:39:24.089
earlier, I think it was James, that there
was this agent's concept in sort of the early

00:39:24.089 --> 00:39:29.009
versions that we've been taking up. It was
not, not well implemented. So, an agent like

00:39:29.009 --> 00:39:33.450
spelling sits on the wave bus. In Wave in
a Box, this is all inside one process. In

00:39:33.450 --> 00:39:36.579
Google Wave, the wave bus was actually on
the wire, and everything that was in that

00:39:36.579 --> 00:39:44.630
original box was on separate machines. So,
the answer is to expose something like the

00:39:44.630 --> 00:39:50.000
wave bus as a, you know, as a network level
interface, and then build some--let's call

00:39:50.000 --> 00:39:55.250
them agents--which respond to that wave bus
and receive all the data in their trusted

00:39:55.250 --> 00:40:01.109
components of your system. They're not things
that you let people need to hook up to. So,

00:40:01.109 --> 00:40:08.359
Wave in a Box will--lacks that at the moment.
It's--we need to sort of--we need to rethink

00:40:08.359 --> 00:40:12.000
how we can expose a wave bus appropriately
in Wave in a Box. But it's sort of--it's a

00:40:12.000 --> 00:40:16.579
little bit beyond our goals in a box because
once we're doing that, it's not--it starts

00:40:16.579 --> 00:40:19.519
to become a distributed system. It's something
we want to look at after we get the core thing

00:40:19.519 --> 00:40:21.700
working. So, we haven't here done it yet.
&gt;&gt; What was the question? Sorry, I haven't

00:40:21.700 --> 00:40:27.670
heard.
&gt;&gt; Oh, in that case, like, spelling. Yeah,

00:40:27.670 --> 00:40:34.846
you act on [INDISTINCT] always without the
user having to add a specific [INDISTINCT].

00:40:34.846 --> 00:40:35.846
Perhaps, it's an advantage, you know.
&gt;&gt; NORTH: So, right now, you could do it by

00:40:35.846 --> 00:40:40.650
coding it into the box--Wave in a Box. But
that's, you know, it's going to be not a winning

00:40:40.650 --> 00:40:45.220
game if we do it too many--too often and have
too much stuff running inside there. So really,

00:40:45.220 --> 00:40:49.579
the right solution is to--once we have sort
of Wave in a box working and decide we need

00:40:49.579 --> 00:40:54.569
to expand it to split out some kind of wave
bus interface over the network and then have

00:40:54.569 --> 00:40:57.739
agent like components.
&gt;&gt; [INDISTINCT] your agents that'll be like

00:40:57.739 --> 00:41:02.429
too much process then to light on Wave in
a Box.

00:41:02.429 --> 00:41:06.200
&gt;&gt; NORTH: Possibly, yeah. I mean, when we
had a library that sort of managed that kind

00:41:06.200 --> 00:41:10.480
of stuff we'd probably do it again rather
than try an open source decoder, it wasn't

00:41:10.480 --> 00:41:11.480
brilliant.
&gt;&gt; I just got another question here.

00:41:11.480 --> 00:41:12.480
&gt;&gt; NORTH: Yeah?
&gt;&gt; I'm really curious in the concepts of theâyou

00:41:12.480 --> 00:41:13.480
should--you guys manage accounts with the
line, you know, happen to do the line--line

00:41:13.480 --> 00:41:14.480
slash line...
&gt;&gt; NORTH: Yeah.

00:41:14.480 --> 00:41:15.480
&gt;&gt; ...and begin the styling and all that kind
of stuff. And I was wondering when you run

00:41:15.480 --> 00:41:26.910
with the same problems you talked earlier
about using Wave to render in something other

00:41:26.910 --> 00:41:30.990
than the document.
&gt;&gt; NORTH: Uh-huh.

00:41:30.990 --> 00:41:44.880
&gt;&gt; Or possibly render to, for instance, a
lot of drawing on to a map or a PowerPoint

00:41:44.880 --> 00:41:57.940
slide or something like that. And would run
into the same process if you were changing

00:41:57.940 --> 00:42:05.470
XML into a conversation? It's kind of like
XML on top of XML [INDISTINCT] type it in,

00:42:05.470 --> 00:42:06.470
it might going to hit a point where a hit
which results something you've [INDISTINCT]

00:42:06.470 --> 00:42:07.789
where your backspace is going.
&gt;&gt; NORTH: The question was, would there be

00:42:07.789 --> 00:42:12.880
a problem? Our answer, in the context of my
earlier talking about lines and so on, if

00:42:12.880 --> 00:42:17.589
you were trying to type XML into a wave, so
XML to an XML, would you run into sort of

00:42:17.589 --> 00:42:22.650
concurrency problems? Probably not. What you
wouldn't have is a guarantee that the XML

00:42:22.650 --> 00:42:26.999
is always well formed. Wave documents never
end up in an ill formed state because you

00:42:26.999 --> 00:42:31.250
can't apply an operation that breaks the nesting
for example. And it was maintaining that kind

00:42:31.250 --> 00:42:35.869
of--those kinds of guarantees that were hard.
If you were just typing XML into a document,

00:42:35.869 --> 00:42:38.680
it's not always in a well formed state if
you're, you know, typing and people can be

00:42:38.680 --> 00:42:41.049
typing all over the document. And that's fine,
it would look fine.

00:42:41.049 --> 00:42:48.470
&gt;&gt; So, I guess the problem then is, you know,
future duration or maybe experimental durations

00:42:48.470 --> 00:42:55.900
of Wave. Do we have to have that restriction
of how it will happen to our components?

00:42:55.900 --> 00:43:00.329
&gt;&gt; NORTH: The question was should--do we--could
we have a version of Wave that doesn't have

00:43:00.329 --> 00:43:09.450
the restriction of being a well formed all
the time? That will be tricky, that requires

00:43:09.450 --> 00:43:12.670
deep thought. That's--I mean--so that's built
very deep into the core of Wave that these

00:43:12.670 --> 00:43:18.680
documents are well formed. At the top of my
head, it would be a different system if it

00:43:18.680 --> 00:43:24.069
wasn't. But it's interesting if you think
about it. I haven't thought about it. Are

00:43:24.069 --> 00:43:28.240
there any other questions over here? These
are good questions. I like it.

00:43:28.240 --> 00:43:38.569
&gt;&gt; Are there any models you're thinking of
adding?

00:43:38.569 --> 00:43:43.170
&gt;&gt; NORTH: Any models we're thinking of adding?
Off the top of my head, no, but it's the kind

00:43:43.170 --> 00:43:47.710
of thing where the code is out. It's an off
code right there now that you can, you can

00:43:47.710 --> 00:43:50.019
write your own.
&gt;&gt; How do you set it?

00:43:50.019 --> 00:43:54.299
&gt;&gt; NORTH: Your settings is another one. The
user settings was--so, if you can turn spelling

00:43:54.299 --> 00:43:57.809
on or off or set up email notification and
so on. That was also...

00:43:57.809 --> 00:44:01.130
&gt;&gt; Was that a bunch of data documents that
similarly or?

00:44:01.130 --> 00:44:09.430
&gt;&gt; NORTH: Yeah. That was a separate wave,
it was your settings wave and a bunch of data

00:44:09.430 --> 00:44:13.369
documents.
&gt;&gt; Search as a way or something that you design.

00:44:13.369 --> 00:44:17.130
&gt;&gt; NORTH: Oh, yeah. So, currently, the digest,
the search results, your inbox is---well,

00:44:17.130 --> 00:44:21.390
let's not talk about how it is currently.
Even in a couple of weeks time it's going

00:44:21.390 --> 00:44:26.660
to be on an RPC, you use the data API. So,
it's basically a request response kind of

00:44:26.660 --> 00:44:31.020
model. So, what we thought about for a long
time is just putting that in a wave so you

00:44:31.020 --> 00:44:39.360
open a wave and the server fills in your inbox
in by embedding it in that wave. And so then,

00:44:39.360 --> 00:44:44.700
that sort of gets rid of another--the advantage
of doing that is it gets rid of, you know,

00:44:44.700 --> 00:44:48.970
you could get rid of a servelet out of the
server. You can get rid of having--or any

00:44:48.970 --> 00:44:55.170
problems with going offline or re-synchronizing
as the wave box--sorry, as the inbox--if you

00:44:55.170 --> 00:45:00.470
have a live inbox or the results appear automatically,
you have to invent a new scheme to resolve

00:45:00.470 --> 00:45:05.420
the concurrent nature of that. You know, you
can archive something and meanwhile something

00:45:05.420 --> 00:45:10.400
appears and those are needed to be resolved
concurrently. You know, Wave just does that

00:45:10.400 --> 00:45:14.410
for you so you get to reuse all of that. You
can reuse the handling of the connection going

00:45:14.410 --> 00:45:19.859
offline and coming back online and reconnecting
and so on. So, the inbox is one example that

00:45:19.859 --> 00:45:24.130
we thought of where we would like to embed
it in a wave. And in fact we have a design

00:45:24.130 --> 00:45:28.440
for it, which I have just been sitting on
those. We were planning to do it then we thought,

00:45:28.440 --> 00:45:33.039
"No, we'll do something simple first." So
perhaps I'll publish that design when I get

00:45:33.039 --> 00:45:34.942
a moment as an example of another thing that
you can embed inside a wave.

00:45:34.942 --> 00:45:45.019
&gt;&gt; We've been thinking about sort ofâguess
like a search, like a synthetic way where

00:45:45.019 --> 00:45:49.369
you're interested in certain things that attach
across multiple ways and you want to just

00:45:49.369 --> 00:45:50.440
create this sort of synthetic view and have
it presented more or less.

00:45:50.440 --> 00:45:52.589
&gt;&gt; NORTH: Yeah.
&gt;&gt; In other ways or something of that nature.

00:45:52.589 --> 00:45:58.540
&gt;&gt; NORTH: Yeah, that could work, yeah. All
right, now I'm going to talk a little bit

00:45:58.540 --> 00:46:02.700
about the structure of the code that represents
these concepts. So, we've got documents that

00:46:02.700 --> 00:46:07.119
are acted on by ops. We have wavelets which
are bundles of documents and then we have

00:46:07.119 --> 00:46:11.230
the wave which is this collection of wavelets
and then the abstract models built on top

00:46:11.230 --> 00:46:16.110
of that. So, just--for those of you who are--excuse
me going to be going to look inside the code

00:46:16.110 --> 00:46:21.250
for this, this is how some of the code modules
are laid out. So, documents first. There's

00:46:21.250 --> 00:46:25.479
a raw document down the bottom which you almost
never have to interact with. That's a DOM

00:46:25.479 --> 00:46:31.349
data holder state, it has not much smarts,
but it's a DOM--it's a tree structure thing,

00:46:31.349 --> 00:46:36.730
very much like an HTML DOM or something. That's
sort of your raw document state, and it's

00:46:36.730 --> 00:46:43.951
mutated by, you know, a DOM star API create
child and stuff like that. You always never

00:46:43.951 --> 00:46:47.380
have to talk to that; you just need to know
it's there. And then this has two implementations.

00:46:47.380 --> 00:46:52.349
There's an implementation in the web client
which has a lot of links into the parallel

00:46:52.349 --> 00:46:59.309
HTML DOM. And so as waves change, as operations
are applied and this document mutates, the

00:46:59.309 --> 00:47:05.240
editor and rendering engine, mutate the HTML
DOM in parallel. And there's another implementation

00:47:05.240 --> 00:47:09.670
for non-browser environments, for service
side environments that just doesn't have those

00:47:09.670 --> 00:47:16.650
kind of links. And then most of the smarts
is in index document. Index document maintains

00:47:16.650 --> 00:47:21.869
a tree index over the structure of this raw
document. So I can very efficiently jump to

00:47:21.869 --> 00:47:26.559
particular locations. It doesn't need to do
a tree traversal, it can jump to particular

00:47:26.559 --> 00:47:33.359
locations very fast. And so, it is what ops
apply to. Ops pass things to the index document,

00:47:33.359 --> 00:47:38.079
and remember an op is a sequence of these
mutations. The index document that deconstructs

00:47:38.079 --> 00:47:42.440
that jumps to the right places in the raw
document and applies the mutations. It does

00:47:42.440 --> 00:47:49.869
the consistency checkings, schema checking,
that kind of stuff. And then, events pop out

00:47:49.869 --> 00:47:53.549
of the index document as it's changed. So,
a full operation applies and then an event

00:47:53.549 --> 00:47:58.880
pops out of the index document describing
what changed as part of that operation. Then

00:47:58.880 --> 00:48:04.160
sitting on top of that is what we call a mutable
document. There's a couple of different classes

00:48:04.160 --> 00:48:08.920
with various flavors of mutable document.
And these are the ones you will commonly interact

00:48:08.920 --> 00:48:12.950
with in code if you're building a data model
on top of a wave or something, and that presents

00:48:12.950 --> 00:48:22.859
you a sort of a user-friendly mutation API
so you can create children and insert text

00:48:22.859 --> 00:48:31.469
and so on. It's not dissimilar to this API
but an immutable document then generates ops.

00:48:31.469 --> 00:48:36.650
Its job is to take your programmatic mutations
and generate an op that describes that and

00:48:36.650 --> 00:48:40.210
then apply it to the mutable document that's
beneath it. And the reason we go through that

00:48:40.210 --> 00:48:44.609
sort of programmatic and then an op and then
programmatic again is because these ops are,

00:48:44.609 --> 00:48:47.780
you know, what Wave is built on and every
ops we need to send all the other serve--send

00:48:47.780 --> 00:48:55.319
to the wave server. So, as an op is applied
to this index document it's applied to the

00:48:55.319 --> 00:48:59.779
local state. It's also sent out to the remote
server so exactly the same op is applied in

00:48:59.779 --> 00:49:04.420
both places. And in the events that come out
of the index document bubble out of the mutable

00:49:04.420 --> 00:49:08.609
document as well. And if you're again writing
a data structure, you need to watch what happens

00:49:08.609 --> 00:49:14.890
to the document that's representing your data
structure as other people change it. So, it's

00:49:14.890 --> 00:49:20.900
a very basic layout of the document. End of
the code. Generally you'll be interacting

00:49:20.900 --> 00:49:23.670
with some interface around a mutable document.
Yes?

00:49:23.670 --> 00:49:27.440
&gt;&gt; When you're having key strokes, do you
do every key stroke or do you just some sort

00:49:27.440 --> 00:49:37.050
of timed key strokes for a certain quantity
of time to exact the operation...

00:49:37.050 --> 00:49:41.359
&gt;&gt; NORTH: The bundling is on somewhere slightly
different. The key strokes all are immediately

00:49:41.359 --> 00:49:44.890
applied to the local document and produce
an operation. You know, at least as fast as

00:49:44.890 --> 00:49:50.029
the browser scheduler let's us do it. But
then we then send an op immediately. They

00:49:50.029 --> 00:49:54.869
get bundled up so that we have just one outstanding
request to the server at a time. So, we send

00:49:54.869 --> 00:49:58.869
that an op, and then while we're waiting for
the response from the server, we can post

00:49:58.869 --> 00:50:02.619
any other ops that are applied to that document.
And when we finally get our response, we send

00:50:02.619 --> 00:50:09.309
that composed bundle off as the next--the
next network transaction. So that'll--that

00:50:09.309 --> 00:50:13.319
self-throttles according to the network latency.
If you have a high latency connection you

00:50:13.319 --> 00:50:24.069
get lots of things composed into one, one
transmission. So this codebin, if you're looking

00:50:24.069 --> 00:50:28.650
at a repository it's like an all great particle
wave model document and various sub-packages

00:50:28.650 --> 00:50:38.980
of that. A wavelet bin also has a similarly
three-tiered architectural loads wired up

00:50:38.980 --> 00:50:42.480
slightly differently. So there's data down
here which includes the documents, that includes

00:50:42.480 --> 00:50:47.190
some metadata about the wavelet, like, you
know, the participants, last modified time

00:50:47.190 --> 00:50:52.940
stamp, things like that. Again, the things
that we call data are really dumb. They're

00:50:52.940 --> 00:50:57.890
just containers. They could almost be a programmatically
generated. They can represent them as a protocol

00:50:57.890 --> 00:51:05.819
buffer of something. There's no--there's no
smarts. Ops are applied to the data--or ops

00:51:05.819 --> 00:51:12.020
apply themselves to the data via an op executor,
I mean any--and the reason we have this sort

00:51:12.020 --> 00:51:16.539
of op executor out to the side is it begin
so we have symmetry with local operations

00:51:16.539 --> 00:51:21.069
and remote operations. Local operations are
produced by other bits of coding in--running

00:51:21.069 --> 00:51:28.490
in your--in your client and apply to this--this
data. And remote operations at the server

00:51:28.490 --> 00:51:32.130
some other client has generated, sent to the
server and now being sent to you, come in

00:51:32.130 --> 00:51:39.170
the same way and apply to the same data. And
what that--yeah, I wonder which way I should

00:51:39.170 --> 00:51:46.489
describe this. And as the data mutates events
pop out and this event stream propagates up

00:51:46.489 --> 00:51:50.630
through the various layers of obstruction.
So above this data layer, we have a classical

00:51:50.630 --> 00:51:56.880
op-based wavelet and an op-based blip--or
that shouldn't be called blip. This layer

00:51:56.880 --> 00:52:01.479
here takes programmatic mutations and build
ops that describe them and then applies them

00:52:01.479 --> 00:52:08.440
to the data upon which it sits. So, again,
data is only over-mutated by operations and

00:52:08.440 --> 00:52:12.230
not joined here like it was not joined in
the other one. The ops that pop out of here

00:52:12.230 --> 00:52:19.140
are the ops that are sent off to the remote,
remote--it's off to the server to be sent

00:52:19.140 --> 00:52:25.789
out to the other clients. So, again, the data
is only ever operated on by ops, and we have

00:52:25.789 --> 00:52:32.729
ops from local mutations and remote mutations
follow the same code path once they've been

00:52:32.729 --> 00:52:36.430
created. And so the events that pop out of
the data here come up to the op-based wavelet

00:52:36.430 --> 00:52:40.500
and then up to your application model, which
is--so the application model might be the

00:52:40.500 --> 00:52:43.550
conversation model which sits on top of an
op-based wavelet and sort of interprets the

00:52:43.550 --> 00:52:48.589
op-based wavelet's data in a particular way.
And so events that pop out of here might be,

00:52:48.589 --> 00:52:54.119
you know, a new line was added to the conversation
document and that sends in to--oh, a new blip

00:52:54.119 --> 00:53:01.280
was added to the conversation. It's an abstract--abstract
event. So programmatic mutation, you know,

00:53:01.280 --> 00:53:04.749
up in the boot to this thread comes in to
the application model. It transforms into

00:53:04.749 --> 00:53:09.410
something that applies to the wavelet. You
interpret that as a wavelet mutation. Apply

00:53:09.410 --> 00:53:13.579
that to its own data and sends the op off.
If someone else and some other client does

00:53:13.579 --> 00:53:18.780
the same thing the op comes in here, applies
here, then the op-based wavelet and then the

00:53:18.780 --> 00:53:24.019
application model both watched the events
from their trials and you update their own--in

00:53:24.019 --> 00:53:30.420
memory state accordingly. So it actually turns
out to be very important to the building of

00:53:30.420 --> 00:53:34.769
application models. It's just one event stream
up here and all the sort of local state update

00:53:34.769 --> 00:53:40.269
is done in response to those events, so you
only have to write the code once to respond

00:53:40.269 --> 00:53:43.420
to something lacking and you're blip being
added. It's not different whether you added

00:53:43.420 --> 00:53:46.619
a blip or someone else added a blip, it's
just a new blip that was added. There's a

00:53:46.619 --> 00:53:50.210
question.
&gt;&gt; So if you have three instances, how do

00:53:50.210 --> 00:53:55.670
you end op-based condition from two people
actively editing [INDISTINCT] as soon you

00:53:55.670 --> 00:53:59.180
get simultaneous ops coming in?
&gt;&gt; NORTH: So that's resolved by the server.

00:53:59.180 --> 00:54:04.910
So, whenever--every operation that any client
generates is sent to the Wave server for that

00:54:04.910 --> 00:54:10.440
wavelet. They reach the servelet in--they
reach the server in some order. The server

00:54:10.440 --> 00:54:13.549
picks an order. You know, they get there in
some order. Whichever one gets their first,

00:54:13.549 --> 00:54:17.089
goes first, whichever one gets their second,
goes second, and then they come out of the

00:54:17.089 --> 00:54:23.390
server in that order. And so every--everyone
watching sees them in one particular order.

00:54:23.390 --> 00:54:27.489
The two clients who are actually part of the
mutation, it's the operational transform code

00:54:27.489 --> 00:54:32.849
that resolves the fact that they--their local
state mutated at the same time as the servers

00:54:32.849 --> 00:54:36.589
canonical state. The operational transform
code, which I'm not going to go into too much

00:54:36.589 --> 00:54:43.740
detail to, but I can point you to other talks
that do, transforms the operations at both

00:54:43.740 --> 00:54:47.969
ends so that the intent is preserved. So if
you're--someone inserts some texts and someone

00:54:47.969 --> 00:54:51.599
deletes some texts earlier in the document,
you know, the insert location moves back a

00:54:51.599 --> 00:54:55.789
bit in the transform operation. It's the server
that the--it's the operational transform code

00:54:55.789 --> 00:55:00.469
that computes that and resolves it at both
ends.

00:55:00.469 --> 00:55:07.160
&gt;&gt; So that one of your purpose in the diagram
is actually the more ops that's been passed

00:55:07.160 --> 00:55:11.420
through the multiple [INDISTINCT]?
&gt;&gt; NORTH: Yes, yes, yes, so that--yeah, good

00:55:11.420 --> 00:55:15.700
point. So this--they might have been--they
saw that popped out of here, some op was already

00:55:15.700 --> 00:55:19.670
coming in here. It's gone through the concurrency
control stack and being transform against

00:55:19.670 --> 00:55:22.580
this one and will now apply correctly to the
document's state.

00:55:22.580 --> 00:55:32.150
&gt;&gt; So, okay, if we can take this [INDISTINCT]
but I want to pick out the ops that are coming

00:55:32.150 --> 00:55:34.549
over my generation.
&gt;&gt; NORTH: Uh-hmm.

00:55:34.549 --> 00:55:49.759
&gt;&gt; It could be--how do you ensure that it's
not pushed through the [INDISTINCT] after

00:55:49.759 --> 00:55:53.000
it's been handed off to concurrency controls
so the ops that are coming in the other direction

00:55:53.000 --> 00:55:54.279
transform the code right up?
&gt;&gt; NORTH: I'm not sure. So essentially--the--these

00:55:54.279 --> 00:55:57.170
arrows--ignoring the remote op arrow, these
arrows are synchronous. So, this whole flow

00:55:57.170 --> 00:56:03.299
happens every time you push a key. And so
it's a--including the things enough to transform.

00:56:03.299 --> 00:56:05.327
&gt;&gt; So you really don't have to worry about
concurrency?

00:56:05.327 --> 00:56:08.859
&gt;&gt; NORTH: So, this is not--it's not concurrent
in the multi-threaded sense inside any one

00:56:08.859 --> 00:56:11.920
client, so you don't have to worry about it
too much. The CC stack.

00:56:11.920 --> 00:56:14.709
&gt;&gt; So I only have to worry about one op as
I'm passing through this [INDISTINCT].

00:56:14.709 --> 00:56:25.640
&gt;&gt; NORTH: Yes, that's right. Apparently, the
next one is my last slide--oh, that's right.

00:56:25.640 --> 00:56:31.749
Okay, so building up now the top of our bottom
up talk. This is kind of an overview of the

00:56:31.749 --> 00:56:37.930
whole--the platform and how we think about
the way the wave models supports Wave. So

00:56:37.930 --> 00:56:43.079
the very core here we have--what I've been
describing. The Wave--the data, the core data

00:56:43.079 --> 00:56:47.420
model and the concurrency control and operational
transform that allow it to be live in real

00:56:47.420 --> 00:56:57.550
time. Then on top of that, we have things
like the robot library which sort of interface

00:56:57.550 --> 00:57:01.160
with robots and then various features to the
client, like the editor, which is, you know,

00:57:01.160 --> 00:57:05.859
the way that we let humans interact in real
time with these documents and can embed gadgets

00:57:05.859 --> 00:57:13.450
and so on. So this platform is what we can
build applications on. The platform is built

00:57:13.450 --> 00:57:16.789
up at the core. And then application, the
most well known application or application

00:57:16.789 --> 00:57:21.759
components is, you know, Google Wave or the
Wave in a Box client. But other application

00:57:21.759 --> 00:57:28.400
components can be built on top of this platform.
So attachments and robots, the actual robots

00:57:28.400 --> 00:57:36.819
and so on, use this core to have their own
real time concurrent behavior. Over in the

00:57:36.819 --> 00:57:41.190
client various things we mentioned, we were
supported by waves before so profiles were

00:57:41.190 --> 00:57:44.970
represented in a wave in Google Wave. We haven't,
you know, done that in Wave in a Box yet.

00:57:44.970 --> 00:57:52.390
Settings was a wave, gadget state is stored
in a wave, inside wave documents. The wave

00:57:52.390 --> 00:57:57.109
panel is part of the application for, you
know, rendering a wave to you. And over on

00:57:57.109 --> 00:58:01.650
this side to link and spell your application
components that worked well with conversational

00:58:01.650 --> 00:58:08.559
wavelets.
Yes, question?

00:58:08.559 --> 00:58:15.289
&gt;&gt; What is the measure [INDISTINCT], did the
editor seems to [INDISTINCT] the application?

00:58:15.289 --> 00:58:20.990
&gt;&gt; NORTH: Yeah, I guess that's a good arbitrary.
You could build other Wave clients but you'd

00:58:20.990 --> 00:58:27.260
still want the editor. Although, I guess it
depends on what platform you're building in,

00:58:27.260 --> 00:58:31.140
that is somewhat arbitrary. We think of it
a reasonable component. It's self-contained,

00:58:31.140 --> 00:58:33.869
you could--you could stick the editor and
all the non-Wave applications and it's good

00:58:33.869 --> 00:58:39.009
for that too. Of course, that's why we think
of it as part of the platform.

00:58:39.009 --> 00:58:54.332
&gt;&gt; Is the editor granular enough that if I
was checking and I want to go back [INDISTINCT]

00:58:54.332 --> 00:58:55.332
the editor just to edit and check the annotation
[INDISTINCT].

00:58:55.332 --> 00:58:56.569
&gt;&gt; NORTH: Excuse me. Yeah, I believe, sir.
I mean, it's probably a bit heavyweight for

00:58:56.569 --> 00:59:07.150
that example but it would be capable of it.
&gt;&gt; [INDISTINCT]

00:59:07.150 --> 00:59:13.180
&gt;&gt; NORTH: Please.
&gt;&gt; [INDISTINCT] So this--this diagram was

00:59:13.180 --> 00:59:18.860
something we drew when we had a bit of a crisis
about how to model certain things.

00:59:18.860 --> 00:59:25.170
&gt;&gt; NORTH: Actuate a little bit in case [INDISTINCT].
&gt;&gt; Okay, if we--it still looks good and they

00:59:25.170 --> 00:59:31.049
supports the point I'd like to make. And so
we found out that the--we've constructing

00:59:31.049 --> 00:59:38.119
the--managing the complexity of all this.
And then that--and then we came up with this

00:59:38.119 --> 00:59:46.880
diagram to--and decided that a good way to
manage the complexity both in terms of sort

00:59:46.880 --> 00:59:55.410
of the understanding and discussing the concepts
and also in terms of implementation was layering.

00:59:55.410 --> 01:00:03.219
And there--so some of the most subtle and
finicky stuff is things to do with operational

01:00:03.219 --> 01:00:17.569
transformation and the CC, Concurrency Control
logic, and so we wanted to not let application

01:00:17.569 --> 01:00:24.829
stuff sort of seep in there. So we've spent--since
we drew this diagram two years ago, we spent

01:00:24.829 --> 01:00:30.529
all that time trying to take things out of
the core and simplifying it, removing operations

01:00:30.529 --> 01:00:40.400
and the--and the--so the--simplify the API
down here. And so the reason why I bring it

01:00:40.400 --> 01:00:45.619
up was that both of them--this is a part of
the story of this diagram that's we found

01:00:45.619 --> 01:00:53.920
was a useful lesson we learned but also to
understand them. When we discuss on the--there've

01:00:53.920 --> 01:00:56.999
been discussions on the main list, and I hope
we'll have a lot of discussions this week

01:00:56.999 --> 01:01:04.469
about what we can do with Wave and what we
should add and what we should change, that

01:01:04.469 --> 01:01:10.059
we are--what we learned is that you should
not put extra features in here. You should--you

01:01:10.059 --> 01:01:17.869
make sure that these things are simple and
that the--that they support building concepts

01:01:17.869 --> 01:01:25.829
and applications on top of them. So, it's
a--we're very curious about what the--of what

01:01:25.829 --> 01:01:31.279
we call the core. So, I imagine that that
will come up.

01:01:31.279 --> 01:01:38.979
&gt;&gt; NORTH: Yeah, thank you, [INDISTINCT]. So,
wait--I mean, I'll go, and we've been moderately

01:01:38.979 --> 01:01:44.549
successful as to build a core that supports
many types of application models and allows

01:01:44.549 --> 01:01:48.920
them to take advantage of being real time
and have concurrency result naturally for

01:01:48.920 --> 01:01:55.759
them. And so, yes, some of us feel very strongly
about the simplicity of that core. I'm sure

01:01:55.759 --> 01:02:01.911
that will come out in various discussions.
So that's all I had. Are there more questions

01:02:01.911 --> 01:02:05.999
before I sort of finish? I think we have a
beak next anyway, but are there more questions?

01:02:05.999 --> 01:02:13.720
Okay, looks like my voice is just about held
out. So lets go and have some tea and coffee

01:02:13.720 --> 01:02:15.420
and then chat.
&gt;&gt; We'll have a 10 minute break to grab some

01:02:15.420 --> 01:02:16.420
chocolate or whatever.

01:02:16.420 --> 01:02:16.709
ng real time and have concurrency res

