WEBVTT
Kind: captions
Language: en

00:00:01.560 --> 00:00:02.720
ERIK KUEFLER: Hi, everyone.

00:00:02.720 --> 00:00:03.560
My name is Erik Kuefler.

00:00:03.560 --> 00:00:05.670
I'm going to be talking
today about MVP and

00:00:05.670 --> 00:00:06.680
the EventBus in GWT.

00:00:06.680 --> 00:00:09.750
Let's get started.

00:00:09.750 --> 00:00:12.270
So going into this talk, I'm
going to assume that you're

00:00:12.270 --> 00:00:13.330
all GWT developers.

00:00:13.330 --> 00:00:15.740
You all have some experience
developing GWT.

00:00:15.740 --> 00:00:18.120
And in particular, you've
worked with UI Binder to

00:00:18.120 --> 00:00:20.700
define your static layouts, and
you're familiar with the

00:00:20.700 --> 00:00:23.480
basics of GIN for using
dependency injection.

00:00:23.480 --> 00:00:27.370
I'll rely on both of those
a bit during my slides.

00:00:27.370 --> 00:00:31.160
So if you've done much reading
into best practices in GWT, at

00:00:31.160 --> 00:00:34.240
some point, you've probably come
across Ray Ryan's 2009

00:00:34.240 --> 00:00:36.910
Tech Talk titled "Best Practices
for Architecting

00:00:36.910 --> 00:00:40.960
your GWT Applications." Who
here has seen that?

00:00:40.960 --> 00:00:42.740
So quite a few people.

00:00:42.740 --> 00:00:45.160
In some sense, this Tech Talk
follows onto that and talks

00:00:45.160 --> 00:00:46.490
about some of the
same concepts.

00:00:46.490 --> 00:00:48.630
So if you've seen it, that's
some good background.

00:00:48.630 --> 00:00:51.090
But if not, I'll reintroduce the
same things here, so you

00:00:51.090 --> 00:00:52.620
shouldn't miss anything.

00:00:52.620 --> 00:00:54.410
So here are some questions I'm
going to answer with this

00:00:54.410 --> 00:00:55.660
presentation.

00:00:55.660 --> 00:00:58.230
I'm going to talk basically
about what MVP is, why it's

00:00:58.230 --> 00:01:00.750
useful, and some strategies
for implementing it.

00:01:00.750 --> 00:01:03.470
And importantly, I'm going to
also talk about when you

00:01:03.470 --> 00:01:05.190
should avoid MVP and stick with

00:01:05.190 --> 00:01:07.190
something simpler instead.

00:01:07.190 --> 00:01:09.260
Once I go through that, I'm
going to talk about combining

00:01:09.260 --> 00:01:11.150
a lot of these components
together and getting them

00:01:11.150 --> 00:01:12.420
communicating in a maintainable

00:01:12.420 --> 00:01:15.310
way using the EventBus.

00:01:15.310 --> 00:01:17.120
As for who I am, I'm currently
a software

00:01:17.120 --> 00:01:18.710
engineer on Google Wallet.

00:01:18.710 --> 00:01:21.540
I've been working with GWT
applications for about the

00:01:21.540 --> 00:01:25.150
past four years across five or
six large GWT applications.

00:01:25.150 --> 00:01:28.240
So I've had a little bit of a
chance to see how my own bad

00:01:28.240 --> 00:01:31.180
architectural decisions can
pile up and some chance to

00:01:31.180 --> 00:01:32.800
figure out how to
do things right.

00:01:32.800 --> 00:01:34.940
But I'm not affiliated with
the GWT team, I'm just

00:01:34.940 --> 00:01:37.770
presenting it here.

00:01:37.770 --> 00:01:40.190
So before we start, I want
to define what our goals

00:01:40.190 --> 00:01:42.430
in doing this are.

00:01:42.430 --> 00:01:44.620
In defining the architecture for
our application, we really

00:01:44.620 --> 00:01:46.880
have two things we're trying
to accomplish.

00:01:46.880 --> 00:01:50.320
The first is testability, which
is a very broad topic.

00:01:50.320 --> 00:01:51.700
And here, I'm going to use
a pretty restrictive

00:01:51.700 --> 00:01:53.180
definition for it.

00:01:53.180 --> 00:01:56.800
I'm going to say that your GWT
application is testable if

00:01:56.800 --> 00:01:59.580
almost the entirety of the
business logic that's specific

00:01:59.580 --> 00:02:03.530
to your application can be
tested using plain Java JVM

00:02:03.530 --> 00:02:05.040
test cases.

00:02:05.040 --> 00:02:07.120
The alternative to this, as
you're probably aware, is to

00:02:07.120 --> 00:02:08.789
use GWT test case.

00:02:08.789 --> 00:02:11.970
And those are a lot more
heavyweight and more complex.

00:02:11.970 --> 00:02:14.550
They actually compile your
application down to JavaScript

00:02:14.550 --> 00:02:16.510
and run them in a
fake browser.

00:02:16.510 --> 00:02:19.230
So this is great when you're
testing actual UI flows and

00:02:19.230 --> 00:02:20.190
things like widgets.

00:02:20.190 --> 00:02:23.070
But when you're just testing
pure business logic, it's

00:02:23.070 --> 00:02:25.440
overkill, because those
tests run an order

00:02:25.440 --> 00:02:26.840
of magnitude slower.

00:02:26.840 --> 00:02:28.080
And you don't have
nice tools like

00:02:28.080 --> 00:02:30.160
mocking frameworks available.

00:02:30.160 --> 00:02:32.540
So as much as possible, we want
to make the interesting

00:02:32.540 --> 00:02:34.590
parts of our application
testable just

00:02:34.590 --> 00:02:37.110
as normal Java code.

00:02:37.110 --> 00:02:39.610
Our second objective here,
equally as important, is

00:02:39.610 --> 00:02:40.990
maintainability.

00:02:40.990 --> 00:02:43.820
And this is also, of course,
a very broad topic.

00:02:43.820 --> 00:02:46.310
Here, I'm going to define
maintainability with a simple

00:02:46.310 --> 00:02:49.520
definition saying that your
application is maintainable if

00:02:49.520 --> 00:02:53.520
making simple changes to it is
really easy and making more

00:02:53.520 --> 00:02:55.620
complex changes is possible.

00:02:55.620 --> 00:02:58.890
So in contrast, in an
unmaintainable application, I

00:02:58.890 --> 00:03:00.870
might describe to you something
really simple using

00:03:00.870 --> 00:03:02.340
just a few lines of English.

00:03:02.340 --> 00:03:04.790
And it might take you 100
lines of code across 10

00:03:04.790 --> 00:03:06.360
different files to
implement that.

00:03:06.360 --> 00:03:07.650
If that's your case, you've
probably got a

00:03:07.650 --> 00:03:09.500
maintainability problem.

00:03:09.500 --> 00:03:11.870
So we want to make our
application testable while

00:03:11.870 --> 00:03:15.560
still keeping it easy
to work with.

00:03:15.560 --> 00:03:17.650
How do we accomplish this?

00:03:17.650 --> 00:03:20.190
The standard pattern that's
common in the GWT community is

00:03:20.190 --> 00:03:22.350
MVP, Model-View-Presenter.

00:03:22.350 --> 00:03:26.170
Let's define what
exactly that is.

00:03:26.170 --> 00:03:28.120
MVP is a really straightforward
pattern.

00:03:28.120 --> 00:03:30.320
It just involves breaking your
application up into three

00:03:30.320 --> 00:03:31.360
separate components--

00:03:31.360 --> 00:03:33.740
the Model, the View,
and the Presenter.

00:03:33.740 --> 00:03:36.080
So at the bottom, you have your
model, which contains all

00:03:36.080 --> 00:03:38.570
the state of your application,
everything it actually knows

00:03:38.570 --> 00:03:39.680
about the user.

00:03:39.680 --> 00:03:42.520
And then at the top, you have
the View, which is responsible

00:03:42.520 --> 00:03:46.980
for actually displaying that
state, converting it into DOM

00:03:46.980 --> 00:03:50.220
browser widgets, and presenting
it to the user.

00:03:50.220 --> 00:03:52.070
And then in the middle, you
have probably the most

00:03:52.070 --> 00:03:54.070
interesting component, which
is the Presenter, which is

00:03:54.070 --> 00:03:57.370
responsible for all the
interesting business logic of

00:03:57.370 --> 00:04:00.960
your application, everything
that is actually tricky and

00:04:00.960 --> 00:04:03.940
the kinds of stuff
we want to test.

00:04:03.940 --> 00:04:05.960
And the motivation for breaking
things up like this

00:04:05.960 --> 00:04:10.610
in MVP when we're using GWT is
that the View tends to contain

00:04:10.610 --> 00:04:14.020
a lot of code that we don't
really want to deal with as

00:04:14.020 --> 00:04:15.880
much that's a lot
harder to test.

00:04:15.880 --> 00:04:19.089
That's for stuff where you have
to work with the DOM, you

00:04:19.089 --> 00:04:22.240
have to run JavaScript, you
have to deal with widgets.

00:04:22.240 --> 00:04:25.240
So if you factor this out into
its own class separate from

00:04:25.240 --> 00:04:28.170
your Presenter, that means that
in your tests, you can

00:04:28.170 --> 00:04:31.430
take out this View, replace it
with a super fast mock View,

00:04:31.430 --> 00:04:33.190
and then you can write
pure Java test just

00:04:33.190 --> 00:04:36.160
against your Presenter.

00:04:36.160 --> 00:04:37.310
And that all works
pretty well.

00:04:37.310 --> 00:04:40.200
That's pretty much all there is
to the MVP pattern itself.

00:04:40.200 --> 00:04:42.480
So let's talk a little bit
about how you actually go

00:04:42.480 --> 00:04:45.380
about implementing this.

00:04:45.380 --> 00:04:47.950
So first of all, it turns out
that the model here isn't all

00:04:47.950 --> 00:04:49.430
that interesting.

00:04:49.430 --> 00:04:52.440
Usually, the model is just a
fairly straightforward Java

00:04:52.440 --> 00:04:55.150
value object that maybe have
some observers on it.

00:04:55.150 --> 00:04:57.130
In some simple stateless
applications, you don't need a

00:04:57.130 --> 00:04:58.260
model at all.

00:04:58.260 --> 00:05:00.370
So I'm not going to talk
too much about it.

00:05:00.370 --> 00:05:02.970
I'm really going to focus on
describing how to implement

00:05:02.970 --> 00:05:06.330
the View and the Presenter
and how those work.

00:05:06.330 --> 00:05:08.170
And the key question when you're
talking about this is

00:05:08.170 --> 00:05:10.910
really, how much of my code goes
in the View, and how much

00:05:10.910 --> 00:05:12.910
goes into the Presenter?

00:05:12.910 --> 00:05:15.240
Do I keep a lot of interesting
logic in the View, or do I try

00:05:15.240 --> 00:05:17.300
to keep it as lightweight
as possible?

00:05:17.300 --> 00:05:19.620
And you can fall in different
places along this spectrum.

00:05:19.620 --> 00:05:21.775
Let's talk about each of them
real quickly before I go into

00:05:21.775 --> 00:05:23.025
some heavier code samples.

00:05:25.730 --> 00:05:28.700
So your first option is to
define a fairly rich View that

00:05:28.700 --> 00:05:30.940
has a lot of code inside it.

00:05:30.940 --> 00:05:33.450
So if you're following this
definition, you might think of

00:05:33.450 --> 00:05:35.750
the View as a component that
contains all of my

00:05:35.750 --> 00:05:38.300
application's display logic.

00:05:38.300 --> 00:05:40.240
If you're following this
philosophy, you probably end

00:05:40.240 --> 00:05:42.320
up with methods in your View
that looks something like what

00:05:42.320 --> 00:05:44.190
you have over here
on the right.

00:05:44.190 --> 00:05:46.720
You have a big monolithic
method in your View.

00:05:46.720 --> 00:05:49.710
It takes a contact object.

00:05:49.710 --> 00:05:53.600
So here we're creating some
sort of address book.

00:05:53.600 --> 00:05:55.450
It goes through, it
takes out contact.

00:05:55.450 --> 00:05:57.890
It does the work of converting
it into labels and sticking

00:05:57.890 --> 00:06:00.060
them into the UI somehow.

00:06:00.060 --> 00:06:00.860
And this is nice.

00:06:00.860 --> 00:06:03.590
The advantage here is, as we
described for MVP, you've

00:06:03.590 --> 00:06:06.050
separated all this DOM code
out into your View.

00:06:06.050 --> 00:06:07.970
You don't need to deal with
it from your Presenter.

00:06:07.970 --> 00:06:09.930
It's encapsulated
for your tests.

00:06:09.930 --> 00:06:13.340
But there are some downsides
to doing it this way.

00:06:13.340 --> 00:06:16.410
The first big downside is that
I described here the View as

00:06:16.410 --> 00:06:18.290
being a component that
encapsulates all of your

00:06:18.290 --> 00:06:19.560
display logic.

00:06:19.560 --> 00:06:22.820
But I haven't really described
what display logic is.

00:06:22.820 --> 00:06:24.600
And that's because it's
pretty vague.

00:06:24.600 --> 00:06:26.830
The kind of things we're doing
here-- concatenating names

00:06:26.830 --> 00:06:29.730
together, iterating over
phone numbers--

00:06:29.730 --> 00:06:32.050
it's related to what we display
to the user, but

00:06:32.050 --> 00:06:33.710
there's also interesting
business logic there

00:06:33.710 --> 00:06:34.960
we'd like to test.

00:06:37.080 --> 00:06:39.580
Whether it goes into the View or
the Presenter ends up being

00:06:39.580 --> 00:06:42.070
a coin flip.

00:06:42.070 --> 00:06:45.420
The other problem here is that
if you think back two slides

00:06:45.420 --> 00:06:48.900
when we were talking about our
MVP and testing it, we said

00:06:48.900 --> 00:06:52.110
that when we started testing
MVP, when we start testing our

00:06:52.110 --> 00:06:54.220
Presenter, we're going to
throw out this View and

00:06:54.220 --> 00:06:56.780
replace it with a mock
implementation, which means

00:06:56.780 --> 00:06:59.530
that all this code we have here
isn't really going to be

00:06:59.530 --> 00:07:01.040
covered by our fast tests.

00:07:01.040 --> 00:07:04.890
Either we'll write heavyweight
GWT test cases for them, or we

00:07:04.890 --> 00:07:07.440
won't bother testing
them at all.

00:07:07.440 --> 00:07:10.155
Put those two facts together,
and I found that when I used

00:07:10.155 --> 00:07:12.200
to write Views like this, I
would find that I would end up

00:07:12.200 --> 00:07:14.560
defining display logic
as the logic that

00:07:14.560 --> 00:07:16.470
I'm too lazy to test.

00:07:16.470 --> 00:07:19.680
So if I didn't feel like testing
something someday, I'd

00:07:19.680 --> 00:07:21.120
throw it in the View and say,
oh, it's in the View.

00:07:21.120 --> 00:07:21.940
I don't have to test it.

00:07:21.940 --> 00:07:23.280
How convenient.

00:07:23.280 --> 00:07:25.540
And that's obviously not
a great place to be.

00:07:25.540 --> 00:07:28.620
So we want to try to simplify
this a little.

00:07:28.620 --> 00:07:31.440
Last point I want to touch on
this slide here is that it's

00:07:31.440 --> 00:07:34.000
not making very good
use of UI binder.

00:07:34.000 --> 00:07:37.300
When MVP was first introduced,
UI binder wasn't available,

00:07:37.300 --> 00:07:39.960
and we had to build our
interfaces like this in this

00:07:39.960 --> 00:07:43.670
very swing-like, imperative way
where we create labels and

00:07:43.670 --> 00:07:46.230
add them to a bunch
of containers.

00:07:46.230 --> 00:07:49.410
These days, UI binder let's us
do this a lot more simply.

00:07:49.410 --> 00:07:51.530
What we have here is basically
a static layout, and we can

00:07:51.530 --> 00:07:53.450
basically do this in XML.

00:07:53.450 --> 00:07:55.580
So our definition for a View
should really take advantage

00:07:55.580 --> 00:07:56.830
of that technology.

00:07:58.950 --> 00:08:01.240
So let's try simplifying
this a little.

00:08:01.240 --> 00:08:03.860
So let's say rather than
containing this notion of some

00:08:03.860 --> 00:08:06.330
sort of display logic, let's say
that the View is just this

00:08:06.330 --> 00:08:10.520
very thin wrapper around widgets
in a ui.xml file.

00:08:10.520 --> 00:08:12.280
If you're following this
approach, you probably end up

00:08:12.280 --> 00:08:14.140
with a View that looks
something like this.

00:08:14.140 --> 00:08:16.830
Rather than having a single
monolithic method, you end up

00:08:16.830 --> 00:08:19.480
with a bunch of small methods
that are just basically

00:08:19.480 --> 00:08:22.430
pass-throughs to one-liner
widget calls.

00:08:22.430 --> 00:08:26.180
So to set the name, I take a
string, and I pass it as the

00:08:26.180 --> 00:08:27.430
text to the name field--

00:08:27.430 --> 00:08:29.610
really straightforward.

00:08:29.610 --> 00:08:32.140
This has all the advantages of
the richer View that has a lot

00:08:32.140 --> 00:08:35.270
of display logic in that it
keeps the DOM out of your

00:08:35.270 --> 00:08:38.280
Presenter so you can
still test it.

00:08:38.280 --> 00:08:41.030
But also, all that code we had
before gets moved out to your

00:08:41.030 --> 00:08:43.780
Presenter, which means it stays
in the realm of nice,

00:08:43.780 --> 00:08:44.660
clean unit test.

00:08:44.660 --> 00:08:47.180
So this ends up being a lot more
testable, defining your

00:08:47.180 --> 00:08:49.880
Views in a simple way like this
that have as little logic

00:08:49.880 --> 00:08:51.790
as possible.

00:08:51.790 --> 00:08:54.970
The big disadvantage here is
that this can be very tedious

00:08:54.970 --> 00:08:55.980
to maintain.

00:08:55.980 --> 00:08:58.930
So all that code I had on the
previous slide didn't go away.

00:08:58.930 --> 00:09:00.470
It was moved to the Presenter.

00:09:00.470 --> 00:09:02.680
And in its place, I have these

00:09:02.680 --> 00:09:05.280
uninteresting one-line methods.

00:09:05.280 --> 00:09:06.950
In this example, it's
not too bad.

00:09:06.950 --> 00:09:11.690
I only have three widgets and
three methods plus a callback.

00:09:11.690 --> 00:09:14.240
But you can imagine that in an
interesting View, I might end

00:09:14.240 --> 00:09:17.980
up with dozens and dozens of
widgets, each of which would

00:09:17.980 --> 00:09:20.820
have to expose a couple of these
methods, and I wind up

00:09:20.820 --> 00:09:24.230
with hundreds of lines of code
that is just pure boilerplate,

00:09:24.230 --> 00:09:27.610
uninteresting, and a
pain to maintain.

00:09:27.610 --> 00:09:29.540
So in this case, the
View really isn't

00:09:29.540 --> 00:09:31.420
providing much value.

00:09:31.420 --> 00:09:34.820
And what I suggest doing if you
have a rather static View

00:09:34.820 --> 00:09:38.770
like this, is just getting rid
of the View entirely, not

00:09:38.770 --> 00:09:41.850
relying on MVP in this case, and
just building much simpler

00:09:41.850 --> 00:09:44.500
single composites, kind of like
you might have if you'd

00:09:44.500 --> 00:09:47.620
never heard about MVP
in the first place.

00:09:47.620 --> 00:09:49.620
There's a lot of advantages
to doing this.

00:09:49.620 --> 00:09:52.220
And I'll run through some more
code samples, what all three

00:09:52.220 --> 00:09:55.180
of these strategies look
like in just a moment.

00:09:55.180 --> 00:09:57.840
So obviously, there's a huge
advantage in that I just

00:09:57.840 --> 00:10:00.640
deleted a whole slide worth of
code, and things work more or

00:10:00.640 --> 00:10:01.620
less the same.

00:10:01.620 --> 00:10:03.140
There's less boilerplate.

00:10:03.140 --> 00:10:04.760
There's less to write.

00:10:04.760 --> 00:10:07.850
And the fact that you have less
code there means there's

00:10:07.850 --> 00:10:09.970
nowhere for your code
to hide from tests.

00:10:09.970 --> 00:10:12.890
If you only have one single
class, there's no ambiguity

00:10:12.890 --> 00:10:14.510
about what logic goes
in the View and

00:10:14.510 --> 00:10:15.890
what goes in the Presenter.

00:10:15.890 --> 00:10:18.710
It's logic, so it has to go in
the Java file, which means

00:10:18.710 --> 00:10:21.660
that you have no excuse
not to test it fully.

00:10:21.660 --> 00:10:23.830
So for very static Views,
this can be a big

00:10:23.830 --> 00:10:27.250
improvement over using MVP.

00:10:27.250 --> 00:10:30.080
The obvious disadvantage here is
that by getting rid of this

00:10:30.080 --> 00:10:33.700
View, you have lost a layer
of encapsulation.

00:10:33.700 --> 00:10:35.745
If you do have a lot of
interesting DOM logic, if

00:10:35.745 --> 00:10:38.290
you're doing a lot of
interesting manipulation, it

00:10:38.290 --> 00:10:41.350
might be valuable to keep that
View around and stick with it.

00:10:41.350 --> 00:10:43.840
But let's run through some
examples of what all three of

00:10:43.840 --> 00:10:47.170
these strategies look like.

00:10:47.170 --> 00:10:49.790
So first, here's how some code
might look if you're writing

00:10:49.790 --> 00:10:52.250
something using the rich
View strategy.

00:10:52.250 --> 00:10:54.035
So over on the left, you
have your Presenter.

00:10:54.035 --> 00:10:55.460
In the middle, you
have a View.

00:10:55.460 --> 00:10:58.560
And on the right, you
have a UI XML file.

00:10:58.560 --> 00:11:01.050
Here, the interesting
part's highlighted.

00:11:01.050 --> 00:11:04.440
So you see here that actually
most of the interesting logic

00:11:04.440 --> 00:11:07.390
here in this example ends up
falling into the View in the

00:11:07.390 --> 00:11:09.900
middle here.

00:11:09.900 --> 00:11:12.570
And from a maintainability
standpoint, this is fine.

00:11:12.570 --> 00:11:14.762
There's not much duplication.

00:11:14.762 --> 00:11:16.650
I pretty much only have
to write things once.

00:11:16.650 --> 00:11:19.180
But the real problem here is
testability, because you can

00:11:19.180 --> 00:11:23.430
imagine that in our fast Java
unit tests, we're going to

00:11:23.430 --> 00:11:25.440
eliminate this View in the
middle here and just test the

00:11:25.440 --> 00:11:27.390
things over on the left
on the Presenter.

00:11:27.390 --> 00:11:29.060
There's really not much
interesting there to test.

00:11:29.060 --> 00:11:32.160
So we're not getting much
testable value there.

00:11:32.160 --> 00:11:34.910
So we can improve testability by
basically taking that chunk

00:11:34.910 --> 00:11:38.160
in the View and pushing it out
to the Presenter, where it's

00:11:38.160 --> 00:11:40.690
covered by our tests.

00:11:40.690 --> 00:11:43.860
Once we've done that, we've
moved to our much simpler View

00:11:43.860 --> 00:11:46.750
strategy, where the interesting
code is moved over

00:11:46.750 --> 00:11:50.100
to the Presenter, and in its
place in the View are these

00:11:50.100 --> 00:11:53.400
very simple one-liner methods
that I talked about.

00:11:53.400 --> 00:11:55.820
So our interface from the
Presenter into the View,

00:11:55.820 --> 00:11:58.470
rather than having a single
monolithic method, has these,

00:11:58.470 --> 00:12:01.620
in this case, two methods to do
some low-level operations

00:12:01.620 --> 00:12:03.880
into the View.

00:12:03.880 --> 00:12:05.970
And testability-wise,
this is great.

00:12:05.970 --> 00:12:08.030
The stuff that's left in the
View is really boring.

00:12:08.030 --> 00:12:10.270
Even I'd be OK if you didn't
write tests for that.

00:12:10.270 --> 00:12:12.150
All the stuff that's
worth caring about

00:12:12.150 --> 00:12:13.910
is over in the Presenter.

00:12:13.910 --> 00:12:16.480
The real problem here, again,
is maintainability.

00:12:16.480 --> 00:12:20.280
So imagine what you'd have to do
to add a new field to this

00:12:20.280 --> 00:12:22.150
component here.

00:12:22.150 --> 00:12:23.870
You'd first have to go
into your ui.xml

00:12:23.870 --> 00:12:25.210
file and define it.

00:12:25.210 --> 00:12:27.110
You'd then have to define
it again as a UI

00:12:27.110 --> 00:12:28.480
field in your View.

00:12:28.480 --> 00:12:30.170
And then based on all properties
you wanted to

00:12:30.170 --> 00:12:33.020
access to that-- maybe it's
text, maybe it's visibility--

00:12:33.020 --> 00:12:35.380
you'd have to add an extra
method in your View for each

00:12:35.380 --> 00:12:38.140
of those things you
wanted to change.

00:12:38.140 --> 00:12:40.430
Then in your Presenter in the
display interface up here, you

00:12:40.430 --> 00:12:42.440
would have to define those
methods again.

00:12:42.440 --> 00:12:44.750
And then only after you've done
that could you actually

00:12:44.750 --> 00:12:47.000
start writing the business
logic that you wanted to.

00:12:47.000 --> 00:12:49.670
So that's a lot of work to just
do something as simple as

00:12:49.670 --> 00:12:51.400
defining a field.

00:12:51.400 --> 00:12:54.420
So it would be great if we could
just get rid of these

00:12:54.420 --> 00:12:56.650
methods here that are pure
boilerplate and aren't telling

00:12:56.650 --> 00:12:59.450
us anything valuable.

00:12:59.450 --> 00:13:03.460
Once we've done that, we move
to this simple non-MVP

00:13:03.460 --> 00:13:05.250
composite strategy.

00:13:05.250 --> 00:13:07.390
And you see how this
looks here is we

00:13:07.390 --> 00:13:09.650
have a single composite.

00:13:09.650 --> 00:13:12.040
It contains a bunch of UI
fields, like a View.

00:13:12.040 --> 00:13:14.130
But otherwise, it looks
like a Presenter.

00:13:14.130 --> 00:13:16.840
The logic here is basically
the same, only rather than

00:13:16.840 --> 00:13:19.720
making a call against a wrapping
View class, we're

00:13:19.720 --> 00:13:22.810
making a call to a
widgets directly.

00:13:22.810 --> 00:13:25.480
And this is a big improvement
maintainability-wise.

00:13:25.480 --> 00:13:28.400
Now if I want to define a new
field, all I have to do is

00:13:28.400 --> 00:13:31.230
define the UI XML file,
define a UI field, and

00:13:31.230 --> 00:13:32.390
then start using it.

00:13:32.390 --> 00:13:34.480
There's a lot fewer steps.

00:13:34.480 --> 00:13:36.790
And the testability here
is also great, too.

00:13:36.790 --> 00:13:39.280
And I'll talk about exactly how
you can test this soon.

00:13:39.280 --> 00:13:42.180
But the idea is you have
one single class.

00:13:42.180 --> 00:13:43.720
You can cover this
entire thing with

00:13:43.720 --> 00:13:45.280
your Java test cases.

00:13:45.280 --> 00:13:48.890
So your entire logic
is testable easily.

00:13:48.890 --> 00:13:50.880
And you might say, but wait,
the whole point of the View

00:13:50.880 --> 00:13:53.840
was to get these widgets out
of the Presenter, put them

00:13:53.840 --> 00:13:55.210
somewhere else so I don't
have to deal with

00:13:55.210 --> 00:13:57.620
them and their tests.

00:13:57.620 --> 00:14:00.250
And that's true, but it turns
out that testing widgets

00:14:00.250 --> 00:14:04.790
directly from Java Test isn't
that hard anymore.

00:14:04.790 --> 00:14:07.030
It used to be the case that it
was a lot harder to do this,

00:14:07.030 --> 00:14:10.120
but there are tools in place
now that can help you.

00:14:10.120 --> 00:14:13.850
And so the key insight here is
that if I define this View in

00:14:13.850 --> 00:14:17.420
order to mock it out for my
tests, why can't I just define

00:14:17.420 --> 00:14:20.810
mocks for these widgets and
mock them out directly?

00:14:20.810 --> 00:14:22.530
And you can do that now.

00:14:22.530 --> 00:14:24.790
Basically, all you have to do to
make this work is, in your

00:14:24.790 --> 00:14:28.300
set up method, you call this
one disarm method on

00:14:28.300 --> 00:14:29.840
GWTMockUtilities.

00:14:29.840 --> 00:14:32.050
That'll make sure that when
you call [? GWT.create ?]

00:14:32.050 --> 00:14:35.460
in your Java unit tests, rather
than things blowing up,

00:14:35.460 --> 00:14:37.990
it'll just harmlessly
return a null.

00:14:37.990 --> 00:14:40.210
And then when you actually
instantiate your widget,

00:14:40.210 --> 00:14:42.170
there's just this one method
you have to override with a

00:14:42.170 --> 00:14:46.120
NOOP implementation, since
otherwise, it would run

00:14:46.120 --> 00:14:49.070
JavaScript for you, which
would break things.

00:14:49.070 --> 00:14:52.350
So once you've done those two
things, you have your widget

00:14:52.350 --> 00:14:53.380
constructed.

00:14:53.380 --> 00:14:56.460
And it's basically just going to
have nulls in all of its UI

00:14:56.460 --> 00:14:57.760
fields there.

00:14:57.760 --> 00:15:00.380
And since those UI fields are
package private, you can go

00:15:00.380 --> 00:15:02.870
through in your tests and assign
fake implementations to

00:15:02.870 --> 00:15:04.020
all of them.

00:15:04.020 --> 00:15:06.490
So here, I'm just pushing
Mockito mocks in each of my

00:15:06.490 --> 00:15:07.440
fields here.

00:15:07.440 --> 00:15:10.310
You can use your own EasyMock
mocks, roll your own mocks--

00:15:10.310 --> 00:15:12.720
whatever you want.

00:15:12.720 --> 00:15:16.430
And once I've done that, my
tests become really easy.

00:15:16.430 --> 00:15:19.160
So this test looks a lot like
what I'd be writing

00:15:19.160 --> 00:15:20.890
if I was using MVP.

00:15:20.890 --> 00:15:24.760
If I'm testing the set contact
method on this contact object,

00:15:24.760 --> 00:15:27.220
all I do is pass it in
my contact objects--

00:15:27.220 --> 00:15:29.240
first name, Fred, last
name, Smith--

00:15:29.240 --> 00:15:32.630
and then verify that that name
widget was set to the text

00:15:32.630 --> 00:15:34.860
Fred Smith.

00:15:34.860 --> 00:15:37.305
So this is exactly the same
verification I'd make against

00:15:37.305 --> 00:15:40.210
the View, only now I'm making
it against that widget

00:15:40.210 --> 00:15:43.130
directly, which improves my test
coverage, since there's

00:15:43.130 --> 00:15:45.410
nothing in between.

00:15:45.410 --> 00:15:47.800
This is a little bit of work
to set this all up.

00:15:47.800 --> 00:15:51.420
If you want to, today I'm open
sourcing a library called GWT

00:15:51.420 --> 00:15:54.000
Mockito that we're using
internally on a few Google

00:15:54.000 --> 00:15:57.470
teams that helps you clean
this up a little.

00:15:57.470 --> 00:15:59.690
If you're using this, all you
have to do is annotate your

00:15:59.690 --> 00:16:02.330
test with this GWT Mockito
test runner.

00:16:02.330 --> 00:16:04.550
It'll take care of automatically
doing all this

00:16:04.550 --> 00:16:05.890
disarming for you.

00:16:05.890 --> 00:16:09.030
It'll automatically populate all
your UI field with mocks,

00:16:09.030 --> 00:16:11.110
which means that in your tests,
all you have to do is

00:16:11.110 --> 00:16:14.300
instantiate your object and
write your test directly.

00:16:14.300 --> 00:16:15.390
So there's a link here.

00:16:15.390 --> 00:16:17.590
You can check that out if
it looks useful to you.

00:16:17.590 --> 00:16:20.750
But if you undo this out of the
box in GWT, it's not too

00:16:20.750 --> 00:16:23.200
bad, and it improves your
maintainability and

00:16:23.200 --> 00:16:25.350
testability.

00:16:25.350 --> 00:16:27.930
And so that's basically it.

00:16:27.930 --> 00:16:29.610
So that describes how
you can test these

00:16:29.610 --> 00:16:32.100
fairly static Views.

00:16:32.100 --> 00:16:34.280
And I've really been advocating
for this approach

00:16:34.280 --> 00:16:37.740
of when you have a simple static
View, rather than going

00:16:37.740 --> 00:16:41.340
full MVP, you should just do
it much more simply with a

00:16:41.340 --> 00:16:43.020
single composite object.

00:16:43.020 --> 00:16:46.280
And of course, there are
some downsides to that.

00:16:46.280 --> 00:16:48.840
So the big obvious thing, as I
said, that we're missing here

00:16:48.840 --> 00:16:52.610
is that we no longer have this
extra layer encapsulating

00:16:52.610 --> 00:16:54.300
display logic.

00:16:54.300 --> 00:16:56.840
And if you're writing something
really complex, like

00:16:56.840 --> 00:17:00.050
say, a game in HTML5 or
something that does a lot of

00:17:00.050 --> 00:17:02.330
very interesting DOM
manipulation,

00:17:02.330 --> 00:17:03.230
that will hurt you.

00:17:03.230 --> 00:17:04.849
And you probably do want
to keep [? this View ?]

00:17:04.849 --> 00:17:08.030
around to factor
that stuff out.

00:17:08.030 --> 00:17:10.179
But in most of the applications
I've worked with,

00:17:10.179 --> 00:17:13.050
and probably most applications
you guys work with, what we

00:17:13.050 --> 00:17:15.579
have is a fairly static View.

00:17:15.579 --> 00:17:18.920
Maybe we add or remove a few
elements, but we've basically

00:17:18.920 --> 00:17:20.849
just got a form that we're
sticking values into and

00:17:20.849 --> 00:17:22.599
pulling values back out of.

00:17:22.599 --> 00:17:25.760
And in that case, there's really
no extra value gained

00:17:25.760 --> 00:17:28.750
by adding the separate
View layer.

00:17:28.750 --> 00:17:31.770
Another thing we partially give
up is the ability to swap

00:17:31.770 --> 00:17:34.340
out different implementations
of Views for the single

00:17:34.340 --> 00:17:36.030
display interface.

00:17:36.030 --> 00:17:38.440
We still have that a little,
since we can define different

00:17:38.440 --> 00:17:41.600
UI XML files, which let us
move the layout around.

00:17:41.600 --> 00:17:44.100
But we no longer have the
ability to use completely

00:17:44.100 --> 00:17:47.690
separate implementations
of our Views.

00:17:47.690 --> 00:17:50.280
I've found that in practice,
this isn't something comes up

00:17:50.280 --> 00:17:51.280
very often.

00:17:51.280 --> 00:17:53.140
Most of the time, you know
what your View is

00:17:53.140 --> 00:17:53.920
going to look like.

00:17:53.920 --> 00:17:55.750
You have a single implementation
of it.

00:17:55.750 --> 00:17:58.880
So you just do that.

00:17:58.880 --> 00:18:00.900
But those few times where
you do want multiple

00:18:00.900 --> 00:18:03.510
implementations of your Views,
it can, again, make sense to

00:18:03.510 --> 00:18:06.330
fall back to the more
complex strategy.

00:18:06.330 --> 00:18:08.010
The general rule of thumb here,
though, is that you

00:18:08.010 --> 00:18:10.710
should always start with the
simplest thing that works.

00:18:10.710 --> 00:18:13.920
It's never very hard to go back
and factor out an extra

00:18:13.920 --> 00:18:15.500
interface or an extra
class if you

00:18:15.500 --> 00:18:17.140
decide that it's necessary.

00:18:17.140 --> 00:18:19.220
There's not much cost to doing
that, over doing it in the

00:18:19.220 --> 00:18:19.990
first place.

00:18:19.990 --> 00:18:22.410
But by avoiding it until you
need it, you save yourself a

00:18:22.410 --> 00:18:23.940
whole lot of work
in the meantime.

00:18:23.940 --> 00:18:25.890
That's how I generally tend
to approach these things.

00:18:28.880 --> 00:18:32.210
So that's about it for MVP and
how you implement the MVP

00:18:32.210 --> 00:18:34.080
pattern and its alternatives
and when

00:18:34.080 --> 00:18:35.720
you should and shouldn't.

00:18:35.720 --> 00:18:38.580
The real interesting question
comes in, though, when you

00:18:38.580 --> 00:18:41.205
start getting multiples of these
components together and

00:18:41.205 --> 00:18:43.550
having each of them talk to each
other, because I'm sure

00:18:43.550 --> 00:18:46.290
you've all experienced code
where you have no discipline

00:18:46.290 --> 00:18:47.300
in what talks to what.

00:18:47.300 --> 00:18:49.120
You wind up with a big nest
of spaghetti code where

00:18:49.120 --> 00:18:51.480
everything is completely
dependent on everything, and

00:18:51.480 --> 00:18:53.360
you can't make changes without
breaking your entire

00:18:53.360 --> 00:18:54.510
application.

00:18:54.510 --> 00:18:56.010
So that's what we really
want to avoid here.

00:18:58.830 --> 00:19:01.040
So when you first start thinking
about hierarchically

00:19:01.040 --> 00:19:03.430
decomposing your application,
the thing you're naturally

00:19:03.430 --> 00:19:06.590
going to go to is some sort
of tree structure.

00:19:06.590 --> 00:19:09.640
And so if you're implementing a
Gmail-like application over

00:19:09.640 --> 00:19:14.360
here, you have some roots, body
element that contains a

00:19:14.360 --> 00:19:17.170
big mailbox in the center and
maybe a bar along the top and

00:19:17.170 --> 00:19:19.730
the bottom and so on.

00:19:19.730 --> 00:19:22.050
Each of those elements contains
their children.

00:19:22.050 --> 00:19:23.620
And this works great,
visually.

00:19:23.620 --> 00:19:26.570
It's a close mirror to the DOM
and how the DOM works and

00:19:26.570 --> 00:19:29.000
having these elements all
contain one another.

00:19:29.000 --> 00:19:31.340
And for defining the visual
layout of your application,

00:19:31.340 --> 00:19:33.020
this is a really natural
thing to do.

00:19:33.020 --> 00:19:34.210
There's not much to say here.

00:19:34.210 --> 00:19:36.320
It just works.

00:19:36.320 --> 00:19:38.840
The real problem comes in,
though, is when you start

00:19:38.840 --> 00:19:41.510
using this structure to also
define the communication

00:19:41.510 --> 00:19:42.830
between the different
components in your

00:19:42.830 --> 00:19:44.300
application.

00:19:44.300 --> 00:19:46.340
So let's give an example
of that.

00:19:46.340 --> 00:19:48.720
So let's say you've written
this Gmail application.

00:19:48.720 --> 00:19:49.380
It's all good.

00:19:49.380 --> 00:19:50.550
You're about to ship it.

00:19:50.550 --> 00:19:52.770
And then, at the last moment,
your product manager comes and

00:19:52.770 --> 00:19:55.280
says, oh, I need one
tiny new feature.

00:19:55.280 --> 00:19:57.640
I need, when you click on one
of the messages, I need to

00:19:57.640 --> 00:19:59.620
show a spinner over in the top
bar while we wait for that

00:19:59.620 --> 00:20:00.740
message to load.

00:20:00.740 --> 00:20:02.240
And you say, sure, no problem.

00:20:02.240 --> 00:20:03.910
That sounds easy enough.

00:20:03.910 --> 00:20:06.350
But then when you look at this
tree here, you try to decide

00:20:06.350 --> 00:20:08.190
how should you do that.

00:20:08.190 --> 00:20:10.870
And the fundamental problem here
is that you're trying to

00:20:10.870 --> 00:20:14.650
pass a message from one leaf
node in your tree to a leaf

00:20:14.650 --> 00:20:19.380
node somewhere way off
on another branch.

00:20:19.380 --> 00:20:21.690
Your first thought about how to
do that is, OK, maybe I'll

00:20:21.690 --> 00:20:25.160
just inject this buttons bar
over into the message and have

00:20:25.160 --> 00:20:27.360
it call a method directly.

00:20:27.360 --> 00:20:29.410
That'll work for your immediate
solution, but if you

00:20:29.410 --> 00:20:32.230
keep following that approach,
you quickly wind up with

00:20:32.230 --> 00:20:34.810
everyone's injected to everyone,
everyone talks to

00:20:34.810 --> 00:20:37.130
everyone, and you can't make
a change everywhere without

00:20:37.130 --> 00:20:40.390
pulling apart your entire
application.

00:20:40.390 --> 00:20:42.330
So you do want to try to
maintain this tree structure

00:20:42.330 --> 00:20:45.140
and not just inject everything
everywhere.

00:20:45.140 --> 00:20:47.070
So if you're doing that, what
you end up deciding you have

00:20:47.070 --> 00:20:50.740
to do is do this traversal of
the tree, where the message

00:20:50.740 --> 00:20:54.060
calls into some call back on the
mailbox, the mailbox calls

00:20:54.060 --> 00:20:57.060
into some call back on the root,
it calls some method

00:20:57.060 --> 00:20:59.010
into the top bar, which then
calls a method down to the

00:20:59.010 --> 00:21:00.730
spinner to show it.

00:21:00.730 --> 00:21:03.040
And this is really even worse
than just doing the direct

00:21:03.040 --> 00:21:07.020
injection, because now this one
line, very simple thing I

00:21:07.020 --> 00:21:10.550
told you to implement, requires
you to touch five

00:21:10.550 --> 00:21:12.890
different classes, probably
write two dozen lines of

00:21:12.890 --> 00:21:14.310
callback code.

00:21:14.310 --> 00:21:17.010
And once you're done, you wind
up with these three classes in

00:21:17.010 --> 00:21:19.300
the middle here knowing about
this interaction that they

00:21:19.300 --> 00:21:20.920
shouldn't actually know
anything about at all.

00:21:20.920 --> 00:21:22.940
It doesn't concern them.

00:21:22.940 --> 00:21:25.540
If you follow this approach, you
wind up with the root node

00:21:25.540 --> 00:21:27.860
here knowing about absolutely
everything that happens in

00:21:27.860 --> 00:21:28.710
your application.

00:21:28.710 --> 00:21:33.120
And it's just this one big god
class that does everything.

00:21:33.120 --> 00:21:34.970
So what we really want to be
able to do is have these

00:21:34.970 --> 00:21:38.820
components talk more or less
directly to each other without

00:21:38.820 --> 00:21:42.120
actually knowing about one
another, which sounds like a

00:21:42.120 --> 00:21:43.930
paradox, but that's what
the EventBus is

00:21:43.930 --> 00:21:46.640
going to help resolve.

00:21:46.640 --> 00:21:48.960
So what's the EventBus?

00:21:48.960 --> 00:21:50.950
The EventBus is a pretty
simple concept.

00:21:50.950 --> 00:21:53.570
It's this global static
singleton object that's

00:21:53.570 --> 00:21:55.790
injected into each of
your Presenters.

00:21:55.790 --> 00:21:58.390
And then rather than the
Presenter sending messages to

00:21:58.390 --> 00:22:01.740
each other, they all send
messages to that EventBus, and

00:22:01.740 --> 00:22:04.150
the EventBus is then responsible
for dispatching it

00:22:04.150 --> 00:22:07.180
out to the Presenters that
are interested in them.

00:22:07.180 --> 00:22:10.400
So when you're using this
concept, the goal is to really

00:22:10.400 --> 00:22:13.600
decouple the visual hierarchy of
your application from your

00:22:13.600 --> 00:22:15.510
communication model.

00:22:15.510 --> 00:22:19.050
So visually, you have these UI
components that all visually

00:22:19.050 --> 00:22:22.070
contain each other, have their
logic off to the side that

00:22:22.070 --> 00:22:23.920
just drives the UI but
doesn't otherwise

00:22:23.920 --> 00:22:25.250
know about each other.

00:22:25.250 --> 00:22:27.450
But communication-wise, you have
something that looks a

00:22:27.450 --> 00:22:30.840
lot more like a star or a wheel,
where at the hub, you

00:22:30.840 --> 00:22:33.490
have this EventBus, which is
responsible for passing

00:22:33.490 --> 00:22:35.430
messages back and forth.

00:22:35.430 --> 00:22:38.110
And then along the spokes, you
have these Presenters, which

00:22:38.110 --> 00:22:40.340
take those messages and
percolate them out to the View

00:22:40.340 --> 00:22:42.830
as needed, or take clicks
from the View and

00:22:42.830 --> 00:22:45.320
fire them as messages.

00:22:45.320 --> 00:22:47.380
Point being here, these
Presenters are all on the

00:22:47.380 --> 00:22:49.270
spokes completely isolated
from each other.

00:22:49.270 --> 00:22:51.610
So they don't know anything
about one another.

00:22:51.610 --> 00:22:54.030
And the reason we do this
is maintainability.

00:22:54.030 --> 00:22:56.380
When the Presenters don't know
anything about one another, it

00:22:56.380 --> 00:23:00.480
makes it very easy to add or
modify or remove code without

00:23:00.480 --> 00:23:02.110
touching other code.

00:23:02.110 --> 00:23:04.230
So here if I decide I don't need
this guy on the bottom

00:23:04.230 --> 00:23:07.590
anymore, I just rip out that
spoke, and everything works

00:23:07.590 --> 00:23:08.450
exactly the same.

00:23:08.450 --> 00:23:10.490
I don't have to touch any
other code really.

00:23:10.490 --> 00:23:13.060
You could imagine that if I
had everything injecting

00:23:13.060 --> 00:23:15.440
everything, getting rid of that
component would probably

00:23:15.440 --> 00:23:18.370
require a day's work of going
down and deleting

00:23:18.370 --> 00:23:20.170
references to it.

00:23:20.170 --> 00:23:21.020
But here, it's easy.

00:23:21.020 --> 00:23:23.010
There's no the changes
I have to make.

00:23:23.010 --> 00:23:24.910
So let's zoom in on the
center here to see

00:23:24.910 --> 00:23:28.500
exactly how this works.

00:23:28.500 --> 00:23:31.270
Like I said, the EventBus is the
singleton component that

00:23:31.270 --> 00:23:33.100
is injected into each
of your Presenters.

00:23:33.100 --> 00:23:36.210
When your application starts,
or when the Presenter is

00:23:36.210 --> 00:23:39.500
loaded, they go through and tell
the EventBus what events

00:23:39.500 --> 00:23:42.070
they are interested in, where
an event is just something

00:23:42.070 --> 00:23:44.410
that happens in your
application.

00:23:44.410 --> 00:23:47.025
So here, I have a Presenter
for my chat screen, a

00:23:47.025 --> 00:23:49.380
Presenter for my Compose window,
and they're each going

00:23:49.380 --> 00:23:52.910
to tell the EventBus, OK, I'm
interested in when a contact

00:23:52.910 --> 00:23:56.140
gets added, because I need to
add that to my UI somehow.

00:23:56.140 --> 00:23:58.400
Then the Presenter is going to
say, OK, I'm also interested

00:23:58.400 --> 00:23:59.810
in when the Compose button
gets clicked,

00:23:59.810 --> 00:24:01.620
so I can show myself.

00:24:01.620 --> 00:24:04.480
They have no idea what's
actually going to fire those

00:24:04.480 --> 00:24:06.770
events, but they've told the
EventBus that when they are

00:24:06.770 --> 00:24:09.190
fired, let me know.

00:24:09.190 --> 00:24:11.070
Then you have a third Presenter
come in, your

00:24:11.070 --> 00:24:14.370
contact Presenter here, where
your user actually goes

00:24:14.370 --> 00:24:17.810
through and adds
these contacts.

00:24:17.810 --> 00:24:21.280
And when the user does that,
it sends a message to the

00:24:21.280 --> 00:24:23.660
EventBus saying, OK,
fire this event.

00:24:23.660 --> 00:24:26.400
The EventBus looks up who's
interested, and it dispatches

00:24:26.400 --> 00:24:28.490
it out to each of those
components and lets them do

00:24:28.490 --> 00:24:31.170
what they want with them.

00:24:31.170 --> 00:24:33.210
That's pretty straightforward.

00:24:33.210 --> 00:24:35.450
How does this actually work?

00:24:35.450 --> 00:24:38.020
When people first hear about
this, they tend to think this

00:24:38.020 --> 00:24:41.260
is some sort of complex object
that is doing some sort of

00:24:41.260 --> 00:24:44.580
asynchronous magical dispatch
of these events, but it's

00:24:44.580 --> 00:24:45.490
really very simple.

00:24:45.490 --> 00:24:47.590
And I can pretty much implement
an entire EventBus

00:24:47.590 --> 00:24:49.360
on a slide here.

00:24:49.360 --> 00:24:52.540
So the heart of the EventBus is
really this map from events

00:24:52.540 --> 00:24:54.820
to lists of event handlers.

00:24:54.820 --> 00:24:57.310
Registering an event handler
just involves adding a new

00:24:57.310 --> 00:24:59.670
entry to that list for the
appropriate event.

00:24:59.670 --> 00:25:02.140
And firing an event just
involves looking up that list

00:25:02.140 --> 00:25:04.780
of handlers, iterating
over it, and calling

00:25:04.780 --> 00:25:06.330
each of them in turn.

00:25:06.330 --> 00:25:09.120
So that's what you should think
of an event firing as,

00:25:09.120 --> 00:25:11.030
as just calling a bunch
of methods in a loop.

00:25:11.030 --> 00:25:13.230
It's really straightforward.

00:25:13.230 --> 00:25:16.440
GWT, of course, defines a
built-in EventBus that is much

00:25:16.440 --> 00:25:17.540
more full featured than this.

00:25:17.540 --> 00:25:19.490
It does nice things like
error handling.

00:25:19.490 --> 00:25:21.770
But if you use this as your
mental model, it'll get you

00:25:21.770 --> 00:25:25.880
through 95% of cases.

00:25:25.880 --> 00:25:27.980
How do you actually use it
in your application?

00:25:27.980 --> 00:25:31.290
There's basically three steps
you have to follow.

00:25:31.290 --> 00:25:33.800
First, you define your events.

00:25:33.800 --> 00:25:35.800
Out of the box, this is actually
a little surprisingly

00:25:35.800 --> 00:25:37.090
verbose in GWT.

00:25:37.090 --> 00:25:40.640
You have to extend GWT event
with a class that overrides

00:25:40.640 --> 00:25:42.930
this dispatch and get
type methods.

00:25:42.930 --> 00:25:45.360
And then you have to define an
interface as a handler for

00:25:45.360 --> 00:25:46.020
that event.

00:25:46.020 --> 00:25:48.115
I'm not going to go into details
of that there, but

00:25:48.115 --> 00:25:50.350
it's on the slide.

00:25:50.350 --> 00:25:52.580
Another library I'm releasing
today that we've been using

00:25:52.580 --> 00:25:55.200
internally inside Google is
called EventBinder, which

00:25:55.200 --> 00:25:57.420
helps you clean up a lot of
the boilerplates around

00:25:57.420 --> 00:25:59.420
dealing with an EventBus.

00:25:59.420 --> 00:26:01.030
So if you're using EventBinder,
you're basically

00:26:01.030 --> 00:26:04.690
just defining your contact
loaded event here as normal

00:26:04.690 --> 00:26:07.670
immutable Java value type.

00:26:07.670 --> 00:26:10.060
In a common case where your
event doesn't have any

00:26:10.060 --> 00:26:12.480
arguments associated with it,
this just becomes a one line

00:26:12.480 --> 00:26:14.070
definition here.

00:26:14.070 --> 00:26:16.170
When you have the slightly more
interesting case, when

00:26:16.170 --> 00:26:18.480
you're carrying parameters,
you've basically just got a

00:26:18.480 --> 00:26:22.400
value object that looks
something like this.

00:26:22.400 --> 00:26:25.730
Your next step is to actually
register handlers for those

00:26:25.730 --> 00:26:28.650
events to say who's interested
in hearing them.

00:26:28.650 --> 00:26:30.950
Again, out of the box in GWT,
there's a little bit of work

00:26:30.950 --> 00:26:33.950
you have to do, in you
invoke this EventBus.

00:26:33.950 --> 00:26:38.570
You pass in these anonymous
handler instances that either

00:26:38.570 --> 00:26:42.020
do work or call out to
methods that do work.

00:26:42.020 --> 00:26:44.385
It's not too bad, but if you're
using EventBinder, this

00:26:44.385 --> 00:26:46.660
is simplified a bit in that all
you have to do is apply

00:26:46.660 --> 00:26:48.620
this Add Event Handler
annotation to

00:26:48.620 --> 00:26:50.200
each of your methods.

00:26:50.200 --> 00:26:52.960
And this looks a lot
like the UI Handler

00:26:52.960 --> 00:26:54.570
annotation in UIBinder.

00:26:54.570 --> 00:26:56.970
And in fact, it works in much
the same way, where just by

00:26:56.970 --> 00:26:59.660
looking at that first argument
to the method, it decides what

00:26:59.660 --> 00:27:01.350
event it needs to listen to.

00:27:01.350 --> 00:27:03.890
And then you just need to call
one line to bind those in your

00:27:03.890 --> 00:27:05.150
constructor.

00:27:05.150 --> 00:27:09.480
So either way, once you've done
that, you're saying that

00:27:09.480 --> 00:27:12.080
any time a contact loaded event
is fired anywhere in my

00:27:12.080 --> 00:27:15.800
application, invoke this method,
and let me know.

00:27:15.800 --> 00:27:18.440
So link there for EventBinder
is up.

00:27:18.440 --> 00:27:20.180
You can check that out on
GitHub if you want.

00:27:20.180 --> 00:27:22.810
But it's also fine if you bind
these manually, if you want to

00:27:22.810 --> 00:27:24.750
get started.

00:27:24.750 --> 00:27:27.490
And the final step, fortunately,
is really easy no

00:27:27.490 --> 00:27:28.400
matter what you're doing.

00:27:28.400 --> 00:27:30.020
You just have to construct
that event and

00:27:30.020 --> 00:27:31.910
fire it on the EventBus.

00:27:31.910 --> 00:27:33.900
And all you do here is you call
the constructor on the

00:27:33.900 --> 00:27:35.700
event you defined earlier
and pass it to

00:27:35.700 --> 00:27:37.650
this fire event method.

00:27:37.650 --> 00:27:39.840
And then if you think back to
the EventBus implementation we

00:27:39.840 --> 00:27:42.140
talked about earlier, what this
means here is that you

00:27:42.140 --> 00:27:45.850
are just in a loop calling
over all those individual

00:27:45.850 --> 00:27:48.620
event handler methods that
you've defined earlier.

00:27:48.620 --> 00:27:52.370
So basically, when you fire
this event, you don't know

00:27:52.370 --> 00:27:54.640
what methods you're calling,
but the EventBus will take

00:27:54.640 --> 00:27:58.450
care of internally
dispatching that.

00:27:58.450 --> 00:27:59.970
That's pretty much all
there is to it.

00:27:59.970 --> 00:28:02.130
So with the rest of my time
here, I just want to talk

00:28:02.130 --> 00:28:05.690
about a few best practices for
using the EventBus, since if

00:28:05.690 --> 00:28:08.090
you're not disciplined about
how you define your events,

00:28:08.090 --> 00:28:11.140
you definitely can get into this
fairly complex scenario

00:28:11.140 --> 00:28:13.830
where you have a lot of events
going back and forth, and it's

00:28:13.830 --> 00:28:16.150
tough to figure out
what's going on.

00:28:16.150 --> 00:28:19.380
So how should you think
about events?

00:28:19.380 --> 00:28:22.350
Superficially, they can seem
kind of similar to methods, in

00:28:22.350 --> 00:28:25.450
that both an event and a method
are a message that

00:28:25.450 --> 00:28:28.570
sends from one class to another,
possibly carrying

00:28:28.570 --> 00:28:30.180
some number of arguments.

00:28:30.180 --> 00:28:33.110
That's about where the
similarity ends.

00:28:33.110 --> 00:28:35.290
The big difference between
methods and events is that

00:28:35.290 --> 00:28:37.730
when you're dealing with
methods, you have a single

00:28:37.730 --> 00:28:39.010
known receiver.

00:28:39.010 --> 00:28:41.480
You know exactly who you're
calling, what they're going to

00:28:41.480 --> 00:28:44.000
do in response, and you can
expect them to give you some

00:28:44.000 --> 00:28:45.620
value back out.

00:28:45.620 --> 00:28:47.820
Events are totally different
in that when you fire an

00:28:47.820 --> 00:28:51.220
event, you have no idea who's
listening to it, you have no

00:28:51.220 --> 00:28:53.860
idea how many people are
listening to it, and maybe no

00:28:53.860 --> 00:28:55.730
one's even listening
to it at all.

00:28:55.730 --> 00:28:57.410
And as a consequence,
you don't get a

00:28:57.410 --> 00:28:59.010
return value back out.

00:28:59.010 --> 00:29:01.300
You can't trust anything in
particular to happen in

00:29:01.300 --> 00:29:04.090
response to firing an event.

00:29:04.090 --> 00:29:07.370
So how these end up being used
is that you keep using methods

00:29:07.370 --> 00:29:10.030
for the tightly coupled
components of your application

00:29:10.030 --> 00:29:12.080
that really do know a lot
about each other's

00:29:12.080 --> 00:29:15.210
implementation details, say,
a Presenter class and some

00:29:15.210 --> 00:29:18.150
helper that's directly tied
to that Presenter.

00:29:18.150 --> 00:29:20.820
Events, in contrast, are used
for much higher level

00:29:20.820 --> 00:29:23.900
notifications when something big
and major happens in your

00:29:23.900 --> 00:29:27.250
application that a lot of code
might care about, but you

00:29:27.250 --> 00:29:29.900
don't really care from
where it happens,

00:29:29.900 --> 00:29:31.150
what happens in response.

00:29:33.510 --> 00:29:36.920
And really, the important word
I use there is notification.

00:29:36.920 --> 00:29:40.280
You should think of events as
notifications, not commands.

00:29:40.280 --> 00:29:43.450
So in a sense, you can think of
event-driven programming as

00:29:43.450 --> 00:29:45.530
a more polite and collaborative
form of

00:29:45.530 --> 00:29:46.710
programming.

00:29:46.710 --> 00:29:48.730
Rather than having a bunch of
individual components that are

00:29:48.730 --> 00:29:50.820
all ordering each other what
to do, calling methods,

00:29:50.820 --> 00:29:54.210
demanding some particular action
being taken, you have a

00:29:54.210 --> 00:29:56.080
bunch of components that
all raise events.

00:29:56.080 --> 00:29:58.040
Say this interesting
thing happened.

00:29:58.040 --> 00:30:00.760
Maybe you would like to do
something in response to that.

00:30:00.760 --> 00:30:03.130
And structuring your application
that way ends up

00:30:03.130 --> 00:30:07.060
being a lot more maintainable
and easy to plug into.

00:30:07.060 --> 00:30:09.860
You can tell if you're falling
afoul of this rule by looking

00:30:09.860 --> 00:30:11.720
at the names of your events.

00:30:11.720 --> 00:30:15.000
So say a user clicks
the button to

00:30:15.000 --> 00:30:16.950
open the Contact Manager.

00:30:16.950 --> 00:30:19.520
I know I have to load the
contacts from the server.

00:30:19.520 --> 00:30:21.270
There are two ways I
might model this.

00:30:21.270 --> 00:30:24.130
The first would be to fire a
load contact from server

00:30:24.130 --> 00:30:26.470
events, named like that.

00:30:26.470 --> 00:30:28.220
That's not a great idea, because
it's demanding a

00:30:28.220 --> 00:30:29.990
particular action be taken.

00:30:29.990 --> 00:30:32.740
It's not very extensible,
because the only way I could

00:30:32.740 --> 00:30:36.140
respond to an event with that
name is to load the contacts

00:30:36.140 --> 00:30:37.650
from the server.

00:30:37.650 --> 00:30:39.960
Instead, I should fire an event
that represents what

00:30:39.960 --> 00:30:41.710
actually happens, so
in this case, a

00:30:41.710 --> 00:30:43.740
ContactManagerOpened event.

00:30:43.740 --> 00:30:45.650
In that case, I can still
have the server

00:30:45.650 --> 00:30:46.980
listen for that event.

00:30:46.980 --> 00:30:48.750
Say the Contact Manager
was opened, I'd

00:30:48.750 --> 00:30:50.510
better load the contacts.

00:30:50.510 --> 00:30:53.220
Then I could also have the UI
listen for that event and say

00:30:53.220 --> 00:30:54.510
Contact Manager was opened.

00:30:54.510 --> 00:30:56.220
I'd better show my pop up.

00:30:56.220 --> 00:30:58.880
And then a year later, if I
decide I want to add some sort

00:30:58.880 --> 00:31:02.140
of analytics handler, I can
just add a new handler, it

00:31:02.140 --> 00:31:05.420
listens to that event, and I
don't have to touch anything

00:31:05.420 --> 00:31:07.700
to make that work.

00:31:07.700 --> 00:31:12.320
In practice, 99% of the time,
the events in our application

00:31:12.320 --> 00:31:14.150
fall into two categories.

00:31:14.150 --> 00:31:17.400
Either they are user inputs,
responds to a user click in

00:31:17.400 --> 00:31:20.090
some way, or they are responses
coming back from the

00:31:20.090 --> 00:31:22.710
server, some asynchronous
call finished.

00:31:22.710 --> 00:31:25.140
There's no magical reason
this has to be the case.

00:31:25.140 --> 00:31:28.390
It's just the fact that in most
web applications, these

00:31:28.390 --> 00:31:30.800
end up being the major things
that happen, and that's what

00:31:30.800 --> 00:31:32.620
our events tend to represent.

00:31:32.620 --> 00:31:34.850
You can get into some other
instances, like maybe you have

00:31:34.850 --> 00:31:37.194
a postMessage response,
and you fire an event

00:31:37.194 --> 00:31:38.290
as a result of that.

00:31:38.290 --> 00:31:40.390
But those instances are
relatively rare.

00:31:43.110 --> 00:31:43.920
That's pretty much it.

00:31:43.920 --> 00:31:46.400
Let's run through one final
example of all this code put

00:31:46.400 --> 00:31:49.990
together before I move
on to questions.

00:31:49.990 --> 00:31:52.080
So here we see a component
that's using everything we

00:31:52.080 --> 00:31:52.990
talked about.

00:31:52.990 --> 00:31:56.020
It's condensed enough to fit
onto one slide here.

00:31:56.020 --> 00:31:57.730
So there's a few interesting
things to note that

00:31:57.730 --> 00:31:59.610
are going on here.

00:31:59.610 --> 00:32:02.820
The single component has a
fairly static UI, so rather

00:32:02.820 --> 00:32:05.670
than using MVP, I'm just
defining this as one single

00:32:05.670 --> 00:32:07.710
composite class.

00:32:07.710 --> 00:32:08.360
It's a widget.

00:32:08.360 --> 00:32:09.690
It extends composite.

00:32:09.690 --> 00:32:12.410
It has a bunch of UI
fields inside it.

00:32:12.410 --> 00:32:15.070
Here I have a child class, which
is something else I've

00:32:15.070 --> 00:32:18.540
defined in my system, called
InfoCard, which is maybe

00:32:18.540 --> 00:32:21.470
something that pops up when
I hover over a contact.

00:32:21.470 --> 00:32:24.400
In order to implement that, I
am injecting that component

00:32:24.400 --> 00:32:27.340
into my composite and then
assigning it to a field

00:32:27.340 --> 00:32:28.910
declared as a widget.

00:32:28.910 --> 00:32:31.630
The reason I'm assigning it to
a widget field rather than an

00:32:31.630 --> 00:32:34.560
InfoCardComposite field is that
I don't want to do any

00:32:34.560 --> 00:32:36.700
communication with
this guy directly

00:32:36.700 --> 00:32:37.990
once I have it injected.

00:32:37.990 --> 00:32:40.520
I want to take it, stick in
my UI, and then basically

00:32:40.520 --> 00:32:41.770
forget about it.

00:32:43.880 --> 00:32:46.760
Once I've done that, you see
that every other method inside

00:32:46.760 --> 00:32:49.050
this composite here
is either an event

00:32:49.050 --> 00:32:50.880
handler or a UI handler.

00:32:50.880 --> 00:32:53.530
In particular, this thing has
no public methods at all.

00:32:53.530 --> 00:32:57.190
So the only way to communicate
with this guy is by either

00:32:57.190 --> 00:33:00.150
interacting with it via
the UI or by firing

00:33:00.150 --> 00:33:01.920
events on the EventBus.

00:33:01.920 --> 00:33:03.580
And that reflects the two
directions in which

00:33:03.580 --> 00:33:04.950
my events can flow.

00:33:04.950 --> 00:33:07.700
Either we have a user click that
initiates something that

00:33:07.700 --> 00:33:10.390
maybe gets propagated out to the
rest of the system, or we

00:33:10.390 --> 00:33:13.510
have a server call back, which
will fire an event, and

00:33:13.510 --> 00:33:14.900
everyone who cares about
that server call

00:33:14.900 --> 00:33:17.540
will respond to it.

00:33:17.540 --> 00:33:19.380
The fact that you've broken it
up like this also means that

00:33:19.380 --> 00:33:21.410
this thing is very testable.

00:33:21.410 --> 00:33:23.460
Basically, your tests
are all just tests

00:33:23.460 --> 00:33:24.560
of these event handlers.

00:33:24.560 --> 00:33:27.370
So you test says, OK, what
happens when someone clicks

00:33:27.370 --> 00:33:28.300
that picture?

00:33:28.300 --> 00:33:30.900
I click the picture, I
expect to do this.

00:33:30.900 --> 00:33:32.420
What happens when the
contact is loaded?

00:33:32.420 --> 00:33:34.820
I fire a contact loaded
event, and I assert

00:33:34.820 --> 00:33:36.190
what happens in response.

00:33:36.190 --> 00:33:37.990
So maintainable, testable--

00:33:37.990 --> 00:33:41.390
those are the goals we're
trying to accomplish.

00:33:41.390 --> 00:33:45.150
So to summarize here, when
you're dealing with static UIs

00:33:45.150 --> 00:33:48.050
when you have symbol display
logic or none at all, there's

00:33:48.050 --> 00:33:50.500
no reason to go full into MVP.

00:33:50.500 --> 00:33:52.960
You can greatly reduce
boilerplate, improve your test

00:33:52.960 --> 00:33:55.750
coverage with no real loss just
by dealing with single

00:33:55.750 --> 00:33:57.820
simple components.

00:33:57.820 --> 00:34:00.470
Once you're defined your
individual components, via MVP

00:34:00.470 --> 00:34:03.360
or not, you want to use an
EventBus to decouple these and

00:34:03.360 --> 00:34:06.570
make it easier to communicate
between things, add

00:34:06.570 --> 00:34:09.350
components, and remove
components.

00:34:09.350 --> 00:34:11.350
That'll work as long as you
define your events to

00:34:11.350 --> 00:34:14.350
represent notifications,
high-level, broad

00:34:14.350 --> 00:34:18.210
notifications rather than
individual low-level commands.

00:34:18.210 --> 00:34:20.600
And the general philosophy I
want to repeat here again is

00:34:20.600 --> 00:34:23.460
that in general, you're best
off starting with a very

00:34:23.460 --> 00:34:26.230
simple solution, doing the
simplest thing that can work,

00:34:26.230 --> 00:34:30.120
and adding additional complexity
only as needed.

00:34:30.120 --> 00:34:33.480
You end up not having to spend
any extra work adding that

00:34:33.480 --> 00:34:35.860
complexity later than if you
added it up front, and in the

00:34:35.860 --> 00:34:39.070
meanwhile, you get a big benefit
of not having to deal

00:34:39.070 --> 00:34:42.550
with that complexity that
you don't need.

00:34:42.550 --> 00:34:44.219
I can take some questions now.

00:34:44.219 --> 00:34:46.040
Here's a link to both those
libraries that are up here,

00:34:46.040 --> 00:34:49.540
and you could also follow me
on GitHub or on Google+.

00:34:49.540 --> 00:34:52.193
There are microphones up if
anyone wants to ask questions.

00:34:52.193 --> 00:35:00.150
[APPLAUSE]

00:35:00.150 --> 00:35:02.530
AUDIENCE: GWT does a lot of
optimization when it complies

00:35:02.530 --> 00:35:05.120
to JavaScript, like I'm thinking
specifically of

00:35:05.120 --> 00:35:07.120
inlining of method calls.

00:35:07.120 --> 00:35:09.910
And if you use this EventBus
strategy where you basically

00:35:09.910 --> 00:35:13.730
call the methods on some objects
in a list, I would

00:35:13.730 --> 00:35:16.060
imagine that that optimization,
for example, the

00:35:16.060 --> 00:35:18.240
inlining just goes away.

00:35:18.240 --> 00:35:21.160
Is there any way around that,
or how much of that

00:35:21.160 --> 00:35:22.620
optimization would we lose?

00:35:22.620 --> 00:35:26.530
Is that an impact that
you've seen?

00:35:26.530 --> 00:35:27.620
ERIK KUEFLER: Yeah, that's
probably true that you're

00:35:27.620 --> 00:35:29.820
definitely introducing an extra
layer here, which is

00:35:29.820 --> 00:35:32.860
going to make it a little
harder to optimize.

00:35:32.860 --> 00:35:35.540
However, if you're using these
events to represent high-level

00:35:35.540 --> 00:35:40.010
things like user clicks or
server responses, those end up

00:35:40.010 --> 00:35:42.690
being infrequent enough that
the extra level of a

00:35:42.690 --> 00:35:45.040
JavaScript call is completely
irrelevant.

00:35:45.040 --> 00:35:49.110
So if you're using an EventBus
to fire off thousands of

00:35:49.110 --> 00:35:51.770
events every second, you
would definitely

00:35:51.770 --> 00:35:52.670
run into issues there.

00:35:52.670 --> 00:35:54.940
But I think if you're doing
that, you're probably doing

00:35:54.940 --> 00:35:56.020
something wrong.

00:35:56.020 --> 00:35:58.490
So as long as your events are
tied to single, discrete,

00:35:58.490 --> 00:36:02.190
external actions, optimization
on that level just isn't

00:36:02.190 --> 00:36:03.972
something that's
very important.

00:36:03.972 --> 00:36:05.120
AUDIENCE: That makes sense.

00:36:05.120 --> 00:36:07.480
Thanks.

00:36:07.480 --> 00:36:10.020
AUDIENCE: So how much of this
code or strategy do we need to

00:36:10.020 --> 00:36:12.650
change to make a cross-platform
app?

00:36:12.650 --> 00:36:19.040
So let's say you want to create
an Android app, which

00:36:19.040 --> 00:36:20.220
can [? take help of ?]

00:36:20.220 --> 00:36:22.580
using code from Presenter.

00:36:22.580 --> 00:36:28.610
What strategy is here to reuse
as much code as possible?

00:36:28.610 --> 00:36:30.610
ERIK KUEFLER: So that falls back
into that case I talked

00:36:30.610 --> 00:36:34.240
about earlier, where if you
want to provide multiple

00:36:34.240 --> 00:36:35.580
implementations for
this View--

00:36:35.580 --> 00:36:37.820
maybe one on GWT,
one on Android--

00:36:37.820 --> 00:36:40.900
using that View interface
is valuable.

00:36:40.900 --> 00:36:42.950
If you're doing these things
for your Presenters, your

00:36:42.950 --> 00:36:45.720
single components reference
the UI field directly, you

00:36:45.720 --> 00:36:47.890
obviously can't do that
quite as much.

00:36:47.890 --> 00:36:50.430
So I found in practice, it tends
to be really hard to

00:36:50.430 --> 00:36:54.710
share the entire UI across
different components.

00:36:54.710 --> 00:36:57.000
But if that's been working for
you, that's great, and you

00:36:57.000 --> 00:36:59.230
probably stick with it.

00:36:59.230 --> 00:37:02.030
In general, you can still factor
out smaller helper

00:37:02.030 --> 00:37:04.610
methods containing interesting
sub-components of your

00:37:04.610 --> 00:37:08.240
business logic and use them
across Android and Java.

00:37:08.240 --> 00:37:11.630
But if you're extending
composite directly and using

00:37:11.630 --> 00:37:13.840
UI fields, that component
definitely

00:37:13.840 --> 00:37:16.390
isn't reusable on Android.

00:37:16.390 --> 00:37:17.040
AUDIENCE: One more.

00:37:17.040 --> 00:37:22.970
So how different is GWT UI
EventBinder from EventBus of

00:37:22.970 --> 00:37:25.970
Guava library?

00:37:25.970 --> 00:37:27.590
ERIK KUEFLER: So I'm definitely
taking some

00:37:27.590 --> 00:37:30.240
inspiration from that there.

00:37:30.240 --> 00:37:33.540
All EventBinder is doing is it's
really just a very thin

00:37:33.540 --> 00:37:36.440
wrapper around the EventBus
that's built into GWT.

00:37:36.440 --> 00:37:40.540
It's just a way to automate
the way in which you bind

00:37:40.540 --> 00:37:41.920
those event handlers.

00:37:41.920 --> 00:37:43.270
So it's not much different
from what's

00:37:43.270 --> 00:37:44.820
already built into GWT.

00:37:44.820 --> 00:37:47.840
That's a lot like what's
built into Guava.

00:37:47.840 --> 00:37:49.480
Guava is a little
more powerful.

00:37:49.480 --> 00:37:53.730
It has full reflection, which
is a big advantage.

00:37:53.730 --> 00:37:56.250
It dispatches events in a
slightly different way, but if

00:37:56.250 --> 00:37:58.330
you've used Guava's EventBus,
you'll probably feel pretty

00:37:58.330 --> 00:37:59.720
comfortable using GWT's.

00:37:59.720 --> 00:38:02.580
The other big difference is
that in GWT, all of your

00:38:02.580 --> 00:38:05.500
events have to extend from this
event type, whereas on

00:38:05.500 --> 00:38:08.360
Guava, you can just fire any
object on your EventBus.

00:38:08.360 --> 00:38:10.600
That ends up not being too big
a deal, because it's not hard

00:38:10.600 --> 00:38:12.000
to just create an event
wrapping the

00:38:12.000 --> 00:38:13.320
type you want to fire.

00:38:13.320 --> 00:38:16.210
So they're pretty similar.

00:38:16.210 --> 00:38:16.980
AUDIENCE: Last one--

00:38:16.980 --> 00:38:21.870
does Google use this concept
for Android apps in Wallet?

00:38:21.870 --> 00:38:24.950
So my question is, do you
use MVP [? pattern ?]

00:38:24.950 --> 00:38:28.470
for the Wallet application for
Android and also as a web

00:38:28.470 --> 00:38:29.060
application?

00:38:29.060 --> 00:38:32.580
Or is it something that's
developed separately?

00:38:32.580 --> 00:38:34.070
ERIK KUEFLER: I think it
definitely varies a lot

00:38:34.070 --> 00:38:35.520
between teams.

00:38:35.520 --> 00:38:37.840
On my team, we have a completely
separate code base

00:38:37.840 --> 00:38:40.470
for our Android versus
our web application.

00:38:40.470 --> 00:38:42.400
And that's just because
the UIs for them

00:38:42.400 --> 00:38:43.120
are different enough.

00:38:43.120 --> 00:38:44.820
There's different enough things
that we're optimizing

00:38:44.820 --> 00:38:47.660
for that there's not a huge
amount of code sharing we take

00:38:47.660 --> 00:38:48.700
advantage of.

00:38:48.700 --> 00:38:50.580
But I suspect there's
some other team to

00:38:50.580 --> 00:38:51.400
do that a lot more.

00:38:51.400 --> 00:38:53.640
It's not something I can really
speak to, though.

00:38:53.640 --> 00:38:54.890
AUDIENCE: Thanks.

00:38:57.780 --> 00:39:01.850
AUDIENCE: You mentioned
something about Views and how

00:39:01.850 --> 00:39:05.380
simple they are most of the
time in most applications.

00:39:05.380 --> 00:39:09.240
I think the reality is that
most applications

00:39:09.240 --> 00:39:11.300
have a mix of both.

00:39:11.300 --> 00:39:14.850
So you've got some Views that
are very simple, like you

00:39:14.850 --> 00:39:17.630
said, and some Views that
are more complex.

00:39:17.630 --> 00:39:19.810
Then you need a lot of
abstractions between the

00:39:19.810 --> 00:39:21.060
different Views.

00:39:24.010 --> 00:39:27.700
I can see that it would help if
you use some sort of MVP or

00:39:27.700 --> 00:39:30.010
some sort of abstraction
in your Views.

00:39:30.010 --> 00:39:37.200
So what is the recommendation
for using a mix of the two

00:39:37.200 --> 00:39:39.710
approaches?

00:39:39.710 --> 00:39:42.305
Do you have any experience
using the mix?

00:39:42.305 --> 00:39:45.880
Or is it possible, or what is
the complications there?

00:39:45.880 --> 00:39:48.000
ERIK KUEFLER: I think these two
things mix really well.

00:39:48.000 --> 00:39:51.160
So in the application I work
with, we started with a more

00:39:51.160 --> 00:39:54.240
complex one, where we used
MVP for everything.

00:39:54.240 --> 00:39:58.250
And when I realized it was
easier to do it this way, we

00:39:58.250 --> 00:40:03.140
in piecemeal re-factored things
to use these simpler,

00:40:03.140 --> 00:40:04.650
smaller Views.

00:40:04.650 --> 00:40:07.660
It's really pretty transparent
to the application and what's

00:40:07.660 --> 00:40:08.610
using what.

00:40:08.610 --> 00:40:11.700
So if you're using a more
complex View, you have your

00:40:11.700 --> 00:40:14.090
View, which is a widget,
extends, composite.

00:40:14.090 --> 00:40:15.950
It has a Presenter behind it.

00:40:15.950 --> 00:40:18.860
And then if you change that
one component to being a

00:40:18.860 --> 00:40:22.290
built-in single component, it
doesn't really change from the

00:40:22.290 --> 00:40:23.780
point of view of the rest of the
application, because it's

00:40:23.780 --> 00:40:26.640
still just a widget that you
can include directly in

00:40:26.640 --> 00:40:28.250
whatever its parents are.

00:40:28.250 --> 00:40:31.930
Similarly, if you start simply
and need to break it out, the

00:40:31.930 --> 00:40:35.610
fact that you're factoring out
a Presenter class is really

00:40:35.610 --> 00:40:38.160
just an implementation detail
that shouldn't affect you in

00:40:38.160 --> 00:40:39.410
the rest of the world.

00:40:41.730 --> 00:40:43.490
Again, start with the simplest
implementation

00:40:43.490 --> 00:40:44.180
you can think of.

00:40:44.180 --> 00:40:47.700
And then it's never hard to just
extract another layer out

00:40:47.700 --> 00:40:48.980
of that for testability later.

00:40:48.980 --> 00:40:51.850
So I think that's something
that works really well.

00:40:51.850 --> 00:40:55.960
AUDIENCE: And is there any
disadvantages with using the

00:40:55.960 --> 00:41:02.030
first approach, the composite
pattern, like in terms of

00:41:02.030 --> 00:41:05.810
maintainability of the EventBus
working with the

00:41:05.810 --> 00:41:12.460
EventBus and cleaning up the
EventBus and stuff like that?

00:41:12.460 --> 00:41:14.090
ERIK KUEFLER: In terms of
EventBus, I don't think this

00:41:14.090 --> 00:41:15.340
pattern really has
much effect.

00:41:18.160 --> 00:41:20.170
So if you've split these apart,
you have a Presenter

00:41:20.170 --> 00:41:23.460
that's listening on the
EventBus, has these event

00:41:23.460 --> 00:41:25.340
handlers fire on the bus.

00:41:25.340 --> 00:41:28.310
When you combine them, you're
doing all the same things,

00:41:28.310 --> 00:41:30.050
just from one single
class here.

00:41:30.050 --> 00:41:32.270
So you're pretty much
using EventBus in

00:41:32.270 --> 00:41:33.720
exactly the same way.

00:41:33.720 --> 00:41:35.950
Either way, you inject it into
your logic class, you register

00:41:35.950 --> 00:41:38.530
it, you fire events on it.

00:41:38.530 --> 00:41:40.590
I don't think there's a
whole lot difference

00:41:40.590 --> 00:41:42.870
doing it this way.

00:41:42.870 --> 00:41:45.270
AUDIENCE: And one
last question--

00:41:45.270 --> 00:41:47.570
what is the future of GWT?

00:41:47.570 --> 00:41:48.820
ERIK KUEFLER: The
future of GWT?

00:41:48.820 --> 00:41:51.870
AUDIENCE: GWT in general.

00:41:51.870 --> 00:41:53.270
ERIK KUEFLER: There's a session
later today that's

00:41:53.270 --> 00:41:56.970
laying out the roadmap for what
exactly is happening.

00:41:56.970 --> 00:42:00.940
It's definitely something that's
still being supported.

00:42:00.940 --> 00:42:03.160
Control was recently transferred
over to a steering

00:42:03.160 --> 00:42:04.270
committee outside of Google.

00:42:04.270 --> 00:42:07.570
So I think the GWT team is
expecting the open source

00:42:07.570 --> 00:42:09.470
world to get a lot more
vibrant around it.

00:42:09.470 --> 00:42:11.720
So it's something that's
definitely going, definitely

00:42:11.720 --> 00:42:12.530
still healthy.

00:42:12.530 --> 00:42:14.190
We're using it a ton
inside Google.

00:42:14.190 --> 00:42:16.490
So I'm not on the GWT team.

00:42:16.490 --> 00:42:17.260
I don't know the details.

00:42:17.260 --> 00:42:19.010
So you should go to that
presentation later.

00:42:19.010 --> 00:42:20.710
But it's not something
I'm worried about.

00:42:20.710 --> 00:42:21.482
AUDIENCE: OK.

00:42:21.482 --> 00:42:21.870
Cool.

00:42:21.870 --> 00:42:23.600
Thanks.

00:42:23.600 --> 00:42:24.550
ERIK KUEFLER: Thank you.

00:42:24.550 --> 00:42:26.400
I think I'm out of time.

00:42:26.400 --> 00:42:28.540
If you guys could please rate
this session as you're

00:42:28.540 --> 00:42:30.460
leaving, either through your
Android apps, or just by

00:42:30.460 --> 00:42:32.570
taking a picture those QR codes
over there, that would

00:42:32.570 --> 00:42:34.020
be a huge help to me.

00:42:34.020 --> 00:42:35.725
So thanks for coming by.

00:42:35.725 --> 00:42:37.280
I'll be around to
answer questions

00:42:37.280 --> 00:42:38.780
afterwards if anyone wants.

00:42:38.780 --> 00:42:42.762
[APPLAUSE]

