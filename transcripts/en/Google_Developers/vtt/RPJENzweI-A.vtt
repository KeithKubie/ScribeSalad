WEBVTT
Kind: captions
Language: en

00:00:04.790 --> 00:00:05.810
&gt;&gt;Jon Larimer: Hi, everyone.

00:00:05.810 --> 00:00:10.130
My name is Jon Larimer, and I am a security
engineer on the Android team based out of

00:00:10.130 --> 00:00:11.130
sunny Atlanta,.

00:00:11.130 --> 00:00:12.970
&gt;&gt;Kenny Root: My name is Kenny Root.

00:00:12.970 --> 00:00:15.290
I'm a software engineer on the Android team.

00:00:15.290 --> 00:00:20.130
&gt;&gt;Jon Larimer: We're here today to talk to
you about security and privacy in the Android

00:00:20.130 --> 00:00:21.860
Apps that you guys are developing and publishing.

00:00:21.860 --> 00:00:24.829
And we're going to dig right in.

00:00:24.829 --> 00:00:27.970
Let's talk about why you need to take security
into account when you're writing apps and

00:00:27.970 --> 00:00:32.340
why it's important to protect your apps and
your users' data.

00:00:32.340 --> 00:00:33.540
I'm sure you've all seen the headlines.

00:00:33.540 --> 00:00:39.210
There's a major security breach here, a major
privacy leak there, some popular mobile app

00:00:39.210 --> 00:00:40.680
gets caught collecting too much data.

00:00:40.680 --> 00:00:41.980
The users are furious.

00:00:41.980 --> 00:00:43.460
The blogosphere is freaking out.

00:00:43.460 --> 00:00:45.680
The media demands answers.

00:00:45.680 --> 00:00:48.660
And even the politicians are getting involved
to speak their mind.

00:00:48.660 --> 00:00:51.060
So this is pretty serious stuff.

00:00:51.060 --> 00:00:55.079
When stories like this hit the mainstream
news outlets and people talk about it in bars

00:00:55.079 --> 00:01:00.120
and in taxi cabs, it shows that people really
are paying attention to the privacy practices

00:01:00.120 --> 00:01:02.750
and security issues in mobile apps today.

00:01:02.750 --> 00:01:06.170
And it would really ruin your day if you woke
up one morning and saw the headline that was

00:01:06.170 --> 00:01:11.910
about your app that your company produced
that you actually spent time developing.

00:01:11.910 --> 00:01:16.159
You don't really want the wake-up call from
your boss with PR and legal on the line, asking

00:01:16.159 --> 00:01:19.220
what's going on and what you're planning on
doing to fix it.

00:01:19.220 --> 00:01:24.240
And the problem isn't really that developers
are collecting personal user data.

00:01:24.240 --> 00:01:28.080
Sometimes a fundamental feature of your app
requires it.

00:01:28.080 --> 00:01:30.280
The problem is the lack of transparency.

00:01:30.280 --> 00:01:35.010
And the problem is not notifying the users
of the data you're collecting and what it's

00:01:35.010 --> 00:01:36.920
been used for.

00:01:36.920 --> 00:01:41.100
And even if you aren't purposely collecting
personal data without telling users, your

00:01:41.100 --> 00:01:45.810
app can still allow an accidental personal
data leak if you aren't taking security into

00:01:45.810 --> 00:01:46.869
consideration.

00:01:46.869 --> 00:01:51.520
If your app stores or transmits any personal
data insecurely, malware authors or hackers

00:01:51.520 --> 00:01:55.600
could end up using this data without you or
your users knowing it.

00:01:55.600 --> 00:01:59.000
And if your app is collecting too much data
or even if it has too access to too much data

00:01:59.000 --> 00:02:03.920
through the permissions that it requests,
people start to worry.

00:02:03.920 --> 00:02:07.090
And they have the right to worry, and they
really should be worrying.

00:02:07.090 --> 00:02:10.530
So how many of you guys have seen negative
reviews on your apps because of the amount

00:02:10.530 --> 00:02:12.180
of permissions that your app needs?

00:02:12.180 --> 00:02:13.719
A few of you.

00:02:13.719 --> 00:02:14.719
Probably a lot of you.

00:02:14.719 --> 00:02:15.719
Some of you aren't raising your hands.

00:02:15.719 --> 00:02:17.510
[ Laughter ]
&gt;&gt;Jon Larimer: I see a lot of these reviews

00:02:17.510 --> 00:02:18.560
all the time.

00:02:18.560 --> 00:02:22.540
So my point is that people are getting more
and more distrustful of apps that ask for

00:02:22.540 --> 00:02:26.790
access to their personal data without any
clear reason for what you're planning on using

00:02:26.790 --> 00:02:27.939
it for.

00:02:27.939 --> 00:02:33.519
So our talk today is about how you can write
apps with privacy and security in mind.

00:02:33.519 --> 00:02:37.090
And we'll talk about ways to protect your
app's data from malicious apps that are on

00:02:37.090 --> 00:02:41.330
the device and how to prevent your app from
being a springboard from privilege elevation

00:02:41.330 --> 00:02:44.340
attacks or information leaks.

00:02:44.340 --> 00:02:48.040
And we'll tell you ways that you can minimize
the number of permissions that your app requests

00:02:48.040 --> 00:02:50.980
and -- so you can lower the impact of a potential
attack.

00:02:50.980 --> 00:02:56.599
And we'll talk about the tools and the documentation
that we have to help you write secure apps.

00:02:56.599 --> 00:03:00.150
So people today, they use their phones for
everything now.

00:03:00.150 --> 00:03:01.200
They surf the Web.

00:03:01.200 --> 00:03:02.200
They read their email.

00:03:02.200 --> 00:03:06.599
They take pictures, they get driving directions,
they interact with all of their friends through

00:03:06.599 --> 00:03:08.169
their social networks.

00:03:08.169 --> 00:03:12.650
And people can customize the way they do these
things by installing different apps.

00:03:12.650 --> 00:03:17.159
But for these apps to work, they need to have
access to the data that basically defines

00:03:17.159 --> 00:03:21.760
your life, your list of friends, your location
on the planet, where you're going and where

00:03:21.760 --> 00:03:23.900
you've been, and who you're talking to.

00:03:23.900 --> 00:03:29.159
So mobile devices are very powerful now, but
they're also a treasure trove of very private

00:03:29.159 --> 00:03:35.339
personal data on the phone's owner and even
all of the phone owner's friends.

00:03:35.339 --> 00:03:39.239
So Android just doesn't hand out this data
to anyone that wants it, as you undoubtedly

00:03:39.239 --> 00:03:43.439
already know, being Android developers, the
Android permission system protects the data

00:03:43.439 --> 00:03:45.559
and the capabilities on your phone.

00:03:45.559 --> 00:03:49.889
So when a user installs an app that wants
to access this data or some capability of

00:03:49.889 --> 00:03:54.230
the phone, the user gets to see the data and
the capabilities that you're wanting to access.

00:03:54.230 --> 00:03:58.510
For example, if your app wants to send SMS
messages, the user can see that your app wants

00:03:58.510 --> 00:04:00.760
to do this through the permission system.

00:04:00.760 --> 00:04:04.359
And if somebody wants to download a game and
they see that it's requesting access to read

00:04:04.359 --> 00:04:08.699
all of your contacts and send SMS messages,
a lot of times, they'll think twice about

00:04:08.699 --> 00:04:13.049
downloading it.

00:04:13.049 --> 00:04:16.870
So when you write an app that accesses the
data on a device or even produces data on

00:04:16.870 --> 00:04:21.250
a device, for example, a social networking
app where a user enters their own content,

00:04:21.250 --> 00:04:25.480
you need to take very good care of this data
and you need to be a good data custodian.

00:04:25.480 --> 00:04:29.290
There are bad guys out there that would love
to abuse this data for purposes that the user

00:04:29.290 --> 00:04:31.490
never really intended it for.

00:04:31.490 --> 00:04:35.820
And, first of all, people generally don't
like giving out their personal information

00:04:35.820 --> 00:04:37.780
to strangers, they really hate it.

00:04:37.780 --> 00:04:41.220
You can go ask someone on the street for their
name and email address and phone number and

00:04:41.220 --> 00:04:42.500
see if they'll give it to you.

00:04:42.500 --> 00:04:43.750
And they probably won't.

00:04:43.750 --> 00:04:47.040
You can ask him for a list of all of their
friends and their friends' phone numbers,

00:04:47.040 --> 00:04:48.870
but they're not going to give this data.

00:04:48.870 --> 00:04:52.690
But it seems like a lot of app developers
are expecting people to just hand over all

00:04:52.690 --> 00:04:55.720
this information for no reason.

00:04:55.720 --> 00:05:00.561
And besides the general discomfort involved
in giving out all this personal data, people

00:05:00.561 --> 00:05:04.570
need to worry about the -- the folks that
write malicious software, the malware authors

00:05:04.570 --> 00:05:08.940
who write apps that try to mine mobile devices
for data.

00:05:08.940 --> 00:05:14.510
What do the bad guys want to do if they get
a piece of malware on a user's phone?

00:05:14.510 --> 00:05:19.660
Well, the user's phone number and email address
could be harvested for sending unsolicited

00:05:19.660 --> 00:05:22.970
advertisements, robo calls, and spam emails.

00:05:22.970 --> 00:05:27.010
Their contacts could be collected, too, so
all of their friends start getting spam emails.

00:05:27.010 --> 00:05:32.290
And the more unscrupulous or Black Hat marketers
and spammers will pay big bucks for collections

00:05:32.290 --> 00:05:36.120
of detailed personal information on lots of
people.

00:05:36.120 --> 00:05:39.440
But that's really not the only way to make
money from having access to a mobile device.

00:05:39.440 --> 00:05:42.850
There are criminals out that there want to
take advantage of your user's phones to send

00:05:42.850 --> 00:05:46.120
premium SMS messages that directly charge
your phone bill.

00:05:46.120 --> 00:05:49.800
And then there are the real serious criminals
out there that would love to transfer money

00:05:49.800 --> 00:05:54.260
directly out of your bank account, for example,
intercepting the two-factor authentication

00:05:54.260 --> 00:05:58.450
messages that your bank sends over SMS.

00:05:58.450 --> 00:06:02.170
So these are just a few of the reasons that
the data and capabilities on Android devices

00:06:02.170 --> 00:06:03.720
really need to be protected.

00:06:03.720 --> 00:06:06.840
But so what does this have to do with the
apps that you write and didn't I just get

00:06:06.840 --> 00:06:10.920
done saying that Android protects all this
will data?

00:06:10.920 --> 00:06:15.950
Well, even well intentioned apps that are
insecure could end up leaking data and other

00:06:15.950 --> 00:06:19.470
device access to malicious apps.

00:06:19.470 --> 00:06:23.680
And when a user installs your app and they
approve access to the permissions that you

00:06:23.680 --> 00:06:28.540
request, they're trusting you with that data
and those device capabilities.

00:06:28.540 --> 00:06:32.280
They have faith that you aren't going to leak
this data to bad apps and that their email

00:06:32.280 --> 00:06:35.220
address won't start getting spam because of
your app and they're trusting that all of

00:06:35.220 --> 00:06:40.010
their contacts won't be solicited unsolicited
SMS messages because of your app.

00:06:40.010 --> 00:06:45.860
So the goal of this talk is really to make
sure that you don't let those users down.

00:06:45.860 --> 00:06:50.800
So you really need to be aware that if your
app requests a permission, a security vulnerability

00:06:50.800 --> 00:06:55.550
in the app can end up granting equivalent
access to another app that doesn't request

00:06:55.550 --> 00:06:56.550
that permission.

00:06:56.550 --> 00:07:00.980
So even if you aren't willfully violating
your user's privacy, a mistake in your code

00:07:00.980 --> 00:07:05.170
could end up leading to some other bad actor
doing that kind of thing.

00:07:05.170 --> 00:07:11.889
One example I have of this kind of security
vulnerability is, for example, storing the

00:07:11.889 --> 00:07:14.860
latest GPS location in a world-readable file.

00:07:14.860 --> 00:07:17.420
And I've seen this a few times, and maybe
your app does this.

00:07:17.420 --> 00:07:18.520
Hopefully, it doesn't.

00:07:18.520 --> 00:07:23.790
If it does, you should go fix it immediately
after this session.

00:07:23.790 --> 00:07:26.980
So if you store the GPS location in a file
that any app can read.

00:07:26.980 --> 00:07:30.690
This means that another app can access the
phone's location without requesting either

00:07:30.690 --> 00:07:35.400
of the access location permissions, either
access course location or access find location.

00:07:35.400 --> 00:07:39.970
You're basically removing the effectiveness
of the location permission that Android normally

00:07:39.970 --> 00:07:43.020
requires to read the location data.

00:07:43.020 --> 00:07:49.340
Another example would be exporting a content
provider that stores sensitive personal information.

00:07:49.340 --> 00:07:53.510
So let's say that you are developing a note
taking app where the user can take notes and

00:07:53.510 --> 00:07:58.080
save their notes, and you might implement
a content provider so the different components

00:07:58.080 --> 00:08:02.120
of your app can all access these notes through
a uniform API.

00:08:02.120 --> 00:08:06.960
And if this content provider is exported and
doesn't require any permissions, then that

00:08:06.960 --> 00:08:10.169
means that any app on the phone could end
up reading the user's private notes.

00:08:10.169 --> 00:08:13.590
And the user could be keeping, like, really
private, sensitive stuff in here and they

00:08:13.590 --> 00:08:16.900
might not have any idea that you're making
it available to any other app that's on the

00:08:16.900 --> 00:08:19.230
phone.

00:08:19.230 --> 00:08:23.669
And you could think -- you could think that
you're being really smart and encrypting the

00:08:23.669 --> 00:08:28.060
backing store for the file or encrypting the
database and thinking that the malware authors

00:08:28.060 --> 00:08:29.889
or the hackers won't be able to access it.

00:08:29.889 --> 00:08:34.479
But if you're providing an open API where
any app can read the data, then your encryption

00:08:34.479 --> 00:08:38.909
is basically worthless, your users are still
at risk, and your app is really a security

00:08:38.909 --> 00:08:41.659
headline waiting to happen.

00:08:41.659 --> 00:08:47.410
And so another one that we see a lot is logging
personal information in the logcat logs.

00:08:47.410 --> 00:08:52.089
We've seen people logging email addresses
or even passwords for the logcat logs.

00:08:52.089 --> 00:08:56.139
And it's usually just leftover lines of code
from debugging that people forget to remove.

00:08:56.139 --> 00:08:58.589
But it's a pretty serious problem.

00:08:58.589 --> 00:09:02.339
And we have made some improvements to the
logging system in Jelly Bean to prevent this

00:09:02.339 --> 00:09:04.839
kind of thing from being abused.

00:09:04.839 --> 00:09:09.199
So apps in Jelly Bean can no longer read the
logcat logs for other apps, which is good.

00:09:09.199 --> 00:09:12.850
But it's still a very bad idea to log any
personal data to logcat logs, regardless of

00:09:12.850 --> 00:09:16.050
that.

00:09:16.050 --> 00:09:19.579
Besides worrying about other malicious acts
interacting with your apps, you need to watch

00:09:19.579 --> 00:09:24.740
what you do over the network, sending unencrypted
personal data over a wireless network is really

00:09:24.740 --> 00:09:25.740
bad.

00:09:25.740 --> 00:09:28.199
You should be using encryption whenever possible.

00:09:28.199 --> 00:09:32.089
If you're transmitting data over an unencrypted
link, you might as well be broadcasting it

00:09:32.089 --> 00:09:33.420
to the world.

00:09:33.420 --> 00:09:36.790
Imagine your user is walking around with a
billboard floating over their head showing

00:09:36.790 --> 00:09:40.550
all of their personal information and the
contents of their documents or even their

00:09:40.550 --> 00:09:41.810
contacts' personal information.

00:09:41.810 --> 00:09:43.569
Like I said, this is bad.

00:09:43.569 --> 00:09:47.040
You need to encrypt anything that goes over
a wireless network.

00:09:47.040 --> 00:09:51.069
And then there is also the issue of lost or
stolen phones.

00:09:51.069 --> 00:09:55.269
And it's really up to the user to protect
access to their physical device.

00:09:55.269 --> 00:09:58.029
But making your app more secure can still
help here.

00:09:58.029 --> 00:10:02.949
Because you don't want to accidentally provide
a back door into someone's phone if they lose

00:10:02.949 --> 00:10:03.949
control over it.

00:10:03.949 --> 00:10:06.569
So that's what our talk is about today.

00:10:06.569 --> 00:10:10.709
We're going to get into more detail about
these possible security holes and how to prevent

00:10:10.709 --> 00:10:11.709
them.

00:10:11.709 --> 00:10:14.230
If you pay attention to what we're saying,
hopefully, you won't have to worry about dealing

00:10:14.230 --> 00:10:21.040
with the consequences of a major security
or privacy breach with your app.

00:10:21.040 --> 00:10:25.079
So the first piece of advice I want to give
you is that you really need to let your users

00:10:25.079 --> 00:10:26.790
know what you're doing with their data.

00:10:26.790 --> 00:10:30.720
If your app is transmitting or collecting
any user data, meaning any data that you get

00:10:30.720 --> 00:10:35.199
from the phone by requesting permission or
any data that the user manually enters into

00:10:35.199 --> 00:10:38.279
the app, make sure that you have a privacy
policy.

00:10:38.279 --> 00:10:43.259
We allow uploading of -- we allow uploading
privacy policies to the Play Store now so

00:10:43.259 --> 00:10:45.259
that users can read it before downloading
the app.

00:10:45.259 --> 00:10:48.199
So you don't have to implement your own sort
of UI for showing a privacy policy.

00:10:48.199 --> 00:10:52.420
This helps you be more up-front and transparent.

00:10:52.420 --> 00:10:56.300
And most users really appreciate this kind
of thing.

00:10:56.300 --> 00:11:00.410
And the privacy policy should spell out exactly
what data you collect.

00:11:00.410 --> 00:11:01.649
And I really mean exactly.

00:11:01.649 --> 00:11:05.309
So if you're collecting email addresses and
names, say names and email addresses.

00:11:05.309 --> 00:11:07.779
If you're collecting phone numbers, say phone
numbers.

00:11:07.779 --> 00:11:11.170
Don't just provide a blanket policy that says
that you are going to collect whatever data

00:11:11.170 --> 00:11:14.069
you want and do whatever you want with it,
because that's not useful and you might as

00:11:14.069 --> 00:11:18.620
well not even have a privacy policy at that
point.

00:11:18.620 --> 00:11:22.089
Something else that you want to do, it's a
pretty good idea to give users a choice.

00:11:22.089 --> 00:11:26.130
If you want to collect all of their contacts
for some reason, ask them and let them know

00:11:26.130 --> 00:11:27.519
why you want this information.

00:11:27.519 --> 00:11:31.689
Let them know what benefit that you're providing
to them in exchange for this data.

00:11:31.689 --> 00:11:35.740
And you should really give the users an option
to select which data they want to give you.

00:11:35.740 --> 00:11:37.300
All or nothing isn't a great option.

00:11:37.300 --> 00:11:41.600
So let them select a subset of the contacts
that they want to share with your app.

00:11:41.600 --> 00:11:45.959
But, really, the most important thing that
you need to do is just be transparent about

00:11:45.959 --> 00:11:52.240
what data your app collects and what you're
doing with it.

00:11:52.240 --> 00:11:56.220
So something else that's really important
to keeping your app secure is keeping your

00:11:56.220 --> 00:11:58.560
developer account itself secure.

00:11:58.560 --> 00:12:02.620
The Play Store Developer Console lets you
upload apps and publish your apps and update

00:12:02.620 --> 00:12:03.620
your apps.

00:12:03.620 --> 00:12:05.269
So you really need to protect your account.

00:12:05.269 --> 00:12:09.720
If someone else gets access to it, they can
publish apps as you, which if they publish

00:12:09.720 --> 00:12:12.209
some really bad apps, it would make you look
pretty bad.

00:12:12.209 --> 00:12:14.740
They could also get access to your financial
data.

00:12:14.740 --> 00:12:19.800
They'll see how much money you make from selling
your apps and all of your in-app content.

00:12:19.800 --> 00:12:24.670
So one of the best ways to prevent unauthorized
access is by using two-factor authentication.

00:12:24.670 --> 00:12:28.140
You can download the Google authenticator
app from your phone and require a one-time

00:12:28.140 --> 00:12:30.970
password when you log into your Google account.

00:12:30.970 --> 00:12:35.010
And if you don't have two-factor authentication
enabled for your developer account, that's

00:12:35.010 --> 00:12:38.399
another one of those things where after this
session, you should go enable it, because

00:12:38.399 --> 00:12:43.680
it's really one of the most effective things
you can do to protect your account.

00:12:43.680 --> 00:12:50.180
So another tip is, if you want to give another
employee or a partner access to your developer

00:12:50.180 --> 00:12:52.230
account, don't give them your password.

00:12:52.230 --> 00:12:56.449
We've seen this happen, and it really kind
of scares me when people do this kind of thing.

00:12:56.449 --> 00:13:00.769
So we added the ability to grant access to
other accounts to your main developer account.

00:13:00.769 --> 00:13:02.120
So you don't have to give out your password.

00:13:02.120 --> 00:13:07.240
You can grant access by email address, and
you get to choose whether or not this person

00:13:07.240 --> 00:13:08.519
can see the financial data.

00:13:08.519 --> 00:13:14.470
So you can end up -- you can create a single
authoritative account for your company, and

00:13:14.470 --> 00:13:16.430
then other accounts can be granted access.

00:13:16.430 --> 00:13:20.899
And this way, a single rogue employee can't
take your account hostage.

00:13:20.899 --> 00:13:24.660
If you're just granting access to other people,
you can revoke that access without changing

00:13:24.660 --> 00:13:26.350
the master account password.

00:13:26.350 --> 00:13:31.860
So if someone leaves the company on bad terms,
there's -- it kind of limits the damage that

00:13:31.860 --> 00:13:33.649
they can do.

00:13:33.649 --> 00:13:36.889
&gt;&gt;Kenny Root: Next we're going to talk about
the app signing key.

00:13:36.889 --> 00:13:40.600
You might ask, what is an app signing key,
well, as Android developers, you've already

00:13:40.600 --> 00:13:41.600
been using it.

00:13:41.600 --> 00:13:46.239
You might not have noticed because in a normal
development work flow, in Eclipse, using the

00:13:46.239 --> 00:13:50.649
ADT, or Android Developer Tools, your app
is signed automatically before it's installed

00:13:50.649 --> 00:13:51.649
on the device.

00:13:51.649 --> 00:13:55.959
And that's because any app installed on Android
device must be signed with a signature before

00:13:55.959 --> 00:14:00.110
that's -- or must be signed with a private
key before it's allowed to be installed.

00:14:00.110 --> 00:14:05.529
However, if you're distributing your app in
the -- whoops -- if you're distributing your

00:14:05.529 --> 00:14:11.279
app in the Google Play or sending it via email
to someone else, you'll have to generate a

00:14:11.279 --> 00:14:12.279
release key.

00:14:12.279 --> 00:14:14.540
This is a unique key to your app.

00:14:14.540 --> 00:14:18.089
And it provides -- any update you want to
provide for that app must be signed with the

00:14:18.089 --> 00:14:19.939
same key.

00:14:19.939 --> 00:14:23.950
Another cool property of this key is, if you
sign multiple apps of the same key, you can

00:14:23.950 --> 00:14:30.170
use things such as shared user IDs between
the apps to look at each app's data, or you

00:14:30.170 --> 00:14:35.100
can use a permission level of signature, which
we'll talk about later.

00:14:35.100 --> 00:14:39.959
Because the signing key is part of the app's
identity, it can be used to update your app,

00:14:39.959 --> 00:14:44.009
you really need to make sure that you protect
this signing key.

00:14:44.009 --> 00:14:49.530
So a big company might have something like
a hardware security module or HSM where they

00:14:49.530 --> 00:14:52.000
have little a ceremony where they sign the
app's keys.

00:14:52.000 --> 00:14:54.480
I don't know, they might have put on special
hats.

00:14:54.480 --> 00:14:59.339
As a home-brewed developer, you might just
have your key on a USB stick that you stick

00:14:59.339 --> 00:15:01.189
in your fireproof safe.

00:15:01.189 --> 00:15:04.639
But the most important part is you need to
keep a backup of this key.

00:15:04.639 --> 00:15:09.800
But whatever you do, don't keep that backup
in your source repository or package it in

00:15:09.800 --> 00:15:10.800
your app.

00:15:10.800 --> 00:15:13.209
We've seen people do this before, and you're
basically giving your private key away to

00:15:13.209 --> 00:15:15.199
the world.

00:15:15.199 --> 00:15:21.369
Oh, and by the way, since you have to sign
with the same key to have updates, if you

00:15:21.369 --> 00:15:24.459
lose that release key, you're not going to
be able to update your app.

00:15:24.459 --> 00:15:28.829
You're going to have to tell users to uninstall
and install a new app with a different key.

00:15:28.829 --> 00:15:32.699
And you can see by the Google Search results
that it happens quite a lot.

00:15:32.699 --> 00:15:34.589
And we've even received support calls about
this.

00:15:34.589 --> 00:15:38.800
And I'm sorry we can't factor your key to
find the private key again.

00:15:38.800 --> 00:15:43.910
But, you know, I don't want to get a call
from you guys about losing your key, because

00:15:43.910 --> 00:15:46.940
I don't want to tell you, sorry, that I can't
fix your key for you.

00:15:46.940 --> 00:15:52.290
Now, that we know how to keep your accounts
and your key secure, let's talk more about

00:15:52.290 --> 00:15:57.740
Android security itself and the features it
offers developers.

00:15:57.740 --> 00:16:01.200
So the security architecture for Android has
several layers.

00:16:01.200 --> 00:16:05.869
The first layer is that each application runs
in its own process space and as its own unique

00:16:05.869 --> 00:16:07.509
user ID.

00:16:07.509 --> 00:16:11.939
There are some exceptions such as being signed
by the same certificate allows you to run

00:16:11.939 --> 00:16:13.299
as a shared user ID.

00:16:13.299 --> 00:16:17.649
But, generally, you can imagine that each
application is separated by kind of a little

00:16:17.649 --> 00:16:18.829
firewall between them.

00:16:18.829 --> 00:16:21.529
It's a process space.

00:16:21.529 --> 00:16:26.630
This -- the Linux kernel provides a separation
between the processes and different user IDs,

00:16:26.630 --> 00:16:28.259
which forms the basis of the Android sandbox.

00:16:28.259 --> 00:16:34.009
And this sandbox gives developers the flexibility
they need to make wonderful and innovative

00:16:34.009 --> 00:16:38.889
apps without jumping through hoops to go through
different problems they might have.

00:16:38.889 --> 00:16:44.739
And the sandbox also ensures that apps -- or
interactions between each app component are

00:16:44.739 --> 00:16:47.680
protected by the appropriate permission check.

00:16:47.680 --> 00:16:53.730
For instance, if your app was accessing the
file system, Linux kernel provides file system

00:16:53.730 --> 00:16:54.760
security.

00:16:54.760 --> 00:17:00.810
So what the Linux kernel would do is see what
your app's user ID is, what the file's owner

00:17:00.810 --> 00:17:02.160
is, check the permissions.

00:17:02.160 --> 00:17:06.730
And if that checks out, allow you to write
from or read to the file.

00:17:06.730 --> 00:17:11.160
Or you can imagine as a developer you might
want to enable Wi-Fi peer-to-peer mode.

00:17:11.160 --> 00:17:16.480
But you can't talk directly to the Wi-Fi peer-to-peer
or the Wi-Fi driver and the kernel, so you

00:17:16.480 --> 00:17:20.040
make a call to the Wi-Fi manager API.

00:17:20.040 --> 00:17:24.990
So in the backend, this actually uses a binder
IPC mechanism or interprocess communication

00:17:24.990 --> 00:17:28.390
protocol or method to talk to the system server.

00:17:28.390 --> 00:17:31.620
And the system server would then check your
app's permissions, what it was granted when

00:17:31.620 --> 00:17:32.620
it was installed.

00:17:32.620 --> 00:17:37.540
And if it's granted, it would talk to the
Wi-Fi kernel driver for you on your app's

00:17:37.540 --> 00:17:41.820
behalf and enable Wi-Fi peer-to-peer mode
if you have that permission.

00:17:41.820 --> 00:17:45.500
But it's not limited to calls to the system
server.

00:17:45.500 --> 00:17:49.980
You can provide components to other applications
for them to interact with, and you can do

00:17:49.980 --> 00:17:54.370
something like maybe you have a foreign language
word list for an input method editor.

00:17:54.370 --> 00:17:59.140
Or you could have a match-making service for
a game to find other opponents.

00:17:59.140 --> 00:18:03.240
You could provide a simple interface for a
complex communication protocol, like Secure

00:18:03.240 --> 00:18:10.520
Shell, or you could have a calendar provider
that goes up to the cloud to grab your next

00:18:10.520 --> 00:18:11.520
appointment.

00:18:11.520 --> 00:18:15.320
You know, it's really limited to whatever
you can imagine.

00:18:15.320 --> 00:18:21.930
Android is unique in that there's freedom
within your app's process to do what you need

00:18:21.930 --> 00:18:23.020
to do.

00:18:23.020 --> 00:18:25.070
This provides a lot of awesome possibilities.

00:18:25.070 --> 00:18:27.910
But it's also different from a desktop VM.

00:18:27.910 --> 00:18:30.190
And I have a kind of a story.

00:18:30.190 --> 00:18:33.280
I was trying to write a tool for the Android
SDK.

00:18:33.280 --> 00:18:37.730
I thought, you know, I'd just write it in
the Java language because it can run on Linux

00:18:37.730 --> 00:18:38.910
and Windows and Mac OS.

00:18:38.910 --> 00:18:40.390
But it turns out I ran into a problem.

00:18:40.390 --> 00:18:44.330
I was trying to use the password-based key
derivation function number 2.

00:18:44.330 --> 00:18:46.670
It's kind of a mouthful.

00:18:46.670 --> 00:18:47.670
But it's PBKDF2.

00:18:47.670 --> 00:18:50.770
It turns out, in Java, it's only available
in some operating systems.

00:18:50.770 --> 00:18:57.060
I thought, oh, boy, I'll just use my own implementation
and provide that through the Java cryptography

00:18:57.060 --> 00:18:58.250
architecture.

00:18:58.250 --> 00:19:04.740
But it turns out in some G -- some VMs, you
can't install your own JCA provider and some

00:19:04.740 --> 00:19:05.740
VMs you can.

00:19:05.740 --> 00:19:06.740
So it's kind of a headache.

00:19:06.740 --> 00:19:09.110
But in Android, you won't have that kind of
headache.

00:19:09.110 --> 00:19:13.650
You can do what you need to do, and you'll
be much happier.

00:19:13.650 --> 00:19:17.160
But it also means you have to be aware of
some things.

00:19:17.160 --> 00:19:21.000
You can use reflection in your own application
to do what you need to do and it allows you

00:19:21.000 --> 00:19:23.280
to do cool things like building dynamic code.

00:19:23.280 --> 00:19:30.050
But it also means that protections for methods,
fields, and classes, like protected and private,

00:19:30.050 --> 00:19:31.190
aren't absolute.

00:19:31.190 --> 00:19:34.020
And you can do some really gnarly things in
your own code using reflection.

00:19:34.020 --> 00:19:37.590
I wouldn't really encourage that, though,
I'd just stay away from it.

00:19:37.590 --> 00:19:42.820
Or you can use JNI, which is a native interface
for applications, and it's allowed developers

00:19:42.820 --> 00:19:48.590
to do some really, really cool things, like
port in the latest game engine or use a third-party

00:19:48.590 --> 00:19:50.870
library to speed up development.

00:19:50.870 --> 00:19:55.370
But it also means that in native code, you
can do anything in your own process space.

00:19:55.370 --> 00:19:57.570
There's not really a restriction.

00:19:57.570 --> 00:20:01.430
So you can also scribble on the Dalvik manage
(indiscernible), which can really cause some

00:20:01.430 --> 00:20:02.880
bizarre behavior.

00:20:02.880 --> 00:20:08.920
If you're processing things in native code,
like images or anything, you can inadvertently

00:20:08.920 --> 00:20:12.490
cause a security exploit by allowing a buffer
overflow.

00:20:12.490 --> 00:20:15.010
In the worst case, you'll provide the security
overflow.

00:20:15.010 --> 00:20:17.660
It might just have a segmentation fault.

00:20:17.660 --> 00:20:21.590
It is a cause of really bizarre behavior.

00:20:21.590 --> 00:20:30.360
&gt;&gt;Jon Larimer: So next we'll talk about what
it takes to actually write a secure app.

00:20:30.360 --> 00:20:34.910
We'll talk about the potential problems you
might face and solutions for those problems,

00:20:34.910 --> 00:20:38.330
we'll tell you the best practices that you
can employ to take advantage of the security

00:20:38.330 --> 00:20:42.820
features that the Android platform framework
and operating system offers.

00:20:42.820 --> 00:20:44.190
So here's a typical application.

00:20:44.190 --> 00:20:45.650
It has a few activities.

00:20:45.650 --> 00:20:48.440
There's a service running in the background.

00:20:48.440 --> 00:20:52.321
The service talks -- the service has a settings
file that it reads and writes to, there's

00:20:52.321 --> 00:20:56.420
a database with a content provider that provides
access to it.

00:20:56.420 --> 00:20:59.400
The app is Internet-enabled and it talks to
the cloud.

00:20:59.400 --> 00:21:03.450
So when you look at this diagram, can you
tell where the attack surface is, which of

00:21:03.450 --> 00:21:07.900
these components could have a security vulnerability
or some kind of data leak that would leak

00:21:07.900 --> 00:21:11.200
data or capabilities from Android?

00:21:11.200 --> 00:21:13.580
And the answer is all of them.

00:21:13.580 --> 00:21:17.110
Every single component here could be exposing
data if the developer -- if you guys aren't

00:21:17.110 --> 00:21:19.250
taking the necessary precautions.

00:21:19.250 --> 00:21:23.740
The activities could be leaking personal data
to the log file, the service could remote

00:21:23.740 --> 00:21:28.640
calls from other apps that don't have permission,
the settings file could be world readable

00:21:28.640 --> 00:21:31.650
or world writeable allowing access to the
service.

00:21:31.650 --> 00:21:37.060
The content provider could be granting access
to the database and the database file itself

00:21:37.060 --> 00:21:39.940
could have insecure file system permissions.

00:21:39.940 --> 00:21:44.270
And even the data being transmitted over the
network could be in clear text or the web

00:21:44.270 --> 00:21:46.840
service itself could be compromised.

00:21:46.840 --> 00:21:50.370
Now, this isn't really as scary as it looks.

00:21:50.370 --> 00:21:54.000
Android actually makes it pretty easy to prevent
most of these kind of attacks, except for

00:21:54.000 --> 00:21:57.640
the cloud one there, we can't really protect
your web server.

00:21:57.640 --> 00:22:01.090
But it's often easier to write a secure app
in Android than it is to write an insecure

00:22:01.090 --> 00:22:02.090
app.

00:22:02.090 --> 00:22:05.510
You just need to know what to do, you need
to know what's safe and what's not safe, and

00:22:05.510 --> 00:22:09.540
once you really understand the risks and the
security model of Android mit starts to become

00:22:09.540 --> 00:22:13.770
like second nature and we do have some tools
to help keep you on track.

00:22:13.770 --> 00:22:18.240
So now Kenny will tell you about the different
types of application components and how to

00:22:18.240 --> 00:22:22.920
protect other apps from accessing them if
you do not want other apps to access them.

00:22:22.920 --> 00:22:29.780
&gt;&gt;Kenny Root: So each component provided by
your app is declared in the Android manifest.

00:22:29.780 --> 00:22:33.600
And this is a way in which the system server
and specifically the activity manager and

00:22:33.600 --> 00:22:38.380
package manager inside the system server knows
the entry points to your apps.

00:22:38.380 --> 00:22:43.490
And these entry points can be services, activities,
broadcast receivers or content providers.

00:22:43.490 --> 00:22:47.310
And each one of these components can have
intent filters associated with them which

00:22:47.310 --> 00:22:52.730
tells the system server which intent data
you want these activities or services or whatever

00:22:52.730 --> 00:22:54.140
being matched for.

00:22:54.140 --> 00:22:59.840
An intent filter signals to the Android system
that you want these components exposed to

00:22:59.840 --> 00:23:01.640
other apps.

00:23:01.640 --> 00:23:05.390
And with without an intent filter, most components
are not available to other applications with

00:23:05.390 --> 00:23:10.780
the exception of the content provider which
is exported by default.

00:23:10.780 --> 00:23:14.770
So it's a good idea to get in the habit of
explicitly marking components as exported

00:23:14.770 --> 00:23:15.770
or not.

00:23:15.770 --> 00:23:19.960
This is not strictly necessary, but it will
help you prevent mistakes you make in the

00:23:19.960 --> 00:23:20.960
future.

00:23:20.960 --> 00:23:25.570
For instance, if you didn't intent a component
to be exported and maybe seven months later

00:23:25.570 --> 00:23:29.340
you come back or a coworker comes in there
and adds an intent filter for something they

00:23:29.340 --> 00:23:34.140
need, they might inadvertently export that
component and it could cause a security vulnerability

00:23:34.140 --> 00:23:36.900
later.

00:23:36.900 --> 00:23:41.080
If you do wish to make your -- whoops, wrong
slide.

00:23:41.080 --> 00:23:46.980
If you do wish to make your components available
but only for limited use, there are permissions

00:23:46.980 --> 00:23:50.120
you can grant in the Androidmanifest.XML.

00:23:50.120 --> 00:23:56.280
These may be listed to the user upon installation,
depending on the protection level they're

00:23:56.280 --> 00:23:57.280
at.

00:23:57.280 --> 00:24:00.910
So if you have a protection level normal,
it's for permissions that you're granting

00:24:00.910 --> 00:24:04.480
to an application that don't really expose
any user data, but you might want the user

00:24:04.480 --> 00:24:09.450
to be aware of if you're scrolling through
the list of permissions that are in there.

00:24:09.450 --> 00:24:13.290
Dangerous is for things that could expose
user data and you do want the user to be aware

00:24:13.290 --> 00:24:14.290
of.

00:24:14.290 --> 00:24:18.730
And finally there's a permission level of
signature which allows you to provide components

00:24:18.730 --> 00:24:25.680
to other applications signed by the same app-signing
keys we discussed before.

00:24:25.680 --> 00:24:30.760
So here's an example of how you define a permission
on an Android manifest.

00:24:30.760 --> 00:24:36.490
Shows that protection level is restricted
to signature and that means the same app-signing

00:24:36.490 --> 00:24:41.100
key that you sign this app with and it's protecting
our service example.

00:24:41.100 --> 00:24:45.890
So if you didn't want the service example
available to other applications or exported,

00:24:45.890 --> 00:24:50.320
it's a good idea to leave that signature in
there and just mark "exported false."

00:24:50.320 --> 00:24:55.240
This is kind of a belt-and-suspenders approach
and it just ensures that if there's any problem

00:24:55.240 --> 00:25:02.430
with the exporting in previous platform versions,
then it's not exported, if you have the same

00:25:02.430 --> 00:25:05.930
sign-in signature.

00:25:05.930 --> 00:25:11.090
So the Android manifest provides really coarse
permission-checking, basically all or nothing

00:25:11.090 --> 00:25:12.090
for some things.

00:25:12.090 --> 00:25:15.960
But if you need to check individual paths
of your code, there's more granular things

00:25:15.960 --> 00:25:18.540
you can do with checking in code.

00:25:18.540 --> 00:25:22.141
For instance, if you register a broadcast
receiver in your code, there's a version of

00:25:22.141 --> 00:25:26.360
the API that specifies what permission the
caller must have before they're allowed to

00:25:26.360 --> 00:25:28.350
invoke that component.

00:25:28.350 --> 00:25:34.930
If you're receiving a binder call, say through
your AIDL file, you can use the enforce call-in

00:25:34.930 --> 00:25:40.100
permissions or check calling permissions methods
to check whether the caller has the appropriate

00:25:40.100 --> 00:25:41.590
permissions.

00:25:41.590 --> 00:25:45.730
And this allows you to avoid the confused
deputy problem.

00:25:45.730 --> 00:25:48.310
So what's a confused deputy problem?

00:25:48.310 --> 00:25:52.050
So we have our Wi-Fi manager here which is
inside the system server which I call the

00:25:52.050 --> 00:25:53.370
strict sheriff.

00:25:53.370 --> 00:25:57.390
And say you want to make a Wi-Fi control app
that enables Wi-Fi peer-to-peer mode like

00:25:57.390 --> 00:25:59.180
we were discussing before.

00:25:59.180 --> 00:26:03.830
So if your app asks the strict sheriff here
whether he's allowed to do it, you would be

00:26:03.830 --> 00:26:04.830
granted.

00:26:04.830 --> 00:26:09.250
It you installed an attacker app that requested
no such permission and he asked the strict

00:26:09.250 --> 00:26:12.690
sheriff, it would be denied.

00:26:12.690 --> 00:26:18.720
But what happens if your app is exposing a
component that is part of the Wi-Fi control

00:26:18.720 --> 00:26:22.500
and the attacker decides that he can ask your
app.

00:26:22.500 --> 00:26:28.310
Well, your app might be asked by the attacker
app, it would ask the strict sheriff, he would

00:26:28.310 --> 00:26:31.910
grant it because you asked for the permission
during installation and your app could return

00:26:31.910 --> 00:26:36.640
some information back to the attacker app
without having the correct permission and

00:26:36.640 --> 00:26:39.000
your app has become the confused deputy.

00:26:39.000 --> 00:26:43.530
He's being deputized by the strict sheriff
and he's leaked information to the other app

00:26:43.530 --> 00:26:45.930
without the correct permission.

00:26:45.930 --> 00:26:53.730
&gt;&gt;Jon Larimer: So now I would like to talk
about protecting your app's data from people

00:26:53.730 --> 00:26:56.060
with physical access to the device.

00:26:56.060 --> 00:26:59.130
And I don't mean the users that installed
your app, they generally have every right

00:26:59.130 --> 00:27:03.800
to access all the data that your app's storing
on the device on their behalf, but I'm talking

00:27:03.800 --> 00:27:08.570
about people who maybe found or stole the
phone from someone.

00:27:08.570 --> 00:27:14.880
The Android debuggable attribute and the Androidmanifest.XML
file turns on debugging for your app.

00:27:14.880 --> 00:27:18.690
And you want to make sure that this isn't
enabled in release builds of your app.

00:27:18.690 --> 00:27:23.000
And it's usually automatically disabled when
you create a replace APK, but if you've been

00:27:23.000 --> 00:27:27.110
messing around with build process, it's possible
to release an APK with it enabled and we have

00:27:27.110 --> 00:27:30.440
seen apps that were released the bug setting
enabled.

00:27:30.440 --> 00:27:35.890
If it is enabled, someone with debug access
to the device, if ADB is enabled and USB-to-bugging

00:27:35.890 --> 00:27:39.910
is enabled they can actually run code with
the same permissions as your app and read

00:27:39.910 --> 00:27:40.910
of your app's data.

00:27:40.910 --> 00:27:42.440
Here you can see how easy it is.

00:27:42.440 --> 00:27:49.080
It takes a single shell command to run another
shell as user ID giving access to the private

00:27:49.080 --> 00:27:53.530
secrets file that's full of secrets.

00:27:53.530 --> 00:27:58.160
Something else that's worth mentioning is
the Android allow backup attribute which isn't

00:27:58.160 --> 00:28:03.760
on this slide but it specifies that your app
allows private data to be backed up by the

00:28:03.760 --> 00:28:05.180
Android backup system.

00:28:05.180 --> 00:28:08.550
And in my opinion this is usually a pretty
good thing.

00:28:08.550 --> 00:28:12.110
Users like being able to back up their data,
but you need to keep in mind that someone

00:28:12.110 --> 00:28:17.530
with ADB access to the device can run ADB
backup and dump all of -- dump the backup

00:28:17.530 --> 00:28:20.930
files, all the app's private data to get access
to this data.

00:28:20.930 --> 00:28:24.570
Like I said, it's usually a good thing in
most cases, but if you have some extremely

00:28:24.570 --> 00:28:29.570
sensitive information that you wouldn't want
someone who stole a phone to have access to,

00:28:29.570 --> 00:28:36.230
then you might want not to allow backups.

00:28:36.230 --> 00:28:40.900
Now let's talk about storing data, and in
particular, storing data in the files on the

00:28:40.900 --> 00:28:42.470
file system.

00:28:42.470 --> 00:28:46.790
So when you store personal data or data that's
protected by a permission, you need to make

00:28:46.790 --> 00:28:49.860
sure that you aren't leaking this data to
other apps.

00:28:49.860 --> 00:28:52.780
And the example I gave at the beginning of
this talk was storing the latest

00:28:52.780 --> 00:28:57.830
GPS location in a world-readable file but
really if there's any information that you

00:28:57.830 --> 00:29:02.590
retrieve from Android that requires a permissions
access or any data that the user enters into

00:29:02.590 --> 00:29:08.340
your app, you don't want it to be world-readable
and you also need to watch out for when you're

00:29:08.340 --> 00:29:09.780
using external storage.

00:29:09.780 --> 00:29:15.590
In Android, the external storage or the SD
card, isn't protected by the same set of granular

00:29:15.590 --> 00:29:20.770
app permissions that private files get and
it was designed to be used as shared storage,

00:29:20.770 --> 00:29:23.300
where any app can access it.

00:29:23.300 --> 00:29:28.370
And in Jelly Bean we added the ability to
protect extra storage with a permission but

00:29:28.370 --> 00:29:30.160
any app can request this permission.

00:29:30.160 --> 00:29:35.630
So this means that if your app is handling
any personal or private data, you really shouldn't

00:29:35.630 --> 00:29:40.060
store it on external storage or the SD card
without asking the user first and making sure

00:29:40.060 --> 00:29:44.670
that they're aware that any other app can
access this data.

00:29:44.670 --> 00:29:48.740
Another important thing I'd like to say is
that you can't trust files that any other

00:29:48.740 --> 00:29:50.130
app can write to.

00:29:50.130 --> 00:29:54.251
It's usually a bad idea to create a world
writeable file anyways, but other apps can

00:29:54.251 --> 00:29:59.590
still get access to write to files that your
app stores in external storage, right, external

00:29:59.590 --> 00:30:01.980
storage permission allows this.

00:30:01.980 --> 00:30:04.760
And I have a couple few really big don'ts
here.

00:30:04.760 --> 00:30:09.580
If you're using any code libraries or external
libraries, don't place the code anywhere that

00:30:09.580 --> 00:30:13.730
it can be written to by other apps.

00:30:13.730 --> 00:30:18.500
Another one is don't write paths to code libraries
in world writeable files because then an app

00:30:18.500 --> 00:30:24.180
can just load that file, change the path of
the file to a library that they control and

00:30:24.180 --> 00:30:29.210
then your app would end up loading that binary
library into their own process space and it

00:30:29.210 --> 00:30:32.470
could be possibly malicious and executing
in the context of your app with all of your

00:30:32.470 --> 00:30:36.990
app's permissions using as your app's user
ID and this has actually happened before in

00:30:36.990 --> 00:30:40.020
some very popular apps.

00:30:40.020 --> 00:30:44.470
If you're going to be reading world writeable
data, you shouldn't do it with native code.

00:30:44.470 --> 00:30:49.710
Dalvik offers protection against memory corruption
vulnerabilities that are really hard to prevent

00:30:49.710 --> 00:30:50.710
in native code.

00:30:50.710 --> 00:30:52.440
It takes a lot of effort.

00:30:52.440 --> 00:30:55.980
And by memory corruption vulnerabilities I
mean the things like buffer overflows or integer

00:30:55.980 --> 00:31:03.990
overflows that lead to arbitrary code execution.

00:31:03.990 --> 00:31:08.640
Here's an example of some good and some bad
code for handling private data files.

00:31:08.640 --> 00:31:13.660
And you can see here that it's pretty easy
to make sure that other apps can't read or

00:31:13.660 --> 00:31:15.150
write to your files.

00:31:15.150 --> 00:31:19.410
And it's actually less characters to type
mode private than mode world readable so it

00:31:19.410 --> 00:31:23.040
actually takes a little bit more effort to
write the apps insecurely.

00:31:23.040 --> 00:31:26.550
And the default value is actually zero so
you could just use zero instead of contacts

00:31:26.550 --> 00:31:29.570
no private.

00:31:29.570 --> 00:31:33.530
So you need to put a little bit of extra effort
into making your app insecure so that's one

00:31:33.530 --> 00:31:38.040
of the examples of it's actually easier to
make a secure app, slightly, very slightly

00:31:38.040 --> 00:31:39.040
easier.

00:31:39.040 --> 00:31:42.420
So something else that you might consider
to protect your files from being accessed

00:31:42.420 --> 00:31:51.020
is encryption but Kenny would like to say
a few words about that So as Jon mentioned,

00:31:51.020 --> 00:31:55.940
permissions don't work on the SD card because
the file system used on the SD card for maximum

00:31:55.940 --> 00:32:00.020
compatibility with consumer electronic devices
like your camera, where you put the SD card

00:32:00.020 --> 00:32:04.050
in, doesn't support the concept of file owners.

00:32:04.050 --> 00:32:08.420
So you might think to yourself, I know, I'll
just encrypt the file I put on the SD card,

00:32:08.420 --> 00:32:10.290
then no bad guy will be able to read them.

00:32:10.290 --> 00:32:14.350
Well, the problem is there's something called
like -- there's some attacks and one of them

00:32:14.350 --> 00:32:16.770
is the chosen-ciphertext attack.

00:32:16.770 --> 00:32:22.210
So what might happen is your encrypt your
loginok=0 in this example, but if the bad

00:32:22.210 --> 00:32:26.570
guy knows that it's always going to be login
okay equals something or he can guess kind

00:32:26.570 --> 00:32:31.420
of the pattern of the file, he can exhort
with the data he thinks it is and then exhort

00:32:31.420 --> 00:32:34.970
with the data he wants it to be, and then
when you later decrypt that file, it will

00:32:34.970 --> 00:32:36.440
become what he wants it to be.

00:32:36.440 --> 00:32:38.960
That's not a good idea.

00:32:38.960 --> 00:32:45.470
So a lot of this problem comes from trying
to compose your own cryptography primitives

00:32:45.470 --> 00:32:50.690
without really understanding the consequences
and the pitfalls you might run into.

00:32:50.690 --> 00:32:54.180
So it's a good idea just to use something
that's been peer-reviewed already, and one

00:32:54.180 --> 00:32:55.870
such library is Keyczar.

00:32:55.870 --> 00:33:00.200
Keyczar was written by the Google security
team, and it's made available under the Apache

00:33:00.200 --> 00:33:05.860
2.0 license and it can handle encryption and
decryption, signing and verification of files

00:33:05.860 --> 00:33:08.850
without much guesswork as to how to actually
use it.

00:33:08.850 --> 00:33:13.100
For instance, on the slide there's a Keyczar
tool you run to create a key pair, the public

00:33:13.100 --> 00:33:14.690
and private part.

00:33:14.690 --> 00:33:19.990
Take that public part and put it in your raw
resources and later on in your application,

00:33:19.990 --> 00:33:24.700
after you've packaged up that public key,
you can -- if you need to send data to your

00:33:24.700 --> 00:33:29.710
server later, you can encrypt your private
data, you can store it away for a while, if

00:33:29.710 --> 00:33:33.850
you want to, but later on you can send it
up to your server and on the server use Keyczar

00:33:33.850 --> 00:33:34.850
to encrypt it.

00:33:34.850 --> 00:33:36.700
And it's really only two lines of code.

00:33:36.700 --> 00:33:41.410
And so it's a lot easier than instantiating
a lot of the Java cryptography objection and

00:33:41.410 --> 00:33:44.730
every API should be that simple, in my opinion.

00:33:44.730 --> 00:33:53.690
I'm working on it, but -- so just to show
how tricky crypto can be, in 1970s Ron Rivest,

00:33:53.690 --> 00:33:57.932
Adi Shamir and Len Adleman took about 42 tries
to get RSA right.

00:33:57.932 --> 00:34:01.150
Those are the R, S, and A in RSA.

00:34:01.150 --> 00:34:02.600
And that means they got it wrong 41 times
beforehand.

00:34:02.600 --> 00:34:05.670
And these guys are experts.

00:34:05.670 --> 00:34:07.800
They've been researching cryptography a long
time.

00:34:07.800 --> 00:34:11.109
So it just shows how easy it is to get things
wrong.

00:34:11.109 --> 00:34:14.990
And more recently, NIST has opened up the
competition for the secure hash algorithm,

00:34:14.990 --> 00:34:17.760
Version 3 or SHA-3.

00:34:17.760 --> 00:34:23.220
64 people entered that, and immediately, crypt
analysts were attacking the algorithms.

00:34:23.220 --> 00:34:27.830
Some were broken immediately, some were deemed
too slow, and some just not secure enough

00:34:27.830 --> 00:34:28.830
in the competition.

00:34:28.830 --> 00:34:33.010
Now, in the third round, there's five people
left, so that means 59 people got some things

00:34:33.010 --> 00:34:34.300
wrong.

00:34:34.300 --> 00:34:38.620
And I just don't want to see anyone in this
room end up in the same area.

00:34:38.620 --> 00:34:44.190
So just use something like cryptography -- or
Keyczar for your cryptography.

00:34:44.190 --> 00:34:50.580
And just to paraphrase a -- one of my favorite
games, it's dangerous to go alone.

00:34:50.580 --> 00:34:57.380
Take this peer-verified cryptography library
with you.

00:34:57.380 --> 00:35:00.630
Now I'd like to talk about protecting the
network trafficking in your app.

00:35:00.630 --> 00:35:03.580
Most apps will connect to the Internet for
something.

00:35:03.580 --> 00:35:07.150
They might be transmitting personal data,
and there's nothing particularly wrong about

00:35:07.150 --> 00:35:11.150
this as long as you include that privacy policy
that Jon talked about.

00:35:11.150 --> 00:35:14.670
But there's a problem if you're transmitting
it unencrypted.

00:35:14.670 --> 00:35:17.670
Now, you can imagine a public Wi-Fi network.

00:35:17.670 --> 00:35:22.110
If someone's on a public Wi-Fi network, anyone
in the room can basically sniff the traffic

00:35:22.110 --> 00:35:23.950
on that public Wi-Fi network.

00:35:23.950 --> 00:35:28.070
And even if you encrypt the public Wi-Fi network,
there might be a problem in the network between

00:35:28.070 --> 00:35:30.140
your server and your client.

00:35:30.140 --> 00:35:34.780
There could be an attacker in there that could
mount what is called a "man in the middle"

00:35:34.780 --> 00:35:35.780
attack.

00:35:35.780 --> 00:35:41.800
They can even inject data into your application
like they could intercept the connection and

00:35:41.800 --> 00:35:45.110
appear as if you're connecting to the server
but they're injecting malicious data into

00:35:45.110 --> 00:35:46.110
your application.

00:35:46.110 --> 00:35:50.140
So you can't even really trust what's coming
into your application even if you know that

00:35:50.140 --> 00:35:54.110
the local network's encrypted.

00:35:54.110 --> 00:35:58.330
So what's the worst that can happen if someone
hijacks a network stream?

00:35:58.330 --> 00:36:03.700
Well, I think the best that could happen is
that they see pictures of my neighbors' cats

00:36:03.700 --> 00:36:06.900
instead of the images they're expecting to
see.

00:36:06.900 --> 00:36:11.430
So I like my neighbors' cats, but you can
imagine something else happening like maybe

00:36:11.430 --> 00:36:16.460
they're injecting malicious data, maybe they're
injecting JavaScript into your WebView.

00:36:16.460 --> 00:36:19.070
It could be anything, really.

00:36:19.070 --> 00:36:23.580
If you've ever been to a hacker conference
like DEF CON or Black Hat in Las Vegas and

00:36:23.580 --> 00:36:26.610
tried to use a public Wi-Fi you might have
seen something -- it might be a little less

00:36:26.610 --> 00:36:32.710
tame than this but you'll know what I mean.

00:36:32.710 --> 00:36:37.140
But in the worst case, your app could be completely
compromised if it's exposing some JavaScript

00:36:37.140 --> 00:36:40.000
interface in the WebView or whatever you're
downloading.

00:36:40.000 --> 00:36:45.369
Luckily it's pretty easy to make -- to enable
encryption if you're using http in Android.

00:36:45.369 --> 00:36:48.490
Just make sure you use https instead of http.

00:36:48.490 --> 00:36:51.600
Just one little letter you put in there makes
a whole lot of difference.

00:36:51.600 --> 00:36:55.040
Of course you need to make sure your server
is supporting https.

00:36:55.040 --> 00:36:58.810
But that's really outside the scope of this
talk and there's plenty of things on the Web

00:36:58.810 --> 00:37:04.140
you can go and search on how to enable https
or SSL on your server.

00:37:04.140 --> 00:37:08.240
Something else to keep in mind is that you
really shouldn't download code into your program.

00:37:08.240 --> 00:37:11.740
Android allows us -- you can download a DEX
file and actually load it into your applications

00:37:11.740 --> 00:37:12.740
process space.

00:37:12.740 --> 00:37:15.550
But it's a really bad idea security-wise.

00:37:15.550 --> 00:37:17.010
So I really wouldn't recommend it.

00:37:17.010 --> 00:37:21.290
And remember the cats from the last slide,
imagine if, instead of the DEX file you intended,

00:37:21.290 --> 00:37:26.100
it's some attacker's DEX file that completely
comprises your application and they'd be able

00:37:26.100 --> 00:37:30.970
to get access to all the data your app has
generated or the permissions it has granted

00:37:30.970 --> 00:37:32.730
by the user.

00:37:32.730 --> 00:37:36.869
If you know what you're doing, you can use
cryptographic signing to ensure that nothing

00:37:36.869 --> 00:37:37.920
like this happens.

00:37:37.920 --> 00:37:43.590
As we saw on the previous slide, it's hard
to get cryptographic signing right.

00:37:43.590 --> 00:37:47.860
It's better to use Android's own updating
mechanism and to provide the freshest data

00:37:47.860 --> 00:37:49.110
to your applications.

00:37:49.110 --> 00:37:56.170
There's a good one in Google Play, by the
way.

00:37:56.170 --> 00:38:00.590
By default, the https stack in Android will
validate SSL certificates against all the

00:38:00.590 --> 00:38:03.880
CAs included in the Android platform.

00:38:03.880 --> 00:38:08.580
This is fine and it provides an adequate level
of security by placing your trust in all the

00:38:08.580 --> 00:38:12.981
trustworthiness of all the CAs, which, I don't
know if you guys have read the news, but there

00:38:12.981 --> 00:38:15.550
was a few break-ins in CAs.

00:38:15.550 --> 00:38:20.619
And when a bad guy breaks into a trusted CA
and generates a rogue certificate for a site,

00:38:20.619 --> 00:38:24.270
if that rogue certificate is used, the user
won't be able to tell because it actually

00:38:24.270 --> 00:38:26.280
validates correctly.

00:38:26.280 --> 00:38:31.280
But breaking into a CA and generating rogue
certificates isn't something that a hobbyist

00:38:31.280 --> 00:38:35.710
hacker or a script kiddie is able to do, these
guys are really serious.

00:38:35.710 --> 00:38:39.600
And they're usually not after money, they're
after information.

00:38:39.600 --> 00:38:44.850
So if your app is used by people in particularly
sensitive areas and you want to protect your

00:38:44.850 --> 00:38:49.119
app a little bit more, you might want to consider
implementing certificate pinning.

00:38:49.119 --> 00:38:54.550
So certificate pinning, if you know some CA
or intermediate certificate in a chain that

00:38:54.550 --> 00:39:00.690
will never change, you can place that certificate
or a group of certificates in a pin set and

00:39:00.690 --> 00:39:06.100
then that means that -- in the pin set and
trust only the group instead of everything

00:39:06.100 --> 00:39:07.910
in the default list.

00:39:07.910 --> 00:39:11.890
And what's even better is if you control the
software which runs on the client, which you

00:39:11.890 --> 00:39:16.570
obviously do, and the server as well, you
can generate your own CA.

00:39:16.570 --> 00:39:19.910
So then you can save a little bit of money
if you're strapped for cash.

00:39:19.910 --> 00:39:24.770
But, of course, if you generate your own CA,
there's some protection you have to put in

00:39:24.770 --> 00:39:25.770
place.

00:39:25.770 --> 00:39:30.310
Like I mentioned before, a big corporation
might have an HSN for assigning capabilities.

00:39:30.310 --> 00:39:34.820
Typically, they have something like they only
take it out at certain times of the year.

00:39:34.820 --> 00:39:39.750
But you should really treat it the same as
your application signing key.

00:39:39.750 --> 00:39:44.119
Make multiple copies, keep a backup and keep
a backup and keep a backup.

00:39:44.119 --> 00:39:48.091
But if you want to find out more about how
to actually pin your certificates, you can

00:39:48.091 --> 00:39:52.210
check the Android documentation for https
URL connection.

00:39:52.210 --> 00:39:58.790
There's some example code in there.

00:39:58.790 --> 00:40:03.510
So now I would like to give you some advice
for using WebView.

00:40:03.510 --> 00:40:08.770
And by default, all JavaScript is disabled
in WebView, and this is good.

00:40:08.770 --> 00:40:13.740
When you enable JavaScript, you open up your
application to attacks like cross-site scripting,

00:40:13.740 --> 00:40:20.230
cross-site request forgery and people could
write heap spray exploits for WebKit bugs.

00:40:20.230 --> 00:40:24.870
There's all sorts of bad things that can happen
if WebView in JavaScript is enabled.

00:40:24.870 --> 00:40:29.350
We don't have time to get deep into those
specific attacks or how to block those attacks

00:40:29.350 --> 00:40:30.350
today.

00:40:30.350 --> 00:40:33.470
It's beyond the scope of this talk and we
just don't have time.

00:40:33.470 --> 00:40:37.660
Keep in mind, you should keep JavaScript disabled
in your WebView unless there is some fundamental

00:40:37.660 --> 00:40:40.450
reason your app requires it.

00:40:40.450 --> 00:40:45.530
Because if an attacker can find a way to inject
arbitrary JavaScript into your application

00:40:45.530 --> 00:40:49.120
either through man-in-the-middle attack as
Kenny was talking about, or even compromising

00:40:49.120 --> 00:40:53.570
your web server, they could end up running
code in the context of your app.

00:40:53.570 --> 00:40:58.340
This is especially dangerous if your WebView
exports a JavaScript interface.

00:40:58.340 --> 00:41:01.890
And the add JavaScript interface method is
really dangerous.

00:41:01.890 --> 00:41:06.530
What this call does is expose your app's functionality
through JavaScript.

00:41:06.530 --> 00:41:11.000
For example, you could write a method at that
reads data from a file in your app's private

00:41:11.000 --> 00:41:15.940
storage and post it back to your server.

00:41:15.940 --> 00:41:21.260
And then you can make this method available
to JavaScript that's running in the WebView.

00:41:21.260 --> 00:41:26.410
If an attacker has any way to control which
JavaScript is running in the WebView, and

00:41:26.410 --> 00:41:30.750
your code -- say your code let's the JavaScript
read any file instead of a specific file,

00:41:30.750 --> 00:41:35.119
like the file name is an argument to the method,
then you could have a major information leak

00:41:35.119 --> 00:41:40.910
on your hands because -- so if you expose
any protected data or any phone capabilities

00:41:40.910 --> 00:41:45.350
through JavaScript, like I said a web site
compromise or man-in-the-middle attack could

00:41:45.350 --> 00:41:48.020
end up executing arbitrary code.

00:41:48.020 --> 00:41:51.820
There are some legitimate uses for using add
JavaScript interface; that's why we put it

00:41:51.820 --> 00:41:52.820
in there.

00:41:52.820 --> 00:41:54.130
It is useful sometimes.

00:41:54.130 --> 00:41:58.620
If you do use it, make sure you are grabbing
the JavaScript over https.

00:41:58.620 --> 00:42:01.610
Make sure it is an encrypted and authenticated
connection.

00:42:01.610 --> 00:42:04.050
Don't expose anything that's protected by
a permission.

00:42:04.050 --> 00:42:09.010
Make sure that the -- any information you
do expose is extremely limited.

00:42:09.010 --> 00:42:13.109
So for example, don't provide a generic interface
for reading and writing files to JavaScript

00:42:13.109 --> 00:42:20.350
and don't expose direct access to content
providers, and definitely don't expose access

00:42:20.350 --> 00:42:22.640
to, like, reflection.

00:42:22.640 --> 00:42:29.310
So you really want to keep the potential attack
surface as small as possible.

00:42:29.310 --> 00:42:33.230
Something else that we like to talk about
is minimizing the permissions that your app

00:42:33.230 --> 00:42:34.350
requests.

00:42:34.350 --> 00:42:38.520
And you already know that requesting too many
unnecessary permissions can get you a lot

00:42:38.520 --> 00:42:40.720
of bad reviews from users.

00:42:40.720 --> 00:42:42.320
People complain on the forums.

00:42:42.320 --> 00:42:48.280
That's not the only problem with requesting
too many permissions in your apps.

00:42:48.280 --> 00:42:52.020
Recently a group of university researchers
found that one third of the app that is they

00:42:52.020 --> 00:42:54.460
tested requested more permissions than they
needed.

00:42:54.460 --> 00:42:59.350
This means that, based on the code that was
in the apps, they requested permissions that

00:42:59.350 --> 00:43:00.870
they didn't have any code that used.

00:43:00.870 --> 00:43:04.960
So there's extra permissions floating around
that weren't really necessary.

00:43:04.960 --> 00:43:09.130
And this is a problem because if there's a
security vulnerability in the app, if an app

00:43:09.130 --> 00:43:13.869
can run arbitrary code in the context of the
app, using one of the vulnerabilities that

00:43:13.869 --> 00:43:19.000
we already talked about, they can take advantage
of any of the permissions that you request.

00:43:19.000 --> 00:43:23.460
So your app might not be using them, but a
malicious app could.

00:43:23.460 --> 00:43:27.780
So I'd like to show you a few examples of
ways that your app can perform common tasks

00:43:27.780 --> 00:43:29.940
without requesting permissions.

00:43:29.940 --> 00:43:33.880
And these are things that most people think
actually require permission and I've seen

00:43:33.880 --> 00:43:37.140
some of this very similar code in apps and
they request a permission that they don't

00:43:37.140 --> 00:43:39.290
need.

00:43:39.290 --> 00:43:42.350
So when I say that you can do these things
without requesting permission, I don't mean

00:43:42.350 --> 00:43:47.680
that you can, like, do these things like access
data secretly behind the user's back without

00:43:47.680 --> 00:43:48.680
permission.

00:43:48.680 --> 00:43:50.280
The user is fully aware of what's going on.

00:43:50.280 --> 00:43:54.380
They are prompted to select the piece of information
to share with your app.

00:43:54.380 --> 00:43:58.550
So in the first example, you'll see how you
don't need to request a permission yourself

00:43:58.550 --> 00:44:02.900
if you call an activity that already has the
permission that your app needs.

00:44:02.900 --> 00:44:07.720
And in the second example, you will see how
content providers can grant temporary permissions

00:44:07.720 --> 00:44:11.980
for your app to access some data.

00:44:11.980 --> 00:44:14.170
So here's one example.

00:44:14.170 --> 00:44:18.300
If you want to let the user take a picture
with a camera and then read that image data

00:44:18.300 --> 00:44:21.340
in your app, you don't need the camera permission
for your app.

00:44:21.340 --> 00:44:26.260
You can just launch the camera system activity
to let the user take a picture and then return

00:44:26.260 --> 00:44:28.180
control to your own app.

00:44:28.180 --> 00:44:33.390
So to make this happen, you fire off an action
image capture intent and specify whatever

00:44:33.390 --> 00:44:35.730
output file name that you want.

00:44:35.730 --> 00:44:39.400
You can use start activity for result to make
sure that your app gets called back with the

00:44:39.400 --> 00:44:41.570
data whenever the activity is complete.

00:44:41.570 --> 00:44:46.420
So in this case, after the user takes the
picture, your on activity result callback

00:44:46.420 --> 00:44:50.390
in your class gets the file path and you can
read the file.

00:44:50.390 --> 00:44:54.051
So from the user's perspective and from a
security and privacy perspective, this is

00:44:54.051 --> 00:44:58.820
a lot safer than granting camera to the app
and writing a bunch of code to interface with

00:44:58.820 --> 00:44:59.820
the camera API.

00:44:59.820 --> 00:45:02.550
The user gets to pick the photo to that is
sent to the app.

00:45:02.550 --> 00:45:07.040
Can't open the camera -- can't read camera
data without actually opening the camera and

00:45:07.040 --> 00:45:08.790
the user seeing it there.

00:45:08.790 --> 00:45:15.440
There's no reason to request the camera permission
unless you are actually writing a camera app

00:45:15.440 --> 00:45:18.080
yourself.

00:45:18.080 --> 00:45:21.970
Another example is letting the user send an
SMS message.

00:45:21.970 --> 00:45:25.790
Instead of requesting the send SMS permission
and going through all of the effort of talking

00:45:25.790 --> 00:45:30.810
to the telephony manager to send an SMS message,
you can create an intent and start an activity

00:45:30.810 --> 00:45:35.359
to launch as the system SMS app with the message
and app that you choose.

00:45:35.359 --> 00:45:38.870
This way the user gets to see the destination
phone number and message.

00:45:38.870 --> 00:45:43.140
They will have an option of either sending
it or declining to send it if they aren't

00:45:43.140 --> 00:45:44.140
comfortable with it.

00:45:44.140 --> 00:45:45.230
Or they can change the message.

00:45:45.230 --> 00:45:51.270
Obviously, this won't work for an app that
-- for every app that has SMS features.

00:45:51.270 --> 00:45:54.980
But if SMS is just a minor part of your app,
for example if you want to let the user share

00:45:54.980 --> 00:45:59.210
a link to your app to one of their contacts
through SMS, letting them send the message

00:45:59.210 --> 00:46:00.580
this way makes a lot of sense.

00:46:00.580 --> 00:46:04.940
You don't have to worry about freaking the
user out by requiring send SMS permission

00:46:04.940 --> 00:46:10.230
if that's the only feature you will be using
it for.

00:46:10.230 --> 00:46:14.680
Something else that's pretty neat is that
content providers can grant temporary permissions

00:46:14.680 --> 00:46:15.680
to apps.

00:46:15.680 --> 00:46:22.080
An app can use the action pic or ActionGetContent
to have the system launch an activity that

00:46:22.080 --> 00:46:25.670
let's the user pick the information they want
to share with your apps.

00:46:25.670 --> 00:46:26.670
Here's an example.

00:46:26.670 --> 00:46:30.160
Let's say you want to get some contact information
from the user.

00:46:30.160 --> 00:46:33.790
So instead of requiring the read contacts
permission and spending a bunch of time writing

00:46:33.790 --> 00:46:38.790
a new widget to let users scroll through the
contacts and pick the ones they want.

00:46:38.790 --> 00:46:45.531
You can use ActionGetContent with the mine
type of phone.content item type, and the Android

00:46:45.531 --> 00:46:50.280
system will pop up a contact chooser that
let's the user pick which contact they want.

00:46:50.280 --> 00:46:56.280
When the user makes their choice, the on activity
result callback for your class is called.

00:46:56.280 --> 00:46:59.130
Then you can use a content resolver to read
the data that you want.

00:46:59.130 --> 00:47:04.369
This works because the context content provider
grants a temporary URI-based permission, which

00:47:04.369 --> 00:47:08.760
we really didn't get into, to your app for
this one piece of information.

00:47:08.760 --> 00:47:12.430
Your app can read this contact but it can't
read any others and they don't have access

00:47:12.430 --> 00:47:18.970
to read the full list and the user picks the
contact themself.

00:47:18.970 --> 00:47:23.440
So I think users will feel much better about
this privacy and security-wise than just granting

00:47:23.440 --> 00:47:31.130
blanket access to your app to read the entire
contact list.

00:47:31.130 --> 00:47:37.270
Another thing I want to talk about minimizing
permissions is identifying app installations.

00:47:37.270 --> 00:47:38.780
And this is a pretty common problem.

00:47:38.780 --> 00:47:42.130
There are a lot of reasons why you'd want
to identify unique installations, whether

00:47:42.130 --> 00:47:48.760
it be for licensing or tracking game scores
or advertising or even just getting an accurate

00:47:48.760 --> 00:47:51.670
count of the active users I don't have you
are app.

00:47:51.670 --> 00:47:56.170
People seem to be inclined to use get device
ID for this or the sim serial number or some

00:47:56.170 --> 00:47:59.539
hardware-based ID.

00:47:59.539 --> 00:48:03.349
The hardware IDs aren't great values for tracking
installs.

00:48:03.349 --> 00:48:08.900
The device ID isn't really reliable on -- and
some devices, and on some customer OMs it's

00:48:08.900 --> 00:48:11.320
just set to a fixed value.

00:48:11.320 --> 00:48:14.930
There was a very popular phone that's shipped
that's still widely used today that had a

00:48:14.930 --> 00:48:17.170
fixed device ID on every single phone.

00:48:17.170 --> 00:48:21.800
There was also the privacy implication that
the user can't change this value without buying

00:48:21.800 --> 00:48:23.260
a new phone.

00:48:23.260 --> 00:48:27.341
If someone decides to do a factor reset on
their device and sell the phone to someone

00:48:27.341 --> 00:48:32.349
else, and then the buyer also purchases your
app, they can see some weird stuff if your

00:48:32.349 --> 00:48:35.350
app is associating that phone with another
user.

00:48:35.350 --> 00:48:38.670
You don't want the new owner of the phone
to see all of the old user's personal data

00:48:38.670 --> 00:48:42.730
if you are storing it keyed on the device
ID.

00:48:42.730 --> 00:48:45.320
So you could use the Android ID to track installs.

00:48:45.320 --> 00:48:49.150
It doesn't require permission and it does
get changed on a device swipe.

00:48:49.150 --> 00:48:52.130
But this really still isn't ideal.

00:48:52.130 --> 00:48:57.960
My favorite method is -- security and privacy-wise,
is just generate an UUID, universal unique

00:48:57.960 --> 00:49:02.450
identifier, when the app starts up for the
first time and then store it in the shared

00:49:02.450 --> 00:49:03.800
preferences file.

00:49:03.800 --> 00:49:08.630
Then you can use the Android backup system
so the shared preference file for your app

00:49:08.630 --> 00:49:10.730
is synced up to the Cloud.

00:49:10.730 --> 00:49:13.200
That way the user can actually wipe the ID
if they want.

00:49:13.200 --> 00:49:16.460
They can go to the system settings and clear
the apps data.

00:49:16.460 --> 00:49:20.359
If they feel like they need to do a factory
reset of the phone, they can do a backup,

00:49:20.359 --> 00:49:25.980
factory reset their phone, resync the device
back to the Cloud and your ID will still be

00:49:25.980 --> 00:49:28.810
there and will still see the same data from
the app.

00:49:28.810 --> 00:49:31.060
This is really the best of both worlds.

00:49:31.060 --> 00:49:35.010
The value is persistent across swipes if the
user wants it to be, or they can erase the

00:49:35.010 --> 00:49:37.849
value without doing a full factory reset.

00:49:37.849 --> 00:49:44.710
So it ends up working a lot like web browser
cookie.

00:49:44.710 --> 00:49:48.410
So now let's talk a bit about device administrator
access.

00:49:48.410 --> 00:49:53.470
The Android device administration API let's
anyone develop and publish apps that can control

00:49:53.470 --> 00:49:57.190
the administrative security features of the
device.

00:49:57.190 --> 00:50:02.400
Things like requiring a lock screen with a
complex password or requiring encryption,

00:50:02.400 --> 00:50:06.210
disabling the camera or doing something fun
like wiping the device.

00:50:06.210 --> 00:50:10.750
So if your app does request device administrator
privileges, it works a little differently

00:50:10.750 --> 00:50:14.010
than the normal permission system.

00:50:14.010 --> 00:50:17.170
Users can actually revoke device administration
privileges.

00:50:17.170 --> 00:50:20.480
And the privileges are also granted on a more
granular basis.

00:50:20.480 --> 00:50:24.660
An app can ask for the ability to enforce
the password length or password complexity

00:50:24.660 --> 00:50:27.080
but still not be able to wipe the device.

00:50:27.080 --> 00:50:32.041
And some issues we have seen in the past are
that people who install apps that require

00:50:32.041 --> 00:50:36.880
device administration access, they can't uninstall
these apps unless device administration is

00:50:36.880 --> 00:50:38.260
disabled.

00:50:38.260 --> 00:50:41.340
Android versions up to Gingerbread, there
wasn't really a clear error here.

00:50:41.340 --> 00:50:42.460
It would say uninstall failed.

00:50:42.460 --> 00:50:46.680
The user would have no idea why they can't
uninstall these apps and they think it's malware.

00:50:46.680 --> 00:50:50.690
But in Ice Cream Sandwich and up, the user
has the option of going directly to the settings

00:50:50.690 --> 00:50:52.290
to disable the app.

00:50:52.290 --> 00:50:58.520
So if you're using device administrator access
in a normal app and not like an actual enterprise

00:50:58.520 --> 00:51:03.900
mobile device management solution, for example
if you developing a lock screen or a replacement

00:51:03.900 --> 00:51:08.320
for the default launcher, make sure that your
users are aware of the power that they are

00:51:08.320 --> 00:51:09.750
giving your app.

00:51:09.750 --> 00:51:13.240
Make sure that they know that they have a
disabled device administrator privileges to

00:51:13.240 --> 00:51:15.960
uninstall your app.

00:51:15.960 --> 00:51:19.150
And I have been saying the whole time that
you need to be really careful with security

00:51:19.150 --> 00:51:24.160
but you should be really careful if your app
has access to any of the more dangerous device

00:51:24.160 --> 00:51:27.869
administrator privileges because accidentally
leaking someone's private notes or their email

00:51:27.869 --> 00:51:29.600
address is one thing.

00:51:29.600 --> 00:51:32.880
But letting some other app wipe the device
without permission is a whole other problem

00:51:32.880 --> 00:51:38.890
and you really don't want to have to deal
with that.

00:51:38.890 --> 00:51:43.890
So I don't know if you guys have seen it,
but we reasonably started including a tool

00:51:43.890 --> 00:51:46.680
call Android Lint with the Android SDK.

00:51:46.680 --> 00:51:50.760
It's been there since around version 16 of
the development kit tools.

00:51:50.760 --> 00:51:56.580
And what it does is it scans your Android
project source code, the Java and the XML

00:51:56.580 --> 00:51:59.119
files, for potential bugs.

00:51:59.119 --> 00:52:05.120
Besides normal bugs like bugs that can crash
your program or performance issues, Lint actually

00:52:05.120 --> 00:52:09.369
checks for several potential security issues
that we talked about today, too.

00:52:09.369 --> 00:52:13.950
And Lint is integrated with Eclipse, so if
it finds an issue, it will generate a warning

00:52:13.950 --> 00:52:17.070
and point the problem out to you with the
yellow squiggly line that you probably can't

00:52:17.070 --> 00:52:20.840
see on the projector under mode world writable.

00:52:20.840 --> 00:52:24.320
When you do see this warning, you can hover
the mouse over it and click a menu option

00:52:24.320 --> 00:52:25.950
to get more detailed information.

00:52:25.950 --> 00:52:31.810
Here you can see we are urging you to carefully
review the code that's creating a world writable

00:52:31.810 --> 00:52:32.810
file.

00:52:32.810 --> 00:52:34.400
It tells you not to write any private data
to the file.

00:52:34.400 --> 00:52:38.180
It let's you know if the file is modified
by malicious code, it can compromise your

00:52:38.180 --> 00:52:40.869
entire application.

00:52:40.869 --> 00:52:45.690
Besides looking for world readable and world
writable files, Lint also checks for exported

00:52:45.690 --> 00:52:49.349
application components that can be accessed
without permission.

00:52:49.349 --> 00:52:54.550
It's not always a vulnerability to export
a service or broadcast receiver or a content

00:52:54.550 --> 00:52:55.740
provider without permission.

00:52:55.740 --> 00:52:59.990
Sometimes that's exactly what you're intending
to do, but Lint is there to make sure that

00:52:59.990 --> 00:53:01.590
you know that you are doing it.

00:53:01.590 --> 00:53:06.060
So when you see these Lint security warnings,
whatever you do, don't ignore them.

00:53:06.060 --> 00:53:11.140
You can suppress the warnings with an annotation,
it's just a menu option and adds the code

00:53:11.140 --> 00:53:15.720
automatically, but you should really only
do that once you understand the security issue

00:53:15.720 --> 00:53:20.490
that is causing the warning and fully aware
of the implications that -- of what you are

00:53:20.490 --> 00:53:21.490
doing.

00:53:21.490 --> 00:53:25.540
You could be making a huge mistake by ignoring
a security warning from Lint.

00:53:25.540 --> 00:53:28.000
And we're also adding new security checks.

00:53:28.000 --> 00:53:31.210
So make sure you are always using the latest
build of the SDK tools.

00:53:31.210 --> 00:53:38.490
The SDK tools are released independently of
the Android operating system, so it's updated

00:53:38.490 --> 00:53:39.720
a lot more frequently.

00:53:39.720 --> 00:53:42.080
It's also developed mostly in open source.

00:53:42.080 --> 00:53:44.210
So you can check out the source for Lint.

00:53:44.210 --> 00:53:46.460
If you have ideas for more checks, you can
feel free to add them.

00:53:46.460 --> 00:53:48.370
We will put them in the source code.

00:53:48.370 --> 00:53:53.670
So definitely check that out if you haven't
seen it.

00:53:53.670 --> 00:53:58.030
And we do have a lot of documentation on the
Android developer site and Android open source

00:53:58.030 --> 00:53:59.030
project site.

00:53:59.030 --> 00:54:02.359
There's some other good references out there,
too.

00:54:02.359 --> 00:54:07.880
The Android security overview site describes
the security features in Android and how they

00:54:07.880 --> 00:54:08.880
are implemented.

00:54:08.880 --> 00:54:11.640
You should definitely check that out to get
a deeper understanding of Android's security

00:54:11.640 --> 00:54:16.030
architecture and some of the underlying features
of the operating system that provide the basis

00:54:16.030 --> 00:54:21.900
for the Android permission model and the various
security features the operating system provides.

00:54:21.900 --> 00:54:26.099
The designing for security page tells you
how to write apps with security in mind.

00:54:26.099 --> 00:54:30.140
This is probably the most important document
that you need to read to be able to design

00:54:30.140 --> 00:54:31.690
and develop your app securely.

00:54:31.690 --> 00:54:35.250
And on that page you will find a lot of the
same information that we talked about today.

00:54:35.250 --> 00:54:38.410
How to avoid world readable and world writable
files.

00:54:38.410 --> 00:54:43.160
How to protect your application components,
and encrypted network communications.

00:54:43.160 --> 00:54:45.780
So definitely take a look at that if you haven't
seen it.

00:54:45.780 --> 00:54:47.360
It's a relatively new document.

00:54:47.360 --> 00:54:49.750
We just put it up a few months ago or late
last year.

00:54:49.750 --> 00:54:52.660
I'm not sure how many people have seen it.

00:54:52.660 --> 00:54:56.119
Then there's the documentation on the security
and permissions in Android.

00:54:56.119 --> 00:55:00.839
If you do decide to export some of your application
components and require permission, definitely

00:55:00.839 --> 00:55:04.380
read the permissions documentation very thoroughly.

00:55:04.380 --> 00:55:09.210
It covers all aspect of the permission system
and there's a lot of good stuff that you need

00:55:09.210 --> 00:55:10.210
to know.

00:55:10.210 --> 00:55:14.040
And something else you might want to check
out is a book buy Jeff Six called Application

00:55:14.040 --> 00:55:16.390
Security For The Android Platform.

00:55:16.390 --> 00:55:20.560
It's short, a little over 100 pages, maybe
115 pages.

00:55:20.560 --> 00:55:22.619
It's still very thorough.

00:55:22.619 --> 00:55:26.590
We would like to think that the short lent
of this book is a testament to how easy it

00:55:26.590 --> 00:55:30.400
is to write secure apps in Android.

00:55:30.400 --> 00:55:34.230
&gt;&gt;Kenny Root: Thanks everyone.

00:55:34.230 --> 00:55:39.220
If you have any questions about the Android
platform security features or general discussion,

00:55:39.220 --> 00:55:43.460
there is a group called Android Security Discuss
on Google Groups.

00:55:43.460 --> 00:55:48.839
If you want to report a security vulnerability
in the Android platform or any Google apps,

00:55:48.839 --> 00:55:53.200
you can send email to security@android.com.

00:55:53.200 --> 00:55:58.651
And we will probably be doing a Google hangout
-- Google+ hangout with the Android developer

00:55:58.651 --> 00:56:00.730
office hours in August sometime.

00:56:00.730 --> 00:56:04.400
So if you can't think of your question right
now, we will be hanging out with Reto and

00:56:04.400 --> 00:56:08.950
the other guys on the Google+ hangout.

00:56:08.950 --> 00:56:11.099
We only have about three minutes left.

00:56:11.099 --> 00:56:13.210
We might be able to take a few questions.

00:56:13.210 --> 00:56:22.319
But if you line up at the microphones in the
aisle, we will answer your questions.

00:56:22.319 --> 00:56:31.589
[ Applause ]
&gt;&gt;&gt; Can you tell us what exactly the device

00:56:31.589 --> 00:56:37.670
encryption setting does and also how does
rooting affect security?

00:56:37.670 --> 00:56:42.130
&gt;&gt;Kenny Root: So device encryption, you mean
the disk encryption?

00:56:42.130 --> 00:56:43.530
Whole device encryption?

00:56:43.530 --> 00:56:44.970
&gt;&gt;&gt; Yes, in the settings.

00:56:44.970 --> 00:56:51.220
&gt;&gt;Kenny Root: What it does, it basically turns
on -- on a low level, it use the Linux kernel

00:56:51.220 --> 00:56:56.030
de-encrypt to encrypt the entire slash data
partition.

00:56:56.030 --> 00:56:59.770
It basically encrypts it in place.

00:56:59.770 --> 00:57:01.980
What was the other part -- how does rooting
--

00:57:01.980 --> 00:57:02.980
&gt;&gt;&gt; Rooting.

00:57:02.980 --> 00:57:05.839
&gt;&gt;Kenny Root: How does rooting affect security?

00:57:05.839 --> 00:57:13.170
&gt;&gt;&gt; My concern is if somebody is rooting the
phone, does an app have access to your data

00:57:13.170 --> 00:57:15.750
even if you have that encryption option turned
on?

00:57:15.750 --> 00:57:19.250
&gt;&gt;Kenny Root: It depends on what it does exactly.

00:57:19.250 --> 00:57:22.950
Basically when your device is running, it
has to access the data.

00:57:22.950 --> 00:57:29.030
So if you -- if there's an application that
runs, it's going to be able to access the

00:57:29.030 --> 00:57:30.720
data because it is unencrypted to the operating
system.

00:57:30.720 --> 00:57:37.650
If it was totally encrypted for everything,
the device would be a brick basically.

00:57:37.650 --> 00:57:43.390
If you have root permissions, you can read
some other applications.

00:57:43.390 --> 00:57:48.800
&gt;&gt;&gt; So you guys have this ability to request
a different context in the SDK.

00:57:48.800 --> 00:57:52.869
Can you explain how that works with your security
model and whether or not another application

00:57:52.869 --> 00:57:54.650
can request your resource bundle.

00:57:54.650 --> 00:57:59.950
&gt;&gt;Kenny Root: Depends on if you have what's
called forward locking.

00:57:59.950 --> 00:58:04.120
So basically you can request resources for
other applications.

00:58:04.120 --> 00:58:07.450
This is what allows third-party launchers
to work.

00:58:07.450 --> 00:58:11.770
So if you wanted to make a launcher, we load
up an icon or other resources, you have to

00:58:11.770 --> 00:58:16.109
have that available for other third-party
launchers to be able to use.

00:58:16.109 --> 00:58:17.109
That's why it's there.

00:58:17.109 --> 00:58:22.130
You can also do things like create add-on
processes where you just install an application,

00:58:22.130 --> 00:58:26.240
doesn't really have any code, but it can have
resources that you can load.

00:58:26.240 --> 00:58:32.430
So you can enable the forward locking but
I think they took it out of the developer

00:58:32.430 --> 00:58:34.600
console for Market.

00:58:34.600 --> 00:58:38.369
&gt;&gt;&gt; Just to be clear, does that mean other
applications can access my resources?

00:58:38.369 --> 00:58:41.200
&gt;&gt;Kenny Root: Depends on where the resources
are.

00:58:41.200 --> 00:58:42.260
But, yeah.

00:58:42.260 --> 00:58:43.920
&gt;&gt;&gt; Is there more guidance?

00:58:43.920 --> 00:58:46.650
The documentation online leaves something
to be desired.

00:58:46.650 --> 00:58:50.010
&gt;&gt;Kenny Root: Yeah, I don't know exactly where
it would be.

00:58:50.010 --> 00:58:53.590
But I'll look it up and get back to you.

00:58:53.590 --> 00:58:54.590
&gt;&gt;&gt; Okay, thanks.

00:58:54.590 --> 00:58:59.830
&gt;&gt;&gt; Are you guys familiar with sequel cipher
for Android and if so, what are your impressions?

00:58:59.830 --> 00:59:02.130
&gt;&gt;Kenny Root: I'm not familiar with it.

00:59:02.130 --> 00:59:03.780
&gt;&gt;Jon Larimer: I'm not familiar.

00:59:03.780 --> 00:59:10.270
&gt;&gt;&gt; It is a drop-in replacement for SQLite,
identical API, so you just use different imports

00:59:10.270 --> 00:59:12.140
for SQLite database.

00:59:12.140 --> 00:59:14.530
It provides full encryption of the database.

00:59:14.530 --> 00:59:17.730
&gt;&gt;Kenny Root: I haven't heard of it.

00:59:17.730 --> 00:59:20.470
&gt;&gt;Jon Larimer: I don't know it.

00:59:20.470 --> 00:59:21.470
&gt;&gt;&gt; It's good.

00:59:21.470 --> 00:59:22.470
&gt;&gt;Jon Larimer: Somebody says it's good.

00:59:22.470 --> 00:59:27.700
&gt;&gt;&gt; It adds a bit to the package size but
the cost of having it self-secure.

00:59:27.700 --> 00:59:32.890
&gt;&gt;Kenny Root: So adds to package size at the
cost of users being mad it takes up too much

00:59:32.890 --> 00:59:33.890
room.

00:59:33.890 --> 00:59:36.839
&gt;&gt;&gt; Posting on the Motorola forum, something
about log --

00:59:36.839 --> 00:59:43.080
&gt;&gt;Kenny Root: I think we have time for one
more question.

00:59:43.080 --> 00:59:45.190
We have 20 seconds.

00:59:45.190 --> 00:59:50.680
&gt;&gt;&gt; It's my understanding that factory data
reset doesn't actually delete user's data

00:59:50.680 --> 00:59:53.590
or do any sort of encryption or anything like
that.

00:59:53.590 --> 00:59:59.260
I've heard reports of people doing factory
data reset with the impression that everything

00:59:59.260 --> 01:00:03.070
would be completely hidden and then someone
buying their phone that knew what they were

01:00:03.070 --> 01:00:04.070
doing.

01:00:04.070 --> 01:00:08.450
&gt;&gt;Kenny Root: On some phones if you don't
have an SD card or if you have an SD card,

01:00:08.450 --> 01:00:13.050
it won't wipe the SD card, a lot of people
take it out when they sell the phone.

01:00:13.050 --> 01:00:19.300
On phones that have USB storage, no removable
SD card, there's an option that says delete

01:00:19.300 --> 01:00:20.650
everything, including photos.

01:00:20.650 --> 01:00:25.000
&gt;&gt;&gt; Even if you -- even the data that is supposedly
deleting, it's actually just marking.

01:00:25.000 --> 01:00:28.200
&gt;&gt;Kenny Root: If you are really paranoid,
you can always enable hold this encryption.

01:00:28.200 --> 01:00:30.691
Basically that throws away the keys.

01:00:30.691 --> 01:00:32.349
&gt;&gt;&gt; I have my phone encryption.

01:00:32.349 --> 01:00:39.010
My main question is really -- since it is
not really getting rid of that data, is there

01:00:39.010 --> 01:00:43.510
any steps that we're supposed to be taking
to make sure that if someone finds themself

01:00:43.510 --> 01:00:46.140
in that situation, the data in our apps is
not accessible.

01:00:46.140 --> 01:00:50.470
&gt;&gt;Kenny Root: If you enable hold this encryption
when you do factory reset, it is getting rid

01:00:50.470 --> 01:00:51.470
of the data.

01:00:51.470 --> 01:00:53.700
&gt;&gt;Jon Larimer: We are out of time for questions.

01:00:53.700 --> 01:01:00.039
But we will hang out up here on stage and
you guys can come up and talk to us.

01:01:00.039 --> 01:01:00.430
[ Applause ]

