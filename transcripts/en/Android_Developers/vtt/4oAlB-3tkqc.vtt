WEBVTT
Kind: captions
Language: en

00:00:00.499 --> 00:00:01.870
TIM MURRAY: My name Tim Murray.

00:00:01.870 --> 00:00:04.780
I'm from the Android
Performance Team.

00:00:04.780 --> 00:00:07.550
And I'm going to talk about
Systrace, which we already

00:00:07.550 --> 00:00:10.570
talked about a bit earlier,
with the system tracing

00:00:10.570 --> 00:00:12.190
in Android Studio.

00:00:12.190 --> 00:00:18.190
But I'm going to talk more
about the old style of looking

00:00:18.190 --> 00:00:23.650
at traces, as well as what
you actually do with a trace.

00:00:23.650 --> 00:00:29.370
So what are the big
performance goals for a game?

00:00:29.370 --> 00:00:33.290
There are really two big ones.

00:00:33.290 --> 00:00:36.220
Number one, you need to
get the game play fast.

00:00:36.220 --> 00:00:44.010
The user has to wait 10, 20, 30
seconds to launch a game, then,

00:00:44.010 --> 00:00:44.927
they're going to quit.

00:00:44.927 --> 00:00:46.801
They're not going to be
happy with your game.

00:00:46.801 --> 00:00:48.870
They're going to
find another game.

00:00:48.870 --> 00:00:52.020
The other thing is, you need
to maintain interactivity

00:00:52.020 --> 00:00:53.572
during gameplay.

00:00:53.572 --> 00:00:55.530
It's great if you get to
the game to play fast.

00:00:55.530 --> 00:00:58.140
But if the gameplay
is super janky,

00:00:58.140 --> 00:01:02.940
dropping frames all over
the place, it's really bad.

00:01:02.940 --> 00:01:07.350
So the problem is mobile
devices are really complicated.

00:01:07.350 --> 00:01:09.600
You know, you look at a
current flagship phone

00:01:09.600 --> 00:01:14.040
and it's an eight-core CPU
with heterogeneous CPU cores.

00:01:16.950 --> 00:01:19.920
And there is a giant GPU.

00:01:19.920 --> 00:01:23.220
And your flash performance is
totally different than what

00:01:23.220 --> 00:01:25.080
you would expect on a PC.

00:01:25.080 --> 00:01:28.040
There's a lot going on.

00:01:28.040 --> 00:01:33.410
You really can't assume anything
about how your code runs.

00:01:33.410 --> 00:01:36.800
I've been looking at
performance for years now.

00:01:36.800 --> 00:01:39.110
I can't predict
how code will run.

00:01:39.110 --> 00:01:42.140
No one should assume
how their code runs.

00:01:42.140 --> 00:01:43.880
So that's why we have Systrace.

00:01:43.880 --> 00:01:47.870
It shows you what
actually is running.

00:01:47.870 --> 00:01:51.460
It is sort of truth,
capital T, Truth.

00:01:51.460 --> 00:01:54.230
If Systrace says something
ran at a certain time,

00:01:54.230 --> 00:01:56.270
it ran at a certain time.

00:01:56.270 --> 00:01:57.620
You cannot lie to it.

00:01:57.620 --> 00:01:59.640
You cannot trick it.

00:01:59.640 --> 00:02:02.990
It's outputting events
from the kernel directly.

00:02:02.990 --> 00:02:04.550
Whatever Systrace
says is happening

00:02:04.550 --> 00:02:07.490
is actually happening,
which makes it really great.

00:02:07.490 --> 00:02:10.820
The other great thing about
it, because it's so low level,

00:02:10.820 --> 00:02:15.170
the overhead is basically zero.

00:02:15.170 --> 00:02:17.900
We will just turn on
Systrace and let it stream

00:02:17.900 --> 00:02:20.650
into a buffer, like
an in-memory buffer.

00:02:20.650 --> 00:02:25.820
So you can get the last 10
or 20 seconds out of it.

00:02:25.820 --> 00:02:27.510
It has no measurable overhead.

00:02:27.510 --> 00:02:30.440
It's sub-1%.

00:02:30.440 --> 00:02:31.340
So we do that.

00:02:31.340 --> 00:02:33.330
And we find a ton of
performance bugs that way.

00:02:33.330 --> 00:02:33.830
It's great.

00:02:36.340 --> 00:02:38.710
So first of all, let's talk
about how to take a trace.

00:02:38.710 --> 00:02:41.320
And I'm going to not talking
about the Android Studio

00:02:41.320 --> 00:02:44.080
side of things, because we
already talked about that.

00:02:44.080 --> 00:02:47.410
I'm going to talk about
the two other ways we

00:02:47.410 --> 00:02:50.050
have to take a trace.

00:02:50.050 --> 00:02:55.180
So first of all, most of
the tools for tracing, other

00:02:55.180 --> 00:02:57.520
than Android Studio, exist
in this open source project

00:02:57.520 --> 00:03:02.260
called Catapult. It's maintained
by people from the Android

00:03:02.260 --> 00:03:03.890
team and the Chrome team.

00:03:03.890 --> 00:03:05.230
And it lives on GitHub.

00:03:05.230 --> 00:03:08.800
So you grab the Git
Repo for Catapult,

00:03:08.800 --> 00:03:13.210
and you end up with a
Systrace Python binary in that

00:03:13.210 --> 00:03:17.170
directory,
catapult/systrace/bin/systrace.

00:03:17.170 --> 00:03:22.027
And that's the main
shell to using Systrace.

00:03:22.027 --> 00:03:24.110
If you want to take a trace
from the command line,

00:03:24.110 --> 00:03:27.680
essentially, you run that,
and you pass a bunch of,

00:03:27.680 --> 00:03:32.390
they're called
tags, to Systrace.

00:03:32.390 --> 00:03:37.530
And this will determine the kind
of output you get in the trace.

00:03:37.530 --> 00:03:41.150
So here it's going to take
a trace containing schedule

00:03:41.150 --> 00:03:46.100
information, so exactly what the
scheduler is doing at any given

00:03:46.100 --> 00:03:51.110
time, CPU frequency and
CPU idle information,

00:03:51.110 --> 00:03:53.360
some Android Activity
Manager and Window Manager

00:03:53.360 --> 00:03:56.120
information, then a
bunch of information

00:03:56.120 --> 00:03:59.335
about the graphic stack, and
then a bunch more things--

00:03:59.335 --> 00:04:01.200
well, input is
useful for game devs,

00:04:01.200 --> 00:04:04.038
but the other ones
aren't too useful.

00:04:04.038 --> 00:04:07.080
Input shows you when an
actual touch event happens,

00:04:07.080 --> 00:04:09.590
so that's really useful
for game developers.

00:04:09.590 --> 00:04:12.800
The last three
options are not tags.

00:04:12.800 --> 00:04:15.950
So -b is the buffer size.

00:04:15.950 --> 00:04:19.339
The buffer size determines
how much you can actually

00:04:19.339 --> 00:04:21.680
record in a trace.

00:04:21.680 --> 00:04:26.640
So it's a per CPU
ring buffer in memory.

00:04:26.640 --> 00:04:29.460
So here, this is in kilobytes.

00:04:29.460 --> 00:04:34.610
So on this device, I
get 16 megs per CPU.

00:04:34.610 --> 00:04:39.910
Generally, 10 megs or
so per CPU is totally

00:04:39.910 --> 00:04:41.895
fine on a high-end device.

00:04:41.895 --> 00:04:44.160
It depends how much
context switching you're

00:04:44.160 --> 00:04:49.480
doing, because that is probably
what occupies the most space

00:04:49.480 --> 00:04:51.800
most of the time.

00:04:51.800 --> 00:04:54.040
You can get about--

00:04:54.040 --> 00:04:56.290
I would say it's
about one meg gets you

00:04:56.290 --> 00:04:58.200
about two seconds of a trace.

00:04:58.200 --> 00:05:00.863
So you could record a
pretty long trace with this.

00:05:00.863 --> 00:05:06.940
- t is an optional
argument that tells you how

00:05:06.940 --> 00:05:08.170
long to record the trace for.

00:05:08.170 --> 00:05:13.360
If you don't pass -t, you just
press Enter to stop the trace.

00:05:13.360 --> 00:05:15.820
And then -o is where
to write the trace.

00:05:15.820 --> 00:05:17.290
If you don't pass
-o, it defaults

00:05:17.290 --> 00:05:21.024
to trace.html, which is
fine, but also very annoying

00:05:21.024 --> 00:05:22.690
when you start taking
hundreds of traces

00:05:22.690 --> 00:05:24.064
and they're all
named trace.html.

00:05:26.590 --> 00:05:28.960
So here's the cool new
thing in Android P,

00:05:28.960 --> 00:05:33.370
which is actually
incredibly useful.

00:05:33.370 --> 00:05:36.550
So it's really annoying to have
to have your phone plugged in

00:05:36.550 --> 00:05:37.750
to take a trace.

00:05:37.750 --> 00:05:41.250
And most of Systrace
actually lives on the device.

00:05:41.250 --> 00:05:43.810
The Systrace binary is
basically just talking

00:05:43.810 --> 00:05:45.610
to device-side stuff.

00:05:45.610 --> 00:05:47.410
So in Android P, we
made it so you can

00:05:47.410 --> 00:05:48.618
take a trace from the device.

00:05:52.090 --> 00:05:55.360
The great thing about
this is that you

00:05:55.360 --> 00:05:57.780
turn on developer options and
you get this Quick Settings

00:05:57.780 --> 00:06:00.000
tile.

00:06:00.000 --> 00:06:02.250
Once you turn it on, you
can start taking a trace.

00:06:02.250 --> 00:06:04.720
And it will stream into
that in-memory buffer.

00:06:04.720 --> 00:06:06.291
So you can turn on a trace.

00:06:06.291 --> 00:06:08.040
It has super low
overhead, so you can just

00:06:08.040 --> 00:06:10.650
leave it on and do your
thing and play your game.

00:06:10.650 --> 00:06:12.554
And then you see,
hey, that seemed

00:06:12.554 --> 00:06:14.220
like it took a long
time, or hey, I just

00:06:14.220 --> 00:06:15.600
dropped a bunch of frames.

00:06:15.600 --> 00:06:17.970
You pull down Quick
Settings, stop the trace.

00:06:17.970 --> 00:06:20.670
And you've just captured
exactly what the problem is.

00:06:20.670 --> 00:06:24.030
And you can just pull it
off, or email it to yourself

00:06:24.030 --> 00:06:27.030
and see what's going on.

00:06:27.030 --> 00:06:28.680
It will pop up a
dialog that allows

00:06:28.680 --> 00:06:33.390
you to email it or share it to
Drive, or Dropbox, or whatever.

00:06:33.390 --> 00:06:37.460
It's also saved to the
device in data/local/traces

00:06:37.460 --> 00:06:40.470
if you do want to
pull it off the ADB.

00:06:40.470 --> 00:06:47.580
The only special thing about the
system tracing Quick Settings

00:06:47.580 --> 00:06:51.210
approach is that they are
compressed on the device,

00:06:51.210 --> 00:06:55.290
so you have to do some
post-processing with Systrace

00:06:55.290 --> 00:06:57.630
and Catapult. And I think
Android Studio is adding

00:06:57.630 --> 00:07:00.410
support for this soon, so you
can import to Android Studio

00:07:00.410 --> 00:07:01.830
as well.

00:07:01.830 --> 00:07:05.700
But you process with
the from_file argument.

00:07:05.700 --> 00:07:11.970
And you will get a trace out
of it, a normal HTML trace.

00:07:11.970 --> 00:07:14.314
So, OK, you've got a trace.

00:07:14.314 --> 00:07:15.480
What do you do with a trace?

00:07:15.480 --> 00:07:17.740
Because it's kind of a lot.

00:07:17.740 --> 00:07:20.010
Well, let's go through
a pretty simple one.

00:07:20.010 --> 00:07:23.090
And then we'll go
through some gaming ones.

00:07:23.090 --> 00:07:26.500
So I don't know how
legible this is.

00:07:26.500 --> 00:07:31.580
Systrace doesn't
really present well.

00:07:31.580 --> 00:07:34.750
But essentially you have
a big timeline view here.

00:07:34.750 --> 00:07:39.010
So I took a trace of
application startup,

00:07:39.010 --> 00:07:41.560
I think calculator startup.

00:07:41.560 --> 00:07:44.387
And at the top, there is
some basic information

00:07:44.387 --> 00:07:46.720
about the overall state of
the device, this interactions

00:07:46.720 --> 00:07:48.100
and alert stuff.

00:07:48.100 --> 00:07:50.590
The kernel line is
where we can see

00:07:50.590 --> 00:07:53.740
what is actually running
on every CPU core

00:07:53.740 --> 00:07:55.970
at any particular time.

00:07:55.970 --> 00:07:58.600
And then we start getting
into a lot of per thread

00:07:58.600 --> 00:08:00.700
information below that
we'll go into more

00:08:00.700 --> 00:08:02.500
detail about in a moment.

00:08:05.920 --> 00:08:08.700
So there's a lot more info
than fits on the screen,

00:08:08.700 --> 00:08:10.300
so it does scroll up and down.

00:08:10.300 --> 00:08:12.660
So make sure you scroll.

00:08:12.660 --> 00:08:17.730
You also can navigate
around the trace with WASD,

00:08:17.730 --> 00:08:21.180
so A and D to move
left and right,

00:08:21.180 --> 00:08:23.390
and W and S to zoom in and out.

00:08:26.230 --> 00:08:28.950
You also have this palette,
this floating palette

00:08:28.950 --> 00:08:32.500
that's at the upper right-hand
that contains four tools.

00:08:32.500 --> 00:08:34.860
The first tool is the pointer.

00:08:34.860 --> 00:08:36.780
The pointer lets you
click stuff in the trace

00:08:36.780 --> 00:08:38.970
and see what it is.

00:08:38.970 --> 00:08:43.950
So here I clicked one of
the calculator time slices.

00:08:43.950 --> 00:08:50.520
And I now get more information
about that particular instance

00:08:50.520 --> 00:08:53.560
that it was running in the
bottom half of the screen.

00:08:53.560 --> 00:08:56.070
So I can see, here is its PID.

00:08:56.070 --> 00:08:57.360
Here's the TID.

00:08:57.360 --> 00:08:58.770
Here's the priority.

00:08:58.770 --> 00:09:04.400
Here is how long it was
actually running on the CPU.

00:09:04.400 --> 00:09:06.599
So you will use
the pointer a lot.

00:09:06.599 --> 00:09:08.390
The other thing you
can do with the pointer

00:09:08.390 --> 00:09:09.848
is you can select
a bunch of stuff.

00:09:09.848 --> 00:09:11.690
You can just draw a rectangle.

00:09:11.690 --> 00:09:13.910
And after you draw
the rectangle,

00:09:13.910 --> 00:09:15.440
you get an aggregate view.

00:09:15.440 --> 00:09:16.730
So you can look and see--

00:09:16.730 --> 00:09:19.310
I don't know-- what was
running during this time.

00:09:19.310 --> 00:09:21.884
And you can sort these
and the normal stuff

00:09:21.884 --> 00:09:22.800
that you would expect.

00:09:26.750 --> 00:09:33.650
The fourth tool on here is
called, I think, the ruler.

00:09:33.650 --> 00:09:38.960
But essentially it allows you
to mark a section of the trace.

00:09:38.960 --> 00:09:40.700
And you highlight it.

00:09:40.700 --> 00:09:44.930
And you can now scroll up
and down the trace view.

00:09:44.930 --> 00:09:46.850
And that highlight will remain.

00:09:46.850 --> 00:09:49.974
So if I've dropped
the frame around here,

00:09:49.974 --> 00:09:51.890
I need to go look around
the rest of the trace

00:09:51.890 --> 00:09:54.110
to see what's going on,
you can highlight that

00:09:54.110 --> 00:09:58.080
and scroll up and down and
know exactly where you are.

00:09:58.080 --> 00:10:00.390
The second and third
things on the palette

00:10:00.390 --> 00:10:05.520
are a panning tool
and a zooming tool,

00:10:05.520 --> 00:10:08.220
but they're equivalent to WASD.

00:10:08.220 --> 00:10:10.170
So you can use the
palette tools if you want.

00:10:10.170 --> 00:10:11.650
You can use WASD if you want.

00:10:11.650 --> 00:10:14.740
It doesn't really matter.

00:10:14.740 --> 00:10:18.340
So if we scroll down, we can
see per thread information.

00:10:18.340 --> 00:10:23.870
And we can see information about
each thread's current state.

00:10:23.870 --> 00:10:26.410
So the first thing
that you'll see--

00:10:26.410 --> 00:10:28.170
and it's hard to read.

00:10:28.170 --> 00:10:29.570
And I apologize.

00:10:29.570 --> 00:10:30.540
Do I have an arrow?

00:10:30.540 --> 00:10:33.060
I do have an arrow.

00:10:33.060 --> 00:10:37.120
So there's this stack of boxes.

00:10:37.120 --> 00:10:42.300
So essentially the trace
sections for a given thread

00:10:42.300 --> 00:10:43.500
are a stack.

00:10:43.500 --> 00:10:48.330
So you'll say trace begin
section, activity start.

00:10:48.330 --> 00:10:51.900
And then something else will
say trace begin section, inflate

00:10:51.900 --> 00:10:54.070
for inflated view.

00:10:54.070 --> 00:10:56.030
And so they appear as
a stack in the trace.

00:10:59.110 --> 00:11:02.050
The other thing
that is at least as

00:11:02.050 --> 00:11:08.650
important for reading a
trace is the multicolored bar

00:11:08.650 --> 00:11:11.200
above each thread.

00:11:11.200 --> 00:11:12.310
And you can see it.

00:11:12.310 --> 00:11:14.400
It's hard to see.

00:11:14.400 --> 00:11:18.530
But that tells you information
about the state of the thread

00:11:18.530 --> 00:11:19.690
at any given time.

00:11:22.450 --> 00:11:24.590
Oh, and you can see it
in more detail there.

00:11:24.590 --> 00:11:27.940
So you can see there we've
got a bunch of green sections.

00:11:27.940 --> 00:11:29.440
We've got some orange section.

00:11:29.440 --> 00:11:30.530
We've got some red.

00:11:30.530 --> 00:11:32.620
We've got some
blue, and sections

00:11:32.620 --> 00:11:34.420
where it's just not colored.

00:11:37.690 --> 00:11:38.915
So there's some green.

00:11:41.560 --> 00:11:45.170
And if you actually
click that green bar,

00:11:45.170 --> 00:11:47.307
it will tell you
that it was running.

00:11:47.307 --> 00:11:49.140
And it will tell you
how long it was running

00:11:49.140 --> 00:11:50.790
and which CPU it was running on.

00:11:50.790 --> 00:11:54.500
So you can track your
thread's progress

00:11:54.500 --> 00:11:57.020
through the system that way.

00:11:57.020 --> 00:11:59.330
You can see, OK, it was
running here for this time,

00:11:59.330 --> 00:12:01.830
and then it was blocked
on something else,

00:12:01.830 --> 00:12:06.800
and then it woke up, and figure
out what's going on there.

00:12:06.800 --> 00:12:08.890
So the different colors are--

00:12:08.890 --> 00:12:10.760
there are five colors.

00:12:10.760 --> 00:12:11.800
Number one is green.

00:12:11.800 --> 00:12:14.320
That just means the
thread is running.

00:12:14.320 --> 00:12:16.080
It's currently running on a CPU.

00:12:16.080 --> 00:12:19.840
You know, it's actually making
progress during that time.

00:12:19.840 --> 00:12:24.010
The only thing that could run
when a thread is in the running

00:12:24.010 --> 00:12:25.180
state is an interrupt.

00:12:25.180 --> 00:12:30.510
And that lasts sub-microsecond
most of the time.

00:12:30.510 --> 00:12:34.070
So if your thread is running,
it's actually on the CPU,

00:12:34.070 --> 00:12:34.940
doing work.

00:12:34.940 --> 00:12:39.050
If it's runnable, that can
mean one of two things.

00:12:39.050 --> 00:12:42.120
A thread will become runnable
when it's been sleeping

00:12:42.120 --> 00:12:43.640
and something wakes it up.

00:12:43.640 --> 00:12:46.010
Or if your thread is just--

00:12:46.010 --> 00:12:51.214
let's say you have a spin loop,
just while one, do nothing,

00:12:51.214 --> 00:12:52.630
eventually the
scheduler will say,

00:12:52.630 --> 00:12:55.130
OK, you've exceeded
the amount of CPU time

00:12:55.130 --> 00:12:56.510
you can have right now.

00:12:56.510 --> 00:12:59.600
I'm going to de-schedule you
and let something else run.

00:12:59.600 --> 00:13:03.200
Then your thread will
be made runnable,

00:13:03.200 --> 00:13:05.242
in that it could be running.

00:13:05.242 --> 00:13:06.950
There's nothing blocking
it from running,

00:13:06.950 --> 00:13:08.860
but the scheduler has
not selected it to run.

00:13:12.840 --> 00:13:14.880
The third state is sleeping.

00:13:14.880 --> 00:13:17.940
Sleeping just means there's
no work for this thread to do,

00:13:17.940 --> 00:13:20.070
so it's not running.

00:13:20.070 --> 00:13:22.430
Usually it means
you're blocked on--

00:13:22.430 --> 00:13:24.030
if you expect that
your thread should

00:13:24.030 --> 00:13:25.710
be running but you
see it's sleeping,

00:13:25.710 --> 00:13:28.350
it's probably actually
blocked on a mutex somewhere,

00:13:28.350 --> 00:13:31.590
because block
contention in userspace

00:13:31.590 --> 00:13:34.020
does show up as sleeping.

00:13:34.020 --> 00:13:38.640
The last two are kinds of
sleep inside the kernel.

00:13:38.640 --> 00:13:42.540
The orange is
uninterruptible sleep

00:13:42.540 --> 00:13:46.374
in block I/O, which means
you are waiting on disk.

00:13:46.374 --> 00:13:47.790
So if you see that
a lot, it means

00:13:47.790 --> 00:13:50.040
you are loading a ton
of data from disk.

00:13:50.040 --> 00:13:52.320
And maybe you shouldn't do that.

00:13:52.320 --> 00:13:55.950
The last one, red, is
uninterruptible sleep.

00:13:55.950 --> 00:13:59.220
This means you are blocked
somewhere else in the kernel.

00:13:59.220 --> 00:14:01.754
It's probably not
I/O. It's probably

00:14:01.754 --> 00:14:03.420
related to memory
management, because we

00:14:03.420 --> 00:14:07.200
do see that the vast majority
of time in uninterruptible sleep

00:14:07.200 --> 00:14:09.488
is actually because
of memory management.

00:14:13.610 --> 00:14:17.310
And so a easy,
quick thing that I

00:14:17.310 --> 00:14:23.300
do as the first part of
reading any trace is you

00:14:23.300 --> 00:14:25.940
can select all of these
bars above a thread

00:14:25.940 --> 00:14:27.500
and get an aggregate view.

00:14:27.500 --> 00:14:30.800
So here I can see that
this particular thread was

00:14:30.800 --> 00:14:32.870
sleeping for 12 milliseconds.

00:14:32.870 --> 00:14:39.134
It was runnable for 0.6
milliseconds, running for 3.1.

00:14:39.134 --> 00:14:42.740
You know, it looks totally
normal, totally fine.

00:14:42.740 --> 00:14:44.930
But you can use this
to get a sense of where

00:14:44.930 --> 00:14:47.550
your bottlenecks may be.

00:14:47.550 --> 00:14:50.750
If your thread is always
running and you're still

00:14:50.750 --> 00:14:52.610
not meeting your
performance targets,

00:14:52.610 --> 00:14:54.590
you're probably CPU bound.

00:14:54.590 --> 00:14:57.410
That's probably a good bet.

00:14:57.410 --> 00:15:00.650
If you see that your thread
is sleeping and never running,

00:15:00.650 --> 00:15:02.150
maybe there is some
lock contention.

00:15:02.150 --> 00:15:06.210
Maybe you're waiting
on GPU activity.

00:15:06.210 --> 00:15:10.700
The bottleneck is not
the CPU for that thread.

00:15:10.700 --> 00:15:12.620
The bottleneck is
somewhere else.

00:15:12.620 --> 00:15:15.660
If you're seeing a
ton of block I/O,

00:15:15.660 --> 00:15:18.500
then you're probably
reading too much

00:15:18.500 --> 00:15:20.090
from the disk at any given time.

00:15:20.090 --> 00:15:22.730
And the thread
can't make progress

00:15:22.730 --> 00:15:24.920
because it's waiting
for data from the desk.

00:15:24.920 --> 00:15:28.630
So that's a good first check for
where your bottlenecks may be.

00:15:32.660 --> 00:15:34.930
One other really helpful
thing here-- let me see,

00:15:34.930 --> 00:15:35.721
do I have an arrow?

00:15:35.721 --> 00:15:38.270
I do have an arrow.

00:15:38.270 --> 00:15:43.680
Up at the very top, this
interactions and alerts area,

00:15:43.680 --> 00:15:45.680
it's really hard to read,
but you can actually

00:15:45.680 --> 00:15:51.410
see when the user touched
the screen, this input thing.

00:15:51.410 --> 00:15:58.280
So you can tell, when you have a
trace and I tap the screen once

00:15:58.280 --> 00:16:00.440
and something happened
that was slow,

00:16:00.440 --> 00:16:02.720
this gives you a really
good way to orient yourself

00:16:02.720 --> 00:16:03.770
in the trace.

00:16:03.770 --> 00:16:07.910
You can tell, OK, well, the bad
behavior must be around here.

00:16:11.280 --> 00:16:14.870
So one of the most important
things to do with a trace

00:16:14.870 --> 00:16:19.190
is to add your own
trace sections.

00:16:19.190 --> 00:16:21.830
You can debug a lot of
issues without having

00:16:21.830 --> 00:16:25.160
your own trace sections,
where you as the app developer

00:16:25.160 --> 00:16:27.650
know what your app
is trying to do.

00:16:27.650 --> 00:16:32.780
But if you add your
own trace sections,

00:16:32.780 --> 00:16:34.200
life gets so much easier.

00:16:34.200 --> 00:16:36.890
It's really five
to 10 times faster

00:16:36.890 --> 00:16:39.950
to debug if you have
your own trace sections.

00:16:39.950 --> 00:16:43.400
So from Java, you
include this package.

00:16:43.400 --> 00:16:45.860
It's trace.beginSection
and trace.endSection.

00:16:45.860 --> 00:16:48.200
The only thing you have to
do is, because it is a stack,

00:16:48.200 --> 00:16:50.750
you need to actually make
sure that every begin section

00:16:50.750 --> 00:16:56.340
has an end section, otherwise
the trace gets really weird.

00:16:56.340 --> 00:16:56.960
And it's bad.

00:16:56.960 --> 00:16:57.876
And you won't like it.

00:16:59.652 --> 00:17:02.110
But, of course, nobody in here
really cares that much about

00:17:02.110 --> 00:17:06.710
Java, so for the NDK, you
include android/trace.h,

00:17:06.710 --> 00:17:09.579
ATrace_beginSection,
ATrace_endSection.

00:17:09.579 --> 00:17:13.109
And I believe that is
supported on API 23 and up.

00:17:17.530 --> 00:17:19.510
So when you actually want
to take an app trace,

00:17:19.510 --> 00:17:21.910
all you have to do
is you take a trace,

00:17:21.910 --> 00:17:25.240
you add -a and
your package name.

00:17:25.240 --> 00:17:28.910
And that will turn on
app tracing for your app.

00:17:28.910 --> 00:17:31.870
And you will just get results.

00:17:31.870 --> 00:17:34.320
There is a trace section
that I added to a random app

00:17:34.320 --> 00:17:36.820
at one point.

00:17:36.820 --> 00:17:39.370
And it just shows up as
any other trace session.

00:17:39.370 --> 00:17:42.130
But it's really good
for when, say, you're

00:17:42.130 --> 00:17:45.190
loading something, or
waiting on network activity,

00:17:45.190 --> 00:17:50.170
you know semantically what
your app is attempting to do.

00:17:50.170 --> 00:17:52.120
You can express that
information in a trace.

00:17:52.120 --> 00:17:55.330
And combined with everything
the system thinks is going on,

00:17:55.330 --> 00:18:01.060
you can get a much better
view of how your app performs.

00:18:01.060 --> 00:18:06.970
OK, so game traces--

00:18:06.970 --> 00:18:09.400
because that's why
we're here, let's

00:18:09.400 --> 00:18:12.070
look at a couple
actual game traces.

00:18:12.070 --> 00:18:18.190
So just out of curiosity, how
many people in here use Unity?

00:18:18.190 --> 00:18:19.400
OK, a pretty large number.

00:18:19.400 --> 00:18:20.395
What about Unreal?

00:18:23.480 --> 00:18:27.797
OK, and what about custom
engines, not Unity or Unreal?

00:18:27.797 --> 00:18:30.150
OK, cool.

00:18:30.150 --> 00:18:35.000
So I took two traces each
from two popular games,

00:18:35.000 --> 00:18:38.170
current top 20, maybe.

00:18:38.170 --> 00:18:47.280
And I anonymized them
to not put them on edge.

00:18:47.280 --> 00:18:49.710
And the first uses
a custom engine.

00:18:49.710 --> 00:18:52.800
The second is a Unity game.

00:18:52.800 --> 00:18:55.080
So let's look at that first one.

00:18:55.080 --> 00:18:56.987
So this is app startup.

00:18:56.987 --> 00:18:58.070
And I don't have my notes.

00:18:58.070 --> 00:18:59.195
And that's really annoying.

00:19:01.800 --> 00:19:05.195
So this is what it looks
like after I took to trace.

00:19:05.195 --> 00:19:10.450
So I downloaded it on
a Pixel 2 XL running P.

00:19:10.450 --> 00:19:11.480
And so I open it up.

00:19:11.480 --> 00:19:14.550
And I can see--

00:19:14.550 --> 00:19:16.520
so this was launching a game.

00:19:16.520 --> 00:19:18.792
So at some point in
here I click the screen.

00:19:18.792 --> 00:19:20.750
And I think you can see
that up at the very top

00:19:20.750 --> 00:19:25.850
there is that one place
where the second row

00:19:25.850 --> 00:19:29.300
in the interaction
section is lit up.

00:19:29.300 --> 00:19:33.260
And that is where I
actually touched the screen.

00:19:33.260 --> 00:19:34.400
So I started this game.

00:19:34.400 --> 00:19:36.360
And I wanted to see, is it fast?

00:19:36.360 --> 00:19:38.390
Is it good?

00:19:38.390 --> 00:19:39.790
And it took a few seconds.

00:19:39.790 --> 00:19:42.110
It wasn't too bad,
but, I thought

00:19:42.110 --> 00:19:44.200
it could probably be better.

00:19:44.200 --> 00:19:52.240
So here's the actual startup
section for the game.

00:19:52.240 --> 00:19:57.054
And it looks a little weird,
because the UI thread is--

00:19:57.054 --> 00:19:59.220
it's called the UI thread
in Catapult. It's actually

00:19:59.220 --> 00:20:00.770
just the main thread.

00:20:00.770 --> 00:20:04.250
It is the first thread,
so that starts up first.

00:20:04.250 --> 00:20:06.540
That's where app
code usually runs.

00:20:06.540 --> 00:20:11.830
The UI thread just goes idle for
a second in the middle there.

00:20:11.830 --> 00:20:15.310
Actually, yeah, it's
1.4-ish seconds.

00:20:15.310 --> 00:20:17.180
It just doesn't run anything.

00:20:17.180 --> 00:20:17.860
It's asleep.

00:20:17.860 --> 00:20:19.540
It's not waiting on anything.

00:20:19.540 --> 00:20:21.030
I looked at other threads.

00:20:21.030 --> 00:20:22.810
Nothing else was running.

00:20:22.810 --> 00:20:23.440
That's weird.

00:20:28.110 --> 00:20:32.460
If you look at what else
is running on the system,

00:20:32.460 --> 00:20:34.974
it doesn't look--

00:20:34.974 --> 00:20:36.140
it might not look that idle.

00:20:36.140 --> 00:20:38.870
It's pretty idle.

00:20:38.870 --> 00:20:41.960
There's some stuff running
at the beginning of that time

00:20:41.960 --> 00:20:45.290
as probably rendering
the transition

00:20:45.290 --> 00:20:48.230
to draw the window for the app.

00:20:48.230 --> 00:20:51.860
But by the end,
nothing's running.

00:20:51.860 --> 00:20:53.900
App is just waiting.

00:20:53.900 --> 00:20:57.080
So we can go and see what
actually woke up the app.

00:20:57.080 --> 00:21:03.200
And here I've zoomed in to the
very edge of that 1.4-second

00:21:03.200 --> 00:21:04.190
time.

00:21:04.190 --> 00:21:06.590
And there's a tiny,
little blue block

00:21:06.590 --> 00:21:10.970
at the end of that where that
main thread becomes runnable.

00:21:10.970 --> 00:21:14.210
And here I can see
wake up from TID zero.

00:21:14.210 --> 00:21:16.430
And so wake up
from TID tells you

00:21:16.430 --> 00:21:18.470
what thread made
something runnable, which

00:21:18.470 --> 00:21:21.860
is really great, because you
can actually get into causation.

00:21:21.860 --> 00:21:26.130
You can say, this thread caused
this other thing to happen.

00:21:26.130 --> 00:21:27.890
And you know it's real.

00:21:27.890 --> 00:21:29.450
It's true.

00:21:29.450 --> 00:21:32.240
But TID zero means
it's an interrupt.

00:21:32.240 --> 00:21:35.180
And that's really weird,
because apps usually

00:21:35.180 --> 00:21:36.920
don't see interrupts directly.

00:21:36.920 --> 00:21:38.930
The only interrupt
they ever really see

00:21:38.930 --> 00:21:41.270
is a timer interrupt.

00:21:41.270 --> 00:21:46.150
But let's just be careful, and
sure, and scroll up and look.

00:21:46.150 --> 00:21:47.410
And, yeah, during the--

00:21:47.410 --> 00:21:49.420
I don't know-- 20
or 30 milliseconds

00:21:49.420 --> 00:21:51.610
before, there's
nothing really running.

00:21:51.610 --> 00:21:53.359
And we don't have
interrupt latency

00:21:53.359 --> 00:21:54.400
of 20 or 30 milliseconds.

00:21:54.400 --> 00:21:58.330
That would be wild.

00:21:58.330 --> 00:22:01.660
So I wonder if the app is
sleeping for 1.4 seconds.

00:22:01.660 --> 00:22:04.175
I think it's possible.

00:22:04.175 --> 00:22:06.550
This wouldn't show up on a
profiler, because you wouldn't

00:22:06.550 --> 00:22:08.650
see sleep on a profiler.

00:22:08.650 --> 00:22:11.690
But it really does look
like the app is just

00:22:11.690 --> 00:22:14.950
sleeping during app startup.

00:22:14.950 --> 00:22:16.850
So let's go on to
the next trace.

00:22:16.850 --> 00:22:18.970
So this is gameplay.

00:22:18.970 --> 00:22:24.496
And gameplay here, it has some
load screens in the middle.

00:22:24.496 --> 00:22:26.620
And I wondered what was
happening during that time.

00:22:31.950 --> 00:22:36.540
So a thing about
gameplay, and why I still

00:22:36.540 --> 00:22:40.930
use Catapult instead
of Android Studio,

00:22:40.930 --> 00:22:43.990
Catapult will show you every
process on the system, which

00:22:43.990 --> 00:22:46.810
is a ton of data,
but it will also

00:22:46.810 --> 00:22:48.880
show you things
like SurfaceFlinger.

00:22:48.880 --> 00:22:50.047
And SurfaceFlinger is great.

00:22:50.047 --> 00:22:52.171
And if you have no idea
what I'm talking about when

00:22:52.171 --> 00:22:54.700
I say SurfaceFlinger, let's
talk about how a frame actually

00:22:54.700 --> 00:22:59.200
makes it to the
display on Android.

00:22:59.200 --> 00:23:03.410
So what is the basic
lifecycle of a frame?

00:23:03.410 --> 00:23:05.360
Number one, apps
will render a frame.

00:23:05.360 --> 00:23:07.820
So your game will
render a frame.

00:23:07.820 --> 00:23:12.770
And it will send a message
to SurfaceFlinger saying,

00:23:12.770 --> 00:23:15.940
I have a frame ready
for you to display.

00:23:15.940 --> 00:23:19.510
SurfaceFlinger will
wake up every 60 hertz,

00:23:19.510 --> 00:23:23.440
I guess, and figure out
which apps are visible.

00:23:23.440 --> 00:23:25.870
And it will build a
list of all the frames

00:23:25.870 --> 00:23:32.170
to be combined into a form that
the underlying hardware can

00:23:32.170 --> 00:23:33.490
deal with.

00:23:33.490 --> 00:23:38.020
So that list makes its way
to a vendor driver and vendor

00:23:38.020 --> 00:23:40.810
hardware called the
hardware composer.

00:23:40.810 --> 00:23:41.950
And it will take--

00:23:41.950 --> 00:23:43.670
maybe you have
this status bar up,

00:23:43.670 --> 00:23:46.360
or the Home and Back buttons.

00:23:46.360 --> 00:23:50.650
And all of that
will get overlayed

00:23:50.650 --> 00:23:52.840
and turn into one framebuffer.

00:23:52.840 --> 00:23:56.830
And that final frame will
be sent to the display.

00:23:56.830 --> 00:24:00.700
The great thing here is
that SurfaceFlinger tracks

00:24:00.700 --> 00:24:02.754
every app and every frame.

00:24:02.754 --> 00:24:04.420
So if we look at
SurfaceFlinger's state,

00:24:04.420 --> 00:24:06.850
we can see exactly
what is arriving

00:24:06.850 --> 00:24:13.010
when from any
particular application.

00:24:13.010 --> 00:24:14.740
So let's go back
and look at gameplay

00:24:14.740 --> 00:24:17.330
and look at SurfaceFlinger.

00:24:17.330 --> 00:24:21.560
So here we have this line,
this surface view row.

00:24:21.560 --> 00:24:24.350
And it's a counter.

00:24:24.350 --> 00:24:26.810
So the surface view
is triple buffered.

00:24:26.810 --> 00:24:32.535
So you either have zero frames
pending, or one or two frames.

00:24:32.535 --> 00:24:34.410
And you can see it's
usually bouncing around,

00:24:34.410 --> 00:24:36.600
which means we are getting
frames from the app.

00:24:36.600 --> 00:24:38.820
But again, there's a gap here.

00:24:38.820 --> 00:24:41.760
And it's about 700 milliseconds.

00:24:41.760 --> 00:24:44.680
And the game does do
something with load screens.

00:24:44.680 --> 00:24:47.505
So let's go see what the app is
doing, because this is probably

00:24:47.505 --> 00:24:48.230
a load screen.

00:24:51.250 --> 00:24:54.230
And here, yeah, we have
this long 700-millisecond

00:24:54.230 --> 00:24:55.720
on-draw frame section.

00:24:59.540 --> 00:25:01.910
And if we look and see what's
actually happening, yeah,

00:25:01.910 --> 00:25:04.050
it's running for
about-- what is that--

00:25:04.050 --> 00:25:11.340
190 milliseconds and sleeping
for 500-odd milliseconds.

00:25:11.340 --> 00:25:13.355
So it's waiting on
other work to happen.

00:25:13.355 --> 00:25:15.230
Now, there are these
other two threads nearby

00:25:15.230 --> 00:25:17.017
that seem to be doing work.

00:25:17.017 --> 00:25:17.850
What's up with them?

00:25:20.420 --> 00:25:22.130
Well, they're
running, and sleeping,

00:25:22.130 --> 00:25:25.050
and runnable for some of it.

00:25:25.050 --> 00:25:26.390
Let's see, is that--

00:25:26.390 --> 00:25:27.920
OK, yeah.

00:25:27.920 --> 00:25:33.470
So if you actually look at
what these thread sections are,

00:25:33.470 --> 00:25:37.250
they are tagged with IOmx,
which I know from other Android

00:25:37.250 --> 00:25:39.590
things is sound stuff.

00:25:39.590 --> 00:25:41.300
So I think what's
actually happening here

00:25:41.300 --> 00:25:44.390
is the game is
pausing its loading--

00:25:44.390 --> 00:25:52.760
or pausing displaying frames
in order to load more sounds.

00:25:52.760 --> 00:25:57.320
But you can see before
this big loading section,

00:25:57.320 --> 00:25:59.180
there's a lot of
free CPU cycles.

00:25:59.180 --> 00:26:06.560
The game is not keeping
the device that busy.

00:26:06.560 --> 00:26:10.250
This load screen can
probably be fixed and removed

00:26:10.250 --> 00:26:15.520
completely just by moving a lot
of this loading ahead of time

00:26:15.520 --> 00:26:21.870
to overlap with actual gameplay,
because there's enough CPU time

00:26:21.870 --> 00:26:23.109
to do it.

00:26:23.109 --> 00:26:24.900
So that's the kind of
stuff you can get out

00:26:24.900 --> 00:26:28.765
of Systrace in less
graphically intensive games.

00:26:28.765 --> 00:26:32.490
Now let's look at a really
graphically intensive game.

00:26:32.490 --> 00:26:35.877
So this one uses Unity as well.

00:26:35.877 --> 00:26:36.460
And let's see.

00:26:36.460 --> 00:26:39.970
I think I have level start here.

00:26:39.970 --> 00:26:43.540
And then we have
actual gameplay next.

00:26:43.540 --> 00:26:48.160
So for my level
start trace, this

00:26:48.160 --> 00:26:51.160
is what I see when
I first open it up.

00:26:51.160 --> 00:26:55.180
And you can see the surface
view in the center there.

00:26:55.180 --> 00:26:59.170
And it does have a big chunk
where SurfaceFlinger is not

00:26:59.170 --> 00:27:02.620
displaying anything,
because no frames are really

00:27:02.620 --> 00:27:03.880
arriving from the game.

00:27:06.960 --> 00:27:09.530
And if we actually trace from--

00:27:09.530 --> 00:27:13.250
highlight from where frames
are being consistently

00:27:13.250 --> 00:27:15.980
delivered, in other
words, before I started

00:27:15.980 --> 00:27:18.590
the level, to when they
are being consistently

00:27:18.590 --> 00:27:19.960
delivered again--

00:27:19.960 --> 00:27:24.590
that's probably after the game
is really displaying stuff--

00:27:24.590 --> 00:27:26.570
it's about 5.7 seconds.

00:27:26.570 --> 00:27:32.960
It's pretty long, as
a player, to see that.

00:27:32.960 --> 00:27:37.360
So let's go see what the
game is actually doing.

00:27:37.360 --> 00:27:39.810
So here is the
Unity main thread.

00:27:39.810 --> 00:27:43.475
And the Unity main thread,
if you look at Unity apps,

00:27:43.475 --> 00:27:45.100
you're going to be
looking at the Unity

00:27:45.100 --> 00:27:46.540
main thread a whole lot.

00:27:46.540 --> 00:27:51.310
But you can see it
is not super busy,

00:27:51.310 --> 00:27:53.290
which is weird and not great.

00:27:53.290 --> 00:27:56.800
So what is it actually doing?

00:27:56.800 --> 00:27:59.060
Well, it's running
for-- what is that--

00:27:59.060 --> 00:28:00.460
3.1 seconds.

00:28:00.460 --> 00:28:04.150
And it's sleeping
for 2.5 seconds.

00:28:04.150 --> 00:28:09.510
So what's actually
happening during this sleep?

00:28:09.510 --> 00:28:11.950
So if we zoom in a lot--

00:28:11.950 --> 00:28:15.550
and now we're looking at a
300-millisecond period that

00:28:15.550 --> 00:28:16.900
you--

00:28:16.900 --> 00:28:20.240
I saw this 300-millisecond
pattern repeat

00:28:20.240 --> 00:28:25.560
kind of consistently throughout
this Unity main section.

00:28:25.560 --> 00:28:28.470
You see that it runs for a
bit, and then goes to sleep,

00:28:28.470 --> 00:28:31.230
and runs for a bit, and
goes to sleep, and repeat.

00:28:31.230 --> 00:28:32.850
And it looks really periodic.

00:28:32.850 --> 00:28:37.360
It looks like it's happening
on frame boundaries.

00:28:37.360 --> 00:28:39.950
So let's see what's
actually waking it up.

00:28:39.950 --> 00:28:41.430
So once again, we can zoom in.

00:28:41.430 --> 00:28:45.000
And there's a tiny, little
blue bar that is probably not

00:28:45.000 --> 00:28:47.580
visible from this.

00:28:47.580 --> 00:28:54.480
But we can see the wake up from
TID 31526, which is something.

00:28:54.480 --> 00:28:57.330
So we can go scroll up
to the top of the trace

00:28:57.330 --> 00:29:01.130
now and figure out what that is.

00:29:01.130 --> 00:29:03.940
Hey, it's the Unity
Choreographer thread.

00:29:03.940 --> 00:29:06.330
So what I think
is happening here

00:29:06.330 --> 00:29:11.830
is that the game is
running some Unity script.

00:29:11.830 --> 00:29:15.280
And in that Unity
script, they're saying--

00:29:15.280 --> 00:29:21.040
they're trying to be nice and
not block rendering and saying,

00:29:21.040 --> 00:29:24.160
wait until next frame.

00:29:24.160 --> 00:29:28.570
But this is causing their
load times to suffer a lot.

00:29:28.570 --> 00:29:30.430
There's probably a
good one and a half,

00:29:30.430 --> 00:29:34.270
two seconds they could
get back by not doing this

00:29:34.270 --> 00:29:39.190
during the actual load,
just because there is so

00:29:39.190 --> 00:29:40.870
much free time on that thread.

00:29:40.870 --> 00:29:43.780
And that is the bottleneck
for the load here.

00:29:43.780 --> 00:29:48.230
There's actually very
little I/O done here.

00:29:48.230 --> 00:29:51.310
One of the things we see
in general on Android

00:29:51.310 --> 00:29:55.420
is that you're
generally not I/O bound,

00:29:55.420 --> 00:29:57.160
especially on high-end devices.

00:29:57.160 --> 00:30:00.260
Low-end devices, really low-end
devices are very different.

00:30:00.260 --> 00:30:03.490
But if you're talking mid- or
high-end in the past few years,

00:30:03.490 --> 00:30:07.630
flash performance has increased
dramatically to the point

00:30:07.630 --> 00:30:10.750
that it's faster than a
lot of desktop machines.

00:30:10.750 --> 00:30:15.420
And you're not that I/O
bound most of the time.

00:30:15.420 --> 00:30:17.780
The biggest bottleneck
is definitely the CPU.

00:30:17.780 --> 00:30:19.950
And that's what we see--

00:30:19.950 --> 00:30:22.545
even in this very
graphically intensive game,

00:30:22.545 --> 00:30:25.200
it's bottlenecked by the CPU.

00:30:25.200 --> 00:30:28.920
Let's look at gameplay, because
there's some interesting stuff

00:30:28.920 --> 00:30:30.950
there, too.

00:30:30.950 --> 00:30:33.980
So once again, there's
the surface view.

00:30:33.980 --> 00:30:38.780
And you can see it's taking back
and forth in the middle there.

00:30:38.780 --> 00:30:41.240
And overall it
looks pretty good.

00:30:41.240 --> 00:30:43.130
I have very few
complaints about this.

00:30:43.130 --> 00:30:45.770
But I can always be
pretty nit-picky,

00:30:45.770 --> 00:30:51.140
so let's find something
that is wrong.

00:30:51.140 --> 00:30:53.840
So it did drop a frame
in the middle here.

00:30:53.840 --> 00:30:57.500
There is a place where it should
have rendered a frame and it

00:30:57.500 --> 00:30:59.570
just didn't.

00:30:59.570 --> 00:31:01.790
No frame was ready
for SurfaceFlinger,

00:31:01.790 --> 00:31:06.770
so the app probably did not
complete a frame on time.

00:31:06.770 --> 00:31:09.184
So let's scroll down and
see what happened in the app

00:31:09.184 --> 00:31:10.850
to make it not complete
a frame on time.

00:31:13.800 --> 00:31:16.470
So here is the Unity
GfxDevice thread,

00:31:16.470 --> 00:31:18.470
which is actually dispatching
the render clause.

00:31:18.470 --> 00:31:20.510
And it looks like at one
point it just skipped.

00:31:20.510 --> 00:31:23.600
So it just missed--

00:31:23.600 --> 00:31:25.280
something missed a
deadline somewhere.

00:31:25.280 --> 00:31:27.560
And it decided, hey,
just drop the frame.

00:31:27.560 --> 00:31:29.560
We're not going to make it.

00:31:29.560 --> 00:31:33.310
So let's look at the Unity main
thread and see what's going on.

00:31:33.310 --> 00:31:37.990
Aha, there is the smoking gun.

00:31:37.990 --> 00:31:43.360
Immediately before that dropped
frame from the Unity GfxDevice,

00:31:43.360 --> 00:31:47.050
we see a bunch of I/O on
the Unity main thread.

00:31:47.050 --> 00:31:48.190
That's a little weird.

00:31:48.190 --> 00:31:49.880
I wonder why that happened.

00:31:49.880 --> 00:31:52.000
But then I scrolled
up and realized

00:31:52.000 --> 00:31:54.310
that is exactly when I
touched the screen to trigger

00:31:54.310 --> 00:31:56.740
some special thing in the game.

00:31:56.740 --> 00:32:03.080
So my guess is that I
pressed a button in the game.

00:32:03.080 --> 00:32:05.870
There was something on the
disk that was not loaded.

00:32:05.870 --> 00:32:07.040
And even though I just--

00:32:07.040 --> 00:32:08.350
throughput is really high.

00:32:08.350 --> 00:32:10.990
It's still disk latency,
so it takes a while for--

00:32:10.990 --> 00:32:12.830
you know, even if
it was 20 bytes,

00:32:12.830 --> 00:32:16.370
it will still take a while to
get those 20 bytes off of disk.

00:32:16.370 --> 00:32:18.410
That blocked the
Unity main thread,

00:32:18.410 --> 00:32:23.030
which, in turn, caused the Unity
GfxDevice thread to not render

00:32:23.030 --> 00:32:24.100
a frame.

00:32:24.100 --> 00:32:27.910
And that was seen
as a frame drop.

00:32:27.910 --> 00:32:31.150
But overall this is
actually a pretty good game.

00:32:31.150 --> 00:32:38.120
It's running pretty close
to a solid 30 FPS, I think.

00:32:38.120 --> 00:32:44.380
But it is actually maintaining
it and working really well.

00:32:44.380 --> 00:32:50.130
But there's always something you
can improve with performance.

00:32:50.130 --> 00:32:53.720
You can always be
harsher on yourself.

00:32:53.720 --> 00:32:56.740
But that's the data we
get out of Systrace.

00:32:56.740 --> 00:32:58.740
It's exactly what happened.

00:32:58.740 --> 00:33:00.540
And it allows you
to tie it together

00:33:00.540 --> 00:33:04.530
across the system to figure
out what actually went wrong.

00:33:04.530 --> 00:33:09.840
And coupled with the new support
on Android P for triggering

00:33:09.840 --> 00:33:13.240
a trace on device,
it's easier than ever

00:33:13.240 --> 00:33:18.270
to actually spot
performance issues

00:33:18.270 --> 00:33:21.570
and figure out what's going on.

00:33:21.570 --> 00:33:24.035
So, yeah, I guess questions.

00:33:33.440 --> 00:33:35.890
AUDIENCE: You just mentioned
that most of the games

00:33:35.890 --> 00:33:37.190
are not I/O bound, right?

00:33:37.190 --> 00:33:38.320
TIM MURRAY: Yeah.

00:33:38.320 --> 00:33:40.360
AUDIENCE: So basically
it's true when

00:33:40.360 --> 00:33:45.040
the assets are uncompressed, but
the APK is compressed itself.

00:33:45.040 --> 00:33:47.620
Of course you can store
some of the frames

00:33:47.620 --> 00:33:50.380
without this deflate
compression there.

00:33:50.380 --> 00:33:53.890
But in that case, the size
is going to probably bypass

00:33:53.890 --> 00:33:55.082
the 100 megabyte limit.

00:33:55.082 --> 00:33:55.790
TIM MURRAY: Yeah.

00:33:55.790 --> 00:33:59.336
AUDIENCE: So if you want to
read 20 bytes from the disk,

00:33:59.336 --> 00:34:01.210
it's not like reading
20 bytes from the disk.

00:34:01.210 --> 00:34:04.410
You have to read the whole block
of the zip compressed file,

00:34:04.410 --> 00:34:05.890
then decompress it.

00:34:05.890 --> 00:34:07.810
And then you have access
to these 20 bytes.

00:34:07.810 --> 00:34:11.860
And that actually is something
which you probably can't even

00:34:11.860 --> 00:34:15.142
solve with the higher
speeds of the flash.

00:34:15.142 --> 00:34:15.850
TIM MURRAY: Sure.

00:34:15.850 --> 00:34:19.360
But with the flash, I
mean, even the latency

00:34:19.360 --> 00:34:23.199
is still poor compared to--

00:34:23.199 --> 00:34:25.719
I mean, it's not like
spinning disk poor.

00:34:25.719 --> 00:34:29.020
But compared to something
that's already in memory,

00:34:29.020 --> 00:34:31.659
it's dramatically higher.

00:34:31.659 --> 00:34:35.620
And you're always going
to read some fixed amount.

00:34:35.620 --> 00:34:38.829
I forgot what the
minimum granularity

00:34:38.829 --> 00:34:40.120
you can read from the flash is.

00:34:40.120 --> 00:34:45.344
But you're always going to read
some block size from the flash.

00:34:45.344 --> 00:34:46.760
So it doesn't
really matter if you

00:34:46.760 --> 00:34:50.235
have 4K to read or
three bytes to read,

00:34:50.235 --> 00:34:52.110
you're going to read
the same amount of data.

00:34:52.110 --> 00:34:53.389
AUDIENCE: Yeah, there
are multiple layers

00:34:53.389 --> 00:34:54.380
of caching everywhere.

00:34:54.380 --> 00:34:54.590
TIM MURRAY: Yeah.

00:34:54.590 --> 00:34:57.050
AUDIENCE: So you have to
invalidate all the caches,

00:34:57.050 --> 00:34:59.750
then read from
the flash, have it

00:34:59.750 --> 00:35:01.760
loaded into the
cache of the flash,

00:35:01.760 --> 00:35:03.530
and then throw the file levels.

00:35:03.530 --> 00:35:07.070
Do you think it makes sense to
store more assets uncompressed

00:35:07.070 --> 00:35:09.725
in order to reduce
the whole overhead?

00:35:12.771 --> 00:35:13.270
Sorry.

00:35:13.270 --> 00:35:14.686
So talking from
the perspective is

00:35:14.686 --> 00:35:17.656
like, on iOS, the assets
are stored uncompressed

00:35:17.656 --> 00:35:18.530
on the device, right?

00:35:18.530 --> 00:35:19.670
TIM MURRAY: Mhm.

00:35:19.670 --> 00:35:22.070
AUDIENCE: And that could
be one of the reasons

00:35:22.070 --> 00:35:25.561
why the loading performance
or the performance when

00:35:25.561 --> 00:35:27.560
you are loading on Nextel
or something like that

00:35:27.560 --> 00:35:28.934
is much higher,
because you don't

00:35:28.934 --> 00:35:31.059
have to uncompressed stuff.

00:35:31.059 --> 00:35:32.600
TIM MURRAY: So I
don't actually think

00:35:32.600 --> 00:35:36.200
that's the reason for
the difference in loading

00:35:36.200 --> 00:35:38.130
performance.

00:35:38.130 --> 00:35:41.000
It looks pretty much
like the difference

00:35:41.000 --> 00:35:43.260
in single-threaded
CPU performance.

00:35:43.260 --> 00:35:45.620
It matches pretty closely
with the difference

00:35:45.620 --> 00:35:47.420
in single-threaded
CPU performance.

00:35:47.420 --> 00:35:50.150
What we see, I mean,
especially in Unity apps,

00:35:50.150 --> 00:35:54.440
is that Unity apps
on 5.6 or something

00:35:54.440 --> 00:35:58.460
like that are still primarily
single-threaded, especially

00:35:58.460 --> 00:36:00.310
around load times.

00:36:00.310 --> 00:36:03.950
And they're CPU
bound on Android.

00:36:03.950 --> 00:36:08.190
I bet they're still probably CPU
bound a lot of the time on iOS.

00:36:08.190 --> 00:36:11.710
IOS generally has higher
single-threaded CPU

00:36:11.710 --> 00:36:15.090
performance, so load
times are better.

00:36:15.090 --> 00:36:17.270
So more multithreading--

00:36:17.270 --> 00:36:20.660
I mean, we've got
eight-core devices

00:36:20.660 --> 00:36:23.010
that are pretty common in
the kind of mid- and high-end

00:36:23.010 --> 00:36:25.318
of Android now.

00:36:25.318 --> 00:36:28.865
More multithreading is
better, essentially.

00:36:28.865 --> 00:36:30.240
AUDIENCE: Right,
but then you get

00:36:30.240 --> 00:36:32.250
into power and thermal issues.

00:36:32.250 --> 00:36:34.480
TIM MURRAY: You do.

00:36:34.480 --> 00:36:40.880
But you-- to some extent, yeah.

00:36:40.880 --> 00:36:43.746
I mean, the CPU is the dominant
power consumer on the system.

00:36:43.746 --> 00:36:44.620
It's not the display.

00:36:44.620 --> 00:36:45.410
It's not the GPU.

00:36:45.410 --> 00:36:46.790
It's the CPU.

00:36:46.790 --> 00:36:50.820
So you do have to be careful
with CPU power consumption.

00:36:50.820 --> 00:36:51.873
AUDIENCE: Thank you.

