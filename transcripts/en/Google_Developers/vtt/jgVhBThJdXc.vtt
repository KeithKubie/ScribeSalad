WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:11.180
&gt;&gt; 
PIKE: Hi, everyone. Thanks for coming. Today,

00:00:11.180 --> 00:00:17.470
we're going to talk about what it's like to
program in the new language, Go. It's different

00:00:17.470 --> 00:00:21.610
from other languages. It doesn't look very
different. But when you actually use it, you'll

00:00:21.610 --> 00:00:25.500
find that it's actually quite a bit different
to work in. And so today, Russ Cox and I are

00:00:25.500 --> 00:00:29.800
going to spend some time explaining some of
the more interesting aspects of programming

00:00:29.800 --> 00:00:34.230
in Go. So this isn't really a tutorial. You'll
understand more of what we say if you know

00:00:34.230 --> 00:00:36.760
a little bit about the language. But we've
tried to pitch it at a level that even if

00:00:36.760 --> 00:00:42.650
you don't know anything about it, you'll still
get a feel for what it's all about. Like all

00:00:42.650 --> 00:00:47.690
the other sessions at Google I/O, there's
a live wave where you can comment or ask questions.

00:00:47.690 --> 00:00:51.920
And we'll refer to it later in the talk. So
hold your questions until the end, please.

00:00:51.920 --> 00:00:56.250
And if you have anything you want to ask,
please put in the Wave, which is at that address.

00:00:56.250 --> 00:01:01.649
So let's start with Russ Cox to introduce
some of these ideas. Russ?

00:01:01.649 --> 00:01:10.560
&gt;&gt; COX: Thanks, Rob. So today, Rob and I are
here to talk to you about programming in Go.

00:01:10.560 --> 00:01:16.159
And if you're going to write a Python program,
you wouldn't start with a C++ program and

00:01:16.159 --> 00:01:20.229
translate it line-by-line and expect to end
up with a very well-written Python program.

00:01:20.229 --> 00:01:24.789
And concepts and the idiom in those languages
are different enough that you just end up

00:01:24.789 --> 00:01:29.189
with a badly-written non-idiomatic Python
program. And the same is true of Go and other

00:01:29.189 --> 00:01:33.909
languages. If you start with the concepts
and idioms from C++ or Java or Python and

00:01:33.909 --> 00:01:40.289
you try to translate those line-by-line into
Go, you'll just be frustrated with the experience.

00:01:40.289 --> 00:01:46.889
On the other hand, if you use the core concepts
and idioms in Go to write real Go programs

00:01:46.889 --> 00:01:50.960
then you--we think that you'll get a lot out
of the experience and you'll be very happy

00:01:50.960 --> 00:01:54.749
with the language and with your programs.
And so our goal today is to teach you the

00:01:54.749 --> 00:01:59.529
beginnings of how to think about programs
in a way that makes the best sense in Go.

00:01:59.529 --> 00:02:07.799
So just to get us all on the same page, let's
look for a little bit at what Go is and is

00:02:07.799 --> 00:02:13.180
not. First of all, Go is object-oriented,
but it's not type-oriented. In particular,

00:02:13.180 --> 00:02:19.489
inheritance is not a primary concept in the
language, and that there are no subclasses.

00:02:19.489 --> 00:02:24.760
In fact, there are no classes at all. There
are basic types like int and float and bool,

00:02:24.760 --> 00:02:29.450
and there are composite types like maps and
structs. And all of these can have methods

00:02:29.450 --> 00:02:37.280
defined on them. Second, Go is implicit and
in two keyways. First of all, it's--when you

00:02:37.280 --> 00:02:41.579
write a variable declaration in a function
or even a top-level, if it has an initializer,

00:02:41.579 --> 00:02:46.480
you can omit the type and it will pull the
type off of the initializer. And because of

00:02:46.480 --> 00:02:51.660
that, you tend not to see type-declarations
inside function bodies. And second and more

00:02:51.660 --> 00:02:57.790
importantly, an object in Go satisfies an
interface, which we'll see soon, just by implementing

00:02:57.790 --> 00:03:03.590
the methods that the interface defines. It
does not have to explicitly declare its intent

00:03:03.590 --> 00:03:07.900
to satisfy that interface. If it has the methods,
it satisfies the interface. And we'll see

00:03:07.900 --> 00:03:12.680
example after example on this talk of why
that's really important. And finally, the

00:03:12.680 --> 00:03:18.150
emphasis in Go is on Concurrent programming
rather than parallel programming. And by concurrency,

00:03:18.150 --> 00:03:22.030
I mean a way to structure your program so
that they can cope with having to do many

00:03:22.030 --> 00:03:25.739
things at once and having to deal with many
simultaneous sources of input like network

00:03:25.739 --> 00:03:30.829
connections, and do that in a way that still
lets you write a simple and well-structured

00:03:30.829 --> 00:03:35.590
program. Now, it turns out that if you have
good support for concurrency then it's not

00:03:35.590 --> 00:03:40.540
too hard to turn that into good parallelism
on a multi-core machine today. And Go can

00:03:40.540 --> 00:03:44.609
do that, and it can keep all the cores running.
But the focus is really on concurrency and

00:03:44.609 --> 00:03:51.280
how it makes it easier to write your programs.
And parallelism is just a nice benefit from

00:03:51.280 --> 00:03:54.890
that. So to start, we're going to look at
a simple expression evaluator. And just to

00:03:54.890 --> 00:03:59.430
keep it simple, this expression evaluator
has values that just have binary operations

00:03:59.430 --> 00:04:05.170
on them. Now if you're going to do this in
a language like C++ or Java, you'd start with

00:04:05.170 --> 00:04:09.749
an abstract class called value. And then you'd
have concrete implementations for things like

00:04:09.749 --> 00:04:14.890
integers and strings. And in Go, we start
with "Value", but "Value" is an interface.

00:04:14.890 --> 00:04:19.120
And an interface defines a set of methods
that must be implemented to satisfy the interface.

00:04:19.120 --> 00:04:24.410
And for our values, we need two properties.
We need to be able to combine a value with

00:04:24.410 --> 00:04:29.580
another value in a binary operation, and that's
the "BinaryOp" method. And the receiver is

00:04:29.580 --> 00:04:35.760
implicit, and so the arguments to the "BinaryOp"
are the operation itself as a string and the

00:04:35.760 --> 00:04:40.630
right-hand side value, Y, and it returns the
result value. And the second method that any

00:04:40.630 --> 00:04:44.630
value in our evaluator needs is the "String"
method. And the "String" method returns a

00:04:44.630 --> 00:04:49.191
string so that it can be printed. And if you
implement those methods, then you have a type

00:04:49.191 --> 00:04:53.420
that the evaluator can pass around as a value.
And you don't have to explicitly say, "I'm

00:04:53.420 --> 00:04:58.930
trying to be a value. So let's look at an
implementation of a value. These are just

00:04:58.930 --> 00:05:03.390
integers. And for the most part, you just
write the methods. The first line there declares

00:05:03.390 --> 00:05:08.630
a new type capital "Int" that has the same
memory representation as a standard int. But

00:05:08.630 --> 00:05:13.700
they're different types. This is not--it's
not like in Java where an integer is a class

00:05:13.700 --> 00:05:17.580
and has all the boxing around it. They have
the same representation in memory, but they're

00:05:17.580 --> 00:05:21.140
different types. And in particular because
we just defined capital "Int", we're allowed

00:05:21.140 --> 00:05:26.300
to specify the methods on it. So the second
line defines a "String" method on "Int". And

00:05:26.300 --> 00:05:32.270
the parameter list between the words func
and String declare a receiver of type-int

00:05:32.270 --> 00:05:38.650
X. And that "String" method returns a string
by passing X to "Itoa" from the strconv package.

00:05:38.650 --> 00:05:43.270
And the rest of the slide is the "BinaryOp"
method for "Int". In the "BinaryOp" method,

00:05:43.270 --> 00:05:49.220
the goal is to compute X op Y, where op is
the operator. And we know that X is an int,

00:05:49.220 --> 00:05:53.440
but we don't know anything about Y other than
that it satisfies the value interface. So

00:05:53.440 --> 00:05:58.230
the first thing we have to do is use a type-switch
on Y to look at what type it is and pick off

00:05:58.230 --> 00:06:02.370
the types that we expect to be able to handle.
And in particular if there's another--if Y

00:06:02.370 --> 00:06:08.311
is also an int, then we can do the usual arithmetic
operations: "+", "-", "*". And if it's not

00:06:08.311 --> 00:06:14.000
an int or if--sorry, if it's an error, which
we'll see on the next slide, then we just

00:06:14.000 --> 00:06:19.140
return that error as is. And on the next slide,
we'll see why. And otherwise, we create a

00:06:19.140 --> 00:06:23.880
new error that describes what failed because
this is a failure that the left-hand side

00:06:23.880 --> 00:06:27.870
and the right-hand side and the operator,
that combination is not valid. And so we create

00:06:27.870 --> 00:06:32.950
a new error. Now, what was this about errors?
Well for error handling, we're going to create

00:06:32.950 --> 00:06:37.600
an "Error" type that also satisfies value.
And so the result of the computation as a

00:06:37.600 --> 00:06:42.240
value for that value might itself be an error
and it just going to propagate the error up

00:06:42.240 --> 00:06:47.410
the evaluation. And so, again, this first
line creates a new type called "Error" which

00:06:47.410 --> 00:06:51.910
has the same representation in memory as a
string. And the "String" method on "Error"

00:06:51.910 --> 00:06:56.690
just returns that string. But it has to convert
it because "Error" and "String" are two distinct

00:06:56.690 --> 00:07:02.910
types. And second, we have the "BinaryOp"
method. And here, there's no computation to

00:07:02.910 --> 00:07:06.500
do. There's already been an error on the left-hand
side of the operator, so we just return that

00:07:06.500 --> 00:07:10.990
error. And notice that in both of these examples,
we didn't have to write. We're implementing

00:07:10.990 --> 00:07:15.530
value. The "Int" and the "Error" type and
the objects of that type are values just because

00:07:15.530 --> 00:07:21.390
they have the right methods. So the final
piece we need for the evaluator is some way

00:07:21.390 --> 00:07:27.100
to create values. We need some way to take
a string that's been typed in and create the

00:07:27.100 --> 00:07:32.460
appropriate value. And so here's the implementation
of that. It's called "newVal". And it calls

00:07:32.460 --> 00:07:37.720
"Atoi" on the string literal. And then if
that succeeds, it returns an int, and otherwise

00:07:37.720 --> 00:07:42.890
it returns an error saying, "This is what
you typed, but it's not valid." And the evaluator

00:07:42.890 --> 00:07:47.360
has a parser, which we're not showing you,
that just tokenizes, parses, and in effect,

00:07:47.360 --> 00:07:58.751
calls the "newVal", "BinaryOp", and "String"
methods. So let's look at the demo. Here's

00:07:58.751 --> 00:08:04.840
our evaluator. If I type "2" then the evaluator
has printed the answer "2", but it's also

00:08:04.840 --> 00:08:09.640
shown a trace of what calls it made. And first,
it called "newVal" on the string "2" that

00:08:09.640 --> 00:08:14.070
I typed in, and it returned--"newVal" returned
the int "2", and then it immediately turned

00:08:14.070 --> 00:08:19.590
it back into a string. So that's not terribly
interesting. If we do "4", it looks the same.

00:08:19.590 --> 00:08:26.020
But if we say "2+4", we get the two "newVal"
calls and then we see "2" called with the

00:08:26.020 --> 00:08:30.910
"BinaryOp" of "+" and "4", and it returns
this new int "6". And then "6" has a--when

00:08:30.910 --> 00:08:35.890
you convert it to a string, it gets back the
string to print. On the other hand, and so

00:08:35.890 --> 00:08:41.141
if, you know--if we do something like "2*3+1",
the right things happen. On the other hand

00:08:41.141 --> 00:08:47.850
if I type "X", "X" is not an integer and I
get the error back. And if I say "2+X", you

00:08:47.850 --> 00:08:51.900
can see that the "2" got created, and then
the error gets created. And then the error

00:08:51.900 --> 00:08:56.620
gets passed to the "BinaryOp" for the Int,
and it gets returned back and we end up with

00:08:56.620 --> 00:09:02.590
"illegal literal 'x'". Now it'd be nice if
we have strings in this. So let's try a string

00:09:02.590 --> 00:09:09.780
and it doesn't work. So let's fix that. If
we want to add strings, we define a new type

00:09:09.780 --> 00:09:14.420
capital "String" which has the same representation
in memory as a normal string. And "String"

00:09:14.420 --> 00:09:19.090
"String" method returns the quoted form. And
the "BinaryOp" is the same form as before.

00:09:19.090 --> 00:09:23.820
We look at the type of "Y", and we pick off
the operations that we want to support. And

00:09:23.820 --> 00:09:29.930
so this slide, we have "String + String" and
"String * Int" as valid operations. And we

00:09:29.930 --> 00:09:35.800
have this "Error" type. And again, we return
the "Error" if it's not valid. Now notice,

00:09:35.800 --> 00:09:41.070
we just defined a second method that has a--second
type that has a representation string with

00:09:41.070 --> 00:09:44.940
different methods. So we have "Error" and
we have capital "String", and they both have

00:09:44.940 --> 00:09:47.760
the "String" method and the "BinaryOp" method.
And they're both represented in memory as

00:09:47.760 --> 00:09:52.930
a string, but I've pointed out before that
when you want to convert between two different

00:09:52.930 --> 00:09:57.230
things with the same representation, you have
to be explicit. And this is one reason why

00:09:57.230 --> 00:10:01.430
so that whenever you're looking at an expression
and a method call, you know what the type

00:10:01.430 --> 00:10:04.820
on the left is, because there's no implicit
conversion. And so it's always clear which

00:10:04.820 --> 00:10:10.779
method's being called. So we also have to
change "newVal" to recognize the quoted strings

00:10:10.779 --> 00:10:15.950
that we type in. So if "Atoi" fails before
we return an error, we try to interpret it

00:10:15.950 --> 00:10:20.420
as a quoted string. And if that works, we
return the string. And notice that, again,

00:10:20.420 --> 00:10:24.390
we just added the "String" type by writing
the code that was necessary for strings. There

00:10:24.390 --> 00:10:38.529
was no bookkeeping that was necessary. So
let's look at this. Say "hello" string, "newVal"

00:10:38.529 --> 00:10:50.340
returns the string "hello". And we can say
things like ""hello"*3", and it does what

00:10:50.340 --> 00:10:57.300
you'd expect. So if we step back for a moment.
If you're coming from Java or C++ or Python,

00:10:57.300 --> 00:11:01.770
the thing that's missing in this program is
a type hierarchy. And in Java and those other

00:11:01.770 --> 00:11:05.650
languages, the type hierarchy is really the
foundation of your program. And you have to

00:11:05.650 --> 00:11:08.780
put it down before you write the rest of your
program. And then when you get halfway through

00:11:08.780 --> 00:11:12.480
your program, a lot of times you've realized,
"Oh, I should have structured it differently.

00:11:12.480 --> 00:11:17.040
And at that point, it can be hard to change.
And in fact, it's often easier to just struggle

00:11:17.040 --> 00:11:22.850
along with a slightly incorrect type hierarchy
than it is to go back and change it. Now in

00:11:22.850 --> 00:11:27.450
Go, program is not primarily about the types
and the type hierarchy. And in fact, there

00:11:27.450 --> 00:11:32.011
is no explicit type hierarchy. And so the
most important design decisions in your program

00:11:32.011 --> 00:11:37.290
can be delayed. And it's easy to change the
types in the program later, because the compiler

00:11:37.290 --> 00:11:41.920
can figure out the relations between them
and you don't have to maintain that information

00:11:41.920 --> 00:11:48.310
yourself. And we think that this makes Go
programs more flexible and more adaptable.

00:11:48.310 --> 00:11:54.490
So, I've pointed out that we have no type
hierarchy, so we have no inheritance. So how

00:11:54.490 --> 00:11:59.130
do you handle a case where, in Java or in
C++, you would use inheritance? So that's

00:11:59.130 --> 00:12:06.360
the next example we're going to look at. In
Java, if you had a "ZLibCompressor" that has

00:12:06.360 --> 00:12:11.720
a "compress" method that takes two-byte arrays.
But now we want to support a "Buffer", compressing

00:12:11.720 --> 00:12:16.100
buffers, and buffers of some other type. And
we want to do this in a way that's going to

00:12:16.100 --> 00:12:19.180
generalize to other compressors. So if we
have some other compress function, we can

00:12:19.180 --> 00:12:24.740
reuse our effort. So what you would do in
Java is you would define an abstract compressor

00:12:24.740 --> 00:12:29.490
class. And it would have an abstract compress
method with the bytes--byte arrays, but then

00:12:29.490 --> 00:12:33.410
it would have a concrete compress method that
talked about buffers and implement it using

00:12:33.410 --> 00:12:37.810
the byte array compress. And then we would
go back to our original ZLib and we would

00:12:37.810 --> 00:12:44.150
add the magic words "extends AbstractCompressor".
And this is very common Java style. You inherit

00:12:44.150 --> 00:12:51.100
the abstract class and you get the concrete
behavior from it that you want to add. Now

00:12:51.100 --> 00:12:55.270
in Go, things look different. So we have the
same example. Again, we have a "ZlibCompressor",

00:12:55.270 --> 00:13:00.029
it has a compress method that takes two byte
slices, and we want to support "Buffer" in

00:13:00.029 --> 00:13:04.550
some general way. But in Go, we don't do it
with an abstract class. Instead, we define

00:13:04.550 --> 00:13:09.301
an interface for the compressor, and then
we just write an ordinary function. So we

00:13:09.301 --> 00:13:13.680
have a compressor interface that says, you
know, some thing is a compressor if it has

00:13:13.680 --> 00:13:18.400
this compress method. And then we have a compress
buffer function, not an abstract class but

00:13:18.400 --> 00:13:23.410
a function, that takes the compressor and
uses it to compress from the input buffer

00:13:23.410 --> 00:13:28.290
to the output buffer. And this is good Go
style, you define what behavior you need as

00:13:28.290 --> 00:13:32.560
an interface and then you just write a function
that takes that interface. This is easier

00:13:32.560 --> 00:13:37.890
and it's less typing with fewer types that
in the Java and C++ way. And you could use

00:13:37.890 --> 00:13:42.700
this kind of approach in Java, but it's not
common Java style because Java puts an emphasis

00:13:42.700 --> 00:13:48.960
on using inheritance. But it's not just a
matter of style. Even if you did it in Java,

00:13:48.960 --> 00:13:53.730
Go has significant benefits over the Java
interface way too. So first of all, in Go,

00:13:53.730 --> 00:13:58.710
you can use as many wrappers as you like,
because the type can satisfy many interfaces

00:13:58.710 --> 00:14:04.990
whereas it can only inherit one abstract--from
one abstract class. In Java, you can only

00:14:04.990 --> 00:14:09.350
extend one abstract class. And a bigger deal
is that we had to go back to our original

00:14:09.350 --> 00:14:14.460
Java program and add the words extends abstract
compressor. And what if it's not, what if

00:14:14.460 --> 00:14:18.160
that code is not yours to edit? What if it's
in some standard library that really shouldn't

00:14:18.160 --> 00:14:24.300
know about this new thing you've defined?
In Go, because things are automatically inferred

00:14:24.300 --> 00:14:28.340
by the compiler, the compressor, the implementer
of compressor doesn't have to know that there

00:14:28.340 --> 00:14:33.210
is a compressor interface. And, similarly,
the definition of the compressor interface

00:14:33.210 --> 00:14:37.430
doesn't need to know that's enabling this
"CompressBuffer" function, and so all of these

00:14:37.430 --> 00:14:43.890
types can be in these joint pieces of library
without explicit dependencies between them.

00:14:43.890 --> 00:14:48.440
And notice that in Java even if you use interfaces,
you still have to go back and say implements

00:14:48.440 --> 00:14:53.399
compressor, and so you still have this problem
that you have to go back and edit the code

00:14:53.399 --> 00:14:58.370
and introduce dependency. Now that's one way
that you would use interfaces to do something

00:14:58.370 --> 00:15:03.210
like you do in other languages. But I also
want to talk about ways that you use interfaces

00:15:03.210 --> 00:15:09.070
just in Go in a more unique to Go. And one
of them is one of the reasons that there are

00:15:09.070 --> 00:15:13.560
more unique ways as interfaces are lightweight
and in fact the typical Go interface has only

00:15:13.560 --> 00:15:20.350
one or two methods. And programmers who are
new to Go tendency interfaces has a building

00:15:20.350 --> 00:15:25.550
block for type hierarchies. They see it as
a way to get back to hierarchies and big classes

00:15:25.550 --> 00:15:29.060
and they tend to create interfaces with lots
of methods. But we found that programming

00:15:29.060 --> 00:15:33.120
in Go is not quite the right way to think
about them. When we think about interfaces,

00:15:33.120 --> 00:15:38.640
they're often small and very precise and nimble
and often ad-hoc because you don't have to

00:15:38.640 --> 00:15:44.260
go back and tell the other classes or the
packages that you're using these interfaces.

00:15:44.260 --> 00:15:49.720
So this is a real example that we did a few
weeks ago. There's an RPC package in Go and

00:15:49.720 --> 00:15:54.670
it uses a package called gob to marshal objects
on the wire and the only language that has

00:15:54.670 --> 00:15:58.540
support for gob format is Go and we thought
it might be nice to talk to other languages

00:15:58.540 --> 00:16:03.160
and so we thought, well, what can we do to
make this work with JSON? And so we can speak

00:16:03.160 --> 00:16:08.980
standard JSON-RPC. So we abstract the codec
into an interface and the server codec is

00:16:08.980 --> 00:16:13.520
shown on the slide. And the server codec says,
you can be a server codec if you have a way

00:16:13.520 --> 00:16:18.240
to read or request header, to read the request
body and then to write a response and the

00:16:18.240 --> 00:16:22.110
server will loop doing that for a while and
eventually close the connection and there's

00:16:22.110 --> 00:16:28.630
a similar client codec. And then, when we
went to the RPC code, we just had to change

00:16:28.630 --> 00:16:33.920
the signature of a few functions. So the send
response function used to take a gob encoder

00:16:33.920 --> 00:16:39.480
and now it takes this more general interface
value. And, similarly, the function to handle

00:16:39.480 --> 00:16:44.200
a request had the same kind of change and
this, basically, the whole change the RPC

00:16:44.200 --> 00:16:48.140
implementation. We took the opportunity to
clean up a few other things at the same but,

00:16:48.140 --> 00:16:52.149
in general, that kind of change is all you
need because of the implicit typing that goes

00:16:52.149 --> 00:16:57.300
on and the rest of the function and the rest
of the program. And notice that we're doing

00:16:57.300 --> 00:17:02.839
this after the fact. It's really powerful
that we can make these changes after the fact

00:17:02.839 --> 00:17:10.669
and not have to plan ahead for them. This
whole change, the converting RPC, to use the

00:17:10.669 --> 00:17:14.499
interface and then JSON took us about 20 minutes
and that included writing and testing the

00:17:14.499 --> 00:17:19.720
JSON implementation of the interface and the
trivial wrap around gob to implement the interface.

00:17:19.720 --> 00:17:25.610
And in Java, you'd probably start with, you
start by factoring RPC into this half-abstract

00:17:25.610 --> 00:17:30.929
class and then you would subclass it to do
JsonRPC and GobRPC. But then you might have

00:17:30.929 --> 00:17:34.889
to decide, oh, but I want to have the same
RPC server but with per connection changes

00:17:34.889 --> 00:17:38.549
and so that would be another re-factoring.
In Go, there's no need to manage this kind

00:17:38.549 --> 00:17:42.759
of decision or this kind of type of hierarchy.
You just pass in the codec interface stub

00:17:42.759 --> 00:17:50.549
and you're done. One more example of interfaces;
we've seen examples of using it to structure

00:17:50.549 --> 00:17:57.840
program and re-factoring and also to provide
abstract wrappers. Well, one of the most powerful

00:17:57.840 --> 00:18:05.059
things in Go is the way we use interfaces
for chaining and for defining new kinds of

00:18:05.059 --> 00:18:13.769
objects that all satisfy a common interface.
And so, in this kind of common interface tends

00:18:13.769 --> 00:18:17.660
to arise organically. It's not something that's
planned, it just turns out that we have a

00:18:17.660 --> 00:18:21.559
lot of different types that have the same
methods and so then it becomes useful to define

00:18:21.559 --> 00:18:26.489
an interface that says, you don't have these
methods and then functions can use them. So,

00:18:26.489 --> 00:18:30.441
you might be familiar with the "io.Reader"
and the "io.Writer" interfaces which are very

00:18:30.441 --> 00:18:34.470
commonly used and have just one method each,
read and write. It's really important that

00:18:34.470 --> 00:18:38.549
these interfaces don't need retrofitting to
work with the existing code. It's important

00:18:38.549 --> 00:18:41.720
that when you introduce the concept of an
"io.Reader," you don't have to go back to

00:18:41.720 --> 00:18:47.100
every single thing with the read method and
say, implements reader. So this is a more

00:18:47.100 --> 00:18:51.929
complex example in reader and writer. When
we started to writing cartography code, we

00:18:51.929 --> 00:18:55.980
noticed that, we have the first code we wrote
was the "aes.Cipher" implementation and it

00:18:55.980 --> 00:19:00.320
was struck with the methods and the methods
that have were "BlockSize" which returns the

00:19:00.320 --> 00:19:05.679
current "BlockSize," the encryption unit size,
and decrypt and encrypt. And, similarly, when

00:19:05.679 --> 00:19:10.330
"blowfish" and "xteo," and other came along,
they mimic this set of methods. And we notice,

00:19:10.330 --> 00:19:14.119
well, if we're going to write code that takes
an arbitrary cipher, we should define an interface

00:19:14.119 --> 00:19:18.650
with these three methods and then it will
apply to all of them. And so the block cipher

00:19:18.650 --> 00:19:23.990
package defines this interface and then defines
these block cipher functions using the interface

00:19:23.990 --> 00:19:29.809
with things like "NewCBCDecrypter," "NewCFBDecrypter,"
"NewOFBereader" implement cipher block chaining,

00:19:29.809 --> 00:19:34.789
cipher feedback and alpha feedback mode, all
taking this cipher and they're not tuned to

00:19:34.789 --> 00:19:40.080
specific cryptographic implementations. So
if you want AES in CBC mode, you create a

00:19:40.080 --> 00:19:44.430
new AES cipher and you pass it to the new
CBC decrypter. And, similarly, if you want

00:19:44.430 --> 00:19:48.460
Blowfish in CBC mode, you can see what to
change. You just create a Blowfish cipher

00:19:48.460 --> 00:19:54.429
instead and there's no need for this cross
product of every possible mode and every possible

00:19:54.429 --> 00:19:59.940
cryptographic algorithm what you see in other
libraries. It's so simple in Go to compose

00:19:59.940 --> 00:20:04.910
them that there's no point in providing all
the different compositions beforehand. And

00:20:04.910 --> 00:20:09.299
this kind of chaining is very useful because
you can chain all sorts of different things.

00:20:09.299 --> 00:20:14.379
So, if we go back to the reader example, and
you might have noticed that the readers on

00:20:14.379 --> 00:20:18.150
the previous slide or the, they took a site
for but they also took a reader and return

00:20:18.150 --> 00:20:23.279
the reader. And the reads on the return reader
are satisfied by reading from the underlying

00:20:23.279 --> 00:20:28.509
stream and decrypting it. And so we can write
this function that decrypts and decompresses

00:20:28.509 --> 00:20:32.499
from a source file to a destination file just
by chaining a sequence of readers together.

00:20:32.499 --> 00:20:37.840
So the first line opens a source file and
then remembers to close it. And the third

00:20:37.840 --> 00:20:42.970
line there, creates a new AES cipher given
the key data and then passes that cipher and

00:20:42.970 --> 00:20:48.489
the file to "newOFBReader" with the key data,
with more key data. And the result of that

00:20:48.489 --> 00:20:53.659
is a reader and that reader, that first reader
"r" when you read from it, the implementation

00:20:53.659 --> 00:20:58.179
will read from "f" and decrypt it and return
the decrypted data. And then we can pass that

00:20:58.179 --> 00:21:03.710
to a gzip new reader and then the "r" that
the gzip new reader function returns. When

00:21:03.710 --> 00:21:08.830
you return from that, it will read the unencrypted
data from the first "r" decompress it and

00:21:08.830 --> 00:21:14.009
return you the uncompressed data. And then
finally write, we open a new file for writing,

00:21:14.009 --> 00:21:20.879
remember to close it and we copy from "r"
into "w". And so with that, I'll turn over

00:21:20.879 --> 00:21:28.980
to Rob to talk about concurrency.
&gt;&gt; PIKE: Thanks, Russ. So, Russ has been talking

00:21:28.980 --> 00:21:33.429
about thinking about programming with the
types and the way the types working inside

00:21:33.429 --> 00:21:36.980
Go and how you structure program given the
kinds of things you want to do when you're

00:21:36.980 --> 00:21:40.570
combining different types and stuff like that.
I'm going to talk about a complete different

00:21:40.570 --> 00:21:45.519
way of thinking about Go programming which
is how we think about concurrency. If you're

00:21:45.519 --> 00:21:50.100
working in Java, you start by thinking about
what the class hierarchy is, how you're going

00:21:50.100 --> 00:21:56.309
to arrange the representation between the
items, and that's fine but it's not Go. In

00:21:56.309 --> 00:22:02.389
Go, if you're writing something like a server
or some distributed program, you can use the

00:22:02.389 --> 00:22:06.480
elements of Concurrent program that construct
the design of your program with a very different

00:22:06.480 --> 00:22:10.679
field and, actually, a very powerful one.
And as Russ said early on, it's not about

00:22:10.679 --> 00:22:15.509
parallelism. Concurrency is not about getting
all the cores humming as hard as you can by

00:22:15.509 --> 00:22:19.809
doing Vector ops or anything like that. It's,
but is a way to make programs use multiple

00:22:19.809 --> 00:22:24.739
for a machine as well in cleanly and easy
in a way that's really easy to understand.

00:22:24.739 --> 00:22:29.909
The resulting programs are structured well
and they're very easy to change and adapt

00:22:29.909 --> 00:22:34.809
as requirements change. So, in short, it's
about, the structure of the program rather

00:22:34.809 --> 00:22:39.799
than the performance you get, but the performance
tends to come out anyway. So we need an example

00:22:39.799 --> 00:22:44.179
and it's hard to do a really, you know, new
full on example and the time we have available.

00:22:44.179 --> 00:22:47.909
So, we're going to take a very idealized one,
but it illustrates a lot of the points about

00:22:47.909 --> 00:22:53.221
how this stuff works. So imagine you have
a bunch of processes that have work to do,

00:22:53.221 --> 00:22:57.909
and they're going to send a request out to
some smaller set of workers presumably worker

00:22:57.909 --> 00:23:03.250
machine somewhere that are going to performs
an operations for them and send the answers

00:23:03.250 --> 00:23:08.369
back. In the middle, we want to place a load
balancer that uses, that controls the load

00:23:08.369 --> 00:23:13.029
across the set of worker machines to balance
the load across all of the workers and keeps

00:23:13.029 --> 00:23:17.259
it to sort of even load it. We're going to
assume that the workers work best when they

00:23:17.259 --> 00:23:21.509
have a lot of work to do simultaneously for
whatever reasons just makes it work nicely.

00:23:21.509 --> 00:23:26.169
If this is a real problem, of course, we'd
use a lot of computers and networking and

00:23:26.169 --> 00:23:28.710
so on and so on and so on. But we're not going
to do that because that just makes the example

00:23:28.710 --> 00:23:33.299
longer without really adding anything to it.
So this is a very simple model but its representative

00:23:33.299 --> 00:23:37.390
of the core of something you might actually
want to do. So let's start what a request

00:23:37.390 --> 00:23:41.749
is going to be. You're going to have some
piece of work you want to do and you're going

00:23:41.749 --> 00:23:47.090
to send across to the worker via a load balancer
and then when the worker has finished the

00:23:47.090 --> 00:23:52.999
task, it's going to send the answer back on
a channel to the requesting processing as

00:23:52.999 --> 00:23:56.549
your result. And then in the middle of the
balancer is going to have some metric for

00:23:56.549 --> 00:24:00.890
the load on the workers that's going to use
to even out the load. It looks a little bit

00:24:00.890 --> 00:24:05.080
like this. Across the top, we have a bunch
of requesters, there's probably many, many

00:24:05.080 --> 00:24:11.110
more requesters and workers but, it's really
hard to make slides that look like that. So

00:24:11.110 --> 00:24:14.559
we'll just assume there's a lot more requesters
on the top. The bottom is a smaller number

00:24:14.559 --> 00:24:17.940
but it still substantial a number of workers.
And then there's just load balancer in the

00:24:17.940 --> 00:24:22.330
middle that has a single channel for all the
requests that are coming in. And then it immediately

00:24:22.330 --> 00:24:27.369
forwards each request to the leg, most lightly
loader worker that's running, and then as

00:24:27.369 --> 00:24:31.609
the worker completes each request and sends
the answer directly back to the thing that

00:24:31.609 --> 00:24:35.399
requested it. And also although it's not in
this slide, it's going to signal the load

00:24:35.399 --> 00:24:41.940
balancer, I'm done now, so you can adjust
the load you have stored from it. So, the

00:24:41.940 --> 00:24:46.279
requesters look like this. You have a request
represented by a closure which is the operation

00:24:46.279 --> 00:24:50.049
you're going to perform that returns some
type which we're just making into you for

00:24:50.049 --> 00:24:55.190
simplicity. And then a channel of that type
which is the response channel so, you're going

00:24:55.190 --> 00:24:59.419
to send, say, basically, run this function
and then when the answer is done, send it

00:24:59.419 --> 00:25:03.590
back to me on this channel, that's a request.
And then here's a really sort of simple minded

00:25:03.590 --> 00:25:10.639
but functional version of the requesting operation,
it just sits in a loop doing something else

00:25:10.639 --> 00:25:16.261
for a while probably and then sends a request
in a form of close on a channel to the work

00:25:16.261 --> 00:25:21.239
channel which delivers it to the load balancer.
And then it says, wait for the answer to come

00:25:21.239 --> 00:25:26.120
back from the worker. And once the answer
has come back it probably does some more processing

00:25:26.120 --> 00:25:30.460
on it. Now the worker is going to sit there
waiting for a request to be delivered now

00:25:30.460 --> 00:25:35.190
from the load balancer and then it just sits
in a loop doing the obvious thing; gets a

00:25:35.190 --> 00:25:40.059
request, executes the function of the request,
sends the answer back on the channel, and

00:25:40.059 --> 00:25:44.779
then tells the load balancer, hey, I'm done,
and by just sending a point itself on the

00:25:44.779 --> 00:25:50.039
done channel. And so this is very, very simple
but it works. And it's important to know that

00:25:50.039 --> 00:25:53.690
the response is going directly back to the
load balancer because the channel gives you

00:25:53.690 --> 00:25:57.570
the capability to tell the worker to respond
to you even though the load balancer in the

00:25:57.570 --> 00:26:04.259
middle doesn't need to know, doesn't need
to keep track of the connections between the

00:26:04.259 --> 00:26:07.059
workers and requesters. So now we got enough
to sort of think about the load balancer and

00:26:07.059 --> 00:26:12.740
we need, we definitely a pool of workers,
that's obvious, we represent that with a slice.

00:26:12.740 --> 00:26:17.639
And then, the balancer itself is a simple
structure that has this pool inside it and

00:26:17.639 --> 00:26:19.970
then the worker channel, so that the workers
can signal when they're done; that can be

00:26:19.970 --> 00:26:26.330
a single channel for all of them because it's
not going to be very busy. And now at this

00:26:26.330 --> 00:26:30.239
point, this is actually the load balancer,
this is all we have to do. We sit in the loop,

00:26:30.239 --> 00:26:34.970
and one of two things is happen; we either
are going to get a request in which case we

00:26:34.970 --> 00:26:40.059
dispatch it to the most likely loaded worker.
Or, a worker tells us it's done in which case

00:26:40.059 --> 00:26:45.239
we update the status of that worker so that
we keep the load sorted out, so that's very

00:26:45.239 --> 00:26:49.940
simple. Now we just have to write two functions;
dispatch and completed. And the way to think

00:26:49.940 --> 00:26:55.470
about that is if you imagine the load balancers,
basically, maintaining a priority queue and

00:26:55.470 --> 00:26:57.889
the things that the head of the queue are
the most likely loaded objects, so we want

00:26:57.889 --> 00:27:05.101
to order that queue by the length of the request
queue going to that worker and to do that,

00:27:05.101 --> 00:27:08.190
the simple thing to do is to just write a
heap. So we basically are going to make a

00:27:08.190 --> 00:27:13.100
heap of channels where the channels representing
the workers inside the worker struct and then

00:27:13.100 --> 00:27:17.611
the load is represented by the length of those
queues. And to do that all we have to do is

00:27:17.611 --> 00:27:23.269
attach the methods for heap onto the pool
type which is part of the implementation of

00:27:23.269 --> 00:27:27.659
the balancer. And they're very, they're all
very simple--here's the less method, there's

00:27:27.659 --> 00:27:30.659
a few others but they're all not, you know,
like, most of them are like one or two lines

00:27:30.659 --> 00:27:35.039
as one is about four or five lines, but they're
all pretty easy. And once we've done, the

00:27:35.039 --> 00:27:39.470
pool of workers behaves like a heap and so
now we just need to define the worker structure

00:27:39.470 --> 00:27:45.979
which is has nothing in it but a request channel
and the count of pending request and then

00:27:45.979 --> 00:27:51.169
an index which is part of the heap implementation.
So now we can implement, right? Here's the

00:27:51.169 --> 00:27:55.320
dispatch. All of the dispatch has to do is
give in a request, you pop the element off

00:27:55.320 --> 00:27:59.470
the heap that will be the most likely loaded
worker, you send the request, you increment

00:27:59.470 --> 00:28:04.239
its pending count and put it back in the heap,
that's it. And for the completed set, it's

00:28:04.239 --> 00:28:09.519
the inverse. You decrement the count for the
load on that worker, take it out of the heap

00:28:09.519 --> 00:28:14.500
and put it back again, that's the whole thing.
And this is all working because the channels

00:28:14.500 --> 00:28:18.429
are first class values and the methods can
be attached this pool type to turn the pile

00:28:18.429 --> 00:28:29.539
of workers into a heap sort of post facto.
So let's show it running here. So this is

00:28:29.539 --> 00:28:34.700
not very graphical but you can get the idea.
This job has 100 requesters and 10 workers,

00:28:34.700 --> 00:28:41.019
and the workers are, the heap is basically
the pool on the left there shows the count

00:28:41.019 --> 00:28:45.669
of the load on each worker. And then the columns
on the right are the average and standard

00:28:45.669 --> 00:28:49.720
deviation of the load. You can see the load
is going up because there's a lot of happening

00:28:49.720 --> 00:28:53.840
but the standard deviation stays pretty small
because the balancer is doing its job, that's

00:28:53.840 --> 00:28:59.440
pretty simple. And just for reference, I made
a version that just trivially does round robin

00:28:59.440 --> 00:29:04.619
on the workers rather than a balancer. And
if you let this run for a little bit, you'll

00:29:04.619 --> 00:29:08.779
see the load goes up as it does in the case
but the standard deviation starts to grow.

00:29:08.779 --> 00:29:15.330
At least, it does--here we go. It's increasing.
It's not nearly as even balanced as it was

00:29:15.330 --> 00:29:19.539
in the case where we actually used a heap
or a queue for the worker, so it's just, you

00:29:19.539 --> 00:29:23.471
know, a proof of concept that's not--there
you go you see the loads starting to go very

00:29:23.471 --> 00:29:30.940
uneven across those workers. So, let's, so
to go back to the discussion here, there's

00:29:30.940 --> 00:29:33.980
a couple of things about this program that
are interesting. One is that it actually works,

00:29:33.980 --> 00:29:39.139
I've shown almost the entire implementation
just a little bit of setup is missing. Everything

00:29:39.139 --> 00:29:44.739
that this thing is doing is synchronous. Everything
blocks and yet the system is highly concurrent,

00:29:44.739 --> 00:29:50.590
and there's not also a single mutex in sight.
Everything is done--the structure of the concurrent

00:29:50.590 --> 00:29:54.820
operations makes it possible to write a program
like this is totally non-blocking even thought

00:29:54.820 --> 00:29:59.009
it's built out of synchronous operations and
there's no mutexes, there's no worrying about

00:29:59.009 --> 00:30:02.279
memory barriers or any of that stuff. But
the fundamental properties of the language

00:30:02.279 --> 00:30:06.180
make it really easy to write a software like
this. Another nice thing nice thing is that

00:30:06.180 --> 00:30:10.669
this notion of a closure and the channel as
a pair. It's a really powerful idea. I can

00:30:10.669 --> 00:30:15.210
send work to somebody and include a way to
get the answer back to me afterwards and that's

00:30:15.210 --> 00:30:19.129
a really powerful structuring concept that
you see in a lot of Go code. And also you

00:30:19.129 --> 00:30:23.429
see these channels being parts of first class
values that are passed around between different

00:30:23.429 --> 00:30:27.229
Go routines as they're running, that's a really
important concept that's missing from some

00:30:27.229 --> 00:30:31.179
other, not all, but some other concurrent
languages where the connections are much more

00:30:31.179 --> 00:30:35.529
rigid than they are when you pass channels
around. Now this is a very simple example.

00:30:35.529 --> 00:30:39.869
We can do a much more interesting case where
we had networks and stuff like that to distribute

00:30:39.869 --> 00:30:42.710
load across many machines and they would look
fundamentally the same but you just have to

00:30:42.710 --> 00:30:46.100
do a little bit of work on it get there. But
it's not really relevant to any of structuring

00:30:46.100 --> 00:30:55.529
the program, principles are all in this example.
So, to conclude here, I think we've shown

00:30:55.529 --> 00:31:00.789
that programming in Go is not like programming
in Java or C++ or Python. Even though when

00:31:00.789 --> 00:31:03.990
you read the spec, you might think it's a
very sort of straightforward language. It's

00:31:03.990 --> 00:31:08.500
actually a lot going on that feels very different
when you write real code in it. These include

00:31:08.500 --> 00:31:13.489
the fact that objects are not always classes.
In fact, it can be anything including--we've

00:31:13.489 --> 00:31:19.369
seen examples with strings of integers and
slices and structures, and methods are being

00:31:19.369 --> 00:31:23.590
used on all of those things. And so inheritance
is not only, not the only way to structure

00:31:23.590 --> 00:31:27.779
a program, it hardly even comes up. The inheritance
properties have gone up very interesting compared

00:31:27.779 --> 00:31:31.270
to some of the other things we can do with
things like interface. We also don't need

00:31:31.270 --> 00:31:35.389
to write everything down in advance. You don't
start by designing your whole superstructure

00:31:35.389 --> 00:31:39.489
of your type system before you write any code.
In fact, a lot of the relationships between

00:31:39.489 --> 00:31:45.189
types tend to come up as the programming evolves
or even long after it does like the PRPC example.

00:31:45.189 --> 00:31:49.469
And because of this, a lot of things are discovered
long after the program is written, it can

00:31:49.469 --> 00:31:54.479
be very pleasant. It was amazing to us that
we may implement a JSON-RPC but just substituting

00:31:54.479 --> 00:32:00.090
an interface into our existing RPC implementation.
And Russ said just the 20-minute job, and

00:32:00.090 --> 00:32:03.399
that's the kind of things it's very hard to
do when the structure of the whole program

00:32:03.399 --> 00:32:09.409
is based around in here. And also, concurrency,
a lot of people think it's really about parallelism

00:32:09.409 --> 00:32:15.080
and it's not. It's about structuring software
so that it can adapt and grow in a very parallel

00:32:15.080 --> 00:32:22.830
universe. And it's not about getting all of
the, it's not about numeric competitions but

00:32:22.830 --> 00:32:28.859
system structure. And as a result of these
changes from existing languages, we think

00:32:28.859 --> 00:32:33.519
that was a very much more productive environment.
You can get a lot done very quickly because

00:32:33.519 --> 00:32:37.690
things tend to be much more nimble when you're
working on it. You can give a method to any

00:32:37.690 --> 00:32:41.759
type which means this all these opportunities
for designing your program that are very different

00:32:41.759 --> 00:32:46.509
from a world where everything is a class and
you think of much larger objects are being

00:32:46.509 --> 00:32:50.989
things that have methods attached. A lot of
the bookkeeping that you see in a type driven

00:32:50.989 --> 00:32:54.509
programming simply doesn't appear in a Go
program. The power is still there but the

00:32:54.509 --> 00:32:59.099
compiler takes care of it for your and that's
just a huge productivity game right there.

00:32:59.099 --> 00:33:03.309
And then, this, it's hard to sort of through
big examples but I think I've shown looks

00:33:03.309 --> 00:33:06.909
like this load balance, for example, that
concurrency is the way to structure a program

00:33:06.909 --> 00:33:11.019
in a way that makes it really productive to
write programs that work with, you know, very

00:33:11.019 --> 00:33:16.590
high load and very interesting parallel environments.
And as a result, Go programs tend to be very

00:33:16.590 --> 00:33:23.229
malleable and adaptable and much less brittle
as conditions change. And, if any of these

00:33:23.229 --> 00:33:26.859
interests you, of course, there's a lot more
available at the website golang.org. But the

00:33:26.859 --> 00:33:32.889
most important point is that Go is a lot more
fun, the programming and, of course, it comes

00:33:32.889 --> 00:33:38.100
with t-shirts and tattoos and stickers. So
we'll do a Q&amp;A now but as you go, there's

00:33:38.100 --> 00:33:43.029
a pile of t-shirts down there and feel free
to take one as you leave if that's the sort

00:33:43.029 --> 00:33:50.409
of thing you like. I said as you go, we're
going to do a Q&amp;A first. And as I said at

00:33:50.409 --> 00:33:56.119
the beginning there's a Q&amp;A thing on this
wave, live wave thing but remember to go to

00:33:56.119 --> 00:34:00.989
golang.org for a lot more information. So,
we'll do this. So there's also microphones

00:34:00.989 --> 00:34:05.739
if you want to do a live questions but we'll
start with the ones on the wave. Oops, can

00:34:05.739 --> 00:34:09.080
you...
&gt;&gt; COX: And if you're worried about making

00:34:09.080 --> 00:34:13.030
the next session, I think that everything
is delayed as much as we were, so, the next

00:34:13.030 --> 00:34:15.419
session has not started yet, right.
&gt;&gt; PIKE: And there's enough t-shirts for everyone,

00:34:15.419 --> 00:34:21.230
so you don't need to mob. Okay. Can you comment
on the suitability of Go for deploying a real

00:34:21.230 --> 00:34:26.929
application today; if not today, what timeframe?
Also, my comments on server is [INDISTINCT]

00:34:26.929 --> 00:34:34.119
with the mobile suitability. As far as the
first thing goes, we're already using Go internally

00:34:34.119 --> 00:34:38.460
at Google for some production stuff so, it
depends on the particular job you're have

00:34:38.460 --> 00:34:43.789
in mind but the language is pretty stable.
The libraries are good in getting better rapidly.

00:34:43.789 --> 00:34:50.809
And for things that it's ready for now, it's
already being used for production stuff. I

00:34:50.809 --> 00:34:55.840
don't know if I based the start up entirely
on Go now, but, it might, I don't know. So,

00:34:55.840 --> 00:35:00.270
as far timeframe goes, it's just going to
get more and more mature, of course, over

00:35:00.270 --> 00:35:04.980
time. But I think if you have an application
today, it might be the right language to do

00:35:04.980 --> 00:35:11.450
it. For server versus desktop versus mobile
suitability, it was originally design for

00:35:11.450 --> 00:35:15.670
server kind of stuff but it seems to work
very well for a lot of other things. The desktop

00:35:15.670 --> 00:35:19.319
capabilities are limited because the graphic
libraries aren't quite there yet, all the

00:35:19.319 --> 00:35:23.150
other are under way. And as far as mobile
goes, I don't have anything to say but we

00:35:23.150 --> 00:35:28.011
really love to see it in a mobile environment.
Do you have anything to add? There's a question

00:35:28.011 --> 00:35:31.059
here.
&gt;&gt; So I knew you have an ARM Compiler and

00:35:31.059 --> 00:35:35.530
I'm just curious with the status, when I think
of concurrency and ARM, I think of interop

00:35:35.530 --> 00:35:41.170
service routines for embedded programming.
Is it applicable and have you done it?

00:35:41.170 --> 00:35:44.380
&gt;&gt; COX: I think that we're still exploring
how you would do something in a very, very

00:35:44.380 --> 00:35:48.410
limited ARM environment on something like
the Android phone, which is also an ARM. You

00:35:48.410 --> 00:35:52.920
don't have those problems and so we've been
running our ARM Compiler tests on that kind

00:35:52.920 --> 00:35:57.549
of platform. We do have one developer who's
working on very, very tiny embedded things

00:35:57.549 --> 00:35:58.619
and I don't know exactly what he's going to
end up with.

00:35:58.619 --> 00:36:02.000
&gt;&gt; Thank you.
&gt;&gt; PIKE: What are your plans about port of

00:36:02.000 --> 00:36:08.750
a loop go [INDISTINCT] between different platforms?
There are no plans per se. It's a compiled

00:36:08.750 --> 00:36:13.470
language and so if you talk about portability,
you mostly mean source level portability.

00:36:13.470 --> 00:36:20.250
We try to make libraries very portable between
different environments. It already runs on

00:36:20.250 --> 00:36:25.930
Linux, MAC OS X, FreeBSD, there's a window
support that's pretty far along, and some

00:36:25.930 --> 00:36:30.690
other sort of ARM embedded stuff. I'm not
sure what to say about that, except that the

00:36:30.690 --> 00:36:34.690
language is intrinsically quite a bit more
parallel than language like C or C++, but

00:36:34.690 --> 00:36:40.109
not quite at the level of Java because it's
one level back in terms of the way you compile,

00:36:40.109 --> 00:36:43.930
but I think it's the right form of a language,
honestly. Yes.

00:36:43.930 --> 00:36:49.410
&gt;&gt; Can you address performance as compared
to C, C++ and Java for server-side programming

00:36:49.410 --> 00:36:56.610
with multi-cores? And also what if you need
to interface to existing libraries and those

00:36:56.610 --> 00:37:01.060
other languages?
&gt;&gt; COX: So working backwards, the interface

00:37:01.060 --> 00:37:05.290
to existing libraries, we have a basic tool
that let's you call C code from go and there's

00:37:05.290 --> 00:37:11.180
also work going on to--I hope go up this week
so that you'll be able to wrap C and C++ libraries

00:37:11.180 --> 00:37:16.000
this week. As far as performance, we found
that things that are highly computational

00:37:16.000 --> 00:37:21.960
tend to be about the same, maybe 10%, 20%
slower with C code and equivalent Go code,

00:37:21.960 --> 00:37:24.980
the place where it goes firewalls behind is
if you're littering your C code with things

00:37:24.980 --> 00:37:29.150
like M-line assembly and send the instructions
and things like that, then we can't keep up

00:37:29.150 --> 00:37:33.000
anymore. But if you're doing just sort of
standard portable C code and you translate

00:37:33.000 --> 00:37:38.790
that into Go, computationally, it's not very
much of a performance set at all.

00:37:38.790 --> 00:37:44.690
&gt;&gt; You did a lot of comparisons with type
languages or C, C++, Java and a lot of the

00:37:44.690 --> 00:37:45.690
structures reminded me more of functional
languages like Haskell or Lang and I was wondering

00:37:45.690 --> 00:37:52.929
if you could do a comparison with those and
where it goes--shines relative to these languages?

00:37:52.929 --> 00:37:58.960
&gt; PIKE: The functional language comparison,
I'm not a functional ad app. I think I'm a

00:37:58.960 --> 00:38:04.770
little bit comfortable with them but not very.
The language has full closures and so that's

00:38:04.770 --> 00:38:10.030
very nice to have but a lot of the sort of
magical type inference that functional languages

00:38:10.030 --> 00:38:14.799
do are not available in Go. The Go type inference
is very simple, it's basic. In front of your

00:38:14.799 --> 00:38:18.190
slides, you can draw out a type, the sort
of meta type of stuff that functional languages

00:38:18.190 --> 00:38:24.020
have, simply not in Go. And I think that would
probably be the biggest difference in thinking

00:38:24.020 --> 00:38:31.859
about them. Plans for not writing Androiding
in Go. There are no plans. I'd love to see

00:38:31.859 --> 00:38:38.161
it but I--honestly, we're a pretty small team
and it's not where we're going. But it's not

00:38:38.161 --> 00:38:46.380
an accident that ARM is one of the things
we support. I'll get back to that one. Yeah.

00:38:46.380 --> 00:38:49.950
&gt;&gt; I saw a lot of you saying, "Oh, well, this
is just, you know, to implement this, this

00:38:49.950 --> 00:39:01.440
is a bunch of one line functions and I think--it
seems like when you go inheritance to sort

00:39:01.440 --> 00:39:07.980
of implicit interfaces, you find to yourself
writing this--do you find yourself writing

00:39:07.980 --> 00:39:09.100
the same one line--the one line implementation
of the same piece in the interface over and

00:39:09.100 --> 00:39:10.279
over again in a lot of different places?
&gt;&gt; PIKE: No. The [INDISTINC] we didn't talk

00:39:10.279 --> 00:39:15.869
about which is embedding which replaces a
lot of that bookkeeping like stuff that you

00:39:15.869 --> 00:39:20.579
would--that I think you're alluding to. It's
possible to borrow the implementation of something

00:39:20.579 --> 00:39:25.440
else and drop it into your object and have
it--bring all the types along with--all of

00:39:25.440 --> 00:39:29.610
the methods along with it. And that tends
to avoid a lot of that sort of repetitive--that

00:39:29.610 --> 00:39:35.049
got to add this ten one line function to this
thing. I think that's what you're referring

00:39:35.049 --> 00:39:41.569
to. Yeah. Current situation with generics,
yeah, that always comes up. We spend probably

00:39:41.569 --> 00:39:46.960
more time on this one issue than almost anything
else. And the short answer is that we're still

00:39:46.960 --> 00:39:52.300
not happy that we've been able to find design
for generics that doesn't break something

00:39:52.300 --> 00:39:58.359
in the language or become to confusing for
users. So we're still thinking about it as

00:39:58.359 --> 00:40:03.599
it's still incredibly active discussion. We're
very sensitive that we have language that

00:40:03.599 --> 00:40:08.630
seems to work really well and we don't want
to mock it up with the generics implementation

00:40:08.630 --> 00:40:14.510
that complicates life when it should. Also,
speaking personally, this is just me, Russ

00:40:14.510 --> 00:40:18.859
may disagree. I don't--having used Go as my
main language now for almost 2 years, they

00:40:18.859 --> 00:40:23.960
don't really mess generics, they don't come
up. The language feels different. And a lot

00:40:23.960 --> 00:40:27.609
of the things that people want generics for
already sort of covered, not everything by

00:40:27.609 --> 00:40:31.510
any means, there's a lot of places where to
be nice. But it's not clear that it's important

00:40:31.510 --> 00:40:35.700
to go as it would be in some other language,
which is not to say that the word design comes

00:40:35.700 --> 00:40:37.930
along. We would not go for it. We definitely
would.

00:40:37.930 --> 00:40:41.710
&gt;&gt; COX: It's also--well, Rob said a lot of
people or at least a few people on the mailing

00:40:41.710 --> 00:40:46.599
list who have written significant amounts
of Go code have said the same thing that having

00:40:46.599 --> 00:40:50.630
written, you know, 1,000 or 5,000 lines code,
they found that, you know, they thought they

00:40:50.630 --> 00:40:54.380
we're going to miss generics but they don't
actually miss them now, so.

00:40:54.380 --> 00:40:59.049
&gt;&gt; PIKE: Yes.
&gt;&gt; You mentioned that there was a certain

00:40:59.049 --> 00:41:04.700
intrinsic properties of the language that
make it easier to manage consistency of your

00:41:04.700 --> 00:41:08.859
state in concurrent programming...
&gt;&gt; PIKE: I'm sorry. It's hard to understand

00:41:08.859 --> 00:41:09.859
the...
&gt;&gt; I'm sorry.

00:41:09.859 --> 00:41:11.680
&gt;&gt; PIKE: ...those things are terrible. Can
you speak a little louder?

00:41:11.680 --> 00:41:17.110
&gt;&gt; Yeah, sure. You mentioned that there was
a--there were intrinsic properties of the

00:41:17.110 --> 00:41:24.170
language that make it easier to concurrency,
perhaps rules dictating how code as it is

00:41:24.170 --> 00:41:28.869
running in parallel can be interleaved and
how that affects the state of variables in

00:41:28.869 --> 00:41:32.609
your closure, that kind of thing. Is that
a shortlist of properties in the language

00:41:32.609 --> 00:41:36.670
that you could speak to now?
&gt;&gt; PIKE: Well, there's quite a few, but you

00:41:36.670 --> 00:41:41.450
saw control structure in there which gives
a way to control access from multiple channels

00:41:41.450 --> 00:41:46.990
at once the select statement there. The way
the stacks work in Go is they start out small,

00:41:46.990 --> 00:41:51.320
they grow in demand. So, you don't have to
allocate a stack and say, "I need 10K of stack

00:41:51.320 --> 00:41:54.990
right now or something like that." The language
completely handles that for you. You don't

00:41:54.990 --> 00:42:00.690
do--you never think about stack size. And
they're cheap to do and recovered as necessary.

00:42:00.690 --> 00:42:07.160
The combination of communication and synchronization
that channels give you, once you've used them

00:42:07.160 --> 00:42:10.380
for awhile, you'll see it's an incredibly
powerful primitive. It's much more interesting

00:42:10.380 --> 00:42:14.589
to program this way than by passing memory
around and using [INDISTINCT] to protect.

00:42:14.589 --> 00:42:19.690
It's also a lot easier to get the code right.
For me, one of the things seems to--sort of

00:42:19.690 --> 00:42:24.849
say the most is my officemate, Rob [INDISTINCT]
who also work on Go had never worked in a

00:42:24.849 --> 00:42:30.920
concurrent language before, although we had
spend a fair amount of time dealing with C++

00:42:30.920 --> 00:42:32.079
and writing server software and that kind
of thing. And he find--he's written a lot

00:42:32.079 --> 00:42:36.690
of concurrent programs in Go now and he just
finds they work. He doesn't struggle with

00:42:36.690 --> 00:42:41.960
the problems he had writing server software
in C++. And it's not that he's got a concurrent

00:42:41.960 --> 00:42:45.920
brain. I've been writing concurrent programs
for many years now but this is all new to

00:42:45.920 --> 00:42:48.799
him. But he finds it's really natural to express
what he wants to do with this independently

00:42:48.799 --> 00:42:54.119
executing agents exchanging information. It's
just a very natural way to program. So the

00:42:54.119 --> 00:42:57.250
language enables that and that's nice.
&gt;&gt; COX: I would just add that in your question

00:42:57.250 --> 00:43:00.441
you talked about, you know, interleaving of
individual instructions and things like that

00:43:00.441 --> 00:43:04.579
and we found that if you're thinking about
that level, you now--you just never get it

00:43:04.579 --> 00:43:09.460
right. And what Go encourages you to do is--especially
with channels to let the Go routines communicate

00:43:09.460 --> 00:43:14.950
amongst themselves of explicit messages and
that communication forces coordination. And

00:43:14.950 --> 00:43:19.079
so you don't have to worry about, can these
instructions happened side-by-side, because,

00:43:19.079 --> 00:43:23.079
you know, you handed object off to a Go routine
and now it owns the object and it does stuff

00:43:23.079 --> 00:43:26.050
and then it hands it back when it's done and
there's no actual...

00:43:26.050 --> 00:43:29.930
&gt;&gt; So there's nothing, there's no memory shared
between independently executing Go routine.

00:43:29.930 --> 00:43:33.710
&gt;&gt; COX: There can be memory shared, but the
convention is that, you know, you pass an

00:43:33.710 --> 00:43:37.430
object to a Go routine and it owns the object
now. When it hands it backs then you can start

00:43:37.430 --> 00:43:40.770
reading and writing again, but until then...
&gt;&gt; I have a metaphor that I used to explain

00:43:40.770 --> 00:43:42.789
this to people.
&gt;&gt; PIKE: Imagine you have a bunch of work

00:43:42.789 --> 00:43:47.160
to do and if you're thinking about memory
barriers and concurrency, what you should

00:43:47.160 --> 00:43:51.039
do is get a piece of paper and you write notes
on the paper and everybody read this paper

00:43:51.039 --> 00:43:55.170
and you markup dynamically what people look
at. Everyone grab things when they come back

00:43:55.170 --> 00:43:58.309
and they edit this piece of paper and it's
very easy to imagine getting confused by what's

00:43:58.309 --> 00:44:01.890
written on the paper. The way you do it in
Go is you have a pad of paper and you write

00:44:01.890 --> 00:44:04.539
down one task and you give that piece of paper
to somebody else and he can walk around the

00:44:04.539 --> 00:44:08.010
room and give it to other people the other
part of it, and we're they're done they bring

00:44:08.010 --> 00:44:11.442
it back to you. And there's never any confusion
because you're never looking at--more than

00:44:11.442 --> 00:44:17.770
thing at a time. It's a very source silly,
childish way to describe it but it has a profound

00:44:17.770 --> 00:44:22.480
effect on how you think about writing a software.
&gt;&gt; COX: So next question is, is there Go Compiler

00:44:22.480 --> 00:44:26.289
for native client in the works? And there
is a Go Compiler for native client, it is

00:44:26.289 --> 00:44:32.480
done, and you can use it to create native
client binaries. We haven't played too much

00:44:32.480 --> 00:44:37.039
with hooking it up to the web browser and
doing interesting things with it but all the

00:44:37.039 --> 00:44:43.109
compiler work is there and ready for playing.
&gt;&gt; It might have been because it was short

00:44:43.109 --> 00:44:48.420
but Unix Programming Environment is the only
programming book that I ever read all the

00:44:48.420 --> 00:44:54.880
way through, and a lot of the reason for that
is because assembling different Unix show

00:44:54.880 --> 00:45:01.180
commands and stringing them together is conversational
in nature, that's important to me. I'm also

00:45:01.180 --> 00:45:07.049
very event driven in my thinking. And this
language shows me a lot of--both of those,

00:45:07.049 --> 00:45:13.130
so we're you specifically going for that feel
like a--did you have a cognitive model of

00:45:13.130 --> 00:45:18.440
programming in mind that made this just like
field really right to you?

00:45:18.440 --> 00:45:24.089
&gt;&gt; PIKE: Not explicitly but I don't think
it's an accident, you know. I have worked

00:45:24.089 --> 00:45:29.309
in concurrent for quite a while and a lot
of it is inspired by the gluing things together,

00:45:29.309 --> 00:45:35.369
model from Unix long ago. And some people
make an analogy between a Unix pipeline and

00:45:35.369 --> 00:45:40.279
both channels sending messages but also interfaces
chaining things together like in the file

00:45:40.279 --> 00:45:44.201
for example. But it's not an explicit goal.
I want to take the Unix ID and make it work.

00:45:44.201 --> 00:45:49.599
It's a programming language. It's just--it's
a good model and it has multiple domains where

00:45:49.599 --> 00:45:52.940
it makes sense.
&gt;&gt; So speaking of that model, the--working

00:45:52.940 --> 00:45:58.119
with programs that seems to be complete when
they were written but you can string them

00:45:58.119 --> 00:46:03.500
together. Do you have a model for sort of
external visibility of the guts of someone

00:46:03.500 --> 00:46:07.650
else's program so that you can inherit from
another complete app?

00:46:07.650 --> 00:46:14.260
&gt;&gt; PIKE: I'm not sure I know what you're asking.
&gt;&gt; Let me--like Tcl seemed when it was starting

00:46:14.260 --> 00:46:18.980
out to be a really good glue language that
you could take stuff and, you know, embed

00:46:18.980 --> 00:46:26.700
it, that's what SWIG is for. You have libraries
and then you have seemingly complex atomic

00:46:26.700 --> 00:46:31.250
things that are good in themselves and then
you string them together in a language that's

00:46:31.250 --> 00:46:40.019
more fluid. So do you have an idea for how
Go would handle the management between seemingly

00:46:40.019 --> 00:46:42.839
independent apps?
&gt;&gt; COX: We're not really targeting...

00:46:42.839 --> 00:46:45.460
&gt;&gt; Okay.
&gt;&gt; COX: ...that kind of glue. We're really

00:46:45.460 --> 00:46:48.190
targeting, you know, Go--whole Go programs.
&gt;&gt; Okay.

00:46:48.190 --> 00:46:52.040
&gt;&gt; COX: And we can interact with other languages
through RPC or through something like SWIG

00:46:52.040 --> 00:46:56.650
for just calling a library, but in general,
you know, the shell works really will for

00:46:56.650 --> 00:47:00.819
that because all the pieces are speaking the
same interface that read from standard input

00:47:00.819 --> 00:47:06.380
and they write to standard output. And, you
know, in Go, you just--you have interfaces

00:47:06.380 --> 00:47:10.170
like that. You have reader and rider but it's
all in the Go world and there's not really

00:47:10.170 --> 00:47:14.519
an emphasis on interacting with the rest of
the world except through things like RPC and

00:47:14.519 --> 00:47:16.039
that sort of standard mechanism, so standard
input, standard output, things like that.

00:47:16.039 --> 00:47:22.380
&gt;&gt; PIKE: And RPC works in his world. RPCs
can satisfy interfaces and, you know, channels

00:47:22.380 --> 00:47:27.019
can be passed over networks and I think there's
higher level of things that go on, but I don't

00:47:27.019 --> 00:47:33.640
think it's exactly what you're getting at.
&gt;&gt; I'm just wondering, is there some model

00:47:33.640 --> 00:47:37.190
for like, for sharing code like, I mean, Ruby
has, like, you know, gems and it's easy to,

00:47:37.190 --> 00:47:42.199
like, I think when something, someone is done
or like Java jars and...

00:47:42.199 --> 00:47:46.720
&gt;&gt; COX: Sure. There's a program in the distribution
called Go Install and you can think of it

00:47:46.720 --> 00:47:50.769
as sort of a distributed CPAN, basically,
if you put your code on GitHub or Google code

00:47:50.769 --> 00:47:55.390
or one of these code hosting sites. Then you
can say "goinstall" and give it a path of

00:47:55.390 --> 00:47:57.369
the right form and it will install that package
and then you just import it.

00:47:57.369 --> 00:47:58.519
&gt;&gt; So does it, like, does it have to be in
the source code format or I mean...

00:47:58.519 --> 00:47:59.659
&gt;&gt; COX: Yes.
&gt;&gt; Yeah?

00:47:59.659 --> 00:48:02.699
&gt;&gt; COX: Yup.
&gt;&gt; So you can't do a binary.

00:48:02.699 --> 00:48:08.720
&gt;&gt; COX: At the moment no. I mean you're compiling
for many different architectures, right? So

00:48:08.720 --> 00:48:13.599
the binary would limit you to just the person
who, you know, has the same machine that you

00:48:13.599 --> 00:48:14.599
do.
&gt;&gt; Thanks.

00:48:14.599 --> 00:48:19.810
&gt;&gt; Well, I was looking at the slide there,
I didn't quite see--if you have a bunch of

00:48:19.810 --> 00:48:24.940
libraries together, how do you make sure the
name spacing doesn't clash? Is there some

00:48:24.940 --> 00:48:27.029
sort of name space or scope...?
&gt;&gt; COX: There's no uniqueness in the name

00:48:27.029 --> 00:48:31.319
space, so if it does clash all you have to
do is rename one of them during the import

00:48:31.319 --> 00:48:35.569
for your particular file and then, you know,
it'll--you can use the different names to

00:48:35.569 --> 00:48:39.400
refer within that file. And the linker and
the compiler and all these tools can handle

00:48:39.400 --> 00:48:43.520
the fact that there might be multiple files,
let's say, I mean pack and hash as long as

00:48:43.520 --> 00:48:46.349
they have different import paths, they're
different, they're different packages. So,

00:48:46.349 --> 00:48:48.430
it all just works.
&gt;&gt; Okay. Excellent.

00:48:48.430 --> 00:48:52.989
&gt;&gt; PIKE: There's no such thing as a truly
global name in Go.

00:48:52.989 --> 00:48:56.480
&gt;&gt; Okay.
&gt;&gt; PIKE: Every name is relative to a package

00:48:56.480 --> 00:49:00.790
and even if packages have the same name, they
are distinct and entities in the world and

00:49:00.790 --> 00:49:06.560
you can resolve it.
&gt;&gt; All right. And my other question was, I

00:49:06.560 --> 00:49:11.369
saw that you had something like defer I/O.close,
what exactly was that?

00:49:11.369 --> 00:49:15.180
&gt;&gt; COX: Defer is a concept in the language
that says, "Right before you return run this

00:49:15.180 --> 00:49:20.849
function call." And so when I said "deferf.close"
what it meant is that no matter how you return

00:49:20.849 --> 00:49:25.660
from this function call "f.close" as you go.
&gt;&gt; PIKE: And that's a dynamic call, it's not

00:49:25.660 --> 00:49:30.789
scope. So, you could call "deferf.close" for
five different values of "F" and it would

00:49:30.789 --> 00:49:35.150
close all five "Fs". So if you have loop opening
file then you said defer call that close in

00:49:35.150 --> 00:49:43.679
that loop, it will close all of it. So, it's
not a scope thing, it's a dynamic thing.

00:49:43.679 --> 00:49:48.589
&gt;&gt; So I suppose this language is not statically
typed, that's right, isn't it?

00:49:48.589 --> 00:49:54.059
&gt;&gt; PIKE: No, it's statically typed but it
has some dynamic typing depending on how you're

00:49:54.059 --> 00:49:57.240
using interfaces. Sometimes narrowing has
to be done dynamically.

00:49:57.240 --> 00:50:02.900
&gt;&gt; Okay. But comparing it to Java a lot of
checking can be done in Java in compile time.

00:50:02.900 --> 00:50:06.920
&gt;&gt; COX: Go is very statically typed. All of
the programs that we're looking at were using

00:50:06.920 --> 00:50:10.450
interfaces; and interfaces, even interfaces
are statically typed. So where there was a

00:50:10.450 --> 00:50:14.380
parameter of typed value there can only be
an object that has the right value methods.

00:50:14.380 --> 00:50:19.170
But you could also have a parameter of type
end, bull or float just like in Java and so...

00:50:19.170 --> 00:50:24.460
&gt;&gt; But the point is that you can't check everything.
You could check in Java at compile time, isn't

00:50:24.460 --> 00:50:29.150
that right? Because if you pass in an object
which might be of the right...

00:50:29.150 --> 00:50:33.049
&gt;&gt; COX: I believe that you can check--everything
you can check in Java and Go in compile time.

00:50:33.049 --> 00:50:35.910
&gt;&gt; In compile time?
&gt;&gt; COX: It's very static, and the compiler--if

00:50:35.910 --> 00:50:40.349
you're not being careful with the types, if
there's something the compiler cannot prove

00:50:40.349 --> 00:50:44.450
but it needs to know, it requires you to be
very explicit and say, "I'm promising here

00:50:44.450 --> 00:50:48.859
and I understand this could be a runtime check
and runtime false." And so it's very much

00:50:48.859 --> 00:50:53.609
statically typed and you can use interfaces
to make it feel much more dynamic but in the

00:50:53.609 --> 00:50:57.660
compiler it's al static.
&gt;&gt; Okay. Thanks.

00:50:57.660 --> 00:51:04.030
&gt;&gt; So I've been using Go for he past couple
of months, and it seems like a lot of the

00:51:04.030 --> 00:51:12.119
work is, like, making it more stable in fixing
bugs. Are there any new features of the language,

00:51:12.119 --> 00:51:15.539
you guys, are planning to add? Like, I personally
like to see more of dynamic features like

00:51:15.539 --> 00:51:19.960
being able to, like, manipulate types more.
Is there anything you guys are planning to...?

00:51:19.960 --> 00:51:28.680
&gt;&gt; PIKE: I think roadmap has some things but
not in a general direction. I think there's

00:51:28.680 --> 00:51:33.829
probably coming a time when dynamic code loading
would be available, but there's no plan for

00:51:33.829 --> 00:51:39.450
that. We haven't talk about it. I just sort
of given a way the packages or work in a structure

00:51:39.450 --> 00:51:43.369
of things. I think that's got to develop on
its own. At the moment we're more concern

00:51:43.369 --> 00:51:46.529
with developing libraries to the point that
people can use this for production in more

00:51:46.529 --> 00:51:53.490
ways. But, you know, rose up in the proposals,
so if you got things you want to talk about,

00:51:53.490 --> 00:51:57.330
you know, let us know and we'll consider it.
&gt;&gt; COX: I also think that language changes

00:51:57.330 --> 00:52:01.319
just take longer. They take a long time to
just simmer and really come up with a good

00:52:01.319 --> 00:52:05.039
design and it takes a while to roll out. And
so you're going to see fewer of them than

00:52:05.039 --> 00:52:08.579
you see, you know, new libraries. And so in
particular the reason it changes to panic

00:52:08.579 --> 00:52:12.920
in the introduction of a cover were things
that we spend a very long time thinking about

00:52:12.920 --> 00:52:16.991
on the back burner before we finally came
over the design that we liked and then it

00:52:16.991 --> 00:52:19.500
was relative and quick to roll out and so
it's mostly design.

00:52:19.500 --> 00:52:22.510
&gt;&gt; PIKE: Two years of thinking before it went
in, so.

00:52:22.510 --> 00:52:26.099
&gt;&gt; COX: And as far as what you were talking
about for types in particular, I think that

00:52:26.099 --> 00:52:31.359
the reflect package is probably in need of
redo. And I think that when we do that you

00:52:31.359 --> 00:52:36.289
might see some more dynamic key things like
you should be able to just construct the type

00:52:36.289 --> 00:52:41.700
at runtime I think. But all of that is still
very much just simmering in the back and eventually

00:52:41.700 --> 00:52:43.940
it will, you know, bubble over and will have
some thing.

00:52:43.940 --> 00:52:52.309
&gt;&gt; PIKE: One thing we didn't mention because
as I've said this is a tutorial is there is

00:52:52.309 --> 00:52:55.240
full runtime reflection for those who don't
know that, which makes for some really interesting

00:52:55.240 --> 00:52:56.829
possibilities. Any questions? How are we on
time? I can't see the clock back there.

00:52:56.829 --> 00:52:57.829
&gt;&gt; COX: It says eight minutes.
&gt;&gt; PIKE: Eight minutes. Okay.

00:52:57.829 --> 00:53:01.300
&gt;&gt; You mentioned about RPC...
&gt;&gt; PIKE: Can you take--can you come to the

00:53:01.300 --> 00:53:10.539
mic if you're going to ask us a question?
&gt;&gt; So graphics processors are really powerful,

00:53:10.539 --> 00:53:13.680
is there plans or something...
&gt;&gt; COX: Can you speak up? I'm sorry.

00:53:13.680 --> 00:53:19.910
&gt;&gt; Is there plans for something like open
CL, you know, to run stuff on the graphics

00:53:19.910 --> 00:53:23.290
processors?
&gt;&gt; COX: Graphics processors. There are no

00:53:23.290 --> 00:53:33.970
plans but hopes and dreams sure.
&gt;&gt; All right. You mentioned RPC for inter-program

00:53:33.970 --> 00:53:41.259
language stuff. Google uses protobuffs and
you have internal RPCs, what about for other

00:53:41.259 --> 00:53:46.670
RPC systems, they're like co-generation for
thrift which does provide RPC right now or

00:53:46.670 --> 00:53:50.299
is that something you could provide?
&gt;&gt; COX: We don't, but I think that changes

00:53:50.299 --> 00:53:54.780
to RPC that we talked about here would--that
made it possible to plug-in JSON RPC as the

00:53:54.780 --> 00:53:58.609
wiring coding. I think you can plug-in protocol
buffer wiring coding. I think you could plug-in

00:53:58.609 --> 00:54:03.099
thrift wiring coding and just use the standard
Go RPC server and you could speak all of those

00:54:03.099 --> 00:54:04.099
protocols at once if you wanted to.
&gt;&gt; All right.

00:54:04.099 --> 00:54:06.030
&gt;&gt; COX: Yeah.
&gt;&gt; Thank you.

00:54:06.030 --> 00:54:12.199
&gt;&gt; PIKE: It's really straightforward to swap
the encoding app.

00:54:12.199 --> 00:54:15.880
&gt;&gt; What's the policy on what goes into the
standard binary package versus external? I've

00:54:15.880 --> 00:54:19.049
seen a whole bunch of stuff that's in the
standard Go and I've seen languages like Perl

00:54:19.049 --> 00:54:23.069
and Python that have grown a really large
standard library, then I had to got it or

00:54:23.069 --> 00:54:26.210
clean it up later.
&gt;&gt; PIKE: We're very, very sensitive with that

00:54:26.210 --> 00:54:31.020
issue because we think that some other languages,
I won't name them, but I think some other

00:54:31.020 --> 00:54:35.589
languages have not been careful enough about
how the library goes. So, we've been trying

00:54:35.589 --> 00:54:39.970
to make sure that the basic libraries that
are installed with the compiler and stuff

00:54:39.970 --> 00:54:45.180
when you get it form a really good corset
that large subset of which will be use in

00:54:45.180 --> 00:54:50.950
most programs. And things that are much more
special purpose or larger in scope, we tend

00:54:50.950 --> 00:54:55.430
to encourage people to make separate repositories
for but then in turn we have a program "Go

00:54:55.430 --> 00:54:59.059
Install" which makes it very easy to import
them if you want. We want to make sure that

00:54:59.059 --> 00:55:04.489
the standard packages were useful, modest
and scoped but--and very, very well written.

00:55:04.489 --> 00:55:09.549
&gt;&gt; COX: I even put in something in the standard
library as a promise that, you know, something

00:55:09.549 --> 00:55:13.779
like this is going to stay there and so I
think we have to be careful just to think

00:55:13.779 --> 00:55:17.780
about, you know, is that general enough that...
&gt;&gt; But you just mentioned redoing the reflect

00:55:17.780 --> 00:55:18.969
package for instance.
&gt;&gt; COX: I'm sorry.

00:55:18.969 --> 00:55:22.249
&gt;&gt; You mentioned redoing the reflect package.
&gt;&gt; COX: Right. But I think it's a promise

00:55:22.249 --> 00:55:26.009
about the functionality more than the details
of the interface. So, for example, you know,

00:55:26.009 --> 00:55:29.789
someone wrote fuse package recently, and I
think fuses are good example, something that

00:55:29.789 --> 00:55:33.130
makes sense as a separate package and you
can "Go Install" it and so it's no harder

00:55:33.130 --> 00:55:37.380
to use than the regular packages. But it,
you know, it doesn't really makes sense in

00:55:37.380 --> 00:55:41.720
those standard tree. I think once Go is a
little bit more mature, we might see people

00:55:41.720 --> 00:55:46.269
who build Go distributions that have a whole
bunch of other packages pulled in, you know,

00:55:46.269 --> 00:55:49.730
just as part of the tree as though they'd
already been "Go Install."

00:55:49.730 --> 00:55:52.260
&gt;&gt; PIKE: Right.
&gt;&gt; COX: But I think the standard stuff is

00:55:52.260 --> 00:55:55.400
really supposed to be the kind of things you'd
expect in a standard library.

00:55:55.400 --> 00:55:59.249
&gt;&gt; PIKE: And "Go Install" works transitive
so it makes [INDISTINCT]. So we've only got

00:55:59.249 --> 00:56:02.540
few seconds left, so are there--I think there's
no more questions. Thanks everyone for coming

00:56:02.540 --> 00:56:03.219
and grab your flag on the way out.

