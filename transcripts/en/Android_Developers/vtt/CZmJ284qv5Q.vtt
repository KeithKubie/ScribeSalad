WEBVTT
Kind: captions
Language: en

00:00:00.499 --> 00:00:05.590
[MUSIC PLAYING]

00:00:05.590 --> 00:00:07.970
ALEX SOUROV: Well, so
good afternoon, everyone.

00:00:07.970 --> 00:00:10.339
So we are Facebook.

00:00:10.339 --> 00:00:12.880
We are-- the two of us are from
the Android immersion markets

00:00:12.880 --> 00:00:14.310
team in Facebook.

00:00:14.310 --> 00:00:17.620
I'm Alex Sourov, the manager
of the emerging market team,

00:00:17.620 --> 00:00:18.574
and here is--

00:00:18.574 --> 00:00:20.240
ALEX PETRESCU: My
name is Alex Petrescu,

00:00:20.240 --> 00:00:23.140
and I'm a software engineer
on the emerging markets team,

00:00:23.140 --> 00:00:24.614
and I focus on the news feed.

00:00:24.614 --> 00:00:26.030
ALEX SOUROV: And
today we're going

00:00:26.030 --> 00:00:29.630
to talk about what we do
to make Android apps work

00:00:29.630 --> 00:00:33.430
better on less powerful devices
and less powerful networks.

00:00:33.430 --> 00:00:35.740
So first of all why we care
about emerging markets.

00:00:38.810 --> 00:00:41.780
So we have almost
150 million users

00:00:41.780 --> 00:00:44.627
using the app on a daily basis,
and these users are everywhere,

00:00:44.627 --> 00:00:46.960
and we want to connect users
who are all over the world.

00:00:46.960 --> 00:00:50.490
As a matter of fact, Android,
our Android users in particular

00:00:50.490 --> 00:00:52.531
are located all over the world.

00:00:52.531 --> 00:00:54.030
9 out of 10 of our
users are located

00:00:54.030 --> 00:00:57.190
outside the United States.

00:00:57.190 --> 00:01:00.250
And most of the new
users who come online

00:01:00.250 --> 00:01:03.840
are also coming online in places
which are emerging markets.

00:01:03.840 --> 00:01:05.840
We have a lot of people
who, for the first time,

00:01:05.840 --> 00:01:07.722
actually getting
internet connections,

00:01:07.722 --> 00:01:09.930
and of course, Facebook want
to connect to everybody,

00:01:09.930 --> 00:01:12.190
and there is an ongoing
effort to do that.

00:01:12.190 --> 00:01:14.350
Our job is to make
sure these users work

00:01:14.350 --> 00:01:18.200
very well with Facebook for
Android app where they are.

00:01:18.200 --> 00:01:22.020
And where they are typically,
with no offense for iOS users,

00:01:22.020 --> 00:01:25.090
are Android devices, usually
cheap Android devices,

00:01:25.090 --> 00:01:29.140
and network which are
not very powerful.

00:01:29.140 --> 00:01:31.340
So we're going to talk
about devices first.

00:01:31.340 --> 00:01:35.140
Does anybody here care to guess
how many different Android

00:01:35.140 --> 00:01:38.290
devices are out
there in the market?

00:01:38.290 --> 00:01:40.730
A number?

00:01:40.730 --> 00:01:42.510
500, 1,000?

00:01:42.510 --> 00:01:43.330
AUDIENCE: 10,000.

00:01:43.330 --> 00:01:44.600
ALEX SOUROV: 10,000?

00:01:44.600 --> 00:01:46.040
The right answer is 10,000.

00:01:46.040 --> 00:01:46.890
You got that.

00:01:46.890 --> 00:01:48.380
So there are about
10,000 devices,

00:01:48.380 --> 00:01:50.340
and actually, the
number keeps increasing.

00:01:50.340 --> 00:01:54.090
So that is about-- six months
ago it was about 10,000.

00:01:54.090 --> 00:01:56.150
I'm not even sure
what is right now.

00:01:56.150 --> 00:01:59.240
And of course, the challenge
is how do we actually test

00:01:59.240 --> 00:02:01.020
and how do we reason
about 10,000 devices?

00:02:01.020 --> 00:02:02.310
They're all very different.

00:02:02.310 --> 00:02:03.860
Well, the way we
reason about them

00:02:03.860 --> 00:02:05.651
is that it would come
up with this approach

00:02:05.651 --> 00:02:07.010
called device year class.

00:02:07.010 --> 00:02:08.509
So what's device year class?

00:02:08.509 --> 00:02:11.930
Quite simply, it's-- no matter
when the device was produced,

00:02:11.930 --> 00:02:14.075
it's the year at which
this device with those

00:02:14.075 --> 00:02:16.200
characteristics would have
been the flagship device

00:02:16.200 --> 00:02:17.140
on the market.

00:02:17.140 --> 00:02:18.330
So here's how it works.

00:02:18.330 --> 00:02:21.850
Moto E here is the recent
device, pretty popular device

00:02:21.850 --> 00:02:24.370
from Motorola, of
course, came out in 2014,

00:02:24.370 --> 00:02:25.750
but it has those
characteristics.

00:02:25.750 --> 00:02:28.820
It has two CPU cores, 1.2
gigahertz clock speed,

00:02:28.820 --> 00:02:30.860
and one gigabyte of RAM.

00:02:30.860 --> 00:02:32.650
And let's compared
with Galaxy S2,

00:02:32.650 --> 00:02:36.191
which is a very popular
device from 2011.

00:02:36.191 --> 00:02:38.440
Has very similar characteristics
as far as these three

00:02:38.440 --> 00:02:39.490
characteristics go.

00:02:39.490 --> 00:02:42.490
And in 2011 that was
the flagship device.

00:02:42.490 --> 00:02:45.790
So as a result, we're going to
say, hey, both of those devices

00:02:45.790 --> 00:02:48.046
are year class 2011 devices.

00:02:48.046 --> 00:02:50.170
And again, there are many
different characteristics

00:02:50.170 --> 00:02:51.362
we could have looked at.

00:02:51.362 --> 00:02:53.070
We looked at-- and we
looked at all them,

00:02:53.070 --> 00:02:55.300
and we thought that these
three characteristics are

00:02:55.300 --> 00:02:57.830
the ones that makes the
most difference in terms

00:02:57.830 --> 00:02:59.940
of the performance of
the app and how users are

00:02:59.940 --> 00:03:02.270
able to interface with the app.

00:03:02.270 --> 00:03:04.470
So these are the
actual settings that

00:03:04.470 --> 00:03:07.070
set up-- that we look at
for these three parameters.

00:03:07.070 --> 00:03:09.710
And here's how we determine
whether a device is

00:03:09.710 --> 00:03:11.540
in one year class or another.

00:03:11.540 --> 00:03:14.360
On some devices you are not
going to get the exact match.

00:03:14.360 --> 00:03:15.610
We go for two out of three.

00:03:15.610 --> 00:03:18.075
If two out of free actually
match the year class,

00:03:18.075 --> 00:03:22.250
we call these devices
from that year class.

00:03:22.250 --> 00:03:25.142
And there's been a really
useful metric for us.

00:03:25.142 --> 00:03:27.100
It's been useful for us
because all of a sudden

00:03:27.100 --> 00:03:30.560
we can classify this whole
world of 10,000 devices

00:03:30.560 --> 00:03:34.910
into smaller groups, and we can
reason about them more easily.

00:03:34.910 --> 00:03:36.990
So once we actually
got this data,

00:03:36.990 --> 00:03:38.810
we started seeing some
interesting trends,

00:03:38.810 --> 00:03:41.130
and I'll let Alex
talk about that.

00:03:41.130 --> 00:03:43.780
ALEX PETRESCU: So we developed
the concept of year class

00:03:43.780 --> 00:03:44.610
a couple years ago.

00:03:44.610 --> 00:03:47.440
It's mostly just
a simple library

00:03:47.440 --> 00:03:50.470
that we've even open
sourced for other developers

00:03:50.470 --> 00:03:53.500
to be able to introduce
this into their apps.

00:03:53.500 --> 00:03:55.290
And once we looked
at the data, we

00:03:55.290 --> 00:03:58.460
gathered a few months
of data, somewhere

00:03:58.460 --> 00:04:02.500
around last year we saw that
about a third of all devices

00:04:02.500 --> 00:04:04.700
will be considered 2010 devices.

00:04:04.700 --> 00:04:07.000
These are mostly
Gingerbread devices.

00:04:07.000 --> 00:04:12.410
You have one core, less
than a gigahertz clock,

00:04:12.410 --> 00:04:15.560
and then usually also
other slow characteristics

00:04:15.560 --> 00:04:20.430
like small cache size
and things like that.

00:04:20.430 --> 00:04:25.780
Another third are 2011 devices,
and these are better devices.

00:04:25.780 --> 00:04:27.605
They have two cores
but still not a lot

00:04:27.605 --> 00:04:30.420
of clock speed,
not a lot of RAM,

00:04:30.420 --> 00:04:34.110
but it seemed that was
the majority of users.

00:04:34.110 --> 00:04:38.100
So we call 2010 and 2011
typical Android devices

00:04:38.100 --> 00:04:40.020
because they were the
majority of the market.

00:04:40.020 --> 00:04:42.300
And then the ones that we
have in our pockets, those

00:04:42.300 --> 00:04:46.225
are the modern phones, the
high-end phones, the 2012.

00:04:46.225 --> 00:04:48.380
You have more than
a couple cores,

00:04:48.380 --> 00:04:50.850
more than a gig of
RAM, things like that.

00:04:50.850 --> 00:04:57.080
Now, good news is that
this year 2010 has shrunk.

00:04:57.080 --> 00:04:59.240
So there's a lot less
Gingerbread devices.

00:04:59.240 --> 00:05:01.870
There's a lot less
single core devices.

00:05:01.870 --> 00:05:05.400
However, the 2011 class is
now the most popular one

00:05:05.400 --> 00:05:06.890
and continues to grow.

00:05:06.890 --> 00:05:09.780
Most of the devices sold in
emerging markets, where they're

00:05:09.780 --> 00:05:13.160
selling millions and
millions, they're

00:05:13.160 --> 00:05:16.390
mostly on the 2011
side, so still only

00:05:16.390 --> 00:05:20.412
two cores, which is a challenge.

00:05:20.412 --> 00:05:22.370
It's a little bit better
for the United States.

00:05:22.370 --> 00:05:26.950
Very few or fewer Gingerbread
users and single core devices,

00:05:26.950 --> 00:05:30.492
but still, more than a third
of users are on 2011 devices.

00:05:30.492 --> 00:05:32.700
So if you're building an
app, you still need to care,

00:05:32.700 --> 00:05:35.110
and you care about any
sort of adoption outside

00:05:35.110 --> 00:05:37.920
of major markets,
you should care

00:05:37.920 --> 00:05:39.715
about these type of devices.

00:05:42.550 --> 00:05:47.020
So as engineers,
instead of-- oh, shoot.

00:05:47.020 --> 00:05:50.170
Sorry, I'm bad at this.

00:05:50.170 --> 00:05:51.446
One second.

00:05:51.446 --> 00:05:54.590
How do I go back?

00:05:54.590 --> 00:05:56.870
OK, bam, got it.

00:05:56.870 --> 00:05:58.590
All right, so as
engineers, instead

00:05:58.590 --> 00:06:01.240
of worrying about 10,000
different devices,

00:06:01.240 --> 00:06:03.260
now you really only need
to worry about eight.

00:06:03.260 --> 00:06:05.892
And honestly, you only need
to worry about two or three.

00:06:05.892 --> 00:06:07.740
You need to have a 2011 device.

00:06:07.740 --> 00:06:10.760
You need to have a 2010
device like a pocket Neo,

00:06:10.760 --> 00:06:12.840
and then you need to
have the device that's

00:06:12.840 --> 00:06:15.480
in your pocket, which is
usually four cores or more

00:06:15.480 --> 00:06:17.132
and a decent speed.

00:06:21.054 --> 00:06:22.470
ALEX SOUROV: So
now that we talked

00:06:22.470 --> 00:06:25.310
about the diversity of
devices, the next place

00:06:25.310 --> 00:06:27.650
where there's a lot of
diversity in terms of usage

00:06:27.650 --> 00:06:29.220
is diversity of
network conditions.

00:06:29.220 --> 00:06:30.890
In some ways it's
even more complicated

00:06:30.890 --> 00:06:32.860
than diversity of devices.

00:06:32.860 --> 00:06:34.680
This is kind of the
basic graph here

00:06:34.680 --> 00:06:37.180
that shows you a very
basic breakdown on network

00:06:37.180 --> 00:06:41.881
conditions, and this is just by
Wi-Fi and cellular worldwide.

00:06:41.881 --> 00:06:43.380
Most of the
connections-- of course,

00:06:43.380 --> 00:06:47.150
this is from Facebook data and
sessions that Facebook have.

00:06:47.150 --> 00:06:49.000
Most of the connections
out there on Wi-Fi.

00:06:49.000 --> 00:06:51.333
I know there are quite a few
cellular, and then about 2%

00:06:51.333 --> 00:06:53.780
worldwide actually
connect where there

00:06:53.780 --> 00:06:54.947
is no connection whatsoever.

00:06:54.947 --> 00:06:57.030
I mean, there might be
different reasons for that.

00:06:57.030 --> 00:06:59.770
Users might have turned off the
mobile data or they in an area

00:06:59.770 --> 00:07:01.520
where there is no mobile data.

00:07:01.520 --> 00:07:03.600
Or they in the area
which is very congested,

00:07:03.600 --> 00:07:05.330
and they can't get to the tower.

00:07:05.330 --> 00:07:08.620
All of these are reasons for not
having any connections at all.

00:07:08.620 --> 00:07:11.460
So that's simple enough,
but when you break it down

00:07:11.460 --> 00:07:14.090
by countries, you'll
see that there's

00:07:14.090 --> 00:07:16.550
a wide variety of
different conditions.

00:07:16.550 --> 00:07:19.180
Even if you look just at
those three, Wi-Fi, cellular,

00:07:19.180 --> 00:07:24.640
and no connection whatsoever,
these profiles vary a lot.

00:07:24.640 --> 00:07:27.170
But it actually is even
more complicated than that.

00:07:27.170 --> 00:07:29.990
I think probably everybody
notices that Wi-Fi, one Wi-Fi

00:07:29.990 --> 00:07:32.944
is not like another Wi-Fi,
and one cellular connection

00:07:32.944 --> 00:07:34.610
is not like another
cellular connection.

00:07:34.610 --> 00:07:37.370
And so we took the page out
of device year class work,

00:07:37.370 --> 00:07:39.820
and we thought, hey could we
actually do something similar

00:07:39.820 --> 00:07:41.200
for network connections?

00:07:41.200 --> 00:07:43.590
Could we actually
break it down into easy

00:07:43.590 --> 00:07:46.370
to understand classifications
that we can then

00:07:46.370 --> 00:07:48.900
use to reason about
them and to make

00:07:48.900 --> 00:07:51.720
improvements for different
network connections?

00:07:51.720 --> 00:07:54.504
And the idea we came up with
is network connection class.

00:07:54.504 --> 00:07:56.920
And again, this is something
we open source and others can

00:07:56.920 --> 00:07:58.270
use as well.

00:07:58.270 --> 00:08:00.420
But in general, this is
fairly straightforward.

00:08:00.420 --> 00:08:02.630
We are doing a passive
measurements of the bandwidth.

00:08:02.630 --> 00:08:06.410
Like, as the app sends the
packets and receives them,

00:08:06.410 --> 00:08:08.910
we keep track of how long it
takes and we measure bandwidth.

00:08:08.910 --> 00:08:11.110
We throw out small packets
because the overhead

00:08:11.110 --> 00:08:13.310
is actually starts [INAUDIBLE].

00:08:13.310 --> 00:08:14.810
And we only look
for something which

00:08:14.810 --> 00:08:16.894
is more than a certain size.

00:08:16.894 --> 00:08:18.310
And then we get
these data points.

00:08:18.310 --> 00:08:20.143
We get these data points
all over the place.

00:08:20.143 --> 00:08:24.720
The mobile connections are
notoriously unreliable,

00:08:24.720 --> 00:08:27.279
and at any given time you could
have a real good connection

00:08:27.279 --> 00:08:29.320
and a really bed connection,
especially if you're

00:08:29.320 --> 00:08:30.831
moving around, so we average.

00:08:30.831 --> 00:08:32.789
So we looked at different
methods of averaging,

00:08:32.789 --> 00:08:34.919
and we landed with a
geometric averaging.

00:08:34.919 --> 00:08:38.350
So essentially, we break the
space of all the bandwidth

00:08:38.350 --> 00:08:39.570
into two categories.

00:08:39.570 --> 00:08:41.590
They're all about
4x from each other.

00:08:41.590 --> 00:08:43.750
Moderate and poor connections
are the lowest ones

00:08:43.750 --> 00:08:44.916
and then good and excellent.

00:08:49.200 --> 00:08:51.410
And then we label them.

00:08:51.410 --> 00:08:53.892
Again, to label them and
understand those boundaries we

00:08:53.892 --> 00:08:54.850
look at the data again.

00:08:54.850 --> 00:08:57.474
We wanted to find the boundaries
which are actually meaningful.

00:08:57.474 --> 00:09:00.570
So as the user moves from one
connection class to another,

00:09:00.570 --> 00:09:03.409
it results in a meaningful
change to performance

00:09:03.409 --> 00:09:05.450
or meaningful change in
how the user can actually

00:09:05.450 --> 00:09:06.550
interact with the app.

00:09:06.550 --> 00:09:09.500
So this is the one we came
up with for the open source

00:09:09.500 --> 00:09:10.000
library.

00:09:10.000 --> 00:09:12.476
We just label them as poor,
moderate, good, and excellent

00:09:12.476 --> 00:09:14.100
because in the future
we might actually

00:09:14.100 --> 00:09:15.630
change what the boundaries are.

00:09:15.630 --> 00:09:17.130
But we found that
these four average

00:09:17.130 --> 00:09:20.070
is great groups for engineers
to think about and target

00:09:20.070 --> 00:09:20.870
the app towards.

00:09:24.307 --> 00:09:25.290
Alex?

00:09:25.290 --> 00:09:29.140
ALEX PETRESCU: So
like Alex mentioned,

00:09:29.140 --> 00:09:31.980
what we found is technology
does not imply speed.

00:09:31.980 --> 00:09:34.560
And this is pretty apparent
to anyone that's actually

00:09:34.560 --> 00:09:36.840
traveled and tried
to use hotel Wi-Fi

00:09:36.840 --> 00:09:39.690
or try to go into an internet
cafe or something like that.

00:09:39.690 --> 00:09:41.690
Just because you're
on Wi-Fi does not

00:09:41.690 --> 00:09:44.740
mean that you're on a
good, fast connection.

00:09:44.740 --> 00:09:47.590
So when you're thinking about
gating very expensive features

00:09:47.590 --> 00:09:52.880
like auto play videos or HD
videos or things like that,

00:09:52.880 --> 00:09:56.670
you can't just use that you're
on Wi-Fi or not on Wi-Fi

00:09:56.670 --> 00:09:59.250
because that doesn't
really tell you anything.

00:09:59.250 --> 00:10:02.080
Again, it doesn't-- if you're
on a LTE connection or 3G

00:10:02.080 --> 00:10:05.450
connection, you might
have one bar or something.

00:10:05.450 --> 00:10:08.100
You're still not getting
a good amount of speed.

00:10:08.100 --> 00:10:11.800
So for example, in India
and in the United States,

00:10:11.800 --> 00:10:14.200
the same download can
take four times longer

00:10:14.200 --> 00:10:16.570
or be four times faster
in the United States

00:10:16.570 --> 00:10:20.710
on average than in India for
the same connection type.

00:10:20.710 --> 00:10:22.550
So this is what
Android gives you.

00:10:22.550 --> 00:10:24.720
Android tells you
you're on Wi-Fi.

00:10:24.720 --> 00:10:25.490
You're on mobile.

00:10:25.490 --> 00:10:26.880
You're on edge.

00:10:26.880 --> 00:10:27.890
You're on LTE.

00:10:27.890 --> 00:10:30.160
But it doesn't really tell
you what the quality is

00:10:30.160 --> 00:10:33.780
or how fast you're
getting packets

00:10:33.780 --> 00:10:36.130
to and from your server.

00:10:36.130 --> 00:10:39.360
So as developers we need
to build one amp, usually,

00:10:39.360 --> 00:10:41.200
that has to work
on both six megs

00:10:41.200 --> 00:10:45.220
a second and essentially
56K modem speeds.

00:10:45.220 --> 00:10:49.240
So it's quite a
challenge for developers,

00:10:49.240 --> 00:10:50.630
and connection
class is something

00:10:50.630 --> 00:10:55.240
we've developed to help us
tackle these types of issues.

00:10:58.076 --> 00:11:00.700
ALEX SOUROV: And now, this is a
talk about tales and somethings

00:11:00.700 --> 00:11:03.610
that we find out which
might not be obvious,

00:11:03.610 --> 00:11:05.400
and this is one of those things.

00:11:05.400 --> 00:11:08.000
In general, if you were to
have a conditional in your app

00:11:08.000 --> 00:11:09.799
and say, hey, if I
think about Japan,

00:11:09.799 --> 00:11:11.382
do I think about bad
connections or do

00:11:11.382 --> 00:11:12.220
I think about good connections?

00:11:12.220 --> 00:11:13.330
I think just
everybody would agree

00:11:13.330 --> 00:11:14.820
that you are thinking about
good connections, really

00:11:14.820 --> 00:11:17.060
good connections for
most users in Japan.

00:11:17.060 --> 00:11:20.220
But when we put this data and
started looking at this data,

00:11:20.220 --> 00:11:21.360
we found this.

00:11:21.360 --> 00:11:24.410
So at the end of every month
about 10% percent of users

00:11:24.410 --> 00:11:26.460
in Japan switch from
excellent connections

00:11:26.460 --> 00:11:28.918
to not so great connections,
poor and moderate connections.

00:11:28.918 --> 00:11:32.080
So we started wondering
why, and the title kind of

00:11:32.080 --> 00:11:34.180
gives it away as to
why this happens,

00:11:34.180 --> 00:11:35.169
the title of the slide.

00:11:35.169 --> 00:11:37.460
But the thing that's happening
is that basically, users

00:11:37.460 --> 00:11:39.910
are either on prepaid
plans or they're basically

00:11:39.910 --> 00:11:42.520
throttled by their carrier
when they use too much data.

00:11:42.520 --> 00:11:44.440
And so again, if
you are just looking

00:11:44.440 --> 00:11:47.000
at the country or the type
of the connection, Wi-Fi

00:11:47.000 --> 00:11:48.820
or cellular, you're
probably missing out

00:11:48.820 --> 00:11:51.020
on some group of the population
which actually doesn't quite

00:11:51.020 --> 00:11:51.780
fit the profile.

00:11:54.052 --> 00:11:56.010
ALEX PETRESCU: So you
guys have seen this slide

00:11:56.010 --> 00:11:57.710
a few slides ago.

00:11:57.710 --> 00:12:00.860
And we talked about the
different breakdowns

00:12:00.860 --> 00:12:04.100
and what I'd like to point out
is now the intermittency issue,

00:12:04.100 --> 00:12:07.730
is that there's a certain time
no matter what country you're

00:12:07.730 --> 00:12:10.902
in, no matter what
network you're on,

00:12:10.902 --> 00:12:12.860
where you turn on your
app, and for some reason

00:12:12.860 --> 00:12:15.090
you don't have a
network right now.

00:12:15.090 --> 00:12:16.860
This is obviously a
much bigger problems

00:12:16.860 --> 00:12:18.460
in places like India
or Nigeria, where

00:12:18.460 --> 00:12:21.390
something like 20%
of all app startups

00:12:21.390 --> 00:12:23.590
do not have any network at all.

00:12:23.590 --> 00:12:25.230
But still, even in
the United States

00:12:25.230 --> 00:12:27.580
we've all been on the subway,
on the bus, or something

00:12:27.580 --> 00:12:31.110
like that, where there's
no connection right now.

00:12:31.110 --> 00:12:34.530
And even though you have
a network connection,

00:12:34.530 --> 00:12:36.900
or Android will tell you you
have a network connection,

00:12:36.900 --> 00:12:40.710
what we found is
packets will go out,

00:12:40.710 --> 00:12:42.420
and then they'll
just essentially just

00:12:42.420 --> 00:12:44.930
go into a black hole somewhere
and then never come back.

00:12:44.930 --> 00:12:46.160
Nothing comes back.

00:12:46.160 --> 00:12:50.662
So what we found is, like, 20%
of all network requests fail.

00:12:50.662 --> 00:12:52.620
And this is while the
app is in the foreground,

00:12:52.620 --> 00:12:54.742
so we know that the user's
trying to use the app.

00:12:54.742 --> 00:12:56.200
While the app is
in the background,

00:12:56.200 --> 00:12:58.795
it could be 50%,
60% if you're trying

00:12:58.795 --> 00:13:01.045
to make a network request
while it' in the background.

00:13:04.180 --> 00:13:05.680
ALEX SOUROV: So in
addition to that,

00:13:05.680 --> 00:13:07.513
we believe that the
improvements, especially

00:13:07.513 --> 00:13:09.720
on the networking side, are
going to take some time.

00:13:09.720 --> 00:13:12.860
So 2G is being phased out in
the U.S. Which is great news.

00:13:12.860 --> 00:13:15.520
But it's going to be
around in the emerging

00:13:15.520 --> 00:13:18.600
marketplaces for a while,
at least for a few years.

00:13:18.600 --> 00:13:20.480
But that's not even
the whole problem.

00:13:20.480 --> 00:13:22.135
The bigger problem
is the congestion

00:13:22.135 --> 00:13:24.010
because if you go to
the emerging marketplace

00:13:24.010 --> 00:13:25.930
and you try the 3G
over there, what will

00:13:25.930 --> 00:13:29.380
you often find that 3G
is not like our 3G here.

00:13:29.380 --> 00:13:31.240
And the reason is,
it's really congested

00:13:31.240 --> 00:13:33.100
and it's not reliable.

00:13:33.100 --> 00:13:37.502
And congestion comes from a lot
of people using the networks.

00:13:37.502 --> 00:13:39.335
And more and more people
are getting online.

00:13:39.335 --> 00:13:41.960
More and more people are using
internet for the first time,

00:13:41.960 --> 00:13:43.136
and that's fantastic news.

00:13:43.136 --> 00:13:44.510
Unfortunately,
the infrastructure

00:13:44.510 --> 00:13:46.190
is not catching up with that.

00:13:46.190 --> 00:13:49.220
So we expect that the congestion
issues are going to continue

00:13:49.220 --> 00:13:52.800
and that it's not going to get
any more reliable anytime soon.

00:13:52.800 --> 00:13:55.710
And here's our tale off the
connectivity in the Facebook

00:13:55.710 --> 00:13:56.834
Hyderabad office.

00:13:56.834 --> 00:13:58.250
So as an emerging
market teams, we

00:13:58.250 --> 00:14:00.880
make trip to emerging market
countries pretty regularly.

00:14:00.880 --> 00:14:02.900
And this year we
really focused on India

00:14:02.900 --> 00:14:04.700
because we wanted to
understand and solve

00:14:04.700 --> 00:14:06.540
a lot problems in that market.

00:14:06.540 --> 00:14:08.170
So we went there twice so far.

00:14:08.170 --> 00:14:10.300
We went there in January
and we went there in July.

00:14:10.300 --> 00:14:13.720
And when we went there in
January, we were disappointed.

00:14:13.720 --> 00:14:15.370
The connection was too good.

00:14:15.370 --> 00:14:17.040
You got 3G speeds.

00:14:17.040 --> 00:14:19.530
The office happens to be in
a high tech part of the town.

00:14:19.530 --> 00:14:20.960
And they got a
little cell towers

00:14:20.960 --> 00:14:22.668
over there, a lot of
high tech companies.

00:14:22.668 --> 00:14:24.429
So generally, connection
was excellent.

00:14:24.429 --> 00:14:25.720
It was like oh, that's too bad.

00:14:25.720 --> 00:14:27.220
We can't really get a
representative sample

00:14:27.220 --> 00:14:27.719
right there.

00:14:27.719 --> 00:14:29.540
So we had to fan
out of the office

00:14:29.540 --> 00:14:32.370
and go to more remote areas and
stay in the cafes and coffee

00:14:32.370 --> 00:14:34.814
shops, and just basically
see what the connectivity is.

00:14:34.814 --> 00:14:37.230
Try to analyze the pattern,
try to analyze what apps works

00:14:37.230 --> 00:14:38.830
and what don't.

00:14:38.830 --> 00:14:42.154
So when they came in
July, things reversed.

00:14:42.154 --> 00:14:44.070
All of a sudden, in the
office, the conditions

00:14:44.070 --> 00:14:44.840
were not that great.

00:14:44.840 --> 00:14:46.339
Or actually for us,
they were great.

00:14:46.339 --> 00:14:48.590
We got this juicy intermittency,
and bad latencies,

00:14:48.590 --> 00:14:49.970
and everything.

00:14:49.970 --> 00:14:53.684
And so we asked Caretel,
which is on the biggest cell

00:14:53.684 --> 00:14:55.850
providers over there what's
going on, and they said,

00:14:55.850 --> 00:14:57.350
well, is there any
more construction

00:14:57.350 --> 00:14:59.880
in the area that happened
between January and July?

00:14:59.880 --> 00:15:01.450
And sure enough, there are
two new office buildings

00:15:01.450 --> 00:15:01.950
right next door.

00:15:01.950 --> 00:15:04.150
They said, well let's probably
between 2,000 and 6,000 people

00:15:04.150 --> 00:15:04.690
there.

00:15:04.690 --> 00:15:06.010
So that's what happens.

00:15:06.010 --> 00:15:07.760
All of a sudden your
network is congested.

00:15:07.760 --> 00:15:09.650
And we're like, well,
what are you guys going

00:15:09.650 --> 00:15:10.400
to do about this?

00:15:10.400 --> 00:15:11.900
They said, well, we'll put a
new cell tower in the area,

00:15:11.900 --> 00:15:13.140
but it takes about
six to nine months

00:15:13.140 --> 00:15:14.820
to put a new cell
tower in the area.

00:15:14.820 --> 00:15:17.153
And so in the meantime, that's
what you're going to get.

00:15:17.153 --> 00:15:19.030
And so that was actually
pretty eye opening.

00:15:19.030 --> 00:15:21.707
We tend to think about
progress as linear.

00:15:21.707 --> 00:15:22.790
Things are just improving.

00:15:22.790 --> 00:15:26.960
And in reality, goes
kind of like that, right?

00:15:26.960 --> 00:15:31.057
Sometimes things have to get
worse before they get better.

00:15:31.057 --> 00:15:33.140
And Hyderabad is particularly
interesting in that,

00:15:33.140 --> 00:15:34.973
because if you look at
this chart over there

00:15:34.973 --> 00:15:36.540
about population
growth in Hyderabad,

00:15:36.540 --> 00:15:38.039
the city's been
growing really fast.

00:15:38.039 --> 00:15:40.220
So not only are a lot
of people coming online

00:15:40.220 --> 00:15:42.419
for the first time,
adding to this congestion,

00:15:42.419 --> 00:15:43.460
people are moving around.

00:15:43.460 --> 00:15:46.439
And when that happens, more and
more people come to one place,

00:15:46.439 --> 00:15:47.855
they overwhelm the
infrastructure.

00:15:50.297 --> 00:15:51.880
ALEX PETRESCU: A
point about that one.

00:15:51.880 --> 00:15:53.910
So the last data point is 2011.

00:15:53.910 --> 00:15:57.340
They've added another 3 million
people in the last four years.

00:15:57.340 --> 00:16:00.370
So this year or last year,
they had 9 million people.

00:16:00.370 --> 00:16:04.040
So they added as many
people in the last three

00:16:04.040 --> 00:16:06.760
years or four years as
they added the previous 10

00:16:06.760 --> 00:16:07.302
years before.

00:16:07.302 --> 00:16:09.885
ALEX SOUROV: Actually, another
interesting anecdote about this

00:16:09.885 --> 00:16:11.750
is if you go to a
rural area in India,

00:16:11.750 --> 00:16:13.520
as long as you stay
to a major highway,

00:16:13.520 --> 00:16:16.070
when you leave a large city,
your connection improves.

00:16:16.070 --> 00:16:17.445
Because along the
major highways,

00:16:17.445 --> 00:16:19.319
your connectivity is
actually pretty descent.

00:16:19.319 --> 00:16:21.290
And congestion start
getting less and less.

00:16:21.290 --> 00:16:23.040
So like just outside
of the cities,

00:16:23.040 --> 00:16:24.225
as long as you stick
to the major highway,

00:16:24.225 --> 00:16:26.016
you actually have really
good connectivity.

00:16:29.460 --> 00:16:33.120
ALEX PETRESCU: So this is
everyday life for most people

00:16:33.120 --> 00:16:36.080
in emerging markets.

00:16:36.080 --> 00:16:39.484
However, the more
we looked at this,

00:16:39.484 --> 00:16:42.150
the more we realized this is not
really just an emerging markets

00:16:42.150 --> 00:16:43.260
problem.

00:16:43.260 --> 00:16:45.670
This is really a subway problem.

00:16:45.670 --> 00:16:47.770
This is a crowded
stadium problem.

00:16:47.770 --> 00:16:49.364
This is a crowded
conference problem.

00:16:49.364 --> 00:16:50.530
This is a road trip problem.

00:16:50.530 --> 00:16:52.770
This is an airplane problem.

00:16:52.770 --> 00:16:55.490
Or if you're in New York
City or somewhere around,

00:16:55.490 --> 00:16:57.835
its your bad reception
in your house.

00:17:02.730 --> 00:17:04.430
It's essentially
issues boiled down

00:17:04.430 --> 00:17:07.030
to when you're
building mobile apps,

00:17:07.030 --> 00:17:08.470
the network is your enemy.

00:17:08.470 --> 00:17:11.569
It doesn't really matter
how good your phone is

00:17:11.569 --> 00:17:15.069
if you're on a bad network or
you happen to be in a situation

00:17:15.069 --> 00:17:17.380
where you're on a bad
network right now,

00:17:17.380 --> 00:17:19.354
your experience, your
user's experience

00:17:19.354 --> 00:17:20.645
is going to be pretty terrible.

00:17:24.125 --> 00:17:25.750
ALEX SOUROV: So when
we think about how

00:17:25.750 --> 00:17:26.800
we address this
issue, especially

00:17:26.800 --> 00:17:28.758
for the network issue,
we kind of break it down

00:17:28.758 --> 00:17:29.810
in two different classes.

00:17:29.810 --> 00:17:31.480
One is a strategies
for modern phones.

00:17:31.480 --> 00:17:33.790
Phone is not a limitation.

00:17:33.790 --> 00:17:35.050
It's not a constraint.

00:17:35.050 --> 00:17:35.930
But network is.

00:17:35.930 --> 00:17:37.054
How do we deal with that?

00:17:37.054 --> 00:17:38.470
And the other one
is the situation

00:17:38.470 --> 00:17:40.330
where your phone is
actually a limitation.

00:17:40.330 --> 00:17:42.020
So we're going to start
talking about strategies

00:17:42.020 --> 00:17:43.060
for modern phone first.

00:17:43.060 --> 00:17:45.730
So phones that
actually have storage,

00:17:45.730 --> 00:17:49.040
phone have pretty good CPU,
and phones that generally look

00:17:49.040 --> 00:17:52.720
like the desktop computers
of five years ago,

00:17:52.720 --> 00:17:54.274
or even better than that.

00:17:54.274 --> 00:17:56.190
ALEX PETRESCU: So the
easiest thing you can do

00:17:56.190 --> 00:17:59.330
is cache the data
that you download.

00:17:59.330 --> 00:18:03.350
So this is very
important, especially

00:18:03.350 --> 00:18:06.400
for images and a lot
of things that take

00:18:06.400 --> 00:18:07.840
a lot of bytes over the wire.

00:18:07.840 --> 00:18:10.130
But it's also important
for just simple responses,

00:18:10.130 --> 00:18:14.560
like from your servers for
metadata and things like that.

00:18:14.560 --> 00:18:17.320
And the reason this is, because
the user might wake up the app.

00:18:17.320 --> 00:18:19.730
And they might have a
network connection right now.

00:18:19.730 --> 00:18:23.790
Or you might have downloaded
data yesterday for a view

00:18:23.790 --> 00:18:25.390
that they're clicking today.

00:18:25.390 --> 00:18:28.320
So try to cache as
much data as possible.

00:18:28.320 --> 00:18:30.460
You have the hardware
on the device.

00:18:30.460 --> 00:18:32.540
You have the storage.

00:18:32.540 --> 00:18:36.130
Your users will generally
thank you for it.

00:18:36.130 --> 00:18:41.250
Also, since you have CPUs,
and you have cores and threads

00:18:41.250 --> 00:18:43.340
that are available,
to try to preprocess

00:18:43.340 --> 00:18:44.870
your media before uploading.

00:18:44.870 --> 00:18:47.940
If you're going to
use a photo on a site

00:18:47.940 --> 00:18:50.440
and it's going to be
a thousand pixels,

00:18:50.440 --> 00:18:53.700
don't upload a five megapixel
or 10 megapixel image

00:18:53.700 --> 00:18:54.480
from the device.

00:18:54.480 --> 00:18:57.670
It doesn't make any sense to
then throw 99% of the bytes

00:18:57.670 --> 00:19:00.010
away once they
get to the server.

00:19:00.010 --> 00:19:02.920
Preprocess it first on the
client, and then upload it.

00:19:02.920 --> 00:19:04.410
Do it in the
background obviously.

00:19:04.410 --> 00:19:05.951
Tell the user that
you're doing stuff

00:19:05.951 --> 00:19:07.360
so he knows why
his phone is hot.

00:19:07.360 --> 00:19:10.120
But do it on the device.

00:19:10.120 --> 00:19:13.280
And then make sure, essentially,
anytime you're posting,

00:19:13.280 --> 00:19:15.790
you're serializing, you queue
these up in the background.

00:19:15.790 --> 00:19:19.030
So never require
network to post data.

00:19:19.030 --> 00:19:21.200
So if I'm uploading
a bunch of photos,

00:19:21.200 --> 00:19:23.722
allow me to essentially
queue those up right now,

00:19:23.722 --> 00:19:25.680
because that's when I
want to do it, right now.

00:19:25.680 --> 00:19:27.650
And then you do it
in the background

00:19:27.650 --> 00:19:29.200
whenever you have a connection.

00:19:29.200 --> 00:19:32.310
Don't make me essentially
wait, look for a spinner.

00:19:32.310 --> 00:19:35.630
And then use the threads.

00:19:35.630 --> 00:19:38.320
Especially, for example,
things like view inflation,

00:19:38.320 --> 00:19:39.520
is very expensive.

00:19:39.520 --> 00:19:41.940
It takes a while,
especially on older phones.

00:19:41.940 --> 00:19:44.910
If you need data for that
view, start the network

00:19:44.910 --> 00:19:48.110
fetch literally as early as
possible, maybe sometimes

00:19:48.110 --> 00:19:50.380
even on the screen beforehand.

00:19:50.380 --> 00:19:52.830
So by the time that
the view is loaded,

00:19:52.830 --> 00:19:56.100
they don't have to wait
those extra 500 milliseconds,

00:19:56.100 --> 00:19:59.700
a second to do that.

00:19:59.700 --> 00:20:02.490
So next, use the
network cleverly.

00:20:02.490 --> 00:20:06.370
So we talk about caching.

00:20:06.370 --> 00:20:08.400
If you have a good cache,
one thing you could do

00:20:08.400 --> 00:20:09.740
is prefetch data.

00:20:09.740 --> 00:20:14.620
So prefetching comes in
different shapes and sizes.

00:20:14.620 --> 00:20:19.620
It could mean prefetch for the
next 30 seconds of interactions

00:20:19.620 --> 00:20:22.160
or 3 minutes of
interactions, or prefetch

00:20:22.160 --> 00:20:26.430
for later on today,
if it's a notification

00:20:26.430 --> 00:20:27.920
or something like that.

00:20:27.920 --> 00:20:30.230
And then maximize the
usage of the network

00:20:30.230 --> 00:20:31.212
when it's available.

00:20:31.212 --> 00:20:32.670
If you have a
connection right now,

00:20:32.670 --> 00:20:35.050
you need to get a bunch
of data for a list view

00:20:35.050 --> 00:20:37.670
or something like that,
try to get it all at once.

00:20:37.670 --> 00:20:39.840
There's many different
reasons for this.

00:20:39.840 --> 00:20:41.272
Mostly mobile
networks are bursty.

00:20:41.272 --> 00:20:42.980
So once you get a
connection, it's great.

00:20:42.980 --> 00:20:44.170
You have data.

00:20:44.170 --> 00:20:49.110
Stuff are going to come over
the network very quickly.

00:20:49.110 --> 00:20:52.870
And also, once it's done,
the radio can go to sleep.

00:20:52.870 --> 00:20:54.650
So that will use
less battery usage.

00:20:54.650 --> 00:20:57.372
And your users
will be happy too.

00:20:57.372 --> 00:20:58.830
But when you're
prefetching, you're

00:20:58.830 --> 00:21:00.288
doing all the extra
stuff, you need

00:21:00.288 --> 00:21:03.030
to make sure you
prioritize cancel requests

00:21:03.030 --> 00:21:05.200
if the user switches
and does something else.

00:21:05.200 --> 00:21:07.780
If you predicted that they're
going to scroll in the list

00:21:07.780 --> 00:21:09.600
and they decide to
click on something,

00:21:09.600 --> 00:21:11.860
cancel all their request
that you currently

00:21:11.860 --> 00:21:13.730
are doing for the list.

00:21:13.730 --> 00:21:16.654
Trunk responses, especially this
is-- I talk a lot about lists

00:21:16.654 --> 00:21:17.820
because I work on News Feed.

00:21:17.820 --> 00:21:19.550
Lists are my life.

00:21:19.550 --> 00:21:23.930
So you know, if you need
the data for 10 stories

00:21:23.930 --> 00:21:25.914
and you're on a fast
connection, that's great.

00:21:25.914 --> 00:21:28.330
Wait till you get those 10
stories because it's only going

00:21:28.330 --> 00:21:30.780
to take you a few milliseconds.

00:21:30.780 --> 00:21:32.850
However, if you're
on a slow connection,

00:21:32.850 --> 00:21:37.360
you only need two stories,
or maybe five rows of data

00:21:37.360 --> 00:21:38.870
in order to show to the user.

00:21:38.870 --> 00:21:42.020
So just tell the server,
give me the first five.

00:21:42.020 --> 00:21:43.000
Let me process it.

00:21:43.000 --> 00:21:46.060
And then give me the
rest in the background.

00:21:46.060 --> 00:21:49.160
So you can return those first
few responses to the UI very,

00:21:49.160 --> 00:21:50.630
very quickly.

00:21:50.630 --> 00:21:52.680
These type of things
are great optimizations

00:21:52.680 --> 00:21:54.980
for just user experience.

00:21:54.980 --> 00:21:58.520
Keep your requests small,
especially when you're sending.

00:21:58.520 --> 00:22:00.242
Packet size matters.

00:22:00.242 --> 00:22:02.700
Usually I think it's like, 1
and 1/2 kilobytes or something

00:22:02.700 --> 00:22:03.310
like that.

00:22:03.310 --> 00:22:05.510
Try to fit your
request inside of that.

00:22:05.510 --> 00:22:08.460
So that has the highest
likelihood of actually getting

00:22:08.460 --> 00:22:10.220
to your server quickly.

00:22:10.220 --> 00:22:12.304
And then this is a
hyper-optimization,

00:22:12.304 --> 00:22:14.220
but something that's
actually quite important.

00:22:14.220 --> 00:22:16.770
DNS is quite unreliable
for some reason.

00:22:16.770 --> 00:22:19.520
So even though the user
has an active connection,

00:22:19.520 --> 00:22:22.300
and if you connect
via IP, it works fine.

00:22:22.300 --> 00:22:24.070
Often, DNS servers will fail.

00:22:24.070 --> 00:22:26.510
And it's really, really lame.

00:22:26.510 --> 00:22:28.460
I think, one of
the optimizations,

00:22:28.460 --> 00:22:31.160
I think WhatsApp or
something has done,

00:22:31.160 --> 00:22:33.220
but it's a great
way to essentially

00:22:33.220 --> 00:22:34.160
just have a fallback.

00:22:34.160 --> 00:22:36.054
If you can't do
a DNS resolution,

00:22:36.054 --> 00:22:37.470
try to fallback
to something else.

00:22:37.470 --> 00:22:38.970
It might work.

00:22:38.970 --> 00:22:41.860
And it will be
great for your user.

00:22:41.860 --> 00:22:43.360
ALEX SOUROV: And
prefetching doesn't

00:22:43.360 --> 00:22:44.526
come without its challenges.

00:22:44.526 --> 00:22:47.640
I think anybody who
actually tried that knows.

00:22:47.640 --> 00:22:49.600
The challenge is fairly obvious.

00:22:49.600 --> 00:22:54.370
It's server CPU, data costs,
battery usage, storage.

00:22:54.370 --> 00:22:57.856
And it can get in the way of
the interactions with the user.

00:22:57.856 --> 00:22:59.230
Even if you're
trying to prefetch

00:22:59.230 --> 00:23:01.072
when the user is
not doing anything,

00:23:01.072 --> 00:23:02.280
they can start at any moment.

00:23:02.280 --> 00:23:06.530
And sometimes cancelling
those fetches is not cheap.

00:23:06.530 --> 00:23:09.455
So prefetching is
inherently probabilistic,

00:23:09.455 --> 00:23:11.580
because you are basically
guessing that the user is

00:23:11.580 --> 00:23:12.765
going to use the data.

00:23:12.765 --> 00:23:14.390
And that's where most
of the challenges

00:23:14.390 --> 00:23:17.160
are going to come from,
because if you guess wrong,

00:23:17.160 --> 00:23:21.470
you just incur all this
cost without any benefits.

00:23:21.470 --> 00:23:24.800
So to deal with that,
we'll talk a little bit

00:23:24.800 --> 00:23:27.900
about what smart
prefetching looks like.

00:23:27.900 --> 00:23:29.510
ALEX PETRESCU: So
smart prefetching,

00:23:29.510 --> 00:23:31.820
because there's
lots of challenges.

00:23:31.820 --> 00:23:34.720
Use the cache data creatively.

00:23:34.720 --> 00:23:37.580
In our app, for example, when
you wake up the app initially,

00:23:37.580 --> 00:23:40.347
we'll show you stories
you've already downloaded.

00:23:40.347 --> 00:23:41.930
We're starting to
essentially show you

00:23:41.930 --> 00:23:43.610
story that we have
in your cache,

00:23:43.610 --> 00:23:45.190
but you've never seen before.

00:23:45.190 --> 00:23:48.810
So there's no reason to show you
something that we already have

00:23:48.810 --> 00:23:50.780
and wait for the network.

00:23:50.780 --> 00:23:53.110
And then this is great,
because in offline mode,

00:23:53.110 --> 00:23:54.587
you can still open up our app.

00:23:54.587 --> 00:23:56.170
You can scroll through
your news feed.

00:23:56.170 --> 00:23:57.625
You can like and comment.

00:23:57.625 --> 00:23:59.000
There won't be
any fresh stories.

00:23:59.000 --> 00:24:00.920
Obviously you still
need a network for that.

00:24:00.920 --> 00:24:04.430
But there will be stories
relatively recently.

00:24:04.430 --> 00:24:06.114
And then if you can,
normalize the data.

00:24:06.114 --> 00:24:08.030
You might have different
endpoints that return

00:24:08.030 --> 00:24:09.700
different pieces of the story.

00:24:09.700 --> 00:24:12.720
You might have a list view
that returns part of the data,

00:24:12.720 --> 00:24:15.570
and then a detail view
that has more data.

00:24:15.570 --> 00:24:18.800
So essentially, take the
data from the list view

00:24:18.800 --> 00:24:20.540
and put it on top
of your detail view

00:24:20.540 --> 00:24:22.585
while you're loading
the rest of the data.

00:24:24.742 --> 00:24:27.075
The users essentially doesn't
have to wait for this view

00:24:27.075 --> 00:24:27.650
to load.

00:24:27.650 --> 00:24:28.440
He sees something.

00:24:28.440 --> 00:24:30.800
There's not just a
big spinner on screen.

00:24:30.800 --> 00:24:35.420
And Google has given
us JobScheduler,

00:24:35.420 --> 00:24:40.530
and the GcmNetworkManager for
pre-Lollipop devices, which

00:24:40.530 --> 00:24:42.710
makes all this much, much
easier, and much more

00:24:42.710 --> 00:24:43.210
efficient.

00:24:43.210 --> 00:24:44.626
We can optimize
for battery usage,

00:24:44.626 --> 00:24:46.760
make sure these
type of prefetches,

00:24:46.760 --> 00:24:48.390
especially in the
background, will

00:24:48.390 --> 00:24:50.450
happen at the same
time with other stuff.

00:24:50.450 --> 00:24:52.700
They will happen on the
types of networks we want.

00:24:52.700 --> 00:24:54.770
The network will be available.

00:24:54.770 --> 00:24:56.860
Like I mentioned
before, you can start

00:24:56.860 --> 00:24:59.920
the app in the background, but
there's a very high likelihood

00:24:59.920 --> 00:25:03.390
that your request will fail
because they have mobile off,

00:25:03.390 --> 00:25:06.320
or for various reasons.

00:25:06.320 --> 00:25:09.630
And then you can do
things like not prefetch

00:25:09.630 --> 00:25:10.960
on certain connection types.

00:25:10.960 --> 00:25:12.440
So we have Connection class.

00:25:12.440 --> 00:25:15.400
And what we found is that
on really fast networks,

00:25:15.400 --> 00:25:17.220
prefetching is useless.

00:25:17.220 --> 00:25:17.750
Don't do it.

00:25:17.750 --> 00:25:19.070
It's not worth the cost.

00:25:19.070 --> 00:25:22.990
Because your paying-- the
amount of time users are waiting

00:25:22.990 --> 00:25:25.770
is so small that it's not
worth you guessing and missing,

00:25:25.770 --> 00:25:28.485
and then using resources
in the background

00:25:28.485 --> 00:25:30.360
and trying to process
stuff while the user us

00:25:30.360 --> 00:25:31.026
doing something.

00:25:31.026 --> 00:25:32.010
So just don't do it.

00:25:32.010 --> 00:25:33.880
Doesn't matter which
type of device it is.

00:25:33.880 --> 00:25:35.690
If you are on a fast
connection, there's

00:25:35.690 --> 00:25:36.750
no point in prefetching.

00:25:36.750 --> 00:25:38.757
You're not going to
get a lot of benefit.

00:25:38.757 --> 00:25:40.340
ALEX SOUROV: Unless
it's intermittent.

00:25:40.340 --> 00:25:41.714
You have to deal
with that, fine.

00:25:41.714 --> 00:25:42.560
ALEX PETRESCU: Sure.

00:25:42.560 --> 00:25:44.179
There's lots of challenges.

00:25:44.179 --> 00:25:46.220
And then when of the
hardest problems in computer

00:25:46.220 --> 00:25:48.130
science is cache invalidation.

00:25:48.130 --> 00:25:52.610
So making sure when--
keeping your cache fresh.

00:25:52.610 --> 00:25:56.440
This might mean periodically
during delta syncs

00:25:56.440 --> 00:25:58.310
and be like hey, has
anything changed?

00:25:58.310 --> 00:26:00.500
And the server can just
say like, yes or no,

00:26:00.500 --> 00:26:02.550
as opposed to just
re-downloading everything

00:26:02.550 --> 00:26:04.569
all the time.

00:26:04.569 --> 00:26:06.860
ALEX SOUROV: And the story
we're going to tell you here

00:26:06.860 --> 00:26:08.318
is the story of
comment prefetching

00:26:08.318 --> 00:26:10.400
and how we sort of
thought about this.

00:26:10.400 --> 00:26:13.620
If you use the Facebook app,
you know that you generally

00:26:13.620 --> 00:26:14.545
get the stories.

00:26:14.545 --> 00:26:16.920
And then to get to the comments,
you click on the button.

00:26:16.920 --> 00:26:18.391
You get the comment
counts, but you

00:26:18.391 --> 00:26:20.140
need to click on the
button to go to them.

00:26:20.140 --> 00:26:22.640
And for a variety of
reasons, fetching comments

00:26:22.640 --> 00:26:25.590
is a pretty expensive operation
and may take some time.

00:26:25.590 --> 00:26:28.780
So it seemed like an ideal
candidate for prefetching,

00:26:28.780 --> 00:26:30.450
and it does help a
lot with performance.

00:26:30.450 --> 00:26:31.780
But there is a problem.

00:26:31.780 --> 00:26:34.490
Even users who use the app
a lot don't necessary click

00:26:34.490 --> 00:26:37.814
on every single common
count for every single story

00:26:37.814 --> 00:26:38.730
to see their comments.

00:26:38.730 --> 00:26:41.680
As a matter of fact, the
majority of the stories,

00:26:41.680 --> 00:26:43.170
users don't click
on the comments.

00:26:43.170 --> 00:26:44.840
They don't look at them.

00:26:44.840 --> 00:26:48.074
And so the problem is, how
do you make it efficient?

00:26:48.074 --> 00:26:50.490
That's a great scenario for a
more probabilistic approach.

00:26:50.490 --> 00:26:53.650
So we're going to try to guess
whether you're actually going

00:26:53.650 --> 00:26:55.460
to read this comment or not.

00:26:55.460 --> 00:26:57.960
In some cases it's fairly easy,
because occasionally we show

00:26:57.960 --> 00:26:59.770
you a story you've seen before.

00:26:59.770 --> 00:27:01.750
But it's got more
comments and more likes.

00:27:01.750 --> 00:27:03.240
In which case, we're already
showing you this story

00:27:03.240 --> 00:27:04.323
because it's got comments.

00:27:04.323 --> 00:27:05.692
So it's a good one to prefetch.

00:27:05.692 --> 00:27:07.400
In other case it's a
little bit trickier.

00:27:07.400 --> 00:27:08.490
There are different
parameters that we

00:27:08.490 --> 00:27:09.750
take into consideration.

00:27:09.750 --> 00:27:12.265
And we actually have a
system on the server that

00:27:12.265 --> 00:27:14.140
does machine learning
and tries to figure out

00:27:14.140 --> 00:27:16.570
how likely are you to actually
look at the comment or not.

00:27:16.570 --> 00:27:19.370
And then the server sends this
probability back to the client,

00:27:19.370 --> 00:27:21.360
and the client can look
at that and say, well,

00:27:21.360 --> 00:27:23.550
do I want to prefetch or
not, depending on what kind

00:27:23.550 --> 00:27:25.790
of device you are running
and what kind of conditions

00:27:25.790 --> 00:27:26.757
you are under.

00:27:26.757 --> 00:27:29.090
So that's an example of how
probabilistic prefetch works

00:27:29.090 --> 00:27:30.550
fairly well.

00:27:30.550 --> 00:27:32.720
That also means that
sometimes when you are offline

00:27:32.720 --> 00:27:34.754
or in a bad connection,
occasionally you

00:27:34.754 --> 00:27:36.670
click on the comments,
it will take some time.

00:27:36.670 --> 00:27:39.165
But we have generally
pretty good about this.

00:27:39.165 --> 00:27:40.790
And so most the time,
when you actually

00:27:40.790 --> 00:27:43.290
want to look at the comment,
it's going to be there for you.

00:27:45.670 --> 00:27:47.320
So now strategies
for low end phone.

00:27:47.320 --> 00:27:49.840
Low ends phones is a completely
different situation here,

00:27:49.840 --> 00:27:51.130
because in the low end phones.

00:27:51.130 --> 00:27:53.560
You actually have
limitations of the device.

00:27:53.560 --> 00:27:55.930
And you have to worry
about those constraints.

00:27:55.930 --> 00:28:00.880
And the biggest constraints
you have to deal with is space.

00:28:00.880 --> 00:28:02.550
ALEX PETRESCU: So
it's a challenge.

00:28:02.550 --> 00:28:05.680
But if you're targeting
low end phones,

00:28:05.680 --> 00:28:08.440
one of the biggest
hardship users

00:28:08.440 --> 00:28:10.570
have is that very
low disk space.

00:28:10.570 --> 00:28:13.550
So often upgrading your app
or downloading a new app

00:28:13.550 --> 00:28:14.976
is very challenge for a user.

00:28:14.976 --> 00:28:16.850
You have to delete one
of the other four apps

00:28:16.850 --> 00:28:19.450
that they can have on the
phone at the same time.

00:28:19.450 --> 00:28:22.680
So developing an app that has
a lightweight app footprint

00:28:22.680 --> 00:28:25.770
is paramount for
these type of phones.

00:28:25.770 --> 00:28:28.160
Next, caching is a premium.

00:28:28.160 --> 00:28:33.350
Again, very low disk
storage on the device.

00:28:33.350 --> 00:28:35.250
So if you're taking
up another 100 megs

00:28:35.250 --> 00:28:37.990
to store images that
they may or may not see,

00:28:37.990 --> 00:28:40.690
that's not going to be a
good trade off for the user.

00:28:40.690 --> 00:28:44.290
And honestly, for
most of these users,

00:28:44.290 --> 00:28:46.320
the mobile website
is their fallback.

00:28:46.320 --> 00:28:48.280
And it's like, oh, I
can't install this app.

00:28:48.280 --> 00:28:50.930
I really want to use this
feature, this service,

00:28:50.930 --> 00:28:53.170
this website I've heard about.

00:28:53.170 --> 00:28:55.152
I don't have space to
download or I don't

00:28:55.152 --> 00:28:56.450
have a good enough connection.

00:28:56.450 --> 00:28:59.450
So make sure you have
a good mobile website.

00:28:59.450 --> 00:29:02.890
And by good, I mean
not a desktop web site

00:29:02.890 --> 00:29:06.890
that just happens to fit
inside of the window.

00:29:06.890 --> 00:29:09.260
You really need to have
one that is specifically

00:29:09.260 --> 00:29:12.010
focused for these type of users
and these type of devices.

00:29:12.010 --> 00:29:14.420
They're the ones most
likely to use this website.

00:29:14.420 --> 00:29:18.760
So to take a term
from web development,

00:29:18.760 --> 00:29:21.340
you should essentially build
progressively, enhance site.

00:29:21.340 --> 00:29:22.800
Essentially make
sure your site has

00:29:22.800 --> 00:29:26.100
the features necessary without
JavaScript, without CSS.

00:29:26.100 --> 00:29:28.780
Because these users might have
turned that off because it's

00:29:28.780 --> 00:29:30.520
slow for them.

00:29:30.520 --> 00:29:34.160
And then a new thing that
has come out last year

00:29:34.160 --> 00:29:36.400
is that you can
essentially have many

00:29:36.400 --> 00:29:39.960
of the benefits of
native applications using

00:29:39.960 --> 00:29:44.250
push notifications
on mobile websites.

00:29:44.250 --> 00:29:47.120
So we're going to talk about the
push notifications a little bit

00:29:47.120 --> 00:29:48.040
later.

00:29:48.040 --> 00:29:50.360
So you won't have to deal
with these type of phones

00:29:50.360 --> 00:29:51.450
or networks.

00:29:51.450 --> 00:29:54.210
These are a little bit older
than what we're targeting.

00:29:54.210 --> 00:29:57.990
But it's still best to send
as little data as possible

00:29:57.990 --> 00:29:59.430
over the wire.

00:29:59.430 --> 00:30:04.120
We're talking about,
no metadata at all.

00:30:04.120 --> 00:30:06.120
If you're not rendering
on this screen

00:30:06.120 --> 00:30:09.770
at this exact point in time,
do not send it over the wire.

00:30:09.770 --> 00:30:13.240
Focus on essentially formats.

00:30:13.240 --> 00:30:16.280
JSON is a great
format for developers.

00:30:16.280 --> 00:30:19.930
It's kind of verbose
when it comes to devices.

00:30:19.930 --> 00:30:23.150
So other essentially
binary protocol

00:30:23.150 --> 00:30:27.470
such as protobufs, or
we use flat buffers--

00:30:27.470 --> 00:30:30.490
that allow you essentially
to send bytes over the wire

00:30:30.490 --> 00:30:33.410
and data over the wire without
having the paid deserialization

00:30:33.410 --> 00:30:35.020
costs.

00:30:35.020 --> 00:30:37.057
And so that goes back
to pre-processing data

00:30:37.057 --> 00:30:37.640
on the server.

00:30:37.640 --> 00:30:38.720
Don't send metadata.

00:30:38.720 --> 00:30:40.877
If you're concatenating
a bunch of strings,

00:30:40.877 --> 00:30:41.960
don't do it on the client.

00:30:41.960 --> 00:30:43.970
Do it on the server.

00:30:43.970 --> 00:30:45.920
Minimize background
work and I/O,

00:30:45.920 --> 00:30:48.190
because you only have one core.

00:30:48.190 --> 00:30:51.520
So it's going to
interfere with things

00:30:51.520 --> 00:30:53.020
that are happening on the UI.

00:30:53.020 --> 00:30:55.060
It's going to be pretty crappy.

00:30:55.060 --> 00:30:57.750
And then minimize the number
of simultaneous requests.

00:30:57.750 --> 00:31:01.620
Often on 2G networks
and low end networks,

00:31:01.620 --> 00:31:04.750
you don't have the
available upstream bandwidth

00:31:04.750 --> 00:31:06.970
to send multiple requests
at the same time.

00:31:06.970 --> 00:31:11.525
So essentially throttle yourself
to one request at a time.

00:31:11.525 --> 00:31:12.900
ALEX SOUROV: Some
things you just

00:31:12.900 --> 00:31:14.399
can't do on low
end devices are--

00:31:14.399 --> 00:31:16.440
at least we haven't figured
out a way to do that.

00:31:16.440 --> 00:31:18.523
For example, how would you
deal with intermittency

00:31:18.523 --> 00:31:20.000
if you don't have
the cache space

00:31:20.000 --> 00:31:22.390
and you can't really
prefetch ahead of time?

00:31:22.390 --> 00:31:22.890
Pretty hard.

00:31:22.890 --> 00:31:26.600
But you can do fairly
well in situations

00:31:26.600 --> 00:31:29.140
where the network
which is just slow.

00:31:29.140 --> 00:31:33.031
So the tale here is the mobile
web and push applications.

00:31:33.031 --> 00:31:35.030
The one thing I want to
mention about mobile app

00:31:35.030 --> 00:31:39.249
is there is a misconception
that on Android, mobile web is

00:31:39.249 --> 00:31:40.540
going down in terms of numbers.

00:31:40.540 --> 00:31:43.230
And the native
applications are going up.

00:31:43.230 --> 00:31:45.750
And actually, what's true
is both are going up.

00:31:45.750 --> 00:31:47.250
Because a lot of
users are switching

00:31:47.250 --> 00:31:49.630
from feature phones--
I mean, a lot of them

00:31:49.630 --> 00:31:52.670
are switching to devices which
is just not powerful enough

00:31:52.670 --> 00:31:56.350
to run some of the functionality
we have in the main app.

00:31:56.350 --> 00:31:59.640
And they opt for using
the mobile web instead.

00:31:59.640 --> 00:32:02.290
And we think for some devices,
it's a perfectly great solution

00:32:02.290 --> 00:32:02.851
to do that.

00:32:02.851 --> 00:32:04.600
So the usage is growing
for both of those.

00:32:04.600 --> 00:32:07.926
And I think for most other
apps, that's true as well.

00:32:07.926 --> 00:32:10.050
And push applications is
just really exciting topic

00:32:10.050 --> 00:32:13.080
because up until
this year, what, push

00:32:13.080 --> 00:32:14.360
notifications in the browser?

00:32:14.360 --> 00:32:16.030
Where did they come from?

00:32:16.030 --> 00:32:19.690
And so this year, we
actually originally partnered

00:32:19.690 --> 00:32:22.000
with UC Mini and
UC Browser, which

00:32:22.000 --> 00:32:25.230
is a very popular browser
in China and India

00:32:25.230 --> 00:32:27.490
to provide push notifications.

00:32:27.490 --> 00:32:30.640
And we did that with UC Mini,
and then we did it with Opera.

00:32:30.640 --> 00:32:34.090
And in both cases, we
saw a tremendous response

00:32:34.090 --> 00:32:35.347
from the users.

00:32:35.347 --> 00:32:37.680
Very active push notifications
is a great functionality.

00:32:37.680 --> 00:32:39.479
And so they visited
the app more often.

00:32:39.479 --> 00:32:40.770
And then we worked with Google.

00:32:40.770 --> 00:32:43.900
Google was very interested in
building as a platform feature.

00:32:43.900 --> 00:32:44.850
And they did that.

00:32:44.850 --> 00:32:46.224
In Chrome right
now, you actually

00:32:46.224 --> 00:32:48.880
can have different apps do
the same thing that we did

00:32:48.880 --> 00:32:51.300
and provide push
notifications for them.

00:32:51.300 --> 00:32:53.870
So they have a platform, and
apps can actually do that now.

00:32:53.870 --> 00:32:55.390
And they're seeing similar
response for all of them.

00:32:55.390 --> 00:32:56.973
I mean, it's just
been great for users

00:32:56.973 --> 00:33:00.780
who can't have a native app
installed on their device,

00:33:00.780 --> 00:33:04.070
or prefer to use a
mobile web instead.

00:33:04.070 --> 00:33:06.670
Firefox is the last
major mobile browser.

00:33:06.670 --> 00:33:08.796
And they announced
recently that their support

00:33:08.796 --> 00:33:11.170
for push notifications is also
coming sometime this year.

00:33:11.170 --> 00:33:12.836
So everybody's moving
in that direction.

00:33:12.836 --> 00:33:14.661
It's pretty great.

00:33:14.661 --> 00:33:16.410
ALEX PETRESCU: Want
to stop for questions?

00:33:16.410 --> 00:33:16.680
ALEX SOUROV: Yeah.

00:33:16.680 --> 00:33:18.429
I mean, I think we had
a lot of materials.

00:33:18.429 --> 00:33:22.185
We have about 15 minutes more
of more material to cover.

00:33:22.185 --> 00:33:23.810
But we wanted to stop
and see if people

00:33:23.810 --> 00:33:26.690
have any questions
before we go on,

00:33:26.690 --> 00:33:28.725
about the material
we just presented.

00:33:28.725 --> 00:33:30.100
If people have
general questions,

00:33:30.100 --> 00:33:32.240
they can also come
out afterwards.

00:33:32.240 --> 00:33:34.680
Anybody?

00:33:34.680 --> 00:33:36.414
Yep, there's a question there.

00:33:36.414 --> 00:33:40.390
AUDIENCE: So shining a light
on some very big problems

00:33:40.390 --> 00:33:41.384
to solve.

00:33:41.384 --> 00:33:46.354
So for companies that don't have
the resources engineering wise

00:33:46.354 --> 00:33:50.330
to do all that, do you have any
suggestions or what to pick off

00:33:50.330 --> 00:33:52.318
and start with instead
of going like oh,

00:33:52.318 --> 00:33:57.360
our app is terrible
compared to Facebook's?

00:33:57.360 --> 00:33:59.189
Any typical first
steps involved?

00:33:59.189 --> 00:33:59.980
ALEX SOUROV: Right.

00:33:59.980 --> 00:34:02.400
So the question the
question is, a lot of stuff

00:34:02.400 --> 00:34:04.910
here is pretty high end like
maybe utilizing the server

00:34:04.910 --> 00:34:07.072
power and require a lot
of development work.

00:34:07.072 --> 00:34:08.530
For companies who
are just starting

00:34:08.530 --> 00:34:12.360
to think about the
emerging markets, what

00:34:12.360 --> 00:34:15.735
are the first few things they
could do to make things better?

00:34:15.735 --> 00:34:18.000
Alex, you want to take that?

00:34:18.000 --> 00:34:19.560
ALEX PETRESCU: Sure.

00:34:19.560 --> 00:34:21.810
I think a lot of the things
that we're talking about,

00:34:21.810 --> 00:34:25.810
things like caching data
and optimizing for your app

00:34:25.810 --> 00:34:27.739
not being online at
this very second,

00:34:27.739 --> 00:34:29.719
are kind of just
user experience.

00:34:29.719 --> 00:34:31.345
And those are
just- you just have

00:34:31.345 --> 00:34:34.616
to have those assumptions when
you're building your product.

00:34:34.616 --> 00:34:36.199
It's really hard to
go back afterwards

00:34:36.199 --> 00:34:37.870
and being like, oh,
I'm going to redesign

00:34:37.870 --> 00:34:39.030
it to work in these things.

00:34:39.030 --> 00:34:41.250
It's quite challenging.

00:34:41.250 --> 00:34:43.540
I know, we're doing it.

00:34:43.540 --> 00:34:46.479
But when you're building,
for a small company,

00:34:46.479 --> 00:34:47.520
you can move much faster.

00:34:47.520 --> 00:34:48.429
And you can do a lot.

00:34:48.429 --> 00:34:50.750
But things like caching
data, it's not hard.

00:34:50.750 --> 00:34:52.719
Like images and
things like that,

00:34:52.719 --> 00:34:55.782
that's no brainer type stuff.

00:34:55.782 --> 00:34:57.490
Prefetching in lists
and things like that

00:34:57.490 --> 00:35:00.690
are also not-- understanding
your users and their flow,

00:35:00.690 --> 00:35:02.420
understanding who your uses are.

00:35:02.420 --> 00:35:05.590
So implementing Connection
class in your class, just purely

00:35:05.590 --> 00:35:08.300
for your analytics
first, that's actually

00:35:08.300 --> 00:35:09.920
most important what we found.

00:35:09.920 --> 00:35:12.170
Just implement it as
part of your analytics.

00:35:12.170 --> 00:35:13.780
Try to understand
what's going on.

00:35:13.780 --> 00:35:15.950
And then optimize for
scenarios that you see.

00:35:15.950 --> 00:35:18.740
Like you might see
a login flow is

00:35:18.740 --> 00:35:23.010
broken and has a huge drop off
on your class 2010 devices.

00:35:23.010 --> 00:35:24.850
So you can grab a year
class 2010 device,

00:35:24.850 --> 00:35:26.940
and then optimize for
that, as opposed to trying

00:35:26.940 --> 00:35:30.840
to do everything up front,
which is challenging.

00:35:30.840 --> 00:35:32.510
So data first.

00:35:32.510 --> 00:35:33.470
Analytics first.

00:35:33.470 --> 00:35:36.219
And then find the big
problems in your app.

00:35:36.219 --> 00:35:38.260
ALEX SOUROV: And there is
many open source things

00:35:38.260 --> 00:35:40.260
like year, class, and
network connection classes

00:35:40.260 --> 00:35:42.477
too, because a lot of
engineers in other companies

00:35:42.477 --> 00:35:43.810
were asking hey, what can we do?

00:35:43.810 --> 00:35:45.890
And we thought that would
be useful for them as well.

00:35:45.890 --> 00:35:47.973
But there are some basic
[INAUDIBLE] as Alex said.

00:35:47.973 --> 00:35:49.995
You know, just catching.

00:35:49.995 --> 00:35:52.370
ALEX PETRESCU: And we're going
to talk about a few things

00:35:52.370 --> 00:35:54.890
like right now, some
tools and some ideas

00:35:54.890 --> 00:35:58.080
that we've essentially built
into our apps to essentially

00:35:58.080 --> 00:35:58.910
solve this issue.

00:35:58.910 --> 00:36:01.327
Because it is a very
difficult problem.

00:36:01.327 --> 00:36:03.410
ALEX SOUROV: Any more
questions before we move on?

00:36:06.326 --> 00:36:06.825
No.

00:36:06.825 --> 00:36:09.070
All right.

00:36:09.070 --> 00:36:12.480
So moving on to testing.

00:36:12.480 --> 00:36:15.140
Most of us are here, we have
the connections that we have.

00:36:15.140 --> 00:36:16.540
And they're pretty good.

00:36:16.540 --> 00:36:19.049
How do we test for bad networks?

00:36:19.049 --> 00:36:20.590
How do we test for
how the apps work,

00:36:20.590 --> 00:36:23.152
our apps work on bad networks?

00:36:23.152 --> 00:36:24.610
ALEX PETRESCU: So
one of the things

00:36:24.610 --> 00:36:28.160
we built last year is called
Augmented Traffic Control.

00:36:28.160 --> 00:36:30.030
And it's a tool
we've open sourced.

00:36:30.030 --> 00:36:34.180
It's a server you run on one of
the computers in your office.

00:36:34.180 --> 00:36:36.580
And then it provides
essentially-- you connect

00:36:36.580 --> 00:36:38.790
to it via Wi-Fi on your phone.

00:36:38.790 --> 00:36:41.130
So essentially all the
traffic from your app

00:36:41.130 --> 00:36:42.760
or other apps on
your phone could

00:36:42.760 --> 00:36:45.280
go through Augmented
Traffic Control.

00:36:45.280 --> 00:36:47.030
And then there's
presets on there,

00:36:47.030 --> 00:36:49.490
so you can, for example,
see what my app feel

00:36:49.490 --> 00:36:52.250
like on 2G in rural India.

00:36:52.250 --> 00:36:56.010
Or when there's a black hole,
and I'm sending packets out,

00:36:56.010 --> 00:36:58.350
and everything is telling
me I have a connection,

00:36:58.350 --> 00:37:01.430
but nothing is coming back,
how does my app behave

00:37:01.430 --> 00:37:04.680
in these type of scenarios?

00:37:04.680 --> 00:37:06.080
So it's all open sourced.

00:37:06.080 --> 00:37:08.220
And you guys can look it up.

00:37:08.220 --> 00:37:10.190
But essentially it's
just a server somewhere

00:37:10.190 --> 00:37:16.500
with some simple software
that will both handle latency,

00:37:16.500 --> 00:37:19.590
bandwidth, and also
things like intermittency.

00:37:19.590 --> 00:37:22.920
So some requests will
be faster than others.

00:37:22.920 --> 00:37:25.170
They'll be bursty, things
like that, some more complex

00:37:25.170 --> 00:37:25.670
modeling.

00:37:28.210 --> 00:37:30.140
Next, Genymotion is out here.

00:37:30.140 --> 00:37:34.090
And they're a great tool
and a great emulator.

00:37:34.090 --> 00:37:38.030
So they've built the ability
to throttle your network.

00:37:38.030 --> 00:37:41.630
And they have presets
like 3G, and 4G, and Edge.

00:37:41.630 --> 00:37:43.245
So you can easily
see what it's like.

00:37:43.245 --> 00:37:45.620
I actually got stuck on one
of these modes the other day.

00:37:45.620 --> 00:37:47.224
And I was like, why
is my app so slow?

00:37:47.224 --> 00:37:48.140
Everything is loading.

00:37:48.140 --> 00:37:50.020
And I was like, oh,
I'm actually on Edge.

00:37:50.020 --> 00:37:53.680
I was like, this is what people
are feeling every single day.

00:37:53.680 --> 00:37:54.880
It is terrible.

00:37:54.880 --> 00:37:56.409
I'm sorry.

00:37:56.409 --> 00:37:58.200
And then there's also
the Android emulator.

00:37:58.200 --> 00:38:01.609
And it provides,
essentially, parameters

00:38:01.609 --> 00:38:03.650
you can pass in to tell
it, I want to be on Edge.

00:38:03.650 --> 00:38:05.660
I want to be on GPS.

00:38:05.660 --> 00:38:10.030
I want to be on Wi-Fi, and then
what the actual delay and speed

00:38:10.030 --> 00:38:11.090
is for those networks.

00:38:13.630 --> 00:38:16.544
ALEX SOUROV: So a lot
of this technologies,

00:38:16.544 --> 00:38:19.210
they're sort of Wi-Fi throttling
technologies or some variations

00:38:19.210 --> 00:38:20.117
of that.

00:38:20.117 --> 00:38:22.450
And Wi-Fi throttling is used
by other companies as well.

00:38:22.450 --> 00:38:25.185
ATC is not the only
solution for that.

00:38:25.185 --> 00:38:26.810
The tricky thing
about Wi-Fi throttling

00:38:26.810 --> 00:38:28.200
is that you can't
really dogfood.

00:38:28.200 --> 00:38:29.700
You can test, but you
can't really dogfood.

00:38:29.700 --> 00:38:31.330
You can't just
take that on a bus

00:38:31.330 --> 00:38:35.550
and try doing things, right, or
things you do in a daily life.

00:38:35.550 --> 00:38:37.306
And dogfooding is
very important.

00:38:37.306 --> 00:38:38.680
When we develop
our apps, we rely

00:38:38.680 --> 00:38:40.830
on dogfooding a lot
to sort of understand

00:38:40.830 --> 00:38:43.460
how the features feel
and how they work.

00:38:43.460 --> 00:38:44.460
And that's a challenge.

00:38:44.460 --> 00:38:46.560
Because with Wi-Fi
throttling and ATC,

00:38:46.560 --> 00:38:48.360
we don't actually get that.

00:38:48.360 --> 00:38:52.995
So we have a couple ideas
and how to solve that.

00:38:52.995 --> 00:38:55.510
And one of them is
VPN throttling, just

00:38:55.510 --> 00:38:57.802
building a VPN app which can
just throttle you as well.

00:38:57.802 --> 00:38:59.384
And it could throttle
you all the time

00:38:59.384 --> 00:39:01.510
and all of the apps on
your phone all the time.

00:39:01.510 --> 00:39:03.310
And it can work with
a current network

00:39:03.310 --> 00:39:05.034
and then just throttle it.

00:39:05.034 --> 00:39:06.450
So that's one
dogfooding solution.

00:39:06.450 --> 00:39:08.160
But another one, and
just to the question

00:39:08.160 --> 00:39:10.240
about how do you
do simple things,

00:39:10.240 --> 00:39:15.810
is don't underestimate the power
of sleep statement in your app.

00:39:15.810 --> 00:39:18.770
If you just have it
for the dogfooders

00:39:18.770 --> 00:39:21.800
or for the engineers where you
just slow down your network

00:39:21.800 --> 00:39:23.355
calls, all of them,
that's actually

00:39:23.355 --> 00:39:25.710
a great way to model latency.

00:39:25.710 --> 00:39:28.690
Just have it parameterizable
so you can change this.

00:39:28.690 --> 00:39:31.210
But that's one way to do that.

00:39:31.210 --> 00:39:35.590
And another way, simple way
to do things, for example,

00:39:35.590 --> 00:39:37.680
to demonstrate what
intermittency might look

00:39:37.680 --> 00:39:39.850
is just fail the network calls.

00:39:39.850 --> 00:39:43.737
You're not going to get
the entire richness of how

00:39:43.737 --> 00:39:45.820
the networks work and how
many ways they can fail,

00:39:45.820 --> 00:39:47.445
but it'll give you
a basic idea of what

00:39:47.445 --> 00:39:50.107
happens when your network
calls starts failing randomly,

00:39:50.107 --> 00:39:51.440
and how the app can handle this.

00:39:54.690 --> 00:39:56.316
And the story I
want to tell here

00:39:56.316 --> 00:39:58.190
is a story of 2G Tuesdays,
which is something

00:39:58.190 --> 00:40:00.490
we started doing internally.

00:40:00.490 --> 00:40:04.250
And we basically used these
techniques, just a simple sleep

00:40:04.250 --> 00:40:08.410
statement to get
the latency and just

00:40:08.410 --> 00:40:10.870
randomly return network
failures even if the network is

00:40:10.870 --> 00:40:12.270
perfectly fine.

00:40:12.270 --> 00:40:16.370
And then we ping
employees every Tuesday

00:40:16.370 --> 00:40:18.520
if you're on Android device.

00:40:18.520 --> 00:40:21.700
And we ask you if you want
to come in and participate

00:40:21.700 --> 00:40:23.410
in the 2G Tuesdays.

00:40:23.410 --> 00:40:25.290
And when you do, you
get those latencies.

00:40:25.290 --> 00:40:26.440
and you get those
intermittencies.

00:40:26.440 --> 00:40:28.065
Again, not the entire
richness, but you

00:40:28.065 --> 00:40:31.940
get enough to actually generate
a lot of interesting bugs.

00:40:31.940 --> 00:40:33.530
So obviously users
are encouraged

00:40:33.530 --> 00:40:35.620
to use and dogfood the
app as long as they can,

00:40:35.620 --> 00:40:36.654
as long as they want to.

00:40:36.654 --> 00:40:38.570
And that's been a great
source of bug reports,

00:40:38.570 --> 00:40:42.005
things which we otherwise would
not have found until they app

00:40:42.005 --> 00:40:44.609
went into the production.

00:40:44.609 --> 00:40:46.400
And it's also a great
way to build empathy.

00:40:46.400 --> 00:40:49.740
Like Alex was talking
about, nothing

00:40:49.740 --> 00:40:52.475
like just seeing a view
like that for five,

00:40:52.475 --> 00:40:55.220
10 seconds to sort of
understand what the problem is

00:40:55.220 --> 00:40:58.370
and really, really feel the
empathy with the people who

00:40:58.370 --> 00:40:59.620
have to go for this every day.

00:41:04.440 --> 00:41:06.190
ALEX PETRESCU: So next,
my favorite thing,

00:41:06.190 --> 00:41:09.600
because it's actually the
solution to all these problems,

00:41:09.600 --> 00:41:11.680
is configuration.

00:41:11.680 --> 00:41:14.550
So we build our
apps and we usually

00:41:14.550 --> 00:41:17.880
optimize for a certain
scenario, usually our scenario.

00:41:17.880 --> 00:41:20.020
I open the app, and I
click these buttons.

00:41:20.020 --> 00:41:20.750
And it works.

00:41:20.750 --> 00:41:23.320
And I close it, and
I'm like, it's done.

00:41:23.320 --> 00:41:24.240
It works.

00:41:24.240 --> 00:41:25.690
I guarantee it.

00:41:25.690 --> 00:41:28.720
Then we ship it and someone
clicks, and then it breaks.

00:41:28.720 --> 00:41:31.100
And you're like, why did
you click it that way?

00:41:31.100 --> 00:41:33.720
So yes, we're terrible at this.

00:41:33.720 --> 00:41:36.230
However, constants are bad.

00:41:36.230 --> 00:41:39.270
That's what we found
is that-- I like

00:41:39.270 --> 00:41:42.190
the quote-- "the only thing
that is constant is change."

00:41:42.190 --> 00:41:45.630
So we essentially have
allowed most, if not

00:41:45.630 --> 00:41:47.570
all of our features
of our app, to have

00:41:47.570 --> 00:41:50.690
parameters for everything
that could be configured.

00:41:50.690 --> 00:41:53.620
So things that would normally
be a static final const

00:41:53.620 --> 00:41:56.020
in your class is
now a parameter.

00:41:56.020 --> 00:41:59.480
It's still a const, but it could
be overridden on the server.

00:41:59.480 --> 00:42:01.530
And so what we do
is then it allows

00:42:01.530 --> 00:42:04.780
us to optimize all sorts
of different interactions

00:42:04.780 --> 00:42:07.700
and feelings inside of our
app for your current device.

00:42:07.700 --> 00:42:10.230
Like we showed less
images on screen

00:42:10.230 --> 00:42:13.040
depending on your
not only device size,

00:42:13.040 --> 00:42:14.550
but your year class.

00:42:14.550 --> 00:42:19.880
There's some devices that
have big screens and very

00:42:19.880 --> 00:42:20.470
little RAM.

00:42:20.470 --> 00:42:24.346
It is really annoying.

00:42:24.346 --> 00:42:27.240
If these devices don't
have a lot of disk space,

00:42:27.240 --> 00:42:30.320
we reduced the cache.

00:42:30.320 --> 00:42:32.680
If an animation we
think is really cool

00:42:32.680 --> 00:42:34.270
does not perform
well, we can just

00:42:34.270 --> 00:42:36.450
turn it off on certain devices.

00:42:36.450 --> 00:42:38.370
It's like oh, you're class 2010.

00:42:38.370 --> 00:42:40.860
There's no point in making
the user sit and watch

00:42:40.860 --> 00:42:41.860
a stuttering animation.

00:42:41.860 --> 00:42:44.379
We just turn it off
and show the screen.

00:42:44.379 --> 00:42:46.670
And then we can optimize for
the current network, which

00:42:46.670 --> 00:42:48.400
is some of the
most powerful stuff

00:42:48.400 --> 00:42:49.630
that we've been able to do.

00:42:49.630 --> 00:42:53.100
So examples being like having
fewer or more concurrent

00:42:53.100 --> 00:42:55.356
connections when
you're on Wi-Fi,

00:42:55.356 --> 00:42:56.980
make all the requests
at the same time.

00:42:56.980 --> 00:42:58.340
It doesn't matter.

00:42:58.340 --> 00:43:01.710
If you're on 2G, make
one request at a time.

00:43:01.710 --> 00:43:05.740
If you're on 2G, download
an image resolution

00:43:05.740 --> 00:43:08.830
that will load in an
appropriate amount of time.

00:43:08.830 --> 00:43:12.320
Even though it should
be 500 by 400 pixels,

00:43:12.320 --> 00:43:15.190
if that's going to take
you 30 seconds to download,

00:43:15.190 --> 00:43:17.940
no one's going to wait there
30 seconds for this image

00:43:17.940 --> 00:43:18.720
to download.

00:43:18.720 --> 00:43:22.180
Download a lower res
version to at least show

00:43:22.180 --> 00:43:24.820
the user in five, 10 seconds.

00:43:24.820 --> 00:43:27.250
And then I mentioned
chunking before.

00:43:27.250 --> 00:43:29.070
You can change the chunk sizes.

00:43:29.070 --> 00:43:32.400
And then when to prefetch,
don't prefetch on fast networks.

00:43:32.400 --> 00:43:35.120
Prefetch more on slow
networks, et cetera.

00:43:39.456 --> 00:43:40.580
So experimentation is good.

00:43:40.580 --> 00:43:43.530
Once you have all these
parameters, step number two.

00:43:48.160 --> 00:43:49.690
It's harder for
smaller companies.

00:43:49.690 --> 00:43:51.440
But you can start out small.

00:43:51.440 --> 00:43:53.087
Essentially start
running A/B tests

00:43:53.087 --> 00:43:54.170
with different parameters.

00:43:54.170 --> 00:43:56.420
Don't assume you
know as a developer,

00:43:56.420 --> 00:43:58.180
I know this is how
or user should use.

00:43:58.180 --> 00:43:59.820
You're not Steve Jobs.

00:43:59.820 --> 00:44:03.960
You need to make sure your
app works for the scenarios

00:44:03.960 --> 00:44:06.250
that your users
are actually using.

00:44:06.250 --> 00:44:08.372
So when you're
looking at this data,

00:44:08.372 --> 00:44:09.580
don't settle for the average.

00:44:09.580 --> 00:44:12.590
Make sure you use the analytics
available to you, year, class,

00:44:12.590 --> 00:44:14.770
connection class, country,
to really make sure

00:44:14.770 --> 00:44:17.010
that you're not hurting
a certain segment

00:44:17.010 --> 00:44:18.140
of the population.

00:44:18.140 --> 00:44:19.510
It might be, on average, good.

00:44:19.510 --> 00:44:21.530
But it might hurt
a small segment

00:44:21.530 --> 00:44:24.200
of the population really bad.

00:44:24.200 --> 00:44:26.720
We found, for example,
out of memory errors

00:44:26.720 --> 00:44:29.190
for one feature was
really bad on one thing,

00:44:29.190 --> 00:44:31.400
even though for overall
it increased engagement.

00:44:31.400 --> 00:44:33.890
And things like that
for other people.

00:44:33.890 --> 00:44:37.420
And then once you've done
that, you're not done.

00:44:37.420 --> 00:44:39.330
You're never done,
especially if you

00:44:39.330 --> 00:44:41.590
have an app that has
a long life cycle

00:44:41.590 --> 00:44:43.480
and is living over
several years.

00:44:43.480 --> 00:44:46.720
The people who are using your
app will change over time.

00:44:46.720 --> 00:44:48.580
There will be early
adopters first,

00:44:48.580 --> 00:44:51.040
and then there will be
like grandmas later.

00:44:51.040 --> 00:44:53.680
They use the app different ways.

00:44:53.680 --> 00:44:55.050
They have different patterns.

00:44:55.050 --> 00:44:57.610
You have to make sure
that what was true

00:44:57.610 --> 00:44:58.880
a year ago is still true now.

00:45:01.214 --> 00:45:03.630
ALEX SOUROV: And I'll tell
here is a tale of MobileConfig,

00:45:03.630 --> 00:45:05.130
which is basically
our configuration

00:45:05.130 --> 00:45:07.220
system for doing these things.

00:45:07.220 --> 00:45:10.417
The key part of the system
is where actually we

00:45:10.417 --> 00:45:12.750
want to push a lot of those
parameters from, the server.

00:45:12.750 --> 00:45:14.740
So we can quickly adjust them
or use the power of the server

00:45:14.740 --> 00:45:17.240
to do analysis and decide,
hey, for this type of users,

00:45:17.240 --> 00:45:18.492
this is the best value.

00:45:18.492 --> 00:45:19.950
And so that's
precisely what we do.

00:45:19.950 --> 00:45:21.908
So different users can
get different parameters

00:45:21.908 --> 00:45:22.842
and different values.

00:45:22.842 --> 00:45:24.466
So the behavior of
that app, especially

00:45:24.466 --> 00:45:27.200
on the infrastructure side,
adjusts to what we think

00:45:27.200 --> 00:45:30.710
is best for them based
on experimentation.

00:45:30.710 --> 00:45:32.840
That system allows
us to experiment

00:45:32.840 --> 00:45:34.050
on things in any time.

00:45:34.050 --> 00:45:37.489
So even if we are pretty
sure that this is the best

00:45:37.489 --> 00:45:39.030
configuration
parameter, it might not

00:45:39.030 --> 00:45:41.238
be the best configuration
parameter six months later.

00:45:41.238 --> 00:45:42.880
So we can repeat
this and do it again.

00:45:42.880 --> 00:45:45.351
In the meantime, start with
just a [INAUDIBLE] constants.

00:45:45.351 --> 00:45:47.350
From the client perspective,
it's just something

00:45:47.350 --> 00:45:48.892
comes from the sky.

00:45:48.892 --> 00:45:50.110
And they just use that.

00:45:50.110 --> 00:45:53.220
How it's actually
send is not relevant.

00:45:53.220 --> 00:45:55.860
And one tricky thing about
this, in mobile world,

00:45:55.860 --> 00:45:58.960
especially on Android, people
don't upgrade very quickly.

00:45:58.960 --> 00:46:01.300
You still have a lot of
old versions out there.

00:46:01.300 --> 00:46:03.600
And you have to
sort of owner that.

00:46:03.600 --> 00:46:05.620
So if you ever build
a system like that,

00:46:05.620 --> 00:46:08.400
you have to worry about
versioning and making sure

00:46:08.400 --> 00:46:09.990
that you can deal with that.

00:46:09.990 --> 00:46:13.190
There are many different
ways to deal with that.

00:46:13.190 --> 00:46:17.090
But that's one of the
problems you have to solve.

00:46:17.090 --> 00:46:19.270
And then sort of going
beyond A/B testing,

00:46:19.270 --> 00:46:20.190
I want to talk about
Facebook Bandit.

00:46:20.190 --> 00:46:22.189
It certainly on the high
end of what you can do,

00:46:22.189 --> 00:46:23.530
but it's pretty exciting for us.

00:46:23.530 --> 00:46:24.738
So we wanted to mention that.

00:46:27.161 --> 00:46:29.410
It's built by Facebook
research, so a lot of the stuff

00:46:29.410 --> 00:46:31.560
is pretty complex.

00:46:31.560 --> 00:46:34.130
So we just want to talk about
sort of the basic things

00:46:34.130 --> 00:46:35.310
involved in the system.

00:46:35.310 --> 00:46:37.640
It's an advanced
experimentation framework.

00:46:37.640 --> 00:46:39.050
It's common in the industry.

00:46:39.050 --> 00:46:40.906
It's called multi-armed bandit.

00:46:40.906 --> 00:46:42.530
That happens to be
the Facebook version

00:46:42.530 --> 00:46:43.571
of that, Facebook Bandit.

00:46:43.571 --> 00:46:45.790
What it allows you to
do is to experiment

00:46:45.790 --> 00:46:47.560
with a large number
of configurations.

00:46:47.560 --> 00:46:51.145
And it very quickly
decides how to narrow down

00:46:51.145 --> 00:46:53.770
to just the configurations which
are likely to produce the best

00:46:53.770 --> 00:46:54.270
results.

00:46:54.270 --> 00:46:57.880
It also very quickly decides
how to throw out configurations

00:46:57.880 --> 00:47:00.370
which are producing results
which are worse than the status

00:47:00.370 --> 00:47:04.480
quo, which is important, because
you don't want have experiments

00:47:04.480 --> 00:47:07.020
out there which actually
degrade user experience.

00:47:07.020 --> 00:47:10.110
So that system helps us
to get there quickly.

00:47:10.110 --> 00:47:12.599
And it allows us to optimize
for competing variables.

00:47:12.599 --> 00:47:14.140
Quite often for
those configurations,

00:47:14.140 --> 00:47:16.870
you are not just thinking
about one variable.

00:47:16.870 --> 00:47:19.050
A great example
here is data usage.

00:47:19.050 --> 00:47:21.610
You do data usage so
your performance improves

00:47:21.610 --> 00:47:23.810
and users spend more
time working with the app

00:47:23.810 --> 00:47:25.310
than they do looking
at the spinner.

00:47:25.310 --> 00:47:28.231
But data usage itself is of
course one of the parameters,

00:47:28.231 --> 00:47:30.230
and you don't want to
drive that value too high.

00:47:34.190 --> 00:47:36.400
And the story here
is the story of how

00:47:36.400 --> 00:47:38.640
we did the prefetching
while scrolling.

00:47:38.640 --> 00:47:40.730
So as we scroll
through the News Feed,

00:47:40.730 --> 00:47:42.490
we prefetch stories
ahead of time

00:47:42.490 --> 00:47:44.980
because we don't want you to
hit that moment where you're

00:47:44.980 --> 00:47:47.800
sort of visibly
looking at the spinner

00:47:47.800 --> 00:47:50.354
while we're trying to get
the next set of stories.

00:47:50.354 --> 00:47:52.020
And originally when
we did this, we just

00:47:52.020 --> 00:47:55.150
said, well, we'll just A/B
test, look at a few values.

00:47:55.150 --> 00:47:57.620
And we find out that
generally, worldwide,

00:47:57.620 --> 00:48:00.400
10 is a fantastic number.

00:48:00.400 --> 00:48:01.990
It could be the best number.

00:48:01.990 --> 00:48:04.370
And we just prefetch
10 stories ahead.

00:48:04.370 --> 00:48:06.810
When you are 10 stories
from the moment where

00:48:06.810 --> 00:48:10.226
we don't have anymore stories,
we will go ahead and prefetch.

00:48:10.226 --> 00:48:12.100
And then when the bandit
came onto the scene,

00:48:12.100 --> 00:48:15.560
we decided that we're going
to run this for the bandit.

00:48:15.560 --> 00:48:18.719
So we can figure out
the best configurations

00:48:18.719 --> 00:48:20.260
for different networks
in particular,

00:48:20.260 --> 00:48:22.110
because we had this hunch that
from the different networks,

00:48:22.110 --> 00:48:23.485
we might get
something different.

00:48:27.550 --> 00:48:30.196
Bandit actually went for 27
different configurations.

00:48:30.196 --> 00:48:31.820
A configuration is
something like that,

00:48:31.820 --> 00:48:33.924
like all metrics over
here, different number

00:48:33.924 --> 00:48:35.340
of stories that
you prefetch ahead

00:48:35.340 --> 00:48:37.846
for on different connections.

00:48:37.846 --> 00:48:39.220
And first, they're
sort of random

00:48:39.220 --> 00:48:40.761
and look at what
the usage would look

00:48:40.761 --> 00:48:42.990
like from different
configurations.

00:48:42.990 --> 00:48:44.490
But the real
interesting thing here

00:48:44.490 --> 00:48:46.156
is optimization for
multiple parameters.

00:48:46.156 --> 00:48:47.910
Because yeah, you
can reduce data usage

00:48:47.910 --> 00:48:51.090
by doing fewer than 10, but you
want to do that in such a way

00:48:51.090 --> 00:48:53.290
that users don't end up
looking at that spinner,

00:48:53.290 --> 00:48:55.540
because the entire work
is there to make sure

00:48:55.540 --> 00:48:59.060
that you can actually
get to the stories

00:48:59.060 --> 00:49:00.230
before user gets to them.

00:49:00.230 --> 00:49:01.972
And so their
engagement continues

00:49:01.972 --> 00:49:03.430
to be high because
they're engaging

00:49:03.430 --> 00:49:06.360
with the app instead of waiting
for the stories to load.

00:49:06.360 --> 00:49:09.750
And so when you actually map
these 27 different cases,

00:49:09.750 --> 00:49:12.580
you see this pattern which,
pareto frontier is just

00:49:12.580 --> 00:49:16.640
a fancy word of saying for all
the other configurations here,

00:49:16.640 --> 00:49:18.407
there is a better
configuration where

00:49:18.407 --> 00:49:20.740
you can improve on one axis
without sacrificing anything

00:49:20.740 --> 00:49:22.050
on the other.

00:49:22.050 --> 00:49:24.480
And so the tool helps
us to figure this out.

00:49:24.480 --> 00:49:27.021
And actually it turns out that
there are those four different

00:49:27.021 --> 00:49:29.252
values out of these
27 that are like that,

00:49:29.252 --> 00:49:31.585
which cannot be improved any
further on one of the other

00:49:31.585 --> 00:49:32.490
axes.

00:49:32.490 --> 00:49:33.710
Two of them are extreme.

00:49:33.710 --> 00:49:35.920
You can obviously run
with no data usage.

00:49:35.920 --> 00:49:38.229
But then you're not going
to get much out of this.

00:49:38.229 --> 00:49:40.270
Or you could just say,
you're going to get a lot.

00:49:40.270 --> 00:49:43.254
But data usage is
we still a concern

00:49:43.254 --> 00:49:44.420
and you have to worry about.

00:49:44.420 --> 00:49:46.050
And then you are just
down to two values.

00:49:46.050 --> 00:49:47.925
And then you can A/B
test on these two values

00:49:47.925 --> 00:49:50.296
and figure out what
the best value is.

00:49:50.296 --> 00:49:52.170
And I'll let Alex finish
on that because that

00:49:52.170 --> 00:49:55.099
was one of his projects.

00:49:55.099 --> 00:49:55.890
ALEX PETRESCU: Yes.

00:49:55.890 --> 00:49:57.400
So we start off with 10.

00:49:57.400 --> 00:49:58.790
That seemed like a good number.

00:49:58.790 --> 00:50:01.810
We tested out 27
different configurations.

00:50:01.810 --> 00:50:05.080
And what we found is that 10 was
actually a pretty good number.

00:50:05.080 --> 00:50:09.230
We did a pretty decent job
for certain types of users.

00:50:09.230 --> 00:50:11.050
And it didn't hurt anyone else.

00:50:11.050 --> 00:50:13.450
But, we could actually
optimize, when

00:50:13.450 --> 00:50:15.710
you're on good and
excellent networks,

00:50:15.710 --> 00:50:17.670
to prefetch less aggressively.

00:50:17.670 --> 00:50:20.480
So this actually reduced
data usage for these people

00:50:20.480 --> 00:50:23.780
dramatically, because now they
didn't essentially download

00:50:23.780 --> 00:50:25.300
things they didn't need.

00:50:25.300 --> 00:50:27.250
And also decreased server CPU.

00:50:27.250 --> 00:50:32.650
We saw like, what is it,
57% of users were on Wi-Fi.

00:50:32.650 --> 00:50:38.910
So 57% of users used to, or
some percentage of that 57%

00:50:38.910 --> 00:50:41.080
used to prefetch relatively
aggressively when

00:50:41.080 --> 00:50:42.060
they didn't need to.

00:50:42.060 --> 00:50:44.880
So we were able to
drastically reduce

00:50:44.880 --> 00:50:48.820
server CPU, which costs
money, without actually

00:50:48.820 --> 00:50:49.970
hurting engagement.

00:50:49.970 --> 00:50:51.700
No one saw anymore spinners.

00:50:51.700 --> 00:50:53.520
Probably no one noticed.

00:50:53.520 --> 00:50:56.520
So then we just now
have one set of values.

00:50:56.520 --> 00:50:59.390
But we do it instead
of 10, we now

00:50:59.390 --> 00:51:01.330
do it based on connection class.

00:51:01.330 --> 00:51:04.890
So you can see we actually
have a JSON configuration

00:51:04.890 --> 00:51:06.510
object that looks exactly that.

00:51:06.510 --> 00:51:09.150
We say when you're on
excellent, use three.

00:51:09.150 --> 00:51:10.642
When you're on good, use five.

00:51:10.642 --> 00:51:11.850
And these will change, right?

00:51:11.850 --> 00:51:13.683
You might be on an
excellent connection now.

00:51:13.683 --> 00:51:16.000
And you turn off Wi-Fi, and
you go walk out the door.

00:51:16.000 --> 00:51:17.830
And now you need to
do another fetch.

00:51:17.830 --> 00:51:19.680
Now you get the value 10.

00:51:19.680 --> 00:51:25.900
So these values can change
over the lifetime of the app.

00:51:25.900 --> 00:51:27.240
And that's it.

00:51:27.240 --> 00:51:28.239
That was a lot.

00:51:28.239 --> 00:51:29.780
ALEX SOUROV: That's
our presentation.

00:51:29.780 --> 00:51:31.840
So thanks very much for coming.

00:51:31.840 --> 00:51:34.540
[APPLAUSE]

00:51:34.540 --> 00:51:38.190
[MUSIC PLAYING]

